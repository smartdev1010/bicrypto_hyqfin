/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./node_modules/arrayslicer/lib/compare/index.js":
/*!*******************************************************!*\
  !*** ./node_modules/arrayslicer/lib/compare/index.js ***!
  \*******************************************************/
/***/ ((module) => {

/**
 * Utility compare functions
 */

module.exports = {

    /**
     * Compare two numbers.
     *
     * @param {Number} a
     * @param {Number} b
     * @returns {Number} 1 if a > b, 0 if a = b, -1 if a < b
     */
    numcmp: function (a, b) {
        return a - b;
    },

    /**
     * Compare two strings.
     *
     * @param {Number|String} a
     * @param {Number|String} b
     * @returns {Number} 1 if a > b, 0 if a = b, -1 if a < b
     */
    strcmp: function (a, b) {
        return a < b ? -1 : a > b ? 1 : 0;
    }

};


/***/ }),

/***/ "./node_modules/arrayslicer/lib/index.js":
/*!***********************************************!*\
  !*** ./node_modules/arrayslicer/lib/index.js ***!
  \***********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/**
 * Indexed Array Binary Search module
 */

/**
 * Dependencies
 */
var util = __webpack_require__(/*! ./util */ "./node_modules/arrayslicer/lib/util.js"),
    cmp = __webpack_require__(/*! ./compare */ "./node_modules/arrayslicer/lib/compare/index.js"),
    bin = __webpack_require__(/*! ./search/binary */ "./node_modules/arrayslicer/lib/search/binary.js");

/**
 * Module interface definition
 */
module.exports = IndexedArray;

/**
 * Indexed Array constructor
 *
 * It loads the array data, defines the index field and the comparison function
 * to be used.
 *
 * @param {Array} data is an array of objects
 * @param {String} index is the object's property used to search the array
 */
function IndexedArray(data, index) {

    // is data sortable array or array-like object?
    if (!util.isSortableArrayLike(data))
        throw new Error("Invalid data");

    // is index a valid property?
    if (!index || data.length > 0 && !(index in data[0]))
        throw new Error("Invalid index");

    // data array
    this.data = data;

    // name of the index property
    this.index = index;

    // set index boundary values
    this.setBoundaries();

    // default comparison function
    this.compare = typeof this.minv === "number" ? cmp.numcmp : cmp.strcmp;

    // default search function
    this.search = bin.search;

    // cache of index values to array positions
    // each value stores an object as { found: true|false, index: array-index }
    this.valpos = {};

    // cursor and adjacent positions
    this.cursor = null;
    this.nextlow = null;
    this.nexthigh = null;
}

/**
 * Set the comparison function
 *
 * @param {Function} fn to compare index values that returnes 1, 0, -1
 */
IndexedArray.prototype.setCompare = function (fn) {
    if (typeof fn !== "function")
        throw new Error("Invalid argument");

    this.compare = fn;
    return this;
};

/**
 * Set the search function
 *
 * @param {Function} fn to search index values in the array of objects
 */
IndexedArray.prototype.setSearch = function (fn) {
    if (typeof fn !== "function")
        throw new Error("Invalid argument");

    this.search = fn;
    return this;
};

/**
 * Sort the data array by its index property
 */
IndexedArray.prototype.sort = function () {
    var self = this,
        index = this.index;

    // sort the array
    this.data.sort(function (a, b) {
        return self.compare(a[index], b[index]);
    });

    // recalculate boundary values
    this.setBoundaries();

    return this;
};

/**
 * Inspect and set the boundaries of the internal data array
 */
IndexedArray.prototype.setBoundaries = function () {
    var data = this.data,
        index = this.index;

    this.minv = data.length && data[0][index];
    this.maxv = data.length && data[data.length - 1][index];

    return this;
};

/**
 * Get the position of the object corresponding to the given index
 *
 * @param {Number|String} index is the id of the requested object
 * @returns {Number} the position of the object in the array
 */
IndexedArray.prototype.fetch = function (value) {
    // check data has objects
    if (this.data.length === 0) {
        this.cursor = null;
        this.nextlow = null;
        this.nexthigh = null;
        return this;
    }

    // check the request is within range
    if (this.compare(value, this.minv) === -1) {
        this.cursor = null;
        this.nextlow = null;
        this.nexthigh = 0;
        return this;
    }
    if (this.compare(value, this.maxv) === 1) {
        this.cursor = null;
        this.nextlow = this.data.length - 1;
        this.nexthigh = null;
        return this;
    }

    var valpos = this.valpos,
        pos = valpos[value];

    // if the request is memorized, just give it back
    if (pos) {
        if (pos.found) {
            this.cursor = pos.index;
            this.nextlow = null;
            this.nexthigh = null;
        } else {
            this.cursor = null;
            this.nextlow = pos.prev;
            this.nexthigh = pos.next;
        }
        return this;
    }

    // if not, do the search
    var result = this.search.call(this, value);
    this.cursor = result.index;
    this.nextlow = result.prev;
    this.nexthigh = result.next;
    return this;
};

/**
 * Get the object corresponding to the given index
 *
 * When no value is given, the function will default to the last fetched item.
 *
 * @param {Number|String} [optional] index is the id of the requested object
 * @returns {Object} the found object or null
 */
IndexedArray.prototype.get = function (value) {
    if (value)
        this.fetch(value);

    var pos = this.cursor;
    return pos !== null ? this.data[pos] : null;
};

/**
 * Get an slice of the data array
 *
 * Boundaries have to be in order.
 *
 * @param {Number|String} begin index is the id of the requested object
 * @param {Number|String} end index is the id of the requested object
 * @returns {Object} the slice of data array or []
 */
IndexedArray.prototype.getRange = function (begin, end) {
    // check if boundaries are in order
    if (this.compare(begin, end) === 1) {
        return [];
    }

    // fetch start and default to the next index above
    this.fetch(begin);
    var start = this.cursor || this.nexthigh;

    // fetch finish and default to the next index below
    this.fetch(end);
    var finish = this.cursor || this.nextlow;

    // if any boundary is not set, return no range
    if (start === null || finish === null) {
        return [];
    }

    // return range
    return this.data.slice(start, finish + 1);
};


/***/ }),

/***/ "./node_modules/arrayslicer/lib/search/binary.js":
/*!*******************************************************!*\
  !*** ./node_modules/arrayslicer/lib/search/binary.js ***!
  \*******************************************************/
/***/ ((module) => {

/**
 * Binary search implementation
 */

/**
 * Main search recursive function
 */
function loop(data, min, max, index, valpos) {

    // set current position as the middle point between min and max
    var curr = (max + min) >>> 1;

    // compare current index value with the one we are looking for
    var diff = this.compare(data[curr][this.index], index);

    // found?
    if (!diff) {
        return valpos[index] = {
            "found": true,
            "index": curr,
            "prev": null,
            "next": null
        };
    }

    // no more positions available?
    if (min >= max) {
        return valpos[index] = {
            "found": false,
            "index": null,
            "prev": (diff < 0) ? max : max - 1,
            "next": (diff < 0) ? max + 1 : max
        };
    }

    // continue looking for index in one of the remaining array halves
    // current position can be skept as index is not there...
    if (diff > 0)
        return loop.call(this, data, min, curr - 1, index, valpos);
    else
        return loop.call(this, data, curr + 1, max, index, valpos);
}

/**
 * Search bootstrap
 * The function has to be executed in the context of the IndexedArray object
 */
function search(index) {
    var data = this.data;
    return loop.call(this, data, 0, data.length - 1, index, this.valpos);
}

/**
 * Export search function
 */
module.exports.search = search;


/***/ }),

/***/ "./node_modules/arrayslicer/lib/util.js":
/*!**********************************************!*\
  !*** ./node_modules/arrayslicer/lib/util.js ***!
  \**********************************************/
/***/ ((module) => {

/**
 * Utils module
 */

/**
 * Check if an object is an array-like object
 *
 * @credit Javascript: The Definitive Guide, O'Reilly, 2011
 */
function isArrayLike(o) {
    if (o &&                                 // o is not null, undefined, etc.
        typeof o === "object" &&             // o is an object
        isFinite(o.length) &&                // o.length is a finite number
        o.length >= 0 &&                     // o.length is non-negative
        o.length === Math.floor(o.length) && // o.length is an integer
        o.length < 4294967296)               // o.length < 2^32
        return true;                         // Then o is array-like
    else
        return false;                        // Otherwise it is not
}

/**
 * Check for the existence of the sort function in the object
 */
function isSortable(o) {
    if (o &&                                 // o is not null, undefined, etc.
        typeof o === "object" &&             // o is an object
        typeof o.sort === "function")        // o.sort is a function
        return true;                         // Then o is array-like
    else
        return false;                        // Otherwise it is not
}

/**
 * Check for sortable-array-like objects
 */
module.exports.isSortableArrayLike = function (o) {
    return isArrayLike(o) && isSortable(o);
};


/***/ }),

/***/ "./build/chart-link/chart-link-dev.js":
/*!********************************************!*\
  !*** ./build/chart-link/chart-link-dev.js ***!
  \********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Main": () => (/* reexport safe */ _src_extensions_chart_link_main_js__WEBPACK_IMPORTED_MODULE_0__["default"]),
/* harmony export */   "colorpacks": () => (/* binding */ colorpacks),
/* harmony export */   "components": () => (/* binding */ components),
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   "overlays": () => (/* binding */ overlays),
/* harmony export */   "skins": () => (/* binding */ skins),
/* harmony export */   "widgets": () => (/* binding */ widgets)
/* harmony export */ });
/* harmony import */ var _src_extensions_chart_link_main_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../src/extensions/chart-link/main.js */ "./src/extensions/chart-link/main.js");
// -------- Development extension index ---------
//      ! THIS FILE WAS AUTO-GENERATED !
//
// You can overwrite it and have fun, to restore
// the default state: 'npm run compile'

_src_extensions_chart_link_main_js__WEBPACK_IMPORTED_MODULE_0__["default"].__name__ = 'chart-link';
var widgets = {};
var components = {};
var overlays = {};
var colorpacks = {};
var skins = {};
var Pack = {
  widgets: widgets,
  components: components,
  overlays: overlays,
  colorpacks: colorpacks,
  skins: skins,
  Main: _src_extensions_chart_link_main_js__WEBPACK_IMPORTED_MODULE_0__["default"]
};
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Pack);


/***/ }),

/***/ "./build/grid-resize/grid-resize-dev.js":
/*!**********************************************!*\
  !*** ./build/grid-resize/grid-resize-dev.js ***!
  \**********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Main": () => (/* reexport safe */ _src_extensions_grid_resize_main_js__WEBPACK_IMPORTED_MODULE_0__["default"]),
/* harmony export */   "colorpacks": () => (/* binding */ colorpacks),
/* harmony export */   "components": () => (/* binding */ components),
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   "overlays": () => (/* binding */ overlays),
/* harmony export */   "skins": () => (/* binding */ skins),
/* harmony export */   "widgets": () => (/* binding */ widgets)
/* harmony export */ });
/* harmony import */ var _src_extensions_grid_resize_main_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../src/extensions/grid-resize/main.js */ "./src/extensions/grid-resize/main.js");
// -------- Development extension index ---------
//      ! THIS FILE WAS AUTO-GENERATED !
//
// You can overwrite it and have fun, to restore
// the default state: 'npm run compile'

_src_extensions_grid_resize_main_js__WEBPACK_IMPORTED_MODULE_0__["default"].__name__ = 'grid-resize';
var widgets = {};
var components = {};
var overlays = {};
var colorpacks = {};
var skins = {};
var Pack = {
  widgets: widgets,
  components: components,
  overlays: overlays,
  colorpacks: colorpacks,
  skins: skins,
  Main: _src_extensions_grid_resize_main_js__WEBPACK_IMPORTED_MODULE_0__["default"]
};
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Pack);


/***/ }),

/***/ "./build/legend-buttons/legend-buttons-dev.js":
/*!****************************************************!*\
  !*** ./build/legend-buttons/legend-buttons-dev.js ***!
  \****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Main": () => (/* reexport safe */ _src_extensions_legend_buttons_main_js__WEBPACK_IMPORTED_MODULE_0__["default"]),
/* harmony export */   "colorpacks": () => (/* binding */ colorpacks),
/* harmony export */   "components": () => (/* binding */ components),
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   "overlays": () => (/* binding */ overlays),
/* harmony export */   "skins": () => (/* binding */ skins),
/* harmony export */   "widgets": () => (/* binding */ widgets)
/* harmony export */ });
/* harmony import */ var _src_extensions_legend_buttons_main_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../src/extensions/legend-buttons/main.js */ "./src/extensions/legend-buttons/main.js");
// -------- Development extension index ---------
//      ! THIS FILE WAS AUTO-GENERATED !
//
// You can overwrite it and have fun, to restore
// the default state: 'npm run compile'

_src_extensions_legend_buttons_main_js__WEBPACK_IMPORTED_MODULE_0__["default"].__name__ = 'legend-buttons';
var widgets = {};
var components = {};
var overlays = {};
var colorpacks = {};
var skins = {};
var Pack = {
  widgets: widgets,
  components: components,
  overlays: overlays,
  colorpacks: colorpacks,
  skins: skins,
  Main: _src_extensions_legend_buttons_main_js__WEBPACK_IMPORTED_MODULE_0__["default"]
};
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Pack);


/***/ }),

/***/ "./build/settings-win/settings-win-dev.js":
/*!************************************************!*\
  !*** ./build/settings-win/settings-win-dev.js ***!
  \************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Main": () => (/* reexport safe */ _src_extensions_settings_win_main_js__WEBPACK_IMPORTED_MODULE_1__["default"]),
/* harmony export */   "SettingsWin": () => (/* reexport safe */ _src_extensions_settings_win_SettingsWin_vue__WEBPACK_IMPORTED_MODULE_0__["default"]),
/* harmony export */   "colorpacks": () => (/* binding */ colorpacks),
/* harmony export */   "components": () => (/* binding */ components),
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   "overlays": () => (/* binding */ overlays),
/* harmony export */   "skins": () => (/* binding */ skins),
/* harmony export */   "widgets": () => (/* binding */ widgets)
/* harmony export */ });
/* harmony import */ var _src_extensions_settings_win_SettingsWin_vue__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../src/extensions/settings-win/SettingsWin.vue */ "./src/extensions/settings-win/SettingsWin.vue");
/* harmony import */ var _src_extensions_settings_win_main_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../src/extensions/settings-win/main.js */ "./src/extensions/settings-win/main.js");
// -------- Development extension index ---------
//      ! THIS FILE WAS AUTO-GENERATED !
//
// You can overwrite it and have fun, to restore
// the default state: 'npm run compile'


_src_extensions_settings_win_main_js__WEBPACK_IMPORTED_MODULE_1__["default"].__name__ = 'settings-win';
var widgets = {
  SettingsWin: _src_extensions_settings_win_SettingsWin_vue__WEBPACK_IMPORTED_MODULE_0__["default"]
};
var components = {};
var overlays = {};
var colorpacks = {};
var skins = {};
var Pack = {
  widgets: widgets,
  SettingsWin: _src_extensions_settings_win_SettingsWin_vue__WEBPACK_IMPORTED_MODULE_0__["default"],
  components: components,
  overlays: overlays,
  colorpacks: colorpacks,
  skins: skins,
  Main: _src_extensions_settings_win_main_js__WEBPACK_IMPORTED_MODULE_1__["default"]
};
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Pack);


/***/ }),

/***/ "./node_modules/babel-loader/lib/index.js??clonedRuleSet-5[0].rules[0].use[0]!./node_modules/vue-loader/lib/index.js??vue-loader-options!./src/Main.vue?vue&type=script&lang=js&":
/*!***************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/babel-loader/lib/index.js??clonedRuleSet-5[0].rules[0].use[0]!./node_modules/vue-loader/lib/index.js??vue-loader-options!./src/Main.vue?vue&type=script&lang=js& ***!
  \***************************************************************************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var trading_vue_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! trading-vue-js */ "./node_modules/trading-vue-js/dist/trading-vue.js");
/* harmony import */ var trading_vue_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(trading_vue_js__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var tvjs_overlays__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! tvjs-overlays */ "./node_modules/tvjs-overlays/dist/tvjs-overlays.js");
/* harmony import */ var tvjs_overlays__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(tvjs_overlays__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _resources_data_data_json__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../resources/data/data.json */ "./resources/data/data.json");
/* harmony import */ var _stuff_utils_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./stuff/utils.js */ "./src/stuff/utils.js");
/* harmony import */ var _stuff_constants_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./stuff/constants.js */ "./src/stuff/constants.js");
/* harmony import */ var _stream_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./stream.js */ "./src/stream.js");
/* harmony import */ var _index_dev__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./index_dev */ "./src/index_dev.js");
/* harmony import */ var raw_loader_resources_assets_cors_txt__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! raw-loader!../resources/assets/cors.txt */ "./node_modules/raw-loader/dist/cjs.js!./resources/assets/cors.txt");
function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }

function _regeneratorRuntime() { "use strict"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ _regeneratorRuntime = function _regeneratorRuntime() { return exports; }; var exports = {}, Op = Object.prototype, hasOwn = Op.hasOwnProperty, $Symbol = "function" == typeof Symbol ? Symbol : {}, iteratorSymbol = $Symbol.iterator || "@@iterator", asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator", toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag"; function define(obj, key, value) { return Object.defineProperty(obj, key, { value: value, enumerable: !0, configurable: !0, writable: !0 }), obj[key]; } try { define({}, ""); } catch (err) { define = function define(obj, key, value) { return obj[key] = value; }; } function wrap(innerFn, outerFn, self, tryLocsList) { var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator, generator = Object.create(protoGenerator.prototype), context = new Context(tryLocsList || []); return generator._invoke = function (innerFn, self, context) { var state = "suspendedStart"; return function (method, arg) { if ("executing" === state) throw new Error("Generator is already running"); if ("completed" === state) { if ("throw" === method) throw arg; return doneResult(); } for (context.method = method, context.arg = arg;;) { var delegate = context.delegate; if (delegate) { var delegateResult = maybeInvokeDelegate(delegate, context); if (delegateResult) { if (delegateResult === ContinueSentinel) continue; return delegateResult; } } if ("next" === context.method) context.sent = context._sent = context.arg;else if ("throw" === context.method) { if ("suspendedStart" === state) throw state = "completed", context.arg; context.dispatchException(context.arg); } else "return" === context.method && context.abrupt("return", context.arg); state = "executing"; var record = tryCatch(innerFn, self, context); if ("normal" === record.type) { if (state = context.done ? "completed" : "suspendedYield", record.arg === ContinueSentinel) continue; return { value: record.arg, done: context.done }; } "throw" === record.type && (state = "completed", context.method = "throw", context.arg = record.arg); } }; }(innerFn, self, context), generator; } function tryCatch(fn, obj, arg) { try { return { type: "normal", arg: fn.call(obj, arg) }; } catch (err) { return { type: "throw", arg: err }; } } exports.wrap = wrap; var ContinueSentinel = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var IteratorPrototype = {}; define(IteratorPrototype, iteratorSymbol, function () { return this; }); var getProto = Object.getPrototypeOf, NativeIteratorPrototype = getProto && getProto(getProto(values([]))); NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol) && (IteratorPrototype = NativeIteratorPrototype); var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype); function defineIteratorMethods(prototype) { ["next", "throw", "return"].forEach(function (method) { define(prototype, method, function (arg) { return this._invoke(method, arg); }); }); } function AsyncIterator(generator, PromiseImpl) { function invoke(method, arg, resolve, reject) { var record = tryCatch(generator[method], generator, arg); if ("throw" !== record.type) { var result = record.arg, value = result.value; return value && "object" == _typeof(value) && hasOwn.call(value, "__await") ? PromiseImpl.resolve(value.__await).then(function (value) { invoke("next", value, resolve, reject); }, function (err) { invoke("throw", err, resolve, reject); }) : PromiseImpl.resolve(value).then(function (unwrapped) { result.value = unwrapped, resolve(result); }, function (error) { return invoke("throw", error, resolve, reject); }); } reject(record.arg); } var previousPromise; this._invoke = function (method, arg) { function callInvokeWithMethodAndArg() { return new PromiseImpl(function (resolve, reject) { invoke(method, arg, resolve, reject); }); } return previousPromise = previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); }; } function maybeInvokeDelegate(delegate, context) { var method = delegate.iterator[context.method]; if (undefined === method) { if (context.delegate = null, "throw" === context.method) { if (delegate.iterator["return"] && (context.method = "return", context.arg = undefined, maybeInvokeDelegate(delegate, context), "throw" === context.method)) return ContinueSentinel; context.method = "throw", context.arg = new TypeError("The iterator does not provide a 'throw' method"); } return ContinueSentinel; } var record = tryCatch(method, delegate.iterator, context.arg); if ("throw" === record.type) return context.method = "throw", context.arg = record.arg, context.delegate = null, ContinueSentinel; var info = record.arg; return info ? info.done ? (context[delegate.resultName] = info.value, context.next = delegate.nextLoc, "return" !== context.method && (context.method = "next", context.arg = undefined), context.delegate = null, ContinueSentinel) : info : (context.method = "throw", context.arg = new TypeError("iterator result is not an object"), context.delegate = null, ContinueSentinel); } function pushTryEntry(locs) { var entry = { tryLoc: locs[0] }; 1 in locs && (entry.catchLoc = locs[1]), 2 in locs && (entry.finallyLoc = locs[2], entry.afterLoc = locs[3]), this.tryEntries.push(entry); } function resetTryEntry(entry) { var record = entry.completion || {}; record.type = "normal", delete record.arg, entry.completion = record; } function Context(tryLocsList) { this.tryEntries = [{ tryLoc: "root" }], tryLocsList.forEach(pushTryEntry, this), this.reset(!0); } function values(iterable) { if (iterable) { var iteratorMethod = iterable[iteratorSymbol]; if (iteratorMethod) return iteratorMethod.call(iterable); if ("function" == typeof iterable.next) return iterable; if (!isNaN(iterable.length)) { var i = -1, next = function next() { for (; ++i < iterable.length;) { if (hasOwn.call(iterable, i)) return next.value = iterable[i], next.done = !1, next; } return next.value = undefined, next.done = !0, next; }; return next.next = next; } } return { next: doneResult }; } function doneResult() { return { value: undefined, done: !0 }; } return GeneratorFunction.prototype = GeneratorFunctionPrototype, define(Gp, "constructor", GeneratorFunctionPrototype), define(GeneratorFunctionPrototype, "constructor", GeneratorFunction), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, toStringTagSymbol, "GeneratorFunction"), exports.isGeneratorFunction = function (genFun) { var ctor = "function" == typeof genFun && genFun.constructor; return !!ctor && (ctor === GeneratorFunction || "GeneratorFunction" === (ctor.displayName || ctor.name)); }, exports.mark = function (genFun) { return Object.setPrototypeOf ? Object.setPrototypeOf(genFun, GeneratorFunctionPrototype) : (genFun.__proto__ = GeneratorFunctionPrototype, define(genFun, toStringTagSymbol, "GeneratorFunction")), genFun.prototype = Object.create(Gp), genFun; }, exports.awrap = function (arg) { return { __await: arg }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, asyncIteratorSymbol, function () { return this; }), exports.AsyncIterator = AsyncIterator, exports.async = function (innerFn, outerFn, self, tryLocsList, PromiseImpl) { void 0 === PromiseImpl && (PromiseImpl = Promise); var iter = new AsyncIterator(wrap(innerFn, outerFn, self, tryLocsList), PromiseImpl); return exports.isGeneratorFunction(outerFn) ? iter : iter.next().then(function (result) { return result.done ? result.value : iter.next(); }); }, defineIteratorMethods(Gp), define(Gp, toStringTagSymbol, "Generator"), define(Gp, iteratorSymbol, function () { return this; }), define(Gp, "toString", function () { return "[object Generator]"; }), exports.keys = function (object) { var keys = []; for (var key in object) { keys.push(key); } return keys.reverse(), function next() { for (; keys.length;) { var key = keys.pop(); if (key in object) return next.value = key, next.done = !1, next; } return next.done = !0, next; }; }, exports.values = values, Context.prototype = { constructor: Context, reset: function reset(skipTempReset) { if (this.prev = 0, this.next = 0, this.sent = this._sent = undefined, this.done = !1, this.delegate = null, this.method = "next", this.arg = undefined, this.tryEntries.forEach(resetTryEntry), !skipTempReset) for (var name in this) { "t" === name.charAt(0) && hasOwn.call(this, name) && !isNaN(+name.slice(1)) && (this[name] = undefined); } }, stop: function stop() { this.done = !0; var rootRecord = this.tryEntries[0].completion; if ("throw" === rootRecord.type) throw rootRecord.arg; return this.rval; }, dispatchException: function dispatchException(exception) { if (this.done) throw exception; var context = this; function handle(loc, caught) { return record.type = "throw", record.arg = exception, context.next = loc, caught && (context.method = "next", context.arg = undefined), !!caught; } for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i], record = entry.completion; if ("root" === entry.tryLoc) return handle("end"); if (entry.tryLoc <= this.prev) { var hasCatch = hasOwn.call(entry, "catchLoc"), hasFinally = hasOwn.call(entry, "finallyLoc"); if (hasCatch && hasFinally) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } else if (hasCatch) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); } else { if (!hasFinally) throw new Error("try statement without catch or finally"); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } } } }, abrupt: function abrupt(type, arg) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc <= this.prev && hasOwn.call(entry, "finallyLoc") && this.prev < entry.finallyLoc) { var finallyEntry = entry; break; } } finallyEntry && ("break" === type || "continue" === type) && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc && (finallyEntry = null); var record = finallyEntry ? finallyEntry.completion : {}; return record.type = type, record.arg = arg, finallyEntry ? (this.method = "next", this.next = finallyEntry.finallyLoc, ContinueSentinel) : this.complete(record); }, complete: function complete(record, afterLoc) { if ("throw" === record.type) throw record.arg; return "break" === record.type || "continue" === record.type ? this.next = record.arg : "return" === record.type ? (this.rval = this.arg = record.arg, this.method = "return", this.next = "end") : "normal" === record.type && afterLoc && (this.next = afterLoc), ContinueSentinel; }, finish: function finish(finallyLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.finallyLoc === finallyLoc) return this.complete(entry.completion, entry.afterLoc), resetTryEntry(entry), ContinueSentinel; } }, "catch": function _catch(tryLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc === tryLoc) { var record = entry.completion; if ("throw" === record.type) { var thrown = record.arg; resetTryEntry(entry); } return thrown; } } throw new Error("illegal catch attempt"); }, delegateYield: function delegateYield(iterable, resultName, nextLoc) { return this.delegate = { iterator: values(iterable), resultName: resultName, nextLoc: nextLoc }, "next" === this.method && (this.arg = undefined), ContinueSentinel; } }, exports; }

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function _iterableToArrayLimit(arr, i) { var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"]; if (_i == null) return; var _arr = []; var _n = true; var _d = false; var _s, _e; try { for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }

function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }

//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//







 // Gettin' data through webpeck proxy

var symbolsm = window.location.pathname.toLowerCase().split('/')[3];
var symbolbg = window.location.pathname.toUpperCase().split('/')[3];
var pairsm = window.location.pathname.toLowerCase().split('/')[4];
var pairbg = window.location.pathname.toUpperCase().split('/')[4];
var URL = raw_loader_resources_assets_cors_txt__WEBPACK_IMPORTED_MODULE_7__["default"] + 'https://api.binance.com/api/v1/klines?symbol=';
var WSS = "wss://stream.binance.com:9443/ws/".concat(symbolsm).concat(pairsm, "@aggTrade");
var datas = "datasets.binance-".concat(symbolsm).concat(pairsm); //const PORT = location.port
//const URL = `http://localhost:${PORT}/api/v1/klines?symbol=`
//const WSS = `ws://localhost:${PORT}/ws/${symbolsm}@aggTrade`

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  name: 'App',
  components: {
    TradingVue: trading_vue_js__WEBPACK_IMPORTED_MODULE_0__.TradingVue
  },
  data: function data() {
    return {
      dc: new trading_vue_js__WEBPACK_IMPORTED_MODULE_0__.DataCube(_resources_data_data_json__WEBPACK_IMPORTED_MODULE_2__),
      title: symbolbg + pairbg,
      width: 0,
      height: 0,
      log_scale: true,
      symbol: symbolbg + pairbg,
      index_based: true,
      timezone: this.timezoned(),
      xsett: {
        'grid-resize': {
          min_height: 30
        }
      },
      ovs: Object.values((tvjs_overlays__WEBPACK_IMPORTED_MODULE_1___default())),
      ext: Object.values(_index_dev__WEBPACK_IMPORTED_MODULE_6__["default"]),
      night: true,
      top: 50,
      resetkey: 0
    };
  },
  computed: {
    colors: function colors() {
      return this.night ? {} : {
        colorBack: '#fff',
        colorGrid: '#eee',
        colorText: '#333'
      };
    }
  },
  mounted: function mounted() {
    var _this = this;

    window.addEventListener('resize', this.onResize);
    var q = this.win_query();
    if (q.nm === 'false') this.night = false;
    if (q.ov) this.current = q.ov;
    if (q.header === 'false') this.top = 0;
    this.onResize(), window.dc = this.dc;
    window.tv = this.$refs.tvjs; // Load the last data chunk & init DataCube:

    var now = _stuff_utils_js__WEBPACK_IMPORTED_MODULE_3__["default"].now();
    this.load_chunk([now - _stuff_constants_js__WEBPACK_IMPORTED_MODULE_4__["default"].HOUR4, now]).then(function (data) {
      dc.data.chart.data = data['chart.data']; // Register onrange callback & And a stream of trades

      _this.dc.onrange(_this.load_chunk);

      _this.stream = new _stream_js__WEBPACK_IMPORTED_MODULE_5__["default"](WSS);
      _this.stream.ontrades = _this.on_trades;
      window.dc = _this.chart; // Debug

      window.tv = _this.$refs.tvjs; // Debug
    });
  },
  beforeDestroy: function beforeDestroy() {
    window.removeEventListener('resize', this.onResize);
    if (this.stream) this.stream.off();
  },
  methods: {
    onResize: function onResize() {
      if (window.innerWidth > '992') {
        this.width = window.innerWidth - window.innerWidth * 0.21;
      } else if (window.innerWidth > '768' && window.innerWidth <= '992') {
        this.width = window.innerWidth - window.innerWidth * 0.26;
      } else {
        this.width = window.innerWidth - 15;
      }

      this.height = window.innerHeight * 0.80;
    },
    spline: function spline() {
      this.dc.data.chart.type = "Spline";
      this.dc.data.chart.tf = "1m";
      this.$refs.tvjs.resetChart();
    },
    candles: function candles() {
      this.dc.data.chart.type = "Candles";
      this.dc.data.chart.tf = "1m";
      this.$refs.tvjs.resetChart();
    },
    xbars: function xbars() {
      this.data.ovs = 'XOhlcBars';
      this.dc.data.chart.tf = "1m";
      this.$refs.tvjs.resetChart();
    },
    trade: function trade() {
      this.dc.data.chart.type = "Spline";
    },
    win_query: function win_query() {
      var qs = function (a) {
        if (a == "") return {};
        var b = {};

        for (var i = 0; i < a.length; ++i) {
          var p = a[i].split('=', 2);
          if (p.length == 1) b[p[0]] = "";else b[p[0]] = decodeURIComponent(p[1].replace(/\+/g, " "));
        }

        return b;
      }(window.location.search.substr(1).split('&'));

      return qs;
    },
    reset: function reset(state) {
      var sub = Object.keys(state).filter(function (x) {
        return state[x];
      });
      this.extensions = sub.map(function (x) {
        return _index_dev__WEBPACK_IMPORTED_MODULE_6__["default"][x];
      });
      this.resetkey++;
    },
    onselect: function onselect(id) {
      this.current = id;
    },
    timezoned: function timezoned() {
      var offset = new Date().getTimezoneOffset();
      var minutes = Math.abs(offset);
      var hours = Math.floor(minutes / 60);
      var prefix = offset < 0 ? "" : "-";
      return parseInt(prefix + hours);
    },
    // New data handler. Should return Promise, or
    // use callback: load_chunk(range, tf, callback)
    load_chunk: function load_chunk(range) {
      var _this2 = this;

      return _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {
        var _range, t1, t2, x, y, q, r;

        return _regeneratorRuntime().wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                _range = _slicedToArray(range, 2), t1 = _range[0], t2 = _range[1];
                x = symbolbg;
                y = pairbg;
                q = "".concat(x).concat(y, "&interval=1m&startTime=").concat(t1, "&endTime=").concat(t2);
                _context.next = 6;
                return fetch(URL + q).then(function (r) {
                  return r.json();
                });

              case 6:
                r = _context.sent;
                return _context.abrupt("return", _this2.format(_this2.parse_binance(r)));

              case 8:
              case "end":
                return _context.stop();
            }
          }
        }, _callee);
      }))();
    },
    // Parse a specific exchange format
    parse_binance: function parse_binance(data) {
      if (!Array.isArray(data)) return [];
      return data.map(function (x) {
        for (var i = 0; i < x.length; i++) {
          x[i] = parseFloat(x[i]);
        }

        return x.slice(0, 6);
      });
    },
    format: function format(data) {
      return {
        'chart.data': data
      };
    },
    on_trades: function on_trades(trade) {
      this.dc.update({
        t: trade.T,
        // Exchange time (optional)
        price: parseFloat(trade.p),
        // Trade price
        volume: parseFloat(trade.q),
        // Trade amount
        datas: [// Update dataset
        trade.T, trade.m ? 0 : 1, // Sell or Buy
        parseFloat(trade.q), parseFloat(trade.p)] // ... other onchart/offchart updates

      });
    }
  }
});

/***/ }),

/***/ "./node_modules/babel-loader/lib/index.js??clonedRuleSet-5[0].rules[0].use[0]!./node_modules/vue-loader/lib/index.js??vue-loader-options!./src/components/StdInput.vue?vue&type=script&lang=js&":
/*!******************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/babel-loader/lib/index.js??clonedRuleSet-5[0].rules[0].use[0]!./node_modules/vue-loader/lib/index.js??vue-loader-options!./src/components/StdInput.vue?vue&type=script&lang=js& ***!
  \******************************************************************************************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  name: 'StdInput',
  props: ['value', 'name', 'type', 'list', 'colors'],
  data: function data() {
    return {};
  },
  computed: {
    style: function style() {
      return {//background: this.$props.colors.back,
        //color: this.$props.colors.text
      };
    }
  },
  methods: {}
});

/***/ }),

/***/ "./node_modules/babel-loader/lib/index.js??clonedRuleSet-5[0].rules[0].use[0]!./node_modules/vue-loader/lib/index.js??vue-loader-options!./src/components/Window.vue?vue&type=script&lang=js&":
/*!****************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/babel-loader/lib/index.js??clonedRuleSet-5[0].rules[0].use[0]!./node_modules/vue-loader/lib/index.js??vue-loader-options!./src/components/Window.vue?vue&type=script&lang=js& ***!
  \****************************************************************************************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _dragg_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./dragg.js */ "./src/components/dragg.js");
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  name: 'Window',
  mixins: [_dragg_js__WEBPACK_IMPORTED_MODULE_0__["default"]],
  props: ['title', 'tv'],
  data: function data() {
    return {
      ww: 0,
      wh: 0,
      x: 0,
      y: 0
    };
  },
  computed: {
    style: function style() {
      return {
        top: "".concat(this.y, "px"),
        left: "".concat(this.x, "px")
      };
    },
    tvw: function tvw() {
      return this.$props.tv.width;
    },
    tvh: function tvh() {
      return this.$props.tv.height;
    }
  },
  mounted: function mounted() {
    this.ww = this.$refs.win.clientWidth;
    this.wh = this.$refs.win.clientHeight;
    this.x = this.tvw * 0.5 - this.ww * 0.5;
    this.y = this.tvh * 0.5 - this.wh * 0.5;
  }
});

/***/ }),

/***/ "./node_modules/babel-loader/lib/index.js??clonedRuleSet-5[0].rules[0].use[0]!./node_modules/vue-loader/lib/index.js??vue-loader-options!./src/extensions/grid-resize/Splitter.vue?vue&type=script&lang=js&":
/*!******************************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/babel-loader/lib/index.js??clonedRuleSet-5[0].rules[0].use[0]!./node_modules/vue-loader/lib/index.js??vue-loader-options!./src/extensions/grid-resize/Splitter.vue?vue&type=script&lang=js& ***!
  \******************************************************************************************************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils.js */ "./src/extensions/grid-resize/utils.js");
//
//
//
//
//
//
//

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  name: 'Splitter',
  props: ['id', 'main', 'dc', 'tv', 'data'],
  computed: {
    hs_style: function hs_style() {
      return {
        drag: null,
        top: this.data.grid2.offset + 'px' //backgroundColor: this.colors.splitter

      };
    }
  },
  mounted: function mounted() {
    this.MIN_HEIGHT = this.data.sett.min_height || 20;
  },
  methods: {
    hs_mousedown: function hs_mousedown(e) {
      this.drag = {
        type: 'hs',
        y: e.clientY,
        h1: this.data.grid1.height,
        h2: this.data.grid2.height
      };
      _utils_js__WEBPACK_IMPORTED_MODULE_0__["default"].add_style('disable-user-select', "body * {\n                user-select: none;\n            }\n            .trading-vue-chart {\n                pointer-events: none;\n            }");
    },
    hs_mouseup: function hs_mouseup(e) {
      this.drag = null;
      _utils_js__WEBPACK_IMPORTED_MODULE_0__["default"].rem_style('disable-user-select');
    },
    hs_mousemove: function hs_mousemove(e) {
      if (this.drag) {
        var off = e.clientY - this.drag.y;
        var new_h1 = this.drag.h1 + off;
        var new_h2 = this.drag.h2 - off;

        if (new_h1 > this.MIN_HEIGHT && new_h2 > this.MIN_HEIGHT) {
          this.data.grid1.height = new_h1;
          this.data.grid2.height = new_h2;
        }

        this.main.calc_heights();
      }
    },
    hs_mouseleave: function hs_mouseleave(e) {
      this.drag = null;
      _utils_js__WEBPACK_IMPORTED_MODULE_0__["default"].rem_style('disable-user-select');
    }
  }
});

/***/ }),

/***/ "./node_modules/babel-loader/lib/index.js??clonedRuleSet-5[0].rules[0].use[0]!./node_modules/vue-loader/lib/index.js??vue-loader-options!./src/extensions/legend-buttons/AddWin.vue?vue&type=script&lang=js&":
/*!*******************************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/babel-loader/lib/index.js??clonedRuleSet-5[0].rules[0].use[0]!./node_modules/vue-loader/lib/index.js??vue-loader-options!./src/extensions/legend-buttons/AddWin.vue?vue&type=script&lang=js& ***!
  \*******************************************************************************************************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _components_Window_vue__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../components/Window.vue */ "./src/components/Window.vue");
//
//
//
//
//
//
//
//
//
//
//
//

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  name: 'AddWin',
  components: {
    Window: _components_Window_vue__WEBPACK_IMPORTED_MODULE_0__["default"]
  },
  props: ['id', 'main', 'dc', 'tv', 'data'],
  data: function data() {
    return {
      ovs: this.tv.overlays.filter(function (x) {
        return x.methods.calc;
      })
    };
  },
  computed: {
    sett: function sett() {
      return this.$props.data.ov.settings;
    }
  },
  mounted: function mounted() {},
  methods: {
    on_close: function on_close() {
      this.$props.main.remove_widget(this.$props.id);
    },
    on_click: function on_click(name) {
      this.on_close();
      this.main.add_overlay({
        side: this.data.type,
        index: this.data.index,
        type: name
      });
    }
  }
});

/***/ }),

/***/ "./node_modules/babel-loader/lib/index.js??clonedRuleSet-5[0].rules[0].use[0]!./node_modules/vue-loader/lib/index.js??vue-loader-options!./src/extensions/settings-win/SettingsWin.vue?vue&type=script&lang=js&":
/*!**********************************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/babel-loader/lib/index.js??clonedRuleSet-5[0].rules[0].use[0]!./node_modules/vue-loader/lib/index.js??vue-loader-options!./src/extensions/settings-win/SettingsWin.vue?vue&type=script&lang=js& ***!
  \**********************************************************************************************************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _components_Window_vue__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../components/Window.vue */ "./src/components/Window.vue");
/* harmony import */ var _components_StdInput_vue__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../components/StdInput.vue */ "./src/components/StdInput.vue");
/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./utils.js */ "./src/extensions/settings-win/utils.js");
function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

//
//
//
//
//
//
//
//
//
//
//



/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  name: 'SettingsWin',
  components: {
    Window: _components_Window_vue__WEBPACK_IMPORTED_MODULE_0__["default"],
    StdInput: _components_StdInput_vue__WEBPACK_IMPORTED_MODULE_1__["default"]
  },
  props: ['id', 'main', 'dc', 'tv', 'data'],
  computed: {
    sett: function sett() {
      return this.$props.data.ov.settings;
    },
    settlist: function settlist() {
      var _this = this;

      return Object.keys(this.sett).filter(function (x) {
        return x[0] !== '$' && _this.sett.$props && _this.sett.$props.includes(x);
      });
    }
  },
  mounted: function mounted() {},
  methods: {
    s2d: function s2d(str) {
      return _utils_js__WEBPACK_IMPORTED_MODULE_2__["default"].sett2desc(str);
    },
    on_close: function on_close() {
      this.$props.main.remove_widget(this.$props.id);
    },
    update_sett: function update_sett(k, val) {
      var dcid = this.$props.data.ov.id;
      var valN = parseFloat(val);
      if (valN !== valN) valN = val;
      this.$props.dc.merge("".concat(dcid, ".settings"), _defineProperty({}, k, valN));
    }
  }
});

/***/ }),

/***/ "./src/components/dragg.js":
/*!*********************************!*\
  !*** ./src/components/dragg.js ***!
  \*********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  methods: {
    onMouseDown: function onMouseDown(e) {
      e = e || window.event;
      e.preventDefault();
      this.drag.offset_x = e.clientX - this.x;
      this.drag.offset_y = e.clientY - this.y;
      document.onmouseup = this.stopdrag;
      document.onmousemove = this.ondrag;
    },
    ondrag: function ondrag(e) {
      e = e || window.event;
      e.preventDefault();
      this.x = e.clientX - this.drag.offset_x;
      this.y = e.clientY - this.drag.offset_y;
    },
    stopdrag: function stopdrag() {
      document.onmouseup = null;
      document.onmousemove = null;
    }
  },
  data: function data() {
    return {
      drag: {
        offset_x: 0,
        offset_y: 0
      }
    };
  }
});

/***/ }),

/***/ "./src/extensions/chart-link/main.js":
/*!*******************************************!*\
  !*** ./src/extensions/chart-link/main.js ***!
  \*******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ Main)
/* harmony export */ });
/* harmony import */ var _shared_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./shared.js */ "./src/extensions/chart-link/shared.js");
/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utils.js */ "./src/extensions/chart-link/utils.js");
function _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it["return"] != null) it["return"](); } finally { if (didErr) throw err; } } }; }

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _iterableToArray(iter) { if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }

/* Example:

rules: {
    '* -> *': {},     // From each to each
    '*': {            // The same as ^
        cursor: true, // bool, 'X', 'Y', 'XY'
        position: 'X', // bool, 'X', 'Y', 'XY'
        tools: true
    },
    'trading-vue-1 -> trading-vue-2': {
        data: [
            'onchart.SMA',
            'RSI4H',
            {
                from: 'chart.data',
                to: 'datasets',
                obj: {
                    id: 'small-tf-data',
                    type: 'SourceData'
                }
            }
        ]
    },
    'none': {
        range: 'X', // bool, 'X', 'Y', 'XY'
    }
}
*/



var Main = /*#__PURE__*/function () {
  function Main(tv, dc, sett) {
    _classCallCheck(this, Main);

    if (sett.use_window) {
      if (!window.xchartlink$) {
        window.xchartlink$ = {};
      }

      this.shared = window.xchartlink$;
    } else {
      this.shared = _shared_js__WEBPACK_IMPORTED_MODULE_0__["default"];
    }

    this.tv = tv;
    this.dc = dc;
    this.sett = sett;
    this.targets = {};
    this.onsettings({
      'chart-link': sett
    });
  }

  _createClass(Main, [{
    key: "onsettings",
    value: function onsettings(all) {
      var _this = this;

      clearTimeout(this.reset_id);
      this.sett = all['chart-link'];

      if (!this.shared.rules) {
        this.shared.rules = {};
        this.shared.refs = {};
        this.shared.meta = {};
      }

      var el = document.getElementById(this.tv.id);

      if (this.sett.rules && el) {
        this.shared.rules[this.tv.id] = this.sett.rules;
      }

      this.shared.refs[this.tv.id] = this.tv;
      this.combine();
      this.reset_id = setTimeout(function () {
        return _this.reset();
      });
    } //  Combine rules from different instances

  }, {
    key: "combine",
    value: function combine() {
      this.shared.combined = {};

      for (var id in this.shared.rules) {
        for (var r in this.shared.rules[id]) {
          this.shared.combined[r] = this.shared.rules[id][r];
        }
      }
    } // Compile rules for this instance

  }, {
    key: "compile",
    value: function compile() {
      var gebcn = 'getElementsByClassName';

      var els = _toConsumableArray(document[gebcn]('trading-vue'));

      this.targets = {};

      var _iterator = _createForOfIteratorHelper(els),
          _step;

      try {
        for (_iterator.s(); !(_step = _iterator.n()).done;) {
          var el = _step.value;
          if (el.id === this.tv.id) continue;
          this.targets[el.id] = {};
        }
      } catch (err) {
        _iterator.e(err);
      } finally {
        _iterator.f();
      }

      var rules = this.rank(this.shared.combined);

      var _iterator2 = _createForOfIteratorHelper(rules),
          _step2;

      try {
        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
          var r = _step2.value;
          var dst = r.pair[1];

          if (dst === '*') {
            dst = Object.keys(this.targets);
          }

          if (Array.isArray(dst)) {
            var _iterator3 = _createForOfIteratorHelper(dst),
                _step3;

            try {
              for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {
                var d = _step3.value;
                if (!(d in this.targets)) continue;
                Object.assign(this.targets[d], r.r);
              }
            } catch (err) {
              _iterator3.e(err);
            } finally {
              _iterator3.f();
            }
          } else {
            if (!(dst in this.targets)) continue;
            Object.assign(this.targets[dst], r.r);
          }
        }
      } catch (err) {
        _iterator2.e(err);
      } finally {
        _iterator2.f();
      }
    } // Select, rank & sort the rules

  }, {
    key: "rank",
    value: function rank(rules) {
      var out = [];

      for (var r in rules) {
        var pair = this.splitr(r);
        if (!this.matches(pair[0])) continue;

        if (pair[0] === '*') {
          var rank = 20;
        } else if (Array.isArray(pair[0])) {
          rank = 10;
        } else {
          rank = 0;
        }

        if (pair[1] === '*') {
          rank += 2;
        } else if (Array.isArray(pair[1])) {
          rank += 1;
        } else {
          rank += 0;
        }

        out.push({
          pair: pair,
          rank: rank,
          r: rules[r]
        });
      }

      return out.sort(function (a, b) {
        return b.rank - a.rank;
      });
    } // Check if the source of a rule matches tv.id

  }, {
    key: "matches",
    value: function matches(src) {
      return src === '*' || src === this.tv.id || Array.isArray(src) && src.includes(this.tv.id);
    }
  }, {
    key: "splitr",
    value: function splitr(rule) {
      if (rule.trim() === '*') return ['*', '*'];
      return rule.split('->').map(function (x) {
        var tup = x.split(',');

        if (tup.length > 1) {
          return tup.map(function (y) {
            return y.trim();
          });
        }

        return x.trim();
      });
    } // Apply all rules for this instance

  }, {
    key: "reset",
    value: function reset() {
      var _this2 = this;

      this.compile(); // Enable some chart hook events

      this.tv.$refs.chart.hooks('xchanged');
      this.tv.$watch(function (x) {
        return _this2.dc.get('.').filter(function (x) {
          return x.settings.$state;
        });
      }, this.ontools.bind(this));
    } // Listening to the Chart.vue hooks &
    // other events

  }, {
    key: "update",
    value: function update(e) {
      switch (e.event) {
        case '?x-changed':
          var cursor = e.args[0];
          if (cursor.preventDefault) return;
          var main = this.tv.$refs.chart._layout.grids[cursor.grid_id];
          var mc = this.tv.$refs.chart.cursor;
          cursor.t = mc.t;
          cursor.$ = mc.y$;

          for (var id in this.targets) {
            var r = this.targets[id].cursor;

            if (r) {
              var tv = this.shared.refs[id];
              var g = tv.$refs.chart._layout.grids[0];
              var xx = this.isX(r);
              var yy = g.id === main.id && this.isY(r);
              var upd = {
                preventDefault: true,
                x: xx ? g.t2screen(cursor.t) : -10,
                y: yy ? g.$2screen(cursor.$) : -10,
                grid_id: 0
              };
              tv.$refs.chart.cursor_changed(upd);
              tv.$refs.chart.cursor.t = xx ? cursor.t : -10;
              tv.$refs.chart.cursor.y$ = yy ? cursor.$ : -10;
            }
          }

          break;

        case 'range-changed':
          var now = new Date().getTime();
          var meta = this.shared.meta[this.tv.id];

          if (meta && meta.position) {
            if (meta.position.lock > now) return;
          }

          var range = e.args[0];

          for (var id in this.targets) {
            var _r = this.targets[id].position;
            var _tv = this.shared.refs[id];

            var _xx = this.isX(_r);

            var _yy = this.isY(_r);

            if (!this.shared.meta[id]) {
              this.shared.meta[id] = {};
            } // Prevents an infinite loop


            this.shared.meta[id].position = {
              lock: now + 100
            };
            if (_xx) _tv["goto"](range[1]);
          }

          break;
      }
    }
  }, {
    key: "ontools",
    value: function ontools(n, p) {
      var _this3 = this;

      var rem = _utils_js__WEBPACK_IMPORTED_MODULE_1__["default"].removed(n.map(function (x) {
        return x.settings.$uuid;
      }), p.map(function (x) {
        return x.settings.$uuid;
      }));
      var now = new Date().getTime();
      var meta = this.shared.meta[this.tv.id];

      if (meta && meta.tools) {
        if (meta.tools.lock > now) return;
      }

      var _loop = function _loop() {
        var r = _this3.targets[id].tools;
        var tv = _this3.shared.refs[id];

        if (r) {
          if (!_this3.shared.meta[id]) {
            _this3.shared.meta[id] = {};
          } // Prevents an infinite loop


          _this3.shared.meta[id].tools = {
            lock: now + 100
          };

          _this3.copy_tools(n, tv);

          rem.forEach(function (r) {
            return tv.data.del("".concat(r));
          });
        }
      };

      for (var id in this.targets) {
        _loop();
      }
    }
  }, {
    key: "copy_tools",
    value: function copy_tools(n, tv) {
      var _iterator4 = _createForOfIteratorHelper(n),
          _step4;

      try {
        for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {
          var tool = _step4.value;
          if (tool.id.includes('offchart')) continue;
          var uuid = tool.settings.$uuid;
          var exi = tv.data.get_one("".concat(uuid));

          if (exi) {
            tv.$set(exi, 'settings', _utils_js__WEBPACK_IMPORTED_MODULE_1__["default"].copy(tool.settings, {
              $selected: false,
              $state: 'finished'
            })); // TODO: maybe add a proper method
            // of accessing overlays

            var ovs = tv.$refs.chart.$refs.sec[0].$refs.grid.$children.filter(function (x) {
              return x.tool;
            });

            var _iterator5 = _createForOfIteratorHelper(ovs),
                _step5;

            try {
              for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {
                var ov = _step5.value;
                ov.pins.forEach(function (x) {
                  return x.re_init();
                });
              }
            } catch (err) {
              _iterator5.e(err);
            } finally {
              _iterator5.f();
            }
          } else {
            var copy = _utils_js__WEBPACK_IMPORTED_MODULE_1__["default"].copy(tool);
            copy.settings.$selected = false;
            copy.settings.$state = 'finished';
            tv.data.add('onchart', copy);
          }
        }
      } catch (err) {
        _iterator4.e(err);
      } finally {
        _iterator4.f();
      }
    }
  }, {
    key: "isX",
    value: function isX(rule) {
      return rule === true || typeof rule === 'string' && rule.includes('X');
    }
  }, {
    key: "isY",
    value: function isY(rule) {
      return rule === true || typeof rule === 'string' && rule.includes('Y');
    }
  }]);

  return Main;
}();



/***/ }),

/***/ "./src/extensions/chart-link/shared.js":
/*!*********************************************!*\
  !*** ./src/extensions/chart-link/shared.js ***!
  \*********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

//  Object shared beetween tvjs instances
var Shared = /*#__PURE__*/_createClass(function Shared() {
  _classCallCheck(this, Shared);

  this.__id__ = Math.random();
});

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (new Shared());

/***/ }),

/***/ "./src/extensions/chart-link/utils.js":
/*!********************************************!*\
  !*** ./src/extensions/chart-link/utils.js ***!
  \********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
function _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it["return"] != null) it["return"](); } finally { if (didErr) throw err; } } }; }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  copy: function copy(obj, mod) {
    var copy = JSON.parse(JSON.stringify(obj));
    return Object.assign(copy, mod);
  },
  removed: function removed(ids, prev) {
    var list = [];

    var _iterator = _createForOfIteratorHelper(prev),
        _step;

    try {
      for (_iterator.s(); !(_step = _iterator.n()).done;) {
        var id = _step.value;

        if (!ids.includes(id)) {
          list.push(id);
        }
      }
    } catch (err) {
      _iterator.e(err);
    } finally {
      _iterator.f();
    }

    return list;
  }
});

/***/ }),

/***/ "./src/extensions/grid-resize/main.js":
/*!********************************************!*\
  !*** ./src/extensions/grid-resize/main.js ***!
  \********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ Main)
/* harmony export */ });
/* harmony import */ var trading_vue_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! trading-vue-js */ "./node_modules/trading-vue-js/dist/trading-vue.js");
/* harmony import */ var trading_vue_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(trading_vue_js__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var vue__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! vue */ "./node_modules/vue/dist/vue.esm.js");
/* harmony import */ var _Splitter_vue__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Splitter.vue */ "./src/extensions/grid-resize/Splitter.vue");
function _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it["return"] != null) it["return"](); } finally { if (didErr) throw err; } } }; }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }

// Extension's controller




var Main = /*#__PURE__*/function () {
  function Main(tv, dc, sett) {
    var _this = this;

    _classCallCheck(this, Main);

    this.widgets = {};
    this.tv = tv;
    this.dc = dc;
    this.sett = sett;
    setTimeout(function () {
      _this.tv.$el.addEventListener('mousemove', _this.onmousemove.bind(_this));

      _this.tv.$el.addEventListener('mouseup', _this.onmouseup.bind(_this));

      _this.tv.$el.addEventListener('mouseleave', _this.onmouseleave.bind(_this));

      _this.place_splitters();

      _this.calc_heights(); // Track changes of grids count


      _this.tv.$watch(function (x) {
        return _this.dc.get('.').map(function (x) {
          return x.id;
        });
      }, _this.ongrids.bind(_this));
    });
  } // Listens to all tvjs events, creates new widgets


  _createClass(Main, [{
    key: "update",
    value: function update(e) {
      switch (e.event) {}
    } // Extension settings has changed

  }, {
    key: "onsettings",
    value: function onsettings(sett) {}
  }, {
    key: "ongrids",
    value: function ongrids() {
      var _this2 = this;

      setTimeout(function () {
        _this2.remove_widgets();

        _this2.place_splitters();
      });
    }
  }, {
    key: "onmousemove",
    value: function onmousemove(e) {
      var _this3 = this;

      // List of widgets created by this controller
      var list = this.tv.$refs.widgets.$children.filter(function (x) {
        return x.main === _this3;
      });

      var _iterator = _createForOfIteratorHelper(list),
          _step;

      try {
        for (_iterator.s(); !(_step = _iterator.n()).done;) {
          var s = _step.value;
          s.hs_mousemove(e);
        }
      } catch (err) {
        _iterator.e(err);
      } finally {
        _iterator.f();
      }
    }
  }, {
    key: "onmouseup",
    value: function onmouseup(e) {
      var _this4 = this;

      // List of widgets created by this controller
      var list = this.tv.$refs.widgets.$children.filter(function (x) {
        return x.main === _this4;
      });

      var _iterator2 = _createForOfIteratorHelper(list),
          _step2;

      try {
        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
          var s = _step2.value;
          s.hs_mouseup(e);
        }
      } catch (err) {
        _iterator2.e(err);
      } finally {
        _iterator2.f();
      }
    }
  }, {
    key: "onmouseleave",
    value: function onmouseleave(e) {
      var _this5 = this;

      // List of widgets created by this controller
      var list = this.tv.$refs.widgets.$children.filter(function (x) {
        return x.main === _this5;
      });

      var _iterator3 = _createForOfIteratorHelper(list),
          _step3;

      try {
        for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {
          var s = _step3.value;
          s.hs_mouseleave(e);
        }
      } catch (err) {
        _iterator3.e(err);
      } finally {
        _iterator3.f();
      }
    }
  }, {
    key: "place_splitters",
    value: function place_splitters() {
      var grids = this.tv.$refs.chart._layout.grids;

      for (var i = 1; i < grids.length; i++) {
        var g1 = grids[i - 1];
        var g2 = grids[i];
        var id = "Splitter-".concat(g1.id, "-").concat(g2.id, "-").concat(trading_vue_js__WEBPACK_IMPORTED_MODULE_0__.Utils.uuid2());
        vue__WEBPACK_IMPORTED_MODULE_2__["default"].set(this.widgets, id, {
          id: id,
          cls: _Splitter_vue__WEBPACK_IMPORTED_MODULE_1__["default"],
          data: {
            grid1: g1,
            grid2: g2,
            sett: this.sett
          }
        });
      }
    }
  }, {
    key: "calc_heights",
    value: function calc_heights() {
      var hs = [];

      var _iterator4 = _createForOfIteratorHelper(this.tv.$refs.chart._layout.grids),
          _step4;

      try {
        for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {
          var g = _step4.value;
          hs.push(g.height);
        }
      } catch (err) {
        _iterator4.e(err);
      } finally {
        _iterator4.f();
      }

      var sum = hs.reduce(function (a, b) {
        return a + b;
      }, 0);
      hs = hs.map(function (h) {
        return h / sum;
      });
      this.grid_ovs().forEach(function (ov, i) {
        if (!ov.grid) {
          vue__WEBPACK_IMPORTED_MODULE_2__["default"].set(ov, 'grid', {});
        }

        vue__WEBPACK_IMPORTED_MODULE_2__["default"].set(ov.grid, 'height', hs[i] || 1);
      });
    } // Grid defining overlays

  }, {
    key: "grid_ovs",
    value: function grid_ovs() {
      var list = [this.dc.data.chart];

      var _iterator5 = _createForOfIteratorHelper(this.dc.data.offchart),
          _step5;

      try {
        for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {
          var ov = _step5.value;

          if (!ov.grid || ov.grid.id === undefined) {
            list.push(ov);
          }
        }
      } catch (err) {
        _iterator5.e(err);
      } finally {
        _iterator5.f();
      }

      return list;
    }
  }, {
    key: "remove_widgets",
    value: function remove_widgets() {
      for (var id in this.widgets) {
        this.tv.$delete(this.widgets, id);
      }
    }
  }, {
    key: "destroy",
    value: function destroy() {
      this.tv.$el.removeEventListener('mousemove', this.onmousemove);
      this.tv.$el.removeEventListener('mouseup', this.mouseup);
      this.tv.$el.removeEventListener('mouseleave', this.mouseleave);
    }
  }]);

  return Main;
}();



/***/ }),

/***/ "./src/extensions/grid-resize/utils.js":
/*!*********************************************!*\
  !*** ./src/extensions/grid-resize/utils.js ***!
  \*********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  add_style: function add_style(id, style) {
    var stbr = document.getElementById(id);

    if (stbr) {
      var sheetParent = stbr.parentNode;
      sheetParent.removeChild(stbr);
    }

    var sheet = document.createElement('style');
    sheet.setAttribute("id", id);
    sheet.innerHTML = style;
    document.body.appendChild(sheet);
  },
  rem_style: function rem_style(id, style) {
    var stbr = document.getElementById(id);

    if (stbr) {
      var sheetParent = stbr.parentNode;
      sheetParent.removeChild(stbr);
    }
  }
});

/***/ }),

/***/ "./src/extensions/legend-buttons/main.js":
/*!***********************************************!*\
  !*** ./src/extensions/legend-buttons/main.js ***!
  \***********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ Main)
/* harmony export */ });
/* harmony import */ var trading_vue_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! trading-vue-js */ "./node_modules/trading-vue-js/dist/trading-vue.js");
/* harmony import */ var trading_vue_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(trading_vue_js__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _AddWin_vue__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./AddWin.vue */ "./src/extensions/legend-buttons/AddWin.vue");
function _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it["return"] != null) it["return"](); } finally { if (didErr) throw err; } } }; }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }

// Extension's controller




var Main = /*#__PURE__*/function () {
  function Main(tv, dc, sett) {
    _classCallCheck(this, Main);

    this.widgets = {};
    this.tv = tv;
    this.dc = dc;
    this.sett = sett;
  } // Listens to all tvjs events, creates new widgets


  _createClass(Main, [{
    key: "update",
    value: function update(e) {
      switch (e.event) {
        case 'legend-button-click':
          this.onbutton(e.args[0]);
          break;
      }
    }
  }, {
    key: "onbutton",
    value: function onbutton(e) {
      var ov = this.dc.get(e.type)[e.dataIndex];
      var onchart = this.dc.data.onchart;
      var offchart = this.dc.data.offchart;
      if (!ov) return;

      switch (e.button) {
        case 'display':
          if (ov.settings.display === undefined) {
            var flag = false;
          } else {
            flag = !ov.settings.display;
          }

          this.tv.$set(ov.settings, 'display', flag);
          break;

        case 'up':
          if (e.type === 'offchart') {
            if (e.dataIndex === 0) {
              offchart.splice(e.dataIndex, 1);
              onchart.push(ov);
            } else {
              var data = offchart;
              var i0 = e.dataIndex;
              var i1 = e.dataIndex - 1;
              data[i0] = data.splice(i1, 1, data[i0])[0];
            }
          }

          this.dc.update_ids();
          break;

        case 'down':
          if (e.type === 'onchart') {
            var h = this.avg_grid_h(offchart);
            onchart.splice(e.dataIndex, 1);
            offchart.unshift(ov);
            this.tv.$set(ov, 'grid', {
              height: h
            });
          } else {
            var n = offchart.length;
            var _data = offchart;

            if (e.dataIndex < n - 1) {
              var _i = e.dataIndex;

              var _i2 = e.dataIndex + 1;

              _data[_i] = _data.splice(_i2, 1, _data[_i])[0];
            }
          }

          this.dc.update_ids();
          break;

        case 'add':
          try {
            var id = "AddWin-".concat(trading_vue_js__WEBPACK_IMPORTED_MODULE_0__.Utils.uuid2());
            var _ov = this.dc.data[e.type][e.dataIndex];
            var f = Object.values(this.widgets).find(function (x) {
              return x.data.ov === _ov;
            });

            if (f) {
              this.tv.$delete(this.widgets, f.id);
              break;
            }

            this.tv.$set(this.widgets, id, {
              id: id,
              cls: _AddWin_vue__WEBPACK_IMPORTED_MODULE_1__["default"],
              data: {
                ov: _ov,
                type: e.type,
                index: e.dataIndex
              }
            });
          } catch (e) {
            console.log(e);
          }

          break;

        case 'remove':
          this.dc.data[e.type].splice(e.dataIndex, 1);
          this.dc.update_ids();
          break;
      }
    } // Called from AddWin.vue

  }, {
    key: "add_overlay",
    value: function add_overlay(e) {
      var preset = this.get_preset(e.type) || {};
      if (preset.side) e.side = preset.side;
      var onchart = this.dc.data.onchart;
      var offchart = this.dc.data.offchart;

      if (e.side === 'onchart') {
        onchart.splice(e.index + 1, 0, {
          name: preset.name,
          type: e.type,
          data: [],
          settings: preset.settings || {}
        });
      } else {
        var h = this.avg_grid_h(offchart);
        offchart.splice(e.index + 1, 0, {
          name: preset.name,
          type: e.type,
          data: [],
          settings: preset.settings || {},
          grid: {
            height: h
          }
        });
      }

      this.dc.update_ids();
    } // Get preset (default settings, colors) if defined

  }, {
    key: "get_preset",
    value: function get_preset(type) {
      var proto = this.tv.overlays.find(function (x) {
        return x.name === type;
      });

      if (proto && proto.methods.meta_info) {
        var meta = proto.methods.meta_info();
        return meta.preset;
      }
    } // Extension settings has changed

  }, {
    key: "onsettings",
    value: function onsettings(sett) {}
  }, {
    key: "avg_grid_h",
    value: function avg_grid_h(ovs) {
      if (!ovs.length) return 0.25;
      var gh = 0;

      var _iterator = _createForOfIteratorHelper(ovs),
          _step;

      try {
        for (_iterator.s(); !(_step = _iterator.n()).done;) {
          var ov = _step.value;

          if (ov.grid && typeof ov.grid.height === 'number') {
            gh += ov.grid.height;
          }
        }
      } catch (err) {
        _iterator.e(err);
      } finally {
        _iterator.f();
      }

      return gh / ovs.length;
    }
  }, {
    key: "remove_widget",
    value: function remove_widget(id) {
      this.tv.$delete(this.widgets, id);
    }
  }, {
    key: "destroy",
    value: function destroy() {}
  }]);

  return Main;
}();



/***/ }),

/***/ "./src/extensions/settings-win/main.js":
/*!*********************************************!*\
  !*** ./src/extensions/settings-win/main.js ***!
  \*********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ Main)
/* harmony export */ });
/* harmony import */ var trading_vue_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! trading-vue-js */ "./node_modules/trading-vue-js/dist/trading-vue.js");
/* harmony import */ var trading_vue_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(trading_vue_js__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _SettingsWin_vue__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./SettingsWin.vue */ "./src/extensions/settings-win/SettingsWin.vue");
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }

// Extension's controller




var Main = /*#__PURE__*/function () {
  function Main(tv, dc) {
    _classCallCheck(this, Main);

    this.widgets = {};
    this.tv = tv;
    this.dc = dc;
  } // Listens to all tvjs events, creates new widgets


  _createClass(Main, [{
    key: "update",
    value: function update(e) {
      switch (e.event) {
        case 'legend-button-click':
          var id = "SettingsWin-".concat(trading_vue_js__WEBPACK_IMPORTED_MODULE_0__.Utils.uuid2());
          var args = e.args[0];
          if (args.button !== 'settings') break;

          try {
            var ov = this.dc.data[args.type][args.dataIndex];
            var f = Object.values(this.widgets).find(function (x) {
              return x.data.ov === ov;
            });

            if (f) {
              this.tv.$delete(this.widgets, f.id);
              break;
            }

            this.tv.$set(this.widgets, id, {
              id: id,
              cls: _SettingsWin_vue__WEBPACK_IMPORTED_MODULE_1__["default"],
              data: {
                ov: ov
              }
            });
          } catch (e) {
            console.log(e);
          }

          break;
      }
    }
  }, {
    key: "remove_widget",
    value: function remove_widget(id) {
      this.tv.$delete(this.widgets, id);
    }
  }]);

  return Main;
}();



/***/ }),

/***/ "./src/extensions/settings-win/utils.js":
/*!**********************************************!*\
  !*** ./src/extensions/settings-win/utils.js ***!
  \**********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  sett2desc: function sett2desc(sett) {
    function setCharAt(str, index, chr) {
      if (index > str.length - 1) return str;
      return str.substring(0, index) + chr + str.substring(index + 1);
    }

    sett = sett.replace(/([^A-Z])([A-Z])/g, '$1 $2');
    sett = sett.replace(/-|_/g, ' ');
    var tuple = sett.split(' ');
    tuple = tuple.filter(function (x) {
      return x.length;
    }).map(function (x) {
      return setCharAt(x, 0, x[0].toUpperCase());
    });
    return tuple.join(' ');
  }
});

/***/ }),

/***/ "./src/index_dev.js":
/*!**************************!*\
  !*** ./src/index_dev.js ***!
  \**************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _build_chart_link_chart_link_dev_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../build/chart-link/chart-link-dev.js */ "./build/chart-link/chart-link-dev.js");
/* harmony import */ var _build_grid_resize_grid_resize_dev_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../build/grid-resize/grid-resize-dev.js */ "./build/grid-resize/grid-resize-dev.js");
/* harmony import */ var _build_legend_buttons_legend_buttons_dev_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../build/legend-buttons/legend-buttons-dev.js */ "./build/legend-buttons/legend-buttons-dev.js");
/* harmony import */ var _build_settings_win_settings_win_dev_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../build/settings-win/settings-win-dev.js */ "./build/settings-win/settings-win-dev.js");
// -------- Development extension index ---------
//      ! THIS FILE WAS AUTO-GENERATED !
//
// You can overwrite it and have fun, to restore
// the default state: 'npm run compile'




var Pack = {
  'chart-link': _build_chart_link_chart_link_dev_js__WEBPACK_IMPORTED_MODULE_0__["default"],
  'grid-resize': _build_grid_resize_grid_resize_dev_js__WEBPACK_IMPORTED_MODULE_1__["default"],
  'legend-buttons': _build_legend_buttons_legend_buttons_dev_js__WEBPACK_IMPORTED_MODULE_2__["default"],
  'settings-win': _build_settings_win_settings_win_dev_js__WEBPACK_IMPORTED_MODULE_3__["default"]
};
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Pack);


/***/ }),

/***/ "./src/main.js":
/*!*********************!*\
  !*** ./src/main.js ***!
  \*********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var vue__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! vue */ "./node_modules/vue/dist/vue.esm.js");
/* harmony import */ var _Main_vue__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Main.vue */ "./src/Main.vue");


new vue__WEBPACK_IMPORTED_MODULE_1__["default"]({
  el: '#app',
  render: function render(h) {
    return h(_Main_vue__WEBPACK_IMPORTED_MODULE_0__["default"]);
  }
});

/***/ }),

/***/ "./src/stream.js":
/*!***********************!*\
  !*** ./src/stream.js ***!
  \***********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ Stream)
/* harmony export */ });
function Stream(url) {
  var ws = new WebSocket(url);

  var cb = function cb() {};

  ws.onopen = function () {
    console.log('Websocket is opened');
  };

  ws.onmessage = function (data) {
    try {
      data = JSON.parse(data.data);
      cb(data);
    } catch (e) {
      console.log(e);
    }
  };

  return {
    set ontrades(val) {
      cb = val;
    },

    off: function off() {
      ws.close(1000);
    }
  };
}

/***/ }),

/***/ "./src/stuff/constants.js":
/*!********************************!*\
  !*** ./src/stuff/constants.js ***!
  \********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
var SECOND = 1000;
var MINUTE = SECOND * 60;
var MINUTE3 = MINUTE * 3;
var MINUTE5 = MINUTE * 5;
var MINUTE15 = MINUTE * 15;
var MINUTE30 = MINUTE * 30;
var HOUR = MINUTE * 60;
var HOUR4 = HOUR * 4;
var HOUR12 = HOUR * 12;
var DAY = HOUR * 24;
var WEEK = DAY * 7;
var MONTH = WEEK * 4;
var YEAR = DAY * 365;
var MONTHMAP = ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"]; // Grid time steps

var TIMESCALES = [YEAR * 10, YEAR * 5, YEAR * 3, YEAR * 2, YEAR, MONTH * 6, MONTH * 4, MONTH * 3, MONTH * 2, MONTH, DAY * 15, DAY * 10, DAY * 7, DAY * 5, DAY * 3, DAY * 2, DAY, HOUR * 12, HOUR * 6, HOUR * 3, HOUR * 1.5, HOUR, MINUTE30, MINUTE15, MINUTE * 10, MINUTE5, MINUTE * 2, MINUTE]; // Grid $ steps

var $SCALES = [0.05, 0.1, 0.2, 0.25, 0.5, 0.8, 1, 2, 5];
var ChartConfig = {
  SBMIN: 60,
  // Minimal sidebar px
  SBMAX: Infinity,
  // Max sidebar, px
  TOOLBAR: 57,
  // Toolbar width px
  TB_ICON: 25,
  // Toolbar icon size px
  TB_ITEM_M: 6,
  // Toolbar item margin px
  TB_ICON_BRI: 1,
  // Toolbar icon brightness
  TB_ICON_HOLD: 420,
  // ms, wait to expand
  TB_BORDER: 1,
  // Toolbar border px
  TB_B_STYLE: 'dotted',
  // Toolbar border style
  TOOL_COLL: 7,
  // Tool collision threshold
  EXPAND: 0.15,
  // %/100 of range
  CANDLEW: 0.6,
  // %/100 of step
  GRIDX: 100,
  // px
  GRIDY: 47,
  // px
  BOTBAR: 28,
  // px
  PANHEIGHT: 22,
  // px
  DEFAULT_LEN: 50,
  // candles
  MINIMUM_LEN: 5,
  // candles,
  MIN_ZOOM: 25,
  // candles
  MAX_ZOOM: 1000,
  // candles,
  VOLSCALE: 0.15,
  // %/100 of height
  UX_OPACITY: 0.9,
  // Ux background opacity
  ZOOM_MODE: 'tv',
  // 'tv' or 'tl'
  L_BTN_SIZE: 21,
  // Legend Button size, px
  L_BTN_MARGIN: '-6px 0 -6px 0',
  // css margin
  SCROLL_WHEEL: 'prevent' // 'pass', 'click'

};
ChartConfig.FONT = "11px -apple-system,BlinkMacSystemFont,\n    Segoe UI,Roboto,Oxygen,Ubuntu,Cantarell,\n    Fira Sans,Droid Sans,Helvetica Neue,\n    sans-serif";
var IB_TF_WARN = "When using IB mode you should specify " + "timeframe ('tf' filed in 'chart' object)," + "otherwise you can get an unexpected behaviour";
var MAP_UNIT = {
  "1s": SECOND,
  "5s": SECOND * 5,
  "10s": SECOND * 10,
  "20s": SECOND * 20,
  "30s": SECOND * 30,
  "1m": MINUTE,
  "3m": MINUTE3,
  "5m": MINUTE5,
  "15m": MINUTE15,
  "30m": MINUTE30,
  "1H": HOUR,
  "2H": HOUR * 2,
  "3H": HOUR * 3,
  "4H": HOUR4,
  "12H": HOUR12,
  "1D": DAY,
  "1W": WEEK,
  "1M": MONTH,
  "1Y": YEAR
};
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  SECOND: SECOND,
  MINUTE: MINUTE,
  MINUTE5: MINUTE5,
  MINUTE15: MINUTE15,
  MINUTE30: MINUTE30,
  HOUR: HOUR,
  HOUR4: HOUR4,
  DAY: DAY,
  WEEK: WEEK,
  MONTH: MONTH,
  YEAR: YEAR,
  MONTHMAP: MONTHMAP,
  TIMESCALES: TIMESCALES,
  $SCALES: $SCALES,
  ChartConfig: ChartConfig,
  map_unit: MAP_UNIT,
  IB_TF_WARN: IB_TF_WARN
});

/***/ }),

/***/ "./src/stuff/utils.js":
/*!****************************!*\
  !*** ./src/stuff/utils.js ***!
  \****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var arrayslicer__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! arrayslicer */ "./node_modules/arrayslicer/lib/index.js");
/* harmony import */ var arrayslicer__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(arrayslicer__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _constants_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./constants.js */ "./src/stuff/constants.js");
function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _iterableToArray(iter) { if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }



/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  name2Name: function name2Name(sett) {
    function setCharAt(str, index, chr) {
      if (index > str.length - 1) return str;
      return str.substring(0, index) + chr + str.substring(index + 1);
    }

    sett = sett.replace(/([^A-Z])([A-Z])/g, '$1 $2');
    sett = sett.replace(/-|_/g, ' ');
    var tuple = sett.split(' ');
    tuple = tuple.filter(function (x) {
      return x.length;
    }).map(function (x) {
      return setCharAt(x, 0, x[0].toUpperCase());
    });
    return tuple.join('');
  },
  clamp: function clamp(num, min, max) {
    return num <= min ? min : num >= max ? max : num;
  },
  add_zero: function add_zero(i) {
    if (i < 10) {
      i = "0" + i;
    }

    return i;
  },
  // Start of the day (zero millisecond)
  day_start: function day_start(t) {
    var start = new Date(t);
    return start.setUTCHours(0, 0, 0, 0);
  },
  // Start of the month
  month_start: function month_start(t) {
    var date = new Date(t);
    return Date.UTC(date.getFullYear(), date.getMonth(), 1);
  },
  // Start of the year
  year_start: function year_start(t) {
    return Date.UTC(new Date(t).getFullYear());
  },
  get_year: function get_year(t) {
    if (!t) return undefined;
    return new Date(t).getUTCFullYear();
  },
  get_month: function get_month(t) {
    if (!t) return undefined;
    return new Date(t).getUTCMonth();
  },
  // Nearest in array
  nearest_a: function nearest_a(x, array) {
    var dist = Infinity;
    var val = null;
    var index = -1;

    for (var i = 0; i < array.length; i++) {
      var xi = array[i];

      if (Math.abs(xi - x) < dist) {
        dist = Math.abs(xi - x);
        val = xi;
        index = i;
      }
    }

    return [index, val];
  },
  round: function round(num) {
    var decimals = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 8;
    return parseFloat(num.toFixed(decimals));
  },
  // Strip? No, it's ugly floats in js
  strip: function strip(number) {
    return parseFloat(parseFloat(number).toPrecision(12));
  },
  get_day: function get_day(t) {
    return t ? new Date(t).getDate() : null;
  },
  // Update array keeping the same reference
  overwrite: function overwrite(arr, new_arr) {
    arr.splice.apply(arr, [0, arr.length].concat(_toConsumableArray(new_arr)));
  },
  // Copy layout in reactive way
  copy_layout: function copy_layout(obj, new_obj) {
    for (var k in obj) {
      if (Array.isArray(obj[k])) {
        // (some offchart indicators are added/removed)
        // we need to update layout in a reactive way
        if (obj[k].length !== new_obj[k].length) {
          this.overwrite(obj[k], new_obj[k]);
          continue;
        }

        for (var m in obj[k]) {
          Object.assign(obj[k][m], new_obj[k][m]);
        }
      } else {
        Object.assign(obj[k], new_obj[k]);
      }
    }
  },
  // Detects candles interval
  detect_interval: function detect_interval(ohlcv) {
    var len = Math.min(ohlcv.length - 1, 99);
    var min = Infinity;
    ohlcv.slice(0, len).forEach(function (x, i) {
      var d = ohlcv[i + 1][0] - x[0];
      if (d === d && d < min) min = d;
    }); // This saves monthly chart from being awkward

    if (min >= _constants_js__WEBPACK_IMPORTED_MODULE_1__["default"].MONTH && min <= _constants_js__WEBPACK_IMPORTED_MODULE_1__["default"].DAY * 30) {
      return _constants_js__WEBPACK_IMPORTED_MODULE_1__["default"].DAY * 31;
    }

    return min;
  },
  // Gets numberic part of overlay id (e.g 'EMA_1' = > 1)
  get_num_id: function get_num_id(id) {
    return parseInt(id.split('_').pop());
  },
  // Fast filter. Really fast, like 10X
  fast_filter: function fast_filter(arr, t1, t2) {
    if (!arr.length) return [arr, undefined];

    try {
      var ia = new (arrayslicer__WEBPACK_IMPORTED_MODULE_0___default())(arr, "0");
      var res = ia.getRange(t1, t2);
      var i0 = ia.valpos[t1].next;
      return [res, i0];
    } catch (e) {
      // Something wrong with fancy slice lib
      // Fast fix: fallback to filter
      return [arr.filter(function (x) {
        return x[0] >= t1 && x[0] <= t2;
      }), 0];
    }
  },
  // Fast filter (index-based)
  fast_filter_i: function fast_filter_i(arr, t1, t2) {
    if (!arr.length) return [arr, undefined];
    var i1 = Math.floor(t1);
    if (i1 < 0) i1 = 0;
    var i2 = Math.floor(t2 + 1);
    var res = arr.slice(i1, i2);
    return [res, i1];
  },
  // Nearest indexes (left and right)
  fast_nearest: function fast_nearest(arr, t1) {
    var ia = new (arrayslicer__WEBPACK_IMPORTED_MODULE_0___default())(arr, "0");
    ia.fetch(t1);
    return [ia.nextlow, ia.nexthigh];
  },
  now: function now() {
    return new Date().getTime();
  },
  pause: function pause(delay) {
    return new Promise(function (rs, rj) {
      return setTimeout(rs, delay);
    });
  },
  // Limit crazy wheel delta values
  smart_wheel: function smart_wheel(delta) {
    var abs = Math.abs(delta);

    if (abs > 500) {
      return (200 + Math.log(abs)) * Math.sign(delta);
    }

    return delta;
  },
  // Parse the original mouse event to find deltaX
  get_deltaX: function get_deltaX(event) {
    return event.originalEvent.deltaX / 12;
  },
  // Parse the original mouse event to find deltaY
  get_deltaY: function get_deltaY(event) {
    return event.originalEvent.deltaY / 12;
  },
  // Apply opacity to a hex color
  apply_opacity: function apply_opacity(c, op) {
    if (c.length === 7) {
      var n = Math.floor(op * 255);
      n = this.clamp(n, 0, 255);
      c += n.toString(16);
    }

    return c;
  },
  // Parse timeframe or return value in ms
  parse_tf: function parse_tf(smth) {
    if (typeof smth === 'string') {
      return _constants_js__WEBPACK_IMPORTED_MODULE_1__["default"].map_unit[smth];
    } else {
      return smth;
    }
  },
  // Detect index shift between the main data sub
  // and the overlay's sub (for IB-mode)
  index_shift: function index_shift(sub, data) {
    // Find the second timestamp (by value)
    if (!data.length) return 0;
    var first = data[0][0];
    var second;

    for (var i = 1; i < data.length; i++) {
      if (data[i][0] !== first) {
        second = data[i][0];
        break;
      }
    }

    for (var j = 0; j < sub.length; j++) {
      if (sub[j][0] === second) {
        return j - i;
      }
    }

    return 0;
  },
  // Fallback fix for Brave browser
  // https://github.com/brave/brave-browser/issues/1738
  measureText: function measureText(ctx, text, tv_id) {
    var m = ctx.measureTextOrg(text);

    if (m.width === 0) {
      var doc = document;
      var id = 'tvjs-measure-text';
      var el = doc.getElementById(id);

      if (!el) {
        var base = doc.getElementById(tv_id);
        el = doc.createElement("div");
        el.id = id;
        el.style.position = 'absolute';
        el.style.top = '-1000px';
        base.appendChild(el);
      }

      if (ctx.font) el.style.font = ctx.font;
      el.innerText = text.replace(/ /g, '.');
      return {
        width: el.offsetWidth
      };
    } else {
      return m;
    }
  },
  uuid: function uuid() {
    var temp = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx';
    return temp.replace(/[xy]/g, function (c) {
      var r = Math.random() * 16 | 0,
          v = c == 'x' ? r : r & 0x3 | 0x8;
      return v.toString(16);
    });
  },
  uuid2: function uuid2() {
    return this.uuid('xxxxxxxxxxxx');
  },
  // Delayed warning, f = condition lambda fn
  warn: function warn(f, text) {
    var delay = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
    setTimeout(function () {
      if (f()) console.warn(text);
    }, delay);
  },
  // Checks if script props updated
  // (and not style settings or something else)
  is_scr_props_upd: function is_scr_props_upd(n, prev) {
    var p = prev.find(function (x) {
      return x.v.$uuid === n.v.$uuid;
    });
    if (!p) return false;
    var props = n.p.settings.$props;
    if (!props) return false;
    return props.some(function (x) {
      return n.v[x] !== p.v[x];
    });
  },
  // Checks if it's time to make a script update
  // (based on execInterval in ms)
  delayed_exec: function delayed_exec(v) {
    if (!v.script || !v.script.execInterval) return true;
    var t = this.now();
    var dt = v.script.execInterval;

    if (!v.settings.$last_exec || t > v.settings.$last_exec + dt) {
      v.settings.$last_exec = t;
      return true;
    }

    return false;
  },
  // Format names such 'RSI, $length', where
  // length - is one of the settings
  format_name: function format_name(ov) {
    if (!ov.name) return undefined;
    var name = ov.name;

    for (var k in ov.settings || {}) {
      var val = ov.settings[k];
      var reg = new RegExp("\\$".concat(k), 'g');
      name = name.replace(reg, val);
    }

    return name;
  },
  // Default cursor mode
  xmode: function xmode() {
    return this.is_mobile ? 'explore' : 'default';
  },
  default_prevented: function default_prevented(event) {
    if (event.original) {
      return event.original.defaultPrevented;
    }

    return event.defaultPrevented;
  },
  // WTF with modern web development
  is_mobile: function (w) {
    return 'onorientationchange' in w && (!!navigator.maxTouchPoints || !!navigator.msMaxTouchPoints || 'ontouchstart' in w || w.DocumentTouch && document instanceof w.DocumentTouch);
  }(typeof window !== 'undefined' ? window : {})
});

/***/ }),

/***/ "./node_modules/laravel-mix/node_modules/css-loader/dist/cjs.js??clonedRuleSet-65[0].rules[0].use[1]!./node_modules/vue-loader/lib/loaders/stylePostLoader.js!./node_modules/postcss-loader/dist/cjs.js??clonedRuleSet-65[0].rules[0].use[2]!./node_modules/vue-loader/lib/index.js??vue-loader-options!./src/Main.vue?vue&type=style&index=0&lang=css&":
/*!**************************************************************************************************************************************************************************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/laravel-mix/node_modules/css-loader/dist/cjs.js??clonedRuleSet-65[0].rules[0].use[1]!./node_modules/vue-loader/lib/loaders/stylePostLoader.js!./node_modules/postcss-loader/dist/cjs.js??clonedRuleSet-65[0].rules[0].use[2]!./node_modules/vue-loader/lib/index.js??vue-loader-options!./src/Main.vue?vue&type=style&index=0&lang=css& ***!
  \**************************************************************************************************************************************************************************************************************************************************************************************************************************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _node_modules_laravel_mix_node_modules_css_loader_dist_runtime_cssWithMappingToString_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../node_modules/laravel-mix/node_modules/css-loader/dist/runtime/cssWithMappingToString.js */ "./node_modules/laravel-mix/node_modules/css-loader/dist/runtime/cssWithMappingToString.js");
/* harmony import */ var _node_modules_laravel_mix_node_modules_css_loader_dist_runtime_cssWithMappingToString_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_laravel_mix_node_modules_css_loader_dist_runtime_cssWithMappingToString_js__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _node_modules_laravel_mix_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../node_modules/laravel-mix/node_modules/css-loader/dist/runtime/api.js */ "./node_modules/laravel-mix/node_modules/css-loader/dist/runtime/api.js");
/* harmony import */ var _node_modules_laravel_mix_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_node_modules_laravel_mix_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__);
// Imports


var ___CSS_LOADER_EXPORT___ = _node_modules_laravel_mix_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default()((_node_modules_laravel_mix_node_modules_css_loader_dist_runtime_cssWithMappingToString_js__WEBPACK_IMPORTED_MODULE_0___default()));
// Module
___CSS_LOADER_EXPORT___.push([module.id, "\n.app-content {\n    padding: calc(2rem + 2.45rem) 0 0 0rem !important;\n    overflow-x: hidden;\n}\n@media (max-width: 767.98px){\nhtml body.navbar-sticky .app-content {\n        padding: calc(1rem - 0.8rem + 4.45rem) 0 0 0 !important;\n}\n}\n.flexed {\n    display: flex;\n    flex-direction: column;\n    align-items: center;\n    justify-content: center;\n    align-content: center;\n    flex-wrap: nowrap;\n}\n#app-conainer {\n    display: flex;\n    flex-direction: row;\n    justify-content: space-between;\n    align-content: space-between;\n    align-items: flex-start;\n    flex-wrap: nowrap;\n}\n\n/* @media (max-width: 767.98px){\n    #app-conainer {\n        display: flex;\n        flex-direction: column;\n        justify-content: space-between;\n        align-content: space-between;\n        align-items: flex-start;\n        flex-wrap: nowrap;\n    }\n} */\n#tradebar {\n    color: #ddd;\n}\n#tvjs-header {\n    position: absolute;\n    display: flex;\n    align-content: center;\n    flex-direction: row;\n    flex-wrap: nowrap;\n    justify-content: flex-start;\n    align-items: center;\n    padding-left: 70px;\n    height: 40px;\n    color: #ddd;\n    width: 100%;\n    background-color: #121826;\n}\n.night-mode {\n    position: absolute;\n    top: 15px;\n    right: 20px;\n}\n#trading-vue-js-grid-0-canvas,\n#trading-vue-js-sidebar-0-canvas,\n#trading-vue-js-grid-1-canvas,\n#trading-vue-js-sidebar-1-canvas,\n#trading-vue-js-botbar-canvas {\n    background-color: rgb(0 0 0 / 0%) !important;\n}\n#trading-vue-tbitem {\n    background-color: rgb(18, 24, 38);\n}\n@media only screen and (max-device-width: 480px) {\n.tf-selector {\n        top: 50px;\n        right: 140px;\n        max-width: 140px;\n        font: 12px -apple-system, BlinkMacSystemFont,\n            Segoe UI, Roboto, Oxygen, Ubuntu, Cantarell,\n            Fira Sans, Droid Sans, Helvetica Neue,\n            sans-serif;\n}\n}\n.box {\n    width: 280px;\n    margin: 0 auto;\n    box-shadow: 0 1.5px 5px -2px rgba(0, 0, 0, 0.2);\n    border-radius: 3px;\n    padding: 0 15px 0 15px;\n}\ntable {\n    font-size: 13px;\n    font-weight: 500;\n    color: rgb(183, 189, 198);\n    overflow: hidden;\n    width: 100%;\n}\ntd {\n    position: relative;\n    height: 20px;\n    line-height: 20px;\n}\ntd.price {\n    width: 30%;\n}\ntd.price span {\n    padding-left: 5px;\n}\ntd.quantity {\n    width: 30%;\n    text-align: right;\n}\ntd.time {\n    width: 40%;\n    text-align: right;\n    color: #999;\n    padding-right: 5px;\n}\ntd.btc {\n    width: 40%;\n    text-align: right;\n    padding-right: 5px;\n}\ntd span {\n    position: relative;\n    z-index: 2;\n}\ntable.asks .percent {\n    background-color: rgba(246, 70, 94, 0.2);\n}\ntable.bids .percent {\n    background-color: rgba(14, 203, 129, 0.2);\n}\ntd .percent {\n    position: absolute;\n    top: 0;\n    bottom: 0;\n    right: 0;\n}\n.newest {\n    border-bottom: 1px solid #eee;\n    margin: 15px -15px;\n}\n.card-110 {\n    top: 110px !important;\n    left: 70px;\n}\n/* Style page content - use this if you want to push the page content to the right when you open the side navigation */\n#main {\n    transition: margin-left .5s;\n    /* If you want a transition effect */\n}\n\n/* On smaller screens, where height is less than 450px, change the style of the sidenav (less padding and a smaller font size) */\n@media screen and (max-height: 450px) {\n.sidebar1 {\n        padding-top: 15px;\n}\n.sidebar1 a {\n        font-size: 18px;\n}\n}\n.btn-circle {\n    width: 30px;\n    height: 30px;\n    padding: 6px 0px;\n    border-radius: 15px;\n    font-size: 8px;\n    text-align: center;\n}\n#chartdiv {\n    min-height: 300px;\n    max-height: 400px;\n    height: 70vh;\n}\n", "",{"version":3,"sources":["webpack://./src/Main.vue"],"names":[],"mappings":";AAgTA;IACA,iDAAA;IACA,kBAAA;AACA;AACA;AACA;QACA,uDAAA;AACA;AACA;AACA;IACA,aAAA;IACA,sBAAA;IACA,mBAAA;IACA,uBAAA;IACA,qBAAA;IACA,iBAAA;AACA;AAEA;IACA,aAAA;IACA,mBAAA;IACA,8BAAA;IACA,4BAAA;IACA,uBAAA;IACA,iBAAA;AACA;;AAEA;;;;;;;;;GASA;AACA;IACA,WAAA;AACA;AAEA;IACA,kBAAA;IACA,aAAA;IACA,qBAAA;IACA,mBAAA;IACA,iBAAA;IACA,2BAAA;IACA,mBAAA;IACA,kBAAA;IACA,YAAA;IACA,WAAA;IACA,WAAA;IACA,yBAAA;AACA;AAEA;IACA,kBAAA;IACA,SAAA;IACA,WAAA;AACA;AAEA;;;;;IAKA,4CAAA;AACA;AAEA;IACA,iCAAA;AACA;AAEA;AACA;QACA,SAAA;QACA,YAAA;QACA,gBAAA;QACA;;;sBAGA;AACA;AACA;AAEA;IACA,YAAA;IACA,cAAA;IACA,+CAAA;IACA,kBAAA;IACA,sBAAA;AACA;AAEA;IACA,eAAA;IACA,gBAAA;IACA,yBAAA;IACA,gBAAA;IACA,WAAA;AACA;AAEA;IACA,kBAAA;IACA,YAAA;IACA,iBAAA;AACA;AAEA;IACA,UAAA;AACA;AAEA;IACA,iBAAA;AACA;AAEA;IACA,UAAA;IACA,iBAAA;AACA;AAEA;IACA,UAAA;IACA,iBAAA;IACA,WAAA;IACA,kBAAA;AACA;AAEA;IACA,UAAA;IACA,iBAAA;IACA,kBAAA;AACA;AAEA;IACA,kBAAA;IACA,UAAA;AACA;AAEA;IACA,wCAAA;AACA;AAEA;IACA,yCAAA;AACA;AAEA;IACA,kBAAA;IACA,MAAA;IACA,SAAA;IACA,QAAA;AACA;AAEA;IACA,6BAAA;IACA,kBAAA;AACA;AAEA;IACA,qBAAA;IACA,UAAA;AACA;AACA,sHAAA;AACA;IACA,2BAAA;IACA,oCAAA;AACA;;AAEA,gIAAA;AACA;AACA;QACA,iBAAA;AACA;AAEA;QACA,eAAA;AACA;AACA;AAEA;IACA,WAAA;IACA,YAAA;IACA,gBAAA;IACA,mBAAA;IACA,cAAA;IACA,kBAAA;AACA;AAEA;IACA,iBAAA;IACA,iBAAA;IACA,YAAA;AACA","sourcesContent":["<template>\n    <div class=\"flex-start col-10 col-xll-10 col-xl-10 col-lg-10 col-md-9 col-sm-12\">\n        <div id=\"tvjs-header\">\n            <a><span v-on:click=\"candles\" class=\"me-1 badge bg-light-secondary\"><i class=\"bi bi-bar-chart\" /><div class=\"d-md-inline d-none\">  Candles</div></span></a>\n            <a><span v-on:click=\"spline\" class=\"me-1 badge bg-light-secondary\"><i class=\"bi bi-graph-up\" /><div class=\"d-md-inline d-none\">  Spline</div></span></a>\n            <a><span id=\"toggleInfo\" class=\"me-1 badge bg-light-info\" data-bs-toggle=\"collapse\"\n                    data-bs-target=\"#collapseInfos\" aria-expanded=\"false\" aria-controls=\"collapseInfos\"><i\n                        class=\"bi bi-info-circle\" /><div class=\"d-md-inline d-none\">  Info</div></span></a>\n            <a><span id=\"toggleDepth\" class=\"me-1 badge bg-light-primary \" data-bs-toggle=\"collapse\"\n                    data-bs-target=\"#collapseDepth\" aria-expanded=\"false\" aria-controls=\"collapseDepth\"><i\n                        class=\"bi bi-kanban\" /><div class=\"d-md-inline d-none\">  Depth View</div></span></a>\n            <a><span id=\"toggleOrders\" class=\"me-1 badge bg-light-warning \" data-bs-toggle=\"collapse\"\n            data-bs-target=\"#collapseOrders\" aria-expanded=\"false\" aria-controls=\"collapseOrders\"><i\n                        class=\"bi bi-file-bar-graph\" /><div class=\"d-md-inline d-none\">  Order Book</div></span></a>\n            </div>\n            <div id=\"collapseInfos\"\n                class=\"collapse col-lg-4 col-md-5 col-sm-6 position-absolute sticky-top card-110 \">\n                <div class=\"card\" style=\"background:#131722e6!important;box-shadow: 0 4px 24px 0 rgb(0 0 0 / 30%);\">\n                    <div class=\"card-header\">\n                        <div class=\"col-md-8\">\n                            <h4 class=\"card-title\">\n                                {{ symbol }}\n                            </h4>\n                        </div>\n                    </div>\n                    <div class=\"card-content\">\n                        <div class=\"card-body\">\n                            <div class=\"row\">\n                                <div class=\"col-8\">\n                                    <div id=\"show_b\" class=\"text-start fs-1\">\n                                        ...\n                                    </div>\n                                </div>\n                                <div class=\"col-4\">\n                                    <div id=\"show_p\" class=\"text-end\" style=\"font-size:14px;\">\n                                        ...\n                                    </div>\n                                    <div id=\"show_P\" class=\"text-end\" style=\"font-size:14px;\">\n                                        ...\n                                    </div>\n                                </div>\n                            </div>\n                            <div class=\"row mt-1\">\n                                <div id=\"myRangeColor\" class=\"progress\">\n                                    <div id=\"myRange\" class=\"progress-bar progress-bar-striped progress-bar-animated\"\n                                        role=\"progressbar\" aria-valuenow=\"50\" aria-valuemin=\"0\" aria-valuemax=\"100\"\n                                        style=\"width: 80%\" />\n                                </div>\n                            </div>\n                            <div class=\"row d-flex justify-content-between align-items-center\">\n                                <div id=\"show_l\" class=\"col text-start text-danger\" style=\"font-size:10px;\" />\n                                <div class=\"col text-dark text-center\" style=\"font-size:10px;\">\n                                    Day Range\n                                </div>\n                                <div id=\"show_h\" class=\"col text-end text-success\" style=\"font-size:10px;\" />\n                            </div>\n                            <div class=\"row mt-1\">\n                                <small class=\"col text-start text-dark clearfix\">Volume 24H</small>\n                                <small id=\"show_v\" class=\"col text-end text-warning clearfix\" />\n                                <hr>\n                            </div>\n                            <div class=\"row\">\n                                <small class=\"col text-start text-dark clearfix\">Market Cap</small>\n                                <small id=\"show_mc\" class=\"col text-end text-warning clearfix\" />\n                                <hr>\n                            </div>\n\n                            <div class=\"row\">\n                                <small class=\"col text-start text-dark clearfix\">Total Supply</small>\n                                <small id=\"show_ts\" class=\"col text-end text-warning clearfix\" />\n                                <hr>\n                            </div>\n                        </div>\n                    </div>\n                </div>\n            </div>\n            <div id=\"collapseDepth\"\n                class=\"collapse col-lg-6 col-md-10 col-sm-12 col-12 position-absolute sticky-top card-110 \">\n                <div class=\"card\" style=\"background:#131722e6!important;box-shadow: 0 4px 24px 0 rgb(0 0 0 / 30%);\">\n                    <div class=\"card-content\">\n                        <div id=\"chartdiv\"></div>\n                    </div>\n                </div>\n            </div>\n            <div id=\"collapseOrders\"\n                class=\"collapse col-lg-4 col-md-4 col-sm-6 col-12 position-absolute sticky-top card-110\" style=\"max-width:280px;\">\n                <div class=\"card\" style=\"background:#131722e6!important;box-shadow: 0 4px 24px 0 rgb(0 0 0 / 30%);\">\n                    <div class=\"card-content my-1\">\n                        <div class=\"box\">\n                            <table>\n                                <thead>\n                                    <tr class=\"mb-1\">\n                                        <th class=\"text-start ps-1 text-dark\">\n                                            Price\n                                        </th>\n                                        <th class=\"text-center ps-1 text-dark\">\n                                            Quantity\n                                        </th>\n                                        <th class=\"text-end pe-1 text-dark\">\n                                            Total\n                                        </th>\n                                    </tr>\n                                </thead>\n                            </table>\n                            <table class=\"asks\" />\n                            <div class=\"newest\" />\n                            <table class=\"bids\" />\n                        </div>\n                    </div>\n                </div>\n            </div>\n        <div class=\"app-container\" style=\"margin-top:40px;\">\n            <trading-vue :key=\"resetkey\" ref=\"tvjs\" :data=\"dc\" :width=\"width\" :height=\"height\" :title-txt=\"title\"\n                color-title=\"#ff9f43\" :legend-buttons=\"['display', 'settings', 'up', 'down', 'add', 'remove']\"\n                :chart-config=\"{DEFAULT_LEN:60,MIN_ZOOM:1}\" :toolbar=\"true\" :color-back=\"colors.colorBack\"\n                :color-grid=\"colors.colorGrid\" :color-text=\"colors.colorText\" :extensions=\"ext\" :overlays=\"ovs\"\n                :night=\"night\" :resetkey=\"resetkey\" :x-settings=\"xsett\" :timezone=\"timezone\" />\n        </div>\n    </div>\n</template>\n\n<script>\nimport { TradingVue, DataCube } from 'trading-vue-js'\nimport Overlays from 'tvjs-overlays'\nimport Data from '../resources/data/data.json'\nimport Utils from './stuff/utils.js'\nimport Const from './stuff/constants.js'\nimport Stream from './stream.js'\nimport Extensions from './index_dev'\nimport txt from 'raw-loader!../resources/assets/cors.txt';\n// Gettin' data through webpeck proxy\nconst symbolsm = window.location.pathname.toLowerCase().split('/')[3]\nconst symbolbg = window.location.pathname.toUpperCase().split('/')[3]\nconst pairsm = window.location.pathname.toLowerCase().split('/')[4]\nconst pairbg = window.location.pathname.toUpperCase().split('/')[4]\nconst URL = txt+'https://api.binance.com/api/v1/klines?symbol='\nconst WSS = `wss://stream.binance.com:9443/ws/${symbolsm}${pairsm}@aggTrade`\nconst datas = `datasets.binance-${symbolsm}${pairsm}`\n//const PORT = location.port\n//const URL = `http://localhost:${PORT}/api/v1/klines?symbol=`\n//const WSS = `ws://localhost:${PORT}/ws/${symbolsm}@aggTrade`\n\nexport default {\n    name: 'App',\n    components: {\n        TradingVue\n    },\n    data() {\n        return {\n            dc: new DataCube(Data),\n            title: symbolbg + pairbg,\n            width: 0,\n            height: 0,\n            log_scale: true,\n            symbol: symbolbg + pairbg,\n            index_based: true,\n            timezone: this.timezoned(),\n            xsett: {\n                'grid-resize': { min_height: 30 }\n            },\n            ovs: Object.values(Overlays),\n            ext: Object.values(Extensions),\n            night: true,\n            top: 50,\n            resetkey: 0\n        }\n    },\n    computed: {\n        colors() {\n            return this.night ? {} : {\n                colorBack: '#fff',\n                colorGrid: '#eee',\n                colorText: '#333'\n            }\n        }\n    },\n    mounted() {\n        window.addEventListener('resize', this.onResize)\n        let q = this.win_query()\n        if (q.nm === 'false') this.night = false\n        if (q.ov) this.current = q.ov\n        if (q.header === 'false') this.top = 0\n        this.onResize(),\n        window.dc = this.dc\n        window.tv = this.$refs.tvjs\n        // Load the last data chunk & init DataCube:\n        let now = Utils.now()\n        this.load_chunk([now - Const.HOUR4, now]).then(data => {\n            dc.data.chart.data = data['chart.data']\n            // Register onrange callback & And a stream of trades\n            this.dc.onrange(this.load_chunk)\n            this.stream = new Stream(WSS)\n            this.stream.ontrades = this.on_trades\n            window.dc = this.chart      // Debug\n            window.tv = this.$refs.tvjs // Debug\n        })\n    },\n    beforeDestroy() {\n        window.removeEventListener('resize', this.onResize)\n        if (this.stream) this.stream.off()\n    },\n    methods: {\n        onResize() {\n            if (window.innerWidth > '992') {\n                this.width = (window.innerWidth - (window.innerWidth * 0.21))\n            } else if (window.innerWidth > '768'  && window.innerWidth <= '992') {\n                this.width = (window.innerWidth - (window.innerWidth * 0.26))\n            } else {\n                this.width = (window.innerWidth - 15)\n            }\n            this.height = window.innerHeight * 0.80\n        },\n        spline () {\n            this.dc.data.chart.type = \"Spline\"\n            this.dc.data.chart.tf = \"1m\"\n            this.$refs.tvjs.resetChart()\n        },\n        candles () {\n            this.dc.data.chart.type = \"Candles\"\n            this.dc.data.chart.tf = \"1m\"\n            this.$refs.tvjs.resetChart()\n        },\n        xbars () {\n            this.data.ovs = 'XOhlcBars'\n            this.dc.data.chart.tf = \"1m\"\n            this.$refs.tvjs.resetChart()\n        },\n        trade () {\n            this.dc.data.chart.type = \"Spline\"\n        },\n        win_query() {\n            let qs = (function(a) {\n                if (a == \"\") return {};\n                var b = {};\n                for (var i = 0; i < a.length; ++i) {\n                    var p=a[i].split('=', 2);\n                    if (p.length == 1)\n                        b[p[0]] = \"\";\n                    else\n                        b[p[0]] = decodeURIComponent(p[1].replace(/\\+/g, \" \"));\n                }\n                return b;\n            })(window.location.search.substr(1).split('&'));\n            return qs\n        },\n        reset(state) {\n            let sub = Object.keys(state).filter(x => state[x])\n            this.extensions = sub.map(x => Extensions[x])\n            this.resetkey++\n        },\n        onselect(id) {\n            this.current = id\n        },\n        timezoned() {\n            var offset = new Date().getTimezoneOffset();\n            var minutes = Math.abs(offset);\n            var hours = Math.floor(minutes / 60);\n            var prefix = offset < 0 ? \"\" : \"-\";\n            return parseInt(prefix+hours);\n        },\n        // New data handler. Should return Promise, or\n        // use callback: load_chunk(range, tf, callback)\n        async load_chunk(range) {\n            let [t1, t2] = range\n            let x = symbolbg\n            let y = pairbg\n            let q = `${x}${y}&interval=1m&startTime=${t1}&endTime=${t2}`\n            let r = await fetch(URL + q).then(r => r.json())\n            return this.format(this.parse_binance(r))\n        },\n        // Parse a specific exchange format\n        parse_binance(data) {\n            if (!Array.isArray(data)) return []\n            return data.map(x => {\n                for (var i = 0; i < x.length; i++) {\n                    x[i] = parseFloat(x[i])\n                }\n                return x.slice(0,6)\n            })\n        },\n        format(data) {\n            return {\n                'chart.data': data,\n            }\n        },\n        on_trades(trade) {\n            this.dc.update({\n                t: trade.T,     // Exchange time (optional)\n                price: parseFloat(trade.p),   // Trade price\n                volume: parseFloat(trade.q),  // Trade amount\n                datas : [ // Update dataset\n                    trade.T,\n                    trade.m ? 0 : 1,          // Sell or Buy\n                    parseFloat(trade.q),\n                    parseFloat(trade.p)\n                ],\n                // ... other onchart/offchart updates\n            })\n        }\n    }\n}\n</script>\n\n<style>\n.app-content {\n    padding: calc(2rem + 2.45rem) 0 0 0rem !important;\n    overflow-x: hidden;\n}\n@media (max-width: 767.98px){\n    html body.navbar-sticky .app-content {\n        padding: calc(1rem - 0.8rem + 4.45rem) 0 0 0 !important;\n    }\n}\n.flexed {\n    display: flex;\n    flex-direction: column;\n    align-items: center;\n    justify-content: center;\n    align-content: center;\n    flex-wrap: nowrap;\n}\n\n#app-conainer {\n    display: flex;\n    flex-direction: row;\n    justify-content: space-between;\n    align-content: space-between;\n    align-items: flex-start;\n    flex-wrap: nowrap;\n}\n\n/* @media (max-width: 767.98px){\n    #app-conainer {\n        display: flex;\n        flex-direction: column;\n        justify-content: space-between;\n        align-content: space-between;\n        align-items: flex-start;\n        flex-wrap: nowrap;\n    }\n} */\n#tradebar {\n    color: #ddd;\n}\n\n#tvjs-header {\n    position: absolute;\n    display: flex;\n    align-content: center;\n    flex-direction: row;\n    flex-wrap: nowrap;\n    justify-content: flex-start;\n    align-items: center;\n    padding-left: 70px;\n    height: 40px;\n    color: #ddd;\n    width: 100%;\n    background-color: #121826;\n}\n\n.night-mode {\n    position: absolute;\n    top: 15px;\n    right: 20px;\n}\n\n#trading-vue-js-grid-0-canvas,\n#trading-vue-js-sidebar-0-canvas,\n#trading-vue-js-grid-1-canvas,\n#trading-vue-js-sidebar-1-canvas,\n#trading-vue-js-botbar-canvas {\n    background-color: rgb(0 0 0 / 0%) !important;\n}\n\n#trading-vue-tbitem {\n    background-color: rgb(18, 24, 38);\n}\n\n@media only screen and (max-device-width: 480px) {\n    .tf-selector {\n        top: 50px;\n        right: 140px;\n        max-width: 140px;\n        font: 12px -apple-system, BlinkMacSystemFont,\n            Segoe UI, Roboto, Oxygen, Ubuntu, Cantarell,\n            Fira Sans, Droid Sans, Helvetica Neue,\n            sans-serif;\n    }\n}\n\n.box {\n    width: 280px;\n    margin: 0 auto;\n    box-shadow: 0 1.5px 5px -2px rgba(0, 0, 0, 0.2);\n    border-radius: 3px;\n    padding: 0 15px 0 15px;\n}\n\ntable {\n    font-size: 13px;\n    font-weight: 500;\n    color: rgb(183, 189, 198);\n    overflow: hidden;\n    width: 100%;\n}\n\ntd {\n    position: relative;\n    height: 20px;\n    line-height: 20px;\n}\n\ntd.price {\n    width: 30%;\n}\n\ntd.price span {\n    padding-left: 5px;\n}\n\ntd.quantity {\n    width: 30%;\n    text-align: right;\n}\n\ntd.time {\n    width: 40%;\n    text-align: right;\n    color: #999;\n    padding-right: 5px;\n}\n\ntd.btc {\n    width: 40%;\n    text-align: right;\n    padding-right: 5px;\n}\n\ntd span {\n    position: relative;\n    z-index: 2;\n}\n\ntable.asks .percent {\n    background-color: rgba(246, 70, 94, 0.2);\n}\n\ntable.bids .percent {\n    background-color: rgba(14, 203, 129, 0.2);\n}\n\ntd .percent {\n    position: absolute;\n    top: 0;\n    bottom: 0;\n    right: 0;\n}\n\n.newest {\n    border-bottom: 1px solid #eee;\n    margin: 15px -15px;\n}\n\n.card-110 {\n    top: 110px !important;\n    left: 70px;\n}\n/* Style page content - use this if you want to push the page content to the right when you open the side navigation */\n#main {\n    transition: margin-left .5s;\n    /* If you want a transition effect */\n}\n\n/* On smaller screens, where height is less than 450px, change the style of the sidenav (less padding and a smaller font size) */\n@media screen and (max-height: 450px) {\n    .sidebar1 {\n        padding-top: 15px;\n    }\n\n    .sidebar1 a {\n        font-size: 18px;\n    }\n}\n\n.btn-circle {\n    width: 30px;\n    height: 30px;\n    padding: 6px 0px;\n    border-radius: 15px;\n    font-size: 8px;\n    text-align: center;\n}\n\n#chartdiv {\n    min-height: 300px;\n    max-height: 400px;\n    height: 70vh;\n}\n</style>\n"],"sourceRoot":""}]);
// Exports
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (___CSS_LOADER_EXPORT___);


/***/ }),

/***/ "./node_modules/laravel-mix/node_modules/css-loader/dist/cjs.js??clonedRuleSet-65[0].rules[0].use[1]!./node_modules/vue-loader/lib/loaders/stylePostLoader.js!./node_modules/postcss-loader/dist/cjs.js??clonedRuleSet-65[0].rules[0].use[2]!./node_modules/vue-loader/lib/index.js??vue-loader-options!./src/components/StdInput.vue?vue&type=style&index=0&lang=css&":
/*!*****************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/laravel-mix/node_modules/css-loader/dist/cjs.js??clonedRuleSet-65[0].rules[0].use[1]!./node_modules/vue-loader/lib/loaders/stylePostLoader.js!./node_modules/postcss-loader/dist/cjs.js??clonedRuleSet-65[0].rules[0].use[2]!./node_modules/vue-loader/lib/index.js??vue-loader-options!./src/components/StdInput.vue?vue&type=style&index=0&lang=css& ***!
  \*****************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _node_modules_laravel_mix_node_modules_css_loader_dist_runtime_cssWithMappingToString_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../node_modules/laravel-mix/node_modules/css-loader/dist/runtime/cssWithMappingToString.js */ "./node_modules/laravel-mix/node_modules/css-loader/dist/runtime/cssWithMappingToString.js");
/* harmony import */ var _node_modules_laravel_mix_node_modules_css_loader_dist_runtime_cssWithMappingToString_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_laravel_mix_node_modules_css_loader_dist_runtime_cssWithMappingToString_js__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _node_modules_laravel_mix_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../node_modules/laravel-mix/node_modules/css-loader/dist/runtime/api.js */ "./node_modules/laravel-mix/node_modules/css-loader/dist/runtime/api.js");
/* harmony import */ var _node_modules_laravel_mix_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_node_modules_laravel_mix_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__);
// Imports


var ___CSS_LOADER_EXPORT___ = _node_modules_laravel_mix_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default()((_node_modules_laravel_mix_node_modules_css_loader_dist_runtime_cssWithMappingToString_js__WEBPACK_IMPORTED_MODULE_0___default()));
// Module
___CSS_LOADER_EXPORT___.push([module.id, "\n.tvjs-std-input {\r\n    margin: 5px;\r\n    background-color: #161b27;\r\n    border: 1px dotted #353940;\r\n    height: 22px;\r\n    border-radius: 3px;\r\n    padding: 2px 0px 3px 10px;\r\n    color: whitesmoke;\r\n    font-size: 1.2em;\r\n    outline: none;\r\n    width: 100px;\n}\nselect.tvjs-std-input {\r\n    height: 29px;\r\n    -moz-appearance: none;\n}\nselect.tvjs-std-input  {\r\n    //display: none; /*hide original SELECT element: */\n}\n.tvjs-std-input::-moz-placeholder {\r\n    color: #8e909a;\r\n    opacity: 0.25;\n}\n.tvjs-std-input:-ms-input-placeholder {\r\n    color: #8e909a;\r\n    opacity: 0.25;\n}\n.tvjs-std-input::placeholder {\r\n    color: #8e909a;\r\n    opacity: 0.25;\n}\r\n", "",{"version":3,"sources":["webpack://./src/components/StdInput.vue"],"names":[],"mappings":";AA4CA;IACA,WAAA;IACA,yBAAA;IACA,0BAAA;IACA,YAAA;IACA,kBAAA;IACA,yBAAA;IACA,iBAAA;IACA,gBAAA;IACA,aAAA;IACA,YAAA;AACA;AAEA;IACA,YAAA;IACA,qBAAA;AAEA;AAEA;IACA,eAAA,EAAA,iCAAA;AACA;AAGA;IACA,cAAA;IACA,aAAA;AACA;AAHA;IACA,cAAA;IACA,aAAA;AACA;AAHA;IACA,cAAA;IACA,aAAA;AACA","sourcesContent":["<template>\r\n    <span>\r\n        <input\nv-if=\"type==='text' || !type\"\r\n            :value=\"value\"\nclass=\"tvjs-std-input\"\n:style=\"style\"\r\n            :placeholder=\"name\"\r\n            @change=\"$emit('change', $event.target.value)\"\r\n            @input=\"$emit('input', $event.target.value)\"\n>\r\n        <select\nv-else-if=\"type==='select'\"\r\n            class=\"tvjs-std-input\"\n:style=\"style\"\r\n            :value=\"value\"\r\n            @input=\"$emit('input', $event.target.value)\"\n>\r\n            <option v-for=\"opt in list\">{{ opt }}</option>\r\n        </select>\r\n    </span>\r\n</template>\r\n\r\n<script>\r\nexport default {\r\n    name: 'StdInput',\r\n    props: ['value', 'name', 'type', 'list', 'colors'],\r\n    data() {\r\n        return {\r\n        }\r\n    },\r\n    computed: {\r\n        style() {\r\n            return {\r\n                //background: this.$props.colors.back,\r\n                //color: this.$props.colors.text\r\n            }\r\n        }\r\n    },\r\n    methods: {}\r\n}\r\n</script>\r\n\r\n<style>\r\n.tvjs-std-input {\r\n    margin: 5px;\r\n    background-color: #161b27;\r\n    border: 1px dotted #353940;\r\n    height: 22px;\r\n    border-radius: 3px;\r\n    padding: 2px 0px 3px 10px;\r\n    color: whitesmoke;\r\n    font-size: 1.2em;\r\n    outline: none;\r\n    width: 100px;\r\n}\r\n\r\nselect.tvjs-std-input {\r\n    height: 29px;\r\n    -moz-appearance: none;\r\n\r\n}\r\n\r\nselect.tvjs-std-input  {\r\n    //display: none; /*hide original SELECT element: */\r\n}\r\n\r\n\r\n.tvjs-std-input::placeholder {\r\n    color: #8e909a;\r\n    opacity: 0.25;\r\n}\r\n</style>\r\n"],"sourceRoot":""}]);
// Exports
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (___CSS_LOADER_EXPORT___);


/***/ }),

/***/ "./node_modules/laravel-mix/node_modules/css-loader/dist/cjs.js??clonedRuleSet-65[0].rules[0].use[1]!./node_modules/vue-loader/lib/loaders/stylePostLoader.js!./node_modules/postcss-loader/dist/cjs.js??clonedRuleSet-65[0].rules[0].use[2]!./node_modules/vue-loader/lib/index.js??vue-loader-options!./src/components/Window.vue?vue&type=style&index=0&lang=css&":
/*!***************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/laravel-mix/node_modules/css-loader/dist/cjs.js??clonedRuleSet-65[0].rules[0].use[1]!./node_modules/vue-loader/lib/loaders/stylePostLoader.js!./node_modules/postcss-loader/dist/cjs.js??clonedRuleSet-65[0].rules[0].use[2]!./node_modules/vue-loader/lib/index.js??vue-loader-options!./src/components/Window.vue?vue&type=style&index=0&lang=css& ***!
  \***************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _node_modules_laravel_mix_node_modules_css_loader_dist_runtime_cssWithMappingToString_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../node_modules/laravel-mix/node_modules/css-loader/dist/runtime/cssWithMappingToString.js */ "./node_modules/laravel-mix/node_modules/css-loader/dist/runtime/cssWithMappingToString.js");
/* harmony import */ var _node_modules_laravel_mix_node_modules_css_loader_dist_runtime_cssWithMappingToString_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_laravel_mix_node_modules_css_loader_dist_runtime_cssWithMappingToString_js__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _node_modules_laravel_mix_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../node_modules/laravel-mix/node_modules/css-loader/dist/runtime/api.js */ "./node_modules/laravel-mix/node_modules/css-loader/dist/runtime/api.js");
/* harmony import */ var _node_modules_laravel_mix_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_node_modules_laravel_mix_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__);
// Imports


var ___CSS_LOADER_EXPORT___ = _node_modules_laravel_mix_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default()((_node_modules_laravel_mix_node_modules_css_loader_dist_runtime_cssWithMappingToString_js__WEBPACK_IMPORTED_MODULE_0___default()));
// Module
___CSS_LOADER_EXPORT___.push([module.id, "\n.tvjs-x-window {\r\n    position: absolute;\r\n    background: #1b202def;\r\n    border-radius: 3px;\r\n    pointer-events: all;\r\n    padding-left: 7px;\r\n    z-index: 100;\r\n    color: #dedddd;\n}\n.tvjs-x-window-head {\r\n    font-size: 2em;\r\n    -webkit-user-select: none;\r\n       -moz-user-select: none;\r\n        -ms-user-select: none;\r\n            user-select: none;\r\n    display: flex;\r\n    flex-direction: row;\r\n    flex-wrap: nowrap;\r\n    justify-content: flex-start;\r\n    align-content: center;\r\n    align-items: center;\r\n    height: 36px;\r\n    padding: 10px;\r\n    cursor: -webkit-grab;\r\n    cursor: grab;\n}\n.tvjs-x-window-body {\r\n    padding: 10px;\r\n    font-size: 1.1em;\n}\n.tvjs-x-window-title {\r\n    width: 300px;\r\n    -webkit-user-select: none;\r\n       -moz-user-select: none;\r\n        -ms-user-select: none;\r\n            user-select: none;\n}\n.tvjs-x-window-close {\r\n    width: 26px;\r\n    cursor: pointer;\r\n    margin: -1em;\r\n    padding: 1em;\r\n    font-size: 0.75em;\n}\r\n", "",{"version":3,"sources":["webpack://./src/components/Window.vue"],"names":[],"mappings":";AAgEA;IACA,kBAAA;IACA,qBAAA;IACA,kBAAA;IACA,mBAAA;IACA,iBAAA;IACA,YAAA;IACA,cAAA;AACA;AACA;IACA,cAAA;IACA,yBAAA;OAAA,sBAAA;QAAA,qBAAA;YAAA,iBAAA;IACA,aAAA;IACA,mBAAA;IACA,iBAAA;IACA,2BAAA;IACA,qBAAA;IACA,mBAAA;IACA,YAAA;IACA,aAAA;IACA,oBAAA;IAAA,YAAA;AACA;AAEA;IACA,aAAA;IACA,gBAAA;AACA;AACA;IACA,YAAA;IACA,yBAAA;OAAA,sBAAA;QAAA,qBAAA;YAAA,iBAAA;AACA;AACA;IACA,WAAA;IACA,eAAA;IACA,YAAA;IACA,YAAA;IACA,iBAAA;AACA","sourcesContent":["<template>\r\n    <div\nref=\"win\"\nclass=\"tvjs-x-window\"\n:style=\"style\"\n>\r\n        <div class=\"tvjs-x-window-head\">\r\n            <div\nclass=\"tvjs-x-window-title\"\r\n                @mousedown=\"onMouseDown\"\n>\r\n                {{ title }}\r\n            </div>\r\n            <div\nclass=\"tvjs-x-window-close\"\r\n                @click=\"$emit('close')\"\n>\r\n                \r\n            </div>\r\n        </div>\r\n        <div class=\"tvjs-x-window-body\">\r\n            <slot />\r\n        </div>\r\n    </div>\r\n</template>\r\n<script>\r\n\r\nimport Dragg from './dragg.js'\r\n\r\nexport default {\r\n    name: 'Window',\r\n    mixins: [Dragg],\r\n    props: ['title', 'tv'],\r\n    data() {\r\n        return {\r\n            ww: 0,\r\n            wh: 0,\r\n            x: 0,\r\n            y: 0\r\n        }\r\n    },\r\n    computed: {\r\n        style() {\r\n            return {\r\n                top: `${this.y}px`,\r\n                left: `${this.x}px`\r\n            }\r\n        },\r\n        tvw() {\r\n            return this.$props.tv.width\r\n        },\r\n        tvh() {\r\n            return this.$props.tv.height\r\n        }\r\n    },\r\n    mounted() {\r\n        this.ww = this.$refs.win.clientWidth\r\n        this.wh = this.$refs.win.clientHeight\r\n        this.x = this.tvw * 0.5 - this.ww * 0.5\r\n        this.y = this.tvh * 0.5 - this.wh * 0.5\r\n    }\r\n}\r\n</script>\r\n<style>\r\n.tvjs-x-window {\r\n    position: absolute;\r\n    background: #1b202def;\r\n    border-radius: 3px;\r\n    pointer-events: all;\r\n    padding-left: 7px;\r\n    z-index: 100;\r\n    color: #dedddd;\r\n}\r\n.tvjs-x-window-head {\r\n    font-size: 2em;\r\n    user-select: none;\r\n    display: flex;\r\n    flex-direction: row;\r\n    flex-wrap: nowrap;\r\n    justify-content: flex-start;\r\n    align-content: center;\r\n    align-items: center;\r\n    height: 36px;\r\n    padding: 10px;\r\n    cursor: grab;\r\n}\r\n\r\n.tvjs-x-window-body {\r\n    padding: 10px;\r\n    font-size: 1.1em;\r\n}\r\n.tvjs-x-window-title {\r\n    width: 300px;\r\n    user-select: none;\r\n}\r\n.tvjs-x-window-close {\r\n    width: 26px;\r\n    cursor: pointer;\r\n    margin: -1em;\r\n    padding: 1em;\r\n    font-size: 0.75em;\r\n}\r\n</style>\r\n"],"sourceRoot":""}]);
// Exports
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (___CSS_LOADER_EXPORT___);


/***/ }),

/***/ "./node_modules/laravel-mix/node_modules/css-loader/dist/cjs.js??clonedRuleSet-65[0].rules[0].use[1]!./node_modules/vue-loader/lib/loaders/stylePostLoader.js!./node_modules/postcss-loader/dist/cjs.js??clonedRuleSet-65[0].rules[0].use[2]!./node_modules/vue-loader/lib/index.js??vue-loader-options!./src/extensions/grid-resize/Splitter.vue?vue&type=style&index=0&id=189fccad&scoped=true&lang=css&":
/*!*****************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/laravel-mix/node_modules/css-loader/dist/cjs.js??clonedRuleSet-65[0].rules[0].use[1]!./node_modules/vue-loader/lib/loaders/stylePostLoader.js!./node_modules/postcss-loader/dist/cjs.js??clonedRuleSet-65[0].rules[0].use[2]!./node_modules/vue-loader/lib/index.js??vue-loader-options!./src/extensions/grid-resize/Splitter.vue?vue&type=style&index=0&id=189fccad&scoped=true&lang=css& ***!
  \*****************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _node_modules_laravel_mix_node_modules_css_loader_dist_runtime_cssWithMappingToString_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../node_modules/laravel-mix/node_modules/css-loader/dist/runtime/cssWithMappingToString.js */ "./node_modules/laravel-mix/node_modules/css-loader/dist/runtime/cssWithMappingToString.js");
/* harmony import */ var _node_modules_laravel_mix_node_modules_css_loader_dist_runtime_cssWithMappingToString_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_laravel_mix_node_modules_css_loader_dist_runtime_cssWithMappingToString_js__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _node_modules_laravel_mix_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../node_modules/laravel-mix/node_modules/css-loader/dist/runtime/api.js */ "./node_modules/laravel-mix/node_modules/css-loader/dist/runtime/api.js");
/* harmony import */ var _node_modules_laravel_mix_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_node_modules_laravel_mix_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__);
// Imports


var ___CSS_LOADER_EXPORT___ = _node_modules_laravel_mix_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default()((_node_modules_laravel_mix_node_modules_css_loader_dist_runtime_cssWithMappingToString_js__WEBPACK_IMPORTED_MODULE_0___default()));
// Module
___CSS_LOADER_EXPORT___.push([module.id, "\n.h-splitter[data-v-189fccad] {\r\n    position: absolute;\r\n    left: 0;\r\n    height: 5px;\r\n    margin-top: -2px;\r\n    width: 100%;\r\n    z-index: 1;\r\n    background-color: #3ee4afb5;\r\n    opacity: 0;\r\n    pointer-events: all;\n}\n.h-splitter[data-v-189fccad]:hover {\r\n    cursor: row-resize;\r\n    opacity: 1;\n}\r\n", "",{"version":3,"sources":["webpack://./src/extensions/grid-resize/Splitter.vue"],"names":[],"mappings":";AAkEA;IACA,kBAAA;IACA,OAAA;IACA,WAAA;IACA,gBAAA;IACA,WAAA;IACA,UAAA;IACA,2BAAA;IACA,UAAA;IACA,mBAAA;AACA;AACA;IACA,kBAAA;IACA,UAAA;AACA","sourcesContent":["<template>\r\n    <span\nclass=\"h-splitter\"\r\n        :style=\"hs_style\"\n@mousedown=\"hs_mousedown\"\n/>\r\n</template>\r\n<script>\r\n\r\nimport Utils from './utils.js'\r\n\r\nexport default {\r\n    name: 'Splitter',\r\n    props: ['id', 'main', 'dc', 'tv', 'data'],\r\n    computed: {\r\n        hs_style() {\r\n            return {\r\n                drag: null,\r\n                top: this.data.grid2.offset + 'px',\r\n                //backgroundColor: this.colors.splitter\r\n            }\r\n        },\r\n    },\r\n    mounted() {\r\n        this.MIN_HEIGHT = this.data.sett.min_height || 20\r\n    },\r\n    methods: {\r\n        hs_mousedown(e) {\r\n            this.drag = {\r\n                type: 'hs',\r\n                y: e.clientY,\r\n                h1: this.data.grid1.height,\r\n                h2: this.data.grid2.height\r\n            }\r\n            Utils.add_style('disable-user-select', `body * {\r\n                user-select: none;\r\n            }\r\n            .trading-vue-chart {\r\n                pointer-events: none;\r\n            }`)\r\n        },\r\n        hs_mouseup(e) {\r\n            this.drag = null\r\n            Utils.rem_style('disable-user-select')\r\n        },\r\n        hs_mousemove(e) {\r\n            if (this.drag) {\r\n                let off = e.clientY - this.drag.y\r\n                let new_h1 = this.drag.h1 + off\r\n                let new_h2 = this.drag.h2 - off\r\n                if (new_h1 > this.MIN_HEIGHT &&\r\n                    new_h2 > this.MIN_HEIGHT) {\r\n                    this.data.grid1.height = new_h1\r\n                    this.data.grid2.height = new_h2\r\n                }\r\n                this.main.calc_heights()\r\n            }\r\n        },\r\n        hs_mouseleave(e) {\r\n            this.drag = null\r\n            Utils.rem_style('disable-user-select')\r\n        }\r\n    }\r\n}\r\n</script>\r\n<style scoped>\r\n.h-splitter {\r\n    position: absolute;\r\n    left: 0;\r\n    height: 5px;\r\n    margin-top: -2px;\r\n    width: 100%;\r\n    z-index: 1;\r\n    background-color: #3ee4afb5;\r\n    opacity: 0;\r\n    pointer-events: all;\r\n}\r\n.h-splitter:hover {\r\n    cursor: row-resize;\r\n    opacity: 1;\r\n}\r\n</style>\r\n"],"sourceRoot":""}]);
// Exports
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (___CSS_LOADER_EXPORT___);


/***/ }),

/***/ "./node_modules/laravel-mix/node_modules/css-loader/dist/cjs.js??clonedRuleSet-65[0].rules[0].use[1]!./node_modules/vue-loader/lib/loaders/stylePostLoader.js!./node_modules/postcss-loader/dist/cjs.js??clonedRuleSet-65[0].rules[0].use[2]!./node_modules/vue-loader/lib/index.js??vue-loader-options!./src/extensions/legend-buttons/AddWin.vue?vue&type=style&index=0&id=53408ac7&scoped=true&lang=css&":
/*!******************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/laravel-mix/node_modules/css-loader/dist/cjs.js??clonedRuleSet-65[0].rules[0].use[1]!./node_modules/vue-loader/lib/loaders/stylePostLoader.js!./node_modules/postcss-loader/dist/cjs.js??clonedRuleSet-65[0].rules[0].use[2]!./node_modules/vue-loader/lib/index.js??vue-loader-options!./src/extensions/legend-buttons/AddWin.vue?vue&type=style&index=0&id=53408ac7&scoped=true&lang=css& ***!
  \******************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _node_modules_laravel_mix_node_modules_css_loader_dist_runtime_cssWithMappingToString_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../node_modules/laravel-mix/node_modules/css-loader/dist/runtime/cssWithMappingToString.js */ "./node_modules/laravel-mix/node_modules/css-loader/dist/runtime/cssWithMappingToString.js");
/* harmony import */ var _node_modules_laravel_mix_node_modules_css_loader_dist_runtime_cssWithMappingToString_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_laravel_mix_node_modules_css_loader_dist_runtime_cssWithMappingToString_js__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _node_modules_laravel_mix_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../node_modules/laravel-mix/node_modules/css-loader/dist/runtime/api.js */ "./node_modules/laravel-mix/node_modules/css-loader/dist/runtime/api.js");
/* harmony import */ var _node_modules_laravel_mix_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_node_modules_laravel_mix_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__);
// Imports


var ___CSS_LOADER_EXPORT___ = _node_modules_laravel_mix_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default()((_node_modules_laravel_mix_node_modules_css_loader_dist_runtime_cssWithMappingToString_js__WEBPACK_IMPORTED_MODULE_0___default()));
// Module
___CSS_LOADER_EXPORT___.push([module.id, "\n.tvjs-x-window.add-win[data-v-53408ac7] {\n    padding-bottom: 30px;\n    border: 1px solid #80808011;\n}\n.add-win-list[data-v-53408ac7] {\n    height: 300px;\n    overflow-x: hidden;\n    overflow-y: auto;\n    -webkit-user-select: none;\n       -moz-user-select: none;\n        -ms-user-select: none;\n            user-select: none;\n}\n/* Hide scrollbar for Chrome, Safari and Opera */\n.add-win-list[data-v-53408ac7]::-webkit-scrollbar {\n  display: none;\n}\n\n/* Hide scrollbar for IE, Edge and Firefox */\n.add-win-list[data-v-53408ac7] {\n  -ms-overflow-style: none;  /* IE and Edge */\n  scrollbar-width: none;  /* Firefox */\n}\n.add-win-item[data-v-53408ac7] {\n    color: #ffffff88;\n    width: 100%;\n    padding: 5px;\n    cursor: pointer;\n}\n.add-win-item[data-v-53408ac7]:hover {\n    background: #88888822;\n    color: #ffffffff;\n}\n.add-win-item-desc[data-v-53408ac7] {\n    color: #ffffff33;\n    margin-left: 3px;\n}\n.add-win-item:hover .add-win-item-desc[data-v-53408ac7] {\n    color: #ffffff44;\n}\n.add-win-empty[data-v-53408ac7] {\n    opacity: 0.5;\n}\n", "",{"version":3,"sources":["webpack://./src/extensions/legend-buttons/AddWin.vue"],"names":[],"mappings":";AAgDA;IACA,oBAAA;IACA,2BAAA;AACA;AACA;IACA,aAAA;IACA,kBAAA;IACA,gBAAA;IACA,yBAAA;OAAA,sBAAA;QAAA,qBAAA;YAAA,iBAAA;AACA;AACA,gDAAA;AACA;EACA,aAAA;AACA;;AAEA,4CAAA;AACA;EACA,wBAAA,GAAA,gBAAA;EACA,qBAAA,GAAA,YAAA;AACA;AACA;IACA,gBAAA;IACA,WAAA;IACA,YAAA;IACA,eAAA;AACA;AACA;IACA,qBAAA;IACA,gBAAA;AACA;AACA;IACA,gBAAA;IACA,gBAAA;AACA;AACA;IACA,gBAAA;AACA;AACA;IACA,YAAA;AACA","sourcesContent":["<template>\n    <window title=\"Add Indicator\" class=\"add-win\" :tv=\"tv\" @close=\"on_close\">\n        <div class=\"add-win-list\">\n            <div v-for=\"ov of ovs\" class=\"add-win-item\" @click=\"on_click(ov.name)\">\n                <span>{{ ov.name }}</span>\n                <span class=\"add-win-item-desc\">\n                    {{ ov.methods.meta_info().desc }}\n                </span>\n            </div>\n        </div>\n    </window>\n</template>\n<script>\n\nimport Window from '../../components/Window.vue'\n\nexport default {\n    name: 'AddWin',\n    components: { Window },\n    props: ['id', 'main', 'dc', 'tv', 'data'],\n    data() {\n        return {\n            ovs: this.tv.overlays.filter(x => x.methods.calc)\n        }\n    },\n    computed: {\n        sett() {\n            return this.$props.data.ov.settings\n        }\n    },\n    mounted() {\n    },\n    methods: {\n        on_close() {\n            this.$props.main.remove_widget(this.$props.id)\n        },\n        on_click(name) {\n            this.on_close()\n            this.main.add_overlay({\n                side: this.data.type,\n                index: this.data.index,\n                type: name\n            })\n        }\n    }\n}\n</script>\n<style scoped>\n.tvjs-x-window.add-win {\n    padding-bottom: 30px;\n    border: 1px solid #80808011;\n}\n.add-win-list {\n    height: 300px;\n    overflow-x: hidden;\n    overflow-y: auto;\n    user-select: none;\n}\n/* Hide scrollbar for Chrome, Safari and Opera */\n.add-win-list::-webkit-scrollbar {\n  display: none;\n}\n\n/* Hide scrollbar for IE, Edge and Firefox */\n.add-win-list {\n  -ms-overflow-style: none;  /* IE and Edge */\n  scrollbar-width: none;  /* Firefox */\n}\n.add-win-item {\n    color: #ffffff88;\n    width: 100%;\n    padding: 5px;\n    cursor: pointer;\n}\n.add-win-item:hover {\n    background: #88888822;\n    color: #ffffffff;\n}\n.add-win-item-desc {\n    color: #ffffff33;\n    margin-left: 3px;\n}\n.add-win-item:hover .add-win-item-desc {\n    color: #ffffff44;\n}\n.add-win-empty {\n    opacity: 0.5;\n}\n</style>\n"],"sourceRoot":""}]);
// Exports
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (___CSS_LOADER_EXPORT___);


/***/ }),

/***/ "./node_modules/laravel-mix/node_modules/css-loader/dist/cjs.js??clonedRuleSet-65[0].rules[0].use[1]!./node_modules/vue-loader/lib/loaders/stylePostLoader.js!./node_modules/postcss-loader/dist/cjs.js??clonedRuleSet-65[0].rules[0].use[2]!./node_modules/vue-loader/lib/index.js??vue-loader-options!./src/extensions/settings-win/SettingsWin.vue?vue&type=style&index=0&id=5d223b0e&scoped=true&lang=css&":
/*!*********************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/laravel-mix/node_modules/css-loader/dist/cjs.js??clonedRuleSet-65[0].rules[0].use[1]!./node_modules/vue-loader/lib/loaders/stylePostLoader.js!./node_modules/postcss-loader/dist/cjs.js??clonedRuleSet-65[0].rules[0].use[2]!./node_modules/vue-loader/lib/index.js??vue-loader-options!./src/extensions/settings-win/SettingsWin.vue?vue&type=style&index=0&id=5d223b0e&scoped=true&lang=css& ***!
  \*********************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _node_modules_laravel_mix_node_modules_css_loader_dist_runtime_cssWithMappingToString_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../node_modules/laravel-mix/node_modules/css-loader/dist/runtime/cssWithMappingToString.js */ "./node_modules/laravel-mix/node_modules/css-loader/dist/runtime/cssWithMappingToString.js");
/* harmony import */ var _node_modules_laravel_mix_node_modules_css_loader_dist_runtime_cssWithMappingToString_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_laravel_mix_node_modules_css_loader_dist_runtime_cssWithMappingToString_js__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _node_modules_laravel_mix_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../node_modules/laravel-mix/node_modules/css-loader/dist/runtime/api.js */ "./node_modules/laravel-mix/node_modules/css-loader/dist/runtime/api.js");
/* harmony import */ var _node_modules_laravel_mix_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_node_modules_laravel_mix_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__);
// Imports


var ___CSS_LOADER_EXPORT___ = _node_modules_laravel_mix_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default()((_node_modules_laravel_mix_node_modules_css_loader_dist_runtime_cssWithMappingToString_js__WEBPACK_IMPORTED_MODULE_0___default()));
// Module
___CSS_LOADER_EXPORT___.push([module.id, "\n.tvjs-x-window.sett-win[data-v-5d223b0e] {\n    padding-bottom: 30px;\n    border: 1px solid #80808011;\n}\n.sett-win-item[data-v-5d223b0e] {\n    display: flex;\n    flex-direction: row;\n    flex-wrap: nowrap;\n    justify-content: flex-start;\n    align-content: center;\n    align-items: center;\n}\n.sett-win-item label[data-v-5d223b0e] {\n    min-width: 80px;\n    color: #35a776;\n}\n.sett-win-empty[data-v-5d223b0e] {\n    opacity: 0.5;\n}\n", "",{"version":3,"sources":["webpack://./src/extensions/settings-win/SettingsWin.vue"],"names":[],"mappings":";AAsDA;IACA,oBAAA;IACA,2BAAA;AACA;AACA;IACA,aAAA;IACA,mBAAA;IACA,iBAAA;IACA,2BAAA;IACA,qBAAA;IACA,mBAAA;AACA;AACA;IACA,eAAA;IACA,cAAA;AACA;AACA;IACA,YAAA;AACA","sourcesContent":["<template>\n    <window :title=\"data.ov.name\" class=\"sett-win\" :tv=\"tv\" @close=\"on_close\">\n        <div v-for=\"k in settlist\" class=\"sett-win-item\">\n            <label>{{ s2d(k) }}</label>\n            <std-input :value=\"sett[k]\" @input=\"update_sett(k, $event)\" />\n        </div>\n        <span v-if=\"!settlist.length\" class=\"sett-win-empty\">\n            <i>No script settings</i>\n        </span>\n    </window>\n</template>\n<script>\n\nimport Window from '../../components/Window.vue'\nimport StdInput from '../../components/StdInput.vue'\nimport Utils from './utils.js'\n\nexport default {\n    name: 'SettingsWin',\n    components: { Window, StdInput },\n    props: ['id', 'main', 'dc', 'tv', 'data'],\n    computed: {\n        sett() {\n            return this.$props.data.ov.settings\n        },\n        settlist() {\n            return Object.keys(this.sett).filter(x =>\n                x[0] !== '$' && this.sett.$props &&\n                this.sett.$props.includes(x))\n        }\n    },\n    mounted() {\n    },\n    methods: {\n        s2d(str) {\n            return Utils.sett2desc(str)\n        },\n        on_close() {\n            this.$props.main.remove_widget(this.$props.id)\n        },\n        update_sett(k, val) {\n            let dcid = this.$props.data.ov.id\n\n            let valN = parseFloat(val)\n            if (valN !== valN) valN = val\n\n            this.$props.dc.merge(`${dcid}.settings`,\n                { [k]: valN }\n            )\n        }\n    }\n}\n</script>\n<style scoped>\n.tvjs-x-window.sett-win {\n    padding-bottom: 30px;\n    border: 1px solid #80808011;\n}\n.sett-win-item {\n    display: flex;\n    flex-direction: row;\n    flex-wrap: nowrap;\n    justify-content: flex-start;\n    align-content: center;\n    align-items: center;\n}\n.sett-win-item label {\n    min-width: 80px;\n    color: #35a776;\n}\n.sett-win-empty {\n    opacity: 0.5;\n}\n</style>\n"],"sourceRoot":""}]);
// Exports
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (___CSS_LOADER_EXPORT___);


/***/ }),

/***/ "./node_modules/laravel-mix/node_modules/css-loader/dist/runtime/api.js":
/*!******************************************************************************!*\
  !*** ./node_modules/laravel-mix/node_modules/css-loader/dist/runtime/api.js ***!
  \******************************************************************************/
/***/ ((module) => {

"use strict";


/*
  MIT License http://www.opensource.org/licenses/mit-license.php
  Author Tobias Koppers @sokra
*/
// css base code, injected by the css-loader
// eslint-disable-next-line func-names
module.exports = function (cssWithMappingToString) {
  var list = []; // return the list of modules as css string

  list.toString = function toString() {
    return this.map(function (item) {
      var content = cssWithMappingToString(item);

      if (item[2]) {
        return "@media ".concat(item[2], " {").concat(content, "}");
      }

      return content;
    }).join("");
  }; // import a list of modules into the list
  // eslint-disable-next-line func-names


  list.i = function (modules, mediaQuery, dedupe) {
    if (typeof modules === "string") {
      // eslint-disable-next-line no-param-reassign
      modules = [[null, modules, ""]];
    }

    var alreadyImportedModules = {};

    if (dedupe) {
      for (var i = 0; i < this.length; i++) {
        // eslint-disable-next-line prefer-destructuring
        var id = this[i][0];

        if (id != null) {
          alreadyImportedModules[id] = true;
        }
      }
    }

    for (var _i = 0; _i < modules.length; _i++) {
      var item = [].concat(modules[_i]);

      if (dedupe && alreadyImportedModules[item[0]]) {
        // eslint-disable-next-line no-continue
        continue;
      }

      if (mediaQuery) {
        if (!item[2]) {
          item[2] = mediaQuery;
        } else {
          item[2] = "".concat(mediaQuery, " and ").concat(item[2]);
        }
      }

      list.push(item);
    }
  };

  return list;
};

/***/ }),

/***/ "./node_modules/laravel-mix/node_modules/css-loader/dist/runtime/cssWithMappingToString.js":
/*!*************************************************************************************************!*\
  !*** ./node_modules/laravel-mix/node_modules/css-loader/dist/runtime/cssWithMappingToString.js ***!
  \*************************************************************************************************/
/***/ ((module) => {

"use strict";


function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function _iterableToArrayLimit(arr, i) { var _i = arr && (typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"]); if (_i == null) return; var _arr = []; var _n = true; var _d = false; var _s, _e; try { for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

module.exports = function cssWithMappingToString(item) {
  var _item = _slicedToArray(item, 4),
      content = _item[1],
      cssMapping = _item[3];

  if (!cssMapping) {
    return content;
  }

  if (typeof btoa === "function") {
    // eslint-disable-next-line no-undef
    var base64 = btoa(unescape(encodeURIComponent(JSON.stringify(cssMapping))));
    var data = "sourceMappingURL=data:application/json;charset=utf-8;base64,".concat(base64);
    var sourceMapping = "/*# ".concat(data, " */");
    var sourceURLs = cssMapping.sources.map(function (source) {
      return "/*# sourceURL=".concat(cssMapping.sourceRoot || "").concat(source, " */");
    });
    return [content].concat(sourceURLs).concat([sourceMapping]).join("\n");
  }

  return [content].join("\n");
};

/***/ }),

/***/ "./resources/scss/base/plugins/extensions/ext-component-ratings.scss":
/*!***************************************************************************!*\
  !*** ./resources/scss/base/plugins/extensions/ext-component-ratings.scss ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
// extracted by mini-css-extract-plugin


/***/ }),

/***/ "./resources/scss/base/plugins/extensions/ext-component-sliders.scss":
/*!***************************************************************************!*\
  !*** ./resources/scss/base/plugins/extensions/ext-component-sliders.scss ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
// extracted by mini-css-extract-plugin


/***/ }),

/***/ "./resources/scss/base/plugins/extensions/ext-component-sweet-alerts.scss":
/*!********************************************************************************!*\
  !*** ./resources/scss/base/plugins/extensions/ext-component-sweet-alerts.scss ***!
  \********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
// extracted by mini-css-extract-plugin


/***/ }),

/***/ "./resources/scss/base/plugins/extensions/ext-component-swiper.scss":
/*!**************************************************************************!*\
  !*** ./resources/scss/base/plugins/extensions/ext-component-swiper.scss ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
// extracted by mini-css-extract-plugin


/***/ }),

/***/ "./resources/scss/base/plugins/extensions/ext-component-toastr.scss":
/*!**************************************************************************!*\
  !*** ./resources/scss/base/plugins/extensions/ext-component-toastr.scss ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
// extracted by mini-css-extract-plugin


/***/ }),

/***/ "./resources/scss/base/plugins/extensions/ext-component-tour.scss":
/*!************************************************************************!*\
  !*** ./resources/scss/base/plugins/extensions/ext-component-tour.scss ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
// extracted by mini-css-extract-plugin


/***/ }),

/***/ "./resources/scss/base/plugins/extensions/ext-component-tree.scss":
/*!************************************************************************!*\
  !*** ./resources/scss/base/plugins/extensions/ext-component-tree.scss ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
// extracted by mini-css-extract-plugin


/***/ }),

/***/ "./resources/scss/base/plugins/forms/form-file-uploader.scss":
/*!*******************************************************************!*\
  !*** ./resources/scss/base/plugins/forms/form-file-uploader.scss ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
// extracted by mini-css-extract-plugin


/***/ }),

/***/ "./resources/scss/base/plugins/forms/form-number-input.scss":
/*!******************************************************************!*\
  !*** ./resources/scss/base/plugins/forms/form-number-input.scss ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
// extracted by mini-css-extract-plugin


/***/ }),

/***/ "./resources/scss/base/plugins/forms/form-quill-editor.scss":
/*!******************************************************************!*\
  !*** ./resources/scss/base/plugins/forms/form-quill-editor.scss ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
// extracted by mini-css-extract-plugin


/***/ }),

/***/ "./resources/scss/base/plugins/forms/form-validation.scss":
/*!****************************************************************!*\
  !*** ./resources/scss/base/plugins/forms/form-validation.scss ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
// extracted by mini-css-extract-plugin


/***/ }),

/***/ "./resources/scss/base/plugins/forms/form-wizard.scss":
/*!************************************************************!*\
  !*** ./resources/scss/base/plugins/forms/form-wizard.scss ***!
  \************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
// extracted by mini-css-extract-plugin


/***/ }),

/***/ "./resources/scss/base/plugins/forms/pickers/form-flat-pickr.scss":
/*!************************************************************************!*\
  !*** ./resources/scss/base/plugins/forms/pickers/form-flat-pickr.scss ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
// extracted by mini-css-extract-plugin


/***/ }),

/***/ "./resources/scss/base/plugins/forms/pickers/form-pickadate.scss":
/*!***********************************************************************!*\
  !*** ./resources/scss/base/plugins/forms/pickers/form-pickadate.scss ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
// extracted by mini-css-extract-plugin


/***/ }),

/***/ "./resources/scss/base/plugins/maps/map-leaflet.scss":
/*!***********************************************************!*\
  !*** ./resources/scss/base/plugins/maps/map-leaflet.scss ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
// extracted by mini-css-extract-plugin


/***/ }),

/***/ "./resources/scss/base/plugins/ui/coming-soon.scss":
/*!*********************************************************!*\
  !*** ./resources/scss/base/plugins/ui/coming-soon.scss ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
// extracted by mini-css-extract-plugin


/***/ }),

/***/ "./resources/scss/base/pages/app-calendar.scss":
/*!*****************************************************!*\
  !*** ./resources/scss/base/pages/app-calendar.scss ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
// extracted by mini-css-extract-plugin


/***/ }),

/***/ "./resources/scss/base/pages/app-chat-list.scss":
/*!******************************************************!*\
  !*** ./resources/scss/base/pages/app-chat-list.scss ***!
  \******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
// extracted by mini-css-extract-plugin


/***/ }),

/***/ "./resources/scss/base/pages/app-chat.scss":
/*!*************************************************!*\
  !*** ./resources/scss/base/pages/app-chat.scss ***!
  \*************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
// extracted by mini-css-extract-plugin


/***/ }),

/***/ "./resources/scss/base/pages/app-ecommerce-details.scss":
/*!**************************************************************!*\
  !*** ./resources/scss/base/pages/app-ecommerce-details.scss ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
// extracted by mini-css-extract-plugin


/***/ }),

/***/ "./resources/scss/base/pages/app-ecommerce.scss":
/*!******************************************************!*\
  !*** ./resources/scss/base/pages/app-ecommerce.scss ***!
  \******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
// extracted by mini-css-extract-plugin


/***/ }),

/***/ "./resources/scss/base/pages/app-email.scss":
/*!**************************************************!*\
  !*** ./resources/scss/base/pages/app-email.scss ***!
  \**************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
// extracted by mini-css-extract-plugin


/***/ }),

/***/ "./resources/scss/base/pages/app-file-manager.scss":
/*!*********************************************************!*\
  !*** ./resources/scss/base/pages/app-file-manager.scss ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
// extracted by mini-css-extract-plugin


/***/ }),

/***/ "./resources/scss/base/pages/app-invoice-list.scss":
/*!*********************************************************!*\
  !*** ./resources/scss/base/pages/app-invoice-list.scss ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
// extracted by mini-css-extract-plugin


/***/ }),

/***/ "./resources/scss/base/pages/app-invoice-print.scss":
/*!**********************************************************!*\
  !*** ./resources/scss/base/pages/app-invoice-print.scss ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
// extracted by mini-css-extract-plugin


/***/ }),

/***/ "./resources/scss/base/pages/app-invoice.scss":
/*!****************************************************!*\
  !*** ./resources/scss/base/pages/app-invoice.scss ***!
  \****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
// extracted by mini-css-extract-plugin


/***/ }),

/***/ "./resources/scss/base/pages/app-kanban.scss":
/*!***************************************************!*\
  !*** ./resources/scss/base/pages/app-kanban.scss ***!
  \***************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
// extracted by mini-css-extract-plugin


/***/ }),

/***/ "./resources/scss/base/pages/app-todo.scss":
/*!*************************************************!*\
  !*** ./resources/scss/base/pages/app-todo.scss ***!
  \*************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
// extracted by mini-css-extract-plugin


/***/ }),

/***/ "./resources/scss/base/pages/authentication.scss":
/*!*******************************************************!*\
  !*** ./resources/scss/base/pages/authentication.scss ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
// extracted by mini-css-extract-plugin


/***/ }),

/***/ "./resources/scss/base/pages/dashboard-ecommerce.scss":
/*!************************************************************!*\
  !*** ./resources/scss/base/pages/dashboard-ecommerce.scss ***!
  \************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
// extracted by mini-css-extract-plugin


/***/ }),

/***/ "./resources/scss/base/pages/modal-create-app.scss":
/*!*********************************************************!*\
  !*** ./resources/scss/base/pages/modal-create-app.scss ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
// extracted by mini-css-extract-plugin


/***/ }),

/***/ "./resources/scss/base/pages/page-blog.scss":
/*!**************************************************!*\
  !*** ./resources/scss/base/pages/page-blog.scss ***!
  \**************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
// extracted by mini-css-extract-plugin


/***/ }),

/***/ "./resources/scss/base/pages/page-coming-soon.scss":
/*!*********************************************************!*\
  !*** ./resources/scss/base/pages/page-coming-soon.scss ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
// extracted by mini-css-extract-plugin


/***/ }),

/***/ "./resources/scss/base/pages/page-faq.scss":
/*!*************************************************!*\
  !*** ./resources/scss/base/pages/page-faq.scss ***!
  \*************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
// extracted by mini-css-extract-plugin


/***/ }),

/***/ "./resources/scss/base/pages/page-knowledge-base.scss":
/*!************************************************************!*\
  !*** ./resources/scss/base/pages/page-knowledge-base.scss ***!
  \************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
// extracted by mini-css-extract-plugin


/***/ }),

/***/ "./resources/scss/base/pages/page-misc.scss":
/*!**************************************************!*\
  !*** ./resources/scss/base/pages/page-misc.scss ***!
  \**************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
// extracted by mini-css-extract-plugin


/***/ }),

/***/ "./resources/scss/base/pages/page-pricing.scss":
/*!*****************************************************!*\
  !*** ./resources/scss/base/pages/page-pricing.scss ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
// extracted by mini-css-extract-plugin


/***/ }),

/***/ "./resources/scss/base/pages/page-profile.scss":
/*!*****************************************************!*\
  !*** ./resources/scss/base/pages/page-profile.scss ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
// extracted by mini-css-extract-plugin


/***/ }),

/***/ "./resources/scss/base/pages/ui-feather.scss":
/*!***************************************************!*\
  !*** ./resources/scss/base/pages/ui-feather.scss ***!
  \***************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
// extracted by mini-css-extract-plugin


/***/ }),

/***/ "./resources/scss/base/core/colors/palette-gradient.scss":
/*!***************************************************************!*\
  !*** ./resources/scss/base/core/colors/palette-gradient.scss ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
// extracted by mini-css-extract-plugin


/***/ }),

/***/ "./resources/scss/base/core/colors/palette-noui.scss":
/*!***********************************************************!*\
  !*** ./resources/scss/base/core/colors/palette-noui.scss ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
// extracted by mini-css-extract-plugin


/***/ }),

/***/ "./resources/scss/base/core/colors/palette-variables.scss":
/*!****************************************************************!*\
  !*** ./resources/scss/base/core/colors/palette-variables.scss ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
// extracted by mini-css-extract-plugin


/***/ }),

/***/ "./resources/scss/base/core/menu/menu-types/horizontal-menu.scss":
/*!***********************************************************************!*\
  !*** ./resources/scss/base/core/menu/menu-types/horizontal-menu.scss ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
// extracted by mini-css-extract-plugin


/***/ }),

/***/ "./resources/scss/base/core/menu/menu-types/vertical-menu.scss":
/*!*********************************************************************!*\
  !*** ./resources/scss/base/core/menu/menu-types/vertical-menu.scss ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
// extracted by mini-css-extract-plugin


/***/ }),

/***/ "./resources/scss/base/core/menu/menu-types/vertical-overlay-menu.scss":
/*!*****************************************************************************!*\
  !*** ./resources/scss/base/core/menu/menu-types/vertical-overlay-menu.scss ***!
  \*****************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
// extracted by mini-css-extract-plugin


/***/ }),

/***/ "./resources/scss/base/core/mixins/alert.scss":
/*!****************************************************!*\
  !*** ./resources/scss/base/core/mixins/alert.scss ***!
  \****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
// extracted by mini-css-extract-plugin


/***/ }),

/***/ "./resources/scss/base/core/mixins/hex2rgb.scss":
/*!******************************************************!*\
  !*** ./resources/scss/base/core/mixins/hex2rgb.scss ***!
  \******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
// extracted by mini-css-extract-plugin


/***/ }),

/***/ "./resources/scss/base/core/mixins/main-menu-mixin.scss":
/*!**************************************************************!*\
  !*** ./resources/scss/base/core/mixins/main-menu-mixin.scss ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
// extracted by mini-css-extract-plugin


/***/ }),

/***/ "./resources/scss/base/core/mixins/transitions.scss":
/*!**********************************************************!*\
  !*** ./resources/scss/base/core/mixins/transitions.scss ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
// extracted by mini-css-extract-plugin


/***/ }),

/***/ "./resources/scss/base/themes/dark-layout.scss":
/*!*****************************************************!*\
  !*** ./resources/scss/base/themes/dark-layout.scss ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
// extracted by mini-css-extract-plugin


/***/ }),

/***/ "./resources/scss/core.scss":
/*!**********************************!*\
  !*** ./resources/scss/core.scss ***!
  \**********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
// extracted by mini-css-extract-plugin


/***/ }),

/***/ "./resources/scss/overrides.scss":
/*!***************************************!*\
  !*** ./resources/scss/overrides.scss ***!
  \***************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
// extracted by mini-css-extract-plugin


/***/ }),

/***/ "./resources/assets/scss/style.scss":
/*!******************************************!*\
  !*** ./resources/assets/scss/style.scss ***!
  \******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
// extracted by mini-css-extract-plugin


/***/ }),

/***/ "./resources/scss/base/plugins/charts/chart-apex.scss":
/*!************************************************************!*\
  !*** ./resources/scss/base/plugins/charts/chart-apex.scss ***!
  \************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
// extracted by mini-css-extract-plugin


/***/ }),

/***/ "./resources/scss/base/plugins/extensions/ext-component-context-menu.scss":
/*!********************************************************************************!*\
  !*** ./resources/scss/base/plugins/extensions/ext-component-context-menu.scss ***!
  \********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
// extracted by mini-css-extract-plugin


/***/ }),

/***/ "./resources/scss/base/plugins/extensions/ext-component-drag-drop.scss":
/*!*****************************************************************************!*\
  !*** ./resources/scss/base/plugins/extensions/ext-component-drag-drop.scss ***!
  \*****************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
// extracted by mini-css-extract-plugin


/***/ }),

/***/ "./resources/scss/base/plugins/extensions/ext-component-media-player.scss":
/*!********************************************************************************!*\
  !*** ./resources/scss/base/plugins/extensions/ext-component-media-player.scss ***!
  \********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
// extracted by mini-css-extract-plugin


/***/ }),

/***/ "./node_modules/raw-loader/dist/cjs.js!./resources/assets/cors.txt":
/*!*************************************************************************!*\
  !*** ./node_modules/raw-loader/dist/cjs.js!./resources/assets/cors.txt ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ("https://fast-reaches-54358.herokuapp.com/");

/***/ }),

/***/ "./node_modules/style-loader/dist/cjs.js!./node_modules/laravel-mix/node_modules/css-loader/dist/cjs.js??clonedRuleSet-65[0].rules[0].use[1]!./node_modules/vue-loader/lib/loaders/stylePostLoader.js!./node_modules/postcss-loader/dist/cjs.js??clonedRuleSet-65[0].rules[0].use[2]!./node_modules/vue-loader/lib/index.js??vue-loader-options!./src/Main.vue?vue&type=style&index=0&lang=css&":
/*!******************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/style-loader/dist/cjs.js!./node_modules/laravel-mix/node_modules/css-loader/dist/cjs.js??clonedRuleSet-65[0].rules[0].use[1]!./node_modules/vue-loader/lib/loaders/stylePostLoader.js!./node_modules/postcss-loader/dist/cjs.js??clonedRuleSet-65[0].rules[0].use[2]!./node_modules/vue-loader/lib/index.js??vue-loader-options!./src/Main.vue?vue&type=style&index=0&lang=css& ***!
  \******************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! !../node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js */ "./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js");
/* harmony import */ var _node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _node_modules_laravel_mix_node_modules_css_loader_dist_cjs_js_clonedRuleSet_65_0_rules_0_use_1_node_modules_vue_loader_lib_loaders_stylePostLoader_js_node_modules_postcss_loader_dist_cjs_js_clonedRuleSet_65_0_rules_0_use_2_node_modules_vue_loader_lib_index_js_vue_loader_options_Main_vue_vue_type_style_index_0_lang_css___WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! !!../node_modules/laravel-mix/node_modules/css-loader/dist/cjs.js??clonedRuleSet-65[0].rules[0].use[1]!../node_modules/vue-loader/lib/loaders/stylePostLoader.js!../node_modules/postcss-loader/dist/cjs.js??clonedRuleSet-65[0].rules[0].use[2]!../node_modules/vue-loader/lib/index.js??vue-loader-options!./Main.vue?vue&type=style&index=0&lang=css& */ "./node_modules/laravel-mix/node_modules/css-loader/dist/cjs.js??clonedRuleSet-65[0].rules[0].use[1]!./node_modules/vue-loader/lib/loaders/stylePostLoader.js!./node_modules/postcss-loader/dist/cjs.js??clonedRuleSet-65[0].rules[0].use[2]!./node_modules/vue-loader/lib/index.js??vue-loader-options!./src/Main.vue?vue&type=style&index=0&lang=css&");

            

var options = {};

options.insert = "head";
options.singleton = false;

var update = _node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default()(_node_modules_laravel_mix_node_modules_css_loader_dist_cjs_js_clonedRuleSet_65_0_rules_0_use_1_node_modules_vue_loader_lib_loaders_stylePostLoader_js_node_modules_postcss_loader_dist_cjs_js_clonedRuleSet_65_0_rules_0_use_2_node_modules_vue_loader_lib_index_js_vue_loader_options_Main_vue_vue_type_style_index_0_lang_css___WEBPACK_IMPORTED_MODULE_1__["default"], options);



/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (_node_modules_laravel_mix_node_modules_css_loader_dist_cjs_js_clonedRuleSet_65_0_rules_0_use_1_node_modules_vue_loader_lib_loaders_stylePostLoader_js_node_modules_postcss_loader_dist_cjs_js_clonedRuleSet_65_0_rules_0_use_2_node_modules_vue_loader_lib_index_js_vue_loader_options_Main_vue_vue_type_style_index_0_lang_css___WEBPACK_IMPORTED_MODULE_1__["default"].locals || {});

/***/ }),

/***/ "./node_modules/style-loader/dist/cjs.js!./node_modules/laravel-mix/node_modules/css-loader/dist/cjs.js??clonedRuleSet-65[0].rules[0].use[1]!./node_modules/vue-loader/lib/loaders/stylePostLoader.js!./node_modules/postcss-loader/dist/cjs.js??clonedRuleSet-65[0].rules[0].use[2]!./node_modules/vue-loader/lib/index.js??vue-loader-options!./src/components/StdInput.vue?vue&type=style&index=0&lang=css&":
/*!*********************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/style-loader/dist/cjs.js!./node_modules/laravel-mix/node_modules/css-loader/dist/cjs.js??clonedRuleSet-65[0].rules[0].use[1]!./node_modules/vue-loader/lib/loaders/stylePostLoader.js!./node_modules/postcss-loader/dist/cjs.js??clonedRuleSet-65[0].rules[0].use[2]!./node_modules/vue-loader/lib/index.js??vue-loader-options!./src/components/StdInput.vue?vue&type=style&index=0&lang=css& ***!
  \*********************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! !../../node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js */ "./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js");
/* harmony import */ var _node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _node_modules_laravel_mix_node_modules_css_loader_dist_cjs_js_clonedRuleSet_65_0_rules_0_use_1_node_modules_vue_loader_lib_loaders_stylePostLoader_js_node_modules_postcss_loader_dist_cjs_js_clonedRuleSet_65_0_rules_0_use_2_node_modules_vue_loader_lib_index_js_vue_loader_options_StdInput_vue_vue_type_style_index_0_lang_css___WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! !!../../node_modules/laravel-mix/node_modules/css-loader/dist/cjs.js??clonedRuleSet-65[0].rules[0].use[1]!../../node_modules/vue-loader/lib/loaders/stylePostLoader.js!../../node_modules/postcss-loader/dist/cjs.js??clonedRuleSet-65[0].rules[0].use[2]!../../node_modules/vue-loader/lib/index.js??vue-loader-options!./StdInput.vue?vue&type=style&index=0&lang=css& */ "./node_modules/laravel-mix/node_modules/css-loader/dist/cjs.js??clonedRuleSet-65[0].rules[0].use[1]!./node_modules/vue-loader/lib/loaders/stylePostLoader.js!./node_modules/postcss-loader/dist/cjs.js??clonedRuleSet-65[0].rules[0].use[2]!./node_modules/vue-loader/lib/index.js??vue-loader-options!./src/components/StdInput.vue?vue&type=style&index=0&lang=css&");

            

var options = {};

options.insert = "head";
options.singleton = false;

var update = _node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default()(_node_modules_laravel_mix_node_modules_css_loader_dist_cjs_js_clonedRuleSet_65_0_rules_0_use_1_node_modules_vue_loader_lib_loaders_stylePostLoader_js_node_modules_postcss_loader_dist_cjs_js_clonedRuleSet_65_0_rules_0_use_2_node_modules_vue_loader_lib_index_js_vue_loader_options_StdInput_vue_vue_type_style_index_0_lang_css___WEBPACK_IMPORTED_MODULE_1__["default"], options);



/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (_node_modules_laravel_mix_node_modules_css_loader_dist_cjs_js_clonedRuleSet_65_0_rules_0_use_1_node_modules_vue_loader_lib_loaders_stylePostLoader_js_node_modules_postcss_loader_dist_cjs_js_clonedRuleSet_65_0_rules_0_use_2_node_modules_vue_loader_lib_index_js_vue_loader_options_StdInput_vue_vue_type_style_index_0_lang_css___WEBPACK_IMPORTED_MODULE_1__["default"].locals || {});

/***/ }),

/***/ "./node_modules/style-loader/dist/cjs.js!./node_modules/laravel-mix/node_modules/css-loader/dist/cjs.js??clonedRuleSet-65[0].rules[0].use[1]!./node_modules/vue-loader/lib/loaders/stylePostLoader.js!./node_modules/postcss-loader/dist/cjs.js??clonedRuleSet-65[0].rules[0].use[2]!./node_modules/vue-loader/lib/index.js??vue-loader-options!./src/components/Window.vue?vue&type=style&index=0&lang=css&":
/*!*******************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/style-loader/dist/cjs.js!./node_modules/laravel-mix/node_modules/css-loader/dist/cjs.js??clonedRuleSet-65[0].rules[0].use[1]!./node_modules/vue-loader/lib/loaders/stylePostLoader.js!./node_modules/postcss-loader/dist/cjs.js??clonedRuleSet-65[0].rules[0].use[2]!./node_modules/vue-loader/lib/index.js??vue-loader-options!./src/components/Window.vue?vue&type=style&index=0&lang=css& ***!
  \*******************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! !../../node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js */ "./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js");
/* harmony import */ var _node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _node_modules_laravel_mix_node_modules_css_loader_dist_cjs_js_clonedRuleSet_65_0_rules_0_use_1_node_modules_vue_loader_lib_loaders_stylePostLoader_js_node_modules_postcss_loader_dist_cjs_js_clonedRuleSet_65_0_rules_0_use_2_node_modules_vue_loader_lib_index_js_vue_loader_options_Window_vue_vue_type_style_index_0_lang_css___WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! !!../../node_modules/laravel-mix/node_modules/css-loader/dist/cjs.js??clonedRuleSet-65[0].rules[0].use[1]!../../node_modules/vue-loader/lib/loaders/stylePostLoader.js!../../node_modules/postcss-loader/dist/cjs.js??clonedRuleSet-65[0].rules[0].use[2]!../../node_modules/vue-loader/lib/index.js??vue-loader-options!./Window.vue?vue&type=style&index=0&lang=css& */ "./node_modules/laravel-mix/node_modules/css-loader/dist/cjs.js??clonedRuleSet-65[0].rules[0].use[1]!./node_modules/vue-loader/lib/loaders/stylePostLoader.js!./node_modules/postcss-loader/dist/cjs.js??clonedRuleSet-65[0].rules[0].use[2]!./node_modules/vue-loader/lib/index.js??vue-loader-options!./src/components/Window.vue?vue&type=style&index=0&lang=css&");

            

var options = {};

options.insert = "head";
options.singleton = false;

var update = _node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default()(_node_modules_laravel_mix_node_modules_css_loader_dist_cjs_js_clonedRuleSet_65_0_rules_0_use_1_node_modules_vue_loader_lib_loaders_stylePostLoader_js_node_modules_postcss_loader_dist_cjs_js_clonedRuleSet_65_0_rules_0_use_2_node_modules_vue_loader_lib_index_js_vue_loader_options_Window_vue_vue_type_style_index_0_lang_css___WEBPACK_IMPORTED_MODULE_1__["default"], options);



/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (_node_modules_laravel_mix_node_modules_css_loader_dist_cjs_js_clonedRuleSet_65_0_rules_0_use_1_node_modules_vue_loader_lib_loaders_stylePostLoader_js_node_modules_postcss_loader_dist_cjs_js_clonedRuleSet_65_0_rules_0_use_2_node_modules_vue_loader_lib_index_js_vue_loader_options_Window_vue_vue_type_style_index_0_lang_css___WEBPACK_IMPORTED_MODULE_1__["default"].locals || {});

/***/ }),

/***/ "./node_modules/style-loader/dist/cjs.js!./node_modules/laravel-mix/node_modules/css-loader/dist/cjs.js??clonedRuleSet-65[0].rules[0].use[1]!./node_modules/vue-loader/lib/loaders/stylePostLoader.js!./node_modules/postcss-loader/dist/cjs.js??clonedRuleSet-65[0].rules[0].use[2]!./node_modules/vue-loader/lib/index.js??vue-loader-options!./src/extensions/grid-resize/Splitter.vue?vue&type=style&index=0&id=189fccad&scoped=true&lang=css&":
/*!*********************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/style-loader/dist/cjs.js!./node_modules/laravel-mix/node_modules/css-loader/dist/cjs.js??clonedRuleSet-65[0].rules[0].use[1]!./node_modules/vue-loader/lib/loaders/stylePostLoader.js!./node_modules/postcss-loader/dist/cjs.js??clonedRuleSet-65[0].rules[0].use[2]!./node_modules/vue-loader/lib/index.js??vue-loader-options!./src/extensions/grid-resize/Splitter.vue?vue&type=style&index=0&id=189fccad&scoped=true&lang=css& ***!
  \*********************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! !../../../node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js */ "./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js");
/* harmony import */ var _node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _node_modules_laravel_mix_node_modules_css_loader_dist_cjs_js_clonedRuleSet_65_0_rules_0_use_1_node_modules_vue_loader_lib_loaders_stylePostLoader_js_node_modules_postcss_loader_dist_cjs_js_clonedRuleSet_65_0_rules_0_use_2_node_modules_vue_loader_lib_index_js_vue_loader_options_Splitter_vue_vue_type_style_index_0_id_189fccad_scoped_true_lang_css___WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! !!../../../node_modules/laravel-mix/node_modules/css-loader/dist/cjs.js??clonedRuleSet-65[0].rules[0].use[1]!../../../node_modules/vue-loader/lib/loaders/stylePostLoader.js!../../../node_modules/postcss-loader/dist/cjs.js??clonedRuleSet-65[0].rules[0].use[2]!../../../node_modules/vue-loader/lib/index.js??vue-loader-options!./Splitter.vue?vue&type=style&index=0&id=189fccad&scoped=true&lang=css& */ "./node_modules/laravel-mix/node_modules/css-loader/dist/cjs.js??clonedRuleSet-65[0].rules[0].use[1]!./node_modules/vue-loader/lib/loaders/stylePostLoader.js!./node_modules/postcss-loader/dist/cjs.js??clonedRuleSet-65[0].rules[0].use[2]!./node_modules/vue-loader/lib/index.js??vue-loader-options!./src/extensions/grid-resize/Splitter.vue?vue&type=style&index=0&id=189fccad&scoped=true&lang=css&");

            

var options = {};

options.insert = "head";
options.singleton = false;

var update = _node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default()(_node_modules_laravel_mix_node_modules_css_loader_dist_cjs_js_clonedRuleSet_65_0_rules_0_use_1_node_modules_vue_loader_lib_loaders_stylePostLoader_js_node_modules_postcss_loader_dist_cjs_js_clonedRuleSet_65_0_rules_0_use_2_node_modules_vue_loader_lib_index_js_vue_loader_options_Splitter_vue_vue_type_style_index_0_id_189fccad_scoped_true_lang_css___WEBPACK_IMPORTED_MODULE_1__["default"], options);



/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (_node_modules_laravel_mix_node_modules_css_loader_dist_cjs_js_clonedRuleSet_65_0_rules_0_use_1_node_modules_vue_loader_lib_loaders_stylePostLoader_js_node_modules_postcss_loader_dist_cjs_js_clonedRuleSet_65_0_rules_0_use_2_node_modules_vue_loader_lib_index_js_vue_loader_options_Splitter_vue_vue_type_style_index_0_id_189fccad_scoped_true_lang_css___WEBPACK_IMPORTED_MODULE_1__["default"].locals || {});

/***/ }),

/***/ "./node_modules/style-loader/dist/cjs.js!./node_modules/laravel-mix/node_modules/css-loader/dist/cjs.js??clonedRuleSet-65[0].rules[0].use[1]!./node_modules/vue-loader/lib/loaders/stylePostLoader.js!./node_modules/postcss-loader/dist/cjs.js??clonedRuleSet-65[0].rules[0].use[2]!./node_modules/vue-loader/lib/index.js??vue-loader-options!./src/extensions/legend-buttons/AddWin.vue?vue&type=style&index=0&id=53408ac7&scoped=true&lang=css&":
/*!**********************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/style-loader/dist/cjs.js!./node_modules/laravel-mix/node_modules/css-loader/dist/cjs.js??clonedRuleSet-65[0].rules[0].use[1]!./node_modules/vue-loader/lib/loaders/stylePostLoader.js!./node_modules/postcss-loader/dist/cjs.js??clonedRuleSet-65[0].rules[0].use[2]!./node_modules/vue-loader/lib/index.js??vue-loader-options!./src/extensions/legend-buttons/AddWin.vue?vue&type=style&index=0&id=53408ac7&scoped=true&lang=css& ***!
  \**********************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! !../../../node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js */ "./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js");
/* harmony import */ var _node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _node_modules_laravel_mix_node_modules_css_loader_dist_cjs_js_clonedRuleSet_65_0_rules_0_use_1_node_modules_vue_loader_lib_loaders_stylePostLoader_js_node_modules_postcss_loader_dist_cjs_js_clonedRuleSet_65_0_rules_0_use_2_node_modules_vue_loader_lib_index_js_vue_loader_options_AddWin_vue_vue_type_style_index_0_id_53408ac7_scoped_true_lang_css___WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! !!../../../node_modules/laravel-mix/node_modules/css-loader/dist/cjs.js??clonedRuleSet-65[0].rules[0].use[1]!../../../node_modules/vue-loader/lib/loaders/stylePostLoader.js!../../../node_modules/postcss-loader/dist/cjs.js??clonedRuleSet-65[0].rules[0].use[2]!../../../node_modules/vue-loader/lib/index.js??vue-loader-options!./AddWin.vue?vue&type=style&index=0&id=53408ac7&scoped=true&lang=css& */ "./node_modules/laravel-mix/node_modules/css-loader/dist/cjs.js??clonedRuleSet-65[0].rules[0].use[1]!./node_modules/vue-loader/lib/loaders/stylePostLoader.js!./node_modules/postcss-loader/dist/cjs.js??clonedRuleSet-65[0].rules[0].use[2]!./node_modules/vue-loader/lib/index.js??vue-loader-options!./src/extensions/legend-buttons/AddWin.vue?vue&type=style&index=0&id=53408ac7&scoped=true&lang=css&");

            

var options = {};

options.insert = "head";
options.singleton = false;

var update = _node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default()(_node_modules_laravel_mix_node_modules_css_loader_dist_cjs_js_clonedRuleSet_65_0_rules_0_use_1_node_modules_vue_loader_lib_loaders_stylePostLoader_js_node_modules_postcss_loader_dist_cjs_js_clonedRuleSet_65_0_rules_0_use_2_node_modules_vue_loader_lib_index_js_vue_loader_options_AddWin_vue_vue_type_style_index_0_id_53408ac7_scoped_true_lang_css___WEBPACK_IMPORTED_MODULE_1__["default"], options);



/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (_node_modules_laravel_mix_node_modules_css_loader_dist_cjs_js_clonedRuleSet_65_0_rules_0_use_1_node_modules_vue_loader_lib_loaders_stylePostLoader_js_node_modules_postcss_loader_dist_cjs_js_clonedRuleSet_65_0_rules_0_use_2_node_modules_vue_loader_lib_index_js_vue_loader_options_AddWin_vue_vue_type_style_index_0_id_53408ac7_scoped_true_lang_css___WEBPACK_IMPORTED_MODULE_1__["default"].locals || {});

/***/ }),

/***/ "./node_modules/style-loader/dist/cjs.js!./node_modules/laravel-mix/node_modules/css-loader/dist/cjs.js??clonedRuleSet-65[0].rules[0].use[1]!./node_modules/vue-loader/lib/loaders/stylePostLoader.js!./node_modules/postcss-loader/dist/cjs.js??clonedRuleSet-65[0].rules[0].use[2]!./node_modules/vue-loader/lib/index.js??vue-loader-options!./src/extensions/settings-win/SettingsWin.vue?vue&type=style&index=0&id=5d223b0e&scoped=true&lang=css&":
/*!*************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/style-loader/dist/cjs.js!./node_modules/laravel-mix/node_modules/css-loader/dist/cjs.js??clonedRuleSet-65[0].rules[0].use[1]!./node_modules/vue-loader/lib/loaders/stylePostLoader.js!./node_modules/postcss-loader/dist/cjs.js??clonedRuleSet-65[0].rules[0].use[2]!./node_modules/vue-loader/lib/index.js??vue-loader-options!./src/extensions/settings-win/SettingsWin.vue?vue&type=style&index=0&id=5d223b0e&scoped=true&lang=css& ***!
  \*************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! !../../../node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js */ "./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js");
/* harmony import */ var _node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _node_modules_laravel_mix_node_modules_css_loader_dist_cjs_js_clonedRuleSet_65_0_rules_0_use_1_node_modules_vue_loader_lib_loaders_stylePostLoader_js_node_modules_postcss_loader_dist_cjs_js_clonedRuleSet_65_0_rules_0_use_2_node_modules_vue_loader_lib_index_js_vue_loader_options_SettingsWin_vue_vue_type_style_index_0_id_5d223b0e_scoped_true_lang_css___WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! !!../../../node_modules/laravel-mix/node_modules/css-loader/dist/cjs.js??clonedRuleSet-65[0].rules[0].use[1]!../../../node_modules/vue-loader/lib/loaders/stylePostLoader.js!../../../node_modules/postcss-loader/dist/cjs.js??clonedRuleSet-65[0].rules[0].use[2]!../../../node_modules/vue-loader/lib/index.js??vue-loader-options!./SettingsWin.vue?vue&type=style&index=0&id=5d223b0e&scoped=true&lang=css& */ "./node_modules/laravel-mix/node_modules/css-loader/dist/cjs.js??clonedRuleSet-65[0].rules[0].use[1]!./node_modules/vue-loader/lib/loaders/stylePostLoader.js!./node_modules/postcss-loader/dist/cjs.js??clonedRuleSet-65[0].rules[0].use[2]!./node_modules/vue-loader/lib/index.js??vue-loader-options!./src/extensions/settings-win/SettingsWin.vue?vue&type=style&index=0&id=5d223b0e&scoped=true&lang=css&");

            

var options = {};

options.insert = "head";
options.singleton = false;

var update = _node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default()(_node_modules_laravel_mix_node_modules_css_loader_dist_cjs_js_clonedRuleSet_65_0_rules_0_use_1_node_modules_vue_loader_lib_loaders_stylePostLoader_js_node_modules_postcss_loader_dist_cjs_js_clonedRuleSet_65_0_rules_0_use_2_node_modules_vue_loader_lib_index_js_vue_loader_options_SettingsWin_vue_vue_type_style_index_0_id_5d223b0e_scoped_true_lang_css___WEBPACK_IMPORTED_MODULE_1__["default"], options);



/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (_node_modules_laravel_mix_node_modules_css_loader_dist_cjs_js_clonedRuleSet_65_0_rules_0_use_1_node_modules_vue_loader_lib_loaders_stylePostLoader_js_node_modules_postcss_loader_dist_cjs_js_clonedRuleSet_65_0_rules_0_use_2_node_modules_vue_loader_lib_index_js_vue_loader_options_SettingsWin_vue_vue_type_style_index_0_id_5d223b0e_scoped_true_lang_css___WEBPACK_IMPORTED_MODULE_1__["default"].locals || {});

/***/ }),

/***/ "./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js":
/*!****************************************************************************!*\
  !*** ./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js ***!
  \****************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var isOldIE = function isOldIE() {
  var memo;
  return function memorize() {
    if (typeof memo === 'undefined') {
      // Test for IE <= 9 as proposed by Browserhacks
      // @see http://browserhacks.com/#hack-e71d8692f65334173fee715c222cb805
      // Tests for existence of standard globals is to allow style-loader
      // to operate correctly into non-standard environments
      // @see https://github.com/webpack-contrib/style-loader/issues/177
      memo = Boolean(window && document && document.all && !window.atob);
    }

    return memo;
  };
}();

var getTarget = function getTarget() {
  var memo = {};
  return function memorize(target) {
    if (typeof memo[target] === 'undefined') {
      var styleTarget = document.querySelector(target); // Special case to return head of iframe instead of iframe itself

      if (window.HTMLIFrameElement && styleTarget instanceof window.HTMLIFrameElement) {
        try {
          // This will throw an exception if access to iframe is blocked
          // due to cross-origin restrictions
          styleTarget = styleTarget.contentDocument.head;
        } catch (e) {
          // istanbul ignore next
          styleTarget = null;
        }
      }

      memo[target] = styleTarget;
    }

    return memo[target];
  };
}();

var stylesInDom = [];

function getIndexByIdentifier(identifier) {
  var result = -1;

  for (var i = 0; i < stylesInDom.length; i++) {
    if (stylesInDom[i].identifier === identifier) {
      result = i;
      break;
    }
  }

  return result;
}

function modulesToDom(list, options) {
  var idCountMap = {};
  var identifiers = [];

  for (var i = 0; i < list.length; i++) {
    var item = list[i];
    var id = options.base ? item[0] + options.base : item[0];
    var count = idCountMap[id] || 0;
    var identifier = "".concat(id, " ").concat(count);
    idCountMap[id] = count + 1;
    var index = getIndexByIdentifier(identifier);
    var obj = {
      css: item[1],
      media: item[2],
      sourceMap: item[3]
    };

    if (index !== -1) {
      stylesInDom[index].references++;
      stylesInDom[index].updater(obj);
    } else {
      stylesInDom.push({
        identifier: identifier,
        updater: addStyle(obj, options),
        references: 1
      });
    }

    identifiers.push(identifier);
  }

  return identifiers;
}

function insertStyleElement(options) {
  var style = document.createElement('style');
  var attributes = options.attributes || {};

  if (typeof attributes.nonce === 'undefined') {
    var nonce =  true ? __webpack_require__.nc : 0;

    if (nonce) {
      attributes.nonce = nonce;
    }
  }

  Object.keys(attributes).forEach(function (key) {
    style.setAttribute(key, attributes[key]);
  });

  if (typeof options.insert === 'function') {
    options.insert(style);
  } else {
    var target = getTarget(options.insert || 'head');

    if (!target) {
      throw new Error("Couldn't find a style target. This probably means that the value for the 'insert' parameter is invalid.");
    }

    target.appendChild(style);
  }

  return style;
}

function removeStyleElement(style) {
  // istanbul ignore if
  if (style.parentNode === null) {
    return false;
  }

  style.parentNode.removeChild(style);
}
/* istanbul ignore next  */


var replaceText = function replaceText() {
  var textStore = [];
  return function replace(index, replacement) {
    textStore[index] = replacement;
    return textStore.filter(Boolean).join('\n');
  };
}();

function applyToSingletonTag(style, index, remove, obj) {
  var css = remove ? '' : obj.media ? "@media ".concat(obj.media, " {").concat(obj.css, "}") : obj.css; // For old IE

  /* istanbul ignore if  */

  if (style.styleSheet) {
    style.styleSheet.cssText = replaceText(index, css);
  } else {
    var cssNode = document.createTextNode(css);
    var childNodes = style.childNodes;

    if (childNodes[index]) {
      style.removeChild(childNodes[index]);
    }

    if (childNodes.length) {
      style.insertBefore(cssNode, childNodes[index]);
    } else {
      style.appendChild(cssNode);
    }
  }
}

function applyToTag(style, options, obj) {
  var css = obj.css;
  var media = obj.media;
  var sourceMap = obj.sourceMap;

  if (media) {
    style.setAttribute('media', media);
  } else {
    style.removeAttribute('media');
  }

  if (sourceMap && typeof btoa !== 'undefined') {
    css += "\n/*# sourceMappingURL=data:application/json;base64,".concat(btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap)))), " */");
  } // For old IE

  /* istanbul ignore if  */


  if (style.styleSheet) {
    style.styleSheet.cssText = css;
  } else {
    while (style.firstChild) {
      style.removeChild(style.firstChild);
    }

    style.appendChild(document.createTextNode(css));
  }
}

var singleton = null;
var singletonCounter = 0;

function addStyle(obj, options) {
  var style;
  var update;
  var remove;

  if (options.singleton) {
    var styleIndex = singletonCounter++;
    style = singleton || (singleton = insertStyleElement(options));
    update = applyToSingletonTag.bind(null, style, styleIndex, false);
    remove = applyToSingletonTag.bind(null, style, styleIndex, true);
  } else {
    style = insertStyleElement(options);
    update = applyToTag.bind(null, style, options);

    remove = function remove() {
      removeStyleElement(style);
    };
  }

  update(obj);
  return function updateStyle(newObj) {
    if (newObj) {
      if (newObj.css === obj.css && newObj.media === obj.media && newObj.sourceMap === obj.sourceMap) {
        return;
      }

      update(obj = newObj);
    } else {
      remove();
    }
  };
}

module.exports = function (list, options) {
  options = options || {}; // Force single-tag solution on IE6-9, which has a hard limit on the # of <style>
  // tags it will allow on a page

  if (!options.singleton && typeof options.singleton !== 'boolean') {
    options.singleton = isOldIE();
  }

  list = list || [];
  var lastIdentifiers = modulesToDom(list, options);
  return function update(newList) {
    newList = newList || [];

    if (Object.prototype.toString.call(newList) !== '[object Array]') {
      return;
    }

    for (var i = 0; i < lastIdentifiers.length; i++) {
      var identifier = lastIdentifiers[i];
      var index = getIndexByIdentifier(identifier);
      stylesInDom[index].references--;
    }

    var newLastIdentifiers = modulesToDom(newList, options);

    for (var _i = 0; _i < lastIdentifiers.length; _i++) {
      var _identifier = lastIdentifiers[_i];

      var _index = getIndexByIdentifier(_identifier);

      if (stylesInDom[_index].references === 0) {
        stylesInDom[_index].updater();

        stylesInDom.splice(_index, 1);
      }
    }

    lastIdentifiers = newLastIdentifiers;
  };
};

/***/ }),

/***/ "./node_modules/trading-vue-js/dist/trading-vue.js":
/*!*********************************************************!*\
  !*** ./node_modules/trading-vue-js/dist/trading-vue.js ***!
  \*********************************************************/
/***/ ((module) => {

/*!
 * TradingVue.JS - v1.0.2 - Thu Mar 18 2021
 *     https://github.com/tvjsx/trading-vue-js
 *     Copyright (c) 2019 C451 Code's All Right;
 *     Licensed under the MIT license
 */
(function webpackUniversalModuleDefinition(root, factory) {
	if(true)
		module.exports = factory();
	else {}
})(self, function() {
return /******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ 757:
/***/ ((module, __unused_webpack_exports, __nested_webpack_require_694__) => {

module.exports = __nested_webpack_require_694__(666);


/***/ }),

/***/ 546:
/***/ ((module) => {

/**
 * Utility compare functions
 */

module.exports = {

    /**
     * Compare two numbers.
     *
     * @param {Number} a
     * @param {Number} b
     * @returns {Number} 1 if a > b, 0 if a = b, -1 if a < b
     */
    numcmp: function (a, b) {
        return a - b;
    },

    /**
     * Compare two strings.
     *
     * @param {Number|String} a
     * @param {Number|String} b
     * @returns {Number} 1 if a > b, 0 if a = b, -1 if a < b
     */
    strcmp: function (a, b) {
        return a < b ? -1 : a > b ? 1 : 0;
    }

};


/***/ }),

/***/ 678:
/***/ ((module, __unused_webpack_exports, __nested_webpack_require_1415__) => {

/**
 * Indexed Array Binary Search module
 */

/**
 * Dependencies
 */
var util = __nested_webpack_require_1415__(500),
    cmp = __nested_webpack_require_1415__(546),
    bin = __nested_webpack_require_1415__(101);

/**
 * Module interface definition
 */
module.exports = IndexedArray;

/**
 * Indexed Array constructor
 *
 * It loads the array data, defines the index field and the comparison function
 * to be used.
 *
 * @param {Array} data is an array of objects
 * @param {String} index is the object's property used to search the array
 */
function IndexedArray(data, index) {

    // is data sortable array or array-like object?
    if (!util.isSortableArrayLike(data))
        throw new Error("Invalid data");

    // is index a valid property?
    if (!index || data.length > 0 && !(index in data[0]))
        throw new Error("Invalid index");

    // data array
    this.data = data;

    // name of the index property
    this.index = index;

    // set index boundary values
    this.setBoundaries();

    // default comparison function
    this.compare = typeof this.minv === "number" ? cmp.numcmp : cmp.strcmp;

    // default search function
    this.search = bin.search;

    // cache of index values to array positions
    // each value stores an object as { found: true|false, index: array-index }
    this.valpos = {};

    // cursor and adjacent positions
    this.cursor = null;
    this.nextlow = null;
    this.nexthigh = null;
}

/**
 * Set the comparison function
 *
 * @param {Function} fn to compare index values that returnes 1, 0, -1
 */
IndexedArray.prototype.setCompare = function (fn) {
    if (typeof fn !== "function")
        throw new Error("Invalid argument");

    this.compare = fn;
    return this;
};

/**
 * Set the search function
 *
 * @param {Function} fn to search index values in the array of objects
 */
IndexedArray.prototype.setSearch = function (fn) {
    if (typeof fn !== "function")
        throw new Error("Invalid argument");

    this.search = fn;
    return this;
};

/**
 * Sort the data array by its index property
 */
IndexedArray.prototype.sort = function () {
    var self = this,
        index = this.index;

    // sort the array
    this.data.sort(function (a, b) {
        return self.compare(a[index], b[index]);
    });

    // recalculate boundary values
    this.setBoundaries();

    return this;
};

/**
 * Inspect and set the boundaries of the internal data array
 */
IndexedArray.prototype.setBoundaries = function () {
    var data = this.data,
        index = this.index;

    this.minv = data.length && data[0][index];
    this.maxv = data.length && data[data.length - 1][index];

    return this;
};

/**
 * Get the position of the object corresponding to the given index
 *
 * @param {Number|String} index is the id of the requested object
 * @returns {Number} the position of the object in the array
 */
IndexedArray.prototype.fetch = function (value) {
    // check data has objects
    if (this.data.length === 0) {
        this.cursor = null;
        this.nextlow = null;
        this.nexthigh = null;
        return this;
    }

    // check the request is within range
    if (this.compare(value, this.minv) === -1) {
        this.cursor = null;
        this.nextlow = null;
        this.nexthigh = 0;
        return this;
    }
    if (this.compare(value, this.maxv) === 1) {
        this.cursor = null;
        this.nextlow = this.data.length - 1;
        this.nexthigh = null;
        return this;
    }

    var valpos = this.valpos,
        pos = valpos[value];

    // if the request is memorized, just give it back
    if (pos) {
        if (pos.found) {
            this.cursor = pos.index;
            this.nextlow = null;
            this.nexthigh = null;
        } else {
            this.cursor = null;
            this.nextlow = pos.prev;
            this.nexthigh = pos.next;
        }
        return this;
    }

    // if not, do the search
    var result = this.search.call(this, value);
    this.cursor = result.index;
    this.nextlow = result.prev;
    this.nexthigh = result.next;
    return this;
};

/**
 * Get the object corresponding to the given index
 *
 * When no value is given, the function will default to the last fetched item.
 *
 * @param {Number|String} [optional] index is the id of the requested object
 * @returns {Object} the found object or null
 */
IndexedArray.prototype.get = function (value) {
    if (value)
        this.fetch(value);

    var pos = this.cursor;
    return pos !== null ? this.data[pos] : null;
};

/**
 * Get an slice of the data array
 *
 * Boundaries have to be in order.
 *
 * @param {Number|String} begin index is the id of the requested object
 * @param {Number|String} end index is the id of the requested object
 * @returns {Object} the slice of data array or []
 */
IndexedArray.prototype.getRange = function (begin, end) {
    // check if boundaries are in order
    if (this.compare(begin, end) === 1) {
        return [];
    }

    // fetch start and default to the next index above
    this.fetch(begin);
    var start = this.cursor || this.nexthigh;

    // fetch finish and default to the next index below
    this.fetch(end);
    var finish = this.cursor || this.nextlow;

    // if any boundary is not set, return no range
    if (start === null || finish === null) {
        return [];
    }

    // return range
    return this.data.slice(start, finish + 1);
};


/***/ }),

/***/ 101:
/***/ ((module) => {

/**
 * Binary search implementation
 */

/**
 * Main search recursive function
 */
function loop(data, min, max, index, valpos) {

    // set current position as the middle point between min and max
    var curr = (max + min) >>> 1;

    // compare current index value with the one we are looking for
    var diff = this.compare(data[curr][this.index], index);

    // found?
    if (!diff) {
        return valpos[index] = {
            "found": true,
            "index": curr,
            "prev": null,
            "next": null
        };
    }

    // no more positions available?
    if (min >= max) {
        return valpos[index] = {
            "found": false,
            "index": null,
            "prev": (diff < 0) ? max : max - 1,
            "next": (diff < 0) ? max + 1 : max
        };
    }

    // continue looking for index in one of the remaining array halves
    // current position can be skept as index is not there...
    if (diff > 0)
        return loop.call(this, data, min, curr - 1, index, valpos);
    else
        return loop.call(this, data, curr + 1, max, index, valpos);
}

/**
 * Search bootstrap
 * The function has to be executed in the context of the IndexedArray object
 */
function search(index) {
    var data = this.data;
    return loop.call(this, data, 0, data.length - 1, index, this.valpos);
}

/**
 * Export search function
 */
module.exports.search = search;


/***/ }),

/***/ 500:
/***/ ((module) => {

/**
 * Utils module
 */

/**
 * Check if an object is an array-like object
 *
 * @credit Javascript: The Definitive Guide, O'Reilly, 2011
 */
function isArrayLike(o) {
    if (o &&                                 // o is not null, undefined, etc.
        typeof o === "object" &&             // o is an object
        isFinite(o.length) &&                // o.length is a finite number
        o.length >= 0 &&                     // o.length is non-negative
        o.length === Math.floor(o.length) && // o.length is an integer
        o.length < 4294967296)               // o.length < 2^32
        return true;                         // Then o is array-like
    else
        return false;                        // Otherwise it is not
}

/**
 * Check for the existence of the sort function in the object
 */
function isSortable(o) {
    if (o &&                                 // o is not null, undefined, etc.
        typeof o === "object" &&             // o is an object
        typeof o.sort === "function")        // o.sort is a function
        return true;                         // Then o is array-like
    else
        return false;                        // Otherwise it is not
}

/**
 * Check for sortable-array-like objects
 */
module.exports.isSortableArrayLike = function (o) {
    return isArrayLike(o) && isSortable(o);
};


/***/ }),

/***/ 851:
/***/ ((__unused_webpack_module, __webpack_exports__, __nested_webpack_require_9759__) => {

"use strict";
// ESM COMPAT FLAG
__nested_webpack_require_9759__.r(__webpack_exports__);

// EXPORTS
__nested_webpack_require_9759__.d(__webpack_exports__, {
  "Candle": () => (/* reexport */ CandleExt),
  "Constants": () => (/* reexport */ constants),
  "DataCube": () => (/* reexport */ DataCube),
  "Interface": () => (/* reexport */ mixins_interface),
  "Overlay": () => (/* reexport */ overlay),
  "Tool": () => (/* reexport */ tool),
  "TradingVue": () => (/* reexport */ TradingVue),
  "Utils": () => (/* reexport */ utils),
  "Volbar": () => (/* reexport */ VolbarExt),
  "default": () => (/* binding */ src),
  "layout_cnv": () => (/* reexport */ layout_cnv),
  "layout_vol": () => (/* reexport */ layout_vol),
  "primitives": () => (/* binding */ primitives)
});

;// CONCATENATED MODULE: ./node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!./node_modules/vue-loader/lib/index.js??vue-loader-options!./src/TradingVue.vue?vue&type=template&id=235c0ade&
var render = function() {
  var _vm = this
  var _h = _vm.$createElement
  var _c = _vm._self._c || _h
  return _c(
    "div",
    {
      staticClass: "trading-vue",
      style: {
        color: this.chart_props.colors.text,
        font: this.font_comp,
        width: this.width + "px",
        height: this.height + "px"
      },
      attrs: { id: _vm.id },
      on: { mousedown: _vm.mousedown, mouseleave: _vm.mouseleave }
    },
    [
      _vm.toolbar
        ? _c(
            "toolbar",
            _vm._b(
              {
                ref: "toolbar",
                attrs: { config: _vm.chart_config },
                on: { "custom-event": _vm.custom_event }
              },
              "toolbar",
              _vm.chart_props,
              false
            )
          )
        : _vm._e(),
      _vm._v(" "),
      _vm.controllers.length
        ? _c("widgets", {
            ref: "widgets",
            attrs: {
              map: _vm.ws,
              width: _vm.width,
              height: _vm.height,
              tv: this,
              dc: _vm.data
            }
          })
        : _vm._e(),
      _vm._v(" "),
      _c(
        "chart",
        _vm._b(
          {
            key: _vm.reset,
            ref: "chart",
            attrs: { tv_id: _vm.id, config: _vm.chart_config },
            on: {
              "custom-event": _vm.custom_event,
              "range-changed": _vm.range_changed,
              "legend-button-click": _vm.legend_button
            }
          },
          "chart",
          _vm.chart_props,
          false
        )
      ),
      _vm._v(" "),
      _c(
        "transition",
        { attrs: { name: "tvjs-drift" } },
        [
          _vm.tip
            ? _c("the-tip", {
                attrs: { data: _vm.tip },
                on: {
                  "remove-me": function($event) {
                    _vm.tip = null
                  }
                }
              })
            : _vm._e()
        ],
        1
      )
    ],
    1
  )
}
var staticRenderFns = []
render._withStripped = true


;// CONCATENATED MODULE: ./src/TradingVue.vue?vue&type=template&id=235c0ade&

;// CONCATENATED MODULE: ./node_modules/@babel/runtime/helpers/esm/arrayLikeToArray.js
function _arrayLikeToArray(arr, len) {
  if (len == null || len > arr.length) len = arr.length;

  for (var i = 0, arr2 = new Array(len); i < len; i++) {
    arr2[i] = arr[i];
  }

  return arr2;
}
;// CONCATENATED MODULE: ./node_modules/@babel/runtime/helpers/esm/arrayWithoutHoles.js

function _arrayWithoutHoles(arr) {
  if (Array.isArray(arr)) return _arrayLikeToArray(arr);
}
;// CONCATENATED MODULE: ./node_modules/@babel/runtime/helpers/esm/iterableToArray.js
function _iterableToArray(iter) {
  if (typeof Symbol !== "undefined" && Symbol.iterator in Object(iter)) return Array.from(iter);
}
;// CONCATENATED MODULE: ./node_modules/@babel/runtime/helpers/esm/unsupportedIterableToArray.js

function _unsupportedIterableToArray(o, minLen) {
  if (!o) return;
  if (typeof o === "string") return _arrayLikeToArray(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor) n = o.constructor.name;
  if (n === "Map" || n === "Set") return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
}
;// CONCATENATED MODULE: ./node_modules/@babel/runtime/helpers/esm/nonIterableSpread.js
function _nonIterableSpread() {
  throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
;// CONCATENATED MODULE: ./node_modules/@babel/runtime/helpers/esm/toConsumableArray.js




function _toConsumableArray(arr) {
  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();
}
;// CONCATENATED MODULE: ./src/stuff/constants.js
var SECOND = 1000;
var MINUTE = SECOND * 60;
var MINUTE3 = MINUTE * 3;
var MINUTE5 = MINUTE * 5;
var MINUTE15 = MINUTE * 15;
var MINUTE30 = MINUTE * 30;
var HOUR = MINUTE * 60;
var HOUR4 = HOUR * 4;
var HOUR12 = HOUR * 12;
var DAY = HOUR * 24;
var WEEK = DAY * 7;
var MONTH = WEEK * 4;
var YEAR = DAY * 365;
var MONTHMAP = ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"]; // Grid time steps

var TIMESCALES = [YEAR * 10, YEAR * 5, YEAR * 3, YEAR * 2, YEAR, MONTH * 6, MONTH * 4, MONTH * 3, MONTH * 2, MONTH, DAY * 15, DAY * 10, DAY * 7, DAY * 5, DAY * 3, DAY * 2, DAY, HOUR * 12, HOUR * 6, HOUR * 3, HOUR * 1.5, HOUR, MINUTE30, MINUTE15, MINUTE * 10, MINUTE5, MINUTE * 2, MINUTE]; // Grid $ steps

var $SCALES = [0.05, 0.1, 0.2, 0.25, 0.5, 0.8, 1, 2, 5];
var ChartConfig = {
  SBMIN: 60,
  // Minimal sidebar px
  SBMAX: Infinity,
  // Max sidebar, px
  TOOLBAR: 57,
  // Toolbar width px
  TB_ICON: 25,
  // Toolbar icon size px
  TB_ITEM_M: 6,
  // Toolbar item margin px
  TB_ICON_BRI: 1,
  // Toolbar icon brightness
  TB_ICON_HOLD: 420,
  // ms, wait to expand
  TB_BORDER: 1,
  // Toolbar border px
  TB_B_STYLE: 'dotted',
  // Toolbar border style
  TOOL_COLL: 7,
  // Tool collision threshold
  EXPAND: 0.15,
  // %/100 of range
  CANDLEW: 0.6,
  // %/100 of step
  GRIDX: 100,
  // px
  GRIDY: 47,
  // px
  BOTBAR: 28,
  // px
  PANHEIGHT: 22,
  // px
  DEFAULT_LEN: 50,
  // candles
  MINIMUM_LEN: 5,
  // candles,
  MIN_ZOOM: 25,
  // candles
  MAX_ZOOM: 1000,
  // candles,
  VOLSCALE: 0.15,
  // %/100 of height
  UX_OPACITY: 0.9,
  // Ux background opacity
  ZOOM_MODE: 'tv',
  // 'tv' or 'tl'
  L_BTN_SIZE: 21,
  // Legend Button size, px
  L_BTN_MARGIN: '-6px 0 -6px 0',
  // css margin
  SCROLL_WHEEL: 'prevent' // 'pass', 'click'

};
ChartConfig.FONT = "11px -apple-system,BlinkMacSystemFont,\n    Segoe UI,Roboto,Oxygen,Ubuntu,Cantarell,\n    Fira Sans,Droid Sans,Helvetica Neue,\n    sans-serif";
var IB_TF_WARN = "When using IB mode you should specify " + "timeframe ('tf' filed in 'chart' object)," + "otherwise you can get an unexpected behaviour";
var MAP_UNIT = {
  "1s": SECOND,
  "5s": SECOND * 5,
  "10s": SECOND * 10,
  "20s": SECOND * 20,
  "30s": SECOND * 30,
  "1m": MINUTE,
  "3m": MINUTE3,
  "5m": MINUTE5,
  "15m": MINUTE15,
  "30m": MINUTE30,
  "1H": HOUR,
  "2H": HOUR * 2,
  "3H": HOUR * 3,
  "4H": HOUR4,
  "12H": HOUR12,
  "1D": DAY,
  "1W": WEEK,
  "1M": MONTH,
  "1Y": YEAR
};
/* harmony default export */ const constants = ({
  SECOND: SECOND,
  MINUTE: MINUTE,
  MINUTE5: MINUTE5,
  MINUTE15: MINUTE15,
  MINUTE30: MINUTE30,
  HOUR: HOUR,
  HOUR4: HOUR4,
  DAY: DAY,
  WEEK: WEEK,
  MONTH: MONTH,
  YEAR: YEAR,
  MONTHMAP: MONTHMAP,
  TIMESCALES: TIMESCALES,
  $SCALES: $SCALES,
  ChartConfig: ChartConfig,
  map_unit: MAP_UNIT,
  IB_TF_WARN: IB_TF_WARN
});
;// CONCATENATED MODULE: ./node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!./node_modules/vue-loader/lib/index.js??vue-loader-options!./src/components/Chart.vue?vue&type=template&id=4d06a4de&
var Chartvue_type_template_id_4d06a4de_render = function() {
  var _vm = this
  var _h = _vm.$createElement
  var _c = _vm._self._c || _h
  return _c(
    "div",
    { staticClass: "trading-vue-chart", style: _vm.styles },
    [
      _c("keyboard", { ref: "keyboard" }),
      _vm._v(" "),
      _vm._l(this._layout.grids, function(grid, i) {
        return _c("grid-section", {
          key: grid.id,
          ref: "sec",
          refInFor: true,
          attrs: { common: _vm.section_props(i), grid_id: i },
          on: {
            "register-kb-listener": _vm.register_kb,
            "remove-kb-listener": _vm.remove_kb,
            "range-changed": _vm.range_changed,
            "cursor-changed": _vm.cursor_changed,
            "cursor-locked": _vm.cursor_locked,
            "sidebar-transform": _vm.set_ytransform,
            "layer-meta-props": _vm.layer_meta_props,
            "custom-event": _vm.emit_custom_event,
            "legend-button-click": _vm.legend_button_click
          }
        })
      }),
      _vm._v(" "),
      _c(
        "botbar",
        _vm._b(
          { attrs: { shaders: _vm.shaders, timezone: _vm.timezone } },
          "botbar",
          _vm.botbar_props,
          false
        )
      )
    ],
    2
  )
}
var Chartvue_type_template_id_4d06a4de_staticRenderFns = []
Chartvue_type_template_id_4d06a4de_render._withStripped = true


;// CONCATENATED MODULE: ./src/components/Chart.vue?vue&type=template&id=4d06a4de&

;// CONCATENATED MODULE: ./node_modules/@babel/runtime/helpers/esm/arrayWithHoles.js
function _arrayWithHoles(arr) {
  if (Array.isArray(arr)) return arr;
}
;// CONCATENATED MODULE: ./node_modules/@babel/runtime/helpers/esm/iterableToArrayLimit.js
function _iterableToArrayLimit(arr, i) {
  if (typeof Symbol === "undefined" || !(Symbol.iterator in Object(arr))) return;
  var _arr = [];
  var _n = true;
  var _d = false;
  var _e = undefined;

  try {
    for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
      _arr.push(_s.value);

      if (i && _arr.length === i) break;
    }
  } catch (err) {
    _d = true;
    _e = err;
  } finally {
    try {
      if (!_n && _i["return"] != null) _i["return"]();
    } finally {
      if (_d) throw _e;
    }
  }

  return _arr;
}
;// CONCATENATED MODULE: ./node_modules/@babel/runtime/helpers/esm/nonIterableRest.js
function _nonIterableRest() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
;// CONCATENATED MODULE: ./node_modules/@babel/runtime/helpers/esm/slicedToArray.js




function _slicedToArray(arr, i) {
  return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();
}
;// CONCATENATED MODULE: ./src/stuff/context.js
// Canvas context for text measurments
function Context($p) {
  var el = document.createElement('canvas');
  var ctx = el.getContext("2d");
  ctx.font = $p.font;
  return ctx;
}

/* harmony default export */ const context = (Context);
// EXTERNAL MODULE: ./node_modules/arrayslicer/lib/index.js
var lib = __nested_webpack_require_9759__(678);
var lib_default = /*#__PURE__*/__nested_webpack_require_9759__.n(lib);
;// CONCATENATED MODULE: ./src/stuff/utils.js



/* harmony default export */ const utils = ({
  clamp: function clamp(num, min, max) {
    return num <= min ? min : num >= max ? max : num;
  },
  add_zero: function add_zero(i) {
    if (i < 10) {
      i = "0" + i;
    }

    return i;
  },
  // Start of the day (zero millisecond)
  day_start: function day_start(t) {
    var start = new Date(t);
    return start.setUTCHours(0, 0, 0, 0);
  },
  // Start of the month
  month_start: function month_start(t) {
    var date = new Date(t);
    return Date.UTC(date.getFullYear(), date.getMonth(), 1);
  },
  // Start of the year
  year_start: function year_start(t) {
    return Date.UTC(new Date(t).getFullYear());
  },
  get_year: function get_year(t) {
    if (!t) return undefined;
    return new Date(t).getUTCFullYear();
  },
  get_month: function get_month(t) {
    if (!t) return undefined;
    return new Date(t).getUTCMonth();
  },
  // Nearest in array
  nearest_a: function nearest_a(x, array) {
    var dist = Infinity;
    var val = null;
    var index = -1;

    for (var i = 0; i < array.length; i++) {
      var xi = array[i];

      if (Math.abs(xi - x) < dist) {
        dist = Math.abs(xi - x);
        val = xi;
        index = i;
      }
    }

    return [index, val];
  },
  round: function round(num, decimals) {
    if (decimals === void 0) {
      decimals = 8;
    }

    return parseFloat(num.toFixed(decimals));
  },
  // Strip? No, it's ugly floats in js
  strip: function strip(number) {
    return parseFloat(parseFloat(number).toPrecision(12));
  },
  get_day: function get_day(t) {
    return t ? new Date(t).getDate() : null;
  },
  // Update array keeping the same reference
  overwrite: function overwrite(arr, new_arr) {
    arr.splice.apply(arr, [0, arr.length].concat(_toConsumableArray(new_arr)));
  },
  // Copy layout in reactive way
  copy_layout: function copy_layout(obj, new_obj) {
    for (var k in obj) {
      if (Array.isArray(obj[k])) {
        // (some offchart indicators are added/removed)
        // we need to update layout in a reactive way
        if (obj[k].length !== new_obj[k].length) {
          this.overwrite(obj[k], new_obj[k]);
          continue;
        }

        for (var m in obj[k]) {
          Object.assign(obj[k][m], new_obj[k][m]);
        }
      } else {
        Object.assign(obj[k], new_obj[k]);
      }
    }
  },
  // Detects candles interval
  detect_interval: function detect_interval(ohlcv) {
    var len = Math.min(ohlcv.length - 1, 99);
    var min = Infinity;
    ohlcv.slice(0, len).forEach(function (x, i) {
      var d = ohlcv[i + 1][0] - x[0];
      if (d === d && d < min) min = d;
    }); // This saves monthly chart from being awkward

    if (min >= constants.MONTH && min <= constants.DAY * 30) {
      return constants.DAY * 31;
    }

    return min;
  },
  // Gets numberic part of overlay id (e.g 'EMA_1' = > 1)
  get_num_id: function get_num_id(id) {
    return parseInt(id.split('_').pop());
  },
  // Fast filter. Really fast, like 10X
  fast_filter: function fast_filter(arr, t1, t2) {
    if (!arr.length) return [arr, undefined];

    try {
      var ia = new (lib_default())(arr, "0");
      var res = ia.getRange(t1, t2);
      var i0 = ia.valpos[t1].next;
      return [res, i0];
    } catch (e) {
      // Something wrong with fancy slice lib
      // Fast fix: fallback to filter
      return [arr.filter(function (x) {
        return x[0] >= t1 && x[0] <= t2;
      }), 0];
    }
  },
  // Fast filter (index-based)
  fast_filter_i: function fast_filter_i(arr, t1, t2) {
    if (!arr.length) return [arr, undefined];
    var i1 = Math.floor(t1);
    if (i1 < 0) i1 = 0;
    var i2 = Math.floor(t2 + 1);
    var res = arr.slice(i1, i2);
    return [res, i1];
  },
  // Nearest indexes (left and right)
  fast_nearest: function fast_nearest(arr, t1) {
    var ia = new (lib_default())(arr, "0");
    ia.fetch(t1);
    return [ia.nextlow, ia.nexthigh];
  },
  now: function now() {
    return new Date().getTime();
  },
  pause: function pause(delay) {
    return new Promise(function (rs, rj) {
      return setTimeout(rs, delay);
    });
  },
  // Limit crazy wheel delta values
  smart_wheel: function smart_wheel(delta) {
    var abs = Math.abs(delta);

    if (abs > 500) {
      return (200 + Math.log(abs)) * Math.sign(delta);
    }

    return delta;
  },
  // Parse the original mouse event to find deltaX
  get_deltaX: function get_deltaX(event) {
    return event.originalEvent.deltaX / 12;
  },
  // Parse the original mouse event to find deltaY
  get_deltaY: function get_deltaY(event) {
    return event.originalEvent.deltaY / 12;
  },
  // Apply opacity to a hex color
  apply_opacity: function apply_opacity(c, op) {
    if (c.length === 7) {
      var n = Math.floor(op * 255);
      n = this.clamp(n, 0, 255);
      c += n.toString(16);
    }

    return c;
  },
  // Parse timeframe or return value in ms
  parse_tf: function parse_tf(smth) {
    if (typeof smth === 'string') {
      return constants.map_unit[smth];
    } else {
      return smth;
    }
  },
  // Detect index shift between the main data sub
  // and the overlay's sub (for IB-mode)
  index_shift: function index_shift(sub, data) {
    // Find the second timestamp (by value)
    if (!data.length) return 0;
    var first = data[0][0];
    var second;

    for (var i = 1; i < data.length; i++) {
      if (data[i][0] !== first) {
        second = data[i][0];
        break;
      }
    }

    for (var j = 0; j < sub.length; j++) {
      if (sub[j][0] === second) {
        return j - i;
      }
    }

    return 0;
  },
  // Fallback fix for Brave browser
  // https://github.com/brave/brave-browser/issues/1738
  measureText: function measureText(ctx, text, tv_id) {
    var m = ctx.measureTextOrg(text);

    if (m.width === 0) {
      var doc = document;
      var id = 'tvjs-measure-text';
      var el = doc.getElementById(id);

      if (!el) {
        var base = doc.getElementById(tv_id);
        el = doc.createElement("div");
        el.id = id;
        el.style.position = 'absolute';
        el.style.top = '-1000px';
        base.appendChild(el);
      }

      if (ctx.font) el.style.font = ctx.font;
      el.innerText = text.replace(/ /g, '.');
      return {
        width: el.offsetWidth
      };
    } else {
      return m;
    }
  },
  uuid: function uuid(temp) {
    if (temp === void 0) {
      temp = 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx';
    }

    return temp.replace(/[xy]/g, function (c) {
      var r = Math.random() * 16 | 0,
          v = c == 'x' ? r : r & 0x3 | 0x8;
      return v.toString(16);
    });
  },
  uuid2: function uuid2() {
    return this.uuid('xxxxxxxxxxxx');
  },
  // Delayed warning, f = condition lambda fn
  warn: function warn(f, text, delay) {
    if (delay === void 0) {
      delay = 0;
    }

    setTimeout(function () {
      if (f()) console.warn(text);
    }, delay);
  },
  // Checks if script props updated
  // (and not style settings or something else)
  is_scr_props_upd: function is_scr_props_upd(n, prev) {
    var p = prev.find(function (x) {
      return x.v.$uuid === n.v.$uuid;
    });
    if (!p) return false;
    var props = n.p.settings.$props;
    if (!props) return false;
    return props.some(function (x) {
      return n.v[x] !== p.v[x];
    });
  },
  // Checks if it's time to make a script update
  // (based on execInterval in ms)
  delayed_exec: function delayed_exec(v) {
    if (!v.script || !v.script.execInterval) return true;
    var t = this.now();
    var dt = v.script.execInterval;

    if (!v.settings.$last_exec || t > v.settings.$last_exec + dt) {
      v.settings.$last_exec = t;
      return true;
    }

    return false;
  },
  // Format names such 'RSI, $length', where
  // length - is one of the settings
  format_name: function format_name(ov) {
    if (!ov.name) return undefined;
    var name = ov.name;

    for (var k in ov.settings || {}) {
      var val = ov.settings[k];
      var reg = new RegExp("\\$".concat(k), 'g');
      name = name.replace(reg, val);
    }

    return name;
  },
  // Default cursor mode
  xmode: function xmode() {
    return this.is_mobile ? 'explore' : 'default';
  },
  default_prevented: function default_prevented(event) {
    if (event.original) {
      return event.original.defaultPrevented;
    }

    return event.defaultPrevented;
  },
  // WTF with modern web development
  is_mobile: function (w) {
    return 'onorientationchange' in w && (!!navigator.maxTouchPoints || !!navigator.msMaxTouchPoints || 'ontouchstart' in w || w.DocumentTouch && document instanceof w.DocumentTouch);
  }(typeof window !== 'undefined' ? window : {})
});
;// CONCATENATED MODULE: ./src/stuff/math.js
// Math/Geometry
/* harmony default export */ const math = ({
  // Distance from point to line
  // p1 = point, (p2, p3) = line
  point2line: function point2line(p1, p2, p3) {
    var _this$tri = this.tri(p1, p2, p3),
        area = _this$tri.area,
        base = _this$tri.base;

    return Math.abs(this.tri_h(area, base));
  },
  // Distance from point to segment
  // p1 = point, (p2, p3) = segment
  point2seg: function point2seg(p1, p2, p3) {
    var _this$tri2 = this.tri(p1, p2, p3),
        area = _this$tri2.area,
        base = _this$tri2.base; // Vector projection


    var proj = this.dot_prod(p1, p2, p3) / base; // Distance from left pin

    var l1 = Math.max(-proj, 0); // Distance from right pin

    var l2 = Math.max(proj - base, 0); // Normal

    var h = Math.abs(this.tri_h(area, base));
    return Math.max(h, l1, l2);
  },
  // Distance from point to ray
  // p1 = point, (p2, p3) = ray
  point2ray: function point2ray(p1, p2, p3) {
    var _this$tri3 = this.tri(p1, p2, p3),
        area = _this$tri3.area,
        base = _this$tri3.base; // Vector projection


    var proj = this.dot_prod(p1, p2, p3) / base; // Distance from left pin

    var l1 = Math.max(-proj, 0); // Normal

    var h = Math.abs(this.tri_h(area, base));
    return Math.max(h, l1);
  },
  tri: function tri(p1, p2, p3) {
    var area = this.area(p1, p2, p3);
    var dx = p3[0] - p2[0];
    var dy = p3[1] - p2[1];
    var base = Math.sqrt(dx * dx + dy * dy);
    return {
      area: area,
      base: base
    };
  },

  /* Area of triangle:
          p1
        /    \
      p2  _  p3
  */
  area: function area(p1, p2, p3) {
    return p1[0] * (p2[1] - p3[1]) + p2[0] * (p3[1] - p1[1]) + p3[0] * (p1[1] - p2[1]);
  },
  // Triangle height
  tri_h: function tri_h(area, base) {
    return area / base;
  },
  // Dot product of (p2, p3) and (p2, p1)
  dot_prod: function dot_prod(p1, p2, p3) {
    var v1 = [p3[0] - p2[0], p3[1] - p2[1]];
    var v2 = [p1[0] - p2[0], p1[1] - p2[1]];
    return v1[0] * v2[0] + v1[1] * v2[1];
  },
  // Symmetrical log
  log: function log(x) {
    // TODO: log for small values
    return Math.sign(x) * Math.log(Math.abs(x) + 1);
  },
  // Symmetrical exp
  exp: function exp(x) {
    return Math.sign(x) * (Math.exp(Math.abs(x)) - 1);
  },
  // Middle line on log scale based on range & px height
  log_mid: function log_mid(r, h) {
    var log_hi = this.log(r[0]);
    var log_lo = this.log(r[1]);
    var px = h / 2;
    var gx = log_hi - px * (log_hi - log_lo) / h;
    return this.exp(gx);
  },
  // Return new adjusted range, based on the previous
  // range, new $_hi, target middle line
  re_range: function re_range(r1, hi2, mid) {
    var log_hi1 = this.log(r1[0]);
    var log_lo1 = this.log(r1[1]);
    var log_hi2 = this.log(hi2);
    var log_$ = this.log(mid);
    var W = (log_hi2 - log_$) * (log_hi1 - log_lo1) / (log_hi1 - log_$);
    return this.exp(log_hi2 - W);
  } // Return new adjusted range, based on the previous
  // range, new $_hi, target middle line + dy (shift)
  // WASTE

  /*range_shift(r1, hi2, mid, dy, h) {
      let log_hi1 = this.log(r1[0])
      let log_lo1 = this.log(r1[1])
      let log_hi2 = this.log(hi2)
      let log_$ = this.log(mid)
       let W = h * (log_hi2 - log_$) /
              (h * (log_hi1 - log_$) / (log_hi1 - log_lo1) + dy)
       return this.exp(log_hi2 - W)
   }*/

});
;// CONCATENATED MODULE: ./src/components/js/layout_fn.js
// Layout functional interface


/* harmony default export */ function layout_fn(self, range) {
  var ib = self.ti_map.ib;
  var dt = range[1] - range[0];
  var r = self.spacex / dt;
  var ls = self.grid.logScale || false;
  Object.assign(self, {
    // Time to screen coordinates
    t2screen: function t2screen(t) {
      if (ib) t = self.ti_map.smth2i(t);
      return Math.floor((t - range[0]) * r) - 0.5;
    },
    // $ to screen coordinates
    $2screen: function $2screen(y) {
      if (ls) y = math.log(y);
      return Math.floor(y * self.A + self.B) - 0.5;
    },
    // Time-axis nearest step
    t_magnet: function t_magnet(t) {
      if (ib) t = self.ti_map.smth2i(t);
      var cn = self.candles || self.master_grid.candles;
      var arr = cn.map(function (x) {
        return x.raw[0];
      });
      var i = utils.nearest_a(t, arr)[0];
      if (!cn[i]) return;
      return Math.floor(cn[i].x) - 0.5;
    },
    // Screen-Y to dollar value (or whatever)
    screen2$: function screen2$(y) {
      if (ls) return math.exp((y - self.B) / self.A);
      return (y - self.B) / self.A;
    },
    // Screen-X to timestamp
    screen2t: function screen2t(x) {
      // TODO: most likely Math.floor not needed
      // return Math.floor(range[0] + x / r)
      return range[0] + x / r;
    },
    // $-axis nearest step
    $_magnet: function $_magnet(price) {},
    // Nearest candlestick
    c_magnet: function c_magnet(t) {
      var cn = self.candles || self.master_grid.candles;
      var arr = cn.map(function (x) {
        return x.raw[0];
      });
      var i = utils.nearest_a(t, arr)[0];
      return cn[i];
    },
    // Nearest data points
    data_magnet: function data_magnet(t) {
      /* TODO: implement */
    }
  });
  return self;
}
;// CONCATENATED MODULE: ./src/components/js/log_scale.js
// Log-scale mode helpers
// TODO: all-negative numbers (sometimes wrong scaling)

/* harmony default export */ const log_scale = ({
  candle: function candle(self, mid, p, $p) {
    return {
      x: mid,
      w: self.px_step * $p.config.CANDLEW,
      o: Math.floor(math.log(p[1]) * self.A + self.B),
      h: Math.floor(math.log(p[2]) * self.A + self.B),
      l: Math.floor(math.log(p[3]) * self.A + self.B),
      c: Math.floor(math.log(p[4]) * self.A + self.B),
      raw: p
    };
  },
  expand: function expand(self, height) {
    // expand log scale
    var A = -height / (math.log(self.$_hi) - math.log(self.$_lo));
    var B = -math.log(self.$_hi) * A;
    var top = -height * 0.1;
    var bot = height * 1.1;
    self.$_hi = math.exp((top - B) / A);
    self.$_lo = math.exp((bot - B) / A);
  }
});
;// CONCATENATED MODULE: ./src/components/js/grid_maker.js






var grid_maker_TIMESCALES = constants.TIMESCALES,
    grid_maker_$SCALES = constants.$SCALES,
    grid_maker_WEEK = constants.WEEK,
    grid_maker_MONTH = constants.MONTH,
    grid_maker_YEAR = constants.YEAR,
    grid_maker_HOUR = constants.HOUR,
    grid_maker_DAY = constants.DAY;
var MAX_INT = Number.MAX_SAFE_INTEGER; // master_grid - ref to the master grid

function GridMaker(id, params, master_grid) {
  if (master_grid === void 0) {
    master_grid = null;
  }

  var sub = params.sub,
      interval = params.interval,
      range = params.range,
      ctx = params.ctx,
      $p = params.$p,
      layers_meta = params.layers_meta,
      height = params.height,
      y_t = params.y_t,
      ti_map = params.ti_map,
      grid = params.grid,
      timezone = params.timezone;
  var self = {
    ti_map: ti_map
  };
  var lm = layers_meta[id];
  var y_range_fn = null;
  var ls = grid.logScale;

  if (lm && Object.keys(lm).length) {
    // Gets last y_range fn()
    var yrs = Object.values(lm).filter(function (x) {
      return x.y_range;
    }); // The first y_range() determines the range

    if (yrs.length) y_range_fn = yrs[0].y_range;
  } // Calc vertical ($/) range


  function calc_$range() {
    if (!master_grid) {
      // $ candlestick range
      if (y_range_fn) {
        var _y_range_fn = y_range_fn(hi, lo),
            _y_range_fn2 = _slicedToArray(_y_range_fn, 2),
            hi = _y_range_fn2[0],
            lo = _y_range_fn2[1];
      } else {
        hi = -Infinity, lo = Infinity;

        for (var i = 0, n = sub.length; i < n; i++) {
          var x = sub[i];
          if (x[2] > hi) hi = x[2];
          if (x[3] < lo) lo = x[3];
        }
      }
    } else {
      // Offchart indicator range
      hi = -Infinity, lo = Infinity;

      for (var i = 0; i < sub.length; i++) {
        for (var j = 1; j < sub[i].length; j++) {
          var v = sub[i][j];
          if (v > hi) hi = v;
          if (v < lo) lo = v;
        }
      }

      if (y_range_fn) {
        var _y_range_fn3 = y_range_fn(hi, lo),
            _y_range_fn4 = _slicedToArray(_y_range_fn3, 3),
            hi = _y_range_fn4[0],
            lo = _y_range_fn4[1],
            exp = _y_range_fn4[2];
      }
    } // Fixed y-range in non-auto mode


    if (y_t && !y_t.auto && y_t.range) {
      self.$_hi = y_t.range[0];
      self.$_lo = y_t.range[1];
    } else {
      if (!ls) {
        exp = exp === false ? 0 : 1;
        self.$_hi = hi + (hi - lo) * $p.config.EXPAND * exp;
        self.$_lo = lo - (hi - lo) * $p.config.EXPAND * exp;
      } else {
        self.$_hi = hi;
        self.$_lo = lo;
        log_scale.expand(self, height);
      }

      if (self.$_hi === self.$_lo) {
        if (!ls) {
          self.$_hi *= 1.05; // Expand if height range === 0

          self.$_lo *= 0.95;
        } else {
          log_scale.expand(self, height);
        }
      }
    }
  }

  function calc_sidebar() {
    if (sub.length < 2) {
      self.prec = 0;
      self.sb = $p.config.SBMIN;
      return;
    } // TODO: improve sidebar width calculation
    // at transition point, when one precision is
    // replaced with another
    // Gets formated levels (their lengths),
    // calculates max and measures the sidebar length
    // from it:
    // TODO: add custom formatter f()


    self.prec = calc_precision(sub);
    var lens = [];
    lens.push(self.$_hi.toFixed(self.prec).length);
    lens.push(self.$_lo.toFixed(self.prec).length);
    var str = '0'.repeat(Math.max.apply(Math, lens)) + '    ';
    self.sb = ctx.measureText(str).width;
    self.sb = Math.max(Math.floor(self.sb), $p.config.SBMIN);
    self.sb = Math.min(self.sb, $p.config.SBMAX);
  } // Calculate $ precision for the Y-axis


  function calc_precision(data) {
    var max_r = 0,
        max_l = 0;
    var min = Infinity;
    var max = -Infinity; // Speed UP

    for (var i = 0, n = data.length; i < n; i++) {
      var x = data[i];
      if (x[1] > max) max = x[1];else if (x[1] < min) min = x[1];
    } // Get max lengths of integer and fractional parts


    [min, max].forEach(function (x) {
      // Fix undefined bug
      var str = x != null ? x.toString() : '';

      if (x < 0.000001) {
        // Parsing the exponential form. Gosh this
        // smells trickily
        var _str$split = str.split('e-'),
            _str$split2 = _slicedToArray(_str$split, 2),
            ls = _str$split2[0],
            rs = _str$split2[1];

        var _ls$split = ls.split('.'),
            _ls$split2 = _slicedToArray(_ls$split, 2),
            l = _ls$split2[0],
            r = _ls$split2[1];

        if (!r) r = '';
        r = {
          length: r.length + parseInt(rs) || 0
        };
      } else {
        var _str$split3 = str.split('.'),
            _str$split4 = _slicedToArray(_str$split3, 2),
            l = _str$split4[0],
            r = _str$split4[1];
      }

      if (r && r.length > max_r) {
        max_r = r.length;
      }

      if (l && l.length > max_l) {
        max_l = l.length;
      }
    }); // Select precision scheme depending
    // on the left and right part lengths
    //

    var even = max_r - max_r % 2 + 2;

    if (max_l === 1) {
      return Math.min(8, Math.max(2, even));
    }

    if (max_l <= 2) {
      return Math.min(4, Math.max(2, even));
    }

    return 2;
  }

  function calc_positions() {
    if (sub.length < 2) return;
    var dt = range[1] - range[0]; // A pixel space available to draw on (x-axis)

    self.spacex = $p.width - self.sb; // Candle capacity

    var capacity = dt / interval;
    self.px_step = self.spacex / capacity; // px / time ratio

    var r = self.spacex / dt;
    self.startx = (sub[0][0] - range[0]) * r; // Candle Y-transform: (A = scale, B = shift)

    if (!grid.logScale) {
      self.A = -height / (self.$_hi - self.$_lo);
      self.B = -self.$_hi * self.A;
    } else {
      self.A = -height / (math.log(self.$_hi) - math.log(self.$_lo));
      self.B = -math.log(self.$_hi) * self.A;
    }
  } // Select nearest good-loking t step (m is target scale)


  function time_step() {
    var k = ti_map.ib ? 60000 : 1;
    var xrange = (range[1] - range[0]) * k;
    var m = xrange * ($p.config.GRIDX / $p.width);
    var s = grid_maker_TIMESCALES;
    return utils.nearest_a(m, s)[1] / k;
  } // Select nearest good-loking $ step (m is target scale)


  function dollar_step() {
    var yrange = self.$_hi - self.$_lo;
    var m = yrange * ($p.config.GRIDY / height);
    var p = parseInt(yrange.toExponential().split('e')[1]);
    var d = Math.pow(10, p);
    var s = grid_maker_$SCALES.map(function (x) {
      return x * d;
    }); // TODO: center the range (look at RSI for example,
    // it looks ugly when "80" is near the top)

    return utils.strip(utils.nearest_a(m, s)[1]);
  }

  function dollar_mult() {
    var mult_hi = dollar_mult_hi();
    var mult_lo = dollar_mult_lo();
    return Math.max(mult_hi, mult_lo);
  } // Price step multiplier (for the log-scale mode)


  function dollar_mult_hi() {
    var h = Math.min(self.B, height);
    if (h < $p.config.GRIDY) return 1;
    var n = h / $p.config.GRIDY; // target grid N

    var yrange = self.$_hi;

    if (self.$_lo > 0) {
      var yratio = self.$_hi / self.$_lo;
    } else {
      yratio = self.$_hi / 1; // TODO: small values
    }

    var m = yrange * ($p.config.GRIDY / h);
    var p = parseInt(yrange.toExponential().split('e')[1]);
    return Math.pow(yratio, 1 / n);
  }

  function dollar_mult_lo() {
    var h = Math.min(height - self.B, height);
    if (h < $p.config.GRIDY) return 1;
    var n = h / $p.config.GRIDY; // target grid N

    var yrange = Math.abs(self.$_lo);

    if (self.$_hi < 0 && self.$_lo < 0) {
      var yratio = Math.abs(self.$_lo / self.$_hi);
    } else {
      yratio = Math.abs(self.$_lo) / 1;
    }

    var m = yrange * ($p.config.GRIDY / h);
    var p = parseInt(yrange.toExponential().split('e')[1]);
    return Math.pow(yratio, 1 / n);
  }

  function grid_x() {
    // If this is a subgrid, no need to calc a timeline,
    // we just borrow it from the master_grid
    if (!master_grid) {
      self.t_step = time_step();
      self.xs = [];
      var dt = range[1] - range[0];
      var r = self.spacex / dt;
      /* TODO: remove the left-side glitch
       let year_0 = Utils.get_year(sub[0][0])
      for (var t0 = year_0; t0 < range[0]; t0 += self.t_step) {}
       let m0 = Utils.get_month(t0)*/

      for (var i = 0; i < sub.length; i++) {
        var p = sub[i];
        var prev = sub[i - 1] || [];
        var prev_xs = self.xs[self.xs.length - 1] || [0, []];
        var x = Math.floor((p[0] - range[0]) * r);
        insert_line(prev, p, x); // Filtering lines that are too near

        var xs = self.xs[self.xs.length - 1] || [0, []];
        if (prev_xs === xs) continue;

        if (xs[1][0] - prev_xs[1][0] < self.t_step * 0.8) {
          // prev_xs is a higher "rank" label
          if (xs[2] <= prev_xs[2]) {
            self.xs.pop();
          } else {
            // Otherwise
            self.xs.splice(self.xs.length - 2, 1);
          }
        }
      } // TODO: fix grid extension for bigger timeframes


      if (interval < grid_maker_WEEK && r > 0) {
        extend_left(dt, r);
        extend_right(dt, r);
      }
    } else {
      self.t_step = master_grid.t_step;
      self.px_step = master_grid.px_step;
      self.startx = master_grid.startx;
      self.xs = master_grid.xs;
    }
  }

  function insert_line(prev, p, x, m0) {
    var prev_t = ti_map.ib ? ti_map.i2t(prev[0]) : prev[0];
    var p_t = ti_map.ib ? ti_map.i2t(p[0]) : p[0];

    if (ti_map.tf < grid_maker_DAY) {
      prev_t += timezone * grid_maker_HOUR;
      p_t += timezone * grid_maker_HOUR;
    }

    var d = timezone * grid_maker_HOUR; // TODO: take this block =========> (see below)

    if ((prev[0] || interval === grid_maker_YEAR) && utils.get_year(p_t) !== utils.get_year(prev_t)) {
      self.xs.push([x, p, grid_maker_YEAR]); // [px, [...], rank]
    } else if (prev[0] && utils.get_month(p_t) !== utils.get_month(prev_t)) {
      self.xs.push([x, p, grid_maker_MONTH]);
    } // TODO: should be added if this day !== prev day
    // And the same for 'botbar.js', TODO(*)
    else if (utils.day_start(p_t) === p_t) {
        self.xs.push([x, p, grid_maker_DAY]);
      } else if (p[0] % self.t_step === 0) {
        self.xs.push([x, p, interval]);
      }
  }

  function extend_left(dt, r) {
    if (!self.xs.length || !isFinite(r)) return;
    var t = self.xs[0][1][0];

    while (true) {
      t -= self.t_step;
      var x = Math.floor((t - range[0]) * r);
      if (x < 0) break; // TODO: ==========> And insert it here somehow

      if (t % interval === 0) {
        self.xs.unshift([x, [t], interval]);
      }
    }
  }

  function extend_right(dt, r) {
    if (!self.xs.length || !isFinite(r)) return;
    var t = self.xs[self.xs.length - 1][1][0];

    while (true) {
      t += self.t_step;
      var x = Math.floor((t - range[0]) * r);
      if (x > self.spacex) break;

      if (t % interval === 0) {
        self.xs.push([x, [t], interval]);
      }
    }
  }

  function grid_y() {
    // Prevent duplicate levels
    var m = Math.pow(10, -self.prec);
    self.$_step = Math.max(m, dollar_step());
    self.ys = [];
    var y1 = self.$_lo - self.$_lo % self.$_step;

    for (var y$ = y1; y$ <= self.$_hi; y$ += self.$_step) {
      var y = Math.floor(y$ * self.A + self.B);
      if (y > height) continue;
      self.ys.push([y, utils.strip(y$)]);
    }
  }

  function grid_y_log() {
    // TODO: Prevent duplicate levels, is this even
    // a problem here ?
    self.$_mult = dollar_mult();
    self.ys = [];
    if (!sub.length) return;
    var v = Math.abs(sub[sub.length - 1][1] || 1);
    var y1 = search_start_pos(v);
    var y2 = search_start_neg(-v);
    var yp = -Infinity; // Previous y value

    var n = height / $p.config.GRIDY; // target grid N

    var q = 1 + (self.$_mult - 1) / 2; // Over 0

    for (var y$ = y1; y$ > 0; y$ /= self.$_mult) {
      y$ = log_rounder(y$, q);
      var y = Math.floor(math.log(y$) * self.A + self.B);
      self.ys.push([y, utils.strip(y$)]);
      if (y > height) break;
      if (y - yp < $p.config.GRIDY * 0.7) break;
      if (self.ys.length > n + 1) break;
      yp = y;
    } // Under 0


    yp = Infinity;

    for (var y$ = y2; y$ < 0; y$ /= self.$_mult) {
      y$ = log_rounder(y$, q);

      var _y = Math.floor(math.log(y$) * self.A + self.B);

      if (yp - _y < $p.config.GRIDY * 0.7) break;
      self.ys.push([_y, utils.strip(y$)]);
      if (_y < 0) break;
      if (self.ys.length > n * 3 + 1) break;
      yp = _y;
    } // TODO: remove lines near to 0

  } // Search a start for the top grid so that
  // the fixed value always included


  function search_start_pos(value) {
    var N = height / $p.config.GRIDY; // target grid N

    var y = Infinity,
        y$ = value,
        count = 0;

    while (y > 0) {
      y = Math.floor(math.log(y$) * self.A + self.B);
      y$ *= self.$_mult;
      if (count++ > N * 3) return 0; // Prevents deadloops
    }

    return y$;
  }

  function search_start_neg(value) {
    var N = height / $p.config.GRIDY; // target grid N

    var y = -Infinity,
        y$ = value,
        count = 0;

    while (y < height) {
      y = Math.floor(math.log(y$) * self.A + self.B);
      y$ *= self.$_mult;
      if (count++ > N * 3) break; // Prevents deadloops
    }

    return y$;
  } // Make log scale levels look great again


  function log_rounder(x, quality) {
    var s = Math.sign(x);
    x = Math.abs(x);

    if (x > 10) {
      for (var div = 10; div < MAX_INT; div *= 10) {
        var nice = Math.floor(x / div) * div;

        if (x / nice > quality) {
          // More than 10% off
          break;
        }
      }

      div /= 10;
      return s * Math.floor(x / div) * div;
    } else if (x < 1) {
      for (var ro = 10; ro >= 1; ro--) {
        var _nice = utils.round(x, ro);

        if (x / _nice > quality) {
          // More than 10% off
          break;
        }
      }

      return s * utils.round(x, ro + 1);
    } else {
      return s * Math.floor(x);
    }
  }

  function apply_sizes() {
    self.width = $p.width - self.sb;
    self.height = height;
  }

  calc_$range();
  calc_sidebar();
  return {
    // First we need to calculate max sidebar width
    // (among all grids). Then we can actually make
    // them
    create: function create() {
      calc_positions();
      grid_x();

      if (grid.logScale) {
        grid_y_log();
      } else {
        grid_y();
      }

      apply_sizes(); // Link to the master grid (candlesticks)

      if (master_grid) {
        self.master_grid = master_grid;
      }

      self.grid = grid; // Grid params
      // Here we add some helpful functions for
      // plugin creators

      return layout_fn(self, range);
    },
    get_layout: function get_layout() {
      return self;
    },
    set_sidebar: function set_sidebar(v) {
      return self.sb = v;
    },
    get_sidebar: function get_sidebar() {
      return self.sb;
    }
  };
}

/* harmony default export */ const grid_maker = (GridMaker);
;// CONCATENATED MODULE: ./src/components/js/layout.js



function _createForOfIteratorHelper(o, allowArrayLike) { var it; if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (it = layout_unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = o[Symbol.iterator](); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it["return"] != null) it["return"](); } finally { if (didErr) throw err; } } }; }

function layout_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return layout_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return layout_arrayLikeToArray(o, minLen); }

function layout_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

// Calculates all necessary s*it to build the chart
// Heights, widths, transforms, ... = everything
// Why such a mess you ask? Well, that's because
// one components size can depend on other component
// data formatting (e.g. grid width depends on sidebar precision)
// So it's better to calc all in one place.





function Layout(params) {
  var chart = params.chart,
      sub = params.sub,
      offsub = params.offsub,
      interval = params.interval,
      range = params.range,
      ctx = params.ctx,
      layers_meta = params.layers_meta,
      ti_map = params.ti_map,
      $p = params.$props,
      y_ts = params.y_transforms;
  var mgrid = chart.grid || {};
  offsub = offsub.filter(function (x, i) {
    // Skip offchart overlays with custom grid id,
    // because they will be mergred with the existing grids
    return !(x.grid && x.grid.id);
  }); // Splits space between main chart
  // and offchart indicator grids

  function grid_hs() {
    var height = $p.height - $p.config.BOTBAR; // When at least one height defined (default = 1),
    // Pxs calculated as: (sum of weights) / number

    if (mgrid.height || offsub.find(function (x) {
      return x.grid.height;
    })) {
      return weighted_hs(mgrid, height);
    }

    var n = offsub.length;
    var off_h = 2 * Math.sqrt(n) / 7 / (n || 1); // Offchart grid height

    var px = Math.floor(height * off_h); // Main grid height

    var m = height - px * n;
    return [m].concat(Array(n).fill(px));
  }

  function weighted_hs(grid, height) {
    var hs = [{
      grid: grid
    }].concat(_toConsumableArray(offsub)).map(function (x) {
      return x.grid.height || 1;
    });
    var sum = hs.reduce(function (a, b) {
      return a + b;
    }, 0);
    hs = hs.map(function (x) {
      return Math.floor(x / sum * height);
    }); // Refine the height if Math.floor decreased px sum

    sum = hs.reduce(function (a, b) {
      return a + b;
    }, 0);

    for (var i = 0; i < height - sum; i++) {
      hs[i % hs.length]++;
    }

    return hs;
  }

  function candles_n_vol() {
    self.candles = [];
    self.volume = [];
    var maxv = Math.max.apply(Math, _toConsumableArray(sub.map(function (x) {
      return x[5];
    })));
    var vs = $p.config.VOLSCALE * $p.height / maxv;
    var x1,
        x2,
        mid,
        prev = undefined;
    var splitter = self.px_step > 5 ? 1 : 0;
    var hf_px_step = self.px_step * 0.5;

    for (var i = 0; i < sub.length; i++) {
      var p = sub[i];
      mid = self.t2screen(p[0]) + 0.5;
      self.candles.push(mgrid.logScale ? log_scale.candle(self, mid, p, $p) : {
        x: mid,
        w: self.px_step * $p.config.CANDLEW,
        o: Math.floor(p[1] * self.A + self.B),
        h: Math.floor(p[2] * self.A + self.B),
        l: Math.floor(p[3] * self.A + self.B),
        c: Math.floor(p[4] * self.A + self.B),
        raw: p
      }); // Clear volume bar if there is a time gap

      if (sub[i - 1] && p[0] - sub[i - 1][0] > interval) {
        prev = null;
      }

      x1 = prev || Math.floor(mid - hf_px_step);
      x2 = Math.floor(mid + hf_px_step) - 0.5;
      self.volume.push({
        x1: x1,
        x2: x2,
        h: p[5] * vs,
        green: p[4] >= p[1],
        raw: p
      });
      prev = x2 + splitter;
    }
  } // Main grid


  var hs = grid_hs();
  var specs = {
    sub: sub,
    interval: interval,
    range: range,
    ctx: ctx,
    $p: $p,
    layers_meta: layers_meta,
    ti_map: ti_map,
    height: hs[0],
    y_t: y_ts[0],
    grid: mgrid,
    timezone: $p.timezone
  };
  var gms = [new grid_maker(0, specs)]; // Sub grids

  var _iterator = _createForOfIteratorHelper(offsub.entries()),
      _step;

  try {
    for (_iterator.s(); !(_step = _iterator.n()).done;) {
      var _step$value = _slicedToArray(_step.value, 2),
          i = _step$value[0],
          _step$value$ = _step$value[1],
          data = _step$value$.data,
          grid = _step$value$.grid;

      specs.sub = data;
      specs.height = hs[i + 1];
      specs.y_t = y_ts[i + 1];
      specs.grid = grid || {};
      gms.push(new grid_maker(i + 1, specs, gms[0].get_layout()));
    } // Max sidebar among all grinds

  } catch (err) {
    _iterator.e(err);
  } finally {
    _iterator.f();
  }

  var sb = Math.max.apply(Math, _toConsumableArray(gms.map(function (x) {
    return x.get_sidebar();
  })));
  var grids = [],
      offset = 0;

  for (i = 0; i < gms.length; i++) {
    gms[i].set_sidebar(sb);
    grids.push(gms[i].create());
    grids[i].id = i;
    grids[i].offset = offset;
    offset += grids[i].height;
  }

  var self = grids[0];
  candles_n_vol();
  return {
    grids: grids,
    botbar: {
      width: $p.width,
      height: $p.config.BOTBAR,
      offset: offset,
      xs: grids[0] ? grids[0].xs : []
    }
  };
}

/* harmony default export */ const layout = (Layout);
;// CONCATENATED MODULE: ./node_modules/@babel/runtime/helpers/esm/classCallCheck.js
function classCallCheck_classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
;// CONCATENATED MODULE: ./node_modules/@babel/runtime/helpers/esm/createClass.js
function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}

function createClass_createClass(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties(Constructor, staticProps);
  return Constructor;
}
;// CONCATENATED MODULE: ./src/components/js/updater.js




function updater_createForOfIteratorHelper(o, allowArrayLike) { var it; if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (it = updater_unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = o[Symbol.iterator](); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it["return"] != null) it["return"](); } finally { if (didErr) throw err; } } }; }

function updater_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return updater_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return updater_arrayLikeToArray(o, minLen); }

function updater_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

// Cursor updater: calculates current values for
// OHLCV and all other indicators


var CursorUpdater = /*#__PURE__*/function () {
  function CursorUpdater(comp) {
    classCallCheck_classCallCheck(this, CursorUpdater);

    this.comp = comp, this.grids = comp._layout.grids, this.cursor = comp.cursor;
  }

  createClass_createClass(CursorUpdater, [{
    key: "sync",
    value: function sync(e) {
      // TODO: values not displaying if a custom grid id is set:
      // grid: { id: N }
      this.cursor.grid_id = e.grid_id;
      var once = true;

      var _iterator = updater_createForOfIteratorHelper(this.grids),
          _step;

      try {
        for (_iterator.s(); !(_step = _iterator.n()).done;) {
          var grid = _step.value;
          var c = this.cursor_data(grid, e);

          if (!this.cursor.locked) {
            // TODO: find a better fix to invisible cursor prob
            if (once) {
              this.cursor.t = this.cursor_time(grid, e, c);
              if (this.cursor.t) once = false;
            }

            if (c.values) {
              this.comp.$set(this.cursor.values, grid.id, c.values);
            }
          }

          if (grid.id !== e.grid_id) continue;
          this.cursor.x = grid.t2screen(this.cursor.t);
          this.cursor.y = c.y;
          this.cursor.y$ = c.y$;
        }
      } catch (err) {
        _iterator.e(err);
      } finally {
        _iterator.f();
      }
    }
  }, {
    key: "overlay_data",
    value: function overlay_data(grid, e) {
      var s = grid.id === 0 ? 'main_section' : 'sub_section';
      var data = this.comp[s].data; // Split offchart data between offchart grids

      if (grid.id > 0) {
        // Sequential grids
        var _d = data.filter(function (x) {
          return x.grid.id === undefined;
        }); // grids with custom ids (for merging)


        var m = data.filter(function (x) {
          return x.grid.id === grid.id;
        });
        data = [_d[grid.id - 1]].concat(_toConsumableArray(m));
      }

      var t = grid.screen2t(e.x);
      var ids = {},
          res = {};

      var _iterator2 = updater_createForOfIteratorHelper(data),
          _step2;

      try {
        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
          var d = _step2.value;
          var ts = d.data.map(function (x) {
            return x[0];
          });
          var i = utils.nearest_a(t, ts)[0];
          d.type in ids ? ids[d.type]++ : ids[d.type] = 0;
          res["".concat(d.type, "_").concat(ids[d.type])] = d.data[i];
        }
      } catch (err) {
        _iterator2.e(err);
      } finally {
        _iterator2.f();
      }

      return res;
    } // Nearest datapoints

  }, {
    key: "cursor_data",
    value: function cursor_data(grid, e) {
      var data = this.comp.main_section.sub;
      var xs = data.map(function (x) {
        return grid.t2screen(x[0]) + 0.5;
      });
      var i = utils.nearest_a(e.x, xs)[0];
      if (!xs[i]) return {};
      return {
        x: Math.floor(xs[i]) - 0.5,
        y: Math.floor(e.y - 2) - 0.5 - grid.offset,
        y$: grid.screen2$(e.y - 2 - grid.offset),
        t: (data[i] || [])[0],
        values: Object.assign({
          ohlcv: grid.id === 0 ? data[i] : undefined
        }, this.overlay_data(grid, e))
      };
    } // Get cursor t-position (extended)

  }, {
    key: "cursor_time",
    value: function cursor_time(grid, mouse, candle) {
      var t = grid.screen2t(mouse.x);
      var r = Math.abs((t - candle.t) / this.comp.interval);
      var sign = Math.sign(t - candle.t);

      if (r >= 0.5) {
        // Outside the data range
        var n = Math.round(r);
        return candle.t + n * this.comp.interval * sign;
      } // Inside the data range


      return candle.t;
    }
  }]);

  return CursorUpdater;
}();

/* harmony default export */ const updater = (CursorUpdater);
;// CONCATENATED MODULE: ./node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!./node_modules/vue-loader/lib/index.js??vue-loader-options!./src/components/Section.vue?vue&type=template&id=8fbe9336&
var Sectionvue_type_template_id_8fbe9336_render = function() {
  var _vm = this
  var _h = _vm.$createElement
  var _c = _vm._self._c || _h
  return _c(
    "div",
    { staticClass: "trading-vue-section" },
    [
      _c("chart-legend", {
        ref: "legend",
        attrs: {
          values: _vm.section_values,
          grid_id: _vm.grid_id,
          common: _vm.legend_props,
          meta_props: _vm.get_meta_props
        },
        on: { "legend-button-click": _vm.button_click }
      }),
      _vm._v(" "),
      _c(
        "grid",
        _vm._b(
          {
            ref: "grid",
            attrs: { grid_id: _vm.grid_id },
            on: {
              "register-kb-listener": _vm.register_kb,
              "remove-kb-listener": _vm.remove_kb,
              "range-changed": _vm.range_changed,
              "cursor-changed": _vm.cursor_changed,
              "cursor-locked": _vm.cursor_locked,
              "layer-meta-props": _vm.emit_meta_props,
              "custom-event": _vm.emit_custom_event,
              "sidebar-transform": _vm.sidebar_transform,
              "rezoom-range": _vm.rezoom_range
            }
          },
          "grid",
          _vm.grid_props,
          false
        )
      ),
      _vm._v(" "),
      _c(
        "sidebar",
        _vm._b(
          {
            ref: "sb-" + _vm.grid_id,
            attrs: { grid_id: _vm.grid_id, rerender: _vm.rerender },
            on: { "sidebar-transform": _vm.sidebar_transform }
          },
          "sidebar",
          _vm.sidebar_props,
          false
        )
      )
    ],
    1
  )
}
var Sectionvue_type_template_id_8fbe9336_staticRenderFns = []
Sectionvue_type_template_id_8fbe9336_render._withStripped = true


;// CONCATENATED MODULE: ./src/components/Section.vue?vue&type=template&id=8fbe9336&

;// CONCATENATED MODULE: ./src/stuff/frame.js


// Annimation frame with a fallback for
// slower devices


var FrameAnimation = /*#__PURE__*/function () {
  function FrameAnimation(cb) {
    var _this = this;

    classCallCheck_classCallCheck(this, FrameAnimation);

    this.t0 = this.t = utils.now();
    this.id = setInterval(function () {
      // The prev frame took too long
      if (utils.now() - _this.t > 100) return;

      if (utils.now() - _this.t0 > 1200) {
        _this.stop();
      }

      if (_this.id) cb(_this);
      _this.t = utils.now();
    }, 16);
  }

  createClass_createClass(FrameAnimation, [{
    key: "stop",
    value: function stop() {
      clearInterval(this.id);
      this.id = null;
    }
  }]);

  return FrameAnimation;
}();


// EXTERNAL MODULE: ./node_modules/hammerjs/hammer.js
var hammer = __nested_webpack_require_9759__(840);
// EXTERNAL MODULE: ./node_modules/hamsterjs/hamster.js
var hamster = __nested_webpack_require_9759__(981);
var hamster_default = /*#__PURE__*/__nested_webpack_require_9759__.n(hamster);
;// CONCATENATED MODULE: ./src/components/js/grid.js





function grid_createForOfIteratorHelper(o, allowArrayLike) { var it; if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (it = grid_unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = o[Symbol.iterator](); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it["return"] != null) it["return"](); } finally { if (didErr) throw err; } } }; }

function grid_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return grid_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return grid_arrayLikeToArray(o, minLen); }

function grid_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

// Grid.js listens to various user-generated events,
// emits Vue-events if something has changed (e.g. range)
// Think of it as an I/O system for Grid.vue




 // Grid is good.

var Grid = /*#__PURE__*/function () {
  function Grid(canvas, comp) {
    classCallCheck_classCallCheck(this, Grid);

    this.MIN_ZOOM = comp.config.MIN_ZOOM;
    this.MAX_ZOOM = comp.config.MAX_ZOOM;
    if (utils.is_mobile) this.MIN_ZOOM *= 0.5;
    this.canvas = canvas;
    this.ctx = canvas.getContext('2d');
    this.comp = comp;
    this.$p = comp.$props;
    this.data = this.$p.sub;
    this.range = this.$p.range;
    this.id = this.$p.grid_id;
    this.layout = this.$p.layout.grids[this.id];
    this.interval = this.$p.interval;
    this.cursor = comp.$props.cursor;
    this.offset_x = 0;
    this.offset_y = 0;
    this.deltas = 0; // Wheel delta events

    this.wmode = this.$p.config.SCROLL_WHEEL;
    this.listeners();
    this.overlays = [];
  }

  createClass_createClass(Grid, [{
    key: "listeners",
    value: function listeners() {
      var _this = this;

      this.hm = hamster_default()(this.canvas);
      this.hm.wheel(function (event, delta) {
        return _this.mousezoom(-delta * 50, event);
      });
      var mc = this.mc = new hammer.Manager(this.canvas);
      var T = utils.is_mobile ? 10 : 0;
      mc.add(new hammer.Pan({
        threshold: T
      }));
      mc.add(new hammer.Tap());
      mc.add(new hammer.Pinch({
        threshold: 0
      }));
      mc.get('pinch').set({
        enable: true
      });
      if (utils.is_mobile) mc.add(new hammer.Press());
      mc.on('panstart', function (event) {
        if (_this.cursor.scroll_lock) return;

        if (_this.cursor.mode === 'aim') {
          return _this.emit_cursor_coord(event);
        }

        var tfrm = _this.$p.y_transform;
        _this.drug = {
          x: event.center.x + _this.offset_x,
          y: event.center.y + _this.offset_y,
          r: _this.range.slice(),
          t: _this.range[1] - _this.range[0],
          o: tfrm ? tfrm.offset || 0 : 0,
          y_r: tfrm && tfrm.range ? tfrm.range.slice() : undefined,
          B: _this.layout.B,
          t0: utils.now()
        };

        _this.comp.$emit('cursor-changed', {
          grid_id: _this.id,
          x: event.center.x + _this.offset_x,
          y: event.center.y + _this.offset_y
        });

        _this.comp.$emit('cursor-locked', true);
      });
      mc.on('panmove', function (event) {
        if (utils.is_mobile) {
          _this.calc_offset();

          _this.propagate('mousemove', _this.touch2mouse(event));
        }

        if (_this.drug) {
          _this.mousedrag(_this.drug.x + event.deltaX, _this.drug.y + event.deltaY);

          _this.comp.$emit('cursor-changed', {
            grid_id: _this.id,
            x: event.center.x + _this.offset_x,
            y: event.center.y + _this.offset_y
          });
        } else if (_this.cursor.mode === 'aim') {
          _this.emit_cursor_coord(event);
        }
      });
      mc.on('panend', function (event) {
        if (utils.is_mobile && _this.drug) {
          _this.pan_fade(event);
        }

        _this.drug = null;

        _this.comp.$emit('cursor-locked', false);
      });
      mc.on('tap', function (event) {
        if (!utils.is_mobile) return;

        _this.sim_mousedown(event);

        if (_this.fade) _this.fade.stop();

        _this.comp.$emit('cursor-changed', {});

        _this.comp.$emit('cursor-changed', {
          /*grid_id: this.id,
          x: undefined,//event.center.x + this.offset_x,
          y: undefined,//event.center.y + this.offset_y,*/
          mode: 'explore'
        });

        _this.update();
      });
      mc.on('pinchstart', function () {
        _this.drug = null;
        _this.pinch = {
          t: _this.range[1] - _this.range[0],
          r: _this.range.slice()
        };
      });
      mc.on('pinchend', function () {
        _this.pinch = null;
      });
      mc.on('pinch', function (event) {
        if (_this.pinch) _this.pinchzoom(event.scale);
      });
      mc.on('press', function (event) {
        if (!utils.is_mobile) return;
        if (_this.fade) _this.fade.stop();

        _this.calc_offset();

        _this.emit_cursor_coord(event, {
          mode: 'aim'
        });

        setTimeout(function () {
          return _this.update();
        });

        _this.sim_mousedown(event);
      });
      var add = addEventListener;
      add("gesturestart", this.gesturestart);
      add("gesturechange", this.gesturechange);
      add("gestureend", this.gestureend);
    }
  }, {
    key: "gesturestart",
    value: function gesturestart(event) {
      event.preventDefault();
    }
  }, {
    key: "gesturechange",
    value: function gesturechange(event) {
      event.preventDefault();
    }
  }, {
    key: "gestureend",
    value: function gestureend(event) {
      event.preventDefault();
    }
  }, {
    key: "mousemove",
    value: function mousemove(event) {
      if (utils.is_mobile) return;
      this.comp.$emit('cursor-changed', {
        grid_id: this.id,
        x: event.layerX,
        y: event.layerY + this.layout.offset
      });
      this.calc_offset();
      this.propagate('mousemove', event);
    }
  }, {
    key: "mouseout",
    value: function mouseout(event) {
      if (utils.is_mobile) return;
      this.comp.$emit('cursor-changed', {});
      this.propagate('mouseout', event);
    }
  }, {
    key: "mouseup",
    value: function mouseup(event) {
      this.drug = null;
      this.comp.$emit('cursor-locked', false);
      this.propagate('mouseup', event);
    }
  }, {
    key: "mousedown",
    value: function mousedown(event) {
      if (utils.is_mobile) return;
      this.propagate('mousedown', event);
      this.comp.$emit('cursor-locked', true);
      if (event.defaultPrevented) return;
      this.comp.$emit('custom-event', {
        event: 'grid-mousedown',
        args: [this.id, event]
      });
    } // Simulated mousedown (for mobile)

  }, {
    key: "sim_mousedown",
    value: function sim_mousedown(event) {
      var _this2 = this;

      if (event.srcEvent.defaultPrevented) return;
      this.comp.$emit('custom-event', {
        event: 'grid-mousedown',
        args: [this.id, event]
      });
      this.propagate('mousemove', this.touch2mouse(event));
      this.update();
      this.propagate('mousedown', this.touch2mouse(event));
      setTimeout(function () {
        _this2.propagate('click', _this2.touch2mouse(event));
      });
    } // Convert touch to "mouse" event

  }, {
    key: "touch2mouse",
    value: function touch2mouse(e) {
      this.calc_offset();
      return {
        original: e.srcEvent,
        layerX: e.center.x + this.offset_x,
        layerY: e.center.y + this.offset_y,
        preventDefault: function preventDefault() {
          this.original.preventDefault();
        }
      };
    }
  }, {
    key: "click",
    value: function click(event) {
      this.propagate('click', event);
    }
  }, {
    key: "emit_cursor_coord",
    value: function emit_cursor_coord(event, add) {
      if (add === void 0) {
        add = {};
      }

      this.comp.$emit('cursor-changed', Object.assign({
        grid_id: this.id,
        x: event.center.x + this.offset_x,
        y: event.center.y + this.offset_y + this.layout.offset
      }, add));
    }
  }, {
    key: "pan_fade",
    value: function pan_fade(event) {
      var _this3 = this;

      var dt = utils.now() - this.drug.t0;
      var dx = this.range[1] - this.drug.r[1];
      var v = 42 * dx / dt;
      var v0 = Math.abs(v * 0.01);
      if (dt > 500) return;
      if (this.fade) this.fade.stop();
      this.fade = new FrameAnimation(function (self) {
        v *= 0.85;

        if (Math.abs(v) < v0) {
          self.stop();
        }

        _this3.range[0] += v;
        _this3.range[1] += v;

        _this3.change_range();
      });
    }
  }, {
    key: "calc_offset",
    value: function calc_offset() {
      var rect = this.canvas.getBoundingClientRect();
      this.offset_x = -rect.x;
      this.offset_y = -rect.y;
    }
  }, {
    key: "new_layer",
    value: function new_layer(layer) {
      if (layer.name === 'crosshair') {
        this.crosshair = layer;
      } else {
        this.overlays.push(layer);
      }

      this.update();
    }
  }, {
    key: "del_layer",
    value: function del_layer(id) {
      this.overlays = this.overlays.filter(function (x) {
        return x.id !== id;
      });
      this.update();
    }
  }, {
    key: "show_hide_layer",
    value: function show_hide_layer(event) {
      var l = this.overlays.filter(function (x) {
        return x.id === event.id;
      });
      if (l.length) l[0].display = event.display;
    }
  }, {
    key: "update",
    value: function update() {
      var _this4 = this;

      // Update reference to the grid
      // TODO: check what happens if data changes interval
      this.layout = this.$p.layout.grids[this.id];
      this.interval = this.$p.interval;
      if (!this.layout) return;
      this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
      if (this.$p.shaders.length) this.apply_shaders();
      this.grid();
      var overlays = [];
      overlays.push.apply(overlays, _toConsumableArray(this.overlays)); // z-index sorting

      overlays.sort(function (l1, l2) {
        return l1.z - l2.z;
      });
      overlays.forEach(function (l) {
        if (!l.display) return;

        _this4.ctx.save();

        var r = l.renderer;
        if (r.pre_draw) r.pre_draw(_this4.ctx);
        r.draw(_this4.ctx);
        if (r.post_draw) r.post_draw(_this4.ctx);

        _this4.ctx.restore();
      });

      if (this.crosshair) {
        this.crosshair.renderer.draw(this.ctx);
      }
    }
  }, {
    key: "apply_shaders",
    value: function apply_shaders() {
      var layout = this.$p.layout.grids[this.id];
      var props = {
        layout: layout,
        range: this.range,
        interval: this.interval,
        tf: layout.ti_map.tf,
        cursor: this.cursor,
        colors: this.$p.colors,
        sub: this.data,
        font: this.$p.font,
        config: this.$p.config,
        meta: this.$p.meta
      };

      var _iterator = grid_createForOfIteratorHelper(this.$p.shaders),
          _step;

      try {
        for (_iterator.s(); !(_step = _iterator.n()).done;) {
          var s = _step.value;
          this.ctx.save();
          s.draw(this.ctx, props);
          this.ctx.restore();
        }
      } catch (err) {
        _iterator.e(err);
      } finally {
        _iterator.f();
      }
    } // Actually draws the grid (for real)

  }, {
    key: "grid",
    value: function grid() {
      this.ctx.strokeStyle = this.$p.colors.grid;
      this.ctx.beginPath();
      var ymax = this.layout.height;

      var _iterator2 = grid_createForOfIteratorHelper(this.layout.xs),
          _step2;

      try {
        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
          var _step2$value = _slicedToArray(_step2.value, 2),
              x = _step2$value[0],
              p = _step2$value[1];

          this.ctx.moveTo(x - 0.5, 0);
          this.ctx.lineTo(x - 0.5, ymax);
        }
      } catch (err) {
        _iterator2.e(err);
      } finally {
        _iterator2.f();
      }

      var _iterator3 = grid_createForOfIteratorHelper(this.layout.ys),
          _step3;

      try {
        for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {
          var _step3$value = _slicedToArray(_step3.value, 2),
              y = _step3$value[0],
              y$ = _step3$value[1];

          this.ctx.moveTo(0, y - 0.5);
          this.ctx.lineTo(this.layout.width, y - 0.5);
        }
      } catch (err) {
        _iterator3.e(err);
      } finally {
        _iterator3.f();
      }

      this.ctx.stroke();
      if (this.$p.grid_id) this.upper_border();
    }
  }, {
    key: "upper_border",
    value: function upper_border() {
      this.ctx.strokeStyle = this.$p.colors.scale;
      this.ctx.beginPath();
      this.ctx.moveTo(0, 0.5);
      this.ctx.lineTo(this.layout.width, 0.5);
      this.ctx.stroke();
    }
  }, {
    key: "mousezoom",
    value: function mousezoom(delta, event) {
      // TODO: for mobile
      if (this.wmode !== 'pass') {
        if (this.wmode === 'click' && !this.$p.meta.activated) {
          return;
        }

        event.originalEvent.preventDefault();
        event.preventDefault();
      }

      event.deltaX = event.deltaX || utils.get_deltaX(event);
      event.deltaY = event.deltaY || utils.get_deltaY(event);

      if (Math.abs(event.deltaX) > 0) {
        this.trackpad = true;

        if (Math.abs(event.deltaX) >= Math.abs(event.deltaY)) {
          delta *= 0.1;
        }

        this.trackpad_scroll(event);
      }

      if (this.trackpad) delta *= 0.032;
      delta = utils.smart_wheel(delta); // TODO: mouse zooming is a little jerky,
      // needs to follow f(mouse_wheel_speed) and
      // if speed is low, scroll shoud be slower

      if (delta < 0 && this.data.length <= this.MIN_ZOOM) return;
      if (delta > 0 && this.data.length > this.MAX_ZOOM) return;
      var k = this.interval / 1000;
      var diff = delta * k * this.data.length;
      var tl = this.comp.config.ZOOM_MODE === 'tl';

      if (event.originalEvent.ctrlKey || tl) {
        var offset = event.originalEvent.offsetX;
        var diff1 = offset / (this.canvas.width - 1) * diff;
        var diff2 = diff - diff1;
        this.range[0] -= diff1;
        this.range[1] += diff2;
      } else {
        this.range[0] -= diff;
      }

      if (tl) {
        var _offset = event.originalEvent.offsetY;

        var _diff = _offset / (this.canvas.height - 1) * 2;

        var _diff2 = 2 - _diff;

        var z = diff / (this.range[1] - this.range[0]); //rezoom_range(z, diff_x, diff_y)

        this.comp.$emit('rezoom-range', {
          grid_id: this.id,
          z: z,
          diff1: _diff,
          diff2: _diff2
        });
      }

      this.change_range();
    }
  }, {
    key: "mousedrag",
    value: function mousedrag(x, y) {
      var dt = this.drug.t * (this.drug.x - x) / this.layout.width;
      var d$ = this.layout.$_hi - this.layout.$_lo;
      d$ *= (this.drug.y - y) / this.layout.height;
      var offset = this.drug.o + d$;
      var ls = this.layout.grid.logScale;

      if (ls && this.drug.y_r) {
        var dy = this.drug.y - y;
        var range = this.drug.y_r.slice();
        range[0] = math.exp((0 - this.drug.B + dy) / this.layout.A);
        range[1] = math.exp((this.layout.height - this.drug.B + dy) / this.layout.A);
      }

      if (this.drug.y_r && this.$p.y_transform && !this.$p.y_transform.auto) {
        this.comp.$emit('sidebar-transform', {
          grid_id: this.id,
          range: ls ? range || this.drug.y_r : [this.drug.y_r[0] - offset, this.drug.y_r[1] - offset]
        });
      }

      this.range[0] = this.drug.r[0] + dt;
      this.range[1] = this.drug.r[1] + dt;
      this.change_range();
    }
  }, {
    key: "pinchzoom",
    value: function pinchzoom(scale) {
      if (scale > 1 && this.data.length <= this.MIN_ZOOM) return;
      if (scale < 1 && this.data.length > this.MAX_ZOOM) return;
      var t = this.pinch.t;
      var nt = t * 1 / scale;
      this.range[0] = this.pinch.r[0] - (nt - t) * 0.5;
      this.range[1] = this.pinch.r[1] + (nt - t) * 0.5;
      this.change_range();
    }
  }, {
    key: "trackpad_scroll",
    value: function trackpad_scroll(event) {
      var dt = this.range[1] - this.range[0];
      this.range[0] += event.deltaX * dt * 0.011;
      this.range[1] += event.deltaX * dt * 0.011;
      this.change_range();
    }
  }, {
    key: "change_range",
    value: function change_range() {
      // TODO: better way to limit the view. Problem:
      // when you are at the dead end of the data,
      // and keep scrolling,
      // the chart continues to scale down a little.
      // Solution: I don't know yet
      if (!this.range.length || this.data.length < 2) return;
      var l = this.data.length - 1;
      var data = this.data;
      var range = this.range;
      range[0] = utils.clamp(range[0], -Infinity, data[l][0] - this.interval * 5.5);
      range[1] = utils.clamp(range[1], data[0][0] + this.interval * 5.5, Infinity); // TODO: IMPORTANT scrolling is jerky The Problem caused
      // by the long round trip of 'range-changed' event.
      // First it propagates up to update layout in Chart.vue,
      // then it moves back as watch() update. It takes 1-5 ms.
      // And because the delay is different each time we see
      // the lag. No smooth movement and it's annoying.
      // Solution: we could try to calc the layout immediatly
      // somewhere here. Still will hurt the sidebar & bottombar

      this.comp.$emit('range-changed', range);
    } // Propagate mouse event to overlays

  }, {
    key: "propagate",
    value: function propagate(name, event) {
      var _iterator4 = grid_createForOfIteratorHelper(this.overlays),
          _step4;

      try {
        for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {
          var layer = _step4.value;

          if (layer.renderer[name]) {
            layer.renderer[name](event);
          }

          var mouse = layer.renderer.mouse;
          var keys = layer.renderer.keys;

          if (mouse.listeners) {
            mouse.emit(name, event);
          }

          if (keys && keys.listeners) {
            keys.emit(name, event);
          }
        }
      } catch (err) {
        _iterator4.e(err);
      } finally {
        _iterator4.f();
      }
    }
  }, {
    key: "destroy",
    value: function destroy() {
      var rm = removeEventListener;
      rm("gesturestart", this.gesturestart);
      rm("gesturechange", this.gesturechange);
      rm("gestureend", this.gestureend);
      if (this.mc) this.mc.destroy();
      if (this.hm) this.hm.unwheel();
    }
  }]);

  return Grid;
}();


;// CONCATENATED MODULE: ./src/mixins/canvas.js
// Interactive canvas-based component
// Should implement: mousemove, mouseout, mouseup, mousedown, click

/* harmony default export */ const canvas = ({
  methods: {
    setup: function setup() {
      var _this = this;

      var id = "".concat(this.$props.tv_id, "-").concat(this._id, "-canvas");
      var canvas = document.getElementById(id);
      var dpr = window.devicePixelRatio || 1;
      canvas.style.width = "".concat(this._attrs.width, "px");
      canvas.style.height = "".concat(this._attrs.height, "px");
      if (dpr < 1) dpr = 1; // Realy ? That's it? Issue #63

      this.$nextTick(function () {
        var rect = canvas.getBoundingClientRect();
        canvas.width = rect.width * dpr;
        canvas.height = rect.height * dpr;
        var ctx = canvas.getContext('2d', {// TODO: test the boost:
          //alpha: false,
          //desynchronized: true,
          //preserveDrawingBuffer: false
        });
        ctx.scale(dpr, dpr);

        _this.redraw(); // Fallback fix for Brave browser
        // https://github.com/brave/brave-browser/issues/1738


        if (!ctx.measureTextOrg) {
          ctx.measureTextOrg = ctx.measureText;
        }

        ctx.measureText = function (text) {
          return utils.measureText(ctx, text, _this.$props.tv_id);
        };
      });
    },
    create_canvas: function create_canvas(h, id, props) {
      var _this2 = this;

      this._id = id;
      this._attrs = props.attrs;
      return h('div', {
        "class": "trading-vue-".concat(id),
        style: {
          left: props.position.x + 'px',
          top: props.position.y + 'px',
          position: 'absolute'
        }
      }, [h('canvas', {
        on: {
          mousemove: function mousemove(e) {
            return _this2.renderer.mousemove(e);
          },
          mouseout: function mouseout(e) {
            return _this2.renderer.mouseout(e);
          },
          mouseup: function mouseup(e) {
            return _this2.renderer.mouseup(e);
          },
          mousedown: function mousedown(e) {
            return _this2.renderer.mousedown(e);
          }
        },
        attrs: Object.assign({
          id: "".concat(this.$props.tv_id, "-").concat(id, "-canvas")
        }, props.attrs),
        ref: 'canvas',
        style: props.style
      })].concat(props.hs || []));
    },
    redraw: function redraw() {
      if (!this.renderer) return;
      this.renderer.update();
    }
  },
  watch: {
    width: function width(val) {
      this._attrs.width = val;
      this.setup();
    },
    height: function height(val) {
      this._attrs.height = val;
      this.setup();
    }
  }
});
;// CONCATENATED MODULE: ./src/mixins/uxlist.js
// Manager for Inteerface objects
/* harmony default export */ const uxlist = ({
  methods: {
    on_ux_event: function on_ux_event(d, target) {
      if (d.event === 'new-interface') {
        if (d.args[0].target === target) {
          d.args[0].vars = d.args[0].vars || {};
          d.args[0].grid_id = d.args[1];
          d.args[0].overlay_id = d.args[2];
          this.uxs.push(d.args[0]); // this.rerender++
        }
      } else if (d.event === 'close-interface') {
        this.uxs = this.uxs.filter(function (x) {
          return x.uuid !== d.args[0];
        });
      } else if (d.event === 'modify-interface') {
        var ux = this.uxs.filter(function (x) {
          return x.uuid === d.args[0];
        });

        if (ux.length) {
          this.modify(ux[0], d.args[1]);
        }
      } else if (d.event === 'hide-interface') {
        var _ux = this.uxs.filter(function (x) {
          return x.uuid === d.args[0];
        });

        if (_ux.length) {
          _ux[0].hidden = true;
          this.modify(_ux[0], {
            hidden: true
          });
        }
      } else if (d.event === 'show-interface') {
        var _ux2 = this.uxs.filter(function (x) {
          return x.uuid === d.args[0];
        });

        if (_ux2.length) {
          this.modify(_ux2[0], {
            hidden: false
          });
        }
      } else {
        return d;
      }
    },
    modify: function modify(ux, obj) {
      if (obj === void 0) {
        obj = {};
      }

      for (var k in obj) {
        if (k in ux) {
          this.$set(ux, k, obj[k]);
        }
      }
    },
    // Remove all UXs for a given overlay id
    remove_all_ux: function remove_all_ux(id) {
      this.uxs = this.uxs.filter(function (x) {
        return x.overlay.id !== id;
      });
    }
  },
  data: function data() {
    return {
      uxs: []
    };
  }
});
;// CONCATENATED MODULE: ./src/components/js/crosshair.js



var Crosshair = /*#__PURE__*/function () {
  function Crosshair(comp) {
    classCallCheck_classCallCheck(this, Crosshair);

    this.comp = comp;
    this.$p = comp.$props;
    this.data = this.$p.sub;
    this._visible = false;
    this.locked = false;
    this.layout = this.$p.layout;
  }

  createClass_createClass(Crosshair, [{
    key: "draw",
    value: function draw(ctx) {
      // Update reference to the grid
      this.layout = this.$p.layout;
      var cursor = this.comp.$props.cursor;
      if (!this.visible && cursor.mode === 'explore') return;
      this.x = this.$p.cursor.x;
      this.y = this.$p.cursor.y;
      ctx.save();
      ctx.strokeStyle = this.$p.colors.cross;
      ctx.beginPath();
      ctx.setLineDash([5]); // H

      if (this.$p.cursor.grid_id === this.layout.id) {
        ctx.moveTo(0, this.y);
        ctx.lineTo(this.layout.width - 0.5, this.y);
      } // V


      ctx.moveTo(this.x, 0);
      ctx.lineTo(this.x, this.layout.height);
      ctx.stroke();
      ctx.restore();
    }
  }, {
    key: "hide",
    value: function hide() {
      this.visible = false;
      this.x = undefined;
      this.y = undefined;
    }
  }, {
    key: "visible",
    get: function get() {
      return this._visible;
    },
    set: function set(val) {
      this._visible = val;
    }
  }]);

  return Crosshair;
}();


;// CONCATENATED MODULE: ./node_modules/babel-loader/lib/index.js!./node_modules/vue-loader/lib/index.js??vue-loader-options!./src/components/Crosshair.vue?vue&type=script&lang=js&


/* harmony default export */ const Crosshairvue_type_script_lang_js_ = ({
  name: 'Crosshair',
  props: ['cursor', 'colors', 'layout', 'sub'],
  methods: {
    create: function create() {
      this.ch = new Crosshair(this); // New grid overlay-renderer descriptor.
      // Should implement draw() (see Spline.vue)

      this.$emit('new-grid-layer', {
        name: 'crosshair',
        renderer: this.ch
      });
    }
  },
  watch: {
    cursor: {
      handler: function handler() {
        if (!this.ch) this.create(); // Explore = default mode on mobile

        var cursor = this.$props.cursor;
        var explore = cursor.mode === 'explore';

        if (!cursor.x || !cursor.y) {
          this.ch.hide();
          this.$emit('redraw-grid');
          return;
        }

        this.ch.visible = !explore;
      },
      deep: true
    }
  },
  render: function render(h) {
    return h();
  }
});
;// CONCATENATED MODULE: ./src/components/Crosshair.vue?vue&type=script&lang=js&
 /* harmony default export */ const components_Crosshairvue_type_script_lang_js_ = (Crosshairvue_type_script_lang_js_); 
;// CONCATENATED MODULE: ./node_modules/vue-loader/lib/runtime/componentNormalizer.js
/* globals __VUE_SSR_CONTEXT__ */

// IMPORTANT: Do NOT use ES2015 features in this file (except for modules).
// This module is a runtime utility for cleaner component module output and will
// be included in the final webpack user bundle.

function normalizeComponent (
  scriptExports,
  render,
  staticRenderFns,
  functionalTemplate,
  injectStyles,
  scopeId,
  moduleIdentifier, /* server only */
  shadowMode /* vue-cli only */
) {
  // Vue.extend constructor export interop
  var options = typeof scriptExports === 'function'
    ? scriptExports.options
    : scriptExports

  // render functions
  if (render) {
    options.render = render
    options.staticRenderFns = staticRenderFns
    options._compiled = true
  }

  // functional template
  if (functionalTemplate) {
    options.functional = true
  }

  // scopedId
  if (scopeId) {
    options._scopeId = 'data-v-' + scopeId
  }

  var hook
  if (moduleIdentifier) { // server build
    hook = function (context) {
      // 2.3 injection
      context =
        context || // cached call
        (this.$vnode && this.$vnode.ssrContext) || // stateful
        (this.parent && this.parent.$vnode && this.parent.$vnode.ssrContext) // functional
      // 2.2 with runInNewContext: true
      if (!context && typeof __VUE_SSR_CONTEXT__ !== 'undefined') {
        context = __VUE_SSR_CONTEXT__
      }
      // inject component styles
      if (injectStyles) {
        injectStyles.call(this, context)
      }
      // register component module identifier for async chunk inferrence
      if (context && context._registeredComponents) {
        context._registeredComponents.add(moduleIdentifier)
      }
    }
    // used by ssr in case component is cached and beforeCreate
    // never gets called
    options._ssrRegister = hook
  } else if (injectStyles) {
    hook = shadowMode
      ? function () {
        injectStyles.call(
          this,
          (options.functional ? this.parent : this).$root.$options.shadowRoot
        )
      }
      : injectStyles
  }

  if (hook) {
    if (options.functional) {
      // for template-only hot-reload because in that case the render fn doesn't
      // go through the normalizer
      options._injectStyles = hook
      // register for functional component in vue file
      var originalRender = options.render
      options.render = function renderWithStyleInjection (h, context) {
        hook.call(context)
        return originalRender(h, context)
      }
    } else {
      // inject component registration as beforeCreate hook
      var existing = options.beforeCreate
      options.beforeCreate = existing
        ? [].concat(existing, hook)
        : [hook]
    }
  }

  return {
    exports: scriptExports,
    options: options
  }
}

;// CONCATENATED MODULE: ./src/components/Crosshair.vue
var Crosshair_render, Crosshair_staticRenderFns
;



/* normalize component */
;
var component = normalizeComponent(
  components_Crosshairvue_type_script_lang_js_,
  Crosshair_render,
  Crosshair_staticRenderFns,
  false,
  null,
  null,
  null
  
)

/* hot reload */
if (false) { var api; }
component.options.__file = "src/components/Crosshair.vue"
/* harmony default export */ const components_Crosshair = (component.exports);
;// CONCATENATED MODULE: ./node_modules/babel-loader/lib/index.js!./node_modules/vue-loader/lib/index.js??vue-loader-options!./src/components/KeyboardListener.vue?vue&type=script&lang=js&
//
//
//
//
/* harmony default export */ const KeyboardListenervue_type_script_lang_js_ = ({
  name: 'KeyboardListener',
  render: function render(h) {
    return h();
  },
  created: function created() {
    this.$emit('register-kb-listener', {
      id: this._uid,
      keydown: this.keydown,
      keyup: this.keyup,
      keypress: this.keypress
    });
  },
  beforeDestroy: function beforeDestroy() {
    this.$emit('remove-kb-listener', {
      id: this._uid
    });
  },
  methods: {
    keydown: function keydown(event) {
      this.$emit('keydown', event);
    },
    keyup: function keyup(event) {
      this.$emit('keyup', event);
    },
    keypress: function keypress(event) {
      this.$emit('keypress', event);
    }
  }
});
;// CONCATENATED MODULE: ./src/components/KeyboardListener.vue?vue&type=script&lang=js&
 /* harmony default export */ const components_KeyboardListenervue_type_script_lang_js_ = (KeyboardListenervue_type_script_lang_js_); 
;// CONCATENATED MODULE: ./src/components/KeyboardListener.vue
var KeyboardListener_render, KeyboardListener_staticRenderFns
;



/* normalize component */
;
var KeyboardListener_component = normalizeComponent(
  components_KeyboardListenervue_type_script_lang_js_,
  KeyboardListener_render,
  KeyboardListener_staticRenderFns,
  false,
  null,
  null,
  null
  
)

/* hot reload */
if (false) { var KeyboardListener_api; }
KeyboardListener_component.options.__file = "src/components/KeyboardListener.vue"
/* harmony default export */ const KeyboardListener = (KeyboardListener_component.exports);
;// CONCATENATED MODULE: ./node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!./node_modules/vue-loader/lib/index.js??vue-loader-options!./src/components/UxLayer.vue?vue&type=template&id=390ccf6e&
var UxLayervue_type_template_id_390ccf6e_render = function() {
  var _vm = this
  var _h = _vm.$createElement
  var _c = _vm._self._c || _h
  return _c(
    "span",
    { class: "trading-vue-grid-ux-" + _vm.id, style: _vm.style },
    _vm._l(_vm.uxs, function(ux) {
      return _c("ux-wrapper", {
        key: ux.uuid,
        attrs: {
          ux: ux,
          updater: _vm.updater,
          colors: _vm.colors,
          config: _vm.config
        },
        on: { "custom-event": _vm.on_custom_event }
      })
    }),
    1
  )
}
var UxLayervue_type_template_id_390ccf6e_staticRenderFns = []
UxLayervue_type_template_id_390ccf6e_render._withStripped = true


;// CONCATENATED MODULE: ./src/components/UxLayer.vue?vue&type=template&id=390ccf6e&

;// CONCATENATED MODULE: ./node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!./node_modules/vue-loader/lib/index.js??vue-loader-options!./src/components/UxWrapper.vue?vue&type=template&id=4bc32070&
var UxWrappervue_type_template_id_4bc32070_render = function() {
  var _vm = this
  var _h = _vm.$createElement
  var _c = _vm._self._c || _h
  return _vm.visible
    ? _c(
        "div",
        {
          staticClass: "trading-vue-ux-wrapper",
          style: _vm.style,
          attrs: { id: "tvjs-ux-wrapper-" + _vm.ux.uuid }
        },
        [
          _c(_vm.ux.component, {
            tag: "component",
            attrs: {
              ux: _vm.ux,
              updater: _vm.updater,
              wrapper: _vm.wrapper,
              colors: _vm.colors
            },
            on: { "custom-event": _vm.on_custom_event }
          }),
          _vm._v(" "),
          _vm.ux.show_pin
            ? _c("div", {
                staticClass: "tvjs-ux-wrapper-pin",
                style: _vm.pin_style
              })
            : _vm._e(),
          _vm._v(" "),
          _vm.ux.win_header !== false
            ? _c("div", { staticClass: "tvjs-ux-wrapper-head" }, [
                _c(
                  "div",
                  {
                    staticClass: "tvjs-ux-wrapper-close",
                    style: _vm.btn_style,
                    on: { click: _vm.close }
                  },
                  [_vm._v("")]
                )
              ])
            : _vm._e()
        ],
        1
      )
    : _vm._e()
}
var UxWrappervue_type_template_id_4bc32070_staticRenderFns = []
UxWrappervue_type_template_id_4bc32070_render._withStripped = true


;// CONCATENATED MODULE: ./src/components/UxWrapper.vue?vue&type=template&id=4bc32070&

;// CONCATENATED MODULE: ./node_modules/babel-loader/lib/index.js!./node_modules/vue-loader/lib/index.js??vue-loader-options!./src/components/UxWrapper.vue?vue&type=script&lang=js&
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//

/* harmony default export */ const UxWrappervue_type_script_lang_js_ = ({
  name: 'UxWrapper',
  props: ['ux', 'updater', 'colors', 'config'],
  mounted: function mounted() {
    this.self = document.getElementById(this.uuid);
    this.w = this.self.offsetWidth; // TODO: => width: "content"

    this.h = this.self.offsetHeight; // TODO: => height: "content"

    this.update_position();
  },
  created: function created() {
    this.mouse.on('mousemove', this.mousemove);
    this.mouse.on('mouseout', this.mouseout);
  },
  beforeDestroy: function beforeDestroy() {
    this.mouse.off('mousemove', this.mousemove);
    this.mouse.off('mouseout', this.mouseout);
  },
  methods: {
    update_position: function update_position() {
      if (this.uxr.hidden) return;
      var lw = this.layout.width;
      var lh = this.layout.height;
      var pin = this.uxr.pin;

      switch (pin[0]) {
        case 'cursor':
          var x = this.uxr.overlay.cursor.x;
          break;

        case 'mouse':
          x = this.mouse.x;
          break;

        default:
          if (typeof pin[0] === 'string') {
            x = this.parse_coord(pin[0], lw);
          } else {
            x = this.layout.t2screen(pin[0]);
          }

      }

      switch (pin[1]) {
        case 'cursor':
          var y = this.uxr.overlay.cursor.y;
          break;

        case 'mouse':
          y = this.mouse.y;
          break;

        default:
          if (typeof pin[1] === 'string') {
            y = this.parse_coord(pin[1], lh);
          } else {
            y = this.layout.$2screen(pin[1]);
          }

      }

      this.x = x + this.ox;
      this.y = y + this.oy;
    },
    parse_coord: function parse_coord(str, scale) {
      str = str.trim();
      if (str === '0' || str === '') return 0;
      var plus = str.split('+');

      if (plus.length === 2) {
        return this.parse_coord(plus[0], scale) + this.parse_coord(plus[1], scale);
      }

      var minus = str.split('-');

      if (minus.length === 2) {
        return this.parse_coord(minus[0], scale) - this.parse_coord(minus[1], scale);
      }

      var per = str.split('%');

      if (per.length === 2) {
        return scale * parseInt(per[0]) / 100;
      }

      var px = str.split('px');

      if (px.length === 2) {
        return parseInt(px[0]);
      }

      return undefined;
    },
    mousemove: function mousemove() {
      this.update_position();
      this.visible = true;
    },
    mouseout: function mouseout() {
      if (this.uxr.pin.includes('cursor') || this.uxr.pin.includes('mouse')) this.visible = false;
    },
    on_custom_event: function on_custom_event(event) {
      this.$emit('custom-event', event);

      if (event.event === 'modify-interface') {
        if (this.self) {
          this.w = this.self.offsetWidth;
          this.h = this.self.offsetHeight;
        }

        this.update_position();
      }
    },
    close: function close() {
      this.$emit('custom-event', {
        event: 'close-interface',
        args: [this.$props.ux.uuid]
      });
    }
  },
  computed: {
    uxr: function uxr() {
      return this.$props.ux; // just a ref
    },
    layout: function layout() {
      return this.$props.ux.overlay.layout;
    },
    settings: function settings() {
      return this.$props.ux.overlay.settings;
    },
    uuid: function uuid() {
      return "tvjs-ux-wrapper-".concat(this.uxr.uuid);
    },
    mouse: function mouse() {
      return this.uxr.overlay.mouse;
    },
    style: function style() {
      var st = {
        'display': this.uxr.hidden ? 'none' : undefined,
        'left': "".concat(this.x, "px"),
        'top': "".concat(this.y, "px"),
        'pointer-events': this.uxr.pointer_events || 'all',
        'z-index': this.z_index
      };
      if (this.uxr.win_styling !== false) st = Object.assign(st, {
        'border': "1px solid ".concat(this.$props.colors.grid),
        'border-radius': '3px',
        'background': "".concat(this.background)
      });
      return st;
    },
    pin_style: function pin_style() {
      return {
        'left': "".concat(-this.ox, "px"),
        'top': "".concat(-this.oy, "px"),
        'background-color': this.uxr.pin_color
      };
    },
    btn_style: function btn_style() {
      return {
        'background': "".concat(this.inactive_btn_color),
        'color': "".concat(this.inactive_btn_color)
      };
    },
    pin_pos: function pin_pos() {
      return this.uxr.pin_position ? this.uxr.pin_position.split(',') : ['0', '0'];
    },
    // Offset x
    ox: function ox() {
      if (this.pin_pos.length !== 2) return undefined;
      var x = this.parse_coord(this.pin_pos[0], this.w);
      return -x;
    },
    // Offset y
    oy: function oy() {
      if (this.pin_pos.length !== 2) return undefined;
      var y = this.parse_coord(this.pin_pos[1], this.h);
      return -y;
    },
    z_index: function z_index() {
      var base_index = this.settings['z-index'] || this.settings['zIndex'] || 0;
      var ux_index = this.uxr['z_index'] || 0;
      return base_index + ux_index;
    },
    background: function background() {
      var c = this.uxr.background || this.$props.colors.back;
      return utils.apply_opacity(c, this.uxr.background_opacity || this.$props.config.UX_OPACITY);
    },
    inactive_btn_color: function inactive_btn_color() {
      return this.uxr.inactive_btn_color || this.$props.colors.grid;
    },
    wrapper: function wrapper() {
      return {
        x: this.x,
        y: this.y,
        pin_x: this.x - this.ox,
        pin_y: this.y - this.oy
      };
    }
  },
  watch: {
    updater: function updater() {
      this.update_position();
    }
  },
  data: function data() {
    return {
      x: 0,
      y: 0,
      w: 0,
      h: 0,
      visible: true
    };
  }
});
;// CONCATENATED MODULE: ./src/components/UxWrapper.vue?vue&type=script&lang=js&
 /* harmony default export */ const components_UxWrappervue_type_script_lang_js_ = (UxWrappervue_type_script_lang_js_); 
// EXTERNAL MODULE: ./node_modules/vue-style-loader/index.js!./node_modules/css-loader/dist/cjs.js!./node_modules/vue-loader/lib/loaders/stylePostLoader.js!./node_modules/vue-loader/lib/index.js??vue-loader-options!./src/components/UxWrapper.vue?vue&type=style&index=0&lang=css&
var UxWrappervue_type_style_index_0_lang_css_ = __nested_webpack_require_9759__(565);
;// CONCATENATED MODULE: ./src/components/UxWrapper.vue?vue&type=style&index=0&lang=css&

;// CONCATENATED MODULE: ./src/components/UxWrapper.vue



;


/* normalize component */

var UxWrapper_component = normalizeComponent(
  components_UxWrappervue_type_script_lang_js_,
  UxWrappervue_type_template_id_4bc32070_render,
  UxWrappervue_type_template_id_4bc32070_staticRenderFns,
  false,
  null,
  null,
  null
  
)

/* hot reload */
if (false) { var UxWrapper_api; }
UxWrapper_component.options.__file = "src/components/UxWrapper.vue"
/* harmony default export */ const UxWrapper = (UxWrapper_component.exports);
;// CONCATENATED MODULE: ./node_modules/babel-loader/lib/index.js!./node_modules/vue-loader/lib/index.js??vue-loader-options!./src/components/UxLayer.vue?vue&type=script&lang=js&
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//

/* harmony default export */ const UxLayervue_type_script_lang_js_ = ({
  name: 'UxLayer',
  props: ['tv_id', 'id', 'uxs', 'updater', 'colors', 'config'],
  components: {
    UxWrapper: UxWrapper
  },
  created: function created() {},
  mounted: function mounted() {},
  beforeDestroy: function beforeDestroy() {},
  methods: {
    on_custom_event: function on_custom_event(event) {
      this.$emit('custom-event', event);
    }
  },
  computed: {
    style: function style() {
      return {
        'top': this.$props.id !== 0 ? '1px' : 0,
        'left': 0,
        'width': '100%',
        'height': 'calc(100% - 2px)',
        'position': 'absolute',
        'z-index': '1',
        'pointer-events': 'none',
        'overflow': 'hidden'
      };
    }
  }
});
;// CONCATENATED MODULE: ./src/components/UxLayer.vue?vue&type=script&lang=js&
 /* harmony default export */ const components_UxLayervue_type_script_lang_js_ = (UxLayervue_type_script_lang_js_); 
;// CONCATENATED MODULE: ./src/components/UxLayer.vue





/* normalize component */
;
var UxLayer_component = normalizeComponent(
  components_UxLayervue_type_script_lang_js_,
  UxLayervue_type_template_id_390ccf6e_render,
  UxLayervue_type_template_id_390ccf6e_staticRenderFns,
  false,
  null,
  null,
  null
  
)

/* hot reload */
if (false) { var UxLayer_api; }
UxLayer_component.options.__file = "src/components/UxLayer.vue"
/* harmony default export */ const UxLayer = (UxLayer_component.exports);
;// CONCATENATED MODULE: ./src/stuff/mouse.js



function mouse_createForOfIteratorHelper(o, allowArrayLike) { var it; if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (it = mouse_unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = o[Symbol.iterator](); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it["return"] != null) it["return"](); } finally { if (didErr) throw err; } } }; }

function mouse_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return mouse_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return mouse_arrayLikeToArray(o, minLen); }

function mouse_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

// Mouse event handler for overlay
var Mouse = /*#__PURE__*/function () {
  function Mouse(comp) {
    classCallCheck_classCallCheck(this, Mouse);

    this.comp = comp;
    this.map = {};
    this.listeners = 0;
    this.pressed = false;
    this.x = comp.$props.cursor.x;
    this.y = comp.$props.cursor.y;
    this.t = comp.$props.cursor.t;
    this.y$ = comp.$props.cursor.y$;
  } // You can choose where to place the handler
  // (beginning or end of the queue)


  createClass_createClass(Mouse, [{
    key: "on",
    value: function on(name, handler, dir) {
      if (dir === void 0) {
        dir = "unshift";
      }

      if (!handler) return;
      this.map[name] = this.map[name] || [];
      this.map[name][dir](handler);
      this.listeners++;
    }
  }, {
    key: "off",
    value: function off(name, handler) {
      if (!this.map[name]) return;
      var i = this.map[name].indexOf(handler);
      if (i < 0) return;
      this.map[name].splice(i, 1);
      this.listeners--;
    } // Called by grid.js

  }, {
    key: "emit",
    value: function emit(name, event) {
      var l = this.comp.layout;

      if (name in this.map) {
        var _iterator = mouse_createForOfIteratorHelper(this.map[name]),
            _step;

        try {
          for (_iterator.s(); !(_step = _iterator.n()).done;) {
            var f = _step.value;
            f(event);
          }
        } catch (err) {
          _iterator.e(err);
        } finally {
          _iterator.f();
        }
      }

      if (name === 'mousemove') {
        this.x = event.layerX;
        this.y = event.layerY;
        this.t = l.screen2t(this.x);
        this.y$ = l.screen2$(this.y);
      }

      if (name === 'mousedown') {
        this.pressed = true;
      }

      if (name === 'mouseup') {
        this.pressed = false;
      }
    }
  }]);

  return Mouse;
}();


;// CONCATENATED MODULE: ./src/mixins/overlay.js
// Usuful stuff for creating overlays. Include as mixin

/* harmony default export */ const overlay = ({
  props: ['id', 'num', 'interval', 'cursor', 'colors', 'layout', 'sub', 'data', 'settings', 'grid_id', 'font', 'config', 'meta', 'tf', 'i0', 'last'],
  mounted: function mounted() {
    // TODO(1): when hot reloading, dynamicaly changed mixins
    // dissapear (cuz it's a hack), the only way for now
    // is to reload the browser
    if (!this.draw) {
      this.draw = function (ctx) {
        var text = 'EARLY ADOPTER BUG: reload the browser & enjoy';
        console.warn(text);
      };
    } // Main chart?


    var main = this.$props.sub === this.$props.data;
    this.meta_info(); // TODO(1): quick fix for vue2, in vue3 we use 3rd party emit

    try {
      new Function('return ' + this.$emit)();
      this._$emit = this.$emit;
      this.$emit = this.custom_event;
    } catch (e) {
      return;
    }

    this._$emit('new-grid-layer', {
      name: this.$options.name,
      id: this.$props.id,
      renderer: this,
      display: 'display' in this.$props.settings ? this.$props.settings['display'] : true,
      z: this.$props.settings['z-index'] || this.$props.settings['zIndex'] || (main ? 0 : -1)
    }); // Overlay meta-props (adjusting behaviour)


    this._$emit('layer-meta-props', {
      grid_id: this.$props.grid_id,
      layer_id: this.$props.id,
      legend: this.legend,
      data_colors: this.data_colors,
      y_range: this.y_range
    });

    this.exec_script();
    this.mouse = new Mouse(this);
    if (this.init_tool) this.init_tool();
    if (this.init) this.init();
  },
  beforeDestroy: function beforeDestroy() {
    if (this.destroy) this.destroy();

    this._$emit('delete-grid-layer', this.$props.id);
  },
  methods: {
    use_for: function use_for() {
      /* override it (mandatory) */
      console.warn('use_for() should be implemented');
      console.warn("Format: use_for() {\n                  return ['type1', 'type2', ...]\n            }");
    },
    meta_info: function meta_info() {
      /* override it (optional) */
      var id = this.$props.id;
      console.warn("".concat(id, " meta_info() is req. for publishing"));
      console.warn("Format: meta_info() {\n                author: 'Satoshi Smith',\n                version: '1.0.0',\n                contact (opt) '<email>'\n                github: (opt) '<GitHub Page>',\n            }");
    },
    custom_event: function custom_event(event) {
      if (event.split(':')[0] === 'hook') return;

      for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
        args[_key - 1] = arguments[_key];
      }

      if (event === 'change-settings' || event === 'object-selected' || event === 'new-shader' || event === 'new-interface' || event === 'remove-tool') {
        args.push(this.grid_id, this.id);

        if (this.$props.settings.$uuid) {
          args.push(this.$props.settings.$uuid);
        }
      }

      if (event === 'new-interface') {
        args[0].overlay = this;
        args[0].uuid = this.last_ux_id = "".concat(this.grid_id, "-").concat(this.id, "-").concat(this.uxs_count++);
      } // TODO: add a namespace to the event name
      // TODO(2): this prevents call overflow, but
      // the root of evil is in (1)


      if (event === 'custom-event') return;

      this._$emit('custom-event', {
        event: event,
        args: args
      });
    },
    // TODO: the event is not firing when the same
    // overlay type is added to the offchart[]
    exec_script: function exec_script() {
      if (this.calc) this.$emit('exec-script', {
        grid_id: this.$props.grid_id,
        layer_id: this.$props.id,
        src: this.calc(),
        use_for: this.use_for()
      });
    }
  },
  watch: {
    settings: {
      handler: function handler(n, p) {
        if (this.watch_uuid) this.watch_uuid(n, p);

        this._$emit('show-grid-layer', {
          id: this.$props.id,
          display: 'display' in this.$props.settings ? this.$props.settings['display'] : true
        });
      },
      deep: true
    }
  },
  data: function data() {
    return {
      uxs_count: 0,
      last_ux_id: null
    };
  },
  render: function render(h) {
    return h();
  }
});
;// CONCATENATED MODULE: ./node_modules/babel-loader/lib/index.js!./node_modules/vue-loader/lib/index.js??vue-loader-options!./src/components/overlays/Spline.vue?vue&type=script&lang=js&
// Spline renderer. (SMAs, EMAs, TEMAs...
// you know what I mean)
// TODO: make a real spline, not a bunch of lines...
// Adds all necessary stuff for you.

/* harmony default export */ const Splinevue_type_script_lang_js_ = ({
  name: 'Spline',
  mixins: [overlay],
  methods: {
    meta_info: function meta_info() {
      return {
        author: 'C451',
        version: '1.1.2'
      };
    },
    // Here goes your code. You are provided with:
    // { All stuff is reactive }
    // $props.layout -> positions of all chart elements +
    //  some helper functions (see layout_fn.js)
    // $props.interval -> candlestick time interval
    // $props.sub -> current subset of candlestick data
    // $props.data -> your indicator's data subset.
    //  Comes "as is", should have the following format:
    //  [[<timestamp>, ... ], ... ]
    // $props.colors -> colors (see TradingVue.vue)
    // $props.cursor -> current position of crosshair
    // $props.settings -> indicator's custom settings
    //  E.g. colors, line thickness, etc. You define it.
    // $props.num -> indicator's layer number (of All
    // layers in the current grid)
    // $props.id -> indicator's id (e.g. EMA_0)
    // ~
    // Finally, let's make the canvas dirty!
    draw: function draw(ctx) {
      ctx.lineWidth = this.line_width;
      ctx.strokeStyle = this.color;
      ctx.beginPath();
      var layout = this.$props.layout;
      var i = this.data_index;
      var data = this.$props.data;

      if (!this.skip_nan) {
        for (var k = 0, n = data.length; k < n; k++) {
          var p = data[k];
          var x = layout.t2screen(p[0]);
          var y = layout.$2screen(p[i]);
          ctx.lineTo(x, y);
        }
      } else {
        var skip = false;

        for (var k = 0, n = data.length; k < n; k++) {
          var _p = data[k];

          var _x = layout.t2screen(_p[0]);

          var _y = layout.$2screen(_p[i]);

          if (_p[i] == null || _y !== _y) {
            skip = true;
          } else {
            if (skip) ctx.moveTo(_x, _y);
            ctx.lineTo(_x, _y);
            skip = false;
          }
        }
      }

      ctx.stroke();
    },
    // For all data with these types overlay will be
    // added to the renderer list. And '$props.data'
    // will have the corresponding values. If you want to
    // redefine the default behviour for a prticular
    // indicator (let's say EMA),
    // just create a new overlay with the same type:
    // e.g. use_for() { return ['EMA'] }.
    use_for: function use_for() {
      return ['Spline', 'EMA', 'SMA'];
    },
    // Colors for the legend, should have the
    // same dimention as a data point (excl. timestamp)
    data_colors: function data_colors() {
      return [this.color];
    }
  },
  // Define internal setting & constants here
  computed: {
    sett: function sett() {
      return this.$props.settings;
    },
    line_width: function line_width() {
      return this.sett.lineWidth || 0.75;
    },
    color: function color() {
      var n = this.$props.num % 5;
      return this.sett.color || this.COLORS[n];
    },
    data_index: function data_index() {
      return this.sett.dataIndex || 1;
    },
    // Don't connect separate parts if true
    skip_nan: function skip_nan() {
      return this.sett.skipNaN;
    }
  },
  data: function data() {
    return {
      COLORS: ['#42b28a', '#5691ce', '#612ff9', '#d50b90', '#ff2316']
    };
  }
});
;// CONCATENATED MODULE: ./src/components/overlays/Spline.vue?vue&type=script&lang=js&
 /* harmony default export */ const overlays_Splinevue_type_script_lang_js_ = (Splinevue_type_script_lang_js_); 
;// CONCATENATED MODULE: ./src/components/overlays/Spline.vue
var Spline_render, Spline_staticRenderFns
;



/* normalize component */
;
var Spline_component = normalizeComponent(
  overlays_Splinevue_type_script_lang_js_,
  Spline_render,
  Spline_staticRenderFns,
  false,
  null,
  null,
  null
  
)

/* hot reload */
if (false) { var Spline_api; }
Spline_component.options.__file = "src/components/overlays/Spline.vue"
/* harmony default export */ const Spline = (Spline_component.exports);
;// CONCATENATED MODULE: ./node_modules/babel-loader/lib/index.js!./node_modules/vue-loader/lib/index.js??vue-loader-options!./src/components/overlays/Splines.vue?vue&type=script&lang=js&
// Channel renderer. (Keltner, Bollinger)

/* harmony default export */ const Splinesvue_type_script_lang_js_ = ({
  name: 'Splines',
  mixins: [overlay],
  methods: {
    meta_info: function meta_info() {
      return {
        author: 'C451',
        version: '1.1.0'
      };
    },
    draw: function draw(ctx) {
      for (var i = 0; i < this.lines_num; i++) {
        var _i = i % this.clrx.length;

        ctx.strokeStyle = this.clrx[_i];
        ctx.lineWidth = this.widths[i] || this.line_width;
        ctx.beginPath();
        this.draw_spline(ctx, i);
        ctx.stroke();
      }
    },
    draw_spline: function draw_spline(ctx, i) {
      var layout = this.$props.layout;
      var data = this.$props.data;

      if (!this.skip_nan) {
        for (var k = 0, n = data.length; k < n; k++) {
          var p = data[k];
          var x = layout.t2screen(p[0]);
          var y = layout.$2screen(p[i + 1]);
          ctx.lineTo(x, y);
        }
      } else {
        var skip = false;

        for (var k = 0, n = data.length; k < n; k++) {
          var _p = data[k];

          var _x = layout.t2screen(_p[0]);

          var _y = layout.$2screen(_p[i + 1]);

          if (_p[i + 1] == null || _y !== _y) {
            skip = true;
          } else {
            if (skip) ctx.moveTo(_x, _y);
            ctx.lineTo(_x, _y);
            skip = false;
          }
        }
      }
    },
    use_for: function use_for() {
      return ['Splines', 'DMI'];
    },
    data_colors: function data_colors() {
      return this.clrx;
    }
  },
  // Define internal setting & constants here
  computed: {
    sett: function sett() {
      return this.$props.settings;
    },
    line_width: function line_width() {
      return this.sett.lineWidth || 0.75;
    },
    widths: function widths() {
      return this.sett.lineWidths || [];
    },
    clrx: function clrx() {
      var colors = this.sett.colors || [];
      var n = this.$props.num;

      if (!colors.length) {
        for (var i = 0; i < this.lines_num; i++) {
          colors.push(this.COLORS[(n + i) % 5]);
        }
      }

      return colors;
    },
    lines_num: function lines_num() {
      if (!this.$props.data[0]) return 0;
      return this.$props.data[0].length - 1;
    },
    // Don't connect separate parts if true
    skip_nan: function skip_nan() {
      return this.sett.skipNaN;
    }
  },
  data: function data() {
    return {
      COLORS: ['#42b28a', '#5691ce', '#612ff9', '#d50b90', '#ff2316']
    };
  }
});
;// CONCATENATED MODULE: ./src/components/overlays/Splines.vue?vue&type=script&lang=js&
 /* harmony default export */ const overlays_Splinesvue_type_script_lang_js_ = (Splinesvue_type_script_lang_js_); 
;// CONCATENATED MODULE: ./src/components/overlays/Splines.vue
var Splines_render, Splines_staticRenderFns
;



/* normalize component */
;
var Splines_component = normalizeComponent(
  overlays_Splinesvue_type_script_lang_js_,
  Splines_render,
  Splines_staticRenderFns,
  false,
  null,
  null,
  null
  
)

/* hot reload */
if (false) { var Splines_api; }
Splines_component.options.__file = "src/components/overlays/Splines.vue"
/* harmony default export */ const Splines = (Splines_component.exports);
;// CONCATENATED MODULE: ./node_modules/babel-loader/lib/index.js!./node_modules/vue-loader/lib/index.js??vue-loader-options!./src/components/overlays/Range.vue?vue&type=script&lang=js&
// R S I . Because we love it
// Adds all necessary stuff for you.

/* harmony default export */ const Rangevue_type_script_lang_js_ = ({
  name: 'Range',
  mixins: [overlay],
  methods: {
    meta_info: function meta_info() {
      return {
        author: 'C451',
        version: '1.0.1'
      };
    },
    // Here goes your code. You are provided with:
    // { All stuff is reactive }
    // $props.layout -> positions of all chart elements +
    //  some helper functions (see layout_fn.js)
    // $props.interval -> candlestick time interval
    // $props.sub -> current subset of candlestick data
    // $props.data -> your indicator's data subset.
    //  Comes "as is", should have the following format:
    //  [[<timestamp>, ... ], ... ]
    // $props.colors -> colors (see TradingVue.vue)
    // $props.cursor -> current position of crosshair
    // $props.settings -> indicator's custom settings
    //  E.g. colors, line thickness, etc. You define it.
    // $props.num -> indicator's layer number (of All
    // layers in the current grid)
    // $props.id -> indicator's id (e.g. EMA_0)
    // ~
    // Finally, let's make the canvas dirty!
    draw: function draw(ctx) {
      var layout = this.$props.layout;
      var upper = layout.$2screen(this.sett.upper || 70);
      var lower = layout.$2screen(this.sett.lower || 30);
      var data = this.$props.data; // RSI values

      ctx.lineWidth = this.line_width;
      ctx.strokeStyle = this.color;
      ctx.beginPath();

      for (var k = 0, n = data.length; k < n; k++) {
        var p = data[k];
        var x = layout.t2screen(p[0]);
        var y = layout.$2screen(p[1]);
        ctx.lineTo(x, y);
      }

      ctx.stroke();
      ctx.strokeStyle = this.band_color;
      ctx.setLineDash([5]); // Will be removed after draw()

      ctx.beginPath(); // Fill the area between the bands

      ctx.fillStyle = this.back_color;
      ctx.fillRect(0, upper, layout.width, lower - upper); // Upper band

      ctx.moveTo(0, upper);
      ctx.lineTo(layout.width, upper); // Lower band

      ctx.moveTo(0, lower);
      ctx.lineTo(layout.width, lower);
      ctx.stroke();
    },
    // For all data with these types overlay will be
    // added to the renderer list. And '$props.data'
    // will have the corresponding values. If you want to
    // redefine the default behviour for a prticular
    // indicator (let's say EMA),
    // just create a new overlay with the same type:
    // e.g. use_for() { return ['EMA'] }.
    use_for: function use_for() {
      return ['Range', 'RSI'];
    },
    // Colors for the legend, should have the
    // same dimention as a data point (excl. timestamp)
    data_colors: function data_colors() {
      return [this.color];
    },
    // Y-Range tansform. For example you need a fixed
    // Y-range for an indicator, you can do it here!
    // Gets estimated range, @return you favorite range
    y_range: function y_range(hi, lo) {
      return [Math.max(hi, this.sett.upper || 70), Math.min(lo, this.sett.lower || 30)];
    }
  },
  // Define internal setting & constants here
  computed: {
    sett: function sett() {
      return this.$props.settings;
    },
    line_width: function line_width() {
      return this.sett.lineWidth || 0.75;
    },
    color: function color() {
      return this.sett.color || '#ec206e';
    },
    band_color: function band_color() {
      return this.sett.bandColor || '#ddd';
    },
    back_color: function back_color() {
      return this.sett.backColor || '#381e9c16';
    }
  }
});
;// CONCATENATED MODULE: ./src/components/overlays/Range.vue?vue&type=script&lang=js&
 /* harmony default export */ const overlays_Rangevue_type_script_lang_js_ = (Rangevue_type_script_lang_js_); 
;// CONCATENATED MODULE: ./src/components/overlays/Range.vue
var Range_render, Range_staticRenderFns
;



/* normalize component */
;
var Range_component = normalizeComponent(
  overlays_Rangevue_type_script_lang_js_,
  Range_render,
  Range_staticRenderFns,
  false,
  null,
  null,
  null
  
)

/* hot reload */
if (false) { var Range_api; }
Range_component.options.__file = "src/components/overlays/Range.vue"
/* harmony default export */ const Range = (Range_component.exports);
;// CONCATENATED MODULE: ./node_modules/babel-loader/lib/index.js!./node_modules/vue-loader/lib/index.js??vue-loader-options!./src/components/overlays/Trades.vue?vue&type=script&lang=js&

/* harmony default export */ const Tradesvue_type_script_lang_js_ = ({
  name: 'Trades',
  mixins: [overlay],
  methods: {
    meta_info: function meta_info() {
      return {
        author: 'C451',
        version: '1.0.2'
      };
    },
    draw: function draw(ctx) {
      var layout = this.$props.layout;
      var data = this.$props.data;
      ctx.lineWidth = 1.5;
      ctx.strokeStyle = 'black';

      for (var k = 0, n = data.length; k < n; k++) {
        var p = data[k];
        ctx.fillStyle = p[1] ? this.buy_color : this.sell_color;
        ctx.beginPath();
        var x = layout.t2screen(p[0]); // x - Mapping

        var y = layout.$2screen(p[2]); // y - Mapping

        ctx.arc(x, y, this.marker_size + 0.5, 0, Math.PI * 2, true);
        ctx.fill();
        ctx.stroke();

        if (this.show_label && p[3]) {
          this.draw_label(ctx, x, y, p);
        }
      }
    },
    draw_label: function draw_label(ctx, x, y, p) {
      ctx.fillStyle = this.label_color;
      ctx.font = this.new_font;
      ctx.textAlign = 'center';
      ctx.fillText(p[3], x, y - 25);
    },
    use_for: function use_for() {
      return ['Trades'];
    },
    // Defines legend format (values & colors)
    legend: function legend(values) {
      switch (values[1]) {
        case 0:
          var pos = 'Sell';
          break;

        case 1:
          pos = 'Buy';
          break;

        default:
          pos = 'Unknown';
      }

      return [{
        value: pos
      }, {
        value: values[2].toFixed(4),
        color: this.$props.colors.text
      }].concat(values[3] ? [{
        value: values[3]
      }] : []);
    }
  },
  // Define internal setting & constants here
  computed: {
    sett: function sett() {
      return this.$props.settings;
    },
    default_font: function default_font() {
      return '12px ' + this.$props.font.split('px').pop();
    },
    buy_color: function buy_color() {
      return this.sett.buyColor || '#63df89';
    },
    sell_color: function sell_color() {
      return this.sett.sellColor || '#ec4662';
    },
    label_color: function label_color() {
      return this.sett.labelColor || '#999';
    },
    marker_size: function marker_size() {
      return this.sett.markerSize || 5;
    },
    show_label: function show_label() {
      return this.sett.showLabel !== false;
    },
    new_font: function new_font() {
      return this.sett.font || this.default_font;
    }
  }
});
;// CONCATENATED MODULE: ./src/components/overlays/Trades.vue?vue&type=script&lang=js&
 /* harmony default export */ const overlays_Tradesvue_type_script_lang_js_ = (Tradesvue_type_script_lang_js_); 
;// CONCATENATED MODULE: ./src/components/overlays/Trades.vue
var Trades_render, Trades_staticRenderFns
;



/* normalize component */
;
var Trades_component = normalizeComponent(
  overlays_Tradesvue_type_script_lang_js_,
  Trades_render,
  Trades_staticRenderFns,
  false,
  null,
  null,
  null
  
)

/* hot reload */
if (false) { var Trades_api; }
Trades_component.options.__file = "src/components/overlays/Trades.vue"
/* harmony default export */ const Trades = (Trades_component.exports);
;// CONCATENATED MODULE: ./node_modules/babel-loader/lib/index.js!./node_modules/vue-loader/lib/index.js??vue-loader-options!./src/components/overlays/Channel.vue?vue&type=script&lang=js&
// Channel renderer. (Keltner, Bollinger)
// TODO: allow color transparency
// TODO: improve performance: draw in one solid chunk

/* harmony default export */ const Channelvue_type_script_lang_js_ = ({
  name: 'Channel',
  mixins: [overlay],
  methods: {
    meta_info: function meta_info() {
      return {
        author: 'C451',
        version: '1.0.1'
      };
    },

    /*draw(ctx) {
        ctx.lineWidth = this.line_width
        ctx.strokeStyle = this.color
        ctx.fillStyle = this.back_color
         for (var i = 0; i < this.$props.data.length - 1; i++) {
              let p1 = this.mapp(this.$props.data[i])
            let p2 = this.mapp(this.$props.data[i+1])
             if (!p2) continue
            if (p1.y1 !== p1.y1) continue // Fix NaN
             // Background
            ctx.beginPath()
            ctx.moveTo(p1.x, p1.y1)
            ctx.lineTo(p2.x + 0.1, p2.y1)
            ctx.lineTo(p2.x + 0.1, p2.y3)
            ctx.lineTo(p1.x, p1.y3)
            ctx.fill()
             // Lines
            ctx.beginPath()
            ctx.moveTo(p1.x, p1.y1)
            ctx.lineTo(p2.x, p2.y1)
            if (this.show_mid) {
                ctx.moveTo(p1.x, p1.y2)
                ctx.lineTo(p2.x, p2.y2)
            }
            ctx.moveTo(p1.x, p1.y3)
            ctx.lineTo(p2.x, p2.y3)
            ctx.stroke()
         }
    },*/
    draw: function draw(ctx) {
      // Background
      var data = this.data;
      var layout = this.layout;
      ctx.beginPath();
      ctx.fillStyle = this.back_color;

      for (var i = 0; i < data.length; i++) {
        var p = data[i];
        var x = layout.t2screen(p[0]);
        var y = layout.$2screen(p[1] || undefined);
        ctx.lineTo(x, y);
      }

      for (var i = data.length - 1; i >= 0; i--) {
        var _p = data[i];

        var _x = layout.t2screen(_p[0]);

        var _y = layout.$2screen(_p[3] || undefined);

        ctx.lineTo(_x, _y);
      }

      ctx.fill(); // Lines

      ctx.lineWidth = this.line_width;
      ctx.strokeStyle = this.color; // Top line

      ctx.beginPath();

      for (var i = 0; i < data.length; i++) {
        var _p2 = data[i];

        var _x2 = layout.t2screen(_p2[0]);

        var _y2 = layout.$2screen(_p2[1] || undefined);

        ctx.lineTo(_x2, _y2);
      }

      ctx.stroke(); // Bottom line

      ctx.beginPath();

      for (var i = 0; i < data.length; i++) {
        var _p3 = data[i];

        var _x3 = layout.t2screen(_p3[0]);

        var _y3 = layout.$2screen(_p3[3] || undefined);

        ctx.lineTo(_x3, _y3);
      }

      ctx.stroke(); // Middle line

      if (!this.show_mid) return;
      ctx.beginPath();

      for (var i = 0; i < data.length; i++) {
        var _p4 = data[i];

        var _x4 = layout.t2screen(_p4[0]);

        var _y4 = layout.$2screen(_p4[2] || undefined);

        ctx.lineTo(_x4, _y4);
      }

      ctx.stroke();
    },
    mapp: function mapp(p) {
      var layout = this.$props.layout;
      return p && {
        x: layout.t2screen(p[0]),
        y1: layout.$2screen(p[1]),
        y2: layout.$2screen(p[2]),
        y3: layout.$2screen(p[3])
      };
    },
    use_for: function use_for() {
      return ['Channel', 'KC', 'BB'];
    },
    data_colors: function data_colors() {
      return [this.color, this.color, this.color];
    }
  },
  // Define internal setting & constants here
  computed: {
    sett: function sett() {
      return this.$props.settings;
    },
    line_width: function line_width() {
      return this.sett.lineWidth || 0.75;
    },
    color: function color() {
      var n = this.$props.num % 5;
      return this.sett.color || this.COLORS[n];
    },
    show_mid: function show_mid() {
      return 'showMid' in this.sett ? this.sett.showMid : true;
    },
    back_color: function back_color() {
      return this.sett.backColor || this.color + '11';
    }
  },
  data: function data() {
    return {
      COLORS: ['#42b28a', '#5691ce', '#612ff9', '#d50b90', '#ff2316']
    };
  }
});
;// CONCATENATED MODULE: ./src/components/overlays/Channel.vue?vue&type=script&lang=js&
 /* harmony default export */ const overlays_Channelvue_type_script_lang_js_ = (Channelvue_type_script_lang_js_); 
;// CONCATENATED MODULE: ./src/components/overlays/Channel.vue
var Channel_render, Channel_staticRenderFns
;



/* normalize component */
;
var Channel_component = normalizeComponent(
  overlays_Channelvue_type_script_lang_js_,
  Channel_render,
  Channel_staticRenderFns,
  false,
  null,
  null,
  null
  
)

/* hot reload */
if (false) { var Channel_api; }
Channel_component.options.__file = "src/components/overlays/Channel.vue"
/* harmony default export */ const Channel = (Channel_component.exports);
;// CONCATENATED MODULE: ./node_modules/babel-loader/lib/index.js!./node_modules/vue-loader/lib/index.js??vue-loader-options!./src/components/overlays/Segment.vue?vue&type=script&lang=js&
// Segment renderer.

/* harmony default export */ const Segmentvue_type_script_lang_js_ = ({
  name: 'Segment',
  mixins: [overlay],
  methods: {
    meta_info: function meta_info() {
      return {
        author: 'C451',
        version: '1.0.0'
      };
    },
    draw: function draw(ctx) {
      if (!this.p1 || !this.p2) return;
      ctx.lineWidth = this.line_width;
      ctx.strokeStyle = this.color;
      ctx.beginPath();
      var layout = this.$props.layout;
      var x1 = layout.t2screen(this.p1[0]);
      var y1 = layout.$2screen(this.p1[1]);
      ctx.moveTo(x1, y1);
      var x2 = layout.t2screen(this.p2[0]);
      var y2 = layout.$2screen(this.p2[1]);
      ctx.lineTo(x2, y2);
      ctx.stroke();
    },
    use_for: function use_for() {
      return ['Segment'];
    },
    data_colors: function data_colors() {
      return [this.color];
    }
  },
  // Define internal setting & constants here
  computed: {
    sett: function sett() {
      return this.$props.settings;
    },
    p1: function p1() {
      return this.$props.settings.p1;
    },
    p2: function p2() {
      return this.$props.settings.p2;
    },
    line_width: function line_width() {
      return this.sett.lineWidth || 0.9;
    },
    color: function color() {
      var n = this.$props.num % 5;
      return this.sett.color || this.COLORS[n];
    }
  },
  data: function data() {
    return {
      COLORS: ['#42b28a', '#5691ce', '#612ff9', '#d50b90', '#ff2316']
    };
  }
});
;// CONCATENATED MODULE: ./src/components/overlays/Segment.vue?vue&type=script&lang=js&
 /* harmony default export */ const overlays_Segmentvue_type_script_lang_js_ = (Segmentvue_type_script_lang_js_); 
;// CONCATENATED MODULE: ./src/components/overlays/Segment.vue
var Segment_render, Segment_staticRenderFns
;



/* normalize component */
;
var Segment_component = normalizeComponent(
  overlays_Segmentvue_type_script_lang_js_,
  Segment_render,
  Segment_staticRenderFns,
  false,
  null,
  null,
  null
  
)

/* hot reload */
if (false) { var Segment_api; }
Segment_component.options.__file = "src/components/overlays/Segment.vue"
/* harmony default export */ const Segment = (Segment_component.exports);
;// CONCATENATED MODULE: ./src/components/js/layout_cnv.js


// Claculates postions and sizes for candlestick
// and volume bars for the given subset of data

function layout_cnv(self) {
  var $p = self.$props;
  var sub = $p.data;
  var t2screen = $p.layout.t2screen;
  var layout = $p.layout;
  var candles = [];
  var volume = []; // The volume bar height is determined as a percentage of
  // the chart's height (VOLSCALE)

  var maxv = Math.max.apply(Math, _toConsumableArray(sub.map(function (x) {
    return x[5];
  })));
  var vs = $p.config.VOLSCALE * layout.height / maxv;
  var x1,
      x2,
      w,
      avg_w,
      mid,
      prev = undefined; // Subset interval against main interval

  var _new_interval = new_interval(layout, $p, sub),
      _new_interval2 = _slicedToArray(_new_interval, 2),
      interval2 = _new_interval2[0],
      ratio = _new_interval2[1];

  var px_step2 = layout.px_step * ratio;
  var splitter = px_step2 > 5 ? 1 : 0; // A & B are current chart tranformations:
  // A === scale,  B === Y-axis shift

  for (var i = 0; i < sub.length; i++) {
    var p = sub[i];
    mid = t2screen(p[0]) + 1; // Clear volume bar if there is a time gap

    if (sub[i - 1] && p[0] - sub[i - 1][0] > interval2) {
      prev = null;
    }

    x1 = prev || Math.floor(mid - px_step2 * 0.5);
    x2 = Math.floor(mid + px_step2 * 0.5) - 0.5; // TODO: add log scale support

    candles.push({
      x: mid,
      w: layout.px_step * $p.config.CANDLEW * ratio,
      o: Math.floor(p[1] * layout.A + layout.B),
      h: Math.floor(p[2] * layout.A + layout.B),
      l: Math.floor(p[3] * layout.A + layout.B),
      c: Math.floor(p[4] * layout.A + layout.B),
      raw: p
    });
    volume.push({
      x1: x1,
      x2: x2,
      h: p[5] * vs,
      green: p[4] >= p[1],
      raw: p
    });
    prev = x2 + splitter;
  }

  return {
    candles: candles,
    volume: volume
  };
}
function layout_vol(self) {
  var $p = self.$props;
  var sub = $p.data;
  var t2screen = $p.layout.t2screen;
  var layout = $p.layout;
  var volume = []; // Detect data second dimention size:

  var dim = sub[0] ? sub[0].length : 0; // Support special volume data (see API book), or OHLCV
  // Data indices:

  self._i1 = dim < 6 ? 1 : 5;
  self._i2 = dim < 6 ? function (p) {
    return p[2];
  } : function (p) {
    return p[4] >= p[1];
  };
  var maxv = Math.max.apply(Math, _toConsumableArray(sub.map(function (x) {
    return x[self._i1];
  })));
  var volscale = self.volscale || $p.config.VOLSCALE;
  var vs = volscale * layout.height / maxv;
  var x1,
      x2,
      mid,
      prev = undefined; // Subset interval against main interval

  var _new_interval3 = new_interval(layout, $p, sub),
      _new_interval4 = _slicedToArray(_new_interval3, 2),
      interval2 = _new_interval4[0],
      ratio = _new_interval4[1];

  var px_step2 = layout.px_step * ratio;
  var splitter = px_step2 > 5 ? 1 : 0; // A & B are current chart tranformations:
  // A === scale,  B === Y-axis shift

  for (var i = 0; i < sub.length; i++) {
    var p = sub[i];
    mid = t2screen(p[0]) + 1; // Clear volume bar if there is a time gap

    if (sub[i - 1] && p[0] - sub[i - 1][0] > interval2) {
      prev = null;
    }

    x1 = prev || Math.floor(mid - px_step2 * 0.5);
    x2 = Math.floor(mid + px_step2 * 0.5) - 0.5;
    volume.push({
      x1: x1,
      x2: x2,
      h: p[self._i1] * vs,
      green: self._i2(p),
      raw: p
    });
    prev = x2 + splitter;
  }

  return volume;
}

function new_interval(layout, $p, sub) {
  // Subset interval against main interval
  if (!layout.ti_map.ib) {
    var interval2 = $p.tf || utils.detect_interval(sub);
    var ratio = interval2 / $p.interval;
  } else {
    if ($p.tf) {
      var ratio = $p.tf / layout.ti_map.tf;
      var interval2 = ratio;
    } else {
      var interval2 = utils.detect_interval(sub);
      var ratio = interval2 / $p.interval;
    }
  }

  return [interval2, ratio];
}
;// CONCATENATED MODULE: ./src/components/primitives/candle.js



// Candle object for Candles overlay
var CandleExt = /*#__PURE__*/function () {
  function CandleExt(overlay, ctx, data) {
    classCallCheck_classCallCheck(this, CandleExt);

    this.ctx = ctx;
    this.self = overlay;
    this.style = data.raw[6] || this.self;
    this.draw(data);
  }

  createClass_createClass(CandleExt, [{
    key: "draw",
    value: function draw(data) {
      var green = data.raw[4] >= data.raw[1];
      var body_color = green ? this.style.colorCandleUp : this.style.colorCandleDw;
      var wick_color = green ? this.style.colorWickUp : this.style.colorWickDw;
      var w = Math.max(data.w, 1);
      var hw = Math.max(Math.floor(w * 0.5), 1);
      var h = Math.abs(data.o - data.c);
      var max_h = data.c === data.o ? 1 : 2;
      var x05 = Math.floor(data.x) - 0.5;
      this.ctx.strokeStyle = wick_color;
      this.ctx.beginPath();
      this.ctx.moveTo(x05, Math.floor(data.h));
      this.ctx.lineTo(x05, Math.floor(data.l));
      this.ctx.stroke();

      if (data.w > 1.5) {
        this.ctx.fillStyle = body_color; // TODO: Move common calculations to layout.js

        var s = green ? 1 : -1;
        this.ctx.fillRect(Math.floor(data.x - hw - 1), data.c, Math.floor(hw * 2 + 1), s * Math.max(h, max_h));
      } else {
        this.ctx.strokeStyle = body_color;
        this.ctx.beginPath();
        this.ctx.moveTo(x05, Math.floor(Math.min(data.o, data.c)));
        this.ctx.lineTo(x05, Math.floor(Math.max(data.o, data.c)) + (data.o === data.c ? 1 : 0));
        this.ctx.stroke();
      }
    }
  }]);

  return CandleExt;
}();


;// CONCATENATED MODULE: ./src/components/primitives/volbar.js



var VolbarExt = /*#__PURE__*/function () {
  function VolbarExt(overlay, ctx, data) {
    classCallCheck_classCallCheck(this, VolbarExt);

    this.ctx = ctx;
    this.$p = overlay.$props;
    this.self = overlay;
    this.style = data.raw[6] || this.self;
    this.draw(data);
  }

  createClass_createClass(VolbarExt, [{
    key: "draw",
    value: function draw(data) {
      var y0 = this.$p.layout.height;
      var w = data.x2 - data.x1;
      var h = Math.floor(data.h);
      this.ctx.fillStyle = data.green ? this.style.colorVolUp : this.style.colorVolDw;
      this.ctx.fillRect(Math.floor(data.x1), Math.floor(y0 - h - 0.5), Math.floor(w), Math.floor(h + 1));
    }
  }]);

  return VolbarExt;
}();


;// CONCATENATED MODULE: ./src/components/primitives/price.js



// Price bar & price line (shader)
var Price = /*#__PURE__*/function () {
  function Price(comp) {
    classCallCheck_classCallCheck(this, Price);

    this.comp = comp;
  } // Defines an inline shader (has access to both
  // target & overlay's contexts)


  createClass_createClass(Price, [{
    key: "init_shader",
    value: function init_shader() {
      var _this = this;

      var layout = this.comp.$props.layout;
      var config = this.comp.$props.config;
      var comp = this.comp;

      var last_bar = function last_bar() {
        return _this.last_bar();
      };

      this.comp.$emit('new-shader', {
        target: 'sidebar',
        draw: function draw(ctx) {
          var bar = last_bar();
          if (!bar) return;
          var w = ctx.canvas.width;
          var h = config.PANHEIGHT;
          var lbl = bar.price.toFixed(layout.prec);
          ctx.fillStyle = bar.color;
          var x = -0.5;
          var y = bar.y - h * 0.5 - 0.5;
          var a = 7;
          ctx.fillRect(x - 0.5, y, w + 1, h);
          ctx.fillStyle = comp.$props.colors.textHL;
          ctx.textAlign = 'left';
          ctx.fillText(lbl, a, y + 15);
        }
      });
      this.shader = true;
    } // Regular draw call for overaly

  }, {
    key: "draw",
    value: function draw(ctx) {
      if (!this.comp.$props.meta.last) return;
      if (!this.shader) this.init_shader();
      var layout = this.comp.$props.layout;
      var last = this.comp.$props.last;
      var dir = last[4] >= last[1];
      var color = dir ? this.green() : this.red();
      var y = layout.$2screen(last[4]) + (dir ? 1 : 0);
      ctx.strokeStyle = color;
      ctx.setLineDash([1, 1]);
      ctx.beginPath();
      ctx.moveTo(0, y);
      ctx.lineTo(layout.width, y);
      ctx.stroke();
      ctx.setLineDash([]);
    }
  }, {
    key: "last_bar",
    value: function last_bar() {
      if (!this.comp.data.length) return undefined;
      var layout = this.comp.$props.layout;
      var last = this.comp.data[this.comp.data.length - 1];
      var y = layout.$2screen(last[4]); //let cndl = layout.c_magnet(last[0])

      return {
        y: y,
        //Math.floor(cndl.c) - 0.5,
        price: last[4],
        color: last[4] >= last[1] ? this.green() : this.red()
      };
    }
  }, {
    key: "last_price",
    value: function last_price() {
      return this.comp.$props.meta.last ? this.comp.$props.meta.last[4] : undefined;
    }
  }, {
    key: "green",
    value: function green() {
      return this.comp.colorCandleUp;
    }
  }, {
    key: "red",
    value: function red() {
      return this.comp.colorCandleDw;
    }
  }]);

  return Price;
}();


;// CONCATENATED MODULE: ./node_modules/babel-loader/lib/index.js!./node_modules/vue-loader/lib/index.js??vue-loader-options!./src/components/overlays/Candles.vue?vue&type=script&lang=js&
// Renedrer for candlesticks + volume (optional)
// It can be used as the main chart or an indicator





/* harmony default export */ const Candlesvue_type_script_lang_js_ = ({
  name: 'Candles',
  mixins: [overlay],
  methods: {
    meta_info: function meta_info() {
      return {
        author: 'C451',
        version: '1.2.1'
      };
    },
    init: function init() {
      this.price = new Price(this);
    },
    draw: function draw(ctx) {
      // If data === main candlestick data
      // render as main chart:
      if (this.$props.sub === this.$props.data) {
        var cnv = {
          candles: this.$props.layout.candles,
          volume: this.$props.layout.volume
        }; // Else, as offchart / onchart indicator:
      } else {
        cnv = layout_cnv(this);
      }

      if (this.show_volume) {
        var cv = cnv.volume;

        for (var i = 0, n = cv.length; i < n; i++) {
          new VolbarExt(this, ctx, cv[i]);
        }
      }

      var cc = cnv.candles;

      for (var i = 0, n = cc.length; i < n; i++) {
        new CandleExt(this, ctx, cc[i]);
      }

      if (this.price_line) this.price.draw(ctx);
    },
    use_for: function use_for() {
      return ['Candles'];
    },
    // In case it's added as offchart overlay
    y_range: function y_range() {
      var hi = -Infinity,
          lo = Infinity;

      for (var i = 0, n = this.sub.length; i < n; i++) {
        var x = this.sub[i];
        if (x[2] > hi) hi = x[2];
        if (x[3] < lo) lo = x[3];
      }

      return [hi, lo];
    }
  },
  // Define internal setting & constants here
  computed: {
    sett: function sett() {
      return this.$props.settings;
    },
    show_volume: function show_volume() {
      return 'showVolume' in this.sett ? this.sett.showVolume : true;
    },
    price_line: function price_line() {
      return 'priceLine' in this.sett ? this.sett.priceLine : true;
    },
    colorCandleUp: function colorCandleUp() {
      return this.sett.colorCandleUp || this.$props.colors.candleUp;
    },
    colorCandleDw: function colorCandleDw() {
      return this.sett.colorCandleDw || this.$props.colors.candleDw;
    },
    colorWickUp: function colorWickUp() {
      return this.sett.colorWickUp || this.$props.colors.wickUp;
    },
    colorWickDw: function colorWickDw() {
      return this.sett.colorWickDw || this.$props.colors.wickDw;
    },
    colorWickSm: function colorWickSm() {
      return this.sett.colorWickSm || this.$props.colors.wickSm;
    },
    colorVolUp: function colorVolUp() {
      return this.sett.colorVolUp || this.$props.colors.volUp;
    },
    colorVolDw: function colorVolDw() {
      return this.sett.colorVolDw || this.$props.colors.volDw;
    }
  },
  data: function data() {
    return {
      price: {}
    };
  }
});
;// CONCATENATED MODULE: ./src/components/overlays/Candles.vue?vue&type=script&lang=js&
 /* harmony default export */ const overlays_Candlesvue_type_script_lang_js_ = (Candlesvue_type_script_lang_js_); 
;// CONCATENATED MODULE: ./src/components/overlays/Candles.vue
var Candles_render, Candles_staticRenderFns
;



/* normalize component */
;
var Candles_component = normalizeComponent(
  overlays_Candlesvue_type_script_lang_js_,
  Candles_render,
  Candles_staticRenderFns,
  false,
  null,
  null,
  null
  
)

/* hot reload */
if (false) { var Candles_api; }
Candles_component.options.__file = "src/components/overlays/Candles.vue"
/* harmony default export */ const Candles = (Candles_component.exports);
;// CONCATENATED MODULE: ./node_modules/babel-loader/lib/index.js!./node_modules/vue-loader/lib/index.js??vue-loader-options!./src/components/overlays/Volume.vue?vue&type=script&lang=js&


function Volumevue_type_script_lang_js_createForOfIteratorHelper(o, allowArrayLike) { var it; if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (it = Volumevue_type_script_lang_js_unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = o[Symbol.iterator](); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it["return"] != null) it["return"](); } finally { if (didErr) throw err; } } }; }

function Volumevue_type_script_lang_js_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return Volumevue_type_script_lang_js_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return Volumevue_type_script_lang_js_arrayLikeToArray(o, minLen); }

function Volumevue_type_script_lang_js_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

// Standalone renedrer for the volume



/* harmony default export */ const Volumevue_type_script_lang_js_ = ({
  name: 'Volume',
  mixins: [overlay],
  methods: {
    meta_info: function meta_info() {
      return {
        author: 'C451',
        version: '1.1.0'
      };
    },
    draw: function draw(ctx) {
      // TODO: volume average
      // TODO: Y-axis scaling
      var _iterator = Volumevue_type_script_lang_js_createForOfIteratorHelper(layout_vol(this)),
          _step;

      try {
        for (_iterator.s(); !(_step = _iterator.n()).done;) {
          var v = _step.value;
          new VolbarExt(this, ctx, v);
        }
      } catch (err) {
        _iterator.e(err);
      } finally {
        _iterator.f();
      }
    },
    use_for: function use_for() {
      return ['Volume'];
    },
    // Defines legend format (values & colors)
    // _i2 - detetected data index (see layout_cnv)
    legend: function legend(values) {
      var flag = this._i2 ? this._i2(values) : values[2];
      var color = flag ? this.colorVolUpLegend : this.colorVolDwLegend;
      return [{
        value: values[this._i1 || 1],
        color: color
      }];
    },
    // When added as offchart overlay
    // If data is OHLCV => recalc y-range
    // _i1 - detetected data index (see layout_cnv)
    y_range: function y_range(hi, lo) {
      var _this = this;

      if (this._i1 === 5) {
        var sub = this.$props.sub;
        return [Math.max.apply(Math, _toConsumableArray(sub.map(function (x) {
          return x[_this._i1];
        }))), Math.min.apply(Math, _toConsumableArray(sub.map(function (x) {
          return x[_this._i1];
        })))];
      } else {
        return [hi, lo];
      }
    }
  },
  // Define internal setting & constants here
  computed: {
    sett: function sett() {
      return this.$props.settings;
    },
    colorVolUp: function colorVolUp() {
      return this.sett.colorVolUp || this.$props.colors.volUp;
    },
    colorVolDw: function colorVolDw() {
      return this.sett.colorVolDw || this.$props.colors.volDw;
    },
    colorVolUpLegend: function colorVolUpLegend() {
      return this.sett.colorVolUpLegend || this.$props.colors.candleUp;
    },
    colorVolDwLegend: function colorVolDwLegend() {
      return this.sett.colorVolDwLegend || this.$props.colors.candleDw;
    },
    volscale: function volscale() {
      return this.sett.volscale || this.$props.grid_id > 0 ? 0.85 : this.$props.config.VOLSCALE;
    }
  },
  data: function data() {
    return {};
  }
});
;// CONCATENATED MODULE: ./src/components/overlays/Volume.vue?vue&type=script&lang=js&
 /* harmony default export */ const overlays_Volumevue_type_script_lang_js_ = (Volumevue_type_script_lang_js_); 
;// CONCATENATED MODULE: ./src/components/overlays/Volume.vue
var Volume_render, Volume_staticRenderFns
;



/* normalize component */
;
var Volume_component = normalizeComponent(
  overlays_Volumevue_type_script_lang_js_,
  Volume_render,
  Volume_staticRenderFns,
  false,
  null,
  null,
  null
  
)

/* hot reload */
if (false) { var Volume_api; }
Volume_component.options.__file = "src/components/overlays/Volume.vue"
/* harmony default export */ const Volume = (Volume_component.exports);
;// CONCATENATED MODULE: ./node_modules/babel-loader/lib/index.js!./node_modules/vue-loader/lib/index.js??vue-loader-options!./src/components/overlays/Splitters.vue?vue&type=script&lang=js&
// Data section splitters (with labels)

/* harmony default export */ const Splittersvue_type_script_lang_js_ = ({
  name: 'Splitters',
  mixins: [overlay],
  methods: {
    meta_info: function meta_info() {
      return {
        author: 'C451',
        version: '1.0.1'
      };
    },
    draw: function draw(ctx) {
      var _this = this;

      var layout = this.$props.layout;
      ctx.lineWidth = this.line_width;
      ctx.strokeStyle = this.line_color;
      this.$props.data.forEach(function (p, i) {
        ctx.beginPath();
        var x = layout.t2screen(p[0]); // x - Mapping

        ctx.setLineDash([10, 10]);
        ctx.moveTo(x, 0);
        ctx.lineTo(x, _this.layout.height);
        ctx.stroke();
        if (p[1]) _this.draw_label(ctx, x, p);
      });
    },
    draw_label: function draw_label(ctx, x, p) {
      var side = p[2] ? 1 : -1;
      x += 2.5 * side;
      ctx.font = this.new_font;
      var pos = p[4] || this.y_position;
      var w = ctx.measureText(p[1]).width + 10;
      var y = this.layout.height * (1.0 - pos);
      y = Math.floor(y);
      ctx.fillStyle = p[3] || this.flag_color;
      ctx.beginPath();
      ctx.moveTo(x, y);
      ctx.lineTo(x + 10 * side, y - 10 * side);
      ctx.lineTo(x + (w + 10) * side, y - 10 * side);
      ctx.lineTo(x + (w + 10) * side, y + 10 * side);
      ctx.lineTo(x + 10 * side, y + 10 * side);
      ctx.closePath();
      ctx.fill();
      ctx.fillStyle = this.label_color;
      ctx.textAlign = side < 0 ? 'right' : 'left';
      ctx.fillText(p[1], x + 15 * side, y + 4);
    },
    use_for: function use_for() {
      return ['Splitters'];
    }
  },
  // Define internal setting & constants here
  computed: {
    sett: function sett() {
      return this.$props.settings;
    },
    new_font: function new_font() {
      return this.sett.font || '12px ' + this.$props.font.split('px').pop();
    },
    flag_color: function flag_color() {
      return this.sett.flagColor || '#4285f4';
    },
    label_color: function label_color() {
      return this.sett.labelColor || '#fff';
    },
    line_color: function line_color() {
      return this.sett.lineColor || '#4285f4';
    },
    line_width: function line_width() {
      return this.sett.lineWidth || 1.0;
    },
    y_position: function y_position() {
      return this.sett.yPosition || 0.9;
    }
  },
  data: function data() {
    return {};
  }
});
;// CONCATENATED MODULE: ./src/components/overlays/Splitters.vue?vue&type=script&lang=js&
 /* harmony default export */ const overlays_Splittersvue_type_script_lang_js_ = (Splittersvue_type_script_lang_js_); 
;// CONCATENATED MODULE: ./src/components/overlays/Splitters.vue
var Splitters_render, Splitters_staticRenderFns
;



/* normalize component */
;
var Splitters_component = normalizeComponent(
  overlays_Splittersvue_type_script_lang_js_,
  Splitters_render,
  Splitters_staticRenderFns,
  false,
  null,
  null,
  null
  
)

/* hot reload */
if (false) { var Splitters_api; }
Splitters_component.options.__file = "src/components/overlays/Splitters.vue"
/* harmony default export */ const Splitters = (Splitters_component.exports);
;// CONCATENATED MODULE: ./src/stuff/keys.js



function keys_createForOfIteratorHelper(o, allowArrayLike) { var it; if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (it = keys_unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = o[Symbol.iterator](); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it["return"] != null) it["return"](); } finally { if (didErr) throw err; } } }; }

function keys_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return keys_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return keys_arrayLikeToArray(o, minLen); }

function keys_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

// Keyboard event handler for overlay
var Keys = /*#__PURE__*/function () {
  function Keys(comp) {
    classCallCheck_classCallCheck(this, Keys);

    this.comp = comp;
    this.map = {};
    this.listeners = 0;
    this.keymap = {};
  }

  createClass_createClass(Keys, [{
    key: "on",
    value: function on(name, handler) {
      if (!handler) return;
      this.map[name] = this.map[name] || [];
      this.map[name].push(handler);
      this.listeners++;
    } // Called by grid.js

  }, {
    key: "emit",
    value: function emit(name, event) {
      if (name in this.map) {
        var _iterator = keys_createForOfIteratorHelper(this.map[name]),
            _step;

        try {
          for (_iterator.s(); !(_step = _iterator.n()).done;) {
            var f = _step.value;
            f(event);
          }
        } catch (err) {
          _iterator.e(err);
        } finally {
          _iterator.f();
        }
      }

      if (name === 'keydown') {
        if (!this.keymap[event.key]) {
          this.emit(event.key);
        }

        this.keymap[event.key] = true;
      }

      if (name === 'keyup') {
        this.keymap[event.key] = false;
      }
    }
  }, {
    key: "pressed",
    value: function pressed(key) {
      return this.keymap[key];
    }
  }]);

  return Keys;
}();


;// CONCATENATED MODULE: ./src/mixins/tool.js
function tool_createForOfIteratorHelper(o, allowArrayLike) { var it; if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (it = tool_unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = o[Symbol.iterator](); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it["return"] != null) it["return"](); } finally { if (didErr) throw err; } } }; }

function tool_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return tool_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return tool_arrayLikeToArray(o, minLen); }

function tool_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

// Usuful stuff for creating tools. Include as mixin


/* harmony default export */ const tool = ({
  methods: {
    init_tool: function init_tool() {
      var _this = this;

      // Collision functions (float, float) => bool,
      this.collisions = [];
      this.pins = [];
      this.mouse.on('mousemove', function (e) {
        if (_this.collisions.some(function (f) {
          return f(_this.mouse.x, _this.mouse.y);
        })) {
          _this.show_pins = true;
        } else {
          _this.show_pins = false;
        }

        if (_this.drag) _this.drag_update();
      });
      this.mouse.on('mousedown', function (e) {
        if (utils.default_prevented(e)) return;

        if (_this.collisions.some(function (f) {
          return f(_this.mouse.x, _this.mouse.y);
        })) {
          if (!_this.selected) {
            _this.$emit('object-selected');
          }

          _this.start_drag();

          e.preventDefault();

          _this.pins.forEach(function (x) {
            return x.mousedown(e, true);
          });
        }
      });
      this.mouse.on('mouseup', function (e) {
        _this.drag = null;

        _this.$emit('scroll-lock', false);
      });
      this.keys = new Keys(this);
      this.keys.on('Delete', this.remove_tool);
      this.keys.on('Backspace', this.remove_tool);
      this.show_pins = false;
      this.drag = null;
    },
    render_pins: function render_pins(ctx) {
      if (this.selected || this.show_pins) {
        this.pins.forEach(function (x) {
          return x.draw(ctx);
        });
      }
    },
    set_state: function set_state(name) {
      this.$emit('change-settings', {
        $state: name
      });
    },
    watch_uuid: function watch_uuid(n, p) {
      // If layer $uuid is changed, then re-init
      // pins & collisions
      if (n.$uuid !== p.$uuid) {
        var _iterator = tool_createForOfIteratorHelper(this.pins),
            _step;

        try {
          for (_iterator.s(); !(_step = _iterator.n()).done;) {
            var p = _step.value;
            p.re_init();
          }
        } catch (err) {
          _iterator.e(err);
        } finally {
          _iterator.f();
        }

        this.collisions = [];
        this.show_pins = false;
        this.drag = null;
      }
    },
    pre_draw: function pre_draw() {
      // Delete all collision functions before
      // the draw() call and let primitives set
      // them again
      this.collisions = [];
    },
    remove_tool: function remove_tool() {
      if (this.selected) this.$emit('remove-tool');
    },
    start_drag: function start_drag() {
      this.$emit('scroll-lock', true);
      var cursor = this.$props.cursor;
      this.drag = {
        t: cursor.t,
        y$: cursor.y$
      };
      this.pins.forEach(function (x) {
        return x.rec_position();
      });
    },
    drag_update: function drag_update() {
      var dt = this.$props.cursor.t - this.drag.t;
      var dy = this.$props.cursor.y$ - this.drag.y$;
      this.pins.forEach(function (x) {
        return x.update_from([x.t1 + dt, x.y$1 + dy], true);
      });
    }
  },
  computed: {
    // Settings starting with $ are reserved
    selected: function selected() {
      return this.$props.settings.$selected;
    },
    state: function state() {
      return this.$props.settings.$state;
    }
  }
});
;// CONCATENATED MODULE: ./src/stuff/icons.json
const icons_namespaceObject = JSON.parse('{"extended.png":"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABkAAAAZAQMAAAD+JxcgAAAAAXNSR0IB2cksfwAAAAlwSFlzAAALEwAACxMBAJqcGAAAAAZQTFRFAAAATU1NkJ+rOQAAAAJ0Uk5TAP9bkSK1AAAANElEQVR4nGNggABGEMEEIlhABAeI+AASF0AlHmAqA4kzKAAx8wGQuAMKwd6AoYzBAWonAwAcLwTgNfJ3RQAAAABJRU5ErkJggg==","ray.png":"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABkAAAAZAQMAAAD+JxcgAAAAAXNSR0IB2cksfwAAAAlwSFlzAAALEwAACxMBAJqcGAAAAAZQTFRFAAAATU1NkJ+rOQAAAAJ0Uk5TAP9bkSK1AAAAMklEQVR4nGNgQAJMIIIFRHCACAEQoQAiHICYvQEkjkrwYypjAIkzwk2zAREuqIQFzD4AE3kE4BEmGggAAAAASUVORK5CYII=","segment.png":"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABkAAAAZAgMAAAC5h23wAAAAAXNSR0IB2cksfwAAAAlwSFlzAAALEwAACxMBAJqcGAAAAAlQTFRFAAAATU1NJCQkCxcHIQAAAAN0Uk5TAP8SmutI5AAAACxJREFUeJxjYMACGAMgNAsLdpoVKi8AVe8A1QblQlWRKt0AoULw2w1zGxoAABdiAviQhF/mAAAAAElFTkSuQmCC","add.png":"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACoAAAAqCAMAAADyHTlpAAAAAXNSR0IB2cksfwAAAAlwSFlzAAALEwAACxMBAJqcGAAAAH5QTFRFAAAAAAAAAAAAAAAAAAAAAAAAAAAACgoKBgYGGxsbKioqPz8/Pj4+BQUFCQkJAQEBZGRkh4eHAgICEBAQNjY2g4ODgYGBAAAAAwMDeXl5d3d3GBgYERERgICAgICANDQ0PDw8Y2NjCAgIhYWFGhoaJycnOjo6YWFhgICAdXV14Y16sQAAACp0Uk5TAAILDxIKESEnJiYoKCgTKSkpKCAnKSkFKCkpJiDl/ycpKSA2JyYpKSkpOkQ+xgAAARdJREFUeJzllNt2gyAQRTWiRsHLoDU0GpPYmMv//2BMS+sgl6Z9bM8bi73gnJkBz/sn8lcBIUHofwtG8TpJKUuTLI6cYF7QEqRKynP71VX9AkhNXVlsbMQrLLQVGyPZLsGHWgPrCxMJwHUPlXa79NBp2et5d9f3u3m1XxatQNn7SagOXCUjCjYUDuqxcWlHj4MSfw12FDJchFViRN8+1qcQoUH6lR1L1mEMEErofB6WzEUwylzomfzOQGiOJdXiWH7mQoUyMa4WXJQWOBvLFvPCGxt6FSr5kyH0qi0YddNG2/pgCsOjff4ZTizXPNwKIzl56OoGg9d9Z/+5cs6On+CFCfevFQ3ZaTycx1YMbvDdRvjkp/lHdAcPXzokxcwfDwAAAABJRU5ErkJggg==","cursor.png":"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABkAAAAZAgMAAAC5h23wAAAAAXNSR0IB2cksfwAAAAlwSFlzAAALEwAACxMBAJqcGAAAAAxQTFRFAAAATU1NTU1NTU1NwlMHHwAAAAR0Uk5TAOvhxbpPrUkAAAAkSURBVHicY2BgYHBggAByabxg1WoGBq2pRCk9AKUbcND43AEAufYHlSuusE4AAAAASUVORK5CYII=","display_off.png":"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACoAAAAqCAMAAADyHTlpAAAAAXNSR0IB2cksfwAAAAlwSFlzAAALEwAACxMBAJqcGAAAAU1QTFRFAAAAh4eHh4eHAAAAAAAAAAAAAwMDAAAAAAAAhoaGGBgYgYGBAAAAPz8/AgICg4ODCQkJhISEh4eHh4eHPj4+NjY2gYGBg4ODgYGBgYGBgoKCAQEBJycngoKChYWFEBAQg4ODCAgIKioqZGRkCgoKBQUFERERd3d3gYGBGxsbNDQ0hISEgYGBPDw8gYGBgYGBh4eHh4eHhYWFh4eHgoKChYWFgYGBgYGBg4ODhoaGg4ODYWFhgoKCBgYGdXV1goKCg4ODgYGBgICAgYGBAAAAg4ODhYWFhISEh4eHgoKChYWFOjo6goKCGhoah4eHh4eHh4eHgoKCh4eHeXl5hoaGgoKChISEgYGBgYGBgoKCY2NjgYGBgoKCh4eHgoKCgYGBhoaGg4ODhoaGhYWFh4eHgYGBhoaGhoaGhoaGg4ODgoKChISEgoKChYWFh4eHfKktUwAAAG90Uk5TACn/AhEFKA8SLCbxCigoVBNKUTYoJ/lh3PyAKSaTNiBtICYpISggKSkmJ0LEKef3lGxA8rn//+pcMSkpnCcptHPJKe0LUjnx5LzKKaMnX73hl64pLnhkzNSgKeLv17LQ+liIzaLe7PfTw5tFpz3K1fXR/gAAAgBJREFUeJzllNdXwjAUxknB0lIoCKVsGTIFQRAZ7r333nuv///R3LZ4mlDQZ/0ekp7b37n5bnITk+mfyDxv5Tir3fwjaElO5BIOKZFLJS1dQVfI0Y809TtEV+elo95RpFPWG+1go4fdQ5QybI8haaNBkM2ANbM09bnrwaPY7iFKrz7EMBdu7CHdVruXIt0M1hb+GKA3LTRKkp5lTA6Dg6xIkhaHhvQ1IlW/UCouQdJNJTRIpk1qO7+wUpcfpl537oBc7VNip3Gi/AmVPBAC1UrL6HXtSGVT+k2Yz0Focad07OMRf3P5BEbd63PFQx7HN+w61JoAm+uBlV48O/0jkLSMmtPCmQ8HwlYdykFV4/LJPp7e3hVyFdapHNehLk6PSjhSkBvwu/cFyJGIYvOyhoc1jjYQFGbygD4CWjoAMla/og3YoSw+KPhjPNoFcim4iFD+pFYA8zZ9WeYU5OBjZ3ORWyCfG03E+47kKpCIJTpGO4KP8XMgtw990xG/PBNTgmPEEXwf7P42oOdFIRAoBCtqTKL6Rcwq4Xsgh5xYC/mmSs6yJKk1YbnVeTq1NaEpmlHbmVn2EORkW2trF2ZzmHGTSUMGl1a9hp4ySRpdQ8yKGURpMmRIYg9pb1YPzg6kO79cLlE6bYFjEtv91bLEUxvhwbWwjY13BxUb9l8+mn9EX8x3Nki8ff5wAAAAAElFTkSuQmCC","display_on.png":"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACoAAAAqCAMAAADyHTlpAAAAAXNSR0IB2cksfwAAAAlwSFlzAAALEwAACxMBAJqcGAAAAR1QTFRFAAAAh4eHgYGBAAAAAAAAgYGBAAAAAwMDAAAAAAAAgYGBg4ODGBgYgYGBhISEAAAAPz8/AgIChoaGCQkJhYWFPj4+NjY2goKCgYGBAQEBJycngYGBgoKCEBAQCAgIhISEKioqZGRkCgoKBQUFERERd3d3gYGBg4ODgYGBGxsbNDQ0hISEgoKCgoKChYWFPDw8gYGBgYGBhoaGgoKCg4ODgoKCgYGBgoKCgoKCgoKCg4ODgoKChoaGgoKCgYGBhoaGg4ODYWFhBgYGdXV1gYGBg4ODgoKCgICAg4ODg4ODhISEAAAAg4ODOjo6gYGBGhoaeXl5goKCgYGBgoKChYWFgoKChISEgoKCY2NjgYGBg4ODgYGBgYGBg4ODgYGBo8n54AAAAF90Uk5TACn/AhH3BSgPEuhUJvFACigoLBM2KCeA6ykm+pMgIEkmKSEoICn9XCkmJ0u6nDop4sUypGuEzLZ6vmCYLZ/dLykpJynUYa8pcllCC1Ip2ycpisl1PadFsintbsPQZdi/bTW7AAAB4UlEQVR4nOWUZ1fCMBSGSSGWFiq0UDbIkr2XbBwMxS0b1P//M0xK9XSiftX7oel585zkvfcmMRj+SRhvzRRlthm/BU3Ry3TYzofTsajpIOjw2iNAjIiddehvHXSdA0mkXEEdG0fkE1DEKXmkSVqVIA6rBmsktUgAWLWHoGp30UNclbtLmwQgoyya91wPTbFy0mQXJ5zJQO6BgXRjfH0iSkX5stHIXr5r0bB/lu8syjR8rzsFbR2SpX+5J2eMP3csLtYsEY2K8BeTFuE2jaVCBw7bHOBuxq16AXmpbui3LtIfbRLUHMY2q4lcFo2WB4KA1SUAlWumNEKCzyxBKZxVHvYGaFguCBx1vM/x0IPzoqQoj5SdP4mns2cCGhBsrgj0uaeUBtzMyxQN8w4mYROTW8+r0oANp8W5mf6WQw5aCYJ2o7ymPaKMi2uVpmWM4TW6tdImgGo1bT4nK6DbbsCc0AZSdmLEFszzHrh6riVvRrNA3/9SE8QLWQu+Gjto9+gE9NBMwr9zi83gFeeFTe11zpm1CHE3HeyVCSknf3MIDcFTbfJKdbR1L4xX49L+/BoillV5uPJqkshD3JWSgpNMXP/lcrD8+hO84MnDr5YpFHv0Fe99VjJ0GBRs2H74aP6R+ACr+TFvZNAQ1wAAAABJRU5ErkJggg==","down.png":"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACoAAAAqCAMAAADyHTlpAAAAAXNSR0IB2cksfwAAAKVQTFRFAAAAg4ODgICAAAAAAAAAAAAACAgIAAAAAAAAAAAAAAAAOTk5hYWFEBAQfHx8ODg4dnZ2NDQ0XV1dGxsbKCgogICAFBQUIiIiZGRkgICAgICAFRUVAAAAgICAgICAgICAf39/Li4ugICAcHBwgoKCgICAgoKCgICAg4ODgYGBPj4+goKCgICAhISEgYGBgICAgoKCgICAgYGBgYGBf39/gICAgICAIdPQHAAAADd0Uk5TACn/KAIRIBMFDwooKyApKSknKSYmzCcmKfL7JRCUi2L3J7IpcLUrr0VbKXntNEnkMbxrUcG56CMpi50AAAFZSURBVHic5ZRpf4MgDIeFKFatWm/tfW091u7evv9Hm1Acoujm2y0vFPH5Jf+EEE37J6bblmlatv4jaBCI4rMfR0CMXtAEJ0fccgfM7tAkQHXzArdDxggmqGETGCnJWROkNlOwOqhIhKCtgbSicw1uK/dATSK0aRatIzytA8ik4XSiyJnLSm+VPxULgeyLI3uHRJH+qcB4WZGrKb4c20WwI7b3iUt74OS6XD+xZWrXUCtme0uKTvfcJ65CZFa9VOebqwXmft+oT8yF+/VymT4XeGB+Xx8L+j4gBcoFIDT+oMz6Qp93Y74pCeBpUXaLuW0rUk6r1iv3nP322ewYkgv2nZIvgpSPQDrY5wTjRJDNg9XAE/+uSXIVX812GdKEmtvR2rtWaw+5MAOuofJy79SXu9TgBl4d9DZdI0NjgyiswNCB/qk1J5Bmvp+lQOa9IJNhW4bxm6H5R+wLQYMSQXZNzbcAAAAASUVORK5CYII=","price_range.png":"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABkAAAAZAQMAAAD+JxcgAAAAAXNSR0IB2cksfwAAAAlwSFlzAAALEwAACxMBAJqcGAAAAAZQTFRFAAAATU1NkJ+rOQAAAAJ0Uk5TAP9bkSK1AAAAIUlEQVR4nGNggAPm/w9gTA4QIQMitECEJ1yMEgLNDiAAADfgBMRu78GgAAAAAElFTkSuQmCC","price_time.png":"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABkAAAAZAQMAAAD+JxcgAAAAAXNSR0IB2cksfwAAAAlwSFlzAAALEwAACxMBAJqcGAAAAAZQTFRFAAAATU1NkJ+rOQAAAAJ0Uk5TAP9bkSK1AAAAOklEQVR4nGNggAPm/w9gTA4QIQPEClpMQMITRHCACScQoQQihBgY9P//grKgYk5wdTACYhQHFjuAAABZFAlc4e1fcQAAAABJRU5ErkJggg==","remove.png":"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACoAAAAqCAMAAADyHTlpAAAAAXNSR0IB2cksfwAAAAlwSFlzAAALEwAACxMBAJqcGAAAAK5QTFRFAAAAh4eHgICAAAAAAAAAh4eHAAAAAwMDAAAAAAAAgICAGBgYAAAAPz8/AgICgICACQkJhoaGhoaGgICAPj4+NjY2gYGBg4ODgYGBAQEBJycngoKCEBAQgICAgICACAgIKioqZGRkCgoKBQUFERERd3d3gYGBGxsbNDQ0gICAPDw8YWFhBgYGdXV1gICAg4ODgICAAAAAOjo6GhoaeXl5gICAhYWFY2NjhYWFgICA9O0oCgAAADp0Uk5TACn/AhErBSgPEvEmCigowxMuMcgoJ7hWrCkmdCD6vSAmKSEoICkpJie6KSknKSkp0wspJynCMik11rrLte8AAAFwSURBVHic5ZTXkoIwFIZNAAPSpKkoRQV7Wcva3v/FFiRmEwise7t7bs7MP98k/ylJq/VPQjjKiiJrwo+gON0uxro7XiRTsRHs+voE4JjoRrf+6sD7AFTMvaDGRht9glLMUJtLqmUwD5XDCohHAmBUPQSV27GHtFK7xycBWJab5uPaR+Hlmue7GfZxHwyWFHVMQghXFgD2A8IOZtfssdNJIXcyFEaSfchzp9BuMVP+Fhvr5Qh0nGfqYTGhm3BcYFUaQBKOhMWzRqHyGFRY03ppQ5lCFZ30RloVZGQTaa3QqEt0OyrQnkSkk8I1YJkvAwPCMgY0UpbzXRZhVbosIWGbZTLNQszGMCM42FJEjWDDjIAMtp+xj6x2K+/DqNDc0r4Yc8yGl3uer2aIyT1iyd8sYSuY8cldZbVrH4zPebTvP8OMNSoedj6XzDyk3pwG98u0/ufqGu7tBW5c1PxriXFyHq5PQxXFzeDThvbmp/lH4gt6WxfZ03H8DwAAAABJRU5ErkJggg==","settings.png":"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACoAAAAqCAMAAADyHTlpAAAAAXNSR0IB2cksfwAAAAlwSFlzAAALEwAACxMBAJqcGAAAAW5QTFRFAAAAAAAAAAAAAAAAAAAAAAAAAAAACgoKBgYGGxsbKioqQEBAPj4+BQUFCAgIAQEBPz8/ZWVlh4eHZGRkAgICCQkJDw8PNjY2g4ODgoKCNTU1EBAQAAAAAwMDeXl5d3d3AAAAGBgYAAAAERERioqKgoKCgoKCgoKCgYGBgoKChISEhoaGNDQ0g4ODgICAgICAgICAgYGBgYGBhYWFgICAgICAPT09AAAAgYGBgICAgICAgICAgICAY2NjCAgIgICAgICAhYWFhYWFgYGBHBwcgICAhYWFGhoagYGBgYGBg4ODhoaGJycnAAAAhISEgICAg4ODPDw8AAAAgoKCgICAhISEOjo6h4eHgoKCgYGBgICAf39/gYGBgoKCgICAGBgYgYGBg4ODg4ODgICACwsLgYGBgICAgYGBgYGBgYGBgICAgYGBYWFhf39/g4ODPj4+gYGBg4ODgICAhYWFgoKCgYGBgICAgYGBgoKCdXV1T0kC9QAAAHp0Uk5TAAILDxMKESEnJiYpKSgTKSgpKSkoEyAnKSknIAYoKSkFJQEgKl94jYVvVC4nU9f/+K8pOu71KBCi3NPq/ikg0e01Nokm1UUnsZVqQSYOT9lrKRJz5lIpK12jyu+sesgnhGVLxCG55a6Um+GaKfJCKKRgKUt8ocergymDQ9knAAABsElEQVR4nOWUV1vCMBSGg1AQpBZrcVdE3KJxo4LgnuCoe4F7orjHv7doTk3bgF7rd5OnX94nZ+SkCP0TWQqsNpuVs/wI2h2FTleR2+XkHfa8YLHgKRGJSj2SN3fosvIKkVJlVXWONGrkWtEgn1zHJP1GMCs/g7XILFIUpXoTWmaKTnIImGovh72Gxqbmlta2dvgOGpsmQO0dnfhTXd3E6JH0pN1DNnr7MFE/HDsQ0qEO6Pxg9sCh4XDkGx2J6sovBD+G8eiYuo5PxLTKeLoJBZNgT2EcnjY0YYajUKsL7Fk1gcjU3PwChcYTFGorAnsRqlpa1tAVhUbdmr+6RtjIOlgbCjMBUdzc2t7ZzbJ7zAQ4p6GSfRVNwkeKLsvCg31w2JBdjlT0GDxZNzEnpcQ+xWfnFxeXVyp6Tay07gq+L/YUOoBvbomV0V8skiq//DutWfeEfJD1JPLCED4+Pb8kX986tApNQ4iqfSJT76bRzvlgBPODQXW/foYqK5lyeBeYJEL1gaoeGnwIBhjRoQ9SZgTAdEbO/9cKRfmZ+MpGPCVHQ3nBzzS4hKIkuNyh/5g+ALiAXSSas9hwAAAAAElFTkSuQmCC","time_range.png":"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABkAAAAZAQMAAAD+JxcgAAAAAXNSR0IB2cksfwAAAAlwSFlzAAALEwAACxMBAJqcGAAAAAZQTFRFAAAATU1NkJ+rOQAAAAJ0Uk5TAP9bkSK1AAAAJElEQVR4nGNgwAsUGJhQCScQoQQihBgY9P//grKgYk4YOvACACOpBKG6Svj+AAAAAElFTkSuQmCC","trash.png":"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABkAAAAZAQMAAAD+JxcgAAAAAXNSR0IB2cksfwAAAAlwSFlzAAALEwAACxMBAJqcGAAAAAZQTFRFAAAATU1NkJ+rOQAAAAJ0Uk5TAP9bkSK1AAAALUlEQVR4nGNgAIN6ENHQACX4//9gYBBgYIESYC4LkA0lPEkmGFAI5v8PILYCAHygDJxlK0RUAAAAAElFTkSuQmCC","up.png":"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACoAAAAqCAMAAADyHTlpAAAAAXNSR0IB2cksfwAAAAlwSFlzAAALEwAACxMBAJqcGAAAAMZQTFRFAAAAh4eHgICAAAAAAAAAAAAAAwMDAAAAAAAAGBgYAAAAPz8/AgICCQkJgICAh4eHPj4+NjY2AQEBJycnEBAQgICAgICACAgIKioqZGRkCgoKBQUFgYGBERERd3d3gYGBGxsbNDQ0gICAgYGBPDw8gYGBh4eHgICAYWFhBgYGgYGBdXV1goKCg4ODhYWFgICAgoKCAAAAhISEOjo6gICAGhoagYGBeXl5hoaGgICAY2Njg4ODgoKCgoKCgYGBgoKCg4ODgoKC64uw1gAAAEJ0Uk5TACn/AhEFKA8SJgooKBP7KignKSYg9c0gJikhKLQgKSkmJ7ywKY8s5SknlClxKTMpXwtFKe0neiku8ClKWmSbbFFjM5GHSgAAAW5JREFUeJzllGd/gjAQxk3AMFWWOHDvVa2rVbu//5cqhJWQQO3b9nkVjv/v7rnLKJX+iYS9JMuSKvwIiu3loKkZzYHXFgvBiqW1QKSWplfySzvmAyDUN50cG2X0DDLqoTKXVLJgIIXDCohHAqCzHhymeuShy/Ru8kkAhtmhWUTvW9fdEnPQaVLU0n8XF0L3kn5P6LTtZPKgNoK+RrUkcGtQ7S9TsgOxxinrkUPYD+LwLCIh7CTsWSVQqRmTuPqpitlZFLQlApXjrsYBc335wOw47ksmUSMMrgKi/gnAE/awCqNHmTUwDf5X34LlBuedsgbUsK15kPMxTIXzzvFSIdsSPBw7nGD1K+7bL3F9xStEnZhoCw71TbpL71GBBbUF1MZmZWTOi97PI3eIJn9zCEtOj0+umaOde2EszqW9/xr6rM54WFtc0vfQNak57Ibd/Jerohu3GFwYqPjVEhve2Z4cbQU1ikFsQ73z0fwj+ga3VBezGuggFQAAAABJRU5ErkJggg=="}');
;// CONCATENATED MODULE: ./node_modules/@babel/runtime/helpers/esm/defineProperty.js
function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}
;// CONCATENATED MODULE: ./src/components/primitives/pin.js



// Semi-automatic pin object. For stretching things.


var Pin = /*#__PURE__*/function () {
  // (Comp reference, a name in overlay settings,
  // pin parameters)
  function Pin(comp, name, params) {
    var _this = this;

    if (params === void 0) {
      params = {};
    }

    classCallCheck_classCallCheck(this, Pin);

    this.RADIUS = comp.$props.config.PIN_RADIUS || 5.5;
    this.RADIUS_SQ = Math.pow(this.RADIUS + 7, 2);

    if (utils.is_mobile) {
      this.RADIUS += 2;
      this.RADIUS_SQ *= 2.5;
    }

    this.COLOR_BACK = comp.$props.colors.back;
    this.COLOR_BR = comp.$props.colors.text;
    this.comp = comp;
    this.layout = comp.layout;
    this.mouse = comp.mouse;
    this.name = name;
    this.state = params.state || 'settled';
    this.hidden = params.hidden || false;
    this.mouse.on('mousemove', function (e) {
      return _this.mousemove(e);
    });
    this.mouse.on('mousedown', function (e) {
      return _this.mousedown(e);
    });
    this.mouse.on('mouseup', function (e) {
      return _this.mouseup(e);
    });

    if (comp.state === 'finished') {
      this.state = 'settled';
      this.update_from(comp.$props.settings[name]);
    } else {
      this.update();
    }

    if (this.state !== 'settled') {
      this.comp.$emit('scroll-lock', true);
    }
  }

  createClass_createClass(Pin, [{
    key: "re_init",
    value: function re_init() {
      this.update_from(this.comp.$props.settings[this.name]);
    }
  }, {
    key: "draw",
    value: function draw(ctx) {
      if (this.hidden) return;

      switch (this.state) {
        case 'tracking':
          break;

        case 'dragging':
          if (!this.moved) this.draw_circle(ctx);
          break;

        case 'settled':
          this.draw_circle(ctx);
          break;
      }
    }
  }, {
    key: "draw_circle",
    value: function draw_circle(ctx) {
      this.layout = this.comp.layout;

      if (this.comp.selected) {
        var r = this.RADIUS,
            lw = 1.5;
      } else {
        var r = this.RADIUS * 0.95,
            lw = 1;
      }

      ctx.lineWidth = lw;
      ctx.strokeStyle = this.COLOR_BR;
      ctx.fillStyle = this.COLOR_BACK;
      ctx.beginPath();
      ctx.arc(this.x = this.layout.t2screen(this.t), this.y = this.layout.$2screen(this.y$), r + 0.5, 0, Math.PI * 2, true);
      ctx.fill();
      ctx.stroke();
    }
  }, {
    key: "update",
    value: function update() {
      this.y$ = this.comp.$props.cursor.y$;
      this.y = this.comp.$props.cursor.y;
      this.t = this.comp.$props.cursor.t;
      this.x = this.comp.$props.cursor.x; // Save pin as time in IB mode
      //if (this.layout.ti_map.ib) {
      //    this.t = this.layout.ti_map.i2t(this.t )
      //}
      // Reset the settings attahed to the pin (position)

      this.comp.$emit('change-settings', _defineProperty({}, this.name, [this.t, this.y$]));
    }
  }, {
    key: "update_from",
    value: function update_from(data, emit) {
      if (emit === void 0) {
        emit = false;
      }

      if (!data) return;
      this.layout = this.comp.layout;
      this.y$ = data[1];
      this.y = this.layout.$2screen(this.y$);
      this.t = data[0];
      this.x = this.layout.t2screen(this.t); // TODO: Save pin as time in IB mode
      //if (this.layout.ti_map.ib) {
      //    this.t = this.layout.ti_map.i2t(this.t )
      //}

      if (emit) this.comp.$emit('change-settings', _defineProperty({}, this.name, [this.t, this.y$]));
    }
  }, {
    key: "rec_position",
    value: function rec_position() {
      this.t1 = this.t;
      this.y$1 = this.y$;
    }
  }, {
    key: "mousemove",
    value: function mousemove(event) {
      switch (this.state) {
        case 'tracking':
        case 'dragging':
          this.moved = true;
          this.update();
          break;
      }
    }
  }, {
    key: "mousedown",
    value: function mousedown(event, force) {
      if (force === void 0) {
        force = false;
      }

      if (utils.default_prevented(event) && !force) return;

      switch (this.state) {
        case 'tracking':
          this.state = 'settled';
          if (this.on_settled) this.on_settled();
          this.comp.$emit('scroll-lock', false);
          break;

        case 'settled':
          if (this.hidden) return;

          if (this.hover()) {
            this.state = 'dragging';
            this.moved = false;
            this.comp.$emit('scroll-lock', true);
            this.comp.$emit('object-selected');
          }

          break;
      }

      if (this.hover()) {
        event.preventDefault();
      }
    }
  }, {
    key: "mouseup",
    value: function mouseup(event) {
      switch (this.state) {
        case 'dragging':
          this.state = 'settled';
          if (this.on_settled) this.on_settled();
          this.comp.$emit('scroll-lock', false);
          break;
      }
    }
  }, {
    key: "on",
    value: function on(name, handler) {
      switch (name) {
        case 'settled':
          this.on_settled = handler;
          break;
      }
    }
  }, {
    key: "hover",
    value: function hover() {
      var x = this.x;
      var y = this.y;
      return (x - this.mouse.x) * (x - this.mouse.x) + (y - this.mouse.y) * (y - this.mouse.y) < this.RADIUS_SQ;
    }
  }]);

  return Pin;
}();


;// CONCATENATED MODULE: ./src/components/primitives/seg.js


// Draws a segment, adds corresponding collision f-n



var Seg = /*#__PURE__*/function () {
  // Overlay ref, canvas ctx
  function Seg(overlay, ctx) {
    classCallCheck_classCallCheck(this, Seg);

    this.ctx = ctx;
    this.comp = overlay;
    this.T = overlay.$props.config.TOOL_COLL;
    if (utils.is_mobile) this.T *= 2;
  } // p1[t, $], p2[t, $] (time-price coordinates)


  createClass_createClass(Seg, [{
    key: "draw",
    value: function draw(p1, p2) {
      var layout = this.comp.$props.layout;
      var x1 = layout.t2screen(p1[0]);
      var y1 = layout.$2screen(p1[1]);
      var x2 = layout.t2screen(p2[0]);
      var y2 = layout.$2screen(p2[1]);
      this.ctx.moveTo(x1, y1);
      this.ctx.lineTo(x2, y2);
      this.comp.collisions.push(this.make([x1, y1], [x2, y2]));
    } // Collision function. x, y - mouse coord.

  }, {
    key: "make",
    value: function make(p1, p2) {
      var _this = this;

      return function (x, y) {
        return math.point2seg([x, y], p1, p2) < _this.T;
      };
    }
  }]);

  return Seg;
}();


;// CONCATENATED MODULE: ./src/components/primitives/line.js


// Draws a line, adds corresponding collision f-n



var Line = /*#__PURE__*/function () {
  // Overlay ref, canvas ctx
  function Line(overlay, ctx) {
    classCallCheck_classCallCheck(this, Line);

    this.ctx = ctx;
    this.comp = overlay;
    this.T = overlay.$props.config.TOOL_COLL;
    if (utils.is_mobile) this.T *= 2;
  } // p1[t, $], p2[t, $] (time-price coordinates)


  createClass_createClass(Line, [{
    key: "draw",
    value: function draw(p1, p2) {
      var layout = this.comp.$props.layout;
      var x1 = layout.t2screen(p1[0]);
      var y1 = layout.$2screen(p1[1]);
      var x2 = layout.t2screen(p2[0]);
      var y2 = layout.$2screen(p2[1]);
      this.ctx.moveTo(x1, y1);
      this.ctx.lineTo(x2, y2);
      var w = layout.width;
      var h = layout.height; // TODO: transform k (angle) to screen ratio
      // (this requires a new a2screen function)

      var k = (y2 - y1) / (x2 - x1);
      var s = Math.sign(x2 - x1 || y2 - y1);
      var dx = w * s * 2;
      var dy = w * k * s * 2;

      if (dy === Infinity) {
        dx = 0, dy = h * s;
      }

      this.ctx.moveTo(x2, y2);
      this.ctx.lineTo(x2 + dx, y2 + dy);

      if (!this.ray) {
        this.ctx.moveTo(x1, y1);
        this.ctx.lineTo(x1 - dx, y1 - dy);
      }

      this.comp.collisions.push(this.make([x1, y1], [x2, y2]));
    } // Collision function. x, y - mouse coord.

  }, {
    key: "make",
    value: function make(p1, p2) {
      var _this = this;

      var f = this.ray ? math.point2ray.bind(math) : math.point2line.bind(math);
      return function (x, y) {
        return f([x, y], p1, p2) < _this.T;
      };
    }
  }]);

  return Line;
}();


;// CONCATENATED MODULE: ./node_modules/@babel/runtime/helpers/esm/setPrototypeOf.js
function _setPrototypeOf(o, p) {
  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
    o.__proto__ = p;
    return o;
  };

  return _setPrototypeOf(o, p);
}
;// CONCATENATED MODULE: ./node_modules/@babel/runtime/helpers/esm/inherits.js

function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }

  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      writable: true,
      configurable: true
    }
  });
  if (superClass) _setPrototypeOf(subClass, superClass);
}
;// CONCATENATED MODULE: ./node_modules/@babel/runtime/helpers/esm/typeof.js
function typeof_typeof(obj) {
  "@babel/helpers - typeof";

  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    typeof_typeof = function _typeof(obj) {
      return typeof obj;
    };
  } else {
    typeof_typeof = function _typeof(obj) {
      return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
    };
  }

  return typeof_typeof(obj);
}
;// CONCATENATED MODULE: ./node_modules/@babel/runtime/helpers/esm/assertThisInitialized.js
function _assertThisInitialized(self) {
  if (self === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }

  return self;
}
;// CONCATENATED MODULE: ./node_modules/@babel/runtime/helpers/esm/possibleConstructorReturn.js


function _possibleConstructorReturn(self, call) {
  if (call && (typeof_typeof(call) === "object" || typeof call === "function")) {
    return call;
  }

  return _assertThisInitialized(self);
}
;// CONCATENATED MODULE: ./node_modules/@babel/runtime/helpers/esm/getPrototypeOf.js
function _getPrototypeOf(o) {
  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
    return o.__proto__ || Object.getPrototypeOf(o);
  };
  return _getPrototypeOf(o);
}
;// CONCATENATED MODULE: ./src/components/primitives/ray.js





function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

// Draws a ray, adds corresponding collision f-n


var Ray = /*#__PURE__*/function (_Line) {
  _inherits(Ray, _Line);

  var _super = _createSuper(Ray);

  function Ray(overlay, ctx) {
    var _this;

    classCallCheck_classCallCheck(this, Ray);

    _this = _super.call(this, overlay, ctx);
    _this.ray = true;
    return _this;
  }

  return Ray;
}(Line);


;// CONCATENATED MODULE: ./node_modules/babel-loader/lib/index.js!./node_modules/vue-loader/lib/index.js??vue-loader-options!./src/components/overlays/LineTool.vue?vue&type=script&lang=js&
// Line drawing tool
// TODO: make an angle-snap when "Shift" is pressed







/* harmony default export */ const LineToolvue_type_script_lang_js_ = ({
  name: 'LineTool',
  mixins: [overlay, tool],
  methods: {
    meta_info: function meta_info() {
      return {
        author: 'C451',
        version: '1.1.0'
      };
    },
    tool: function tool() {
      return {
        // Descriptor for the tool
        group: 'Lines',
        icon: icons_namespaceObject["segment.png"],
        type: 'Segment',
        hint: 'This hint will be shown on hover',
        data: [],
        // Default data
        settings: {},
        // Default settings
        // Modifications
        mods: {
          'Extended': {
            // Rewrites the default setting fields
            settings: {
              extended: true
            },
            icon: icons_namespaceObject["extended.png"]
          },
          'Ray': {
            // Rewrites the default setting fields
            settings: {
              ray: true
            },
            icon: icons_namespaceObject["ray.png"]
          }
        }
      };
    },
    // Called after overlay mounted
    init: function init() {
      var _this = this;

      // First pin is settled at the mouse position
      this.pins.push(new Pin(this, 'p1')); // Second one is following mouse until it clicks

      this.pins.push(new Pin(this, 'p2', {
        state: 'tracking'
      }));
      this.pins[1].on('settled', function () {
        // Call when current tool drawing is finished
        // (Optionally) reset the mode back to 'Cursor'
        _this.set_state('finished');

        _this.$emit('drawing-mode-off');
      });
    },
    draw: function draw(ctx) {
      if (!this.p1 || !this.p2) return;
      ctx.lineWidth = this.line_width;
      ctx.strokeStyle = this.color;
      ctx.beginPath();

      if (this.sett.ray) {
        new Ray(this, ctx).draw(this.p1, this.p2);
      } else if (this.sett.extended) {
        new Line(this, ctx).draw(this.p1, this.p2);
      } else {
        new Seg(this, ctx).draw(this.p1, this.p2);
      }

      ctx.stroke();
      this.render_pins(ctx);
    },
    use_for: function use_for() {
      return ['LineTool'];
    },
    data_colors: function data_colors() {
      return [this.color];
    }
  },
  // Define internal setting & constants here
  computed: {
    sett: function sett() {
      return this.$props.settings;
    },
    p1: function p1() {
      return this.$props.settings.p1;
    },
    p2: function p2() {
      return this.$props.settings.p2;
    },
    line_width: function line_width() {
      return this.sett.lineWidth || 0.9;
    },
    color: function color() {
      return this.sett.color || '#42b28a';
    }
  },
  data: function data() {
    return {};
  }
});
;// CONCATENATED MODULE: ./src/components/overlays/LineTool.vue?vue&type=script&lang=js&
 /* harmony default export */ const overlays_LineToolvue_type_script_lang_js_ = (LineToolvue_type_script_lang_js_); 
;// CONCATENATED MODULE: ./src/components/overlays/LineTool.vue
var LineTool_render, LineTool_staticRenderFns
;



/* normalize component */
;
var LineTool_component = normalizeComponent(
  overlays_LineToolvue_type_script_lang_js_,
  LineTool_render,
  LineTool_staticRenderFns,
  false,
  null,
  null,
  null
  
)

/* hot reload */
if (false) { var LineTool_api; }
LineTool_component.options.__file = "src/components/overlays/LineTool.vue"
/* harmony default export */ const LineTool = (LineTool_component.exports);
;// CONCATENATED MODULE: ./node_modules/babel-loader/lib/index.js!./node_modules/vue-loader/lib/index.js??vue-loader-options!./src/components/overlays/RangeTool.vue?vue&type=script&lang=js&

// Price/Time measurment tool





/* harmony default export */ const RangeToolvue_type_script_lang_js_ = ({
  name: 'RangeTool',
  mixins: [overlay, tool],
  methods: {
    meta_info: function meta_info() {
      return {
        author: 'C451',
        version: '2.0.1'
      };
    },
    tool: function tool() {
      return {
        // Descriptor for the tool
        group: 'Measurements',
        icon: icons_namespaceObject["price_range.png"],
        type: 'Price',
        hint: 'Price Range',
        data: [],
        // Default data
        settings: {},
        // Default settings
        mods: {
          'Time': {
            // Rewrites the default setting fields
            icon: icons_namespaceObject["time_range.png"],
            settings: {
              price: false,
              time: true
            }
          },
          'PriceTime': {
            // Rewrites the default setting fields
            icon: icons_namespaceObject["price_time.png"],
            settings: {
              price: true,
              time: true
            }
          },
          'ShiftMode': {
            // Rewrites the default setting fields
            settings: {
              price: true,
              time: true,
              shiftMode: true
            },
            hidden: true
          }
        }
      };
    },
    // Called after overlay mounted
    init: function init() {
      var _this = this;

      // First pin is settled at the mouse position
      this.pins.push(new Pin(this, 'p1', {
        hidden: this.shift
      })); // Second one is following mouse until it clicks

      this.pins.push(new Pin(this, 'p2', {
        state: 'tracking',
        hidden: this.shift
      }));
      this.pins[1].on('settled', function () {
        // Call when current tool drawing is finished
        // (Optionally) reset the mode back to 'Cursor'
        _this.set_state('finished');

        _this.$emit('drawing-mode-off'); // Deselect the tool in shiftMode


        if (_this.shift) _this._$emit('custom-event', {
          event: 'object-selected',
          args: []
        });
      });
    },
    draw: function draw(ctx) {
      if (!this.p1 || !this.p2) return;
      var dir = Math.sign(this.p2[1] - this.p1[1]);
      var layout = this.$props.layout;
      var xm = layout.t2screen((this.p1[0] + this.p2[0]) * 0.5);
      ctx.lineWidth = this.line_width;
      ctx.strokeStyle = this.color; // Background

      ctx.fillStyle = this.back_color;
      var x1 = layout.t2screen(this.p1[0]);
      var y1 = layout.$2screen(this.p1[1]);
      var x2 = layout.t2screen(this.p2[0]);
      var y2 = layout.$2screen(this.p2[1]);
      ctx.fillRect(x1, y1, x2 - x1, y2 - y1);
      if (this.price) this.vertical(ctx, x1, y1, x2, y2, xm);
      if (this.time) this.horizontal(ctx, x1, y1, x2, y2, xm);
      this.draw_value(ctx, dir, xm, y2);
      this.render_pins(ctx);
    },
    vertical: function vertical(ctx, x1, y1, x2, y2, xm) {
      var layout = this.$props.layout;
      var dir = Math.sign(this.p2[1] - this.p1[1]);
      ctx.beginPath();

      if (!this.shift) {
        // Top
        new Seg(this, ctx).draw([this.p1[0], this.p2[1]], [this.p2[0], this.p2[1]]); // Bottom

        new Seg(this, ctx).draw([this.p1[0], this.p1[1]], [this.p2[0], this.p1[1]]);
      } // Vertical Arrow


      ctx.moveTo(xm - 4, y2 + 5 * dir);
      ctx.lineTo(xm, y2);
      ctx.lineTo(xm + 4, y2 + 5 * dir);
      ctx.stroke(); // Vertical Line

      ctx.beginPath();
      ctx.setLineDash([5, 5]);
      new Seg(this, ctx).draw([(this.p1[0] + this.p2[0]) * 0.5, this.p2[1]], [(this.p1[0] + this.p2[0]) * 0.5, this.p1[1]]);
      ctx.stroke();
      ctx.setLineDash([]);
    },
    horizontal: function horizontal(ctx, x1, y1, x2, y2, xm) {
      var layout = this.$props.layout;
      var xdir = Math.sign(this.p2[0] - this.p1[0]);
      var ym = (layout.$2screen(this.p1[1]) + layout.$2screen(this.p2[1])) / 2;
      ctx.beginPath();

      if (!this.shift) {
        // Left
        new Seg(this, ctx).draw([this.p1[0], this.p1[1]], [this.p1[0], this.p2[1]]); // Right

        new Seg(this, ctx).draw([this.p2[0], this.p1[1]], [this.p2[0], this.p2[1]]);
      } // Horizontal Arrow


      ctx.moveTo(x2 - 5 * xdir, ym - 4);
      ctx.lineTo(x2, ym);
      ctx.lineTo(x2 - 5 * xdir, ym + 4);
      ctx.stroke(); // Horizontal Line

      ctx.beginPath();
      ctx.setLineDash([5, 5]);
      ctx.moveTo(x1, ym);
      ctx.lineTo(x2, ym);
      ctx.stroke();
      ctx.setLineDash([]);
    },
    // WTF? I know dude, a lot of shitty code here
    draw_value: function draw_value(ctx, dir, xm, y) {
      var _this2 = this;

      ctx.font = this.new_font; // Price delta (anf percent)

      var d$ = (this.p2[1] - this.p1[1]).toFixed(this.prec);
      var p = (100 * (this.p2[1] / this.p1[1] - 1)).toFixed(this.prec); // Map interval to the actual tf (in ms)

      var f = function f(t) {
        return _this2.layout.ti_map.smth2t(t);
      };

      var dt = f(this.p2[0]) - f(this.p1[0]);
      var tf = this.layout.ti_map.tf; // Bars count (through the candle index)

      var f2 = function f2(t) {
        var c = _this2.layout.c_magnet(t);

        var cn = _this2.layout.candles || _this2.layout.master_grid.candles;
        return cn.indexOf(c);
      }; // Bars count (and handling the negative values)


      var b = f2(this.p2[0]) - f2(this.p1[0]); // Format time delta
      // Format time delta

      var dtstr = this.t2str(dt);
      var text = [];
      if (this.price) text.push("".concat(d$, "  (").concat(p, "%)"));
      if (this.time) text.push("".concat(b, " bars, ").concat(dtstr));
      text = text.join('\n'); // "Multiple" fillText

      var lines = text.split('\n');
      var w = Math.max.apply(Math, _toConsumableArray(lines.map(function (x) {
        return ctx.measureText(x).width + 20;
      })).concat([100]));
      var n = lines.length;
      var h = 20 * n;
      ctx.fillStyle = this.value_back;
      ctx.fillRect(xm - w * 0.5, y - (10 + h) * dir, w, h * dir);
      ctx.fillStyle = this.value_color;
      ctx.textAlign = 'center';
      lines.forEach(function (l, i) {
        ctx.fillText(l, xm, y + (dir > 0 ? 20 * i - 20 * n + 5 : 20 * i + 25));
      });
    },
    // Formats time from ms to `1D 12h` for example
    t2str: function t2str(t) {
      var sign = Math.sign(t);
      var abs = Math.abs(t);
      var tfs = [[1000, 's', 60], [60000, 'm', 60], [3600000, 'h', 24], [86400000, 'D', 7], [604800000, 'W', 4], [2592000000, 'M', 12], [31536000000, 'Y', Infinity], [Infinity, 'Eternity', Infinity]];

      for (var i = 0; i < tfs.length; i++) {
        tfs[i][0] = Math.floor(abs / tfs[i][0]);

        if (tfs[i][0] === 0) {
          var p1 = tfs[i - 1];
          var p2 = tfs[i - 2];
          var txt = sign < 0 ? '-' : '';

          if (p1) {
            txt += p1.slice(0, 2).join('');
          }

          var n2 = p2 ? p2[0] - p1[0] * p2[2] : 0;

          if (p2 && n2) {
            txt += ' ';
            txt += "".concat(n2).concat(p2[1]);
          }

          return txt;
        }
      }
    },
    use_for: function use_for() {
      return ['RangeTool'];
    },
    data_colors: function data_colors() {
      return [this.color];
    }
  },
  // Define internal setting & constants here
  computed: {
    sett: function sett() {
      return this.$props.settings;
    },
    p1: function p1() {
      return this.$props.settings.p1;
    },
    p2: function p2() {
      return this.$props.settings.p2;
    },
    line_width: function line_width() {
      return this.sett.lineWidth || 0.9;
    },
    color: function color() {
      return this.sett.color || this.$props.colors.cross;
    },
    back_color: function back_color() {
      return this.sett.backColor || '#9b9ba316';
    },
    value_back: function value_back() {
      return this.sett.valueBack || '#9b9ba316';
    },
    value_color: function value_color() {
      return this.sett.valueColor || this.$props.colors.text;
    },
    prec: function prec() {
      return this.sett.precision || 2;
    },
    new_font: function new_font() {
      return '12px ' + this.$props.font.split('px').pop();
    },
    price: function price() {
      return 'price' in this.sett ? this.sett.price : true;
    },
    time: function time() {
      return 'time' in this.sett ? this.sett.time : false;
    },
    shift: function shift() {
      return this.sett.shiftMode;
    }
  },
  data: function data() {
    return {};
  }
});
;// CONCATENATED MODULE: ./src/components/overlays/RangeTool.vue?vue&type=script&lang=js&
 /* harmony default export */ const overlays_RangeToolvue_type_script_lang_js_ = (RangeToolvue_type_script_lang_js_); 
;// CONCATENATED MODULE: ./src/components/overlays/RangeTool.vue
var RangeTool_render, RangeTool_staticRenderFns
;



/* normalize component */
;
var RangeTool_component = normalizeComponent(
  overlays_RangeToolvue_type_script_lang_js_,
  RangeTool_render,
  RangeTool_staticRenderFns,
  false,
  null,
  null,
  null
  
)

/* hot reload */
if (false) { var RangeTool_api; }
RangeTool_component.options.__file = "src/components/overlays/RangeTool.vue"
/* harmony default export */ const RangeTool = (RangeTool_component.exports);
;// CONCATENATED MODULE: ./node_modules/babel-loader/lib/index.js!./node_modules/vue-loader/lib/index.js??vue-loader-options!./src/components/Grid.vue?vue&type=script&lang=js&
function Gridvue_type_script_lang_js_createForOfIteratorHelper(o, allowArrayLike) { var it; if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (it = Gridvue_type_script_lang_js_unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = o[Symbol.iterator](); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it["return"] != null) it["return"](); } finally { if (didErr) throw err; } } }; }

function Gridvue_type_script_lang_js_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return Gridvue_type_script_lang_js_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return Gridvue_type_script_lang_js_arrayLikeToArray(o, minLen); }

function Gridvue_type_script_lang_js_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

// Sets up all layers/overlays for the grid with 'grid_id'

















/* harmony default export */ const Gridvue_type_script_lang_js_ = ({
  name: 'Grid',
  props: ['sub', 'layout', 'range', 'interval', 'cursor', 'colors', 'overlays', 'width', 'height', 'data', 'grid_id', 'y_transform', 'font', 'tv_id', 'config', 'meta', 'shaders'],
  mixins: [canvas, uxlist],
  components: {
    Crosshair: components_Crosshair,
    KeyboardListener: KeyboardListener
  },
  created: function created() {
    var _this = this;

    // List of all possible overlays (builtin + custom)
    this._list = [Spline, Splines, Range, Trades, Channel, Segment, Candles, Volume, Splitters, LineTool, RangeTool].concat(this.$props.overlays);
    this._registry = {}; // We need to know which components we will use.
    // Custom overlay components overwrite built-ins:

    var tools = [];

    this._list.forEach(function (x, i) {
      var use_for = x.methods.use_for();
      if (x.methods.tool) tools.push({
        use_for: use_for,
        info: x.methods.tool()
      });
      use_for.forEach(function (indicator) {
        _this._registry[indicator] = i;
      });
    });

    this.$emit('custom-event', {
      event: 'register-tools',
      args: tools
    });
    this.$on('custom-event', function (e) {
      return _this.on_ux_event(e, 'grid');
    });
  },
  beforeDestroy: function beforeDestroy() {
    if (this.renderer) this.renderer.destroy();
  },
  mounted: function mounted() {
    var _this2 = this;

    var el = this.$refs['canvas'];
    this.renderer = new Grid(el, this);
    this.setup();
    this.$nextTick(function () {
      return _this2.redraw();
    });
  },
  render: function render(h) {
    var id = this.$props.grid_id;
    var layout = this.$props.layout.grids[id];
    return this.create_canvas(h, "grid-".concat(id), {
      position: {
        x: 0,
        y: layout.offset || 0
      },
      attrs: {
        width: layout.width,
        height: layout.height,
        overflow: 'hidden'
      },
      style: {
        backgroundColor: this.$props.colors.back
      },
      hs: [h(components_Crosshair, {
        props: this.common_props(),
        on: this.layer_events
      }), h(KeyboardListener, {
        on: this.keyboard_events
      }), h(UxLayer, {
        props: {
          id: id,
          tv_id: this.$props.tv_id,
          uxs: this.uxs,
          colors: this.$props.colors,
          config: this.$props.config,
          updater: Math.random()
        },
        on: {
          'custom-event': this.emit_ux_event
        }
      })].concat(this.get_overlays(h))
    });
  },
  methods: {
    new_layer: function new_layer(layer) {
      var _this3 = this;

      this.$nextTick(function () {
        return _this3.renderer.new_layer(layer);
      });
    },
    del_layer: function del_layer(layer) {
      var _this4 = this;

      this.$nextTick(function () {
        return _this4.renderer.del_layer(layer);
      });
      var grid_id = this.$props.grid_id;
      this.$emit('custom-event', {
        event: 'remove-shaders',
        args: [grid_id, layer]
      }); // TODO: close all interfaces

      this.$emit('custom-event', {
        event: 'remove-layer-meta',
        args: [grid_id, layer]
      });
      this.remove_all_ux(layer);
    },
    get_overlays: function get_overlays(h) {
      var _this5 = this;

      // Distributes overlay data & settings according
      // to this._registry; returns compo list
      var comp_list = [],
          count = {};

      var _iterator = Gridvue_type_script_lang_js_createForOfIteratorHelper(this.$props.data),
          _step;

      try {
        for (_iterator.s(); !(_step = _iterator.n()).done;) {
          var d = _step.value;
          var comp = this._list[this._registry[d.type]];

          if (comp) {
            if (comp.methods.calc) {
              comp = this.inject_renderer(comp);
            }

            comp_list.push({
              cls: comp,
              type: d.type,
              data: d.data,
              settings: d.settings,
              i0: d.i0,
              tf: d.tf,
              last: d.last
            });
            count[d.type] = 0;
          }
        }
      } catch (err) {
        _iterator.e(err);
      } finally {
        _iterator.f();
      }

      return comp_list.map(function (x, i) {
        return h(x.cls, {
          on: _this5.layer_events,
          attrs: Object.assign(_this5.common_props(), {
            id: "".concat(x.type, "_").concat(count[x.type]++),
            type: x.type,
            data: x.data,
            settings: x.settings,
            i0: x.i0,
            tf: x.tf,
            num: i,
            grid_id: _this5.$props.grid_id,
            meta: _this5.$props.meta,
            last: x.last
          })
        });
      });
    },
    common_props: function common_props() {
      return {
        cursor: this.$props.cursor,
        colors: this.$props.colors,
        layout: this.$props.layout.grids[this.$props.grid_id],
        interval: this.$props.interval,
        sub: this.$props.sub,
        font: this.$props.font,
        config: this.$props.config
      };
    },
    emit_ux_event: function emit_ux_event(e) {
      var e_pass = this.on_ux_event(e, 'grid');
      if (e_pass) this.$emit('custom-event', e);
    },
    // Replace the current comp with 'renderer'
    inject_renderer: function inject_renderer(comp) {
      var src = comp.methods.calc();

      if (!src.conf || !src.conf.renderer || comp.__renderer__) {
        return comp;
      } // Search for an overlay with the target 'name'


      var f = this._list.find(function (x) {
        return x.name === src.conf.renderer;
      });

      if (!f) return comp;
      comp.mixins.push(f);
      comp.__renderer__ = src.conf.renderer;
      return comp;
    }
  },
  computed: {
    is_active: function is_active() {
      return this.$props.cursor.t !== undefined && this.$props.cursor.grid_id === this.$props.grid_id;
    }
  },
  watch: {
    range: {
      handler: function handler() {
        var _this6 = this;

        // TODO: Left-side render lag fix:
        // Overlay data is updated one tick later than
        // the main sub. Fast fix is to delay redraw()
        // call. It will be a solution until a better
        // one comes by.
        this.$nextTick(function () {
          return _this6.redraw();
        });
      },
      deep: true
    },
    cursor: {
      handler: function handler() {
        if (!this.$props.cursor.locked) this.redraw();
      },
      deep: true
    },
    overlays: {
      // Track changes in calc() functions
      handler: function handler(ovs) {
        var _iterator2 = Gridvue_type_script_lang_js_createForOfIteratorHelper(ovs),
            _step2;

        try {
          for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
            var ov = _step2.value;

            var _iterator3 = Gridvue_type_script_lang_js_createForOfIteratorHelper(this.$children),
                _step3;

            try {
              for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {
                var comp = _step3.value;
                if (typeof comp.id !== 'string') continue;
                var tuple = comp.id.split('_');
                tuple.pop();

                if (tuple.join('_') === ov.name) {
                  comp.calc = ov.methods.calc;
                  if (!comp.calc) continue;
                  var calc = comp.calc.toString();

                  if (calc !== ov.__prevscript__) {
                    comp.exec_script();
                  }

                  ov.__prevscript__ = calc;
                }
              }
            } catch (err) {
              _iterator3.e(err);
            } finally {
              _iterator3.f();
            }
          }
        } catch (err) {
          _iterator2.e(err);
        } finally {
          _iterator2.f();
        }
      },
      deep: true
    },
    // Redraw on the shader list change
    shaders: function shaders(n, p) {
      this.redraw();
    }
  },
  data: function data() {
    var _this7 = this;

    return {
      layer_events: {
        'new-grid-layer': this.new_layer,
        'delete-grid-layer': this.del_layer,
        'show-grid-layer': function showGridLayer(d) {
          _this7.renderer.show_hide_layer(d);

          _this7.redraw();
        },
        'redraw-grid': this.redraw,
        'layer-meta-props': function layerMetaProps(d) {
          return _this7.$emit('layer-meta-props', d);
        },
        'custom-event': function customEvent(d) {
          return _this7.$emit('custom-event', d);
        }
      },
      keyboard_events: {
        'register-kb-listener': function registerKbListener(event) {
          _this7.$emit('register-kb-listener', event);
        },
        'remove-kb-listener': function removeKbListener(event) {
          _this7.$emit('remove-kb-listener', event);
        },
        'keyup': function keyup(event) {
          if (!_this7.is_active) return;

          _this7.renderer.propagate('keyup', event);
        },
        'keydown': function keydown(event) {
          if (!_this7.is_active) return; // TODO: is this neeeded?

          _this7.renderer.propagate('keydown', event);
        },
        'keypress': function keypress(event) {
          if (!_this7.is_active) return;

          _this7.renderer.propagate('keypress', event);
        }
      }
    };
  }
});
;// CONCATENATED MODULE: ./src/components/Grid.vue?vue&type=script&lang=js&
 /* harmony default export */ const components_Gridvue_type_script_lang_js_ = (Gridvue_type_script_lang_js_); 
;// CONCATENATED MODULE: ./src/components/Grid.vue
var Grid_render, Grid_staticRenderFns
;



/* normalize component */
;
var Grid_component = normalizeComponent(
  components_Gridvue_type_script_lang_js_,
  Grid_render,
  Grid_staticRenderFns,
  false,
  null,
  null,
  null
  
)

/* hot reload */
if (false) { var Grid_api; }
Grid_component.options.__file = "src/components/Grid.vue"
/* harmony default export */ const components_Grid = (Grid_component.exports);
;// CONCATENATED MODULE: ./src/components/js/sidebar.js



function sidebar_createForOfIteratorHelper(o, allowArrayLike) { var it; if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (it = sidebar_unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = o[Symbol.iterator](); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it["return"] != null) it["return"](); } finally { if (didErr) throw err; } } }; }

function sidebar_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return sidebar_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return sidebar_arrayLikeToArray(o, minLen); }

function sidebar_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }




var PANHEIGHT;

var Sidebar = /*#__PURE__*/function () {
  function Sidebar(canvas, comp, side) {
    if (side === void 0) {
      side = 'right';
    }

    classCallCheck_classCallCheck(this, Sidebar);

    PANHEIGHT = comp.config.PANHEIGHT;
    this.canvas = canvas;
    this.ctx = canvas.getContext('2d');
    this.comp = comp;
    this.$p = comp.$props;
    this.data = this.$p.sub;
    this.range = this.$p.range;
    this.id = this.$p.grid_id;
    this.layout = this.$p.layout.grids[this.id];
    this.side = side;
    this.listeners();
  }

  createClass_createClass(Sidebar, [{
    key: "listeners",
    value: function listeners() {
      var _this = this;

      var mc = this.mc = new hammer.Manager(this.canvas);
      mc.add(new hammer.Pan({
        direction: hammer.DIRECTION_VERTICAL,
        threshold: 0
      }));
      mc.add(new hammer.Tap({
        event: 'doubletap',
        taps: 2,
        posThreshold: 50
      }));
      mc.on('panstart', function (event) {
        if (_this.$p.y_transform) {
          _this.zoom = _this.$p.y_transform.zoom;
        } else {
          _this.zoom = 1.0;
        }

        _this.y_range = [_this.layout.$_hi, _this.layout.$_lo];
        _this.drug = {
          y: event.center.y,
          z: _this.zoom,
          mid: math.log_mid(_this.y_range, _this.layout.height),
          A: _this.layout.A,
          B: _this.layout.B
        };
      });
      mc.on('panmove', function (event) {
        if (_this.drug) {
          _this.zoom = _this.calc_zoom(event);

          _this.comp.$emit('sidebar-transform', {
            grid_id: _this.id,
            zoom: _this.zoom,
            auto: false,
            range: _this.calc_range(),
            drugging: true
          });

          _this.update();
        }
      });
      mc.on('panend', function () {
        _this.drug = null;

        _this.comp.$emit('sidebar-transform', {
          grid_id: _this.id,
          drugging: false
        });
      });
      mc.on('doubletap', function () {
        _this.comp.$emit('sidebar-transform', {
          grid_id: _this.id,
          zoom: 1.0,
          auto: true
        });

        _this.zoom = 1.0;

        _this.update();
      }); // TODO: Do later for mobile version
    }
  }, {
    key: "update",
    value: function update() {
      // Update reference to the grid
      this.layout = this.$p.layout.grids[this.id];
      var points = this.layout.ys;
      var x,
          y,
          w,
          h,
          side = this.side;
      var sb = this.layout.sb; //this.ctx.fillStyle = this.$p.colors.back

      this.ctx.font = this.$p.font;

      switch (side) {
        case 'left':
          x = 0;
          y = 0;
          w = Math.floor(sb);
          h = this.layout.height; //this.ctx.fillRect(x, y, w, h)

          this.ctx.clearRect(x, y, w, h);
          this.ctx.strokeStyle = this.$p.colors.scale;
          this.ctx.beginPath();
          this.ctx.moveTo(x + 0.5, 0);
          this.ctx.lineTo(x + 0.5, h);
          this.ctx.stroke();
          break;

        case 'right':
          x = 0;
          y = 0;
          w = Math.floor(sb);
          h = this.layout.height; //this.ctx.fillRect(x, y, w, h)

          this.ctx.clearRect(x, y, w, h);
          this.ctx.strokeStyle = this.$p.colors.scale;
          this.ctx.beginPath();
          this.ctx.moveTo(x + 0.5, 0);
          this.ctx.lineTo(x + 0.5, h);
          this.ctx.stroke();
          break;
      }

      this.ctx.fillStyle = this.$p.colors.text;
      this.ctx.beginPath();

      var _iterator = sidebar_createForOfIteratorHelper(points),
          _step;

      try {
        for (_iterator.s(); !(_step = _iterator.n()).done;) {
          var p = _step.value;
          if (p[0] > this.layout.height) continue;
          var x1 = side === 'left' ? w - 0.5 : x - 0.5;
          var x2 = side === 'left' ? x1 - 4.5 : x1 + 4.5;
          this.ctx.moveTo(x1, p[0] - 0.5);
          this.ctx.lineTo(x2, p[0] - 0.5);
          var offst = side === 'left' ? -10 : 10;
          this.ctx.textAlign = side === 'left' ? 'end' : 'start';
          var d = this.layout.prec;
          this.ctx.fillText(p[1].toFixed(d), x1 + offst, p[0] + 4);
        }
      } catch (err) {
        _iterator.e(err);
      } finally {
        _iterator.f();
      }

      this.ctx.stroke();
      if (this.$p.grid_id) this.upper_border();
      this.apply_shaders();
      if (this.$p.cursor.y && this.$p.cursor.y$) this.panel();
    }
  }, {
    key: "apply_shaders",
    value: function apply_shaders() {
      var layout = this.$p.layout.grids[this.id];
      var props = {
        layout: layout,
        cursor: this.$p.cursor
      };

      var _iterator2 = sidebar_createForOfIteratorHelper(this.$p.shaders),
          _step2;

      try {
        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
          var s = _step2.value;
          this.ctx.save();
          s.draw(this.ctx, props);
          this.ctx.restore();
        }
      } catch (err) {
        _iterator2.e(err);
      } finally {
        _iterator2.f();
      }
    }
  }, {
    key: "upper_border",
    value: function upper_border() {
      this.ctx.strokeStyle = this.$p.colors.scale;
      this.ctx.beginPath();
      this.ctx.moveTo(0, 0.5);
      this.ctx.lineTo(this.layout.width, 0.5);
      this.ctx.stroke();
    } // A gray bar behind the current price

  }, {
    key: "panel",
    value: function panel() {
      if (this.$p.cursor.grid_id !== this.layout.id) {
        return;
      }

      var lbl = this.$p.cursor.y$.toFixed(this.layout.prec);
      this.ctx.fillStyle = this.$p.colors.panel;
      var panwidth = this.layout.sb + 1;
      var x = -0.5;
      var y = this.$p.cursor.y - PANHEIGHT * 0.5 - 0.5;
      var a = 7;
      this.ctx.fillRect(x - 0.5, y, panwidth, PANHEIGHT);
      this.ctx.fillStyle = this.$p.colors.textHL;
      this.ctx.textAlign = 'left';
      this.ctx.fillText(lbl, a, y + 15);
    }
  }, {
    key: "calc_zoom",
    value: function calc_zoom(event) {
      var d = this.drug.y - event.center.y;
      var speed = d > 0 ? 3 : 1;
      var k = 1 + speed * d / this.layout.height;
      return utils.clamp(this.drug.z * k, 0.005, 100);
    } // Not the best place to calculate y-range but
    // this is the simplest solution I found up to
    // date

  }, {
    key: "calc_range",
    value: function calc_range(diff1, diff2) {
      var _this2 = this;

      if (diff1 === void 0) {
        diff1 = 1;
      }

      if (diff2 === void 0) {
        diff2 = 1;
      }

      var z = this.zoom / this.drug.z;
      var zk = (1 / z - 1) / 2;
      var range = this.y_range.slice();
      var delta = range[0] - range[1];

      if (!this.layout.grid.logScale) {
        range[0] = range[0] + delta * zk * diff1;
        range[1] = range[1] - delta * zk * diff2;
      } else {
        var px_mid = this.layout.height / 2;
        var new_hi = px_mid - px_mid * (1 / z);
        var new_lo = px_mid + px_mid * (1 / z); // Use old mapping to get a new range

        var f = function f(y) {
          return math.exp((y - _this2.drug.B) / _this2.drug.A);
        };

        var copy = range.slice();
        range[0] = f(new_hi);
        range[1] = f(new_lo);
      }

      return range;
    }
  }, {
    key: "rezoom_range",
    value: function rezoom_range(delta, diff1, diff2) {
      if (!this.$p.y_transform || this.$p.y_transform.auto) return;
      this.zoom = 1.0; // TODO: further work (improve scaling ratio)

      if (delta < 0) delta /= 3.75; // Btw, idk why 3.75, but it works

      delta *= 0.25;
      this.y_range = [this.layout.$_hi, this.layout.$_lo];
      this.drug = {
        y: 0,
        z: this.zoom,
        mid: math.log_mid(this.y_range, this.layout.height),
        A: this.layout.A,
        B: this.layout.B
      };
      this.zoom = this.calc_zoom({
        center: {
          y: delta * this.layout.height
        }
      });
      this.comp.$emit('sidebar-transform', {
        grid_id: this.id,
        zoom: this.zoom,
        auto: false,
        range: this.calc_range(diff1, diff2),
        drugging: true
      });
      this.drug = null;
      this.comp.$emit('sidebar-transform', {
        grid_id: this.id,
        drugging: false
      });
    }
  }, {
    key: "destroy",
    value: function destroy() {
      if (this.mc) this.mc.destroy();
    }
  }, {
    key: "mousemove",
    value: function mousemove() {}
  }, {
    key: "mouseout",
    value: function mouseout() {}
  }, {
    key: "mouseup",
    value: function mouseup() {}
  }, {
    key: "mousedown",
    value: function mousedown() {}
  }]);

  return Sidebar;
}();


;// CONCATENATED MODULE: ./node_modules/babel-loader/lib/index.js!./node_modules/vue-loader/lib/index.js??vue-loader-options!./src/components/Sidebar.vue?vue&type=script&lang=js&
// The side bar (yep, that thing with a bunch of $$$)


/* harmony default export */ const Sidebarvue_type_script_lang_js_ = ({
  name: 'Sidebar',
  props: ['sub', 'layout', 'range', 'interval', 'cursor', 'colors', 'font', 'width', 'height', 'grid_id', 'rerender', 'y_transform', 'tv_id', 'config', 'shaders'],
  mixins: [canvas],
  mounted: function mounted() {
    var el = this.$refs['canvas'];
    this.renderer = new Sidebar(el, this);
    this.setup();
    this.redraw();
  },
  render: function render(h) {
    var id = this.$props.grid_id;
    var layout = this.$props.layout.grids[id];
    return this.create_canvas(h, "sidebar-".concat(id), {
      position: {
        x: layout.width,
        y: layout.offset || 0
      },
      attrs: {
        rerender: this.$props.rerender,
        width: this.$props.width,
        height: layout.height
      },
      style: {
        backgroundColor: this.$props.colors.back
      }
    });
  },
  watch: {
    range: {
      handler: function handler() {
        this.redraw();
      },
      deep: true
    },
    cursor: {
      handler: function handler() {
        this.redraw();
      },
      deep: true
    },
    rerender: function rerender() {
      var _this = this;

      this.$nextTick(function () {
        return _this.redraw();
      });
    }
  },
  beforeDestroy: function beforeDestroy() {
    if (this.renderer) this.renderer.destroy();
  }
});
;// CONCATENATED MODULE: ./src/components/Sidebar.vue?vue&type=script&lang=js&
 /* harmony default export */ const components_Sidebarvue_type_script_lang_js_ = (Sidebarvue_type_script_lang_js_); 
;// CONCATENATED MODULE: ./src/components/Sidebar.vue
var Sidebar_render, Sidebar_staticRenderFns
;



/* normalize component */
;
var Sidebar_component = normalizeComponent(
  components_Sidebarvue_type_script_lang_js_,
  Sidebar_render,
  Sidebar_staticRenderFns,
  false,
  null,
  null,
  null
  
)

/* hot reload */
if (false) { var Sidebar_api; }
Sidebar_component.options.__file = "src/components/Sidebar.vue"
/* harmony default export */ const components_Sidebar = (Sidebar_component.exports);
;// CONCATENATED MODULE: ./node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!./node_modules/vue-loader/lib/index.js??vue-loader-options!./src/components/Legend.vue?vue&type=template&id=34724886&
var Legendvue_type_template_id_34724886_render = function() {
  var _vm = this
  var _h = _vm.$createElement
  var _c = _vm._self._c || _h
  return _c(
    "div",
    { staticClass: "trading-vue-legend", style: _vm.calc_style },
    [
      _vm.grid_id === 0
        ? _c(
            "div",
            {
              staticClass: "trading-vue-ohlcv",
              style: { "max-width": _vm.common.width + "px" }
            },
            [
              _c(
                "span",
                {
                  staticClass: "t-vue-title",
                  style: { color: _vm.common.colors.title }
                },
                [
                  _vm._v(
                    "\n              " +
                      _vm._s(_vm.common.title_txt) +
                      "\n        "
                  )
                ]
              ),
              _vm._v(" "),
              _vm.show_values
                ? _c("span", [
                    _vm._v("\n            O"),
                    _c("span", { staticClass: "t-vue-lspan" }, [
                      _vm._v(_vm._s(_vm.ohlcv[0]))
                    ]),
                    _vm._v("\n            H"),
                    _c("span", { staticClass: "t-vue-lspan" }, [
                      _vm._v(_vm._s(_vm.ohlcv[1]))
                    ]),
                    _vm._v("\n            L"),
                    _c("span", { staticClass: "t-vue-lspan" }, [
                      _vm._v(_vm._s(_vm.ohlcv[2]))
                    ]),
                    _vm._v("\n            C"),
                    _c("span", { staticClass: "t-vue-lspan" }, [
                      _vm._v(_vm._s(_vm.ohlcv[3]))
                    ]),
                    _vm._v("\n            V"),
                    _c("span", { staticClass: "t-vue-lspan" }, [
                      _vm._v(_vm._s(_vm.ohlcv[4]))
                    ])
                  ])
                : _vm._e(),
              _vm._v(" "),
              !_vm.show_values
                ? _c(
                    "span",
                    {
                      staticClass: "t-vue-lspan",
                      style: { color: _vm.common.colors.text }
                    },
                    [
                      _vm._v(
                        "\n            " +
                          _vm._s((_vm.common.meta.last || [])[4]) +
                          "\n        "
                      )
                    ]
                  )
                : _vm._e()
            ]
          )
        : _vm._e(),
      _vm._v(" "),
      _vm._l(this.indicators, function(ind) {
        return _c(
          "div",
          { staticClass: "t-vue-ind" },
          [
            _c("span", { staticClass: "t-vue-iname" }, [
              _vm._v(_vm._s(ind.name))
            ]),
            _vm._v(" "),
            _c("button-group", {
              attrs: {
                buttons: _vm.common.buttons,
                config: _vm.common.config,
                ov_id: ind.id,
                grid_id: _vm.grid_id,
                index: ind.index,
                tv_id: _vm.common.tv_id,
                display: ind.v
              },
              on: { "legend-button-click": _vm.button_click }
            }),
            _vm._v(" "),
            ind.v
              ? _c(
                  "span",
                  { staticClass: "t-vue-ivalues" },
                  _vm._l(ind.values, function(v) {
                    return _vm.show_values
                      ? _c(
                          "span",
                          {
                            staticClass: "t-vue-lspan t-vue-ivalue",
                            style: { color: v.color }
                          },
                          [
                            _vm._v(
                              "\n                " +
                                _vm._s(v.value) +
                                "\n            "
                            )
                          ]
                        )
                      : _vm._e()
                  }),
                  0
                )
              : _vm._e(),
            _vm._v(" "),
            ind.unk
              ? _c("span", { staticClass: "t-vue-unknown" }, [
                  _vm._v("\n            (Unknown type)\n        ")
                ])
              : _vm._e(),
            _vm._v(" "),
            _c(
              "transition",
              { attrs: { name: "tvjs-appear" } },
              [
                ind.loading
                  ? _c("spinner", { attrs: { colors: _vm.common.colors } })
                  : _vm._e()
              ],
              1
            )
          ],
          1
        )
      })
    ],
    2
  )
}
var Legendvue_type_template_id_34724886_staticRenderFns = []
Legendvue_type_template_id_34724886_render._withStripped = true


;// CONCATENATED MODULE: ./src/components/Legend.vue?vue&type=template&id=34724886&

;// CONCATENATED MODULE: ./node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!./node_modules/vue-loader/lib/index.js??vue-loader-options!./src/components/ButtonGroup.vue?vue&type=template&id=6f826426&
var ButtonGroupvue_type_template_id_6f826426_render = function() {
  var _vm = this
  var _h = _vm.$createElement
  var _c = _vm._self._c || _h
  return _c(
    "span",
    { staticClass: "t-vue-lbtn-grp" },
    _vm._l(_vm.buttons, function(b, i) {
      return _c("legend-button", {
        key: i,
        attrs: {
          id: b.name || b,
          tv_id: _vm.tv_id,
          ov_id: _vm.ov_id,
          grid_id: _vm.grid_id,
          index: _vm.index,
          display: _vm.display,
          icon: b.icon,
          config: _vm.config
        },
        on: { "legend-button-click": _vm.button_click }
      })
    }),
    1
  )
}
var ButtonGroupvue_type_template_id_6f826426_staticRenderFns = []
ButtonGroupvue_type_template_id_6f826426_render._withStripped = true


;// CONCATENATED MODULE: ./src/components/ButtonGroup.vue?vue&type=template&id=6f826426&

;// CONCATENATED MODULE: ./node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!./node_modules/vue-loader/lib/index.js??vue-loader-options!./src/components/LegendButton.vue?vue&type=template&id=1ad87362&
var LegendButtonvue_type_template_id_1ad87362_render = function() {
  var _vm = this
  var _h = _vm.$createElement
  var _c = _vm._self._c || _h
  return _c("img", {
    staticClass: "t-vue-lbtn",
    style: {
      width: _vm.config.L_BTN_SIZE + "px",
      height: _vm.config.L_BTN_SIZE + "px",
      margin: _vm.config.L_BTN_MARGIN
    },
    attrs: { src: _vm.base64, id: _vm.uuid },
    on: { click: _vm.onclick }
  })
}
var LegendButtonvue_type_template_id_1ad87362_staticRenderFns = []
LegendButtonvue_type_template_id_1ad87362_render._withStripped = true


;// CONCATENATED MODULE: ./src/components/LegendButton.vue?vue&type=template&id=1ad87362&

;// CONCATENATED MODULE: ./node_modules/babel-loader/lib/index.js!./node_modules/vue-loader/lib/index.js??vue-loader-options!./src/components/LegendButton.vue?vue&type=script&lang=js&
//
//
//
//
//
//
//
//
//

/* harmony default export */ const LegendButtonvue_type_script_lang_js_ = ({
  name: 'LegendButton',
  props: ['id', 'tv_id', 'grid_id', 'ov_id', 'index', 'display', 'icon', 'config'],
  mounted: function mounted() {},
  computed: {
    base64: function base64() {
      return this.icon || icons_namespaceObject[this.file_name];
    },
    file_name: function file_name() {
      var id = this.$props.id;

      if (this.$props.id === 'display') {
        id = this.$props.display ? 'display_on' : 'display_off';
      }

      return id + '.png';
    },
    uuid: function uuid() {
      var tv = this.$props.tv_id;
      var gr = this.$props.grid_id;
      var ov = this.$props.ov_id;
      return "".concat(tv, "-btn-g").concat(gr, "-").concat(ov);
    },
    data_type: function data_type() {
      return this.$props.grid_id === 0 ? "onchart" : "offchart";
    },
    data_index: function data_index() {
      return this.$props.index;
    }
  },
  methods: {
    onclick: function onclick() {
      this.$emit('legend-button-click', {
        button: this.$props.id,
        type: this.data_type,
        dataIndex: this.data_index,
        grid: this.$props.grid_id,
        overlay: this.$props.ov_id
      });
    }
  }
});
;// CONCATENATED MODULE: ./src/components/LegendButton.vue?vue&type=script&lang=js&
 /* harmony default export */ const components_LegendButtonvue_type_script_lang_js_ = (LegendButtonvue_type_script_lang_js_); 
// EXTERNAL MODULE: ./node_modules/vue-style-loader/index.js!./node_modules/css-loader/dist/cjs.js!./node_modules/vue-loader/lib/loaders/stylePostLoader.js!./node_modules/vue-loader/lib/index.js??vue-loader-options!./src/components/LegendButton.vue?vue&type=style&index=0&lang=css&
var LegendButtonvue_type_style_index_0_lang_css_ = __nested_webpack_require_9759__(169);
;// CONCATENATED MODULE: ./src/components/LegendButton.vue?vue&type=style&index=0&lang=css&

;// CONCATENATED MODULE: ./src/components/LegendButton.vue



;


/* normalize component */

var LegendButton_component = normalizeComponent(
  components_LegendButtonvue_type_script_lang_js_,
  LegendButtonvue_type_template_id_1ad87362_render,
  LegendButtonvue_type_template_id_1ad87362_staticRenderFns,
  false,
  null,
  null,
  null
  
)

/* hot reload */
if (false) { var LegendButton_api; }
LegendButton_component.options.__file = "src/components/LegendButton.vue"
/* harmony default export */ const LegendButton = (LegendButton_component.exports);
;// CONCATENATED MODULE: ./node_modules/babel-loader/lib/index.js!./node_modules/vue-loader/lib/index.js??vue-loader-options!./src/components/ButtonGroup.vue?vue&type=script&lang=js&
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//

/* harmony default export */ const ButtonGroupvue_type_script_lang_js_ = ({
  name: 'ButtonGroup',
  props: ['buttons', 'tv_id', 'ov_id', 'grid_id', 'index', 'display', 'config'],
  components: {
    LegendButton: LegendButton
  },
  methods: {
    button_click: function button_click(event) {
      this.$emit('legend-button-click', event);
    }
  }
});
;// CONCATENATED MODULE: ./src/components/ButtonGroup.vue?vue&type=script&lang=js&
 /* harmony default export */ const components_ButtonGroupvue_type_script_lang_js_ = (ButtonGroupvue_type_script_lang_js_); 
// EXTERNAL MODULE: ./node_modules/vue-style-loader/index.js!./node_modules/css-loader/dist/cjs.js!./node_modules/vue-loader/lib/loaders/stylePostLoader.js!./node_modules/vue-loader/lib/index.js??vue-loader-options!./src/components/ButtonGroup.vue?vue&type=style&index=0&lang=css&
var ButtonGroupvue_type_style_index_0_lang_css_ = __nested_webpack_require_9759__(886);
;// CONCATENATED MODULE: ./src/components/ButtonGroup.vue?vue&type=style&index=0&lang=css&

;// CONCATENATED MODULE: ./src/components/ButtonGroup.vue



;


/* normalize component */

var ButtonGroup_component = normalizeComponent(
  components_ButtonGroupvue_type_script_lang_js_,
  ButtonGroupvue_type_template_id_6f826426_render,
  ButtonGroupvue_type_template_id_6f826426_staticRenderFns,
  false,
  null,
  null,
  null
  
)

/* hot reload */
if (false) { var ButtonGroup_api; }
ButtonGroup_component.options.__file = "src/components/ButtonGroup.vue"
/* harmony default export */ const ButtonGroup = (ButtonGroup_component.exports);
;// CONCATENATED MODULE: ./node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!./node_modules/vue-loader/lib/index.js??vue-loader-options!./src/components/Spinner.vue?vue&type=template&id=39432f99&
var Spinnervue_type_template_id_39432f99_render = function() {
  var _vm = this
  var _h = _vm.$createElement
  var _c = _vm._self._c || _h
  return _c(
    "div",
    { staticClass: "tvjs-spinner" },
    _vm._l(4, function(i) {
      return _c("div", { key: i, style: { background: _vm.colors.text } })
    }),
    0
  )
}
var Spinnervue_type_template_id_39432f99_staticRenderFns = []
Spinnervue_type_template_id_39432f99_render._withStripped = true


;// CONCATENATED MODULE: ./src/components/Spinner.vue?vue&type=template&id=39432f99&

;// CONCATENATED MODULE: ./node_modules/babel-loader/lib/index.js!./node_modules/vue-loader/lib/index.js??vue-loader-options!./src/components/Spinner.vue?vue&type=script&lang=js&
//
//
//
//
//
//
/* harmony default export */ const Spinnervue_type_script_lang_js_ = ({
  name: 'Spinner',
  props: ['colors']
});
;// CONCATENATED MODULE: ./src/components/Spinner.vue?vue&type=script&lang=js&
 /* harmony default export */ const components_Spinnervue_type_script_lang_js_ = (Spinnervue_type_script_lang_js_); 
// EXTERNAL MODULE: ./node_modules/vue-style-loader/index.js!./node_modules/css-loader/dist/cjs.js!./node_modules/vue-loader/lib/loaders/stylePostLoader.js!./node_modules/vue-loader/lib/index.js??vue-loader-options!./src/components/Spinner.vue?vue&type=style&index=0&lang=css&
var Spinnervue_type_style_index_0_lang_css_ = __nested_webpack_require_9759__(372);
;// CONCATENATED MODULE: ./src/components/Spinner.vue?vue&type=style&index=0&lang=css&

;// CONCATENATED MODULE: ./src/components/Spinner.vue



;


/* normalize component */

var Spinner_component = normalizeComponent(
  components_Spinnervue_type_script_lang_js_,
  Spinnervue_type_template_id_39432f99_render,
  Spinnervue_type_template_id_39432f99_staticRenderFns,
  false,
  null,
  null,
  null
  
)

/* hot reload */
if (false) { var Spinner_api; }
Spinner_component.options.__file = "src/components/Spinner.vue"
/* harmony default export */ const Spinner = (Spinner_component.exports);
;// CONCATENATED MODULE: ./node_modules/babel-loader/lib/index.js!./node_modules/vue-loader/lib/index.js??vue-loader-options!./src/components/Legend.vue?vue&type=script&lang=js&
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//


/* harmony default export */ const Legendvue_type_script_lang_js_ = ({
  name: 'ChartLegend',
  props: ['common', 'values', 'grid_id', 'meta_props'],
  components: {
    ButtonGroup: ButtonGroup,
    Spinner: Spinner
  },
  computed: {
    ohlcv: function ohlcv() {
      if (!this.$props.values || !this.$props.values.ohlcv) {
        return Array(6).fill('n/a');
      }

      var prec = this.layout.prec; // TODO: main the main legend more customizable

      var id = this.main_type + '_0';
      var meta = this.$props.meta_props[id] || {};

      if (meta.legend) {
        return (meta.legend() || []).map(function (x) {
          return x.value;
        });
      }

      return [this.$props.values.ohlcv[1].toFixed(prec), this.$props.values.ohlcv[2].toFixed(prec), this.$props.values.ohlcv[3].toFixed(prec), this.$props.values.ohlcv[4].toFixed(prec), this.$props.values.ohlcv[5] ? this.$props.values.ohlcv[5].toFixed(2) : 'n/a'];
    },
    // TODO: add support for { grid: { id : N }}
    indicators: function indicators() {
      var _this = this;

      var values = this.$props.values;
      var f = this.format;
      var types = {};
      return this.json_data.filter(function (x) {
        return x.settings.legend !== false && !x.main;
      }).map(function (x) {
        if (!(x.type in types)) types[x.type] = 0;
        var id = x.type + "_".concat(types[x.type]++);
        return {
          v: 'display' in x.settings ? x.settings.display : true,
          name: x.name || id,
          index: (_this.off_data || _this.json_data).indexOf(x),
          id: id,
          values: values ? f(id, values) : _this.n_a(1),
          unk: !(id in (_this.$props.meta_props || {})),
          loading: x.loading
        };
      });
    },
    calc_style: function calc_style() {
      var top = this.layout.height > 150 ? 10 : 5;
      var grids = this.$props.common.layout.grids;
      var w = grids[0] ? grids[0].width : undefined;
      return {
        top: "".concat(this.layout.offset + top, "px"),
        width: "".concat(w - 20, "px")
      };
    },
    layout: function layout() {
      var id = this.$props.grid_id;
      return this.$props.common.layout.grids[id];
    },
    json_data: function json_data() {
      return this.$props.common.data;
    },
    off_data: function off_data() {
      return this.$props.common.offchart;
    },
    main_type: function main_type() {
      var f = this.common.data.find(function (x) {
        return x.main;
      });
      return f ? f.type : undefined;
    },
    show_values: function show_values() {
      return this.common.cursor.mode !== 'explore';
    }
  },
  methods: {
    format: function format(id, values) {
      var meta = this.$props.meta_props[id] || {}; // Matches Overlay.data_colors with the data values
      // (see Spline.vue)

      if (!values[id]) return this.n_a(1); // Custom formatter

      if (meta.legend) return meta.legend(values[id]);
      return values[id].slice(1).map(function (x, i) {
        var cs = meta.data_colors ? meta.data_colors() : [];

        if (typeof x == 'number') {
          // Show 8 digits for small values
          x = x.toFixed(Math.abs(x) > 0.001 ? 4 : 8);
        }

        return {
          value: x,
          color: cs ? cs[i % cs.length] : undefined
        };
      });
    },
    n_a: function n_a(len) {
      return Array(len).fill({
        value: 'n/a'
      });
    },
    button_click: function button_click(event) {
      this.$emit('legend-button-click', event);
    }
  }
});
;// CONCATENATED MODULE: ./src/components/Legend.vue?vue&type=script&lang=js&
 /* harmony default export */ const components_Legendvue_type_script_lang_js_ = (Legendvue_type_script_lang_js_); 
// EXTERNAL MODULE: ./node_modules/vue-style-loader/index.js!./node_modules/css-loader/dist/cjs.js!./node_modules/vue-loader/lib/loaders/stylePostLoader.js!./node_modules/vue-loader/lib/index.js??vue-loader-options!./src/components/Legend.vue?vue&type=style&index=0&lang=css&
var Legendvue_type_style_index_0_lang_css_ = __nested_webpack_require_9759__(600);
;// CONCATENATED MODULE: ./src/components/Legend.vue?vue&type=style&index=0&lang=css&

;// CONCATENATED MODULE: ./src/components/Legend.vue



;


/* normalize component */

var Legend_component = normalizeComponent(
  components_Legendvue_type_script_lang_js_,
  Legendvue_type_template_id_34724886_render,
  Legendvue_type_template_id_34724886_staticRenderFns,
  false,
  null,
  null,
  null
  
)

/* hot reload */
if (false) { var Legend_api; }
Legend_component.options.__file = "src/components/Legend.vue"
/* harmony default export */ const Legend = (Legend_component.exports);
;// CONCATENATED MODULE: ./src/mixins/shaders.js
function shaders_createForOfIteratorHelper(o, allowArrayLike) { var it; if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (it = shaders_unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = o[Symbol.iterator](); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it["return"] != null) it["return"](); } finally { if (didErr) throw err; } } }; }

function shaders_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return shaders_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return shaders_arrayLikeToArray(o, minLen); }

function shaders_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

// Parser for shader events
/* harmony default export */ const shaders = ({
  methods: {
    // Init shaders from extensions
    init_shaders: function init_shaders(skin, prev) {
      if (skin !== prev) {
        if (prev) this.shaders = this.shaders.filter(function (x) {
          return x.owner !== prev.id;
        });

        var _iterator = shaders_createForOfIteratorHelper(skin.shaders),
            _step;

        try {
          for (_iterator.s(); !(_step = _iterator.n()).done;) {
            var Shader = _step.value;
            var shader = new Shader();
            shader.owner = skin.id;
            this.shaders.push(shader);
          } // TODO: Sort by zIndex

        } catch (err) {
          _iterator.e(err);
        } finally {
          _iterator.f();
        }
      }
    },
    on_shader_event: function on_shader_event(d, target) {
      if (d.event === 'new-shader') {
        if (d.args[0].target === target) {
          d.args[0].id = "".concat(d.args[1], "-").concat(d.args[2]);
          this.shaders.push(d.args[0]);
          this.rerender++;
        }
      }

      if (d.event === 'remove-shaders') {
        var id = d.args.join('-');
        this.shaders = this.shaders.filter(function (x) {
          return x.id !== id;
        });
      }
    }
  },
  watch: {
    skin: function skin(n, p) {
      this.init_shaders(n, p);
    }
  },
  data: function data() {
    return {
      shaders: []
    };
  }
});
;// CONCATENATED MODULE: ./node_modules/babel-loader/lib/index.js!./node_modules/vue-loader/lib/index.js??vue-loader-options!./src/components/Section.vue?vue&type=script&lang=js&

//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//




/* harmony default export */ const Sectionvue_type_script_lang_js_ = ({
  name: 'GridSection',
  props: ['common', 'grid_id'],
  mixins: [shaders],
  components: {
    Grid: components_Grid,
    Sidebar: components_Sidebar,
    ChartLegend: Legend
  },
  mounted: function mounted() {
    this.init_shaders(this.$props.common.skin);
  },
  methods: {
    range_changed: function range_changed(r) {
      this.$emit('range-changed', r);
    },
    cursor_changed: function cursor_changed(c) {
      c.grid_id = this.$props.grid_id;
      this.$emit('cursor-changed', c);
    },
    cursor_locked: function cursor_locked(state) {
      this.$emit('cursor-locked', state);
    },
    sidebar_transform: function sidebar_transform(s) {
      this.$emit('sidebar-transform', s);
    },
    emit_meta_props: function emit_meta_props(d) {
      this.$set(this.meta_props, d.layer_id, d);
      this.$emit('layer-meta-props', d);
    },
    emit_custom_event: function emit_custom_event(d) {
      this.on_shader_event(d, 'sidebar');
      this.$emit('custom-event', d);
    },
    button_click: function button_click(event) {
      this.$emit('legend-button-click', event);
    },
    register_kb: function register_kb(event) {
      this.$emit('register-kb-listener', event);
    },
    remove_kb: function remove_kb(event) {
      this.$emit('remove-kb-listener', event);
    },
    rezoom_range: function rezoom_range(event) {
      var id = 'sb-' + event.grid_id;

      if (this.$refs[id]) {
        this.$refs[id].renderer.rezoom_range(event.z, event.diff1, event.diff2);
      }
    },
    ghash: function ghash(val) {
      // Measures grid heights configuration
      var hs = val.layout.grids.map(function (x) {
        return x.height;
      });
      return hs.reduce(function (a, b) {
        return a + b;
      }, '');
    }
  },
  computed: {
    // Component-specific props subsets:
    grid_props: function grid_props() {
      var id = this.$props.grid_id;
      var p = Object.assign({}, this.$props.common); // Split offchart data between offchart grids

      if (id > 0) {
        var _p$data;

        var all = p.data;
        p.data = [p.data[id - 1]]; // Merge offchart overlays with custom ids with
        // the existing onse (by comparing the grid ids)

        (_p$data = p.data).push.apply(_p$data, _toConsumableArray(all.filter(function (x) {
          return x.grid && x.grid.id === id;
        })));
      }

      p.width = p.layout.grids[id].width;
      p.height = p.layout.grids[id].height;
      p.y_transform = p.y_ts[id];
      p.shaders = this.grid_shaders;
      return p;
    },
    sidebar_props: function sidebar_props() {
      var id = this.$props.grid_id;
      var p = Object.assign({}, this.$props.common);
      p.width = p.layout.grids[id].sb;
      p.height = p.layout.grids[id].height;
      p.y_transform = p.y_ts[id];
      p.shaders = this.sb_shaders;
      return p;
    },
    section_values: function section_values() {
      var id = this.$props.grid_id;
      var p = Object.assign({}, this.$props.common);
      p.width = p.layout.grids[id].width;
      return p.cursor.values[id];
    },
    legend_props: function legend_props() {
      var id = this.$props.grid_id;
      var p = Object.assign({}, this.$props.common); // Split offchart data between offchart grids

      if (id > 0) {
        var _p$data2;

        var all = p.data;
        p.offchart = all;
        p.data = [p.data[id - 1]];

        (_p$data2 = p.data).push.apply(_p$data2, _toConsumableArray(all.filter(function (x) {
          return x.grid && x.grid.id === id;
        })));
      }

      return p;
    },
    get_meta_props: function get_meta_props() {
      return this.meta_props;
    },
    grid_shaders: function grid_shaders() {
      return this.shaders.filter(function (x) {
        return x.target === 'grid';
      });
    },
    sb_shaders: function sb_shaders() {
      return this.shaders.filter(function (x) {
        return x.target === 'sidebar';
      });
    }
  },
  watch: {
    common: {
      handler: function handler(val, old_val) {
        var newhash = this.ghash(val);

        if (newhash !== this.last_ghash) {
          this.rerender++;
        }

        if (val.data.length !== old_val.data.length) {
          // Look at this nasty trick!
          this.rerender++;
        }

        this.last_ghash = newhash;
      },
      deep: true
    }
  },
  data: function data() {
    return {
      meta_props: {},
      rerender: 0,
      last_ghash: ''
    };
  }
});
;// CONCATENATED MODULE: ./src/components/Section.vue?vue&type=script&lang=js&
 /* harmony default export */ const components_Sectionvue_type_script_lang_js_ = (Sectionvue_type_script_lang_js_); 
// EXTERNAL MODULE: ./node_modules/vue-style-loader/index.js!./node_modules/css-loader/dist/cjs.js!./node_modules/vue-loader/lib/loaders/stylePostLoader.js!./node_modules/vue-loader/lib/index.js??vue-loader-options!./src/components/Section.vue?vue&type=style&index=0&lang=css&
var Sectionvue_type_style_index_0_lang_css_ = __nested_webpack_require_9759__(11);
;// CONCATENATED MODULE: ./src/components/Section.vue?vue&type=style&index=0&lang=css&

;// CONCATENATED MODULE: ./src/components/Section.vue



;


/* normalize component */

var Section_component = normalizeComponent(
  components_Sectionvue_type_script_lang_js_,
  Sectionvue_type_template_id_8fbe9336_render,
  Sectionvue_type_template_id_8fbe9336_staticRenderFns,
  false,
  null,
  null,
  null
  
)

/* hot reload */
if (false) { var Section_api; }
Section_component.options.__file = "src/components/Section.vue"
/* harmony default export */ const Section = (Section_component.exports);
;// CONCATENATED MODULE: ./src/components/js/botbar.js



function botbar_createForOfIteratorHelper(o, allowArrayLike) { var it; if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (it = botbar_unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = o[Symbol.iterator](); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it["return"] != null) it["return"](); } finally { if (didErr) throw err; } } }; }

function botbar_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return botbar_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return botbar_arrayLikeToArray(o, minLen); }

function botbar_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }



var botbar_MINUTE15 = constants.MINUTE15,
    botbar_MINUTE = constants.MINUTE,
    botbar_HOUR = constants.HOUR,
    botbar_DAY = constants.DAY,
    botbar_WEEK = constants.WEEK,
    botbar_MONTH = constants.MONTH,
    botbar_YEAR = constants.YEAR,
    botbar_MONTHMAP = constants.MONTHMAP;

var Botbar = /*#__PURE__*/function () {
  function Botbar(canvas, comp) {
    classCallCheck_classCallCheck(this, Botbar);

    this.canvas = canvas;
    this.ctx = canvas.getContext('2d');
    this.comp = comp;
    this.$p = comp.$props;
    this.data = this.$p.sub;
    this.range = this.$p.range;
    this.layout = this.$p.layout;
  }

  createClass_createClass(Botbar, [{
    key: "update",
    value: function update() {
      this.grid_0 = this.layout.grids[0];
      var width = this.layout.botbar.width;
      var height = this.layout.botbar.height;
      var sb = this.layout.grids[0].sb; //this.ctx.fillStyle = this.$p.colors.back

      this.ctx.font = this.$p.font; //this.ctx.fillRect(0, 0, width, height)

      this.ctx.clearRect(0, 0, width, height);
      this.ctx.strokeStyle = this.$p.colors.scale;
      this.ctx.beginPath();
      this.ctx.moveTo(0, 0.5);
      this.ctx.lineTo(Math.floor(width + 1), 0.5);
      this.ctx.stroke();
      this.ctx.fillStyle = this.$p.colors.text;
      this.ctx.beginPath();

      var _iterator = botbar_createForOfIteratorHelper(this.layout.botbar.xs),
          _step;

      try {
        for (_iterator.s(); !(_step = _iterator.n()).done;) {
          var p = _step.value;
          var lbl = this.format_date(p);
          if (p[0] > width - sb) continue;
          this.ctx.moveTo(p[0] - 0.5, 0);
          this.ctx.lineTo(p[0] - 0.5, 4.5);

          if (!this.lbl_highlight(p[1][0])) {
            this.ctx.globalAlpha = 0.85;
          }

          this.ctx.textAlign = 'center';
          this.ctx.fillText(lbl, p[0], 18);
          this.ctx.globalAlpha = 1;
        }
      } catch (err) {
        _iterator.e(err);
      } finally {
        _iterator.f();
      }

      this.ctx.stroke();
      this.apply_shaders();
      if (this.$p.cursor.x && this.$p.cursor.t !== undefined) this.panel();
    }
  }, {
    key: "apply_shaders",
    value: function apply_shaders() {
      var layout = this.layout.grids[0];
      var props = {
        layout: layout,
        cursor: this.$p.cursor
      };

      var _iterator2 = botbar_createForOfIteratorHelper(this.comp.bot_shaders),
          _step2;

      try {
        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
          var s = _step2.value;
          this.ctx.save();
          s.draw(this.ctx, props);
          this.ctx.restore();
        }
      } catch (err) {
        _iterator2.e(err);
      } finally {
        _iterator2.f();
      }
    }
  }, {
    key: "panel",
    value: function panel() {
      var lbl = this.format_cursor_x();
      this.ctx.fillStyle = this.$p.colors.panel;
      var measure = this.ctx.measureText(lbl + '    ');
      var panwidth = Math.floor(measure.width);
      var cursor = this.$p.cursor.x;
      var x = Math.floor(cursor - panwidth * 0.5);
      var y = -0.5;
      var panheight = this.comp.config.PANHEIGHT;
      this.ctx.fillRect(x, y, panwidth, panheight + 0.5);
      this.ctx.fillStyle = this.$p.colors.textHL;
      this.ctx.textAlign = 'center';
      this.ctx.fillText(lbl, cursor, y + 16);
    }
  }, {
    key: "format_date",
    value: function format_date(p) {
      var t = p[1][0];
      t = this.grid_0.ti_map.i2t(t);
      var ti = this.$p.layout.grids[0].ti_map.tf; // Enable timezones only for tf < 1D

      var k = ti < botbar_DAY ? 1 : 0;
      var tZ = t + k * this.$p.timezone * botbar_HOUR; //t += new Date(t).getTimezoneOffset() * MINUTE

      var d = new Date(tZ);

      if (p[2] === botbar_YEAR || utils.year_start(t) === t) {
        return d.getUTCFullYear();
      }

      if (p[2] === botbar_MONTH || utils.month_start(t) === t) {
        return botbar_MONTHMAP[d.getUTCMonth()];
      } // TODO(*) see grid_maker.js


      if (utils.day_start(tZ) === tZ) return d.getUTCDate();
      var h = utils.add_zero(d.getUTCHours());
      var m = utils.add_zero(d.getUTCMinutes());
      return h + ":" + m;
    }
  }, {
    key: "format_cursor_x",
    value: function format_cursor_x() {
      var t = this.$p.cursor.t;
      t = this.grid_0.ti_map.i2t(t); //let ti = this.$p.interval

      var ti = this.$p.layout.grids[0].ti_map.tf; // Enable timezones only for tf < 1D

      var k = ti < botbar_DAY ? 1 : 0; //t += new Date(t).getTimezoneOffset() * MINUTE

      var d = new Date(t + k * this.$p.timezone * botbar_HOUR);

      if (ti === botbar_YEAR) {
        return d.getUTCFullYear();
      }

      if (ti < botbar_YEAR) {
        var yr = '`' + "".concat(d.getUTCFullYear()).slice(-2);
        var mo = botbar_MONTHMAP[d.getUTCMonth()];
        var dd = '01';
      }

      if (ti <= botbar_WEEK) dd = d.getUTCDate();
      var date = "".concat(dd, " ").concat(mo, " ").concat(yr);
      var time = '';

      if (ti < botbar_DAY) {
        var h = utils.add_zero(d.getUTCHours());
        var m = utils.add_zero(d.getUTCMinutes());
        time = h + ":" + m;
      }

      return "".concat(date, "  ").concat(time);
    } // Highlights the begining of a time interval
    // TODO: improve. Problem: let's say we have a new month,
    // but if there is no grid line in place, there
    // will be no month name on t-axis. Sad.
    // Solution: manipulate the grid, skew it, you know

  }, {
    key: "lbl_highlight",
    value: function lbl_highlight(t) {
      var ti = this.$p.interval;
      if (t === 0) return true;
      if (utils.month_start(t) === t) return true;
      if (utils.day_start(t) === t) return true;
      if (ti <= botbar_MINUTE15 && t % botbar_HOUR === 0) return true;
      return false;
    }
  }, {
    key: "mousemove",
    value: function mousemove() {}
  }, {
    key: "mouseout",
    value: function mouseout() {}
  }, {
    key: "mouseup",
    value: function mouseup() {}
  }, {
    key: "mousedown",
    value: function mousedown() {}
  }]);

  return Botbar;
}();


;// CONCATENATED MODULE: ./node_modules/babel-loader/lib/index.js!./node_modules/vue-loader/lib/index.js??vue-loader-options!./src/components/Botbar.vue?vue&type=script&lang=js&
// The bottom bar (yep, that thing with a bunch of dates)


/* harmony default export */ const Botbarvue_type_script_lang_js_ = ({
  name: 'Botbar',
  props: ['sub', 'layout', 'range', 'interval', 'cursor', 'colors', 'font', 'width', 'height', 'rerender', 'tv_id', 'config', 'shaders', 'timezone'],
  mixins: [canvas],
  mounted: function mounted() {
    var el = this.$refs['canvas'];
    this.renderer = new Botbar(el, this);
    this.setup();
    this.redraw();
  },
  render: function render(h) {
    var sett = this.$props.layout.botbar;
    return this.create_canvas(h, 'botbar', {
      position: {
        x: 0,
        y: sett.offset || 0
      },
      attrs: {
        rerender: this.$props.rerender,
        width: sett.width,
        height: sett.height
      },
      style: {
        backgroundColor: this.$props.colors.back
      }
    });
  },
  computed: {
    bot_shaders: function bot_shaders() {
      return this.$props.shaders.filter(function (x) {
        return x.target === 'botbar';
      });
    }
  },
  watch: {
    range: {
      handler: function handler() {
        this.redraw();
      },
      deep: true
    },
    cursor: {
      handler: function handler() {
        this.redraw();
      },
      deep: true
    },
    rerender: function rerender() {
      var _this = this;

      this.$nextTick(function () {
        return _this.redraw();
      });
    }
  }
});
;// CONCATENATED MODULE: ./src/components/Botbar.vue?vue&type=script&lang=js&
 /* harmony default export */ const components_Botbarvue_type_script_lang_js_ = (Botbarvue_type_script_lang_js_); 
// EXTERNAL MODULE: ./node_modules/vue-style-loader/index.js!./node_modules/css-loader/dist/cjs.js!./node_modules/vue-loader/lib/loaders/stylePostLoader.js!./node_modules/vue-loader/lib/index.js??vue-loader-options!./src/components/Botbar.vue?vue&type=style&index=0&lang=css&
var Botbarvue_type_style_index_0_lang_css_ = __nested_webpack_require_9759__(124);
;// CONCATENATED MODULE: ./src/components/Botbar.vue?vue&type=style&index=0&lang=css&

;// CONCATENATED MODULE: ./src/components/Botbar.vue
var Botbar_render, Botbar_staticRenderFns
;

;


/* normalize component */

var Botbar_component = normalizeComponent(
  components_Botbarvue_type_script_lang_js_,
  Botbar_render,
  Botbar_staticRenderFns,
  false,
  null,
  null,
  null
  
)

/* hot reload */
if (false) { var Botbar_api; }
Botbar_component.options.__file = "src/components/Botbar.vue"
/* harmony default export */ const components_Botbar = (Botbar_component.exports);
;// CONCATENATED MODULE: ./node_modules/babel-loader/lib/index.js!./node_modules/vue-loader/lib/index.js??vue-loader-options!./src/components/Keyboard.vue?vue&type=script&lang=js&
//
//
//
//
/* harmony default export */ const Keyboardvue_type_script_lang_js_ = ({
  name: 'Keyboard',
  created: function created() {
    window.addEventListener('keydown', this.keydown);
    window.addEventListener('keyup', this.keyup);
    window.addEventListener('keypress', this.keypress);
    this._listeners = {};
  },
  beforeDestroy: function beforeDestroy() {
    window.removeEventListener('keydown', this.keydown);
    window.removeEventListener('keyup', this.keyup);
    window.removeEventListener('keypress', this.keypress);
  },
  render: function render(h) {
    return h();
  },
  methods: {
    keydown: function keydown(event) {
      for (var id in this._listeners) {
        var l = this._listeners[id];

        if (l && l.keydown) {
          l.keydown(event);
        } else {
          console.warn("No 'keydown' listener for ".concat(id));
        }
      }
    },
    keyup: function keyup(event) {
      for (var id in this._listeners) {
        var l = this._listeners[id];

        if (l && l.keyup) {
          l.keyup(event);
        } else {
          console.warn("No 'keyup' listener for ".concat(id));
        }
      }
    },
    keypress: function keypress(event) {
      for (var id in this._listeners) {
        var l = this._listeners[id];

        if (l && l.keypress) {
          l.keypress(event);
        } else {
          console.warn("No 'keypress' listener for ".concat(id));
        }
      }
    },
    register: function register(listener) {
      this._listeners[listener.id] = listener;
    },
    remove: function remove(listener) {
      delete this._listeners[listener.id];
    }
  }
});
;// CONCATENATED MODULE: ./src/components/Keyboard.vue?vue&type=script&lang=js&
 /* harmony default export */ const components_Keyboardvue_type_script_lang_js_ = (Keyboardvue_type_script_lang_js_); 
;// CONCATENATED MODULE: ./src/components/Keyboard.vue
var Keyboard_render, Keyboard_staticRenderFns
;



/* normalize component */
;
var Keyboard_component = normalizeComponent(
  components_Keyboardvue_type_script_lang_js_,
  Keyboard_render,
  Keyboard_staticRenderFns,
  false,
  null,
  null,
  null
  
)

/* hot reload */
if (false) { var Keyboard_api; }
Keyboard_component.options.__file = "src/components/Keyboard.vue"
/* harmony default export */ const Keyboard = (Keyboard_component.exports);
;// CONCATENATED MODULE: ./src/mixins/datatrack.js
// Data tracker/watcher

/* harmony default export */ const datatrack = ({
  methods: {
    data_changed: function data_changed() {
      var n = this.ohlcv;
      var changed = false;

      if (this._data_n0 !== n[0] && this._data_len !== n.length) {
        changed = true;
      }

      this.check_all_data(changed);

      if (this.ti_map.ib) {
        this.reindex_delta(n[0], this._data_n0);
      }

      this._data_n0 = n[0];
      this._data_len = n.length;
      this.save_data_t();
      return changed;
    },
    check_all_data: function check_all_data(changed) {
      // If length of data in the Structure changed by > 1 point
      // emit a special event for DC to recalc the scripts
      // TODO: check overlays data too
      var len = this._data_len || 0;

      if (Math.abs(this.ohlcv.length - len) > 1 || this._data_n0 !== this.ohlcv[0]) {
        this.$emit('custom-event', {
          event: 'data-len-changed',
          args: []
        });
      }
    },
    reindex_delta: function reindex_delta(n, p) {
      n = n || [[0]];
      p = p || [[0]];
      var dt = n[0] - p[0];

      if (dt !== 0 && this._data_t) {
        // Convert t back to index
        try {
          // More precise method first
          var nt = this._data_t + 0.01; // fix for the filter lib

          var res = utils.fast_nearest(this.ohlcv, nt);
          var cndl = this.ohlcv[res[0]];
          var off = (nt - cndl[0]) / this.interval_ms;
          this["goto"](res[0] + off);
        } catch (e) {
          this["goto"](this.ti_map.t2i(this._data_t));
        }
      }
    },
    save_data_t: function save_data_t() {
      this._data_t = this.ti_map.i2t(this.range[1]); // save as t
    }
  },
  data: function data() {
    return {
      _data_n0: null,
      _data_len: 0,
      _data_t: 0
    };
  }
});
;// CONCATENATED MODULE: ./src/components/js/ti_mapping.js




// Time-index mapping (for non-linear t-axis)

var MAX_ARR = Math.pow(2, 32); // 3 MODES of index calculation for overlays/subcharts:
// ::: indexSrc :::
// * "map"      -> use TI mapping functions to detect index
//                 (slowest, for stocks only. DEFAULT)
//
// * "calc"     -> calculate shift between sub & data
//                 (faster, but overlay data should be perfectly
//                  align with the main chart,
//                  1-1 candle/data point. Supports Renko)
//
// * "data"     -> overlay data should come with candle index
//                 (fastest, supports Renko)

var TI = /*#__PURE__*/function () {
  function TI() {
    classCallCheck_classCallCheck(this, TI);

    this.ib = false;
  }

  createClass_createClass(TI, [{
    key: "init",
    value: function init(params, res) {
      var sub = params.sub,
          interval = params.interval,
          meta = params.meta,
          $p = params.$props,
          interval_ms = params.interval_ms,
          sub_start = params.sub_start,
          ib = params.ib;
      this.ti_map = [];
      this.it_map = [];
      this.sub_i = [];
      this.ib = ib;
      this.sub = res;
      this.ss = sub_start;
      this.tf = interval_ms;
      var start = meta.sub_start; // Skip mapping for the regular mode

      if (this.ib) {
        this.map_sub(res);
      }
    } // Make maps for the main subset

  }, {
    key: "map_sub",
    value: function map_sub(res) {
      for (var i = 0; i < res.length; i++) {
        var t = res[i][0];

        var _i = this.ss + i;

        this.ti_map[t] = _i;
        this.it_map[_i] = t; // Overwrite t with i

        var copy = _toConsumableArray(res[i]);

        copy[0] = _i;
        this.sub_i.push(copy);
      }
    } // Map overlay data
    // TODO: parse() called 3 times instead of 2 for 'spx_sample.json'

  }, {
    key: "parse",
    value: function parse(data, mode) {
      if (!this.ib || !this.sub[0] || mode === 'data') return data;
      var res = [];
      var k = 0; // Candlestick index

      if (mode === 'calc') {
        var shift = utils.index_shift(this.sub, data);

        for (var i = 0; i < data.length; i++) {
          var _i = this.ss + i;

          var copy = _toConsumableArray(data[i]);

          copy[0] = _i + shift;
          res.push(copy);
        }

        return res;
      } // If indicator data starts after ohlcv, calc the first index


      if (data.length) {
        try {
          var k1 = utils.fast_nearest(this.sub, data[0][0])[0];
          if (k1 !== null && k1 >= 0) k = k1;
        } catch (e) {}
      }

      var t0 = this.sub[0][0];
      var tN = this.sub[this.sub.length - 1][0];

      for (var i = 0; i < data.length; i++) {
        var _copy = _toConsumableArray(data[i]);

        var tk = this.sub[k][0];
        var t = data[i][0];
        var index = this.ti_map[t];

        if (index === undefined) {
          // Linear extrapolation
          if (t < t0 || t > tN) {
            index = this.ss + k - (tk - t) / this.tf;
            t = data[i + 1] ? data[i + 1][0] : undefined;
          } // Linear interpolation
          else {
              var tk2 = this.sub[k + 1][0];
              index = tk === tk2 ? this.ss + k : this.ss + k + (t - tk) / (tk2 - tk);
              t = data[i + 1] ? data[i + 1][0] : undefined;
            }
        } // Race of data points & sub points (ohlcv)
        // (like turn based increments)


        while (k + 1 < this.sub.length - 1 && t > this.sub[k + 1][0]) {
          k++;
          tk = this.sub[k][0];
        }

        _copy[0] = index;
        res.push(_copy);
      }

      return res;
    } // index => time

  }, {
    key: "i2t",
    value: function i2t(i) {
      if (!this.ib || !this.sub.length) return i; // Regular mode
      // Discrete mapping

      var res = this.it_map[i];
      if (res !== undefined) return res; // Linear extrapolation
      else if (i >= this.ss + this.sub_i.length) {
          var di = i - (this.ss + this.sub_i.length) + 1;
          var last = this.sub[this.sub.length - 1];
          return last[0] + di * this.tf;
        } else if (i < this.ss) {
          var _di = i - this.ss;

          return this.sub[0][0] + _di * this.tf;
        } // Linear Interpolation

      var i1 = Math.floor(i) - this.ss;
      var i2 = i1 + 1;
      var len = this.sub.length;
      if (i2 >= len) i2 = len - 1;
      var sub1 = this.sub[i1];
      var sub2 = this.sub[i2];

      if (sub1 && sub2) {
        var t1 = sub1[0];
        var t2 = sub2[0];
        return t1 + (t2 - t1) * (i - i1 - this.ss);
      }

      return undefined;
    } // Map or bypass depending on the mode

  }, {
    key: "i2t_mode",
    value: function i2t_mode(i, mode) {
      return mode === 'data' ? i : this.i2t(i);
    } // time => index
    // TODO: when switch from IB mode to regular tools
    // disappear (bc there is no more mapping)

  }, {
    key: "t2i",
    value: function t2i(t) {
      if (!this.sub.length) return undefined; // Discrete mapping

      var res = this.ti_map[t];
      if (res !== undefined) return res;
      var t0 = this.sub[0][0];
      var tN = this.sub[this.sub.length - 1][0]; // Linear extrapolation

      if (t < t0) {
        return this.ss - (t0 - t) / this.tf;
      } else if (t > tN) {
        var k = this.sub.length - 1;
        return this.ss + k - (tN - t) / this.tf;
      }

      try {
        // Linear Interpolation
        var i = utils.fast_nearest(this.sub, t);
        var tk = this.sub[i[0]][0];
        var tk2 = this.sub[i[1]][0];

        var _k = (t - tk) / (tk2 - tk);

        return this.ss + i[0] + _k * (i[1] - i[0]);
      } catch (e) {}

      return undefined;
    } // Auto detect: is it time or index?
    // Assuming that index-based mode is ON

  }, {
    key: "smth2i",
    value: function smth2i(smth) {
      if (smth > MAX_ARR) {
        return this.t2i(smth); // it was time
      } else {
          return smth; // it was an index
        }
    }
  }, {
    key: "smth2t",
    value: function smth2t(smth) {
      if (smth < MAX_ARR) {
        return this.i2t(smth); // it was an index
      } else {
          return smth; // it was time
        }
    } // Global Time => Index (uses all data, approx. method)
    // Used by tv.goto()

  }, {
    key: "gt2i",
    value: function gt2i(smth, ohlcv) {
      if (smth > MAX_ARR) {
        var E = 0.1; // Fixes the arrayslicer bug

        var _Utils$fast_nearest = utils.fast_nearest(ohlcv, smth + E),
            _Utils$fast_nearest2 = _slicedToArray(_Utils$fast_nearest, 2),
            i1 = _Utils$fast_nearest2[0],
            i2 = _Utils$fast_nearest2[1];

        if (typeof i1 === 'number') {
          return i1;
        } else {
          return this.t2i(smth); // fallback
        }
      } else {
          return smth; // it was an index
        }
    }
  }]);

  return TI;
}();


;// CONCATENATED MODULE: ./node_modules/babel-loader/lib/index.js!./node_modules/vue-loader/lib/index.js??vue-loader-options!./src/components/Chart.vue?vue&type=script&lang=js&


//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//











/* harmony default export */ const Chartvue_type_script_lang_js_ = ({
  name: 'Chart',
  props: ['title_txt', 'data', 'width', 'height', 'font', 'colors', 'overlays', 'tv_id', 'config', 'buttons', 'toolbar', 'ib', 'skin', 'timezone'],
  mixins: [shaders, datatrack],
  components: {
    GridSection: Section,
    Botbar: components_Botbar,
    Keyboard: Keyboard
  },
  created: function created() {
    // Context for text measurements
    this.ctx = new context(this.$props); // Initial layout (All measurments for the chart)

    this.init_range();
    this.sub = this.subset();
    utils.overwrite(this.range, this.range); // Fix for IB mode

    this._layout = new layout(this); // Updates current cursor values

    this.updater = new updater(this);
    this.update_last_values();
    this.init_shaders(this.skin);
  },
  methods: {
    range_changed: function range_changed(r) {
      // Overwite & keep the original references
      // Quick fix for IB mode (switch 2 next lines)
      // TODO: wtf?
      var sub = this.subset(r);
      utils.overwrite(this.range, r);
      utils.overwrite(this.sub, sub);
      this.update_layout();
      this.$emit('range-changed', r);
      if (this.$props.ib) this.save_data_t();
    },
    "goto": function goto(t) {
      var dt = this.range[1] - this.range[0];
      this.range_changed([t - dt, t]);
    },
    setRange: function setRange(t1, t2) {
      this.range_changed([t1, t2]);
    },
    cursor_changed: function cursor_changed(e) {
      if (e.mode) this.cursor.mode = e.mode;

      if (this.cursor.mode !== 'explore') {
        this.updater.sync(e);
      }

      if (this._hook_xchanged) this.ce('?x-changed', e);
    },
    cursor_locked: function cursor_locked(state) {
      if (this.cursor.scroll_lock && state) return;
      this.cursor.locked = state;
      if (this._hook_xlocked) this.ce('?x-locked', state);
    },
    calc_interval: function calc_interval() {
      var _this = this;

      var tf = utils.parse_tf(this.forced_tf);
      if (this.ohlcv.length < 2 && !tf) return;
      this.interval_ms = tf || utils.detect_interval(this.ohlcv);
      this.interval = this.$props.ib ? 1 : this.interval_ms;
      utils.warn(function () {
        return _this.$props.ib && !_this.chart.tf;
      }, constants.IB_TF_WARN, constants.SECOND);
    },
    set_ytransform: function set_ytransform(s) {
      var obj = this.y_transforms[s.grid_id] || {};
      Object.assign(obj, s);
      this.$set(this.y_transforms, s.grid_id, obj);
      this.update_layout();
      utils.overwrite(this.range, this.range);
    },
    default_range: function default_range() {
      var dl = this.$props.config.DEFAULT_LEN;
      var ml = this.$props.config.MINIMUM_LEN + 0.5;
      var l = this.ohlcv.length - 1;
      if (this.ohlcv.length < 2) return;

      if (this.ohlcv.length <= dl) {
        var s = 0,
            d = ml;
      } else {
        s = l - dl, d = 0.5;
      }

      if (!this.$props.ib) {
        utils.overwrite(this.range, [this.ohlcv[s][0] - this.interval * d, this.ohlcv[l][0] + this.interval * ml]);
      } else {
        utils.overwrite(this.range, [s - this.interval * d, l + this.interval * ml]);
      }
    },
    subset: function subset(range) {
      if (range === void 0) {
        range = this.range;
      }

      var _this$filter = this.filter(this.ohlcv, range[0] - this.interval, range[1]),
          _this$filter2 = _slicedToArray(_this$filter, 2),
          res = _this$filter2[0],
          index = _this$filter2[1];

      this.ti_map = new TI();

      if (res) {
        this.sub_start = index;
        this.ti_map.init(this, res);
        if (!this.$props.ib) return res || [];
        return this.ti_map.sub_i;
      }

      return [];
    },
    common_props: function common_props() {
      return {
        title_txt: this.chart.name || this.$props.title_txt,
        layout: this._layout,
        sub: this.sub,
        range: this.range,
        interval: this.interval,
        cursor: this.cursor,
        colors: this.$props.colors,
        font: this.$props.font,
        y_ts: this.y_transforms,
        tv_id: this.$props.tv_id,
        config: this.$props.config,
        buttons: this.$props.buttons,
        meta: this.meta,
        skin: this.$props.skin
      };
    },
    overlay_subset: function overlay_subset(source, side) {
      var _this2 = this;

      return source.map(function (d, i) {
        var res = utils.fast_filter(d.data, _this2.ti_map.i2t_mode(_this2.range[0] - _this2.interval, d.indexSrc), _this2.ti_map.i2t_mode(_this2.range[1], d.indexSrc));
        return {
          type: d.type,
          name: utils.format_name(d),
          data: _this2.ti_map.parse(res[0] || [], d.indexSrc || 'map'),
          settings: d.settings || _this2.settings_ov,
          grid: d.grid || {},
          tf: utils.parse_tf(d.tf),
          i0: res[1],
          loading: d.loading,
          last: (_this2.last_values[side] || [])[i]
        };
      });
    },
    section_props: function section_props(i) {
      return i === 0 ? this.main_section : this.sub_section;
    },
    init_range: function init_range() {
      this.calc_interval();
      this.default_range();
    },
    layer_meta_props: function layer_meta_props(d) {
      // TODO: check reactivity when layout is changed
      if (!(d.grid_id in this.layers_meta)) {
        this.$set(this.layers_meta, d.grid_id, {});
      }

      this.$set(this.layers_meta[d.grid_id], d.layer_id, d); // Rerender

      this.update_layout();
    },
    remove_meta_props: function remove_meta_props(grid_id, layer_id) {
      if (grid_id in this.layers_meta) {
        this.$delete(this.layers_meta[grid_id], layer_id);
      }
    },
    emit_custom_event: function emit_custom_event(d) {
      this.on_shader_event(d, 'botbar');
      this.$emit('custom-event', d);

      if (d.event === 'remove-layer-meta') {
        this.remove_meta_props.apply(this, _toConsumableArray(d.args));
      }
    },
    update_layout: function update_layout(clac_tf) {
      if (clac_tf) this.calc_interval();
      var lay = new layout(this);
      utils.copy_layout(this._layout, lay);
      if (this._hook_update) this.ce('?chart-update', lay);
    },
    legend_button_click: function legend_button_click(event) {
      this.$emit('legend-button-click', event);
    },
    register_kb: function register_kb(event) {
      if (!this.$refs.keyboard) return;
      this.$refs.keyboard.register(event);
    },
    remove_kb: function remove_kb(event) {
      if (!this.$refs.keyboard) return;
      this.$refs.keyboard.remove(event);
    },
    update_last_values: function update_last_values() {
      var _this3 = this;

      this.last_candle = this.ohlcv ? this.ohlcv[this.ohlcv.length - 1] : undefined;
      this.last_values = {
        onchart: [],
        offchart: []
      };
      this.onchart.forEach(function (x, i) {
        var d = x.data || [];
        _this3.last_values.onchart[i] = d[d.length - 1];
      });
      this.offchart.forEach(function (x, i) {
        var d = x.data || [];
        _this3.last_values.offchart[i] = d[d.length - 1];
      });
    },
    // Hook events for extensions
    ce: function ce(event) {
      for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
        args[_key - 1] = arguments[_key];
      }

      this.emit_custom_event({
        event: event,
        args: args
      });
    },
    // Set hooks list (called from an extension)
    hooks: function hooks() {
      var _this4 = this;

      for (var _len2 = arguments.length, list = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
        list[_key2] = arguments[_key2];
      }

      list.forEach(function (x) {
        return _this4["_hook_".concat(x)] = true;
      });
    }
  },
  computed: {
    // Component-specific props subsets:
    main_section: function main_section() {
      var p = Object.assign({}, this.common_props());
      p.data = this.overlay_subset(this.onchart, 'onchart');
      p.data.push({
        type: this.chart.type || 'Candles',
        main: true,
        data: this.sub,
        i0: this.sub_start,
        settings: this.chart.settings || this.settings_ohlcv,
        grid: this.chart.grid || {},
        last: this.last_candle
      });
      p.overlays = this.$props.overlays;
      return p;
    },
    sub_section: function sub_section() {
      var p = Object.assign({}, this.common_props());
      p.data = this.overlay_subset(this.offchart, 'offchart');
      p.overlays = this.$props.overlays;
      return p;
    },
    botbar_props: function botbar_props() {
      var p = Object.assign({}, this.common_props());
      p.width = p.layout.botbar.width;
      p.height = p.layout.botbar.height;
      p.rerender = this.rerender;
      return p;
    },
    offsub: function offsub() {
      return this.overlay_subset(this.offchart, 'offchart');
    },
    // Datasets: candles, onchart, offchart indicators
    ohlcv: function ohlcv() {
      return this.$props.data.ohlcv || this.chart.data || [];
    },
    chart: function chart() {
      return this.$props.data.chart || {
        grid: {}
      };
    },
    onchart: function onchart() {
      return this.$props.data.onchart || [];
    },
    offchart: function offchart() {
      return this.$props.data.offchart || [];
    },
    filter: function filter() {
      return this.$props.ib ? utils.fast_filter_i : utils.fast_filter;
    },
    styles: function styles() {
      var w = this.$props.toolbar ? this.$props.config.TOOLBAR : 0;
      return {
        'margin-left': "".concat(w, "px")
      };
    },
    meta: function meta() {
      return {
        last: this.last_candle,
        sub_start: this.sub_start,
        activated: this.activated
      };
    },
    forced_tf: function forced_tf() {
      return this.chart.tf;
    }
  },
  data: function data() {
    return {
      // Current data slice
      sub: [],
      // Time range
      range: [],
      // Candlestick interval
      interval: 0,
      // Crosshair states
      cursor: {
        x: null,
        y: null,
        t: null,
        y$: null,
        grid_id: null,
        locked: false,
        values: {},
        scroll_lock: false,
        mode: utils.xmode()
      },
      // A trick to re-render botbar
      rerender: 0,
      // Layers meta-props (changing behaviour)
      layers_meta: {},
      // Y-transforms (for y-zoom and -shift)
      y_transforms: {},
      // Default OHLCV settings (when using DataStructure v1.0)
      settings_ohlcv: {},
      // Default overlay settings
      settings_ov: {},
      // Meta data
      last_candle: [],
      last_values: {},
      sub_start: undefined,
      activated: false
    };
  },
  watch: {
    width: function width() {
      this.update_layout();
      if (this._hook_resize) this.ce('?chart-resize');
    },
    height: function height() {
      this.update_layout();
      if (this._hook_resize) this.ce('?chart-resize');
    },
    ib: function ib(nw) {
      if (!nw) {
        // Change range index => time
        var t1 = this.ti_map.i2t(this.range[0]);
        var t2 = this.ti_map.i2t(this.range[1]);
        utils.overwrite(this.range, [t1, t2]);
        this.interval = this.interval_ms;
      } else {
        this.init_range(); // TODO: calc index range instead

        utils.overwrite(this.range, this.range);
        this.interval = 1;
      }

      var sub = this.subset();
      utils.overwrite(this.sub, sub);
      this.update_layout();
    },
    timezone: function timezone() {
      this.update_layout();
    },
    colors: function colors() {
      utils.overwrite(this.range, this.range);
    },
    forced_tf: function forced_tf(n, p) {
      this.update_layout(true);
      this.ce('exec-all-scripts');
    },
    data: {
      handler: function handler(n, p) {
        if (!this.sub.length) this.init_range();
        var sub = this.subset(); // Fixes Infinite loop warn, when the subset is empty
        // TODO: Consider removing 'sub' from data entirely

        if (this.sub.length || sub.length) {
          utils.overwrite(this.sub, sub);
        }

        var nw = this.data_changed();
        this.update_layout(nw);
        utils.overwrite(this.range, this.range);
        this.cursor.scroll_lock = !!n.scrollLock;

        if (n.scrollLock && this.cursor.locked) {
          this.cursor.locked = false;
        }

        if (this._hook_data) this.ce('?chart-data', nw);
        this.update_last_values(); // TODO: update legend values for overalys

        this.rerender++;
      },
      deep: true
    }
  }
});
;// CONCATENATED MODULE: ./src/components/Chart.vue?vue&type=script&lang=js&
 /* harmony default export */ const components_Chartvue_type_script_lang_js_ = (Chartvue_type_script_lang_js_); 
;// CONCATENATED MODULE: ./src/components/Chart.vue





/* normalize component */
;
var Chart_component = normalizeComponent(
  components_Chartvue_type_script_lang_js_,
  Chartvue_type_template_id_4d06a4de_render,
  Chartvue_type_template_id_4d06a4de_staticRenderFns,
  false,
  null,
  null,
  null
  
)

/* hot reload */
if (false) { var Chart_api; }
Chart_component.options.__file = "src/components/Chart.vue"
/* harmony default export */ const Chart = (Chart_component.exports);
;// CONCATENATED MODULE: ./node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!./node_modules/vue-loader/lib/index.js??vue-loader-options!./src/components/Toolbar.vue?vue&type=template&id=021887fb&
var Toolbarvue_type_template_id_021887fb_render = function() {
  var _vm = this
  var _h = _vm.$createElement
  var _c = _vm._self._c || _h
  return _c(
    "div",
    {
      key: _vm.tool_count,
      staticClass: "trading-vue-toolbar",
      style: _vm.styles
    },
    _vm._l(_vm.groups, function(tool, i) {
      return tool.icon && !tool.hidden
        ? _c("toolbar-item", {
            key: i,
            attrs: {
              data: tool,
              subs: _vm.sub_map,
              dc: _vm.data,
              config: _vm.config,
              colors: _vm.colors,
              selected: _vm.is_selected(tool)
            },
            on: { "item-selected": _vm.selected }
          })
        : _vm._e()
    }),
    1
  )
}
var Toolbarvue_type_template_id_021887fb_staticRenderFns = []
Toolbarvue_type_template_id_021887fb_render._withStripped = true


;// CONCATENATED MODULE: ./src/components/Toolbar.vue?vue&type=template&id=021887fb&

;// CONCATENATED MODULE: ./node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!./node_modules/vue-loader/lib/index.js??vue-loader-options!./src/components/ToolbarItem.vue?vue&type=template&id=227b3c2e&
var ToolbarItemvue_type_template_id_227b3c2e_render = function() {
  var _vm = this
  var _h = _vm.$createElement
  var _c = _vm._self._c || _h
  return _c(
    "div",
    {
      class: ["trading-vue-tbitem", _vm.selected ? "selected-item" : ""],
      style: _vm.item_style,
      on: {
        click: function($event) {
          return _vm.emit_selected("click")
        },
        mousedown: _vm.mousedown,
        touchstart: _vm.mousedown,
        touchend: function($event) {
          return _vm.emit_selected("touch")
        }
      }
    },
    [
      _c("div", {
        staticClass: "trading-vue-tbicon tvjs-pixelated",
        style: _vm.icon_style
      }),
      _vm._v(" "),
      _vm.data.group
        ? _c(
            "div",
            {
              staticClass: "trading-vue-tbitem-exp",
              style: _vm.exp_style,
              on: {
                click: _vm.exp_click,
                mousedown: _vm.expmousedown,
                mouseover: _vm.expmouseover,
                mouseleave: _vm.expmouseleave
              }
            },
            [_vm._v("\n        \n    ")]
          )
        : _vm._e(),
      _vm._v(" "),
      _vm.show_exp_list
        ? _c("item-list", {
            attrs: {
              config: _vm.config,
              items: _vm.data.items,
              colors: _vm.colors,
              dc: _vm.dc
            },
            on: {
              "close-list": _vm.close_list,
              "item-selected": _vm.emit_selected_sub
            }
          })
        : _vm._e()
    ],
    1
  )
}
var ToolbarItemvue_type_template_id_227b3c2e_staticRenderFns = []
ToolbarItemvue_type_template_id_227b3c2e_render._withStripped = true


;// CONCATENATED MODULE: ./src/components/ToolbarItem.vue?vue&type=template&id=227b3c2e&

;// CONCATENATED MODULE: ./node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!./node_modules/vue-loader/lib/index.js??vue-loader-options!./src/components/ItemList.vue?vue&type=template&id=c50b23fe&
var ItemListvue_type_template_id_c50b23fe_render = function() {
  var _vm = this
  var _h = _vm.$createElement
  var _c = _vm._self._c || _h
  return _c(
    "div",
    {
      staticClass: "tvjs-item-list",
      style: _vm.list_style(),
      on: { mousedown: _vm.thismousedown }
    },
    _vm._l(_vm.items, function(item) {
      return !item.hidden
        ? _c(
            "div",
            {
              class: _vm.item_class(item),
              style: _vm.item_style(item),
              on: {
                click: function(e) {
                  return _vm.item_click(e, item)
                }
              }
            },
            [
              _c("div", {
                staticClass: "trading-vue-tbicon tvjs-pixelated",
                style: _vm.icon_style(item)
              }),
              _vm._v(" "),
              _c("div", [_vm._v(_vm._s(item.type))])
            ]
          )
        : _vm._e()
    }),
    0
  )
}
var ItemListvue_type_template_id_c50b23fe_staticRenderFns = []
ItemListvue_type_template_id_c50b23fe_render._withStripped = true


;// CONCATENATED MODULE: ./src/components/ItemList.vue?vue&type=template&id=c50b23fe&

;// CONCATENATED MODULE: ./node_modules/babel-loader/lib/index.js!./node_modules/vue-loader/lib/index.js??vue-loader-options!./src/components/ItemList.vue?vue&type=script&lang=js&
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
/* harmony default export */ const ItemListvue_type_script_lang_js_ = ({
  name: 'ItemList',
  props: ['config', 'items', 'colors', 'dc'],
  mounted: function mounted() {
    window.addEventListener('mousedown', this.onmousedown);
  },
  beforeDestroy: function beforeDestroy() {
    window.removeEventListener('mousedown', this.onmousedown);
  },
  methods: {
    list_style: function list_style() {
      var conf = this.$props.config;
      var w = conf.TOOLBAR;
      var brd = this.colors.tbListBorder || this.colors.grid;
      var bstl = "1px solid ".concat(brd);
      return {
        left: "".concat(w, "px"),
        background: this.colors.back,
        borderTop: bstl,
        borderRight: bstl,
        borderBottom: bstl
      };
    },
    item_class: function item_class(item) {
      if (this.dc.tool === item.type) {
        return "tvjs-item-list-item selected-item";
      }

      return "tvjs-item-list-item";
    },
    item_style: function item_style(item) {
      var conf = this.$props.config;
      var h = conf.TB_ICON + conf.TB_ITEM_M * 2 + 8;
      var sel = this.dc.tool === item.type;
      return {
        height: "".concat(h, "px"),
        color: sel ? undefined : "#888888"
      };
    },
    icon_style: function icon_style(data) {
      var conf = this.$props.config;
      var br = conf.TB_ICON_BRI;
      var im = conf.TB_ITEM_M;
      return {
        'background-image': "url(".concat(data.icon, ")"),
        'width': '25px',
        'height': '25px',
        'margin': "".concat(im, "px"),
        'filter': "brightness(".concat(br, ")")
      };
    },
    item_click: function item_click(e, item) {
      e.cancelBubble = true;
      this.$emit('item-selected', item);
      this.$emit('close-list');
    },
    onmousedown: function onmousedown() {
      this.$emit('close-list');
    },
    thismousedown: function thismousedown(e) {
      e.stopPropagation();
    }
  },
  computed: {},
  data: function data() {
    return {};
  }
});
;// CONCATENATED MODULE: ./src/components/ItemList.vue?vue&type=script&lang=js&
 /* harmony default export */ const components_ItemListvue_type_script_lang_js_ = (ItemListvue_type_script_lang_js_); 
// EXTERNAL MODULE: ./node_modules/vue-style-loader/index.js!./node_modules/css-loader/dist/cjs.js!./node_modules/vue-loader/lib/loaders/stylePostLoader.js!./node_modules/vue-loader/lib/index.js??vue-loader-options!./src/components/ItemList.vue?vue&type=style&index=0&lang=css&
var ItemListvue_type_style_index_0_lang_css_ = __nested_webpack_require_9759__(807);
;// CONCATENATED MODULE: ./src/components/ItemList.vue?vue&type=style&index=0&lang=css&

;// CONCATENATED MODULE: ./src/components/ItemList.vue



;


/* normalize component */

var ItemList_component = normalizeComponent(
  components_ItemListvue_type_script_lang_js_,
  ItemListvue_type_template_id_c50b23fe_render,
  ItemListvue_type_template_id_c50b23fe_staticRenderFns,
  false,
  null,
  null,
  null
  
)

/* hot reload */
if (false) { var ItemList_api; }
ItemList_component.options.__file = "src/components/ItemList.vue"
/* harmony default export */ const ItemList = (ItemList_component.exports);
;// CONCATENATED MODULE: ./node_modules/babel-loader/lib/index.js!./node_modules/vue-loader/lib/index.js??vue-loader-options!./src/components/ToolbarItem.vue?vue&type=script&lang=js&
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//


/* harmony default export */ const ToolbarItemvue_type_script_lang_js_ = ({
  name: 'ToolbarItem',
  props: ['data', 'selected', 'colors', 'tv_id', 'config', 'dc', 'subs'],
  components: {
    ItemList: ItemList
  },
  mounted: function mounted() {
    if (this.data.group) {
      var type = this.subs[this.data.group];
      var item = this.data.items.find(function (x) {
        return x.type === type;
      });
      if (item) this.sub_item = item;
    }
  },
  methods: {
    mousedown: function mousedown(e) {
      var _this = this;

      this.click_start = utils.now();
      this.click_id = setTimeout(function () {
        _this.show_exp_list = true;
      }, this.config.TB_ICON_HOLD);
    },
    expmouseover: function expmouseover() {
      this.exp_hover = true;
    },
    expmouseleave: function expmouseleave() {
      this.exp_hover = false;
    },
    expmousedown: function expmousedown(e) {
      if (this.show_exp_list) e.stopPropagation();
    },
    emit_selected: function emit_selected(src) {
      if (utils.now() - this.click_start > this.config.TB_ICON_HOLD) return;
      clearTimeout(this.click_id); //if (Utils.is_mobile && src === 'click') return
      // TODO: double firing

      if (!this.data.group) {
        this.$emit('item-selected', this.data);
      } else {
        var item = this.sub_item || this.data.items[0];
        this.$emit('item-selected', item);
      }
    },
    emit_selected_sub: function emit_selected_sub(item) {
      this.$emit('item-selected', item);
      this.sub_item = item;
    },
    exp_click: function exp_click(e) {
      if (!this.data.group) return;
      e.cancelBubble = true;
      this.show_exp_list = !this.show_exp_list;
    },
    close_list: function close_list() {
      this.show_exp_list = false;
    }
  },
  computed: {
    item_style: function item_style() {
      if (this.$props.data.type === 'System:Splitter') {
        return this.splitter;
      }

      var conf = this.$props.config;
      var im = conf.TB_ITEM_M;
      var m = (conf.TOOLBAR - conf.TB_ICON) * 0.5 - im;
      var s = conf.TB_ICON + im * 2;
      var b = this.exp_hover ? 0 : 3;
      return {
        'width': "".concat(s, "px"),
        'height': "".concat(s, "px"),
        'margin': "8px ".concat(m, "px 0px ").concat(m, "px"),
        'border-radius': "3px ".concat(b, "px ").concat(b, "px 3px")
      };
    },
    icon_style: function icon_style() {
      if (this.$props.data.type === 'System:Splitter') {
        return {};
      }

      var conf = this.$props.config;
      var br = conf.TB_ICON_BRI;
      var sz = conf.TB_ICON;
      var im = conf.TB_ITEM_M;
      var ic = this.sub_item ? this.sub_item.icon : this.$props.data.icon;
      return {
        'background-image': "url(".concat(ic, ")"),
        'width': "".concat(sz, "px"),
        'height': "".concat(sz, "px"),
        'margin': "".concat(im, "px"),
        'filter': "brightness(".concat(br, ")")
      };
    },
    exp_style: function exp_style() {
      var conf = this.$props.config;
      var im = conf.TB_ITEM_M;
      var s = conf.TB_ICON * 0.5 + im;
      var p = (conf.TOOLBAR - s * 2) / 4;
      return {
        padding: "".concat(s, "px ").concat(p, "px"),
        transform: this.show_exp_list ? "scale(-0.6, 1)" : "scaleX(0.6)"
      };
    },
    splitter: function splitter() {
      var conf = this.$props.config;
      var colors = this.$props.colors;
      var c = colors.grid;
      var im = conf.TB_ITEM_M;
      var m = (conf.TOOLBAR - conf.TB_ICON) * 0.5 - im;
      var s = conf.TB_ICON + im * 2;
      return {
        'width': "".concat(s, "px"),
        'height': '1px',
        'margin': "8px ".concat(m, "px 8px ").concat(m, "px"),
        'background-color': c
      };
    }
  },
  data: function data() {
    return {
      exp_hover: false,
      show_exp_list: false,
      sub_item: null
    };
  }
});
;// CONCATENATED MODULE: ./src/components/ToolbarItem.vue?vue&type=script&lang=js&
 /* harmony default export */ const components_ToolbarItemvue_type_script_lang_js_ = (ToolbarItemvue_type_script_lang_js_); 
// EXTERNAL MODULE: ./node_modules/vue-style-loader/index.js!./node_modules/css-loader/dist/cjs.js!./node_modules/vue-loader/lib/loaders/stylePostLoader.js!./node_modules/vue-loader/lib/index.js??vue-loader-options!./src/components/ToolbarItem.vue?vue&type=style&index=0&lang=css&
var ToolbarItemvue_type_style_index_0_lang_css_ = __nested_webpack_require_9759__(501);
;// CONCATENATED MODULE: ./src/components/ToolbarItem.vue?vue&type=style&index=0&lang=css&

;// CONCATENATED MODULE: ./src/components/ToolbarItem.vue



;


/* normalize component */

var ToolbarItem_component = normalizeComponent(
  components_ToolbarItemvue_type_script_lang_js_,
  ToolbarItemvue_type_template_id_227b3c2e_render,
  ToolbarItemvue_type_template_id_227b3c2e_staticRenderFns,
  false,
  null,
  null,
  null
  
)

/* hot reload */
if (false) { var ToolbarItem_api; }
ToolbarItem_component.options.__file = "src/components/ToolbarItem.vue"
/* harmony default export */ const ToolbarItem = (ToolbarItem_component.exports);
;// CONCATENATED MODULE: ./node_modules/babel-loader/lib/index.js!./node_modules/vue-loader/lib/index.js??vue-loader-options!./src/components/Toolbar.vue?vue&type=script&lang=js&
function Toolbarvue_type_script_lang_js_createForOfIteratorHelper(o, allowArrayLike) { var it; if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (it = Toolbarvue_type_script_lang_js_unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = o[Symbol.iterator](); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it["return"] != null) it["return"](); } finally { if (didErr) throw err; } } }; }

function Toolbarvue_type_script_lang_js_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return Toolbarvue_type_script_lang_js_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return Toolbarvue_type_script_lang_js_arrayLikeToArray(o, minLen); }

function Toolbarvue_type_script_lang_js_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//

/* harmony default export */ const Toolbarvue_type_script_lang_js_ = ({
  name: 'Toolbar',
  props: ['data', 'height', 'colors', 'tv_id', 'config'],
  components: {
    ToolbarItem: ToolbarItem
  },
  mounted: function mounted() {},
  methods: {
    selected: function selected(tool) {
      this.$emit('custom-event', {
        event: 'tool-selected',
        args: [tool.type]
      });

      if (tool.group) {
        // TODO: emit the sub map to DC (save)
        this.sub_map[tool.group] = tool.type;
      }
    },
    is_selected: function is_selected(tool) {
      var _this = this;

      if (tool.group) {
        return !!tool.items.find(function (x) {
          return x.type === _this.data.tool;
        });
      }

      return tool.type === this.data.tool;
    }
  },
  computed: {
    styles: function styles() {
      var colors = this.$props.colors;
      var b = this.$props.config.TB_BORDER;
      var w = this.$props.config.TOOLBAR - b;
      var c = colors.grid;
      var cb = colors.tbBack || colors.back;
      var brd = colors.tbBorder || colors.scale;
      var st = this.$props.config.TB_B_STYLE;
      return {
        'width': "".concat(w, "px"),
        'height': "".concat(this.$props.height - 3, "px"),
        'background-color': cb,
        'border-right': "".concat(b, "px ").concat(st, " ").concat(brd)
      };
    },
    groups: function groups() {
      var arr = [];

      var _iterator = Toolbarvue_type_script_lang_js_createForOfIteratorHelper(this.data.tools || []),
          _step;

      try {
        for (_iterator.s(); !(_step = _iterator.n()).done;) {
          var tool = _step.value;

          if (!tool.group) {
            arr.push(tool);
            continue;
          }

          var g = arr.find(function (x) {
            return x.group === tool.group;
          });

          if (!g) {
            arr.push({
              group: tool.group,
              icon: tool.icon,
              items: [tool]
            });
          } else {
            g.items.push(tool);
          }
        }
      } catch (err) {
        _iterator.e(err);
      } finally {
        _iterator.f();
      }

      return arr;
    }
  },
  watch: {
    data: {
      handler: function handler(n) {
        // For some reason Vue.js doesn't want to
        // update 'tools' automatically when new item
        // is pushed/removed. Yo, Vue, I herd you
        // you want more dirty tricks?
        if (n.tools) this.tool_count = n.tools.length;
      },
      deep: true
    }
  },
  data: function data() {
    return {
      tool_count: 0,
      sub_map: {}
    };
  }
});
;// CONCATENATED MODULE: ./src/components/Toolbar.vue?vue&type=script&lang=js&
 /* harmony default export */ const components_Toolbarvue_type_script_lang_js_ = (Toolbarvue_type_script_lang_js_); 
// EXTERNAL MODULE: ./node_modules/vue-style-loader/index.js!./node_modules/css-loader/dist/cjs.js!./node_modules/vue-loader/lib/loaders/stylePostLoader.js!./node_modules/vue-loader/lib/index.js??vue-loader-options!./src/components/Toolbar.vue?vue&type=style&index=0&lang=css&
var Toolbarvue_type_style_index_0_lang_css_ = __nested_webpack_require_9759__(153);
;// CONCATENATED MODULE: ./src/components/Toolbar.vue?vue&type=style&index=0&lang=css&

;// CONCATENATED MODULE: ./src/components/Toolbar.vue



;


/* normalize component */

var Toolbar_component = normalizeComponent(
  components_Toolbarvue_type_script_lang_js_,
  Toolbarvue_type_template_id_021887fb_render,
  Toolbarvue_type_template_id_021887fb_staticRenderFns,
  false,
  null,
  null,
  null
  
)

/* hot reload */
if (false) { var Toolbar_api; }
Toolbar_component.options.__file = "src/components/Toolbar.vue"
/* harmony default export */ const Toolbar = (Toolbar_component.exports);
;// CONCATENATED MODULE: ./node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!./node_modules/vue-loader/lib/index.js??vue-loader-options!./src/components/Widgets.vue?vue&type=template&id=5fe4312f&
var Widgetsvue_type_template_id_5fe4312f_render = function() {
  var _vm = this
  var _h = _vm.$createElement
  var _c = _vm._self._c || _h
  return _c(
    "div",
    {
      staticClass: "tvjs-widgets",
      style: { width: _vm.width + "px", height: _vm.height + "px" }
    },
    _vm._l(Object.keys(_vm.map), function(id) {
      return _c(_vm.initw(id), {
        key: id,
        tag: "component",
        attrs: {
          id: id,
          main: _vm.map[id].ctrl,
          data: _vm.map[id].data,
          tv: _vm.tv,
          dc: _vm.dc
        }
      })
    }),
    1
  )
}
var Widgetsvue_type_template_id_5fe4312f_staticRenderFns = []
Widgetsvue_type_template_id_5fe4312f_render._withStripped = true


;// CONCATENATED MODULE: ./src/components/Widgets.vue?vue&type=template&id=5fe4312f&

;// CONCATENATED MODULE: ./node_modules/babel-loader/lib/index.js!./node_modules/vue-loader/lib/index.js??vue-loader-options!./src/components/Widgets.vue?vue&type=script&lang=js&
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
/* harmony default export */ const Widgetsvue_type_script_lang_js_ = ({
  name: 'Widgets',
  props: ['width', 'height', 'map', 'tv', 'dc'],
  methods: {
    initw: function initw(id) {
      return this.$props.map[id].cls;
    }
  }
});
;// CONCATENATED MODULE: ./src/components/Widgets.vue?vue&type=script&lang=js&
 /* harmony default export */ const components_Widgetsvue_type_script_lang_js_ = (Widgetsvue_type_script_lang_js_); 
// EXTERNAL MODULE: ./node_modules/vue-style-loader/index.js!./node_modules/css-loader/dist/cjs.js!./node_modules/vue-loader/lib/loaders/stylePostLoader.js!./node_modules/vue-loader/lib/index.js??vue-loader-options!./src/components/Widgets.vue?vue&type=style&index=0&lang=css&
var Widgetsvue_type_style_index_0_lang_css_ = __nested_webpack_require_9759__(5);
;// CONCATENATED MODULE: ./src/components/Widgets.vue?vue&type=style&index=0&lang=css&

;// CONCATENATED MODULE: ./src/components/Widgets.vue



;


/* normalize component */

var Widgets_component = normalizeComponent(
  components_Widgetsvue_type_script_lang_js_,
  Widgetsvue_type_template_id_5fe4312f_render,
  Widgetsvue_type_template_id_5fe4312f_staticRenderFns,
  false,
  null,
  null,
  null
  
)

/* hot reload */
if (false) { var Widgets_api; }
Widgets_component.options.__file = "src/components/Widgets.vue"
/* harmony default export */ const Widgets = (Widgets_component.exports);
;// CONCATENATED MODULE: ./node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!./node_modules/vue-loader/lib/index.js??vue-loader-options!./src/components/TheTip.vue?vue&type=template&id=2c1770cc&
var TheTipvue_type_template_id_2c1770cc_render = function() {
  var _vm = this
  var _h = _vm.$createElement
  var _c = _vm._self._c || _h
  return _c("div", {
    staticClass: "tvjs-the-tip",
    style: _vm.style,
    domProps: { innerHTML: _vm._s(_vm.data.text) },
    on: {
      mousedown: function($event) {
        return _vm.$emit("remove-me")
      }
    }
  })
}
var TheTipvue_type_template_id_2c1770cc_staticRenderFns = []
TheTipvue_type_template_id_2c1770cc_render._withStripped = true


;// CONCATENATED MODULE: ./src/components/TheTip.vue?vue&type=template&id=2c1770cc&

;// CONCATENATED MODULE: ./node_modules/babel-loader/lib/index.js!./node_modules/vue-loader/lib/index.js??vue-loader-options!./src/components/TheTip.vue?vue&type=script&lang=js&
//
//
//
//
//
//
/* harmony default export */ const TheTipvue_type_script_lang_js_ = ({
  name: 'TheTip',
  props: ['data'],
  mounted: function mounted() {
    var _this = this;

    setTimeout(function () {
      return _this.$emit('remove-me');
    }, 3000);
  },
  computed: {
    style: function style() {
      return {
        background: this.data.color
      };
    }
  }
});
;// CONCATENATED MODULE: ./src/components/TheTip.vue?vue&type=script&lang=js&
 /* harmony default export */ const components_TheTipvue_type_script_lang_js_ = (TheTipvue_type_script_lang_js_); 
// EXTERNAL MODULE: ./node_modules/vue-style-loader/index.js!./node_modules/css-loader/dist/cjs.js!./node_modules/vue-loader/lib/loaders/stylePostLoader.js!./node_modules/vue-loader/lib/index.js??vue-loader-options!./src/components/TheTip.vue?vue&type=style&index=0&lang=css&
var TheTipvue_type_style_index_0_lang_css_ = __nested_webpack_require_9759__(477);
;// CONCATENATED MODULE: ./src/components/TheTip.vue?vue&type=style&index=0&lang=css&

;// CONCATENATED MODULE: ./src/components/TheTip.vue



;


/* normalize component */

var TheTip_component = normalizeComponent(
  components_TheTipvue_type_script_lang_js_,
  TheTipvue_type_template_id_2c1770cc_render,
  TheTipvue_type_template_id_2c1770cc_staticRenderFns,
  false,
  null,
  null,
  null
  
)

/* hot reload */
if (false) { var TheTip_api; }
TheTip_component.options.__file = "src/components/TheTip.vue"
/* harmony default export */ const TheTip = (TheTip_component.exports);
;// CONCATENATED MODULE: ./src/mixins/xcontrol.js
function xcontrol_createForOfIteratorHelper(o, allowArrayLike) { var it; if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (it = xcontrol_unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = o[Symbol.iterator](); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it["return"] != null) it["return"](); } finally { if (didErr) throw err; } } }; }

function xcontrol_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return xcontrol_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return xcontrol_arrayLikeToArray(o, minLen); }

function xcontrol_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

// extensions control
/* harmony default export */ const xcontrol = ({
  mounted: function mounted() {
    this.ctrllist();
    this.skin_styles();
  },
  methods: {
    // Build / rebuild component list
    ctrllist: function ctrllist() {
      this.ctrl_destroy();
      this.controllers = [];

      var _iterator = xcontrol_createForOfIteratorHelper(this.$props.extensions),
          _step;

      try {
        for (_iterator.s(); !(_step = _iterator.n()).done;) {
          var x = _step.value;
          var name = x.Main.__name__;

          if (!this.xSettings[name]) {
            this.$set(this.xSettings, name, {});
          }

          var nc = new x.Main(this, // tv inst
          this.data, // dc
          this.xSettings[name] // settings
          );
          nc.name = name;
          this.controllers.push(nc);
        }
      } catch (err) {
        _iterator.e(err);
      } finally {
        _iterator.f();
      }

      return this.controllers;
    },
    // TODO: preventDefault
    pre_dc: function pre_dc(e) {
      var _iterator2 = xcontrol_createForOfIteratorHelper(this.controllers),
          _step2;

      try {
        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
          var ctrl = _step2.value;

          if (ctrl.update) {
            ctrl.update(e);
          }
        }
      } catch (err) {
        _iterator2.e(err);
      } finally {
        _iterator2.f();
      }
    },
    post_dc: function post_dc(e) {
      var _iterator3 = xcontrol_createForOfIteratorHelper(this.controllers),
          _step3;

      try {
        for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {
          var ctrl = _step3.value;

          if (ctrl.post_update) {
            ctrl.post_update(e);
          }
        }
      } catch (err) {
        _iterator3.e(err);
      } finally {
        _iterator3.f();
      }
    },
    ctrl_destroy: function ctrl_destroy() {
      var _iterator4 = xcontrol_createForOfIteratorHelper(this.controllers),
          _step4;

      try {
        for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {
          var ctrl = _step4.value;
          if (ctrl.destroy) ctrl.destroy();
        }
      } catch (err) {
        _iterator4.e(err);
      } finally {
        _iterator4.f();
      }
    },
    skin_styles: function skin_styles() {
      var id = 'tvjs-skin-styles';
      var stbr = document.getElementById(id);

      if (stbr) {
        var parent = stbr.parentNode;
        parent.removeChild(stbr);
      }

      if (this.skin_proto && this.skin_proto.styles) {
        var sheet = document.createElement('style');
        sheet.setAttribute("id", id);
        sheet.innerHTML = this.skin_proto.styles;
        this.$el.appendChild(sheet);
      }
    }
  },
  computed: {
    ws: function ws() {
      var ws = {};

      var _iterator5 = xcontrol_createForOfIteratorHelper(this.controllers),
          _step5;

      try {
        for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {
          var ctrl = _step5.value;

          if (ctrl.widgets) {
            for (var id in ctrl.widgets) {
              ws[id] = ctrl.widgets[id];
              ws[id].ctrl = ctrl;
            }
          }
        }
      } catch (err) {
        _iterator5.e(err);
      } finally {
        _iterator5.f();
      }

      return ws;
    },
    skins: function skins() {
      var sks = {};

      var _iterator6 = xcontrol_createForOfIteratorHelper(this.$props.extensions),
          _step6;

      try {
        for (_iterator6.s(); !(_step6 = _iterator6.n()).done;) {
          var x = _step6.value;

          for (var id in x.skins || {}) {
            sks[id] = x.skins[id];
          }
        }
      } catch (err) {
        _iterator6.e(err);
      } finally {
        _iterator6.f();
      }

      return sks;
    },
    skin_proto: function skin_proto() {
      return this.skins[this.$props.skin];
    },
    colorpack: function colorpack() {
      var sel = this.skins[this.$props.skin];
      return sel ? sel.colors : undefined;
    }
  },
  watch: {
    // TODO: This is fast & dirty fix, need
    // to fix the actual reactivity problem
    skin: function skin(n, p) {
      if (n !== p) this.resetChart();
      this.skin_styles();
    },
    extensions: function extensions() {
      this.ctrllist();
    },
    xSettings: {
      handler: function handler(n, p) {
        var _iterator7 = xcontrol_createForOfIteratorHelper(this.controllers),
            _step7;

        try {
          for (_iterator7.s(); !(_step7 = _iterator7.n()).done;) {
            var ctrl = _step7.value;

            if (ctrl.onsettings) {
              ctrl.onsettings(n, p);
            }
          }
        } catch (err) {
          _iterator7.e(err);
        } finally {
          _iterator7.f();
        }
      },
      deep: true
    }
  },
  data: function data() {
    return {
      controllers: []
    };
  }
});
;// CONCATENATED MODULE: ./node_modules/babel-loader/lib/index.js!./node_modules/vue-loader/lib/index.js??vue-loader-options!./src/TradingVue.vue?vue&type=script&lang=js&


function TradingVuevue_type_script_lang_js_createForOfIteratorHelper(o, allowArrayLike) { var it; if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (it = TradingVuevue_type_script_lang_js_unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = o[Symbol.iterator](); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it["return"] != null) it["return"](); } finally { if (didErr) throw err; } } }; }

function TradingVuevue_type_script_lang_js_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return TradingVuevue_type_script_lang_js_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return TradingVuevue_type_script_lang_js_arrayLikeToArray(o, minLen); }

function TradingVuevue_type_script_lang_js_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//






/* harmony default export */ const TradingVuevue_type_script_lang_js_ = ({
  name: 'TradingVue',
  components: {
    Chart: Chart,
    Toolbar: Toolbar,
    Widgets: Widgets,
    TheTip: TheTip
  },
  mixins: [xcontrol],
  props: {
    titleTxt: {
      type: String,
      "default": 'TradingVue.js'
    },
    id: {
      type: String,
      "default": 'trading-vue-js'
    },
    width: {
      type: Number,
      "default": 800
    },
    height: {
      type: Number,
      "default": 421
    },
    colorTitle: {
      type: String,
      "default": '#42b883'
    },
    colorBack: {
      type: String,
      "default": '#121826'
    },
    colorGrid: {
      type: String,
      "default": '#2f3240'
    },
    colorText: {
      type: String,
      "default": '#dedddd'
    },
    colorTextHL: {
      type: String,
      "default": '#fff'
    },
    colorScale: {
      type: String,
      "default": '#838383'
    },
    colorCross: {
      type: String,
      "default": '#8091a0'
    },
    colorCandleUp: {
      type: String,
      "default": '#23a776'
    },
    colorCandleDw: {
      type: String,
      "default": '#e54150'
    },
    colorWickUp: {
      type: String,
      "default": '#23a77688'
    },
    colorWickDw: {
      type: String,
      "default": '#e5415088'
    },
    colorWickSm: {
      type: String,
      "default": 'transparent' // deprecated

    },
    colorVolUp: {
      type: String,
      "default": '#79999e42'
    },
    colorVolDw: {
      type: String,
      "default": '#ef535042'
    },
    colorPanel: {
      type: String,
      "default": '#565c68'
    },
    colorTbBack: {
      type: String
    },
    colorTbBorder: {
      type: String,
      "default": '#8282827d'
    },
    colors: {
      type: Object
    },
    font: {
      type: String,
      "default": constants.ChartConfig.FONT
    },
    toolbar: {
      type: Boolean,
      "default": false
    },
    data: {
      type: Object,
      required: true
    },
    // Your overlay classes here
    overlays: {
      type: Array,
      "default": function _default() {
        return [];
      }
    },
    // Overwrites ChartConfig values,
    // see constants.js
    chartConfig: {
      type: Object,
      "default": function _default() {
        return {};
      }
    },
    legendButtons: {
      type: Array,
      "default": function _default() {
        return [];
      }
    },
    indexBased: {
      type: Boolean,
      "default": false
    },
    extensions: {
      type: Array,
      "default": function _default() {
        return [];
      }
    },
    xSettings: {
      type: Object,
      "default": function _default() {
        return {};
      }
    },
    skin: {
      type: String // Skin Name

    },
    timezone: {
      type: Number,
      "default": 0
    }
  },
  computed: {
    // Copy a subset of TradingVue props
    chart_props: function chart_props() {
      var offset = this.$props.toolbar ? this.chart_config.TOOLBAR : 0;
      var chart_props = {
        title_txt: this.$props.titleTxt,
        overlays: this.$props.overlays.concat(this.mod_ovs),
        data: this.decubed,
        width: this.$props.width - offset,
        height: this.$props.height,
        font: this.font_comp,
        buttons: this.$props.legendButtons,
        toolbar: this.$props.toolbar,
        ib: this.$props.indexBased || this.index_based || false,
        colors: Object.assign({}, this.$props.colors || this.colorpack),
        skin: this.skin_proto,
        timezone: this.$props.timezone
      };
      this.parse_colors(chart_props.colors);
      return chart_props;
    },
    chart_config: function chart_config() {
      return Object.assign({}, constants.ChartConfig, this.$props.chartConfig);
    },
    decubed: function decubed() {
      var data = this.$props.data;

      if (data.data !== undefined) {
        // DataCube detected
        data.init_tvjs(this);
        return data.data;
      } else {
        return data;
      }
    },
    index_based: function index_based() {
      var base = this.$props.data;

      if (base.chart) {
        return base.chart.indexBased;
      } else if (base.data) {
        return base.data.chart.indexBased;
      }

      return false;
    },
    mod_ovs: function mod_ovs() {
      var arr = [];

      var _iterator = TradingVuevue_type_script_lang_js_createForOfIteratorHelper(this.$props.extensions),
          _step;

      try {
        for (_iterator.s(); !(_step = _iterator.n()).done;) {
          var x = _step.value;
          arr.push.apply(arr, _toConsumableArray(Object.values(x.overlays)));
        }
      } catch (err) {
        _iterator.e(err);
      } finally {
        _iterator.f();
      }

      return arr;
    },
    font_comp: function font_comp() {
      return this.skin_proto && this.skin_proto.font ? this.skin_proto.font : this.font;
    }
  },
  data: function data() {
    return {
      reset: 0,
      tip: null
    };
  },
  beforeDestroy: function beforeDestroy() {
    this.custom_event({
      event: 'before-destroy'
    });
    this.ctrl_destroy();
  },
  methods: {
    // TODO: reset extensions?
    resetChart: function resetChart(resetRange) {
      var _this = this;

      if (resetRange === void 0) {
        resetRange = true;
      }

      this.reset++;
      var range = this.getRange();

      if (!resetRange && range[0] && range[1]) {
        this.$nextTick(function () {
          return _this.setRange.apply(_this, _toConsumableArray(range));
        });
      }

      this.$nextTick(function () {
        return _this.custom_event({
          event: 'chart-reset',
          args: []
        });
      });
    },
    "goto": function goto(t) {
      // TODO: limit goto & setRange (out of data error)
      if (this.chart_props.ib) {
        var ti_map = this.$refs.chart.ti_map;
        t = ti_map.gt2i(t, this.$refs.chart.ohlcv);
      }

      this.$refs.chart["goto"](t);
    },
    setRange: function setRange(t1, t2) {
      if (this.chart_props.ib) {
        var ti_map = this.$refs.chart.ti_map;
        var ohlcv = this.$refs.chart.ohlcv;
        t1 = ti_map.gt2i(t1, ohlcv);
        t2 = ti_map.gt2i(t2, ohlcv);
      }

      this.$refs.chart.setRange(t1, t2);
    },
    getRange: function getRange() {
      if (this.chart_props.ib) {
        var ti_map = this.$refs.chart.ti_map; // Time range => index range

        return this.$refs.chart.range.map(function (x) {
          return ti_map.i2t(x);
        });
      }

      return this.$refs.chart.range;
    },
    getCursor: function getCursor() {
      var cursor = this.$refs.chart.cursor;

      if (this.chart_props.ib) {
        var ti_map = this.$refs.chart.ti_map;
        var copy = Object.assign({}, cursor);
        copy.i = copy.t;
        copy.t = ti_map.i2t(copy.t);
        return copy;
      }

      return cursor;
    },
    showTheTip: function showTheTip(text, color) {
      if (color === void 0) {
        color = "orange";
      }

      this.tip = {
        text: text,
        color: color
      };
    },
    legend_button: function legend_button(event) {
      this.custom_event({
        event: 'legend-button-click',
        args: [event]
      });
    },
    custom_event: function custom_event(d) {
      if ('args' in d) {
        this.$emit.apply(this, [d.event].concat(_toConsumableArray(d.args)));
      } else {
        this.$emit(d.event);
      }

      var data = this.$props.data;
      var ctrl = this.controllers.length !== 0;
      if (ctrl) this.pre_dc(d);

      if (data.tv) {
        // If the data object is DataCube
        data.on_custom_event(d.event, d.args);
      }

      if (ctrl) this.post_dc(d);
    },
    range_changed: function range_changed(r) {
      if (this.chart_props.ib) {
        var ti_map = this.$refs.chart.ti_map;
        r = r.map(function (x) {
          return ti_map.i2t(x);
        });
      }

      this.$emit('range-changed', r);
      this.custom_event({
        event: 'range-changed',
        args: [r]
      });
      if (this.onrange) this.onrange(r);
    },
    set_loader: function set_loader(dc) {
      var _this2 = this;

      this.onrange = function (r) {
        var pf = _this2.chart_props.ib ? '_ms' : '';
        var tf = _this2.$refs.chart['interval' + pf];
        dc.range_changed(r, tf);
      };
    },
    parse_colors: function parse_colors(colors) {
      for (var k in this.$props) {
        if (k.indexOf('color') === 0 && k !== 'colors') {
          var k2 = k.replace('color', '');
          k2 = k2[0].toLowerCase() + k2.slice(1);
          if (colors[k2]) continue;
          colors[k2] = this.$props[k];
        }
      }
    },
    mousedown: function mousedown() {
      this.$refs.chart.activated = true;
    },
    mouseleave: function mouseleave() {
      this.$refs.chart.activated = false;
    }
  }
});
;// CONCATENATED MODULE: ./src/TradingVue.vue?vue&type=script&lang=js&
 /* harmony default export */ const src_TradingVuevue_type_script_lang_js_ = (TradingVuevue_type_script_lang_js_); 
// EXTERNAL MODULE: ./node_modules/vue-style-loader/index.js!./node_modules/css-loader/dist/cjs.js!./node_modules/vue-loader/lib/loaders/stylePostLoader.js!./node_modules/vue-loader/lib/index.js??vue-loader-options!./src/TradingVue.vue?vue&type=style&index=0&lang=css&
var TradingVuevue_type_style_index_0_lang_css_ = __nested_webpack_require_9759__(863);
;// CONCATENATED MODULE: ./src/TradingVue.vue?vue&type=style&index=0&lang=css&

;// CONCATENATED MODULE: ./src/TradingVue.vue



;


/* normalize component */

var TradingVue_component = normalizeComponent(
  src_TradingVuevue_type_script_lang_js_,
  render,
  staticRenderFns,
  false,
  null,
  null,
  null
  
)

/* hot reload */
if (false) { var TradingVue_api; }
TradingVue_component.options.__file = "src/TradingVue.vue"
/* harmony default export */ const TradingVue = (TradingVue_component.exports);
;// CONCATENATED MODULE: ./node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js
function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {
  try {
    var info = gen[key](arg);
    var value = info.value;
  } catch (error) {
    reject(error);
    return;
  }

  if (info.done) {
    resolve(value);
  } else {
    Promise.resolve(value).then(_next, _throw);
  }
}

function _asyncToGenerator(fn) {
  return function () {
    var self = this,
        args = arguments;
    return new Promise(function (resolve, reject) {
      var gen = fn.apply(self, args);

      function _next(value) {
        asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);
      }

      function _throw(err) {
        asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);
      }

      _next(undefined);
    });
  };
}
// EXTERNAL MODULE: ./node_modules/@babel/runtime/regenerator/index.js
var regenerator = __nested_webpack_require_9759__(757);
var regenerator_default = /*#__PURE__*/__nested_webpack_require_9759__.n(regenerator);
;// CONCATENATED MODULE: ./src/helpers/tmp/ww$$$.json
const ww$$$_namespaceObject = JSON.parse('["BTCUF4D4G8DcEMBOACALuaB2ArJgXMKgDQCmRAdhDKgHQkAeADgPaKoDO45wAbH6AF8i2ACw886anSasOGcgFcAtgGMljPADMF5FagCWzbsRKhoiEqgWJyaALQkh7VIjUbtug0cKkzFqzZoADwkAPx2AIwSkGFRAAwCiUQ8mAAcBCYUVHBIyIhcwNhxcaBE+gWiPKXwBRFxEaAA3B56hrbsPqbQ+prAAISINPrsAMqy8ABGADYkAIKIiPAAngAy+gDWJISgoKgAFojMAO7I5CQnAKILrMAARACS5AhT+gAmyK/wqPC3TT39JAAPoDaDNyABzfaQOIAMhhfWAJGQ+lsqAA2nEALo7faHE5nS7XRB3R7PN7I8ivBi/Rr7YY0T7fcDEOnsIaUhjgMismjsSwAIWYOk+iH0JA6pR5KmY6iQJHAt0USgmJEQt3AzKWjBIzE0aD29KUKNgoX0NCVbjwZucrnURB5fKQKj24HgvJITr29oNbOeLE40CEUus7FYXAUUym3vpZ3oqCmx3DkejbNjdPBLsUkYEtAYLDYnHYRDZjEOqGYqC1JHdqAAwjLGHLwC0vMYzP9bi22rc+prtbq0LsDsdTudkFdDsSHk94C93khwcoSORUDT/NZUT6aNLZRZmSmnDRSxWK1WayMPa4XV3vKh271OzpWkYe32dXq77iRwTx0SSTO52QBclxXNdLA3fV6UdK991ZQ9j3LSttV5WRmyfVswByFB0FZUhmS3FEqXoRp10CHlGTdUM2BAG9uHIIhED8cCyO3Bs5WAcg0RITEGK47EBB2FMa0FYUkDFCUD2LI8y1PZC+VQETKTE8U0M8NpMIQbD8PpCi8J5QiGBI5jN0NY1mRoMFIT2OF0SxPihKUeB6FgczLP2Gy0VBZcrMiTF7LgqSENk6tNEsZ1VOfNtul6OINW0tkKIs7z9lAUiTLZFQQzDLMox5NMEyOJNcq3NMDQzIqU0af5IjiqU2IsHweSNJ4djSyCMqy/IcqE/LE26vKGHTF04kq/4Ilqrcd0bBqWS3RznNa4z2u3TqKoGuMCvihkvjdNy9kiHrBrKzMI2K4ZGk05B5R5P1mHYTzMSq3pTDakKhUpUJCEm1bqwM+hDo2vrToBoaitADJvsQKi1pKwbNurUsSFgEHjq5c1BslH0Ltycgtug51t1nKYvuGe0mja4Moey9kiJBzbyGkpGUf0cqGbTSSSxkpDq3BSwIowu9oFQGyt1C1BnW2bGUGuyGqKMgJbBy3suVCcidr4vAcvgrmz151AACV4AheVaM6e9gHGjU6t3LYTEWhW0UenkxYlu8pdOLbMqpxBgXWobaVFsK9kRJpLvySmqN92HAaOeWIJyuLyGBBONUQUJHYkLdEvYF4VC2ejEAAagaJI6iiSRoFoq6fALsoiHgMxLs4IvyEgNuIiIZhPfq220XYPz9I5egeP0cmluYUJW/ANP4DRfRMQwTR3tePA+g7v7NeBxHYDwZggjiUJEDwRADrTXf98P4vj4EXfoVCasVCJkmi2Iej2AO/R6/Bh+n9w4h2GLgxOuDc8Cz3novZeq8RobyLNvTeyYz5axzNIfMHB3Sen5upQWl1cZq2+HHQIP9IzPwoEQEaDM9oHVmvSW67BBBCCKHECQUAhYoNkGyYYYw2CTBmPMRYqwNgm3QlgpiCtkCm0FmlPoCJhYwluMwCYAArEgeh1RvgHLI4YAAxFE+hUC2yShCFKNlDFWUgOAWEMIvJGJdBqAAsl8PYNBNAJhuNYqyoATF7SCCIAATAAThEP4lIASqgCG2HCCRoiNwIj6KgYE8ilEqNXL2bmGiEm0VfGkj8KE2CCG2EkPg4gK6XSEWpW8ZhbgKD5MgG0+hVHuzILjAA8kkvQ0kTzcwYlwGgex4DsGaUccgAAFQ42o2BLDKAqTJVsqwDhGEsZUzApihAWUsqYeBAz13AGaPRqovisASQAASOXsxY5Y1TFh2TQfpSxdD3H0ecw5gJbgnNufcx5BzLldzNOWEYLgUTggACrwHBMco5fyAUQhBeCW4zRhFGGQAoToWRzBLVaco9pVJNAohIKM5g4zKwopyFMBQJBNakCVPs6Y5K+gjWlOQHFi5Fg0qgUQI4opvisrpQJe0fEcyICWNAZFWzbi/AEI/cWwdBYKEwbeUgqKKZ8S4IkKu0qFUF0brkcoJA4QIx1tqCkzgjZ5wHIwe+eBGDbIxck7cFgvhbDNEFbmpROA/guMAH2gJHZjzEW6AA+saZgmw5XGA1VqlA+RNAENsKbT+Ddoqeriv6oceJRyEknHcAA4sufZFzkTsCAlMe1rwlh5B0OQQFNJ/j5A1K8c2twvxHDUTs1NI54AxuQPcMAAgl7EgZkoSwexmCvB2RQG5iBwSukaI0CNtSelUhmOCB1T1gB0KwsgLudi11ZFXcwc2XcNSwFAAygwigSCduYIkDsaYW0DqHSO0ADM+Qrh6f6l96AGYLkaCQKYNSOxNrvTQQd+xH2Jtrc2NtJx8ivHHd+hmrxhiNilRcegedGAYS/ZOwQv6+S3DSkBkDw7Xhwi/RMRACgMN3AI3B7DJFwD+vdrKlQKLKCrsVKwRyUwW0KBoC68DC6jBhBXlGXjC44rHtPSiMlMaSVkrwGJydRBXhCc1gyITiRG3DmbXFXj3M4RJtg/e0Do6tN4luLRqdinwT0PCa/Ys1Re0ItsCxzIlAhaCrRQrIWVY8AccQFxizC4JCE2IU0+hkrXbRJsD57UfnAP10nRIRIyCOXwEYOAPY7tNAKnYNU7UHJXj/KQKuIgUxcv5eXFSV4ABNMUUxXgWf9QqBgKiFBnthcphUU0Zj6Ma0QFygZ4XlNsIwTCTmRvICWONquShxuXSnUN8EaJ4AL1NtF9KAh3brHADa9pet8WISrM0zQ7LwDrDhOsYAV2ABywAfU7EaEcOERxlbkDhIMR+xCjhfwM1Oo4odcgTHAEoDpR3tTgEYGD4Ku22m0BUPa/RwAbPDcisgeg2xoBokVINCzZnjh44I5iZxrALjwAlsAU2XRkWZEp85zHFMtyBqeMGrY3JBA7AEoIKuswzaV2c6cYA8biydzncxwgc8eLEAbuxwDys9NVjnS6azRActOOeDJtqmg4SJMxauWZ/Y9Ta5hJ9p+p3bj+v9fAI48A9G/HvjQCwoYpiwC2JoGglvre27vHxvYy4aL08FtwHHcYLP/1F7yunI3MfB4S+H/dXO8DVid8s13lPQC+/91HyKmP1ezjJfuDoewOdEGzwLDbgv8fNvtCLhPnPmDAGs4IS6+gA70mZ7AVnoafCMX55N+AmE2o/i2GX9SZBR7QDDYgBVo8ucCDauUfQppM/cHgF/UBPaJto+3a/Od4chifIuWiYzxHHo1ril0f4CHf0kGXfoiqVfCMPvrYm2gZyvmO+MgZk/I6FQ0aw1OmQDvlkEQI/onMBs/vbBBLAI0D/qZglgAVwGOEClWBODcLcECn7siIfqwB8MwOKKcBWMgMeLAG8EiPAMgAAORNqUHIBEYjriptSwACAt7gAsbT5v44HT4AF/APiAZxS/KK5D4QEmYKgIETpTpmgLjjqLq34OoVQwGXQ1BSGTqdrwChBugqZnCfScS0BO4RioA3bwCDoLxuga5NLoxxjmRpgrDMAqCgEEZvYiHEbf7OG/4h6laIGmAyE3537yjdTHqgIEBwFiHaYWaIE/goHahoFTjv75r6FTCoAFqEFJFGybpw6/A+FLryEBHc4C7NKY6lIYAuCrB2ESAYiYhbYRAUhoAGY/xSq2EqDMhogRDYhEC+I1GyKIjOIohEylFNHoi+I8TVjwCaCPKNHNEADMbRPIJRFwK4oo4oR41SwcpgW+rYyAIwhRuQ10rE6gvWbQwIQ21Y3MCo5AnGs4Fmsh+iV0Eh9oexjABxRgXI6xbQ44mOsxgq8xAKKkaIHm/RfmhwFYtwAgUuJOiAZOEszSKYmM9ITulg/QJQrxiKd2gs/w2COMzRq2q6lAwhX2xMbsHYMy6iOSaYqUS0qAq6fQwwRhqJpiKUc65QB0nAVc3AZgfawAjQhchc+gQQ7i+ws6NaoWBJZQUBgQDM5hzR88MhQm4Aa8FAnaEp+e8oFhWh8odKFAW2bUqYg04A7AiQaUk+g0eA9wqqAu3aG2cm5KZAapUCBpS0Sw0OpxEwrE5ANoCgegYYSgRAoODK7pnp+QkyjpiG7AjxywRhg64AyK3pzAoBOaZwTyiAWizmmRb+7A8ZearAyZI23eGJ0s0yKZBu74tRVirp/pFyMa0iuqMIiIcUSwCSGZiZ2ZkULa3RIZYZSwEZQIgI1Y5Axhpggg9xjkiAO2USXmEEe2tA8kh2wUJ2oQk5NYM53MJ2PgSg4MhAHu/qQUluIORANOnccZuaTZKZgktAzqVYsOeudqHoSOEwkoQYNyaWGWY5hpnuNueiyWQgGOswTpiuRAP5552ofca29OFeAUtAsw7AdyKgDymZ+Qsw9x7yTRVOpC0+8ajczA5IsUGo8ABmNQ+KRofIgOKAbqY4vOqxqFopX8naaZjZXyzZmGoAoQ7AeAOpcYYAK+Ae0ekiFJ6m2htA5hrFlhqAPanORAGOd5e5wAEwB5twdFFymREwK2IF0eYFPoQgLpkKooEI3eG2twaICieuyA8lrAmIIJ9xmwSwLJgec68ojszQNwOCnRoACMKxHEvqEEyeSMqofIYAquAubJlcNwP69JWWe+aMLAY2vBnqzlwhkp3BfF6pHc5A8+S0CGspGpKVD55hnAN2RAFwv5EO0AfpLgHpFyeAFwDE4olgWgNlr+W428FiIMTVDoy4OETOH6XIQkapcpHc5EvhORwMTUz+ZxuOQk4m3IW4cxCx4k4JkJwcIwpQcSoAHJTlKI7UoAjaQGzoSAswIlJQH2wpJClAcI1J7AtJwAhcz6ucWwDQniNZrIx+C8axxY5Y7goFQsWcGVcQ7s7V9I01Px90WIDxTx5AsuYRtUfGiuTaaAEhNFW4iAzwQg7ZXwzoqG6GrYtV3F5s5EQmUGaA7suCWMVc+gnqop45gQzAUNEOj+ncEh+4bMupaFrh9Bpmt6lmXIS11JvajluQNQnxSw3xixbIlCEQjQ8A5iP1dgdgCaTcW0ANwtylncepINlgbQ7GQJ+uGobIJRjR5JYipNtwVW1avQOtgqjRQQW028Yu08R1RYtwkWewjRmRLopuxC9tOKfZkY/RJtjecIxe9V9I28QQGUqNTtdh+tEEpNodDRdhRAdK0VPIwdbIntfRetC+a6PRXtUw/ROGf6SI/wCgONDVFgsAIdhMsdKgkdgQ0dFdzojR8dSJuGJAiafQxeMN7qf4jagqtS3w+ig6K4yARweiw67WyAjtm6KAqd3tvtSdpd5d09Od6dS0tdi9udKWQgkwFGGGWNOedsQVxIOC8tXxM1SxotsBktjQ0t7mrBAtQt4kT1q6vy5tdhltc9SMh1+JQuoBa9zt9179ZdZov9EdG6yhjQ5GHo6wiQuFNZtwED8A6wLa8SLyUm56SD91boutr9XIeqltbowDKgeFYM7snA6hboPWatRgmyWpS0OtF5/89NZA6hz8bhbNY1fsroWdadcdgR1sjxlgWwdCQgFD+iu9AsvgiaYBVs1NpgMNtA36BG8DiDkN3MCSqDZKSDMjqs0cOEEhgJxkmj3Mn0PIiNs4W04m8jSmw1oh+GBjzVRtlIvwfm5xAWlxKjVYeqBmHD3hzBquui7AewYjIiB9wARRd9p9ItyU+0YtJAl90tXQR94TgNfEOJXD3tExVs1d6UqtSODMIjbQcGYxqoetRAWxlAA2SQjtQTFSITYTU1J9gNoVkQP6cTDgc6RN/1DTit3EqTWDTRmTG6XUOT6tAGENqcMjjJtt36ZTggC+iQHdY4MRdw+gkYchUw49YdQEqA/dGG4qymA1+idWv6K8EiqFalOkBz8o3QXBeAqJpQCRhh/ZFKNhZRiAQgHhSDc0z+XjW4E1pQzBQYdmbCBYTQJRaKvMCZXy+sOgBgkZjgjtmODF6k+GhOt+R5ULML+gg6yA4AeQvwIcKWeEQ2rJnq5sJAaIiA2Ir0FLxOeY7C7sOqNLGAdLBY1DNDYi6IlL39ZoLLHAIBPLMgBYAgbMzILCYTJilu4odiI6EYYQYAUAtA2K8ABhBAVAlJwhrwiIRA0A8ASevKjgMh4AZsLCq1uQKA61pgDMDeZAjEp1VrPe91C52KuK+KhK02xA0+0Ay4S4LKMwbKesSeNLAkQgVrRrdsUAC5gF1YfSAyQyrrqolYR1dspe8rMAVSNSdSDSVcIl+9HEp0Go3ZsT/JxedRrkUTTQprKAuMI0XUZFCwywIcsBIQsB3JqUT1zR5Aj0bUbzVcbOqK/wl+D4dSEIai2SV0WTaAWrbGYcl5tqUbfGzA/y2l4IR1pgvIN1wAqQRAkQHlNgtwk5LaiAeqZZpVAZBm+QD8Rg5ZrA5o/ZpQtwDijAh7CSF4Wt08oQfCywzihwc2pgfm8wi4A9HAz7gIAA9AAHrAChB4AACq+ggI9wT6Il0HqQgIEQPAgIkxvioAUHeAtYUwxh2o9aH79bSwAAJKB3xuKCJYxKrFO+DJ3lhWaZNv2hXlTubJ+46cMJxyHBOyJWse5cCGOR2MKCQJ7SQI1qknMnqGshMMsnCLJ8sgfnBTUZOdsBO5x9+zKAUoJz2bp+tp9WmpEagV3aSLOOSF8Ds0keWLUojPAO8OceQHYO/jSkat8LoNWAADrkCPCT1UjYTMDIAqjYHUozBECEFOdID8LpF66FpKDVJJF9Ku5ATIBoiKdTDKeJmYhgB0HP40Dio9ok01xsd1X/CafcekfqcUx2agBCeB4SMiccjieSckmbGLJydTAKftdKdxG4HrVqd3jtPgCOzdIanlDyk1CMfvA/VguVu1LK3ojpeZdfLZdNAIj5BrrgBU1phgAZ5qn3UcTLEBOZ3mFLXdkUJRPKymD0YJ2NASph2Y7jcjT829q9He3/HmDJz5tbef4KzAhU1pSFdvc52Jqjww3wD2liJZXFfAi2xZB1eqWGffjIEmeZrThkjzjbMkDqDWeBdUjlnWBIiOfOefKucojGoec0Dee+esD+doCBfBcudhcRcy2kcxfJJxcJfIBJfkGpdLe9dcugC5cmb5f5J5H96sZALC7rpguXRdzoirZrqlCypU3mH3dSoM5LRTeC53gCBU1qn3yN7gwEXDBeXO5p5F2cVoXi9o4dA8ViIGd1Oky4zARAfsCKljgm++Wj7eDW8bqcDyOMCPHTbhao4bEN6CwD5FhoUHkKCgHs269Vw05mBR9S+x+gFx6CAN7a9Imc7Im2AR8Ne9AyJucmrFkDkLMnBREkBLO3C1hGznFJH4kpcqAEfsCFr9IpeZI28bH7ldBzfVtNvVh7QtuFzhXkudskR0BUq+vyiDDeuDqz/AjymfZGBMrWA8LqkjS3DmG3DrVHs1mDAcp6Kb9yklBEBOticutjIJvusMQ0CWUMT0JqqsYV7Vk06FVkDeHvYwj7nlOoAsFcgTRbgDgEwClAcsbMYAFXTD5vECSG2YAOVkfAjZR20nNrush1xQV1kKAw3GgI67LcLkoQF8hSVQEADqmUUCmDrmJJjt0uJiEqhRgDJxQaBViZWEtyjahBbgmAjrrcAkAkCBIBSKuP6j5yA9msC5acgahIAnYEee9CRhTE3Lblms3IPgXbHz4fBMIjXZ1mcEaxFkBw+sMTjMD0DL9dBLiW1HQLKpZM14q6IwfoPhxXtT2U5PpGuSkRi0iShZVrvinoBLBzBM3TzG1EFDLIPQDMeduYROxHUrBJg2wfQJEp+CZgRsIgCNx96BUucS1BIAi3t4xIIgzHNHLAFf4U1uALkTVkxTCHtJTBegMgTkJnbH5ToXbI7k4nSzB8ya13VggSGABIsjANACYIRBuRB8c6DrXdorDhCCDP4gQ8QaUH0ACQuh9Q7qK7zapCNLoGWCICQEmJEAlg4AHgCQBEA+lwAkxEgNgCIBTp/EOwogDtgiCpBDhhUSYmsN2HA4RAAAKh+z0BwAviW4T9lmDgBMANw/6HYnAC3CEKzSLYTwGwAfDSmGAEYPyDsT3AbseAHgCNFBF2JZgAADTwARBQOI0IFM0maQrB+QswfWHgFwBEAgU/If1PcFrDNJIRviXYQSKJFAoLgdif1HYihH4jCRxI0kf6n5D6x7gSIxkUSJJE3Z/UAACQxEAARPAH4lRGEj+QzSfWIKIuA4iO4lIwkSMCBQ1YVgFwPzCpix79Y0RGI/1CSJWArA8AmAfKvCOGSzAbswomgBEF2G1hTRgolUQAHU8ANAHgEQCzTsjBRiIuoCNFdH3BBRNWEUYaIlEEjsReAXxFuxNE3Y+RFwe4Fmj5FAoQxviIgNKK0SzAYOKwIFP6hVGQiigRAcETdnuB2IYOtIzMbiJzEQj/UAALXRH0jyROYhERWKrFIjFhRAAAGoYiRg1olUY6MtFEAYO8I/1M0hNG1h7gSox0f4iICVjmktIuxM0mlHxZYAFmFYKyKBS8iRg9wcsaqN8QdxFx/IZcXSOxFZoIRfmOwDwEYD0BkAcQZAMeNPHniLM7Y/WBiMXF2jIxFwfUbcG3htULMWiUkXGNuARAIg14mWt0JIB2AoKzgbHkQH5AvByA6wBxCoAWRgSlAWiIwMQG87IA0JmxW/PgWQAwd7gRAfWAohPAX8PBELHsRMBhZx96+K4OUMmFQnoSdEiwTYkbCLCCjDg5IEYExKIB8jf0ruAwI/GQA3YSAZKIgLRLQnsAmJIE1UD0BBKNASq44EERcB5HCirUuYmDtSLwCTIVJ1I7AHgG9KaSLglovAOCFLE3ZVJFwSYkwnWCcTmkMHHET9gFE2SRAeAGSoKNmB+j/odoi4BcAADSeABCtOJuxAo+ReAOxEQBqwXBgx0JfyYFLhHDI8A2OAAFJGw8cWiEgBMDxwOJLktwWYKWHSnLA8c8UnQPlIjB45ZgCgTrLcAvBPtQCzSVRKARuzMB5xoBQUSoluA8QgU+Yi4O2NmAqiRgcUuoDcOhKAjoSkxAae0VGnQkeANwkKbcJCkjSQpviKaTmKICWigR/U/6O8P+iAj/oI0/6AtP+j/QIgC0n7JNJ+wjSfsogM4UcL2HJBDh3pQ6esOWE8QyOXUnqXFJoBxBdhFoogDQATE/TPpn0rdh3ATHYAeItYPpGwHrCMoWYeAEYD6XSz+odAH5aAL+PYDcCrUtwbAKjNxFNjfxcQLGQsI2G3BfEeM7gb4gem3BzJWM7YYTIiBKBuBkyCmXTKRGnDCZ2AJmd6V/FszuBRkimXECZmWTfxfI7gT9iJlCyQxdw0ApMTFlnTQCIgMWTJV/G+IxZIgLDocN/GCjuB/0X8XaO4EIVfxdibgSFN/E1ZuBzSIQPcEJFAotE/qO0diMhG3A7RfuWwNUkBRdp+QdBEdEiCWBChako9BrLZxUQ9Ay0sLMTosGxbABqCmgWgjihmDvB1qlBHamwFoKGVkkpQCsH7kQDD0ak3shQBs1sB6wgIzs2MNqD0AScguJAJLoYGsDSTLoN2cAKBwSHIBAQOHNEGR1mB2Byx/qPyHEDsD+J25ncsjp5xoCYgbhoANEJ537g3DQgnnEADQCnmgBPOoAUDuCCxZEB7g9c+7G3I7ldyMQvc/uf6kHnDzR548yedPLRD3ZwOtwcDp5zRDXzMQmIQuKEAXmYhl5q8xRBvM86vAx+wATzkcFHnLzvSQKDAFtirgrBMcN2CyP0lQCPAiIFiRpOAAgWtZXM0VLoOS1aJ8ZRQc2UoOSyGIYKsWYATtOS2mJ4KsFvIR4nojuCgEM8jkMbAkM14csSFolWZsZEdgqDBR9CiCFOQ3Zv4h4K5W4MjNACAJQQUCmBQwD4UCBfgPfN4rWD5w58L8pbMVKUHuCQLnAoih4T9RUwbpcYyipBZLCvzhVOI6CgFFgqmScRcFxighR2DiAtp4OgIaaHyEeAiVR4QQbACemQnSYL07AYehr17yPw8MvWbgX4pIA78kAgS/pMEoIx4B1GjgJQgqFuCulJUZNfSr8ASVfAtWFuQ2hngZSJLP4FmZACkuyVpLp8vwMyqC3MgWAwyecDiBUS/iN1EgRwA0DMHco0UVBWiR7kOyhSwptBH4PjvAtoBaVAUBC16Ou3qRs4aYYih8AIsATD8RFvCh8BIs5xVwYOsizEmLS8V6IJYXQIJRwO4G4wCqIwBSaSMFHgN7U6wGSeEtuBMy9lNAPSScsgbnK8MYs65fZP1h3KEGDy4JRrM1jgACqLkmrG8rOXbKdZ3ygqh5O8kAqPlD7XZT8puXfi+REK7ZSbJBU0Awp2I1KmInsUkBHF2wG4SlSrjDJ2ldwJUCqDVDdLBwFMVdECgegTsqVqAR6IohUXQKh4cCoogyt0VuxXon0WlQvGWVoLhiaIIYqUG5UMdMK03FQQAEchBFJQuLcDsC3BC41YUMi8BEq3AggcqjPJFUK4C5+QKyqtsAocqH0zWzlWptqhqKcRKWwCvlJS02oURXwOyb/DS0lzNFKWkuJoOauJwUQuQEuSlttG+DMKoeKg/WOUNFXnjE43+CxBW15qRomq5QYts00QCW1W8c6GoA4n2DOJXExIT1DySXnYdV0CvPyJ2wvwTsO0+ap6iEEPiugr45QeAJEHRWeU+SylJ6hoVATFwVBfI7YvmR+oD9jV6JJ6r6pgbohO2/aioi5ULjgAAAXhLiHUUQR1NwwdR6p2ihU61hCFQZOsFhzc7KPEXGA9G6Q/ULuNiWdBunKCBCCUflGoMTFHjsY5O/gpKXFAbhFxvhP6fOsiA6XLsW096sdQtLNAj9m6L6olcoBJXvrUoY61IE+v/QPgU5qiO9XCBqgFtxl9AFcqPBWpRrakNRVysd1HiilAhblfQMBX9UQQe2AuMjrqo9hxqO44cR+gMFh4VFIAiACoqrBqEhxyihaxwFXCzSD5jIHEMcIKIdQZ49YQKLFlsCkWIo7RsikNdhRwY1kkqxFD2NjmOh44CoeOVvndGCWgFO83GYnH9BXIcqlopsP3rEp5CW5UAmgS3G3jZCW43gpmxfMCCWD9KSGKsWzQ9AqLHxGg6yjXv0EM3+pUAcQS3MCH0DmJPN3my3IXAbg/N6QOgAJj0BEqTE3szFPAOf0C0+bms+gZzgAFIG4qKIJeeNYqQBHqWIMLUDQXh0IEV4S5AFEHYB8kfQFRArRUT1JNAlGHy5AL4kzjDBat7vBrVlsmItbCtY6/UjyD2hbRLcYIXzYCGwCZCNiNWHIcMos2vAdyJgTcsNuaz0RWNAucsSRrBrqCr+mg7AcWXS5fdIwVsNLt1wy4C9sQiacruwB453hgQHEXMkXw81ZN2Mw7Lpa1zvBtRmxZsQmrO3aTzsBlEIJNhnhzijLN227BoI0H3YZEw1pZEoRcnDU2C3Sdgm9n2UHTRUH26WO9C+0sB3oNOpHLTnNkJIPgAOIEYDonGBAQdcOcHBDkh1w6od0OmHbDrh3w6EcJOTFTjhRyo7OB3KE7D7coPU6w8bIOuYlaqB20aJQqZgH/oQC4Ayb8g0CXSkNkNIsUhhZQivIgAC2hVQg0AW0jyk2Ra6O4glTltyUqJCByUY5ORkIE0BWh5m2mdNMgGr618zOgESztjwwz08Qu5yInkYBJ6hcC6COsvlTx84F9EAdPGzoz1J7M9ieUXZYOzz0Cc9nA3PeAMlwoJHb1k+A0yjl1Zqi9ABKANfJwA1JdwLBCu5XZPmaL88uCq3ENkXsuifphKQy2huZDVL2hjdZQwWPnue7MhzdResFuwH23lYekaUZOL9w3BA9s6Qqf4PunB4b0q4POiRnmwO1chYeuWsXaW2LaRrDVeqmtkgROA8dru5AZtuQFbZ0bC186ztG80ujwjhu8iArHjnk2gFFNoBZTXhjU3LJWpRAeKXLuzb0dE0EfH0GTCEhvAekbwISMZvAAEqGYxm2EinQuLV6+0jkahGyFBSQgLyX6cEIge1AJJmAewKYCoEak8hh6lIPqDQDwMqYfszsFZlMGXSMA3UPRSMBQZfhZwdoXVPBPAC80XkRoTUW3LjGkQDoODf+14A8KYOBo+DflWYjQstWzEcs4hmzf0tOzsGUQBWvjDlls0KH72GBrA/OImj0gED/GMOFMjW3wjQWnmDktaAIXrdrkbJPbkJkPWPVZUgwcwgvEm1ipUlObAiLBgtwFKjAiSounEJmJVaFAxOS3JoHIA7lRNlvDoZSGfhog/DEByI/4a80mbms4hxIKkPbB0B+BwPUfc4k3wdhpQjAJYJ800MoHtDfNK5HoYMNCoOSbICUI0ARA1BUwu3RKoesugKAzNkRzhnYfAAOH4lhS5w/SEANuGslHhtJV4Z9QpgYjm5YzXNqmqaAkjD3QWGyFtjc50j0AFOoVxQ3DRGgewSrTpEXUj89grbEQ+lk8j0HvgaIPYN3PvmZYBALg5AWSp5BaGPGD1SaAmD5AdG7gXRwYz0Y4SuH/UD+4JaUBGNShnj1YAI0EYSO/NCjVYISL8fGPxH5amgCA8Bg4Pmw4kUxqDGjvWrGbfZQof2cFw0ESc4UShzKM4BlD+pHIKIeKO7AGLHHZ4dkLEI0CUPoAVAdgFQKlvENCRKMjIfOMDAZOlAlDiUVQ9gf7WhUmqfJxdQKdgBCnGAblNEAyaEgEplwNSnkMdEVNbgCoKp+kL8fVO+hlkFRfiMutsDqo/illPzByYdQWZBKpzLoARnFP5H4DEJ7UNo3C2MBOT/qcU2bD8w5G8jGhu06gbCA8hTT+iH4wSjv5/skBLZW4+Cd9OOm2QAZkgD8YS7ac7YeAHPkkGgDGmqkzph1K6cwPYHzTypZvRIxVJSG+MX2/SHwdc3eLXY1Jlg9qDMBZamEA7XLdSaOPbHvgTTVoiOqcHuxw4W4Ig8cHvh2BcDhEY4IXHENJ4SIdgaeKyamMMtwAQapg0/yfoBbqTYurs7EpICFwGT0aEgFse1MZcjNSW0c1MfkPqbatJQA1aE1yC56RoPyRoHvCYOhU7zrbZY71SYxbQZ1zAM/L0AUDH4+MgmzEOYgbgNaeQ8phmCCctyN5fzoF4YgieOiblAjEFn8wzGOgwWhIBUeC6CcgsUJjgqFwEypowuIXfzvx3C1uHU0EXBBSFmgOppgtXHTayJy2FtBjnkH0s7AU6rIdxLGQLBl0F0Hhb5AVEzNNAUC+ReABehvCSplmE4nAuCDRLCJ9C1JZEu+AoTQJ4SzJaEhkX5LI0NYvqZ5RCA0zJAJYCaczOBnPTeZ0lCbvq6oL59gIBk6Wamo0L7IPZ1s7PE7ZTJEtVm4vrYtiY7Ijz/1eEyauz1wL4ALi8Ws+cerwjlKxOCLQaDGKhNxNggNywoIcDTnfL9mh8+fQSvenh1/carY8f+r2WErRW7pEwbw20XSWHJGoD9SCvYAQrY/T6q1vCurZzj08FbMXEqK/r0SosMg7QeQ3EgKr4tYK/AFCtVaGr982rbxb5WEs9LBljMy6aJPlg6ZA2fM5abMBFnrLdmxJi4eIhuaqzTlms1stK0Nni+aV8tl2cbPFXjrNiXyJ2c4ti0Z2Q5/A0cAHP3XiDPlnWhbovQnwpz4h2c/OepOLn/g/m98zsZOs3WLz65zc9IauQjdbz95lcyP2YDPmmjQNk45+dXSUWQ5AF10KAAa0lg3KRdUq5ExsTL8GLpBmgyxdADcXPYyl+S8VubprxlYpN5i5QYMw8WnjKmkdZSapv4WDzpmvoCoAX1sFXrCh4xmzb5A0AorUWkSwiehM83ErJAZK29fBjjXatewbSwkF0vpmKIgh+gKZfkyO9cg6AIbNtelSRn+M2ym01aCOuiwoDtlZGzScejVkeAV3dXZMQvyhV5DMBr4GIUE27wCsRAY6GVmOBEBfjyZ5/UretuuN0AjaH26BbwDHQ8ABUKJUCdDvcYBADWpViq2dhQHvbg6JOyppBKM56QntqcuQpVV+YM8faealxRzzhYvW7tmEIqtLuUKUlld8nMHDoVWmKSyqFKpzlPKJAZi4SCtgLi8nrb2MonZriLpk7Hae9h20vXBTO1ldcdFXfhNsBu24xlrrdN7cZCe2dLJ75KpaAAEVPtR9SNuIIXZLtAUAOkZVUq3Y7twdB7KHfDuvYH9btT9xHYMGR3XcOwj7DHS8lfbY62omnTQD+z0WE7J0xO1GaTrA6QdoOlOxDiuBp1ocMOWHHDtByZ3qAWdJHfhOzv0Sc7KAE7I+7zsG786rEgugDcLtuNi7J8XjKXd2ZjVy72WG4ZY1aAoBF7u2auvaBrq10JAddqmeUvropaG6kg5l7GkjxOAADVclunMNbuM7RFTOAECzljxx6u64iHupzkzx90U884/umnkHtVCu7Q93u8LhHrZ6QaOAdBLnjzxS7J68Bp29PXl3FRKErkee184XoM64IbHPXMvT2lYf62tIjNdin0PnSKshMje0gM3rMCt7tkEji3QZy70z2+9xkAfYD0WMj6v9+NCHiliriEOZ9KcQtovr2gHddihTsG5iQ30/ht9bqvfQfvbbH7u2WetAOgAM4f6ug3+0mHeCEjLgXIk1KCPKFs1CQRgdouEcN2RHOjfEoHMZxM+WkTOpcW4RUdKObH+oLgwyEYOAAWGRA2DczoFAs4rFrPgJGwwzX9C82LAVA6wQZfhsCCGmprfmZnERGOfk4znI7Ra2Zcr0G28IC5A7OIO00+hSguMEex88sCDIRkN/CZF2Q6ADlaQhhm4M+hMOS7IBOwBo+FQErKkKzGy4OL4ouUw7WAYSvDMByiUXKOAxmnF8ErEn7Fgl+LvDLc4YD3PTnVaCl8Eq83sA3gxLjJSy/9Tzj6XFuezrNv0AsvE5q4Tlx4fBkCvzbmgTQPy5ZeYDAl7i89A09jVM5uXgaMmo9R9V/bwQu3KqDVotWz51eUWSfKkcT5LGGYvQWzNq3TNW5XgPL3WyI+kEJNMSYC7wuUBkXyh2F3hLTPSDAgG0ruoQbIa0ILjuUnD92eeDsHgRTBUz5rjgMy+ed62LLeld47oDSXEBVV6qwN1pbNf6WbnvL6Nza/Ead2oep0XsNWXlCSbgTghy3AZj6ClvFtvscxFW+XCW4inC2+twkcLiuLG9GtjNxbkakWnY3uQ04AW+ZA2QrYErMt/6gre0AhtzbgWxO/9SLaDuM7xbVyFbf3kO3014Dtm4LOCGiAcR82Du8Ls61nAvQYgHEe3dvAZNMsekF074zt80QghrtktDCDkssQzIAgBe/mNPBr390O98NzpWkBNylm5rIIewXhvO3hLzQNa4LNkAgPWiraFe44Bfu3g97qHpPGEt3gCAr9rcHB5vffvqV/72bYB8ANgW4jO5Ald/3IvgBRNDtIEykrCOat8HmpVd35lJf8MIPlp0hNB7uuYeP38H294h5P2HxUP65JNDyCw8IfXgC8XDzNp3JbvBgRm2E6AfubkfRNa7Wj6S3uYgfpr5Acdax97dD5vuyDVAKknvjAgmEAAxj4qB+AbuiB+bufQZ9SQafnG4Hqz7p5XrsAdElaJHHeFVih2sK3r8lLSQc+3BuXOn7igqg4+YlDNkbzVlu6C+WvMijl1MAPi8+0kQsUn/1KrGc3EB5XMYAfKYFCApfS3AH++M5o+sUkpqHQIuEMPuJyeG3gXvLGlOc+heoPZ7mD5F6ZfRe+j9X+L1tD7LbB8v8ASETO6K+2RMQEgVyyVFy9MUCveHy3MV6xDjn9317z1M51IQzuJjKaQL/F0SIhfbXp7l/BtfbxRfgAMXrb6uHuY9ekvU3gb6l9HcZf5vWXi7yHH6+QjCv+Hub6N9K8ctyvnqG4VV7W/xH6E6b6a4hm7dLWLLe3obm17eDHe+jIP7r3lEu/Pebvw3zL+N5y9PfpvaX97wt7K//UKvoHP7zCdq/mezgnWHt6F/C/5kofHX1w6T8yIdNEvfXlL0N7e8jeJA8NPH8ADsDLbqvxHjb+Z8mCozGve9CvKmtqETA7egP650F+lBC/yfIvvt2L5uSy+Ck5npl+CC9o7fc3GFLCvIqk3AL72sZ20+6F5DgyJOdAV3CuBFi9P3Q4RjgQjn0AYYQJLMTX9q25hjeKIerKX+mfV9e0pJwv3N6ijkUagJduMQMIb6MvBLMrYtgJnKFeAW+2qXjEdwB5ocjfJQ1vyo4qqqx3B2ADvp3778uJu/fMNpHaJrDnwC+pgjkLX1gg1RAJoPc3bL+ZqO8xfZwjkO4Km9AJULA39EPHAMYTc0cqFki7ZEr5cTMBoXNwxEDu1dRchQO0+LuCNFlQjR1jmxi9HsdquXQmiSvvMFz4iBTTHER4Y4CJZlrtEl5wABaUr5YBHAd02HR7AjbYJ7kx16IYCdExHkqB9Ty0DgI3lA6xlP4/34n0D78x+kFEGr8amNqCV8gAtsEC8docgBADyBJaHAD3OVXwACgvFwFgCfALdx3cN0eUDiMEkcIkG1m/Poy+ApwQNyTdNqQSAS9p+CU1j8LAV4Dk0JLeN0SVTAEeFg8P3agIk5scRTVTdQAHiH5ouPKgLN9aAqj3zsuAniAD5vvchG3dwDTtEK1HvOjVaImKOjSxBnOZzSV95oYAFUCnIT1AqJlArEBzF9/QXy0ClA2eHkDSgcAIl8hcbQOMDsQBE1cYd0XfCgDYAMnzB9EeObnQBphFcEJsrIPCAqdKuDp0H5d9Skn30x+CflMJwHN3kfoEYU9VX1LzaNVl0fqXkmH4omKqAP0x1clnngT9UDkSCbEOrxRA84NAOPcWvJ3ib92vGH1cMmXDzjAAaQWRBZ9y3B6maIsQGTQZ8lvHPl8BFSMa1CAmEQxQflkqQLwmAGveX0D96ISnzyB8AkoJi8+g9v26N0lLvymCe/MgNGE8YNv0yBGIaJy3BnAKkGyFlgseSxBcVGNDnggDDoFw0sQELQYgZVCIDDwifFNAOCLAowNOCiZC4Jq8U0I3WQC+g6vAGCa/JpAh9BmUYOh9xgiYCv8GAtJTIBe/bv0H9BIRv15AlghVEYgalXgKghUADYJRQYQnYLBpFvT/wWl4AAnyAQ//fnxeCx/bjAD9gmKRDiRAvFQBUAs3d4PlRmvfbwi8mcAgNcMyQw2g79fgIfwoD2AKEPCw0fBKCRhX+bZAlwlAxQOxAG5d6RWkjg7EA58D3YADXx6IHEO99O3POBWZ8g0X338FQuAVJC+kY2HyCwvQoPE09fWsjB0DvYoN+C+jHamNhJgj43SV5giUKW8RvQc3sgZQy4LlDprNQGYAtQ6kMh86QsYJNClABvEBD+OMEPO8pQDUN5gfAZKgWDZiCrxo0LEQ+Gc1yEGVU6xZQ1YM59BQyWg6C8AOwEFCKAGVQJDEwsQKghlAb+iaQzg34BqV5eNYILC18IsPuDtgpD04VvvT0Qn934fdAbkAEfdFW9HQ0kOYAnAl5zY96/FDSaDGXY0IZCfQ80P79LQ1kLxgCwtzBrCpkNvUqtm2QazH59AR/2UoJ/QazB00QjoGc5Z/dsMeCnQj01YBLkSkMSFzPWXyVDFfFULugkA6XwRw7oOX2cDdvYYIHD6Q+/UOB2+eHxo0n3TEFSQWiACz5VrQz/24Jefdb33CHaN8NDBXcI8IfDA/J8J+CafV8LvCGpYXUDDPwnK3RBWiS2n/DNwsmgdC9w0kPAjROKCJ7DwfWCOp9SghCPb5CIj8KxAQgNCN/Da3X8IAiKvXcL59QIzKAWtjw9AMKCdiOCPIiHaZQHp95aDoE0tgIgHzaDn3PKDXUR1IWy09qleQIY9kAz4G9lNAH0JXA9gc8KHxuNB1EIBizH3D1hVJWsB40kcUCKUjdQI4BIASARBkJDQAtKi0jPPXSL41LAAyJ41psQRQyFzPDYLdCvggfl4iYvREL9Dxw8gMWCkvcNBqVygOcP6sL0RcNABlw8ADMC7eZSgzCgnCMKFxMgliJAjAvV4CNAvIjAPANWvT0KHDQCLKKZCpgpNxmCLQ4EPmDukHAJeQLMCEKvc2AwQPk1A3RiB4CWA/gLj8OAgnBajuAq5CDCjYEMM/hkqYsJnCywmMFvwWGU0JDC18YaOrCsgGpVlQUohsJYZevOhCR92ASAGYA4QDaIPgWKc/n30KZJrHAN/bISIthigCfwR9gAfdCR9mASAFYsYQW6IPhmAeLV+cZVEQCOj4TYOy2hbAz4n6BkqSQM+jX4GVWwBMiCQyzh9ATYIRo2/OPiBjbgHgEyJ7CA6NSBMicrHIgIYlhlsCvQWGMwAEYrMNuB/ETIjBNNDS10pwysPGLqASwukzSgWzNkB+j6w86PijKcbQKmAR1BuQk10vKICuCDov8Q+jsFcmN8RQYsrGeDpfbHks9OIzIFIiCo+CKNo2/AKMqiJw8Z0RBi4cMPED0osSIXwxrCbwsD5A6M0hCQo8LGc1EAOdQqJC4C2CSi51EqEnVcNeSLGFzPPMA0j4A/f239decz00AiYKtGsiw0d0P8tSNKWL4i3YyMEGU5YgMKKswotZyqgQgYuGSClw3oFV0pSKllx9JQ+UlwjWIpiMRI1Y//2l8cUegD7IYAz2MJVLotPx6sYgq6HDidzYth/RW2f4BRN0fJ/2sChYMaxSYlGd/zM9kA0f2xd84wWBH8M1a8PTNjoajhyiWvHyLIiYvfuM51g4lkKCjIgFEVnCI4i9GXCx+dEHnhaNc9njjko77yAjZQwLzHjUACYCQB7w4iKa9vI/sN8i+jHeL3ioYUcMYCQ4/IGni4g7ZHnCoo/Y2UoV4w/ixJmAmXGwiVvFOIyjzPPYCr9O47UJpC9VEeLPjZY5kKqj8gbuLH9iQEgFA5sOKZCV9DgYUHUD9/dgHFVqIAciTC2QU7xYYjgKEO4IRo9ohAI8wtkHwT9YvGIFi05ScImApQkXAOjJiT1zrD6QchKui64A6PejQI0eiIiY3UR00iTgIyNtgHImgH0igUWsD5EhQS+NAiegJz3Fjw0Pt2qCZvMdzqC0/e0AtQsqZAPWAVALyNrhcovy2D9p4VeNu5b6P2Ji8tEq+KBDO/dwzHCe/cqLHDilKqJqAaosVD6i+A0306jbgZqKmCG4HiDGj33DqJoCuo5tEDcfEvclg8OQsoCITXaXWJcA/oyJPuCAY8O059CtOwGYAwomVUYTRIhty+iRPNv1Et4kzhL2CYY77x/NjglQAqJcVeJJBiskq4JSjSkzEGZMKk+iGXC4Yh4NYjhY9My0S3g6CI+DKKPRJ19puOKBft8gYxO1RT41wy6SLE/0JBDZgqxL79ElBxKH84QtkHMS3MIBFuAuk3mLTipQ38MsCBVc4yXl7bMKJqTQIqCQsBuw3hN28hgnUN18Q/cNXPNOPQ7y9DXDM5ImiJ4q0IXdm3OKP381Az5NBMTPVoNYI2PdzF0YgdKpU0sM8Uuh8ohNRE1oUN7amO5BKiR7B0N40Jqk4AbzJqkX8To+lDgUOSYpySCVAZthUBnzauPRAVABOLERaSbLGaJyUkK2bAalABHpTWiB/3pSdgzQFLCx1dlLZTfw/225J3/coHYBQOfaCTQRLG4WYAZaG4ToQG5PYBuEFACVIbhQAG4UxCvQI2I3JRabn0EUxhV/jTjP4Dgg7DzPBMAuSc3IkMdi01Q1N7jO3Q1IpjO45ULNSuwuoAtTprAqAHjAE72OHjTEvo2dTx4iBInDkROILnjo43YElwggYZLXi04zeP1TkAr1N3j94weJfx3Up5MKjbgaNIviOgd5N9SZ48KIfjIomqyDTVsENNXj81KZE/jE4pb2/iTkzb3Jx+sORM+Dp8YYIhDBw6WMcgVATVjlj5ktJUoAWokOOWS6ACJJaTzg6f1ySQo5pJlUqEhbnLDaEnPXiTGE5XnCSB8WMjQo3ophJsADKPciEh6vNhLj4WkkGO4DK0nW3zj2SFDTcCwgmYVCpvAuthXs/AuBQCDR+FynbZ3AjgEfphlTVVMCfkpyAmEehMX18BNvEdCDk3QswCUMX0VtJ9DEMTQCWBUkyCII48jbVgUAFAN4DG8cUY5hYpHAUCLIkxXJl3HVVNGtLMA/knckcBzPJQBxQ40j0MTSm0nFCmTAowMLcTGoqi2WQuQ7cGDC4eWaIHTYQraFwS0KS2gPhTPGpQOix00hOAwDCMmkBsuM8ol0CGEzIj8TeQCsI1Ql02dIdACwosCrCd0k6Jz5rQ3ryLobtVmzhImXTdLxj4YmsIRNP/L0B/iAfTb2ACD0n2OPTAOU9L2hz0rfV8Dfna9L5Jb0kINdAT0jwKfSH3A/yio9AtNWagP06bC/S03aX2ah2sLDJ6SbIqHjsihEtaz4xHI1AAMi7EaTFwdN8ZAJ9COIiLK9ivgw0I9wXwy5W0500x7GwjbQuuIzjcQkLOQl1Im1L7cfwQRJ0jYsvSKcixE6VjUjUsm8OFc0AswEC8hXErB0Tss3ULuSayMPwEhZzeIOegrLSVX3ZdADrIh97QZP3w8DMWNU3JdQTQHkgRtNg3qC2iC7Su1/6OiOBo0vRbM2zls9DMsB1s+0HMgaFau3LwFEioiSF46ETw/cestgD4hk1HpG5hGga4iJ4ZGcdDI4oKNSLP5x0dgDOdGAWkjP57NbbIcz2BLGTFQBLK9yey64+QCeZuQXzHgAX2chTOB5VIsE98RueSA6wWKN+Dz8OAVeA7hwQUUBXgGYUnLeAjiFLH0AbhcAC3N3YLuAhzL0pihlN+lHkmJwpg4kEG44pBkx5J7QR6GI0HsiU3hy+IftQjxzPFbIldXU9jxuTBkwbNu1w/PCG7JJsk7HFcZsoD1Gy81ebNqChccyEtwVstbP9QAUnCBHV/yJe0u0HMjyHy0rECoiUTDskb2OzVs07ONzAQDbNoBLsuhTSEyIW7J2AlqYXMEsxXflxezQGN7KrAPsm/BuIwDSEwZhfsu5H2AAc59GBzQculHByLcnbKhzuBGHIDypc4V2VRJ8JHPtAUctHKglglQuCxzS/HHMsA8cilFz9RQDDBYp5SSnPJyREsnOpzr0OnIZy5ecAGZyG2LzzZy+MDnJaj1OXnPZzf/QXJYY4coPLzzuIcXITxJc3QGo9qs4kIDyaMjwyBMvGG7XQAtzUoGAA+cnfNS0CVO8A1AkSNX2rzAUA+MuTrs1fKqxSTX9LAzgAZY3PyIQFigAFSgBcn6RffSfNYDXAGsBZBQIw3Kx0Zc6D3RIlEvjidyjcxg1stSMviMAKVVH1KCjP/XfBP0ICl3K6o3mA1NxQxIUCAszAvM4DlAbQI2CsjOIrrJJ8CcCzMB5as3jRETLAATUHQ2s9M3GQ84BYiILOswMHM9GACGPTl6AmXOuT40lDQoDG0viM4LO8IaAozgQuxMSU5gofx1QrqQBH5onqK5B+oKtVvAAQY4qULfpgKbaLew+Ob71pJsQx0LTi18PVLwiOCrgvjByCmtNlz+CtfRGDQE1wxEKKwAqHEK5k0EMniFgjc330O4BQpct0U1zSCBVCquN6AJaZon7htCkP10LOffQpMLU47COMKK0jgssLMsjhUCAL/Q/xdjkA0UHKCjUyD2PjbC58OeSHCYYCDiEClCN0DygZwUjjnBIIs9RNC4N2wjk4k5LTjMqBIsyKAEqwsliYCmL1sDCs873HxToiQNlDO0MUMe9rY7EF1j2QihMoBnNfkIfllvBoAtiYwK2N/CdgHcNtjMiuwmIz8oror6NDgFjF6K045aJKyXs0DlKyTMzOPTNkExxmXzTUpxCuLNWDIul8oYCkOSKJYlr1JStY0wGPY0vEjKNDpY54uAB/oTwRpBZUT0Q2c4gBuQiAhbEH1f4R1AQGbpi9ewocIdMg4seSMoRjNDCIfMOJSiNAjHGnx9o4sJOTsEstNUCUQMmgJKEk3MO+i2/T+CrCZ00sOpKB8SsLxjOEhaIsQ4oCeE9F4tOKHYA0wsEs9FIS8vO/8LnbJk/84+A6OqSt4tX1CVeCvb0STBmejKEKYvMSWIDSo1wqmCJC6xKkLu0hjGM1cA1xMvdWAgQLoCMwAKNCTJMhqONLk07qO8TeoxaOoyrS34zNLeorTMlCWg/tN5ick773dLR0z0rBjOfH0sOjEksrFOjAy96ODLAPYzVCBJLWd2bdIgdSU4JVQLrAL0lof1HMQIgVeL2AeUhi3S9ILLEEgAfzVok+hyk59w7guUheFxK10BlJWLukUku4A0k3QLSSTAggBLKF4A6HLLvkvzLJKGy3xJrKoEt9IxxCtYsBWLSgFmIkj1yVsrYIeUscoXgWY5lI7L2U+SIYtWyz6EK1IAcsoMwOyocpnLOypxGagEBE2PCw05CoktoX7ScoOgsy593LLVcWrR7KysMa2TKSgdch7KggDcprIOyu8p3K6yg8uOCjy4cvzLDEmsknKO4S8rWwalLcpqUdy4gFHQE6UoFeBNM2rSLgZyif3LKko5aTihWy/2ijCeylm1vLtA8/lg0pym3NArLaQrVwrn3HrSfLSgVWzPyGUatNeKK8KgvsiGs+LIMiLwOiolAcgjXwdixEJXy/zHin33MzxY21KcRygx1KY92i14qATD0/IvGTQCSYpcL3C3dVniEgwNIfUl42sLIgN4tKPOLysn3wwTSsYSovC01dBOogBKzt3WCkYLYoH4peOSo4EEQnkN6LiShSsyBMNdFOVofqPeAvQEbdf1yBZUV+wMoeIW+PtsswxiFc0x1BQFlSW477z4qDKtdEyDRhVoul9iTZ0D6y607iPNY7KvLDmwAoxZMEgagI4u0D+tY4Go4OIJ/jNz+MneK1ZkQhpOKrzIvB3KqqY0tM/9MQosF/9I05KoEjgCoeJPikSjgQLCnKmXRUrm2BeOA1448NLKzQIvLEJQLAa4o6LADTAJyylSzr0owE2WatbSSA9Uoqib43Us0B9S+qKNKPErxItDWo4kstKPEzgK5zeo/jPOrAkoQLwweo3xPAAaAQERuCH5e2zkzFi+A1iSqw84MSSalV0qW9xU8Ut9LgyqkyWKRLHlNAqmgUCr1J6IlQFCBKy0CuDtwYUCupSUohGxBqgyndxDLJIpmPnKK2NrV/CggFZG/LryqYHBhyy92CJjJQ2aPDKd3TtH9RNYiGqZrmUpmoaDt3WrUIr2azEG2iaNFZCiAcynK0K0ggBGvjKeauISWjk0ejVAqtAHjOBjPSgaHVd/UPTJKU6vchK1Dhgt91yzCijgQ1rHM9EGmIvqmgEGc4RE2MGIR5HkFNrZgX8NHNfw42utr9ku2p2CraoZxtrpiNOJ58pS5AKlduq/bwGzJNWsnD8vtX6HgqQQD1LKDFkX2lDquATp1YDFke6E7ZIi/xN5AE6vtVjNtgOOqoC06yfmNsEBdTmKoLlMx24EZ2H8HilPtVfJzqF4GIqK9BgLW1OIogOup2g9rOBQ60LlIXTVBj4TfWQBy67qG8Im674BbrfEErTwxntbgROIJDbpDLq98xVjFMczCU10h+6/tRbqEgRbwaiq66eAYhAvdzh4qIIJX0QDzKtd0E1/09guQCQ5Y1HUA2C7ep4TjU+VH6S4AAOq6J0ANeHPc7K2JICjSAof1xhnEizAoDbq9gM8T6A7v16iDqgJIAbLqi0MoA2o1fMdLqPYBtEC4FbUke8rA/+hjClAsUOCkBywwIaSxQ3zPF9IwowJrLGYsUJloRy64MUzEk7eqZc+s4YMEK8syN0UrJCjtJDiIQqaKYy7g6xWqBTo4hrNyi4X8TaSQIg0vmMlgzDxpLUKIhJtZfSmsNOLRGpL1ka6EguAyTMiSRtuBWSpqq+9kkgwtMLkAzSH0Ay+E+sC9YAG3CqkjKwxo1q/a34p1qk0oxvASNSnapga4/WjKjAIQpAoqTMw7mIEaAfZyrEaqwqhIqIZGqCDb9p8OkspjNK0Uo6BpQpdKSr0zcyMsjdQJYEvBzwooiYqYsnkxCp5IAyIkSQwYABGhcmshGwUawOrJ5gmswyO0jBFSYjsBuiURNKbXIwuCqBUtMAS+0UmqppKbkySMBqxLwPyhGgRAIJyhKkE5eBABJ/SgFA5UgHgBEAdhOwEmJTYinJKaXIsADqbQABpqXkwBQL3Mb5qmwpLiCipNNYTBq+hwiigrJ+N8qSKI1mAkG4G4Q+tetSJPfjJU6Ks599AHcN0rQIo4BylAE++qKCrG6WOebVSi0M/rBIb+r1LaooqwdKjqoBtmCQG9qPcS7qiBpsTeontP/rBAp0vgahG3pAktSqjgkUtJM6NO/pk2fypSSPqlsO0Cey9eM58GwuwDj4oPcA0C8EmmUqMr+E5ADqzkGHkxoKEssRLaapgDpqQBN8AewIVe2HNgkYcEMeya5cULQVa49tQEBThFuY7VT1rVc7XTyHMtezu1B2B7TSgd7N9VuMJ2BBztgvtU+06QzwNVyvswUrYFvswdCHT1w70WgQiEyqVgDh0T2SISR072djB/soHCqSx1E4HHX4Q8dUBzuAidN3l/tydWB3g54HZDjwBadZBwZ00HAjgwdiONnUo5cHESnwch8PloE5iHHsgF05EDur3sV9ahzqDp2M1nocDORhxixFdXxw+p2HMthsQuHPhx4dNdPhz118zA3ULhng2+qigzdSR1tjK+W3VR50CB3UUcrOFR0Pw1HL3Vn5S+Snmp5A9YPQZ4C6MPTIAWeSPTLQzHWPUS4E9Xnk8cTtbxyF4M9Rx2KNrzZWhTLvMFinccS9KVrsdBycgFed/HGvSCcA+RKjCdm2zHCicXuSRzidPMbvXFbvuBmH71xWwfRsBh9PonScJ9LJwCok2swFn1e9fJxX1l9MXVKd19KeovSG2HfWqcx+Q/QXg6nJaFP0zWdAAbkq4ZuU3l95buT3lt5Q+RHkx5CeRHlp5WeSnkJ5UeUXkCfb0j0QN5bDpblPOLeU7k/IZjqHke5PuW3liO8eVQA7ATzhQBPOegFmA4gTzgUB0OVIFE6FAYmWKB+O6TuKBZgMTuJlQxJTriAAkVTt8QtEVTuwAtOhQHMligMTq0QLgLRC0QyOmeXuwJ5TzhGAR5Xjv47BO4Tqk6JOqTpk6e5VTriBFO+TpU7PO/xA07dO4mR06xO/Tqk6jOkzuI6aOleW9IvbZpwFx/Q9zDacX4BE3WD6cqcgRDmcPXC41xHT41PIXDNGFgzADB0FcBGDLcCFBUAKU3QAHDErrK6LMAE2pNhuWZzx8AwIMDWCE6sQzWCBA2OpAt2sMrvaFmAegFJMEGVUDYyBu/1Dk4McRVVcAETeHNa76QXPJKxgFd/yud0zMiRWZ6Kw+JzwcM4rq672sHrr67HITYG5yf9B0AEDlhDp0+zloSru27Ru/rv27AvXREMrkijbpm6tunhQoUpq/RBMaGKh+tuTB3OoITo5sqxC3AJbGK1frOu0ru26M60FkmhgzLVg6d+tLFle7AvIHvu61ujCBkqS4pIgxNNusHtoAke2KywpDM9viHAGuh6EuCo4YnrpVxbN0misRKHPlOT4e5Hqvz1IOdD+o2QC7spIN1TomFNcM13N2EIw9dByyePHpn3UrIN9FjL/k0bUmt0zEy1dSBk0NQLZS2UZJASse7roNyTs1AFM0lYH7pYY2esayUS7vUb1fguAX2FQL1elNFnNQesrtYybLK/Dwox1cgBuEd8igAHd9AOEG/Vy2TgGUph8pDTA0kQOWhWwygB211jEoKU2O46EbrWHULrHyFaI9SStM2ARu3rqSadiCgG+1aAT511btQb53hD60bpBcSdUESgBdUAIF3jZQXfsg6B8HSF3KMbgYwzW5ayM0HMNEXZGSxc1QZWE25qwU7nPYx1B2lsFe6WbQCj7aHFlqRf0d3HWDReQN3tp2hQiDXQh+3kARCF5GALz5kjboANdUnP9qAYe0WJRhy5uQtAxMOkSg2pzzYHPgZtd++6H7gqLWcAptcgeXmP7gKM/qmAfezdHABD+q2DWDf83HOAoJi1/urzgKELGPBKDG/uxQ6UkJRQA++0AgH6tStJXikRgUkRn7l2IOSuj72bzi3aUAWVE36UNbfuyZGoonsqNjSsIoB6oIHAdiMU/GsgUBO+2SRAHbgAfpozwBkSntpEB5FNyAXQVAdsL0B2Ggoh9+jdCaIlDWA2dB/UV4Dt4XDe4hnVT+l1DzU2uxxr4H7oclNAA9jbrG77yBygYECGQG90oJqBqAVAJKCBdW+A6Bn3o3QJDLK2Jx3sv0n8FCDJAGDwjI8JSSIVBwN3NxaCYYCRQhW7bTz4wWNqD9cc/IfuLBjux/VuARJdCV8G/BqgmqQkQTNlQBKCRoG84fB/wf8HQOUDmQB+QODMSJnOWNGcxC0KUJeBwlOhAiHIh3wdyrQCcIdsAshyIeiHkAaVleBZWFIdmBhke4GQAYhlEEeQ3YvOAyH8hgob8HVB9gzj6QMsob8pvB8gEyHmhooboLqqYWl6GCh1Qbj5uh4YayGihwUX0ALAPQA+AdoNAHYAJhyIdkkKISgen6KIZYf8HZJcUwUHxB9vkEt56/tS2GWh9tJEovQcYaaHmh9CSKGRgQnMoJC0X/oTZxIZACFwPPOfuuHThkJNyGehq4c+GihrNATA94v9BOHfB2SVxyL89YamBh+z/u2ZQR9CVklMTXFhozjNeEbQlZJRYGNg9hmgMdwBokgDyHPh3wcHg9EAftKCB+ygk1pKCIXigBkAaADRGvh0qJLoSAMbBe71e9gAm6fhwkfQkBAAka5HloWM1JHBDckcpHqRyAFpH6RsEe76kiZEcUGRKD4b5HJRhHTd1sR83zOQwACUfQlWhpkZZHxbZ03fQOR7oYVGeR34YVGk6O6GlHXhoUdxYKRsfxCHRR8Ub+G+RrUaDoKlDcn9A2Rg0fpHjRz4ckVdXaVArxXBjgXcHGovHHpHKCQId7pRQPQFCH6R4kYtGcuGkcDBYxwHsj9SR+0aTHHR5obNG49XFgTGxRjMZ9HTXELOG6OhmYEvy725nriVoOq6BqIuBkdDoQ6xvgbFz0sF3oepSBuQeZD1h4DHrG0QFQbOH0lDQa6FcNPkGhGhgcT1TJO+7Qeq4OCipXPCo7TzlQAFxtCV6xkALcgsA9QXFgAADMjmgBBDAQDVV5VArpUBxbPkH9Q+0E2OTdNxxAdHMygYRVUVmVH6iKINFZgBg89EaQBUQvWm+jzaugxhQWCzFR6E4gPa643DNU4JoARLYlBmD+grqO3K00HwO4Eh6s+yXFT8Gqc0ezia4IgG5JvCQa2+FRhO8aZVYFTJwEAGlFZnzggnGRSTd1g/1HFREiw930B90qwvcw5uCgL1grcSdH4Gi7bFERB9khF1syIQ6aDao/cPkHBczcntJYmFwdgH9RfEIXGn9doJIIq1EAcKrH43QEPuDgd+cTWXTbAZSbcpKCNcbE4ZVKOVBCVBqkclBP8SpUdR5K1Lrlj9k0AngmQkmgEURMKYPHC5MidwsC9+JtSOqpyxiJx9j5QchF6pd1EiD5JHzIuHULbgO4FqgaWT6A3NC4ZPoTpy7JBhpY9UaWgoA4QCTReheKerxtAcm04I3CKSQL00BsUXeq0rEJinrVcGCztzEm2JxPqp8EaNFj67lNM4E9Q3YGZXvHYFR8cxJqwdlSCdAJgwcwUOKThx6myFZVWbtqFdLCuyTUhhQsUOcCuxWZHkcaciyNwDJRa4fui3CJcGbRPFYVzPSqfBAJJgWOqyN1ZPpG4s0iq2ccO4fPQ7hZUeUmX8gp3Y1bYwphKbONFs7klIAbtOyj2MTAwfwinHpmEBS07AUAmxwvp3mphBFw0AjMpAZuEBrU/p24BUHwZmslz06EIgCMnYZq6LlI2w24E3GHpoGcbw5SLwzxwGbU40xBgQCIGVhbFVHMBBX25gGBAFAEhy4no+4zMY1vCN6datSgCTVbHqyWmYXh6ZlSZDhvA06G6nYU+ae4A83ThWvsRiboTv5YE3uxmnEiVUEFmUi8gFA5b5UjsLhKOLqfL9MiuqZ+MEwDHJuKosk4F0FwQVDB1HQwawDzh7iFxFBQhGM/MpA780DOgyjKwDOz98su2YgzVQKDIsxhUODJXgyzPxiQzksehG5a3VXgDSAmgcEaadS2zjRSb4sgYZ8cKwXMkYrPeH9lN45Z2u21JaCwTRK6Ye6aa2x5EFxjFAqJVsDYa9+bgHawFQce2FaskVAT7NHraueoYDuLgwT0WYD/HmggUIUGdBhkRyY4Bl+PoD7JSCO/BvYlAdgAcR6AVuY9I9gDudqHX23OfLAx541DYBi5pFGQZtuwUTsJidUeedADMFTHYi2qPcloAV57eZXB154vBk12sGAURQ9gYDq0VBWvExFbqBaezfbbPVdulaF7XoF7z3WWrkBBbtDe1JTHtDsDHr1WtqD0Bj7TEh1bwcE4kXZOlA1o3ZjWpoFNbkkc1uh1LWs9iGzzIJvtvYUdR1vR1nW/+zdbAHXHWAdEzVHR9aZhP1pgdYOQNup0UOJB3p1UHPDkjaiOVnVI4cHUqoTaloIBaIcdgEh1kRFQch1JVXtKhwl1P0aXXzaPqQtvIBmHJXQM4y24tkrazgO0l4c5F/h3rbBHRtuEdvJ1tot122mRxR45HNHh7bMePtps5VHFng0cR27RzHa/OfRxD0p2ox1nbTHOHEXb49RPT55j29duF5iMTPSccd286dkwD2j6g8c57LLh8cz2vxzQAekHbivb69UJwkc72lvQBzH22Jw+p4nB+d70P2pJy/aUnV7jScx9DJ0n0BcdhdydvucDqX19fFfWrHq2WDvsyV7BDovQggttiP1PMsRHQ6p6TDquiCsQEGOhAQAqEBBfjQEHU0cOT+W/lf5f+XBBvSRIg3l1CFwEBAuk0IEBBio8maQByZ1arYB1qwEC+aBlr+Wnk/5BeXYAbhGeQAVJAjeWg5MDXxA6WsDSYkBABTHpoAUZJbvteBDbTFW8mig5PqnJXAHPoCjIJjz31H7CbodUGGYDk2+Wfhv5YP9nAb5YrY8JtRSapEiRlUhWRoLzRhWHxj7JfH/gGoDGJ3x9gh2BE0e23WoGTQnuiVZzXFfuh7bewx2TdAn1CqhLg8AGWVZ4IYnrg0QaYlGElPHZOZSE6CfvCMdXYiaaUZcTRRRXdS9FbU8sViohxX+lPFZlcZMJOn3i4zDgHfRFkUlb1NOVrYG5WXxpQlXRz1XMHoAPxxiBiiHwaJRbRQltwNtqaVrdVdB9kvNVrGUu2bUeJqkLJi76VwDxThQ86lBsLrcXTuurAqQSg3uxAG00tv1yC+6uCUeA7iZO6Z+y1dJR7oOlTu1oPJgkfqaHF+qANucuUsoAtsNurwwiA8eoZBmRjoBNKqs60urw/Vl/SNXeTC1a3JQ1h6AjWWvRbyICuIozEEAR64JS0S0191czWvV7Nbv081gNcFUg1yiatWw1lSl28Y+SNa14A61sb1y/unkFWToQuuC3dE12tY2SVAZtCTx01j1azWFNX1adL21tokAzUu7tdLW2PftfLXB177uHWnuBE0mTlgydcI8a15NeCViohtYzXPVm/RzWlNaj3XXC14NeLXqkHdZIj91jRoSgjQFFCnXL105UhUVS29aXXm1lddzW11ulY7XN1kNY/Xw13da+DFvFUqRCE1wDfuVtlaarWrjaBdcbX71ngsfX79Z9eg2N1ote3WENr9ZfxkN5ZZcBs/N4urWk1oDe2Uvm0DabWH11tag2C1zta3WS1ijYp9v15hLITSwKtayAUsXbmiUiJxpUVXByTFUZcZVpQEg8zAPOsFhtlE5fpkRVtkBOXXjTxKmA9pkY0JXekXTfI8pF4yBeqJ/JQ2VNjgpQzVMGgxjYw2LlHM0YSEyz90M2VAV2wcNHN6rtI2XNxzeM2I5hWBnqUWjMBNjrN44BC34cIE1ZjJiOzfeVzbHM3ejnN+D0OGsDEQG02rlrzdfWktq5b83EeNKD+lzN2gFAtwtoLdAqIbCyDC2rNiLfZtbNpIEbXFNrRW6QL5yWFm4bgQYCqMEQXGA/t6jNUkaMxkpUjMttkZcPnji+KUPNXP3TFblpCV5SleM18clfM0+fEAx5n5thC2axRNT+FZXVPK2b9GGcZfqyW/2wYBNcUsM+dsBYAS+YFbNtCezJUxWiVqfnTtDjjlaWchVu/mjrX+dfUq0ABaWgqMLVpPs4cT/nPtIFr+h9xDWkHTvs4FqDUGy37O1pftcEW1qtaP7B1u/ssFkP0x032DizEQgHEBwJ1vW9zJJ1kd6Bwp0KFhByoW6dFB0Z16FzBxjaOdeNrFJRsYDpq4P56sm4WM2yh0Kds2uF2EXZdAtt8WWHEJf82CNDhyiZZF2lGrbddDdwbam29Ret0YnKRw7a7deRwx4tmQxcC5jF4nlMXyedznMWA9SxYC5y5N3U35jHT3Tnbo9cx3i449KxyT1AllbnscReJAaAhnHDFL3amHPxcR4Al1xfntgl89rCWAnOUekCols4FvbvJh9vb0n2pJZfaEnNJb+4MlzjRX73uHJYA7xtN4i+3ClufWKXCnSDpKcfI8pzg6Q+Kp1qWanBpcn56nWSVs1N9OhXZIYuzCHi7f9dgwywtkJg2m75jDVZUBBDGGHpBxVMlALwRufqkSJmDdvcElN1dk0j9/UPvc736uzP22YG9mfvkI69uaHrHJ9rtdDXJ94AxTNSkBUjahFuztyQUrcSMDYKq9Ck1b5LwAYczmRPJvaA9uqOerUN5DLff/15II/faw10SnA4phyK7EbkhNPtxNdCDRYDhT6cfvmCpZ0POv1QkYNGDJJnVpEEOsNyO7vfQ+6LYAXJLKO3lhS/cuuzTBHhAFXf8RicjEowVVAjFDnStZrQ5I9COM0gPLs0FhoAR9rIKshZ0dVY/HaAMg9N9JbR7GrjYD/S3gOaFDPFZ3eyXUlA1m44ZWQPDRPQh0ACFLLXwBFWRYBRBh9jvfFBBD0rXSApyW/ONRjIxrX8ROXHDeGViTKKkSBsFaadKA6gPPmQCt9kcYg9btDoA/3n9wWcnY7XKtjT4c9Cky1wOKJ8jln11P/dABlNxmBchaAEA/rNLbFhn5N56nDOEoUD7g94ot6TA+owDGHA5qRmtK/BT6H+Zg5DhqDOaa9ywKGohwT0sLnD/0vl+Q9Im/D5A54BUDxb0XRB62g+5mxLG5AwOqMWxgVgaQLLWKQ+MWKA/24DxtiEOvDjclQBxofpTiButvGlYRkD9DlQPz8fpQiBb+oSRr2aWbI91I/xPI6COyjlVV1WiARpqy0/xLQBuAKCdaghD7LH1XZHjx3/tfbw/FY9sByWSlkWzPe54C5BHVVbAQnG96g7mhDja1XuJeD2tbK1xAWQR6Ot2ExgEO2MBY5kOs4UQ6CMyDiSFaobZzI6kOIjphG2UVDjKbepN8SUBhI7s6z3jgAskhAfShGQchFim96qdLjWQcpc57Nj10j2rP515ePGGUHLCVyCT9kD0QvGXkF/zIDzY/AA2lUk7u7TySk+PHYzCk5xOAVmk7pOmT3Uc5NGTnE/dHWT3/PdHvl2k43I+T80cEh7lo8ElXM6pqHrGsB7sabGh1RGH9QunDPwVPE64nGVOunDcjy7YMN2G7Ud+rp27rE3C/l+3P8l3xYZGo7VljsQLP23jtxLDMEDsjgcPoKhg7ZO3GsBsZZHD71NZTHb5w+3SFQA2HLzIkczkIM7ERfoR5CDALdNk0xHeYcPtjOyAdfJU07SA4LoQETfK3FsvZlDocg5T2U8VPicAkBVOngNU5AyNT9GCOAizzYMzP8ukg6vdluhrHKnprI32qyig0Qactkt7AzVOfDtQyFNCnDqzhIK0QFHlPYzcQ/73GNZqfzptilI/aH6x/1GHRg0NNOVOwJJ9iozDQEsdnP5z9YEXPzRqA+ZHMicoFOYJ8Obj6sgrYXoFJooziEV43YJuGVpTt5rahdiQKmna3Nubbk6OzgXreQGVacwhCp7LPw0oCZ+5kekmZjDXhb1dttemgAqaQ7fKtArENMfNooujSvOa12Xj5o7bDs4XqdoK5FknLrM6ZNX+4MJKYOrKFhlYOToiwSO7HG7ylfQZrM00pNVcR/pzYyjEJmH7YXZCnNA3zi9DnRysY8e/P/gGcs2iR1Mi5xGkzl4zG5G8eOgaB64RjQpqSLkaDUKdBni5PKiW/Fdnh+4cADDdgLvV3dwFjPbfe53cQ7f0hHkPUiANcL843XT3unZLwvi8ddMUGhLpKjKBRLyy7h6jQOUfXTb8iHpcvAT6A57RF+owZmByt9VxdjbujI+gP0T3YgcmyS3v2tCKMcgErQIQEW3bwncb4DYAuQTK2+AgcsS/XJbT5cDS2r9bw1gsJLbTZv0au+kE2gHDO/SKuMoIE202nS3K7UtlkbTfU0Mt1M/n2eN6pHn32umfd6MDLzZ3+oWqNYOBz/Jt4+ivAUAHNmJ+kHbDIAE6Or1S6UQM1pbOeIgvqXJjsI9yCcP89vgtOenSoxauEZ1uOSq5D4K4syAT1tO8hcUECX2vljQnJYoCL9iZSPGANg6iYysKBS3JVQaM4apnr28dVBw+s5AevQVwM9mJlMZuowzyUAQ0BuGIQc4hBic4NmtnZtZs5IK6rTPzt8kIxACgyyWyPzDwI7WAwRlI/XbkC8LAZnD0R+uj7pR6meyzM6Jrj265P2rjtc8YBqVHG8KkN3WsmMOn9pABf2WndpisPa8NdK9B7CKMBVrYMZGEYBO0D/fsPEjkJhnRnDys2lRXD6wgxhQD7LUOu7gY67OBTrs021YormK/BA7SRzM51sFKyyuuiL9LARNlTqK9tnwXVc+nO4zUs7nOx/Lc7uAlz97v3Ohumc74Grbhc9tudz5c9TIpb50Um5+OBi/KteQWF1IZWLhFx63QALuF9BlSByEONPzf87u6vL2YxT4wLpY3wYe0e0vbPxTcXMBq55kSi8MBL83wouo7D26+issBY661q4qASCBeMQpzGOrCLDj6PegFk2wBFhXsBKBuj8Y8wBJjhhR6PDRCsBybwjpEAiB8AD4rhJqOErAk5duNu6sIIgfxE7uRZ4I/KPsDxrWnuljg7s6vBupkyxipqKMjRByUrUwAuxsH8ykGrLxxpsu2CeXHbMQyn6imBYLkfimAanKYGy5ruZrDvPruFreJB/UAO5r7R0D+/r7Q7ruHj9zCKO+puY7hqLMvBARfo/utL8C4/uoLm4HKwr7gIsfM77pcLRAH7xtmDBiTJQH665DPAfNvszNQ2ENVTenuBOkQAJCiVnp9w/GPJiB46w5kzOi/QeHz0Jk/vqjYAAywJTX+8sMw7yHCGONr2FMCr/ztnpBW5R7bewQk7tJwlM9L/w8mIZ7q9eQALhH/tLp/he4m81UFh7iqBg7K9mMHzU9o/7u5HpQ+zH1e429LOeZpOmeu9SOUe58hINW+Gv5SeW/kRIM5YDsBbVISGLsCb3jka0VZZQ8cZj4CE6iCNDmvFwg0QNEGdELhe+S0P/KPhK8y6hHoVwgkTjnDV97bmXsTQDE9ma35NDg0+yYhLXHvQifDekDgtsnwNbqrKeyLRitDa3J4qv8LAp5EBynpxuKfqeiXBBkCeuhD56+1R4JiSb3IdXkskkg9zLPsn8rzLOunsCefUMn87oKxG45lIdPYai2rQsKtlDvpWx97cEi2JItEGqfarqCrRAQZVM/lOePTp7592ngZ7PHMLbp8/cnqZmp6fWnw54gs6epy7YLMrs88BqhLSd3F7eercDgsBtSZ6bdnnmZ6OAue1U2OBPnkbReeNTZS3efRbOty+eboJTlBeaEJTiefAXqa96y5rmqd6dtmXkEJzeB5kYFJOVSsrjUyAEoHi1Mon49HOyULyYM5+ztkFoPCnCm+b2n4IZ/A1vD39EKOJDsXWpf30X9AZee94l8iCoqBEwKPe9iQ7q77+jkgEsRzyl6SDKx/0yH3aDkp593JXzk1V9XYqAwJudEvfG2Qcc+h5whgQPW5r3HsN+8zpnz/IDqMQ7zh43Qu4Ww0ju07m68CqTouE7IgtsauOJmNQXjDZ7BdITDtVnX57uTgG0BM54xBLT157I50JolJpuyExjxGT/Wi9bKQy8pNaINjeOYUT4j2WZFulUACuNwRvS2jDc8+LSeO5ugFeFjJPfYOF4wr3CiF+dzgV01gAWKCC+mySsPAB1VC3x7Kre2Af2zTlp86t9reBHlt8bfi8DQ/hLn1LN+Dgc33eH+vvgUN0hvF++YzSM0nFYxFLloOaxJMyTH/j7fH8+DIdoZsz3wfMM7iiF5RMnNuKVeYbh7o3R0Aeyg57Meqm8sb7LHpgdenCNnr8PuZgd5L9h3hmCLf1YR94/dEoUWiRTqxoavKBsceHLxxZu+ea7ZEHkfhCnXs3DUpZqxn3VOBKA5SjnQqDLp0bUemM8jcoB3xw28TQCUfo1K4K0vwSh1YHD7bN33yG57eakJD+zf4M+991YtYad52vLi0e7YB8TCgs4sa48zQSuSseQ39QWPpK9seEaMG6nQuPoOjMeRoSa/M8LAH0Ndx30C65Cvk+u87dg9XmFxr7/CYO4sN3z8fh4eI83rCRARjylnUv/R/VygejXTI3is1gva7Ka3J3G6Mf6x88OPfsmUs/lPSzsXKNudAEs57HZ8hz8gCaJwx50ATbyz5Q1IPvM+afZ9psZc+dzqK6c/AvzU+C+BDw+r8w9ui243Prb0l7qoiiI9/7DSbw0FzOAvjU4ehj2bmb8/TnintU9cvpOqCd8MxSObqLAdvZmH6PoyueWWkX7Zyp9b269pBSMcc+iDWCP4nd992PkRWBawZsRBI2omS64B+rTwPPOSU3oEl0iV7EC5Pi301+iP6v0k+LeKVlSYRPdUq6IFmO7S0ngycer2aLy4sE4irANDv3MSAkbIBlmnE321/IA+gBcnq+3VnaBmnwjdb77c9viHGkZuYOfCKyloKu8F2FAEd4Iyw6XgYS+mvNHqr1UvvD4bhyXiPoMGLyAtj45Y+uMxtMLMvfYwf5rbB+W15aIW2M1aQbk+0i+6/+hXMN3xdW5muIe4iK3dA2gEs2wSGzbBJNTUn6cbdTUCNmHZwZvcBu2C4V4/Owl9tSYMl5OoBEBUgXAGdFta3HMIMKzsOVnd6eqkkRAbIGIB2BgLIh6cv30fQEwye0YG4V/5QUcwXYdEDVc1YEEw66gOTPzArl/mfhH4NtZv5Umuv+1Uae/3In7zE2+xx+0BCw2+dXo5MDvzH6ogRKL3JkFeKPjpOI0j4tjhAzu86xgnxPfu3vINXWbDO2cYa+a218TK7fvmbty3YuQX54ADfnV7T+fXte3H+ZVa/53ew+2xESEGAW9VUBeCh/t5digXgdGBfvtIdCHdh3kF1+2r+LkdBa/sHwJ1rx2XW1Hfdav2Ahfx0iFnHcgc8d/1vIWqdInZDbqF0nYjbmdaNqYXY2lhZp3kAPP44WGdtNp4XlQCh34XWdwRdocZ2TndEXudyRb53AgOOJkWa2xRZF3a2sXZUWJd03Sl2O9LRaM4dFmvnl3zOAxed1cePXajzPdNXd91R2rXdp4rFydr12aUA3aRcexaxcCxxm7ZdrWOeP5p6DdoOOZvDbtAHI+LNxz+LI9op6E9oV6fVbhLQaC16MRDXtBvQxLQPbxLYPaJLRHjJLFOAR7DcDJOaPbaXEHhx7a3SETFQRz/ZPZgdBfQQdUpZQdTPaVLZACVOIfi3pZDodsMJp5ABpzrAcOYuBCva12Kvaw9VUyPXDkzgAdjQImf/RkAZP6UAOK6g/WOryIeeotodmazEC8idfbr69fENzeHBgwIYDC5aAiHDR5WswLdHwBGmTtyL8XmAhXVC4j8AdiWNGdS0mIKp22LiBXWcormQGOQJHc75oAE8o92Lhq0AbwFnfOqjJvACxvMXV61dM0CMjJyxfwIj4afWrrUfTtwEoE+rKbSQGgraQGyAv9xm2C5TyQbgT17G77fAe4gM/LAzy/RX71aJjYXKRdDcCf34R9FwxgkEoFM/FX4EKK9aXKSdD5Ar5iToMZTFvYoEqIRn5lAoTQpYHiBWAps5D7ImAn1EZ6mADsA2mHQrfBZ9BN2eJQlhVojJwPNTDqGVot4aJxrAzQbWHWeBYXKPpPVJQD8cJ6h+3G4BPnWFzlAV87GvZT4boWVBmgb879AV9r1JO6IjqCGaMafGwiPSJxiPP9qQXJX5bAxlSY3UdCyAjeiBzdlDP1NZTT9IwCDodvigoeUBIUMJYwAFw6JQHIF4YWMxOPJkwQjF/LqbP/L16RdQUQGdZIKECSE5bgS1kUUyD1cr5wZGgIbkRKDZwHYCnUI4BdEekEA5Ecbu4d0Z2IcUBiSEMKxYclC2MPvbOAJx47QK4il+FDKZbHLBH5IUxIgz6JKGBM44gtsyJQBM5BrIo5uUWeqygxdQIzJQxb7Wl74gpvYy0SMCEg+vJ4uUpCNAEkHKg5gzkgyr4PFcUGqg2kHwgekEGYRkEakZkFCPNkHQgzkEdfckHUcfkHfAQUHDvYUFBrYAxig6kGLqY6JSgvEYygzQiLqeUHqg0/aag1oGUYBMD2cT0E/AFe6bNZI7T9VkHsgmEGP5Dr4UQFG7xg6rAgkaoDvkJIi93cS4mg837QAFca7EQMEnGSfikg5ywLwH8BCAsqprEKUF9A0oGA3Pyj2gjuBRglRDb7YmAVA+zYogx4jMABMGljclwrjKNCJfHiLEsFL4YmbVZ3Aed52qH/h78ZaZfjaNRgKedRgTdtg/gVwbT4dhSbg6d6OAKkG4g2770mD3I9jMsGJQRDzd1HcH04Z2Z44LwYvABrz7gy0Ftmed47AY8EqgtsyAGfpxhVVoFjghwCW+AVyxgyPyJg7gRCArH6BmJ+D9OS8G3fQQYngtszimOEBKGDOqwQxCG+HGdZ6wRMF5A1ihpg80bOgjkFbAAd5lgwAye+OsGeQV8GrYEbKtAiiDyQVJJPsUBBFgzdAiUUsGUQscZjbCiDIQk0EUQ6sFugRDyCWMbAwQyiEmTXiHorLiHorPsEtAyoFDgzkwQZCSTbMC/JYg/0Gfg8MFtmYMF6EUMFoQt0CRgqg5M/dl5aQ9NY97AcGxbXIFVYOwAgYGtQogJeBKQ0UEqQoUzqQ3EbGwMMFCmBM4zrET5IRPUGO+PFytg0T5xmOvJeQ+A68QwHyOzSkBhsXwAsIZTZ1mIuoOPcDK2qQVwxQlG6cmFlyK3YCSZHFlwgZIOSuzJG55STlwAQuKGYbQnLO+DXyXEXCGjjdMEugoiHu+aCpCgwj44cDnAEKAABQ0QwAAxLUhJEnnBH2JwUIQDZIVgHqR0XkcAfnkcBWAPt17JjdcgAA=="]');
// EXTERNAL MODULE: ./node_modules/lz-string/libs/lz-string.js
var lz_string = __nested_webpack_require_9759__(961);
var lz_string_default = /*#__PURE__*/__nested_webpack_require_9759__.n(lz_string);
;// CONCATENATED MODULE: ./src/helpers/script_ww_api.js




// Webworker interface
// Compiled webworker (see webpack/ww_plugin.js)



 // For webworker-loader to find the ww

var WebWork = /*#__PURE__*/function () {
  function WebWork(dc) {
    classCallCheck_classCallCheck(this, WebWork);

    this.dc = dc;
    this.tasks = {};

    this.onevent = function () {};

    this.start();
  }

  createClass_createClass(WebWork, [{
    key: "start",
    value: function start() {
      var _this = this;

      if (this.worker) this.worker.terminate(); // URL.createObjectURL

      window.URL = window.URL || window.webkitURL;
      var data = lz_string_default().decompressFromBase64(ww$$$_namespaceObject[0]);
      var blob;

      try {
        blob = new Blob([data], {
          type: 'application/javascript'
        });
      } catch (e) {
        // Backwards-compatibility
        window.BlobBuilder = window.BlobBuilder || window.WebKitBlobBuilder || window.MozBlobBuilder;
        blob = new BlobBuilder();
        blob.append(data);
        blob = blob.getBlob();
      }

      this.worker = new Worker(URL.createObjectURL(blob));

      this.worker.onmessage = function (e) {
        return _this.onmessage(e);
      };
    }
  }, {
    key: "start_socket",
    value: function start_socket() {
      var _this2 = this;

      if (!this.dc.sett.node_url) return;
      this.socket = new WebSocket(this.dc.sett.node_url);
      this.socket.addEventListener('message', function (e) {
        _this2.onmessage({
          data: JSON.parse(e.data)
        });
      });
      this.msg_queue = [];
    }
  }, {
    key: "send",
    value: function send(msg, tx_keys) {
      if (this.dc.sett.node_url) {
        return this.send_node(msg, tx_keys);
      }

      if (tx_keys) {
        var tx_objs = tx_keys.map(function (k) {
          return msg.data[k];
        });
        this.worker.postMessage(msg, tx_objs);
      } else {
        this.worker.postMessage(msg);
      }
    } // Send to node.js via websocket

  }, {
    key: "send_node",
    value: function send_node(msg, tx_keys) {
      if (!this.socket) this.start_socket();

      if (this.socket && this.socket.readyState) {
        // Send the old messages first
        while (this.msg_queue.length) {
          var m = this.msg_queue.shift();
          this.socket.send(JSON.stringify(m));
        }

        this.socket.send(JSON.stringify(msg));
      } else {
        this.msg_queue.push(msg);
      }
    }
  }, {
    key: "onmessage",
    value: function onmessage(e) {
      if (e.data.id in this.tasks) {
        this.tasks[e.data.id](e.data.data);
        delete this.tasks[e.data.id];
      } else {
        this.onevent(e);
      }
    } // Execute a task

  }, {
    key: "exec",
    value: function () {
      var _exec = _asyncToGenerator( /*#__PURE__*/regenerator_default().mark(function _callee(type, data, tx_keys) {
        var _this3 = this;

        return regenerator_default().wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                return _context.abrupt("return", new Promise(function (rs, rj) {
                  var id = utils.uuid();

                  _this3.send({
                    type: type,
                    id: id,
                    data: data
                  }, tx_keys);

                  _this3.tasks[id] = function (res) {
                    rs(res);
                  };
                }));

              case 1:
              case "end":
                return _context.stop();
            }
          }
        }, _callee);
      }));

      function exec(_x, _x2, _x3) {
        return _exec.apply(this, arguments);
      }

      return exec;
    }() // Execute a task, but just fucking do it,
    // do not wait for the result

  }, {
    key: "just",
    value: function just(type, data, tx_keys) {
      var id = utils.uuid();
      this.send({
        type: type,
        id: id,
        data: data
      }, tx_keys);
    } // Relay an event from iframe postMessage
    // (for the future)

  }, {
    key: "relay",
    value: function () {
      var _relay = _asyncToGenerator( /*#__PURE__*/regenerator_default().mark(function _callee2(event, just) {
        var _this4 = this;

        return regenerator_default().wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                if (just === void 0) {
                  just = false;
                }

                return _context2.abrupt("return", new Promise(function (rs, rj) {
                  _this4.send(event, event.tx_keys);

                  if (!just) {
                    _this4.tasks[event.id] = function (res) {
                      rs(res);
                    };
                  }
                }));

              case 2:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee2);
      }));

      function relay(_x4, _x5) {
        return _relay.apply(this, arguments);
      }

      return relay;
    }()
  }, {
    key: "destroy",
    value: function destroy() {
      if (this.worker) this.worker.terminate();
    }
  }]);

  return WebWork;
}();

/* harmony default export */ const script_ww_api = (WebWork);
;// CONCATENATED MODULE: ./src/helpers/script_utils.js


var FDEFS = /(function |)([$A-Z_][0-9A-Z_$\.]*)[\s]*?\((.*?)\)/gmi;
var SBRACKETS = /([$A-Z_][0-9A-Z_$\.]*)[\s]*?\[([^"^\[^\]]+?)\]/gmi;
var TFSTR = /(\d+)(\w*)/gm;
var BUF_INC = 5;
var tf_cache = {};
function f_args(src) {
  FDEFS.lastIndex = 0;
  var m = FDEFS.exec(src);

  if (m) {
    var fkeyword = m[1].trim();
    var fname = m[2].trim();
    var fargs = m[3].trim();
    return fargs.split(',').map(function (x) {
      return x.trim();
    });
  }

  return [];
}
function f_body(src) {
  return src.slice(src.indexOf("{") + 1, src.lastIndexOf("}"));
}
function wrap_idxs(src, pre) {
  if (pre === void 0) {
    pre = '';
  }

  SBRACKETS.lastIndex = 0;
  var changed = false;

  do {
    var m = SBRACKETS.exec(src);

    if (m) {
      var vname = m[1].trim();
      var vindex = m[2].trim();

      if (vindex === '0' || parseInt(vindex) < BUF_INC) {
        continue;
      }

      switch (vname) {
        case 'let':
        case 'var':
        case 'return':
          continue;
      } //let wrap = `${pre}_v(${vname}, ${vindex})[${vindex}]`


      var wrap = "".concat(vname, "[").concat(pre, "_i(").concat(vindex, ", ").concat(vname, ")]");
      src = src.replace(m[0], wrap);
      changed = true;
    }
  } while (m);

  return changed ? src : src;
} // Get all module helper classes

function make_module_lib(mod) {
  var lib = {};

  for (var k in mod) {
    if (k === 'main' || k === 'id') continue;
    var a = f_args(mod[k]);
    lib[k] = new Function(a, f_body(mod[k]));
  }

  return lib;
}
function get_raw_src(f) {
  if (typeof f === 'string') return f;
  var src = f.toString();
  return src.slice(src.indexOf("{") + 1, src.lastIndexOf("}"));
} // Get tf in ms from pairs such (`15`, `m`)

function tf_from_pair(num, pf) {
  var mult = 1;

  switch (pf) {
    case 's':
      mult = Const.SECOND;
      break;

    case 'm':
      mult = Const.MINUTE;
      break;

    case 'H':
      mult = Const.HOUR;
      break;

    case 'D':
      mult = Const.DAY;
      break;

    case 'W':
      mult = Const.WEEK;
      break;

    case 'M':
      mult = Const.MONTH;
      break;

    case 'Y':
      mult = Const.YEAR;
      break;
  }

  return parseInt(num) * mult;
}
function tf_from_str(str) {
  if (typeof str === 'number') return str;
  if (tf_cache[str]) return tf_cache[str];
  TFSTR.lastIndex = 0;
  var m = TFSTR.exec(str);

  if (m) {
    tf_cache[str] = tf_from_pair(m[1], m[2]);
    return tf_cache[str];
  }

  return undefined;
}
function get_fn_id(pre, id) {
  return pre + '-' + id.split('<-').pop();
} // Apply filter for all new overlays

function ovf(obj, f) {
  var nw = {};

  for (var id in obj) {
    nw[id] = {};

    for (var k in obj[id]) {
      if (k === 'data') continue;
      nw[id][k] = obj[id][k];
    }

    nw[id].data = f(obj[id].data);
  }

  return nw;
} // Return index of the next element in
// dataset (since t). Impl: simple binary search
// TODO: optimize (remember the penultimate
// iteration and start from there)

function nextt(data, t, ti) {
  if (ti === void 0) {
    ti = 0;
  }

  var i0 = 0;
  var iN = data.length - 1;

  while (i0 <= iN) {
    var mid = Math.floor((i0 + iN) / 2);

    if (data[mid][ti] === t) {
      return mid;
    } else if (data[mid][ti] < t) {
      i0 = mid + 1;
    } else {
      iN = mid - 1;
    }
  }

  return t < data[mid][ti] ? mid : mid + 1;
} // Estimated size of datasets

function size_of_dss(data) {
  var bytes = 0;

  for (var id in data) {
    if (data[id].data && data[id].data[0]) {
      var s0 = size_of(data[id].data[0]);
      bytes += s0 * data[id].data.length;
    }
  }

  return bytes;
} // Used to measure the size of dataset

function size_of(object) {
  var list = [],
      stack = [object],
      bytes = 0;

  while (stack.length) {
    var value = stack.pop();

    var type = _typeof(value);

    if (type === 'boolean') {
      bytes += 4;
    } else if (type === 'string') {
      bytes += value.length * 2;
    } else if (type === 'number') {
      bytes += 8;
    } else if (type === 'object' && list.indexOf(value) === -1) {
      list.push(value);

      for (var i in value) {
        stack.push(value[i]);
      }
    }
  }

  return bytes;
} // Update onchart/offchart

function update(data, val) {
  var i = data.length - 1;
  var last = data[i];

  if (!last || val[0] > last[0]) {
    data.push(val);
  } else {
    data[i] = val;
  }
}
function script_utils_now() {
  return new Date().getTime();
}
;// CONCATENATED MODULE: ./src/helpers/dataset.js





function dataset_createForOfIteratorHelper(o, allowArrayLike) { var it; if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (it = dataset_unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = o[Symbol.iterator](); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it["return"] != null) it["return"](); } finally { if (didErr) throw err; } } }; }

function dataset_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return dataset_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return dataset_arrayLikeToArray(o, minLen); }

function dataset_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }


// Dataset proxy between vuejs & WebWorker


var Dataset = /*#__PURE__*/function () {
  function Dataset(dc, desc) {
    classCallCheck_classCallCheck(this, Dataset);

    // TODO: dataset url arrow fn tells WW
    // to load the ds directly from web
    this.type = desc.type;
    this.id = desc.id;
    this.dc = dc; // Send the data to WW

    if (desc.data) {
      this.dc.ww.just('upload-data', _defineProperty({}, this.id, desc)); // Remove the data from the descriptor

      delete desc.data;
    }

    var proto = Object.getPrototypeOf(this);
    Object.setPrototypeOf(desc, proto);
    Object.defineProperty(desc, 'dc', {
      get: function get() {
        return dc;
      }
    });
  } // Watch for the changes of descriptors


  createClass_createClass(Dataset, [{
    key: "set",
    value: // Set data (overwrite the whole dataset)
    function set(data, exec) {
      if (exec === void 0) {
        exec = true;
      }

      this.dc.ww.just('dataset-op', {
        id: this.id,
        type: 'set',
        data: data,
        exec: exec
      });
    } // Update with new data (array of data points)

  }, {
    key: "update",
    value: function update(arr) {
      this.dc.ww.just('update-data', _defineProperty({}, this.id, arr));
    } // Send WW a chunk to merge. The merge algo
    // here is simpler than in DC. It just adds
    // data at the beginning or/and the end of ds

  }, {
    key: "merge",
    value: function merge(data, exec) {
      if (exec === void 0) {
        exec = true;
      }

      this.dc.ww.just('dataset-op', {
        id: this.id,
        type: 'mrg',
        data: data,
        exec: exec
      });
    } // Remove the ds from WW

  }, {
    key: "remove",
    value: function remove(exec) {
      if (exec === void 0) {
        exec = true;
      }

      this.dc.del("datasets.".concat(this.id));
      this.dc.ww.just('dataset-op', {
        id: this.id,
        type: 'del',
        exec: exec
      });
      delete this.dc.dss[this.id];
    } // Fetch data from WW

  }, {
    key: "data",
    value: function () {
      var _data = _asyncToGenerator( /*#__PURE__*/regenerator_default().mark(function _callee() {
        var ds;
        return regenerator_default().wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                _context.next = 2;
                return this.dc.ww.exec('get-dataset', this.id);

              case 2:
                ds = _context.sent;

                if (ds) {
                  _context.next = 5;
                  break;
                }

                return _context.abrupt("return");

              case 5:
                return _context.abrupt("return", ds.data);

              case 6:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, this);
      }));

      function data() {
        return _data.apply(this, arguments);
      }

      return data;
    }()
  }], [{
    key: "watcher",
    value: function watcher(n, p) {
      var nids = n.map(function (x) {
        return x.id;
      });
      var pids = p.map(function (x) {
        return x.id;
      });

      var _iterator = dataset_createForOfIteratorHelper(nids),
          _step;

      try {
        for (_iterator.s(); !(_step = _iterator.n()).done;) {
          var id = _step.value;

          if (!pids.includes(id)) {
            var ds = n.filter(function (x) {
              return x.id === id;
            })[0];
            this.dss[id] = new Dataset(this, ds);
          }
        }
      } catch (err) {
        _iterator.e(err);
      } finally {
        _iterator.f();
      }

      var _iterator2 = dataset_createForOfIteratorHelper(pids),
          _step2;

      try {
        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
          var id = _step2.value;

          if (!nids.includes(id) && this.dss[id]) {
            this.dss[id].remove();
          }
        }
      } catch (err) {
        _iterator2.e(err);
      } finally {
        _iterator2.f();
      }
    } // Make an object for data transfer

  }, {
    key: "make_tx",
    value: function make_tx(dc, types) {
      var main = dc.data.chart.data;
      var base = {};

      if (types.find(function (x) {
        return x.type === 'OHLCV';
      })) {
        base = {
          ohlcv: main
        };
      } // TODO: add more sophisticated search
      // (using 'script.datasets' paramerter)

      /*for (var req of types) {
          let ds = Object.values(dc.dss || {})
              .find(x => x.type === req.type)
          if (ds && ds.data) {
              base[ds.id] = {
                  id: ds.id,
                  type: ds.type,
                  data: ds.data
              }
          }
      }*/
      // TODO: Data request callback ?


      return base;
    }
  }]);

  return Dataset;
}(); // Dataset reciever (created on WW)



var DatasetWW = /*#__PURE__*/(/* unused pure expression or super */ null && (0));
;// CONCATENATED MODULE: ./src/helpers/dc_events.js





function dc_events_createForOfIteratorHelper(o, allowArrayLike) { var it; if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (it = dc_events_unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = o[Symbol.iterator](); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it["return"] != null) it["return"](); } finally { if (didErr) throw err; } } }; }

function dc_events_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return dc_events_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return dc_events_arrayLikeToArray(o, minLen); }

function dc_events_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

// DataCube event handlers





var DCEvents = /*#__PURE__*/function () {
  function DCEvents() {
    var _this = this;

    classCallCheck_classCallCheck(this, DCEvents);

    this.ww = new script_ww_api(this); // Listen to the web-worker events

    this.ww.onevent = function (e) {
      var _iterator = dc_events_createForOfIteratorHelper(_this.tv.controllers),
          _step;

      try {
        for (_iterator.s(); !(_step = _iterator.n()).done;) {
          var ctrl = _step.value;
          if (ctrl.ww) ctrl.ww(e.data);
        }
      } catch (err) {
        _iterator.e(err);
      } finally {
        _iterator.f();
      }

      switch (e.data.type) {
        case 'request-data':
          // TODO: DataTunnel class for smarter data transfer
          if (_this.ww._data_uploading) break;
          var data = Dataset.make_tx(_this, e.data.data);

          _this.send_meta_2_ww();

          _this.ww.just('upload-data', data);

          _this.ww._data_uploading = true;
          break;

        case 'overlay-data':
          _this.on_overlay_data(e.data.data);

          break;

        case 'overlay-update':
          _this.on_overlay_update(e.data.data);

          break;

        case 'data-uploaded':
          _this.ww._data_uploading = false;
          break;

        case 'engine-state':
          _this.se_state = Object.assign(_this.se_state || {}, e.data.data);
          break;

        case 'modify-overlay':
          _this.modify_overlay(e.data.data);

          break;

        case 'script-signal':
          _this.tv.$emit('signal', e.data.data);

          break;
      }

      var _iterator2 = dc_events_createForOfIteratorHelper(_this.tv.controllers),
          _step2;

      try {
        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
          var ctrl = _step2.value;
          if (ctrl.post_ww) ctrl.post_ww(e.data);
        }
      } catch (err) {
        _iterator2.e(err);
      } finally {
        _iterator2.f();
      }
    };
  } // Called when overalay/tv emits 'custom-event'


  createClass_createClass(DCEvents, [{
    key: "on_custom_event",
    value: function on_custom_event(event, args) {
      switch (event) {
        case 'register-tools':
          this.register_tools(args);
          break;

        case 'exec-script':
          this.exec_script(args);
          break;

        case 'exec-all-scripts':
          this.exec_all_scripts();
          break;

        case 'data-len-changed':
          this.data_changed(args);
          break;

        case 'tool-selected':
          if (!args[0]) break; // TODO: Quick fix, investigate

          if (args[0].split(':')[0] === 'System') {
            this.system_tool(args[0].split(':')[1]);
            break;
          }

          this.tv.$set(this.data, 'tool', args[0]);

          if (args[0] === 'Cursor') {
            this.drawing_mode_off();
          }

          break;

        case 'grid-mousedown':
          this.grid_mousedown(args);
          break;

        case 'drawing-mode-off':
          this.drawing_mode_off();
          break;

        case 'change-settings':
          this.change_settings(args);
          break;

        case 'range-changed':
          this.scripts_onrange.apply(this, _toConsumableArray(args));
          break;

        case 'scroll-lock':
          this.on_scroll_lock(args[0]);
          break;

        case 'object-selected':
          this.object_selected(args);
          break;

        case 'remove-tool':
          this.system_tool('Remove');
          break;

        case 'before-destroy':
          this.before_destroy();
          break;
      }
    } // Triggered when one or multiple settings are changed
    // We select only the changed ones & re-exec them on the
    // web worker

  }, {
    key: "on_settings",
    value: function on_settings(values, prev) {
      var _this2 = this;

      if (!this.sett.scripts) return;
      var delta = {};
      var changed = false;

      var _loop = function _loop() {
        var n = values[i];
        var arr = prev.filter(function (x) {
          return x.v === n.v;
        });

        if (!arr.length && n.p.settings.$props) {
          var id = n.p.settings.$uuid;

          if (utils.is_scr_props_upd(n, prev) && utils.delayed_exec(n.p)) {
            delta[id] = n.v;
            changed = true;

            _this2.tv.$set(n.p, 'loading', true);
          }
        }
      };

      for (var i = 0; i < values.length; i++) {
        _loop();
      }

      if (changed && Object.keys(delta).length) {
        var tf = this.tv.$refs.chart.interval_ms || this.data.chart.tf;
        var range = this.tv.getRange();
        this.ww.just('update-ov-settings', {
          delta: delta,
          tf: tf,
          range: range
        });
      }
    } // When the set of $uuids is changed

  }, {
    key: "on_ids_changed",
    value: function on_ids_changed(values, prev) {
      var rem = prev.filter(function (x) {
        return x !== undefined && !values.includes(x);
      });

      if (rem.length) {
        this.ww.just('remove-scripts', rem);
      }
    } // Combine all tools and their mods

  }, {
    key: "register_tools",
    value: function register_tools(tools) {
      var preset = {};

      var _iterator3 = dc_events_createForOfIteratorHelper(this.data.tools || []),
          _step3;

      try {
        for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {
          var tool = _step3.value;
          preset[tool.type] = tool;
          delete tool.type;
        }
      } catch (err) {
        _iterator3.e(err);
      } finally {
        _iterator3.f();
      }

      this.tv.$set(this.data, 'tools', []);
      var list = [{
        type: 'Cursor',
        icon: icons_namespaceObject["cursor.png"]
      }];

      var _iterator4 = dc_events_createForOfIteratorHelper(tools),
          _step4;

      try {
        for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {
          var tool = _step4.value;
          var proto = Object.assign({}, tool.info);
          var type = tool.info.type || 'Default';
          proto.type = "".concat(tool.use_for, ":").concat(type);
          this.merge_presets(proto, preset[tool.use_for]);
          this.merge_presets(proto, preset[proto.type]);
          delete proto.mods;
          list.push(proto);

          for (var mod in tool.info.mods) {
            var mp = Object.assign({}, proto);
            mp = Object.assign(mp, tool.info.mods[mod]);
            mp.type = "".concat(tool.use_for, ":").concat(mod);
            this.merge_presets(mp, preset[tool.use_for]);
            this.merge_presets(mp, preset[mp.type]);
            list.push(mp);
          }
        }
      } catch (err) {
        _iterator4.e(err);
      } finally {
        _iterator4.f();
      }

      this.tv.$set(this.data, 'tools', list);
      this.tv.$set(this.data, 'tool', 'Cursor');
    }
  }, {
    key: "exec_script",
    value: function exec_script(args) {
      if (args.length && this.sett.scripts) {
        var obj = this.get_overlay(args[0]);
        if (!obj || obj.scripts === false) return;

        if (obj.script && obj.script.src) {
          args[0].src = obj.script.src; // opt, override the src
        } // Parse script props & get the values from the ov
        // TODO: remove unnecessary script initializations


        var s = obj.settings;
        var props = args[0].src.props || {};
        if (!s.$uuid) s.$uuid = "".concat(obj.type, "-").concat(utils.uuid2());
        args[0].uuid = s.$uuid;
        args[0].sett = s;

        for (var k in props || {}) {
          var proto = props[k];

          if (s[k] !== undefined) {
            proto.val = s[k]; // use the existing val

            continue;
          }

          if (proto.def === undefined) {
            // TODO: add support of info / errors to the legend
            console.error("Overlay ".concat(obj.id, ": script prop '").concat(k, "' ") + "doesn't have a default value");
            return;
          }

          s[k] = proto.val = proto.def; // set the default
        } // Remove old props (dropped by the current exec)


        if (s.$props) {
          for (var k in s) {
            if (s.$props.includes(k) && !(k in props)) {
              delete s[k];
            }
          }
        }

        s.$props = Object.keys(args[0].src.props || {});
        this.tv.$set(obj, 'loading', true);
        var tf = this.tv.$refs.chart.interval_ms || this.data.chart.tf;
        var range = this.tv.getRange();

        if (obj.script && obj.script.output != null) {
          args[0].output = obj.script.output;
        }

        this.ww.just('exec-script', {
          s: args[0],
          tf: tf,
          range: range
        });
      }
    }
  }, {
    key: "exec_all_scripts",
    value: function exec_all_scripts() {
      if (!this.sett.scripts) return;
      this.set_loading(true);
      var tf = this.tv.$refs.chart.interval_ms || this.data.chart.tf;
      var range = this.tv.getRange();
      this.ww.just('exec-all-scripts', {
        tf: tf,
        range: range
      });
    }
  }, {
    key: "scripts_onrange",
    value: function scripts_onrange(r) {
      if (!this.sett.scripts) return;
      var delta = {};
      this.get('.').forEach(function (v) {
        if (v.script && v.script.execOnRange && v.settings.$uuid) {
          // TODO: execInterrupt flag?
          if (utils.delayed_exec(v)) {
            delta[v.settings.$uuid] = v.settings;
          }
        }
      });

      if (Object.keys(delta).length) {
        var tf = this.tv.$refs.chart.interval_ms || this.data.chart.tf;
        var range = this.tv.getRange();
        this.ww.just('update-ov-settings', {
          delta: delta,
          tf: tf,
          range: range
        });
      }
    } // Overlay modification from WW

  }, {
    key: "modify_overlay",
    value: function modify_overlay(upd) {
      var obj = this.get_overlay(upd);

      if (obj) {
        for (var k in upd.fields || {}) {
          if (typeof_typeof(obj[k]) === 'object') {
            this.merge("".concat(upd.uuid, ".").concat(k), upd.fields[k]);
          } else {
            this.tv.$set(obj, k, upd.fields[k]);
          }
        }
      }
    }
  }, {
    key: "data_changed",
    value: function data_changed(args) {
      if (!this.sett.scripts) return;
      if (this.sett.data_change_exec === false) return;
      var main = this.data.chart.data;
      if (this.ww._data_uploading) return;
      if (!this.se_state.scripts) return;
      this.send_meta_2_ww();
      this.ww.just('upload-data', {
        ohlcv: main
      });
      this.ww._data_uploading = true;
      this.set_loading(true);
    }
  }, {
    key: "set_loading",
    value: function set_loading(flag) {
      var skrr = this.get('.').filter(function (x) {
        return x.settings.$props;
      });

      var _iterator5 = dc_events_createForOfIteratorHelper(skrr),
          _step5;

      try {
        for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {
          var s = _step5.value;
          this.merge("".concat(s.id), {
            loading: flag
          });
        }
      } catch (err) {
        _iterator5.e(err);
      } finally {
        _iterator5.f();
      }
    }
  }, {
    key: "send_meta_2_ww",
    value: function send_meta_2_ww() {
      var tf = this.tv.$refs.chart.interval_ms || this.data.chart.tf;
      var range = this.tv.getRange();
      this.ww.just('send-meta-info', {
        tf: tf,
        range: range
      });
    }
  }, {
    key: "merge_presets",
    value: function merge_presets(proto, preset) {
      if (!preset) return;

      for (var k in preset) {
        if (k === 'settings') {
          Object.assign(proto[k], preset[k]);
        } else {
          proto[k] = preset[k];
        }
      }
    }
  }, {
    key: "grid_mousedown",
    value: function grid_mousedown(args) {
      var _this3 = this;

      // TODO: tool state finished?
      this.object_selected([]); // Remove the previous RangeTool

      var rem = function rem() {
        return _this3.get('RangeTool').filter(function (x) {
          return x.settings.shiftMode;
        }).forEach(function (x) {
          return _this3.del(x.id);
        });
      };

      if (this.data.tool && this.data.tool !== 'Cursor' && !this.data.drawingMode) {
        // Prevent from "null" tools (tool created with HODL)
        if (args[1].type !== 'tap') {
          this.tv.$set(this.data, 'drawingMode', true);
          this.build_tool(args[0]);
        } else {
          this.tv.showTheTip("<b>Hodl</b>+<b>Drug</b> to create, " + "<b>Tap</b> to finish a tool");
        }
      } else if (this.sett.shift_measure && args[1].shiftKey) {
        rem();
        this.tv.$nextTick(function () {
          return _this3.build_tool(args[0], 'RangeTool:ShiftMode');
        });
      } else {
        rem();
      }
    }
  }, {
    key: "drawing_mode_off",
    value: function drawing_mode_off() {
      this.tv.$set(this.data, 'drawingMode', false);
      this.tv.$set(this.data, 'tool', 'Cursor');
    } // Place a new tool

  }, {
    key: "build_tool",
    value: function build_tool(grid_id, type) {
      var list = this.data.tools;
      type = type || this.data.tool;
      var proto = list.find(function (x) {
        return x.type === type;
      });
      if (!proto) return;
      var sett = Object.assign({}, proto.settings || {});
      var data = (proto.data || []).slice();
      if (!('legend' in sett)) sett.legend = false;
      if (!('z-index' in sett)) sett['z-index'] = 100;
      sett.$selected = true;
      sett.$state = 'wip';
      var side = grid_id ? 'offchart' : 'onchart';
      var id = this.add(side, {
        name: proto.name,
        type: type.split(':')[0],
        settings: sett,
        data: data,
        grid: {
          id: grid_id
        }
      });
      sett.$uuid = "".concat(id, "-").concat(utils.now());
      this.tv.$set(this.data, 'selected', sett.$uuid);
      this.add_trash_icon();
    } // Remove selected / Remove all, etc

  }, {
    key: "system_tool",
    value: function system_tool(type) {
      switch (type) {
        case 'Remove':
          if (this.data.selected) {
            this.del(this.data.selected);
            this.remove_trash_icon();
            this.drawing_mode_off();
            this.on_scroll_lock(false);
          }

          break;
      }
    } // Apply new overlay settings

  }, {
    key: "change_settings",
    value: function change_settings(args) {
      var settings = args[0];
      delete settings.id;
      var grid_id = args[1];
      this.merge("".concat(args[3], ".settings"), settings);
    } // Lock the scrolling mechanism

  }, {
    key: "on_scroll_lock",
    value: function on_scroll_lock(flag) {
      this.tv.$set(this.data, 'scrollLock', flag);
    } // When new object is selected / unselected

  }, {
    key: "object_selected",
    value: function object_selected(args) {
      var q = this.data.selected;

      if (q) {
        // Check if current drawing is finished
        //let res = this.get_one(`${q}.settings`)
        //if (res && res.$state !== 'finished') return
        this.merge("".concat(q, ".settings"), {
          $selected: false
        });
        this.remove_trash_icon();
      }

      this.tv.$set(this.data, 'selected', null);
      if (!args.length) return;
      this.tv.$set(this.data, 'selected', args[2]);
      this.merge("".concat(args[2], ".settings"), {
        $selected: true
      });
      this.add_trash_icon();
    }
  }, {
    key: "add_trash_icon",
    value: function add_trash_icon() {
      var type = 'System:Remove';

      if (this.data.tools.find(function (x) {
        return x.type === type;
      })) {
        return;
      }

      this.data.tools.push({
        type: type,
        icon: icons_namespaceObject["trash.png"]
      });
    }
  }, {
    key: "remove_trash_icon",
    value: function remove_trash_icon() {
      // TODO: Does not call Toolbar render (distr version)
      var type = 'System:Remove';
      utils.overwrite(this.data.tools, this.data.tools.filter(function (x) {
        return x.type !== type;
      }));
    } // Set overlay data from the web-worker

  }, {
    key: "on_overlay_data",
    value: function on_overlay_data(data) {
      var _this4 = this;

      this.get('.').forEach(function (x) {
        if (x.settings.$synth) _this4.del("".concat(x.id));
      });

      var _iterator6 = dc_events_createForOfIteratorHelper(data),
          _step6;

      try {
        for (_iterator6.s(); !(_step6 = _iterator6.n()).done;) {
          var ov = _step6.value;
          var obj = this.get_one("".concat(ov.id));

          if (obj) {
            this.tv.$set(obj, 'loading', false);
            if (!ov.data) continue;
            obj.data = ov.data;
          }

          if (!ov.new_ovs) continue;

          for (var id in ov.new_ovs.onchart) {
            if (!this.get_one("onchart.".concat(id))) {
              this.add('onchart', ov.new_ovs.onchart[id]);
            }
          }

          for (var id in ov.new_ovs.offchart) {
            if (!this.get_one("offchart.".concat(id))) {
              this.add('offchart', ov.new_ovs.offchart[id]);
            }
          }
        }
      } catch (err) {
        _iterator6.e(err);
      } finally {
        _iterator6.f();
      }
    } // Push overlay updates from the web-worker

  }, {
    key: "on_overlay_update",
    value: function on_overlay_update(data) {
      var _iterator7 = dc_events_createForOfIteratorHelper(data),
          _step7;

      try {
        for (_iterator7.s(); !(_step7 = _iterator7.n()).done;) {
          var ov = _step7.value;
          if (!ov.data) continue;
          var obj = this.get_one("".concat(ov.id));

          if (obj) {
            this.fast_merge(obj.data, ov.data, false);
          }
        }
      } catch (err) {
        _iterator7.e(err);
      } finally {
        _iterator7.f();
      }
    } // Clean-up unfinished business (tools)

  }, {
    key: "before_destroy",
    value: function before_destroy() {
      var f = function f(x) {
        return !x.settings.$state || x.settings.$state === 'finished';
      };

      this.data.onchart = this.data.onchart.filter(f);
      this.data.offchart = this.data.offchart.filter(f);
      this.drawing_mode_off();
      this.on_scroll_lock(false);
      this.object_selected([]);
      this.ww.destroy();
    } // Get overlay by grid-layer id

  }, {
    key: "get_overlay",
    value: function get_overlay(obj) {
      var id = obj.id || "g".concat(obj.grid_id, "_").concat(obj.layer_id);
      var dcid = obj.uuid || this.gldc[id];
      return this.get_one("".concat(dcid));
    }
  }]);

  return DCEvents;
}();


;// CONCATENATED MODULE: ./src/helpers/dc_core.js









function dc_core_createForOfIteratorHelper(o, allowArrayLike) { var it; if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (it = dc_core_unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = o[Symbol.iterator](); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it["return"] != null) it["return"](); } finally { if (didErr) throw err; } } }; }

function dc_core_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return dc_core_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return dc_core_arrayLikeToArray(o, minLen); }

function dc_core_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function dc_core_createSuper(Derived) { var hasNativeReflectConstruct = dc_core_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function dc_core_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

// DataCube "private" methods




var DCCore = /*#__PURE__*/function (_DCEvents) {
  _inherits(DCCore, _DCEvents);

  var _super = dc_core_createSuper(DCCore);

  function DCCore() {
    classCallCheck_classCallCheck(this, DCCore);

    return _super.apply(this, arguments);
  }

  createClass_createClass(DCCore, [{
    key: "init_tvjs",
    value: // Set TV instance (once). Called by TradingVue itself
    function init_tvjs($root) {
      var _this = this;

      if (!this.tv) {
        this.tv = $root;
        this.init_data();
        this.update_ids(); // Listen to all setting changes
        // TODO: works only with merge()

        this.tv.$watch(function () {
          return _this.get_by_query('.settings');
        }, function (n, p) {
          return _this.on_settings(n, p);
        }); // Listen to all indices changes

        this.tv.$watch(function () {
          return _this.get('.').map(function (x) {
            return x.settings.$uuid;
          });
        }, function (n, p) {
          return _this.on_ids_changed(n, p);
        }); // Watch for all 'datasets' changes

        this.tv.$watch(function () {
          return _this.get('datasets');
        }, Dataset.watcher.bind(this));
      }
    } // Init Data Structure v1.1

  }, {
    key: "init_data",
    value: function init_data($root) {
      if (!('chart' in this.data)) {
        this.tv.$set(this.data, 'chart', {
          type: 'Candles',
          data: this.data.ohlcv || []
        });
      }

      if (!('onchart' in this.data)) {
        this.tv.$set(this.data, 'onchart', []);
      }

      if (!('offchart' in this.data)) {
        this.tv.$set(this.data, 'offchart', []);
      }

      if (!this.data.chart.settings) {
        this.tv.$set(this.data.chart, 'settings', {});
      } // Remove ohlcv cuz we have Data v1.1^


      delete this.data.ohlcv;

      if (!('datasets' in this.data)) {
        this.tv.$set(this.data, 'datasets', []);
      } // Init dataset proxies


      var _iterator = dc_core_createForOfIteratorHelper(this.data.datasets),
          _step;

      try {
        for (_iterator.s(); !(_step = _iterator.n()).done;) {
          var ds = _step.value;
          if (!this.dss) this.dss = {};
          this.dss[ds.id] = new Dataset(this, ds);
        }
      } catch (err) {
        _iterator.e(err);
      } finally {
        _iterator.f();
      }
    } // Range change callback (called by TradingVue)
    // TODO: improve (reliablity + chunk with limited size)

  }, {
    key: "range_changed",
    value: function () {
      var _range_changed = _asyncToGenerator( /*#__PURE__*/regenerator_default().mark(function _callee(range, tf, check) {
        var _this2 = this;

        var first, prom;
        return regenerator_default().wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                if (check === void 0) {
                  check = false;
                }

                if (this.loader) {
                  _context.next = 3;
                  break;
                }

                return _context.abrupt("return");

              case 3:
                if (this.loading) {
                  _context.next = 19;
                  break;
                }

                first = this.data.chart.data[0][0];

                if (!(range[0] < first)) {
                  _context.next = 19;
                  break;
                }

                this.loading = true;
                _context.next = 9;
                return utils.pause(250);

              case 9:
                // Load bigger chunks
                range = range.slice(); // copy

                range[0] = Math.floor(range[0]);
                range[1] = Math.floor(first);
                prom = this.loader(range, tf, function (d) {
                  // Callback way
                  _this2.chunk_loaded(d);
                });

                if (!(prom && prom.then)) {
                  _context.next = 19;
                  break;
                }

                _context.t0 = this;
                _context.next = 17;
                return prom;

              case 17:
                _context.t1 = _context.sent;

                _context.t0.chunk_loaded.call(_context.t0, _context.t1);

              case 19:
                if (!check) this.last_chunk = [range, tf];

              case 20:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, this);
      }));

      function range_changed(_x, _x2, _x3) {
        return _range_changed.apply(this, arguments);
      }

      return range_changed;
    }() // A new chunk of data is loaded
    // TODO: bulletproof fetch

  }, {
    key: "chunk_loaded",
    value: function chunk_loaded(data) {
      // Updates only candlestick data, or
      if (Array.isArray(data)) {
        this.merge('chart.data', data);
      } else {
        // Bunch of overlays, including chart.data
        for (var k in data) {
          this.merge(k, data[k]);
        }
      }

      this.loading = false;

      if (this.last_chunk) {
        this.range_changed.apply(this, _toConsumableArray(this.last_chunk).concat([true]));
        this.last_chunk = null;
      }
    } // Update ids for all overlays

  }, {
    key: "update_ids",
    value: function update_ids() {
      this.data.chart.id = "chart.".concat(this.data.chart.type);
      var count = {}; // grid_id,layer_id => DC id mapping

      this.gldc = {}, this.dcgl = {};

      var _iterator2 = dc_core_createForOfIteratorHelper(this.data.onchart),
          _step2;

      try {
        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
          var ov = _step2.value;

          if (count[ov.type] === undefined) {
            count[ov.type] = 0;
          }

          var i = count[ov.type]++;
          ov.id = "onchart.".concat(ov.type).concat(i);
          if (!ov.name) ov.name = ov.type + " ".concat(i);
          if (!ov.settings) this.tv.$set(ov, 'settings', {}); // grid_id,layer_id => DC id mapping

          this.gldc["g0_".concat(ov.type, "_").concat(i)] = ov.id;
          this.dcgl[ov.id] = "g0_".concat(ov.type, "_").concat(i);
        }
      } catch (err) {
        _iterator2.e(err);
      } finally {
        _iterator2.f();
      }

      count = {};
      var grids = [{}];
      var gid = 0;

      var _iterator3 = dc_core_createForOfIteratorHelper(this.data.offchart),
          _step3;

      try {
        for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {
          var ov = _step3.value;

          if (count[ov.type] === undefined) {
            count[ov.type] = 0;
          }

          var _i = count[ov.type]++;

          ov.id = "offchart.".concat(ov.type).concat(_i);
          if (!ov.name) ov.name = ov.type + " ".concat(_i);
          if (!ov.settings) this.tv.$set(ov, 'settings', {}); // grid_id,layer_id => DC id mapping

          gid++;
          var rgid = (ov.grid || {}).id || gid; // real grid_id
          // When we merge grid, skip ++

          if ((ov.grid || {}).id) gid--;
          if (!grids[rgid]) grids[rgid] = {};

          if (grids[rgid][ov.type] === undefined) {
            grids[rgid][ov.type] = 0;
          }

          var ri = grids[rgid][ov.type]++;
          this.gldc["g".concat(rgid, "_").concat(ov.type, "_").concat(ri)] = ov.id;
          this.dcgl[ov.id] = "g".concat(rgid, "_").concat(ov.type, "_").concat(ri);
        }
      } catch (err) {
        _iterator3.e(err);
      } finally {
        _iterator3.f();
      }
    } // TODO: chart refine (from the exchange chart)

  }, {
    key: "update_candle",
    value: function update_candle(data) {
      var ohlcv = this.data.chart.data;
      var last = ohlcv[ohlcv.length - 1];
      var candle = data['candle'];
      var tf = this.tv.$refs.chart.interval_ms;
      var t_next = last[0] + tf;
      var now = data.t || utils.now();
      var t = now >= t_next ? now - now % tf : last[0]; // Update the entire candle

      if (candle.length >= 6) {
        t = candle[0];
      } else {
        candle = [t].concat(_toConsumableArray(candle));
      }

      this.agg.push('ohlcv', candle);
      this.update_overlays(data, t, tf);
      return t >= t_next;
    }
  }, {
    key: "update_tick",
    value: function update_tick(data) {
      var ohlcv = this.data.chart.data;
      var last = ohlcv[ohlcv.length - 1];
      var tick = data['price'];
      var volume = data['volume'] || 0;
      var tf = this.tv.$refs.chart.interval_ms;

      if (!tf) {
        return console.warn('Define the main timeframe');
      }

      var now = data.t || utils.now();
      if (!last) last = [now - now % tf];
      var t_next = last[0] + tf;
      var t = now >= t_next ? now - now % tf : last[0];

      if ((t >= t_next || !ohlcv.length) && tick !== undefined) {
        // And new zero-height candle
        var nc = [t, tick, tick, tick, tick, volume];
        this.agg.push('ohlcv', nc, tf);
        ohlcv.push(nc);
        this.scroll_to(t);
      } else if (tick !== undefined) {
        // Update an existing one
        // TODO: make a separate class Sampler
        last[2] = Math.max(tick, last[2]);
        last[3] = Math.min(tick, last[3]);
        last[4] = tick;
        last[5] += volume;
        this.agg.push('ohlcv', last, tf);
      }

      this.update_overlays(data, t, tf);
      return t >= t_next;
    } // Updates all overlays with given values.

  }, {
    key: "update_overlays",
    value: function update_overlays(data, t, tf) {
      for (var k in data) {
        if (k === 'price' || k === 'volume' || k === 'candle' || k === 't') {
          continue;
        }

        if (k.includes('datasets.')) {
          this.agg.push(k, data[k], tf);
          continue;
        }

        if (!Array.isArray(data[k])) {
          var val = [data[k]];
        } else {
          val = data[k];
        }

        if (!k.includes('.data')) k += '.data';
        this.agg.push(k, [t].concat(_toConsumableArray(val)), tf);
      }
    } // Returns array of objects matching query.
    // Object contains { parent, index, value }
    // TODO: query caching

  }, {
    key: "get_by_query",
    value: function get_by_query(query, chuck) {
      var tuple = query.split('.');

      switch (tuple[0]) {
        case 'chart':
          var result = this.chart_as_piv(tuple);
          break;

        case 'onchart':
        case 'offchart':
          result = this.query_search(query, tuple);
          break;

        case 'datasets':
          result = this.query_search(query, tuple);

          var _iterator4 = dc_core_createForOfIteratorHelper(result),
              _step4;

          try {
            for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {
              var r = _step4.value;

              if (r.i === 'data') {
                r.v = this.dss[r.p.id].data();
              }
            }
          } catch (err) {
            _iterator4.e(err);
          } finally {
            _iterator4.f();
          }

          break;

        default:
          /* Should get('.') return also the chart? */

          /*let ch = this.chart_as_query([
              'chart',
              tuple[1]
          ])*/
          var on = this.query_search(query, ['onchart', tuple[0], tuple[1]]);
          var off = this.query_search(query, ['offchart', tuple[0], tuple[1]]);
          result = [].concat(_toConsumableArray(on), _toConsumableArray(off));
          break;
      }

      return result.filter(function (x) {
        return !(x.v || {}).locked || chuck;
      });
    }
  }, {
    key: "chart_as_piv",
    value: function chart_as_piv(tuple) {
      var field = tuple[1];
      if (field) return [{
        p: this.data.chart,
        i: field,
        v: this.data.chart[field]
      }];else return [{
        p: this.data,
        i: 'chart',
        v: this.data.chart
      }];
    }
  }, {
    key: "query_search",
    value: function query_search(query, tuple) {
      var _this3 = this;

      var side = tuple[0];
      var path = tuple[1] || '';
      var field = tuple[2];
      var arr = this.data[side].filter(function (x) {
        return x.id === query || x.id && x.id.includes(path) || x.name === query || x.name && x.name.includes(path) || query.includes((x.settings || {}).$uuid);
      });

      if (field) {
        return arr.map(function (x) {
          return {
            p: x,
            i: field,
            v: x[field]
          };
        });
      }

      return arr.map(function (x, i) {
        return {
          p: _this3.data[side],
          i: _this3.data[side].indexOf(x),
          v: x
        };
      });
    }
  }, {
    key: "merge_objects",
    value: function merge_objects(obj, data, new_obj) {
      if (new_obj === void 0) {
        new_obj = {};
      }

      // The only way to get Vue to update all stuff
      // reactively is to create a brand new object.
      // TODO: Is there a simpler approach?
      Object.assign(new_obj, obj.v);
      Object.assign(new_obj, data);
      this.tv.$set(obj.p, obj.i, new_obj);
    } // Merge overlapping time series

  }, {
    key: "merge_ts",
    value: function merge_ts(obj, data) {
      // Assume that both arrays are pre-sorted
      if (!data.length) return obj.v;
      var r1 = [obj.v[0][0], obj.v[obj.v.length - 1][0]];
      var r2 = [data[0][0], data[data.length - 1][0]]; // Overlap

      var o = [Math.max(r1[0], r2[0]), Math.min(r1[1], r2[1])];

      if (o[1] >= o[0]) {
        var _obj$v, _data;

        var _this$ts_overlap = this.ts_overlap(obj.v, data, o),
            od = _this$ts_overlap.od,
            d1 = _this$ts_overlap.d1,
            d2 = _this$ts_overlap.d2;

        (_obj$v = obj.v).splice.apply(_obj$v, _toConsumableArray(d1));

        (_data = data).splice.apply(_data, _toConsumableArray(d2)); // Dst === Overlap === Src


        if (!obj.v.length && !data.length) {
          this.tv.$set(obj.p, obj.i, od);
          return obj.v;
        } // If src is totally contained in dst


        if (!data.length) {
          data = obj.v.splice(d1[0]);
        } // If dst is totally contained in src


        if (!obj.v.length) {
          obj.v = data.splice(d2[0]);
        }

        this.tv.$set(obj.p, obj.i, this.combine(obj.v, od, data));
      } else {
        this.tv.$set(obj.p, obj.i, this.combine(obj.v, [], data));
      }

      return obj.v;
    } // TODO: review performance, move to worker

  }, {
    key: "ts_overlap",
    value: function ts_overlap(arr1, arr2, range) {
      var t1 = range[0];
      var t2 = range[1];
      var ts = {}; // timestamp map

      var a1 = arr1.filter(function (x) {
        return x[0] >= t1 && x[0] <= t2;
      });
      var a2 = arr2.filter(function (x) {
        return x[0] >= t1 && x[0] <= t2;
      }); // Indices of segments

      var id11 = arr1.indexOf(a1[0]);
      var id12 = arr1.indexOf(a1[a1.length - 1]);
      var id21 = arr2.indexOf(a2[0]);
      var id22 = arr2.indexOf(a2[a2.length - 1]);

      for (var i = 0; i < a1.length; i++) {
        ts[a1[i][0]] = a1[i];
      }

      for (var i = 0; i < a2.length; i++) {
        ts[a2[i][0]] = a2[i];
      }

      var ts_sorted = Object.keys(ts).sort();
      return {
        od: ts_sorted.map(function (x) {
          return ts[x];
        }),
        d1: [id11, id12 - id11 + 1],
        d2: [id21, id22 - id21 + 1]
      };
    } // Combine parts together:
    // (destination, overlap, source)

  }, {
    key: "combine",
    value: function combine(dst, o, src) {
      function last(arr) {
        return arr[arr.length - 1][0];
      }

      if (!dst.length) {
        dst = o;
        o = [];
      }

      if (!src.length) {
        src = o;
        o = [];
      } // The overlap right in the middle


      if (src[0][0] >= dst[0][0] && last(src) <= last(dst)) {
        return Object.assign(dst, o); // The overlap is on the right
      } else if (last(src) > last(dst)) {
        // Psh(...) is faster but can overflow the stack
        if (o.length < 100000 && src.length < 100000) {
          var _dst;

          (_dst = dst).push.apply(_dst, _toConsumableArray(o).concat(_toConsumableArray(src)));

          return dst;
        } else {
          return dst.concat(o, src);
        } // The overlap is on the left

      } else if (src[0][0] < dst[0][0]) {
        // Push(...) is faster but can overflow the stack
        if (o.length < 100000 && src.length < 100000) {
          var _src;

          (_src = src).push.apply(_src, _toConsumableArray(o).concat(_toConsumableArray(dst)));

          return src;
        } else {
          return src.concat(o, dst);
        }
      } else {
        return [];
      }
    } // Simple data-point merge (faster)

  }, {
    key: "fast_merge",
    value: function fast_merge(data, point, main) {
      if (main === void 0) {
        main = true;
      }

      if (!data) return;
      var last_t = (data[data.length - 1] || [])[0];
      var upd_t = point[0];

      if (!data.length || upd_t > last_t) {
        data.push(point);

        if (main && this.sett.auto_scroll) {
          this.scroll_to(upd_t);
        }
      } else if (upd_t === last_t) {
        if (main) {
          this.tv.$set(data, data.length - 1, point);
        } else {
          data[data.length - 1] = point;
        }
      }
    }
  }, {
    key: "scroll_to",
    value: function scroll_to(t) {
      if (this.tv.$refs.chart.cursor.locked) return;
      var last = this.tv.$refs.chart.last_candle;
      if (!last) return;
      var tl = last[0];
      var d = this.tv.getRange()[1] - tl;
      if (d > 0) this.tv["goto"](t + d);
    }
  }]);

  return DCCore;
}(DCEvents);


;// CONCATENATED MODULE: ./src/helpers/sett_proxy.js
// Sends all dc.sett changes to the web-worker
/* harmony default export */ function sett_proxy(sett, ww) {
  var h = {
    get: function get(sett, k) {
      return sett[k];
    },
    set: function set(sett, k, v) {
      sett[k] = v;
      ww.just('update-dc-settings', sett);
      return true;
    }
  };
  ww.just('update-dc-settings', sett);
  return new Proxy(sett, h);
}
;// CONCATENATED MODULE: ./src/helpers/agg_tool.js


// Tick aggregation


var AggTool = /*#__PURE__*/function () {
  function AggTool(dc, _int) {
    if (_int === void 0) {
      _int = 100;
    }

    classCallCheck_classCallCheck(this, AggTool);

    this.symbols = {};
    this["int"] = _int; // Itarval in ms

    this.dc = dc;
    this.st_id = null;
    this.data_changed = false;
  }

  createClass_createClass(AggTool, [{
    key: "push",
    value: function push(sym, upd, tf) {
      var _this = this;

      // Start auto updates
      if (!this.st_id) {
        this.st_id = setTimeout(function () {
          return _this.update();
        });
      }

      tf = parseInt(tf);
      var old = this.symbols[sym];
      var t = utils.now();
      var isds = sym.includes('datasets.');
      this.data_changed = true;

      if (!old) {
        this.symbols[sym] = {
          upd: upd,
          t: t,
          data: []
        };
      } else if (upd[0] >= old.upd[0] + tf && !isds) {
        // Refine the previous data point
        this.refine(sym, old.upd.slice());
        this.symbols[sym] = {
          upd: upd,
          t: t,
          data: []
        };
      } else {
        // Tick updates the current
        this.symbols[sym].upd = upd;
        this.symbols[sym].t = t;
      }

      if (isds) {
        this.symbols[sym].data.push(upd);
      }
    }
  }, {
    key: "update",
    value: function update() {
      var _this2 = this;

      var out = {};

      for (var sym in this.symbols) {
        var upd = this.symbols[sym].upd;

        switch (sym) {
          case 'ohlcv':
            var data = this.dc.data.chart.data;
            this.dc.fast_merge(data, upd);
            out.ohlcv = data.slice(-2);
            break;

          default:
            if (sym.includes('datasets.')) {
              this.update_ds(sym, out);
              continue;
            }

            var data = this.dc.get_one("".concat(sym));
            if (!data) continue;
            this.dc.fast_merge(data, upd, false);
            break;
        }
      } // TODO: fill gaps


      if (this.data_changed) {
        this.dc.ww.just('update-data', out);
        this.data_changed = false;
      }

      setTimeout(function () {
        return _this2.update();
      }, this["int"]);
    }
  }, {
    key: "refine",
    value: function refine(sym, upd) {
      if (sym === 'ohlcv') {
        var data = this.dc.data.chart.data;
        this.dc.fast_merge(data, upd);
      } else {
        var data = this.dc.get_one("".concat(sym));
        if (!data) return;
        this.dc.fast_merge(data, upd, false);
      }
    }
  }, {
    key: "update_ds",
    value: function update_ds(sym, out) {
      var data = this.symbols[sym].data;

      if (data.length) {
        out[sym] = data;
        this.symbols[sym].data = [];
      }
    }
  }, {
    key: "clear",
    value: function clear() {
      this.symbols = {};
    }
  }]);

  return AggTool;
}();


;// CONCATENATED MODULE: ./src/helpers/datacube.js








function datacube_createForOfIteratorHelper(o, allowArrayLike) { var it; if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (it = datacube_unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = o[Symbol.iterator](); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it["return"] != null) it["return"](); } finally { if (didErr) throw err; } } }; }

function datacube_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return datacube_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return datacube_arrayLikeToArray(o, minLen); }

function datacube_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function datacube_createSuper(Derived) { var hasNativeReflectConstruct = datacube_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function datacube_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

// Main DataHelper class. A container for data,
// which works as a proxy and CRUD interface



 // Interface methods. Private methods in dc_core.js

var DataCube = /*#__PURE__*/function (_DCCore) {
  _inherits(DataCube, _DCCore);

  var _super = datacube_createSuper(DataCube);

  function DataCube(data, sett) {
    var _this;

    if (data === void 0) {
      data = {};
    }

    if (sett === void 0) {
      sett = {};
    }

    classCallCheck_classCallCheck(this, DataCube);

    var def_sett = {
      aggregation: 100,
      // Update aggregation interval
      script_depth: 0,
      // 0 === Exec on all data
      auto_scroll: true,
      // Auto scroll to a new candle
      scripts: true,
      // Enable overlays scripts,
      ww_ram_limit: 0,
      // WebWorker RAM limit (MB)
      node_url: null,
      // Use node.js instead of WW
      shift_measure: true // Draw measurment shift+click

    };
    sett = Object.assign(def_sett, sett);
    _this = _super.call(this);
    _this.sett = sett;
    _this.data = data;
    _this.sett = sett_proxy(sett, _this.ww);
    _this.agg = new AggTool(_assertThisInitialized(_this), sett.aggregation);
    _this.se_state = {}; //this.agg.update = this.agg_update.bind(this)

    return _this;
  } // Add new overlay


  createClass_createClass(DataCube, [{
    key: "add",
    value: function add(side, overlay) {
      if (side !== 'onchart' && side !== 'offchart' && side !== 'datasets') {
        return;
      }

      this.data[side].push(overlay);
      this.update_ids();
      return overlay.id;
    } // Get all objects matching the query

  }, {
    key: "get",
    value: function get(query) {
      return this.get_by_query(query).map(function (x) {
        return x.v;
      });
    } // Get first object matching the query

  }, {
    key: "get_one",
    value: function get_one(query) {
      return this.get_by_query(query).map(function (x) {
        return x.v;
      })[0];
    } // Set data (reactively)

  }, {
    key: "set",
    value: function set(query, data) {
      var objects = this.get_by_query(query);

      var _iterator = datacube_createForOfIteratorHelper(objects),
          _step;

      try {
        for (_iterator.s(); !(_step = _iterator.n()).done;) {
          var obj = _step.value;
          var i = obj.i !== undefined ? obj.i : obj.p.indexOf(obj.v);

          if (i !== -1) {
            this.tv.$set(obj.p, i, data);
          }
        }
      } catch (err) {
        _iterator.e(err);
      } finally {
        _iterator.f();
      }

      this.update_ids();
    } // Merge object or array (reactively)

  }, {
    key: "merge",
    value: function merge(query, data) {
      var objects = this.get_by_query(query);

      var _iterator2 = datacube_createForOfIteratorHelper(objects),
          _step2;

      try {
        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
          var obj = _step2.value;

          if (Array.isArray(obj.v)) {
            if (!Array.isArray(data)) continue; // If array is a timeseries, merge it by timestamp
            // else merge by item index

            if (obj.v[0] && obj.v[0].length >= 2) {
              this.merge_ts(obj, data);
            } else {
              this.merge_objects(obj, data, []);
            }
          } else if (typeof_typeof(obj.v) === 'object') {
            this.merge_objects(obj, data);
          }
        }
      } catch (err) {
        _iterator2.e(err);
      } finally {
        _iterator2.f();
      }

      this.update_ids();
    } // Remove an overlay by query (id/type/name/...)

  }, {
    key: "del",
    value: function del(query) {
      var objects = this.get_by_query(query);

      var _iterator3 = datacube_createForOfIteratorHelper(objects),
          _step3;

      try {
        for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {
          var obj = _step3.value;
          // Find current index of the field (if not defined)
          var i = typeof obj.i !== 'number' ? obj.i : obj.p.indexOf(obj.v);

          if (i !== -1) {
            this.tv.$delete(obj.p, i);
          }
        }
      } catch (err) {
        _iterator3.e(err);
      } finally {
        _iterator3.f();
      }

      this.update_ids();
    } // Update/append data point, depending on timestamp

  }, {
    key: "update",
    value: function update(data) {
      if (data['candle']) {
        return this.update_candle(data);
      } else {
        return this.update_tick(data);
      }
    } // Lock overlays from being pulled by query_search
    // TODO: subject to review

  }, {
    key: "lock",
    value: function lock(query) {
      var objects = this.get_by_query(query);
      objects.forEach(function (x) {
        if (x.v && x.v.id && x.v.type) {
          x.v.locked = true;
        }
      });
    } // Unlock overlays from being pulled by query_search
    //

  }, {
    key: "unlock",
    value: function unlock(query) {
      var objects = this.get_by_query(query, true);
      objects.forEach(function (x) {
        if (x.v && x.v.id && x.v.type) {
          x.v.locked = false;
        }
      });
    } // Show indicator

  }, {
    key: "show",
    value: function show(query) {
      if (query === 'offchart' || query === 'onchart') {
        query += '.';
      } else if (query === '.') {
        query = '';
      }

      this.merge(query + '.settings', {
        display: true
      });
    } // Hide indicator

  }, {
    key: "hide",
    value: function hide(query) {
      if (query === 'offchart' || query === 'onchart') {
        query += '.';
      } else if (query === '.') {
        query = '';
      }

      this.merge(query + '.settings', {
        display: false
      });
    } // Set data loader callback

  }, {
    key: "onrange",
    value: function onrange(callback) {
      var _this2 = this;

      this.loader = callback;
      setTimeout(function () {
        return _this2.tv.set_loader(callback ? _this2 : null);
      }, 0);
    }
  }]);

  return DataCube;
}(DCCore);


;// CONCATENATED MODULE: ./src/mixins/interface.js
// Html interface, shown on top of the grid.
// Can be static (a tooltip) or interactive,
// e.g. a control panel.
/* harmony default export */ const mixins_interface = ({
  props: ['ux', 'updater', 'colors', 'wrapper'],
  mounted: function mounted() {
    this._$emit = this.$emit;
    this.$emit = this.custom_event;
    if (this.init) this.init();
  },
  methods: {
    close: function close() {
      this.$emit('custom-event', {
        event: 'close-interface',
        args: [this.$props.ux.uuid]
      });
    },
    // TODO: emit all the way to the uxlist
    // add apply the changes there
    modify: function modify(obj) {
      this.$emit('custom-event', {
        event: 'modify-interface',
        args: [this.$props.ux.uuid, obj]
      });
    },
    custom_event: function custom_event(event) {
      if (event.split(':')[0] === 'hook') return;

      for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
        args[_key - 1] = arguments[_key];
      }

      this._$emit('custom-event', {
        event: event,
        args: args
      });
    }
  },
  computed: {
    overlay: function overlay() {
      return this.$props.ux.overlay;
    },
    layout: function layout() {
      return this.overlay.layout;
    },
    uxr: function uxr() {
      return this.$props.ux;
    }
  },
  data: function data() {
    return {};
  }
});
;// CONCATENATED MODULE: ./src/index.js















var primitives = {
  Candle: CandleExt,
  Volbar: VolbarExt,
  Line: Line,
  Pin: Pin,
  Price: Price,
  Ray: Ray,
  Seg: Seg
};

TradingVue.install = function (Vue) {
  Vue.component(TradingVue.name, TradingVue);
};

if (typeof window !== 'undefined' && window.Vue) {
  window.Vue.use(TradingVue);
  window.TradingVueLib = {
    TradingVue: TradingVue,
    Overlay: overlay,
    Utils: utils,
    Constants: constants,
    Candle: CandleExt,
    Volbar: VolbarExt,
    layout_cnv: layout_cnv,
    layout_vol: layout_vol,
    DataCube: DataCube,
    Tool: tool,
    Interface: mixins_interface,
    primitives: primitives
  };
}

/* harmony default export */ const src = (TradingVue);


/***/ }),

/***/ 418:
/***/ ((module, exports, __nested_webpack_require_449538__) => {

// Imports
var ___CSS_LOADER_API_IMPORT___ = __nested_webpack_require_449538__(645);
exports = ___CSS_LOADER_API_IMPORT___(false);
// Module
exports.push([module.id, "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n/* Anit-boostrap tactix */\n.trading-vue *, ::after, ::before {\n    box-sizing: content-box;\n}\n.trading-vue img {\n    vertical-align: initial;\n}\n", ""]);
// Exports
module.exports = exports;


/***/ }),

/***/ 976:
/***/ ((module, exports, __nested_webpack_require_450696__) => {

// Imports
var ___CSS_LOADER_API_IMPORT___ = __nested_webpack_require_450696__(645);
exports = ___CSS_LOADER_API_IMPORT___(false);
// Module
exports.push([module.id, "\n.trading-vue-botbar {\n    position: relative !important;\n}\n", ""]);
// Exports
module.exports = exports;


/***/ }),

/***/ 449:
/***/ ((module, exports, __nested_webpack_require_451035__) => {

// Imports
var ___CSS_LOADER_API_IMPORT___ = __nested_webpack_require_451035__(645);
exports = ___CSS_LOADER_API_IMPORT___(false);
// Module
exports.push([module.id, "\n.t-vue-lbtn-grp {\n    margin-left: 0.5em;\n}\n", ""]);
// Exports
module.exports = exports;


/***/ }),

/***/ 108:
/***/ ((module, exports, __nested_webpack_require_451359__) => {

// Imports
var ___CSS_LOADER_API_IMPORT___ = __nested_webpack_require_451359__(645);
exports = ___CSS_LOADER_API_IMPORT___(false);
// Module
exports.push([module.id, "\n.tvjs-item-list {\n    position: absolute;\n    user-select: none;\n    margin-top: -5px;\n}\n.tvjs-item-list-item {\n    display: flex;\n    align-items: center;\n    padding-right: 20px;\n    font-size: 1.15em;\n    letter-spacing: 0.05em;\n}\n.tvjs-item-list-item:hover {\n    background-color: #76878319;\n}\n.tvjs-item-list-item * {\n    position: relative !important;\n}\n", ""]);
// Exports
module.exports = exports;


/***/ }),

/***/ 988:
/***/ ((module, exports, __nested_webpack_require_452014__) => {

// Imports
var ___CSS_LOADER_API_IMPORT___ = __nested_webpack_require_452014__(645);
exports = ___CSS_LOADER_API_IMPORT___(false);
// Module
exports.push([module.id, "\n.trading-vue-legend {\n    position: relative;\n    z-index: 100;\n    font-size: 1.25em;\n    margin-left: 10px;\n    pointer-events: none;\n    text-align: left;\n    user-select: none;\n    font-weight: 300;\n}\n@media (min-resolution: 2x) {\n.trading-vue-legend {\n        font-weight: 400;\n}\n}\n.trading-vue-ohlcv {\n    pointer-events: none;\n    margin-bottom: 0.5em;\n}\n.t-vue-lspan {\n    font-variant-numeric: tabular-nums;\n    font-size: 0.95em;\n    color: #999999; /* TODO: move => params */\n    margin-left: 0.1em;\n    margin-right: 0.2em;\n}\n.t-vue-title {\n    margin-right: 0.25em;\n    font-size: 1.45em;\n}\n.t-vue-ind {\n    margin-left: 0.2em;\n    margin-bottom: 0.5em;\n    font-size: 1.0em;\n    margin-top: 0.3em;\n}\n.t-vue-ivalue {\n    margin-left: 0.5em;\n}\n.t-vue-unknown {\n    color: #999999; /* TODO: move => params */\n}\n.tvjs-appear-enter-active,\n.tvjs-appear-leave-active\n{\n    transition: all .25s ease;\n}\n.tvjs-appear-enter, .tvjs-appear-leave-to\n{\n    opacity: 0;\n}\n", ""]);
// Exports
module.exports = exports;


/***/ }),

/***/ 423:
/***/ ((module, exports, __nested_webpack_require_453314__) => {

// Imports
var ___CSS_LOADER_API_IMPORT___ = __nested_webpack_require_453314__(645);
exports = ___CSS_LOADER_API_IMPORT___(false);
// Module
exports.push([module.id, "\n.t-vue-lbtn {\n    z-index: 100;\n    pointer-events: all;\n    cursor: pointer;\n}\n", ""]);
// Exports
module.exports = exports;


/***/ }),

/***/ 661:
/***/ ((module, exports, __nested_webpack_require_453676__) => {

// Imports
var ___CSS_LOADER_API_IMPORT___ = __nested_webpack_require_453676__(645);
exports = ___CSS_LOADER_API_IMPORT___(false);
// Module
exports.push([module.id, "\n.trading-vue-section {\n    height: 0;\n    position: absolute;\n}\n", ""]);
// Exports
module.exports = exports;


/***/ }),

/***/ 168:
/***/ ((module, exports, __nested_webpack_require_454021__) => {

// Imports
var ___CSS_LOADER_API_IMPORT___ = __nested_webpack_require_454021__(645);
exports = ___CSS_LOADER_API_IMPORT___(false);
// Module
exports.push([module.id, "\n.tvjs-spinner {\n    display: inline-block;\n    position: relative;\n    width: 20px;\n    height: 16px;\n    margin: -4px 0px -1px 0px;\n    opacity: 0.7;\n}\n.tvjs-spinner div {\n    position: absolute;\n    top: 8px;\n    width: 4px;\n    height: 4px;\n    border-radius: 50%;\n    animation-timing-function: cubic-bezier(1, 1, 1, 1);\n}\n.tvjs-spinner div:nth-child(1) {\n    left: 2px;\n    animation: tvjs-spinner1 0.6s infinite;\n    opacity: 0.9;\n}\n.tvjs-spinner div:nth-child(2) {\n    left: 2px;\n    animation: tvjs-spinner2 0.6s infinite;\n}\n.tvjs-spinner div:nth-child(3) {\n    left: 9px;\n    animation: tvjs-spinner2 0.6s infinite;\n}\n.tvjs-spinner div:nth-child(4) {\n    left: 16px;\n    animation: tvjs-spinner3 0.6s infinite;\n    opacity: 0.9;\n}\n@keyframes tvjs-spinner1 {\n0% {\n        transform: scale(0);\n}\n100% {\n        transform: scale(1);\n}\n}\n@keyframes tvjs-spinner3 {\n0% {\n        transform: scale(1);\n}\n100% {\n        transform: scale(0);\n}\n}\n@keyframes tvjs-spinner2 {\n0% {\n        transform: translate(0, 0);\n}\n100% {\n        transform: translate(7px, 0);\n}\n}\n", ""]);
// Exports
module.exports = exports;


/***/ }),

/***/ 29:
/***/ ((module, exports, __nested_webpack_require_455420__) => {

// Imports
var ___CSS_LOADER_API_IMPORT___ = __nested_webpack_require_455420__(645);
exports = ___CSS_LOADER_API_IMPORT___(false);
// Module
exports.push([module.id, "\n.tvjs-drift-enter-active {\n    transition: all .3s ease;\n}\n.tvjs-drift-leave-active {\n    transition: all .8s cubic-bezier(1.0, 0.5, 0.8, 1.0);\n}\n.tvjs-drift-enter, .tvjs-drift-leave-to\n{\n    transform: translateX(10px);\n    opacity: 0;\n}\n.tvjs-the-tip {\n    position: absolute;\n    width: 200px;\n    text-align: center;\n    z-index: 10001;\n    color: #ffffff;\n    font-size: 1.5em;\n    line-height: 1.15em;\n    padding: 10px;\n    border-radius: 3px;\n    right: 70px;\n    top: 10px;\n    text-shadow: 1px 1px black;\n}\n", ""]);
// Exports
module.exports = exports;


/***/ }),

/***/ 935:
/***/ ((module, exports, __nested_webpack_require_456239__) => {

// Imports
var ___CSS_LOADER_API_IMPORT___ = __nested_webpack_require_456239__(645);
exports = ___CSS_LOADER_API_IMPORT___(false);
// Module
exports.push([module.id, "\n.trading-vue-toolbar {\n    position: absolute;\n    border-right: 1px solid black;\n    z-index: 101;\n    padding-top: 3px;\n    user-select: none;\n}\n", ""]);
// Exports
module.exports = exports;


/***/ }),

/***/ 379:
/***/ ((module, exports, __nested_webpack_require_456670__) => {

// Imports
var ___CSS_LOADER_API_IMPORT___ = __nested_webpack_require_456670__(645);
exports = ___CSS_LOADER_API_IMPORT___(false);
// Module
exports.push([module.id, "\n.trading-vue-tbitem {\n}\n.trading-vue-tbitem:hover {\n    background-color: #76878319;\n}\n.trading-vue-tbitem-exp {\n    position: absolute;\n    right: -3px;\n    padding: 18.5px 5px;\n    font-stretch: extra-condensed;\n    transform: scaleX(0.6);\n    font-size: 0.6em;\n    opacity: 0.0;\n    user-select: none;\n    line-height: 0;\n}\n.trading-vue-tbitem:hover\n.trading-vue-tbitem-exp {\n    opacity: 0.5;\n}\n.trading-vue-tbitem-exp:hover {\n    background-color: #76878330;\n    opacity: 0.9 !important;\n}\n.trading-vue-tbicon {\n    position: absolute;\n}\n.trading-vue-tbitem.selected-item > .trading-vue-tbicon,\n.tvjs-item-list-item.selected-item > .trading-vue-tbicon {\n     filter: brightness(1.45) sepia(1) hue-rotate(90deg) saturate(4.5) !important;\n}\n.tvjs-pixelated {\n    -ms-interpolation-mode: nearest-neighbor;\n    image-rendering: -webkit-optimize-contrast;\n    image-rendering: -webkit-crisp-edges;\n    image-rendering: -moz-crisp-edges;\n    image-rendering: -o-crisp-edges;\n    image-rendering: pixelated;\n}\n\n", ""]);
// Exports
module.exports = exports;


/***/ }),

/***/ 72:
/***/ ((module, exports, __nested_webpack_require_457995__) => {

// Imports
var ___CSS_LOADER_API_IMPORT___ = __nested_webpack_require_457995__(645);
exports = ___CSS_LOADER_API_IMPORT___(false);
// Module
exports.push([module.id, "\n.trading-vue-ux-wrapper {\n    position: absolute;\n    display: flex;\n}\n.tvjs-ux-wrapper-pin {\n    position: absolute;\n    width: 9px;\n    height: 9px;\n    z-index: 100;\n    background-color: #23a776;\n    border-radius: 10px;\n    margin-left: -6px;\n    margin-top: -6px;\n    pointer-events: none;\n}\n.tvjs-ux-wrapper-head {\n    position: absolute;\n    height: 23px;\n    width: 100%;\n}\n.tvjs-ux-wrapper-close {\n    position: absolute;\n    width: 11px;\n    height: 11px;\n    font-size: 1.5em;\n    line-height: 0.5em;\n    padding: 1px 1px 1px 1px;\n    border-radius: 10px;\n    right: 5px;\n    top: 5px;\n    user-select: none;\n    text-align: center;\n    z-index: 100;\n}\n.tvjs-ux-wrapper-close-hb {\n}\n.tvjs-ux-wrapper-close:hover {\n    background-color: #FF605C !important;\n    color: #692324 !important;\n}\n.tvjs-ux-wrapper-full {\n}\n", ""]);
// Exports
module.exports = exports;


/***/ }),

/***/ 983:
/***/ ((module, exports, __nested_webpack_require_459141__) => {

// Imports
var ___CSS_LOADER_API_IMPORT___ = __nested_webpack_require_459141__(645);
exports = ___CSS_LOADER_API_IMPORT___(false);
// Module
exports.push([module.id, "\n.tvjs-widgets {\n    position: absolute;\n    z-index: 1000;\n    pointer-events: none;\n}\n", ""]);
// Exports
module.exports = exports;


/***/ }),

/***/ 645:
/***/ ((module) => {

"use strict";


/*
  MIT License http://www.opensource.org/licenses/mit-license.php
  Author Tobias Koppers @sokra
*/
// css base code, injected by the css-loader
// eslint-disable-next-line func-names
module.exports = function (useSourceMap) {
  var list = []; // return the list of modules as css string

  list.toString = function toString() {
    return this.map(function (item) {
      var content = cssWithMappingToString(item, useSourceMap);

      if (item[2]) {
        return "@media ".concat(item[2], " {").concat(content, "}");
      }

      return content;
    }).join('');
  }; // import a list of modules into the list
  // eslint-disable-next-line func-names


  list.i = function (modules, mediaQuery, dedupe) {
    if (typeof modules === 'string') {
      // eslint-disable-next-line no-param-reassign
      modules = [[null, modules, '']];
    }

    var alreadyImportedModules = {};

    if (dedupe) {
      for (var i = 0; i < this.length; i++) {
        // eslint-disable-next-line prefer-destructuring
        var id = this[i][0];

        if (id != null) {
          alreadyImportedModules[id] = true;
        }
      }
    }

    for (var _i = 0; _i < modules.length; _i++) {
      var item = [].concat(modules[_i]);

      if (dedupe && alreadyImportedModules[item[0]]) {
        // eslint-disable-next-line no-continue
        continue;
      }

      if (mediaQuery) {
        if (!item[2]) {
          item[2] = mediaQuery;
        } else {
          item[2] = "".concat(mediaQuery, " and ").concat(item[2]);
        }
      }

      list.push(item);
    }
  };

  return list;
};

function cssWithMappingToString(item, useSourceMap) {
  var content = item[1] || ''; // eslint-disable-next-line prefer-destructuring

  var cssMapping = item[3];

  if (!cssMapping) {
    return content;
  }

  if (useSourceMap && typeof btoa === 'function') {
    var sourceMapping = toComment(cssMapping);
    var sourceURLs = cssMapping.sources.map(function (source) {
      return "/*# sourceURL=".concat(cssMapping.sourceRoot || '').concat(source, " */");
    });
    return [content].concat(sourceURLs).concat([sourceMapping]).join('\n');
  }

  return [content].join('\n');
} // Adapted from convert-source-map (MIT)


function toComment(sourceMap) {
  // eslint-disable-next-line no-undef
  var base64 = btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap))));
  var data = "sourceMappingURL=data:application/json;charset=utf-8;base64,".concat(base64);
  return "/*# ".concat(data, " */");
}

/***/ }),

/***/ 840:
/***/ ((module, exports, __nested_webpack_require_462074__) => {

var __WEBPACK_AMD_DEFINE_RESULT__;/*! Hammer.JS - v2.0.7 - 2016-04-22
 * http://hammerjs.github.io/
 *
 * Copyright (c) 2016 Jorik Tangelder;
 * Licensed under the MIT license */
(function(window, document, exportName, undefined) {
  'use strict';

var VENDOR_PREFIXES = ['', 'webkit', 'Moz', 'MS', 'ms', 'o'];
var TEST_ELEMENT = document.createElement('div');

var TYPE_FUNCTION = 'function';

var round = Math.round;
var abs = Math.abs;
var now = Date.now;

/**
 * set a timeout with a given scope
 * @param {Function} fn
 * @param {Number} timeout
 * @param {Object} context
 * @returns {number}
 */
function setTimeoutContext(fn, timeout, context) {
    return setTimeout(bindFn(fn, context), timeout);
}

/**
 * if the argument is an array, we want to execute the fn on each entry
 * if it aint an array we don't want to do a thing.
 * this is used by all the methods that accept a single and array argument.
 * @param {*|Array} arg
 * @param {String} fn
 * @param {Object} [context]
 * @returns {Boolean}
 */
function invokeArrayArg(arg, fn, context) {
    if (Array.isArray(arg)) {
        each(arg, context[fn], context);
        return true;
    }
    return false;
}

/**
 * walk objects and arrays
 * @param {Object} obj
 * @param {Function} iterator
 * @param {Object} context
 */
function each(obj, iterator, context) {
    var i;

    if (!obj) {
        return;
    }

    if (obj.forEach) {
        obj.forEach(iterator, context);
    } else if (obj.length !== undefined) {
        i = 0;
        while (i < obj.length) {
            iterator.call(context, obj[i], i, obj);
            i++;
        }
    } else {
        for (i in obj) {
            obj.hasOwnProperty(i) && iterator.call(context, obj[i], i, obj);
        }
    }
}

/**
 * wrap a method with a deprecation warning and stack trace
 * @param {Function} method
 * @param {String} name
 * @param {String} message
 * @returns {Function} A new function wrapping the supplied method.
 */
function deprecate(method, name, message) {
    var deprecationMessage = 'DEPRECATED METHOD: ' + name + '\n' + message + ' AT \n';
    return function() {
        var e = new Error('get-stack-trace');
        var stack = e && e.stack ? e.stack.replace(/^[^\(]+?[\n$]/gm, '')
            .replace(/^\s+at\s+/gm, '')
            .replace(/^Object.<anonymous>\s*\(/gm, '{anonymous}()@') : 'Unknown Stack Trace';

        var log = window.console && (window.console.warn || window.console.log);
        if (log) {
            log.call(window.console, deprecationMessage, stack);
        }
        return method.apply(this, arguments);
    };
}

/**
 * extend object.
 * means that properties in dest will be overwritten by the ones in src.
 * @param {Object} target
 * @param {...Object} objects_to_assign
 * @returns {Object} target
 */
var assign;
if (typeof Object.assign !== 'function') {
    assign = function assign(target) {
        if (target === undefined || target === null) {
            throw new TypeError('Cannot convert undefined or null to object');
        }

        var output = Object(target);
        for (var index = 1; index < arguments.length; index++) {
            var source = arguments[index];
            if (source !== undefined && source !== null) {
                for (var nextKey in source) {
                    if (source.hasOwnProperty(nextKey)) {
                        output[nextKey] = source[nextKey];
                    }
                }
            }
        }
        return output;
    };
} else {
    assign = Object.assign;
}

/**
 * extend object.
 * means that properties in dest will be overwritten by the ones in src.
 * @param {Object} dest
 * @param {Object} src
 * @param {Boolean} [merge=false]
 * @returns {Object} dest
 */
var extend = deprecate(function extend(dest, src, merge) {
    var keys = Object.keys(src);
    var i = 0;
    while (i < keys.length) {
        if (!merge || (merge && dest[keys[i]] === undefined)) {
            dest[keys[i]] = src[keys[i]];
        }
        i++;
    }
    return dest;
}, 'extend', 'Use `assign`.');

/**
 * merge the values from src in the dest.
 * means that properties that exist in dest will not be overwritten by src
 * @param {Object} dest
 * @param {Object} src
 * @returns {Object} dest
 */
var merge = deprecate(function merge(dest, src) {
    return extend(dest, src, true);
}, 'merge', 'Use `assign`.');

/**
 * simple class inheritance
 * @param {Function} child
 * @param {Function} base
 * @param {Object} [properties]
 */
function inherit(child, base, properties) {
    var baseP = base.prototype,
        childP;

    childP = child.prototype = Object.create(baseP);
    childP.constructor = child;
    childP._super = baseP;

    if (properties) {
        assign(childP, properties);
    }
}

/**
 * simple function bind
 * @param {Function} fn
 * @param {Object} context
 * @returns {Function}
 */
function bindFn(fn, context) {
    return function boundFn() {
        return fn.apply(context, arguments);
    };
}

/**
 * let a boolean value also be a function that must return a boolean
 * this first item in args will be used as the context
 * @param {Boolean|Function} val
 * @param {Array} [args]
 * @returns {Boolean}
 */
function boolOrFn(val, args) {
    if (typeof val == TYPE_FUNCTION) {
        return val.apply(args ? args[0] || undefined : undefined, args);
    }
    return val;
}

/**
 * use the val2 when val1 is undefined
 * @param {*} val1
 * @param {*} val2
 * @returns {*}
 */
function ifUndefined(val1, val2) {
    return (val1 === undefined) ? val2 : val1;
}

/**
 * addEventListener with multiple events at once
 * @param {EventTarget} target
 * @param {String} types
 * @param {Function} handler
 */
function addEventListeners(target, types, handler) {
    each(splitStr(types), function(type) {
        target.addEventListener(type, handler, false);
    });
}

/**
 * removeEventListener with multiple events at once
 * @param {EventTarget} target
 * @param {String} types
 * @param {Function} handler
 */
function removeEventListeners(target, types, handler) {
    each(splitStr(types), function(type) {
        target.removeEventListener(type, handler, false);
    });
}

/**
 * find if a node is in the given parent
 * @method hasParent
 * @param {HTMLElement} node
 * @param {HTMLElement} parent
 * @return {Boolean} found
 */
function hasParent(node, parent) {
    while (node) {
        if (node == parent) {
            return true;
        }
        node = node.parentNode;
    }
    return false;
}

/**
 * small indexOf wrapper
 * @param {String} str
 * @param {String} find
 * @returns {Boolean} found
 */
function inStr(str, find) {
    return str.indexOf(find) > -1;
}

/**
 * split string on whitespace
 * @param {String} str
 * @returns {Array} words
 */
function splitStr(str) {
    return str.trim().split(/\s+/g);
}

/**
 * find if a array contains the object using indexOf or a simple polyFill
 * @param {Array} src
 * @param {String} find
 * @param {String} [findByKey]
 * @return {Boolean|Number} false when not found, or the index
 */
function inArray(src, find, findByKey) {
    if (src.indexOf && !findByKey) {
        return src.indexOf(find);
    } else {
        var i = 0;
        while (i < src.length) {
            if ((findByKey && src[i][findByKey] == find) || (!findByKey && src[i] === find)) {
                return i;
            }
            i++;
        }
        return -1;
    }
}

/**
 * convert array-like objects to real arrays
 * @param {Object} obj
 * @returns {Array}
 */
function toArray(obj) {
    return Array.prototype.slice.call(obj, 0);
}

/**
 * unique array with objects based on a key (like 'id') or just by the array's value
 * @param {Array} src [{id:1},{id:2},{id:1}]
 * @param {String} [key]
 * @param {Boolean} [sort=False]
 * @returns {Array} [{id:1},{id:2}]
 */
function uniqueArray(src, key, sort) {
    var results = [];
    var values = [];
    var i = 0;

    while (i < src.length) {
        var val = key ? src[i][key] : src[i];
        if (inArray(values, val) < 0) {
            results.push(src[i]);
        }
        values[i] = val;
        i++;
    }

    if (sort) {
        if (!key) {
            results = results.sort();
        } else {
            results = results.sort(function sortUniqueArray(a, b) {
                return a[key] > b[key];
            });
        }
    }

    return results;
}

/**
 * get the prefixed property
 * @param {Object} obj
 * @param {String} property
 * @returns {String|Undefined} prefixed
 */
function prefixed(obj, property) {
    var prefix, prop;
    var camelProp = property[0].toUpperCase() + property.slice(1);

    var i = 0;
    while (i < VENDOR_PREFIXES.length) {
        prefix = VENDOR_PREFIXES[i];
        prop = (prefix) ? prefix + camelProp : property;

        if (prop in obj) {
            return prop;
        }
        i++;
    }
    return undefined;
}

/**
 * get a unique id
 * @returns {number} uniqueId
 */
var _uniqueId = 1;
function uniqueId() {
    return _uniqueId++;
}

/**
 * get the window object of an element
 * @param {HTMLElement} element
 * @returns {DocumentView|Window}
 */
function getWindowForElement(element) {
    var doc = element.ownerDocument || element;
    return (doc.defaultView || doc.parentWindow || window);
}

var MOBILE_REGEX = /mobile|tablet|ip(ad|hone|od)|android/i;

var SUPPORT_TOUCH = ('ontouchstart' in window);
var SUPPORT_POINTER_EVENTS = prefixed(window, 'PointerEvent') !== undefined;
var SUPPORT_ONLY_TOUCH = SUPPORT_TOUCH && MOBILE_REGEX.test(navigator.userAgent);

var INPUT_TYPE_TOUCH = 'touch';
var INPUT_TYPE_PEN = 'pen';
var INPUT_TYPE_MOUSE = 'mouse';
var INPUT_TYPE_KINECT = 'kinect';

var COMPUTE_INTERVAL = 25;

var INPUT_START = 1;
var INPUT_MOVE = 2;
var INPUT_END = 4;
var INPUT_CANCEL = 8;

var DIRECTION_NONE = 1;
var DIRECTION_LEFT = 2;
var DIRECTION_RIGHT = 4;
var DIRECTION_UP = 8;
var DIRECTION_DOWN = 16;

var DIRECTION_HORIZONTAL = DIRECTION_LEFT | DIRECTION_RIGHT;
var DIRECTION_VERTICAL = DIRECTION_UP | DIRECTION_DOWN;
var DIRECTION_ALL = DIRECTION_HORIZONTAL | DIRECTION_VERTICAL;

var PROPS_XY = ['x', 'y'];
var PROPS_CLIENT_XY = ['clientX', 'clientY'];

/**
 * create new input type manager
 * @param {Manager} manager
 * @param {Function} callback
 * @returns {Input}
 * @constructor
 */
function Input(manager, callback) {
    var self = this;
    this.manager = manager;
    this.callback = callback;
    this.element = manager.element;
    this.target = manager.options.inputTarget;

    // smaller wrapper around the handler, for the scope and the enabled state of the manager,
    // so when disabled the input events are completely bypassed.
    this.domHandler = function(ev) {
        if (boolOrFn(manager.options.enable, [manager])) {
            self.handler(ev);
        }
    };

    this.init();

}

Input.prototype = {
    /**
     * should handle the inputEvent data and trigger the callback
     * @virtual
     */
    handler: function() { },

    /**
     * bind the events
     */
    init: function() {
        this.evEl && addEventListeners(this.element, this.evEl, this.domHandler);
        this.evTarget && addEventListeners(this.target, this.evTarget, this.domHandler);
        this.evWin && addEventListeners(getWindowForElement(this.element), this.evWin, this.domHandler);
    },

    /**
     * unbind the events
     */
    destroy: function() {
        this.evEl && removeEventListeners(this.element, this.evEl, this.domHandler);
        this.evTarget && removeEventListeners(this.target, this.evTarget, this.domHandler);
        this.evWin && removeEventListeners(getWindowForElement(this.element), this.evWin, this.domHandler);
    }
};

/**
 * create new input type manager
 * called by the Manager constructor
 * @param {Hammer} manager
 * @returns {Input}
 */
function createInputInstance(manager) {
    var Type;
    var inputClass = manager.options.inputClass;

    if (inputClass) {
        Type = inputClass;
    } else if (SUPPORT_POINTER_EVENTS) {
        Type = PointerEventInput;
    } else if (SUPPORT_ONLY_TOUCH) {
        Type = TouchInput;
    } else if (!SUPPORT_TOUCH) {
        Type = MouseInput;
    } else {
        Type = TouchMouseInput;
    }
    return new (Type)(manager, inputHandler);
}

/**
 * handle input events
 * @param {Manager} manager
 * @param {String} eventType
 * @param {Object} input
 */
function inputHandler(manager, eventType, input) {
    var pointersLen = input.pointers.length;
    var changedPointersLen = input.changedPointers.length;
    var isFirst = (eventType & INPUT_START && (pointersLen - changedPointersLen === 0));
    var isFinal = (eventType & (INPUT_END | INPUT_CANCEL) && (pointersLen - changedPointersLen === 0));

    input.isFirst = !!isFirst;
    input.isFinal = !!isFinal;

    if (isFirst) {
        manager.session = {};
    }

    // source event is the normalized value of the domEvents
    // like 'touchstart, mouseup, pointerdown'
    input.eventType = eventType;

    // compute scale, rotation etc
    computeInputData(manager, input);

    // emit secret event
    manager.emit('hammer.input', input);

    manager.recognize(input);
    manager.session.prevInput = input;
}

/**
 * extend the data with some usable properties like scale, rotate, velocity etc
 * @param {Object} manager
 * @param {Object} input
 */
function computeInputData(manager, input) {
    var session = manager.session;
    var pointers = input.pointers;
    var pointersLength = pointers.length;

    // store the first input to calculate the distance and direction
    if (!session.firstInput) {
        session.firstInput = simpleCloneInputData(input);
    }

    // to compute scale and rotation we need to store the multiple touches
    if (pointersLength > 1 && !session.firstMultiple) {
        session.firstMultiple = simpleCloneInputData(input);
    } else if (pointersLength === 1) {
        session.firstMultiple = false;
    }

    var firstInput = session.firstInput;
    var firstMultiple = session.firstMultiple;
    var offsetCenter = firstMultiple ? firstMultiple.center : firstInput.center;

    var center = input.center = getCenter(pointers);
    input.timeStamp = now();
    input.deltaTime = input.timeStamp - firstInput.timeStamp;

    input.angle = getAngle(offsetCenter, center);
    input.distance = getDistance(offsetCenter, center);

    computeDeltaXY(session, input);
    input.offsetDirection = getDirection(input.deltaX, input.deltaY);

    var overallVelocity = getVelocity(input.deltaTime, input.deltaX, input.deltaY);
    input.overallVelocityX = overallVelocity.x;
    input.overallVelocityY = overallVelocity.y;
    input.overallVelocity = (abs(overallVelocity.x) > abs(overallVelocity.y)) ? overallVelocity.x : overallVelocity.y;

    input.scale = firstMultiple ? getScale(firstMultiple.pointers, pointers) : 1;
    input.rotation = firstMultiple ? getRotation(firstMultiple.pointers, pointers) : 0;

    input.maxPointers = !session.prevInput ? input.pointers.length : ((input.pointers.length >
        session.prevInput.maxPointers) ? input.pointers.length : session.prevInput.maxPointers);

    computeIntervalInputData(session, input);

    // find the correct target
    var target = manager.element;
    if (hasParent(input.srcEvent.target, target)) {
        target = input.srcEvent.target;
    }
    input.target = target;
}

function computeDeltaXY(session, input) {
    var center = input.center;
    var offset = session.offsetDelta || {};
    var prevDelta = session.prevDelta || {};
    var prevInput = session.prevInput || {};

    if (input.eventType === INPUT_START || prevInput.eventType === INPUT_END) {
        prevDelta = session.prevDelta = {
            x: prevInput.deltaX || 0,
            y: prevInput.deltaY || 0
        };

        offset = session.offsetDelta = {
            x: center.x,
            y: center.y
        };
    }

    input.deltaX = prevDelta.x + (center.x - offset.x);
    input.deltaY = prevDelta.y + (center.y - offset.y);
}

/**
 * velocity is calculated every x ms
 * @param {Object} session
 * @param {Object} input
 */
function computeIntervalInputData(session, input) {
    var last = session.lastInterval || input,
        deltaTime = input.timeStamp - last.timeStamp,
        velocity, velocityX, velocityY, direction;

    if (input.eventType != INPUT_CANCEL && (deltaTime > COMPUTE_INTERVAL || last.velocity === undefined)) {
        var deltaX = input.deltaX - last.deltaX;
        var deltaY = input.deltaY - last.deltaY;

        var v = getVelocity(deltaTime, deltaX, deltaY);
        velocityX = v.x;
        velocityY = v.y;
        velocity = (abs(v.x) > abs(v.y)) ? v.x : v.y;
        direction = getDirection(deltaX, deltaY);

        session.lastInterval = input;
    } else {
        // use latest velocity info if it doesn't overtake a minimum period
        velocity = last.velocity;
        velocityX = last.velocityX;
        velocityY = last.velocityY;
        direction = last.direction;
    }

    input.velocity = velocity;
    input.velocityX = velocityX;
    input.velocityY = velocityY;
    input.direction = direction;
}

/**
 * create a simple clone from the input used for storage of firstInput and firstMultiple
 * @param {Object} input
 * @returns {Object} clonedInputData
 */
function simpleCloneInputData(input) {
    // make a simple copy of the pointers because we will get a reference if we don't
    // we only need clientXY for the calculations
    var pointers = [];
    var i = 0;
    while (i < input.pointers.length) {
        pointers[i] = {
            clientX: round(input.pointers[i].clientX),
            clientY: round(input.pointers[i].clientY)
        };
        i++;
    }

    return {
        timeStamp: now(),
        pointers: pointers,
        center: getCenter(pointers),
        deltaX: input.deltaX,
        deltaY: input.deltaY
    };
}

/**
 * get the center of all the pointers
 * @param {Array} pointers
 * @return {Object} center contains `x` and `y` properties
 */
function getCenter(pointers) {
    var pointersLength = pointers.length;

    // no need to loop when only one touch
    if (pointersLength === 1) {
        return {
            x: round(pointers[0].clientX),
            y: round(pointers[0].clientY)
        };
    }

    var x = 0, y = 0, i = 0;
    while (i < pointersLength) {
        x += pointers[i].clientX;
        y += pointers[i].clientY;
        i++;
    }

    return {
        x: round(x / pointersLength),
        y: round(y / pointersLength)
    };
}

/**
 * calculate the velocity between two points. unit is in px per ms.
 * @param {Number} deltaTime
 * @param {Number} x
 * @param {Number} y
 * @return {Object} velocity `x` and `y`
 */
function getVelocity(deltaTime, x, y) {
    return {
        x: x / deltaTime || 0,
        y: y / deltaTime || 0
    };
}

/**
 * get the direction between two points
 * @param {Number} x
 * @param {Number} y
 * @return {Number} direction
 */
function getDirection(x, y) {
    if (x === y) {
        return DIRECTION_NONE;
    }

    if (abs(x) >= abs(y)) {
        return x < 0 ? DIRECTION_LEFT : DIRECTION_RIGHT;
    }
    return y < 0 ? DIRECTION_UP : DIRECTION_DOWN;
}

/**
 * calculate the absolute distance between two points
 * @param {Object} p1 {x, y}
 * @param {Object} p2 {x, y}
 * @param {Array} [props] containing x and y keys
 * @return {Number} distance
 */
function getDistance(p1, p2, props) {
    if (!props) {
        props = PROPS_XY;
    }
    var x = p2[props[0]] - p1[props[0]],
        y = p2[props[1]] - p1[props[1]];

    return Math.sqrt((x * x) + (y * y));
}

/**
 * calculate the angle between two coordinates
 * @param {Object} p1
 * @param {Object} p2
 * @param {Array} [props] containing x and y keys
 * @return {Number} angle
 */
function getAngle(p1, p2, props) {
    if (!props) {
        props = PROPS_XY;
    }
    var x = p2[props[0]] - p1[props[0]],
        y = p2[props[1]] - p1[props[1]];
    return Math.atan2(y, x) * 180 / Math.PI;
}

/**
 * calculate the rotation degrees between two pointersets
 * @param {Array} start array of pointers
 * @param {Array} end array of pointers
 * @return {Number} rotation
 */
function getRotation(start, end) {
    return getAngle(end[1], end[0], PROPS_CLIENT_XY) + getAngle(start[1], start[0], PROPS_CLIENT_XY);
}

/**
 * calculate the scale factor between two pointersets
 * no scale is 1, and goes down to 0 when pinched together, and bigger when pinched out
 * @param {Array} start array of pointers
 * @param {Array} end array of pointers
 * @return {Number} scale
 */
function getScale(start, end) {
    return getDistance(end[0], end[1], PROPS_CLIENT_XY) / getDistance(start[0], start[1], PROPS_CLIENT_XY);
}

var MOUSE_INPUT_MAP = {
    mousedown: INPUT_START,
    mousemove: INPUT_MOVE,
    mouseup: INPUT_END
};

var MOUSE_ELEMENT_EVENTS = 'mousedown';
var MOUSE_WINDOW_EVENTS = 'mousemove mouseup';

/**
 * Mouse events input
 * @constructor
 * @extends Input
 */
function MouseInput() {
    this.evEl = MOUSE_ELEMENT_EVENTS;
    this.evWin = MOUSE_WINDOW_EVENTS;

    this.pressed = false; // mousedown state

    Input.apply(this, arguments);
}

inherit(MouseInput, Input, {
    /**
     * handle mouse events
     * @param {Object} ev
     */
    handler: function MEhandler(ev) {
        var eventType = MOUSE_INPUT_MAP[ev.type];

        // on start we want to have the left mouse button down
        if (eventType & INPUT_START && ev.button === 0) {
            this.pressed = true;
        }

        if (eventType & INPUT_MOVE && ev.which !== 1) {
            eventType = INPUT_END;
        }

        // mouse must be down
        if (!this.pressed) {
            return;
        }

        if (eventType & INPUT_END) {
            this.pressed = false;
        }

        this.callback(this.manager, eventType, {
            pointers: [ev],
            changedPointers: [ev],
            pointerType: INPUT_TYPE_MOUSE,
            srcEvent: ev
        });
    }
});

var POINTER_INPUT_MAP = {
    pointerdown: INPUT_START,
    pointermove: INPUT_MOVE,
    pointerup: INPUT_END,
    pointercancel: INPUT_CANCEL,
    pointerout: INPUT_CANCEL
};

// in IE10 the pointer types is defined as an enum
var IE10_POINTER_TYPE_ENUM = {
    2: INPUT_TYPE_TOUCH,
    3: INPUT_TYPE_PEN,
    4: INPUT_TYPE_MOUSE,
    5: INPUT_TYPE_KINECT // see https://twitter.com/jacobrossi/status/480596438489890816
};

var POINTER_ELEMENT_EVENTS = 'pointerdown';
var POINTER_WINDOW_EVENTS = 'pointermove pointerup pointercancel';

// IE10 has prefixed support, and case-sensitive
if (window.MSPointerEvent && !window.PointerEvent) {
    POINTER_ELEMENT_EVENTS = 'MSPointerDown';
    POINTER_WINDOW_EVENTS = 'MSPointerMove MSPointerUp MSPointerCancel';
}

/**
 * Pointer events input
 * @constructor
 * @extends Input
 */
function PointerEventInput() {
    this.evEl = POINTER_ELEMENT_EVENTS;
    this.evWin = POINTER_WINDOW_EVENTS;

    Input.apply(this, arguments);

    this.store = (this.manager.session.pointerEvents = []);
}

inherit(PointerEventInput, Input, {
    /**
     * handle mouse events
     * @param {Object} ev
     */
    handler: function PEhandler(ev) {
        var store = this.store;
        var removePointer = false;

        var eventTypeNormalized = ev.type.toLowerCase().replace('ms', '');
        var eventType = POINTER_INPUT_MAP[eventTypeNormalized];
        var pointerType = IE10_POINTER_TYPE_ENUM[ev.pointerType] || ev.pointerType;

        var isTouch = (pointerType == INPUT_TYPE_TOUCH);

        // get index of the event in the store
        var storeIndex = inArray(store, ev.pointerId, 'pointerId');

        // start and mouse must be down
        if (eventType & INPUT_START && (ev.button === 0 || isTouch)) {
            if (storeIndex < 0) {
                store.push(ev);
                storeIndex = store.length - 1;
            }
        } else if (eventType & (INPUT_END | INPUT_CANCEL)) {
            removePointer = true;
        }

        // it not found, so the pointer hasn't been down (so it's probably a hover)
        if (storeIndex < 0) {
            return;
        }

        // update the event in the store
        store[storeIndex] = ev;

        this.callback(this.manager, eventType, {
            pointers: store,
            changedPointers: [ev],
            pointerType: pointerType,
            srcEvent: ev
        });

        if (removePointer) {
            // remove from the store
            store.splice(storeIndex, 1);
        }
    }
});

var SINGLE_TOUCH_INPUT_MAP = {
    touchstart: INPUT_START,
    touchmove: INPUT_MOVE,
    touchend: INPUT_END,
    touchcancel: INPUT_CANCEL
};

var SINGLE_TOUCH_TARGET_EVENTS = 'touchstart';
var SINGLE_TOUCH_WINDOW_EVENTS = 'touchstart touchmove touchend touchcancel';

/**
 * Touch events input
 * @constructor
 * @extends Input
 */
function SingleTouchInput() {
    this.evTarget = SINGLE_TOUCH_TARGET_EVENTS;
    this.evWin = SINGLE_TOUCH_WINDOW_EVENTS;
    this.started = false;

    Input.apply(this, arguments);
}

inherit(SingleTouchInput, Input, {
    handler: function TEhandler(ev) {
        var type = SINGLE_TOUCH_INPUT_MAP[ev.type];

        // should we handle the touch events?
        if (type === INPUT_START) {
            this.started = true;
        }

        if (!this.started) {
            return;
        }

        var touches = normalizeSingleTouches.call(this, ev, type);

        // when done, reset the started state
        if (type & (INPUT_END | INPUT_CANCEL) && touches[0].length - touches[1].length === 0) {
            this.started = false;
        }

        this.callback(this.manager, type, {
            pointers: touches[0],
            changedPointers: touches[1],
            pointerType: INPUT_TYPE_TOUCH,
            srcEvent: ev
        });
    }
});

/**
 * @this {TouchInput}
 * @param {Object} ev
 * @param {Number} type flag
 * @returns {undefined|Array} [all, changed]
 */
function normalizeSingleTouches(ev, type) {
    var all = toArray(ev.touches);
    var changed = toArray(ev.changedTouches);

    if (type & (INPUT_END | INPUT_CANCEL)) {
        all = uniqueArray(all.concat(changed), 'identifier', true);
    }

    return [all, changed];
}

var TOUCH_INPUT_MAP = {
    touchstart: INPUT_START,
    touchmove: INPUT_MOVE,
    touchend: INPUT_END,
    touchcancel: INPUT_CANCEL
};

var TOUCH_TARGET_EVENTS = 'touchstart touchmove touchend touchcancel';

/**
 * Multi-user touch events input
 * @constructor
 * @extends Input
 */
function TouchInput() {
    this.evTarget = TOUCH_TARGET_EVENTS;
    this.targetIds = {};

    Input.apply(this, arguments);
}

inherit(TouchInput, Input, {
    handler: function MTEhandler(ev) {
        var type = TOUCH_INPUT_MAP[ev.type];
        var touches = getTouches.call(this, ev, type);
        if (!touches) {
            return;
        }

        this.callback(this.manager, type, {
            pointers: touches[0],
            changedPointers: touches[1],
            pointerType: INPUT_TYPE_TOUCH,
            srcEvent: ev
        });
    }
});

/**
 * @this {TouchInput}
 * @param {Object} ev
 * @param {Number} type flag
 * @returns {undefined|Array} [all, changed]
 */
function getTouches(ev, type) {
    var allTouches = toArray(ev.touches);
    var targetIds = this.targetIds;

    // when there is only one touch, the process can be simplified
    if (type & (INPUT_START | INPUT_MOVE) && allTouches.length === 1) {
        targetIds[allTouches[0].identifier] = true;
        return [allTouches, allTouches];
    }

    var i,
        targetTouches,
        changedTouches = toArray(ev.changedTouches),
        changedTargetTouches = [],
        target = this.target;

    // get target touches from touches
    targetTouches = allTouches.filter(function(touch) {
        return hasParent(touch.target, target);
    });

    // collect touches
    if (type === INPUT_START) {
        i = 0;
        while (i < targetTouches.length) {
            targetIds[targetTouches[i].identifier] = true;
            i++;
        }
    }

    // filter changed touches to only contain touches that exist in the collected target ids
    i = 0;
    while (i < changedTouches.length) {
        if (targetIds[changedTouches[i].identifier]) {
            changedTargetTouches.push(changedTouches[i]);
        }

        // cleanup removed touches
        if (type & (INPUT_END | INPUT_CANCEL)) {
            delete targetIds[changedTouches[i].identifier];
        }
        i++;
    }

    if (!changedTargetTouches.length) {
        return;
    }

    return [
        // merge targetTouches with changedTargetTouches so it contains ALL touches, including 'end' and 'cancel'
        uniqueArray(targetTouches.concat(changedTargetTouches), 'identifier', true),
        changedTargetTouches
    ];
}

/**
 * Combined touch and mouse input
 *
 * Touch has a higher priority then mouse, and while touching no mouse events are allowed.
 * This because touch devices also emit mouse events while doing a touch.
 *
 * @constructor
 * @extends Input
 */

var DEDUP_TIMEOUT = 2500;
var DEDUP_DISTANCE = 25;

function TouchMouseInput() {
    Input.apply(this, arguments);

    var handler = bindFn(this.handler, this);
    this.touch = new TouchInput(this.manager, handler);
    this.mouse = new MouseInput(this.manager, handler);

    this.primaryTouch = null;
    this.lastTouches = [];
}

inherit(TouchMouseInput, Input, {
    /**
     * handle mouse and touch events
     * @param {Hammer} manager
     * @param {String} inputEvent
     * @param {Object} inputData
     */
    handler: function TMEhandler(manager, inputEvent, inputData) {
        var isTouch = (inputData.pointerType == INPUT_TYPE_TOUCH),
            isMouse = (inputData.pointerType == INPUT_TYPE_MOUSE);

        if (isMouse && inputData.sourceCapabilities && inputData.sourceCapabilities.firesTouchEvents) {
            return;
        }

        // when we're in a touch event, record touches to  de-dupe synthetic mouse event
        if (isTouch) {
            recordTouches.call(this, inputEvent, inputData);
        } else if (isMouse && isSyntheticEvent.call(this, inputData)) {
            return;
        }

        this.callback(manager, inputEvent, inputData);
    },

    /**
     * remove the event listeners
     */
    destroy: function destroy() {
        this.touch.destroy();
        this.mouse.destroy();
    }
});

function recordTouches(eventType, eventData) {
    if (eventType & INPUT_START) {
        this.primaryTouch = eventData.changedPointers[0].identifier;
        setLastTouch.call(this, eventData);
    } else if (eventType & (INPUT_END | INPUT_CANCEL)) {
        setLastTouch.call(this, eventData);
    }
}

function setLastTouch(eventData) {
    var touch = eventData.changedPointers[0];

    if (touch.identifier === this.primaryTouch) {
        var lastTouch = {x: touch.clientX, y: touch.clientY};
        this.lastTouches.push(lastTouch);
        var lts = this.lastTouches;
        var removeLastTouch = function() {
            var i = lts.indexOf(lastTouch);
            if (i > -1) {
                lts.splice(i, 1);
            }
        };
        setTimeout(removeLastTouch, DEDUP_TIMEOUT);
    }
}

function isSyntheticEvent(eventData) {
    var x = eventData.srcEvent.clientX, y = eventData.srcEvent.clientY;
    for (var i = 0; i < this.lastTouches.length; i++) {
        var t = this.lastTouches[i];
        var dx = Math.abs(x - t.x), dy = Math.abs(y - t.y);
        if (dx <= DEDUP_DISTANCE && dy <= DEDUP_DISTANCE) {
            return true;
        }
    }
    return false;
}

var PREFIXED_TOUCH_ACTION = prefixed(TEST_ELEMENT.style, 'touchAction');
var NATIVE_TOUCH_ACTION = PREFIXED_TOUCH_ACTION !== undefined;

// magical touchAction value
var TOUCH_ACTION_COMPUTE = 'compute';
var TOUCH_ACTION_AUTO = 'auto';
var TOUCH_ACTION_MANIPULATION = 'manipulation'; // not implemented
var TOUCH_ACTION_NONE = 'none';
var TOUCH_ACTION_PAN_X = 'pan-x';
var TOUCH_ACTION_PAN_Y = 'pan-y';
var TOUCH_ACTION_MAP = getTouchActionProps();

/**
 * Touch Action
 * sets the touchAction property or uses the js alternative
 * @param {Manager} manager
 * @param {String} value
 * @constructor
 */
function TouchAction(manager, value) {
    this.manager = manager;
    this.set(value);
}

TouchAction.prototype = {
    /**
     * set the touchAction value on the element or enable the polyfill
     * @param {String} value
     */
    set: function(value) {
        // find out the touch-action by the event handlers
        if (value == TOUCH_ACTION_COMPUTE) {
            value = this.compute();
        }

        if (NATIVE_TOUCH_ACTION && this.manager.element.style && TOUCH_ACTION_MAP[value]) {
            this.manager.element.style[PREFIXED_TOUCH_ACTION] = value;
        }
        this.actions = value.toLowerCase().trim();
    },

    /**
     * just re-set the touchAction value
     */
    update: function() {
        this.set(this.manager.options.touchAction);
    },

    /**
     * compute the value for the touchAction property based on the recognizer's settings
     * @returns {String} value
     */
    compute: function() {
        var actions = [];
        each(this.manager.recognizers, function(recognizer) {
            if (boolOrFn(recognizer.options.enable, [recognizer])) {
                actions = actions.concat(recognizer.getTouchAction());
            }
        });
        return cleanTouchActions(actions.join(' '));
    },

    /**
     * this method is called on each input cycle and provides the preventing of the browser behavior
     * @param {Object} input
     */
    preventDefaults: function(input) {
        var srcEvent = input.srcEvent;
        var direction = input.offsetDirection;

        // if the touch action did prevented once this session
        if (this.manager.session.prevented) {
            srcEvent.preventDefault();
            return;
        }

        var actions = this.actions;
        var hasNone = inStr(actions, TOUCH_ACTION_NONE) && !TOUCH_ACTION_MAP[TOUCH_ACTION_NONE];
        var hasPanY = inStr(actions, TOUCH_ACTION_PAN_Y) && !TOUCH_ACTION_MAP[TOUCH_ACTION_PAN_Y];
        var hasPanX = inStr(actions, TOUCH_ACTION_PAN_X) && !TOUCH_ACTION_MAP[TOUCH_ACTION_PAN_X];

        if (hasNone) {
            //do not prevent defaults if this is a tap gesture

            var isTapPointer = input.pointers.length === 1;
            var isTapMovement = input.distance < 2;
            var isTapTouchTime = input.deltaTime < 250;

            if (isTapPointer && isTapMovement && isTapTouchTime) {
                return;
            }
        }

        if (hasPanX && hasPanY) {
            // `pan-x pan-y` means browser handles all scrolling/panning, do not prevent
            return;
        }

        if (hasNone ||
            (hasPanY && direction & DIRECTION_HORIZONTAL) ||
            (hasPanX && direction & DIRECTION_VERTICAL)) {
            return this.preventSrc(srcEvent);
        }
    },

    /**
     * call preventDefault to prevent the browser's default behavior (scrolling in most cases)
     * @param {Object} srcEvent
     */
    preventSrc: function(srcEvent) {
        this.manager.session.prevented = true;
        srcEvent.preventDefault();
    }
};

/**
 * when the touchActions are collected they are not a valid value, so we need to clean things up. *
 * @param {String} actions
 * @returns {*}
 */
function cleanTouchActions(actions) {
    // none
    if (inStr(actions, TOUCH_ACTION_NONE)) {
        return TOUCH_ACTION_NONE;
    }

    var hasPanX = inStr(actions, TOUCH_ACTION_PAN_X);
    var hasPanY = inStr(actions, TOUCH_ACTION_PAN_Y);

    // if both pan-x and pan-y are set (different recognizers
    // for different directions, e.g. horizontal pan but vertical swipe?)
    // we need none (as otherwise with pan-x pan-y combined none of these
    // recognizers will work, since the browser would handle all panning
    if (hasPanX && hasPanY) {
        return TOUCH_ACTION_NONE;
    }

    // pan-x OR pan-y
    if (hasPanX || hasPanY) {
        return hasPanX ? TOUCH_ACTION_PAN_X : TOUCH_ACTION_PAN_Y;
    }

    // manipulation
    if (inStr(actions, TOUCH_ACTION_MANIPULATION)) {
        return TOUCH_ACTION_MANIPULATION;
    }

    return TOUCH_ACTION_AUTO;
}

function getTouchActionProps() {
    if (!NATIVE_TOUCH_ACTION) {
        return false;
    }
    var touchMap = {};
    var cssSupports = window.CSS && window.CSS.supports;
    ['auto', 'manipulation', 'pan-y', 'pan-x', 'pan-x pan-y', 'none'].forEach(function(val) {

        // If css.supports is not supported but there is native touch-action assume it supports
        // all values. This is the case for IE 10 and 11.
        touchMap[val] = cssSupports ? window.CSS.supports('touch-action', val) : true;
    });
    return touchMap;
}

/**
 * Recognizer flow explained; *
 * All recognizers have the initial state of POSSIBLE when a input session starts.
 * The definition of a input session is from the first input until the last input, with all it's movement in it. *
 * Example session for mouse-input: mousedown -> mousemove -> mouseup
 *
 * On each recognizing cycle (see Manager.recognize) the .recognize() method is executed
 * which determines with state it should be.
 *
 * If the recognizer has the state FAILED, CANCELLED or RECOGNIZED (equals ENDED), it is reset to
 * POSSIBLE to give it another change on the next cycle.
 *
 *               Possible
 *                  |
 *            +-----+---------------+
 *            |                     |
 *      +-----+-----+               |
 *      |           |               |
 *   Failed      Cancelled          |
 *                          +-------+------+
 *                          |              |
 *                      Recognized       Began
 *                                         |
 *                                      Changed
 *                                         |
 *                                  Ended/Recognized
 */
var STATE_POSSIBLE = 1;
var STATE_BEGAN = 2;
var STATE_CHANGED = 4;
var STATE_ENDED = 8;
var STATE_RECOGNIZED = STATE_ENDED;
var STATE_CANCELLED = 16;
var STATE_FAILED = 32;

/**
 * Recognizer
 * Every recognizer needs to extend from this class.
 * @constructor
 * @param {Object} options
 */
function Recognizer(options) {
    this.options = assign({}, this.defaults, options || {});

    this.id = uniqueId();

    this.manager = null;

    // default is enable true
    this.options.enable = ifUndefined(this.options.enable, true);

    this.state = STATE_POSSIBLE;

    this.simultaneous = {};
    this.requireFail = [];
}

Recognizer.prototype = {
    /**
     * @virtual
     * @type {Object}
     */
    defaults: {},

    /**
     * set options
     * @param {Object} options
     * @return {Recognizer}
     */
    set: function(options) {
        assign(this.options, options);

        // also update the touchAction, in case something changed about the directions/enabled state
        this.manager && this.manager.touchAction.update();
        return this;
    },

    /**
     * recognize simultaneous with an other recognizer.
     * @param {Recognizer} otherRecognizer
     * @returns {Recognizer} this
     */
    recognizeWith: function(otherRecognizer) {
        if (invokeArrayArg(otherRecognizer, 'recognizeWith', this)) {
            return this;
        }

        var simultaneous = this.simultaneous;
        otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);
        if (!simultaneous[otherRecognizer.id]) {
            simultaneous[otherRecognizer.id] = otherRecognizer;
            otherRecognizer.recognizeWith(this);
        }
        return this;
    },

    /**
     * drop the simultaneous link. it doesnt remove the link on the other recognizer.
     * @param {Recognizer} otherRecognizer
     * @returns {Recognizer} this
     */
    dropRecognizeWith: function(otherRecognizer) {
        if (invokeArrayArg(otherRecognizer, 'dropRecognizeWith', this)) {
            return this;
        }

        otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);
        delete this.simultaneous[otherRecognizer.id];
        return this;
    },

    /**
     * recognizer can only run when an other is failing
     * @param {Recognizer} otherRecognizer
     * @returns {Recognizer} this
     */
    requireFailure: function(otherRecognizer) {
        if (invokeArrayArg(otherRecognizer, 'requireFailure', this)) {
            return this;
        }

        var requireFail = this.requireFail;
        otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);
        if (inArray(requireFail, otherRecognizer) === -1) {
            requireFail.push(otherRecognizer);
            otherRecognizer.requireFailure(this);
        }
        return this;
    },

    /**
     * drop the requireFailure link. it does not remove the link on the other recognizer.
     * @param {Recognizer} otherRecognizer
     * @returns {Recognizer} this
     */
    dropRequireFailure: function(otherRecognizer) {
        if (invokeArrayArg(otherRecognizer, 'dropRequireFailure', this)) {
            return this;
        }

        otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);
        var index = inArray(this.requireFail, otherRecognizer);
        if (index > -1) {
            this.requireFail.splice(index, 1);
        }
        return this;
    },

    /**
     * has require failures boolean
     * @returns {boolean}
     */
    hasRequireFailures: function() {
        return this.requireFail.length > 0;
    },

    /**
     * if the recognizer can recognize simultaneous with an other recognizer
     * @param {Recognizer} otherRecognizer
     * @returns {Boolean}
     */
    canRecognizeWith: function(otherRecognizer) {
        return !!this.simultaneous[otherRecognizer.id];
    },

    /**
     * You should use `tryEmit` instead of `emit` directly to check
     * that all the needed recognizers has failed before emitting.
     * @param {Object} input
     */
    emit: function(input) {
        var self = this;
        var state = this.state;

        function emit(event) {
            self.manager.emit(event, input);
        }

        // 'panstart' and 'panmove'
        if (state < STATE_ENDED) {
            emit(self.options.event + stateStr(state));
        }

        emit(self.options.event); // simple 'eventName' events

        if (input.additionalEvent) { // additional event(panleft, panright, pinchin, pinchout...)
            emit(input.additionalEvent);
        }

        // panend and pancancel
        if (state >= STATE_ENDED) {
            emit(self.options.event + stateStr(state));
        }
    },

    /**
     * Check that all the require failure recognizers has failed,
     * if true, it emits a gesture event,
     * otherwise, setup the state to FAILED.
     * @param {Object} input
     */
    tryEmit: function(input) {
        if (this.canEmit()) {
            return this.emit(input);
        }
        // it's failing anyway
        this.state = STATE_FAILED;
    },

    /**
     * can we emit?
     * @returns {boolean}
     */
    canEmit: function() {
        var i = 0;
        while (i < this.requireFail.length) {
            if (!(this.requireFail[i].state & (STATE_FAILED | STATE_POSSIBLE))) {
                return false;
            }
            i++;
        }
        return true;
    },

    /**
     * update the recognizer
     * @param {Object} inputData
     */
    recognize: function(inputData) {
        // make a new copy of the inputData
        // so we can change the inputData without messing up the other recognizers
        var inputDataClone = assign({}, inputData);

        // is is enabled and allow recognizing?
        if (!boolOrFn(this.options.enable, [this, inputDataClone])) {
            this.reset();
            this.state = STATE_FAILED;
            return;
        }

        // reset when we've reached the end
        if (this.state & (STATE_RECOGNIZED | STATE_CANCELLED | STATE_FAILED)) {
            this.state = STATE_POSSIBLE;
        }

        this.state = this.process(inputDataClone);

        // the recognizer has recognized a gesture
        // so trigger an event
        if (this.state & (STATE_BEGAN | STATE_CHANGED | STATE_ENDED | STATE_CANCELLED)) {
            this.tryEmit(inputDataClone);
        }
    },

    /**
     * return the state of the recognizer
     * the actual recognizing happens in this method
     * @virtual
     * @param {Object} inputData
     * @returns {Const} STATE
     */
    process: function(inputData) { }, // jshint ignore:line

    /**
     * return the preferred touch-action
     * @virtual
     * @returns {Array}
     */
    getTouchAction: function() { },

    /**
     * called when the gesture isn't allowed to recognize
     * like when another is being recognized or it is disabled
     * @virtual
     */
    reset: function() { }
};

/**
 * get a usable string, used as event postfix
 * @param {Const} state
 * @returns {String} state
 */
function stateStr(state) {
    if (state & STATE_CANCELLED) {
        return 'cancel';
    } else if (state & STATE_ENDED) {
        return 'end';
    } else if (state & STATE_CHANGED) {
        return 'move';
    } else if (state & STATE_BEGAN) {
        return 'start';
    }
    return '';
}

/**
 * direction cons to string
 * @param {Const} direction
 * @returns {String}
 */
function directionStr(direction) {
    if (direction == DIRECTION_DOWN) {
        return 'down';
    } else if (direction == DIRECTION_UP) {
        return 'up';
    } else if (direction == DIRECTION_LEFT) {
        return 'left';
    } else if (direction == DIRECTION_RIGHT) {
        return 'right';
    }
    return '';
}

/**
 * get a recognizer by name if it is bound to a manager
 * @param {Recognizer|String} otherRecognizer
 * @param {Recognizer} recognizer
 * @returns {Recognizer}
 */
function getRecognizerByNameIfManager(otherRecognizer, recognizer) {
    var manager = recognizer.manager;
    if (manager) {
        return manager.get(otherRecognizer);
    }
    return otherRecognizer;
}

/**
 * This recognizer is just used as a base for the simple attribute recognizers.
 * @constructor
 * @extends Recognizer
 */
function AttrRecognizer() {
    Recognizer.apply(this, arguments);
}

inherit(AttrRecognizer, Recognizer, {
    /**
     * @namespace
     * @memberof AttrRecognizer
     */
    defaults: {
        /**
         * @type {Number}
         * @default 1
         */
        pointers: 1
    },

    /**
     * Used to check if it the recognizer receives valid input, like input.distance > 10.
     * @memberof AttrRecognizer
     * @param {Object} input
     * @returns {Boolean} recognized
     */
    attrTest: function(input) {
        var optionPointers = this.options.pointers;
        return optionPointers === 0 || input.pointers.length === optionPointers;
    },

    /**
     * Process the input and return the state for the recognizer
     * @memberof AttrRecognizer
     * @param {Object} input
     * @returns {*} State
     */
    process: function(input) {
        var state = this.state;
        var eventType = input.eventType;

        var isRecognized = state & (STATE_BEGAN | STATE_CHANGED);
        var isValid = this.attrTest(input);

        // on cancel input and we've recognized before, return STATE_CANCELLED
        if (isRecognized && (eventType & INPUT_CANCEL || !isValid)) {
            return state | STATE_CANCELLED;
        } else if (isRecognized || isValid) {
            if (eventType & INPUT_END) {
                return state | STATE_ENDED;
            } else if (!(state & STATE_BEGAN)) {
                return STATE_BEGAN;
            }
            return state | STATE_CHANGED;
        }
        return STATE_FAILED;
    }
});

/**
 * Pan
 * Recognized when the pointer is down and moved in the allowed direction.
 * @constructor
 * @extends AttrRecognizer
 */
function PanRecognizer() {
    AttrRecognizer.apply(this, arguments);

    this.pX = null;
    this.pY = null;
}

inherit(PanRecognizer, AttrRecognizer, {
    /**
     * @namespace
     * @memberof PanRecognizer
     */
    defaults: {
        event: 'pan',
        threshold: 10,
        pointers: 1,
        direction: DIRECTION_ALL
    },

    getTouchAction: function() {
        var direction = this.options.direction;
        var actions = [];
        if (direction & DIRECTION_HORIZONTAL) {
            actions.push(TOUCH_ACTION_PAN_Y);
        }
        if (direction & DIRECTION_VERTICAL) {
            actions.push(TOUCH_ACTION_PAN_X);
        }
        return actions;
    },

    directionTest: function(input) {
        var options = this.options;
        var hasMoved = true;
        var distance = input.distance;
        var direction = input.direction;
        var x = input.deltaX;
        var y = input.deltaY;

        // lock to axis?
        if (!(direction & options.direction)) {
            if (options.direction & DIRECTION_HORIZONTAL) {
                direction = (x === 0) ? DIRECTION_NONE : (x < 0) ? DIRECTION_LEFT : DIRECTION_RIGHT;
                hasMoved = x != this.pX;
                distance = Math.abs(input.deltaX);
            } else {
                direction = (y === 0) ? DIRECTION_NONE : (y < 0) ? DIRECTION_UP : DIRECTION_DOWN;
                hasMoved = y != this.pY;
                distance = Math.abs(input.deltaY);
            }
        }
        input.direction = direction;
        return hasMoved && distance > options.threshold && direction & options.direction;
    },

    attrTest: function(input) {
        return AttrRecognizer.prototype.attrTest.call(this, input) &&
            (this.state & STATE_BEGAN || (!(this.state & STATE_BEGAN) && this.directionTest(input)));
    },

    emit: function(input) {

        this.pX = input.deltaX;
        this.pY = input.deltaY;

        var direction = directionStr(input.direction);

        if (direction) {
            input.additionalEvent = this.options.event + direction;
        }
        this._super.emit.call(this, input);
    }
});

/**
 * Pinch
 * Recognized when two or more pointers are moving toward (zoom-in) or away from each other (zoom-out).
 * @constructor
 * @extends AttrRecognizer
 */
function PinchRecognizer() {
    AttrRecognizer.apply(this, arguments);
}

inherit(PinchRecognizer, AttrRecognizer, {
    /**
     * @namespace
     * @memberof PinchRecognizer
     */
    defaults: {
        event: 'pinch',
        threshold: 0,
        pointers: 2
    },

    getTouchAction: function() {
        return [TOUCH_ACTION_NONE];
    },

    attrTest: function(input) {
        return this._super.attrTest.call(this, input) &&
            (Math.abs(input.scale - 1) > this.options.threshold || this.state & STATE_BEGAN);
    },

    emit: function(input) {
        if (input.scale !== 1) {
            var inOut = input.scale < 1 ? 'in' : 'out';
            input.additionalEvent = this.options.event + inOut;
        }
        this._super.emit.call(this, input);
    }
});

/**
 * Press
 * Recognized when the pointer is down for x ms without any movement.
 * @constructor
 * @extends Recognizer
 */
function PressRecognizer() {
    Recognizer.apply(this, arguments);

    this._timer = null;
    this._input = null;
}

inherit(PressRecognizer, Recognizer, {
    /**
     * @namespace
     * @memberof PressRecognizer
     */
    defaults: {
        event: 'press',
        pointers: 1,
        time: 251, // minimal time of the pointer to be pressed
        threshold: 9 // a minimal movement is ok, but keep it low
    },

    getTouchAction: function() {
        return [TOUCH_ACTION_AUTO];
    },

    process: function(input) {
        var options = this.options;
        var validPointers = input.pointers.length === options.pointers;
        var validMovement = input.distance < options.threshold;
        var validTime = input.deltaTime > options.time;

        this._input = input;

        // we only allow little movement
        // and we've reached an end event, so a tap is possible
        if (!validMovement || !validPointers || (input.eventType & (INPUT_END | INPUT_CANCEL) && !validTime)) {
            this.reset();
        } else if (input.eventType & INPUT_START) {
            this.reset();
            this._timer = setTimeoutContext(function() {
                this.state = STATE_RECOGNIZED;
                this.tryEmit();
            }, options.time, this);
        } else if (input.eventType & INPUT_END) {
            return STATE_RECOGNIZED;
        }
        return STATE_FAILED;
    },

    reset: function() {
        clearTimeout(this._timer);
    },

    emit: function(input) {
        if (this.state !== STATE_RECOGNIZED) {
            return;
        }

        if (input && (input.eventType & INPUT_END)) {
            this.manager.emit(this.options.event + 'up', input);
        } else {
            this._input.timeStamp = now();
            this.manager.emit(this.options.event, this._input);
        }
    }
});

/**
 * Rotate
 * Recognized when two or more pointer are moving in a circular motion.
 * @constructor
 * @extends AttrRecognizer
 */
function RotateRecognizer() {
    AttrRecognizer.apply(this, arguments);
}

inherit(RotateRecognizer, AttrRecognizer, {
    /**
     * @namespace
     * @memberof RotateRecognizer
     */
    defaults: {
        event: 'rotate',
        threshold: 0,
        pointers: 2
    },

    getTouchAction: function() {
        return [TOUCH_ACTION_NONE];
    },

    attrTest: function(input) {
        return this._super.attrTest.call(this, input) &&
            (Math.abs(input.rotation) > this.options.threshold || this.state & STATE_BEGAN);
    }
});

/**
 * Swipe
 * Recognized when the pointer is moving fast (velocity), with enough distance in the allowed direction.
 * @constructor
 * @extends AttrRecognizer
 */
function SwipeRecognizer() {
    AttrRecognizer.apply(this, arguments);
}

inherit(SwipeRecognizer, AttrRecognizer, {
    /**
     * @namespace
     * @memberof SwipeRecognizer
     */
    defaults: {
        event: 'swipe',
        threshold: 10,
        velocity: 0.3,
        direction: DIRECTION_HORIZONTAL | DIRECTION_VERTICAL,
        pointers: 1
    },

    getTouchAction: function() {
        return PanRecognizer.prototype.getTouchAction.call(this);
    },

    attrTest: function(input) {
        var direction = this.options.direction;
        var velocity;

        if (direction & (DIRECTION_HORIZONTAL | DIRECTION_VERTICAL)) {
            velocity = input.overallVelocity;
        } else if (direction & DIRECTION_HORIZONTAL) {
            velocity = input.overallVelocityX;
        } else if (direction & DIRECTION_VERTICAL) {
            velocity = input.overallVelocityY;
        }

        return this._super.attrTest.call(this, input) &&
            direction & input.offsetDirection &&
            input.distance > this.options.threshold &&
            input.maxPointers == this.options.pointers &&
            abs(velocity) > this.options.velocity && input.eventType & INPUT_END;
    },

    emit: function(input) {
        var direction = directionStr(input.offsetDirection);
        if (direction) {
            this.manager.emit(this.options.event + direction, input);
        }

        this.manager.emit(this.options.event, input);
    }
});

/**
 * A tap is ecognized when the pointer is doing a small tap/click. Multiple taps are recognized if they occur
 * between the given interval and position. The delay option can be used to recognize multi-taps without firing
 * a single tap.
 *
 * The eventData from the emitted event contains the property `tapCount`, which contains the amount of
 * multi-taps being recognized.
 * @constructor
 * @extends Recognizer
 */
function TapRecognizer() {
    Recognizer.apply(this, arguments);

    // previous time and center,
    // used for tap counting
    this.pTime = false;
    this.pCenter = false;

    this._timer = null;
    this._input = null;
    this.count = 0;
}

inherit(TapRecognizer, Recognizer, {
    /**
     * @namespace
     * @memberof PinchRecognizer
     */
    defaults: {
        event: 'tap',
        pointers: 1,
        taps: 1,
        interval: 300, // max time between the multi-tap taps
        time: 250, // max time of the pointer to be down (like finger on the screen)
        threshold: 9, // a minimal movement is ok, but keep it low
        posThreshold: 10 // a multi-tap can be a bit off the initial position
    },

    getTouchAction: function() {
        return [TOUCH_ACTION_MANIPULATION];
    },

    process: function(input) {
        var options = this.options;

        var validPointers = input.pointers.length === options.pointers;
        var validMovement = input.distance < options.threshold;
        var validTouchTime = input.deltaTime < options.time;

        this.reset();

        if ((input.eventType & INPUT_START) && (this.count === 0)) {
            return this.failTimeout();
        }

        // we only allow little movement
        // and we've reached an end event, so a tap is possible
        if (validMovement && validTouchTime && validPointers) {
            if (input.eventType != INPUT_END) {
                return this.failTimeout();
            }

            var validInterval = this.pTime ? (input.timeStamp - this.pTime < options.interval) : true;
            var validMultiTap = !this.pCenter || getDistance(this.pCenter, input.center) < options.posThreshold;

            this.pTime = input.timeStamp;
            this.pCenter = input.center;

            if (!validMultiTap || !validInterval) {
                this.count = 1;
            } else {
                this.count += 1;
            }

            this._input = input;

            // if tap count matches we have recognized it,
            // else it has began recognizing...
            var tapCount = this.count % options.taps;
            if (tapCount === 0) {
                // no failing requirements, immediately trigger the tap event
                // or wait as long as the multitap interval to trigger
                if (!this.hasRequireFailures()) {
                    return STATE_RECOGNIZED;
                } else {
                    this._timer = setTimeoutContext(function() {
                        this.state = STATE_RECOGNIZED;
                        this.tryEmit();
                    }, options.interval, this);
                    return STATE_BEGAN;
                }
            }
        }
        return STATE_FAILED;
    },

    failTimeout: function() {
        this._timer = setTimeoutContext(function() {
            this.state = STATE_FAILED;
        }, this.options.interval, this);
        return STATE_FAILED;
    },

    reset: function() {
        clearTimeout(this._timer);
    },

    emit: function() {
        if (this.state == STATE_RECOGNIZED) {
            this._input.tapCount = this.count;
            this.manager.emit(this.options.event, this._input);
        }
    }
});

/**
 * Simple way to create a manager with a default set of recognizers.
 * @param {HTMLElement} element
 * @param {Object} [options]
 * @constructor
 */
function Hammer(element, options) {
    options = options || {};
    options.recognizers = ifUndefined(options.recognizers, Hammer.defaults.preset);
    return new Manager(element, options);
}

/**
 * @const {string}
 */
Hammer.VERSION = '2.0.7';

/**
 * default settings
 * @namespace
 */
Hammer.defaults = {
    /**
     * set if DOM events are being triggered.
     * But this is slower and unused by simple implementations, so disabled by default.
     * @type {Boolean}
     * @default false
     */
    domEvents: false,

    /**
     * The value for the touchAction property/fallback.
     * When set to `compute` it will magically set the correct value based on the added recognizers.
     * @type {String}
     * @default compute
     */
    touchAction: TOUCH_ACTION_COMPUTE,

    /**
     * @type {Boolean}
     * @default true
     */
    enable: true,

    /**
     * EXPERIMENTAL FEATURE -- can be removed/changed
     * Change the parent input target element.
     * If Null, then it is being set the to main element.
     * @type {Null|EventTarget}
     * @default null
     */
    inputTarget: null,

    /**
     * force an input class
     * @type {Null|Function}
     * @default null
     */
    inputClass: null,

    /**
     * Default recognizer setup when calling `Hammer()`
     * When creating a new Manager these will be skipped.
     * @type {Array}
     */
    preset: [
        // RecognizerClass, options, [recognizeWith, ...], [requireFailure, ...]
        [RotateRecognizer, {enable: false}],
        [PinchRecognizer, {enable: false}, ['rotate']],
        [SwipeRecognizer, {direction: DIRECTION_HORIZONTAL}],
        [PanRecognizer, {direction: DIRECTION_HORIZONTAL}, ['swipe']],
        [TapRecognizer],
        [TapRecognizer, {event: 'doubletap', taps: 2}, ['tap']],
        [PressRecognizer]
    ],

    /**
     * Some CSS properties can be used to improve the working of Hammer.
     * Add them to this method and they will be set when creating a new Manager.
     * @namespace
     */
    cssProps: {
        /**
         * Disables text selection to improve the dragging gesture. Mainly for desktop browsers.
         * @type {String}
         * @default 'none'
         */
        userSelect: 'none',

        /**
         * Disable the Windows Phone grippers when pressing an element.
         * @type {String}
         * @default 'none'
         */
        touchSelect: 'none',

        /**
         * Disables the default callout shown when you touch and hold a touch target.
         * On iOS, when you touch and hold a touch target such as a link, Safari displays
         * a callout containing information about the link. This property allows you to disable that callout.
         * @type {String}
         * @default 'none'
         */
        touchCallout: 'none',

        /**
         * Specifies whether zooming is enabled. Used by IE10>
         * @type {String}
         * @default 'none'
         */
        contentZooming: 'none',

        /**
         * Specifies that an entire element should be draggable instead of its contents. Mainly for desktop browsers.
         * @type {String}
         * @default 'none'
         */
        userDrag: 'none',

        /**
         * Overrides the highlight color shown when the user taps a link or a JavaScript
         * clickable element in iOS. This property obeys the alpha value, if specified.
         * @type {String}
         * @default 'rgba(0,0,0,0)'
         */
        tapHighlightColor: 'rgba(0,0,0,0)'
    }
};

var STOP = 1;
var FORCED_STOP = 2;

/**
 * Manager
 * @param {HTMLElement} element
 * @param {Object} [options]
 * @constructor
 */
function Manager(element, options) {
    this.options = assign({}, Hammer.defaults, options || {});

    this.options.inputTarget = this.options.inputTarget || element;

    this.handlers = {};
    this.session = {};
    this.recognizers = [];
    this.oldCssProps = {};

    this.element = element;
    this.input = createInputInstance(this);
    this.touchAction = new TouchAction(this, this.options.touchAction);

    toggleCssProps(this, true);

    each(this.options.recognizers, function(item) {
        var recognizer = this.add(new (item[0])(item[1]));
        item[2] && recognizer.recognizeWith(item[2]);
        item[3] && recognizer.requireFailure(item[3]);
    }, this);
}

Manager.prototype = {
    /**
     * set options
     * @param {Object} options
     * @returns {Manager}
     */
    set: function(options) {
        assign(this.options, options);

        // Options that need a little more setup
        if (options.touchAction) {
            this.touchAction.update();
        }
        if (options.inputTarget) {
            // Clean up existing event listeners and reinitialize
            this.input.destroy();
            this.input.target = options.inputTarget;
            this.input.init();
        }
        return this;
    },

    /**
     * stop recognizing for this session.
     * This session will be discarded, when a new [input]start event is fired.
     * When forced, the recognizer cycle is stopped immediately.
     * @param {Boolean} [force]
     */
    stop: function(force) {
        this.session.stopped = force ? FORCED_STOP : STOP;
    },

    /**
     * run the recognizers!
     * called by the inputHandler function on every movement of the pointers (touches)
     * it walks through all the recognizers and tries to detect the gesture that is being made
     * @param {Object} inputData
     */
    recognize: function(inputData) {
        var session = this.session;
        if (session.stopped) {
            return;
        }

        // run the touch-action polyfill
        this.touchAction.preventDefaults(inputData);

        var recognizer;
        var recognizers = this.recognizers;

        // this holds the recognizer that is being recognized.
        // so the recognizer's state needs to be BEGAN, CHANGED, ENDED or RECOGNIZED
        // if no recognizer is detecting a thing, it is set to `null`
        var curRecognizer = session.curRecognizer;

        // reset when the last recognizer is recognized
        // or when we're in a new session
        if (!curRecognizer || (curRecognizer && curRecognizer.state & STATE_RECOGNIZED)) {
            curRecognizer = session.curRecognizer = null;
        }

        var i = 0;
        while (i < recognizers.length) {
            recognizer = recognizers[i];

            // find out if we are allowed try to recognize the input for this one.
            // 1.   allow if the session is NOT forced stopped (see the .stop() method)
            // 2.   allow if we still haven't recognized a gesture in this session, or the this recognizer is the one
            //      that is being recognized.
            // 3.   allow if the recognizer is allowed to run simultaneous with the current recognized recognizer.
            //      this can be setup with the `recognizeWith()` method on the recognizer.
            if (session.stopped !== FORCED_STOP && ( // 1
                    !curRecognizer || recognizer == curRecognizer || // 2
                    recognizer.canRecognizeWith(curRecognizer))) { // 3
                recognizer.recognize(inputData);
            } else {
                recognizer.reset();
            }

            // if the recognizer has been recognizing the input as a valid gesture, we want to store this one as the
            // current active recognizer. but only if we don't already have an active recognizer
            if (!curRecognizer && recognizer.state & (STATE_BEGAN | STATE_CHANGED | STATE_ENDED)) {
                curRecognizer = session.curRecognizer = recognizer;
            }
            i++;
        }
    },

    /**
     * get a recognizer by its event name.
     * @param {Recognizer|String} recognizer
     * @returns {Recognizer|Null}
     */
    get: function(recognizer) {
        if (recognizer instanceof Recognizer) {
            return recognizer;
        }

        var recognizers = this.recognizers;
        for (var i = 0; i < recognizers.length; i++) {
            if (recognizers[i].options.event == recognizer) {
                return recognizers[i];
            }
        }
        return null;
    },

    /**
     * add a recognizer to the manager
     * existing recognizers with the same event name will be removed
     * @param {Recognizer} recognizer
     * @returns {Recognizer|Manager}
     */
    add: function(recognizer) {
        if (invokeArrayArg(recognizer, 'add', this)) {
            return this;
        }

        // remove existing
        var existing = this.get(recognizer.options.event);
        if (existing) {
            this.remove(existing);
        }

        this.recognizers.push(recognizer);
        recognizer.manager = this;

        this.touchAction.update();
        return recognizer;
    },

    /**
     * remove a recognizer by name or instance
     * @param {Recognizer|String} recognizer
     * @returns {Manager}
     */
    remove: function(recognizer) {
        if (invokeArrayArg(recognizer, 'remove', this)) {
            return this;
        }

        recognizer = this.get(recognizer);

        // let's make sure this recognizer exists
        if (recognizer) {
            var recognizers = this.recognizers;
            var index = inArray(recognizers, recognizer);

            if (index !== -1) {
                recognizers.splice(index, 1);
                this.touchAction.update();
            }
        }

        return this;
    },

    /**
     * bind event
     * @param {String} events
     * @param {Function} handler
     * @returns {EventEmitter} this
     */
    on: function(events, handler) {
        if (events === undefined) {
            return;
        }
        if (handler === undefined) {
            return;
        }

        var handlers = this.handlers;
        each(splitStr(events), function(event) {
            handlers[event] = handlers[event] || [];
            handlers[event].push(handler);
        });
        return this;
    },

    /**
     * unbind event, leave emit blank to remove all handlers
     * @param {String} events
     * @param {Function} [handler]
     * @returns {EventEmitter} this
     */
    off: function(events, handler) {
        if (events === undefined) {
            return;
        }

        var handlers = this.handlers;
        each(splitStr(events), function(event) {
            if (!handler) {
                delete handlers[event];
            } else {
                handlers[event] && handlers[event].splice(inArray(handlers[event], handler), 1);
            }
        });
        return this;
    },

    /**
     * emit event to the listeners
     * @param {String} event
     * @param {Object} data
     */
    emit: function(event, data) {
        // we also want to trigger dom events
        if (this.options.domEvents) {
            triggerDomEvent(event, data);
        }

        // no handlers, so skip it all
        var handlers = this.handlers[event] && this.handlers[event].slice();
        if (!handlers || !handlers.length) {
            return;
        }

        data.type = event;
        data.preventDefault = function() {
            data.srcEvent.preventDefault();
        };

        var i = 0;
        while (i < handlers.length) {
            handlers[i](data);
            i++;
        }
    },

    /**
     * destroy the manager and unbinds all events
     * it doesn't unbind dom events, that is the user own responsibility
     */
    destroy: function() {
        this.element && toggleCssProps(this, false);

        this.handlers = {};
        this.session = {};
        this.input.destroy();
        this.element = null;
    }
};

/**
 * add/remove the css properties as defined in manager.options.cssProps
 * @param {Manager} manager
 * @param {Boolean} add
 */
function toggleCssProps(manager, add) {
    var element = manager.element;
    if (!element.style) {
        return;
    }
    var prop;
    each(manager.options.cssProps, function(value, name) {
        prop = prefixed(element.style, name);
        if (add) {
            manager.oldCssProps[prop] = element.style[prop];
            element.style[prop] = value;
        } else {
            element.style[prop] = manager.oldCssProps[prop] || '';
        }
    });
    if (!add) {
        manager.oldCssProps = {};
    }
}

/**
 * trigger dom event
 * @param {String} event
 * @param {Object} data
 */
function triggerDomEvent(event, data) {
    var gestureEvent = document.createEvent('Event');
    gestureEvent.initEvent(event, true, true);
    gestureEvent.gesture = data;
    data.target.dispatchEvent(gestureEvent);
}

assign(Hammer, {
    INPUT_START: INPUT_START,
    INPUT_MOVE: INPUT_MOVE,
    INPUT_END: INPUT_END,
    INPUT_CANCEL: INPUT_CANCEL,

    STATE_POSSIBLE: STATE_POSSIBLE,
    STATE_BEGAN: STATE_BEGAN,
    STATE_CHANGED: STATE_CHANGED,
    STATE_ENDED: STATE_ENDED,
    STATE_RECOGNIZED: STATE_RECOGNIZED,
    STATE_CANCELLED: STATE_CANCELLED,
    STATE_FAILED: STATE_FAILED,

    DIRECTION_NONE: DIRECTION_NONE,
    DIRECTION_LEFT: DIRECTION_LEFT,
    DIRECTION_RIGHT: DIRECTION_RIGHT,
    DIRECTION_UP: DIRECTION_UP,
    DIRECTION_DOWN: DIRECTION_DOWN,
    DIRECTION_HORIZONTAL: DIRECTION_HORIZONTAL,
    DIRECTION_VERTICAL: DIRECTION_VERTICAL,
    DIRECTION_ALL: DIRECTION_ALL,

    Manager: Manager,
    Input: Input,
    TouchAction: TouchAction,

    TouchInput: TouchInput,
    MouseInput: MouseInput,
    PointerEventInput: PointerEventInput,
    TouchMouseInput: TouchMouseInput,
    SingleTouchInput: SingleTouchInput,

    Recognizer: Recognizer,
    AttrRecognizer: AttrRecognizer,
    Tap: TapRecognizer,
    Pan: PanRecognizer,
    Swipe: SwipeRecognizer,
    Pinch: PinchRecognizer,
    Rotate: RotateRecognizer,
    Press: PressRecognizer,

    on: addEventListeners,
    off: removeEventListeners,
    each: each,
    merge: merge,
    extend: extend,
    assign: assign,
    inherit: inherit,
    bindFn: bindFn,
    prefixed: prefixed
});

// this prevents errors when Hammer is loaded in the presence of an AMD
//  style loader but by script tag, not by the loader.
var freeGlobal = (typeof window !== 'undefined' ? window : (typeof self !== 'undefined' ? self : {})); // jshint ignore:line
freeGlobal.Hammer = Hammer;

if (true) {
    !(__WEBPACK_AMD_DEFINE_RESULT__ = (function() {
        return Hammer;
    }).call(exports, __nested_webpack_require_462074__, exports, module),
		__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
} else {}

})(window, document, 'Hammer');


/***/ }),

/***/ 981:
/***/ ((module) => {

/*
 * Hamster.js v1.1.2
 * (c) 2013 Monospaced http://monospaced.com
 * License: MIT
 */

(function(window, document){
'use strict';

/**
 * Hamster
 * use this to create instances
 * @returns {Hamster.Instance}
 * @constructor
 */
var Hamster = function(element) {
  return new Hamster.Instance(element);
};

// default event name
Hamster.SUPPORT = 'wheel';

// default DOM methods
Hamster.ADD_EVENT = 'addEventListener';
Hamster.REMOVE_EVENT = 'removeEventListener';
Hamster.PREFIX = '';

// until browser inconsistencies have been fixed...
Hamster.READY = false;

Hamster.Instance = function(element){
  if (!Hamster.READY) {
    // fix browser inconsistencies
    Hamster.normalise.browser();

    // Hamster is ready...!
    Hamster.READY = true;
  }

  this.element = element;

  // store attached event handlers
  this.handlers = [];

  // return instance
  return this;
};

/**
 * create new hamster instance
 * all methods should return the instance itself, so it is chainable.
 * @param   {HTMLElement}       element
 * @returns {Hamster.Instance}
 * @constructor
 */
Hamster.Instance.prototype = {
  /**
   * bind events to the instance
   * @param   {Function}    handler
   * @param   {Boolean}     useCapture
   * @returns {Hamster.Instance}
   */
  wheel: function onEvent(handler, useCapture){
    Hamster.event.add(this, Hamster.SUPPORT, handler, useCapture);

    // handle MozMousePixelScroll in older Firefox
    if (Hamster.SUPPORT === 'DOMMouseScroll') {
      Hamster.event.add(this, 'MozMousePixelScroll', handler, useCapture);
    }

    return this;
  },

  /**
   * unbind events to the instance
   * @param   {Function}    handler
   * @param   {Boolean}     useCapture
   * @returns {Hamster.Instance}
   */
  unwheel: function offEvent(handler, useCapture){
    // if no handler argument,
    // unbind the last bound handler (if exists)
    if (handler === undefined && (handler = this.handlers.slice(-1)[0])) {
      handler = handler.original;
    }

    Hamster.event.remove(this, Hamster.SUPPORT, handler, useCapture);

    // handle MozMousePixelScroll in older Firefox
    if (Hamster.SUPPORT === 'DOMMouseScroll') {
      Hamster.event.remove(this, 'MozMousePixelScroll', handler, useCapture);
    }

    return this;
  }
};

Hamster.event = {
  /**
   * cross-browser 'addWheelListener'
   * @param   {Instance}    hamster
   * @param   {String}      eventName
   * @param   {Function}    handler
   * @param   {Boolean}     useCapture
   */
  add: function add(hamster, eventName, handler, useCapture){
    // store the original handler
    var originalHandler = handler;

    // redefine the handler
    handler = function(originalEvent){

      if (!originalEvent) {
        originalEvent = window.event;
      }

      // create a normalised event object,
      // and normalise "deltas" of the mouse wheel
      var event = Hamster.normalise.event(originalEvent),
          delta = Hamster.normalise.delta(originalEvent);

      // fire the original handler with normalised arguments
      return originalHandler(event, delta[0], delta[1], delta[2]);

    };

    // cross-browser addEventListener
    hamster.element[Hamster.ADD_EVENT](Hamster.PREFIX + eventName, handler, useCapture || false);

    // store original and normalised handlers on the instance
    hamster.handlers.push({
      original: originalHandler,
      normalised: handler
    });
  },

  /**
   * removeWheelListener
   * @param   {Instance}    hamster
   * @param   {String}      eventName
   * @param   {Function}    handler
   * @param   {Boolean}     useCapture
   */
  remove: function remove(hamster, eventName, handler, useCapture){
    // find the normalised handler on the instance
    var originalHandler = handler,
        lookup = {},
        handlers;
    for (var i = 0, len = hamster.handlers.length; i < len; ++i) {
      lookup[hamster.handlers[i].original] = hamster.handlers[i];
    }
    handlers = lookup[originalHandler];
    handler = handlers.normalised;

    // cross-browser removeEventListener
    hamster.element[Hamster.REMOVE_EVENT](Hamster.PREFIX + eventName, handler, useCapture || false);

    // remove original and normalised handlers from the instance
    for (var h in hamster.handlers) {
      if (hamster.handlers[h] == handlers) {
        hamster.handlers.splice(h, 1);
        break;
      }
    }
  }
};

/**
 * these hold the lowest deltas,
 * used to normalise the delta values
 * @type {Number}
 */
var lowestDelta,
    lowestDeltaXY;

Hamster.normalise = {
  /**
   * fix browser inconsistencies
   */
  browser: function normaliseBrowser(){
    // detect deprecated wheel events
    if (!('onwheel' in document || document.documentMode >= 9)) {
      Hamster.SUPPORT = document.onmousewheel !== undefined ?
                        'mousewheel' : // webkit and IE < 9 support at least "mousewheel"
                        'DOMMouseScroll'; // assume remaining browsers are older Firefox
    }

    // detect deprecated event model
    if (!window.addEventListener) {
      // assume IE < 9
      Hamster.ADD_EVENT = 'attachEvent';
      Hamster.REMOVE_EVENT = 'detachEvent';
      Hamster.PREFIX = 'on';
    }

  },

  /**
   * create a normalised event object
   * @param   {Function}    originalEvent
   * @returns {Object}      event
   */
   event: function normaliseEvent(originalEvent){
    var event = {
          // keep a reference to the original event object
          originalEvent: originalEvent,
          target: originalEvent.target || originalEvent.srcElement,
          type: 'wheel',
          deltaMode: originalEvent.type === 'MozMousePixelScroll' ? 0 : 1,
          deltaX: 0,
          deltaZ: 0,
          preventDefault: function(){
            if (originalEvent.preventDefault) {
              originalEvent.preventDefault();
            } else {
              originalEvent.returnValue = false;
            }
          },
          stopPropagation: function(){
            if (originalEvent.stopPropagation) {
              originalEvent.stopPropagation();
            } else {
              originalEvent.cancelBubble = false;
            }
          }
        };

    // calculate deltaY (and deltaX) according to the event

    // 'mousewheel'
    if (originalEvent.wheelDelta) {
      event.deltaY = - 1/40 * originalEvent.wheelDelta;
    }
    // webkit
    if (originalEvent.wheelDeltaX) {
      event.deltaX = - 1/40 * originalEvent.wheelDeltaX;
    }

    // 'DomMouseScroll'
    if (originalEvent.detail) {
      event.deltaY = originalEvent.detail;
    }

    return event;
  },

  /**
   * normalise 'deltas' of the mouse wheel
   * @param   {Function}    originalEvent
   * @returns {Array}       deltas
   */
  delta: function normaliseDelta(originalEvent){
    var delta = 0,
      deltaX = 0,
      deltaY = 0,
      absDelta = 0,
      absDeltaXY = 0,
      fn;

    // normalise deltas according to the event

    // 'wheel' event
    if (originalEvent.deltaY) {
      deltaY = originalEvent.deltaY * -1;
      delta  = deltaY;
    }
    if (originalEvent.deltaX) {
      deltaX = originalEvent.deltaX;
      delta  = deltaX * -1;
    }

    // 'mousewheel' event
    if (originalEvent.wheelDelta) {
      delta = originalEvent.wheelDelta;
    }
    // webkit
    if (originalEvent.wheelDeltaY) {
      deltaY = originalEvent.wheelDeltaY;
    }
    if (originalEvent.wheelDeltaX) {
      deltaX = originalEvent.wheelDeltaX * -1;
    }

    // 'DomMouseScroll' event
    if (originalEvent.detail) {
      delta = originalEvent.detail * -1;
    }

    // Don't return NaN
    if (delta === 0) {
      return [0, 0, 0];
    }

    // look for lowest delta to normalize the delta values
    absDelta = Math.abs(delta);
    if (!lowestDelta || absDelta < lowestDelta) {
      lowestDelta = absDelta;
    }
    absDeltaXY = Math.max(Math.abs(deltaY), Math.abs(deltaX));
    if (!lowestDeltaXY || absDeltaXY < lowestDeltaXY) {
      lowestDeltaXY = absDeltaXY;
    }

    // convert deltas to whole numbers
    fn = delta > 0 ? 'floor' : 'ceil';
    delta  = Math[fn](delta / lowestDelta);
    deltaX = Math[fn](deltaX / lowestDeltaXY);
    deltaY = Math[fn](deltaY / lowestDeltaXY);

    return [delta, deltaX, deltaY];
  }
};

if (typeof window.define === 'function' && window.define.amd) {
  // AMD
  window.define('hamster', [], function(){
    return Hamster;
  });
} else if (true) {
  // CommonJS
  module.exports = Hamster;
} else {}

})(window, window.document);


/***/ }),

/***/ 961:
/***/ ((module, exports, __nested_webpack_require_544513__) => {

var __WEBPACK_AMD_DEFINE_RESULT__;// Copyright (c) 2013 Pieroxy <pieroxy@pieroxy.net>
// This work is free. You can redistribute it and/or modify it
// under the terms of the WTFPL, Version 2
// For more information see LICENSE.txt or http://www.wtfpl.net/
//
// For more information, the home page:
// http://pieroxy.net/blog/pages/lz-string/testing.html
//
// LZ-based compression algorithm, version 1.4.4
var LZString = (function() {

// private property
var f = String.fromCharCode;
var keyStrBase64 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
var keyStrUriSafe = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+-$";
var baseReverseDic = {};

function getBaseValue(alphabet, character) {
  if (!baseReverseDic[alphabet]) {
    baseReverseDic[alphabet] = {};
    for (var i=0 ; i<alphabet.length ; i++) {
      baseReverseDic[alphabet][alphabet.charAt(i)] = i;
    }
  }
  return baseReverseDic[alphabet][character];
}

var LZString = {
  compressToBase64 : function (input) {
    if (input == null) return "";
    var res = LZString._compress(input, 6, function(a){return keyStrBase64.charAt(a);});
    switch (res.length % 4) { // To produce valid Base64
    default: // When could this happen ?
    case 0 : return res;
    case 1 : return res+"===";
    case 2 : return res+"==";
    case 3 : return res+"=";
    }
  },

  decompressFromBase64 : function (input) {
    if (input == null) return "";
    if (input == "") return null;
    return LZString._decompress(input.length, 32, function(index) { return getBaseValue(keyStrBase64, input.charAt(index)); });
  },

  compressToUTF16 : function (input) {
    if (input == null) return "";
    return LZString._compress(input, 15, function(a){return f(a+32);}) + " ";
  },

  decompressFromUTF16: function (compressed) {
    if (compressed == null) return "";
    if (compressed == "") return null;
    return LZString._decompress(compressed.length, 16384, function(index) { return compressed.charCodeAt(index) - 32; });
  },

  //compress into uint8array (UCS-2 big endian format)
  compressToUint8Array: function (uncompressed) {
    var compressed = LZString.compress(uncompressed);
    var buf=new Uint8Array(compressed.length*2); // 2 bytes per character

    for (var i=0, TotalLen=compressed.length; i<TotalLen; i++) {
      var current_value = compressed.charCodeAt(i);
      buf[i*2] = current_value >>> 8;
      buf[i*2+1] = current_value % 256;
    }
    return buf;
  },

  //decompress from uint8array (UCS-2 big endian format)
  decompressFromUint8Array:function (compressed) {
    if (compressed===null || compressed===undefined){
        return LZString.decompress(compressed);
    } else {
        var buf=new Array(compressed.length/2); // 2 bytes per character
        for (var i=0, TotalLen=buf.length; i<TotalLen; i++) {
          buf[i]=compressed[i*2]*256+compressed[i*2+1];
        }

        var result = [];
        buf.forEach(function (c) {
          result.push(f(c));
        });
        return LZString.decompress(result.join(''));

    }

  },


  //compress into a string that is already URI encoded
  compressToEncodedURIComponent: function (input) {
    if (input == null) return "";
    return LZString._compress(input, 6, function(a){return keyStrUriSafe.charAt(a);});
  },

  //decompress from an output of compressToEncodedURIComponent
  decompressFromEncodedURIComponent:function (input) {
    if (input == null) return "";
    if (input == "") return null;
    input = input.replace(/ /g, "+");
    return LZString._decompress(input.length, 32, function(index) { return getBaseValue(keyStrUriSafe, input.charAt(index)); });
  },

  compress: function (uncompressed) {
    return LZString._compress(uncompressed, 16, function(a){return f(a);});
  },
  _compress: function (uncompressed, bitsPerChar, getCharFromInt) {
    if (uncompressed == null) return "";
    var i, value,
        context_dictionary= {},
        context_dictionaryToCreate= {},
        context_c="",
        context_wc="",
        context_w="",
        context_enlargeIn= 2, // Compensate for the first entry which should not count
        context_dictSize= 3,
        context_numBits= 2,
        context_data=[],
        context_data_val=0,
        context_data_position=0,
        ii;

    for (ii = 0; ii < uncompressed.length; ii += 1) {
      context_c = uncompressed.charAt(ii);
      if (!Object.prototype.hasOwnProperty.call(context_dictionary,context_c)) {
        context_dictionary[context_c] = context_dictSize++;
        context_dictionaryToCreate[context_c] = true;
      }

      context_wc = context_w + context_c;
      if (Object.prototype.hasOwnProperty.call(context_dictionary,context_wc)) {
        context_w = context_wc;
      } else {
        if (Object.prototype.hasOwnProperty.call(context_dictionaryToCreate,context_w)) {
          if (context_w.charCodeAt(0)<256) {
            for (i=0 ; i<context_numBits ; i++) {
              context_data_val = (context_data_val << 1);
              if (context_data_position == bitsPerChar-1) {
                context_data_position = 0;
                context_data.push(getCharFromInt(context_data_val));
                context_data_val = 0;
              } else {
                context_data_position++;
              }
            }
            value = context_w.charCodeAt(0);
            for (i=0 ; i<8 ; i++) {
              context_data_val = (context_data_val << 1) | (value&1);
              if (context_data_position == bitsPerChar-1) {
                context_data_position = 0;
                context_data.push(getCharFromInt(context_data_val));
                context_data_val = 0;
              } else {
                context_data_position++;
              }
              value = value >> 1;
            }
          } else {
            value = 1;
            for (i=0 ; i<context_numBits ; i++) {
              context_data_val = (context_data_val << 1) | value;
              if (context_data_position ==bitsPerChar-1) {
                context_data_position = 0;
                context_data.push(getCharFromInt(context_data_val));
                context_data_val = 0;
              } else {
                context_data_position++;
              }
              value = 0;
            }
            value = context_w.charCodeAt(0);
            for (i=0 ; i<16 ; i++) {
              context_data_val = (context_data_val << 1) | (value&1);
              if (context_data_position == bitsPerChar-1) {
                context_data_position = 0;
                context_data.push(getCharFromInt(context_data_val));
                context_data_val = 0;
              } else {
                context_data_position++;
              }
              value = value >> 1;
            }
          }
          context_enlargeIn--;
          if (context_enlargeIn == 0) {
            context_enlargeIn = Math.pow(2, context_numBits);
            context_numBits++;
          }
          delete context_dictionaryToCreate[context_w];
        } else {
          value = context_dictionary[context_w];
          for (i=0 ; i<context_numBits ; i++) {
            context_data_val = (context_data_val << 1) | (value&1);
            if (context_data_position == bitsPerChar-1) {
              context_data_position = 0;
              context_data.push(getCharFromInt(context_data_val));
              context_data_val = 0;
            } else {
              context_data_position++;
            }
            value = value >> 1;
          }


        }
        context_enlargeIn--;
        if (context_enlargeIn == 0) {
          context_enlargeIn = Math.pow(2, context_numBits);
          context_numBits++;
        }
        // Add wc to the dictionary.
        context_dictionary[context_wc] = context_dictSize++;
        context_w = String(context_c);
      }
    }

    // Output the code for w.
    if (context_w !== "") {
      if (Object.prototype.hasOwnProperty.call(context_dictionaryToCreate,context_w)) {
        if (context_w.charCodeAt(0)<256) {
          for (i=0 ; i<context_numBits ; i++) {
            context_data_val = (context_data_val << 1);
            if (context_data_position == bitsPerChar-1) {
              context_data_position = 0;
              context_data.push(getCharFromInt(context_data_val));
              context_data_val = 0;
            } else {
              context_data_position++;
            }
          }
          value = context_w.charCodeAt(0);
          for (i=0 ; i<8 ; i++) {
            context_data_val = (context_data_val << 1) | (value&1);
            if (context_data_position == bitsPerChar-1) {
              context_data_position = 0;
              context_data.push(getCharFromInt(context_data_val));
              context_data_val = 0;
            } else {
              context_data_position++;
            }
            value = value >> 1;
          }
        } else {
          value = 1;
          for (i=0 ; i<context_numBits ; i++) {
            context_data_val = (context_data_val << 1) | value;
            if (context_data_position == bitsPerChar-1) {
              context_data_position = 0;
              context_data.push(getCharFromInt(context_data_val));
              context_data_val = 0;
            } else {
              context_data_position++;
            }
            value = 0;
          }
          value = context_w.charCodeAt(0);
          for (i=0 ; i<16 ; i++) {
            context_data_val = (context_data_val << 1) | (value&1);
            if (context_data_position == bitsPerChar-1) {
              context_data_position = 0;
              context_data.push(getCharFromInt(context_data_val));
              context_data_val = 0;
            } else {
              context_data_position++;
            }
            value = value >> 1;
          }
        }
        context_enlargeIn--;
        if (context_enlargeIn == 0) {
          context_enlargeIn = Math.pow(2, context_numBits);
          context_numBits++;
        }
        delete context_dictionaryToCreate[context_w];
      } else {
        value = context_dictionary[context_w];
        for (i=0 ; i<context_numBits ; i++) {
          context_data_val = (context_data_val << 1) | (value&1);
          if (context_data_position == bitsPerChar-1) {
            context_data_position = 0;
            context_data.push(getCharFromInt(context_data_val));
            context_data_val = 0;
          } else {
            context_data_position++;
          }
          value = value >> 1;
        }


      }
      context_enlargeIn--;
      if (context_enlargeIn == 0) {
        context_enlargeIn = Math.pow(2, context_numBits);
        context_numBits++;
      }
    }

    // Mark the end of the stream
    value = 2;
    for (i=0 ; i<context_numBits ; i++) {
      context_data_val = (context_data_val << 1) | (value&1);
      if (context_data_position == bitsPerChar-1) {
        context_data_position = 0;
        context_data.push(getCharFromInt(context_data_val));
        context_data_val = 0;
      } else {
        context_data_position++;
      }
      value = value >> 1;
    }

    // Flush the last char
    while (true) {
      context_data_val = (context_data_val << 1);
      if (context_data_position == bitsPerChar-1) {
        context_data.push(getCharFromInt(context_data_val));
        break;
      }
      else context_data_position++;
    }
    return context_data.join('');
  },

  decompress: function (compressed) {
    if (compressed == null) return "";
    if (compressed == "") return null;
    return LZString._decompress(compressed.length, 32768, function(index) { return compressed.charCodeAt(index); });
  },

  _decompress: function (length, resetValue, getNextValue) {
    var dictionary = [],
        next,
        enlargeIn = 4,
        dictSize = 4,
        numBits = 3,
        entry = "",
        result = [],
        i,
        w,
        bits, resb, maxpower, power,
        c,
        data = {val:getNextValue(0), position:resetValue, index:1};

    for (i = 0; i < 3; i += 1) {
      dictionary[i] = i;
    }

    bits = 0;
    maxpower = Math.pow(2,2);
    power=1;
    while (power!=maxpower) {
      resb = data.val & data.position;
      data.position >>= 1;
      if (data.position == 0) {
        data.position = resetValue;
        data.val = getNextValue(data.index++);
      }
      bits |= (resb>0 ? 1 : 0) * power;
      power <<= 1;
    }

    switch (next = bits) {
      case 0:
          bits = 0;
          maxpower = Math.pow(2,8);
          power=1;
          while (power!=maxpower) {
            resb = data.val & data.position;
            data.position >>= 1;
            if (data.position == 0) {
              data.position = resetValue;
              data.val = getNextValue(data.index++);
            }
            bits |= (resb>0 ? 1 : 0) * power;
            power <<= 1;
          }
        c = f(bits);
        break;
      case 1:
          bits = 0;
          maxpower = Math.pow(2,16);
          power=1;
          while (power!=maxpower) {
            resb = data.val & data.position;
            data.position >>= 1;
            if (data.position == 0) {
              data.position = resetValue;
              data.val = getNextValue(data.index++);
            }
            bits |= (resb>0 ? 1 : 0) * power;
            power <<= 1;
          }
        c = f(bits);
        break;
      case 2:
        return "";
    }
    dictionary[3] = c;
    w = c;
    result.push(c);
    while (true) {
      if (data.index > length) {
        return "";
      }

      bits = 0;
      maxpower = Math.pow(2,numBits);
      power=1;
      while (power!=maxpower) {
        resb = data.val & data.position;
        data.position >>= 1;
        if (data.position == 0) {
          data.position = resetValue;
          data.val = getNextValue(data.index++);
        }
        bits |= (resb>0 ? 1 : 0) * power;
        power <<= 1;
      }

      switch (c = bits) {
        case 0:
          bits = 0;
          maxpower = Math.pow(2,8);
          power=1;
          while (power!=maxpower) {
            resb = data.val & data.position;
            data.position >>= 1;
            if (data.position == 0) {
              data.position = resetValue;
              data.val = getNextValue(data.index++);
            }
            bits |= (resb>0 ? 1 : 0) * power;
            power <<= 1;
          }

          dictionary[dictSize++] = f(bits);
          c = dictSize-1;
          enlargeIn--;
          break;
        case 1:
          bits = 0;
          maxpower = Math.pow(2,16);
          power=1;
          while (power!=maxpower) {
            resb = data.val & data.position;
            data.position >>= 1;
            if (data.position == 0) {
              data.position = resetValue;
              data.val = getNextValue(data.index++);
            }
            bits |= (resb>0 ? 1 : 0) * power;
            power <<= 1;
          }
          dictionary[dictSize++] = f(bits);
          c = dictSize-1;
          enlargeIn--;
          break;
        case 2:
          return result.join('');
      }

      if (enlargeIn == 0) {
        enlargeIn = Math.pow(2, numBits);
        numBits++;
      }

      if (dictionary[c]) {
        entry = dictionary[c];
      } else {
        if (c === dictSize) {
          entry = w + w.charAt(0);
        } else {
          return null;
        }
      }
      result.push(entry);

      // Add w+entry[0] to the dictionary.
      dictionary[dictSize++] = w + entry.charAt(0);
      enlargeIn--;

      w = entry;

      if (enlargeIn == 0) {
        enlargeIn = Math.pow(2, numBits);
        numBits++;
      }

    }
  }
};
  return LZString;
})();

if (true) {
  !(__WEBPACK_AMD_DEFINE_RESULT__ = (function () { return LZString; }).call(exports, __nested_webpack_require_544513__, exports, module),
		__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
} else {}


/***/ }),

/***/ 666:
/***/ ((module) => {

/**
 * Copyright (c) 2014-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

var runtime = (function (exports) {
  "use strict";

  var Op = Object.prototype;
  var hasOwn = Op.hasOwnProperty;
  var undefined; // More compressible than void 0.
  var $Symbol = typeof Symbol === "function" ? Symbol : {};
  var iteratorSymbol = $Symbol.iterator || "@@iterator";
  var asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator";
  var toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag";

  function define(obj, key, value) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
    return obj[key];
  }
  try {
    // IE 8 has a broken Object.defineProperty that only works on DOM objects.
    define({}, "");
  } catch (err) {
    define = function(obj, key, value) {
      return obj[key] = value;
    };
  }

  function wrap(innerFn, outerFn, self, tryLocsList) {
    // If outerFn provided and outerFn.prototype is a Generator, then outerFn.prototype instanceof Generator.
    var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator;
    var generator = Object.create(protoGenerator.prototype);
    var context = new Context(tryLocsList || []);

    // The ._invoke method unifies the implementations of the .next,
    // .throw, and .return methods.
    generator._invoke = makeInvokeMethod(innerFn, self, context);

    return generator;
  }
  exports.wrap = wrap;

  // Try/catch helper to minimize deoptimizations. Returns a completion
  // record like context.tryEntries[i].completion. This interface could
  // have been (and was previously) designed to take a closure to be
  // invoked without arguments, but in all the cases we care about we
  // already have an existing method we want to call, so there's no need
  // to create a new function object. We can even get away with assuming
  // the method takes exactly one argument, since that happens to be true
  // in every case, so we don't have to touch the arguments object. The
  // only additional allocation required is the completion record, which
  // has a stable shape and so hopefully should be cheap to allocate.
  function tryCatch(fn, obj, arg) {
    try {
      return { type: "normal", arg: fn.call(obj, arg) };
    } catch (err) {
      return { type: "throw", arg: err };
    }
  }

  var GenStateSuspendedStart = "suspendedStart";
  var GenStateSuspendedYield = "suspendedYield";
  var GenStateExecuting = "executing";
  var GenStateCompleted = "completed";

  // Returning this object from the innerFn has the same effect as
  // breaking out of the dispatch switch statement.
  var ContinueSentinel = {};

  // Dummy constructor functions that we use as the .constructor and
  // .constructor.prototype properties for functions that return Generator
  // objects. For full spec compliance, you may wish to configure your
  // minifier not to mangle the names of these two functions.
  function Generator() {}
  function GeneratorFunction() {}
  function GeneratorFunctionPrototype() {}

  // This is a polyfill for %IteratorPrototype% for environments that
  // don't natively support it.
  var IteratorPrototype = {};
  IteratorPrototype[iteratorSymbol] = function () {
    return this;
  };

  var getProto = Object.getPrototypeOf;
  var NativeIteratorPrototype = getProto && getProto(getProto(values([])));
  if (NativeIteratorPrototype &&
      NativeIteratorPrototype !== Op &&
      hasOwn.call(NativeIteratorPrototype, iteratorSymbol)) {
    // This environment has a native %IteratorPrototype%; use it instead
    // of the polyfill.
    IteratorPrototype = NativeIteratorPrototype;
  }

  var Gp = GeneratorFunctionPrototype.prototype =
    Generator.prototype = Object.create(IteratorPrototype);
  GeneratorFunction.prototype = Gp.constructor = GeneratorFunctionPrototype;
  GeneratorFunctionPrototype.constructor = GeneratorFunction;
  GeneratorFunction.displayName = define(
    GeneratorFunctionPrototype,
    toStringTagSymbol,
    "GeneratorFunction"
  );

  // Helper for defining the .next, .throw, and .return methods of the
  // Iterator interface in terms of a single ._invoke method.
  function defineIteratorMethods(prototype) {
    ["next", "throw", "return"].forEach(function(method) {
      define(prototype, method, function(arg) {
        return this._invoke(method, arg);
      });
    });
  }

  exports.isGeneratorFunction = function(genFun) {
    var ctor = typeof genFun === "function" && genFun.constructor;
    return ctor
      ? ctor === GeneratorFunction ||
        // For the native GeneratorFunction constructor, the best we can
        // do is to check its .name property.
        (ctor.displayName || ctor.name) === "GeneratorFunction"
      : false;
  };

  exports.mark = function(genFun) {
    if (Object.setPrototypeOf) {
      Object.setPrototypeOf(genFun, GeneratorFunctionPrototype);
    } else {
      genFun.__proto__ = GeneratorFunctionPrototype;
      define(genFun, toStringTagSymbol, "GeneratorFunction");
    }
    genFun.prototype = Object.create(Gp);
    return genFun;
  };

  // Within the body of any async function, `await x` is transformed to
  // `yield regeneratorRuntime.awrap(x)`, so that the runtime can test
  // `hasOwn.call(value, "__await")` to determine if the yielded value is
  // meant to be awaited.
  exports.awrap = function(arg) {
    return { __await: arg };
  };

  function AsyncIterator(generator, PromiseImpl) {
    function invoke(method, arg, resolve, reject) {
      var record = tryCatch(generator[method], generator, arg);
      if (record.type === "throw") {
        reject(record.arg);
      } else {
        var result = record.arg;
        var value = result.value;
        if (value &&
            typeof value === "object" &&
            hasOwn.call(value, "__await")) {
          return PromiseImpl.resolve(value.__await).then(function(value) {
            invoke("next", value, resolve, reject);
          }, function(err) {
            invoke("throw", err, resolve, reject);
          });
        }

        return PromiseImpl.resolve(value).then(function(unwrapped) {
          // When a yielded Promise is resolved, its final value becomes
          // the .value of the Promise<{value,done}> result for the
          // current iteration.
          result.value = unwrapped;
          resolve(result);
        }, function(error) {
          // If a rejected Promise was yielded, throw the rejection back
          // into the async generator function so it can be handled there.
          return invoke("throw", error, resolve, reject);
        });
      }
    }

    var previousPromise;

    function enqueue(method, arg) {
      function callInvokeWithMethodAndArg() {
        return new PromiseImpl(function(resolve, reject) {
          invoke(method, arg, resolve, reject);
        });
      }

      return previousPromise =
        // If enqueue has been called before, then we want to wait until
        // all previous Promises have been resolved before calling invoke,
        // so that results are always delivered in the correct order. If
        // enqueue has not been called before, then it is important to
        // call invoke immediately, without waiting on a callback to fire,
        // so that the async generator function has the opportunity to do
        // any necessary setup in a predictable way. This predictability
        // is why the Promise constructor synchronously invokes its
        // executor callback, and why async functions synchronously
        // execute code before the first await. Since we implement simple
        // async functions in terms of async generators, it is especially
        // important to get this right, even though it requires care.
        previousPromise ? previousPromise.then(
          callInvokeWithMethodAndArg,
          // Avoid propagating failures to Promises returned by later
          // invocations of the iterator.
          callInvokeWithMethodAndArg
        ) : callInvokeWithMethodAndArg();
    }

    // Define the unified helper method that is used to implement .next,
    // .throw, and .return (see defineIteratorMethods).
    this._invoke = enqueue;
  }

  defineIteratorMethods(AsyncIterator.prototype);
  AsyncIterator.prototype[asyncIteratorSymbol] = function () {
    return this;
  };
  exports.AsyncIterator = AsyncIterator;

  // Note that simple async functions are implemented on top of
  // AsyncIterator objects; they just return a Promise for the value of
  // the final result produced by the iterator.
  exports.async = function(innerFn, outerFn, self, tryLocsList, PromiseImpl) {
    if (PromiseImpl === void 0) PromiseImpl = Promise;

    var iter = new AsyncIterator(
      wrap(innerFn, outerFn, self, tryLocsList),
      PromiseImpl
    );

    return exports.isGeneratorFunction(outerFn)
      ? iter // If outerFn is a generator, return the full iterator.
      : iter.next().then(function(result) {
          return result.done ? result.value : iter.next();
        });
  };

  function makeInvokeMethod(innerFn, self, context) {
    var state = GenStateSuspendedStart;

    return function invoke(method, arg) {
      if (state === GenStateExecuting) {
        throw new Error("Generator is already running");
      }

      if (state === GenStateCompleted) {
        if (method === "throw") {
          throw arg;
        }

        // Be forgiving, per 25.3.3.3.3 of the spec:
        // https://people.mozilla.org/~jorendorff/es6-draft.html#sec-generatorresume
        return doneResult();
      }

      context.method = method;
      context.arg = arg;

      while (true) {
        var delegate = context.delegate;
        if (delegate) {
          var delegateResult = maybeInvokeDelegate(delegate, context);
          if (delegateResult) {
            if (delegateResult === ContinueSentinel) continue;
            return delegateResult;
          }
        }

        if (context.method === "next") {
          // Setting context._sent for legacy support of Babel's
          // function.sent implementation.
          context.sent = context._sent = context.arg;

        } else if (context.method === "throw") {
          if (state === GenStateSuspendedStart) {
            state = GenStateCompleted;
            throw context.arg;
          }

          context.dispatchException(context.arg);

        } else if (context.method === "return") {
          context.abrupt("return", context.arg);
        }

        state = GenStateExecuting;

        var record = tryCatch(innerFn, self, context);
        if (record.type === "normal") {
          // If an exception is thrown from innerFn, we leave state ===
          // GenStateExecuting and loop back for another invocation.
          state = context.done
            ? GenStateCompleted
            : GenStateSuspendedYield;

          if (record.arg === ContinueSentinel) {
            continue;
          }

          return {
            value: record.arg,
            done: context.done
          };

        } else if (record.type === "throw") {
          state = GenStateCompleted;
          // Dispatch the exception by looping back around to the
          // context.dispatchException(context.arg) call above.
          context.method = "throw";
          context.arg = record.arg;
        }
      }
    };
  }

  // Call delegate.iterator[context.method](context.arg) and handle the
  // result, either by returning a { value, done } result from the
  // delegate iterator, or by modifying context.method and context.arg,
  // setting context.delegate to null, and returning the ContinueSentinel.
  function maybeInvokeDelegate(delegate, context) {
    var method = delegate.iterator[context.method];
    if (method === undefined) {
      // A .throw or .return when the delegate iterator has no .throw
      // method always terminates the yield* loop.
      context.delegate = null;

      if (context.method === "throw") {
        // Note: ["return"] must be used for ES3 parsing compatibility.
        if (delegate.iterator["return"]) {
          // If the delegate iterator has a return method, give it a
          // chance to clean up.
          context.method = "return";
          context.arg = undefined;
          maybeInvokeDelegate(delegate, context);

          if (context.method === "throw") {
            // If maybeInvokeDelegate(context) changed context.method from
            // "return" to "throw", let that override the TypeError below.
            return ContinueSentinel;
          }
        }

        context.method = "throw";
        context.arg = new TypeError(
          "The iterator does not provide a 'throw' method");
      }

      return ContinueSentinel;
    }

    var record = tryCatch(method, delegate.iterator, context.arg);

    if (record.type === "throw") {
      context.method = "throw";
      context.arg = record.arg;
      context.delegate = null;
      return ContinueSentinel;
    }

    var info = record.arg;

    if (! info) {
      context.method = "throw";
      context.arg = new TypeError("iterator result is not an object");
      context.delegate = null;
      return ContinueSentinel;
    }

    if (info.done) {
      // Assign the result of the finished delegate to the temporary
      // variable specified by delegate.resultName (see delegateYield).
      context[delegate.resultName] = info.value;

      // Resume execution at the desired location (see delegateYield).
      context.next = delegate.nextLoc;

      // If context.method was "throw" but the delegate handled the
      // exception, let the outer generator proceed normally. If
      // context.method was "next", forget context.arg since it has been
      // "consumed" by the delegate iterator. If context.method was
      // "return", allow the original .return call to continue in the
      // outer generator.
      if (context.method !== "return") {
        context.method = "next";
        context.arg = undefined;
      }

    } else {
      // Re-yield the result returned by the delegate method.
      return info;
    }

    // The delegate iterator is finished, so forget it and continue with
    // the outer generator.
    context.delegate = null;
    return ContinueSentinel;
  }

  // Define Generator.prototype.{next,throw,return} in terms of the
  // unified ._invoke helper method.
  defineIteratorMethods(Gp);

  define(Gp, toStringTagSymbol, "Generator");

  // A Generator should always return itself as the iterator object when the
  // @@iterator function is called on it. Some browsers' implementations of the
  // iterator prototype chain incorrectly implement this, causing the Generator
  // object to not be returned from this call. This ensures that doesn't happen.
  // See https://github.com/facebook/regenerator/issues/274 for more details.
  Gp[iteratorSymbol] = function() {
    return this;
  };

  Gp.toString = function() {
    return "[object Generator]";
  };

  function pushTryEntry(locs) {
    var entry = { tryLoc: locs[0] };

    if (1 in locs) {
      entry.catchLoc = locs[1];
    }

    if (2 in locs) {
      entry.finallyLoc = locs[2];
      entry.afterLoc = locs[3];
    }

    this.tryEntries.push(entry);
  }

  function resetTryEntry(entry) {
    var record = entry.completion || {};
    record.type = "normal";
    delete record.arg;
    entry.completion = record;
  }

  function Context(tryLocsList) {
    // The root entry object (effectively a try statement without a catch
    // or a finally block) gives us a place to store values thrown from
    // locations where there is no enclosing try statement.
    this.tryEntries = [{ tryLoc: "root" }];
    tryLocsList.forEach(pushTryEntry, this);
    this.reset(true);
  }

  exports.keys = function(object) {
    var keys = [];
    for (var key in object) {
      keys.push(key);
    }
    keys.reverse();

    // Rather than returning an object with a next method, we keep
    // things simple and return the next function itself.
    return function next() {
      while (keys.length) {
        var key = keys.pop();
        if (key in object) {
          next.value = key;
          next.done = false;
          return next;
        }
      }

      // To avoid creating an additional object, we just hang the .value
      // and .done properties off the next function object itself. This
      // also ensures that the minifier will not anonymize the function.
      next.done = true;
      return next;
    };
  };

  function values(iterable) {
    if (iterable) {
      var iteratorMethod = iterable[iteratorSymbol];
      if (iteratorMethod) {
        return iteratorMethod.call(iterable);
      }

      if (typeof iterable.next === "function") {
        return iterable;
      }

      if (!isNaN(iterable.length)) {
        var i = -1, next = function next() {
          while (++i < iterable.length) {
            if (hasOwn.call(iterable, i)) {
              next.value = iterable[i];
              next.done = false;
              return next;
            }
          }

          next.value = undefined;
          next.done = true;

          return next;
        };

        return next.next = next;
      }
    }

    // Return an iterator with no values.
    return { next: doneResult };
  }
  exports.values = values;

  function doneResult() {
    return { value: undefined, done: true };
  }

  Context.prototype = {
    constructor: Context,

    reset: function(skipTempReset) {
      this.prev = 0;
      this.next = 0;
      // Resetting context._sent for legacy support of Babel's
      // function.sent implementation.
      this.sent = this._sent = undefined;
      this.done = false;
      this.delegate = null;

      this.method = "next";
      this.arg = undefined;

      this.tryEntries.forEach(resetTryEntry);

      if (!skipTempReset) {
        for (var name in this) {
          // Not sure about the optimal order of these conditions:
          if (name.charAt(0) === "t" &&
              hasOwn.call(this, name) &&
              !isNaN(+name.slice(1))) {
            this[name] = undefined;
          }
        }
      }
    },

    stop: function() {
      this.done = true;

      var rootEntry = this.tryEntries[0];
      var rootRecord = rootEntry.completion;
      if (rootRecord.type === "throw") {
        throw rootRecord.arg;
      }

      return this.rval;
    },

    dispatchException: function(exception) {
      if (this.done) {
        throw exception;
      }

      var context = this;
      function handle(loc, caught) {
        record.type = "throw";
        record.arg = exception;
        context.next = loc;

        if (caught) {
          // If the dispatched exception was caught by a catch block,
          // then let that catch block handle the exception normally.
          context.method = "next";
          context.arg = undefined;
        }

        return !! caught;
      }

      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        var record = entry.completion;

        if (entry.tryLoc === "root") {
          // Exception thrown outside of any try block that could handle
          // it, so set the completion value of the entire function to
          // throw the exception.
          return handle("end");
        }

        if (entry.tryLoc <= this.prev) {
          var hasCatch = hasOwn.call(entry, "catchLoc");
          var hasFinally = hasOwn.call(entry, "finallyLoc");

          if (hasCatch && hasFinally) {
            if (this.prev < entry.catchLoc) {
              return handle(entry.catchLoc, true);
            } else if (this.prev < entry.finallyLoc) {
              return handle(entry.finallyLoc);
            }

          } else if (hasCatch) {
            if (this.prev < entry.catchLoc) {
              return handle(entry.catchLoc, true);
            }

          } else if (hasFinally) {
            if (this.prev < entry.finallyLoc) {
              return handle(entry.finallyLoc);
            }

          } else {
            throw new Error("try statement without catch or finally");
          }
        }
      }
    },

    abrupt: function(type, arg) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.tryLoc <= this.prev &&
            hasOwn.call(entry, "finallyLoc") &&
            this.prev < entry.finallyLoc) {
          var finallyEntry = entry;
          break;
        }
      }

      if (finallyEntry &&
          (type === "break" ||
           type === "continue") &&
          finallyEntry.tryLoc <= arg &&
          arg <= finallyEntry.finallyLoc) {
        // Ignore the finally entry if control is not jumping to a
        // location outside the try/catch block.
        finallyEntry = null;
      }

      var record = finallyEntry ? finallyEntry.completion : {};
      record.type = type;
      record.arg = arg;

      if (finallyEntry) {
        this.method = "next";
        this.next = finallyEntry.finallyLoc;
        return ContinueSentinel;
      }

      return this.complete(record);
    },

    complete: function(record, afterLoc) {
      if (record.type === "throw") {
        throw record.arg;
      }

      if (record.type === "break" ||
          record.type === "continue") {
        this.next = record.arg;
      } else if (record.type === "return") {
        this.rval = this.arg = record.arg;
        this.method = "return";
        this.next = "end";
      } else if (record.type === "normal" && afterLoc) {
        this.next = afterLoc;
      }

      return ContinueSentinel;
    },

    finish: function(finallyLoc) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.finallyLoc === finallyLoc) {
          this.complete(entry.completion, entry.afterLoc);
          resetTryEntry(entry);
          return ContinueSentinel;
        }
      }
    },

    "catch": function(tryLoc) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.tryLoc === tryLoc) {
          var record = entry.completion;
          if (record.type === "throw") {
            var thrown = record.arg;
            resetTryEntry(entry);
          }
          return thrown;
        }
      }

      // The context.catch method must only be called with a location
      // argument that corresponds to a known catch block.
      throw new Error("illegal catch attempt");
    },

    delegateYield: function(iterable, resultName, nextLoc) {
      this.delegate = {
        iterator: values(iterable),
        resultName: resultName,
        nextLoc: nextLoc
      };

      if (this.method === "next") {
        // Deliberately forget the last sent value so that we don't
        // accidentally pass it on to the delegate.
        this.arg = undefined;
      }

      return ContinueSentinel;
    }
  };

  // Regardless of whether this script is executing as a CommonJS module
  // or not, return the runtime object so that we can declare the variable
  // regeneratorRuntime in the outer scope, which allows this module to be
  // injected easily by `bin/regenerator --include-runtime script.js`.
  return exports;

}(
  // If this script is executing as a CommonJS module, use module.exports
  // as the regeneratorRuntime namespace. Otherwise create a new empty
  // object. Either way, the resulting object will be used to initialize
  // the regeneratorRuntime variable at the top of this file.
    true ? module.exports : 0
));

try {
  regeneratorRuntime = runtime;
} catch (accidentalStrictMode) {
  // This module should not be running in strict mode, so the above
  // assignment should always work unless something is misconfigured. Just
  // in case runtime.js accidentally runs in strict mode, we can escape
  // strict mode using a global Function call. This could conceivably fail
  // if a Content Security Policy forbids using Function, but in that case
  // the proper solution is to fix the accidental strict mode problem. If
  // you've misconfigured your bundler to force strict mode and applied a
  // CSP to forbid Function, and you're not willing to fix either of those
  // problems, please detail your unique predicament in a GitHub issue.
  Function("r", "regeneratorRuntime = r")(runtime);
}


/***/ }),

/***/ 863:
/***/ ((module, __unused_webpack_exports, __nested_webpack_require_585176__) => {

// style-loader: Adds some css to the DOM by adding a <style> tag

// load the styles
var content = __nested_webpack_require_585176__(418);
if(content.__esModule) content = content.default;
if(typeof content === 'string') content = [[module.id, content, '']];
if(content.locals) module.exports = content.locals;
// add the styles to the DOM
var add = __nested_webpack_require_585176__(346)/* .default */ .Z
var update = add("550b47ab", content, false, {});
// Hot Module Replacement
if(false) {}

/***/ }),

/***/ 124:
/***/ ((module, __unused_webpack_exports, __nested_webpack_require_585736__) => {

// style-loader: Adds some css to the DOM by adding a <style> tag

// load the styles
var content = __nested_webpack_require_585736__(976);
if(content.__esModule) content = content.default;
if(typeof content === 'string') content = [[module.id, content, '']];
if(content.locals) module.exports = content.locals;
// add the styles to the DOM
var add = __nested_webpack_require_585736__(346)/* .default */ .Z
var update = add("1b34bfeb", content, false, {});
// Hot Module Replacement
if(false) {}

/***/ }),

/***/ 886:
/***/ ((module, __unused_webpack_exports, __nested_webpack_require_586296__) => {

// style-loader: Adds some css to the DOM by adding a <style> tag

// load the styles
var content = __nested_webpack_require_586296__(449);
if(content.__esModule) content = content.default;
if(typeof content === 'string') content = [[module.id, content, '']];
if(content.locals) module.exports = content.locals;
// add the styles to the DOM
var add = __nested_webpack_require_586296__(346)/* .default */ .Z
var update = add("9895d3a6", content, false, {});
// Hot Module Replacement
if(false) {}

/***/ }),

/***/ 807:
/***/ ((module, __unused_webpack_exports, __nested_webpack_require_586856__) => {

// style-loader: Adds some css to the DOM by adding a <style> tag

// load the styles
var content = __nested_webpack_require_586856__(108);
if(content.__esModule) content = content.default;
if(typeof content === 'string') content = [[module.id, content, '']];
if(content.locals) module.exports = content.locals;
// add the styles to the DOM
var add = __nested_webpack_require_586856__(346)/* .default */ .Z
var update = add("8139036a", content, false, {});
// Hot Module Replacement
if(false) {}

/***/ }),

/***/ 600:
/***/ ((module, __unused_webpack_exports, __nested_webpack_require_587416__) => {

// style-loader: Adds some css to the DOM by adding a <style> tag

// load the styles
var content = __nested_webpack_require_587416__(988);
if(content.__esModule) content = content.default;
if(typeof content === 'string') content = [[module.id, content, '']];
if(content.locals) module.exports = content.locals;
// add the styles to the DOM
var add = __nested_webpack_require_587416__(346)/* .default */ .Z
var update = add("1db01c0b", content, false, {});
// Hot Module Replacement
if(false) {}

/***/ }),

/***/ 169:
/***/ ((module, __unused_webpack_exports, __nested_webpack_require_587976__) => {

// style-loader: Adds some css to the DOM by adding a <style> tag

// load the styles
var content = __nested_webpack_require_587976__(423);
if(content.__esModule) content = content.default;
if(typeof content === 'string') content = [[module.id, content, '']];
if(content.locals) module.exports = content.locals;
// add the styles to the DOM
var add = __nested_webpack_require_587976__(346)/* .default */ .Z
var update = add("68f243ea", content, false, {});
// Hot Module Replacement
if(false) {}

/***/ }),

/***/ 11:
/***/ ((module, __unused_webpack_exports, __nested_webpack_require_588535__) => {

// style-loader: Adds some css to the DOM by adding a <style> tag

// load the styles
var content = __nested_webpack_require_588535__(661);
if(content.__esModule) content = content.default;
if(typeof content === 'string') content = [[module.id, content, '']];
if(content.locals) module.exports = content.locals;
// add the styles to the DOM
var add = __nested_webpack_require_588535__(346)/* .default */ .Z
var update = add("12d2309d", content, false, {});
// Hot Module Replacement
if(false) {}

/***/ }),

/***/ 372:
/***/ ((module, __unused_webpack_exports, __nested_webpack_require_589095__) => {

// style-loader: Adds some css to the DOM by adding a <style> tag

// load the styles
var content = __nested_webpack_require_589095__(168);
if(content.__esModule) content = content.default;
if(typeof content === 'string') content = [[module.id, content, '']];
if(content.locals) module.exports = content.locals;
// add the styles to the DOM
var add = __nested_webpack_require_589095__(346)/* .default */ .Z
var update = add("5b620605", content, false, {});
// Hot Module Replacement
if(false) {}

/***/ }),

/***/ 477:
/***/ ((module, __unused_webpack_exports, __nested_webpack_require_589655__) => {

// style-loader: Adds some css to the DOM by adding a <style> tag

// load the styles
var content = __nested_webpack_require_589655__(29);
if(content.__esModule) content = content.default;
if(typeof content === 'string') content = [[module.id, content, '']];
if(content.locals) module.exports = content.locals;
// add the styles to the DOM
var add = __nested_webpack_require_589655__(346)/* .default */ .Z
var update = add("143dffab", content, false, {});
// Hot Module Replacement
if(false) {}

/***/ }),

/***/ 153:
/***/ ((module, __unused_webpack_exports, __nested_webpack_require_590214__) => {

// style-loader: Adds some css to the DOM by adding a <style> tag

// load the styles
var content = __nested_webpack_require_590214__(935);
if(content.__esModule) content = content.default;
if(typeof content === 'string') content = [[module.id, content, '']];
if(content.locals) module.exports = content.locals;
// add the styles to the DOM
var add = __nested_webpack_require_590214__(346)/* .default */ .Z
var update = add("f32fd36e", content, false, {});
// Hot Module Replacement
if(false) {}

/***/ }),

/***/ 501:
/***/ ((module, __unused_webpack_exports, __nested_webpack_require_590774__) => {

// style-loader: Adds some css to the DOM by adding a <style> tag

// load the styles
var content = __nested_webpack_require_590774__(379);
if(content.__esModule) content = content.default;
if(typeof content === 'string') content = [[module.id, content, '']];
if(content.locals) module.exports = content.locals;
// add the styles to the DOM
var add = __nested_webpack_require_590774__(346)/* .default */ .Z
var update = add("604bf5ef", content, false, {});
// Hot Module Replacement
if(false) {}

/***/ }),

/***/ 565:
/***/ ((module, __unused_webpack_exports, __nested_webpack_require_591334__) => {

// style-loader: Adds some css to the DOM by adding a <style> tag

// load the styles
var content = __nested_webpack_require_591334__(72);
if(content.__esModule) content = content.default;
if(typeof content === 'string') content = [[module.id, content, '']];
if(content.locals) module.exports = content.locals;
// add the styles to the DOM
var add = __nested_webpack_require_591334__(346)/* .default */ .Z
var update = add("21fde573", content, false, {});
// Hot Module Replacement
if(false) {}

/***/ }),

/***/ 5:
/***/ ((module, __unused_webpack_exports, __nested_webpack_require_591891__) => {

// style-loader: Adds some css to the DOM by adding a <style> tag

// load the styles
var content = __nested_webpack_require_591891__(983);
if(content.__esModule) content = content.default;
if(typeof content === 'string') content = [[module.id, content, '']];
if(content.locals) module.exports = content.locals;
// add the styles to the DOM
var add = __nested_webpack_require_591891__(346)/* .default */ .Z
var update = add("fd83689e", content, false, {});
// Hot Module Replacement
if(false) {}

/***/ }),

/***/ 346:
/***/ ((__unused_webpack_module, __webpack_exports__, __nested_webpack_require_592463__) => {

"use strict";

// EXPORTS
__nested_webpack_require_592463__.d(__webpack_exports__, {
  "Z": () => (/* binding */ addStylesClient)
});

;// CONCATENATED MODULE: ./node_modules/vue-style-loader/lib/listToStyles.js
/**
 * Translates the list format produced by css-loader into something
 * easier to manipulate.
 */
function listToStyles (parentId, list) {
  var styles = []
  var newStyles = {}
  for (var i = 0; i < list.length; i++) {
    var item = list[i]
    var id = item[0]
    var css = item[1]
    var media = item[2]
    var sourceMap = item[3]
    var part = {
      id: parentId + ':' + i,
      css: css,
      media: media,
      sourceMap: sourceMap
    }
    if (!newStyles[id]) {
      styles.push(newStyles[id] = { id: id, parts: [part] })
    } else {
      newStyles[id].parts.push(part)
    }
  }
  return styles
}

;// CONCATENATED MODULE: ./node_modules/vue-style-loader/lib/addStylesClient.js
/*
  MIT License http://www.opensource.org/licenses/mit-license.php
  Author Tobias Koppers @sokra
  Modified by Evan You @yyx990803
*/



var hasDocument = typeof document !== 'undefined'

if (typeof DEBUG !== 'undefined' && DEBUG) {
  if (!hasDocument) {
    throw new Error(
    'vue-style-loader cannot be used in a non-browser environment. ' +
    "Use { target: 'node' } in your Webpack config to indicate a server-rendering environment."
  ) }
}

/*
type StyleObject = {
  id: number;
  parts: Array<StyleObjectPart>
}

type StyleObjectPart = {
  css: string;
  media: string;
  sourceMap: ?string
}
*/

var stylesInDom = {/*
  [id: number]: {
    id: number,
    refs: number,
    parts: Array<(obj?: StyleObjectPart) => void>
  }
*/}

var head = hasDocument && (document.head || document.getElementsByTagName('head')[0])
var singletonElement = null
var singletonCounter = 0
var isProduction = false
var noop = function () {}
var options = null
var ssrIdKey = 'data-vue-ssr-id'

// Force single-tag solution on IE6-9, which has a hard limit on the # of <style>
// tags it will allow on a page
var isOldIE = typeof navigator !== 'undefined' && /msie [6-9]\b/.test(navigator.userAgent.toLowerCase())

function addStylesClient (parentId, list, _isProduction, _options) {
  isProduction = _isProduction

  options = _options || {}

  var styles = listToStyles(parentId, list)
  addStylesToDom(styles)

  return function update (newList) {
    var mayRemove = []
    for (var i = 0; i < styles.length; i++) {
      var item = styles[i]
      var domStyle = stylesInDom[item.id]
      domStyle.refs--
      mayRemove.push(domStyle)
    }
    if (newList) {
      styles = listToStyles(parentId, newList)
      addStylesToDom(styles)
    } else {
      styles = []
    }
    for (var i = 0; i < mayRemove.length; i++) {
      var domStyle = mayRemove[i]
      if (domStyle.refs === 0) {
        for (var j = 0; j < domStyle.parts.length; j++) {
          domStyle.parts[j]()
        }
        delete stylesInDom[domStyle.id]
      }
    }
  }
}

function addStylesToDom (styles /* Array<StyleObject> */) {
  for (var i = 0; i < styles.length; i++) {
    var item = styles[i]
    var domStyle = stylesInDom[item.id]
    if (domStyle) {
      domStyle.refs++
      for (var j = 0; j < domStyle.parts.length; j++) {
        domStyle.parts[j](item.parts[j])
      }
      for (; j < item.parts.length; j++) {
        domStyle.parts.push(addStyle(item.parts[j]))
      }
      if (domStyle.parts.length > item.parts.length) {
        domStyle.parts.length = item.parts.length
      }
    } else {
      var parts = []
      for (var j = 0; j < item.parts.length; j++) {
        parts.push(addStyle(item.parts[j]))
      }
      stylesInDom[item.id] = { id: item.id, refs: 1, parts: parts }
    }
  }
}

function createStyleElement () {
  var styleElement = document.createElement('style')
  styleElement.type = 'text/css'
  head.appendChild(styleElement)
  return styleElement
}

function addStyle (obj /* StyleObjectPart */) {
  var update, remove
  var styleElement = document.querySelector('style[' + ssrIdKey + '~="' + obj.id + '"]')

  if (styleElement) {
    if (isProduction) {
      // has SSR styles and in production mode.
      // simply do nothing.
      return noop
    } else {
      // has SSR styles but in dev mode.
      // for some reason Chrome can't handle source map in server-rendered
      // style tags - source maps in <style> only works if the style tag is
      // created and inserted dynamically. So we remove the server rendered
      // styles and inject new ones.
      styleElement.parentNode.removeChild(styleElement)
    }
  }

  if (isOldIE) {
    // use singleton mode for IE9.
    var styleIndex = singletonCounter++
    styleElement = singletonElement || (singletonElement = createStyleElement())
    update = applyToSingletonTag.bind(null, styleElement, styleIndex, false)
    remove = applyToSingletonTag.bind(null, styleElement, styleIndex, true)
  } else {
    // use multi-style-tag mode in all other cases
    styleElement = createStyleElement()
    update = applyToTag.bind(null, styleElement)
    remove = function () {
      styleElement.parentNode.removeChild(styleElement)
    }
  }

  update(obj)

  return function updateStyle (newObj /* StyleObjectPart */) {
    if (newObj) {
      if (newObj.css === obj.css &&
          newObj.media === obj.media &&
          newObj.sourceMap === obj.sourceMap) {
        return
      }
      update(obj = newObj)
    } else {
      remove()
    }
  }
}

var replaceText = (function () {
  var textStore = []

  return function (index, replacement) {
    textStore[index] = replacement
    return textStore.filter(Boolean).join('\n')
  }
})()

function applyToSingletonTag (styleElement, index, remove, obj) {
  var css = remove ? '' : obj.css

  if (styleElement.styleSheet) {
    styleElement.styleSheet.cssText = replaceText(index, css)
  } else {
    var cssNode = document.createTextNode(css)
    var childNodes = styleElement.childNodes
    if (childNodes[index]) styleElement.removeChild(childNodes[index])
    if (childNodes.length) {
      styleElement.insertBefore(cssNode, childNodes[index])
    } else {
      styleElement.appendChild(cssNode)
    }
  }
}

function applyToTag (styleElement, obj) {
  var css = obj.css
  var media = obj.media
  var sourceMap = obj.sourceMap

  if (media) {
    styleElement.setAttribute('media', media)
  }
  if (options.ssrId) {
    styleElement.setAttribute(ssrIdKey, obj.id)
  }

  if (sourceMap) {
    // https://developer.chrome.com/devtools/docs/javascript-debugging
    // this makes source maps inside style tags work properly in Chrome
    css += '\n/*# sourceURL=' + sourceMap.sources[0] + ' */'
    // http://stackoverflow.com/a/26603875
    css += '\n/*# sourceMappingURL=data:application/json;base64,' + btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap)))) + ' */'
  }

  if (styleElement.styleSheet) {
    styleElement.styleSheet.cssText = css
  } else {
    while (styleElement.firstChild) {
      styleElement.removeChild(styleElement.firstChild)
    }
    styleElement.appendChild(document.createTextNode(css))
  }
}


/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __nested_webpack_require_599798__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		if(__webpack_module_cache__[moduleId]) {
/******/ 			return __webpack_module_cache__[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			id: moduleId,
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __nested_webpack_require_599798__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/compat get default export */
/******/ 	(() => {
/******/ 		// getDefaultExport function for compatibility with non-harmony modules
/******/ 		__nested_webpack_require_599798__.n = (module) => {
/******/ 			var getter = module && module.__esModule ?
/******/ 				() => (module['default']) :
/******/ 				() => (module);
/******/ 			__nested_webpack_require_599798__.d(getter, { a: getter });
/******/ 			return getter;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__nested_webpack_require_599798__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__nested_webpack_require_599798__.o(definition, key) && !__nested_webpack_require_599798__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__nested_webpack_require_599798__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__nested_webpack_require_599798__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module doesn't tell about it's top-level declarations so it can't be inlined
/******/ 	var __webpack_exports__ = __nested_webpack_require_599798__(851);
/******/ 	
/******/ 	return __webpack_exports__;
/******/ })()
;
});
//# sourceMappingURL=trading-vue.js.map

/***/ }),

/***/ "./node_modules/tvjs-overlays/dist/tvjs-overlays.js":
/*!**********************************************************!*\
  !*** ./node_modules/tvjs-overlays/dist/tvjs-overlays.js ***!
  \**********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/*!
 * TVJS Overlays - v0.5.0 - Fri Jul 09 2021
 *     https://github.com/tvjsx/trading-vue-js
 *     Copyright (c) 2020 c451 Code's All Right;
 *     Licensed under the MIT license
 */
(function webpackUniversalModuleDefinition(root, factory) {
    if (!root['trading-vue-js']) {
        root['trading-vue-js'] = root['TradingVueJs']
    }
	if(true)
		module.exports = factory(__webpack_require__(/*! trading-vue-js */ "./node_modules/trading-vue-js/dist/trading-vue.js"));
	else {}
})(self, function(__WEBPACK_EXTERNAL_MODULE__954__) {
return /******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ 954:
/***/ ((module) => {

module.exports = __WEBPACK_EXTERNAL_MODULE__954__;

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __nested_webpack_require_1194__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __nested_webpack_require_1194__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__nested_webpack_require_1194__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__nested_webpack_require_1194__.o(definition, key) && !__nested_webpack_require_1194__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__nested_webpack_require_1194__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__nested_webpack_require_1194__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
var __webpack_exports__ = {};
// This entry need to be wrapped in an IIFE because it need to be isolated against other modules in the chunk.
(() => {
// ESM COMPAT FLAG
__nested_webpack_require_1194__.r(__webpack_exports__);

// EXPORTS
__nested_webpack_require_1194__.d(__webpack_exports__, {
  "ALMA": () => (/* reexport */ ALMA),
  "ATR": () => (/* reexport */ ATR),
  "ATRp": () => (/* reexport */ ATRp),
  "Area51": () => (/* reexport */ Area51),
  "BB": () => (/* reexport */ BB),
  "BBW": () => (/* reexport */ BBW),
  "CCI": () => (/* reexport */ CCI),
  "CMO": () => (/* reexport */ CMO),
  "COG": () => (/* reexport */ COG),
  "DHistogram": () => (/* reexport */ DHistogram),
  "DMI": () => (/* reexport */ DMI),
  "EMA": () => (/* reexport */ EMA),
  "HMA": () => (/* reexport */ HMA),
  "Histogram": () => (/* reexport */ Histogram),
  "Ichi": () => (/* reexport */ Ichi),
  "Ichimoku": () => (/* reexport */ Ichimoku),
  "KC": () => (/* reexport */ KC),
  "KCW": () => (/* reexport */ KCW),
  "LongShortTrades": () => (/* reexport */ LongShortTrades),
  "MACD": () => (/* reexport */ MACD),
  "MFI": () => (/* reexport */ MFI),
  "MOM": () => (/* reexport */ MOM),
  "Markers": () => (/* reexport */ Markers),
  "PlotCross": () => (/* reexport */ PlotCross),
  "ROC": () => (/* reexport */ ROC),
  "RSI": () => (/* reexport */ RSI),
  "Ribbon": () => (/* reexport */ Ribbon),
  "SAR": () => (/* reexport */ SAR),
  "SMA": () => (/* reexport */ SMA),
  "SWMA": () => (/* reexport */ SWMA),
  "Stoch": () => (/* reexport */ Stoch),
  "TSI": () => (/* reexport */ TSI),
  "TradesPlus": () => (/* reexport */ TradesPlus),
  "VWMA": () => (/* reexport */ VWMA),
  "WilliamsR": () => (/* reexport */ WilliamsR),
  "XOhlcBars": () => (/* reexport */ XOhlcBars),
  "default": () => (/* binding */ index_prod)
});

// EXTERNAL MODULE: external "trading-vue-js"
var external_trading_vue_js_ = __nested_webpack_require_1194__(954);
;// CONCATENATED MODULE: ./node_modules/babel-loader/lib/index.js!./node_modules/vue-loader/lib/index.js??vue-loader-options!./src/overlays/ALMA/ALMA.vue?vue&type=script&lang=js&

/* harmony default export */ const ALMAvue_type_script_lang_js_ = ({
  name: 'ALMA',
  mixins: [external_trading_vue_js_.Overlay],
  methods: {
    meta_info: function meta_info() {
      return {
        author: 'StdSquad',
        version: '1.0.0',
        desc: 'Arnaud Legoux Moving Average',
        preset: {
          name: 'ALMA $length $offset $sigma',
          side: 'onchart',
          settings: {
            lineWidth: 0.75,
            color: '#559de0'
          }
        }
      };
    },
    use_for: function use_for() {
      return ['ALMA'];
    },
    calc: function calc() {
      return {
        props: {
          length: {
            def: 10,
            text: 'Length'
          },
          offset: {
            def: 0.9,
            text: 'Offset'
          },
          sigma: {
            def: 5,
            text: 'Sigma'
          }
        },
        conf: {
          renderer: 'Spline'
        },
        update: "\n                    return alma(close, length, offset, sigma)[0]\n                "
      };
    }
  }
});
;// CONCATENATED MODULE: ./src/overlays/ALMA/ALMA.vue?vue&type=script&lang=js&
 /* harmony default export */ const ALMA_ALMAvue_type_script_lang_js_ = (ALMAvue_type_script_lang_js_); 
;// CONCATENATED MODULE: ./node_modules/vue-loader/lib/runtime/componentNormalizer.js
/* globals __VUE_SSR_CONTEXT__ */

// IMPORTANT: Do NOT use ES2015 features in this file (except for modules).
// This module is a runtime utility for cleaner component module output and will
// be included in the final webpack user bundle.

function normalizeComponent (
  scriptExports,
  render,
  staticRenderFns,
  functionalTemplate,
  injectStyles,
  scopeId,
  moduleIdentifier, /* server only */
  shadowMode /* vue-cli only */
) {
  // Vue.extend constructor export interop
  var options = typeof scriptExports === 'function'
    ? scriptExports.options
    : scriptExports

  // render functions
  if (render) {
    options.render = render
    options.staticRenderFns = staticRenderFns
    options._compiled = true
  }

  // functional template
  if (functionalTemplate) {
    options.functional = true
  }

  // scopedId
  if (scopeId) {
    options._scopeId = 'data-v-' + scopeId
  }

  var hook
  if (moduleIdentifier) { // server build
    hook = function (context) {
      // 2.3 injection
      context =
        context || // cached call
        (this.$vnode && this.$vnode.ssrContext) || // stateful
        (this.parent && this.parent.$vnode && this.parent.$vnode.ssrContext) // functional
      // 2.2 with runInNewContext: true
      if (!context && typeof __VUE_SSR_CONTEXT__ !== 'undefined') {
        context = __VUE_SSR_CONTEXT__
      }
      // inject component styles
      if (injectStyles) {
        injectStyles.call(this, context)
      }
      // register component module identifier for async chunk inferrence
      if (context && context._registeredComponents) {
        context._registeredComponents.add(moduleIdentifier)
      }
    }
    // used by ssr in case component is cached and beforeCreate
    // never gets called
    options._ssrRegister = hook
  } else if (injectStyles) {
    hook = shadowMode
      ? function () {
        injectStyles.call(
          this,
          (options.functional ? this.parent : this).$root.$options.shadowRoot
        )
      }
      : injectStyles
  }

  if (hook) {
    if (options.functional) {
      // for template-only hot-reload because in that case the render fn doesn't
      // go through the normalizer
      options._injectStyles = hook
      // register for functional component in vue file
      var originalRender = options.render
      options.render = function renderWithStyleInjection (h, context) {
        hook.call(context)
        return originalRender(h, context)
      }
    } else {
      // inject component registration as beforeCreate hook
      var existing = options.beforeCreate
      options.beforeCreate = existing
        ? [].concat(existing, hook)
        : [hook]
    }
  }

  return {
    exports: scriptExports,
    options: options
  }
}

;// CONCATENATED MODULE: ./src/overlays/ALMA/ALMA.vue
var render, staticRenderFns
;



/* normalize component */
;
var component = normalizeComponent(
  ALMA_ALMAvue_type_script_lang_js_,
  render,
  staticRenderFns,
  false,
  null,
  null,
  null
  
)

/* hot reload */
if (false) { var api; }
component.options.__file = "src/overlays/ALMA/ALMA.vue"
/* harmony default export */ const ALMA = (component.exports);
;// CONCATENATED MODULE: ./node_modules/babel-loader/lib/index.js!./node_modules/vue-loader/lib/index.js??vue-loader-options!./src/overlays/ATR/ATR.vue?vue&type=script&lang=js&

/* harmony default export */ const ATRvue_type_script_lang_js_ = ({
  name: 'ATR',
  mixins: [external_trading_vue_js_.Overlay],
  methods: {
    meta_info: function meta_info() {
      return {
        author: 'StdSquad',
        version: '1.0.0',
        desc: 'Average True Range',
        preset: {
          name: 'ATR $length',
          side: 'offchart',
          settings: {
            lineWidth: 0.75,
            color: '#e52468'
          }
        }
      };
    },
    use_for: function use_for() {
      return ['ATR'];
    },
    calc: function calc() {
      return {
        props: {
          length: {
            def: 15,
            text: 'Length'
          }
        },
        conf: {
          renderer: 'Spline'
        },
        update: "\n                    return atr(length)[0]\n                "
      };
    }
  }
});
;// CONCATENATED MODULE: ./src/overlays/ATR/ATR.vue?vue&type=script&lang=js&
 /* harmony default export */ const ATR_ATRvue_type_script_lang_js_ = (ATRvue_type_script_lang_js_); 
;// CONCATENATED MODULE: ./src/overlays/ATR/ATR.vue
var ATR_render, ATR_staticRenderFns
;



/* normalize component */
;
var ATR_component = normalizeComponent(
  ATR_ATRvue_type_script_lang_js_,
  ATR_render,
  ATR_staticRenderFns,
  false,
  null,
  null,
  null
  
)

/* hot reload */
if (false) { var ATR_api; }
ATR_component.options.__file = "src/overlays/ATR/ATR.vue"
/* harmony default export */ const ATR = (ATR_component.exports);
;// CONCATENATED MODULE: ./node_modules/babel-loader/lib/index.js!./node_modules/vue-loader/lib/index.js??vue-loader-options!./src/overlays/ATRp/ATRp.vue?vue&type=script&lang=js&

/* harmony default export */ const ATRpvue_type_script_lang_js_ = ({
  name: 'ATRp',
  mixins: [external_trading_vue_js_.Overlay],
  methods: {
    meta_info: function meta_info() {
      return {
        author: 'StdSquad',
        version: '1.0.0',
        desc: 'Average True Range, %',
        preset: {
          name: 'ATR% $length',
          side: 'offchart',
          settings: {
            lineWidth: 0.75,
            color: '#f44336'
          }
        }
      };
    },
    use_for: function use_for() {
      return ['ATRp'];
    },
    calc: function calc() {
      return {
        props: {
          length: {
            def: 15,
            text: 'Length'
          }
        },
        conf: {
          renderer: 'Spline'
        },
        update: "\n                    return 100 * atr(length)[0] / close[0]\n                "
      };
    }
  }
});
;// CONCATENATED MODULE: ./src/overlays/ATRp/ATRp.vue?vue&type=script&lang=js&
 /* harmony default export */ const ATRp_ATRpvue_type_script_lang_js_ = (ATRpvue_type_script_lang_js_); 
;// CONCATENATED MODULE: ./src/overlays/ATRp/ATRp.vue
var ATRp_render, ATRp_staticRenderFns
;



/* normalize component */
;
var ATRp_component = normalizeComponent(
  ATRp_ATRpvue_type_script_lang_js_,
  ATRp_render,
  ATRp_staticRenderFns,
  false,
  null,
  null,
  null
  
)

/* hot reload */
if (false) { var ATRp_api; }
ATRp_component.options.__file = "src/overlays/ATRp/ATRp.vue"
/* harmony default export */ const ATRp = (ATRp_component.exports);
;// CONCATENATED MODULE: ./node_modules/babel-loader/lib/index.js!./node_modules/vue-loader/lib/index.js??vue-loader-options!./src/overlays/Area51/Area51.vue?vue&type=script&lang=js&
function _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it["return"] != null) it["return"](); } finally { if (didErr) throw err; } } }; }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }


/* harmony default export */ const Area51vue_type_script_lang_js_ = ({
  name: 'Area51',
  mixins: [external_trading_vue_js_.Overlay],
  methods: {
    meta_info: function meta_info() {
      return {
        author: '',
        version: '1.0.0',
        desc: 'Gradient area chart'
      };
    },
    draw: function draw(ctx) {
      var layout = this.$props.layout;
      var data = this.$props.data;
      var grd = ctx.createLinearGradient(0, 0, 0, layout.height);
      grd.addColorStop(0, this.back1);
      grd.addColorStop(1, this.back2); // Line

      ctx.lineWidth = this.line_width;
      ctx.strokeStyle = this.color;
      ctx.beginPath();

      var _iterator = _createForOfIteratorHelper(data),
          _step;

      try {
        for (_iterator.s(); !(_step = _iterator.n()).done;) {
          var p = _step.value;
          var x = layout.t2screen(p[0]);
          var y = layout.$2screen(p[1]);
          ctx.lineTo(x, y);
        }
      } catch (err) {
        _iterator.e(err);
      } finally {
        _iterator.f();
      }

      ctx.stroke(); // Area

      ctx.fillStyle = grd;
      ctx.beginPath();
      var p0 = (data[0] || [])[0];
      var pN = (data[data.length - 1] || [])[0];
      ctx.lineTo(layout.t2screen(p0), layout.height);

      var _iterator2 = _createForOfIteratorHelper(data),
          _step2;

      try {
        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
          var p = _step2.value;

          var _x = layout.t2screen(p[0]);

          var _y = layout.$2screen(p[1]);

          ctx.lineTo(_x, _y);
        }
      } catch (err) {
        _iterator2.e(err);
      } finally {
        _iterator2.f();
      }

      ctx.lineTo(layout.t2screen(pN), layout.height);
      ctx.fill();
    },
    use_for: function use_for() {
      return ['Area51'];
    },
    data_colors: function data_colors() {
      return [this.color];
    }
  },
  // Define internal setting & constants here
  computed: {
    sett: function sett() {
      return this.$props.settings;
    },
    line_width: function line_width() {
      return this.sett.lineWidth || 1.25;
    },
    color: function color() {
      return this.sett.color || '#2fd68f';
    },
    back1: function back1() {
      return this.sett.back1 || this.color + '15';
    },
    back2: function back2() {
      return this.sett.back2 || this.color + '01';
    }
  },
  data: function data() {
    return {};
  }
});
;// CONCATENATED MODULE: ./src/overlays/Area51/Area51.vue?vue&type=script&lang=js&
 /* harmony default export */ const Area51_Area51vue_type_script_lang_js_ = (Area51vue_type_script_lang_js_); 
;// CONCATENATED MODULE: ./src/overlays/Area51/Area51.vue
var Area51_render, Area51_staticRenderFns
;



/* normalize component */
;
var Area51_component = normalizeComponent(
  Area51_Area51vue_type_script_lang_js_,
  Area51_render,
  Area51_staticRenderFns,
  false,
  null,
  null,
  null
  
)

/* hot reload */
if (false) { var Area51_api; }
Area51_component.options.__file = "src/overlays/Area51/Area51.vue"
/* harmony default export */ const Area51 = (Area51_component.exports);
;// CONCATENATED MODULE: ./node_modules/babel-loader/lib/index.js!./node_modules/vue-loader/lib/index.js??vue-loader-options!./src/overlays/BB/BB.vue?vue&type=script&lang=js&

/* harmony default export */ const BBvue_type_script_lang_js_ = ({
  name: 'BB',
  mixins: [external_trading_vue_js_.Overlay],
  methods: {
    meta_info: function meta_info() {
      return {
        author: 'StdSquad',
        version: '1.0.0',
        desc: 'Bollinger Bands',
        preset: {
          name: 'BB $length $stddev',
          side: 'onchart',
          settings: {
            lineWidth: 0.75,
            color: '#2cc6c9ab',
            showMid: true,
            backColor: '#2cc6c90a'
          }
        }
      };
    },
    use_for: function use_for() {
      return ['BB'];
    },
    calc: function calc() {
      return {
        props: {
          length: {
            def: 21,
            text: 'Length'
          },
          stddev: {
            def: 2,
            text: 'StdDev'
          }
        },
        conf: {
          renderer: 'Channel'
        },
        update: "\n                    let [m, h, l] = bb(close, length, stddev)\n                    return [h[0], m[0], l[0]]\n                "
      };
    }
  }
});
;// CONCATENATED MODULE: ./src/overlays/BB/BB.vue?vue&type=script&lang=js&
 /* harmony default export */ const BB_BBvue_type_script_lang_js_ = (BBvue_type_script_lang_js_); 
;// CONCATENATED MODULE: ./src/overlays/BB/BB.vue
var BB_render, BB_staticRenderFns
;



/* normalize component */
;
var BB_component = normalizeComponent(
  BB_BBvue_type_script_lang_js_,
  BB_render,
  BB_staticRenderFns,
  false,
  null,
  null,
  null
  
)

/* hot reload */
if (false) { var BB_api; }
BB_component.options.__file = "src/overlays/BB/BB.vue"
/* harmony default export */ const BB = (BB_component.exports);
;// CONCATENATED MODULE: ./node_modules/babel-loader/lib/index.js!./node_modules/vue-loader/lib/index.js??vue-loader-options!./src/overlays/BBW/BBW.vue?vue&type=script&lang=js&

/* harmony default export */ const BBWvue_type_script_lang_js_ = ({
  name: 'BBW',
  mixins: [external_trading_vue_js_.Overlay],
  methods: {
    meta_info: function meta_info() {
      return {
        author: 'StdSquad',
        version: '1.0.0',
        desc: 'Bollinger Bands Width',
        preset: {
          name: 'BBW $length $stddev',
          side: 'offchart',
          settings: {
            lineWidth: 0.75,
            color: '#2cc6c9ab'
          }
        }
      };
    },
    use_for: function use_for() {
      return ['BBW'];
    },
    calc: function calc() {
      return {
        props: {
          length: {
            def: 21,
            text: 'Length'
          },
          stddev: {
            def: 2,
            text: 'StdDev'
          }
        },
        conf: {
          renderer: 'Spline'
        },
        update: "\n                    return bbw(close, length, stddev)[0]\n                "
      };
    }
  }
});
;// CONCATENATED MODULE: ./src/overlays/BBW/BBW.vue?vue&type=script&lang=js&
 /* harmony default export */ const BBW_BBWvue_type_script_lang_js_ = (BBWvue_type_script_lang_js_); 
;// CONCATENATED MODULE: ./src/overlays/BBW/BBW.vue
var BBW_render, BBW_staticRenderFns
;



/* normalize component */
;
var BBW_component = normalizeComponent(
  BBW_BBWvue_type_script_lang_js_,
  BBW_render,
  BBW_staticRenderFns,
  false,
  null,
  null,
  null
  
)

/* hot reload */
if (false) { var BBW_api; }
BBW_component.options.__file = "src/overlays/BBW/BBW.vue"
/* harmony default export */ const BBW = (BBW_component.exports);
;// CONCATENATED MODULE: ./node_modules/babel-loader/lib/index.js!./node_modules/vue-loader/lib/index.js??vue-loader-options!./src/overlays/CCI/CCI.vue?vue&type=script&lang=js&

/* harmony default export */ const CCIvue_type_script_lang_js_ = ({
  name: 'CCI',
  mixins: [external_trading_vue_js_.Overlay],
  methods: {
    meta_info: function meta_info() {
      return {
        author: 'StdSquad',
        version: '1.0.0',
        desc: 'Commodity Channel Index',
        preset: {
          name: 'CCI $length',
          side: 'offchart',
          settings: {
            lineWidth: 0.75,
            color: '#e28a3dee',
            backColor: '#e28a3d11',
            bandColor: '#aaaaaa',
            upper: 100,
            lower: -100
          }
        }
      };
    },
    use_for: function use_for() {
      return ['CCI'];
    },
    calc: function calc() {
      return {
        props: {
          length: {
            def: 21,
            text: 'Length'
          }
        },
        conf: {
          renderer: 'Range'
        },
        update: "return cci(close, length)[0]"
      };
    }
  }
});
;// CONCATENATED MODULE: ./src/overlays/CCI/CCI.vue?vue&type=script&lang=js&
 /* harmony default export */ const CCI_CCIvue_type_script_lang_js_ = (CCIvue_type_script_lang_js_); 
;// CONCATENATED MODULE: ./src/overlays/CCI/CCI.vue
var CCI_render, CCI_staticRenderFns
;



/* normalize component */
;
var CCI_component = normalizeComponent(
  CCI_CCIvue_type_script_lang_js_,
  CCI_render,
  CCI_staticRenderFns,
  false,
  null,
  null,
  null
  
)

/* hot reload */
if (false) { var CCI_api; }
CCI_component.options.__file = "src/overlays/CCI/CCI.vue"
/* harmony default export */ const CCI = (CCI_component.exports);
;// CONCATENATED MODULE: ./node_modules/babel-loader/lib/index.js!./node_modules/vue-loader/lib/index.js??vue-loader-options!./src/overlays/CMO/CMO.vue?vue&type=script&lang=js&

/* harmony default export */ const CMOvue_type_script_lang_js_ = ({
  name: 'CMO',
  mixins: [external_trading_vue_js_.Overlay],
  methods: {
    meta_info: function meta_info() {
      return {
        author: 'StdSquad',
        version: '1.0.0',
        desc: 'Chande Momentum Oscillator',
        preset: {
          name: 'CMO $length',
          side: 'offchart',
          settings: {
            lineWidth: 0.75,
            color: '#559de0'
          }
        }
      };
    },
    use_for: function use_for() {
      return ['CMO'];
    },
    calc: function calc() {
      return {
        props: {
          length: {
            def: 10,
            text: 'Length'
          }
        },
        conf: {
          renderer: 'Spline'
        },
        update: "return cmo(close, length)[0]"
      };
    }
  }
});
;// CONCATENATED MODULE: ./src/overlays/CMO/CMO.vue?vue&type=script&lang=js&
 /* harmony default export */ const CMO_CMOvue_type_script_lang_js_ = (CMOvue_type_script_lang_js_); 
;// CONCATENATED MODULE: ./src/overlays/CMO/CMO.vue
var CMO_render, CMO_staticRenderFns
;



/* normalize component */
;
var CMO_component = normalizeComponent(
  CMO_CMOvue_type_script_lang_js_,
  CMO_render,
  CMO_staticRenderFns,
  false,
  null,
  null,
  null
  
)

/* hot reload */
if (false) { var CMO_api; }
CMO_component.options.__file = "src/overlays/CMO/CMO.vue"
/* harmony default export */ const CMO = (CMO_component.exports);
;// CONCATENATED MODULE: ./node_modules/babel-loader/lib/index.js!./node_modules/vue-loader/lib/index.js??vue-loader-options!./src/overlays/COG/COG.vue?vue&type=script&lang=js&

/* harmony default export */ const COGvue_type_script_lang_js_ = ({
  name: 'COG',
  mixins: [external_trading_vue_js_.Overlay],
  methods: {
    meta_info: function meta_info() {
      return {
        author: 'StdSquad',
        version: '1.0.0',
        desc: 'Center of Gravity',
        preset: {
          name: 'COG $length',
          side: 'offchart',
          settings: {
            lineWidth: 0.75,
            color: '#559de0'
          }
        }
      };
    },
    use_for: function use_for() {
      return ['COG'];
    },
    calc: function calc() {
      return {
        props: {
          length: {
            def: 10,
            text: 'Length'
          }
        },
        conf: {
          renderer: 'Spline'
        },
        update: "return cog(close, length)[0]"
      };
    }
  }
});
;// CONCATENATED MODULE: ./src/overlays/COG/COG.vue?vue&type=script&lang=js&
 /* harmony default export */ const COG_COGvue_type_script_lang_js_ = (COGvue_type_script_lang_js_); 
;// CONCATENATED MODULE: ./src/overlays/COG/COG.vue
var COG_render, COG_staticRenderFns
;



/* normalize component */
;
var COG_component = normalizeComponent(
  COG_COGvue_type_script_lang_js_,
  COG_render,
  COG_staticRenderFns,
  false,
  null,
  null,
  null
  
)

/* hot reload */
if (false) { var COG_api; }
COG_component.options.__file = "src/overlays/COG/COG.vue"
/* harmony default export */ const COG = (COG_component.exports);
;// CONCATENATED MODULE: ./node_modules/babel-loader/lib/index.js!./node_modules/vue-loader/lib/index.js??vue-loader-options!./src/overlays/DHistogram/DHistogram.vue?vue&type=script&lang=js&
function DHistogramvue_type_script_lang_js_createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = DHistogramvue_type_script_lang_js_unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it["return"] != null) it["return"](); } finally { if (didErr) throw err; } } }; }

function DHistogramvue_type_script_lang_js_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return DHistogramvue_type_script_lang_js_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return DHistogramvue_type_script_lang_js_arrayLikeToArray(o, minLen); }

function DHistogramvue_type_script_lang_js_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }


/* harmony default export */ const DHistogramvue_type_script_lang_js_ = ({
  name: "DHistogram",
  mixins: [external_trading_vue_js_.Overlay],
  methods: {
    meta_info: function meta_info() {
      return {
        author: "Acid3croco",
        version: "1.0.0",
        desc: "Double Histogram Plot",
        preset: {
          name: "DHistogram",
          side: "offchart",
          settings: {
            histWidth: 4,
            thresholdSize: 0,
            posColor: "#35a776",
            negColor: "#e54150"
          }
        }
      };
    },
    draw: function draw(ctx) {
      ctx.lineWidth = this.hist_width;
      ctx.strokeStyle = this.color;
      var layout = this.$props.layout;
      var base = layout.$2screen(0) + 0.5;
      var off = this.hist_width % 2 ? 0 : 0.5; // Color changed

      var changed = false;

      var _iterator = DHistogramvue_type_script_lang_js_createForOfIteratorHelper(this.$props.data),
          _step;

      try {
        for (_iterator.s(); !(_step = _iterator.n()).done;) {
          var p = _step.value;
          var pos_value = p[1];
          var neg_value = p[2];
          var x = layout.t2screen(p[0]) - off;
          var y1 = layout.$2screen(pos_value) - 0.5;
          var y2 = layout.$2screen(neg_value) - 0.5;

          if (pos_value > this.threshold_size) {
            ctx.strokeStyle = this.pos_color;
            ctx.beginPath();
            ctx.moveTo(x, base);
            ctx.lineTo(x, y1);
            ctx.stroke();
          }

          if (neg_value < -this.threshold_size) {
            ctx.strokeStyle = this.neg_color;
            ctx.beginPath();
            ctx.moveTo(x, base);
            ctx.lineTo(x, y2);
            ctx.stroke();
          }
        }
      } catch (err) {
        _iterator.e(err);
      } finally {
        _iterator.f();
      }
    },
    use_for: function use_for() {
      return ["DHistogram"];
    },
    legend: function legend(values) {
      var xs = values.slice(1, 3).map(function (x) {
        return x.toFixed(Math.abs(x) > 0.001 ? 4 : 8);
      });
      return [{
        value: xs[0],
        color: this.pos_color
      }, {
        value: xs[1],
        color: this.neg_color
      }];
    }
  },
  // Define internal setting & constants here
  computed: {
    sett: function sett() {
      return this.$props.settings;
    },
    hist_width: function hist_width() {
      return this.sett.histWidth || 4;
    },
    threshold_size: function threshold_size() {
      return this.sett.thresholdSize || 0;
    },
    pos_color: function pos_color() {
      return this.sett.posColor || "#35a776";
    },
    neg_color: function neg_color() {
      return this.sett.negColor || "#e54150";
    }
  },
  data: function data() {
    return {};
  }
});
;// CONCATENATED MODULE: ./src/overlays/DHistogram/DHistogram.vue?vue&type=script&lang=js&
 /* harmony default export */ const DHistogram_DHistogramvue_type_script_lang_js_ = (DHistogramvue_type_script_lang_js_); 
;// CONCATENATED MODULE: ./src/overlays/DHistogram/DHistogram.vue
var DHistogram_render, DHistogram_staticRenderFns
;



/* normalize component */
;
var DHistogram_component = normalizeComponent(
  DHistogram_DHistogramvue_type_script_lang_js_,
  DHistogram_render,
  DHistogram_staticRenderFns,
  false,
  null,
  null,
  null
  
)

/* hot reload */
if (false) { var DHistogram_api; }
DHistogram_component.options.__file = "src/overlays/DHistogram/DHistogram.vue"
/* harmony default export */ const DHistogram = (DHistogram_component.exports);
;// CONCATENATED MODULE: ./node_modules/babel-loader/lib/index.js!./node_modules/vue-loader/lib/index.js??vue-loader-options!./src/overlays/DMI/DMI.vue?vue&type=script&lang=js&

/* harmony default export */ const DMIvue_type_script_lang_js_ = ({
  name: 'DMI',
  mixins: [external_trading_vue_js_.Overlay],
  methods: {
    meta_info: function meta_info() {
      return {
        author: 'StdSquad',
        version: '1.0.0',
        desc: 'Directional Movement Index',
        preset: {
          name: 'DMI $length $smooth',
          side: 'offchart',
          settings: {
            lineWidth: 0.75,
            colors: ["#ef1360", "#3782f2", "#f48709"]
          }
        }
      };
    },
    use_for: function use_for() {
      return ['DMI'];
    },
    calc: function calc() {
      return {
        props: {
          length: {
            def: 15,
            text: 'DI Length'
          },
          smooth: {
            def: 15,
            text: 'ADX Smothing'
          }
        },
        conf: {
          renderer: 'Splines'
        },
        update: "\n                    let [adx, dp, dn] = dmi(length, smooth)\n                    return [adx[0], dp[0], dn[0]]\n                "
      };
    }
  }
});
;// CONCATENATED MODULE: ./src/overlays/DMI/DMI.vue?vue&type=script&lang=js&
 /* harmony default export */ const DMI_DMIvue_type_script_lang_js_ = (DMIvue_type_script_lang_js_); 
;// CONCATENATED MODULE: ./src/overlays/DMI/DMI.vue
var DMI_render, DMI_staticRenderFns
;



/* normalize component */
;
var DMI_component = normalizeComponent(
  DMI_DMIvue_type_script_lang_js_,
  DMI_render,
  DMI_staticRenderFns,
  false,
  null,
  null,
  null
  
)

/* hot reload */
if (false) { var DMI_api; }
DMI_component.options.__file = "src/overlays/DMI/DMI.vue"
/* harmony default export */ const DMI = (DMI_component.exports);
;// CONCATENATED MODULE: ./node_modules/babel-loader/lib/index.js!./node_modules/vue-loader/lib/index.js??vue-loader-options!./src/overlays/EMA/EMA.vue?vue&type=script&lang=js&

/* harmony default export */ const EMAvue_type_script_lang_js_ = ({
  name: 'EMA',
  mixins: [external_trading_vue_js_.Overlay],
  methods: {
    meta_info: function meta_info() {
      return {
        author: 'StdSquad',
        version: '1.0.0',
        desc: 'Exponential Moving Average',
        preset: {
          name: 'EMA $length',
          side: 'onchart',
          settings: {
            lineWidth: 0.75,
            color: '#f7890c'
          }
        }
      };
    },
    use_for: function use_for() {
      return ['EMA'];
    },
    calc: function calc() {
      return {
        props: {
          length: {
            def: 12,
            text: 'Length'
          }
        },
        conf: {
          renderer: 'Spline'
        },
        update: "\n                    return ema(close, length)[0]\n                "
      };
    }
  }
});
;// CONCATENATED MODULE: ./src/overlays/EMA/EMA.vue?vue&type=script&lang=js&
 /* harmony default export */ const EMA_EMAvue_type_script_lang_js_ = (EMAvue_type_script_lang_js_); 
;// CONCATENATED MODULE: ./src/overlays/EMA/EMA.vue
var EMA_render, EMA_staticRenderFns
;



/* normalize component */
;
var EMA_component = normalizeComponent(
  EMA_EMAvue_type_script_lang_js_,
  EMA_render,
  EMA_staticRenderFns,
  false,
  null,
  null,
  null
  
)

/* hot reload */
if (false) { var EMA_api; }
EMA_component.options.__file = "src/overlays/EMA/EMA.vue"
/* harmony default export */ const EMA = (EMA_component.exports);
;// CONCATENATED MODULE: ./node_modules/babel-loader/lib/index.js!./node_modules/vue-loader/lib/index.js??vue-loader-options!./src/overlays/HMA/HMA.vue?vue&type=script&lang=js&

/* harmony default export */ const HMAvue_type_script_lang_js_ = ({
  name: 'HMA',
  mixins: [external_trading_vue_js_.Overlay],
  methods: {
    meta_info: function meta_info() {
      return {
        author: 'StdSquad',
        version: '1.0.0',
        desc: 'Hull Moving Average',
        preset: {
          name: 'HMA $length',
          side: 'onchart',
          settings: {
            lineWidth: 0.75,
            color: '#3af475'
          }
        }
      };
    },
    use_for: function use_for() {
      return ['HMA'];
    },
    calc: function calc() {
      return {
        props: {
          length: {
            def: 10,
            text: 'Length'
          }
        },
        conf: {
          renderer: 'Spline'
        },
        update: "\n                    return hma(close, length)[0]\n                "
      };
    }
  }
});
;// CONCATENATED MODULE: ./src/overlays/HMA/HMA.vue?vue&type=script&lang=js&
 /* harmony default export */ const HMA_HMAvue_type_script_lang_js_ = (HMAvue_type_script_lang_js_); 
;// CONCATENATED MODULE: ./src/overlays/HMA/HMA.vue
var HMA_render, HMA_staticRenderFns
;



/* normalize component */
;
var HMA_component = normalizeComponent(
  HMA_HMAvue_type_script_lang_js_,
  HMA_render,
  HMA_staticRenderFns,
  false,
  null,
  null,
  null
  
)

/* hot reload */
if (false) { var HMA_api; }
HMA_component.options.__file = "src/overlays/HMA/HMA.vue"
/* harmony default export */ const HMA = (HMA_component.exports);
;// CONCATENATED MODULE: ./node_modules/babel-loader/lib/index.js!./node_modules/vue-loader/lib/index.js??vue-loader-options!./src/overlays/Histogram/Histogram.vue?vue&type=script&lang=js&
function Histogramvue_type_script_lang_js_createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = Histogramvue_type_script_lang_js_unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it["return"] != null) it["return"](); } finally { if (didErr) throw err; } } }; }

function Histogramvue_type_script_lang_js_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return Histogramvue_type_script_lang_js_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return Histogramvue_type_script_lang_js_arrayLikeToArray(o, minLen); }

function Histogramvue_type_script_lang_js_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }


/* harmony default export */ const Histogramvue_type_script_lang_js_ = ({
  name: 'Histogram',
  mixins: [external_trading_vue_js_.Overlay],
  methods: {
    meta_info: function meta_info() {
      return {
        author: 'StdSquad',
        version: '1.0.0',
        desc: 'Histogram plot'
      };
    },
    draw: function draw(ctx) {
      ctx.lineWidth = this.line_width;
      ctx.strokeStyle = this.color;
      ctx.beginPath();
      var layout = this.$props.layout;
      var base = layout.$2screen(0) + 0.5;
      var off = this.line_width % 2 ? 0 : 0.5; // Color changed

      var changed = false;

      var _iterator = Histogramvue_type_script_lang_js_createForOfIteratorHelper(this.$props.data),
          _step;

      try {
        for (_iterator.s(); !(_step = _iterator.n()).done;) {
          var p = _step.value;
          var x = layout.t2screen(p[0]) - off;
          var y = layout.$2screen(p[1]) - 0.5;
          var _changed = false;

          if (p[2]) {
            if (ctx.strokeStyle !== p[2]) {
              ctx.stroke();
              _changed = true;
            }

            ctx.strokeStyle = p[2];
          } else {
            if (ctx.strokeStyle !== this.color) {
              ctx.stroke();
              _changed = true;
            }

            ctx.strokeStyle = this.color;
          }

          if (_changed) ctx.beginPath();
          ctx.moveTo(x, base);
          ctx.lineTo(x, y);
        }
      } catch (err) {
        _iterator.e(err);
      } finally {
        _iterator.f();
      }

      ctx.stroke();
    },
    use_for: function use_for() {
      return ['Histogram'];
    },
    legend: function legend(values) {
      var x = values[1];

      if (typeof x === "number") {
        x = x.toFixed(Math.abs(x) > 0.001 ? 4 : 8);
      }

      return [{
        value: x,
        color: values[2] || this.color
      }];
    }
  },
  // Define internal setting & constants here
  computed: {
    sett: function sett() {
      return this.$props.settings;
    },
    line_width: function line_width() {
      return this.sett.lineWidth || 2;
    },
    color: function color() {
      var n = this.$props.num % 5;
      return this.sett.color || this.COLORS[n];
    }
  },
  data: function data() {
    return {
      COLORS: ['#888888', '#42b28a', '#5691ce', '#612ff9', '#d50b90', '#ff2316']
    };
  }
});
;// CONCATENATED MODULE: ./src/overlays/Histogram/Histogram.vue?vue&type=script&lang=js&
 /* harmony default export */ const Histogram_Histogramvue_type_script_lang_js_ = (Histogramvue_type_script_lang_js_); 
;// CONCATENATED MODULE: ./src/overlays/Histogram/Histogram.vue
var Histogram_render, Histogram_staticRenderFns
;



/* normalize component */
;
var Histogram_component = normalizeComponent(
  Histogram_Histogramvue_type_script_lang_js_,
  Histogram_render,
  Histogram_staticRenderFns,
  false,
  null,
  null,
  null
  
)

/* hot reload */
if (false) { var Histogram_api; }
Histogram_component.options.__file = "src/overlays/Histogram/Histogram.vue"
/* harmony default export */ const Histogram = (Histogram_component.exports);
;// CONCATENATED MODULE: ./node_modules/babel-loader/lib/index.js!./node_modules/vue-loader/lib/index.js??vue-loader-options!./src/overlays/Ichi/Ichi.vue?vue&type=script&lang=js&
// Cloud renderer. (Ichimoku)

/* harmony default export */ const Ichivue_type_script_lang_js_ = ({
  name: 'Ichi',
  mixins: [external_trading_vue_js_.Overlay],
  methods: {
    meta_info: function meta_info() {
      return {
        author: 'C451',
        version: '1.0.0',
        desc: 'Ichimoku Cloud based on scripts'
      };
    },
    draw: function draw(ctx) {
      ctx.lineWidth = this.line_width;

      for (var i = 0; i < this.$props.data.length - 1; i++) {
        var p1 = this.mapp(this.$props.data[i]);
        var p2 = this.mapp(this.$props.data[i + 1]);
        if (!p2) continue;
        if (p1.y1 !== p1.y1) continue; // Fix NaN
        // Background

        ctx.beginPath();
        ctx.fillStyle = p1.y1 < p1.y2 ? this.back1 : this.back2;
        ctx.moveTo(p1.x, p1.y1);
        ctx.lineTo(p2.x + 0.1, p2.y1);
        ctx.lineTo(p2.x + 0.1, p2.y2);
        ctx.lineTo(p1.x, p1.y2);
        ctx.fill(); // Lines

        if (!this.draw_lines) continue;
        ctx.beginPath();
        ctx.strokeStyle = this.color1;
        ctx.moveTo(p1.x, p1.y1);
        ctx.lineTo(p2.x, p2.y1);
        ctx.stroke();
        ctx.beginPath();
        ctx.strokeStyle = this.color2;
        ctx.moveTo(p1.x, p1.y2);
        ctx.lineTo(p2.x, p2.y2);
        ctx.stroke();
      }
    },
    mapp: function mapp(p) {
      var layout = this.$props.layout;
      return p && {
        x: layout.t2screen(p[0]),
        y1: layout.$2screen(p[1]),
        y2: layout.$2screen(p[2])
      };
    },
    use_for: function use_for() {
      return ['Ichi'];
    },
    data_colors: function data_colors() {
      return [this.color1, this.color2];
    },
    calc: function calc() {
      return {
        props: {
          CP: {
            def: 9,
            text: 'Conversion Line Length'
          },
          BP: {
            def: 26,
            text: 'Base Line Length'
          },
          LSP: {
            def: 52,
            text: 'Lagging Span 2 Length'
          },
          DIZ: {
            def: 26,
            text: 'Displacement'
          },
          baseColor: {
            def: 'brown',
            text: 'Base Line Color'
          },
          conversionColor: {
            def: 'lightblue',
            text: 'Conversion Line Color'
          },
          laggingColor: {
            def: '#66CC66',
            text: 'Lagging Span Color'
          }
        },
        update: "\n                    let donchian = (len, id) => ts(\n                        avg(lowest(low, len)[0], highest(high, len)[0]), id\n                    )\n                    let conversionLine = donchian(CP, 1)\n                    let baseLine = donchian(BP, 2)\n                    let leadLine1 = ts(avg(conversionLine[0], baseLine[0]))\n                    let leadLine2 = donchian(LSP, 3)\n                    let lagging = ts(close[0])\n\n\n                    offset(this, DIZ - 1)\n                    offset(lagging, -DIZ + 1)\n                    onchart([conversionLine, baseLine], 'Base Lines', {\n                        colors: [conversionColor, baseColor]\n                    })\n                    onchart(lagging, 'Lagging Span', {\n                        color: laggingColor\n                    })\n                    return [leadLine1[0], leadLine2[0]]\n                "
      };
    }
  },
  // Define internal setting & constants here
  computed: {
    sett: function sett() {
      return this.$props.settings;
    },
    line_width: function line_width() {
      return this.sett.lineWidth || 0.75;
    },
    color1: function color1() {
      return this.sett.color1 || 'lightgreen';
    },
    color2: function color2() {
      return this.sett.color2 || 'orange';
    },
    back1: function back1() {
      return this.sett.back1 || '#79ff9e22';
    },
    back2: function back2() {
      return this.sett.back2 || '#ef535022';
    },
    draw_lines: function draw_lines() {
      return this.sett.drawLines;
    }
  },
  data: function data() {
    return {
      COLORS: ['#42b28a', '#5691ce', '#612ff9', '#d50b90', '#ff2316']
    };
  }
});
;// CONCATENATED MODULE: ./src/overlays/Ichi/Ichi.vue?vue&type=script&lang=js&
 /* harmony default export */ const Ichi_Ichivue_type_script_lang_js_ = (Ichivue_type_script_lang_js_); 
;// CONCATENATED MODULE: ./src/overlays/Ichi/Ichi.vue
var Ichi_render, Ichi_staticRenderFns
;



/* normalize component */
;
var Ichi_component = normalizeComponent(
  Ichi_Ichivue_type_script_lang_js_,
  Ichi_render,
  Ichi_staticRenderFns,
  false,
  null,
  null,
  null
  
)

/* hot reload */
if (false) { var Ichi_api; }
Ichi_component.options.__file = "src/overlays/Ichi/Ichi.vue"
/* harmony default export */ const Ichi = (Ichi_component.exports);
;// CONCATENATED MODULE: ./node_modules/babel-loader/lib/index.js!./node_modules/vue-loader/lib/index.js??vue-loader-options!./src/overlays/Ichimoku/Ichimoku.vue?vue&type=script&lang=js&
function Ichimokuvue_type_script_lang_js_createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = Ichimokuvue_type_script_lang_js_unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it["return"] != null) it["return"](); } finally { if (didErr) throw err; } } }; }

function Ichimokuvue_type_script_lang_js_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return Ichimokuvue_type_script_lang_js_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return Ichimokuvue_type_script_lang_js_arrayLikeToArray(o, minLen); }

function Ichimokuvue_type_script_lang_js_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

//Ichimoku Indicator Overlay. Expected Format: [ <timestamp>, <ConversionLine>, <BaseLine>, <Lead1>, <Lead2>, <Lagging> ]

/* harmony default export */ const Ichimokuvue_type_script_lang_js_ = ({
  name: "Ichimoku",
  mixins: [external_trading_vue_js_.Overlay],
  data: function data() {
    return {
      ctxTenkan: {},
      ctxKijun: {},
      ctxSenkouSpanA: {},
      ctxSenkouSpanB: {},
      ctxChinkou: {},
      ctxFillKumo: {},
      tenkan: [],
      kijun: [],
      senkouSpanA: [],
      senkouSpanB: [],
      chinkou: [],
      offset: 26,
      tenkanLineWidth: 1,
      kijunLineWidth: 1,
      senkouSpanALineWidth: 1,
      senkouSpanBLineWidth: 1,
      chinkouLineWidth: 1,
      colorTenkan: "#52A634",
      colorKijun: "#52A59D",
      colorSenkouSpanA: "#438625",
      colorSenkouSpanB: "#bd003c",
      colorChinkou: "#BF2A64",
      colorKumoUp: "#063f0f",
      colorKumoDown: "#391c19",
      showTenkan: true,
      showKijun: true,
      showSenkouSpanA: true,
      showSenkouSpanB: true,
      showChinkou: true,
      showFillKumo: true
    };
  },
  computed: {
    sett: function sett() {
      return this.$props.settings;
    },
    tenkan_color: function tenkan_color() {
      return this.sett['tenkan-color'] || this.colorTenkan;
    },
    kijun_color: function kijun_color() {
      return this.sett['kijun-color'] || this.colorKijun;
    },
    senkou_spanA_color: function senkou_spanA_color() {
      return this.sett['senkou_spanA_color'] || this.colorSenkouSpanA;
    },
    senkou_spanB_color: function senkou_spanB_color() {
      return this.sett['senkou_spanB_color'] || this.colorSenkouSpanB;
    },
    chinkou_color: function chinkou_color() {
      return this.sett['chinkou_color'] || this.colorChinkou;
    },
    kumo_up_color: function kumo_up_color() {
      return this.sett['kumo_up_color'] || this.colorKumoUp;
    },
    kumo_down_color: function kumo_down_color() {
      return this.sett['kumo_down_color'] || this.colorKumoDown;
    },
    tenkan_line_width: function tenkan_line_width() {
      return this.sett['tenkan_line_width'] || this.tenkanLineWidth;
    },
    kijun_line_width: function kijun_line_width() {
      return this.sett['kijun_line_width'] || this.kijunLineWidth;
    },
    senkou_spanA_line_width: function senkou_spanA_line_width() {
      return this.sett['senkou_spanA_line_width'] || this.senkouSpanALineWidth;
    },
    senkou_spanB_line_width: function senkou_spanB_line_width() {
      return this.sett['senkou_spanB_line_width'] || this.senkouSpanBLineWidth;
    },
    chinkou_line_width: function chinkou_line_width() {
      return this.sett['chinkou_line_width'] || this.chinkouLineWidth;
    }
  },
  methods: {
    meta_info: function meta_info() {
      return {
        author: "Sudeep Batra",
        version: "1.0.0"
      };
    },
    draw: function draw(ctx) {
      var layout = this.$props.layout;
      var propsSub = this.$props.sub;
      this.ctxTenkan = ctx;
      this.ctxKijun = ctx;
      this.ctxSenkouSpanA = ctx;
      this.ctxSenkouSpanB = ctx;
      this.ctxChinkou = ctx;
      this.ctxFillKumo = ctx;
      var subdata = this.$props.data.slice(0, propsSub.length);
      var subdataSenkouSpan = this.$props.data.slice(0, propsSub.length + this.offset);
      var subdataChinkou = this.$props.data.slice(0, propsSub.length - this.offset);

      if (this.showFillKumo) {
        this.ctxFillKumo.beginPath();
        var ind = 0;

        var _iterator = Ichimokuvue_type_script_lang_js_createForOfIteratorHelper(subdataSenkouSpan),
            _step;

        try {
          for (_iterator.s(); !(_step = _iterator.n()).done;) {
            var currItem = _step.value;

            if (ind > 1) {
              var p1 = this.map_senkou_span_values(subdataSenkouSpan[ind - 1]);
              var p2 = this.map_senkou_span_values(currItem);
              this.ctxSenkouSpanB.beginPath();
              this.ctxSenkouSpanB.moveTo(p1.x, p1.senkouSpanA);
              this.ctxSenkouSpanB.lineTo(p2.x + 0.1, p2.senkouSpanA);
              this.ctxSenkouSpanB.lineTo(p2.x + 0.1, p2.senkouSpanB);
              this.ctxSenkouSpanB.lineTo(p1.x, p1.senkouSpanB);

              if (p1.senkouSpanA >= p1.senkouSpanB) {
                this.ctxSenkouSpanB.fillStyle = this.kumo_down_color;
              } else {
                this.ctxSenkouSpanB.fillStyle = this.kumo_up_color;
              }

              this.ctxSenkouSpanB.fill();
            }

            ind++;
          }
        } catch (err) {
          _iterator.e(err);
        } finally {
          _iterator.f();
        }

        this.ctxSenkouSpanB.stroke();
      }

      if (this.showTenkan) {
        this.ctxTenkan.beginPath();

        var _iterator2 = Ichimokuvue_type_script_lang_js_createForOfIteratorHelper(subdata),
            _step2;

        try {
          for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
            var pTenkan = _step2.value;
            this.ctxTenkan.strokeStyle = this.tenkan_color;
            this.ctxTenkan.lineWidth = this.tenkan_line_width;
            this.ctxTenkan.lineTo(layout.t2screen(pTenkan[0]), layout.$2screen(pTenkan[1]));
          }
        } catch (err) {
          _iterator2.e(err);
        } finally {
          _iterator2.f();
        }

        this.ctxTenkan.stroke();
      }

      if (this.showKijun) {
        this.ctxKijun.beginPath();

        var _iterator3 = Ichimokuvue_type_script_lang_js_createForOfIteratorHelper(subdata),
            _step3;

        try {
          for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {
            var pKijun = _step3.value;
            this.ctxKijun.strokeStyle = this.kijun_color;
            this.ctxKijun.lineWidth = this.kijun_line_width;
            this.ctxKijun.lineTo(layout.t2screen(pKijun[0]), layout.$2screen(pKijun[2]));
          }
        } catch (err) {
          _iterator3.e(err);
        } finally {
          _iterator3.f();
        }

        this.ctxKijun.stroke();
      }

      if (this.showSenkouSpanA) {
        this.ctxSenkouSpanA.beginPath();

        var _iterator4 = Ichimokuvue_type_script_lang_js_createForOfIteratorHelper(subdataSenkouSpan),
            _step4;

        try {
          for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {
            var pSenkouSpanA = _step4.value;
            this.ctxSenkouSpanA.strokeStyle = this.senkou_spanA_color;
            this.ctxSenkouSpanA.lineWidth = this.senkou_spanA_line_width;
            this.ctxSenkouSpanA.lineTo(layout.t2screen(pSenkouSpanA[0]), layout.$2screen(pSenkouSpanA[3]));
          }
        } catch (err) {
          _iterator4.e(err);
        } finally {
          _iterator4.f();
        }

        this.ctxSenkouSpanA.stroke();
      }

      if (this.colorSenkouSpanB) {
        this.ctxSenkouSpanB.beginPath();

        var _iterator5 = Ichimokuvue_type_script_lang_js_createForOfIteratorHelper(subdataSenkouSpan),
            _step5;

        try {
          for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {
            var pSenkouSpanB = _step5.value;
            this.ctxSenkouSpanB.strokeStyle = this.senkou_spanB_color;
            this.ctxSenkouSpanB.lineWidth = this.senkou_spanB_line_width;
            this.ctxSenkouSpanB.lineTo(layout.t2screen(pSenkouSpanB[0]), layout.$2screen(pSenkouSpanB[4]));
          }
        } catch (err) {
          _iterator5.e(err);
        } finally {
          _iterator5.f();
        }

        this.ctxSenkouSpanB.stroke();
      }

      if (this.showChinkou) {
        this.ctxChinkou.beginPath();

        var _iterator6 = Ichimokuvue_type_script_lang_js_createForOfIteratorHelper(subdataChinkou),
            _step6;

        try {
          for (_iterator6.s(); !(_step6 = _iterator6.n()).done;) {
            var pChikou = _step6.value;
            this.ctxChinkou.strokeStyle = this.chinkou_color;
            this.ctxChinkou.lineWidth = this.chinkou_line_width;
            this.ctxChinkou.lineTo(layout.t2screen(pChikou[0]), layout.$2screen(pChikou[5]));
          }
        } catch (err) {
          _iterator6.e(err);
        } finally {
          _iterator6.f();
        }

        this.ctxChinkou.stroke();
      }
    },
    map_senkou_span_values: function map_senkou_span_values(p) {
      var layout = this.$props.layout;
      return p && {
        x: layout.t2screen(p[0]),
        senkouSpanA: layout.$2screen(p[3]),
        senkouSpanB: layout.$2screen(p[4])
      };
    },
    use_for: function use_for() {
      return ["Ichimoku"];
    },
    data_colors: function data_colors() {
      var colors = [];
      colors.push(this.tenkan_color);
      colors.push(this.kijun_color);
      colors.push(this.senkou_spanA_color);
      colors.push(this.senkou_spanB_color);
      colors.push(this.chinkou_color);
      return colors;
    }
  }
});
;// CONCATENATED MODULE: ./src/overlays/Ichimoku/Ichimoku.vue?vue&type=script&lang=js&
 /* harmony default export */ const Ichimoku_Ichimokuvue_type_script_lang_js_ = (Ichimokuvue_type_script_lang_js_); 
;// CONCATENATED MODULE: ./src/overlays/Ichimoku/Ichimoku.vue
var Ichimoku_render, Ichimoku_staticRenderFns
;



/* normalize component */
;
var Ichimoku_component = normalizeComponent(
  Ichimoku_Ichimokuvue_type_script_lang_js_,
  Ichimoku_render,
  Ichimoku_staticRenderFns,
  false,
  null,
  null,
  null
  
)

/* hot reload */
if (false) { var Ichimoku_api; }
Ichimoku_component.options.__file = "src/overlays/Ichimoku/Ichimoku.vue"
/* harmony default export */ const Ichimoku = (Ichimoku_component.exports);
;// CONCATENATED MODULE: ./node_modules/babel-loader/lib/index.js!./node_modules/vue-loader/lib/index.js??vue-loader-options!./src/overlays/KC/KC.vue?vue&type=script&lang=js&

/* harmony default export */ const KCvue_type_script_lang_js_ = ({
  name: 'KC',
  mixins: [external_trading_vue_js_.Overlay],
  methods: {
    meta_info: function meta_info() {
      return {
        author: 'StdSquad',
        version: '1.0.0',
        desc: 'Keltner Channels',
        preset: {
          name: 'KC $length $mult',
          side: 'onchart',
          settings: {
            lineWidth: 0.75,
            color: '#4c8dffab',
            showMid: true,
            backColor: '#4c8dff0a'
          }
        }
      };
    },
    use_for: function use_for() {
      return ['KC'];
    },
    calc: function calc() {
      return {
        props: {
          length: {
            def: 20,
            text: 'Length'
          },
          mult: {
            def: 1,
            text: 'Multiplier'
          },
          use_tr: {
            def: true,
            text: 'Use True Range'
          }
        },
        conf: {
          renderer: 'Channel'
        },
        update: "\n                    let [m, h, l] = kc(close, length, mult, use_tr)\n                    return [h[0], m[0], l[0]]\n                "
      };
    }
  }
});
;// CONCATENATED MODULE: ./src/overlays/KC/KC.vue?vue&type=script&lang=js&
 /* harmony default export */ const KC_KCvue_type_script_lang_js_ = (KCvue_type_script_lang_js_); 
;// CONCATENATED MODULE: ./src/overlays/KC/KC.vue
var KC_render, KC_staticRenderFns
;



/* normalize component */
;
var KC_component = normalizeComponent(
  KC_KCvue_type_script_lang_js_,
  KC_render,
  KC_staticRenderFns,
  false,
  null,
  null,
  null
  
)

/* hot reload */
if (false) { var KC_api; }
KC_component.options.__file = "src/overlays/KC/KC.vue"
/* harmony default export */ const KC = (KC_component.exports);
;// CONCATENATED MODULE: ./node_modules/babel-loader/lib/index.js!./node_modules/vue-loader/lib/index.js??vue-loader-options!./src/overlays/KCW/KCW.vue?vue&type=script&lang=js&

/* harmony default export */ const KCWvue_type_script_lang_js_ = ({
  name: 'KCW',
  mixins: [external_trading_vue_js_.Overlay],
  methods: {
    meta_info: function meta_info() {
      return {
        author: 'StdSquad',
        version: '1.0.0',
        desc: 'Keltner Channels Width',
        preset: {
          name: 'KCW $length $mult',
          side: 'offchart',
          settings: {
            lineWidth: 0.75,
            color: '#4c8dffab'
          }
        }
      };
    },
    use_for: function use_for() {
      return ['KCW'];
    },
    calc: function calc() {
      return {
        props: {
          length: {
            def: 20,
            text: 'Length'
          },
          mult: {
            def: 1,
            text: 'Multiplier'
          },
          use_tr: {
            def: true,
            text: 'Use True Range'
          }
        },
        conf: {
          renderer: 'Spline'
        },
        update: "\n                    return kcw(close, length, mult, use_tr)[0]\n                "
      };
    }
  }
});
;// CONCATENATED MODULE: ./src/overlays/KCW/KCW.vue?vue&type=script&lang=js&
 /* harmony default export */ const KCW_KCWvue_type_script_lang_js_ = (KCWvue_type_script_lang_js_); 
;// CONCATENATED MODULE: ./src/overlays/KCW/KCW.vue
var KCW_render, KCW_staticRenderFns
;



/* normalize component */
;
var KCW_component = normalizeComponent(
  KCW_KCWvue_type_script_lang_js_,
  KCW_render,
  KCW_staticRenderFns,
  false,
  null,
  null,
  null
  
)

/* hot reload */
if (false) { var KCW_api; }
KCW_component.options.__file = "src/overlays/KCW/KCW.vue"
/* harmony default export */ const KCW = (KCW_component.exports);
;// CONCATENATED MODULE: ./node_modules/babel-loader/lib/index.js!./node_modules/vue-loader/lib/index.js??vue-loader-options!./src/overlays/LongShortTrades/LongShortTrades.vue?vue&type=script&lang=js&
function LongShortTradesvue_type_script_lang_js_createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = LongShortTradesvue_type_script_lang_js_unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it["return"] != null) it["return"](); } finally { if (didErr) throw err; } } }; }

function LongShortTradesvue_type_script_lang_js_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return LongShortTradesvue_type_script_lang_js_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return LongShortTradesvue_type_script_lang_js_arrayLikeToArray(o, minLen); }

function LongShortTradesvue_type_script_lang_js_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

//Long Short Overlay. Expected Format: [ <timestamp>, <Short:0 Long:1 ShortCover: 2 LongCover:3>, <Price Change>, <Percent Price Change>, <Open Price>, <High Price>, <Low Price>, <Close Price> ]

/* harmony default export */ const LongShortTradesvue_type_script_lang_js_ = ({
  name: 'LongShortTrades',
  mixins: [external_trading_vue_js_.Overlay],
  computed: {
    sett: function sett() {
      return this.$props.settings;
    },
    default_font: function default_font() {
      return '12px ' + this.$props.font.split('px').pop();
    },
    currency_symbol: function currency_symbol() {
      return this.sett.currency || '';
    },
    long_color: function long_color() {
      return this.sett.longColor || '#63df89';
    },
    short_color: function short_color() {
      return this.sett.shortColor || '#ffd581';
    },
    long_cover_color: function long_cover_color() {
      return this.sett.longCoverColor || '#fc7e2f';
    },
    short_cover_color: function short_cover_color() {
      return this.sett.shortCoverColor || '#ff6bd6';
    },
    label_color: function label_color() {
      return '#4BECF9';
    },
    marker_size: function marker_size() {
      return this.sett.markerSize || 5;
    },
    show_label: function show_label() {
      return this.sett.showLabel !== false;
    },
    new_font: function new_font() {
      return this.sett.font || this.default_font;
    }
  },
  methods: {
    meta_info: function meta_info() {
      return {
        author: 'Sudeep Batra',
        version: '1.0.1'
      };
    },
    draw: function draw(ctx) {
      var layout = this.$props.layout;
      ctx.lineWidth = 1.5;
      ctx.strokeStyle = 'black';

      var _iterator = LongShortTradesvue_type_script_lang_js_createForOfIteratorHelper(this.$props.data),
          _step;

      try {
        for (_iterator.s(); !(_step = _iterator.n()).done;) {
          var p = _step.value;
          var tradeTime = p[0];
          var longShortEntryExit = p[1];
          var priceChange = p[2];
          var percentPriceChange = p[3];
          var openPrice = p[4];
          var highPrice = p[5];
          var lowPrice = p[6];
          var closePrice = p[7];
          var x = layout.t2screen(tradeTime);
          var lowPriceY = layout.$2screen(lowPrice);
          var highPriceY = layout.$2screen(highPrice);

          switch (longShortEntryExit) {
            case 0:
              this.filledArrowDownFilledBottom(ctx, x, highPriceY - 25, 5, 5, 3, 20, this.short_color);
              this.draw_label(ctx, x + 30, highPriceY - 35, this.currency_symbol + closePrice);
              break;

            case 1:
              this.filledArrowUpFilledBottom(ctx, x, lowPriceY + 20, 5, 5, 3, 20, this.long_color);
              this.draw_label(ctx, x + 30, lowPriceY + 40, this.currency_symbol + closePrice);
              break;

            case 2:
              this.upTriangle(ctx, x, lowPriceY + 25, 5, 7, this.short_cover_color);

              if (this.show_label && priceChange) {
                this.draw_label(ctx, x, lowPriceY + 50, priceChange + " (" + percentPriceChange + ")");
              }

              break;

            case 3:
              this.downTriangle(ctx, x, highPriceY - 25, 5, 7, this.long_cover_color);

              if (this.show_label && priceChange) {
                this.draw_label(ctx, x, highPriceY - 45, priceChange + " (" + percentPriceChange + ")");
              }

              break;

            default:
              ctx.fillStyle = 'black';
          } // this.simpleArrowUp(ctx, x, z - 25, '#84e5b1')
          // this.simpleArrowDown(ctx, x, z - 25, '#84e5b1')
          // this.filledArrowUp(ctx, x, z - 25, 5, 5, 20, '#84e5b1')
          // this.filledDownArrow(ctx, x, z - 25, 5, 5, 20, '#84e5b1')
          // this.filledArrowUpFilledBottom(ctx, x, z - 25, 5, 5, 3, 20, '#84e5b1')
          // this.filledArrowDownFilledBottom(ctx, x, z - 25, 5, 5, 3, 20, '#84e5b1')
          // this.upTriangle(ctx, x, z-60, 5, 7, '#84e5b1')
          // this.downTriangle(ctx, x, z - 25, 5, 7, '#84e5b1')

        }
      } catch (err) {
        _iterator.e(err);
      } finally {
        _iterator.f();
      }
    },
    draw_label: function draw_label(ctx, x, y, labelText) {
      ctx.fillStyle = this.label_color;
      ctx.font = this.new_font;
      ctx.textAlign = 'center';
      ctx.fillText(labelText, x, y);
    },
    use_for: function use_for() {
      return ['LongShortTrades'];
    },
    legend: function legend(values) {
      switch (values[1]) {
        case 0:
          var pos = 'Short';
          break;

        case 1:
          pos = 'Long';
          break;

        case 2:
          pos = 'Short Cover';
          break;

        case 3:
          pos = 'Long Cover';
          break;

        default:
          pos = 'Unknown';
      }

      return [{
        value: pos
      }, {
        value: values[2].toFixed(4),
        color: this.$props.colors.colorText
      }].concat(values[3] ? [{
        value: values[3]
      }] : []);
    },
    simpleArrowUp: function simpleArrowUp(ctx, x, y, color) {
      ctx.beginPath();
      ctx.fillStyle = color;
      ctx.strokeStyle = color;
      ctx.moveTo(x - 5, y + 5);
      ctx.lineTo(x, y);
      ctx.lineTo(x + 5, y + 5);
      ctx.moveTo(x, y);
      ctx.lineTo(x, y + 15);
      ctx.stroke();
      ctx.closePath();
    },
    simpleArrowDown: function simpleArrowDown(ctx, x, y, color) {
      ctx.beginPath();
      ctx.fillStyle = color;
      ctx.strokeStyle = color;
      ctx.moveTo(x - 5, y - 5);
      ctx.lineTo(x, y);
      ctx.lineTo(x + 5, y - 5);
      ctx.moveTo(x, y);
      ctx.lineTo(x, y - 15);
      ctx.stroke();
      ctx.closePath();
    },
    filledArrowUp: function filledArrowUp(ctx, x, y, width, height, depth, color) {
      ctx.beginPath();
      ctx.fillStyle = color;
      ctx.strokeStyle = color;
      ctx.moveTo(x - width, y + height);
      ctx.lineTo(x, y);
      ctx.lineTo(x + width, y + height);
      ctx.moveTo(x, y);
      ctx.lineTo(x, y + depth);
      ctx.fill();
      ctx.stroke();
      ctx.closePath();
    },
    filledDownArrow: function filledDownArrow(ctx, x, y, width, height, depth, color) {
      ctx.beginPath();
      ctx.fillStyle = color;
      ctx.strokeStyle = color;
      ctx.moveTo(x - width, y - height);
      ctx.lineTo(x, y);
      ctx.lineTo(x + width, y - height);
      ctx.moveTo(x, y);
      ctx.lineTo(x, y - depth);
      ctx.fill();
      ctx.stroke();
      ctx.closePath();
    },
    filledArrowUpFilledBottom: function filledArrowUpFilledBottom(ctx, x, y, width, height, bottom, depth, color) {
      ctx.beginPath();
      ctx.fillStyle = color;
      ctx.strokeStyle = color;
      ctx.moveTo(x - width, y + height);
      ctx.lineTo(x, y);
      ctx.lineTo(x + width, y + height);
      ctx.moveTo(x, y);
      ctx.rect(x - bottom / 2, y + height, bottom, depth);
      ctx.fill();
      ctx.stroke();
      ctx.closePath();
    },
    filledArrowDownFilledBottom: function filledArrowDownFilledBottom(ctx, x, y, width, height, bottom, depth, color) {
      ctx.beginPath();
      ctx.fillStyle = color;
      ctx.strokeStyle = color;
      ctx.moveTo(x - width, y - height);
      ctx.lineTo(x, y);
      ctx.lineTo(x + width, y - height);
      ctx.moveTo(x, y);
      ctx.rect(x - bottom / 2, y - height - depth, bottom, depth);
      ctx.fill();
      ctx.stroke();
      ctx.closePath();
    },
    upTriangle: function upTriangle(ctx, x, y, width, height, color) {
      ctx.beginPath();
      ctx.fillStyle = color;
      ctx.strokeStyle = color;
      ctx.moveTo(x - width, y + height);
      ctx.lineTo(x, y);
      ctx.lineTo(x + width, y + height);
      ctx.fill();
      ctx.stroke();
      ctx.closePath();
    },
    downTriangle: function downTriangle(ctx, x, y, width, height, color) {
      ctx.beginPath();
      ctx.fillStyle = color;
      ctx.strokeStyle = color;
      ctx.moveTo(x - width, y - height);
      ctx.lineTo(x, y);
      ctx.lineTo(x + width, y - height);
      ctx.fill();
      ctx.stroke();
      ctx.closePath();
    }
  }
});
;// CONCATENATED MODULE: ./src/overlays/LongShortTrades/LongShortTrades.vue?vue&type=script&lang=js&
 /* harmony default export */ const LongShortTrades_LongShortTradesvue_type_script_lang_js_ = (LongShortTradesvue_type_script_lang_js_); 
;// CONCATENATED MODULE: ./src/overlays/LongShortTrades/LongShortTrades.vue
var LongShortTrades_render, LongShortTrades_staticRenderFns
;



/* normalize component */
;
var LongShortTrades_component = normalizeComponent(
  LongShortTrades_LongShortTradesvue_type_script_lang_js_,
  LongShortTrades_render,
  LongShortTrades_staticRenderFns,
  false,
  null,
  null,
  null
  
)

/* hot reload */
if (false) { var LongShortTrades_api; }
LongShortTrades_component.options.__file = "src/overlays/LongShortTrades/LongShortTrades.vue"
/* harmony default export */ const LongShortTrades = (LongShortTrades_component.exports);
;// CONCATENATED MODULE: ./node_modules/babel-loader/lib/index.js!./node_modules/vue-loader/lib/index.js??vue-loader-options!./src/overlays/MACD/MACD.vue?vue&type=script&lang=js&
function MACDvue_type_script_lang_js_createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = MACDvue_type_script_lang_js_unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it["return"] != null) it["return"](); } finally { if (didErr) throw err; } } }; }

function MACDvue_type_script_lang_js_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return MACDvue_type_script_lang_js_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return MACDvue_type_script_lang_js_arrayLikeToArray(o, minLen); }

function MACDvue_type_script_lang_js_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

// TODO: pass colors from settings to the script
// TODO: hist lines => recangles (like in volbar.js)

/* harmony default export */ const MACDvue_type_script_lang_js_ = ({
  name: 'MACD',
  mixins: [external_trading_vue_js_.Overlay],
  methods: {
    meta_info: function meta_info() {
      return {
        author: 'StdSquad',
        version: '1.0.2',
        desc: 'Moving Average Convergence/Divergence',
        preset: {
          name: 'MACD $fast $slow $smooth',
          side: 'offchart',
          settings: {
            histWidth: 4,
            macdWidth: 1,
            signalWidth: 1,
            defColor: "#42b28a",
            macdColor: "#3782f2",
            signalColor: "#f48709",
            histColors: ["#35a776", "#79e0b3", "#e54150", "#ea969e"]
          }
        }
      };
    },
    draw: function draw(ctx) {
      var layout = this.$props.layout; // HISTOGRAM

      var base = layout.$2screen(0) + 0.5;
      var off = this.hist_width % 2 ? 0 : 0.5;
      ctx.lineWidth = this.hist_width;
      ctx.strokeStyle = this.color;
      ctx.beginPath();

      var _iterator = MACDvue_type_script_lang_js_createForOfIteratorHelper(this.$props.data),
          _step;

      try {
        for (_iterator.s(); !(_step = _iterator.n()).done;) {
          var p = _step.value;
          var x = layout.t2screen(p[0]) - off;
          var y = layout.$2screen(p[1]) - 0.5;
          ctx.strokeStyle = this.sett.histColors[p[4]];
          ctx.beginPath();
          ctx.moveTo(x, base);
          ctx.lineTo(x, y);
          ctx.stroke();
        } // MACD LINE

      } catch (err) {
        _iterator.e(err);
      } finally {
        _iterator.f();
      }

      ctx.beginPath();
      ctx.lineWidth = this.macd_width;
      ctx.strokeStyle = this.macd_color;

      var _iterator2 = MACDvue_type_script_lang_js_createForOfIteratorHelper(this.$props.data),
          _step2;

      try {
        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
          var p = _step2.value;

          var _x = layout.t2screen(p[0]);

          var _y = layout.$2screen(p[2]);

          ctx.lineTo(_x, _y);
        }
      } catch (err) {
        _iterator2.e(err);
      } finally {
        _iterator2.f();
      }

      ctx.stroke(); // SIGNAL LINE

      ctx.beginPath();
      ctx.lineWidth = this.signal_width;
      ctx.strokeStyle = this.signal_color;

      var _iterator3 = MACDvue_type_script_lang_js_createForOfIteratorHelper(this.$props.data),
          _step3;

      try {
        for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {
          var p = _step3.value;

          var _x2 = layout.t2screen(p[0]);

          var _y2 = layout.$2screen(p[3]);

          ctx.lineTo(_x2, _y2);
        }
      } catch (err) {
        _iterator3.e(err);
      } finally {
        _iterator3.f();
      }

      ctx.stroke();
    },
    use_for: function use_for() {
      return ['MACD'];
    },
    legend: function legend(values) {
      var xs = values.slice(1, 4).map(function (x) {
        return x.toFixed(Math.abs(x) > 0.001 ? 4 : 8);
      });
      return [{
        value: xs[0],
        color: this.hist_colors[values[4]]
      }, {
        value: xs[1],
        color: this.macd_color
      }, {
        value: xs[2],
        color: this.signal_color
      }];
    },
    calc: function calc() {
      return {
        props: {
          fast: {
            def: 12,
            text: 'Fast Length'
          },
          slow: {
            def: 26,
            text: 'Slow Length'
          },
          smooth: {
            def: 9,
            text: 'Signal EMA'
          }
        },
        update: "\n                    let [macd, signal, hist] =\n                        macd(close, fast, slow, smooth)\n\n                    if (hist[0] >= 0) {\n                         var color = 0\n                         if (hist[0] < hist[1]) color = 1\n                    } else {\n                        color = 2\n                        if (hist[0] > hist[1]) color = 3\n                    }\n\n                    return [hist[0], macd[0], signal[0], color]\n                "
      };
    }
  },
  // Define internal setting & constants here
  computed: {
    sett: function sett() {
      return this.$props.settings;
    },
    hist_width: function hist_width() {
      return this.sett.histWidth || 4;
    },
    macd_width: function macd_width() {
      return this.sett.macdWidth || 1;
    },
    signal_width: function signal_width() {
      return this.sett.signalWidth || 1;
    },
    color: function color() {
      return this.sett.defColor || "#42b28a";
    },
    macd_color: function macd_color() {
      return this.sett.macdColor || "#3782f2";
    },
    signal_color: function signal_color() {
      return this.sett.signalColor || "#f48709";
    },
    hist_colors: function hist_colors() {
      return this.sett.histColors;
    }
  }
});
;// CONCATENATED MODULE: ./src/overlays/MACD/MACD.vue?vue&type=script&lang=js&
 /* harmony default export */ const MACD_MACDvue_type_script_lang_js_ = (MACDvue_type_script_lang_js_); 
;// CONCATENATED MODULE: ./src/overlays/MACD/MACD.vue
var MACD_render, MACD_staticRenderFns
;



/* normalize component */
;
var MACD_component = normalizeComponent(
  MACD_MACDvue_type_script_lang_js_,
  MACD_render,
  MACD_staticRenderFns,
  false,
  null,
  null,
  null
  
)

/* hot reload */
if (false) { var MACD_api; }
MACD_component.options.__file = "src/overlays/MACD/MACD.vue"
/* harmony default export */ const MACD = (MACD_component.exports);
;// CONCATENATED MODULE: ./node_modules/babel-loader/lib/index.js!./node_modules/vue-loader/lib/index.js??vue-loader-options!./src/overlays/MFI/MFI.vue?vue&type=script&lang=js&

/* harmony default export */ const MFIvue_type_script_lang_js_ = ({
  name: 'MFI',
  mixins: [external_trading_vue_js_.Overlay],
  methods: {
    meta_info: function meta_info() {
      return {
        author: 'StdSquad',
        version: '1.0.0',
        desc: 'Money Flow Index',
        preset: {
          name: 'MFI $length',
          side: 'offchart',
          settings: {
            lineWidth: 0.75,
            color: '#85c427ee',
            bandColor: '#aaaaaa',
            backColor: '#85c42711',
            upper: 80,
            lower: 20
          }
        }
      };
    },
    use_for: function use_for() {
      return ['MFI'];
    },
    calc: function calc() {
      return {
        props: {
          length: {
            def: 14,
            text: 'Length'
          }
        },
        conf: {
          renderer: 'Range'
        },
        update: "\n                    let hlc3 = ts((high[0] + low[0] + close[0]) / 3)\n                    return mfi(hlc3, length)[0]\n                "
      };
    }
  }
});
;// CONCATENATED MODULE: ./src/overlays/MFI/MFI.vue?vue&type=script&lang=js&
 /* harmony default export */ const MFI_MFIvue_type_script_lang_js_ = (MFIvue_type_script_lang_js_); 
;// CONCATENATED MODULE: ./src/overlays/MFI/MFI.vue
var MFI_render, MFI_staticRenderFns
;



/* normalize component */
;
var MFI_component = normalizeComponent(
  MFI_MFIvue_type_script_lang_js_,
  MFI_render,
  MFI_staticRenderFns,
  false,
  null,
  null,
  null
  
)

/* hot reload */
if (false) { var MFI_api; }
MFI_component.options.__file = "src/overlays/MFI/MFI.vue"
/* harmony default export */ const MFI = (MFI_component.exports);
;// CONCATENATED MODULE: ./node_modules/babel-loader/lib/index.js!./node_modules/vue-loader/lib/index.js??vue-loader-options!./src/overlays/MOM/MOM.vue?vue&type=script&lang=js&

/* harmony default export */ const MOMvue_type_script_lang_js_ = ({
  name: 'MOM',
  mixins: [external_trading_vue_js_.Overlay],
  methods: {
    meta_info: function meta_info() {
      return {
        author: 'StdSquad',
        version: '1.0.0',
        desc: 'Momentum',
        preset: {
          name: 'MOM $length',
          side: 'offchart',
          settings: {
            lineWidth: 0.75,
            color: '#bcc427ee'
          }
        }
      };
    },
    use_for: function use_for() {
      return ['MOM'];
    },
    calc: function calc() {
      return {
        props: {
          length: {
            def: 11,
            text: 'Length'
          }
        },
        conf: {
          renderer: 'Spline'
        },
        update: "\n                    return mom(close, length)[0]\n                "
      };
    }
  }
});
;// CONCATENATED MODULE: ./src/overlays/MOM/MOM.vue?vue&type=script&lang=js&
 /* harmony default export */ const MOM_MOMvue_type_script_lang_js_ = (MOMvue_type_script_lang_js_); 
;// CONCATENATED MODULE: ./src/overlays/MOM/MOM.vue
var MOM_render, MOM_staticRenderFns
;



/* normalize component */
;
var MOM_component = normalizeComponent(
  MOM_MOMvue_type_script_lang_js_,
  MOM_render,
  MOM_staticRenderFns,
  false,
  null,
  null,
  null
  
)

/* hot reload */
if (false) { var MOM_api; }
MOM_component.options.__file = "src/overlays/MOM/MOM.vue"
/* harmony default export */ const MOM = (MOM_component.exports);
;// CONCATENATED MODULE: ./node_modules/babel-loader/lib/index.js!./node_modules/vue-loader/lib/index.js??vue-loader-options!./src/overlays/Markers/Markers.vue?vue&type=script&lang=js&
function Markersvue_type_script_lang_js_createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = Markersvue_type_script_lang_js_unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it["return"] != null) it["return"](); } finally { if (didErr) throw err; } } }; }

function Markersvue_type_script_lang_js_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return Markersvue_type_script_lang_js_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return Markersvue_type_script_lang_js_arrayLikeToArray(o, minLen); }

function Markersvue_type_script_lang_js_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }


/* harmony default export */ const Markersvue_type_script_lang_js_ = ({
  name: 'Markers',
  mixins: [external_trading_vue_js_.Overlay],
  methods: {
    meta_info: function meta_info() {
      return {
        author: 'C451',
        version: '1.0.1',
        desc: 'Interactive markers'
      };
    },
    init: function init() {
      this.mouse.on('mousemove', function () {});
    },
    draw: function draw(ctx) {
      ctx.lineWidth = 1.5;
      ctx.strokeStyle = 'black';
      document.body.style.cursor = 'auto';
      this.selected = null;

      var _iterator = Markersvue_type_script_lang_js_createForOfIteratorHelper(this.$props.data),
          _step;

      try {
        for (_iterator.s(); !(_step = _iterator.n()).done;) {
          var p = _step.value;
          this.draw_point(ctx, p);
        }
      } catch (err) {
        _iterator.e(err);
      } finally {
        _iterator.f();
      }

      var f = this.data.find(function (x) {
        return x[1].sel;
      });

      if (f) {
        this.draw_point(ctx, f);
      }
    },
    draw_point: function draw_point(ctx, p) {
      var layout = this.$props.layout;
      var stroke = this.colors.back;
      var fill = p[1].color || 'orange';
      var radius = 2;
      var height = p[1].sel ? 20 : 14;
      var width = p[1].sel ? 17 : 13;
      var x = layout.t2screen(p[0]) - width * 0.5;
      var y = layout.$2screen(p[1].$) - (p[1].sel ? 27 : 20); // Collisions

      if (this.mouse.x > x && this.mouse.x < x + width && this.mouse.y > y && this.mouse.y < y + height) {
        document.body.style.cursor = 'pointer';
        this.selected = p;
        stroke = this.colors.text;
      }

      ctx.beginPath();
      ctx.moveTo(x + radius, y);
      ctx.lineTo(x + width - radius, y);
      ctx.quadraticCurveTo(x + width, y, x + width, y + radius);
      ctx.lineTo(x + width, y + height - radius);
      ctx.quadraticCurveTo(x + width, y + height, x + width - radius, y + height);
      ctx.lineTo(x + width * 1 / 2, y + height + height / 5);
      ctx.lineTo(x + radius, y + height);
      ctx.quadraticCurveTo(x, y + height, x, y + height - radius);
      ctx.lineTo(x, y + radius);
      ctx.quadraticCurveTo(x, y, x + radius, y);
      ctx.lineWidth = 1;
      ctx.closePath();
      ctx.fillStyle = fill;
      ctx.strokeStyle = stroke;
      ctx.fill();
      ctx.stroke();
      ctx.textAlign = 'center';
      ctx.fillStyle = p[1].textColor || this.colors.back;
      ctx.font = "".concat(p[1].sel ? 15 : 11, "px Arial");
      ctx.fillText(p[1].text || '$', x + width / 2, y + height * 0.8);
    },
    use_for: function use_for() {
      return ['Markers'];
    },
    legend: function legend() {
      return [];
    },
    mousedown: function mousedown() {
      this.$emit('marker-selected', this.selected);
    }
  },
  // Define internal setting & constants here
  computed: {
    sett: function sett() {
      return this.$props.settings;
    },
    default_font: function default_font() {
      return '12px ' + this.$props.font.split('px').pop();
    },
    new_font: function new_font() {
      return this.sett.font || this.default_font;
    }
  },
  data: function data() {
    return {
      selected: null
    };
  }
});
;// CONCATENATED MODULE: ./src/overlays/Markers/Markers.vue?vue&type=script&lang=js&
 /* harmony default export */ const Markers_Markersvue_type_script_lang_js_ = (Markersvue_type_script_lang_js_); 
;// CONCATENATED MODULE: ./src/overlays/Markers/Markers.vue
var Markers_render, Markers_staticRenderFns
;



/* normalize component */
;
var Markers_component = normalizeComponent(
  Markers_Markersvue_type_script_lang_js_,
  Markers_render,
  Markers_staticRenderFns,
  false,
  null,
  null,
  null
  
)

/* hot reload */
if (false) { var Markers_api; }
Markers_component.options.__file = "src/overlays/Markers/Markers.vue"
/* harmony default export */ const Markers = (Markers_component.exports);
;// CONCATENATED MODULE: ./node_modules/babel-loader/lib/index.js!./node_modules/vue-loader/lib/index.js??vue-loader-options!./src/overlays/PlotCross/PlotCross.vue?vue&type=script&lang=js&
function PlotCrossvue_type_script_lang_js_createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = PlotCrossvue_type_script_lang_js_unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it["return"] != null) it["return"](); } finally { if (didErr) throw err; } } }; }

function PlotCrossvue_type_script_lang_js_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return PlotCrossvue_type_script_lang_js_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return PlotCrossvue_type_script_lang_js_arrayLikeToArray(o, minLen); }

function PlotCrossvue_type_script_lang_js_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }


/* harmony default export */ const PlotCrossvue_type_script_lang_js_ = ({
  name: 'PlotCross',
  mixins: [external_trading_vue_js_.Overlay],
  methods: {
    meta_info: function meta_info() {
      return {
        author: 'StdSquad',
        version: '1.0.0',
        desc: 'Plot line with crosses'
      };
    },
    draw: function draw(ctx) {
      var w = ctx.lineWidth = this.line_width;
      ctx.strokeStyle = this.color;
      ctx.beginPath();
      var layout = this.$props.layout;
      var base = layout.$2screen(0) + 0.5;
      var off = this.line_width % 2 ? 0 : 0.5;
      var off2 = this.line_width % 2 ? 0.5 : 1; // Color changed

      var changed = false;

      var _iterator = PlotCrossvue_type_script_lang_js_createForOfIteratorHelper(this.$props.data),
          _step;

      try {
        for (_iterator.s(); !(_step = _iterator.n()).done;) {
          var p = _step.value;
          var x = layout.t2screen(p[0]) - off;
          var y = layout.$2screen(p[1]) - off;
          var _changed = false;

          if (p[2]) {
            if (ctx.strokeStyle !== p[2]) {
              ctx.stroke();
              _changed = true;
            }

            ctx.strokeStyle = p[2];
          } else {
            if (ctx.strokeStyle !== this.color) {
              ctx.stroke();
              _changed = true;
            }

            ctx.strokeStyle = this.color;
          }

          if (_changed) ctx.beginPath();
          ctx.moveTo(x, y - w * 2 + off2);
          ctx.lineTo(x, y + w * 2 - off2);
          ctx.moveTo(x - w * 2 + off2, y);
          ctx.lineTo(x + w * 2 - off2, y);
        }
      } catch (err) {
        _iterator.e(err);
      } finally {
        _iterator.f();
      }

      ctx.stroke();
    },
    use_for: function use_for() {
      return ['PlotCross'];
    },
    legend: function legend(values) {
      var x = values[1];

      if (typeof x === "number") {
        x = x.toFixed(Math.abs(x) > 0.001 ? 4 : 8);
      }

      return [{
        value: x,
        color: values[2] || this.color
      }];
    }
  },
  // Define internal setting & constants here
  computed: {
    sett: function sett() {
      return this.$props.settings;
    },
    line_width: function line_width() {
      return this.sett.lineWidth || 2;
    },
    color: function color() {
      var n = this.$props.num % 5;
      return this.sett.color || this.COLORS[n];
    }
  },
  data: function data() {
    return {
      COLORS: ['#888888', '#42b28a', '#5691ce', '#612ff9', '#d50b90', '#ff2316']
    };
  }
});
;// CONCATENATED MODULE: ./src/overlays/PlotCross/PlotCross.vue?vue&type=script&lang=js&
 /* harmony default export */ const PlotCross_PlotCrossvue_type_script_lang_js_ = (PlotCrossvue_type_script_lang_js_); 
;// CONCATENATED MODULE: ./src/overlays/PlotCross/PlotCross.vue
var PlotCross_render, PlotCross_staticRenderFns
;



/* normalize component */
;
var PlotCross_component = normalizeComponent(
  PlotCross_PlotCrossvue_type_script_lang_js_,
  PlotCross_render,
  PlotCross_staticRenderFns,
  false,
  null,
  null,
  null
  
)

/* hot reload */
if (false) { var PlotCross_api; }
PlotCross_component.options.__file = "src/overlays/PlotCross/PlotCross.vue"
/* harmony default export */ const PlotCross = (PlotCross_component.exports);
;// CONCATENATED MODULE: ./node_modules/babel-loader/lib/index.js!./node_modules/vue-loader/lib/index.js??vue-loader-options!./src/overlays/ROC/ROC.vue?vue&type=script&lang=js&

/* harmony default export */ const ROCvue_type_script_lang_js_ = ({
  name: 'ROC',
  mixins: [external_trading_vue_js_.Overlay],
  methods: {
    meta_info: function meta_info() {
      return {
        author: 'StdSquad',
        version: '1.0.0',
        desc: 'Rate of Change',
        preset: {
          name: 'ROC $length',
          side: 'offchart',
          settings: {
            lineWidth: 0.75,
            color: '#279fc4'
          }
        }
      };
    },
    use_for: function use_for() {
      return ['ROC'];
    },
    calc: function calc() {
      return {
        props: {
          length: {
            def: 9,
            text: 'Length'
          }
        },
        conf: {
          renderer: 'Spline'
        },
        update: "\n                    return roc(close, length)[0]\n                "
      };
    }
  }
});
;// CONCATENATED MODULE: ./src/overlays/ROC/ROC.vue?vue&type=script&lang=js&
 /* harmony default export */ const ROC_ROCvue_type_script_lang_js_ = (ROCvue_type_script_lang_js_); 
;// CONCATENATED MODULE: ./src/overlays/ROC/ROC.vue
var ROC_render, ROC_staticRenderFns
;



/* normalize component */
;
var ROC_component = normalizeComponent(
  ROC_ROCvue_type_script_lang_js_,
  ROC_render,
  ROC_staticRenderFns,
  false,
  null,
  null,
  null
  
)

/* hot reload */
if (false) { var ROC_api; }
ROC_component.options.__file = "src/overlays/ROC/ROC.vue"
/* harmony default export */ const ROC = (ROC_component.exports);
;// CONCATENATED MODULE: ./node_modules/babel-loader/lib/index.js!./node_modules/vue-loader/lib/index.js??vue-loader-options!./src/overlays/RSI/RSI.vue?vue&type=script&lang=js&

/* harmony default export */ const RSIvue_type_script_lang_js_ = ({
  name: 'RSI',
  mixins: [external_trading_vue_js_.Overlay],
  methods: {
    meta_info: function meta_info() {
      return {
        author: 'StdSquad',
        version: '1.0.0',
        desc: 'Relative Strength Index',
        preset: {
          name: 'RSI $length',
          side: 'offchart',
          settings: {
            lineWidth: 0.75,
            color: '#ec206e',
            bandColor: '#aaa',
            backColor: '#9b9ba316'
          }
        }
      };
    },
    use_for: function use_for() {
      return ['RSI'];
    },
    calc: function calc() {
      return {
        props: {
          length: {
            def: 14,
            text: 'Length'
          }
        },
        conf: {
          renderer: 'Range'
        },
        update: "return rsi(close, length)[0]"
      };
    }
  }
});
;// CONCATENATED MODULE: ./src/overlays/RSI/RSI.vue?vue&type=script&lang=js&
 /* harmony default export */ const RSI_RSIvue_type_script_lang_js_ = (RSIvue_type_script_lang_js_); 
;// CONCATENATED MODULE: ./src/overlays/RSI/RSI.vue
var RSI_render, RSI_staticRenderFns
;



/* normalize component */
;
var RSI_component = normalizeComponent(
  RSI_RSIvue_type_script_lang_js_,
  RSI_render,
  RSI_staticRenderFns,
  false,
  null,
  null,
  null
  
)

/* hot reload */
if (false) { var RSI_api; }
RSI_component.options.__file = "src/overlays/RSI/RSI.vue"
/* harmony default export */ const RSI = (RSI_component.exports);
;// CONCATENATED MODULE: ./node_modules/babel-loader/lib/index.js!./node_modules/vue-loader/lib/index.js??vue-loader-options!./src/overlays/Ribbon/Ribbon.vue?vue&type=script&lang=js&

/* harmony default export */ const Ribbonvue_type_script_lang_js_ = ({
  name: 'Ribbon',
  mixins: [external_trading_vue_js_.Overlay],
  methods: {
    meta_info: function meta_info() {
      return {
        author: 'StdSquad',
        version: '1.0.0',
        desc: 'Moving Average Ribbon',
        preset: {
          name: 'EMA x $number',
          side: 'onchart',
          settings: {
            lineWidth: 0.75,
            colors: ["#3aaaf4ee"]
          }
        }
      };
    },
    use_for: function use_for() {
      return ['Ribbon'];
    },
    calc: function calc() {
      return {
        props: {
          start: {
            def: 10,
            text: 'Start Length'
          },
          number: {
            def: 5,
            text: 'Number of Lines'
          },
          step: {
            def: 10,
            text: 'Length Step'
          }
        },
        conf: {
          renderer: 'Splines'
        },
        update: "\n                    this[0] = []\n                    for (var i = 0; i < number; i++) {\n                        let l = start + i * step\n                        this[0].push(ema(close, l)[0])\n                    }\n                "
      };
    }
  }
});
;// CONCATENATED MODULE: ./src/overlays/Ribbon/Ribbon.vue?vue&type=script&lang=js&
 /* harmony default export */ const Ribbon_Ribbonvue_type_script_lang_js_ = (Ribbonvue_type_script_lang_js_); 
;// CONCATENATED MODULE: ./src/overlays/Ribbon/Ribbon.vue
var Ribbon_render, Ribbon_staticRenderFns
;



/* normalize component */
;
var Ribbon_component = normalizeComponent(
  Ribbon_Ribbonvue_type_script_lang_js_,
  Ribbon_render,
  Ribbon_staticRenderFns,
  false,
  null,
  null,
  null
  
)

/* hot reload */
if (false) { var Ribbon_api; }
Ribbon_component.options.__file = "src/overlays/Ribbon/Ribbon.vue"
/* harmony default export */ const Ribbon = (Ribbon_component.exports);
;// CONCATENATED MODULE: ./node_modules/babel-loader/lib/index.js!./node_modules/vue-loader/lib/index.js??vue-loader-options!./src/overlays/SAR/SAR.vue?vue&type=script&lang=js&

/* harmony default export */ const SARvue_type_script_lang_js_ = ({
  name: 'SAR',
  mixins: [external_trading_vue_js_.Overlay],
  methods: {
    meta_info: function meta_info() {
      return {
        author: 'StdSquad',
        version: '1.0.0',
        desc: 'Parabolic SAR',
        preset: {
          name: 'SAR $start $inc $max',
          side: 'onchart',
          settings: {
            lineWidth: 2,
            color: '#35a9c6'
          }
        }
      };
    },
    use_for: function use_for() {
      return ['SAR'];
    },
    calc: function calc() {
      return {
        props: {
          start: {
            def: 0.02,
            text: 'Start'
          },
          inc: {
            def: 0.02,
            text: 'Increment'
          },
          max: {
            def: 0.2,
            text: 'Maximum'
          }
        },
        conf: {
          renderer: 'PlotCross'
        },
        update: "\n                    return sar(start, inc, max)[0]\n                "
      };
    }
  }
});
;// CONCATENATED MODULE: ./src/overlays/SAR/SAR.vue?vue&type=script&lang=js&
 /* harmony default export */ const SAR_SARvue_type_script_lang_js_ = (SARvue_type_script_lang_js_); 
;// CONCATENATED MODULE: ./src/overlays/SAR/SAR.vue
var SAR_render, SAR_staticRenderFns
;



/* normalize component */
;
var SAR_component = normalizeComponent(
  SAR_SARvue_type_script_lang_js_,
  SAR_render,
  SAR_staticRenderFns,
  false,
  null,
  null,
  null
  
)

/* hot reload */
if (false) { var SAR_api; }
SAR_component.options.__file = "src/overlays/SAR/SAR.vue"
/* harmony default export */ const SAR = (SAR_component.exports);
;// CONCATENATED MODULE: ./node_modules/babel-loader/lib/index.js!./node_modules/vue-loader/lib/index.js??vue-loader-options!./src/overlays/SMA/SMA.vue?vue&type=script&lang=js&

/* harmony default export */ const SMAvue_type_script_lang_js_ = ({
  name: 'SMA',
  mixins: [external_trading_vue_js_.Overlay],
  methods: {
    meta_info: function meta_info() {
      return {
        author: 'StdSquad',
        version: '1.0.0',
        desc: 'Simple Moving Average',
        preset: {
          name: 'SMA $length',
          side: 'onchart',
          settings: {
            lineWidth: 0.75,
            color: '#d1385c'
          }
        }
      };
    },
    use_for: function use_for() {
      return ['SMA'];
    },
    calc: function calc() {
      return {
        props: {
          length: {
            def: 25,
            text: 'Length'
          }
        },
        conf: {
          renderer: 'Spline'
        },
        update: "\n                    return sma(close, length)[0]\n                "
      };
    }
  }
});
;// CONCATENATED MODULE: ./src/overlays/SMA/SMA.vue?vue&type=script&lang=js&
 /* harmony default export */ const SMA_SMAvue_type_script_lang_js_ = (SMAvue_type_script_lang_js_); 
;// CONCATENATED MODULE: ./src/overlays/SMA/SMA.vue
var SMA_render, SMA_staticRenderFns
;



/* normalize component */
;
var SMA_component = normalizeComponent(
  SMA_SMAvue_type_script_lang_js_,
  SMA_render,
  SMA_staticRenderFns,
  false,
  null,
  null,
  null
  
)

/* hot reload */
if (false) { var SMA_api; }
SMA_component.options.__file = "src/overlays/SMA/SMA.vue"
/* harmony default export */ const SMA = (SMA_component.exports);
;// CONCATENATED MODULE: ./node_modules/babel-loader/lib/index.js!./node_modules/vue-loader/lib/index.js??vue-loader-options!./src/overlays/SWMA/SWMA.vue?vue&type=script&lang=js&

/* harmony default export */ const SWMAvue_type_script_lang_js_ = ({
  name: 'SWMA',
  mixins: [external_trading_vue_js_.Overlay],
  methods: {
    meta_info: function meta_info() {
      return {
        author: 'StdSquad',
        version: '1.0.0',
        desc: 'Symmetrically Weighted Moving Average',
        preset: {
          name: 'SWMA',
          side: 'onchart',
          settings: {
            lineWidth: 0.75,
            color: '#e57440'
          }
        }
      };
    },
    use_for: function use_for() {
      return ['SWMA'];
    },
    calc: function calc() {
      return {
        props: {},
        conf: {
          renderer: 'Spline'
        },
        update: "\n                    return swma(close)[0]\n                "
      };
    }
  }
});
;// CONCATENATED MODULE: ./src/overlays/SWMA/SWMA.vue?vue&type=script&lang=js&
 /* harmony default export */ const SWMA_SWMAvue_type_script_lang_js_ = (SWMAvue_type_script_lang_js_); 
;// CONCATENATED MODULE: ./src/overlays/SWMA/SWMA.vue
var SWMA_render, SWMA_staticRenderFns
;



/* normalize component */
;
var SWMA_component = normalizeComponent(
  SWMA_SWMAvue_type_script_lang_js_,
  SWMA_render,
  SWMA_staticRenderFns,
  false,
  null,
  null,
  null
  
)

/* hot reload */
if (false) { var SWMA_api; }
SWMA_component.options.__file = "src/overlays/SWMA/SWMA.vue"
/* harmony default export */ const SWMA = (SWMA_component.exports);
;// CONCATENATED MODULE: ./node_modules/babel-loader/lib/index.js!./node_modules/vue-loader/lib/index.js??vue-loader-options!./src/overlays/Stoch/Stoch.vue?vue&type=script&lang=js&
function Stochvue_type_script_lang_js_createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = Stochvue_type_script_lang_js_unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it["return"] != null) it["return"](); } finally { if (didErr) throw err; } } }; }

function Stochvue_type_script_lang_js_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return Stochvue_type_script_lang_js_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return Stochvue_type_script_lang_js_arrayLikeToArray(o, minLen); }

function Stochvue_type_script_lang_js_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }


/* harmony default export */ const Stochvue_type_script_lang_js_ = ({
  name: 'Stoch',
  mixins: [external_trading_vue_js_.Overlay],
  methods: {
    meta_info: function meta_info() {
      return {
        author: 'StdSquad',
        version: '1.0.0',
        desc: 'Stochastic',
        preset: {
          name: 'Stoch $param_k $param_d $smooth',
          side: 'offchart',
          settings: {
            lineWidth: 0.75,
            kColor: '#3782f2',
            dColor: '#f48709',
            bandColor: '#ddd',
            backColor: '#381e9c16'
          }
        }
      };
    },
    draw: function draw(ctx) {
      var layout = this.$props.layout;
      var upper = layout.$2screen(this.sett.upper || 80);
      var lower = layout.$2screen(this.sett.lower || 20); // K

      ctx.lineWidth = this.line_width;
      ctx.strokeStyle = this.k_color;
      ctx.beginPath();

      var _iterator = Stochvue_type_script_lang_js_createForOfIteratorHelper(this.$props.data),
          _step;

      try {
        for (_iterator.s(); !(_step = _iterator.n()).done;) {
          var p = _step.value;
          var x = layout.t2screen(p[0]);
          var y = layout.$2screen(p[1]);
          ctx.lineTo(x, y);
        }
      } catch (err) {
        _iterator.e(err);
      } finally {
        _iterator.f();
      }

      ctx.stroke(); // D

      ctx.lineWidth = this.line_width;
      ctx.strokeStyle = this.d_color;
      ctx.beginPath();

      var _iterator2 = Stochvue_type_script_lang_js_createForOfIteratorHelper(this.$props.data),
          _step2;

      try {
        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
          var p = _step2.value;

          var _x = layout.t2screen(p[0]);

          var _y = layout.$2screen(p[2]);

          ctx.lineTo(_x, _y);
        }
      } catch (err) {
        _iterator2.e(err);
      } finally {
        _iterator2.f();
      }

      ctx.stroke();
      ctx.strokeStyle = this.band_color;
      ctx.setLineDash([5]); // Will be removed after draw()

      ctx.beginPath(); // Fill the area between the bands

      ctx.fillStyle = this.back_color;
      ctx.fillRect(0, upper, layout.width, lower - upper); // Upper band

      ctx.moveTo(0, upper);
      ctx.lineTo(layout.width, upper); // Lower band

      ctx.moveTo(0, lower);
      ctx.lineTo(layout.width, lower);
      ctx.stroke();
    },
    use_for: function use_for() {
      return ['Stoch'];
    },
    data_colors: function data_colors() {
      return [this.color];
    },
    y_range: function y_range(hi, lo) {
      return [Math.max(hi, this.sett.upper || 80), Math.min(lo, this.sett.lower || 20)];
    },
    calc: function calc() {
      return {
        props: {
          param_k: {
            def: 14,
            text: 'K'
          },
          param_d: {
            def: 3,
            text: 'D'
          },
          smooth: {
            def: 3,
            text: 'Smooth'
          }
        },
        update: "\n                    let k = sma(stoch(close, high, low, param_k), smooth)\n                    let d = sma(k, param_d)\n                    return [k[0], d[0]]\n                "
      };
    }
  },
  computed: {
    sett: function sett() {
      return this.$props.settings;
    },
    line_width: function line_width() {
      return this.sett.lineWidth || 0.75;
    },
    k_color: function k_color() {
      return this.sett.kColor || '#3782f2';
    },
    d_color: function d_color() {
      return this.sett.dColor || '#f48709';
    },
    band_color: function band_color() {
      return this.sett.bandColor || '#ddd';
    },
    back_color: function back_color() {
      return this.sett.backColor || '#381e9c16';
    }
  }
});
;// CONCATENATED MODULE: ./src/overlays/Stoch/Stoch.vue?vue&type=script&lang=js&
 /* harmony default export */ const Stoch_Stochvue_type_script_lang_js_ = (Stochvue_type_script_lang_js_); 
;// CONCATENATED MODULE: ./src/overlays/Stoch/Stoch.vue
var Stoch_render, Stoch_staticRenderFns
;



/* normalize component */
;
var Stoch_component = normalizeComponent(
  Stoch_Stochvue_type_script_lang_js_,
  Stoch_render,
  Stoch_staticRenderFns,
  false,
  null,
  null,
  null
  
)

/* hot reload */
if (false) { var Stoch_api; }
Stoch_component.options.__file = "src/overlays/Stoch/Stoch.vue"
/* harmony default export */ const Stoch = (Stoch_component.exports);
;// CONCATENATED MODULE: ./node_modules/babel-loader/lib/index.js!./node_modules/vue-loader/lib/index.js??vue-loader-options!./src/overlays/TSI/TSI.vue?vue&type=script&lang=js&

/* harmony default export */ const TSIvue_type_script_lang_js_ = ({
  name: 'TSI',
  mixins: [external_trading_vue_js_.Overlay],
  methods: {
    meta_info: function meta_info() {
      return {
        author: 'StdSquad',
        version: '1.0.0',
        desc: 'True Strength Index',
        preset: {
          name: 'TSI $long $short $signal',
          side: 'offchart',
          settings: {
            lineWidth: 0.75,
            colors: ["#3bb3e4", "#f7046d"]
          }
        }
      };
    },
    use_for: function use_for() {
      return ['TSI'];
    },
    calc: function calc() {
      return {
        props: {
          "long": {
            def: 25,
            text: 'Long Length'
          },
          "short": {
            def: 13,
            text: 'Short Length'
          },
          signal: {
            def: 13,
            text: 'Signal Length'
          }
        },
        conf: {
          renderer: 'Splines'
        },
        update: "\n                    let val = tsi(close, short, long)\n                    let sig = ema(val, signal)\n                    return [val[0] * 100, sig[0] * 100]\n                "
      };
    }
  }
});
;// CONCATENATED MODULE: ./src/overlays/TSI/TSI.vue?vue&type=script&lang=js&
 /* harmony default export */ const TSI_TSIvue_type_script_lang_js_ = (TSIvue_type_script_lang_js_); 
;// CONCATENATED MODULE: ./src/overlays/TSI/TSI.vue
var TSI_render, TSI_staticRenderFns
;



/* normalize component */
;
var TSI_component = normalizeComponent(
  TSI_TSIvue_type_script_lang_js_,
  TSI_render,
  TSI_staticRenderFns,
  false,
  null,
  null,
  null
  
)

/* hot reload */
if (false) { var TSI_api; }
TSI_component.options.__file = "src/overlays/TSI/TSI.vue"
/* harmony default export */ const TSI = (TSI_component.exports);
;// CONCATENATED MODULE: ./node_modules/babel-loader/lib/index.js!./node_modules/vue-loader/lib/index.js??vue-loader-options!./src/overlays/TradesPlus/TradesPlus.vue?vue&type=script&lang=js&
function TradesPlusvue_type_script_lang_js_createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = TradesPlusvue_type_script_lang_js_unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it["return"] != null) it["return"](); } finally { if (didErr) throw err; } } }; }

function TradesPlusvue_type_script_lang_js_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return TradesPlusvue_type_script_lang_js_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return TradesPlusvue_type_script_lang_js_arrayLikeToArray(o, minLen); }

function TradesPlusvue_type_script_lang_js_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }


var CROSS = "m512.001 84.853-84.853-84.853-171.147 171.147-171.148-171.147-84.853\n84.853 171.148 171.147-171.148 171.148 84.853 84.853 171.148-171.147\n171.147 171.147 84.853-84.853-171.148-171.148z";
/* harmony default export */ const TradesPlusvue_type_script_lang_js_ = ({
  name: 'TradesPlus',
  mixins: [external_trading_vue_js_.Overlay],
  methods: {
    meta_info: function meta_info() {
      return {
        author: 'C451',
        version: '1.0.1',
        desc: 'Trades overlay with stops'
      };
    },
    draw: function draw(ctx) {
      var layout = this.$props.layout;
      ctx.strokeStyle = 'black';

      var _iterator = TradesPlusvue_type_script_lang_js_createForOfIteratorHelper(this.$props.data),
          _step;

      try {
        for (_iterator.s(); !(_step = _iterator.n()).done;) {
          var p = _step.value;
          ctx.fillStyle = p[1] ? this.buy_color : this.sell_color;
          var x = layout.t2screen(p[0]); // x - Mapping

          var y = layout.$2screen(p[2]); // y - Mapping

          if (p[3] === 'Stop') {
            this.draw_cross(ctx, x, y);
          } else {
            this.draw_circle(ctx, x, y);
          }

          if (this.show_label && p[3] && p[3] !== 'Stop') {
            this.draw_label(ctx, x, y, p);
          }
        }
      } catch (err) {
        _iterator.e(err);
      } finally {
        _iterator.f();
      }
    },
    draw_label: function draw_label(ctx, x, y, p) {
      ctx.fillStyle = this.label_color;
      ctx.font = this.new_font;
      ctx.textAlign = 'center';
      ctx.fillText(p[3], x, y - 25);
    },
    draw_circle: function draw_circle(ctx, x, y) {
      ctx.lineWidth = 1.5;
      ctx.beginPath();
      ctx.arc(x, y, this.marker_size + 0.5, 0, Math.PI * 2, true);
      ctx.fill();
      ctx.stroke();
    },
    draw_cross: function draw_cross(ctx, x, y) {
      ctx.save();
      var p = new Path2D(CROSS);
      ctx.lineWidth = 150;
      ctx.translate(x - 5, y - 5);
      ctx.scale(0.0175, 0.0175);
      ctx.stroke(p);
      ctx.fill(p);
      ctx.scale(1, 1);
      ctx.restore();
    },
    use_for: function use_for() {
      return ['TradesPlus'];
    },
    // Defines legend format (values & colors)
    legend: function legend(values) {
      switch (values[1]) {
        case 0:
          var pos = 'Sell';
          break;

        case 1:
          pos = 'Buy';
          break;

        default:
          pos = 'Unknown';
      }

      return [{
        value: pos
      }, {
        value: values[2].toFixed(4),
        color: this.$props.colors.colorText
      }].concat(values[3] ? [{
        value: values[3]
      }] : []);
    }
  },
  // Define internal setting & constants here
  computed: {
    sett: function sett() {
      return this.$props.settings;
    },
    default_font: function default_font() {
      return '12px ' + this.$props.font.split('px').pop();
    },
    buy_color: function buy_color() {
      return this.sett.buyColor || '#63df89';
    },
    sell_color: function sell_color() {
      return this.sett.sellColor || '#ec4662';
    },
    label_color: function label_color() {
      return this.sett.labelColor || this.colors.text;
    },
    marker_size: function marker_size() {
      return this.sett.markerSize || 5;
    },
    show_label: function show_label() {
      return this.sett.showLabel !== false;
    },
    new_font: function new_font() {
      return this.sett.font || this.default_font;
    }
  }
});
;// CONCATENATED MODULE: ./src/overlays/TradesPlus/TradesPlus.vue?vue&type=script&lang=js&
 /* harmony default export */ const TradesPlus_TradesPlusvue_type_script_lang_js_ = (TradesPlusvue_type_script_lang_js_); 
;// CONCATENATED MODULE: ./src/overlays/TradesPlus/TradesPlus.vue
var TradesPlus_render, TradesPlus_staticRenderFns
;



/* normalize component */
;
var TradesPlus_component = normalizeComponent(
  TradesPlus_TradesPlusvue_type_script_lang_js_,
  TradesPlus_render,
  TradesPlus_staticRenderFns,
  false,
  null,
  null,
  null
  
)

/* hot reload */
if (false) { var TradesPlus_api; }
TradesPlus_component.options.__file = "src/overlays/TradesPlus/TradesPlus.vue"
/* harmony default export */ const TradesPlus = (TradesPlus_component.exports);
;// CONCATENATED MODULE: ./node_modules/babel-loader/lib/index.js!./node_modules/vue-loader/lib/index.js??vue-loader-options!./src/overlays/VWMA/VWMA.vue?vue&type=script&lang=js&

/* harmony default export */ const VWMAvue_type_script_lang_js_ = ({
  name: 'VWMA',
  mixins: [external_trading_vue_js_.Overlay],
  methods: {
    meta_info: function meta_info() {
      return {
        author: 'StdSquad',
        version: '1.0.0',
        desc: 'Volume Weighted Moving Average',
        preset: {
          name: 'VWMA $length',
          side: 'onchart',
          settings: {
            lineWidth: 0.75,
            color: '#db0670'
          }
        }
      };
    },
    use_for: function use_for() {
      return ['VWMA'];
    },
    calc: function calc() {
      return {
        props: {
          length: {
            def: 20,
            text: 'Length'
          }
        },
        conf: {
          renderer: 'Spline'
        },
        update: "\n                    return vwma(close, length)[0]\n                "
      };
    }
  }
});
;// CONCATENATED MODULE: ./src/overlays/VWMA/VWMA.vue?vue&type=script&lang=js&
 /* harmony default export */ const VWMA_VWMAvue_type_script_lang_js_ = (VWMAvue_type_script_lang_js_); 
;// CONCATENATED MODULE: ./src/overlays/VWMA/VWMA.vue
var VWMA_render, VWMA_staticRenderFns
;



/* normalize component */
;
var VWMA_component = normalizeComponent(
  VWMA_VWMAvue_type_script_lang_js_,
  VWMA_render,
  VWMA_staticRenderFns,
  false,
  null,
  null,
  null
  
)

/* hot reload */
if (false) { var VWMA_api; }
VWMA_component.options.__file = "src/overlays/VWMA/VWMA.vue"
/* harmony default export */ const VWMA = (VWMA_component.exports);
;// CONCATENATED MODULE: ./node_modules/babel-loader/lib/index.js!./node_modules/vue-loader/lib/index.js??vue-loader-options!./src/overlays/WilliamsR/WilliamsR.vue?vue&type=script&lang=js&

/* harmony default export */ const WilliamsRvue_type_script_lang_js_ = ({
  name: 'WilliamsR',
  mixins: [external_trading_vue_js_.Overlay],
  methods: {
    meta_info: function meta_info() {
      return {
        author: 'StdSquad',
        version: '1.0.0',
        desc: 'Williams %R',
        preset: {
          name: '%R $length',
          side: 'offchart',
          settings: {
            lineWidth: 0.75,
            color: '#0980e8',
            bandColor: '#aaa',
            backColor: '#9b9ba316',
            upper: -20,
            lower: -80
          }
        }
      };
    },
    use_for: function use_for() {
      return ['WilliamsR'];
    },
    calc: function calc() {
      return {
        props: {
          length: {
            def: 14,
            text: 'Length'
          }
        },
        conf: {
          renderer: 'Range'
        },
        update: "\n                    return wpr(length)[0]\n                "
      };
    }
  }
});
;// CONCATENATED MODULE: ./src/overlays/WilliamsR/WilliamsR.vue?vue&type=script&lang=js&
 /* harmony default export */ const WilliamsR_WilliamsRvue_type_script_lang_js_ = (WilliamsRvue_type_script_lang_js_); 
;// CONCATENATED MODULE: ./src/overlays/WilliamsR/WilliamsR.vue
var WilliamsR_render, WilliamsR_staticRenderFns
;



/* normalize component */
;
var WilliamsR_component = normalizeComponent(
  WilliamsR_WilliamsRvue_type_script_lang_js_,
  WilliamsR_render,
  WilliamsR_staticRenderFns,
  false,
  null,
  null,
  null
  
)

/* hot reload */
if (false) { var WilliamsR_api; }
WilliamsR_component.options.__file = "src/overlays/WilliamsR/WilliamsR.vue"
/* harmony default export */ const WilliamsR = (WilliamsR_component.exports);
;// CONCATENATED MODULE: ./node_modules/@babel/runtime/helpers/esm/arrayLikeToArray.js
function arrayLikeToArray_arrayLikeToArray(arr, len) {
  if (len == null || len > arr.length) len = arr.length;

  for (var i = 0, arr2 = new Array(len); i < len; i++) {
    arr2[i] = arr[i];
  }

  return arr2;
}
;// CONCATENATED MODULE: ./node_modules/@babel/runtime/helpers/esm/arrayWithoutHoles.js

function _arrayWithoutHoles(arr) {
  if (Array.isArray(arr)) return arrayLikeToArray_arrayLikeToArray(arr);
}
;// CONCATENATED MODULE: ./node_modules/@babel/runtime/helpers/esm/iterableToArray.js
function _iterableToArray(iter) {
  if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter);
}
;// CONCATENATED MODULE: ./node_modules/@babel/runtime/helpers/esm/unsupportedIterableToArray.js

function unsupportedIterableToArray_unsupportedIterableToArray(o, minLen) {
  if (!o) return;
  if (typeof o === "string") return arrayLikeToArray_arrayLikeToArray(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor) n = o.constructor.name;
  if (n === "Map" || n === "Set") return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return arrayLikeToArray_arrayLikeToArray(o, minLen);
}
;// CONCATENATED MODULE: ./node_modules/@babel/runtime/helpers/esm/nonIterableSpread.js
function _nonIterableSpread() {
  throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
;// CONCATENATED MODULE: ./node_modules/@babel/runtime/helpers/esm/toConsumableArray.js




function _toConsumableArray(arr) {
  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || unsupportedIterableToArray_unsupportedIterableToArray(arr) || _nonIterableSpread();
}
;// CONCATENATED MODULE: ./node_modules/@babel/runtime/helpers/esm/classCallCheck.js
function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
;// CONCATENATED MODULE: ./node_modules/@babel/runtime/helpers/esm/createClass.js
function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}

function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties(Constructor, staticProps);
  return Constructor;
}
;// CONCATENATED MODULE: ./src/overlays/XOhlcBars/primitives/xohlcbar.js



// Ohlc object for Ohlcs overlay
var XOhlcBar = /*#__PURE__*/function () {
  function XOhlcBar(overlay, ctx, data) {
    _classCallCheck(this, XOhlcBar);

    this.ctx = ctx;
    this.self = overlay;
    this.style = data.raw[6] || this.self;

    this._draw(data);
  }

  _createClass(XOhlcBar, [{
    key: "_draw",
    value: function _draw(data) {
      var line_width = this.style.lineWidth;
      var hlc_only = this.style.chartType == "HLC";
      var line_width_half = line_width / 2; // Bar color

      var bar_color = data.c <= data.o ? this.style.upBarColor : this.style.downBarColor;
      var width = Math.max(data.w, 1);
      var halfwidth = Math.max(Math.floor(width * 0.5), 1);
      var height = Math.abs(data.o - data.c);
      var max_h = data.c === data.o ? 1 : 2;
      var s = line_width % 2 === 0 ? 0 : 0.5; // Draw the line from low to high and open and close also

      this.ctx.strokeStyle = bar_color;
      this.ctx.lineWidth = line_width;
      this.ctx.beginPath(); // Draw high to low

      this.ctx.moveTo(Math.floor(data.x - line_width_half) + s, Math.floor(data.h));
      this.ctx.lineTo(Math.floor(data.x - line_width_half) + s, Math.floor(data.l));

      if (width > 1) {
        // Draw open notch
        if (hlc_only) {
          // No open price in consideration
          // Draw open notch with close price
          this.ctx.moveTo(Math.floor(data.x - halfwidth - line_width_half - 1), Math.floor(data.c) - s);
          this.ctx.lineTo(Math.floor(data.x - line_width_half), Math.floor(data.c) - s);
        } else {
          // Draw open notch with open price
          this.ctx.moveTo(Math.floor(data.x - halfwidth - line_width_half - 1), Math.floor(data.o) - s);
          this.ctx.lineTo(Math.floor(data.x - line_width_half), Math.floor(data.o) - s);
        } // Draw close notch


        this.ctx.moveTo(Math.floor(data.x - line_width_half), Math.floor(data.c) - s);
        this.ctx.lineTo(Math.floor(data.x + halfwidth - line_width_half + 1), Math.floor(data.c) - s);
      }

      this.ctx.stroke();
    }
  }]);

  return XOhlcBar;
}();


;// CONCATENATED MODULE: ./src/overlays/XOhlcBars/primitives/xvolbar.js



var XVolbar = /*#__PURE__*/function () {
  function XVolbar(overlay, ctx, data, barData, thinVolumeBar) {
    _classCallCheck(this, XVolbar);

    this.ctx = ctx;
    this.$p = overlay.$props;
    this.self = overlay;
    this.style = data.raw[6] || this.self;

    this._draw(data, barData, thinVolumeBar);
  }

  _createClass(XVolbar, [{
    key: "_draw",
    value: function _draw(data, barData, thinVolumeBar) {
      if (thinVolumeBar) {
        // Thin Volume Bar
        var bar_color = data.green ? this.style.upVolBarColor : this.style.downVolBarColor;
        var line_width = this.style.volBarWidth;
        var line_width_half = line_width / 2;
        var y0 = this.$p.layout.height;
        var w = data.x2 - data.x1;
        var h = Math.floor(data.h);
        this.ctx.strokeStyle = bar_color;
        this.ctx.lineWidth = line_width;
        this.ctx.beginPath(); // Draw high to low

        this.ctx.moveTo(Math.floor(barData.x - line_width_half), Math.floor(y0 - h - 0.5));
        this.ctx.lineTo(Math.floor(barData.x - line_width_half), Math.floor(y0 + 0.5));
        this.ctx.stroke();
      } else {
        // Thick Volume Bar
        var _y = this.$p.layout.height;

        var _w = data.x2 - data.x1;

        var _h = Math.floor(data.h);

        this.ctx.fillStyle = data.green ? this.style.upVolBarColor : this.style.downVolBarColor;
        this.ctx.fillRect(Math.floor(data.x1), Math.floor(_y - _h - 0.5), Math.floor(_w), Math.floor(_h + 1));
      }
    }
  }]);

  return XVolbar;
}();


;// CONCATENATED MODULE: ./node_modules/babel-loader/lib/index.js!./node_modules/vue-loader/lib/index.js??vue-loader-options!./src/overlays/XOhlcBars/XOhlcBars.vue?vue&type=script&lang=js&


function XOhlcBarsvue_type_script_lang_js_createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = XOhlcBarsvue_type_script_lang_js_unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it["return"] != null) it["return"](); } finally { if (didErr) throw err; } } }; }

function XOhlcBarsvue_type_script_lang_js_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return XOhlcBarsvue_type_script_lang_js_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return XOhlcBarsvue_type_script_lang_js_arrayLikeToArray(o, minLen); }

function XOhlcBarsvue_type_script_lang_js_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

// Renedrer for ohlcbar + volume (optional)
// It can be used as the main chart or an indicator



/* harmony default export */ const XOhlcBarsvue_type_script_lang_js_ = ({
  name: 'XOhlcBars',
  mixins: [external_trading_vue_js_.Overlay],
  methods: {
    meta_info: function meta_info() {
      return {
        author: 'X',
        version: '1.3.0',
        desc: 'Bar Chart'
      };
    },
    init: function init() {//this.price = new Price(this) // TODO:
    },
    draw: function draw(ctx) {
      //console.log("XOhlcBar.draw() called. this.$props.data.length = " + this.$props.data.length)
      // render as main chart:
      if (this.$props.sub === this.$props.data) {
        var cnv = {
          ohlcbars: this.$props.layout.candles,
          volume: this.$props.layout.volume
        }; // Else, as offchart / onchart indicator:
      } else {
        cnv = (0,external_trading_vue_js_.layout_cnv)(this);
      }

      if (this.show_volume) {
        for (var i = 0; i < cnv.volume.length; i++) {
          var volumeData = cnv.volume[i];
          var _barData = cnv.ohlcbars[i];
          new XVolbar(this, ctx, volumeData, _barData);
        }
      }

      var _iterator = XOhlcBarsvue_type_script_lang_js_createForOfIteratorHelper(cnv.ohlcbars),
          _step;

      try {
        for (_iterator.s(); !(_step = _iterator.n()).done;) {
          var barData = _step.value;
          new XOhlcBar(this, ctx, barData);
        } //if (this.price_line) this.price.draw(ctx)  // TODO:

      } catch (err) {
        _iterator.e(err);
      } finally {
        _iterator.f();
      }
    },
    use_for: function use_for() {
      return ['XOhlcBars'];
    },
    // When added as offchart overlay
    y_range: function y_range() {
      return [Math.max.apply(Math, _toConsumableArray(this.$props.sub.map(function (x) {
        return x[2];
      }))), Math.min.apply(Math, _toConsumableArray(this.$props.sub.map(function (x) {
        return x[3];
      })))];
    }
  },
  // Define internal setting & constants here
  computed: {
    sett: function sett() {
      return this.$props.settings;
    },
    show_volume: function show_volume() {
      return 'showVolume' in this.sett ? this.sett.showVolume : true;
    },
    price_line: function price_line() {
      return 'priceLine' in this.sett ? this.sett.priceLine : true;
    },
    upVolBarColor: function upVolBarColor() {
      return this.sett.upBarColor || "#23a77655";
    },
    downVolBarColor: function downVolBarColor() {
      return this.sett.downBarColor || "#e5415055";
    },
    volBarWidth: function volBarWidth() {
      return this.sett.barWidth || 2;
    },
    upBarColor: function upBarColor() {
      return this.sett.upBarColor || "#23a776";
    },
    downBarColor: function downBarColor() {
      return this.sett.downBarColor || "#e54150";
    },
    barWidth: function barWidth() {
      return this.sett.barWidth || 1;
    },
    hlcOnly: function hlcOnly() {
      return this.sett.hlcOnly || false;
    },
    lineWidth: function lineWidth() {
      return this.sett.lineWidth || 1;
    }
  },
  data: function data() {
    return {
      price: {}
    };
  }
});
;// CONCATENATED MODULE: ./src/overlays/XOhlcBars/XOhlcBars.vue?vue&type=script&lang=js&
 /* harmony default export */ const XOhlcBars_XOhlcBarsvue_type_script_lang_js_ = (XOhlcBarsvue_type_script_lang_js_); 
;// CONCATENATED MODULE: ./src/overlays/XOhlcBars/XOhlcBars.vue
var XOhlcBars_render, XOhlcBars_staticRenderFns
;



/* normalize component */
;
var XOhlcBars_component = normalizeComponent(
  XOhlcBars_XOhlcBarsvue_type_script_lang_js_,
  XOhlcBars_render,
  XOhlcBars_staticRenderFns,
  false,
  null,
  null,
  null
  
)

/* hot reload */
if (false) { var XOhlcBars_api; }
XOhlcBars_component.options.__file = "src/overlays/XOhlcBars/XOhlcBars.vue"
/* harmony default export */ const XOhlcBars = (XOhlcBars_component.exports);
;// CONCATENATED MODULE: ./src/index_prod.js
// -------- Production overlay index ---------
//      ! THIS FILE WAS AUTO-GENERATED !
//
// Do not commit this file, the final index is
// compiled by the repo owner, use index_dev.js to
// experiment: 'npm run compile'




































var Pack = {
  ALMA: ALMA,
  ATR: ATR,
  ATRp: ATRp,
  Area51: Area51,
  BB: BB,
  BBW: BBW,
  CCI: CCI,
  CMO: CMO,
  COG: COG,
  DHistogram: DHistogram,
  DMI: DMI,
  EMA: EMA,
  HMA: HMA,
  Histogram: Histogram,
  Ichi: Ichi,
  Ichimoku: Ichimoku,
  KC: KC,
  KCW: KCW,
  LongShortTrades: LongShortTrades,
  MACD: MACD,
  MFI: MFI,
  MOM: MOM,
  Markers: Markers,
  PlotCross: PlotCross,
  ROC: ROC,
  RSI: RSI,
  Ribbon: Ribbon,
  SAR: SAR,
  SMA: SMA,
  SWMA: SWMA,
  Stoch: Stoch,
  TSI: TSI,
  TradesPlus: TradesPlus,
  VWMA: VWMA,
  WilliamsR: WilliamsR,
  XOhlcBars: XOhlcBars
};

if (typeof window !== 'undefined' && window.Vue) {
  window.TvjsOverlays = Pack;
}

/* harmony default export */ const index_prod = (Pack);

})();

/******/ 	return __webpack_exports__;
/******/ })()
;
});

/***/ }),

/***/ "./src/Main.vue":
/*!**********************!*\
  !*** ./src/Main.vue ***!
  \**********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _Main_vue_vue_type_template_id_3ffae6b2___WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Main.vue?vue&type=template&id=3ffae6b2& */ "./src/Main.vue?vue&type=template&id=3ffae6b2&");
/* harmony import */ var _Main_vue_vue_type_script_lang_js___WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Main.vue?vue&type=script&lang=js& */ "./src/Main.vue?vue&type=script&lang=js&");
/* harmony import */ var _Main_vue_vue_type_style_index_0_lang_css___WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Main.vue?vue&type=style&index=0&lang=css& */ "./src/Main.vue?vue&type=style&index=0&lang=css&");
/* harmony import */ var _node_modules_vue_loader_lib_runtime_componentNormalizer_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! !../node_modules/vue-loader/lib/runtime/componentNormalizer.js */ "./node_modules/vue-loader/lib/runtime/componentNormalizer.js");



;


/* normalize component */

var component = (0,_node_modules_vue_loader_lib_runtime_componentNormalizer_js__WEBPACK_IMPORTED_MODULE_3__["default"])(
  _Main_vue_vue_type_script_lang_js___WEBPACK_IMPORTED_MODULE_1__["default"],
  _Main_vue_vue_type_template_id_3ffae6b2___WEBPACK_IMPORTED_MODULE_0__.render,
  _Main_vue_vue_type_template_id_3ffae6b2___WEBPACK_IMPORTED_MODULE_0__.staticRenderFns,
  false,
  null,
  null,
  null
  
)

/* hot reload */
if (false) { var api; }
component.options.__file = "src/Main.vue"
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (component.exports);

/***/ }),

/***/ "./src/components/StdInput.vue":
/*!*************************************!*\
  !*** ./src/components/StdInput.vue ***!
  \*************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _StdInput_vue_vue_type_template_id_5e1f1c17___WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./StdInput.vue?vue&type=template&id=5e1f1c17& */ "./src/components/StdInput.vue?vue&type=template&id=5e1f1c17&");
/* harmony import */ var _StdInput_vue_vue_type_script_lang_js___WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./StdInput.vue?vue&type=script&lang=js& */ "./src/components/StdInput.vue?vue&type=script&lang=js&");
/* harmony import */ var _StdInput_vue_vue_type_style_index_0_lang_css___WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./StdInput.vue?vue&type=style&index=0&lang=css& */ "./src/components/StdInput.vue?vue&type=style&index=0&lang=css&");
/* harmony import */ var _node_modules_vue_loader_lib_runtime_componentNormalizer_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! !../../node_modules/vue-loader/lib/runtime/componentNormalizer.js */ "./node_modules/vue-loader/lib/runtime/componentNormalizer.js");



;


/* normalize component */

var component = (0,_node_modules_vue_loader_lib_runtime_componentNormalizer_js__WEBPACK_IMPORTED_MODULE_3__["default"])(
  _StdInput_vue_vue_type_script_lang_js___WEBPACK_IMPORTED_MODULE_1__["default"],
  _StdInput_vue_vue_type_template_id_5e1f1c17___WEBPACK_IMPORTED_MODULE_0__.render,
  _StdInput_vue_vue_type_template_id_5e1f1c17___WEBPACK_IMPORTED_MODULE_0__.staticRenderFns,
  false,
  null,
  null,
  null
  
)

/* hot reload */
if (false) { var api; }
component.options.__file = "src/components/StdInput.vue"
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (component.exports);

/***/ }),

/***/ "./src/components/Window.vue":
/*!***********************************!*\
  !*** ./src/components/Window.vue ***!
  \***********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _Window_vue_vue_type_template_id_5b030a20___WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Window.vue?vue&type=template&id=5b030a20& */ "./src/components/Window.vue?vue&type=template&id=5b030a20&");
/* harmony import */ var _Window_vue_vue_type_script_lang_js___WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Window.vue?vue&type=script&lang=js& */ "./src/components/Window.vue?vue&type=script&lang=js&");
/* harmony import */ var _Window_vue_vue_type_style_index_0_lang_css___WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Window.vue?vue&type=style&index=0&lang=css& */ "./src/components/Window.vue?vue&type=style&index=0&lang=css&");
/* harmony import */ var _node_modules_vue_loader_lib_runtime_componentNormalizer_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! !../../node_modules/vue-loader/lib/runtime/componentNormalizer.js */ "./node_modules/vue-loader/lib/runtime/componentNormalizer.js");



;


/* normalize component */

var component = (0,_node_modules_vue_loader_lib_runtime_componentNormalizer_js__WEBPACK_IMPORTED_MODULE_3__["default"])(
  _Window_vue_vue_type_script_lang_js___WEBPACK_IMPORTED_MODULE_1__["default"],
  _Window_vue_vue_type_template_id_5b030a20___WEBPACK_IMPORTED_MODULE_0__.render,
  _Window_vue_vue_type_template_id_5b030a20___WEBPACK_IMPORTED_MODULE_0__.staticRenderFns,
  false,
  null,
  null,
  null
  
)

/* hot reload */
if (false) { var api; }
component.options.__file = "src/components/Window.vue"
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (component.exports);

/***/ }),

/***/ "./src/extensions/grid-resize/Splitter.vue":
/*!*************************************************!*\
  !*** ./src/extensions/grid-resize/Splitter.vue ***!
  \*************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _Splitter_vue_vue_type_template_id_189fccad_scoped_true___WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Splitter.vue?vue&type=template&id=189fccad&scoped=true& */ "./src/extensions/grid-resize/Splitter.vue?vue&type=template&id=189fccad&scoped=true&");
/* harmony import */ var _Splitter_vue_vue_type_script_lang_js___WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Splitter.vue?vue&type=script&lang=js& */ "./src/extensions/grid-resize/Splitter.vue?vue&type=script&lang=js&");
/* harmony import */ var _Splitter_vue_vue_type_style_index_0_id_189fccad_scoped_true_lang_css___WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Splitter.vue?vue&type=style&index=0&id=189fccad&scoped=true&lang=css& */ "./src/extensions/grid-resize/Splitter.vue?vue&type=style&index=0&id=189fccad&scoped=true&lang=css&");
/* harmony import */ var _node_modules_vue_loader_lib_runtime_componentNormalizer_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! !../../../node_modules/vue-loader/lib/runtime/componentNormalizer.js */ "./node_modules/vue-loader/lib/runtime/componentNormalizer.js");



;


/* normalize component */

var component = (0,_node_modules_vue_loader_lib_runtime_componentNormalizer_js__WEBPACK_IMPORTED_MODULE_3__["default"])(
  _Splitter_vue_vue_type_script_lang_js___WEBPACK_IMPORTED_MODULE_1__["default"],
  _Splitter_vue_vue_type_template_id_189fccad_scoped_true___WEBPACK_IMPORTED_MODULE_0__.render,
  _Splitter_vue_vue_type_template_id_189fccad_scoped_true___WEBPACK_IMPORTED_MODULE_0__.staticRenderFns,
  false,
  null,
  "189fccad",
  null
  
)

/* hot reload */
if (false) { var api; }
component.options.__file = "src/extensions/grid-resize/Splitter.vue"
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (component.exports);

/***/ }),

/***/ "./src/extensions/legend-buttons/AddWin.vue":
/*!**************************************************!*\
  !*** ./src/extensions/legend-buttons/AddWin.vue ***!
  \**************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _AddWin_vue_vue_type_template_id_53408ac7_scoped_true___WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./AddWin.vue?vue&type=template&id=53408ac7&scoped=true& */ "./src/extensions/legend-buttons/AddWin.vue?vue&type=template&id=53408ac7&scoped=true&");
/* harmony import */ var _AddWin_vue_vue_type_script_lang_js___WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./AddWin.vue?vue&type=script&lang=js& */ "./src/extensions/legend-buttons/AddWin.vue?vue&type=script&lang=js&");
/* harmony import */ var _AddWin_vue_vue_type_style_index_0_id_53408ac7_scoped_true_lang_css___WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./AddWin.vue?vue&type=style&index=0&id=53408ac7&scoped=true&lang=css& */ "./src/extensions/legend-buttons/AddWin.vue?vue&type=style&index=0&id=53408ac7&scoped=true&lang=css&");
/* harmony import */ var _node_modules_vue_loader_lib_runtime_componentNormalizer_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! !../../../node_modules/vue-loader/lib/runtime/componentNormalizer.js */ "./node_modules/vue-loader/lib/runtime/componentNormalizer.js");



;


/* normalize component */

var component = (0,_node_modules_vue_loader_lib_runtime_componentNormalizer_js__WEBPACK_IMPORTED_MODULE_3__["default"])(
  _AddWin_vue_vue_type_script_lang_js___WEBPACK_IMPORTED_MODULE_1__["default"],
  _AddWin_vue_vue_type_template_id_53408ac7_scoped_true___WEBPACK_IMPORTED_MODULE_0__.render,
  _AddWin_vue_vue_type_template_id_53408ac7_scoped_true___WEBPACK_IMPORTED_MODULE_0__.staticRenderFns,
  false,
  null,
  "53408ac7",
  null
  
)

/* hot reload */
if (false) { var api; }
component.options.__file = "src/extensions/legend-buttons/AddWin.vue"
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (component.exports);

/***/ }),

/***/ "./src/extensions/settings-win/SettingsWin.vue":
/*!*****************************************************!*\
  !*** ./src/extensions/settings-win/SettingsWin.vue ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _SettingsWin_vue_vue_type_template_id_5d223b0e_scoped_true___WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./SettingsWin.vue?vue&type=template&id=5d223b0e&scoped=true& */ "./src/extensions/settings-win/SettingsWin.vue?vue&type=template&id=5d223b0e&scoped=true&");
/* harmony import */ var _SettingsWin_vue_vue_type_script_lang_js___WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./SettingsWin.vue?vue&type=script&lang=js& */ "./src/extensions/settings-win/SettingsWin.vue?vue&type=script&lang=js&");
/* harmony import */ var _SettingsWin_vue_vue_type_style_index_0_id_5d223b0e_scoped_true_lang_css___WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./SettingsWin.vue?vue&type=style&index=0&id=5d223b0e&scoped=true&lang=css& */ "./src/extensions/settings-win/SettingsWin.vue?vue&type=style&index=0&id=5d223b0e&scoped=true&lang=css&");
/* harmony import */ var _node_modules_vue_loader_lib_runtime_componentNormalizer_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! !../../../node_modules/vue-loader/lib/runtime/componentNormalizer.js */ "./node_modules/vue-loader/lib/runtime/componentNormalizer.js");



;


/* normalize component */

var component = (0,_node_modules_vue_loader_lib_runtime_componentNormalizer_js__WEBPACK_IMPORTED_MODULE_3__["default"])(
  _SettingsWin_vue_vue_type_script_lang_js___WEBPACK_IMPORTED_MODULE_1__["default"],
  _SettingsWin_vue_vue_type_template_id_5d223b0e_scoped_true___WEBPACK_IMPORTED_MODULE_0__.render,
  _SettingsWin_vue_vue_type_template_id_5d223b0e_scoped_true___WEBPACK_IMPORTED_MODULE_0__.staticRenderFns,
  false,
  null,
  "5d223b0e",
  null
  
)

/* hot reload */
if (false) { var api; }
component.options.__file = "src/extensions/settings-win/SettingsWin.vue"
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (component.exports);

/***/ }),

/***/ "./src/Main.vue?vue&type=script&lang=js&":
/*!***********************************************!*\
  !*** ./src/Main.vue?vue&type=script&lang=js& ***!
  \***********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _node_modules_babel_loader_lib_index_js_clonedRuleSet_5_0_rules_0_use_0_node_modules_vue_loader_lib_index_js_vue_loader_options_Main_vue_vue_type_script_lang_js___WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! -!../node_modules/babel-loader/lib/index.js??clonedRuleSet-5[0].rules[0].use[0]!../node_modules/vue-loader/lib/index.js??vue-loader-options!./Main.vue?vue&type=script&lang=js& */ "./node_modules/babel-loader/lib/index.js??clonedRuleSet-5[0].rules[0].use[0]!./node_modules/vue-loader/lib/index.js??vue-loader-options!./src/Main.vue?vue&type=script&lang=js&");
 /* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (_node_modules_babel_loader_lib_index_js_clonedRuleSet_5_0_rules_0_use_0_node_modules_vue_loader_lib_index_js_vue_loader_options_Main_vue_vue_type_script_lang_js___WEBPACK_IMPORTED_MODULE_0__["default"]); 

/***/ }),

/***/ "./src/components/StdInput.vue?vue&type=script&lang=js&":
/*!**************************************************************!*\
  !*** ./src/components/StdInput.vue?vue&type=script&lang=js& ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _node_modules_babel_loader_lib_index_js_clonedRuleSet_5_0_rules_0_use_0_node_modules_vue_loader_lib_index_js_vue_loader_options_StdInput_vue_vue_type_script_lang_js___WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! -!../../node_modules/babel-loader/lib/index.js??clonedRuleSet-5[0].rules[0].use[0]!../../node_modules/vue-loader/lib/index.js??vue-loader-options!./StdInput.vue?vue&type=script&lang=js& */ "./node_modules/babel-loader/lib/index.js??clonedRuleSet-5[0].rules[0].use[0]!./node_modules/vue-loader/lib/index.js??vue-loader-options!./src/components/StdInput.vue?vue&type=script&lang=js&");
 /* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (_node_modules_babel_loader_lib_index_js_clonedRuleSet_5_0_rules_0_use_0_node_modules_vue_loader_lib_index_js_vue_loader_options_StdInput_vue_vue_type_script_lang_js___WEBPACK_IMPORTED_MODULE_0__["default"]); 

/***/ }),

/***/ "./src/components/Window.vue?vue&type=script&lang=js&":
/*!************************************************************!*\
  !*** ./src/components/Window.vue?vue&type=script&lang=js& ***!
  \************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _node_modules_babel_loader_lib_index_js_clonedRuleSet_5_0_rules_0_use_0_node_modules_vue_loader_lib_index_js_vue_loader_options_Window_vue_vue_type_script_lang_js___WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! -!../../node_modules/babel-loader/lib/index.js??clonedRuleSet-5[0].rules[0].use[0]!../../node_modules/vue-loader/lib/index.js??vue-loader-options!./Window.vue?vue&type=script&lang=js& */ "./node_modules/babel-loader/lib/index.js??clonedRuleSet-5[0].rules[0].use[0]!./node_modules/vue-loader/lib/index.js??vue-loader-options!./src/components/Window.vue?vue&type=script&lang=js&");
 /* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (_node_modules_babel_loader_lib_index_js_clonedRuleSet_5_0_rules_0_use_0_node_modules_vue_loader_lib_index_js_vue_loader_options_Window_vue_vue_type_script_lang_js___WEBPACK_IMPORTED_MODULE_0__["default"]); 

/***/ }),

/***/ "./src/extensions/grid-resize/Splitter.vue?vue&type=script&lang=js&":
/*!**************************************************************************!*\
  !*** ./src/extensions/grid-resize/Splitter.vue?vue&type=script&lang=js& ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _node_modules_babel_loader_lib_index_js_clonedRuleSet_5_0_rules_0_use_0_node_modules_vue_loader_lib_index_js_vue_loader_options_Splitter_vue_vue_type_script_lang_js___WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! -!../../../node_modules/babel-loader/lib/index.js??clonedRuleSet-5[0].rules[0].use[0]!../../../node_modules/vue-loader/lib/index.js??vue-loader-options!./Splitter.vue?vue&type=script&lang=js& */ "./node_modules/babel-loader/lib/index.js??clonedRuleSet-5[0].rules[0].use[0]!./node_modules/vue-loader/lib/index.js??vue-loader-options!./src/extensions/grid-resize/Splitter.vue?vue&type=script&lang=js&");
 /* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (_node_modules_babel_loader_lib_index_js_clonedRuleSet_5_0_rules_0_use_0_node_modules_vue_loader_lib_index_js_vue_loader_options_Splitter_vue_vue_type_script_lang_js___WEBPACK_IMPORTED_MODULE_0__["default"]); 

/***/ }),

/***/ "./src/extensions/legend-buttons/AddWin.vue?vue&type=script&lang=js&":
/*!***************************************************************************!*\
  !*** ./src/extensions/legend-buttons/AddWin.vue?vue&type=script&lang=js& ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _node_modules_babel_loader_lib_index_js_clonedRuleSet_5_0_rules_0_use_0_node_modules_vue_loader_lib_index_js_vue_loader_options_AddWin_vue_vue_type_script_lang_js___WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! -!../../../node_modules/babel-loader/lib/index.js??clonedRuleSet-5[0].rules[0].use[0]!../../../node_modules/vue-loader/lib/index.js??vue-loader-options!./AddWin.vue?vue&type=script&lang=js& */ "./node_modules/babel-loader/lib/index.js??clonedRuleSet-5[0].rules[0].use[0]!./node_modules/vue-loader/lib/index.js??vue-loader-options!./src/extensions/legend-buttons/AddWin.vue?vue&type=script&lang=js&");
 /* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (_node_modules_babel_loader_lib_index_js_clonedRuleSet_5_0_rules_0_use_0_node_modules_vue_loader_lib_index_js_vue_loader_options_AddWin_vue_vue_type_script_lang_js___WEBPACK_IMPORTED_MODULE_0__["default"]); 

/***/ }),

/***/ "./src/extensions/settings-win/SettingsWin.vue?vue&type=script&lang=js&":
/*!******************************************************************************!*\
  !*** ./src/extensions/settings-win/SettingsWin.vue?vue&type=script&lang=js& ***!
  \******************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _node_modules_babel_loader_lib_index_js_clonedRuleSet_5_0_rules_0_use_0_node_modules_vue_loader_lib_index_js_vue_loader_options_SettingsWin_vue_vue_type_script_lang_js___WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! -!../../../node_modules/babel-loader/lib/index.js??clonedRuleSet-5[0].rules[0].use[0]!../../../node_modules/vue-loader/lib/index.js??vue-loader-options!./SettingsWin.vue?vue&type=script&lang=js& */ "./node_modules/babel-loader/lib/index.js??clonedRuleSet-5[0].rules[0].use[0]!./node_modules/vue-loader/lib/index.js??vue-loader-options!./src/extensions/settings-win/SettingsWin.vue?vue&type=script&lang=js&");
 /* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (_node_modules_babel_loader_lib_index_js_clonedRuleSet_5_0_rules_0_use_0_node_modules_vue_loader_lib_index_js_vue_loader_options_SettingsWin_vue_vue_type_script_lang_js___WEBPACK_IMPORTED_MODULE_0__["default"]); 

/***/ }),

/***/ "./src/Main.vue?vue&type=style&index=0&lang=css&":
/*!*******************************************************!*\
  !*** ./src/Main.vue?vue&type=style&index=0&lang=css& ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _node_modules_style_loader_dist_cjs_js_node_modules_laravel_mix_node_modules_css_loader_dist_cjs_js_clonedRuleSet_65_0_rules_0_use_1_node_modules_vue_loader_lib_loaders_stylePostLoader_js_node_modules_postcss_loader_dist_cjs_js_clonedRuleSet_65_0_rules_0_use_2_node_modules_vue_loader_lib_index_js_vue_loader_options_Main_vue_vue_type_style_index_0_lang_css___WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! -!../node_modules/style-loader/dist/cjs.js!../node_modules/laravel-mix/node_modules/css-loader/dist/cjs.js??clonedRuleSet-65[0].rules[0].use[1]!../node_modules/vue-loader/lib/loaders/stylePostLoader.js!../node_modules/postcss-loader/dist/cjs.js??clonedRuleSet-65[0].rules[0].use[2]!../node_modules/vue-loader/lib/index.js??vue-loader-options!./Main.vue?vue&type=style&index=0&lang=css& */ "./node_modules/style-loader/dist/cjs.js!./node_modules/laravel-mix/node_modules/css-loader/dist/cjs.js??clonedRuleSet-65[0].rules[0].use[1]!./node_modules/vue-loader/lib/loaders/stylePostLoader.js!./node_modules/postcss-loader/dist/cjs.js??clonedRuleSet-65[0].rules[0].use[2]!./node_modules/vue-loader/lib/index.js??vue-loader-options!./src/Main.vue?vue&type=style&index=0&lang=css&");


/***/ }),

/***/ "./src/components/StdInput.vue?vue&type=style&index=0&lang=css&":
/*!**********************************************************************!*\
  !*** ./src/components/StdInput.vue?vue&type=style&index=0&lang=css& ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _node_modules_style_loader_dist_cjs_js_node_modules_laravel_mix_node_modules_css_loader_dist_cjs_js_clonedRuleSet_65_0_rules_0_use_1_node_modules_vue_loader_lib_loaders_stylePostLoader_js_node_modules_postcss_loader_dist_cjs_js_clonedRuleSet_65_0_rules_0_use_2_node_modules_vue_loader_lib_index_js_vue_loader_options_StdInput_vue_vue_type_style_index_0_lang_css___WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! -!../../node_modules/style-loader/dist/cjs.js!../../node_modules/laravel-mix/node_modules/css-loader/dist/cjs.js??clonedRuleSet-65[0].rules[0].use[1]!../../node_modules/vue-loader/lib/loaders/stylePostLoader.js!../../node_modules/postcss-loader/dist/cjs.js??clonedRuleSet-65[0].rules[0].use[2]!../../node_modules/vue-loader/lib/index.js??vue-loader-options!./StdInput.vue?vue&type=style&index=0&lang=css& */ "./node_modules/style-loader/dist/cjs.js!./node_modules/laravel-mix/node_modules/css-loader/dist/cjs.js??clonedRuleSet-65[0].rules[0].use[1]!./node_modules/vue-loader/lib/loaders/stylePostLoader.js!./node_modules/postcss-loader/dist/cjs.js??clonedRuleSet-65[0].rules[0].use[2]!./node_modules/vue-loader/lib/index.js??vue-loader-options!./src/components/StdInput.vue?vue&type=style&index=0&lang=css&");


/***/ }),

/***/ "./src/components/Window.vue?vue&type=style&index=0&lang=css&":
/*!********************************************************************!*\
  !*** ./src/components/Window.vue?vue&type=style&index=0&lang=css& ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _node_modules_style_loader_dist_cjs_js_node_modules_laravel_mix_node_modules_css_loader_dist_cjs_js_clonedRuleSet_65_0_rules_0_use_1_node_modules_vue_loader_lib_loaders_stylePostLoader_js_node_modules_postcss_loader_dist_cjs_js_clonedRuleSet_65_0_rules_0_use_2_node_modules_vue_loader_lib_index_js_vue_loader_options_Window_vue_vue_type_style_index_0_lang_css___WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! -!../../node_modules/style-loader/dist/cjs.js!../../node_modules/laravel-mix/node_modules/css-loader/dist/cjs.js??clonedRuleSet-65[0].rules[0].use[1]!../../node_modules/vue-loader/lib/loaders/stylePostLoader.js!../../node_modules/postcss-loader/dist/cjs.js??clonedRuleSet-65[0].rules[0].use[2]!../../node_modules/vue-loader/lib/index.js??vue-loader-options!./Window.vue?vue&type=style&index=0&lang=css& */ "./node_modules/style-loader/dist/cjs.js!./node_modules/laravel-mix/node_modules/css-loader/dist/cjs.js??clonedRuleSet-65[0].rules[0].use[1]!./node_modules/vue-loader/lib/loaders/stylePostLoader.js!./node_modules/postcss-loader/dist/cjs.js??clonedRuleSet-65[0].rules[0].use[2]!./node_modules/vue-loader/lib/index.js??vue-loader-options!./src/components/Window.vue?vue&type=style&index=0&lang=css&");


/***/ }),

/***/ "./src/extensions/grid-resize/Splitter.vue?vue&type=style&index=0&id=189fccad&scoped=true&lang=css&":
/*!**********************************************************************************************************!*\
  !*** ./src/extensions/grid-resize/Splitter.vue?vue&type=style&index=0&id=189fccad&scoped=true&lang=css& ***!
  \**********************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _node_modules_style_loader_dist_cjs_js_node_modules_laravel_mix_node_modules_css_loader_dist_cjs_js_clonedRuleSet_65_0_rules_0_use_1_node_modules_vue_loader_lib_loaders_stylePostLoader_js_node_modules_postcss_loader_dist_cjs_js_clonedRuleSet_65_0_rules_0_use_2_node_modules_vue_loader_lib_index_js_vue_loader_options_Splitter_vue_vue_type_style_index_0_id_189fccad_scoped_true_lang_css___WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! -!../../../node_modules/style-loader/dist/cjs.js!../../../node_modules/laravel-mix/node_modules/css-loader/dist/cjs.js??clonedRuleSet-65[0].rules[0].use[1]!../../../node_modules/vue-loader/lib/loaders/stylePostLoader.js!../../../node_modules/postcss-loader/dist/cjs.js??clonedRuleSet-65[0].rules[0].use[2]!../../../node_modules/vue-loader/lib/index.js??vue-loader-options!./Splitter.vue?vue&type=style&index=0&id=189fccad&scoped=true&lang=css& */ "./node_modules/style-loader/dist/cjs.js!./node_modules/laravel-mix/node_modules/css-loader/dist/cjs.js??clonedRuleSet-65[0].rules[0].use[1]!./node_modules/vue-loader/lib/loaders/stylePostLoader.js!./node_modules/postcss-loader/dist/cjs.js??clonedRuleSet-65[0].rules[0].use[2]!./node_modules/vue-loader/lib/index.js??vue-loader-options!./src/extensions/grid-resize/Splitter.vue?vue&type=style&index=0&id=189fccad&scoped=true&lang=css&");


/***/ }),

/***/ "./src/extensions/legend-buttons/AddWin.vue?vue&type=style&index=0&id=53408ac7&scoped=true&lang=css&":
/*!***********************************************************************************************************!*\
  !*** ./src/extensions/legend-buttons/AddWin.vue?vue&type=style&index=0&id=53408ac7&scoped=true&lang=css& ***!
  \***********************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _node_modules_style_loader_dist_cjs_js_node_modules_laravel_mix_node_modules_css_loader_dist_cjs_js_clonedRuleSet_65_0_rules_0_use_1_node_modules_vue_loader_lib_loaders_stylePostLoader_js_node_modules_postcss_loader_dist_cjs_js_clonedRuleSet_65_0_rules_0_use_2_node_modules_vue_loader_lib_index_js_vue_loader_options_AddWin_vue_vue_type_style_index_0_id_53408ac7_scoped_true_lang_css___WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! -!../../../node_modules/style-loader/dist/cjs.js!../../../node_modules/laravel-mix/node_modules/css-loader/dist/cjs.js??clonedRuleSet-65[0].rules[0].use[1]!../../../node_modules/vue-loader/lib/loaders/stylePostLoader.js!../../../node_modules/postcss-loader/dist/cjs.js??clonedRuleSet-65[0].rules[0].use[2]!../../../node_modules/vue-loader/lib/index.js??vue-loader-options!./AddWin.vue?vue&type=style&index=0&id=53408ac7&scoped=true&lang=css& */ "./node_modules/style-loader/dist/cjs.js!./node_modules/laravel-mix/node_modules/css-loader/dist/cjs.js??clonedRuleSet-65[0].rules[0].use[1]!./node_modules/vue-loader/lib/loaders/stylePostLoader.js!./node_modules/postcss-loader/dist/cjs.js??clonedRuleSet-65[0].rules[0].use[2]!./node_modules/vue-loader/lib/index.js??vue-loader-options!./src/extensions/legend-buttons/AddWin.vue?vue&type=style&index=0&id=53408ac7&scoped=true&lang=css&");


/***/ }),

/***/ "./src/extensions/settings-win/SettingsWin.vue?vue&type=style&index=0&id=5d223b0e&scoped=true&lang=css&":
/*!**************************************************************************************************************!*\
  !*** ./src/extensions/settings-win/SettingsWin.vue?vue&type=style&index=0&id=5d223b0e&scoped=true&lang=css& ***!
  \**************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _node_modules_style_loader_dist_cjs_js_node_modules_laravel_mix_node_modules_css_loader_dist_cjs_js_clonedRuleSet_65_0_rules_0_use_1_node_modules_vue_loader_lib_loaders_stylePostLoader_js_node_modules_postcss_loader_dist_cjs_js_clonedRuleSet_65_0_rules_0_use_2_node_modules_vue_loader_lib_index_js_vue_loader_options_SettingsWin_vue_vue_type_style_index_0_id_5d223b0e_scoped_true_lang_css___WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! -!../../../node_modules/style-loader/dist/cjs.js!../../../node_modules/laravel-mix/node_modules/css-loader/dist/cjs.js??clonedRuleSet-65[0].rules[0].use[1]!../../../node_modules/vue-loader/lib/loaders/stylePostLoader.js!../../../node_modules/postcss-loader/dist/cjs.js??clonedRuleSet-65[0].rules[0].use[2]!../../../node_modules/vue-loader/lib/index.js??vue-loader-options!./SettingsWin.vue?vue&type=style&index=0&id=5d223b0e&scoped=true&lang=css& */ "./node_modules/style-loader/dist/cjs.js!./node_modules/laravel-mix/node_modules/css-loader/dist/cjs.js??clonedRuleSet-65[0].rules[0].use[1]!./node_modules/vue-loader/lib/loaders/stylePostLoader.js!./node_modules/postcss-loader/dist/cjs.js??clonedRuleSet-65[0].rules[0].use[2]!./node_modules/vue-loader/lib/index.js??vue-loader-options!./src/extensions/settings-win/SettingsWin.vue?vue&type=style&index=0&id=5d223b0e&scoped=true&lang=css&");


/***/ }),

/***/ "./src/Main.vue?vue&type=template&id=3ffae6b2&":
/*!*****************************************************!*\
  !*** ./src/Main.vue?vue&type=template&id=3ffae6b2& ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "render": () => (/* reexport safe */ _node_modules_vue_loader_lib_loaders_templateLoader_js_vue_loader_options_node_modules_vue_loader_lib_index_js_vue_loader_options_Main_vue_vue_type_template_id_3ffae6b2___WEBPACK_IMPORTED_MODULE_0__.render),
/* harmony export */   "staticRenderFns": () => (/* reexport safe */ _node_modules_vue_loader_lib_loaders_templateLoader_js_vue_loader_options_node_modules_vue_loader_lib_index_js_vue_loader_options_Main_vue_vue_type_template_id_3ffae6b2___WEBPACK_IMPORTED_MODULE_0__.staticRenderFns)
/* harmony export */ });
/* harmony import */ var _node_modules_vue_loader_lib_loaders_templateLoader_js_vue_loader_options_node_modules_vue_loader_lib_index_js_vue_loader_options_Main_vue_vue_type_template_id_3ffae6b2___WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! -!../node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!../node_modules/vue-loader/lib/index.js??vue-loader-options!./Main.vue?vue&type=template&id=3ffae6b2& */ "./node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!./node_modules/vue-loader/lib/index.js??vue-loader-options!./src/Main.vue?vue&type=template&id=3ffae6b2&");


/***/ }),

/***/ "./src/components/StdInput.vue?vue&type=template&id=5e1f1c17&":
/*!********************************************************************!*\
  !*** ./src/components/StdInput.vue?vue&type=template&id=5e1f1c17& ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "render": () => (/* reexport safe */ _node_modules_vue_loader_lib_loaders_templateLoader_js_vue_loader_options_node_modules_vue_loader_lib_index_js_vue_loader_options_StdInput_vue_vue_type_template_id_5e1f1c17___WEBPACK_IMPORTED_MODULE_0__.render),
/* harmony export */   "staticRenderFns": () => (/* reexport safe */ _node_modules_vue_loader_lib_loaders_templateLoader_js_vue_loader_options_node_modules_vue_loader_lib_index_js_vue_loader_options_StdInput_vue_vue_type_template_id_5e1f1c17___WEBPACK_IMPORTED_MODULE_0__.staticRenderFns)
/* harmony export */ });
/* harmony import */ var _node_modules_vue_loader_lib_loaders_templateLoader_js_vue_loader_options_node_modules_vue_loader_lib_index_js_vue_loader_options_StdInput_vue_vue_type_template_id_5e1f1c17___WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! -!../../node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!../../node_modules/vue-loader/lib/index.js??vue-loader-options!./StdInput.vue?vue&type=template&id=5e1f1c17& */ "./node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!./node_modules/vue-loader/lib/index.js??vue-loader-options!./src/components/StdInput.vue?vue&type=template&id=5e1f1c17&");


/***/ }),

/***/ "./src/components/Window.vue?vue&type=template&id=5b030a20&":
/*!******************************************************************!*\
  !*** ./src/components/Window.vue?vue&type=template&id=5b030a20& ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "render": () => (/* reexport safe */ _node_modules_vue_loader_lib_loaders_templateLoader_js_vue_loader_options_node_modules_vue_loader_lib_index_js_vue_loader_options_Window_vue_vue_type_template_id_5b030a20___WEBPACK_IMPORTED_MODULE_0__.render),
/* harmony export */   "staticRenderFns": () => (/* reexport safe */ _node_modules_vue_loader_lib_loaders_templateLoader_js_vue_loader_options_node_modules_vue_loader_lib_index_js_vue_loader_options_Window_vue_vue_type_template_id_5b030a20___WEBPACK_IMPORTED_MODULE_0__.staticRenderFns)
/* harmony export */ });
/* harmony import */ var _node_modules_vue_loader_lib_loaders_templateLoader_js_vue_loader_options_node_modules_vue_loader_lib_index_js_vue_loader_options_Window_vue_vue_type_template_id_5b030a20___WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! -!../../node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!../../node_modules/vue-loader/lib/index.js??vue-loader-options!./Window.vue?vue&type=template&id=5b030a20& */ "./node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!./node_modules/vue-loader/lib/index.js??vue-loader-options!./src/components/Window.vue?vue&type=template&id=5b030a20&");


/***/ }),

/***/ "./src/extensions/grid-resize/Splitter.vue?vue&type=template&id=189fccad&scoped=true&":
/*!********************************************************************************************!*\
  !*** ./src/extensions/grid-resize/Splitter.vue?vue&type=template&id=189fccad&scoped=true& ***!
  \********************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "render": () => (/* reexport safe */ _node_modules_vue_loader_lib_loaders_templateLoader_js_vue_loader_options_node_modules_vue_loader_lib_index_js_vue_loader_options_Splitter_vue_vue_type_template_id_189fccad_scoped_true___WEBPACK_IMPORTED_MODULE_0__.render),
/* harmony export */   "staticRenderFns": () => (/* reexport safe */ _node_modules_vue_loader_lib_loaders_templateLoader_js_vue_loader_options_node_modules_vue_loader_lib_index_js_vue_loader_options_Splitter_vue_vue_type_template_id_189fccad_scoped_true___WEBPACK_IMPORTED_MODULE_0__.staticRenderFns)
/* harmony export */ });
/* harmony import */ var _node_modules_vue_loader_lib_loaders_templateLoader_js_vue_loader_options_node_modules_vue_loader_lib_index_js_vue_loader_options_Splitter_vue_vue_type_template_id_189fccad_scoped_true___WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! -!../../../node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!../../../node_modules/vue-loader/lib/index.js??vue-loader-options!./Splitter.vue?vue&type=template&id=189fccad&scoped=true& */ "./node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!./node_modules/vue-loader/lib/index.js??vue-loader-options!./src/extensions/grid-resize/Splitter.vue?vue&type=template&id=189fccad&scoped=true&");


/***/ }),

/***/ "./src/extensions/legend-buttons/AddWin.vue?vue&type=template&id=53408ac7&scoped=true&":
/*!*********************************************************************************************!*\
  !*** ./src/extensions/legend-buttons/AddWin.vue?vue&type=template&id=53408ac7&scoped=true& ***!
  \*********************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "render": () => (/* reexport safe */ _node_modules_vue_loader_lib_loaders_templateLoader_js_vue_loader_options_node_modules_vue_loader_lib_index_js_vue_loader_options_AddWin_vue_vue_type_template_id_53408ac7_scoped_true___WEBPACK_IMPORTED_MODULE_0__.render),
/* harmony export */   "staticRenderFns": () => (/* reexport safe */ _node_modules_vue_loader_lib_loaders_templateLoader_js_vue_loader_options_node_modules_vue_loader_lib_index_js_vue_loader_options_AddWin_vue_vue_type_template_id_53408ac7_scoped_true___WEBPACK_IMPORTED_MODULE_0__.staticRenderFns)
/* harmony export */ });
/* harmony import */ var _node_modules_vue_loader_lib_loaders_templateLoader_js_vue_loader_options_node_modules_vue_loader_lib_index_js_vue_loader_options_AddWin_vue_vue_type_template_id_53408ac7_scoped_true___WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! -!../../../node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!../../../node_modules/vue-loader/lib/index.js??vue-loader-options!./AddWin.vue?vue&type=template&id=53408ac7&scoped=true& */ "./node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!./node_modules/vue-loader/lib/index.js??vue-loader-options!./src/extensions/legend-buttons/AddWin.vue?vue&type=template&id=53408ac7&scoped=true&");


/***/ }),

/***/ "./src/extensions/settings-win/SettingsWin.vue?vue&type=template&id=5d223b0e&scoped=true&":
/*!************************************************************************************************!*\
  !*** ./src/extensions/settings-win/SettingsWin.vue?vue&type=template&id=5d223b0e&scoped=true& ***!
  \************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "render": () => (/* reexport safe */ _node_modules_vue_loader_lib_loaders_templateLoader_js_vue_loader_options_node_modules_vue_loader_lib_index_js_vue_loader_options_SettingsWin_vue_vue_type_template_id_5d223b0e_scoped_true___WEBPACK_IMPORTED_MODULE_0__.render),
/* harmony export */   "staticRenderFns": () => (/* reexport safe */ _node_modules_vue_loader_lib_loaders_templateLoader_js_vue_loader_options_node_modules_vue_loader_lib_index_js_vue_loader_options_SettingsWin_vue_vue_type_template_id_5d223b0e_scoped_true___WEBPACK_IMPORTED_MODULE_0__.staticRenderFns)
/* harmony export */ });
/* harmony import */ var _node_modules_vue_loader_lib_loaders_templateLoader_js_vue_loader_options_node_modules_vue_loader_lib_index_js_vue_loader_options_SettingsWin_vue_vue_type_template_id_5d223b0e_scoped_true___WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! -!../../../node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!../../../node_modules/vue-loader/lib/index.js??vue-loader-options!./SettingsWin.vue?vue&type=template&id=5d223b0e&scoped=true& */ "./node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!./node_modules/vue-loader/lib/index.js??vue-loader-options!./src/extensions/settings-win/SettingsWin.vue?vue&type=template&id=5d223b0e&scoped=true&");


/***/ }),

/***/ "./node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!./node_modules/vue-loader/lib/index.js??vue-loader-options!./src/Main.vue?vue&type=template&id=3ffae6b2&":
/*!********************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!./node_modules/vue-loader/lib/index.js??vue-loader-options!./src/Main.vue?vue&type=template&id=3ffae6b2& ***!
  \********************************************************************************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "render": () => (/* binding */ render),
/* harmony export */   "staticRenderFns": () => (/* binding */ staticRenderFns)
/* harmony export */ });
var render = function () {
  var _vm = this
  var _h = _vm.$createElement
  var _c = _vm._self._c || _h
  return _c(
    "div",
    {
      staticClass:
        "flex-start col-10 col-xll-10 col-xl-10 col-lg-10 col-md-9 col-sm-12",
    },
    [
      _c("div", { attrs: { id: "tvjs-header" } }, [
        _c("a", [
          _c(
            "span",
            {
              staticClass: "me-1 badge bg-light-secondary",
              on: { click: _vm.candles },
            },
            [
              _c("i", { staticClass: "bi bi-bar-chart" }),
              _c("div", { staticClass: "d-md-inline d-none" }, [
                _vm._v("  Candles"),
              ]),
            ]
          ),
        ]),
        _vm._v(" "),
        _c("a", [
          _c(
            "span",
            {
              staticClass: "me-1 badge bg-light-secondary",
              on: { click: _vm.spline },
            },
            [
              _c("i", { staticClass: "bi bi-graph-up" }),
              _c("div", { staticClass: "d-md-inline d-none" }, [
                _vm._v("  Spline"),
              ]),
            ]
          ),
        ]),
        _vm._v(" "),
        _vm._m(0),
        _vm._v(" "),
        _vm._m(1),
        _vm._v(" "),
        _vm._m(2),
      ]),
      _vm._v(" "),
      _c(
        "div",
        {
          staticClass:
            "collapse col-lg-4 col-md-5 col-sm-6 position-absolute sticky-top card-110 ",
          attrs: { id: "collapseInfos" },
        },
        [
          _c(
            "div",
            {
              staticClass: "card",
              staticStyle: {
                background: "#131722e6!important",
                "box-shadow": "0 4px 24px 0 rgb(0 0 0 / 30%)",
              },
            },
            [
              _c("div", { staticClass: "card-header" }, [
                _c("div", { staticClass: "col-md-8" }, [
                  _c("h4", { staticClass: "card-title" }, [
                    _vm._v(
                      "\n                            " +
                        _vm._s(_vm.symbol) +
                        "\n                        "
                    ),
                  ]),
                ]),
              ]),
              _vm._v(" "),
              _vm._m(3),
            ]
          ),
        ]
      ),
      _vm._v(" "),
      _vm._m(4),
      _vm._v(" "),
      _vm._m(5),
      _vm._v(" "),
      _c(
        "div",
        { staticClass: "app-container", staticStyle: { "margin-top": "40px" } },
        [
          _c("trading-vue", {
            key: _vm.resetkey,
            ref: "tvjs",
            attrs: {
              data: _vm.dc,
              width: _vm.width,
              height: _vm.height,
              "title-txt": _vm.title,
              "color-title": "#ff9f43",
              "legend-buttons": [
                "display",
                "settings",
                "up",
                "down",
                "add",
                "remove",
              ],
              "chart-config": { DEFAULT_LEN: 60, MIN_ZOOM: 1 },
              toolbar: true,
              "color-back": _vm.colors.colorBack,
              "color-grid": _vm.colors.colorGrid,
              "color-text": _vm.colors.colorText,
              extensions: _vm.ext,
              overlays: _vm.ovs,
              night: _vm.night,
              resetkey: _vm.resetkey,
              "x-settings": _vm.xsett,
              timezone: _vm.timezone,
            },
          }),
        ],
        1
      ),
    ]
  )
}
var staticRenderFns = [
  function () {
    var _vm = this
    var _h = _vm.$createElement
    var _c = _vm._self._c || _h
    return _c("a", [
      _c(
        "span",
        {
          staticClass: "me-1 badge bg-light-info",
          attrs: {
            id: "toggleInfo",
            "data-bs-toggle": "collapse",
            "data-bs-target": "#collapseInfos",
            "aria-expanded": "false",
            "aria-controls": "collapseInfos",
          },
        },
        [
          _c("i", { staticClass: "bi bi-info-circle" }),
          _c("div", { staticClass: "d-md-inline d-none" }, [_vm._v("  Info")]),
        ]
      ),
    ])
  },
  function () {
    var _vm = this
    var _h = _vm.$createElement
    var _c = _vm._self._c || _h
    return _c("a", [
      _c(
        "span",
        {
          staticClass: "me-1 badge bg-light-primary ",
          attrs: {
            id: "toggleDepth",
            "data-bs-toggle": "collapse",
            "data-bs-target": "#collapseDepth",
            "aria-expanded": "false",
            "aria-controls": "collapseDepth",
          },
        },
        [
          _c("i", { staticClass: "bi bi-kanban" }),
          _c("div", { staticClass: "d-md-inline d-none" }, [
            _vm._v("  Depth View"),
          ]),
        ]
      ),
    ])
  },
  function () {
    var _vm = this
    var _h = _vm.$createElement
    var _c = _vm._self._c || _h
    return _c("a", [
      _c(
        "span",
        {
          staticClass: "me-1 badge bg-light-warning ",
          attrs: {
            id: "toggleOrders",
            "data-bs-toggle": "collapse",
            "data-bs-target": "#collapseOrders",
            "aria-expanded": "false",
            "aria-controls": "collapseOrders",
          },
        },
        [
          _c("i", { staticClass: "bi bi-file-bar-graph" }),
          _c("div", { staticClass: "d-md-inline d-none" }, [
            _vm._v("  Order Book"),
          ]),
        ]
      ),
    ])
  },
  function () {
    var _vm = this
    var _h = _vm.$createElement
    var _c = _vm._self._c || _h
    return _c("div", { staticClass: "card-content" }, [
      _c("div", { staticClass: "card-body" }, [
        _c("div", { staticClass: "row" }, [
          _c("div", { staticClass: "col-8" }, [
            _c(
              "div",
              { staticClass: "text-start fs-1", attrs: { id: "show_b" } },
              [
                _vm._v(
                  "\n                                    ...\n                                "
                ),
              ]
            ),
          ]),
          _vm._v(" "),
          _c("div", { staticClass: "col-4" }, [
            _c(
              "div",
              {
                staticClass: "text-end",
                staticStyle: { "font-size": "14px" },
                attrs: { id: "show_p" },
              },
              [
                _vm._v(
                  "\n                                    ...\n                                "
                ),
              ]
            ),
            _vm._v(" "),
            _c(
              "div",
              {
                staticClass: "text-end",
                staticStyle: { "font-size": "14px" },
                attrs: { id: "show_P" },
              },
              [
                _vm._v(
                  "\n                                    ...\n                                "
                ),
              ]
            ),
          ]),
        ]),
        _vm._v(" "),
        _c("div", { staticClass: "row mt-1" }, [
          _c(
            "div",
            { staticClass: "progress", attrs: { id: "myRangeColor" } },
            [
              _c("div", {
                staticClass:
                  "progress-bar progress-bar-striped progress-bar-animated",
                staticStyle: { width: "80%" },
                attrs: {
                  id: "myRange",
                  role: "progressbar",
                  "aria-valuenow": "50",
                  "aria-valuemin": "0",
                  "aria-valuemax": "100",
                },
              }),
            ]
          ),
        ]),
        _vm._v(" "),
        _c(
          "div",
          {
            staticClass:
              "row d-flex justify-content-between align-items-center",
          },
          [
            _c("div", {
              staticClass: "col text-start text-danger",
              staticStyle: { "font-size": "10px" },
              attrs: { id: "show_l" },
            }),
            _vm._v(" "),
            _c(
              "div",
              {
                staticClass: "col text-dark text-center",
                staticStyle: { "font-size": "10px" },
              },
              [
                _vm._v(
                  "\n                                Day Range\n                            "
                ),
              ]
            ),
            _vm._v(" "),
            _c("div", {
              staticClass: "col text-end text-success",
              staticStyle: { "font-size": "10px" },
              attrs: { id: "show_h" },
            }),
          ]
        ),
        _vm._v(" "),
        _c("div", { staticClass: "row mt-1" }, [
          _c("small", { staticClass: "col text-start text-dark clearfix" }, [
            _vm._v("Volume 24H"),
          ]),
          _vm._v(" "),
          _c("small", {
            staticClass: "col text-end text-warning clearfix",
            attrs: { id: "show_v" },
          }),
          _vm._v(" "),
          _c("hr"),
        ]),
        _vm._v(" "),
        _c("div", { staticClass: "row" }, [
          _c("small", { staticClass: "col text-start text-dark clearfix" }, [
            _vm._v("Market Cap"),
          ]),
          _vm._v(" "),
          _c("small", {
            staticClass: "col text-end text-warning clearfix",
            attrs: { id: "show_mc" },
          }),
          _vm._v(" "),
          _c("hr"),
        ]),
        _vm._v(" "),
        _c("div", { staticClass: "row" }, [
          _c("small", { staticClass: "col text-start text-dark clearfix" }, [
            _vm._v("Total Supply"),
          ]),
          _vm._v(" "),
          _c("small", {
            staticClass: "col text-end text-warning clearfix",
            attrs: { id: "show_ts" },
          }),
          _vm._v(" "),
          _c("hr"),
        ]),
      ]),
    ])
  },
  function () {
    var _vm = this
    var _h = _vm.$createElement
    var _c = _vm._self._c || _h
    return _c(
      "div",
      {
        staticClass:
          "collapse col-lg-6 col-md-10 col-sm-12 col-12 position-absolute sticky-top card-110 ",
        attrs: { id: "collapseDepth" },
      },
      [
        _c(
          "div",
          {
            staticClass: "card",
            staticStyle: {
              background: "#131722e6!important",
              "box-shadow": "0 4px 24px 0 rgb(0 0 0 / 30%)",
            },
          },
          [
            _c("div", { staticClass: "card-content" }, [
              _c("div", { attrs: { id: "chartdiv" } }),
            ]),
          ]
        ),
      ]
    )
  },
  function () {
    var _vm = this
    var _h = _vm.$createElement
    var _c = _vm._self._c || _h
    return _c(
      "div",
      {
        staticClass:
          "collapse col-lg-4 col-md-4 col-sm-6 col-12 position-absolute sticky-top card-110",
        staticStyle: { "max-width": "280px" },
        attrs: { id: "collapseOrders" },
      },
      [
        _c(
          "div",
          {
            staticClass: "card",
            staticStyle: {
              background: "#131722e6!important",
              "box-shadow": "0 4px 24px 0 rgb(0 0 0 / 30%)",
            },
          },
          [
            _c("div", { staticClass: "card-content my-1" }, [
              _c("div", { staticClass: "box" }, [
                _c("table", [
                  _c("thead", [
                    _c("tr", { staticClass: "mb-1" }, [
                      _c("th", { staticClass: "text-start ps-1 text-dark" }, [
                        _vm._v(
                          "\n                                        Price\n                                    "
                        ),
                      ]),
                      _vm._v(" "),
                      _c("th", { staticClass: "text-center ps-1 text-dark" }, [
                        _vm._v(
                          "\n                                        Quantity\n                                    "
                        ),
                      ]),
                      _vm._v(" "),
                      _c("th", { staticClass: "text-end pe-1 text-dark" }, [
                        _vm._v(
                          "\n                                        Total\n                                    "
                        ),
                      ]),
                    ]),
                  ]),
                ]),
                _vm._v(" "),
                _c("table", { staticClass: "asks" }),
                _vm._v(" "),
                _c("div", { staticClass: "newest" }),
                _vm._v(" "),
                _c("table", { staticClass: "bids" }),
              ]),
            ]),
          ]
        ),
      ]
    )
  },
]
render._withStripped = true



/***/ }),

/***/ "./node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!./node_modules/vue-loader/lib/index.js??vue-loader-options!./src/components/StdInput.vue?vue&type=template&id=5e1f1c17&":
/*!***********************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!./node_modules/vue-loader/lib/index.js??vue-loader-options!./src/components/StdInput.vue?vue&type=template&id=5e1f1c17& ***!
  \***********************************************************************************************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "render": () => (/* binding */ render),
/* harmony export */   "staticRenderFns": () => (/* binding */ staticRenderFns)
/* harmony export */ });
var render = function () {
  var _vm = this
  var _h = _vm.$createElement
  var _c = _vm._self._c || _h
  return _c("span", [
    _vm.type === "text" || !_vm.type
      ? _c("input", {
          staticClass: "tvjs-std-input",
          style: _vm.style,
          attrs: { placeholder: _vm.name },
          domProps: { value: _vm.value },
          on: {
            change: function ($event) {
              return _vm.$emit("change", $event.target.value)
            },
            input: function ($event) {
              return _vm.$emit("input", $event.target.value)
            },
          },
        })
      : _vm.type === "select"
      ? _c(
          "select",
          {
            staticClass: "tvjs-std-input",
            style: _vm.style,
            domProps: { value: _vm.value },
            on: {
              input: function ($event) {
                return _vm.$emit("input", $event.target.value)
              },
            },
          },
          _vm._l(_vm.list, function (opt) {
            return _c("option", [_vm._v(_vm._s(opt))])
          }),
          0
        )
      : _vm._e(),
  ])
}
var staticRenderFns = []
render._withStripped = true



/***/ }),

/***/ "./node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!./node_modules/vue-loader/lib/index.js??vue-loader-options!./src/components/Window.vue?vue&type=template&id=5b030a20&":
/*!*********************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!./node_modules/vue-loader/lib/index.js??vue-loader-options!./src/components/Window.vue?vue&type=template&id=5b030a20& ***!
  \*********************************************************************************************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "render": () => (/* binding */ render),
/* harmony export */   "staticRenderFns": () => (/* binding */ staticRenderFns)
/* harmony export */ });
var render = function () {
  var _vm = this
  var _h = _vm.$createElement
  var _c = _vm._self._c || _h
  return _c(
    "div",
    { ref: "win", staticClass: "tvjs-x-window", style: _vm.style },
    [
      _c("div", { staticClass: "tvjs-x-window-head" }, [
        _c(
          "div",
          {
            staticClass: "tvjs-x-window-title",
            on: { mousedown: _vm.onMouseDown },
          },
          [_vm._v("\n                " + _vm._s(_vm.title) + "\n            ")]
        ),
        _vm._v(" "),
        _c(
          "div",
          {
            staticClass: "tvjs-x-window-close",
            on: {
              click: function ($event) {
                return _vm.$emit("close")
              },
            },
          },
          [_vm._v("\n                \n            ")]
        ),
      ]),
      _vm._v(" "),
      _c("div", { staticClass: "tvjs-x-window-body" }, [_vm._t("default")], 2),
    ]
  )
}
var staticRenderFns = []
render._withStripped = true



/***/ }),

/***/ "./node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!./node_modules/vue-loader/lib/index.js??vue-loader-options!./src/extensions/grid-resize/Splitter.vue?vue&type=template&id=189fccad&scoped=true&":
/*!***********************************************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!./node_modules/vue-loader/lib/index.js??vue-loader-options!./src/extensions/grid-resize/Splitter.vue?vue&type=template&id=189fccad&scoped=true& ***!
  \***********************************************************************************************************************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "render": () => (/* binding */ render),
/* harmony export */   "staticRenderFns": () => (/* binding */ staticRenderFns)
/* harmony export */ });
var render = function () {
  var _vm = this
  var _h = _vm.$createElement
  var _c = _vm._self._c || _h
  return _c("span", {
    staticClass: "h-splitter",
    style: _vm.hs_style,
    on: { mousedown: _vm.hs_mousedown },
  })
}
var staticRenderFns = []
render._withStripped = true



/***/ }),

/***/ "./node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!./node_modules/vue-loader/lib/index.js??vue-loader-options!./src/extensions/legend-buttons/AddWin.vue?vue&type=template&id=53408ac7&scoped=true&":
/*!************************************************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!./node_modules/vue-loader/lib/index.js??vue-loader-options!./src/extensions/legend-buttons/AddWin.vue?vue&type=template&id=53408ac7&scoped=true& ***!
  \************************************************************************************************************************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "render": () => (/* binding */ render),
/* harmony export */   "staticRenderFns": () => (/* binding */ staticRenderFns)
/* harmony export */ });
var render = function () {
  var _vm = this
  var _h = _vm.$createElement
  var _c = _vm._self._c || _h
  return _c(
    "window",
    {
      staticClass: "add-win",
      attrs: { title: "Add Indicator", tv: _vm.tv },
      on: { close: _vm.on_close },
    },
    [
      _c(
        "div",
        { staticClass: "add-win-list" },
        _vm._l(_vm.ovs, function (ov) {
          return _c(
            "div",
            {
              staticClass: "add-win-item",
              on: {
                click: function ($event) {
                  return _vm.on_click(ov.name)
                },
              },
            },
            [
              _c("span", [_vm._v(_vm._s(ov.name))]),
              _vm._v(" "),
              _c("span", { staticClass: "add-win-item-desc" }, [
                _vm._v(
                  "\n                " +
                    _vm._s(ov.methods.meta_info().desc) +
                    "\n            "
                ),
              ]),
            ]
          )
        }),
        0
      ),
    ]
  )
}
var staticRenderFns = []
render._withStripped = true



/***/ }),

/***/ "./node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!./node_modules/vue-loader/lib/index.js??vue-loader-options!./src/extensions/settings-win/SettingsWin.vue?vue&type=template&id=5d223b0e&scoped=true&":
/*!***************************************************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!./node_modules/vue-loader/lib/index.js??vue-loader-options!./src/extensions/settings-win/SettingsWin.vue?vue&type=template&id=5d223b0e&scoped=true& ***!
  \***************************************************************************************************************************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "render": () => (/* binding */ render),
/* harmony export */   "staticRenderFns": () => (/* binding */ staticRenderFns)
/* harmony export */ });
var render = function () {
  var _vm = this
  var _h = _vm.$createElement
  var _c = _vm._self._c || _h
  return _c(
    "window",
    {
      staticClass: "sett-win",
      attrs: { title: _vm.data.ov.name, tv: _vm.tv },
      on: { close: _vm.on_close },
    },
    [
      _vm._l(_vm.settlist, function (k) {
        return _c(
          "div",
          { staticClass: "sett-win-item" },
          [
            _c("label", [_vm._v(_vm._s(_vm.s2d(k)))]),
            _vm._v(" "),
            _c("std-input", {
              attrs: { value: _vm.sett[k] },
              on: {
                input: function ($event) {
                  return _vm.update_sett(k, $event)
                },
              },
            }),
          ],
          1
        )
      }),
      _vm._v(" "),
      !_vm.settlist.length
        ? _c("span", { staticClass: "sett-win-empty" }, [
            _c("i", [_vm._v("No script settings")]),
          ])
        : _vm._e(),
    ],
    2
  )
}
var staticRenderFns = []
render._withStripped = true



/***/ }),

/***/ "./node_modules/vue-loader/lib/runtime/componentNormalizer.js":
/*!********************************************************************!*\
  !*** ./node_modules/vue-loader/lib/runtime/componentNormalizer.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ normalizeComponent)
/* harmony export */ });
/* globals __VUE_SSR_CONTEXT__ */

// IMPORTANT: Do NOT use ES2015 features in this file (except for modules).
// This module is a runtime utility for cleaner component module output and will
// be included in the final webpack user bundle.

function normalizeComponent (
  scriptExports,
  render,
  staticRenderFns,
  functionalTemplate,
  injectStyles,
  scopeId,
  moduleIdentifier, /* server only */
  shadowMode /* vue-cli only */
) {
  // Vue.extend constructor export interop
  var options = typeof scriptExports === 'function'
    ? scriptExports.options
    : scriptExports

  // render functions
  if (render) {
    options.render = render
    options.staticRenderFns = staticRenderFns
    options._compiled = true
  }

  // functional template
  if (functionalTemplate) {
    options.functional = true
  }

  // scopedId
  if (scopeId) {
    options._scopeId = 'data-v-' + scopeId
  }

  var hook
  if (moduleIdentifier) { // server build
    hook = function (context) {
      // 2.3 injection
      context =
        context || // cached call
        (this.$vnode && this.$vnode.ssrContext) || // stateful
        (this.parent && this.parent.$vnode && this.parent.$vnode.ssrContext) // functional
      // 2.2 with runInNewContext: true
      if (!context && typeof __VUE_SSR_CONTEXT__ !== 'undefined') {
        context = __VUE_SSR_CONTEXT__
      }
      // inject component styles
      if (injectStyles) {
        injectStyles.call(this, context)
      }
      // register component module identifier for async chunk inferrence
      if (context && context._registeredComponents) {
        context._registeredComponents.add(moduleIdentifier)
      }
    }
    // used by ssr in case component is cached and beforeCreate
    // never gets called
    options._ssrRegister = hook
  } else if (injectStyles) {
    hook = shadowMode
      ? function () {
        injectStyles.call(
          this,
          (options.functional ? this.parent : this).$root.$options.shadowRoot
        )
      }
      : injectStyles
  }

  if (hook) {
    if (options.functional) {
      // for template-only hot-reload because in that case the render fn doesn't
      // go through the normalizer
      options._injectStyles = hook
      // register for functional component in vue file
      var originalRender = options.render
      options.render = function renderWithStyleInjection (h, context) {
        hook.call(context)
        return originalRender(h, context)
      }
    } else {
      // inject component registration as beforeCreate hook
      var existing = options.beforeCreate
      options.beforeCreate = existing
        ? [].concat(existing, hook)
        : [hook]
    }
  }

  return {
    exports: scriptExports,
    options: options
  }
}


/***/ }),

/***/ "./node_modules/vue/dist/vue.esm.js":
/*!******************************************!*\
  !*** ./node_modules/vue/dist/vue.esm.js ***!
  \******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/*!
 * Vue.js v2.6.14
 * (c) 2014-2021 Evan You
 * Released under the MIT License.
 */
/*  */

var emptyObject = Object.freeze({});

// These helpers produce better VM code in JS engines due to their
// explicitness and function inlining.
function isUndef (v) {
  return v === undefined || v === null
}

function isDef (v) {
  return v !== undefined && v !== null
}

function isTrue (v) {
  return v === true
}

function isFalse (v) {
  return v === false
}

/**
 * Check if value is primitive.
 */
function isPrimitive (value) {
  return (
    typeof value === 'string' ||
    typeof value === 'number' ||
    // $flow-disable-line
    typeof value === 'symbol' ||
    typeof value === 'boolean'
  )
}

/**
 * Quick object check - this is primarily used to tell
 * Objects from primitive values when we know the value
 * is a JSON-compliant type.
 */
function isObject (obj) {
  return obj !== null && typeof obj === 'object'
}

/**
 * Get the raw type string of a value, e.g., [object Object].
 */
var _toString = Object.prototype.toString;

function toRawType (value) {
  return _toString.call(value).slice(8, -1)
}

/**
 * Strict object type check. Only returns true
 * for plain JavaScript objects.
 */
function isPlainObject (obj) {
  return _toString.call(obj) === '[object Object]'
}

function isRegExp (v) {
  return _toString.call(v) === '[object RegExp]'
}

/**
 * Check if val is a valid array index.
 */
function isValidArrayIndex (val) {
  var n = parseFloat(String(val));
  return n >= 0 && Math.floor(n) === n && isFinite(val)
}

function isPromise (val) {
  return (
    isDef(val) &&
    typeof val.then === 'function' &&
    typeof val.catch === 'function'
  )
}

/**
 * Convert a value to a string that is actually rendered.
 */
function toString (val) {
  return val == null
    ? ''
    : Array.isArray(val) || (isPlainObject(val) && val.toString === _toString)
      ? JSON.stringify(val, null, 2)
      : String(val)
}

/**
 * Convert an input value to a number for persistence.
 * If the conversion fails, return original string.
 */
function toNumber (val) {
  var n = parseFloat(val);
  return isNaN(n) ? val : n
}

/**
 * Make a map and return a function for checking if a key
 * is in that map.
 */
function makeMap (
  str,
  expectsLowerCase
) {
  var map = Object.create(null);
  var list = str.split(',');
  for (var i = 0; i < list.length; i++) {
    map[list[i]] = true;
  }
  return expectsLowerCase
    ? function (val) { return map[val.toLowerCase()]; }
    : function (val) { return map[val]; }
}

/**
 * Check if a tag is a built-in tag.
 */
var isBuiltInTag = makeMap('slot,component', true);

/**
 * Check if an attribute is a reserved attribute.
 */
var isReservedAttribute = makeMap('key,ref,slot,slot-scope,is');

/**
 * Remove an item from an array.
 */
function remove (arr, item) {
  if (arr.length) {
    var index = arr.indexOf(item);
    if (index > -1) {
      return arr.splice(index, 1)
    }
  }
}

/**
 * Check whether an object has the property.
 */
var hasOwnProperty = Object.prototype.hasOwnProperty;
function hasOwn (obj, key) {
  return hasOwnProperty.call(obj, key)
}

/**
 * Create a cached version of a pure function.
 */
function cached (fn) {
  var cache = Object.create(null);
  return (function cachedFn (str) {
    var hit = cache[str];
    return hit || (cache[str] = fn(str))
  })
}

/**
 * Camelize a hyphen-delimited string.
 */
var camelizeRE = /-(\w)/g;
var camelize = cached(function (str) {
  return str.replace(camelizeRE, function (_, c) { return c ? c.toUpperCase() : ''; })
});

/**
 * Capitalize a string.
 */
var capitalize = cached(function (str) {
  return str.charAt(0).toUpperCase() + str.slice(1)
});

/**
 * Hyphenate a camelCase string.
 */
var hyphenateRE = /\B([A-Z])/g;
var hyphenate = cached(function (str) {
  return str.replace(hyphenateRE, '-$1').toLowerCase()
});

/**
 * Simple bind polyfill for environments that do not support it,
 * e.g., PhantomJS 1.x. Technically, we don't need this anymore
 * since native bind is now performant enough in most browsers.
 * But removing it would mean breaking code that was able to run in
 * PhantomJS 1.x, so this must be kept for backward compatibility.
 */

/* istanbul ignore next */
function polyfillBind (fn, ctx) {
  function boundFn (a) {
    var l = arguments.length;
    return l
      ? l > 1
        ? fn.apply(ctx, arguments)
        : fn.call(ctx, a)
      : fn.call(ctx)
  }

  boundFn._length = fn.length;
  return boundFn
}

function nativeBind (fn, ctx) {
  return fn.bind(ctx)
}

var bind = Function.prototype.bind
  ? nativeBind
  : polyfillBind;

/**
 * Convert an Array-like object to a real Array.
 */
function toArray (list, start) {
  start = start || 0;
  var i = list.length - start;
  var ret = new Array(i);
  while (i--) {
    ret[i] = list[i + start];
  }
  return ret
}

/**
 * Mix properties into target object.
 */
function extend (to, _from) {
  for (var key in _from) {
    to[key] = _from[key];
  }
  return to
}

/**
 * Merge an Array of Objects into a single Object.
 */
function toObject (arr) {
  var res = {};
  for (var i = 0; i < arr.length; i++) {
    if (arr[i]) {
      extend(res, arr[i]);
    }
  }
  return res
}

/* eslint-disable no-unused-vars */

/**
 * Perform no operation.
 * Stubbing args to make Flow happy without leaving useless transpiled code
 * with ...rest (https://flow.org/blog/2017/05/07/Strict-Function-Call-Arity/).
 */
function noop (a, b, c) {}

/**
 * Always return false.
 */
var no = function (a, b, c) { return false; };

/* eslint-enable no-unused-vars */

/**
 * Return the same value.
 */
var identity = function (_) { return _; };

/**
 * Generate a string containing static keys from compiler modules.
 */
function genStaticKeys (modules) {
  return modules.reduce(function (keys, m) {
    return keys.concat(m.staticKeys || [])
  }, []).join(',')
}

/**
 * Check if two values are loosely equal - that is,
 * if they are plain objects, do they have the same shape?
 */
function looseEqual (a, b) {
  if (a === b) { return true }
  var isObjectA = isObject(a);
  var isObjectB = isObject(b);
  if (isObjectA && isObjectB) {
    try {
      var isArrayA = Array.isArray(a);
      var isArrayB = Array.isArray(b);
      if (isArrayA && isArrayB) {
        return a.length === b.length && a.every(function (e, i) {
          return looseEqual(e, b[i])
        })
      } else if (a instanceof Date && b instanceof Date) {
        return a.getTime() === b.getTime()
      } else if (!isArrayA && !isArrayB) {
        var keysA = Object.keys(a);
        var keysB = Object.keys(b);
        return keysA.length === keysB.length && keysA.every(function (key) {
          return looseEqual(a[key], b[key])
        })
      } else {
        /* istanbul ignore next */
        return false
      }
    } catch (e) {
      /* istanbul ignore next */
      return false
    }
  } else if (!isObjectA && !isObjectB) {
    return String(a) === String(b)
  } else {
    return false
  }
}

/**
 * Return the first index at which a loosely equal value can be
 * found in the array (if value is a plain object, the array must
 * contain an object of the same shape), or -1 if it is not present.
 */
function looseIndexOf (arr, val) {
  for (var i = 0; i < arr.length; i++) {
    if (looseEqual(arr[i], val)) { return i }
  }
  return -1
}

/**
 * Ensure a function is called only once.
 */
function once (fn) {
  var called = false;
  return function () {
    if (!called) {
      called = true;
      fn.apply(this, arguments);
    }
  }
}

var SSR_ATTR = 'data-server-rendered';

var ASSET_TYPES = [
  'component',
  'directive',
  'filter'
];

var LIFECYCLE_HOOKS = [
  'beforeCreate',
  'created',
  'beforeMount',
  'mounted',
  'beforeUpdate',
  'updated',
  'beforeDestroy',
  'destroyed',
  'activated',
  'deactivated',
  'errorCaptured',
  'serverPrefetch'
];

/*  */



var config = ({
  /**
   * Option merge strategies (used in core/util/options)
   */
  // $flow-disable-line
  optionMergeStrategies: Object.create(null),

  /**
   * Whether to suppress warnings.
   */
  silent: false,

  /**
   * Show production mode tip message on boot?
   */
  productionTip: "development" !== 'production',

  /**
   * Whether to enable devtools
   */
  devtools: "development" !== 'production',

  /**
   * Whether to record perf
   */
  performance: false,

  /**
   * Error handler for watcher errors
   */
  errorHandler: null,

  /**
   * Warn handler for watcher warns
   */
  warnHandler: null,

  /**
   * Ignore certain custom elements
   */
  ignoredElements: [],

  /**
   * Custom user key aliases for v-on
   */
  // $flow-disable-line
  keyCodes: Object.create(null),

  /**
   * Check if a tag is reserved so that it cannot be registered as a
   * component. This is platform-dependent and may be overwritten.
   */
  isReservedTag: no,

  /**
   * Check if an attribute is reserved so that it cannot be used as a component
   * prop. This is platform-dependent and may be overwritten.
   */
  isReservedAttr: no,

  /**
   * Check if a tag is an unknown element.
   * Platform-dependent.
   */
  isUnknownElement: no,

  /**
   * Get the namespace of an element
   */
  getTagNamespace: noop,

  /**
   * Parse the real tag name for the specific platform.
   */
  parsePlatformTagName: identity,

  /**
   * Check if an attribute must be bound using property, e.g. value
   * Platform-dependent.
   */
  mustUseProp: no,

  /**
   * Perform updates asynchronously. Intended to be used by Vue Test Utils
   * This will significantly reduce performance if set to false.
   */
  async: true,

  /**
   * Exposed for legacy reasons
   */
  _lifecycleHooks: LIFECYCLE_HOOKS
});

/*  */

/**
 * unicode letters used for parsing html tags, component names and property paths.
 * using https://www.w3.org/TR/html53/semantics-scripting.html#potentialcustomelementname
 * skipping \u10000-\uEFFFF due to it freezing up PhantomJS
 */
var unicodeRegExp = /a-zA-Z\u00B7\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u037D\u037F-\u1FFF\u200C-\u200D\u203F-\u2040\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD/;

/**
 * Check if a string starts with $ or _
 */
function isReserved (str) {
  var c = (str + '').charCodeAt(0);
  return c === 0x24 || c === 0x5F
}

/**
 * Define a property.
 */
function def (obj, key, val, enumerable) {
  Object.defineProperty(obj, key, {
    value: val,
    enumerable: !!enumerable,
    writable: true,
    configurable: true
  });
}

/**
 * Parse simple path.
 */
var bailRE = new RegExp(("[^" + (unicodeRegExp.source) + ".$_\\d]"));
function parsePath (path) {
  if (bailRE.test(path)) {
    return
  }
  var segments = path.split('.');
  return function (obj) {
    for (var i = 0; i < segments.length; i++) {
      if (!obj) { return }
      obj = obj[segments[i]];
    }
    return obj
  }
}

/*  */

// can we use __proto__?
var hasProto = '__proto__' in {};

// Browser environment sniffing
var inBrowser = typeof window !== 'undefined';
var inWeex = typeof WXEnvironment !== 'undefined' && !!WXEnvironment.platform;
var weexPlatform = inWeex && WXEnvironment.platform.toLowerCase();
var UA = inBrowser && window.navigator.userAgent.toLowerCase();
var isIE = UA && /msie|trident/.test(UA);
var isIE9 = UA && UA.indexOf('msie 9.0') > 0;
var isEdge = UA && UA.indexOf('edge/') > 0;
var isAndroid = (UA && UA.indexOf('android') > 0) || (weexPlatform === 'android');
var isIOS = (UA && /iphone|ipad|ipod|ios/.test(UA)) || (weexPlatform === 'ios');
var isChrome = UA && /chrome\/\d+/.test(UA) && !isEdge;
var isPhantomJS = UA && /phantomjs/.test(UA);
var isFF = UA && UA.match(/firefox\/(\d+)/);

// Firefox has a "watch" function on Object.prototype...
var nativeWatch = ({}).watch;

var supportsPassive = false;
if (inBrowser) {
  try {
    var opts = {};
    Object.defineProperty(opts, 'passive', ({
      get: function get () {
        /* istanbul ignore next */
        supportsPassive = true;
      }
    })); // https://github.com/facebook/flow/issues/285
    window.addEventListener('test-passive', null, opts);
  } catch (e) {}
}

// this needs to be lazy-evaled because vue may be required before
// vue-server-renderer can set VUE_ENV
var _isServer;
var isServerRendering = function () {
  if (_isServer === undefined) {
    /* istanbul ignore if */
    if (!inBrowser && !inWeex && typeof __webpack_require__.g !== 'undefined') {
      // detect presence of vue-server-renderer and avoid
      // Webpack shimming the process
      _isServer = __webpack_require__.g['process'] && __webpack_require__.g['process'].env.VUE_ENV === 'server';
    } else {
      _isServer = false;
    }
  }
  return _isServer
};

// detect devtools
var devtools = inBrowser && window.__VUE_DEVTOOLS_GLOBAL_HOOK__;

/* istanbul ignore next */
function isNative (Ctor) {
  return typeof Ctor === 'function' && /native code/.test(Ctor.toString())
}

var hasSymbol =
  typeof Symbol !== 'undefined' && isNative(Symbol) &&
  typeof Reflect !== 'undefined' && isNative(Reflect.ownKeys);

var _Set;
/* istanbul ignore if */ // $flow-disable-line
if (typeof Set !== 'undefined' && isNative(Set)) {
  // use native Set when available.
  _Set = Set;
} else {
  // a non-standard Set polyfill that only works with primitive keys.
  _Set = /*@__PURE__*/(function () {
    function Set () {
      this.set = Object.create(null);
    }
    Set.prototype.has = function has (key) {
      return this.set[key] === true
    };
    Set.prototype.add = function add (key) {
      this.set[key] = true;
    };
    Set.prototype.clear = function clear () {
      this.set = Object.create(null);
    };

    return Set;
  }());
}

/*  */

var warn = noop;
var tip = noop;
var generateComponentTrace = (noop); // work around flow check
var formatComponentName = (noop);

if (true) {
  var hasConsole = typeof console !== 'undefined';
  var classifyRE = /(?:^|[-_])(\w)/g;
  var classify = function (str) { return str
    .replace(classifyRE, function (c) { return c.toUpperCase(); })
    .replace(/[-_]/g, ''); };

  warn = function (msg, vm) {
    var trace = vm ? generateComponentTrace(vm) : '';

    if (config.warnHandler) {
      config.warnHandler.call(null, msg, vm, trace);
    } else if (hasConsole && (!config.silent)) {
      console.error(("[Vue warn]: " + msg + trace));
    }
  };

  tip = function (msg, vm) {
    if (hasConsole && (!config.silent)) {
      console.warn("[Vue tip]: " + msg + (
        vm ? generateComponentTrace(vm) : ''
      ));
    }
  };

  formatComponentName = function (vm, includeFile) {
    if (vm.$root === vm) {
      return '<Root>'
    }
    var options = typeof vm === 'function' && vm.cid != null
      ? vm.options
      : vm._isVue
        ? vm.$options || vm.constructor.options
        : vm;
    var name = options.name || options._componentTag;
    var file = options.__file;
    if (!name && file) {
      var match = file.match(/([^/\\]+)\.vue$/);
      name = match && match[1];
    }

    return (
      (name ? ("<" + (classify(name)) + ">") : "<Anonymous>") +
      (file && includeFile !== false ? (" at " + file) : '')
    )
  };

  var repeat = function (str, n) {
    var res = '';
    while (n) {
      if (n % 2 === 1) { res += str; }
      if (n > 1) { str += str; }
      n >>= 1;
    }
    return res
  };

  generateComponentTrace = function (vm) {
    if (vm._isVue && vm.$parent) {
      var tree = [];
      var currentRecursiveSequence = 0;
      while (vm) {
        if (tree.length > 0) {
          var last = tree[tree.length - 1];
          if (last.constructor === vm.constructor) {
            currentRecursiveSequence++;
            vm = vm.$parent;
            continue
          } else if (currentRecursiveSequence > 0) {
            tree[tree.length - 1] = [last, currentRecursiveSequence];
            currentRecursiveSequence = 0;
          }
        }
        tree.push(vm);
        vm = vm.$parent;
      }
      return '\n\nfound in\n\n' + tree
        .map(function (vm, i) { return ("" + (i === 0 ? '---> ' : repeat(' ', 5 + i * 2)) + (Array.isArray(vm)
            ? ((formatComponentName(vm[0])) + "... (" + (vm[1]) + " recursive calls)")
            : formatComponentName(vm))); })
        .join('\n')
    } else {
      return ("\n\n(found in " + (formatComponentName(vm)) + ")")
    }
  };
}

/*  */

var uid = 0;

/**
 * A dep is an observable that can have multiple
 * directives subscribing to it.
 */
var Dep = function Dep () {
  this.id = uid++;
  this.subs = [];
};

Dep.prototype.addSub = function addSub (sub) {
  this.subs.push(sub);
};

Dep.prototype.removeSub = function removeSub (sub) {
  remove(this.subs, sub);
};

Dep.prototype.depend = function depend () {
  if (Dep.target) {
    Dep.target.addDep(this);
  }
};

Dep.prototype.notify = function notify () {
  // stabilize the subscriber list first
  var subs = this.subs.slice();
  if ( true && !config.async) {
    // subs aren't sorted in scheduler if not running async
    // we need to sort them now to make sure they fire in correct
    // order
    subs.sort(function (a, b) { return a.id - b.id; });
  }
  for (var i = 0, l = subs.length; i < l; i++) {
    subs[i].update();
  }
};

// The current target watcher being evaluated.
// This is globally unique because only one watcher
// can be evaluated at a time.
Dep.target = null;
var targetStack = [];

function pushTarget (target) {
  targetStack.push(target);
  Dep.target = target;
}

function popTarget () {
  targetStack.pop();
  Dep.target = targetStack[targetStack.length - 1];
}

/*  */

var VNode = function VNode (
  tag,
  data,
  children,
  text,
  elm,
  context,
  componentOptions,
  asyncFactory
) {
  this.tag = tag;
  this.data = data;
  this.children = children;
  this.text = text;
  this.elm = elm;
  this.ns = undefined;
  this.context = context;
  this.fnContext = undefined;
  this.fnOptions = undefined;
  this.fnScopeId = undefined;
  this.key = data && data.key;
  this.componentOptions = componentOptions;
  this.componentInstance = undefined;
  this.parent = undefined;
  this.raw = false;
  this.isStatic = false;
  this.isRootInsert = true;
  this.isComment = false;
  this.isCloned = false;
  this.isOnce = false;
  this.asyncFactory = asyncFactory;
  this.asyncMeta = undefined;
  this.isAsyncPlaceholder = false;
};

var prototypeAccessors = { child: { configurable: true } };

// DEPRECATED: alias for componentInstance for backwards compat.
/* istanbul ignore next */
prototypeAccessors.child.get = function () {
  return this.componentInstance
};

Object.defineProperties( VNode.prototype, prototypeAccessors );

var createEmptyVNode = function (text) {
  if ( text === void 0 ) text = '';

  var node = new VNode();
  node.text = text;
  node.isComment = true;
  return node
};

function createTextVNode (val) {
  return new VNode(undefined, undefined, undefined, String(val))
}

// optimized shallow clone
// used for static nodes and slot nodes because they may be reused across
// multiple renders, cloning them avoids errors when DOM manipulations rely
// on their elm reference.
function cloneVNode (vnode) {
  var cloned = new VNode(
    vnode.tag,
    vnode.data,
    // #7975
    // clone children array to avoid mutating original in case of cloning
    // a child.
    vnode.children && vnode.children.slice(),
    vnode.text,
    vnode.elm,
    vnode.context,
    vnode.componentOptions,
    vnode.asyncFactory
  );
  cloned.ns = vnode.ns;
  cloned.isStatic = vnode.isStatic;
  cloned.key = vnode.key;
  cloned.isComment = vnode.isComment;
  cloned.fnContext = vnode.fnContext;
  cloned.fnOptions = vnode.fnOptions;
  cloned.fnScopeId = vnode.fnScopeId;
  cloned.asyncMeta = vnode.asyncMeta;
  cloned.isCloned = true;
  return cloned
}

/*
 * not type checking this file because flow doesn't play well with
 * dynamically accessing methods on Array prototype
 */

var arrayProto = Array.prototype;
var arrayMethods = Object.create(arrayProto);

var methodsToPatch = [
  'push',
  'pop',
  'shift',
  'unshift',
  'splice',
  'sort',
  'reverse'
];

/**
 * Intercept mutating methods and emit events
 */
methodsToPatch.forEach(function (method) {
  // cache original method
  var original = arrayProto[method];
  def(arrayMethods, method, function mutator () {
    var args = [], len = arguments.length;
    while ( len-- ) args[ len ] = arguments[ len ];

    var result = original.apply(this, args);
    var ob = this.__ob__;
    var inserted;
    switch (method) {
      case 'push':
      case 'unshift':
        inserted = args;
        break
      case 'splice':
        inserted = args.slice(2);
        break
    }
    if (inserted) { ob.observeArray(inserted); }
    // notify change
    ob.dep.notify();
    return result
  });
});

/*  */

var arrayKeys = Object.getOwnPropertyNames(arrayMethods);

/**
 * In some cases we may want to disable observation inside a component's
 * update computation.
 */
var shouldObserve = true;

function toggleObserving (value) {
  shouldObserve = value;
}

/**
 * Observer class that is attached to each observed
 * object. Once attached, the observer converts the target
 * object's property keys into getter/setters that
 * collect dependencies and dispatch updates.
 */
var Observer = function Observer (value) {
  this.value = value;
  this.dep = new Dep();
  this.vmCount = 0;
  def(value, '__ob__', this);
  if (Array.isArray(value)) {
    if (hasProto) {
      protoAugment(value, arrayMethods);
    } else {
      copyAugment(value, arrayMethods, arrayKeys);
    }
    this.observeArray(value);
  } else {
    this.walk(value);
  }
};

/**
 * Walk through all properties and convert them into
 * getter/setters. This method should only be called when
 * value type is Object.
 */
Observer.prototype.walk = function walk (obj) {
  var keys = Object.keys(obj);
  for (var i = 0; i < keys.length; i++) {
    defineReactive$$1(obj, keys[i]);
  }
};

/**
 * Observe a list of Array items.
 */
Observer.prototype.observeArray = function observeArray (items) {
  for (var i = 0, l = items.length; i < l; i++) {
    observe(items[i]);
  }
};

// helpers

/**
 * Augment a target Object or Array by intercepting
 * the prototype chain using __proto__
 */
function protoAugment (target, src) {
  /* eslint-disable no-proto */
  target.__proto__ = src;
  /* eslint-enable no-proto */
}

/**
 * Augment a target Object or Array by defining
 * hidden properties.
 */
/* istanbul ignore next */
function copyAugment (target, src, keys) {
  for (var i = 0, l = keys.length; i < l; i++) {
    var key = keys[i];
    def(target, key, src[key]);
  }
}

/**
 * Attempt to create an observer instance for a value,
 * returns the new observer if successfully observed,
 * or the existing observer if the value already has one.
 */
function observe (value, asRootData) {
  if (!isObject(value) || value instanceof VNode) {
    return
  }
  var ob;
  if (hasOwn(value, '__ob__') && value.__ob__ instanceof Observer) {
    ob = value.__ob__;
  } else if (
    shouldObserve &&
    !isServerRendering() &&
    (Array.isArray(value) || isPlainObject(value)) &&
    Object.isExtensible(value) &&
    !value._isVue
  ) {
    ob = new Observer(value);
  }
  if (asRootData && ob) {
    ob.vmCount++;
  }
  return ob
}

/**
 * Define a reactive property on an Object.
 */
function defineReactive$$1 (
  obj,
  key,
  val,
  customSetter,
  shallow
) {
  var dep = new Dep();

  var property = Object.getOwnPropertyDescriptor(obj, key);
  if (property && property.configurable === false) {
    return
  }

  // cater for pre-defined getter/setters
  var getter = property && property.get;
  var setter = property && property.set;
  if ((!getter || setter) && arguments.length === 2) {
    val = obj[key];
  }

  var childOb = !shallow && observe(val);
  Object.defineProperty(obj, key, {
    enumerable: true,
    configurable: true,
    get: function reactiveGetter () {
      var value = getter ? getter.call(obj) : val;
      if (Dep.target) {
        dep.depend();
        if (childOb) {
          childOb.dep.depend();
          if (Array.isArray(value)) {
            dependArray(value);
          }
        }
      }
      return value
    },
    set: function reactiveSetter (newVal) {
      var value = getter ? getter.call(obj) : val;
      /* eslint-disable no-self-compare */
      if (newVal === value || (newVal !== newVal && value !== value)) {
        return
      }
      /* eslint-enable no-self-compare */
      if ( true && customSetter) {
        customSetter();
      }
      // #7981: for accessor properties without setter
      if (getter && !setter) { return }
      if (setter) {
        setter.call(obj, newVal);
      } else {
        val = newVal;
      }
      childOb = !shallow && observe(newVal);
      dep.notify();
    }
  });
}

/**
 * Set a property on an object. Adds the new property and
 * triggers change notification if the property doesn't
 * already exist.
 */
function set (target, key, val) {
  if ( true &&
    (isUndef(target) || isPrimitive(target))
  ) {
    warn(("Cannot set reactive property on undefined, null, or primitive value: " + ((target))));
  }
  if (Array.isArray(target) && isValidArrayIndex(key)) {
    target.length = Math.max(target.length, key);
    target.splice(key, 1, val);
    return val
  }
  if (key in target && !(key in Object.prototype)) {
    target[key] = val;
    return val
  }
  var ob = (target).__ob__;
  if (target._isVue || (ob && ob.vmCount)) {
     true && warn(
      'Avoid adding reactive properties to a Vue instance or its root $data ' +
      'at runtime - declare it upfront in the data option.'
    );
    return val
  }
  if (!ob) {
    target[key] = val;
    return val
  }
  defineReactive$$1(ob.value, key, val);
  ob.dep.notify();
  return val
}

/**
 * Delete a property and trigger change if necessary.
 */
function del (target, key) {
  if ( true &&
    (isUndef(target) || isPrimitive(target))
  ) {
    warn(("Cannot delete reactive property on undefined, null, or primitive value: " + ((target))));
  }
  if (Array.isArray(target) && isValidArrayIndex(key)) {
    target.splice(key, 1);
    return
  }
  var ob = (target).__ob__;
  if (target._isVue || (ob && ob.vmCount)) {
     true && warn(
      'Avoid deleting properties on a Vue instance or its root $data ' +
      '- just set it to null.'
    );
    return
  }
  if (!hasOwn(target, key)) {
    return
  }
  delete target[key];
  if (!ob) {
    return
  }
  ob.dep.notify();
}

/**
 * Collect dependencies on array elements when the array is touched, since
 * we cannot intercept array element access like property getters.
 */
function dependArray (value) {
  for (var e = (void 0), i = 0, l = value.length; i < l; i++) {
    e = value[i];
    e && e.__ob__ && e.__ob__.dep.depend();
    if (Array.isArray(e)) {
      dependArray(e);
    }
  }
}

/*  */

/**
 * Option overwriting strategies are functions that handle
 * how to merge a parent option value and a child option
 * value into the final value.
 */
var strats = config.optionMergeStrategies;

/**
 * Options with restrictions
 */
if (true) {
  strats.el = strats.propsData = function (parent, child, vm, key) {
    if (!vm) {
      warn(
        "option \"" + key + "\" can only be used during instance " +
        'creation with the `new` keyword.'
      );
    }
    return defaultStrat(parent, child)
  };
}

/**
 * Helper that recursively merges two data objects together.
 */
function mergeData (to, from) {
  if (!from) { return to }
  var key, toVal, fromVal;

  var keys = hasSymbol
    ? Reflect.ownKeys(from)
    : Object.keys(from);

  for (var i = 0; i < keys.length; i++) {
    key = keys[i];
    // in case the object is already observed...
    if (key === '__ob__') { continue }
    toVal = to[key];
    fromVal = from[key];
    if (!hasOwn(to, key)) {
      set(to, key, fromVal);
    } else if (
      toVal !== fromVal &&
      isPlainObject(toVal) &&
      isPlainObject(fromVal)
    ) {
      mergeData(toVal, fromVal);
    }
  }
  return to
}

/**
 * Data
 */
function mergeDataOrFn (
  parentVal,
  childVal,
  vm
) {
  if (!vm) {
    // in a Vue.extend merge, both should be functions
    if (!childVal) {
      return parentVal
    }
    if (!parentVal) {
      return childVal
    }
    // when parentVal & childVal are both present,
    // we need to return a function that returns the
    // merged result of both functions... no need to
    // check if parentVal is a function here because
    // it has to be a function to pass previous merges.
    return function mergedDataFn () {
      return mergeData(
        typeof childVal === 'function' ? childVal.call(this, this) : childVal,
        typeof parentVal === 'function' ? parentVal.call(this, this) : parentVal
      )
    }
  } else {
    return function mergedInstanceDataFn () {
      // instance merge
      var instanceData = typeof childVal === 'function'
        ? childVal.call(vm, vm)
        : childVal;
      var defaultData = typeof parentVal === 'function'
        ? parentVal.call(vm, vm)
        : parentVal;
      if (instanceData) {
        return mergeData(instanceData, defaultData)
      } else {
        return defaultData
      }
    }
  }
}

strats.data = function (
  parentVal,
  childVal,
  vm
) {
  if (!vm) {
    if (childVal && typeof childVal !== 'function') {
       true && warn(
        'The "data" option should be a function ' +
        'that returns a per-instance value in component ' +
        'definitions.',
        vm
      );

      return parentVal
    }
    return mergeDataOrFn(parentVal, childVal)
  }

  return mergeDataOrFn(parentVal, childVal, vm)
};

/**
 * Hooks and props are merged as arrays.
 */
function mergeHook (
  parentVal,
  childVal
) {
  var res = childVal
    ? parentVal
      ? parentVal.concat(childVal)
      : Array.isArray(childVal)
        ? childVal
        : [childVal]
    : parentVal;
  return res
    ? dedupeHooks(res)
    : res
}

function dedupeHooks (hooks) {
  var res = [];
  for (var i = 0; i < hooks.length; i++) {
    if (res.indexOf(hooks[i]) === -1) {
      res.push(hooks[i]);
    }
  }
  return res
}

LIFECYCLE_HOOKS.forEach(function (hook) {
  strats[hook] = mergeHook;
});

/**
 * Assets
 *
 * When a vm is present (instance creation), we need to do
 * a three-way merge between constructor options, instance
 * options and parent options.
 */
function mergeAssets (
  parentVal,
  childVal,
  vm,
  key
) {
  var res = Object.create(parentVal || null);
  if (childVal) {
     true && assertObjectType(key, childVal, vm);
    return extend(res, childVal)
  } else {
    return res
  }
}

ASSET_TYPES.forEach(function (type) {
  strats[type + 's'] = mergeAssets;
});

/**
 * Watchers.
 *
 * Watchers hashes should not overwrite one
 * another, so we merge them as arrays.
 */
strats.watch = function (
  parentVal,
  childVal,
  vm,
  key
) {
  // work around Firefox's Object.prototype.watch...
  if (parentVal === nativeWatch) { parentVal = undefined; }
  if (childVal === nativeWatch) { childVal = undefined; }
  /* istanbul ignore if */
  if (!childVal) { return Object.create(parentVal || null) }
  if (true) {
    assertObjectType(key, childVal, vm);
  }
  if (!parentVal) { return childVal }
  var ret = {};
  extend(ret, parentVal);
  for (var key$1 in childVal) {
    var parent = ret[key$1];
    var child = childVal[key$1];
    if (parent && !Array.isArray(parent)) {
      parent = [parent];
    }
    ret[key$1] = parent
      ? parent.concat(child)
      : Array.isArray(child) ? child : [child];
  }
  return ret
};

/**
 * Other object hashes.
 */
strats.props =
strats.methods =
strats.inject =
strats.computed = function (
  parentVal,
  childVal,
  vm,
  key
) {
  if (childVal && "development" !== 'production') {
    assertObjectType(key, childVal, vm);
  }
  if (!parentVal) { return childVal }
  var ret = Object.create(null);
  extend(ret, parentVal);
  if (childVal) { extend(ret, childVal); }
  return ret
};
strats.provide = mergeDataOrFn;

/**
 * Default strategy.
 */
var defaultStrat = function (parentVal, childVal) {
  return childVal === undefined
    ? parentVal
    : childVal
};

/**
 * Validate component names
 */
function checkComponents (options) {
  for (var key in options.components) {
    validateComponentName(key);
  }
}

function validateComponentName (name) {
  if (!new RegExp(("^[a-zA-Z][\\-\\.0-9_" + (unicodeRegExp.source) + "]*$")).test(name)) {
    warn(
      'Invalid component name: "' + name + '". Component names ' +
      'should conform to valid custom element name in html5 specification.'
    );
  }
  if (isBuiltInTag(name) || config.isReservedTag(name)) {
    warn(
      'Do not use built-in or reserved HTML elements as component ' +
      'id: ' + name
    );
  }
}

/**
 * Ensure all props option syntax are normalized into the
 * Object-based format.
 */
function normalizeProps (options, vm) {
  var props = options.props;
  if (!props) { return }
  var res = {};
  var i, val, name;
  if (Array.isArray(props)) {
    i = props.length;
    while (i--) {
      val = props[i];
      if (typeof val === 'string') {
        name = camelize(val);
        res[name] = { type: null };
      } else if (true) {
        warn('props must be strings when using array syntax.');
      }
    }
  } else if (isPlainObject(props)) {
    for (var key in props) {
      val = props[key];
      name = camelize(key);
      res[name] = isPlainObject(val)
        ? val
        : { type: val };
    }
  } else if (true) {
    warn(
      "Invalid value for option \"props\": expected an Array or an Object, " +
      "but got " + (toRawType(props)) + ".",
      vm
    );
  }
  options.props = res;
}

/**
 * Normalize all injections into Object-based format
 */
function normalizeInject (options, vm) {
  var inject = options.inject;
  if (!inject) { return }
  var normalized = options.inject = {};
  if (Array.isArray(inject)) {
    for (var i = 0; i < inject.length; i++) {
      normalized[inject[i]] = { from: inject[i] };
    }
  } else if (isPlainObject(inject)) {
    for (var key in inject) {
      var val = inject[key];
      normalized[key] = isPlainObject(val)
        ? extend({ from: key }, val)
        : { from: val };
    }
  } else if (true) {
    warn(
      "Invalid value for option \"inject\": expected an Array or an Object, " +
      "but got " + (toRawType(inject)) + ".",
      vm
    );
  }
}

/**
 * Normalize raw function directives into object format.
 */
function normalizeDirectives (options) {
  var dirs = options.directives;
  if (dirs) {
    for (var key in dirs) {
      var def$$1 = dirs[key];
      if (typeof def$$1 === 'function') {
        dirs[key] = { bind: def$$1, update: def$$1 };
      }
    }
  }
}

function assertObjectType (name, value, vm) {
  if (!isPlainObject(value)) {
    warn(
      "Invalid value for option \"" + name + "\": expected an Object, " +
      "but got " + (toRawType(value)) + ".",
      vm
    );
  }
}

/**
 * Merge two option objects into a new one.
 * Core utility used in both instantiation and inheritance.
 */
function mergeOptions (
  parent,
  child,
  vm
) {
  if (true) {
    checkComponents(child);
  }

  if (typeof child === 'function') {
    child = child.options;
  }

  normalizeProps(child, vm);
  normalizeInject(child, vm);
  normalizeDirectives(child);

  // Apply extends and mixins on the child options,
  // but only if it is a raw options object that isn't
  // the result of another mergeOptions call.
  // Only merged options has the _base property.
  if (!child._base) {
    if (child.extends) {
      parent = mergeOptions(parent, child.extends, vm);
    }
    if (child.mixins) {
      for (var i = 0, l = child.mixins.length; i < l; i++) {
        parent = mergeOptions(parent, child.mixins[i], vm);
      }
    }
  }

  var options = {};
  var key;
  for (key in parent) {
    mergeField(key);
  }
  for (key in child) {
    if (!hasOwn(parent, key)) {
      mergeField(key);
    }
  }
  function mergeField (key) {
    var strat = strats[key] || defaultStrat;
    options[key] = strat(parent[key], child[key], vm, key);
  }
  return options
}

/**
 * Resolve an asset.
 * This function is used because child instances need access
 * to assets defined in its ancestor chain.
 */
function resolveAsset (
  options,
  type,
  id,
  warnMissing
) {
  /* istanbul ignore if */
  if (typeof id !== 'string') {
    return
  }
  var assets = options[type];
  // check local registration variations first
  if (hasOwn(assets, id)) { return assets[id] }
  var camelizedId = camelize(id);
  if (hasOwn(assets, camelizedId)) { return assets[camelizedId] }
  var PascalCaseId = capitalize(camelizedId);
  if (hasOwn(assets, PascalCaseId)) { return assets[PascalCaseId] }
  // fallback to prototype chain
  var res = assets[id] || assets[camelizedId] || assets[PascalCaseId];
  if ( true && warnMissing && !res) {
    warn(
      'Failed to resolve ' + type.slice(0, -1) + ': ' + id,
      options
    );
  }
  return res
}

/*  */



function validateProp (
  key,
  propOptions,
  propsData,
  vm
) {
  var prop = propOptions[key];
  var absent = !hasOwn(propsData, key);
  var value = propsData[key];
  // boolean casting
  var booleanIndex = getTypeIndex(Boolean, prop.type);
  if (booleanIndex > -1) {
    if (absent && !hasOwn(prop, 'default')) {
      value = false;
    } else if (value === '' || value === hyphenate(key)) {
      // only cast empty string / same name to boolean if
      // boolean has higher priority
      var stringIndex = getTypeIndex(String, prop.type);
      if (stringIndex < 0 || booleanIndex < stringIndex) {
        value = true;
      }
    }
  }
  // check default value
  if (value === undefined) {
    value = getPropDefaultValue(vm, prop, key);
    // since the default value is a fresh copy,
    // make sure to observe it.
    var prevShouldObserve = shouldObserve;
    toggleObserving(true);
    observe(value);
    toggleObserving(prevShouldObserve);
  }
  if (
    true
  ) {
    assertProp(prop, key, value, vm, absent);
  }
  return value
}

/**
 * Get the default value of a prop.
 */
function getPropDefaultValue (vm, prop, key) {
  // no default, return undefined
  if (!hasOwn(prop, 'default')) {
    return undefined
  }
  var def = prop.default;
  // warn against non-factory defaults for Object & Array
  if ( true && isObject(def)) {
    warn(
      'Invalid default value for prop "' + key + '": ' +
      'Props with type Object/Array must use a factory function ' +
      'to return the default value.',
      vm
    );
  }
  // the raw prop value was also undefined from previous render,
  // return previous default value to avoid unnecessary watcher trigger
  if (vm && vm.$options.propsData &&
    vm.$options.propsData[key] === undefined &&
    vm._props[key] !== undefined
  ) {
    return vm._props[key]
  }
  // call factory function for non-Function types
  // a value is Function if its prototype is function even across different execution context
  return typeof def === 'function' && getType(prop.type) !== 'Function'
    ? def.call(vm)
    : def
}

/**
 * Assert whether a prop is valid.
 */
function assertProp (
  prop,
  name,
  value,
  vm,
  absent
) {
  if (prop.required && absent) {
    warn(
      'Missing required prop: "' + name + '"',
      vm
    );
    return
  }
  if (value == null && !prop.required) {
    return
  }
  var type = prop.type;
  var valid = !type || type === true;
  var expectedTypes = [];
  if (type) {
    if (!Array.isArray(type)) {
      type = [type];
    }
    for (var i = 0; i < type.length && !valid; i++) {
      var assertedType = assertType(value, type[i], vm);
      expectedTypes.push(assertedType.expectedType || '');
      valid = assertedType.valid;
    }
  }

  var haveExpectedTypes = expectedTypes.some(function (t) { return t; });
  if (!valid && haveExpectedTypes) {
    warn(
      getInvalidTypeMessage(name, value, expectedTypes),
      vm
    );
    return
  }
  var validator = prop.validator;
  if (validator) {
    if (!validator(value)) {
      warn(
        'Invalid prop: custom validator check failed for prop "' + name + '".',
        vm
      );
    }
  }
}

var simpleCheckRE = /^(String|Number|Boolean|Function|Symbol|BigInt)$/;

function assertType (value, type, vm) {
  var valid;
  var expectedType = getType(type);
  if (simpleCheckRE.test(expectedType)) {
    var t = typeof value;
    valid = t === expectedType.toLowerCase();
    // for primitive wrapper objects
    if (!valid && t === 'object') {
      valid = value instanceof type;
    }
  } else if (expectedType === 'Object') {
    valid = isPlainObject(value);
  } else if (expectedType === 'Array') {
    valid = Array.isArray(value);
  } else {
    try {
      valid = value instanceof type;
    } catch (e) {
      warn('Invalid prop type: "' + String(type) + '" is not a constructor', vm);
      valid = false;
    }
  }
  return {
    valid: valid,
    expectedType: expectedType
  }
}

var functionTypeCheckRE = /^\s*function (\w+)/;

/**
 * Use function string name to check built-in types,
 * because a simple equality check will fail when running
 * across different vms / iframes.
 */
function getType (fn) {
  var match = fn && fn.toString().match(functionTypeCheckRE);
  return match ? match[1] : ''
}

function isSameType (a, b) {
  return getType(a) === getType(b)
}

function getTypeIndex (type, expectedTypes) {
  if (!Array.isArray(expectedTypes)) {
    return isSameType(expectedTypes, type) ? 0 : -1
  }
  for (var i = 0, len = expectedTypes.length; i < len; i++) {
    if (isSameType(expectedTypes[i], type)) {
      return i
    }
  }
  return -1
}

function getInvalidTypeMessage (name, value, expectedTypes) {
  var message = "Invalid prop: type check failed for prop \"" + name + "\"." +
    " Expected " + (expectedTypes.map(capitalize).join(', '));
  var expectedType = expectedTypes[0];
  var receivedType = toRawType(value);
  // check if we need to specify expected value
  if (
    expectedTypes.length === 1 &&
    isExplicable(expectedType) &&
    isExplicable(typeof value) &&
    !isBoolean(expectedType, receivedType)
  ) {
    message += " with value " + (styleValue(value, expectedType));
  }
  message += ", got " + receivedType + " ";
  // check if we need to specify received value
  if (isExplicable(receivedType)) {
    message += "with value " + (styleValue(value, receivedType)) + ".";
  }
  return message
}

function styleValue (value, type) {
  if (type === 'String') {
    return ("\"" + value + "\"")
  } else if (type === 'Number') {
    return ("" + (Number(value)))
  } else {
    return ("" + value)
  }
}

var EXPLICABLE_TYPES = ['string', 'number', 'boolean'];
function isExplicable (value) {
  return EXPLICABLE_TYPES.some(function (elem) { return value.toLowerCase() === elem; })
}

function isBoolean () {
  var args = [], len = arguments.length;
  while ( len-- ) args[ len ] = arguments[ len ];

  return args.some(function (elem) { return elem.toLowerCase() === 'boolean'; })
}

/*  */

function handleError (err, vm, info) {
  // Deactivate deps tracking while processing error handler to avoid possible infinite rendering.
  // See: https://github.com/vuejs/vuex/issues/1505
  pushTarget();
  try {
    if (vm) {
      var cur = vm;
      while ((cur = cur.$parent)) {
        var hooks = cur.$options.errorCaptured;
        if (hooks) {
          for (var i = 0; i < hooks.length; i++) {
            try {
              var capture = hooks[i].call(cur, err, vm, info) === false;
              if (capture) { return }
            } catch (e) {
              globalHandleError(e, cur, 'errorCaptured hook');
            }
          }
        }
      }
    }
    globalHandleError(err, vm, info);
  } finally {
    popTarget();
  }
}

function invokeWithErrorHandling (
  handler,
  context,
  args,
  vm,
  info
) {
  var res;
  try {
    res = args ? handler.apply(context, args) : handler.call(context);
    if (res && !res._isVue && isPromise(res) && !res._handled) {
      res.catch(function (e) { return handleError(e, vm, info + " (Promise/async)"); });
      // issue #9511
      // avoid catch triggering multiple times when nested calls
      res._handled = true;
    }
  } catch (e) {
    handleError(e, vm, info);
  }
  return res
}

function globalHandleError (err, vm, info) {
  if (config.errorHandler) {
    try {
      return config.errorHandler.call(null, err, vm, info)
    } catch (e) {
      // if the user intentionally throws the original error in the handler,
      // do not log it twice
      if (e !== err) {
        logError(e, null, 'config.errorHandler');
      }
    }
  }
  logError(err, vm, info);
}

function logError (err, vm, info) {
  if (true) {
    warn(("Error in " + info + ": \"" + (err.toString()) + "\""), vm);
  }
  /* istanbul ignore else */
  if ((inBrowser || inWeex) && typeof console !== 'undefined') {
    console.error(err);
  } else {
    throw err
  }
}

/*  */

var isUsingMicroTask = false;

var callbacks = [];
var pending = false;

function flushCallbacks () {
  pending = false;
  var copies = callbacks.slice(0);
  callbacks.length = 0;
  for (var i = 0; i < copies.length; i++) {
    copies[i]();
  }
}

// Here we have async deferring wrappers using microtasks.
// In 2.5 we used (macro) tasks (in combination with microtasks).
// However, it has subtle problems when state is changed right before repaint
// (e.g. #6813, out-in transitions).
// Also, using (macro) tasks in event handler would cause some weird behaviors
// that cannot be circumvented (e.g. #7109, #7153, #7546, #7834, #8109).
// So we now use microtasks everywhere, again.
// A major drawback of this tradeoff is that there are some scenarios
// where microtasks have too high a priority and fire in between supposedly
// sequential events (e.g. #4521, #6690, which have workarounds)
// or even between bubbling of the same event (#6566).
var timerFunc;

// The nextTick behavior leverages the microtask queue, which can be accessed
// via either native Promise.then or MutationObserver.
// MutationObserver has wider support, however it is seriously bugged in
// UIWebView in iOS >= 9.3.3 when triggered in touch event handlers. It
// completely stops working after triggering a few times... so, if native
// Promise is available, we will use it:
/* istanbul ignore next, $flow-disable-line */
if (typeof Promise !== 'undefined' && isNative(Promise)) {
  var p = Promise.resolve();
  timerFunc = function () {
    p.then(flushCallbacks);
    // In problematic UIWebViews, Promise.then doesn't completely break, but
    // it can get stuck in a weird state where callbacks are pushed into the
    // microtask queue but the queue isn't being flushed, until the browser
    // needs to do some other work, e.g. handle a timer. Therefore we can
    // "force" the microtask queue to be flushed by adding an empty timer.
    if (isIOS) { setTimeout(noop); }
  };
  isUsingMicroTask = true;
} else if (!isIE && typeof MutationObserver !== 'undefined' && (
  isNative(MutationObserver) ||
  // PhantomJS and iOS 7.x
  MutationObserver.toString() === '[object MutationObserverConstructor]'
)) {
  // Use MutationObserver where native Promise is not available,
  // e.g. PhantomJS, iOS7, Android 4.4
  // (#6466 MutationObserver is unreliable in IE11)
  var counter = 1;
  var observer = new MutationObserver(flushCallbacks);
  var textNode = document.createTextNode(String(counter));
  observer.observe(textNode, {
    characterData: true
  });
  timerFunc = function () {
    counter = (counter + 1) % 2;
    textNode.data = String(counter);
  };
  isUsingMicroTask = true;
} else if (typeof setImmediate !== 'undefined' && isNative(setImmediate)) {
  // Fallback to setImmediate.
  // Technically it leverages the (macro) task queue,
  // but it is still a better choice than setTimeout.
  timerFunc = function () {
    setImmediate(flushCallbacks);
  };
} else {
  // Fallback to setTimeout.
  timerFunc = function () {
    setTimeout(flushCallbacks, 0);
  };
}

function nextTick (cb, ctx) {
  var _resolve;
  callbacks.push(function () {
    if (cb) {
      try {
        cb.call(ctx);
      } catch (e) {
        handleError(e, ctx, 'nextTick');
      }
    } else if (_resolve) {
      _resolve(ctx);
    }
  });
  if (!pending) {
    pending = true;
    timerFunc();
  }
  // $flow-disable-line
  if (!cb && typeof Promise !== 'undefined') {
    return new Promise(function (resolve) {
      _resolve = resolve;
    })
  }
}

/*  */

var mark;
var measure;

if (true) {
  var perf = inBrowser && window.performance;
  /* istanbul ignore if */
  if (
    perf &&
    perf.mark &&
    perf.measure &&
    perf.clearMarks &&
    perf.clearMeasures
  ) {
    mark = function (tag) { return perf.mark(tag); };
    measure = function (name, startTag, endTag) {
      perf.measure(name, startTag, endTag);
      perf.clearMarks(startTag);
      perf.clearMarks(endTag);
      // perf.clearMeasures(name)
    };
  }
}

/* not type checking this file because flow doesn't play well with Proxy */

var initProxy;

if (true) {
  var allowedGlobals = makeMap(
    'Infinity,undefined,NaN,isFinite,isNaN,' +
    'parseFloat,parseInt,decodeURI,decodeURIComponent,encodeURI,encodeURIComponent,' +
    'Math,Number,Date,Array,Object,Boolean,String,RegExp,Map,Set,JSON,Intl,BigInt,' +
    'require' // for Webpack/Browserify
  );

  var warnNonPresent = function (target, key) {
    warn(
      "Property or method \"" + key + "\" is not defined on the instance but " +
      'referenced during render. Make sure that this property is reactive, ' +
      'either in the data option, or for class-based components, by ' +
      'initializing the property. ' +
      'See: https://vuejs.org/v2/guide/reactivity.html#Declaring-Reactive-Properties.',
      target
    );
  };

  var warnReservedPrefix = function (target, key) {
    warn(
      "Property \"" + key + "\" must be accessed with \"$data." + key + "\" because " +
      'properties starting with "$" or "_" are not proxied in the Vue instance to ' +
      'prevent conflicts with Vue internals. ' +
      'See: https://vuejs.org/v2/api/#data',
      target
    );
  };

  var hasProxy =
    typeof Proxy !== 'undefined' && isNative(Proxy);

  if (hasProxy) {
    var isBuiltInModifier = makeMap('stop,prevent,self,ctrl,shift,alt,meta,exact');
    config.keyCodes = new Proxy(config.keyCodes, {
      set: function set (target, key, value) {
        if (isBuiltInModifier(key)) {
          warn(("Avoid overwriting built-in modifier in config.keyCodes: ." + key));
          return false
        } else {
          target[key] = value;
          return true
        }
      }
    });
  }

  var hasHandler = {
    has: function has (target, key) {
      var has = key in target;
      var isAllowed = allowedGlobals(key) ||
        (typeof key === 'string' && key.charAt(0) === '_' && !(key in target.$data));
      if (!has && !isAllowed) {
        if (key in target.$data) { warnReservedPrefix(target, key); }
        else { warnNonPresent(target, key); }
      }
      return has || !isAllowed
    }
  };

  var getHandler = {
    get: function get (target, key) {
      if (typeof key === 'string' && !(key in target)) {
        if (key in target.$data) { warnReservedPrefix(target, key); }
        else { warnNonPresent(target, key); }
      }
      return target[key]
    }
  };

  initProxy = function initProxy (vm) {
    if (hasProxy) {
      // determine which proxy handler to use
      var options = vm.$options;
      var handlers = options.render && options.render._withStripped
        ? getHandler
        : hasHandler;
      vm._renderProxy = new Proxy(vm, handlers);
    } else {
      vm._renderProxy = vm;
    }
  };
}

/*  */

var seenObjects = new _Set();

/**
 * Recursively traverse an object to evoke all converted
 * getters, so that every nested property inside the object
 * is collected as a "deep" dependency.
 */
function traverse (val) {
  _traverse(val, seenObjects);
  seenObjects.clear();
}

function _traverse (val, seen) {
  var i, keys;
  var isA = Array.isArray(val);
  if ((!isA && !isObject(val)) || Object.isFrozen(val) || val instanceof VNode) {
    return
  }
  if (val.__ob__) {
    var depId = val.__ob__.dep.id;
    if (seen.has(depId)) {
      return
    }
    seen.add(depId);
  }
  if (isA) {
    i = val.length;
    while (i--) { _traverse(val[i], seen); }
  } else {
    keys = Object.keys(val);
    i = keys.length;
    while (i--) { _traverse(val[keys[i]], seen); }
  }
}

/*  */

var normalizeEvent = cached(function (name) {
  var passive = name.charAt(0) === '&';
  name = passive ? name.slice(1) : name;
  var once$$1 = name.charAt(0) === '~'; // Prefixed last, checked first
  name = once$$1 ? name.slice(1) : name;
  var capture = name.charAt(0) === '!';
  name = capture ? name.slice(1) : name;
  return {
    name: name,
    once: once$$1,
    capture: capture,
    passive: passive
  }
});

function createFnInvoker (fns, vm) {
  function invoker () {
    var arguments$1 = arguments;

    var fns = invoker.fns;
    if (Array.isArray(fns)) {
      var cloned = fns.slice();
      for (var i = 0; i < cloned.length; i++) {
        invokeWithErrorHandling(cloned[i], null, arguments$1, vm, "v-on handler");
      }
    } else {
      // return handler return value for single handlers
      return invokeWithErrorHandling(fns, null, arguments, vm, "v-on handler")
    }
  }
  invoker.fns = fns;
  return invoker
}

function updateListeners (
  on,
  oldOn,
  add,
  remove$$1,
  createOnceHandler,
  vm
) {
  var name, def$$1, cur, old, event;
  for (name in on) {
    def$$1 = cur = on[name];
    old = oldOn[name];
    event = normalizeEvent(name);
    if (isUndef(cur)) {
       true && warn(
        "Invalid handler for event \"" + (event.name) + "\": got " + String(cur),
        vm
      );
    } else if (isUndef(old)) {
      if (isUndef(cur.fns)) {
        cur = on[name] = createFnInvoker(cur, vm);
      }
      if (isTrue(event.once)) {
        cur = on[name] = createOnceHandler(event.name, cur, event.capture);
      }
      add(event.name, cur, event.capture, event.passive, event.params);
    } else if (cur !== old) {
      old.fns = cur;
      on[name] = old;
    }
  }
  for (name in oldOn) {
    if (isUndef(on[name])) {
      event = normalizeEvent(name);
      remove$$1(event.name, oldOn[name], event.capture);
    }
  }
}

/*  */

function mergeVNodeHook (def, hookKey, hook) {
  if (def instanceof VNode) {
    def = def.data.hook || (def.data.hook = {});
  }
  var invoker;
  var oldHook = def[hookKey];

  function wrappedHook () {
    hook.apply(this, arguments);
    // important: remove merged hook to ensure it's called only once
    // and prevent memory leak
    remove(invoker.fns, wrappedHook);
  }

  if (isUndef(oldHook)) {
    // no existing hook
    invoker = createFnInvoker([wrappedHook]);
  } else {
    /* istanbul ignore if */
    if (isDef(oldHook.fns) && isTrue(oldHook.merged)) {
      // already a merged invoker
      invoker = oldHook;
      invoker.fns.push(wrappedHook);
    } else {
      // existing plain hook
      invoker = createFnInvoker([oldHook, wrappedHook]);
    }
  }

  invoker.merged = true;
  def[hookKey] = invoker;
}

/*  */

function extractPropsFromVNodeData (
  data,
  Ctor,
  tag
) {
  // we are only extracting raw values here.
  // validation and default values are handled in the child
  // component itself.
  var propOptions = Ctor.options.props;
  if (isUndef(propOptions)) {
    return
  }
  var res = {};
  var attrs = data.attrs;
  var props = data.props;
  if (isDef(attrs) || isDef(props)) {
    for (var key in propOptions) {
      var altKey = hyphenate(key);
      if (true) {
        var keyInLowerCase = key.toLowerCase();
        if (
          key !== keyInLowerCase &&
          attrs && hasOwn(attrs, keyInLowerCase)
        ) {
          tip(
            "Prop \"" + keyInLowerCase + "\" is passed to component " +
            (formatComponentName(tag || Ctor)) + ", but the declared prop name is" +
            " \"" + key + "\". " +
            "Note that HTML attributes are case-insensitive and camelCased " +
            "props need to use their kebab-case equivalents when using in-DOM " +
            "templates. You should probably use \"" + altKey + "\" instead of \"" + key + "\"."
          );
        }
      }
      checkProp(res, props, key, altKey, true) ||
      checkProp(res, attrs, key, altKey, false);
    }
  }
  return res
}

function checkProp (
  res,
  hash,
  key,
  altKey,
  preserve
) {
  if (isDef(hash)) {
    if (hasOwn(hash, key)) {
      res[key] = hash[key];
      if (!preserve) {
        delete hash[key];
      }
      return true
    } else if (hasOwn(hash, altKey)) {
      res[key] = hash[altKey];
      if (!preserve) {
        delete hash[altKey];
      }
      return true
    }
  }
  return false
}

/*  */

// The template compiler attempts to minimize the need for normalization by
// statically analyzing the template at compile time.
//
// For plain HTML markup, normalization can be completely skipped because the
// generated render function is guaranteed to return Array<VNode>. There are
// two cases where extra normalization is needed:

// 1. When the children contains components - because a functional component
// may return an Array instead of a single root. In this case, just a simple
// normalization is needed - if any child is an Array, we flatten the whole
// thing with Array.prototype.concat. It is guaranteed to be only 1-level deep
// because functional components already normalize their own children.
function simpleNormalizeChildren (children) {
  for (var i = 0; i < children.length; i++) {
    if (Array.isArray(children[i])) {
      return Array.prototype.concat.apply([], children)
    }
  }
  return children
}

// 2. When the children contains constructs that always generated nested Arrays,
// e.g. <template>, <slot>, v-for, or when the children is provided by user
// with hand-written render functions / JSX. In such cases a full normalization
// is needed to cater to all possible types of children values.
function normalizeChildren (children) {
  return isPrimitive(children)
    ? [createTextVNode(children)]
    : Array.isArray(children)
      ? normalizeArrayChildren(children)
      : undefined
}

function isTextNode (node) {
  return isDef(node) && isDef(node.text) && isFalse(node.isComment)
}

function normalizeArrayChildren (children, nestedIndex) {
  var res = [];
  var i, c, lastIndex, last;
  for (i = 0; i < children.length; i++) {
    c = children[i];
    if (isUndef(c) || typeof c === 'boolean') { continue }
    lastIndex = res.length - 1;
    last = res[lastIndex];
    //  nested
    if (Array.isArray(c)) {
      if (c.length > 0) {
        c = normalizeArrayChildren(c, ((nestedIndex || '') + "_" + i));
        // merge adjacent text nodes
        if (isTextNode(c[0]) && isTextNode(last)) {
          res[lastIndex] = createTextVNode(last.text + (c[0]).text);
          c.shift();
        }
        res.push.apply(res, c);
      }
    } else if (isPrimitive(c)) {
      if (isTextNode(last)) {
        // merge adjacent text nodes
        // this is necessary for SSR hydration because text nodes are
        // essentially merged when rendered to HTML strings
        res[lastIndex] = createTextVNode(last.text + c);
      } else if (c !== '') {
        // convert primitive to vnode
        res.push(createTextVNode(c));
      }
    } else {
      if (isTextNode(c) && isTextNode(last)) {
        // merge adjacent text nodes
        res[lastIndex] = createTextVNode(last.text + c.text);
      } else {
        // default key for nested array children (likely generated by v-for)
        if (isTrue(children._isVList) &&
          isDef(c.tag) &&
          isUndef(c.key) &&
          isDef(nestedIndex)) {
          c.key = "__vlist" + nestedIndex + "_" + i + "__";
        }
        res.push(c);
      }
    }
  }
  return res
}

/*  */

function initProvide (vm) {
  var provide = vm.$options.provide;
  if (provide) {
    vm._provided = typeof provide === 'function'
      ? provide.call(vm)
      : provide;
  }
}

function initInjections (vm) {
  var result = resolveInject(vm.$options.inject, vm);
  if (result) {
    toggleObserving(false);
    Object.keys(result).forEach(function (key) {
      /* istanbul ignore else */
      if (true) {
        defineReactive$$1(vm, key, result[key], function () {
          warn(
            "Avoid mutating an injected value directly since the changes will be " +
            "overwritten whenever the provided component re-renders. " +
            "injection being mutated: \"" + key + "\"",
            vm
          );
        });
      } else {}
    });
    toggleObserving(true);
  }
}

function resolveInject (inject, vm) {
  if (inject) {
    // inject is :any because flow is not smart enough to figure out cached
    var result = Object.create(null);
    var keys = hasSymbol
      ? Reflect.ownKeys(inject)
      : Object.keys(inject);

    for (var i = 0; i < keys.length; i++) {
      var key = keys[i];
      // #6574 in case the inject object is observed...
      if (key === '__ob__') { continue }
      var provideKey = inject[key].from;
      var source = vm;
      while (source) {
        if (source._provided && hasOwn(source._provided, provideKey)) {
          result[key] = source._provided[provideKey];
          break
        }
        source = source.$parent;
      }
      if (!source) {
        if ('default' in inject[key]) {
          var provideDefault = inject[key].default;
          result[key] = typeof provideDefault === 'function'
            ? provideDefault.call(vm)
            : provideDefault;
        } else if (true) {
          warn(("Injection \"" + key + "\" not found"), vm);
        }
      }
    }
    return result
  }
}

/*  */



/**
 * Runtime helper for resolving raw children VNodes into a slot object.
 */
function resolveSlots (
  children,
  context
) {
  if (!children || !children.length) {
    return {}
  }
  var slots = {};
  for (var i = 0, l = children.length; i < l; i++) {
    var child = children[i];
    var data = child.data;
    // remove slot attribute if the node is resolved as a Vue slot node
    if (data && data.attrs && data.attrs.slot) {
      delete data.attrs.slot;
    }
    // named slots should only be respected if the vnode was rendered in the
    // same context.
    if ((child.context === context || child.fnContext === context) &&
      data && data.slot != null
    ) {
      var name = data.slot;
      var slot = (slots[name] || (slots[name] = []));
      if (child.tag === 'template') {
        slot.push.apply(slot, child.children || []);
      } else {
        slot.push(child);
      }
    } else {
      (slots.default || (slots.default = [])).push(child);
    }
  }
  // ignore slots that contains only whitespace
  for (var name$1 in slots) {
    if (slots[name$1].every(isWhitespace)) {
      delete slots[name$1];
    }
  }
  return slots
}

function isWhitespace (node) {
  return (node.isComment && !node.asyncFactory) || node.text === ' '
}

/*  */

function isAsyncPlaceholder (node) {
  return node.isComment && node.asyncFactory
}

/*  */

function normalizeScopedSlots (
  slots,
  normalSlots,
  prevSlots
) {
  var res;
  var hasNormalSlots = Object.keys(normalSlots).length > 0;
  var isStable = slots ? !!slots.$stable : !hasNormalSlots;
  var key = slots && slots.$key;
  if (!slots) {
    res = {};
  } else if (slots._normalized) {
    // fast path 1: child component re-render only, parent did not change
    return slots._normalized
  } else if (
    isStable &&
    prevSlots &&
    prevSlots !== emptyObject &&
    key === prevSlots.$key &&
    !hasNormalSlots &&
    !prevSlots.$hasNormal
  ) {
    // fast path 2: stable scoped slots w/ no normal slots to proxy,
    // only need to normalize once
    return prevSlots
  } else {
    res = {};
    for (var key$1 in slots) {
      if (slots[key$1] && key$1[0] !== '$') {
        res[key$1] = normalizeScopedSlot(normalSlots, key$1, slots[key$1]);
      }
    }
  }
  // expose normal slots on scopedSlots
  for (var key$2 in normalSlots) {
    if (!(key$2 in res)) {
      res[key$2] = proxyNormalSlot(normalSlots, key$2);
    }
  }
  // avoriaz seems to mock a non-extensible $scopedSlots object
  // and when that is passed down this would cause an error
  if (slots && Object.isExtensible(slots)) {
    (slots)._normalized = res;
  }
  def(res, '$stable', isStable);
  def(res, '$key', key);
  def(res, '$hasNormal', hasNormalSlots);
  return res
}

function normalizeScopedSlot(normalSlots, key, fn) {
  var normalized = function () {
    var res = arguments.length ? fn.apply(null, arguments) : fn({});
    res = res && typeof res === 'object' && !Array.isArray(res)
      ? [res] // single vnode
      : normalizeChildren(res);
    var vnode = res && res[0];
    return res && (
      !vnode ||
      (res.length === 1 && vnode.isComment && !isAsyncPlaceholder(vnode)) // #9658, #10391
    ) ? undefined
      : res
  };
  // this is a slot using the new v-slot syntax without scope. although it is
  // compiled as a scoped slot, render fn users would expect it to be present
  // on this.$slots because the usage is semantically a normal slot.
  if (fn.proxy) {
    Object.defineProperty(normalSlots, key, {
      get: normalized,
      enumerable: true,
      configurable: true
    });
  }
  return normalized
}

function proxyNormalSlot(slots, key) {
  return function () { return slots[key]; }
}

/*  */

/**
 * Runtime helper for rendering v-for lists.
 */
function renderList (
  val,
  render
) {
  var ret, i, l, keys, key;
  if (Array.isArray(val) || typeof val === 'string') {
    ret = new Array(val.length);
    for (i = 0, l = val.length; i < l; i++) {
      ret[i] = render(val[i], i);
    }
  } else if (typeof val === 'number') {
    ret = new Array(val);
    for (i = 0; i < val; i++) {
      ret[i] = render(i + 1, i);
    }
  } else if (isObject(val)) {
    if (hasSymbol && val[Symbol.iterator]) {
      ret = [];
      var iterator = val[Symbol.iterator]();
      var result = iterator.next();
      while (!result.done) {
        ret.push(render(result.value, ret.length));
        result = iterator.next();
      }
    } else {
      keys = Object.keys(val);
      ret = new Array(keys.length);
      for (i = 0, l = keys.length; i < l; i++) {
        key = keys[i];
        ret[i] = render(val[key], key, i);
      }
    }
  }
  if (!isDef(ret)) {
    ret = [];
  }
  (ret)._isVList = true;
  return ret
}

/*  */

/**
 * Runtime helper for rendering <slot>
 */
function renderSlot (
  name,
  fallbackRender,
  props,
  bindObject
) {
  var scopedSlotFn = this.$scopedSlots[name];
  var nodes;
  if (scopedSlotFn) {
    // scoped slot
    props = props || {};
    if (bindObject) {
      if ( true && !isObject(bindObject)) {
        warn('slot v-bind without argument expects an Object', this);
      }
      props = extend(extend({}, bindObject), props);
    }
    nodes =
      scopedSlotFn(props) ||
      (typeof fallbackRender === 'function' ? fallbackRender() : fallbackRender);
  } else {
    nodes =
      this.$slots[name] ||
      (typeof fallbackRender === 'function' ? fallbackRender() : fallbackRender);
  }

  var target = props && props.slot;
  if (target) {
    return this.$createElement('template', { slot: target }, nodes)
  } else {
    return nodes
  }
}

/*  */

/**
 * Runtime helper for resolving filters
 */
function resolveFilter (id) {
  return resolveAsset(this.$options, 'filters', id, true) || identity
}

/*  */

function isKeyNotMatch (expect, actual) {
  if (Array.isArray(expect)) {
    return expect.indexOf(actual) === -1
  } else {
    return expect !== actual
  }
}

/**
 * Runtime helper for checking keyCodes from config.
 * exposed as Vue.prototype._k
 * passing in eventKeyName as last argument separately for backwards compat
 */
function checkKeyCodes (
  eventKeyCode,
  key,
  builtInKeyCode,
  eventKeyName,
  builtInKeyName
) {
  var mappedKeyCode = config.keyCodes[key] || builtInKeyCode;
  if (builtInKeyName && eventKeyName && !config.keyCodes[key]) {
    return isKeyNotMatch(builtInKeyName, eventKeyName)
  } else if (mappedKeyCode) {
    return isKeyNotMatch(mappedKeyCode, eventKeyCode)
  } else if (eventKeyName) {
    return hyphenate(eventKeyName) !== key
  }
  return eventKeyCode === undefined
}

/*  */

/**
 * Runtime helper for merging v-bind="object" into a VNode's data.
 */
function bindObjectProps (
  data,
  tag,
  value,
  asProp,
  isSync
) {
  if (value) {
    if (!isObject(value)) {
       true && warn(
        'v-bind without argument expects an Object or Array value',
        this
      );
    } else {
      if (Array.isArray(value)) {
        value = toObject(value);
      }
      var hash;
      var loop = function ( key ) {
        if (
          key === 'class' ||
          key === 'style' ||
          isReservedAttribute(key)
        ) {
          hash = data;
        } else {
          var type = data.attrs && data.attrs.type;
          hash = asProp || config.mustUseProp(tag, type, key)
            ? data.domProps || (data.domProps = {})
            : data.attrs || (data.attrs = {});
        }
        var camelizedKey = camelize(key);
        var hyphenatedKey = hyphenate(key);
        if (!(camelizedKey in hash) && !(hyphenatedKey in hash)) {
          hash[key] = value[key];

          if (isSync) {
            var on = data.on || (data.on = {});
            on[("update:" + key)] = function ($event) {
              value[key] = $event;
            };
          }
        }
      };

      for (var key in value) loop( key );
    }
  }
  return data
}

/*  */

/**
 * Runtime helper for rendering static trees.
 */
function renderStatic (
  index,
  isInFor
) {
  var cached = this._staticTrees || (this._staticTrees = []);
  var tree = cached[index];
  // if has already-rendered static tree and not inside v-for,
  // we can reuse the same tree.
  if (tree && !isInFor) {
    return tree
  }
  // otherwise, render a fresh tree.
  tree = cached[index] = this.$options.staticRenderFns[index].call(
    this._renderProxy,
    null,
    this // for render fns generated for functional component templates
  );
  markStatic(tree, ("__static__" + index), false);
  return tree
}

/**
 * Runtime helper for v-once.
 * Effectively it means marking the node as static with a unique key.
 */
function markOnce (
  tree,
  index,
  key
) {
  markStatic(tree, ("__once__" + index + (key ? ("_" + key) : "")), true);
  return tree
}

function markStatic (
  tree,
  key,
  isOnce
) {
  if (Array.isArray(tree)) {
    for (var i = 0; i < tree.length; i++) {
      if (tree[i] && typeof tree[i] !== 'string') {
        markStaticNode(tree[i], (key + "_" + i), isOnce);
      }
    }
  } else {
    markStaticNode(tree, key, isOnce);
  }
}

function markStaticNode (node, key, isOnce) {
  node.isStatic = true;
  node.key = key;
  node.isOnce = isOnce;
}

/*  */

function bindObjectListeners (data, value) {
  if (value) {
    if (!isPlainObject(value)) {
       true && warn(
        'v-on without argument expects an Object value',
        this
      );
    } else {
      var on = data.on = data.on ? extend({}, data.on) : {};
      for (var key in value) {
        var existing = on[key];
        var ours = value[key];
        on[key] = existing ? [].concat(existing, ours) : ours;
      }
    }
  }
  return data
}

/*  */

function resolveScopedSlots (
  fns, // see flow/vnode
  res,
  // the following are added in 2.6
  hasDynamicKeys,
  contentHashKey
) {
  res = res || { $stable: !hasDynamicKeys };
  for (var i = 0; i < fns.length; i++) {
    var slot = fns[i];
    if (Array.isArray(slot)) {
      resolveScopedSlots(slot, res, hasDynamicKeys);
    } else if (slot) {
      // marker for reverse proxying v-slot without scope on this.$slots
      if (slot.proxy) {
        slot.fn.proxy = true;
      }
      res[slot.key] = slot.fn;
    }
  }
  if (contentHashKey) {
    (res).$key = contentHashKey;
  }
  return res
}

/*  */

function bindDynamicKeys (baseObj, values) {
  for (var i = 0; i < values.length; i += 2) {
    var key = values[i];
    if (typeof key === 'string' && key) {
      baseObj[values[i]] = values[i + 1];
    } else if ( true && key !== '' && key !== null) {
      // null is a special value for explicitly removing a binding
      warn(
        ("Invalid value for dynamic directive argument (expected string or null): " + key),
        this
      );
    }
  }
  return baseObj
}

// helper to dynamically append modifier runtime markers to event names.
// ensure only append when value is already string, otherwise it will be cast
// to string and cause the type check to miss.
function prependModifier (value, symbol) {
  return typeof value === 'string' ? symbol + value : value
}

/*  */

function installRenderHelpers (target) {
  target._o = markOnce;
  target._n = toNumber;
  target._s = toString;
  target._l = renderList;
  target._t = renderSlot;
  target._q = looseEqual;
  target._i = looseIndexOf;
  target._m = renderStatic;
  target._f = resolveFilter;
  target._k = checkKeyCodes;
  target._b = bindObjectProps;
  target._v = createTextVNode;
  target._e = createEmptyVNode;
  target._u = resolveScopedSlots;
  target._g = bindObjectListeners;
  target._d = bindDynamicKeys;
  target._p = prependModifier;
}

/*  */

function FunctionalRenderContext (
  data,
  props,
  children,
  parent,
  Ctor
) {
  var this$1 = this;

  var options = Ctor.options;
  // ensure the createElement function in functional components
  // gets a unique context - this is necessary for correct named slot check
  var contextVm;
  if (hasOwn(parent, '_uid')) {
    contextVm = Object.create(parent);
    // $flow-disable-line
    contextVm._original = parent;
  } else {
    // the context vm passed in is a functional context as well.
    // in this case we want to make sure we are able to get a hold to the
    // real context instance.
    contextVm = parent;
    // $flow-disable-line
    parent = parent._original;
  }
  var isCompiled = isTrue(options._compiled);
  var needNormalization = !isCompiled;

  this.data = data;
  this.props = props;
  this.children = children;
  this.parent = parent;
  this.listeners = data.on || emptyObject;
  this.injections = resolveInject(options.inject, parent);
  this.slots = function () {
    if (!this$1.$slots) {
      normalizeScopedSlots(
        data.scopedSlots,
        this$1.$slots = resolveSlots(children, parent)
      );
    }
    return this$1.$slots
  };

  Object.defineProperty(this, 'scopedSlots', ({
    enumerable: true,
    get: function get () {
      return normalizeScopedSlots(data.scopedSlots, this.slots())
    }
  }));

  // support for compiled functional template
  if (isCompiled) {
    // exposing $options for renderStatic()
    this.$options = options;
    // pre-resolve slots for renderSlot()
    this.$slots = this.slots();
    this.$scopedSlots = normalizeScopedSlots(data.scopedSlots, this.$slots);
  }

  if (options._scopeId) {
    this._c = function (a, b, c, d) {
      var vnode = createElement(contextVm, a, b, c, d, needNormalization);
      if (vnode && !Array.isArray(vnode)) {
        vnode.fnScopeId = options._scopeId;
        vnode.fnContext = parent;
      }
      return vnode
    };
  } else {
    this._c = function (a, b, c, d) { return createElement(contextVm, a, b, c, d, needNormalization); };
  }
}

installRenderHelpers(FunctionalRenderContext.prototype);

function createFunctionalComponent (
  Ctor,
  propsData,
  data,
  contextVm,
  children
) {
  var options = Ctor.options;
  var props = {};
  var propOptions = options.props;
  if (isDef(propOptions)) {
    for (var key in propOptions) {
      props[key] = validateProp(key, propOptions, propsData || emptyObject);
    }
  } else {
    if (isDef(data.attrs)) { mergeProps(props, data.attrs); }
    if (isDef(data.props)) { mergeProps(props, data.props); }
  }

  var renderContext = new FunctionalRenderContext(
    data,
    props,
    children,
    contextVm,
    Ctor
  );

  var vnode = options.render.call(null, renderContext._c, renderContext);

  if (vnode instanceof VNode) {
    return cloneAndMarkFunctionalResult(vnode, data, renderContext.parent, options, renderContext)
  } else if (Array.isArray(vnode)) {
    var vnodes = normalizeChildren(vnode) || [];
    var res = new Array(vnodes.length);
    for (var i = 0; i < vnodes.length; i++) {
      res[i] = cloneAndMarkFunctionalResult(vnodes[i], data, renderContext.parent, options, renderContext);
    }
    return res
  }
}

function cloneAndMarkFunctionalResult (vnode, data, contextVm, options, renderContext) {
  // #7817 clone node before setting fnContext, otherwise if the node is reused
  // (e.g. it was from a cached normal slot) the fnContext causes named slots
  // that should not be matched to match.
  var clone = cloneVNode(vnode);
  clone.fnContext = contextVm;
  clone.fnOptions = options;
  if (true) {
    (clone.devtoolsMeta = clone.devtoolsMeta || {}).renderContext = renderContext;
  }
  if (data.slot) {
    (clone.data || (clone.data = {})).slot = data.slot;
  }
  return clone
}

function mergeProps (to, from) {
  for (var key in from) {
    to[camelize(key)] = from[key];
  }
}

/*  */

/*  */

/*  */

/*  */

// inline hooks to be invoked on component VNodes during patch
var componentVNodeHooks = {
  init: function init (vnode, hydrating) {
    if (
      vnode.componentInstance &&
      !vnode.componentInstance._isDestroyed &&
      vnode.data.keepAlive
    ) {
      // kept-alive components, treat as a patch
      var mountedNode = vnode; // work around flow
      componentVNodeHooks.prepatch(mountedNode, mountedNode);
    } else {
      var child = vnode.componentInstance = createComponentInstanceForVnode(
        vnode,
        activeInstance
      );
      child.$mount(hydrating ? vnode.elm : undefined, hydrating);
    }
  },

  prepatch: function prepatch (oldVnode, vnode) {
    var options = vnode.componentOptions;
    var child = vnode.componentInstance = oldVnode.componentInstance;
    updateChildComponent(
      child,
      options.propsData, // updated props
      options.listeners, // updated listeners
      vnode, // new parent vnode
      options.children // new children
    );
  },

  insert: function insert (vnode) {
    var context = vnode.context;
    var componentInstance = vnode.componentInstance;
    if (!componentInstance._isMounted) {
      componentInstance._isMounted = true;
      callHook(componentInstance, 'mounted');
    }
    if (vnode.data.keepAlive) {
      if (context._isMounted) {
        // vue-router#1212
        // During updates, a kept-alive component's child components may
        // change, so directly walking the tree here may call activated hooks
        // on incorrect children. Instead we push them into a queue which will
        // be processed after the whole patch process ended.
        queueActivatedComponent(componentInstance);
      } else {
        activateChildComponent(componentInstance, true /* direct */);
      }
    }
  },

  destroy: function destroy (vnode) {
    var componentInstance = vnode.componentInstance;
    if (!componentInstance._isDestroyed) {
      if (!vnode.data.keepAlive) {
        componentInstance.$destroy();
      } else {
        deactivateChildComponent(componentInstance, true /* direct */);
      }
    }
  }
};

var hooksToMerge = Object.keys(componentVNodeHooks);

function createComponent (
  Ctor,
  data,
  context,
  children,
  tag
) {
  if (isUndef(Ctor)) {
    return
  }

  var baseCtor = context.$options._base;

  // plain options object: turn it into a constructor
  if (isObject(Ctor)) {
    Ctor = baseCtor.extend(Ctor);
  }

  // if at this stage it's not a constructor or an async component factory,
  // reject.
  if (typeof Ctor !== 'function') {
    if (true) {
      warn(("Invalid Component definition: " + (String(Ctor))), context);
    }
    return
  }

  // async component
  var asyncFactory;
  if (isUndef(Ctor.cid)) {
    asyncFactory = Ctor;
    Ctor = resolveAsyncComponent(asyncFactory, baseCtor);
    if (Ctor === undefined) {
      // return a placeholder node for async component, which is rendered
      // as a comment node but preserves all the raw information for the node.
      // the information will be used for async server-rendering and hydration.
      return createAsyncPlaceholder(
        asyncFactory,
        data,
        context,
        children,
        tag
      )
    }
  }

  data = data || {};

  // resolve constructor options in case global mixins are applied after
  // component constructor creation
  resolveConstructorOptions(Ctor);

  // transform component v-model data into props & events
  if (isDef(data.model)) {
    transformModel(Ctor.options, data);
  }

  // extract props
  var propsData = extractPropsFromVNodeData(data, Ctor, tag);

  // functional component
  if (isTrue(Ctor.options.functional)) {
    return createFunctionalComponent(Ctor, propsData, data, context, children)
  }

  // extract listeners, since these needs to be treated as
  // child component listeners instead of DOM listeners
  var listeners = data.on;
  // replace with listeners with .native modifier
  // so it gets processed during parent component patch.
  data.on = data.nativeOn;

  if (isTrue(Ctor.options.abstract)) {
    // abstract components do not keep anything
    // other than props & listeners & slot

    // work around flow
    var slot = data.slot;
    data = {};
    if (slot) {
      data.slot = slot;
    }
  }

  // install component management hooks onto the placeholder node
  installComponentHooks(data);

  // return a placeholder vnode
  var name = Ctor.options.name || tag;
  var vnode = new VNode(
    ("vue-component-" + (Ctor.cid) + (name ? ("-" + name) : '')),
    data, undefined, undefined, undefined, context,
    { Ctor: Ctor, propsData: propsData, listeners: listeners, tag: tag, children: children },
    asyncFactory
  );

  return vnode
}

function createComponentInstanceForVnode (
  // we know it's MountedComponentVNode but flow doesn't
  vnode,
  // activeInstance in lifecycle state
  parent
) {
  var options = {
    _isComponent: true,
    _parentVnode: vnode,
    parent: parent
  };
  // check inline-template render functions
  var inlineTemplate = vnode.data.inlineTemplate;
  if (isDef(inlineTemplate)) {
    options.render = inlineTemplate.render;
    options.staticRenderFns = inlineTemplate.staticRenderFns;
  }
  return new vnode.componentOptions.Ctor(options)
}

function installComponentHooks (data) {
  var hooks = data.hook || (data.hook = {});
  for (var i = 0; i < hooksToMerge.length; i++) {
    var key = hooksToMerge[i];
    var existing = hooks[key];
    var toMerge = componentVNodeHooks[key];
    if (existing !== toMerge && !(existing && existing._merged)) {
      hooks[key] = existing ? mergeHook$1(toMerge, existing) : toMerge;
    }
  }
}

function mergeHook$1 (f1, f2) {
  var merged = function (a, b) {
    // flow complains about extra args which is why we use any
    f1(a, b);
    f2(a, b);
  };
  merged._merged = true;
  return merged
}

// transform component v-model info (value and callback) into
// prop and event handler respectively.
function transformModel (options, data) {
  var prop = (options.model && options.model.prop) || 'value';
  var event = (options.model && options.model.event) || 'input'
  ;(data.attrs || (data.attrs = {}))[prop] = data.model.value;
  var on = data.on || (data.on = {});
  var existing = on[event];
  var callback = data.model.callback;
  if (isDef(existing)) {
    if (
      Array.isArray(existing)
        ? existing.indexOf(callback) === -1
        : existing !== callback
    ) {
      on[event] = [callback].concat(existing);
    }
  } else {
    on[event] = callback;
  }
}

/*  */

var SIMPLE_NORMALIZE = 1;
var ALWAYS_NORMALIZE = 2;

// wrapper function for providing a more flexible interface
// without getting yelled at by flow
function createElement (
  context,
  tag,
  data,
  children,
  normalizationType,
  alwaysNormalize
) {
  if (Array.isArray(data) || isPrimitive(data)) {
    normalizationType = children;
    children = data;
    data = undefined;
  }
  if (isTrue(alwaysNormalize)) {
    normalizationType = ALWAYS_NORMALIZE;
  }
  return _createElement(context, tag, data, children, normalizationType)
}

function _createElement (
  context,
  tag,
  data,
  children,
  normalizationType
) {
  if (isDef(data) && isDef((data).__ob__)) {
     true && warn(
      "Avoid using observed data object as vnode data: " + (JSON.stringify(data)) + "\n" +
      'Always create fresh vnode data objects in each render!',
      context
    );
    return createEmptyVNode()
  }
  // object syntax in v-bind
  if (isDef(data) && isDef(data.is)) {
    tag = data.is;
  }
  if (!tag) {
    // in case of component :is set to falsy value
    return createEmptyVNode()
  }
  // warn against non-primitive key
  if ( true &&
    isDef(data) && isDef(data.key) && !isPrimitive(data.key)
  ) {
    {
      warn(
        'Avoid using non-primitive value as key, ' +
        'use string/number value instead.',
        context
      );
    }
  }
  // support single function children as default scoped slot
  if (Array.isArray(children) &&
    typeof children[0] === 'function'
  ) {
    data = data || {};
    data.scopedSlots = { default: children[0] };
    children.length = 0;
  }
  if (normalizationType === ALWAYS_NORMALIZE) {
    children = normalizeChildren(children);
  } else if (normalizationType === SIMPLE_NORMALIZE) {
    children = simpleNormalizeChildren(children);
  }
  var vnode, ns;
  if (typeof tag === 'string') {
    var Ctor;
    ns = (context.$vnode && context.$vnode.ns) || config.getTagNamespace(tag);
    if (config.isReservedTag(tag)) {
      // platform built-in elements
      if ( true && isDef(data) && isDef(data.nativeOn) && data.tag !== 'component') {
        warn(
          ("The .native modifier for v-on is only valid on components but it was used on <" + tag + ">."),
          context
        );
      }
      vnode = new VNode(
        config.parsePlatformTagName(tag), data, children,
        undefined, undefined, context
      );
    } else if ((!data || !data.pre) && isDef(Ctor = resolveAsset(context.$options, 'components', tag))) {
      // component
      vnode = createComponent(Ctor, data, context, children, tag);
    } else {
      // unknown or unlisted namespaced elements
      // check at runtime because it may get assigned a namespace when its
      // parent normalizes children
      vnode = new VNode(
        tag, data, children,
        undefined, undefined, context
      );
    }
  } else {
    // direct component options / constructor
    vnode = createComponent(tag, data, context, children);
  }
  if (Array.isArray(vnode)) {
    return vnode
  } else if (isDef(vnode)) {
    if (isDef(ns)) { applyNS(vnode, ns); }
    if (isDef(data)) { registerDeepBindings(data); }
    return vnode
  } else {
    return createEmptyVNode()
  }
}

function applyNS (vnode, ns, force) {
  vnode.ns = ns;
  if (vnode.tag === 'foreignObject') {
    // use default namespace inside foreignObject
    ns = undefined;
    force = true;
  }
  if (isDef(vnode.children)) {
    for (var i = 0, l = vnode.children.length; i < l; i++) {
      var child = vnode.children[i];
      if (isDef(child.tag) && (
        isUndef(child.ns) || (isTrue(force) && child.tag !== 'svg'))) {
        applyNS(child, ns, force);
      }
    }
  }
}

// ref #5318
// necessary to ensure parent re-render when deep bindings like :style and
// :class are used on slot nodes
function registerDeepBindings (data) {
  if (isObject(data.style)) {
    traverse(data.style);
  }
  if (isObject(data.class)) {
    traverse(data.class);
  }
}

/*  */

function initRender (vm) {
  vm._vnode = null; // the root of the child tree
  vm._staticTrees = null; // v-once cached trees
  var options = vm.$options;
  var parentVnode = vm.$vnode = options._parentVnode; // the placeholder node in parent tree
  var renderContext = parentVnode && parentVnode.context;
  vm.$slots = resolveSlots(options._renderChildren, renderContext);
  vm.$scopedSlots = emptyObject;
  // bind the createElement fn to this instance
  // so that we get proper render context inside it.
  // args order: tag, data, children, normalizationType, alwaysNormalize
  // internal version is used by render functions compiled from templates
  vm._c = function (a, b, c, d) { return createElement(vm, a, b, c, d, false); };
  // normalization is always applied for the public version, used in
  // user-written render functions.
  vm.$createElement = function (a, b, c, d) { return createElement(vm, a, b, c, d, true); };

  // $attrs & $listeners are exposed for easier HOC creation.
  // they need to be reactive so that HOCs using them are always updated
  var parentData = parentVnode && parentVnode.data;

  /* istanbul ignore else */
  if (true) {
    defineReactive$$1(vm, '$attrs', parentData && parentData.attrs || emptyObject, function () {
      !isUpdatingChildComponent && warn("$attrs is readonly.", vm);
    }, true);
    defineReactive$$1(vm, '$listeners', options._parentListeners || emptyObject, function () {
      !isUpdatingChildComponent && warn("$listeners is readonly.", vm);
    }, true);
  } else {}
}

var currentRenderingInstance = null;

function renderMixin (Vue) {
  // install runtime convenience helpers
  installRenderHelpers(Vue.prototype);

  Vue.prototype.$nextTick = function (fn) {
    return nextTick(fn, this)
  };

  Vue.prototype._render = function () {
    var vm = this;
    var ref = vm.$options;
    var render = ref.render;
    var _parentVnode = ref._parentVnode;

    if (_parentVnode) {
      vm.$scopedSlots = normalizeScopedSlots(
        _parentVnode.data.scopedSlots,
        vm.$slots,
        vm.$scopedSlots
      );
    }

    // set parent vnode. this allows render functions to have access
    // to the data on the placeholder node.
    vm.$vnode = _parentVnode;
    // render self
    var vnode;
    try {
      // There's no need to maintain a stack because all render fns are called
      // separately from one another. Nested component's render fns are called
      // when parent component is patched.
      currentRenderingInstance = vm;
      vnode = render.call(vm._renderProxy, vm.$createElement);
    } catch (e) {
      handleError(e, vm, "render");
      // return error render result,
      // or previous vnode to prevent render error causing blank component
      /* istanbul ignore else */
      if ( true && vm.$options.renderError) {
        try {
          vnode = vm.$options.renderError.call(vm._renderProxy, vm.$createElement, e);
        } catch (e) {
          handleError(e, vm, "renderError");
          vnode = vm._vnode;
        }
      } else {
        vnode = vm._vnode;
      }
    } finally {
      currentRenderingInstance = null;
    }
    // if the returned array contains only a single node, allow it
    if (Array.isArray(vnode) && vnode.length === 1) {
      vnode = vnode[0];
    }
    // return empty vnode in case the render function errored out
    if (!(vnode instanceof VNode)) {
      if ( true && Array.isArray(vnode)) {
        warn(
          'Multiple root nodes returned from render function. Render function ' +
          'should return a single root node.',
          vm
        );
      }
      vnode = createEmptyVNode();
    }
    // set parent
    vnode.parent = _parentVnode;
    return vnode
  };
}

/*  */

function ensureCtor (comp, base) {
  if (
    comp.__esModule ||
    (hasSymbol && comp[Symbol.toStringTag] === 'Module')
  ) {
    comp = comp.default;
  }
  return isObject(comp)
    ? base.extend(comp)
    : comp
}

function createAsyncPlaceholder (
  factory,
  data,
  context,
  children,
  tag
) {
  var node = createEmptyVNode();
  node.asyncFactory = factory;
  node.asyncMeta = { data: data, context: context, children: children, tag: tag };
  return node
}

function resolveAsyncComponent (
  factory,
  baseCtor
) {
  if (isTrue(factory.error) && isDef(factory.errorComp)) {
    return factory.errorComp
  }

  if (isDef(factory.resolved)) {
    return factory.resolved
  }

  var owner = currentRenderingInstance;
  if (owner && isDef(factory.owners) && factory.owners.indexOf(owner) === -1) {
    // already pending
    factory.owners.push(owner);
  }

  if (isTrue(factory.loading) && isDef(factory.loadingComp)) {
    return factory.loadingComp
  }

  if (owner && !isDef(factory.owners)) {
    var owners = factory.owners = [owner];
    var sync = true;
    var timerLoading = null;
    var timerTimeout = null

    ;(owner).$on('hook:destroyed', function () { return remove(owners, owner); });

    var forceRender = function (renderCompleted) {
      for (var i = 0, l = owners.length; i < l; i++) {
        (owners[i]).$forceUpdate();
      }

      if (renderCompleted) {
        owners.length = 0;
        if (timerLoading !== null) {
          clearTimeout(timerLoading);
          timerLoading = null;
        }
        if (timerTimeout !== null) {
          clearTimeout(timerTimeout);
          timerTimeout = null;
        }
      }
    };

    var resolve = once(function (res) {
      // cache resolved
      factory.resolved = ensureCtor(res, baseCtor);
      // invoke callbacks only if this is not a synchronous resolve
      // (async resolves are shimmed as synchronous during SSR)
      if (!sync) {
        forceRender(true);
      } else {
        owners.length = 0;
      }
    });

    var reject = once(function (reason) {
       true && warn(
        "Failed to resolve async component: " + (String(factory)) +
        (reason ? ("\nReason: " + reason) : '')
      );
      if (isDef(factory.errorComp)) {
        factory.error = true;
        forceRender(true);
      }
    });

    var res = factory(resolve, reject);

    if (isObject(res)) {
      if (isPromise(res)) {
        // () => Promise
        if (isUndef(factory.resolved)) {
          res.then(resolve, reject);
        }
      } else if (isPromise(res.component)) {
        res.component.then(resolve, reject);

        if (isDef(res.error)) {
          factory.errorComp = ensureCtor(res.error, baseCtor);
        }

        if (isDef(res.loading)) {
          factory.loadingComp = ensureCtor(res.loading, baseCtor);
          if (res.delay === 0) {
            factory.loading = true;
          } else {
            timerLoading = setTimeout(function () {
              timerLoading = null;
              if (isUndef(factory.resolved) && isUndef(factory.error)) {
                factory.loading = true;
                forceRender(false);
              }
            }, res.delay || 200);
          }
        }

        if (isDef(res.timeout)) {
          timerTimeout = setTimeout(function () {
            timerTimeout = null;
            if (isUndef(factory.resolved)) {
              reject(
                 true
                  ? ("timeout (" + (res.timeout) + "ms)")
                  : 0
              );
            }
          }, res.timeout);
        }
      }
    }

    sync = false;
    // return in case resolved synchronously
    return factory.loading
      ? factory.loadingComp
      : factory.resolved
  }
}

/*  */

function getFirstComponentChild (children) {
  if (Array.isArray(children)) {
    for (var i = 0; i < children.length; i++) {
      var c = children[i];
      if (isDef(c) && (isDef(c.componentOptions) || isAsyncPlaceholder(c))) {
        return c
      }
    }
  }
}

/*  */

/*  */

function initEvents (vm) {
  vm._events = Object.create(null);
  vm._hasHookEvent = false;
  // init parent attached events
  var listeners = vm.$options._parentListeners;
  if (listeners) {
    updateComponentListeners(vm, listeners);
  }
}

var target;

function add (event, fn) {
  target.$on(event, fn);
}

function remove$1 (event, fn) {
  target.$off(event, fn);
}

function createOnceHandler (event, fn) {
  var _target = target;
  return function onceHandler () {
    var res = fn.apply(null, arguments);
    if (res !== null) {
      _target.$off(event, onceHandler);
    }
  }
}

function updateComponentListeners (
  vm,
  listeners,
  oldListeners
) {
  target = vm;
  updateListeners(listeners, oldListeners || {}, add, remove$1, createOnceHandler, vm);
  target = undefined;
}

function eventsMixin (Vue) {
  var hookRE = /^hook:/;
  Vue.prototype.$on = function (event, fn) {
    var vm = this;
    if (Array.isArray(event)) {
      for (var i = 0, l = event.length; i < l; i++) {
        vm.$on(event[i], fn);
      }
    } else {
      (vm._events[event] || (vm._events[event] = [])).push(fn);
      // optimize hook:event cost by using a boolean flag marked at registration
      // instead of a hash lookup
      if (hookRE.test(event)) {
        vm._hasHookEvent = true;
      }
    }
    return vm
  };

  Vue.prototype.$once = function (event, fn) {
    var vm = this;
    function on () {
      vm.$off(event, on);
      fn.apply(vm, arguments);
    }
    on.fn = fn;
    vm.$on(event, on);
    return vm
  };

  Vue.prototype.$off = function (event, fn) {
    var vm = this;
    // all
    if (!arguments.length) {
      vm._events = Object.create(null);
      return vm
    }
    // array of events
    if (Array.isArray(event)) {
      for (var i$1 = 0, l = event.length; i$1 < l; i$1++) {
        vm.$off(event[i$1], fn);
      }
      return vm
    }
    // specific event
    var cbs = vm._events[event];
    if (!cbs) {
      return vm
    }
    if (!fn) {
      vm._events[event] = null;
      return vm
    }
    // specific handler
    var cb;
    var i = cbs.length;
    while (i--) {
      cb = cbs[i];
      if (cb === fn || cb.fn === fn) {
        cbs.splice(i, 1);
        break
      }
    }
    return vm
  };

  Vue.prototype.$emit = function (event) {
    var vm = this;
    if (true) {
      var lowerCaseEvent = event.toLowerCase();
      if (lowerCaseEvent !== event && vm._events[lowerCaseEvent]) {
        tip(
          "Event \"" + lowerCaseEvent + "\" is emitted in component " +
          (formatComponentName(vm)) + " but the handler is registered for \"" + event + "\". " +
          "Note that HTML attributes are case-insensitive and you cannot use " +
          "v-on to listen to camelCase events when using in-DOM templates. " +
          "You should probably use \"" + (hyphenate(event)) + "\" instead of \"" + event + "\"."
        );
      }
    }
    var cbs = vm._events[event];
    if (cbs) {
      cbs = cbs.length > 1 ? toArray(cbs) : cbs;
      var args = toArray(arguments, 1);
      var info = "event handler for \"" + event + "\"";
      for (var i = 0, l = cbs.length; i < l; i++) {
        invokeWithErrorHandling(cbs[i], vm, args, vm, info);
      }
    }
    return vm
  };
}

/*  */

var activeInstance = null;
var isUpdatingChildComponent = false;

function setActiveInstance(vm) {
  var prevActiveInstance = activeInstance;
  activeInstance = vm;
  return function () {
    activeInstance = prevActiveInstance;
  }
}

function initLifecycle (vm) {
  var options = vm.$options;

  // locate first non-abstract parent
  var parent = options.parent;
  if (parent && !options.abstract) {
    while (parent.$options.abstract && parent.$parent) {
      parent = parent.$parent;
    }
    parent.$children.push(vm);
  }

  vm.$parent = parent;
  vm.$root = parent ? parent.$root : vm;

  vm.$children = [];
  vm.$refs = {};

  vm._watcher = null;
  vm._inactive = null;
  vm._directInactive = false;
  vm._isMounted = false;
  vm._isDestroyed = false;
  vm._isBeingDestroyed = false;
}

function lifecycleMixin (Vue) {
  Vue.prototype._update = function (vnode, hydrating) {
    var vm = this;
    var prevEl = vm.$el;
    var prevVnode = vm._vnode;
    var restoreActiveInstance = setActiveInstance(vm);
    vm._vnode = vnode;
    // Vue.prototype.__patch__ is injected in entry points
    // based on the rendering backend used.
    if (!prevVnode) {
      // initial render
      vm.$el = vm.__patch__(vm.$el, vnode, hydrating, false /* removeOnly */);
    } else {
      // updates
      vm.$el = vm.__patch__(prevVnode, vnode);
    }
    restoreActiveInstance();
    // update __vue__ reference
    if (prevEl) {
      prevEl.__vue__ = null;
    }
    if (vm.$el) {
      vm.$el.__vue__ = vm;
    }
    // if parent is an HOC, update its $el as well
    if (vm.$vnode && vm.$parent && vm.$vnode === vm.$parent._vnode) {
      vm.$parent.$el = vm.$el;
    }
    // updated hook is called by the scheduler to ensure that children are
    // updated in a parent's updated hook.
  };

  Vue.prototype.$forceUpdate = function () {
    var vm = this;
    if (vm._watcher) {
      vm._watcher.update();
    }
  };

  Vue.prototype.$destroy = function () {
    var vm = this;
    if (vm._isBeingDestroyed) {
      return
    }
    callHook(vm, 'beforeDestroy');
    vm._isBeingDestroyed = true;
    // remove self from parent
    var parent = vm.$parent;
    if (parent && !parent._isBeingDestroyed && !vm.$options.abstract) {
      remove(parent.$children, vm);
    }
    // teardown watchers
    if (vm._watcher) {
      vm._watcher.teardown();
    }
    var i = vm._watchers.length;
    while (i--) {
      vm._watchers[i].teardown();
    }
    // remove reference from data ob
    // frozen object may not have observer.
    if (vm._data.__ob__) {
      vm._data.__ob__.vmCount--;
    }
    // call the last hook...
    vm._isDestroyed = true;
    // invoke destroy hooks on current rendered tree
    vm.__patch__(vm._vnode, null);
    // fire destroyed hook
    callHook(vm, 'destroyed');
    // turn off all instance listeners.
    vm.$off();
    // remove __vue__ reference
    if (vm.$el) {
      vm.$el.__vue__ = null;
    }
    // release circular reference (#6759)
    if (vm.$vnode) {
      vm.$vnode.parent = null;
    }
  };
}

function mountComponent (
  vm,
  el,
  hydrating
) {
  vm.$el = el;
  if (!vm.$options.render) {
    vm.$options.render = createEmptyVNode;
    if (true) {
      /* istanbul ignore if */
      if ((vm.$options.template && vm.$options.template.charAt(0) !== '#') ||
        vm.$options.el || el) {
        warn(
          'You are using the runtime-only build of Vue where the template ' +
          'compiler is not available. Either pre-compile the templates into ' +
          'render functions, or use the compiler-included build.',
          vm
        );
      } else {
        warn(
          'Failed to mount component: template or render function not defined.',
          vm
        );
      }
    }
  }
  callHook(vm, 'beforeMount');

  var updateComponent;
  /* istanbul ignore if */
  if ( true && config.performance && mark) {
    updateComponent = function () {
      var name = vm._name;
      var id = vm._uid;
      var startTag = "vue-perf-start:" + id;
      var endTag = "vue-perf-end:" + id;

      mark(startTag);
      var vnode = vm._render();
      mark(endTag);
      measure(("vue " + name + " render"), startTag, endTag);

      mark(startTag);
      vm._update(vnode, hydrating);
      mark(endTag);
      measure(("vue " + name + " patch"), startTag, endTag);
    };
  } else {
    updateComponent = function () {
      vm._update(vm._render(), hydrating);
    };
  }

  // we set this to vm._watcher inside the watcher's constructor
  // since the watcher's initial patch may call $forceUpdate (e.g. inside child
  // component's mounted hook), which relies on vm._watcher being already defined
  new Watcher(vm, updateComponent, noop, {
    before: function before () {
      if (vm._isMounted && !vm._isDestroyed) {
        callHook(vm, 'beforeUpdate');
      }
    }
  }, true /* isRenderWatcher */);
  hydrating = false;

  // manually mounted instance, call mounted on self
  // mounted is called for render-created child components in its inserted hook
  if (vm.$vnode == null) {
    vm._isMounted = true;
    callHook(vm, 'mounted');
  }
  return vm
}

function updateChildComponent (
  vm,
  propsData,
  listeners,
  parentVnode,
  renderChildren
) {
  if (true) {
    isUpdatingChildComponent = true;
  }

  // determine whether component has slot children
  // we need to do this before overwriting $options._renderChildren.

  // check if there are dynamic scopedSlots (hand-written or compiled but with
  // dynamic slot names). Static scoped slots compiled from template has the
  // "$stable" marker.
  var newScopedSlots = parentVnode.data.scopedSlots;
  var oldScopedSlots = vm.$scopedSlots;
  var hasDynamicScopedSlot = !!(
    (newScopedSlots && !newScopedSlots.$stable) ||
    (oldScopedSlots !== emptyObject && !oldScopedSlots.$stable) ||
    (newScopedSlots && vm.$scopedSlots.$key !== newScopedSlots.$key) ||
    (!newScopedSlots && vm.$scopedSlots.$key)
  );

  // Any static slot children from the parent may have changed during parent's
  // update. Dynamic scoped slots may also have changed. In such cases, a forced
  // update is necessary to ensure correctness.
  var needsForceUpdate = !!(
    renderChildren ||               // has new static slots
    vm.$options._renderChildren ||  // has old static slots
    hasDynamicScopedSlot
  );

  vm.$options._parentVnode = parentVnode;
  vm.$vnode = parentVnode; // update vm's placeholder node without re-render

  if (vm._vnode) { // update child tree's parent
    vm._vnode.parent = parentVnode;
  }
  vm.$options._renderChildren = renderChildren;

  // update $attrs and $listeners hash
  // these are also reactive so they may trigger child update if the child
  // used them during render
  vm.$attrs = parentVnode.data.attrs || emptyObject;
  vm.$listeners = listeners || emptyObject;

  // update props
  if (propsData && vm.$options.props) {
    toggleObserving(false);
    var props = vm._props;
    var propKeys = vm.$options._propKeys || [];
    for (var i = 0; i < propKeys.length; i++) {
      var key = propKeys[i];
      var propOptions = vm.$options.props; // wtf flow?
      props[key] = validateProp(key, propOptions, propsData, vm);
    }
    toggleObserving(true);
    // keep a copy of raw propsData
    vm.$options.propsData = propsData;
  }

  // update listeners
  listeners = listeners || emptyObject;
  var oldListeners = vm.$options._parentListeners;
  vm.$options._parentListeners = listeners;
  updateComponentListeners(vm, listeners, oldListeners);

  // resolve slots + force update if has children
  if (needsForceUpdate) {
    vm.$slots = resolveSlots(renderChildren, parentVnode.context);
    vm.$forceUpdate();
  }

  if (true) {
    isUpdatingChildComponent = false;
  }
}

function isInInactiveTree (vm) {
  while (vm && (vm = vm.$parent)) {
    if (vm._inactive) { return true }
  }
  return false
}

function activateChildComponent (vm, direct) {
  if (direct) {
    vm._directInactive = false;
    if (isInInactiveTree(vm)) {
      return
    }
  } else if (vm._directInactive) {
    return
  }
  if (vm._inactive || vm._inactive === null) {
    vm._inactive = false;
    for (var i = 0; i < vm.$children.length; i++) {
      activateChildComponent(vm.$children[i]);
    }
    callHook(vm, 'activated');
  }
}

function deactivateChildComponent (vm, direct) {
  if (direct) {
    vm._directInactive = true;
    if (isInInactiveTree(vm)) {
      return
    }
  }
  if (!vm._inactive) {
    vm._inactive = true;
    for (var i = 0; i < vm.$children.length; i++) {
      deactivateChildComponent(vm.$children[i]);
    }
    callHook(vm, 'deactivated');
  }
}

function callHook (vm, hook) {
  // #7573 disable dep collection when invoking lifecycle hooks
  pushTarget();
  var handlers = vm.$options[hook];
  var info = hook + " hook";
  if (handlers) {
    for (var i = 0, j = handlers.length; i < j; i++) {
      invokeWithErrorHandling(handlers[i], vm, null, vm, info);
    }
  }
  if (vm._hasHookEvent) {
    vm.$emit('hook:' + hook);
  }
  popTarget();
}

/*  */

var MAX_UPDATE_COUNT = 100;

var queue = [];
var activatedChildren = [];
var has = {};
var circular = {};
var waiting = false;
var flushing = false;
var index = 0;

/**
 * Reset the scheduler's state.
 */
function resetSchedulerState () {
  index = queue.length = activatedChildren.length = 0;
  has = {};
  if (true) {
    circular = {};
  }
  waiting = flushing = false;
}

// Async edge case #6566 requires saving the timestamp when event listeners are
// attached. However, calling performance.now() has a perf overhead especially
// if the page has thousands of event listeners. Instead, we take a timestamp
// every time the scheduler flushes and use that for all event listeners
// attached during that flush.
var currentFlushTimestamp = 0;

// Async edge case fix requires storing an event listener's attach timestamp.
var getNow = Date.now;

// Determine what event timestamp the browser is using. Annoyingly, the
// timestamp can either be hi-res (relative to page load) or low-res
// (relative to UNIX epoch), so in order to compare time we have to use the
// same timestamp type when saving the flush timestamp.
// All IE versions use low-res event timestamps, and have problematic clock
// implementations (#9632)
if (inBrowser && !isIE) {
  var performance = window.performance;
  if (
    performance &&
    typeof performance.now === 'function' &&
    getNow() > document.createEvent('Event').timeStamp
  ) {
    // if the event timestamp, although evaluated AFTER the Date.now(), is
    // smaller than it, it means the event is using a hi-res timestamp,
    // and we need to use the hi-res version for event listener timestamps as
    // well.
    getNow = function () { return performance.now(); };
  }
}

/**
 * Flush both queues and run the watchers.
 */
function flushSchedulerQueue () {
  currentFlushTimestamp = getNow();
  flushing = true;
  var watcher, id;

  // Sort queue before flush.
  // This ensures that:
  // 1. Components are updated from parent to child. (because parent is always
  //    created before the child)
  // 2. A component's user watchers are run before its render watcher (because
  //    user watchers are created before the render watcher)
  // 3. If a component is destroyed during a parent component's watcher run,
  //    its watchers can be skipped.
  queue.sort(function (a, b) { return a.id - b.id; });

  // do not cache length because more watchers might be pushed
  // as we run existing watchers
  for (index = 0; index < queue.length; index++) {
    watcher = queue[index];
    if (watcher.before) {
      watcher.before();
    }
    id = watcher.id;
    has[id] = null;
    watcher.run();
    // in dev build, check and stop circular updates.
    if ( true && has[id] != null) {
      circular[id] = (circular[id] || 0) + 1;
      if (circular[id] > MAX_UPDATE_COUNT) {
        warn(
          'You may have an infinite update loop ' + (
            watcher.user
              ? ("in watcher with expression \"" + (watcher.expression) + "\"")
              : "in a component render function."
          ),
          watcher.vm
        );
        break
      }
    }
  }

  // keep copies of post queues before resetting state
  var activatedQueue = activatedChildren.slice();
  var updatedQueue = queue.slice();

  resetSchedulerState();

  // call component updated and activated hooks
  callActivatedHooks(activatedQueue);
  callUpdatedHooks(updatedQueue);

  // devtool hook
  /* istanbul ignore if */
  if (devtools && config.devtools) {
    devtools.emit('flush');
  }
}

function callUpdatedHooks (queue) {
  var i = queue.length;
  while (i--) {
    var watcher = queue[i];
    var vm = watcher.vm;
    if (vm._watcher === watcher && vm._isMounted && !vm._isDestroyed) {
      callHook(vm, 'updated');
    }
  }
}

/**
 * Queue a kept-alive component that was activated during patch.
 * The queue will be processed after the entire tree has been patched.
 */
function queueActivatedComponent (vm) {
  // setting _inactive to false here so that a render function can
  // rely on checking whether it's in an inactive tree (e.g. router-view)
  vm._inactive = false;
  activatedChildren.push(vm);
}

function callActivatedHooks (queue) {
  for (var i = 0; i < queue.length; i++) {
    queue[i]._inactive = true;
    activateChildComponent(queue[i], true /* true */);
  }
}

/**
 * Push a watcher into the watcher queue.
 * Jobs with duplicate IDs will be skipped unless it's
 * pushed when the queue is being flushed.
 */
function queueWatcher (watcher) {
  var id = watcher.id;
  if (has[id] == null) {
    has[id] = true;
    if (!flushing) {
      queue.push(watcher);
    } else {
      // if already flushing, splice the watcher based on its id
      // if already past its id, it will be run next immediately.
      var i = queue.length - 1;
      while (i > index && queue[i].id > watcher.id) {
        i--;
      }
      queue.splice(i + 1, 0, watcher);
    }
    // queue the flush
    if (!waiting) {
      waiting = true;

      if ( true && !config.async) {
        flushSchedulerQueue();
        return
      }
      nextTick(flushSchedulerQueue);
    }
  }
}

/*  */



var uid$2 = 0;

/**
 * A watcher parses an expression, collects dependencies,
 * and fires callback when the expression value changes.
 * This is used for both the $watch() api and directives.
 */
var Watcher = function Watcher (
  vm,
  expOrFn,
  cb,
  options,
  isRenderWatcher
) {
  this.vm = vm;
  if (isRenderWatcher) {
    vm._watcher = this;
  }
  vm._watchers.push(this);
  // options
  if (options) {
    this.deep = !!options.deep;
    this.user = !!options.user;
    this.lazy = !!options.lazy;
    this.sync = !!options.sync;
    this.before = options.before;
  } else {
    this.deep = this.user = this.lazy = this.sync = false;
  }
  this.cb = cb;
  this.id = ++uid$2; // uid for batching
  this.active = true;
  this.dirty = this.lazy; // for lazy watchers
  this.deps = [];
  this.newDeps = [];
  this.depIds = new _Set();
  this.newDepIds = new _Set();
  this.expression =  true
    ? expOrFn.toString()
    : 0;
  // parse expression for getter
  if (typeof expOrFn === 'function') {
    this.getter = expOrFn;
  } else {
    this.getter = parsePath(expOrFn);
    if (!this.getter) {
      this.getter = noop;
       true && warn(
        "Failed watching path: \"" + expOrFn + "\" " +
        'Watcher only accepts simple dot-delimited paths. ' +
        'For full control, use a function instead.',
        vm
      );
    }
  }
  this.value = this.lazy
    ? undefined
    : this.get();
};

/**
 * Evaluate the getter, and re-collect dependencies.
 */
Watcher.prototype.get = function get () {
  pushTarget(this);
  var value;
  var vm = this.vm;
  try {
    value = this.getter.call(vm, vm);
  } catch (e) {
    if (this.user) {
      handleError(e, vm, ("getter for watcher \"" + (this.expression) + "\""));
    } else {
      throw e
    }
  } finally {
    // "touch" every property so they are all tracked as
    // dependencies for deep watching
    if (this.deep) {
      traverse(value);
    }
    popTarget();
    this.cleanupDeps();
  }
  return value
};

/**
 * Add a dependency to this directive.
 */
Watcher.prototype.addDep = function addDep (dep) {
  var id = dep.id;
  if (!this.newDepIds.has(id)) {
    this.newDepIds.add(id);
    this.newDeps.push(dep);
    if (!this.depIds.has(id)) {
      dep.addSub(this);
    }
  }
};

/**
 * Clean up for dependency collection.
 */
Watcher.prototype.cleanupDeps = function cleanupDeps () {
  var i = this.deps.length;
  while (i--) {
    var dep = this.deps[i];
    if (!this.newDepIds.has(dep.id)) {
      dep.removeSub(this);
    }
  }
  var tmp = this.depIds;
  this.depIds = this.newDepIds;
  this.newDepIds = tmp;
  this.newDepIds.clear();
  tmp = this.deps;
  this.deps = this.newDeps;
  this.newDeps = tmp;
  this.newDeps.length = 0;
};

/**
 * Subscriber interface.
 * Will be called when a dependency changes.
 */
Watcher.prototype.update = function update () {
  /* istanbul ignore else */
  if (this.lazy) {
    this.dirty = true;
  } else if (this.sync) {
    this.run();
  } else {
    queueWatcher(this);
  }
};

/**
 * Scheduler job interface.
 * Will be called by the scheduler.
 */
Watcher.prototype.run = function run () {
  if (this.active) {
    var value = this.get();
    if (
      value !== this.value ||
      // Deep watchers and watchers on Object/Arrays should fire even
      // when the value is the same, because the value may
      // have mutated.
      isObject(value) ||
      this.deep
    ) {
      // set new value
      var oldValue = this.value;
      this.value = value;
      if (this.user) {
        var info = "callback for watcher \"" + (this.expression) + "\"";
        invokeWithErrorHandling(this.cb, this.vm, [value, oldValue], this.vm, info);
      } else {
        this.cb.call(this.vm, value, oldValue);
      }
    }
  }
};

/**
 * Evaluate the value of the watcher.
 * This only gets called for lazy watchers.
 */
Watcher.prototype.evaluate = function evaluate () {
  this.value = this.get();
  this.dirty = false;
};

/**
 * Depend on all deps collected by this watcher.
 */
Watcher.prototype.depend = function depend () {
  var i = this.deps.length;
  while (i--) {
    this.deps[i].depend();
  }
};

/**
 * Remove self from all dependencies' subscriber list.
 */
Watcher.prototype.teardown = function teardown () {
  if (this.active) {
    // remove self from vm's watcher list
    // this is a somewhat expensive operation so we skip it
    // if the vm is being destroyed.
    if (!this.vm._isBeingDestroyed) {
      remove(this.vm._watchers, this);
    }
    var i = this.deps.length;
    while (i--) {
      this.deps[i].removeSub(this);
    }
    this.active = false;
  }
};

/*  */

var sharedPropertyDefinition = {
  enumerable: true,
  configurable: true,
  get: noop,
  set: noop
};

function proxy (target, sourceKey, key) {
  sharedPropertyDefinition.get = function proxyGetter () {
    return this[sourceKey][key]
  };
  sharedPropertyDefinition.set = function proxySetter (val) {
    this[sourceKey][key] = val;
  };
  Object.defineProperty(target, key, sharedPropertyDefinition);
}

function initState (vm) {
  vm._watchers = [];
  var opts = vm.$options;
  if (opts.props) { initProps(vm, opts.props); }
  if (opts.methods) { initMethods(vm, opts.methods); }
  if (opts.data) {
    initData(vm);
  } else {
    observe(vm._data = {}, true /* asRootData */);
  }
  if (opts.computed) { initComputed(vm, opts.computed); }
  if (opts.watch && opts.watch !== nativeWatch) {
    initWatch(vm, opts.watch);
  }
}

function initProps (vm, propsOptions) {
  var propsData = vm.$options.propsData || {};
  var props = vm._props = {};
  // cache prop keys so that future props updates can iterate using Array
  // instead of dynamic object key enumeration.
  var keys = vm.$options._propKeys = [];
  var isRoot = !vm.$parent;
  // root instance props should be converted
  if (!isRoot) {
    toggleObserving(false);
  }
  var loop = function ( key ) {
    keys.push(key);
    var value = validateProp(key, propsOptions, propsData, vm);
    /* istanbul ignore else */
    if (true) {
      var hyphenatedKey = hyphenate(key);
      if (isReservedAttribute(hyphenatedKey) ||
          config.isReservedAttr(hyphenatedKey)) {
        warn(
          ("\"" + hyphenatedKey + "\" is a reserved attribute and cannot be used as component prop."),
          vm
        );
      }
      defineReactive$$1(props, key, value, function () {
        if (!isRoot && !isUpdatingChildComponent) {
          warn(
            "Avoid mutating a prop directly since the value will be " +
            "overwritten whenever the parent component re-renders. " +
            "Instead, use a data or computed property based on the prop's " +
            "value. Prop being mutated: \"" + key + "\"",
            vm
          );
        }
      });
    } else {}
    // static props are already proxied on the component's prototype
    // during Vue.extend(). We only need to proxy props defined at
    // instantiation here.
    if (!(key in vm)) {
      proxy(vm, "_props", key);
    }
  };

  for (var key in propsOptions) loop( key );
  toggleObserving(true);
}

function initData (vm) {
  var data = vm.$options.data;
  data = vm._data = typeof data === 'function'
    ? getData(data, vm)
    : data || {};
  if (!isPlainObject(data)) {
    data = {};
     true && warn(
      'data functions should return an object:\n' +
      'https://vuejs.org/v2/guide/components.html#data-Must-Be-a-Function',
      vm
    );
  }
  // proxy data on instance
  var keys = Object.keys(data);
  var props = vm.$options.props;
  var methods = vm.$options.methods;
  var i = keys.length;
  while (i--) {
    var key = keys[i];
    if (true) {
      if (methods && hasOwn(methods, key)) {
        warn(
          ("Method \"" + key + "\" has already been defined as a data property."),
          vm
        );
      }
    }
    if (props && hasOwn(props, key)) {
       true && warn(
        "The data property \"" + key + "\" is already declared as a prop. " +
        "Use prop default value instead.",
        vm
      );
    } else if (!isReserved(key)) {
      proxy(vm, "_data", key);
    }
  }
  // observe data
  observe(data, true /* asRootData */);
}

function getData (data, vm) {
  // #7573 disable dep collection when invoking data getters
  pushTarget();
  try {
    return data.call(vm, vm)
  } catch (e) {
    handleError(e, vm, "data()");
    return {}
  } finally {
    popTarget();
  }
}

var computedWatcherOptions = { lazy: true };

function initComputed (vm, computed) {
  // $flow-disable-line
  var watchers = vm._computedWatchers = Object.create(null);
  // computed properties are just getters during SSR
  var isSSR = isServerRendering();

  for (var key in computed) {
    var userDef = computed[key];
    var getter = typeof userDef === 'function' ? userDef : userDef.get;
    if ( true && getter == null) {
      warn(
        ("Getter is missing for computed property \"" + key + "\"."),
        vm
      );
    }

    if (!isSSR) {
      // create internal watcher for the computed property.
      watchers[key] = new Watcher(
        vm,
        getter || noop,
        noop,
        computedWatcherOptions
      );
    }

    // component-defined computed properties are already defined on the
    // component prototype. We only need to define computed properties defined
    // at instantiation here.
    if (!(key in vm)) {
      defineComputed(vm, key, userDef);
    } else if (true) {
      if (key in vm.$data) {
        warn(("The computed property \"" + key + "\" is already defined in data."), vm);
      } else if (vm.$options.props && key in vm.$options.props) {
        warn(("The computed property \"" + key + "\" is already defined as a prop."), vm);
      } else if (vm.$options.methods && key in vm.$options.methods) {
        warn(("The computed property \"" + key + "\" is already defined as a method."), vm);
      }
    }
  }
}

function defineComputed (
  target,
  key,
  userDef
) {
  var shouldCache = !isServerRendering();
  if (typeof userDef === 'function') {
    sharedPropertyDefinition.get = shouldCache
      ? createComputedGetter(key)
      : createGetterInvoker(userDef);
    sharedPropertyDefinition.set = noop;
  } else {
    sharedPropertyDefinition.get = userDef.get
      ? shouldCache && userDef.cache !== false
        ? createComputedGetter(key)
        : createGetterInvoker(userDef.get)
      : noop;
    sharedPropertyDefinition.set = userDef.set || noop;
  }
  if ( true &&
      sharedPropertyDefinition.set === noop) {
    sharedPropertyDefinition.set = function () {
      warn(
        ("Computed property \"" + key + "\" was assigned to but it has no setter."),
        this
      );
    };
  }
  Object.defineProperty(target, key, sharedPropertyDefinition);
}

function createComputedGetter (key) {
  return function computedGetter () {
    var watcher = this._computedWatchers && this._computedWatchers[key];
    if (watcher) {
      if (watcher.dirty) {
        watcher.evaluate();
      }
      if (Dep.target) {
        watcher.depend();
      }
      return watcher.value
    }
  }
}

function createGetterInvoker(fn) {
  return function computedGetter () {
    return fn.call(this, this)
  }
}

function initMethods (vm, methods) {
  var props = vm.$options.props;
  for (var key in methods) {
    if (true) {
      if (typeof methods[key] !== 'function') {
        warn(
          "Method \"" + key + "\" has type \"" + (typeof methods[key]) + "\" in the component definition. " +
          "Did you reference the function correctly?",
          vm
        );
      }
      if (props && hasOwn(props, key)) {
        warn(
          ("Method \"" + key + "\" has already been defined as a prop."),
          vm
        );
      }
      if ((key in vm) && isReserved(key)) {
        warn(
          "Method \"" + key + "\" conflicts with an existing Vue instance method. " +
          "Avoid defining component methods that start with _ or $."
        );
      }
    }
    vm[key] = typeof methods[key] !== 'function' ? noop : bind(methods[key], vm);
  }
}

function initWatch (vm, watch) {
  for (var key in watch) {
    var handler = watch[key];
    if (Array.isArray(handler)) {
      for (var i = 0; i < handler.length; i++) {
        createWatcher(vm, key, handler[i]);
      }
    } else {
      createWatcher(vm, key, handler);
    }
  }
}

function createWatcher (
  vm,
  expOrFn,
  handler,
  options
) {
  if (isPlainObject(handler)) {
    options = handler;
    handler = handler.handler;
  }
  if (typeof handler === 'string') {
    handler = vm[handler];
  }
  return vm.$watch(expOrFn, handler, options)
}

function stateMixin (Vue) {
  // flow somehow has problems with directly declared definition object
  // when using Object.defineProperty, so we have to procedurally build up
  // the object here.
  var dataDef = {};
  dataDef.get = function () { return this._data };
  var propsDef = {};
  propsDef.get = function () { return this._props };
  if (true) {
    dataDef.set = function () {
      warn(
        'Avoid replacing instance root $data. ' +
        'Use nested data properties instead.',
        this
      );
    };
    propsDef.set = function () {
      warn("$props is readonly.", this);
    };
  }
  Object.defineProperty(Vue.prototype, '$data', dataDef);
  Object.defineProperty(Vue.prototype, '$props', propsDef);

  Vue.prototype.$set = set;
  Vue.prototype.$delete = del;

  Vue.prototype.$watch = function (
    expOrFn,
    cb,
    options
  ) {
    var vm = this;
    if (isPlainObject(cb)) {
      return createWatcher(vm, expOrFn, cb, options)
    }
    options = options || {};
    options.user = true;
    var watcher = new Watcher(vm, expOrFn, cb, options);
    if (options.immediate) {
      var info = "callback for immediate watcher \"" + (watcher.expression) + "\"";
      pushTarget();
      invokeWithErrorHandling(cb, vm, [watcher.value], vm, info);
      popTarget();
    }
    return function unwatchFn () {
      watcher.teardown();
    }
  };
}

/*  */

var uid$3 = 0;

function initMixin (Vue) {
  Vue.prototype._init = function (options) {
    var vm = this;
    // a uid
    vm._uid = uid$3++;

    var startTag, endTag;
    /* istanbul ignore if */
    if ( true && config.performance && mark) {
      startTag = "vue-perf-start:" + (vm._uid);
      endTag = "vue-perf-end:" + (vm._uid);
      mark(startTag);
    }

    // a flag to avoid this being observed
    vm._isVue = true;
    // merge options
    if (options && options._isComponent) {
      // optimize internal component instantiation
      // since dynamic options merging is pretty slow, and none of the
      // internal component options needs special treatment.
      initInternalComponent(vm, options);
    } else {
      vm.$options = mergeOptions(
        resolveConstructorOptions(vm.constructor),
        options || {},
        vm
      );
    }
    /* istanbul ignore else */
    if (true) {
      initProxy(vm);
    } else {}
    // expose real self
    vm._self = vm;
    initLifecycle(vm);
    initEvents(vm);
    initRender(vm);
    callHook(vm, 'beforeCreate');
    initInjections(vm); // resolve injections before data/props
    initState(vm);
    initProvide(vm); // resolve provide after data/props
    callHook(vm, 'created');

    /* istanbul ignore if */
    if ( true && config.performance && mark) {
      vm._name = formatComponentName(vm, false);
      mark(endTag);
      measure(("vue " + (vm._name) + " init"), startTag, endTag);
    }

    if (vm.$options.el) {
      vm.$mount(vm.$options.el);
    }
  };
}

function initInternalComponent (vm, options) {
  var opts = vm.$options = Object.create(vm.constructor.options);
  // doing this because it's faster than dynamic enumeration.
  var parentVnode = options._parentVnode;
  opts.parent = options.parent;
  opts._parentVnode = parentVnode;

  var vnodeComponentOptions = parentVnode.componentOptions;
  opts.propsData = vnodeComponentOptions.propsData;
  opts._parentListeners = vnodeComponentOptions.listeners;
  opts._renderChildren = vnodeComponentOptions.children;
  opts._componentTag = vnodeComponentOptions.tag;

  if (options.render) {
    opts.render = options.render;
    opts.staticRenderFns = options.staticRenderFns;
  }
}

function resolveConstructorOptions (Ctor) {
  var options = Ctor.options;
  if (Ctor.super) {
    var superOptions = resolveConstructorOptions(Ctor.super);
    var cachedSuperOptions = Ctor.superOptions;
    if (superOptions !== cachedSuperOptions) {
      // super option changed,
      // need to resolve new options.
      Ctor.superOptions = superOptions;
      // check if there are any late-modified/attached options (#4976)
      var modifiedOptions = resolveModifiedOptions(Ctor);
      // update base extend options
      if (modifiedOptions) {
        extend(Ctor.extendOptions, modifiedOptions);
      }
      options = Ctor.options = mergeOptions(superOptions, Ctor.extendOptions);
      if (options.name) {
        options.components[options.name] = Ctor;
      }
    }
  }
  return options
}

function resolveModifiedOptions (Ctor) {
  var modified;
  var latest = Ctor.options;
  var sealed = Ctor.sealedOptions;
  for (var key in latest) {
    if (latest[key] !== sealed[key]) {
      if (!modified) { modified = {}; }
      modified[key] = latest[key];
    }
  }
  return modified
}

function Vue (options) {
  if ( true &&
    !(this instanceof Vue)
  ) {
    warn('Vue is a constructor and should be called with the `new` keyword');
  }
  this._init(options);
}

initMixin(Vue);
stateMixin(Vue);
eventsMixin(Vue);
lifecycleMixin(Vue);
renderMixin(Vue);

/*  */

function initUse (Vue) {
  Vue.use = function (plugin) {
    var installedPlugins = (this._installedPlugins || (this._installedPlugins = []));
    if (installedPlugins.indexOf(plugin) > -1) {
      return this
    }

    // additional parameters
    var args = toArray(arguments, 1);
    args.unshift(this);
    if (typeof plugin.install === 'function') {
      plugin.install.apply(plugin, args);
    } else if (typeof plugin === 'function') {
      plugin.apply(null, args);
    }
    installedPlugins.push(plugin);
    return this
  };
}

/*  */

function initMixin$1 (Vue) {
  Vue.mixin = function (mixin) {
    this.options = mergeOptions(this.options, mixin);
    return this
  };
}

/*  */

function initExtend (Vue) {
  /**
   * Each instance constructor, including Vue, has a unique
   * cid. This enables us to create wrapped "child
   * constructors" for prototypal inheritance and cache them.
   */
  Vue.cid = 0;
  var cid = 1;

  /**
   * Class inheritance
   */
  Vue.extend = function (extendOptions) {
    extendOptions = extendOptions || {};
    var Super = this;
    var SuperId = Super.cid;
    var cachedCtors = extendOptions._Ctor || (extendOptions._Ctor = {});
    if (cachedCtors[SuperId]) {
      return cachedCtors[SuperId]
    }

    var name = extendOptions.name || Super.options.name;
    if ( true && name) {
      validateComponentName(name);
    }

    var Sub = function VueComponent (options) {
      this._init(options);
    };
    Sub.prototype = Object.create(Super.prototype);
    Sub.prototype.constructor = Sub;
    Sub.cid = cid++;
    Sub.options = mergeOptions(
      Super.options,
      extendOptions
    );
    Sub['super'] = Super;

    // For props and computed properties, we define the proxy getters on
    // the Vue instances at extension time, on the extended prototype. This
    // avoids Object.defineProperty calls for each instance created.
    if (Sub.options.props) {
      initProps$1(Sub);
    }
    if (Sub.options.computed) {
      initComputed$1(Sub);
    }

    // allow further extension/mixin/plugin usage
    Sub.extend = Super.extend;
    Sub.mixin = Super.mixin;
    Sub.use = Super.use;

    // create asset registers, so extended classes
    // can have their private assets too.
    ASSET_TYPES.forEach(function (type) {
      Sub[type] = Super[type];
    });
    // enable recursive self-lookup
    if (name) {
      Sub.options.components[name] = Sub;
    }

    // keep a reference to the super options at extension time.
    // later at instantiation we can check if Super's options have
    // been updated.
    Sub.superOptions = Super.options;
    Sub.extendOptions = extendOptions;
    Sub.sealedOptions = extend({}, Sub.options);

    // cache constructor
    cachedCtors[SuperId] = Sub;
    return Sub
  };
}

function initProps$1 (Comp) {
  var props = Comp.options.props;
  for (var key in props) {
    proxy(Comp.prototype, "_props", key);
  }
}

function initComputed$1 (Comp) {
  var computed = Comp.options.computed;
  for (var key in computed) {
    defineComputed(Comp.prototype, key, computed[key]);
  }
}

/*  */

function initAssetRegisters (Vue) {
  /**
   * Create asset registration methods.
   */
  ASSET_TYPES.forEach(function (type) {
    Vue[type] = function (
      id,
      definition
    ) {
      if (!definition) {
        return this.options[type + 's'][id]
      } else {
        /* istanbul ignore if */
        if ( true && type === 'component') {
          validateComponentName(id);
        }
        if (type === 'component' && isPlainObject(definition)) {
          definition.name = definition.name || id;
          definition = this.options._base.extend(definition);
        }
        if (type === 'directive' && typeof definition === 'function') {
          definition = { bind: definition, update: definition };
        }
        this.options[type + 's'][id] = definition;
        return definition
      }
    };
  });
}

/*  */





function getComponentName (opts) {
  return opts && (opts.Ctor.options.name || opts.tag)
}

function matches (pattern, name) {
  if (Array.isArray(pattern)) {
    return pattern.indexOf(name) > -1
  } else if (typeof pattern === 'string') {
    return pattern.split(',').indexOf(name) > -1
  } else if (isRegExp(pattern)) {
    return pattern.test(name)
  }
  /* istanbul ignore next */
  return false
}

function pruneCache (keepAliveInstance, filter) {
  var cache = keepAliveInstance.cache;
  var keys = keepAliveInstance.keys;
  var _vnode = keepAliveInstance._vnode;
  for (var key in cache) {
    var entry = cache[key];
    if (entry) {
      var name = entry.name;
      if (name && !filter(name)) {
        pruneCacheEntry(cache, key, keys, _vnode);
      }
    }
  }
}

function pruneCacheEntry (
  cache,
  key,
  keys,
  current
) {
  var entry = cache[key];
  if (entry && (!current || entry.tag !== current.tag)) {
    entry.componentInstance.$destroy();
  }
  cache[key] = null;
  remove(keys, key);
}

var patternTypes = [String, RegExp, Array];

var KeepAlive = {
  name: 'keep-alive',
  abstract: true,

  props: {
    include: patternTypes,
    exclude: patternTypes,
    max: [String, Number]
  },

  methods: {
    cacheVNode: function cacheVNode() {
      var ref = this;
      var cache = ref.cache;
      var keys = ref.keys;
      var vnodeToCache = ref.vnodeToCache;
      var keyToCache = ref.keyToCache;
      if (vnodeToCache) {
        var tag = vnodeToCache.tag;
        var componentInstance = vnodeToCache.componentInstance;
        var componentOptions = vnodeToCache.componentOptions;
        cache[keyToCache] = {
          name: getComponentName(componentOptions),
          tag: tag,
          componentInstance: componentInstance,
        };
        keys.push(keyToCache);
        // prune oldest entry
        if (this.max && keys.length > parseInt(this.max)) {
          pruneCacheEntry(cache, keys[0], keys, this._vnode);
        }
        this.vnodeToCache = null;
      }
    }
  },

  created: function created () {
    this.cache = Object.create(null);
    this.keys = [];
  },

  destroyed: function destroyed () {
    for (var key in this.cache) {
      pruneCacheEntry(this.cache, key, this.keys);
    }
  },

  mounted: function mounted () {
    var this$1 = this;

    this.cacheVNode();
    this.$watch('include', function (val) {
      pruneCache(this$1, function (name) { return matches(val, name); });
    });
    this.$watch('exclude', function (val) {
      pruneCache(this$1, function (name) { return !matches(val, name); });
    });
  },

  updated: function updated () {
    this.cacheVNode();
  },

  render: function render () {
    var slot = this.$slots.default;
    var vnode = getFirstComponentChild(slot);
    var componentOptions = vnode && vnode.componentOptions;
    if (componentOptions) {
      // check pattern
      var name = getComponentName(componentOptions);
      var ref = this;
      var include = ref.include;
      var exclude = ref.exclude;
      if (
        // not included
        (include && (!name || !matches(include, name))) ||
        // excluded
        (exclude && name && matches(exclude, name))
      ) {
        return vnode
      }

      var ref$1 = this;
      var cache = ref$1.cache;
      var keys = ref$1.keys;
      var key = vnode.key == null
        // same constructor may get registered as different local components
        // so cid alone is not enough (#3269)
        ? componentOptions.Ctor.cid + (componentOptions.tag ? ("::" + (componentOptions.tag)) : '')
        : vnode.key;
      if (cache[key]) {
        vnode.componentInstance = cache[key].componentInstance;
        // make current key freshest
        remove(keys, key);
        keys.push(key);
      } else {
        // delay setting the cache until update
        this.vnodeToCache = vnode;
        this.keyToCache = key;
      }

      vnode.data.keepAlive = true;
    }
    return vnode || (slot && slot[0])
  }
};

var builtInComponents = {
  KeepAlive: KeepAlive
};

/*  */

function initGlobalAPI (Vue) {
  // config
  var configDef = {};
  configDef.get = function () { return config; };
  if (true) {
    configDef.set = function () {
      warn(
        'Do not replace the Vue.config object, set individual fields instead.'
      );
    };
  }
  Object.defineProperty(Vue, 'config', configDef);

  // exposed util methods.
  // NOTE: these are not considered part of the public API - avoid relying on
  // them unless you are aware of the risk.
  Vue.util = {
    warn: warn,
    extend: extend,
    mergeOptions: mergeOptions,
    defineReactive: defineReactive$$1
  };

  Vue.set = set;
  Vue.delete = del;
  Vue.nextTick = nextTick;

  // 2.6 explicit observable API
  Vue.observable = function (obj) {
    observe(obj);
    return obj
  };

  Vue.options = Object.create(null);
  ASSET_TYPES.forEach(function (type) {
    Vue.options[type + 's'] = Object.create(null);
  });

  // this is used to identify the "base" constructor to extend all plain-object
  // components with in Weex's multi-instance scenarios.
  Vue.options._base = Vue;

  extend(Vue.options.components, builtInComponents);

  initUse(Vue);
  initMixin$1(Vue);
  initExtend(Vue);
  initAssetRegisters(Vue);
}

initGlobalAPI(Vue);

Object.defineProperty(Vue.prototype, '$isServer', {
  get: isServerRendering
});

Object.defineProperty(Vue.prototype, '$ssrContext', {
  get: function get () {
    /* istanbul ignore next */
    return this.$vnode && this.$vnode.ssrContext
  }
});

// expose FunctionalRenderContext for ssr runtime helper installation
Object.defineProperty(Vue, 'FunctionalRenderContext', {
  value: FunctionalRenderContext
});

Vue.version = '2.6.14';

/*  */

// these are reserved for web because they are directly compiled away
// during template compilation
var isReservedAttr = makeMap('style,class');

// attributes that should be using props for binding
var acceptValue = makeMap('input,textarea,option,select,progress');
var mustUseProp = function (tag, type, attr) {
  return (
    (attr === 'value' && acceptValue(tag)) && type !== 'button' ||
    (attr === 'selected' && tag === 'option') ||
    (attr === 'checked' && tag === 'input') ||
    (attr === 'muted' && tag === 'video')
  )
};

var isEnumeratedAttr = makeMap('contenteditable,draggable,spellcheck');

var isValidContentEditableValue = makeMap('events,caret,typing,plaintext-only');

var convertEnumeratedValue = function (key, value) {
  return isFalsyAttrValue(value) || value === 'false'
    ? 'false'
    // allow arbitrary string value for contenteditable
    : key === 'contenteditable' && isValidContentEditableValue(value)
      ? value
      : 'true'
};

var isBooleanAttr = makeMap(
  'allowfullscreen,async,autofocus,autoplay,checked,compact,controls,declare,' +
  'default,defaultchecked,defaultmuted,defaultselected,defer,disabled,' +
  'enabled,formnovalidate,hidden,indeterminate,inert,ismap,itemscope,loop,multiple,' +
  'muted,nohref,noresize,noshade,novalidate,nowrap,open,pauseonexit,readonly,' +
  'required,reversed,scoped,seamless,selected,sortable,' +
  'truespeed,typemustmatch,visible'
);

var xlinkNS = 'http://www.w3.org/1999/xlink';

var isXlink = function (name) {
  return name.charAt(5) === ':' && name.slice(0, 5) === 'xlink'
};

var getXlinkProp = function (name) {
  return isXlink(name) ? name.slice(6, name.length) : ''
};

var isFalsyAttrValue = function (val) {
  return val == null || val === false
};

/*  */

function genClassForVnode (vnode) {
  var data = vnode.data;
  var parentNode = vnode;
  var childNode = vnode;
  while (isDef(childNode.componentInstance)) {
    childNode = childNode.componentInstance._vnode;
    if (childNode && childNode.data) {
      data = mergeClassData(childNode.data, data);
    }
  }
  while (isDef(parentNode = parentNode.parent)) {
    if (parentNode && parentNode.data) {
      data = mergeClassData(data, parentNode.data);
    }
  }
  return renderClass(data.staticClass, data.class)
}

function mergeClassData (child, parent) {
  return {
    staticClass: concat(child.staticClass, parent.staticClass),
    class: isDef(child.class)
      ? [child.class, parent.class]
      : parent.class
  }
}

function renderClass (
  staticClass,
  dynamicClass
) {
  if (isDef(staticClass) || isDef(dynamicClass)) {
    return concat(staticClass, stringifyClass(dynamicClass))
  }
  /* istanbul ignore next */
  return ''
}

function concat (a, b) {
  return a ? b ? (a + ' ' + b) : a : (b || '')
}

function stringifyClass (value) {
  if (Array.isArray(value)) {
    return stringifyArray(value)
  }
  if (isObject(value)) {
    return stringifyObject(value)
  }
  if (typeof value === 'string') {
    return value
  }
  /* istanbul ignore next */
  return ''
}

function stringifyArray (value) {
  var res = '';
  var stringified;
  for (var i = 0, l = value.length; i < l; i++) {
    if (isDef(stringified = stringifyClass(value[i])) && stringified !== '') {
      if (res) { res += ' '; }
      res += stringified;
    }
  }
  return res
}

function stringifyObject (value) {
  var res = '';
  for (var key in value) {
    if (value[key]) {
      if (res) { res += ' '; }
      res += key;
    }
  }
  return res
}

/*  */

var namespaceMap = {
  svg: 'http://www.w3.org/2000/svg',
  math: 'http://www.w3.org/1998/Math/MathML'
};

var isHTMLTag = makeMap(
  'html,body,base,head,link,meta,style,title,' +
  'address,article,aside,footer,header,h1,h2,h3,h4,h5,h6,hgroup,nav,section,' +
  'div,dd,dl,dt,figcaption,figure,picture,hr,img,li,main,ol,p,pre,ul,' +
  'a,b,abbr,bdi,bdo,br,cite,code,data,dfn,em,i,kbd,mark,q,rp,rt,rtc,ruby,' +
  's,samp,small,span,strong,sub,sup,time,u,var,wbr,area,audio,map,track,video,' +
  'embed,object,param,source,canvas,script,noscript,del,ins,' +
  'caption,col,colgroup,table,thead,tbody,td,th,tr,' +
  'button,datalist,fieldset,form,input,label,legend,meter,optgroup,option,' +
  'output,progress,select,textarea,' +
  'details,dialog,menu,menuitem,summary,' +
  'content,element,shadow,template,blockquote,iframe,tfoot'
);

// this map is intentionally selective, only covering SVG elements that may
// contain child elements.
var isSVG = makeMap(
  'svg,animate,circle,clippath,cursor,defs,desc,ellipse,filter,font-face,' +
  'foreignobject,g,glyph,image,line,marker,mask,missing-glyph,path,pattern,' +
  'polygon,polyline,rect,switch,symbol,text,textpath,tspan,use,view',
  true
);

var isPreTag = function (tag) { return tag === 'pre'; };

var isReservedTag = function (tag) {
  return isHTMLTag(tag) || isSVG(tag)
};

function getTagNamespace (tag) {
  if (isSVG(tag)) {
    return 'svg'
  }
  // basic support for MathML
  // note it doesn't support other MathML elements being component roots
  if (tag === 'math') {
    return 'math'
  }
}

var unknownElementCache = Object.create(null);
function isUnknownElement (tag) {
  /* istanbul ignore if */
  if (!inBrowser) {
    return true
  }
  if (isReservedTag(tag)) {
    return false
  }
  tag = tag.toLowerCase();
  /* istanbul ignore if */
  if (unknownElementCache[tag] != null) {
    return unknownElementCache[tag]
  }
  var el = document.createElement(tag);
  if (tag.indexOf('-') > -1) {
    // http://stackoverflow.com/a/28210364/1070244
    return (unknownElementCache[tag] = (
      el.constructor === window.HTMLUnknownElement ||
      el.constructor === window.HTMLElement
    ))
  } else {
    return (unknownElementCache[tag] = /HTMLUnknownElement/.test(el.toString()))
  }
}

var isTextInputType = makeMap('text,number,password,search,email,tel,url');

/*  */

/**
 * Query an element selector if it's not an element already.
 */
function query (el) {
  if (typeof el === 'string') {
    var selected = document.querySelector(el);
    if (!selected) {
       true && warn(
        'Cannot find element: ' + el
      );
      return document.createElement('div')
    }
    return selected
  } else {
    return el
  }
}

/*  */

function createElement$1 (tagName, vnode) {
  var elm = document.createElement(tagName);
  if (tagName !== 'select') {
    return elm
  }
  // false or null will remove the attribute but undefined will not
  if (vnode.data && vnode.data.attrs && vnode.data.attrs.multiple !== undefined) {
    elm.setAttribute('multiple', 'multiple');
  }
  return elm
}

function createElementNS (namespace, tagName) {
  return document.createElementNS(namespaceMap[namespace], tagName)
}

function createTextNode (text) {
  return document.createTextNode(text)
}

function createComment (text) {
  return document.createComment(text)
}

function insertBefore (parentNode, newNode, referenceNode) {
  parentNode.insertBefore(newNode, referenceNode);
}

function removeChild (node, child) {
  node.removeChild(child);
}

function appendChild (node, child) {
  node.appendChild(child);
}

function parentNode (node) {
  return node.parentNode
}

function nextSibling (node) {
  return node.nextSibling
}

function tagName (node) {
  return node.tagName
}

function setTextContent (node, text) {
  node.textContent = text;
}

function setStyleScope (node, scopeId) {
  node.setAttribute(scopeId, '');
}

var nodeOps = /*#__PURE__*/Object.freeze({
  createElement: createElement$1,
  createElementNS: createElementNS,
  createTextNode: createTextNode,
  createComment: createComment,
  insertBefore: insertBefore,
  removeChild: removeChild,
  appendChild: appendChild,
  parentNode: parentNode,
  nextSibling: nextSibling,
  tagName: tagName,
  setTextContent: setTextContent,
  setStyleScope: setStyleScope
});

/*  */

var ref = {
  create: function create (_, vnode) {
    registerRef(vnode);
  },
  update: function update (oldVnode, vnode) {
    if (oldVnode.data.ref !== vnode.data.ref) {
      registerRef(oldVnode, true);
      registerRef(vnode);
    }
  },
  destroy: function destroy (vnode) {
    registerRef(vnode, true);
  }
};

function registerRef (vnode, isRemoval) {
  var key = vnode.data.ref;
  if (!isDef(key)) { return }

  var vm = vnode.context;
  var ref = vnode.componentInstance || vnode.elm;
  var refs = vm.$refs;
  if (isRemoval) {
    if (Array.isArray(refs[key])) {
      remove(refs[key], ref);
    } else if (refs[key] === ref) {
      refs[key] = undefined;
    }
  } else {
    if (vnode.data.refInFor) {
      if (!Array.isArray(refs[key])) {
        refs[key] = [ref];
      } else if (refs[key].indexOf(ref) < 0) {
        // $flow-disable-line
        refs[key].push(ref);
      }
    } else {
      refs[key] = ref;
    }
  }
}

/**
 * Virtual DOM patching algorithm based on Snabbdom by
 * Simon Friis Vindum (@paldepind)
 * Licensed under the MIT License
 * https://github.com/paldepind/snabbdom/blob/master/LICENSE
 *
 * modified by Evan You (@yyx990803)
 *
 * Not type-checking this because this file is perf-critical and the cost
 * of making flow understand it is not worth it.
 */

var emptyNode = new VNode('', {}, []);

var hooks = ['create', 'activate', 'update', 'remove', 'destroy'];

function sameVnode (a, b) {
  return (
    a.key === b.key &&
    a.asyncFactory === b.asyncFactory && (
      (
        a.tag === b.tag &&
        a.isComment === b.isComment &&
        isDef(a.data) === isDef(b.data) &&
        sameInputType(a, b)
      ) || (
        isTrue(a.isAsyncPlaceholder) &&
        isUndef(b.asyncFactory.error)
      )
    )
  )
}

function sameInputType (a, b) {
  if (a.tag !== 'input') { return true }
  var i;
  var typeA = isDef(i = a.data) && isDef(i = i.attrs) && i.type;
  var typeB = isDef(i = b.data) && isDef(i = i.attrs) && i.type;
  return typeA === typeB || isTextInputType(typeA) && isTextInputType(typeB)
}

function createKeyToOldIdx (children, beginIdx, endIdx) {
  var i, key;
  var map = {};
  for (i = beginIdx; i <= endIdx; ++i) {
    key = children[i].key;
    if (isDef(key)) { map[key] = i; }
  }
  return map
}

function createPatchFunction (backend) {
  var i, j;
  var cbs = {};

  var modules = backend.modules;
  var nodeOps = backend.nodeOps;

  for (i = 0; i < hooks.length; ++i) {
    cbs[hooks[i]] = [];
    for (j = 0; j < modules.length; ++j) {
      if (isDef(modules[j][hooks[i]])) {
        cbs[hooks[i]].push(modules[j][hooks[i]]);
      }
    }
  }

  function emptyNodeAt (elm) {
    return new VNode(nodeOps.tagName(elm).toLowerCase(), {}, [], undefined, elm)
  }

  function createRmCb (childElm, listeners) {
    function remove$$1 () {
      if (--remove$$1.listeners === 0) {
        removeNode(childElm);
      }
    }
    remove$$1.listeners = listeners;
    return remove$$1
  }

  function removeNode (el) {
    var parent = nodeOps.parentNode(el);
    // element may have already been removed due to v-html / v-text
    if (isDef(parent)) {
      nodeOps.removeChild(parent, el);
    }
  }

  function isUnknownElement$$1 (vnode, inVPre) {
    return (
      !inVPre &&
      !vnode.ns &&
      !(
        config.ignoredElements.length &&
        config.ignoredElements.some(function (ignore) {
          return isRegExp(ignore)
            ? ignore.test(vnode.tag)
            : ignore === vnode.tag
        })
      ) &&
      config.isUnknownElement(vnode.tag)
    )
  }

  var creatingElmInVPre = 0;

  function createElm (
    vnode,
    insertedVnodeQueue,
    parentElm,
    refElm,
    nested,
    ownerArray,
    index
  ) {
    if (isDef(vnode.elm) && isDef(ownerArray)) {
      // This vnode was used in a previous render!
      // now it's used as a new node, overwriting its elm would cause
      // potential patch errors down the road when it's used as an insertion
      // reference node. Instead, we clone the node on-demand before creating
      // associated DOM element for it.
      vnode = ownerArray[index] = cloneVNode(vnode);
    }

    vnode.isRootInsert = !nested; // for transition enter check
    if (createComponent(vnode, insertedVnodeQueue, parentElm, refElm)) {
      return
    }

    var data = vnode.data;
    var children = vnode.children;
    var tag = vnode.tag;
    if (isDef(tag)) {
      if (true) {
        if (data && data.pre) {
          creatingElmInVPre++;
        }
        if (isUnknownElement$$1(vnode, creatingElmInVPre)) {
          warn(
            'Unknown custom element: <' + tag + '> - did you ' +
            'register the component correctly? For recursive components, ' +
            'make sure to provide the "name" option.',
            vnode.context
          );
        }
      }

      vnode.elm = vnode.ns
        ? nodeOps.createElementNS(vnode.ns, tag)
        : nodeOps.createElement(tag, vnode);
      setScope(vnode);

      /* istanbul ignore if */
      {
        createChildren(vnode, children, insertedVnodeQueue);
        if (isDef(data)) {
          invokeCreateHooks(vnode, insertedVnodeQueue);
        }
        insert(parentElm, vnode.elm, refElm);
      }

      if ( true && data && data.pre) {
        creatingElmInVPre--;
      }
    } else if (isTrue(vnode.isComment)) {
      vnode.elm = nodeOps.createComment(vnode.text);
      insert(parentElm, vnode.elm, refElm);
    } else {
      vnode.elm = nodeOps.createTextNode(vnode.text);
      insert(parentElm, vnode.elm, refElm);
    }
  }

  function createComponent (vnode, insertedVnodeQueue, parentElm, refElm) {
    var i = vnode.data;
    if (isDef(i)) {
      var isReactivated = isDef(vnode.componentInstance) && i.keepAlive;
      if (isDef(i = i.hook) && isDef(i = i.init)) {
        i(vnode, false /* hydrating */);
      }
      // after calling the init hook, if the vnode is a child component
      // it should've created a child instance and mounted it. the child
      // component also has set the placeholder vnode's elm.
      // in that case we can just return the element and be done.
      if (isDef(vnode.componentInstance)) {
        initComponent(vnode, insertedVnodeQueue);
        insert(parentElm, vnode.elm, refElm);
        if (isTrue(isReactivated)) {
          reactivateComponent(vnode, insertedVnodeQueue, parentElm, refElm);
        }
        return true
      }
    }
  }

  function initComponent (vnode, insertedVnodeQueue) {
    if (isDef(vnode.data.pendingInsert)) {
      insertedVnodeQueue.push.apply(insertedVnodeQueue, vnode.data.pendingInsert);
      vnode.data.pendingInsert = null;
    }
    vnode.elm = vnode.componentInstance.$el;
    if (isPatchable(vnode)) {
      invokeCreateHooks(vnode, insertedVnodeQueue);
      setScope(vnode);
    } else {
      // empty component root.
      // skip all element-related modules except for ref (#3455)
      registerRef(vnode);
      // make sure to invoke the insert hook
      insertedVnodeQueue.push(vnode);
    }
  }

  function reactivateComponent (vnode, insertedVnodeQueue, parentElm, refElm) {
    var i;
    // hack for #4339: a reactivated component with inner transition
    // does not trigger because the inner node's created hooks are not called
    // again. It's not ideal to involve module-specific logic in here but
    // there doesn't seem to be a better way to do it.
    var innerNode = vnode;
    while (innerNode.componentInstance) {
      innerNode = innerNode.componentInstance._vnode;
      if (isDef(i = innerNode.data) && isDef(i = i.transition)) {
        for (i = 0; i < cbs.activate.length; ++i) {
          cbs.activate[i](emptyNode, innerNode);
        }
        insertedVnodeQueue.push(innerNode);
        break
      }
    }
    // unlike a newly created component,
    // a reactivated keep-alive component doesn't insert itself
    insert(parentElm, vnode.elm, refElm);
  }

  function insert (parent, elm, ref$$1) {
    if (isDef(parent)) {
      if (isDef(ref$$1)) {
        if (nodeOps.parentNode(ref$$1) === parent) {
          nodeOps.insertBefore(parent, elm, ref$$1);
        }
      } else {
        nodeOps.appendChild(parent, elm);
      }
    }
  }

  function createChildren (vnode, children, insertedVnodeQueue) {
    if (Array.isArray(children)) {
      if (true) {
        checkDuplicateKeys(children);
      }
      for (var i = 0; i < children.length; ++i) {
        createElm(children[i], insertedVnodeQueue, vnode.elm, null, true, children, i);
      }
    } else if (isPrimitive(vnode.text)) {
      nodeOps.appendChild(vnode.elm, nodeOps.createTextNode(String(vnode.text)));
    }
  }

  function isPatchable (vnode) {
    while (vnode.componentInstance) {
      vnode = vnode.componentInstance._vnode;
    }
    return isDef(vnode.tag)
  }

  function invokeCreateHooks (vnode, insertedVnodeQueue) {
    for (var i$1 = 0; i$1 < cbs.create.length; ++i$1) {
      cbs.create[i$1](emptyNode, vnode);
    }
    i = vnode.data.hook; // Reuse variable
    if (isDef(i)) {
      if (isDef(i.create)) { i.create(emptyNode, vnode); }
      if (isDef(i.insert)) { insertedVnodeQueue.push(vnode); }
    }
  }

  // set scope id attribute for scoped CSS.
  // this is implemented as a special case to avoid the overhead
  // of going through the normal attribute patching process.
  function setScope (vnode) {
    var i;
    if (isDef(i = vnode.fnScopeId)) {
      nodeOps.setStyleScope(vnode.elm, i);
    } else {
      var ancestor = vnode;
      while (ancestor) {
        if (isDef(i = ancestor.context) && isDef(i = i.$options._scopeId)) {
          nodeOps.setStyleScope(vnode.elm, i);
        }
        ancestor = ancestor.parent;
      }
    }
    // for slot content they should also get the scopeId from the host instance.
    if (isDef(i = activeInstance) &&
      i !== vnode.context &&
      i !== vnode.fnContext &&
      isDef(i = i.$options._scopeId)
    ) {
      nodeOps.setStyleScope(vnode.elm, i);
    }
  }

  function addVnodes (parentElm, refElm, vnodes, startIdx, endIdx, insertedVnodeQueue) {
    for (; startIdx <= endIdx; ++startIdx) {
      createElm(vnodes[startIdx], insertedVnodeQueue, parentElm, refElm, false, vnodes, startIdx);
    }
  }

  function invokeDestroyHook (vnode) {
    var i, j;
    var data = vnode.data;
    if (isDef(data)) {
      if (isDef(i = data.hook) && isDef(i = i.destroy)) { i(vnode); }
      for (i = 0; i < cbs.destroy.length; ++i) { cbs.destroy[i](vnode); }
    }
    if (isDef(i = vnode.children)) {
      for (j = 0; j < vnode.children.length; ++j) {
        invokeDestroyHook(vnode.children[j]);
      }
    }
  }

  function removeVnodes (vnodes, startIdx, endIdx) {
    for (; startIdx <= endIdx; ++startIdx) {
      var ch = vnodes[startIdx];
      if (isDef(ch)) {
        if (isDef(ch.tag)) {
          removeAndInvokeRemoveHook(ch);
          invokeDestroyHook(ch);
        } else { // Text node
          removeNode(ch.elm);
        }
      }
    }
  }

  function removeAndInvokeRemoveHook (vnode, rm) {
    if (isDef(rm) || isDef(vnode.data)) {
      var i;
      var listeners = cbs.remove.length + 1;
      if (isDef(rm)) {
        // we have a recursively passed down rm callback
        // increase the listeners count
        rm.listeners += listeners;
      } else {
        // directly removing
        rm = createRmCb(vnode.elm, listeners);
      }
      // recursively invoke hooks on child component root node
      if (isDef(i = vnode.componentInstance) && isDef(i = i._vnode) && isDef(i.data)) {
        removeAndInvokeRemoveHook(i, rm);
      }
      for (i = 0; i < cbs.remove.length; ++i) {
        cbs.remove[i](vnode, rm);
      }
      if (isDef(i = vnode.data.hook) && isDef(i = i.remove)) {
        i(vnode, rm);
      } else {
        rm();
      }
    } else {
      removeNode(vnode.elm);
    }
  }

  function updateChildren (parentElm, oldCh, newCh, insertedVnodeQueue, removeOnly) {
    var oldStartIdx = 0;
    var newStartIdx = 0;
    var oldEndIdx = oldCh.length - 1;
    var oldStartVnode = oldCh[0];
    var oldEndVnode = oldCh[oldEndIdx];
    var newEndIdx = newCh.length - 1;
    var newStartVnode = newCh[0];
    var newEndVnode = newCh[newEndIdx];
    var oldKeyToIdx, idxInOld, vnodeToMove, refElm;

    // removeOnly is a special flag used only by <transition-group>
    // to ensure removed elements stay in correct relative positions
    // during leaving transitions
    var canMove = !removeOnly;

    if (true) {
      checkDuplicateKeys(newCh);
    }

    while (oldStartIdx <= oldEndIdx && newStartIdx <= newEndIdx) {
      if (isUndef(oldStartVnode)) {
        oldStartVnode = oldCh[++oldStartIdx]; // Vnode has been moved left
      } else if (isUndef(oldEndVnode)) {
        oldEndVnode = oldCh[--oldEndIdx];
      } else if (sameVnode(oldStartVnode, newStartVnode)) {
        patchVnode(oldStartVnode, newStartVnode, insertedVnodeQueue, newCh, newStartIdx);
        oldStartVnode = oldCh[++oldStartIdx];
        newStartVnode = newCh[++newStartIdx];
      } else if (sameVnode(oldEndVnode, newEndVnode)) {
        patchVnode(oldEndVnode, newEndVnode, insertedVnodeQueue, newCh, newEndIdx);
        oldEndVnode = oldCh[--oldEndIdx];
        newEndVnode = newCh[--newEndIdx];
      } else if (sameVnode(oldStartVnode, newEndVnode)) { // Vnode moved right
        patchVnode(oldStartVnode, newEndVnode, insertedVnodeQueue, newCh, newEndIdx);
        canMove && nodeOps.insertBefore(parentElm, oldStartVnode.elm, nodeOps.nextSibling(oldEndVnode.elm));
        oldStartVnode = oldCh[++oldStartIdx];
        newEndVnode = newCh[--newEndIdx];
      } else if (sameVnode(oldEndVnode, newStartVnode)) { // Vnode moved left
        patchVnode(oldEndVnode, newStartVnode, insertedVnodeQueue, newCh, newStartIdx);
        canMove && nodeOps.insertBefore(parentElm, oldEndVnode.elm, oldStartVnode.elm);
        oldEndVnode = oldCh[--oldEndIdx];
        newStartVnode = newCh[++newStartIdx];
      } else {
        if (isUndef(oldKeyToIdx)) { oldKeyToIdx = createKeyToOldIdx(oldCh, oldStartIdx, oldEndIdx); }
        idxInOld = isDef(newStartVnode.key)
          ? oldKeyToIdx[newStartVnode.key]
          : findIdxInOld(newStartVnode, oldCh, oldStartIdx, oldEndIdx);
        if (isUndef(idxInOld)) { // New element
          createElm(newStartVnode, insertedVnodeQueue, parentElm, oldStartVnode.elm, false, newCh, newStartIdx);
        } else {
          vnodeToMove = oldCh[idxInOld];
          if (sameVnode(vnodeToMove, newStartVnode)) {
            patchVnode(vnodeToMove, newStartVnode, insertedVnodeQueue, newCh, newStartIdx);
            oldCh[idxInOld] = undefined;
            canMove && nodeOps.insertBefore(parentElm, vnodeToMove.elm, oldStartVnode.elm);
          } else {
            // same key but different element. treat as new element
            createElm(newStartVnode, insertedVnodeQueue, parentElm, oldStartVnode.elm, false, newCh, newStartIdx);
          }
        }
        newStartVnode = newCh[++newStartIdx];
      }
    }
    if (oldStartIdx > oldEndIdx) {
      refElm = isUndef(newCh[newEndIdx + 1]) ? null : newCh[newEndIdx + 1].elm;
      addVnodes(parentElm, refElm, newCh, newStartIdx, newEndIdx, insertedVnodeQueue);
    } else if (newStartIdx > newEndIdx) {
      removeVnodes(oldCh, oldStartIdx, oldEndIdx);
    }
  }

  function checkDuplicateKeys (children) {
    var seenKeys = {};
    for (var i = 0; i < children.length; i++) {
      var vnode = children[i];
      var key = vnode.key;
      if (isDef(key)) {
        if (seenKeys[key]) {
          warn(
            ("Duplicate keys detected: '" + key + "'. This may cause an update error."),
            vnode.context
          );
        } else {
          seenKeys[key] = true;
        }
      }
    }
  }

  function findIdxInOld (node, oldCh, start, end) {
    for (var i = start; i < end; i++) {
      var c = oldCh[i];
      if (isDef(c) && sameVnode(node, c)) { return i }
    }
  }

  function patchVnode (
    oldVnode,
    vnode,
    insertedVnodeQueue,
    ownerArray,
    index,
    removeOnly
  ) {
    if (oldVnode === vnode) {
      return
    }

    if (isDef(vnode.elm) && isDef(ownerArray)) {
      // clone reused vnode
      vnode = ownerArray[index] = cloneVNode(vnode);
    }

    var elm = vnode.elm = oldVnode.elm;

    if (isTrue(oldVnode.isAsyncPlaceholder)) {
      if (isDef(vnode.asyncFactory.resolved)) {
        hydrate(oldVnode.elm, vnode, insertedVnodeQueue);
      } else {
        vnode.isAsyncPlaceholder = true;
      }
      return
    }

    // reuse element for static trees.
    // note we only do this if the vnode is cloned -
    // if the new node is not cloned it means the render functions have been
    // reset by the hot-reload-api and we need to do a proper re-render.
    if (isTrue(vnode.isStatic) &&
      isTrue(oldVnode.isStatic) &&
      vnode.key === oldVnode.key &&
      (isTrue(vnode.isCloned) || isTrue(vnode.isOnce))
    ) {
      vnode.componentInstance = oldVnode.componentInstance;
      return
    }

    var i;
    var data = vnode.data;
    if (isDef(data) && isDef(i = data.hook) && isDef(i = i.prepatch)) {
      i(oldVnode, vnode);
    }

    var oldCh = oldVnode.children;
    var ch = vnode.children;
    if (isDef(data) && isPatchable(vnode)) {
      for (i = 0; i < cbs.update.length; ++i) { cbs.update[i](oldVnode, vnode); }
      if (isDef(i = data.hook) && isDef(i = i.update)) { i(oldVnode, vnode); }
    }
    if (isUndef(vnode.text)) {
      if (isDef(oldCh) && isDef(ch)) {
        if (oldCh !== ch) { updateChildren(elm, oldCh, ch, insertedVnodeQueue, removeOnly); }
      } else if (isDef(ch)) {
        if (true) {
          checkDuplicateKeys(ch);
        }
        if (isDef(oldVnode.text)) { nodeOps.setTextContent(elm, ''); }
        addVnodes(elm, null, ch, 0, ch.length - 1, insertedVnodeQueue);
      } else if (isDef(oldCh)) {
        removeVnodes(oldCh, 0, oldCh.length - 1);
      } else if (isDef(oldVnode.text)) {
        nodeOps.setTextContent(elm, '');
      }
    } else if (oldVnode.text !== vnode.text) {
      nodeOps.setTextContent(elm, vnode.text);
    }
    if (isDef(data)) {
      if (isDef(i = data.hook) && isDef(i = i.postpatch)) { i(oldVnode, vnode); }
    }
  }

  function invokeInsertHook (vnode, queue, initial) {
    // delay insert hooks for component root nodes, invoke them after the
    // element is really inserted
    if (isTrue(initial) && isDef(vnode.parent)) {
      vnode.parent.data.pendingInsert = queue;
    } else {
      for (var i = 0; i < queue.length; ++i) {
        queue[i].data.hook.insert(queue[i]);
      }
    }
  }

  var hydrationBailed = false;
  // list of modules that can skip create hook during hydration because they
  // are already rendered on the client or has no need for initialization
  // Note: style is excluded because it relies on initial clone for future
  // deep updates (#7063).
  var isRenderedModule = makeMap('attrs,class,staticClass,staticStyle,key');

  // Note: this is a browser-only function so we can assume elms are DOM nodes.
  function hydrate (elm, vnode, insertedVnodeQueue, inVPre) {
    var i;
    var tag = vnode.tag;
    var data = vnode.data;
    var children = vnode.children;
    inVPre = inVPre || (data && data.pre);
    vnode.elm = elm;

    if (isTrue(vnode.isComment) && isDef(vnode.asyncFactory)) {
      vnode.isAsyncPlaceholder = true;
      return true
    }
    // assert node match
    if (true) {
      if (!assertNodeMatch(elm, vnode, inVPre)) {
        return false
      }
    }
    if (isDef(data)) {
      if (isDef(i = data.hook) && isDef(i = i.init)) { i(vnode, true /* hydrating */); }
      if (isDef(i = vnode.componentInstance)) {
        // child component. it should have hydrated its own tree.
        initComponent(vnode, insertedVnodeQueue);
        return true
      }
    }
    if (isDef(tag)) {
      if (isDef(children)) {
        // empty element, allow client to pick up and populate children
        if (!elm.hasChildNodes()) {
          createChildren(vnode, children, insertedVnodeQueue);
        } else {
          // v-html and domProps: innerHTML
          if (isDef(i = data) && isDef(i = i.domProps) && isDef(i = i.innerHTML)) {
            if (i !== elm.innerHTML) {
              /* istanbul ignore if */
              if ( true &&
                typeof console !== 'undefined' &&
                !hydrationBailed
              ) {
                hydrationBailed = true;
                console.warn('Parent: ', elm);
                console.warn('server innerHTML: ', i);
                console.warn('client innerHTML: ', elm.innerHTML);
              }
              return false
            }
          } else {
            // iterate and compare children lists
            var childrenMatch = true;
            var childNode = elm.firstChild;
            for (var i$1 = 0; i$1 < children.length; i$1++) {
              if (!childNode || !hydrate(childNode, children[i$1], insertedVnodeQueue, inVPre)) {
                childrenMatch = false;
                break
              }
              childNode = childNode.nextSibling;
            }
            // if childNode is not null, it means the actual childNodes list is
            // longer than the virtual children list.
            if (!childrenMatch || childNode) {
              /* istanbul ignore if */
              if ( true &&
                typeof console !== 'undefined' &&
                !hydrationBailed
              ) {
                hydrationBailed = true;
                console.warn('Parent: ', elm);
                console.warn('Mismatching childNodes vs. VNodes: ', elm.childNodes, children);
              }
              return false
            }
          }
        }
      }
      if (isDef(data)) {
        var fullInvoke = false;
        for (var key in data) {
          if (!isRenderedModule(key)) {
            fullInvoke = true;
            invokeCreateHooks(vnode, insertedVnodeQueue);
            break
          }
        }
        if (!fullInvoke && data['class']) {
          // ensure collecting deps for deep class bindings for future updates
          traverse(data['class']);
        }
      }
    } else if (elm.data !== vnode.text) {
      elm.data = vnode.text;
    }
    return true
  }

  function assertNodeMatch (node, vnode, inVPre) {
    if (isDef(vnode.tag)) {
      return vnode.tag.indexOf('vue-component') === 0 || (
        !isUnknownElement$$1(vnode, inVPre) &&
        vnode.tag.toLowerCase() === (node.tagName && node.tagName.toLowerCase())
      )
    } else {
      return node.nodeType === (vnode.isComment ? 8 : 3)
    }
  }

  return function patch (oldVnode, vnode, hydrating, removeOnly) {
    if (isUndef(vnode)) {
      if (isDef(oldVnode)) { invokeDestroyHook(oldVnode); }
      return
    }

    var isInitialPatch = false;
    var insertedVnodeQueue = [];

    if (isUndef(oldVnode)) {
      // empty mount (likely as component), create new root element
      isInitialPatch = true;
      createElm(vnode, insertedVnodeQueue);
    } else {
      var isRealElement = isDef(oldVnode.nodeType);
      if (!isRealElement && sameVnode(oldVnode, vnode)) {
        // patch existing root node
        patchVnode(oldVnode, vnode, insertedVnodeQueue, null, null, removeOnly);
      } else {
        if (isRealElement) {
          // mounting to a real element
          // check if this is server-rendered content and if we can perform
          // a successful hydration.
          if (oldVnode.nodeType === 1 && oldVnode.hasAttribute(SSR_ATTR)) {
            oldVnode.removeAttribute(SSR_ATTR);
            hydrating = true;
          }
          if (isTrue(hydrating)) {
            if (hydrate(oldVnode, vnode, insertedVnodeQueue)) {
              invokeInsertHook(vnode, insertedVnodeQueue, true);
              return oldVnode
            } else if (true) {
              warn(
                'The client-side rendered virtual DOM tree is not matching ' +
                'server-rendered content. This is likely caused by incorrect ' +
                'HTML markup, for example nesting block-level elements inside ' +
                '<p>, or missing <tbody>. Bailing hydration and performing ' +
                'full client-side render.'
              );
            }
          }
          // either not server-rendered, or hydration failed.
          // create an empty node and replace it
          oldVnode = emptyNodeAt(oldVnode);
        }

        // replacing existing element
        var oldElm = oldVnode.elm;
        var parentElm = nodeOps.parentNode(oldElm);

        // create new node
        createElm(
          vnode,
          insertedVnodeQueue,
          // extremely rare edge case: do not insert if old element is in a
          // leaving transition. Only happens when combining transition +
          // keep-alive + HOCs. (#4590)
          oldElm._leaveCb ? null : parentElm,
          nodeOps.nextSibling(oldElm)
        );

        // update parent placeholder node element, recursively
        if (isDef(vnode.parent)) {
          var ancestor = vnode.parent;
          var patchable = isPatchable(vnode);
          while (ancestor) {
            for (var i = 0; i < cbs.destroy.length; ++i) {
              cbs.destroy[i](ancestor);
            }
            ancestor.elm = vnode.elm;
            if (patchable) {
              for (var i$1 = 0; i$1 < cbs.create.length; ++i$1) {
                cbs.create[i$1](emptyNode, ancestor);
              }
              // #6513
              // invoke insert hooks that may have been merged by create hooks.
              // e.g. for directives that uses the "inserted" hook.
              var insert = ancestor.data.hook.insert;
              if (insert.merged) {
                // start at index 1 to avoid re-invoking component mounted hook
                for (var i$2 = 1; i$2 < insert.fns.length; i$2++) {
                  insert.fns[i$2]();
                }
              }
            } else {
              registerRef(ancestor);
            }
            ancestor = ancestor.parent;
          }
        }

        // destroy old node
        if (isDef(parentElm)) {
          removeVnodes([oldVnode], 0, 0);
        } else if (isDef(oldVnode.tag)) {
          invokeDestroyHook(oldVnode);
        }
      }
    }

    invokeInsertHook(vnode, insertedVnodeQueue, isInitialPatch);
    return vnode.elm
  }
}

/*  */

var directives = {
  create: updateDirectives,
  update: updateDirectives,
  destroy: function unbindDirectives (vnode) {
    updateDirectives(vnode, emptyNode);
  }
};

function updateDirectives (oldVnode, vnode) {
  if (oldVnode.data.directives || vnode.data.directives) {
    _update(oldVnode, vnode);
  }
}

function _update (oldVnode, vnode) {
  var isCreate = oldVnode === emptyNode;
  var isDestroy = vnode === emptyNode;
  var oldDirs = normalizeDirectives$1(oldVnode.data.directives, oldVnode.context);
  var newDirs = normalizeDirectives$1(vnode.data.directives, vnode.context);

  var dirsWithInsert = [];
  var dirsWithPostpatch = [];

  var key, oldDir, dir;
  for (key in newDirs) {
    oldDir = oldDirs[key];
    dir = newDirs[key];
    if (!oldDir) {
      // new directive, bind
      callHook$1(dir, 'bind', vnode, oldVnode);
      if (dir.def && dir.def.inserted) {
        dirsWithInsert.push(dir);
      }
    } else {
      // existing directive, update
      dir.oldValue = oldDir.value;
      dir.oldArg = oldDir.arg;
      callHook$1(dir, 'update', vnode, oldVnode);
      if (dir.def && dir.def.componentUpdated) {
        dirsWithPostpatch.push(dir);
      }
    }
  }

  if (dirsWithInsert.length) {
    var callInsert = function () {
      for (var i = 0; i < dirsWithInsert.length; i++) {
        callHook$1(dirsWithInsert[i], 'inserted', vnode, oldVnode);
      }
    };
    if (isCreate) {
      mergeVNodeHook(vnode, 'insert', callInsert);
    } else {
      callInsert();
    }
  }

  if (dirsWithPostpatch.length) {
    mergeVNodeHook(vnode, 'postpatch', function () {
      for (var i = 0; i < dirsWithPostpatch.length; i++) {
        callHook$1(dirsWithPostpatch[i], 'componentUpdated', vnode, oldVnode);
      }
    });
  }

  if (!isCreate) {
    for (key in oldDirs) {
      if (!newDirs[key]) {
        // no longer present, unbind
        callHook$1(oldDirs[key], 'unbind', oldVnode, oldVnode, isDestroy);
      }
    }
  }
}

var emptyModifiers = Object.create(null);

function normalizeDirectives$1 (
  dirs,
  vm
) {
  var res = Object.create(null);
  if (!dirs) {
    // $flow-disable-line
    return res
  }
  var i, dir;
  for (i = 0; i < dirs.length; i++) {
    dir = dirs[i];
    if (!dir.modifiers) {
      // $flow-disable-line
      dir.modifiers = emptyModifiers;
    }
    res[getRawDirName(dir)] = dir;
    dir.def = resolveAsset(vm.$options, 'directives', dir.name, true);
  }
  // $flow-disable-line
  return res
}

function getRawDirName (dir) {
  return dir.rawName || ((dir.name) + "." + (Object.keys(dir.modifiers || {}).join('.')))
}

function callHook$1 (dir, hook, vnode, oldVnode, isDestroy) {
  var fn = dir.def && dir.def[hook];
  if (fn) {
    try {
      fn(vnode.elm, dir, vnode, oldVnode, isDestroy);
    } catch (e) {
      handleError(e, vnode.context, ("directive " + (dir.name) + " " + hook + " hook"));
    }
  }
}

var baseModules = [
  ref,
  directives
];

/*  */

function updateAttrs (oldVnode, vnode) {
  var opts = vnode.componentOptions;
  if (isDef(opts) && opts.Ctor.options.inheritAttrs === false) {
    return
  }
  if (isUndef(oldVnode.data.attrs) && isUndef(vnode.data.attrs)) {
    return
  }
  var key, cur, old;
  var elm = vnode.elm;
  var oldAttrs = oldVnode.data.attrs || {};
  var attrs = vnode.data.attrs || {};
  // clone observed objects, as the user probably wants to mutate it
  if (isDef(attrs.__ob__)) {
    attrs = vnode.data.attrs = extend({}, attrs);
  }

  for (key in attrs) {
    cur = attrs[key];
    old = oldAttrs[key];
    if (old !== cur) {
      setAttr(elm, key, cur, vnode.data.pre);
    }
  }
  // #4391: in IE9, setting type can reset value for input[type=radio]
  // #6666: IE/Edge forces progress value down to 1 before setting a max
  /* istanbul ignore if */
  if ((isIE || isEdge) && attrs.value !== oldAttrs.value) {
    setAttr(elm, 'value', attrs.value);
  }
  for (key in oldAttrs) {
    if (isUndef(attrs[key])) {
      if (isXlink(key)) {
        elm.removeAttributeNS(xlinkNS, getXlinkProp(key));
      } else if (!isEnumeratedAttr(key)) {
        elm.removeAttribute(key);
      }
    }
  }
}

function setAttr (el, key, value, isInPre) {
  if (isInPre || el.tagName.indexOf('-') > -1) {
    baseSetAttr(el, key, value);
  } else if (isBooleanAttr(key)) {
    // set attribute for blank value
    // e.g. <option disabled>Select one</option>
    if (isFalsyAttrValue(value)) {
      el.removeAttribute(key);
    } else {
      // technically allowfullscreen is a boolean attribute for <iframe>,
      // but Flash expects a value of "true" when used on <embed> tag
      value = key === 'allowfullscreen' && el.tagName === 'EMBED'
        ? 'true'
        : key;
      el.setAttribute(key, value);
    }
  } else if (isEnumeratedAttr(key)) {
    el.setAttribute(key, convertEnumeratedValue(key, value));
  } else if (isXlink(key)) {
    if (isFalsyAttrValue(value)) {
      el.removeAttributeNS(xlinkNS, getXlinkProp(key));
    } else {
      el.setAttributeNS(xlinkNS, key, value);
    }
  } else {
    baseSetAttr(el, key, value);
  }
}

function baseSetAttr (el, key, value) {
  if (isFalsyAttrValue(value)) {
    el.removeAttribute(key);
  } else {
    // #7138: IE10 & 11 fires input event when setting placeholder on
    // <textarea>... block the first input event and remove the blocker
    // immediately.
    /* istanbul ignore if */
    if (
      isIE && !isIE9 &&
      el.tagName === 'TEXTAREA' &&
      key === 'placeholder' && value !== '' && !el.__ieph
    ) {
      var blocker = function (e) {
        e.stopImmediatePropagation();
        el.removeEventListener('input', blocker);
      };
      el.addEventListener('input', blocker);
      // $flow-disable-line
      el.__ieph = true; /* IE placeholder patched */
    }
    el.setAttribute(key, value);
  }
}

var attrs = {
  create: updateAttrs,
  update: updateAttrs
};

/*  */

function updateClass (oldVnode, vnode) {
  var el = vnode.elm;
  var data = vnode.data;
  var oldData = oldVnode.data;
  if (
    isUndef(data.staticClass) &&
    isUndef(data.class) && (
      isUndef(oldData) || (
        isUndef(oldData.staticClass) &&
        isUndef(oldData.class)
      )
    )
  ) {
    return
  }

  var cls = genClassForVnode(vnode);

  // handle transition classes
  var transitionClass = el._transitionClasses;
  if (isDef(transitionClass)) {
    cls = concat(cls, stringifyClass(transitionClass));
  }

  // set the class
  if (cls !== el._prevClass) {
    el.setAttribute('class', cls);
    el._prevClass = cls;
  }
}

var klass = {
  create: updateClass,
  update: updateClass
};

/*  */

var validDivisionCharRE = /[\w).+\-_$\]]/;

function parseFilters (exp) {
  var inSingle = false;
  var inDouble = false;
  var inTemplateString = false;
  var inRegex = false;
  var curly = 0;
  var square = 0;
  var paren = 0;
  var lastFilterIndex = 0;
  var c, prev, i, expression, filters;

  for (i = 0; i < exp.length; i++) {
    prev = c;
    c = exp.charCodeAt(i);
    if (inSingle) {
      if (c === 0x27 && prev !== 0x5C) { inSingle = false; }
    } else if (inDouble) {
      if (c === 0x22 && prev !== 0x5C) { inDouble = false; }
    } else if (inTemplateString) {
      if (c === 0x60 && prev !== 0x5C) { inTemplateString = false; }
    } else if (inRegex) {
      if (c === 0x2f && prev !== 0x5C) { inRegex = false; }
    } else if (
      c === 0x7C && // pipe
      exp.charCodeAt(i + 1) !== 0x7C &&
      exp.charCodeAt(i - 1) !== 0x7C &&
      !curly && !square && !paren
    ) {
      if (expression === undefined) {
        // first filter, end of expression
        lastFilterIndex = i + 1;
        expression = exp.slice(0, i).trim();
      } else {
        pushFilter();
      }
    } else {
      switch (c) {
        case 0x22: inDouble = true; break         // "
        case 0x27: inSingle = true; break         // '
        case 0x60: inTemplateString = true; break // `
        case 0x28: paren++; break                 // (
        case 0x29: paren--; break                 // )
        case 0x5B: square++; break                // [
        case 0x5D: square--; break                // ]
        case 0x7B: curly++; break                 // {
        case 0x7D: curly--; break                 // }
      }
      if (c === 0x2f) { // /
        var j = i - 1;
        var p = (void 0);
        // find first non-whitespace prev char
        for (; j >= 0; j--) {
          p = exp.charAt(j);
          if (p !== ' ') { break }
        }
        if (!p || !validDivisionCharRE.test(p)) {
          inRegex = true;
        }
      }
    }
  }

  if (expression === undefined) {
    expression = exp.slice(0, i).trim();
  } else if (lastFilterIndex !== 0) {
    pushFilter();
  }

  function pushFilter () {
    (filters || (filters = [])).push(exp.slice(lastFilterIndex, i).trim());
    lastFilterIndex = i + 1;
  }

  if (filters) {
    for (i = 0; i < filters.length; i++) {
      expression = wrapFilter(expression, filters[i]);
    }
  }

  return expression
}

function wrapFilter (exp, filter) {
  var i = filter.indexOf('(');
  if (i < 0) {
    // _f: resolveFilter
    return ("_f(\"" + filter + "\")(" + exp + ")")
  } else {
    var name = filter.slice(0, i);
    var args = filter.slice(i + 1);
    return ("_f(\"" + name + "\")(" + exp + (args !== ')' ? ',' + args : args))
  }
}

/*  */



/* eslint-disable no-unused-vars */
function baseWarn (msg, range) {
  console.error(("[Vue compiler]: " + msg));
}
/* eslint-enable no-unused-vars */

function pluckModuleFunction (
  modules,
  key
) {
  return modules
    ? modules.map(function (m) { return m[key]; }).filter(function (_) { return _; })
    : []
}

function addProp (el, name, value, range, dynamic) {
  (el.props || (el.props = [])).push(rangeSetItem({ name: name, value: value, dynamic: dynamic }, range));
  el.plain = false;
}

function addAttr (el, name, value, range, dynamic) {
  var attrs = dynamic
    ? (el.dynamicAttrs || (el.dynamicAttrs = []))
    : (el.attrs || (el.attrs = []));
  attrs.push(rangeSetItem({ name: name, value: value, dynamic: dynamic }, range));
  el.plain = false;
}

// add a raw attr (use this in preTransforms)
function addRawAttr (el, name, value, range) {
  el.attrsMap[name] = value;
  el.attrsList.push(rangeSetItem({ name: name, value: value }, range));
}

function addDirective (
  el,
  name,
  rawName,
  value,
  arg,
  isDynamicArg,
  modifiers,
  range
) {
  (el.directives || (el.directives = [])).push(rangeSetItem({
    name: name,
    rawName: rawName,
    value: value,
    arg: arg,
    isDynamicArg: isDynamicArg,
    modifiers: modifiers
  }, range));
  el.plain = false;
}

function prependModifierMarker (symbol, name, dynamic) {
  return dynamic
    ? ("_p(" + name + ",\"" + symbol + "\")")
    : symbol + name // mark the event as captured
}

function addHandler (
  el,
  name,
  value,
  modifiers,
  important,
  warn,
  range,
  dynamic
) {
  modifiers = modifiers || emptyObject;
  // warn prevent and passive modifier
  /* istanbul ignore if */
  if (
     true && warn &&
    modifiers.prevent && modifiers.passive
  ) {
    warn(
      'passive and prevent can\'t be used together. ' +
      'Passive handler can\'t prevent default event.',
      range
    );
  }

  // normalize click.right and click.middle since they don't actually fire
  // this is technically browser-specific, but at least for now browsers are
  // the only target envs that have right/middle clicks.
  if (modifiers.right) {
    if (dynamic) {
      name = "(" + name + ")==='click'?'contextmenu':(" + name + ")";
    } else if (name === 'click') {
      name = 'contextmenu';
      delete modifiers.right;
    }
  } else if (modifiers.middle) {
    if (dynamic) {
      name = "(" + name + ")==='click'?'mouseup':(" + name + ")";
    } else if (name === 'click') {
      name = 'mouseup';
    }
  }

  // check capture modifier
  if (modifiers.capture) {
    delete modifiers.capture;
    name = prependModifierMarker('!', name, dynamic);
  }
  if (modifiers.once) {
    delete modifiers.once;
    name = prependModifierMarker('~', name, dynamic);
  }
  /* istanbul ignore if */
  if (modifiers.passive) {
    delete modifiers.passive;
    name = prependModifierMarker('&', name, dynamic);
  }

  var events;
  if (modifiers.native) {
    delete modifiers.native;
    events = el.nativeEvents || (el.nativeEvents = {});
  } else {
    events = el.events || (el.events = {});
  }

  var newHandler = rangeSetItem({ value: value.trim(), dynamic: dynamic }, range);
  if (modifiers !== emptyObject) {
    newHandler.modifiers = modifiers;
  }

  var handlers = events[name];
  /* istanbul ignore if */
  if (Array.isArray(handlers)) {
    important ? handlers.unshift(newHandler) : handlers.push(newHandler);
  } else if (handlers) {
    events[name] = important ? [newHandler, handlers] : [handlers, newHandler];
  } else {
    events[name] = newHandler;
  }

  el.plain = false;
}

function getRawBindingAttr (
  el,
  name
) {
  return el.rawAttrsMap[':' + name] ||
    el.rawAttrsMap['v-bind:' + name] ||
    el.rawAttrsMap[name]
}

function getBindingAttr (
  el,
  name,
  getStatic
) {
  var dynamicValue =
    getAndRemoveAttr(el, ':' + name) ||
    getAndRemoveAttr(el, 'v-bind:' + name);
  if (dynamicValue != null) {
    return parseFilters(dynamicValue)
  } else if (getStatic !== false) {
    var staticValue = getAndRemoveAttr(el, name);
    if (staticValue != null) {
      return JSON.stringify(staticValue)
    }
  }
}

// note: this only removes the attr from the Array (attrsList) so that it
// doesn't get processed by processAttrs.
// By default it does NOT remove it from the map (attrsMap) because the map is
// needed during codegen.
function getAndRemoveAttr (
  el,
  name,
  removeFromMap
) {
  var val;
  if ((val = el.attrsMap[name]) != null) {
    var list = el.attrsList;
    for (var i = 0, l = list.length; i < l; i++) {
      if (list[i].name === name) {
        list.splice(i, 1);
        break
      }
    }
  }
  if (removeFromMap) {
    delete el.attrsMap[name];
  }
  return val
}

function getAndRemoveAttrByRegex (
  el,
  name
) {
  var list = el.attrsList;
  for (var i = 0, l = list.length; i < l; i++) {
    var attr = list[i];
    if (name.test(attr.name)) {
      list.splice(i, 1);
      return attr
    }
  }
}

function rangeSetItem (
  item,
  range
) {
  if (range) {
    if (range.start != null) {
      item.start = range.start;
    }
    if (range.end != null) {
      item.end = range.end;
    }
  }
  return item
}

/*  */

/**
 * Cross-platform code generation for component v-model
 */
function genComponentModel (
  el,
  value,
  modifiers
) {
  var ref = modifiers || {};
  var number = ref.number;
  var trim = ref.trim;

  var baseValueExpression = '$$v';
  var valueExpression = baseValueExpression;
  if (trim) {
    valueExpression =
      "(typeof " + baseValueExpression + " === 'string'" +
      "? " + baseValueExpression + ".trim()" +
      ": " + baseValueExpression + ")";
  }
  if (number) {
    valueExpression = "_n(" + valueExpression + ")";
  }
  var assignment = genAssignmentCode(value, valueExpression);

  el.model = {
    value: ("(" + value + ")"),
    expression: JSON.stringify(value),
    callback: ("function (" + baseValueExpression + ") {" + assignment + "}")
  };
}

/**
 * Cross-platform codegen helper for generating v-model value assignment code.
 */
function genAssignmentCode (
  value,
  assignment
) {
  var res = parseModel(value);
  if (res.key === null) {
    return (value + "=" + assignment)
  } else {
    return ("$set(" + (res.exp) + ", " + (res.key) + ", " + assignment + ")")
  }
}

/**
 * Parse a v-model expression into a base path and a final key segment.
 * Handles both dot-path and possible square brackets.
 *
 * Possible cases:
 *
 * - test
 * - test[key]
 * - test[test1[key]]
 * - test["a"][key]
 * - xxx.test[a[a].test1[key]]
 * - test.xxx.a["asa"][test1[key]]
 *
 */

var len, str, chr, index$1, expressionPos, expressionEndPos;



function parseModel (val) {
  // Fix https://github.com/vuejs/vue/pull/7730
  // allow v-model="obj.val " (trailing whitespace)
  val = val.trim();
  len = val.length;

  if (val.indexOf('[') < 0 || val.lastIndexOf(']') < len - 1) {
    index$1 = val.lastIndexOf('.');
    if (index$1 > -1) {
      return {
        exp: val.slice(0, index$1),
        key: '"' + val.slice(index$1 + 1) + '"'
      }
    } else {
      return {
        exp: val,
        key: null
      }
    }
  }

  str = val;
  index$1 = expressionPos = expressionEndPos = 0;

  while (!eof()) {
    chr = next();
    /* istanbul ignore if */
    if (isStringStart(chr)) {
      parseString(chr);
    } else if (chr === 0x5B) {
      parseBracket(chr);
    }
  }

  return {
    exp: val.slice(0, expressionPos),
    key: val.slice(expressionPos + 1, expressionEndPos)
  }
}

function next () {
  return str.charCodeAt(++index$1)
}

function eof () {
  return index$1 >= len
}

function isStringStart (chr) {
  return chr === 0x22 || chr === 0x27
}

function parseBracket (chr) {
  var inBracket = 1;
  expressionPos = index$1;
  while (!eof()) {
    chr = next();
    if (isStringStart(chr)) {
      parseString(chr);
      continue
    }
    if (chr === 0x5B) { inBracket++; }
    if (chr === 0x5D) { inBracket--; }
    if (inBracket === 0) {
      expressionEndPos = index$1;
      break
    }
  }
}

function parseString (chr) {
  var stringQuote = chr;
  while (!eof()) {
    chr = next();
    if (chr === stringQuote) {
      break
    }
  }
}

/*  */

var warn$1;

// in some cases, the event used has to be determined at runtime
// so we used some reserved tokens during compile.
var RANGE_TOKEN = '__r';
var CHECKBOX_RADIO_TOKEN = '__c';

function model (
  el,
  dir,
  _warn
) {
  warn$1 = _warn;
  var value = dir.value;
  var modifiers = dir.modifiers;
  var tag = el.tag;
  var type = el.attrsMap.type;

  if (true) {
    // inputs with type="file" are read only and setting the input's
    // value will throw an error.
    if (tag === 'input' && type === 'file') {
      warn$1(
        "<" + (el.tag) + " v-model=\"" + value + "\" type=\"file\">:\n" +
        "File inputs are read only. Use a v-on:change listener instead.",
        el.rawAttrsMap['v-model']
      );
    }
  }

  if (el.component) {
    genComponentModel(el, value, modifiers);
    // component v-model doesn't need extra runtime
    return false
  } else if (tag === 'select') {
    genSelect(el, value, modifiers);
  } else if (tag === 'input' && type === 'checkbox') {
    genCheckboxModel(el, value, modifiers);
  } else if (tag === 'input' && type === 'radio') {
    genRadioModel(el, value, modifiers);
  } else if (tag === 'input' || tag === 'textarea') {
    genDefaultModel(el, value, modifiers);
  } else if (!config.isReservedTag(tag)) {
    genComponentModel(el, value, modifiers);
    // component v-model doesn't need extra runtime
    return false
  } else if (true) {
    warn$1(
      "<" + (el.tag) + " v-model=\"" + value + "\">: " +
      "v-model is not supported on this element type. " +
      'If you are working with contenteditable, it\'s recommended to ' +
      'wrap a library dedicated for that purpose inside a custom component.',
      el.rawAttrsMap['v-model']
    );
  }

  // ensure runtime directive metadata
  return true
}

function genCheckboxModel (
  el,
  value,
  modifiers
) {
  var number = modifiers && modifiers.number;
  var valueBinding = getBindingAttr(el, 'value') || 'null';
  var trueValueBinding = getBindingAttr(el, 'true-value') || 'true';
  var falseValueBinding = getBindingAttr(el, 'false-value') || 'false';
  addProp(el, 'checked',
    "Array.isArray(" + value + ")" +
    "?_i(" + value + "," + valueBinding + ")>-1" + (
      trueValueBinding === 'true'
        ? (":(" + value + ")")
        : (":_q(" + value + "," + trueValueBinding + ")")
    )
  );
  addHandler(el, 'change',
    "var $$a=" + value + "," +
        '$$el=$event.target,' +
        "$$c=$$el.checked?(" + trueValueBinding + "):(" + falseValueBinding + ");" +
    'if(Array.isArray($$a)){' +
      "var $$v=" + (number ? '_n(' + valueBinding + ')' : valueBinding) + "," +
          '$$i=_i($$a,$$v);' +
      "if($$el.checked){$$i<0&&(" + (genAssignmentCode(value, '$$a.concat([$$v])')) + ")}" +
      "else{$$i>-1&&(" + (genAssignmentCode(value, '$$a.slice(0,$$i).concat($$a.slice($$i+1))')) + ")}" +
    "}else{" + (genAssignmentCode(value, '$$c')) + "}",
    null, true
  );
}

function genRadioModel (
  el,
  value,
  modifiers
) {
  var number = modifiers && modifiers.number;
  var valueBinding = getBindingAttr(el, 'value') || 'null';
  valueBinding = number ? ("_n(" + valueBinding + ")") : valueBinding;
  addProp(el, 'checked', ("_q(" + value + "," + valueBinding + ")"));
  addHandler(el, 'change', genAssignmentCode(value, valueBinding), null, true);
}

function genSelect (
  el,
  value,
  modifiers
) {
  var number = modifiers && modifiers.number;
  var selectedVal = "Array.prototype.filter" +
    ".call($event.target.options,function(o){return o.selected})" +
    ".map(function(o){var val = \"_value\" in o ? o._value : o.value;" +
    "return " + (number ? '_n(val)' : 'val') + "})";

  var assignment = '$event.target.multiple ? $$selectedVal : $$selectedVal[0]';
  var code = "var $$selectedVal = " + selectedVal + ";";
  code = code + " " + (genAssignmentCode(value, assignment));
  addHandler(el, 'change', code, null, true);
}

function genDefaultModel (
  el,
  value,
  modifiers
) {
  var type = el.attrsMap.type;

  // warn if v-bind:value conflicts with v-model
  // except for inputs with v-bind:type
  if (true) {
    var value$1 = el.attrsMap['v-bind:value'] || el.attrsMap[':value'];
    var typeBinding = el.attrsMap['v-bind:type'] || el.attrsMap[':type'];
    if (value$1 && !typeBinding) {
      var binding = el.attrsMap['v-bind:value'] ? 'v-bind:value' : ':value';
      warn$1(
        binding + "=\"" + value$1 + "\" conflicts with v-model on the same element " +
        'because the latter already expands to a value binding internally',
        el.rawAttrsMap[binding]
      );
    }
  }

  var ref = modifiers || {};
  var lazy = ref.lazy;
  var number = ref.number;
  var trim = ref.trim;
  var needCompositionGuard = !lazy && type !== 'range';
  var event = lazy
    ? 'change'
    : type === 'range'
      ? RANGE_TOKEN
      : 'input';

  var valueExpression = '$event.target.value';
  if (trim) {
    valueExpression = "$event.target.value.trim()";
  }
  if (number) {
    valueExpression = "_n(" + valueExpression + ")";
  }

  var code = genAssignmentCode(value, valueExpression);
  if (needCompositionGuard) {
    code = "if($event.target.composing)return;" + code;
  }

  addProp(el, 'value', ("(" + value + ")"));
  addHandler(el, event, code, null, true);
  if (trim || number) {
    addHandler(el, 'blur', '$forceUpdate()');
  }
}

/*  */

// normalize v-model event tokens that can only be determined at runtime.
// it's important to place the event as the first in the array because
// the whole point is ensuring the v-model callback gets called before
// user-attached handlers.
function normalizeEvents (on) {
  /* istanbul ignore if */
  if (isDef(on[RANGE_TOKEN])) {
    // IE input[type=range] only supports `change` event
    var event = isIE ? 'change' : 'input';
    on[event] = [].concat(on[RANGE_TOKEN], on[event] || []);
    delete on[RANGE_TOKEN];
  }
  // This was originally intended to fix #4521 but no longer necessary
  // after 2.5. Keeping it for backwards compat with generated code from < 2.4
  /* istanbul ignore if */
  if (isDef(on[CHECKBOX_RADIO_TOKEN])) {
    on.change = [].concat(on[CHECKBOX_RADIO_TOKEN], on.change || []);
    delete on[CHECKBOX_RADIO_TOKEN];
  }
}

var target$1;

function createOnceHandler$1 (event, handler, capture) {
  var _target = target$1; // save current target element in closure
  return function onceHandler () {
    var res = handler.apply(null, arguments);
    if (res !== null) {
      remove$2(event, onceHandler, capture, _target);
    }
  }
}

// #9446: Firefox <= 53 (in particular, ESR 52) has incorrect Event.timeStamp
// implementation and does not fire microtasks in between event propagation, so
// safe to exclude.
var useMicrotaskFix = isUsingMicroTask && !(isFF && Number(isFF[1]) <= 53);

function add$1 (
  name,
  handler,
  capture,
  passive
) {
  // async edge case #6566: inner click event triggers patch, event handler
  // attached to outer element during patch, and triggered again. This
  // happens because browsers fire microtask ticks between event propagation.
  // the solution is simple: we save the timestamp when a handler is attached,
  // and the handler would only fire if the event passed to it was fired
  // AFTER it was attached.
  if (useMicrotaskFix) {
    var attachedTimestamp = currentFlushTimestamp;
    var original = handler;
    handler = original._wrapper = function (e) {
      if (
        // no bubbling, should always fire.
        // this is just a safety net in case event.timeStamp is unreliable in
        // certain weird environments...
        e.target === e.currentTarget ||
        // event is fired after handler attachment
        e.timeStamp >= attachedTimestamp ||
        // bail for environments that have buggy event.timeStamp implementations
        // #9462 iOS 9 bug: event.timeStamp is 0 after history.pushState
        // #9681 QtWebEngine event.timeStamp is negative value
        e.timeStamp <= 0 ||
        // #9448 bail if event is fired in another document in a multi-page
        // electron/nw.js app, since event.timeStamp will be using a different
        // starting reference
        e.target.ownerDocument !== document
      ) {
        return original.apply(this, arguments)
      }
    };
  }
  target$1.addEventListener(
    name,
    handler,
    supportsPassive
      ? { capture: capture, passive: passive }
      : capture
  );
}

function remove$2 (
  name,
  handler,
  capture,
  _target
) {
  (_target || target$1).removeEventListener(
    name,
    handler._wrapper || handler,
    capture
  );
}

function updateDOMListeners (oldVnode, vnode) {
  if (isUndef(oldVnode.data.on) && isUndef(vnode.data.on)) {
    return
  }
  var on = vnode.data.on || {};
  var oldOn = oldVnode.data.on || {};
  target$1 = vnode.elm;
  normalizeEvents(on);
  updateListeners(on, oldOn, add$1, remove$2, createOnceHandler$1, vnode.context);
  target$1 = undefined;
}

var events = {
  create: updateDOMListeners,
  update: updateDOMListeners
};

/*  */

var svgContainer;

function updateDOMProps (oldVnode, vnode) {
  if (isUndef(oldVnode.data.domProps) && isUndef(vnode.data.domProps)) {
    return
  }
  var key, cur;
  var elm = vnode.elm;
  var oldProps = oldVnode.data.domProps || {};
  var props = vnode.data.domProps || {};
  // clone observed objects, as the user probably wants to mutate it
  if (isDef(props.__ob__)) {
    props = vnode.data.domProps = extend({}, props);
  }

  for (key in oldProps) {
    if (!(key in props)) {
      elm[key] = '';
    }
  }

  for (key in props) {
    cur = props[key];
    // ignore children if the node has textContent or innerHTML,
    // as these will throw away existing DOM nodes and cause removal errors
    // on subsequent patches (#3360)
    if (key === 'textContent' || key === 'innerHTML') {
      if (vnode.children) { vnode.children.length = 0; }
      if (cur === oldProps[key]) { continue }
      // #6601 work around Chrome version <= 55 bug where single textNode
      // replaced by innerHTML/textContent retains its parentNode property
      if (elm.childNodes.length === 1) {
        elm.removeChild(elm.childNodes[0]);
      }
    }

    if (key === 'value' && elm.tagName !== 'PROGRESS') {
      // store value as _value as well since
      // non-string values will be stringified
      elm._value = cur;
      // avoid resetting cursor position when value is the same
      var strCur = isUndef(cur) ? '' : String(cur);
      if (shouldUpdateValue(elm, strCur)) {
        elm.value = strCur;
      }
    } else if (key === 'innerHTML' && isSVG(elm.tagName) && isUndef(elm.innerHTML)) {
      // IE doesn't support innerHTML for SVG elements
      svgContainer = svgContainer || document.createElement('div');
      svgContainer.innerHTML = "<svg>" + cur + "</svg>";
      var svg = svgContainer.firstChild;
      while (elm.firstChild) {
        elm.removeChild(elm.firstChild);
      }
      while (svg.firstChild) {
        elm.appendChild(svg.firstChild);
      }
    } else if (
      // skip the update if old and new VDOM state is the same.
      // `value` is handled separately because the DOM value may be temporarily
      // out of sync with VDOM state due to focus, composition and modifiers.
      // This  #4521 by skipping the unnecessary `checked` update.
      cur !== oldProps[key]
    ) {
      // some property updates can throw
      // e.g. `value` on <progress> w/ non-finite value
      try {
        elm[key] = cur;
      } catch (e) {}
    }
  }
}

// check platforms/web/util/attrs.js acceptValue


function shouldUpdateValue (elm, checkVal) {
  return (!elm.composing && (
    elm.tagName === 'OPTION' ||
    isNotInFocusAndDirty(elm, checkVal) ||
    isDirtyWithModifiers(elm, checkVal)
  ))
}

function isNotInFocusAndDirty (elm, checkVal) {
  // return true when textbox (.number and .trim) loses focus and its value is
  // not equal to the updated value
  var notInFocus = true;
  // #6157
  // work around IE bug when accessing document.activeElement in an iframe
  try { notInFocus = document.activeElement !== elm; } catch (e) {}
  return notInFocus && elm.value !== checkVal
}

function isDirtyWithModifiers (elm, newVal) {
  var value = elm.value;
  var modifiers = elm._vModifiers; // injected by v-model runtime
  if (isDef(modifiers)) {
    if (modifiers.number) {
      return toNumber(value) !== toNumber(newVal)
    }
    if (modifiers.trim) {
      return value.trim() !== newVal.trim()
    }
  }
  return value !== newVal
}

var domProps = {
  create: updateDOMProps,
  update: updateDOMProps
};

/*  */

var parseStyleText = cached(function (cssText) {
  var res = {};
  var listDelimiter = /;(?![^(]*\))/g;
  var propertyDelimiter = /:(.+)/;
  cssText.split(listDelimiter).forEach(function (item) {
    if (item) {
      var tmp = item.split(propertyDelimiter);
      tmp.length > 1 && (res[tmp[0].trim()] = tmp[1].trim());
    }
  });
  return res
});

// merge static and dynamic style data on the same vnode
function normalizeStyleData (data) {
  var style = normalizeStyleBinding(data.style);
  // static style is pre-processed into an object during compilation
  // and is always a fresh object, so it's safe to merge into it
  return data.staticStyle
    ? extend(data.staticStyle, style)
    : style
}

// normalize possible array / string values into Object
function normalizeStyleBinding (bindingStyle) {
  if (Array.isArray(bindingStyle)) {
    return toObject(bindingStyle)
  }
  if (typeof bindingStyle === 'string') {
    return parseStyleText(bindingStyle)
  }
  return bindingStyle
}

/**
 * parent component style should be after child's
 * so that parent component's style could override it
 */
function getStyle (vnode, checkChild) {
  var res = {};
  var styleData;

  if (checkChild) {
    var childNode = vnode;
    while (childNode.componentInstance) {
      childNode = childNode.componentInstance._vnode;
      if (
        childNode && childNode.data &&
        (styleData = normalizeStyleData(childNode.data))
      ) {
        extend(res, styleData);
      }
    }
  }

  if ((styleData = normalizeStyleData(vnode.data))) {
    extend(res, styleData);
  }

  var parentNode = vnode;
  while ((parentNode = parentNode.parent)) {
    if (parentNode.data && (styleData = normalizeStyleData(parentNode.data))) {
      extend(res, styleData);
    }
  }
  return res
}

/*  */

var cssVarRE = /^--/;
var importantRE = /\s*!important$/;
var setProp = function (el, name, val) {
  /* istanbul ignore if */
  if (cssVarRE.test(name)) {
    el.style.setProperty(name, val);
  } else if (importantRE.test(val)) {
    el.style.setProperty(hyphenate(name), val.replace(importantRE, ''), 'important');
  } else {
    var normalizedName = normalize(name);
    if (Array.isArray(val)) {
      // Support values array created by autoprefixer, e.g.
      // {display: ["-webkit-box", "-ms-flexbox", "flex"]}
      // Set them one by one, and the browser will only set those it can recognize
      for (var i = 0, len = val.length; i < len; i++) {
        el.style[normalizedName] = val[i];
      }
    } else {
      el.style[normalizedName] = val;
    }
  }
};

var vendorNames = ['Webkit', 'Moz', 'ms'];

var emptyStyle;
var normalize = cached(function (prop) {
  emptyStyle = emptyStyle || document.createElement('div').style;
  prop = camelize(prop);
  if (prop !== 'filter' && (prop in emptyStyle)) {
    return prop
  }
  var capName = prop.charAt(0).toUpperCase() + prop.slice(1);
  for (var i = 0; i < vendorNames.length; i++) {
    var name = vendorNames[i] + capName;
    if (name in emptyStyle) {
      return name
    }
  }
});

function updateStyle (oldVnode, vnode) {
  var data = vnode.data;
  var oldData = oldVnode.data;

  if (isUndef(data.staticStyle) && isUndef(data.style) &&
    isUndef(oldData.staticStyle) && isUndef(oldData.style)
  ) {
    return
  }

  var cur, name;
  var el = vnode.elm;
  var oldStaticStyle = oldData.staticStyle;
  var oldStyleBinding = oldData.normalizedStyle || oldData.style || {};

  // if static style exists, stylebinding already merged into it when doing normalizeStyleData
  var oldStyle = oldStaticStyle || oldStyleBinding;

  var style = normalizeStyleBinding(vnode.data.style) || {};

  // store normalized style under a different key for next diff
  // make sure to clone it if it's reactive, since the user likely wants
  // to mutate it.
  vnode.data.normalizedStyle = isDef(style.__ob__)
    ? extend({}, style)
    : style;

  var newStyle = getStyle(vnode, true);

  for (name in oldStyle) {
    if (isUndef(newStyle[name])) {
      setProp(el, name, '');
    }
  }
  for (name in newStyle) {
    cur = newStyle[name];
    if (cur !== oldStyle[name]) {
      // ie9 setting to null has no effect, must use empty string
      setProp(el, name, cur == null ? '' : cur);
    }
  }
}

var style = {
  create: updateStyle,
  update: updateStyle
};

/*  */

var whitespaceRE = /\s+/;

/**
 * Add class with compatibility for SVG since classList is not supported on
 * SVG elements in IE
 */
function addClass (el, cls) {
  /* istanbul ignore if */
  if (!cls || !(cls = cls.trim())) {
    return
  }

  /* istanbul ignore else */
  if (el.classList) {
    if (cls.indexOf(' ') > -1) {
      cls.split(whitespaceRE).forEach(function (c) { return el.classList.add(c); });
    } else {
      el.classList.add(cls);
    }
  } else {
    var cur = " " + (el.getAttribute('class') || '') + " ";
    if (cur.indexOf(' ' + cls + ' ') < 0) {
      el.setAttribute('class', (cur + cls).trim());
    }
  }
}

/**
 * Remove class with compatibility for SVG since classList is not supported on
 * SVG elements in IE
 */
function removeClass (el, cls) {
  /* istanbul ignore if */
  if (!cls || !(cls = cls.trim())) {
    return
  }

  /* istanbul ignore else */
  if (el.classList) {
    if (cls.indexOf(' ') > -1) {
      cls.split(whitespaceRE).forEach(function (c) { return el.classList.remove(c); });
    } else {
      el.classList.remove(cls);
    }
    if (!el.classList.length) {
      el.removeAttribute('class');
    }
  } else {
    var cur = " " + (el.getAttribute('class') || '') + " ";
    var tar = ' ' + cls + ' ';
    while (cur.indexOf(tar) >= 0) {
      cur = cur.replace(tar, ' ');
    }
    cur = cur.trim();
    if (cur) {
      el.setAttribute('class', cur);
    } else {
      el.removeAttribute('class');
    }
  }
}

/*  */

function resolveTransition (def$$1) {
  if (!def$$1) {
    return
  }
  /* istanbul ignore else */
  if (typeof def$$1 === 'object') {
    var res = {};
    if (def$$1.css !== false) {
      extend(res, autoCssTransition(def$$1.name || 'v'));
    }
    extend(res, def$$1);
    return res
  } else if (typeof def$$1 === 'string') {
    return autoCssTransition(def$$1)
  }
}

var autoCssTransition = cached(function (name) {
  return {
    enterClass: (name + "-enter"),
    enterToClass: (name + "-enter-to"),
    enterActiveClass: (name + "-enter-active"),
    leaveClass: (name + "-leave"),
    leaveToClass: (name + "-leave-to"),
    leaveActiveClass: (name + "-leave-active")
  }
});

var hasTransition = inBrowser && !isIE9;
var TRANSITION = 'transition';
var ANIMATION = 'animation';

// Transition property/event sniffing
var transitionProp = 'transition';
var transitionEndEvent = 'transitionend';
var animationProp = 'animation';
var animationEndEvent = 'animationend';
if (hasTransition) {
  /* istanbul ignore if */
  if (window.ontransitionend === undefined &&
    window.onwebkittransitionend !== undefined
  ) {
    transitionProp = 'WebkitTransition';
    transitionEndEvent = 'webkitTransitionEnd';
  }
  if (window.onanimationend === undefined &&
    window.onwebkitanimationend !== undefined
  ) {
    animationProp = 'WebkitAnimation';
    animationEndEvent = 'webkitAnimationEnd';
  }
}

// binding to window is necessary to make hot reload work in IE in strict mode
var raf = inBrowser
  ? window.requestAnimationFrame
    ? window.requestAnimationFrame.bind(window)
    : setTimeout
  : /* istanbul ignore next */ function (fn) { return fn(); };

function nextFrame (fn) {
  raf(function () {
    raf(fn);
  });
}

function addTransitionClass (el, cls) {
  var transitionClasses = el._transitionClasses || (el._transitionClasses = []);
  if (transitionClasses.indexOf(cls) < 0) {
    transitionClasses.push(cls);
    addClass(el, cls);
  }
}

function removeTransitionClass (el, cls) {
  if (el._transitionClasses) {
    remove(el._transitionClasses, cls);
  }
  removeClass(el, cls);
}

function whenTransitionEnds (
  el,
  expectedType,
  cb
) {
  var ref = getTransitionInfo(el, expectedType);
  var type = ref.type;
  var timeout = ref.timeout;
  var propCount = ref.propCount;
  if (!type) { return cb() }
  var event = type === TRANSITION ? transitionEndEvent : animationEndEvent;
  var ended = 0;
  var end = function () {
    el.removeEventListener(event, onEnd);
    cb();
  };
  var onEnd = function (e) {
    if (e.target === el) {
      if (++ended >= propCount) {
        end();
      }
    }
  };
  setTimeout(function () {
    if (ended < propCount) {
      end();
    }
  }, timeout + 1);
  el.addEventListener(event, onEnd);
}

var transformRE = /\b(transform|all)(,|$)/;

function getTransitionInfo (el, expectedType) {
  var styles = window.getComputedStyle(el);
  // JSDOM may return undefined for transition properties
  var transitionDelays = (styles[transitionProp + 'Delay'] || '').split(', ');
  var transitionDurations = (styles[transitionProp + 'Duration'] || '').split(', ');
  var transitionTimeout = getTimeout(transitionDelays, transitionDurations);
  var animationDelays = (styles[animationProp + 'Delay'] || '').split(', ');
  var animationDurations = (styles[animationProp + 'Duration'] || '').split(', ');
  var animationTimeout = getTimeout(animationDelays, animationDurations);

  var type;
  var timeout = 0;
  var propCount = 0;
  /* istanbul ignore if */
  if (expectedType === TRANSITION) {
    if (transitionTimeout > 0) {
      type = TRANSITION;
      timeout = transitionTimeout;
      propCount = transitionDurations.length;
    }
  } else if (expectedType === ANIMATION) {
    if (animationTimeout > 0) {
      type = ANIMATION;
      timeout = animationTimeout;
      propCount = animationDurations.length;
    }
  } else {
    timeout = Math.max(transitionTimeout, animationTimeout);
    type = timeout > 0
      ? transitionTimeout > animationTimeout
        ? TRANSITION
        : ANIMATION
      : null;
    propCount = type
      ? type === TRANSITION
        ? transitionDurations.length
        : animationDurations.length
      : 0;
  }
  var hasTransform =
    type === TRANSITION &&
    transformRE.test(styles[transitionProp + 'Property']);
  return {
    type: type,
    timeout: timeout,
    propCount: propCount,
    hasTransform: hasTransform
  }
}

function getTimeout (delays, durations) {
  /* istanbul ignore next */
  while (delays.length < durations.length) {
    delays = delays.concat(delays);
  }

  return Math.max.apply(null, durations.map(function (d, i) {
    return toMs(d) + toMs(delays[i])
  }))
}

// Old versions of Chromium (below 61.0.3163.100) formats floating pointer numbers
// in a locale-dependent way, using a comma instead of a dot.
// If comma is not replaced with a dot, the input will be rounded down (i.e. acting
// as a floor function) causing unexpected behaviors
function toMs (s) {
  return Number(s.slice(0, -1).replace(',', '.')) * 1000
}

/*  */

function enter (vnode, toggleDisplay) {
  var el = vnode.elm;

  // call leave callback now
  if (isDef(el._leaveCb)) {
    el._leaveCb.cancelled = true;
    el._leaveCb();
  }

  var data = resolveTransition(vnode.data.transition);
  if (isUndef(data)) {
    return
  }

  /* istanbul ignore if */
  if (isDef(el._enterCb) || el.nodeType !== 1) {
    return
  }

  var css = data.css;
  var type = data.type;
  var enterClass = data.enterClass;
  var enterToClass = data.enterToClass;
  var enterActiveClass = data.enterActiveClass;
  var appearClass = data.appearClass;
  var appearToClass = data.appearToClass;
  var appearActiveClass = data.appearActiveClass;
  var beforeEnter = data.beforeEnter;
  var enter = data.enter;
  var afterEnter = data.afterEnter;
  var enterCancelled = data.enterCancelled;
  var beforeAppear = data.beforeAppear;
  var appear = data.appear;
  var afterAppear = data.afterAppear;
  var appearCancelled = data.appearCancelled;
  var duration = data.duration;

  // activeInstance will always be the <transition> component managing this
  // transition. One edge case to check is when the <transition> is placed
  // as the root node of a child component. In that case we need to check
  // <transition>'s parent for appear check.
  var context = activeInstance;
  var transitionNode = activeInstance.$vnode;
  while (transitionNode && transitionNode.parent) {
    context = transitionNode.context;
    transitionNode = transitionNode.parent;
  }

  var isAppear = !context._isMounted || !vnode.isRootInsert;

  if (isAppear && !appear && appear !== '') {
    return
  }

  var startClass = isAppear && appearClass
    ? appearClass
    : enterClass;
  var activeClass = isAppear && appearActiveClass
    ? appearActiveClass
    : enterActiveClass;
  var toClass = isAppear && appearToClass
    ? appearToClass
    : enterToClass;

  var beforeEnterHook = isAppear
    ? (beforeAppear || beforeEnter)
    : beforeEnter;
  var enterHook = isAppear
    ? (typeof appear === 'function' ? appear : enter)
    : enter;
  var afterEnterHook = isAppear
    ? (afterAppear || afterEnter)
    : afterEnter;
  var enterCancelledHook = isAppear
    ? (appearCancelled || enterCancelled)
    : enterCancelled;

  var explicitEnterDuration = toNumber(
    isObject(duration)
      ? duration.enter
      : duration
  );

  if ( true && explicitEnterDuration != null) {
    checkDuration(explicitEnterDuration, 'enter', vnode);
  }

  var expectsCSS = css !== false && !isIE9;
  var userWantsControl = getHookArgumentsLength(enterHook);

  var cb = el._enterCb = once(function () {
    if (expectsCSS) {
      removeTransitionClass(el, toClass);
      removeTransitionClass(el, activeClass);
    }
    if (cb.cancelled) {
      if (expectsCSS) {
        removeTransitionClass(el, startClass);
      }
      enterCancelledHook && enterCancelledHook(el);
    } else {
      afterEnterHook && afterEnterHook(el);
    }
    el._enterCb = null;
  });

  if (!vnode.data.show) {
    // remove pending leave element on enter by injecting an insert hook
    mergeVNodeHook(vnode, 'insert', function () {
      var parent = el.parentNode;
      var pendingNode = parent && parent._pending && parent._pending[vnode.key];
      if (pendingNode &&
        pendingNode.tag === vnode.tag &&
        pendingNode.elm._leaveCb
      ) {
        pendingNode.elm._leaveCb();
      }
      enterHook && enterHook(el, cb);
    });
  }

  // start enter transition
  beforeEnterHook && beforeEnterHook(el);
  if (expectsCSS) {
    addTransitionClass(el, startClass);
    addTransitionClass(el, activeClass);
    nextFrame(function () {
      removeTransitionClass(el, startClass);
      if (!cb.cancelled) {
        addTransitionClass(el, toClass);
        if (!userWantsControl) {
          if (isValidDuration(explicitEnterDuration)) {
            setTimeout(cb, explicitEnterDuration);
          } else {
            whenTransitionEnds(el, type, cb);
          }
        }
      }
    });
  }

  if (vnode.data.show) {
    toggleDisplay && toggleDisplay();
    enterHook && enterHook(el, cb);
  }

  if (!expectsCSS && !userWantsControl) {
    cb();
  }
}

function leave (vnode, rm) {
  var el = vnode.elm;

  // call enter callback now
  if (isDef(el._enterCb)) {
    el._enterCb.cancelled = true;
    el._enterCb();
  }

  var data = resolveTransition(vnode.data.transition);
  if (isUndef(data) || el.nodeType !== 1) {
    return rm()
  }

  /* istanbul ignore if */
  if (isDef(el._leaveCb)) {
    return
  }

  var css = data.css;
  var type = data.type;
  var leaveClass = data.leaveClass;
  var leaveToClass = data.leaveToClass;
  var leaveActiveClass = data.leaveActiveClass;
  var beforeLeave = data.beforeLeave;
  var leave = data.leave;
  var afterLeave = data.afterLeave;
  var leaveCancelled = data.leaveCancelled;
  var delayLeave = data.delayLeave;
  var duration = data.duration;

  var expectsCSS = css !== false && !isIE9;
  var userWantsControl = getHookArgumentsLength(leave);

  var explicitLeaveDuration = toNumber(
    isObject(duration)
      ? duration.leave
      : duration
  );

  if ( true && isDef(explicitLeaveDuration)) {
    checkDuration(explicitLeaveDuration, 'leave', vnode);
  }

  var cb = el._leaveCb = once(function () {
    if (el.parentNode && el.parentNode._pending) {
      el.parentNode._pending[vnode.key] = null;
    }
    if (expectsCSS) {
      removeTransitionClass(el, leaveToClass);
      removeTransitionClass(el, leaveActiveClass);
    }
    if (cb.cancelled) {
      if (expectsCSS) {
        removeTransitionClass(el, leaveClass);
      }
      leaveCancelled && leaveCancelled(el);
    } else {
      rm();
      afterLeave && afterLeave(el);
    }
    el._leaveCb = null;
  });

  if (delayLeave) {
    delayLeave(performLeave);
  } else {
    performLeave();
  }

  function performLeave () {
    // the delayed leave may have already been cancelled
    if (cb.cancelled) {
      return
    }
    // record leaving element
    if (!vnode.data.show && el.parentNode) {
      (el.parentNode._pending || (el.parentNode._pending = {}))[(vnode.key)] = vnode;
    }
    beforeLeave && beforeLeave(el);
    if (expectsCSS) {
      addTransitionClass(el, leaveClass);
      addTransitionClass(el, leaveActiveClass);
      nextFrame(function () {
        removeTransitionClass(el, leaveClass);
        if (!cb.cancelled) {
          addTransitionClass(el, leaveToClass);
          if (!userWantsControl) {
            if (isValidDuration(explicitLeaveDuration)) {
              setTimeout(cb, explicitLeaveDuration);
            } else {
              whenTransitionEnds(el, type, cb);
            }
          }
        }
      });
    }
    leave && leave(el, cb);
    if (!expectsCSS && !userWantsControl) {
      cb();
    }
  }
}

// only used in dev mode
function checkDuration (val, name, vnode) {
  if (typeof val !== 'number') {
    warn(
      "<transition> explicit " + name + " duration is not a valid number - " +
      "got " + (JSON.stringify(val)) + ".",
      vnode.context
    );
  } else if (isNaN(val)) {
    warn(
      "<transition> explicit " + name + " duration is NaN - " +
      'the duration expression might be incorrect.',
      vnode.context
    );
  }
}

function isValidDuration (val) {
  return typeof val === 'number' && !isNaN(val)
}

/**
 * Normalize a transition hook's argument length. The hook may be:
 * - a merged hook (invoker) with the original in .fns
 * - a wrapped component method (check ._length)
 * - a plain function (.length)
 */
function getHookArgumentsLength (fn) {
  if (isUndef(fn)) {
    return false
  }
  var invokerFns = fn.fns;
  if (isDef(invokerFns)) {
    // invoker
    return getHookArgumentsLength(
      Array.isArray(invokerFns)
        ? invokerFns[0]
        : invokerFns
    )
  } else {
    return (fn._length || fn.length) > 1
  }
}

function _enter (_, vnode) {
  if (vnode.data.show !== true) {
    enter(vnode);
  }
}

var transition = inBrowser ? {
  create: _enter,
  activate: _enter,
  remove: function remove$$1 (vnode, rm) {
    /* istanbul ignore else */
    if (vnode.data.show !== true) {
      leave(vnode, rm);
    } else {
      rm();
    }
  }
} : {};

var platformModules = [
  attrs,
  klass,
  events,
  domProps,
  style,
  transition
];

/*  */

// the directive module should be applied last, after all
// built-in modules have been applied.
var modules = platformModules.concat(baseModules);

var patch = createPatchFunction({ nodeOps: nodeOps, modules: modules });

/**
 * Not type checking this file because flow doesn't like attaching
 * properties to Elements.
 */

/* istanbul ignore if */
if (isIE9) {
  // http://www.matts411.com/post/internet-explorer-9-oninput/
  document.addEventListener('selectionchange', function () {
    var el = document.activeElement;
    if (el && el.vmodel) {
      trigger(el, 'input');
    }
  });
}

var directive = {
  inserted: function inserted (el, binding, vnode, oldVnode) {
    if (vnode.tag === 'select') {
      // #6903
      if (oldVnode.elm && !oldVnode.elm._vOptions) {
        mergeVNodeHook(vnode, 'postpatch', function () {
          directive.componentUpdated(el, binding, vnode);
        });
      } else {
        setSelected(el, binding, vnode.context);
      }
      el._vOptions = [].map.call(el.options, getValue);
    } else if (vnode.tag === 'textarea' || isTextInputType(el.type)) {
      el._vModifiers = binding.modifiers;
      if (!binding.modifiers.lazy) {
        el.addEventListener('compositionstart', onCompositionStart);
        el.addEventListener('compositionend', onCompositionEnd);
        // Safari < 10.2 & UIWebView doesn't fire compositionend when
        // switching focus before confirming composition choice
        // this also fixes the issue where some browsers e.g. iOS Chrome
        // fires "change" instead of "input" on autocomplete.
        el.addEventListener('change', onCompositionEnd);
        /* istanbul ignore if */
        if (isIE9) {
          el.vmodel = true;
        }
      }
    }
  },

  componentUpdated: function componentUpdated (el, binding, vnode) {
    if (vnode.tag === 'select') {
      setSelected(el, binding, vnode.context);
      // in case the options rendered by v-for have changed,
      // it's possible that the value is out-of-sync with the rendered options.
      // detect such cases and filter out values that no longer has a matching
      // option in the DOM.
      var prevOptions = el._vOptions;
      var curOptions = el._vOptions = [].map.call(el.options, getValue);
      if (curOptions.some(function (o, i) { return !looseEqual(o, prevOptions[i]); })) {
        // trigger change event if
        // no matching option found for at least one value
        var needReset = el.multiple
          ? binding.value.some(function (v) { return hasNoMatchingOption(v, curOptions); })
          : binding.value !== binding.oldValue && hasNoMatchingOption(binding.value, curOptions);
        if (needReset) {
          trigger(el, 'change');
        }
      }
    }
  }
};

function setSelected (el, binding, vm) {
  actuallySetSelected(el, binding, vm);
  /* istanbul ignore if */
  if (isIE || isEdge) {
    setTimeout(function () {
      actuallySetSelected(el, binding, vm);
    }, 0);
  }
}

function actuallySetSelected (el, binding, vm) {
  var value = binding.value;
  var isMultiple = el.multiple;
  if (isMultiple && !Array.isArray(value)) {
     true && warn(
      "<select multiple v-model=\"" + (binding.expression) + "\"> " +
      "expects an Array value for its binding, but got " + (Object.prototype.toString.call(value).slice(8, -1)),
      vm
    );
    return
  }
  var selected, option;
  for (var i = 0, l = el.options.length; i < l; i++) {
    option = el.options[i];
    if (isMultiple) {
      selected = looseIndexOf(value, getValue(option)) > -1;
      if (option.selected !== selected) {
        option.selected = selected;
      }
    } else {
      if (looseEqual(getValue(option), value)) {
        if (el.selectedIndex !== i) {
          el.selectedIndex = i;
        }
        return
      }
    }
  }
  if (!isMultiple) {
    el.selectedIndex = -1;
  }
}

function hasNoMatchingOption (value, options) {
  return options.every(function (o) { return !looseEqual(o, value); })
}

function getValue (option) {
  return '_value' in option
    ? option._value
    : option.value
}

function onCompositionStart (e) {
  e.target.composing = true;
}

function onCompositionEnd (e) {
  // prevent triggering an input event for no reason
  if (!e.target.composing) { return }
  e.target.composing = false;
  trigger(e.target, 'input');
}

function trigger (el, type) {
  var e = document.createEvent('HTMLEvents');
  e.initEvent(type, true, true);
  el.dispatchEvent(e);
}

/*  */

// recursively search for possible transition defined inside the component root
function locateNode (vnode) {
  return vnode.componentInstance && (!vnode.data || !vnode.data.transition)
    ? locateNode(vnode.componentInstance._vnode)
    : vnode
}

var show = {
  bind: function bind (el, ref, vnode) {
    var value = ref.value;

    vnode = locateNode(vnode);
    var transition$$1 = vnode.data && vnode.data.transition;
    var originalDisplay = el.__vOriginalDisplay =
      el.style.display === 'none' ? '' : el.style.display;
    if (value && transition$$1) {
      vnode.data.show = true;
      enter(vnode, function () {
        el.style.display = originalDisplay;
      });
    } else {
      el.style.display = value ? originalDisplay : 'none';
    }
  },

  update: function update (el, ref, vnode) {
    var value = ref.value;
    var oldValue = ref.oldValue;

    /* istanbul ignore if */
    if (!value === !oldValue) { return }
    vnode = locateNode(vnode);
    var transition$$1 = vnode.data && vnode.data.transition;
    if (transition$$1) {
      vnode.data.show = true;
      if (value) {
        enter(vnode, function () {
          el.style.display = el.__vOriginalDisplay;
        });
      } else {
        leave(vnode, function () {
          el.style.display = 'none';
        });
      }
    } else {
      el.style.display = value ? el.__vOriginalDisplay : 'none';
    }
  },

  unbind: function unbind (
    el,
    binding,
    vnode,
    oldVnode,
    isDestroy
  ) {
    if (!isDestroy) {
      el.style.display = el.__vOriginalDisplay;
    }
  }
};

var platformDirectives = {
  model: directive,
  show: show
};

/*  */

var transitionProps = {
  name: String,
  appear: Boolean,
  css: Boolean,
  mode: String,
  type: String,
  enterClass: String,
  leaveClass: String,
  enterToClass: String,
  leaveToClass: String,
  enterActiveClass: String,
  leaveActiveClass: String,
  appearClass: String,
  appearActiveClass: String,
  appearToClass: String,
  duration: [Number, String, Object]
};

// in case the child is also an abstract component, e.g. <keep-alive>
// we want to recursively retrieve the real component to be rendered
function getRealChild (vnode) {
  var compOptions = vnode && vnode.componentOptions;
  if (compOptions && compOptions.Ctor.options.abstract) {
    return getRealChild(getFirstComponentChild(compOptions.children))
  } else {
    return vnode
  }
}

function extractTransitionData (comp) {
  var data = {};
  var options = comp.$options;
  // props
  for (var key in options.propsData) {
    data[key] = comp[key];
  }
  // events.
  // extract listeners and pass them directly to the transition methods
  var listeners = options._parentListeners;
  for (var key$1 in listeners) {
    data[camelize(key$1)] = listeners[key$1];
  }
  return data
}

function placeholder (h, rawChild) {
  if (/\d-keep-alive$/.test(rawChild.tag)) {
    return h('keep-alive', {
      props: rawChild.componentOptions.propsData
    })
  }
}

function hasParentTransition (vnode) {
  while ((vnode = vnode.parent)) {
    if (vnode.data.transition) {
      return true
    }
  }
}

function isSameChild (child, oldChild) {
  return oldChild.key === child.key && oldChild.tag === child.tag
}

var isNotTextNode = function (c) { return c.tag || isAsyncPlaceholder(c); };

var isVShowDirective = function (d) { return d.name === 'show'; };

var Transition = {
  name: 'transition',
  props: transitionProps,
  abstract: true,

  render: function render (h) {
    var this$1 = this;

    var children = this.$slots.default;
    if (!children) {
      return
    }

    // filter out text nodes (possible whitespaces)
    children = children.filter(isNotTextNode);
    /* istanbul ignore if */
    if (!children.length) {
      return
    }

    // warn multiple elements
    if ( true && children.length > 1) {
      warn(
        '<transition> can only be used on a single element. Use ' +
        '<transition-group> for lists.',
        this.$parent
      );
    }

    var mode = this.mode;

    // warn invalid mode
    if ( true &&
      mode && mode !== 'in-out' && mode !== 'out-in'
    ) {
      warn(
        'invalid <transition> mode: ' + mode,
        this.$parent
      );
    }

    var rawChild = children[0];

    // if this is a component root node and the component's
    // parent container node also has transition, skip.
    if (hasParentTransition(this.$vnode)) {
      return rawChild
    }

    // apply transition data to child
    // use getRealChild() to ignore abstract components e.g. keep-alive
    var child = getRealChild(rawChild);
    /* istanbul ignore if */
    if (!child) {
      return rawChild
    }

    if (this._leaving) {
      return placeholder(h, rawChild)
    }

    // ensure a key that is unique to the vnode type and to this transition
    // component instance. This key will be used to remove pending leaving nodes
    // during entering.
    var id = "__transition-" + (this._uid) + "-";
    child.key = child.key == null
      ? child.isComment
        ? id + 'comment'
        : id + child.tag
      : isPrimitive(child.key)
        ? (String(child.key).indexOf(id) === 0 ? child.key : id + child.key)
        : child.key;

    var data = (child.data || (child.data = {})).transition = extractTransitionData(this);
    var oldRawChild = this._vnode;
    var oldChild = getRealChild(oldRawChild);

    // mark v-show
    // so that the transition module can hand over the control to the directive
    if (child.data.directives && child.data.directives.some(isVShowDirective)) {
      child.data.show = true;
    }

    if (
      oldChild &&
      oldChild.data &&
      !isSameChild(child, oldChild) &&
      !isAsyncPlaceholder(oldChild) &&
      // #6687 component root is a comment node
      !(oldChild.componentInstance && oldChild.componentInstance._vnode.isComment)
    ) {
      // replace old child transition data with fresh one
      // important for dynamic transitions!
      var oldData = oldChild.data.transition = extend({}, data);
      // handle transition mode
      if (mode === 'out-in') {
        // return placeholder node and queue update when leave finishes
        this._leaving = true;
        mergeVNodeHook(oldData, 'afterLeave', function () {
          this$1._leaving = false;
          this$1.$forceUpdate();
        });
        return placeholder(h, rawChild)
      } else if (mode === 'in-out') {
        if (isAsyncPlaceholder(child)) {
          return oldRawChild
        }
        var delayedLeave;
        var performLeave = function () { delayedLeave(); };
        mergeVNodeHook(data, 'afterEnter', performLeave);
        mergeVNodeHook(data, 'enterCancelled', performLeave);
        mergeVNodeHook(oldData, 'delayLeave', function (leave) { delayedLeave = leave; });
      }
    }

    return rawChild
  }
};

/*  */

var props = extend({
  tag: String,
  moveClass: String
}, transitionProps);

delete props.mode;

var TransitionGroup = {
  props: props,

  beforeMount: function beforeMount () {
    var this$1 = this;

    var update = this._update;
    this._update = function (vnode, hydrating) {
      var restoreActiveInstance = setActiveInstance(this$1);
      // force removing pass
      this$1.__patch__(
        this$1._vnode,
        this$1.kept,
        false, // hydrating
        true // removeOnly (!important, avoids unnecessary moves)
      );
      this$1._vnode = this$1.kept;
      restoreActiveInstance();
      update.call(this$1, vnode, hydrating);
    };
  },

  render: function render (h) {
    var tag = this.tag || this.$vnode.data.tag || 'span';
    var map = Object.create(null);
    var prevChildren = this.prevChildren = this.children;
    var rawChildren = this.$slots.default || [];
    var children = this.children = [];
    var transitionData = extractTransitionData(this);

    for (var i = 0; i < rawChildren.length; i++) {
      var c = rawChildren[i];
      if (c.tag) {
        if (c.key != null && String(c.key).indexOf('__vlist') !== 0) {
          children.push(c);
          map[c.key] = c
          ;(c.data || (c.data = {})).transition = transitionData;
        } else if (true) {
          var opts = c.componentOptions;
          var name = opts ? (opts.Ctor.options.name || opts.tag || '') : c.tag;
          warn(("<transition-group> children must be keyed: <" + name + ">"));
        }
      }
    }

    if (prevChildren) {
      var kept = [];
      var removed = [];
      for (var i$1 = 0; i$1 < prevChildren.length; i$1++) {
        var c$1 = prevChildren[i$1];
        c$1.data.transition = transitionData;
        c$1.data.pos = c$1.elm.getBoundingClientRect();
        if (map[c$1.key]) {
          kept.push(c$1);
        } else {
          removed.push(c$1);
        }
      }
      this.kept = h(tag, null, kept);
      this.removed = removed;
    }

    return h(tag, null, children)
  },

  updated: function updated () {
    var children = this.prevChildren;
    var moveClass = this.moveClass || ((this.name || 'v') + '-move');
    if (!children.length || !this.hasMove(children[0].elm, moveClass)) {
      return
    }

    // we divide the work into three loops to avoid mixing DOM reads and writes
    // in each iteration - which helps prevent layout thrashing.
    children.forEach(callPendingCbs);
    children.forEach(recordPosition);
    children.forEach(applyTranslation);

    // force reflow to put everything in position
    // assign to this to avoid being removed in tree-shaking
    // $flow-disable-line
    this._reflow = document.body.offsetHeight;

    children.forEach(function (c) {
      if (c.data.moved) {
        var el = c.elm;
        var s = el.style;
        addTransitionClass(el, moveClass);
        s.transform = s.WebkitTransform = s.transitionDuration = '';
        el.addEventListener(transitionEndEvent, el._moveCb = function cb (e) {
          if (e && e.target !== el) {
            return
          }
          if (!e || /transform$/.test(e.propertyName)) {
            el.removeEventListener(transitionEndEvent, cb);
            el._moveCb = null;
            removeTransitionClass(el, moveClass);
          }
        });
      }
    });
  },

  methods: {
    hasMove: function hasMove (el, moveClass) {
      /* istanbul ignore if */
      if (!hasTransition) {
        return false
      }
      /* istanbul ignore if */
      if (this._hasMove) {
        return this._hasMove
      }
      // Detect whether an element with the move class applied has
      // CSS transitions. Since the element may be inside an entering
      // transition at this very moment, we make a clone of it and remove
      // all other transition classes applied to ensure only the move class
      // is applied.
      var clone = el.cloneNode();
      if (el._transitionClasses) {
        el._transitionClasses.forEach(function (cls) { removeClass(clone, cls); });
      }
      addClass(clone, moveClass);
      clone.style.display = 'none';
      this.$el.appendChild(clone);
      var info = getTransitionInfo(clone);
      this.$el.removeChild(clone);
      return (this._hasMove = info.hasTransform)
    }
  }
};

function callPendingCbs (c) {
  /* istanbul ignore if */
  if (c.elm._moveCb) {
    c.elm._moveCb();
  }
  /* istanbul ignore if */
  if (c.elm._enterCb) {
    c.elm._enterCb();
  }
}

function recordPosition (c) {
  c.data.newPos = c.elm.getBoundingClientRect();
}

function applyTranslation (c) {
  var oldPos = c.data.pos;
  var newPos = c.data.newPos;
  var dx = oldPos.left - newPos.left;
  var dy = oldPos.top - newPos.top;
  if (dx || dy) {
    c.data.moved = true;
    var s = c.elm.style;
    s.transform = s.WebkitTransform = "translate(" + dx + "px," + dy + "px)";
    s.transitionDuration = '0s';
  }
}

var platformComponents = {
  Transition: Transition,
  TransitionGroup: TransitionGroup
};

/*  */

// install platform specific utils
Vue.config.mustUseProp = mustUseProp;
Vue.config.isReservedTag = isReservedTag;
Vue.config.isReservedAttr = isReservedAttr;
Vue.config.getTagNamespace = getTagNamespace;
Vue.config.isUnknownElement = isUnknownElement;

// install platform runtime directives & components
extend(Vue.options.directives, platformDirectives);
extend(Vue.options.components, platformComponents);

// install platform patch function
Vue.prototype.__patch__ = inBrowser ? patch : noop;

// public mount method
Vue.prototype.$mount = function (
  el,
  hydrating
) {
  el = el && inBrowser ? query(el) : undefined;
  return mountComponent(this, el, hydrating)
};

// devtools global hook
/* istanbul ignore next */
if (inBrowser) {
  setTimeout(function () {
    if (config.devtools) {
      if (devtools) {
        devtools.emit('init', Vue);
      } else if (
        true
      ) {
        console[console.info ? 'info' : 'log'](
          'Download the Vue Devtools extension for a better development experience:\n' +
          'https://github.com/vuejs/vue-devtools'
        );
      }
    }
    if ( true &&
      config.productionTip !== false &&
      typeof console !== 'undefined'
    ) {
      console[console.info ? 'info' : 'log'](
        "You are running Vue in development mode.\n" +
        "Make sure to turn on production mode when deploying for production.\n" +
        "See more tips at https://vuejs.org/guide/deployment.html"
      );
    }
  }, 0);
}

/*  */

var defaultTagRE = /\{\{((?:.|\r?\n)+?)\}\}/g;
var regexEscapeRE = /[-.*+?^${}()|[\]\/\\]/g;

var buildRegex = cached(function (delimiters) {
  var open = delimiters[0].replace(regexEscapeRE, '\\$&');
  var close = delimiters[1].replace(regexEscapeRE, '\\$&');
  return new RegExp(open + '((?:.|\\n)+?)' + close, 'g')
});



function parseText (
  text,
  delimiters
) {
  var tagRE = delimiters ? buildRegex(delimiters) : defaultTagRE;
  if (!tagRE.test(text)) {
    return
  }
  var tokens = [];
  var rawTokens = [];
  var lastIndex = tagRE.lastIndex = 0;
  var match, index, tokenValue;
  while ((match = tagRE.exec(text))) {
    index = match.index;
    // push text token
    if (index > lastIndex) {
      rawTokens.push(tokenValue = text.slice(lastIndex, index));
      tokens.push(JSON.stringify(tokenValue));
    }
    // tag token
    var exp = parseFilters(match[1].trim());
    tokens.push(("_s(" + exp + ")"));
    rawTokens.push({ '@binding': exp });
    lastIndex = index + match[0].length;
  }
  if (lastIndex < text.length) {
    rawTokens.push(tokenValue = text.slice(lastIndex));
    tokens.push(JSON.stringify(tokenValue));
  }
  return {
    expression: tokens.join('+'),
    tokens: rawTokens
  }
}

/*  */

function transformNode (el, options) {
  var warn = options.warn || baseWarn;
  var staticClass = getAndRemoveAttr(el, 'class');
  if ( true && staticClass) {
    var res = parseText(staticClass, options.delimiters);
    if (res) {
      warn(
        "class=\"" + staticClass + "\": " +
        'Interpolation inside attributes has been removed. ' +
        'Use v-bind or the colon shorthand instead. For example, ' +
        'instead of <div class="{{ val }}">, use <div :class="val">.',
        el.rawAttrsMap['class']
      );
    }
  }
  if (staticClass) {
    el.staticClass = JSON.stringify(staticClass);
  }
  var classBinding = getBindingAttr(el, 'class', false /* getStatic */);
  if (classBinding) {
    el.classBinding = classBinding;
  }
}

function genData (el) {
  var data = '';
  if (el.staticClass) {
    data += "staticClass:" + (el.staticClass) + ",";
  }
  if (el.classBinding) {
    data += "class:" + (el.classBinding) + ",";
  }
  return data
}

var klass$1 = {
  staticKeys: ['staticClass'],
  transformNode: transformNode,
  genData: genData
};

/*  */

function transformNode$1 (el, options) {
  var warn = options.warn || baseWarn;
  var staticStyle = getAndRemoveAttr(el, 'style');
  if (staticStyle) {
    /* istanbul ignore if */
    if (true) {
      var res = parseText(staticStyle, options.delimiters);
      if (res) {
        warn(
          "style=\"" + staticStyle + "\": " +
          'Interpolation inside attributes has been removed. ' +
          'Use v-bind or the colon shorthand instead. For example, ' +
          'instead of <div style="{{ val }}">, use <div :style="val">.',
          el.rawAttrsMap['style']
        );
      }
    }
    el.staticStyle = JSON.stringify(parseStyleText(staticStyle));
  }

  var styleBinding = getBindingAttr(el, 'style', false /* getStatic */);
  if (styleBinding) {
    el.styleBinding = styleBinding;
  }
}

function genData$1 (el) {
  var data = '';
  if (el.staticStyle) {
    data += "staticStyle:" + (el.staticStyle) + ",";
  }
  if (el.styleBinding) {
    data += "style:(" + (el.styleBinding) + "),";
  }
  return data
}

var style$1 = {
  staticKeys: ['staticStyle'],
  transformNode: transformNode$1,
  genData: genData$1
};

/*  */

var decoder;

var he = {
  decode: function decode (html) {
    decoder = decoder || document.createElement('div');
    decoder.innerHTML = html;
    return decoder.textContent
  }
};

/*  */

var isUnaryTag = makeMap(
  'area,base,br,col,embed,frame,hr,img,input,isindex,keygen,' +
  'link,meta,param,source,track,wbr'
);

// Elements that you can, intentionally, leave open
// (and which close themselves)
var canBeLeftOpenTag = makeMap(
  'colgroup,dd,dt,li,options,p,td,tfoot,th,thead,tr,source'
);

// HTML5 tags https://html.spec.whatwg.org/multipage/indices.html#elements-3
// Phrasing Content https://html.spec.whatwg.org/multipage/dom.html#phrasing-content
var isNonPhrasingTag = makeMap(
  'address,article,aside,base,blockquote,body,caption,col,colgroup,dd,' +
  'details,dialog,div,dl,dt,fieldset,figcaption,figure,footer,form,' +
  'h1,h2,h3,h4,h5,h6,head,header,hgroup,hr,html,legend,li,menuitem,meta,' +
  'optgroup,option,param,rp,rt,source,style,summary,tbody,td,tfoot,th,thead,' +
  'title,tr,track'
);

/**
 * Not type-checking this file because it's mostly vendor code.
 */

// Regular Expressions for parsing tags and attributes
var attribute = /^\s*([^\s"'<>\/=]+)(?:\s*(=)\s*(?:"([^"]*)"+|'([^']*)'+|([^\s"'=<>`]+)))?/;
var dynamicArgAttribute = /^\s*((?:v-[\w-]+:|@|:|#)\[[^=]+?\][^\s"'<>\/=]*)(?:\s*(=)\s*(?:"([^"]*)"+|'([^']*)'+|([^\s"'=<>`]+)))?/;
var ncname = "[a-zA-Z_][\\-\\.0-9_a-zA-Z" + (unicodeRegExp.source) + "]*";
var qnameCapture = "((?:" + ncname + "\\:)?" + ncname + ")";
var startTagOpen = new RegExp(("^<" + qnameCapture));
var startTagClose = /^\s*(\/?)>/;
var endTag = new RegExp(("^<\\/" + qnameCapture + "[^>]*>"));
var doctype = /^<!DOCTYPE [^>]+>/i;
// #7298: escape - to avoid being passed as HTML comment when inlined in page
var comment = /^<!\--/;
var conditionalComment = /^<!\[/;

// Special Elements (can contain anything)
var isPlainTextElement = makeMap('script,style,textarea', true);
var reCache = {};

var decodingMap = {
  '&lt;': '<',
  '&gt;': '>',
  '&quot;': '"',
  '&amp;': '&',
  '&#10;': '\n',
  '&#9;': '\t',
  '&#39;': "'"
};
var encodedAttr = /&(?:lt|gt|quot|amp|#39);/g;
var encodedAttrWithNewLines = /&(?:lt|gt|quot|amp|#39|#10|#9);/g;

// #5992
var isIgnoreNewlineTag = makeMap('pre,textarea', true);
var shouldIgnoreFirstNewline = function (tag, html) { return tag && isIgnoreNewlineTag(tag) && html[0] === '\n'; };

function decodeAttr (value, shouldDecodeNewlines) {
  var re = shouldDecodeNewlines ? encodedAttrWithNewLines : encodedAttr;
  return value.replace(re, function (match) { return decodingMap[match]; })
}

function parseHTML (html, options) {
  var stack = [];
  var expectHTML = options.expectHTML;
  var isUnaryTag$$1 = options.isUnaryTag || no;
  var canBeLeftOpenTag$$1 = options.canBeLeftOpenTag || no;
  var index = 0;
  var last, lastTag;
  while (html) {
    last = html;
    // Make sure we're not in a plaintext content element like script/style
    if (!lastTag || !isPlainTextElement(lastTag)) {
      var textEnd = html.indexOf('<');
      if (textEnd === 0) {
        // Comment:
        if (comment.test(html)) {
          var commentEnd = html.indexOf('-->');

          if (commentEnd >= 0) {
            if (options.shouldKeepComment) {
              options.comment(html.substring(4, commentEnd), index, index + commentEnd + 3);
            }
            advance(commentEnd + 3);
            continue
          }
        }

        // http://en.wikipedia.org/wiki/Conditional_comment#Downlevel-revealed_conditional_comment
        if (conditionalComment.test(html)) {
          var conditionalEnd = html.indexOf(']>');

          if (conditionalEnd >= 0) {
            advance(conditionalEnd + 2);
            continue
          }
        }

        // Doctype:
        var doctypeMatch = html.match(doctype);
        if (doctypeMatch) {
          advance(doctypeMatch[0].length);
          continue
        }

        // End tag:
        var endTagMatch = html.match(endTag);
        if (endTagMatch) {
          var curIndex = index;
          advance(endTagMatch[0].length);
          parseEndTag(endTagMatch[1], curIndex, index);
          continue
        }

        // Start tag:
        var startTagMatch = parseStartTag();
        if (startTagMatch) {
          handleStartTag(startTagMatch);
          if (shouldIgnoreFirstNewline(startTagMatch.tagName, html)) {
            advance(1);
          }
          continue
        }
      }

      var text = (void 0), rest = (void 0), next = (void 0);
      if (textEnd >= 0) {
        rest = html.slice(textEnd);
        while (
          !endTag.test(rest) &&
          !startTagOpen.test(rest) &&
          !comment.test(rest) &&
          !conditionalComment.test(rest)
        ) {
          // < in plain text, be forgiving and treat it as text
          next = rest.indexOf('<', 1);
          if (next < 0) { break }
          textEnd += next;
          rest = html.slice(textEnd);
        }
        text = html.substring(0, textEnd);
      }

      if (textEnd < 0) {
        text = html;
      }

      if (text) {
        advance(text.length);
      }

      if (options.chars && text) {
        options.chars(text, index - text.length, index);
      }
    } else {
      var endTagLength = 0;
      var stackedTag = lastTag.toLowerCase();
      var reStackedTag = reCache[stackedTag] || (reCache[stackedTag] = new RegExp('([\\s\\S]*?)(</' + stackedTag + '[^>]*>)', 'i'));
      var rest$1 = html.replace(reStackedTag, function (all, text, endTag) {
        endTagLength = endTag.length;
        if (!isPlainTextElement(stackedTag) && stackedTag !== 'noscript') {
          text = text
            .replace(/<!\--([\s\S]*?)-->/g, '$1') // #7298
            .replace(/<!\[CDATA\[([\s\S]*?)]]>/g, '$1');
        }
        if (shouldIgnoreFirstNewline(stackedTag, text)) {
          text = text.slice(1);
        }
        if (options.chars) {
          options.chars(text);
        }
        return ''
      });
      index += html.length - rest$1.length;
      html = rest$1;
      parseEndTag(stackedTag, index - endTagLength, index);
    }

    if (html === last) {
      options.chars && options.chars(html);
      if ( true && !stack.length && options.warn) {
        options.warn(("Mal-formatted tag at end of template: \"" + html + "\""), { start: index + html.length });
      }
      break
    }
  }

  // Clean up any remaining tags
  parseEndTag();

  function advance (n) {
    index += n;
    html = html.substring(n);
  }

  function parseStartTag () {
    var start = html.match(startTagOpen);
    if (start) {
      var match = {
        tagName: start[1],
        attrs: [],
        start: index
      };
      advance(start[0].length);
      var end, attr;
      while (!(end = html.match(startTagClose)) && (attr = html.match(dynamicArgAttribute) || html.match(attribute))) {
        attr.start = index;
        advance(attr[0].length);
        attr.end = index;
        match.attrs.push(attr);
      }
      if (end) {
        match.unarySlash = end[1];
        advance(end[0].length);
        match.end = index;
        return match
      }
    }
  }

  function handleStartTag (match) {
    var tagName = match.tagName;
    var unarySlash = match.unarySlash;

    if (expectHTML) {
      if (lastTag === 'p' && isNonPhrasingTag(tagName)) {
        parseEndTag(lastTag);
      }
      if (canBeLeftOpenTag$$1(tagName) && lastTag === tagName) {
        parseEndTag(tagName);
      }
    }

    var unary = isUnaryTag$$1(tagName) || !!unarySlash;

    var l = match.attrs.length;
    var attrs = new Array(l);
    for (var i = 0; i < l; i++) {
      var args = match.attrs[i];
      var value = args[3] || args[4] || args[5] || '';
      var shouldDecodeNewlines = tagName === 'a' && args[1] === 'href'
        ? options.shouldDecodeNewlinesForHref
        : options.shouldDecodeNewlines;
      attrs[i] = {
        name: args[1],
        value: decodeAttr(value, shouldDecodeNewlines)
      };
      if ( true && options.outputSourceRange) {
        attrs[i].start = args.start + args[0].match(/^\s*/).length;
        attrs[i].end = args.end;
      }
    }

    if (!unary) {
      stack.push({ tag: tagName, lowerCasedTag: tagName.toLowerCase(), attrs: attrs, start: match.start, end: match.end });
      lastTag = tagName;
    }

    if (options.start) {
      options.start(tagName, attrs, unary, match.start, match.end);
    }
  }

  function parseEndTag (tagName, start, end) {
    var pos, lowerCasedTagName;
    if (start == null) { start = index; }
    if (end == null) { end = index; }

    // Find the closest opened tag of the same type
    if (tagName) {
      lowerCasedTagName = tagName.toLowerCase();
      for (pos = stack.length - 1; pos >= 0; pos--) {
        if (stack[pos].lowerCasedTag === lowerCasedTagName) {
          break
        }
      }
    } else {
      // If no tag name is provided, clean shop
      pos = 0;
    }

    if (pos >= 0) {
      // Close all the open elements, up the stack
      for (var i = stack.length - 1; i >= pos; i--) {
        if ( true &&
          (i > pos || !tagName) &&
          options.warn
        ) {
          options.warn(
            ("tag <" + (stack[i].tag) + "> has no matching end tag."),
            { start: stack[i].start, end: stack[i].end }
          );
        }
        if (options.end) {
          options.end(stack[i].tag, start, end);
        }
      }

      // Remove the open elements from the stack
      stack.length = pos;
      lastTag = pos && stack[pos - 1].tag;
    } else if (lowerCasedTagName === 'br') {
      if (options.start) {
        options.start(tagName, [], true, start, end);
      }
    } else if (lowerCasedTagName === 'p') {
      if (options.start) {
        options.start(tagName, [], false, start, end);
      }
      if (options.end) {
        options.end(tagName, start, end);
      }
    }
  }
}

/*  */

var onRE = /^@|^v-on:/;
var dirRE = /^v-|^@|^:|^#/;
var forAliasRE = /([\s\S]*?)\s+(?:in|of)\s+([\s\S]*)/;
var forIteratorRE = /,([^,\}\]]*)(?:,([^,\}\]]*))?$/;
var stripParensRE = /^\(|\)$/g;
var dynamicArgRE = /^\[.*\]$/;

var argRE = /:(.*)$/;
var bindRE = /^:|^\.|^v-bind:/;
var modifierRE = /\.[^.\]]+(?=[^\]]*$)/g;

var slotRE = /^v-slot(:|$)|^#/;

var lineBreakRE = /[\r\n]/;
var whitespaceRE$1 = /[ \f\t\r\n]+/g;

var invalidAttributeRE = /[\s"'<>\/=]/;

var decodeHTMLCached = cached(he.decode);

var emptySlotScopeToken = "_empty_";

// configurable state
var warn$2;
var delimiters;
var transforms;
var preTransforms;
var postTransforms;
var platformIsPreTag;
var platformMustUseProp;
var platformGetTagNamespace;
var maybeComponent;

function createASTElement (
  tag,
  attrs,
  parent
) {
  return {
    type: 1,
    tag: tag,
    attrsList: attrs,
    attrsMap: makeAttrsMap(attrs),
    rawAttrsMap: {},
    parent: parent,
    children: []
  }
}

/**
 * Convert HTML string to AST.
 */
function parse (
  template,
  options
) {
  warn$2 = options.warn || baseWarn;

  platformIsPreTag = options.isPreTag || no;
  platformMustUseProp = options.mustUseProp || no;
  platformGetTagNamespace = options.getTagNamespace || no;
  var isReservedTag = options.isReservedTag || no;
  maybeComponent = function (el) { return !!(
    el.component ||
    el.attrsMap[':is'] ||
    el.attrsMap['v-bind:is'] ||
    !(el.attrsMap.is ? isReservedTag(el.attrsMap.is) : isReservedTag(el.tag))
  ); };
  transforms = pluckModuleFunction(options.modules, 'transformNode');
  preTransforms = pluckModuleFunction(options.modules, 'preTransformNode');
  postTransforms = pluckModuleFunction(options.modules, 'postTransformNode');

  delimiters = options.delimiters;

  var stack = [];
  var preserveWhitespace = options.preserveWhitespace !== false;
  var whitespaceOption = options.whitespace;
  var root;
  var currentParent;
  var inVPre = false;
  var inPre = false;
  var warned = false;

  function warnOnce (msg, range) {
    if (!warned) {
      warned = true;
      warn$2(msg, range);
    }
  }

  function closeElement (element) {
    trimEndingWhitespace(element);
    if (!inVPre && !element.processed) {
      element = processElement(element, options);
    }
    // tree management
    if (!stack.length && element !== root) {
      // allow root elements with v-if, v-else-if and v-else
      if (root.if && (element.elseif || element.else)) {
        if (true) {
          checkRootConstraints(element);
        }
        addIfCondition(root, {
          exp: element.elseif,
          block: element
        });
      } else if (true) {
        warnOnce(
          "Component template should contain exactly one root element. " +
          "If you are using v-if on multiple elements, " +
          "use v-else-if to chain them instead.",
          { start: element.start }
        );
      }
    }
    if (currentParent && !element.forbidden) {
      if (element.elseif || element.else) {
        processIfConditions(element, currentParent);
      } else {
        if (element.slotScope) {
          // scoped slot
          // keep it in the children list so that v-else(-if) conditions can
          // find it as the prev node.
          var name = element.slotTarget || '"default"'
          ;(currentParent.scopedSlots || (currentParent.scopedSlots = {}))[name] = element;
        }
        currentParent.children.push(element);
        element.parent = currentParent;
      }
    }

    // final children cleanup
    // filter out scoped slots
    element.children = element.children.filter(function (c) { return !(c).slotScope; });
    // remove trailing whitespace node again
    trimEndingWhitespace(element);

    // check pre state
    if (element.pre) {
      inVPre = false;
    }
    if (platformIsPreTag(element.tag)) {
      inPre = false;
    }
    // apply post-transforms
    for (var i = 0; i < postTransforms.length; i++) {
      postTransforms[i](element, options);
    }
  }

  function trimEndingWhitespace (el) {
    // remove trailing whitespace node
    if (!inPre) {
      var lastNode;
      while (
        (lastNode = el.children[el.children.length - 1]) &&
        lastNode.type === 3 &&
        lastNode.text === ' '
      ) {
        el.children.pop();
      }
    }
  }

  function checkRootConstraints (el) {
    if (el.tag === 'slot' || el.tag === 'template') {
      warnOnce(
        "Cannot use <" + (el.tag) + "> as component root element because it may " +
        'contain multiple nodes.',
        { start: el.start }
      );
    }
    if (el.attrsMap.hasOwnProperty('v-for')) {
      warnOnce(
        'Cannot use v-for on stateful component root element because ' +
        'it renders multiple elements.',
        el.rawAttrsMap['v-for']
      );
    }
  }

  parseHTML(template, {
    warn: warn$2,
    expectHTML: options.expectHTML,
    isUnaryTag: options.isUnaryTag,
    canBeLeftOpenTag: options.canBeLeftOpenTag,
    shouldDecodeNewlines: options.shouldDecodeNewlines,
    shouldDecodeNewlinesForHref: options.shouldDecodeNewlinesForHref,
    shouldKeepComment: options.comments,
    outputSourceRange: options.outputSourceRange,
    start: function start (tag, attrs, unary, start$1, end) {
      // check namespace.
      // inherit parent ns if there is one
      var ns = (currentParent && currentParent.ns) || platformGetTagNamespace(tag);

      // handle IE svg bug
      /* istanbul ignore if */
      if (isIE && ns === 'svg') {
        attrs = guardIESVGBug(attrs);
      }

      var element = createASTElement(tag, attrs, currentParent);
      if (ns) {
        element.ns = ns;
      }

      if (true) {
        if (options.outputSourceRange) {
          element.start = start$1;
          element.end = end;
          element.rawAttrsMap = element.attrsList.reduce(function (cumulated, attr) {
            cumulated[attr.name] = attr;
            return cumulated
          }, {});
        }
        attrs.forEach(function (attr) {
          if (invalidAttributeRE.test(attr.name)) {
            warn$2(
              "Invalid dynamic argument expression: attribute names cannot contain " +
              "spaces, quotes, <, >, / or =.",
              {
                start: attr.start + attr.name.indexOf("["),
                end: attr.start + attr.name.length
              }
            );
          }
        });
      }

      if (isForbiddenTag(element) && !isServerRendering()) {
        element.forbidden = true;
         true && warn$2(
          'Templates should only be responsible for mapping the state to the ' +
          'UI. Avoid placing tags with side-effects in your templates, such as ' +
          "<" + tag + ">" + ', as they will not be parsed.',
          { start: element.start }
        );
      }

      // apply pre-transforms
      for (var i = 0; i < preTransforms.length; i++) {
        element = preTransforms[i](element, options) || element;
      }

      if (!inVPre) {
        processPre(element);
        if (element.pre) {
          inVPre = true;
        }
      }
      if (platformIsPreTag(element.tag)) {
        inPre = true;
      }
      if (inVPre) {
        processRawAttrs(element);
      } else if (!element.processed) {
        // structural directives
        processFor(element);
        processIf(element);
        processOnce(element);
      }

      if (!root) {
        root = element;
        if (true) {
          checkRootConstraints(root);
        }
      }

      if (!unary) {
        currentParent = element;
        stack.push(element);
      } else {
        closeElement(element);
      }
    },

    end: function end (tag, start, end$1) {
      var element = stack[stack.length - 1];
      // pop stack
      stack.length -= 1;
      currentParent = stack[stack.length - 1];
      if ( true && options.outputSourceRange) {
        element.end = end$1;
      }
      closeElement(element);
    },

    chars: function chars (text, start, end) {
      if (!currentParent) {
        if (true) {
          if (text === template) {
            warnOnce(
              'Component template requires a root element, rather than just text.',
              { start: start }
            );
          } else if ((text = text.trim())) {
            warnOnce(
              ("text \"" + text + "\" outside root element will be ignored."),
              { start: start }
            );
          }
        }
        return
      }
      // IE textarea placeholder bug
      /* istanbul ignore if */
      if (isIE &&
        currentParent.tag === 'textarea' &&
        currentParent.attrsMap.placeholder === text
      ) {
        return
      }
      var children = currentParent.children;
      if (inPre || text.trim()) {
        text = isTextTag(currentParent) ? text : decodeHTMLCached(text);
      } else if (!children.length) {
        // remove the whitespace-only node right after an opening tag
        text = '';
      } else if (whitespaceOption) {
        if (whitespaceOption === 'condense') {
          // in condense mode, remove the whitespace node if it contains
          // line break, otherwise condense to a single space
          text = lineBreakRE.test(text) ? '' : ' ';
        } else {
          text = ' ';
        }
      } else {
        text = preserveWhitespace ? ' ' : '';
      }
      if (text) {
        if (!inPre && whitespaceOption === 'condense') {
          // condense consecutive whitespaces into single space
          text = text.replace(whitespaceRE$1, ' ');
        }
        var res;
        var child;
        if (!inVPre && text !== ' ' && (res = parseText(text, delimiters))) {
          child = {
            type: 2,
            expression: res.expression,
            tokens: res.tokens,
            text: text
          };
        } else if (text !== ' ' || !children.length || children[children.length - 1].text !== ' ') {
          child = {
            type: 3,
            text: text
          };
        }
        if (child) {
          if ( true && options.outputSourceRange) {
            child.start = start;
            child.end = end;
          }
          children.push(child);
        }
      }
    },
    comment: function comment (text, start, end) {
      // adding anything as a sibling to the root node is forbidden
      // comments should still be allowed, but ignored
      if (currentParent) {
        var child = {
          type: 3,
          text: text,
          isComment: true
        };
        if ( true && options.outputSourceRange) {
          child.start = start;
          child.end = end;
        }
        currentParent.children.push(child);
      }
    }
  });
  return root
}

function processPre (el) {
  if (getAndRemoveAttr(el, 'v-pre') != null) {
    el.pre = true;
  }
}

function processRawAttrs (el) {
  var list = el.attrsList;
  var len = list.length;
  if (len) {
    var attrs = el.attrs = new Array(len);
    for (var i = 0; i < len; i++) {
      attrs[i] = {
        name: list[i].name,
        value: JSON.stringify(list[i].value)
      };
      if (list[i].start != null) {
        attrs[i].start = list[i].start;
        attrs[i].end = list[i].end;
      }
    }
  } else if (!el.pre) {
    // non root node in pre blocks with no attributes
    el.plain = true;
  }
}

function processElement (
  element,
  options
) {
  processKey(element);

  // determine whether this is a plain element after
  // removing structural attributes
  element.plain = (
    !element.key &&
    !element.scopedSlots &&
    !element.attrsList.length
  );

  processRef(element);
  processSlotContent(element);
  processSlotOutlet(element);
  processComponent(element);
  for (var i = 0; i < transforms.length; i++) {
    element = transforms[i](element, options) || element;
  }
  processAttrs(element);
  return element
}

function processKey (el) {
  var exp = getBindingAttr(el, 'key');
  if (exp) {
    if (true) {
      if (el.tag === 'template') {
        warn$2(
          "<template> cannot be keyed. Place the key on real elements instead.",
          getRawBindingAttr(el, 'key')
        );
      }
      if (el.for) {
        var iterator = el.iterator2 || el.iterator1;
        var parent = el.parent;
        if (iterator && iterator === exp && parent && parent.tag === 'transition-group') {
          warn$2(
            "Do not use v-for index as key on <transition-group> children, " +
            "this is the same as not using keys.",
            getRawBindingAttr(el, 'key'),
            true /* tip */
          );
        }
      }
    }
    el.key = exp;
  }
}

function processRef (el) {
  var ref = getBindingAttr(el, 'ref');
  if (ref) {
    el.ref = ref;
    el.refInFor = checkInFor(el);
  }
}

function processFor (el) {
  var exp;
  if ((exp = getAndRemoveAttr(el, 'v-for'))) {
    var res = parseFor(exp);
    if (res) {
      extend(el, res);
    } else if (true) {
      warn$2(
        ("Invalid v-for expression: " + exp),
        el.rawAttrsMap['v-for']
      );
    }
  }
}



function parseFor (exp) {
  var inMatch = exp.match(forAliasRE);
  if (!inMatch) { return }
  var res = {};
  res.for = inMatch[2].trim();
  var alias = inMatch[1].trim().replace(stripParensRE, '');
  var iteratorMatch = alias.match(forIteratorRE);
  if (iteratorMatch) {
    res.alias = alias.replace(forIteratorRE, '').trim();
    res.iterator1 = iteratorMatch[1].trim();
    if (iteratorMatch[2]) {
      res.iterator2 = iteratorMatch[2].trim();
    }
  } else {
    res.alias = alias;
  }
  return res
}

function processIf (el) {
  var exp = getAndRemoveAttr(el, 'v-if');
  if (exp) {
    el.if = exp;
    addIfCondition(el, {
      exp: exp,
      block: el
    });
  } else {
    if (getAndRemoveAttr(el, 'v-else') != null) {
      el.else = true;
    }
    var elseif = getAndRemoveAttr(el, 'v-else-if');
    if (elseif) {
      el.elseif = elseif;
    }
  }
}

function processIfConditions (el, parent) {
  var prev = findPrevElement(parent.children);
  if (prev && prev.if) {
    addIfCondition(prev, {
      exp: el.elseif,
      block: el
    });
  } else if (true) {
    warn$2(
      "v-" + (el.elseif ? ('else-if="' + el.elseif + '"') : 'else') + " " +
      "used on element <" + (el.tag) + "> without corresponding v-if.",
      el.rawAttrsMap[el.elseif ? 'v-else-if' : 'v-else']
    );
  }
}

function findPrevElement (children) {
  var i = children.length;
  while (i--) {
    if (children[i].type === 1) {
      return children[i]
    } else {
      if ( true && children[i].text !== ' ') {
        warn$2(
          "text \"" + (children[i].text.trim()) + "\" between v-if and v-else(-if) " +
          "will be ignored.",
          children[i]
        );
      }
      children.pop();
    }
  }
}

function addIfCondition (el, condition) {
  if (!el.ifConditions) {
    el.ifConditions = [];
  }
  el.ifConditions.push(condition);
}

function processOnce (el) {
  var once$$1 = getAndRemoveAttr(el, 'v-once');
  if (once$$1 != null) {
    el.once = true;
  }
}

// handle content being passed to a component as slot,
// e.g. <template slot="xxx">, <div slot-scope="xxx">
function processSlotContent (el) {
  var slotScope;
  if (el.tag === 'template') {
    slotScope = getAndRemoveAttr(el, 'scope');
    /* istanbul ignore if */
    if ( true && slotScope) {
      warn$2(
        "the \"scope\" attribute for scoped slots have been deprecated and " +
        "replaced by \"slot-scope\" since 2.5. The new \"slot-scope\" attribute " +
        "can also be used on plain elements in addition to <template> to " +
        "denote scoped slots.",
        el.rawAttrsMap['scope'],
        true
      );
    }
    el.slotScope = slotScope || getAndRemoveAttr(el, 'slot-scope');
  } else if ((slotScope = getAndRemoveAttr(el, 'slot-scope'))) {
    /* istanbul ignore if */
    if ( true && el.attrsMap['v-for']) {
      warn$2(
        "Ambiguous combined usage of slot-scope and v-for on <" + (el.tag) + "> " +
        "(v-for takes higher priority). Use a wrapper <template> for the " +
        "scoped slot to make it clearer.",
        el.rawAttrsMap['slot-scope'],
        true
      );
    }
    el.slotScope = slotScope;
  }

  // slot="xxx"
  var slotTarget = getBindingAttr(el, 'slot');
  if (slotTarget) {
    el.slotTarget = slotTarget === '""' ? '"default"' : slotTarget;
    el.slotTargetDynamic = !!(el.attrsMap[':slot'] || el.attrsMap['v-bind:slot']);
    // preserve slot as an attribute for native shadow DOM compat
    // only for non-scoped slots.
    if (el.tag !== 'template' && !el.slotScope) {
      addAttr(el, 'slot', slotTarget, getRawBindingAttr(el, 'slot'));
    }
  }

  // 2.6 v-slot syntax
  {
    if (el.tag === 'template') {
      // v-slot on <template>
      var slotBinding = getAndRemoveAttrByRegex(el, slotRE);
      if (slotBinding) {
        if (true) {
          if (el.slotTarget || el.slotScope) {
            warn$2(
              "Unexpected mixed usage of different slot syntaxes.",
              el
            );
          }
          if (el.parent && !maybeComponent(el.parent)) {
            warn$2(
              "<template v-slot> can only appear at the root level inside " +
              "the receiving component",
              el
            );
          }
        }
        var ref = getSlotName(slotBinding);
        var name = ref.name;
        var dynamic = ref.dynamic;
        el.slotTarget = name;
        el.slotTargetDynamic = dynamic;
        el.slotScope = slotBinding.value || emptySlotScopeToken; // force it into a scoped slot for perf
      }
    } else {
      // v-slot on component, denotes default slot
      var slotBinding$1 = getAndRemoveAttrByRegex(el, slotRE);
      if (slotBinding$1) {
        if (true) {
          if (!maybeComponent(el)) {
            warn$2(
              "v-slot can only be used on components or <template>.",
              slotBinding$1
            );
          }
          if (el.slotScope || el.slotTarget) {
            warn$2(
              "Unexpected mixed usage of different slot syntaxes.",
              el
            );
          }
          if (el.scopedSlots) {
            warn$2(
              "To avoid scope ambiguity, the default slot should also use " +
              "<template> syntax when there are other named slots.",
              slotBinding$1
            );
          }
        }
        // add the component's children to its default slot
        var slots = el.scopedSlots || (el.scopedSlots = {});
        var ref$1 = getSlotName(slotBinding$1);
        var name$1 = ref$1.name;
        var dynamic$1 = ref$1.dynamic;
        var slotContainer = slots[name$1] = createASTElement('template', [], el);
        slotContainer.slotTarget = name$1;
        slotContainer.slotTargetDynamic = dynamic$1;
        slotContainer.children = el.children.filter(function (c) {
          if (!c.slotScope) {
            c.parent = slotContainer;
            return true
          }
        });
        slotContainer.slotScope = slotBinding$1.value || emptySlotScopeToken;
        // remove children as they are returned from scopedSlots now
        el.children = [];
        // mark el non-plain so data gets generated
        el.plain = false;
      }
    }
  }
}

function getSlotName (binding) {
  var name = binding.name.replace(slotRE, '');
  if (!name) {
    if (binding.name[0] !== '#') {
      name = 'default';
    } else if (true) {
      warn$2(
        "v-slot shorthand syntax requires a slot name.",
        binding
      );
    }
  }
  return dynamicArgRE.test(name)
    // dynamic [name]
    ? { name: name.slice(1, -1), dynamic: true }
    // static name
    : { name: ("\"" + name + "\""), dynamic: false }
}

// handle <slot/> outlets
function processSlotOutlet (el) {
  if (el.tag === 'slot') {
    el.slotName = getBindingAttr(el, 'name');
    if ( true && el.key) {
      warn$2(
        "`key` does not work on <slot> because slots are abstract outlets " +
        "and can possibly expand into multiple elements. " +
        "Use the key on a wrapping element instead.",
        getRawBindingAttr(el, 'key')
      );
    }
  }
}

function processComponent (el) {
  var binding;
  if ((binding = getBindingAttr(el, 'is'))) {
    el.component = binding;
  }
  if (getAndRemoveAttr(el, 'inline-template') != null) {
    el.inlineTemplate = true;
  }
}

function processAttrs (el) {
  var list = el.attrsList;
  var i, l, name, rawName, value, modifiers, syncGen, isDynamic;
  for (i = 0, l = list.length; i < l; i++) {
    name = rawName = list[i].name;
    value = list[i].value;
    if (dirRE.test(name)) {
      // mark element as dynamic
      el.hasBindings = true;
      // modifiers
      modifiers = parseModifiers(name.replace(dirRE, ''));
      // support .foo shorthand syntax for the .prop modifier
      if (modifiers) {
        name = name.replace(modifierRE, '');
      }
      if (bindRE.test(name)) { // v-bind
        name = name.replace(bindRE, '');
        value = parseFilters(value);
        isDynamic = dynamicArgRE.test(name);
        if (isDynamic) {
          name = name.slice(1, -1);
        }
        if (
           true &&
          value.trim().length === 0
        ) {
          warn$2(
            ("The value for a v-bind expression cannot be empty. Found in \"v-bind:" + name + "\"")
          );
        }
        if (modifiers) {
          if (modifiers.prop && !isDynamic) {
            name = camelize(name);
            if (name === 'innerHtml') { name = 'innerHTML'; }
          }
          if (modifiers.camel && !isDynamic) {
            name = camelize(name);
          }
          if (modifiers.sync) {
            syncGen = genAssignmentCode(value, "$event");
            if (!isDynamic) {
              addHandler(
                el,
                ("update:" + (camelize(name))),
                syncGen,
                null,
                false,
                warn$2,
                list[i]
              );
              if (hyphenate(name) !== camelize(name)) {
                addHandler(
                  el,
                  ("update:" + (hyphenate(name))),
                  syncGen,
                  null,
                  false,
                  warn$2,
                  list[i]
                );
              }
            } else {
              // handler w/ dynamic event name
              addHandler(
                el,
                ("\"update:\"+(" + name + ")"),
                syncGen,
                null,
                false,
                warn$2,
                list[i],
                true // dynamic
              );
            }
          }
        }
        if ((modifiers && modifiers.prop) || (
          !el.component && platformMustUseProp(el.tag, el.attrsMap.type, name)
        )) {
          addProp(el, name, value, list[i], isDynamic);
        } else {
          addAttr(el, name, value, list[i], isDynamic);
        }
      } else if (onRE.test(name)) { // v-on
        name = name.replace(onRE, '');
        isDynamic = dynamicArgRE.test(name);
        if (isDynamic) {
          name = name.slice(1, -1);
        }
        addHandler(el, name, value, modifiers, false, warn$2, list[i], isDynamic);
      } else { // normal directives
        name = name.replace(dirRE, '');
        // parse arg
        var argMatch = name.match(argRE);
        var arg = argMatch && argMatch[1];
        isDynamic = false;
        if (arg) {
          name = name.slice(0, -(arg.length + 1));
          if (dynamicArgRE.test(arg)) {
            arg = arg.slice(1, -1);
            isDynamic = true;
          }
        }
        addDirective(el, name, rawName, value, arg, isDynamic, modifiers, list[i]);
        if ( true && name === 'model') {
          checkForAliasModel(el, value);
        }
      }
    } else {
      // literal attribute
      if (true) {
        var res = parseText(value, delimiters);
        if (res) {
          warn$2(
            name + "=\"" + value + "\": " +
            'Interpolation inside attributes has been removed. ' +
            'Use v-bind or the colon shorthand instead. For example, ' +
            'instead of <div id="{{ val }}">, use <div :id="val">.',
            list[i]
          );
        }
      }
      addAttr(el, name, JSON.stringify(value), list[i]);
      // #6887 firefox doesn't update muted state if set via attribute
      // even immediately after element creation
      if (!el.component &&
          name === 'muted' &&
          platformMustUseProp(el.tag, el.attrsMap.type, name)) {
        addProp(el, name, 'true', list[i]);
      }
    }
  }
}

function checkInFor (el) {
  var parent = el;
  while (parent) {
    if (parent.for !== undefined) {
      return true
    }
    parent = parent.parent;
  }
  return false
}

function parseModifiers (name) {
  var match = name.match(modifierRE);
  if (match) {
    var ret = {};
    match.forEach(function (m) { ret[m.slice(1)] = true; });
    return ret
  }
}

function makeAttrsMap (attrs) {
  var map = {};
  for (var i = 0, l = attrs.length; i < l; i++) {
    if (
       true &&
      map[attrs[i].name] && !isIE && !isEdge
    ) {
      warn$2('duplicate attribute: ' + attrs[i].name, attrs[i]);
    }
    map[attrs[i].name] = attrs[i].value;
  }
  return map
}

// for script (e.g. type="x/template") or style, do not decode content
function isTextTag (el) {
  return el.tag === 'script' || el.tag === 'style'
}

function isForbiddenTag (el) {
  return (
    el.tag === 'style' ||
    (el.tag === 'script' && (
      !el.attrsMap.type ||
      el.attrsMap.type === 'text/javascript'
    ))
  )
}

var ieNSBug = /^xmlns:NS\d+/;
var ieNSPrefix = /^NS\d+:/;

/* istanbul ignore next */
function guardIESVGBug (attrs) {
  var res = [];
  for (var i = 0; i < attrs.length; i++) {
    var attr = attrs[i];
    if (!ieNSBug.test(attr.name)) {
      attr.name = attr.name.replace(ieNSPrefix, '');
      res.push(attr);
    }
  }
  return res
}

function checkForAliasModel (el, value) {
  var _el = el;
  while (_el) {
    if (_el.for && _el.alias === value) {
      warn$2(
        "<" + (el.tag) + " v-model=\"" + value + "\">: " +
        "You are binding v-model directly to a v-for iteration alias. " +
        "This will not be able to modify the v-for source array because " +
        "writing to the alias is like modifying a function local variable. " +
        "Consider using an array of objects and use v-model on an object property instead.",
        el.rawAttrsMap['v-model']
      );
    }
    _el = _el.parent;
  }
}

/*  */

function preTransformNode (el, options) {
  if (el.tag === 'input') {
    var map = el.attrsMap;
    if (!map['v-model']) {
      return
    }

    var typeBinding;
    if (map[':type'] || map['v-bind:type']) {
      typeBinding = getBindingAttr(el, 'type');
    }
    if (!map.type && !typeBinding && map['v-bind']) {
      typeBinding = "(" + (map['v-bind']) + ").type";
    }

    if (typeBinding) {
      var ifCondition = getAndRemoveAttr(el, 'v-if', true);
      var ifConditionExtra = ifCondition ? ("&&(" + ifCondition + ")") : "";
      var hasElse = getAndRemoveAttr(el, 'v-else', true) != null;
      var elseIfCondition = getAndRemoveAttr(el, 'v-else-if', true);
      // 1. checkbox
      var branch0 = cloneASTElement(el);
      // process for on the main node
      processFor(branch0);
      addRawAttr(branch0, 'type', 'checkbox');
      processElement(branch0, options);
      branch0.processed = true; // prevent it from double-processed
      branch0.if = "(" + typeBinding + ")==='checkbox'" + ifConditionExtra;
      addIfCondition(branch0, {
        exp: branch0.if,
        block: branch0
      });
      // 2. add radio else-if condition
      var branch1 = cloneASTElement(el);
      getAndRemoveAttr(branch1, 'v-for', true);
      addRawAttr(branch1, 'type', 'radio');
      processElement(branch1, options);
      addIfCondition(branch0, {
        exp: "(" + typeBinding + ")==='radio'" + ifConditionExtra,
        block: branch1
      });
      // 3. other
      var branch2 = cloneASTElement(el);
      getAndRemoveAttr(branch2, 'v-for', true);
      addRawAttr(branch2, ':type', typeBinding);
      processElement(branch2, options);
      addIfCondition(branch0, {
        exp: ifCondition,
        block: branch2
      });

      if (hasElse) {
        branch0.else = true;
      } else if (elseIfCondition) {
        branch0.elseif = elseIfCondition;
      }

      return branch0
    }
  }
}

function cloneASTElement (el) {
  return createASTElement(el.tag, el.attrsList.slice(), el.parent)
}

var model$1 = {
  preTransformNode: preTransformNode
};

var modules$1 = [
  klass$1,
  style$1,
  model$1
];

/*  */

function text (el, dir) {
  if (dir.value) {
    addProp(el, 'textContent', ("_s(" + (dir.value) + ")"), dir);
  }
}

/*  */

function html (el, dir) {
  if (dir.value) {
    addProp(el, 'innerHTML', ("_s(" + (dir.value) + ")"), dir);
  }
}

var directives$1 = {
  model: model,
  text: text,
  html: html
};

/*  */

var baseOptions = {
  expectHTML: true,
  modules: modules$1,
  directives: directives$1,
  isPreTag: isPreTag,
  isUnaryTag: isUnaryTag,
  mustUseProp: mustUseProp,
  canBeLeftOpenTag: canBeLeftOpenTag,
  isReservedTag: isReservedTag,
  getTagNamespace: getTagNamespace,
  staticKeys: genStaticKeys(modules$1)
};

/*  */

var isStaticKey;
var isPlatformReservedTag;

var genStaticKeysCached = cached(genStaticKeys$1);

/**
 * Goal of the optimizer: walk the generated template AST tree
 * and detect sub-trees that are purely static, i.e. parts of
 * the DOM that never needs to change.
 *
 * Once we detect these sub-trees, we can:
 *
 * 1. Hoist them into constants, so that we no longer need to
 *    create fresh nodes for them on each re-render;
 * 2. Completely skip them in the patching process.
 */
function optimize (root, options) {
  if (!root) { return }
  isStaticKey = genStaticKeysCached(options.staticKeys || '');
  isPlatformReservedTag = options.isReservedTag || no;
  // first pass: mark all non-static nodes.
  markStatic$1(root);
  // second pass: mark static roots.
  markStaticRoots(root, false);
}

function genStaticKeys$1 (keys) {
  return makeMap(
    'type,tag,attrsList,attrsMap,plain,parent,children,attrs,start,end,rawAttrsMap' +
    (keys ? ',' + keys : '')
  )
}

function markStatic$1 (node) {
  node.static = isStatic(node);
  if (node.type === 1) {
    // do not make component slot content static. this avoids
    // 1. components not able to mutate slot nodes
    // 2. static slot content fails for hot-reloading
    if (
      !isPlatformReservedTag(node.tag) &&
      node.tag !== 'slot' &&
      node.attrsMap['inline-template'] == null
    ) {
      return
    }
    for (var i = 0, l = node.children.length; i < l; i++) {
      var child = node.children[i];
      markStatic$1(child);
      if (!child.static) {
        node.static = false;
      }
    }
    if (node.ifConditions) {
      for (var i$1 = 1, l$1 = node.ifConditions.length; i$1 < l$1; i$1++) {
        var block = node.ifConditions[i$1].block;
        markStatic$1(block);
        if (!block.static) {
          node.static = false;
        }
      }
    }
  }
}

function markStaticRoots (node, isInFor) {
  if (node.type === 1) {
    if (node.static || node.once) {
      node.staticInFor = isInFor;
    }
    // For a node to qualify as a static root, it should have children that
    // are not just static text. Otherwise the cost of hoisting out will
    // outweigh the benefits and it's better off to just always render it fresh.
    if (node.static && node.children.length && !(
      node.children.length === 1 &&
      node.children[0].type === 3
    )) {
      node.staticRoot = true;
      return
    } else {
      node.staticRoot = false;
    }
    if (node.children) {
      for (var i = 0, l = node.children.length; i < l; i++) {
        markStaticRoots(node.children[i], isInFor || !!node.for);
      }
    }
    if (node.ifConditions) {
      for (var i$1 = 1, l$1 = node.ifConditions.length; i$1 < l$1; i$1++) {
        markStaticRoots(node.ifConditions[i$1].block, isInFor);
      }
    }
  }
}

function isStatic (node) {
  if (node.type === 2) { // expression
    return false
  }
  if (node.type === 3) { // text
    return true
  }
  return !!(node.pre || (
    !node.hasBindings && // no dynamic bindings
    !node.if && !node.for && // not v-if or v-for or v-else
    !isBuiltInTag(node.tag) && // not a built-in
    isPlatformReservedTag(node.tag) && // not a component
    !isDirectChildOfTemplateFor(node) &&
    Object.keys(node).every(isStaticKey)
  ))
}

function isDirectChildOfTemplateFor (node) {
  while (node.parent) {
    node = node.parent;
    if (node.tag !== 'template') {
      return false
    }
    if (node.for) {
      return true
    }
  }
  return false
}

/*  */

var fnExpRE = /^([\w$_]+|\([^)]*?\))\s*=>|^function(?:\s+[\w$]+)?\s*\(/;
var fnInvokeRE = /\([^)]*?\);*$/;
var simplePathRE = /^[A-Za-z_$][\w$]*(?:\.[A-Za-z_$][\w$]*|\['[^']*?']|\["[^"]*?"]|\[\d+]|\[[A-Za-z_$][\w$]*])*$/;

// KeyboardEvent.keyCode aliases
var keyCodes = {
  esc: 27,
  tab: 9,
  enter: 13,
  space: 32,
  up: 38,
  left: 37,
  right: 39,
  down: 40,
  'delete': [8, 46]
};

// KeyboardEvent.key aliases
var keyNames = {
  // #7880: IE11 and Edge use `Esc` for Escape key name.
  esc: ['Esc', 'Escape'],
  tab: 'Tab',
  enter: 'Enter',
  // #9112: IE11 uses `Spacebar` for Space key name.
  space: [' ', 'Spacebar'],
  // #7806: IE11 uses key names without `Arrow` prefix for arrow keys.
  up: ['Up', 'ArrowUp'],
  left: ['Left', 'ArrowLeft'],
  right: ['Right', 'ArrowRight'],
  down: ['Down', 'ArrowDown'],
  // #9112: IE11 uses `Del` for Delete key name.
  'delete': ['Backspace', 'Delete', 'Del']
};

// #4868: modifiers that prevent the execution of the listener
// need to explicitly return null so that we can determine whether to remove
// the listener for .once
var genGuard = function (condition) { return ("if(" + condition + ")return null;"); };

var modifierCode = {
  stop: '$event.stopPropagation();',
  prevent: '$event.preventDefault();',
  self: genGuard("$event.target !== $event.currentTarget"),
  ctrl: genGuard("!$event.ctrlKey"),
  shift: genGuard("!$event.shiftKey"),
  alt: genGuard("!$event.altKey"),
  meta: genGuard("!$event.metaKey"),
  left: genGuard("'button' in $event && $event.button !== 0"),
  middle: genGuard("'button' in $event && $event.button !== 1"),
  right: genGuard("'button' in $event && $event.button !== 2")
};

function genHandlers (
  events,
  isNative
) {
  var prefix = isNative ? 'nativeOn:' : 'on:';
  var staticHandlers = "";
  var dynamicHandlers = "";
  for (var name in events) {
    var handlerCode = genHandler(events[name]);
    if (events[name] && events[name].dynamic) {
      dynamicHandlers += name + "," + handlerCode + ",";
    } else {
      staticHandlers += "\"" + name + "\":" + handlerCode + ",";
    }
  }
  staticHandlers = "{" + (staticHandlers.slice(0, -1)) + "}";
  if (dynamicHandlers) {
    return prefix + "_d(" + staticHandlers + ",[" + (dynamicHandlers.slice(0, -1)) + "])"
  } else {
    return prefix + staticHandlers
  }
}

function genHandler (handler) {
  if (!handler) {
    return 'function(){}'
  }

  if (Array.isArray(handler)) {
    return ("[" + (handler.map(function (handler) { return genHandler(handler); }).join(',')) + "]")
  }

  var isMethodPath = simplePathRE.test(handler.value);
  var isFunctionExpression = fnExpRE.test(handler.value);
  var isFunctionInvocation = simplePathRE.test(handler.value.replace(fnInvokeRE, ''));

  if (!handler.modifiers) {
    if (isMethodPath || isFunctionExpression) {
      return handler.value
    }
    return ("function($event){" + (isFunctionInvocation ? ("return " + (handler.value)) : handler.value) + "}") // inline statement
  } else {
    var code = '';
    var genModifierCode = '';
    var keys = [];
    for (var key in handler.modifiers) {
      if (modifierCode[key]) {
        genModifierCode += modifierCode[key];
        // left/right
        if (keyCodes[key]) {
          keys.push(key);
        }
      } else if (key === 'exact') {
        var modifiers = (handler.modifiers);
        genModifierCode += genGuard(
          ['ctrl', 'shift', 'alt', 'meta']
            .filter(function (keyModifier) { return !modifiers[keyModifier]; })
            .map(function (keyModifier) { return ("$event." + keyModifier + "Key"); })
            .join('||')
        );
      } else {
        keys.push(key);
      }
    }
    if (keys.length) {
      code += genKeyFilter(keys);
    }
    // Make sure modifiers like prevent and stop get executed after key filtering
    if (genModifierCode) {
      code += genModifierCode;
    }
    var handlerCode = isMethodPath
      ? ("return " + (handler.value) + ".apply(null, arguments)")
      : isFunctionExpression
        ? ("return (" + (handler.value) + ").apply(null, arguments)")
        : isFunctionInvocation
          ? ("return " + (handler.value))
          : handler.value;
    return ("function($event){" + code + handlerCode + "}")
  }
}

function genKeyFilter (keys) {
  return (
    // make sure the key filters only apply to KeyboardEvents
    // #9441: can't use 'keyCode' in $event because Chrome autofill fires fake
    // key events that do not have keyCode property...
    "if(!$event.type.indexOf('key')&&" +
    (keys.map(genFilterCode).join('&&')) + ")return null;"
  )
}

function genFilterCode (key) {
  var keyVal = parseInt(key, 10);
  if (keyVal) {
    return ("$event.keyCode!==" + keyVal)
  }
  var keyCode = keyCodes[key];
  var keyName = keyNames[key];
  return (
    "_k($event.keyCode," +
    (JSON.stringify(key)) + "," +
    (JSON.stringify(keyCode)) + "," +
    "$event.key," +
    "" + (JSON.stringify(keyName)) +
    ")"
  )
}

/*  */

function on (el, dir) {
  if ( true && dir.modifiers) {
    warn("v-on without argument does not support modifiers.");
  }
  el.wrapListeners = function (code) { return ("_g(" + code + "," + (dir.value) + ")"); };
}

/*  */

function bind$1 (el, dir) {
  el.wrapData = function (code) {
    return ("_b(" + code + ",'" + (el.tag) + "'," + (dir.value) + "," + (dir.modifiers && dir.modifiers.prop ? 'true' : 'false') + (dir.modifiers && dir.modifiers.sync ? ',true' : '') + ")")
  };
}

/*  */

var baseDirectives = {
  on: on,
  bind: bind$1,
  cloak: noop
};

/*  */





var CodegenState = function CodegenState (options) {
  this.options = options;
  this.warn = options.warn || baseWarn;
  this.transforms = pluckModuleFunction(options.modules, 'transformCode');
  this.dataGenFns = pluckModuleFunction(options.modules, 'genData');
  this.directives = extend(extend({}, baseDirectives), options.directives);
  var isReservedTag = options.isReservedTag || no;
  this.maybeComponent = function (el) { return !!el.component || !isReservedTag(el.tag); };
  this.onceId = 0;
  this.staticRenderFns = [];
  this.pre = false;
};



function generate (
  ast,
  options
) {
  var state = new CodegenState(options);
  // fix #11483, Root level <script> tags should not be rendered.
  var code = ast ? (ast.tag === 'script' ? 'null' : genElement(ast, state)) : '_c("div")';
  return {
    render: ("with(this){return " + code + "}"),
    staticRenderFns: state.staticRenderFns
  }
}

function genElement (el, state) {
  if (el.parent) {
    el.pre = el.pre || el.parent.pre;
  }

  if (el.staticRoot && !el.staticProcessed) {
    return genStatic(el, state)
  } else if (el.once && !el.onceProcessed) {
    return genOnce(el, state)
  } else if (el.for && !el.forProcessed) {
    return genFor(el, state)
  } else if (el.if && !el.ifProcessed) {
    return genIf(el, state)
  } else if (el.tag === 'template' && !el.slotTarget && !state.pre) {
    return genChildren(el, state) || 'void 0'
  } else if (el.tag === 'slot') {
    return genSlot(el, state)
  } else {
    // component or element
    var code;
    if (el.component) {
      code = genComponent(el.component, el, state);
    } else {
      var data;
      if (!el.plain || (el.pre && state.maybeComponent(el))) {
        data = genData$2(el, state);
      }

      var children = el.inlineTemplate ? null : genChildren(el, state, true);
      code = "_c('" + (el.tag) + "'" + (data ? ("," + data) : '') + (children ? ("," + children) : '') + ")";
    }
    // module transforms
    for (var i = 0; i < state.transforms.length; i++) {
      code = state.transforms[i](el, code);
    }
    return code
  }
}

// hoist static sub-trees out
function genStatic (el, state) {
  el.staticProcessed = true;
  // Some elements (templates) need to behave differently inside of a v-pre
  // node.  All pre nodes are static roots, so we can use this as a location to
  // wrap a state change and reset it upon exiting the pre node.
  var originalPreState = state.pre;
  if (el.pre) {
    state.pre = el.pre;
  }
  state.staticRenderFns.push(("with(this){return " + (genElement(el, state)) + "}"));
  state.pre = originalPreState;
  return ("_m(" + (state.staticRenderFns.length - 1) + (el.staticInFor ? ',true' : '') + ")")
}

// v-once
function genOnce (el, state) {
  el.onceProcessed = true;
  if (el.if && !el.ifProcessed) {
    return genIf(el, state)
  } else if (el.staticInFor) {
    var key = '';
    var parent = el.parent;
    while (parent) {
      if (parent.for) {
        key = parent.key;
        break
      }
      parent = parent.parent;
    }
    if (!key) {
       true && state.warn(
        "v-once can only be used inside v-for that is keyed. ",
        el.rawAttrsMap['v-once']
      );
      return genElement(el, state)
    }
    return ("_o(" + (genElement(el, state)) + "," + (state.onceId++) + "," + key + ")")
  } else {
    return genStatic(el, state)
  }
}

function genIf (
  el,
  state,
  altGen,
  altEmpty
) {
  el.ifProcessed = true; // avoid recursion
  return genIfConditions(el.ifConditions.slice(), state, altGen, altEmpty)
}

function genIfConditions (
  conditions,
  state,
  altGen,
  altEmpty
) {
  if (!conditions.length) {
    return altEmpty || '_e()'
  }

  var condition = conditions.shift();
  if (condition.exp) {
    return ("(" + (condition.exp) + ")?" + (genTernaryExp(condition.block)) + ":" + (genIfConditions(conditions, state, altGen, altEmpty)))
  } else {
    return ("" + (genTernaryExp(condition.block)))
  }

  // v-if with v-once should generate code like (a)?_m(0):_m(1)
  function genTernaryExp (el) {
    return altGen
      ? altGen(el, state)
      : el.once
        ? genOnce(el, state)
        : genElement(el, state)
  }
}

function genFor (
  el,
  state,
  altGen,
  altHelper
) {
  var exp = el.for;
  var alias = el.alias;
  var iterator1 = el.iterator1 ? ("," + (el.iterator1)) : '';
  var iterator2 = el.iterator2 ? ("," + (el.iterator2)) : '';

  if ( true &&
    state.maybeComponent(el) &&
    el.tag !== 'slot' &&
    el.tag !== 'template' &&
    !el.key
  ) {
    state.warn(
      "<" + (el.tag) + " v-for=\"" + alias + " in " + exp + "\">: component lists rendered with " +
      "v-for should have explicit keys. " +
      "See https://vuejs.org/guide/list.html#key for more info.",
      el.rawAttrsMap['v-for'],
      true /* tip */
    );
  }

  el.forProcessed = true; // avoid recursion
  return (altHelper || '_l') + "((" + exp + ")," +
    "function(" + alias + iterator1 + iterator2 + "){" +
      "return " + ((altGen || genElement)(el, state)) +
    '})'
}

function genData$2 (el, state) {
  var data = '{';

  // directives first.
  // directives may mutate the el's other properties before they are generated.
  var dirs = genDirectives(el, state);
  if (dirs) { data += dirs + ','; }

  // key
  if (el.key) {
    data += "key:" + (el.key) + ",";
  }
  // ref
  if (el.ref) {
    data += "ref:" + (el.ref) + ",";
  }
  if (el.refInFor) {
    data += "refInFor:true,";
  }
  // pre
  if (el.pre) {
    data += "pre:true,";
  }
  // record original tag name for components using "is" attribute
  if (el.component) {
    data += "tag:\"" + (el.tag) + "\",";
  }
  // module data generation functions
  for (var i = 0; i < state.dataGenFns.length; i++) {
    data += state.dataGenFns[i](el);
  }
  // attributes
  if (el.attrs) {
    data += "attrs:" + (genProps(el.attrs)) + ",";
  }
  // DOM props
  if (el.props) {
    data += "domProps:" + (genProps(el.props)) + ",";
  }
  // event handlers
  if (el.events) {
    data += (genHandlers(el.events, false)) + ",";
  }
  if (el.nativeEvents) {
    data += (genHandlers(el.nativeEvents, true)) + ",";
  }
  // slot target
  // only for non-scoped slots
  if (el.slotTarget && !el.slotScope) {
    data += "slot:" + (el.slotTarget) + ",";
  }
  // scoped slots
  if (el.scopedSlots) {
    data += (genScopedSlots(el, el.scopedSlots, state)) + ",";
  }
  // component v-model
  if (el.model) {
    data += "model:{value:" + (el.model.value) + ",callback:" + (el.model.callback) + ",expression:" + (el.model.expression) + "},";
  }
  // inline-template
  if (el.inlineTemplate) {
    var inlineTemplate = genInlineTemplate(el, state);
    if (inlineTemplate) {
      data += inlineTemplate + ",";
    }
  }
  data = data.replace(/,$/, '') + '}';
  // v-bind dynamic argument wrap
  // v-bind with dynamic arguments must be applied using the same v-bind object
  // merge helper so that class/style/mustUseProp attrs are handled correctly.
  if (el.dynamicAttrs) {
    data = "_b(" + data + ",\"" + (el.tag) + "\"," + (genProps(el.dynamicAttrs)) + ")";
  }
  // v-bind data wrap
  if (el.wrapData) {
    data = el.wrapData(data);
  }
  // v-on data wrap
  if (el.wrapListeners) {
    data = el.wrapListeners(data);
  }
  return data
}

function genDirectives (el, state) {
  var dirs = el.directives;
  if (!dirs) { return }
  var res = 'directives:[';
  var hasRuntime = false;
  var i, l, dir, needRuntime;
  for (i = 0, l = dirs.length; i < l; i++) {
    dir = dirs[i];
    needRuntime = true;
    var gen = state.directives[dir.name];
    if (gen) {
      // compile-time directive that manipulates AST.
      // returns true if it also needs a runtime counterpart.
      needRuntime = !!gen(el, dir, state.warn);
    }
    if (needRuntime) {
      hasRuntime = true;
      res += "{name:\"" + (dir.name) + "\",rawName:\"" + (dir.rawName) + "\"" + (dir.value ? (",value:(" + (dir.value) + "),expression:" + (JSON.stringify(dir.value))) : '') + (dir.arg ? (",arg:" + (dir.isDynamicArg ? dir.arg : ("\"" + (dir.arg) + "\""))) : '') + (dir.modifiers ? (",modifiers:" + (JSON.stringify(dir.modifiers))) : '') + "},";
    }
  }
  if (hasRuntime) {
    return res.slice(0, -1) + ']'
  }
}

function genInlineTemplate (el, state) {
  var ast = el.children[0];
  if ( true && (
    el.children.length !== 1 || ast.type !== 1
  )) {
    state.warn(
      'Inline-template components must have exactly one child element.',
      { start: el.start }
    );
  }
  if (ast && ast.type === 1) {
    var inlineRenderFns = generate(ast, state.options);
    return ("inlineTemplate:{render:function(){" + (inlineRenderFns.render) + "},staticRenderFns:[" + (inlineRenderFns.staticRenderFns.map(function (code) { return ("function(){" + code + "}"); }).join(',')) + "]}")
  }
}

function genScopedSlots (
  el,
  slots,
  state
) {
  // by default scoped slots are considered "stable", this allows child
  // components with only scoped slots to skip forced updates from parent.
  // but in some cases we have to bail-out of this optimization
  // for example if the slot contains dynamic names, has v-if or v-for on them...
  var needsForceUpdate = el.for || Object.keys(slots).some(function (key) {
    var slot = slots[key];
    return (
      slot.slotTargetDynamic ||
      slot.if ||
      slot.for ||
      containsSlotChild(slot) // is passing down slot from parent which may be dynamic
    )
  });

  // #9534: if a component with scoped slots is inside a conditional branch,
  // it's possible for the same component to be reused but with different
  // compiled slot content. To avoid that, we generate a unique key based on
  // the generated code of all the slot contents.
  var needsKey = !!el.if;

  // OR when it is inside another scoped slot or v-for (the reactivity may be
  // disconnected due to the intermediate scope variable)
  // #9438, #9506
  // TODO: this can be further optimized by properly analyzing in-scope bindings
  // and skip force updating ones that do not actually use scope variables.
  if (!needsForceUpdate) {
    var parent = el.parent;
    while (parent) {
      if (
        (parent.slotScope && parent.slotScope !== emptySlotScopeToken) ||
        parent.for
      ) {
        needsForceUpdate = true;
        break
      }
      if (parent.if) {
        needsKey = true;
      }
      parent = parent.parent;
    }
  }

  var generatedSlots = Object.keys(slots)
    .map(function (key) { return genScopedSlot(slots[key], state); })
    .join(',');

  return ("scopedSlots:_u([" + generatedSlots + "]" + (needsForceUpdate ? ",null,true" : "") + (!needsForceUpdate && needsKey ? (",null,false," + (hash(generatedSlots))) : "") + ")")
}

function hash(str) {
  var hash = 5381;
  var i = str.length;
  while(i) {
    hash = (hash * 33) ^ str.charCodeAt(--i);
  }
  return hash >>> 0
}

function containsSlotChild (el) {
  if (el.type === 1) {
    if (el.tag === 'slot') {
      return true
    }
    return el.children.some(containsSlotChild)
  }
  return false
}

function genScopedSlot (
  el,
  state
) {
  var isLegacySyntax = el.attrsMap['slot-scope'];
  if (el.if && !el.ifProcessed && !isLegacySyntax) {
    return genIf(el, state, genScopedSlot, "null")
  }
  if (el.for && !el.forProcessed) {
    return genFor(el, state, genScopedSlot)
  }
  var slotScope = el.slotScope === emptySlotScopeToken
    ? ""
    : String(el.slotScope);
  var fn = "function(" + slotScope + "){" +
    "return " + (el.tag === 'template'
      ? el.if && isLegacySyntax
        ? ("(" + (el.if) + ")?" + (genChildren(el, state) || 'undefined') + ":undefined")
        : genChildren(el, state) || 'undefined'
      : genElement(el, state)) + "}";
  // reverse proxy v-slot without scope on this.$slots
  var reverseProxy = slotScope ? "" : ",proxy:true";
  return ("{key:" + (el.slotTarget || "\"default\"") + ",fn:" + fn + reverseProxy + "}")
}

function genChildren (
  el,
  state,
  checkSkip,
  altGenElement,
  altGenNode
) {
  var children = el.children;
  if (children.length) {
    var el$1 = children[0];
    // optimize single v-for
    if (children.length === 1 &&
      el$1.for &&
      el$1.tag !== 'template' &&
      el$1.tag !== 'slot'
    ) {
      var normalizationType = checkSkip
        ? state.maybeComponent(el$1) ? ",1" : ",0"
        : "";
      return ("" + ((altGenElement || genElement)(el$1, state)) + normalizationType)
    }
    var normalizationType$1 = checkSkip
      ? getNormalizationType(children, state.maybeComponent)
      : 0;
    var gen = altGenNode || genNode;
    return ("[" + (children.map(function (c) { return gen(c, state); }).join(',')) + "]" + (normalizationType$1 ? ("," + normalizationType$1) : ''))
  }
}

// determine the normalization needed for the children array.
// 0: no normalization needed
// 1: simple normalization needed (possible 1-level deep nested array)
// 2: full normalization needed
function getNormalizationType (
  children,
  maybeComponent
) {
  var res = 0;
  for (var i = 0; i < children.length; i++) {
    var el = children[i];
    if (el.type !== 1) {
      continue
    }
    if (needsNormalization(el) ||
        (el.ifConditions && el.ifConditions.some(function (c) { return needsNormalization(c.block); }))) {
      res = 2;
      break
    }
    if (maybeComponent(el) ||
        (el.ifConditions && el.ifConditions.some(function (c) { return maybeComponent(c.block); }))) {
      res = 1;
    }
  }
  return res
}

function needsNormalization (el) {
  return el.for !== undefined || el.tag === 'template' || el.tag === 'slot'
}

function genNode (node, state) {
  if (node.type === 1) {
    return genElement(node, state)
  } else if (node.type === 3 && node.isComment) {
    return genComment(node)
  } else {
    return genText(node)
  }
}

function genText (text) {
  return ("_v(" + (text.type === 2
    ? text.expression // no need for () because already wrapped in _s()
    : transformSpecialNewlines(JSON.stringify(text.text))) + ")")
}

function genComment (comment) {
  return ("_e(" + (JSON.stringify(comment.text)) + ")")
}

function genSlot (el, state) {
  var slotName = el.slotName || '"default"';
  var children = genChildren(el, state);
  var res = "_t(" + slotName + (children ? (",function(){return " + children + "}") : '');
  var attrs = el.attrs || el.dynamicAttrs
    ? genProps((el.attrs || []).concat(el.dynamicAttrs || []).map(function (attr) { return ({
        // slot props are camelized
        name: camelize(attr.name),
        value: attr.value,
        dynamic: attr.dynamic
      }); }))
    : null;
  var bind$$1 = el.attrsMap['v-bind'];
  if ((attrs || bind$$1) && !children) {
    res += ",null";
  }
  if (attrs) {
    res += "," + attrs;
  }
  if (bind$$1) {
    res += (attrs ? '' : ',null') + "," + bind$$1;
  }
  return res + ')'
}

// componentName is el.component, take it as argument to shun flow's pessimistic refinement
function genComponent (
  componentName,
  el,
  state
) {
  var children = el.inlineTemplate ? null : genChildren(el, state, true);
  return ("_c(" + componentName + "," + (genData$2(el, state)) + (children ? ("," + children) : '') + ")")
}

function genProps (props) {
  var staticProps = "";
  var dynamicProps = "";
  for (var i = 0; i < props.length; i++) {
    var prop = props[i];
    var value = transformSpecialNewlines(prop.value);
    if (prop.dynamic) {
      dynamicProps += (prop.name) + "," + value + ",";
    } else {
      staticProps += "\"" + (prop.name) + "\":" + value + ",";
    }
  }
  staticProps = "{" + (staticProps.slice(0, -1)) + "}";
  if (dynamicProps) {
    return ("_d(" + staticProps + ",[" + (dynamicProps.slice(0, -1)) + "])")
  } else {
    return staticProps
  }
}

// #3895, #4268
function transformSpecialNewlines (text) {
  return text
    .replace(/\u2028/g, '\\u2028')
    .replace(/\u2029/g, '\\u2029')
}

/*  */



// these keywords should not appear inside expressions, but operators like
// typeof, instanceof and in are allowed
var prohibitedKeywordRE = new RegExp('\\b' + (
  'do,if,for,let,new,try,var,case,else,with,await,break,catch,class,const,' +
  'super,throw,while,yield,delete,export,import,return,switch,default,' +
  'extends,finally,continue,debugger,function,arguments'
).split(',').join('\\b|\\b') + '\\b');

// these unary operators should not be used as property/method names
var unaryOperatorsRE = new RegExp('\\b' + (
  'delete,typeof,void'
).split(',').join('\\s*\\([^\\)]*\\)|\\b') + '\\s*\\([^\\)]*\\)');

// strip strings in expressions
var stripStringRE = /'(?:[^'\\]|\\.)*'|"(?:[^"\\]|\\.)*"|`(?:[^`\\]|\\.)*\$\{|\}(?:[^`\\]|\\.)*`|`(?:[^`\\]|\\.)*`/g;

// detect problematic expressions in a template
function detectErrors (ast, warn) {
  if (ast) {
    checkNode(ast, warn);
  }
}

function checkNode (node, warn) {
  if (node.type === 1) {
    for (var name in node.attrsMap) {
      if (dirRE.test(name)) {
        var value = node.attrsMap[name];
        if (value) {
          var range = node.rawAttrsMap[name];
          if (name === 'v-for') {
            checkFor(node, ("v-for=\"" + value + "\""), warn, range);
          } else if (name === 'v-slot' || name[0] === '#') {
            checkFunctionParameterExpression(value, (name + "=\"" + value + "\""), warn, range);
          } else if (onRE.test(name)) {
            checkEvent(value, (name + "=\"" + value + "\""), warn, range);
          } else {
            checkExpression(value, (name + "=\"" + value + "\""), warn, range);
          }
        }
      }
    }
    if (node.children) {
      for (var i = 0; i < node.children.length; i++) {
        checkNode(node.children[i], warn);
      }
    }
  } else if (node.type === 2) {
    checkExpression(node.expression, node.text, warn, node);
  }
}

function checkEvent (exp, text, warn, range) {
  var stripped = exp.replace(stripStringRE, '');
  var keywordMatch = stripped.match(unaryOperatorsRE);
  if (keywordMatch && stripped.charAt(keywordMatch.index - 1) !== '$') {
    warn(
      "avoid using JavaScript unary operator as property name: " +
      "\"" + (keywordMatch[0]) + "\" in expression " + (text.trim()),
      range
    );
  }
  checkExpression(exp, text, warn, range);
}

function checkFor (node, text, warn, range) {
  checkExpression(node.for || '', text, warn, range);
  checkIdentifier(node.alias, 'v-for alias', text, warn, range);
  checkIdentifier(node.iterator1, 'v-for iterator', text, warn, range);
  checkIdentifier(node.iterator2, 'v-for iterator', text, warn, range);
}

function checkIdentifier (
  ident,
  type,
  text,
  warn,
  range
) {
  if (typeof ident === 'string') {
    try {
      new Function(("var " + ident + "=_"));
    } catch (e) {
      warn(("invalid " + type + " \"" + ident + "\" in expression: " + (text.trim())), range);
    }
  }
}

function checkExpression (exp, text, warn, range) {
  try {
    new Function(("return " + exp));
  } catch (e) {
    var keywordMatch = exp.replace(stripStringRE, '').match(prohibitedKeywordRE);
    if (keywordMatch) {
      warn(
        "avoid using JavaScript keyword as property name: " +
        "\"" + (keywordMatch[0]) + "\"\n  Raw expression: " + (text.trim()),
        range
      );
    } else {
      warn(
        "invalid expression: " + (e.message) + " in\n\n" +
        "    " + exp + "\n\n" +
        "  Raw expression: " + (text.trim()) + "\n",
        range
      );
    }
  }
}

function checkFunctionParameterExpression (exp, text, warn, range) {
  try {
    new Function(exp, '');
  } catch (e) {
    warn(
      "invalid function parameter expression: " + (e.message) + " in\n\n" +
      "    " + exp + "\n\n" +
      "  Raw expression: " + (text.trim()) + "\n",
      range
    );
  }
}

/*  */

var range = 2;

function generateCodeFrame (
  source,
  start,
  end
) {
  if ( start === void 0 ) start = 0;
  if ( end === void 0 ) end = source.length;

  var lines = source.split(/\r?\n/);
  var count = 0;
  var res = [];
  for (var i = 0; i < lines.length; i++) {
    count += lines[i].length + 1;
    if (count >= start) {
      for (var j = i - range; j <= i + range || end > count; j++) {
        if (j < 0 || j >= lines.length) { continue }
        res.push(("" + (j + 1) + (repeat$1(" ", 3 - String(j + 1).length)) + "|  " + (lines[j])));
        var lineLength = lines[j].length;
        if (j === i) {
          // push underline
          var pad = start - (count - lineLength) + 1;
          var length = end > count ? lineLength - pad : end - start;
          res.push("   |  " + repeat$1(" ", pad) + repeat$1("^", length));
        } else if (j > i) {
          if (end > count) {
            var length$1 = Math.min(end - count, lineLength);
            res.push("   |  " + repeat$1("^", length$1));
          }
          count += lineLength + 1;
        }
      }
      break
    }
  }
  return res.join('\n')
}

function repeat$1 (str, n) {
  var result = '';
  if (n > 0) {
    while (true) { // eslint-disable-line
      if (n & 1) { result += str; }
      n >>>= 1;
      if (n <= 0) { break }
      str += str;
    }
  }
  return result
}

/*  */



function createFunction (code, errors) {
  try {
    return new Function(code)
  } catch (err) {
    errors.push({ err: err, code: code });
    return noop
  }
}

function createCompileToFunctionFn (compile) {
  var cache = Object.create(null);

  return function compileToFunctions (
    template,
    options,
    vm
  ) {
    options = extend({}, options);
    var warn$$1 = options.warn || warn;
    delete options.warn;

    /* istanbul ignore if */
    if (true) {
      // detect possible CSP restriction
      try {
        new Function('return 1');
      } catch (e) {
        if (e.toString().match(/unsafe-eval|CSP/)) {
          warn$$1(
            'It seems you are using the standalone build of Vue.js in an ' +
            'environment with Content Security Policy that prohibits unsafe-eval. ' +
            'The template compiler cannot work in this environment. Consider ' +
            'relaxing the policy to allow unsafe-eval or pre-compiling your ' +
            'templates into render functions.'
          );
        }
      }
    }

    // check cache
    var key = options.delimiters
      ? String(options.delimiters) + template
      : template;
    if (cache[key]) {
      return cache[key]
    }

    // compile
    var compiled = compile(template, options);

    // check compilation errors/tips
    if (true) {
      if (compiled.errors && compiled.errors.length) {
        if (options.outputSourceRange) {
          compiled.errors.forEach(function (e) {
            warn$$1(
              "Error compiling template:\n\n" + (e.msg) + "\n\n" +
              generateCodeFrame(template, e.start, e.end),
              vm
            );
          });
        } else {
          warn$$1(
            "Error compiling template:\n\n" + template + "\n\n" +
            compiled.errors.map(function (e) { return ("- " + e); }).join('\n') + '\n',
            vm
          );
        }
      }
      if (compiled.tips && compiled.tips.length) {
        if (options.outputSourceRange) {
          compiled.tips.forEach(function (e) { return tip(e.msg, vm); });
        } else {
          compiled.tips.forEach(function (msg) { return tip(msg, vm); });
        }
      }
    }

    // turn code into functions
    var res = {};
    var fnGenErrors = [];
    res.render = createFunction(compiled.render, fnGenErrors);
    res.staticRenderFns = compiled.staticRenderFns.map(function (code) {
      return createFunction(code, fnGenErrors)
    });

    // check function generation errors.
    // this should only happen if there is a bug in the compiler itself.
    // mostly for codegen development use
    /* istanbul ignore if */
    if (true) {
      if ((!compiled.errors || !compiled.errors.length) && fnGenErrors.length) {
        warn$$1(
          "Failed to generate render function:\n\n" +
          fnGenErrors.map(function (ref) {
            var err = ref.err;
            var code = ref.code;

            return ((err.toString()) + " in\n\n" + code + "\n");
        }).join('\n'),
          vm
        );
      }
    }

    return (cache[key] = res)
  }
}

/*  */

function createCompilerCreator (baseCompile) {
  return function createCompiler (baseOptions) {
    function compile (
      template,
      options
    ) {
      var finalOptions = Object.create(baseOptions);
      var errors = [];
      var tips = [];

      var warn = function (msg, range, tip) {
        (tip ? tips : errors).push(msg);
      };

      if (options) {
        if ( true && options.outputSourceRange) {
          // $flow-disable-line
          var leadingSpaceLength = template.match(/^\s*/)[0].length;

          warn = function (msg, range, tip) {
            var data = { msg: msg };
            if (range) {
              if (range.start != null) {
                data.start = range.start + leadingSpaceLength;
              }
              if (range.end != null) {
                data.end = range.end + leadingSpaceLength;
              }
            }
            (tip ? tips : errors).push(data);
          };
        }
        // merge custom modules
        if (options.modules) {
          finalOptions.modules =
            (baseOptions.modules || []).concat(options.modules);
        }
        // merge custom directives
        if (options.directives) {
          finalOptions.directives = extend(
            Object.create(baseOptions.directives || null),
            options.directives
          );
        }
        // copy other options
        for (var key in options) {
          if (key !== 'modules' && key !== 'directives') {
            finalOptions[key] = options[key];
          }
        }
      }

      finalOptions.warn = warn;

      var compiled = baseCompile(template.trim(), finalOptions);
      if (true) {
        detectErrors(compiled.ast, warn);
      }
      compiled.errors = errors;
      compiled.tips = tips;
      return compiled
    }

    return {
      compile: compile,
      compileToFunctions: createCompileToFunctionFn(compile)
    }
  }
}

/*  */

// `createCompilerCreator` allows creating compilers that use alternative
// parser/optimizer/codegen, e.g the SSR optimizing compiler.
// Here we just export a default compiler using the default parts.
var createCompiler = createCompilerCreator(function baseCompile (
  template,
  options
) {
  var ast = parse(template.trim(), options);
  if (options.optimize !== false) {
    optimize(ast, options);
  }
  var code = generate(ast, options);
  return {
    ast: ast,
    render: code.render,
    staticRenderFns: code.staticRenderFns
  }
});

/*  */

var ref$1 = createCompiler(baseOptions);
var compile = ref$1.compile;
var compileToFunctions = ref$1.compileToFunctions;

/*  */

// check whether current browser encodes a char inside attribute values
var div;
function getShouldDecode (href) {
  div = div || document.createElement('div');
  div.innerHTML = href ? "<a href=\"\n\"/>" : "<div a=\"\n\"/>";
  return div.innerHTML.indexOf('&#10;') > 0
}

// #3663: IE encodes newlines inside attribute values while other browsers don't
var shouldDecodeNewlines = inBrowser ? getShouldDecode(false) : false;
// #6828: chrome encodes content in a[href]
var shouldDecodeNewlinesForHref = inBrowser ? getShouldDecode(true) : false;

/*  */

var idToTemplate = cached(function (id) {
  var el = query(id);
  return el && el.innerHTML
});

var mount = Vue.prototype.$mount;
Vue.prototype.$mount = function (
  el,
  hydrating
) {
  el = el && query(el);

  /* istanbul ignore if */
  if (el === document.body || el === document.documentElement) {
     true && warn(
      "Do not mount Vue to <html> or <body> - mount to normal elements instead."
    );
    return this
  }

  var options = this.$options;
  // resolve template/el and convert to render function
  if (!options.render) {
    var template = options.template;
    if (template) {
      if (typeof template === 'string') {
        if (template.charAt(0) === '#') {
          template = idToTemplate(template);
          /* istanbul ignore if */
          if ( true && !template) {
            warn(
              ("Template element not found or is empty: " + (options.template)),
              this
            );
          }
        }
      } else if (template.nodeType) {
        template = template.innerHTML;
      } else {
        if (true) {
          warn('invalid template option:' + template, this);
        }
        return this
      }
    } else if (el) {
      template = getOuterHTML(el);
    }
    if (template) {
      /* istanbul ignore if */
      if ( true && config.performance && mark) {
        mark('compile');
      }

      var ref = compileToFunctions(template, {
        outputSourceRange: "development" !== 'production',
        shouldDecodeNewlines: shouldDecodeNewlines,
        shouldDecodeNewlinesForHref: shouldDecodeNewlinesForHref,
        delimiters: options.delimiters,
        comments: options.comments
      }, this);
      var render = ref.render;
      var staticRenderFns = ref.staticRenderFns;
      options.render = render;
      options.staticRenderFns = staticRenderFns;

      /* istanbul ignore if */
      if ( true && config.performance && mark) {
        mark('compile end');
        measure(("vue " + (this._name) + " compile"), 'compile', 'compile end');
      }
    }
  }
  return mount.call(this, el, hydrating)
};

/**
 * Get outerHTML of elements, taking care
 * of SVG elements in IE as well.
 */
function getOuterHTML (el) {
  if (el.outerHTML) {
    return el.outerHTML
  } else {
    var container = document.createElement('div');
    container.appendChild(el.cloneNode(true));
    return container.innerHTML
  }
}

Vue.compile = compileToFunctions;

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Vue);


/***/ }),

/***/ "./resources/data/data.json":
/*!**********************************!*\
  !*** ./resources/data/data.json ***!
  \**********************************/
/***/ ((module) => {

"use strict";
module.exports = JSON.parse('{"ohlcv":[],"offchart":[{"name":"MACD","type":"MACD","data":[],"settings":{"histColors":["#35a776","#79e0b3","#e54150","#ea969e"]}}],"tools":[{"type":"Cursor","icon":"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABkAAAAZAgMAAAC5h23wAAAAAXNSR0IB2cksfwAAAAlwSFlzAAALEwAACxMBAJqcGAAAAAxQTFRFAAAATU1NTU1NTU1NwlMHHwAAAAR0Uk5TAOvhxbpPrUkAAAAkSURBVHicY2BgYHBggAByabxg1WoGBq2pRCk9AKUbcND43AEAufYHlSuusE4AAAAASUVORK5CYII="},{"type":"LineToolSegment","icon":"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABkAAAAZAgMAAAC5h23wAAAAAXNSR0IB2cksfwAAAAlwSFlzAAALEwAACxMBAJqcGAAAAAlQTFRFAAAATU1NJCQkCxcHIQAAAAN0Uk5TAP8SmutI5AAAACxJREFUeJxjYMACGAMgNAsLdpoVKi8AVe8A1QblQlWRKt0AoULw2w1zGxoAABdiAviQhF/mAAAAAElFTkSuQmCC"},{"type":"LineToolExtended","icon":"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABkAAAAZAQMAAAD+JxcgAAAAAXNSR0IB2cksfwAAAAlwSFlzAAALEwAACxMBAJqcGAAAAAZQTFRFAAAATU1NkJ+rOQAAAAJ0Uk5TAP9bkSK1AAAANElEQVR4nGNggABGEMEEIlhABAeI+AASF0AlHmAqA4kzKAAx8wGQuAMKwd6AoYzBAWonAwAcLwTgNfJ3RQAAAABJRU5ErkJggg=="}],"tool":"Cursor"}');

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			id: moduleId,
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = __webpack_modules__;
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/chunk loaded */
/******/ 	(() => {
/******/ 		var deferred = [];
/******/ 		__webpack_require__.O = (result, chunkIds, fn, priority) => {
/******/ 			if(chunkIds) {
/******/ 				priority = priority || 0;
/******/ 				for(var i = deferred.length; i > 0 && deferred[i - 1][2] > priority; i--) deferred[i] = deferred[i - 1];
/******/ 				deferred[i] = [chunkIds, fn, priority];
/******/ 				return;
/******/ 			}
/******/ 			var notFulfilled = Infinity;
/******/ 			for (var i = 0; i < deferred.length; i++) {
/******/ 				var [chunkIds, fn, priority] = deferred[i];
/******/ 				var fulfilled = true;
/******/ 				for (var j = 0; j < chunkIds.length; j++) {
/******/ 					if ((priority & 1 === 0 || notFulfilled >= priority) && Object.keys(__webpack_require__.O).every((key) => (__webpack_require__.O[key](chunkIds[j])))) {
/******/ 						chunkIds.splice(j--, 1);
/******/ 					} else {
/******/ 						fulfilled = false;
/******/ 						if(priority < notFulfilled) notFulfilled = priority;
/******/ 					}
/******/ 				}
/******/ 				if(fulfilled) {
/******/ 					deferred.splice(i--, 1)
/******/ 					var r = fn();
/******/ 					if (r !== undefined) result = r;
/******/ 				}
/******/ 			}
/******/ 			return result;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/compat get default export */
/******/ 	(() => {
/******/ 		// getDefaultExport function for compatibility with non-harmony modules
/******/ 		__webpack_require__.n = (module) => {
/******/ 			var getter = module && module.__esModule ?
/******/ 				() => (module['default']) :
/******/ 				() => (module);
/******/ 			__webpack_require__.d(getter, { a: getter });
/******/ 			return getter;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/global */
/******/ 	(() => {
/******/ 		__webpack_require__.g = (function() {
/******/ 			if (typeof globalThis === 'object') return globalThis;
/******/ 			try {
/******/ 				return this || new Function('return this')();
/******/ 			} catch (e) {
/******/ 				if (typeof window === 'object') return window;
/******/ 			}
/******/ 		})();
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/jsonp chunk loading */
/******/ 	(() => {
/******/ 		// no baseURI
/******/ 		
/******/ 		// object to store loaded and loading chunks
/******/ 		// undefined = chunk not loaded, null = chunk preloaded/prefetched
/******/ 		// [resolve, reject, Promise] = chunk loading, 0 = chunk loaded
/******/ 		var installedChunks = {
/******/ 			"/js/main": 0,
/******/ 			"css/base/plugins/extensions/ext-component-media-player": 0,
/******/ 			"css/base/plugins/extensions/ext-component-drag-drop": 0,
/******/ 			"css/base/plugins/extensions/ext-component-context-menu": 0,
/******/ 			"css/base/plugins/charts/chart-apex": 0,
/******/ 			"css/style": 0,
/******/ 			"css/overrides": 0,
/******/ 			"css/core": 0,
/******/ 			"css/base/themes/dark-layout": 0,
/******/ 			"css/base/core/mixins/transitions": 0,
/******/ 			"css/base/core/mixins/main-menu-mixin": 0,
/******/ 			"css/base/core/mixins/hex2rgb": 0,
/******/ 			"css/base/core/mixins/alert": 0,
/******/ 			"css/base/core/menu/menu-types/vertical-overlay-menu": 0,
/******/ 			"css/base/core/menu/menu-types/vertical-menu": 0,
/******/ 			"css/base/core/menu/menu-types/horizontal-menu": 0,
/******/ 			"css/base/core/colors/palette-variables": 0,
/******/ 			"css/base/core/colors/palette-noui": 0,
/******/ 			"css/base/core/colors/palette-gradient": 0,
/******/ 			"css/base/pages/ui-feather": 0,
/******/ 			"css/base/pages/page-profile": 0,
/******/ 			"css/base/pages/page-pricing": 0,
/******/ 			"css/base/pages/page-misc": 0,
/******/ 			"css/base/pages/page-knowledge-base": 0,
/******/ 			"css/base/pages/page-faq": 0,
/******/ 			"css/base/pages/page-coming-soon": 0,
/******/ 			"css/base/pages/page-blog": 0,
/******/ 			"css/base/pages/modal-create-app": 0,
/******/ 			"css/base/pages/dashboard-ecommerce": 0,
/******/ 			"css/base/pages/authentication": 0,
/******/ 			"css/base/pages/app-todo": 0,
/******/ 			"css/base/pages/app-kanban": 0,
/******/ 			"css/base/pages/app-invoice": 0,
/******/ 			"css/base/pages/app-invoice-print": 0,
/******/ 			"css/base/pages/app-invoice-list": 0,
/******/ 			"css/base/pages/app-file-manager": 0,
/******/ 			"css/base/pages/app-email": 0,
/******/ 			"css/base/pages/app-ecommerce": 0,
/******/ 			"css/base/pages/app-ecommerce-details": 0,
/******/ 			"css/base/pages/app-chat": 0,
/******/ 			"css/base/pages/app-chat-list": 0,
/******/ 			"css/base/pages/app-calendar": 0,
/******/ 			"css/base/plugins/ui/coming-soon": 0,
/******/ 			"css/base/plugins/maps/map-leaflet": 0,
/******/ 			"css/base/plugins/forms/pickers/form-pickadate": 0,
/******/ 			"css/base/plugins/forms/pickers/form-flat-pickr": 0,
/******/ 			"css/base/plugins/forms/form-wizard": 0,
/******/ 			"css/base/plugins/forms/form-validation": 0,
/******/ 			"css/base/plugins/forms/form-quill-editor": 0,
/******/ 			"css/base/plugins/forms/form-number-input": 0,
/******/ 			"css/base/plugins/forms/form-file-uploader": 0,
/******/ 			"css/base/plugins/extensions/ext-component-tree": 0,
/******/ 			"css/base/plugins/extensions/ext-component-tour": 0,
/******/ 			"css/base/plugins/extensions/ext-component-toastr": 0,
/******/ 			"css/base/plugins/extensions/ext-component-swiper": 0,
/******/ 			"css/base/plugins/extensions/ext-component-sweet-alerts": 0,
/******/ 			"css/base/plugins/extensions/ext-component-sliders": 0,
/******/ 			"css/base/plugins/extensions/ext-component-ratings": 0
/******/ 		};
/******/ 		
/******/ 		// no chunk on demand loading
/******/ 		
/******/ 		// no prefetching
/******/ 		
/******/ 		// no preloaded
/******/ 		
/******/ 		// no HMR
/******/ 		
/******/ 		// no HMR manifest
/******/ 		
/******/ 		__webpack_require__.O.j = (chunkId) => (installedChunks[chunkId] === 0);
/******/ 		
/******/ 		// install a JSONP callback for chunk loading
/******/ 		var webpackJsonpCallback = (parentChunkLoadingFunction, data) => {
/******/ 			var [chunkIds, moreModules, runtime] = data;
/******/ 			// add "moreModules" to the modules object,
/******/ 			// then flag all "chunkIds" as loaded and fire callback
/******/ 			var moduleId, chunkId, i = 0;
/******/ 			if(chunkIds.some((id) => (installedChunks[id] !== 0))) {
/******/ 				for(moduleId in moreModules) {
/******/ 					if(__webpack_require__.o(moreModules, moduleId)) {
/******/ 						__webpack_require__.m[moduleId] = moreModules[moduleId];
/******/ 					}
/******/ 				}
/******/ 				if(runtime) var result = runtime(__webpack_require__);
/******/ 			}
/******/ 			if(parentChunkLoadingFunction) parentChunkLoadingFunction(data);
/******/ 			for(;i < chunkIds.length; i++) {
/******/ 				chunkId = chunkIds[i];
/******/ 				if(__webpack_require__.o(installedChunks, chunkId) && installedChunks[chunkId]) {
/******/ 					installedChunks[chunkId][0]();
/******/ 				}
/******/ 				installedChunks[chunkId] = 0;
/******/ 			}
/******/ 			return __webpack_require__.O(result);
/******/ 		}
/******/ 		
/******/ 		var chunkLoadingGlobal = self["webpackChunk"] = self["webpackChunk"] || [];
/******/ 		chunkLoadingGlobal.forEach(webpackJsonpCallback.bind(null, 0));
/******/ 		chunkLoadingGlobal.push = webpackJsonpCallback.bind(null, chunkLoadingGlobal.push.bind(chunkLoadingGlobal));
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/nonce */
/******/ 	(() => {
/******/ 		__webpack_require__.nc = undefined;
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module depends on other loaded chunks and execution need to be delayed
/******/ 	__webpack_require__.O(undefined, ["css/base/plugins/extensions/ext-component-media-player","css/base/plugins/extensions/ext-component-drag-drop","css/base/plugins/extensions/ext-component-context-menu","css/base/plugins/charts/chart-apex","css/style","css/overrides","css/core","css/base/themes/dark-layout","css/base/core/mixins/transitions","css/base/core/mixins/main-menu-mixin","css/base/core/mixins/hex2rgb","css/base/core/mixins/alert","css/base/core/menu/menu-types/vertical-overlay-menu","css/base/core/menu/menu-types/vertical-menu","css/base/core/menu/menu-types/horizontal-menu","css/base/core/colors/palette-variables","css/base/core/colors/palette-noui","css/base/core/colors/palette-gradient","css/base/pages/ui-feather","css/base/pages/page-profile","css/base/pages/page-pricing","css/base/pages/page-misc","css/base/pages/page-knowledge-base","css/base/pages/page-faq","css/base/pages/page-coming-soon","css/base/pages/page-blog","css/base/pages/modal-create-app","css/base/pages/dashboard-ecommerce","css/base/pages/authentication","css/base/pages/app-todo","css/base/pages/app-kanban","css/base/pages/app-invoice","css/base/pages/app-invoice-print","css/base/pages/app-invoice-list","css/base/pages/app-file-manager","css/base/pages/app-email","css/base/pages/app-ecommerce","css/base/pages/app-ecommerce-details","css/base/pages/app-chat","css/base/pages/app-chat-list","css/base/pages/app-calendar","css/base/plugins/ui/coming-soon","css/base/plugins/maps/map-leaflet","css/base/plugins/forms/pickers/form-pickadate","css/base/plugins/forms/pickers/form-flat-pickr","css/base/plugins/forms/form-wizard","css/base/plugins/forms/form-validation","css/base/plugins/forms/form-quill-editor","css/base/plugins/forms/form-number-input","css/base/plugins/forms/form-file-uploader","css/base/plugins/extensions/ext-component-tree","css/base/plugins/extensions/ext-component-tour","css/base/plugins/extensions/ext-component-toastr","css/base/plugins/extensions/ext-component-swiper","css/base/plugins/extensions/ext-component-sweet-alerts","css/base/plugins/extensions/ext-component-sliders","css/base/plugins/extensions/ext-component-ratings"], () => (__webpack_require__("./src/main.js")))
/******/ 	__webpack_require__.O(undefined, ["css/base/plugins/extensions/ext-component-media-player","css/base/plugins/extensions/ext-component-drag-drop","css/base/plugins/extensions/ext-component-context-menu","css/base/plugins/charts/chart-apex","css/style","css/overrides","css/core","css/base/themes/dark-layout","css/base/core/mixins/transitions","css/base/core/mixins/main-menu-mixin","css/base/core/mixins/hex2rgb","css/base/core/mixins/alert","css/base/core/menu/menu-types/vertical-overlay-menu","css/base/core/menu/menu-types/vertical-menu","css/base/core/menu/menu-types/horizontal-menu","css/base/core/colors/palette-variables","css/base/core/colors/palette-noui","css/base/core/colors/palette-gradient","css/base/pages/ui-feather","css/base/pages/page-profile","css/base/pages/page-pricing","css/base/pages/page-misc","css/base/pages/page-knowledge-base","css/base/pages/page-faq","css/base/pages/page-coming-soon","css/base/pages/page-blog","css/base/pages/modal-create-app","css/base/pages/dashboard-ecommerce","css/base/pages/authentication","css/base/pages/app-todo","css/base/pages/app-kanban","css/base/pages/app-invoice","css/base/pages/app-invoice-print","css/base/pages/app-invoice-list","css/base/pages/app-file-manager","css/base/pages/app-email","css/base/pages/app-ecommerce","css/base/pages/app-ecommerce-details","css/base/pages/app-chat","css/base/pages/app-chat-list","css/base/pages/app-calendar","css/base/plugins/ui/coming-soon","css/base/plugins/maps/map-leaflet","css/base/plugins/forms/pickers/form-pickadate","css/base/plugins/forms/pickers/form-flat-pickr","css/base/plugins/forms/form-wizard","css/base/plugins/forms/form-validation","css/base/plugins/forms/form-quill-editor","css/base/plugins/forms/form-number-input","css/base/plugins/forms/form-file-uploader","css/base/plugins/extensions/ext-component-tree","css/base/plugins/extensions/ext-component-tour","css/base/plugins/extensions/ext-component-toastr","css/base/plugins/extensions/ext-component-swiper","css/base/plugins/extensions/ext-component-sweet-alerts","css/base/plugins/extensions/ext-component-sliders","css/base/plugins/extensions/ext-component-ratings"], () => (__webpack_require__("./resources/scss/base/plugins/charts/chart-apex.scss")))
/******/ 	__webpack_require__.O(undefined, ["css/base/plugins/extensions/ext-component-media-player","css/base/plugins/extensions/ext-component-drag-drop","css/base/plugins/extensions/ext-component-context-menu","css/base/plugins/charts/chart-apex","css/style","css/overrides","css/core","css/base/themes/dark-layout","css/base/core/mixins/transitions","css/base/core/mixins/main-menu-mixin","css/base/core/mixins/hex2rgb","css/base/core/mixins/alert","css/base/core/menu/menu-types/vertical-overlay-menu","css/base/core/menu/menu-types/vertical-menu","css/base/core/menu/menu-types/horizontal-menu","css/base/core/colors/palette-variables","css/base/core/colors/palette-noui","css/base/core/colors/palette-gradient","css/base/pages/ui-feather","css/base/pages/page-profile","css/base/pages/page-pricing","css/base/pages/page-misc","css/base/pages/page-knowledge-base","css/base/pages/page-faq","css/base/pages/page-coming-soon","css/base/pages/page-blog","css/base/pages/modal-create-app","css/base/pages/dashboard-ecommerce","css/base/pages/authentication","css/base/pages/app-todo","css/base/pages/app-kanban","css/base/pages/app-invoice","css/base/pages/app-invoice-print","css/base/pages/app-invoice-list","css/base/pages/app-file-manager","css/base/pages/app-email","css/base/pages/app-ecommerce","css/base/pages/app-ecommerce-details","css/base/pages/app-chat","css/base/pages/app-chat-list","css/base/pages/app-calendar","css/base/plugins/ui/coming-soon","css/base/plugins/maps/map-leaflet","css/base/plugins/forms/pickers/form-pickadate","css/base/plugins/forms/pickers/form-flat-pickr","css/base/plugins/forms/form-wizard","css/base/plugins/forms/form-validation","css/base/plugins/forms/form-quill-editor","css/base/plugins/forms/form-number-input","css/base/plugins/forms/form-file-uploader","css/base/plugins/extensions/ext-component-tree","css/base/plugins/extensions/ext-component-tour","css/base/plugins/extensions/ext-component-toastr","css/base/plugins/extensions/ext-component-swiper","css/base/plugins/extensions/ext-component-sweet-alerts","css/base/plugins/extensions/ext-component-sliders","css/base/plugins/extensions/ext-component-ratings"], () => (__webpack_require__("./resources/scss/base/plugins/extensions/ext-component-context-menu.scss")))
/******/ 	__webpack_require__.O(undefined, ["css/base/plugins/extensions/ext-component-media-player","css/base/plugins/extensions/ext-component-drag-drop","css/base/plugins/extensions/ext-component-context-menu","css/base/plugins/charts/chart-apex","css/style","css/overrides","css/core","css/base/themes/dark-layout","css/base/core/mixins/transitions","css/base/core/mixins/main-menu-mixin","css/base/core/mixins/hex2rgb","css/base/core/mixins/alert","css/base/core/menu/menu-types/vertical-overlay-menu","css/base/core/menu/menu-types/vertical-menu","css/base/core/menu/menu-types/horizontal-menu","css/base/core/colors/palette-variables","css/base/core/colors/palette-noui","css/base/core/colors/palette-gradient","css/base/pages/ui-feather","css/base/pages/page-profile","css/base/pages/page-pricing","css/base/pages/page-misc","css/base/pages/page-knowledge-base","css/base/pages/page-faq","css/base/pages/page-coming-soon","css/base/pages/page-blog","css/base/pages/modal-create-app","css/base/pages/dashboard-ecommerce","css/base/pages/authentication","css/base/pages/app-todo","css/base/pages/app-kanban","css/base/pages/app-invoice","css/base/pages/app-invoice-print","css/base/pages/app-invoice-list","css/base/pages/app-file-manager","css/base/pages/app-email","css/base/pages/app-ecommerce","css/base/pages/app-ecommerce-details","css/base/pages/app-chat","css/base/pages/app-chat-list","css/base/pages/app-calendar","css/base/plugins/ui/coming-soon","css/base/plugins/maps/map-leaflet","css/base/plugins/forms/pickers/form-pickadate","css/base/plugins/forms/pickers/form-flat-pickr","css/base/plugins/forms/form-wizard","css/base/plugins/forms/form-validation","css/base/plugins/forms/form-quill-editor","css/base/plugins/forms/form-number-input","css/base/plugins/forms/form-file-uploader","css/base/plugins/extensions/ext-component-tree","css/base/plugins/extensions/ext-component-tour","css/base/plugins/extensions/ext-component-toastr","css/base/plugins/extensions/ext-component-swiper","css/base/plugins/extensions/ext-component-sweet-alerts","css/base/plugins/extensions/ext-component-sliders","css/base/plugins/extensions/ext-component-ratings"], () => (__webpack_require__("./resources/scss/base/plugins/extensions/ext-component-drag-drop.scss")))
/******/ 	__webpack_require__.O(undefined, ["css/base/plugins/extensions/ext-component-media-player","css/base/plugins/extensions/ext-component-drag-drop","css/base/plugins/extensions/ext-component-context-menu","css/base/plugins/charts/chart-apex","css/style","css/overrides","css/core","css/base/themes/dark-layout","css/base/core/mixins/transitions","css/base/core/mixins/main-menu-mixin","css/base/core/mixins/hex2rgb","css/base/core/mixins/alert","css/base/core/menu/menu-types/vertical-overlay-menu","css/base/core/menu/menu-types/vertical-menu","css/base/core/menu/menu-types/horizontal-menu","css/base/core/colors/palette-variables","css/base/core/colors/palette-noui","css/base/core/colors/palette-gradient","css/base/pages/ui-feather","css/base/pages/page-profile","css/base/pages/page-pricing","css/base/pages/page-misc","css/base/pages/page-knowledge-base","css/base/pages/page-faq","css/base/pages/page-coming-soon","css/base/pages/page-blog","css/base/pages/modal-create-app","css/base/pages/dashboard-ecommerce","css/base/pages/authentication","css/base/pages/app-todo","css/base/pages/app-kanban","css/base/pages/app-invoice","css/base/pages/app-invoice-print","css/base/pages/app-invoice-list","css/base/pages/app-file-manager","css/base/pages/app-email","css/base/pages/app-ecommerce","css/base/pages/app-ecommerce-details","css/base/pages/app-chat","css/base/pages/app-chat-list","css/base/pages/app-calendar","css/base/plugins/ui/coming-soon","css/base/plugins/maps/map-leaflet","css/base/plugins/forms/pickers/form-pickadate","css/base/plugins/forms/pickers/form-flat-pickr","css/base/plugins/forms/form-wizard","css/base/plugins/forms/form-validation","css/base/plugins/forms/form-quill-editor","css/base/plugins/forms/form-number-input","css/base/plugins/forms/form-file-uploader","css/base/plugins/extensions/ext-component-tree","css/base/plugins/extensions/ext-component-tour","css/base/plugins/extensions/ext-component-toastr","css/base/plugins/extensions/ext-component-swiper","css/base/plugins/extensions/ext-component-sweet-alerts","css/base/plugins/extensions/ext-component-sliders","css/base/plugins/extensions/ext-component-ratings"], () => (__webpack_require__("./resources/scss/base/plugins/extensions/ext-component-media-player.scss")))
/******/ 	__webpack_require__.O(undefined, ["css/base/plugins/extensions/ext-component-media-player","css/base/plugins/extensions/ext-component-drag-drop","css/base/plugins/extensions/ext-component-context-menu","css/base/plugins/charts/chart-apex","css/style","css/overrides","css/core","css/base/themes/dark-layout","css/base/core/mixins/transitions","css/base/core/mixins/main-menu-mixin","css/base/core/mixins/hex2rgb","css/base/core/mixins/alert","css/base/core/menu/menu-types/vertical-overlay-menu","css/base/core/menu/menu-types/vertical-menu","css/base/core/menu/menu-types/horizontal-menu","css/base/core/colors/palette-variables","css/base/core/colors/palette-noui","css/base/core/colors/palette-gradient","css/base/pages/ui-feather","css/base/pages/page-profile","css/base/pages/page-pricing","css/base/pages/page-misc","css/base/pages/page-knowledge-base","css/base/pages/page-faq","css/base/pages/page-coming-soon","css/base/pages/page-blog","css/base/pages/modal-create-app","css/base/pages/dashboard-ecommerce","css/base/pages/authentication","css/base/pages/app-todo","css/base/pages/app-kanban","css/base/pages/app-invoice","css/base/pages/app-invoice-print","css/base/pages/app-invoice-list","css/base/pages/app-file-manager","css/base/pages/app-email","css/base/pages/app-ecommerce","css/base/pages/app-ecommerce-details","css/base/pages/app-chat","css/base/pages/app-chat-list","css/base/pages/app-calendar","css/base/plugins/ui/coming-soon","css/base/plugins/maps/map-leaflet","css/base/plugins/forms/pickers/form-pickadate","css/base/plugins/forms/pickers/form-flat-pickr","css/base/plugins/forms/form-wizard","css/base/plugins/forms/form-validation","css/base/plugins/forms/form-quill-editor","css/base/plugins/forms/form-number-input","css/base/plugins/forms/form-file-uploader","css/base/plugins/extensions/ext-component-tree","css/base/plugins/extensions/ext-component-tour","css/base/plugins/extensions/ext-component-toastr","css/base/plugins/extensions/ext-component-swiper","css/base/plugins/extensions/ext-component-sweet-alerts","css/base/plugins/extensions/ext-component-sliders","css/base/plugins/extensions/ext-component-ratings"], () => (__webpack_require__("./resources/scss/base/plugins/extensions/ext-component-ratings.scss")))
/******/ 	__webpack_require__.O(undefined, ["css/base/plugins/extensions/ext-component-media-player","css/base/plugins/extensions/ext-component-drag-drop","css/base/plugins/extensions/ext-component-context-menu","css/base/plugins/charts/chart-apex","css/style","css/overrides","css/core","css/base/themes/dark-layout","css/base/core/mixins/transitions","css/base/core/mixins/main-menu-mixin","css/base/core/mixins/hex2rgb","css/base/core/mixins/alert","css/base/core/menu/menu-types/vertical-overlay-menu","css/base/core/menu/menu-types/vertical-menu","css/base/core/menu/menu-types/horizontal-menu","css/base/core/colors/palette-variables","css/base/core/colors/palette-noui","css/base/core/colors/palette-gradient","css/base/pages/ui-feather","css/base/pages/page-profile","css/base/pages/page-pricing","css/base/pages/page-misc","css/base/pages/page-knowledge-base","css/base/pages/page-faq","css/base/pages/page-coming-soon","css/base/pages/page-blog","css/base/pages/modal-create-app","css/base/pages/dashboard-ecommerce","css/base/pages/authentication","css/base/pages/app-todo","css/base/pages/app-kanban","css/base/pages/app-invoice","css/base/pages/app-invoice-print","css/base/pages/app-invoice-list","css/base/pages/app-file-manager","css/base/pages/app-email","css/base/pages/app-ecommerce","css/base/pages/app-ecommerce-details","css/base/pages/app-chat","css/base/pages/app-chat-list","css/base/pages/app-calendar","css/base/plugins/ui/coming-soon","css/base/plugins/maps/map-leaflet","css/base/plugins/forms/pickers/form-pickadate","css/base/plugins/forms/pickers/form-flat-pickr","css/base/plugins/forms/form-wizard","css/base/plugins/forms/form-validation","css/base/plugins/forms/form-quill-editor","css/base/plugins/forms/form-number-input","css/base/plugins/forms/form-file-uploader","css/base/plugins/extensions/ext-component-tree","css/base/plugins/extensions/ext-component-tour","css/base/plugins/extensions/ext-component-toastr","css/base/plugins/extensions/ext-component-swiper","css/base/plugins/extensions/ext-component-sweet-alerts","css/base/plugins/extensions/ext-component-sliders","css/base/plugins/extensions/ext-component-ratings"], () => (__webpack_require__("./resources/scss/base/plugins/extensions/ext-component-sliders.scss")))
/******/ 	__webpack_require__.O(undefined, ["css/base/plugins/extensions/ext-component-media-player","css/base/plugins/extensions/ext-component-drag-drop","css/base/plugins/extensions/ext-component-context-menu","css/base/plugins/charts/chart-apex","css/style","css/overrides","css/core","css/base/themes/dark-layout","css/base/core/mixins/transitions","css/base/core/mixins/main-menu-mixin","css/base/core/mixins/hex2rgb","css/base/core/mixins/alert","css/base/core/menu/menu-types/vertical-overlay-menu","css/base/core/menu/menu-types/vertical-menu","css/base/core/menu/menu-types/horizontal-menu","css/base/core/colors/palette-variables","css/base/core/colors/palette-noui","css/base/core/colors/palette-gradient","css/base/pages/ui-feather","css/base/pages/page-profile","css/base/pages/page-pricing","css/base/pages/page-misc","css/base/pages/page-knowledge-base","css/base/pages/page-faq","css/base/pages/page-coming-soon","css/base/pages/page-blog","css/base/pages/modal-create-app","css/base/pages/dashboard-ecommerce","css/base/pages/authentication","css/base/pages/app-todo","css/base/pages/app-kanban","css/base/pages/app-invoice","css/base/pages/app-invoice-print","css/base/pages/app-invoice-list","css/base/pages/app-file-manager","css/base/pages/app-email","css/base/pages/app-ecommerce","css/base/pages/app-ecommerce-details","css/base/pages/app-chat","css/base/pages/app-chat-list","css/base/pages/app-calendar","css/base/plugins/ui/coming-soon","css/base/plugins/maps/map-leaflet","css/base/plugins/forms/pickers/form-pickadate","css/base/plugins/forms/pickers/form-flat-pickr","css/base/plugins/forms/form-wizard","css/base/plugins/forms/form-validation","css/base/plugins/forms/form-quill-editor","css/base/plugins/forms/form-number-input","css/base/plugins/forms/form-file-uploader","css/base/plugins/extensions/ext-component-tree","css/base/plugins/extensions/ext-component-tour","css/base/plugins/extensions/ext-component-toastr","css/base/plugins/extensions/ext-component-swiper","css/base/plugins/extensions/ext-component-sweet-alerts","css/base/plugins/extensions/ext-component-sliders","css/base/plugins/extensions/ext-component-ratings"], () => (__webpack_require__("./resources/scss/base/plugins/extensions/ext-component-sweet-alerts.scss")))
/******/ 	__webpack_require__.O(undefined, ["css/base/plugins/extensions/ext-component-media-player","css/base/plugins/extensions/ext-component-drag-drop","css/base/plugins/extensions/ext-component-context-menu","css/base/plugins/charts/chart-apex","css/style","css/overrides","css/core","css/base/themes/dark-layout","css/base/core/mixins/transitions","css/base/core/mixins/main-menu-mixin","css/base/core/mixins/hex2rgb","css/base/core/mixins/alert","css/base/core/menu/menu-types/vertical-overlay-menu","css/base/core/menu/menu-types/vertical-menu","css/base/core/menu/menu-types/horizontal-menu","css/base/core/colors/palette-variables","css/base/core/colors/palette-noui","css/base/core/colors/palette-gradient","css/base/pages/ui-feather","css/base/pages/page-profile","css/base/pages/page-pricing","css/base/pages/page-misc","css/base/pages/page-knowledge-base","css/base/pages/page-faq","css/base/pages/page-coming-soon","css/base/pages/page-blog","css/base/pages/modal-create-app","css/base/pages/dashboard-ecommerce","css/base/pages/authentication","css/base/pages/app-todo","css/base/pages/app-kanban","css/base/pages/app-invoice","css/base/pages/app-invoice-print","css/base/pages/app-invoice-list","css/base/pages/app-file-manager","css/base/pages/app-email","css/base/pages/app-ecommerce","css/base/pages/app-ecommerce-details","css/base/pages/app-chat","css/base/pages/app-chat-list","css/base/pages/app-calendar","css/base/plugins/ui/coming-soon","css/base/plugins/maps/map-leaflet","css/base/plugins/forms/pickers/form-pickadate","css/base/plugins/forms/pickers/form-flat-pickr","css/base/plugins/forms/form-wizard","css/base/plugins/forms/form-validation","css/base/plugins/forms/form-quill-editor","css/base/plugins/forms/form-number-input","css/base/plugins/forms/form-file-uploader","css/base/plugins/extensions/ext-component-tree","css/base/plugins/extensions/ext-component-tour","css/base/plugins/extensions/ext-component-toastr","css/base/plugins/extensions/ext-component-swiper","css/base/plugins/extensions/ext-component-sweet-alerts","css/base/plugins/extensions/ext-component-sliders","css/base/plugins/extensions/ext-component-ratings"], () => (__webpack_require__("./resources/scss/base/plugins/extensions/ext-component-swiper.scss")))
/******/ 	__webpack_require__.O(undefined, ["css/base/plugins/extensions/ext-component-media-player","css/base/plugins/extensions/ext-component-drag-drop","css/base/plugins/extensions/ext-component-context-menu","css/base/plugins/charts/chart-apex","css/style","css/overrides","css/core","css/base/themes/dark-layout","css/base/core/mixins/transitions","css/base/core/mixins/main-menu-mixin","css/base/core/mixins/hex2rgb","css/base/core/mixins/alert","css/base/core/menu/menu-types/vertical-overlay-menu","css/base/core/menu/menu-types/vertical-menu","css/base/core/menu/menu-types/horizontal-menu","css/base/core/colors/palette-variables","css/base/core/colors/palette-noui","css/base/core/colors/palette-gradient","css/base/pages/ui-feather","css/base/pages/page-profile","css/base/pages/page-pricing","css/base/pages/page-misc","css/base/pages/page-knowledge-base","css/base/pages/page-faq","css/base/pages/page-coming-soon","css/base/pages/page-blog","css/base/pages/modal-create-app","css/base/pages/dashboard-ecommerce","css/base/pages/authentication","css/base/pages/app-todo","css/base/pages/app-kanban","css/base/pages/app-invoice","css/base/pages/app-invoice-print","css/base/pages/app-invoice-list","css/base/pages/app-file-manager","css/base/pages/app-email","css/base/pages/app-ecommerce","css/base/pages/app-ecommerce-details","css/base/pages/app-chat","css/base/pages/app-chat-list","css/base/pages/app-calendar","css/base/plugins/ui/coming-soon","css/base/plugins/maps/map-leaflet","css/base/plugins/forms/pickers/form-pickadate","css/base/plugins/forms/pickers/form-flat-pickr","css/base/plugins/forms/form-wizard","css/base/plugins/forms/form-validation","css/base/plugins/forms/form-quill-editor","css/base/plugins/forms/form-number-input","css/base/plugins/forms/form-file-uploader","css/base/plugins/extensions/ext-component-tree","css/base/plugins/extensions/ext-component-tour","css/base/plugins/extensions/ext-component-toastr","css/base/plugins/extensions/ext-component-swiper","css/base/plugins/extensions/ext-component-sweet-alerts","css/base/plugins/extensions/ext-component-sliders","css/base/plugins/extensions/ext-component-ratings"], () => (__webpack_require__("./resources/scss/base/plugins/extensions/ext-component-toastr.scss")))
/******/ 	__webpack_require__.O(undefined, ["css/base/plugins/extensions/ext-component-media-player","css/base/plugins/extensions/ext-component-drag-drop","css/base/plugins/extensions/ext-component-context-menu","css/base/plugins/charts/chart-apex","css/style","css/overrides","css/core","css/base/themes/dark-layout","css/base/core/mixins/transitions","css/base/core/mixins/main-menu-mixin","css/base/core/mixins/hex2rgb","css/base/core/mixins/alert","css/base/core/menu/menu-types/vertical-overlay-menu","css/base/core/menu/menu-types/vertical-menu","css/base/core/menu/menu-types/horizontal-menu","css/base/core/colors/palette-variables","css/base/core/colors/palette-noui","css/base/core/colors/palette-gradient","css/base/pages/ui-feather","css/base/pages/page-profile","css/base/pages/page-pricing","css/base/pages/page-misc","css/base/pages/page-knowledge-base","css/base/pages/page-faq","css/base/pages/page-coming-soon","css/base/pages/page-blog","css/base/pages/modal-create-app","css/base/pages/dashboard-ecommerce","css/base/pages/authentication","css/base/pages/app-todo","css/base/pages/app-kanban","css/base/pages/app-invoice","css/base/pages/app-invoice-print","css/base/pages/app-invoice-list","css/base/pages/app-file-manager","css/base/pages/app-email","css/base/pages/app-ecommerce","css/base/pages/app-ecommerce-details","css/base/pages/app-chat","css/base/pages/app-chat-list","css/base/pages/app-calendar","css/base/plugins/ui/coming-soon","css/base/plugins/maps/map-leaflet","css/base/plugins/forms/pickers/form-pickadate","css/base/plugins/forms/pickers/form-flat-pickr","css/base/plugins/forms/form-wizard","css/base/plugins/forms/form-validation","css/base/plugins/forms/form-quill-editor","css/base/plugins/forms/form-number-input","css/base/plugins/forms/form-file-uploader","css/base/plugins/extensions/ext-component-tree","css/base/plugins/extensions/ext-component-tour","css/base/plugins/extensions/ext-component-toastr","css/base/plugins/extensions/ext-component-swiper","css/base/plugins/extensions/ext-component-sweet-alerts","css/base/plugins/extensions/ext-component-sliders","css/base/plugins/extensions/ext-component-ratings"], () => (__webpack_require__("./resources/scss/base/plugins/extensions/ext-component-tour.scss")))
/******/ 	__webpack_require__.O(undefined, ["css/base/plugins/extensions/ext-component-media-player","css/base/plugins/extensions/ext-component-drag-drop","css/base/plugins/extensions/ext-component-context-menu","css/base/plugins/charts/chart-apex","css/style","css/overrides","css/core","css/base/themes/dark-layout","css/base/core/mixins/transitions","css/base/core/mixins/main-menu-mixin","css/base/core/mixins/hex2rgb","css/base/core/mixins/alert","css/base/core/menu/menu-types/vertical-overlay-menu","css/base/core/menu/menu-types/vertical-menu","css/base/core/menu/menu-types/horizontal-menu","css/base/core/colors/palette-variables","css/base/core/colors/palette-noui","css/base/core/colors/palette-gradient","css/base/pages/ui-feather","css/base/pages/page-profile","css/base/pages/page-pricing","css/base/pages/page-misc","css/base/pages/page-knowledge-base","css/base/pages/page-faq","css/base/pages/page-coming-soon","css/base/pages/page-blog","css/base/pages/modal-create-app","css/base/pages/dashboard-ecommerce","css/base/pages/authentication","css/base/pages/app-todo","css/base/pages/app-kanban","css/base/pages/app-invoice","css/base/pages/app-invoice-print","css/base/pages/app-invoice-list","css/base/pages/app-file-manager","css/base/pages/app-email","css/base/pages/app-ecommerce","css/base/pages/app-ecommerce-details","css/base/pages/app-chat","css/base/pages/app-chat-list","css/base/pages/app-calendar","css/base/plugins/ui/coming-soon","css/base/plugins/maps/map-leaflet","css/base/plugins/forms/pickers/form-pickadate","css/base/plugins/forms/pickers/form-flat-pickr","css/base/plugins/forms/form-wizard","css/base/plugins/forms/form-validation","css/base/plugins/forms/form-quill-editor","css/base/plugins/forms/form-number-input","css/base/plugins/forms/form-file-uploader","css/base/plugins/extensions/ext-component-tree","css/base/plugins/extensions/ext-component-tour","css/base/plugins/extensions/ext-component-toastr","css/base/plugins/extensions/ext-component-swiper","css/base/plugins/extensions/ext-component-sweet-alerts","css/base/plugins/extensions/ext-component-sliders","css/base/plugins/extensions/ext-component-ratings"], () => (__webpack_require__("./resources/scss/base/plugins/extensions/ext-component-tree.scss")))
/******/ 	__webpack_require__.O(undefined, ["css/base/plugins/extensions/ext-component-media-player","css/base/plugins/extensions/ext-component-drag-drop","css/base/plugins/extensions/ext-component-context-menu","css/base/plugins/charts/chart-apex","css/style","css/overrides","css/core","css/base/themes/dark-layout","css/base/core/mixins/transitions","css/base/core/mixins/main-menu-mixin","css/base/core/mixins/hex2rgb","css/base/core/mixins/alert","css/base/core/menu/menu-types/vertical-overlay-menu","css/base/core/menu/menu-types/vertical-menu","css/base/core/menu/menu-types/horizontal-menu","css/base/core/colors/palette-variables","css/base/core/colors/palette-noui","css/base/core/colors/palette-gradient","css/base/pages/ui-feather","css/base/pages/page-profile","css/base/pages/page-pricing","css/base/pages/page-misc","css/base/pages/page-knowledge-base","css/base/pages/page-faq","css/base/pages/page-coming-soon","css/base/pages/page-blog","css/base/pages/modal-create-app","css/base/pages/dashboard-ecommerce","css/base/pages/authentication","css/base/pages/app-todo","css/base/pages/app-kanban","css/base/pages/app-invoice","css/base/pages/app-invoice-print","css/base/pages/app-invoice-list","css/base/pages/app-file-manager","css/base/pages/app-email","css/base/pages/app-ecommerce","css/base/pages/app-ecommerce-details","css/base/pages/app-chat","css/base/pages/app-chat-list","css/base/pages/app-calendar","css/base/plugins/ui/coming-soon","css/base/plugins/maps/map-leaflet","css/base/plugins/forms/pickers/form-pickadate","css/base/plugins/forms/pickers/form-flat-pickr","css/base/plugins/forms/form-wizard","css/base/plugins/forms/form-validation","css/base/plugins/forms/form-quill-editor","css/base/plugins/forms/form-number-input","css/base/plugins/forms/form-file-uploader","css/base/plugins/extensions/ext-component-tree","css/base/plugins/extensions/ext-component-tour","css/base/plugins/extensions/ext-component-toastr","css/base/plugins/extensions/ext-component-swiper","css/base/plugins/extensions/ext-component-sweet-alerts","css/base/plugins/extensions/ext-component-sliders","css/base/plugins/extensions/ext-component-ratings"], () => (__webpack_require__("./resources/scss/base/plugins/forms/form-file-uploader.scss")))
/******/ 	__webpack_require__.O(undefined, ["css/base/plugins/extensions/ext-component-media-player","css/base/plugins/extensions/ext-component-drag-drop","css/base/plugins/extensions/ext-component-context-menu","css/base/plugins/charts/chart-apex","css/style","css/overrides","css/core","css/base/themes/dark-layout","css/base/core/mixins/transitions","css/base/core/mixins/main-menu-mixin","css/base/core/mixins/hex2rgb","css/base/core/mixins/alert","css/base/core/menu/menu-types/vertical-overlay-menu","css/base/core/menu/menu-types/vertical-menu","css/base/core/menu/menu-types/horizontal-menu","css/base/core/colors/palette-variables","css/base/core/colors/palette-noui","css/base/core/colors/palette-gradient","css/base/pages/ui-feather","css/base/pages/page-profile","css/base/pages/page-pricing","css/base/pages/page-misc","css/base/pages/page-knowledge-base","css/base/pages/page-faq","css/base/pages/page-coming-soon","css/base/pages/page-blog","css/base/pages/modal-create-app","css/base/pages/dashboard-ecommerce","css/base/pages/authentication","css/base/pages/app-todo","css/base/pages/app-kanban","css/base/pages/app-invoice","css/base/pages/app-invoice-print","css/base/pages/app-invoice-list","css/base/pages/app-file-manager","css/base/pages/app-email","css/base/pages/app-ecommerce","css/base/pages/app-ecommerce-details","css/base/pages/app-chat","css/base/pages/app-chat-list","css/base/pages/app-calendar","css/base/plugins/ui/coming-soon","css/base/plugins/maps/map-leaflet","css/base/plugins/forms/pickers/form-pickadate","css/base/plugins/forms/pickers/form-flat-pickr","css/base/plugins/forms/form-wizard","css/base/plugins/forms/form-validation","css/base/plugins/forms/form-quill-editor","css/base/plugins/forms/form-number-input","css/base/plugins/forms/form-file-uploader","css/base/plugins/extensions/ext-component-tree","css/base/plugins/extensions/ext-component-tour","css/base/plugins/extensions/ext-component-toastr","css/base/plugins/extensions/ext-component-swiper","css/base/plugins/extensions/ext-component-sweet-alerts","css/base/plugins/extensions/ext-component-sliders","css/base/plugins/extensions/ext-component-ratings"], () => (__webpack_require__("./resources/scss/base/plugins/forms/form-number-input.scss")))
/******/ 	__webpack_require__.O(undefined, ["css/base/plugins/extensions/ext-component-media-player","css/base/plugins/extensions/ext-component-drag-drop","css/base/plugins/extensions/ext-component-context-menu","css/base/plugins/charts/chart-apex","css/style","css/overrides","css/core","css/base/themes/dark-layout","css/base/core/mixins/transitions","css/base/core/mixins/main-menu-mixin","css/base/core/mixins/hex2rgb","css/base/core/mixins/alert","css/base/core/menu/menu-types/vertical-overlay-menu","css/base/core/menu/menu-types/vertical-menu","css/base/core/menu/menu-types/horizontal-menu","css/base/core/colors/palette-variables","css/base/core/colors/palette-noui","css/base/core/colors/palette-gradient","css/base/pages/ui-feather","css/base/pages/page-profile","css/base/pages/page-pricing","css/base/pages/page-misc","css/base/pages/page-knowledge-base","css/base/pages/page-faq","css/base/pages/page-coming-soon","css/base/pages/page-blog","css/base/pages/modal-create-app","css/base/pages/dashboard-ecommerce","css/base/pages/authentication","css/base/pages/app-todo","css/base/pages/app-kanban","css/base/pages/app-invoice","css/base/pages/app-invoice-print","css/base/pages/app-invoice-list","css/base/pages/app-file-manager","css/base/pages/app-email","css/base/pages/app-ecommerce","css/base/pages/app-ecommerce-details","css/base/pages/app-chat","css/base/pages/app-chat-list","css/base/pages/app-calendar","css/base/plugins/ui/coming-soon","css/base/plugins/maps/map-leaflet","css/base/plugins/forms/pickers/form-pickadate","css/base/plugins/forms/pickers/form-flat-pickr","css/base/plugins/forms/form-wizard","css/base/plugins/forms/form-validation","css/base/plugins/forms/form-quill-editor","css/base/plugins/forms/form-number-input","css/base/plugins/forms/form-file-uploader","css/base/plugins/extensions/ext-component-tree","css/base/plugins/extensions/ext-component-tour","css/base/plugins/extensions/ext-component-toastr","css/base/plugins/extensions/ext-component-swiper","css/base/plugins/extensions/ext-component-sweet-alerts","css/base/plugins/extensions/ext-component-sliders","css/base/plugins/extensions/ext-component-ratings"], () => (__webpack_require__("./resources/scss/base/plugins/forms/form-quill-editor.scss")))
/******/ 	__webpack_require__.O(undefined, ["css/base/plugins/extensions/ext-component-media-player","css/base/plugins/extensions/ext-component-drag-drop","css/base/plugins/extensions/ext-component-context-menu","css/base/plugins/charts/chart-apex","css/style","css/overrides","css/core","css/base/themes/dark-layout","css/base/core/mixins/transitions","css/base/core/mixins/main-menu-mixin","css/base/core/mixins/hex2rgb","css/base/core/mixins/alert","css/base/core/menu/menu-types/vertical-overlay-menu","css/base/core/menu/menu-types/vertical-menu","css/base/core/menu/menu-types/horizontal-menu","css/base/core/colors/palette-variables","css/base/core/colors/palette-noui","css/base/core/colors/palette-gradient","css/base/pages/ui-feather","css/base/pages/page-profile","css/base/pages/page-pricing","css/base/pages/page-misc","css/base/pages/page-knowledge-base","css/base/pages/page-faq","css/base/pages/page-coming-soon","css/base/pages/page-blog","css/base/pages/modal-create-app","css/base/pages/dashboard-ecommerce","css/base/pages/authentication","css/base/pages/app-todo","css/base/pages/app-kanban","css/base/pages/app-invoice","css/base/pages/app-invoice-print","css/base/pages/app-invoice-list","css/base/pages/app-file-manager","css/base/pages/app-email","css/base/pages/app-ecommerce","css/base/pages/app-ecommerce-details","css/base/pages/app-chat","css/base/pages/app-chat-list","css/base/pages/app-calendar","css/base/plugins/ui/coming-soon","css/base/plugins/maps/map-leaflet","css/base/plugins/forms/pickers/form-pickadate","css/base/plugins/forms/pickers/form-flat-pickr","css/base/plugins/forms/form-wizard","css/base/plugins/forms/form-validation","css/base/plugins/forms/form-quill-editor","css/base/plugins/forms/form-number-input","css/base/plugins/forms/form-file-uploader","css/base/plugins/extensions/ext-component-tree","css/base/plugins/extensions/ext-component-tour","css/base/plugins/extensions/ext-component-toastr","css/base/plugins/extensions/ext-component-swiper","css/base/plugins/extensions/ext-component-sweet-alerts","css/base/plugins/extensions/ext-component-sliders","css/base/plugins/extensions/ext-component-ratings"], () => (__webpack_require__("./resources/scss/base/plugins/forms/form-validation.scss")))
/******/ 	__webpack_require__.O(undefined, ["css/base/plugins/extensions/ext-component-media-player","css/base/plugins/extensions/ext-component-drag-drop","css/base/plugins/extensions/ext-component-context-menu","css/base/plugins/charts/chart-apex","css/style","css/overrides","css/core","css/base/themes/dark-layout","css/base/core/mixins/transitions","css/base/core/mixins/main-menu-mixin","css/base/core/mixins/hex2rgb","css/base/core/mixins/alert","css/base/core/menu/menu-types/vertical-overlay-menu","css/base/core/menu/menu-types/vertical-menu","css/base/core/menu/menu-types/horizontal-menu","css/base/core/colors/palette-variables","css/base/core/colors/palette-noui","css/base/core/colors/palette-gradient","css/base/pages/ui-feather","css/base/pages/page-profile","css/base/pages/page-pricing","css/base/pages/page-misc","css/base/pages/page-knowledge-base","css/base/pages/page-faq","css/base/pages/page-coming-soon","css/base/pages/page-blog","css/base/pages/modal-create-app","css/base/pages/dashboard-ecommerce","css/base/pages/authentication","css/base/pages/app-todo","css/base/pages/app-kanban","css/base/pages/app-invoice","css/base/pages/app-invoice-print","css/base/pages/app-invoice-list","css/base/pages/app-file-manager","css/base/pages/app-email","css/base/pages/app-ecommerce","css/base/pages/app-ecommerce-details","css/base/pages/app-chat","css/base/pages/app-chat-list","css/base/pages/app-calendar","css/base/plugins/ui/coming-soon","css/base/plugins/maps/map-leaflet","css/base/plugins/forms/pickers/form-pickadate","css/base/plugins/forms/pickers/form-flat-pickr","css/base/plugins/forms/form-wizard","css/base/plugins/forms/form-validation","css/base/plugins/forms/form-quill-editor","css/base/plugins/forms/form-number-input","css/base/plugins/forms/form-file-uploader","css/base/plugins/extensions/ext-component-tree","css/base/plugins/extensions/ext-component-tour","css/base/plugins/extensions/ext-component-toastr","css/base/plugins/extensions/ext-component-swiper","css/base/plugins/extensions/ext-component-sweet-alerts","css/base/plugins/extensions/ext-component-sliders","css/base/plugins/extensions/ext-component-ratings"], () => (__webpack_require__("./resources/scss/base/plugins/forms/form-wizard.scss")))
/******/ 	__webpack_require__.O(undefined, ["css/base/plugins/extensions/ext-component-media-player","css/base/plugins/extensions/ext-component-drag-drop","css/base/plugins/extensions/ext-component-context-menu","css/base/plugins/charts/chart-apex","css/style","css/overrides","css/core","css/base/themes/dark-layout","css/base/core/mixins/transitions","css/base/core/mixins/main-menu-mixin","css/base/core/mixins/hex2rgb","css/base/core/mixins/alert","css/base/core/menu/menu-types/vertical-overlay-menu","css/base/core/menu/menu-types/vertical-menu","css/base/core/menu/menu-types/horizontal-menu","css/base/core/colors/palette-variables","css/base/core/colors/palette-noui","css/base/core/colors/palette-gradient","css/base/pages/ui-feather","css/base/pages/page-profile","css/base/pages/page-pricing","css/base/pages/page-misc","css/base/pages/page-knowledge-base","css/base/pages/page-faq","css/base/pages/page-coming-soon","css/base/pages/page-blog","css/base/pages/modal-create-app","css/base/pages/dashboard-ecommerce","css/base/pages/authentication","css/base/pages/app-todo","css/base/pages/app-kanban","css/base/pages/app-invoice","css/base/pages/app-invoice-print","css/base/pages/app-invoice-list","css/base/pages/app-file-manager","css/base/pages/app-email","css/base/pages/app-ecommerce","css/base/pages/app-ecommerce-details","css/base/pages/app-chat","css/base/pages/app-chat-list","css/base/pages/app-calendar","css/base/plugins/ui/coming-soon","css/base/plugins/maps/map-leaflet","css/base/plugins/forms/pickers/form-pickadate","css/base/plugins/forms/pickers/form-flat-pickr","css/base/plugins/forms/form-wizard","css/base/plugins/forms/form-validation","css/base/plugins/forms/form-quill-editor","css/base/plugins/forms/form-number-input","css/base/plugins/forms/form-file-uploader","css/base/plugins/extensions/ext-component-tree","css/base/plugins/extensions/ext-component-tour","css/base/plugins/extensions/ext-component-toastr","css/base/plugins/extensions/ext-component-swiper","css/base/plugins/extensions/ext-component-sweet-alerts","css/base/plugins/extensions/ext-component-sliders","css/base/plugins/extensions/ext-component-ratings"], () => (__webpack_require__("./resources/scss/base/plugins/forms/pickers/form-flat-pickr.scss")))
/******/ 	__webpack_require__.O(undefined, ["css/base/plugins/extensions/ext-component-media-player","css/base/plugins/extensions/ext-component-drag-drop","css/base/plugins/extensions/ext-component-context-menu","css/base/plugins/charts/chart-apex","css/style","css/overrides","css/core","css/base/themes/dark-layout","css/base/core/mixins/transitions","css/base/core/mixins/main-menu-mixin","css/base/core/mixins/hex2rgb","css/base/core/mixins/alert","css/base/core/menu/menu-types/vertical-overlay-menu","css/base/core/menu/menu-types/vertical-menu","css/base/core/menu/menu-types/horizontal-menu","css/base/core/colors/palette-variables","css/base/core/colors/palette-noui","css/base/core/colors/palette-gradient","css/base/pages/ui-feather","css/base/pages/page-profile","css/base/pages/page-pricing","css/base/pages/page-misc","css/base/pages/page-knowledge-base","css/base/pages/page-faq","css/base/pages/page-coming-soon","css/base/pages/page-blog","css/base/pages/modal-create-app","css/base/pages/dashboard-ecommerce","css/base/pages/authentication","css/base/pages/app-todo","css/base/pages/app-kanban","css/base/pages/app-invoice","css/base/pages/app-invoice-print","css/base/pages/app-invoice-list","css/base/pages/app-file-manager","css/base/pages/app-email","css/base/pages/app-ecommerce","css/base/pages/app-ecommerce-details","css/base/pages/app-chat","css/base/pages/app-chat-list","css/base/pages/app-calendar","css/base/plugins/ui/coming-soon","css/base/plugins/maps/map-leaflet","css/base/plugins/forms/pickers/form-pickadate","css/base/plugins/forms/pickers/form-flat-pickr","css/base/plugins/forms/form-wizard","css/base/plugins/forms/form-validation","css/base/plugins/forms/form-quill-editor","css/base/plugins/forms/form-number-input","css/base/plugins/forms/form-file-uploader","css/base/plugins/extensions/ext-component-tree","css/base/plugins/extensions/ext-component-tour","css/base/plugins/extensions/ext-component-toastr","css/base/plugins/extensions/ext-component-swiper","css/base/plugins/extensions/ext-component-sweet-alerts","css/base/plugins/extensions/ext-component-sliders","css/base/plugins/extensions/ext-component-ratings"], () => (__webpack_require__("./resources/scss/base/plugins/forms/pickers/form-pickadate.scss")))
/******/ 	__webpack_require__.O(undefined, ["css/base/plugins/extensions/ext-component-media-player","css/base/plugins/extensions/ext-component-drag-drop","css/base/plugins/extensions/ext-component-context-menu","css/base/plugins/charts/chart-apex","css/style","css/overrides","css/core","css/base/themes/dark-layout","css/base/core/mixins/transitions","css/base/core/mixins/main-menu-mixin","css/base/core/mixins/hex2rgb","css/base/core/mixins/alert","css/base/core/menu/menu-types/vertical-overlay-menu","css/base/core/menu/menu-types/vertical-menu","css/base/core/menu/menu-types/horizontal-menu","css/base/core/colors/palette-variables","css/base/core/colors/palette-noui","css/base/core/colors/palette-gradient","css/base/pages/ui-feather","css/base/pages/page-profile","css/base/pages/page-pricing","css/base/pages/page-misc","css/base/pages/page-knowledge-base","css/base/pages/page-faq","css/base/pages/page-coming-soon","css/base/pages/page-blog","css/base/pages/modal-create-app","css/base/pages/dashboard-ecommerce","css/base/pages/authentication","css/base/pages/app-todo","css/base/pages/app-kanban","css/base/pages/app-invoice","css/base/pages/app-invoice-print","css/base/pages/app-invoice-list","css/base/pages/app-file-manager","css/base/pages/app-email","css/base/pages/app-ecommerce","css/base/pages/app-ecommerce-details","css/base/pages/app-chat","css/base/pages/app-chat-list","css/base/pages/app-calendar","css/base/plugins/ui/coming-soon","css/base/plugins/maps/map-leaflet","css/base/plugins/forms/pickers/form-pickadate","css/base/plugins/forms/pickers/form-flat-pickr","css/base/plugins/forms/form-wizard","css/base/plugins/forms/form-validation","css/base/plugins/forms/form-quill-editor","css/base/plugins/forms/form-number-input","css/base/plugins/forms/form-file-uploader","css/base/plugins/extensions/ext-component-tree","css/base/plugins/extensions/ext-component-tour","css/base/plugins/extensions/ext-component-toastr","css/base/plugins/extensions/ext-component-swiper","css/base/plugins/extensions/ext-component-sweet-alerts","css/base/plugins/extensions/ext-component-sliders","css/base/plugins/extensions/ext-component-ratings"], () => (__webpack_require__("./resources/scss/base/plugins/maps/map-leaflet.scss")))
/******/ 	__webpack_require__.O(undefined, ["css/base/plugins/extensions/ext-component-media-player","css/base/plugins/extensions/ext-component-drag-drop","css/base/plugins/extensions/ext-component-context-menu","css/base/plugins/charts/chart-apex","css/style","css/overrides","css/core","css/base/themes/dark-layout","css/base/core/mixins/transitions","css/base/core/mixins/main-menu-mixin","css/base/core/mixins/hex2rgb","css/base/core/mixins/alert","css/base/core/menu/menu-types/vertical-overlay-menu","css/base/core/menu/menu-types/vertical-menu","css/base/core/menu/menu-types/horizontal-menu","css/base/core/colors/palette-variables","css/base/core/colors/palette-noui","css/base/core/colors/palette-gradient","css/base/pages/ui-feather","css/base/pages/page-profile","css/base/pages/page-pricing","css/base/pages/page-misc","css/base/pages/page-knowledge-base","css/base/pages/page-faq","css/base/pages/page-coming-soon","css/base/pages/page-blog","css/base/pages/modal-create-app","css/base/pages/dashboard-ecommerce","css/base/pages/authentication","css/base/pages/app-todo","css/base/pages/app-kanban","css/base/pages/app-invoice","css/base/pages/app-invoice-print","css/base/pages/app-invoice-list","css/base/pages/app-file-manager","css/base/pages/app-email","css/base/pages/app-ecommerce","css/base/pages/app-ecommerce-details","css/base/pages/app-chat","css/base/pages/app-chat-list","css/base/pages/app-calendar","css/base/plugins/ui/coming-soon","css/base/plugins/maps/map-leaflet","css/base/plugins/forms/pickers/form-pickadate","css/base/plugins/forms/pickers/form-flat-pickr","css/base/plugins/forms/form-wizard","css/base/plugins/forms/form-validation","css/base/plugins/forms/form-quill-editor","css/base/plugins/forms/form-number-input","css/base/plugins/forms/form-file-uploader","css/base/plugins/extensions/ext-component-tree","css/base/plugins/extensions/ext-component-tour","css/base/plugins/extensions/ext-component-toastr","css/base/plugins/extensions/ext-component-swiper","css/base/plugins/extensions/ext-component-sweet-alerts","css/base/plugins/extensions/ext-component-sliders","css/base/plugins/extensions/ext-component-ratings"], () => (__webpack_require__("./resources/scss/base/plugins/ui/coming-soon.scss")))
/******/ 	__webpack_require__.O(undefined, ["css/base/plugins/extensions/ext-component-media-player","css/base/plugins/extensions/ext-component-drag-drop","css/base/plugins/extensions/ext-component-context-menu","css/base/plugins/charts/chart-apex","css/style","css/overrides","css/core","css/base/themes/dark-layout","css/base/core/mixins/transitions","css/base/core/mixins/main-menu-mixin","css/base/core/mixins/hex2rgb","css/base/core/mixins/alert","css/base/core/menu/menu-types/vertical-overlay-menu","css/base/core/menu/menu-types/vertical-menu","css/base/core/menu/menu-types/horizontal-menu","css/base/core/colors/palette-variables","css/base/core/colors/palette-noui","css/base/core/colors/palette-gradient","css/base/pages/ui-feather","css/base/pages/page-profile","css/base/pages/page-pricing","css/base/pages/page-misc","css/base/pages/page-knowledge-base","css/base/pages/page-faq","css/base/pages/page-coming-soon","css/base/pages/page-blog","css/base/pages/modal-create-app","css/base/pages/dashboard-ecommerce","css/base/pages/authentication","css/base/pages/app-todo","css/base/pages/app-kanban","css/base/pages/app-invoice","css/base/pages/app-invoice-print","css/base/pages/app-invoice-list","css/base/pages/app-file-manager","css/base/pages/app-email","css/base/pages/app-ecommerce","css/base/pages/app-ecommerce-details","css/base/pages/app-chat","css/base/pages/app-chat-list","css/base/pages/app-calendar","css/base/plugins/ui/coming-soon","css/base/plugins/maps/map-leaflet","css/base/plugins/forms/pickers/form-pickadate","css/base/plugins/forms/pickers/form-flat-pickr","css/base/plugins/forms/form-wizard","css/base/plugins/forms/form-validation","css/base/plugins/forms/form-quill-editor","css/base/plugins/forms/form-number-input","css/base/plugins/forms/form-file-uploader","css/base/plugins/extensions/ext-component-tree","css/base/plugins/extensions/ext-component-tour","css/base/plugins/extensions/ext-component-toastr","css/base/plugins/extensions/ext-component-swiper","css/base/plugins/extensions/ext-component-sweet-alerts","css/base/plugins/extensions/ext-component-sliders","css/base/plugins/extensions/ext-component-ratings"], () => (__webpack_require__("./resources/scss/base/pages/app-calendar.scss")))
/******/ 	__webpack_require__.O(undefined, ["css/base/plugins/extensions/ext-component-media-player","css/base/plugins/extensions/ext-component-drag-drop","css/base/plugins/extensions/ext-component-context-menu","css/base/plugins/charts/chart-apex","css/style","css/overrides","css/core","css/base/themes/dark-layout","css/base/core/mixins/transitions","css/base/core/mixins/main-menu-mixin","css/base/core/mixins/hex2rgb","css/base/core/mixins/alert","css/base/core/menu/menu-types/vertical-overlay-menu","css/base/core/menu/menu-types/vertical-menu","css/base/core/menu/menu-types/horizontal-menu","css/base/core/colors/palette-variables","css/base/core/colors/palette-noui","css/base/core/colors/palette-gradient","css/base/pages/ui-feather","css/base/pages/page-profile","css/base/pages/page-pricing","css/base/pages/page-misc","css/base/pages/page-knowledge-base","css/base/pages/page-faq","css/base/pages/page-coming-soon","css/base/pages/page-blog","css/base/pages/modal-create-app","css/base/pages/dashboard-ecommerce","css/base/pages/authentication","css/base/pages/app-todo","css/base/pages/app-kanban","css/base/pages/app-invoice","css/base/pages/app-invoice-print","css/base/pages/app-invoice-list","css/base/pages/app-file-manager","css/base/pages/app-email","css/base/pages/app-ecommerce","css/base/pages/app-ecommerce-details","css/base/pages/app-chat","css/base/pages/app-chat-list","css/base/pages/app-calendar","css/base/plugins/ui/coming-soon","css/base/plugins/maps/map-leaflet","css/base/plugins/forms/pickers/form-pickadate","css/base/plugins/forms/pickers/form-flat-pickr","css/base/plugins/forms/form-wizard","css/base/plugins/forms/form-validation","css/base/plugins/forms/form-quill-editor","css/base/plugins/forms/form-number-input","css/base/plugins/forms/form-file-uploader","css/base/plugins/extensions/ext-component-tree","css/base/plugins/extensions/ext-component-tour","css/base/plugins/extensions/ext-component-toastr","css/base/plugins/extensions/ext-component-swiper","css/base/plugins/extensions/ext-component-sweet-alerts","css/base/plugins/extensions/ext-component-sliders","css/base/plugins/extensions/ext-component-ratings"], () => (__webpack_require__("./resources/scss/base/pages/app-chat-list.scss")))
/******/ 	__webpack_require__.O(undefined, ["css/base/plugins/extensions/ext-component-media-player","css/base/plugins/extensions/ext-component-drag-drop","css/base/plugins/extensions/ext-component-context-menu","css/base/plugins/charts/chart-apex","css/style","css/overrides","css/core","css/base/themes/dark-layout","css/base/core/mixins/transitions","css/base/core/mixins/main-menu-mixin","css/base/core/mixins/hex2rgb","css/base/core/mixins/alert","css/base/core/menu/menu-types/vertical-overlay-menu","css/base/core/menu/menu-types/vertical-menu","css/base/core/menu/menu-types/horizontal-menu","css/base/core/colors/palette-variables","css/base/core/colors/palette-noui","css/base/core/colors/palette-gradient","css/base/pages/ui-feather","css/base/pages/page-profile","css/base/pages/page-pricing","css/base/pages/page-misc","css/base/pages/page-knowledge-base","css/base/pages/page-faq","css/base/pages/page-coming-soon","css/base/pages/page-blog","css/base/pages/modal-create-app","css/base/pages/dashboard-ecommerce","css/base/pages/authentication","css/base/pages/app-todo","css/base/pages/app-kanban","css/base/pages/app-invoice","css/base/pages/app-invoice-print","css/base/pages/app-invoice-list","css/base/pages/app-file-manager","css/base/pages/app-email","css/base/pages/app-ecommerce","css/base/pages/app-ecommerce-details","css/base/pages/app-chat","css/base/pages/app-chat-list","css/base/pages/app-calendar","css/base/plugins/ui/coming-soon","css/base/plugins/maps/map-leaflet","css/base/plugins/forms/pickers/form-pickadate","css/base/plugins/forms/pickers/form-flat-pickr","css/base/plugins/forms/form-wizard","css/base/plugins/forms/form-validation","css/base/plugins/forms/form-quill-editor","css/base/plugins/forms/form-number-input","css/base/plugins/forms/form-file-uploader","css/base/plugins/extensions/ext-component-tree","css/base/plugins/extensions/ext-component-tour","css/base/plugins/extensions/ext-component-toastr","css/base/plugins/extensions/ext-component-swiper","css/base/plugins/extensions/ext-component-sweet-alerts","css/base/plugins/extensions/ext-component-sliders","css/base/plugins/extensions/ext-component-ratings"], () => (__webpack_require__("./resources/scss/base/pages/app-chat.scss")))
/******/ 	__webpack_require__.O(undefined, ["css/base/plugins/extensions/ext-component-media-player","css/base/plugins/extensions/ext-component-drag-drop","css/base/plugins/extensions/ext-component-context-menu","css/base/plugins/charts/chart-apex","css/style","css/overrides","css/core","css/base/themes/dark-layout","css/base/core/mixins/transitions","css/base/core/mixins/main-menu-mixin","css/base/core/mixins/hex2rgb","css/base/core/mixins/alert","css/base/core/menu/menu-types/vertical-overlay-menu","css/base/core/menu/menu-types/vertical-menu","css/base/core/menu/menu-types/horizontal-menu","css/base/core/colors/palette-variables","css/base/core/colors/palette-noui","css/base/core/colors/palette-gradient","css/base/pages/ui-feather","css/base/pages/page-profile","css/base/pages/page-pricing","css/base/pages/page-misc","css/base/pages/page-knowledge-base","css/base/pages/page-faq","css/base/pages/page-coming-soon","css/base/pages/page-blog","css/base/pages/modal-create-app","css/base/pages/dashboard-ecommerce","css/base/pages/authentication","css/base/pages/app-todo","css/base/pages/app-kanban","css/base/pages/app-invoice","css/base/pages/app-invoice-print","css/base/pages/app-invoice-list","css/base/pages/app-file-manager","css/base/pages/app-email","css/base/pages/app-ecommerce","css/base/pages/app-ecommerce-details","css/base/pages/app-chat","css/base/pages/app-chat-list","css/base/pages/app-calendar","css/base/plugins/ui/coming-soon","css/base/plugins/maps/map-leaflet","css/base/plugins/forms/pickers/form-pickadate","css/base/plugins/forms/pickers/form-flat-pickr","css/base/plugins/forms/form-wizard","css/base/plugins/forms/form-validation","css/base/plugins/forms/form-quill-editor","css/base/plugins/forms/form-number-input","css/base/plugins/forms/form-file-uploader","css/base/plugins/extensions/ext-component-tree","css/base/plugins/extensions/ext-component-tour","css/base/plugins/extensions/ext-component-toastr","css/base/plugins/extensions/ext-component-swiper","css/base/plugins/extensions/ext-component-sweet-alerts","css/base/plugins/extensions/ext-component-sliders","css/base/plugins/extensions/ext-component-ratings"], () => (__webpack_require__("./resources/scss/base/pages/app-ecommerce-details.scss")))
/******/ 	__webpack_require__.O(undefined, ["css/base/plugins/extensions/ext-component-media-player","css/base/plugins/extensions/ext-component-drag-drop","css/base/plugins/extensions/ext-component-context-menu","css/base/plugins/charts/chart-apex","css/style","css/overrides","css/core","css/base/themes/dark-layout","css/base/core/mixins/transitions","css/base/core/mixins/main-menu-mixin","css/base/core/mixins/hex2rgb","css/base/core/mixins/alert","css/base/core/menu/menu-types/vertical-overlay-menu","css/base/core/menu/menu-types/vertical-menu","css/base/core/menu/menu-types/horizontal-menu","css/base/core/colors/palette-variables","css/base/core/colors/palette-noui","css/base/core/colors/palette-gradient","css/base/pages/ui-feather","css/base/pages/page-profile","css/base/pages/page-pricing","css/base/pages/page-misc","css/base/pages/page-knowledge-base","css/base/pages/page-faq","css/base/pages/page-coming-soon","css/base/pages/page-blog","css/base/pages/modal-create-app","css/base/pages/dashboard-ecommerce","css/base/pages/authentication","css/base/pages/app-todo","css/base/pages/app-kanban","css/base/pages/app-invoice","css/base/pages/app-invoice-print","css/base/pages/app-invoice-list","css/base/pages/app-file-manager","css/base/pages/app-email","css/base/pages/app-ecommerce","css/base/pages/app-ecommerce-details","css/base/pages/app-chat","css/base/pages/app-chat-list","css/base/pages/app-calendar","css/base/plugins/ui/coming-soon","css/base/plugins/maps/map-leaflet","css/base/plugins/forms/pickers/form-pickadate","css/base/plugins/forms/pickers/form-flat-pickr","css/base/plugins/forms/form-wizard","css/base/plugins/forms/form-validation","css/base/plugins/forms/form-quill-editor","css/base/plugins/forms/form-number-input","css/base/plugins/forms/form-file-uploader","css/base/plugins/extensions/ext-component-tree","css/base/plugins/extensions/ext-component-tour","css/base/plugins/extensions/ext-component-toastr","css/base/plugins/extensions/ext-component-swiper","css/base/plugins/extensions/ext-component-sweet-alerts","css/base/plugins/extensions/ext-component-sliders","css/base/plugins/extensions/ext-component-ratings"], () => (__webpack_require__("./resources/scss/base/pages/app-ecommerce.scss")))
/******/ 	__webpack_require__.O(undefined, ["css/base/plugins/extensions/ext-component-media-player","css/base/plugins/extensions/ext-component-drag-drop","css/base/plugins/extensions/ext-component-context-menu","css/base/plugins/charts/chart-apex","css/style","css/overrides","css/core","css/base/themes/dark-layout","css/base/core/mixins/transitions","css/base/core/mixins/main-menu-mixin","css/base/core/mixins/hex2rgb","css/base/core/mixins/alert","css/base/core/menu/menu-types/vertical-overlay-menu","css/base/core/menu/menu-types/vertical-menu","css/base/core/menu/menu-types/horizontal-menu","css/base/core/colors/palette-variables","css/base/core/colors/palette-noui","css/base/core/colors/palette-gradient","css/base/pages/ui-feather","css/base/pages/page-profile","css/base/pages/page-pricing","css/base/pages/page-misc","css/base/pages/page-knowledge-base","css/base/pages/page-faq","css/base/pages/page-coming-soon","css/base/pages/page-blog","css/base/pages/modal-create-app","css/base/pages/dashboard-ecommerce","css/base/pages/authentication","css/base/pages/app-todo","css/base/pages/app-kanban","css/base/pages/app-invoice","css/base/pages/app-invoice-print","css/base/pages/app-invoice-list","css/base/pages/app-file-manager","css/base/pages/app-email","css/base/pages/app-ecommerce","css/base/pages/app-ecommerce-details","css/base/pages/app-chat","css/base/pages/app-chat-list","css/base/pages/app-calendar","css/base/plugins/ui/coming-soon","css/base/plugins/maps/map-leaflet","css/base/plugins/forms/pickers/form-pickadate","css/base/plugins/forms/pickers/form-flat-pickr","css/base/plugins/forms/form-wizard","css/base/plugins/forms/form-validation","css/base/plugins/forms/form-quill-editor","css/base/plugins/forms/form-number-input","css/base/plugins/forms/form-file-uploader","css/base/plugins/extensions/ext-component-tree","css/base/plugins/extensions/ext-component-tour","css/base/plugins/extensions/ext-component-toastr","css/base/plugins/extensions/ext-component-swiper","css/base/plugins/extensions/ext-component-sweet-alerts","css/base/plugins/extensions/ext-component-sliders","css/base/plugins/extensions/ext-component-ratings"], () => (__webpack_require__("./resources/scss/base/pages/app-email.scss")))
/******/ 	__webpack_require__.O(undefined, ["css/base/plugins/extensions/ext-component-media-player","css/base/plugins/extensions/ext-component-drag-drop","css/base/plugins/extensions/ext-component-context-menu","css/base/plugins/charts/chart-apex","css/style","css/overrides","css/core","css/base/themes/dark-layout","css/base/core/mixins/transitions","css/base/core/mixins/main-menu-mixin","css/base/core/mixins/hex2rgb","css/base/core/mixins/alert","css/base/core/menu/menu-types/vertical-overlay-menu","css/base/core/menu/menu-types/vertical-menu","css/base/core/menu/menu-types/horizontal-menu","css/base/core/colors/palette-variables","css/base/core/colors/palette-noui","css/base/core/colors/palette-gradient","css/base/pages/ui-feather","css/base/pages/page-profile","css/base/pages/page-pricing","css/base/pages/page-misc","css/base/pages/page-knowledge-base","css/base/pages/page-faq","css/base/pages/page-coming-soon","css/base/pages/page-blog","css/base/pages/modal-create-app","css/base/pages/dashboard-ecommerce","css/base/pages/authentication","css/base/pages/app-todo","css/base/pages/app-kanban","css/base/pages/app-invoice","css/base/pages/app-invoice-print","css/base/pages/app-invoice-list","css/base/pages/app-file-manager","css/base/pages/app-email","css/base/pages/app-ecommerce","css/base/pages/app-ecommerce-details","css/base/pages/app-chat","css/base/pages/app-chat-list","css/base/pages/app-calendar","css/base/plugins/ui/coming-soon","css/base/plugins/maps/map-leaflet","css/base/plugins/forms/pickers/form-pickadate","css/base/plugins/forms/pickers/form-flat-pickr","css/base/plugins/forms/form-wizard","css/base/plugins/forms/form-validation","css/base/plugins/forms/form-quill-editor","css/base/plugins/forms/form-number-input","css/base/plugins/forms/form-file-uploader","css/base/plugins/extensions/ext-component-tree","css/base/plugins/extensions/ext-component-tour","css/base/plugins/extensions/ext-component-toastr","css/base/plugins/extensions/ext-component-swiper","css/base/plugins/extensions/ext-component-sweet-alerts","css/base/plugins/extensions/ext-component-sliders","css/base/plugins/extensions/ext-component-ratings"], () => (__webpack_require__("./resources/scss/base/pages/app-file-manager.scss")))
/******/ 	__webpack_require__.O(undefined, ["css/base/plugins/extensions/ext-component-media-player","css/base/plugins/extensions/ext-component-drag-drop","css/base/plugins/extensions/ext-component-context-menu","css/base/plugins/charts/chart-apex","css/style","css/overrides","css/core","css/base/themes/dark-layout","css/base/core/mixins/transitions","css/base/core/mixins/main-menu-mixin","css/base/core/mixins/hex2rgb","css/base/core/mixins/alert","css/base/core/menu/menu-types/vertical-overlay-menu","css/base/core/menu/menu-types/vertical-menu","css/base/core/menu/menu-types/horizontal-menu","css/base/core/colors/palette-variables","css/base/core/colors/palette-noui","css/base/core/colors/palette-gradient","css/base/pages/ui-feather","css/base/pages/page-profile","css/base/pages/page-pricing","css/base/pages/page-misc","css/base/pages/page-knowledge-base","css/base/pages/page-faq","css/base/pages/page-coming-soon","css/base/pages/page-blog","css/base/pages/modal-create-app","css/base/pages/dashboard-ecommerce","css/base/pages/authentication","css/base/pages/app-todo","css/base/pages/app-kanban","css/base/pages/app-invoice","css/base/pages/app-invoice-print","css/base/pages/app-invoice-list","css/base/pages/app-file-manager","css/base/pages/app-email","css/base/pages/app-ecommerce","css/base/pages/app-ecommerce-details","css/base/pages/app-chat","css/base/pages/app-chat-list","css/base/pages/app-calendar","css/base/plugins/ui/coming-soon","css/base/plugins/maps/map-leaflet","css/base/plugins/forms/pickers/form-pickadate","css/base/plugins/forms/pickers/form-flat-pickr","css/base/plugins/forms/form-wizard","css/base/plugins/forms/form-validation","css/base/plugins/forms/form-quill-editor","css/base/plugins/forms/form-number-input","css/base/plugins/forms/form-file-uploader","css/base/plugins/extensions/ext-component-tree","css/base/plugins/extensions/ext-component-tour","css/base/plugins/extensions/ext-component-toastr","css/base/plugins/extensions/ext-component-swiper","css/base/plugins/extensions/ext-component-sweet-alerts","css/base/plugins/extensions/ext-component-sliders","css/base/plugins/extensions/ext-component-ratings"], () => (__webpack_require__("./resources/scss/base/pages/app-invoice-list.scss")))
/******/ 	__webpack_require__.O(undefined, ["css/base/plugins/extensions/ext-component-media-player","css/base/plugins/extensions/ext-component-drag-drop","css/base/plugins/extensions/ext-component-context-menu","css/base/plugins/charts/chart-apex","css/style","css/overrides","css/core","css/base/themes/dark-layout","css/base/core/mixins/transitions","css/base/core/mixins/main-menu-mixin","css/base/core/mixins/hex2rgb","css/base/core/mixins/alert","css/base/core/menu/menu-types/vertical-overlay-menu","css/base/core/menu/menu-types/vertical-menu","css/base/core/menu/menu-types/horizontal-menu","css/base/core/colors/palette-variables","css/base/core/colors/palette-noui","css/base/core/colors/palette-gradient","css/base/pages/ui-feather","css/base/pages/page-profile","css/base/pages/page-pricing","css/base/pages/page-misc","css/base/pages/page-knowledge-base","css/base/pages/page-faq","css/base/pages/page-coming-soon","css/base/pages/page-blog","css/base/pages/modal-create-app","css/base/pages/dashboard-ecommerce","css/base/pages/authentication","css/base/pages/app-todo","css/base/pages/app-kanban","css/base/pages/app-invoice","css/base/pages/app-invoice-print","css/base/pages/app-invoice-list","css/base/pages/app-file-manager","css/base/pages/app-email","css/base/pages/app-ecommerce","css/base/pages/app-ecommerce-details","css/base/pages/app-chat","css/base/pages/app-chat-list","css/base/pages/app-calendar","css/base/plugins/ui/coming-soon","css/base/plugins/maps/map-leaflet","css/base/plugins/forms/pickers/form-pickadate","css/base/plugins/forms/pickers/form-flat-pickr","css/base/plugins/forms/form-wizard","css/base/plugins/forms/form-validation","css/base/plugins/forms/form-quill-editor","css/base/plugins/forms/form-number-input","css/base/plugins/forms/form-file-uploader","css/base/plugins/extensions/ext-component-tree","css/base/plugins/extensions/ext-component-tour","css/base/plugins/extensions/ext-component-toastr","css/base/plugins/extensions/ext-component-swiper","css/base/plugins/extensions/ext-component-sweet-alerts","css/base/plugins/extensions/ext-component-sliders","css/base/plugins/extensions/ext-component-ratings"], () => (__webpack_require__("./resources/scss/base/pages/app-invoice-print.scss")))
/******/ 	__webpack_require__.O(undefined, ["css/base/plugins/extensions/ext-component-media-player","css/base/plugins/extensions/ext-component-drag-drop","css/base/plugins/extensions/ext-component-context-menu","css/base/plugins/charts/chart-apex","css/style","css/overrides","css/core","css/base/themes/dark-layout","css/base/core/mixins/transitions","css/base/core/mixins/main-menu-mixin","css/base/core/mixins/hex2rgb","css/base/core/mixins/alert","css/base/core/menu/menu-types/vertical-overlay-menu","css/base/core/menu/menu-types/vertical-menu","css/base/core/menu/menu-types/horizontal-menu","css/base/core/colors/palette-variables","css/base/core/colors/palette-noui","css/base/core/colors/palette-gradient","css/base/pages/ui-feather","css/base/pages/page-profile","css/base/pages/page-pricing","css/base/pages/page-misc","css/base/pages/page-knowledge-base","css/base/pages/page-faq","css/base/pages/page-coming-soon","css/base/pages/page-blog","css/base/pages/modal-create-app","css/base/pages/dashboard-ecommerce","css/base/pages/authentication","css/base/pages/app-todo","css/base/pages/app-kanban","css/base/pages/app-invoice","css/base/pages/app-invoice-print","css/base/pages/app-invoice-list","css/base/pages/app-file-manager","css/base/pages/app-email","css/base/pages/app-ecommerce","css/base/pages/app-ecommerce-details","css/base/pages/app-chat","css/base/pages/app-chat-list","css/base/pages/app-calendar","css/base/plugins/ui/coming-soon","css/base/plugins/maps/map-leaflet","css/base/plugins/forms/pickers/form-pickadate","css/base/plugins/forms/pickers/form-flat-pickr","css/base/plugins/forms/form-wizard","css/base/plugins/forms/form-validation","css/base/plugins/forms/form-quill-editor","css/base/plugins/forms/form-number-input","css/base/plugins/forms/form-file-uploader","css/base/plugins/extensions/ext-component-tree","css/base/plugins/extensions/ext-component-tour","css/base/plugins/extensions/ext-component-toastr","css/base/plugins/extensions/ext-component-swiper","css/base/plugins/extensions/ext-component-sweet-alerts","css/base/plugins/extensions/ext-component-sliders","css/base/plugins/extensions/ext-component-ratings"], () => (__webpack_require__("./resources/scss/base/pages/app-invoice.scss")))
/******/ 	__webpack_require__.O(undefined, ["css/base/plugins/extensions/ext-component-media-player","css/base/plugins/extensions/ext-component-drag-drop","css/base/plugins/extensions/ext-component-context-menu","css/base/plugins/charts/chart-apex","css/style","css/overrides","css/core","css/base/themes/dark-layout","css/base/core/mixins/transitions","css/base/core/mixins/main-menu-mixin","css/base/core/mixins/hex2rgb","css/base/core/mixins/alert","css/base/core/menu/menu-types/vertical-overlay-menu","css/base/core/menu/menu-types/vertical-menu","css/base/core/menu/menu-types/horizontal-menu","css/base/core/colors/palette-variables","css/base/core/colors/palette-noui","css/base/core/colors/palette-gradient","css/base/pages/ui-feather","css/base/pages/page-profile","css/base/pages/page-pricing","css/base/pages/page-misc","css/base/pages/page-knowledge-base","css/base/pages/page-faq","css/base/pages/page-coming-soon","css/base/pages/page-blog","css/base/pages/modal-create-app","css/base/pages/dashboard-ecommerce","css/base/pages/authentication","css/base/pages/app-todo","css/base/pages/app-kanban","css/base/pages/app-invoice","css/base/pages/app-invoice-print","css/base/pages/app-invoice-list","css/base/pages/app-file-manager","css/base/pages/app-email","css/base/pages/app-ecommerce","css/base/pages/app-ecommerce-details","css/base/pages/app-chat","css/base/pages/app-chat-list","css/base/pages/app-calendar","css/base/plugins/ui/coming-soon","css/base/plugins/maps/map-leaflet","css/base/plugins/forms/pickers/form-pickadate","css/base/plugins/forms/pickers/form-flat-pickr","css/base/plugins/forms/form-wizard","css/base/plugins/forms/form-validation","css/base/plugins/forms/form-quill-editor","css/base/plugins/forms/form-number-input","css/base/plugins/forms/form-file-uploader","css/base/plugins/extensions/ext-component-tree","css/base/plugins/extensions/ext-component-tour","css/base/plugins/extensions/ext-component-toastr","css/base/plugins/extensions/ext-component-swiper","css/base/plugins/extensions/ext-component-sweet-alerts","css/base/plugins/extensions/ext-component-sliders","css/base/plugins/extensions/ext-component-ratings"], () => (__webpack_require__("./resources/scss/base/pages/app-kanban.scss")))
/******/ 	__webpack_require__.O(undefined, ["css/base/plugins/extensions/ext-component-media-player","css/base/plugins/extensions/ext-component-drag-drop","css/base/plugins/extensions/ext-component-context-menu","css/base/plugins/charts/chart-apex","css/style","css/overrides","css/core","css/base/themes/dark-layout","css/base/core/mixins/transitions","css/base/core/mixins/main-menu-mixin","css/base/core/mixins/hex2rgb","css/base/core/mixins/alert","css/base/core/menu/menu-types/vertical-overlay-menu","css/base/core/menu/menu-types/vertical-menu","css/base/core/menu/menu-types/horizontal-menu","css/base/core/colors/palette-variables","css/base/core/colors/palette-noui","css/base/core/colors/palette-gradient","css/base/pages/ui-feather","css/base/pages/page-profile","css/base/pages/page-pricing","css/base/pages/page-misc","css/base/pages/page-knowledge-base","css/base/pages/page-faq","css/base/pages/page-coming-soon","css/base/pages/page-blog","css/base/pages/modal-create-app","css/base/pages/dashboard-ecommerce","css/base/pages/authentication","css/base/pages/app-todo","css/base/pages/app-kanban","css/base/pages/app-invoice","css/base/pages/app-invoice-print","css/base/pages/app-invoice-list","css/base/pages/app-file-manager","css/base/pages/app-email","css/base/pages/app-ecommerce","css/base/pages/app-ecommerce-details","css/base/pages/app-chat","css/base/pages/app-chat-list","css/base/pages/app-calendar","css/base/plugins/ui/coming-soon","css/base/plugins/maps/map-leaflet","css/base/plugins/forms/pickers/form-pickadate","css/base/plugins/forms/pickers/form-flat-pickr","css/base/plugins/forms/form-wizard","css/base/plugins/forms/form-validation","css/base/plugins/forms/form-quill-editor","css/base/plugins/forms/form-number-input","css/base/plugins/forms/form-file-uploader","css/base/plugins/extensions/ext-component-tree","css/base/plugins/extensions/ext-component-tour","css/base/plugins/extensions/ext-component-toastr","css/base/plugins/extensions/ext-component-swiper","css/base/plugins/extensions/ext-component-sweet-alerts","css/base/plugins/extensions/ext-component-sliders","css/base/plugins/extensions/ext-component-ratings"], () => (__webpack_require__("./resources/scss/base/pages/app-todo.scss")))
/******/ 	__webpack_require__.O(undefined, ["css/base/plugins/extensions/ext-component-media-player","css/base/plugins/extensions/ext-component-drag-drop","css/base/plugins/extensions/ext-component-context-menu","css/base/plugins/charts/chart-apex","css/style","css/overrides","css/core","css/base/themes/dark-layout","css/base/core/mixins/transitions","css/base/core/mixins/main-menu-mixin","css/base/core/mixins/hex2rgb","css/base/core/mixins/alert","css/base/core/menu/menu-types/vertical-overlay-menu","css/base/core/menu/menu-types/vertical-menu","css/base/core/menu/menu-types/horizontal-menu","css/base/core/colors/palette-variables","css/base/core/colors/palette-noui","css/base/core/colors/palette-gradient","css/base/pages/ui-feather","css/base/pages/page-profile","css/base/pages/page-pricing","css/base/pages/page-misc","css/base/pages/page-knowledge-base","css/base/pages/page-faq","css/base/pages/page-coming-soon","css/base/pages/page-blog","css/base/pages/modal-create-app","css/base/pages/dashboard-ecommerce","css/base/pages/authentication","css/base/pages/app-todo","css/base/pages/app-kanban","css/base/pages/app-invoice","css/base/pages/app-invoice-print","css/base/pages/app-invoice-list","css/base/pages/app-file-manager","css/base/pages/app-email","css/base/pages/app-ecommerce","css/base/pages/app-ecommerce-details","css/base/pages/app-chat","css/base/pages/app-chat-list","css/base/pages/app-calendar","css/base/plugins/ui/coming-soon","css/base/plugins/maps/map-leaflet","css/base/plugins/forms/pickers/form-pickadate","css/base/plugins/forms/pickers/form-flat-pickr","css/base/plugins/forms/form-wizard","css/base/plugins/forms/form-validation","css/base/plugins/forms/form-quill-editor","css/base/plugins/forms/form-number-input","css/base/plugins/forms/form-file-uploader","css/base/plugins/extensions/ext-component-tree","css/base/plugins/extensions/ext-component-tour","css/base/plugins/extensions/ext-component-toastr","css/base/plugins/extensions/ext-component-swiper","css/base/plugins/extensions/ext-component-sweet-alerts","css/base/plugins/extensions/ext-component-sliders","css/base/plugins/extensions/ext-component-ratings"], () => (__webpack_require__("./resources/scss/base/pages/authentication.scss")))
/******/ 	__webpack_require__.O(undefined, ["css/base/plugins/extensions/ext-component-media-player","css/base/plugins/extensions/ext-component-drag-drop","css/base/plugins/extensions/ext-component-context-menu","css/base/plugins/charts/chart-apex","css/style","css/overrides","css/core","css/base/themes/dark-layout","css/base/core/mixins/transitions","css/base/core/mixins/main-menu-mixin","css/base/core/mixins/hex2rgb","css/base/core/mixins/alert","css/base/core/menu/menu-types/vertical-overlay-menu","css/base/core/menu/menu-types/vertical-menu","css/base/core/menu/menu-types/horizontal-menu","css/base/core/colors/palette-variables","css/base/core/colors/palette-noui","css/base/core/colors/palette-gradient","css/base/pages/ui-feather","css/base/pages/page-profile","css/base/pages/page-pricing","css/base/pages/page-misc","css/base/pages/page-knowledge-base","css/base/pages/page-faq","css/base/pages/page-coming-soon","css/base/pages/page-blog","css/base/pages/modal-create-app","css/base/pages/dashboard-ecommerce","css/base/pages/authentication","css/base/pages/app-todo","css/base/pages/app-kanban","css/base/pages/app-invoice","css/base/pages/app-invoice-print","css/base/pages/app-invoice-list","css/base/pages/app-file-manager","css/base/pages/app-email","css/base/pages/app-ecommerce","css/base/pages/app-ecommerce-details","css/base/pages/app-chat","css/base/pages/app-chat-list","css/base/pages/app-calendar","css/base/plugins/ui/coming-soon","css/base/plugins/maps/map-leaflet","css/base/plugins/forms/pickers/form-pickadate","css/base/plugins/forms/pickers/form-flat-pickr","css/base/plugins/forms/form-wizard","css/base/plugins/forms/form-validation","css/base/plugins/forms/form-quill-editor","css/base/plugins/forms/form-number-input","css/base/plugins/forms/form-file-uploader","css/base/plugins/extensions/ext-component-tree","css/base/plugins/extensions/ext-component-tour","css/base/plugins/extensions/ext-component-toastr","css/base/plugins/extensions/ext-component-swiper","css/base/plugins/extensions/ext-component-sweet-alerts","css/base/plugins/extensions/ext-component-sliders","css/base/plugins/extensions/ext-component-ratings"], () => (__webpack_require__("./resources/scss/base/pages/dashboard-ecommerce.scss")))
/******/ 	__webpack_require__.O(undefined, ["css/base/plugins/extensions/ext-component-media-player","css/base/plugins/extensions/ext-component-drag-drop","css/base/plugins/extensions/ext-component-context-menu","css/base/plugins/charts/chart-apex","css/style","css/overrides","css/core","css/base/themes/dark-layout","css/base/core/mixins/transitions","css/base/core/mixins/main-menu-mixin","css/base/core/mixins/hex2rgb","css/base/core/mixins/alert","css/base/core/menu/menu-types/vertical-overlay-menu","css/base/core/menu/menu-types/vertical-menu","css/base/core/menu/menu-types/horizontal-menu","css/base/core/colors/palette-variables","css/base/core/colors/palette-noui","css/base/core/colors/palette-gradient","css/base/pages/ui-feather","css/base/pages/page-profile","css/base/pages/page-pricing","css/base/pages/page-misc","css/base/pages/page-knowledge-base","css/base/pages/page-faq","css/base/pages/page-coming-soon","css/base/pages/page-blog","css/base/pages/modal-create-app","css/base/pages/dashboard-ecommerce","css/base/pages/authentication","css/base/pages/app-todo","css/base/pages/app-kanban","css/base/pages/app-invoice","css/base/pages/app-invoice-print","css/base/pages/app-invoice-list","css/base/pages/app-file-manager","css/base/pages/app-email","css/base/pages/app-ecommerce","css/base/pages/app-ecommerce-details","css/base/pages/app-chat","css/base/pages/app-chat-list","css/base/pages/app-calendar","css/base/plugins/ui/coming-soon","css/base/plugins/maps/map-leaflet","css/base/plugins/forms/pickers/form-pickadate","css/base/plugins/forms/pickers/form-flat-pickr","css/base/plugins/forms/form-wizard","css/base/plugins/forms/form-validation","css/base/plugins/forms/form-quill-editor","css/base/plugins/forms/form-number-input","css/base/plugins/forms/form-file-uploader","css/base/plugins/extensions/ext-component-tree","css/base/plugins/extensions/ext-component-tour","css/base/plugins/extensions/ext-component-toastr","css/base/plugins/extensions/ext-component-swiper","css/base/plugins/extensions/ext-component-sweet-alerts","css/base/plugins/extensions/ext-component-sliders","css/base/plugins/extensions/ext-component-ratings"], () => (__webpack_require__("./resources/scss/base/pages/modal-create-app.scss")))
/******/ 	__webpack_require__.O(undefined, ["css/base/plugins/extensions/ext-component-media-player","css/base/plugins/extensions/ext-component-drag-drop","css/base/plugins/extensions/ext-component-context-menu","css/base/plugins/charts/chart-apex","css/style","css/overrides","css/core","css/base/themes/dark-layout","css/base/core/mixins/transitions","css/base/core/mixins/main-menu-mixin","css/base/core/mixins/hex2rgb","css/base/core/mixins/alert","css/base/core/menu/menu-types/vertical-overlay-menu","css/base/core/menu/menu-types/vertical-menu","css/base/core/menu/menu-types/horizontal-menu","css/base/core/colors/palette-variables","css/base/core/colors/palette-noui","css/base/core/colors/palette-gradient","css/base/pages/ui-feather","css/base/pages/page-profile","css/base/pages/page-pricing","css/base/pages/page-misc","css/base/pages/page-knowledge-base","css/base/pages/page-faq","css/base/pages/page-coming-soon","css/base/pages/page-blog","css/base/pages/modal-create-app","css/base/pages/dashboard-ecommerce","css/base/pages/authentication","css/base/pages/app-todo","css/base/pages/app-kanban","css/base/pages/app-invoice","css/base/pages/app-invoice-print","css/base/pages/app-invoice-list","css/base/pages/app-file-manager","css/base/pages/app-email","css/base/pages/app-ecommerce","css/base/pages/app-ecommerce-details","css/base/pages/app-chat","css/base/pages/app-chat-list","css/base/pages/app-calendar","css/base/plugins/ui/coming-soon","css/base/plugins/maps/map-leaflet","css/base/plugins/forms/pickers/form-pickadate","css/base/plugins/forms/pickers/form-flat-pickr","css/base/plugins/forms/form-wizard","css/base/plugins/forms/form-validation","css/base/plugins/forms/form-quill-editor","css/base/plugins/forms/form-number-input","css/base/plugins/forms/form-file-uploader","css/base/plugins/extensions/ext-component-tree","css/base/plugins/extensions/ext-component-tour","css/base/plugins/extensions/ext-component-toastr","css/base/plugins/extensions/ext-component-swiper","css/base/plugins/extensions/ext-component-sweet-alerts","css/base/plugins/extensions/ext-component-sliders","css/base/plugins/extensions/ext-component-ratings"], () => (__webpack_require__("./resources/scss/base/pages/page-blog.scss")))
/******/ 	__webpack_require__.O(undefined, ["css/base/plugins/extensions/ext-component-media-player","css/base/plugins/extensions/ext-component-drag-drop","css/base/plugins/extensions/ext-component-context-menu","css/base/plugins/charts/chart-apex","css/style","css/overrides","css/core","css/base/themes/dark-layout","css/base/core/mixins/transitions","css/base/core/mixins/main-menu-mixin","css/base/core/mixins/hex2rgb","css/base/core/mixins/alert","css/base/core/menu/menu-types/vertical-overlay-menu","css/base/core/menu/menu-types/vertical-menu","css/base/core/menu/menu-types/horizontal-menu","css/base/core/colors/palette-variables","css/base/core/colors/palette-noui","css/base/core/colors/palette-gradient","css/base/pages/ui-feather","css/base/pages/page-profile","css/base/pages/page-pricing","css/base/pages/page-misc","css/base/pages/page-knowledge-base","css/base/pages/page-faq","css/base/pages/page-coming-soon","css/base/pages/page-blog","css/base/pages/modal-create-app","css/base/pages/dashboard-ecommerce","css/base/pages/authentication","css/base/pages/app-todo","css/base/pages/app-kanban","css/base/pages/app-invoice","css/base/pages/app-invoice-print","css/base/pages/app-invoice-list","css/base/pages/app-file-manager","css/base/pages/app-email","css/base/pages/app-ecommerce","css/base/pages/app-ecommerce-details","css/base/pages/app-chat","css/base/pages/app-chat-list","css/base/pages/app-calendar","css/base/plugins/ui/coming-soon","css/base/plugins/maps/map-leaflet","css/base/plugins/forms/pickers/form-pickadate","css/base/plugins/forms/pickers/form-flat-pickr","css/base/plugins/forms/form-wizard","css/base/plugins/forms/form-validation","css/base/plugins/forms/form-quill-editor","css/base/plugins/forms/form-number-input","css/base/plugins/forms/form-file-uploader","css/base/plugins/extensions/ext-component-tree","css/base/plugins/extensions/ext-component-tour","css/base/plugins/extensions/ext-component-toastr","css/base/plugins/extensions/ext-component-swiper","css/base/plugins/extensions/ext-component-sweet-alerts","css/base/plugins/extensions/ext-component-sliders","css/base/plugins/extensions/ext-component-ratings"], () => (__webpack_require__("./resources/scss/base/pages/page-coming-soon.scss")))
/******/ 	__webpack_require__.O(undefined, ["css/base/plugins/extensions/ext-component-media-player","css/base/plugins/extensions/ext-component-drag-drop","css/base/plugins/extensions/ext-component-context-menu","css/base/plugins/charts/chart-apex","css/style","css/overrides","css/core","css/base/themes/dark-layout","css/base/core/mixins/transitions","css/base/core/mixins/main-menu-mixin","css/base/core/mixins/hex2rgb","css/base/core/mixins/alert","css/base/core/menu/menu-types/vertical-overlay-menu","css/base/core/menu/menu-types/vertical-menu","css/base/core/menu/menu-types/horizontal-menu","css/base/core/colors/palette-variables","css/base/core/colors/palette-noui","css/base/core/colors/palette-gradient","css/base/pages/ui-feather","css/base/pages/page-profile","css/base/pages/page-pricing","css/base/pages/page-misc","css/base/pages/page-knowledge-base","css/base/pages/page-faq","css/base/pages/page-coming-soon","css/base/pages/page-blog","css/base/pages/modal-create-app","css/base/pages/dashboard-ecommerce","css/base/pages/authentication","css/base/pages/app-todo","css/base/pages/app-kanban","css/base/pages/app-invoice","css/base/pages/app-invoice-print","css/base/pages/app-invoice-list","css/base/pages/app-file-manager","css/base/pages/app-email","css/base/pages/app-ecommerce","css/base/pages/app-ecommerce-details","css/base/pages/app-chat","css/base/pages/app-chat-list","css/base/pages/app-calendar","css/base/plugins/ui/coming-soon","css/base/plugins/maps/map-leaflet","css/base/plugins/forms/pickers/form-pickadate","css/base/plugins/forms/pickers/form-flat-pickr","css/base/plugins/forms/form-wizard","css/base/plugins/forms/form-validation","css/base/plugins/forms/form-quill-editor","css/base/plugins/forms/form-number-input","css/base/plugins/forms/form-file-uploader","css/base/plugins/extensions/ext-component-tree","css/base/plugins/extensions/ext-component-tour","css/base/plugins/extensions/ext-component-toastr","css/base/plugins/extensions/ext-component-swiper","css/base/plugins/extensions/ext-component-sweet-alerts","css/base/plugins/extensions/ext-component-sliders","css/base/plugins/extensions/ext-component-ratings"], () => (__webpack_require__("./resources/scss/base/pages/page-faq.scss")))
/******/ 	__webpack_require__.O(undefined, ["css/base/plugins/extensions/ext-component-media-player","css/base/plugins/extensions/ext-component-drag-drop","css/base/plugins/extensions/ext-component-context-menu","css/base/plugins/charts/chart-apex","css/style","css/overrides","css/core","css/base/themes/dark-layout","css/base/core/mixins/transitions","css/base/core/mixins/main-menu-mixin","css/base/core/mixins/hex2rgb","css/base/core/mixins/alert","css/base/core/menu/menu-types/vertical-overlay-menu","css/base/core/menu/menu-types/vertical-menu","css/base/core/menu/menu-types/horizontal-menu","css/base/core/colors/palette-variables","css/base/core/colors/palette-noui","css/base/core/colors/palette-gradient","css/base/pages/ui-feather","css/base/pages/page-profile","css/base/pages/page-pricing","css/base/pages/page-misc","css/base/pages/page-knowledge-base","css/base/pages/page-faq","css/base/pages/page-coming-soon","css/base/pages/page-blog","css/base/pages/modal-create-app","css/base/pages/dashboard-ecommerce","css/base/pages/authentication","css/base/pages/app-todo","css/base/pages/app-kanban","css/base/pages/app-invoice","css/base/pages/app-invoice-print","css/base/pages/app-invoice-list","css/base/pages/app-file-manager","css/base/pages/app-email","css/base/pages/app-ecommerce","css/base/pages/app-ecommerce-details","css/base/pages/app-chat","css/base/pages/app-chat-list","css/base/pages/app-calendar","css/base/plugins/ui/coming-soon","css/base/plugins/maps/map-leaflet","css/base/plugins/forms/pickers/form-pickadate","css/base/plugins/forms/pickers/form-flat-pickr","css/base/plugins/forms/form-wizard","css/base/plugins/forms/form-validation","css/base/plugins/forms/form-quill-editor","css/base/plugins/forms/form-number-input","css/base/plugins/forms/form-file-uploader","css/base/plugins/extensions/ext-component-tree","css/base/plugins/extensions/ext-component-tour","css/base/plugins/extensions/ext-component-toastr","css/base/plugins/extensions/ext-component-swiper","css/base/plugins/extensions/ext-component-sweet-alerts","css/base/plugins/extensions/ext-component-sliders","css/base/plugins/extensions/ext-component-ratings"], () => (__webpack_require__("./resources/scss/base/pages/page-knowledge-base.scss")))
/******/ 	__webpack_require__.O(undefined, ["css/base/plugins/extensions/ext-component-media-player","css/base/plugins/extensions/ext-component-drag-drop","css/base/plugins/extensions/ext-component-context-menu","css/base/plugins/charts/chart-apex","css/style","css/overrides","css/core","css/base/themes/dark-layout","css/base/core/mixins/transitions","css/base/core/mixins/main-menu-mixin","css/base/core/mixins/hex2rgb","css/base/core/mixins/alert","css/base/core/menu/menu-types/vertical-overlay-menu","css/base/core/menu/menu-types/vertical-menu","css/base/core/menu/menu-types/horizontal-menu","css/base/core/colors/palette-variables","css/base/core/colors/palette-noui","css/base/core/colors/palette-gradient","css/base/pages/ui-feather","css/base/pages/page-profile","css/base/pages/page-pricing","css/base/pages/page-misc","css/base/pages/page-knowledge-base","css/base/pages/page-faq","css/base/pages/page-coming-soon","css/base/pages/page-blog","css/base/pages/modal-create-app","css/base/pages/dashboard-ecommerce","css/base/pages/authentication","css/base/pages/app-todo","css/base/pages/app-kanban","css/base/pages/app-invoice","css/base/pages/app-invoice-print","css/base/pages/app-invoice-list","css/base/pages/app-file-manager","css/base/pages/app-email","css/base/pages/app-ecommerce","css/base/pages/app-ecommerce-details","css/base/pages/app-chat","css/base/pages/app-chat-list","css/base/pages/app-calendar","css/base/plugins/ui/coming-soon","css/base/plugins/maps/map-leaflet","css/base/plugins/forms/pickers/form-pickadate","css/base/plugins/forms/pickers/form-flat-pickr","css/base/plugins/forms/form-wizard","css/base/plugins/forms/form-validation","css/base/plugins/forms/form-quill-editor","css/base/plugins/forms/form-number-input","css/base/plugins/forms/form-file-uploader","css/base/plugins/extensions/ext-component-tree","css/base/plugins/extensions/ext-component-tour","css/base/plugins/extensions/ext-component-toastr","css/base/plugins/extensions/ext-component-swiper","css/base/plugins/extensions/ext-component-sweet-alerts","css/base/plugins/extensions/ext-component-sliders","css/base/plugins/extensions/ext-component-ratings"], () => (__webpack_require__("./resources/scss/base/pages/page-misc.scss")))
/******/ 	__webpack_require__.O(undefined, ["css/base/plugins/extensions/ext-component-media-player","css/base/plugins/extensions/ext-component-drag-drop","css/base/plugins/extensions/ext-component-context-menu","css/base/plugins/charts/chart-apex","css/style","css/overrides","css/core","css/base/themes/dark-layout","css/base/core/mixins/transitions","css/base/core/mixins/main-menu-mixin","css/base/core/mixins/hex2rgb","css/base/core/mixins/alert","css/base/core/menu/menu-types/vertical-overlay-menu","css/base/core/menu/menu-types/vertical-menu","css/base/core/menu/menu-types/horizontal-menu","css/base/core/colors/palette-variables","css/base/core/colors/palette-noui","css/base/core/colors/palette-gradient","css/base/pages/ui-feather","css/base/pages/page-profile","css/base/pages/page-pricing","css/base/pages/page-misc","css/base/pages/page-knowledge-base","css/base/pages/page-faq","css/base/pages/page-coming-soon","css/base/pages/page-blog","css/base/pages/modal-create-app","css/base/pages/dashboard-ecommerce","css/base/pages/authentication","css/base/pages/app-todo","css/base/pages/app-kanban","css/base/pages/app-invoice","css/base/pages/app-invoice-print","css/base/pages/app-invoice-list","css/base/pages/app-file-manager","css/base/pages/app-email","css/base/pages/app-ecommerce","css/base/pages/app-ecommerce-details","css/base/pages/app-chat","css/base/pages/app-chat-list","css/base/pages/app-calendar","css/base/plugins/ui/coming-soon","css/base/plugins/maps/map-leaflet","css/base/plugins/forms/pickers/form-pickadate","css/base/plugins/forms/pickers/form-flat-pickr","css/base/plugins/forms/form-wizard","css/base/plugins/forms/form-validation","css/base/plugins/forms/form-quill-editor","css/base/plugins/forms/form-number-input","css/base/plugins/forms/form-file-uploader","css/base/plugins/extensions/ext-component-tree","css/base/plugins/extensions/ext-component-tour","css/base/plugins/extensions/ext-component-toastr","css/base/plugins/extensions/ext-component-swiper","css/base/plugins/extensions/ext-component-sweet-alerts","css/base/plugins/extensions/ext-component-sliders","css/base/plugins/extensions/ext-component-ratings"], () => (__webpack_require__("./resources/scss/base/pages/page-pricing.scss")))
/******/ 	__webpack_require__.O(undefined, ["css/base/plugins/extensions/ext-component-media-player","css/base/plugins/extensions/ext-component-drag-drop","css/base/plugins/extensions/ext-component-context-menu","css/base/plugins/charts/chart-apex","css/style","css/overrides","css/core","css/base/themes/dark-layout","css/base/core/mixins/transitions","css/base/core/mixins/main-menu-mixin","css/base/core/mixins/hex2rgb","css/base/core/mixins/alert","css/base/core/menu/menu-types/vertical-overlay-menu","css/base/core/menu/menu-types/vertical-menu","css/base/core/menu/menu-types/horizontal-menu","css/base/core/colors/palette-variables","css/base/core/colors/palette-noui","css/base/core/colors/palette-gradient","css/base/pages/ui-feather","css/base/pages/page-profile","css/base/pages/page-pricing","css/base/pages/page-misc","css/base/pages/page-knowledge-base","css/base/pages/page-faq","css/base/pages/page-coming-soon","css/base/pages/page-blog","css/base/pages/modal-create-app","css/base/pages/dashboard-ecommerce","css/base/pages/authentication","css/base/pages/app-todo","css/base/pages/app-kanban","css/base/pages/app-invoice","css/base/pages/app-invoice-print","css/base/pages/app-invoice-list","css/base/pages/app-file-manager","css/base/pages/app-email","css/base/pages/app-ecommerce","css/base/pages/app-ecommerce-details","css/base/pages/app-chat","css/base/pages/app-chat-list","css/base/pages/app-calendar","css/base/plugins/ui/coming-soon","css/base/plugins/maps/map-leaflet","css/base/plugins/forms/pickers/form-pickadate","css/base/plugins/forms/pickers/form-flat-pickr","css/base/plugins/forms/form-wizard","css/base/plugins/forms/form-validation","css/base/plugins/forms/form-quill-editor","css/base/plugins/forms/form-number-input","css/base/plugins/forms/form-file-uploader","css/base/plugins/extensions/ext-component-tree","css/base/plugins/extensions/ext-component-tour","css/base/plugins/extensions/ext-component-toastr","css/base/plugins/extensions/ext-component-swiper","css/base/plugins/extensions/ext-component-sweet-alerts","css/base/plugins/extensions/ext-component-sliders","css/base/plugins/extensions/ext-component-ratings"], () => (__webpack_require__("./resources/scss/base/pages/page-profile.scss")))
/******/ 	__webpack_require__.O(undefined, ["css/base/plugins/extensions/ext-component-media-player","css/base/plugins/extensions/ext-component-drag-drop","css/base/plugins/extensions/ext-component-context-menu","css/base/plugins/charts/chart-apex","css/style","css/overrides","css/core","css/base/themes/dark-layout","css/base/core/mixins/transitions","css/base/core/mixins/main-menu-mixin","css/base/core/mixins/hex2rgb","css/base/core/mixins/alert","css/base/core/menu/menu-types/vertical-overlay-menu","css/base/core/menu/menu-types/vertical-menu","css/base/core/menu/menu-types/horizontal-menu","css/base/core/colors/palette-variables","css/base/core/colors/palette-noui","css/base/core/colors/palette-gradient","css/base/pages/ui-feather","css/base/pages/page-profile","css/base/pages/page-pricing","css/base/pages/page-misc","css/base/pages/page-knowledge-base","css/base/pages/page-faq","css/base/pages/page-coming-soon","css/base/pages/page-blog","css/base/pages/modal-create-app","css/base/pages/dashboard-ecommerce","css/base/pages/authentication","css/base/pages/app-todo","css/base/pages/app-kanban","css/base/pages/app-invoice","css/base/pages/app-invoice-print","css/base/pages/app-invoice-list","css/base/pages/app-file-manager","css/base/pages/app-email","css/base/pages/app-ecommerce","css/base/pages/app-ecommerce-details","css/base/pages/app-chat","css/base/pages/app-chat-list","css/base/pages/app-calendar","css/base/plugins/ui/coming-soon","css/base/plugins/maps/map-leaflet","css/base/plugins/forms/pickers/form-pickadate","css/base/plugins/forms/pickers/form-flat-pickr","css/base/plugins/forms/form-wizard","css/base/plugins/forms/form-validation","css/base/plugins/forms/form-quill-editor","css/base/plugins/forms/form-number-input","css/base/plugins/forms/form-file-uploader","css/base/plugins/extensions/ext-component-tree","css/base/plugins/extensions/ext-component-tour","css/base/plugins/extensions/ext-component-toastr","css/base/plugins/extensions/ext-component-swiper","css/base/plugins/extensions/ext-component-sweet-alerts","css/base/plugins/extensions/ext-component-sliders","css/base/plugins/extensions/ext-component-ratings"], () => (__webpack_require__("./resources/scss/base/pages/ui-feather.scss")))
/******/ 	__webpack_require__.O(undefined, ["css/base/plugins/extensions/ext-component-media-player","css/base/plugins/extensions/ext-component-drag-drop","css/base/plugins/extensions/ext-component-context-menu","css/base/plugins/charts/chart-apex","css/style","css/overrides","css/core","css/base/themes/dark-layout","css/base/core/mixins/transitions","css/base/core/mixins/main-menu-mixin","css/base/core/mixins/hex2rgb","css/base/core/mixins/alert","css/base/core/menu/menu-types/vertical-overlay-menu","css/base/core/menu/menu-types/vertical-menu","css/base/core/menu/menu-types/horizontal-menu","css/base/core/colors/palette-variables","css/base/core/colors/palette-noui","css/base/core/colors/palette-gradient","css/base/pages/ui-feather","css/base/pages/page-profile","css/base/pages/page-pricing","css/base/pages/page-misc","css/base/pages/page-knowledge-base","css/base/pages/page-faq","css/base/pages/page-coming-soon","css/base/pages/page-blog","css/base/pages/modal-create-app","css/base/pages/dashboard-ecommerce","css/base/pages/authentication","css/base/pages/app-todo","css/base/pages/app-kanban","css/base/pages/app-invoice","css/base/pages/app-invoice-print","css/base/pages/app-invoice-list","css/base/pages/app-file-manager","css/base/pages/app-email","css/base/pages/app-ecommerce","css/base/pages/app-ecommerce-details","css/base/pages/app-chat","css/base/pages/app-chat-list","css/base/pages/app-calendar","css/base/plugins/ui/coming-soon","css/base/plugins/maps/map-leaflet","css/base/plugins/forms/pickers/form-pickadate","css/base/plugins/forms/pickers/form-flat-pickr","css/base/plugins/forms/form-wizard","css/base/plugins/forms/form-validation","css/base/plugins/forms/form-quill-editor","css/base/plugins/forms/form-number-input","css/base/plugins/forms/form-file-uploader","css/base/plugins/extensions/ext-component-tree","css/base/plugins/extensions/ext-component-tour","css/base/plugins/extensions/ext-component-toastr","css/base/plugins/extensions/ext-component-swiper","css/base/plugins/extensions/ext-component-sweet-alerts","css/base/plugins/extensions/ext-component-sliders","css/base/plugins/extensions/ext-component-ratings"], () => (__webpack_require__("./resources/scss/base/core/colors/palette-gradient.scss")))
/******/ 	__webpack_require__.O(undefined, ["css/base/plugins/extensions/ext-component-media-player","css/base/plugins/extensions/ext-component-drag-drop","css/base/plugins/extensions/ext-component-context-menu","css/base/plugins/charts/chart-apex","css/style","css/overrides","css/core","css/base/themes/dark-layout","css/base/core/mixins/transitions","css/base/core/mixins/main-menu-mixin","css/base/core/mixins/hex2rgb","css/base/core/mixins/alert","css/base/core/menu/menu-types/vertical-overlay-menu","css/base/core/menu/menu-types/vertical-menu","css/base/core/menu/menu-types/horizontal-menu","css/base/core/colors/palette-variables","css/base/core/colors/palette-noui","css/base/core/colors/palette-gradient","css/base/pages/ui-feather","css/base/pages/page-profile","css/base/pages/page-pricing","css/base/pages/page-misc","css/base/pages/page-knowledge-base","css/base/pages/page-faq","css/base/pages/page-coming-soon","css/base/pages/page-blog","css/base/pages/modal-create-app","css/base/pages/dashboard-ecommerce","css/base/pages/authentication","css/base/pages/app-todo","css/base/pages/app-kanban","css/base/pages/app-invoice","css/base/pages/app-invoice-print","css/base/pages/app-invoice-list","css/base/pages/app-file-manager","css/base/pages/app-email","css/base/pages/app-ecommerce","css/base/pages/app-ecommerce-details","css/base/pages/app-chat","css/base/pages/app-chat-list","css/base/pages/app-calendar","css/base/plugins/ui/coming-soon","css/base/plugins/maps/map-leaflet","css/base/plugins/forms/pickers/form-pickadate","css/base/plugins/forms/pickers/form-flat-pickr","css/base/plugins/forms/form-wizard","css/base/plugins/forms/form-validation","css/base/plugins/forms/form-quill-editor","css/base/plugins/forms/form-number-input","css/base/plugins/forms/form-file-uploader","css/base/plugins/extensions/ext-component-tree","css/base/plugins/extensions/ext-component-tour","css/base/plugins/extensions/ext-component-toastr","css/base/plugins/extensions/ext-component-swiper","css/base/plugins/extensions/ext-component-sweet-alerts","css/base/plugins/extensions/ext-component-sliders","css/base/plugins/extensions/ext-component-ratings"], () => (__webpack_require__("./resources/scss/base/core/colors/palette-noui.scss")))
/******/ 	__webpack_require__.O(undefined, ["css/base/plugins/extensions/ext-component-media-player","css/base/plugins/extensions/ext-component-drag-drop","css/base/plugins/extensions/ext-component-context-menu","css/base/plugins/charts/chart-apex","css/style","css/overrides","css/core","css/base/themes/dark-layout","css/base/core/mixins/transitions","css/base/core/mixins/main-menu-mixin","css/base/core/mixins/hex2rgb","css/base/core/mixins/alert","css/base/core/menu/menu-types/vertical-overlay-menu","css/base/core/menu/menu-types/vertical-menu","css/base/core/menu/menu-types/horizontal-menu","css/base/core/colors/palette-variables","css/base/core/colors/palette-noui","css/base/core/colors/palette-gradient","css/base/pages/ui-feather","css/base/pages/page-profile","css/base/pages/page-pricing","css/base/pages/page-misc","css/base/pages/page-knowledge-base","css/base/pages/page-faq","css/base/pages/page-coming-soon","css/base/pages/page-blog","css/base/pages/modal-create-app","css/base/pages/dashboard-ecommerce","css/base/pages/authentication","css/base/pages/app-todo","css/base/pages/app-kanban","css/base/pages/app-invoice","css/base/pages/app-invoice-print","css/base/pages/app-invoice-list","css/base/pages/app-file-manager","css/base/pages/app-email","css/base/pages/app-ecommerce","css/base/pages/app-ecommerce-details","css/base/pages/app-chat","css/base/pages/app-chat-list","css/base/pages/app-calendar","css/base/plugins/ui/coming-soon","css/base/plugins/maps/map-leaflet","css/base/plugins/forms/pickers/form-pickadate","css/base/plugins/forms/pickers/form-flat-pickr","css/base/plugins/forms/form-wizard","css/base/plugins/forms/form-validation","css/base/plugins/forms/form-quill-editor","css/base/plugins/forms/form-number-input","css/base/plugins/forms/form-file-uploader","css/base/plugins/extensions/ext-component-tree","css/base/plugins/extensions/ext-component-tour","css/base/plugins/extensions/ext-component-toastr","css/base/plugins/extensions/ext-component-swiper","css/base/plugins/extensions/ext-component-sweet-alerts","css/base/plugins/extensions/ext-component-sliders","css/base/plugins/extensions/ext-component-ratings"], () => (__webpack_require__("./resources/scss/base/core/colors/palette-variables.scss")))
/******/ 	__webpack_require__.O(undefined, ["css/base/plugins/extensions/ext-component-media-player","css/base/plugins/extensions/ext-component-drag-drop","css/base/plugins/extensions/ext-component-context-menu","css/base/plugins/charts/chart-apex","css/style","css/overrides","css/core","css/base/themes/dark-layout","css/base/core/mixins/transitions","css/base/core/mixins/main-menu-mixin","css/base/core/mixins/hex2rgb","css/base/core/mixins/alert","css/base/core/menu/menu-types/vertical-overlay-menu","css/base/core/menu/menu-types/vertical-menu","css/base/core/menu/menu-types/horizontal-menu","css/base/core/colors/palette-variables","css/base/core/colors/palette-noui","css/base/core/colors/palette-gradient","css/base/pages/ui-feather","css/base/pages/page-profile","css/base/pages/page-pricing","css/base/pages/page-misc","css/base/pages/page-knowledge-base","css/base/pages/page-faq","css/base/pages/page-coming-soon","css/base/pages/page-blog","css/base/pages/modal-create-app","css/base/pages/dashboard-ecommerce","css/base/pages/authentication","css/base/pages/app-todo","css/base/pages/app-kanban","css/base/pages/app-invoice","css/base/pages/app-invoice-print","css/base/pages/app-invoice-list","css/base/pages/app-file-manager","css/base/pages/app-email","css/base/pages/app-ecommerce","css/base/pages/app-ecommerce-details","css/base/pages/app-chat","css/base/pages/app-chat-list","css/base/pages/app-calendar","css/base/plugins/ui/coming-soon","css/base/plugins/maps/map-leaflet","css/base/plugins/forms/pickers/form-pickadate","css/base/plugins/forms/pickers/form-flat-pickr","css/base/plugins/forms/form-wizard","css/base/plugins/forms/form-validation","css/base/plugins/forms/form-quill-editor","css/base/plugins/forms/form-number-input","css/base/plugins/forms/form-file-uploader","css/base/plugins/extensions/ext-component-tree","css/base/plugins/extensions/ext-component-tour","css/base/plugins/extensions/ext-component-toastr","css/base/plugins/extensions/ext-component-swiper","css/base/plugins/extensions/ext-component-sweet-alerts","css/base/plugins/extensions/ext-component-sliders","css/base/plugins/extensions/ext-component-ratings"], () => (__webpack_require__("./resources/scss/base/core/menu/menu-types/horizontal-menu.scss")))
/******/ 	__webpack_require__.O(undefined, ["css/base/plugins/extensions/ext-component-media-player","css/base/plugins/extensions/ext-component-drag-drop","css/base/plugins/extensions/ext-component-context-menu","css/base/plugins/charts/chart-apex","css/style","css/overrides","css/core","css/base/themes/dark-layout","css/base/core/mixins/transitions","css/base/core/mixins/main-menu-mixin","css/base/core/mixins/hex2rgb","css/base/core/mixins/alert","css/base/core/menu/menu-types/vertical-overlay-menu","css/base/core/menu/menu-types/vertical-menu","css/base/core/menu/menu-types/horizontal-menu","css/base/core/colors/palette-variables","css/base/core/colors/palette-noui","css/base/core/colors/palette-gradient","css/base/pages/ui-feather","css/base/pages/page-profile","css/base/pages/page-pricing","css/base/pages/page-misc","css/base/pages/page-knowledge-base","css/base/pages/page-faq","css/base/pages/page-coming-soon","css/base/pages/page-blog","css/base/pages/modal-create-app","css/base/pages/dashboard-ecommerce","css/base/pages/authentication","css/base/pages/app-todo","css/base/pages/app-kanban","css/base/pages/app-invoice","css/base/pages/app-invoice-print","css/base/pages/app-invoice-list","css/base/pages/app-file-manager","css/base/pages/app-email","css/base/pages/app-ecommerce","css/base/pages/app-ecommerce-details","css/base/pages/app-chat","css/base/pages/app-chat-list","css/base/pages/app-calendar","css/base/plugins/ui/coming-soon","css/base/plugins/maps/map-leaflet","css/base/plugins/forms/pickers/form-pickadate","css/base/plugins/forms/pickers/form-flat-pickr","css/base/plugins/forms/form-wizard","css/base/plugins/forms/form-validation","css/base/plugins/forms/form-quill-editor","css/base/plugins/forms/form-number-input","css/base/plugins/forms/form-file-uploader","css/base/plugins/extensions/ext-component-tree","css/base/plugins/extensions/ext-component-tour","css/base/plugins/extensions/ext-component-toastr","css/base/plugins/extensions/ext-component-swiper","css/base/plugins/extensions/ext-component-sweet-alerts","css/base/plugins/extensions/ext-component-sliders","css/base/plugins/extensions/ext-component-ratings"], () => (__webpack_require__("./resources/scss/base/core/menu/menu-types/vertical-menu.scss")))
/******/ 	__webpack_require__.O(undefined, ["css/base/plugins/extensions/ext-component-media-player","css/base/plugins/extensions/ext-component-drag-drop","css/base/plugins/extensions/ext-component-context-menu","css/base/plugins/charts/chart-apex","css/style","css/overrides","css/core","css/base/themes/dark-layout","css/base/core/mixins/transitions","css/base/core/mixins/main-menu-mixin","css/base/core/mixins/hex2rgb","css/base/core/mixins/alert","css/base/core/menu/menu-types/vertical-overlay-menu","css/base/core/menu/menu-types/vertical-menu","css/base/core/menu/menu-types/horizontal-menu","css/base/core/colors/palette-variables","css/base/core/colors/palette-noui","css/base/core/colors/palette-gradient","css/base/pages/ui-feather","css/base/pages/page-profile","css/base/pages/page-pricing","css/base/pages/page-misc","css/base/pages/page-knowledge-base","css/base/pages/page-faq","css/base/pages/page-coming-soon","css/base/pages/page-blog","css/base/pages/modal-create-app","css/base/pages/dashboard-ecommerce","css/base/pages/authentication","css/base/pages/app-todo","css/base/pages/app-kanban","css/base/pages/app-invoice","css/base/pages/app-invoice-print","css/base/pages/app-invoice-list","css/base/pages/app-file-manager","css/base/pages/app-email","css/base/pages/app-ecommerce","css/base/pages/app-ecommerce-details","css/base/pages/app-chat","css/base/pages/app-chat-list","css/base/pages/app-calendar","css/base/plugins/ui/coming-soon","css/base/plugins/maps/map-leaflet","css/base/plugins/forms/pickers/form-pickadate","css/base/plugins/forms/pickers/form-flat-pickr","css/base/plugins/forms/form-wizard","css/base/plugins/forms/form-validation","css/base/plugins/forms/form-quill-editor","css/base/plugins/forms/form-number-input","css/base/plugins/forms/form-file-uploader","css/base/plugins/extensions/ext-component-tree","css/base/plugins/extensions/ext-component-tour","css/base/plugins/extensions/ext-component-toastr","css/base/plugins/extensions/ext-component-swiper","css/base/plugins/extensions/ext-component-sweet-alerts","css/base/plugins/extensions/ext-component-sliders","css/base/plugins/extensions/ext-component-ratings"], () => (__webpack_require__("./resources/scss/base/core/menu/menu-types/vertical-overlay-menu.scss")))
/******/ 	__webpack_require__.O(undefined, ["css/base/plugins/extensions/ext-component-media-player","css/base/plugins/extensions/ext-component-drag-drop","css/base/plugins/extensions/ext-component-context-menu","css/base/plugins/charts/chart-apex","css/style","css/overrides","css/core","css/base/themes/dark-layout","css/base/core/mixins/transitions","css/base/core/mixins/main-menu-mixin","css/base/core/mixins/hex2rgb","css/base/core/mixins/alert","css/base/core/menu/menu-types/vertical-overlay-menu","css/base/core/menu/menu-types/vertical-menu","css/base/core/menu/menu-types/horizontal-menu","css/base/core/colors/palette-variables","css/base/core/colors/palette-noui","css/base/core/colors/palette-gradient","css/base/pages/ui-feather","css/base/pages/page-profile","css/base/pages/page-pricing","css/base/pages/page-misc","css/base/pages/page-knowledge-base","css/base/pages/page-faq","css/base/pages/page-coming-soon","css/base/pages/page-blog","css/base/pages/modal-create-app","css/base/pages/dashboard-ecommerce","css/base/pages/authentication","css/base/pages/app-todo","css/base/pages/app-kanban","css/base/pages/app-invoice","css/base/pages/app-invoice-print","css/base/pages/app-invoice-list","css/base/pages/app-file-manager","css/base/pages/app-email","css/base/pages/app-ecommerce","css/base/pages/app-ecommerce-details","css/base/pages/app-chat","css/base/pages/app-chat-list","css/base/pages/app-calendar","css/base/plugins/ui/coming-soon","css/base/plugins/maps/map-leaflet","css/base/plugins/forms/pickers/form-pickadate","css/base/plugins/forms/pickers/form-flat-pickr","css/base/plugins/forms/form-wizard","css/base/plugins/forms/form-validation","css/base/plugins/forms/form-quill-editor","css/base/plugins/forms/form-number-input","css/base/plugins/forms/form-file-uploader","css/base/plugins/extensions/ext-component-tree","css/base/plugins/extensions/ext-component-tour","css/base/plugins/extensions/ext-component-toastr","css/base/plugins/extensions/ext-component-swiper","css/base/plugins/extensions/ext-component-sweet-alerts","css/base/plugins/extensions/ext-component-sliders","css/base/plugins/extensions/ext-component-ratings"], () => (__webpack_require__("./resources/scss/base/core/mixins/alert.scss")))
/******/ 	__webpack_require__.O(undefined, ["css/base/plugins/extensions/ext-component-media-player","css/base/plugins/extensions/ext-component-drag-drop","css/base/plugins/extensions/ext-component-context-menu","css/base/plugins/charts/chart-apex","css/style","css/overrides","css/core","css/base/themes/dark-layout","css/base/core/mixins/transitions","css/base/core/mixins/main-menu-mixin","css/base/core/mixins/hex2rgb","css/base/core/mixins/alert","css/base/core/menu/menu-types/vertical-overlay-menu","css/base/core/menu/menu-types/vertical-menu","css/base/core/menu/menu-types/horizontal-menu","css/base/core/colors/palette-variables","css/base/core/colors/palette-noui","css/base/core/colors/palette-gradient","css/base/pages/ui-feather","css/base/pages/page-profile","css/base/pages/page-pricing","css/base/pages/page-misc","css/base/pages/page-knowledge-base","css/base/pages/page-faq","css/base/pages/page-coming-soon","css/base/pages/page-blog","css/base/pages/modal-create-app","css/base/pages/dashboard-ecommerce","css/base/pages/authentication","css/base/pages/app-todo","css/base/pages/app-kanban","css/base/pages/app-invoice","css/base/pages/app-invoice-print","css/base/pages/app-invoice-list","css/base/pages/app-file-manager","css/base/pages/app-email","css/base/pages/app-ecommerce","css/base/pages/app-ecommerce-details","css/base/pages/app-chat","css/base/pages/app-chat-list","css/base/pages/app-calendar","css/base/plugins/ui/coming-soon","css/base/plugins/maps/map-leaflet","css/base/plugins/forms/pickers/form-pickadate","css/base/plugins/forms/pickers/form-flat-pickr","css/base/plugins/forms/form-wizard","css/base/plugins/forms/form-validation","css/base/plugins/forms/form-quill-editor","css/base/plugins/forms/form-number-input","css/base/plugins/forms/form-file-uploader","css/base/plugins/extensions/ext-component-tree","css/base/plugins/extensions/ext-component-tour","css/base/plugins/extensions/ext-component-toastr","css/base/plugins/extensions/ext-component-swiper","css/base/plugins/extensions/ext-component-sweet-alerts","css/base/plugins/extensions/ext-component-sliders","css/base/plugins/extensions/ext-component-ratings"], () => (__webpack_require__("./resources/scss/base/core/mixins/hex2rgb.scss")))
/******/ 	__webpack_require__.O(undefined, ["css/base/plugins/extensions/ext-component-media-player","css/base/plugins/extensions/ext-component-drag-drop","css/base/plugins/extensions/ext-component-context-menu","css/base/plugins/charts/chart-apex","css/style","css/overrides","css/core","css/base/themes/dark-layout","css/base/core/mixins/transitions","css/base/core/mixins/main-menu-mixin","css/base/core/mixins/hex2rgb","css/base/core/mixins/alert","css/base/core/menu/menu-types/vertical-overlay-menu","css/base/core/menu/menu-types/vertical-menu","css/base/core/menu/menu-types/horizontal-menu","css/base/core/colors/palette-variables","css/base/core/colors/palette-noui","css/base/core/colors/palette-gradient","css/base/pages/ui-feather","css/base/pages/page-profile","css/base/pages/page-pricing","css/base/pages/page-misc","css/base/pages/page-knowledge-base","css/base/pages/page-faq","css/base/pages/page-coming-soon","css/base/pages/page-blog","css/base/pages/modal-create-app","css/base/pages/dashboard-ecommerce","css/base/pages/authentication","css/base/pages/app-todo","css/base/pages/app-kanban","css/base/pages/app-invoice","css/base/pages/app-invoice-print","css/base/pages/app-invoice-list","css/base/pages/app-file-manager","css/base/pages/app-email","css/base/pages/app-ecommerce","css/base/pages/app-ecommerce-details","css/base/pages/app-chat","css/base/pages/app-chat-list","css/base/pages/app-calendar","css/base/plugins/ui/coming-soon","css/base/plugins/maps/map-leaflet","css/base/plugins/forms/pickers/form-pickadate","css/base/plugins/forms/pickers/form-flat-pickr","css/base/plugins/forms/form-wizard","css/base/plugins/forms/form-validation","css/base/plugins/forms/form-quill-editor","css/base/plugins/forms/form-number-input","css/base/plugins/forms/form-file-uploader","css/base/plugins/extensions/ext-component-tree","css/base/plugins/extensions/ext-component-tour","css/base/plugins/extensions/ext-component-toastr","css/base/plugins/extensions/ext-component-swiper","css/base/plugins/extensions/ext-component-sweet-alerts","css/base/plugins/extensions/ext-component-sliders","css/base/plugins/extensions/ext-component-ratings"], () => (__webpack_require__("./resources/scss/base/core/mixins/main-menu-mixin.scss")))
/******/ 	__webpack_require__.O(undefined, ["css/base/plugins/extensions/ext-component-media-player","css/base/plugins/extensions/ext-component-drag-drop","css/base/plugins/extensions/ext-component-context-menu","css/base/plugins/charts/chart-apex","css/style","css/overrides","css/core","css/base/themes/dark-layout","css/base/core/mixins/transitions","css/base/core/mixins/main-menu-mixin","css/base/core/mixins/hex2rgb","css/base/core/mixins/alert","css/base/core/menu/menu-types/vertical-overlay-menu","css/base/core/menu/menu-types/vertical-menu","css/base/core/menu/menu-types/horizontal-menu","css/base/core/colors/palette-variables","css/base/core/colors/palette-noui","css/base/core/colors/palette-gradient","css/base/pages/ui-feather","css/base/pages/page-profile","css/base/pages/page-pricing","css/base/pages/page-misc","css/base/pages/page-knowledge-base","css/base/pages/page-faq","css/base/pages/page-coming-soon","css/base/pages/page-blog","css/base/pages/modal-create-app","css/base/pages/dashboard-ecommerce","css/base/pages/authentication","css/base/pages/app-todo","css/base/pages/app-kanban","css/base/pages/app-invoice","css/base/pages/app-invoice-print","css/base/pages/app-invoice-list","css/base/pages/app-file-manager","css/base/pages/app-email","css/base/pages/app-ecommerce","css/base/pages/app-ecommerce-details","css/base/pages/app-chat","css/base/pages/app-chat-list","css/base/pages/app-calendar","css/base/plugins/ui/coming-soon","css/base/plugins/maps/map-leaflet","css/base/plugins/forms/pickers/form-pickadate","css/base/plugins/forms/pickers/form-flat-pickr","css/base/plugins/forms/form-wizard","css/base/plugins/forms/form-validation","css/base/plugins/forms/form-quill-editor","css/base/plugins/forms/form-number-input","css/base/plugins/forms/form-file-uploader","css/base/plugins/extensions/ext-component-tree","css/base/plugins/extensions/ext-component-tour","css/base/plugins/extensions/ext-component-toastr","css/base/plugins/extensions/ext-component-swiper","css/base/plugins/extensions/ext-component-sweet-alerts","css/base/plugins/extensions/ext-component-sliders","css/base/plugins/extensions/ext-component-ratings"], () => (__webpack_require__("./resources/scss/base/core/mixins/transitions.scss")))
/******/ 	__webpack_require__.O(undefined, ["css/base/plugins/extensions/ext-component-media-player","css/base/plugins/extensions/ext-component-drag-drop","css/base/plugins/extensions/ext-component-context-menu","css/base/plugins/charts/chart-apex","css/style","css/overrides","css/core","css/base/themes/dark-layout","css/base/core/mixins/transitions","css/base/core/mixins/main-menu-mixin","css/base/core/mixins/hex2rgb","css/base/core/mixins/alert","css/base/core/menu/menu-types/vertical-overlay-menu","css/base/core/menu/menu-types/vertical-menu","css/base/core/menu/menu-types/horizontal-menu","css/base/core/colors/palette-variables","css/base/core/colors/palette-noui","css/base/core/colors/palette-gradient","css/base/pages/ui-feather","css/base/pages/page-profile","css/base/pages/page-pricing","css/base/pages/page-misc","css/base/pages/page-knowledge-base","css/base/pages/page-faq","css/base/pages/page-coming-soon","css/base/pages/page-blog","css/base/pages/modal-create-app","css/base/pages/dashboard-ecommerce","css/base/pages/authentication","css/base/pages/app-todo","css/base/pages/app-kanban","css/base/pages/app-invoice","css/base/pages/app-invoice-print","css/base/pages/app-invoice-list","css/base/pages/app-file-manager","css/base/pages/app-email","css/base/pages/app-ecommerce","css/base/pages/app-ecommerce-details","css/base/pages/app-chat","css/base/pages/app-chat-list","css/base/pages/app-calendar","css/base/plugins/ui/coming-soon","css/base/plugins/maps/map-leaflet","css/base/plugins/forms/pickers/form-pickadate","css/base/plugins/forms/pickers/form-flat-pickr","css/base/plugins/forms/form-wizard","css/base/plugins/forms/form-validation","css/base/plugins/forms/form-quill-editor","css/base/plugins/forms/form-number-input","css/base/plugins/forms/form-file-uploader","css/base/plugins/extensions/ext-component-tree","css/base/plugins/extensions/ext-component-tour","css/base/plugins/extensions/ext-component-toastr","css/base/plugins/extensions/ext-component-swiper","css/base/plugins/extensions/ext-component-sweet-alerts","css/base/plugins/extensions/ext-component-sliders","css/base/plugins/extensions/ext-component-ratings"], () => (__webpack_require__("./resources/scss/base/themes/dark-layout.scss")))
/******/ 	__webpack_require__.O(undefined, ["css/base/plugins/extensions/ext-component-media-player","css/base/plugins/extensions/ext-component-drag-drop","css/base/plugins/extensions/ext-component-context-menu","css/base/plugins/charts/chart-apex","css/style","css/overrides","css/core","css/base/themes/dark-layout","css/base/core/mixins/transitions","css/base/core/mixins/main-menu-mixin","css/base/core/mixins/hex2rgb","css/base/core/mixins/alert","css/base/core/menu/menu-types/vertical-overlay-menu","css/base/core/menu/menu-types/vertical-menu","css/base/core/menu/menu-types/horizontal-menu","css/base/core/colors/palette-variables","css/base/core/colors/palette-noui","css/base/core/colors/palette-gradient","css/base/pages/ui-feather","css/base/pages/page-profile","css/base/pages/page-pricing","css/base/pages/page-misc","css/base/pages/page-knowledge-base","css/base/pages/page-faq","css/base/pages/page-coming-soon","css/base/pages/page-blog","css/base/pages/modal-create-app","css/base/pages/dashboard-ecommerce","css/base/pages/authentication","css/base/pages/app-todo","css/base/pages/app-kanban","css/base/pages/app-invoice","css/base/pages/app-invoice-print","css/base/pages/app-invoice-list","css/base/pages/app-file-manager","css/base/pages/app-email","css/base/pages/app-ecommerce","css/base/pages/app-ecommerce-details","css/base/pages/app-chat","css/base/pages/app-chat-list","css/base/pages/app-calendar","css/base/plugins/ui/coming-soon","css/base/plugins/maps/map-leaflet","css/base/plugins/forms/pickers/form-pickadate","css/base/plugins/forms/pickers/form-flat-pickr","css/base/plugins/forms/form-wizard","css/base/plugins/forms/form-validation","css/base/plugins/forms/form-quill-editor","css/base/plugins/forms/form-number-input","css/base/plugins/forms/form-file-uploader","css/base/plugins/extensions/ext-component-tree","css/base/plugins/extensions/ext-component-tour","css/base/plugins/extensions/ext-component-toastr","css/base/plugins/extensions/ext-component-swiper","css/base/plugins/extensions/ext-component-sweet-alerts","css/base/plugins/extensions/ext-component-sliders","css/base/plugins/extensions/ext-component-ratings"], () => (__webpack_require__("./resources/scss/core.scss")))
/******/ 	__webpack_require__.O(undefined, ["css/base/plugins/extensions/ext-component-media-player","css/base/plugins/extensions/ext-component-drag-drop","css/base/plugins/extensions/ext-component-context-menu","css/base/plugins/charts/chart-apex","css/style","css/overrides","css/core","css/base/themes/dark-layout","css/base/core/mixins/transitions","css/base/core/mixins/main-menu-mixin","css/base/core/mixins/hex2rgb","css/base/core/mixins/alert","css/base/core/menu/menu-types/vertical-overlay-menu","css/base/core/menu/menu-types/vertical-menu","css/base/core/menu/menu-types/horizontal-menu","css/base/core/colors/palette-variables","css/base/core/colors/palette-noui","css/base/core/colors/palette-gradient","css/base/pages/ui-feather","css/base/pages/page-profile","css/base/pages/page-pricing","css/base/pages/page-misc","css/base/pages/page-knowledge-base","css/base/pages/page-faq","css/base/pages/page-coming-soon","css/base/pages/page-blog","css/base/pages/modal-create-app","css/base/pages/dashboard-ecommerce","css/base/pages/authentication","css/base/pages/app-todo","css/base/pages/app-kanban","css/base/pages/app-invoice","css/base/pages/app-invoice-print","css/base/pages/app-invoice-list","css/base/pages/app-file-manager","css/base/pages/app-email","css/base/pages/app-ecommerce","css/base/pages/app-ecommerce-details","css/base/pages/app-chat","css/base/pages/app-chat-list","css/base/pages/app-calendar","css/base/plugins/ui/coming-soon","css/base/plugins/maps/map-leaflet","css/base/plugins/forms/pickers/form-pickadate","css/base/plugins/forms/pickers/form-flat-pickr","css/base/plugins/forms/form-wizard","css/base/plugins/forms/form-validation","css/base/plugins/forms/form-quill-editor","css/base/plugins/forms/form-number-input","css/base/plugins/forms/form-file-uploader","css/base/plugins/extensions/ext-component-tree","css/base/plugins/extensions/ext-component-tour","css/base/plugins/extensions/ext-component-toastr","css/base/plugins/extensions/ext-component-swiper","css/base/plugins/extensions/ext-component-sweet-alerts","css/base/plugins/extensions/ext-component-sliders","css/base/plugins/extensions/ext-component-ratings"], () => (__webpack_require__("./resources/scss/overrides.scss")))
/******/ 	var __webpack_exports__ = __webpack_require__.O(undefined, ["css/base/plugins/extensions/ext-component-media-player","css/base/plugins/extensions/ext-component-drag-drop","css/base/plugins/extensions/ext-component-context-menu","css/base/plugins/charts/chart-apex","css/style","css/overrides","css/core","css/base/themes/dark-layout","css/base/core/mixins/transitions","css/base/core/mixins/main-menu-mixin","css/base/core/mixins/hex2rgb","css/base/core/mixins/alert","css/base/core/menu/menu-types/vertical-overlay-menu","css/base/core/menu/menu-types/vertical-menu","css/base/core/menu/menu-types/horizontal-menu","css/base/core/colors/palette-variables","css/base/core/colors/palette-noui","css/base/core/colors/palette-gradient","css/base/pages/ui-feather","css/base/pages/page-profile","css/base/pages/page-pricing","css/base/pages/page-misc","css/base/pages/page-knowledge-base","css/base/pages/page-faq","css/base/pages/page-coming-soon","css/base/pages/page-blog","css/base/pages/modal-create-app","css/base/pages/dashboard-ecommerce","css/base/pages/authentication","css/base/pages/app-todo","css/base/pages/app-kanban","css/base/pages/app-invoice","css/base/pages/app-invoice-print","css/base/pages/app-invoice-list","css/base/pages/app-file-manager","css/base/pages/app-email","css/base/pages/app-ecommerce","css/base/pages/app-ecommerce-details","css/base/pages/app-chat","css/base/pages/app-chat-list","css/base/pages/app-calendar","css/base/plugins/ui/coming-soon","css/base/plugins/maps/map-leaflet","css/base/plugins/forms/pickers/form-pickadate","css/base/plugins/forms/pickers/form-flat-pickr","css/base/plugins/forms/form-wizard","css/base/plugins/forms/form-validation","css/base/plugins/forms/form-quill-editor","css/base/plugins/forms/form-number-input","css/base/plugins/forms/form-file-uploader","css/base/plugins/extensions/ext-component-tree","css/base/plugins/extensions/ext-component-tour","css/base/plugins/extensions/ext-component-toastr","css/base/plugins/extensions/ext-component-swiper","css/base/plugins/extensions/ext-component-sweet-alerts","css/base/plugins/extensions/ext-component-sliders","css/base/plugins/extensions/ext-component-ratings"], () => (__webpack_require__("./resources/assets/scss/style.scss")))
/******/ 	__webpack_exports__ = __webpack_require__.O(__webpack_exports__);
/******/ 	
/******/ })()
;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiL2pzL21haW4uanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkIsaUJBQWlCLFFBQVE7QUFDekI7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQSxlQUFlLGVBQWU7QUFDOUIsZUFBZSxlQUFlO0FBQzlCLGlCQUFpQixRQUFRO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7Ozs7Ozs7OztBQzVCQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxtQkFBTyxDQUFDLHNEQUFRO0FBQzNCLFVBQVUsbUJBQU8sQ0FBQyxrRUFBVztBQUM3QixVQUFVLG1CQUFPLENBQUMsd0VBQWlCOztBQUVuQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsV0FBVyxRQUFRO0FBQ25CO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSx3Q0FBd0M7QUFDeEM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFVBQVU7QUFDckI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsVUFBVTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxlQUFlO0FBQzFCLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLGVBQWU7QUFDMUIsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxlQUFlO0FBQzFCLFdBQVcsZUFBZTtBQUMxQixhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQ3pOQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7Ozs7Ozs7Ozs7O0FDdkRyQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDO0FBQzdD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QUFFdmUsZ0NBQWdDOztBQUVoQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsdURBQXVELGNBQWM7QUFDckU7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTs7Ozs7Ozs7Ozs7O0FDbkNBOzs7Ozs7Ozs7Ozs7O0FDQUE7Ozs7Ozs7Ozs7Ozs7QUNBQTs7Ozs7Ozs7Ozs7OztBQ0FBOzs7Ozs7Ozs7Ozs7O0FDQUE7Ozs7Ozs7Ozs7Ozs7QUNBQTs7Ozs7Ozs7Ozs7OztBQ0FBOzs7Ozs7Ozs7Ozs7O0FDQUE7Ozs7Ozs7Ozs7Ozs7QUNBQTs7Ozs7Ozs7Ozs7OztBQ0FBOzs7Ozs7Ozs7Ozs7O0FDQUE7Ozs7Ozs7Ozs7Ozs7QUNBQTs7Ozs7Ozs7Ozs7OztBQ0FBOzs7Ozs7Ozs7Ozs7O0FDQUE7Ozs7Ozs7Ozs7Ozs7QUNBQTs7Ozs7Ozs7Ozs7OztBQ0FBOzs7Ozs7Ozs7Ozs7O0FDQUE7Ozs7Ozs7Ozs7Ozs7QUNBQTs7Ozs7Ozs7Ozs7OztBQ0FBOzs7Ozs7Ozs7Ozs7O0FDQUE7Ozs7Ozs7Ozs7Ozs7QUNBQTs7Ozs7Ozs7Ozs7OztBQ0FBOzs7Ozs7Ozs7Ozs7O0FDQUE7Ozs7Ozs7Ozs7Ozs7QUNBQTs7Ozs7Ozs7Ozs7OztBQ0FBOzs7Ozs7Ozs7Ozs7O0FDQUE7Ozs7Ozs7Ozs7Ozs7QUNBQTs7Ozs7Ozs7Ozs7OztBQ0FBOzs7Ozs7Ozs7Ozs7O0FDQUE7Ozs7Ozs7Ozs7Ozs7QUNBQTs7Ozs7Ozs7Ozs7OztBQ0FBOzs7Ozs7Ozs7Ozs7O0FDQUE7Ozs7Ozs7Ozs7Ozs7QUNBQTs7Ozs7Ozs7Ozs7OztBQ0FBOzs7Ozs7Ozs7Ozs7O0FDQUE7Ozs7Ozs7Ozs7Ozs7QUNBQTs7Ozs7Ozs7Ozs7OztBQ0FBOzs7Ozs7Ozs7Ozs7O0FDQUE7Ozs7Ozs7Ozs7Ozs7QUNBQTs7Ozs7Ozs7Ozs7OztBQ0FBOzs7Ozs7Ozs7Ozs7O0FDQUE7Ozs7Ozs7Ozs7Ozs7QUNBQTs7Ozs7Ozs7Ozs7OztBQ0FBOzs7Ozs7Ozs7Ozs7O0FDQUE7Ozs7Ozs7Ozs7Ozs7QUNBQTs7Ozs7Ozs7Ozs7OztBQ0FBOzs7Ozs7Ozs7Ozs7O0FDQUE7Ozs7Ozs7Ozs7Ozs7QUNBQTs7Ozs7Ozs7Ozs7OztBQ0FBOzs7Ozs7Ozs7Ozs7O0FDQUE7Ozs7Ozs7Ozs7Ozs7QUNBQTs7Ozs7Ozs7Ozs7OztBQ0FBOzs7Ozs7Ozs7Ozs7O0FDQUE7Ozs7Ozs7Ozs7Ozs7QUNBQTs7Ozs7Ozs7Ozs7OztBQ0FBOzs7Ozs7Ozs7Ozs7O0FDQUE7Ozs7Ozs7Ozs7Ozs7QUNBQTs7Ozs7Ozs7Ozs7Ozs7OztBQ0FBLGlFQUFlLDJDQUEyQzs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDQStCO0FBQ3pGLFlBQTJYOztBQUUzWDs7QUFFQTtBQUNBOztBQUVBLGFBQWEsMEdBQUcsQ0FBQyx3V0FBTzs7OztBQUl4QixpRUFBZSwrV0FBYyxNQUFNOzs7Ozs7Ozs7Ozs7Ozs7Ozs7QUNaeUQ7QUFDNUYsWUFBMlk7O0FBRTNZOztBQUVBO0FBQ0E7O0FBRUEsYUFBYSwwR0FBRyxDQUFDLDRXQUFPOzs7O0FBSXhCLGlFQUFlLG1YQUFjLE1BQU07Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ1p5RDtBQUM1RixZQUF5WTs7QUFFelk7O0FBRUE7QUFDQTs7QUFFQSxhQUFhLDBHQUFHLENBQUMsMFdBQU87Ozs7QUFJeEIsaUVBQWUsaVhBQWMsTUFBTTs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDWjREO0FBQy9GLFlBQSthOztBQUUvYTs7QUFFQTtBQUNBOztBQUVBLGFBQWEsMEdBQUcsQ0FBQyxvWUFBTzs7OztBQUl4QixpRUFBZSwyWUFBYyxNQUFNOzs7Ozs7Ozs7Ozs7Ozs7Ozs7QUNaNEQ7QUFDL0YsWUFBNmE7O0FBRTdhOztBQUVBO0FBQ0E7O0FBRUEsYUFBYSwwR0FBRyxDQUFDLGtZQUFPOzs7O0FBSXhCLGlFQUFlLHlZQUFjLE1BQU07Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ1o0RDtBQUMvRixZQUFrYjs7QUFFbGI7O0FBRUE7QUFDQTs7QUFFQSxhQUFhLDBHQUFHLENBQUMsdVlBQU87Ozs7QUFJeEIsaUVBQWUsOFlBQWMsTUFBTTs7Ozs7Ozs7Ozs7QUNadEI7O0FBRWI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdEQUF3RDs7QUFFeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxDQUFDOztBQUVEOztBQUVBO0FBQ0E7O0FBRUEsa0JBQWtCLHdCQUF3QjtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLGtCQUFrQixpQkFBaUI7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGdCQUFnQixLQUF3QyxHQUFHLHNCQUFpQixHQUFHLENBQUk7O0FBRW5GO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBLHFFQUFxRSxxQkFBcUIsY0FBYzs7QUFFeEc7O0FBRUE7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBLHlEQUF5RDtBQUN6RCxJQUFJOztBQUVKOzs7QUFHQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsMkJBQTJCO0FBQzNCOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsb0JBQW9CLDRCQUE0QjtBQUNoRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxxQkFBcUIsNkJBQTZCO0FBQ2xEOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7Ozs7Ozs7OztBQzVRQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUksSUFBeUQ7QUFDN0Q7QUFDQSxNQUFNLEVBSzZCO0FBQ25DLENBQUM7QUFDRCx5QkFBeUI7QUFDekI7O0FBRUE7QUFDQSwwQ0FBMEMsOEJBQW1COztBQUU3RCxpQkFBaUIsOEJBQW1COzs7QUFHcEMsT0FBTzs7QUFFUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsZUFBZSxRQUFRO0FBQ3ZCLGlCQUFpQixRQUFRO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0EsZUFBZSxlQUFlO0FBQzlCLGVBQWUsZUFBZTtBQUM5QixpQkFBaUIsUUFBUTtBQUN6QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7O0FBR0EsT0FBTzs7QUFFUDtBQUNBLDBDQUEwQywrQkFBbUI7O0FBRTdEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLCtCQUFtQjtBQUM5QixVQUFVLCtCQUFtQjtBQUM3QixVQUFVLCtCQUFtQjs7QUFFN0I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsUUFBUTtBQUNuQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0Esd0NBQXdDO0FBQ3hDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxVQUFVO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFVBQVU7QUFDckI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsZUFBZTtBQUMxQixhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxlQUFlO0FBQzFCLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FB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QUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1gsVUFBVTtBQUNWO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQSw2Q0FBNkM7O0FBRTdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQztBQUMxQztBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsTUFBTTs7QUFFTixHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsTUFBTTs7QUFFTixHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNI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QVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNELENBQUM7Ozs7QUFJRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCOztBQUU1QjtBQUNBO0FBQ0E7QUFDQSxRQUFROzs7QUFHUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBLENBQUM7OztBQUdELENBQUM7OztBQUdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUM7QUFDckM7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQzs7QUFFckM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNELENBQUM7QUFDRDtBQUNBLENBQUM7QUFDRDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxDQUFDO0FBQ0Q7QUFDQTs7OztBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLElBQUksS0FBSyxFQUFFLFlBQVk7QUFDdkI7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRCxDQUFDO0FBQ0Q7QUFDQSxDQUFDO0FBQ0Q7QUFDQTs7OztBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLElBQUksS0FBSyxFQUFFLDZCQUE2QjtBQUN4QztBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU0sMERBQTBEO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsY0FBYztBQUNkLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0EsQ0FBQzs7QUFFRCxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkIsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2Isa0JBQWtCO0FBQ2xCLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQixxQ0FBcUM7QUFDL0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQixtQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0EsQ0FBQzs7QUFFRCxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DOztBQUVwQyxxQ0FBcUM7O0FBRXJDO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QixLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdB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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3Qzs7QUFFeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0EsQ0FBQzs7O0FBR0QsQ0FBQztBQUNEO0FBQ0E7Ozs7OztBQU1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYLFFBQVE7QUFDUjtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsdUNBQXVDLE9BQU87QUFDOUM7QUFDQTtBQUNBOztBQUVBOztBQUVBLHFDQUFxQyxPQUFPO0FBQzVDO0FBQ0E7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQSwyQ0FBMkMsT0FBTztBQUNsRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRCxDQUFDO0FBQ0Q7QUFDQSxDQUFDO0FBQ0Q7QUFDQTs7OztBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLElBQUksS0FBSyxFQUFFLG9CQUFvQjtBQUMvQjtBQUNBO0FBQ0EsQ0FBQzs7O0FBR0Qsc0ZBQXNGLFFBQVEsbUVBQW1FLHFKQUFxSixnQkFBZ0IsV0FBVyx5QkFBeUIsU0FBUyx3QkFBd0IsNEJBQTRCLGNBQWMsU0FBUywrQkFBK0Isc0JBQXNCLFdBQVcsWUFBWSxnS0FBZ0ssa0RBQWtELFNBQVMsa0JBQWtCLDRCQUE0QixvQkFBb0Isc0JBQXNCLDhCQUE4QixjQUFjLHVCQUF1QixlQUFlLFlBQVksb0JBQW9CLE1BQU0saUVBQWlFLFVBQVU7O0FBRWhnQywrRUFBK0UsZ0JBQWdCLDZGQUE2Rix3REFBd0QsNkRBQTZELHNEQUFzRDs7QUFFdlcsb0VBQW9FLHVEQUF1RCx1Q0FBdUMsU0FBUyxPQUFPLG9CQUFvQjs7QUFFdE07Ozs7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDRCQUE0Qiw4QkFBOEI7QUFDMUQ7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsU0FBUztBQUNULFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNELENBQUM7QUFDRDtBQUNBLENBQUM7QUFDRDtBQUNBOzs7O0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsSUFBSSxLQUFLLEVBQUUsbUJBQW1CO0FBQzlCO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1Qzs7QUFFdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0QsQ0FBQztBQUNEO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7Ozs7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxJQUFJLEtBQUssRUFBRSxzQkFBc0I7QUFDakM7QUFDQTtBQUNBLENBQUM7Ozs7QUFJRCw2REFBNkQsUUFBUSxtRUFBbUUsNEhBQTRILGdCQUFnQixXQUFXLHlCQUF5QixTQUFTLHdCQUF3Qiw0QkFBNEIsY0FBYyxTQUFTLCtCQUErQixzQkFBc0IsV0FBVyxZQUFZLGdLQUFnSyxrREFBa0QsU0FBUyxrQkFBa0IsNEJBQTRCLG9CQUFvQixzQkFBc0IsOEJBQThCLGNBQWMsdUJBQXVCLGVBQWUsWUFBWSxvQkFBb0IsTUFBTSxpRUFBaUUsVUFBVTs7QUFFOThCLHNEQUFzRCxnQkFBZ0Isb0VBQW9FLHdEQUF3RCw2REFBNkQsc0RBQXNEOztBQUVyVCwyQ0FBMkMsdURBQXVELHVDQUF1QyxTQUFTLE9BQU8sb0JBQW9COztBQUU3SztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTs7QUFFTixHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDhCQUE4Qiw4QkFBOEI7QUFDNUQ7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBLENBQUM7OztBQUdELENBQUM7QUFDRCw2REFBNkQsUUFBUSxtRUFBbUUsNEhBQTRILGdCQUFnQixXQUFXLHlCQUF5QixTQUFTLHdCQUF3Qiw0QkFBNEIsY0FBYyxTQUFTLCtCQUErQixzQkFBc0IsV0FBVyxZQUFZLGdLQUFnSyxrREFBa0QsU0FBUyxrQkFBa0IsNEJBQTRCLG9CQUFvQixzQkFBc0IsOEJBQThCLGNBQWMsdUJBQXVCLGVBQWUsWUFBWSxvQkFBb0IsTUFBTSxpRUFBaUUsVUFBVTs7QUFFOThCLHNEQUFzRCxnQkFBZ0Isb0VBQW9FLHdEQUF3RCw2REFBNkQsc0RBQXNEOztBQUVyVCwyQ0FBMkMsdURBQXVELHVDQUF1QyxTQUFTLE9BQU8sb0JBQW9COztBQUU3Szs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7O0FBRUE7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDhCQUE4Qiw4QkFBOEI7QUFDNUQ7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRCxDQUFDO0FBQ0QsMkNBQTJDLCtCQUErQiwrUUFBK1EsK1FBQStRLHVRQUF1USxzeEJBQXN4QiwyUUFBMlEsODdDQUE4N0MsNHpDQUE0ekMsMjVCQUEyNUIsMFBBQTBQLDBSQUEwUixvK0JBQW8rQiw4NENBQTg0Qyx5UEFBeVAsa1FBQWtRLDYrQkFBNitCO0FBQ241VCxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLENBQUM7Ozs7QUFJRDs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEM7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsMkRBQTJEO0FBQzNEO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QztBQUM3QztBQUNBO0FBQ0E7O0FBRUEscUVBQXFFO0FBQ3JFO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQSxDQUFDOzs7QUFHRCxDQUFDOzs7QUFHRDs7OztBQUlBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7O0FBR0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07O0FBRU4sR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQSxDQUFDOzs7QUFHRCxDQUFDOzs7QUFHRDs7OztBQUlBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7O0FBR0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3Qjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLE1BQU07O0FBRU4sR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBLENBQUM7OztBQUdELENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsQ0FBQzs7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O0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTs7QUFFWixVQUFVO0FBQ1Y7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNELENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLHVCQUF1Qjs7QUFFckQ7QUFDQTs7QUFFQTtBQUNBLG1DQUFtQztBQUNuQzs7QUFFQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFD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QTs7QUFFQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0QsQ0FBQztBQUNEO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7Ozs7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxJQUFJLEtBQUssRUFBRSxxQkFBcUI7QUFDaEM7QUFDQTtBQUNBLENBQUM7QUFDRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3Qzs7QUFFeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EscURBQXFEO0FBQ3JEO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNELENBQUM7Ozs7O0FBS0Q7O0FBRUEsK0JBQStCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxpREFBaUQ7QUFDakQ7O0FBRUEsNkRBQTZEOztBQUU3RDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7QUFDQSw2RkFBNkYsYUFBYTtBQUMxRztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBLDZFQUE2RSxlQUFlO0FBQzVGO0FBQ0E7O0FBRUE7QUFDQTtB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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWixLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0EsQ0FBQzs7QUFFRCxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNELENBQUM7QUFDRDtBQUNBO0FBQ0EsK0NBQStDLCtCQUFtQjtBQUNsRSxDQUFDOztBQUVELENBQUM7Ozs7QUFJRDs7O0FBR0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxJQUFJLEtBQUssRUFBRSxxQkFBcUI7QUFDaEM7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsbUNBQW1DO0FBQ25DOztBQUVBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRCxDQUFDO0FBQ0Q7QUFDQTtBQUNBLGtEQUFrRCwrQkFBbUI7QUFDckUsQ0FBQzs7QUFFRCxDQUFDOzs7O0FBSUQ7OztBQUdBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsSUFBSSxLQUFLLEVBQUUsd0JBQXdCO0FBQ25DO0FBQ0E7QUFDQSxDQUFDO0FBQ0QsdUZBQXVGLFFBQVEsbUVBQW1FLHNKQUFzSixnQkFBZ0IsV0FBVyx5QkFBeUIsU0FBUyx3QkFBd0IsNEJBQTRCLGNBQWMsU0FBUywrQkFBK0Isc0JBQXNCLFdBQVcsWUFBWSxnS0FBZ0ssa0RBQWtELFNBQVMsa0JBQWtCLDRCQUE0QixvQkFBb0Isc0JBQXNCLDhCQUE4QixjQUFjLHVCQUF1QixlQUFlLFlBQVksb0JBQW9CLE1BQU0saUVBQWlFLFVBQVU7O0FBRWxnQyxnRkFBZ0YsZ0JBQWdCLDhGQUE4Rix3REFBd0QsNkRBQTZELHNEQUFzRDs7QUFFelcscUVBQXFFLHVEQUF1RCx1Q0FBdUMsU0FBUyxPQUFPLG9CQUFvQjs7QUFFdk07QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsZ0NBQWdDO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLDRCQUE0Qiw4QkFBOEI7QUFDMUQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVc7O0FBRVg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNELENBQUM7QUFDRDtBQUNBO0FBQ0EsOENBQThDLCtCQUFtQjtBQUNqRSxDQUFDOztBQUVELENBQUM7Ozs7QUFJRDs7O0FBR0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxJQUFJLEtBQUssRUFBRSxvQkFBb0I7QUFDL0I7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQSxDQUFDOztBQUVELENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNELENBQUM7QUFDRDtBQUNBO0FBQ0EsOENBQThDLCtCQUFtQjtBQUNqRSxDQUFDOztBQUVELENBQUM7Ozs7QUFJRDs7O0FBR0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxJQUFJLEtBQUssRUFBRSxvQkFBb0I7QUFDL0I7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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TDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUEsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0M7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLDZCQUE2QjtBQUM3QixLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLDRCQUE0Qiw4QkFBOEI7QUFDMUQ7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsOENBQThDOztBQUU5QztBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLG1DQUFtQztBQUNuQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FB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O0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSxnQkFBZ0IsSUFBSSxLQUFLLE1BQU0sSUFBSSxPQUFPLElBQUksT0FBTzs7O0FBRzdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBLEVBQUU7O0FBRUY7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsMEJBQTBCO0FBQzNELEVBQUU7O0FBRUY7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Es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VUFBVTtBQUNWO0FBQ0EsVUFBVTs7QUFFVixRQUFRO0FBQ1I7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLE1BQU07O0FBRU4sR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBLENBQUM7OztBQUdELENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7OztBQUdEOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0Esd0JBQXdCOztBQUV4QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTs7O0FBR1I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLEdB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QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxTQUFTO0FBQ3BCLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixZQUFZLFFBQVE7QUFDcEI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixZQUFZLFFBQVE7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsWUFBWSxRQUFRO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxRQUFRLElBQUk7QUFDdkIsV0FBVyxRQUFRLElBQUk7QUFDdkIsV0FBVyxPQUFPO0FBQ2xCLFlBQVksUUFBUTtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsT0FBTztBQUNsQixZQUFZLFFBQVE7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsV0FBVyxPQUFPO0FBQ2xCLFlBQVksUUFBUTtBQUNwQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsV0FBVyxPQUFPO0FBQ2xCLFlBQVksUUFBUTtBQUNwQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSwwQkFBMEI7O0FBRTFCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBLFVBQVU7QUFDVixXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLGFBQWEsaUJBQWlCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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OztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQSxVQUFVO0FBQ1Y7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Q0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsbUJBQW1CO0FBQ2hDLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxhQUFhO0FBQzVCLGVBQWUsYUFBYTtBQUM1QixlQUFlO0FBQ2Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0EsZUFBZSxhQUFhO0FBQzVCLGVBQWUsYUFBYTtBQUM1QixlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsYUFBYTtBQUM1QixlQUFlLGFBQWE7QUFDNUIsZUFBZSxhQUFhO0FBQzVCLGVBQWUsYUFBYTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRzs7QUFFSDtBQUNBO0FBQ0EsZUFBZSxhQUFhO0FBQzVCLGVBQWUsYUFBYTtBQUM1QixlQUFlLGFBQWE7QUFDNUIsZUFBZSxhQUFhO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0EsbURBQW1ELFNBQVM7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FB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QTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0EsV0FBVztBQUNYOztBQUVBO0FBQ0E7QUFDQSx3Q0FBd0MsV0FBVztBQUNuRDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsNEJBQTRCO0FBQzVCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxVQUFVO0FBQ1Y7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHFDQUFxQyxjQUFjO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGlDQUFpQyxtQkFBbUI7QUFDcEQ7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGtCQUFrQjs7QUFFbEI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLGdCQUFnQjtBQUN6QztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGFBQWE7QUFDYjtBQUNBOztBQUVBO0FBQ0EsYUFBYTtBQUNiOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsK0NBQStDLFFBQVE7QUFDdkQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBOztBQUVBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7O0FBRUEsWUFBWTtBQUNaO0FBQ0E7QUFDQTs7QUFFQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0EsK0NBQStDLFFBQVE7QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQSwrQ0FBK0MsUUFBUTtBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQSwrQ0FBK0MsUUFBUTtBQUN2RDtBQUNBO0FBQ0E7QUFD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QVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNELENBQUM7QUFDRDtBQUNBLENBQUM7QUFDRDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxDQUFDO0FBQ0Q7QUFDQTs7OztBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLElBQUksS0FBSyxFQUFFLFlBQVk7QUFDdkI7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRCxDQUFDO0FBQ0Q7QUFDQSxDQUFDO0FBQ0Q7QUFDQTs7OztBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLElBQUksS0FBSyxFQUFFLGdCQUFnQjtBQUMzQjtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNELENBQUM7QUFDRDtBQUNBLENBQUM7QUFDRDtBQUNBOzs7O0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsSUFBSSxLQUFLLEVBQUUsaUJBQWlCO0FBQzVCO0FBQ0E7QUFDQSxDQUFDO0FBQ0QseURBQXlELGlGQUFpRixXQUFXLHdIQUF3SCxnQkFBZ0IsV0FBVyx5QkFBeUIsU0FBUyx3QkFBd0IsNEJBQTRCLGNBQWMsU0FBUywrQkFBK0Isc0JBQXNCLFdBQVcsWUFBWSxnS0FBZ0ssa0RBQWtELFNBQVMsa0JBQWtCLGtCQUFrQixvQkFBb0Isc0JBQXNCLDhCQUE4QixjQUFjLHVCQUF1QixlQUFlLFlBQVksb0JBQW9CLE1BQU0saUVBQWlFLFVBQVU7O0FBRTc4QixrREFBa0QsZ0JBQWdCLGdFQUFnRSx3REFBd0QsNkRBQTZELHNEQUFzRDs7QUFFN1MsdUNBQXVDLHVEQUF1RCx1Q0FBdUMsU0FBUyxPQUFPLG9CQUFvQjs7O0FBR3pLO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUM7O0FBRXZDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsNEJBQTRCLDhCQUE4QjtBQUMxRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7O0FBRUEsb0JBQW9COztBQUVwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSw2QkFBNkIsZ0NBQWdDO0FBQzdEOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQSxRQUFRO0FBQ1I7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0QsQ0FBQztBQUNEO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7Ozs7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxJQUFJLEtBQUssRUFBRSxtQkFBbUI7QUFDOUI7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNELENBQUM7QUFDRDtBQUNBLENBQUM7QUFDRDtBQUNBOzs7O0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsSUFBSSxLQUFLLEVBQUUsZUFBZTtBQUMxQjtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRCxDQUFDO0FBQ0Q7QUFDQSxDQUFDO0FBQ0Q7QUFDQTs7OztBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLElBQUksS0FBSyxFQUFFLGdCQUFnQjtBQUMzQjtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0QsQ0FBQztBQUNEO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7Ozs7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7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QXVCO0FBQ2xDO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNELENBQUM7QUFDRDtBQUNBLENBQUM7QUFDRDtBQUNBOzs7O0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsSUFBSSxLQUFLLEVBQUUsZ0JBQWdCO0FBQzNCO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0QsQ0FBQztBQUNEO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7Ozs7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxJQUFJLEtBQUssRUFBRSxnQkFBZ0I7QUFDM0I7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFD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O0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSw0QkFBNEIsOEJBQThCO0FBQzFEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxRQUFRO0FBQ1I7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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TDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRCxDQUFDO0FBQ0Q7QUFDQSxDQUFDO0FBQ0Q7QUFDQTs7OztBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLElBQUksS0FBSyxFQUFFLGlCQUFpQjtBQUM1QjtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0QsQ0FBQztBQUNEO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7Ozs7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxJQUFJLEtBQUssRUFBRSxnQkFBZ0I7QUFDM0I7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRCxDQUFDO0FBQ0Q7QUFDQSxDQUFDO0FBQ0Q7QUFDQTs7OztBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLElBQUksS0FB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QUFPO0FBQ1A7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNELENBQUM7QUFDRDtBQUNBLENBQUM7QUFDRDtBQUNBOzs7O0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsSUFBSSxLQUFLLEVBQUUsc0JBQXNCO0FBQ2pDO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0QsQ0FBQztBQUNEO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7Ozs7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxJQUFJLEtBQUssRUFBRSxnQkFBZ0I7QUFDM0I7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0QsQ0FBQztBQUNEO0FBQ0Es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QUFFQTtBQUNBLElBQUksS0FBSyxFQUFFLHVCQUF1QjtBQUNsQztBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNELENBQUM7QUFDRDtBQUNBLENBQUM7QUFDRDtBQUNBOzs7O0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsSUFBSSxLQUFLLEVBQUUsaUJBQWlCO0FBQzVCO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRCxDQUFDO0FBQ0Q7QUFDQSxDQUFDO0FBQ0Q7QUFDQTs7OztBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLElBQUksS0FBSyxFQUFFLHNCQUFzQjtBQUNqQztBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7O0FBRUEseUNBQXlDLFNBQVM7QUFDbEQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDO0FBQ2hDO0FBQ0EsMENBQTBDO0FBQzFDO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU0sS0FBcUM7QUFDM0M7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLHFCQUFxQjtBQUNyRDtBQUNBLG1DQUFtQyxPQUFPO0FBQzFDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDJCQUEyQixTQUFTOztBQUVwQztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxDQUFDOztBQUVEOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixpQkFBaUI7QUFDbkM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLE9BQU87QUFDM0M7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMsT0FBTztBQUMxQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLEtBQXFDO0FBQy9DO0FBQ0E7QUFDQTtBQUNBLCtCQUErQjtBQUMvQjtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTSxLQUFxQztBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJLEtBQXFDO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTSxLQUFxQztBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUksS0FBcUM7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0RBQWtELE9BQU87QUFDekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUksSUFBcUM7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7O0FBRUE7QUFDQTtBQUNBOztBQUVBLGtCQUFrQixpQkFBaUI7QUFDbkM7QUFDQTtBQUNBLDRCQUE0QjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNLEtBQXFDO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGtCQUFrQixrQkFBa0I7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUksS0FBcUM7QUFDekM7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DO0FBQ25DLGtDQUFrQztBQUNsQztBQUNBLG1CQUFtQjtBQUNuQixNQUFNLElBQXFDO0FBQzNDO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsYUFBb0I7QUFDdEM7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QixRQUFRLFNBQVMsSUFBcUM7QUFDdEQ7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQSxJQUFJLFNBQVMsSUFBcUM7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQSxvQkFBb0IsbUJBQW1CO0FBQ3ZDLGdDQUFnQztBQUNoQztBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsV0FBVztBQUM5QixZQUFZO0FBQ1o7QUFDQSxJQUFJLFNBQVMsSUFBcUM7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNLElBQXFDO0FBQzNDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0MsT0FBTztBQUN0RDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCO0FBQzVCO0FBQ0EscUNBQXFDO0FBQ3JDO0FBQ0Esc0NBQXNDO0FBQ3RDO0FBQ0E7QUFDQSxNQUFNLEtBQXFDO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7O0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUksSUFFUTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNLEtBQXFDO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNLEtBQXFDO0FBQzNDO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSw4Q0FBOEM7QUFDOUM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSxJQUFxQztBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixxQkFBcUI7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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Q0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsS0FBcUM7QUFDL0M7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSxLQUFxQztBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEtBQUssNENBQTRDLCtCQUErQjs7QUFFaEY7QUFDQSx5Q0FBeUMsT0FBTztBQUNoRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBLE1BQU0sS0FBcUM7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixLQUFxQztBQUNyRDtBQUNBLG9CQUFvQixDQUFJO0FBQ3hCO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxvQkFBb0IscUJBQXFCO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0M7QUFDL0M7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDLE9BQU87QUFDL0M7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDLFNBQVM7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFFBQVEsSUFBcUM7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0MsT0FBTztBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLElBQXFDO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNLEtBQXFDO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU0sSUFBcUM7QUFDM0M7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDJCQUEyQjs7QUFFM0IsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IscUJBQXFCO0FBQ3pDO0FBQ0EsMkNBQTJDO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsTUFBTSxJQUFxQztBQUMzQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLHlCQUF5QjtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQix5QkFBeUI7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUMsT0FBTztBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU0sSUFBcUM7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IscUJBQXFCOztBQUVwRDtBQUNBO0FBQ0Esa0JBQWtCLHNCQUFzQjtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSxLQUFxQztBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esa0JBQWtCLGtCQUFrQjtBQUNwQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsVUFBVSxLQUFxQztBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7OztBQUlBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsS0FBcUM7QUFDekQ7QUFDQSxNQUFNLENBQUU7QUFDUjtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0EsTUFBTSxLQUFxQztBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEIsc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQSxJQUFJO0FBQ0oseUJBQXlCO0FBQ3pCO0FBQ0EsdUJBQXVCO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsSUFBcUM7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLE1BQU0sS0FBSyxFQUVOO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSSxLQUFxQztBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLElBQXFDO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNLEtBQXFDO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBLCtCQUErQjs7QUFFL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLEtBQXFDO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNLFNBQVMsSUFBcUM7QUFDcEQ7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNLEtBQXFDO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLElBQXFDO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0Isb0JBQW9CO0FBQzFDO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEI7QUFDOUI7QUFDQSwrQkFBK0I7QUFDL0IsTUFBTSxJQUFxQztBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsUUFBUSxLQUFxQztBQUM3QztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLElBQXFDO0FBQzdDO0FBQ0EsTUFBTSxLQUFLLEVBRU47QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQSxxQkFBcUI7QUFDckI7O0FBRUE7QUFDQSxRQUFRLEtBQXFDO0FBQzdDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsTUFBTSxLQUFxQztBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzRUFBc0U7QUFDdEU7QUFDQTtBQUNBOztBQUVBO0FBQ0EsUUFBUSxLQUFxQztBQUM3QztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUM7O0FBRWpDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsWUFBWSxLQUFxQztBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBOzs7Ozs7QUFNQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsMkNBQTJDLDRCQUE0QjtBQUN2RSxLQUFLO0FBQ0w7QUFDQSwyQ0FBMkMsNkJBQTZCO0FBQ3hFLEtBQUs7QUFDTCxHQUFHOztBQUVIO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0M7QUFDaEMsTUFBTSxJQUFxQztBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0MsT0FBTztBQUMzQztBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxnQ0FBZ0M7O0FBRWhDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTSxLQUFxQztBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxxQkFBcUI7O0FBRXJCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNB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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDLE9BQU87QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLE9BQU87QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSx3REFBd0QsbUJBQW1CO0FBQzNFO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7Ozs7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCLHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLE1BQU0sSUFBcUM7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0EsSUFBSSxTQUFTLElBQXFDO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpRkFBaUY7QUFDakYsNEJBQTRCO0FBQzVCO0FBQ0EsMkJBQTJCO0FBQzNCLHdCQUF3QixpRUFBaUU7QUFDekYsWUFBWSwwRkFBMEY7QUFDdEcsTUFBTSxLQUFLLDBDQUEwQztBQUNyRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QyxrQkFBa0I7QUFDL0Qsc0JBQXNCLCtDQUErQztBQUNyRSxpREFBaUQ7O0FBRWpEO0FBQ0Esc0RBQXNEO0FBQ3REO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQU0sSUFBcUM7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsOENBQThDO0FBQzlDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQztBQUMzQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QjtBQUM1QixtQ0FBbUM7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7O0FBRUE7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsK0NBQStDO0FBQ3ZEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLG1DQUFtQztBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0Esd0NBQXdDLFNBQVM7QUFDakQ7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLHdCQUF3QjtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxxREFBcUQsNkJBQTZCO0FBQ2xGLE1BQU07QUFDTjtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EscURBQXFELGdDQUFnQztBQUNyRixNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0NBQStDOztBQUUvQztBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsTUFBTSxLQUFxQztBQUMzQztBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxNQUFNLEtBQXFDO0FBQzNDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxN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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxtQ0FBbUM7O0FBRW5DLHNDQUFzQzs7QUFFdEM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxRQUFRLEtBQXFDO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLFFBQVEsS0FBcUM7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSw4Q0FBOEM7QUFDOUM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0RBQXdEO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDO0FBQ3pDO0FBQ0E7QUFDQSxpRUFBaUUsdUJBQXVCO0FBQ3hG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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxPQUFPO0FBQ1AsT0FBTztBQUNQLFNBQVM7QUFDVCxRQUFRO0FBQ1IsUUFBUTtBQUNSLE9BQU87QUFDUCxRQUFRO0FBQ1I7QUFDQSwyQ0FBMkM7QUFDM0MsOERBQThEOztBQUU5RDtBQUNBO0FBQ0Esc0RBQXNEOztBQUV0RDtBQUNBO0FBQ0EsOENBQThDLDRCQUE0QjtBQUMxRTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUI7QUFD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QUNBLFlBQVksSUFBcUM7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMERBQTBEO0FBQzFEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNLFNBQVMsSUFBcUM7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBLFFBQVE7QUFDUjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsS0FBcUM7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IsT0FBTztBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSxLQUFxQztBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0M7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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QUNBLE1BQU0scUJBQXFCO1dBQzNCO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7O1dBRUE7V0FDQTtXQUNBOzs7OztXQ3pHQTs7Ozs7VUVBQTtVQUNBO1VBQ0E7VUFDQTtVQUNBO1VBQ0E7VUFDQTtVQUNBO1VBQ0E7VUFDQTtVQUNBO1VBQ0E7VUFDQTtVQUNBO1VBQ0E7VUFDQTtVQUNBO1VBQ0E7VUFDQTtVQUNBO1VBQ0E7VUFDQTtVQUNBO1VBQ0E7VUFDQTtVQUNBO1VBQ0E7VUFDQTtVQUNBO1VBQ0E7VUFDQTtVQUNBO1VBQ0E7VUFDQTtVQUNBO1VBQ0E7VUFDQTtVQUNBO1VBQ0E7VUFDQTtVQUNBO1VBQ0E7VUFDQTtVQUNBO1VBQ0E7VUFDQTtVQUNBO1VBQ0E7VUFDQTtVQUNBO1VBQ0E7VUFDQTtVQUNBO1VBQ0E7VUFDQTtVQUNBO1VBQ0E7VUFDQTtVQUNBO1VBQ0E7VUFDQTtVQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2FycmF5c2xpY2VyL2xpYi9jb21wYXJlL2luZGV4LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9hcnJheXNsaWNlci9saWIvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2FycmF5c2xpY2VyL2xpYi9zZWFyY2gvYmluYXJ5LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9hcnJheXNsaWNlci9saWIvdXRpbC5qcyIsIndlYnBhY2s6Ly8vLi9idWlsZC9jaGFydC1saW5rL2NoYXJ0LWxpbmstZGV2LmpzIiwid2VicGFjazovLy8uL2J1aWxkL2dyaWQtcmVzaXplL2dyaWQtcmVzaXplLWRldi5qcyIsIndlYnBhY2s6Ly8vLi9idWlsZC9sZWdlbmQtYnV0dG9ucy9sZWdlbmQtYnV0dG9ucy1kZXYuanMiLCJ3ZWJwYWNrOi8vLy4vYnVpbGQvc2V0dGluZ3Mtd2luL3NldHRpbmdzLXdpbi1kZXYuanMiLCJ3ZWJwYWNrOi8vL3NyYy9NYWluLnZ1ZSIsIndlYnBhY2s6Ly8vc3JjL2NvbXBvbmVudHMvU3RkSW5wdXQudnVlIiwid2VicGFjazovLy9zcmMvY29tcG9uZW50cy9XaW5kb3cudnVlIiwid2VicGFjazovLy9zcmMvZXh0ZW5zaW9ucy9ncmlkLXJlc2l6ZS9TcGxpdHRlci52dWUiLCJ3ZWJwYWNrOi8vL3NyYy9leHRlbnNpb25zL2xlZ2VuZC1idXR0b25zL0FkZFdpbi52dWUiLCJ3ZWJwYWNrOi8vL3NyYy9leHRlbnNpb25zL3NldHRpbmdzLXdpbi9TZXR0aW5nc1dpbi52dWUiLCJ3ZWJwYWNrOi8vLy4vc3JjL2NvbXBvbmVudHMvZHJhZ2cuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2V4dGVuc2lvbnMvY2hhcnQtbGluay9tYWluLmpzIiwid2VicGFjazovLy8uL3NyYy9leHRlbnNpb25zL2NoYXJ0LWxpbmsvc2hhcmVkLmpzIiwid2VicGFjazovLy8uL3NyYy9leHRlbnNpb25zL2NoYXJ0LWxpbmsvdXRpbHMuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2V4dGVuc2lvbnMvZ3JpZC1yZXNpemUvbWFpbi5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvZXh0ZW5zaW9ucy9ncmlkLXJlc2l6ZS91dGlscy5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvZXh0ZW5zaW9ucy9sZWdlbmQtYnV0dG9ucy9tYWluLmpzIiwid2VicGFjazovLy8uL3NyYy9leHRlbnNpb25zL3NldHRpbmdzLXdpbi9tYWluLmpzIiwid2VicGFjazovLy8uL3NyYy9leHRlbnNpb25zL3NldHRpbmdzLXdpbi91dGlscy5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvaW5kZXhfZGV2LmpzIiwid2VicGFjazovLy8uL3NyYy9tYWluLmpzIiwid2VicGFjazovLy8uL3NyYy9zdHJlYW0uanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL3N0dWZmL2NvbnN0YW50cy5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvc3R1ZmYvdXRpbHMuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL01haW4udnVlPzdiYTIiLCJ3ZWJwYWNrOi8vLy4vc3JjL2NvbXBvbmVudHMvU3RkSW5wdXQudnVlPzA0YWEiLCJ3ZWJwYWNrOi8vLy4vc3JjL2NvbXBvbmVudHMvV2luZG93LnZ1ZT85OTlhIiwid2VicGFjazovLy8uL3NyYy9leHRlbnNpb25zL2dyaWQtcmVzaXplL1NwbGl0dGVyLnZ1ZT8xZmZiIiwid2VicGFjazovLy8uL3NyYy9leHRlbnNpb25zL2xlZ2VuZC1idXR0b25zL0FkZFdpbi52dWU/YzA4MCIsIndlYnBhY2s6Ly8vLi9zcmMvZXh0ZW5zaW9ucy9zZXR0aW5ncy13aW4vU2V0dGluZ3NXaW4udnVlPzEyMzYiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2xhcmF2ZWwtbWl4L25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2Rpc3QvcnVudGltZS9hcGkuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2xhcmF2ZWwtbWl4L25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2Rpc3QvcnVudGltZS9jc3NXaXRoTWFwcGluZ1RvU3RyaW5nLmpzIiwid2VicGFjazovLy8uL3Jlc291cmNlcy9zY3NzL2Jhc2UvcGx1Z2lucy9leHRlbnNpb25zL2V4dC1jb21wb25lbnQtcmF0aW5ncy5zY3NzP2MzNjMiLCJ3ZWJwYWNrOi8vLy4vcmVzb3VyY2VzL3Njc3MvYmFzZS9wbHVnaW5zL2V4dGVuc2lvbnMvZXh0LWNvbXBvbmVudC1zbGlkZXJzLnNjc3M/MDlkNCIsIndlYnBhY2s6Ly8vLi9yZXNvdXJjZXMvc2Nzcy9iYXNlL3BsdWdpbnMvZXh0ZW5zaW9ucy9leHQtY29tcG9uZW50LXN3ZWV0LWFsZXJ0cy5zY3NzP2Q1MWEiLCJ3ZWJwYWNrOi8vLy4vcmVzb3VyY2VzL3Njc3MvYmFzZS9wbHVnaW5zL2V4dGVuc2lvbnMvZXh0LWNvbXBvbmVudC1zd2lwZXIuc2Nzcz84YzczIiwid2VicGFjazovLy8uL3Jlc291cmNlcy9zY3NzL2Jhc2UvcGx1Z2lucy9leHRlbnNpb25zL2V4dC1jb21wb25lbnQtdG9hc3RyLnNjc3M/OTE0NyIsIndlYnBhY2s6Ly8vLi9yZXNvdXJjZXMvc2Nzcy9iYXNlL3BsdWdpbnMvZXh0ZW5zaW9ucy9leHQtY29tcG9uZW50LXRvdXIuc2Nzcz8wY2I1Iiwid2VicGFjazovLy8uL3Jlc291cmNlcy9zY3NzL2Jhc2UvcGx1Z2lucy9leHRlbnNpb25zL2V4dC1jb21wb25lbnQtdHJlZS5zY3NzPzVkMjYiLCJ3ZWJwYWNrOi8vLy4vcmVzb3VyY2VzL3Njc3MvYmFzZS9wbHVnaW5zL2Zvcm1zL2Zvcm0tZmlsZS11cGxvYWRlci5zY3NzPzM5MTYiLCJ3ZWJwYWNrOi8vLy4vcmVzb3VyY2VzL3Njc3MvYmFzZS9wbHVnaW5zL2Zvcm1zL2Zvcm0tbnVtYmVyLWlucHV0LnNjc3M/ZmY4YSIsIndlYnBhY2s6Ly8vLi9yZXNvdXJjZXMvc2Nzcy9iYXNlL3BsdWdpbnMvZm9ybXMvZm9ybS1xdWlsbC1lZGl0b3Iuc2Nzcz9mNjlkIiwid2VicGFjazovLy8uL3Jlc291cmNlcy9zY3NzL2Jhc2UvcGx1Z2lucy9mb3Jtcy9mb3JtLXZhbGlkYXRpb24uc2Nzcz9iNTRhIiwid2VicGFjazovLy8uL3Jlc291cmNlcy9zY3NzL2Jhc2UvcGx1Z2lucy9mb3Jtcy9mb3JtLXdpemFyZC5zY3NzP2QzNWYiLCJ3ZWJwYWNrOi8vLy4vcmVzb3VyY2VzL3Njc3MvYmFzZS9wbHVnaW5zL2Zvcm1zL3BpY2tlcnMvZm9ybS1mbGF0LXBpY2tyLnNjc3M/YmI4MCIsIndlYnBhY2s6Ly8vLi9yZXNvdXJjZXMvc2Nzcy9iYXNlL3BsdWdpbnMvZm9ybXMvcGlja2Vycy9mb3JtLXBpY2thZGF0ZS5zY3NzPzBhNWEiLCJ3ZWJwYWNrOi8vLy4vcmVzb3VyY2VzL3Njc3MvYmFzZS9wbHVnaW5zL21hcHMvbWFwLWxlYWZsZXQuc2Nzcz9jZDllIiwid2VicGFjazovLy8uL3Jlc291cmNlcy9zY3NzL2Jhc2UvcGx1Z2lucy91aS9jb21pbmctc29vbi5zY3NzP2JjZjYiLCJ3ZWJwYWNrOi8vLy4vcmVzb3VyY2VzL3Njc3MvYmFzZS9wYWdlcy9hcHAtY2FsZW5kYXIuc2Nzcz9kMmI0Iiwid2VicGFjazovLy8uL3Jlc291cmNlcy9zY3NzL2Jhc2UvcGFnZXMvYXBwLWNoYXQtbGlzdC5zY3NzPzM1ZjAiLCJ3ZWJwYWNrOi8vLy4vcmVzb3VyY2VzL3Njc3MvYmFzZS9wYWdlcy9hcHAtY2hhdC5zY3NzP2QxZDQiLCJ3ZWJwYWNrOi8vLy4vcmVzb3VyY2VzL3Njc3MvYmFzZS9wYWdlcy9hcHAtZWNvbW1lcmNlLWRldGFpbHMuc2Nzcz9lNDNkIiwid2VicGFjazovLy8uL3Jlc291cmNlcy9zY3NzL2Jhc2UvcGFnZXMvYXBwLWVjb21tZXJjZS5zY3NzPzZhMTUiLCJ3ZWJwYWNrOi8vLy4vcmVzb3VyY2VzL3Njc3MvYmFzZS9wYWdlcy9hcHAtZW1haWwuc2Nzcz8xY2FmIiwid2VicGFjazovLy8uL3Jlc291cmNlcy9zY3NzL2Jhc2UvcGFnZXMvYXBwLWZpbGUtbWFuYWdlci5zY3NzPzVjNzgiLCJ3ZWJwYWNrOi8vLy4vcmVzb3VyY2VzL3Njc3MvYmFzZS9wYWdlcy9hcHAtaW52b2ljZS1saXN0LnNjc3M/MGQ2MSIsIndlYnBhY2s6Ly8vLi9yZXNvdXJjZXMvc2Nzcy9iYXNlL3BhZ2VzL2FwcC1pbnZvaWNlLXByaW50LnNjc3M/YTUwOCIsIndlYnBhY2s6Ly8vLi9yZXNvdXJjZXMvc2Nzcy9iYXNlL3BhZ2VzL2FwcC1pbnZvaWNlLnNjc3M/ODg0MyIsIndlYnBhY2s6Ly8vLi9yZXNvdXJjZXMvc2Nzcy9iYXNlL3BhZ2VzL2FwcC1rYW5iYW4uc2Nzcz83YTA4Iiwid2VicGFjazovLy8uL3Jlc291cmNlcy9zY3NzL2Jhc2UvcGFnZXMvYXBwLXRvZG8uc2Nzcz80ZmVhIiwid2VicGFjazovLy8uL3Jlc291cmNlcy9zY3NzL2Jhc2UvcGFnZXMvYXV0aGVudGljYXRpb24uc2Nzcz82ZjEwIiwid2VicGFjazovLy8uL3Jlc291cmNlcy9zY3NzL2Jhc2UvcGFnZXMvZGFzaGJvYXJkLWVjb21tZXJjZS5zY3NzP2RmYTkiLCJ3ZWJwYWNrOi8vLy4vcmVzb3VyY2VzL3Njc3MvYmFzZS9wYWdlcy9tb2RhbC1jcmVhdGUtYXBwLnNjc3M/OTkxNiIsIndlYnBhY2s6Ly8vLi9yZXNvdXJjZXMvc2Nzcy9iYXNlL3BhZ2VzL3BhZ2UtYmxvZy5zY3NzPzY3NTAiLCJ3ZWJwYWNrOi8vLy4vcmVzb3VyY2VzL3Njc3MvYmFzZS9wYWdlcy9wYWdlLWNvbWluZy1zb29uLnNjc3M/MzdiZiIsIndlYnBhY2s6Ly8vLi9yZXNvdXJjZXMvc2Nzcy9iYXNlL3BhZ2VzL3BhZ2UtZmFxLnNjc3M/YmZhOSIsIndlYnBhY2s6Ly8vLi9yZXNvdXJjZXMvc2Nzcy9iYXNlL3BhZ2VzL3BhZ2Uta25vd2xlZGdlLWJhc2Uuc2Nzcz83YzMwIiwid2VicGFjazovLy8uL3Jlc291cmNlcy9zY3NzL2Jhc2UvcGFnZXMvcGFnZS1taXNjLnNjc3M/ZDFkNCIsIndlYnBhY2s6Ly8vLi9yZXNvdXJjZXMvc2Nzcy9iYXNlL3BhZ2VzL3BhZ2UtcHJpY2luZy5zY3NzP2FkM2EiLCJ3ZWJwYWNrOi8vLy4vcmVzb3VyY2VzL3Njc3MvYmFzZS9wYWdlcy9wYWdlLXByb2ZpbGUuc2Nzcz82MDk4Iiwid2VicGFjazovLy8uL3Jlc291cmNlcy9zY3NzL2Jhc2UvcGFnZXMvdWktZmVhdGhlci5zY3NzPzRiZDEiLCJ3ZWJwYWNrOi8vLy4vcmVzb3VyY2VzL3Njc3MvYmFzZS9jb3JlL2NvbG9ycy9wYWxldHRlLWdyYWRpZW50LnNjc3M/NzIzYyIsIndlYnBhY2s6Ly8vLi9yZXNvdXJjZXMvc2Nzcy9iYXNlL2NvcmUvY29sb3JzL3BhbGV0dGUtbm91aS5zY3NzPzY3M2QiLCJ3ZWJwYWNrOi8vLy4vcmVzb3VyY2VzL3Njc3MvYmFzZS9jb3JlL2NvbG9ycy9wYWxldHRlLXZhcmlhYmxlcy5zY3NzPzkyYzAiLCJ3ZWJwYWNrOi8vLy4vcmVzb3VyY2VzL3Njc3MvYmFzZS9jb3JlL21lbnUvbWVudS10eXBlcy9ob3Jpem9udGFsLW1lbnUuc2Nzcz83ZmJjIiwid2VicGFjazovLy8uL3Jlc291cmNlcy9zY3NzL2Jhc2UvY29yZS9tZW51L21lbnUtdHlwZXMvdmVydGljYWwtbWVudS5zY3NzPzIzMjEiLCJ3ZWJwYWNrOi8vLy4vcmVzb3VyY2VzL3Njc3MvYmFzZS9jb3JlL21lbnUvbWVudS10eXBlcy92ZXJ0aWNhbC1vdmVybGF5LW1lbnUuc2Nzcz81ZjlmIiwid2VicGFjazovLy8uL3Jlc291cmNlcy9zY3NzL2Jhc2UvY29yZS9taXhpbnMvYWxlcnQuc2Nzcz9kYTA4Iiwid2VicGFjazovLy8uL3Jlc291cmNlcy9zY3NzL2Jhc2UvY29yZS9taXhpbnMvaGV4MnJnYi5zY3NzPzAyNzEiLCJ3ZWJwYWNrOi8vLy4vcmVzb3VyY2VzL3Njc3MvYmFzZS9jb3JlL21peGlucy9tYWluLW1lbnUtbWl4aW4uc2Nzcz8zODQ0Iiwid2VicGFjazovLy8uL3Jlc291cmNlcy9zY3NzL2Jhc2UvY29yZS9taXhpbnMvdHJhbnNpdGlvbnMuc2NzcyIsIndlYnBhY2s6Ly8vLi9yZXNvdXJjZXMvc2Nzcy9iYXNlL3RoZW1lcy9kYXJrLWxheW91dC5zY3NzP2E4YzQiLCJ3ZWJwYWNrOi8vLy4vcmVzb3VyY2VzL3Njc3MvY29yZS5zY3NzPzZiMGMiLCJ3ZWJwYWNrOi8vLy4vcmVzb3VyY2VzL3Njc3Mvb3ZlcnJpZGVzLnNjc3M/NGI1ZSIsIndlYnBhY2s6Ly8vLi9yZXNvdXJjZXMvYXNzZXRzL3Njc3Mvc3R5bGUuc2NzcyIsIndlYnBhY2s6Ly8vLi9yZXNvdXJjZXMvc2Nzcy9iYXNlL3BsdWdpbnMvY2hhcnRzL2NoYXJ0LWFwZXguc2Nzcz8zN2U0Iiwid2VicGFjazovLy8uL3Jlc291cmNlcy9zY3NzL2Jhc2UvcGx1Z2lucy9leHRlbnNpb25zL2V4dC1jb21wb25lbnQtY29udGV4dC1tZW51LnNjc3M/OGQ2OSIsIndlYnBhY2s6Ly8vLi9yZXNvdXJjZXMvc2Nzcy9iYXNlL3BsdWdpbnMvZXh0ZW5zaW9ucy9leHQtY29tcG9uZW50LWRyYWctZHJvcC5zY3NzP2EwMjQiLCJ3ZWJwYWNrOi8vLy4vcmVzb3VyY2VzL3Njc3MvYmFzZS9wbHVnaW5zL2V4dGVuc2lvbnMvZXh0LWNvbXBvbmVudC1tZWRpYS1wbGF5ZXIuc2Nzcz9jNTljIiwid2VicGFjazovLy8uL3Jlc291cmNlcy9hc3NldHMvY29ycy50eHQiLCJ3ZWJwYWNrOi8vLy4vc3JjL01haW4udnVlP2Q5NzkiLCJ3ZWJwYWNrOi8vLy4vc3JjL2NvbXBvbmVudHMvU3RkSW5wdXQudnVlP2ViZjYiLCJ3ZWJwYWNrOi8vLy4vc3JjL2NvbXBvbmVudHMvV2luZG93LnZ1ZT9hZDZiIiwid2VicGFjazovLy8uL3NyYy9leHRlbnNpb25zL2dyaWQtcmVzaXplL1NwbGl0dGVyLnZ1ZT85YThjIiwid2VicGFjazovLy8uL3NyYy9leHRlbnNpb25zL2xlZ2VuZC1idXR0b25zL0FkZFdpbi52dWU/OWI1ZiIsIndlYnBhY2s6Ly8vLi9zcmMvZXh0ZW5zaW9ucy9zZXR0aW5ncy13aW4vU2V0dGluZ3NXaW4udnVlPzc3NGUiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3N0eWxlLWxvYWRlci9kaXN0L3J1bnRpbWUvaW5qZWN0U3R5bGVzSW50b1N0eWxlVGFnLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy90cmFkaW5nLXZ1ZS1qcy9kaXN0L3RyYWRpbmctdnVlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy90dmpzLW92ZXJsYXlzL2Rpc3QvdHZqcy1vdmVybGF5cy5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvTWFpbi52dWUiLCJ3ZWJwYWNrOi8vLy4vc3JjL2NvbXBvbmVudHMvU3RkSW5wdXQudnVlIiwid2VicGFjazovLy8uL3NyYy9jb21wb25lbnRzL1dpbmRvdy52dWUiLCJ3ZWJwYWNrOi8vLy4vc3JjL2V4dGVuc2lvbnMvZ3JpZC1yZXNpemUvU3BsaXR0ZXIudnVlIiwid2VicGFjazovLy8uL3NyYy9leHRlbnNpb25zL2xlZ2VuZC1idXR0b25zL0FkZFdpbi52dWUiLCJ3ZWJwYWNrOi8vLy4vc3JjL2V4dGVuc2lvbnMvc2V0dGluZ3Mtd2luL1NldHRpbmdzV2luLnZ1ZSIsIndlYnBhY2s6Ly8vLi9zcmMvTWFpbi52dWU/ODA4ZCIsIndlYnBhY2s6Ly8vLi9zcmMvY29tcG9uZW50cy9TdGRJbnB1dC52dWU/NGZiYiIsIndlYnBhY2s6Ly8vLi9zcmMvY29tcG9uZW50cy9XaW5kb3cudnVlPzgzMjciLCJ3ZWJwYWNrOi8vLy4vc3JjL2V4dGVuc2lvbnMvZ3JpZC1yZXNpemUvU3BsaXR0ZXIudnVlP2RjNmQiLCJ3ZWJwYWNrOi8vLy4vc3JjL2V4dGVuc2lvbnMvbGVnZW5kLWJ1dHRvbnMvQWRkV2luLnZ1ZT8wOTFiIiwid2VicGFjazovLy8uL3NyYy9leHRlbnNpb25zL3NldHRpbmdzLXdpbi9TZXR0aW5nc1dpbi52dWU/MmEwOCIsIndlYnBhY2s6Ly8vLi9zcmMvTWFpbi52dWU/MjliMiIsIndlYnBhY2s6Ly8vLi9zcmMvY29tcG9uZW50cy9TdGRJbnB1dC52dWU/ZTRjNSIsIndlYnBhY2s6Ly8vLi9zcmMvY29tcG9uZW50cy9XaW5kb3cudnVlPzQ3NjUiLCJ3ZWJwYWNrOi8vLy4vc3JjL2V4dGVuc2lvbnMvZ3JpZC1yZXNpemUvU3BsaXR0ZXIudnVlPzEzZDQiLCJ3ZWJwYWNrOi8vLy4vc3JjL2V4dGVuc2lvbnMvbGVnZW5kLWJ1dHRvbnMvQWRkV2luLnZ1ZT80ZGVmIiwid2VicGFjazovLy8uL3NyYy9leHRlbnNpb25zL3NldHRpbmdzLXdpbi9TZXR0aW5nc1dpbi52dWU/NTc4NCIsIndlYnBhY2s6Ly8vLi9zcmMvTWFpbi52dWU/NzEzNCIsIndlYnBhY2s6Ly8vLi9zcmMvY29tcG9uZW50cy9TdGRJbnB1dC52dWU/YjJkMSIsIndlYnBhY2s6Ly8vLi9zcmMvY29tcG9uZW50cy9XaW5kb3cudnVlPzM2YzYiLCJ3ZWJwYWNrOi8vLy4vc3JjL2V4dGVuc2lvbnMvZ3JpZC1yZXNpemUvU3BsaXR0ZXIudnVlP2VjN2YiLCJ3ZWJwYWNrOi8vLy4vc3JjL2V4dGVuc2lvbnMvbGVnZW5kLWJ1dHRvbnMvQWRkV2luLnZ1ZT9hMzYyIiwid2VicGFjazovLy8uL3NyYy9leHRlbnNpb25zL3NldHRpbmdzLXdpbi9TZXR0aW5nc1dpbi52dWU/NTQxOCIsIndlYnBhY2s6Ly8vLi9zcmMvTWFpbi52dWU/NzIzNCIsIndlYnBhY2s6Ly8vLi9zcmMvY29tcG9uZW50cy9TdGRJbnB1dC52dWU/ZGZlYSIsIndlYnBhY2s6Ly8vLi9zcmMvY29tcG9uZW50cy9XaW5kb3cudnVlPzRiYzAiLCJ3ZWJwYWNrOi8vLy4vc3JjL2V4dGVuc2lvbnMvZ3JpZC1yZXNpemUvU3BsaXR0ZXIudnVlPzFkNDkiLCJ3ZWJwYWNrOi8vLy4vc3JjL2V4dGVuc2lvbnMvbGVnZW5kLWJ1dHRvbnMvQWRkV2luLnZ1ZT84YThlIiwid2VicGFjazovLy8uL3NyYy9leHRlbnNpb25zL3NldHRpbmdzLXdpbi9TZXR0aW5nc1dpbi52dWU/ODUzMCIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvcnVudGltZS9jb21wb25lbnROb3JtYWxpemVyLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy92dWUvZGlzdC92dWUuZXNtLmpzIiwid2VicGFjazovLy93ZWJwYWNrL2Jvb3RzdHJhcCIsIndlYnBhY2s6Ly8vd2VicGFjay9ydW50aW1lL2NodW5rIGxvYWRlZCIsIndlYnBhY2s6Ly8vd2VicGFjay9ydW50aW1lL2NvbXBhdCBnZXQgZGVmYXVsdCBleHBvcnQiLCJ3ZWJwYWNrOi8vL3dlYnBhY2svcnVudGltZS9kZWZpbmUgcHJvcGVydHkgZ2V0dGVycyIsIndlYnBhY2s6Ly8vd2VicGFjay9ydW50aW1lL2dsb2JhbCIsIndlYnBhY2s6Ly8vd2VicGFjay9ydW50aW1lL2hhc093blByb3BlcnR5IHNob3J0aGFuZCIsIndlYnBhY2s6Ly8vd2VicGFjay9ydW50aW1lL21ha2UgbmFtZXNwYWNlIG9iamVjdCIsIndlYnBhY2s6Ly8vd2VicGFjay9ydW50aW1lL2pzb25wIGNodW5rIGxvYWRpbmciLCJ3ZWJwYWNrOi8vL3dlYnBhY2svcnVudGltZS9ub25jZSIsIndlYnBhY2s6Ly8vd2VicGFjay9iZWZvcmUtc3RhcnR1cCIsIndlYnBhY2s6Ly8vd2VicGFjay9zdGFydHVwIiwid2VicGFjazovLy93ZWJwYWNrL2FmdGVyLXN0YXJ0dXAiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBVdGlsaXR5IGNvbXBhcmUgZnVuY3Rpb25zXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSB7XG5cbiAgICAvKipcbiAgICAgKiBDb21wYXJlIHR3byBudW1iZXJzLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGFcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gYlxuICAgICAqIEByZXR1cm5zIHtOdW1iZXJ9IDEgaWYgYSA+IGIsIDAgaWYgYSA9IGIsIC0xIGlmIGEgPCBiXG4gICAgICovXG4gICAgbnVtY21wOiBmdW5jdGlvbiAoYSwgYikge1xuICAgICAgICByZXR1cm4gYSAtIGI7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENvbXBhcmUgdHdvIHN0cmluZ3MuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge051bWJlcnxTdHJpbmd9IGFcbiAgICAgKiBAcGFyYW0ge051bWJlcnxTdHJpbmd9IGJcbiAgICAgKiBAcmV0dXJucyB7TnVtYmVyfSAxIGlmIGEgPiBiLCAwIGlmIGEgPSBiLCAtMSBpZiBhIDwgYlxuICAgICAqL1xuICAgIHN0cmNtcDogZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgICAgcmV0dXJuIGEgPCBiID8gLTEgOiBhID4gYiA/IDEgOiAwO1xuICAgIH1cblxufTtcbiIsIi8qKlxuICogSW5kZXhlZCBBcnJheSBCaW5hcnkgU2VhcmNoIG1vZHVsZVxuICovXG5cbi8qKlxuICogRGVwZW5kZW5jaWVzXG4gKi9cbnZhciB1dGlsID0gcmVxdWlyZShcIi4vdXRpbFwiKSxcbiAgICBjbXAgPSByZXF1aXJlKFwiLi9jb21wYXJlXCIpLFxuICAgIGJpbiA9IHJlcXVpcmUoXCIuL3NlYXJjaC9iaW5hcnlcIik7XG5cbi8qKlxuICogTW9kdWxlIGludGVyZmFjZSBkZWZpbml0aW9uXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gSW5kZXhlZEFycmF5O1xuXG4vKipcbiAqIEluZGV4ZWQgQXJyYXkgY29uc3RydWN0b3JcbiAqXG4gKiBJdCBsb2FkcyB0aGUgYXJyYXkgZGF0YSwgZGVmaW5lcyB0aGUgaW5kZXggZmllbGQgYW5kIHRoZSBjb21wYXJpc29uIGZ1bmN0aW9uXG4gKiB0byBiZSB1c2VkLlxuICpcbiAqIEBwYXJhbSB7QXJyYXl9IGRhdGEgaXMgYW4gYXJyYXkgb2Ygb2JqZWN0c1xuICogQHBhcmFtIHtTdHJpbmd9IGluZGV4IGlzIHRoZSBvYmplY3QncyBwcm9wZXJ0eSB1c2VkIHRvIHNlYXJjaCB0aGUgYXJyYXlcbiAqL1xuZnVuY3Rpb24gSW5kZXhlZEFycmF5KGRhdGEsIGluZGV4KSB7XG5cbiAgICAvLyBpcyBkYXRhIHNvcnRhYmxlIGFycmF5IG9yIGFycmF5LWxpa2Ugb2JqZWN0P1xuICAgIGlmICghdXRpbC5pc1NvcnRhYmxlQXJyYXlMaWtlKGRhdGEpKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIGRhdGFcIik7XG5cbiAgICAvLyBpcyBpbmRleCBhIHZhbGlkIHByb3BlcnR5P1xuICAgIGlmICghaW5kZXggfHwgZGF0YS5sZW5ndGggPiAwICYmICEoaW5kZXggaW4gZGF0YVswXSkpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgaW5kZXhcIik7XG5cbiAgICAvLyBkYXRhIGFycmF5XG4gICAgdGhpcy5kYXRhID0gZGF0YTtcblxuICAgIC8vIG5hbWUgb2YgdGhlIGluZGV4IHByb3BlcnR5XG4gICAgdGhpcy5pbmRleCA9IGluZGV4O1xuXG4gICAgLy8gc2V0IGluZGV4IGJvdW5kYXJ5IHZhbHVlc1xuICAgIHRoaXMuc2V0Qm91bmRhcmllcygpO1xuXG4gICAgLy8gZGVmYXVsdCBjb21wYXJpc29uIGZ1bmN0aW9uXG4gICAgdGhpcy5jb21wYXJlID0gdHlwZW9mIHRoaXMubWludiA9PT0gXCJudW1iZXJcIiA/IGNtcC5udW1jbXAgOiBjbXAuc3RyY21wO1xuXG4gICAgLy8gZGVmYXVsdCBzZWFyY2ggZnVuY3Rpb25cbiAgICB0aGlzLnNlYXJjaCA9IGJpbi5zZWFyY2g7XG5cbiAgICAvLyBjYWNoZSBvZiBpbmRleCB2YWx1ZXMgdG8gYXJyYXkgcG9zaXRpb25zXG4gICAgLy8gZWFjaCB2YWx1ZSBzdG9yZXMgYW4gb2JqZWN0IGFzIHsgZm91bmQ6IHRydWV8ZmFsc2UsIGluZGV4OiBhcnJheS1pbmRleCB9XG4gICAgdGhpcy52YWxwb3MgPSB7fTtcblxuICAgIC8vIGN1cnNvciBhbmQgYWRqYWNlbnQgcG9zaXRpb25zXG4gICAgdGhpcy5jdXJzb3IgPSBudWxsO1xuICAgIHRoaXMubmV4dGxvdyA9IG51bGw7XG4gICAgdGhpcy5uZXh0aGlnaCA9IG51bGw7XG59XG5cbi8qKlxuICogU2V0IHRoZSBjb21wYXJpc29uIGZ1bmN0aW9uXG4gKlxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gdG8gY29tcGFyZSBpbmRleCB2YWx1ZXMgdGhhdCByZXR1cm5lcyAxLCAwLCAtMVxuICovXG5JbmRleGVkQXJyYXkucHJvdG90eXBlLnNldENvbXBhcmUgPSBmdW5jdGlvbiAoZm4pIHtcbiAgICBpZiAodHlwZW9mIGZuICE9PSBcImZ1bmN0aW9uXCIpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgYXJndW1lbnRcIik7XG5cbiAgICB0aGlzLmNvbXBhcmUgPSBmbjtcbiAgICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogU2V0IHRoZSBzZWFyY2ggZnVuY3Rpb25cbiAqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiB0byBzZWFyY2ggaW5kZXggdmFsdWVzIGluIHRoZSBhcnJheSBvZiBvYmplY3RzXG4gKi9cbkluZGV4ZWRBcnJheS5wcm90b3R5cGUuc2V0U2VhcmNoID0gZnVuY3Rpb24gKGZuKSB7XG4gICAgaWYgKHR5cGVvZiBmbiAhPT0gXCJmdW5jdGlvblwiKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIGFyZ3VtZW50XCIpO1xuXG4gICAgdGhpcy5zZWFyY2ggPSBmbjtcbiAgICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogU29ydCB0aGUgZGF0YSBhcnJheSBieSBpdHMgaW5kZXggcHJvcGVydHlcbiAqL1xuSW5kZXhlZEFycmF5LnByb3RvdHlwZS5zb3J0ID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBzZWxmID0gdGhpcyxcbiAgICAgICAgaW5kZXggPSB0aGlzLmluZGV4O1xuXG4gICAgLy8gc29ydCB0aGUgYXJyYXlcbiAgICB0aGlzLmRhdGEuc29ydChmdW5jdGlvbiAoYSwgYikge1xuICAgICAgICByZXR1cm4gc2VsZi5jb21wYXJlKGFbaW5kZXhdLCBiW2luZGV4XSk7XG4gICAgfSk7XG5cbiAgICAvLyByZWNhbGN1bGF0ZSBib3VuZGFyeSB2YWx1ZXNcbiAgICB0aGlzLnNldEJvdW5kYXJpZXMoKTtcblxuICAgIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBJbnNwZWN0IGFuZCBzZXQgdGhlIGJvdW5kYXJpZXMgb2YgdGhlIGludGVybmFsIGRhdGEgYXJyYXlcbiAqL1xuSW5kZXhlZEFycmF5LnByb3RvdHlwZS5zZXRCb3VuZGFyaWVzID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBkYXRhID0gdGhpcy5kYXRhLFxuICAgICAgICBpbmRleCA9IHRoaXMuaW5kZXg7XG5cbiAgICB0aGlzLm1pbnYgPSBkYXRhLmxlbmd0aCAmJiBkYXRhWzBdW2luZGV4XTtcbiAgICB0aGlzLm1heHYgPSBkYXRhLmxlbmd0aCAmJiBkYXRhW2RhdGEubGVuZ3RoIC0gMV1baW5kZXhdO1xuXG4gICAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIEdldCB0aGUgcG9zaXRpb24gb2YgdGhlIG9iamVjdCBjb3JyZXNwb25kaW5nIHRvIHRoZSBnaXZlbiBpbmRleFxuICpcbiAqIEBwYXJhbSB7TnVtYmVyfFN0cmluZ30gaW5kZXggaXMgdGhlIGlkIG9mIHRoZSByZXF1ZXN0ZWQgb2JqZWN0XG4gKiBAcmV0dXJucyB7TnVtYmVyfSB0aGUgcG9zaXRpb24gb2YgdGhlIG9iamVjdCBpbiB0aGUgYXJyYXlcbiAqL1xuSW5kZXhlZEFycmF5LnByb3RvdHlwZS5mZXRjaCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgIC8vIGNoZWNrIGRhdGEgaGFzIG9iamVjdHNcbiAgICBpZiAodGhpcy5kYXRhLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICB0aGlzLmN1cnNvciA9IG51bGw7XG4gICAgICAgIHRoaXMubmV4dGxvdyA9IG51bGw7XG4gICAgICAgIHRoaXMubmV4dGhpZ2ggPSBudWxsO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvLyBjaGVjayB0aGUgcmVxdWVzdCBpcyB3aXRoaW4gcmFuZ2VcbiAgICBpZiAodGhpcy5jb21wYXJlKHZhbHVlLCB0aGlzLm1pbnYpID09PSAtMSkge1xuICAgICAgICB0aGlzLmN1cnNvciA9IG51bGw7XG4gICAgICAgIHRoaXMubmV4dGxvdyA9IG51bGw7XG4gICAgICAgIHRoaXMubmV4dGhpZ2ggPSAwO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgaWYgKHRoaXMuY29tcGFyZSh2YWx1ZSwgdGhpcy5tYXh2KSA9PT0gMSkge1xuICAgICAgICB0aGlzLmN1cnNvciA9IG51bGw7XG4gICAgICAgIHRoaXMubmV4dGxvdyA9IHRoaXMuZGF0YS5sZW5ndGggLSAxO1xuICAgICAgICB0aGlzLm5leHRoaWdoID0gbnVsbDtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgdmFyIHZhbHBvcyA9IHRoaXMudmFscG9zLFxuICAgICAgICBwb3MgPSB2YWxwb3NbdmFsdWVdO1xuXG4gICAgLy8gaWYgdGhlIHJlcXVlc3QgaXMgbWVtb3JpemVkLCBqdXN0IGdpdmUgaXQgYmFja1xuICAgIGlmIChwb3MpIHtcbiAgICAgICAgaWYgKHBvcy5mb3VuZCkge1xuICAgICAgICAgICAgdGhpcy5jdXJzb3IgPSBwb3MuaW5kZXg7XG4gICAgICAgICAgICB0aGlzLm5leHRsb3cgPSBudWxsO1xuICAgICAgICAgICAgdGhpcy5uZXh0aGlnaCA9IG51bGw7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmN1cnNvciA9IG51bGw7XG4gICAgICAgICAgICB0aGlzLm5leHRsb3cgPSBwb3MucHJldjtcbiAgICAgICAgICAgIHRoaXMubmV4dGhpZ2ggPSBwb3MubmV4dDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvLyBpZiBub3QsIGRvIHRoZSBzZWFyY2hcbiAgICB2YXIgcmVzdWx0ID0gdGhpcy5zZWFyY2guY2FsbCh0aGlzLCB2YWx1ZSk7XG4gICAgdGhpcy5jdXJzb3IgPSByZXN1bHQuaW5kZXg7XG4gICAgdGhpcy5uZXh0bG93ID0gcmVzdWx0LnByZXY7XG4gICAgdGhpcy5uZXh0aGlnaCA9IHJlc3VsdC5uZXh0O1xuICAgIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBHZXQgdGhlIG9iamVjdCBjb3JyZXNwb25kaW5nIHRvIHRoZSBnaXZlbiBpbmRleFxuICpcbiAqIFdoZW4gbm8gdmFsdWUgaXMgZ2l2ZW4sIHRoZSBmdW5jdGlvbiB3aWxsIGRlZmF1bHQgdG8gdGhlIGxhc3QgZmV0Y2hlZCBpdGVtLlxuICpcbiAqIEBwYXJhbSB7TnVtYmVyfFN0cmluZ30gW29wdGlvbmFsXSBpbmRleCBpcyB0aGUgaWQgb2YgdGhlIHJlcXVlc3RlZCBvYmplY3RcbiAqIEByZXR1cm5zIHtPYmplY3R9IHRoZSBmb3VuZCBvYmplY3Qgb3IgbnVsbFxuICovXG5JbmRleGVkQXJyYXkucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgIGlmICh2YWx1ZSlcbiAgICAgICAgdGhpcy5mZXRjaCh2YWx1ZSk7XG5cbiAgICB2YXIgcG9zID0gdGhpcy5jdXJzb3I7XG4gICAgcmV0dXJuIHBvcyAhPT0gbnVsbCA/IHRoaXMuZGF0YVtwb3NdIDogbnVsbDtcbn07XG5cbi8qKlxuICogR2V0IGFuIHNsaWNlIG9mIHRoZSBkYXRhIGFycmF5XG4gKlxuICogQm91bmRhcmllcyBoYXZlIHRvIGJlIGluIG9yZGVyLlxuICpcbiAqIEBwYXJhbSB7TnVtYmVyfFN0cmluZ30gYmVnaW4gaW5kZXggaXMgdGhlIGlkIG9mIHRoZSByZXF1ZXN0ZWQgb2JqZWN0XG4gKiBAcGFyYW0ge051bWJlcnxTdHJpbmd9IGVuZCBpbmRleCBpcyB0aGUgaWQgb2YgdGhlIHJlcXVlc3RlZCBvYmplY3RcbiAqIEByZXR1cm5zIHtPYmplY3R9IHRoZSBzbGljZSBvZiBkYXRhIGFycmF5IG9yIFtdXG4gKi9cbkluZGV4ZWRBcnJheS5wcm90b3R5cGUuZ2V0UmFuZ2UgPSBmdW5jdGlvbiAoYmVnaW4sIGVuZCkge1xuICAgIC8vIGNoZWNrIGlmIGJvdW5kYXJpZXMgYXJlIGluIG9yZGVyXG4gICAgaWYgKHRoaXMuY29tcGFyZShiZWdpbiwgZW5kKSA9PT0gMSkge1xuICAgICAgICByZXR1cm4gW107XG4gICAgfVxuXG4gICAgLy8gZmV0Y2ggc3RhcnQgYW5kIGRlZmF1bHQgdG8gdGhlIG5leHQgaW5kZXggYWJvdmVcbiAgICB0aGlzLmZldGNoKGJlZ2luKTtcbiAgICB2YXIgc3RhcnQgPSB0aGlzLmN1cnNvciB8fCB0aGlzLm5leHRoaWdoO1xuXG4gICAgLy8gZmV0Y2ggZmluaXNoIGFuZCBkZWZhdWx0IHRvIHRoZSBuZXh0IGluZGV4IGJlbG93XG4gICAgdGhpcy5mZXRjaChlbmQpO1xuICAgIHZhciBmaW5pc2ggPSB0aGlzLmN1cnNvciB8fCB0aGlzLm5leHRsb3c7XG5cbiAgICAvLyBpZiBhbnkgYm91bmRhcnkgaXMgbm90IHNldCwgcmV0dXJuIG5vIHJhbmdlXG4gICAgaWYgKHN0YXJ0ID09PSBudWxsIHx8IGZpbmlzaCA9PT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gW107XG4gICAgfVxuXG4gICAgLy8gcmV0dXJuIHJhbmdlXG4gICAgcmV0dXJuIHRoaXMuZGF0YS5zbGljZShzdGFydCwgZmluaXNoICsgMSk7XG59O1xuIiwiLyoqXG4gKiBCaW5hcnkgc2VhcmNoIGltcGxlbWVudGF0aW9uXG4gKi9cblxuLyoqXG4gKiBNYWluIHNlYXJjaCByZWN1cnNpdmUgZnVuY3Rpb25cbiAqL1xuZnVuY3Rpb24gbG9vcChkYXRhLCBtaW4sIG1heCwgaW5kZXgsIHZhbHBvcykge1xuXG4gICAgLy8gc2V0IGN1cnJlbnQgcG9zaXRpb24gYXMgdGhlIG1pZGRsZSBwb2ludCBiZXR3ZWVuIG1pbiBhbmQgbWF4XG4gICAgdmFyIGN1cnIgPSAobWF4ICsgbWluKSA+Pj4gMTtcblxuICAgIC8vIGNvbXBhcmUgY3VycmVudCBpbmRleCB2YWx1ZSB3aXRoIHRoZSBvbmUgd2UgYXJlIGxvb2tpbmcgZm9yXG4gICAgdmFyIGRpZmYgPSB0aGlzLmNvbXBhcmUoZGF0YVtjdXJyXVt0aGlzLmluZGV4XSwgaW5kZXgpO1xuXG4gICAgLy8gZm91bmQ/XG4gICAgaWYgKCFkaWZmKSB7XG4gICAgICAgIHJldHVybiB2YWxwb3NbaW5kZXhdID0ge1xuICAgICAgICAgICAgXCJmb3VuZFwiOiB0cnVlLFxuICAgICAgICAgICAgXCJpbmRleFwiOiBjdXJyLFxuICAgICAgICAgICAgXCJwcmV2XCI6IG51bGwsXG4gICAgICAgICAgICBcIm5leHRcIjogbnVsbFxuICAgICAgICB9O1xuICAgIH1cblxuICAgIC8vIG5vIG1vcmUgcG9zaXRpb25zIGF2YWlsYWJsZT9cbiAgICBpZiAobWluID49IG1heCkge1xuICAgICAgICByZXR1cm4gdmFscG9zW2luZGV4XSA9IHtcbiAgICAgICAgICAgIFwiZm91bmRcIjogZmFsc2UsXG4gICAgICAgICAgICBcImluZGV4XCI6IG51bGwsXG4gICAgICAgICAgICBcInByZXZcIjogKGRpZmYgPCAwKSA/IG1heCA6IG1heCAtIDEsXG4gICAgICAgICAgICBcIm5leHRcIjogKGRpZmYgPCAwKSA/IG1heCArIDEgOiBtYXhcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICAvLyBjb250aW51ZSBsb29raW5nIGZvciBpbmRleCBpbiBvbmUgb2YgdGhlIHJlbWFpbmluZyBhcnJheSBoYWx2ZXNcbiAgICAvLyBjdXJyZW50IHBvc2l0aW9uIGNhbiBiZSBza2VwdCBhcyBpbmRleCBpcyBub3QgdGhlcmUuLi5cbiAgICBpZiAoZGlmZiA+IDApXG4gICAgICAgIHJldHVybiBsb29wLmNhbGwodGhpcywgZGF0YSwgbWluLCBjdXJyIC0gMSwgaW5kZXgsIHZhbHBvcyk7XG4gICAgZWxzZVxuICAgICAgICByZXR1cm4gbG9vcC5jYWxsKHRoaXMsIGRhdGEsIGN1cnIgKyAxLCBtYXgsIGluZGV4LCB2YWxwb3MpO1xufVxuXG4vKipcbiAqIFNlYXJjaCBib290c3RyYXBcbiAqIFRoZSBmdW5jdGlvbiBoYXMgdG8gYmUgZXhlY3V0ZWQgaW4gdGhlIGNvbnRleHQgb2YgdGhlIEluZGV4ZWRBcnJheSBvYmplY3RcbiAqL1xuZnVuY3Rpb24gc2VhcmNoKGluZGV4KSB7XG4gICAgdmFyIGRhdGEgPSB0aGlzLmRhdGE7XG4gICAgcmV0dXJuIGxvb3AuY2FsbCh0aGlzLCBkYXRhLCAwLCBkYXRhLmxlbmd0aCAtIDEsIGluZGV4LCB0aGlzLnZhbHBvcyk7XG59XG5cbi8qKlxuICogRXhwb3J0IHNlYXJjaCBmdW5jdGlvblxuICovXG5tb2R1bGUuZXhwb3J0cy5zZWFyY2ggPSBzZWFyY2g7XG4iLCIvKipcbiAqIFV0aWxzIG1vZHVsZVxuICovXG5cbi8qKlxuICogQ2hlY2sgaWYgYW4gb2JqZWN0IGlzIGFuIGFycmF5LWxpa2Ugb2JqZWN0XG4gKlxuICogQGNyZWRpdCBKYXZhc2NyaXB0OiBUaGUgRGVmaW5pdGl2ZSBHdWlkZSwgTydSZWlsbHksIDIwMTFcbiAqL1xuZnVuY3Rpb24gaXNBcnJheUxpa2Uobykge1xuICAgIGlmIChvICYmICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gbyBpcyBub3QgbnVsbCwgdW5kZWZpbmVkLCBldGMuXG4gICAgICAgIHR5cGVvZiBvID09PSBcIm9iamVjdFwiICYmICAgICAgICAgICAgIC8vIG8gaXMgYW4gb2JqZWN0XG4gICAgICAgIGlzRmluaXRlKG8ubGVuZ3RoKSAmJiAgICAgICAgICAgICAgICAvLyBvLmxlbmd0aCBpcyBhIGZpbml0ZSBudW1iZXJcbiAgICAgICAgby5sZW5ndGggPj0gMCAmJiAgICAgICAgICAgICAgICAgICAgIC8vIG8ubGVuZ3RoIGlzIG5vbi1uZWdhdGl2ZVxuICAgICAgICBvLmxlbmd0aCA9PT0gTWF0aC5mbG9vcihvLmxlbmd0aCkgJiYgLy8gby5sZW5ndGggaXMgYW4gaW50ZWdlclxuICAgICAgICBvLmxlbmd0aCA8IDQyOTQ5NjcyOTYpICAgICAgICAgICAgICAgLy8gby5sZW5ndGggPCAyXjMyXG4gICAgICAgIHJldHVybiB0cnVlOyAgICAgICAgICAgICAgICAgICAgICAgICAvLyBUaGVuIG8gaXMgYXJyYXktbGlrZVxuICAgIGVsc2VcbiAgICAgICAgcmV0dXJuIGZhbHNlOyAgICAgICAgICAgICAgICAgICAgICAgIC8vIE90aGVyd2lzZSBpdCBpcyBub3Rcbn1cblxuLyoqXG4gKiBDaGVjayBmb3IgdGhlIGV4aXN0ZW5jZSBvZiB0aGUgc29ydCBmdW5jdGlvbiBpbiB0aGUgb2JqZWN0XG4gKi9cbmZ1bmN0aW9uIGlzU29ydGFibGUobykge1xuICAgIGlmIChvICYmICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gbyBpcyBub3QgbnVsbCwgdW5kZWZpbmVkLCBldGMuXG4gICAgICAgIHR5cGVvZiBvID09PSBcIm9iamVjdFwiICYmICAgICAgICAgICAgIC8vIG8gaXMgYW4gb2JqZWN0XG4gICAgICAgIHR5cGVvZiBvLnNvcnQgPT09IFwiZnVuY3Rpb25cIikgICAgICAgIC8vIG8uc29ydCBpcyBhIGZ1bmN0aW9uXG4gICAgICAgIHJldHVybiB0cnVlOyAgICAgICAgICAgICAgICAgICAgICAgICAvLyBUaGVuIG8gaXMgYXJyYXktbGlrZVxuICAgIGVsc2VcbiAgICAgICAgcmV0dXJuIGZhbHNlOyAgICAgICAgICAgICAgICAgICAgICAgIC8vIE90aGVyd2lzZSBpdCBpcyBub3Rcbn1cblxuLyoqXG4gKiBDaGVjayBmb3Igc29ydGFibGUtYXJyYXktbGlrZSBvYmplY3RzXG4gKi9cbm1vZHVsZS5leHBvcnRzLmlzU29ydGFibGVBcnJheUxpa2UgPSBmdW5jdGlvbiAobykge1xuICAgIHJldHVybiBpc0FycmF5TGlrZShvKSAmJiBpc1NvcnRhYmxlKG8pO1xufTtcbiIsIlxuXG4vLyAtLS0tLS0tLSBEZXZlbG9wbWVudCBleHRlbnNpb24gaW5kZXggLS0tLS0tLS0tXG4vLyAgICAgICEgVEhJUyBGSUxFIFdBUyBBVVRPLUdFTkVSQVRFRCAhXG4vL1xuLy8gWW91IGNhbiBvdmVyd3JpdGUgaXQgYW5kIGhhdmUgZnVuLCB0byByZXN0b3JlXG4vLyB0aGUgZGVmYXVsdCBzdGF0ZTogJ25wbSBydW4gY29tcGlsZSdcblxuaW1wb3J0IE1haW4gZnJvbSAnLi4vLi4vc3JjL2V4dGVuc2lvbnMvY2hhcnQtbGluay9tYWluLmpzJ1xuTWFpbi5fX25hbWVfXyA9ICdjaGFydC1saW5rJ1xuXG5jb25zdCB3aWRnZXRzID0geyAgfVxuY29uc3QgY29tcG9uZW50cyA9IHsgIH1cbmNvbnN0IG92ZXJsYXlzID0geyAgfVxuY29uc3QgY29sb3JwYWNrcyA9IHsgIH1cbmNvbnN0IHNraW5zID0geyAgfVxuXG5jb25zdCBQYWNrID0ge1xuICAgIHdpZGdldHMsXG4gICAgY29tcG9uZW50cyxcbiAgICBvdmVybGF5cyxcbiAgICBjb2xvcnBhY2tzLFxuICAgIHNraW5zLFxuICAgIE1haW5cbn1cblxuZXhwb3J0IGRlZmF1bHQgUGFja1xuXG5leHBvcnQge1xuICAgIHdpZGdldHMsXG4gICAgY29tcG9uZW50cyxcbiAgICBvdmVybGF5cyxcbiAgICBjb2xvcnBhY2tzLFxuICAgIHNraW5zLFxuICAgIE1haW5cbn0iLCJcblxuLy8gLS0tLS0tLS0gRGV2ZWxvcG1lbnQgZXh0ZW5zaW9uIGluZGV4IC0tLS0tLS0tLVxuLy8gICAgICAhIFRISVMgRklMRSBXQVMgQVVUTy1HRU5FUkFURUQgIVxuLy9cbi8vIFlvdSBjYW4gb3ZlcndyaXRlIGl0IGFuZCBoYXZlIGZ1biwgdG8gcmVzdG9yZVxuLy8gdGhlIGRlZmF1bHQgc3RhdGU6ICducG0gcnVuIGNvbXBpbGUnXG5cbmltcG9ydCBNYWluIGZyb20gJy4uLy4uL3NyYy9leHRlbnNpb25zL2dyaWQtcmVzaXplL21haW4uanMnXG5NYWluLl9fbmFtZV9fID0gJ2dyaWQtcmVzaXplJ1xuXG5jb25zdCB3aWRnZXRzID0geyAgfVxuY29uc3QgY29tcG9uZW50cyA9IHsgIH1cbmNvbnN0IG92ZXJsYXlzID0geyAgfVxuY29uc3QgY29sb3JwYWNrcyA9IHsgIH1cbmNvbnN0IHNraW5zID0geyAgfVxuXG5jb25zdCBQYWNrID0ge1xuICAgIHdpZGdldHMsXG4gICAgY29tcG9uZW50cyxcbiAgICBvdmVybGF5cyxcbiAgICBjb2xvcnBhY2tzLFxuICAgIHNraW5zLFxuICAgIE1haW5cbn1cblxuZXhwb3J0IGRlZmF1bHQgUGFja1xuXG5leHBvcnQge1xuICAgIHdpZGdldHMsXG4gICAgY29tcG9uZW50cyxcbiAgICBvdmVybGF5cyxcbiAgICBjb2xvcnBhY2tzLFxuICAgIHNraW5zLFxuICAgIE1haW5cbn0iLCJcblxuLy8gLS0tLS0tLS0gRGV2ZWxvcG1lbnQgZXh0ZW5zaW9uIGluZGV4IC0tLS0tLS0tLVxuLy8gICAgICAhIFRISVMgRklMRSBXQVMgQVVUTy1HRU5FUkFURUQgIVxuLy9cbi8vIFlvdSBjYW4gb3ZlcndyaXRlIGl0IGFuZCBoYXZlIGZ1biwgdG8gcmVzdG9yZVxuLy8gdGhlIGRlZmF1bHQgc3RhdGU6ICducG0gcnVuIGNvbXBpbGUnXG5cbmltcG9ydCBNYWluIGZyb20gJy4uLy4uL3NyYy9leHRlbnNpb25zL2xlZ2VuZC1idXR0b25zL21haW4uanMnXG5NYWluLl9fbmFtZV9fID0gJ2xlZ2VuZC1idXR0b25zJ1xuXG5jb25zdCB3aWRnZXRzID0geyAgfVxuY29uc3QgY29tcG9uZW50cyA9IHsgIH1cbmNvbnN0IG92ZXJsYXlzID0geyAgfVxuY29uc3QgY29sb3JwYWNrcyA9IHsgIH1cbmNvbnN0IHNraW5zID0geyAgfVxuXG5jb25zdCBQYWNrID0ge1xuICAgIHdpZGdldHMsXG4gICAgY29tcG9uZW50cyxcbiAgICBvdmVybGF5cyxcbiAgICBjb2xvcnBhY2tzLFxuICAgIHNraW5zLFxuICAgIE1haW5cbn1cblxuZXhwb3J0IGRlZmF1bHQgUGFja1xuXG5leHBvcnQge1xuICAgIHdpZGdldHMsXG4gICAgY29tcG9uZW50cyxcbiAgICBvdmVybGF5cyxcbiAgICBjb2xvcnBhY2tzLFxuICAgIHNraW5zLFxuICAgIE1haW5cbn0iLCJcblxuLy8gLS0tLS0tLS0gRGV2ZWxvcG1lbnQgZXh0ZW5zaW9uIGluZGV4IC0tLS0tLS0tLVxuLy8gICAgICAhIFRISVMgRklMRSBXQVMgQVVUTy1HRU5FUkFURUQgIVxuLy9cbi8vIFlvdSBjYW4gb3ZlcndyaXRlIGl0IGFuZCBoYXZlIGZ1biwgdG8gcmVzdG9yZVxuLy8gdGhlIGRlZmF1bHQgc3RhdGU6ICducG0gcnVuIGNvbXBpbGUnXG5cbmltcG9ydCBTZXR0aW5nc1dpbiBmcm9tICcuLi8uLi9zcmMvZXh0ZW5zaW9ucy9zZXR0aW5ncy13aW4vU2V0dGluZ3NXaW4udnVlJ1xuaW1wb3J0IE1haW4gZnJvbSAnLi4vLi4vc3JjL2V4dGVuc2lvbnMvc2V0dGluZ3Mtd2luL21haW4uanMnXG5NYWluLl9fbmFtZV9fID0gJ3NldHRpbmdzLXdpbidcblxuY29uc3Qgd2lkZ2V0cyA9IHsgU2V0dGluZ3NXaW4gfVxuY29uc3QgY29tcG9uZW50cyA9IHsgIH1cbmNvbnN0IG92ZXJsYXlzID0geyAgfVxuY29uc3QgY29sb3JwYWNrcyA9IHsgIH1cbmNvbnN0IHNraW5zID0geyAgfVxuXG5jb25zdCBQYWNrID0ge1xuICAgIHdpZGdldHMsXG4gICAgU2V0dGluZ3NXaW4sXG4gICAgY29tcG9uZW50cyxcbiAgICBvdmVybGF5cyxcbiAgICBjb2xvcnBhY2tzLFxuICAgIHNraW5zLFxuICAgIE1haW5cbn1cblxuZXhwb3J0IGRlZmF1bHQgUGFja1xuXG5leHBvcnQge1xuICAgIHdpZGdldHMsXG4gICAgU2V0dGluZ3NXaW4sXG4gICAgY29tcG9uZW50cyxcbiAgICBvdmVybGF5cyxcbiAgICBjb2xvcnBhY2tzLFxuICAgIHNraW5zLFxuICAgIE1haW5cbn0iLCI8dGVtcGxhdGU+XG4gICAgPGRpdiBjbGFzcz1cImZsZXgtc3RhcnQgY29sLTEwIGNvbC14bGwtMTAgY29sLXhsLTEwIGNvbC1sZy0xMCBjb2wtbWQtOSBjb2wtc20tMTJcIj5cbiAgICAgICAgPGRpdiBpZD1cInR2anMtaGVhZGVyXCI+XG4gICAgICAgICAgICA8YT48c3BhbiB2LW9uOmNsaWNrPVwiY2FuZGxlc1wiIGNsYXNzPVwibWUtMSBiYWRnZSBiZy1saWdodC1zZWNvbmRhcnlcIj48aSBjbGFzcz1cImJpIGJpLWJhci1jaGFydFwiIC8+PGRpdiBjbGFzcz1cImQtbWQtaW5saW5lIGQtbm9uZVwiPiAgQ2FuZGxlczwvZGl2Pjwvc3Bhbj48L2E+XG4gICAgICAgICAgICA8YT48c3BhbiB2LW9uOmNsaWNrPVwic3BsaW5lXCIgY2xhc3M9XCJtZS0xIGJhZGdlIGJnLWxpZ2h0LXNlY29uZGFyeVwiPjxpIGNsYXNzPVwiYmkgYmktZ3JhcGgtdXBcIiAvPjxkaXYgY2xhc3M9XCJkLW1kLWlubGluZSBkLW5vbmVcIj4gIFNwbGluZTwvZGl2Pjwvc3Bhbj48L2E+XG4gICAgICAgICAgICA8YT48c3BhbiBpZD1cInRvZ2dsZUluZm9cIiBjbGFzcz1cIm1lLTEgYmFkZ2UgYmctbGlnaHQtaW5mb1wiIGRhdGEtYnMtdG9nZ2xlPVwiY29sbGFwc2VcIlxuICAgICAgICAgICAgICAgICAgICBkYXRhLWJzLXRhcmdldD1cIiNjb2xsYXBzZUluZm9zXCIgYXJpYS1leHBhbmRlZD1cImZhbHNlXCIgYXJpYS1jb250cm9scz1cImNvbGxhcHNlSW5mb3NcIj48aVxuICAgICAgICAgICAgICAgICAgICAgICAgY2xhc3M9XCJiaSBiaS1pbmZvLWNpcmNsZVwiIC8+PGRpdiBjbGFzcz1cImQtbWQtaW5saW5lIGQtbm9uZVwiPiAgSW5mbzwvZGl2Pjwvc3Bhbj48L2E+XG4gICAgICAgICAgICA8YT48c3BhbiBpZD1cInRvZ2dsZURlcHRoXCIgY2xhc3M9XCJtZS0xIGJhZGdlIGJnLWxpZ2h0LXByaW1hcnkgXCIgZGF0YS1icy10b2dnbGU9XCJjb2xsYXBzZVwiXG4gICAgICAgICAgICAgICAgICAgIGRhdGEtYnMtdGFyZ2V0PVwiI2NvbGxhcHNlRGVwdGhcIiBhcmlhLWV4cGFuZGVkPVwiZmFsc2VcIiBhcmlhLWNvbnRyb2xzPVwiY29sbGFwc2VEZXB0aFwiPjxpXG4gICAgICAgICAgICAgICAgICAgICAgICBjbGFzcz1cImJpIGJpLWthbmJhblwiIC8+PGRpdiBjbGFzcz1cImQtbWQtaW5saW5lIGQtbm9uZVwiPiAgRGVwdGggVmlldzwvZGl2Pjwvc3Bhbj48L2E+XG4gICAgICAgICAgICA8YT48c3BhbiBpZD1cInRvZ2dsZU9yZGVyc1wiIGNsYXNzPVwibWUtMSBiYWRnZSBiZy1saWdodC13YXJuaW5nIFwiIGRhdGEtYnMtdG9nZ2xlPVwiY29sbGFwc2VcIlxuICAgICAgICAgICAgZGF0YS1icy10YXJnZXQ9XCIjY29sbGFwc2VPcmRlcnNcIiBhcmlhLWV4cGFuZGVkPVwiZmFsc2VcIiBhcmlhLWNvbnRyb2xzPVwiY29sbGFwc2VPcmRlcnNcIj48aVxuICAgICAgICAgICAgICAgICAgICAgICAgY2xhc3M9XCJiaSBiaS1maWxlLWJhci1ncmFwaFwiIC8+PGRpdiBjbGFzcz1cImQtbWQtaW5saW5lIGQtbm9uZVwiPiAgT3JkZXIgQm9vazwvZGl2Pjwvc3Bhbj48L2E+XG4gICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgIDxkaXYgaWQ9XCJjb2xsYXBzZUluZm9zXCJcbiAgICAgICAgICAgICAgICBjbGFzcz1cImNvbGxhcHNlIGNvbC1sZy00IGNvbC1tZC01IGNvbC1zbS02IHBvc2l0aW9uLWFic29sdXRlIHN0aWNreS10b3AgY2FyZC0xMTAgXCI+XG4gICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cImNhcmRcIiBzdHlsZT1cImJhY2tncm91bmQ6IzEzMTcyMmU2IWltcG9ydGFudDtib3gtc2hhZG93OiAwIDRweCAyNHB4IDAgcmdiKDAgMCAwIC8gMzAlKTtcIj5cbiAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cImNhcmQtaGVhZGVyXCI+XG4gICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVwiY29sLW1kLThcIj5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8aDQgY2xhc3M9XCJjYXJkLXRpdGxlXCI+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHt7IHN5bWJvbCB9fVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvaDQ+XG4gICAgICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJjYXJkLWNvbnRlbnRcIj5cbiAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJjYXJkLWJvZHlcIj5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVwicm93XCI+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJjb2wtOFwiPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiBpZD1cInNob3dfYlwiIGNsYXNzPVwidGV4dC1zdGFydCBmcy0xXCI+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLi4uXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJjb2wtNFwiPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiBpZD1cInNob3dfcFwiIGNsYXNzPVwidGV4dC1lbmRcIiBzdHlsZT1cImZvbnQtc2l6ZToxNHB4O1wiPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC4uLlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IGlkPVwic2hvd19QXCIgY2xhc3M9XCJ0ZXh0LWVuZFwiIHN0eWxlPVwiZm9udC1zaXplOjE0cHg7XCI+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLi4uXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cInJvdyBtdC0xXCI+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgaWQ9XCJteVJhbmdlQ29sb3JcIiBjbGFzcz1cInByb2dyZXNzXCI+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IGlkPVwibXlSYW5nZVwiIGNsYXNzPVwicHJvZ3Jlc3MtYmFyIHByb2dyZXNzLWJhci1zdHJpcGVkIHByb2dyZXNzLWJhci1hbmltYXRlZFwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcm9sZT1cInByb2dyZXNzYmFyXCIgYXJpYS12YWx1ZW5vdz1cIjUwXCIgYXJpYS12YWx1ZW1pbj1cIjBcIiBhcmlhLXZhbHVlbWF4PVwiMTAwXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdHlsZT1cIndpZHRoOiA4MCVcIiAvPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVwicm93IGQtZmxleCBqdXN0aWZ5LWNvbnRlbnQtYmV0d2VlbiBhbGlnbi1pdGVtcy1jZW50ZXJcIj5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiBpZD1cInNob3dfbFwiIGNsYXNzPVwiY29sIHRleHQtc3RhcnQgdGV4dC1kYW5nZXJcIiBzdHlsZT1cImZvbnQtc2l6ZToxMHB4O1wiIC8+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJjb2wgdGV4dC1kYXJrIHRleHQtY2VudGVyXCIgc3R5bGU9XCJmb250LXNpemU6MTBweDtcIj5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIERheSBSYW5nZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiBpZD1cInNob3dfaFwiIGNsYXNzPVwiY29sIHRleHQtZW5kIHRleHQtc3VjY2Vzc1wiIHN0eWxlPVwiZm9udC1zaXplOjEwcHg7XCIgLz5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVwicm93IG10LTFcIj5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPHNtYWxsIGNsYXNzPVwiY29sIHRleHQtc3RhcnQgdGV4dC1kYXJrIGNsZWFyZml4XCI+Vm9sdW1lIDI0SDwvc21hbGw+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxzbWFsbCBpZD1cInNob3dfdlwiIGNsYXNzPVwiY29sIHRleHQtZW5kIHRleHQtd2FybmluZyBjbGVhcmZpeFwiIC8+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxocj5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVwicm93XCI+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxzbWFsbCBjbGFzcz1cImNvbCB0ZXh0LXN0YXJ0IHRleHQtZGFyayBjbGVhcmZpeFwiPk1hcmtldCBDYXA8L3NtYWxsPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8c21hbGwgaWQ9XCJzaG93X21jXCIgY2xhc3M9XCJjb2wgdGV4dC1lbmQgdGV4dC13YXJuaW5nIGNsZWFyZml4XCIgLz5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPGhyPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvZGl2PlxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cInJvd1wiPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8c21hbGwgY2xhc3M9XCJjb2wgdGV4dC1zdGFydCB0ZXh0LWRhcmsgY2xlYXJmaXhcIj5Ub3RhbCBTdXBwbHk8L3NtYWxsPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8c21hbGwgaWQ9XCJzaG93X3RzXCIgY2xhc3M9XCJjb2wgdGV4dC1lbmQgdGV4dC13YXJuaW5nIGNsZWFyZml4XCIgLz5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPGhyPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICA8ZGl2IGlkPVwiY29sbGFwc2VEZXB0aFwiXG4gICAgICAgICAgICAgICAgY2xhc3M9XCJjb2xsYXBzZSBjb2wtbGctNiBjb2wtbWQtMTAgY29sLXNtLTEyIGNvbC0xMiBwb3NpdGlvbi1hYnNvbHV0ZSBzdGlja3ktdG9wIGNhcmQtMTEwIFwiPlxuICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJjYXJkXCIgc3R5bGU9XCJiYWNrZ3JvdW5kOiMxMzE3MjJlNiFpbXBvcnRhbnQ7Ym94LXNoYWRvdzogMCA0cHggMjRweCAwIHJnYigwIDAgMCAvIDMwJSk7XCI+XG4gICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJjYXJkLWNvbnRlbnRcIj5cbiAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgaWQ9XCJjaGFydGRpdlwiPjwvZGl2PlxuICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgPGRpdiBpZD1cImNvbGxhcHNlT3JkZXJzXCJcbiAgICAgICAgICAgICAgICBjbGFzcz1cImNvbGxhcHNlIGNvbC1sZy00IGNvbC1tZC00IGNvbC1zbS02IGNvbC0xMiBwb3NpdGlvbi1hYnNvbHV0ZSBzdGlja3ktdG9wIGNhcmQtMTEwXCIgc3R5bGU9XCJtYXgtd2lkdGg6MjgwcHg7XCI+XG4gICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cImNhcmRcIiBzdHlsZT1cImJhY2tncm91bmQ6IzEzMTcyMmU2IWltcG9ydGFudDtib3gtc2hhZG93OiAwIDRweCAyNHB4IDAgcmdiKDAgMCAwIC8gMzAlKTtcIj5cbiAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cImNhcmQtY29udGVudCBteS0xXCI+XG4gICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVwiYm94XCI+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPHRhYmxlPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8dGhlYWQ+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8dHIgY2xhc3M9XCJtYi0xXCI+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPHRoIGNsYXNzPVwidGV4dC1zdGFydCBwcy0xIHRleHQtZGFya1wiPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBQcmljZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvdGg+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPHRoIGNsYXNzPVwidGV4dC1jZW50ZXIgcHMtMSB0ZXh0LWRhcmtcIj5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgUXVhbnRpdHlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L3RoPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDx0aCBjbGFzcz1cInRleHQtZW5kIHBlLTEgdGV4dC1kYXJrXCI+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFRvdGFsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPC90aD5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvdHI+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvdGhlYWQ+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPC90YWJsZT5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8dGFibGUgY2xhc3M9XCJhc2tzXCIgLz5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVwibmV3ZXN0XCIgLz5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8dGFibGUgY2xhc3M9XCJiaWRzXCIgLz5cbiAgICAgICAgICAgICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICA8ZGl2IGNsYXNzPVwiYXBwLWNvbnRhaW5lclwiIHN0eWxlPVwibWFyZ2luLXRvcDo0MHB4O1wiPlxuICAgICAgICAgICAgPHRyYWRpbmctdnVlIDprZXk9XCJyZXNldGtleVwiIHJlZj1cInR2anNcIiA6ZGF0YT1cImRjXCIgOndpZHRoPVwid2lkdGhcIiA6aGVpZ2h0PVwiaGVpZ2h0XCIgOnRpdGxlLXR4dD1cInRpdGxlXCJcbiAgICAgICAgICAgICAgICBjb2xvci10aXRsZT1cIiNmZjlmNDNcIiA6bGVnZW5kLWJ1dHRvbnM9XCJbJ2Rpc3BsYXknLCAnc2V0dGluZ3MnLCAndXAnLCAnZG93bicsICdhZGQnLCAncmVtb3ZlJ11cIlxuICAgICAgICAgICAgICAgIDpjaGFydC1jb25maWc9XCJ7REVGQVVMVF9MRU46NjAsTUlOX1pPT006MX1cIiA6dG9vbGJhcj1cInRydWVcIiA6Y29sb3ItYmFjaz1cImNvbG9ycy5jb2xvckJhY2tcIlxuICAgICAgICAgICAgICAgIDpjb2xvci1ncmlkPVwiY29sb3JzLmNvbG9yR3JpZFwiIDpjb2xvci10ZXh0PVwiY29sb3JzLmNvbG9yVGV4dFwiIDpleHRlbnNpb25zPVwiZXh0XCIgOm92ZXJsYXlzPVwib3ZzXCJcbiAgICAgICAgICAgICAgICA6bmlnaHQ9XCJuaWdodFwiIDpyZXNldGtleT1cInJlc2V0a2V5XCIgOngtc2V0dGluZ3M9XCJ4c2V0dFwiIDp0aW1lem9uZT1cInRpbWV6b25lXCIgLz5cbiAgICAgICAgPC9kaXY+XG4gICAgPC9kaXY+XG48L3RlbXBsYXRlPlxuXG48c2NyaXB0PlxuaW1wb3J0IHsgVHJhZGluZ1Z1ZSwgRGF0YUN1YmUgfSBmcm9tICd0cmFkaW5nLXZ1ZS1qcydcbmltcG9ydCBPdmVybGF5cyBmcm9tICd0dmpzLW92ZXJsYXlzJ1xuaW1wb3J0IERhdGEgZnJvbSAnLi4vcmVzb3VyY2VzL2RhdGEvZGF0YS5qc29uJ1xuaW1wb3J0IFV0aWxzIGZyb20gJy4vc3R1ZmYvdXRpbHMuanMnXG5pbXBvcnQgQ29uc3QgZnJvbSAnLi9zdHVmZi9jb25zdGFudHMuanMnXG5pbXBvcnQgU3RyZWFtIGZyb20gJy4vc3RyZWFtLmpzJ1xuaW1wb3J0IEV4dGVuc2lvbnMgZnJvbSAnLi9pbmRleF9kZXYnXG5pbXBvcnQgdHh0IGZyb20gJ3Jhdy1sb2FkZXIhLi4vcmVzb3VyY2VzL2Fzc2V0cy9jb3JzLnR4dCc7XG4vLyBHZXR0aW4nIGRhdGEgdGhyb3VnaCB3ZWJwZWNrIHByb3h5XG5jb25zdCBzeW1ib2xzbSA9IHdpbmRvdy5sb2NhdGlvbi5wYXRobmFtZS50b0xvd2VyQ2FzZSgpLnNwbGl0KCcvJylbM11cbmNvbnN0IHN5bWJvbGJnID0gd2luZG93LmxvY2F0aW9uLnBhdGhuYW1lLnRvVXBwZXJDYXNlKCkuc3BsaXQoJy8nKVszXVxuY29uc3QgcGFpcnNtID0gd2luZG93LmxvY2F0aW9uLnBhdGhuYW1lLnRvTG93ZXJDYXNlKCkuc3BsaXQoJy8nKVs0XVxuY29uc3QgcGFpcmJnID0gd2luZG93LmxvY2F0aW9uLnBhdGhuYW1lLnRvVXBwZXJDYXNlKCkuc3BsaXQoJy8nKVs0XVxuY29uc3QgVVJMID0gdHh0KydodHRwczovL2FwaS5iaW5hbmNlLmNvbS9hcGkvdjEva2xpbmVzP3N5bWJvbD0nXG5jb25zdCBXU1MgPSBgd3NzOi8vc3RyZWFtLmJpbmFuY2UuY29tOjk0NDMvd3MvJHtzeW1ib2xzbX0ke3BhaXJzbX1AYWdnVHJhZGVgXG5jb25zdCBkYXRhcyA9IGBkYXRhc2V0cy5iaW5hbmNlLSR7c3ltYm9sc219JHtwYWlyc219YFxuLy9jb25zdCBQT1JUID0gbG9jYXRpb24ucG9ydFxuLy9jb25zdCBVUkwgPSBgaHR0cDovL2xvY2FsaG9zdDoke1BPUlR9L2FwaS92MS9rbGluZXM/c3ltYm9sPWBcbi8vY29uc3QgV1NTID0gYHdzOi8vbG9jYWxob3N0OiR7UE9SVH0vd3MvJHtzeW1ib2xzbX1AYWdnVHJhZGVgXG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgICBuYW1lOiAnQXBwJyxcbiAgICBjb21wb25lbnRzOiB7XG4gICAgICAgIFRyYWRpbmdWdWVcbiAgICB9LFxuICAgIGRhdGEoKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBkYzogbmV3IERhdGFDdWJlKERhdGEpLFxuICAgICAgICAgICAgdGl0bGU6IHN5bWJvbGJnICsgcGFpcmJnLFxuICAgICAgICAgICAgd2lkdGg6IDAsXG4gICAgICAgICAgICBoZWlnaHQ6IDAsXG4gICAgICAgICAgICBsb2dfc2NhbGU6IHRydWUsXG4gICAgICAgICAgICBzeW1ib2w6IHN5bWJvbGJnICsgcGFpcmJnLFxuICAgICAgICAgICAgaW5kZXhfYmFzZWQ6IHRydWUsXG4gICAgICAgICAgICB0aW1lem9uZTogdGhpcy50aW1lem9uZWQoKSxcbiAgICAgICAgICAgIHhzZXR0OiB7XG4gICAgICAgICAgICAgICAgJ2dyaWQtcmVzaXplJzogeyBtaW5faGVpZ2h0OiAzMCB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgb3ZzOiBPYmplY3QudmFsdWVzKE92ZXJsYXlzKSxcbiAgICAgICAgICAgIGV4dDogT2JqZWN0LnZhbHVlcyhFeHRlbnNpb25zKSxcbiAgICAgICAgICAgIG5pZ2h0OiB0cnVlLFxuICAgICAgICAgICAgdG9wOiA1MCxcbiAgICAgICAgICAgIHJlc2V0a2V5OiAwXG4gICAgICAgIH1cbiAgICB9LFxuICAgIGNvbXB1dGVkOiB7XG4gICAgICAgIGNvbG9ycygpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm5pZ2h0ID8ge30gOiB7XG4gICAgICAgICAgICAgICAgY29sb3JCYWNrOiAnI2ZmZicsXG4gICAgICAgICAgICAgICAgY29sb3JHcmlkOiAnI2VlZScsXG4gICAgICAgICAgICAgICAgY29sb3JUZXh0OiAnIzMzMydcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0sXG4gICAgbW91bnRlZCgpIHtcbiAgICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3Jlc2l6ZScsIHRoaXMub25SZXNpemUpXG4gICAgICAgIGxldCBxID0gdGhpcy53aW5fcXVlcnkoKVxuICAgICAgICBpZiAocS5ubSA9PT0gJ2ZhbHNlJykgdGhpcy5uaWdodCA9IGZhbHNlXG4gICAgICAgIGlmIChxLm92KSB0aGlzLmN1cnJlbnQgPSBxLm92XG4gICAgICAgIGlmIChxLmhlYWRlciA9PT0gJ2ZhbHNlJykgdGhpcy50b3AgPSAwXG4gICAgICAgIHRoaXMub25SZXNpemUoKSxcbiAgICAgICAgd2luZG93LmRjID0gdGhpcy5kY1xuICAgICAgICB3aW5kb3cudHYgPSB0aGlzLiRyZWZzLnR2anNcbiAgICAgICAgLy8gTG9hZCB0aGUgbGFzdCBkYXRhIGNodW5rICYgaW5pdCBEYXRhQ3ViZTpcbiAgICAgICAgbGV0IG5vdyA9IFV0aWxzLm5vdygpXG4gICAgICAgIHRoaXMubG9hZF9jaHVuayhbbm93IC0gQ29uc3QuSE9VUjQsIG5vd10pLnRoZW4oZGF0YSA9PiB7XG4gICAgICAgICAgICBkYy5kYXRhLmNoYXJ0LmRhdGEgPSBkYXRhWydjaGFydC5kYXRhJ11cbiAgICAgICAgICAgIC8vIFJlZ2lzdGVyIG9ucmFuZ2UgY2FsbGJhY2sgJiBBbmQgYSBzdHJlYW0gb2YgdHJhZGVzXG4gICAgICAgICAgICB0aGlzLmRjLm9ucmFuZ2UodGhpcy5sb2FkX2NodW5rKVxuICAgICAgICAgICAgdGhpcy5zdHJlYW0gPSBuZXcgU3RyZWFtKFdTUylcbiAgICAgICAgICAgIHRoaXMuc3RyZWFtLm9udHJhZGVzID0gdGhpcy5vbl90cmFkZXNcbiAgICAgICAgICAgIHdpbmRvdy5kYyA9IHRoaXMuY2hhcnQgICAgICAvLyBEZWJ1Z1xuICAgICAgICAgICAgd2luZG93LnR2ID0gdGhpcy4kcmVmcy50dmpzIC8vIERlYnVnXG4gICAgICAgIH0pXG4gICAgfSxcbiAgICBiZWZvcmVEZXN0cm95KCkge1xuICAgICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcigncmVzaXplJywgdGhpcy5vblJlc2l6ZSlcbiAgICAgICAgaWYgKHRoaXMuc3RyZWFtKSB0aGlzLnN0cmVhbS5vZmYoKVxuICAgIH0sXG4gICAgbWV0aG9kczoge1xuICAgICAgICBvblJlc2l6ZSgpIHtcbiAgICAgICAgICAgIGlmICh3aW5kb3cuaW5uZXJXaWR0aCA+ICc5OTInKSB7XG4gICAgICAgICAgICAgICAgdGhpcy53aWR0aCA9ICh3aW5kb3cuaW5uZXJXaWR0aCAtICh3aW5kb3cuaW5uZXJXaWR0aCAqIDAuMjEpKVxuICAgICAgICAgICAgfSBlbHNlIGlmICh3aW5kb3cuaW5uZXJXaWR0aCA+ICc3NjgnICAmJiB3aW5kb3cuaW5uZXJXaWR0aCA8PSAnOTkyJykge1xuICAgICAgICAgICAgICAgIHRoaXMud2lkdGggPSAod2luZG93LmlubmVyV2lkdGggLSAod2luZG93LmlubmVyV2lkdGggKiAwLjI2KSlcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy53aWR0aCA9ICh3aW5kb3cuaW5uZXJXaWR0aCAtIDE1KVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5oZWlnaHQgPSB3aW5kb3cuaW5uZXJIZWlnaHQgKiAwLjgwXG4gICAgICAgIH0sXG4gICAgICAgIHNwbGluZSAoKSB7XG4gICAgICAgICAgICB0aGlzLmRjLmRhdGEuY2hhcnQudHlwZSA9IFwiU3BsaW5lXCJcbiAgICAgICAgICAgIHRoaXMuZGMuZGF0YS5jaGFydC50ZiA9IFwiMW1cIlxuICAgICAgICAgICAgdGhpcy4kcmVmcy50dmpzLnJlc2V0Q2hhcnQoKVxuICAgICAgICB9LFxuICAgICAgICBjYW5kbGVzICgpIHtcbiAgICAgICAgICAgIHRoaXMuZGMuZGF0YS5jaGFydC50eXBlID0gXCJDYW5kbGVzXCJcbiAgICAgICAgICAgIHRoaXMuZGMuZGF0YS5jaGFydC50ZiA9IFwiMW1cIlxuICAgICAgICAgICAgdGhpcy4kcmVmcy50dmpzLnJlc2V0Q2hhcnQoKVxuICAgICAgICB9LFxuICAgICAgICB4YmFycyAoKSB7XG4gICAgICAgICAgICB0aGlzLmRhdGEub3ZzID0gJ1hPaGxjQmFycydcbiAgICAgICAgICAgIHRoaXMuZGMuZGF0YS5jaGFydC50ZiA9IFwiMW1cIlxuICAgICAgICAgICAgdGhpcy4kcmVmcy50dmpzLnJlc2V0Q2hhcnQoKVxuICAgICAgICB9LFxuICAgICAgICB0cmFkZSAoKSB7XG4gICAgICAgICAgICB0aGlzLmRjLmRhdGEuY2hhcnQudHlwZSA9IFwiU3BsaW5lXCJcbiAgICAgICAgfSxcbiAgICAgICAgd2luX3F1ZXJ5KCkge1xuICAgICAgICAgICAgbGV0IHFzID0gKGZ1bmN0aW9uKGEpIHtcbiAgICAgICAgICAgICAgICBpZiAoYSA9PSBcIlwiKSByZXR1cm4ge307XG4gICAgICAgICAgICAgICAgdmFyIGIgPSB7fTtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGEubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHA9YVtpXS5zcGxpdCgnPScsIDIpO1xuICAgICAgICAgICAgICAgICAgICBpZiAocC5sZW5ndGggPT0gMSlcbiAgICAgICAgICAgICAgICAgICAgICAgIGJbcFswXV0gPSBcIlwiO1xuICAgICAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgICAgICBiW3BbMF1dID0gZGVjb2RlVVJJQ29tcG9uZW50KHBbMV0ucmVwbGFjZSgvXFwrL2csIFwiIFwiKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBiO1xuICAgICAgICAgICAgfSkod2luZG93LmxvY2F0aW9uLnNlYXJjaC5zdWJzdHIoMSkuc3BsaXQoJyYnKSk7XG4gICAgICAgICAgICByZXR1cm4gcXNcbiAgICAgICAgfSxcbiAgICAgICAgcmVzZXQoc3RhdGUpIHtcbiAgICAgICAgICAgIGxldCBzdWIgPSBPYmplY3Qua2V5cyhzdGF0ZSkuZmlsdGVyKHggPT4gc3RhdGVbeF0pXG4gICAgICAgICAgICB0aGlzLmV4dGVuc2lvbnMgPSBzdWIubWFwKHggPT4gRXh0ZW5zaW9uc1t4XSlcbiAgICAgICAgICAgIHRoaXMucmVzZXRrZXkrK1xuICAgICAgICB9LFxuICAgICAgICBvbnNlbGVjdChpZCkge1xuICAgICAgICAgICAgdGhpcy5jdXJyZW50ID0gaWRcbiAgICAgICAgfSxcbiAgICAgICAgdGltZXpvbmVkKCkge1xuICAgICAgICAgICAgdmFyIG9mZnNldCA9IG5ldyBEYXRlKCkuZ2V0VGltZXpvbmVPZmZzZXQoKTtcbiAgICAgICAgICAgIHZhciBtaW51dGVzID0gTWF0aC5hYnMob2Zmc2V0KTtcbiAgICAgICAgICAgIHZhciBob3VycyA9IE1hdGguZmxvb3IobWludXRlcyAvIDYwKTtcbiAgICAgICAgICAgIHZhciBwcmVmaXggPSBvZmZzZXQgPCAwID8gXCJcIiA6IFwiLVwiO1xuICAgICAgICAgICAgcmV0dXJuIHBhcnNlSW50KHByZWZpeCtob3Vycyk7XG4gICAgICAgIH0sXG4gICAgICAgIC8vIE5ldyBkYXRhIGhhbmRsZXIuIFNob3VsZCByZXR1cm4gUHJvbWlzZSwgb3JcbiAgICAgICAgLy8gdXNlIGNhbGxiYWNrOiBsb2FkX2NodW5rKHJhbmdlLCB0ZiwgY2FsbGJhY2spXG4gICAgICAgIGFzeW5jIGxvYWRfY2h1bmsocmFuZ2UpIHtcbiAgICAgICAgICAgIGxldCBbdDEsIHQyXSA9IHJhbmdlXG4gICAgICAgICAgICBsZXQgeCA9IHN5bWJvbGJnXG4gICAgICAgICAgICBsZXQgeSA9IHBhaXJiZ1xuICAgICAgICAgICAgbGV0IHEgPSBgJHt4fSR7eX0maW50ZXJ2YWw9MW0mc3RhcnRUaW1lPSR7dDF9JmVuZFRpbWU9JHt0Mn1gXG4gICAgICAgICAgICBsZXQgciA9IGF3YWl0IGZldGNoKFVSTCArIHEpLnRoZW4ociA9PiByLmpzb24oKSlcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmZvcm1hdCh0aGlzLnBhcnNlX2JpbmFuY2UocikpXG4gICAgICAgIH0sXG4gICAgICAgIC8vIFBhcnNlIGEgc3BlY2lmaWMgZXhjaGFuZ2UgZm9ybWF0XG4gICAgICAgIHBhcnNlX2JpbmFuY2UoZGF0YSkge1xuICAgICAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KGRhdGEpKSByZXR1cm4gW11cbiAgICAgICAgICAgIHJldHVybiBkYXRhLm1hcCh4ID0+IHtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHgubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgeFtpXSA9IHBhcnNlRmxvYXQoeFtpXSlcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHguc2xpY2UoMCw2KVxuICAgICAgICAgICAgfSlcbiAgICAgICAgfSxcbiAgICAgICAgZm9ybWF0KGRhdGEpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgJ2NoYXJ0LmRhdGEnOiBkYXRhLFxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBvbl90cmFkZXModHJhZGUpIHtcbiAgICAgICAgICAgIHRoaXMuZGMudXBkYXRlKHtcbiAgICAgICAgICAgICAgICB0OiB0cmFkZS5ULCAgICAgLy8gRXhjaGFuZ2UgdGltZSAob3B0aW9uYWwpXG4gICAgICAgICAgICAgICAgcHJpY2U6IHBhcnNlRmxvYXQodHJhZGUucCksICAgLy8gVHJhZGUgcHJpY2VcbiAgICAgICAgICAgICAgICB2b2x1bWU6IHBhcnNlRmxvYXQodHJhZGUucSksICAvLyBUcmFkZSBhbW91bnRcbiAgICAgICAgICAgICAgICBkYXRhcyA6IFsgLy8gVXBkYXRlIGRhdGFzZXRcbiAgICAgICAgICAgICAgICAgICAgdHJhZGUuVCxcbiAgICAgICAgICAgICAgICAgICAgdHJhZGUubSA/IDAgOiAxLCAgICAgICAgICAvLyBTZWxsIG9yIEJ1eVxuICAgICAgICAgICAgICAgICAgICBwYXJzZUZsb2F0KHRyYWRlLnEpLFxuICAgICAgICAgICAgICAgICAgICBwYXJzZUZsb2F0KHRyYWRlLnApXG4gICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICAvLyAuLi4gb3RoZXIgb25jaGFydC9vZmZjaGFydCB1cGRhdGVzXG4gICAgICAgICAgICB9KVxuICAgICAgICB9XG4gICAgfVxufVxuPC9zY3JpcHQ+XG5cbjxzdHlsZT5cbi5hcHAtY29udGVudCB7XG4gICAgcGFkZGluZzogY2FsYygycmVtICsgMi40NXJlbSkgMCAwIDByZW0gIWltcG9ydGFudDtcbiAgICBvdmVyZmxvdy14OiBoaWRkZW47XG59XG5AbWVkaWEgKG1heC13aWR0aDogNzY3Ljk4cHgpe1xuICAgIGh0bWwgYm9keS5uYXZiYXItc3RpY2t5IC5hcHAtY29udGVudCB7XG4gICAgICAgIHBhZGRpbmc6IGNhbGMoMXJlbSAtIDAuOHJlbSArIDQuNDVyZW0pIDAgMCAwICFpbXBvcnRhbnQ7XG4gICAgfVxufVxuLmZsZXhlZCB7XG4gICAgZGlzcGxheTogZmxleDtcbiAgICBmbGV4LWRpcmVjdGlvbjogY29sdW1uO1xuICAgIGFsaWduLWl0ZW1zOiBjZW50ZXI7XG4gICAganVzdGlmeS1jb250ZW50OiBjZW50ZXI7XG4gICAgYWxpZ24tY29udGVudDogY2VudGVyO1xuICAgIGZsZXgtd3JhcDogbm93cmFwO1xufVxuXG4jYXBwLWNvbmFpbmVyIHtcbiAgICBkaXNwbGF5OiBmbGV4O1xuICAgIGZsZXgtZGlyZWN0aW9uOiByb3c7XG4gICAganVzdGlmeS1jb250ZW50OiBzcGFjZS1iZXR3ZWVuO1xuICAgIGFsaWduLWNvbnRlbnQ6IHNwYWNlLWJldHdlZW47XG4gICAgYWxpZ24taXRlbXM6IGZsZXgtc3RhcnQ7XG4gICAgZmxleC13cmFwOiBub3dyYXA7XG59XG5cbi8qIEBtZWRpYSAobWF4LXdpZHRoOiA3NjcuOThweCl7XG4gICAgI2FwcC1jb25haW5lciB7XG4gICAgICAgIGRpc3BsYXk6IGZsZXg7XG4gICAgICAgIGZsZXgtZGlyZWN0aW9uOiBjb2x1bW47XG4gICAgICAgIGp1c3RpZnktY29udGVudDogc3BhY2UtYmV0d2VlbjtcbiAgICAgICAgYWxpZ24tY29udGVudDogc3BhY2UtYmV0d2VlbjtcbiAgICAgICAgYWxpZ24taXRlbXM6IGZsZXgtc3RhcnQ7XG4gICAgICAgIGZsZXgtd3JhcDogbm93cmFwO1xuICAgIH1cbn0gKi9cbiN0cmFkZWJhciB7XG4gICAgY29sb3I6ICNkZGQ7XG59XG5cbiN0dmpzLWhlYWRlciB7XG4gICAgcG9zaXRpb246IGFic29sdXRlO1xuICAgIGRpc3BsYXk6IGZsZXg7XG4gICAgYWxpZ24tY29udGVudDogY2VudGVyO1xuICAgIGZsZXgtZGlyZWN0aW9uOiByb3c7XG4gICAgZmxleC13cmFwOiBub3dyYXA7XG4gICAganVzdGlmeS1jb250ZW50OiBmbGV4LXN0YXJ0O1xuICAgIGFsaWduLWl0ZW1zOiBjZW50ZXI7XG4gICAgcGFkZGluZy1sZWZ0OiA3MHB4O1xuICAgIGhlaWdodDogNDBweDtcbiAgICBjb2xvcjogI2RkZDtcbiAgICB3aWR0aDogMTAwJTtcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiAjMTIxODI2O1xufVxuXG4ubmlnaHQtbW9kZSB7XG4gICAgcG9zaXRpb246IGFic29sdXRlO1xuICAgIHRvcDogMTVweDtcbiAgICByaWdodDogMjBweDtcbn1cblxuI3RyYWRpbmctdnVlLWpzLWdyaWQtMC1jYW52YXMsXG4jdHJhZGluZy12dWUtanMtc2lkZWJhci0wLWNhbnZhcyxcbiN0cmFkaW5nLXZ1ZS1qcy1ncmlkLTEtY2FudmFzLFxuI3RyYWRpbmctdnVlLWpzLXNpZGViYXItMS1jYW52YXMsXG4jdHJhZGluZy12dWUtanMtYm90YmFyLWNhbnZhcyB7XG4gICAgYmFja2dyb3VuZC1jb2xvcjogcmdiKDAgMCAwIC8gMCUpICFpbXBvcnRhbnQ7XG59XG5cbiN0cmFkaW5nLXZ1ZS10Yml0ZW0ge1xuICAgIGJhY2tncm91bmQtY29sb3I6IHJnYigxOCwgMjQsIDM4KTtcbn1cblxuQG1lZGlhIG9ubHkgc2NyZWVuIGFuZCAobWF4LWRldmljZS13aWR0aDogNDgwcHgpIHtcbiAgICAudGYtc2VsZWN0b3Ige1xuICAgICAgICB0b3A6IDUwcHg7XG4gICAgICAgIHJpZ2h0OiAxNDBweDtcbiAgICAgICAgbWF4LXdpZHRoOiAxNDBweDtcbiAgICAgICAgZm9udDogMTJweCAtYXBwbGUtc3lzdGVtLCBCbGlua01hY1N5c3RlbUZvbnQsXG4gICAgICAgICAgICBTZWdvZSBVSSwgUm9ib3RvLCBPeHlnZW4sIFVidW50dSwgQ2FudGFyZWxsLFxuICAgICAgICAgICAgRmlyYSBTYW5zLCBEcm9pZCBTYW5zLCBIZWx2ZXRpY2EgTmV1ZSxcbiAgICAgICAgICAgIHNhbnMtc2VyaWY7XG4gICAgfVxufVxuXG4uYm94IHtcbiAgICB3aWR0aDogMjgwcHg7XG4gICAgbWFyZ2luOiAwIGF1dG87XG4gICAgYm94LXNoYWRvdzogMCAxLjVweCA1cHggLTJweCByZ2JhKDAsIDAsIDAsIDAuMik7XG4gICAgYm9yZGVyLXJhZGl1czogM3B4O1xuICAgIHBhZGRpbmc6IDAgMTVweCAwIDE1cHg7XG59XG5cbnRhYmxlIHtcbiAgICBmb250LXNpemU6IDEzcHg7XG4gICAgZm9udC13ZWlnaHQ6IDUwMDtcbiAgICBjb2xvcjogcmdiKDE4MywgMTg5LCAxOTgpO1xuICAgIG92ZXJmbG93OiBoaWRkZW47XG4gICAgd2lkdGg6IDEwMCU7XG59XG5cbnRkIHtcbiAgICBwb3NpdGlvbjogcmVsYXRpdmU7XG4gICAgaGVpZ2h0OiAyMHB4O1xuICAgIGxpbmUtaGVpZ2h0OiAyMHB4O1xufVxuXG50ZC5wcmljZSB7XG4gICAgd2lkdGg6IDMwJTtcbn1cblxudGQucHJpY2Ugc3BhbiB7XG4gICAgcGFkZGluZy1sZWZ0OiA1cHg7XG59XG5cbnRkLnF1YW50aXR5IHtcbiAgICB3aWR0aDogMzAlO1xuICAgIHRleHQtYWxpZ246IHJpZ2h0O1xufVxuXG50ZC50aW1lIHtcbiAgICB3aWR0aDogNDAlO1xuICAgIHRleHQtYWxpZ246IHJpZ2h0O1xuICAgIGNvbG9yOiAjOTk5O1xuICAgIHBhZGRpbmctcmlnaHQ6IDVweDtcbn1cblxudGQuYnRjIHtcbiAgICB3aWR0aDogNDAlO1xuICAgIHRleHQtYWxpZ246IHJpZ2h0O1xuICAgIHBhZGRpbmctcmlnaHQ6IDVweDtcbn1cblxudGQgc3BhbiB7XG4gICAgcG9zaXRpb246IHJlbGF0aXZlO1xuICAgIHotaW5kZXg6IDI7XG59XG5cbnRhYmxlLmFza3MgLnBlcmNlbnQge1xuICAgIGJhY2tncm91bmQtY29sb3I6IHJnYmEoMjQ2LCA3MCwgOTQsIDAuMik7XG59XG5cbnRhYmxlLmJpZHMgLnBlcmNlbnQge1xuICAgIGJhY2tncm91bmQtY29sb3I6IHJnYmEoMTQsIDIwMywgMTI5LCAwLjIpO1xufVxuXG50ZCAucGVyY2VudCB7XG4gICAgcG9zaXRpb246IGFic29sdXRlO1xuICAgIHRvcDogMDtcbiAgICBib3R0b206IDA7XG4gICAgcmlnaHQ6IDA7XG59XG5cbi5uZXdlc3Qge1xuICAgIGJvcmRlci1ib3R0b206IDFweCBzb2xpZCAjZWVlO1xuICAgIG1hcmdpbjogMTVweCAtMTVweDtcbn1cblxuLmNhcmQtMTEwIHtcbiAgICB0b3A6IDExMHB4ICFpbXBvcnRhbnQ7XG4gICAgbGVmdDogNzBweDtcbn1cbi8qIFN0eWxlIHBhZ2UgY29udGVudCAtIHVzZSB0aGlzIGlmIHlvdSB3YW50IHRvIHB1c2ggdGhlIHBhZ2UgY29udGVudCB0byB0aGUgcmlnaHQgd2hlbiB5b3Ugb3BlbiB0aGUgc2lkZSBuYXZpZ2F0aW9uICovXG4jbWFpbiB7XG4gICAgdHJhbnNpdGlvbjogbWFyZ2luLWxlZnQgLjVzO1xuICAgIC8qIElmIHlvdSB3YW50IGEgdHJhbnNpdGlvbiBlZmZlY3QgKi9cbn1cblxuLyogT24gc21hbGxlciBzY3JlZW5zLCB3aGVyZSBoZWlnaHQgaXMgbGVzcyB0aGFuIDQ1MHB4LCBjaGFuZ2UgdGhlIHN0eWxlIG9mIHRoZSBzaWRlbmF2IChsZXNzIHBhZGRpbmcgYW5kIGEgc21hbGxlciBmb250IHNpemUpICovXG5AbWVkaWEgc2NyZWVuIGFuZCAobWF4LWhlaWdodDogNDUwcHgpIHtcbiAgICAuc2lkZWJhcjEge1xuICAgICAgICBwYWRkaW5nLXRvcDogMTVweDtcbiAgICB9XG5cbiAgICAuc2lkZWJhcjEgYSB7XG4gICAgICAgIGZvbnQtc2l6ZTogMThweDtcbiAgICB9XG59XG5cbi5idG4tY2lyY2xlIHtcbiAgICB3aWR0aDogMzBweDtcbiAgICBoZWlnaHQ6IDMwcHg7XG4gICAgcGFkZGluZzogNnB4IDBweDtcbiAgICBib3JkZXItcmFkaXVzOiAxNXB4O1xuICAgIGZvbnQtc2l6ZTogOHB4O1xuICAgIHRleHQtYWxpZ246IGNlbnRlcjtcbn1cblxuI2NoYXJ0ZGl2IHtcbiAgICBtaW4taGVpZ2h0OiAzMDBweDtcbiAgICBtYXgtaGVpZ2h0OiA0MDBweDtcbiAgICBoZWlnaHQ6IDcwdmg7XG59XG48L3N0eWxlPlxuIiwiPHRlbXBsYXRlPlxyXG4gICAgPHNwYW4+XHJcbiAgICAgICAgPGlucHV0XG52LWlmPVwidHlwZT09PSd0ZXh0JyB8fCAhdHlwZVwiXHJcbiAgICAgICAgICAgIDp2YWx1ZT1cInZhbHVlXCJcbmNsYXNzPVwidHZqcy1zdGQtaW5wdXRcIlxuOnN0eWxlPVwic3R5bGVcIlxyXG4gICAgICAgICAgICA6cGxhY2Vob2xkZXI9XCJuYW1lXCJcclxuICAgICAgICAgICAgQGNoYW5nZT1cIiRlbWl0KCdjaGFuZ2UnLCAkZXZlbnQudGFyZ2V0LnZhbHVlKVwiXHJcbiAgICAgICAgICAgIEBpbnB1dD1cIiRlbWl0KCdpbnB1dCcsICRldmVudC50YXJnZXQudmFsdWUpXCJcbj5cclxuICAgICAgICA8c2VsZWN0XG52LWVsc2UtaWY9XCJ0eXBlPT09J3NlbGVjdCdcIlxyXG4gICAgICAgICAgICBjbGFzcz1cInR2anMtc3RkLWlucHV0XCJcbjpzdHlsZT1cInN0eWxlXCJcclxuICAgICAgICAgICAgOnZhbHVlPVwidmFsdWVcIlxyXG4gICAgICAgICAgICBAaW5wdXQ9XCIkZW1pdCgnaW5wdXQnLCAkZXZlbnQudGFyZ2V0LnZhbHVlKVwiXG4+XHJcbiAgICAgICAgICAgIDxvcHRpb24gdi1mb3I9XCJvcHQgaW4gbGlzdFwiPnt7IG9wdCB9fTwvb3B0aW9uPlxyXG4gICAgICAgIDwvc2VsZWN0PlxyXG4gICAgPC9zcGFuPlxyXG48L3RlbXBsYXRlPlxyXG5cclxuPHNjcmlwdD5cclxuZXhwb3J0IGRlZmF1bHQge1xyXG4gICAgbmFtZTogJ1N0ZElucHV0JyxcclxuICAgIHByb3BzOiBbJ3ZhbHVlJywgJ25hbWUnLCAndHlwZScsICdsaXN0JywgJ2NvbG9ycyddLFxyXG4gICAgZGF0YSgpIHtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgIH1cclxuICAgIH0sXHJcbiAgICBjb21wdXRlZDoge1xyXG4gICAgICAgIHN0eWxlKCkge1xyXG4gICAgICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICAgICAgLy9iYWNrZ3JvdW5kOiB0aGlzLiRwcm9wcy5jb2xvcnMuYmFjayxcclxuICAgICAgICAgICAgICAgIC8vY29sb3I6IHRoaXMuJHByb3BzLmNvbG9ycy50ZXh0XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9LFxyXG4gICAgbWV0aG9kczoge31cclxufVxyXG48L3NjcmlwdD5cclxuXHJcbjxzdHlsZT5cclxuLnR2anMtc3RkLWlucHV0IHtcclxuICAgIG1hcmdpbjogNXB4O1xyXG4gICAgYmFja2dyb3VuZC1jb2xvcjogIzE2MWIyNztcclxuICAgIGJvcmRlcjogMXB4IGRvdHRlZCAjMzUzOTQwO1xyXG4gICAgaGVpZ2h0OiAyMnB4O1xyXG4gICAgYm9yZGVyLXJhZGl1czogM3B4O1xyXG4gICAgcGFkZGluZzogMnB4IDBweCAzcHggMTBweDtcclxuICAgIGNvbG9yOiB3aGl0ZXNtb2tlO1xyXG4gICAgZm9udC1zaXplOiAxLjJlbTtcclxuICAgIG91dGxpbmU6IG5vbmU7XHJcbiAgICB3aWR0aDogMTAwcHg7XHJcbn1cclxuXHJcbnNlbGVjdC50dmpzLXN0ZC1pbnB1dCB7XHJcbiAgICBoZWlnaHQ6IDI5cHg7XHJcbiAgICAtbW96LWFwcGVhcmFuY2U6IG5vbmU7XHJcblxyXG59XHJcblxyXG5zZWxlY3QudHZqcy1zdGQtaW5wdXQgIHtcclxuICAgIC8vZGlzcGxheTogbm9uZTsgLypoaWRlIG9yaWdpbmFsIFNFTEVDVCBlbGVtZW50OiAqL1xyXG59XHJcblxyXG5cclxuLnR2anMtc3RkLWlucHV0OjpwbGFjZWhvbGRlciB7XHJcbiAgICBjb2xvcjogIzhlOTA5YTtcclxuICAgIG9wYWNpdHk6IDAuMjU7XHJcbn1cclxuPC9zdHlsZT5cclxuIiwiPHRlbXBsYXRlPlxyXG4gICAgPGRpdlxucmVmPVwid2luXCJcbmNsYXNzPVwidHZqcy14LXdpbmRvd1wiXG46c3R5bGU9XCJzdHlsZVwiXG4+XHJcbiAgICAgICAgPGRpdiBjbGFzcz1cInR2anMteC13aW5kb3ctaGVhZFwiPlxyXG4gICAgICAgICAgICA8ZGl2XG5jbGFzcz1cInR2anMteC13aW5kb3ctdGl0bGVcIlxyXG4gICAgICAgICAgICAgICAgQG1vdXNlZG93bj1cIm9uTW91c2VEb3duXCJcbj5cclxuICAgICAgICAgICAgICAgIHt7IHRpdGxlIH19XHJcbiAgICAgICAgICAgIDwvZGl2PlxyXG4gICAgICAgICAgICA8ZGl2XG5jbGFzcz1cInR2anMteC13aW5kb3ctY2xvc2VcIlxyXG4gICAgICAgICAgICAgICAgQGNsaWNrPVwiJGVtaXQoJ2Nsb3NlJylcIlxuPlxyXG4gICAgICAgICAgICAgICAg4pWzXHJcbiAgICAgICAgICAgIDwvZGl2PlxyXG4gICAgICAgIDwvZGl2PlxyXG4gICAgICAgIDxkaXYgY2xhc3M9XCJ0dmpzLXgtd2luZG93LWJvZHlcIj5cclxuICAgICAgICAgICAgPHNsb3QgLz5cclxuICAgICAgICA8L2Rpdj5cclxuICAgIDwvZGl2PlxyXG48L3RlbXBsYXRlPlxyXG48c2NyaXB0PlxyXG5cclxuaW1wb3J0IERyYWdnIGZyb20gJy4vZHJhZ2cuanMnXHJcblxyXG5leHBvcnQgZGVmYXVsdCB7XHJcbiAgICBuYW1lOiAnV2luZG93JyxcclxuICAgIG1peGluczogW0RyYWdnXSxcclxuICAgIHByb3BzOiBbJ3RpdGxlJywgJ3R2J10sXHJcbiAgICBkYXRhKCkge1xyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIHd3OiAwLFxyXG4gICAgICAgICAgICB3aDogMCxcclxuICAgICAgICAgICAgeDogMCxcclxuICAgICAgICAgICAgeTogMFxyXG4gICAgICAgIH1cclxuICAgIH0sXHJcbiAgICBjb21wdXRlZDoge1xyXG4gICAgICAgIHN0eWxlKCkge1xyXG4gICAgICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICAgICAgdG9wOiBgJHt0aGlzLnl9cHhgLFxyXG4gICAgICAgICAgICAgICAgbGVmdDogYCR7dGhpcy54fXB4YFxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSxcclxuICAgICAgICB0dncoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLiRwcm9wcy50di53aWR0aFxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgdHZoKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy4kcHJvcHMudHYuaGVpZ2h0XHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuICAgIG1vdW50ZWQoKSB7XHJcbiAgICAgICAgdGhpcy53dyA9IHRoaXMuJHJlZnMud2luLmNsaWVudFdpZHRoXHJcbiAgICAgICAgdGhpcy53aCA9IHRoaXMuJHJlZnMud2luLmNsaWVudEhlaWdodFxyXG4gICAgICAgIHRoaXMueCA9IHRoaXMudHZ3ICogMC41IC0gdGhpcy53dyAqIDAuNVxyXG4gICAgICAgIHRoaXMueSA9IHRoaXMudHZoICogMC41IC0gdGhpcy53aCAqIDAuNVxyXG4gICAgfVxyXG59XHJcbjwvc2NyaXB0PlxyXG48c3R5bGU+XHJcbi50dmpzLXgtd2luZG93IHtcclxuICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTtcclxuICAgIGJhY2tncm91bmQ6ICMxYjIwMmRlZjtcclxuICAgIGJvcmRlci1yYWRpdXM6IDNweDtcclxuICAgIHBvaW50ZXItZXZlbnRzOiBhbGw7XHJcbiAgICBwYWRkaW5nLWxlZnQ6IDdweDtcclxuICAgIHotaW5kZXg6IDEwMDtcclxuICAgIGNvbG9yOiAjZGVkZGRkO1xyXG59XHJcbi50dmpzLXgtd2luZG93LWhlYWQge1xyXG4gICAgZm9udC1zaXplOiAyZW07XHJcbiAgICB1c2VyLXNlbGVjdDogbm9uZTtcclxuICAgIGRpc3BsYXk6IGZsZXg7XHJcbiAgICBmbGV4LWRpcmVjdGlvbjogcm93O1xyXG4gICAgZmxleC13cmFwOiBub3dyYXA7XHJcbiAgICBqdXN0aWZ5LWNvbnRlbnQ6IGZsZXgtc3RhcnQ7XHJcbiAgICBhbGlnbi1jb250ZW50OiBjZW50ZXI7XHJcbiAgICBhbGlnbi1pdGVtczogY2VudGVyO1xyXG4gICAgaGVpZ2h0OiAzNnB4O1xyXG4gICAgcGFkZGluZzogMTBweDtcclxuICAgIGN1cnNvcjogZ3JhYjtcclxufVxyXG5cclxuLnR2anMteC13aW5kb3ctYm9keSB7XHJcbiAgICBwYWRkaW5nOiAxMHB4O1xyXG4gICAgZm9udC1zaXplOiAxLjFlbTtcclxufVxyXG4udHZqcy14LXdpbmRvdy10aXRsZSB7XHJcbiAgICB3aWR0aDogMzAwcHg7XHJcbiAgICB1c2VyLXNlbGVjdDogbm9uZTtcclxufVxyXG4udHZqcy14LXdpbmRvdy1jbG9zZSB7XHJcbiAgICB3aWR0aDogMjZweDtcclxuICAgIGN1cnNvcjogcG9pbnRlcjtcclxuICAgIG1hcmdpbjogLTFlbTtcclxuICAgIHBhZGRpbmc6IDFlbTtcclxuICAgIGZvbnQtc2l6ZTogMC43NWVtO1xyXG59XHJcbjwvc3R5bGU+XHJcbiIsIjx0ZW1wbGF0ZT5cclxuICAgIDxzcGFuXG5jbGFzcz1cImgtc3BsaXR0ZXJcIlxyXG4gICAgICAgIDpzdHlsZT1cImhzX3N0eWxlXCJcbkBtb3VzZWRvd249XCJoc19tb3VzZWRvd25cIlxuLz5cclxuPC90ZW1wbGF0ZT5cclxuPHNjcmlwdD5cclxuXHJcbmltcG9ydCBVdGlscyBmcm9tICcuL3V0aWxzLmpzJ1xyXG5cclxuZXhwb3J0IGRlZmF1bHQge1xyXG4gICAgbmFtZTogJ1NwbGl0dGVyJyxcclxuICAgIHByb3BzOiBbJ2lkJywgJ21haW4nLCAnZGMnLCAndHYnLCAnZGF0YSddLFxyXG4gICAgY29tcHV0ZWQ6IHtcclxuICAgICAgICBoc19zdHlsZSgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgICAgIGRyYWc6IG51bGwsXHJcbiAgICAgICAgICAgICAgICB0b3A6IHRoaXMuZGF0YS5ncmlkMi5vZmZzZXQgKyAncHgnLFxyXG4gICAgICAgICAgICAgICAgLy9iYWNrZ3JvdW5kQ29sb3I6IHRoaXMuY29sb3JzLnNwbGl0dGVyXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LFxyXG4gICAgfSxcclxuICAgIG1vdW50ZWQoKSB7XHJcbiAgICAgICAgdGhpcy5NSU5fSEVJR0hUID0gdGhpcy5kYXRhLnNldHQubWluX2hlaWdodCB8fCAyMFxyXG4gICAgfSxcclxuICAgIG1ldGhvZHM6IHtcclxuICAgICAgICBoc19tb3VzZWRvd24oZSkge1xyXG4gICAgICAgICAgICB0aGlzLmRyYWcgPSB7XHJcbiAgICAgICAgICAgICAgICB0eXBlOiAnaHMnLFxyXG4gICAgICAgICAgICAgICAgeTogZS5jbGllbnRZLFxyXG4gICAgICAgICAgICAgICAgaDE6IHRoaXMuZGF0YS5ncmlkMS5oZWlnaHQsXHJcbiAgICAgICAgICAgICAgICBoMjogdGhpcy5kYXRhLmdyaWQyLmhlaWdodFxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIFV0aWxzLmFkZF9zdHlsZSgnZGlzYWJsZS11c2VyLXNlbGVjdCcsIGBib2R5ICoge1xyXG4gICAgICAgICAgICAgICAgdXNlci1zZWxlY3Q6IG5vbmU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLnRyYWRpbmctdnVlLWNoYXJ0IHtcclxuICAgICAgICAgICAgICAgIHBvaW50ZXItZXZlbnRzOiBub25lO1xyXG4gICAgICAgICAgICB9YClcclxuICAgICAgICB9LFxyXG4gICAgICAgIGhzX21vdXNldXAoZSkge1xyXG4gICAgICAgICAgICB0aGlzLmRyYWcgPSBudWxsXHJcbiAgICAgICAgICAgIFV0aWxzLnJlbV9zdHlsZSgnZGlzYWJsZS11c2VyLXNlbGVjdCcpXHJcbiAgICAgICAgfSxcclxuICAgICAgICBoc19tb3VzZW1vdmUoZSkge1xyXG4gICAgICAgICAgICBpZiAodGhpcy5kcmFnKSB7XHJcbiAgICAgICAgICAgICAgICBsZXQgb2ZmID0gZS5jbGllbnRZIC0gdGhpcy5kcmFnLnlcclxuICAgICAgICAgICAgICAgIGxldCBuZXdfaDEgPSB0aGlzLmRyYWcuaDEgKyBvZmZcclxuICAgICAgICAgICAgICAgIGxldCBuZXdfaDIgPSB0aGlzLmRyYWcuaDIgLSBvZmZcclxuICAgICAgICAgICAgICAgIGlmIChuZXdfaDEgPiB0aGlzLk1JTl9IRUlHSFQgJiZcclxuICAgICAgICAgICAgICAgICAgICBuZXdfaDIgPiB0aGlzLk1JTl9IRUlHSFQpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRhdGEuZ3JpZDEuaGVpZ2h0ID0gbmV3X2gxXHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kYXRhLmdyaWQyLmhlaWdodCA9IG5ld19oMlxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgdGhpcy5tYWluLmNhbGNfaGVpZ2h0cygpXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LFxyXG4gICAgICAgIGhzX21vdXNlbGVhdmUoZSkge1xyXG4gICAgICAgICAgICB0aGlzLmRyYWcgPSBudWxsXHJcbiAgICAgICAgICAgIFV0aWxzLnJlbV9zdHlsZSgnZGlzYWJsZS11c2VyLXNlbGVjdCcpXHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcbjwvc2NyaXB0PlxyXG48c3R5bGUgc2NvcGVkPlxyXG4uaC1zcGxpdHRlciB7XHJcbiAgICBwb3NpdGlvbjogYWJzb2x1dGU7XHJcbiAgICBsZWZ0OiAwO1xyXG4gICAgaGVpZ2h0OiA1cHg7XHJcbiAgICBtYXJnaW4tdG9wOiAtMnB4O1xyXG4gICAgd2lkdGg6IDEwMCU7XHJcbiAgICB6LWluZGV4OiAxO1xyXG4gICAgYmFja2dyb3VuZC1jb2xvcjogIzNlZTRhZmI1O1xyXG4gICAgb3BhY2l0eTogMDtcclxuICAgIHBvaW50ZXItZXZlbnRzOiBhbGw7XHJcbn1cclxuLmgtc3BsaXR0ZXI6aG92ZXIge1xyXG4gICAgY3Vyc29yOiByb3ctcmVzaXplO1xyXG4gICAgb3BhY2l0eTogMTtcclxufVxyXG48L3N0eWxlPlxyXG4iLCI8dGVtcGxhdGU+XG4gICAgPHdpbmRvdyB0aXRsZT1cIkFkZCBJbmRpY2F0b3JcIiBjbGFzcz1cImFkZC13aW5cIiA6dHY9XCJ0dlwiIEBjbG9zZT1cIm9uX2Nsb3NlXCI+XG4gICAgICAgIDxkaXYgY2xhc3M9XCJhZGQtd2luLWxpc3RcIj5cbiAgICAgICAgICAgIDxkaXYgdi1mb3I9XCJvdiBvZiBvdnNcIiBjbGFzcz1cImFkZC13aW4taXRlbVwiIEBjbGljaz1cIm9uX2NsaWNrKG92Lm5hbWUpXCI+XG4gICAgICAgICAgICAgICAgPHNwYW4+e3sgb3YubmFtZSB9fTwvc3Bhbj5cbiAgICAgICAgICAgICAgICA8c3BhbiBjbGFzcz1cImFkZC13aW4taXRlbS1kZXNjXCI+XG4gICAgICAgICAgICAgICAgICAgIHt7IG92Lm1ldGhvZHMubWV0YV9pbmZvKCkuZGVzYyB9fVxuICAgICAgICAgICAgICAgIDwvc3Bhbj5cbiAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICA8L2Rpdj5cbiAgICA8L3dpbmRvdz5cbjwvdGVtcGxhdGU+XG48c2NyaXB0PlxuXG5pbXBvcnQgV2luZG93IGZyb20gJy4uLy4uL2NvbXBvbmVudHMvV2luZG93LnZ1ZSdcblxuZXhwb3J0IGRlZmF1bHQge1xuICAgIG5hbWU6ICdBZGRXaW4nLFxuICAgIGNvbXBvbmVudHM6IHsgV2luZG93IH0sXG4gICAgcHJvcHM6IFsnaWQnLCAnbWFpbicsICdkYycsICd0dicsICdkYXRhJ10sXG4gICAgZGF0YSgpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIG92czogdGhpcy50di5vdmVybGF5cy5maWx0ZXIoeCA9PiB4Lm1ldGhvZHMuY2FsYylcbiAgICAgICAgfVxuICAgIH0sXG4gICAgY29tcHV0ZWQ6IHtcbiAgICAgICAgc2V0dCgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLiRwcm9wcy5kYXRhLm92LnNldHRpbmdzXG4gICAgICAgIH1cbiAgICB9LFxuICAgIG1vdW50ZWQoKSB7XG4gICAgfSxcbiAgICBtZXRob2RzOiB7XG4gICAgICAgIG9uX2Nsb3NlKCkge1xuICAgICAgICAgICAgdGhpcy4kcHJvcHMubWFpbi5yZW1vdmVfd2lkZ2V0KHRoaXMuJHByb3BzLmlkKVxuICAgICAgICB9LFxuICAgICAgICBvbl9jbGljayhuYW1lKSB7XG4gICAgICAgICAgICB0aGlzLm9uX2Nsb3NlKClcbiAgICAgICAgICAgIHRoaXMubWFpbi5hZGRfb3ZlcmxheSh7XG4gICAgICAgICAgICAgICAgc2lkZTogdGhpcy5kYXRhLnR5cGUsXG4gICAgICAgICAgICAgICAgaW5kZXg6IHRoaXMuZGF0YS5pbmRleCxcbiAgICAgICAgICAgICAgICB0eXBlOiBuYW1lXG4gICAgICAgICAgICB9KVxuICAgICAgICB9XG4gICAgfVxufVxuPC9zY3JpcHQ+XG48c3R5bGUgc2NvcGVkPlxuLnR2anMteC13aW5kb3cuYWRkLXdpbiB7XG4gICAgcGFkZGluZy1ib3R0b206IDMwcHg7XG4gICAgYm9yZGVyOiAxcHggc29saWQgIzgwODA4MDExO1xufVxuLmFkZC13aW4tbGlzdCB7XG4gICAgaGVpZ2h0OiAzMDBweDtcbiAgICBvdmVyZmxvdy14OiBoaWRkZW47XG4gICAgb3ZlcmZsb3cteTogYXV0bztcbiAgICB1c2VyLXNlbGVjdDogbm9uZTtcbn1cbi8qIEhpZGUgc2Nyb2xsYmFyIGZvciBDaHJvbWUsIFNhZmFyaSBhbmQgT3BlcmEgKi9cbi5hZGQtd2luLWxpc3Q6Oi13ZWJraXQtc2Nyb2xsYmFyIHtcbiAgZGlzcGxheTogbm9uZTtcbn1cblxuLyogSGlkZSBzY3JvbGxiYXIgZm9yIElFLCBFZGdlIGFuZCBGaXJlZm94ICovXG4uYWRkLXdpbi1saXN0IHtcbiAgLW1zLW92ZXJmbG93LXN0eWxlOiBub25lOyAgLyogSUUgYW5kIEVkZ2UgKi9cbiAgc2Nyb2xsYmFyLXdpZHRoOiBub25lOyAgLyogRmlyZWZveCAqL1xufVxuLmFkZC13aW4taXRlbSB7XG4gICAgY29sb3I6ICNmZmZmZmY4ODtcbiAgICB3aWR0aDogMTAwJTtcbiAgICBwYWRkaW5nOiA1cHg7XG4gICAgY3Vyc29yOiBwb2ludGVyO1xufVxuLmFkZC13aW4taXRlbTpob3ZlciB7XG4gICAgYmFja2dyb3VuZDogIzg4ODg4ODIyO1xuICAgIGNvbG9yOiAjZmZmZmZmZmY7XG59XG4uYWRkLXdpbi1pdGVtLWRlc2Mge1xuICAgIGNvbG9yOiAjZmZmZmZmMzM7XG4gICAgbWFyZ2luLWxlZnQ6IDNweDtcbn1cbi5hZGQtd2luLWl0ZW06aG92ZXIgLmFkZC13aW4taXRlbS1kZXNjIHtcbiAgICBjb2xvcjogI2ZmZmZmZjQ0O1xufVxuLmFkZC13aW4tZW1wdHkge1xuICAgIG9wYWNpdHk6IDAuNTtcbn1cbjwvc3R5bGU+XG4iLCI8dGVtcGxhdGU+XG4gICAgPHdpbmRvdyA6dGl0bGU9XCJkYXRhLm92Lm5hbWVcIiBjbGFzcz1cInNldHQtd2luXCIgOnR2PVwidHZcIiBAY2xvc2U9XCJvbl9jbG9zZVwiPlxuICAgICAgICA8ZGl2IHYtZm9yPVwiayBpbiBzZXR0bGlzdFwiIGNsYXNzPVwic2V0dC13aW4taXRlbVwiPlxuICAgICAgICAgICAgPGxhYmVsPnt7IHMyZChrKSB9fTwvbGFiZWw+XG4gICAgICAgICAgICA8c3RkLWlucHV0IDp2YWx1ZT1cInNldHRba11cIiBAaW5wdXQ9XCJ1cGRhdGVfc2V0dChrLCAkZXZlbnQpXCIgLz5cbiAgICAgICAgPC9kaXY+XG4gICAgICAgIDxzcGFuIHYtaWY9XCIhc2V0dGxpc3QubGVuZ3RoXCIgY2xhc3M9XCJzZXR0LXdpbi1lbXB0eVwiPlxuICAgICAgICAgICAgPGk+Tm8gc2NyaXB0IHNldHRpbmdzPC9pPlxuICAgICAgICA8L3NwYW4+XG4gICAgPC93aW5kb3c+XG48L3RlbXBsYXRlPlxuPHNjcmlwdD5cblxuaW1wb3J0IFdpbmRvdyBmcm9tICcuLi8uLi9jb21wb25lbnRzL1dpbmRvdy52dWUnXG5pbXBvcnQgU3RkSW5wdXQgZnJvbSAnLi4vLi4vY29tcG9uZW50cy9TdGRJbnB1dC52dWUnXG5pbXBvcnQgVXRpbHMgZnJvbSAnLi91dGlscy5qcydcblxuZXhwb3J0IGRlZmF1bHQge1xuICAgIG5hbWU6ICdTZXR0aW5nc1dpbicsXG4gICAgY29tcG9uZW50czogeyBXaW5kb3csIFN0ZElucHV0IH0sXG4gICAgcHJvcHM6IFsnaWQnLCAnbWFpbicsICdkYycsICd0dicsICdkYXRhJ10sXG4gICAgY29tcHV0ZWQ6IHtcbiAgICAgICAgc2V0dCgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLiRwcm9wcy5kYXRhLm92LnNldHRpbmdzXG4gICAgICAgIH0sXG4gICAgICAgIHNldHRsaXN0KCkge1xuICAgICAgICAgICAgcmV0dXJuIE9iamVjdC5rZXlzKHRoaXMuc2V0dCkuZmlsdGVyKHggPT5cbiAgICAgICAgICAgICAgICB4WzBdICE9PSAnJCcgJiYgdGhpcy5zZXR0LiRwcm9wcyAmJlxuICAgICAgICAgICAgICAgIHRoaXMuc2V0dC4kcHJvcHMuaW5jbHVkZXMoeCkpXG4gICAgICAgIH1cbiAgICB9LFxuICAgIG1vdW50ZWQoKSB7XG4gICAgfSxcbiAgICBtZXRob2RzOiB7XG4gICAgICAgIHMyZChzdHIpIHtcbiAgICAgICAgICAgIHJldHVybiBVdGlscy5zZXR0MmRlc2Moc3RyKVxuICAgICAgICB9LFxuICAgICAgICBvbl9jbG9zZSgpIHtcbiAgICAgICAgICAgIHRoaXMuJHByb3BzLm1haW4ucmVtb3ZlX3dpZGdldCh0aGlzLiRwcm9wcy5pZClcbiAgICAgICAgfSxcbiAgICAgICAgdXBkYXRlX3NldHQoaywgdmFsKSB7XG4gICAgICAgICAgICBsZXQgZGNpZCA9IHRoaXMuJHByb3BzLmRhdGEub3YuaWRcblxuICAgICAgICAgICAgbGV0IHZhbE4gPSBwYXJzZUZsb2F0KHZhbClcbiAgICAgICAgICAgIGlmICh2YWxOICE9PSB2YWxOKSB2YWxOID0gdmFsXG5cbiAgICAgICAgICAgIHRoaXMuJHByb3BzLmRjLm1lcmdlKGAke2RjaWR9LnNldHRpbmdzYCxcbiAgICAgICAgICAgICAgICB7IFtrXTogdmFsTiB9XG4gICAgICAgICAgICApXG4gICAgICAgIH1cbiAgICB9XG59XG48L3NjcmlwdD5cbjxzdHlsZSBzY29wZWQ+XG4udHZqcy14LXdpbmRvdy5zZXR0LXdpbiB7XG4gICAgcGFkZGluZy1ib3R0b206IDMwcHg7XG4gICAgYm9yZGVyOiAxcHggc29saWQgIzgwODA4MDExO1xufVxuLnNldHQtd2luLWl0ZW0ge1xuICAgIGRpc3BsYXk6IGZsZXg7XG4gICAgZmxleC1kaXJlY3Rpb246IHJvdztcbiAgICBmbGV4LXdyYXA6IG5vd3JhcDtcbiAgICBqdXN0aWZ5LWNvbnRlbnQ6IGZsZXgtc3RhcnQ7XG4gICAgYWxpZ24tY29udGVudDogY2VudGVyO1xuICAgIGFsaWduLWl0ZW1zOiBjZW50ZXI7XG59XG4uc2V0dC13aW4taXRlbSBsYWJlbCB7XG4gICAgbWluLXdpZHRoOiA4MHB4O1xuICAgIGNvbG9yOiAjMzVhNzc2O1xufVxuLnNldHQtd2luLWVtcHR5IHtcbiAgICBvcGFjaXR5OiAwLjU7XG59XG48L3N0eWxlPlxuIiwiZXhwb3J0IGRlZmF1bHQgIHtcclxuICAgIG1ldGhvZHM6IHtcclxuICAgICAgICBvbk1vdXNlRG93bihlKSB7XHJcbiAgICAgICAgICAgIGUgPSBlIHx8IHdpbmRvdy5ldmVudFxyXG4gICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KClcclxuICAgICAgICAgICAgdGhpcy5kcmFnLm9mZnNldF94ID0gZS5jbGllbnRYIC0gdGhpcy54XHJcbiAgICAgICAgICAgIHRoaXMuZHJhZy5vZmZzZXRfeSA9IGUuY2xpZW50WSAtIHRoaXMueVxyXG4gICAgICAgICAgICBkb2N1bWVudC5vbm1vdXNldXAgPSB0aGlzLnN0b3BkcmFnXHJcbiAgICAgICAgICAgIGRvY3VtZW50Lm9ubW91c2Vtb3ZlID0gdGhpcy5vbmRyYWdcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICBvbmRyYWcoZSkge1xyXG4gICAgICAgICAgICBlID0gZSB8fCB3aW5kb3cuZXZlbnRcclxuICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpXHJcbiAgICAgICAgICAgIHRoaXMueCA9IGUuY2xpZW50WCAtIHRoaXMuZHJhZy5vZmZzZXRfeFxyXG4gICAgICAgICAgICB0aGlzLnkgPSAgZS5jbGllbnRZIC0gdGhpcy5kcmFnLm9mZnNldF95XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgc3RvcGRyYWcoKSB7XHJcbiAgICAgICAgICAgIGRvY3VtZW50Lm9ubW91c2V1cCA9IG51bGxcclxuICAgICAgICAgICAgZG9jdW1lbnQub25tb3VzZW1vdmUgPSBudWxsXHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuICAgIGRhdGEoKSB7XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgZHJhZzoge1xyXG4gICAgICAgICAgICAgICAgb2Zmc2V0X3g6IDAsXHJcbiAgICAgICAgICAgICAgICBvZmZzZXRfeTogMFxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcbiIsIlxyXG4vKiBFeGFtcGxlOlxyXG5cclxucnVsZXM6IHtcclxuICAgICcqIC0+IConOiB7fSwgICAgIC8vIEZyb20gZWFjaCB0byBlYWNoXHJcbiAgICAnKic6IHsgICAgICAgICAgICAvLyBUaGUgc2FtZSBhcyBeXHJcbiAgICAgICAgY3Vyc29yOiB0cnVlLCAvLyBib29sLCAnWCcsICdZJywgJ1hZJ1xyXG4gICAgICAgIHBvc2l0aW9uOiAnWCcsIC8vIGJvb2wsICdYJywgJ1knLCAnWFknXHJcbiAgICAgICAgdG9vbHM6IHRydWVcclxuICAgIH0sXHJcbiAgICAndHJhZGluZy12dWUtMSAtPiB0cmFkaW5nLXZ1ZS0yJzoge1xyXG4gICAgICAgIGRhdGE6IFtcclxuICAgICAgICAgICAgJ29uY2hhcnQuU01BJyxcclxuICAgICAgICAgICAgJ1JTSTRIJyxcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgZnJvbTogJ2NoYXJ0LmRhdGEnLFxyXG4gICAgICAgICAgICAgICAgdG86ICdkYXRhc2V0cycsXHJcbiAgICAgICAgICAgICAgICBvYmo6IHtcclxuICAgICAgICAgICAgICAgICAgICBpZDogJ3NtYWxsLXRmLWRhdGEnLFxyXG4gICAgICAgICAgICAgICAgICAgIHR5cGU6ICdTb3VyY2VEYXRhJ1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgXVxyXG4gICAgfSxcclxuICAgICdub25lJzoge1xyXG4gICAgICAgIHJhbmdlOiAnWCcsIC8vIGJvb2wsICdYJywgJ1knLCAnWFknXHJcbiAgICB9XHJcbn1cclxuKi9cclxuXHJcbmltcG9ydCBTaGFyZWQgZnJvbSAnLi9zaGFyZWQuanMnXHJcbmltcG9ydCBVdGlscyBmcm9tICcuL3V0aWxzLmpzJ1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgTWFpbiB7XHJcblxyXG4gICAgY29uc3RydWN0b3IodHYsIGRjLCBzZXR0KSB7XHJcblxyXG4gICAgICAgIGlmIChzZXR0LnVzZV93aW5kb3cpIHtcclxuICAgICAgICAgICAgaWYgKCF3aW5kb3cueGNoYXJ0bGluayQpIHtcclxuICAgICAgICAgICAgICAgIHdpbmRvdy54Y2hhcnRsaW5rJCA9IHt9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy5zaGFyZWQgPSB3aW5kb3cueGNoYXJ0bGluayRcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICB0aGlzLnNoYXJlZCA9IFNoYXJlZFxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdGhpcy50diA9IHR2XHJcbiAgICAgICAgdGhpcy5kYyA9IGRjXHJcbiAgICAgICAgdGhpcy5zZXR0ID0gc2V0dFxyXG4gICAgICAgIHRoaXMudGFyZ2V0cyA9IHt9XHJcblxyXG4gICAgICAgIHRoaXMub25zZXR0aW5ncyh7J2NoYXJ0LWxpbmsnOiBzZXR0fSlcclxuICAgIH1cclxuXHJcbiAgICBvbnNldHRpbmdzKGFsbCkge1xyXG4gICAgICAgIGNsZWFyVGltZW91dCh0aGlzLnJlc2V0X2lkKVxyXG4gICAgICAgIHRoaXMuc2V0dCA9IGFsbFsnY2hhcnQtbGluayddXHJcbiAgICAgICAgaWYgKCF0aGlzLnNoYXJlZC5ydWxlcykge1xyXG4gICAgICAgICAgICB0aGlzLnNoYXJlZC5ydWxlcyA9IHt9XHJcbiAgICAgICAgICAgIHRoaXMuc2hhcmVkLnJlZnMgPSB7fVxyXG4gICAgICAgICAgICB0aGlzLnNoYXJlZC5tZXRhID0ge31cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGxldCBlbCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKHRoaXMudHYuaWQpXHJcblxyXG4gICAgICAgIGlmICh0aGlzLnNldHQucnVsZXMgJiYgZWwpIHtcclxuICAgICAgICAgICAgdGhpcy5zaGFyZWQucnVsZXNbdGhpcy50di5pZF0gPSB0aGlzLnNldHQucnVsZXNcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHRoaXMuc2hhcmVkLnJlZnNbdGhpcy50di5pZF0gPSB0aGlzLnR2XHJcblxyXG4gICAgICAgIHRoaXMuY29tYmluZSgpXHJcbiAgICAgICAgdGhpcy5yZXNldF9pZCA9IHNldFRpbWVvdXQoKCkgPT4gdGhpcy5yZXNldCgpKVxyXG4gICAgfVxyXG5cclxuICAgIC8vICBDb21iaW5lIHJ1bGVzIGZyb20gZGlmZmVyZW50IGluc3RhbmNlc1xyXG4gICAgY29tYmluZSgpIHtcclxuICAgICAgICB0aGlzLnNoYXJlZC5jb21iaW5lZCA9IHt9XHJcbiAgICAgICAgZm9yICh2YXIgaWQgaW4gdGhpcy5zaGFyZWQucnVsZXMpIHtcclxuICAgICAgICAgICAgZm9yICh2YXIgciBpbiB0aGlzLnNoYXJlZC5ydWxlc1tpZF0pIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuc2hhcmVkLmNvbWJpbmVkW3JdID1cclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnNoYXJlZC5ydWxlc1tpZF1bcl1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvLyBDb21waWxlIHJ1bGVzIGZvciB0aGlzIGluc3RhbmNlXHJcbiAgICBjb21waWxlKCkge1xyXG5cclxuICAgICAgICBsZXQgZ2ViY24gPSAnZ2V0RWxlbWVudHNCeUNsYXNzTmFtZSdcclxuICAgICAgICBsZXQgZWxzID0gWy4uLmRvY3VtZW50W2dlYmNuXSgndHJhZGluZy12dWUnKV1cclxuICAgICAgICB0aGlzLnRhcmdldHMgPSB7fVxyXG5cclxuICAgICAgICBmb3IgKGxldCBlbCBvZiBlbHMpIHtcclxuICAgICAgICAgICAgaWYgKGVsLmlkID09PSB0aGlzLnR2LmlkKSBjb250aW51ZVxyXG4gICAgICAgICAgICB0aGlzLnRhcmdldHNbZWwuaWRdID0ge31cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGxldCBydWxlcyA9IHRoaXMucmFuayh0aGlzLnNoYXJlZC5jb21iaW5lZClcclxuXHJcbiAgICAgICAgZm9yICh2YXIgciBvZiBydWxlcykge1xyXG4gICAgICAgICAgICBsZXQgZHN0ID0gci5wYWlyWzFdXHJcbiAgICAgICAgICAgIGlmIChkc3QgPT09ICcqJykge1xyXG4gICAgICAgICAgICAgICAgZHN0ID0gT2JqZWN0LmtleXModGhpcy50YXJnZXRzKVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KGRzdCkpIHtcclxuICAgICAgICAgICAgICAgIGZvciAodmFyIGQgb2YgZHN0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCEoZCBpbiB0aGlzLnRhcmdldHMpKSBjb250aW51ZVxyXG4gICAgICAgICAgICAgICAgICAgIE9iamVjdC5hc3NpZ24odGhpcy50YXJnZXRzW2RdLCByLnIpXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoIShkc3QgaW4gdGhpcy50YXJnZXRzKSkgY29udGludWVcclxuICAgICAgICAgICAgICAgIE9iamVjdC5hc3NpZ24odGhpcy50YXJnZXRzW2RzdF0sIHIucilcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvLyBTZWxlY3QsIHJhbmsgJiBzb3J0IHRoZSBydWxlc1xyXG4gICAgcmFuayhydWxlcykge1xyXG4gICAgICAgIGxldCBvdXQgPSBbXVxyXG4gICAgICAgIGZvciAodmFyIHIgaW4gcnVsZXMpIHtcclxuICAgICAgICAgICAgbGV0IHBhaXIgPSB0aGlzLnNwbGl0cihyKVxyXG4gICAgICAgICAgICBpZiAoIXRoaXMubWF0Y2hlcyhwYWlyWzBdKSkgY29udGludWVcclxuICAgICAgICAgICAgaWYgKHBhaXJbMF0gPT09ICcqJykge1xyXG4gICAgICAgICAgICAgICAgdmFyIHJhbmsgPSAyMFxyXG4gICAgICAgICAgICB9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkocGFpclswXSkgKSB7XHJcbiAgICAgICAgICAgICAgICByYW5rID0gMTBcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHJhbmsgPSAwXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKHBhaXJbMV0gPT09ICcqJykge1xyXG4gICAgICAgICAgICAgICAgcmFuayArPSAyXHJcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheShwYWlyWzFdKSApIHtcclxuICAgICAgICAgICAgICAgIHJhbmsgKz0gMVxyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgcmFuayArPSAwXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgb3V0LnB1c2goe3BhaXIsIHJhbmssIHI6IHJ1bGVzW3JdfSlcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG91dC5zb3J0KChhLCBiKSA9PiBiLnJhbmsgLSBhLnJhbmspXHJcbiAgICB9XHJcblxyXG4gICAgLy8gQ2hlY2sgaWYgdGhlIHNvdXJjZSBvZiBhIHJ1bGUgbWF0Y2hlcyB0di5pZFxyXG4gICAgbWF0Y2hlcyhzcmMpIHtcclxuICAgICAgICByZXR1cm4gc3JjID09PSAnKicgfHwgc3JjID09PSB0aGlzLnR2LmlkIHx8XHJcbiAgICAgICAgICAgIChBcnJheS5pc0FycmF5KHNyYykgJiYgc3JjLmluY2x1ZGVzKHRoaXMudHYuaWQpKVxyXG4gICAgfVxyXG5cclxuICAgIHNwbGl0cihydWxlKSB7XHJcbiAgICAgICAgaWYgKHJ1bGUudHJpbSgpID09PSAnKicpIHJldHVybiBbJyonLCAnKiddXHJcbiAgICAgICAgcmV0dXJuIHJ1bGUuc3BsaXQoJy0+JykubWFwKHggPT4ge1xyXG4gICAgICAgICAgICBsZXQgdHVwID0geC5zcGxpdCgnLCcpXHJcbiAgICAgICAgICAgIGlmICh0dXAubGVuZ3RoID4gMSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHR1cC5tYXAoeSA9PiB5LnRyaW0oKSlcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4geC50cmltKClcclxuICAgICAgICB9KVxyXG5cclxuICAgIH1cclxuXHJcbiAgICAvLyBBcHBseSBhbGwgcnVsZXMgZm9yIHRoaXMgaW5zdGFuY2VcclxuICAgIHJlc2V0KCkge1xyXG4gICAgICAgIHRoaXMuY29tcGlsZSgpXHJcblxyXG4gICAgICAgIC8vIEVuYWJsZSBzb21lIGNoYXJ0IGhvb2sgZXZlbnRzXHJcbiAgICAgICAgdGhpcy50di4kcmVmcy5jaGFydC5ob29rcygneGNoYW5nZWQnKVxyXG5cclxuXHJcbiAgICAgICAgdGhpcy50di4kd2F0Y2goeCA9PiB0aGlzLmRjLmdldCgnLicpXHJcbiAgICAgICAgICAgIC5maWx0ZXIoeCA9PiB4LnNldHRpbmdzLiRzdGF0ZSksXHJcbiAgICAgICAgICAgIHRoaXMub250b29scy5iaW5kKHRoaXMpKVxyXG5cclxuICAgIH1cclxuXHJcbiAgICAvLyBMaXN0ZW5pbmcgdG8gdGhlIENoYXJ0LnZ1ZSBob29rcyAmXHJcbiAgICAvLyBvdGhlciBldmVudHNcclxuICAgIHVwZGF0ZShlKSB7XHJcbiAgICAgICAgc3dpdGNoIChlLmV2ZW50KSB7XHJcbiAgICAgICAgICAgIGNhc2UgJz94LWNoYW5nZWQnOlxyXG4gICAgICAgICAgICAgICAgbGV0IGN1cnNvciA9IGUuYXJnc1swXVxyXG4gICAgICAgICAgICAgICAgaWYgKGN1cnNvci5wcmV2ZW50RGVmYXVsdCkgcmV0dXJuXHJcbiAgICAgICAgICAgICAgICBsZXQgbWFpbiA9IHRoaXMudHYuJHJlZnMuY2hhcnQuX2xheW91dC5ncmlkc1tjdXJzb3IuZ3JpZF9pZF1cclxuICAgICAgICAgICAgICAgIGxldCBtYyA9IHRoaXMudHYuJHJlZnMuY2hhcnQuY3Vyc29yXHJcbiAgICAgICAgICAgICAgICBjdXJzb3IudCA9IG1jLnRcclxuICAgICAgICAgICAgICAgIGN1cnNvci4kID0gbWMueSRcclxuICAgICAgICAgICAgICAgIGZvciAodmFyIGlkIGluIHRoaXMudGFyZ2V0cykge1xyXG4gICAgICAgICAgICAgICAgICAgIGxldCByID0gdGhpcy50YXJnZXRzW2lkXS5jdXJzb3JcclxuICAgICAgICAgICAgICAgICAgICBpZiAocikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgdHYgPSB0aGlzLnNoYXJlZC5yZWZzW2lkXVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgZyA9IHR2LiRyZWZzLmNoYXJ0Ll9sYXlvdXQuZ3JpZHNbMF1cclxuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IHh4ID0gdGhpcy5pc1gocilcclxuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IHl5ID0gZy5pZCA9PT0gbWFpbi5pZCAmJiB0aGlzLmlzWShyKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgdXBkID0ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJldmVudERlZmF1bHQ6IHRydWUsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB4OiB4eCA/IGcudDJzY3JlZW4oY3Vyc29yLnQpIDogLTEwLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgeTogeXkgPyBnLiQyc2NyZWVuKGN1cnNvci4kKSA6IC0xMCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGdyaWRfaWQ6IDBcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0di4kcmVmcy5jaGFydC5jdXJzb3JfY2hhbmdlZCh1cGQpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHR2LiRyZWZzLmNoYXJ0LmN1cnNvci50ID0geHggPyBjdXJzb3IudCA6IC0xMFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0di4kcmVmcy5jaGFydC5jdXJzb3IueSQgPSB5eSA/IGN1cnNvci4kIDogLTEwXHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgYnJlYWtcclxuICAgICAgICAgICAgY2FzZSAncmFuZ2UtY2hhbmdlZCc6XHJcbiAgICAgICAgICAgICAgICBsZXQgbm93ID0gbmV3IERhdGUoKS5nZXRUaW1lKClcclxuICAgICAgICAgICAgICAgIGxldCBtZXRhID0gdGhpcy5zaGFyZWQubWV0YVt0aGlzLnR2LmlkXVxyXG4gICAgICAgICAgICAgICAgaWYgKG1ldGEgJiYgbWV0YS5wb3NpdGlvbikge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChtZXRhLnBvc2l0aW9uLmxvY2sgPiBub3cpIHJldHVyblxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgbGV0IHJhbmdlID0gZS5hcmdzWzBdXHJcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpZCBpbiB0aGlzLnRhcmdldHMpIHtcclxuICAgICAgICAgICAgICAgICAgICBsZXQgciA9IHRoaXMudGFyZ2V0c1tpZF0ucG9zaXRpb25cclxuICAgICAgICAgICAgICAgICAgICBsZXQgdHYgPSB0aGlzLnNoYXJlZC5yZWZzW2lkXVxyXG4gICAgICAgICAgICAgICAgICAgIGxldCB4eCA9IHRoaXMuaXNYKHIpXHJcbiAgICAgICAgICAgICAgICAgICAgbGV0IHl5ID0gdGhpcy5pc1kocilcclxuICAgICAgICAgICAgICAgICAgICBpZiAoIXRoaXMuc2hhcmVkLm1ldGFbaWRdKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc2hhcmVkLm1ldGFbaWRdID0ge31cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gUHJldmVudHMgYW4gaW5maW5pdGUgbG9vcFxyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2hhcmVkLm1ldGFbaWRdLnBvc2l0aW9uID0ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBsb2NrOiBub3cgKyAxMDBcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHh4KSB0di5nb3RvKHJhbmdlWzFdKVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgYnJlYWtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgb250b29scyhuLCBwKSB7XHJcbiAgICAgICAgbGV0IHJlbSA9IFV0aWxzLnJlbW92ZWQoXHJcbiAgICAgICAgICAgIG4ubWFwKHggPT4geC5zZXR0aW5ncy4kdXVpZCksXHJcbiAgICAgICAgICAgIHAubWFwKHggPT4geC5zZXR0aW5ncy4kdXVpZClcclxuICAgICAgICApXHJcbiAgICAgICAgbGV0IG5vdyA9IG5ldyBEYXRlKCkuZ2V0VGltZSgpXHJcbiAgICAgICAgbGV0IG1ldGEgPSB0aGlzLnNoYXJlZC5tZXRhW3RoaXMudHYuaWRdXHJcbiAgICAgICAgaWYgKG1ldGEgJiYgbWV0YS50b29scykge1xyXG4gICAgICAgICAgICBpZiAobWV0YS50b29scy5sb2NrID4gbm93KSByZXR1cm5cclxuICAgICAgICB9XHJcbiAgICAgICAgZm9yICh2YXIgaWQgaW4gdGhpcy50YXJnZXRzKSB7XHJcbiAgICAgICAgICAgIGxldCByID0gdGhpcy50YXJnZXRzW2lkXS50b29sc1xyXG4gICAgICAgICAgICBsZXQgdHYgPSB0aGlzLnNoYXJlZC5yZWZzW2lkXVxyXG4gICAgICAgICAgICBpZiAocikge1xyXG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLnNoYXJlZC5tZXRhW2lkXSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2hhcmVkLm1ldGFbaWRdID0ge31cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIC8vIFByZXZlbnRzIGFuIGluZmluaXRlIGxvb3BcclxuICAgICAgICAgICAgICAgIHRoaXMuc2hhcmVkLm1ldGFbaWRdLnRvb2xzID0ge1xyXG4gICAgICAgICAgICAgICAgICAgIGxvY2s6IG5vdyArIDEwMFxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgdGhpcy5jb3B5X3Rvb2xzKG4sIHR2KVxyXG4gICAgICAgICAgICAgICAgcmVtLmZvckVhY2gociA9PiB0di5kYXRhLmRlbChgJHtyfWApKVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGNvcHlfdG9vbHMobiwgdHYpIHtcclxuICAgICAgICBmb3IgKHZhciB0b29sIG9mIG4pIHtcclxuICAgICAgICAgICAgaWYgKHRvb2wuaWQuaW5jbHVkZXMoJ29mZmNoYXJ0JykpIGNvbnRpbnVlXHJcbiAgICAgICAgICAgIGxldCB1dWlkID0gdG9vbC5zZXR0aW5ncy4kdXVpZFxyXG4gICAgICAgICAgICBsZXQgZXhpID0gdHYuZGF0YS5nZXRfb25lKGAke3V1aWR9YClcclxuICAgICAgICAgICAgaWYgKGV4aSkge1xyXG4gICAgICAgICAgICAgICAgdHYuJHNldChleGksICdzZXR0aW5ncycsIFV0aWxzLmNvcHkoXHJcbiAgICAgICAgICAgICAgICAgICAgdG9vbC5zZXR0aW5ncyxcclxuICAgICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICRzZWxlY3RlZDogZmFsc2UsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICRzdGF0ZTogJ2ZpbmlzaGVkJ1xyXG4gICAgICAgICAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgICAgICApXHJcbiAgICAgICAgICAgICAgICAvLyBUT0RPOiBtYXliZSBhZGQgYSBwcm9wZXIgbWV0aG9kXHJcbiAgICAgICAgICAgICAgICAvLyBvZiBhY2Nlc3Npbmcgb3ZlcmxheXNcclxuICAgICAgICAgICAgICAgIGxldCBvdnMgPSB0di4kcmVmcy5jaGFydC4kcmVmcy5zZWNbMF1cclxuICAgICAgICAgICAgICAgICAgICAuJHJlZnMuZ3JpZFxyXG4gICAgICAgICAgICAgICAgICAgIC4kY2hpbGRyZW4uZmlsdGVyKHggPT4geC50b29sKVxyXG5cclxuICAgICAgICAgICAgICAgIGZvciAodmFyIG92IG9mIG92cykge1xyXG4gICAgICAgICAgICAgICAgICAgIG92LnBpbnMuZm9yRWFjaCh4ID0+IHgucmVfaW5pdCgpKVxyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGxldCBjb3B5ID0gVXRpbHMuY29weSh0b29sKVxyXG4gICAgICAgICAgICAgICAgY29weS5zZXR0aW5ncy4kc2VsZWN0ZWQgPSBmYWxzZVxyXG4gICAgICAgICAgICAgICAgY29weS5zZXR0aW5ncy4kc3RhdGUgPSAnZmluaXNoZWQnXHJcbiAgICAgICAgICAgICAgICB0di5kYXRhLmFkZCgnb25jaGFydCcsIGNvcHkpXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgaXNYKHJ1bGUpIHtcclxuICAgICAgICByZXR1cm4gcnVsZSA9PT0gdHJ1ZSB8fFxyXG4gICAgICAgICAgICAodHlwZW9mIHJ1bGUgPT09ICdzdHJpbmcnICYmIHJ1bGUuaW5jbHVkZXMoJ1gnKSlcclxuICAgIH1cclxuXHJcbiAgICBpc1kocnVsZSkge1xyXG4gICAgICAgIHJldHVybiBydWxlID09PSB0cnVlIHx8XHJcbiAgICAgICAgICAgICh0eXBlb2YgcnVsZSA9PT0gJ3N0cmluZycgJiYgcnVsZS5pbmNsdWRlcygnWScpKVxyXG4gICAgfVxyXG5cclxufVxyXG4iLCJcclxuLy8gIE9iamVjdCBzaGFyZWQgYmVldHdlZW4gdHZqcyBpbnN0YW5jZXNcclxuXHJcbmNsYXNzIFNoYXJlZCB7XHJcbiAgICBjb25zdHJ1Y3RvcigpIHtcclxuICAgICAgICB0aGlzLl9faWRfXyA9IE1hdGgucmFuZG9tKClcclxuICAgIH1cclxufVxyXG5cclxuZXhwb3J0IGRlZmF1bHQgbmV3IFNoYXJlZCgpXHJcbiIsImV4cG9ydCBkZWZhdWx0IHtcclxuXHJcbiAgICBjb3B5KG9iaiwgbW9kKSB7XHJcbiAgICAgICAgbGV0IGNvcHkgPSBKU09OLnBhcnNlKEpTT04uc3RyaW5naWZ5KG9iaikpXHJcbiAgICAgICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oY29weSwgbW9kKVxyXG4gICAgfSxcclxuXHJcbiAgICByZW1vdmVkKGlkcywgcHJldikge1xyXG4gICAgICAgIGxldCBsaXN0ID0gW11cclxuICAgICAgICBmb3IgKHZhciBpZCBvZiBwcmV2KSB7XHJcbiAgICAgICAgICAgIGlmICghaWRzLmluY2x1ZGVzKGlkKSkge1xyXG4gICAgICAgICAgICAgICAgbGlzdC5wdXNoKGlkKVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBsaXN0XHJcbiAgICB9XHJcbn1cclxuIiwiXG4vLyBFeHRlbnNpb24ncyBjb250cm9sbGVyXG5cbmltcG9ydCB7IFV0aWxzIH0gZnJvbSAndHJhZGluZy12dWUtanMnXG5pbXBvcnQgVnVlIGZyb20gJ3Z1ZSdcbmltcG9ydCBTcGxpdHRlciBmcm9tICcuL1NwbGl0dGVyLnZ1ZSdcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgTWFpbiB7XG5cbiAgICBjb25zdHJ1Y3Rvcih0diwgZGMsIHNldHQpIHtcblxuICAgICAgICB0aGlzLndpZGdldHMgPSB7fVxuICAgICAgICB0aGlzLnR2ID0gdHZcbiAgICAgICAgdGhpcy5kYyA9IGRjXG4gICAgICAgIHRoaXMuc2V0dCA9IHNldHRcblxuICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcblxuICAgICAgICAgICAgdGhpcy50di4kZWwuYWRkRXZlbnRMaXN0ZW5lcihcbiAgICAgICAgICAgICAgICAnbW91c2Vtb3ZlJywgdGhpcy5vbm1vdXNlbW92ZS5iaW5kKHRoaXMpXG4gICAgICAgICAgICApXG5cbiAgICAgICAgICAgIHRoaXMudHYuJGVsLmFkZEV2ZW50TGlzdGVuZXIoXG4gICAgICAgICAgICAgICAgJ21vdXNldXAnLCB0aGlzLm9ubW91c2V1cC5iaW5kKHRoaXMpXG4gICAgICAgICAgICApXG5cbiAgICAgICAgICAgIHRoaXMudHYuJGVsLmFkZEV2ZW50TGlzdGVuZXIoXG4gICAgICAgICAgICAgICAgJ21vdXNlbGVhdmUnLCB0aGlzLm9ubW91c2VsZWF2ZS5iaW5kKHRoaXMpXG4gICAgICAgICAgICApXG5cbiAgICAgICAgICAgIHRoaXMucGxhY2Vfc3BsaXR0ZXJzKClcbiAgICAgICAgICAgIHRoaXMuY2FsY19oZWlnaHRzKClcblxuICAgICAgICAgICAgLy8gVHJhY2sgY2hhbmdlcyBvZiBncmlkcyBjb3VudFxuICAgICAgICAgICAgdGhpcy50di4kd2F0Y2goeCA9PlxuICAgICAgICAgICAgICAgIHRoaXMuZGMuZ2V0KCcuJykubWFwKHggPT4geC5pZCksXG4gICAgICAgICAgICAgICAgdGhpcy5vbmdyaWRzLmJpbmQodGhpcykpXG5cbiAgICAgICAgfSlcblxuICAgIH1cblxuICAgIC8vIExpc3RlbnMgdG8gYWxsIHR2anMgZXZlbnRzLCBjcmVhdGVzIG5ldyB3aWRnZXRzXG4gICAgdXBkYXRlKGUpIHtcbiAgICAgICAgc3dpdGNoKGUuZXZlbnQpIHtcblxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gRXh0ZW5zaW9uIHNldHRpbmdzIGhhcyBjaGFuZ2VkXG4gICAgb25zZXR0aW5ncyhzZXR0KSB7fVxuXG4gICAgb25ncmlkcygpIHtcbiAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLnJlbW92ZV93aWRnZXRzKClcbiAgICAgICAgICAgIHRoaXMucGxhY2Vfc3BsaXR0ZXJzKClcbiAgICAgICAgfSlcbiAgICB9XG5cbiAgICBvbm1vdXNlbW92ZShlKSB7XG4gICAgICAgIC8vIExpc3Qgb2Ygd2lkZ2V0cyBjcmVhdGVkIGJ5IHRoaXMgY29udHJvbGxlclxuICAgICAgICBsZXQgbGlzdCA9IHRoaXMudHYuJHJlZnMud2lkZ2V0cy4kY2hpbGRyZW5cbiAgICAgICAgICAgIC5maWx0ZXIoeCA9PiB4Lm1haW4gPT09IHRoaXMpXG5cbiAgICAgICAgZm9yICh2YXIgcyBvZiBsaXN0KSB7XG4gICAgICAgICAgICBzLmhzX21vdXNlbW92ZShlKVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgb25tb3VzZXVwKGUpIHtcbiAgICAgICAgLy8gTGlzdCBvZiB3aWRnZXRzIGNyZWF0ZWQgYnkgdGhpcyBjb250cm9sbGVyXG4gICAgICAgIGxldCBsaXN0ID0gdGhpcy50di4kcmVmcy53aWRnZXRzLiRjaGlsZHJlblxuICAgICAgICAgICAgLmZpbHRlcih4ID0+IHgubWFpbiA9PT0gdGhpcylcblxuICAgICAgICBmb3IgKHZhciBzIG9mIGxpc3QpIHtcbiAgICAgICAgICAgIHMuaHNfbW91c2V1cChlKVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgb25tb3VzZWxlYXZlKGUpIHtcbiAgICAgICAgLy8gTGlzdCBvZiB3aWRnZXRzIGNyZWF0ZWQgYnkgdGhpcyBjb250cm9sbGVyXG4gICAgICAgIGxldCBsaXN0ID0gdGhpcy50di4kcmVmcy53aWRnZXRzLiRjaGlsZHJlblxuICAgICAgICAgICAgLmZpbHRlcih4ID0+IHgubWFpbiA9PT0gdGhpcylcblxuICAgICAgICBmb3IgKHZhciBzIG9mIGxpc3QpIHtcbiAgICAgICAgICAgIHMuaHNfbW91c2VsZWF2ZShlKVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgcGxhY2Vfc3BsaXR0ZXJzKCkge1xuICAgICAgICBsZXQgZ3JpZHMgPSB0aGlzLnR2LiRyZWZzLmNoYXJ0Ll9sYXlvdXQuZ3JpZHNcbiAgICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPCBncmlkcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgbGV0IGcxID0gZ3JpZHNbaS0xXVxuICAgICAgICAgICAgbGV0IGcyID0gZ3JpZHNbaV1cbiAgICAgICAgICAgIGxldCBpZCA9IGBTcGxpdHRlci0ke2cxLmlkfS0ke2cyLmlkfS0ke1V0aWxzLnV1aWQyKCl9YFxuICAgICAgICAgICAgVnVlLnNldCh0aGlzLndpZGdldHMsIGlkLCB7XG4gICAgICAgICAgICAgICAgaWQ6IGlkLFxuICAgICAgICAgICAgICAgIGNsczogU3BsaXR0ZXIsXG4gICAgICAgICAgICAgICAgZGF0YToge1xuICAgICAgICAgICAgICAgICAgICBncmlkMTogZzEsXG4gICAgICAgICAgICAgICAgICAgIGdyaWQyOiBnMixcbiAgICAgICAgICAgICAgICAgICAgc2V0dDogdGhpcy5zZXR0XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSlcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGNhbGNfaGVpZ2h0cygpIHtcbiAgICAgICAgbGV0IGhzID0gW11cbiAgICAgICAgZm9yICh2YXIgZyBvZiB0aGlzLnR2LiRyZWZzLmNoYXJ0Ll9sYXlvdXQuZ3JpZHMpIHtcbiAgICAgICAgICAgIGhzLnB1c2goZy5oZWlnaHQpXG4gICAgICAgIH1cbiAgICAgICAgbGV0IHN1bSA9IGhzLnJlZHVjZSgoYSwgYikgPT4gYSArIGIsIDApXG4gICAgICAgIGhzID0gaHMubWFwKGggPT4gaCAvIHN1bSlcbiAgICAgICAgdGhpcy5ncmlkX292cygpLmZvckVhY2goKG92LCBpKSA9PiB7XG4gICAgICAgICAgICBpZiAoIW92LmdyaWQpIHtcbiAgICAgICAgICAgICAgICBWdWUuc2V0KG92LCAnZ3JpZCcsIHt9KVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgVnVlLnNldChvdi5ncmlkLCAnaGVpZ2h0JywgaHNbaV0gfHwgMSlcbiAgICAgICAgfSlcbiAgICB9XG5cbiAgICAvLyBHcmlkIGRlZmluaW5nIG92ZXJsYXlzXG4gICAgZ3JpZF9vdnMoKSB7XG4gICAgICAgIGxldCBsaXN0ID0gW3RoaXMuZGMuZGF0YS5jaGFydF1cbiAgICAgICAgZm9yICh2YXIgb3Ygb2YgdGhpcy5kYy5kYXRhLm9mZmNoYXJ0KSB7XG4gICAgICAgICAgICBpZiAoIW92LmdyaWQgfHwgb3YuZ3JpZC5pZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgbGlzdC5wdXNoKG92KVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBsaXN0XG4gICAgfVxuXG4gICAgcmVtb3ZlX3dpZGdldHMoKSB7XG4gICAgICAgIGZvciAodmFyIGlkIGluIHRoaXMud2lkZ2V0cykge1xuICAgICAgICAgICAgdGhpcy50di4kZGVsZXRlKHRoaXMud2lkZ2V0cywgaWQpXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBkZXN0cm95KCkge1xuICAgICAgICB0aGlzLnR2LiRlbC5yZW1vdmVFdmVudExpc3RlbmVyKFxuICAgICAgICAgICAgJ21vdXNlbW92ZScsIHRoaXMub25tb3VzZW1vdmVcbiAgICAgICAgKVxuICAgICAgICB0aGlzLnR2LiRlbC5yZW1vdmVFdmVudExpc3RlbmVyKFxuICAgICAgICAgICAgJ21vdXNldXAnLCB0aGlzLm1vdXNldXBcbiAgICAgICAgKVxuICAgICAgICB0aGlzLnR2LiRlbC5yZW1vdmVFdmVudExpc3RlbmVyKFxuICAgICAgICAgICAgJ21vdXNlbGVhdmUnLCB0aGlzLm1vdXNlbGVhdmVcbiAgICAgICAgKVxuICAgIH1cblxufVxuIiwiZXhwb3J0IGRlZmF1bHQge1xyXG5cclxuICAgIGFkZF9zdHlsZShpZCwgc3R5bGUpIHtcclxuXHJcbiAgICAgICAgdmFyIHN0YnIgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChpZClcclxuICAgICAgICBpZiAoc3Ricikge1xyXG4gICAgICAgICAgICB2YXIgc2hlZXRQYXJlbnQgPSBzdGJyLnBhcmVudE5vZGVcclxuICAgICAgICAgICAgc2hlZXRQYXJlbnQucmVtb3ZlQ2hpbGQoc3RicilcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHZhciBzaGVldCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3N0eWxlJylcclxuICAgICAgICBzaGVldC5zZXRBdHRyaWJ1dGUoXCJpZFwiLCBpZClcclxuICAgICAgICBzaGVldC5pbm5lckhUTUwgPSBzdHlsZVxyXG4gICAgICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQoc2hlZXQpXHJcbiAgICB9LFxyXG5cclxuICAgIHJlbV9zdHlsZShpZCwgc3R5bGUpIHtcclxuICAgICAgICB2YXIgc3RiciA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKGlkKVxyXG4gICAgICAgIGlmIChzdGJyKSB7XHJcbiAgICAgICAgICAgIHZhciBzaGVldFBhcmVudCA9IHN0YnIucGFyZW50Tm9kZVxyXG4gICAgICAgICAgICBzaGVldFBhcmVudC5yZW1vdmVDaGlsZChzdGJyKVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbn1cclxuIiwiXHJcbi8vIEV4dGVuc2lvbidzIGNvbnRyb2xsZXJcclxuXHJcbmltcG9ydCB7IFV0aWxzIH0gZnJvbSAndHJhZGluZy12dWUtanMnXHJcbmltcG9ydCBWdWUgZnJvbSAndnVlJ1xyXG5pbXBvcnQgQWRkV2luIGZyb20gJy4vQWRkV2luLnZ1ZSdcclxuXHJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIE1haW4ge1xyXG5cclxuICAgIGNvbnN0cnVjdG9yKHR2LCBkYywgc2V0dCkge1xyXG5cclxuICAgICAgICB0aGlzLndpZGdldHMgPSB7fVxyXG4gICAgICAgIHRoaXMudHYgPSB0dlxyXG4gICAgICAgIHRoaXMuZGMgPSBkY1xyXG4gICAgICAgIHRoaXMuc2V0dCA9IHNldHRcclxuXHJcbiAgICB9XHJcblxyXG4gICAgLy8gTGlzdGVucyB0byBhbGwgdHZqcyBldmVudHMsIGNyZWF0ZXMgbmV3IHdpZGdldHNcclxuICAgIHVwZGF0ZShlKSB7XHJcbiAgICAgICAgc3dpdGNoKGUuZXZlbnQpIHtcclxuICAgICAgICAgICAgY2FzZSAnbGVnZW5kLWJ1dHRvbi1jbGljayc6XHJcbiAgICAgICAgICAgICAgICB0aGlzLm9uYnV0dG9uKGUuYXJnc1swXSlcclxuICAgICAgICAgICAgYnJlYWtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgb25idXR0b24oZSkge1xyXG4gICAgICAgIGxldCBvdiA9IHRoaXMuZGMuZ2V0KGUudHlwZSlbZS5kYXRhSW5kZXhdXHJcbiAgICAgICAgbGV0IG9uY2hhcnQgPSB0aGlzLmRjLmRhdGEub25jaGFydFxyXG4gICAgICAgIGxldCBvZmZjaGFydCA9IHRoaXMuZGMuZGF0YS5vZmZjaGFydFxyXG4gICAgICAgIGlmICghb3YpIHJldHVyblxyXG4gICAgICAgIHN3aXRjaChlLmJ1dHRvbikge1xyXG4gICAgICAgICAgICBjYXNlICdkaXNwbGF5JzpcclxuICAgICAgICAgICAgICAgIGlmIChvdi5zZXR0aW5ncy5kaXNwbGF5ID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgZmxhZyA9IGZhbHNlXHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIGZsYWcgPSAhb3Yuc2V0dGluZ3MuZGlzcGxheVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgdGhpcy50di4kc2V0KG92LnNldHRpbmdzLCAnZGlzcGxheScsIGZsYWcpXHJcbiAgICAgICAgICAgICAgICBicmVha1xyXG4gICAgICAgICAgICBjYXNlICd1cCc6XHJcbiAgICAgICAgICAgICAgICBpZiAoZS50eXBlID09PSAnb2ZmY2hhcnQnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGUuZGF0YUluZGV4ID09PSAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG9mZmNoYXJ0LnNwbGljZShlLmRhdGFJbmRleCwgMSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgb25jaGFydC5wdXNoKG92KVxyXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBkYXRhID0gb2ZmY2hhcnRcclxuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGkwID0gZS5kYXRhSW5kZXhcclxuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGkxID0gZS5kYXRhSW5kZXgtMVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRhW2kwXSA9IGRhdGEuc3BsaWNlKGkxLCAxLCBkYXRhW2kwXSlbMF1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB0aGlzLmRjLnVwZGF0ZV9pZHMoKVxyXG4gICAgICAgICAgICAgICAgYnJlYWtcclxuICAgICAgICAgICAgY2FzZSAnZG93bic6XHJcbiAgICAgICAgICAgICAgICBpZiAoZS50eXBlID09PSAnb25jaGFydCcpIHtcclxuICAgICAgICAgICAgICAgICAgICBsZXQgaCA9IHRoaXMuYXZnX2dyaWRfaChvZmZjaGFydClcclxuICAgICAgICAgICAgICAgICAgICBvbmNoYXJ0LnNwbGljZShlLmRhdGFJbmRleCwgMSlcclxuICAgICAgICAgICAgICAgICAgICBvZmZjaGFydC51bnNoaWZ0KG92KVxyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMudHYuJHNldChvdiwgJ2dyaWQnLCB7aGVpZ2h0OiBofSlcclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbGV0IG4gPSBvZmZjaGFydC5sZW5ndGhcclxuICAgICAgICAgICAgICAgICAgICBsZXQgZGF0YSA9IG9mZmNoYXJ0XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGUuZGF0YUluZGV4IDwgbiAtIDEpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGkwID0gZS5kYXRhSW5kZXhcclxuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGkxID0gZS5kYXRhSW5kZXgrMVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRhW2kwXSA9IGRhdGEuc3BsaWNlKGkxLCAxLCBkYXRhW2kwXSlbMF1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB0aGlzLmRjLnVwZGF0ZV9pZHMoKVxyXG4gICAgICAgICAgICAgICAgYnJlYWtcclxuICAgICAgICAgICAgY2FzZSAnYWRkJzpcclxuICAgICAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbGV0IGlkID0gYEFkZFdpbi0ke1V0aWxzLnV1aWQyKCl9YFxyXG4gICAgICAgICAgICAgICAgICAgIGxldCBvdiA9IHRoaXMuZGMuZGF0YVtlLnR5cGVdW2UuZGF0YUluZGV4XVxyXG4gICAgICAgICAgICAgICAgICAgIGxldCBmID0gT2JqZWN0LnZhbHVlcyh0aGlzLndpZGdldHMpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC5maW5kKHggPT4geC5kYXRhLm92ID09PSBvdilcclxuICAgICAgICAgICAgICAgICAgICBpZihmKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMudHYuJGRlbGV0ZSh0aGlzLndpZGdldHMsIGYuaWQpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrXHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMudHYuJHNldCh0aGlzLndpZGdldHMsIGlkLCB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlkLCBjbHM6IEFkZFdpbiwgZGF0YToge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb3Y6IG92LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogZS50eXBlLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5kZXg6IGUuZGF0YUluZGV4XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICAgICAgfSBjYXRjaChlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coZSlcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGJyZWFrXHJcbiAgICAgICAgICAgIGNhc2UgJ3JlbW92ZSc6XHJcbiAgICAgICAgICAgICAgICB0aGlzLmRjLmRhdGFbZS50eXBlXS5zcGxpY2UoZS5kYXRhSW5kZXgsIDEpXHJcbiAgICAgICAgICAgICAgICB0aGlzLmRjLnVwZGF0ZV9pZHMoKVxyXG4gICAgICAgICAgICAgICAgYnJlYWtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLy8gQ2FsbGVkIGZyb20gQWRkV2luLnZ1ZVxyXG4gICAgYWRkX292ZXJsYXkoZSkge1xyXG4gICAgICAgIGxldCBwcmVzZXQgPSB0aGlzLmdldF9wcmVzZXQoZS50eXBlKSB8fCB7fVxyXG4gICAgICAgIGlmIChwcmVzZXQuc2lkZSkgZS5zaWRlID0gcHJlc2V0LnNpZGVcclxuICAgICAgICBsZXQgb25jaGFydCA9IHRoaXMuZGMuZGF0YS5vbmNoYXJ0XHJcbiAgICAgICAgbGV0IG9mZmNoYXJ0ID0gdGhpcy5kYy5kYXRhLm9mZmNoYXJ0XHJcbiAgICAgICAgaWYgKGUuc2lkZSA9PT0gJ29uY2hhcnQnKSB7XHJcbiAgICAgICAgICAgIG9uY2hhcnQuc3BsaWNlKGUuaW5kZXgrMSwgMCwge1xyXG4gICAgICAgICAgICAgICAgbmFtZTogcHJlc2V0Lm5hbWUsXHJcbiAgICAgICAgICAgICAgICB0eXBlOiBlLnR5cGUsXHJcbiAgICAgICAgICAgICAgICBkYXRhOiBbXSxcclxuICAgICAgICAgICAgICAgIHNldHRpbmdzOiBwcmVzZXQuc2V0dGluZ3MgfHwge31cclxuICAgICAgICAgICAgfSlcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBsZXQgaCA9IHRoaXMuYXZnX2dyaWRfaChvZmZjaGFydClcclxuICAgICAgICAgICAgb2ZmY2hhcnQuc3BsaWNlKGUuaW5kZXgrMSwgMCwge1xyXG4gICAgICAgICAgICAgICAgbmFtZTogcHJlc2V0Lm5hbWUsXHJcbiAgICAgICAgICAgICAgICB0eXBlOiBlLnR5cGUsXHJcbiAgICAgICAgICAgICAgICBkYXRhOiBbXSxcclxuICAgICAgICAgICAgICAgIHNldHRpbmdzOiBwcmVzZXQuc2V0dGluZ3MgfHwge30sXHJcbiAgICAgICAgICAgICAgICBncmlkOiB7aGVpZ2h0OiBofVxyXG4gICAgICAgICAgICB9KVxyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLmRjLnVwZGF0ZV9pZHMoKVxyXG4gICAgfVxyXG5cclxuICAgIC8vIEdldCBwcmVzZXQgKGRlZmF1bHQgc2V0dGluZ3MsIGNvbG9ycykgaWYgZGVmaW5lZFxyXG4gICAgZ2V0X3ByZXNldCh0eXBlKSB7XHJcbiAgICAgICAgbGV0IHByb3RvID0gdGhpcy50di5vdmVybGF5cy5maW5kKHggPT4geC5uYW1lID09PSB0eXBlKVxyXG4gICAgICAgIGlmIChwcm90byAmJiBwcm90by5tZXRob2RzLm1ldGFfaW5mbykge1xyXG4gICAgICAgICAgICBsZXQgbWV0YSA9IHByb3RvLm1ldGhvZHMubWV0YV9pbmZvKClcclxuICAgICAgICAgICAgcmV0dXJuIG1ldGEucHJlc2V0XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8vIEV4dGVuc2lvbiBzZXR0aW5ncyBoYXMgY2hhbmdlZFxyXG4gICAgb25zZXR0aW5ncyhzZXR0KSB7fVxyXG5cclxuICAgIGF2Z19ncmlkX2gob3ZzKSB7XHJcbiAgICAgICAgaWYgKCFvdnMubGVuZ3RoKSByZXR1cm4gMC4yNVxyXG4gICAgICAgIGxldCBnaCA9IDBcclxuICAgICAgICBmb3IgKHZhciBvdiBvZiBvdnMpIHtcclxuICAgICAgICAgICAgaWYgKG92LmdyaWQgJiYgdHlwZW9mIG92LmdyaWQuaGVpZ2h0ID09PSAnbnVtYmVyJykge1xyXG4gICAgICAgICAgICAgICAgZ2ggKz0gb3YuZ3JpZC5oZWlnaHRcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gZ2ggLyBvdnMubGVuZ3RoXHJcbiAgICB9XHJcblxyXG4gICAgcmVtb3ZlX3dpZGdldChpZCkge1xyXG4gICAgICAgIHRoaXMudHYuJGRlbGV0ZSh0aGlzLndpZGdldHMsIGlkKVxyXG4gICAgfVxyXG5cclxuICAgIGRlc3Ryb3koKSB7XHJcblxyXG4gICAgfVxyXG5cclxufVxyXG4iLCJcclxuLy8gRXh0ZW5zaW9uJ3MgY29udHJvbGxlclxyXG5cclxuaW1wb3J0IHsgVXRpbHMgfSBmcm9tICd0cmFkaW5nLXZ1ZS1qcydcclxuaW1wb3J0IFNldHRpbmdzV2luIGZyb20gJy4vU2V0dGluZ3NXaW4udnVlJ1xyXG5pbXBvcnQgVnVlIGZyb20gJ3Z1ZSdcclxuXHJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIE1haW4ge1xyXG5cclxuICAgIGNvbnN0cnVjdG9yKHR2LCBkYykge1xyXG4gICAgICAgIHRoaXMud2lkZ2V0cyA9IHt9XHJcbiAgICAgICAgdGhpcy50diA9IHR2XHJcbiAgICAgICAgdGhpcy5kYyA9IGRjXHJcbiAgICB9XHJcblxyXG4gICAgLy8gTGlzdGVucyB0byBhbGwgdHZqcyBldmVudHMsIGNyZWF0ZXMgbmV3IHdpZGdldHNcclxuICAgIHVwZGF0ZShlKSB7XHJcbiAgICAgICAgc3dpdGNoKGUuZXZlbnQpIHtcclxuICAgICAgICAgICAgY2FzZSAnbGVnZW5kLWJ1dHRvbi1jbGljayc6XHJcbiAgICAgICAgICAgICAgICBsZXQgaWQgPSBgU2V0dGluZ3NXaW4tJHtVdGlscy51dWlkMigpfWBcclxuICAgICAgICAgICAgICAgIGxldCBhcmdzID0gZS5hcmdzWzBdXHJcbiAgICAgICAgICAgICAgICBpZiAoYXJncy5idXR0b24gIT09ICdzZXR0aW5ncycpIGJyZWFrXHJcbiAgICAgICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgICAgIGxldCBvdiA9IHRoaXMuZGMuZGF0YVthcmdzLnR5cGVdW2FyZ3MuZGF0YUluZGV4XVxyXG4gICAgICAgICAgICAgICAgICAgIGxldCBmID0gT2JqZWN0LnZhbHVlcyh0aGlzLndpZGdldHMpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC5maW5kKHggPT4geC5kYXRhLm92ID09PSBvdilcclxuICAgICAgICAgICAgICAgICAgICBpZihmKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMudHYuJGRlbGV0ZSh0aGlzLndpZGdldHMsIGYuaWQpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrXHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMudHYuJHNldCh0aGlzLndpZGdldHMsIGlkLCB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlkLCBjbHM6IFNldHRpbmdzV2luLCBkYXRhOiB7IG92OiBvdiB9XHJcbiAgICAgICAgICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgICAgIH0gY2F0Y2goZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKGUpXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBicmVha1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICByZW1vdmVfd2lkZ2V0KGlkKSB7XHJcbiAgICAgICAgdGhpcy50di4kZGVsZXRlKHRoaXMud2lkZ2V0cywgaWQpXHJcbiAgICB9XHJcblxyXG59XHJcbiIsIlxyXG5leHBvcnQgZGVmYXVsdCB7XHJcblxyXG4gICAgc2V0dDJkZXNjKHNldHQpIHtcclxuICAgICAgICBmdW5jdGlvbiBzZXRDaGFyQXQoc3RyLGluZGV4LGNocikge1xyXG4gICAgICAgICAgICBpZihpbmRleCA+IHN0ci5sZW5ndGgtMSkgcmV0dXJuIHN0clxyXG4gICAgICAgICAgICByZXR1cm4gc3RyLnN1YnN0cmluZygwLGluZGV4KSArIGNociArIHN0ci5zdWJzdHJpbmcoaW5kZXgrMSlcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHNldHQgPSBzZXR0LnJlcGxhY2UoLyhbXkEtWl0pKFtBLVpdKS9nLCAnJDEgJDInKVxyXG4gICAgICAgIHNldHQgPSBzZXR0LnJlcGxhY2UoLy18Xy9nLCAnICcpXHJcbiAgICAgICAgbGV0IHR1cGxlID0gc2V0dC5zcGxpdCgnICcpXHJcbiAgICAgICAgdHVwbGUgPSB0dXBsZVxyXG4gICAgICAgICAgICAuZmlsdGVyKHggPT4geC5sZW5ndGgpXHJcbiAgICAgICAgICAgIC5tYXAoeCA9PiBzZXRDaGFyQXQoeCwgMCwgeFswXS50b1VwcGVyQ2FzZSgpKSlcclxuICAgICAgICByZXR1cm4gdHVwbGUuam9pbignICcpXHJcbiAgICB9XHJcbiAgICBcclxufVxyXG4iLCJcblxuLy8gLS0tLS0tLS0gRGV2ZWxvcG1lbnQgZXh0ZW5zaW9uIGluZGV4IC0tLS0tLS0tLVxuLy8gICAgICAhIFRISVMgRklMRSBXQVMgQVVUTy1HRU5FUkFURUQgIVxuLy9cbi8vIFlvdSBjYW4gb3ZlcndyaXRlIGl0IGFuZCBoYXZlIGZ1biwgdG8gcmVzdG9yZVxuLy8gdGhlIGRlZmF1bHQgc3RhdGU6ICducG0gcnVuIGNvbXBpbGUnXG5cbmltcG9ydCBDaGFydExpbmsgZnJvbSAnLi4vYnVpbGQvY2hhcnQtbGluay9jaGFydC1saW5rLWRldi5qcydcbmltcG9ydCBHcmlkUmVzaXplIGZyb20gJy4uL2J1aWxkL2dyaWQtcmVzaXplL2dyaWQtcmVzaXplLWRldi5qcydcbmltcG9ydCBMZWdlbmRCdXR0b25zIGZyb20gJy4uL2J1aWxkL2xlZ2VuZC1idXR0b25zL2xlZ2VuZC1idXR0b25zLWRldi5qcydcbmltcG9ydCBTZXR0aW5nc1dpbiBmcm9tICcuLi9idWlsZC9zZXR0aW5ncy13aW4vc2V0dGluZ3Mtd2luLWRldi5qcydcblxuXG5cbmNvbnN0IFBhY2sgPSB7XG4gICAgJ2NoYXJ0LWxpbmsnOiBDaGFydExpbmssXG4gICAgJ2dyaWQtcmVzaXplJzogR3JpZFJlc2l6ZSxcbiAgICAnbGVnZW5kLWJ1dHRvbnMnOiBMZWdlbmRCdXR0b25zLFxuICAgICdzZXR0aW5ncy13aW4nOiBTZXR0aW5nc1dpblxufVxuXG5leHBvcnQgZGVmYXVsdCBQYWNrXG5cbmV4cG9ydCB7XG4gICAgXG59IiwiaW1wb3J0IFZ1ZSBmcm9tICd2dWUnXG5pbXBvcnQgQXBwIGZyb20gJy4vTWFpbi52dWUnXG5cbm5ldyBWdWUoe1xuICAgIGVsOiAnI2FwcCcsXG4gICAgcmVuZGVyOiBoID0+IGgoQXBwKVxufSlcbiIsImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIFN0cmVhbSh1cmwpIHtcclxuXHJcbiAgICB2YXIgd3MgPSBuZXcgV2ViU29ja2V0KHVybClcclxuICAgIHZhciBjYiA9ICgpID0+IHt9XHJcblxyXG5cclxuICAgIHdzLm9ub3BlbiA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIGNvbnNvbGUubG9nKCdXZWJzb2NrZXQgaXMgb3BlbmVkJylcclxuICAgIH1cclxuXHJcbiAgICB3cy5vbm1lc3NhZ2UgPSBmdW5jdGlvbihkYXRhKSB7XHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgZGF0YSA9IEpTT04ucGFyc2UoZGF0YS5kYXRhKVxyXG4gICAgICAgICAgICBjYihkYXRhKVxyXG4gICAgICAgIH0gY2F0Y2goZSkge1xyXG4gICAgICAgICAgICBjb25zb2xlLmxvZyhlKVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIHNldCBvbnRyYWRlcyh2YWwpIHsgY2IgPSB2YWwgfSxcclxuICAgICAgICBvZmYoKSB7IHdzLmNsb3NlKDEwMDApIH1cclxuICAgIH1cclxufVxyXG4iLCJcclxuY29uc3QgU0VDT05EID0gMTAwMFxyXG5jb25zdCBNSU5VVEUgPSBTRUNPTkQgKiA2MFxyXG5jb25zdCBNSU5VVEUzID0gTUlOVVRFICogM1xyXG5jb25zdCBNSU5VVEU1ID0gTUlOVVRFICogNVxyXG5jb25zdCBNSU5VVEUxNSA9IE1JTlVURSAqIDE1XHJcbmNvbnN0IE1JTlVURTMwID0gTUlOVVRFICogMzBcclxuY29uc3QgSE9VUiA9IE1JTlVURSAqIDYwXHJcbmNvbnN0IEhPVVI0ID0gSE9VUiAqIDRcclxuY29uc3QgSE9VUjEyID0gSE9VUiAqIDEyXHJcbmNvbnN0IERBWSA9IEhPVVIgKiAyNFxyXG5jb25zdCBXRUVLID0gREFZICogN1xyXG5jb25zdCBNT05USCA9IFdFRUsgKiA0XHJcbmNvbnN0IFlFQVIgPSBEQVkgKiAzNjVcclxuXHJcbmNvbnN0IE1PTlRITUFQID0gW1xyXG4gICAgXCJKYW5cIiwgXCJGZWJcIiwgXCJNYXJcIiwgXCJBcHJcIixcclxuICAgIFwiTWF5XCIsIFwiSnVuXCIsXCJKdWxcIiwgXCJBdWdcIixcclxuICAgIFwiU2VwXCIsIFwiT2N0XCIsXCJOb3ZcIiwgXCJEZWNcIlxyXG5dXHJcblxyXG4vLyBHcmlkIHRpbWUgc3RlcHNcclxuY29uc3QgVElNRVNDQUxFUyA9IFtcclxuICAgIFlFQVIgKiAxMCwgWUVBUiAqIDUsIFlFQVIgKiAzLCBZRUFSICogMiwgWUVBUixcclxuICAgIE1PTlRIICogNiwgTU9OVEggKiA0LCBNT05USCAqIDMsIE1PTlRIICogMiwgTU9OVEgsXHJcbiAgICBEQVkgKiAxNSwgREFZICogMTAsIERBWSAqIDcsIERBWSAqIDUsIERBWSAqIDMsIERBWSAqIDIsIERBWSxcclxuICAgIEhPVVIgKiAxMiwgSE9VUiAqIDYsIEhPVVIgKiAzLCBIT1VSICogMS41LCBIT1VSLFxyXG4gICAgTUlOVVRFMzAsIE1JTlVURTE1LCBNSU5VVEUgKiAxMCwgTUlOVVRFNSwgTUlOVVRFICogMiwgTUlOVVRFXHJcbl1cclxuXHJcbi8vIEdyaWQgJCBzdGVwc1xyXG5jb25zdCAkU0NBTEVTID0gWzAuMDUsIDAuMSwgMC4yLCAwLjI1LCAwLjUsIDAuOCwgMSwgMiwgNV1cclxuXHJcbmNvbnN0IENoYXJ0Q29uZmlnID0ge1xyXG4gICAgU0JNSU46IDYwLCAgICAgICAvLyBNaW5pbWFsIHNpZGViYXIgcHhcclxuICAgIFNCTUFYOiBJbmZpbml0eSwgLy8gTWF4IHNpZGViYXIsIHB4XHJcbiAgICBUT09MQkFSOiA1NywgICAgIC8vIFRvb2xiYXIgd2lkdGggcHhcclxuICAgIFRCX0lDT046IDI1LCAgICAgLy8gVG9vbGJhciBpY29uIHNpemUgcHhcclxuICAgIFRCX0lURU1fTTogNiwgICAgLy8gVG9vbGJhciBpdGVtIG1hcmdpbiBweFxyXG4gICAgVEJfSUNPTl9CUkk6IDEsICAvLyBUb29sYmFyIGljb24gYnJpZ2h0bmVzc1xyXG4gICAgVEJfSUNPTl9IT0xEOiA0MjAsIC8vIG1zLCB3YWl0IHRvIGV4cGFuZFxyXG4gICAgVEJfQk9SREVSOiAxLCAgICAvLyBUb29sYmFyIGJvcmRlciBweFxyXG4gICAgVEJfQl9TVFlMRTogJ2RvdHRlZCcsIC8vIFRvb2xiYXIgYm9yZGVyIHN0eWxlXHJcbiAgICBUT09MX0NPTEw6IDcsICAgIC8vIFRvb2wgY29sbGlzaW9uIHRocmVzaG9sZFxyXG4gICAgRVhQQU5EOiAwLjE1LCAgICAvLyAlLzEwMCBvZiByYW5nZVxyXG4gICAgQ0FORExFVzogMC42LCAgICAvLyAlLzEwMCBvZiBzdGVwXHJcbiAgICBHUklEWDogMTAwLCAgICAgIC8vIHB4XHJcbiAgICBHUklEWTogNDcsICAgICAgIC8vIHB4XHJcbiAgICBCT1RCQVI6IDI4LCAgICAgIC8vIHB4XHJcbiAgICBQQU5IRUlHSFQ6IDIyLCAgIC8vIHB4XHJcbiAgICBERUZBVUxUX0xFTjogNTAsIC8vIGNhbmRsZXNcclxuICAgIE1JTklNVU1fTEVOOiA1LCAgLy8gY2FuZGxlcyxcclxuICAgIE1JTl9aT09NOiAyNSwgICAgLy8gY2FuZGxlc1xyXG4gICAgTUFYX1pPT006IDEwMDAsICAvLyBjYW5kbGVzLFxyXG4gICAgVk9MU0NBTEU6IDAuMTUsICAvLyAlLzEwMCBvZiBoZWlnaHRcclxuICAgIFVYX09QQUNJVFk6IDAuOSwgLy8gVXggYmFja2dyb3VuZCBvcGFjaXR5XHJcbiAgICBaT09NX01PREU6ICd0dicsIC8vICd0dicgb3IgJ3RsJ1xyXG4gICAgTF9CVE5fU0laRTogMjEsICAvLyBMZWdlbmQgQnV0dG9uIHNpemUsIHB4XHJcbiAgICBMX0JUTl9NQVJHSU46ICctNnB4IDAgLTZweCAwJywgLy8gY3NzIG1hcmdpblxyXG4gICAgU0NST0xMX1dIRUVMOiAncHJldmVudCcsIC8vICdwYXNzJywgJ2NsaWNrJ1xyXG59XHJcblxyXG5DaGFydENvbmZpZy5GT05UID1cclxuICAgIGAxMXB4IC1hcHBsZS1zeXN0ZW0sQmxpbmtNYWNTeXN0ZW1Gb250LFxyXG4gICAgU2Vnb2UgVUksUm9ib3RvLE94eWdlbixVYnVudHUsQ2FudGFyZWxsLFxyXG4gICAgRmlyYSBTYW5zLERyb2lkIFNhbnMsSGVsdmV0aWNhIE5ldWUsXHJcbiAgICBzYW5zLXNlcmlmYFxyXG5cclxuY29uc3QgSUJfVEZfV0FSTiA9XHJcbiAgICBgV2hlbiB1c2luZyBJQiBtb2RlIHlvdSBzaG91bGQgc3BlY2lmeSBgICtcclxuICAgIGB0aW1lZnJhbWUgKCd0ZicgZmlsZWQgaW4gJ2NoYXJ0JyBvYmplY3QpLGAgK1xyXG4gICAgYG90aGVyd2lzZSB5b3UgY2FuIGdldCBhbiB1bmV4cGVjdGVkIGJlaGF2aW91cmBcclxuXHJcbmNvbnN0IE1BUF9VTklUID0ge1xyXG4gIFwiMXNcIjogU0VDT05ELFxyXG4gIFwiNXNcIjogU0VDT05EICogNSxcclxuICBcIjEwc1wiOiBTRUNPTkQgKiAxMCxcclxuICBcIjIwc1wiOiBTRUNPTkQgKiAyMCxcclxuICBcIjMwc1wiOiBTRUNPTkQgKiAzMCxcclxuICBcIjFtXCI6IE1JTlVURSxcclxuICBcIjNtXCI6IE1JTlVURTMsXHJcbiAgXCI1bVwiOiBNSU5VVEU1LFxyXG4gIFwiMTVtXCI6IE1JTlVURTE1LFxyXG4gIFwiMzBtXCI6IE1JTlVURTMwLFxyXG4gIFwiMUhcIjogSE9VUixcclxuICBcIjJIXCI6IEhPVVIgKiAyLFxyXG4gIFwiM0hcIjogSE9VUiAqIDMsXHJcbiAgXCI0SFwiOiBIT1VSNCxcclxuICBcIjEySFwiOiBIT1VSMTIsXHJcbiAgXCIxRFwiOiBEQVksXHJcbiAgXCIxV1wiOiBXRUVLLFxyXG4gIFwiMU1cIjogTU9OVEgsXHJcbiAgXCIxWVwiOiBZRUFSXHJcbn1cclxuXHJcbmV4cG9ydCBkZWZhdWx0IHtcclxuICAgIFNFQ09ORDogU0VDT05ELFxyXG4gICAgTUlOVVRFOiBNSU5VVEUsXHJcbiAgICBNSU5VVEU1OiBNSU5VVEU1LFxyXG4gICAgTUlOVVRFMTU6IE1JTlVURTE1LFxyXG4gICAgTUlOVVRFMzA6IE1JTlVURTMwLFxyXG4gICAgSE9VUjogSE9VUixcclxuICAgIEhPVVI0OiBIT1VSNCxcclxuICAgIERBWTogREFZLFxyXG4gICAgV0VFSzogV0VFSyxcclxuICAgIE1PTlRIOiBNT05USCxcclxuICAgIFlFQVI6IFlFQVIsXHJcbiAgICBNT05USE1BUDogTU9OVEhNQVAsXHJcbiAgICBUSU1FU0NBTEVTOiBUSU1FU0NBTEVTLFxyXG4gICAgJFNDQUxFUzogJFNDQUxFUyxcclxuICAgIENoYXJ0Q29uZmlnOiBDaGFydENvbmZpZyxcclxuICAgIG1hcF91bml0OiBNQVBfVU5JVCxcclxuICAgIElCX1RGX1dBUk5cclxufVxyXG4iLCJpbXBvcnQgSW5kZXhlZEFycmF5IGZyb20gJ2FycmF5c2xpY2VyJ1xyXG5pbXBvcnQgQ29uc3QgZnJvbSAnLi9jb25zdGFudHMuanMnXHJcblxyXG5leHBvcnQgZGVmYXVsdCB7XHJcblxyXG4gICAgbmFtZTJOYW1lKHNldHQpIHtcclxuICAgICAgICBmdW5jdGlvbiBzZXRDaGFyQXQoc3RyLGluZGV4LGNocikge1xyXG4gICAgICAgICAgICBpZihpbmRleCA+IHN0ci5sZW5ndGgtMSkgcmV0dXJuIHN0clxyXG4gICAgICAgICAgICByZXR1cm4gc3RyLnN1YnN0cmluZygwLGluZGV4KSArIGNociArIHN0ci5zdWJzdHJpbmcoaW5kZXgrMSlcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHNldHQgPSBzZXR0LnJlcGxhY2UoLyhbXkEtWl0pKFtBLVpdKS9nLCAnJDEgJDInKVxyXG4gICAgICAgIHNldHQgPSBzZXR0LnJlcGxhY2UoLy18Xy9nLCAnICcpXHJcbiAgICAgICAgbGV0IHR1cGxlID0gc2V0dC5zcGxpdCgnICcpXHJcbiAgICAgICAgdHVwbGUgPSB0dXBsZVxyXG4gICAgICAgICAgICAuZmlsdGVyKHggPT4geC5sZW5ndGgpXHJcbiAgICAgICAgICAgIC5tYXAoeCA9PiBzZXRDaGFyQXQoeCwgMCwgeFswXS50b1VwcGVyQ2FzZSgpKSlcclxuICAgICAgICByZXR1cm4gdHVwbGUuam9pbignJylcclxuICAgIH0sXHJcblxyXG4gICAgY2xhbXAobnVtLCBtaW4sIG1heCkge1xyXG4gICAgICAgIHJldHVybiBudW0gPD0gbWluID8gbWluIDogbnVtID49IG1heCA/IG1heCA6IG51bVxyXG4gICAgfSxcclxuXHJcbiAgICBhZGRfemVybyhpKSB7XHJcbiAgICAgICAgaWYgKGkgPCAxMCkge1xyXG4gICAgICAgICAgICBpID0gXCIwXCIgKyBpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gaVxyXG4gICAgfSxcclxuXHJcbiAgICAvLyBTdGFydCBvZiB0aGUgZGF5ICh6ZXJvIG1pbGxpc2Vjb25kKVxyXG4gICAgZGF5X3N0YXJ0KHQpIHtcclxuICAgICAgICBsZXQgc3RhcnQgPSBuZXcgRGF0ZSh0KVxyXG4gICAgICAgIHJldHVybiBzdGFydC5zZXRVVENIb3VycygwLDAsMCwwKVxyXG4gICAgfSxcclxuXHJcbiAgICAvLyBTdGFydCBvZiB0aGUgbW9udGhcclxuICAgIG1vbnRoX3N0YXJ0KHQpIHtcclxuICAgICAgICBsZXQgZGF0ZSA9IG5ldyBEYXRlKHQpXHJcbiAgICAgICAgcmV0dXJuIERhdGUuVVRDKFxyXG4gICAgICAgICAgICBkYXRlLmdldEZ1bGxZZWFyKCksXHJcbiAgICAgICAgICAgIGRhdGUuZ2V0TW9udGgoKSwgMVxyXG4gICAgICAgIClcclxuICAgIH0sXHJcblxyXG4gICAgLy8gU3RhcnQgb2YgdGhlIHllYXJcclxuICAgIHllYXJfc3RhcnQodCkge1xyXG4gICAgICAgIHJldHVybiBEYXRlLlVUQyhuZXcgRGF0ZSh0KS5nZXRGdWxsWWVhcigpKVxyXG4gICAgfSxcclxuXHJcbiAgICBnZXRfeWVhcih0KSB7XHJcbiAgICAgICAgaWYgKCF0KSByZXR1cm4gdW5kZWZpbmVkXHJcbiAgICAgICAgcmV0dXJuIG5ldyBEYXRlKHQpLmdldFVUQ0Z1bGxZZWFyKClcclxuICAgIH0sXHJcblxyXG4gICAgZ2V0X21vbnRoKHQpIHtcclxuICAgICAgICBpZiAoIXQpIHJldHVybiB1bmRlZmluZWRcclxuICAgICAgICByZXR1cm4gbmV3IERhdGUodCkuZ2V0VVRDTW9udGgoKVxyXG4gICAgfSxcclxuXHJcbiAgICAvLyBOZWFyZXN0IGluIGFycmF5XHJcbiAgICBuZWFyZXN0X2EoeCwgYXJyYXkpIHtcclxuICAgICAgICBsZXQgZGlzdCA9IEluZmluaXR5XHJcbiAgICAgICAgbGV0IHZhbCA9IG51bGxcclxuICAgICAgICBsZXQgaW5kZXggPSAtMVxyXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJyYXkubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgdmFyIHhpID0gYXJyYXlbaV1cclxuICAgICAgICAgICAgaWYgKE1hdGguYWJzKHhpIC0geCkgPCBkaXN0KSB7XHJcbiAgICAgICAgICAgICAgICBkaXN0ID0gTWF0aC5hYnMoeGkgLSB4KVxyXG4gICAgICAgICAgICAgICAgdmFsID0geGlcclxuICAgICAgICAgICAgICAgIGluZGV4ID0gaVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBbaW5kZXgsIHZhbF1cclxuICAgIH0sXHJcblxyXG4gICAgcm91bmQobnVtLCBkZWNpbWFscyA9IDgpIHtcclxuICAgICAgICByZXR1cm4gcGFyc2VGbG9hdChudW0udG9GaXhlZChkZWNpbWFscykpXHJcbiAgICB9LFxyXG5cclxuICAgIC8vIFN0cmlwPyBObywgaXQncyB1Z2x5IGZsb2F0cyBpbiBqc1xyXG4gICAgc3RyaXAobnVtYmVyKSB7XHJcbiAgICAgICAgcmV0dXJuIHBhcnNlRmxvYXQoXHJcbiAgICAgICAgICAgIHBhcnNlRmxvYXQobnVtYmVyKS50b1ByZWNpc2lvbigxMilcclxuICAgICAgICApXHJcbiAgICB9LFxyXG5cclxuICAgIGdldF9kYXkodCkge1xyXG4gICAgICAgIHJldHVybiB0ID8gbmV3IERhdGUodCkuZ2V0RGF0ZSgpIDogbnVsbFxyXG4gICAgfSxcclxuXHJcbiAgICAvLyBVcGRhdGUgYXJyYXkga2VlcGluZyB0aGUgc2FtZSByZWZlcmVuY2VcclxuICAgIG92ZXJ3cml0ZShhcnIsIG5ld19hcnIpIHtcclxuICAgICAgICBhcnIuc3BsaWNlKDAsIGFyci5sZW5ndGgsIC4uLm5ld19hcnIpXHJcbiAgICB9LFxyXG5cclxuICAgIC8vIENvcHkgbGF5b3V0IGluIHJlYWN0aXZlIHdheVxyXG4gICAgY29weV9sYXlvdXQob2JqLCBuZXdfb2JqKSB7XHJcbiAgICAgICAgZm9yICh2YXIgayBpbiBvYmopIHtcclxuICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkob2JqW2tdKSkge1xyXG4gICAgICAgICAgICAgICAgLy8gKHNvbWUgb2ZmY2hhcnQgaW5kaWNhdG9ycyBhcmUgYWRkZWQvcmVtb3ZlZClcclxuICAgICAgICAgICAgICAgIC8vIHdlIG5lZWQgdG8gdXBkYXRlIGxheW91dCBpbiBhIHJlYWN0aXZlIHdheVxyXG4gICAgICAgICAgICAgICAgaWYgKG9ialtrXS5sZW5ndGggIT09IG5ld19vYmpba10ubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5vdmVyd3JpdGUob2JqW2tdLCBuZXdfb2JqW2tdKVxyXG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBtIGluIG9ialtrXSkge1xyXG4gICAgICAgICAgICAgICAgICAgIE9iamVjdC5hc3NpZ24ob2JqW2tdW21dLCBuZXdfb2JqW2tdW21dKVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgT2JqZWN0LmFzc2lnbihvYmpba10sIG5ld19vYmpba10pXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9LFxyXG5cclxuICAgIC8vIERldGVjdHMgY2FuZGxlcyBpbnRlcnZhbFxyXG4gICAgZGV0ZWN0X2ludGVydmFsKG9obGN2KSB7XHJcbiAgICAgICAgbGV0IGxlbiA9IE1hdGgubWluKG9obGN2Lmxlbmd0aCAtIDEsIDk5KVxyXG4gICAgICAgIGxldCBtaW4gPSBJbmZpbml0eVxyXG4gICAgICAgIG9obGN2LnNsaWNlKDAsIGxlbikuZm9yRWFjaCgoeCwgaSkgPT4ge1xyXG4gICAgICAgICAgICBsZXQgZCA9IG9obGN2W2krMV1bMF0gLSB4WzBdXHJcbiAgICAgICAgICAgIGlmIChkID09PSBkICYmIGQgPCBtaW4pIG1pbiA9IGRcclxuICAgICAgICB9KVxyXG4gICAgICAgIC8vIFRoaXMgc2F2ZXMgbW9udGhseSBjaGFydCBmcm9tIGJlaW5nIGF3a3dhcmRcclxuICAgICAgICBpZiAobWluID49IENvbnN0Lk1PTlRIICYmIG1pbiA8PSBDb25zdC5EQVkgKiAzMCkge1xyXG4gICAgICAgICAgICByZXR1cm4gQ29uc3QuREFZICogMzFcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG1pblxyXG4gICAgfSxcclxuXHJcbiAgICAvLyBHZXRzIG51bWJlcmljIHBhcnQgb2Ygb3ZlcmxheSBpZCAoZS5nICdFTUFfMScgPSA+IDEpXHJcbiAgICBnZXRfbnVtX2lkKGlkKSB7XHJcbiAgICAgICAgcmV0dXJuIHBhcnNlSW50KGlkLnNwbGl0KCdfJykucG9wKCkpXHJcbiAgICB9LFxyXG5cclxuICAgIC8vIEZhc3QgZmlsdGVyLiBSZWFsbHkgZmFzdCwgbGlrZSAxMFhcclxuICAgIGZhc3RfZmlsdGVyKGFyciwgdDEsIHQyKSB7XHJcbiAgICAgICAgaWYgKCFhcnIubGVuZ3RoKSByZXR1cm4gW2FyciwgdW5kZWZpbmVkXVxyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgIGxldCBpYSA9IG5ldyBJbmRleGVkQXJyYXkoYXJyLCBcIjBcIilcclxuICAgICAgICAgICAgbGV0IHJlcyA9IGlhLmdldFJhbmdlKHQxLCB0MilcclxuICAgICAgICAgICAgbGV0IGkwID0gaWEudmFscG9zW3QxXS5uZXh0XHJcbiAgICAgICAgICAgIHJldHVybiBbcmVzLCBpMF1cclxuICAgICAgICB9IGNhdGNoKGUpIHtcclxuICAgICAgICAgICAgLy8gU29tZXRoaW5nIHdyb25nIHdpdGggZmFuY3kgc2xpY2UgbGliXHJcbiAgICAgICAgICAgIC8vIEZhc3QgZml4OiBmYWxsYmFjayB0byBmaWx0ZXJcclxuICAgICAgICAgICAgcmV0dXJuIFthcnIuZmlsdGVyKHggPT5cclxuICAgICAgICAgICAgICAgIHhbMF0gPj0gdDEgJiYgeFswXSA8PSB0MlxyXG4gICAgICAgICAgICApLCAwXVxyXG4gICAgICAgIH1cclxuICAgIH0sXHJcblxyXG4gICAgLy8gRmFzdCBmaWx0ZXIgKGluZGV4LWJhc2VkKVxyXG4gICAgZmFzdF9maWx0ZXJfaShhcnIsIHQxLCB0Mikge1xyXG4gICAgICAgIGlmICghYXJyLmxlbmd0aCkgcmV0dXJuIFthcnIsIHVuZGVmaW5lZF1cclxuICAgICAgICBsZXQgaTEgPSAgTWF0aC5mbG9vcih0MSlcclxuICAgICAgICBpZiAoaTEgPCAwKSBpMSA9IDBcclxuICAgICAgICBsZXQgaTIgPSAgTWF0aC5mbG9vcih0MiArIDEpXHJcbiAgICAgICAgbGV0IHJlcyA9IGFyci5zbGljZShpMSwgaTIpXHJcbiAgICAgICAgcmV0dXJuIFtyZXMsIGkxXVxyXG4gICAgfSxcclxuXHJcbiAgICAvLyBOZWFyZXN0IGluZGV4ZXMgKGxlZnQgYW5kIHJpZ2h0KVxyXG4gICAgZmFzdF9uZWFyZXN0KGFyciwgdDEpIHtcclxuICAgICAgICBsZXQgaWEgPSBuZXcgSW5kZXhlZEFycmF5KGFyciwgXCIwXCIpXHJcbiAgICAgICAgaWEuZmV0Y2godDEpXHJcbiAgICAgICAgcmV0dXJuIFtpYS5uZXh0bG93LCBpYS5uZXh0aGlnaF1cclxuICAgIH0sXHJcblxyXG4gICAgbm93KCkgeyByZXR1cm4gKG5ldyBEYXRlKCkpLmdldFRpbWUoKSB9LFxyXG5cclxuICAgIHBhdXNlKGRlbGF5KSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChycywgcmopID0+IHNldFRpbWVvdXQocnMsIGRlbGF5KSlcclxuICAgIH0sXHJcblxyXG4gICAgLy8gTGltaXQgY3Jhenkgd2hlZWwgZGVsdGEgdmFsdWVzXHJcbiAgICBzbWFydF93aGVlbChkZWx0YSkge1xyXG4gICAgICAgIGxldCBhYnMgPSBNYXRoLmFicyhkZWx0YSlcclxuICAgICAgICBpZiAoYWJzID4gNTAwKSB7XHJcbiAgICAgICAgICAgIHJldHVybiAoMjAwICsgTWF0aC5sb2coYWJzKSkgKiBNYXRoLnNpZ24oZGVsdGEpXHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBkZWx0YVxyXG4gICAgfSxcclxuXHJcbiAgICAvLyBQYXJzZSB0aGUgb3JpZ2luYWwgbW91c2UgZXZlbnQgdG8gZmluZCBkZWx0YVhcclxuICAgIGdldF9kZWx0YVgoZXZlbnQpIHtcclxuICAgICAgICByZXR1cm4gZXZlbnQub3JpZ2luYWxFdmVudC5kZWx0YVggLyAxMlxyXG4gICAgfSxcclxuXHJcbiAgICAvLyBQYXJzZSB0aGUgb3JpZ2luYWwgbW91c2UgZXZlbnQgdG8gZmluZCBkZWx0YVlcclxuICAgIGdldF9kZWx0YVkoZXZlbnQpIHtcclxuICAgICAgICByZXR1cm4gZXZlbnQub3JpZ2luYWxFdmVudC5kZWx0YVkgLyAxMlxyXG4gICAgfSxcclxuXHJcbiAgICAvLyBBcHBseSBvcGFjaXR5IHRvIGEgaGV4IGNvbG9yXHJcbiAgICBhcHBseV9vcGFjaXR5KGMsIG9wKSB7XHJcbiAgICAgICAgaWYgKGMubGVuZ3RoID09PSA3KSB7XHJcbiAgICAgICAgICAgIGxldCBuID0gTWF0aC5mbG9vcihvcCAqIDI1NSlcclxuICAgICAgICAgICAgbiA9IHRoaXMuY2xhbXAobiwgMCwgMjU1KVxyXG4gICAgICAgICAgICBjICs9IG4udG9TdHJpbmcoMTYpXHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBjXHJcbiAgICB9LFxyXG5cclxuICAgIC8vIFBhcnNlIHRpbWVmcmFtZSBvciByZXR1cm4gdmFsdWUgaW4gbXNcclxuICAgIHBhcnNlX3RmKHNtdGgpIHtcclxuICAgICAgICBpZiAodHlwZW9mIHNtdGggPT09ICdzdHJpbmcnKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBDb25zdC5tYXBfdW5pdFtzbXRoXVxyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiBzbXRoXHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuXHJcbiAgICAvLyBEZXRlY3QgaW5kZXggc2hpZnQgYmV0d2VlbiB0aGUgbWFpbiBkYXRhIHN1YlxyXG4gICAgLy8gYW5kIHRoZSBvdmVybGF5J3Mgc3ViIChmb3IgSUItbW9kZSlcclxuICAgIGluZGV4X3NoaWZ0KHN1YiwgZGF0YSkge1xyXG5cclxuICAgICAgICAvLyBGaW5kIHRoZSBzZWNvbmQgdGltZXN0YW1wIChieSB2YWx1ZSlcclxuICAgICAgICBpZiAoIWRhdGEubGVuZ3RoKSByZXR1cm4gMFxyXG4gICAgICAgIGxldCBmaXJzdCA9IGRhdGFbMF1bMF1cclxuICAgICAgICBsZXQgc2Vjb25kXHJcblxyXG4gICAgICAgIGZvciAodmFyIGkgPSAxOyBpIDwgZGF0YS5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICBpZiAoZGF0YVtpXVswXSAhPT0gZmlyc3QpIHtcclxuICAgICAgICAgICAgICAgIHNlY29uZCA9IGRhdGFbaV1bMF1cclxuICAgICAgICAgICAgICAgIGJyZWFrXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgc3ViLmxlbmd0aDsgaisrKSB7XHJcbiAgICAgICAgICAgIGlmIChzdWJbal1bMF0gPT09IHNlY29uZCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGogLSBpXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiAwXHJcbiAgICB9LFxyXG5cclxuICAgIC8vIEZhbGxiYWNrIGZpeCBmb3IgQnJhdmUgYnJvd3NlclxyXG4gICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2JyYXZlL2JyYXZlLWJyb3dzZXIvaXNzdWVzLzE3MzhcclxuICAgIG1lYXN1cmVUZXh0KGN0eCwgdGV4dCwgdHZfaWQpIHtcclxuICAgICAgICBsZXQgbSA9IGN0eC5tZWFzdXJlVGV4dE9yZyh0ZXh0KVxyXG4gICAgICAgIGlmIChtLndpZHRoID09PSAwKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGRvYyA9IGRvY3VtZW50XHJcbiAgICAgICAgICAgIGNvbnN0IGlkID0gJ3R2anMtbWVhc3VyZS10ZXh0J1xyXG4gICAgICAgICAgICBsZXQgZWwgPSBkb2MuZ2V0RWxlbWVudEJ5SWQoaWQpXHJcbiAgICAgICAgICAgIGlmICghZWwpIHtcclxuICAgICAgICAgICAgICAgIGxldCBiYXNlID0gZG9jLmdldEVsZW1lbnRCeUlkKHR2X2lkKVxyXG4gICAgICAgICAgICAgICAgZWwgPSBkb2MuY3JlYXRlRWxlbWVudChcImRpdlwiKVxyXG4gICAgICAgICAgICAgICAgZWwuaWQgPSBpZFxyXG4gICAgICAgICAgICAgICAgZWwuc3R5bGUucG9zaXRpb24gPSAnYWJzb2x1dGUnXHJcbiAgICAgICAgICAgICAgICBlbC5zdHlsZS50b3AgPSAnLTEwMDBweCdcclxuICAgICAgICAgICAgICAgIGJhc2UuYXBwZW5kQ2hpbGQoZWwpXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYoY3R4LmZvbnQpIGVsLnN0eWxlLmZvbnQgPSBjdHguZm9udFxyXG4gICAgICAgICAgICBlbC5pbm5lclRleHQgPSB0ZXh0LnJlcGxhY2UoLyAvZywgJy4nKTtcclxuICAgICAgICAgICAgcmV0dXJuIHsgd2lkdGg6IGVsLm9mZnNldFdpZHRoIH1cclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm4gbVxyXG4gICAgICAgIH1cclxuICAgIH0sXHJcblxyXG4gICAgdXVpZCh0ZW1wID0gJ3h4eHh4eHh4LXh4eHgtNHh4eC15eHh4LXh4eHh4eHh4eHh4eCcpIHtcclxuICAgICAgICByZXR1cm4gdGVtcFxyXG4gICAgICAgICAgICAucmVwbGFjZSgvW3h5XS9nLCBjID0+IHtcclxuICAgICAgICAgICAgdmFyIHIgPSBNYXRoLnJhbmRvbSgpICogMTYgfCAwLCB2ID0gYyA9PSAneCcgP1xyXG4gICAgICAgICAgICAgICAgciA6XHJcbiAgICAgICAgICAgICAgICAociAmIDB4MyB8IDB4OClcclxuICAgICAgICAgICAgcmV0dXJuIHYudG9TdHJpbmcoMTYpXHJcbiAgICAgICAgfSlcclxuICAgIH0sXHJcblxyXG4gICAgdXVpZDIoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMudXVpZCgneHh4eHh4eHh4eHh4JylcclxuICAgIH0sXHJcblxyXG4gICAgLy8gRGVsYXllZCB3YXJuaW5nLCBmID0gY29uZGl0aW9uIGxhbWJkYSBmblxyXG4gICAgd2FybihmLCB0ZXh0LCBkZWxheSA9IDApIHtcclxuICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcclxuICAgICAgICAgICAgaWYgKGYoKSkgY29uc29sZS53YXJuKHRleHQpXHJcbiAgICAgICAgfSwgZGVsYXkpXHJcbiAgICB9LFxyXG5cclxuICAgIC8vIENoZWNrcyBpZiBzY3JpcHQgcHJvcHMgdXBkYXRlZFxyXG4gICAgLy8gKGFuZCBub3Qgc3R5bGUgc2V0dGluZ3Mgb3Igc29tZXRoaW5nIGVsc2UpXHJcbiAgICBpc19zY3JfcHJvcHNfdXBkKG4sIHByZXYpIHtcclxuICAgICAgICBsZXQgcCA9IHByZXYuZmluZCh4ID0+IHgudi4kdXVpZCA9PT0gbi52LiR1dWlkKVxyXG4gICAgICAgIGlmICghcCkgcmV0dXJuIGZhbHNlXHJcblxyXG4gICAgICAgIGxldCBwcm9wcyA9IG4ucC5zZXR0aW5ncy4kcHJvcHNcclxuICAgICAgICBpZiAoIXByb3BzKSByZXR1cm4gZmFsc2VcclxuXHJcbiAgICAgICAgcmV0dXJuIHByb3BzLnNvbWUoeCA9PiBuLnZbeF0gIT09IHAudlt4XSlcclxuICAgIH0sXHJcblxyXG4gICAgLy8gQ2hlY2tzIGlmIGl0J3MgdGltZSB0byBtYWtlIGEgc2NyaXB0IHVwZGF0ZVxyXG4gICAgLy8gKGJhc2VkIG9uIGV4ZWNJbnRlcnZhbCBpbiBtcylcclxuICAgIGRlbGF5ZWRfZXhlYyh2KSB7XHJcbiAgICAgICAgaWYgKCF2LnNjcmlwdCB8fCAhdi5zY3JpcHQuZXhlY0ludGVydmFsKVxyXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZVxyXG4gICAgICAgIGxldCB0ID0gdGhpcy5ub3coKVxyXG4gICAgICAgIGxldCBkdCA9IHYuc2NyaXB0LmV4ZWNJbnRlcnZhbFxyXG4gICAgICAgIGlmICghdi5zZXR0aW5ncy4kbGFzdF9leGVjIHx8XHJcbiAgICAgICAgICAgIHQgPiB2LnNldHRpbmdzLiRsYXN0X2V4ZWMgKyBkdCkge1xyXG4gICAgICAgICAgICB2LnNldHRpbmdzLiRsYXN0X2V4ZWMgPSB0XHJcbiAgICAgICAgICAgIHJldHVybiB0cnVlXHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBmYWxzZVxyXG4gICAgfSxcclxuXHJcbiAgICAvLyBGb3JtYXQgbmFtZXMgc3VjaCAnUlNJLCAkbGVuZ3RoJywgd2hlcmVcclxuICAgIC8vIGxlbmd0aCAtIGlzIG9uZSBvZiB0aGUgc2V0dGluZ3NcclxuICAgIGZvcm1hdF9uYW1lKG92KSB7XHJcbiAgICAgICAgaWYgKCFvdi5uYW1lKSByZXR1cm4gdW5kZWZpbmVkXHJcblxyXG4gICAgICAgIGxldCBuYW1lID0gb3YubmFtZVxyXG5cclxuICAgICAgICBmb3IgKHZhciBrIGluIG92LnNldHRpbmdzIHx8IHt9KSB7XHJcbiAgICAgICAgICAgIGxldCB2YWwgPSBvdi5zZXR0aW5nc1trXVxyXG4gICAgICAgICAgICBsZXQgcmVnID0gbmV3IFJlZ0V4cChgXFxcXCQke2t9YCwgJ2cnKVxyXG4gICAgICAgICAgICBuYW1lID0gbmFtZS5yZXBsYWNlKHJlZywgdmFsKVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIG5hbWVcclxuICAgIH0sXHJcblxyXG4gICAgLy8gRGVmYXVsdCBjdXJzb3IgbW9kZVxyXG4gICAgeG1vZGUoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuaXNfbW9iaWxlID8gJ2V4cGxvcmUnIDogJ2RlZmF1bHQnXHJcbiAgICB9LFxyXG5cclxuICAgIGRlZmF1bHRfcHJldmVudGVkKGV2ZW50KSB7XHJcbiAgICAgICAgaWYgKGV2ZW50Lm9yaWdpbmFsKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBldmVudC5vcmlnaW5hbC5kZWZhdWx0UHJldmVudGVkXHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBldmVudC5kZWZhdWx0UHJldmVudGVkXHJcbiAgICB9LFxyXG5cclxuICAgIC8vIFdURiB3aXRoIG1vZGVybiB3ZWIgZGV2ZWxvcG1lbnRcclxuICAgIGlzX21vYmlsZTogKHcgPT4gJ29ub3JpZW50YXRpb25jaGFuZ2UnIGluIHcgJiZcclxuICAgICAgICghIW5hdmlnYXRvci5tYXhUb3VjaFBvaW50cyB8fFxyXG4gICAgICAgICEhbmF2aWdhdG9yLm1zTWF4VG91Y2hQb2ludHMgfHxcclxuICAgICAgICAoJ29udG91Y2hzdGFydCcgaW4gdyB8fFxyXG4gICAgICAgICh3LkRvY3VtZW50VG91Y2ggJiZcclxuICAgICAgICBkb2N1bWVudCBpbnN0YW5jZW9mIHcuRG9jdW1lbnRUb3VjaCkpKSlcclxuICAgICAgICAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgPyB3aW5kb3cgOiB7fSlcclxuXHJcbn1cclxuIiwiLy8gSW1wb3J0c1xuaW1wb3J0IF9fX0NTU19MT0FERVJfQVBJX1NPVVJDRU1BUF9JTVBPUlRfX18gZnJvbSBcIi4uL25vZGVfbW9kdWxlcy9sYXJhdmVsLW1peC9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9kaXN0L3J1bnRpbWUvY3NzV2l0aE1hcHBpbmdUb1N0cmluZy5qc1wiO1xuaW1wb3J0IF9fX0NTU19MT0FERVJfQVBJX0lNUE9SVF9fXyBmcm9tIFwiLi4vbm9kZV9tb2R1bGVzL2xhcmF2ZWwtbWl4L25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2Rpc3QvcnVudGltZS9hcGkuanNcIjtcbnZhciBfX19DU1NfTE9BREVSX0VYUE9SVF9fXyA9IF9fX0NTU19MT0FERVJfQVBJX0lNUE9SVF9fXyhfX19DU1NfTE9BREVSX0FQSV9TT1VSQ0VNQVBfSU1QT1JUX19fKTtcbi8vIE1vZHVsZVxuX19fQ1NTX0xPQURFUl9FWFBPUlRfX18ucHVzaChbbW9kdWxlLmlkLCBcIlxcbi5hcHAtY29udGVudCB7XFxuICAgIHBhZGRpbmc6IGNhbGMoMnJlbSArIDIuNDVyZW0pIDAgMCAwcmVtICFpbXBvcnRhbnQ7XFxuICAgIG92ZXJmbG93LXg6IGhpZGRlbjtcXG59XFxuQG1lZGlhIChtYXgtd2lkdGg6IDc2Ny45OHB4KXtcXG5odG1sIGJvZHkubmF2YmFyLXN0aWNreSAuYXBwLWNvbnRlbnQge1xcbiAgICAgICAgcGFkZGluZzogY2FsYygxcmVtIC0gMC44cmVtICsgNC40NXJlbSkgMCAwIDAgIWltcG9ydGFudDtcXG59XFxufVxcbi5mbGV4ZWQge1xcbiAgICBkaXNwbGF5OiBmbGV4O1xcbiAgICBmbGV4LWRpcmVjdGlvbjogY29sdW1uO1xcbiAgICBhbGlnbi1pdGVtczogY2VudGVyO1xcbiAgICBqdXN0aWZ5LWNvbnRlbnQ6IGNlbnRlcjtcXG4gICAgYWxpZ24tY29udGVudDogY2VudGVyO1xcbiAgICBmbGV4LXdyYXA6IG5vd3JhcDtcXG59XFxuI2FwcC1jb25haW5lciB7XFxuICAgIGRpc3BsYXk6IGZsZXg7XFxuICAgIGZsZXgtZGlyZWN0aW9uOiByb3c7XFxuICAgIGp1c3RpZnktY29udGVudDogc3BhY2UtYmV0d2VlbjtcXG4gICAgYWxpZ24tY29udGVudDogc3BhY2UtYmV0d2VlbjtcXG4gICAgYWxpZ24taXRlbXM6IGZsZXgtc3RhcnQ7XFxuICAgIGZsZXgtd3JhcDogbm93cmFwO1xcbn1cXG5cXG4vKiBAbWVkaWEgKG1heC13aWR0aDogNzY3Ljk4cHgpe1xcbiAgICAjYXBwLWNvbmFpbmVyIHtcXG4gICAgICAgIGRpc3BsYXk6IGZsZXg7XFxuICAgICAgICBmbGV4LWRpcmVjdGlvbjogY29sdW1uO1xcbiAgICAgICAganVzdGlmeS1jb250ZW50OiBzcGFjZS1iZXR3ZWVuO1xcbiAgICAgICAgYWxpZ24tY29udGVudDogc3BhY2UtYmV0d2VlbjtcXG4gICAgICAgIGFsaWduLWl0ZW1zOiBmbGV4LXN0YXJ0O1xcbiAgICAgICAgZmxleC13cmFwOiBub3dyYXA7XFxuICAgIH1cXG59ICovXFxuI3RyYWRlYmFyIHtcXG4gICAgY29sb3I6ICNkZGQ7XFxufVxcbiN0dmpzLWhlYWRlciB7XFxuICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTtcXG4gICAgZGlzcGxheTogZmxleDtcXG4gICAgYWxpZ24tY29udGVudDogY2VudGVyO1xcbiAgICBmbGV4LWRpcmVjdGlvbjogcm93O1xcbiAgICBmbGV4LXdyYXA6IG5vd3JhcDtcXG4gICAganVzdGlmeS1jb250ZW50OiBmbGV4LXN0YXJ0O1xcbiAgICBhbGlnbi1pdGVtczogY2VudGVyO1xcbiAgICBwYWRkaW5nLWxlZnQ6IDcwcHg7XFxuICAgIGhlaWdodDogNDBweDtcXG4gICAgY29sb3I6ICNkZGQ7XFxuICAgIHdpZHRoOiAxMDAlO1xcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiAjMTIxODI2O1xcbn1cXG4ubmlnaHQtbW9kZSB7XFxuICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTtcXG4gICAgdG9wOiAxNXB4O1xcbiAgICByaWdodDogMjBweDtcXG59XFxuI3RyYWRpbmctdnVlLWpzLWdyaWQtMC1jYW52YXMsXFxuI3RyYWRpbmctdnVlLWpzLXNpZGViYXItMC1jYW52YXMsXFxuI3RyYWRpbmctdnVlLWpzLWdyaWQtMS1jYW52YXMsXFxuI3RyYWRpbmctdnVlLWpzLXNpZGViYXItMS1jYW52YXMsXFxuI3RyYWRpbmctdnVlLWpzLWJvdGJhci1jYW52YXMge1xcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiByZ2IoMCAwIDAgLyAwJSkgIWltcG9ydGFudDtcXG59XFxuI3RyYWRpbmctdnVlLXRiaXRlbSB7XFxuICAgIGJhY2tncm91bmQtY29sb3I6IHJnYigxOCwgMjQsIDM4KTtcXG59XFxuQG1lZGlhIG9ubHkgc2NyZWVuIGFuZCAobWF4LWRldmljZS13aWR0aDogNDgwcHgpIHtcXG4udGYtc2VsZWN0b3Ige1xcbiAgICAgICAgdG9wOiA1MHB4O1xcbiAgICAgICAgcmlnaHQ6IDE0MHB4O1xcbiAgICAgICAgbWF4LXdpZHRoOiAxNDBweDtcXG4gICAgICAgIGZvbnQ6IDEycHggLWFwcGxlLXN5c3RlbSwgQmxpbmtNYWNTeXN0ZW1Gb250LFxcbiAgICAgICAgICAgIFNlZ29lIFVJLCBSb2JvdG8sIE94eWdlbiwgVWJ1bnR1LCBDYW50YXJlbGwsXFxuICAgICAgICAgICAgRmlyYSBTYW5zLCBEcm9pZCBTYW5zLCBIZWx2ZXRpY2EgTmV1ZSxcXG4gICAgICAgICAgICBzYW5zLXNlcmlmO1xcbn1cXG59XFxuLmJveCB7XFxuICAgIHdpZHRoOiAyODBweDtcXG4gICAgbWFyZ2luOiAwIGF1dG87XFxuICAgIGJveC1zaGFkb3c6IDAgMS41cHggNXB4IC0ycHggcmdiYSgwLCAwLCAwLCAwLjIpO1xcbiAgICBib3JkZXItcmFkaXVzOiAzcHg7XFxuICAgIHBhZGRpbmc6IDAgMTVweCAwIDE1cHg7XFxufVxcbnRhYmxlIHtcXG4gICAgZm9udC1zaXplOiAxM3B4O1xcbiAgICBmb250LXdlaWdodDogNTAwO1xcbiAgICBjb2xvcjogcmdiKDE4MywgMTg5LCAxOTgpO1xcbiAgICBvdmVyZmxvdzogaGlkZGVuO1xcbiAgICB3aWR0aDogMTAwJTtcXG59XFxudGQge1xcbiAgICBwb3NpdGlvbjogcmVsYXRpdmU7XFxuICAgIGhlaWdodDogMjBweDtcXG4gICAgbGluZS1oZWlnaHQ6IDIwcHg7XFxufVxcbnRkLnByaWNlIHtcXG4gICAgd2lkdGg6IDMwJTtcXG59XFxudGQucHJpY2Ugc3BhbiB7XFxuICAgIHBhZGRpbmctbGVmdDogNXB4O1xcbn1cXG50ZC5xdWFudGl0eSB7XFxuICAgIHdpZHRoOiAzMCU7XFxuICAgIHRleHQtYWxpZ246IHJpZ2h0O1xcbn1cXG50ZC50aW1lIHtcXG4gICAgd2lkdGg6IDQwJTtcXG4gICAgdGV4dC1hbGlnbjogcmlnaHQ7XFxuICAgIGNvbG9yOiAjOTk5O1xcbiAgICBwYWRkaW5nLXJpZ2h0OiA1cHg7XFxufVxcbnRkLmJ0YyB7XFxuICAgIHdpZHRoOiA0MCU7XFxuICAgIHRleHQtYWxpZ246IHJpZ2h0O1xcbiAgICBwYWRkaW5nLXJpZ2h0OiA1cHg7XFxufVxcbnRkIHNwYW4ge1xcbiAgICBwb3NpdGlvbjogcmVsYXRpdmU7XFxuICAgIHotaW5kZXg6IDI7XFxufVxcbnRhYmxlLmFza3MgLnBlcmNlbnQge1xcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiByZ2JhKDI0NiwgNzAsIDk0LCAwLjIpO1xcbn1cXG50YWJsZS5iaWRzIC5wZXJjZW50IHtcXG4gICAgYmFja2dyb3VuZC1jb2xvcjogcmdiYSgxNCwgMjAzLCAxMjksIDAuMik7XFxufVxcbnRkIC5wZXJjZW50IHtcXG4gICAgcG9zaXRpb246IGFic29sdXRlO1xcbiAgICB0b3A6IDA7XFxuICAgIGJvdHRvbTogMDtcXG4gICAgcmlnaHQ6IDA7XFxufVxcbi5uZXdlc3Qge1xcbiAgICBib3JkZXItYm90dG9tOiAxcHggc29saWQgI2VlZTtcXG4gICAgbWFyZ2luOiAxNXB4IC0xNXB4O1xcbn1cXG4uY2FyZC0xMTAge1xcbiAgICB0b3A6IDExMHB4ICFpbXBvcnRhbnQ7XFxuICAgIGxlZnQ6IDcwcHg7XFxufVxcbi8qIFN0eWxlIHBhZ2UgY29udGVudCAtIHVzZSB0aGlzIGlmIHlvdSB3YW50IHRvIHB1c2ggdGhlIHBhZ2UgY29udGVudCB0byB0aGUgcmlnaHQgd2hlbiB5b3Ugb3BlbiB0aGUgc2lkZSBuYXZpZ2F0aW9uICovXFxuI21haW4ge1xcbiAgICB0cmFuc2l0aW9uOiBtYXJnaW4tbGVmdCAuNXM7XFxuICAgIC8qIElmIHlvdSB3YW50IGEgdHJhbnNpdGlvbiBlZmZlY3QgKi9cXG59XFxuXFxuLyogT24gc21hbGxlciBzY3JlZW5zLCB3aGVyZSBoZWlnaHQgaXMgbGVzcyB0aGFuIDQ1MHB4LCBjaGFuZ2UgdGhlIHN0eWxlIG9mIHRoZSBzaWRlbmF2IChsZXNzIHBhZGRpbmcgYW5kIGEgc21hbGxlciBmb250IHNpemUpICovXFxuQG1lZGlhIHNjcmVlbiBhbmQgKG1heC1oZWlnaHQ6IDQ1MHB4KSB7XFxuLnNpZGViYXIxIHtcXG4gICAgICAgIHBhZGRpbmctdG9wOiAxNXB4O1xcbn1cXG4uc2lkZWJhcjEgYSB7XFxuICAgICAgICBmb250LXNpemU6IDE4cHg7XFxufVxcbn1cXG4uYnRuLWNpcmNsZSB7XFxuICAgIHdpZHRoOiAzMHB4O1xcbiAgICBoZWlnaHQ6IDMwcHg7XFxuICAgIHBhZGRpbmc6IDZweCAwcHg7XFxuICAgIGJvcmRlci1yYWRpdXM6IDE1cHg7XFxuICAgIGZvbnQtc2l6ZTogOHB4O1xcbiAgICB0ZXh0LWFsaWduOiBjZW50ZXI7XFxufVxcbiNjaGFydGRpdiB7XFxuICAgIG1pbi1oZWlnaHQ6IDMwMHB4O1xcbiAgICBtYXgtaGVpZ2h0OiA0MDBweDtcXG4gICAgaGVpZ2h0OiA3MHZoO1xcbn1cXG5cIiwgXCJcIix7XCJ2ZXJzaW9uXCI6MyxcInNvdXJjZXNcIjpbXCJ3ZWJwYWNrOi8vLi9zcmMvTWFpbi52dWVcIl0sXCJuYW1lc1wiOltdLFwibWFwcGluZ3NcIjpcIjtBQWdUQTtJQUNBLGlEQUFBO0lBQ0Esa0JBQUE7QUFDQTtBQUNBO0FBQ0E7UUFDQSx1REFBQTtBQUNBO0FBQ0E7QUFDQTtJQUNBLGFBQUE7SUFDQSxzQkFBQTtJQUNBLG1CQUFBO0lBQ0EsdUJBQUE7SUFDQSxxQkFBQTtJQUNBLGlCQUFBO0FBQ0E7QUFFQTtJQUNBLGFBQUE7SUFDQSxtQkFBQTtJQUNBLDhCQUFBO0lBQ0EsNEJBQUE7SUFDQSx1QkFBQTtJQUNBLGlCQUFBO0FBQ0E7O0FBRUE7Ozs7Ozs7OztHQVNBO0FBQ0E7SUFDQSxXQUFBO0FBQ0E7QUFFQTtJQUNBLGtCQUFBO0lBQ0EsYUFBQTtJQUNBLHFCQUFBO0lBQ0EsbUJBQUE7SUFDQSxpQkFBQTtJQUNBLDJCQUFBO0lBQ0EsbUJBQUE7SUFDQSxrQkFBQTtJQUNBLFlBQUE7SUFDQSxXQUFBO0lBQ0EsV0FBQTtJQUNBLHlCQUFBO0FBQ0E7QUFFQTtJQUNBLGtCQUFBO0lBQ0EsU0FBQTtJQUNBLFdBQUE7QUFDQTtBQUVBOzs7OztJQUtBLDRDQUFBO0FBQ0E7QUFFQTtJQUNBLGlDQUFBO0FBQ0E7QUFFQTtBQUNBO1FBQ0EsU0FBQTtRQUNBLFlBQUE7UUFDQSxnQkFBQTtRQUNBOzs7c0JBR0E7QUFDQTtBQUNBO0FBRUE7SUFDQSxZQUFBO0lBQ0EsY0FBQTtJQUNBLCtDQUFBO0lBQ0Esa0JBQUE7SUFDQSxzQkFBQTtBQUNBO0FBRUE7SUFDQSxlQUFBO0lBQ0EsZ0JBQUE7SUFDQSx5QkFBQTtJQUNBLGdCQUFBO0lBQ0EsV0FBQTtBQUNBO0FBRUE7SUFDQSxrQkFBQTtJQUNBLFlBQUE7SUFDQSxpQkFBQTtBQUNBO0FBRUE7SUFDQSxVQUFBO0FBQ0E7QUFFQTtJQUNBLGlCQUFBO0FBQ0E7QUFFQTtJQUNBLFVBQUE7SUFDQSxpQkFBQTtBQUNBO0FBRUE7SUFDQSxVQUFBO0lBQ0EsaUJBQUE7SUFDQSxXQUFBO0lBQ0Esa0JBQUE7QUFDQTtBQUVBO0lBQ0EsVUFBQTtJQUNBLGlCQUFBO0lBQ0Esa0JBQUE7QUFDQTtBQUVBO0lBQ0Esa0JBQUE7SUFDQSxVQUFBO0FBQ0E7QUFFQTtJQUNBLHdDQUFBO0FBQ0E7QUFFQTtJQUNBLHlDQUFBO0FBQ0E7QUFFQTtJQUNBLGtCQUFBO0lBQ0EsTUFBQTtJQUNBLFNBQUE7SUFDQSxRQUFBO0FBQ0E7QUFFQTtJQUNBLDZCQUFBO0lBQ0Esa0JBQUE7QUFDQTtBQUVBO0lBQ0EscUJBQUE7SUFDQSxVQUFBO0FBQ0E7QUFDQSxzSEFBQTtBQUNBO0lBQ0EsMkJBQUE7SUFDQSxvQ0FBQTtBQUNBOztBQUVBLGdJQUFBO0FBQ0E7QUFDQTtRQUNBLGlCQUFBO0FBQ0E7QUFFQTtRQUNBLGVBQUE7QUFDQTtBQUNBO0FBRUE7SUFDQSxXQUFBO0lBQ0EsWUFBQTtJQUNBLGdCQUFBO0lBQ0EsbUJBQUE7SUFDQSxjQUFBO0lBQ0Esa0JBQUE7QUFDQTtBQUVBO0lBQ0EsaUJBQUE7SUFDQSxpQkFBQTtJQUNBLFlBQUE7QUFDQVwiLFwic291cmNlc0NvbnRlbnRcIjpbXCI8dGVtcGxhdGU+XFxuICAgIDxkaXYgY2xhc3M9XFxcImZsZXgtc3RhcnQgY29sLTEwIGNvbC14bGwtMTAgY29sLXhsLTEwIGNvbC1sZy0xMCBjb2wtbWQtOSBjb2wtc20tMTJcXFwiPlxcbiAgICAgICAgPGRpdiBpZD1cXFwidHZqcy1oZWFkZXJcXFwiPlxcbiAgICAgICAgICAgIDxhPjxzcGFuIHYtb246Y2xpY2s9XFxcImNhbmRsZXNcXFwiIGNsYXNzPVxcXCJtZS0xIGJhZGdlIGJnLWxpZ2h0LXNlY29uZGFyeVxcXCI+PGkgY2xhc3M9XFxcImJpIGJpLWJhci1jaGFydFxcXCIgLz48ZGl2IGNsYXNzPVxcXCJkLW1kLWlubGluZSBkLW5vbmVcXFwiPiAgQ2FuZGxlczwvZGl2Pjwvc3Bhbj48L2E+XFxuICAgICAgICAgICAgPGE+PHNwYW4gdi1vbjpjbGljaz1cXFwic3BsaW5lXFxcIiBjbGFzcz1cXFwibWUtMSBiYWRnZSBiZy1saWdodC1zZWNvbmRhcnlcXFwiPjxpIGNsYXNzPVxcXCJiaSBiaS1ncmFwaC11cFxcXCIgLz48ZGl2IGNsYXNzPVxcXCJkLW1kLWlubGluZSBkLW5vbmVcXFwiPiAgU3BsaW5lPC9kaXY+PC9zcGFuPjwvYT5cXG4gICAgICAgICAgICA8YT48c3BhbiBpZD1cXFwidG9nZ2xlSW5mb1xcXCIgY2xhc3M9XFxcIm1lLTEgYmFkZ2UgYmctbGlnaHQtaW5mb1xcXCIgZGF0YS1icy10b2dnbGU9XFxcImNvbGxhcHNlXFxcIlxcbiAgICAgICAgICAgICAgICAgICAgZGF0YS1icy10YXJnZXQ9XFxcIiNjb2xsYXBzZUluZm9zXFxcIiBhcmlhLWV4cGFuZGVkPVxcXCJmYWxzZVxcXCIgYXJpYS1jb250cm9scz1cXFwiY29sbGFwc2VJbmZvc1xcXCI+PGlcXG4gICAgICAgICAgICAgICAgICAgICAgICBjbGFzcz1cXFwiYmkgYmktaW5mby1jaXJjbGVcXFwiIC8+PGRpdiBjbGFzcz1cXFwiZC1tZC1pbmxpbmUgZC1ub25lXFxcIj4gIEluZm88L2Rpdj48L3NwYW4+PC9hPlxcbiAgICAgICAgICAgIDxhPjxzcGFuIGlkPVxcXCJ0b2dnbGVEZXB0aFxcXCIgY2xhc3M9XFxcIm1lLTEgYmFkZ2UgYmctbGlnaHQtcHJpbWFyeSBcXFwiIGRhdGEtYnMtdG9nZ2xlPVxcXCJjb2xsYXBzZVxcXCJcXG4gICAgICAgICAgICAgICAgICAgIGRhdGEtYnMtdGFyZ2V0PVxcXCIjY29sbGFwc2VEZXB0aFxcXCIgYXJpYS1leHBhbmRlZD1cXFwiZmFsc2VcXFwiIGFyaWEtY29udHJvbHM9XFxcImNvbGxhcHNlRGVwdGhcXFwiPjxpXFxuICAgICAgICAgICAgICAgICAgICAgICAgY2xhc3M9XFxcImJpIGJpLWthbmJhblxcXCIgLz48ZGl2IGNsYXNzPVxcXCJkLW1kLWlubGluZSBkLW5vbmVcXFwiPiAgRGVwdGggVmlldzwvZGl2Pjwvc3Bhbj48L2E+XFxuICAgICAgICAgICAgPGE+PHNwYW4gaWQ9XFxcInRvZ2dsZU9yZGVyc1xcXCIgY2xhc3M9XFxcIm1lLTEgYmFkZ2UgYmctbGlnaHQtd2FybmluZyBcXFwiIGRhdGEtYnMtdG9nZ2xlPVxcXCJjb2xsYXBzZVxcXCJcXG4gICAgICAgICAgICBkYXRhLWJzLXRhcmdldD1cXFwiI2NvbGxhcHNlT3JkZXJzXFxcIiBhcmlhLWV4cGFuZGVkPVxcXCJmYWxzZVxcXCIgYXJpYS1jb250cm9scz1cXFwiY29sbGFwc2VPcmRlcnNcXFwiPjxpXFxuICAgICAgICAgICAgICAgICAgICAgICAgY2xhc3M9XFxcImJpIGJpLWZpbGUtYmFyLWdyYXBoXFxcIiAvPjxkaXYgY2xhc3M9XFxcImQtbWQtaW5saW5lIGQtbm9uZVxcXCI+ICBPcmRlciBCb29rPC9kaXY+PC9zcGFuPjwvYT5cXG4gICAgICAgICAgICA8L2Rpdj5cXG4gICAgICAgICAgICA8ZGl2IGlkPVxcXCJjb2xsYXBzZUluZm9zXFxcIlxcbiAgICAgICAgICAgICAgICBjbGFzcz1cXFwiY29sbGFwc2UgY29sLWxnLTQgY29sLW1kLTUgY29sLXNtLTYgcG9zaXRpb24tYWJzb2x1dGUgc3RpY2t5LXRvcCBjYXJkLTExMCBcXFwiPlxcbiAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVxcXCJjYXJkXFxcIiBzdHlsZT1cXFwiYmFja2dyb3VuZDojMTMxNzIyZTYhaW1wb3J0YW50O2JveC1zaGFkb3c6IDAgNHB4IDI0cHggMCByZ2IoMCAwIDAgLyAzMCUpO1xcXCI+XFxuICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVxcXCJjYXJkLWhlYWRlclxcXCI+XFxuICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cXFwiY29sLW1kLThcXFwiPlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8aDQgY2xhc3M9XFxcImNhcmQtdGl0bGVcXFwiPlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAge3sgc3ltYm9sIH19XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvaDQ+XFxuICAgICAgICAgICAgICAgICAgICAgICAgPC9kaXY+XFxuICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cXG4gICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XFxcImNhcmQtY29udGVudFxcXCI+XFxuICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cXFwiY2FyZC1ib2R5XFxcIj5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cXFwicm93XFxcIj5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XFxcImNvbC04XFxcIj5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IGlkPVxcXCJzaG93X2JcXFwiIGNsYXNzPVxcXCJ0ZXh0LXN0YXJ0IGZzLTFcXFwiPlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAuLi5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvZGl2PlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cXFwiY29sLTRcXFwiPlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgaWQ9XFxcInNob3dfcFxcXCIgY2xhc3M9XFxcInRleHQtZW5kXFxcIiBzdHlsZT1cXFwiZm9udC1zaXplOjE0cHg7XFxcIj5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLi4uXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPC9kaXY+XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiBpZD1cXFwic2hvd19QXFxcIiBjbGFzcz1cXFwidGV4dC1lbmRcXFwiIHN0eWxlPVxcXCJmb250LXNpemU6MTRweDtcXFwiPlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAuLi5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvZGl2PlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cXFwicm93IG10LTFcXFwiPlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiBpZD1cXFwibXlSYW5nZUNvbG9yXFxcIiBjbGFzcz1cXFwicHJvZ3Jlc3NcXFwiPlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgaWQ9XFxcIm15UmFuZ2VcXFwiIGNsYXNzPVxcXCJwcm9ncmVzcy1iYXIgcHJvZ3Jlc3MtYmFyLXN0cmlwZWQgcHJvZ3Jlc3MtYmFyLWFuaW1hdGVkXFxcIlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByb2xlPVxcXCJwcm9ncmVzc2JhclxcXCIgYXJpYS12YWx1ZW5vdz1cXFwiNTBcXFwiIGFyaWEtdmFsdWVtaW49XFxcIjBcXFwiIGFyaWEtdmFsdWVtYXg9XFxcIjEwMFxcXCJcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3R5bGU9XFxcIndpZHRoOiA4MCVcXFwiIC8+XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPC9kaXY+XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XFxcInJvdyBkLWZsZXgganVzdGlmeS1jb250ZW50LWJldHdlZW4gYWxpZ24taXRlbXMtY2VudGVyXFxcIj5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgaWQ9XFxcInNob3dfbFxcXCIgY2xhc3M9XFxcImNvbCB0ZXh0LXN0YXJ0IHRleHQtZGFuZ2VyXFxcIiBzdHlsZT1cXFwiZm9udC1zaXplOjEwcHg7XFxcIiAvPlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cXFwiY29sIHRleHQtZGFyayB0ZXh0LWNlbnRlclxcXCIgc3R5bGU9XFxcImZvbnQtc2l6ZToxMHB4O1xcXCI+XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgRGF5IFJhbmdlXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgaWQ9XFxcInNob3dfaFxcXCIgY2xhc3M9XFxcImNvbCB0ZXh0LWVuZCB0ZXh0LXN1Y2Nlc3NcXFwiIHN0eWxlPVxcXCJmb250LXNpemU6MTBweDtcXFwiIC8+XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvZGl2PlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVxcXCJyb3cgbXQtMVxcXCI+XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8c21hbGwgY2xhc3M9XFxcImNvbCB0ZXh0LXN0YXJ0IHRleHQtZGFyayBjbGVhcmZpeFxcXCI+Vm9sdW1lIDI0SDwvc21hbGw+XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8c21hbGwgaWQ9XFxcInNob3dfdlxcXCIgY2xhc3M9XFxcImNvbCB0ZXh0LWVuZCB0ZXh0LXdhcm5pbmcgY2xlYXJmaXhcXFwiIC8+XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8aHI+XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvZGl2PlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVxcXCJyb3dcXFwiPlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPHNtYWxsIGNsYXNzPVxcXCJjb2wgdGV4dC1zdGFydCB0ZXh0LWRhcmsgY2xlYXJmaXhcXFwiPk1hcmtldCBDYXA8L3NtYWxsPlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPHNtYWxsIGlkPVxcXCJzaG93X21jXFxcIiBjbGFzcz1cXFwiY29sIHRleHQtZW5kIHRleHQtd2FybmluZyBjbGVhcmZpeFxcXCIgLz5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxocj5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPC9kaXY+XFxuXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XFxcInJvd1xcXCI+XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8c21hbGwgY2xhc3M9XFxcImNvbCB0ZXh0LXN0YXJ0IHRleHQtZGFyayBjbGVhcmZpeFxcXCI+VG90YWwgU3VwcGx5PC9zbWFsbD5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxzbWFsbCBpZD1cXFwic2hvd190c1xcXCIgY2xhc3M9XFxcImNvbCB0ZXh0LWVuZCB0ZXh0LXdhcm5pbmcgY2xlYXJmaXhcXFwiIC8+XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8aHI+XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvZGl2PlxcbiAgICAgICAgICAgICAgICAgICAgICAgIDwvZGl2PlxcbiAgICAgICAgICAgICAgICAgICAgPC9kaXY+XFxuICAgICAgICAgICAgICAgIDwvZGl2PlxcbiAgICAgICAgICAgIDwvZGl2PlxcbiAgICAgICAgICAgIDxkaXYgaWQ9XFxcImNvbGxhcHNlRGVwdGhcXFwiXFxuICAgICAgICAgICAgICAgIGNsYXNzPVxcXCJjb2xsYXBzZSBjb2wtbGctNiBjb2wtbWQtMTAgY29sLXNtLTEyIGNvbC0xMiBwb3NpdGlvbi1hYnNvbHV0ZSBzdGlja3ktdG9wIGNhcmQtMTEwIFxcXCI+XFxuICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XFxcImNhcmRcXFwiIHN0eWxlPVxcXCJiYWNrZ3JvdW5kOiMxMzE3MjJlNiFpbXBvcnRhbnQ7Ym94LXNoYWRvdzogMCA0cHggMjRweCAwIHJnYigwIDAgMCAvIDMwJSk7XFxcIj5cXG4gICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XFxcImNhcmQtY29udGVudFxcXCI+XFxuICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiBpZD1cXFwiY2hhcnRkaXZcXFwiPjwvZGl2PlxcbiAgICAgICAgICAgICAgICAgICAgPC9kaXY+XFxuICAgICAgICAgICAgICAgIDwvZGl2PlxcbiAgICAgICAgICAgIDwvZGl2PlxcbiAgICAgICAgICAgIDxkaXYgaWQ9XFxcImNvbGxhcHNlT3JkZXJzXFxcIlxcbiAgICAgICAgICAgICAgICBjbGFzcz1cXFwiY29sbGFwc2UgY29sLWxnLTQgY29sLW1kLTQgY29sLXNtLTYgY29sLTEyIHBvc2l0aW9uLWFic29sdXRlIHN0aWNreS10b3AgY2FyZC0xMTBcXFwiIHN0eWxlPVxcXCJtYXgtd2lkdGg6MjgwcHg7XFxcIj5cXG4gICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cXFwiY2FyZFxcXCIgc3R5bGU9XFxcImJhY2tncm91bmQ6IzEzMTcyMmU2IWltcG9ydGFudDtib3gtc2hhZG93OiAwIDRweCAyNHB4IDAgcmdiKDAgMCAwIC8gMzAlKTtcXFwiPlxcbiAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cXFwiY2FyZC1jb250ZW50IG15LTFcXFwiPlxcbiAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XFxcImJveFxcXCI+XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDx0YWJsZT5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDx0aGVhZD5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8dHIgY2xhc3M9XFxcIm1iLTFcXFwiPlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8dGggY2xhc3M9XFxcInRleHQtc3RhcnQgcHMtMSB0ZXh0LWRhcmtcXFwiPlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgUHJpY2VcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPC90aD5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPHRoIGNsYXNzPVxcXCJ0ZXh0LWNlbnRlciBwcy0xIHRleHQtZGFya1xcXCI+XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBRdWFudGl0eVxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L3RoPlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8dGggY2xhc3M9XFxcInRleHQtZW5kIHBlLTEgdGV4dC1kYXJrXFxcIj5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFRvdGFsXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvdGg+XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPC90cj5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvdGhlYWQ+XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvdGFibGU+XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDx0YWJsZSBjbGFzcz1cXFwiYXNrc1xcXCIgLz5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cXFwibmV3ZXN0XFxcIiAvPlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8dGFibGUgY2xhc3M9XFxcImJpZHNcXFwiIC8+XFxuICAgICAgICAgICAgICAgICAgICAgICAgPC9kaXY+XFxuICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cXG4gICAgICAgICAgICAgICAgPC9kaXY+XFxuICAgICAgICAgICAgPC9kaXY+XFxuICAgICAgICA8ZGl2IGNsYXNzPVxcXCJhcHAtY29udGFpbmVyXFxcIiBzdHlsZT1cXFwibWFyZ2luLXRvcDo0MHB4O1xcXCI+XFxuICAgICAgICAgICAgPHRyYWRpbmctdnVlIDprZXk9XFxcInJlc2V0a2V5XFxcIiByZWY9XFxcInR2anNcXFwiIDpkYXRhPVxcXCJkY1xcXCIgOndpZHRoPVxcXCJ3aWR0aFxcXCIgOmhlaWdodD1cXFwiaGVpZ2h0XFxcIiA6dGl0bGUtdHh0PVxcXCJ0aXRsZVxcXCJcXG4gICAgICAgICAgICAgICAgY29sb3ItdGl0bGU9XFxcIiNmZjlmNDNcXFwiIDpsZWdlbmQtYnV0dG9ucz1cXFwiWydkaXNwbGF5JywgJ3NldHRpbmdzJywgJ3VwJywgJ2Rvd24nLCAnYWRkJywgJ3JlbW92ZSddXFxcIlxcbiAgICAgICAgICAgICAgICA6Y2hhcnQtY29uZmlnPVxcXCJ7REVGQVVMVF9MRU46NjAsTUlOX1pPT006MX1cXFwiIDp0b29sYmFyPVxcXCJ0cnVlXFxcIiA6Y29sb3ItYmFjaz1cXFwiY29sb3JzLmNvbG9yQmFja1xcXCJcXG4gICAgICAgICAgICAgICAgOmNvbG9yLWdyaWQ9XFxcImNvbG9ycy5jb2xvckdyaWRcXFwiIDpjb2xvci10ZXh0PVxcXCJjb2xvcnMuY29sb3JUZXh0XFxcIiA6ZXh0ZW5zaW9ucz1cXFwiZXh0XFxcIiA6b3ZlcmxheXM9XFxcIm92c1xcXCJcXG4gICAgICAgICAgICAgICAgOm5pZ2h0PVxcXCJuaWdodFxcXCIgOnJlc2V0a2V5PVxcXCJyZXNldGtleVxcXCIgOngtc2V0dGluZ3M9XFxcInhzZXR0XFxcIiA6dGltZXpvbmU9XFxcInRpbWV6b25lXFxcIiAvPlxcbiAgICAgICAgPC9kaXY+XFxuICAgIDwvZGl2PlxcbjwvdGVtcGxhdGU+XFxuXFxuPHNjcmlwdD5cXG5pbXBvcnQgeyBUcmFkaW5nVnVlLCBEYXRhQ3ViZSB9IGZyb20gJ3RyYWRpbmctdnVlLWpzJ1xcbmltcG9ydCBPdmVybGF5cyBmcm9tICd0dmpzLW92ZXJsYXlzJ1xcbmltcG9ydCBEYXRhIGZyb20gJy4uL3Jlc291cmNlcy9kYXRhL2RhdGEuanNvbidcXG5pbXBvcnQgVXRpbHMgZnJvbSAnLi9zdHVmZi91dGlscy5qcydcXG5pbXBvcnQgQ29uc3QgZnJvbSAnLi9zdHVmZi9jb25zdGFudHMuanMnXFxuaW1wb3J0IFN0cmVhbSBmcm9tICcuL3N0cmVhbS5qcydcXG5pbXBvcnQgRXh0ZW5zaW9ucyBmcm9tICcuL2luZGV4X2RldidcXG5pbXBvcnQgdHh0IGZyb20gJ3Jhdy1sb2FkZXIhLi4vcmVzb3VyY2VzL2Fzc2V0cy9jb3JzLnR4dCc7XFxuLy8gR2V0dGluJyBkYXRhIHRocm91Z2ggd2VicGVjayBwcm94eVxcbmNvbnN0IHN5bWJvbHNtID0gd2luZG93LmxvY2F0aW9uLnBhdGhuYW1lLnRvTG93ZXJDYXNlKCkuc3BsaXQoJy8nKVszXVxcbmNvbnN0IHN5bWJvbGJnID0gd2luZG93LmxvY2F0aW9uLnBhdGhuYW1lLnRvVXBwZXJDYXNlKCkuc3BsaXQoJy8nKVszXVxcbmNvbnN0IHBhaXJzbSA9IHdpbmRvdy5sb2NhdGlvbi5wYXRobmFtZS50b0xvd2VyQ2FzZSgpLnNwbGl0KCcvJylbNF1cXG5jb25zdCBwYWlyYmcgPSB3aW5kb3cubG9jYXRpb24ucGF0aG5hbWUudG9VcHBlckNhc2UoKS5zcGxpdCgnLycpWzRdXFxuY29uc3QgVVJMID0gdHh0KydodHRwczovL2FwaS5iaW5hbmNlLmNvbS9hcGkvdjEva2xpbmVzP3N5bWJvbD0nXFxuY29uc3QgV1NTID0gYHdzczovL3N0cmVhbS5iaW5hbmNlLmNvbTo5NDQzL3dzLyR7c3ltYm9sc219JHtwYWlyc219QGFnZ1RyYWRlYFxcbmNvbnN0IGRhdGFzID0gYGRhdGFzZXRzLmJpbmFuY2UtJHtzeW1ib2xzbX0ke3BhaXJzbX1gXFxuLy9jb25zdCBQT1JUID0gbG9jYXRpb24ucG9ydFxcbi8vY29uc3QgVVJMID0gYGh0dHA6Ly9sb2NhbGhvc3Q6JHtQT1JUfS9hcGkvdjEva2xpbmVzP3N5bWJvbD1gXFxuLy9jb25zdCBXU1MgPSBgd3M6Ly9sb2NhbGhvc3Q6JHtQT1JUfS93cy8ke3N5bWJvbHNtfUBhZ2dUcmFkZWBcXG5cXG5leHBvcnQgZGVmYXVsdCB7XFxuICAgIG5hbWU6ICdBcHAnLFxcbiAgICBjb21wb25lbnRzOiB7XFxuICAgICAgICBUcmFkaW5nVnVlXFxuICAgIH0sXFxuICAgIGRhdGEoKSB7XFxuICAgICAgICByZXR1cm4ge1xcbiAgICAgICAgICAgIGRjOiBuZXcgRGF0YUN1YmUoRGF0YSksXFxuICAgICAgICAgICAgdGl0bGU6IHN5bWJvbGJnICsgcGFpcmJnLFxcbiAgICAgICAgICAgIHdpZHRoOiAwLFxcbiAgICAgICAgICAgIGhlaWdodDogMCxcXG4gICAgICAgICAgICBsb2dfc2NhbGU6IHRydWUsXFxuICAgICAgICAgICAgc3ltYm9sOiBzeW1ib2xiZyArIHBhaXJiZyxcXG4gICAgICAgICAgICBpbmRleF9iYXNlZDogdHJ1ZSxcXG4gICAgICAgICAgICB0aW1lem9uZTogdGhpcy50aW1lem9uZWQoKSxcXG4gICAgICAgICAgICB4c2V0dDoge1xcbiAgICAgICAgICAgICAgICAnZ3JpZC1yZXNpemUnOiB7IG1pbl9oZWlnaHQ6IDMwIH1cXG4gICAgICAgICAgICB9LFxcbiAgICAgICAgICAgIG92czogT2JqZWN0LnZhbHVlcyhPdmVybGF5cyksXFxuICAgICAgICAgICAgZXh0OiBPYmplY3QudmFsdWVzKEV4dGVuc2lvbnMpLFxcbiAgICAgICAgICAgIG5pZ2h0OiB0cnVlLFxcbiAgICAgICAgICAgIHRvcDogNTAsXFxuICAgICAgICAgICAgcmVzZXRrZXk6IDBcXG4gICAgICAgIH1cXG4gICAgfSxcXG4gICAgY29tcHV0ZWQ6IHtcXG4gICAgICAgIGNvbG9ycygpIHtcXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5uaWdodCA/IHt9IDoge1xcbiAgICAgICAgICAgICAgICBjb2xvckJhY2s6ICcjZmZmJyxcXG4gICAgICAgICAgICAgICAgY29sb3JHcmlkOiAnI2VlZScsXFxuICAgICAgICAgICAgICAgIGNvbG9yVGV4dDogJyMzMzMnXFxuICAgICAgICAgICAgfVxcbiAgICAgICAgfVxcbiAgICB9LFxcbiAgICBtb3VudGVkKCkge1xcbiAgICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3Jlc2l6ZScsIHRoaXMub25SZXNpemUpXFxuICAgICAgICBsZXQgcSA9IHRoaXMud2luX3F1ZXJ5KClcXG4gICAgICAgIGlmIChxLm5tID09PSAnZmFsc2UnKSB0aGlzLm5pZ2h0ID0gZmFsc2VcXG4gICAgICAgIGlmIChxLm92KSB0aGlzLmN1cnJlbnQgPSBxLm92XFxuICAgICAgICBpZiAocS5oZWFkZXIgPT09ICdmYWxzZScpIHRoaXMudG9wID0gMFxcbiAgICAgICAgdGhpcy5vblJlc2l6ZSgpLFxcbiAgICAgICAgd2luZG93LmRjID0gdGhpcy5kY1xcbiAgICAgICAgd2luZG93LnR2ID0gdGhpcy4kcmVmcy50dmpzXFxuICAgICAgICAvLyBMb2FkIHRoZSBsYXN0IGRhdGEgY2h1bmsgJiBpbml0IERhdGFDdWJlOlxcbiAgICAgICAgbGV0IG5vdyA9IFV0aWxzLm5vdygpXFxuICAgICAgICB0aGlzLmxvYWRfY2h1bmsoW25vdyAtIENvbnN0LkhPVVI0LCBub3ddKS50aGVuKGRhdGEgPT4ge1xcbiAgICAgICAgICAgIGRjLmRhdGEuY2hhcnQuZGF0YSA9IGRhdGFbJ2NoYXJ0LmRhdGEnXVxcbiAgICAgICAgICAgIC8vIFJlZ2lzdGVyIG9ucmFuZ2UgY2FsbGJhY2sgJiBBbmQgYSBzdHJlYW0gb2YgdHJhZGVzXFxuICAgICAgICAgICAgdGhpcy5kYy5vbnJhbmdlKHRoaXMubG9hZF9jaHVuaylcXG4gICAgICAgICAgICB0aGlzLnN0cmVhbSA9IG5ldyBTdHJlYW0oV1NTKVxcbiAgICAgICAgICAgIHRoaXMuc3RyZWFtLm9udHJhZGVzID0gdGhpcy5vbl90cmFkZXNcXG4gICAgICAgICAgICB3aW5kb3cuZGMgPSB0aGlzLmNoYXJ0ICAgICAgLy8gRGVidWdcXG4gICAgICAgICAgICB3aW5kb3cudHYgPSB0aGlzLiRyZWZzLnR2anMgLy8gRGVidWdcXG4gICAgICAgIH0pXFxuICAgIH0sXFxuICAgIGJlZm9yZURlc3Ryb3koKSB7XFxuICAgICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcigncmVzaXplJywgdGhpcy5vblJlc2l6ZSlcXG4gICAgICAgIGlmICh0aGlzLnN0cmVhbSkgdGhpcy5zdHJlYW0ub2ZmKClcXG4gICAgfSxcXG4gICAgbWV0aG9kczoge1xcbiAgICAgICAgb25SZXNpemUoKSB7XFxuICAgICAgICAgICAgaWYgKHdpbmRvdy5pbm5lcldpZHRoID4gJzk5MicpIHtcXG4gICAgICAgICAgICAgICAgdGhpcy53aWR0aCA9ICh3aW5kb3cuaW5uZXJXaWR0aCAtICh3aW5kb3cuaW5uZXJXaWR0aCAqIDAuMjEpKVxcbiAgICAgICAgICAgIH0gZWxzZSBpZiAod2luZG93LmlubmVyV2lkdGggPiAnNzY4JyAgJiYgd2luZG93LmlubmVyV2lkdGggPD0gJzk5MicpIHtcXG4gICAgICAgICAgICAgICAgdGhpcy53aWR0aCA9ICh3aW5kb3cuaW5uZXJXaWR0aCAtICh3aW5kb3cuaW5uZXJXaWR0aCAqIDAuMjYpKVxcbiAgICAgICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgICAgICAgIHRoaXMud2lkdGggPSAod2luZG93LmlubmVyV2lkdGggLSAxNSlcXG4gICAgICAgICAgICB9XFxuICAgICAgICAgICAgdGhpcy5oZWlnaHQgPSB3aW5kb3cuaW5uZXJIZWlnaHQgKiAwLjgwXFxuICAgICAgICB9LFxcbiAgICAgICAgc3BsaW5lICgpIHtcXG4gICAgICAgICAgICB0aGlzLmRjLmRhdGEuY2hhcnQudHlwZSA9IFxcXCJTcGxpbmVcXFwiXFxuICAgICAgICAgICAgdGhpcy5kYy5kYXRhLmNoYXJ0LnRmID0gXFxcIjFtXFxcIlxcbiAgICAgICAgICAgIHRoaXMuJHJlZnMudHZqcy5yZXNldENoYXJ0KClcXG4gICAgICAgIH0sXFxuICAgICAgICBjYW5kbGVzICgpIHtcXG4gICAgICAgICAgICB0aGlzLmRjLmRhdGEuY2hhcnQudHlwZSA9IFxcXCJDYW5kbGVzXFxcIlxcbiAgICAgICAgICAgIHRoaXMuZGMuZGF0YS5jaGFydC50ZiA9IFxcXCIxbVxcXCJcXG4gICAgICAgICAgICB0aGlzLiRyZWZzLnR2anMucmVzZXRDaGFydCgpXFxuICAgICAgICB9LFxcbiAgICAgICAgeGJhcnMgKCkge1xcbiAgICAgICAgICAgIHRoaXMuZGF0YS5vdnMgPSAnWE9obGNCYXJzJ1xcbiAgICAgICAgICAgIHRoaXMuZGMuZGF0YS5jaGFydC50ZiA9IFxcXCIxbVxcXCJcXG4gICAgICAgICAgICB0aGlzLiRyZWZzLnR2anMucmVzZXRDaGFydCgpXFxuICAgICAgICB9LFxcbiAgICAgICAgdHJhZGUgKCkge1xcbiAgICAgICAgICAgIHRoaXMuZGMuZGF0YS5jaGFydC50eXBlID0gXFxcIlNwbGluZVxcXCJcXG4gICAgICAgIH0sXFxuICAgICAgICB3aW5fcXVlcnkoKSB7XFxuICAgICAgICAgICAgbGV0IHFzID0gKGZ1bmN0aW9uKGEpIHtcXG4gICAgICAgICAgICAgICAgaWYgKGEgPT0gXFxcIlxcXCIpIHJldHVybiB7fTtcXG4gICAgICAgICAgICAgICAgdmFyIGIgPSB7fTtcXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhLmxlbmd0aDsgKytpKSB7XFxuICAgICAgICAgICAgICAgICAgICB2YXIgcD1hW2ldLnNwbGl0KCc9JywgMik7XFxuICAgICAgICAgICAgICAgICAgICBpZiAocC5sZW5ndGggPT0gMSlcXG4gICAgICAgICAgICAgICAgICAgICAgICBiW3BbMF1dID0gXFxcIlxcXCI7XFxuICAgICAgICAgICAgICAgICAgICBlbHNlXFxuICAgICAgICAgICAgICAgICAgICAgICAgYltwWzBdXSA9IGRlY29kZVVSSUNvbXBvbmVudChwWzFdLnJlcGxhY2UoL1xcXFwrL2csIFxcXCIgXFxcIikpO1xcbiAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgICAgIHJldHVybiBiO1xcbiAgICAgICAgICAgIH0pKHdpbmRvdy5sb2NhdGlvbi5zZWFyY2guc3Vic3RyKDEpLnNwbGl0KCcmJykpO1xcbiAgICAgICAgICAgIHJldHVybiBxc1xcbiAgICAgICAgfSxcXG4gICAgICAgIHJlc2V0KHN0YXRlKSB7XFxuICAgICAgICAgICAgbGV0IHN1YiA9IE9iamVjdC5rZXlzKHN0YXRlKS5maWx0ZXIoeCA9PiBzdGF0ZVt4XSlcXG4gICAgICAgICAgICB0aGlzLmV4dGVuc2lvbnMgPSBzdWIubWFwKHggPT4gRXh0ZW5zaW9uc1t4XSlcXG4gICAgICAgICAgICB0aGlzLnJlc2V0a2V5KytcXG4gICAgICAgIH0sXFxuICAgICAgICBvbnNlbGVjdChpZCkge1xcbiAgICAgICAgICAgIHRoaXMuY3VycmVudCA9IGlkXFxuICAgICAgICB9LFxcbiAgICAgICAgdGltZXpvbmVkKCkge1xcbiAgICAgICAgICAgIHZhciBvZmZzZXQgPSBuZXcgRGF0ZSgpLmdldFRpbWV6b25lT2Zmc2V0KCk7XFxuICAgICAgICAgICAgdmFyIG1pbnV0ZXMgPSBNYXRoLmFicyhvZmZzZXQpO1xcbiAgICAgICAgICAgIHZhciBob3VycyA9IE1hdGguZmxvb3IobWludXRlcyAvIDYwKTtcXG4gICAgICAgICAgICB2YXIgcHJlZml4ID0gb2Zmc2V0IDwgMCA/IFxcXCJcXFwiIDogXFxcIi1cXFwiO1xcbiAgICAgICAgICAgIHJldHVybiBwYXJzZUludChwcmVmaXgraG91cnMpO1xcbiAgICAgICAgfSxcXG4gICAgICAgIC8vIE5ldyBkYXRhIGhhbmRsZXIuIFNob3VsZCByZXR1cm4gUHJvbWlzZSwgb3JcXG4gICAgICAgIC8vIHVzZSBjYWxsYmFjazogbG9hZF9jaHVuayhyYW5nZSwgdGYsIGNhbGxiYWNrKVxcbiAgICAgICAgYXN5bmMgbG9hZF9jaHVuayhyYW5nZSkge1xcbiAgICAgICAgICAgIGxldCBbdDEsIHQyXSA9IHJhbmdlXFxuICAgICAgICAgICAgbGV0IHggPSBzeW1ib2xiZ1xcbiAgICAgICAgICAgIGxldCB5ID0gcGFpcmJnXFxuICAgICAgICAgICAgbGV0IHEgPSBgJHt4fSR7eX0maW50ZXJ2YWw9MW0mc3RhcnRUaW1lPSR7dDF9JmVuZFRpbWU9JHt0Mn1gXFxuICAgICAgICAgICAgbGV0IHIgPSBhd2FpdCBmZXRjaChVUkwgKyBxKS50aGVuKHIgPT4gci5qc29uKCkpXFxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZm9ybWF0KHRoaXMucGFyc2VfYmluYW5jZShyKSlcXG4gICAgICAgIH0sXFxuICAgICAgICAvLyBQYXJzZSBhIHNwZWNpZmljIGV4Y2hhbmdlIGZvcm1hdFxcbiAgICAgICAgcGFyc2VfYmluYW5jZShkYXRhKSB7XFxuICAgICAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KGRhdGEpKSByZXR1cm4gW11cXG4gICAgICAgICAgICByZXR1cm4gZGF0YS5tYXAoeCA9PiB7XFxuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgeC5sZW5ndGg7IGkrKykge1xcbiAgICAgICAgICAgICAgICAgICAgeFtpXSA9IHBhcnNlRmxvYXQoeFtpXSlcXG4gICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgICAgICByZXR1cm4geC5zbGljZSgwLDYpXFxuICAgICAgICAgICAgfSlcXG4gICAgICAgIH0sXFxuICAgICAgICBmb3JtYXQoZGF0YSkge1xcbiAgICAgICAgICAgIHJldHVybiB7XFxuICAgICAgICAgICAgICAgICdjaGFydC5kYXRhJzogZGF0YSxcXG4gICAgICAgICAgICB9XFxuICAgICAgICB9LFxcbiAgICAgICAgb25fdHJhZGVzKHRyYWRlKSB7XFxuICAgICAgICAgICAgdGhpcy5kYy51cGRhdGUoe1xcbiAgICAgICAgICAgICAgICB0OiB0cmFkZS5ULCAgICAgLy8gRXhjaGFuZ2UgdGltZSAob3B0aW9uYWwpXFxuICAgICAgICAgICAgICAgIHByaWNlOiBwYXJzZUZsb2F0KHRyYWRlLnApLCAgIC8vIFRyYWRlIHByaWNlXFxuICAgICAgICAgICAgICAgIHZvbHVtZTogcGFyc2VGbG9hdCh0cmFkZS5xKSwgIC8vIFRyYWRlIGFtb3VudFxcbiAgICAgICAgICAgICAgICBkYXRhcyA6IFsgLy8gVXBkYXRlIGRhdGFzZXRcXG4gICAgICAgICAgICAgICAgICAgIHRyYWRlLlQsXFxuICAgICAgICAgICAgICAgICAgICB0cmFkZS5tID8gMCA6IDEsICAgICAgICAgIC8vIFNlbGwgb3IgQnV5XFxuICAgICAgICAgICAgICAgICAgICBwYXJzZUZsb2F0KHRyYWRlLnEpLFxcbiAgICAgICAgICAgICAgICAgICAgcGFyc2VGbG9hdCh0cmFkZS5wKVxcbiAgICAgICAgICAgICAgICBdLFxcbiAgICAgICAgICAgICAgICAvLyAuLi4gb3RoZXIgb25jaGFydC9vZmZjaGFydCB1cGRhdGVzXFxuICAgICAgICAgICAgfSlcXG4gICAgICAgIH1cXG4gICAgfVxcbn1cXG48L3NjcmlwdD5cXG5cXG48c3R5bGU+XFxuLmFwcC1jb250ZW50IHtcXG4gICAgcGFkZGluZzogY2FsYygycmVtICsgMi40NXJlbSkgMCAwIDByZW0gIWltcG9ydGFudDtcXG4gICAgb3ZlcmZsb3cteDogaGlkZGVuO1xcbn1cXG5AbWVkaWEgKG1heC13aWR0aDogNzY3Ljk4cHgpe1xcbiAgICBodG1sIGJvZHkubmF2YmFyLXN0aWNreSAuYXBwLWNvbnRlbnQge1xcbiAgICAgICAgcGFkZGluZzogY2FsYygxcmVtIC0gMC44cmVtICsgNC40NXJlbSkgMCAwIDAgIWltcG9ydGFudDtcXG4gICAgfVxcbn1cXG4uZmxleGVkIHtcXG4gICAgZGlzcGxheTogZmxleDtcXG4gICAgZmxleC1kaXJlY3Rpb246IGNvbHVtbjtcXG4gICAgYWxpZ24taXRlbXM6IGNlbnRlcjtcXG4gICAganVzdGlmeS1jb250ZW50OiBjZW50ZXI7XFxuICAgIGFsaWduLWNvbnRlbnQ6IGNlbnRlcjtcXG4gICAgZmxleC13cmFwOiBub3dyYXA7XFxufVxcblxcbiNhcHAtY29uYWluZXIge1xcbiAgICBkaXNwbGF5OiBmbGV4O1xcbiAgICBmbGV4LWRpcmVjdGlvbjogcm93O1xcbiAgICBqdXN0aWZ5LWNvbnRlbnQ6IHNwYWNlLWJldHdlZW47XFxuICAgIGFsaWduLWNvbnRlbnQ6IHNwYWNlLWJldHdlZW47XFxuICAgIGFsaWduLWl0ZW1zOiBmbGV4LXN0YXJ0O1xcbiAgICBmbGV4LXdyYXA6IG5vd3JhcDtcXG59XFxuXFxuLyogQG1lZGlhIChtYXgtd2lkdGg6IDc2Ny45OHB4KXtcXG4gICAgI2FwcC1jb25haW5lciB7XFxuICAgICAgICBkaXNwbGF5OiBmbGV4O1xcbiAgICAgICAgZmxleC1kaXJlY3Rpb246IGNvbHVtbjtcXG4gICAgICAgIGp1c3RpZnktY29udGVudDogc3BhY2UtYmV0d2VlbjtcXG4gICAgICAgIGFsaWduLWNvbnRlbnQ6IHNwYWNlLWJldHdlZW47XFxuICAgICAgICBhbGlnbi1pdGVtczogZmxleC1zdGFydDtcXG4gICAgICAgIGZsZXgtd3JhcDogbm93cmFwO1xcbiAgICB9XFxufSAqL1xcbiN0cmFkZWJhciB7XFxuICAgIGNvbG9yOiAjZGRkO1xcbn1cXG5cXG4jdHZqcy1oZWFkZXIge1xcbiAgICBwb3NpdGlvbjogYWJzb2x1dGU7XFxuICAgIGRpc3BsYXk6IGZsZXg7XFxuICAgIGFsaWduLWNvbnRlbnQ6IGNlbnRlcjtcXG4gICAgZmxleC1kaXJlY3Rpb246IHJvdztcXG4gICAgZmxleC13cmFwOiBub3dyYXA7XFxuICAgIGp1c3RpZnktY29udGVudDogZmxleC1zdGFydDtcXG4gICAgYWxpZ24taXRlbXM6IGNlbnRlcjtcXG4gICAgcGFkZGluZy1sZWZ0OiA3MHB4O1xcbiAgICBoZWlnaHQ6IDQwcHg7XFxuICAgIGNvbG9yOiAjZGRkO1xcbiAgICB3aWR0aDogMTAwJTtcXG4gICAgYmFja2dyb3VuZC1jb2xvcjogIzEyMTgyNjtcXG59XFxuXFxuLm5pZ2h0LW1vZGUge1xcbiAgICBwb3NpdGlvbjogYWJzb2x1dGU7XFxuICAgIHRvcDogMTVweDtcXG4gICAgcmlnaHQ6IDIwcHg7XFxufVxcblxcbiN0cmFkaW5nLXZ1ZS1qcy1ncmlkLTAtY2FudmFzLFxcbiN0cmFkaW5nLXZ1ZS1qcy1zaWRlYmFyLTAtY2FudmFzLFxcbiN0cmFkaW5nLXZ1ZS1qcy1ncmlkLTEtY2FudmFzLFxcbiN0cmFkaW5nLXZ1ZS1qcy1zaWRlYmFyLTEtY2FudmFzLFxcbiN0cmFkaW5nLXZ1ZS1qcy1ib3RiYXItY2FudmFzIHtcXG4gICAgYmFja2dyb3VuZC1jb2xvcjogcmdiKDAgMCAwIC8gMCUpICFpbXBvcnRhbnQ7XFxufVxcblxcbiN0cmFkaW5nLXZ1ZS10Yml0ZW0ge1xcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiByZ2IoMTgsIDI0LCAzOCk7XFxufVxcblxcbkBtZWRpYSBvbmx5IHNjcmVlbiBhbmQgKG1heC1kZXZpY2Utd2lkdGg6IDQ4MHB4KSB7XFxuICAgIC50Zi1zZWxlY3RvciB7XFxuICAgICAgICB0b3A6IDUwcHg7XFxuICAgICAgICByaWdodDogMTQwcHg7XFxuICAgICAgICBtYXgtd2lkdGg6IDE0MHB4O1xcbiAgICAgICAgZm9udDogMTJweCAtYXBwbGUtc3lzdGVtLCBCbGlua01hY1N5c3RlbUZvbnQsXFxuICAgICAgICAgICAgU2Vnb2UgVUksIFJvYm90bywgT3h5Z2VuLCBVYnVudHUsIENhbnRhcmVsbCxcXG4gICAgICAgICAgICBGaXJhIFNhbnMsIERyb2lkIFNhbnMsIEhlbHZldGljYSBOZXVlLFxcbiAgICAgICAgICAgIHNhbnMtc2VyaWY7XFxuICAgIH1cXG59XFxuXFxuLmJveCB7XFxuICAgIHdpZHRoOiAyODBweDtcXG4gICAgbWFyZ2luOiAwIGF1dG87XFxuICAgIGJveC1zaGFkb3c6IDAgMS41cHggNXB4IC0ycHggcmdiYSgwLCAwLCAwLCAwLjIpO1xcbiAgICBib3JkZXItcmFkaXVzOiAzcHg7XFxuICAgIHBhZGRpbmc6IDAgMTVweCAwIDE1cHg7XFxufVxcblxcbnRhYmxlIHtcXG4gICAgZm9udC1zaXplOiAxM3B4O1xcbiAgICBmb250LXdlaWdodDogNTAwO1xcbiAgICBjb2xvcjogcmdiKDE4MywgMTg5LCAxOTgpO1xcbiAgICBvdmVyZmxvdzogaGlkZGVuO1xcbiAgICB3aWR0aDogMTAwJTtcXG59XFxuXFxudGQge1xcbiAgICBwb3NpdGlvbjogcmVsYXRpdmU7XFxuICAgIGhlaWdodDogMjBweDtcXG4gICAgbGluZS1oZWlnaHQ6IDIwcHg7XFxufVxcblxcbnRkLnByaWNlIHtcXG4gICAgd2lkdGg6IDMwJTtcXG59XFxuXFxudGQucHJpY2Ugc3BhbiB7XFxuICAgIHBhZGRpbmctbGVmdDogNXB4O1xcbn1cXG5cXG50ZC5xdWFudGl0eSB7XFxuICAgIHdpZHRoOiAzMCU7XFxuICAgIHRleHQtYWxpZ246IHJpZ2h0O1xcbn1cXG5cXG50ZC50aW1lIHtcXG4gICAgd2lkdGg6IDQwJTtcXG4gICAgdGV4dC1hbGlnbjogcmlnaHQ7XFxuICAgIGNvbG9yOiAjOTk5O1xcbiAgICBwYWRkaW5nLXJpZ2h0OiA1cHg7XFxufVxcblxcbnRkLmJ0YyB7XFxuICAgIHdpZHRoOiA0MCU7XFxuICAgIHRleHQtYWxpZ246IHJpZ2h0O1xcbiAgICBwYWRkaW5nLXJpZ2h0OiA1cHg7XFxufVxcblxcbnRkIHNwYW4ge1xcbiAgICBwb3NpdGlvbjogcmVsYXRpdmU7XFxuICAgIHotaW5kZXg6IDI7XFxufVxcblxcbnRhYmxlLmFza3MgLnBlcmNlbnQge1xcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiByZ2JhKDI0NiwgNzAsIDk0LCAwLjIpO1xcbn1cXG5cXG50YWJsZS5iaWRzIC5wZXJjZW50IHtcXG4gICAgYmFja2dyb3VuZC1jb2xvcjogcmdiYSgxNCwgMjAzLCAxMjksIDAuMik7XFxufVxcblxcbnRkIC5wZXJjZW50IHtcXG4gICAgcG9zaXRpb246IGFic29sdXRlO1xcbiAgICB0b3A6IDA7XFxuICAgIGJvdHRvbTogMDtcXG4gICAgcmlnaHQ6IDA7XFxufVxcblxcbi5uZXdlc3Qge1xcbiAgICBib3JkZXItYm90dG9tOiAxcHggc29saWQgI2VlZTtcXG4gICAgbWFyZ2luOiAxNXB4IC0xNXB4O1xcbn1cXG5cXG4uY2FyZC0xMTAge1xcbiAgICB0b3A6IDExMHB4ICFpbXBvcnRhbnQ7XFxuICAgIGxlZnQ6IDcwcHg7XFxufVxcbi8qIFN0eWxlIHBhZ2UgY29udGVudCAtIHVzZSB0aGlzIGlmIHlvdSB3YW50IHRvIHB1c2ggdGhlIHBhZ2UgY29udGVudCB0byB0aGUgcmlnaHQgd2hlbiB5b3Ugb3BlbiB0aGUgc2lkZSBuYXZpZ2F0aW9uICovXFxuI21haW4ge1xcbiAgICB0cmFuc2l0aW9uOiBtYXJnaW4tbGVmdCAuNXM7XFxuICAgIC8qIElmIHlvdSB3YW50IGEgdHJhbnNpdGlvbiBlZmZlY3QgKi9cXG59XFxuXFxuLyogT24gc21hbGxlciBzY3JlZW5zLCB3aGVyZSBoZWlnaHQgaXMgbGVzcyB0aGFuIDQ1MHB4LCBjaGFuZ2UgdGhlIHN0eWxlIG9mIHRoZSBzaWRlbmF2IChsZXNzIHBhZGRpbmcgYW5kIGEgc21hbGxlciBmb250IHNpemUpICovXFxuQG1lZGlhIHNjcmVlbiBhbmQgKG1heC1oZWlnaHQ6IDQ1MHB4KSB7XFxuICAgIC5zaWRlYmFyMSB7XFxuICAgICAgICBwYWRkaW5nLXRvcDogMTVweDtcXG4gICAgfVxcblxcbiAgICAuc2lkZWJhcjEgYSB7XFxuICAgICAgICBmb250LXNpemU6IDE4cHg7XFxuICAgIH1cXG59XFxuXFxuLmJ0bi1jaXJjbGUge1xcbiAgICB3aWR0aDogMzBweDtcXG4gICAgaGVpZ2h0OiAzMHB4O1xcbiAgICBwYWRkaW5nOiA2cHggMHB4O1xcbiAgICBib3JkZXItcmFkaXVzOiAxNXB4O1xcbiAgICBmb250LXNpemU6IDhweDtcXG4gICAgdGV4dC1hbGlnbjogY2VudGVyO1xcbn1cXG5cXG4jY2hhcnRkaXYge1xcbiAgICBtaW4taGVpZ2h0OiAzMDBweDtcXG4gICAgbWF4LWhlaWdodDogNDAwcHg7XFxuICAgIGhlaWdodDogNzB2aDtcXG59XFxuPC9zdHlsZT5cXG5cIl0sXCJzb3VyY2VSb290XCI6XCJcIn1dKTtcbi8vIEV4cG9ydHNcbmV4cG9ydCBkZWZhdWx0IF9fX0NTU19MT0FERVJfRVhQT1JUX19fO1xuIiwiLy8gSW1wb3J0c1xuaW1wb3J0IF9fX0NTU19MT0FERVJfQVBJX1NPVVJDRU1BUF9JTVBPUlRfX18gZnJvbSBcIi4uLy4uL25vZGVfbW9kdWxlcy9sYXJhdmVsLW1peC9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9kaXN0L3J1bnRpbWUvY3NzV2l0aE1hcHBpbmdUb1N0cmluZy5qc1wiO1xuaW1wb3J0IF9fX0NTU19MT0FERVJfQVBJX0lNUE9SVF9fXyBmcm9tIFwiLi4vLi4vbm9kZV9tb2R1bGVzL2xhcmF2ZWwtbWl4L25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2Rpc3QvcnVudGltZS9hcGkuanNcIjtcbnZhciBfX19DU1NfTE9BREVSX0VYUE9SVF9fXyA9IF9fX0NTU19MT0FERVJfQVBJX0lNUE9SVF9fXyhfX19DU1NfTE9BREVSX0FQSV9TT1VSQ0VNQVBfSU1QT1JUX19fKTtcbi8vIE1vZHVsZVxuX19fQ1NTX0xPQURFUl9FWFBPUlRfX18ucHVzaChbbW9kdWxlLmlkLCBcIlxcbi50dmpzLXN0ZC1pbnB1dCB7XFxyXFxuICAgIG1hcmdpbjogNXB4O1xcclxcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiAjMTYxYjI3O1xcclxcbiAgICBib3JkZXI6IDFweCBkb3R0ZWQgIzM1Mzk0MDtcXHJcXG4gICAgaGVpZ2h0OiAyMnB4O1xcclxcbiAgICBib3JkZXItcmFkaXVzOiAzcHg7XFxyXFxuICAgIHBhZGRpbmc6IDJweCAwcHggM3B4IDEwcHg7XFxyXFxuICAgIGNvbG9yOiB3aGl0ZXNtb2tlO1xcclxcbiAgICBmb250LXNpemU6IDEuMmVtO1xcclxcbiAgICBvdXRsaW5lOiBub25lO1xcclxcbiAgICB3aWR0aDogMTAwcHg7XFxufVxcbnNlbGVjdC50dmpzLXN0ZC1pbnB1dCB7XFxyXFxuICAgIGhlaWdodDogMjlweDtcXHJcXG4gICAgLW1vei1hcHBlYXJhbmNlOiBub25lO1xcbn1cXG5zZWxlY3QudHZqcy1zdGQtaW5wdXQgIHtcXHJcXG4gICAgLy9kaXNwbGF5OiBub25lOyAvKmhpZGUgb3JpZ2luYWwgU0VMRUNUIGVsZW1lbnQ6ICovXFxufVxcbi50dmpzLXN0ZC1pbnB1dDo6LW1vei1wbGFjZWhvbGRlciB7XFxyXFxuICAgIGNvbG9yOiAjOGU5MDlhO1xcclxcbiAgICBvcGFjaXR5OiAwLjI1O1xcbn1cXG4udHZqcy1zdGQtaW5wdXQ6LW1zLWlucHV0LXBsYWNlaG9sZGVyIHtcXHJcXG4gICAgY29sb3I6ICM4ZTkwOWE7XFxyXFxuICAgIG9wYWNpdHk6IDAuMjU7XFxufVxcbi50dmpzLXN0ZC1pbnB1dDo6cGxhY2Vob2xkZXIge1xcclxcbiAgICBjb2xvcjogIzhlOTA5YTtcXHJcXG4gICAgb3BhY2l0eTogMC4yNTtcXG59XFxyXFxuXCIsIFwiXCIse1widmVyc2lvblwiOjMsXCJzb3VyY2VzXCI6W1wid2VicGFjazovLy4vc3JjL2NvbXBvbmVudHMvU3RkSW5wdXQudnVlXCJdLFwibmFtZXNcIjpbXSxcIm1hcHBpbmdzXCI6XCI7QUE0Q0E7SUFDQSxXQUFBO0lBQ0EseUJBQUE7SUFDQSwwQkFBQTtJQUNBLFlBQUE7SUFDQSxrQkFBQTtJQUNBLHlCQUFBO0lBQ0EsaUJBQUE7SUFDQSxnQkFBQTtJQUNBLGFBQUE7SUFDQSxZQUFBO0FBQ0E7QUFFQTtJQUNBLFlBQUE7SUFDQSxxQkFBQTtBQUVBO0FBRUE7SUFDQSxlQUFBLEVBQUEsaUNBQUE7QUFDQTtBQUdBO0lBQ0EsY0FBQTtJQUNBLGFBQUE7QUFDQTtBQUhBO0lBQ0EsY0FBQTtJQUNBLGFBQUE7QUFDQTtBQUhBO0lBQ0EsY0FBQTtJQUNBLGFBQUE7QUFDQVwiLFwic291cmNlc0NvbnRlbnRcIjpbXCI8dGVtcGxhdGU+XFxyXFxuICAgIDxzcGFuPlxcclxcbiAgICAgICAgPGlucHV0XFxudi1pZj1cXFwidHlwZT09PSd0ZXh0JyB8fCAhdHlwZVxcXCJcXHJcXG4gICAgICAgICAgICA6dmFsdWU9XFxcInZhbHVlXFxcIlxcbmNsYXNzPVxcXCJ0dmpzLXN0ZC1pbnB1dFxcXCJcXG46c3R5bGU9XFxcInN0eWxlXFxcIlxcclxcbiAgICAgICAgICAgIDpwbGFjZWhvbGRlcj1cXFwibmFtZVxcXCJcXHJcXG4gICAgICAgICAgICBAY2hhbmdlPVxcXCIkZW1pdCgnY2hhbmdlJywgJGV2ZW50LnRhcmdldC52YWx1ZSlcXFwiXFxyXFxuICAgICAgICAgICAgQGlucHV0PVxcXCIkZW1pdCgnaW5wdXQnLCAkZXZlbnQudGFyZ2V0LnZhbHVlKVxcXCJcXG4+XFxyXFxuICAgICAgICA8c2VsZWN0XFxudi1lbHNlLWlmPVxcXCJ0eXBlPT09J3NlbGVjdCdcXFwiXFxyXFxuICAgICAgICAgICAgY2xhc3M9XFxcInR2anMtc3RkLWlucHV0XFxcIlxcbjpzdHlsZT1cXFwic3R5bGVcXFwiXFxyXFxuICAgICAgICAgICAgOnZhbHVlPVxcXCJ2YWx1ZVxcXCJcXHJcXG4gICAgICAgICAgICBAaW5wdXQ9XFxcIiRlbWl0KCdpbnB1dCcsICRldmVudC50YXJnZXQudmFsdWUpXFxcIlxcbj5cXHJcXG4gICAgICAgICAgICA8b3B0aW9uIHYtZm9yPVxcXCJvcHQgaW4gbGlzdFxcXCI+e3sgb3B0IH19PC9vcHRpb24+XFxyXFxuICAgICAgICA8L3NlbGVjdD5cXHJcXG4gICAgPC9zcGFuPlxcclxcbjwvdGVtcGxhdGU+XFxyXFxuXFxyXFxuPHNjcmlwdD5cXHJcXG5leHBvcnQgZGVmYXVsdCB7XFxyXFxuICAgIG5hbWU6ICdTdGRJbnB1dCcsXFxyXFxuICAgIHByb3BzOiBbJ3ZhbHVlJywgJ25hbWUnLCAndHlwZScsICdsaXN0JywgJ2NvbG9ycyddLFxcclxcbiAgICBkYXRhKCkge1xcclxcbiAgICAgICAgcmV0dXJuIHtcXHJcXG4gICAgICAgIH1cXHJcXG4gICAgfSxcXHJcXG4gICAgY29tcHV0ZWQ6IHtcXHJcXG4gICAgICAgIHN0eWxlKCkge1xcclxcbiAgICAgICAgICAgIHJldHVybiB7XFxyXFxuICAgICAgICAgICAgICAgIC8vYmFja2dyb3VuZDogdGhpcy4kcHJvcHMuY29sb3JzLmJhY2ssXFxyXFxuICAgICAgICAgICAgICAgIC8vY29sb3I6IHRoaXMuJHByb3BzLmNvbG9ycy50ZXh0XFxyXFxuICAgICAgICAgICAgfVxcclxcbiAgICAgICAgfVxcclxcbiAgICB9LFxcclxcbiAgICBtZXRob2RzOiB7fVxcclxcbn1cXHJcXG48L3NjcmlwdD5cXHJcXG5cXHJcXG48c3R5bGU+XFxyXFxuLnR2anMtc3RkLWlucHV0IHtcXHJcXG4gICAgbWFyZ2luOiA1cHg7XFxyXFxuICAgIGJhY2tncm91bmQtY29sb3I6ICMxNjFiMjc7XFxyXFxuICAgIGJvcmRlcjogMXB4IGRvdHRlZCAjMzUzOTQwO1xcclxcbiAgICBoZWlnaHQ6IDIycHg7XFxyXFxuICAgIGJvcmRlci1yYWRpdXM6IDNweDtcXHJcXG4gICAgcGFkZGluZzogMnB4IDBweCAzcHggMTBweDtcXHJcXG4gICAgY29sb3I6IHdoaXRlc21va2U7XFxyXFxuICAgIGZvbnQtc2l6ZTogMS4yZW07XFxyXFxuICAgIG91dGxpbmU6IG5vbmU7XFxyXFxuICAgIHdpZHRoOiAxMDBweDtcXHJcXG59XFxyXFxuXFxyXFxuc2VsZWN0LnR2anMtc3RkLWlucHV0IHtcXHJcXG4gICAgaGVpZ2h0OiAyOXB4O1xcclxcbiAgICAtbW96LWFwcGVhcmFuY2U6IG5vbmU7XFxyXFxuXFxyXFxufVxcclxcblxcclxcbnNlbGVjdC50dmpzLXN0ZC1pbnB1dCAge1xcclxcbiAgICAvL2Rpc3BsYXk6IG5vbmU7IC8qaGlkZSBvcmlnaW5hbCBTRUxFQ1QgZWxlbWVudDogKi9cXHJcXG59XFxyXFxuXFxyXFxuXFxyXFxuLnR2anMtc3RkLWlucHV0OjpwbGFjZWhvbGRlciB7XFxyXFxuICAgIGNvbG9yOiAjOGU5MDlhO1xcclxcbiAgICBvcGFjaXR5OiAwLjI1O1xcclxcbn1cXHJcXG48L3N0eWxlPlxcclxcblwiXSxcInNvdXJjZVJvb3RcIjpcIlwifV0pO1xuLy8gRXhwb3J0c1xuZXhwb3J0IGRlZmF1bHQgX19fQ1NTX0xPQURFUl9FWFBPUlRfX187XG4iLCIvLyBJbXBvcnRzXG5pbXBvcnQgX19fQ1NTX0xPQURFUl9BUElfU09VUkNFTUFQX0lNUE9SVF9fXyBmcm9tIFwiLi4vLi4vbm9kZV9tb2R1bGVzL2xhcmF2ZWwtbWl4L25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2Rpc3QvcnVudGltZS9jc3NXaXRoTWFwcGluZ1RvU3RyaW5nLmpzXCI7XG5pbXBvcnQgX19fQ1NTX0xPQURFUl9BUElfSU1QT1JUX19fIGZyb20gXCIuLi8uLi9ub2RlX21vZHVsZXMvbGFyYXZlbC1taXgvbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvZGlzdC9ydW50aW1lL2FwaS5qc1wiO1xudmFyIF9fX0NTU19MT0FERVJfRVhQT1JUX19fID0gX19fQ1NTX0xPQURFUl9BUElfSU1QT1JUX19fKF9fX0NTU19MT0FERVJfQVBJX1NPVVJDRU1BUF9JTVBPUlRfX18pO1xuLy8gTW9kdWxlXG5fX19DU1NfTE9BREVSX0VYUE9SVF9fXy5wdXNoKFttb2R1bGUuaWQsIFwiXFxuLnR2anMteC13aW5kb3cge1xcclxcbiAgICBwb3NpdGlvbjogYWJzb2x1dGU7XFxyXFxuICAgIGJhY2tncm91bmQ6ICMxYjIwMmRlZjtcXHJcXG4gICAgYm9yZGVyLXJhZGl1czogM3B4O1xcclxcbiAgICBwb2ludGVyLWV2ZW50czogYWxsO1xcclxcbiAgICBwYWRkaW5nLWxlZnQ6IDdweDtcXHJcXG4gICAgei1pbmRleDogMTAwO1xcclxcbiAgICBjb2xvcjogI2RlZGRkZDtcXG59XFxuLnR2anMteC13aW5kb3ctaGVhZCB7XFxyXFxuICAgIGZvbnQtc2l6ZTogMmVtO1xcclxcbiAgICAtd2Via2l0LXVzZXItc2VsZWN0OiBub25lO1xcclxcbiAgICAgICAtbW96LXVzZXItc2VsZWN0OiBub25lO1xcclxcbiAgICAgICAgLW1zLXVzZXItc2VsZWN0OiBub25lO1xcclxcbiAgICAgICAgICAgIHVzZXItc2VsZWN0OiBub25lO1xcclxcbiAgICBkaXNwbGF5OiBmbGV4O1xcclxcbiAgICBmbGV4LWRpcmVjdGlvbjogcm93O1xcclxcbiAgICBmbGV4LXdyYXA6IG5vd3JhcDtcXHJcXG4gICAganVzdGlmeS1jb250ZW50OiBmbGV4LXN0YXJ0O1xcclxcbiAgICBhbGlnbi1jb250ZW50OiBjZW50ZXI7XFxyXFxuICAgIGFsaWduLWl0ZW1zOiBjZW50ZXI7XFxyXFxuICAgIGhlaWdodDogMzZweDtcXHJcXG4gICAgcGFkZGluZzogMTBweDtcXHJcXG4gICAgY3Vyc29yOiAtd2Via2l0LWdyYWI7XFxyXFxuICAgIGN1cnNvcjogZ3JhYjtcXG59XFxuLnR2anMteC13aW5kb3ctYm9keSB7XFxyXFxuICAgIHBhZGRpbmc6IDEwcHg7XFxyXFxuICAgIGZvbnQtc2l6ZTogMS4xZW07XFxufVxcbi50dmpzLXgtd2luZG93LXRpdGxlIHtcXHJcXG4gICAgd2lkdGg6IDMwMHB4O1xcclxcbiAgICAtd2Via2l0LXVzZXItc2VsZWN0OiBub25lO1xcclxcbiAgICAgICAtbW96LXVzZXItc2VsZWN0OiBub25lO1xcclxcbiAgICAgICAgLW1zLXVzZXItc2VsZWN0OiBub25lO1xcclxcbiAgICAgICAgICAgIHVzZXItc2VsZWN0OiBub25lO1xcbn1cXG4udHZqcy14LXdpbmRvdy1jbG9zZSB7XFxyXFxuICAgIHdpZHRoOiAyNnB4O1xcclxcbiAgICBjdXJzb3I6IHBvaW50ZXI7XFxyXFxuICAgIG1hcmdpbjogLTFlbTtcXHJcXG4gICAgcGFkZGluZzogMWVtO1xcclxcbiAgICBmb250LXNpemU6IDAuNzVlbTtcXG59XFxyXFxuXCIsIFwiXCIse1widmVyc2lvblwiOjMsXCJzb3VyY2VzXCI6W1wid2VicGFjazovLy4vc3JjL2NvbXBvbmVudHMvV2luZG93LnZ1ZVwiXSxcIm5hbWVzXCI6W10sXCJtYXBwaW5nc1wiOlwiO0FBZ0VBO0lBQ0Esa0JBQUE7SUFDQSxxQkFBQTtJQUNBLGtCQUFBO0lBQ0EsbUJBQUE7SUFDQSxpQkFBQTtJQUNBLFlBQUE7SUFDQSxjQUFBO0FBQ0E7QUFDQTtJQUNBLGNBQUE7SUFDQSx5QkFBQTtPQUFBLHNCQUFBO1FBQUEscUJBQUE7WUFBQSxpQkFBQTtJQUNBLGFBQUE7SUFDQSxtQkFBQTtJQUNBLGlCQUFBO0lBQ0EsMkJBQUE7SUFDQSxxQkFBQTtJQUNBLG1CQUFBO0lBQ0EsWUFBQTtJQUNBLGFBQUE7SUFDQSxvQkFBQTtJQUFBLFlBQUE7QUFDQTtBQUVBO0lBQ0EsYUFBQTtJQUNBLGdCQUFBO0FBQ0E7QUFDQTtJQUNBLFlBQUE7SUFDQSx5QkFBQTtPQUFBLHNCQUFBO1FBQUEscUJBQUE7WUFBQSxpQkFBQTtBQUNBO0FBQ0E7SUFDQSxXQUFBO0lBQ0EsZUFBQTtJQUNBLFlBQUE7SUFDQSxZQUFBO0lBQ0EsaUJBQUE7QUFDQVwiLFwic291cmNlc0NvbnRlbnRcIjpbXCI8dGVtcGxhdGU+XFxyXFxuICAgIDxkaXZcXG5yZWY9XFxcIndpblxcXCJcXG5jbGFzcz1cXFwidHZqcy14LXdpbmRvd1xcXCJcXG46c3R5bGU9XFxcInN0eWxlXFxcIlxcbj5cXHJcXG4gICAgICAgIDxkaXYgY2xhc3M9XFxcInR2anMteC13aW5kb3ctaGVhZFxcXCI+XFxyXFxuICAgICAgICAgICAgPGRpdlxcbmNsYXNzPVxcXCJ0dmpzLXgtd2luZG93LXRpdGxlXFxcIlxcclxcbiAgICAgICAgICAgICAgICBAbW91c2Vkb3duPVxcXCJvbk1vdXNlRG93blxcXCJcXG4+XFxyXFxuICAgICAgICAgICAgICAgIHt7IHRpdGxlIH19XFxyXFxuICAgICAgICAgICAgPC9kaXY+XFxyXFxuICAgICAgICAgICAgPGRpdlxcbmNsYXNzPVxcXCJ0dmpzLXgtd2luZG93LWNsb3NlXFxcIlxcclxcbiAgICAgICAgICAgICAgICBAY2xpY2s9XFxcIiRlbWl0KCdjbG9zZScpXFxcIlxcbj5cXHJcXG4gICAgICAgICAgICAgICAg4pWzXFxyXFxuICAgICAgICAgICAgPC9kaXY+XFxyXFxuICAgICAgICA8L2Rpdj5cXHJcXG4gICAgICAgIDxkaXYgY2xhc3M9XFxcInR2anMteC13aW5kb3ctYm9keVxcXCI+XFxyXFxuICAgICAgICAgICAgPHNsb3QgLz5cXHJcXG4gICAgICAgIDwvZGl2PlxcclxcbiAgICA8L2Rpdj5cXHJcXG48L3RlbXBsYXRlPlxcclxcbjxzY3JpcHQ+XFxyXFxuXFxyXFxuaW1wb3J0IERyYWdnIGZyb20gJy4vZHJhZ2cuanMnXFxyXFxuXFxyXFxuZXhwb3J0IGRlZmF1bHQge1xcclxcbiAgICBuYW1lOiAnV2luZG93JyxcXHJcXG4gICAgbWl4aW5zOiBbRHJhZ2ddLFxcclxcbiAgICBwcm9wczogWyd0aXRsZScsICd0diddLFxcclxcbiAgICBkYXRhKCkge1xcclxcbiAgICAgICAgcmV0dXJuIHtcXHJcXG4gICAgICAgICAgICB3dzogMCxcXHJcXG4gICAgICAgICAgICB3aDogMCxcXHJcXG4gICAgICAgICAgICB4OiAwLFxcclxcbiAgICAgICAgICAgIHk6IDBcXHJcXG4gICAgICAgIH1cXHJcXG4gICAgfSxcXHJcXG4gICAgY29tcHV0ZWQ6IHtcXHJcXG4gICAgICAgIHN0eWxlKCkge1xcclxcbiAgICAgICAgICAgIHJldHVybiB7XFxyXFxuICAgICAgICAgICAgICAgIHRvcDogYCR7dGhpcy55fXB4YCxcXHJcXG4gICAgICAgICAgICAgICAgbGVmdDogYCR7dGhpcy54fXB4YFxcclxcbiAgICAgICAgICAgIH1cXHJcXG4gICAgICAgIH0sXFxyXFxuICAgICAgICB0dncoKSB7XFxyXFxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuJHByb3BzLnR2LndpZHRoXFxyXFxuICAgICAgICB9LFxcclxcbiAgICAgICAgdHZoKCkge1xcclxcbiAgICAgICAgICAgIHJldHVybiB0aGlzLiRwcm9wcy50di5oZWlnaHRcXHJcXG4gICAgICAgIH1cXHJcXG4gICAgfSxcXHJcXG4gICAgbW91bnRlZCgpIHtcXHJcXG4gICAgICAgIHRoaXMud3cgPSB0aGlzLiRyZWZzLndpbi5jbGllbnRXaWR0aFxcclxcbiAgICAgICAgdGhpcy53aCA9IHRoaXMuJHJlZnMud2luLmNsaWVudEhlaWdodFxcclxcbiAgICAgICAgdGhpcy54ID0gdGhpcy50dncgKiAwLjUgLSB0aGlzLnd3ICogMC41XFxyXFxuICAgICAgICB0aGlzLnkgPSB0aGlzLnR2aCAqIDAuNSAtIHRoaXMud2ggKiAwLjVcXHJcXG4gICAgfVxcclxcbn1cXHJcXG48L3NjcmlwdD5cXHJcXG48c3R5bGU+XFxyXFxuLnR2anMteC13aW5kb3cge1xcclxcbiAgICBwb3NpdGlvbjogYWJzb2x1dGU7XFxyXFxuICAgIGJhY2tncm91bmQ6ICMxYjIwMmRlZjtcXHJcXG4gICAgYm9yZGVyLXJhZGl1czogM3B4O1xcclxcbiAgICBwb2ludGVyLWV2ZW50czogYWxsO1xcclxcbiAgICBwYWRkaW5nLWxlZnQ6IDdweDtcXHJcXG4gICAgei1pbmRleDogMTAwO1xcclxcbiAgICBjb2xvcjogI2RlZGRkZDtcXHJcXG59XFxyXFxuLnR2anMteC13aW5kb3ctaGVhZCB7XFxyXFxuICAgIGZvbnQtc2l6ZTogMmVtO1xcclxcbiAgICB1c2VyLXNlbGVjdDogbm9uZTtcXHJcXG4gICAgZGlzcGxheTogZmxleDtcXHJcXG4gICAgZmxleC1kaXJlY3Rpb246IHJvdztcXHJcXG4gICAgZmxleC13cmFwOiBub3dyYXA7XFxyXFxuICAgIGp1c3RpZnktY29udGVudDogZmxleC1zdGFydDtcXHJcXG4gICAgYWxpZ24tY29udGVudDogY2VudGVyO1xcclxcbiAgICBhbGlnbi1pdGVtczogY2VudGVyO1xcclxcbiAgICBoZWlnaHQ6IDM2cHg7XFxyXFxuICAgIHBhZGRpbmc6IDEwcHg7XFxyXFxuICAgIGN1cnNvcjogZ3JhYjtcXHJcXG59XFxyXFxuXFxyXFxuLnR2anMteC13aW5kb3ctYm9keSB7XFxyXFxuICAgIHBhZGRpbmc6IDEwcHg7XFxyXFxuICAgIGZvbnQtc2l6ZTogMS4xZW07XFxyXFxufVxcclxcbi50dmpzLXgtd2luZG93LXRpdGxlIHtcXHJcXG4gICAgd2lkdGg6IDMwMHB4O1xcclxcbiAgICB1c2VyLXNlbGVjdDogbm9uZTtcXHJcXG59XFxyXFxuLnR2anMteC13aW5kb3ctY2xvc2Uge1xcclxcbiAgICB3aWR0aDogMjZweDtcXHJcXG4gICAgY3Vyc29yOiBwb2ludGVyO1xcclxcbiAgICBtYXJnaW46IC0xZW07XFxyXFxuICAgIHBhZGRpbmc6IDFlbTtcXHJcXG4gICAgZm9udC1zaXplOiAwLjc1ZW07XFxyXFxufVxcclxcbjwvc3R5bGU+XFxyXFxuXCJdLFwic291cmNlUm9vdFwiOlwiXCJ9XSk7XG4vLyBFeHBvcnRzXG5leHBvcnQgZGVmYXVsdCBfX19DU1NfTE9BREVSX0VYUE9SVF9fXztcbiIsIi8vIEltcG9ydHNcbmltcG9ydCBfX19DU1NfTE9BREVSX0FQSV9TT1VSQ0VNQVBfSU1QT1JUX19fIGZyb20gXCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvbGFyYXZlbC1taXgvbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvZGlzdC9ydW50aW1lL2Nzc1dpdGhNYXBwaW5nVG9TdHJpbmcuanNcIjtcbmltcG9ydCBfX19DU1NfTE9BREVSX0FQSV9JTVBPUlRfX18gZnJvbSBcIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9sYXJhdmVsLW1peC9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9kaXN0L3J1bnRpbWUvYXBpLmpzXCI7XG52YXIgX19fQ1NTX0xPQURFUl9FWFBPUlRfX18gPSBfX19DU1NfTE9BREVSX0FQSV9JTVBPUlRfX18oX19fQ1NTX0xPQURFUl9BUElfU09VUkNFTUFQX0lNUE9SVF9fXyk7XG4vLyBNb2R1bGVcbl9fX0NTU19MT0FERVJfRVhQT1JUX19fLnB1c2goW21vZHVsZS5pZCwgXCJcXG4uaC1zcGxpdHRlcltkYXRhLXYtMTg5ZmNjYWRdIHtcXHJcXG4gICAgcG9zaXRpb246IGFic29sdXRlO1xcclxcbiAgICBsZWZ0OiAwO1xcclxcbiAgICBoZWlnaHQ6IDVweDtcXHJcXG4gICAgbWFyZ2luLXRvcDogLTJweDtcXHJcXG4gICAgd2lkdGg6IDEwMCU7XFxyXFxuICAgIHotaW5kZXg6IDE7XFxyXFxuICAgIGJhY2tncm91bmQtY29sb3I6ICMzZWU0YWZiNTtcXHJcXG4gICAgb3BhY2l0eTogMDtcXHJcXG4gICAgcG9pbnRlci1ldmVudHM6IGFsbDtcXG59XFxuLmgtc3BsaXR0ZXJbZGF0YS12LTE4OWZjY2FkXTpob3ZlciB7XFxyXFxuICAgIGN1cnNvcjogcm93LXJlc2l6ZTtcXHJcXG4gICAgb3BhY2l0eTogMTtcXG59XFxyXFxuXCIsIFwiXCIse1widmVyc2lvblwiOjMsXCJzb3VyY2VzXCI6W1wid2VicGFjazovLy4vc3JjL2V4dGVuc2lvbnMvZ3JpZC1yZXNpemUvU3BsaXR0ZXIudnVlXCJdLFwibmFtZXNcIjpbXSxcIm1hcHBpbmdzXCI6XCI7QUFrRUE7SUFDQSxrQkFBQTtJQUNBLE9BQUE7SUFDQSxXQUFBO0lBQ0EsZ0JBQUE7SUFDQSxXQUFBO0lBQ0EsVUFBQTtJQUNBLDJCQUFBO0lBQ0EsVUFBQTtJQUNBLG1CQUFBO0FBQ0E7QUFDQTtJQUNBLGtCQUFBO0lBQ0EsVUFBQTtBQUNBXCIsXCJzb3VyY2VzQ29udGVudFwiOltcIjx0ZW1wbGF0ZT5cXHJcXG4gICAgPHNwYW5cXG5jbGFzcz1cXFwiaC1zcGxpdHRlclxcXCJcXHJcXG4gICAgICAgIDpzdHlsZT1cXFwiaHNfc3R5bGVcXFwiXFxuQG1vdXNlZG93bj1cXFwiaHNfbW91c2Vkb3duXFxcIlxcbi8+XFxyXFxuPC90ZW1wbGF0ZT5cXHJcXG48c2NyaXB0PlxcclxcblxcclxcbmltcG9ydCBVdGlscyBmcm9tICcuL3V0aWxzLmpzJ1xcclxcblxcclxcbmV4cG9ydCBkZWZhdWx0IHtcXHJcXG4gICAgbmFtZTogJ1NwbGl0dGVyJyxcXHJcXG4gICAgcHJvcHM6IFsnaWQnLCAnbWFpbicsICdkYycsICd0dicsICdkYXRhJ10sXFxyXFxuICAgIGNvbXB1dGVkOiB7XFxyXFxuICAgICAgICBoc19zdHlsZSgpIHtcXHJcXG4gICAgICAgICAgICByZXR1cm4ge1xcclxcbiAgICAgICAgICAgICAgICBkcmFnOiBudWxsLFxcclxcbiAgICAgICAgICAgICAgICB0b3A6IHRoaXMuZGF0YS5ncmlkMi5vZmZzZXQgKyAncHgnLFxcclxcbiAgICAgICAgICAgICAgICAvL2JhY2tncm91bmRDb2xvcjogdGhpcy5jb2xvcnMuc3BsaXR0ZXJcXHJcXG4gICAgICAgICAgICB9XFxyXFxuICAgICAgICB9LFxcclxcbiAgICB9LFxcclxcbiAgICBtb3VudGVkKCkge1xcclxcbiAgICAgICAgdGhpcy5NSU5fSEVJR0hUID0gdGhpcy5kYXRhLnNldHQubWluX2hlaWdodCB8fCAyMFxcclxcbiAgICB9LFxcclxcbiAgICBtZXRob2RzOiB7XFxyXFxuICAgICAgICBoc19tb3VzZWRvd24oZSkge1xcclxcbiAgICAgICAgICAgIHRoaXMuZHJhZyA9IHtcXHJcXG4gICAgICAgICAgICAgICAgdHlwZTogJ2hzJyxcXHJcXG4gICAgICAgICAgICAgICAgeTogZS5jbGllbnRZLFxcclxcbiAgICAgICAgICAgICAgICBoMTogdGhpcy5kYXRhLmdyaWQxLmhlaWdodCxcXHJcXG4gICAgICAgICAgICAgICAgaDI6IHRoaXMuZGF0YS5ncmlkMi5oZWlnaHRcXHJcXG4gICAgICAgICAgICB9XFxyXFxuICAgICAgICAgICAgVXRpbHMuYWRkX3N0eWxlKCdkaXNhYmxlLXVzZXItc2VsZWN0JywgYGJvZHkgKiB7XFxyXFxuICAgICAgICAgICAgICAgIHVzZXItc2VsZWN0OiBub25lO1xcclxcbiAgICAgICAgICAgIH1cXHJcXG4gICAgICAgICAgICAudHJhZGluZy12dWUtY2hhcnQge1xcclxcbiAgICAgICAgICAgICAgICBwb2ludGVyLWV2ZW50czogbm9uZTtcXHJcXG4gICAgICAgICAgICB9YClcXHJcXG4gICAgICAgIH0sXFxyXFxuICAgICAgICBoc19tb3VzZXVwKGUpIHtcXHJcXG4gICAgICAgICAgICB0aGlzLmRyYWcgPSBudWxsXFxyXFxuICAgICAgICAgICAgVXRpbHMucmVtX3N0eWxlKCdkaXNhYmxlLXVzZXItc2VsZWN0JylcXHJcXG4gICAgICAgIH0sXFxyXFxuICAgICAgICBoc19tb3VzZW1vdmUoZSkge1xcclxcbiAgICAgICAgICAgIGlmICh0aGlzLmRyYWcpIHtcXHJcXG4gICAgICAgICAgICAgICAgbGV0IG9mZiA9IGUuY2xpZW50WSAtIHRoaXMuZHJhZy55XFxyXFxuICAgICAgICAgICAgICAgIGxldCBuZXdfaDEgPSB0aGlzLmRyYWcuaDEgKyBvZmZcXHJcXG4gICAgICAgICAgICAgICAgbGV0IG5ld19oMiA9IHRoaXMuZHJhZy5oMiAtIG9mZlxcclxcbiAgICAgICAgICAgICAgICBpZiAobmV3X2gxID4gdGhpcy5NSU5fSEVJR0hUICYmXFxyXFxuICAgICAgICAgICAgICAgICAgICBuZXdfaDIgPiB0aGlzLk1JTl9IRUlHSFQpIHtcXHJcXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZGF0YS5ncmlkMS5oZWlnaHQgPSBuZXdfaDFcXHJcXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZGF0YS5ncmlkMi5oZWlnaHQgPSBuZXdfaDJcXHJcXG4gICAgICAgICAgICAgICAgfVxcclxcbiAgICAgICAgICAgICAgICB0aGlzLm1haW4uY2FsY19oZWlnaHRzKClcXHJcXG4gICAgICAgICAgICB9XFxyXFxuICAgICAgICB9LFxcclxcbiAgICAgICAgaHNfbW91c2VsZWF2ZShlKSB7XFxyXFxuICAgICAgICAgICAgdGhpcy5kcmFnID0gbnVsbFxcclxcbiAgICAgICAgICAgIFV0aWxzLnJlbV9zdHlsZSgnZGlzYWJsZS11c2VyLXNlbGVjdCcpXFxyXFxuICAgICAgICB9XFxyXFxuICAgIH1cXHJcXG59XFxyXFxuPC9zY3JpcHQ+XFxyXFxuPHN0eWxlIHNjb3BlZD5cXHJcXG4uaC1zcGxpdHRlciB7XFxyXFxuICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTtcXHJcXG4gICAgbGVmdDogMDtcXHJcXG4gICAgaGVpZ2h0OiA1cHg7XFxyXFxuICAgIG1hcmdpbi10b3A6IC0ycHg7XFxyXFxuICAgIHdpZHRoOiAxMDAlO1xcclxcbiAgICB6LWluZGV4OiAxO1xcclxcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiAjM2VlNGFmYjU7XFxyXFxuICAgIG9wYWNpdHk6IDA7XFxyXFxuICAgIHBvaW50ZXItZXZlbnRzOiBhbGw7XFxyXFxufVxcclxcbi5oLXNwbGl0dGVyOmhvdmVyIHtcXHJcXG4gICAgY3Vyc29yOiByb3ctcmVzaXplO1xcclxcbiAgICBvcGFjaXR5OiAxO1xcclxcbn1cXHJcXG48L3N0eWxlPlxcclxcblwiXSxcInNvdXJjZVJvb3RcIjpcIlwifV0pO1xuLy8gRXhwb3J0c1xuZXhwb3J0IGRlZmF1bHQgX19fQ1NTX0xPQURFUl9FWFBPUlRfX187XG4iLCIvLyBJbXBvcnRzXG5pbXBvcnQgX19fQ1NTX0xPQURFUl9BUElfU09VUkNFTUFQX0lNUE9SVF9fXyBmcm9tIFwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2xhcmF2ZWwtbWl4L25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2Rpc3QvcnVudGltZS9jc3NXaXRoTWFwcGluZ1RvU3RyaW5nLmpzXCI7XG5pbXBvcnQgX19fQ1NTX0xPQURFUl9BUElfSU1QT1JUX19fIGZyb20gXCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvbGFyYXZlbC1taXgvbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvZGlzdC9ydW50aW1lL2FwaS5qc1wiO1xudmFyIF9fX0NTU19MT0FERVJfRVhQT1JUX19fID0gX19fQ1NTX0xPQURFUl9BUElfSU1QT1JUX19fKF9fX0NTU19MT0FERVJfQVBJX1NPVVJDRU1BUF9JTVBPUlRfX18pO1xuLy8gTW9kdWxlXG5fX19DU1NfTE9BREVSX0VYUE9SVF9fXy5wdXNoKFttb2R1bGUuaWQsIFwiXFxuLnR2anMteC13aW5kb3cuYWRkLXdpbltkYXRhLXYtNTM0MDhhYzddIHtcXG4gICAgcGFkZGluZy1ib3R0b206IDMwcHg7XFxuICAgIGJvcmRlcjogMXB4IHNvbGlkICM4MDgwODAxMTtcXG59XFxuLmFkZC13aW4tbGlzdFtkYXRhLXYtNTM0MDhhYzddIHtcXG4gICAgaGVpZ2h0OiAzMDBweDtcXG4gICAgb3ZlcmZsb3cteDogaGlkZGVuO1xcbiAgICBvdmVyZmxvdy15OiBhdXRvO1xcbiAgICAtd2Via2l0LXVzZXItc2VsZWN0OiBub25lO1xcbiAgICAgICAtbW96LXVzZXItc2VsZWN0OiBub25lO1xcbiAgICAgICAgLW1zLXVzZXItc2VsZWN0OiBub25lO1xcbiAgICAgICAgICAgIHVzZXItc2VsZWN0OiBub25lO1xcbn1cXG4vKiBIaWRlIHNjcm9sbGJhciBmb3IgQ2hyb21lLCBTYWZhcmkgYW5kIE9wZXJhICovXFxuLmFkZC13aW4tbGlzdFtkYXRhLXYtNTM0MDhhYzddOjotd2Via2l0LXNjcm9sbGJhciB7XFxuICBkaXNwbGF5OiBub25lO1xcbn1cXG5cXG4vKiBIaWRlIHNjcm9sbGJhciBmb3IgSUUsIEVkZ2UgYW5kIEZpcmVmb3ggKi9cXG4uYWRkLXdpbi1saXN0W2RhdGEtdi01MzQwOGFjN10ge1xcbiAgLW1zLW92ZXJmbG93LXN0eWxlOiBub25lOyAgLyogSUUgYW5kIEVkZ2UgKi9cXG4gIHNjcm9sbGJhci13aWR0aDogbm9uZTsgIC8qIEZpcmVmb3ggKi9cXG59XFxuLmFkZC13aW4taXRlbVtkYXRhLXYtNTM0MDhhYzddIHtcXG4gICAgY29sb3I6ICNmZmZmZmY4ODtcXG4gICAgd2lkdGg6IDEwMCU7XFxuICAgIHBhZGRpbmc6IDVweDtcXG4gICAgY3Vyc29yOiBwb2ludGVyO1xcbn1cXG4uYWRkLXdpbi1pdGVtW2RhdGEtdi01MzQwOGFjN106aG92ZXIge1xcbiAgICBiYWNrZ3JvdW5kOiAjODg4ODg4MjI7XFxuICAgIGNvbG9yOiAjZmZmZmZmZmY7XFxufVxcbi5hZGQtd2luLWl0ZW0tZGVzY1tkYXRhLXYtNTM0MDhhYzddIHtcXG4gICAgY29sb3I6ICNmZmZmZmYzMztcXG4gICAgbWFyZ2luLWxlZnQ6IDNweDtcXG59XFxuLmFkZC13aW4taXRlbTpob3ZlciAuYWRkLXdpbi1pdGVtLWRlc2NbZGF0YS12LTUzNDA4YWM3XSB7XFxuICAgIGNvbG9yOiAjZmZmZmZmNDQ7XFxufVxcbi5hZGQtd2luLWVtcHR5W2RhdGEtdi01MzQwOGFjN10ge1xcbiAgICBvcGFjaXR5OiAwLjU7XFxufVxcblwiLCBcIlwiLHtcInZlcnNpb25cIjozLFwic291cmNlc1wiOltcIndlYnBhY2s6Ly8uL3NyYy9leHRlbnNpb25zL2xlZ2VuZC1idXR0b25zL0FkZFdpbi52dWVcIl0sXCJuYW1lc1wiOltdLFwibWFwcGluZ3NcIjpcIjtBQWdEQTtJQUNBLG9CQUFBO0lBQ0EsMkJBQUE7QUFDQTtBQUNBO0lBQ0EsYUFBQTtJQUNBLGtCQUFBO0lBQ0EsZ0JBQUE7SUFDQSx5QkFBQTtPQUFBLHNCQUFBO1FBQUEscUJBQUE7WUFBQSxpQkFBQTtBQUNBO0FBQ0EsZ0RBQUE7QUFDQTtFQUNBLGFBQUE7QUFDQTs7QUFFQSw0Q0FBQTtBQUNBO0VBQ0Esd0JBQUEsR0FBQSxnQkFBQTtFQUNBLHFCQUFBLEdBQUEsWUFBQTtBQUNBO0FBQ0E7SUFDQSxnQkFBQTtJQUNBLFdBQUE7SUFDQSxZQUFBO0lBQ0EsZUFBQTtBQUNBO0FBQ0E7SUFDQSxxQkFBQTtJQUNBLGdCQUFBO0FBQ0E7QUFDQTtJQUNBLGdCQUFBO0lBQ0EsZ0JBQUE7QUFDQTtBQUNBO0lBQ0EsZ0JBQUE7QUFDQTtBQUNBO0lBQ0EsWUFBQTtBQUNBXCIsXCJzb3VyY2VzQ29udGVudFwiOltcIjx0ZW1wbGF0ZT5cXG4gICAgPHdpbmRvdyB0aXRsZT1cXFwiQWRkIEluZGljYXRvclxcXCIgY2xhc3M9XFxcImFkZC13aW5cXFwiIDp0dj1cXFwidHZcXFwiIEBjbG9zZT1cXFwib25fY2xvc2VcXFwiPlxcbiAgICAgICAgPGRpdiBjbGFzcz1cXFwiYWRkLXdpbi1saXN0XFxcIj5cXG4gICAgICAgICAgICA8ZGl2IHYtZm9yPVxcXCJvdiBvZiBvdnNcXFwiIGNsYXNzPVxcXCJhZGQtd2luLWl0ZW1cXFwiIEBjbGljaz1cXFwib25fY2xpY2sob3YubmFtZSlcXFwiPlxcbiAgICAgICAgICAgICAgICA8c3Bhbj57eyBvdi5uYW1lIH19PC9zcGFuPlxcbiAgICAgICAgICAgICAgICA8c3BhbiBjbGFzcz1cXFwiYWRkLXdpbi1pdGVtLWRlc2NcXFwiPlxcbiAgICAgICAgICAgICAgICAgICAge3sgb3YubWV0aG9kcy5tZXRhX2luZm8oKS5kZXNjIH19XFxuICAgICAgICAgICAgICAgIDwvc3Bhbj5cXG4gICAgICAgICAgICA8L2Rpdj5cXG4gICAgICAgIDwvZGl2PlxcbiAgICA8L3dpbmRvdz5cXG48L3RlbXBsYXRlPlxcbjxzY3JpcHQ+XFxuXFxuaW1wb3J0IFdpbmRvdyBmcm9tICcuLi8uLi9jb21wb25lbnRzL1dpbmRvdy52dWUnXFxuXFxuZXhwb3J0IGRlZmF1bHQge1xcbiAgICBuYW1lOiAnQWRkV2luJyxcXG4gICAgY29tcG9uZW50czogeyBXaW5kb3cgfSxcXG4gICAgcHJvcHM6IFsnaWQnLCAnbWFpbicsICdkYycsICd0dicsICdkYXRhJ10sXFxuICAgIGRhdGEoKSB7XFxuICAgICAgICByZXR1cm4ge1xcbiAgICAgICAgICAgIG92czogdGhpcy50di5vdmVybGF5cy5maWx0ZXIoeCA9PiB4Lm1ldGhvZHMuY2FsYylcXG4gICAgICAgIH1cXG4gICAgfSxcXG4gICAgY29tcHV0ZWQ6IHtcXG4gICAgICAgIHNldHQoKSB7XFxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuJHByb3BzLmRhdGEub3Yuc2V0dGluZ3NcXG4gICAgICAgIH1cXG4gICAgfSxcXG4gICAgbW91bnRlZCgpIHtcXG4gICAgfSxcXG4gICAgbWV0aG9kczoge1xcbiAgICAgICAgb25fY2xvc2UoKSB7XFxuICAgICAgICAgICAgdGhpcy4kcHJvcHMubWFpbi5yZW1vdmVfd2lkZ2V0KHRoaXMuJHByb3BzLmlkKVxcbiAgICAgICAgfSxcXG4gICAgICAgIG9uX2NsaWNrKG5hbWUpIHtcXG4gICAgICAgICAgICB0aGlzLm9uX2Nsb3NlKClcXG4gICAgICAgICAgICB0aGlzLm1haW4uYWRkX292ZXJsYXkoe1xcbiAgICAgICAgICAgICAgICBzaWRlOiB0aGlzLmRhdGEudHlwZSxcXG4gICAgICAgICAgICAgICAgaW5kZXg6IHRoaXMuZGF0YS5pbmRleCxcXG4gICAgICAgICAgICAgICAgdHlwZTogbmFtZVxcbiAgICAgICAgICAgIH0pXFxuICAgICAgICB9XFxuICAgIH1cXG59XFxuPC9zY3JpcHQ+XFxuPHN0eWxlIHNjb3BlZD5cXG4udHZqcy14LXdpbmRvdy5hZGQtd2luIHtcXG4gICAgcGFkZGluZy1ib3R0b206IDMwcHg7XFxuICAgIGJvcmRlcjogMXB4IHNvbGlkICM4MDgwODAxMTtcXG59XFxuLmFkZC13aW4tbGlzdCB7XFxuICAgIGhlaWdodDogMzAwcHg7XFxuICAgIG92ZXJmbG93LXg6IGhpZGRlbjtcXG4gICAgb3ZlcmZsb3cteTogYXV0bztcXG4gICAgdXNlci1zZWxlY3Q6IG5vbmU7XFxufVxcbi8qIEhpZGUgc2Nyb2xsYmFyIGZvciBDaHJvbWUsIFNhZmFyaSBhbmQgT3BlcmEgKi9cXG4uYWRkLXdpbi1saXN0Ojotd2Via2l0LXNjcm9sbGJhciB7XFxuICBkaXNwbGF5OiBub25lO1xcbn1cXG5cXG4vKiBIaWRlIHNjcm9sbGJhciBmb3IgSUUsIEVkZ2UgYW5kIEZpcmVmb3ggKi9cXG4uYWRkLXdpbi1saXN0IHtcXG4gIC1tcy1vdmVyZmxvdy1zdHlsZTogbm9uZTsgIC8qIElFIGFuZCBFZGdlICovXFxuICBzY3JvbGxiYXItd2lkdGg6IG5vbmU7ICAvKiBGaXJlZm94ICovXFxufVxcbi5hZGQtd2luLWl0ZW0ge1xcbiAgICBjb2xvcjogI2ZmZmZmZjg4O1xcbiAgICB3aWR0aDogMTAwJTtcXG4gICAgcGFkZGluZzogNXB4O1xcbiAgICBjdXJzb3I6IHBvaW50ZXI7XFxufVxcbi5hZGQtd2luLWl0ZW06aG92ZXIge1xcbiAgICBiYWNrZ3JvdW5kOiAjODg4ODg4MjI7XFxuICAgIGNvbG9yOiAjZmZmZmZmZmY7XFxufVxcbi5hZGQtd2luLWl0ZW0tZGVzYyB7XFxuICAgIGNvbG9yOiAjZmZmZmZmMzM7XFxuICAgIG1hcmdpbi1sZWZ0OiAzcHg7XFxufVxcbi5hZGQtd2luLWl0ZW06aG92ZXIgLmFkZC13aW4taXRlbS1kZXNjIHtcXG4gICAgY29sb3I6ICNmZmZmZmY0NDtcXG59XFxuLmFkZC13aW4tZW1wdHkge1xcbiAgICBvcGFjaXR5OiAwLjU7XFxufVxcbjwvc3R5bGU+XFxuXCJdLFwic291cmNlUm9vdFwiOlwiXCJ9XSk7XG4vLyBFeHBvcnRzXG5leHBvcnQgZGVmYXVsdCBfX19DU1NfTE9BREVSX0VYUE9SVF9fXztcbiIsIi8vIEltcG9ydHNcbmltcG9ydCBfX19DU1NfTE9BREVSX0FQSV9TT1VSQ0VNQVBfSU1QT1JUX19fIGZyb20gXCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvbGFyYXZlbC1taXgvbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvZGlzdC9ydW50aW1lL2Nzc1dpdGhNYXBwaW5nVG9TdHJpbmcuanNcIjtcbmltcG9ydCBfX19DU1NfTE9BREVSX0FQSV9JTVBPUlRfX18gZnJvbSBcIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9sYXJhdmVsLW1peC9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9kaXN0L3J1bnRpbWUvYXBpLmpzXCI7XG52YXIgX19fQ1NTX0xPQURFUl9FWFBPUlRfX18gPSBfX19DU1NfTE9BREVSX0FQSV9JTVBPUlRfX18oX19fQ1NTX0xPQURFUl9BUElfU09VUkNFTUFQX0lNUE9SVF9fXyk7XG4vLyBNb2R1bGVcbl9fX0NTU19MT0FERVJfRVhQT1JUX19fLnB1c2goW21vZHVsZS5pZCwgXCJcXG4udHZqcy14LXdpbmRvdy5zZXR0LXdpbltkYXRhLXYtNWQyMjNiMGVdIHtcXG4gICAgcGFkZGluZy1ib3R0b206IDMwcHg7XFxuICAgIGJvcmRlcjogMXB4IHNvbGlkICM4MDgwODAxMTtcXG59XFxuLnNldHQtd2luLWl0ZW1bZGF0YS12LTVkMjIzYjBlXSB7XFxuICAgIGRpc3BsYXk6IGZsZXg7XFxuICAgIGZsZXgtZGlyZWN0aW9uOiByb3c7XFxuICAgIGZsZXgtd3JhcDogbm93cmFwO1xcbiAgICBqdXN0aWZ5LWNvbnRlbnQ6IGZsZXgtc3RhcnQ7XFxuICAgIGFsaWduLWNvbnRlbnQ6IGNlbnRlcjtcXG4gICAgYWxpZ24taXRlbXM6IGNlbnRlcjtcXG59XFxuLnNldHQtd2luLWl0ZW0gbGFiZWxbZGF0YS12LTVkMjIzYjBlXSB7XFxuICAgIG1pbi13aWR0aDogODBweDtcXG4gICAgY29sb3I6ICMzNWE3NzY7XFxufVxcbi5zZXR0LXdpbi1lbXB0eVtkYXRhLXYtNWQyMjNiMGVdIHtcXG4gICAgb3BhY2l0eTogMC41O1xcbn1cXG5cIiwgXCJcIix7XCJ2ZXJzaW9uXCI6MyxcInNvdXJjZXNcIjpbXCJ3ZWJwYWNrOi8vLi9zcmMvZXh0ZW5zaW9ucy9zZXR0aW5ncy13aW4vU2V0dGluZ3NXaW4udnVlXCJdLFwibmFtZXNcIjpbXSxcIm1hcHBpbmdzXCI6XCI7QUFzREE7SUFDQSxvQkFBQTtJQUNBLDJCQUFBO0FBQ0E7QUFDQTtJQUNBLGFBQUE7SUFDQSxtQkFBQTtJQUNBLGlCQUFBO0lBQ0EsMkJBQUE7SUFDQSxxQkFBQTtJQUNBLG1CQUFBO0FBQ0E7QUFDQTtJQUNBLGVBQUE7SUFDQSxjQUFBO0FBQ0E7QUFDQTtJQUNBLFlBQUE7QUFDQVwiLFwic291cmNlc0NvbnRlbnRcIjpbXCI8dGVtcGxhdGU+XFxuICAgIDx3aW5kb3cgOnRpdGxlPVxcXCJkYXRhLm92Lm5hbWVcXFwiIGNsYXNzPVxcXCJzZXR0LXdpblxcXCIgOnR2PVxcXCJ0dlxcXCIgQGNsb3NlPVxcXCJvbl9jbG9zZVxcXCI+XFxuICAgICAgICA8ZGl2IHYtZm9yPVxcXCJrIGluIHNldHRsaXN0XFxcIiBjbGFzcz1cXFwic2V0dC13aW4taXRlbVxcXCI+XFxuICAgICAgICAgICAgPGxhYmVsPnt7IHMyZChrKSB9fTwvbGFiZWw+XFxuICAgICAgICAgICAgPHN0ZC1pbnB1dCA6dmFsdWU9XFxcInNldHRba11cXFwiIEBpbnB1dD1cXFwidXBkYXRlX3NldHQoaywgJGV2ZW50KVxcXCIgLz5cXG4gICAgICAgIDwvZGl2PlxcbiAgICAgICAgPHNwYW4gdi1pZj1cXFwiIXNldHRsaXN0Lmxlbmd0aFxcXCIgY2xhc3M9XFxcInNldHQtd2luLWVtcHR5XFxcIj5cXG4gICAgICAgICAgICA8aT5ObyBzY3JpcHQgc2V0dGluZ3M8L2k+XFxuICAgICAgICA8L3NwYW4+XFxuICAgIDwvd2luZG93PlxcbjwvdGVtcGxhdGU+XFxuPHNjcmlwdD5cXG5cXG5pbXBvcnQgV2luZG93IGZyb20gJy4uLy4uL2NvbXBvbmVudHMvV2luZG93LnZ1ZSdcXG5pbXBvcnQgU3RkSW5wdXQgZnJvbSAnLi4vLi4vY29tcG9uZW50cy9TdGRJbnB1dC52dWUnXFxuaW1wb3J0IFV0aWxzIGZyb20gJy4vdXRpbHMuanMnXFxuXFxuZXhwb3J0IGRlZmF1bHQge1xcbiAgICBuYW1lOiAnU2V0dGluZ3NXaW4nLFxcbiAgICBjb21wb25lbnRzOiB7IFdpbmRvdywgU3RkSW5wdXQgfSxcXG4gICAgcHJvcHM6IFsnaWQnLCAnbWFpbicsICdkYycsICd0dicsICdkYXRhJ10sXFxuICAgIGNvbXB1dGVkOiB7XFxuICAgICAgICBzZXR0KCkge1xcbiAgICAgICAgICAgIHJldHVybiB0aGlzLiRwcm9wcy5kYXRhLm92LnNldHRpbmdzXFxuICAgICAgICB9LFxcbiAgICAgICAgc2V0dGxpc3QoKSB7XFxuICAgICAgICAgICAgcmV0dXJuIE9iamVjdC5rZXlzKHRoaXMuc2V0dCkuZmlsdGVyKHggPT5cXG4gICAgICAgICAgICAgICAgeFswXSAhPT0gJyQnICYmIHRoaXMuc2V0dC4kcHJvcHMgJiZcXG4gICAgICAgICAgICAgICAgdGhpcy5zZXR0LiRwcm9wcy5pbmNsdWRlcyh4KSlcXG4gICAgICAgIH1cXG4gICAgfSxcXG4gICAgbW91bnRlZCgpIHtcXG4gICAgfSxcXG4gICAgbWV0aG9kczoge1xcbiAgICAgICAgczJkKHN0cikge1xcbiAgICAgICAgICAgIHJldHVybiBVdGlscy5zZXR0MmRlc2Moc3RyKVxcbiAgICAgICAgfSxcXG4gICAgICAgIG9uX2Nsb3NlKCkge1xcbiAgICAgICAgICAgIHRoaXMuJHByb3BzLm1haW4ucmVtb3ZlX3dpZGdldCh0aGlzLiRwcm9wcy5pZClcXG4gICAgICAgIH0sXFxuICAgICAgICB1cGRhdGVfc2V0dChrLCB2YWwpIHtcXG4gICAgICAgICAgICBsZXQgZGNpZCA9IHRoaXMuJHByb3BzLmRhdGEub3YuaWRcXG5cXG4gICAgICAgICAgICBsZXQgdmFsTiA9IHBhcnNlRmxvYXQodmFsKVxcbiAgICAgICAgICAgIGlmICh2YWxOICE9PSB2YWxOKSB2YWxOID0gdmFsXFxuXFxuICAgICAgICAgICAgdGhpcy4kcHJvcHMuZGMubWVyZ2UoYCR7ZGNpZH0uc2V0dGluZ3NgLFxcbiAgICAgICAgICAgICAgICB7IFtrXTogdmFsTiB9XFxuICAgICAgICAgICAgKVxcbiAgICAgICAgfVxcbiAgICB9XFxufVxcbjwvc2NyaXB0PlxcbjxzdHlsZSBzY29wZWQ+XFxuLnR2anMteC13aW5kb3cuc2V0dC13aW4ge1xcbiAgICBwYWRkaW5nLWJvdHRvbTogMzBweDtcXG4gICAgYm9yZGVyOiAxcHggc29saWQgIzgwODA4MDExO1xcbn1cXG4uc2V0dC13aW4taXRlbSB7XFxuICAgIGRpc3BsYXk6IGZsZXg7XFxuICAgIGZsZXgtZGlyZWN0aW9uOiByb3c7XFxuICAgIGZsZXgtd3JhcDogbm93cmFwO1xcbiAgICBqdXN0aWZ5LWNvbnRlbnQ6IGZsZXgtc3RhcnQ7XFxuICAgIGFsaWduLWNvbnRlbnQ6IGNlbnRlcjtcXG4gICAgYWxpZ24taXRlbXM6IGNlbnRlcjtcXG59XFxuLnNldHQtd2luLWl0ZW0gbGFiZWwge1xcbiAgICBtaW4td2lkdGg6IDgwcHg7XFxuICAgIGNvbG9yOiAjMzVhNzc2O1xcbn1cXG4uc2V0dC13aW4tZW1wdHkge1xcbiAgICBvcGFjaXR5OiAwLjU7XFxufVxcbjwvc3R5bGU+XFxuXCJdLFwic291cmNlUm9vdFwiOlwiXCJ9XSk7XG4vLyBFeHBvcnRzXG5leHBvcnQgZGVmYXVsdCBfX19DU1NfTE9BREVSX0VYUE9SVF9fXztcbiIsIlwidXNlIHN0cmljdFwiO1xuXG4vKlxuICBNSVQgTGljZW5zZSBodHRwOi8vd3d3Lm9wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL21pdC1saWNlbnNlLnBocFxuICBBdXRob3IgVG9iaWFzIEtvcHBlcnMgQHNva3JhXG4qL1xuLy8gY3NzIGJhc2UgY29kZSwgaW5qZWN0ZWQgYnkgdGhlIGNzcy1sb2FkZXJcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBmdW5jLW5hbWVzXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChjc3NXaXRoTWFwcGluZ1RvU3RyaW5nKSB7XG4gIHZhciBsaXN0ID0gW107IC8vIHJldHVybiB0aGUgbGlzdCBvZiBtb2R1bGVzIGFzIGNzcyBzdHJpbmdcblxuICBsaXN0LnRvU3RyaW5nID0gZnVuY3Rpb24gdG9TdHJpbmcoKSB7XG4gICAgcmV0dXJuIHRoaXMubWFwKGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICB2YXIgY29udGVudCA9IGNzc1dpdGhNYXBwaW5nVG9TdHJpbmcoaXRlbSk7XG5cbiAgICAgIGlmIChpdGVtWzJdKSB7XG4gICAgICAgIHJldHVybiBcIkBtZWRpYSBcIi5jb25jYXQoaXRlbVsyXSwgXCIge1wiKS5jb25jYXQoY29udGVudCwgXCJ9XCIpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gY29udGVudDtcbiAgICB9KS5qb2luKFwiXCIpO1xuICB9OyAvLyBpbXBvcnQgYSBsaXN0IG9mIG1vZHVsZXMgaW50byB0aGUgbGlzdFxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZnVuYy1uYW1lc1xuXG5cbiAgbGlzdC5pID0gZnVuY3Rpb24gKG1vZHVsZXMsIG1lZGlhUXVlcnksIGRlZHVwZSkge1xuICAgIGlmICh0eXBlb2YgbW9kdWxlcyA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXBhcmFtLXJlYXNzaWduXG4gICAgICBtb2R1bGVzID0gW1tudWxsLCBtb2R1bGVzLCBcIlwiXV07XG4gICAgfVxuXG4gICAgdmFyIGFscmVhZHlJbXBvcnRlZE1vZHVsZXMgPSB7fTtcblxuICAgIGlmIChkZWR1cGUpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcHJlZmVyLWRlc3RydWN0dXJpbmdcbiAgICAgICAgdmFyIGlkID0gdGhpc1tpXVswXTtcblxuICAgICAgICBpZiAoaWQgIT0gbnVsbCkge1xuICAgICAgICAgIGFscmVhZHlJbXBvcnRlZE1vZHVsZXNbaWRdID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBtb2R1bGVzLmxlbmd0aDsgX2krKykge1xuICAgICAgdmFyIGl0ZW0gPSBbXS5jb25jYXQobW9kdWxlc1tfaV0pO1xuXG4gICAgICBpZiAoZGVkdXBlICYmIGFscmVhZHlJbXBvcnRlZE1vZHVsZXNbaXRlbVswXV0pIHtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWNvbnRpbnVlXG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICBpZiAobWVkaWFRdWVyeSkge1xuICAgICAgICBpZiAoIWl0ZW1bMl0pIHtcbiAgICAgICAgICBpdGVtWzJdID0gbWVkaWFRdWVyeTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpdGVtWzJdID0gXCJcIi5jb25jYXQobWVkaWFRdWVyeSwgXCIgYW5kIFwiKS5jb25jYXQoaXRlbVsyXSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgbGlzdC5wdXNoKGl0ZW0pO1xuICAgIH1cbiAgfTtcblxuICByZXR1cm4gbGlzdDtcbn07IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbmZ1bmN0aW9uIF9zbGljZWRUb0FycmF5KGFyciwgaSkgeyByZXR1cm4gX2FycmF5V2l0aEhvbGVzKGFycikgfHwgX2l0ZXJhYmxlVG9BcnJheUxpbWl0KGFyciwgaSkgfHwgX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5KGFyciwgaSkgfHwgX25vbkl0ZXJhYmxlUmVzdCgpOyB9XG5cbmZ1bmN0aW9uIF9ub25JdGVyYWJsZVJlc3QoKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJJbnZhbGlkIGF0dGVtcHQgdG8gZGVzdHJ1Y3R1cmUgbm9uLWl0ZXJhYmxlIGluc3RhbmNlLlxcbkluIG9yZGVyIHRvIGJlIGl0ZXJhYmxlLCBub24tYXJyYXkgb2JqZWN0cyBtdXN0IGhhdmUgYSBbU3ltYm9sLml0ZXJhdG9yXSgpIG1ldGhvZC5cIik7IH1cblxuZnVuY3Rpb24gX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5KG8sIG1pbkxlbikgeyBpZiAoIW8pIHJldHVybjsgaWYgKHR5cGVvZiBvID09PSBcInN0cmluZ1wiKSByZXR1cm4gX2FycmF5TGlrZVRvQXJyYXkobywgbWluTGVuKTsgdmFyIG4gPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwobykuc2xpY2UoOCwgLTEpOyBpZiAobiA9PT0gXCJPYmplY3RcIiAmJiBvLmNvbnN0cnVjdG9yKSBuID0gby5jb25zdHJ1Y3Rvci5uYW1lOyBpZiAobiA9PT0gXCJNYXBcIiB8fCBuID09PSBcIlNldFwiKSByZXR1cm4gQXJyYXkuZnJvbShvKTsgaWYgKG4gPT09IFwiQXJndW1lbnRzXCIgfHwgL14oPzpVaXxJKW50KD86OHwxNnwzMikoPzpDbGFtcGVkKT9BcnJheSQvLnRlc3QobikpIHJldHVybiBfYXJyYXlMaWtlVG9BcnJheShvLCBtaW5MZW4pOyB9XG5cbmZ1bmN0aW9uIF9hcnJheUxpa2VUb0FycmF5KGFyciwgbGVuKSB7IGlmIChsZW4gPT0gbnVsbCB8fCBsZW4gPiBhcnIubGVuZ3RoKSBsZW4gPSBhcnIubGVuZ3RoOyBmb3IgKHZhciBpID0gMCwgYXJyMiA9IG5ldyBBcnJheShsZW4pOyBpIDwgbGVuOyBpKyspIHsgYXJyMltpXSA9IGFycltpXTsgfSByZXR1cm4gYXJyMjsgfVxuXG5mdW5jdGlvbiBfaXRlcmFibGVUb0FycmF5TGltaXQoYXJyLCBpKSB7IHZhciBfaSA9IGFyciAmJiAodHlwZW9mIFN5bWJvbCAhPT0gXCJ1bmRlZmluZWRcIiAmJiBhcnJbU3ltYm9sLml0ZXJhdG9yXSB8fCBhcnJbXCJAQGl0ZXJhdG9yXCJdKTsgaWYgKF9pID09IG51bGwpIHJldHVybjsgdmFyIF9hcnIgPSBbXTsgdmFyIF9uID0gdHJ1ZTsgdmFyIF9kID0gZmFsc2U7IHZhciBfcywgX2U7IHRyeSB7IGZvciAoX2kgPSBfaS5jYWxsKGFycik7ICEoX24gPSAoX3MgPSBfaS5uZXh0KCkpLmRvbmUpOyBfbiA9IHRydWUpIHsgX2Fyci5wdXNoKF9zLnZhbHVlKTsgaWYgKGkgJiYgX2Fyci5sZW5ndGggPT09IGkpIGJyZWFrOyB9IH0gY2F0Y2ggKGVycikgeyBfZCA9IHRydWU7IF9lID0gZXJyOyB9IGZpbmFsbHkgeyB0cnkgeyBpZiAoIV9uICYmIF9pW1wicmV0dXJuXCJdICE9IG51bGwpIF9pW1wicmV0dXJuXCJdKCk7IH0gZmluYWxseSB7IGlmIChfZCkgdGhyb3cgX2U7IH0gfSByZXR1cm4gX2FycjsgfVxuXG5mdW5jdGlvbiBfYXJyYXlXaXRoSG9sZXMoYXJyKSB7IGlmIChBcnJheS5pc0FycmF5KGFycikpIHJldHVybiBhcnI7IH1cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBjc3NXaXRoTWFwcGluZ1RvU3RyaW5nKGl0ZW0pIHtcbiAgdmFyIF9pdGVtID0gX3NsaWNlZFRvQXJyYXkoaXRlbSwgNCksXG4gICAgICBjb250ZW50ID0gX2l0ZW1bMV0sXG4gICAgICBjc3NNYXBwaW5nID0gX2l0ZW1bM107XG5cbiAgaWYgKCFjc3NNYXBwaW5nKSB7XG4gICAgcmV0dXJuIGNvbnRlbnQ7XG4gIH1cblxuICBpZiAodHlwZW9mIGJ0b2EgPT09IFwiZnVuY3Rpb25cIikge1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11bmRlZlxuICAgIHZhciBiYXNlNjQgPSBidG9hKHVuZXNjYXBlKGVuY29kZVVSSUNvbXBvbmVudChKU09OLnN0cmluZ2lmeShjc3NNYXBwaW5nKSkpKTtcbiAgICB2YXIgZGF0YSA9IFwic291cmNlTWFwcGluZ1VSTD1kYXRhOmFwcGxpY2F0aW9uL2pzb247Y2hhcnNldD11dGYtODtiYXNlNjQsXCIuY29uY2F0KGJhc2U2NCk7XG4gICAgdmFyIHNvdXJjZU1hcHBpbmcgPSBcIi8qIyBcIi5jb25jYXQoZGF0YSwgXCIgKi9cIik7XG4gICAgdmFyIHNvdXJjZVVSTHMgPSBjc3NNYXBwaW5nLnNvdXJjZXMubWFwKGZ1bmN0aW9uIChzb3VyY2UpIHtcbiAgICAgIHJldHVybiBcIi8qIyBzb3VyY2VVUkw9XCIuY29uY2F0KGNzc01hcHBpbmcuc291cmNlUm9vdCB8fCBcIlwiKS5jb25jYXQoc291cmNlLCBcIiAqL1wiKTtcbiAgICB9KTtcbiAgICByZXR1cm4gW2NvbnRlbnRdLmNvbmNhdChzb3VyY2VVUkxzKS5jb25jYXQoW3NvdXJjZU1hcHBpbmddKS5qb2luKFwiXFxuXCIpO1xuICB9XG5cbiAgcmV0dXJuIFtjb250ZW50XS5qb2luKFwiXFxuXCIpO1xufTsiLCIvLyBleHRyYWN0ZWQgYnkgbWluaS1jc3MtZXh0cmFjdC1wbHVnaW5cbmV4cG9ydCB7fTsiLCIvLyBleHRyYWN0ZWQgYnkgbWluaS1jc3MtZXh0cmFjdC1wbHVnaW5cbmV4cG9ydCB7fTsiLCIvLyBleHRyYWN0ZWQgYnkgbWluaS1jc3MtZXh0cmFjdC1wbHVnaW5cbmV4cG9ydCB7fTsiLCIvLyBleHRyYWN0ZWQgYnkgbWluaS1jc3MtZXh0cmFjdC1wbHVnaW5cbmV4cG9ydCB7fTsiLCIvLyBleHRyYWN0ZWQgYnkgbWluaS1jc3MtZXh0cmFjdC1wbHVnaW5cbmV4cG9ydCB7fTsiLCIvLyBleHRyYWN0ZWQgYnkgbWluaS1jc3MtZXh0cmFjdC1wbHVnaW5cbmV4cG9ydCB7fTsiLCIvLyBleHRyYWN0ZWQgYnkgbWluaS1jc3MtZXh0cmFjdC1wbHVnaW5cbmV4cG9ydCB7fTsiLCIvLyBleHRyYWN0ZWQgYnkgbWluaS1jc3MtZXh0cmFjdC1wbHVnaW5cbmV4cG9ydCB7fTsiLCIvLyBleHRyYWN0ZWQgYnkgbWluaS1jc3MtZXh0cmFjdC1wbHVnaW5cbmV4cG9ydCB7fTsiLCIvLyBleHRyYWN0ZWQgYnkgbWluaS1jc3MtZXh0cmFjdC1wbHVnaW5cbmV4cG9ydCB7fTsiLCIvLyBleHRyYWN0ZWQgYnkgbWluaS1jc3MtZXh0cmFjdC1wbHVnaW5cbmV4cG9ydCB7fTsiLCIvLyBleHRyYWN0ZWQgYnkgbWluaS1jc3MtZXh0cmFjdC1wbHVnaW5cbmV4cG9ydCB7fTsiLCIvLyBleHRyYWN0ZWQgYnkgbWluaS1jc3MtZXh0cmFjdC1wbHVnaW5cbmV4cG9ydCB7fTsiLCIvLyBleHRyYWN0ZWQgYnkgbWluaS1jc3MtZXh0cmFjdC1wbHVnaW5cbmV4cG9ydCB7fTsiLCIvLyBleHRyYWN0ZWQgYnkgbWluaS1jc3MtZXh0cmFjdC1wbHVnaW5cbmV4cG9ydCB7fTsiLCIvLyBleHRyYWN0ZWQgYnkgbWluaS1jc3MtZXh0cmFjdC1wbHVnaW5cbmV4cG9ydCB7fTsiLCIvLyBleHRyYWN0ZWQgYnkgbWluaS1jc3MtZXh0cmFjdC1wbHVnaW5cbmV4cG9ydCB7fTsiLCIvLyBleHRyYWN0ZWQgYnkgbWluaS1jc3MtZXh0cmFjdC1wbHVnaW5cbmV4cG9ydCB7fTsiLCIvLyBleHRyYWN0ZWQgYnkgbWluaS1jc3MtZXh0cmFjdC1wbHVnaW5cbmV4cG9ydCB7fTsiLCIvLyBleHRyYWN0ZWQgYnkgbWluaS1jc3MtZXh0cmFjdC1wbHVnaW5cbmV4cG9ydCB7fTsiLCIvLyBleHRyYWN0ZWQgYnkgbWluaS1jc3MtZXh0cmFjdC1wbHVnaW5cbmV4cG9ydCB7fTsiLCIvLyBleHRyYWN0ZWQgYnkgbWluaS1jc3MtZXh0cmFjdC1wbHVnaW5cbmV4cG9ydCB7fTsiLCIvLyBleHRyYWN0ZWQgYnkgbWluaS1jc3MtZXh0cmFjdC1wbHVnaW5cbmV4cG9ydCB7fTsiLCIvLyBleHRyYWN0ZWQgYnkgbWluaS1jc3MtZXh0cmFjdC1wbHVnaW5cbmV4cG9ydCB7fTsiLCIvLyBleHRyYWN0ZWQgYnkgbWluaS1jc3MtZXh0cmFjdC1wbHVnaW5cbmV4cG9ydCB7fTsiLCIvLyBleHRyYWN0ZWQgYnkgbWluaS1jc3MtZXh0cmFjdC1wbHVnaW5cbmV4cG9ydCB7fTsiLCIvLyBleHRyYWN0ZWQgYnkgbWluaS1jc3MtZXh0cmFjdC1wbHVnaW5cbmV4cG9ydCB7fTsiLCIvLyBleHRyYWN0ZWQgYnkgbWluaS1jc3MtZXh0cmFjdC1wbHVnaW5cbmV4cG9ydCB7fTsiLCIvLyBleHRyYWN0ZWQgYnkgbWluaS1jc3MtZXh0cmFjdC1wbHVnaW5cbmV4cG9ydCB7fTsiLCIvLyBleHRyYWN0ZWQgYnkgbWluaS1jc3MtZXh0cmFjdC1wbHVnaW5cbmV4cG9ydCB7fTsiLCIvLyBleHRyYWN0ZWQgYnkgbWluaS1jc3MtZXh0cmFjdC1wbHVnaW5cbmV4cG9ydCB7fTsiLCIvLyBleHRyYWN0ZWQgYnkgbWluaS1jc3MtZXh0cmFjdC1wbHVnaW5cbmV4cG9ydCB7fTsiLCIvLyBleHRyYWN0ZWQgYnkgbWluaS1jc3MtZXh0cmFjdC1wbHVnaW5cbmV4cG9ydCB7fTsiLCIvLyBleHRyYWN0ZWQgYnkgbWluaS1jc3MtZXh0cmFjdC1wbHVnaW5cbmV4cG9ydCB7fTsiLCIvLyBleHRyYWN0ZWQgYnkgbWluaS1jc3MtZXh0cmFjdC1wbHVnaW5cbmV4cG9ydCB7fTsiLCIvLyBleHRyYWN0ZWQgYnkgbWluaS1jc3MtZXh0cmFjdC1wbHVnaW5cbmV4cG9ydCB7fTsiLCIvLyBleHRyYWN0ZWQgYnkgbWluaS1jc3MtZXh0cmFjdC1wbHVnaW5cbmV4cG9ydCB7fTsiLCIvLyBleHRyYWN0ZWQgYnkgbWluaS1jc3MtZXh0cmFjdC1wbHVnaW5cbmV4cG9ydCB7fTsiLCIvLyBleHRyYWN0ZWQgYnkgbWluaS1jc3MtZXh0cmFjdC1wbHVnaW5cbmV4cG9ydCB7fTsiLCIvLyBleHRyYWN0ZWQgYnkgbWluaS1jc3MtZXh0cmFjdC1wbHVnaW5cbmV4cG9ydCB7fTsiLCIvLyBleHRyYWN0ZWQgYnkgbWluaS1jc3MtZXh0cmFjdC1wbHVnaW5cbmV4cG9ydCB7fTsiLCIvLyBleHRyYWN0ZWQgYnkgbWluaS1jc3MtZXh0cmFjdC1wbHVnaW5cbmV4cG9ydCB7fTsiLCIvLyBleHRyYWN0ZWQgYnkgbWluaS1jc3MtZXh0cmFjdC1wbHVnaW5cbmV4cG9ydCB7fTsiLCIvLyBleHRyYWN0ZWQgYnkgbWluaS1jc3MtZXh0cmFjdC1wbHVnaW5cbmV4cG9ydCB7fTsiLCIvLyBleHRyYWN0ZWQgYnkgbWluaS1jc3MtZXh0cmFjdC1wbHVnaW5cbmV4cG9ydCB7fTsiLCIvLyBleHRyYWN0ZWQgYnkgbWluaS1jc3MtZXh0cmFjdC1wbHVnaW5cbmV4cG9ydCB7fTsiLCIvLyBleHRyYWN0ZWQgYnkgbWluaS1jc3MtZXh0cmFjdC1wbHVnaW5cbmV4cG9ydCB7fTsiLCIvLyBleHRyYWN0ZWQgYnkgbWluaS1jc3MtZXh0cmFjdC1wbHVnaW5cbmV4cG9ydCB7fTsiLCIvLyBleHRyYWN0ZWQgYnkgbWluaS1jc3MtZXh0cmFjdC1wbHVnaW5cbmV4cG9ydCB7fTsiLCIvLyBleHRyYWN0ZWQgYnkgbWluaS1jc3MtZXh0cmFjdC1wbHVnaW5cbmV4cG9ydCB7fTsiLCIvLyBleHRyYWN0ZWQgYnkgbWluaS1jc3MtZXh0cmFjdC1wbHVnaW5cbmV4cG9ydCB7fTsiLCIvLyBleHRyYWN0ZWQgYnkgbWluaS1jc3MtZXh0cmFjdC1wbHVnaW5cbmV4cG9ydCB7fTsiLCIvLyBleHRyYWN0ZWQgYnkgbWluaS1jc3MtZXh0cmFjdC1wbHVnaW5cbmV4cG9ydCB7fTsiLCIvLyBleHRyYWN0ZWQgYnkgbWluaS1jc3MtZXh0cmFjdC1wbHVnaW5cbmV4cG9ydCB7fTsiLCIvLyBleHRyYWN0ZWQgYnkgbWluaS1jc3MtZXh0cmFjdC1wbHVnaW5cbmV4cG9ydCB7fTsiLCIvLyBleHRyYWN0ZWQgYnkgbWluaS1jc3MtZXh0cmFjdC1wbHVnaW5cbmV4cG9ydCB7fTsiLCIvLyBleHRyYWN0ZWQgYnkgbWluaS1jc3MtZXh0cmFjdC1wbHVnaW5cbmV4cG9ydCB7fTsiLCJleHBvcnQgZGVmYXVsdCBcImh0dHBzOi8vZmFzdC1yZWFjaGVzLTU0MzU4Lmhlcm9rdWFwcC5jb20vXCI7IiwiaW1wb3J0IGFwaSBmcm9tIFwiIS4uL25vZGVfbW9kdWxlcy9zdHlsZS1sb2FkZXIvZGlzdC9ydW50aW1lL2luamVjdFN0eWxlc0ludG9TdHlsZVRhZy5qc1wiO1xuICAgICAgICAgICAgaW1wb3J0IGNvbnRlbnQgZnJvbSBcIiEhLi4vbm9kZV9tb2R1bGVzL2xhcmF2ZWwtbWl4L25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2Rpc3QvY2pzLmpzPz9jbG9uZWRSdWxlU2V0LTY1WzBdLnJ1bGVzWzBdLnVzZVsxXSEuLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvbG9hZGVycy9zdHlsZVBvc3RMb2FkZXIuanMhLi4vbm9kZV9tb2R1bGVzL3Bvc3Rjc3MtbG9hZGVyL2Rpc3QvY2pzLmpzPz9jbG9uZWRSdWxlU2V0LTY1WzBdLnJ1bGVzWzBdLnVzZVsyXSEuLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvaW5kZXguanM/P3Z1ZS1sb2FkZXItb3B0aW9ucyEuL01haW4udnVlP3Z1ZSZ0eXBlPXN0eWxlJmluZGV4PTAmbGFuZz1jc3MmXCI7XG5cbnZhciBvcHRpb25zID0ge307XG5cbm9wdGlvbnMuaW5zZXJ0ID0gXCJoZWFkXCI7XG5vcHRpb25zLnNpbmdsZXRvbiA9IGZhbHNlO1xuXG52YXIgdXBkYXRlID0gYXBpKGNvbnRlbnQsIG9wdGlvbnMpO1xuXG5cblxuZXhwb3J0IGRlZmF1bHQgY29udGVudC5sb2NhbHMgfHwge307IiwiaW1wb3J0IGFwaSBmcm9tIFwiIS4uLy4uL25vZGVfbW9kdWxlcy9zdHlsZS1sb2FkZXIvZGlzdC9ydW50aW1lL2luamVjdFN0eWxlc0ludG9TdHlsZVRhZy5qc1wiO1xuICAgICAgICAgICAgaW1wb3J0IGNvbnRlbnQgZnJvbSBcIiEhLi4vLi4vbm9kZV9tb2R1bGVzL2xhcmF2ZWwtbWl4L25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2Rpc3QvY2pzLmpzPz9jbG9uZWRSdWxlU2V0LTY1WzBdLnJ1bGVzWzBdLnVzZVsxXSEuLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvbG9hZGVycy9zdHlsZVBvc3RMb2FkZXIuanMhLi4vLi4vbm9kZV9tb2R1bGVzL3Bvc3Rjc3MtbG9hZGVyL2Rpc3QvY2pzLmpzPz9jbG9uZWRSdWxlU2V0LTY1WzBdLnJ1bGVzWzBdLnVzZVsyXSEuLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvaW5kZXguanM/P3Z1ZS1sb2FkZXItb3B0aW9ucyEuL1N0ZElucHV0LnZ1ZT92dWUmdHlwZT1zdHlsZSZpbmRleD0wJmxhbmc9Y3NzJlwiO1xuXG52YXIgb3B0aW9ucyA9IHt9O1xuXG5vcHRpb25zLmluc2VydCA9IFwiaGVhZFwiO1xub3B0aW9ucy5zaW5nbGV0b24gPSBmYWxzZTtcblxudmFyIHVwZGF0ZSA9IGFwaShjb250ZW50LCBvcHRpb25zKTtcblxuXG5cbmV4cG9ydCBkZWZhdWx0IGNvbnRlbnQubG9jYWxzIHx8IHt9OyIsImltcG9ydCBhcGkgZnJvbSBcIiEuLi8uLi9ub2RlX21vZHVsZXMvc3R5bGUtbG9hZGVyL2Rpc3QvcnVudGltZS9pbmplY3RTdHlsZXNJbnRvU3R5bGVUYWcuanNcIjtcbiAgICAgICAgICAgIGltcG9ydCBjb250ZW50IGZyb20gXCIhIS4uLy4uL25vZGVfbW9kdWxlcy9sYXJhdmVsLW1peC9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9kaXN0L2Nqcy5qcz8/Y2xvbmVkUnVsZVNldC02NVswXS5ydWxlc1swXS51c2VbMV0hLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL2xvYWRlcnMvc3R5bGVQb3N0TG9hZGVyLmpzIS4uLy4uL25vZGVfbW9kdWxlcy9wb3N0Y3NzLWxvYWRlci9kaXN0L2Nqcy5qcz8/Y2xvbmVkUnVsZVNldC02NVswXS5ydWxlc1swXS51c2VbMl0hLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL2luZGV4LmpzPz92dWUtbG9hZGVyLW9wdGlvbnMhLi9XaW5kb3cudnVlP3Z1ZSZ0eXBlPXN0eWxlJmluZGV4PTAmbGFuZz1jc3MmXCI7XG5cbnZhciBvcHRpb25zID0ge307XG5cbm9wdGlvbnMuaW5zZXJ0ID0gXCJoZWFkXCI7XG5vcHRpb25zLnNpbmdsZXRvbiA9IGZhbHNlO1xuXG52YXIgdXBkYXRlID0gYXBpKGNvbnRlbnQsIG9wdGlvbnMpO1xuXG5cblxuZXhwb3J0IGRlZmF1bHQgY29udGVudC5sb2NhbHMgfHwge307IiwiaW1wb3J0IGFwaSBmcm9tIFwiIS4uLy4uLy4uL25vZGVfbW9kdWxlcy9zdHlsZS1sb2FkZXIvZGlzdC9ydW50aW1lL2luamVjdFN0eWxlc0ludG9TdHlsZVRhZy5qc1wiO1xuICAgICAgICAgICAgaW1wb3J0IGNvbnRlbnQgZnJvbSBcIiEhLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2xhcmF2ZWwtbWl4L25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2Rpc3QvY2pzLmpzPz9jbG9uZWRSdWxlU2V0LTY1WzBdLnJ1bGVzWzBdLnVzZVsxXSEuLi8uLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvbG9hZGVycy9zdHlsZVBvc3RMb2FkZXIuanMhLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3Bvc3Rjc3MtbG9hZGVyL2Rpc3QvY2pzLmpzPz9jbG9uZWRSdWxlU2V0LTY1WzBdLnJ1bGVzWzBdLnVzZVsyXSEuLi8uLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvaW5kZXguanM/P3Z1ZS1sb2FkZXItb3B0aW9ucyEuL1NwbGl0dGVyLnZ1ZT92dWUmdHlwZT1zdHlsZSZpbmRleD0wJmlkPTE4OWZjY2FkJnNjb3BlZD10cnVlJmxhbmc9Y3NzJlwiO1xuXG52YXIgb3B0aW9ucyA9IHt9O1xuXG5vcHRpb25zLmluc2VydCA9IFwiaGVhZFwiO1xub3B0aW9ucy5zaW5nbGV0b24gPSBmYWxzZTtcblxudmFyIHVwZGF0ZSA9IGFwaShjb250ZW50LCBvcHRpb25zKTtcblxuXG5cbmV4cG9ydCBkZWZhdWx0IGNvbnRlbnQubG9jYWxzIHx8IHt9OyIsImltcG9ydCBhcGkgZnJvbSBcIiEuLi8uLi8uLi9ub2RlX21vZHVsZXMvc3R5bGUtbG9hZGVyL2Rpc3QvcnVudGltZS9pbmplY3RTdHlsZXNJbnRvU3R5bGVUYWcuanNcIjtcbiAgICAgICAgICAgIGltcG9ydCBjb250ZW50IGZyb20gXCIhIS4uLy4uLy4uL25vZGVfbW9kdWxlcy9sYXJhdmVsLW1peC9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9kaXN0L2Nqcy5qcz8/Y2xvbmVkUnVsZVNldC02NVswXS5ydWxlc1swXS51c2VbMV0hLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL2xvYWRlcnMvc3R5bGVQb3N0TG9hZGVyLmpzIS4uLy4uLy4uL25vZGVfbW9kdWxlcy9wb3N0Y3NzLWxvYWRlci9kaXN0L2Nqcy5qcz8/Y2xvbmVkUnVsZVNldC02NVswXS5ydWxlc1swXS51c2VbMl0hLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL2luZGV4LmpzPz92dWUtbG9hZGVyLW9wdGlvbnMhLi9BZGRXaW4udnVlP3Z1ZSZ0eXBlPXN0eWxlJmluZGV4PTAmaWQ9NTM0MDhhYzcmc2NvcGVkPXRydWUmbGFuZz1jc3MmXCI7XG5cbnZhciBvcHRpb25zID0ge307XG5cbm9wdGlvbnMuaW5zZXJ0ID0gXCJoZWFkXCI7XG5vcHRpb25zLnNpbmdsZXRvbiA9IGZhbHNlO1xuXG52YXIgdXBkYXRlID0gYXBpKGNvbnRlbnQsIG9wdGlvbnMpO1xuXG5cblxuZXhwb3J0IGRlZmF1bHQgY29udGVudC5sb2NhbHMgfHwge307IiwiaW1wb3J0IGFwaSBmcm9tIFwiIS4uLy4uLy4uL25vZGVfbW9kdWxlcy9zdHlsZS1sb2FkZXIvZGlzdC9ydW50aW1lL2luamVjdFN0eWxlc0ludG9TdHlsZVRhZy5qc1wiO1xuICAgICAgICAgICAgaW1wb3J0IGNvbnRlbnQgZnJvbSBcIiEhLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2xhcmF2ZWwtbWl4L25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2Rpc3QvY2pzLmpzPz9jbG9uZWRSdWxlU2V0LTY1WzBdLnJ1bGVzWzBdLnVzZVsxXSEuLi8uLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvbG9hZGVycy9zdHlsZVBvc3RMb2FkZXIuanMhLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3Bvc3Rjc3MtbG9hZGVyL2Rpc3QvY2pzLmpzPz9jbG9uZWRSdWxlU2V0LTY1WzBdLnJ1bGVzWzBdLnVzZVsyXSEuLi8uLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvaW5kZXguanM/P3Z1ZS1sb2FkZXItb3B0aW9ucyEuL1NldHRpbmdzV2luLnZ1ZT92dWUmdHlwZT1zdHlsZSZpbmRleD0wJmlkPTVkMjIzYjBlJnNjb3BlZD10cnVlJmxhbmc9Y3NzJlwiO1xuXG52YXIgb3B0aW9ucyA9IHt9O1xuXG5vcHRpb25zLmluc2VydCA9IFwiaGVhZFwiO1xub3B0aW9ucy5zaW5nbGV0b24gPSBmYWxzZTtcblxudmFyIHVwZGF0ZSA9IGFwaShjb250ZW50LCBvcHRpb25zKTtcblxuXG5cbmV4cG9ydCBkZWZhdWx0IGNvbnRlbnQubG9jYWxzIHx8IHt9OyIsIlwidXNlIHN0cmljdFwiO1xuXG52YXIgaXNPbGRJRSA9IGZ1bmN0aW9uIGlzT2xkSUUoKSB7XG4gIHZhciBtZW1vO1xuICByZXR1cm4gZnVuY3Rpb24gbWVtb3JpemUoKSB7XG4gICAgaWYgKHR5cGVvZiBtZW1vID09PSAndW5kZWZpbmVkJykge1xuICAgICAgLy8gVGVzdCBmb3IgSUUgPD0gOSBhcyBwcm9wb3NlZCBieSBCcm93c2VyaGFja3NcbiAgICAgIC8vIEBzZWUgaHR0cDovL2Jyb3dzZXJoYWNrcy5jb20vI2hhY2stZTcxZDg2OTJmNjUzMzQxNzNmZWU3MTVjMjIyY2I4MDVcbiAgICAgIC8vIFRlc3RzIGZvciBleGlzdGVuY2Ugb2Ygc3RhbmRhcmQgZ2xvYmFscyBpcyB0byBhbGxvdyBzdHlsZS1sb2FkZXJcbiAgICAgIC8vIHRvIG9wZXJhdGUgY29ycmVjdGx5IGludG8gbm9uLXN0YW5kYXJkIGVudmlyb25tZW50c1xuICAgICAgLy8gQHNlZSBodHRwczovL2dpdGh1Yi5jb20vd2VicGFjay1jb250cmliL3N0eWxlLWxvYWRlci9pc3N1ZXMvMTc3XG4gICAgICBtZW1vID0gQm9vbGVhbih3aW5kb3cgJiYgZG9jdW1lbnQgJiYgZG9jdW1lbnQuYWxsICYmICF3aW5kb3cuYXRvYik7XG4gICAgfVxuXG4gICAgcmV0dXJuIG1lbW87XG4gIH07XG59KCk7XG5cbnZhciBnZXRUYXJnZXQgPSBmdW5jdGlvbiBnZXRUYXJnZXQoKSB7XG4gIHZhciBtZW1vID0ge307XG4gIHJldHVybiBmdW5jdGlvbiBtZW1vcml6ZSh0YXJnZXQpIHtcbiAgICBpZiAodHlwZW9mIG1lbW9bdGFyZ2V0XSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIHZhciBzdHlsZVRhcmdldCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IodGFyZ2V0KTsgLy8gU3BlY2lhbCBjYXNlIHRvIHJldHVybiBoZWFkIG9mIGlmcmFtZSBpbnN0ZWFkIG9mIGlmcmFtZSBpdHNlbGZcblxuICAgICAgaWYgKHdpbmRvdy5IVE1MSUZyYW1lRWxlbWVudCAmJiBzdHlsZVRhcmdldCBpbnN0YW5jZW9mIHdpbmRvdy5IVE1MSUZyYW1lRWxlbWVudCkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIC8vIFRoaXMgd2lsbCB0aHJvdyBhbiBleGNlcHRpb24gaWYgYWNjZXNzIHRvIGlmcmFtZSBpcyBibG9ja2VkXG4gICAgICAgICAgLy8gZHVlIHRvIGNyb3NzLW9yaWdpbiByZXN0cmljdGlvbnNcbiAgICAgICAgICBzdHlsZVRhcmdldCA9IHN0eWxlVGFyZ2V0LmNvbnRlbnREb2N1bWVudC5oZWFkO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgLy8gaXN0YW5idWwgaWdub3JlIG5leHRcbiAgICAgICAgICBzdHlsZVRhcmdldCA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgbWVtb1t0YXJnZXRdID0gc3R5bGVUYXJnZXQ7XG4gICAgfVxuXG4gICAgcmV0dXJuIG1lbW9bdGFyZ2V0XTtcbiAgfTtcbn0oKTtcblxudmFyIHN0eWxlc0luRG9tID0gW107XG5cbmZ1bmN0aW9uIGdldEluZGV4QnlJZGVudGlmaWVyKGlkZW50aWZpZXIpIHtcbiAgdmFyIHJlc3VsdCA9IC0xO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgc3R5bGVzSW5Eb20ubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAoc3R5bGVzSW5Eb21baV0uaWRlbnRpZmllciA9PT0gaWRlbnRpZmllcikge1xuICAgICAgcmVzdWx0ID0gaTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiByZXN1bHQ7XG59XG5cbmZ1bmN0aW9uIG1vZHVsZXNUb0RvbShsaXN0LCBvcHRpb25zKSB7XG4gIHZhciBpZENvdW50TWFwID0ge307XG4gIHZhciBpZGVudGlmaWVycyA9IFtdO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7IGkrKykge1xuICAgIHZhciBpdGVtID0gbGlzdFtpXTtcbiAgICB2YXIgaWQgPSBvcHRpb25zLmJhc2UgPyBpdGVtWzBdICsgb3B0aW9ucy5iYXNlIDogaXRlbVswXTtcbiAgICB2YXIgY291bnQgPSBpZENvdW50TWFwW2lkXSB8fCAwO1xuICAgIHZhciBpZGVudGlmaWVyID0gXCJcIi5jb25jYXQoaWQsIFwiIFwiKS5jb25jYXQoY291bnQpO1xuICAgIGlkQ291bnRNYXBbaWRdID0gY291bnQgKyAxO1xuICAgIHZhciBpbmRleCA9IGdldEluZGV4QnlJZGVudGlmaWVyKGlkZW50aWZpZXIpO1xuICAgIHZhciBvYmogPSB7XG4gICAgICBjc3M6IGl0ZW1bMV0sXG4gICAgICBtZWRpYTogaXRlbVsyXSxcbiAgICAgIHNvdXJjZU1hcDogaXRlbVszXVxuICAgIH07XG5cbiAgICBpZiAoaW5kZXggIT09IC0xKSB7XG4gICAgICBzdHlsZXNJbkRvbVtpbmRleF0ucmVmZXJlbmNlcysrO1xuICAgICAgc3R5bGVzSW5Eb21baW5kZXhdLnVwZGF0ZXIob2JqKTtcbiAgICB9IGVsc2Uge1xuICAgICAgc3R5bGVzSW5Eb20ucHVzaCh7XG4gICAgICAgIGlkZW50aWZpZXI6IGlkZW50aWZpZXIsXG4gICAgICAgIHVwZGF0ZXI6IGFkZFN0eWxlKG9iaiwgb3B0aW9ucyksXG4gICAgICAgIHJlZmVyZW5jZXM6IDFcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGlkZW50aWZpZXJzLnB1c2goaWRlbnRpZmllcik7XG4gIH1cblxuICByZXR1cm4gaWRlbnRpZmllcnM7XG59XG5cbmZ1bmN0aW9uIGluc2VydFN0eWxlRWxlbWVudChvcHRpb25zKSB7XG4gIHZhciBzdHlsZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3N0eWxlJyk7XG4gIHZhciBhdHRyaWJ1dGVzID0gb3B0aW9ucy5hdHRyaWJ1dGVzIHx8IHt9O1xuXG4gIGlmICh0eXBlb2YgYXR0cmlidXRlcy5ub25jZSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICB2YXIgbm9uY2UgPSB0eXBlb2YgX193ZWJwYWNrX25vbmNlX18gIT09ICd1bmRlZmluZWQnID8gX193ZWJwYWNrX25vbmNlX18gOiBudWxsO1xuXG4gICAgaWYgKG5vbmNlKSB7XG4gICAgICBhdHRyaWJ1dGVzLm5vbmNlID0gbm9uY2U7XG4gICAgfVxuICB9XG5cbiAgT2JqZWN0LmtleXMoYXR0cmlidXRlcykuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgc3R5bGUuc2V0QXR0cmlidXRlKGtleSwgYXR0cmlidXRlc1trZXldKTtcbiAgfSk7XG5cbiAgaWYgKHR5cGVvZiBvcHRpb25zLmluc2VydCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIG9wdGlvbnMuaW5zZXJ0KHN0eWxlKTtcbiAgfSBlbHNlIHtcbiAgICB2YXIgdGFyZ2V0ID0gZ2V0VGFyZ2V0KG9wdGlvbnMuaW5zZXJ0IHx8ICdoZWFkJyk7XG5cbiAgICBpZiAoIXRhcmdldCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ291bGRuJ3QgZmluZCBhIHN0eWxlIHRhcmdldC4gVGhpcyBwcm9iYWJseSBtZWFucyB0aGF0IHRoZSB2YWx1ZSBmb3IgdGhlICdpbnNlcnQnIHBhcmFtZXRlciBpcyBpbnZhbGlkLlwiKTtcbiAgICB9XG5cbiAgICB0YXJnZXQuYXBwZW5kQ2hpbGQoc3R5bGUpO1xuICB9XG5cbiAgcmV0dXJuIHN0eWxlO1xufVxuXG5mdW5jdGlvbiByZW1vdmVTdHlsZUVsZW1lbnQoc3R5bGUpIHtcbiAgLy8gaXN0YW5idWwgaWdub3JlIGlmXG4gIGlmIChzdHlsZS5wYXJlbnROb2RlID09PSBudWxsKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgc3R5bGUucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChzdHlsZSk7XG59XG4vKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAgKi9cblxuXG52YXIgcmVwbGFjZVRleHQgPSBmdW5jdGlvbiByZXBsYWNlVGV4dCgpIHtcbiAgdmFyIHRleHRTdG9yZSA9IFtdO1xuICByZXR1cm4gZnVuY3Rpb24gcmVwbGFjZShpbmRleCwgcmVwbGFjZW1lbnQpIHtcbiAgICB0ZXh0U3RvcmVbaW5kZXhdID0gcmVwbGFjZW1lbnQ7XG4gICAgcmV0dXJuIHRleHRTdG9yZS5maWx0ZXIoQm9vbGVhbikuam9pbignXFxuJyk7XG4gIH07XG59KCk7XG5cbmZ1bmN0aW9uIGFwcGx5VG9TaW5nbGV0b25UYWcoc3R5bGUsIGluZGV4LCByZW1vdmUsIG9iaikge1xuICB2YXIgY3NzID0gcmVtb3ZlID8gJycgOiBvYmoubWVkaWEgPyBcIkBtZWRpYSBcIi5jb25jYXQob2JqLm1lZGlhLCBcIiB7XCIpLmNvbmNhdChvYmouY3NzLCBcIn1cIikgOiBvYmouY3NzOyAvLyBGb3Igb2xkIElFXG5cbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICAqL1xuXG4gIGlmIChzdHlsZS5zdHlsZVNoZWV0KSB7XG4gICAgc3R5bGUuc3R5bGVTaGVldC5jc3NUZXh0ID0gcmVwbGFjZVRleHQoaW5kZXgsIGNzcyk7XG4gIH0gZWxzZSB7XG4gICAgdmFyIGNzc05vZGUgPSBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShjc3MpO1xuICAgIHZhciBjaGlsZE5vZGVzID0gc3R5bGUuY2hpbGROb2RlcztcblxuICAgIGlmIChjaGlsZE5vZGVzW2luZGV4XSkge1xuICAgICAgc3R5bGUucmVtb3ZlQ2hpbGQoY2hpbGROb2Rlc1tpbmRleF0pO1xuICAgIH1cblxuICAgIGlmIChjaGlsZE5vZGVzLmxlbmd0aCkge1xuICAgICAgc3R5bGUuaW5zZXJ0QmVmb3JlKGNzc05vZGUsIGNoaWxkTm9kZXNbaW5kZXhdKTtcbiAgICB9IGVsc2Uge1xuICAgICAgc3R5bGUuYXBwZW5kQ2hpbGQoY3NzTm9kZSk7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGFwcGx5VG9UYWcoc3R5bGUsIG9wdGlvbnMsIG9iaikge1xuICB2YXIgY3NzID0gb2JqLmNzcztcbiAgdmFyIG1lZGlhID0gb2JqLm1lZGlhO1xuICB2YXIgc291cmNlTWFwID0gb2JqLnNvdXJjZU1hcDtcblxuICBpZiAobWVkaWEpIHtcbiAgICBzdHlsZS5zZXRBdHRyaWJ1dGUoJ21lZGlhJywgbWVkaWEpO1xuICB9IGVsc2Uge1xuICAgIHN0eWxlLnJlbW92ZUF0dHJpYnV0ZSgnbWVkaWEnKTtcbiAgfVxuXG4gIGlmIChzb3VyY2VNYXAgJiYgdHlwZW9mIGJ0b2EgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgY3NzICs9IFwiXFxuLyojIHNvdXJjZU1hcHBpbmdVUkw9ZGF0YTphcHBsaWNhdGlvbi9qc29uO2Jhc2U2NCxcIi5jb25jYXQoYnRvYSh1bmVzY2FwZShlbmNvZGVVUklDb21wb25lbnQoSlNPTi5zdHJpbmdpZnkoc291cmNlTWFwKSkpKSwgXCIgKi9cIik7XG4gIH0gLy8gRm9yIG9sZCBJRVxuXG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAgKi9cblxuXG4gIGlmIChzdHlsZS5zdHlsZVNoZWV0KSB7XG4gICAgc3R5bGUuc3R5bGVTaGVldC5jc3NUZXh0ID0gY3NzO1xuICB9IGVsc2Uge1xuICAgIHdoaWxlIChzdHlsZS5maXJzdENoaWxkKSB7XG4gICAgICBzdHlsZS5yZW1vdmVDaGlsZChzdHlsZS5maXJzdENoaWxkKTtcbiAgICB9XG5cbiAgICBzdHlsZS5hcHBlbmRDaGlsZChkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShjc3MpKTtcbiAgfVxufVxuXG52YXIgc2luZ2xldG9uID0gbnVsbDtcbnZhciBzaW5nbGV0b25Db3VudGVyID0gMDtcblxuZnVuY3Rpb24gYWRkU3R5bGUob2JqLCBvcHRpb25zKSB7XG4gIHZhciBzdHlsZTtcbiAgdmFyIHVwZGF0ZTtcbiAgdmFyIHJlbW92ZTtcblxuICBpZiAob3B0aW9ucy5zaW5nbGV0b24pIHtcbiAgICB2YXIgc3R5bGVJbmRleCA9IHNpbmdsZXRvbkNvdW50ZXIrKztcbiAgICBzdHlsZSA9IHNpbmdsZXRvbiB8fCAoc2luZ2xldG9uID0gaW5zZXJ0U3R5bGVFbGVtZW50KG9wdGlvbnMpKTtcbiAgICB1cGRhdGUgPSBhcHBseVRvU2luZ2xldG9uVGFnLmJpbmQobnVsbCwgc3R5bGUsIHN0eWxlSW5kZXgsIGZhbHNlKTtcbiAgICByZW1vdmUgPSBhcHBseVRvU2luZ2xldG9uVGFnLmJpbmQobnVsbCwgc3R5bGUsIHN0eWxlSW5kZXgsIHRydWUpO1xuICB9IGVsc2Uge1xuICAgIHN0eWxlID0gaW5zZXJ0U3R5bGVFbGVtZW50KG9wdGlvbnMpO1xuICAgIHVwZGF0ZSA9IGFwcGx5VG9UYWcuYmluZChudWxsLCBzdHlsZSwgb3B0aW9ucyk7XG5cbiAgICByZW1vdmUgPSBmdW5jdGlvbiByZW1vdmUoKSB7XG4gICAgICByZW1vdmVTdHlsZUVsZW1lbnQoc3R5bGUpO1xuICAgIH07XG4gIH1cblxuICB1cGRhdGUob2JqKTtcbiAgcmV0dXJuIGZ1bmN0aW9uIHVwZGF0ZVN0eWxlKG5ld09iaikge1xuICAgIGlmIChuZXdPYmopIHtcbiAgICAgIGlmIChuZXdPYmouY3NzID09PSBvYmouY3NzICYmIG5ld09iai5tZWRpYSA9PT0gb2JqLm1lZGlhICYmIG5ld09iai5zb3VyY2VNYXAgPT09IG9iai5zb3VyY2VNYXApIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB1cGRhdGUob2JqID0gbmV3T2JqKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmVtb3ZlKCk7XG4gICAgfVxuICB9O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChsaXN0LCBvcHRpb25zKSB7XG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9OyAvLyBGb3JjZSBzaW5nbGUtdGFnIHNvbHV0aW9uIG9uIElFNi05LCB3aGljaCBoYXMgYSBoYXJkIGxpbWl0IG9uIHRoZSAjIG9mIDxzdHlsZT5cbiAgLy8gdGFncyBpdCB3aWxsIGFsbG93IG9uIGEgcGFnZVxuXG4gIGlmICghb3B0aW9ucy5zaW5nbGV0b24gJiYgdHlwZW9mIG9wdGlvbnMuc2luZ2xldG9uICE9PSAnYm9vbGVhbicpIHtcbiAgICBvcHRpb25zLnNpbmdsZXRvbiA9IGlzT2xkSUUoKTtcbiAgfVxuXG4gIGxpc3QgPSBsaXN0IHx8IFtdO1xuICB2YXIgbGFzdElkZW50aWZpZXJzID0gbW9kdWxlc1RvRG9tKGxpc3QsIG9wdGlvbnMpO1xuICByZXR1cm4gZnVuY3Rpb24gdXBkYXRlKG5ld0xpc3QpIHtcbiAgICBuZXdMaXN0ID0gbmV3TGlzdCB8fCBbXTtcblxuICAgIGlmIChPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwobmV3TGlzdCkgIT09ICdbb2JqZWN0IEFycmF5XScpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxhc3RJZGVudGlmaWVycy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGlkZW50aWZpZXIgPSBsYXN0SWRlbnRpZmllcnNbaV07XG4gICAgICB2YXIgaW5kZXggPSBnZXRJbmRleEJ5SWRlbnRpZmllcihpZGVudGlmaWVyKTtcbiAgICAgIHN0eWxlc0luRG9tW2luZGV4XS5yZWZlcmVuY2VzLS07XG4gICAgfVxuXG4gICAgdmFyIG5ld0xhc3RJZGVudGlmaWVycyA9IG1vZHVsZXNUb0RvbShuZXdMaXN0LCBvcHRpb25zKTtcblxuICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBsYXN0SWRlbnRpZmllcnMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICB2YXIgX2lkZW50aWZpZXIgPSBsYXN0SWRlbnRpZmllcnNbX2ldO1xuXG4gICAgICB2YXIgX2luZGV4ID0gZ2V0SW5kZXhCeUlkZW50aWZpZXIoX2lkZW50aWZpZXIpO1xuXG4gICAgICBpZiAoc3R5bGVzSW5Eb21bX2luZGV4XS5yZWZlcmVuY2VzID09PSAwKSB7XG4gICAgICAgIHN0eWxlc0luRG9tW19pbmRleF0udXBkYXRlcigpO1xuXG4gICAgICAgIHN0eWxlc0luRG9tLnNwbGljZShfaW5kZXgsIDEpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGxhc3RJZGVudGlmaWVycyA9IG5ld0xhc3RJZGVudGlmaWVycztcbiAgfTtcbn07IiwiLyohXG4gKiBUcmFkaW5nVnVlLkpTIC0gdjEuMC4yIC0gVGh1IE1hciAxOCAyMDIxXG4gKiAgICAgaHR0cHM6Ly9naXRodWIuY29tL3R2anN4L3RyYWRpbmctdnVlLWpzXG4gKiAgICAgQ29weXJpZ2h0IChjKSAyMDE5IEM0NTEgQ29kZSdzIEFsbCBSaWdodDtcbiAqICAgICBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2VcbiAqL1xuKGZ1bmN0aW9uIHdlYnBhY2tVbml2ZXJzYWxNb2R1bGVEZWZpbml0aW9uKHJvb3QsIGZhY3RvcnkpIHtcblx0aWYodHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgPT09ICdvYmplY3QnKVxuXHRcdG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeSgpO1xuXHRlbHNlIGlmKHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZClcblx0XHRkZWZpbmUoW10sIGZhY3RvcnkpO1xuXHRlbHNlIGlmKHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0Jylcblx0XHRleHBvcnRzW1wiVHJhZGluZ1Z1ZUpzXCJdID0gZmFjdG9yeSgpO1xuXHRlbHNlXG5cdFx0cm9vdFtcIlRyYWRpbmdWdWVKc1wiXSA9IGZhY3RvcnkoKTtcbn0pKHNlbGYsIGZ1bmN0aW9uKCkge1xucmV0dXJuIC8qKioqKiovICgoKSA9PiB7IC8vIHdlYnBhY2tCb290c3RyYXBcbi8qKioqKiovIFx0dmFyIF9fd2VicGFja19tb2R1bGVzX18gPSAoe1xuXG4vKioqLyA3NTc6XG4vKioqLyAoKG1vZHVsZSwgX191bnVzZWRfd2VicGFja19leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cbm1vZHVsZS5leHBvcnRzID0gX193ZWJwYWNrX3JlcXVpcmVfXyg2NjYpO1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyA1NDY6XG4vKioqLyAoKG1vZHVsZSkgPT4ge1xuXG4vKipcbiAqIFV0aWxpdHkgY29tcGFyZSBmdW5jdGlvbnNcbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcblxuICAgIC8qKlxuICAgICAqIENvbXBhcmUgdHdvIG51bWJlcnMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gYVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBiXG4gICAgICogQHJldHVybnMge051bWJlcn0gMSBpZiBhID4gYiwgMCBpZiBhID0gYiwgLTEgaWYgYSA8IGJcbiAgICAgKi9cbiAgICBudW1jbXA6IGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICAgIHJldHVybiBhIC0gYjtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQ29tcGFyZSB0d28gc3RyaW5ncy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfFN0cmluZ30gYVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfFN0cmluZ30gYlxuICAgICAqIEByZXR1cm5zIHtOdW1iZXJ9IDEgaWYgYSA+IGIsIDAgaWYgYSA9IGIsIC0xIGlmIGEgPCBiXG4gICAgICovXG4gICAgc3RyY21wOiBmdW5jdGlvbiAoYSwgYikge1xuICAgICAgICByZXR1cm4gYSA8IGIgPyAtMSA6IGEgPiBiID8gMSA6IDA7XG4gICAgfVxuXG59O1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyA2Nzg6XG4vKioqLyAoKG1vZHVsZSwgX191bnVzZWRfd2VicGFja19leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cbi8qKlxuICogSW5kZXhlZCBBcnJheSBCaW5hcnkgU2VhcmNoIG1vZHVsZVxuICovXG5cbi8qKlxuICogRGVwZW5kZW5jaWVzXG4gKi9cbnZhciB1dGlsID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1MDApLFxuICAgIGNtcCA9IF9fd2VicGFja19yZXF1aXJlX18oNTQ2KSxcbiAgICBiaW4gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEwMSk7XG5cbi8qKlxuICogTW9kdWxlIGludGVyZmFjZSBkZWZpbml0aW9uXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gSW5kZXhlZEFycmF5O1xuXG4vKipcbiAqIEluZGV4ZWQgQXJyYXkgY29uc3RydWN0b3JcbiAqXG4gKiBJdCBsb2FkcyB0aGUgYXJyYXkgZGF0YSwgZGVmaW5lcyB0aGUgaW5kZXggZmllbGQgYW5kIHRoZSBjb21wYXJpc29uIGZ1bmN0aW9uXG4gKiB0byBiZSB1c2VkLlxuICpcbiAqIEBwYXJhbSB7QXJyYXl9IGRhdGEgaXMgYW4gYXJyYXkgb2Ygb2JqZWN0c1xuICogQHBhcmFtIHtTdHJpbmd9IGluZGV4IGlzIHRoZSBvYmplY3QncyBwcm9wZXJ0eSB1c2VkIHRvIHNlYXJjaCB0aGUgYXJyYXlcbiAqL1xuZnVuY3Rpb24gSW5kZXhlZEFycmF5KGRhdGEsIGluZGV4KSB7XG5cbiAgICAvLyBpcyBkYXRhIHNvcnRhYmxlIGFycmF5IG9yIGFycmF5LWxpa2Ugb2JqZWN0P1xuICAgIGlmICghdXRpbC5pc1NvcnRhYmxlQXJyYXlMaWtlKGRhdGEpKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIGRhdGFcIik7XG5cbiAgICAvLyBpcyBpbmRleCBhIHZhbGlkIHByb3BlcnR5P1xuICAgIGlmICghaW5kZXggfHwgZGF0YS5sZW5ndGggPiAwICYmICEoaW5kZXggaW4gZGF0YVswXSkpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgaW5kZXhcIik7XG5cbiAgICAvLyBkYXRhIGFycmF5XG4gICAgdGhpcy5kYXRhID0gZGF0YTtcblxuICAgIC8vIG5hbWUgb2YgdGhlIGluZGV4IHByb3BlcnR5XG4gICAgdGhpcy5pbmRleCA9IGluZGV4O1xuXG4gICAgLy8gc2V0IGluZGV4IGJvdW5kYXJ5IHZhbHVlc1xuICAgIHRoaXMuc2V0Qm91bmRhcmllcygpO1xuXG4gICAgLy8gZGVmYXVsdCBjb21wYXJpc29uIGZ1bmN0aW9uXG4gICAgdGhpcy5jb21wYXJlID0gdHlwZW9mIHRoaXMubWludiA9PT0gXCJudW1iZXJcIiA/IGNtcC5udW1jbXAgOiBjbXAuc3RyY21wO1xuXG4gICAgLy8gZGVmYXVsdCBzZWFyY2ggZnVuY3Rpb25cbiAgICB0aGlzLnNlYXJjaCA9IGJpbi5zZWFyY2g7XG5cbiAgICAvLyBjYWNoZSBvZiBpbmRleCB2YWx1ZXMgdG8gYXJyYXkgcG9zaXRpb25zXG4gICAgLy8gZWFjaCB2YWx1ZSBzdG9yZXMgYW4gb2JqZWN0IGFzIHsgZm91bmQ6IHRydWV8ZmFsc2UsIGluZGV4OiBhcnJheS1pbmRleCB9XG4gICAgdGhpcy52YWxwb3MgPSB7fTtcblxuICAgIC8vIGN1cnNvciBhbmQgYWRqYWNlbnQgcG9zaXRpb25zXG4gICAgdGhpcy5jdXJzb3IgPSBudWxsO1xuICAgIHRoaXMubmV4dGxvdyA9IG51bGw7XG4gICAgdGhpcy5uZXh0aGlnaCA9IG51bGw7XG59XG5cbi8qKlxuICogU2V0IHRoZSBjb21wYXJpc29uIGZ1bmN0aW9uXG4gKlxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gdG8gY29tcGFyZSBpbmRleCB2YWx1ZXMgdGhhdCByZXR1cm5lcyAxLCAwLCAtMVxuICovXG5JbmRleGVkQXJyYXkucHJvdG90eXBlLnNldENvbXBhcmUgPSBmdW5jdGlvbiAoZm4pIHtcbiAgICBpZiAodHlwZW9mIGZuICE9PSBcImZ1bmN0aW9uXCIpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgYXJndW1lbnRcIik7XG5cbiAgICB0aGlzLmNvbXBhcmUgPSBmbjtcbiAgICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogU2V0IHRoZSBzZWFyY2ggZnVuY3Rpb25cbiAqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiB0byBzZWFyY2ggaW5kZXggdmFsdWVzIGluIHRoZSBhcnJheSBvZiBvYmplY3RzXG4gKi9cbkluZGV4ZWRBcnJheS5wcm90b3R5cGUuc2V0U2VhcmNoID0gZnVuY3Rpb24gKGZuKSB7XG4gICAgaWYgKHR5cGVvZiBmbiAhPT0gXCJmdW5jdGlvblwiKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIGFyZ3VtZW50XCIpO1xuXG4gICAgdGhpcy5zZWFyY2ggPSBmbjtcbiAgICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogU29ydCB0aGUgZGF0YSBhcnJheSBieSBpdHMgaW5kZXggcHJvcGVydHlcbiAqL1xuSW5kZXhlZEFycmF5LnByb3RvdHlwZS5zb3J0ID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBzZWxmID0gdGhpcyxcbiAgICAgICAgaW5kZXggPSB0aGlzLmluZGV4O1xuXG4gICAgLy8gc29ydCB0aGUgYXJyYXlcbiAgICB0aGlzLmRhdGEuc29ydChmdW5jdGlvbiAoYSwgYikge1xuICAgICAgICByZXR1cm4gc2VsZi5jb21wYXJlKGFbaW5kZXhdLCBiW2luZGV4XSk7XG4gICAgfSk7XG5cbiAgICAvLyByZWNhbGN1bGF0ZSBib3VuZGFyeSB2YWx1ZXNcbiAgICB0aGlzLnNldEJvdW5kYXJpZXMoKTtcblxuICAgIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBJbnNwZWN0IGFuZCBzZXQgdGhlIGJvdW5kYXJpZXMgb2YgdGhlIGludGVybmFsIGRhdGEgYXJyYXlcbiAqL1xuSW5kZXhlZEFycmF5LnByb3RvdHlwZS5zZXRCb3VuZGFyaWVzID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBkYXRhID0gdGhpcy5kYXRhLFxuICAgICAgICBpbmRleCA9IHRoaXMuaW5kZXg7XG5cbiAgICB0aGlzLm1pbnYgPSBkYXRhLmxlbmd0aCAmJiBkYXRhWzBdW2luZGV4XTtcbiAgICB0aGlzLm1heHYgPSBkYXRhLmxlbmd0aCAmJiBkYXRhW2RhdGEubGVuZ3RoIC0gMV1baW5kZXhdO1xuXG4gICAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIEdldCB0aGUgcG9zaXRpb24gb2YgdGhlIG9iamVjdCBjb3JyZXNwb25kaW5nIHRvIHRoZSBnaXZlbiBpbmRleFxuICpcbiAqIEBwYXJhbSB7TnVtYmVyfFN0cmluZ30gaW5kZXggaXMgdGhlIGlkIG9mIHRoZSByZXF1ZXN0ZWQgb2JqZWN0XG4gKiBAcmV0dXJucyB7TnVtYmVyfSB0aGUgcG9zaXRpb24gb2YgdGhlIG9iamVjdCBpbiB0aGUgYXJyYXlcbiAqL1xuSW5kZXhlZEFycmF5LnByb3RvdHlwZS5mZXRjaCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgIC8vIGNoZWNrIGRhdGEgaGFzIG9iamVjdHNcbiAgICBpZiAodGhpcy5kYXRhLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICB0aGlzLmN1cnNvciA9IG51bGw7XG4gICAgICAgIHRoaXMubmV4dGxvdyA9IG51bGw7XG4gICAgICAgIHRoaXMubmV4dGhpZ2ggPSBudWxsO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvLyBjaGVjayB0aGUgcmVxdWVzdCBpcyB3aXRoaW4gcmFuZ2VcbiAgICBpZiAodGhpcy5jb21wYXJlKHZhbHVlLCB0aGlzLm1pbnYpID09PSAtMSkge1xuICAgICAgICB0aGlzLmN1cnNvciA9IG51bGw7XG4gICAgICAgIHRoaXMubmV4dGxvdyA9IG51bGw7XG4gICAgICAgIHRoaXMubmV4dGhpZ2ggPSAwO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgaWYgKHRoaXMuY29tcGFyZSh2YWx1ZSwgdGhpcy5tYXh2KSA9PT0gMSkge1xuICAgICAgICB0aGlzLmN1cnNvciA9IG51bGw7XG4gICAgICAgIHRoaXMubmV4dGxvdyA9IHRoaXMuZGF0YS5sZW5ndGggLSAxO1xuICAgICAgICB0aGlzLm5leHRoaWdoID0gbnVsbDtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgdmFyIHZhbHBvcyA9IHRoaXMudmFscG9zLFxuICAgICAgICBwb3MgPSB2YWxwb3NbdmFsdWVdO1xuXG4gICAgLy8gaWYgdGhlIHJlcXVlc3QgaXMgbWVtb3JpemVkLCBqdXN0IGdpdmUgaXQgYmFja1xuICAgIGlmIChwb3MpIHtcbiAgICAgICAgaWYgKHBvcy5mb3VuZCkge1xuICAgICAgICAgICAgdGhpcy5jdXJzb3IgPSBwb3MuaW5kZXg7XG4gICAgICAgICAgICB0aGlzLm5leHRsb3cgPSBudWxsO1xuICAgICAgICAgICAgdGhpcy5uZXh0aGlnaCA9IG51bGw7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmN1cnNvciA9IG51bGw7XG4gICAgICAgICAgICB0aGlzLm5leHRsb3cgPSBwb3MucHJldjtcbiAgICAgICAgICAgIHRoaXMubmV4dGhpZ2ggPSBwb3MubmV4dDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvLyBpZiBub3QsIGRvIHRoZSBzZWFyY2hcbiAgICB2YXIgcmVzdWx0ID0gdGhpcy5zZWFyY2guY2FsbCh0aGlzLCB2YWx1ZSk7XG4gICAgdGhpcy5jdXJzb3IgPSByZXN1bHQuaW5kZXg7XG4gICAgdGhpcy5uZXh0bG93ID0gcmVzdWx0LnByZXY7XG4gICAgdGhpcy5uZXh0aGlnaCA9IHJlc3VsdC5uZXh0O1xuICAgIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBHZXQgdGhlIG9iamVjdCBjb3JyZXNwb25kaW5nIHRvIHRoZSBnaXZlbiBpbmRleFxuICpcbiAqIFdoZW4gbm8gdmFsdWUgaXMgZ2l2ZW4sIHRoZSBmdW5jdGlvbiB3aWxsIGRlZmF1bHQgdG8gdGhlIGxhc3QgZmV0Y2hlZCBpdGVtLlxuICpcbiAqIEBwYXJhbSB7TnVtYmVyfFN0cmluZ30gW29wdGlvbmFsXSBpbmRleCBpcyB0aGUgaWQgb2YgdGhlIHJlcXVlc3RlZCBvYmplY3RcbiAqIEByZXR1cm5zIHtPYmplY3R9IHRoZSBmb3VuZCBvYmplY3Qgb3IgbnVsbFxuICovXG5JbmRleGVkQXJyYXkucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgIGlmICh2YWx1ZSlcbiAgICAgICAgdGhpcy5mZXRjaCh2YWx1ZSk7XG5cbiAgICB2YXIgcG9zID0gdGhpcy5jdXJzb3I7XG4gICAgcmV0dXJuIHBvcyAhPT0gbnVsbCA/IHRoaXMuZGF0YVtwb3NdIDogbnVsbDtcbn07XG5cbi8qKlxuICogR2V0IGFuIHNsaWNlIG9mIHRoZSBkYXRhIGFycmF5XG4gKlxuICogQm91bmRhcmllcyBoYXZlIHRvIGJlIGluIG9yZGVyLlxuICpcbiAqIEBwYXJhbSB7TnVtYmVyfFN0cmluZ30gYmVnaW4gaW5kZXggaXMgdGhlIGlkIG9mIHRoZSByZXF1ZXN0ZWQgb2JqZWN0XG4gKiBAcGFyYW0ge051bWJlcnxTdHJpbmd9IGVuZCBpbmRleCBpcyB0aGUgaWQgb2YgdGhlIHJlcXVlc3RlZCBvYmplY3RcbiAqIEByZXR1cm5zIHtPYmplY3R9IHRoZSBzbGljZSBvZiBkYXRhIGFycmF5IG9yIFtdXG4gKi9cbkluZGV4ZWRBcnJheS5wcm90b3R5cGUuZ2V0UmFuZ2UgPSBmdW5jdGlvbiAoYmVnaW4sIGVuZCkge1xuICAgIC8vIGNoZWNrIGlmIGJvdW5kYXJpZXMgYXJlIGluIG9yZGVyXG4gICAgaWYgKHRoaXMuY29tcGFyZShiZWdpbiwgZW5kKSA9PT0gMSkge1xuICAgICAgICByZXR1cm4gW107XG4gICAgfVxuXG4gICAgLy8gZmV0Y2ggc3RhcnQgYW5kIGRlZmF1bHQgdG8gdGhlIG5leHQgaW5kZXggYWJvdmVcbiAgICB0aGlzLmZldGNoKGJlZ2luKTtcbiAgICB2YXIgc3RhcnQgPSB0aGlzLmN1cnNvciB8fCB0aGlzLm5leHRoaWdoO1xuXG4gICAgLy8gZmV0Y2ggZmluaXNoIGFuZCBkZWZhdWx0IHRvIHRoZSBuZXh0IGluZGV4IGJlbG93XG4gICAgdGhpcy5mZXRjaChlbmQpO1xuICAgIHZhciBmaW5pc2ggPSB0aGlzLmN1cnNvciB8fCB0aGlzLm5leHRsb3c7XG5cbiAgICAvLyBpZiBhbnkgYm91bmRhcnkgaXMgbm90IHNldCwgcmV0dXJuIG5vIHJhbmdlXG4gICAgaWYgKHN0YXJ0ID09PSBudWxsIHx8IGZpbmlzaCA9PT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gW107XG4gICAgfVxuXG4gICAgLy8gcmV0dXJuIHJhbmdlXG4gICAgcmV0dXJuIHRoaXMuZGF0YS5zbGljZShzdGFydCwgZmluaXNoICsgMSk7XG59O1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyAxMDE6XG4vKioqLyAoKG1vZHVsZSkgPT4ge1xuXG4vKipcbiAqIEJpbmFyeSBzZWFyY2ggaW1wbGVtZW50YXRpb25cbiAqL1xuXG4vKipcbiAqIE1haW4gc2VhcmNoIHJlY3Vyc2l2ZSBmdW5jdGlvblxuICovXG5mdW5jdGlvbiBsb29wKGRhdGEsIG1pbiwgbWF4LCBpbmRleCwgdmFscG9zKSB7XG5cbiAgICAvLyBzZXQgY3VycmVudCBwb3NpdGlvbiBhcyB0aGUgbWlkZGxlIHBvaW50IGJldHdlZW4gbWluIGFuZCBtYXhcbiAgICB2YXIgY3VyciA9IChtYXggKyBtaW4pID4+PiAxO1xuXG4gICAgLy8gY29tcGFyZSBjdXJyZW50IGluZGV4IHZhbHVlIHdpdGggdGhlIG9uZSB3ZSBhcmUgbG9va2luZyBmb3JcbiAgICB2YXIgZGlmZiA9IHRoaXMuY29tcGFyZShkYXRhW2N1cnJdW3RoaXMuaW5kZXhdLCBpbmRleCk7XG5cbiAgICAvLyBmb3VuZD9cbiAgICBpZiAoIWRpZmYpIHtcbiAgICAgICAgcmV0dXJuIHZhbHBvc1tpbmRleF0gPSB7XG4gICAgICAgICAgICBcImZvdW5kXCI6IHRydWUsXG4gICAgICAgICAgICBcImluZGV4XCI6IGN1cnIsXG4gICAgICAgICAgICBcInByZXZcIjogbnVsbCxcbiAgICAgICAgICAgIFwibmV4dFwiOiBudWxsXG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgLy8gbm8gbW9yZSBwb3NpdGlvbnMgYXZhaWxhYmxlP1xuICAgIGlmIChtaW4gPj0gbWF4KSB7XG4gICAgICAgIHJldHVybiB2YWxwb3NbaW5kZXhdID0ge1xuICAgICAgICAgICAgXCJmb3VuZFwiOiBmYWxzZSxcbiAgICAgICAgICAgIFwiaW5kZXhcIjogbnVsbCxcbiAgICAgICAgICAgIFwicHJldlwiOiAoZGlmZiA8IDApID8gbWF4IDogbWF4IC0gMSxcbiAgICAgICAgICAgIFwibmV4dFwiOiAoZGlmZiA8IDApID8gbWF4ICsgMSA6IG1heFxuICAgICAgICB9O1xuICAgIH1cblxuICAgIC8vIGNvbnRpbnVlIGxvb2tpbmcgZm9yIGluZGV4IGluIG9uZSBvZiB0aGUgcmVtYWluaW5nIGFycmF5IGhhbHZlc1xuICAgIC8vIGN1cnJlbnQgcG9zaXRpb24gY2FuIGJlIHNrZXB0IGFzIGluZGV4IGlzIG5vdCB0aGVyZS4uLlxuICAgIGlmIChkaWZmID4gMClcbiAgICAgICAgcmV0dXJuIGxvb3AuY2FsbCh0aGlzLCBkYXRhLCBtaW4sIGN1cnIgLSAxLCBpbmRleCwgdmFscG9zKTtcbiAgICBlbHNlXG4gICAgICAgIHJldHVybiBsb29wLmNhbGwodGhpcywgZGF0YSwgY3VyciArIDEsIG1heCwgaW5kZXgsIHZhbHBvcyk7XG59XG5cbi8qKlxuICogU2VhcmNoIGJvb3RzdHJhcFxuICogVGhlIGZ1bmN0aW9uIGhhcyB0byBiZSBleGVjdXRlZCBpbiB0aGUgY29udGV4dCBvZiB0aGUgSW5kZXhlZEFycmF5IG9iamVjdFxuICovXG5mdW5jdGlvbiBzZWFyY2goaW5kZXgpIHtcbiAgICB2YXIgZGF0YSA9IHRoaXMuZGF0YTtcbiAgICByZXR1cm4gbG9vcC5jYWxsKHRoaXMsIGRhdGEsIDAsIGRhdGEubGVuZ3RoIC0gMSwgaW5kZXgsIHRoaXMudmFscG9zKTtcbn1cblxuLyoqXG4gKiBFeHBvcnQgc2VhcmNoIGZ1bmN0aW9uXG4gKi9cbm1vZHVsZS5leHBvcnRzLnNlYXJjaCA9IHNlYXJjaDtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gNTAwOlxuLyoqKi8gKChtb2R1bGUpID0+IHtcblxuLyoqXG4gKiBVdGlscyBtb2R1bGVcbiAqL1xuXG4vKipcbiAqIENoZWNrIGlmIGFuIG9iamVjdCBpcyBhbiBhcnJheS1saWtlIG9iamVjdFxuICpcbiAqIEBjcmVkaXQgSmF2YXNjcmlwdDogVGhlIERlZmluaXRpdmUgR3VpZGUsIE8nUmVpbGx5LCAyMDExXG4gKi9cbmZ1bmN0aW9uIGlzQXJyYXlMaWtlKG8pIHtcbiAgICBpZiAobyAmJiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIG8gaXMgbm90IG51bGwsIHVuZGVmaW5lZCwgZXRjLlxuICAgICAgICB0eXBlb2YgbyA9PT0gXCJvYmplY3RcIiAmJiAgICAgICAgICAgICAvLyBvIGlzIGFuIG9iamVjdFxuICAgICAgICBpc0Zpbml0ZShvLmxlbmd0aCkgJiYgICAgICAgICAgICAgICAgLy8gby5sZW5ndGggaXMgYSBmaW5pdGUgbnVtYmVyXG4gICAgICAgIG8ubGVuZ3RoID49IDAgJiYgICAgICAgICAgICAgICAgICAgICAvLyBvLmxlbmd0aCBpcyBub24tbmVnYXRpdmVcbiAgICAgICAgby5sZW5ndGggPT09IE1hdGguZmxvb3Ioby5sZW5ndGgpICYmIC8vIG8ubGVuZ3RoIGlzIGFuIGludGVnZXJcbiAgICAgICAgby5sZW5ndGggPCA0Mjk0OTY3Mjk2KSAgICAgICAgICAgICAgIC8vIG8ubGVuZ3RoIDwgMl4zMlxuICAgICAgICByZXR1cm4gdHJ1ZTsgICAgICAgICAgICAgICAgICAgICAgICAgLy8gVGhlbiBvIGlzIGFycmF5LWxpa2VcbiAgICBlbHNlXG4gICAgICAgIHJldHVybiBmYWxzZTsgICAgICAgICAgICAgICAgICAgICAgICAvLyBPdGhlcndpc2UgaXQgaXMgbm90XG59XG5cbi8qKlxuICogQ2hlY2sgZm9yIHRoZSBleGlzdGVuY2Ugb2YgdGhlIHNvcnQgZnVuY3Rpb24gaW4gdGhlIG9iamVjdFxuICovXG5mdW5jdGlvbiBpc1NvcnRhYmxlKG8pIHtcbiAgICBpZiAobyAmJiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIG8gaXMgbm90IG51bGwsIHVuZGVmaW5lZCwgZXRjLlxuICAgICAgICB0eXBlb2YgbyA9PT0gXCJvYmplY3RcIiAmJiAgICAgICAgICAgICAvLyBvIGlzIGFuIG9iamVjdFxuICAgICAgICB0eXBlb2Ygby5zb3J0ID09PSBcImZ1bmN0aW9uXCIpICAgICAgICAvLyBvLnNvcnQgaXMgYSBmdW5jdGlvblxuICAgICAgICByZXR1cm4gdHJ1ZTsgICAgICAgICAgICAgICAgICAgICAgICAgLy8gVGhlbiBvIGlzIGFycmF5LWxpa2VcbiAgICBlbHNlXG4gICAgICAgIHJldHVybiBmYWxzZTsgICAgICAgICAgICAgICAgICAgICAgICAvLyBPdGhlcndpc2UgaXQgaXMgbm90XG59XG5cbi8qKlxuICogQ2hlY2sgZm9yIHNvcnRhYmxlLWFycmF5LWxpa2Ugb2JqZWN0c1xuICovXG5tb2R1bGUuZXhwb3J0cy5pc1NvcnRhYmxlQXJyYXlMaWtlID0gZnVuY3Rpb24gKG8pIHtcbiAgICByZXR1cm4gaXNBcnJheUxpa2UobykgJiYgaXNTb3J0YWJsZShvKTtcbn07XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIDg1MTpcbi8qKiovICgoX191bnVzZWRfd2VicGFja19tb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG4vLyBFU00gQ09NUEFUIEZMQUdcbl9fd2VicGFja19yZXF1aXJlX18ucihfX3dlYnBhY2tfZXhwb3J0c19fKTtcblxuLy8gRVhQT1JUU1xuX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIHtcbiAgXCJDYW5kbGVcIjogKCkgPT4gKC8qIHJlZXhwb3J0ICovIENhbmRsZUV4dCksXG4gIFwiQ29uc3RhbnRzXCI6ICgpID0+ICgvKiByZWV4cG9ydCAqLyBjb25zdGFudHMpLFxuICBcIkRhdGFDdWJlXCI6ICgpID0+ICgvKiByZWV4cG9ydCAqLyBEYXRhQ3ViZSksXG4gIFwiSW50ZXJmYWNlXCI6ICgpID0+ICgvKiByZWV4cG9ydCAqLyBtaXhpbnNfaW50ZXJmYWNlKSxcbiAgXCJPdmVybGF5XCI6ICgpID0+ICgvKiByZWV4cG9ydCAqLyBvdmVybGF5KSxcbiAgXCJUb29sXCI6ICgpID0+ICgvKiByZWV4cG9ydCAqLyB0b29sKSxcbiAgXCJUcmFkaW5nVnVlXCI6ICgpID0+ICgvKiByZWV4cG9ydCAqLyBUcmFkaW5nVnVlKSxcbiAgXCJVdGlsc1wiOiAoKSA9PiAoLyogcmVleHBvcnQgKi8gdXRpbHMpLFxuICBcIlZvbGJhclwiOiAoKSA9PiAoLyogcmVleHBvcnQgKi8gVm9sYmFyRXh0KSxcbiAgXCJkZWZhdWx0XCI6ICgpID0+ICgvKiBiaW5kaW5nICovIHNyYyksXG4gIFwibGF5b3V0X2NudlwiOiAoKSA9PiAoLyogcmVleHBvcnQgKi8gbGF5b3V0X2NudiksXG4gIFwibGF5b3V0X3ZvbFwiOiAoKSA9PiAoLyogcmVleHBvcnQgKi8gbGF5b3V0X3ZvbCksXG4gIFwicHJpbWl0aXZlc1wiOiAoKSA9PiAoLyogYmluZGluZyAqLyBwcmltaXRpdmVzKVxufSk7XG5cbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9sb2FkZXJzL3RlbXBsYXRlTG9hZGVyLmpzPz92dWUtbG9hZGVyLW9wdGlvbnMhLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvaW5kZXguanM/P3Z1ZS1sb2FkZXItb3B0aW9ucyEuL3NyYy9UcmFkaW5nVnVlLnZ1ZT92dWUmdHlwZT10ZW1wbGF0ZSZpZD0yMzVjMGFkZSZcbnZhciByZW5kZXIgPSBmdW5jdGlvbigpIHtcbiAgdmFyIF92bSA9IHRoaXNcbiAgdmFyIF9oID0gX3ZtLiRjcmVhdGVFbGVtZW50XG4gIHZhciBfYyA9IF92bS5fc2VsZi5fYyB8fCBfaFxuICByZXR1cm4gX2MoXG4gICAgXCJkaXZcIixcbiAgICB7XG4gICAgICBzdGF0aWNDbGFzczogXCJ0cmFkaW5nLXZ1ZVwiLFxuICAgICAgc3R5bGU6IHtcbiAgICAgICAgY29sb3I6IHRoaXMuY2hhcnRfcHJvcHMuY29sb3JzLnRleHQsXG4gICAgICAgIGZvbnQ6IHRoaXMuZm9udF9jb21wLFxuICAgICAgICB3aWR0aDogdGhpcy53aWR0aCArIFwicHhcIixcbiAgICAgICAgaGVpZ2h0OiB0aGlzLmhlaWdodCArIFwicHhcIlxuICAgICAgfSxcbiAgICAgIGF0dHJzOiB7IGlkOiBfdm0uaWQgfSxcbiAgICAgIG9uOiB7IG1vdXNlZG93bjogX3ZtLm1vdXNlZG93biwgbW91c2VsZWF2ZTogX3ZtLm1vdXNlbGVhdmUgfVxuICAgIH0sXG4gICAgW1xuICAgICAgX3ZtLnRvb2xiYXJcbiAgICAgICAgPyBfYyhcbiAgICAgICAgICAgIFwidG9vbGJhclwiLFxuICAgICAgICAgICAgX3ZtLl9iKFxuICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgcmVmOiBcInRvb2xiYXJcIixcbiAgICAgICAgICAgICAgICBhdHRyczogeyBjb25maWc6IF92bS5jaGFydF9jb25maWcgfSxcbiAgICAgICAgICAgICAgICBvbjogeyBcImN1c3RvbS1ldmVudFwiOiBfdm0uY3VzdG9tX2V2ZW50IH1cbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgXCJ0b29sYmFyXCIsXG4gICAgICAgICAgICAgIF92bS5jaGFydF9wcm9wcyxcbiAgICAgICAgICAgICAgZmFsc2VcbiAgICAgICAgICAgIClcbiAgICAgICAgICApXG4gICAgICAgIDogX3ZtLl9lKCksXG4gICAgICBfdm0uX3YoXCIgXCIpLFxuICAgICAgX3ZtLmNvbnRyb2xsZXJzLmxlbmd0aFxuICAgICAgICA/IF9jKFwid2lkZ2V0c1wiLCB7XG4gICAgICAgICAgICByZWY6IFwid2lkZ2V0c1wiLFxuICAgICAgICAgICAgYXR0cnM6IHtcbiAgICAgICAgICAgICAgbWFwOiBfdm0ud3MsXG4gICAgICAgICAgICAgIHdpZHRoOiBfdm0ud2lkdGgsXG4gICAgICAgICAgICAgIGhlaWdodDogX3ZtLmhlaWdodCxcbiAgICAgICAgICAgICAgdHY6IHRoaXMsXG4gICAgICAgICAgICAgIGRjOiBfdm0uZGF0YVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pXG4gICAgICAgIDogX3ZtLl9lKCksXG4gICAgICBfdm0uX3YoXCIgXCIpLFxuICAgICAgX2MoXG4gICAgICAgIFwiY2hhcnRcIixcbiAgICAgICAgX3ZtLl9iKFxuICAgICAgICAgIHtcbiAgICAgICAgICAgIGtleTogX3ZtLnJlc2V0LFxuICAgICAgICAgICAgcmVmOiBcImNoYXJ0XCIsXG4gICAgICAgICAgICBhdHRyczogeyB0dl9pZDogX3ZtLmlkLCBjb25maWc6IF92bS5jaGFydF9jb25maWcgfSxcbiAgICAgICAgICAgIG9uOiB7XG4gICAgICAgICAgICAgIFwiY3VzdG9tLWV2ZW50XCI6IF92bS5jdXN0b21fZXZlbnQsXG4gICAgICAgICAgICAgIFwicmFuZ2UtY2hhbmdlZFwiOiBfdm0ucmFuZ2VfY2hhbmdlZCxcbiAgICAgICAgICAgICAgXCJsZWdlbmQtYnV0dG9uLWNsaWNrXCI6IF92bS5sZWdlbmRfYnV0dG9uXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSxcbiAgICAgICAgICBcImNoYXJ0XCIsXG4gICAgICAgICAgX3ZtLmNoYXJ0X3Byb3BzLFxuICAgICAgICAgIGZhbHNlXG4gICAgICAgIClcbiAgICAgICksXG4gICAgICBfdm0uX3YoXCIgXCIpLFxuICAgICAgX2MoXG4gICAgICAgIFwidHJhbnNpdGlvblwiLFxuICAgICAgICB7IGF0dHJzOiB7IG5hbWU6IFwidHZqcy1kcmlmdFwiIH0gfSxcbiAgICAgICAgW1xuICAgICAgICAgIF92bS50aXBcbiAgICAgICAgICAgID8gX2MoXCJ0aGUtdGlwXCIsIHtcbiAgICAgICAgICAgICAgICBhdHRyczogeyBkYXRhOiBfdm0udGlwIH0sXG4gICAgICAgICAgICAgICAgb246IHtcbiAgICAgICAgICAgICAgICAgIFwicmVtb3ZlLW1lXCI6IGZ1bmN0aW9uKCRldmVudCkge1xuICAgICAgICAgICAgICAgICAgICBfdm0udGlwID0gbnVsbFxuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIDogX3ZtLl9lKClcbiAgICAgICAgXSxcbiAgICAgICAgMVxuICAgICAgKVxuICAgIF0sXG4gICAgMVxuICApXG59XG52YXIgc3RhdGljUmVuZGVyRm5zID0gW11cbnJlbmRlci5fd2l0aFN0cmlwcGVkID0gdHJ1ZVxuXG5cbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9UcmFkaW5nVnVlLnZ1ZT92dWUmdHlwZT10ZW1wbGF0ZSZpZD0yMzVjMGFkZSZcblxuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL2FycmF5TGlrZVRvQXJyYXkuanNcbmZ1bmN0aW9uIF9hcnJheUxpa2VUb0FycmF5KGFyciwgbGVuKSB7XG4gIGlmIChsZW4gPT0gbnVsbCB8fCBsZW4gPiBhcnIubGVuZ3RoKSBsZW4gPSBhcnIubGVuZ3RoO1xuXG4gIGZvciAodmFyIGkgPSAwLCBhcnIyID0gbmV3IEFycmF5KGxlbik7IGkgPCBsZW47IGkrKykge1xuICAgIGFycjJbaV0gPSBhcnJbaV07XG4gIH1cblxuICByZXR1cm4gYXJyMjtcbn1cbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9hcnJheVdpdGhvdXRIb2xlcy5qc1xuXG5mdW5jdGlvbiBfYXJyYXlXaXRob3V0SG9sZXMoYXJyKSB7XG4gIGlmIChBcnJheS5pc0FycmF5KGFycikpIHJldHVybiBfYXJyYXlMaWtlVG9BcnJheShhcnIpO1xufVxuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL2l0ZXJhYmxlVG9BcnJheS5qc1xuZnVuY3Rpb24gX2l0ZXJhYmxlVG9BcnJheShpdGVyKSB7XG4gIGlmICh0eXBlb2YgU3ltYm9sICE9PSBcInVuZGVmaW5lZFwiICYmIFN5bWJvbC5pdGVyYXRvciBpbiBPYmplY3QoaXRlcikpIHJldHVybiBBcnJheS5mcm9tKGl0ZXIpO1xufVxuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5LmpzXG5cbmZ1bmN0aW9uIF91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheShvLCBtaW5MZW4pIHtcbiAgaWYgKCFvKSByZXR1cm47XG4gIGlmICh0eXBlb2YgbyA9PT0gXCJzdHJpbmdcIikgcmV0dXJuIF9hcnJheUxpa2VUb0FycmF5KG8sIG1pbkxlbik7XG4gIHZhciBuID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG8pLnNsaWNlKDgsIC0xKTtcbiAgaWYgKG4gPT09IFwiT2JqZWN0XCIgJiYgby5jb25zdHJ1Y3RvcikgbiA9IG8uY29uc3RydWN0b3IubmFtZTtcbiAgaWYgKG4gPT09IFwiTWFwXCIgfHwgbiA9PT0gXCJTZXRcIikgcmV0dXJuIEFycmF5LmZyb20obyk7XG4gIGlmIChuID09PSBcIkFyZ3VtZW50c1wiIHx8IC9eKD86VWl8SSludCg/Ojh8MTZ8MzIpKD86Q2xhbXBlZCk/QXJyYXkkLy50ZXN0KG4pKSByZXR1cm4gX2FycmF5TGlrZVRvQXJyYXkobywgbWluTGVuKTtcbn1cbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9ub25JdGVyYWJsZVNwcmVhZC5qc1xuZnVuY3Rpb24gX25vbkl0ZXJhYmxlU3ByZWFkKCkge1xuICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiSW52YWxpZCBhdHRlbXB0IHRvIHNwcmVhZCBub24taXRlcmFibGUgaW5zdGFuY2UuXFxuSW4gb3JkZXIgdG8gYmUgaXRlcmFibGUsIG5vbi1hcnJheSBvYmplY3RzIG11c3QgaGF2ZSBhIFtTeW1ib2wuaXRlcmF0b3JdKCkgbWV0aG9kLlwiKTtcbn1cbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS90b0NvbnN1bWFibGVBcnJheS5qc1xuXG5cblxuXG5mdW5jdGlvbiBfdG9Db25zdW1hYmxlQXJyYXkoYXJyKSB7XG4gIHJldHVybiBfYXJyYXlXaXRob3V0SG9sZXMoYXJyKSB8fCBfaXRlcmFibGVUb0FycmF5KGFycikgfHwgX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5KGFycikgfHwgX25vbkl0ZXJhYmxlU3ByZWFkKCk7XG59XG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvc3R1ZmYvY29uc3RhbnRzLmpzXG52YXIgU0VDT05EID0gMTAwMDtcbnZhciBNSU5VVEUgPSBTRUNPTkQgKiA2MDtcbnZhciBNSU5VVEUzID0gTUlOVVRFICogMztcbnZhciBNSU5VVEU1ID0gTUlOVVRFICogNTtcbnZhciBNSU5VVEUxNSA9IE1JTlVURSAqIDE1O1xudmFyIE1JTlVURTMwID0gTUlOVVRFICogMzA7XG52YXIgSE9VUiA9IE1JTlVURSAqIDYwO1xudmFyIEhPVVI0ID0gSE9VUiAqIDQ7XG52YXIgSE9VUjEyID0gSE9VUiAqIDEyO1xudmFyIERBWSA9IEhPVVIgKiAyNDtcbnZhciBXRUVLID0gREFZICogNztcbnZhciBNT05USCA9IFdFRUsgKiA0O1xudmFyIFlFQVIgPSBEQVkgKiAzNjU7XG52YXIgTU9OVEhNQVAgPSBbXCJKYW5cIiwgXCJGZWJcIiwgXCJNYXJcIiwgXCJBcHJcIiwgXCJNYXlcIiwgXCJKdW5cIiwgXCJKdWxcIiwgXCJBdWdcIiwgXCJTZXBcIiwgXCJPY3RcIiwgXCJOb3ZcIiwgXCJEZWNcIl07IC8vIEdyaWQgdGltZSBzdGVwc1xuXG52YXIgVElNRVNDQUxFUyA9IFtZRUFSICogMTAsIFlFQVIgKiA1LCBZRUFSICogMywgWUVBUiAqIDIsIFlFQVIsIE1PTlRIICogNiwgTU9OVEggKiA0LCBNT05USCAqIDMsIE1PTlRIICogMiwgTU9OVEgsIERBWSAqIDE1LCBEQVkgKiAxMCwgREFZICogNywgREFZICogNSwgREFZICogMywgREFZICogMiwgREFZLCBIT1VSICogMTIsIEhPVVIgKiA2LCBIT1VSICogMywgSE9VUiAqIDEuNSwgSE9VUiwgTUlOVVRFMzAsIE1JTlVURTE1LCBNSU5VVEUgKiAxMCwgTUlOVVRFNSwgTUlOVVRFICogMiwgTUlOVVRFXTsgLy8gR3JpZCAkIHN0ZXBzXG5cbnZhciAkU0NBTEVTID0gWzAuMDUsIDAuMSwgMC4yLCAwLjI1LCAwLjUsIDAuOCwgMSwgMiwgNV07XG52YXIgQ2hhcnRDb25maWcgPSB7XG4gIFNCTUlOOiA2MCxcbiAgLy8gTWluaW1hbCBzaWRlYmFyIHB4XG4gIFNCTUFYOiBJbmZpbml0eSxcbiAgLy8gTWF4IHNpZGViYXIsIHB4XG4gIFRPT0xCQVI6IDU3LFxuICAvLyBUb29sYmFyIHdpZHRoIHB4XG4gIFRCX0lDT046IDI1LFxuICAvLyBUb29sYmFyIGljb24gc2l6ZSBweFxuICBUQl9JVEVNX006IDYsXG4gIC8vIFRvb2xiYXIgaXRlbSBtYXJnaW4gcHhcbiAgVEJfSUNPTl9CUkk6IDEsXG4gIC8vIFRvb2xiYXIgaWNvbiBicmlnaHRuZXNzXG4gIFRCX0lDT05fSE9MRDogNDIwLFxuICAvLyBtcywgd2FpdCB0byBleHBhbmRcbiAgVEJfQk9SREVSOiAxLFxuICAvLyBUb29sYmFyIGJvcmRlciBweFxuICBUQl9CX1NUWUxFOiAnZG90dGVkJyxcbiAgLy8gVG9vbGJhciBib3JkZXIgc3R5bGVcbiAgVE9PTF9DT0xMOiA3LFxuICAvLyBUb29sIGNvbGxpc2lvbiB0aHJlc2hvbGRcbiAgRVhQQU5EOiAwLjE1LFxuICAvLyAlLzEwMCBvZiByYW5nZVxuICBDQU5ETEVXOiAwLjYsXG4gIC8vICUvMTAwIG9mIHN0ZXBcbiAgR1JJRFg6IDEwMCxcbiAgLy8gcHhcbiAgR1JJRFk6IDQ3LFxuICAvLyBweFxuICBCT1RCQVI6IDI4LFxuICAvLyBweFxuICBQQU5IRUlHSFQ6IDIyLFxuICAvLyBweFxuICBERUZBVUxUX0xFTjogNTAsXG4gIC8vIGNhbmRsZXNcbiAgTUlOSU1VTV9MRU46IDUsXG4gIC8vIGNhbmRsZXMsXG4gIE1JTl9aT09NOiAyNSxcbiAgLy8gY2FuZGxlc1xuICBNQVhfWk9PTTogMTAwMCxcbiAgLy8gY2FuZGxlcyxcbiAgVk9MU0NBTEU6IDAuMTUsXG4gIC8vICUvMTAwIG9mIGhlaWdodFxuICBVWF9PUEFDSVRZOiAwLjksXG4gIC8vIFV4IGJhY2tncm91bmQgb3BhY2l0eVxuICBaT09NX01PREU6ICd0dicsXG4gIC8vICd0dicgb3IgJ3RsJ1xuICBMX0JUTl9TSVpFOiAyMSxcbiAgLy8gTGVnZW5kIEJ1dHRvbiBzaXplLCBweFxuICBMX0JUTl9NQVJHSU46ICctNnB4IDAgLTZweCAwJyxcbiAgLy8gY3NzIG1hcmdpblxuICBTQ1JPTExfV0hFRUw6ICdwcmV2ZW50JyAvLyAncGFzcycsICdjbGljaydcblxufTtcbkNoYXJ0Q29uZmlnLkZPTlQgPSBcIjExcHggLWFwcGxlLXN5c3RlbSxCbGlua01hY1N5c3RlbUZvbnQsXFxuICAgIFNlZ29lIFVJLFJvYm90byxPeHlnZW4sVWJ1bnR1LENhbnRhcmVsbCxcXG4gICAgRmlyYSBTYW5zLERyb2lkIFNhbnMsSGVsdmV0aWNhIE5ldWUsXFxuICAgIHNhbnMtc2VyaWZcIjtcbnZhciBJQl9URl9XQVJOID0gXCJXaGVuIHVzaW5nIElCIG1vZGUgeW91IHNob3VsZCBzcGVjaWZ5IFwiICsgXCJ0aW1lZnJhbWUgKCd0ZicgZmlsZWQgaW4gJ2NoYXJ0JyBvYmplY3QpLFwiICsgXCJvdGhlcndpc2UgeW91IGNhbiBnZXQgYW4gdW5leHBlY3RlZCBiZWhhdmlvdXJcIjtcbnZhciBNQVBfVU5JVCA9IHtcbiAgXCIxc1wiOiBTRUNPTkQsXG4gIFwiNXNcIjogU0VDT05EICogNSxcbiAgXCIxMHNcIjogU0VDT05EICogMTAsXG4gIFwiMjBzXCI6IFNFQ09ORCAqIDIwLFxuICBcIjMwc1wiOiBTRUNPTkQgKiAzMCxcbiAgXCIxbVwiOiBNSU5VVEUsXG4gIFwiM21cIjogTUlOVVRFMyxcbiAgXCI1bVwiOiBNSU5VVEU1LFxuICBcIjE1bVwiOiBNSU5VVEUxNSxcbiAgXCIzMG1cIjogTUlOVVRFMzAsXG4gIFwiMUhcIjogSE9VUixcbiAgXCIySFwiOiBIT1VSICogMixcbiAgXCIzSFwiOiBIT1VSICogMyxcbiAgXCI0SFwiOiBIT1VSNCxcbiAgXCIxMkhcIjogSE9VUjEyLFxuICBcIjFEXCI6IERBWSxcbiAgXCIxV1wiOiBXRUVLLFxuICBcIjFNXCI6IE1PTlRILFxuICBcIjFZXCI6IFlFQVJcbn07XG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIGNvbnN0IGNvbnN0YW50cyA9ICh7XG4gIFNFQ09ORDogU0VDT05ELFxuICBNSU5VVEU6IE1JTlVURSxcbiAgTUlOVVRFNTogTUlOVVRFNSxcbiAgTUlOVVRFMTU6IE1JTlVURTE1LFxuICBNSU5VVEUzMDogTUlOVVRFMzAsXG4gIEhPVVI6IEhPVVIsXG4gIEhPVVI0OiBIT1VSNCxcbiAgREFZOiBEQVksXG4gIFdFRUs6IFdFRUssXG4gIE1PTlRIOiBNT05USCxcbiAgWUVBUjogWUVBUixcbiAgTU9OVEhNQVA6IE1PTlRITUFQLFxuICBUSU1FU0NBTEVTOiBUSU1FU0NBTEVTLFxuICAkU0NBTEVTOiAkU0NBTEVTLFxuICBDaGFydENvbmZpZzogQ2hhcnRDb25maWcsXG4gIG1hcF91bml0OiBNQVBfVU5JVCxcbiAgSUJfVEZfV0FSTjogSUJfVEZfV0FSTlxufSk7XG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvbG9hZGVycy90ZW1wbGF0ZUxvYWRlci5qcz8/dnVlLWxvYWRlci1vcHRpb25zIS4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL2luZGV4LmpzPz92dWUtbG9hZGVyLW9wdGlvbnMhLi9zcmMvY29tcG9uZW50cy9DaGFydC52dWU/dnVlJnR5cGU9dGVtcGxhdGUmaWQ9NGQwNmE0ZGUmXG52YXIgQ2hhcnR2dWVfdHlwZV90ZW1wbGF0ZV9pZF80ZDA2YTRkZV9yZW5kZXIgPSBmdW5jdGlvbigpIHtcbiAgdmFyIF92bSA9IHRoaXNcbiAgdmFyIF9oID0gX3ZtLiRjcmVhdGVFbGVtZW50XG4gIHZhciBfYyA9IF92bS5fc2VsZi5fYyB8fCBfaFxuICByZXR1cm4gX2MoXG4gICAgXCJkaXZcIixcbiAgICB7IHN0YXRpY0NsYXNzOiBcInRyYWRpbmctdnVlLWNoYXJ0XCIsIHN0eWxlOiBfdm0uc3R5bGVzIH0sXG4gICAgW1xuICAgICAgX2MoXCJrZXlib2FyZFwiLCB7IHJlZjogXCJrZXlib2FyZFwiIH0pLFxuICAgICAgX3ZtLl92KFwiIFwiKSxcbiAgICAgIF92bS5fbCh0aGlzLl9sYXlvdXQuZ3JpZHMsIGZ1bmN0aW9uKGdyaWQsIGkpIHtcbiAgICAgICAgcmV0dXJuIF9jKFwiZ3JpZC1zZWN0aW9uXCIsIHtcbiAgICAgICAgICBrZXk6IGdyaWQuaWQsXG4gICAgICAgICAgcmVmOiBcInNlY1wiLFxuICAgICAgICAgIHJlZkluRm9yOiB0cnVlLFxuICAgICAgICAgIGF0dHJzOiB7IGNvbW1vbjogX3ZtLnNlY3Rpb25fcHJvcHMoaSksIGdyaWRfaWQ6IGkgfSxcbiAgICAgICAgICBvbjoge1xuICAgICAgICAgICAgXCJyZWdpc3Rlci1rYi1saXN0ZW5lclwiOiBfdm0ucmVnaXN0ZXJfa2IsXG4gICAgICAgICAgICBcInJlbW92ZS1rYi1saXN0ZW5lclwiOiBfdm0ucmVtb3ZlX2tiLFxuICAgICAgICAgICAgXCJyYW5nZS1jaGFuZ2VkXCI6IF92bS5yYW5nZV9jaGFuZ2VkLFxuICAgICAgICAgICAgXCJjdXJzb3ItY2hhbmdlZFwiOiBfdm0uY3Vyc29yX2NoYW5nZWQsXG4gICAgICAgICAgICBcImN1cnNvci1sb2NrZWRcIjogX3ZtLmN1cnNvcl9sb2NrZWQsXG4gICAgICAgICAgICBcInNpZGViYXItdHJhbnNmb3JtXCI6IF92bS5zZXRfeXRyYW5zZm9ybSxcbiAgICAgICAgICAgIFwibGF5ZXItbWV0YS1wcm9wc1wiOiBfdm0ubGF5ZXJfbWV0YV9wcm9wcyxcbiAgICAgICAgICAgIFwiY3VzdG9tLWV2ZW50XCI6IF92bS5lbWl0X2N1c3RvbV9ldmVudCxcbiAgICAgICAgICAgIFwibGVnZW5kLWJ1dHRvbi1jbGlja1wiOiBfdm0ubGVnZW5kX2J1dHRvbl9jbGlja1xuICAgICAgICAgIH1cbiAgICAgICAgfSlcbiAgICAgIH0pLFxuICAgICAgX3ZtLl92KFwiIFwiKSxcbiAgICAgIF9jKFxuICAgICAgICBcImJvdGJhclwiLFxuICAgICAgICBfdm0uX2IoXG4gICAgICAgICAgeyBhdHRyczogeyBzaGFkZXJzOiBfdm0uc2hhZGVycywgdGltZXpvbmU6IF92bS50aW1lem9uZSB9IH0sXG4gICAgICAgICAgXCJib3RiYXJcIixcbiAgICAgICAgICBfdm0uYm90YmFyX3Byb3BzLFxuICAgICAgICAgIGZhbHNlXG4gICAgICAgIClcbiAgICAgIClcbiAgICBdLFxuICAgIDJcbiAgKVxufVxudmFyIENoYXJ0dnVlX3R5cGVfdGVtcGxhdGVfaWRfNGQwNmE0ZGVfc3RhdGljUmVuZGVyRm5zID0gW11cbkNoYXJ0dnVlX3R5cGVfdGVtcGxhdGVfaWRfNGQwNmE0ZGVfcmVuZGVyLl93aXRoU3RyaXBwZWQgPSB0cnVlXG5cblxuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL2NvbXBvbmVudHMvQ2hhcnQudnVlP3Z1ZSZ0eXBlPXRlbXBsYXRlJmlkPTRkMDZhNGRlJlxuXG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vYXJyYXlXaXRoSG9sZXMuanNcbmZ1bmN0aW9uIF9hcnJheVdpdGhIb2xlcyhhcnIpIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkoYXJyKSkgcmV0dXJuIGFycjtcbn1cbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9pdGVyYWJsZVRvQXJyYXlMaW1pdC5qc1xuZnVuY3Rpb24gX2l0ZXJhYmxlVG9BcnJheUxpbWl0KGFyciwgaSkge1xuICBpZiAodHlwZW9mIFN5bWJvbCA9PT0gXCJ1bmRlZmluZWRcIiB8fCAhKFN5bWJvbC5pdGVyYXRvciBpbiBPYmplY3QoYXJyKSkpIHJldHVybjtcbiAgdmFyIF9hcnIgPSBbXTtcbiAgdmFyIF9uID0gdHJ1ZTtcbiAgdmFyIF9kID0gZmFsc2U7XG4gIHZhciBfZSA9IHVuZGVmaW5lZDtcblxuICB0cnkge1xuICAgIGZvciAodmFyIF9pID0gYXJyW1N5bWJvbC5pdGVyYXRvcl0oKSwgX3M7ICEoX24gPSAoX3MgPSBfaS5uZXh0KCkpLmRvbmUpOyBfbiA9IHRydWUpIHtcbiAgICAgIF9hcnIucHVzaChfcy52YWx1ZSk7XG5cbiAgICAgIGlmIChpICYmIF9hcnIubGVuZ3RoID09PSBpKSBicmVhaztcbiAgICB9XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIF9kID0gdHJ1ZTtcbiAgICBfZSA9IGVycjtcbiAgfSBmaW5hbGx5IHtcbiAgICB0cnkge1xuICAgICAgaWYgKCFfbiAmJiBfaVtcInJldHVyblwiXSAhPSBudWxsKSBfaVtcInJldHVyblwiXSgpO1xuICAgIH0gZmluYWxseSB7XG4gICAgICBpZiAoX2QpIHRocm93IF9lO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBfYXJyO1xufVxuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL25vbkl0ZXJhYmxlUmVzdC5qc1xuZnVuY3Rpb24gX25vbkl0ZXJhYmxlUmVzdCgpIHtcbiAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkludmFsaWQgYXR0ZW1wdCB0byBkZXN0cnVjdHVyZSBub24taXRlcmFibGUgaW5zdGFuY2UuXFxuSW4gb3JkZXIgdG8gYmUgaXRlcmFibGUsIG5vbi1hcnJheSBvYmplY3RzIG11c3QgaGF2ZSBhIFtTeW1ib2wuaXRlcmF0b3JdKCkgbWV0aG9kLlwiKTtcbn1cbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9zbGljZWRUb0FycmF5LmpzXG5cblxuXG5cbmZ1bmN0aW9uIF9zbGljZWRUb0FycmF5KGFyciwgaSkge1xuICByZXR1cm4gX2FycmF5V2l0aEhvbGVzKGFycikgfHwgX2l0ZXJhYmxlVG9BcnJheUxpbWl0KGFyciwgaSkgfHwgX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5KGFyciwgaSkgfHwgX25vbkl0ZXJhYmxlUmVzdCgpO1xufVxuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL3N0dWZmL2NvbnRleHQuanNcbi8vIENhbnZhcyBjb250ZXh0IGZvciB0ZXh0IG1lYXN1cm1lbnRzXG5mdW5jdGlvbiBDb250ZXh0KCRwKSB7XG4gIHZhciBlbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpO1xuICB2YXIgY3R4ID0gZWwuZ2V0Q29udGV4dChcIjJkXCIpO1xuICBjdHguZm9udCA9ICRwLmZvbnQ7XG4gIHJldHVybiBjdHg7XG59XG5cbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gY29uc3QgY29udGV4dCA9IChDb250ZXh0KTtcbi8vIEVYVEVSTkFMIE1PRFVMRTogLi9ub2RlX21vZHVsZXMvYXJyYXlzbGljZXIvbGliL2luZGV4LmpzXG52YXIgbGliID0gX193ZWJwYWNrX3JlcXVpcmVfXyg2NzgpO1xudmFyIGxpYl9kZWZhdWx0ID0gLyojX19QVVJFX18qL19fd2VicGFja19yZXF1aXJlX18ubihsaWIpO1xuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL3N0dWZmL3V0aWxzLmpzXG5cblxuXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIGNvbnN0IHV0aWxzID0gKHtcbiAgY2xhbXA6IGZ1bmN0aW9uIGNsYW1wKG51bSwgbWluLCBtYXgpIHtcbiAgICByZXR1cm4gbnVtIDw9IG1pbiA/IG1pbiA6IG51bSA+PSBtYXggPyBtYXggOiBudW07XG4gIH0sXG4gIGFkZF96ZXJvOiBmdW5jdGlvbiBhZGRfemVybyhpKSB7XG4gICAgaWYgKGkgPCAxMCkge1xuICAgICAgaSA9IFwiMFwiICsgaTtcbiAgICB9XG5cbiAgICByZXR1cm4gaTtcbiAgfSxcbiAgLy8gU3RhcnQgb2YgdGhlIGRheSAoemVybyBtaWxsaXNlY29uZClcbiAgZGF5X3N0YXJ0OiBmdW5jdGlvbiBkYXlfc3RhcnQodCkge1xuICAgIHZhciBzdGFydCA9IG5ldyBEYXRlKHQpO1xuICAgIHJldHVybiBzdGFydC5zZXRVVENIb3VycygwLCAwLCAwLCAwKTtcbiAgfSxcbiAgLy8gU3RhcnQgb2YgdGhlIG1vbnRoXG4gIG1vbnRoX3N0YXJ0OiBmdW5jdGlvbiBtb250aF9zdGFydCh0KSB7XG4gICAgdmFyIGRhdGUgPSBuZXcgRGF0ZSh0KTtcbiAgICByZXR1cm4gRGF0ZS5VVEMoZGF0ZS5nZXRGdWxsWWVhcigpLCBkYXRlLmdldE1vbnRoKCksIDEpO1xuICB9LFxuICAvLyBTdGFydCBvZiB0aGUgeWVhclxuICB5ZWFyX3N0YXJ0OiBmdW5jdGlvbiB5ZWFyX3N0YXJ0KHQpIHtcbiAgICByZXR1cm4gRGF0ZS5VVEMobmV3IERhdGUodCkuZ2V0RnVsbFllYXIoKSk7XG4gIH0sXG4gIGdldF95ZWFyOiBmdW5jdGlvbiBnZXRfeWVhcih0KSB7XG4gICAgaWYgKCF0KSByZXR1cm4gdW5kZWZpbmVkO1xuICAgIHJldHVybiBuZXcgRGF0ZSh0KS5nZXRVVENGdWxsWWVhcigpO1xuICB9LFxuICBnZXRfbW9udGg6IGZ1bmN0aW9uIGdldF9tb250aCh0KSB7XG4gICAgaWYgKCF0KSByZXR1cm4gdW5kZWZpbmVkO1xuICAgIHJldHVybiBuZXcgRGF0ZSh0KS5nZXRVVENNb250aCgpO1xuICB9LFxuICAvLyBOZWFyZXN0IGluIGFycmF5XG4gIG5lYXJlc3RfYTogZnVuY3Rpb24gbmVhcmVzdF9hKHgsIGFycmF5KSB7XG4gICAgdmFyIGRpc3QgPSBJbmZpbml0eTtcbiAgICB2YXIgdmFsID0gbnVsbDtcbiAgICB2YXIgaW5kZXggPSAtMTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJyYXkubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciB4aSA9IGFycmF5W2ldO1xuXG4gICAgICBpZiAoTWF0aC5hYnMoeGkgLSB4KSA8IGRpc3QpIHtcbiAgICAgICAgZGlzdCA9IE1hdGguYWJzKHhpIC0geCk7XG4gICAgICAgIHZhbCA9IHhpO1xuICAgICAgICBpbmRleCA9IGk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIFtpbmRleCwgdmFsXTtcbiAgfSxcbiAgcm91bmQ6IGZ1bmN0aW9uIHJvdW5kKG51bSwgZGVjaW1hbHMpIHtcbiAgICBpZiAoZGVjaW1hbHMgPT09IHZvaWQgMCkge1xuICAgICAgZGVjaW1hbHMgPSA4O1xuICAgIH1cblxuICAgIHJldHVybiBwYXJzZUZsb2F0KG51bS50b0ZpeGVkKGRlY2ltYWxzKSk7XG4gIH0sXG4gIC8vIFN0cmlwPyBObywgaXQncyB1Z2x5IGZsb2F0cyBpbiBqc1xuICBzdHJpcDogZnVuY3Rpb24gc3RyaXAobnVtYmVyKSB7XG4gICAgcmV0dXJuIHBhcnNlRmxvYXQocGFyc2VGbG9hdChudW1iZXIpLnRvUHJlY2lzaW9uKDEyKSk7XG4gIH0sXG4gIGdldF9kYXk6IGZ1bmN0aW9uIGdldF9kYXkodCkge1xuICAgIHJldHVybiB0ID8gbmV3IERhdGUodCkuZ2V0RGF0ZSgpIDogbnVsbDtcbiAgfSxcbiAgLy8gVXBkYXRlIGFycmF5IGtlZXBpbmcgdGhlIHNhbWUgcmVmZXJlbmNlXG4gIG92ZXJ3cml0ZTogZnVuY3Rpb24gb3ZlcndyaXRlKGFyciwgbmV3X2Fycikge1xuICAgIGFyci5zcGxpY2UuYXBwbHkoYXJyLCBbMCwgYXJyLmxlbmd0aF0uY29uY2F0KF90b0NvbnN1bWFibGVBcnJheShuZXdfYXJyKSkpO1xuICB9LFxuICAvLyBDb3B5IGxheW91dCBpbiByZWFjdGl2ZSB3YXlcbiAgY29weV9sYXlvdXQ6IGZ1bmN0aW9uIGNvcHlfbGF5b3V0KG9iaiwgbmV3X29iaikge1xuICAgIGZvciAodmFyIGsgaW4gb2JqKSB7XG4gICAgICBpZiAoQXJyYXkuaXNBcnJheShvYmpba10pKSB7XG4gICAgICAgIC8vIChzb21lIG9mZmNoYXJ0IGluZGljYXRvcnMgYXJlIGFkZGVkL3JlbW92ZWQpXG4gICAgICAgIC8vIHdlIG5lZWQgdG8gdXBkYXRlIGxheW91dCBpbiBhIHJlYWN0aXZlIHdheVxuICAgICAgICBpZiAob2JqW2tdLmxlbmd0aCAhPT0gbmV3X29ialtrXS5sZW5ndGgpIHtcbiAgICAgICAgICB0aGlzLm92ZXJ3cml0ZShvYmpba10sIG5ld19vYmpba10pO1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgZm9yICh2YXIgbSBpbiBvYmpba10pIHtcbiAgICAgICAgICBPYmplY3QuYXNzaWduKG9ialtrXVttXSwgbmV3X29ialtrXVttXSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIE9iamVjdC5hc3NpZ24ob2JqW2tdLCBuZXdfb2JqW2tdKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sXG4gIC8vIERldGVjdHMgY2FuZGxlcyBpbnRlcnZhbFxuICBkZXRlY3RfaW50ZXJ2YWw6IGZ1bmN0aW9uIGRldGVjdF9pbnRlcnZhbChvaGxjdikge1xuICAgIHZhciBsZW4gPSBNYXRoLm1pbihvaGxjdi5sZW5ndGggLSAxLCA5OSk7XG4gICAgdmFyIG1pbiA9IEluZmluaXR5O1xuICAgIG9obGN2LnNsaWNlKDAsIGxlbikuZm9yRWFjaChmdW5jdGlvbiAoeCwgaSkge1xuICAgICAgdmFyIGQgPSBvaGxjdltpICsgMV1bMF0gLSB4WzBdO1xuICAgICAgaWYgKGQgPT09IGQgJiYgZCA8IG1pbikgbWluID0gZDtcbiAgICB9KTsgLy8gVGhpcyBzYXZlcyBtb250aGx5IGNoYXJ0IGZyb20gYmVpbmcgYXdrd2FyZFxuXG4gICAgaWYgKG1pbiA+PSBjb25zdGFudHMuTU9OVEggJiYgbWluIDw9IGNvbnN0YW50cy5EQVkgKiAzMCkge1xuICAgICAgcmV0dXJuIGNvbnN0YW50cy5EQVkgKiAzMTtcbiAgICB9XG5cbiAgICByZXR1cm4gbWluO1xuICB9LFxuICAvLyBHZXRzIG51bWJlcmljIHBhcnQgb2Ygb3ZlcmxheSBpZCAoZS5nICdFTUFfMScgPSA+IDEpXG4gIGdldF9udW1faWQ6IGZ1bmN0aW9uIGdldF9udW1faWQoaWQpIHtcbiAgICByZXR1cm4gcGFyc2VJbnQoaWQuc3BsaXQoJ18nKS5wb3AoKSk7XG4gIH0sXG4gIC8vIEZhc3QgZmlsdGVyLiBSZWFsbHkgZmFzdCwgbGlrZSAxMFhcbiAgZmFzdF9maWx0ZXI6IGZ1bmN0aW9uIGZhc3RfZmlsdGVyKGFyciwgdDEsIHQyKSB7XG4gICAgaWYgKCFhcnIubGVuZ3RoKSByZXR1cm4gW2FyciwgdW5kZWZpbmVkXTtcblxuICAgIHRyeSB7XG4gICAgICB2YXIgaWEgPSBuZXcgKGxpYl9kZWZhdWx0KCkpKGFyciwgXCIwXCIpO1xuICAgICAgdmFyIHJlcyA9IGlhLmdldFJhbmdlKHQxLCB0Mik7XG4gICAgICB2YXIgaTAgPSBpYS52YWxwb3NbdDFdLm5leHQ7XG4gICAgICByZXR1cm4gW3JlcywgaTBdO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIC8vIFNvbWV0aGluZyB3cm9uZyB3aXRoIGZhbmN5IHNsaWNlIGxpYlxuICAgICAgLy8gRmFzdCBmaXg6IGZhbGxiYWNrIHRvIGZpbHRlclxuICAgICAgcmV0dXJuIFthcnIuZmlsdGVyKGZ1bmN0aW9uICh4KSB7XG4gICAgICAgIHJldHVybiB4WzBdID49IHQxICYmIHhbMF0gPD0gdDI7XG4gICAgICB9KSwgMF07XG4gICAgfVxuICB9LFxuICAvLyBGYXN0IGZpbHRlciAoaW5kZXgtYmFzZWQpXG4gIGZhc3RfZmlsdGVyX2k6IGZ1bmN0aW9uIGZhc3RfZmlsdGVyX2koYXJyLCB0MSwgdDIpIHtcbiAgICBpZiAoIWFyci5sZW5ndGgpIHJldHVybiBbYXJyLCB1bmRlZmluZWRdO1xuICAgIHZhciBpMSA9IE1hdGguZmxvb3IodDEpO1xuICAgIGlmIChpMSA8IDApIGkxID0gMDtcbiAgICB2YXIgaTIgPSBNYXRoLmZsb29yKHQyICsgMSk7XG4gICAgdmFyIHJlcyA9IGFyci5zbGljZShpMSwgaTIpO1xuICAgIHJldHVybiBbcmVzLCBpMV07XG4gIH0sXG4gIC8vIE5lYXJlc3QgaW5kZXhlcyAobGVmdCBhbmQgcmlnaHQpXG4gIGZhc3RfbmVhcmVzdDogZnVuY3Rpb24gZmFzdF9uZWFyZXN0KGFyciwgdDEpIHtcbiAgICB2YXIgaWEgPSBuZXcgKGxpYl9kZWZhdWx0KCkpKGFyciwgXCIwXCIpO1xuICAgIGlhLmZldGNoKHQxKTtcbiAgICByZXR1cm4gW2lhLm5leHRsb3csIGlhLm5leHRoaWdoXTtcbiAgfSxcbiAgbm93OiBmdW5jdGlvbiBub3coKSB7XG4gICAgcmV0dXJuIG5ldyBEYXRlKCkuZ2V0VGltZSgpO1xuICB9LFxuICBwYXVzZTogZnVuY3Rpb24gcGF1c2UoZGVsYXkpIHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJzLCByaikge1xuICAgICAgcmV0dXJuIHNldFRpbWVvdXQocnMsIGRlbGF5KTtcbiAgICB9KTtcbiAgfSxcbiAgLy8gTGltaXQgY3Jhenkgd2hlZWwgZGVsdGEgdmFsdWVzXG4gIHNtYXJ0X3doZWVsOiBmdW5jdGlvbiBzbWFydF93aGVlbChkZWx0YSkge1xuICAgIHZhciBhYnMgPSBNYXRoLmFicyhkZWx0YSk7XG5cbiAgICBpZiAoYWJzID4gNTAwKSB7XG4gICAgICByZXR1cm4gKDIwMCArIE1hdGgubG9nKGFicykpICogTWF0aC5zaWduKGRlbHRhKTtcbiAgICB9XG5cbiAgICByZXR1cm4gZGVsdGE7XG4gIH0sXG4gIC8vIFBhcnNlIHRoZSBvcmlnaW5hbCBtb3VzZSBldmVudCB0byBmaW5kIGRlbHRhWFxuICBnZXRfZGVsdGFYOiBmdW5jdGlvbiBnZXRfZGVsdGFYKGV2ZW50KSB7XG4gICAgcmV0dXJuIGV2ZW50Lm9yaWdpbmFsRXZlbnQuZGVsdGFYIC8gMTI7XG4gIH0sXG4gIC8vIFBhcnNlIHRoZSBvcmlnaW5hbCBtb3VzZSBldmVudCB0byBmaW5kIGRlbHRhWVxuICBnZXRfZGVsdGFZOiBmdW5jdGlvbiBnZXRfZGVsdGFZKGV2ZW50KSB7XG4gICAgcmV0dXJuIGV2ZW50Lm9yaWdpbmFsRXZlbnQuZGVsdGFZIC8gMTI7XG4gIH0sXG4gIC8vIEFwcGx5IG9wYWNpdHkgdG8gYSBoZXggY29sb3JcbiAgYXBwbHlfb3BhY2l0eTogZnVuY3Rpb24gYXBwbHlfb3BhY2l0eShjLCBvcCkge1xuICAgIGlmIChjLmxlbmd0aCA9PT0gNykge1xuICAgICAgdmFyIG4gPSBNYXRoLmZsb29yKG9wICogMjU1KTtcbiAgICAgIG4gPSB0aGlzLmNsYW1wKG4sIDAsIDI1NSk7XG4gICAgICBjICs9IG4udG9TdHJpbmcoMTYpO1xuICAgIH1cblxuICAgIHJldHVybiBjO1xuICB9LFxuICAvLyBQYXJzZSB0aW1lZnJhbWUgb3IgcmV0dXJuIHZhbHVlIGluIG1zXG4gIHBhcnNlX3RmOiBmdW5jdGlvbiBwYXJzZV90ZihzbXRoKSB7XG4gICAgaWYgKHR5cGVvZiBzbXRoID09PSAnc3RyaW5nJykge1xuICAgICAgcmV0dXJuIGNvbnN0YW50cy5tYXBfdW5pdFtzbXRoXTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHNtdGg7XG4gICAgfVxuICB9LFxuICAvLyBEZXRlY3QgaW5kZXggc2hpZnQgYmV0d2VlbiB0aGUgbWFpbiBkYXRhIHN1YlxuICAvLyBhbmQgdGhlIG92ZXJsYXkncyBzdWIgKGZvciBJQi1tb2RlKVxuICBpbmRleF9zaGlmdDogZnVuY3Rpb24gaW5kZXhfc2hpZnQoc3ViLCBkYXRhKSB7XG4gICAgLy8gRmluZCB0aGUgc2Vjb25kIHRpbWVzdGFtcCAoYnkgdmFsdWUpXG4gICAgaWYgKCFkYXRhLmxlbmd0aCkgcmV0dXJuIDA7XG4gICAgdmFyIGZpcnN0ID0gZGF0YVswXVswXTtcbiAgICB2YXIgc2Vjb25kO1xuXG4gICAgZm9yICh2YXIgaSA9IDE7IGkgPCBkYXRhLmxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAoZGF0YVtpXVswXSAhPT0gZmlyc3QpIHtcbiAgICAgICAgc2Vjb25kID0gZGF0YVtpXVswXTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuXG4gICAgZm9yICh2YXIgaiA9IDA7IGogPCBzdWIubGVuZ3RoOyBqKyspIHtcbiAgICAgIGlmIChzdWJbal1bMF0gPT09IHNlY29uZCkge1xuICAgICAgICByZXR1cm4gaiAtIGk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIDA7XG4gIH0sXG4gIC8vIEZhbGxiYWNrIGZpeCBmb3IgQnJhdmUgYnJvd3NlclxuICAvLyBodHRwczovL2dpdGh1Yi5jb20vYnJhdmUvYnJhdmUtYnJvd3Nlci9pc3N1ZXMvMTczOFxuICBtZWFzdXJlVGV4dDogZnVuY3Rpb24gbWVhc3VyZVRleHQoY3R4LCB0ZXh0LCB0dl9pZCkge1xuICAgIHZhciBtID0gY3R4Lm1lYXN1cmVUZXh0T3JnKHRleHQpO1xuXG4gICAgaWYgKG0ud2lkdGggPT09IDApIHtcbiAgICAgIHZhciBkb2MgPSBkb2N1bWVudDtcbiAgICAgIHZhciBpZCA9ICd0dmpzLW1lYXN1cmUtdGV4dCc7XG4gICAgICB2YXIgZWwgPSBkb2MuZ2V0RWxlbWVudEJ5SWQoaWQpO1xuXG4gICAgICBpZiAoIWVsKSB7XG4gICAgICAgIHZhciBiYXNlID0gZG9jLmdldEVsZW1lbnRCeUlkKHR2X2lkKTtcbiAgICAgICAgZWwgPSBkb2MuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICAgICAgZWwuaWQgPSBpZDtcbiAgICAgICAgZWwuc3R5bGUucG9zaXRpb24gPSAnYWJzb2x1dGUnO1xuICAgICAgICBlbC5zdHlsZS50b3AgPSAnLTEwMDBweCc7XG4gICAgICAgIGJhc2UuYXBwZW5kQ2hpbGQoZWwpO1xuICAgICAgfVxuXG4gICAgICBpZiAoY3R4LmZvbnQpIGVsLnN0eWxlLmZvbnQgPSBjdHguZm9udDtcbiAgICAgIGVsLmlubmVyVGV4dCA9IHRleHQucmVwbGFjZSgvIC9nLCAnLicpO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgd2lkdGg6IGVsLm9mZnNldFdpZHRoXG4gICAgICB9O1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gbTtcbiAgICB9XG4gIH0sXG4gIHV1aWQ6IGZ1bmN0aW9uIHV1aWQodGVtcCkge1xuICAgIGlmICh0ZW1wID09PSB2b2lkIDApIHtcbiAgICAgIHRlbXAgPSAneHh4eHh4eHgteHh4eC00eHh4LXl4eHgteHh4eHh4eHh4eHh4JztcbiAgICB9XG5cbiAgICByZXR1cm4gdGVtcC5yZXBsYWNlKC9beHldL2csIGZ1bmN0aW9uIChjKSB7XG4gICAgICB2YXIgciA9IE1hdGgucmFuZG9tKCkgKiAxNiB8IDAsXG4gICAgICAgICAgdiA9IGMgPT0gJ3gnID8gciA6IHIgJiAweDMgfCAweDg7XG4gICAgICByZXR1cm4gdi50b1N0cmluZygxNik7XG4gICAgfSk7XG4gIH0sXG4gIHV1aWQyOiBmdW5jdGlvbiB1dWlkMigpIHtcbiAgICByZXR1cm4gdGhpcy51dWlkKCd4eHh4eHh4eHh4eHgnKTtcbiAgfSxcbiAgLy8gRGVsYXllZCB3YXJuaW5nLCBmID0gY29uZGl0aW9uIGxhbWJkYSBmblxuICB3YXJuOiBmdW5jdGlvbiB3YXJuKGYsIHRleHQsIGRlbGF5KSB7XG4gICAgaWYgKGRlbGF5ID09PSB2b2lkIDApIHtcbiAgICAgIGRlbGF5ID0gMDtcbiAgICB9XG5cbiAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmIChmKCkpIGNvbnNvbGUud2Fybih0ZXh0KTtcbiAgICB9LCBkZWxheSk7XG4gIH0sXG4gIC8vIENoZWNrcyBpZiBzY3JpcHQgcHJvcHMgdXBkYXRlZFxuICAvLyAoYW5kIG5vdCBzdHlsZSBzZXR0aW5ncyBvciBzb21ldGhpbmcgZWxzZSlcbiAgaXNfc2NyX3Byb3BzX3VwZDogZnVuY3Rpb24gaXNfc2NyX3Byb3BzX3VwZChuLCBwcmV2KSB7XG4gICAgdmFyIHAgPSBwcmV2LmZpbmQoZnVuY3Rpb24gKHgpIHtcbiAgICAgIHJldHVybiB4LnYuJHV1aWQgPT09IG4udi4kdXVpZDtcbiAgICB9KTtcbiAgICBpZiAoIXApIHJldHVybiBmYWxzZTtcbiAgICB2YXIgcHJvcHMgPSBuLnAuc2V0dGluZ3MuJHByb3BzO1xuICAgIGlmICghcHJvcHMpIHJldHVybiBmYWxzZTtcbiAgICByZXR1cm4gcHJvcHMuc29tZShmdW5jdGlvbiAoeCkge1xuICAgICAgcmV0dXJuIG4udlt4XSAhPT0gcC52W3hdO1xuICAgIH0pO1xuICB9LFxuICAvLyBDaGVja3MgaWYgaXQncyB0aW1lIHRvIG1ha2UgYSBzY3JpcHQgdXBkYXRlXG4gIC8vIChiYXNlZCBvbiBleGVjSW50ZXJ2YWwgaW4gbXMpXG4gIGRlbGF5ZWRfZXhlYzogZnVuY3Rpb24gZGVsYXllZF9leGVjKHYpIHtcbiAgICBpZiAoIXYuc2NyaXB0IHx8ICF2LnNjcmlwdC5leGVjSW50ZXJ2YWwpIHJldHVybiB0cnVlO1xuICAgIHZhciB0ID0gdGhpcy5ub3coKTtcbiAgICB2YXIgZHQgPSB2LnNjcmlwdC5leGVjSW50ZXJ2YWw7XG5cbiAgICBpZiAoIXYuc2V0dGluZ3MuJGxhc3RfZXhlYyB8fCB0ID4gdi5zZXR0aW5ncy4kbGFzdF9leGVjICsgZHQpIHtcbiAgICAgIHYuc2V0dGluZ3MuJGxhc3RfZXhlYyA9IHQ7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICByZXR1cm4gZmFsc2U7XG4gIH0sXG4gIC8vIEZvcm1hdCBuYW1lcyBzdWNoICdSU0ksICRsZW5ndGgnLCB3aGVyZVxuICAvLyBsZW5ndGggLSBpcyBvbmUgb2YgdGhlIHNldHRpbmdzXG4gIGZvcm1hdF9uYW1lOiBmdW5jdGlvbiBmb3JtYXRfbmFtZShvdikge1xuICAgIGlmICghb3YubmFtZSkgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB2YXIgbmFtZSA9IG92Lm5hbWU7XG5cbiAgICBmb3IgKHZhciBrIGluIG92LnNldHRpbmdzIHx8IHt9KSB7XG4gICAgICB2YXIgdmFsID0gb3Yuc2V0dGluZ3Nba107XG4gICAgICB2YXIgcmVnID0gbmV3IFJlZ0V4cChcIlxcXFwkXCIuY29uY2F0KGspLCAnZycpO1xuICAgICAgbmFtZSA9IG5hbWUucmVwbGFjZShyZWcsIHZhbCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG5hbWU7XG4gIH0sXG4gIC8vIERlZmF1bHQgY3Vyc29yIG1vZGVcbiAgeG1vZGU6IGZ1bmN0aW9uIHhtb2RlKCkge1xuICAgIHJldHVybiB0aGlzLmlzX21vYmlsZSA/ICdleHBsb3JlJyA6ICdkZWZhdWx0JztcbiAgfSxcbiAgZGVmYXVsdF9wcmV2ZW50ZWQ6IGZ1bmN0aW9uIGRlZmF1bHRfcHJldmVudGVkKGV2ZW50KSB7XG4gICAgaWYgKGV2ZW50Lm9yaWdpbmFsKSB7XG4gICAgICByZXR1cm4gZXZlbnQub3JpZ2luYWwuZGVmYXVsdFByZXZlbnRlZDtcbiAgICB9XG5cbiAgICByZXR1cm4gZXZlbnQuZGVmYXVsdFByZXZlbnRlZDtcbiAgfSxcbiAgLy8gV1RGIHdpdGggbW9kZXJuIHdlYiBkZXZlbG9wbWVudFxuICBpc19tb2JpbGU6IGZ1bmN0aW9uICh3KSB7XG4gICAgcmV0dXJuICdvbm9yaWVudGF0aW9uY2hhbmdlJyBpbiB3ICYmICghIW5hdmlnYXRvci5tYXhUb3VjaFBvaW50cyB8fCAhIW5hdmlnYXRvci5tc01heFRvdWNoUG9pbnRzIHx8ICdvbnRvdWNoc3RhcnQnIGluIHcgfHwgdy5Eb2N1bWVudFRvdWNoICYmIGRvY3VtZW50IGluc3RhbmNlb2Ygdy5Eb2N1bWVudFRvdWNoKTtcbiAgfSh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyA/IHdpbmRvdyA6IHt9KVxufSk7XG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvc3R1ZmYvbWF0aC5qc1xuLy8gTWF0aC9HZW9tZXRyeVxuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyBjb25zdCBtYXRoID0gKHtcbiAgLy8gRGlzdGFuY2UgZnJvbSBwb2ludCB0byBsaW5lXG4gIC8vIHAxID0gcG9pbnQsIChwMiwgcDMpID0gbGluZVxuICBwb2ludDJsaW5lOiBmdW5jdGlvbiBwb2ludDJsaW5lKHAxLCBwMiwgcDMpIHtcbiAgICB2YXIgX3RoaXMkdHJpID0gdGhpcy50cmkocDEsIHAyLCBwMyksXG4gICAgICAgIGFyZWEgPSBfdGhpcyR0cmkuYXJlYSxcbiAgICAgICAgYmFzZSA9IF90aGlzJHRyaS5iYXNlO1xuXG4gICAgcmV0dXJuIE1hdGguYWJzKHRoaXMudHJpX2goYXJlYSwgYmFzZSkpO1xuICB9LFxuICAvLyBEaXN0YW5jZSBmcm9tIHBvaW50IHRvIHNlZ21lbnRcbiAgLy8gcDEgPSBwb2ludCwgKHAyLCBwMykgPSBzZWdtZW50XG4gIHBvaW50MnNlZzogZnVuY3Rpb24gcG9pbnQyc2VnKHAxLCBwMiwgcDMpIHtcbiAgICB2YXIgX3RoaXMkdHJpMiA9IHRoaXMudHJpKHAxLCBwMiwgcDMpLFxuICAgICAgICBhcmVhID0gX3RoaXMkdHJpMi5hcmVhLFxuICAgICAgICBiYXNlID0gX3RoaXMkdHJpMi5iYXNlOyAvLyBWZWN0b3IgcHJvamVjdGlvblxuXG5cbiAgICB2YXIgcHJvaiA9IHRoaXMuZG90X3Byb2QocDEsIHAyLCBwMykgLyBiYXNlOyAvLyBEaXN0YW5jZSBmcm9tIGxlZnQgcGluXG5cbiAgICB2YXIgbDEgPSBNYXRoLm1heCgtcHJvaiwgMCk7IC8vIERpc3RhbmNlIGZyb20gcmlnaHQgcGluXG5cbiAgICB2YXIgbDIgPSBNYXRoLm1heChwcm9qIC0gYmFzZSwgMCk7IC8vIE5vcm1hbFxuXG4gICAgdmFyIGggPSBNYXRoLmFicyh0aGlzLnRyaV9oKGFyZWEsIGJhc2UpKTtcbiAgICByZXR1cm4gTWF0aC5tYXgoaCwgbDEsIGwyKTtcbiAgfSxcbiAgLy8gRGlzdGFuY2UgZnJvbSBwb2ludCB0byByYXlcbiAgLy8gcDEgPSBwb2ludCwgKHAyLCBwMykgPSByYXlcbiAgcG9pbnQycmF5OiBmdW5jdGlvbiBwb2ludDJyYXkocDEsIHAyLCBwMykge1xuICAgIHZhciBfdGhpcyR0cmkzID0gdGhpcy50cmkocDEsIHAyLCBwMyksXG4gICAgICAgIGFyZWEgPSBfdGhpcyR0cmkzLmFyZWEsXG4gICAgICAgIGJhc2UgPSBfdGhpcyR0cmkzLmJhc2U7IC8vIFZlY3RvciBwcm9qZWN0aW9uXG5cblxuICAgIHZhciBwcm9qID0gdGhpcy5kb3RfcHJvZChwMSwgcDIsIHAzKSAvIGJhc2U7IC8vIERpc3RhbmNlIGZyb20gbGVmdCBwaW5cblxuICAgIHZhciBsMSA9IE1hdGgubWF4KC1wcm9qLCAwKTsgLy8gTm9ybWFsXG5cbiAgICB2YXIgaCA9IE1hdGguYWJzKHRoaXMudHJpX2goYXJlYSwgYmFzZSkpO1xuICAgIHJldHVybiBNYXRoLm1heChoLCBsMSk7XG4gIH0sXG4gIHRyaTogZnVuY3Rpb24gdHJpKHAxLCBwMiwgcDMpIHtcbiAgICB2YXIgYXJlYSA9IHRoaXMuYXJlYShwMSwgcDIsIHAzKTtcbiAgICB2YXIgZHggPSBwM1swXSAtIHAyWzBdO1xuICAgIHZhciBkeSA9IHAzWzFdIC0gcDJbMV07XG4gICAgdmFyIGJhc2UgPSBNYXRoLnNxcnQoZHggKiBkeCArIGR5ICogZHkpO1xuICAgIHJldHVybiB7XG4gICAgICBhcmVhOiBhcmVhLFxuICAgICAgYmFzZTogYmFzZVxuICAgIH07XG4gIH0sXG5cbiAgLyogQXJlYSBvZiB0cmlhbmdsZTpcbiAgICAgICAgICBwMVxuICAgICAgICAvICAgIFxcXG4gICAgICBwMiAgXyAgcDNcbiAgKi9cbiAgYXJlYTogZnVuY3Rpb24gYXJlYShwMSwgcDIsIHAzKSB7XG4gICAgcmV0dXJuIHAxWzBdICogKHAyWzFdIC0gcDNbMV0pICsgcDJbMF0gKiAocDNbMV0gLSBwMVsxXSkgKyBwM1swXSAqIChwMVsxXSAtIHAyWzFdKTtcbiAgfSxcbiAgLy8gVHJpYW5nbGUgaGVpZ2h0XG4gIHRyaV9oOiBmdW5jdGlvbiB0cmlfaChhcmVhLCBiYXNlKSB7XG4gICAgcmV0dXJuIGFyZWEgLyBiYXNlO1xuICB9LFxuICAvLyBEb3QgcHJvZHVjdCBvZiAocDIsIHAzKSBhbmQgKHAyLCBwMSlcbiAgZG90X3Byb2Q6IGZ1bmN0aW9uIGRvdF9wcm9kKHAxLCBwMiwgcDMpIHtcbiAgICB2YXIgdjEgPSBbcDNbMF0gLSBwMlswXSwgcDNbMV0gLSBwMlsxXV07XG4gICAgdmFyIHYyID0gW3AxWzBdIC0gcDJbMF0sIHAxWzFdIC0gcDJbMV1dO1xuICAgIHJldHVybiB2MVswXSAqIHYyWzBdICsgdjFbMV0gKiB2MlsxXTtcbiAgfSxcbiAgLy8gU3ltbWV0cmljYWwgbG9nXG4gIGxvZzogZnVuY3Rpb24gbG9nKHgpIHtcbiAgICAvLyBUT0RPOiBsb2cgZm9yIHNtYWxsIHZhbHVlc1xuICAgIHJldHVybiBNYXRoLnNpZ24oeCkgKiBNYXRoLmxvZyhNYXRoLmFicyh4KSArIDEpO1xuICB9LFxuICAvLyBTeW1tZXRyaWNhbCBleHBcbiAgZXhwOiBmdW5jdGlvbiBleHAoeCkge1xuICAgIHJldHVybiBNYXRoLnNpZ24oeCkgKiAoTWF0aC5leHAoTWF0aC5hYnMoeCkpIC0gMSk7XG4gIH0sXG4gIC8vIE1pZGRsZSBsaW5lIG9uIGxvZyBzY2FsZSBiYXNlZCBvbiByYW5nZSAmIHB4IGhlaWdodFxuICBsb2dfbWlkOiBmdW5jdGlvbiBsb2dfbWlkKHIsIGgpIHtcbiAgICB2YXIgbG9nX2hpID0gdGhpcy5sb2coclswXSk7XG4gICAgdmFyIGxvZ19sbyA9IHRoaXMubG9nKHJbMV0pO1xuICAgIHZhciBweCA9IGggLyAyO1xuICAgIHZhciBneCA9IGxvZ19oaSAtIHB4ICogKGxvZ19oaSAtIGxvZ19sbykgLyBoO1xuICAgIHJldHVybiB0aGlzLmV4cChneCk7XG4gIH0sXG4gIC8vIFJldHVybiBuZXcgYWRqdXN0ZWQgcmFuZ2UsIGJhc2VkIG9uIHRoZSBwcmV2aW91c1xuICAvLyByYW5nZSwgbmV3ICRfaGksIHRhcmdldCBtaWRkbGUgbGluZVxuICByZV9yYW5nZTogZnVuY3Rpb24gcmVfcmFuZ2UocjEsIGhpMiwgbWlkKSB7XG4gICAgdmFyIGxvZ19oaTEgPSB0aGlzLmxvZyhyMVswXSk7XG4gICAgdmFyIGxvZ19sbzEgPSB0aGlzLmxvZyhyMVsxXSk7XG4gICAgdmFyIGxvZ19oaTIgPSB0aGlzLmxvZyhoaTIpO1xuICAgIHZhciBsb2dfJCA9IHRoaXMubG9nKG1pZCk7XG4gICAgdmFyIFcgPSAobG9nX2hpMiAtIGxvZ18kKSAqIChsb2dfaGkxIC0gbG9nX2xvMSkgLyAobG9nX2hpMSAtIGxvZ18kKTtcbiAgICByZXR1cm4gdGhpcy5leHAobG9nX2hpMiAtIFcpO1xuICB9IC8vIFJldHVybiBuZXcgYWRqdXN0ZWQgcmFuZ2UsIGJhc2VkIG9uIHRoZSBwcmV2aW91c1xuICAvLyByYW5nZSwgbmV3ICRfaGksIHRhcmdldCBtaWRkbGUgbGluZSArIGR5IChzaGlmdClcbiAgLy8gV0FTVEVcblxuICAvKnJhbmdlX3NoaWZ0KHIxLCBoaTIsIG1pZCwgZHksIGgpIHtcbiAgICAgIGxldCBsb2dfaGkxID0gdGhpcy5sb2cocjFbMF0pXG4gICAgICBsZXQgbG9nX2xvMSA9IHRoaXMubG9nKHIxWzFdKVxuICAgICAgbGV0IGxvZ19oaTIgPSB0aGlzLmxvZyhoaTIpXG4gICAgICBsZXQgbG9nXyQgPSB0aGlzLmxvZyhtaWQpXG4gICAgICAgbGV0IFcgPSBoICogKGxvZ19oaTIgLSBsb2dfJCkgL1xuICAgICAgICAgICAgICAoaCAqIChsb2dfaGkxIC0gbG9nXyQpIC8gKGxvZ19oaTEgLSBsb2dfbG8xKSArIGR5KVxuICAgICAgIHJldHVybiB0aGlzLmV4cChsb2dfaGkyIC0gVylcbiAgIH0qL1xuXG59KTtcbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9jb21wb25lbnRzL2pzL2xheW91dF9mbi5qc1xuLy8gTGF5b3V0IGZ1bmN0aW9uYWwgaW50ZXJmYWNlXG5cblxuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyBmdW5jdGlvbiBsYXlvdXRfZm4oc2VsZiwgcmFuZ2UpIHtcbiAgdmFyIGliID0gc2VsZi50aV9tYXAuaWI7XG4gIHZhciBkdCA9IHJhbmdlWzFdIC0gcmFuZ2VbMF07XG4gIHZhciByID0gc2VsZi5zcGFjZXggLyBkdDtcbiAgdmFyIGxzID0gc2VsZi5ncmlkLmxvZ1NjYWxlIHx8IGZhbHNlO1xuICBPYmplY3QuYXNzaWduKHNlbGYsIHtcbiAgICAvLyBUaW1lIHRvIHNjcmVlbiBjb29yZGluYXRlc1xuICAgIHQyc2NyZWVuOiBmdW5jdGlvbiB0MnNjcmVlbih0KSB7XG4gICAgICBpZiAoaWIpIHQgPSBzZWxmLnRpX21hcC5zbXRoMmkodCk7XG4gICAgICByZXR1cm4gTWF0aC5mbG9vcigodCAtIHJhbmdlWzBdKSAqIHIpIC0gMC41O1xuICAgIH0sXG4gICAgLy8gJCB0byBzY3JlZW4gY29vcmRpbmF0ZXNcbiAgICAkMnNjcmVlbjogZnVuY3Rpb24gJDJzY3JlZW4oeSkge1xuICAgICAgaWYgKGxzKSB5ID0gbWF0aC5sb2coeSk7XG4gICAgICByZXR1cm4gTWF0aC5mbG9vcih5ICogc2VsZi5BICsgc2VsZi5CKSAtIDAuNTtcbiAgICB9LFxuICAgIC8vIFRpbWUtYXhpcyBuZWFyZXN0IHN0ZXBcbiAgICB0X21hZ25ldDogZnVuY3Rpb24gdF9tYWduZXQodCkge1xuICAgICAgaWYgKGliKSB0ID0gc2VsZi50aV9tYXAuc210aDJpKHQpO1xuICAgICAgdmFyIGNuID0gc2VsZi5jYW5kbGVzIHx8IHNlbGYubWFzdGVyX2dyaWQuY2FuZGxlcztcbiAgICAgIHZhciBhcnIgPSBjbi5tYXAoZnVuY3Rpb24gKHgpIHtcbiAgICAgICAgcmV0dXJuIHgucmF3WzBdO1xuICAgICAgfSk7XG4gICAgICB2YXIgaSA9IHV0aWxzLm5lYXJlc3RfYSh0LCBhcnIpWzBdO1xuICAgICAgaWYgKCFjbltpXSkgcmV0dXJuO1xuICAgICAgcmV0dXJuIE1hdGguZmxvb3IoY25baV0ueCkgLSAwLjU7XG4gICAgfSxcbiAgICAvLyBTY3JlZW4tWSB0byBkb2xsYXIgdmFsdWUgKG9yIHdoYXRldmVyKVxuICAgIHNjcmVlbjIkOiBmdW5jdGlvbiBzY3JlZW4yJCh5KSB7XG4gICAgICBpZiAobHMpIHJldHVybiBtYXRoLmV4cCgoeSAtIHNlbGYuQikgLyBzZWxmLkEpO1xuICAgICAgcmV0dXJuICh5IC0gc2VsZi5CKSAvIHNlbGYuQTtcbiAgICB9LFxuICAgIC8vIFNjcmVlbi1YIHRvIHRpbWVzdGFtcFxuICAgIHNjcmVlbjJ0OiBmdW5jdGlvbiBzY3JlZW4ydCh4KSB7XG4gICAgICAvLyBUT0RPOiBtb3N0IGxpa2VseSBNYXRoLmZsb29yIG5vdCBuZWVkZWRcbiAgICAgIC8vIHJldHVybiBNYXRoLmZsb29yKHJhbmdlWzBdICsgeCAvIHIpXG4gICAgICByZXR1cm4gcmFuZ2VbMF0gKyB4IC8gcjtcbiAgICB9LFxuICAgIC8vICQtYXhpcyBuZWFyZXN0IHN0ZXBcbiAgICAkX21hZ25ldDogZnVuY3Rpb24gJF9tYWduZXQocHJpY2UpIHt9LFxuICAgIC8vIE5lYXJlc3QgY2FuZGxlc3RpY2tcbiAgICBjX21hZ25ldDogZnVuY3Rpb24gY19tYWduZXQodCkge1xuICAgICAgdmFyIGNuID0gc2VsZi5jYW5kbGVzIHx8IHNlbGYubWFzdGVyX2dyaWQuY2FuZGxlcztcbiAgICAgIHZhciBhcnIgPSBjbi5tYXAoZnVuY3Rpb24gKHgpIHtcbiAgICAgICAgcmV0dXJuIHgucmF3WzBdO1xuICAgICAgfSk7XG4gICAgICB2YXIgaSA9IHV0aWxzLm5lYXJlc3RfYSh0LCBhcnIpWzBdO1xuICAgICAgcmV0dXJuIGNuW2ldO1xuICAgIH0sXG4gICAgLy8gTmVhcmVzdCBkYXRhIHBvaW50c1xuICAgIGRhdGFfbWFnbmV0OiBmdW5jdGlvbiBkYXRhX21hZ25ldCh0KSB7XG4gICAgICAvKiBUT0RPOiBpbXBsZW1lbnQgKi9cbiAgICB9XG4gIH0pO1xuICByZXR1cm4gc2VsZjtcbn1cbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9jb21wb25lbnRzL2pzL2xvZ19zY2FsZS5qc1xuLy8gTG9nLXNjYWxlIG1vZGUgaGVscGVyc1xuLy8gVE9ETzogYWxsLW5lZ2F0aXZlIG51bWJlcnMgKHNvbWV0aW1lcyB3cm9uZyBzY2FsaW5nKVxuXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIGNvbnN0IGxvZ19zY2FsZSA9ICh7XG4gIGNhbmRsZTogZnVuY3Rpb24gY2FuZGxlKHNlbGYsIG1pZCwgcCwgJHApIHtcbiAgICByZXR1cm4ge1xuICAgICAgeDogbWlkLFxuICAgICAgdzogc2VsZi5weF9zdGVwICogJHAuY29uZmlnLkNBTkRMRVcsXG4gICAgICBvOiBNYXRoLmZsb29yKG1hdGgubG9nKHBbMV0pICogc2VsZi5BICsgc2VsZi5CKSxcbiAgICAgIGg6IE1hdGguZmxvb3IobWF0aC5sb2cocFsyXSkgKiBzZWxmLkEgKyBzZWxmLkIpLFxuICAgICAgbDogTWF0aC5mbG9vcihtYXRoLmxvZyhwWzNdKSAqIHNlbGYuQSArIHNlbGYuQiksXG4gICAgICBjOiBNYXRoLmZsb29yKG1hdGgubG9nKHBbNF0pICogc2VsZi5BICsgc2VsZi5CKSxcbiAgICAgIHJhdzogcFxuICAgIH07XG4gIH0sXG4gIGV4cGFuZDogZnVuY3Rpb24gZXhwYW5kKHNlbGYsIGhlaWdodCkge1xuICAgIC8vIGV4cGFuZCBsb2cgc2NhbGVcbiAgICB2YXIgQSA9IC1oZWlnaHQgLyAobWF0aC5sb2coc2VsZi4kX2hpKSAtIG1hdGgubG9nKHNlbGYuJF9sbykpO1xuICAgIHZhciBCID0gLW1hdGgubG9nKHNlbGYuJF9oaSkgKiBBO1xuICAgIHZhciB0b3AgPSAtaGVpZ2h0ICogMC4xO1xuICAgIHZhciBib3QgPSBoZWlnaHQgKiAxLjE7XG4gICAgc2VsZi4kX2hpID0gbWF0aC5leHAoKHRvcCAtIEIpIC8gQSk7XG4gICAgc2VsZi4kX2xvID0gbWF0aC5leHAoKGJvdCAtIEIpIC8gQSk7XG4gIH1cbn0pO1xuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL2NvbXBvbmVudHMvanMvZ3JpZF9tYWtlci5qc1xuXG5cblxuXG5cblxudmFyIGdyaWRfbWFrZXJfVElNRVNDQUxFUyA9IGNvbnN0YW50cy5USU1FU0NBTEVTLFxuICAgIGdyaWRfbWFrZXJfJFNDQUxFUyA9IGNvbnN0YW50cy4kU0NBTEVTLFxuICAgIGdyaWRfbWFrZXJfV0VFSyA9IGNvbnN0YW50cy5XRUVLLFxuICAgIGdyaWRfbWFrZXJfTU9OVEggPSBjb25zdGFudHMuTU9OVEgsXG4gICAgZ3JpZF9tYWtlcl9ZRUFSID0gY29uc3RhbnRzLllFQVIsXG4gICAgZ3JpZF9tYWtlcl9IT1VSID0gY29uc3RhbnRzLkhPVVIsXG4gICAgZ3JpZF9tYWtlcl9EQVkgPSBjb25zdGFudHMuREFZO1xudmFyIE1BWF9JTlQgPSBOdW1iZXIuTUFYX1NBRkVfSU5URUdFUjsgLy8gbWFzdGVyX2dyaWQgLSByZWYgdG8gdGhlIG1hc3RlciBncmlkXG5cbmZ1bmN0aW9uIEdyaWRNYWtlcihpZCwgcGFyYW1zLCBtYXN0ZXJfZ3JpZCkge1xuICBpZiAobWFzdGVyX2dyaWQgPT09IHZvaWQgMCkge1xuICAgIG1hc3Rlcl9ncmlkID0gbnVsbDtcbiAgfVxuXG4gIHZhciBzdWIgPSBwYXJhbXMuc3ViLFxuICAgICAgaW50ZXJ2YWwgPSBwYXJhbXMuaW50ZXJ2YWwsXG4gICAgICByYW5nZSA9IHBhcmFtcy5yYW5nZSxcbiAgICAgIGN0eCA9IHBhcmFtcy5jdHgsXG4gICAgICAkcCA9IHBhcmFtcy4kcCxcbiAgICAgIGxheWVyc19tZXRhID0gcGFyYW1zLmxheWVyc19tZXRhLFxuICAgICAgaGVpZ2h0ID0gcGFyYW1zLmhlaWdodCxcbiAgICAgIHlfdCA9IHBhcmFtcy55X3QsXG4gICAgICB0aV9tYXAgPSBwYXJhbXMudGlfbWFwLFxuICAgICAgZ3JpZCA9IHBhcmFtcy5ncmlkLFxuICAgICAgdGltZXpvbmUgPSBwYXJhbXMudGltZXpvbmU7XG4gIHZhciBzZWxmID0ge1xuICAgIHRpX21hcDogdGlfbWFwXG4gIH07XG4gIHZhciBsbSA9IGxheWVyc19tZXRhW2lkXTtcbiAgdmFyIHlfcmFuZ2VfZm4gPSBudWxsO1xuICB2YXIgbHMgPSBncmlkLmxvZ1NjYWxlO1xuXG4gIGlmIChsbSAmJiBPYmplY3Qua2V5cyhsbSkubGVuZ3RoKSB7XG4gICAgLy8gR2V0cyBsYXN0IHlfcmFuZ2UgZm4oKVxuICAgIHZhciB5cnMgPSBPYmplY3QudmFsdWVzKGxtKS5maWx0ZXIoZnVuY3Rpb24gKHgpIHtcbiAgICAgIHJldHVybiB4LnlfcmFuZ2U7XG4gICAgfSk7IC8vIFRoZSBmaXJzdCB5X3JhbmdlKCkgZGV0ZXJtaW5lcyB0aGUgcmFuZ2VcblxuICAgIGlmICh5cnMubGVuZ3RoKSB5X3JhbmdlX2ZuID0geXJzWzBdLnlfcmFuZ2U7XG4gIH0gLy8gQ2FsYyB2ZXJ0aWNhbCAoJC/igr8pIHJhbmdlXG5cblxuICBmdW5jdGlvbiBjYWxjXyRyYW5nZSgpIHtcbiAgICBpZiAoIW1hc3Rlcl9ncmlkKSB7XG4gICAgICAvLyAkIGNhbmRsZXN0aWNrIHJhbmdlXG4gICAgICBpZiAoeV9yYW5nZV9mbikge1xuICAgICAgICB2YXIgX3lfcmFuZ2VfZm4gPSB5X3JhbmdlX2ZuKGhpLCBsbyksXG4gICAgICAgICAgICBfeV9yYW5nZV9mbjIgPSBfc2xpY2VkVG9BcnJheShfeV9yYW5nZV9mbiwgMiksXG4gICAgICAgICAgICBoaSA9IF95X3JhbmdlX2ZuMlswXSxcbiAgICAgICAgICAgIGxvID0gX3lfcmFuZ2VfZm4yWzFdO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaGkgPSAtSW5maW5pdHksIGxvID0gSW5maW5pdHk7XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIG4gPSBzdWIubGVuZ3RoOyBpIDwgbjsgaSsrKSB7XG4gICAgICAgICAgdmFyIHggPSBzdWJbaV07XG4gICAgICAgICAgaWYgKHhbMl0gPiBoaSkgaGkgPSB4WzJdO1xuICAgICAgICAgIGlmICh4WzNdIDwgbG8pIGxvID0geFszXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBPZmZjaGFydCBpbmRpY2F0b3IgcmFuZ2VcbiAgICAgIGhpID0gLUluZmluaXR5LCBsbyA9IEluZmluaXR5O1xuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHN1Yi5sZW5ndGg7IGkrKykge1xuICAgICAgICBmb3IgKHZhciBqID0gMTsgaiA8IHN1YltpXS5sZW5ndGg7IGorKykge1xuICAgICAgICAgIHZhciB2ID0gc3ViW2ldW2pdO1xuICAgICAgICAgIGlmICh2ID4gaGkpIGhpID0gdjtcbiAgICAgICAgICBpZiAodiA8IGxvKSBsbyA9IHY7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKHlfcmFuZ2VfZm4pIHtcbiAgICAgICAgdmFyIF95X3JhbmdlX2ZuMyA9IHlfcmFuZ2VfZm4oaGksIGxvKSxcbiAgICAgICAgICAgIF95X3JhbmdlX2ZuNCA9IF9zbGljZWRUb0FycmF5KF95X3JhbmdlX2ZuMywgMyksXG4gICAgICAgICAgICBoaSA9IF95X3JhbmdlX2ZuNFswXSxcbiAgICAgICAgICAgIGxvID0gX3lfcmFuZ2VfZm40WzFdLFxuICAgICAgICAgICAgZXhwID0gX3lfcmFuZ2VfZm40WzJdO1xuICAgICAgfVxuICAgIH0gLy8gRml4ZWQgeS1yYW5nZSBpbiBub24tYXV0byBtb2RlXG5cblxuICAgIGlmICh5X3QgJiYgIXlfdC5hdXRvICYmIHlfdC5yYW5nZSkge1xuICAgICAgc2VsZi4kX2hpID0geV90LnJhbmdlWzBdO1xuICAgICAgc2VsZi4kX2xvID0geV90LnJhbmdlWzFdO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoIWxzKSB7XG4gICAgICAgIGV4cCA9IGV4cCA9PT0gZmFsc2UgPyAwIDogMTtcbiAgICAgICAgc2VsZi4kX2hpID0gaGkgKyAoaGkgLSBsbykgKiAkcC5jb25maWcuRVhQQU5EICogZXhwO1xuICAgICAgICBzZWxmLiRfbG8gPSBsbyAtIChoaSAtIGxvKSAqICRwLmNvbmZpZy5FWFBBTkQgKiBleHA7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzZWxmLiRfaGkgPSBoaTtcbiAgICAgICAgc2VsZi4kX2xvID0gbG87XG4gICAgICAgIGxvZ19zY2FsZS5leHBhbmQoc2VsZiwgaGVpZ2h0KTtcbiAgICAgIH1cblxuICAgICAgaWYgKHNlbGYuJF9oaSA9PT0gc2VsZi4kX2xvKSB7XG4gICAgICAgIGlmICghbHMpIHtcbiAgICAgICAgICBzZWxmLiRfaGkgKj0gMS4wNTsgLy8gRXhwYW5kIGlmIGhlaWdodCByYW5nZSA9PT0gMFxuXG4gICAgICAgICAgc2VsZi4kX2xvICo9IDAuOTU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbG9nX3NjYWxlLmV4cGFuZChzZWxmLCBoZWlnaHQpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gY2FsY19zaWRlYmFyKCkge1xuICAgIGlmIChzdWIubGVuZ3RoIDwgMikge1xuICAgICAgc2VsZi5wcmVjID0gMDtcbiAgICAgIHNlbGYuc2IgPSAkcC5jb25maWcuU0JNSU47XG4gICAgICByZXR1cm47XG4gICAgfSAvLyBUT0RPOiBpbXByb3ZlIHNpZGViYXIgd2lkdGggY2FsY3VsYXRpb25cbiAgICAvLyBhdCB0cmFuc2l0aW9uIHBvaW50LCB3aGVuIG9uZSBwcmVjaXNpb24gaXNcbiAgICAvLyByZXBsYWNlZCB3aXRoIGFub3RoZXJcbiAgICAvLyBHZXRzIGZvcm1hdGVkIGxldmVscyAodGhlaXIgbGVuZ3RocyksXG4gICAgLy8gY2FsY3VsYXRlcyBtYXggYW5kIG1lYXN1cmVzIHRoZSBzaWRlYmFyIGxlbmd0aFxuICAgIC8vIGZyb20gaXQ6XG4gICAgLy8gVE9ETzogYWRkIGN1c3RvbSBmb3JtYXR0ZXIgZigpXG5cblxuICAgIHNlbGYucHJlYyA9IGNhbGNfcHJlY2lzaW9uKHN1Yik7XG4gICAgdmFyIGxlbnMgPSBbXTtcbiAgICBsZW5zLnB1c2goc2VsZi4kX2hpLnRvRml4ZWQoc2VsZi5wcmVjKS5sZW5ndGgpO1xuICAgIGxlbnMucHVzaChzZWxmLiRfbG8udG9GaXhlZChzZWxmLnByZWMpLmxlbmd0aCk7XG4gICAgdmFyIHN0ciA9ICcwJy5yZXBlYXQoTWF0aC5tYXguYXBwbHkoTWF0aCwgbGVucykpICsgJyAgICAnO1xuICAgIHNlbGYuc2IgPSBjdHgubWVhc3VyZVRleHQoc3RyKS53aWR0aDtcbiAgICBzZWxmLnNiID0gTWF0aC5tYXgoTWF0aC5mbG9vcihzZWxmLnNiKSwgJHAuY29uZmlnLlNCTUlOKTtcbiAgICBzZWxmLnNiID0gTWF0aC5taW4oc2VsZi5zYiwgJHAuY29uZmlnLlNCTUFYKTtcbiAgfSAvLyBDYWxjdWxhdGUgJCBwcmVjaXNpb24gZm9yIHRoZSBZLWF4aXNcblxuXG4gIGZ1bmN0aW9uIGNhbGNfcHJlY2lzaW9uKGRhdGEpIHtcbiAgICB2YXIgbWF4X3IgPSAwLFxuICAgICAgICBtYXhfbCA9IDA7XG4gICAgdmFyIG1pbiA9IEluZmluaXR5O1xuICAgIHZhciBtYXggPSAtSW5maW5pdHk7IC8vIFNwZWVkIFVQXG5cbiAgICBmb3IgKHZhciBpID0gMCwgbiA9IGRhdGEubGVuZ3RoOyBpIDwgbjsgaSsrKSB7XG4gICAgICB2YXIgeCA9IGRhdGFbaV07XG4gICAgICBpZiAoeFsxXSA+IG1heCkgbWF4ID0geFsxXTtlbHNlIGlmICh4WzFdIDwgbWluKSBtaW4gPSB4WzFdO1xuICAgIH0gLy8gR2V0IG1heCBsZW5ndGhzIG9mIGludGVnZXIgYW5kIGZyYWN0aW9uYWwgcGFydHNcblxuXG4gICAgW21pbiwgbWF4XS5mb3JFYWNoKGZ1bmN0aW9uICh4KSB7XG4gICAgICAvLyBGaXggdW5kZWZpbmVkIGJ1Z1xuICAgICAgdmFyIHN0ciA9IHggIT0gbnVsbCA/IHgudG9TdHJpbmcoKSA6ICcnO1xuXG4gICAgICBpZiAoeCA8IDAuMDAwMDAxKSB7XG4gICAgICAgIC8vIFBhcnNpbmcgdGhlIGV4cG9uZW50aWFsIGZvcm0uIEdvc2ggdGhpc1xuICAgICAgICAvLyBzbWVsbHMgdHJpY2tpbHlcbiAgICAgICAgdmFyIF9zdHIkc3BsaXQgPSBzdHIuc3BsaXQoJ2UtJyksXG4gICAgICAgICAgICBfc3RyJHNwbGl0MiA9IF9zbGljZWRUb0FycmF5KF9zdHIkc3BsaXQsIDIpLFxuICAgICAgICAgICAgbHMgPSBfc3RyJHNwbGl0MlswXSxcbiAgICAgICAgICAgIHJzID0gX3N0ciRzcGxpdDJbMV07XG5cbiAgICAgICAgdmFyIF9scyRzcGxpdCA9IGxzLnNwbGl0KCcuJyksXG4gICAgICAgICAgICBfbHMkc3BsaXQyID0gX3NsaWNlZFRvQXJyYXkoX2xzJHNwbGl0LCAyKSxcbiAgICAgICAgICAgIGwgPSBfbHMkc3BsaXQyWzBdLFxuICAgICAgICAgICAgciA9IF9scyRzcGxpdDJbMV07XG5cbiAgICAgICAgaWYgKCFyKSByID0gJyc7XG4gICAgICAgIHIgPSB7XG4gICAgICAgICAgbGVuZ3RoOiByLmxlbmd0aCArIHBhcnNlSW50KHJzKSB8fCAwXG4gICAgICAgIH07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgX3N0ciRzcGxpdDMgPSBzdHIuc3BsaXQoJy4nKSxcbiAgICAgICAgICAgIF9zdHIkc3BsaXQ0ID0gX3NsaWNlZFRvQXJyYXkoX3N0ciRzcGxpdDMsIDIpLFxuICAgICAgICAgICAgbCA9IF9zdHIkc3BsaXQ0WzBdLFxuICAgICAgICAgICAgciA9IF9zdHIkc3BsaXQ0WzFdO1xuICAgICAgfVxuXG4gICAgICBpZiAociAmJiByLmxlbmd0aCA+IG1heF9yKSB7XG4gICAgICAgIG1heF9yID0gci5sZW5ndGg7XG4gICAgICB9XG5cbiAgICAgIGlmIChsICYmIGwubGVuZ3RoID4gbWF4X2wpIHtcbiAgICAgICAgbWF4X2wgPSBsLmxlbmd0aDtcbiAgICAgIH1cbiAgICB9KTsgLy8gU2VsZWN0IHByZWNpc2lvbiBzY2hlbWUgZGVwZW5kaW5nXG4gICAgLy8gb24gdGhlIGxlZnQgYW5kIHJpZ2h0IHBhcnQgbGVuZ3Roc1xuICAgIC8vXG5cbiAgICB2YXIgZXZlbiA9IG1heF9yIC0gbWF4X3IgJSAyICsgMjtcblxuICAgIGlmIChtYXhfbCA9PT0gMSkge1xuICAgICAgcmV0dXJuIE1hdGgubWluKDgsIE1hdGgubWF4KDIsIGV2ZW4pKTtcbiAgICB9XG5cbiAgICBpZiAobWF4X2wgPD0gMikge1xuICAgICAgcmV0dXJuIE1hdGgubWluKDQsIE1hdGgubWF4KDIsIGV2ZW4pKTtcbiAgICB9XG5cbiAgICByZXR1cm4gMjtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNhbGNfcG9zaXRpb25zKCkge1xuICAgIGlmIChzdWIubGVuZ3RoIDwgMikgcmV0dXJuO1xuICAgIHZhciBkdCA9IHJhbmdlWzFdIC0gcmFuZ2VbMF07IC8vIEEgcGl4ZWwgc3BhY2UgYXZhaWxhYmxlIHRvIGRyYXcgb24gKHgtYXhpcylcblxuICAgIHNlbGYuc3BhY2V4ID0gJHAud2lkdGggLSBzZWxmLnNiOyAvLyBDYW5kbGUgY2FwYWNpdHlcblxuICAgIHZhciBjYXBhY2l0eSA9IGR0IC8gaW50ZXJ2YWw7XG4gICAgc2VsZi5weF9zdGVwID0gc2VsZi5zcGFjZXggLyBjYXBhY2l0eTsgLy8gcHggLyB0aW1lIHJhdGlvXG5cbiAgICB2YXIgciA9IHNlbGYuc3BhY2V4IC8gZHQ7XG4gICAgc2VsZi5zdGFydHggPSAoc3ViWzBdWzBdIC0gcmFuZ2VbMF0pICogcjsgLy8gQ2FuZGxlIFktdHJhbnNmb3JtOiAoQSA9IHNjYWxlLCBCID0gc2hpZnQpXG5cbiAgICBpZiAoIWdyaWQubG9nU2NhbGUpIHtcbiAgICAgIHNlbGYuQSA9IC1oZWlnaHQgLyAoc2VsZi4kX2hpIC0gc2VsZi4kX2xvKTtcbiAgICAgIHNlbGYuQiA9IC1zZWxmLiRfaGkgKiBzZWxmLkE7XG4gICAgfSBlbHNlIHtcbiAgICAgIHNlbGYuQSA9IC1oZWlnaHQgLyAobWF0aC5sb2coc2VsZi4kX2hpKSAtIG1hdGgubG9nKHNlbGYuJF9sbykpO1xuICAgICAgc2VsZi5CID0gLW1hdGgubG9nKHNlbGYuJF9oaSkgKiBzZWxmLkE7XG4gICAgfVxuICB9IC8vIFNlbGVjdCBuZWFyZXN0IGdvb2QtbG9raW5nIHQgc3RlcCAobSBpcyB0YXJnZXQgc2NhbGUpXG5cblxuICBmdW5jdGlvbiB0aW1lX3N0ZXAoKSB7XG4gICAgdmFyIGsgPSB0aV9tYXAuaWIgPyA2MDAwMCA6IDE7XG4gICAgdmFyIHhyYW5nZSA9IChyYW5nZVsxXSAtIHJhbmdlWzBdKSAqIGs7XG4gICAgdmFyIG0gPSB4cmFuZ2UgKiAoJHAuY29uZmlnLkdSSURYIC8gJHAud2lkdGgpO1xuICAgIHZhciBzID0gZ3JpZF9tYWtlcl9USU1FU0NBTEVTO1xuICAgIHJldHVybiB1dGlscy5uZWFyZXN0X2EobSwgcylbMV0gLyBrO1xuICB9IC8vIFNlbGVjdCBuZWFyZXN0IGdvb2QtbG9raW5nICQgc3RlcCAobSBpcyB0YXJnZXQgc2NhbGUpXG5cblxuICBmdW5jdGlvbiBkb2xsYXJfc3RlcCgpIHtcbiAgICB2YXIgeXJhbmdlID0gc2VsZi4kX2hpIC0gc2VsZi4kX2xvO1xuICAgIHZhciBtID0geXJhbmdlICogKCRwLmNvbmZpZy5HUklEWSAvIGhlaWdodCk7XG4gICAgdmFyIHAgPSBwYXJzZUludCh5cmFuZ2UudG9FeHBvbmVudGlhbCgpLnNwbGl0KCdlJylbMV0pO1xuICAgIHZhciBkID0gTWF0aC5wb3coMTAsIHApO1xuICAgIHZhciBzID0gZ3JpZF9tYWtlcl8kU0NBTEVTLm1hcChmdW5jdGlvbiAoeCkge1xuICAgICAgcmV0dXJuIHggKiBkO1xuICAgIH0pOyAvLyBUT0RPOiBjZW50ZXIgdGhlIHJhbmdlIChsb29rIGF0IFJTSSBmb3IgZXhhbXBsZSxcbiAgICAvLyBpdCBsb29rcyB1Z2x5IHdoZW4gXCI4MFwiIGlzIG5lYXIgdGhlIHRvcClcblxuICAgIHJldHVybiB1dGlscy5zdHJpcCh1dGlscy5uZWFyZXN0X2EobSwgcylbMV0pO1xuICB9XG5cbiAgZnVuY3Rpb24gZG9sbGFyX211bHQoKSB7XG4gICAgdmFyIG11bHRfaGkgPSBkb2xsYXJfbXVsdF9oaSgpO1xuICAgIHZhciBtdWx0X2xvID0gZG9sbGFyX211bHRfbG8oKTtcbiAgICByZXR1cm4gTWF0aC5tYXgobXVsdF9oaSwgbXVsdF9sbyk7XG4gIH0gLy8gUHJpY2Ugc3RlcCBtdWx0aXBsaWVyIChmb3IgdGhlIGxvZy1zY2FsZSBtb2RlKVxuXG5cbiAgZnVuY3Rpb24gZG9sbGFyX211bHRfaGkoKSB7XG4gICAgdmFyIGggPSBNYXRoLm1pbihzZWxmLkIsIGhlaWdodCk7XG4gICAgaWYgKGggPCAkcC5jb25maWcuR1JJRFkpIHJldHVybiAxO1xuICAgIHZhciBuID0gaCAvICRwLmNvbmZpZy5HUklEWTsgLy8gdGFyZ2V0IGdyaWQgTlxuXG4gICAgdmFyIHlyYW5nZSA9IHNlbGYuJF9oaTtcblxuICAgIGlmIChzZWxmLiRfbG8gPiAwKSB7XG4gICAgICB2YXIgeXJhdGlvID0gc2VsZi4kX2hpIC8gc2VsZi4kX2xvO1xuICAgIH0gZWxzZSB7XG4gICAgICB5cmF0aW8gPSBzZWxmLiRfaGkgLyAxOyAvLyBUT0RPOiBzbWFsbCB2YWx1ZXNcbiAgICB9XG5cbiAgICB2YXIgbSA9IHlyYW5nZSAqICgkcC5jb25maWcuR1JJRFkgLyBoKTtcbiAgICB2YXIgcCA9IHBhcnNlSW50KHlyYW5nZS50b0V4cG9uZW50aWFsKCkuc3BsaXQoJ2UnKVsxXSk7XG4gICAgcmV0dXJuIE1hdGgucG93KHlyYXRpbywgMSAvIG4pO1xuICB9XG5cbiAgZnVuY3Rpb24gZG9sbGFyX211bHRfbG8oKSB7XG4gICAgdmFyIGggPSBNYXRoLm1pbihoZWlnaHQgLSBzZWxmLkIsIGhlaWdodCk7XG4gICAgaWYgKGggPCAkcC5jb25maWcuR1JJRFkpIHJldHVybiAxO1xuICAgIHZhciBuID0gaCAvICRwLmNvbmZpZy5HUklEWTsgLy8gdGFyZ2V0IGdyaWQgTlxuXG4gICAgdmFyIHlyYW5nZSA9IE1hdGguYWJzKHNlbGYuJF9sbyk7XG5cbiAgICBpZiAoc2VsZi4kX2hpIDwgMCAmJiBzZWxmLiRfbG8gPCAwKSB7XG4gICAgICB2YXIgeXJhdGlvID0gTWF0aC5hYnMoc2VsZi4kX2xvIC8gc2VsZi4kX2hpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgeXJhdGlvID0gTWF0aC5hYnMoc2VsZi4kX2xvKSAvIDE7XG4gICAgfVxuXG4gICAgdmFyIG0gPSB5cmFuZ2UgKiAoJHAuY29uZmlnLkdSSURZIC8gaCk7XG4gICAgdmFyIHAgPSBwYXJzZUludCh5cmFuZ2UudG9FeHBvbmVudGlhbCgpLnNwbGl0KCdlJylbMV0pO1xuICAgIHJldHVybiBNYXRoLnBvdyh5cmF0aW8sIDEgLyBuKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGdyaWRfeCgpIHtcbiAgICAvLyBJZiB0aGlzIGlzIGEgc3ViZ3JpZCwgbm8gbmVlZCB0byBjYWxjIGEgdGltZWxpbmUsXG4gICAgLy8gd2UganVzdCBib3Jyb3cgaXQgZnJvbSB0aGUgbWFzdGVyX2dyaWRcbiAgICBpZiAoIW1hc3Rlcl9ncmlkKSB7XG4gICAgICBzZWxmLnRfc3RlcCA9IHRpbWVfc3RlcCgpO1xuICAgICAgc2VsZi54cyA9IFtdO1xuICAgICAgdmFyIGR0ID0gcmFuZ2VbMV0gLSByYW5nZVswXTtcbiAgICAgIHZhciByID0gc2VsZi5zcGFjZXggLyBkdDtcbiAgICAgIC8qIFRPRE86IHJlbW92ZSB0aGUgbGVmdC1zaWRlIGdsaXRjaFxuICAgICAgIGxldCB5ZWFyXzAgPSBVdGlscy5nZXRfeWVhcihzdWJbMF1bMF0pXG4gICAgICBmb3IgKHZhciB0MCA9IHllYXJfMDsgdDAgPCByYW5nZVswXTsgdDAgKz0gc2VsZi50X3N0ZXApIHt9XG4gICAgICAgbGV0IG0wID0gVXRpbHMuZ2V0X21vbnRoKHQwKSovXG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc3ViLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBwID0gc3ViW2ldO1xuICAgICAgICB2YXIgcHJldiA9IHN1YltpIC0gMV0gfHwgW107XG4gICAgICAgIHZhciBwcmV2X3hzID0gc2VsZi54c1tzZWxmLnhzLmxlbmd0aCAtIDFdIHx8IFswLCBbXV07XG4gICAgICAgIHZhciB4ID0gTWF0aC5mbG9vcigocFswXSAtIHJhbmdlWzBdKSAqIHIpO1xuICAgICAgICBpbnNlcnRfbGluZShwcmV2LCBwLCB4KTsgLy8gRmlsdGVyaW5nIGxpbmVzIHRoYXQgYXJlIHRvbyBuZWFyXG5cbiAgICAgICAgdmFyIHhzID0gc2VsZi54c1tzZWxmLnhzLmxlbmd0aCAtIDFdIHx8IFswLCBbXV07XG4gICAgICAgIGlmIChwcmV2X3hzID09PSB4cykgY29udGludWU7XG5cbiAgICAgICAgaWYgKHhzWzFdWzBdIC0gcHJldl94c1sxXVswXSA8IHNlbGYudF9zdGVwICogMC44KSB7XG4gICAgICAgICAgLy8gcHJldl94cyBpcyBhIGhpZ2hlciBcInJhbmtcIiBsYWJlbFxuICAgICAgICAgIGlmICh4c1syXSA8PSBwcmV2X3hzWzJdKSB7XG4gICAgICAgICAgICBzZWxmLnhzLnBvcCgpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBPdGhlcndpc2VcbiAgICAgICAgICAgIHNlbGYueHMuc3BsaWNlKHNlbGYueHMubGVuZ3RoIC0gMiwgMSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IC8vIFRPRE86IGZpeCBncmlkIGV4dGVuc2lvbiBmb3IgYmlnZ2VyIHRpbWVmcmFtZXNcblxuXG4gICAgICBpZiAoaW50ZXJ2YWwgPCBncmlkX21ha2VyX1dFRUsgJiYgciA+IDApIHtcbiAgICAgICAgZXh0ZW5kX2xlZnQoZHQsIHIpO1xuICAgICAgICBleHRlbmRfcmlnaHQoZHQsIHIpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBzZWxmLnRfc3RlcCA9IG1hc3Rlcl9ncmlkLnRfc3RlcDtcbiAgICAgIHNlbGYucHhfc3RlcCA9IG1hc3Rlcl9ncmlkLnB4X3N0ZXA7XG4gICAgICBzZWxmLnN0YXJ0eCA9IG1hc3Rlcl9ncmlkLnN0YXJ0eDtcbiAgICAgIHNlbGYueHMgPSBtYXN0ZXJfZ3JpZC54cztcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBpbnNlcnRfbGluZShwcmV2LCBwLCB4LCBtMCkge1xuICAgIHZhciBwcmV2X3QgPSB0aV9tYXAuaWIgPyB0aV9tYXAuaTJ0KHByZXZbMF0pIDogcHJldlswXTtcbiAgICB2YXIgcF90ID0gdGlfbWFwLmliID8gdGlfbWFwLmkydChwWzBdKSA6IHBbMF07XG5cbiAgICBpZiAodGlfbWFwLnRmIDwgZ3JpZF9tYWtlcl9EQVkpIHtcbiAgICAgIHByZXZfdCArPSB0aW1lem9uZSAqIGdyaWRfbWFrZXJfSE9VUjtcbiAgICAgIHBfdCArPSB0aW1lem9uZSAqIGdyaWRfbWFrZXJfSE9VUjtcbiAgICB9XG5cbiAgICB2YXIgZCA9IHRpbWV6b25lICogZ3JpZF9tYWtlcl9IT1VSOyAvLyBUT0RPOiB0YWtlIHRoaXMgYmxvY2sgPT09PT09PT09PiAoc2VlIGJlbG93KVxuXG4gICAgaWYgKChwcmV2WzBdIHx8IGludGVydmFsID09PSBncmlkX21ha2VyX1lFQVIpICYmIHV0aWxzLmdldF95ZWFyKHBfdCkgIT09IHV0aWxzLmdldF95ZWFyKHByZXZfdCkpIHtcbiAgICAgIHNlbGYueHMucHVzaChbeCwgcCwgZ3JpZF9tYWtlcl9ZRUFSXSk7IC8vIFtweCwgWy4uLl0sIHJhbmtdXG4gICAgfSBlbHNlIGlmIChwcmV2WzBdICYmIHV0aWxzLmdldF9tb250aChwX3QpICE9PSB1dGlscy5nZXRfbW9udGgocHJldl90KSkge1xuICAgICAgc2VsZi54cy5wdXNoKFt4LCBwLCBncmlkX21ha2VyX01PTlRIXSk7XG4gICAgfSAvLyBUT0RPOiBzaG91bGQgYmUgYWRkZWQgaWYgdGhpcyBkYXkgIT09IHByZXYgZGF5XG4gICAgLy8gQW5kIHRoZSBzYW1lIGZvciAnYm90YmFyLmpzJywgVE9ETygqKVxuICAgIGVsc2UgaWYgKHV0aWxzLmRheV9zdGFydChwX3QpID09PSBwX3QpIHtcbiAgICAgICAgc2VsZi54cy5wdXNoKFt4LCBwLCBncmlkX21ha2VyX0RBWV0pO1xuICAgICAgfSBlbHNlIGlmIChwWzBdICUgc2VsZi50X3N0ZXAgPT09IDApIHtcbiAgICAgICAgc2VsZi54cy5wdXNoKFt4LCBwLCBpbnRlcnZhbF0pO1xuICAgICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gZXh0ZW5kX2xlZnQoZHQsIHIpIHtcbiAgICBpZiAoIXNlbGYueHMubGVuZ3RoIHx8ICFpc0Zpbml0ZShyKSkgcmV0dXJuO1xuICAgIHZhciB0ID0gc2VsZi54c1swXVsxXVswXTtcblxuICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICB0IC09IHNlbGYudF9zdGVwO1xuICAgICAgdmFyIHggPSBNYXRoLmZsb29yKCh0IC0gcmFuZ2VbMF0pICogcik7XG4gICAgICBpZiAoeCA8IDApIGJyZWFrOyAvLyBUT0RPOiA9PT09PT09PT09PiBBbmQgaW5zZXJ0IGl0IGhlcmUgc29tZWhvd1xuXG4gICAgICBpZiAodCAlIGludGVydmFsID09PSAwKSB7XG4gICAgICAgIHNlbGYueHMudW5zaGlmdChbeCwgW3RdLCBpbnRlcnZhbF0pO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGV4dGVuZF9yaWdodChkdCwgcikge1xuICAgIGlmICghc2VsZi54cy5sZW5ndGggfHwgIWlzRmluaXRlKHIpKSByZXR1cm47XG4gICAgdmFyIHQgPSBzZWxmLnhzW3NlbGYueHMubGVuZ3RoIC0gMV1bMV1bMF07XG5cbiAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgdCArPSBzZWxmLnRfc3RlcDtcbiAgICAgIHZhciB4ID0gTWF0aC5mbG9vcigodCAtIHJhbmdlWzBdKSAqIHIpO1xuICAgICAgaWYgKHggPiBzZWxmLnNwYWNleCkgYnJlYWs7XG5cbiAgICAgIGlmICh0ICUgaW50ZXJ2YWwgPT09IDApIHtcbiAgICAgICAgc2VsZi54cy5wdXNoKFt4LCBbdF0sIGludGVydmFsXSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gZ3JpZF95KCkge1xuICAgIC8vIFByZXZlbnQgZHVwbGljYXRlIGxldmVsc1xuICAgIHZhciBtID0gTWF0aC5wb3coMTAsIC1zZWxmLnByZWMpO1xuICAgIHNlbGYuJF9zdGVwID0gTWF0aC5tYXgobSwgZG9sbGFyX3N0ZXAoKSk7XG4gICAgc2VsZi55cyA9IFtdO1xuICAgIHZhciB5MSA9IHNlbGYuJF9sbyAtIHNlbGYuJF9sbyAlIHNlbGYuJF9zdGVwO1xuXG4gICAgZm9yICh2YXIgeSQgPSB5MTsgeSQgPD0gc2VsZi4kX2hpOyB5JCArPSBzZWxmLiRfc3RlcCkge1xuICAgICAgdmFyIHkgPSBNYXRoLmZsb29yKHkkICogc2VsZi5BICsgc2VsZi5CKTtcbiAgICAgIGlmICh5ID4gaGVpZ2h0KSBjb250aW51ZTtcbiAgICAgIHNlbGYueXMucHVzaChbeSwgdXRpbHMuc3RyaXAoeSQpXSk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gZ3JpZF95X2xvZygpIHtcbiAgICAvLyBUT0RPOiBQcmV2ZW50IGR1cGxpY2F0ZSBsZXZlbHMsIGlzIHRoaXMgZXZlblxuICAgIC8vIGEgcHJvYmxlbSBoZXJlID9cbiAgICBzZWxmLiRfbXVsdCA9IGRvbGxhcl9tdWx0KCk7XG4gICAgc2VsZi55cyA9IFtdO1xuICAgIGlmICghc3ViLmxlbmd0aCkgcmV0dXJuO1xuICAgIHZhciB2ID0gTWF0aC5hYnMoc3ViW3N1Yi5sZW5ndGggLSAxXVsxXSB8fCAxKTtcbiAgICB2YXIgeTEgPSBzZWFyY2hfc3RhcnRfcG9zKHYpO1xuICAgIHZhciB5MiA9IHNlYXJjaF9zdGFydF9uZWcoLXYpO1xuICAgIHZhciB5cCA9IC1JbmZpbml0eTsgLy8gUHJldmlvdXMgeSB2YWx1ZVxuXG4gICAgdmFyIG4gPSBoZWlnaHQgLyAkcC5jb25maWcuR1JJRFk7IC8vIHRhcmdldCBncmlkIE5cblxuICAgIHZhciBxID0gMSArIChzZWxmLiRfbXVsdCAtIDEpIC8gMjsgLy8gT3ZlciAwXG5cbiAgICBmb3IgKHZhciB5JCA9IHkxOyB5JCA+IDA7IHkkIC89IHNlbGYuJF9tdWx0KSB7XG4gICAgICB5JCA9IGxvZ19yb3VuZGVyKHkkLCBxKTtcbiAgICAgIHZhciB5ID0gTWF0aC5mbG9vcihtYXRoLmxvZyh5JCkgKiBzZWxmLkEgKyBzZWxmLkIpO1xuICAgICAgc2VsZi55cy5wdXNoKFt5LCB1dGlscy5zdHJpcCh5JCldKTtcbiAgICAgIGlmICh5ID4gaGVpZ2h0KSBicmVhaztcbiAgICAgIGlmICh5IC0geXAgPCAkcC5jb25maWcuR1JJRFkgKiAwLjcpIGJyZWFrO1xuICAgICAgaWYgKHNlbGYueXMubGVuZ3RoID4gbiArIDEpIGJyZWFrO1xuICAgICAgeXAgPSB5O1xuICAgIH0gLy8gVW5kZXIgMFxuXG5cbiAgICB5cCA9IEluZmluaXR5O1xuXG4gICAgZm9yICh2YXIgeSQgPSB5MjsgeSQgPCAwOyB5JCAvPSBzZWxmLiRfbXVsdCkge1xuICAgICAgeSQgPSBsb2dfcm91bmRlcih5JCwgcSk7XG5cbiAgICAgIHZhciBfeSA9IE1hdGguZmxvb3IobWF0aC5sb2coeSQpICogc2VsZi5BICsgc2VsZi5CKTtcblxuICAgICAgaWYgKHlwIC0gX3kgPCAkcC5jb25maWcuR1JJRFkgKiAwLjcpIGJyZWFrO1xuICAgICAgc2VsZi55cy5wdXNoKFtfeSwgdXRpbHMuc3RyaXAoeSQpXSk7XG4gICAgICBpZiAoX3kgPCAwKSBicmVhaztcbiAgICAgIGlmIChzZWxmLnlzLmxlbmd0aCA+IG4gKiAzICsgMSkgYnJlYWs7XG4gICAgICB5cCA9IF95O1xuICAgIH0gLy8gVE9ETzogcmVtb3ZlIGxpbmVzIG5lYXIgdG8gMFxuXG4gIH0gLy8gU2VhcmNoIGEgc3RhcnQgZm9yIHRoZSB0b3AgZ3JpZCBzbyB0aGF0XG4gIC8vIHRoZSBmaXhlZCB2YWx1ZSBhbHdheXMgaW5jbHVkZWRcblxuXG4gIGZ1bmN0aW9uIHNlYXJjaF9zdGFydF9wb3ModmFsdWUpIHtcbiAgICB2YXIgTiA9IGhlaWdodCAvICRwLmNvbmZpZy5HUklEWTsgLy8gdGFyZ2V0IGdyaWQgTlxuXG4gICAgdmFyIHkgPSBJbmZpbml0eSxcbiAgICAgICAgeSQgPSB2YWx1ZSxcbiAgICAgICAgY291bnQgPSAwO1xuXG4gICAgd2hpbGUgKHkgPiAwKSB7XG4gICAgICB5ID0gTWF0aC5mbG9vcihtYXRoLmxvZyh5JCkgKiBzZWxmLkEgKyBzZWxmLkIpO1xuICAgICAgeSQgKj0gc2VsZi4kX211bHQ7XG4gICAgICBpZiAoY291bnQrKyA+IE4gKiAzKSByZXR1cm4gMDsgLy8gUHJldmVudHMgZGVhZGxvb3BzXG4gICAgfVxuXG4gICAgcmV0dXJuIHkkO1xuICB9XG5cbiAgZnVuY3Rpb24gc2VhcmNoX3N0YXJ0X25lZyh2YWx1ZSkge1xuICAgIHZhciBOID0gaGVpZ2h0IC8gJHAuY29uZmlnLkdSSURZOyAvLyB0YXJnZXQgZ3JpZCBOXG5cbiAgICB2YXIgeSA9IC1JbmZpbml0eSxcbiAgICAgICAgeSQgPSB2YWx1ZSxcbiAgICAgICAgY291bnQgPSAwO1xuXG4gICAgd2hpbGUgKHkgPCBoZWlnaHQpIHtcbiAgICAgIHkgPSBNYXRoLmZsb29yKG1hdGgubG9nKHkkKSAqIHNlbGYuQSArIHNlbGYuQik7XG4gICAgICB5JCAqPSBzZWxmLiRfbXVsdDtcbiAgICAgIGlmIChjb3VudCsrID4gTiAqIDMpIGJyZWFrOyAvLyBQcmV2ZW50cyBkZWFkbG9vcHNcbiAgICB9XG5cbiAgICByZXR1cm4geSQ7XG4gIH0gLy8gTWFrZSBsb2cgc2NhbGUgbGV2ZWxzIGxvb2sgZ3JlYXQgYWdhaW5cblxuXG4gIGZ1bmN0aW9uIGxvZ19yb3VuZGVyKHgsIHF1YWxpdHkpIHtcbiAgICB2YXIgcyA9IE1hdGguc2lnbih4KTtcbiAgICB4ID0gTWF0aC5hYnMoeCk7XG5cbiAgICBpZiAoeCA+IDEwKSB7XG4gICAgICBmb3IgKHZhciBkaXYgPSAxMDsgZGl2IDwgTUFYX0lOVDsgZGl2ICo9IDEwKSB7XG4gICAgICAgIHZhciBuaWNlID0gTWF0aC5mbG9vcih4IC8gZGl2KSAqIGRpdjtcblxuICAgICAgICBpZiAoeCAvIG5pY2UgPiBxdWFsaXR5KSB7XG4gICAgICAgICAgLy8gTW9yZSB0aGFuIDEwJSBvZmZcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBkaXYgLz0gMTA7XG4gICAgICByZXR1cm4gcyAqIE1hdGguZmxvb3IoeCAvIGRpdikgKiBkaXY7XG4gICAgfSBlbHNlIGlmICh4IDwgMSkge1xuICAgICAgZm9yICh2YXIgcm8gPSAxMDsgcm8gPj0gMTsgcm8tLSkge1xuICAgICAgICB2YXIgX25pY2UgPSB1dGlscy5yb3VuZCh4LCBybyk7XG5cbiAgICAgICAgaWYgKHggLyBfbmljZSA+IHF1YWxpdHkpIHtcbiAgICAgICAgICAvLyBNb3JlIHRoYW4gMTAlIG9mZlxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBzICogdXRpbHMucm91bmQoeCwgcm8gKyAxKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHMgKiBNYXRoLmZsb29yKHgpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGFwcGx5X3NpemVzKCkge1xuICAgIHNlbGYud2lkdGggPSAkcC53aWR0aCAtIHNlbGYuc2I7XG4gICAgc2VsZi5oZWlnaHQgPSBoZWlnaHQ7XG4gIH1cblxuICBjYWxjXyRyYW5nZSgpO1xuICBjYWxjX3NpZGViYXIoKTtcbiAgcmV0dXJuIHtcbiAgICAvLyBGaXJzdCB3ZSBuZWVkIHRvIGNhbGN1bGF0ZSBtYXggc2lkZWJhciB3aWR0aFxuICAgIC8vIChhbW9uZyBhbGwgZ3JpZHMpLiBUaGVuIHdlIGNhbiBhY3R1YWxseSBtYWtlXG4gICAgLy8gdGhlbVxuICAgIGNyZWF0ZTogZnVuY3Rpb24gY3JlYXRlKCkge1xuICAgICAgY2FsY19wb3NpdGlvbnMoKTtcbiAgICAgIGdyaWRfeCgpO1xuXG4gICAgICBpZiAoZ3JpZC5sb2dTY2FsZSkge1xuICAgICAgICBncmlkX3lfbG9nKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBncmlkX3koKTtcbiAgICAgIH1cblxuICAgICAgYXBwbHlfc2l6ZXMoKTsgLy8gTGluayB0byB0aGUgbWFzdGVyIGdyaWQgKGNhbmRsZXN0aWNrcylcblxuICAgICAgaWYgKG1hc3Rlcl9ncmlkKSB7XG4gICAgICAgIHNlbGYubWFzdGVyX2dyaWQgPSBtYXN0ZXJfZ3JpZDtcbiAgICAgIH1cblxuICAgICAgc2VsZi5ncmlkID0gZ3JpZDsgLy8gR3JpZCBwYXJhbXNcbiAgICAgIC8vIEhlcmUgd2UgYWRkIHNvbWUgaGVscGZ1bCBmdW5jdGlvbnMgZm9yXG4gICAgICAvLyBwbHVnaW4gY3JlYXRvcnNcblxuICAgICAgcmV0dXJuIGxheW91dF9mbihzZWxmLCByYW5nZSk7XG4gICAgfSxcbiAgICBnZXRfbGF5b3V0OiBmdW5jdGlvbiBnZXRfbGF5b3V0KCkge1xuICAgICAgcmV0dXJuIHNlbGY7XG4gICAgfSxcbiAgICBzZXRfc2lkZWJhcjogZnVuY3Rpb24gc2V0X3NpZGViYXIodikge1xuICAgICAgcmV0dXJuIHNlbGYuc2IgPSB2O1xuICAgIH0sXG4gICAgZ2V0X3NpZGViYXI6IGZ1bmN0aW9uIGdldF9zaWRlYmFyKCkge1xuICAgICAgcmV0dXJuIHNlbGYuc2I7XG4gICAgfVxuICB9O1xufVxuXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIGNvbnN0IGdyaWRfbWFrZXIgPSAoR3JpZE1ha2VyKTtcbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9jb21wb25lbnRzL2pzL2xheW91dC5qc1xuXG5cblxuZnVuY3Rpb24gX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXIobywgYWxsb3dBcnJheUxpa2UpIHsgdmFyIGl0OyBpZiAodHlwZW9mIFN5bWJvbCA9PT0gXCJ1bmRlZmluZWRcIiB8fCBvW1N5bWJvbC5pdGVyYXRvcl0gPT0gbnVsbCkgeyBpZiAoQXJyYXkuaXNBcnJheShvKSB8fCAoaXQgPSBsYXlvdXRfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkobykpIHx8IGFsbG93QXJyYXlMaWtlICYmIG8gJiYgdHlwZW9mIG8ubGVuZ3RoID09PSBcIm51bWJlclwiKSB7IGlmIChpdCkgbyA9IGl0OyB2YXIgaSA9IDA7IHZhciBGID0gZnVuY3Rpb24gRigpIHt9OyByZXR1cm4geyBzOiBGLCBuOiBmdW5jdGlvbiBuKCkgeyBpZiAoaSA+PSBvLmxlbmd0aCkgcmV0dXJuIHsgZG9uZTogdHJ1ZSB9OyByZXR1cm4geyBkb25lOiBmYWxzZSwgdmFsdWU6IG9baSsrXSB9OyB9LCBlOiBmdW5jdGlvbiBlKF9lKSB7IHRocm93IF9lOyB9LCBmOiBGIH07IH0gdGhyb3cgbmV3IFR5cGVFcnJvcihcIkludmFsaWQgYXR0ZW1wdCB0byBpdGVyYXRlIG5vbi1pdGVyYWJsZSBpbnN0YW5jZS5cXG5JbiBvcmRlciB0byBiZSBpdGVyYWJsZSwgbm9uLWFycmF5IG9iamVjdHMgbXVzdCBoYXZlIGEgW1N5bWJvbC5pdGVyYXRvcl0oKSBtZXRob2QuXCIpOyB9IHZhciBub3JtYWxDb21wbGV0aW9uID0gdHJ1ZSwgZGlkRXJyID0gZmFsc2UsIGVycjsgcmV0dXJuIHsgczogZnVuY3Rpb24gcygpIHsgaXQgPSBvW1N5bWJvbC5pdGVyYXRvcl0oKTsgfSwgbjogZnVuY3Rpb24gbigpIHsgdmFyIHN0ZXAgPSBpdC5uZXh0KCk7IG5vcm1hbENvbXBsZXRpb24gPSBzdGVwLmRvbmU7IHJldHVybiBzdGVwOyB9LCBlOiBmdW5jdGlvbiBlKF9lMikgeyBkaWRFcnIgPSB0cnVlOyBlcnIgPSBfZTI7IH0sIGY6IGZ1bmN0aW9uIGYoKSB7IHRyeSB7IGlmICghbm9ybWFsQ29tcGxldGlvbiAmJiBpdFtcInJldHVyblwiXSAhPSBudWxsKSBpdFtcInJldHVyblwiXSgpOyB9IGZpbmFsbHkgeyBpZiAoZGlkRXJyKSB0aHJvdyBlcnI7IH0gfSB9OyB9XG5cbmZ1bmN0aW9uIGxheW91dF91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheShvLCBtaW5MZW4pIHsgaWYgKCFvKSByZXR1cm47IGlmICh0eXBlb2YgbyA9PT0gXCJzdHJpbmdcIikgcmV0dXJuIGxheW91dF9hcnJheUxpa2VUb0FycmF5KG8sIG1pbkxlbik7IHZhciBuID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG8pLnNsaWNlKDgsIC0xKTsgaWYgKG4gPT09IFwiT2JqZWN0XCIgJiYgby5jb25zdHJ1Y3RvcikgbiA9IG8uY29uc3RydWN0b3IubmFtZTsgaWYgKG4gPT09IFwiTWFwXCIgfHwgbiA9PT0gXCJTZXRcIikgcmV0dXJuIEFycmF5LmZyb20obyk7IGlmIChuID09PSBcIkFyZ3VtZW50c1wiIHx8IC9eKD86VWl8SSludCg/Ojh8MTZ8MzIpKD86Q2xhbXBlZCk/QXJyYXkkLy50ZXN0KG4pKSByZXR1cm4gbGF5b3V0X2FycmF5TGlrZVRvQXJyYXkobywgbWluTGVuKTsgfVxuXG5mdW5jdGlvbiBsYXlvdXRfYXJyYXlMaWtlVG9BcnJheShhcnIsIGxlbikgeyBpZiAobGVuID09IG51bGwgfHwgbGVuID4gYXJyLmxlbmd0aCkgbGVuID0gYXJyLmxlbmd0aDsgZm9yICh2YXIgaSA9IDAsIGFycjIgPSBuZXcgQXJyYXkobGVuKTsgaSA8IGxlbjsgaSsrKSB7IGFycjJbaV0gPSBhcnJbaV07IH0gcmV0dXJuIGFycjI7IH1cblxuLy8gQ2FsY3VsYXRlcyBhbGwgbmVjZXNzYXJ5IHMqaXQgdG8gYnVpbGQgdGhlIGNoYXJ0XG4vLyBIZWlnaHRzLCB3aWR0aHMsIHRyYW5zZm9ybXMsIC4uLiA9IGV2ZXJ5dGhpbmdcbi8vIFdoeSBzdWNoIGEgbWVzcyB5b3UgYXNrPyBXZWxsLCB0aGF0J3MgYmVjYXVzZVxuLy8gb25lIGNvbXBvbmVudHMgc2l6ZSBjYW4gZGVwZW5kIG9uIG90aGVyIGNvbXBvbmVudFxuLy8gZGF0YSBmb3JtYXR0aW5nIChlLmcuIGdyaWQgd2lkdGggZGVwZW5kcyBvbiBzaWRlYmFyIHByZWNpc2lvbilcbi8vIFNvIGl0J3MgYmV0dGVyIHRvIGNhbGMgYWxsIGluIG9uZSBwbGFjZS5cblxuXG5cblxuXG5mdW5jdGlvbiBMYXlvdXQocGFyYW1zKSB7XG4gIHZhciBjaGFydCA9IHBhcmFtcy5jaGFydCxcbiAgICAgIHN1YiA9IHBhcmFtcy5zdWIsXG4gICAgICBvZmZzdWIgPSBwYXJhbXMub2Zmc3ViLFxuICAgICAgaW50ZXJ2YWwgPSBwYXJhbXMuaW50ZXJ2YWwsXG4gICAgICByYW5nZSA9IHBhcmFtcy5yYW5nZSxcbiAgICAgIGN0eCA9IHBhcmFtcy5jdHgsXG4gICAgICBsYXllcnNfbWV0YSA9IHBhcmFtcy5sYXllcnNfbWV0YSxcbiAgICAgIHRpX21hcCA9IHBhcmFtcy50aV9tYXAsXG4gICAgICAkcCA9IHBhcmFtcy4kcHJvcHMsXG4gICAgICB5X3RzID0gcGFyYW1zLnlfdHJhbnNmb3JtcztcbiAgdmFyIG1ncmlkID0gY2hhcnQuZ3JpZCB8fCB7fTtcbiAgb2Zmc3ViID0gb2Zmc3ViLmZpbHRlcihmdW5jdGlvbiAoeCwgaSkge1xuICAgIC8vIFNraXAgb2ZmY2hhcnQgb3ZlcmxheXMgd2l0aCBjdXN0b20gZ3JpZCBpZCxcbiAgICAvLyBiZWNhdXNlIHRoZXkgd2lsbCBiZSBtZXJncmVkIHdpdGggdGhlIGV4aXN0aW5nIGdyaWRzXG4gICAgcmV0dXJuICEoeC5ncmlkICYmIHguZ3JpZC5pZCk7XG4gIH0pOyAvLyBTcGxpdHMgc3BhY2UgYmV0d2VlbiBtYWluIGNoYXJ0XG4gIC8vIGFuZCBvZmZjaGFydCBpbmRpY2F0b3IgZ3JpZHNcblxuICBmdW5jdGlvbiBncmlkX2hzKCkge1xuICAgIHZhciBoZWlnaHQgPSAkcC5oZWlnaHQgLSAkcC5jb25maWcuQk9UQkFSOyAvLyBXaGVuIGF0IGxlYXN0IG9uZSBoZWlnaHQgZGVmaW5lZCAoZGVmYXVsdCA9IDEpLFxuICAgIC8vIFB4cyBjYWxjdWxhdGVkIGFzOiAoc3VtIG9mIHdlaWdodHMpIC8gbnVtYmVyXG5cbiAgICBpZiAobWdyaWQuaGVpZ2h0IHx8IG9mZnN1Yi5maW5kKGZ1bmN0aW9uICh4KSB7XG4gICAgICByZXR1cm4geC5ncmlkLmhlaWdodDtcbiAgICB9KSkge1xuICAgICAgcmV0dXJuIHdlaWdodGVkX2hzKG1ncmlkLCBoZWlnaHQpO1xuICAgIH1cblxuICAgIHZhciBuID0gb2Zmc3ViLmxlbmd0aDtcbiAgICB2YXIgb2ZmX2ggPSAyICogTWF0aC5zcXJ0KG4pIC8gNyAvIChuIHx8IDEpOyAvLyBPZmZjaGFydCBncmlkIGhlaWdodFxuXG4gICAgdmFyIHB4ID0gTWF0aC5mbG9vcihoZWlnaHQgKiBvZmZfaCk7IC8vIE1haW4gZ3JpZCBoZWlnaHRcblxuICAgIHZhciBtID0gaGVpZ2h0IC0gcHggKiBuO1xuICAgIHJldHVybiBbbV0uY29uY2F0KEFycmF5KG4pLmZpbGwocHgpKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHdlaWdodGVkX2hzKGdyaWQsIGhlaWdodCkge1xuICAgIHZhciBocyA9IFt7XG4gICAgICBncmlkOiBncmlkXG4gICAgfV0uY29uY2F0KF90b0NvbnN1bWFibGVBcnJheShvZmZzdWIpKS5tYXAoZnVuY3Rpb24gKHgpIHtcbiAgICAgIHJldHVybiB4LmdyaWQuaGVpZ2h0IHx8IDE7XG4gICAgfSk7XG4gICAgdmFyIHN1bSA9IGhzLnJlZHVjZShmdW5jdGlvbiAoYSwgYikge1xuICAgICAgcmV0dXJuIGEgKyBiO1xuICAgIH0sIDApO1xuICAgIGhzID0gaHMubWFwKGZ1bmN0aW9uICh4KSB7XG4gICAgICByZXR1cm4gTWF0aC5mbG9vcih4IC8gc3VtICogaGVpZ2h0KTtcbiAgICB9KTsgLy8gUmVmaW5lIHRoZSBoZWlnaHQgaWYgTWF0aC5mbG9vciBkZWNyZWFzZWQgcHggc3VtXG5cbiAgICBzdW0gPSBocy5yZWR1Y2UoZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgIHJldHVybiBhICsgYjtcbiAgICB9LCAwKTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaGVpZ2h0IC0gc3VtOyBpKyspIHtcbiAgICAgIGhzW2kgJSBocy5sZW5ndGhdKys7XG4gICAgfVxuXG4gICAgcmV0dXJuIGhzO1xuICB9XG5cbiAgZnVuY3Rpb24gY2FuZGxlc19uX3ZvbCgpIHtcbiAgICBzZWxmLmNhbmRsZXMgPSBbXTtcbiAgICBzZWxmLnZvbHVtZSA9IFtdO1xuICAgIHZhciBtYXh2ID0gTWF0aC5tYXguYXBwbHkoTWF0aCwgX3RvQ29uc3VtYWJsZUFycmF5KHN1Yi5tYXAoZnVuY3Rpb24gKHgpIHtcbiAgICAgIHJldHVybiB4WzVdO1xuICAgIH0pKSk7XG4gICAgdmFyIHZzID0gJHAuY29uZmlnLlZPTFNDQUxFICogJHAuaGVpZ2h0IC8gbWF4djtcbiAgICB2YXIgeDEsXG4gICAgICAgIHgyLFxuICAgICAgICBtaWQsXG4gICAgICAgIHByZXYgPSB1bmRlZmluZWQ7XG4gICAgdmFyIHNwbGl0dGVyID0gc2VsZi5weF9zdGVwID4gNSA/IDEgOiAwO1xuICAgIHZhciBoZl9weF9zdGVwID0gc2VsZi5weF9zdGVwICogMC41O1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdWIubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBwID0gc3ViW2ldO1xuICAgICAgbWlkID0gc2VsZi50MnNjcmVlbihwWzBdKSArIDAuNTtcbiAgICAgIHNlbGYuY2FuZGxlcy5wdXNoKG1ncmlkLmxvZ1NjYWxlID8gbG9nX3NjYWxlLmNhbmRsZShzZWxmLCBtaWQsIHAsICRwKSA6IHtcbiAgICAgICAgeDogbWlkLFxuICAgICAgICB3OiBzZWxmLnB4X3N0ZXAgKiAkcC5jb25maWcuQ0FORExFVyxcbiAgICAgICAgbzogTWF0aC5mbG9vcihwWzFdICogc2VsZi5BICsgc2VsZi5CKSxcbiAgICAgICAgaDogTWF0aC5mbG9vcihwWzJdICogc2VsZi5BICsgc2VsZi5CKSxcbiAgICAgICAgbDogTWF0aC5mbG9vcihwWzNdICogc2VsZi5BICsgc2VsZi5CKSxcbiAgICAgICAgYzogTWF0aC5mbG9vcihwWzRdICogc2VsZi5BICsgc2VsZi5CKSxcbiAgICAgICAgcmF3OiBwXG4gICAgICB9KTsgLy8gQ2xlYXIgdm9sdW1lIGJhciBpZiB0aGVyZSBpcyBhIHRpbWUgZ2FwXG5cbiAgICAgIGlmIChzdWJbaSAtIDFdICYmIHBbMF0gLSBzdWJbaSAtIDFdWzBdID4gaW50ZXJ2YWwpIHtcbiAgICAgICAgcHJldiA9IG51bGw7XG4gICAgICB9XG5cbiAgICAgIHgxID0gcHJldiB8fCBNYXRoLmZsb29yKG1pZCAtIGhmX3B4X3N0ZXApO1xuICAgICAgeDIgPSBNYXRoLmZsb29yKG1pZCArIGhmX3B4X3N0ZXApIC0gMC41O1xuICAgICAgc2VsZi52b2x1bWUucHVzaCh7XG4gICAgICAgIHgxOiB4MSxcbiAgICAgICAgeDI6IHgyLFxuICAgICAgICBoOiBwWzVdICogdnMsXG4gICAgICAgIGdyZWVuOiBwWzRdID49IHBbMV0sXG4gICAgICAgIHJhdzogcFxuICAgICAgfSk7XG4gICAgICBwcmV2ID0geDIgKyBzcGxpdHRlcjtcbiAgICB9XG4gIH0gLy8gTWFpbiBncmlkXG5cblxuICB2YXIgaHMgPSBncmlkX2hzKCk7XG4gIHZhciBzcGVjcyA9IHtcbiAgICBzdWI6IHN1YixcbiAgICBpbnRlcnZhbDogaW50ZXJ2YWwsXG4gICAgcmFuZ2U6IHJhbmdlLFxuICAgIGN0eDogY3R4LFxuICAgICRwOiAkcCxcbiAgICBsYXllcnNfbWV0YTogbGF5ZXJzX21ldGEsXG4gICAgdGlfbWFwOiB0aV9tYXAsXG4gICAgaGVpZ2h0OiBoc1swXSxcbiAgICB5X3Q6IHlfdHNbMF0sXG4gICAgZ3JpZDogbWdyaWQsXG4gICAgdGltZXpvbmU6ICRwLnRpbWV6b25lXG4gIH07XG4gIHZhciBnbXMgPSBbbmV3IGdyaWRfbWFrZXIoMCwgc3BlY3MpXTsgLy8gU3ViIGdyaWRzXG5cbiAgdmFyIF9pdGVyYXRvciA9IF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyKG9mZnN1Yi5lbnRyaWVzKCkpLFxuICAgICAgX3N0ZXA7XG5cbiAgdHJ5IHtcbiAgICBmb3IgKF9pdGVyYXRvci5zKCk7ICEoX3N0ZXAgPSBfaXRlcmF0b3IubigpKS5kb25lOykge1xuICAgICAgdmFyIF9zdGVwJHZhbHVlID0gX3NsaWNlZFRvQXJyYXkoX3N0ZXAudmFsdWUsIDIpLFxuICAgICAgICAgIGkgPSBfc3RlcCR2YWx1ZVswXSxcbiAgICAgICAgICBfc3RlcCR2YWx1ZSQgPSBfc3RlcCR2YWx1ZVsxXSxcbiAgICAgICAgICBkYXRhID0gX3N0ZXAkdmFsdWUkLmRhdGEsXG4gICAgICAgICAgZ3JpZCA9IF9zdGVwJHZhbHVlJC5ncmlkO1xuXG4gICAgICBzcGVjcy5zdWIgPSBkYXRhO1xuICAgICAgc3BlY3MuaGVpZ2h0ID0gaHNbaSArIDFdO1xuICAgICAgc3BlY3MueV90ID0geV90c1tpICsgMV07XG4gICAgICBzcGVjcy5ncmlkID0gZ3JpZCB8fCB7fTtcbiAgICAgIGdtcy5wdXNoKG5ldyBncmlkX21ha2VyKGkgKyAxLCBzcGVjcywgZ21zWzBdLmdldF9sYXlvdXQoKSkpO1xuICAgIH0gLy8gTWF4IHNpZGViYXIgYW1vbmcgYWxsIGdyaW5kc1xuXG4gIH0gY2F0Y2ggKGVycikge1xuICAgIF9pdGVyYXRvci5lKGVycik7XG4gIH0gZmluYWxseSB7XG4gICAgX2l0ZXJhdG9yLmYoKTtcbiAgfVxuXG4gIHZhciBzYiA9IE1hdGgubWF4LmFwcGx5KE1hdGgsIF90b0NvbnN1bWFibGVBcnJheShnbXMubWFwKGZ1bmN0aW9uICh4KSB7XG4gICAgcmV0dXJuIHguZ2V0X3NpZGViYXIoKTtcbiAgfSkpKTtcbiAgdmFyIGdyaWRzID0gW10sXG4gICAgICBvZmZzZXQgPSAwO1xuXG4gIGZvciAoaSA9IDA7IGkgPCBnbXMubGVuZ3RoOyBpKyspIHtcbiAgICBnbXNbaV0uc2V0X3NpZGViYXIoc2IpO1xuICAgIGdyaWRzLnB1c2goZ21zW2ldLmNyZWF0ZSgpKTtcbiAgICBncmlkc1tpXS5pZCA9IGk7XG4gICAgZ3JpZHNbaV0ub2Zmc2V0ID0gb2Zmc2V0O1xuICAgIG9mZnNldCArPSBncmlkc1tpXS5oZWlnaHQ7XG4gIH1cblxuICB2YXIgc2VsZiA9IGdyaWRzWzBdO1xuICBjYW5kbGVzX25fdm9sKCk7XG4gIHJldHVybiB7XG4gICAgZ3JpZHM6IGdyaWRzLFxuICAgIGJvdGJhcjoge1xuICAgICAgd2lkdGg6ICRwLndpZHRoLFxuICAgICAgaGVpZ2h0OiAkcC5jb25maWcuQk9UQkFSLFxuICAgICAgb2Zmc2V0OiBvZmZzZXQsXG4gICAgICB4czogZ3JpZHNbMF0gPyBncmlkc1swXS54cyA6IFtdXG4gICAgfVxuICB9O1xufVxuXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIGNvbnN0IGxheW91dCA9IChMYXlvdXQpO1xuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL2NsYXNzQ2FsbENoZWNrLmpzXG5mdW5jdGlvbiBjbGFzc0NhbGxDaGVja19jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHtcbiAgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpO1xuICB9XG59XG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vY3JlYXRlQ2xhc3MuanNcbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07XG4gICAgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlO1xuICAgIGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTtcbiAgICBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBjcmVhdGVDbGFzc19jcmVhdGVDbGFzcyhDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHtcbiAgaWYgKHByb3RvUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7XG4gIGlmIChzdGF0aWNQcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTtcbiAgcmV0dXJuIENvbnN0cnVjdG9yO1xufVxuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL2NvbXBvbmVudHMvanMvdXBkYXRlci5qc1xuXG5cblxuXG5mdW5jdGlvbiB1cGRhdGVyX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXIobywgYWxsb3dBcnJheUxpa2UpIHsgdmFyIGl0OyBpZiAodHlwZW9mIFN5bWJvbCA9PT0gXCJ1bmRlZmluZWRcIiB8fCBvW1N5bWJvbC5pdGVyYXRvcl0gPT0gbnVsbCkgeyBpZiAoQXJyYXkuaXNBcnJheShvKSB8fCAoaXQgPSB1cGRhdGVyX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5KG8pKSB8fCBhbGxvd0FycmF5TGlrZSAmJiBvICYmIHR5cGVvZiBvLmxlbmd0aCA9PT0gXCJudW1iZXJcIikgeyBpZiAoaXQpIG8gPSBpdDsgdmFyIGkgPSAwOyB2YXIgRiA9IGZ1bmN0aW9uIEYoKSB7fTsgcmV0dXJuIHsgczogRiwgbjogZnVuY3Rpb24gbigpIHsgaWYgKGkgPj0gby5sZW5ndGgpIHJldHVybiB7IGRvbmU6IHRydWUgfTsgcmV0dXJuIHsgZG9uZTogZmFsc2UsIHZhbHVlOiBvW2krK10gfTsgfSwgZTogZnVuY3Rpb24gZShfZSkgeyB0aHJvdyBfZTsgfSwgZjogRiB9OyB9IHRocm93IG5ldyBUeXBlRXJyb3IoXCJJbnZhbGlkIGF0dGVtcHQgdG8gaXRlcmF0ZSBub24taXRlcmFibGUgaW5zdGFuY2UuXFxuSW4gb3JkZXIgdG8gYmUgaXRlcmFibGUsIG5vbi1hcnJheSBvYmplY3RzIG11c3QgaGF2ZSBhIFtTeW1ib2wuaXRlcmF0b3JdKCkgbWV0aG9kLlwiKTsgfSB2YXIgbm9ybWFsQ29tcGxldGlvbiA9IHRydWUsIGRpZEVyciA9IGZhbHNlLCBlcnI7IHJldHVybiB7IHM6IGZ1bmN0aW9uIHMoKSB7IGl0ID0gb1tTeW1ib2wuaXRlcmF0b3JdKCk7IH0sIG46IGZ1bmN0aW9uIG4oKSB7IHZhciBzdGVwID0gaXQubmV4dCgpOyBub3JtYWxDb21wbGV0aW9uID0gc3RlcC5kb25lOyByZXR1cm4gc3RlcDsgfSwgZTogZnVuY3Rpb24gZShfZTIpIHsgZGlkRXJyID0gdHJ1ZTsgZXJyID0gX2UyOyB9LCBmOiBmdW5jdGlvbiBmKCkgeyB0cnkgeyBpZiAoIW5vcm1hbENvbXBsZXRpb24gJiYgaXRbXCJyZXR1cm5cIl0gIT0gbnVsbCkgaXRbXCJyZXR1cm5cIl0oKTsgfSBmaW5hbGx5IHsgaWYgKGRpZEVycikgdGhyb3cgZXJyOyB9IH0gfTsgfVxuXG5mdW5jdGlvbiB1cGRhdGVyX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5KG8sIG1pbkxlbikgeyBpZiAoIW8pIHJldHVybjsgaWYgKHR5cGVvZiBvID09PSBcInN0cmluZ1wiKSByZXR1cm4gdXBkYXRlcl9hcnJheUxpa2VUb0FycmF5KG8sIG1pbkxlbik7IHZhciBuID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG8pLnNsaWNlKDgsIC0xKTsgaWYgKG4gPT09IFwiT2JqZWN0XCIgJiYgby5jb25zdHJ1Y3RvcikgbiA9IG8uY29uc3RydWN0b3IubmFtZTsgaWYgKG4gPT09IFwiTWFwXCIgfHwgbiA9PT0gXCJTZXRcIikgcmV0dXJuIEFycmF5LmZyb20obyk7IGlmIChuID09PSBcIkFyZ3VtZW50c1wiIHx8IC9eKD86VWl8SSludCg/Ojh8MTZ8MzIpKD86Q2xhbXBlZCk/QXJyYXkkLy50ZXN0KG4pKSByZXR1cm4gdXBkYXRlcl9hcnJheUxpa2VUb0FycmF5KG8sIG1pbkxlbik7IH1cblxuZnVuY3Rpb24gdXBkYXRlcl9hcnJheUxpa2VUb0FycmF5KGFyciwgbGVuKSB7IGlmIChsZW4gPT0gbnVsbCB8fCBsZW4gPiBhcnIubGVuZ3RoKSBsZW4gPSBhcnIubGVuZ3RoOyBmb3IgKHZhciBpID0gMCwgYXJyMiA9IG5ldyBBcnJheShsZW4pOyBpIDwgbGVuOyBpKyspIHsgYXJyMltpXSA9IGFycltpXTsgfSByZXR1cm4gYXJyMjsgfVxuXG4vLyBDdXJzb3IgdXBkYXRlcjogY2FsY3VsYXRlcyBjdXJyZW50IHZhbHVlcyBmb3Jcbi8vIE9ITENWIGFuZCBhbGwgb3RoZXIgaW5kaWNhdG9yc1xuXG5cbnZhciBDdXJzb3JVcGRhdGVyID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gQ3Vyc29yVXBkYXRlcihjb21wKSB7XG4gICAgY2xhc3NDYWxsQ2hlY2tfY2xhc3NDYWxsQ2hlY2sodGhpcywgQ3Vyc29yVXBkYXRlcik7XG5cbiAgICB0aGlzLmNvbXAgPSBjb21wLCB0aGlzLmdyaWRzID0gY29tcC5fbGF5b3V0LmdyaWRzLCB0aGlzLmN1cnNvciA9IGNvbXAuY3Vyc29yO1xuICB9XG5cbiAgY3JlYXRlQ2xhc3NfY3JlYXRlQ2xhc3MoQ3Vyc29yVXBkYXRlciwgW3tcbiAgICBrZXk6IFwic3luY1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzeW5jKGUpIHtcbiAgICAgIC8vIFRPRE86IHZhbHVlcyBub3QgZGlzcGxheWluZyBpZiBhIGN1c3RvbSBncmlkIGlkIGlzIHNldDpcbiAgICAgIC8vIGdyaWQ6IHsgaWQ6IE4gfVxuICAgICAgdGhpcy5jdXJzb3IuZ3JpZF9pZCA9IGUuZ3JpZF9pZDtcbiAgICAgIHZhciBvbmNlID0gdHJ1ZTtcblxuICAgICAgdmFyIF9pdGVyYXRvciA9IHVwZGF0ZXJfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlcih0aGlzLmdyaWRzKSxcbiAgICAgICAgICBfc3RlcDtcblxuICAgICAgdHJ5IHtcbiAgICAgICAgZm9yIChfaXRlcmF0b3IucygpOyAhKF9zdGVwID0gX2l0ZXJhdG9yLm4oKSkuZG9uZTspIHtcbiAgICAgICAgICB2YXIgZ3JpZCA9IF9zdGVwLnZhbHVlO1xuICAgICAgICAgIHZhciBjID0gdGhpcy5jdXJzb3JfZGF0YShncmlkLCBlKTtcblxuICAgICAgICAgIGlmICghdGhpcy5jdXJzb3IubG9ja2VkKSB7XG4gICAgICAgICAgICAvLyBUT0RPOiBmaW5kIGEgYmV0dGVyIGZpeCB0byBpbnZpc2libGUgY3Vyc29yIHByb2JcbiAgICAgICAgICAgIGlmIChvbmNlKSB7XG4gICAgICAgICAgICAgIHRoaXMuY3Vyc29yLnQgPSB0aGlzLmN1cnNvcl90aW1lKGdyaWQsIGUsIGMpO1xuICAgICAgICAgICAgICBpZiAodGhpcy5jdXJzb3IudCkgb25jZSA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoYy52YWx1ZXMpIHtcbiAgICAgICAgICAgICAgdGhpcy5jb21wLiRzZXQodGhpcy5jdXJzb3IudmFsdWVzLCBncmlkLmlkLCBjLnZhbHVlcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKGdyaWQuaWQgIT09IGUuZ3JpZF9pZCkgY29udGludWU7XG4gICAgICAgICAgdGhpcy5jdXJzb3IueCA9IGdyaWQudDJzY3JlZW4odGhpcy5jdXJzb3IudCk7XG4gICAgICAgICAgdGhpcy5jdXJzb3IueSA9IGMueTtcbiAgICAgICAgICB0aGlzLmN1cnNvci55JCA9IGMueSQ7XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICBfaXRlcmF0b3IuZShlcnIpO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgX2l0ZXJhdG9yLmYoKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwib3ZlcmxheV9kYXRhXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG92ZXJsYXlfZGF0YShncmlkLCBlKSB7XG4gICAgICB2YXIgcyA9IGdyaWQuaWQgPT09IDAgPyAnbWFpbl9zZWN0aW9uJyA6ICdzdWJfc2VjdGlvbic7XG4gICAgICB2YXIgZGF0YSA9IHRoaXMuY29tcFtzXS5kYXRhOyAvLyBTcGxpdCBvZmZjaGFydCBkYXRhIGJldHdlZW4gb2ZmY2hhcnQgZ3JpZHNcblxuICAgICAgaWYgKGdyaWQuaWQgPiAwKSB7XG4gICAgICAgIC8vIFNlcXVlbnRpYWwgZ3JpZHNcbiAgICAgICAgdmFyIF9kID0gZGF0YS5maWx0ZXIoZnVuY3Rpb24gKHgpIHtcbiAgICAgICAgICByZXR1cm4geC5ncmlkLmlkID09PSB1bmRlZmluZWQ7XG4gICAgICAgIH0pOyAvLyBncmlkcyB3aXRoIGN1c3RvbSBpZHMgKGZvciBtZXJnaW5nKVxuXG5cbiAgICAgICAgdmFyIG0gPSBkYXRhLmZpbHRlcihmdW5jdGlvbiAoeCkge1xuICAgICAgICAgIHJldHVybiB4LmdyaWQuaWQgPT09IGdyaWQuaWQ7XG4gICAgICAgIH0pO1xuICAgICAgICBkYXRhID0gW19kW2dyaWQuaWQgLSAxXV0uY29uY2F0KF90b0NvbnN1bWFibGVBcnJheShtKSk7XG4gICAgICB9XG5cbiAgICAgIHZhciB0ID0gZ3JpZC5zY3JlZW4ydChlLngpO1xuICAgICAgdmFyIGlkcyA9IHt9LFxuICAgICAgICAgIHJlcyA9IHt9O1xuXG4gICAgICB2YXIgX2l0ZXJhdG9yMiA9IHVwZGF0ZXJfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlcihkYXRhKSxcbiAgICAgICAgICBfc3RlcDI7XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIGZvciAoX2l0ZXJhdG9yMi5zKCk7ICEoX3N0ZXAyID0gX2l0ZXJhdG9yMi5uKCkpLmRvbmU7KSB7XG4gICAgICAgICAgdmFyIGQgPSBfc3RlcDIudmFsdWU7XG4gICAgICAgICAgdmFyIHRzID0gZC5kYXRhLm1hcChmdW5jdGlvbiAoeCkge1xuICAgICAgICAgICAgcmV0dXJuIHhbMF07XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgdmFyIGkgPSB1dGlscy5uZWFyZXN0X2EodCwgdHMpWzBdO1xuICAgICAgICAgIGQudHlwZSBpbiBpZHMgPyBpZHNbZC50eXBlXSsrIDogaWRzW2QudHlwZV0gPSAwO1xuICAgICAgICAgIHJlc1tcIlwiLmNvbmNhdChkLnR5cGUsIFwiX1wiKS5jb25jYXQoaWRzW2QudHlwZV0pXSA9IGQuZGF0YVtpXTtcbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIF9pdGVyYXRvcjIuZShlcnIpO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgX2l0ZXJhdG9yMi5mKCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiByZXM7XG4gICAgfSAvLyBOZWFyZXN0IGRhdGFwb2ludHNcblxuICB9LCB7XG4gICAga2V5OiBcImN1cnNvcl9kYXRhXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGN1cnNvcl9kYXRhKGdyaWQsIGUpIHtcbiAgICAgIHZhciBkYXRhID0gdGhpcy5jb21wLm1haW5fc2VjdGlvbi5zdWI7XG4gICAgICB2YXIgeHMgPSBkYXRhLm1hcChmdW5jdGlvbiAoeCkge1xuICAgICAgICByZXR1cm4gZ3JpZC50MnNjcmVlbih4WzBdKSArIDAuNTtcbiAgICAgIH0pO1xuICAgICAgdmFyIGkgPSB1dGlscy5uZWFyZXN0X2EoZS54LCB4cylbMF07XG4gICAgICBpZiAoIXhzW2ldKSByZXR1cm4ge307XG4gICAgICByZXR1cm4ge1xuICAgICAgICB4OiBNYXRoLmZsb29yKHhzW2ldKSAtIDAuNSxcbiAgICAgICAgeTogTWF0aC5mbG9vcihlLnkgLSAyKSAtIDAuNSAtIGdyaWQub2Zmc2V0LFxuICAgICAgICB5JDogZ3JpZC5zY3JlZW4yJChlLnkgLSAyIC0gZ3JpZC5vZmZzZXQpLFxuICAgICAgICB0OiAoZGF0YVtpXSB8fCBbXSlbMF0sXG4gICAgICAgIHZhbHVlczogT2JqZWN0LmFzc2lnbih7XG4gICAgICAgICAgb2hsY3Y6IGdyaWQuaWQgPT09IDAgPyBkYXRhW2ldIDogdW5kZWZpbmVkXG4gICAgICAgIH0sIHRoaXMub3ZlcmxheV9kYXRhKGdyaWQsIGUpKVxuICAgICAgfTtcbiAgICB9IC8vIEdldCBjdXJzb3IgdC1wb3NpdGlvbiAoZXh0ZW5kZWQpXG5cbiAgfSwge1xuICAgIGtleTogXCJjdXJzb3JfdGltZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjdXJzb3JfdGltZShncmlkLCBtb3VzZSwgY2FuZGxlKSB7XG4gICAgICB2YXIgdCA9IGdyaWQuc2NyZWVuMnQobW91c2UueCk7XG4gICAgICB2YXIgciA9IE1hdGguYWJzKCh0IC0gY2FuZGxlLnQpIC8gdGhpcy5jb21wLmludGVydmFsKTtcbiAgICAgIHZhciBzaWduID0gTWF0aC5zaWduKHQgLSBjYW5kbGUudCk7XG5cbiAgICAgIGlmIChyID49IDAuNSkge1xuICAgICAgICAvLyBPdXRzaWRlIHRoZSBkYXRhIHJhbmdlXG4gICAgICAgIHZhciBuID0gTWF0aC5yb3VuZChyKTtcbiAgICAgICAgcmV0dXJuIGNhbmRsZS50ICsgbiAqIHRoaXMuY29tcC5pbnRlcnZhbCAqIHNpZ247XG4gICAgICB9IC8vIEluc2lkZSB0aGUgZGF0YSByYW5nZVxuXG5cbiAgICAgIHJldHVybiBjYW5kbGUudDtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gQ3Vyc29yVXBkYXRlcjtcbn0oKTtcblxuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyBjb25zdCB1cGRhdGVyID0gKEN1cnNvclVwZGF0ZXIpO1xuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL2xvYWRlcnMvdGVtcGxhdGVMb2FkZXIuanM/P3Z1ZS1sb2FkZXItb3B0aW9ucyEuL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9pbmRleC5qcz8/dnVlLWxvYWRlci1vcHRpb25zIS4vc3JjL2NvbXBvbmVudHMvU2VjdGlvbi52dWU/dnVlJnR5cGU9dGVtcGxhdGUmaWQ9OGZiZTkzMzYmXG52YXIgU2VjdGlvbnZ1ZV90eXBlX3RlbXBsYXRlX2lkXzhmYmU5MzM2X3JlbmRlciA9IGZ1bmN0aW9uKCkge1xuICB2YXIgX3ZtID0gdGhpc1xuICB2YXIgX2ggPSBfdm0uJGNyZWF0ZUVsZW1lbnRcbiAgdmFyIF9jID0gX3ZtLl9zZWxmLl9jIHx8IF9oXG4gIHJldHVybiBfYyhcbiAgICBcImRpdlwiLFxuICAgIHsgc3RhdGljQ2xhc3M6IFwidHJhZGluZy12dWUtc2VjdGlvblwiIH0sXG4gICAgW1xuICAgICAgX2MoXCJjaGFydC1sZWdlbmRcIiwge1xuICAgICAgICByZWY6IFwibGVnZW5kXCIsXG4gICAgICAgIGF0dHJzOiB7XG4gICAgICAgICAgdmFsdWVzOiBfdm0uc2VjdGlvbl92YWx1ZXMsXG4gICAgICAgICAgZ3JpZF9pZDogX3ZtLmdyaWRfaWQsXG4gICAgICAgICAgY29tbW9uOiBfdm0ubGVnZW5kX3Byb3BzLFxuICAgICAgICAgIG1ldGFfcHJvcHM6IF92bS5nZXRfbWV0YV9wcm9wc1xuICAgICAgICB9LFxuICAgICAgICBvbjogeyBcImxlZ2VuZC1idXR0b24tY2xpY2tcIjogX3ZtLmJ1dHRvbl9jbGljayB9XG4gICAgICB9KSxcbiAgICAgIF92bS5fdihcIiBcIiksXG4gICAgICBfYyhcbiAgICAgICAgXCJncmlkXCIsXG4gICAgICAgIF92bS5fYihcbiAgICAgICAgICB7XG4gICAgICAgICAgICByZWY6IFwiZ3JpZFwiLFxuICAgICAgICAgICAgYXR0cnM6IHsgZ3JpZF9pZDogX3ZtLmdyaWRfaWQgfSxcbiAgICAgICAgICAgIG9uOiB7XG4gICAgICAgICAgICAgIFwicmVnaXN0ZXIta2ItbGlzdGVuZXJcIjogX3ZtLnJlZ2lzdGVyX2tiLFxuICAgICAgICAgICAgICBcInJlbW92ZS1rYi1saXN0ZW5lclwiOiBfdm0ucmVtb3ZlX2tiLFxuICAgICAgICAgICAgICBcInJhbmdlLWNoYW5nZWRcIjogX3ZtLnJhbmdlX2NoYW5nZWQsXG4gICAgICAgICAgICAgIFwiY3Vyc29yLWNoYW5nZWRcIjogX3ZtLmN1cnNvcl9jaGFuZ2VkLFxuICAgICAgICAgICAgICBcImN1cnNvci1sb2NrZWRcIjogX3ZtLmN1cnNvcl9sb2NrZWQsXG4gICAgICAgICAgICAgIFwibGF5ZXItbWV0YS1wcm9wc1wiOiBfdm0uZW1pdF9tZXRhX3Byb3BzLFxuICAgICAgICAgICAgICBcImN1c3RvbS1ldmVudFwiOiBfdm0uZW1pdF9jdXN0b21fZXZlbnQsXG4gICAgICAgICAgICAgIFwic2lkZWJhci10cmFuc2Zvcm1cIjogX3ZtLnNpZGViYXJfdHJhbnNmb3JtLFxuICAgICAgICAgICAgICBcInJlem9vbS1yYW5nZVwiOiBfdm0ucmV6b29tX3JhbmdlXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSxcbiAgICAgICAgICBcImdyaWRcIixcbiAgICAgICAgICBfdm0uZ3JpZF9wcm9wcyxcbiAgICAgICAgICBmYWxzZVxuICAgICAgICApXG4gICAgICApLFxuICAgICAgX3ZtLl92KFwiIFwiKSxcbiAgICAgIF9jKFxuICAgICAgICBcInNpZGViYXJcIixcbiAgICAgICAgX3ZtLl9iKFxuICAgICAgICAgIHtcbiAgICAgICAgICAgIHJlZjogXCJzYi1cIiArIF92bS5ncmlkX2lkLFxuICAgICAgICAgICAgYXR0cnM6IHsgZ3JpZF9pZDogX3ZtLmdyaWRfaWQsIHJlcmVuZGVyOiBfdm0ucmVyZW5kZXIgfSxcbiAgICAgICAgICAgIG9uOiB7IFwic2lkZWJhci10cmFuc2Zvcm1cIjogX3ZtLnNpZGViYXJfdHJhbnNmb3JtIH1cbiAgICAgICAgICB9LFxuICAgICAgICAgIFwic2lkZWJhclwiLFxuICAgICAgICAgIF92bS5zaWRlYmFyX3Byb3BzLFxuICAgICAgICAgIGZhbHNlXG4gICAgICAgIClcbiAgICAgIClcbiAgICBdLFxuICAgIDFcbiAgKVxufVxudmFyIFNlY3Rpb252dWVfdHlwZV90ZW1wbGF0ZV9pZF84ZmJlOTMzNl9zdGF0aWNSZW5kZXJGbnMgPSBbXVxuU2VjdGlvbnZ1ZV90eXBlX3RlbXBsYXRlX2lkXzhmYmU5MzM2X3JlbmRlci5fd2l0aFN0cmlwcGVkID0gdHJ1ZVxuXG5cbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9jb21wb25lbnRzL1NlY3Rpb24udnVlP3Z1ZSZ0eXBlPXRlbXBsYXRlJmlkPThmYmU5MzM2JlxuXG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvc3R1ZmYvZnJhbWUuanNcblxuXG4vLyBBbm5pbWF0aW9uIGZyYW1lIHdpdGggYSBmYWxsYmFjayBmb3Jcbi8vIHNsb3dlciBkZXZpY2VzXG5cblxudmFyIEZyYW1lQW5pbWF0aW9uID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gRnJhbWVBbmltYXRpb24oY2IpIHtcbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgY2xhc3NDYWxsQ2hlY2tfY2xhc3NDYWxsQ2hlY2sodGhpcywgRnJhbWVBbmltYXRpb24pO1xuXG4gICAgdGhpcy50MCA9IHRoaXMudCA9IHV0aWxzLm5vdygpO1xuICAgIHRoaXMuaWQgPSBzZXRJbnRlcnZhbChmdW5jdGlvbiAoKSB7XG4gICAgICAvLyBUaGUgcHJldiBmcmFtZSB0b29rIHRvbyBsb25nXG4gICAgICBpZiAodXRpbHMubm93KCkgLSBfdGhpcy50ID4gMTAwKSByZXR1cm47XG5cbiAgICAgIGlmICh1dGlscy5ub3coKSAtIF90aGlzLnQwID4gMTIwMCkge1xuICAgICAgICBfdGhpcy5zdG9wKCk7XG4gICAgICB9XG5cbiAgICAgIGlmIChfdGhpcy5pZCkgY2IoX3RoaXMpO1xuICAgICAgX3RoaXMudCA9IHV0aWxzLm5vdygpO1xuICAgIH0sIDE2KTtcbiAgfVxuXG4gIGNyZWF0ZUNsYXNzX2NyZWF0ZUNsYXNzKEZyYW1lQW5pbWF0aW9uLCBbe1xuICAgIGtleTogXCJzdG9wXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHN0b3AoKSB7XG4gICAgICBjbGVhckludGVydmFsKHRoaXMuaWQpO1xuICAgICAgdGhpcy5pZCA9IG51bGw7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIEZyYW1lQW5pbWF0aW9uO1xufSgpO1xuXG5cbi8vIEVYVEVSTkFMIE1PRFVMRTogLi9ub2RlX21vZHVsZXMvaGFtbWVyanMvaGFtbWVyLmpzXG52YXIgaGFtbWVyID0gX193ZWJwYWNrX3JlcXVpcmVfXyg4NDApO1xuLy8gRVhURVJOQUwgTU9EVUxFOiAuL25vZGVfbW9kdWxlcy9oYW1zdGVyanMvaGFtc3Rlci5qc1xudmFyIGhhbXN0ZXIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDk4MSk7XG52YXIgaGFtc3Rlcl9kZWZhdWx0ID0gLyojX19QVVJFX18qL19fd2VicGFja19yZXF1aXJlX18ubihoYW1zdGVyKTtcbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9jb21wb25lbnRzL2pzL2dyaWQuanNcblxuXG5cblxuXG5mdW5jdGlvbiBncmlkX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXIobywgYWxsb3dBcnJheUxpa2UpIHsgdmFyIGl0OyBpZiAodHlwZW9mIFN5bWJvbCA9PT0gXCJ1bmRlZmluZWRcIiB8fCBvW1N5bWJvbC5pdGVyYXRvcl0gPT0gbnVsbCkgeyBpZiAoQXJyYXkuaXNBcnJheShvKSB8fCAoaXQgPSBncmlkX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5KG8pKSB8fCBhbGxvd0FycmF5TGlrZSAmJiBvICYmIHR5cGVvZiBvLmxlbmd0aCA9PT0gXCJudW1iZXJcIikgeyBpZiAoaXQpIG8gPSBpdDsgdmFyIGkgPSAwOyB2YXIgRiA9IGZ1bmN0aW9uIEYoKSB7fTsgcmV0dXJuIHsgczogRiwgbjogZnVuY3Rpb24gbigpIHsgaWYgKGkgPj0gby5sZW5ndGgpIHJldHVybiB7IGRvbmU6IHRydWUgfTsgcmV0dXJuIHsgZG9uZTogZmFsc2UsIHZhbHVlOiBvW2krK10gfTsgfSwgZTogZnVuY3Rpb24gZShfZSkgeyB0aHJvdyBfZTsgfSwgZjogRiB9OyB9IHRocm93IG5ldyBUeXBlRXJyb3IoXCJJbnZhbGlkIGF0dGVtcHQgdG8gaXRlcmF0ZSBub24taXRlcmFibGUgaW5zdGFuY2UuXFxuSW4gb3JkZXIgdG8gYmUgaXRlcmFibGUsIG5vbi1hcnJheSBvYmplY3RzIG11c3QgaGF2ZSBhIFtTeW1ib2wuaXRlcmF0b3JdKCkgbWV0aG9kLlwiKTsgfSB2YXIgbm9ybWFsQ29tcGxldGlvbiA9IHRydWUsIGRpZEVyciA9IGZhbHNlLCBlcnI7IHJldHVybiB7IHM6IGZ1bmN0aW9uIHMoKSB7IGl0ID0gb1tTeW1ib2wuaXRlcmF0b3JdKCk7IH0sIG46IGZ1bmN0aW9uIG4oKSB7IHZhciBzdGVwID0gaXQubmV4dCgpOyBub3JtYWxDb21wbGV0aW9uID0gc3RlcC5kb25lOyByZXR1cm4gc3RlcDsgfSwgZTogZnVuY3Rpb24gZShfZTIpIHsgZGlkRXJyID0gdHJ1ZTsgZXJyID0gX2UyOyB9LCBmOiBmdW5jdGlvbiBmKCkgeyB0cnkgeyBpZiAoIW5vcm1hbENvbXBsZXRpb24gJiYgaXRbXCJyZXR1cm5cIl0gIT0gbnVsbCkgaXRbXCJyZXR1cm5cIl0oKTsgfSBmaW5hbGx5IHsgaWYgKGRpZEVycikgdGhyb3cgZXJyOyB9IH0gfTsgfVxuXG5mdW5jdGlvbiBncmlkX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5KG8sIG1pbkxlbikgeyBpZiAoIW8pIHJldHVybjsgaWYgKHR5cGVvZiBvID09PSBcInN0cmluZ1wiKSByZXR1cm4gZ3JpZF9hcnJheUxpa2VUb0FycmF5KG8sIG1pbkxlbik7IHZhciBuID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG8pLnNsaWNlKDgsIC0xKTsgaWYgKG4gPT09IFwiT2JqZWN0XCIgJiYgby5jb25zdHJ1Y3RvcikgbiA9IG8uY29uc3RydWN0b3IubmFtZTsgaWYgKG4gPT09IFwiTWFwXCIgfHwgbiA9PT0gXCJTZXRcIikgcmV0dXJuIEFycmF5LmZyb20obyk7IGlmIChuID09PSBcIkFyZ3VtZW50c1wiIHx8IC9eKD86VWl8SSludCg/Ojh8MTZ8MzIpKD86Q2xhbXBlZCk/QXJyYXkkLy50ZXN0KG4pKSByZXR1cm4gZ3JpZF9hcnJheUxpa2VUb0FycmF5KG8sIG1pbkxlbik7IH1cblxuZnVuY3Rpb24gZ3JpZF9hcnJheUxpa2VUb0FycmF5KGFyciwgbGVuKSB7IGlmIChsZW4gPT0gbnVsbCB8fCBsZW4gPiBhcnIubGVuZ3RoKSBsZW4gPSBhcnIubGVuZ3RoOyBmb3IgKHZhciBpID0gMCwgYXJyMiA9IG5ldyBBcnJheShsZW4pOyBpIDwgbGVuOyBpKyspIHsgYXJyMltpXSA9IGFycltpXTsgfSByZXR1cm4gYXJyMjsgfVxuXG4vLyBHcmlkLmpzIGxpc3RlbnMgdG8gdmFyaW91cyB1c2VyLWdlbmVyYXRlZCBldmVudHMsXG4vLyBlbWl0cyBWdWUtZXZlbnRzIGlmIHNvbWV0aGluZyBoYXMgY2hhbmdlZCAoZS5nLiByYW5nZSlcbi8vIFRoaW5rIG9mIGl0IGFzIGFuIEkvTyBzeXN0ZW0gZm9yIEdyaWQudnVlXG5cblxuXG5cbiAvLyBHcmlkIGlzIGdvb2QuXG5cbnZhciBHcmlkID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gR3JpZChjYW52YXMsIGNvbXApIHtcbiAgICBjbGFzc0NhbGxDaGVja19jbGFzc0NhbGxDaGVjayh0aGlzLCBHcmlkKTtcblxuICAgIHRoaXMuTUlOX1pPT00gPSBjb21wLmNvbmZpZy5NSU5fWk9PTTtcbiAgICB0aGlzLk1BWF9aT09NID0gY29tcC5jb25maWcuTUFYX1pPT007XG4gICAgaWYgKHV0aWxzLmlzX21vYmlsZSkgdGhpcy5NSU5fWk9PTSAqPSAwLjU7XG4gICAgdGhpcy5jYW52YXMgPSBjYW52YXM7XG4gICAgdGhpcy5jdHggPSBjYW52YXMuZ2V0Q29udGV4dCgnMmQnKTtcbiAgICB0aGlzLmNvbXAgPSBjb21wO1xuICAgIHRoaXMuJHAgPSBjb21wLiRwcm9wcztcbiAgICB0aGlzLmRhdGEgPSB0aGlzLiRwLnN1YjtcbiAgICB0aGlzLnJhbmdlID0gdGhpcy4kcC5yYW5nZTtcbiAgICB0aGlzLmlkID0gdGhpcy4kcC5ncmlkX2lkO1xuICAgIHRoaXMubGF5b3V0ID0gdGhpcy4kcC5sYXlvdXQuZ3JpZHNbdGhpcy5pZF07XG4gICAgdGhpcy5pbnRlcnZhbCA9IHRoaXMuJHAuaW50ZXJ2YWw7XG4gICAgdGhpcy5jdXJzb3IgPSBjb21wLiRwcm9wcy5jdXJzb3I7XG4gICAgdGhpcy5vZmZzZXRfeCA9IDA7XG4gICAgdGhpcy5vZmZzZXRfeSA9IDA7XG4gICAgdGhpcy5kZWx0YXMgPSAwOyAvLyBXaGVlbCBkZWx0YSBldmVudHNcblxuICAgIHRoaXMud21vZGUgPSB0aGlzLiRwLmNvbmZpZy5TQ1JPTExfV0hFRUw7XG4gICAgdGhpcy5saXN0ZW5lcnMoKTtcbiAgICB0aGlzLm92ZXJsYXlzID0gW107XG4gIH1cblxuICBjcmVhdGVDbGFzc19jcmVhdGVDbGFzcyhHcmlkLCBbe1xuICAgIGtleTogXCJsaXN0ZW5lcnNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gbGlzdGVuZXJzKCkge1xuICAgICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgICAgdGhpcy5obSA9IGhhbXN0ZXJfZGVmYXVsdCgpKHRoaXMuY2FudmFzKTtcbiAgICAgIHRoaXMuaG0ud2hlZWwoZnVuY3Rpb24gKGV2ZW50LCBkZWx0YSkge1xuICAgICAgICByZXR1cm4gX3RoaXMubW91c2V6b29tKC1kZWx0YSAqIDUwLCBldmVudCk7XG4gICAgICB9KTtcbiAgICAgIHZhciBtYyA9IHRoaXMubWMgPSBuZXcgaGFtbWVyLk1hbmFnZXIodGhpcy5jYW52YXMpO1xuICAgICAgdmFyIFQgPSB1dGlscy5pc19tb2JpbGUgPyAxMCA6IDA7XG4gICAgICBtYy5hZGQobmV3IGhhbW1lci5QYW4oe1xuICAgICAgICB0aHJlc2hvbGQ6IFRcbiAgICAgIH0pKTtcbiAgICAgIG1jLmFkZChuZXcgaGFtbWVyLlRhcCgpKTtcbiAgICAgIG1jLmFkZChuZXcgaGFtbWVyLlBpbmNoKHtcbiAgICAgICAgdGhyZXNob2xkOiAwXG4gICAgICB9KSk7XG4gICAgICBtYy5nZXQoJ3BpbmNoJykuc2V0KHtcbiAgICAgICAgZW5hYmxlOiB0cnVlXG4gICAgICB9KTtcbiAgICAgIGlmICh1dGlscy5pc19tb2JpbGUpIG1jLmFkZChuZXcgaGFtbWVyLlByZXNzKCkpO1xuICAgICAgbWMub24oJ3BhbnN0YXJ0JywgZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgIGlmIChfdGhpcy5jdXJzb3Iuc2Nyb2xsX2xvY2spIHJldHVybjtcblxuICAgICAgICBpZiAoX3RoaXMuY3Vyc29yLm1vZGUgPT09ICdhaW0nKSB7XG4gICAgICAgICAgcmV0dXJuIF90aGlzLmVtaXRfY3Vyc29yX2Nvb3JkKGV2ZW50KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciB0ZnJtID0gX3RoaXMuJHAueV90cmFuc2Zvcm07XG4gICAgICAgIF90aGlzLmRydWcgPSB7XG4gICAgICAgICAgeDogZXZlbnQuY2VudGVyLnggKyBfdGhpcy5vZmZzZXRfeCxcbiAgICAgICAgICB5OiBldmVudC5jZW50ZXIueSArIF90aGlzLm9mZnNldF95LFxuICAgICAgICAgIHI6IF90aGlzLnJhbmdlLnNsaWNlKCksXG4gICAgICAgICAgdDogX3RoaXMucmFuZ2VbMV0gLSBfdGhpcy5yYW5nZVswXSxcbiAgICAgICAgICBvOiB0ZnJtID8gdGZybS5vZmZzZXQgfHwgMCA6IDAsXG4gICAgICAgICAgeV9yOiB0ZnJtICYmIHRmcm0ucmFuZ2UgPyB0ZnJtLnJhbmdlLnNsaWNlKCkgOiB1bmRlZmluZWQsXG4gICAgICAgICAgQjogX3RoaXMubGF5b3V0LkIsXG4gICAgICAgICAgdDA6IHV0aWxzLm5vdygpXG4gICAgICAgIH07XG5cbiAgICAgICAgX3RoaXMuY29tcC4kZW1pdCgnY3Vyc29yLWNoYW5nZWQnLCB7XG4gICAgICAgICAgZ3JpZF9pZDogX3RoaXMuaWQsXG4gICAgICAgICAgeDogZXZlbnQuY2VudGVyLnggKyBfdGhpcy5vZmZzZXRfeCxcbiAgICAgICAgICB5OiBldmVudC5jZW50ZXIueSArIF90aGlzLm9mZnNldF95XG4gICAgICAgIH0pO1xuXG4gICAgICAgIF90aGlzLmNvbXAuJGVtaXQoJ2N1cnNvci1sb2NrZWQnLCB0cnVlKTtcbiAgICAgIH0pO1xuICAgICAgbWMub24oJ3Bhbm1vdmUnLCBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgaWYgKHV0aWxzLmlzX21vYmlsZSkge1xuICAgICAgICAgIF90aGlzLmNhbGNfb2Zmc2V0KCk7XG5cbiAgICAgICAgICBfdGhpcy5wcm9wYWdhdGUoJ21vdXNlbW92ZScsIF90aGlzLnRvdWNoMm1vdXNlKGV2ZW50KSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoX3RoaXMuZHJ1Zykge1xuICAgICAgICAgIF90aGlzLm1vdXNlZHJhZyhfdGhpcy5kcnVnLnggKyBldmVudC5kZWx0YVgsIF90aGlzLmRydWcueSArIGV2ZW50LmRlbHRhWSk7XG5cbiAgICAgICAgICBfdGhpcy5jb21wLiRlbWl0KCdjdXJzb3ItY2hhbmdlZCcsIHtcbiAgICAgICAgICAgIGdyaWRfaWQ6IF90aGlzLmlkLFxuICAgICAgICAgICAgeDogZXZlbnQuY2VudGVyLnggKyBfdGhpcy5vZmZzZXRfeCxcbiAgICAgICAgICAgIHk6IGV2ZW50LmNlbnRlci55ICsgX3RoaXMub2Zmc2V0X3lcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIGlmIChfdGhpcy5jdXJzb3IubW9kZSA9PT0gJ2FpbScpIHtcbiAgICAgICAgICBfdGhpcy5lbWl0X2N1cnNvcl9jb29yZChldmVudCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgbWMub24oJ3BhbmVuZCcsIGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICBpZiAodXRpbHMuaXNfbW9iaWxlICYmIF90aGlzLmRydWcpIHtcbiAgICAgICAgICBfdGhpcy5wYW5fZmFkZShldmVudCk7XG4gICAgICAgIH1cblxuICAgICAgICBfdGhpcy5kcnVnID0gbnVsbDtcblxuICAgICAgICBfdGhpcy5jb21wLiRlbWl0KCdjdXJzb3ItbG9ja2VkJywgZmFsc2UpO1xuICAgICAgfSk7XG4gICAgICBtYy5vbigndGFwJywgZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgIGlmICghdXRpbHMuaXNfbW9iaWxlKSByZXR1cm47XG5cbiAgICAgICAgX3RoaXMuc2ltX21vdXNlZG93bihldmVudCk7XG5cbiAgICAgICAgaWYgKF90aGlzLmZhZGUpIF90aGlzLmZhZGUuc3RvcCgpO1xuXG4gICAgICAgIF90aGlzLmNvbXAuJGVtaXQoJ2N1cnNvci1jaGFuZ2VkJywge30pO1xuXG4gICAgICAgIF90aGlzLmNvbXAuJGVtaXQoJ2N1cnNvci1jaGFuZ2VkJywge1xuICAgICAgICAgIC8qZ3JpZF9pZDogdGhpcy5pZCxcbiAgICAgICAgICB4OiB1bmRlZmluZWQsLy9ldmVudC5jZW50ZXIueCArIHRoaXMub2Zmc2V0X3gsXG4gICAgICAgICAgeTogdW5kZWZpbmVkLC8vZXZlbnQuY2VudGVyLnkgKyB0aGlzLm9mZnNldF95LCovXG4gICAgICAgICAgbW9kZTogJ2V4cGxvcmUnXG4gICAgICAgIH0pO1xuXG4gICAgICAgIF90aGlzLnVwZGF0ZSgpO1xuICAgICAgfSk7XG4gICAgICBtYy5vbigncGluY2hzdGFydCcsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgX3RoaXMuZHJ1ZyA9IG51bGw7XG4gICAgICAgIF90aGlzLnBpbmNoID0ge1xuICAgICAgICAgIHQ6IF90aGlzLnJhbmdlWzFdIC0gX3RoaXMucmFuZ2VbMF0sXG4gICAgICAgICAgcjogX3RoaXMucmFuZ2Uuc2xpY2UoKVxuICAgICAgICB9O1xuICAgICAgfSk7XG4gICAgICBtYy5vbigncGluY2hlbmQnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIF90aGlzLnBpbmNoID0gbnVsbDtcbiAgICAgIH0pO1xuICAgICAgbWMub24oJ3BpbmNoJywgZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgIGlmIChfdGhpcy5waW5jaCkgX3RoaXMucGluY2h6b29tKGV2ZW50LnNjYWxlKTtcbiAgICAgIH0pO1xuICAgICAgbWMub24oJ3ByZXNzJywgZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgIGlmICghdXRpbHMuaXNfbW9iaWxlKSByZXR1cm47XG4gICAgICAgIGlmIChfdGhpcy5mYWRlKSBfdGhpcy5mYWRlLnN0b3AoKTtcblxuICAgICAgICBfdGhpcy5jYWxjX29mZnNldCgpO1xuXG4gICAgICAgIF90aGlzLmVtaXRfY3Vyc29yX2Nvb3JkKGV2ZW50LCB7XG4gICAgICAgICAgbW9kZTogJ2FpbSdcbiAgICAgICAgfSk7XG5cbiAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgcmV0dXJuIF90aGlzLnVwZGF0ZSgpO1xuICAgICAgICB9KTtcblxuICAgICAgICBfdGhpcy5zaW1fbW91c2Vkb3duKGV2ZW50KTtcbiAgICAgIH0pO1xuICAgICAgdmFyIGFkZCA9IGFkZEV2ZW50TGlzdGVuZXI7XG4gICAgICBhZGQoXCJnZXN0dXJlc3RhcnRcIiwgdGhpcy5nZXN0dXJlc3RhcnQpO1xuICAgICAgYWRkKFwiZ2VzdHVyZWNoYW5nZVwiLCB0aGlzLmdlc3R1cmVjaGFuZ2UpO1xuICAgICAgYWRkKFwiZ2VzdHVyZWVuZFwiLCB0aGlzLmdlc3R1cmVlbmQpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJnZXN0dXJlc3RhcnRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2VzdHVyZXN0YXJ0KGV2ZW50KSB7XG4gICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJnZXN0dXJlY2hhbmdlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdlc3R1cmVjaGFuZ2UoZXZlbnQpIHtcbiAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImdlc3R1cmVlbmRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2VzdHVyZWVuZChldmVudCkge1xuICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwibW91c2Vtb3ZlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG1vdXNlbW92ZShldmVudCkge1xuICAgICAgaWYgKHV0aWxzLmlzX21vYmlsZSkgcmV0dXJuO1xuICAgICAgdGhpcy5jb21wLiRlbWl0KCdjdXJzb3ItY2hhbmdlZCcsIHtcbiAgICAgICAgZ3JpZF9pZDogdGhpcy5pZCxcbiAgICAgICAgeDogZXZlbnQubGF5ZXJYLFxuICAgICAgICB5OiBldmVudC5sYXllclkgKyB0aGlzLmxheW91dC5vZmZzZXRcbiAgICAgIH0pO1xuICAgICAgdGhpcy5jYWxjX29mZnNldCgpO1xuICAgICAgdGhpcy5wcm9wYWdhdGUoJ21vdXNlbW92ZScsIGV2ZW50KTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwibW91c2VvdXRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gbW91c2VvdXQoZXZlbnQpIHtcbiAgICAgIGlmICh1dGlscy5pc19tb2JpbGUpIHJldHVybjtcbiAgICAgIHRoaXMuY29tcC4kZW1pdCgnY3Vyc29yLWNoYW5nZWQnLCB7fSk7XG4gICAgICB0aGlzLnByb3BhZ2F0ZSgnbW91c2VvdXQnLCBldmVudCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIm1vdXNldXBcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gbW91c2V1cChldmVudCkge1xuICAgICAgdGhpcy5kcnVnID0gbnVsbDtcbiAgICAgIHRoaXMuY29tcC4kZW1pdCgnY3Vyc29yLWxvY2tlZCcsIGZhbHNlKTtcbiAgICAgIHRoaXMucHJvcGFnYXRlKCdtb3VzZXVwJywgZXZlbnQpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJtb3VzZWRvd25cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gbW91c2Vkb3duKGV2ZW50KSB7XG4gICAgICBpZiAodXRpbHMuaXNfbW9iaWxlKSByZXR1cm47XG4gICAgICB0aGlzLnByb3BhZ2F0ZSgnbW91c2Vkb3duJywgZXZlbnQpO1xuICAgICAgdGhpcy5jb21wLiRlbWl0KCdjdXJzb3ItbG9ja2VkJywgdHJ1ZSk7XG4gICAgICBpZiAoZXZlbnQuZGVmYXVsdFByZXZlbnRlZCkgcmV0dXJuO1xuICAgICAgdGhpcy5jb21wLiRlbWl0KCdjdXN0b20tZXZlbnQnLCB7XG4gICAgICAgIGV2ZW50OiAnZ3JpZC1tb3VzZWRvd24nLFxuICAgICAgICBhcmdzOiBbdGhpcy5pZCwgZXZlbnRdXG4gICAgICB9KTtcbiAgICB9IC8vIFNpbXVsYXRlZCBtb3VzZWRvd24gKGZvciBtb2JpbGUpXG5cbiAgfSwge1xuICAgIGtleTogXCJzaW1fbW91c2Vkb3duXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNpbV9tb3VzZWRvd24oZXZlbnQpIHtcbiAgICAgIHZhciBfdGhpczIgPSB0aGlzO1xuXG4gICAgICBpZiAoZXZlbnQuc3JjRXZlbnQuZGVmYXVsdFByZXZlbnRlZCkgcmV0dXJuO1xuICAgICAgdGhpcy5jb21wLiRlbWl0KCdjdXN0b20tZXZlbnQnLCB7XG4gICAgICAgIGV2ZW50OiAnZ3JpZC1tb3VzZWRvd24nLFxuICAgICAgICBhcmdzOiBbdGhpcy5pZCwgZXZlbnRdXG4gICAgICB9KTtcbiAgICAgIHRoaXMucHJvcGFnYXRlKCdtb3VzZW1vdmUnLCB0aGlzLnRvdWNoMm1vdXNlKGV2ZW50KSk7XG4gICAgICB0aGlzLnVwZGF0ZSgpO1xuICAgICAgdGhpcy5wcm9wYWdhdGUoJ21vdXNlZG93bicsIHRoaXMudG91Y2gybW91c2UoZXZlbnQpKTtcbiAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICBfdGhpczIucHJvcGFnYXRlKCdjbGljaycsIF90aGlzMi50b3VjaDJtb3VzZShldmVudCkpO1xuICAgICAgfSk7XG4gICAgfSAvLyBDb252ZXJ0IHRvdWNoIHRvIFwibW91c2VcIiBldmVudFxuXG4gIH0sIHtcbiAgICBrZXk6IFwidG91Y2gybW91c2VcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdG91Y2gybW91c2UoZSkge1xuICAgICAgdGhpcy5jYWxjX29mZnNldCgpO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgb3JpZ2luYWw6IGUuc3JjRXZlbnQsXG4gICAgICAgIGxheWVyWDogZS5jZW50ZXIueCArIHRoaXMub2Zmc2V0X3gsXG4gICAgICAgIGxheWVyWTogZS5jZW50ZXIueSArIHRoaXMub2Zmc2V0X3ksXG4gICAgICAgIHByZXZlbnREZWZhdWx0OiBmdW5jdGlvbiBwcmV2ZW50RGVmYXVsdCgpIHtcbiAgICAgICAgICB0aGlzLm9yaWdpbmFsLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImNsaWNrXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNsaWNrKGV2ZW50KSB7XG4gICAgICB0aGlzLnByb3BhZ2F0ZSgnY2xpY2snLCBldmVudCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImVtaXRfY3Vyc29yX2Nvb3JkXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGVtaXRfY3Vyc29yX2Nvb3JkKGV2ZW50LCBhZGQpIHtcbiAgICAgIGlmIChhZGQgPT09IHZvaWQgMCkge1xuICAgICAgICBhZGQgPSB7fTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5jb21wLiRlbWl0KCdjdXJzb3ItY2hhbmdlZCcsIE9iamVjdC5hc3NpZ24oe1xuICAgICAgICBncmlkX2lkOiB0aGlzLmlkLFxuICAgICAgICB4OiBldmVudC5jZW50ZXIueCArIHRoaXMub2Zmc2V0X3gsXG4gICAgICAgIHk6IGV2ZW50LmNlbnRlci55ICsgdGhpcy5vZmZzZXRfeSArIHRoaXMubGF5b3V0Lm9mZnNldFxuICAgICAgfSwgYWRkKSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInBhbl9mYWRlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHBhbl9mYWRlKGV2ZW50KSB7XG4gICAgICB2YXIgX3RoaXMzID0gdGhpcztcblxuICAgICAgdmFyIGR0ID0gdXRpbHMubm93KCkgLSB0aGlzLmRydWcudDA7XG4gICAgICB2YXIgZHggPSB0aGlzLnJhbmdlWzFdIC0gdGhpcy5kcnVnLnJbMV07XG4gICAgICB2YXIgdiA9IDQyICogZHggLyBkdDtcbiAgICAgIHZhciB2MCA9IE1hdGguYWJzKHYgKiAwLjAxKTtcbiAgICAgIGlmIChkdCA+IDUwMCkgcmV0dXJuO1xuICAgICAgaWYgKHRoaXMuZmFkZSkgdGhpcy5mYWRlLnN0b3AoKTtcbiAgICAgIHRoaXMuZmFkZSA9IG5ldyBGcmFtZUFuaW1hdGlvbihmdW5jdGlvbiAoc2VsZikge1xuICAgICAgICB2ICo9IDAuODU7XG5cbiAgICAgICAgaWYgKE1hdGguYWJzKHYpIDwgdjApIHtcbiAgICAgICAgICBzZWxmLnN0b3AoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIF90aGlzMy5yYW5nZVswXSArPSB2O1xuICAgICAgICBfdGhpczMucmFuZ2VbMV0gKz0gdjtcblxuICAgICAgICBfdGhpczMuY2hhbmdlX3JhbmdlKCk7XG4gICAgICB9KTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiY2FsY19vZmZzZXRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gY2FsY19vZmZzZXQoKSB7XG4gICAgICB2YXIgcmVjdCA9IHRoaXMuY2FudmFzLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgdGhpcy5vZmZzZXRfeCA9IC1yZWN0Lng7XG4gICAgICB0aGlzLm9mZnNldF95ID0gLXJlY3QueTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwibmV3X2xheWVyXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG5ld19sYXllcihsYXllcikge1xuICAgICAgaWYgKGxheWVyLm5hbWUgPT09ICdjcm9zc2hhaXInKSB7XG4gICAgICAgIHRoaXMuY3Jvc3NoYWlyID0gbGF5ZXI7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLm92ZXJsYXlzLnB1c2gobGF5ZXIpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLnVwZGF0ZSgpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJkZWxfbGF5ZXJcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZGVsX2xheWVyKGlkKSB7XG4gICAgICB0aGlzLm92ZXJsYXlzID0gdGhpcy5vdmVybGF5cy5maWx0ZXIoZnVuY3Rpb24gKHgpIHtcbiAgICAgICAgcmV0dXJuIHguaWQgIT09IGlkO1xuICAgICAgfSk7XG4gICAgICB0aGlzLnVwZGF0ZSgpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJzaG93X2hpZGVfbGF5ZXJcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2hvd19oaWRlX2xheWVyKGV2ZW50KSB7XG4gICAgICB2YXIgbCA9IHRoaXMub3ZlcmxheXMuZmlsdGVyKGZ1bmN0aW9uICh4KSB7XG4gICAgICAgIHJldHVybiB4LmlkID09PSBldmVudC5pZDtcbiAgICAgIH0pO1xuICAgICAgaWYgKGwubGVuZ3RoKSBsWzBdLmRpc3BsYXkgPSBldmVudC5kaXNwbGF5O1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJ1cGRhdGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdXBkYXRlKCkge1xuICAgICAgdmFyIF90aGlzNCA9IHRoaXM7XG5cbiAgICAgIC8vIFVwZGF0ZSByZWZlcmVuY2UgdG8gdGhlIGdyaWRcbiAgICAgIC8vIFRPRE86IGNoZWNrIHdoYXQgaGFwcGVucyBpZiBkYXRhIGNoYW5nZXMgaW50ZXJ2YWxcbiAgICAgIHRoaXMubGF5b3V0ID0gdGhpcy4kcC5sYXlvdXQuZ3JpZHNbdGhpcy5pZF07XG4gICAgICB0aGlzLmludGVydmFsID0gdGhpcy4kcC5pbnRlcnZhbDtcbiAgICAgIGlmICghdGhpcy5sYXlvdXQpIHJldHVybjtcbiAgICAgIHRoaXMuY3R4LmNsZWFyUmVjdCgwLCAwLCB0aGlzLmNhbnZhcy53aWR0aCwgdGhpcy5jYW52YXMuaGVpZ2h0KTtcbiAgICAgIGlmICh0aGlzLiRwLnNoYWRlcnMubGVuZ3RoKSB0aGlzLmFwcGx5X3NoYWRlcnMoKTtcbiAgICAgIHRoaXMuZ3JpZCgpO1xuICAgICAgdmFyIG92ZXJsYXlzID0gW107XG4gICAgICBvdmVybGF5cy5wdXNoLmFwcGx5KG92ZXJsYXlzLCBfdG9Db25zdW1hYmxlQXJyYXkodGhpcy5vdmVybGF5cykpOyAvLyB6LWluZGV4IHNvcnRpbmdcblxuICAgICAgb3ZlcmxheXMuc29ydChmdW5jdGlvbiAobDEsIGwyKSB7XG4gICAgICAgIHJldHVybiBsMS56IC0gbDIuejtcbiAgICAgIH0pO1xuICAgICAgb3ZlcmxheXMuZm9yRWFjaChmdW5jdGlvbiAobCkge1xuICAgICAgICBpZiAoIWwuZGlzcGxheSkgcmV0dXJuO1xuXG4gICAgICAgIF90aGlzNC5jdHguc2F2ZSgpO1xuXG4gICAgICAgIHZhciByID0gbC5yZW5kZXJlcjtcbiAgICAgICAgaWYgKHIucHJlX2RyYXcpIHIucHJlX2RyYXcoX3RoaXM0LmN0eCk7XG4gICAgICAgIHIuZHJhdyhfdGhpczQuY3R4KTtcbiAgICAgICAgaWYgKHIucG9zdF9kcmF3KSByLnBvc3RfZHJhdyhfdGhpczQuY3R4KTtcblxuICAgICAgICBfdGhpczQuY3R4LnJlc3RvcmUoKTtcbiAgICAgIH0pO1xuXG4gICAgICBpZiAodGhpcy5jcm9zc2hhaXIpIHtcbiAgICAgICAgdGhpcy5jcm9zc2hhaXIucmVuZGVyZXIuZHJhdyh0aGlzLmN0eCk7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImFwcGx5X3NoYWRlcnNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gYXBwbHlfc2hhZGVycygpIHtcbiAgICAgIHZhciBsYXlvdXQgPSB0aGlzLiRwLmxheW91dC5ncmlkc1t0aGlzLmlkXTtcbiAgICAgIHZhciBwcm9wcyA9IHtcbiAgICAgICAgbGF5b3V0OiBsYXlvdXQsXG4gICAgICAgIHJhbmdlOiB0aGlzLnJhbmdlLFxuICAgICAgICBpbnRlcnZhbDogdGhpcy5pbnRlcnZhbCxcbiAgICAgICAgdGY6IGxheW91dC50aV9tYXAudGYsXG4gICAgICAgIGN1cnNvcjogdGhpcy5jdXJzb3IsXG4gICAgICAgIGNvbG9yczogdGhpcy4kcC5jb2xvcnMsXG4gICAgICAgIHN1YjogdGhpcy5kYXRhLFxuICAgICAgICBmb250OiB0aGlzLiRwLmZvbnQsXG4gICAgICAgIGNvbmZpZzogdGhpcy4kcC5jb25maWcsXG4gICAgICAgIG1ldGE6IHRoaXMuJHAubWV0YVxuICAgICAgfTtcblxuICAgICAgdmFyIF9pdGVyYXRvciA9IGdyaWRfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlcih0aGlzLiRwLnNoYWRlcnMpLFxuICAgICAgICAgIF9zdGVwO1xuXG4gICAgICB0cnkge1xuICAgICAgICBmb3IgKF9pdGVyYXRvci5zKCk7ICEoX3N0ZXAgPSBfaXRlcmF0b3IubigpKS5kb25lOykge1xuICAgICAgICAgIHZhciBzID0gX3N0ZXAudmFsdWU7XG4gICAgICAgICAgdGhpcy5jdHguc2F2ZSgpO1xuICAgICAgICAgIHMuZHJhdyh0aGlzLmN0eCwgcHJvcHMpO1xuICAgICAgICAgIHRoaXMuY3R4LnJlc3RvcmUoKTtcbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIF9pdGVyYXRvci5lKGVycik7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICBfaXRlcmF0b3IuZigpO1xuICAgICAgfVxuICAgIH0gLy8gQWN0dWFsbHkgZHJhd3MgdGhlIGdyaWQgKGZvciByZWFsKVxuXG4gIH0sIHtcbiAgICBrZXk6IFwiZ3JpZFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBncmlkKCkge1xuICAgICAgdGhpcy5jdHguc3Ryb2tlU3R5bGUgPSB0aGlzLiRwLmNvbG9ycy5ncmlkO1xuICAgICAgdGhpcy5jdHguYmVnaW5QYXRoKCk7XG4gICAgICB2YXIgeW1heCA9IHRoaXMubGF5b3V0LmhlaWdodDtcblxuICAgICAgdmFyIF9pdGVyYXRvcjIgPSBncmlkX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXIodGhpcy5sYXlvdXQueHMpLFxuICAgICAgICAgIF9zdGVwMjtcblxuICAgICAgdHJ5IHtcbiAgICAgICAgZm9yIChfaXRlcmF0b3IyLnMoKTsgIShfc3RlcDIgPSBfaXRlcmF0b3IyLm4oKSkuZG9uZTspIHtcbiAgICAgICAgICB2YXIgX3N0ZXAyJHZhbHVlID0gX3NsaWNlZFRvQXJyYXkoX3N0ZXAyLnZhbHVlLCAyKSxcbiAgICAgICAgICAgICAgeCA9IF9zdGVwMiR2YWx1ZVswXSxcbiAgICAgICAgICAgICAgcCA9IF9zdGVwMiR2YWx1ZVsxXTtcblxuICAgICAgICAgIHRoaXMuY3R4Lm1vdmVUbyh4IC0gMC41LCAwKTtcbiAgICAgICAgICB0aGlzLmN0eC5saW5lVG8oeCAtIDAuNSwgeW1heCk7XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICBfaXRlcmF0b3IyLmUoZXJyKTtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIF9pdGVyYXRvcjIuZigpO1xuICAgICAgfVxuXG4gICAgICB2YXIgX2l0ZXJhdG9yMyA9IGdyaWRfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlcih0aGlzLmxheW91dC55cyksXG4gICAgICAgICAgX3N0ZXAzO1xuXG4gICAgICB0cnkge1xuICAgICAgICBmb3IgKF9pdGVyYXRvcjMucygpOyAhKF9zdGVwMyA9IF9pdGVyYXRvcjMubigpKS5kb25lOykge1xuICAgICAgICAgIHZhciBfc3RlcDMkdmFsdWUgPSBfc2xpY2VkVG9BcnJheShfc3RlcDMudmFsdWUsIDIpLFxuICAgICAgICAgICAgICB5ID0gX3N0ZXAzJHZhbHVlWzBdLFxuICAgICAgICAgICAgICB5JCA9IF9zdGVwMyR2YWx1ZVsxXTtcblxuICAgICAgICAgIHRoaXMuY3R4Lm1vdmVUbygwLCB5IC0gMC41KTtcbiAgICAgICAgICB0aGlzLmN0eC5saW5lVG8odGhpcy5sYXlvdXQud2lkdGgsIHkgLSAwLjUpO1xuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgX2l0ZXJhdG9yMy5lKGVycik7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICBfaXRlcmF0b3IzLmYoKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5jdHguc3Ryb2tlKCk7XG4gICAgICBpZiAodGhpcy4kcC5ncmlkX2lkKSB0aGlzLnVwcGVyX2JvcmRlcigpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJ1cHBlcl9ib3JkZXJcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdXBwZXJfYm9yZGVyKCkge1xuICAgICAgdGhpcy5jdHguc3Ryb2tlU3R5bGUgPSB0aGlzLiRwLmNvbG9ycy5zY2FsZTtcbiAgICAgIHRoaXMuY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgdGhpcy5jdHgubW92ZVRvKDAsIDAuNSk7XG4gICAgICB0aGlzLmN0eC5saW5lVG8odGhpcy5sYXlvdXQud2lkdGgsIDAuNSk7XG4gICAgICB0aGlzLmN0eC5zdHJva2UoKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwibW91c2V6b29tXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG1vdXNlem9vbShkZWx0YSwgZXZlbnQpIHtcbiAgICAgIC8vIFRPRE86IGZvciBtb2JpbGVcbiAgICAgIGlmICh0aGlzLndtb2RlICE9PSAncGFzcycpIHtcbiAgICAgICAgaWYgKHRoaXMud21vZGUgPT09ICdjbGljaycgJiYgIXRoaXMuJHAubWV0YS5hY3RpdmF0ZWQpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBldmVudC5vcmlnaW5hbEV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICB9XG5cbiAgICAgIGV2ZW50LmRlbHRhWCA9IGV2ZW50LmRlbHRhWCB8fCB1dGlscy5nZXRfZGVsdGFYKGV2ZW50KTtcbiAgICAgIGV2ZW50LmRlbHRhWSA9IGV2ZW50LmRlbHRhWSB8fCB1dGlscy5nZXRfZGVsdGFZKGV2ZW50KTtcblxuICAgICAgaWYgKE1hdGguYWJzKGV2ZW50LmRlbHRhWCkgPiAwKSB7XG4gICAgICAgIHRoaXMudHJhY2twYWQgPSB0cnVlO1xuXG4gICAgICAgIGlmIChNYXRoLmFicyhldmVudC5kZWx0YVgpID49IE1hdGguYWJzKGV2ZW50LmRlbHRhWSkpIHtcbiAgICAgICAgICBkZWx0YSAqPSAwLjE7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnRyYWNrcGFkX3Njcm9sbChldmVudCk7XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLnRyYWNrcGFkKSBkZWx0YSAqPSAwLjAzMjtcbiAgICAgIGRlbHRhID0gdXRpbHMuc21hcnRfd2hlZWwoZGVsdGEpOyAvLyBUT0RPOiBtb3VzZSB6b29taW5nIGlzIGEgbGl0dGxlIGplcmt5LFxuICAgICAgLy8gbmVlZHMgdG8gZm9sbG93IGYobW91c2Vfd2hlZWxfc3BlZWQpIGFuZFxuICAgICAgLy8gaWYgc3BlZWQgaXMgbG93LCBzY3JvbGwgc2hvdWQgYmUgc2xvd2VyXG5cbiAgICAgIGlmIChkZWx0YSA8IDAgJiYgdGhpcy5kYXRhLmxlbmd0aCA8PSB0aGlzLk1JTl9aT09NKSByZXR1cm47XG4gICAgICBpZiAoZGVsdGEgPiAwICYmIHRoaXMuZGF0YS5sZW5ndGggPiB0aGlzLk1BWF9aT09NKSByZXR1cm47XG4gICAgICB2YXIgayA9IHRoaXMuaW50ZXJ2YWwgLyAxMDAwO1xuICAgICAgdmFyIGRpZmYgPSBkZWx0YSAqIGsgKiB0aGlzLmRhdGEubGVuZ3RoO1xuICAgICAgdmFyIHRsID0gdGhpcy5jb21wLmNvbmZpZy5aT09NX01PREUgPT09ICd0bCc7XG5cbiAgICAgIGlmIChldmVudC5vcmlnaW5hbEV2ZW50LmN0cmxLZXkgfHwgdGwpIHtcbiAgICAgICAgdmFyIG9mZnNldCA9IGV2ZW50Lm9yaWdpbmFsRXZlbnQub2Zmc2V0WDtcbiAgICAgICAgdmFyIGRpZmYxID0gb2Zmc2V0IC8gKHRoaXMuY2FudmFzLndpZHRoIC0gMSkgKiBkaWZmO1xuICAgICAgICB2YXIgZGlmZjIgPSBkaWZmIC0gZGlmZjE7XG4gICAgICAgIHRoaXMucmFuZ2VbMF0gLT0gZGlmZjE7XG4gICAgICAgIHRoaXMucmFuZ2VbMV0gKz0gZGlmZjI7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLnJhbmdlWzBdIC09IGRpZmY7XG4gICAgICB9XG5cbiAgICAgIGlmICh0bCkge1xuICAgICAgICB2YXIgX29mZnNldCA9IGV2ZW50Lm9yaWdpbmFsRXZlbnQub2Zmc2V0WTtcblxuICAgICAgICB2YXIgX2RpZmYgPSBfb2Zmc2V0IC8gKHRoaXMuY2FudmFzLmhlaWdodCAtIDEpICogMjtcblxuICAgICAgICB2YXIgX2RpZmYyID0gMiAtIF9kaWZmO1xuXG4gICAgICAgIHZhciB6ID0gZGlmZiAvICh0aGlzLnJhbmdlWzFdIC0gdGhpcy5yYW5nZVswXSk7IC8vcmV6b29tX3JhbmdlKHosIGRpZmZfeCwgZGlmZl95KVxuXG4gICAgICAgIHRoaXMuY29tcC4kZW1pdCgncmV6b29tLXJhbmdlJywge1xuICAgICAgICAgIGdyaWRfaWQ6IHRoaXMuaWQsXG4gICAgICAgICAgejogeixcbiAgICAgICAgICBkaWZmMTogX2RpZmYsXG4gICAgICAgICAgZGlmZjI6IF9kaWZmMlxuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5jaGFuZ2VfcmFuZ2UoKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwibW91c2VkcmFnXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG1vdXNlZHJhZyh4LCB5KSB7XG4gICAgICB2YXIgZHQgPSB0aGlzLmRydWcudCAqICh0aGlzLmRydWcueCAtIHgpIC8gdGhpcy5sYXlvdXQud2lkdGg7XG4gICAgICB2YXIgZCQgPSB0aGlzLmxheW91dC4kX2hpIC0gdGhpcy5sYXlvdXQuJF9sbztcbiAgICAgIGQkICo9ICh0aGlzLmRydWcueSAtIHkpIC8gdGhpcy5sYXlvdXQuaGVpZ2h0O1xuICAgICAgdmFyIG9mZnNldCA9IHRoaXMuZHJ1Zy5vICsgZCQ7XG4gICAgICB2YXIgbHMgPSB0aGlzLmxheW91dC5ncmlkLmxvZ1NjYWxlO1xuXG4gICAgICBpZiAobHMgJiYgdGhpcy5kcnVnLnlfcikge1xuICAgICAgICB2YXIgZHkgPSB0aGlzLmRydWcueSAtIHk7XG4gICAgICAgIHZhciByYW5nZSA9IHRoaXMuZHJ1Zy55X3Iuc2xpY2UoKTtcbiAgICAgICAgcmFuZ2VbMF0gPSBtYXRoLmV4cCgoMCAtIHRoaXMuZHJ1Zy5CICsgZHkpIC8gdGhpcy5sYXlvdXQuQSk7XG4gICAgICAgIHJhbmdlWzFdID0gbWF0aC5leHAoKHRoaXMubGF5b3V0LmhlaWdodCAtIHRoaXMuZHJ1Zy5CICsgZHkpIC8gdGhpcy5sYXlvdXQuQSk7XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLmRydWcueV9yICYmIHRoaXMuJHAueV90cmFuc2Zvcm0gJiYgIXRoaXMuJHAueV90cmFuc2Zvcm0uYXV0bykge1xuICAgICAgICB0aGlzLmNvbXAuJGVtaXQoJ3NpZGViYXItdHJhbnNmb3JtJywge1xuICAgICAgICAgIGdyaWRfaWQ6IHRoaXMuaWQsXG4gICAgICAgICAgcmFuZ2U6IGxzID8gcmFuZ2UgfHwgdGhpcy5kcnVnLnlfciA6IFt0aGlzLmRydWcueV9yWzBdIC0gb2Zmc2V0LCB0aGlzLmRydWcueV9yWzFdIC0gb2Zmc2V0XVxuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5yYW5nZVswXSA9IHRoaXMuZHJ1Zy5yWzBdICsgZHQ7XG4gICAgICB0aGlzLnJhbmdlWzFdID0gdGhpcy5kcnVnLnJbMV0gKyBkdDtcbiAgICAgIHRoaXMuY2hhbmdlX3JhbmdlKCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInBpbmNoem9vbVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBwaW5jaHpvb20oc2NhbGUpIHtcbiAgICAgIGlmIChzY2FsZSA+IDEgJiYgdGhpcy5kYXRhLmxlbmd0aCA8PSB0aGlzLk1JTl9aT09NKSByZXR1cm47XG4gICAgICBpZiAoc2NhbGUgPCAxICYmIHRoaXMuZGF0YS5sZW5ndGggPiB0aGlzLk1BWF9aT09NKSByZXR1cm47XG4gICAgICB2YXIgdCA9IHRoaXMucGluY2gudDtcbiAgICAgIHZhciBudCA9IHQgKiAxIC8gc2NhbGU7XG4gICAgICB0aGlzLnJhbmdlWzBdID0gdGhpcy5waW5jaC5yWzBdIC0gKG50IC0gdCkgKiAwLjU7XG4gICAgICB0aGlzLnJhbmdlWzFdID0gdGhpcy5waW5jaC5yWzFdICsgKG50IC0gdCkgKiAwLjU7XG4gICAgICB0aGlzLmNoYW5nZV9yYW5nZSgpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJ0cmFja3BhZF9zY3JvbGxcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdHJhY2twYWRfc2Nyb2xsKGV2ZW50KSB7XG4gICAgICB2YXIgZHQgPSB0aGlzLnJhbmdlWzFdIC0gdGhpcy5yYW5nZVswXTtcbiAgICAgIHRoaXMucmFuZ2VbMF0gKz0gZXZlbnQuZGVsdGFYICogZHQgKiAwLjAxMTtcbiAgICAgIHRoaXMucmFuZ2VbMV0gKz0gZXZlbnQuZGVsdGFYICogZHQgKiAwLjAxMTtcbiAgICAgIHRoaXMuY2hhbmdlX3JhbmdlKCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImNoYW5nZV9yYW5nZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjaGFuZ2VfcmFuZ2UoKSB7XG4gICAgICAvLyBUT0RPOiBiZXR0ZXIgd2F5IHRvIGxpbWl0IHRoZSB2aWV3LiBQcm9ibGVtOlxuICAgICAgLy8gd2hlbiB5b3UgYXJlIGF0IHRoZSBkZWFkIGVuZCBvZiB0aGUgZGF0YSxcbiAgICAgIC8vIGFuZCBrZWVwIHNjcm9sbGluZyxcbiAgICAgIC8vIHRoZSBjaGFydCBjb250aW51ZXMgdG8gc2NhbGUgZG93biBhIGxpdHRsZS5cbiAgICAgIC8vIFNvbHV0aW9uOiBJIGRvbid0IGtub3cgeWV0XG4gICAgICBpZiAoIXRoaXMucmFuZ2UubGVuZ3RoIHx8IHRoaXMuZGF0YS5sZW5ndGggPCAyKSByZXR1cm47XG4gICAgICB2YXIgbCA9IHRoaXMuZGF0YS5sZW5ndGggLSAxO1xuICAgICAgdmFyIGRhdGEgPSB0aGlzLmRhdGE7XG4gICAgICB2YXIgcmFuZ2UgPSB0aGlzLnJhbmdlO1xuICAgICAgcmFuZ2VbMF0gPSB1dGlscy5jbGFtcChyYW5nZVswXSwgLUluZmluaXR5LCBkYXRhW2xdWzBdIC0gdGhpcy5pbnRlcnZhbCAqIDUuNSk7XG4gICAgICByYW5nZVsxXSA9IHV0aWxzLmNsYW1wKHJhbmdlWzFdLCBkYXRhWzBdWzBdICsgdGhpcy5pbnRlcnZhbCAqIDUuNSwgSW5maW5pdHkpOyAvLyBUT0RPOiBJTVBPUlRBTlQgc2Nyb2xsaW5nIGlzIGplcmt5IFRoZSBQcm9ibGVtIGNhdXNlZFxuICAgICAgLy8gYnkgdGhlIGxvbmcgcm91bmQgdHJpcCBvZiAncmFuZ2UtY2hhbmdlZCcgZXZlbnQuXG4gICAgICAvLyBGaXJzdCBpdCBwcm9wYWdhdGVzIHVwIHRvIHVwZGF0ZSBsYXlvdXQgaW4gQ2hhcnQudnVlLFxuICAgICAgLy8gdGhlbiBpdCBtb3ZlcyBiYWNrIGFzIHdhdGNoKCkgdXBkYXRlLiBJdCB0YWtlcyAxLTUgbXMuXG4gICAgICAvLyBBbmQgYmVjYXVzZSB0aGUgZGVsYXkgaXMgZGlmZmVyZW50IGVhY2ggdGltZSB3ZSBzZWVcbiAgICAgIC8vIHRoZSBsYWcuIE5vIHNtb290aCBtb3ZlbWVudCBhbmQgaXQncyBhbm5veWluZy5cbiAgICAgIC8vIFNvbHV0aW9uOiB3ZSBjb3VsZCB0cnkgdG8gY2FsYyB0aGUgbGF5b3V0IGltbWVkaWF0bHlcbiAgICAgIC8vIHNvbWV3aGVyZSBoZXJlLiBTdGlsbCB3aWxsIGh1cnQgdGhlIHNpZGViYXIgJiBib3R0b21iYXJcblxuICAgICAgdGhpcy5jb21wLiRlbWl0KCdyYW5nZS1jaGFuZ2VkJywgcmFuZ2UpO1xuICAgIH0gLy8gUHJvcGFnYXRlIG1vdXNlIGV2ZW50IHRvIG92ZXJsYXlzXG5cbiAgfSwge1xuICAgIGtleTogXCJwcm9wYWdhdGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcHJvcGFnYXRlKG5hbWUsIGV2ZW50KSB7XG4gICAgICB2YXIgX2l0ZXJhdG9yNCA9IGdyaWRfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlcih0aGlzLm92ZXJsYXlzKSxcbiAgICAgICAgICBfc3RlcDQ7XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIGZvciAoX2l0ZXJhdG9yNC5zKCk7ICEoX3N0ZXA0ID0gX2l0ZXJhdG9yNC5uKCkpLmRvbmU7KSB7XG4gICAgICAgICAgdmFyIGxheWVyID0gX3N0ZXA0LnZhbHVlO1xuXG4gICAgICAgICAgaWYgKGxheWVyLnJlbmRlcmVyW25hbWVdKSB7XG4gICAgICAgICAgICBsYXllci5yZW5kZXJlcltuYW1lXShldmVudCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdmFyIG1vdXNlID0gbGF5ZXIucmVuZGVyZXIubW91c2U7XG4gICAgICAgICAgdmFyIGtleXMgPSBsYXllci5yZW5kZXJlci5rZXlzO1xuXG4gICAgICAgICAgaWYgKG1vdXNlLmxpc3RlbmVycykge1xuICAgICAgICAgICAgbW91c2UuZW1pdChuYW1lLCBldmVudCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKGtleXMgJiYga2V5cy5saXN0ZW5lcnMpIHtcbiAgICAgICAgICAgIGtleXMuZW1pdChuYW1lLCBldmVudCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgX2l0ZXJhdG9yNC5lKGVycik7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICBfaXRlcmF0b3I0LmYoKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZGVzdHJveVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBkZXN0cm95KCkge1xuICAgICAgdmFyIHJtID0gcmVtb3ZlRXZlbnRMaXN0ZW5lcjtcbiAgICAgIHJtKFwiZ2VzdHVyZXN0YXJ0XCIsIHRoaXMuZ2VzdHVyZXN0YXJ0KTtcbiAgICAgIHJtKFwiZ2VzdHVyZWNoYW5nZVwiLCB0aGlzLmdlc3R1cmVjaGFuZ2UpO1xuICAgICAgcm0oXCJnZXN0dXJlZW5kXCIsIHRoaXMuZ2VzdHVyZWVuZCk7XG4gICAgICBpZiAodGhpcy5tYykgdGhpcy5tYy5kZXN0cm95KCk7XG4gICAgICBpZiAodGhpcy5obSkgdGhpcy5obS51bndoZWVsKCk7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIEdyaWQ7XG59KCk7XG5cblxuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL21peGlucy9jYW52YXMuanNcbi8vIEludGVyYWN0aXZlIGNhbnZhcy1iYXNlZCBjb21wb25lbnRcbi8vIFNob3VsZCBpbXBsZW1lbnQ6IG1vdXNlbW92ZSwgbW91c2VvdXQsIG1vdXNldXAsIG1vdXNlZG93biwgY2xpY2tcblxuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyBjb25zdCBjYW52YXMgPSAoe1xuICBtZXRob2RzOiB7XG4gICAgc2V0dXA6IGZ1bmN0aW9uIHNldHVwKCkge1xuICAgICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgICAgdmFyIGlkID0gXCJcIi5jb25jYXQodGhpcy4kcHJvcHMudHZfaWQsIFwiLVwiKS5jb25jYXQodGhpcy5faWQsIFwiLWNhbnZhc1wiKTtcbiAgICAgIHZhciBjYW52YXMgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChpZCk7XG4gICAgICB2YXIgZHByID0gd2luZG93LmRldmljZVBpeGVsUmF0aW8gfHwgMTtcbiAgICAgIGNhbnZhcy5zdHlsZS53aWR0aCA9IFwiXCIuY29uY2F0KHRoaXMuX2F0dHJzLndpZHRoLCBcInB4XCIpO1xuICAgICAgY2FudmFzLnN0eWxlLmhlaWdodCA9IFwiXCIuY29uY2F0KHRoaXMuX2F0dHJzLmhlaWdodCwgXCJweFwiKTtcbiAgICAgIGlmIChkcHIgPCAxKSBkcHIgPSAxOyAvLyBSZWFseSA/IFRoYXQncyBpdD8gSXNzdWUgIzYzXG5cbiAgICAgIHRoaXMuJG5leHRUaWNrKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHJlY3QgPSBjYW52YXMuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICAgIGNhbnZhcy53aWR0aCA9IHJlY3Qud2lkdGggKiBkcHI7XG4gICAgICAgIGNhbnZhcy5oZWlnaHQgPSByZWN0LmhlaWdodCAqIGRwcjtcbiAgICAgICAgdmFyIGN0eCA9IGNhbnZhcy5nZXRDb250ZXh0KCcyZCcsIHsvLyBUT0RPOiB0ZXN0IHRoZSBib29zdDpcbiAgICAgICAgICAvL2FscGhhOiBmYWxzZSxcbiAgICAgICAgICAvL2Rlc3luY2hyb25pemVkOiB0cnVlLFxuICAgICAgICAgIC8vcHJlc2VydmVEcmF3aW5nQnVmZmVyOiBmYWxzZVxuICAgICAgICB9KTtcbiAgICAgICAgY3R4LnNjYWxlKGRwciwgZHByKTtcblxuICAgICAgICBfdGhpcy5yZWRyYXcoKTsgLy8gRmFsbGJhY2sgZml4IGZvciBCcmF2ZSBicm93c2VyXG4gICAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9icmF2ZS9icmF2ZS1icm93c2VyL2lzc3Vlcy8xNzM4XG5cblxuICAgICAgICBpZiAoIWN0eC5tZWFzdXJlVGV4dE9yZykge1xuICAgICAgICAgIGN0eC5tZWFzdXJlVGV4dE9yZyA9IGN0eC5tZWFzdXJlVGV4dDtcbiAgICAgICAgfVxuXG4gICAgICAgIGN0eC5tZWFzdXJlVGV4dCA9IGZ1bmN0aW9uICh0ZXh0KSB7XG4gICAgICAgICAgcmV0dXJuIHV0aWxzLm1lYXN1cmVUZXh0KGN0eCwgdGV4dCwgX3RoaXMuJHByb3BzLnR2X2lkKTtcbiAgICAgICAgfTtcbiAgICAgIH0pO1xuICAgIH0sXG4gICAgY3JlYXRlX2NhbnZhczogZnVuY3Rpb24gY3JlYXRlX2NhbnZhcyhoLCBpZCwgcHJvcHMpIHtcbiAgICAgIHZhciBfdGhpczIgPSB0aGlzO1xuXG4gICAgICB0aGlzLl9pZCA9IGlkO1xuICAgICAgdGhpcy5fYXR0cnMgPSBwcm9wcy5hdHRycztcbiAgICAgIHJldHVybiBoKCdkaXYnLCB7XG4gICAgICAgIFwiY2xhc3NcIjogXCJ0cmFkaW5nLXZ1ZS1cIi5jb25jYXQoaWQpLFxuICAgICAgICBzdHlsZToge1xuICAgICAgICAgIGxlZnQ6IHByb3BzLnBvc2l0aW9uLnggKyAncHgnLFxuICAgICAgICAgIHRvcDogcHJvcHMucG9zaXRpb24ueSArICdweCcsXG4gICAgICAgICAgcG9zaXRpb246ICdhYnNvbHV0ZSdcbiAgICAgICAgfVxuICAgICAgfSwgW2goJ2NhbnZhcycsIHtcbiAgICAgICAgb246IHtcbiAgICAgICAgICBtb3VzZW1vdmU6IGZ1bmN0aW9uIG1vdXNlbW92ZShlKSB7XG4gICAgICAgICAgICByZXR1cm4gX3RoaXMyLnJlbmRlcmVyLm1vdXNlbW92ZShlKTtcbiAgICAgICAgICB9LFxuICAgICAgICAgIG1vdXNlb3V0OiBmdW5jdGlvbiBtb3VzZW91dChlKSB7XG4gICAgICAgICAgICByZXR1cm4gX3RoaXMyLnJlbmRlcmVyLm1vdXNlb3V0KGUpO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgbW91c2V1cDogZnVuY3Rpb24gbW91c2V1cChlKSB7XG4gICAgICAgICAgICByZXR1cm4gX3RoaXMyLnJlbmRlcmVyLm1vdXNldXAoZSk7XG4gICAgICAgICAgfSxcbiAgICAgICAgICBtb3VzZWRvd246IGZ1bmN0aW9uIG1vdXNlZG93bihlKSB7XG4gICAgICAgICAgICByZXR1cm4gX3RoaXMyLnJlbmRlcmVyLm1vdXNlZG93bihlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIGF0dHJzOiBPYmplY3QuYXNzaWduKHtcbiAgICAgICAgICBpZDogXCJcIi5jb25jYXQodGhpcy4kcHJvcHMudHZfaWQsIFwiLVwiKS5jb25jYXQoaWQsIFwiLWNhbnZhc1wiKVxuICAgICAgICB9LCBwcm9wcy5hdHRycyksXG4gICAgICAgIHJlZjogJ2NhbnZhcycsXG4gICAgICAgIHN0eWxlOiBwcm9wcy5zdHlsZVxuICAgICAgfSldLmNvbmNhdChwcm9wcy5ocyB8fCBbXSkpO1xuICAgIH0sXG4gICAgcmVkcmF3OiBmdW5jdGlvbiByZWRyYXcoKSB7XG4gICAgICBpZiAoIXRoaXMucmVuZGVyZXIpIHJldHVybjtcbiAgICAgIHRoaXMucmVuZGVyZXIudXBkYXRlKCk7XG4gICAgfVxuICB9LFxuICB3YXRjaDoge1xuICAgIHdpZHRoOiBmdW5jdGlvbiB3aWR0aCh2YWwpIHtcbiAgICAgIHRoaXMuX2F0dHJzLndpZHRoID0gdmFsO1xuICAgICAgdGhpcy5zZXR1cCgpO1xuICAgIH0sXG4gICAgaGVpZ2h0OiBmdW5jdGlvbiBoZWlnaHQodmFsKSB7XG4gICAgICB0aGlzLl9hdHRycy5oZWlnaHQgPSB2YWw7XG4gICAgICB0aGlzLnNldHVwKCk7XG4gICAgfVxuICB9XG59KTtcbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9taXhpbnMvdXhsaXN0LmpzXG4vLyBNYW5hZ2VyIGZvciBJbnRlZXJmYWNlIG9iamVjdHNcbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gY29uc3QgdXhsaXN0ID0gKHtcbiAgbWV0aG9kczoge1xuICAgIG9uX3V4X2V2ZW50OiBmdW5jdGlvbiBvbl91eF9ldmVudChkLCB0YXJnZXQpIHtcbiAgICAgIGlmIChkLmV2ZW50ID09PSAnbmV3LWludGVyZmFjZScpIHtcbiAgICAgICAgaWYgKGQuYXJnc1swXS50YXJnZXQgPT09IHRhcmdldCkge1xuICAgICAgICAgIGQuYXJnc1swXS52YXJzID0gZC5hcmdzWzBdLnZhcnMgfHwge307XG4gICAgICAgICAgZC5hcmdzWzBdLmdyaWRfaWQgPSBkLmFyZ3NbMV07XG4gICAgICAgICAgZC5hcmdzWzBdLm92ZXJsYXlfaWQgPSBkLmFyZ3NbMl07XG4gICAgICAgICAgdGhpcy51eHMucHVzaChkLmFyZ3NbMF0pOyAvLyB0aGlzLnJlcmVuZGVyKytcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChkLmV2ZW50ID09PSAnY2xvc2UtaW50ZXJmYWNlJykge1xuICAgICAgICB0aGlzLnV4cyA9IHRoaXMudXhzLmZpbHRlcihmdW5jdGlvbiAoeCkge1xuICAgICAgICAgIHJldHVybiB4LnV1aWQgIT09IGQuYXJnc1swXTtcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2UgaWYgKGQuZXZlbnQgPT09ICdtb2RpZnktaW50ZXJmYWNlJykge1xuICAgICAgICB2YXIgdXggPSB0aGlzLnV4cy5maWx0ZXIoZnVuY3Rpb24gKHgpIHtcbiAgICAgICAgICByZXR1cm4geC51dWlkID09PSBkLmFyZ3NbMF07XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGlmICh1eC5sZW5ndGgpIHtcbiAgICAgICAgICB0aGlzLm1vZGlmeSh1eFswXSwgZC5hcmdzWzFdKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChkLmV2ZW50ID09PSAnaGlkZS1pbnRlcmZhY2UnKSB7XG4gICAgICAgIHZhciBfdXggPSB0aGlzLnV4cy5maWx0ZXIoZnVuY3Rpb24gKHgpIHtcbiAgICAgICAgICByZXR1cm4geC51dWlkID09PSBkLmFyZ3NbMF07XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGlmIChfdXgubGVuZ3RoKSB7XG4gICAgICAgICAgX3V4WzBdLmhpZGRlbiA9IHRydWU7XG4gICAgICAgICAgdGhpcy5tb2RpZnkoX3V4WzBdLCB7XG4gICAgICAgICAgICBoaWRkZW46IHRydWVcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChkLmV2ZW50ID09PSAnc2hvdy1pbnRlcmZhY2UnKSB7XG4gICAgICAgIHZhciBfdXgyID0gdGhpcy51eHMuZmlsdGVyKGZ1bmN0aW9uICh4KSB7XG4gICAgICAgICAgcmV0dXJuIHgudXVpZCA9PT0gZC5hcmdzWzBdO1xuICAgICAgICB9KTtcblxuICAgICAgICBpZiAoX3V4Mi5sZW5ndGgpIHtcbiAgICAgICAgICB0aGlzLm1vZGlmeShfdXgyWzBdLCB7XG4gICAgICAgICAgICBoaWRkZW46IGZhbHNlXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBkO1xuICAgICAgfVxuICAgIH0sXG4gICAgbW9kaWZ5OiBmdW5jdGlvbiBtb2RpZnkodXgsIG9iaikge1xuICAgICAgaWYgKG9iaiA9PT0gdm9pZCAwKSB7XG4gICAgICAgIG9iaiA9IHt9O1xuICAgICAgfVxuXG4gICAgICBmb3IgKHZhciBrIGluIG9iaikge1xuICAgICAgICBpZiAoayBpbiB1eCkge1xuICAgICAgICAgIHRoaXMuJHNldCh1eCwgaywgb2JqW2tdKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG4gICAgLy8gUmVtb3ZlIGFsbCBVWHMgZm9yIGEgZ2l2ZW4gb3ZlcmxheSBpZFxuICAgIHJlbW92ZV9hbGxfdXg6IGZ1bmN0aW9uIHJlbW92ZV9hbGxfdXgoaWQpIHtcbiAgICAgIHRoaXMudXhzID0gdGhpcy51eHMuZmlsdGVyKGZ1bmN0aW9uICh4KSB7XG4gICAgICAgIHJldHVybiB4Lm92ZXJsYXkuaWQgIT09IGlkO1xuICAgICAgfSk7XG4gICAgfVxuICB9LFxuICBkYXRhOiBmdW5jdGlvbiBkYXRhKCkge1xuICAgIHJldHVybiB7XG4gICAgICB1eHM6IFtdXG4gICAgfTtcbiAgfVxufSk7XG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvY29tcG9uZW50cy9qcy9jcm9zc2hhaXIuanNcblxuXG5cbnZhciBDcm9zc2hhaXIgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBDcm9zc2hhaXIoY29tcCkge1xuICAgIGNsYXNzQ2FsbENoZWNrX2NsYXNzQ2FsbENoZWNrKHRoaXMsIENyb3NzaGFpcik7XG5cbiAgICB0aGlzLmNvbXAgPSBjb21wO1xuICAgIHRoaXMuJHAgPSBjb21wLiRwcm9wcztcbiAgICB0aGlzLmRhdGEgPSB0aGlzLiRwLnN1YjtcbiAgICB0aGlzLl92aXNpYmxlID0gZmFsc2U7XG4gICAgdGhpcy5sb2NrZWQgPSBmYWxzZTtcbiAgICB0aGlzLmxheW91dCA9IHRoaXMuJHAubGF5b3V0O1xuICB9XG5cbiAgY3JlYXRlQ2xhc3NfY3JlYXRlQ2xhc3MoQ3Jvc3NoYWlyLCBbe1xuICAgIGtleTogXCJkcmF3XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGRyYXcoY3R4KSB7XG4gICAgICAvLyBVcGRhdGUgcmVmZXJlbmNlIHRvIHRoZSBncmlkXG4gICAgICB0aGlzLmxheW91dCA9IHRoaXMuJHAubGF5b3V0O1xuICAgICAgdmFyIGN1cnNvciA9IHRoaXMuY29tcC4kcHJvcHMuY3Vyc29yO1xuICAgICAgaWYgKCF0aGlzLnZpc2libGUgJiYgY3Vyc29yLm1vZGUgPT09ICdleHBsb3JlJykgcmV0dXJuO1xuICAgICAgdGhpcy54ID0gdGhpcy4kcC5jdXJzb3IueDtcbiAgICAgIHRoaXMueSA9IHRoaXMuJHAuY3Vyc29yLnk7XG4gICAgICBjdHguc2F2ZSgpO1xuICAgICAgY3R4LnN0cm9rZVN0eWxlID0gdGhpcy4kcC5jb2xvcnMuY3Jvc3M7XG4gICAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgICBjdHguc2V0TGluZURhc2goWzVdKTsgLy8gSFxuXG4gICAgICBpZiAodGhpcy4kcC5jdXJzb3IuZ3JpZF9pZCA9PT0gdGhpcy5sYXlvdXQuaWQpIHtcbiAgICAgICAgY3R4Lm1vdmVUbygwLCB0aGlzLnkpO1xuICAgICAgICBjdHgubGluZVRvKHRoaXMubGF5b3V0LndpZHRoIC0gMC41LCB0aGlzLnkpO1xuICAgICAgfSAvLyBWXG5cblxuICAgICAgY3R4Lm1vdmVUbyh0aGlzLngsIDApO1xuICAgICAgY3R4LmxpbmVUbyh0aGlzLngsIHRoaXMubGF5b3V0LmhlaWdodCk7XG4gICAgICBjdHguc3Ryb2tlKCk7XG4gICAgICBjdHgucmVzdG9yZSgpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJoaWRlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGhpZGUoKSB7XG4gICAgICB0aGlzLnZpc2libGUgPSBmYWxzZTtcbiAgICAgIHRoaXMueCA9IHVuZGVmaW5lZDtcbiAgICAgIHRoaXMueSA9IHVuZGVmaW5lZDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwidmlzaWJsZVwiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIHRoaXMuX3Zpc2libGU7XG4gICAgfSxcbiAgICBzZXQ6IGZ1bmN0aW9uIHNldCh2YWwpIHtcbiAgICAgIHRoaXMuX3Zpc2libGUgPSB2YWw7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIENyb3NzaGFpcjtcbn0oKTtcblxuXG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9ub2RlX21vZHVsZXMvYmFiZWwtbG9hZGVyL2xpYi9pbmRleC5qcyEuL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9pbmRleC5qcz8/dnVlLWxvYWRlci1vcHRpb25zIS4vc3JjL2NvbXBvbmVudHMvQ3Jvc3NoYWlyLnZ1ZT92dWUmdHlwZT1zY3JpcHQmbGFuZz1qcyZcblxuXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIGNvbnN0IENyb3NzaGFpcnZ1ZV90eXBlX3NjcmlwdF9sYW5nX2pzXyA9ICh7XG4gIG5hbWU6ICdDcm9zc2hhaXInLFxuICBwcm9wczogWydjdXJzb3InLCAnY29sb3JzJywgJ2xheW91dCcsICdzdWInXSxcbiAgbWV0aG9kczoge1xuICAgIGNyZWF0ZTogZnVuY3Rpb24gY3JlYXRlKCkge1xuICAgICAgdGhpcy5jaCA9IG5ldyBDcm9zc2hhaXIodGhpcyk7IC8vIE5ldyBncmlkIG92ZXJsYXktcmVuZGVyZXIgZGVzY3JpcHRvci5cbiAgICAgIC8vIFNob3VsZCBpbXBsZW1lbnQgZHJhdygpIChzZWUgU3BsaW5lLnZ1ZSlcblxuICAgICAgdGhpcy4kZW1pdCgnbmV3LWdyaWQtbGF5ZXInLCB7XG4gICAgICAgIG5hbWU6ICdjcm9zc2hhaXInLFxuICAgICAgICByZW5kZXJlcjogdGhpcy5jaFxuICAgICAgfSk7XG4gICAgfVxuICB9LFxuICB3YXRjaDoge1xuICAgIGN1cnNvcjoge1xuICAgICAgaGFuZGxlcjogZnVuY3Rpb24gaGFuZGxlcigpIHtcbiAgICAgICAgaWYgKCF0aGlzLmNoKSB0aGlzLmNyZWF0ZSgpOyAvLyBFeHBsb3JlID0gZGVmYXVsdCBtb2RlIG9uIG1vYmlsZVxuXG4gICAgICAgIHZhciBjdXJzb3IgPSB0aGlzLiRwcm9wcy5jdXJzb3I7XG4gICAgICAgIHZhciBleHBsb3JlID0gY3Vyc29yLm1vZGUgPT09ICdleHBsb3JlJztcblxuICAgICAgICBpZiAoIWN1cnNvci54IHx8ICFjdXJzb3IueSkge1xuICAgICAgICAgIHRoaXMuY2guaGlkZSgpO1xuICAgICAgICAgIHRoaXMuJGVtaXQoJ3JlZHJhdy1ncmlkJyk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5jaC52aXNpYmxlID0gIWV4cGxvcmU7XG4gICAgICB9LFxuICAgICAgZGVlcDogdHJ1ZVxuICAgIH1cbiAgfSxcbiAgcmVuZGVyOiBmdW5jdGlvbiByZW5kZXIoaCkge1xuICAgIHJldHVybiBoKCk7XG4gIH1cbn0pO1xuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL2NvbXBvbmVudHMvQ3Jvc3NoYWlyLnZ1ZT92dWUmdHlwZT1zY3JpcHQmbGFuZz1qcyZcbiAvKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIGNvbnN0IGNvbXBvbmVudHNfQ3Jvc3NoYWlydnVlX3R5cGVfc2NyaXB0X2xhbmdfanNfID0gKENyb3NzaGFpcnZ1ZV90eXBlX3NjcmlwdF9sYW5nX2pzXyk7IFxuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3J1bnRpbWUvY29tcG9uZW50Tm9ybWFsaXplci5qc1xuLyogZ2xvYmFscyBfX1ZVRV9TU1JfQ09OVEVYVF9fICovXG5cbi8vIElNUE9SVEFOVDogRG8gTk9UIHVzZSBFUzIwMTUgZmVhdHVyZXMgaW4gdGhpcyBmaWxlIChleGNlcHQgZm9yIG1vZHVsZXMpLlxuLy8gVGhpcyBtb2R1bGUgaXMgYSBydW50aW1lIHV0aWxpdHkgZm9yIGNsZWFuZXIgY29tcG9uZW50IG1vZHVsZSBvdXRwdXQgYW5kIHdpbGxcbi8vIGJlIGluY2x1ZGVkIGluIHRoZSBmaW5hbCB3ZWJwYWNrIHVzZXIgYnVuZGxlLlxuXG5mdW5jdGlvbiBub3JtYWxpemVDb21wb25lbnQgKFxuICBzY3JpcHRFeHBvcnRzLFxuICByZW5kZXIsXG4gIHN0YXRpY1JlbmRlckZucyxcbiAgZnVuY3Rpb25hbFRlbXBsYXRlLFxuICBpbmplY3RTdHlsZXMsXG4gIHNjb3BlSWQsXG4gIG1vZHVsZUlkZW50aWZpZXIsIC8qIHNlcnZlciBvbmx5ICovXG4gIHNoYWRvd01vZGUgLyogdnVlLWNsaSBvbmx5ICovXG4pIHtcbiAgLy8gVnVlLmV4dGVuZCBjb25zdHJ1Y3RvciBleHBvcnQgaW50ZXJvcFxuICB2YXIgb3B0aW9ucyA9IHR5cGVvZiBzY3JpcHRFeHBvcnRzID09PSAnZnVuY3Rpb24nXG4gICAgPyBzY3JpcHRFeHBvcnRzLm9wdGlvbnNcbiAgICA6IHNjcmlwdEV4cG9ydHNcblxuICAvLyByZW5kZXIgZnVuY3Rpb25zXG4gIGlmIChyZW5kZXIpIHtcbiAgICBvcHRpb25zLnJlbmRlciA9IHJlbmRlclxuICAgIG9wdGlvbnMuc3RhdGljUmVuZGVyRm5zID0gc3RhdGljUmVuZGVyRm5zXG4gICAgb3B0aW9ucy5fY29tcGlsZWQgPSB0cnVlXG4gIH1cblxuICAvLyBmdW5jdGlvbmFsIHRlbXBsYXRlXG4gIGlmIChmdW5jdGlvbmFsVGVtcGxhdGUpIHtcbiAgICBvcHRpb25zLmZ1bmN0aW9uYWwgPSB0cnVlXG4gIH1cblxuICAvLyBzY29wZWRJZFxuICBpZiAoc2NvcGVJZCkge1xuICAgIG9wdGlvbnMuX3Njb3BlSWQgPSAnZGF0YS12LScgKyBzY29wZUlkXG4gIH1cblxuICB2YXIgaG9va1xuICBpZiAobW9kdWxlSWRlbnRpZmllcikgeyAvLyBzZXJ2ZXIgYnVpbGRcbiAgICBob29rID0gZnVuY3Rpb24gKGNvbnRleHQpIHtcbiAgICAgIC8vIDIuMyBpbmplY3Rpb25cbiAgICAgIGNvbnRleHQgPVxuICAgICAgICBjb250ZXh0IHx8IC8vIGNhY2hlZCBjYWxsXG4gICAgICAgICh0aGlzLiR2bm9kZSAmJiB0aGlzLiR2bm9kZS5zc3JDb250ZXh0KSB8fCAvLyBzdGF0ZWZ1bFxuICAgICAgICAodGhpcy5wYXJlbnQgJiYgdGhpcy5wYXJlbnQuJHZub2RlICYmIHRoaXMucGFyZW50LiR2bm9kZS5zc3JDb250ZXh0KSAvLyBmdW5jdGlvbmFsXG4gICAgICAvLyAyLjIgd2l0aCBydW5Jbk5ld0NvbnRleHQ6IHRydWVcbiAgICAgIGlmICghY29udGV4dCAmJiB0eXBlb2YgX19WVUVfU1NSX0NPTlRFWFRfXyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgY29udGV4dCA9IF9fVlVFX1NTUl9DT05URVhUX19cbiAgICAgIH1cbiAgICAgIC8vIGluamVjdCBjb21wb25lbnQgc3R5bGVzXG4gICAgICBpZiAoaW5qZWN0U3R5bGVzKSB7XG4gICAgICAgIGluamVjdFN0eWxlcy5jYWxsKHRoaXMsIGNvbnRleHQpXG4gICAgICB9XG4gICAgICAvLyByZWdpc3RlciBjb21wb25lbnQgbW9kdWxlIGlkZW50aWZpZXIgZm9yIGFzeW5jIGNodW5rIGluZmVycmVuY2VcbiAgICAgIGlmIChjb250ZXh0ICYmIGNvbnRleHQuX3JlZ2lzdGVyZWRDb21wb25lbnRzKSB7XG4gICAgICAgIGNvbnRleHQuX3JlZ2lzdGVyZWRDb21wb25lbnRzLmFkZChtb2R1bGVJZGVudGlmaWVyKVxuICAgICAgfVxuICAgIH1cbiAgICAvLyB1c2VkIGJ5IHNzciBpbiBjYXNlIGNvbXBvbmVudCBpcyBjYWNoZWQgYW5kIGJlZm9yZUNyZWF0ZVxuICAgIC8vIG5ldmVyIGdldHMgY2FsbGVkXG4gICAgb3B0aW9ucy5fc3NyUmVnaXN0ZXIgPSBob29rXG4gIH0gZWxzZSBpZiAoaW5qZWN0U3R5bGVzKSB7XG4gICAgaG9vayA9IHNoYWRvd01vZGVcbiAgICAgID8gZnVuY3Rpb24gKCkge1xuICAgICAgICBpbmplY3RTdHlsZXMuY2FsbChcbiAgICAgICAgICB0aGlzLFxuICAgICAgICAgIChvcHRpb25zLmZ1bmN0aW9uYWwgPyB0aGlzLnBhcmVudCA6IHRoaXMpLiRyb290LiRvcHRpb25zLnNoYWRvd1Jvb3RcbiAgICAgICAgKVxuICAgICAgfVxuICAgICAgOiBpbmplY3RTdHlsZXNcbiAgfVxuXG4gIGlmIChob29rKSB7XG4gICAgaWYgKG9wdGlvbnMuZnVuY3Rpb25hbCkge1xuICAgICAgLy8gZm9yIHRlbXBsYXRlLW9ubHkgaG90LXJlbG9hZCBiZWNhdXNlIGluIHRoYXQgY2FzZSB0aGUgcmVuZGVyIGZuIGRvZXNuJ3RcbiAgICAgIC8vIGdvIHRocm91Z2ggdGhlIG5vcm1hbGl6ZXJcbiAgICAgIG9wdGlvbnMuX2luamVjdFN0eWxlcyA9IGhvb2tcbiAgICAgIC8vIHJlZ2lzdGVyIGZvciBmdW5jdGlvbmFsIGNvbXBvbmVudCBpbiB2dWUgZmlsZVxuICAgICAgdmFyIG9yaWdpbmFsUmVuZGVyID0gb3B0aW9ucy5yZW5kZXJcbiAgICAgIG9wdGlvbnMucmVuZGVyID0gZnVuY3Rpb24gcmVuZGVyV2l0aFN0eWxlSW5qZWN0aW9uIChoLCBjb250ZXh0KSB7XG4gICAgICAgIGhvb2suY2FsbChjb250ZXh0KVxuICAgICAgICByZXR1cm4gb3JpZ2luYWxSZW5kZXIoaCwgY29udGV4dClcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gaW5qZWN0IGNvbXBvbmVudCByZWdpc3RyYXRpb24gYXMgYmVmb3JlQ3JlYXRlIGhvb2tcbiAgICAgIHZhciBleGlzdGluZyA9IG9wdGlvbnMuYmVmb3JlQ3JlYXRlXG4gICAgICBvcHRpb25zLmJlZm9yZUNyZWF0ZSA9IGV4aXN0aW5nXG4gICAgICAgID8gW10uY29uY2F0KGV4aXN0aW5nLCBob29rKVxuICAgICAgICA6IFtob29rXVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiB7XG4gICAgZXhwb3J0czogc2NyaXB0RXhwb3J0cyxcbiAgICBvcHRpb25zOiBvcHRpb25zXG4gIH1cbn1cblxuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL2NvbXBvbmVudHMvQ3Jvc3NoYWlyLnZ1ZVxudmFyIENyb3NzaGFpcl9yZW5kZXIsIENyb3NzaGFpcl9zdGF0aWNSZW5kZXJGbnNcbjtcblxuXG5cbi8qIG5vcm1hbGl6ZSBjb21wb25lbnQgKi9cbjtcbnZhciBjb21wb25lbnQgPSBub3JtYWxpemVDb21wb25lbnQoXG4gIGNvbXBvbmVudHNfQ3Jvc3NoYWlydnVlX3R5cGVfc2NyaXB0X2xhbmdfanNfLFxuICBDcm9zc2hhaXJfcmVuZGVyLFxuICBDcm9zc2hhaXJfc3RhdGljUmVuZGVyRm5zLFxuICBmYWxzZSxcbiAgbnVsbCxcbiAgbnVsbCxcbiAgbnVsbFxuICBcbilcblxuLyogaG90IHJlbG9hZCAqL1xuaWYgKGZhbHNlKSB7IHZhciBhcGk7IH1cbmNvbXBvbmVudC5vcHRpb25zLl9fZmlsZSA9IFwic3JjL2NvbXBvbmVudHMvQ3Jvc3NoYWlyLnZ1ZVwiXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIGNvbnN0IGNvbXBvbmVudHNfQ3Jvc3NoYWlyID0gKGNvbXBvbmVudC5leHBvcnRzKTtcbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL25vZGVfbW9kdWxlcy9iYWJlbC1sb2FkZXIvbGliL2luZGV4LmpzIS4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL2luZGV4LmpzPz92dWUtbG9hZGVyLW9wdGlvbnMhLi9zcmMvY29tcG9uZW50cy9LZXlib2FyZExpc3RlbmVyLnZ1ZT92dWUmdHlwZT1zY3JpcHQmbGFuZz1qcyZcbi8vXG4vL1xuLy9cbi8vXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIGNvbnN0IEtleWJvYXJkTGlzdGVuZXJ2dWVfdHlwZV9zY3JpcHRfbGFuZ19qc18gPSAoe1xuICBuYW1lOiAnS2V5Ym9hcmRMaXN0ZW5lcicsXG4gIHJlbmRlcjogZnVuY3Rpb24gcmVuZGVyKGgpIHtcbiAgICByZXR1cm4gaCgpO1xuICB9LFxuICBjcmVhdGVkOiBmdW5jdGlvbiBjcmVhdGVkKCkge1xuICAgIHRoaXMuJGVtaXQoJ3JlZ2lzdGVyLWtiLWxpc3RlbmVyJywge1xuICAgICAgaWQ6IHRoaXMuX3VpZCxcbiAgICAgIGtleWRvd246IHRoaXMua2V5ZG93bixcbiAgICAgIGtleXVwOiB0aGlzLmtleXVwLFxuICAgICAga2V5cHJlc3M6IHRoaXMua2V5cHJlc3NcbiAgICB9KTtcbiAgfSxcbiAgYmVmb3JlRGVzdHJveTogZnVuY3Rpb24gYmVmb3JlRGVzdHJveSgpIHtcbiAgICB0aGlzLiRlbWl0KCdyZW1vdmUta2ItbGlzdGVuZXInLCB7XG4gICAgICBpZDogdGhpcy5fdWlkXG4gICAgfSk7XG4gIH0sXG4gIG1ldGhvZHM6IHtcbiAgICBrZXlkb3duOiBmdW5jdGlvbiBrZXlkb3duKGV2ZW50KSB7XG4gICAgICB0aGlzLiRlbWl0KCdrZXlkb3duJywgZXZlbnQpO1xuICAgIH0sXG4gICAga2V5dXA6IGZ1bmN0aW9uIGtleXVwKGV2ZW50KSB7XG4gICAgICB0aGlzLiRlbWl0KCdrZXl1cCcsIGV2ZW50KTtcbiAgICB9LFxuICAgIGtleXByZXNzOiBmdW5jdGlvbiBrZXlwcmVzcyhldmVudCkge1xuICAgICAgdGhpcy4kZW1pdCgna2V5cHJlc3MnLCBldmVudCk7XG4gICAgfVxuICB9XG59KTtcbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9jb21wb25lbnRzL0tleWJvYXJkTGlzdGVuZXIudnVlP3Z1ZSZ0eXBlPXNjcmlwdCZsYW5nPWpzJlxuIC8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gY29uc3QgY29tcG9uZW50c19LZXlib2FyZExpc3RlbmVydnVlX3R5cGVfc2NyaXB0X2xhbmdfanNfID0gKEtleWJvYXJkTGlzdGVuZXJ2dWVfdHlwZV9zY3JpcHRfbGFuZ19qc18pOyBcbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9jb21wb25lbnRzL0tleWJvYXJkTGlzdGVuZXIudnVlXG52YXIgS2V5Ym9hcmRMaXN0ZW5lcl9yZW5kZXIsIEtleWJvYXJkTGlzdGVuZXJfc3RhdGljUmVuZGVyRm5zXG47XG5cblxuXG4vKiBub3JtYWxpemUgY29tcG9uZW50ICovXG47XG52YXIgS2V5Ym9hcmRMaXN0ZW5lcl9jb21wb25lbnQgPSBub3JtYWxpemVDb21wb25lbnQoXG4gIGNvbXBvbmVudHNfS2V5Ym9hcmRMaXN0ZW5lcnZ1ZV90eXBlX3NjcmlwdF9sYW5nX2pzXyxcbiAgS2V5Ym9hcmRMaXN0ZW5lcl9yZW5kZXIsXG4gIEtleWJvYXJkTGlzdGVuZXJfc3RhdGljUmVuZGVyRm5zLFxuICBmYWxzZSxcbiAgbnVsbCxcbiAgbnVsbCxcbiAgbnVsbFxuICBcbilcblxuLyogaG90IHJlbG9hZCAqL1xuaWYgKGZhbHNlKSB7IHZhciBLZXlib2FyZExpc3RlbmVyX2FwaTsgfVxuS2V5Ym9hcmRMaXN0ZW5lcl9jb21wb25lbnQub3B0aW9ucy5fX2ZpbGUgPSBcInNyYy9jb21wb25lbnRzL0tleWJvYXJkTGlzdGVuZXIudnVlXCJcbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gY29uc3QgS2V5Ym9hcmRMaXN0ZW5lciA9IChLZXlib2FyZExpc3RlbmVyX2NvbXBvbmVudC5leHBvcnRzKTtcbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9sb2FkZXJzL3RlbXBsYXRlTG9hZGVyLmpzPz92dWUtbG9hZGVyLW9wdGlvbnMhLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvaW5kZXguanM/P3Z1ZS1sb2FkZXItb3B0aW9ucyEuL3NyYy9jb21wb25lbnRzL1V4TGF5ZXIudnVlP3Z1ZSZ0eXBlPXRlbXBsYXRlJmlkPTM5MGNjZjZlJlxudmFyIFV4TGF5ZXJ2dWVfdHlwZV90ZW1wbGF0ZV9pZF8zOTBjY2Y2ZV9yZW5kZXIgPSBmdW5jdGlvbigpIHtcbiAgdmFyIF92bSA9IHRoaXNcbiAgdmFyIF9oID0gX3ZtLiRjcmVhdGVFbGVtZW50XG4gIHZhciBfYyA9IF92bS5fc2VsZi5fYyB8fCBfaFxuICByZXR1cm4gX2MoXG4gICAgXCJzcGFuXCIsXG4gICAgeyBjbGFzczogXCJ0cmFkaW5nLXZ1ZS1ncmlkLXV4LVwiICsgX3ZtLmlkLCBzdHlsZTogX3ZtLnN0eWxlIH0sXG4gICAgX3ZtLl9sKF92bS51eHMsIGZ1bmN0aW9uKHV4KSB7XG4gICAgICByZXR1cm4gX2MoXCJ1eC13cmFwcGVyXCIsIHtcbiAgICAgICAga2V5OiB1eC51dWlkLFxuICAgICAgICBhdHRyczoge1xuICAgICAgICAgIHV4OiB1eCxcbiAgICAgICAgICB1cGRhdGVyOiBfdm0udXBkYXRlcixcbiAgICAgICAgICBjb2xvcnM6IF92bS5jb2xvcnMsXG4gICAgICAgICAgY29uZmlnOiBfdm0uY29uZmlnXG4gICAgICAgIH0sXG4gICAgICAgIG9uOiB7IFwiY3VzdG9tLWV2ZW50XCI6IF92bS5vbl9jdXN0b21fZXZlbnQgfVxuICAgICAgfSlcbiAgICB9KSxcbiAgICAxXG4gIClcbn1cbnZhciBVeExheWVydnVlX3R5cGVfdGVtcGxhdGVfaWRfMzkwY2NmNmVfc3RhdGljUmVuZGVyRm5zID0gW11cblV4TGF5ZXJ2dWVfdHlwZV90ZW1wbGF0ZV9pZF8zOTBjY2Y2ZV9yZW5kZXIuX3dpdGhTdHJpcHBlZCA9IHRydWVcblxuXG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvY29tcG9uZW50cy9VeExheWVyLnZ1ZT92dWUmdHlwZT10ZW1wbGF0ZSZpZD0zOTBjY2Y2ZSZcblxuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL2xvYWRlcnMvdGVtcGxhdGVMb2FkZXIuanM/P3Z1ZS1sb2FkZXItb3B0aW9ucyEuL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9pbmRleC5qcz8/dnVlLWxvYWRlci1vcHRpb25zIS4vc3JjL2NvbXBvbmVudHMvVXhXcmFwcGVyLnZ1ZT92dWUmdHlwZT10ZW1wbGF0ZSZpZD00YmMzMjA3MCZcbnZhciBVeFdyYXBwZXJ2dWVfdHlwZV90ZW1wbGF0ZV9pZF80YmMzMjA3MF9yZW5kZXIgPSBmdW5jdGlvbigpIHtcbiAgdmFyIF92bSA9IHRoaXNcbiAgdmFyIF9oID0gX3ZtLiRjcmVhdGVFbGVtZW50XG4gIHZhciBfYyA9IF92bS5fc2VsZi5fYyB8fCBfaFxuICByZXR1cm4gX3ZtLnZpc2libGVcbiAgICA/IF9jKFxuICAgICAgICBcImRpdlwiLFxuICAgICAgICB7XG4gICAgICAgICAgc3RhdGljQ2xhc3M6IFwidHJhZGluZy12dWUtdXgtd3JhcHBlclwiLFxuICAgICAgICAgIHN0eWxlOiBfdm0uc3R5bGUsXG4gICAgICAgICAgYXR0cnM6IHsgaWQ6IFwidHZqcy11eC13cmFwcGVyLVwiICsgX3ZtLnV4LnV1aWQgfVxuICAgICAgICB9LFxuICAgICAgICBbXG4gICAgICAgICAgX2MoX3ZtLnV4LmNvbXBvbmVudCwge1xuICAgICAgICAgICAgdGFnOiBcImNvbXBvbmVudFwiLFxuICAgICAgICAgICAgYXR0cnM6IHtcbiAgICAgICAgICAgICAgdXg6IF92bS51eCxcbiAgICAgICAgICAgICAgdXBkYXRlcjogX3ZtLnVwZGF0ZXIsXG4gICAgICAgICAgICAgIHdyYXBwZXI6IF92bS53cmFwcGVyLFxuICAgICAgICAgICAgICBjb2xvcnM6IF92bS5jb2xvcnNcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBvbjogeyBcImN1c3RvbS1ldmVudFwiOiBfdm0ub25fY3VzdG9tX2V2ZW50IH1cbiAgICAgICAgICB9KSxcbiAgICAgICAgICBfdm0uX3YoXCIgXCIpLFxuICAgICAgICAgIF92bS51eC5zaG93X3BpblxuICAgICAgICAgICAgPyBfYyhcImRpdlwiLCB7XG4gICAgICAgICAgICAgICAgc3RhdGljQ2xhc3M6IFwidHZqcy11eC13cmFwcGVyLXBpblwiLFxuICAgICAgICAgICAgICAgIHN0eWxlOiBfdm0ucGluX3N0eWxlXG4gICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICA6IF92bS5fZSgpLFxuICAgICAgICAgIF92bS5fdihcIiBcIiksXG4gICAgICAgICAgX3ZtLnV4Lndpbl9oZWFkZXIgIT09IGZhbHNlXG4gICAgICAgICAgICA/IF9jKFwiZGl2XCIsIHsgc3RhdGljQ2xhc3M6IFwidHZqcy11eC13cmFwcGVyLWhlYWRcIiB9LCBbXG4gICAgICAgICAgICAgICAgX2MoXG4gICAgICAgICAgICAgICAgICBcImRpdlwiLFxuICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBzdGF0aWNDbGFzczogXCJ0dmpzLXV4LXdyYXBwZXItY2xvc2VcIixcbiAgICAgICAgICAgICAgICAgICAgc3R5bGU6IF92bS5idG5fc3R5bGUsXG4gICAgICAgICAgICAgICAgICAgIG9uOiB7IGNsaWNrOiBfdm0uY2xvc2UgfVxuICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgIFtfdm0uX3YoXCLDl1wiKV1cbiAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgIF0pXG4gICAgICAgICAgICA6IF92bS5fZSgpXG4gICAgICAgIF0sXG4gICAgICAgIDFcbiAgICAgIClcbiAgICA6IF92bS5fZSgpXG59XG52YXIgVXhXcmFwcGVydnVlX3R5cGVfdGVtcGxhdGVfaWRfNGJjMzIwNzBfc3RhdGljUmVuZGVyRm5zID0gW11cblV4V3JhcHBlcnZ1ZV90eXBlX3RlbXBsYXRlX2lkXzRiYzMyMDcwX3JlbmRlci5fd2l0aFN0cmlwcGVkID0gdHJ1ZVxuXG5cbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9jb21wb25lbnRzL1V4V3JhcHBlci52dWU/dnVlJnR5cGU9dGVtcGxhdGUmaWQ9NGJjMzIwNzAmXG5cbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL25vZGVfbW9kdWxlcy9iYWJlbC1sb2FkZXIvbGliL2luZGV4LmpzIS4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL2luZGV4LmpzPz92dWUtbG9hZGVyLW9wdGlvbnMhLi9zcmMvY29tcG9uZW50cy9VeFdyYXBwZXIudnVlP3Z1ZSZ0eXBlPXNjcmlwdCZsYW5nPWpzJlxuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG5cbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gY29uc3QgVXhXcmFwcGVydnVlX3R5cGVfc2NyaXB0X2xhbmdfanNfID0gKHtcbiAgbmFtZTogJ1V4V3JhcHBlcicsXG4gIHByb3BzOiBbJ3V4JywgJ3VwZGF0ZXInLCAnY29sb3JzJywgJ2NvbmZpZyddLFxuICBtb3VudGVkOiBmdW5jdGlvbiBtb3VudGVkKCkge1xuICAgIHRoaXMuc2VsZiA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKHRoaXMudXVpZCk7XG4gICAgdGhpcy53ID0gdGhpcy5zZWxmLm9mZnNldFdpZHRoOyAvLyBUT0RPOiA9PiB3aWR0aDogXCJjb250ZW50XCJcblxuICAgIHRoaXMuaCA9IHRoaXMuc2VsZi5vZmZzZXRIZWlnaHQ7IC8vIFRPRE86ID0+IGhlaWdodDogXCJjb250ZW50XCJcblxuICAgIHRoaXMudXBkYXRlX3Bvc2l0aW9uKCk7XG4gIH0sXG4gIGNyZWF0ZWQ6IGZ1bmN0aW9uIGNyZWF0ZWQoKSB7XG4gICAgdGhpcy5tb3VzZS5vbignbW91c2Vtb3ZlJywgdGhpcy5tb3VzZW1vdmUpO1xuICAgIHRoaXMubW91c2Uub24oJ21vdXNlb3V0JywgdGhpcy5tb3VzZW91dCk7XG4gIH0sXG4gIGJlZm9yZURlc3Ryb3k6IGZ1bmN0aW9uIGJlZm9yZURlc3Ryb3koKSB7XG4gICAgdGhpcy5tb3VzZS5vZmYoJ21vdXNlbW92ZScsIHRoaXMubW91c2Vtb3ZlKTtcbiAgICB0aGlzLm1vdXNlLm9mZignbW91c2VvdXQnLCB0aGlzLm1vdXNlb3V0KTtcbiAgfSxcbiAgbWV0aG9kczoge1xuICAgIHVwZGF0ZV9wb3NpdGlvbjogZnVuY3Rpb24gdXBkYXRlX3Bvc2l0aW9uKCkge1xuICAgICAgaWYgKHRoaXMudXhyLmhpZGRlbikgcmV0dXJuO1xuICAgICAgdmFyIGx3ID0gdGhpcy5sYXlvdXQud2lkdGg7XG4gICAgICB2YXIgbGggPSB0aGlzLmxheW91dC5oZWlnaHQ7XG4gICAgICB2YXIgcGluID0gdGhpcy51eHIucGluO1xuXG4gICAgICBzd2l0Y2ggKHBpblswXSkge1xuICAgICAgICBjYXNlICdjdXJzb3InOlxuICAgICAgICAgIHZhciB4ID0gdGhpcy51eHIub3ZlcmxheS5jdXJzb3IueDtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlICdtb3VzZSc6XG4gICAgICAgICAgeCA9IHRoaXMubW91c2UueDtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIGlmICh0eXBlb2YgcGluWzBdID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgeCA9IHRoaXMucGFyc2VfY29vcmQocGluWzBdLCBsdyk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHggPSB0aGlzLmxheW91dC50MnNjcmVlbihwaW5bMF0pO1xuICAgICAgICAgIH1cblxuICAgICAgfVxuXG4gICAgICBzd2l0Y2ggKHBpblsxXSkge1xuICAgICAgICBjYXNlICdjdXJzb3InOlxuICAgICAgICAgIHZhciB5ID0gdGhpcy51eHIub3ZlcmxheS5jdXJzb3IueTtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlICdtb3VzZSc6XG4gICAgICAgICAgeSA9IHRoaXMubW91c2UueTtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIGlmICh0eXBlb2YgcGluWzFdID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgeSA9IHRoaXMucGFyc2VfY29vcmQocGluWzFdLCBsaCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHkgPSB0aGlzLmxheW91dC4kMnNjcmVlbihwaW5bMV0pO1xuICAgICAgICAgIH1cblxuICAgICAgfVxuXG4gICAgICB0aGlzLnggPSB4ICsgdGhpcy5veDtcbiAgICAgIHRoaXMueSA9IHkgKyB0aGlzLm95O1xuICAgIH0sXG4gICAgcGFyc2VfY29vcmQ6IGZ1bmN0aW9uIHBhcnNlX2Nvb3JkKHN0ciwgc2NhbGUpIHtcbiAgICAgIHN0ciA9IHN0ci50cmltKCk7XG4gICAgICBpZiAoc3RyID09PSAnMCcgfHwgc3RyID09PSAnJykgcmV0dXJuIDA7XG4gICAgICB2YXIgcGx1cyA9IHN0ci5zcGxpdCgnKycpO1xuXG4gICAgICBpZiAocGx1cy5sZW5ndGggPT09IDIpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VfY29vcmQocGx1c1swXSwgc2NhbGUpICsgdGhpcy5wYXJzZV9jb29yZChwbHVzWzFdLCBzY2FsZSk7XG4gICAgICB9XG5cbiAgICAgIHZhciBtaW51cyA9IHN0ci5zcGxpdCgnLScpO1xuXG4gICAgICBpZiAobWludXMubGVuZ3RoID09PSAyKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnBhcnNlX2Nvb3JkKG1pbnVzWzBdLCBzY2FsZSkgLSB0aGlzLnBhcnNlX2Nvb3JkKG1pbnVzWzFdLCBzY2FsZSk7XG4gICAgICB9XG5cbiAgICAgIHZhciBwZXIgPSBzdHIuc3BsaXQoJyUnKTtcblxuICAgICAgaWYgKHBlci5sZW5ndGggPT09IDIpIHtcbiAgICAgICAgcmV0dXJuIHNjYWxlICogcGFyc2VJbnQocGVyWzBdKSAvIDEwMDtcbiAgICAgIH1cblxuICAgICAgdmFyIHB4ID0gc3RyLnNwbGl0KCdweCcpO1xuXG4gICAgICBpZiAocHgubGVuZ3RoID09PSAyKSB7XG4gICAgICAgIHJldHVybiBwYXJzZUludChweFswXSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfSxcbiAgICBtb3VzZW1vdmU6IGZ1bmN0aW9uIG1vdXNlbW92ZSgpIHtcbiAgICAgIHRoaXMudXBkYXRlX3Bvc2l0aW9uKCk7XG4gICAgICB0aGlzLnZpc2libGUgPSB0cnVlO1xuICAgIH0sXG4gICAgbW91c2VvdXQ6IGZ1bmN0aW9uIG1vdXNlb3V0KCkge1xuICAgICAgaWYgKHRoaXMudXhyLnBpbi5pbmNsdWRlcygnY3Vyc29yJykgfHwgdGhpcy51eHIucGluLmluY2x1ZGVzKCdtb3VzZScpKSB0aGlzLnZpc2libGUgPSBmYWxzZTtcbiAgICB9LFxuICAgIG9uX2N1c3RvbV9ldmVudDogZnVuY3Rpb24gb25fY3VzdG9tX2V2ZW50KGV2ZW50KSB7XG4gICAgICB0aGlzLiRlbWl0KCdjdXN0b20tZXZlbnQnLCBldmVudCk7XG5cbiAgICAgIGlmIChldmVudC5ldmVudCA9PT0gJ21vZGlmeS1pbnRlcmZhY2UnKSB7XG4gICAgICAgIGlmICh0aGlzLnNlbGYpIHtcbiAgICAgICAgICB0aGlzLncgPSB0aGlzLnNlbGYub2Zmc2V0V2lkdGg7XG4gICAgICAgICAgdGhpcy5oID0gdGhpcy5zZWxmLm9mZnNldEhlaWdodDtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMudXBkYXRlX3Bvc2l0aW9uKCk7XG4gICAgICB9XG4gICAgfSxcbiAgICBjbG9zZTogZnVuY3Rpb24gY2xvc2UoKSB7XG4gICAgICB0aGlzLiRlbWl0KCdjdXN0b20tZXZlbnQnLCB7XG4gICAgICAgIGV2ZW50OiAnY2xvc2UtaW50ZXJmYWNlJyxcbiAgICAgICAgYXJnczogW3RoaXMuJHByb3BzLnV4LnV1aWRdXG4gICAgICB9KTtcbiAgICB9XG4gIH0sXG4gIGNvbXB1dGVkOiB7XG4gICAgdXhyOiBmdW5jdGlvbiB1eHIoKSB7XG4gICAgICByZXR1cm4gdGhpcy4kcHJvcHMudXg7IC8vIGp1c3QgYSByZWZcbiAgICB9LFxuICAgIGxheW91dDogZnVuY3Rpb24gbGF5b3V0KCkge1xuICAgICAgcmV0dXJuIHRoaXMuJHByb3BzLnV4Lm92ZXJsYXkubGF5b3V0O1xuICAgIH0sXG4gICAgc2V0dGluZ3M6IGZ1bmN0aW9uIHNldHRpbmdzKCkge1xuICAgICAgcmV0dXJuIHRoaXMuJHByb3BzLnV4Lm92ZXJsYXkuc2V0dGluZ3M7XG4gICAgfSxcbiAgICB1dWlkOiBmdW5jdGlvbiB1dWlkKCkge1xuICAgICAgcmV0dXJuIFwidHZqcy11eC13cmFwcGVyLVwiLmNvbmNhdCh0aGlzLnV4ci51dWlkKTtcbiAgICB9LFxuICAgIG1vdXNlOiBmdW5jdGlvbiBtb3VzZSgpIHtcbiAgICAgIHJldHVybiB0aGlzLnV4ci5vdmVybGF5Lm1vdXNlO1xuICAgIH0sXG4gICAgc3R5bGU6IGZ1bmN0aW9uIHN0eWxlKCkge1xuICAgICAgdmFyIHN0ID0ge1xuICAgICAgICAnZGlzcGxheSc6IHRoaXMudXhyLmhpZGRlbiA/ICdub25lJyA6IHVuZGVmaW5lZCxcbiAgICAgICAgJ2xlZnQnOiBcIlwiLmNvbmNhdCh0aGlzLngsIFwicHhcIiksXG4gICAgICAgICd0b3AnOiBcIlwiLmNvbmNhdCh0aGlzLnksIFwicHhcIiksXG4gICAgICAgICdwb2ludGVyLWV2ZW50cyc6IHRoaXMudXhyLnBvaW50ZXJfZXZlbnRzIHx8ICdhbGwnLFxuICAgICAgICAnei1pbmRleCc6IHRoaXMuel9pbmRleFxuICAgICAgfTtcbiAgICAgIGlmICh0aGlzLnV4ci53aW5fc3R5bGluZyAhPT0gZmFsc2UpIHN0ID0gT2JqZWN0LmFzc2lnbihzdCwge1xuICAgICAgICAnYm9yZGVyJzogXCIxcHggc29saWQgXCIuY29uY2F0KHRoaXMuJHByb3BzLmNvbG9ycy5ncmlkKSxcbiAgICAgICAgJ2JvcmRlci1yYWRpdXMnOiAnM3B4JyxcbiAgICAgICAgJ2JhY2tncm91bmQnOiBcIlwiLmNvbmNhdCh0aGlzLmJhY2tncm91bmQpXG4gICAgICB9KTtcbiAgICAgIHJldHVybiBzdDtcbiAgICB9LFxuICAgIHBpbl9zdHlsZTogZnVuY3Rpb24gcGluX3N0eWxlKCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgJ2xlZnQnOiBcIlwiLmNvbmNhdCgtdGhpcy5veCwgXCJweFwiKSxcbiAgICAgICAgJ3RvcCc6IFwiXCIuY29uY2F0KC10aGlzLm95LCBcInB4XCIpLFxuICAgICAgICAnYmFja2dyb3VuZC1jb2xvcic6IHRoaXMudXhyLnBpbl9jb2xvclxuICAgICAgfTtcbiAgICB9LFxuICAgIGJ0bl9zdHlsZTogZnVuY3Rpb24gYnRuX3N0eWxlKCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgJ2JhY2tncm91bmQnOiBcIlwiLmNvbmNhdCh0aGlzLmluYWN0aXZlX2J0bl9jb2xvciksXG4gICAgICAgICdjb2xvcic6IFwiXCIuY29uY2F0KHRoaXMuaW5hY3RpdmVfYnRuX2NvbG9yKVxuICAgICAgfTtcbiAgICB9LFxuICAgIHBpbl9wb3M6IGZ1bmN0aW9uIHBpbl9wb3MoKSB7XG4gICAgICByZXR1cm4gdGhpcy51eHIucGluX3Bvc2l0aW9uID8gdGhpcy51eHIucGluX3Bvc2l0aW9uLnNwbGl0KCcsJykgOiBbJzAnLCAnMCddO1xuICAgIH0sXG4gICAgLy8gT2Zmc2V0IHhcbiAgICBveDogZnVuY3Rpb24gb3goKSB7XG4gICAgICBpZiAodGhpcy5waW5fcG9zLmxlbmd0aCAhPT0gMikgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgIHZhciB4ID0gdGhpcy5wYXJzZV9jb29yZCh0aGlzLnBpbl9wb3NbMF0sIHRoaXMudyk7XG4gICAgICByZXR1cm4gLXg7XG4gICAgfSxcbiAgICAvLyBPZmZzZXQgeVxuICAgIG95OiBmdW5jdGlvbiBveSgpIHtcbiAgICAgIGlmICh0aGlzLnBpbl9wb3MubGVuZ3RoICE9PSAyKSByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgdmFyIHkgPSB0aGlzLnBhcnNlX2Nvb3JkKHRoaXMucGluX3Bvc1sxXSwgdGhpcy5oKTtcbiAgICAgIHJldHVybiAteTtcbiAgICB9LFxuICAgIHpfaW5kZXg6IGZ1bmN0aW9uIHpfaW5kZXgoKSB7XG4gICAgICB2YXIgYmFzZV9pbmRleCA9IHRoaXMuc2V0dGluZ3NbJ3otaW5kZXgnXSB8fCB0aGlzLnNldHRpbmdzWyd6SW5kZXgnXSB8fCAwO1xuICAgICAgdmFyIHV4X2luZGV4ID0gdGhpcy51eHJbJ3pfaW5kZXgnXSB8fCAwO1xuICAgICAgcmV0dXJuIGJhc2VfaW5kZXggKyB1eF9pbmRleDtcbiAgICB9LFxuICAgIGJhY2tncm91bmQ6IGZ1bmN0aW9uIGJhY2tncm91bmQoKSB7XG4gICAgICB2YXIgYyA9IHRoaXMudXhyLmJhY2tncm91bmQgfHwgdGhpcy4kcHJvcHMuY29sb3JzLmJhY2s7XG4gICAgICByZXR1cm4gdXRpbHMuYXBwbHlfb3BhY2l0eShjLCB0aGlzLnV4ci5iYWNrZ3JvdW5kX29wYWNpdHkgfHwgdGhpcy4kcHJvcHMuY29uZmlnLlVYX09QQUNJVFkpO1xuICAgIH0sXG4gICAgaW5hY3RpdmVfYnRuX2NvbG9yOiBmdW5jdGlvbiBpbmFjdGl2ZV9idG5fY29sb3IoKSB7XG4gICAgICByZXR1cm4gdGhpcy51eHIuaW5hY3RpdmVfYnRuX2NvbG9yIHx8IHRoaXMuJHByb3BzLmNvbG9ycy5ncmlkO1xuICAgIH0sXG4gICAgd3JhcHBlcjogZnVuY3Rpb24gd3JhcHBlcigpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHg6IHRoaXMueCxcbiAgICAgICAgeTogdGhpcy55LFxuICAgICAgICBwaW5feDogdGhpcy54IC0gdGhpcy5veCxcbiAgICAgICAgcGluX3k6IHRoaXMueSAtIHRoaXMub3lcbiAgICAgIH07XG4gICAgfVxuICB9LFxuICB3YXRjaDoge1xuICAgIHVwZGF0ZXI6IGZ1bmN0aW9uIHVwZGF0ZXIoKSB7XG4gICAgICB0aGlzLnVwZGF0ZV9wb3NpdGlvbigpO1xuICAgIH1cbiAgfSxcbiAgZGF0YTogZnVuY3Rpb24gZGF0YSgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgeDogMCxcbiAgICAgIHk6IDAsXG4gICAgICB3OiAwLFxuICAgICAgaDogMCxcbiAgICAgIHZpc2libGU6IHRydWVcbiAgICB9O1xuICB9XG59KTtcbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9jb21wb25lbnRzL1V4V3JhcHBlci52dWU/dnVlJnR5cGU9c2NyaXB0Jmxhbmc9anMmXG4gLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyBjb25zdCBjb21wb25lbnRzX1V4V3JhcHBlcnZ1ZV90eXBlX3NjcmlwdF9sYW5nX2pzXyA9IChVeFdyYXBwZXJ2dWVfdHlwZV9zY3JpcHRfbGFuZ19qc18pOyBcbi8vIEVYVEVSTkFMIE1PRFVMRTogLi9ub2RlX21vZHVsZXMvdnVlLXN0eWxlLWxvYWRlci9pbmRleC5qcyEuL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2Rpc3QvY2pzLmpzIS4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL2xvYWRlcnMvc3R5bGVQb3N0TG9hZGVyLmpzIS4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL2luZGV4LmpzPz92dWUtbG9hZGVyLW9wdGlvbnMhLi9zcmMvY29tcG9uZW50cy9VeFdyYXBwZXIudnVlP3Z1ZSZ0eXBlPXN0eWxlJmluZGV4PTAmbGFuZz1jc3MmXG52YXIgVXhXcmFwcGVydnVlX3R5cGVfc3R5bGVfaW5kZXhfMF9sYW5nX2Nzc18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDU2NSk7XG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvY29tcG9uZW50cy9VeFdyYXBwZXIudnVlP3Z1ZSZ0eXBlPXN0eWxlJmluZGV4PTAmbGFuZz1jc3MmXG5cbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9jb21wb25lbnRzL1V4V3JhcHBlci52dWVcblxuXG5cbjtcblxuXG4vKiBub3JtYWxpemUgY29tcG9uZW50ICovXG5cbnZhciBVeFdyYXBwZXJfY29tcG9uZW50ID0gbm9ybWFsaXplQ29tcG9uZW50KFxuICBjb21wb25lbnRzX1V4V3JhcHBlcnZ1ZV90eXBlX3NjcmlwdF9sYW5nX2pzXyxcbiAgVXhXcmFwcGVydnVlX3R5cGVfdGVtcGxhdGVfaWRfNGJjMzIwNzBfcmVuZGVyLFxuICBVeFdyYXBwZXJ2dWVfdHlwZV90ZW1wbGF0ZV9pZF80YmMzMjA3MF9zdGF0aWNSZW5kZXJGbnMsXG4gIGZhbHNlLFxuICBudWxsLFxuICBudWxsLFxuICBudWxsXG4gIFxuKVxuXG4vKiBob3QgcmVsb2FkICovXG5pZiAoZmFsc2UpIHsgdmFyIFV4V3JhcHBlcl9hcGk7IH1cblV4V3JhcHBlcl9jb21wb25lbnQub3B0aW9ucy5fX2ZpbGUgPSBcInNyYy9jb21wb25lbnRzL1V4V3JhcHBlci52dWVcIlxuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyBjb25zdCBVeFdyYXBwZXIgPSAoVXhXcmFwcGVyX2NvbXBvbmVudC5leHBvcnRzKTtcbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL25vZGVfbW9kdWxlcy9iYWJlbC1sb2FkZXIvbGliL2luZGV4LmpzIS4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL2luZGV4LmpzPz92dWUtbG9hZGVyLW9wdGlvbnMhLi9zcmMvY29tcG9uZW50cy9VeExheWVyLnZ1ZT92dWUmdHlwZT1zY3JpcHQmbGFuZz1qcyZcbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG5cbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gY29uc3QgVXhMYXllcnZ1ZV90eXBlX3NjcmlwdF9sYW5nX2pzXyA9ICh7XG4gIG5hbWU6ICdVeExheWVyJyxcbiAgcHJvcHM6IFsndHZfaWQnLCAnaWQnLCAndXhzJywgJ3VwZGF0ZXInLCAnY29sb3JzJywgJ2NvbmZpZyddLFxuICBjb21wb25lbnRzOiB7XG4gICAgVXhXcmFwcGVyOiBVeFdyYXBwZXJcbiAgfSxcbiAgY3JlYXRlZDogZnVuY3Rpb24gY3JlYXRlZCgpIHt9LFxuICBtb3VudGVkOiBmdW5jdGlvbiBtb3VudGVkKCkge30sXG4gIGJlZm9yZURlc3Ryb3k6IGZ1bmN0aW9uIGJlZm9yZURlc3Ryb3koKSB7fSxcbiAgbWV0aG9kczoge1xuICAgIG9uX2N1c3RvbV9ldmVudDogZnVuY3Rpb24gb25fY3VzdG9tX2V2ZW50KGV2ZW50KSB7XG4gICAgICB0aGlzLiRlbWl0KCdjdXN0b20tZXZlbnQnLCBldmVudCk7XG4gICAgfVxuICB9LFxuICBjb21wdXRlZDoge1xuICAgIHN0eWxlOiBmdW5jdGlvbiBzdHlsZSgpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgICd0b3AnOiB0aGlzLiRwcm9wcy5pZCAhPT0gMCA/ICcxcHgnIDogMCxcbiAgICAgICAgJ2xlZnQnOiAwLFxuICAgICAgICAnd2lkdGgnOiAnMTAwJScsXG4gICAgICAgICdoZWlnaHQnOiAnY2FsYygxMDAlIC0gMnB4KScsXG4gICAgICAgICdwb3NpdGlvbic6ICdhYnNvbHV0ZScsXG4gICAgICAgICd6LWluZGV4JzogJzEnLFxuICAgICAgICAncG9pbnRlci1ldmVudHMnOiAnbm9uZScsXG4gICAgICAgICdvdmVyZmxvdyc6ICdoaWRkZW4nXG4gICAgICB9O1xuICAgIH1cbiAgfVxufSk7XG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvY29tcG9uZW50cy9VeExheWVyLnZ1ZT92dWUmdHlwZT1zY3JpcHQmbGFuZz1qcyZcbiAvKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIGNvbnN0IGNvbXBvbmVudHNfVXhMYXllcnZ1ZV90eXBlX3NjcmlwdF9sYW5nX2pzXyA9IChVeExheWVydnVlX3R5cGVfc2NyaXB0X2xhbmdfanNfKTsgXG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvY29tcG9uZW50cy9VeExheWVyLnZ1ZVxuXG5cblxuXG5cbi8qIG5vcm1hbGl6ZSBjb21wb25lbnQgKi9cbjtcbnZhciBVeExheWVyX2NvbXBvbmVudCA9IG5vcm1hbGl6ZUNvbXBvbmVudChcbiAgY29tcG9uZW50c19VeExheWVydnVlX3R5cGVfc2NyaXB0X2xhbmdfanNfLFxuICBVeExheWVydnVlX3R5cGVfdGVtcGxhdGVfaWRfMzkwY2NmNmVfcmVuZGVyLFxuICBVeExheWVydnVlX3R5cGVfdGVtcGxhdGVfaWRfMzkwY2NmNmVfc3RhdGljUmVuZGVyRm5zLFxuICBmYWxzZSxcbiAgbnVsbCxcbiAgbnVsbCxcbiAgbnVsbFxuICBcbilcblxuLyogaG90IHJlbG9hZCAqL1xuaWYgKGZhbHNlKSB7IHZhciBVeExheWVyX2FwaTsgfVxuVXhMYXllcl9jb21wb25lbnQub3B0aW9ucy5fX2ZpbGUgPSBcInNyYy9jb21wb25lbnRzL1V4TGF5ZXIudnVlXCJcbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gY29uc3QgVXhMYXllciA9IChVeExheWVyX2NvbXBvbmVudC5leHBvcnRzKTtcbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9zdHVmZi9tb3VzZS5qc1xuXG5cblxuZnVuY3Rpb24gbW91c2VfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlcihvLCBhbGxvd0FycmF5TGlrZSkgeyB2YXIgaXQ7IGlmICh0eXBlb2YgU3ltYm9sID09PSBcInVuZGVmaW5lZFwiIHx8IG9bU3ltYm9sLml0ZXJhdG9yXSA9PSBudWxsKSB7IGlmIChBcnJheS5pc0FycmF5KG8pIHx8IChpdCA9IG1vdXNlX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5KG8pKSB8fCBhbGxvd0FycmF5TGlrZSAmJiBvICYmIHR5cGVvZiBvLmxlbmd0aCA9PT0gXCJudW1iZXJcIikgeyBpZiAoaXQpIG8gPSBpdDsgdmFyIGkgPSAwOyB2YXIgRiA9IGZ1bmN0aW9uIEYoKSB7fTsgcmV0dXJuIHsgczogRiwgbjogZnVuY3Rpb24gbigpIHsgaWYgKGkgPj0gby5sZW5ndGgpIHJldHVybiB7IGRvbmU6IHRydWUgfTsgcmV0dXJuIHsgZG9uZTogZmFsc2UsIHZhbHVlOiBvW2krK10gfTsgfSwgZTogZnVuY3Rpb24gZShfZSkgeyB0aHJvdyBfZTsgfSwgZjogRiB9OyB9IHRocm93IG5ldyBUeXBlRXJyb3IoXCJJbnZhbGlkIGF0dGVtcHQgdG8gaXRlcmF0ZSBub24taXRlcmFibGUgaW5zdGFuY2UuXFxuSW4gb3JkZXIgdG8gYmUgaXRlcmFibGUsIG5vbi1hcnJheSBvYmplY3RzIG11c3QgaGF2ZSBhIFtTeW1ib2wuaXRlcmF0b3JdKCkgbWV0aG9kLlwiKTsgfSB2YXIgbm9ybWFsQ29tcGxldGlvbiA9IHRydWUsIGRpZEVyciA9IGZhbHNlLCBlcnI7IHJldHVybiB7IHM6IGZ1bmN0aW9uIHMoKSB7IGl0ID0gb1tTeW1ib2wuaXRlcmF0b3JdKCk7IH0sIG46IGZ1bmN0aW9uIG4oKSB7IHZhciBzdGVwID0gaXQubmV4dCgpOyBub3JtYWxDb21wbGV0aW9uID0gc3RlcC5kb25lOyByZXR1cm4gc3RlcDsgfSwgZTogZnVuY3Rpb24gZShfZTIpIHsgZGlkRXJyID0gdHJ1ZTsgZXJyID0gX2UyOyB9LCBmOiBmdW5jdGlvbiBmKCkgeyB0cnkgeyBpZiAoIW5vcm1hbENvbXBsZXRpb24gJiYgaXRbXCJyZXR1cm5cIl0gIT0gbnVsbCkgaXRbXCJyZXR1cm5cIl0oKTsgfSBmaW5hbGx5IHsgaWYgKGRpZEVycikgdGhyb3cgZXJyOyB9IH0gfTsgfVxuXG5mdW5jdGlvbiBtb3VzZV91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheShvLCBtaW5MZW4pIHsgaWYgKCFvKSByZXR1cm47IGlmICh0eXBlb2YgbyA9PT0gXCJzdHJpbmdcIikgcmV0dXJuIG1vdXNlX2FycmF5TGlrZVRvQXJyYXkobywgbWluTGVuKTsgdmFyIG4gPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwobykuc2xpY2UoOCwgLTEpOyBpZiAobiA9PT0gXCJPYmplY3RcIiAmJiBvLmNvbnN0cnVjdG9yKSBuID0gby5jb25zdHJ1Y3Rvci5uYW1lOyBpZiAobiA9PT0gXCJNYXBcIiB8fCBuID09PSBcIlNldFwiKSByZXR1cm4gQXJyYXkuZnJvbShvKTsgaWYgKG4gPT09IFwiQXJndW1lbnRzXCIgfHwgL14oPzpVaXxJKW50KD86OHwxNnwzMikoPzpDbGFtcGVkKT9BcnJheSQvLnRlc3QobikpIHJldHVybiBtb3VzZV9hcnJheUxpa2VUb0FycmF5KG8sIG1pbkxlbik7IH1cblxuZnVuY3Rpb24gbW91c2VfYXJyYXlMaWtlVG9BcnJheShhcnIsIGxlbikgeyBpZiAobGVuID09IG51bGwgfHwgbGVuID4gYXJyLmxlbmd0aCkgbGVuID0gYXJyLmxlbmd0aDsgZm9yICh2YXIgaSA9IDAsIGFycjIgPSBuZXcgQXJyYXkobGVuKTsgaSA8IGxlbjsgaSsrKSB7IGFycjJbaV0gPSBhcnJbaV07IH0gcmV0dXJuIGFycjI7IH1cblxuLy8gTW91c2UgZXZlbnQgaGFuZGxlciBmb3Igb3ZlcmxheVxudmFyIE1vdXNlID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gTW91c2UoY29tcCkge1xuICAgIGNsYXNzQ2FsbENoZWNrX2NsYXNzQ2FsbENoZWNrKHRoaXMsIE1vdXNlKTtcblxuICAgIHRoaXMuY29tcCA9IGNvbXA7XG4gICAgdGhpcy5tYXAgPSB7fTtcbiAgICB0aGlzLmxpc3RlbmVycyA9IDA7XG4gICAgdGhpcy5wcmVzc2VkID0gZmFsc2U7XG4gICAgdGhpcy54ID0gY29tcC4kcHJvcHMuY3Vyc29yLng7XG4gICAgdGhpcy55ID0gY29tcC4kcHJvcHMuY3Vyc29yLnk7XG4gICAgdGhpcy50ID0gY29tcC4kcHJvcHMuY3Vyc29yLnQ7XG4gICAgdGhpcy55JCA9IGNvbXAuJHByb3BzLmN1cnNvci55JDtcbiAgfSAvLyBZb3UgY2FuIGNob29zZSB3aGVyZSB0byBwbGFjZSB0aGUgaGFuZGxlclxuICAvLyAoYmVnaW5uaW5nIG9yIGVuZCBvZiB0aGUgcXVldWUpXG5cblxuICBjcmVhdGVDbGFzc19jcmVhdGVDbGFzcyhNb3VzZSwgW3tcbiAgICBrZXk6IFwib25cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gb24obmFtZSwgaGFuZGxlciwgZGlyKSB7XG4gICAgICBpZiAoZGlyID09PSB2b2lkIDApIHtcbiAgICAgICAgZGlyID0gXCJ1bnNoaWZ0XCI7XG4gICAgICB9XG5cbiAgICAgIGlmICghaGFuZGxlcikgcmV0dXJuO1xuICAgICAgdGhpcy5tYXBbbmFtZV0gPSB0aGlzLm1hcFtuYW1lXSB8fCBbXTtcbiAgICAgIHRoaXMubWFwW25hbWVdW2Rpcl0oaGFuZGxlcik7XG4gICAgICB0aGlzLmxpc3RlbmVycysrO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJvZmZcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gb2ZmKG5hbWUsIGhhbmRsZXIpIHtcbiAgICAgIGlmICghdGhpcy5tYXBbbmFtZV0pIHJldHVybjtcbiAgICAgIHZhciBpID0gdGhpcy5tYXBbbmFtZV0uaW5kZXhPZihoYW5kbGVyKTtcbiAgICAgIGlmIChpIDwgMCkgcmV0dXJuO1xuICAgICAgdGhpcy5tYXBbbmFtZV0uc3BsaWNlKGksIDEpO1xuICAgICAgdGhpcy5saXN0ZW5lcnMtLTtcbiAgICB9IC8vIENhbGxlZCBieSBncmlkLmpzXG5cbiAgfSwge1xuICAgIGtleTogXCJlbWl0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGVtaXQobmFtZSwgZXZlbnQpIHtcbiAgICAgIHZhciBsID0gdGhpcy5jb21wLmxheW91dDtcblxuICAgICAgaWYgKG5hbWUgaW4gdGhpcy5tYXApIHtcbiAgICAgICAgdmFyIF9pdGVyYXRvciA9IG1vdXNlX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXIodGhpcy5tYXBbbmFtZV0pLFxuICAgICAgICAgICAgX3N0ZXA7XG5cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBmb3IgKF9pdGVyYXRvci5zKCk7ICEoX3N0ZXAgPSBfaXRlcmF0b3IubigpKS5kb25lOykge1xuICAgICAgICAgICAgdmFyIGYgPSBfc3RlcC52YWx1ZTtcbiAgICAgICAgICAgIGYoZXZlbnQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgX2l0ZXJhdG9yLmUoZXJyKTtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICBfaXRlcmF0b3IuZigpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChuYW1lID09PSAnbW91c2Vtb3ZlJykge1xuICAgICAgICB0aGlzLnggPSBldmVudC5sYXllclg7XG4gICAgICAgIHRoaXMueSA9IGV2ZW50LmxheWVyWTtcbiAgICAgICAgdGhpcy50ID0gbC5zY3JlZW4ydCh0aGlzLngpO1xuICAgICAgICB0aGlzLnkkID0gbC5zY3JlZW4yJCh0aGlzLnkpO1xuICAgICAgfVxuXG4gICAgICBpZiAobmFtZSA9PT0gJ21vdXNlZG93bicpIHtcbiAgICAgICAgdGhpcy5wcmVzc2VkID0gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgaWYgKG5hbWUgPT09ICdtb3VzZXVwJykge1xuICAgICAgICB0aGlzLnByZXNzZWQgPSBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gTW91c2U7XG59KCk7XG5cblxuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL21peGlucy9vdmVybGF5LmpzXG4vLyBVc3VmdWwgc3R1ZmYgZm9yIGNyZWF0aW5nIG92ZXJsYXlzLiBJbmNsdWRlIGFzIG1peGluXG5cbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gY29uc3Qgb3ZlcmxheSA9ICh7XG4gIHByb3BzOiBbJ2lkJywgJ251bScsICdpbnRlcnZhbCcsICdjdXJzb3InLCAnY29sb3JzJywgJ2xheW91dCcsICdzdWInLCAnZGF0YScsICdzZXR0aW5ncycsICdncmlkX2lkJywgJ2ZvbnQnLCAnY29uZmlnJywgJ21ldGEnLCAndGYnLCAnaTAnLCAnbGFzdCddLFxuICBtb3VudGVkOiBmdW5jdGlvbiBtb3VudGVkKCkge1xuICAgIC8vIFRPRE8oMSk6IHdoZW4gaG90IHJlbG9hZGluZywgZHluYW1pY2FseSBjaGFuZ2VkIG1peGluc1xuICAgIC8vIGRpc3NhcGVhciAoY3V6IGl0J3MgYSBoYWNrKSwgdGhlIG9ubHkgd2F5IGZvciBub3dcbiAgICAvLyBpcyB0byByZWxvYWQgdGhlIGJyb3dzZXJcbiAgICBpZiAoIXRoaXMuZHJhdykge1xuICAgICAgdGhpcy5kcmF3ID0gZnVuY3Rpb24gKGN0eCkge1xuICAgICAgICB2YXIgdGV4dCA9ICdFQVJMWSBBRE9QVEVSIEJVRzogcmVsb2FkIHRoZSBicm93c2VyICYgZW5qb3knO1xuICAgICAgICBjb25zb2xlLndhcm4odGV4dCk7XG4gICAgICB9O1xuICAgIH0gLy8gTWFpbiBjaGFydD9cblxuXG4gICAgdmFyIG1haW4gPSB0aGlzLiRwcm9wcy5zdWIgPT09IHRoaXMuJHByb3BzLmRhdGE7XG4gICAgdGhpcy5tZXRhX2luZm8oKTsgLy8gVE9ETygxKTogcXVpY2sgZml4IGZvciB2dWUyLCBpbiB2dWUzIHdlIHVzZSAzcmQgcGFydHkgZW1pdFxuXG4gICAgdHJ5IHtcbiAgICAgIG5ldyBGdW5jdGlvbigncmV0dXJuICcgKyB0aGlzLiRlbWl0KSgpO1xuICAgICAgdGhpcy5fJGVtaXQgPSB0aGlzLiRlbWl0O1xuICAgICAgdGhpcy4kZW1pdCA9IHRoaXMuY3VzdG9tX2V2ZW50O1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0aGlzLl8kZW1pdCgnbmV3LWdyaWQtbGF5ZXInLCB7XG4gICAgICBuYW1lOiB0aGlzLiRvcHRpb25zLm5hbWUsXG4gICAgICBpZDogdGhpcy4kcHJvcHMuaWQsXG4gICAgICByZW5kZXJlcjogdGhpcyxcbiAgICAgIGRpc3BsYXk6ICdkaXNwbGF5JyBpbiB0aGlzLiRwcm9wcy5zZXR0aW5ncyA/IHRoaXMuJHByb3BzLnNldHRpbmdzWydkaXNwbGF5J10gOiB0cnVlLFxuICAgICAgejogdGhpcy4kcHJvcHMuc2V0dGluZ3NbJ3otaW5kZXgnXSB8fCB0aGlzLiRwcm9wcy5zZXR0aW5nc1snekluZGV4J10gfHwgKG1haW4gPyAwIDogLTEpXG4gICAgfSk7IC8vIE92ZXJsYXkgbWV0YS1wcm9wcyAoYWRqdXN0aW5nIGJlaGF2aW91cilcblxuXG4gICAgdGhpcy5fJGVtaXQoJ2xheWVyLW1ldGEtcHJvcHMnLCB7XG4gICAgICBncmlkX2lkOiB0aGlzLiRwcm9wcy5ncmlkX2lkLFxuICAgICAgbGF5ZXJfaWQ6IHRoaXMuJHByb3BzLmlkLFxuICAgICAgbGVnZW5kOiB0aGlzLmxlZ2VuZCxcbiAgICAgIGRhdGFfY29sb3JzOiB0aGlzLmRhdGFfY29sb3JzLFxuICAgICAgeV9yYW5nZTogdGhpcy55X3JhbmdlXG4gICAgfSk7XG5cbiAgICB0aGlzLmV4ZWNfc2NyaXB0KCk7XG4gICAgdGhpcy5tb3VzZSA9IG5ldyBNb3VzZSh0aGlzKTtcbiAgICBpZiAodGhpcy5pbml0X3Rvb2wpIHRoaXMuaW5pdF90b29sKCk7XG4gICAgaWYgKHRoaXMuaW5pdCkgdGhpcy5pbml0KCk7XG4gIH0sXG4gIGJlZm9yZURlc3Ryb3k6IGZ1bmN0aW9uIGJlZm9yZURlc3Ryb3koKSB7XG4gICAgaWYgKHRoaXMuZGVzdHJveSkgdGhpcy5kZXN0cm95KCk7XG5cbiAgICB0aGlzLl8kZW1pdCgnZGVsZXRlLWdyaWQtbGF5ZXInLCB0aGlzLiRwcm9wcy5pZCk7XG4gIH0sXG4gIG1ldGhvZHM6IHtcbiAgICB1c2VfZm9yOiBmdW5jdGlvbiB1c2VfZm9yKCkge1xuICAgICAgLyogb3ZlcnJpZGUgaXQgKG1hbmRhdG9yeSkgKi9cbiAgICAgIGNvbnNvbGUud2FybigndXNlX2ZvcigpIHNob3VsZCBiZSBpbXBsZW1lbnRlZCcpO1xuICAgICAgY29uc29sZS53YXJuKFwiRm9ybWF0OiB1c2VfZm9yKCkge1xcbiAgICAgICAgICAgICAgICAgIHJldHVybiBbJ3R5cGUxJywgJ3R5cGUyJywgLi4uXVxcbiAgICAgICAgICAgIH1cIik7XG4gICAgfSxcbiAgICBtZXRhX2luZm86IGZ1bmN0aW9uIG1ldGFfaW5mbygpIHtcbiAgICAgIC8qIG92ZXJyaWRlIGl0IChvcHRpb25hbCkgKi9cbiAgICAgIHZhciBpZCA9IHRoaXMuJHByb3BzLmlkO1xuICAgICAgY29uc29sZS53YXJuKFwiXCIuY29uY2F0KGlkLCBcIiBtZXRhX2luZm8oKSBpcyByZXEuIGZvciBwdWJsaXNoaW5nXCIpKTtcbiAgICAgIGNvbnNvbGUud2FybihcIkZvcm1hdDogbWV0YV9pbmZvKCkge1xcbiAgICAgICAgICAgICAgICBhdXRob3I6ICdTYXRvc2hpIFNtaXRoJyxcXG4gICAgICAgICAgICAgICAgdmVyc2lvbjogJzEuMC4wJyxcXG4gICAgICAgICAgICAgICAgY29udGFjdCAob3B0KSAnPGVtYWlsPidcXG4gICAgICAgICAgICAgICAgZ2l0aHViOiAob3B0KSAnPEdpdEh1YiBQYWdlPicsXFxuICAgICAgICAgICAgfVwiKTtcbiAgICB9LFxuICAgIGN1c3RvbV9ldmVudDogZnVuY3Rpb24gY3VzdG9tX2V2ZW50KGV2ZW50KSB7XG4gICAgICBpZiAoZXZlbnQuc3BsaXQoJzonKVswXSA9PT0gJ2hvb2snKSByZXR1cm47XG5cbiAgICAgIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW4gPiAxID8gX2xlbiAtIDEgOiAwKSwgX2tleSA9IDE7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICAgICAgYXJnc1tfa2V5IC0gMV0gPSBhcmd1bWVudHNbX2tleV07XG4gICAgICB9XG5cbiAgICAgIGlmIChldmVudCA9PT0gJ2NoYW5nZS1zZXR0aW5ncycgfHwgZXZlbnQgPT09ICdvYmplY3Qtc2VsZWN0ZWQnIHx8IGV2ZW50ID09PSAnbmV3LXNoYWRlcicgfHwgZXZlbnQgPT09ICduZXctaW50ZXJmYWNlJyB8fCBldmVudCA9PT0gJ3JlbW92ZS10b29sJykge1xuICAgICAgICBhcmdzLnB1c2godGhpcy5ncmlkX2lkLCB0aGlzLmlkKTtcblxuICAgICAgICBpZiAodGhpcy4kcHJvcHMuc2V0dGluZ3MuJHV1aWQpIHtcbiAgICAgICAgICBhcmdzLnB1c2godGhpcy4kcHJvcHMuc2V0dGluZ3MuJHV1aWQpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChldmVudCA9PT0gJ25ldy1pbnRlcmZhY2UnKSB7XG4gICAgICAgIGFyZ3NbMF0ub3ZlcmxheSA9IHRoaXM7XG4gICAgICAgIGFyZ3NbMF0udXVpZCA9IHRoaXMubGFzdF91eF9pZCA9IFwiXCIuY29uY2F0KHRoaXMuZ3JpZF9pZCwgXCItXCIpLmNvbmNhdCh0aGlzLmlkLCBcIi1cIikuY29uY2F0KHRoaXMudXhzX2NvdW50KyspO1xuICAgICAgfSAvLyBUT0RPOiBhZGQgYSBuYW1lc3BhY2UgdG8gdGhlIGV2ZW50IG5hbWVcbiAgICAgIC8vIFRPRE8oMik6IHRoaXMgcHJldmVudHMgY2FsbCBvdmVyZmxvdywgYnV0XG4gICAgICAvLyB0aGUgcm9vdCBvZiBldmlsIGlzIGluICgxKVxuXG5cbiAgICAgIGlmIChldmVudCA9PT0gJ2N1c3RvbS1ldmVudCcpIHJldHVybjtcblxuICAgICAgdGhpcy5fJGVtaXQoJ2N1c3RvbS1ldmVudCcsIHtcbiAgICAgICAgZXZlbnQ6IGV2ZW50LFxuICAgICAgICBhcmdzOiBhcmdzXG4gICAgICB9KTtcbiAgICB9LFxuICAgIC8vIFRPRE86IHRoZSBldmVudCBpcyBub3QgZmlyaW5nIHdoZW4gdGhlIHNhbWVcbiAgICAvLyBvdmVybGF5IHR5cGUgaXMgYWRkZWQgdG8gdGhlIG9mZmNoYXJ0W11cbiAgICBleGVjX3NjcmlwdDogZnVuY3Rpb24gZXhlY19zY3JpcHQoKSB7XG4gICAgICBpZiAodGhpcy5jYWxjKSB0aGlzLiRlbWl0KCdleGVjLXNjcmlwdCcsIHtcbiAgICAgICAgZ3JpZF9pZDogdGhpcy4kcHJvcHMuZ3JpZF9pZCxcbiAgICAgICAgbGF5ZXJfaWQ6IHRoaXMuJHByb3BzLmlkLFxuICAgICAgICBzcmM6IHRoaXMuY2FsYygpLFxuICAgICAgICB1c2VfZm9yOiB0aGlzLnVzZV9mb3IoKVxuICAgICAgfSk7XG4gICAgfVxuICB9LFxuICB3YXRjaDoge1xuICAgIHNldHRpbmdzOiB7XG4gICAgICBoYW5kbGVyOiBmdW5jdGlvbiBoYW5kbGVyKG4sIHApIHtcbiAgICAgICAgaWYgKHRoaXMud2F0Y2hfdXVpZCkgdGhpcy53YXRjaF91dWlkKG4sIHApO1xuXG4gICAgICAgIHRoaXMuXyRlbWl0KCdzaG93LWdyaWQtbGF5ZXInLCB7XG4gICAgICAgICAgaWQ6IHRoaXMuJHByb3BzLmlkLFxuICAgICAgICAgIGRpc3BsYXk6ICdkaXNwbGF5JyBpbiB0aGlzLiRwcm9wcy5zZXR0aW5ncyA/IHRoaXMuJHByb3BzLnNldHRpbmdzWydkaXNwbGF5J10gOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgfSxcbiAgICAgIGRlZXA6IHRydWVcbiAgICB9XG4gIH0sXG4gIGRhdGE6IGZ1bmN0aW9uIGRhdGEoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHV4c19jb3VudDogMCxcbiAgICAgIGxhc3RfdXhfaWQ6IG51bGxcbiAgICB9O1xuICB9LFxuICByZW5kZXI6IGZ1bmN0aW9uIHJlbmRlcihoKSB7XG4gICAgcmV0dXJuIGgoKTtcbiAgfVxufSk7XG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9ub2RlX21vZHVsZXMvYmFiZWwtbG9hZGVyL2xpYi9pbmRleC5qcyEuL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9pbmRleC5qcz8/dnVlLWxvYWRlci1vcHRpb25zIS4vc3JjL2NvbXBvbmVudHMvb3ZlcmxheXMvU3BsaW5lLnZ1ZT92dWUmdHlwZT1zY3JpcHQmbGFuZz1qcyZcbi8vIFNwbGluZSByZW5kZXJlci4gKFNNQXMsIEVNQXMsIFRFTUFzLi4uXG4vLyB5b3Uga25vdyB3aGF0IEkgbWVhbilcbi8vIFRPRE86IG1ha2UgYSByZWFsIHNwbGluZSwgbm90IGEgYnVuY2ggb2YgbGluZXMuLi5cbi8vIEFkZHMgYWxsIG5lY2Vzc2FyeSBzdHVmZiBmb3IgeW91LlxuXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIGNvbnN0IFNwbGluZXZ1ZV90eXBlX3NjcmlwdF9sYW5nX2pzXyA9ICh7XG4gIG5hbWU6ICdTcGxpbmUnLFxuICBtaXhpbnM6IFtvdmVybGF5XSxcbiAgbWV0aG9kczoge1xuICAgIG1ldGFfaW5mbzogZnVuY3Rpb24gbWV0YV9pbmZvKCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgYXV0aG9yOiAnQzQ1MScsXG4gICAgICAgIHZlcnNpb246ICcxLjEuMidcbiAgICAgIH07XG4gICAgfSxcbiAgICAvLyBIZXJlIGdvZXMgeW91ciBjb2RlLiBZb3UgYXJlIHByb3ZpZGVkIHdpdGg6XG4gICAgLy8geyBBbGwgc3R1ZmYgaXMgcmVhY3RpdmUgfVxuICAgIC8vICRwcm9wcy5sYXlvdXQgLT4gcG9zaXRpb25zIG9mIGFsbCBjaGFydCBlbGVtZW50cyArXG4gICAgLy8gIHNvbWUgaGVscGVyIGZ1bmN0aW9ucyAoc2VlIGxheW91dF9mbi5qcylcbiAgICAvLyAkcHJvcHMuaW50ZXJ2YWwgLT4gY2FuZGxlc3RpY2sgdGltZSBpbnRlcnZhbFxuICAgIC8vICRwcm9wcy5zdWIgLT4gY3VycmVudCBzdWJzZXQgb2YgY2FuZGxlc3RpY2sgZGF0YVxuICAgIC8vICRwcm9wcy5kYXRhIC0+IHlvdXIgaW5kaWNhdG9yJ3MgZGF0YSBzdWJzZXQuXG4gICAgLy8gIENvbWVzIFwiYXMgaXNcIiwgc2hvdWxkIGhhdmUgdGhlIGZvbGxvd2luZyBmb3JtYXQ6XG4gICAgLy8gIFtbPHRpbWVzdGFtcD4sIC4uLiBdLCAuLi4gXVxuICAgIC8vICRwcm9wcy5jb2xvcnMgLT4gY29sb3JzIChzZWUgVHJhZGluZ1Z1ZS52dWUpXG4gICAgLy8gJHByb3BzLmN1cnNvciAtPiBjdXJyZW50IHBvc2l0aW9uIG9mIGNyb3NzaGFpclxuICAgIC8vICRwcm9wcy5zZXR0aW5ncyAtPiBpbmRpY2F0b3IncyBjdXN0b20gc2V0dGluZ3NcbiAgICAvLyAgRS5nLiBjb2xvcnMsIGxpbmUgdGhpY2tuZXNzLCBldGMuIFlvdSBkZWZpbmUgaXQuXG4gICAgLy8gJHByb3BzLm51bSAtPiBpbmRpY2F0b3IncyBsYXllciBudW1iZXIgKG9mIEFsbFxuICAgIC8vIGxheWVycyBpbiB0aGUgY3VycmVudCBncmlkKVxuICAgIC8vICRwcm9wcy5pZCAtPiBpbmRpY2F0b3IncyBpZCAoZS5nLiBFTUFfMClcbiAgICAvLyB+XG4gICAgLy8gRmluYWxseSwgbGV0J3MgbWFrZSB0aGUgY2FudmFzIGRpcnR5IVxuICAgIGRyYXc6IGZ1bmN0aW9uIGRyYXcoY3R4KSB7XG4gICAgICBjdHgubGluZVdpZHRoID0gdGhpcy5saW5lX3dpZHRoO1xuICAgICAgY3R4LnN0cm9rZVN0eWxlID0gdGhpcy5jb2xvcjtcbiAgICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICAgIHZhciBsYXlvdXQgPSB0aGlzLiRwcm9wcy5sYXlvdXQ7XG4gICAgICB2YXIgaSA9IHRoaXMuZGF0YV9pbmRleDtcbiAgICAgIHZhciBkYXRhID0gdGhpcy4kcHJvcHMuZGF0YTtcblxuICAgICAgaWYgKCF0aGlzLnNraXBfbmFuKSB7XG4gICAgICAgIGZvciAodmFyIGsgPSAwLCBuID0gZGF0YS5sZW5ndGg7IGsgPCBuOyBrKyspIHtcbiAgICAgICAgICB2YXIgcCA9IGRhdGFba107XG4gICAgICAgICAgdmFyIHggPSBsYXlvdXQudDJzY3JlZW4ocFswXSk7XG4gICAgICAgICAgdmFyIHkgPSBsYXlvdXQuJDJzY3JlZW4ocFtpXSk7XG4gICAgICAgICAgY3R4LmxpbmVUbyh4LCB5KTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIHNraXAgPSBmYWxzZTtcblxuICAgICAgICBmb3IgKHZhciBrID0gMCwgbiA9IGRhdGEubGVuZ3RoOyBrIDwgbjsgaysrKSB7XG4gICAgICAgICAgdmFyIF9wID0gZGF0YVtrXTtcblxuICAgICAgICAgIHZhciBfeCA9IGxheW91dC50MnNjcmVlbihfcFswXSk7XG5cbiAgICAgICAgICB2YXIgX3kgPSBsYXlvdXQuJDJzY3JlZW4oX3BbaV0pO1xuXG4gICAgICAgICAgaWYgKF9wW2ldID09IG51bGwgfHwgX3kgIT09IF95KSB7XG4gICAgICAgICAgICBza2lwID0gdHJ1ZTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKHNraXApIGN0eC5tb3ZlVG8oX3gsIF95KTtcbiAgICAgICAgICAgIGN0eC5saW5lVG8oX3gsIF95KTtcbiAgICAgICAgICAgIHNraXAgPSBmYWxzZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgY3R4LnN0cm9rZSgpO1xuICAgIH0sXG4gICAgLy8gRm9yIGFsbCBkYXRhIHdpdGggdGhlc2UgdHlwZXMgb3ZlcmxheSB3aWxsIGJlXG4gICAgLy8gYWRkZWQgdG8gdGhlIHJlbmRlcmVyIGxpc3QuIEFuZCAnJHByb3BzLmRhdGEnXG4gICAgLy8gd2lsbCBoYXZlIHRoZSBjb3JyZXNwb25kaW5nIHZhbHVlcy4gSWYgeW91IHdhbnQgdG9cbiAgICAvLyByZWRlZmluZSB0aGUgZGVmYXVsdCBiZWh2aW91ciBmb3IgYSBwcnRpY3VsYXJcbiAgICAvLyBpbmRpY2F0b3IgKGxldCdzIHNheSBFTUEpLFxuICAgIC8vIGp1c3QgY3JlYXRlIGEgbmV3IG92ZXJsYXkgd2l0aCB0aGUgc2FtZSB0eXBlOlxuICAgIC8vIGUuZy4gdXNlX2ZvcigpIHsgcmV0dXJuIFsnRU1BJ10gfS5cbiAgICB1c2VfZm9yOiBmdW5jdGlvbiB1c2VfZm9yKCkge1xuICAgICAgcmV0dXJuIFsnU3BsaW5lJywgJ0VNQScsICdTTUEnXTtcbiAgICB9LFxuICAgIC8vIENvbG9ycyBmb3IgdGhlIGxlZ2VuZCwgc2hvdWxkIGhhdmUgdGhlXG4gICAgLy8gc2FtZSBkaW1lbnRpb24gYXMgYSBkYXRhIHBvaW50IChleGNsLiB0aW1lc3RhbXApXG4gICAgZGF0YV9jb2xvcnM6IGZ1bmN0aW9uIGRhdGFfY29sb3JzKCkge1xuICAgICAgcmV0dXJuIFt0aGlzLmNvbG9yXTtcbiAgICB9XG4gIH0sXG4gIC8vIERlZmluZSBpbnRlcm5hbCBzZXR0aW5nICYgY29uc3RhbnRzIGhlcmVcbiAgY29tcHV0ZWQ6IHtcbiAgICBzZXR0OiBmdW5jdGlvbiBzZXR0KCkge1xuICAgICAgcmV0dXJuIHRoaXMuJHByb3BzLnNldHRpbmdzO1xuICAgIH0sXG4gICAgbGluZV93aWR0aDogZnVuY3Rpb24gbGluZV93aWR0aCgpIHtcbiAgICAgIHJldHVybiB0aGlzLnNldHQubGluZVdpZHRoIHx8IDAuNzU7XG4gICAgfSxcbiAgICBjb2xvcjogZnVuY3Rpb24gY29sb3IoKSB7XG4gICAgICB2YXIgbiA9IHRoaXMuJHByb3BzLm51bSAlIDU7XG4gICAgICByZXR1cm4gdGhpcy5zZXR0LmNvbG9yIHx8IHRoaXMuQ09MT1JTW25dO1xuICAgIH0sXG4gICAgZGF0YV9pbmRleDogZnVuY3Rpb24gZGF0YV9pbmRleCgpIHtcbiAgICAgIHJldHVybiB0aGlzLnNldHQuZGF0YUluZGV4IHx8IDE7XG4gICAgfSxcbiAgICAvLyBEb24ndCBjb25uZWN0IHNlcGFyYXRlIHBhcnRzIGlmIHRydWVcbiAgICBza2lwX25hbjogZnVuY3Rpb24gc2tpcF9uYW4oKSB7XG4gICAgICByZXR1cm4gdGhpcy5zZXR0LnNraXBOYU47XG4gICAgfVxuICB9LFxuICBkYXRhOiBmdW5jdGlvbiBkYXRhKCkge1xuICAgIHJldHVybiB7XG4gICAgICBDT0xPUlM6IFsnIzQyYjI4YScsICcjNTY5MWNlJywgJyM2MTJmZjknLCAnI2Q1MGI5MCcsICcjZmYyMzE2J11cbiAgICB9O1xuICB9XG59KTtcbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9jb21wb25lbnRzL292ZXJsYXlzL1NwbGluZS52dWU/dnVlJnR5cGU9c2NyaXB0Jmxhbmc9anMmXG4gLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyBjb25zdCBvdmVybGF5c19TcGxpbmV2dWVfdHlwZV9zY3JpcHRfbGFuZ19qc18gPSAoU3BsaW5ldnVlX3R5cGVfc2NyaXB0X2xhbmdfanNfKTsgXG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvY29tcG9uZW50cy9vdmVybGF5cy9TcGxpbmUudnVlXG52YXIgU3BsaW5lX3JlbmRlciwgU3BsaW5lX3N0YXRpY1JlbmRlckZuc1xuO1xuXG5cblxuLyogbm9ybWFsaXplIGNvbXBvbmVudCAqL1xuO1xudmFyIFNwbGluZV9jb21wb25lbnQgPSBub3JtYWxpemVDb21wb25lbnQoXG4gIG92ZXJsYXlzX1NwbGluZXZ1ZV90eXBlX3NjcmlwdF9sYW5nX2pzXyxcbiAgU3BsaW5lX3JlbmRlcixcbiAgU3BsaW5lX3N0YXRpY1JlbmRlckZucyxcbiAgZmFsc2UsXG4gIG51bGwsXG4gIG51bGwsXG4gIG51bGxcbiAgXG4pXG5cbi8qIGhvdCByZWxvYWQgKi9cbmlmIChmYWxzZSkgeyB2YXIgU3BsaW5lX2FwaTsgfVxuU3BsaW5lX2NvbXBvbmVudC5vcHRpb25zLl9fZmlsZSA9IFwic3JjL2NvbXBvbmVudHMvb3ZlcmxheXMvU3BsaW5lLnZ1ZVwiXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIGNvbnN0IFNwbGluZSA9IChTcGxpbmVfY29tcG9uZW50LmV4cG9ydHMpO1xuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vbm9kZV9tb2R1bGVzL2JhYmVsLWxvYWRlci9saWIvaW5kZXguanMhLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvaW5kZXguanM/P3Z1ZS1sb2FkZXItb3B0aW9ucyEuL3NyYy9jb21wb25lbnRzL292ZXJsYXlzL1NwbGluZXMudnVlP3Z1ZSZ0eXBlPXNjcmlwdCZsYW5nPWpzJlxuLy8gQ2hhbm5lbCByZW5kZXJlci4gKEtlbHRuZXIsIEJvbGxpbmdlcilcblxuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyBjb25zdCBTcGxpbmVzdnVlX3R5cGVfc2NyaXB0X2xhbmdfanNfID0gKHtcbiAgbmFtZTogJ1NwbGluZXMnLFxuICBtaXhpbnM6IFtvdmVybGF5XSxcbiAgbWV0aG9kczoge1xuICAgIG1ldGFfaW5mbzogZnVuY3Rpb24gbWV0YV9pbmZvKCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgYXV0aG9yOiAnQzQ1MScsXG4gICAgICAgIHZlcnNpb246ICcxLjEuMCdcbiAgICAgIH07XG4gICAgfSxcbiAgICBkcmF3OiBmdW5jdGlvbiBkcmF3KGN0eCkge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmxpbmVzX251bTsgaSsrKSB7XG4gICAgICAgIHZhciBfaSA9IGkgJSB0aGlzLmNscngubGVuZ3RoO1xuXG4gICAgICAgIGN0eC5zdHJva2VTdHlsZSA9IHRoaXMuY2xyeFtfaV07XG4gICAgICAgIGN0eC5saW5lV2lkdGggPSB0aGlzLndpZHRoc1tpXSB8fCB0aGlzLmxpbmVfd2lkdGg7XG4gICAgICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICAgICAgdGhpcy5kcmF3X3NwbGluZShjdHgsIGkpO1xuICAgICAgICBjdHguc3Ryb2tlKCk7XG4gICAgICB9XG4gICAgfSxcbiAgICBkcmF3X3NwbGluZTogZnVuY3Rpb24gZHJhd19zcGxpbmUoY3R4LCBpKSB7XG4gICAgICB2YXIgbGF5b3V0ID0gdGhpcy4kcHJvcHMubGF5b3V0O1xuICAgICAgdmFyIGRhdGEgPSB0aGlzLiRwcm9wcy5kYXRhO1xuXG4gICAgICBpZiAoIXRoaXMuc2tpcF9uYW4pIHtcbiAgICAgICAgZm9yICh2YXIgayA9IDAsIG4gPSBkYXRhLmxlbmd0aDsgayA8IG47IGsrKykge1xuICAgICAgICAgIHZhciBwID0gZGF0YVtrXTtcbiAgICAgICAgICB2YXIgeCA9IGxheW91dC50MnNjcmVlbihwWzBdKTtcbiAgICAgICAgICB2YXIgeSA9IGxheW91dC4kMnNjcmVlbihwW2kgKyAxXSk7XG4gICAgICAgICAgY3R4LmxpbmVUbyh4LCB5KTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIHNraXAgPSBmYWxzZTtcblxuICAgICAgICBmb3IgKHZhciBrID0gMCwgbiA9IGRhdGEubGVuZ3RoOyBrIDwgbjsgaysrKSB7XG4gICAgICAgICAgdmFyIF9wID0gZGF0YVtrXTtcblxuICAgICAgICAgIHZhciBfeCA9IGxheW91dC50MnNjcmVlbihfcFswXSk7XG5cbiAgICAgICAgICB2YXIgX3kgPSBsYXlvdXQuJDJzY3JlZW4oX3BbaSArIDFdKTtcblxuICAgICAgICAgIGlmIChfcFtpICsgMV0gPT0gbnVsbCB8fCBfeSAhPT0gX3kpIHtcbiAgICAgICAgICAgIHNraXAgPSB0cnVlO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAoc2tpcCkgY3R4Lm1vdmVUbyhfeCwgX3kpO1xuICAgICAgICAgICAgY3R4LmxpbmVUbyhfeCwgX3kpO1xuICAgICAgICAgICAgc2tpcCA9IGZhbHNlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG4gICAgdXNlX2ZvcjogZnVuY3Rpb24gdXNlX2ZvcigpIHtcbiAgICAgIHJldHVybiBbJ1NwbGluZXMnLCAnRE1JJ107XG4gICAgfSxcbiAgICBkYXRhX2NvbG9yczogZnVuY3Rpb24gZGF0YV9jb2xvcnMoKSB7XG4gICAgICByZXR1cm4gdGhpcy5jbHJ4O1xuICAgIH1cbiAgfSxcbiAgLy8gRGVmaW5lIGludGVybmFsIHNldHRpbmcgJiBjb25zdGFudHMgaGVyZVxuICBjb21wdXRlZDoge1xuICAgIHNldHQ6IGZ1bmN0aW9uIHNldHQoKSB7XG4gICAgICByZXR1cm4gdGhpcy4kcHJvcHMuc2V0dGluZ3M7XG4gICAgfSxcbiAgICBsaW5lX3dpZHRoOiBmdW5jdGlvbiBsaW5lX3dpZHRoKCkge1xuICAgICAgcmV0dXJuIHRoaXMuc2V0dC5saW5lV2lkdGggfHwgMC43NTtcbiAgICB9LFxuICAgIHdpZHRoczogZnVuY3Rpb24gd2lkdGhzKCkge1xuICAgICAgcmV0dXJuIHRoaXMuc2V0dC5saW5lV2lkdGhzIHx8IFtdO1xuICAgIH0sXG4gICAgY2xyeDogZnVuY3Rpb24gY2xyeCgpIHtcbiAgICAgIHZhciBjb2xvcnMgPSB0aGlzLnNldHQuY29sb3JzIHx8IFtdO1xuICAgICAgdmFyIG4gPSB0aGlzLiRwcm9wcy5udW07XG5cbiAgICAgIGlmICghY29sb3JzLmxlbmd0aCkge1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMubGluZXNfbnVtOyBpKyspIHtcbiAgICAgICAgICBjb2xvcnMucHVzaCh0aGlzLkNPTE9SU1sobiArIGkpICUgNV0pO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBjb2xvcnM7XG4gICAgfSxcbiAgICBsaW5lc19udW06IGZ1bmN0aW9uIGxpbmVzX251bSgpIHtcbiAgICAgIGlmICghdGhpcy4kcHJvcHMuZGF0YVswXSkgcmV0dXJuIDA7XG4gICAgICByZXR1cm4gdGhpcy4kcHJvcHMuZGF0YVswXS5sZW5ndGggLSAxO1xuICAgIH0sXG4gICAgLy8gRG9uJ3QgY29ubmVjdCBzZXBhcmF0ZSBwYXJ0cyBpZiB0cnVlXG4gICAgc2tpcF9uYW46IGZ1bmN0aW9uIHNraXBfbmFuKCkge1xuICAgICAgcmV0dXJuIHRoaXMuc2V0dC5za2lwTmFOO1xuICAgIH1cbiAgfSxcbiAgZGF0YTogZnVuY3Rpb24gZGF0YSgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgQ09MT1JTOiBbJyM0MmIyOGEnLCAnIzU2OTFjZScsICcjNjEyZmY5JywgJyNkNTBiOTAnLCAnI2ZmMjMxNiddXG4gICAgfTtcbiAgfVxufSk7XG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvY29tcG9uZW50cy9vdmVybGF5cy9TcGxpbmVzLnZ1ZT92dWUmdHlwZT1zY3JpcHQmbGFuZz1qcyZcbiAvKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIGNvbnN0IG92ZXJsYXlzX1NwbGluZXN2dWVfdHlwZV9zY3JpcHRfbGFuZ19qc18gPSAoU3BsaW5lc3Z1ZV90eXBlX3NjcmlwdF9sYW5nX2pzXyk7IFxuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL2NvbXBvbmVudHMvb3ZlcmxheXMvU3BsaW5lcy52dWVcbnZhciBTcGxpbmVzX3JlbmRlciwgU3BsaW5lc19zdGF0aWNSZW5kZXJGbnNcbjtcblxuXG5cbi8qIG5vcm1hbGl6ZSBjb21wb25lbnQgKi9cbjtcbnZhciBTcGxpbmVzX2NvbXBvbmVudCA9IG5vcm1hbGl6ZUNvbXBvbmVudChcbiAgb3ZlcmxheXNfU3BsaW5lc3Z1ZV90eXBlX3NjcmlwdF9sYW5nX2pzXyxcbiAgU3BsaW5lc19yZW5kZXIsXG4gIFNwbGluZXNfc3RhdGljUmVuZGVyRm5zLFxuICBmYWxzZSxcbiAgbnVsbCxcbiAgbnVsbCxcbiAgbnVsbFxuICBcbilcblxuLyogaG90IHJlbG9hZCAqL1xuaWYgKGZhbHNlKSB7IHZhciBTcGxpbmVzX2FwaTsgfVxuU3BsaW5lc19jb21wb25lbnQub3B0aW9ucy5fX2ZpbGUgPSBcInNyYy9jb21wb25lbnRzL292ZXJsYXlzL1NwbGluZXMudnVlXCJcbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gY29uc3QgU3BsaW5lcyA9IChTcGxpbmVzX2NvbXBvbmVudC5leHBvcnRzKTtcbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL25vZGVfbW9kdWxlcy9iYWJlbC1sb2FkZXIvbGliL2luZGV4LmpzIS4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL2luZGV4LmpzPz92dWUtbG9hZGVyLW9wdGlvbnMhLi9zcmMvY29tcG9uZW50cy9vdmVybGF5cy9SYW5nZS52dWU/dnVlJnR5cGU9c2NyaXB0Jmxhbmc9anMmXG4vLyBSIFMgSSAuIEJlY2F1c2Ugd2UgbG92ZSBpdFxuLy8gQWRkcyBhbGwgbmVjZXNzYXJ5IHN0dWZmIGZvciB5b3UuXG5cbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gY29uc3QgUmFuZ2V2dWVfdHlwZV9zY3JpcHRfbGFuZ19qc18gPSAoe1xuICBuYW1lOiAnUmFuZ2UnLFxuICBtaXhpbnM6IFtvdmVybGF5XSxcbiAgbWV0aG9kczoge1xuICAgIG1ldGFfaW5mbzogZnVuY3Rpb24gbWV0YV9pbmZvKCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgYXV0aG9yOiAnQzQ1MScsXG4gICAgICAgIHZlcnNpb246ICcxLjAuMSdcbiAgICAgIH07XG4gICAgfSxcbiAgICAvLyBIZXJlIGdvZXMgeW91ciBjb2RlLiBZb3UgYXJlIHByb3ZpZGVkIHdpdGg6XG4gICAgLy8geyBBbGwgc3R1ZmYgaXMgcmVhY3RpdmUgfVxuICAgIC8vICRwcm9wcy5sYXlvdXQgLT4gcG9zaXRpb25zIG9mIGFsbCBjaGFydCBlbGVtZW50cyArXG4gICAgLy8gIHNvbWUgaGVscGVyIGZ1bmN0aW9ucyAoc2VlIGxheW91dF9mbi5qcylcbiAgICAvLyAkcHJvcHMuaW50ZXJ2YWwgLT4gY2FuZGxlc3RpY2sgdGltZSBpbnRlcnZhbFxuICAgIC8vICRwcm9wcy5zdWIgLT4gY3VycmVudCBzdWJzZXQgb2YgY2FuZGxlc3RpY2sgZGF0YVxuICAgIC8vICRwcm9wcy5kYXRhIC0+IHlvdXIgaW5kaWNhdG9yJ3MgZGF0YSBzdWJzZXQuXG4gICAgLy8gIENvbWVzIFwiYXMgaXNcIiwgc2hvdWxkIGhhdmUgdGhlIGZvbGxvd2luZyBmb3JtYXQ6XG4gICAgLy8gIFtbPHRpbWVzdGFtcD4sIC4uLiBdLCAuLi4gXVxuICAgIC8vICRwcm9wcy5jb2xvcnMgLT4gY29sb3JzIChzZWUgVHJhZGluZ1Z1ZS52dWUpXG4gICAgLy8gJHByb3BzLmN1cnNvciAtPiBjdXJyZW50IHBvc2l0aW9uIG9mIGNyb3NzaGFpclxuICAgIC8vICRwcm9wcy5zZXR0aW5ncyAtPiBpbmRpY2F0b3IncyBjdXN0b20gc2V0dGluZ3NcbiAgICAvLyAgRS5nLiBjb2xvcnMsIGxpbmUgdGhpY2tuZXNzLCBldGMuIFlvdSBkZWZpbmUgaXQuXG4gICAgLy8gJHByb3BzLm51bSAtPiBpbmRpY2F0b3IncyBsYXllciBudW1iZXIgKG9mIEFsbFxuICAgIC8vIGxheWVycyBpbiB0aGUgY3VycmVudCBncmlkKVxuICAgIC8vICRwcm9wcy5pZCAtPiBpbmRpY2F0b3IncyBpZCAoZS5nLiBFTUFfMClcbiAgICAvLyB+XG4gICAgLy8gRmluYWxseSwgbGV0J3MgbWFrZSB0aGUgY2FudmFzIGRpcnR5IVxuICAgIGRyYXc6IGZ1bmN0aW9uIGRyYXcoY3R4KSB7XG4gICAgICB2YXIgbGF5b3V0ID0gdGhpcy4kcHJvcHMubGF5b3V0O1xuICAgICAgdmFyIHVwcGVyID0gbGF5b3V0LiQyc2NyZWVuKHRoaXMuc2V0dC51cHBlciB8fCA3MCk7XG4gICAgICB2YXIgbG93ZXIgPSBsYXlvdXQuJDJzY3JlZW4odGhpcy5zZXR0Lmxvd2VyIHx8IDMwKTtcbiAgICAgIHZhciBkYXRhID0gdGhpcy4kcHJvcHMuZGF0YTsgLy8gUlNJIHZhbHVlc1xuXG4gICAgICBjdHgubGluZVdpZHRoID0gdGhpcy5saW5lX3dpZHRoO1xuICAgICAgY3R4LnN0cm9rZVN0eWxlID0gdGhpcy5jb2xvcjtcbiAgICAgIGN0eC5iZWdpblBhdGgoKTtcblxuICAgICAgZm9yICh2YXIgayA9IDAsIG4gPSBkYXRhLmxlbmd0aDsgayA8IG47IGsrKykge1xuICAgICAgICB2YXIgcCA9IGRhdGFba107XG4gICAgICAgIHZhciB4ID0gbGF5b3V0LnQyc2NyZWVuKHBbMF0pO1xuICAgICAgICB2YXIgeSA9IGxheW91dC4kMnNjcmVlbihwWzFdKTtcbiAgICAgICAgY3R4LmxpbmVUbyh4LCB5KTtcbiAgICAgIH1cblxuICAgICAgY3R4LnN0cm9rZSgpO1xuICAgICAgY3R4LnN0cm9rZVN0eWxlID0gdGhpcy5iYW5kX2NvbG9yO1xuICAgICAgY3R4LnNldExpbmVEYXNoKFs1XSk7IC8vIFdpbGwgYmUgcmVtb3ZlZCBhZnRlciBkcmF3KClcblxuICAgICAgY3R4LmJlZ2luUGF0aCgpOyAvLyBGaWxsIHRoZSBhcmVhIGJldHdlZW4gdGhlIGJhbmRzXG5cbiAgICAgIGN0eC5maWxsU3R5bGUgPSB0aGlzLmJhY2tfY29sb3I7XG4gICAgICBjdHguZmlsbFJlY3QoMCwgdXBwZXIsIGxheW91dC53aWR0aCwgbG93ZXIgLSB1cHBlcik7IC8vIFVwcGVyIGJhbmRcblxuICAgICAgY3R4Lm1vdmVUbygwLCB1cHBlcik7XG4gICAgICBjdHgubGluZVRvKGxheW91dC53aWR0aCwgdXBwZXIpOyAvLyBMb3dlciBiYW5kXG5cbiAgICAgIGN0eC5tb3ZlVG8oMCwgbG93ZXIpO1xuICAgICAgY3R4LmxpbmVUbyhsYXlvdXQud2lkdGgsIGxvd2VyKTtcbiAgICAgIGN0eC5zdHJva2UoKTtcbiAgICB9LFxuICAgIC8vIEZvciBhbGwgZGF0YSB3aXRoIHRoZXNlIHR5cGVzIG92ZXJsYXkgd2lsbCBiZVxuICAgIC8vIGFkZGVkIHRvIHRoZSByZW5kZXJlciBsaXN0LiBBbmQgJyRwcm9wcy5kYXRhJ1xuICAgIC8vIHdpbGwgaGF2ZSB0aGUgY29ycmVzcG9uZGluZyB2YWx1ZXMuIElmIHlvdSB3YW50IHRvXG4gICAgLy8gcmVkZWZpbmUgdGhlIGRlZmF1bHQgYmVodmlvdXIgZm9yIGEgcHJ0aWN1bGFyXG4gICAgLy8gaW5kaWNhdG9yIChsZXQncyBzYXkgRU1BKSxcbiAgICAvLyBqdXN0IGNyZWF0ZSBhIG5ldyBvdmVybGF5IHdpdGggdGhlIHNhbWUgdHlwZTpcbiAgICAvLyBlLmcuIHVzZV9mb3IoKSB7IHJldHVybiBbJ0VNQSddIH0uXG4gICAgdXNlX2ZvcjogZnVuY3Rpb24gdXNlX2ZvcigpIHtcbiAgICAgIHJldHVybiBbJ1JhbmdlJywgJ1JTSSddO1xuICAgIH0sXG4gICAgLy8gQ29sb3JzIGZvciB0aGUgbGVnZW5kLCBzaG91bGQgaGF2ZSB0aGVcbiAgICAvLyBzYW1lIGRpbWVudGlvbiBhcyBhIGRhdGEgcG9pbnQgKGV4Y2wuIHRpbWVzdGFtcClcbiAgICBkYXRhX2NvbG9yczogZnVuY3Rpb24gZGF0YV9jb2xvcnMoKSB7XG4gICAgICByZXR1cm4gW3RoaXMuY29sb3JdO1xuICAgIH0sXG4gICAgLy8gWS1SYW5nZSB0YW5zZm9ybS4gRm9yIGV4YW1wbGUgeW91IG5lZWQgYSBmaXhlZFxuICAgIC8vIFktcmFuZ2UgZm9yIGFuIGluZGljYXRvciwgeW91IGNhbiBkbyBpdCBoZXJlIVxuICAgIC8vIEdldHMgZXN0aW1hdGVkIHJhbmdlLCBAcmV0dXJuIHlvdSBmYXZvcml0ZSByYW5nZVxuICAgIHlfcmFuZ2U6IGZ1bmN0aW9uIHlfcmFuZ2UoaGksIGxvKSB7XG4gICAgICByZXR1cm4gW01hdGgubWF4KGhpLCB0aGlzLnNldHQudXBwZXIgfHwgNzApLCBNYXRoLm1pbihsbywgdGhpcy5zZXR0Lmxvd2VyIHx8IDMwKV07XG4gICAgfVxuICB9LFxuICAvLyBEZWZpbmUgaW50ZXJuYWwgc2V0dGluZyAmIGNvbnN0YW50cyBoZXJlXG4gIGNvbXB1dGVkOiB7XG4gICAgc2V0dDogZnVuY3Rpb24gc2V0dCgpIHtcbiAgICAgIHJldHVybiB0aGlzLiRwcm9wcy5zZXR0aW5ncztcbiAgICB9LFxuICAgIGxpbmVfd2lkdGg6IGZ1bmN0aW9uIGxpbmVfd2lkdGgoKSB7XG4gICAgICByZXR1cm4gdGhpcy5zZXR0LmxpbmVXaWR0aCB8fCAwLjc1O1xuICAgIH0sXG4gICAgY29sb3I6IGZ1bmN0aW9uIGNvbG9yKCkge1xuICAgICAgcmV0dXJuIHRoaXMuc2V0dC5jb2xvciB8fCAnI2VjMjA2ZSc7XG4gICAgfSxcbiAgICBiYW5kX2NvbG9yOiBmdW5jdGlvbiBiYW5kX2NvbG9yKCkge1xuICAgICAgcmV0dXJuIHRoaXMuc2V0dC5iYW5kQ29sb3IgfHwgJyNkZGQnO1xuICAgIH0sXG4gICAgYmFja19jb2xvcjogZnVuY3Rpb24gYmFja19jb2xvcigpIHtcbiAgICAgIHJldHVybiB0aGlzLnNldHQuYmFja0NvbG9yIHx8ICcjMzgxZTljMTYnO1xuICAgIH1cbiAgfVxufSk7XG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvY29tcG9uZW50cy9vdmVybGF5cy9SYW5nZS52dWU/dnVlJnR5cGU9c2NyaXB0Jmxhbmc9anMmXG4gLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyBjb25zdCBvdmVybGF5c19SYW5nZXZ1ZV90eXBlX3NjcmlwdF9sYW5nX2pzXyA9IChSYW5nZXZ1ZV90eXBlX3NjcmlwdF9sYW5nX2pzXyk7IFxuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL2NvbXBvbmVudHMvb3ZlcmxheXMvUmFuZ2UudnVlXG52YXIgUmFuZ2VfcmVuZGVyLCBSYW5nZV9zdGF0aWNSZW5kZXJGbnNcbjtcblxuXG5cbi8qIG5vcm1hbGl6ZSBjb21wb25lbnQgKi9cbjtcbnZhciBSYW5nZV9jb21wb25lbnQgPSBub3JtYWxpemVDb21wb25lbnQoXG4gIG92ZXJsYXlzX1JhbmdldnVlX3R5cGVfc2NyaXB0X2xhbmdfanNfLFxuICBSYW5nZV9yZW5kZXIsXG4gIFJhbmdlX3N0YXRpY1JlbmRlckZucyxcbiAgZmFsc2UsXG4gIG51bGwsXG4gIG51bGwsXG4gIG51bGxcbiAgXG4pXG5cbi8qIGhvdCByZWxvYWQgKi9cbmlmIChmYWxzZSkgeyB2YXIgUmFuZ2VfYXBpOyB9XG5SYW5nZV9jb21wb25lbnQub3B0aW9ucy5fX2ZpbGUgPSBcInNyYy9jb21wb25lbnRzL292ZXJsYXlzL1JhbmdlLnZ1ZVwiXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIGNvbnN0IFJhbmdlID0gKFJhbmdlX2NvbXBvbmVudC5leHBvcnRzKTtcbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL25vZGVfbW9kdWxlcy9iYWJlbC1sb2FkZXIvbGliL2luZGV4LmpzIS4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL2luZGV4LmpzPz92dWUtbG9hZGVyLW9wdGlvbnMhLi9zcmMvY29tcG9uZW50cy9vdmVybGF5cy9UcmFkZXMudnVlP3Z1ZSZ0eXBlPXNjcmlwdCZsYW5nPWpzJlxuXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIGNvbnN0IFRyYWRlc3Z1ZV90eXBlX3NjcmlwdF9sYW5nX2pzXyA9ICh7XG4gIG5hbWU6ICdUcmFkZXMnLFxuICBtaXhpbnM6IFtvdmVybGF5XSxcbiAgbWV0aG9kczoge1xuICAgIG1ldGFfaW5mbzogZnVuY3Rpb24gbWV0YV9pbmZvKCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgYXV0aG9yOiAnQzQ1MScsXG4gICAgICAgIHZlcnNpb246ICcxLjAuMidcbiAgICAgIH07XG4gICAgfSxcbiAgICBkcmF3OiBmdW5jdGlvbiBkcmF3KGN0eCkge1xuICAgICAgdmFyIGxheW91dCA9IHRoaXMuJHByb3BzLmxheW91dDtcbiAgICAgIHZhciBkYXRhID0gdGhpcy4kcHJvcHMuZGF0YTtcbiAgICAgIGN0eC5saW5lV2lkdGggPSAxLjU7XG4gICAgICBjdHguc3Ryb2tlU3R5bGUgPSAnYmxhY2snO1xuXG4gICAgICBmb3IgKHZhciBrID0gMCwgbiA9IGRhdGEubGVuZ3RoOyBrIDwgbjsgaysrKSB7XG4gICAgICAgIHZhciBwID0gZGF0YVtrXTtcbiAgICAgICAgY3R4LmZpbGxTdHlsZSA9IHBbMV0gPyB0aGlzLmJ1eV9jb2xvciA6IHRoaXMuc2VsbF9jb2xvcjtcbiAgICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgICB2YXIgeCA9IGxheW91dC50MnNjcmVlbihwWzBdKTsgLy8geCAtIE1hcHBpbmdcblxuICAgICAgICB2YXIgeSA9IGxheW91dC4kMnNjcmVlbihwWzJdKTsgLy8geSAtIE1hcHBpbmdcblxuICAgICAgICBjdHguYXJjKHgsIHksIHRoaXMubWFya2VyX3NpemUgKyAwLjUsIDAsIE1hdGguUEkgKiAyLCB0cnVlKTtcbiAgICAgICAgY3R4LmZpbGwoKTtcbiAgICAgICAgY3R4LnN0cm9rZSgpO1xuXG4gICAgICAgIGlmICh0aGlzLnNob3dfbGFiZWwgJiYgcFszXSkge1xuICAgICAgICAgIHRoaXMuZHJhd19sYWJlbChjdHgsIHgsIHksIHApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcbiAgICBkcmF3X2xhYmVsOiBmdW5jdGlvbiBkcmF3X2xhYmVsKGN0eCwgeCwgeSwgcCkge1xuICAgICAgY3R4LmZpbGxTdHlsZSA9IHRoaXMubGFiZWxfY29sb3I7XG4gICAgICBjdHguZm9udCA9IHRoaXMubmV3X2ZvbnQ7XG4gICAgICBjdHgudGV4dEFsaWduID0gJ2NlbnRlcic7XG4gICAgICBjdHguZmlsbFRleHQocFszXSwgeCwgeSAtIDI1KTtcbiAgICB9LFxuICAgIHVzZV9mb3I6IGZ1bmN0aW9uIHVzZV9mb3IoKSB7XG4gICAgICByZXR1cm4gWydUcmFkZXMnXTtcbiAgICB9LFxuICAgIC8vIERlZmluZXMgbGVnZW5kIGZvcm1hdCAodmFsdWVzICYgY29sb3JzKVxuICAgIGxlZ2VuZDogZnVuY3Rpb24gbGVnZW5kKHZhbHVlcykge1xuICAgICAgc3dpdGNoICh2YWx1ZXNbMV0pIHtcbiAgICAgICAgY2FzZSAwOlxuICAgICAgICAgIHZhciBwb3MgPSAnU2VsbCc7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSAxOlxuICAgICAgICAgIHBvcyA9ICdCdXknO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgcG9zID0gJ1Vua25vd24nO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gW3tcbiAgICAgICAgdmFsdWU6IHBvc1xuICAgICAgfSwge1xuICAgICAgICB2YWx1ZTogdmFsdWVzWzJdLnRvRml4ZWQoNCksXG4gICAgICAgIGNvbG9yOiB0aGlzLiRwcm9wcy5jb2xvcnMudGV4dFxuICAgICAgfV0uY29uY2F0KHZhbHVlc1szXSA/IFt7XG4gICAgICAgIHZhbHVlOiB2YWx1ZXNbM11cbiAgICAgIH1dIDogW10pO1xuICAgIH1cbiAgfSxcbiAgLy8gRGVmaW5lIGludGVybmFsIHNldHRpbmcgJiBjb25zdGFudHMgaGVyZVxuICBjb21wdXRlZDoge1xuICAgIHNldHQ6IGZ1bmN0aW9uIHNldHQoKSB7XG4gICAgICByZXR1cm4gdGhpcy4kcHJvcHMuc2V0dGluZ3M7XG4gICAgfSxcbiAgICBkZWZhdWx0X2ZvbnQ6IGZ1bmN0aW9uIGRlZmF1bHRfZm9udCgpIHtcbiAgICAgIHJldHVybiAnMTJweCAnICsgdGhpcy4kcHJvcHMuZm9udC5zcGxpdCgncHgnKS5wb3AoKTtcbiAgICB9LFxuICAgIGJ1eV9jb2xvcjogZnVuY3Rpb24gYnV5X2NvbG9yKCkge1xuICAgICAgcmV0dXJuIHRoaXMuc2V0dC5idXlDb2xvciB8fCAnIzYzZGY4OSc7XG4gICAgfSxcbiAgICBzZWxsX2NvbG9yOiBmdW5jdGlvbiBzZWxsX2NvbG9yKCkge1xuICAgICAgcmV0dXJuIHRoaXMuc2V0dC5zZWxsQ29sb3IgfHwgJyNlYzQ2NjInO1xuICAgIH0sXG4gICAgbGFiZWxfY29sb3I6IGZ1bmN0aW9uIGxhYmVsX2NvbG9yKCkge1xuICAgICAgcmV0dXJuIHRoaXMuc2V0dC5sYWJlbENvbG9yIHx8ICcjOTk5JztcbiAgICB9LFxuICAgIG1hcmtlcl9zaXplOiBmdW5jdGlvbiBtYXJrZXJfc2l6ZSgpIHtcbiAgICAgIHJldHVybiB0aGlzLnNldHQubWFya2VyU2l6ZSB8fCA1O1xuICAgIH0sXG4gICAgc2hvd19sYWJlbDogZnVuY3Rpb24gc2hvd19sYWJlbCgpIHtcbiAgICAgIHJldHVybiB0aGlzLnNldHQuc2hvd0xhYmVsICE9PSBmYWxzZTtcbiAgICB9LFxuICAgIG5ld19mb250OiBmdW5jdGlvbiBuZXdfZm9udCgpIHtcbiAgICAgIHJldHVybiB0aGlzLnNldHQuZm9udCB8fCB0aGlzLmRlZmF1bHRfZm9udDtcbiAgICB9XG4gIH1cbn0pO1xuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL2NvbXBvbmVudHMvb3ZlcmxheXMvVHJhZGVzLnZ1ZT92dWUmdHlwZT1zY3JpcHQmbGFuZz1qcyZcbiAvKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIGNvbnN0IG92ZXJsYXlzX1RyYWRlc3Z1ZV90eXBlX3NjcmlwdF9sYW5nX2pzXyA9IChUcmFkZXN2dWVfdHlwZV9zY3JpcHRfbGFuZ19qc18pOyBcbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9jb21wb25lbnRzL292ZXJsYXlzL1RyYWRlcy52dWVcbnZhciBUcmFkZXNfcmVuZGVyLCBUcmFkZXNfc3RhdGljUmVuZGVyRm5zXG47XG5cblxuXG4vKiBub3JtYWxpemUgY29tcG9uZW50ICovXG47XG52YXIgVHJhZGVzX2NvbXBvbmVudCA9IG5vcm1hbGl6ZUNvbXBvbmVudChcbiAgb3ZlcmxheXNfVHJhZGVzdnVlX3R5cGVfc2NyaXB0X2xhbmdfanNfLFxuICBUcmFkZXNfcmVuZGVyLFxuICBUcmFkZXNfc3RhdGljUmVuZGVyRm5zLFxuICBmYWxzZSxcbiAgbnVsbCxcbiAgbnVsbCxcbiAgbnVsbFxuICBcbilcblxuLyogaG90IHJlbG9hZCAqL1xuaWYgKGZhbHNlKSB7IHZhciBUcmFkZXNfYXBpOyB9XG5UcmFkZXNfY29tcG9uZW50Lm9wdGlvbnMuX19maWxlID0gXCJzcmMvY29tcG9uZW50cy9vdmVybGF5cy9UcmFkZXMudnVlXCJcbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gY29uc3QgVHJhZGVzID0gKFRyYWRlc19jb21wb25lbnQuZXhwb3J0cyk7XG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9ub2RlX21vZHVsZXMvYmFiZWwtbG9hZGVyL2xpYi9pbmRleC5qcyEuL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9pbmRleC5qcz8/dnVlLWxvYWRlci1vcHRpb25zIS4vc3JjL2NvbXBvbmVudHMvb3ZlcmxheXMvQ2hhbm5lbC52dWU/dnVlJnR5cGU9c2NyaXB0Jmxhbmc9anMmXG4vLyBDaGFubmVsIHJlbmRlcmVyLiAoS2VsdG5lciwgQm9sbGluZ2VyKVxuLy8gVE9ETzogYWxsb3cgY29sb3IgdHJhbnNwYXJlbmN5XG4vLyBUT0RPOiBpbXByb3ZlIHBlcmZvcm1hbmNlOiBkcmF3IGluIG9uZSBzb2xpZCBjaHVua1xuXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIGNvbnN0IENoYW5uZWx2dWVfdHlwZV9zY3JpcHRfbGFuZ19qc18gPSAoe1xuICBuYW1lOiAnQ2hhbm5lbCcsXG4gIG1peGluczogW292ZXJsYXldLFxuICBtZXRob2RzOiB7XG4gICAgbWV0YV9pbmZvOiBmdW5jdGlvbiBtZXRhX2luZm8oKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBhdXRob3I6ICdDNDUxJyxcbiAgICAgICAgdmVyc2lvbjogJzEuMC4xJ1xuICAgICAgfTtcbiAgICB9LFxuXG4gICAgLypkcmF3KGN0eCkge1xuICAgICAgICBjdHgubGluZVdpZHRoID0gdGhpcy5saW5lX3dpZHRoXG4gICAgICAgIGN0eC5zdHJva2VTdHlsZSA9IHRoaXMuY29sb3JcbiAgICAgICAgY3R4LmZpbGxTdHlsZSA9IHRoaXMuYmFja19jb2xvclxuICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLiRwcm9wcy5kYXRhLmxlbmd0aCAtIDE7IGkrKykge1xuICAgICAgICAgICAgICBsZXQgcDEgPSB0aGlzLm1hcHAodGhpcy4kcHJvcHMuZGF0YVtpXSlcbiAgICAgICAgICAgIGxldCBwMiA9IHRoaXMubWFwcCh0aGlzLiRwcm9wcy5kYXRhW2krMV0pXG4gICAgICAgICAgICAgaWYgKCFwMikgY29udGludWVcbiAgICAgICAgICAgIGlmIChwMS55MSAhPT0gcDEueTEpIGNvbnRpbnVlIC8vIEZpeCBOYU5cbiAgICAgICAgICAgICAvLyBCYWNrZ3JvdW5kXG4gICAgICAgICAgICBjdHguYmVnaW5QYXRoKClcbiAgICAgICAgICAgIGN0eC5tb3ZlVG8ocDEueCwgcDEueTEpXG4gICAgICAgICAgICBjdHgubGluZVRvKHAyLnggKyAwLjEsIHAyLnkxKVxuICAgICAgICAgICAgY3R4LmxpbmVUbyhwMi54ICsgMC4xLCBwMi55MylcbiAgICAgICAgICAgIGN0eC5saW5lVG8ocDEueCwgcDEueTMpXG4gICAgICAgICAgICBjdHguZmlsbCgpXG4gICAgICAgICAgICAgLy8gTGluZXNcbiAgICAgICAgICAgIGN0eC5iZWdpblBhdGgoKVxuICAgICAgICAgICAgY3R4Lm1vdmVUbyhwMS54LCBwMS55MSlcbiAgICAgICAgICAgIGN0eC5saW5lVG8ocDIueCwgcDIueTEpXG4gICAgICAgICAgICBpZiAodGhpcy5zaG93X21pZCkge1xuICAgICAgICAgICAgICAgIGN0eC5tb3ZlVG8ocDEueCwgcDEueTIpXG4gICAgICAgICAgICAgICAgY3R4LmxpbmVUbyhwMi54LCBwMi55MilcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGN0eC5tb3ZlVG8ocDEueCwgcDEueTMpXG4gICAgICAgICAgICBjdHgubGluZVRvKHAyLngsIHAyLnkzKVxuICAgICAgICAgICAgY3R4LnN0cm9rZSgpXG4gICAgICAgICB9XG4gICAgfSwqL1xuICAgIGRyYXc6IGZ1bmN0aW9uIGRyYXcoY3R4KSB7XG4gICAgICAvLyBCYWNrZ3JvdW5kXG4gICAgICB2YXIgZGF0YSA9IHRoaXMuZGF0YTtcbiAgICAgIHZhciBsYXlvdXQgPSB0aGlzLmxheW91dDtcbiAgICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICAgIGN0eC5maWxsU3R5bGUgPSB0aGlzLmJhY2tfY29sb3I7XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZGF0YS5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgcCA9IGRhdGFbaV07XG4gICAgICAgIHZhciB4ID0gbGF5b3V0LnQyc2NyZWVuKHBbMF0pO1xuICAgICAgICB2YXIgeSA9IGxheW91dC4kMnNjcmVlbihwWzFdIHx8IHVuZGVmaW5lZCk7XG4gICAgICAgIGN0eC5saW5lVG8oeCwgeSk7XG4gICAgICB9XG5cbiAgICAgIGZvciAodmFyIGkgPSBkYXRhLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgIHZhciBfcCA9IGRhdGFbaV07XG5cbiAgICAgICAgdmFyIF94ID0gbGF5b3V0LnQyc2NyZWVuKF9wWzBdKTtcblxuICAgICAgICB2YXIgX3kgPSBsYXlvdXQuJDJzY3JlZW4oX3BbM10gfHwgdW5kZWZpbmVkKTtcblxuICAgICAgICBjdHgubGluZVRvKF94LCBfeSk7XG4gICAgICB9XG5cbiAgICAgIGN0eC5maWxsKCk7IC8vIExpbmVzXG5cbiAgICAgIGN0eC5saW5lV2lkdGggPSB0aGlzLmxpbmVfd2lkdGg7XG4gICAgICBjdHguc3Ryb2tlU3R5bGUgPSB0aGlzLmNvbG9yOyAvLyBUb3AgbGluZVxuXG4gICAgICBjdHguYmVnaW5QYXRoKCk7XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZGF0YS5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgX3AyID0gZGF0YVtpXTtcblxuICAgICAgICB2YXIgX3gyID0gbGF5b3V0LnQyc2NyZWVuKF9wMlswXSk7XG5cbiAgICAgICAgdmFyIF95MiA9IGxheW91dC4kMnNjcmVlbihfcDJbMV0gfHwgdW5kZWZpbmVkKTtcblxuICAgICAgICBjdHgubGluZVRvKF94MiwgX3kyKTtcbiAgICAgIH1cblxuICAgICAgY3R4LnN0cm9rZSgpOyAvLyBCb3R0b20gbGluZVxuXG4gICAgICBjdHguYmVnaW5QYXRoKCk7XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZGF0YS5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgX3AzID0gZGF0YVtpXTtcblxuICAgICAgICB2YXIgX3gzID0gbGF5b3V0LnQyc2NyZWVuKF9wM1swXSk7XG5cbiAgICAgICAgdmFyIF95MyA9IGxheW91dC4kMnNjcmVlbihfcDNbM10gfHwgdW5kZWZpbmVkKTtcblxuICAgICAgICBjdHgubGluZVRvKF94MywgX3kzKTtcbiAgICAgIH1cblxuICAgICAgY3R4LnN0cm9rZSgpOyAvLyBNaWRkbGUgbGluZVxuXG4gICAgICBpZiAoIXRoaXMuc2hvd19taWQpIHJldHVybjtcbiAgICAgIGN0eC5iZWdpblBhdGgoKTtcblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBkYXRhLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBfcDQgPSBkYXRhW2ldO1xuXG4gICAgICAgIHZhciBfeDQgPSBsYXlvdXQudDJzY3JlZW4oX3A0WzBdKTtcblxuICAgICAgICB2YXIgX3k0ID0gbGF5b3V0LiQyc2NyZWVuKF9wNFsyXSB8fCB1bmRlZmluZWQpO1xuXG4gICAgICAgIGN0eC5saW5lVG8oX3g0LCBfeTQpO1xuICAgICAgfVxuXG4gICAgICBjdHguc3Ryb2tlKCk7XG4gICAgfSxcbiAgICBtYXBwOiBmdW5jdGlvbiBtYXBwKHApIHtcbiAgICAgIHZhciBsYXlvdXQgPSB0aGlzLiRwcm9wcy5sYXlvdXQ7XG4gICAgICByZXR1cm4gcCAmJiB7XG4gICAgICAgIHg6IGxheW91dC50MnNjcmVlbihwWzBdKSxcbiAgICAgICAgeTE6IGxheW91dC4kMnNjcmVlbihwWzFdKSxcbiAgICAgICAgeTI6IGxheW91dC4kMnNjcmVlbihwWzJdKSxcbiAgICAgICAgeTM6IGxheW91dC4kMnNjcmVlbihwWzNdKVxuICAgICAgfTtcbiAgICB9LFxuICAgIHVzZV9mb3I6IGZ1bmN0aW9uIHVzZV9mb3IoKSB7XG4gICAgICByZXR1cm4gWydDaGFubmVsJywgJ0tDJywgJ0JCJ107XG4gICAgfSxcbiAgICBkYXRhX2NvbG9yczogZnVuY3Rpb24gZGF0YV9jb2xvcnMoKSB7XG4gICAgICByZXR1cm4gW3RoaXMuY29sb3IsIHRoaXMuY29sb3IsIHRoaXMuY29sb3JdO1xuICAgIH1cbiAgfSxcbiAgLy8gRGVmaW5lIGludGVybmFsIHNldHRpbmcgJiBjb25zdGFudHMgaGVyZVxuICBjb21wdXRlZDoge1xuICAgIHNldHQ6IGZ1bmN0aW9uIHNldHQoKSB7XG4gICAgICByZXR1cm4gdGhpcy4kcHJvcHMuc2V0dGluZ3M7XG4gICAgfSxcbiAgICBsaW5lX3dpZHRoOiBmdW5jdGlvbiBsaW5lX3dpZHRoKCkge1xuICAgICAgcmV0dXJuIHRoaXMuc2V0dC5saW5lV2lkdGggfHwgMC43NTtcbiAgICB9LFxuICAgIGNvbG9yOiBmdW5jdGlvbiBjb2xvcigpIHtcbiAgICAgIHZhciBuID0gdGhpcy4kcHJvcHMubnVtICUgNTtcbiAgICAgIHJldHVybiB0aGlzLnNldHQuY29sb3IgfHwgdGhpcy5DT0xPUlNbbl07XG4gICAgfSxcbiAgICBzaG93X21pZDogZnVuY3Rpb24gc2hvd19taWQoKSB7XG4gICAgICByZXR1cm4gJ3Nob3dNaWQnIGluIHRoaXMuc2V0dCA/IHRoaXMuc2V0dC5zaG93TWlkIDogdHJ1ZTtcbiAgICB9LFxuICAgIGJhY2tfY29sb3I6IGZ1bmN0aW9uIGJhY2tfY29sb3IoKSB7XG4gICAgICByZXR1cm4gdGhpcy5zZXR0LmJhY2tDb2xvciB8fCB0aGlzLmNvbG9yICsgJzExJztcbiAgICB9XG4gIH0sXG4gIGRhdGE6IGZ1bmN0aW9uIGRhdGEoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIENPTE9SUzogWycjNDJiMjhhJywgJyM1NjkxY2UnLCAnIzYxMmZmOScsICcjZDUwYjkwJywgJyNmZjIzMTYnXVxuICAgIH07XG4gIH1cbn0pO1xuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL2NvbXBvbmVudHMvb3ZlcmxheXMvQ2hhbm5lbC52dWU/dnVlJnR5cGU9c2NyaXB0Jmxhbmc9anMmXG4gLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyBjb25zdCBvdmVybGF5c19DaGFubmVsdnVlX3R5cGVfc2NyaXB0X2xhbmdfanNfID0gKENoYW5uZWx2dWVfdHlwZV9zY3JpcHRfbGFuZ19qc18pOyBcbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9jb21wb25lbnRzL292ZXJsYXlzL0NoYW5uZWwudnVlXG52YXIgQ2hhbm5lbF9yZW5kZXIsIENoYW5uZWxfc3RhdGljUmVuZGVyRm5zXG47XG5cblxuXG4vKiBub3JtYWxpemUgY29tcG9uZW50ICovXG47XG52YXIgQ2hhbm5lbF9jb21wb25lbnQgPSBub3JtYWxpemVDb21wb25lbnQoXG4gIG92ZXJsYXlzX0NoYW5uZWx2dWVfdHlwZV9zY3JpcHRfbGFuZ19qc18sXG4gIENoYW5uZWxfcmVuZGVyLFxuICBDaGFubmVsX3N0YXRpY1JlbmRlckZucyxcbiAgZmFsc2UsXG4gIG51bGwsXG4gIG51bGwsXG4gIG51bGxcbiAgXG4pXG5cbi8qIGhvdCByZWxvYWQgKi9cbmlmIChmYWxzZSkgeyB2YXIgQ2hhbm5lbF9hcGk7IH1cbkNoYW5uZWxfY29tcG9uZW50Lm9wdGlvbnMuX19maWxlID0gXCJzcmMvY29tcG9uZW50cy9vdmVybGF5cy9DaGFubmVsLnZ1ZVwiXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIGNvbnN0IENoYW5uZWwgPSAoQ2hhbm5lbF9jb21wb25lbnQuZXhwb3J0cyk7XG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9ub2RlX21vZHVsZXMvYmFiZWwtbG9hZGVyL2xpYi9pbmRleC5qcyEuL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9pbmRleC5qcz8/dnVlLWxvYWRlci1vcHRpb25zIS4vc3JjL2NvbXBvbmVudHMvb3ZlcmxheXMvU2VnbWVudC52dWU/dnVlJnR5cGU9c2NyaXB0Jmxhbmc9anMmXG4vLyBTZWdtZW50IHJlbmRlcmVyLlxuXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIGNvbnN0IFNlZ21lbnR2dWVfdHlwZV9zY3JpcHRfbGFuZ19qc18gPSAoe1xuICBuYW1lOiAnU2VnbWVudCcsXG4gIG1peGluczogW292ZXJsYXldLFxuICBtZXRob2RzOiB7XG4gICAgbWV0YV9pbmZvOiBmdW5jdGlvbiBtZXRhX2luZm8oKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBhdXRob3I6ICdDNDUxJyxcbiAgICAgICAgdmVyc2lvbjogJzEuMC4wJ1xuICAgICAgfTtcbiAgICB9LFxuICAgIGRyYXc6IGZ1bmN0aW9uIGRyYXcoY3R4KSB7XG4gICAgICBpZiAoIXRoaXMucDEgfHwgIXRoaXMucDIpIHJldHVybjtcbiAgICAgIGN0eC5saW5lV2lkdGggPSB0aGlzLmxpbmVfd2lkdGg7XG4gICAgICBjdHguc3Ryb2tlU3R5bGUgPSB0aGlzLmNvbG9yO1xuICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgdmFyIGxheW91dCA9IHRoaXMuJHByb3BzLmxheW91dDtcbiAgICAgIHZhciB4MSA9IGxheW91dC50MnNjcmVlbih0aGlzLnAxWzBdKTtcbiAgICAgIHZhciB5MSA9IGxheW91dC4kMnNjcmVlbih0aGlzLnAxWzFdKTtcbiAgICAgIGN0eC5tb3ZlVG8oeDEsIHkxKTtcbiAgICAgIHZhciB4MiA9IGxheW91dC50MnNjcmVlbih0aGlzLnAyWzBdKTtcbiAgICAgIHZhciB5MiA9IGxheW91dC4kMnNjcmVlbih0aGlzLnAyWzFdKTtcbiAgICAgIGN0eC5saW5lVG8oeDIsIHkyKTtcbiAgICAgIGN0eC5zdHJva2UoKTtcbiAgICB9LFxuICAgIHVzZV9mb3I6IGZ1bmN0aW9uIHVzZV9mb3IoKSB7XG4gICAgICByZXR1cm4gWydTZWdtZW50J107XG4gICAgfSxcbiAgICBkYXRhX2NvbG9yczogZnVuY3Rpb24gZGF0YV9jb2xvcnMoKSB7XG4gICAgICByZXR1cm4gW3RoaXMuY29sb3JdO1xuICAgIH1cbiAgfSxcbiAgLy8gRGVmaW5lIGludGVybmFsIHNldHRpbmcgJiBjb25zdGFudHMgaGVyZVxuICBjb21wdXRlZDoge1xuICAgIHNldHQ6IGZ1bmN0aW9uIHNldHQoKSB7XG4gICAgICByZXR1cm4gdGhpcy4kcHJvcHMuc2V0dGluZ3M7XG4gICAgfSxcbiAgICBwMTogZnVuY3Rpb24gcDEoKSB7XG4gICAgICByZXR1cm4gdGhpcy4kcHJvcHMuc2V0dGluZ3MucDE7XG4gICAgfSxcbiAgICBwMjogZnVuY3Rpb24gcDIoKSB7XG4gICAgICByZXR1cm4gdGhpcy4kcHJvcHMuc2V0dGluZ3MucDI7XG4gICAgfSxcbiAgICBsaW5lX3dpZHRoOiBmdW5jdGlvbiBsaW5lX3dpZHRoKCkge1xuICAgICAgcmV0dXJuIHRoaXMuc2V0dC5saW5lV2lkdGggfHwgMC45O1xuICAgIH0sXG4gICAgY29sb3I6IGZ1bmN0aW9uIGNvbG9yKCkge1xuICAgICAgdmFyIG4gPSB0aGlzLiRwcm9wcy5udW0gJSA1O1xuICAgICAgcmV0dXJuIHRoaXMuc2V0dC5jb2xvciB8fCB0aGlzLkNPTE9SU1tuXTtcbiAgICB9XG4gIH0sXG4gIGRhdGE6IGZ1bmN0aW9uIGRhdGEoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIENPTE9SUzogWycjNDJiMjhhJywgJyM1NjkxY2UnLCAnIzYxMmZmOScsICcjZDUwYjkwJywgJyNmZjIzMTYnXVxuICAgIH07XG4gIH1cbn0pO1xuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL2NvbXBvbmVudHMvb3ZlcmxheXMvU2VnbWVudC52dWU/dnVlJnR5cGU9c2NyaXB0Jmxhbmc9anMmXG4gLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyBjb25zdCBvdmVybGF5c19TZWdtZW50dnVlX3R5cGVfc2NyaXB0X2xhbmdfanNfID0gKFNlZ21lbnR2dWVfdHlwZV9zY3JpcHRfbGFuZ19qc18pOyBcbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9jb21wb25lbnRzL292ZXJsYXlzL1NlZ21lbnQudnVlXG52YXIgU2VnbWVudF9yZW5kZXIsIFNlZ21lbnRfc3RhdGljUmVuZGVyRm5zXG47XG5cblxuXG4vKiBub3JtYWxpemUgY29tcG9uZW50ICovXG47XG52YXIgU2VnbWVudF9jb21wb25lbnQgPSBub3JtYWxpemVDb21wb25lbnQoXG4gIG92ZXJsYXlzX1NlZ21lbnR2dWVfdHlwZV9zY3JpcHRfbGFuZ19qc18sXG4gIFNlZ21lbnRfcmVuZGVyLFxuICBTZWdtZW50X3N0YXRpY1JlbmRlckZucyxcbiAgZmFsc2UsXG4gIG51bGwsXG4gIG51bGwsXG4gIG51bGxcbiAgXG4pXG5cbi8qIGhvdCByZWxvYWQgKi9cbmlmIChmYWxzZSkgeyB2YXIgU2VnbWVudF9hcGk7IH1cblNlZ21lbnRfY29tcG9uZW50Lm9wdGlvbnMuX19maWxlID0gXCJzcmMvY29tcG9uZW50cy9vdmVybGF5cy9TZWdtZW50LnZ1ZVwiXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIGNvbnN0IFNlZ21lbnQgPSAoU2VnbWVudF9jb21wb25lbnQuZXhwb3J0cyk7XG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvY29tcG9uZW50cy9qcy9sYXlvdXRfY252LmpzXG5cblxuLy8gQ2xhY3VsYXRlcyBwb3N0aW9ucyBhbmQgc2l6ZXMgZm9yIGNhbmRsZXN0aWNrXG4vLyBhbmQgdm9sdW1lIGJhcnMgZm9yIHRoZSBnaXZlbiBzdWJzZXQgb2YgZGF0YVxuXG5mdW5jdGlvbiBsYXlvdXRfY252KHNlbGYpIHtcbiAgdmFyICRwID0gc2VsZi4kcHJvcHM7XG4gIHZhciBzdWIgPSAkcC5kYXRhO1xuICB2YXIgdDJzY3JlZW4gPSAkcC5sYXlvdXQudDJzY3JlZW47XG4gIHZhciBsYXlvdXQgPSAkcC5sYXlvdXQ7XG4gIHZhciBjYW5kbGVzID0gW107XG4gIHZhciB2b2x1bWUgPSBbXTsgLy8gVGhlIHZvbHVtZSBiYXIgaGVpZ2h0IGlzIGRldGVybWluZWQgYXMgYSBwZXJjZW50YWdlIG9mXG4gIC8vIHRoZSBjaGFydCdzIGhlaWdodCAoVk9MU0NBTEUpXG5cbiAgdmFyIG1heHYgPSBNYXRoLm1heC5hcHBseShNYXRoLCBfdG9Db25zdW1hYmxlQXJyYXkoc3ViLm1hcChmdW5jdGlvbiAoeCkge1xuICAgIHJldHVybiB4WzVdO1xuICB9KSkpO1xuICB2YXIgdnMgPSAkcC5jb25maWcuVk9MU0NBTEUgKiBsYXlvdXQuaGVpZ2h0IC8gbWF4djtcbiAgdmFyIHgxLFxuICAgICAgeDIsXG4gICAgICB3LFxuICAgICAgYXZnX3csXG4gICAgICBtaWQsXG4gICAgICBwcmV2ID0gdW5kZWZpbmVkOyAvLyBTdWJzZXQgaW50ZXJ2YWwgYWdhaW5zdCBtYWluIGludGVydmFsXG5cbiAgdmFyIF9uZXdfaW50ZXJ2YWwgPSBuZXdfaW50ZXJ2YWwobGF5b3V0LCAkcCwgc3ViKSxcbiAgICAgIF9uZXdfaW50ZXJ2YWwyID0gX3NsaWNlZFRvQXJyYXkoX25ld19pbnRlcnZhbCwgMiksXG4gICAgICBpbnRlcnZhbDIgPSBfbmV3X2ludGVydmFsMlswXSxcbiAgICAgIHJhdGlvID0gX25ld19pbnRlcnZhbDJbMV07XG5cbiAgdmFyIHB4X3N0ZXAyID0gbGF5b3V0LnB4X3N0ZXAgKiByYXRpbztcbiAgdmFyIHNwbGl0dGVyID0gcHhfc3RlcDIgPiA1ID8gMSA6IDA7IC8vIEEgJiBCIGFyZSBjdXJyZW50IGNoYXJ0IHRyYW5mb3JtYXRpb25zOlxuICAvLyBBID09PSBzY2FsZSwgIEIgPT09IFktYXhpcyBzaGlmdFxuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgc3ViLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIHAgPSBzdWJbaV07XG4gICAgbWlkID0gdDJzY3JlZW4ocFswXSkgKyAxOyAvLyBDbGVhciB2b2x1bWUgYmFyIGlmIHRoZXJlIGlzIGEgdGltZSBnYXBcblxuICAgIGlmIChzdWJbaSAtIDFdICYmIHBbMF0gLSBzdWJbaSAtIDFdWzBdID4gaW50ZXJ2YWwyKSB7XG4gICAgICBwcmV2ID0gbnVsbDtcbiAgICB9XG5cbiAgICB4MSA9IHByZXYgfHwgTWF0aC5mbG9vcihtaWQgLSBweF9zdGVwMiAqIDAuNSk7XG4gICAgeDIgPSBNYXRoLmZsb29yKG1pZCArIHB4X3N0ZXAyICogMC41KSAtIDAuNTsgLy8gVE9ETzogYWRkIGxvZyBzY2FsZSBzdXBwb3J0XG5cbiAgICBjYW5kbGVzLnB1c2goe1xuICAgICAgeDogbWlkLFxuICAgICAgdzogbGF5b3V0LnB4X3N0ZXAgKiAkcC5jb25maWcuQ0FORExFVyAqIHJhdGlvLFxuICAgICAgbzogTWF0aC5mbG9vcihwWzFdICogbGF5b3V0LkEgKyBsYXlvdXQuQiksXG4gICAgICBoOiBNYXRoLmZsb29yKHBbMl0gKiBsYXlvdXQuQSArIGxheW91dC5CKSxcbiAgICAgIGw6IE1hdGguZmxvb3IocFszXSAqIGxheW91dC5BICsgbGF5b3V0LkIpLFxuICAgICAgYzogTWF0aC5mbG9vcihwWzRdICogbGF5b3V0LkEgKyBsYXlvdXQuQiksXG4gICAgICByYXc6IHBcbiAgICB9KTtcbiAgICB2b2x1bWUucHVzaCh7XG4gICAgICB4MTogeDEsXG4gICAgICB4MjogeDIsXG4gICAgICBoOiBwWzVdICogdnMsXG4gICAgICBncmVlbjogcFs0XSA+PSBwWzFdLFxuICAgICAgcmF3OiBwXG4gICAgfSk7XG4gICAgcHJldiA9IHgyICsgc3BsaXR0ZXI7XG4gIH1cblxuICByZXR1cm4ge1xuICAgIGNhbmRsZXM6IGNhbmRsZXMsXG4gICAgdm9sdW1lOiB2b2x1bWVcbiAgfTtcbn1cbmZ1bmN0aW9uIGxheW91dF92b2woc2VsZikge1xuICB2YXIgJHAgPSBzZWxmLiRwcm9wcztcbiAgdmFyIHN1YiA9ICRwLmRhdGE7XG4gIHZhciB0MnNjcmVlbiA9ICRwLmxheW91dC50MnNjcmVlbjtcbiAgdmFyIGxheW91dCA9ICRwLmxheW91dDtcbiAgdmFyIHZvbHVtZSA9IFtdOyAvLyBEZXRlY3QgZGF0YSBzZWNvbmQgZGltZW50aW9uIHNpemU6XG5cbiAgdmFyIGRpbSA9IHN1YlswXSA/IHN1YlswXS5sZW5ndGggOiAwOyAvLyBTdXBwb3J0IHNwZWNpYWwgdm9sdW1lIGRhdGEgKHNlZSBBUEkgYm9vayksIG9yIE9ITENWXG4gIC8vIERhdGEgaW5kaWNlczpcblxuICBzZWxmLl9pMSA9IGRpbSA8IDYgPyAxIDogNTtcbiAgc2VsZi5faTIgPSBkaW0gPCA2ID8gZnVuY3Rpb24gKHApIHtcbiAgICByZXR1cm4gcFsyXTtcbiAgfSA6IGZ1bmN0aW9uIChwKSB7XG4gICAgcmV0dXJuIHBbNF0gPj0gcFsxXTtcbiAgfTtcbiAgdmFyIG1heHYgPSBNYXRoLm1heC5hcHBseShNYXRoLCBfdG9Db25zdW1hYmxlQXJyYXkoc3ViLm1hcChmdW5jdGlvbiAoeCkge1xuICAgIHJldHVybiB4W3NlbGYuX2kxXTtcbiAgfSkpKTtcbiAgdmFyIHZvbHNjYWxlID0gc2VsZi52b2xzY2FsZSB8fCAkcC5jb25maWcuVk9MU0NBTEU7XG4gIHZhciB2cyA9IHZvbHNjYWxlICogbGF5b3V0LmhlaWdodCAvIG1heHY7XG4gIHZhciB4MSxcbiAgICAgIHgyLFxuICAgICAgbWlkLFxuICAgICAgcHJldiA9IHVuZGVmaW5lZDsgLy8gU3Vic2V0IGludGVydmFsIGFnYWluc3QgbWFpbiBpbnRlcnZhbFxuXG4gIHZhciBfbmV3X2ludGVydmFsMyA9IG5ld19pbnRlcnZhbChsYXlvdXQsICRwLCBzdWIpLFxuICAgICAgX25ld19pbnRlcnZhbDQgPSBfc2xpY2VkVG9BcnJheShfbmV3X2ludGVydmFsMywgMiksXG4gICAgICBpbnRlcnZhbDIgPSBfbmV3X2ludGVydmFsNFswXSxcbiAgICAgIHJhdGlvID0gX25ld19pbnRlcnZhbDRbMV07XG5cbiAgdmFyIHB4X3N0ZXAyID0gbGF5b3V0LnB4X3N0ZXAgKiByYXRpbztcbiAgdmFyIHNwbGl0dGVyID0gcHhfc3RlcDIgPiA1ID8gMSA6IDA7IC8vIEEgJiBCIGFyZSBjdXJyZW50IGNoYXJ0IHRyYW5mb3JtYXRpb25zOlxuICAvLyBBID09PSBzY2FsZSwgIEIgPT09IFktYXhpcyBzaGlmdFxuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgc3ViLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIHAgPSBzdWJbaV07XG4gICAgbWlkID0gdDJzY3JlZW4ocFswXSkgKyAxOyAvLyBDbGVhciB2b2x1bWUgYmFyIGlmIHRoZXJlIGlzIGEgdGltZSBnYXBcblxuICAgIGlmIChzdWJbaSAtIDFdICYmIHBbMF0gLSBzdWJbaSAtIDFdWzBdID4gaW50ZXJ2YWwyKSB7XG4gICAgICBwcmV2ID0gbnVsbDtcbiAgICB9XG5cbiAgICB4MSA9IHByZXYgfHwgTWF0aC5mbG9vcihtaWQgLSBweF9zdGVwMiAqIDAuNSk7XG4gICAgeDIgPSBNYXRoLmZsb29yKG1pZCArIHB4X3N0ZXAyICogMC41KSAtIDAuNTtcbiAgICB2b2x1bWUucHVzaCh7XG4gICAgICB4MTogeDEsXG4gICAgICB4MjogeDIsXG4gICAgICBoOiBwW3NlbGYuX2kxXSAqIHZzLFxuICAgICAgZ3JlZW46IHNlbGYuX2kyKHApLFxuICAgICAgcmF3OiBwXG4gICAgfSk7XG4gICAgcHJldiA9IHgyICsgc3BsaXR0ZXI7XG4gIH1cblxuICByZXR1cm4gdm9sdW1lO1xufVxuXG5mdW5jdGlvbiBuZXdfaW50ZXJ2YWwobGF5b3V0LCAkcCwgc3ViKSB7XG4gIC8vIFN1YnNldCBpbnRlcnZhbCBhZ2FpbnN0IG1haW4gaW50ZXJ2YWxcbiAgaWYgKCFsYXlvdXQudGlfbWFwLmliKSB7XG4gICAgdmFyIGludGVydmFsMiA9ICRwLnRmIHx8IHV0aWxzLmRldGVjdF9pbnRlcnZhbChzdWIpO1xuICAgIHZhciByYXRpbyA9IGludGVydmFsMiAvICRwLmludGVydmFsO1xuICB9IGVsc2Uge1xuICAgIGlmICgkcC50Zikge1xuICAgICAgdmFyIHJhdGlvID0gJHAudGYgLyBsYXlvdXQudGlfbWFwLnRmO1xuICAgICAgdmFyIGludGVydmFsMiA9IHJhdGlvO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgaW50ZXJ2YWwyID0gdXRpbHMuZGV0ZWN0X2ludGVydmFsKHN1Yik7XG4gICAgICB2YXIgcmF0aW8gPSBpbnRlcnZhbDIgLyAkcC5pbnRlcnZhbDtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gW2ludGVydmFsMiwgcmF0aW9dO1xufVxuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL2NvbXBvbmVudHMvcHJpbWl0aXZlcy9jYW5kbGUuanNcblxuXG5cbi8vIENhbmRsZSBvYmplY3QgZm9yIENhbmRsZXMgb3ZlcmxheVxudmFyIENhbmRsZUV4dCA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIENhbmRsZUV4dChvdmVybGF5LCBjdHgsIGRhdGEpIHtcbiAgICBjbGFzc0NhbGxDaGVja19jbGFzc0NhbGxDaGVjayh0aGlzLCBDYW5kbGVFeHQpO1xuXG4gICAgdGhpcy5jdHggPSBjdHg7XG4gICAgdGhpcy5zZWxmID0gb3ZlcmxheTtcbiAgICB0aGlzLnN0eWxlID0gZGF0YS5yYXdbNl0gfHwgdGhpcy5zZWxmO1xuICAgIHRoaXMuZHJhdyhkYXRhKTtcbiAgfVxuXG4gIGNyZWF0ZUNsYXNzX2NyZWF0ZUNsYXNzKENhbmRsZUV4dCwgW3tcbiAgICBrZXk6IFwiZHJhd1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBkcmF3KGRhdGEpIHtcbiAgICAgIHZhciBncmVlbiA9IGRhdGEucmF3WzRdID49IGRhdGEucmF3WzFdO1xuICAgICAgdmFyIGJvZHlfY29sb3IgPSBncmVlbiA/IHRoaXMuc3R5bGUuY29sb3JDYW5kbGVVcCA6IHRoaXMuc3R5bGUuY29sb3JDYW5kbGVEdztcbiAgICAgIHZhciB3aWNrX2NvbG9yID0gZ3JlZW4gPyB0aGlzLnN0eWxlLmNvbG9yV2lja1VwIDogdGhpcy5zdHlsZS5jb2xvcldpY2tEdztcbiAgICAgIHZhciB3ID0gTWF0aC5tYXgoZGF0YS53LCAxKTtcbiAgICAgIHZhciBodyA9IE1hdGgubWF4KE1hdGguZmxvb3IodyAqIDAuNSksIDEpO1xuICAgICAgdmFyIGggPSBNYXRoLmFicyhkYXRhLm8gLSBkYXRhLmMpO1xuICAgICAgdmFyIG1heF9oID0gZGF0YS5jID09PSBkYXRhLm8gPyAxIDogMjtcbiAgICAgIHZhciB4MDUgPSBNYXRoLmZsb29yKGRhdGEueCkgLSAwLjU7XG4gICAgICB0aGlzLmN0eC5zdHJva2VTdHlsZSA9IHdpY2tfY29sb3I7XG4gICAgICB0aGlzLmN0eC5iZWdpblBhdGgoKTtcbiAgICAgIHRoaXMuY3R4Lm1vdmVUbyh4MDUsIE1hdGguZmxvb3IoZGF0YS5oKSk7XG4gICAgICB0aGlzLmN0eC5saW5lVG8oeDA1LCBNYXRoLmZsb29yKGRhdGEubCkpO1xuICAgICAgdGhpcy5jdHguc3Ryb2tlKCk7XG5cbiAgICAgIGlmIChkYXRhLncgPiAxLjUpIHtcbiAgICAgICAgdGhpcy5jdHguZmlsbFN0eWxlID0gYm9keV9jb2xvcjsgLy8gVE9ETzogTW92ZSBjb21tb24gY2FsY3VsYXRpb25zIHRvIGxheW91dC5qc1xuXG4gICAgICAgIHZhciBzID0gZ3JlZW4gPyAxIDogLTE7XG4gICAgICAgIHRoaXMuY3R4LmZpbGxSZWN0KE1hdGguZmxvb3IoZGF0YS54IC0gaHcgLSAxKSwgZGF0YS5jLCBNYXRoLmZsb29yKGh3ICogMiArIDEpLCBzICogTWF0aC5tYXgoaCwgbWF4X2gpKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuY3R4LnN0cm9rZVN0eWxlID0gYm9keV9jb2xvcjtcbiAgICAgICAgdGhpcy5jdHguYmVnaW5QYXRoKCk7XG4gICAgICAgIHRoaXMuY3R4Lm1vdmVUbyh4MDUsIE1hdGguZmxvb3IoTWF0aC5taW4oZGF0YS5vLCBkYXRhLmMpKSk7XG4gICAgICAgIHRoaXMuY3R4LmxpbmVUbyh4MDUsIE1hdGguZmxvb3IoTWF0aC5tYXgoZGF0YS5vLCBkYXRhLmMpKSArIChkYXRhLm8gPT09IGRhdGEuYyA/IDEgOiAwKSk7XG4gICAgICAgIHRoaXMuY3R4LnN0cm9rZSgpO1xuICAgICAgfVxuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBDYW5kbGVFeHQ7XG59KCk7XG5cblxuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL2NvbXBvbmVudHMvcHJpbWl0aXZlcy92b2xiYXIuanNcblxuXG5cbnZhciBWb2xiYXJFeHQgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBWb2xiYXJFeHQob3ZlcmxheSwgY3R4LCBkYXRhKSB7XG4gICAgY2xhc3NDYWxsQ2hlY2tfY2xhc3NDYWxsQ2hlY2sodGhpcywgVm9sYmFyRXh0KTtcblxuICAgIHRoaXMuY3R4ID0gY3R4O1xuICAgIHRoaXMuJHAgPSBvdmVybGF5LiRwcm9wcztcbiAgICB0aGlzLnNlbGYgPSBvdmVybGF5O1xuICAgIHRoaXMuc3R5bGUgPSBkYXRhLnJhd1s2XSB8fCB0aGlzLnNlbGY7XG4gICAgdGhpcy5kcmF3KGRhdGEpO1xuICB9XG5cbiAgY3JlYXRlQ2xhc3NfY3JlYXRlQ2xhc3MoVm9sYmFyRXh0LCBbe1xuICAgIGtleTogXCJkcmF3XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGRyYXcoZGF0YSkge1xuICAgICAgdmFyIHkwID0gdGhpcy4kcC5sYXlvdXQuaGVpZ2h0O1xuICAgICAgdmFyIHcgPSBkYXRhLngyIC0gZGF0YS54MTtcbiAgICAgIHZhciBoID0gTWF0aC5mbG9vcihkYXRhLmgpO1xuICAgICAgdGhpcy5jdHguZmlsbFN0eWxlID0gZGF0YS5ncmVlbiA/IHRoaXMuc3R5bGUuY29sb3JWb2xVcCA6IHRoaXMuc3R5bGUuY29sb3JWb2xEdztcbiAgICAgIHRoaXMuY3R4LmZpbGxSZWN0KE1hdGguZmxvb3IoZGF0YS54MSksIE1hdGguZmxvb3IoeTAgLSBoIC0gMC41KSwgTWF0aC5mbG9vcih3KSwgTWF0aC5mbG9vcihoICsgMSkpO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBWb2xiYXJFeHQ7XG59KCk7XG5cblxuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL2NvbXBvbmVudHMvcHJpbWl0aXZlcy9wcmljZS5qc1xuXG5cblxuLy8gUHJpY2UgYmFyICYgcHJpY2UgbGluZSAoc2hhZGVyKVxudmFyIFByaWNlID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gUHJpY2UoY29tcCkge1xuICAgIGNsYXNzQ2FsbENoZWNrX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFByaWNlKTtcblxuICAgIHRoaXMuY29tcCA9IGNvbXA7XG4gIH0gLy8gRGVmaW5lcyBhbiBpbmxpbmUgc2hhZGVyIChoYXMgYWNjZXNzIHRvIGJvdGhcbiAgLy8gdGFyZ2V0ICYgb3ZlcmxheSdzIGNvbnRleHRzKVxuXG5cbiAgY3JlYXRlQ2xhc3NfY3JlYXRlQ2xhc3MoUHJpY2UsIFt7XG4gICAga2V5OiBcImluaXRfc2hhZGVyXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGluaXRfc2hhZGVyKCkge1xuICAgICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgICAgdmFyIGxheW91dCA9IHRoaXMuY29tcC4kcHJvcHMubGF5b3V0O1xuICAgICAgdmFyIGNvbmZpZyA9IHRoaXMuY29tcC4kcHJvcHMuY29uZmlnO1xuICAgICAgdmFyIGNvbXAgPSB0aGlzLmNvbXA7XG5cbiAgICAgIHZhciBsYXN0X2JhciA9IGZ1bmN0aW9uIGxhc3RfYmFyKCkge1xuICAgICAgICByZXR1cm4gX3RoaXMubGFzdF9iYXIoKTtcbiAgICAgIH07XG5cbiAgICAgIHRoaXMuY29tcC4kZW1pdCgnbmV3LXNoYWRlcicsIHtcbiAgICAgICAgdGFyZ2V0OiAnc2lkZWJhcicsXG4gICAgICAgIGRyYXc6IGZ1bmN0aW9uIGRyYXcoY3R4KSB7XG4gICAgICAgICAgdmFyIGJhciA9IGxhc3RfYmFyKCk7XG4gICAgICAgICAgaWYgKCFiYXIpIHJldHVybjtcbiAgICAgICAgICB2YXIgdyA9IGN0eC5jYW52YXMud2lkdGg7XG4gICAgICAgICAgdmFyIGggPSBjb25maWcuUEFOSEVJR0hUO1xuICAgICAgICAgIHZhciBsYmwgPSBiYXIucHJpY2UudG9GaXhlZChsYXlvdXQucHJlYyk7XG4gICAgICAgICAgY3R4LmZpbGxTdHlsZSA9IGJhci5jb2xvcjtcbiAgICAgICAgICB2YXIgeCA9IC0wLjU7XG4gICAgICAgICAgdmFyIHkgPSBiYXIueSAtIGggKiAwLjUgLSAwLjU7XG4gICAgICAgICAgdmFyIGEgPSA3O1xuICAgICAgICAgIGN0eC5maWxsUmVjdCh4IC0gMC41LCB5LCB3ICsgMSwgaCk7XG4gICAgICAgICAgY3R4LmZpbGxTdHlsZSA9IGNvbXAuJHByb3BzLmNvbG9ycy50ZXh0SEw7XG4gICAgICAgICAgY3R4LnRleHRBbGlnbiA9ICdsZWZ0JztcbiAgICAgICAgICBjdHguZmlsbFRleHQobGJsLCBhLCB5ICsgMTUpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHRoaXMuc2hhZGVyID0gdHJ1ZTtcbiAgICB9IC8vIFJlZ3VsYXIgZHJhdyBjYWxsIGZvciBvdmVyYWx5XG5cbiAgfSwge1xuICAgIGtleTogXCJkcmF3XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGRyYXcoY3R4KSB7XG4gICAgICBpZiAoIXRoaXMuY29tcC4kcHJvcHMubWV0YS5sYXN0KSByZXR1cm47XG4gICAgICBpZiAoIXRoaXMuc2hhZGVyKSB0aGlzLmluaXRfc2hhZGVyKCk7XG4gICAgICB2YXIgbGF5b3V0ID0gdGhpcy5jb21wLiRwcm9wcy5sYXlvdXQ7XG4gICAgICB2YXIgbGFzdCA9IHRoaXMuY29tcC4kcHJvcHMubGFzdDtcbiAgICAgIHZhciBkaXIgPSBsYXN0WzRdID49IGxhc3RbMV07XG4gICAgICB2YXIgY29sb3IgPSBkaXIgPyB0aGlzLmdyZWVuKCkgOiB0aGlzLnJlZCgpO1xuICAgICAgdmFyIHkgPSBsYXlvdXQuJDJzY3JlZW4obGFzdFs0XSkgKyAoZGlyID8gMSA6IDApO1xuICAgICAgY3R4LnN0cm9rZVN0eWxlID0gY29sb3I7XG4gICAgICBjdHguc2V0TGluZURhc2goWzEsIDFdKTtcbiAgICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICAgIGN0eC5tb3ZlVG8oMCwgeSk7XG4gICAgICBjdHgubGluZVRvKGxheW91dC53aWR0aCwgeSk7XG4gICAgICBjdHguc3Ryb2tlKCk7XG4gICAgICBjdHguc2V0TGluZURhc2goW10pO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJsYXN0X2JhclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBsYXN0X2JhcigpIHtcbiAgICAgIGlmICghdGhpcy5jb21wLmRhdGEubGVuZ3RoKSByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgdmFyIGxheW91dCA9IHRoaXMuY29tcC4kcHJvcHMubGF5b3V0O1xuICAgICAgdmFyIGxhc3QgPSB0aGlzLmNvbXAuZGF0YVt0aGlzLmNvbXAuZGF0YS5sZW5ndGggLSAxXTtcbiAgICAgIHZhciB5ID0gbGF5b3V0LiQyc2NyZWVuKGxhc3RbNF0pOyAvL2xldCBjbmRsID0gbGF5b3V0LmNfbWFnbmV0KGxhc3RbMF0pXG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIHk6IHksXG4gICAgICAgIC8vTWF0aC5mbG9vcihjbmRsLmMpIC0gMC41LFxuICAgICAgICBwcmljZTogbGFzdFs0XSxcbiAgICAgICAgY29sb3I6IGxhc3RbNF0gPj0gbGFzdFsxXSA/IHRoaXMuZ3JlZW4oKSA6IHRoaXMucmVkKClcbiAgICAgIH07XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImxhc3RfcHJpY2VcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gbGFzdF9wcmljZSgpIHtcbiAgICAgIHJldHVybiB0aGlzLmNvbXAuJHByb3BzLm1ldGEubGFzdCA/IHRoaXMuY29tcC4kcHJvcHMubWV0YS5sYXN0WzRdIDogdW5kZWZpbmVkO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJncmVlblwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBncmVlbigpIHtcbiAgICAgIHJldHVybiB0aGlzLmNvbXAuY29sb3JDYW5kbGVVcDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwicmVkXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJlZCgpIHtcbiAgICAgIHJldHVybiB0aGlzLmNvbXAuY29sb3JDYW5kbGVEdztcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gUHJpY2U7XG59KCk7XG5cblxuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vbm9kZV9tb2R1bGVzL2JhYmVsLWxvYWRlci9saWIvaW5kZXguanMhLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvaW5kZXguanM/P3Z1ZS1sb2FkZXItb3B0aW9ucyEuL3NyYy9jb21wb25lbnRzL292ZXJsYXlzL0NhbmRsZXMudnVlP3Z1ZSZ0eXBlPXNjcmlwdCZsYW5nPWpzJlxuLy8gUmVuZWRyZXIgZm9yIGNhbmRsZXN0aWNrcyArIHZvbHVtZSAob3B0aW9uYWwpXG4vLyBJdCBjYW4gYmUgdXNlZCBhcyB0aGUgbWFpbiBjaGFydCBvciBhbiBpbmRpY2F0b3JcblxuXG5cblxuXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIGNvbnN0IENhbmRsZXN2dWVfdHlwZV9zY3JpcHRfbGFuZ19qc18gPSAoe1xuICBuYW1lOiAnQ2FuZGxlcycsXG4gIG1peGluczogW292ZXJsYXldLFxuICBtZXRob2RzOiB7XG4gICAgbWV0YV9pbmZvOiBmdW5jdGlvbiBtZXRhX2luZm8oKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBhdXRob3I6ICdDNDUxJyxcbiAgICAgICAgdmVyc2lvbjogJzEuMi4xJ1xuICAgICAgfTtcbiAgICB9LFxuICAgIGluaXQ6IGZ1bmN0aW9uIGluaXQoKSB7XG4gICAgICB0aGlzLnByaWNlID0gbmV3IFByaWNlKHRoaXMpO1xuICAgIH0sXG4gICAgZHJhdzogZnVuY3Rpb24gZHJhdyhjdHgpIHtcbiAgICAgIC8vIElmIGRhdGEgPT09IG1haW4gY2FuZGxlc3RpY2sgZGF0YVxuICAgICAgLy8gcmVuZGVyIGFzIG1haW4gY2hhcnQ6XG4gICAgICBpZiAodGhpcy4kcHJvcHMuc3ViID09PSB0aGlzLiRwcm9wcy5kYXRhKSB7XG4gICAgICAgIHZhciBjbnYgPSB7XG4gICAgICAgICAgY2FuZGxlczogdGhpcy4kcHJvcHMubGF5b3V0LmNhbmRsZXMsXG4gICAgICAgICAgdm9sdW1lOiB0aGlzLiRwcm9wcy5sYXlvdXQudm9sdW1lXG4gICAgICAgIH07IC8vIEVsc2UsIGFzIG9mZmNoYXJ0IC8gb25jaGFydCBpbmRpY2F0b3I6XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjbnYgPSBsYXlvdXRfY252KHRoaXMpO1xuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5zaG93X3ZvbHVtZSkge1xuICAgICAgICB2YXIgY3YgPSBjbnYudm9sdW1lO1xuXG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBuID0gY3YubGVuZ3RoOyBpIDwgbjsgaSsrKSB7XG4gICAgICAgICAgbmV3IFZvbGJhckV4dCh0aGlzLCBjdHgsIGN2W2ldKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB2YXIgY2MgPSBjbnYuY2FuZGxlcztcblxuICAgICAgZm9yICh2YXIgaSA9IDAsIG4gPSBjYy5sZW5ndGg7IGkgPCBuOyBpKyspIHtcbiAgICAgICAgbmV3IENhbmRsZUV4dCh0aGlzLCBjdHgsIGNjW2ldKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMucHJpY2VfbGluZSkgdGhpcy5wcmljZS5kcmF3KGN0eCk7XG4gICAgfSxcbiAgICB1c2VfZm9yOiBmdW5jdGlvbiB1c2VfZm9yKCkge1xuICAgICAgcmV0dXJuIFsnQ2FuZGxlcyddO1xuICAgIH0sXG4gICAgLy8gSW4gY2FzZSBpdCdzIGFkZGVkIGFzIG9mZmNoYXJ0IG92ZXJsYXlcbiAgICB5X3JhbmdlOiBmdW5jdGlvbiB5X3JhbmdlKCkge1xuICAgICAgdmFyIGhpID0gLUluZmluaXR5LFxuICAgICAgICAgIGxvID0gSW5maW5pdHk7XG5cbiAgICAgIGZvciAodmFyIGkgPSAwLCBuID0gdGhpcy5zdWIubGVuZ3RoOyBpIDwgbjsgaSsrKSB7XG4gICAgICAgIHZhciB4ID0gdGhpcy5zdWJbaV07XG4gICAgICAgIGlmICh4WzJdID4gaGkpIGhpID0geFsyXTtcbiAgICAgICAgaWYgKHhbM10gPCBsbykgbG8gPSB4WzNdO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gW2hpLCBsb107XG4gICAgfVxuICB9LFxuICAvLyBEZWZpbmUgaW50ZXJuYWwgc2V0dGluZyAmIGNvbnN0YW50cyBoZXJlXG4gIGNvbXB1dGVkOiB7XG4gICAgc2V0dDogZnVuY3Rpb24gc2V0dCgpIHtcbiAgICAgIHJldHVybiB0aGlzLiRwcm9wcy5zZXR0aW5ncztcbiAgICB9LFxuICAgIHNob3dfdm9sdW1lOiBmdW5jdGlvbiBzaG93X3ZvbHVtZSgpIHtcbiAgICAgIHJldHVybiAnc2hvd1ZvbHVtZScgaW4gdGhpcy5zZXR0ID8gdGhpcy5zZXR0LnNob3dWb2x1bWUgOiB0cnVlO1xuICAgIH0sXG4gICAgcHJpY2VfbGluZTogZnVuY3Rpb24gcHJpY2VfbGluZSgpIHtcbiAgICAgIHJldHVybiAncHJpY2VMaW5lJyBpbiB0aGlzLnNldHQgPyB0aGlzLnNldHQucHJpY2VMaW5lIDogdHJ1ZTtcbiAgICB9LFxuICAgIGNvbG9yQ2FuZGxlVXA6IGZ1bmN0aW9uIGNvbG9yQ2FuZGxlVXAoKSB7XG4gICAgICByZXR1cm4gdGhpcy5zZXR0LmNvbG9yQ2FuZGxlVXAgfHwgdGhpcy4kcHJvcHMuY29sb3JzLmNhbmRsZVVwO1xuICAgIH0sXG4gICAgY29sb3JDYW5kbGVEdzogZnVuY3Rpb24gY29sb3JDYW5kbGVEdygpIHtcbiAgICAgIHJldHVybiB0aGlzLnNldHQuY29sb3JDYW5kbGVEdyB8fCB0aGlzLiRwcm9wcy5jb2xvcnMuY2FuZGxlRHc7XG4gICAgfSxcbiAgICBjb2xvcldpY2tVcDogZnVuY3Rpb24gY29sb3JXaWNrVXAoKSB7XG4gICAgICByZXR1cm4gdGhpcy5zZXR0LmNvbG9yV2lja1VwIHx8IHRoaXMuJHByb3BzLmNvbG9ycy53aWNrVXA7XG4gICAgfSxcbiAgICBjb2xvcldpY2tEdzogZnVuY3Rpb24gY29sb3JXaWNrRHcoKSB7XG4gICAgICByZXR1cm4gdGhpcy5zZXR0LmNvbG9yV2lja0R3IHx8IHRoaXMuJHByb3BzLmNvbG9ycy53aWNrRHc7XG4gICAgfSxcbiAgICBjb2xvcldpY2tTbTogZnVuY3Rpb24gY29sb3JXaWNrU20oKSB7XG4gICAgICByZXR1cm4gdGhpcy5zZXR0LmNvbG9yV2lja1NtIHx8IHRoaXMuJHByb3BzLmNvbG9ycy53aWNrU207XG4gICAgfSxcbiAgICBjb2xvclZvbFVwOiBmdW5jdGlvbiBjb2xvclZvbFVwKCkge1xuICAgICAgcmV0dXJuIHRoaXMuc2V0dC5jb2xvclZvbFVwIHx8IHRoaXMuJHByb3BzLmNvbG9ycy52b2xVcDtcbiAgICB9LFxuICAgIGNvbG9yVm9sRHc6IGZ1bmN0aW9uIGNvbG9yVm9sRHcoKSB7XG4gICAgICByZXR1cm4gdGhpcy5zZXR0LmNvbG9yVm9sRHcgfHwgdGhpcy4kcHJvcHMuY29sb3JzLnZvbER3O1xuICAgIH1cbiAgfSxcbiAgZGF0YTogZnVuY3Rpb24gZGF0YSgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgcHJpY2U6IHt9XG4gICAgfTtcbiAgfVxufSk7XG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvY29tcG9uZW50cy9vdmVybGF5cy9DYW5kbGVzLnZ1ZT92dWUmdHlwZT1zY3JpcHQmbGFuZz1qcyZcbiAvKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIGNvbnN0IG92ZXJsYXlzX0NhbmRsZXN2dWVfdHlwZV9zY3JpcHRfbGFuZ19qc18gPSAoQ2FuZGxlc3Z1ZV90eXBlX3NjcmlwdF9sYW5nX2pzXyk7IFxuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL2NvbXBvbmVudHMvb3ZlcmxheXMvQ2FuZGxlcy52dWVcbnZhciBDYW5kbGVzX3JlbmRlciwgQ2FuZGxlc19zdGF0aWNSZW5kZXJGbnNcbjtcblxuXG5cbi8qIG5vcm1hbGl6ZSBjb21wb25lbnQgKi9cbjtcbnZhciBDYW5kbGVzX2NvbXBvbmVudCA9IG5vcm1hbGl6ZUNvbXBvbmVudChcbiAgb3ZlcmxheXNfQ2FuZGxlc3Z1ZV90eXBlX3NjcmlwdF9sYW5nX2pzXyxcbiAgQ2FuZGxlc19yZW5kZXIsXG4gIENhbmRsZXNfc3RhdGljUmVuZGVyRm5zLFxuICBmYWxzZSxcbiAgbnVsbCxcbiAgbnVsbCxcbiAgbnVsbFxuICBcbilcblxuLyogaG90IHJlbG9hZCAqL1xuaWYgKGZhbHNlKSB7IHZhciBDYW5kbGVzX2FwaTsgfVxuQ2FuZGxlc19jb21wb25lbnQub3B0aW9ucy5fX2ZpbGUgPSBcInNyYy9jb21wb25lbnRzL292ZXJsYXlzL0NhbmRsZXMudnVlXCJcbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gY29uc3QgQ2FuZGxlcyA9IChDYW5kbGVzX2NvbXBvbmVudC5leHBvcnRzKTtcbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL25vZGVfbW9kdWxlcy9iYWJlbC1sb2FkZXIvbGliL2luZGV4LmpzIS4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL2luZGV4LmpzPz92dWUtbG9hZGVyLW9wdGlvbnMhLi9zcmMvY29tcG9uZW50cy9vdmVybGF5cy9Wb2x1bWUudnVlP3Z1ZSZ0eXBlPXNjcmlwdCZsYW5nPWpzJlxuXG5cbmZ1bmN0aW9uIFZvbHVtZXZ1ZV90eXBlX3NjcmlwdF9sYW5nX2pzX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXIobywgYWxsb3dBcnJheUxpa2UpIHsgdmFyIGl0OyBpZiAodHlwZW9mIFN5bWJvbCA9PT0gXCJ1bmRlZmluZWRcIiB8fCBvW1N5bWJvbC5pdGVyYXRvcl0gPT0gbnVsbCkgeyBpZiAoQXJyYXkuaXNBcnJheShvKSB8fCAoaXQgPSBWb2x1bWV2dWVfdHlwZV9zY3JpcHRfbGFuZ19qc191bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheShvKSkgfHwgYWxsb3dBcnJheUxpa2UgJiYgbyAmJiB0eXBlb2Ygby5sZW5ndGggPT09IFwibnVtYmVyXCIpIHsgaWYgKGl0KSBvID0gaXQ7IHZhciBpID0gMDsgdmFyIEYgPSBmdW5jdGlvbiBGKCkge307IHJldHVybiB7IHM6IEYsIG46IGZ1bmN0aW9uIG4oKSB7IGlmIChpID49IG8ubGVuZ3RoKSByZXR1cm4geyBkb25lOiB0cnVlIH07IHJldHVybiB7IGRvbmU6IGZhbHNlLCB2YWx1ZTogb1tpKytdIH07IH0sIGU6IGZ1bmN0aW9uIGUoX2UpIHsgdGhyb3cgX2U7IH0sIGY6IEYgfTsgfSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiSW52YWxpZCBhdHRlbXB0IHRvIGl0ZXJhdGUgbm9uLWl0ZXJhYmxlIGluc3RhbmNlLlxcbkluIG9yZGVyIHRvIGJlIGl0ZXJhYmxlLCBub24tYXJyYXkgb2JqZWN0cyBtdXN0IGhhdmUgYSBbU3ltYm9sLml0ZXJhdG9yXSgpIG1ldGhvZC5cIik7IH0gdmFyIG5vcm1hbENvbXBsZXRpb24gPSB0cnVlLCBkaWRFcnIgPSBmYWxzZSwgZXJyOyByZXR1cm4geyBzOiBmdW5jdGlvbiBzKCkgeyBpdCA9IG9bU3ltYm9sLml0ZXJhdG9yXSgpOyB9LCBuOiBmdW5jdGlvbiBuKCkgeyB2YXIgc3RlcCA9IGl0Lm5leHQoKTsgbm9ybWFsQ29tcGxldGlvbiA9IHN0ZXAuZG9uZTsgcmV0dXJuIHN0ZXA7IH0sIGU6IGZ1bmN0aW9uIGUoX2UyKSB7IGRpZEVyciA9IHRydWU7IGVyciA9IF9lMjsgfSwgZjogZnVuY3Rpb24gZigpIHsgdHJ5IHsgaWYgKCFub3JtYWxDb21wbGV0aW9uICYmIGl0W1wicmV0dXJuXCJdICE9IG51bGwpIGl0W1wicmV0dXJuXCJdKCk7IH0gZmluYWxseSB7IGlmIChkaWRFcnIpIHRocm93IGVycjsgfSB9IH07IH1cblxuZnVuY3Rpb24gVm9sdW1ldnVlX3R5cGVfc2NyaXB0X2xhbmdfanNfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkobywgbWluTGVuKSB7IGlmICghbykgcmV0dXJuOyBpZiAodHlwZW9mIG8gPT09IFwic3RyaW5nXCIpIHJldHVybiBWb2x1bWV2dWVfdHlwZV9zY3JpcHRfbGFuZ19qc19hcnJheUxpa2VUb0FycmF5KG8sIG1pbkxlbik7IHZhciBuID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG8pLnNsaWNlKDgsIC0xKTsgaWYgKG4gPT09IFwiT2JqZWN0XCIgJiYgby5jb25zdHJ1Y3RvcikgbiA9IG8uY29uc3RydWN0b3IubmFtZTsgaWYgKG4gPT09IFwiTWFwXCIgfHwgbiA9PT0gXCJTZXRcIikgcmV0dXJuIEFycmF5LmZyb20obyk7IGlmIChuID09PSBcIkFyZ3VtZW50c1wiIHx8IC9eKD86VWl8SSludCg/Ojh8MTZ8MzIpKD86Q2xhbXBlZCk/QXJyYXkkLy50ZXN0KG4pKSByZXR1cm4gVm9sdW1ldnVlX3R5cGVfc2NyaXB0X2xhbmdfanNfYXJyYXlMaWtlVG9BcnJheShvLCBtaW5MZW4pOyB9XG5cbmZ1bmN0aW9uIFZvbHVtZXZ1ZV90eXBlX3NjcmlwdF9sYW5nX2pzX2FycmF5TGlrZVRvQXJyYXkoYXJyLCBsZW4pIHsgaWYgKGxlbiA9PSBudWxsIHx8IGxlbiA+IGFyci5sZW5ndGgpIGxlbiA9IGFyci5sZW5ndGg7IGZvciAodmFyIGkgPSAwLCBhcnIyID0gbmV3IEFycmF5KGxlbik7IGkgPCBsZW47IGkrKykgeyBhcnIyW2ldID0gYXJyW2ldOyB9IHJldHVybiBhcnIyOyB9XG5cbi8vIFN0YW5kYWxvbmUgcmVuZWRyZXIgZm9yIHRoZSB2b2x1bWVcblxuXG5cbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gY29uc3QgVm9sdW1ldnVlX3R5cGVfc2NyaXB0X2xhbmdfanNfID0gKHtcbiAgbmFtZTogJ1ZvbHVtZScsXG4gIG1peGluczogW292ZXJsYXldLFxuICBtZXRob2RzOiB7XG4gICAgbWV0YV9pbmZvOiBmdW5jdGlvbiBtZXRhX2luZm8oKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBhdXRob3I6ICdDNDUxJyxcbiAgICAgICAgdmVyc2lvbjogJzEuMS4wJ1xuICAgICAgfTtcbiAgICB9LFxuICAgIGRyYXc6IGZ1bmN0aW9uIGRyYXcoY3R4KSB7XG4gICAgICAvLyBUT0RPOiB2b2x1bWUgYXZlcmFnZVxuICAgICAgLy8gVE9ETzogWS1heGlzIHNjYWxpbmdcbiAgICAgIHZhciBfaXRlcmF0b3IgPSBWb2x1bWV2dWVfdHlwZV9zY3JpcHRfbGFuZ19qc19jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyKGxheW91dF92b2wodGhpcykpLFxuICAgICAgICAgIF9zdGVwO1xuXG4gICAgICB0cnkge1xuICAgICAgICBmb3IgKF9pdGVyYXRvci5zKCk7ICEoX3N0ZXAgPSBfaXRlcmF0b3IubigpKS5kb25lOykge1xuICAgICAgICAgIHZhciB2ID0gX3N0ZXAudmFsdWU7XG4gICAgICAgICAgbmV3IFZvbGJhckV4dCh0aGlzLCBjdHgsIHYpO1xuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgX2l0ZXJhdG9yLmUoZXJyKTtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIF9pdGVyYXRvci5mKCk7XG4gICAgICB9XG4gICAgfSxcbiAgICB1c2VfZm9yOiBmdW5jdGlvbiB1c2VfZm9yKCkge1xuICAgICAgcmV0dXJuIFsnVm9sdW1lJ107XG4gICAgfSxcbiAgICAvLyBEZWZpbmVzIGxlZ2VuZCBmb3JtYXQgKHZhbHVlcyAmIGNvbG9ycylcbiAgICAvLyBfaTIgLSBkZXRldGVjdGVkIGRhdGEgaW5kZXggKHNlZSBsYXlvdXRfY252KVxuICAgIGxlZ2VuZDogZnVuY3Rpb24gbGVnZW5kKHZhbHVlcykge1xuICAgICAgdmFyIGZsYWcgPSB0aGlzLl9pMiA/IHRoaXMuX2kyKHZhbHVlcykgOiB2YWx1ZXNbMl07XG4gICAgICB2YXIgY29sb3IgPSBmbGFnID8gdGhpcy5jb2xvclZvbFVwTGVnZW5kIDogdGhpcy5jb2xvclZvbER3TGVnZW5kO1xuICAgICAgcmV0dXJuIFt7XG4gICAgICAgIHZhbHVlOiB2YWx1ZXNbdGhpcy5faTEgfHwgMV0sXG4gICAgICAgIGNvbG9yOiBjb2xvclxuICAgICAgfV07XG4gICAgfSxcbiAgICAvLyBXaGVuIGFkZGVkIGFzIG9mZmNoYXJ0IG92ZXJsYXlcbiAgICAvLyBJZiBkYXRhIGlzIE9ITENWID0+IHJlY2FsYyB5LXJhbmdlXG4gICAgLy8gX2kxIC0gZGV0ZXRlY3RlZCBkYXRhIGluZGV4IChzZWUgbGF5b3V0X2NudilcbiAgICB5X3JhbmdlOiBmdW5jdGlvbiB5X3JhbmdlKGhpLCBsbykge1xuICAgICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgICAgaWYgKHRoaXMuX2kxID09PSA1KSB7XG4gICAgICAgIHZhciBzdWIgPSB0aGlzLiRwcm9wcy5zdWI7XG4gICAgICAgIHJldHVybiBbTWF0aC5tYXguYXBwbHkoTWF0aCwgX3RvQ29uc3VtYWJsZUFycmF5KHN1Yi5tYXAoZnVuY3Rpb24gKHgpIHtcbiAgICAgICAgICByZXR1cm4geFtfdGhpcy5faTFdO1xuICAgICAgICB9KSkpLCBNYXRoLm1pbi5hcHBseShNYXRoLCBfdG9Db25zdW1hYmxlQXJyYXkoc3ViLm1hcChmdW5jdGlvbiAoeCkge1xuICAgICAgICAgIHJldHVybiB4W190aGlzLl9pMV07XG4gICAgICAgIH0pKSldO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIFtoaSwgbG9dO1xuICAgICAgfVxuICAgIH1cbiAgfSxcbiAgLy8gRGVmaW5lIGludGVybmFsIHNldHRpbmcgJiBjb25zdGFudHMgaGVyZVxuICBjb21wdXRlZDoge1xuICAgIHNldHQ6IGZ1bmN0aW9uIHNldHQoKSB7XG4gICAgICByZXR1cm4gdGhpcy4kcHJvcHMuc2V0dGluZ3M7XG4gICAgfSxcbiAgICBjb2xvclZvbFVwOiBmdW5jdGlvbiBjb2xvclZvbFVwKCkge1xuICAgICAgcmV0dXJuIHRoaXMuc2V0dC5jb2xvclZvbFVwIHx8IHRoaXMuJHByb3BzLmNvbG9ycy52b2xVcDtcbiAgICB9LFxuICAgIGNvbG9yVm9sRHc6IGZ1bmN0aW9uIGNvbG9yVm9sRHcoKSB7XG4gICAgICByZXR1cm4gdGhpcy5zZXR0LmNvbG9yVm9sRHcgfHwgdGhpcy4kcHJvcHMuY29sb3JzLnZvbER3O1xuICAgIH0sXG4gICAgY29sb3JWb2xVcExlZ2VuZDogZnVuY3Rpb24gY29sb3JWb2xVcExlZ2VuZCgpIHtcbiAgICAgIHJldHVybiB0aGlzLnNldHQuY29sb3JWb2xVcExlZ2VuZCB8fCB0aGlzLiRwcm9wcy5jb2xvcnMuY2FuZGxlVXA7XG4gICAgfSxcbiAgICBjb2xvclZvbER3TGVnZW5kOiBmdW5jdGlvbiBjb2xvclZvbER3TGVnZW5kKCkge1xuICAgICAgcmV0dXJuIHRoaXMuc2V0dC5jb2xvclZvbER3TGVnZW5kIHx8IHRoaXMuJHByb3BzLmNvbG9ycy5jYW5kbGVEdztcbiAgICB9LFxuICAgIHZvbHNjYWxlOiBmdW5jdGlvbiB2b2xzY2FsZSgpIHtcbiAgICAgIHJldHVybiB0aGlzLnNldHQudm9sc2NhbGUgfHwgdGhpcy4kcHJvcHMuZ3JpZF9pZCA+IDAgPyAwLjg1IDogdGhpcy4kcHJvcHMuY29uZmlnLlZPTFNDQUxFO1xuICAgIH1cbiAgfSxcbiAgZGF0YTogZnVuY3Rpb24gZGF0YSgpIHtcbiAgICByZXR1cm4ge307XG4gIH1cbn0pO1xuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL2NvbXBvbmVudHMvb3ZlcmxheXMvVm9sdW1lLnZ1ZT92dWUmdHlwZT1zY3JpcHQmbGFuZz1qcyZcbiAvKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIGNvbnN0IG92ZXJsYXlzX1ZvbHVtZXZ1ZV90eXBlX3NjcmlwdF9sYW5nX2pzXyA9IChWb2x1bWV2dWVfdHlwZV9zY3JpcHRfbGFuZ19qc18pOyBcbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9jb21wb25lbnRzL292ZXJsYXlzL1ZvbHVtZS52dWVcbnZhciBWb2x1bWVfcmVuZGVyLCBWb2x1bWVfc3RhdGljUmVuZGVyRm5zXG47XG5cblxuXG4vKiBub3JtYWxpemUgY29tcG9uZW50ICovXG47XG52YXIgVm9sdW1lX2NvbXBvbmVudCA9IG5vcm1hbGl6ZUNvbXBvbmVudChcbiAgb3ZlcmxheXNfVm9sdW1ldnVlX3R5cGVfc2NyaXB0X2xhbmdfanNfLFxuICBWb2x1bWVfcmVuZGVyLFxuICBWb2x1bWVfc3RhdGljUmVuZGVyRm5zLFxuICBmYWxzZSxcbiAgbnVsbCxcbiAgbnVsbCxcbiAgbnVsbFxuICBcbilcblxuLyogaG90IHJlbG9hZCAqL1xuaWYgKGZhbHNlKSB7IHZhciBWb2x1bWVfYXBpOyB9XG5Wb2x1bWVfY29tcG9uZW50Lm9wdGlvbnMuX19maWxlID0gXCJzcmMvY29tcG9uZW50cy9vdmVybGF5cy9Wb2x1bWUudnVlXCJcbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gY29uc3QgVm9sdW1lID0gKFZvbHVtZV9jb21wb25lbnQuZXhwb3J0cyk7XG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9ub2RlX21vZHVsZXMvYmFiZWwtbG9hZGVyL2xpYi9pbmRleC5qcyEuL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9pbmRleC5qcz8/dnVlLWxvYWRlci1vcHRpb25zIS4vc3JjL2NvbXBvbmVudHMvb3ZlcmxheXMvU3BsaXR0ZXJzLnZ1ZT92dWUmdHlwZT1zY3JpcHQmbGFuZz1qcyZcbi8vIERhdGEgc2VjdGlvbiBzcGxpdHRlcnMgKHdpdGggbGFiZWxzKVxuXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIGNvbnN0IFNwbGl0dGVyc3Z1ZV90eXBlX3NjcmlwdF9sYW5nX2pzXyA9ICh7XG4gIG5hbWU6ICdTcGxpdHRlcnMnLFxuICBtaXhpbnM6IFtvdmVybGF5XSxcbiAgbWV0aG9kczoge1xuICAgIG1ldGFfaW5mbzogZnVuY3Rpb24gbWV0YV9pbmZvKCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgYXV0aG9yOiAnQzQ1MScsXG4gICAgICAgIHZlcnNpb246ICcxLjAuMSdcbiAgICAgIH07XG4gICAgfSxcbiAgICBkcmF3OiBmdW5jdGlvbiBkcmF3KGN0eCkge1xuICAgICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgICAgdmFyIGxheW91dCA9IHRoaXMuJHByb3BzLmxheW91dDtcbiAgICAgIGN0eC5saW5lV2lkdGggPSB0aGlzLmxpbmVfd2lkdGg7XG4gICAgICBjdHguc3Ryb2tlU3R5bGUgPSB0aGlzLmxpbmVfY29sb3I7XG4gICAgICB0aGlzLiRwcm9wcy5kYXRhLmZvckVhY2goZnVuY3Rpb24gKHAsIGkpIHtcbiAgICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgICB2YXIgeCA9IGxheW91dC50MnNjcmVlbihwWzBdKTsgLy8geCAtIE1hcHBpbmdcblxuICAgICAgICBjdHguc2V0TGluZURhc2goWzEwLCAxMF0pO1xuICAgICAgICBjdHgubW92ZVRvKHgsIDApO1xuICAgICAgICBjdHgubGluZVRvKHgsIF90aGlzLmxheW91dC5oZWlnaHQpO1xuICAgICAgICBjdHguc3Ryb2tlKCk7XG4gICAgICAgIGlmIChwWzFdKSBfdGhpcy5kcmF3X2xhYmVsKGN0eCwgeCwgcCk7XG4gICAgICB9KTtcbiAgICB9LFxuICAgIGRyYXdfbGFiZWw6IGZ1bmN0aW9uIGRyYXdfbGFiZWwoY3R4LCB4LCBwKSB7XG4gICAgICB2YXIgc2lkZSA9IHBbMl0gPyAxIDogLTE7XG4gICAgICB4ICs9IDIuNSAqIHNpZGU7XG4gICAgICBjdHguZm9udCA9IHRoaXMubmV3X2ZvbnQ7XG4gICAgICB2YXIgcG9zID0gcFs0XSB8fCB0aGlzLnlfcG9zaXRpb247XG4gICAgICB2YXIgdyA9IGN0eC5tZWFzdXJlVGV4dChwWzFdKS53aWR0aCArIDEwO1xuICAgICAgdmFyIHkgPSB0aGlzLmxheW91dC5oZWlnaHQgKiAoMS4wIC0gcG9zKTtcbiAgICAgIHkgPSBNYXRoLmZsb29yKHkpO1xuICAgICAgY3R4LmZpbGxTdHlsZSA9IHBbM10gfHwgdGhpcy5mbGFnX2NvbG9yO1xuICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgY3R4Lm1vdmVUbyh4LCB5KTtcbiAgICAgIGN0eC5saW5lVG8oeCArIDEwICogc2lkZSwgeSAtIDEwICogc2lkZSk7XG4gICAgICBjdHgubGluZVRvKHggKyAodyArIDEwKSAqIHNpZGUsIHkgLSAxMCAqIHNpZGUpO1xuICAgICAgY3R4LmxpbmVUbyh4ICsgKHcgKyAxMCkgKiBzaWRlLCB5ICsgMTAgKiBzaWRlKTtcbiAgICAgIGN0eC5saW5lVG8oeCArIDEwICogc2lkZSwgeSArIDEwICogc2lkZSk7XG4gICAgICBjdHguY2xvc2VQYXRoKCk7XG4gICAgICBjdHguZmlsbCgpO1xuICAgICAgY3R4LmZpbGxTdHlsZSA9IHRoaXMubGFiZWxfY29sb3I7XG4gICAgICBjdHgudGV4dEFsaWduID0gc2lkZSA8IDAgPyAncmlnaHQnIDogJ2xlZnQnO1xuICAgICAgY3R4LmZpbGxUZXh0KHBbMV0sIHggKyAxNSAqIHNpZGUsIHkgKyA0KTtcbiAgICB9LFxuICAgIHVzZV9mb3I6IGZ1bmN0aW9uIHVzZV9mb3IoKSB7XG4gICAgICByZXR1cm4gWydTcGxpdHRlcnMnXTtcbiAgICB9XG4gIH0sXG4gIC8vIERlZmluZSBpbnRlcm5hbCBzZXR0aW5nICYgY29uc3RhbnRzIGhlcmVcbiAgY29tcHV0ZWQ6IHtcbiAgICBzZXR0OiBmdW5jdGlvbiBzZXR0KCkge1xuICAgICAgcmV0dXJuIHRoaXMuJHByb3BzLnNldHRpbmdzO1xuICAgIH0sXG4gICAgbmV3X2ZvbnQ6IGZ1bmN0aW9uIG5ld19mb250KCkge1xuICAgICAgcmV0dXJuIHRoaXMuc2V0dC5mb250IHx8ICcxMnB4ICcgKyB0aGlzLiRwcm9wcy5mb250LnNwbGl0KCdweCcpLnBvcCgpO1xuICAgIH0sXG4gICAgZmxhZ19jb2xvcjogZnVuY3Rpb24gZmxhZ19jb2xvcigpIHtcbiAgICAgIHJldHVybiB0aGlzLnNldHQuZmxhZ0NvbG9yIHx8ICcjNDI4NWY0JztcbiAgICB9LFxuICAgIGxhYmVsX2NvbG9yOiBmdW5jdGlvbiBsYWJlbF9jb2xvcigpIHtcbiAgICAgIHJldHVybiB0aGlzLnNldHQubGFiZWxDb2xvciB8fCAnI2ZmZic7XG4gICAgfSxcbiAgICBsaW5lX2NvbG9yOiBmdW5jdGlvbiBsaW5lX2NvbG9yKCkge1xuICAgICAgcmV0dXJuIHRoaXMuc2V0dC5saW5lQ29sb3IgfHwgJyM0Mjg1ZjQnO1xuICAgIH0sXG4gICAgbGluZV93aWR0aDogZnVuY3Rpb24gbGluZV93aWR0aCgpIHtcbiAgICAgIHJldHVybiB0aGlzLnNldHQubGluZVdpZHRoIHx8IDEuMDtcbiAgICB9LFxuICAgIHlfcG9zaXRpb246IGZ1bmN0aW9uIHlfcG9zaXRpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy5zZXR0LnlQb3NpdGlvbiB8fCAwLjk7XG4gICAgfVxuICB9LFxuICBkYXRhOiBmdW5jdGlvbiBkYXRhKCkge1xuICAgIHJldHVybiB7fTtcbiAgfVxufSk7XG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvY29tcG9uZW50cy9vdmVybGF5cy9TcGxpdHRlcnMudnVlP3Z1ZSZ0eXBlPXNjcmlwdCZsYW5nPWpzJlxuIC8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gY29uc3Qgb3ZlcmxheXNfU3BsaXR0ZXJzdnVlX3R5cGVfc2NyaXB0X2xhbmdfanNfID0gKFNwbGl0dGVyc3Z1ZV90eXBlX3NjcmlwdF9sYW5nX2pzXyk7IFxuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL2NvbXBvbmVudHMvb3ZlcmxheXMvU3BsaXR0ZXJzLnZ1ZVxudmFyIFNwbGl0dGVyc19yZW5kZXIsIFNwbGl0dGVyc19zdGF0aWNSZW5kZXJGbnNcbjtcblxuXG5cbi8qIG5vcm1hbGl6ZSBjb21wb25lbnQgKi9cbjtcbnZhciBTcGxpdHRlcnNfY29tcG9uZW50ID0gbm9ybWFsaXplQ29tcG9uZW50KFxuICBvdmVybGF5c19TcGxpdHRlcnN2dWVfdHlwZV9zY3JpcHRfbGFuZ19qc18sXG4gIFNwbGl0dGVyc19yZW5kZXIsXG4gIFNwbGl0dGVyc19zdGF0aWNSZW5kZXJGbnMsXG4gIGZhbHNlLFxuICBudWxsLFxuICBudWxsLFxuICBudWxsXG4gIFxuKVxuXG4vKiBob3QgcmVsb2FkICovXG5pZiAoZmFsc2UpIHsgdmFyIFNwbGl0dGVyc19hcGk7IH1cblNwbGl0dGVyc19jb21wb25lbnQub3B0aW9ucy5fX2ZpbGUgPSBcInNyYy9jb21wb25lbnRzL292ZXJsYXlzL1NwbGl0dGVycy52dWVcIlxuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyBjb25zdCBTcGxpdHRlcnMgPSAoU3BsaXR0ZXJzX2NvbXBvbmVudC5leHBvcnRzKTtcbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9zdHVmZi9rZXlzLmpzXG5cblxuXG5mdW5jdGlvbiBrZXlzX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXIobywgYWxsb3dBcnJheUxpa2UpIHsgdmFyIGl0OyBpZiAodHlwZW9mIFN5bWJvbCA9PT0gXCJ1bmRlZmluZWRcIiB8fCBvW1N5bWJvbC5pdGVyYXRvcl0gPT0gbnVsbCkgeyBpZiAoQXJyYXkuaXNBcnJheShvKSB8fCAoaXQgPSBrZXlzX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5KG8pKSB8fCBhbGxvd0FycmF5TGlrZSAmJiBvICYmIHR5cGVvZiBvLmxlbmd0aCA9PT0gXCJudW1iZXJcIikgeyBpZiAoaXQpIG8gPSBpdDsgdmFyIGkgPSAwOyB2YXIgRiA9IGZ1bmN0aW9uIEYoKSB7fTsgcmV0dXJuIHsgczogRiwgbjogZnVuY3Rpb24gbigpIHsgaWYgKGkgPj0gby5sZW5ndGgpIHJldHVybiB7IGRvbmU6IHRydWUgfTsgcmV0dXJuIHsgZG9uZTogZmFsc2UsIHZhbHVlOiBvW2krK10gfTsgfSwgZTogZnVuY3Rpb24gZShfZSkgeyB0aHJvdyBfZTsgfSwgZjogRiB9OyB9IHRocm93IG5ldyBUeXBlRXJyb3IoXCJJbnZhbGlkIGF0dGVtcHQgdG8gaXRlcmF0ZSBub24taXRlcmFibGUgaW5zdGFuY2UuXFxuSW4gb3JkZXIgdG8gYmUgaXRlcmFibGUsIG5vbi1hcnJheSBvYmplY3RzIG11c3QgaGF2ZSBhIFtTeW1ib2wuaXRlcmF0b3JdKCkgbWV0aG9kLlwiKTsgfSB2YXIgbm9ybWFsQ29tcGxldGlvbiA9IHRydWUsIGRpZEVyciA9IGZhbHNlLCBlcnI7IHJldHVybiB7IHM6IGZ1bmN0aW9uIHMoKSB7IGl0ID0gb1tTeW1ib2wuaXRlcmF0b3JdKCk7IH0sIG46IGZ1bmN0aW9uIG4oKSB7IHZhciBzdGVwID0gaXQubmV4dCgpOyBub3JtYWxDb21wbGV0aW9uID0gc3RlcC5kb25lOyByZXR1cm4gc3RlcDsgfSwgZTogZnVuY3Rpb24gZShfZTIpIHsgZGlkRXJyID0gdHJ1ZTsgZXJyID0gX2UyOyB9LCBmOiBmdW5jdGlvbiBmKCkgeyB0cnkgeyBpZiAoIW5vcm1hbENvbXBsZXRpb24gJiYgaXRbXCJyZXR1cm5cIl0gIT0gbnVsbCkgaXRbXCJyZXR1cm5cIl0oKTsgfSBmaW5hbGx5IHsgaWYgKGRpZEVycikgdGhyb3cgZXJyOyB9IH0gfTsgfVxuXG5mdW5jdGlvbiBrZXlzX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5KG8sIG1pbkxlbikgeyBpZiAoIW8pIHJldHVybjsgaWYgKHR5cGVvZiBvID09PSBcInN0cmluZ1wiKSByZXR1cm4ga2V5c19hcnJheUxpa2VUb0FycmF5KG8sIG1pbkxlbik7IHZhciBuID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG8pLnNsaWNlKDgsIC0xKTsgaWYgKG4gPT09IFwiT2JqZWN0XCIgJiYgby5jb25zdHJ1Y3RvcikgbiA9IG8uY29uc3RydWN0b3IubmFtZTsgaWYgKG4gPT09IFwiTWFwXCIgfHwgbiA9PT0gXCJTZXRcIikgcmV0dXJuIEFycmF5LmZyb20obyk7IGlmIChuID09PSBcIkFyZ3VtZW50c1wiIHx8IC9eKD86VWl8SSludCg/Ojh8MTZ8MzIpKD86Q2xhbXBlZCk/QXJyYXkkLy50ZXN0KG4pKSByZXR1cm4ga2V5c19hcnJheUxpa2VUb0FycmF5KG8sIG1pbkxlbik7IH1cblxuZnVuY3Rpb24ga2V5c19hcnJheUxpa2VUb0FycmF5KGFyciwgbGVuKSB7IGlmIChsZW4gPT0gbnVsbCB8fCBsZW4gPiBhcnIubGVuZ3RoKSBsZW4gPSBhcnIubGVuZ3RoOyBmb3IgKHZhciBpID0gMCwgYXJyMiA9IG5ldyBBcnJheShsZW4pOyBpIDwgbGVuOyBpKyspIHsgYXJyMltpXSA9IGFycltpXTsgfSByZXR1cm4gYXJyMjsgfVxuXG4vLyBLZXlib2FyZCBldmVudCBoYW5kbGVyIGZvciBvdmVybGF5XG52YXIgS2V5cyA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIEtleXMoY29tcCkge1xuICAgIGNsYXNzQ2FsbENoZWNrX2NsYXNzQ2FsbENoZWNrKHRoaXMsIEtleXMpO1xuXG4gICAgdGhpcy5jb21wID0gY29tcDtcbiAgICB0aGlzLm1hcCA9IHt9O1xuICAgIHRoaXMubGlzdGVuZXJzID0gMDtcbiAgICB0aGlzLmtleW1hcCA9IHt9O1xuICB9XG5cbiAgY3JlYXRlQ2xhc3NfY3JlYXRlQ2xhc3MoS2V5cywgW3tcbiAgICBrZXk6IFwib25cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gb24obmFtZSwgaGFuZGxlcikge1xuICAgICAgaWYgKCFoYW5kbGVyKSByZXR1cm47XG4gICAgICB0aGlzLm1hcFtuYW1lXSA9IHRoaXMubWFwW25hbWVdIHx8IFtdO1xuICAgICAgdGhpcy5tYXBbbmFtZV0ucHVzaChoYW5kbGVyKTtcbiAgICAgIHRoaXMubGlzdGVuZXJzKys7XG4gICAgfSAvLyBDYWxsZWQgYnkgZ3JpZC5qc1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiZW1pdFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBlbWl0KG5hbWUsIGV2ZW50KSB7XG4gICAgICBpZiAobmFtZSBpbiB0aGlzLm1hcCkge1xuICAgICAgICB2YXIgX2l0ZXJhdG9yID0ga2V5c19jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyKHRoaXMubWFwW25hbWVdKSxcbiAgICAgICAgICAgIF9zdGVwO1xuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgZm9yIChfaXRlcmF0b3IucygpOyAhKF9zdGVwID0gX2l0ZXJhdG9yLm4oKSkuZG9uZTspIHtcbiAgICAgICAgICAgIHZhciBmID0gX3N0ZXAudmFsdWU7XG4gICAgICAgICAgICBmKGV2ZW50KTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgIF9pdGVyYXRvci5lKGVycik7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgX2l0ZXJhdG9yLmYoKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAobmFtZSA9PT0gJ2tleWRvd24nKSB7XG4gICAgICAgIGlmICghdGhpcy5rZXltYXBbZXZlbnQua2V5XSkge1xuICAgICAgICAgIHRoaXMuZW1pdChldmVudC5rZXkpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5rZXltYXBbZXZlbnQua2V5XSA9IHRydWU7XG4gICAgICB9XG5cbiAgICAgIGlmIChuYW1lID09PSAna2V5dXAnKSB7XG4gICAgICAgIHRoaXMua2V5bWFwW2V2ZW50LmtleV0gPSBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwicHJlc3NlZFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBwcmVzc2VkKGtleSkge1xuICAgICAgcmV0dXJuIHRoaXMua2V5bWFwW2tleV07XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIEtleXM7XG59KCk7XG5cblxuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL21peGlucy90b29sLmpzXG5mdW5jdGlvbiB0b29sX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXIobywgYWxsb3dBcnJheUxpa2UpIHsgdmFyIGl0OyBpZiAodHlwZW9mIFN5bWJvbCA9PT0gXCJ1bmRlZmluZWRcIiB8fCBvW1N5bWJvbC5pdGVyYXRvcl0gPT0gbnVsbCkgeyBpZiAoQXJyYXkuaXNBcnJheShvKSB8fCAoaXQgPSB0b29sX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5KG8pKSB8fCBhbGxvd0FycmF5TGlrZSAmJiBvICYmIHR5cGVvZiBvLmxlbmd0aCA9PT0gXCJudW1iZXJcIikgeyBpZiAoaXQpIG8gPSBpdDsgdmFyIGkgPSAwOyB2YXIgRiA9IGZ1bmN0aW9uIEYoKSB7fTsgcmV0dXJuIHsgczogRiwgbjogZnVuY3Rpb24gbigpIHsgaWYgKGkgPj0gby5sZW5ndGgpIHJldHVybiB7IGRvbmU6IHRydWUgfTsgcmV0dXJuIHsgZG9uZTogZmFsc2UsIHZhbHVlOiBvW2krK10gfTsgfSwgZTogZnVuY3Rpb24gZShfZSkgeyB0aHJvdyBfZTsgfSwgZjogRiB9OyB9IHRocm93IG5ldyBUeXBlRXJyb3IoXCJJbnZhbGlkIGF0dGVtcHQgdG8gaXRlcmF0ZSBub24taXRlcmFibGUgaW5zdGFuY2UuXFxuSW4gb3JkZXIgdG8gYmUgaXRlcmFibGUsIG5vbi1hcnJheSBvYmplY3RzIG11c3QgaGF2ZSBhIFtTeW1ib2wuaXRlcmF0b3JdKCkgbWV0aG9kLlwiKTsgfSB2YXIgbm9ybWFsQ29tcGxldGlvbiA9IHRydWUsIGRpZEVyciA9IGZhbHNlLCBlcnI7IHJldHVybiB7IHM6IGZ1bmN0aW9uIHMoKSB7IGl0ID0gb1tTeW1ib2wuaXRlcmF0b3JdKCk7IH0sIG46IGZ1bmN0aW9uIG4oKSB7IHZhciBzdGVwID0gaXQubmV4dCgpOyBub3JtYWxDb21wbGV0aW9uID0gc3RlcC5kb25lOyByZXR1cm4gc3RlcDsgfSwgZTogZnVuY3Rpb24gZShfZTIpIHsgZGlkRXJyID0gdHJ1ZTsgZXJyID0gX2UyOyB9LCBmOiBmdW5jdGlvbiBmKCkgeyB0cnkgeyBpZiAoIW5vcm1hbENvbXBsZXRpb24gJiYgaXRbXCJyZXR1cm5cIl0gIT0gbnVsbCkgaXRbXCJyZXR1cm5cIl0oKTsgfSBmaW5hbGx5IHsgaWYgKGRpZEVycikgdGhyb3cgZXJyOyB9IH0gfTsgfVxuXG5mdW5jdGlvbiB0b29sX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5KG8sIG1pbkxlbikgeyBpZiAoIW8pIHJldHVybjsgaWYgKHR5cGVvZiBvID09PSBcInN0cmluZ1wiKSByZXR1cm4gdG9vbF9hcnJheUxpa2VUb0FycmF5KG8sIG1pbkxlbik7IHZhciBuID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG8pLnNsaWNlKDgsIC0xKTsgaWYgKG4gPT09IFwiT2JqZWN0XCIgJiYgby5jb25zdHJ1Y3RvcikgbiA9IG8uY29uc3RydWN0b3IubmFtZTsgaWYgKG4gPT09IFwiTWFwXCIgfHwgbiA9PT0gXCJTZXRcIikgcmV0dXJuIEFycmF5LmZyb20obyk7IGlmIChuID09PSBcIkFyZ3VtZW50c1wiIHx8IC9eKD86VWl8SSludCg/Ojh8MTZ8MzIpKD86Q2xhbXBlZCk/QXJyYXkkLy50ZXN0KG4pKSByZXR1cm4gdG9vbF9hcnJheUxpa2VUb0FycmF5KG8sIG1pbkxlbik7IH1cblxuZnVuY3Rpb24gdG9vbF9hcnJheUxpa2VUb0FycmF5KGFyciwgbGVuKSB7IGlmIChsZW4gPT0gbnVsbCB8fCBsZW4gPiBhcnIubGVuZ3RoKSBsZW4gPSBhcnIubGVuZ3RoOyBmb3IgKHZhciBpID0gMCwgYXJyMiA9IG5ldyBBcnJheShsZW4pOyBpIDwgbGVuOyBpKyspIHsgYXJyMltpXSA9IGFycltpXTsgfSByZXR1cm4gYXJyMjsgfVxuXG4vLyBVc3VmdWwgc3R1ZmYgZm9yIGNyZWF0aW5nIHRvb2xzLiBJbmNsdWRlIGFzIG1peGluXG5cblxuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyBjb25zdCB0b29sID0gKHtcbiAgbWV0aG9kczoge1xuICAgIGluaXRfdG9vbDogZnVuY3Rpb24gaW5pdF90b29sKCkge1xuICAgICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgICAgLy8gQ29sbGlzaW9uIGZ1bmN0aW9ucyAoZmxvYXQsIGZsb2F0KSA9PiBib29sLFxuICAgICAgdGhpcy5jb2xsaXNpb25zID0gW107XG4gICAgICB0aGlzLnBpbnMgPSBbXTtcbiAgICAgIHRoaXMubW91c2Uub24oJ21vdXNlbW92ZScsIGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIGlmIChfdGhpcy5jb2xsaXNpb25zLnNvbWUoZnVuY3Rpb24gKGYpIHtcbiAgICAgICAgICByZXR1cm4gZihfdGhpcy5tb3VzZS54LCBfdGhpcy5tb3VzZS55KTtcbiAgICAgICAgfSkpIHtcbiAgICAgICAgICBfdGhpcy5zaG93X3BpbnMgPSB0cnVlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIF90aGlzLnNob3dfcGlucyA9IGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKF90aGlzLmRyYWcpIF90aGlzLmRyYWdfdXBkYXRlKCk7XG4gICAgICB9KTtcbiAgICAgIHRoaXMubW91c2Uub24oJ21vdXNlZG93bicsIGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIGlmICh1dGlscy5kZWZhdWx0X3ByZXZlbnRlZChlKSkgcmV0dXJuO1xuXG4gICAgICAgIGlmIChfdGhpcy5jb2xsaXNpb25zLnNvbWUoZnVuY3Rpb24gKGYpIHtcbiAgICAgICAgICByZXR1cm4gZihfdGhpcy5tb3VzZS54LCBfdGhpcy5tb3VzZS55KTtcbiAgICAgICAgfSkpIHtcbiAgICAgICAgICBpZiAoIV90aGlzLnNlbGVjdGVkKSB7XG4gICAgICAgICAgICBfdGhpcy4kZW1pdCgnb2JqZWN0LXNlbGVjdGVkJyk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgX3RoaXMuc3RhcnRfZHJhZygpO1xuXG4gICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuXG4gICAgICAgICAgX3RoaXMucGlucy5mb3JFYWNoKGZ1bmN0aW9uICh4KSB7XG4gICAgICAgICAgICByZXR1cm4geC5tb3VzZWRvd24oZSwgdHJ1ZSk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgdGhpcy5tb3VzZS5vbignbW91c2V1cCcsIGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIF90aGlzLmRyYWcgPSBudWxsO1xuXG4gICAgICAgIF90aGlzLiRlbWl0KCdzY3JvbGwtbG9jaycsIGZhbHNlKTtcbiAgICAgIH0pO1xuICAgICAgdGhpcy5rZXlzID0gbmV3IEtleXModGhpcyk7XG4gICAgICB0aGlzLmtleXMub24oJ0RlbGV0ZScsIHRoaXMucmVtb3ZlX3Rvb2wpO1xuICAgICAgdGhpcy5rZXlzLm9uKCdCYWNrc3BhY2UnLCB0aGlzLnJlbW92ZV90b29sKTtcbiAgICAgIHRoaXMuc2hvd19waW5zID0gZmFsc2U7XG4gICAgICB0aGlzLmRyYWcgPSBudWxsO1xuICAgIH0sXG4gICAgcmVuZGVyX3BpbnM6IGZ1bmN0aW9uIHJlbmRlcl9waW5zKGN0eCkge1xuICAgICAgaWYgKHRoaXMuc2VsZWN0ZWQgfHwgdGhpcy5zaG93X3BpbnMpIHtcbiAgICAgICAgdGhpcy5waW5zLmZvckVhY2goZnVuY3Rpb24gKHgpIHtcbiAgICAgICAgICByZXR1cm4geC5kcmF3KGN0eCk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0sXG4gICAgc2V0X3N0YXRlOiBmdW5jdGlvbiBzZXRfc3RhdGUobmFtZSkge1xuICAgICAgdGhpcy4kZW1pdCgnY2hhbmdlLXNldHRpbmdzJywge1xuICAgICAgICAkc3RhdGU6IG5hbWVcbiAgICAgIH0pO1xuICAgIH0sXG4gICAgd2F0Y2hfdXVpZDogZnVuY3Rpb24gd2F0Y2hfdXVpZChuLCBwKSB7XG4gICAgICAvLyBJZiBsYXllciAkdXVpZCBpcyBjaGFuZ2VkLCB0aGVuIHJlLWluaXRcbiAgICAgIC8vIHBpbnMgJiBjb2xsaXNpb25zXG4gICAgICBpZiAobi4kdXVpZCAhPT0gcC4kdXVpZCkge1xuICAgICAgICB2YXIgX2l0ZXJhdG9yID0gdG9vbF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyKHRoaXMucGlucyksXG4gICAgICAgICAgICBfc3RlcDtcblxuICAgICAgICB0cnkge1xuICAgICAgICAgIGZvciAoX2l0ZXJhdG9yLnMoKTsgIShfc3RlcCA9IF9pdGVyYXRvci5uKCkpLmRvbmU7KSB7XG4gICAgICAgICAgICB2YXIgcCA9IF9zdGVwLnZhbHVlO1xuICAgICAgICAgICAgcC5yZV9pbml0KCk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICBfaXRlcmF0b3IuZShlcnIpO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgIF9pdGVyYXRvci5mKCk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmNvbGxpc2lvbnMgPSBbXTtcbiAgICAgICAgdGhpcy5zaG93X3BpbnMgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5kcmFnID0gbnVsbDtcbiAgICAgIH1cbiAgICB9LFxuICAgIHByZV9kcmF3OiBmdW5jdGlvbiBwcmVfZHJhdygpIHtcbiAgICAgIC8vIERlbGV0ZSBhbGwgY29sbGlzaW9uIGZ1bmN0aW9ucyBiZWZvcmVcbiAgICAgIC8vIHRoZSBkcmF3KCkgY2FsbCBhbmQgbGV0IHByaW1pdGl2ZXMgc2V0XG4gICAgICAvLyB0aGVtIGFnYWluXG4gICAgICB0aGlzLmNvbGxpc2lvbnMgPSBbXTtcbiAgICB9LFxuICAgIHJlbW92ZV90b29sOiBmdW5jdGlvbiByZW1vdmVfdG9vbCgpIHtcbiAgICAgIGlmICh0aGlzLnNlbGVjdGVkKSB0aGlzLiRlbWl0KCdyZW1vdmUtdG9vbCcpO1xuICAgIH0sXG4gICAgc3RhcnRfZHJhZzogZnVuY3Rpb24gc3RhcnRfZHJhZygpIHtcbiAgICAgIHRoaXMuJGVtaXQoJ3Njcm9sbC1sb2NrJywgdHJ1ZSk7XG4gICAgICB2YXIgY3Vyc29yID0gdGhpcy4kcHJvcHMuY3Vyc29yO1xuICAgICAgdGhpcy5kcmFnID0ge1xuICAgICAgICB0OiBjdXJzb3IudCxcbiAgICAgICAgeSQ6IGN1cnNvci55JFxuICAgICAgfTtcbiAgICAgIHRoaXMucGlucy5mb3JFYWNoKGZ1bmN0aW9uICh4KSB7XG4gICAgICAgIHJldHVybiB4LnJlY19wb3NpdGlvbigpO1xuICAgICAgfSk7XG4gICAgfSxcbiAgICBkcmFnX3VwZGF0ZTogZnVuY3Rpb24gZHJhZ191cGRhdGUoKSB7XG4gICAgICB2YXIgZHQgPSB0aGlzLiRwcm9wcy5jdXJzb3IudCAtIHRoaXMuZHJhZy50O1xuICAgICAgdmFyIGR5ID0gdGhpcy4kcHJvcHMuY3Vyc29yLnkkIC0gdGhpcy5kcmFnLnkkO1xuICAgICAgdGhpcy5waW5zLmZvckVhY2goZnVuY3Rpb24gKHgpIHtcbiAgICAgICAgcmV0dXJuIHgudXBkYXRlX2Zyb20oW3gudDEgKyBkdCwgeC55JDEgKyBkeV0sIHRydWUpO1xuICAgICAgfSk7XG4gICAgfVxuICB9LFxuICBjb21wdXRlZDoge1xuICAgIC8vIFNldHRpbmdzIHN0YXJ0aW5nIHdpdGggJCBhcmUgcmVzZXJ2ZWRcbiAgICBzZWxlY3RlZDogZnVuY3Rpb24gc2VsZWN0ZWQoKSB7XG4gICAgICByZXR1cm4gdGhpcy4kcHJvcHMuc2V0dGluZ3MuJHNlbGVjdGVkO1xuICAgIH0sXG4gICAgc3RhdGU6IGZ1bmN0aW9uIHN0YXRlKCkge1xuICAgICAgcmV0dXJuIHRoaXMuJHByb3BzLnNldHRpbmdzLiRzdGF0ZTtcbiAgICB9XG4gIH1cbn0pO1xuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL3N0dWZmL2ljb25zLmpzb25cbmNvbnN0IGljb25zX25hbWVzcGFjZU9iamVjdCA9IEpTT04ucGFyc2UoJ3tcImV4dGVuZGVkLnBuZ1wiOlwiZGF0YTppbWFnZS9wbmc7YmFzZTY0LGlWQk9SdzBLR2dvQUFBQU5TVWhFVWdBQUFCa0FBQUFaQVFNQUFBRCtKeGNnQUFBQUFYTlNSMElCMmNrc2Z3QUFBQWx3U0ZsekFBQUxFd0FBQ3hNQkFKcWNHQUFBQUFaUVRGUkZBQUFBVFUxTmtKK3JPUUFBQUFKMFVrNVRBUDlia1NLMUFBQUFORWxFUVZSNG5HTmdnQUJHRU1FRUlsaEFCQWVJK0FBU0YwQWxIbUFxQTRrektBQXg4d0dRdUFNS3dkNkFvWXpCQVdvbkF3QWNMd1RnTmZKM1JRQUFBQUJKUlU1RXJrSmdnZz09XCIsXCJyYXkucG5nXCI6XCJkYXRhOmltYWdlL3BuZztiYXNlNjQsaVZCT1J3MEtHZ29BQUFBTlNVaEVVZ0FBQUJrQUFBQVpBUU1BQUFEK0p4Y2dBQUFBQVhOU1IwSUIyY2tzZndBQUFBbHdTRmx6QUFBTEV3QUFDeE1CQUpxY0dBQUFBQVpRVEZSRkFBQUFUVTFOa0orck9RQUFBQUowVWs1VEFQOWJrU0sxQUFBQU1rbEVRVlI0bkdOZ1FBSk1JSUlGUkhDQUNBRVFvUUFpSElDWXZRRWtqa3J3WXlwakFJa3p3azJ6QVJFdXFJUUZ6RDRBRTNrRTRCRW1HZ2dBQUFBQVNVVk9SSzVDWUlJPVwiLFwic2VnbWVudC5wbmdcIjpcImRhdGE6aW1hZ2UvcG5nO2Jhc2U2NCxpVkJPUncwS0dnb0FBQUFOU1VoRVVnQUFBQmtBQUFBWkFnTUFBQUM1aDIzd0FBQUFBWE5TUjBJQjJja3Nmd0FBQUFsd1NGbHpBQUFMRXdBQUN4TUJBSnFjR0FBQUFBbFFURlJGQUFBQVRVMU5KQ1FrQ3hjSElRQUFBQU4wVWs1VEFQOFNtdXRJNUFBQUFDeEpSRUZVZUp4allNQUNHQU1nTkFzTGRwb1ZLaThBVmU4QTFRYmxRbFdSS3QwQW9VTHcydzF6R3hvQUFCZGlBdmlRaEYvbUFBQUFBRWxGVGtTdVFtQ0NcIixcImFkZC5wbmdcIjpcImRhdGE6aW1hZ2UvcG5nO2Jhc2U2NCxpVkJPUncwS0dnb0FBQUFOU1VoRVVnQUFBQ29BQUFBcUNBTUFBQUR5SFRscEFBQUFBWE5TUjBJQjJja3Nmd0FBQUFsd1NGbHpBQUFMRXdBQUN4TUJBSnFjR0FBQUFINVFURlJGQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUNnb0tCZ1lHR3hzYktpb3FQejgvUGo0K0JRVUZDUWtKQVFFQlpHUmtoNGVIQWdJQ0VCQVFOalkyZzRPRGdZR0JBQUFBQXdNRGVYbDVkM2QzR0JnWUVSRVJnSUNBZ0lDQU5EUTBQRHc4WTJOakNBZ0loWVdGR2hvYUp5Y25Pam82WVdGaGdJQ0FkWFYxNFkxNnNRQUFBQ3AwVWs1VEFBSUxEeElLRVNFbkppWW9LQ2dUS1NrcEtDQW5LU2tGS0NrcEppRGwveWNwS1NBMkp5WXBLU2twT2tRK3hnQUFBUmRKUkVGVWVKemxsTnQyZ3lBUVJUV2lSc0hMb0RVMEdwUFltTXYvLzJCTVMrc2dsNlo5Yk04Ymk3M2duSmtCei9zbjhsY0JJVUhvZnd0RzhUcEpLVXVUTEk2Y1lGN1FFcVJLeW5QNzFWWDlBa2hOWFZsc2JNUXJMTFFWR3lQWkxzR0hXZ1ByQ3hNSndIVVBsWGE3OU5CcDJldDVkOWYzdTNtMVh4YXRRTm43U2FnT1hDVWpDallVRHVxeGNXbEhqNE1TZncxMkZESmNoRlZpUk44KzFxY1FvVUg2bFIxTDFtRU1FRXJvZkI2V3pFVXd5bHpvbWZ6T1FHaU9KZFhpV0g3bVFvVXlNYTRXWEpRV09CdkxGdlBDR3h0NkZTcjVreUgwcWkwWWRkTkcyL3BnQ3NPamZmNFpUaXpYUE53S0l6bDU2T29HZzlkOVovKzVjczZPbitDRkNmZXZGUTNaYVR5Y3gxWU1idkRkUnZqa3AvbEhkQWNQWHpva3hjd2ZEd0FBQUFCSlJVNUVya0pnZ2c9PVwiLFwiY3Vyc29yLnBuZ1wiOlwiZGF0YTppbWFnZS9wbmc7YmFzZTY0LGlWQk9SdzBLR2dvQUFBQU5TVWhFVWdBQUFCa0FBQUFaQWdNQUFBQzVoMjN3QUFBQUFYTlNSMElCMmNrc2Z3QUFBQWx3U0ZsekFBQUxFd0FBQ3hNQkFKcWNHQUFBQUF4UVRGUkZBQUFBVFUxTlRVMU5UVTFOd2xNSEh3QUFBQVIwVWs1VEFPdmh4YnBQclVrQUFBQWtTVVJCVkhpY1kyQmdZSEJnZ0FCeWFieGcxV29HQnEycFJDazlBS1ViY05ENDNBRUF1ZllIbFN1dXNFNEFBQUFBU1VWT1JLNUNZSUk9XCIsXCJkaXNwbGF5X29mZi5wbmdcIjpcImRhdGE6aW1hZ2UvcG5nO2Jhc2U2NCxpVkJPUncwS0dnb0FBQUFOU1VoRVVnQUFBQ29BQUFBcUNBTUFBQUR5SFRscEFBQUFBWE5TUjBJQjJja3Nmd0FBQUFsd1NGbHpBQUFMRXdBQUN4TUJBSnFjR0FBQUFVMVFURlJGQUFBQWg0ZUhoNGVIQUFBQUFBQUFBQUFBQXdNREFBQUFBQUFBaG9hR0dCZ1lnWUdCQUFBQVB6OC9BZ0lDZzRPRENRa0poSVNFaDRlSGg0ZUhQajQrTmpZMmdZR0JnNE9EZ1lHQmdZR0Jnb0tDQVFFQkp5Y25nb0tDaFlXRkVCQVFnNE9EQ0FnSUtpb3FaR1JrQ2dvS0JRVUZFUkVSZDNkM2dZR0JHeHNiTkRRMGhJU0VnWUdCUER3OGdZR0JnWUdCaDRlSGg0ZUhoWVdGaDRlSGdvS0NoWVdGZ1lHQmdZR0JnNE9EaG9hR2c0T0RZV0ZoZ29LQ0JnWUdkWFYxZ29LQ2c0T0RnWUdCZ0lDQWdZR0JBQUFBZzRPRGhZV0ZoSVNFaDRlSGdvS0NoWVdGT2pvNmdvS0NHaG9haDRlSGg0ZUhoNGVIZ29LQ2g0ZUhlWGw1aG9hR2dvS0NoSVNFZ1lHQmdZR0Jnb0tDWTJOamdZR0Jnb0tDaDRlSGdvS0NnWUdCaG9hR2c0T0Rob2FHaFlXRmg0ZUhnWUdCaG9hR2hvYUdob2FHZzRPRGdvS0NoSVNFZ29LQ2hZV0ZoNGVIZktrdFV3QUFBRzkwVWs1VEFDbi9BaEVGS0E4U0xDYnhDaWdvVkJOS1VUWW9KL2xoM1B5QUtTYVROaUJ0SUNZcElTZ2dLU2ttSjBMRUtlZjNsR3hBOHJuLy8rcGNNU2twbkNjcHRIUEpLZTBMVWpueDVMektLYU1uWDczaGw2NHBMbmhrek5TZ0tlTHYxN0xRK2xpSXphTGU3UGZUdzV0RnB6M0sxZlhSL2dBQUFnQkpSRUZVZUp6bGxOZFh3akFVeGtuQjBsSW9DS1ZzR1RJRlFSQVo3cjMzM251di8vL1IzTFo0bWxEUVovMGVrcDdiMzduNWJuSVRrK21meUR4djVUaXIzZndqYUVsTzVCSU9LWkZMSlMxZFFWZkkwWTgwOVR0RVYrZWxvOTVScEZQV0crMWdvNGZkUTVReWJJOGhhYU5Ca00yQU5iTTA5Ym5yd2FQWTdpRktyejdFTUJkdTdDSGRWcnVYSXQwTTFoYitHS0EzTFRSS2twNWxUQTZEZzZ4SWtoYUhodlExSWxXL1VDb3VRZEpOSlRSSXBrMXFPNyt3VXBjZnBsNTM3b0JjN1ZOaXAzR2kvQW1WUEJBQzFVckw2SFh0U0dWVCtrMll6MEZvY2FkMDdPTVJmM1A1QkViZDYzUEZReDdITit3NjFKb0FtK3VCbFY0OE8vMGprTFNNbXRQQ21ROEh3bFlkeWtGVjQvTEpQcDdlM2hWeUZkYXBITmVoTGs2UFNqaFNrQnZ3dS9jRnlKR0lZdk95aG9jMWpqWVFGR2J5Z0Q0Q1dqb0FNbGEvb2czWW9TdytLUGhqUE5vRmNpbTRpRkQrcEZZQTh6WjlXZVlVNU9CalozT1JXeUNmRzAzRSs0N2tLcENJSlRwR080S1A4WE1ndHc5OTB4Ry9QQk5UZ21QRUVYd2Y3UDQyb09kRklSQW9CQ3RxVEtMNlJjd3E0WHNnaDV4WUMvbW1TczZ5SktrMVliblZlVHExTmFFcG1sSGJtVm4yRU9Sa1cydHJGMlp6bUhHVFNVTUdsMWE5aHA0eVNScGRROHlLR1VScE1tUklZZzlwYjFZUHpnNmtPNzljTGxFNmJZRmpFdHY5MWJMRVV4dmh3Yld3alkxM0J4VWI5bDgrbW45RVg4eDNOa2k4ZmY1d0FBQUFBRWxGVGtTdVFtQ0NcIixcImRpc3BsYXlfb24ucG5nXCI6XCJkYXRhOmltYWdlL3BuZztiYXNlNjQsaVZCT1J3MEtHZ29BQUFBTlNVaEVVZ0FBQUNvQUFBQXFDQU1BQUFEeUhUbHBBQUFBQVhOU1IwSUIyY2tzZndBQUFBbHdTRmx6QUFBTEV3QUFDeE1CQUpxY0dBQUFBUjFRVEZSRkFBQUFoNGVIZ1lHQkFBQUFBQUFBZ1lHQkFBQUFBd01EQUFBQUFBQUFnWUdCZzRPREdCZ1lnWUdCaElTRUFBQUFQejgvQWdJQ2hvYUdDUWtKaFlXRlBqNCtOalkyZ29LQ2dZR0JBUUVCSnljbmdZR0Jnb0tDRUJBUUNBZ0loSVNFS2lvcVpHUmtDZ29LQlFVRkVSRVJkM2QzZ1lHQmc0T0RnWUdCR3hzYk5EUTBoSVNFZ29LQ2dvS0NoWVdGUER3OGdZR0JnWUdCaG9hR2dvS0NnNE9EZ29LQ2dZR0Jnb0tDZ29LQ2dvS0NnNE9EZ29LQ2hvYUdnb0tDZ1lHQmhvYUdnNE9EWVdGaEJnWUdkWFYxZ1lHQmc0T0Rnb0tDZ0lDQWc0T0RnNE9EaElTRUFBQUFnNE9ET2pvNmdZR0JHaG9hZVhsNWdvS0NnWUdCZ29LQ2hZV0Znb0tDaElTRWdvS0NZMk5qZ1lHQmc0T0RnWUdCZ1lHQmc0T0RnWUdCbzhuNTRBQUFBRjkwVWs1VEFDbi9BaEgzQlNnUEV1aFVKdkZBQ2lnb0xCTTJLQ2VBNnlrbStwTWdJRWttS1NFb0lDbjlYQ2ttSjB1Nm5Eb3A0c1V5cEd1RXpMWjZ2bUNZTFovZEx5a3BKeW5VWWE4cGNsbENDMUlwMnljcGlzbDFQYWRGc2ludGJzUFFaZGkvYlRXN0FBQUI0VWxFUVZSNG5PV1VaMWZDTUJTR1NTR1dGaXEwVURiSWtyMlhiQndNeFMwYjFQLy9NMHhLOVhTaWZ0WDdvZWw1ODV6a3ZmY21NUmorU1JodnpSUmx0aG0vQlUzUnkzVFl6b2ZUc2FqcElPancyaU5BaklpZGRlaHZIWFNkQTBta1hFRWRHMGZrRTFERUtYbWtTVnFWSUE2ckJtc2t0VWdBV0xXSG9HcDMwVU5jbGJ0TG13UWdveXlhOTF3UFRiRnkwbVFYSjV6SlFPNkJnWFJqZkgwaVNrWDVzdEhJWHI1cjBiQi9sdThzeWpSOHJ6c0ZiUjJTcFgrNUoyZU1QM2NzTHRZc0VZMks4QmVURnVFMmphVkNCdzdiSE9CdXhxMTZBWG1wYnVpM0x0SWZiUkxVSE1ZMnE0bGNGbzJXQjRLQTFTVUFsV3VtTkVLQ3p5eEJLWnhWSHZZR2FGZ3VDQngxdk0veDBJUHpvcVFvajVTZFA0bW5zMmNDR2hCc3JnajB1YWVVQnR6TXl4UU44dzRtWVJPVFc4K3Iwb0FOcDhXNW1mNldRdzVhQ1lKMm83eW1QYUtNaTJ1VnBtV000VFc2dGRJbWdHbzFiVDRuSzZEYmJzQ2MwQVpTZG1MRUZzenpIcmg2cmlWdlJyTkEzLzlTRThRTFdRdStHanRvOStnRTlOQk13cjl6aTgzZ0ZlZUZUZTExenBtMUNIRTNIZXlWQ1NrbmYzTUlEY0ZUYmZKS2RiUjFMNHhYNDlMKy9Cb2lsbFY1dVBKcWtzaEQzSldTZ3BOTVhQL2xjckQ4K2hPODRNbkRyNVlwRkh2MEZlOTlWakowR0JSczJINzRhUDZSK0FDcitURnZaTkFRMXdBQUFBQkpSVTVFcmtKZ2dnPT1cIixcImRvd24ucG5nXCI6XCJkYXRhOmltYWdlL3BuZztiYXNlNjQsaVZCT1J3MEtHZ29BQUFBTlNVaEVVZ0FBQUNvQUFBQXFDQU1BQUFEeUhUbHBBQUFBQVhOU1IwSUIyY2tzZndBQUFLVlFURlJGQUFBQWc0T0RnSUNBQUFBQUFBQUFBQUFBQ0FnSUFBQUFBQUFBQUFBQUFBQUFPVGs1aFlXRkVCQVFmSHg4T0RnNGRuWjJORFEwWFYxZEd4c2JLQ2dvZ0lDQUZCUVVJaUlpWkdSa2dJQ0FnSUNBRlJVVkFBQUFnSUNBZ0lDQWdJQ0FmMzkvTGk0dWdJQ0FjSEJ3Z29LQ2dJQ0Fnb0tDZ0lDQWc0T0RnWUdCUGo0K2dvS0NnSUNBaElTRWdZR0JnSUNBZ29LQ2dJQ0FnWUdCZ1lHQmYzOS9nSUNBZ0lDQUlkUFFIQUFBQURkMFVrNVRBQ24vS0FJUklCTUZEd29vS3lBcEtTa25LU1ltekNjbUtmTDdKUkNVaTJMM0o3SXBjTFVycjBWYktYbnRORW5rTWJ4clVjRzU2Q01waTUwQUFBRlpTVVJCVkhpYzVaUnBmNE1nREllRktGYXRXbS90ZlcwOTF1N2V2djlIbTFBY291am0yeTB2RlBINUpmK0VFRTM3SjZiYmxtbGF0djRqYUJDSTRyTWZSMENNWHRBRUowZmNjZ2ZNN3RBa1FIWHpBcmREeGdnbXFHRVRHQ25KV1JPa05sT3dPcWhJaEtDdGdiU2ljdzF1Sy9kQVRTSzBhUmF0SXp5dEE4aWs0WFNpeUpuTFNtK1ZQeFVMZ2V5TEkzdUhSSkgrcWNCNFdaR3JLYjRjMjBXd0k3YjNpVXQ3NE9TNlhEK3haV3JYVUN0bWUwdUtUdmZjSjY1Q1pGYTlWT2VicXdYbWZ0K29UOHlGKy9WeW1UNFhlR0IrWHg4TCtqNGdCY29GSURUK29NejZRcDkzWTc0cENlQnBVWGFMdVcwclVrNnIxaXYzblAzMjJld1lrZ3YyblpJdmdwU1BRRHJZNXdUalJKRE5nOVhBRS8rdVNYSVZYODEyR2RLRW10dlIycnRXYXcrNU1BT3VvZkp5NzlTWHU5VGdCbDRkOURaZEkwTmpneWlzd05DQi9xazFKNUJtdnArbFFPYTlJSk5oVzRieG02SDVSK3dMUVlNU1FYWk56YmNBQUFBQVNVVk9SSzVDWUlJPVwiLFwicHJpY2VfcmFuZ2UucG5nXCI6XCJkYXRhOmltYWdlL3BuZztiYXNlNjQsaVZCT1J3MEtHZ29BQUFBTlNVaEVVZ0FBQUJrQUFBQVpBUU1BQUFEK0p4Y2dBQUFBQVhOU1IwSUIyY2tzZndBQUFBbHdTRmx6QUFBTEV3QUFDeE1CQUpxY0dBQUFBQVpRVEZSRkFBQUFUVTFOa0orck9RQUFBQUowVWs1VEFQOWJrU0sxQUFBQUlVbEVRVlI0bkdOZ2dBUG0vdzlnVEE0UUlRTWl0RUNFSjF5TUVnTE5EaUFBQURmZ0JNUnU3OEdnQUFBQUFFbEZUa1N1UW1DQ1wiLFwicHJpY2VfdGltZS5wbmdcIjpcImRhdGE6aW1hZ2UvcG5nO2Jhc2U2NCxpVkJPUncwS0dnb0FBQUFOU1VoRVVnQUFBQmtBQUFBWkFRTUFBQUQrSnhjZ0FBQUFBWE5TUjBJQjJja3Nmd0FBQUFsd1NGbHpBQUFMRXdBQUN4TUJBSnFjR0FBQUFBWlFURlJGQUFBQVRVMU5rSityT1FBQUFBSjBVazVUQVA5YmtTSzFBQUFBT2tsRVFWUjRuR05nZ0FQbS93OWdUQTRRSVFQRUNscE1RTUlUUkhDQUNTY1FvUVFpaEJnWTlQLy9ncktnWWs1d2RUQUNZaFFIRmp1QUFBQlpGQWxjNGUxZmNRQUFBQUJKUlU1RXJrSmdnZz09XCIsXCJyZW1vdmUucG5nXCI6XCJkYXRhOmltYWdlL3BuZztiYXNlNjQsaVZCT1J3MEtHZ29BQUFBTlNVaEVVZ0FBQUNvQUFBQXFDQU1BQUFEeUhUbHBBQUFBQVhOU1IwSUIyY2tzZndBQUFBbHdTRmx6QUFBTEV3QUFDeE1CQUpxY0dBQUFBSzVRVEZSRkFBQUFoNGVIZ0lDQUFBQUFBQUFBaDRlSEFBQUFBd01EQUFBQUFBQUFnSUNBR0JnWUFBQUFQejgvQWdJQ2dJQ0FDUWtKaG9hR2hvYUdnSUNBUGo0K05qWTJnWUdCZzRPRGdZR0JBUUVCSnljbmdvS0NFQkFRZ0lDQWdJQ0FDQWdJS2lvcVpHUmtDZ29LQlFVRkVSRVJkM2QzZ1lHQkd4c2JORFEwZ0lDQVBEdzhZV0ZoQmdZR2RYVjFnSUNBZzRPRGdJQ0FBQUFBT2pvNkdob2FlWGw1Z0lDQWhZV0ZZMk5qaFlXRmdJQ0E5TzBvQ2dBQUFEcDBVazVUQUNuL0FoRXJCU2dQRXZFbUNpZ293eE11TWNnb0o3aFdyQ2ttZENENnZTQW1LU0VvSUNrcEppZTZLU2tuS1NrcDB3c3BKeW5DTWlrMTFyckx0ZThBQUFGd1NVUkJWSGljNVpUWGtvSXdGSVpOQUFQU3BLa29SUVY3V2N2YTN2L0ZGaVJtRXdpc2U3dDdiczdNUDk4ay95bEpxL1ZQUWpqS2lpSnJ3bytnT04wdXhybzdYaVJUc1JIcyt2b0U0SmpvUnJmKzZzRDdBRlRNdmFER1JodDlnbExNVUp0THFtVXdENVhEQ29oSEFtQlVQUVNWMjdHSHRGSzd4eWNCV0phYjV1UGFSK0hsbXVlN0dmWnhId3lXRkhWTVFnaFhGZ0QyQThJT1p0ZnNzZE5KSVhjeUZFYVNmY2h6cDlCdU1WUCtGaHZyNVFoMG5HZnFZVEdobTNCY1lGVWFRQktPaE1XelJxSHlHRlJZMDNwcFE1bENGWjMwUmxvVlpHUVRhYTNRcUV0ME95clFua1NrazhJMVlKa3ZBd1BDTWdZMFVwYnpYUlpoVmJvc0lXR2JaVExOUXN6R01DTTQyRkpFaldERGpJQU10cCt4ajZ4MksrL0RxTkRjMHI0WWM4eUdsM3VlcjJhSXlUMWl5ZDhzWVN1WThjbGRaYlZySDR6UGViVHZQOE9NTlNvZWRqNlh6RHlrM3B3Rzk4dTAvdWZxR3U3dEJXNWMxUHhyaVhGeUhxNVBReFhGemVEVGh2Ym1wL2xINGd0Nld4ZlowM0g4RHdBQUFBQkpSVTVFcmtKZ2dnPT1cIixcInNldHRpbmdzLnBuZ1wiOlwiZGF0YTppbWFnZS9wbmc7YmFzZTY0LGlWQk9SdzBLR2dvQUFBQU5TVWhFVWdBQUFDb0FBQUFxQ0FNQUFBRHlIVGxwQUFBQUFYTlNSMElCMmNrc2Z3QUFBQWx3U0ZsekFBQUxFd0FBQ3hNQkFKcWNHQUFBQVc1UVRGUkZBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQ2dvS0JnWUdHeHNiS2lvcVFFQkFQajQrQlFVRkNBZ0lBUUVCUHo4L1pXVmxoNGVIWkdSa0FnSUNDUWtKRHc4UE5qWTJnNE9EZ29LQ05UVTFFQkFRQUFBQUF3TURlWGw1ZDNkM0FBQUFHQmdZQUFBQUVSRVJpb3FLZ29LQ2dvS0Nnb0tDZ1lHQmdvS0NoSVNFaG9hR05EUTBnNE9EZ0lDQWdJQ0FnSUNBZ1lHQmdZR0JoWVdGZ0lDQWdJQ0FQVDA5QUFBQWdZR0JnSUNBZ0lDQWdJQ0FnSUNBWTJOakNBZ0lnSUNBZ0lDQWhZV0ZoWVdGZ1lHQkhCd2NnSUNBaFlXRkdob2FnWUdCZ1lHQmc0T0Rob2FHSnljbkFBQUFoSVNFZ0lDQWc0T0RQRHc4QUFBQWdvS0NnSUNBaElTRU9qbzZoNGVIZ29LQ2dZR0JnSUNBZjM5L2dZR0Jnb0tDZ0lDQUdCZ1lnWUdCZzRPRGc0T0RnSUNBQ3dzTGdZR0JnSUNBZ1lHQmdZR0JnWUdCZ0lDQWdZR0JZV0ZoZjM5L2c0T0RQajQrZ1lHQmc0T0RnSUNBaFlXRmdvS0NnWUdCZ0lDQWdZR0Jnb0tDZFhWMVQwa0M5UUFBQUhwMFVrNVRBQUlMRHhNS0VTRW5KaVlwS1NnVEtTZ3BLU2tvRXlBbktTa25JQVlvS1NrRkpRRWdLbDk0allWdlZDNG5VOWYvK0s4cE91NzFLQkNpM05QcS9pa2cwZTAxTm9rbTFVVW5zWlZxUVNZT1Q5bHJLUkp6NWxJcEsxMmp5dStzZXNnbmhHVkx4Q0c1NWE2VW0rR2FLZkpDS0tSZ0tVdDhvY2VyZ3ltRFE5a25BQUFCc0VsRVFWUjRuT1dVVjF2Q01CU0dnMUFRcEJacmNWZEUzS0p4bzRMZ251Q29lNEY3b3JqSHY3ZG9UazNiZ0Y3cmQ1T25YOTRuWitTa0NQMFRXUXFzTnB1VnMvd0kyaDJGVGxlUjIrWGtIZmE4WUxIZ0tSR0pTajJTTjNmb3N2SUtrVkpsVlhXT05HcmtXdEVnbjF6SEpQMUdNQ3MvZzdYSUxGSVVwWG9UV21hS1RuSUltR292aDcyR3hxYm1sdGEyZHZnT0dwc21RTzBkbmZoVFhkM0U2SkgwcE4xRE5ucjdNRkUvSERzUTBxRU82UHhnOXNDaDRYRGtHeDJKNnNvdkJEK0c4ZWlZdW81UHhMVEtlTG9KQlpOZ1QyRWNualkwWVlhalVLc0w3RmsxZ2NqVTNQd0NoY1lURkdvckFuc1JxbHBhMXRBVmhVYmRtcis2UnRqSU9sZ2JDak1CVWR6YzJ0N1p6Yko3ekFRNHA2R1NmUlZOd2tlS0xzdkNnMzF3MkpCZGpsVDBHRHhaTnpFbnBjUSt4V2ZuRnhlWFZ5cDZUYXkwN2dxK0wvWVVPb0J2Ym9tVjBWOHNraXEvL0R1dFdmZUVmSkQxSlBMQ0VENCtQYjhrWDk4NnRBcE5RNGlxZlNKVDc2YlJ6dmxnQlBPRFFYVy9mb1lxSzVseWVCZVlKRUwxZ2FvZUdud0lCaGpSb1E5U1pnVEFkRWJPLzljS1JmbVorTXBHUENWSFEzbkJ6elM0aEtJa3VOeWgvNWcrQUxpQVhTU2FzOWh3QUFBQUFFbEZUa1N1UW1DQ1wiLFwidGltZV9yYW5nZS5wbmdcIjpcImRhdGE6aW1hZ2UvcG5nO2Jhc2U2NCxpVkJPUncwS0dnb0FBQUFOU1VoRVVnQUFBQmtBQUFBWkFRTUFBQUQrSnhjZ0FBQUFBWE5TUjBJQjJja3Nmd0FBQUFsd1NGbHpBQUFMRXdBQUN4TUJBSnFjR0FBQUFBWlFURlJGQUFBQVRVMU5rSityT1FBQUFBSjBVazVUQVA5YmtTSzFBQUFBSkVsRVFWUjRuR05nd0FzVUdKaFFDU2NRb1FRaWhCZ1k5UC8vZ3JLZ1lrNFlPdkFDQUNPcEJLRzZTdmorQUFBQUFFbEZUa1N1UW1DQ1wiLFwidHJhc2gucG5nXCI6XCJkYXRhOmltYWdlL3BuZztiYXNlNjQsaVZCT1J3MEtHZ29BQUFBTlNVaEVVZ0FBQUJrQUFBQVpBUU1BQUFEK0p4Y2dBQUFBQVhOU1IwSUIyY2tzZndBQUFBbHdTRmx6QUFBTEV3QUFDeE1CQUpxY0dBQUFBQVpRVEZSRkFBQUFUVTFOa0orck9RQUFBQUowVWs1VEFQOWJrU0sxQUFBQUxVbEVRVlI0bkdOZ0FJTjZFTkhRQUNYNC8vOWdZQkJnWUlFU1lDNExrQTBsUEVrbUdGQUk1djhQSUxZQ0FIeWdESnhsSzBSVUFBQUFBRWxGVGtTdVFtQ0NcIixcInVwLnBuZ1wiOlwiZGF0YTppbWFnZS9wbmc7YmFzZTY0LGlWQk9SdzBLR2dvQUFBQU5TVWhFVWdBQUFDb0FBQUFxQ0FNQUFBRHlIVGxwQUFBQUFYTlNSMElCMmNrc2Z3QUFBQWx3U0ZsekFBQUxFd0FBQ3hNQkFKcWNHQUFBQU1aUVRGUkZBQUFBaDRlSGdJQ0FBQUFBQUFBQUFBQUFBd01EQUFBQUFBQUFHQmdZQUFBQVB6OC9BZ0lDQ1FrSmdJQ0FoNGVIUGo0K05qWTJBUUVCSnljbkVCQVFnSUNBZ0lDQUNBZ0lLaW9xWkdSa0Nnb0tCUVVGZ1lHQkVSRVJkM2QzZ1lHQkd4c2JORFEwZ0lDQWdZR0JQRHc4Z1lHQmg0ZUhnSUNBWVdGaEJnWUdnWUdCZFhWMWdvS0NnNE9EaFlXRmdJQ0Fnb0tDQUFBQWhJU0VPam82Z0lDQUdob2FnWUdCZVhsNWhvYUdnSUNBWTJOamc0T0Rnb0tDZ29LQ2dZR0Jnb0tDZzRPRGdvS0M2NHV3MWdBQUFFSjBVazVUQUNuL0FoRUZLQThTSmdvb0tCUDdLaWduS1NZZzljMGdKaWtoS0xRZ0tTa21KN3l3S1k4czVTa25sQ2x4S1RNcFh3dEZLZTBuZWlrdThDbEtXbVNiYkZGak01R0hTZ0FBQVc1SlJFRlVlSnpsbEdkL2dqQVF4azNBTUZXV09IRHZWYTJyVmJ1Ly81Y3FoSldRUU8zYjlua1Zqdi92N3JuTEtKWCtpWVM5Sk11U0t2d0lpdTNsb0trWnpZSFhGZ3ZCaXFXMVFLU1dwbGZ5U3p2bUF5RFVONTBjRzJYMERETHFvVEtYVkxKZ0lJWERDb2hIQXFDekhoeW1ldVNoeS9SdThra0FodG1oV1VUdlc5ZmRFblBRYVZMVTBuOFhGMEwza241UDZMVHRaUEtnTm9LK1JyVWtjR3RRN1M5VHNnT3h4aW5ya1VQWUQrTHdMQ0loN0NUc1dTVlFxUm1UdVBxcGl0bFpGTFFsQXBYanJzWUJjMzM1d093NDdrc21VU01NcmdLaS9nbkFFL2F3Q3FOSG1UVXdEZjVYMzRMbEJ1ZWRzZ2JVc0sxNWtQTXhUSVh6enZGU0lkc1NQQnc3bkdEMUsrN2JMM0Y5eFN0RW5aaG9DdzcxVGJwTDcxR0JCYlVGMU1abVpXVE9pOTdQSTNlSUpuOXpDRXRPajArdW1hT2RlMkVzenFXOS94cjZyTTU0V0Z0YzB2ZlFOYWs1N0liZC9KZXJvaHUzR0Z3WXFQalZFaHZlMlo0Y2JRVTFpa0ZzUTczejBmd2orZ2EzVkJlekd1Z2dGUUFBQUFCSlJVNUVya0pnZ2c9PVwifScpO1xuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL2RlZmluZVByb3BlcnR5LmpzXG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHZhbHVlKSB7XG4gIGlmIChrZXkgaW4gb2JqKSB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwga2V5LCB7XG4gICAgICB2YWx1ZTogdmFsdWUsXG4gICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgd3JpdGFibGU6IHRydWVcbiAgICB9KTtcbiAgfSBlbHNlIHtcbiAgICBvYmpba2V5XSA9IHZhbHVlO1xuICB9XG5cbiAgcmV0dXJuIG9iajtcbn1cbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9jb21wb25lbnRzL3ByaW1pdGl2ZXMvcGluLmpzXG5cblxuXG4vLyBTZW1pLWF1dG9tYXRpYyBwaW4gb2JqZWN0LiBGb3Igc3RyZXRjaGluZyB0aGluZ3MuXG5cblxudmFyIFBpbiA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIC8vIChDb21wIHJlZmVyZW5jZSwgYSBuYW1lIGluIG92ZXJsYXkgc2V0dGluZ3MsXG4gIC8vIHBpbiBwYXJhbWV0ZXJzKVxuICBmdW5jdGlvbiBQaW4oY29tcCwgbmFtZSwgcGFyYW1zKSB7XG4gICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgIGlmIChwYXJhbXMgPT09IHZvaWQgMCkge1xuICAgICAgcGFyYW1zID0ge307XG4gICAgfVxuXG4gICAgY2xhc3NDYWxsQ2hlY2tfY2xhc3NDYWxsQ2hlY2sodGhpcywgUGluKTtcblxuICAgIHRoaXMuUkFESVVTID0gY29tcC4kcHJvcHMuY29uZmlnLlBJTl9SQURJVVMgfHwgNS41O1xuICAgIHRoaXMuUkFESVVTX1NRID0gTWF0aC5wb3codGhpcy5SQURJVVMgKyA3LCAyKTtcblxuICAgIGlmICh1dGlscy5pc19tb2JpbGUpIHtcbiAgICAgIHRoaXMuUkFESVVTICs9IDI7XG4gICAgICB0aGlzLlJBRElVU19TUSAqPSAyLjU7XG4gICAgfVxuXG4gICAgdGhpcy5DT0xPUl9CQUNLID0gY29tcC4kcHJvcHMuY29sb3JzLmJhY2s7XG4gICAgdGhpcy5DT0xPUl9CUiA9IGNvbXAuJHByb3BzLmNvbG9ycy50ZXh0O1xuICAgIHRoaXMuY29tcCA9IGNvbXA7XG4gICAgdGhpcy5sYXlvdXQgPSBjb21wLmxheW91dDtcbiAgICB0aGlzLm1vdXNlID0gY29tcC5tb3VzZTtcbiAgICB0aGlzLm5hbWUgPSBuYW1lO1xuICAgIHRoaXMuc3RhdGUgPSBwYXJhbXMuc3RhdGUgfHwgJ3NldHRsZWQnO1xuICAgIHRoaXMuaGlkZGVuID0gcGFyYW1zLmhpZGRlbiB8fCBmYWxzZTtcbiAgICB0aGlzLm1vdXNlLm9uKCdtb3VzZW1vdmUnLCBmdW5jdGlvbiAoZSkge1xuICAgICAgcmV0dXJuIF90aGlzLm1vdXNlbW92ZShlKTtcbiAgICB9KTtcbiAgICB0aGlzLm1vdXNlLm9uKCdtb3VzZWRvd24nLCBmdW5jdGlvbiAoZSkge1xuICAgICAgcmV0dXJuIF90aGlzLm1vdXNlZG93bihlKTtcbiAgICB9KTtcbiAgICB0aGlzLm1vdXNlLm9uKCdtb3VzZXVwJywgZnVuY3Rpb24gKGUpIHtcbiAgICAgIHJldHVybiBfdGhpcy5tb3VzZXVwKGUpO1xuICAgIH0pO1xuXG4gICAgaWYgKGNvbXAuc3RhdGUgPT09ICdmaW5pc2hlZCcpIHtcbiAgICAgIHRoaXMuc3RhdGUgPSAnc2V0dGxlZCc7XG4gICAgICB0aGlzLnVwZGF0ZV9mcm9tKGNvbXAuJHByb3BzLnNldHRpbmdzW25hbWVdKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy51cGRhdGUoKTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5zdGF0ZSAhPT0gJ3NldHRsZWQnKSB7XG4gICAgICB0aGlzLmNvbXAuJGVtaXQoJ3Njcm9sbC1sb2NrJywgdHJ1ZSk7XG4gICAgfVxuICB9XG5cbiAgY3JlYXRlQ2xhc3NfY3JlYXRlQ2xhc3MoUGluLCBbe1xuICAgIGtleTogXCJyZV9pbml0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJlX2luaXQoKSB7XG4gICAgICB0aGlzLnVwZGF0ZV9mcm9tKHRoaXMuY29tcC4kcHJvcHMuc2V0dGluZ3NbdGhpcy5uYW1lXSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImRyYXdcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZHJhdyhjdHgpIHtcbiAgICAgIGlmICh0aGlzLmhpZGRlbikgcmV0dXJuO1xuXG4gICAgICBzd2l0Y2ggKHRoaXMuc3RhdGUpIHtcbiAgICAgICAgY2FzZSAndHJhY2tpbmcnOlxuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgJ2RyYWdnaW5nJzpcbiAgICAgICAgICBpZiAoIXRoaXMubW92ZWQpIHRoaXMuZHJhd19jaXJjbGUoY3R4KTtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlICdzZXR0bGVkJzpcbiAgICAgICAgICB0aGlzLmRyYXdfY2lyY2xlKGN0eCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImRyYXdfY2lyY2xlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGRyYXdfY2lyY2xlKGN0eCkge1xuICAgICAgdGhpcy5sYXlvdXQgPSB0aGlzLmNvbXAubGF5b3V0O1xuXG4gICAgICBpZiAodGhpcy5jb21wLnNlbGVjdGVkKSB7XG4gICAgICAgIHZhciByID0gdGhpcy5SQURJVVMsXG4gICAgICAgICAgICBsdyA9IDEuNTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciByID0gdGhpcy5SQURJVVMgKiAwLjk1LFxuICAgICAgICAgICAgbHcgPSAxO1xuICAgICAgfVxuXG4gICAgICBjdHgubGluZVdpZHRoID0gbHc7XG4gICAgICBjdHguc3Ryb2tlU3R5bGUgPSB0aGlzLkNPTE9SX0JSO1xuICAgICAgY3R4LmZpbGxTdHlsZSA9IHRoaXMuQ09MT1JfQkFDSztcbiAgICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICAgIGN0eC5hcmModGhpcy54ID0gdGhpcy5sYXlvdXQudDJzY3JlZW4odGhpcy50KSwgdGhpcy55ID0gdGhpcy5sYXlvdXQuJDJzY3JlZW4odGhpcy55JCksIHIgKyAwLjUsIDAsIE1hdGguUEkgKiAyLCB0cnVlKTtcbiAgICAgIGN0eC5maWxsKCk7XG4gICAgICBjdHguc3Ryb2tlKCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInVwZGF0ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB1cGRhdGUoKSB7XG4gICAgICB0aGlzLnkkID0gdGhpcy5jb21wLiRwcm9wcy5jdXJzb3IueSQ7XG4gICAgICB0aGlzLnkgPSB0aGlzLmNvbXAuJHByb3BzLmN1cnNvci55O1xuICAgICAgdGhpcy50ID0gdGhpcy5jb21wLiRwcm9wcy5jdXJzb3IudDtcbiAgICAgIHRoaXMueCA9IHRoaXMuY29tcC4kcHJvcHMuY3Vyc29yLng7IC8vIFNhdmUgcGluIGFzIHRpbWUgaW4gSUIgbW9kZVxuICAgICAgLy9pZiAodGhpcy5sYXlvdXQudGlfbWFwLmliKSB7XG4gICAgICAvLyAgICB0aGlzLnQgPSB0aGlzLmxheW91dC50aV9tYXAuaTJ0KHRoaXMudCApXG4gICAgICAvL31cbiAgICAgIC8vIFJlc2V0IHRoZSBzZXR0aW5ncyBhdHRhaGVkIHRvIHRoZSBwaW4gKHBvc2l0aW9uKVxuXG4gICAgICB0aGlzLmNvbXAuJGVtaXQoJ2NoYW5nZS1zZXR0aW5ncycsIF9kZWZpbmVQcm9wZXJ0eSh7fSwgdGhpcy5uYW1lLCBbdGhpcy50LCB0aGlzLnkkXSkpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJ1cGRhdGVfZnJvbVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB1cGRhdGVfZnJvbShkYXRhLCBlbWl0KSB7XG4gICAgICBpZiAoZW1pdCA9PT0gdm9pZCAwKSB7XG4gICAgICAgIGVtaXQgPSBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgaWYgKCFkYXRhKSByZXR1cm47XG4gICAgICB0aGlzLmxheW91dCA9IHRoaXMuY29tcC5sYXlvdXQ7XG4gICAgICB0aGlzLnkkID0gZGF0YVsxXTtcbiAgICAgIHRoaXMueSA9IHRoaXMubGF5b3V0LiQyc2NyZWVuKHRoaXMueSQpO1xuICAgICAgdGhpcy50ID0gZGF0YVswXTtcbiAgICAgIHRoaXMueCA9IHRoaXMubGF5b3V0LnQyc2NyZWVuKHRoaXMudCk7IC8vIFRPRE86IFNhdmUgcGluIGFzIHRpbWUgaW4gSUIgbW9kZVxuICAgICAgLy9pZiAodGhpcy5sYXlvdXQudGlfbWFwLmliKSB7XG4gICAgICAvLyAgICB0aGlzLnQgPSB0aGlzLmxheW91dC50aV9tYXAuaTJ0KHRoaXMudCApXG4gICAgICAvL31cblxuICAgICAgaWYgKGVtaXQpIHRoaXMuY29tcC4kZW1pdCgnY2hhbmdlLXNldHRpbmdzJywgX2RlZmluZVByb3BlcnR5KHt9LCB0aGlzLm5hbWUsIFt0aGlzLnQsIHRoaXMueSRdKSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInJlY19wb3NpdGlvblwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByZWNfcG9zaXRpb24oKSB7XG4gICAgICB0aGlzLnQxID0gdGhpcy50O1xuICAgICAgdGhpcy55JDEgPSB0aGlzLnkkO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJtb3VzZW1vdmVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gbW91c2Vtb3ZlKGV2ZW50KSB7XG4gICAgICBzd2l0Y2ggKHRoaXMuc3RhdGUpIHtcbiAgICAgICAgY2FzZSAndHJhY2tpbmcnOlxuICAgICAgICBjYXNlICdkcmFnZ2luZyc6XG4gICAgICAgICAgdGhpcy5tb3ZlZCA9IHRydWU7XG4gICAgICAgICAgdGhpcy51cGRhdGUoKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwibW91c2Vkb3duXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG1vdXNlZG93bihldmVudCwgZm9yY2UpIHtcbiAgICAgIGlmIChmb3JjZSA9PT0gdm9pZCAwKSB7XG4gICAgICAgIGZvcmNlID0gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIGlmICh1dGlscy5kZWZhdWx0X3ByZXZlbnRlZChldmVudCkgJiYgIWZvcmNlKSByZXR1cm47XG5cbiAgICAgIHN3aXRjaCAodGhpcy5zdGF0ZSkge1xuICAgICAgICBjYXNlICd0cmFja2luZyc6XG4gICAgICAgICAgdGhpcy5zdGF0ZSA9ICdzZXR0bGVkJztcbiAgICAgICAgICBpZiAodGhpcy5vbl9zZXR0bGVkKSB0aGlzLm9uX3NldHRsZWQoKTtcbiAgICAgICAgICB0aGlzLmNvbXAuJGVtaXQoJ3Njcm9sbC1sb2NrJywgZmFsc2UpO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgJ3NldHRsZWQnOlxuICAgICAgICAgIGlmICh0aGlzLmhpZGRlbikgcmV0dXJuO1xuXG4gICAgICAgICAgaWYgKHRoaXMuaG92ZXIoKSkge1xuICAgICAgICAgICAgdGhpcy5zdGF0ZSA9ICdkcmFnZ2luZyc7XG4gICAgICAgICAgICB0aGlzLm1vdmVkID0gZmFsc2U7XG4gICAgICAgICAgICB0aGlzLmNvbXAuJGVtaXQoJ3Njcm9sbC1sb2NrJywgdHJ1ZSk7XG4gICAgICAgICAgICB0aGlzLmNvbXAuJGVtaXQoJ29iamVjdC1zZWxlY3RlZCcpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5ob3ZlcigpKSB7XG4gICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIm1vdXNldXBcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gbW91c2V1cChldmVudCkge1xuICAgICAgc3dpdGNoICh0aGlzLnN0YXRlKSB7XG4gICAgICAgIGNhc2UgJ2RyYWdnaW5nJzpcbiAgICAgICAgICB0aGlzLnN0YXRlID0gJ3NldHRsZWQnO1xuICAgICAgICAgIGlmICh0aGlzLm9uX3NldHRsZWQpIHRoaXMub25fc2V0dGxlZCgpO1xuICAgICAgICAgIHRoaXMuY29tcC4kZW1pdCgnc2Nyb2xsLWxvY2snLCBmYWxzZSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIm9uXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG9uKG5hbWUsIGhhbmRsZXIpIHtcbiAgICAgIHN3aXRjaCAobmFtZSkge1xuICAgICAgICBjYXNlICdzZXR0bGVkJzpcbiAgICAgICAgICB0aGlzLm9uX3NldHRsZWQgPSBoYW5kbGVyO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJob3ZlclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBob3ZlcigpIHtcbiAgICAgIHZhciB4ID0gdGhpcy54O1xuICAgICAgdmFyIHkgPSB0aGlzLnk7XG4gICAgICByZXR1cm4gKHggLSB0aGlzLm1vdXNlLngpICogKHggLSB0aGlzLm1vdXNlLngpICsgKHkgLSB0aGlzLm1vdXNlLnkpICogKHkgLSB0aGlzLm1vdXNlLnkpIDwgdGhpcy5SQURJVVNfU1E7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIFBpbjtcbn0oKTtcblxuXG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvY29tcG9uZW50cy9wcmltaXRpdmVzL3NlZy5qc1xuXG5cbi8vIERyYXdzIGEgc2VnbWVudCwgYWRkcyBjb3JyZXNwb25kaW5nIGNvbGxpc2lvbiBmLW5cblxuXG5cbnZhciBTZWcgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICAvLyBPdmVybGF5IHJlZiwgY2FudmFzIGN0eFxuICBmdW5jdGlvbiBTZWcob3ZlcmxheSwgY3R4KSB7XG4gICAgY2xhc3NDYWxsQ2hlY2tfY2xhc3NDYWxsQ2hlY2sodGhpcywgU2VnKTtcblxuICAgIHRoaXMuY3R4ID0gY3R4O1xuICAgIHRoaXMuY29tcCA9IG92ZXJsYXk7XG4gICAgdGhpcy5UID0gb3ZlcmxheS4kcHJvcHMuY29uZmlnLlRPT0xfQ09MTDtcbiAgICBpZiAodXRpbHMuaXNfbW9iaWxlKSB0aGlzLlQgKj0gMjtcbiAgfSAvLyBwMVt0LCAkXSwgcDJbdCwgJF0gKHRpbWUtcHJpY2UgY29vcmRpbmF0ZXMpXG5cblxuICBjcmVhdGVDbGFzc19jcmVhdGVDbGFzcyhTZWcsIFt7XG4gICAga2V5OiBcImRyYXdcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZHJhdyhwMSwgcDIpIHtcbiAgICAgIHZhciBsYXlvdXQgPSB0aGlzLmNvbXAuJHByb3BzLmxheW91dDtcbiAgICAgIHZhciB4MSA9IGxheW91dC50MnNjcmVlbihwMVswXSk7XG4gICAgICB2YXIgeTEgPSBsYXlvdXQuJDJzY3JlZW4ocDFbMV0pO1xuICAgICAgdmFyIHgyID0gbGF5b3V0LnQyc2NyZWVuKHAyWzBdKTtcbiAgICAgIHZhciB5MiA9IGxheW91dC4kMnNjcmVlbihwMlsxXSk7XG4gICAgICB0aGlzLmN0eC5tb3ZlVG8oeDEsIHkxKTtcbiAgICAgIHRoaXMuY3R4LmxpbmVUbyh4MiwgeTIpO1xuICAgICAgdGhpcy5jb21wLmNvbGxpc2lvbnMucHVzaCh0aGlzLm1ha2UoW3gxLCB5MV0sIFt4MiwgeTJdKSk7XG4gICAgfSAvLyBDb2xsaXNpb24gZnVuY3Rpb24uIHgsIHkgLSBtb3VzZSBjb29yZC5cblxuICB9LCB7XG4gICAga2V5OiBcIm1ha2VcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gbWFrZShwMSwgcDIpIHtcbiAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICAgIHJldHVybiBmdW5jdGlvbiAoeCwgeSkge1xuICAgICAgICByZXR1cm4gbWF0aC5wb2ludDJzZWcoW3gsIHldLCBwMSwgcDIpIDwgX3RoaXMuVDtcbiAgICAgIH07XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIFNlZztcbn0oKTtcblxuXG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvY29tcG9uZW50cy9wcmltaXRpdmVzL2xpbmUuanNcblxuXG4vLyBEcmF3cyBhIGxpbmUsIGFkZHMgY29ycmVzcG9uZGluZyBjb2xsaXNpb24gZi1uXG5cblxuXG52YXIgTGluZSA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIC8vIE92ZXJsYXkgcmVmLCBjYW52YXMgY3R4XG4gIGZ1bmN0aW9uIExpbmUob3ZlcmxheSwgY3R4KSB7XG4gICAgY2xhc3NDYWxsQ2hlY2tfY2xhc3NDYWxsQ2hlY2sodGhpcywgTGluZSk7XG5cbiAgICB0aGlzLmN0eCA9IGN0eDtcbiAgICB0aGlzLmNvbXAgPSBvdmVybGF5O1xuICAgIHRoaXMuVCA9IG92ZXJsYXkuJHByb3BzLmNvbmZpZy5UT09MX0NPTEw7XG4gICAgaWYgKHV0aWxzLmlzX21vYmlsZSkgdGhpcy5UICo9IDI7XG4gIH0gLy8gcDFbdCwgJF0sIHAyW3QsICRdICh0aW1lLXByaWNlIGNvb3JkaW5hdGVzKVxuXG5cbiAgY3JlYXRlQ2xhc3NfY3JlYXRlQ2xhc3MoTGluZSwgW3tcbiAgICBrZXk6IFwiZHJhd1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBkcmF3KHAxLCBwMikge1xuICAgICAgdmFyIGxheW91dCA9IHRoaXMuY29tcC4kcHJvcHMubGF5b3V0O1xuICAgICAgdmFyIHgxID0gbGF5b3V0LnQyc2NyZWVuKHAxWzBdKTtcbiAgICAgIHZhciB5MSA9IGxheW91dC4kMnNjcmVlbihwMVsxXSk7XG4gICAgICB2YXIgeDIgPSBsYXlvdXQudDJzY3JlZW4ocDJbMF0pO1xuICAgICAgdmFyIHkyID0gbGF5b3V0LiQyc2NyZWVuKHAyWzFdKTtcbiAgICAgIHRoaXMuY3R4Lm1vdmVUbyh4MSwgeTEpO1xuICAgICAgdGhpcy5jdHgubGluZVRvKHgyLCB5Mik7XG4gICAgICB2YXIgdyA9IGxheW91dC53aWR0aDtcbiAgICAgIHZhciBoID0gbGF5b3V0LmhlaWdodDsgLy8gVE9ETzogdHJhbnNmb3JtIGsgKGFuZ2xlKSB0byBzY3JlZW4gcmF0aW9cbiAgICAgIC8vICh0aGlzIHJlcXVpcmVzIGEgbmV3IGEyc2NyZWVuIGZ1bmN0aW9uKVxuXG4gICAgICB2YXIgayA9ICh5MiAtIHkxKSAvICh4MiAtIHgxKTtcbiAgICAgIHZhciBzID0gTWF0aC5zaWduKHgyIC0geDEgfHwgeTIgLSB5MSk7XG4gICAgICB2YXIgZHggPSB3ICogcyAqIDI7XG4gICAgICB2YXIgZHkgPSB3ICogayAqIHMgKiAyO1xuXG4gICAgICBpZiAoZHkgPT09IEluZmluaXR5KSB7XG4gICAgICAgIGR4ID0gMCwgZHkgPSBoICogcztcbiAgICAgIH1cblxuICAgICAgdGhpcy5jdHgubW92ZVRvKHgyLCB5Mik7XG4gICAgICB0aGlzLmN0eC5saW5lVG8oeDIgKyBkeCwgeTIgKyBkeSk7XG5cbiAgICAgIGlmICghdGhpcy5yYXkpIHtcbiAgICAgICAgdGhpcy5jdHgubW92ZVRvKHgxLCB5MSk7XG4gICAgICAgIHRoaXMuY3R4LmxpbmVUbyh4MSAtIGR4LCB5MSAtIGR5KTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5jb21wLmNvbGxpc2lvbnMucHVzaCh0aGlzLm1ha2UoW3gxLCB5MV0sIFt4MiwgeTJdKSk7XG4gICAgfSAvLyBDb2xsaXNpb24gZnVuY3Rpb24uIHgsIHkgLSBtb3VzZSBjb29yZC5cblxuICB9LCB7XG4gICAga2V5OiBcIm1ha2VcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gbWFrZShwMSwgcDIpIHtcbiAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICAgIHZhciBmID0gdGhpcy5yYXkgPyBtYXRoLnBvaW50MnJheS5iaW5kKG1hdGgpIDogbWF0aC5wb2ludDJsaW5lLmJpbmQobWF0aCk7XG4gICAgICByZXR1cm4gZnVuY3Rpb24gKHgsIHkpIHtcbiAgICAgICAgcmV0dXJuIGYoW3gsIHldLCBwMSwgcDIpIDwgX3RoaXMuVDtcbiAgICAgIH07XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIExpbmU7XG59KCk7XG5cblxuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL3NldFByb3RvdHlwZU9mLmpzXG5mdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YobywgcCkge1xuICBfc2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHwgZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKG8sIHApIHtcbiAgICBvLl9fcHJvdG9fXyA9IHA7XG4gICAgcmV0dXJuIG87XG4gIH07XG5cbiAgcmV0dXJuIF9zZXRQcm90b3R5cGVPZihvLCBwKTtcbn1cbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9pbmhlcml0cy5qc1xuXG5mdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHtcbiAgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcImZ1bmN0aW9uXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvblwiKTtcbiAgfVxuXG4gIHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwge1xuICAgIGNvbnN0cnVjdG9yOiB7XG4gICAgICB2YWx1ZTogc3ViQ2xhc3MsXG4gICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH1cbiAgfSk7XG4gIGlmIChzdXBlckNsYXNzKSBfc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpO1xufVxuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL3R5cGVvZi5qc1xuZnVuY3Rpb24gdHlwZW9mX3R5cGVvZihvYmopIHtcbiAgXCJAYmFiZWwvaGVscGVycyAtIHR5cGVvZlwiO1xuXG4gIGlmICh0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PT0gXCJzeW1ib2xcIikge1xuICAgIHR5cGVvZl90eXBlb2YgPSBmdW5jdGlvbiBfdHlwZW9mKG9iaikge1xuICAgICAgcmV0dXJuIHR5cGVvZiBvYmo7XG4gICAgfTtcbiAgfSBlbHNlIHtcbiAgICB0eXBlb2ZfdHlwZW9mID0gZnVuY3Rpb24gX3R5cGVvZihvYmopIHtcbiAgICAgIHJldHVybiBvYmogJiYgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG9iaiAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqO1xuICAgIH07XG4gIH1cblxuICByZXR1cm4gdHlwZW9mX3R5cGVvZihvYmopO1xufVxuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL2Fzc2VydFRoaXNJbml0aWFsaXplZC5qc1xuZnVuY3Rpb24gX2Fzc2VydFRoaXNJbml0aWFsaXplZChzZWxmKSB7XG4gIGlmIChzZWxmID09PSB2b2lkIDApIHtcbiAgICB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7XG4gIH1cblxuICByZXR1cm4gc2VsZjtcbn1cbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuLmpzXG5cblxuZnVuY3Rpb24gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oc2VsZiwgY2FsbCkge1xuICBpZiAoY2FsbCAmJiAodHlwZW9mX3R5cGVvZihjYWxsKSA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgY2FsbCA9PT0gXCJmdW5jdGlvblwiKSkge1xuICAgIHJldHVybiBjYWxsO1xuICB9XG5cbiAgcmV0dXJuIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoc2VsZik7XG59XG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vZ2V0UHJvdG90eXBlT2YuanNcbmZ1bmN0aW9uIF9nZXRQcm90b3R5cGVPZihvKSB7XG4gIF9nZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5nZXRQcm90b3R5cGVPZiA6IGZ1bmN0aW9uIF9nZXRQcm90b3R5cGVPZihvKSB7XG4gICAgcmV0dXJuIG8uX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihvKTtcbiAgfTtcbiAgcmV0dXJuIF9nZXRQcm90b3R5cGVPZihvKTtcbn1cbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9jb21wb25lbnRzL3ByaW1pdGl2ZXMvcmF5LmpzXG5cblxuXG5cblxuZnVuY3Rpb24gX2NyZWF0ZVN1cGVyKERlcml2ZWQpIHsgdmFyIGhhc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QgPSBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KCk7IHJldHVybiBmdW5jdGlvbiBfY3JlYXRlU3VwZXJJbnRlcm5hbCgpIHsgdmFyIFN1cGVyID0gX2dldFByb3RvdHlwZU9mKERlcml2ZWQpLCByZXN1bHQ7IGlmIChoYXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KSB7IHZhciBOZXdUYXJnZXQgPSBfZ2V0UHJvdG90eXBlT2YodGhpcykuY29uc3RydWN0b3I7IHJlc3VsdCA9IFJlZmxlY3QuY29uc3RydWN0KFN1cGVyLCBhcmd1bWVudHMsIE5ld1RhcmdldCk7IH0gZWxzZSB7IHJlc3VsdCA9IFN1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7IH0gcmV0dXJuIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIHJlc3VsdCk7IH07IH1cblxuZnVuY3Rpb24gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCgpIHsgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcInVuZGVmaW5lZFwiIHx8ICFSZWZsZWN0LmNvbnN0cnVjdCkgcmV0dXJuIGZhbHNlOyBpZiAoUmVmbGVjdC5jb25zdHJ1Y3Quc2hhbSkgcmV0dXJuIGZhbHNlOyBpZiAodHlwZW9mIFByb3h5ID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiB0cnVlOyB0cnkgeyBCb29sZWFuLnByb3RvdHlwZS52YWx1ZU9mLmNhbGwoUmVmbGVjdC5jb25zdHJ1Y3QoQm9vbGVhbiwgW10sIGZ1bmN0aW9uICgpIHt9KSk7IHJldHVybiB0cnVlOyB9IGNhdGNoIChlKSB7IHJldHVybiBmYWxzZTsgfSB9XG5cbi8vIERyYXdzIGEgcmF5LCBhZGRzIGNvcnJlc3BvbmRpbmcgY29sbGlzaW9uIGYtblxuXG5cbnZhciBSYXkgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9MaW5lKSB7XG4gIF9pbmhlcml0cyhSYXksIF9MaW5lKTtcblxuICB2YXIgX3N1cGVyID0gX2NyZWF0ZVN1cGVyKFJheSk7XG5cbiAgZnVuY3Rpb24gUmF5KG92ZXJsYXksIGN0eCkge1xuICAgIHZhciBfdGhpcztcblxuICAgIGNsYXNzQ2FsbENoZWNrX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFJheSk7XG5cbiAgICBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIG92ZXJsYXksIGN0eCk7XG4gICAgX3RoaXMucmF5ID0gdHJ1ZTtcbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cblxuICByZXR1cm4gUmF5O1xufShMaW5lKTtcblxuXG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9ub2RlX21vZHVsZXMvYmFiZWwtbG9hZGVyL2xpYi9pbmRleC5qcyEuL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9pbmRleC5qcz8/dnVlLWxvYWRlci1vcHRpb25zIS4vc3JjL2NvbXBvbmVudHMvb3ZlcmxheXMvTGluZVRvb2wudnVlP3Z1ZSZ0eXBlPXNjcmlwdCZsYW5nPWpzJlxuLy8gTGluZSBkcmF3aW5nIHRvb2xcbi8vIFRPRE86IG1ha2UgYW4gYW5nbGUtc25hcCB3aGVuIFwiU2hpZnRcIiBpcyBwcmVzc2VkXG5cblxuXG5cblxuXG5cbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gY29uc3QgTGluZVRvb2x2dWVfdHlwZV9zY3JpcHRfbGFuZ19qc18gPSAoe1xuICBuYW1lOiAnTGluZVRvb2wnLFxuICBtaXhpbnM6IFtvdmVybGF5LCB0b29sXSxcbiAgbWV0aG9kczoge1xuICAgIG1ldGFfaW5mbzogZnVuY3Rpb24gbWV0YV9pbmZvKCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgYXV0aG9yOiAnQzQ1MScsXG4gICAgICAgIHZlcnNpb246ICcxLjEuMCdcbiAgICAgIH07XG4gICAgfSxcbiAgICB0b29sOiBmdW5jdGlvbiB0b29sKCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgLy8gRGVzY3JpcHRvciBmb3IgdGhlIHRvb2xcbiAgICAgICAgZ3JvdXA6ICdMaW5lcycsXG4gICAgICAgIGljb246IGljb25zX25hbWVzcGFjZU9iamVjdFtcInNlZ21lbnQucG5nXCJdLFxuICAgICAgICB0eXBlOiAnU2VnbWVudCcsXG4gICAgICAgIGhpbnQ6ICdUaGlzIGhpbnQgd2lsbCBiZSBzaG93biBvbiBob3ZlcicsXG4gICAgICAgIGRhdGE6IFtdLFxuICAgICAgICAvLyBEZWZhdWx0IGRhdGFcbiAgICAgICAgc2V0dGluZ3M6IHt9LFxuICAgICAgICAvLyBEZWZhdWx0IHNldHRpbmdzXG4gICAgICAgIC8vIE1vZGlmaWNhdGlvbnNcbiAgICAgICAgbW9kczoge1xuICAgICAgICAgICdFeHRlbmRlZCc6IHtcbiAgICAgICAgICAgIC8vIFJld3JpdGVzIHRoZSBkZWZhdWx0IHNldHRpbmcgZmllbGRzXG4gICAgICAgICAgICBzZXR0aW5nczoge1xuICAgICAgICAgICAgICBleHRlbmRlZDogdHJ1ZVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGljb246IGljb25zX25hbWVzcGFjZU9iamVjdFtcImV4dGVuZGVkLnBuZ1wiXVxuICAgICAgICAgIH0sXG4gICAgICAgICAgJ1JheSc6IHtcbiAgICAgICAgICAgIC8vIFJld3JpdGVzIHRoZSBkZWZhdWx0IHNldHRpbmcgZmllbGRzXG4gICAgICAgICAgICBzZXR0aW5nczoge1xuICAgICAgICAgICAgICByYXk6IHRydWVcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBpY29uOiBpY29uc19uYW1lc3BhY2VPYmplY3RbXCJyYXkucG5nXCJdXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9O1xuICAgIH0sXG4gICAgLy8gQ2FsbGVkIGFmdGVyIG92ZXJsYXkgbW91bnRlZFxuICAgIGluaXQ6IGZ1bmN0aW9uIGluaXQoKSB7XG4gICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgICAvLyBGaXJzdCBwaW4gaXMgc2V0dGxlZCBhdCB0aGUgbW91c2UgcG9zaXRpb25cbiAgICAgIHRoaXMucGlucy5wdXNoKG5ldyBQaW4odGhpcywgJ3AxJykpOyAvLyBTZWNvbmQgb25lIGlzIGZvbGxvd2luZyBtb3VzZSB1bnRpbCBpdCBjbGlja3NcblxuICAgICAgdGhpcy5waW5zLnB1c2gobmV3IFBpbih0aGlzLCAncDInLCB7XG4gICAgICAgIHN0YXRlOiAndHJhY2tpbmcnXG4gICAgICB9KSk7XG4gICAgICB0aGlzLnBpbnNbMV0ub24oJ3NldHRsZWQnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIC8vIENhbGwgd2hlbiBjdXJyZW50IHRvb2wgZHJhd2luZyBpcyBmaW5pc2hlZFxuICAgICAgICAvLyAoT3B0aW9uYWxseSkgcmVzZXQgdGhlIG1vZGUgYmFjayB0byAnQ3Vyc29yJ1xuICAgICAgICBfdGhpcy5zZXRfc3RhdGUoJ2ZpbmlzaGVkJyk7XG5cbiAgICAgICAgX3RoaXMuJGVtaXQoJ2RyYXdpbmctbW9kZS1vZmYnKTtcbiAgICAgIH0pO1xuICAgIH0sXG4gICAgZHJhdzogZnVuY3Rpb24gZHJhdyhjdHgpIHtcbiAgICAgIGlmICghdGhpcy5wMSB8fCAhdGhpcy5wMikgcmV0dXJuO1xuICAgICAgY3R4LmxpbmVXaWR0aCA9IHRoaXMubGluZV93aWR0aDtcbiAgICAgIGN0eC5zdHJva2VTdHlsZSA9IHRoaXMuY29sb3I7XG4gICAgICBjdHguYmVnaW5QYXRoKCk7XG5cbiAgICAgIGlmICh0aGlzLnNldHQucmF5KSB7XG4gICAgICAgIG5ldyBSYXkodGhpcywgY3R4KS5kcmF3KHRoaXMucDEsIHRoaXMucDIpO1xuICAgICAgfSBlbHNlIGlmICh0aGlzLnNldHQuZXh0ZW5kZWQpIHtcbiAgICAgICAgbmV3IExpbmUodGhpcywgY3R4KS5kcmF3KHRoaXMucDEsIHRoaXMucDIpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbmV3IFNlZyh0aGlzLCBjdHgpLmRyYXcodGhpcy5wMSwgdGhpcy5wMik7XG4gICAgICB9XG5cbiAgICAgIGN0eC5zdHJva2UoKTtcbiAgICAgIHRoaXMucmVuZGVyX3BpbnMoY3R4KTtcbiAgICB9LFxuICAgIHVzZV9mb3I6IGZ1bmN0aW9uIHVzZV9mb3IoKSB7XG4gICAgICByZXR1cm4gWydMaW5lVG9vbCddO1xuICAgIH0sXG4gICAgZGF0YV9jb2xvcnM6IGZ1bmN0aW9uIGRhdGFfY29sb3JzKCkge1xuICAgICAgcmV0dXJuIFt0aGlzLmNvbG9yXTtcbiAgICB9XG4gIH0sXG4gIC8vIERlZmluZSBpbnRlcm5hbCBzZXR0aW5nICYgY29uc3RhbnRzIGhlcmVcbiAgY29tcHV0ZWQ6IHtcbiAgICBzZXR0OiBmdW5jdGlvbiBzZXR0KCkge1xuICAgICAgcmV0dXJuIHRoaXMuJHByb3BzLnNldHRpbmdzO1xuICAgIH0sXG4gICAgcDE6IGZ1bmN0aW9uIHAxKCkge1xuICAgICAgcmV0dXJuIHRoaXMuJHByb3BzLnNldHRpbmdzLnAxO1xuICAgIH0sXG4gICAgcDI6IGZ1bmN0aW9uIHAyKCkge1xuICAgICAgcmV0dXJuIHRoaXMuJHByb3BzLnNldHRpbmdzLnAyO1xuICAgIH0sXG4gICAgbGluZV93aWR0aDogZnVuY3Rpb24gbGluZV93aWR0aCgpIHtcbiAgICAgIHJldHVybiB0aGlzLnNldHQubGluZVdpZHRoIHx8IDAuOTtcbiAgICB9LFxuICAgIGNvbG9yOiBmdW5jdGlvbiBjb2xvcigpIHtcbiAgICAgIHJldHVybiB0aGlzLnNldHQuY29sb3IgfHwgJyM0MmIyOGEnO1xuICAgIH1cbiAgfSxcbiAgZGF0YTogZnVuY3Rpb24gZGF0YSgpIHtcbiAgICByZXR1cm4ge307XG4gIH1cbn0pO1xuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL2NvbXBvbmVudHMvb3ZlcmxheXMvTGluZVRvb2wudnVlP3Z1ZSZ0eXBlPXNjcmlwdCZsYW5nPWpzJlxuIC8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gY29uc3Qgb3ZlcmxheXNfTGluZVRvb2x2dWVfdHlwZV9zY3JpcHRfbGFuZ19qc18gPSAoTGluZVRvb2x2dWVfdHlwZV9zY3JpcHRfbGFuZ19qc18pOyBcbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9jb21wb25lbnRzL292ZXJsYXlzL0xpbmVUb29sLnZ1ZVxudmFyIExpbmVUb29sX3JlbmRlciwgTGluZVRvb2xfc3RhdGljUmVuZGVyRm5zXG47XG5cblxuXG4vKiBub3JtYWxpemUgY29tcG9uZW50ICovXG47XG52YXIgTGluZVRvb2xfY29tcG9uZW50ID0gbm9ybWFsaXplQ29tcG9uZW50KFxuICBvdmVybGF5c19MaW5lVG9vbHZ1ZV90eXBlX3NjcmlwdF9sYW5nX2pzXyxcbiAgTGluZVRvb2xfcmVuZGVyLFxuICBMaW5lVG9vbF9zdGF0aWNSZW5kZXJGbnMsXG4gIGZhbHNlLFxuICBudWxsLFxuICBudWxsLFxuICBudWxsXG4gIFxuKVxuXG4vKiBob3QgcmVsb2FkICovXG5pZiAoZmFsc2UpIHsgdmFyIExpbmVUb29sX2FwaTsgfVxuTGluZVRvb2xfY29tcG9uZW50Lm9wdGlvbnMuX19maWxlID0gXCJzcmMvY29tcG9uZW50cy9vdmVybGF5cy9MaW5lVG9vbC52dWVcIlxuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyBjb25zdCBMaW5lVG9vbCA9IChMaW5lVG9vbF9jb21wb25lbnQuZXhwb3J0cyk7XG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9ub2RlX21vZHVsZXMvYmFiZWwtbG9hZGVyL2xpYi9pbmRleC5qcyEuL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9pbmRleC5qcz8/dnVlLWxvYWRlci1vcHRpb25zIS4vc3JjL2NvbXBvbmVudHMvb3ZlcmxheXMvUmFuZ2VUb29sLnZ1ZT92dWUmdHlwZT1zY3JpcHQmbGFuZz1qcyZcblxuLy8gUHJpY2UvVGltZSBtZWFzdXJtZW50IHRvb2xcblxuXG5cblxuXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIGNvbnN0IFJhbmdlVG9vbHZ1ZV90eXBlX3NjcmlwdF9sYW5nX2pzXyA9ICh7XG4gIG5hbWU6ICdSYW5nZVRvb2wnLFxuICBtaXhpbnM6IFtvdmVybGF5LCB0b29sXSxcbiAgbWV0aG9kczoge1xuICAgIG1ldGFfaW5mbzogZnVuY3Rpb24gbWV0YV9pbmZvKCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgYXV0aG9yOiAnQzQ1MScsXG4gICAgICAgIHZlcnNpb246ICcyLjAuMSdcbiAgICAgIH07XG4gICAgfSxcbiAgICB0b29sOiBmdW5jdGlvbiB0b29sKCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgLy8gRGVzY3JpcHRvciBmb3IgdGhlIHRvb2xcbiAgICAgICAgZ3JvdXA6ICdNZWFzdXJlbWVudHMnLFxuICAgICAgICBpY29uOiBpY29uc19uYW1lc3BhY2VPYmplY3RbXCJwcmljZV9yYW5nZS5wbmdcIl0sXG4gICAgICAgIHR5cGU6ICdQcmljZScsXG4gICAgICAgIGhpbnQ6ICdQcmljZSBSYW5nZScsXG4gICAgICAgIGRhdGE6IFtdLFxuICAgICAgICAvLyBEZWZhdWx0IGRhdGFcbiAgICAgICAgc2V0dGluZ3M6IHt9LFxuICAgICAgICAvLyBEZWZhdWx0IHNldHRpbmdzXG4gICAgICAgIG1vZHM6IHtcbiAgICAgICAgICAnVGltZSc6IHtcbiAgICAgICAgICAgIC8vIFJld3JpdGVzIHRoZSBkZWZhdWx0IHNldHRpbmcgZmllbGRzXG4gICAgICAgICAgICBpY29uOiBpY29uc19uYW1lc3BhY2VPYmplY3RbXCJ0aW1lX3JhbmdlLnBuZ1wiXSxcbiAgICAgICAgICAgIHNldHRpbmdzOiB7XG4gICAgICAgICAgICAgIHByaWNlOiBmYWxzZSxcbiAgICAgICAgICAgICAgdGltZTogdHJ1ZVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0sXG4gICAgICAgICAgJ1ByaWNlVGltZSc6IHtcbiAgICAgICAgICAgIC8vIFJld3JpdGVzIHRoZSBkZWZhdWx0IHNldHRpbmcgZmllbGRzXG4gICAgICAgICAgICBpY29uOiBpY29uc19uYW1lc3BhY2VPYmplY3RbXCJwcmljZV90aW1lLnBuZ1wiXSxcbiAgICAgICAgICAgIHNldHRpbmdzOiB7XG4gICAgICAgICAgICAgIHByaWNlOiB0cnVlLFxuICAgICAgICAgICAgICB0aW1lOiB0cnVlXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSxcbiAgICAgICAgICAnU2hpZnRNb2RlJzoge1xuICAgICAgICAgICAgLy8gUmV3cml0ZXMgdGhlIGRlZmF1bHQgc2V0dGluZyBmaWVsZHNcbiAgICAgICAgICAgIHNldHRpbmdzOiB7XG4gICAgICAgICAgICAgIHByaWNlOiB0cnVlLFxuICAgICAgICAgICAgICB0aW1lOiB0cnVlLFxuICAgICAgICAgICAgICBzaGlmdE1vZGU6IHRydWVcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBoaWRkZW46IHRydWVcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfSxcbiAgICAvLyBDYWxsZWQgYWZ0ZXIgb3ZlcmxheSBtb3VudGVkXG4gICAgaW5pdDogZnVuY3Rpb24gaW5pdCgpIHtcbiAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICAgIC8vIEZpcnN0IHBpbiBpcyBzZXR0bGVkIGF0IHRoZSBtb3VzZSBwb3NpdGlvblxuICAgICAgdGhpcy5waW5zLnB1c2gobmV3IFBpbih0aGlzLCAncDEnLCB7XG4gICAgICAgIGhpZGRlbjogdGhpcy5zaGlmdFxuICAgICAgfSkpOyAvLyBTZWNvbmQgb25lIGlzIGZvbGxvd2luZyBtb3VzZSB1bnRpbCBpdCBjbGlja3NcblxuICAgICAgdGhpcy5waW5zLnB1c2gobmV3IFBpbih0aGlzLCAncDInLCB7XG4gICAgICAgIHN0YXRlOiAndHJhY2tpbmcnLFxuICAgICAgICBoaWRkZW46IHRoaXMuc2hpZnRcbiAgICAgIH0pKTtcbiAgICAgIHRoaXMucGluc1sxXS5vbignc2V0dGxlZCcsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgLy8gQ2FsbCB3aGVuIGN1cnJlbnQgdG9vbCBkcmF3aW5nIGlzIGZpbmlzaGVkXG4gICAgICAgIC8vIChPcHRpb25hbGx5KSByZXNldCB0aGUgbW9kZSBiYWNrIHRvICdDdXJzb3InXG4gICAgICAgIF90aGlzLnNldF9zdGF0ZSgnZmluaXNoZWQnKTtcblxuICAgICAgICBfdGhpcy4kZW1pdCgnZHJhd2luZy1tb2RlLW9mZicpOyAvLyBEZXNlbGVjdCB0aGUgdG9vbCBpbiBzaGlmdE1vZGVcblxuXG4gICAgICAgIGlmIChfdGhpcy5zaGlmdCkgX3RoaXMuXyRlbWl0KCdjdXN0b20tZXZlbnQnLCB7XG4gICAgICAgICAgZXZlbnQ6ICdvYmplY3Qtc2VsZWN0ZWQnLFxuICAgICAgICAgIGFyZ3M6IFtdXG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfSxcbiAgICBkcmF3OiBmdW5jdGlvbiBkcmF3KGN0eCkge1xuICAgICAgaWYgKCF0aGlzLnAxIHx8ICF0aGlzLnAyKSByZXR1cm47XG4gICAgICB2YXIgZGlyID0gTWF0aC5zaWduKHRoaXMucDJbMV0gLSB0aGlzLnAxWzFdKTtcbiAgICAgIHZhciBsYXlvdXQgPSB0aGlzLiRwcm9wcy5sYXlvdXQ7XG4gICAgICB2YXIgeG0gPSBsYXlvdXQudDJzY3JlZW4oKHRoaXMucDFbMF0gKyB0aGlzLnAyWzBdKSAqIDAuNSk7XG4gICAgICBjdHgubGluZVdpZHRoID0gdGhpcy5saW5lX3dpZHRoO1xuICAgICAgY3R4LnN0cm9rZVN0eWxlID0gdGhpcy5jb2xvcjsgLy8gQmFja2dyb3VuZFxuXG4gICAgICBjdHguZmlsbFN0eWxlID0gdGhpcy5iYWNrX2NvbG9yO1xuICAgICAgdmFyIHgxID0gbGF5b3V0LnQyc2NyZWVuKHRoaXMucDFbMF0pO1xuICAgICAgdmFyIHkxID0gbGF5b3V0LiQyc2NyZWVuKHRoaXMucDFbMV0pO1xuICAgICAgdmFyIHgyID0gbGF5b3V0LnQyc2NyZWVuKHRoaXMucDJbMF0pO1xuICAgICAgdmFyIHkyID0gbGF5b3V0LiQyc2NyZWVuKHRoaXMucDJbMV0pO1xuICAgICAgY3R4LmZpbGxSZWN0KHgxLCB5MSwgeDIgLSB4MSwgeTIgLSB5MSk7XG4gICAgICBpZiAodGhpcy5wcmljZSkgdGhpcy52ZXJ0aWNhbChjdHgsIHgxLCB5MSwgeDIsIHkyLCB4bSk7XG4gICAgICBpZiAodGhpcy50aW1lKSB0aGlzLmhvcml6b250YWwoY3R4LCB4MSwgeTEsIHgyLCB5MiwgeG0pO1xuICAgICAgdGhpcy5kcmF3X3ZhbHVlKGN0eCwgZGlyLCB4bSwgeTIpO1xuICAgICAgdGhpcy5yZW5kZXJfcGlucyhjdHgpO1xuICAgIH0sXG4gICAgdmVydGljYWw6IGZ1bmN0aW9uIHZlcnRpY2FsKGN0eCwgeDEsIHkxLCB4MiwgeTIsIHhtKSB7XG4gICAgICB2YXIgbGF5b3V0ID0gdGhpcy4kcHJvcHMubGF5b3V0O1xuICAgICAgdmFyIGRpciA9IE1hdGguc2lnbih0aGlzLnAyWzFdIC0gdGhpcy5wMVsxXSk7XG4gICAgICBjdHguYmVnaW5QYXRoKCk7XG5cbiAgICAgIGlmICghdGhpcy5zaGlmdCkge1xuICAgICAgICAvLyBUb3BcbiAgICAgICAgbmV3IFNlZyh0aGlzLCBjdHgpLmRyYXcoW3RoaXMucDFbMF0sIHRoaXMucDJbMV1dLCBbdGhpcy5wMlswXSwgdGhpcy5wMlsxXV0pOyAvLyBCb3R0b21cblxuICAgICAgICBuZXcgU2VnKHRoaXMsIGN0eCkuZHJhdyhbdGhpcy5wMVswXSwgdGhpcy5wMVsxXV0sIFt0aGlzLnAyWzBdLCB0aGlzLnAxWzFdXSk7XG4gICAgICB9IC8vIFZlcnRpY2FsIEFycm93XG5cblxuICAgICAgY3R4Lm1vdmVUbyh4bSAtIDQsIHkyICsgNSAqIGRpcik7XG4gICAgICBjdHgubGluZVRvKHhtLCB5Mik7XG4gICAgICBjdHgubGluZVRvKHhtICsgNCwgeTIgKyA1ICogZGlyKTtcbiAgICAgIGN0eC5zdHJva2UoKTsgLy8gVmVydGljYWwgTGluZVxuXG4gICAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgICBjdHguc2V0TGluZURhc2goWzUsIDVdKTtcbiAgICAgIG5ldyBTZWcodGhpcywgY3R4KS5kcmF3KFsodGhpcy5wMVswXSArIHRoaXMucDJbMF0pICogMC41LCB0aGlzLnAyWzFdXSwgWyh0aGlzLnAxWzBdICsgdGhpcy5wMlswXSkgKiAwLjUsIHRoaXMucDFbMV1dKTtcbiAgICAgIGN0eC5zdHJva2UoKTtcbiAgICAgIGN0eC5zZXRMaW5lRGFzaChbXSk7XG4gICAgfSxcbiAgICBob3Jpem9udGFsOiBmdW5jdGlvbiBob3Jpem9udGFsKGN0eCwgeDEsIHkxLCB4MiwgeTIsIHhtKSB7XG4gICAgICB2YXIgbGF5b3V0ID0gdGhpcy4kcHJvcHMubGF5b3V0O1xuICAgICAgdmFyIHhkaXIgPSBNYXRoLnNpZ24odGhpcy5wMlswXSAtIHRoaXMucDFbMF0pO1xuICAgICAgdmFyIHltID0gKGxheW91dC4kMnNjcmVlbih0aGlzLnAxWzFdKSArIGxheW91dC4kMnNjcmVlbih0aGlzLnAyWzFdKSkgLyAyO1xuICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuXG4gICAgICBpZiAoIXRoaXMuc2hpZnQpIHtcbiAgICAgICAgLy8gTGVmdFxuICAgICAgICBuZXcgU2VnKHRoaXMsIGN0eCkuZHJhdyhbdGhpcy5wMVswXSwgdGhpcy5wMVsxXV0sIFt0aGlzLnAxWzBdLCB0aGlzLnAyWzFdXSk7IC8vIFJpZ2h0XG5cbiAgICAgICAgbmV3IFNlZyh0aGlzLCBjdHgpLmRyYXcoW3RoaXMucDJbMF0sIHRoaXMucDFbMV1dLCBbdGhpcy5wMlswXSwgdGhpcy5wMlsxXV0pO1xuICAgICAgfSAvLyBIb3Jpem9udGFsIEFycm93XG5cblxuICAgICAgY3R4Lm1vdmVUbyh4MiAtIDUgKiB4ZGlyLCB5bSAtIDQpO1xuICAgICAgY3R4LmxpbmVUbyh4MiwgeW0pO1xuICAgICAgY3R4LmxpbmVUbyh4MiAtIDUgKiB4ZGlyLCB5bSArIDQpO1xuICAgICAgY3R4LnN0cm9rZSgpOyAvLyBIb3Jpem9udGFsIExpbmVcblxuICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgY3R4LnNldExpbmVEYXNoKFs1LCA1XSk7XG4gICAgICBjdHgubW92ZVRvKHgxLCB5bSk7XG4gICAgICBjdHgubGluZVRvKHgyLCB5bSk7XG4gICAgICBjdHguc3Ryb2tlKCk7XG4gICAgICBjdHguc2V0TGluZURhc2goW10pO1xuICAgIH0sXG4gICAgLy8gV1RGPyBJIGtub3cgZHVkZSwgYSBsb3Qgb2Ygc2hpdHR5IGNvZGUgaGVyZVxuICAgIGRyYXdfdmFsdWU6IGZ1bmN0aW9uIGRyYXdfdmFsdWUoY3R4LCBkaXIsIHhtLCB5KSB7XG4gICAgICB2YXIgX3RoaXMyID0gdGhpcztcblxuICAgICAgY3R4LmZvbnQgPSB0aGlzLm5ld19mb250OyAvLyBQcmljZSBkZWx0YSAoYW5mIHBlcmNlbnQpXG5cbiAgICAgIHZhciBkJCA9ICh0aGlzLnAyWzFdIC0gdGhpcy5wMVsxXSkudG9GaXhlZCh0aGlzLnByZWMpO1xuICAgICAgdmFyIHAgPSAoMTAwICogKHRoaXMucDJbMV0gLyB0aGlzLnAxWzFdIC0gMSkpLnRvRml4ZWQodGhpcy5wcmVjKTsgLy8gTWFwIGludGVydmFsIHRvIHRoZSBhY3R1YWwgdGYgKGluIG1zKVxuXG4gICAgICB2YXIgZiA9IGZ1bmN0aW9uIGYodCkge1xuICAgICAgICByZXR1cm4gX3RoaXMyLmxheW91dC50aV9tYXAuc210aDJ0KHQpO1xuICAgICAgfTtcblxuICAgICAgdmFyIGR0ID0gZih0aGlzLnAyWzBdKSAtIGYodGhpcy5wMVswXSk7XG4gICAgICB2YXIgdGYgPSB0aGlzLmxheW91dC50aV9tYXAudGY7IC8vIEJhcnMgY291bnQgKHRocm91Z2ggdGhlIGNhbmRsZSBpbmRleClcblxuICAgICAgdmFyIGYyID0gZnVuY3Rpb24gZjIodCkge1xuICAgICAgICB2YXIgYyA9IF90aGlzMi5sYXlvdXQuY19tYWduZXQodCk7XG5cbiAgICAgICAgdmFyIGNuID0gX3RoaXMyLmxheW91dC5jYW5kbGVzIHx8IF90aGlzMi5sYXlvdXQubWFzdGVyX2dyaWQuY2FuZGxlcztcbiAgICAgICAgcmV0dXJuIGNuLmluZGV4T2YoYyk7XG4gICAgICB9OyAvLyBCYXJzIGNvdW50IChhbmQgaGFuZGxpbmcgdGhlIG5lZ2F0aXZlIHZhbHVlcylcblxuXG4gICAgICB2YXIgYiA9IGYyKHRoaXMucDJbMF0pIC0gZjIodGhpcy5wMVswXSk7IC8vIEZvcm1hdCB0aW1lIGRlbHRhXG4gICAgICAvLyBGb3JtYXQgdGltZSBkZWx0YVxuXG4gICAgICB2YXIgZHRzdHIgPSB0aGlzLnQyc3RyKGR0KTtcbiAgICAgIHZhciB0ZXh0ID0gW107XG4gICAgICBpZiAodGhpcy5wcmljZSkgdGV4dC5wdXNoKFwiXCIuY29uY2F0KGQkLCBcIiAgKFwiKS5jb25jYXQocCwgXCIlKVwiKSk7XG4gICAgICBpZiAodGhpcy50aW1lKSB0ZXh0LnB1c2goXCJcIi5jb25jYXQoYiwgXCIgYmFycywgXCIpLmNvbmNhdChkdHN0cikpO1xuICAgICAgdGV4dCA9IHRleHQuam9pbignXFxuJyk7IC8vIFwiTXVsdGlwbGVcIiBmaWxsVGV4dFxuXG4gICAgICB2YXIgbGluZXMgPSB0ZXh0LnNwbGl0KCdcXG4nKTtcbiAgICAgIHZhciB3ID0gTWF0aC5tYXguYXBwbHkoTWF0aCwgX3RvQ29uc3VtYWJsZUFycmF5KGxpbmVzLm1hcChmdW5jdGlvbiAoeCkge1xuICAgICAgICByZXR1cm4gY3R4Lm1lYXN1cmVUZXh0KHgpLndpZHRoICsgMjA7XG4gICAgICB9KSkuY29uY2F0KFsxMDBdKSk7XG4gICAgICB2YXIgbiA9IGxpbmVzLmxlbmd0aDtcbiAgICAgIHZhciBoID0gMjAgKiBuO1xuICAgICAgY3R4LmZpbGxTdHlsZSA9IHRoaXMudmFsdWVfYmFjaztcbiAgICAgIGN0eC5maWxsUmVjdCh4bSAtIHcgKiAwLjUsIHkgLSAoMTAgKyBoKSAqIGRpciwgdywgaCAqIGRpcik7XG4gICAgICBjdHguZmlsbFN0eWxlID0gdGhpcy52YWx1ZV9jb2xvcjtcbiAgICAgIGN0eC50ZXh0QWxpZ24gPSAnY2VudGVyJztcbiAgICAgIGxpbmVzLmZvckVhY2goZnVuY3Rpb24gKGwsIGkpIHtcbiAgICAgICAgY3R4LmZpbGxUZXh0KGwsIHhtLCB5ICsgKGRpciA+IDAgPyAyMCAqIGkgLSAyMCAqIG4gKyA1IDogMjAgKiBpICsgMjUpKTtcbiAgICAgIH0pO1xuICAgIH0sXG4gICAgLy8gRm9ybWF0cyB0aW1lIGZyb20gbXMgdG8gYDFEIDEyaGAgZm9yIGV4YW1wbGVcbiAgICB0MnN0cjogZnVuY3Rpb24gdDJzdHIodCkge1xuICAgICAgdmFyIHNpZ24gPSBNYXRoLnNpZ24odCk7XG4gICAgICB2YXIgYWJzID0gTWF0aC5hYnModCk7XG4gICAgICB2YXIgdGZzID0gW1sxMDAwLCAncycsIDYwXSwgWzYwMDAwLCAnbScsIDYwXSwgWzM2MDAwMDAsICdoJywgMjRdLCBbODY0MDAwMDAsICdEJywgN10sIFs2MDQ4MDAwMDAsICdXJywgNF0sIFsyNTkyMDAwMDAwLCAnTScsIDEyXSwgWzMxNTM2MDAwMDAwLCAnWScsIEluZmluaXR5XSwgW0luZmluaXR5LCAnRXRlcm5pdHknLCBJbmZpbml0eV1dO1xuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRmcy5sZW5ndGg7IGkrKykge1xuICAgICAgICB0ZnNbaV1bMF0gPSBNYXRoLmZsb29yKGFicyAvIHRmc1tpXVswXSk7XG5cbiAgICAgICAgaWYgKHRmc1tpXVswXSA9PT0gMCkge1xuICAgICAgICAgIHZhciBwMSA9IHRmc1tpIC0gMV07XG4gICAgICAgICAgdmFyIHAyID0gdGZzW2kgLSAyXTtcbiAgICAgICAgICB2YXIgdHh0ID0gc2lnbiA8IDAgPyAnLScgOiAnJztcblxuICAgICAgICAgIGlmIChwMSkge1xuICAgICAgICAgICAgdHh0ICs9IHAxLnNsaWNlKDAsIDIpLmpvaW4oJycpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHZhciBuMiA9IHAyID8gcDJbMF0gLSBwMVswXSAqIHAyWzJdIDogMDtcblxuICAgICAgICAgIGlmIChwMiAmJiBuMikge1xuICAgICAgICAgICAgdHh0ICs9ICcgJztcbiAgICAgICAgICAgIHR4dCArPSBcIlwiLmNvbmNhdChuMikuY29uY2F0KHAyWzFdKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4gdHh0O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcbiAgICB1c2VfZm9yOiBmdW5jdGlvbiB1c2VfZm9yKCkge1xuICAgICAgcmV0dXJuIFsnUmFuZ2VUb29sJ107XG4gICAgfSxcbiAgICBkYXRhX2NvbG9yczogZnVuY3Rpb24gZGF0YV9jb2xvcnMoKSB7XG4gICAgICByZXR1cm4gW3RoaXMuY29sb3JdO1xuICAgIH1cbiAgfSxcbiAgLy8gRGVmaW5lIGludGVybmFsIHNldHRpbmcgJiBjb25zdGFudHMgaGVyZVxuICBjb21wdXRlZDoge1xuICAgIHNldHQ6IGZ1bmN0aW9uIHNldHQoKSB7XG4gICAgICByZXR1cm4gdGhpcy4kcHJvcHMuc2V0dGluZ3M7XG4gICAgfSxcbiAgICBwMTogZnVuY3Rpb24gcDEoKSB7XG4gICAgICByZXR1cm4gdGhpcy4kcHJvcHMuc2V0dGluZ3MucDE7XG4gICAgfSxcbiAgICBwMjogZnVuY3Rpb24gcDIoKSB7XG4gICAgICByZXR1cm4gdGhpcy4kcHJvcHMuc2V0dGluZ3MucDI7XG4gICAgfSxcbiAgICBsaW5lX3dpZHRoOiBmdW5jdGlvbiBsaW5lX3dpZHRoKCkge1xuICAgICAgcmV0dXJuIHRoaXMuc2V0dC5saW5lV2lkdGggfHwgMC45O1xuICAgIH0sXG4gICAgY29sb3I6IGZ1bmN0aW9uIGNvbG9yKCkge1xuICAgICAgcmV0dXJuIHRoaXMuc2V0dC5jb2xvciB8fCB0aGlzLiRwcm9wcy5jb2xvcnMuY3Jvc3M7XG4gICAgfSxcbiAgICBiYWNrX2NvbG9yOiBmdW5jdGlvbiBiYWNrX2NvbG9yKCkge1xuICAgICAgcmV0dXJuIHRoaXMuc2V0dC5iYWNrQ29sb3IgfHwgJyM5YjliYTMxNic7XG4gICAgfSxcbiAgICB2YWx1ZV9iYWNrOiBmdW5jdGlvbiB2YWx1ZV9iYWNrKCkge1xuICAgICAgcmV0dXJuIHRoaXMuc2V0dC52YWx1ZUJhY2sgfHwgJyM5YjliYTMxNic7XG4gICAgfSxcbiAgICB2YWx1ZV9jb2xvcjogZnVuY3Rpb24gdmFsdWVfY29sb3IoKSB7XG4gICAgICByZXR1cm4gdGhpcy5zZXR0LnZhbHVlQ29sb3IgfHwgdGhpcy4kcHJvcHMuY29sb3JzLnRleHQ7XG4gICAgfSxcbiAgICBwcmVjOiBmdW5jdGlvbiBwcmVjKCkge1xuICAgICAgcmV0dXJuIHRoaXMuc2V0dC5wcmVjaXNpb24gfHwgMjtcbiAgICB9LFxuICAgIG5ld19mb250OiBmdW5jdGlvbiBuZXdfZm9udCgpIHtcbiAgICAgIHJldHVybiAnMTJweCAnICsgdGhpcy4kcHJvcHMuZm9udC5zcGxpdCgncHgnKS5wb3AoKTtcbiAgICB9LFxuICAgIHByaWNlOiBmdW5jdGlvbiBwcmljZSgpIHtcbiAgICAgIHJldHVybiAncHJpY2UnIGluIHRoaXMuc2V0dCA/IHRoaXMuc2V0dC5wcmljZSA6IHRydWU7XG4gICAgfSxcbiAgICB0aW1lOiBmdW5jdGlvbiB0aW1lKCkge1xuICAgICAgcmV0dXJuICd0aW1lJyBpbiB0aGlzLnNldHQgPyB0aGlzLnNldHQudGltZSA6IGZhbHNlO1xuICAgIH0sXG4gICAgc2hpZnQ6IGZ1bmN0aW9uIHNoaWZ0KCkge1xuICAgICAgcmV0dXJuIHRoaXMuc2V0dC5zaGlmdE1vZGU7XG4gICAgfVxuICB9LFxuICBkYXRhOiBmdW5jdGlvbiBkYXRhKCkge1xuICAgIHJldHVybiB7fTtcbiAgfVxufSk7XG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvY29tcG9uZW50cy9vdmVybGF5cy9SYW5nZVRvb2wudnVlP3Z1ZSZ0eXBlPXNjcmlwdCZsYW5nPWpzJlxuIC8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gY29uc3Qgb3ZlcmxheXNfUmFuZ2VUb29sdnVlX3R5cGVfc2NyaXB0X2xhbmdfanNfID0gKFJhbmdlVG9vbHZ1ZV90eXBlX3NjcmlwdF9sYW5nX2pzXyk7IFxuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL2NvbXBvbmVudHMvb3ZlcmxheXMvUmFuZ2VUb29sLnZ1ZVxudmFyIFJhbmdlVG9vbF9yZW5kZXIsIFJhbmdlVG9vbF9zdGF0aWNSZW5kZXJGbnNcbjtcblxuXG5cbi8qIG5vcm1hbGl6ZSBjb21wb25lbnQgKi9cbjtcbnZhciBSYW5nZVRvb2xfY29tcG9uZW50ID0gbm9ybWFsaXplQ29tcG9uZW50KFxuICBvdmVybGF5c19SYW5nZVRvb2x2dWVfdHlwZV9zY3JpcHRfbGFuZ19qc18sXG4gIFJhbmdlVG9vbF9yZW5kZXIsXG4gIFJhbmdlVG9vbF9zdGF0aWNSZW5kZXJGbnMsXG4gIGZhbHNlLFxuICBudWxsLFxuICBudWxsLFxuICBudWxsXG4gIFxuKVxuXG4vKiBob3QgcmVsb2FkICovXG5pZiAoZmFsc2UpIHsgdmFyIFJhbmdlVG9vbF9hcGk7IH1cblJhbmdlVG9vbF9jb21wb25lbnQub3B0aW9ucy5fX2ZpbGUgPSBcInNyYy9jb21wb25lbnRzL292ZXJsYXlzL1JhbmdlVG9vbC52dWVcIlxuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyBjb25zdCBSYW5nZVRvb2wgPSAoUmFuZ2VUb29sX2NvbXBvbmVudC5leHBvcnRzKTtcbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL25vZGVfbW9kdWxlcy9iYWJlbC1sb2FkZXIvbGliL2luZGV4LmpzIS4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL2luZGV4LmpzPz92dWUtbG9hZGVyLW9wdGlvbnMhLi9zcmMvY29tcG9uZW50cy9HcmlkLnZ1ZT92dWUmdHlwZT1zY3JpcHQmbGFuZz1qcyZcbmZ1bmN0aW9uIEdyaWR2dWVfdHlwZV9zY3JpcHRfbGFuZ19qc19jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyKG8sIGFsbG93QXJyYXlMaWtlKSB7IHZhciBpdDsgaWYgKHR5cGVvZiBTeW1ib2wgPT09IFwidW5kZWZpbmVkXCIgfHwgb1tTeW1ib2wuaXRlcmF0b3JdID09IG51bGwpIHsgaWYgKEFycmF5LmlzQXJyYXkobykgfHwgKGl0ID0gR3JpZHZ1ZV90eXBlX3NjcmlwdF9sYW5nX2pzX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5KG8pKSB8fCBhbGxvd0FycmF5TGlrZSAmJiBvICYmIHR5cGVvZiBvLmxlbmd0aCA9PT0gXCJudW1iZXJcIikgeyBpZiAoaXQpIG8gPSBpdDsgdmFyIGkgPSAwOyB2YXIgRiA9IGZ1bmN0aW9uIEYoKSB7fTsgcmV0dXJuIHsgczogRiwgbjogZnVuY3Rpb24gbigpIHsgaWYgKGkgPj0gby5sZW5ndGgpIHJldHVybiB7IGRvbmU6IHRydWUgfTsgcmV0dXJuIHsgZG9uZTogZmFsc2UsIHZhbHVlOiBvW2krK10gfTsgfSwgZTogZnVuY3Rpb24gZShfZSkgeyB0aHJvdyBfZTsgfSwgZjogRiB9OyB9IHRocm93IG5ldyBUeXBlRXJyb3IoXCJJbnZhbGlkIGF0dGVtcHQgdG8gaXRlcmF0ZSBub24taXRlcmFibGUgaW5zdGFuY2UuXFxuSW4gb3JkZXIgdG8gYmUgaXRlcmFibGUsIG5vbi1hcnJheSBvYmplY3RzIG11c3QgaGF2ZSBhIFtTeW1ib2wuaXRlcmF0b3JdKCkgbWV0aG9kLlwiKTsgfSB2YXIgbm9ybWFsQ29tcGxldGlvbiA9IHRydWUsIGRpZEVyciA9IGZhbHNlLCBlcnI7IHJldHVybiB7IHM6IGZ1bmN0aW9uIHMoKSB7IGl0ID0gb1tTeW1ib2wuaXRlcmF0b3JdKCk7IH0sIG46IGZ1bmN0aW9uIG4oKSB7IHZhciBzdGVwID0gaXQubmV4dCgpOyBub3JtYWxDb21wbGV0aW9uID0gc3RlcC5kb25lOyByZXR1cm4gc3RlcDsgfSwgZTogZnVuY3Rpb24gZShfZTIpIHsgZGlkRXJyID0gdHJ1ZTsgZXJyID0gX2UyOyB9LCBmOiBmdW5jdGlvbiBmKCkgeyB0cnkgeyBpZiAoIW5vcm1hbENvbXBsZXRpb24gJiYgaXRbXCJyZXR1cm5cIl0gIT0gbnVsbCkgaXRbXCJyZXR1cm5cIl0oKTsgfSBmaW5hbGx5IHsgaWYgKGRpZEVycikgdGhyb3cgZXJyOyB9IH0gfTsgfVxuXG5mdW5jdGlvbiBHcmlkdnVlX3R5cGVfc2NyaXB0X2xhbmdfanNfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkobywgbWluTGVuKSB7IGlmICghbykgcmV0dXJuOyBpZiAodHlwZW9mIG8gPT09IFwic3RyaW5nXCIpIHJldHVybiBHcmlkdnVlX3R5cGVfc2NyaXB0X2xhbmdfanNfYXJyYXlMaWtlVG9BcnJheShvLCBtaW5MZW4pOyB2YXIgbiA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvKS5zbGljZSg4LCAtMSk7IGlmIChuID09PSBcIk9iamVjdFwiICYmIG8uY29uc3RydWN0b3IpIG4gPSBvLmNvbnN0cnVjdG9yLm5hbWU7IGlmIChuID09PSBcIk1hcFwiIHx8IG4gPT09IFwiU2V0XCIpIHJldHVybiBBcnJheS5mcm9tKG8pOyBpZiAobiA9PT0gXCJBcmd1bWVudHNcIiB8fCAvXig/OlVpfEkpbnQoPzo4fDE2fDMyKSg/OkNsYW1wZWQpP0FycmF5JC8udGVzdChuKSkgcmV0dXJuIEdyaWR2dWVfdHlwZV9zY3JpcHRfbGFuZ19qc19hcnJheUxpa2VUb0FycmF5KG8sIG1pbkxlbik7IH1cblxuZnVuY3Rpb24gR3JpZHZ1ZV90eXBlX3NjcmlwdF9sYW5nX2pzX2FycmF5TGlrZVRvQXJyYXkoYXJyLCBsZW4pIHsgaWYgKGxlbiA9PSBudWxsIHx8IGxlbiA+IGFyci5sZW5ndGgpIGxlbiA9IGFyci5sZW5ndGg7IGZvciAodmFyIGkgPSAwLCBhcnIyID0gbmV3IEFycmF5KGxlbik7IGkgPCBsZW47IGkrKykgeyBhcnIyW2ldID0gYXJyW2ldOyB9IHJldHVybiBhcnIyOyB9XG5cbi8vIFNldHMgdXAgYWxsIGxheWVycy9vdmVybGF5cyBmb3IgdGhlIGdyaWQgd2l0aCAnZ3JpZF9pZCdcblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIGNvbnN0IEdyaWR2dWVfdHlwZV9zY3JpcHRfbGFuZ19qc18gPSAoe1xuICBuYW1lOiAnR3JpZCcsXG4gIHByb3BzOiBbJ3N1YicsICdsYXlvdXQnLCAncmFuZ2UnLCAnaW50ZXJ2YWwnLCAnY3Vyc29yJywgJ2NvbG9ycycsICdvdmVybGF5cycsICd3aWR0aCcsICdoZWlnaHQnLCAnZGF0YScsICdncmlkX2lkJywgJ3lfdHJhbnNmb3JtJywgJ2ZvbnQnLCAndHZfaWQnLCAnY29uZmlnJywgJ21ldGEnLCAnc2hhZGVycyddLFxuICBtaXhpbnM6IFtjYW52YXMsIHV4bGlzdF0sXG4gIGNvbXBvbmVudHM6IHtcbiAgICBDcm9zc2hhaXI6IGNvbXBvbmVudHNfQ3Jvc3NoYWlyLFxuICAgIEtleWJvYXJkTGlzdGVuZXI6IEtleWJvYXJkTGlzdGVuZXJcbiAgfSxcbiAgY3JlYXRlZDogZnVuY3Rpb24gY3JlYXRlZCgpIHtcbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgLy8gTGlzdCBvZiBhbGwgcG9zc2libGUgb3ZlcmxheXMgKGJ1aWx0aW4gKyBjdXN0b20pXG4gICAgdGhpcy5fbGlzdCA9IFtTcGxpbmUsIFNwbGluZXMsIFJhbmdlLCBUcmFkZXMsIENoYW5uZWwsIFNlZ21lbnQsIENhbmRsZXMsIFZvbHVtZSwgU3BsaXR0ZXJzLCBMaW5lVG9vbCwgUmFuZ2VUb29sXS5jb25jYXQodGhpcy4kcHJvcHMub3ZlcmxheXMpO1xuICAgIHRoaXMuX3JlZ2lzdHJ5ID0ge307IC8vIFdlIG5lZWQgdG8ga25vdyB3aGljaCBjb21wb25lbnRzIHdlIHdpbGwgdXNlLlxuICAgIC8vIEN1c3RvbSBvdmVybGF5IGNvbXBvbmVudHMgb3ZlcndyaXRlIGJ1aWx0LWluczpcblxuICAgIHZhciB0b29scyA9IFtdO1xuXG4gICAgdGhpcy5fbGlzdC5mb3JFYWNoKGZ1bmN0aW9uICh4LCBpKSB7XG4gICAgICB2YXIgdXNlX2ZvciA9IHgubWV0aG9kcy51c2VfZm9yKCk7XG4gICAgICBpZiAoeC5tZXRob2RzLnRvb2wpIHRvb2xzLnB1c2goe1xuICAgICAgICB1c2VfZm9yOiB1c2VfZm9yLFxuICAgICAgICBpbmZvOiB4Lm1ldGhvZHMudG9vbCgpXG4gICAgICB9KTtcbiAgICAgIHVzZV9mb3IuZm9yRWFjaChmdW5jdGlvbiAoaW5kaWNhdG9yKSB7XG4gICAgICAgIF90aGlzLl9yZWdpc3RyeVtpbmRpY2F0b3JdID0gaTtcbiAgICAgIH0pO1xuICAgIH0pO1xuXG4gICAgdGhpcy4kZW1pdCgnY3VzdG9tLWV2ZW50Jywge1xuICAgICAgZXZlbnQ6ICdyZWdpc3Rlci10b29scycsXG4gICAgICBhcmdzOiB0b29sc1xuICAgIH0pO1xuICAgIHRoaXMuJG9uKCdjdXN0b20tZXZlbnQnLCBmdW5jdGlvbiAoZSkge1xuICAgICAgcmV0dXJuIF90aGlzLm9uX3V4X2V2ZW50KGUsICdncmlkJyk7XG4gICAgfSk7XG4gIH0sXG4gIGJlZm9yZURlc3Ryb3k6IGZ1bmN0aW9uIGJlZm9yZURlc3Ryb3koKSB7XG4gICAgaWYgKHRoaXMucmVuZGVyZXIpIHRoaXMucmVuZGVyZXIuZGVzdHJveSgpO1xuICB9LFxuICBtb3VudGVkOiBmdW5jdGlvbiBtb3VudGVkKCkge1xuICAgIHZhciBfdGhpczIgPSB0aGlzO1xuXG4gICAgdmFyIGVsID0gdGhpcy4kcmVmc1snY2FudmFzJ107XG4gICAgdGhpcy5yZW5kZXJlciA9IG5ldyBHcmlkKGVsLCB0aGlzKTtcbiAgICB0aGlzLnNldHVwKCk7XG4gICAgdGhpcy4kbmV4dFRpY2soZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIF90aGlzMi5yZWRyYXcoKTtcbiAgICB9KTtcbiAgfSxcbiAgcmVuZGVyOiBmdW5jdGlvbiByZW5kZXIoaCkge1xuICAgIHZhciBpZCA9IHRoaXMuJHByb3BzLmdyaWRfaWQ7XG4gICAgdmFyIGxheW91dCA9IHRoaXMuJHByb3BzLmxheW91dC5ncmlkc1tpZF07XG4gICAgcmV0dXJuIHRoaXMuY3JlYXRlX2NhbnZhcyhoLCBcImdyaWQtXCIuY29uY2F0KGlkKSwge1xuICAgICAgcG9zaXRpb246IHtcbiAgICAgICAgeDogMCxcbiAgICAgICAgeTogbGF5b3V0Lm9mZnNldCB8fCAwXG4gICAgICB9LFxuICAgICAgYXR0cnM6IHtcbiAgICAgICAgd2lkdGg6IGxheW91dC53aWR0aCxcbiAgICAgICAgaGVpZ2h0OiBsYXlvdXQuaGVpZ2h0LFxuICAgICAgICBvdmVyZmxvdzogJ2hpZGRlbidcbiAgICAgIH0sXG4gICAgICBzdHlsZToge1xuICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6IHRoaXMuJHByb3BzLmNvbG9ycy5iYWNrXG4gICAgICB9LFxuICAgICAgaHM6IFtoKGNvbXBvbmVudHNfQ3Jvc3NoYWlyLCB7XG4gICAgICAgIHByb3BzOiB0aGlzLmNvbW1vbl9wcm9wcygpLFxuICAgICAgICBvbjogdGhpcy5sYXllcl9ldmVudHNcbiAgICAgIH0pLCBoKEtleWJvYXJkTGlzdGVuZXIsIHtcbiAgICAgICAgb246IHRoaXMua2V5Ym9hcmRfZXZlbnRzXG4gICAgICB9KSwgaChVeExheWVyLCB7XG4gICAgICAgIHByb3BzOiB7XG4gICAgICAgICAgaWQ6IGlkLFxuICAgICAgICAgIHR2X2lkOiB0aGlzLiRwcm9wcy50dl9pZCxcbiAgICAgICAgICB1eHM6IHRoaXMudXhzLFxuICAgICAgICAgIGNvbG9yczogdGhpcy4kcHJvcHMuY29sb3JzLFxuICAgICAgICAgIGNvbmZpZzogdGhpcy4kcHJvcHMuY29uZmlnLFxuICAgICAgICAgIHVwZGF0ZXI6IE1hdGgucmFuZG9tKClcbiAgICAgICAgfSxcbiAgICAgICAgb246IHtcbiAgICAgICAgICAnY3VzdG9tLWV2ZW50JzogdGhpcy5lbWl0X3V4X2V2ZW50XG4gICAgICAgIH1cbiAgICAgIH0pXS5jb25jYXQodGhpcy5nZXRfb3ZlcmxheXMoaCkpXG4gICAgfSk7XG4gIH0sXG4gIG1ldGhvZHM6IHtcbiAgICBuZXdfbGF5ZXI6IGZ1bmN0aW9uIG5ld19sYXllcihsYXllcikge1xuICAgICAgdmFyIF90aGlzMyA9IHRoaXM7XG5cbiAgICAgIHRoaXMuJG5leHRUaWNrKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIF90aGlzMy5yZW5kZXJlci5uZXdfbGF5ZXIobGF5ZXIpO1xuICAgICAgfSk7XG4gICAgfSxcbiAgICBkZWxfbGF5ZXI6IGZ1bmN0aW9uIGRlbF9sYXllcihsYXllcikge1xuICAgICAgdmFyIF90aGlzNCA9IHRoaXM7XG5cbiAgICAgIHRoaXMuJG5leHRUaWNrKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIF90aGlzNC5yZW5kZXJlci5kZWxfbGF5ZXIobGF5ZXIpO1xuICAgICAgfSk7XG4gICAgICB2YXIgZ3JpZF9pZCA9IHRoaXMuJHByb3BzLmdyaWRfaWQ7XG4gICAgICB0aGlzLiRlbWl0KCdjdXN0b20tZXZlbnQnLCB7XG4gICAgICAgIGV2ZW50OiAncmVtb3ZlLXNoYWRlcnMnLFxuICAgICAgICBhcmdzOiBbZ3JpZF9pZCwgbGF5ZXJdXG4gICAgICB9KTsgLy8gVE9ETzogY2xvc2UgYWxsIGludGVyZmFjZXNcblxuICAgICAgdGhpcy4kZW1pdCgnY3VzdG9tLWV2ZW50Jywge1xuICAgICAgICBldmVudDogJ3JlbW92ZS1sYXllci1tZXRhJyxcbiAgICAgICAgYXJnczogW2dyaWRfaWQsIGxheWVyXVxuICAgICAgfSk7XG4gICAgICB0aGlzLnJlbW92ZV9hbGxfdXgobGF5ZXIpO1xuICAgIH0sXG4gICAgZ2V0X292ZXJsYXlzOiBmdW5jdGlvbiBnZXRfb3ZlcmxheXMoaCkge1xuICAgICAgdmFyIF90aGlzNSA9IHRoaXM7XG5cbiAgICAgIC8vIERpc3RyaWJ1dGVzIG92ZXJsYXkgZGF0YSAmIHNldHRpbmdzIGFjY29yZGluZ1xuICAgICAgLy8gdG8gdGhpcy5fcmVnaXN0cnk7IHJldHVybnMgY29tcG8gbGlzdFxuICAgICAgdmFyIGNvbXBfbGlzdCA9IFtdLFxuICAgICAgICAgIGNvdW50ID0ge307XG5cbiAgICAgIHZhciBfaXRlcmF0b3IgPSBHcmlkdnVlX3R5cGVfc2NyaXB0X2xhbmdfanNfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlcih0aGlzLiRwcm9wcy5kYXRhKSxcbiAgICAgICAgICBfc3RlcDtcblxuICAgICAgdHJ5IHtcbiAgICAgICAgZm9yIChfaXRlcmF0b3IucygpOyAhKF9zdGVwID0gX2l0ZXJhdG9yLm4oKSkuZG9uZTspIHtcbiAgICAgICAgICB2YXIgZCA9IF9zdGVwLnZhbHVlO1xuICAgICAgICAgIHZhciBjb21wID0gdGhpcy5fbGlzdFt0aGlzLl9yZWdpc3RyeVtkLnR5cGVdXTtcblxuICAgICAgICAgIGlmIChjb21wKSB7XG4gICAgICAgICAgICBpZiAoY29tcC5tZXRob2RzLmNhbGMpIHtcbiAgICAgICAgICAgICAgY29tcCA9IHRoaXMuaW5qZWN0X3JlbmRlcmVyKGNvbXApO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjb21wX2xpc3QucHVzaCh7XG4gICAgICAgICAgICAgIGNsczogY29tcCxcbiAgICAgICAgICAgICAgdHlwZTogZC50eXBlLFxuICAgICAgICAgICAgICBkYXRhOiBkLmRhdGEsXG4gICAgICAgICAgICAgIHNldHRpbmdzOiBkLnNldHRpbmdzLFxuICAgICAgICAgICAgICBpMDogZC5pMCxcbiAgICAgICAgICAgICAgdGY6IGQudGYsXG4gICAgICAgICAgICAgIGxhc3Q6IGQubGFzdFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBjb3VudFtkLnR5cGVdID0gMDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICBfaXRlcmF0b3IuZShlcnIpO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgX2l0ZXJhdG9yLmYoKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGNvbXBfbGlzdC5tYXAoZnVuY3Rpb24gKHgsIGkpIHtcbiAgICAgICAgcmV0dXJuIGgoeC5jbHMsIHtcbiAgICAgICAgICBvbjogX3RoaXM1LmxheWVyX2V2ZW50cyxcbiAgICAgICAgICBhdHRyczogT2JqZWN0LmFzc2lnbihfdGhpczUuY29tbW9uX3Byb3BzKCksIHtcbiAgICAgICAgICAgIGlkOiBcIlwiLmNvbmNhdCh4LnR5cGUsIFwiX1wiKS5jb25jYXQoY291bnRbeC50eXBlXSsrKSxcbiAgICAgICAgICAgIHR5cGU6IHgudHlwZSxcbiAgICAgICAgICAgIGRhdGE6IHguZGF0YSxcbiAgICAgICAgICAgIHNldHRpbmdzOiB4LnNldHRpbmdzLFxuICAgICAgICAgICAgaTA6IHguaTAsXG4gICAgICAgICAgICB0ZjogeC50ZixcbiAgICAgICAgICAgIG51bTogaSxcbiAgICAgICAgICAgIGdyaWRfaWQ6IF90aGlzNS4kcHJvcHMuZ3JpZF9pZCxcbiAgICAgICAgICAgIG1ldGE6IF90aGlzNS4kcHJvcHMubWV0YSxcbiAgICAgICAgICAgIGxhc3Q6IHgubGFzdFxuICAgICAgICAgIH0pXG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfSxcbiAgICBjb21tb25fcHJvcHM6IGZ1bmN0aW9uIGNvbW1vbl9wcm9wcygpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGN1cnNvcjogdGhpcy4kcHJvcHMuY3Vyc29yLFxuICAgICAgICBjb2xvcnM6IHRoaXMuJHByb3BzLmNvbG9ycyxcbiAgICAgICAgbGF5b3V0OiB0aGlzLiRwcm9wcy5sYXlvdXQuZ3JpZHNbdGhpcy4kcHJvcHMuZ3JpZF9pZF0sXG4gICAgICAgIGludGVydmFsOiB0aGlzLiRwcm9wcy5pbnRlcnZhbCxcbiAgICAgICAgc3ViOiB0aGlzLiRwcm9wcy5zdWIsXG4gICAgICAgIGZvbnQ6IHRoaXMuJHByb3BzLmZvbnQsXG4gICAgICAgIGNvbmZpZzogdGhpcy4kcHJvcHMuY29uZmlnXG4gICAgICB9O1xuICAgIH0sXG4gICAgZW1pdF91eF9ldmVudDogZnVuY3Rpb24gZW1pdF91eF9ldmVudChlKSB7XG4gICAgICB2YXIgZV9wYXNzID0gdGhpcy5vbl91eF9ldmVudChlLCAnZ3JpZCcpO1xuICAgICAgaWYgKGVfcGFzcykgdGhpcy4kZW1pdCgnY3VzdG9tLWV2ZW50JywgZSk7XG4gICAgfSxcbiAgICAvLyBSZXBsYWNlIHRoZSBjdXJyZW50IGNvbXAgd2l0aCAncmVuZGVyZXInXG4gICAgaW5qZWN0X3JlbmRlcmVyOiBmdW5jdGlvbiBpbmplY3RfcmVuZGVyZXIoY29tcCkge1xuICAgICAgdmFyIHNyYyA9IGNvbXAubWV0aG9kcy5jYWxjKCk7XG5cbiAgICAgIGlmICghc3JjLmNvbmYgfHwgIXNyYy5jb25mLnJlbmRlcmVyIHx8IGNvbXAuX19yZW5kZXJlcl9fKSB7XG4gICAgICAgIHJldHVybiBjb21wO1xuICAgICAgfSAvLyBTZWFyY2ggZm9yIGFuIG92ZXJsYXkgd2l0aCB0aGUgdGFyZ2V0ICduYW1lJ1xuXG5cbiAgICAgIHZhciBmID0gdGhpcy5fbGlzdC5maW5kKGZ1bmN0aW9uICh4KSB7XG4gICAgICAgIHJldHVybiB4Lm5hbWUgPT09IHNyYy5jb25mLnJlbmRlcmVyO1xuICAgICAgfSk7XG5cbiAgICAgIGlmICghZikgcmV0dXJuIGNvbXA7XG4gICAgICBjb21wLm1peGlucy5wdXNoKGYpO1xuICAgICAgY29tcC5fX3JlbmRlcmVyX18gPSBzcmMuY29uZi5yZW5kZXJlcjtcbiAgICAgIHJldHVybiBjb21wO1xuICAgIH1cbiAgfSxcbiAgY29tcHV0ZWQ6IHtcbiAgICBpc19hY3RpdmU6IGZ1bmN0aW9uIGlzX2FjdGl2ZSgpIHtcbiAgICAgIHJldHVybiB0aGlzLiRwcm9wcy5jdXJzb3IudCAhPT0gdW5kZWZpbmVkICYmIHRoaXMuJHByb3BzLmN1cnNvci5ncmlkX2lkID09PSB0aGlzLiRwcm9wcy5ncmlkX2lkO1xuICAgIH1cbiAgfSxcbiAgd2F0Y2g6IHtcbiAgICByYW5nZToge1xuICAgICAgaGFuZGxlcjogZnVuY3Rpb24gaGFuZGxlcigpIHtcbiAgICAgICAgdmFyIF90aGlzNiA9IHRoaXM7XG5cbiAgICAgICAgLy8gVE9ETzogTGVmdC1zaWRlIHJlbmRlciBsYWcgZml4OlxuICAgICAgICAvLyBPdmVybGF5IGRhdGEgaXMgdXBkYXRlZCBvbmUgdGljayBsYXRlciB0aGFuXG4gICAgICAgIC8vIHRoZSBtYWluIHN1Yi4gRmFzdCBmaXggaXMgdG8gZGVsYXkgcmVkcmF3KClcbiAgICAgICAgLy8gY2FsbC4gSXQgd2lsbCBiZSBhIHNvbHV0aW9uIHVudGlsIGEgYmV0dGVyXG4gICAgICAgIC8vIG9uZSBjb21lcyBieS5cbiAgICAgICAgdGhpcy4kbmV4dFRpY2soZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHJldHVybiBfdGhpczYucmVkcmF3KCk7XG4gICAgICAgIH0pO1xuICAgICAgfSxcbiAgICAgIGRlZXA6IHRydWVcbiAgICB9LFxuICAgIGN1cnNvcjoge1xuICAgICAgaGFuZGxlcjogZnVuY3Rpb24gaGFuZGxlcigpIHtcbiAgICAgICAgaWYgKCF0aGlzLiRwcm9wcy5jdXJzb3IubG9ja2VkKSB0aGlzLnJlZHJhdygpO1xuICAgICAgfSxcbiAgICAgIGRlZXA6IHRydWVcbiAgICB9LFxuICAgIG92ZXJsYXlzOiB7XG4gICAgICAvLyBUcmFjayBjaGFuZ2VzIGluIGNhbGMoKSBmdW5jdGlvbnNcbiAgICAgIGhhbmRsZXI6IGZ1bmN0aW9uIGhhbmRsZXIob3ZzKSB7XG4gICAgICAgIHZhciBfaXRlcmF0b3IyID0gR3JpZHZ1ZV90eXBlX3NjcmlwdF9sYW5nX2pzX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXIob3ZzKSxcbiAgICAgICAgICAgIF9zdGVwMjtcblxuICAgICAgICB0cnkge1xuICAgICAgICAgIGZvciAoX2l0ZXJhdG9yMi5zKCk7ICEoX3N0ZXAyID0gX2l0ZXJhdG9yMi5uKCkpLmRvbmU7KSB7XG4gICAgICAgICAgICB2YXIgb3YgPSBfc3RlcDIudmFsdWU7XG5cbiAgICAgICAgICAgIHZhciBfaXRlcmF0b3IzID0gR3JpZHZ1ZV90eXBlX3NjcmlwdF9sYW5nX2pzX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXIodGhpcy4kY2hpbGRyZW4pLFxuICAgICAgICAgICAgICAgIF9zdGVwMztcblxuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgZm9yIChfaXRlcmF0b3IzLnMoKTsgIShfc3RlcDMgPSBfaXRlcmF0b3IzLm4oKSkuZG9uZTspIHtcbiAgICAgICAgICAgICAgICB2YXIgY29tcCA9IF9zdGVwMy52YWx1ZTtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGNvbXAuaWQgIT09ICdzdHJpbmcnKSBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB2YXIgdHVwbGUgPSBjb21wLmlkLnNwbGl0KCdfJyk7XG4gICAgICAgICAgICAgICAgdHVwbGUucG9wKCk7XG5cbiAgICAgICAgICAgICAgICBpZiAodHVwbGUuam9pbignXycpID09PSBvdi5uYW1lKSB7XG4gICAgICAgICAgICAgICAgICBjb21wLmNhbGMgPSBvdi5tZXRob2RzLmNhbGM7XG4gICAgICAgICAgICAgICAgICBpZiAoIWNvbXAuY2FsYykgY29udGludWU7XG4gICAgICAgICAgICAgICAgICB2YXIgY2FsYyA9IGNvbXAuY2FsYy50b1N0cmluZygpO1xuXG4gICAgICAgICAgICAgICAgICBpZiAoY2FsYyAhPT0gb3YuX19wcmV2c2NyaXB0X18pIHtcbiAgICAgICAgICAgICAgICAgICAgY29tcC5leGVjX3NjcmlwdCgpO1xuICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICBvdi5fX3ByZXZzY3JpcHRfXyA9IGNhbGM7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgICAgX2l0ZXJhdG9yMy5lKGVycik7XG4gICAgICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgICBfaXRlcmF0b3IzLmYoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgIF9pdGVyYXRvcjIuZShlcnIpO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgIF9pdGVyYXRvcjIuZigpO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgZGVlcDogdHJ1ZVxuICAgIH0sXG4gICAgLy8gUmVkcmF3IG9uIHRoZSBzaGFkZXIgbGlzdCBjaGFuZ2VcbiAgICBzaGFkZXJzOiBmdW5jdGlvbiBzaGFkZXJzKG4sIHApIHtcbiAgICAgIHRoaXMucmVkcmF3KCk7XG4gICAgfVxuICB9LFxuICBkYXRhOiBmdW5jdGlvbiBkYXRhKCkge1xuICAgIHZhciBfdGhpczcgPSB0aGlzO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgIGxheWVyX2V2ZW50czoge1xuICAgICAgICAnbmV3LWdyaWQtbGF5ZXInOiB0aGlzLm5ld19sYXllcixcbiAgICAgICAgJ2RlbGV0ZS1ncmlkLWxheWVyJzogdGhpcy5kZWxfbGF5ZXIsXG4gICAgICAgICdzaG93LWdyaWQtbGF5ZXInOiBmdW5jdGlvbiBzaG93R3JpZExheWVyKGQpIHtcbiAgICAgICAgICBfdGhpczcucmVuZGVyZXIuc2hvd19oaWRlX2xheWVyKGQpO1xuXG4gICAgICAgICAgX3RoaXM3LnJlZHJhdygpO1xuICAgICAgICB9LFxuICAgICAgICAncmVkcmF3LWdyaWQnOiB0aGlzLnJlZHJhdyxcbiAgICAgICAgJ2xheWVyLW1ldGEtcHJvcHMnOiBmdW5jdGlvbiBsYXllck1ldGFQcm9wcyhkKSB7XG4gICAgICAgICAgcmV0dXJuIF90aGlzNy4kZW1pdCgnbGF5ZXItbWV0YS1wcm9wcycsIGQpO1xuICAgICAgICB9LFxuICAgICAgICAnY3VzdG9tLWV2ZW50JzogZnVuY3Rpb24gY3VzdG9tRXZlbnQoZCkge1xuICAgICAgICAgIHJldHVybiBfdGhpczcuJGVtaXQoJ2N1c3RvbS1ldmVudCcsIGQpO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAga2V5Ym9hcmRfZXZlbnRzOiB7XG4gICAgICAgICdyZWdpc3Rlci1rYi1saXN0ZW5lcic6IGZ1bmN0aW9uIHJlZ2lzdGVyS2JMaXN0ZW5lcihldmVudCkge1xuICAgICAgICAgIF90aGlzNy4kZW1pdCgncmVnaXN0ZXIta2ItbGlzdGVuZXInLCBldmVudCk7XG4gICAgICAgIH0sXG4gICAgICAgICdyZW1vdmUta2ItbGlzdGVuZXInOiBmdW5jdGlvbiByZW1vdmVLYkxpc3RlbmVyKGV2ZW50KSB7XG4gICAgICAgICAgX3RoaXM3LiRlbWl0KCdyZW1vdmUta2ItbGlzdGVuZXInLCBldmVudCk7XG4gICAgICAgIH0sXG4gICAgICAgICdrZXl1cCc6IGZ1bmN0aW9uIGtleXVwKGV2ZW50KSB7XG4gICAgICAgICAgaWYgKCFfdGhpczcuaXNfYWN0aXZlKSByZXR1cm47XG5cbiAgICAgICAgICBfdGhpczcucmVuZGVyZXIucHJvcGFnYXRlKCdrZXl1cCcsIGV2ZW50KTtcbiAgICAgICAgfSxcbiAgICAgICAgJ2tleWRvd24nOiBmdW5jdGlvbiBrZXlkb3duKGV2ZW50KSB7XG4gICAgICAgICAgaWYgKCFfdGhpczcuaXNfYWN0aXZlKSByZXR1cm47IC8vIFRPRE86IGlzIHRoaXMgbmVlZWRlZD9cblxuICAgICAgICAgIF90aGlzNy5yZW5kZXJlci5wcm9wYWdhdGUoJ2tleWRvd24nLCBldmVudCk7XG4gICAgICAgIH0sXG4gICAgICAgICdrZXlwcmVzcyc6IGZ1bmN0aW9uIGtleXByZXNzKGV2ZW50KSB7XG4gICAgICAgICAgaWYgKCFfdGhpczcuaXNfYWN0aXZlKSByZXR1cm47XG5cbiAgICAgICAgICBfdGhpczcucmVuZGVyZXIucHJvcGFnYXRlKCdrZXlwcmVzcycsIGV2ZW50KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG4gIH1cbn0pO1xuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL2NvbXBvbmVudHMvR3JpZC52dWU/dnVlJnR5cGU9c2NyaXB0Jmxhbmc9anMmXG4gLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyBjb25zdCBjb21wb25lbnRzX0dyaWR2dWVfdHlwZV9zY3JpcHRfbGFuZ19qc18gPSAoR3JpZHZ1ZV90eXBlX3NjcmlwdF9sYW5nX2pzXyk7IFxuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL2NvbXBvbmVudHMvR3JpZC52dWVcbnZhciBHcmlkX3JlbmRlciwgR3JpZF9zdGF0aWNSZW5kZXJGbnNcbjtcblxuXG5cbi8qIG5vcm1hbGl6ZSBjb21wb25lbnQgKi9cbjtcbnZhciBHcmlkX2NvbXBvbmVudCA9IG5vcm1hbGl6ZUNvbXBvbmVudChcbiAgY29tcG9uZW50c19HcmlkdnVlX3R5cGVfc2NyaXB0X2xhbmdfanNfLFxuICBHcmlkX3JlbmRlcixcbiAgR3JpZF9zdGF0aWNSZW5kZXJGbnMsXG4gIGZhbHNlLFxuICBudWxsLFxuICBudWxsLFxuICBudWxsXG4gIFxuKVxuXG4vKiBob3QgcmVsb2FkICovXG5pZiAoZmFsc2UpIHsgdmFyIEdyaWRfYXBpOyB9XG5HcmlkX2NvbXBvbmVudC5vcHRpb25zLl9fZmlsZSA9IFwic3JjL2NvbXBvbmVudHMvR3JpZC52dWVcIlxuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyBjb25zdCBjb21wb25lbnRzX0dyaWQgPSAoR3JpZF9jb21wb25lbnQuZXhwb3J0cyk7XG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvY29tcG9uZW50cy9qcy9zaWRlYmFyLmpzXG5cblxuXG5mdW5jdGlvbiBzaWRlYmFyX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXIobywgYWxsb3dBcnJheUxpa2UpIHsgdmFyIGl0OyBpZiAodHlwZW9mIFN5bWJvbCA9PT0gXCJ1bmRlZmluZWRcIiB8fCBvW1N5bWJvbC5pdGVyYXRvcl0gPT0gbnVsbCkgeyBpZiAoQXJyYXkuaXNBcnJheShvKSB8fCAoaXQgPSBzaWRlYmFyX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5KG8pKSB8fCBhbGxvd0FycmF5TGlrZSAmJiBvICYmIHR5cGVvZiBvLmxlbmd0aCA9PT0gXCJudW1iZXJcIikgeyBpZiAoaXQpIG8gPSBpdDsgdmFyIGkgPSAwOyB2YXIgRiA9IGZ1bmN0aW9uIEYoKSB7fTsgcmV0dXJuIHsgczogRiwgbjogZnVuY3Rpb24gbigpIHsgaWYgKGkgPj0gby5sZW5ndGgpIHJldHVybiB7IGRvbmU6IHRydWUgfTsgcmV0dXJuIHsgZG9uZTogZmFsc2UsIHZhbHVlOiBvW2krK10gfTsgfSwgZTogZnVuY3Rpb24gZShfZSkgeyB0aHJvdyBfZTsgfSwgZjogRiB9OyB9IHRocm93IG5ldyBUeXBlRXJyb3IoXCJJbnZhbGlkIGF0dGVtcHQgdG8gaXRlcmF0ZSBub24taXRlcmFibGUgaW5zdGFuY2UuXFxuSW4gb3JkZXIgdG8gYmUgaXRlcmFibGUsIG5vbi1hcnJheSBvYmplY3RzIG11c3QgaGF2ZSBhIFtTeW1ib2wuaXRlcmF0b3JdKCkgbWV0aG9kLlwiKTsgfSB2YXIgbm9ybWFsQ29tcGxldGlvbiA9IHRydWUsIGRpZEVyciA9IGZhbHNlLCBlcnI7IHJldHVybiB7IHM6IGZ1bmN0aW9uIHMoKSB7IGl0ID0gb1tTeW1ib2wuaXRlcmF0b3JdKCk7IH0sIG46IGZ1bmN0aW9uIG4oKSB7IHZhciBzdGVwID0gaXQubmV4dCgpOyBub3JtYWxDb21wbGV0aW9uID0gc3RlcC5kb25lOyByZXR1cm4gc3RlcDsgfSwgZTogZnVuY3Rpb24gZShfZTIpIHsgZGlkRXJyID0gdHJ1ZTsgZXJyID0gX2UyOyB9LCBmOiBmdW5jdGlvbiBmKCkgeyB0cnkgeyBpZiAoIW5vcm1hbENvbXBsZXRpb24gJiYgaXRbXCJyZXR1cm5cIl0gIT0gbnVsbCkgaXRbXCJyZXR1cm5cIl0oKTsgfSBmaW5hbGx5IHsgaWYgKGRpZEVycikgdGhyb3cgZXJyOyB9IH0gfTsgfVxuXG5mdW5jdGlvbiBzaWRlYmFyX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5KG8sIG1pbkxlbikgeyBpZiAoIW8pIHJldHVybjsgaWYgKHR5cGVvZiBvID09PSBcInN0cmluZ1wiKSByZXR1cm4gc2lkZWJhcl9hcnJheUxpa2VUb0FycmF5KG8sIG1pbkxlbik7IHZhciBuID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG8pLnNsaWNlKDgsIC0xKTsgaWYgKG4gPT09IFwiT2JqZWN0XCIgJiYgby5jb25zdHJ1Y3RvcikgbiA9IG8uY29uc3RydWN0b3IubmFtZTsgaWYgKG4gPT09IFwiTWFwXCIgfHwgbiA9PT0gXCJTZXRcIikgcmV0dXJuIEFycmF5LmZyb20obyk7IGlmIChuID09PSBcIkFyZ3VtZW50c1wiIHx8IC9eKD86VWl8SSludCg/Ojh8MTZ8MzIpKD86Q2xhbXBlZCk/QXJyYXkkLy50ZXN0KG4pKSByZXR1cm4gc2lkZWJhcl9hcnJheUxpa2VUb0FycmF5KG8sIG1pbkxlbik7IH1cblxuZnVuY3Rpb24gc2lkZWJhcl9hcnJheUxpa2VUb0FycmF5KGFyciwgbGVuKSB7IGlmIChsZW4gPT0gbnVsbCB8fCBsZW4gPiBhcnIubGVuZ3RoKSBsZW4gPSBhcnIubGVuZ3RoOyBmb3IgKHZhciBpID0gMCwgYXJyMiA9IG5ldyBBcnJheShsZW4pOyBpIDwgbGVuOyBpKyspIHsgYXJyMltpXSA9IGFycltpXTsgfSByZXR1cm4gYXJyMjsgfVxuXG5cblxuXG52YXIgUEFOSEVJR0hUO1xuXG52YXIgU2lkZWJhciA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIFNpZGViYXIoY2FudmFzLCBjb21wLCBzaWRlKSB7XG4gICAgaWYgKHNpZGUgPT09IHZvaWQgMCkge1xuICAgICAgc2lkZSA9ICdyaWdodCc7XG4gICAgfVxuXG4gICAgY2xhc3NDYWxsQ2hlY2tfY2xhc3NDYWxsQ2hlY2sodGhpcywgU2lkZWJhcik7XG5cbiAgICBQQU5IRUlHSFQgPSBjb21wLmNvbmZpZy5QQU5IRUlHSFQ7XG4gICAgdGhpcy5jYW52YXMgPSBjYW52YXM7XG4gICAgdGhpcy5jdHggPSBjYW52YXMuZ2V0Q29udGV4dCgnMmQnKTtcbiAgICB0aGlzLmNvbXAgPSBjb21wO1xuICAgIHRoaXMuJHAgPSBjb21wLiRwcm9wcztcbiAgICB0aGlzLmRhdGEgPSB0aGlzLiRwLnN1YjtcbiAgICB0aGlzLnJhbmdlID0gdGhpcy4kcC5yYW5nZTtcbiAgICB0aGlzLmlkID0gdGhpcy4kcC5ncmlkX2lkO1xuICAgIHRoaXMubGF5b3V0ID0gdGhpcy4kcC5sYXlvdXQuZ3JpZHNbdGhpcy5pZF07XG4gICAgdGhpcy5zaWRlID0gc2lkZTtcbiAgICB0aGlzLmxpc3RlbmVycygpO1xuICB9XG5cbiAgY3JlYXRlQ2xhc3NfY3JlYXRlQ2xhc3MoU2lkZWJhciwgW3tcbiAgICBrZXk6IFwibGlzdGVuZXJzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGxpc3RlbmVycygpIHtcbiAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICAgIHZhciBtYyA9IHRoaXMubWMgPSBuZXcgaGFtbWVyLk1hbmFnZXIodGhpcy5jYW52YXMpO1xuICAgICAgbWMuYWRkKG5ldyBoYW1tZXIuUGFuKHtcbiAgICAgICAgZGlyZWN0aW9uOiBoYW1tZXIuRElSRUNUSU9OX1ZFUlRJQ0FMLFxuICAgICAgICB0aHJlc2hvbGQ6IDBcbiAgICAgIH0pKTtcbiAgICAgIG1jLmFkZChuZXcgaGFtbWVyLlRhcCh7XG4gICAgICAgIGV2ZW50OiAnZG91YmxldGFwJyxcbiAgICAgICAgdGFwczogMixcbiAgICAgICAgcG9zVGhyZXNob2xkOiA1MFxuICAgICAgfSkpO1xuICAgICAgbWMub24oJ3BhbnN0YXJ0JywgZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgIGlmIChfdGhpcy4kcC55X3RyYW5zZm9ybSkge1xuICAgICAgICAgIF90aGlzLnpvb20gPSBfdGhpcy4kcC55X3RyYW5zZm9ybS56b29tO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIF90aGlzLnpvb20gPSAxLjA7XG4gICAgICAgIH1cblxuICAgICAgICBfdGhpcy55X3JhbmdlID0gW190aGlzLmxheW91dC4kX2hpLCBfdGhpcy5sYXlvdXQuJF9sb107XG4gICAgICAgIF90aGlzLmRydWcgPSB7XG4gICAgICAgICAgeTogZXZlbnQuY2VudGVyLnksXG4gICAgICAgICAgejogX3RoaXMuem9vbSxcbiAgICAgICAgICBtaWQ6IG1hdGgubG9nX21pZChfdGhpcy55X3JhbmdlLCBfdGhpcy5sYXlvdXQuaGVpZ2h0KSxcbiAgICAgICAgICBBOiBfdGhpcy5sYXlvdXQuQSxcbiAgICAgICAgICBCOiBfdGhpcy5sYXlvdXQuQlxuICAgICAgICB9O1xuICAgICAgfSk7XG4gICAgICBtYy5vbigncGFubW92ZScsIGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICBpZiAoX3RoaXMuZHJ1Zykge1xuICAgICAgICAgIF90aGlzLnpvb20gPSBfdGhpcy5jYWxjX3pvb20oZXZlbnQpO1xuXG4gICAgICAgICAgX3RoaXMuY29tcC4kZW1pdCgnc2lkZWJhci10cmFuc2Zvcm0nLCB7XG4gICAgICAgICAgICBncmlkX2lkOiBfdGhpcy5pZCxcbiAgICAgICAgICAgIHpvb206IF90aGlzLnpvb20sXG4gICAgICAgICAgICBhdXRvOiBmYWxzZSxcbiAgICAgICAgICAgIHJhbmdlOiBfdGhpcy5jYWxjX3JhbmdlKCksXG4gICAgICAgICAgICBkcnVnZ2luZzogdHJ1ZVxuICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgX3RoaXMudXBkYXRlKCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgbWMub24oJ3BhbmVuZCcsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgX3RoaXMuZHJ1ZyA9IG51bGw7XG5cbiAgICAgICAgX3RoaXMuY29tcC4kZW1pdCgnc2lkZWJhci10cmFuc2Zvcm0nLCB7XG4gICAgICAgICAgZ3JpZF9pZDogX3RoaXMuaWQsXG4gICAgICAgICAgZHJ1Z2dpbmc6IGZhbHNlXG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgICBtYy5vbignZG91YmxldGFwJywgZnVuY3Rpb24gKCkge1xuICAgICAgICBfdGhpcy5jb21wLiRlbWl0KCdzaWRlYmFyLXRyYW5zZm9ybScsIHtcbiAgICAgICAgICBncmlkX2lkOiBfdGhpcy5pZCxcbiAgICAgICAgICB6b29tOiAxLjAsXG4gICAgICAgICAgYXV0bzogdHJ1ZVxuICAgICAgICB9KTtcblxuICAgICAgICBfdGhpcy56b29tID0gMS4wO1xuXG4gICAgICAgIF90aGlzLnVwZGF0ZSgpO1xuICAgICAgfSk7IC8vIFRPRE86IERvIGxhdGVyIGZvciBtb2JpbGUgdmVyc2lvblxuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJ1cGRhdGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdXBkYXRlKCkge1xuICAgICAgLy8gVXBkYXRlIHJlZmVyZW5jZSB0byB0aGUgZ3JpZFxuICAgICAgdGhpcy5sYXlvdXQgPSB0aGlzLiRwLmxheW91dC5ncmlkc1t0aGlzLmlkXTtcbiAgICAgIHZhciBwb2ludHMgPSB0aGlzLmxheW91dC55cztcbiAgICAgIHZhciB4LFxuICAgICAgICAgIHksXG4gICAgICAgICAgdyxcbiAgICAgICAgICBoLFxuICAgICAgICAgIHNpZGUgPSB0aGlzLnNpZGU7XG4gICAgICB2YXIgc2IgPSB0aGlzLmxheW91dC5zYjsgLy90aGlzLmN0eC5maWxsU3R5bGUgPSB0aGlzLiRwLmNvbG9ycy5iYWNrXG5cbiAgICAgIHRoaXMuY3R4LmZvbnQgPSB0aGlzLiRwLmZvbnQ7XG5cbiAgICAgIHN3aXRjaCAoc2lkZSkge1xuICAgICAgICBjYXNlICdsZWZ0JzpcbiAgICAgICAgICB4ID0gMDtcbiAgICAgICAgICB5ID0gMDtcbiAgICAgICAgICB3ID0gTWF0aC5mbG9vcihzYik7XG4gICAgICAgICAgaCA9IHRoaXMubGF5b3V0LmhlaWdodDsgLy90aGlzLmN0eC5maWxsUmVjdCh4LCB5LCB3LCBoKVxuXG4gICAgICAgICAgdGhpcy5jdHguY2xlYXJSZWN0KHgsIHksIHcsIGgpO1xuICAgICAgICAgIHRoaXMuY3R4LnN0cm9rZVN0eWxlID0gdGhpcy4kcC5jb2xvcnMuc2NhbGU7XG4gICAgICAgICAgdGhpcy5jdHguYmVnaW5QYXRoKCk7XG4gICAgICAgICAgdGhpcy5jdHgubW92ZVRvKHggKyAwLjUsIDApO1xuICAgICAgICAgIHRoaXMuY3R4LmxpbmVUbyh4ICsgMC41LCBoKTtcbiAgICAgICAgICB0aGlzLmN0eC5zdHJva2UoKTtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlICdyaWdodCc6XG4gICAgICAgICAgeCA9IDA7XG4gICAgICAgICAgeSA9IDA7XG4gICAgICAgICAgdyA9IE1hdGguZmxvb3Ioc2IpO1xuICAgICAgICAgIGggPSB0aGlzLmxheW91dC5oZWlnaHQ7IC8vdGhpcy5jdHguZmlsbFJlY3QoeCwgeSwgdywgaClcblxuICAgICAgICAgIHRoaXMuY3R4LmNsZWFyUmVjdCh4LCB5LCB3LCBoKTtcbiAgICAgICAgICB0aGlzLmN0eC5zdHJva2VTdHlsZSA9IHRoaXMuJHAuY29sb3JzLnNjYWxlO1xuICAgICAgICAgIHRoaXMuY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgICAgIHRoaXMuY3R4Lm1vdmVUbyh4ICsgMC41LCAwKTtcbiAgICAgICAgICB0aGlzLmN0eC5saW5lVG8oeCArIDAuNSwgaCk7XG4gICAgICAgICAgdGhpcy5jdHguc3Ryb2tlKCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuY3R4LmZpbGxTdHlsZSA9IHRoaXMuJHAuY29sb3JzLnRleHQ7XG4gICAgICB0aGlzLmN0eC5iZWdpblBhdGgoKTtcblxuICAgICAgdmFyIF9pdGVyYXRvciA9IHNpZGViYXJfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlcihwb2ludHMpLFxuICAgICAgICAgIF9zdGVwO1xuXG4gICAgICB0cnkge1xuICAgICAgICBmb3IgKF9pdGVyYXRvci5zKCk7ICEoX3N0ZXAgPSBfaXRlcmF0b3IubigpKS5kb25lOykge1xuICAgICAgICAgIHZhciBwID0gX3N0ZXAudmFsdWU7XG4gICAgICAgICAgaWYgKHBbMF0gPiB0aGlzLmxheW91dC5oZWlnaHQpIGNvbnRpbnVlO1xuICAgICAgICAgIHZhciB4MSA9IHNpZGUgPT09ICdsZWZ0JyA/IHcgLSAwLjUgOiB4IC0gMC41O1xuICAgICAgICAgIHZhciB4MiA9IHNpZGUgPT09ICdsZWZ0JyA/IHgxIC0gNC41IDogeDEgKyA0LjU7XG4gICAgICAgICAgdGhpcy5jdHgubW92ZVRvKHgxLCBwWzBdIC0gMC41KTtcbiAgICAgICAgICB0aGlzLmN0eC5saW5lVG8oeDIsIHBbMF0gLSAwLjUpO1xuICAgICAgICAgIHZhciBvZmZzdCA9IHNpZGUgPT09ICdsZWZ0JyA/IC0xMCA6IDEwO1xuICAgICAgICAgIHRoaXMuY3R4LnRleHRBbGlnbiA9IHNpZGUgPT09ICdsZWZ0JyA/ICdlbmQnIDogJ3N0YXJ0JztcbiAgICAgICAgICB2YXIgZCA9IHRoaXMubGF5b3V0LnByZWM7XG4gICAgICAgICAgdGhpcy5jdHguZmlsbFRleHQocFsxXS50b0ZpeGVkKGQpLCB4MSArIG9mZnN0LCBwWzBdICsgNCk7XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICBfaXRlcmF0b3IuZShlcnIpO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgX2l0ZXJhdG9yLmYoKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5jdHguc3Ryb2tlKCk7XG4gICAgICBpZiAodGhpcy4kcC5ncmlkX2lkKSB0aGlzLnVwcGVyX2JvcmRlcigpO1xuICAgICAgdGhpcy5hcHBseV9zaGFkZXJzKCk7XG4gICAgICBpZiAodGhpcy4kcC5jdXJzb3IueSAmJiB0aGlzLiRwLmN1cnNvci55JCkgdGhpcy5wYW5lbCgpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJhcHBseV9zaGFkZXJzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGFwcGx5X3NoYWRlcnMoKSB7XG4gICAgICB2YXIgbGF5b3V0ID0gdGhpcy4kcC5sYXlvdXQuZ3JpZHNbdGhpcy5pZF07XG4gICAgICB2YXIgcHJvcHMgPSB7XG4gICAgICAgIGxheW91dDogbGF5b3V0LFxuICAgICAgICBjdXJzb3I6IHRoaXMuJHAuY3Vyc29yXG4gICAgICB9O1xuXG4gICAgICB2YXIgX2l0ZXJhdG9yMiA9IHNpZGViYXJfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlcih0aGlzLiRwLnNoYWRlcnMpLFxuICAgICAgICAgIF9zdGVwMjtcblxuICAgICAgdHJ5IHtcbiAgICAgICAgZm9yIChfaXRlcmF0b3IyLnMoKTsgIShfc3RlcDIgPSBfaXRlcmF0b3IyLm4oKSkuZG9uZTspIHtcbiAgICAgICAgICB2YXIgcyA9IF9zdGVwMi52YWx1ZTtcbiAgICAgICAgICB0aGlzLmN0eC5zYXZlKCk7XG4gICAgICAgICAgcy5kcmF3KHRoaXMuY3R4LCBwcm9wcyk7XG4gICAgICAgICAgdGhpcy5jdHgucmVzdG9yZSgpO1xuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgX2l0ZXJhdG9yMi5lKGVycik7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICBfaXRlcmF0b3IyLmYoKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwidXBwZXJfYm9yZGVyXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHVwcGVyX2JvcmRlcigpIHtcbiAgICAgIHRoaXMuY3R4LnN0cm9rZVN0eWxlID0gdGhpcy4kcC5jb2xvcnMuc2NhbGU7XG4gICAgICB0aGlzLmN0eC5iZWdpblBhdGgoKTtcbiAgICAgIHRoaXMuY3R4Lm1vdmVUbygwLCAwLjUpO1xuICAgICAgdGhpcy5jdHgubGluZVRvKHRoaXMubGF5b3V0LndpZHRoLCAwLjUpO1xuICAgICAgdGhpcy5jdHguc3Ryb2tlKCk7XG4gICAgfSAvLyBBIGdyYXkgYmFyIGJlaGluZCB0aGUgY3VycmVudCBwcmljZVxuXG4gIH0sIHtcbiAgICBrZXk6IFwicGFuZWxcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcGFuZWwoKSB7XG4gICAgICBpZiAodGhpcy4kcC5jdXJzb3IuZ3JpZF9pZCAhPT0gdGhpcy5sYXlvdXQuaWQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB2YXIgbGJsID0gdGhpcy4kcC5jdXJzb3IueSQudG9GaXhlZCh0aGlzLmxheW91dC5wcmVjKTtcbiAgICAgIHRoaXMuY3R4LmZpbGxTdHlsZSA9IHRoaXMuJHAuY29sb3JzLnBhbmVsO1xuICAgICAgdmFyIHBhbndpZHRoID0gdGhpcy5sYXlvdXQuc2IgKyAxO1xuICAgICAgdmFyIHggPSAtMC41O1xuICAgICAgdmFyIHkgPSB0aGlzLiRwLmN1cnNvci55IC0gUEFOSEVJR0hUICogMC41IC0gMC41O1xuICAgICAgdmFyIGEgPSA3O1xuICAgICAgdGhpcy5jdHguZmlsbFJlY3QoeCAtIDAuNSwgeSwgcGFud2lkdGgsIFBBTkhFSUdIVCk7XG4gICAgICB0aGlzLmN0eC5maWxsU3R5bGUgPSB0aGlzLiRwLmNvbG9ycy50ZXh0SEw7XG4gICAgICB0aGlzLmN0eC50ZXh0QWxpZ24gPSAnbGVmdCc7XG4gICAgICB0aGlzLmN0eC5maWxsVGV4dChsYmwsIGEsIHkgKyAxNSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImNhbGNfem9vbVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjYWxjX3pvb20oZXZlbnQpIHtcbiAgICAgIHZhciBkID0gdGhpcy5kcnVnLnkgLSBldmVudC5jZW50ZXIueTtcbiAgICAgIHZhciBzcGVlZCA9IGQgPiAwID8gMyA6IDE7XG4gICAgICB2YXIgayA9IDEgKyBzcGVlZCAqIGQgLyB0aGlzLmxheW91dC5oZWlnaHQ7XG4gICAgICByZXR1cm4gdXRpbHMuY2xhbXAodGhpcy5kcnVnLnogKiBrLCAwLjAwNSwgMTAwKTtcbiAgICB9IC8vIE5vdCB0aGUgYmVzdCBwbGFjZSB0byBjYWxjdWxhdGUgeS1yYW5nZSBidXRcbiAgICAvLyB0aGlzIGlzIHRoZSBzaW1wbGVzdCBzb2x1dGlvbiBJIGZvdW5kIHVwIHRvXG4gICAgLy8gZGF0ZVxuXG4gIH0sIHtcbiAgICBrZXk6IFwiY2FsY19yYW5nZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjYWxjX3JhbmdlKGRpZmYxLCBkaWZmMikge1xuICAgICAgdmFyIF90aGlzMiA9IHRoaXM7XG5cbiAgICAgIGlmIChkaWZmMSA9PT0gdm9pZCAwKSB7XG4gICAgICAgIGRpZmYxID0gMTtcbiAgICAgIH1cblxuICAgICAgaWYgKGRpZmYyID09PSB2b2lkIDApIHtcbiAgICAgICAgZGlmZjIgPSAxO1xuICAgICAgfVxuXG4gICAgICB2YXIgeiA9IHRoaXMuem9vbSAvIHRoaXMuZHJ1Zy56O1xuICAgICAgdmFyIHprID0gKDEgLyB6IC0gMSkgLyAyO1xuICAgICAgdmFyIHJhbmdlID0gdGhpcy55X3JhbmdlLnNsaWNlKCk7XG4gICAgICB2YXIgZGVsdGEgPSByYW5nZVswXSAtIHJhbmdlWzFdO1xuXG4gICAgICBpZiAoIXRoaXMubGF5b3V0LmdyaWQubG9nU2NhbGUpIHtcbiAgICAgICAgcmFuZ2VbMF0gPSByYW5nZVswXSArIGRlbHRhICogemsgKiBkaWZmMTtcbiAgICAgICAgcmFuZ2VbMV0gPSByYW5nZVsxXSAtIGRlbHRhICogemsgKiBkaWZmMjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBweF9taWQgPSB0aGlzLmxheW91dC5oZWlnaHQgLyAyO1xuICAgICAgICB2YXIgbmV3X2hpID0gcHhfbWlkIC0gcHhfbWlkICogKDEgLyB6KTtcbiAgICAgICAgdmFyIG5ld19sbyA9IHB4X21pZCArIHB4X21pZCAqICgxIC8geik7IC8vIFVzZSBvbGQgbWFwcGluZyB0byBnZXQgYSBuZXcgcmFuZ2VcblxuICAgICAgICB2YXIgZiA9IGZ1bmN0aW9uIGYoeSkge1xuICAgICAgICAgIHJldHVybiBtYXRoLmV4cCgoeSAtIF90aGlzMi5kcnVnLkIpIC8gX3RoaXMyLmRydWcuQSk7XG4gICAgICAgIH07XG5cbiAgICAgICAgdmFyIGNvcHkgPSByYW5nZS5zbGljZSgpO1xuICAgICAgICByYW5nZVswXSA9IGYobmV3X2hpKTtcbiAgICAgICAgcmFuZ2VbMV0gPSBmKG5ld19sbyk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiByYW5nZTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwicmV6b29tX3JhbmdlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJlem9vbV9yYW5nZShkZWx0YSwgZGlmZjEsIGRpZmYyKSB7XG4gICAgICBpZiAoIXRoaXMuJHAueV90cmFuc2Zvcm0gfHwgdGhpcy4kcC55X3RyYW5zZm9ybS5hdXRvKSByZXR1cm47XG4gICAgICB0aGlzLnpvb20gPSAxLjA7IC8vIFRPRE86IGZ1cnRoZXIgd29yayAoaW1wcm92ZSBzY2FsaW5nIHJhdGlvKVxuXG4gICAgICBpZiAoZGVsdGEgPCAwKSBkZWx0YSAvPSAzLjc1OyAvLyBCdHcsIGlkayB3aHkgMy43NSwgYnV0IGl0IHdvcmtzXG5cbiAgICAgIGRlbHRhICo9IDAuMjU7XG4gICAgICB0aGlzLnlfcmFuZ2UgPSBbdGhpcy5sYXlvdXQuJF9oaSwgdGhpcy5sYXlvdXQuJF9sb107XG4gICAgICB0aGlzLmRydWcgPSB7XG4gICAgICAgIHk6IDAsXG4gICAgICAgIHo6IHRoaXMuem9vbSxcbiAgICAgICAgbWlkOiBtYXRoLmxvZ19taWQodGhpcy55X3JhbmdlLCB0aGlzLmxheW91dC5oZWlnaHQpLFxuICAgICAgICBBOiB0aGlzLmxheW91dC5BLFxuICAgICAgICBCOiB0aGlzLmxheW91dC5CXG4gICAgICB9O1xuICAgICAgdGhpcy56b29tID0gdGhpcy5jYWxjX3pvb20oe1xuICAgICAgICBjZW50ZXI6IHtcbiAgICAgICAgICB5OiBkZWx0YSAqIHRoaXMubGF5b3V0LmhlaWdodFxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHRoaXMuY29tcC4kZW1pdCgnc2lkZWJhci10cmFuc2Zvcm0nLCB7XG4gICAgICAgIGdyaWRfaWQ6IHRoaXMuaWQsXG4gICAgICAgIHpvb206IHRoaXMuem9vbSxcbiAgICAgICAgYXV0bzogZmFsc2UsXG4gICAgICAgIHJhbmdlOiB0aGlzLmNhbGNfcmFuZ2UoZGlmZjEsIGRpZmYyKSxcbiAgICAgICAgZHJ1Z2dpbmc6IHRydWVcbiAgICAgIH0pO1xuICAgICAgdGhpcy5kcnVnID0gbnVsbDtcbiAgICAgIHRoaXMuY29tcC4kZW1pdCgnc2lkZWJhci10cmFuc2Zvcm0nLCB7XG4gICAgICAgIGdyaWRfaWQ6IHRoaXMuaWQsXG4gICAgICAgIGRydWdnaW5nOiBmYWxzZVxuICAgICAgfSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImRlc3Ryb3lcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZGVzdHJveSgpIHtcbiAgICAgIGlmICh0aGlzLm1jKSB0aGlzLm1jLmRlc3Ryb3koKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwibW91c2Vtb3ZlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG1vdXNlbW92ZSgpIHt9XG4gIH0sIHtcbiAgICBrZXk6IFwibW91c2VvdXRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gbW91c2VvdXQoKSB7fVxuICB9LCB7XG4gICAga2V5OiBcIm1vdXNldXBcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gbW91c2V1cCgpIHt9XG4gIH0sIHtcbiAgICBrZXk6IFwibW91c2Vkb3duXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG1vdXNlZG93bigpIHt9XG4gIH1dKTtcblxuICByZXR1cm4gU2lkZWJhcjtcbn0oKTtcblxuXG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9ub2RlX21vZHVsZXMvYmFiZWwtbG9hZGVyL2xpYi9pbmRleC5qcyEuL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9pbmRleC5qcz8/dnVlLWxvYWRlci1vcHRpb25zIS4vc3JjL2NvbXBvbmVudHMvU2lkZWJhci52dWU/dnVlJnR5cGU9c2NyaXB0Jmxhbmc9anMmXG4vLyBUaGUgc2lkZSBiYXIgKHllcCwgdGhhdCB0aGluZyB3aXRoIGEgYnVuY2ggb2YgJCQkKVxuXG5cbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gY29uc3QgU2lkZWJhcnZ1ZV90eXBlX3NjcmlwdF9sYW5nX2pzXyA9ICh7XG4gIG5hbWU6ICdTaWRlYmFyJyxcbiAgcHJvcHM6IFsnc3ViJywgJ2xheW91dCcsICdyYW5nZScsICdpbnRlcnZhbCcsICdjdXJzb3InLCAnY29sb3JzJywgJ2ZvbnQnLCAnd2lkdGgnLCAnaGVpZ2h0JywgJ2dyaWRfaWQnLCAncmVyZW5kZXInLCAneV90cmFuc2Zvcm0nLCAndHZfaWQnLCAnY29uZmlnJywgJ3NoYWRlcnMnXSxcbiAgbWl4aW5zOiBbY2FudmFzXSxcbiAgbW91bnRlZDogZnVuY3Rpb24gbW91bnRlZCgpIHtcbiAgICB2YXIgZWwgPSB0aGlzLiRyZWZzWydjYW52YXMnXTtcbiAgICB0aGlzLnJlbmRlcmVyID0gbmV3IFNpZGViYXIoZWwsIHRoaXMpO1xuICAgIHRoaXMuc2V0dXAoKTtcbiAgICB0aGlzLnJlZHJhdygpO1xuICB9LFxuICByZW5kZXI6IGZ1bmN0aW9uIHJlbmRlcihoKSB7XG4gICAgdmFyIGlkID0gdGhpcy4kcHJvcHMuZ3JpZF9pZDtcbiAgICB2YXIgbGF5b3V0ID0gdGhpcy4kcHJvcHMubGF5b3V0LmdyaWRzW2lkXTtcbiAgICByZXR1cm4gdGhpcy5jcmVhdGVfY2FudmFzKGgsIFwic2lkZWJhci1cIi5jb25jYXQoaWQpLCB7XG4gICAgICBwb3NpdGlvbjoge1xuICAgICAgICB4OiBsYXlvdXQud2lkdGgsXG4gICAgICAgIHk6IGxheW91dC5vZmZzZXQgfHwgMFxuICAgICAgfSxcbiAgICAgIGF0dHJzOiB7XG4gICAgICAgIHJlcmVuZGVyOiB0aGlzLiRwcm9wcy5yZXJlbmRlcixcbiAgICAgICAgd2lkdGg6IHRoaXMuJHByb3BzLndpZHRoLFxuICAgICAgICBoZWlnaHQ6IGxheW91dC5oZWlnaHRcbiAgICAgIH0sXG4gICAgICBzdHlsZToge1xuICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6IHRoaXMuJHByb3BzLmNvbG9ycy5iYWNrXG4gICAgICB9XG4gICAgfSk7XG4gIH0sXG4gIHdhdGNoOiB7XG4gICAgcmFuZ2U6IHtcbiAgICAgIGhhbmRsZXI6IGZ1bmN0aW9uIGhhbmRsZXIoKSB7XG4gICAgICAgIHRoaXMucmVkcmF3KCk7XG4gICAgICB9LFxuICAgICAgZGVlcDogdHJ1ZVxuICAgIH0sXG4gICAgY3Vyc29yOiB7XG4gICAgICBoYW5kbGVyOiBmdW5jdGlvbiBoYW5kbGVyKCkge1xuICAgICAgICB0aGlzLnJlZHJhdygpO1xuICAgICAgfSxcbiAgICAgIGRlZXA6IHRydWVcbiAgICB9LFxuICAgIHJlcmVuZGVyOiBmdW5jdGlvbiByZXJlbmRlcigpIHtcbiAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICAgIHRoaXMuJG5leHRUaWNrKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIF90aGlzLnJlZHJhdygpO1xuICAgICAgfSk7XG4gICAgfVxuICB9LFxuICBiZWZvcmVEZXN0cm95OiBmdW5jdGlvbiBiZWZvcmVEZXN0cm95KCkge1xuICAgIGlmICh0aGlzLnJlbmRlcmVyKSB0aGlzLnJlbmRlcmVyLmRlc3Ryb3koKTtcbiAgfVxufSk7XG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvY29tcG9uZW50cy9TaWRlYmFyLnZ1ZT92dWUmdHlwZT1zY3JpcHQmbGFuZz1qcyZcbiAvKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIGNvbnN0IGNvbXBvbmVudHNfU2lkZWJhcnZ1ZV90eXBlX3NjcmlwdF9sYW5nX2pzXyA9IChTaWRlYmFydnVlX3R5cGVfc2NyaXB0X2xhbmdfanNfKTsgXG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvY29tcG9uZW50cy9TaWRlYmFyLnZ1ZVxudmFyIFNpZGViYXJfcmVuZGVyLCBTaWRlYmFyX3N0YXRpY1JlbmRlckZuc1xuO1xuXG5cblxuLyogbm9ybWFsaXplIGNvbXBvbmVudCAqL1xuO1xudmFyIFNpZGViYXJfY29tcG9uZW50ID0gbm9ybWFsaXplQ29tcG9uZW50KFxuICBjb21wb25lbnRzX1NpZGViYXJ2dWVfdHlwZV9zY3JpcHRfbGFuZ19qc18sXG4gIFNpZGViYXJfcmVuZGVyLFxuICBTaWRlYmFyX3N0YXRpY1JlbmRlckZucyxcbiAgZmFsc2UsXG4gIG51bGwsXG4gIG51bGwsXG4gIG51bGxcbiAgXG4pXG5cbi8qIGhvdCByZWxvYWQgKi9cbmlmIChmYWxzZSkgeyB2YXIgU2lkZWJhcl9hcGk7IH1cblNpZGViYXJfY29tcG9uZW50Lm9wdGlvbnMuX19maWxlID0gXCJzcmMvY29tcG9uZW50cy9TaWRlYmFyLnZ1ZVwiXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIGNvbnN0IGNvbXBvbmVudHNfU2lkZWJhciA9IChTaWRlYmFyX2NvbXBvbmVudC5leHBvcnRzKTtcbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9sb2FkZXJzL3RlbXBsYXRlTG9hZGVyLmpzPz92dWUtbG9hZGVyLW9wdGlvbnMhLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvaW5kZXguanM/P3Z1ZS1sb2FkZXItb3B0aW9ucyEuL3NyYy9jb21wb25lbnRzL0xlZ2VuZC52dWU/dnVlJnR5cGU9dGVtcGxhdGUmaWQ9MzQ3MjQ4ODYmXG52YXIgTGVnZW5kdnVlX3R5cGVfdGVtcGxhdGVfaWRfMzQ3MjQ4ODZfcmVuZGVyID0gZnVuY3Rpb24oKSB7XG4gIHZhciBfdm0gPSB0aGlzXG4gIHZhciBfaCA9IF92bS4kY3JlYXRlRWxlbWVudFxuICB2YXIgX2MgPSBfdm0uX3NlbGYuX2MgfHwgX2hcbiAgcmV0dXJuIF9jKFxuICAgIFwiZGl2XCIsXG4gICAgeyBzdGF0aWNDbGFzczogXCJ0cmFkaW5nLXZ1ZS1sZWdlbmRcIiwgc3R5bGU6IF92bS5jYWxjX3N0eWxlIH0sXG4gICAgW1xuICAgICAgX3ZtLmdyaWRfaWQgPT09IDBcbiAgICAgICAgPyBfYyhcbiAgICAgICAgICAgIFwiZGl2XCIsXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIHN0YXRpY0NsYXNzOiBcInRyYWRpbmctdnVlLW9obGN2XCIsXG4gICAgICAgICAgICAgIHN0eWxlOiB7IFwibWF4LXdpZHRoXCI6IF92bS5jb21tb24ud2lkdGggKyBcInB4XCIgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIFtcbiAgICAgICAgICAgICAgX2MoXG4gICAgICAgICAgICAgICAgXCJzcGFuXCIsXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgc3RhdGljQ2xhc3M6IFwidC12dWUtdGl0bGVcIixcbiAgICAgICAgICAgICAgICAgIHN0eWxlOiB7IGNvbG9yOiBfdm0uY29tbW9uLmNvbG9ycy50aXRsZSB9XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBbXG4gICAgICAgICAgICAgICAgICBfdm0uX3YoXG4gICAgICAgICAgICAgICAgICAgIFwiXFxuICAgICAgICAgICAgICBcIiArXG4gICAgICAgICAgICAgICAgICAgICAgX3ZtLl9zKF92bS5jb21tb24udGl0bGVfdHh0KSArXG4gICAgICAgICAgICAgICAgICAgICAgXCJcXG4gICAgICAgIFwiXG4gICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgXVxuICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgICBfdm0uX3YoXCIgXCIpLFxuICAgICAgICAgICAgICBfdm0uc2hvd192YWx1ZXNcbiAgICAgICAgICAgICAgICA/IF9jKFwic3BhblwiLCBbXG4gICAgICAgICAgICAgICAgICAgIF92bS5fdihcIlxcbiAgICAgICAgICAgIE9cIiksXG4gICAgICAgICAgICAgICAgICAgIF9jKFwic3BhblwiLCB7IHN0YXRpY0NsYXNzOiBcInQtdnVlLWxzcGFuXCIgfSwgW1xuICAgICAgICAgICAgICAgICAgICAgIF92bS5fdihfdm0uX3MoX3ZtLm9obGN2WzBdKSlcbiAgICAgICAgICAgICAgICAgICAgXSksXG4gICAgICAgICAgICAgICAgICAgIF92bS5fdihcIlxcbiAgICAgICAgICAgIEhcIiksXG4gICAgICAgICAgICAgICAgICAgIF9jKFwic3BhblwiLCB7IHN0YXRpY0NsYXNzOiBcInQtdnVlLWxzcGFuXCIgfSwgW1xuICAgICAgICAgICAgICAgICAgICAgIF92bS5fdihfdm0uX3MoX3ZtLm9obGN2WzFdKSlcbiAgICAgICAgICAgICAgICAgICAgXSksXG4gICAgICAgICAgICAgICAgICAgIF92bS5fdihcIlxcbiAgICAgICAgICAgIExcIiksXG4gICAgICAgICAgICAgICAgICAgIF9jKFwic3BhblwiLCB7IHN0YXRpY0NsYXNzOiBcInQtdnVlLWxzcGFuXCIgfSwgW1xuICAgICAgICAgICAgICAgICAgICAgIF92bS5fdihfdm0uX3MoX3ZtLm9obGN2WzJdKSlcbiAgICAgICAgICAgICAgICAgICAgXSksXG4gICAgICAgICAgICAgICAgICAgIF92bS5fdihcIlxcbiAgICAgICAgICAgIENcIiksXG4gICAgICAgICAgICAgICAgICAgIF9jKFwic3BhblwiLCB7IHN0YXRpY0NsYXNzOiBcInQtdnVlLWxzcGFuXCIgfSwgW1xuICAgICAgICAgICAgICAgICAgICAgIF92bS5fdihfdm0uX3MoX3ZtLm9obGN2WzNdKSlcbiAgICAgICAgICAgICAgICAgICAgXSksXG4gICAgICAgICAgICAgICAgICAgIF92bS5fdihcIlxcbiAgICAgICAgICAgIFZcIiksXG4gICAgICAgICAgICAgICAgICAgIF9jKFwic3BhblwiLCB7IHN0YXRpY0NsYXNzOiBcInQtdnVlLWxzcGFuXCIgfSwgW1xuICAgICAgICAgICAgICAgICAgICAgIF92bS5fdihfdm0uX3MoX3ZtLm9obGN2WzRdKSlcbiAgICAgICAgICAgICAgICAgICAgXSlcbiAgICAgICAgICAgICAgICAgIF0pXG4gICAgICAgICAgICAgICAgOiBfdm0uX2UoKSxcbiAgICAgICAgICAgICAgX3ZtLl92KFwiIFwiKSxcbiAgICAgICAgICAgICAgIV92bS5zaG93X3ZhbHVlc1xuICAgICAgICAgICAgICAgID8gX2MoXG4gICAgICAgICAgICAgICAgICAgIFwic3BhblwiLFxuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgc3RhdGljQ2xhc3M6IFwidC12dWUtbHNwYW5cIixcbiAgICAgICAgICAgICAgICAgICAgICBzdHlsZTogeyBjb2xvcjogX3ZtLmNvbW1vbi5jb2xvcnMudGV4dCB9XG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIFtcbiAgICAgICAgICAgICAgICAgICAgICBfdm0uX3YoXG4gICAgICAgICAgICAgICAgICAgICAgICBcIlxcbiAgICAgICAgICAgIFwiICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgX3ZtLl9zKChfdm0uY29tbW9uLm1ldGEubGFzdCB8fCBbXSlbNF0pICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgXCJcXG4gICAgICAgIFwiXG4gICAgICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgICAgICBdXG4gICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgOiBfdm0uX2UoKVxuICAgICAgICAgICAgXVxuICAgICAgICAgIClcbiAgICAgICAgOiBfdm0uX2UoKSxcbiAgICAgIF92bS5fdihcIiBcIiksXG4gICAgICBfdm0uX2wodGhpcy5pbmRpY2F0b3JzLCBmdW5jdGlvbihpbmQpIHtcbiAgICAgICAgcmV0dXJuIF9jKFxuICAgICAgICAgIFwiZGl2XCIsXG4gICAgICAgICAgeyBzdGF0aWNDbGFzczogXCJ0LXZ1ZS1pbmRcIiB9LFxuICAgICAgICAgIFtcbiAgICAgICAgICAgIF9jKFwic3BhblwiLCB7IHN0YXRpY0NsYXNzOiBcInQtdnVlLWluYW1lXCIgfSwgW1xuICAgICAgICAgICAgICBfdm0uX3YoX3ZtLl9zKGluZC5uYW1lKSlcbiAgICAgICAgICAgIF0pLFxuICAgICAgICAgICAgX3ZtLl92KFwiIFwiKSxcbiAgICAgICAgICAgIF9jKFwiYnV0dG9uLWdyb3VwXCIsIHtcbiAgICAgICAgICAgICAgYXR0cnM6IHtcbiAgICAgICAgICAgICAgICBidXR0b25zOiBfdm0uY29tbW9uLmJ1dHRvbnMsXG4gICAgICAgICAgICAgICAgY29uZmlnOiBfdm0uY29tbW9uLmNvbmZpZyxcbiAgICAgICAgICAgICAgICBvdl9pZDogaW5kLmlkLFxuICAgICAgICAgICAgICAgIGdyaWRfaWQ6IF92bS5ncmlkX2lkLFxuICAgICAgICAgICAgICAgIGluZGV4OiBpbmQuaW5kZXgsXG4gICAgICAgICAgICAgICAgdHZfaWQ6IF92bS5jb21tb24udHZfaWQsXG4gICAgICAgICAgICAgICAgZGlzcGxheTogaW5kLnZcbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgb246IHsgXCJsZWdlbmQtYnV0dG9uLWNsaWNrXCI6IF92bS5idXR0b25fY2xpY2sgfVxuICAgICAgICAgICAgfSksXG4gICAgICAgICAgICBfdm0uX3YoXCIgXCIpLFxuICAgICAgICAgICAgaW5kLnZcbiAgICAgICAgICAgICAgPyBfYyhcbiAgICAgICAgICAgICAgICAgIFwic3BhblwiLFxuICAgICAgICAgICAgICAgICAgeyBzdGF0aWNDbGFzczogXCJ0LXZ1ZS1pdmFsdWVzXCIgfSxcbiAgICAgICAgICAgICAgICAgIF92bS5fbChpbmQudmFsdWVzLCBmdW5jdGlvbih2KSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBfdm0uc2hvd192YWx1ZXNcbiAgICAgICAgICAgICAgICAgICAgICA/IF9jKFxuICAgICAgICAgICAgICAgICAgICAgICAgICBcInNwYW5cIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXRpY0NsYXNzOiBcInQtdnVlLWxzcGFuIHQtdnVlLWl2YWx1ZVwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0eWxlOiB7IGNvbG9yOiB2LmNvbG9yIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF92bS5fdihcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiXFxuICAgICAgICAgICAgICAgIFwiICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX3ZtLl9zKHYudmFsdWUpICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJcXG4gICAgICAgICAgICBcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgXVxuICAgICAgICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgICAgICAgIDogX3ZtLl9lKClcbiAgICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAgICAgMFxuICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgOiBfdm0uX2UoKSxcbiAgICAgICAgICAgIF92bS5fdihcIiBcIiksXG4gICAgICAgICAgICBpbmQudW5rXG4gICAgICAgICAgICAgID8gX2MoXCJzcGFuXCIsIHsgc3RhdGljQ2xhc3M6IFwidC12dWUtdW5rbm93blwiIH0sIFtcbiAgICAgICAgICAgICAgICAgIF92bS5fdihcIlxcbiAgICAgICAgICAgIChVbmtub3duIHR5cGUpXFxuICAgICAgICBcIilcbiAgICAgICAgICAgICAgICBdKVxuICAgICAgICAgICAgICA6IF92bS5fZSgpLFxuICAgICAgICAgICAgX3ZtLl92KFwiIFwiKSxcbiAgICAgICAgICAgIF9jKFxuICAgICAgICAgICAgICBcInRyYW5zaXRpb25cIixcbiAgICAgICAgICAgICAgeyBhdHRyczogeyBuYW1lOiBcInR2anMtYXBwZWFyXCIgfSB9LFxuICAgICAgICAgICAgICBbXG4gICAgICAgICAgICAgICAgaW5kLmxvYWRpbmdcbiAgICAgICAgICAgICAgICAgID8gX2MoXCJzcGlubmVyXCIsIHsgYXR0cnM6IHsgY29sb3JzOiBfdm0uY29tbW9uLmNvbG9ycyB9IH0pXG4gICAgICAgICAgICAgICAgICA6IF92bS5fZSgpXG4gICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgIDFcbiAgICAgICAgICAgIClcbiAgICAgICAgICBdLFxuICAgICAgICAgIDFcbiAgICAgICAgKVxuICAgICAgfSlcbiAgICBdLFxuICAgIDJcbiAgKVxufVxudmFyIExlZ2VuZHZ1ZV90eXBlX3RlbXBsYXRlX2lkXzM0NzI0ODg2X3N0YXRpY1JlbmRlckZucyA9IFtdXG5MZWdlbmR2dWVfdHlwZV90ZW1wbGF0ZV9pZF8zNDcyNDg4Nl9yZW5kZXIuX3dpdGhTdHJpcHBlZCA9IHRydWVcblxuXG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvY29tcG9uZW50cy9MZWdlbmQudnVlP3Z1ZSZ0eXBlPXRlbXBsYXRlJmlkPTM0NzI0ODg2JlxuXG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvbG9hZGVycy90ZW1wbGF0ZUxvYWRlci5qcz8/dnVlLWxvYWRlci1vcHRpb25zIS4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL2luZGV4LmpzPz92dWUtbG9hZGVyLW9wdGlvbnMhLi9zcmMvY29tcG9uZW50cy9CdXR0b25Hcm91cC52dWU/dnVlJnR5cGU9dGVtcGxhdGUmaWQ9NmY4MjY0MjYmXG52YXIgQnV0dG9uR3JvdXB2dWVfdHlwZV90ZW1wbGF0ZV9pZF82ZjgyNjQyNl9yZW5kZXIgPSBmdW5jdGlvbigpIHtcbiAgdmFyIF92bSA9IHRoaXNcbiAgdmFyIF9oID0gX3ZtLiRjcmVhdGVFbGVtZW50XG4gIHZhciBfYyA9IF92bS5fc2VsZi5fYyB8fCBfaFxuICByZXR1cm4gX2MoXG4gICAgXCJzcGFuXCIsXG4gICAgeyBzdGF0aWNDbGFzczogXCJ0LXZ1ZS1sYnRuLWdycFwiIH0sXG4gICAgX3ZtLl9sKF92bS5idXR0b25zLCBmdW5jdGlvbihiLCBpKSB7XG4gICAgICByZXR1cm4gX2MoXCJsZWdlbmQtYnV0dG9uXCIsIHtcbiAgICAgICAga2V5OiBpLFxuICAgICAgICBhdHRyczoge1xuICAgICAgICAgIGlkOiBiLm5hbWUgfHwgYixcbiAgICAgICAgICB0dl9pZDogX3ZtLnR2X2lkLFxuICAgICAgICAgIG92X2lkOiBfdm0ub3ZfaWQsXG4gICAgICAgICAgZ3JpZF9pZDogX3ZtLmdyaWRfaWQsXG4gICAgICAgICAgaW5kZXg6IF92bS5pbmRleCxcbiAgICAgICAgICBkaXNwbGF5OiBfdm0uZGlzcGxheSxcbiAgICAgICAgICBpY29uOiBiLmljb24sXG4gICAgICAgICAgY29uZmlnOiBfdm0uY29uZmlnXG4gICAgICAgIH0sXG4gICAgICAgIG9uOiB7IFwibGVnZW5kLWJ1dHRvbi1jbGlja1wiOiBfdm0uYnV0dG9uX2NsaWNrIH1cbiAgICAgIH0pXG4gICAgfSksXG4gICAgMVxuICApXG59XG52YXIgQnV0dG9uR3JvdXB2dWVfdHlwZV90ZW1wbGF0ZV9pZF82ZjgyNjQyNl9zdGF0aWNSZW5kZXJGbnMgPSBbXVxuQnV0dG9uR3JvdXB2dWVfdHlwZV90ZW1wbGF0ZV9pZF82ZjgyNjQyNl9yZW5kZXIuX3dpdGhTdHJpcHBlZCA9IHRydWVcblxuXG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvY29tcG9uZW50cy9CdXR0b25Hcm91cC52dWU/dnVlJnR5cGU9dGVtcGxhdGUmaWQ9NmY4MjY0MjYmXG5cbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9sb2FkZXJzL3RlbXBsYXRlTG9hZGVyLmpzPz92dWUtbG9hZGVyLW9wdGlvbnMhLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvaW5kZXguanM/P3Z1ZS1sb2FkZXItb3B0aW9ucyEuL3NyYy9jb21wb25lbnRzL0xlZ2VuZEJ1dHRvbi52dWU/dnVlJnR5cGU9dGVtcGxhdGUmaWQ9MWFkODczNjImXG52YXIgTGVnZW5kQnV0dG9udnVlX3R5cGVfdGVtcGxhdGVfaWRfMWFkODczNjJfcmVuZGVyID0gZnVuY3Rpb24oKSB7XG4gIHZhciBfdm0gPSB0aGlzXG4gIHZhciBfaCA9IF92bS4kY3JlYXRlRWxlbWVudFxuICB2YXIgX2MgPSBfdm0uX3NlbGYuX2MgfHwgX2hcbiAgcmV0dXJuIF9jKFwiaW1nXCIsIHtcbiAgICBzdGF0aWNDbGFzczogXCJ0LXZ1ZS1sYnRuXCIsXG4gICAgc3R5bGU6IHtcbiAgICAgIHdpZHRoOiBfdm0uY29uZmlnLkxfQlROX1NJWkUgKyBcInB4XCIsXG4gICAgICBoZWlnaHQ6IF92bS5jb25maWcuTF9CVE5fU0laRSArIFwicHhcIixcbiAgICAgIG1hcmdpbjogX3ZtLmNvbmZpZy5MX0JUTl9NQVJHSU5cbiAgICB9LFxuICAgIGF0dHJzOiB7IHNyYzogX3ZtLmJhc2U2NCwgaWQ6IF92bS51dWlkIH0sXG4gICAgb246IHsgY2xpY2s6IF92bS5vbmNsaWNrIH1cbiAgfSlcbn1cbnZhciBMZWdlbmRCdXR0b252dWVfdHlwZV90ZW1wbGF0ZV9pZF8xYWQ4NzM2Ml9zdGF0aWNSZW5kZXJGbnMgPSBbXVxuTGVnZW5kQnV0dG9udnVlX3R5cGVfdGVtcGxhdGVfaWRfMWFkODczNjJfcmVuZGVyLl93aXRoU3RyaXBwZWQgPSB0cnVlXG5cblxuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL2NvbXBvbmVudHMvTGVnZW5kQnV0dG9uLnZ1ZT92dWUmdHlwZT10ZW1wbGF0ZSZpZD0xYWQ4NzM2MiZcblxuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vbm9kZV9tb2R1bGVzL2JhYmVsLWxvYWRlci9saWIvaW5kZXguanMhLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvaW5kZXguanM/P3Z1ZS1sb2FkZXItb3B0aW9ucyEuL3NyYy9jb21wb25lbnRzL0xlZ2VuZEJ1dHRvbi52dWU/dnVlJnR5cGU9c2NyaXB0Jmxhbmc9anMmXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG5cbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gY29uc3QgTGVnZW5kQnV0dG9udnVlX3R5cGVfc2NyaXB0X2xhbmdfanNfID0gKHtcbiAgbmFtZTogJ0xlZ2VuZEJ1dHRvbicsXG4gIHByb3BzOiBbJ2lkJywgJ3R2X2lkJywgJ2dyaWRfaWQnLCAnb3ZfaWQnLCAnaW5kZXgnLCAnZGlzcGxheScsICdpY29uJywgJ2NvbmZpZyddLFxuICBtb3VudGVkOiBmdW5jdGlvbiBtb3VudGVkKCkge30sXG4gIGNvbXB1dGVkOiB7XG4gICAgYmFzZTY0OiBmdW5jdGlvbiBiYXNlNjQoKSB7XG4gICAgICByZXR1cm4gdGhpcy5pY29uIHx8IGljb25zX25hbWVzcGFjZU9iamVjdFt0aGlzLmZpbGVfbmFtZV07XG4gICAgfSxcbiAgICBmaWxlX25hbWU6IGZ1bmN0aW9uIGZpbGVfbmFtZSgpIHtcbiAgICAgIHZhciBpZCA9IHRoaXMuJHByb3BzLmlkO1xuXG4gICAgICBpZiAodGhpcy4kcHJvcHMuaWQgPT09ICdkaXNwbGF5Jykge1xuICAgICAgICBpZCA9IHRoaXMuJHByb3BzLmRpc3BsYXkgPyAnZGlzcGxheV9vbicgOiAnZGlzcGxheV9vZmYnO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gaWQgKyAnLnBuZyc7XG4gICAgfSxcbiAgICB1dWlkOiBmdW5jdGlvbiB1dWlkKCkge1xuICAgICAgdmFyIHR2ID0gdGhpcy4kcHJvcHMudHZfaWQ7XG4gICAgICB2YXIgZ3IgPSB0aGlzLiRwcm9wcy5ncmlkX2lkO1xuICAgICAgdmFyIG92ID0gdGhpcy4kcHJvcHMub3ZfaWQ7XG4gICAgICByZXR1cm4gXCJcIi5jb25jYXQodHYsIFwiLWJ0bi1nXCIpLmNvbmNhdChnciwgXCItXCIpLmNvbmNhdChvdik7XG4gICAgfSxcbiAgICBkYXRhX3R5cGU6IGZ1bmN0aW9uIGRhdGFfdHlwZSgpIHtcbiAgICAgIHJldHVybiB0aGlzLiRwcm9wcy5ncmlkX2lkID09PSAwID8gXCJvbmNoYXJ0XCIgOiBcIm9mZmNoYXJ0XCI7XG4gICAgfSxcbiAgICBkYXRhX2luZGV4OiBmdW5jdGlvbiBkYXRhX2luZGV4KCkge1xuICAgICAgcmV0dXJuIHRoaXMuJHByb3BzLmluZGV4O1xuICAgIH1cbiAgfSxcbiAgbWV0aG9kczoge1xuICAgIG9uY2xpY2s6IGZ1bmN0aW9uIG9uY2xpY2soKSB7XG4gICAgICB0aGlzLiRlbWl0KCdsZWdlbmQtYnV0dG9uLWNsaWNrJywge1xuICAgICAgICBidXR0b246IHRoaXMuJHByb3BzLmlkLFxuICAgICAgICB0eXBlOiB0aGlzLmRhdGFfdHlwZSxcbiAgICAgICAgZGF0YUluZGV4OiB0aGlzLmRhdGFfaW5kZXgsXG4gICAgICAgIGdyaWQ6IHRoaXMuJHByb3BzLmdyaWRfaWQsXG4gICAgICAgIG92ZXJsYXk6IHRoaXMuJHByb3BzLm92X2lkXG4gICAgICB9KTtcbiAgICB9XG4gIH1cbn0pO1xuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL2NvbXBvbmVudHMvTGVnZW5kQnV0dG9uLnZ1ZT92dWUmdHlwZT1zY3JpcHQmbGFuZz1qcyZcbiAvKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIGNvbnN0IGNvbXBvbmVudHNfTGVnZW5kQnV0dG9udnVlX3R5cGVfc2NyaXB0X2xhbmdfanNfID0gKExlZ2VuZEJ1dHRvbnZ1ZV90eXBlX3NjcmlwdF9sYW5nX2pzXyk7IFxuLy8gRVhURVJOQUwgTU9EVUxFOiAuL25vZGVfbW9kdWxlcy92dWUtc3R5bGUtbG9hZGVyL2luZGV4LmpzIS4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvZGlzdC9janMuanMhLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvbG9hZGVycy9zdHlsZVBvc3RMb2FkZXIuanMhLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvaW5kZXguanM/P3Z1ZS1sb2FkZXItb3B0aW9ucyEuL3NyYy9jb21wb25lbnRzL0xlZ2VuZEJ1dHRvbi52dWU/dnVlJnR5cGU9c3R5bGUmaW5kZXg9MCZsYW5nPWNzcyZcbnZhciBMZWdlbmRCdXR0b252dWVfdHlwZV9zdHlsZV9pbmRleF8wX2xhbmdfY3NzXyA9IF9fd2VicGFja19yZXF1aXJlX18oMTY5KTtcbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9jb21wb25lbnRzL0xlZ2VuZEJ1dHRvbi52dWU/dnVlJnR5cGU9c3R5bGUmaW5kZXg9MCZsYW5nPWNzcyZcblxuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL2NvbXBvbmVudHMvTGVnZW5kQnV0dG9uLnZ1ZVxuXG5cblxuO1xuXG5cbi8qIG5vcm1hbGl6ZSBjb21wb25lbnQgKi9cblxudmFyIExlZ2VuZEJ1dHRvbl9jb21wb25lbnQgPSBub3JtYWxpemVDb21wb25lbnQoXG4gIGNvbXBvbmVudHNfTGVnZW5kQnV0dG9udnVlX3R5cGVfc2NyaXB0X2xhbmdfanNfLFxuICBMZWdlbmRCdXR0b252dWVfdHlwZV90ZW1wbGF0ZV9pZF8xYWQ4NzM2Ml9yZW5kZXIsXG4gIExlZ2VuZEJ1dHRvbnZ1ZV90eXBlX3RlbXBsYXRlX2lkXzFhZDg3MzYyX3N0YXRpY1JlbmRlckZucyxcbiAgZmFsc2UsXG4gIG51bGwsXG4gIG51bGwsXG4gIG51bGxcbiAgXG4pXG5cbi8qIGhvdCByZWxvYWQgKi9cbmlmIChmYWxzZSkgeyB2YXIgTGVnZW5kQnV0dG9uX2FwaTsgfVxuTGVnZW5kQnV0dG9uX2NvbXBvbmVudC5vcHRpb25zLl9fZmlsZSA9IFwic3JjL2NvbXBvbmVudHMvTGVnZW5kQnV0dG9uLnZ1ZVwiXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIGNvbnN0IExlZ2VuZEJ1dHRvbiA9IChMZWdlbmRCdXR0b25fY29tcG9uZW50LmV4cG9ydHMpO1xuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vbm9kZV9tb2R1bGVzL2JhYmVsLWxvYWRlci9saWIvaW5kZXguanMhLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvaW5kZXguanM/P3Z1ZS1sb2FkZXItb3B0aW9ucyEuL3NyYy9jb21wb25lbnRzL0J1dHRvbkdyb3VwLnZ1ZT92dWUmdHlwZT1zY3JpcHQmbGFuZz1qcyZcbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIGNvbnN0IEJ1dHRvbkdyb3VwdnVlX3R5cGVfc2NyaXB0X2xhbmdfanNfID0gKHtcbiAgbmFtZTogJ0J1dHRvbkdyb3VwJyxcbiAgcHJvcHM6IFsnYnV0dG9ucycsICd0dl9pZCcsICdvdl9pZCcsICdncmlkX2lkJywgJ2luZGV4JywgJ2Rpc3BsYXknLCAnY29uZmlnJ10sXG4gIGNvbXBvbmVudHM6IHtcbiAgICBMZWdlbmRCdXR0b246IExlZ2VuZEJ1dHRvblxuICB9LFxuICBtZXRob2RzOiB7XG4gICAgYnV0dG9uX2NsaWNrOiBmdW5jdGlvbiBidXR0b25fY2xpY2soZXZlbnQpIHtcbiAgICAgIHRoaXMuJGVtaXQoJ2xlZ2VuZC1idXR0b24tY2xpY2snLCBldmVudCk7XG4gICAgfVxuICB9XG59KTtcbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9jb21wb25lbnRzL0J1dHRvbkdyb3VwLnZ1ZT92dWUmdHlwZT1zY3JpcHQmbGFuZz1qcyZcbiAvKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIGNvbnN0IGNvbXBvbmVudHNfQnV0dG9uR3JvdXB2dWVfdHlwZV9zY3JpcHRfbGFuZ19qc18gPSAoQnV0dG9uR3JvdXB2dWVfdHlwZV9zY3JpcHRfbGFuZ19qc18pOyBcbi8vIEVYVEVSTkFMIE1PRFVMRTogLi9ub2RlX21vZHVsZXMvdnVlLXN0eWxlLWxvYWRlci9pbmRleC5qcyEuL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2Rpc3QvY2pzLmpzIS4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL2xvYWRlcnMvc3R5bGVQb3N0TG9hZGVyLmpzIS4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL2luZGV4LmpzPz92dWUtbG9hZGVyLW9wdGlvbnMhLi9zcmMvY29tcG9uZW50cy9CdXR0b25Hcm91cC52dWU/dnVlJnR5cGU9c3R5bGUmaW5kZXg9MCZsYW5nPWNzcyZcbnZhciBCdXR0b25Hcm91cHZ1ZV90eXBlX3N0eWxlX2luZGV4XzBfbGFuZ19jc3NfID0gX193ZWJwYWNrX3JlcXVpcmVfXyg4ODYpO1xuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL2NvbXBvbmVudHMvQnV0dG9uR3JvdXAudnVlP3Z1ZSZ0eXBlPXN0eWxlJmluZGV4PTAmbGFuZz1jc3MmXG5cbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9jb21wb25lbnRzL0J1dHRvbkdyb3VwLnZ1ZVxuXG5cblxuO1xuXG5cbi8qIG5vcm1hbGl6ZSBjb21wb25lbnQgKi9cblxudmFyIEJ1dHRvbkdyb3VwX2NvbXBvbmVudCA9IG5vcm1hbGl6ZUNvbXBvbmVudChcbiAgY29tcG9uZW50c19CdXR0b25Hcm91cHZ1ZV90eXBlX3NjcmlwdF9sYW5nX2pzXyxcbiAgQnV0dG9uR3JvdXB2dWVfdHlwZV90ZW1wbGF0ZV9pZF82ZjgyNjQyNl9yZW5kZXIsXG4gIEJ1dHRvbkdyb3VwdnVlX3R5cGVfdGVtcGxhdGVfaWRfNmY4MjY0MjZfc3RhdGljUmVuZGVyRm5zLFxuICBmYWxzZSxcbiAgbnVsbCxcbiAgbnVsbCxcbiAgbnVsbFxuICBcbilcblxuLyogaG90IHJlbG9hZCAqL1xuaWYgKGZhbHNlKSB7IHZhciBCdXR0b25Hcm91cF9hcGk7IH1cbkJ1dHRvbkdyb3VwX2NvbXBvbmVudC5vcHRpb25zLl9fZmlsZSA9IFwic3JjL2NvbXBvbmVudHMvQnV0dG9uR3JvdXAudnVlXCJcbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gY29uc3QgQnV0dG9uR3JvdXAgPSAoQnV0dG9uR3JvdXBfY29tcG9uZW50LmV4cG9ydHMpO1xuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL2xvYWRlcnMvdGVtcGxhdGVMb2FkZXIuanM/P3Z1ZS1sb2FkZXItb3B0aW9ucyEuL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9pbmRleC5qcz8/dnVlLWxvYWRlci1vcHRpb25zIS4vc3JjL2NvbXBvbmVudHMvU3Bpbm5lci52dWU/dnVlJnR5cGU9dGVtcGxhdGUmaWQ9Mzk0MzJmOTkmXG52YXIgU3Bpbm5lcnZ1ZV90eXBlX3RlbXBsYXRlX2lkXzM5NDMyZjk5X3JlbmRlciA9IGZ1bmN0aW9uKCkge1xuICB2YXIgX3ZtID0gdGhpc1xuICB2YXIgX2ggPSBfdm0uJGNyZWF0ZUVsZW1lbnRcbiAgdmFyIF9jID0gX3ZtLl9zZWxmLl9jIHx8IF9oXG4gIHJldHVybiBfYyhcbiAgICBcImRpdlwiLFxuICAgIHsgc3RhdGljQ2xhc3M6IFwidHZqcy1zcGlubmVyXCIgfSxcbiAgICBfdm0uX2woNCwgZnVuY3Rpb24oaSkge1xuICAgICAgcmV0dXJuIF9jKFwiZGl2XCIsIHsga2V5OiBpLCBzdHlsZTogeyBiYWNrZ3JvdW5kOiBfdm0uY29sb3JzLnRleHQgfSB9KVxuICAgIH0pLFxuICAgIDBcbiAgKVxufVxudmFyIFNwaW5uZXJ2dWVfdHlwZV90ZW1wbGF0ZV9pZF8zOTQzMmY5OV9zdGF0aWNSZW5kZXJGbnMgPSBbXVxuU3Bpbm5lcnZ1ZV90eXBlX3RlbXBsYXRlX2lkXzM5NDMyZjk5X3JlbmRlci5fd2l0aFN0cmlwcGVkID0gdHJ1ZVxuXG5cbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9jb21wb25lbnRzL1NwaW5uZXIudnVlP3Z1ZSZ0eXBlPXRlbXBsYXRlJmlkPTM5NDMyZjk5JlxuXG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9ub2RlX21vZHVsZXMvYmFiZWwtbG9hZGVyL2xpYi9pbmRleC5qcyEuL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9pbmRleC5qcz8/dnVlLWxvYWRlci1vcHRpb25zIS4vc3JjL2NvbXBvbmVudHMvU3Bpbm5lci52dWU/dnVlJnR5cGU9c2NyaXB0Jmxhbmc9anMmXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIGNvbnN0IFNwaW5uZXJ2dWVfdHlwZV9zY3JpcHRfbGFuZ19qc18gPSAoe1xuICBuYW1lOiAnU3Bpbm5lcicsXG4gIHByb3BzOiBbJ2NvbG9ycyddXG59KTtcbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9jb21wb25lbnRzL1NwaW5uZXIudnVlP3Z1ZSZ0eXBlPXNjcmlwdCZsYW5nPWpzJlxuIC8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gY29uc3QgY29tcG9uZW50c19TcGlubmVydnVlX3R5cGVfc2NyaXB0X2xhbmdfanNfID0gKFNwaW5uZXJ2dWVfdHlwZV9zY3JpcHRfbGFuZ19qc18pOyBcbi8vIEVYVEVSTkFMIE1PRFVMRTogLi9ub2RlX21vZHVsZXMvdnVlLXN0eWxlLWxvYWRlci9pbmRleC5qcyEuL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2Rpc3QvY2pzLmpzIS4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL2xvYWRlcnMvc3R5bGVQb3N0TG9hZGVyLmpzIS4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL2luZGV4LmpzPz92dWUtbG9hZGVyLW9wdGlvbnMhLi9zcmMvY29tcG9uZW50cy9TcGlubmVyLnZ1ZT92dWUmdHlwZT1zdHlsZSZpbmRleD0wJmxhbmc9Y3NzJlxudmFyIFNwaW5uZXJ2dWVfdHlwZV9zdHlsZV9pbmRleF8wX2xhbmdfY3NzXyA9IF9fd2VicGFja19yZXF1aXJlX18oMzcyKTtcbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9jb21wb25lbnRzL1NwaW5uZXIudnVlP3Z1ZSZ0eXBlPXN0eWxlJmluZGV4PTAmbGFuZz1jc3MmXG5cbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9jb21wb25lbnRzL1NwaW5uZXIudnVlXG5cblxuXG47XG5cblxuLyogbm9ybWFsaXplIGNvbXBvbmVudCAqL1xuXG52YXIgU3Bpbm5lcl9jb21wb25lbnQgPSBub3JtYWxpemVDb21wb25lbnQoXG4gIGNvbXBvbmVudHNfU3Bpbm5lcnZ1ZV90eXBlX3NjcmlwdF9sYW5nX2pzXyxcbiAgU3Bpbm5lcnZ1ZV90eXBlX3RlbXBsYXRlX2lkXzM5NDMyZjk5X3JlbmRlcixcbiAgU3Bpbm5lcnZ1ZV90eXBlX3RlbXBsYXRlX2lkXzM5NDMyZjk5X3N0YXRpY1JlbmRlckZucyxcbiAgZmFsc2UsXG4gIG51bGwsXG4gIG51bGwsXG4gIG51bGxcbiAgXG4pXG5cbi8qIGhvdCByZWxvYWQgKi9cbmlmIChmYWxzZSkgeyB2YXIgU3Bpbm5lcl9hcGk7IH1cblNwaW5uZXJfY29tcG9uZW50Lm9wdGlvbnMuX19maWxlID0gXCJzcmMvY29tcG9uZW50cy9TcGlubmVyLnZ1ZVwiXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIGNvbnN0IFNwaW5uZXIgPSAoU3Bpbm5lcl9jb21wb25lbnQuZXhwb3J0cyk7XG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9ub2RlX21vZHVsZXMvYmFiZWwtbG9hZGVyL2xpYi9pbmRleC5qcyEuL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9pbmRleC5qcz8/dnVlLWxvYWRlci1vcHRpb25zIS4vc3JjL2NvbXBvbmVudHMvTGVnZW5kLnZ1ZT92dWUmdHlwZT1zY3JpcHQmbGFuZz1qcyZcbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cblxuXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIGNvbnN0IExlZ2VuZHZ1ZV90eXBlX3NjcmlwdF9sYW5nX2pzXyA9ICh7XG4gIG5hbWU6ICdDaGFydExlZ2VuZCcsXG4gIHByb3BzOiBbJ2NvbW1vbicsICd2YWx1ZXMnLCAnZ3JpZF9pZCcsICdtZXRhX3Byb3BzJ10sXG4gIGNvbXBvbmVudHM6IHtcbiAgICBCdXR0b25Hcm91cDogQnV0dG9uR3JvdXAsXG4gICAgU3Bpbm5lcjogU3Bpbm5lclxuICB9LFxuICBjb21wdXRlZDoge1xuICAgIG9obGN2OiBmdW5jdGlvbiBvaGxjdigpIHtcbiAgICAgIGlmICghdGhpcy4kcHJvcHMudmFsdWVzIHx8ICF0aGlzLiRwcm9wcy52YWx1ZXMub2hsY3YpIHtcbiAgICAgICAgcmV0dXJuIEFycmF5KDYpLmZpbGwoJ24vYScpO1xuICAgICAgfVxuXG4gICAgICB2YXIgcHJlYyA9IHRoaXMubGF5b3V0LnByZWM7IC8vIFRPRE86IG1haW4gdGhlIG1haW4gbGVnZW5kIG1vcmUgY3VzdG9taXphYmxlXG5cbiAgICAgIHZhciBpZCA9IHRoaXMubWFpbl90eXBlICsgJ18wJztcbiAgICAgIHZhciBtZXRhID0gdGhpcy4kcHJvcHMubWV0YV9wcm9wc1tpZF0gfHwge307XG5cbiAgICAgIGlmIChtZXRhLmxlZ2VuZCkge1xuICAgICAgICByZXR1cm4gKG1ldGEubGVnZW5kKCkgfHwgW10pLm1hcChmdW5jdGlvbiAoeCkge1xuICAgICAgICAgIHJldHVybiB4LnZhbHVlO1xuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIFt0aGlzLiRwcm9wcy52YWx1ZXMub2hsY3ZbMV0udG9GaXhlZChwcmVjKSwgdGhpcy4kcHJvcHMudmFsdWVzLm9obGN2WzJdLnRvRml4ZWQocHJlYyksIHRoaXMuJHByb3BzLnZhbHVlcy5vaGxjdlszXS50b0ZpeGVkKHByZWMpLCB0aGlzLiRwcm9wcy52YWx1ZXMub2hsY3ZbNF0udG9GaXhlZChwcmVjKSwgdGhpcy4kcHJvcHMudmFsdWVzLm9obGN2WzVdID8gdGhpcy4kcHJvcHMudmFsdWVzLm9obGN2WzVdLnRvRml4ZWQoMikgOiAnbi9hJ107XG4gICAgfSxcbiAgICAvLyBUT0RPOiBhZGQgc3VwcG9ydCBmb3IgeyBncmlkOiB7IGlkIDogTiB9fVxuICAgIGluZGljYXRvcnM6IGZ1bmN0aW9uIGluZGljYXRvcnMoKSB7XG4gICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgICB2YXIgdmFsdWVzID0gdGhpcy4kcHJvcHMudmFsdWVzO1xuICAgICAgdmFyIGYgPSB0aGlzLmZvcm1hdDtcbiAgICAgIHZhciB0eXBlcyA9IHt9O1xuICAgICAgcmV0dXJuIHRoaXMuanNvbl9kYXRhLmZpbHRlcihmdW5jdGlvbiAoeCkge1xuICAgICAgICByZXR1cm4geC5zZXR0aW5ncy5sZWdlbmQgIT09IGZhbHNlICYmICF4Lm1haW47XG4gICAgICB9KS5tYXAoZnVuY3Rpb24gKHgpIHtcbiAgICAgICAgaWYgKCEoeC50eXBlIGluIHR5cGVzKSkgdHlwZXNbeC50eXBlXSA9IDA7XG4gICAgICAgIHZhciBpZCA9IHgudHlwZSArIFwiX1wiLmNvbmNhdCh0eXBlc1t4LnR5cGVdKyspO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHY6ICdkaXNwbGF5JyBpbiB4LnNldHRpbmdzID8geC5zZXR0aW5ncy5kaXNwbGF5IDogdHJ1ZSxcbiAgICAgICAgICBuYW1lOiB4Lm5hbWUgfHwgaWQsXG4gICAgICAgICAgaW5kZXg6IChfdGhpcy5vZmZfZGF0YSB8fCBfdGhpcy5qc29uX2RhdGEpLmluZGV4T2YoeCksXG4gICAgICAgICAgaWQ6IGlkLFxuICAgICAgICAgIHZhbHVlczogdmFsdWVzID8gZihpZCwgdmFsdWVzKSA6IF90aGlzLm5fYSgxKSxcbiAgICAgICAgICB1bms6ICEoaWQgaW4gKF90aGlzLiRwcm9wcy5tZXRhX3Byb3BzIHx8IHt9KSksXG4gICAgICAgICAgbG9hZGluZzogeC5sb2FkaW5nXG4gICAgICAgIH07XG4gICAgICB9KTtcbiAgICB9LFxuICAgIGNhbGNfc3R5bGU6IGZ1bmN0aW9uIGNhbGNfc3R5bGUoKSB7XG4gICAgICB2YXIgdG9wID0gdGhpcy5sYXlvdXQuaGVpZ2h0ID4gMTUwID8gMTAgOiA1O1xuICAgICAgdmFyIGdyaWRzID0gdGhpcy4kcHJvcHMuY29tbW9uLmxheW91dC5ncmlkcztcbiAgICAgIHZhciB3ID0gZ3JpZHNbMF0gPyBncmlkc1swXS53aWR0aCA6IHVuZGVmaW5lZDtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHRvcDogXCJcIi5jb25jYXQodGhpcy5sYXlvdXQub2Zmc2V0ICsgdG9wLCBcInB4XCIpLFxuICAgICAgICB3aWR0aDogXCJcIi5jb25jYXQodyAtIDIwLCBcInB4XCIpXG4gICAgICB9O1xuICAgIH0sXG4gICAgbGF5b3V0OiBmdW5jdGlvbiBsYXlvdXQoKSB7XG4gICAgICB2YXIgaWQgPSB0aGlzLiRwcm9wcy5ncmlkX2lkO1xuICAgICAgcmV0dXJuIHRoaXMuJHByb3BzLmNvbW1vbi5sYXlvdXQuZ3JpZHNbaWRdO1xuICAgIH0sXG4gICAganNvbl9kYXRhOiBmdW5jdGlvbiBqc29uX2RhdGEoKSB7XG4gICAgICByZXR1cm4gdGhpcy4kcHJvcHMuY29tbW9uLmRhdGE7XG4gICAgfSxcbiAgICBvZmZfZGF0YTogZnVuY3Rpb24gb2ZmX2RhdGEoKSB7XG4gICAgICByZXR1cm4gdGhpcy4kcHJvcHMuY29tbW9uLm9mZmNoYXJ0O1xuICAgIH0sXG4gICAgbWFpbl90eXBlOiBmdW5jdGlvbiBtYWluX3R5cGUoKSB7XG4gICAgICB2YXIgZiA9IHRoaXMuY29tbW9uLmRhdGEuZmluZChmdW5jdGlvbiAoeCkge1xuICAgICAgICByZXR1cm4geC5tYWluO1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gZiA/IGYudHlwZSA6IHVuZGVmaW5lZDtcbiAgICB9LFxuICAgIHNob3dfdmFsdWVzOiBmdW5jdGlvbiBzaG93X3ZhbHVlcygpIHtcbiAgICAgIHJldHVybiB0aGlzLmNvbW1vbi5jdXJzb3IubW9kZSAhPT0gJ2V4cGxvcmUnO1xuICAgIH1cbiAgfSxcbiAgbWV0aG9kczoge1xuICAgIGZvcm1hdDogZnVuY3Rpb24gZm9ybWF0KGlkLCB2YWx1ZXMpIHtcbiAgICAgIHZhciBtZXRhID0gdGhpcy4kcHJvcHMubWV0YV9wcm9wc1tpZF0gfHwge307IC8vIE1hdGNoZXMgT3ZlcmxheS5kYXRhX2NvbG9ycyB3aXRoIHRoZSBkYXRhIHZhbHVlc1xuICAgICAgLy8gKHNlZSBTcGxpbmUudnVlKVxuXG4gICAgICBpZiAoIXZhbHVlc1tpZF0pIHJldHVybiB0aGlzLm5fYSgxKTsgLy8gQ3VzdG9tIGZvcm1hdHRlclxuXG4gICAgICBpZiAobWV0YS5sZWdlbmQpIHJldHVybiBtZXRhLmxlZ2VuZCh2YWx1ZXNbaWRdKTtcbiAgICAgIHJldHVybiB2YWx1ZXNbaWRdLnNsaWNlKDEpLm1hcChmdW5jdGlvbiAoeCwgaSkge1xuICAgICAgICB2YXIgY3MgPSBtZXRhLmRhdGFfY29sb3JzID8gbWV0YS5kYXRhX2NvbG9ycygpIDogW107XG5cbiAgICAgICAgaWYgKHR5cGVvZiB4ID09ICdudW1iZXInKSB7XG4gICAgICAgICAgLy8gU2hvdyA4IGRpZ2l0cyBmb3Igc21hbGwgdmFsdWVzXG4gICAgICAgICAgeCA9IHgudG9GaXhlZChNYXRoLmFicyh4KSA+IDAuMDAxID8gNCA6IDgpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICB2YWx1ZTogeCxcbiAgICAgICAgICBjb2xvcjogY3MgPyBjc1tpICUgY3MubGVuZ3RoXSA6IHVuZGVmaW5lZFxuICAgICAgICB9O1xuICAgICAgfSk7XG4gICAgfSxcbiAgICBuX2E6IGZ1bmN0aW9uIG5fYShsZW4pIHtcbiAgICAgIHJldHVybiBBcnJheShsZW4pLmZpbGwoe1xuICAgICAgICB2YWx1ZTogJ24vYSdcbiAgICAgIH0pO1xuICAgIH0sXG4gICAgYnV0dG9uX2NsaWNrOiBmdW5jdGlvbiBidXR0b25fY2xpY2soZXZlbnQpIHtcbiAgICAgIHRoaXMuJGVtaXQoJ2xlZ2VuZC1idXR0b24tY2xpY2snLCBldmVudCk7XG4gICAgfVxuICB9XG59KTtcbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9jb21wb25lbnRzL0xlZ2VuZC52dWU/dnVlJnR5cGU9c2NyaXB0Jmxhbmc9anMmXG4gLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyBjb25zdCBjb21wb25lbnRzX0xlZ2VuZHZ1ZV90eXBlX3NjcmlwdF9sYW5nX2pzXyA9IChMZWdlbmR2dWVfdHlwZV9zY3JpcHRfbGFuZ19qc18pOyBcbi8vIEVYVEVSTkFMIE1PRFVMRTogLi9ub2RlX21vZHVsZXMvdnVlLXN0eWxlLWxvYWRlci9pbmRleC5qcyEuL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2Rpc3QvY2pzLmpzIS4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL2xvYWRlcnMvc3R5bGVQb3N0TG9hZGVyLmpzIS4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL2luZGV4LmpzPz92dWUtbG9hZGVyLW9wdGlvbnMhLi9zcmMvY29tcG9uZW50cy9MZWdlbmQudnVlP3Z1ZSZ0eXBlPXN0eWxlJmluZGV4PTAmbGFuZz1jc3MmXG52YXIgTGVnZW5kdnVlX3R5cGVfc3R5bGVfaW5kZXhfMF9sYW5nX2Nzc18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDYwMCk7XG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvY29tcG9uZW50cy9MZWdlbmQudnVlP3Z1ZSZ0eXBlPXN0eWxlJmluZGV4PTAmbGFuZz1jc3MmXG5cbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9jb21wb25lbnRzL0xlZ2VuZC52dWVcblxuXG5cbjtcblxuXG4vKiBub3JtYWxpemUgY29tcG9uZW50ICovXG5cbnZhciBMZWdlbmRfY29tcG9uZW50ID0gbm9ybWFsaXplQ29tcG9uZW50KFxuICBjb21wb25lbnRzX0xlZ2VuZHZ1ZV90eXBlX3NjcmlwdF9sYW5nX2pzXyxcbiAgTGVnZW5kdnVlX3R5cGVfdGVtcGxhdGVfaWRfMzQ3MjQ4ODZfcmVuZGVyLFxuICBMZWdlbmR2dWVfdHlwZV90ZW1wbGF0ZV9pZF8zNDcyNDg4Nl9zdGF0aWNSZW5kZXJGbnMsXG4gIGZhbHNlLFxuICBudWxsLFxuICBudWxsLFxuICBudWxsXG4gIFxuKVxuXG4vKiBob3QgcmVsb2FkICovXG5pZiAoZmFsc2UpIHsgdmFyIExlZ2VuZF9hcGk7IH1cbkxlZ2VuZF9jb21wb25lbnQub3B0aW9ucy5fX2ZpbGUgPSBcInNyYy9jb21wb25lbnRzL0xlZ2VuZC52dWVcIlxuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyBjb25zdCBMZWdlbmQgPSAoTGVnZW5kX2NvbXBvbmVudC5leHBvcnRzKTtcbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9taXhpbnMvc2hhZGVycy5qc1xuZnVuY3Rpb24gc2hhZGVyc19jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyKG8sIGFsbG93QXJyYXlMaWtlKSB7IHZhciBpdDsgaWYgKHR5cGVvZiBTeW1ib2wgPT09IFwidW5kZWZpbmVkXCIgfHwgb1tTeW1ib2wuaXRlcmF0b3JdID09IG51bGwpIHsgaWYgKEFycmF5LmlzQXJyYXkobykgfHwgKGl0ID0gc2hhZGVyc191bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheShvKSkgfHwgYWxsb3dBcnJheUxpa2UgJiYgbyAmJiB0eXBlb2Ygby5sZW5ndGggPT09IFwibnVtYmVyXCIpIHsgaWYgKGl0KSBvID0gaXQ7IHZhciBpID0gMDsgdmFyIEYgPSBmdW5jdGlvbiBGKCkge307IHJldHVybiB7IHM6IEYsIG46IGZ1bmN0aW9uIG4oKSB7IGlmIChpID49IG8ubGVuZ3RoKSByZXR1cm4geyBkb25lOiB0cnVlIH07IHJldHVybiB7IGRvbmU6IGZhbHNlLCB2YWx1ZTogb1tpKytdIH07IH0sIGU6IGZ1bmN0aW9uIGUoX2UpIHsgdGhyb3cgX2U7IH0sIGY6IEYgfTsgfSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiSW52YWxpZCBhdHRlbXB0IHRvIGl0ZXJhdGUgbm9uLWl0ZXJhYmxlIGluc3RhbmNlLlxcbkluIG9yZGVyIHRvIGJlIGl0ZXJhYmxlLCBub24tYXJyYXkgb2JqZWN0cyBtdXN0IGhhdmUgYSBbU3ltYm9sLml0ZXJhdG9yXSgpIG1ldGhvZC5cIik7IH0gdmFyIG5vcm1hbENvbXBsZXRpb24gPSB0cnVlLCBkaWRFcnIgPSBmYWxzZSwgZXJyOyByZXR1cm4geyBzOiBmdW5jdGlvbiBzKCkgeyBpdCA9IG9bU3ltYm9sLml0ZXJhdG9yXSgpOyB9LCBuOiBmdW5jdGlvbiBuKCkgeyB2YXIgc3RlcCA9IGl0Lm5leHQoKTsgbm9ybWFsQ29tcGxldGlvbiA9IHN0ZXAuZG9uZTsgcmV0dXJuIHN0ZXA7IH0sIGU6IGZ1bmN0aW9uIGUoX2UyKSB7IGRpZEVyciA9IHRydWU7IGVyciA9IF9lMjsgfSwgZjogZnVuY3Rpb24gZigpIHsgdHJ5IHsgaWYgKCFub3JtYWxDb21wbGV0aW9uICYmIGl0W1wicmV0dXJuXCJdICE9IG51bGwpIGl0W1wicmV0dXJuXCJdKCk7IH0gZmluYWxseSB7IGlmIChkaWRFcnIpIHRocm93IGVycjsgfSB9IH07IH1cblxuZnVuY3Rpb24gc2hhZGVyc191bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheShvLCBtaW5MZW4pIHsgaWYgKCFvKSByZXR1cm47IGlmICh0eXBlb2YgbyA9PT0gXCJzdHJpbmdcIikgcmV0dXJuIHNoYWRlcnNfYXJyYXlMaWtlVG9BcnJheShvLCBtaW5MZW4pOyB2YXIgbiA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvKS5zbGljZSg4LCAtMSk7IGlmIChuID09PSBcIk9iamVjdFwiICYmIG8uY29uc3RydWN0b3IpIG4gPSBvLmNvbnN0cnVjdG9yLm5hbWU7IGlmIChuID09PSBcIk1hcFwiIHx8IG4gPT09IFwiU2V0XCIpIHJldHVybiBBcnJheS5mcm9tKG8pOyBpZiAobiA9PT0gXCJBcmd1bWVudHNcIiB8fCAvXig/OlVpfEkpbnQoPzo4fDE2fDMyKSg/OkNsYW1wZWQpP0FycmF5JC8udGVzdChuKSkgcmV0dXJuIHNoYWRlcnNfYXJyYXlMaWtlVG9BcnJheShvLCBtaW5MZW4pOyB9XG5cbmZ1bmN0aW9uIHNoYWRlcnNfYXJyYXlMaWtlVG9BcnJheShhcnIsIGxlbikgeyBpZiAobGVuID09IG51bGwgfHwgbGVuID4gYXJyLmxlbmd0aCkgbGVuID0gYXJyLmxlbmd0aDsgZm9yICh2YXIgaSA9IDAsIGFycjIgPSBuZXcgQXJyYXkobGVuKTsgaSA8IGxlbjsgaSsrKSB7IGFycjJbaV0gPSBhcnJbaV07IH0gcmV0dXJuIGFycjI7IH1cblxuLy8gUGFyc2VyIGZvciBzaGFkZXIgZXZlbnRzXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIGNvbnN0IHNoYWRlcnMgPSAoe1xuICBtZXRob2RzOiB7XG4gICAgLy8gSW5pdCBzaGFkZXJzIGZyb20gZXh0ZW5zaW9uc1xuICAgIGluaXRfc2hhZGVyczogZnVuY3Rpb24gaW5pdF9zaGFkZXJzKHNraW4sIHByZXYpIHtcbiAgICAgIGlmIChza2luICE9PSBwcmV2KSB7XG4gICAgICAgIGlmIChwcmV2KSB0aGlzLnNoYWRlcnMgPSB0aGlzLnNoYWRlcnMuZmlsdGVyKGZ1bmN0aW9uICh4KSB7XG4gICAgICAgICAgcmV0dXJuIHgub3duZXIgIT09IHByZXYuaWQ7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHZhciBfaXRlcmF0b3IgPSBzaGFkZXJzX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXIoc2tpbi5zaGFkZXJzKSxcbiAgICAgICAgICAgIF9zdGVwO1xuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgZm9yIChfaXRlcmF0b3IucygpOyAhKF9zdGVwID0gX2l0ZXJhdG9yLm4oKSkuZG9uZTspIHtcbiAgICAgICAgICAgIHZhciBTaGFkZXIgPSBfc3RlcC52YWx1ZTtcbiAgICAgICAgICAgIHZhciBzaGFkZXIgPSBuZXcgU2hhZGVyKCk7XG4gICAgICAgICAgICBzaGFkZXIub3duZXIgPSBza2luLmlkO1xuICAgICAgICAgICAgdGhpcy5zaGFkZXJzLnB1c2goc2hhZGVyKTtcbiAgICAgICAgICB9IC8vIFRPRE86IFNvcnQgYnkgekluZGV4XG5cbiAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgX2l0ZXJhdG9yLmUoZXJyKTtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICBfaXRlcmF0b3IuZigpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcbiAgICBvbl9zaGFkZXJfZXZlbnQ6IGZ1bmN0aW9uIG9uX3NoYWRlcl9ldmVudChkLCB0YXJnZXQpIHtcbiAgICAgIGlmIChkLmV2ZW50ID09PSAnbmV3LXNoYWRlcicpIHtcbiAgICAgICAgaWYgKGQuYXJnc1swXS50YXJnZXQgPT09IHRhcmdldCkge1xuICAgICAgICAgIGQuYXJnc1swXS5pZCA9IFwiXCIuY29uY2F0KGQuYXJnc1sxXSwgXCItXCIpLmNvbmNhdChkLmFyZ3NbMl0pO1xuICAgICAgICAgIHRoaXMuc2hhZGVycy5wdXNoKGQuYXJnc1swXSk7XG4gICAgICAgICAgdGhpcy5yZXJlbmRlcisrO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChkLmV2ZW50ID09PSAncmVtb3ZlLXNoYWRlcnMnKSB7XG4gICAgICAgIHZhciBpZCA9IGQuYXJncy5qb2luKCctJyk7XG4gICAgICAgIHRoaXMuc2hhZGVycyA9IHRoaXMuc2hhZGVycy5maWx0ZXIoZnVuY3Rpb24gKHgpIHtcbiAgICAgICAgICByZXR1cm4geC5pZCAhPT0gaWQ7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cbiAgfSxcbiAgd2F0Y2g6IHtcbiAgICBza2luOiBmdW5jdGlvbiBza2luKG4sIHApIHtcbiAgICAgIHRoaXMuaW5pdF9zaGFkZXJzKG4sIHApO1xuICAgIH1cbiAgfSxcbiAgZGF0YTogZnVuY3Rpb24gZGF0YSgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgc2hhZGVyczogW11cbiAgICB9O1xuICB9XG59KTtcbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL25vZGVfbW9kdWxlcy9iYWJlbC1sb2FkZXIvbGliL2luZGV4LmpzIS4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL2luZGV4LmpzPz92dWUtbG9hZGVyLW9wdGlvbnMhLi9zcmMvY29tcG9uZW50cy9TZWN0aW9uLnZ1ZT92dWUmdHlwZT1zY3JpcHQmbGFuZz1qcyZcblxuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG5cblxuXG5cbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gY29uc3QgU2VjdGlvbnZ1ZV90eXBlX3NjcmlwdF9sYW5nX2pzXyA9ICh7XG4gIG5hbWU6ICdHcmlkU2VjdGlvbicsXG4gIHByb3BzOiBbJ2NvbW1vbicsICdncmlkX2lkJ10sXG4gIG1peGluczogW3NoYWRlcnNdLFxuICBjb21wb25lbnRzOiB7XG4gICAgR3JpZDogY29tcG9uZW50c19HcmlkLFxuICAgIFNpZGViYXI6IGNvbXBvbmVudHNfU2lkZWJhcixcbiAgICBDaGFydExlZ2VuZDogTGVnZW5kXG4gIH0sXG4gIG1vdW50ZWQ6IGZ1bmN0aW9uIG1vdW50ZWQoKSB7XG4gICAgdGhpcy5pbml0X3NoYWRlcnModGhpcy4kcHJvcHMuY29tbW9uLnNraW4pO1xuICB9LFxuICBtZXRob2RzOiB7XG4gICAgcmFuZ2VfY2hhbmdlZDogZnVuY3Rpb24gcmFuZ2VfY2hhbmdlZChyKSB7XG4gICAgICB0aGlzLiRlbWl0KCdyYW5nZS1jaGFuZ2VkJywgcik7XG4gICAgfSxcbiAgICBjdXJzb3JfY2hhbmdlZDogZnVuY3Rpb24gY3Vyc29yX2NoYW5nZWQoYykge1xuICAgICAgYy5ncmlkX2lkID0gdGhpcy4kcHJvcHMuZ3JpZF9pZDtcbiAgICAgIHRoaXMuJGVtaXQoJ2N1cnNvci1jaGFuZ2VkJywgYyk7XG4gICAgfSxcbiAgICBjdXJzb3JfbG9ja2VkOiBmdW5jdGlvbiBjdXJzb3JfbG9ja2VkKHN0YXRlKSB7XG4gICAgICB0aGlzLiRlbWl0KCdjdXJzb3ItbG9ja2VkJywgc3RhdGUpO1xuICAgIH0sXG4gICAgc2lkZWJhcl90cmFuc2Zvcm06IGZ1bmN0aW9uIHNpZGViYXJfdHJhbnNmb3JtKHMpIHtcbiAgICAgIHRoaXMuJGVtaXQoJ3NpZGViYXItdHJhbnNmb3JtJywgcyk7XG4gICAgfSxcbiAgICBlbWl0X21ldGFfcHJvcHM6IGZ1bmN0aW9uIGVtaXRfbWV0YV9wcm9wcyhkKSB7XG4gICAgICB0aGlzLiRzZXQodGhpcy5tZXRhX3Byb3BzLCBkLmxheWVyX2lkLCBkKTtcbiAgICAgIHRoaXMuJGVtaXQoJ2xheWVyLW1ldGEtcHJvcHMnLCBkKTtcbiAgICB9LFxuICAgIGVtaXRfY3VzdG9tX2V2ZW50OiBmdW5jdGlvbiBlbWl0X2N1c3RvbV9ldmVudChkKSB7XG4gICAgICB0aGlzLm9uX3NoYWRlcl9ldmVudChkLCAnc2lkZWJhcicpO1xuICAgICAgdGhpcy4kZW1pdCgnY3VzdG9tLWV2ZW50JywgZCk7XG4gICAgfSxcbiAgICBidXR0b25fY2xpY2s6IGZ1bmN0aW9uIGJ1dHRvbl9jbGljayhldmVudCkge1xuICAgICAgdGhpcy4kZW1pdCgnbGVnZW5kLWJ1dHRvbi1jbGljaycsIGV2ZW50KTtcbiAgICB9LFxuICAgIHJlZ2lzdGVyX2tiOiBmdW5jdGlvbiByZWdpc3Rlcl9rYihldmVudCkge1xuICAgICAgdGhpcy4kZW1pdCgncmVnaXN0ZXIta2ItbGlzdGVuZXInLCBldmVudCk7XG4gICAgfSxcbiAgICByZW1vdmVfa2I6IGZ1bmN0aW9uIHJlbW92ZV9rYihldmVudCkge1xuICAgICAgdGhpcy4kZW1pdCgncmVtb3ZlLWtiLWxpc3RlbmVyJywgZXZlbnQpO1xuICAgIH0sXG4gICAgcmV6b29tX3JhbmdlOiBmdW5jdGlvbiByZXpvb21fcmFuZ2UoZXZlbnQpIHtcbiAgICAgIHZhciBpZCA9ICdzYi0nICsgZXZlbnQuZ3JpZF9pZDtcblxuICAgICAgaWYgKHRoaXMuJHJlZnNbaWRdKSB7XG4gICAgICAgIHRoaXMuJHJlZnNbaWRdLnJlbmRlcmVyLnJlem9vbV9yYW5nZShldmVudC56LCBldmVudC5kaWZmMSwgZXZlbnQuZGlmZjIpO1xuICAgICAgfVxuICAgIH0sXG4gICAgZ2hhc2g6IGZ1bmN0aW9uIGdoYXNoKHZhbCkge1xuICAgICAgLy8gTWVhc3VyZXMgZ3JpZCBoZWlnaHRzIGNvbmZpZ3VyYXRpb25cbiAgICAgIHZhciBocyA9IHZhbC5sYXlvdXQuZ3JpZHMubWFwKGZ1bmN0aW9uICh4KSB7XG4gICAgICAgIHJldHVybiB4LmhlaWdodDtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIGhzLnJlZHVjZShmdW5jdGlvbiAoYSwgYikge1xuICAgICAgICByZXR1cm4gYSArIGI7XG4gICAgICB9LCAnJyk7XG4gICAgfVxuICB9LFxuICBjb21wdXRlZDoge1xuICAgIC8vIENvbXBvbmVudC1zcGVjaWZpYyBwcm9wcyBzdWJzZXRzOlxuICAgIGdyaWRfcHJvcHM6IGZ1bmN0aW9uIGdyaWRfcHJvcHMoKSB7XG4gICAgICB2YXIgaWQgPSB0aGlzLiRwcm9wcy5ncmlkX2lkO1xuICAgICAgdmFyIHAgPSBPYmplY3QuYXNzaWduKHt9LCB0aGlzLiRwcm9wcy5jb21tb24pOyAvLyBTcGxpdCBvZmZjaGFydCBkYXRhIGJldHdlZW4gb2ZmY2hhcnQgZ3JpZHNcblxuICAgICAgaWYgKGlkID4gMCkge1xuICAgICAgICB2YXIgX3AkZGF0YTtcblxuICAgICAgICB2YXIgYWxsID0gcC5kYXRhO1xuICAgICAgICBwLmRhdGEgPSBbcC5kYXRhW2lkIC0gMV1dOyAvLyBNZXJnZSBvZmZjaGFydCBvdmVybGF5cyB3aXRoIGN1c3RvbSBpZHMgd2l0aFxuICAgICAgICAvLyB0aGUgZXhpc3Rpbmcgb25zZSAoYnkgY29tcGFyaW5nIHRoZSBncmlkIGlkcylcblxuICAgICAgICAoX3AkZGF0YSA9IHAuZGF0YSkucHVzaC5hcHBseShfcCRkYXRhLCBfdG9Db25zdW1hYmxlQXJyYXkoYWxsLmZpbHRlcihmdW5jdGlvbiAoeCkge1xuICAgICAgICAgIHJldHVybiB4LmdyaWQgJiYgeC5ncmlkLmlkID09PSBpZDtcbiAgICAgICAgfSkpKTtcbiAgICAgIH1cblxuICAgICAgcC53aWR0aCA9IHAubGF5b3V0LmdyaWRzW2lkXS53aWR0aDtcbiAgICAgIHAuaGVpZ2h0ID0gcC5sYXlvdXQuZ3JpZHNbaWRdLmhlaWdodDtcbiAgICAgIHAueV90cmFuc2Zvcm0gPSBwLnlfdHNbaWRdO1xuICAgICAgcC5zaGFkZXJzID0gdGhpcy5ncmlkX3NoYWRlcnM7XG4gICAgICByZXR1cm4gcDtcbiAgICB9LFxuICAgIHNpZGViYXJfcHJvcHM6IGZ1bmN0aW9uIHNpZGViYXJfcHJvcHMoKSB7XG4gICAgICB2YXIgaWQgPSB0aGlzLiRwcm9wcy5ncmlkX2lkO1xuICAgICAgdmFyIHAgPSBPYmplY3QuYXNzaWduKHt9LCB0aGlzLiRwcm9wcy5jb21tb24pO1xuICAgICAgcC53aWR0aCA9IHAubGF5b3V0LmdyaWRzW2lkXS5zYjtcbiAgICAgIHAuaGVpZ2h0ID0gcC5sYXlvdXQuZ3JpZHNbaWRdLmhlaWdodDtcbiAgICAgIHAueV90cmFuc2Zvcm0gPSBwLnlfdHNbaWRdO1xuICAgICAgcC5zaGFkZXJzID0gdGhpcy5zYl9zaGFkZXJzO1xuICAgICAgcmV0dXJuIHA7XG4gICAgfSxcbiAgICBzZWN0aW9uX3ZhbHVlczogZnVuY3Rpb24gc2VjdGlvbl92YWx1ZXMoKSB7XG4gICAgICB2YXIgaWQgPSB0aGlzLiRwcm9wcy5ncmlkX2lkO1xuICAgICAgdmFyIHAgPSBPYmplY3QuYXNzaWduKHt9LCB0aGlzLiRwcm9wcy5jb21tb24pO1xuICAgICAgcC53aWR0aCA9IHAubGF5b3V0LmdyaWRzW2lkXS53aWR0aDtcbiAgICAgIHJldHVybiBwLmN1cnNvci52YWx1ZXNbaWRdO1xuICAgIH0sXG4gICAgbGVnZW5kX3Byb3BzOiBmdW5jdGlvbiBsZWdlbmRfcHJvcHMoKSB7XG4gICAgICB2YXIgaWQgPSB0aGlzLiRwcm9wcy5ncmlkX2lkO1xuICAgICAgdmFyIHAgPSBPYmplY3QuYXNzaWduKHt9LCB0aGlzLiRwcm9wcy5jb21tb24pOyAvLyBTcGxpdCBvZmZjaGFydCBkYXRhIGJldHdlZW4gb2ZmY2hhcnQgZ3JpZHNcblxuICAgICAgaWYgKGlkID4gMCkge1xuICAgICAgICB2YXIgX3AkZGF0YTI7XG5cbiAgICAgICAgdmFyIGFsbCA9IHAuZGF0YTtcbiAgICAgICAgcC5vZmZjaGFydCA9IGFsbDtcbiAgICAgICAgcC5kYXRhID0gW3AuZGF0YVtpZCAtIDFdXTtcblxuICAgICAgICAoX3AkZGF0YTIgPSBwLmRhdGEpLnB1c2guYXBwbHkoX3AkZGF0YTIsIF90b0NvbnN1bWFibGVBcnJheShhbGwuZmlsdGVyKGZ1bmN0aW9uICh4KSB7XG4gICAgICAgICAgcmV0dXJuIHguZ3JpZCAmJiB4LmdyaWQuaWQgPT09IGlkO1xuICAgICAgICB9KSkpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gcDtcbiAgICB9LFxuICAgIGdldF9tZXRhX3Byb3BzOiBmdW5jdGlvbiBnZXRfbWV0YV9wcm9wcygpIHtcbiAgICAgIHJldHVybiB0aGlzLm1ldGFfcHJvcHM7XG4gICAgfSxcbiAgICBncmlkX3NoYWRlcnM6IGZ1bmN0aW9uIGdyaWRfc2hhZGVycygpIHtcbiAgICAgIHJldHVybiB0aGlzLnNoYWRlcnMuZmlsdGVyKGZ1bmN0aW9uICh4KSB7XG4gICAgICAgIHJldHVybiB4LnRhcmdldCA9PT0gJ2dyaWQnO1xuICAgICAgfSk7XG4gICAgfSxcbiAgICBzYl9zaGFkZXJzOiBmdW5jdGlvbiBzYl9zaGFkZXJzKCkge1xuICAgICAgcmV0dXJuIHRoaXMuc2hhZGVycy5maWx0ZXIoZnVuY3Rpb24gKHgpIHtcbiAgICAgICAgcmV0dXJuIHgudGFyZ2V0ID09PSAnc2lkZWJhcic7XG4gICAgICB9KTtcbiAgICB9XG4gIH0sXG4gIHdhdGNoOiB7XG4gICAgY29tbW9uOiB7XG4gICAgICBoYW5kbGVyOiBmdW5jdGlvbiBoYW5kbGVyKHZhbCwgb2xkX3ZhbCkge1xuICAgICAgICB2YXIgbmV3aGFzaCA9IHRoaXMuZ2hhc2godmFsKTtcblxuICAgICAgICBpZiAobmV3aGFzaCAhPT0gdGhpcy5sYXN0X2doYXNoKSB7XG4gICAgICAgICAgdGhpcy5yZXJlbmRlcisrO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHZhbC5kYXRhLmxlbmd0aCAhPT0gb2xkX3ZhbC5kYXRhLmxlbmd0aCkge1xuICAgICAgICAgIC8vIExvb2sgYXQgdGhpcyBuYXN0eSB0cmljayFcbiAgICAgICAgICB0aGlzLnJlcmVuZGVyKys7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmxhc3RfZ2hhc2ggPSBuZXdoYXNoO1xuICAgICAgfSxcbiAgICAgIGRlZXA6IHRydWVcbiAgICB9XG4gIH0sXG4gIGRhdGE6IGZ1bmN0aW9uIGRhdGEoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIG1ldGFfcHJvcHM6IHt9LFxuICAgICAgcmVyZW5kZXI6IDAsXG4gICAgICBsYXN0X2doYXNoOiAnJ1xuICAgIH07XG4gIH1cbn0pO1xuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL2NvbXBvbmVudHMvU2VjdGlvbi52dWU/dnVlJnR5cGU9c2NyaXB0Jmxhbmc9anMmXG4gLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyBjb25zdCBjb21wb25lbnRzX1NlY3Rpb252dWVfdHlwZV9zY3JpcHRfbGFuZ19qc18gPSAoU2VjdGlvbnZ1ZV90eXBlX3NjcmlwdF9sYW5nX2pzXyk7IFxuLy8gRVhURVJOQUwgTU9EVUxFOiAuL25vZGVfbW9kdWxlcy92dWUtc3R5bGUtbG9hZGVyL2luZGV4LmpzIS4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvZGlzdC9janMuanMhLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvbG9hZGVycy9zdHlsZVBvc3RMb2FkZXIuanMhLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvaW5kZXguanM/P3Z1ZS1sb2FkZXItb3B0aW9ucyEuL3NyYy9jb21wb25lbnRzL1NlY3Rpb24udnVlP3Z1ZSZ0eXBlPXN0eWxlJmluZGV4PTAmbGFuZz1jc3MmXG52YXIgU2VjdGlvbnZ1ZV90eXBlX3N0eWxlX2luZGV4XzBfbGFuZ19jc3NfID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMSk7XG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvY29tcG9uZW50cy9TZWN0aW9uLnZ1ZT92dWUmdHlwZT1zdHlsZSZpbmRleD0wJmxhbmc9Y3NzJlxuXG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvY29tcG9uZW50cy9TZWN0aW9uLnZ1ZVxuXG5cblxuO1xuXG5cbi8qIG5vcm1hbGl6ZSBjb21wb25lbnQgKi9cblxudmFyIFNlY3Rpb25fY29tcG9uZW50ID0gbm9ybWFsaXplQ29tcG9uZW50KFxuICBjb21wb25lbnRzX1NlY3Rpb252dWVfdHlwZV9zY3JpcHRfbGFuZ19qc18sXG4gIFNlY3Rpb252dWVfdHlwZV90ZW1wbGF0ZV9pZF84ZmJlOTMzNl9yZW5kZXIsXG4gIFNlY3Rpb252dWVfdHlwZV90ZW1wbGF0ZV9pZF84ZmJlOTMzNl9zdGF0aWNSZW5kZXJGbnMsXG4gIGZhbHNlLFxuICBudWxsLFxuICBudWxsLFxuICBudWxsXG4gIFxuKVxuXG4vKiBob3QgcmVsb2FkICovXG5pZiAoZmFsc2UpIHsgdmFyIFNlY3Rpb25fYXBpOyB9XG5TZWN0aW9uX2NvbXBvbmVudC5vcHRpb25zLl9fZmlsZSA9IFwic3JjL2NvbXBvbmVudHMvU2VjdGlvbi52dWVcIlxuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyBjb25zdCBTZWN0aW9uID0gKFNlY3Rpb25fY29tcG9uZW50LmV4cG9ydHMpO1xuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL2NvbXBvbmVudHMvanMvYm90YmFyLmpzXG5cblxuXG5mdW5jdGlvbiBib3RiYXJfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlcihvLCBhbGxvd0FycmF5TGlrZSkgeyB2YXIgaXQ7IGlmICh0eXBlb2YgU3ltYm9sID09PSBcInVuZGVmaW5lZFwiIHx8IG9bU3ltYm9sLml0ZXJhdG9yXSA9PSBudWxsKSB7IGlmIChBcnJheS5pc0FycmF5KG8pIHx8IChpdCA9IGJvdGJhcl91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheShvKSkgfHwgYWxsb3dBcnJheUxpa2UgJiYgbyAmJiB0eXBlb2Ygby5sZW5ndGggPT09IFwibnVtYmVyXCIpIHsgaWYgKGl0KSBvID0gaXQ7IHZhciBpID0gMDsgdmFyIEYgPSBmdW5jdGlvbiBGKCkge307IHJldHVybiB7IHM6IEYsIG46IGZ1bmN0aW9uIG4oKSB7IGlmIChpID49IG8ubGVuZ3RoKSByZXR1cm4geyBkb25lOiB0cnVlIH07IHJldHVybiB7IGRvbmU6IGZhbHNlLCB2YWx1ZTogb1tpKytdIH07IH0sIGU6IGZ1bmN0aW9uIGUoX2UpIHsgdGhyb3cgX2U7IH0sIGY6IEYgfTsgfSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiSW52YWxpZCBhdHRlbXB0IHRvIGl0ZXJhdGUgbm9uLWl0ZXJhYmxlIGluc3RhbmNlLlxcbkluIG9yZGVyIHRvIGJlIGl0ZXJhYmxlLCBub24tYXJyYXkgb2JqZWN0cyBtdXN0IGhhdmUgYSBbU3ltYm9sLml0ZXJhdG9yXSgpIG1ldGhvZC5cIik7IH0gdmFyIG5vcm1hbENvbXBsZXRpb24gPSB0cnVlLCBkaWRFcnIgPSBmYWxzZSwgZXJyOyByZXR1cm4geyBzOiBmdW5jdGlvbiBzKCkgeyBpdCA9IG9bU3ltYm9sLml0ZXJhdG9yXSgpOyB9LCBuOiBmdW5jdGlvbiBuKCkgeyB2YXIgc3RlcCA9IGl0Lm5leHQoKTsgbm9ybWFsQ29tcGxldGlvbiA9IHN0ZXAuZG9uZTsgcmV0dXJuIHN0ZXA7IH0sIGU6IGZ1bmN0aW9uIGUoX2UyKSB7IGRpZEVyciA9IHRydWU7IGVyciA9IF9lMjsgfSwgZjogZnVuY3Rpb24gZigpIHsgdHJ5IHsgaWYgKCFub3JtYWxDb21wbGV0aW9uICYmIGl0W1wicmV0dXJuXCJdICE9IG51bGwpIGl0W1wicmV0dXJuXCJdKCk7IH0gZmluYWxseSB7IGlmIChkaWRFcnIpIHRocm93IGVycjsgfSB9IH07IH1cblxuZnVuY3Rpb24gYm90YmFyX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5KG8sIG1pbkxlbikgeyBpZiAoIW8pIHJldHVybjsgaWYgKHR5cGVvZiBvID09PSBcInN0cmluZ1wiKSByZXR1cm4gYm90YmFyX2FycmF5TGlrZVRvQXJyYXkobywgbWluTGVuKTsgdmFyIG4gPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwobykuc2xpY2UoOCwgLTEpOyBpZiAobiA9PT0gXCJPYmplY3RcIiAmJiBvLmNvbnN0cnVjdG9yKSBuID0gby5jb25zdHJ1Y3Rvci5uYW1lOyBpZiAobiA9PT0gXCJNYXBcIiB8fCBuID09PSBcIlNldFwiKSByZXR1cm4gQXJyYXkuZnJvbShvKTsgaWYgKG4gPT09IFwiQXJndW1lbnRzXCIgfHwgL14oPzpVaXxJKW50KD86OHwxNnwzMikoPzpDbGFtcGVkKT9BcnJheSQvLnRlc3QobikpIHJldHVybiBib3RiYXJfYXJyYXlMaWtlVG9BcnJheShvLCBtaW5MZW4pOyB9XG5cbmZ1bmN0aW9uIGJvdGJhcl9hcnJheUxpa2VUb0FycmF5KGFyciwgbGVuKSB7IGlmIChsZW4gPT0gbnVsbCB8fCBsZW4gPiBhcnIubGVuZ3RoKSBsZW4gPSBhcnIubGVuZ3RoOyBmb3IgKHZhciBpID0gMCwgYXJyMiA9IG5ldyBBcnJheShsZW4pOyBpIDwgbGVuOyBpKyspIHsgYXJyMltpXSA9IGFycltpXTsgfSByZXR1cm4gYXJyMjsgfVxuXG5cblxudmFyIGJvdGJhcl9NSU5VVEUxNSA9IGNvbnN0YW50cy5NSU5VVEUxNSxcbiAgICBib3RiYXJfTUlOVVRFID0gY29uc3RhbnRzLk1JTlVURSxcbiAgICBib3RiYXJfSE9VUiA9IGNvbnN0YW50cy5IT1VSLFxuICAgIGJvdGJhcl9EQVkgPSBjb25zdGFudHMuREFZLFxuICAgIGJvdGJhcl9XRUVLID0gY29uc3RhbnRzLldFRUssXG4gICAgYm90YmFyX01PTlRIID0gY29uc3RhbnRzLk1PTlRILFxuICAgIGJvdGJhcl9ZRUFSID0gY29uc3RhbnRzLllFQVIsXG4gICAgYm90YmFyX01PTlRITUFQID0gY29uc3RhbnRzLk1PTlRITUFQO1xuXG52YXIgQm90YmFyID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gQm90YmFyKGNhbnZhcywgY29tcCkge1xuICAgIGNsYXNzQ2FsbENoZWNrX2NsYXNzQ2FsbENoZWNrKHRoaXMsIEJvdGJhcik7XG5cbiAgICB0aGlzLmNhbnZhcyA9IGNhbnZhcztcbiAgICB0aGlzLmN0eCA9IGNhbnZhcy5nZXRDb250ZXh0KCcyZCcpO1xuICAgIHRoaXMuY29tcCA9IGNvbXA7XG4gICAgdGhpcy4kcCA9IGNvbXAuJHByb3BzO1xuICAgIHRoaXMuZGF0YSA9IHRoaXMuJHAuc3ViO1xuICAgIHRoaXMucmFuZ2UgPSB0aGlzLiRwLnJhbmdlO1xuICAgIHRoaXMubGF5b3V0ID0gdGhpcy4kcC5sYXlvdXQ7XG4gIH1cblxuICBjcmVhdGVDbGFzc19jcmVhdGVDbGFzcyhCb3RiYXIsIFt7XG4gICAga2V5OiBcInVwZGF0ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB1cGRhdGUoKSB7XG4gICAgICB0aGlzLmdyaWRfMCA9IHRoaXMubGF5b3V0LmdyaWRzWzBdO1xuICAgICAgdmFyIHdpZHRoID0gdGhpcy5sYXlvdXQuYm90YmFyLndpZHRoO1xuICAgICAgdmFyIGhlaWdodCA9IHRoaXMubGF5b3V0LmJvdGJhci5oZWlnaHQ7XG4gICAgICB2YXIgc2IgPSB0aGlzLmxheW91dC5ncmlkc1swXS5zYjsgLy90aGlzLmN0eC5maWxsU3R5bGUgPSB0aGlzLiRwLmNvbG9ycy5iYWNrXG5cbiAgICAgIHRoaXMuY3R4LmZvbnQgPSB0aGlzLiRwLmZvbnQ7IC8vdGhpcy5jdHguZmlsbFJlY3QoMCwgMCwgd2lkdGgsIGhlaWdodClcblxuICAgICAgdGhpcy5jdHguY2xlYXJSZWN0KDAsIDAsIHdpZHRoLCBoZWlnaHQpO1xuICAgICAgdGhpcy5jdHguc3Ryb2tlU3R5bGUgPSB0aGlzLiRwLmNvbG9ycy5zY2FsZTtcbiAgICAgIHRoaXMuY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgdGhpcy5jdHgubW92ZVRvKDAsIDAuNSk7XG4gICAgICB0aGlzLmN0eC5saW5lVG8oTWF0aC5mbG9vcih3aWR0aCArIDEpLCAwLjUpO1xuICAgICAgdGhpcy5jdHguc3Ryb2tlKCk7XG4gICAgICB0aGlzLmN0eC5maWxsU3R5bGUgPSB0aGlzLiRwLmNvbG9ycy50ZXh0O1xuICAgICAgdGhpcy5jdHguYmVnaW5QYXRoKCk7XG5cbiAgICAgIHZhciBfaXRlcmF0b3IgPSBib3RiYXJfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlcih0aGlzLmxheW91dC5ib3RiYXIueHMpLFxuICAgICAgICAgIF9zdGVwO1xuXG4gICAgICB0cnkge1xuICAgICAgICBmb3IgKF9pdGVyYXRvci5zKCk7ICEoX3N0ZXAgPSBfaXRlcmF0b3IubigpKS5kb25lOykge1xuICAgICAgICAgIHZhciBwID0gX3N0ZXAudmFsdWU7XG4gICAgICAgICAgdmFyIGxibCA9IHRoaXMuZm9ybWF0X2RhdGUocCk7XG4gICAgICAgICAgaWYgKHBbMF0gPiB3aWR0aCAtIHNiKSBjb250aW51ZTtcbiAgICAgICAgICB0aGlzLmN0eC5tb3ZlVG8ocFswXSAtIDAuNSwgMCk7XG4gICAgICAgICAgdGhpcy5jdHgubGluZVRvKHBbMF0gLSAwLjUsIDQuNSk7XG5cbiAgICAgICAgICBpZiAoIXRoaXMubGJsX2hpZ2hsaWdodChwWzFdWzBdKSkge1xuICAgICAgICAgICAgdGhpcy5jdHguZ2xvYmFsQWxwaGEgPSAwLjg1O1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHRoaXMuY3R4LnRleHRBbGlnbiA9ICdjZW50ZXInO1xuICAgICAgICAgIHRoaXMuY3R4LmZpbGxUZXh0KGxibCwgcFswXSwgMTgpO1xuICAgICAgICAgIHRoaXMuY3R4Lmdsb2JhbEFscGhhID0gMTtcbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIF9pdGVyYXRvci5lKGVycik7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICBfaXRlcmF0b3IuZigpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLmN0eC5zdHJva2UoKTtcbiAgICAgIHRoaXMuYXBwbHlfc2hhZGVycygpO1xuICAgICAgaWYgKHRoaXMuJHAuY3Vyc29yLnggJiYgdGhpcy4kcC5jdXJzb3IudCAhPT0gdW5kZWZpbmVkKSB0aGlzLnBhbmVsKCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImFwcGx5X3NoYWRlcnNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gYXBwbHlfc2hhZGVycygpIHtcbiAgICAgIHZhciBsYXlvdXQgPSB0aGlzLmxheW91dC5ncmlkc1swXTtcbiAgICAgIHZhciBwcm9wcyA9IHtcbiAgICAgICAgbGF5b3V0OiBsYXlvdXQsXG4gICAgICAgIGN1cnNvcjogdGhpcy4kcC5jdXJzb3JcbiAgICAgIH07XG5cbiAgICAgIHZhciBfaXRlcmF0b3IyID0gYm90YmFyX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXIodGhpcy5jb21wLmJvdF9zaGFkZXJzKSxcbiAgICAgICAgICBfc3RlcDI7XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIGZvciAoX2l0ZXJhdG9yMi5zKCk7ICEoX3N0ZXAyID0gX2l0ZXJhdG9yMi5uKCkpLmRvbmU7KSB7XG4gICAgICAgICAgdmFyIHMgPSBfc3RlcDIudmFsdWU7XG4gICAgICAgICAgdGhpcy5jdHguc2F2ZSgpO1xuICAgICAgICAgIHMuZHJhdyh0aGlzLmN0eCwgcHJvcHMpO1xuICAgICAgICAgIHRoaXMuY3R4LnJlc3RvcmUoKTtcbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIF9pdGVyYXRvcjIuZShlcnIpO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgX2l0ZXJhdG9yMi5mKCk7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInBhbmVsXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHBhbmVsKCkge1xuICAgICAgdmFyIGxibCA9IHRoaXMuZm9ybWF0X2N1cnNvcl94KCk7XG4gICAgICB0aGlzLmN0eC5maWxsU3R5bGUgPSB0aGlzLiRwLmNvbG9ycy5wYW5lbDtcbiAgICAgIHZhciBtZWFzdXJlID0gdGhpcy5jdHgubWVhc3VyZVRleHQobGJsICsgJyAgICAnKTtcbiAgICAgIHZhciBwYW53aWR0aCA9IE1hdGguZmxvb3IobWVhc3VyZS53aWR0aCk7XG4gICAgICB2YXIgY3Vyc29yID0gdGhpcy4kcC5jdXJzb3IueDtcbiAgICAgIHZhciB4ID0gTWF0aC5mbG9vcihjdXJzb3IgLSBwYW53aWR0aCAqIDAuNSk7XG4gICAgICB2YXIgeSA9IC0wLjU7XG4gICAgICB2YXIgcGFuaGVpZ2h0ID0gdGhpcy5jb21wLmNvbmZpZy5QQU5IRUlHSFQ7XG4gICAgICB0aGlzLmN0eC5maWxsUmVjdCh4LCB5LCBwYW53aWR0aCwgcGFuaGVpZ2h0ICsgMC41KTtcbiAgICAgIHRoaXMuY3R4LmZpbGxTdHlsZSA9IHRoaXMuJHAuY29sb3JzLnRleHRITDtcbiAgICAgIHRoaXMuY3R4LnRleHRBbGlnbiA9ICdjZW50ZXInO1xuICAgICAgdGhpcy5jdHguZmlsbFRleHQobGJsLCBjdXJzb3IsIHkgKyAxNik7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImZvcm1hdF9kYXRlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGZvcm1hdF9kYXRlKHApIHtcbiAgICAgIHZhciB0ID0gcFsxXVswXTtcbiAgICAgIHQgPSB0aGlzLmdyaWRfMC50aV9tYXAuaTJ0KHQpO1xuICAgICAgdmFyIHRpID0gdGhpcy4kcC5sYXlvdXQuZ3JpZHNbMF0udGlfbWFwLnRmOyAvLyBFbmFibGUgdGltZXpvbmVzIG9ubHkgZm9yIHRmIDwgMURcblxuICAgICAgdmFyIGsgPSB0aSA8IGJvdGJhcl9EQVkgPyAxIDogMDtcbiAgICAgIHZhciB0WiA9IHQgKyBrICogdGhpcy4kcC50aW1lem9uZSAqIGJvdGJhcl9IT1VSOyAvL3QgKz0gbmV3IERhdGUodCkuZ2V0VGltZXpvbmVPZmZzZXQoKSAqIE1JTlVURVxuXG4gICAgICB2YXIgZCA9IG5ldyBEYXRlKHRaKTtcblxuICAgICAgaWYgKHBbMl0gPT09IGJvdGJhcl9ZRUFSIHx8IHV0aWxzLnllYXJfc3RhcnQodCkgPT09IHQpIHtcbiAgICAgICAgcmV0dXJuIGQuZ2V0VVRDRnVsbFllYXIoKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHBbMl0gPT09IGJvdGJhcl9NT05USCB8fCB1dGlscy5tb250aF9zdGFydCh0KSA9PT0gdCkge1xuICAgICAgICByZXR1cm4gYm90YmFyX01PTlRITUFQW2QuZ2V0VVRDTW9udGgoKV07XG4gICAgICB9IC8vIFRPRE8oKikgc2VlIGdyaWRfbWFrZXIuanNcblxuXG4gICAgICBpZiAodXRpbHMuZGF5X3N0YXJ0KHRaKSA9PT0gdFopIHJldHVybiBkLmdldFVUQ0RhdGUoKTtcbiAgICAgIHZhciBoID0gdXRpbHMuYWRkX3plcm8oZC5nZXRVVENIb3VycygpKTtcbiAgICAgIHZhciBtID0gdXRpbHMuYWRkX3plcm8oZC5nZXRVVENNaW51dGVzKCkpO1xuICAgICAgcmV0dXJuIGggKyBcIjpcIiArIG07XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImZvcm1hdF9jdXJzb3JfeFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBmb3JtYXRfY3Vyc29yX3goKSB7XG4gICAgICB2YXIgdCA9IHRoaXMuJHAuY3Vyc29yLnQ7XG4gICAgICB0ID0gdGhpcy5ncmlkXzAudGlfbWFwLmkydCh0KTsgLy9sZXQgdGkgPSB0aGlzLiRwLmludGVydmFsXG5cbiAgICAgIHZhciB0aSA9IHRoaXMuJHAubGF5b3V0LmdyaWRzWzBdLnRpX21hcC50ZjsgLy8gRW5hYmxlIHRpbWV6b25lcyBvbmx5IGZvciB0ZiA8IDFEXG5cbiAgICAgIHZhciBrID0gdGkgPCBib3RiYXJfREFZID8gMSA6IDA7IC8vdCArPSBuZXcgRGF0ZSh0KS5nZXRUaW1lem9uZU9mZnNldCgpICogTUlOVVRFXG5cbiAgICAgIHZhciBkID0gbmV3IERhdGUodCArIGsgKiB0aGlzLiRwLnRpbWV6b25lICogYm90YmFyX0hPVVIpO1xuXG4gICAgICBpZiAodGkgPT09IGJvdGJhcl9ZRUFSKSB7XG4gICAgICAgIHJldHVybiBkLmdldFVUQ0Z1bGxZZWFyKCk7XG4gICAgICB9XG5cbiAgICAgIGlmICh0aSA8IGJvdGJhcl9ZRUFSKSB7XG4gICAgICAgIHZhciB5ciA9ICdgJyArIFwiXCIuY29uY2F0KGQuZ2V0VVRDRnVsbFllYXIoKSkuc2xpY2UoLTIpO1xuICAgICAgICB2YXIgbW8gPSBib3RiYXJfTU9OVEhNQVBbZC5nZXRVVENNb250aCgpXTtcbiAgICAgICAgdmFyIGRkID0gJzAxJztcbiAgICAgIH1cblxuICAgICAgaWYgKHRpIDw9IGJvdGJhcl9XRUVLKSBkZCA9IGQuZ2V0VVRDRGF0ZSgpO1xuICAgICAgdmFyIGRhdGUgPSBcIlwiLmNvbmNhdChkZCwgXCIgXCIpLmNvbmNhdChtbywgXCIgXCIpLmNvbmNhdCh5cik7XG4gICAgICB2YXIgdGltZSA9ICcnO1xuXG4gICAgICBpZiAodGkgPCBib3RiYXJfREFZKSB7XG4gICAgICAgIHZhciBoID0gdXRpbHMuYWRkX3plcm8oZC5nZXRVVENIb3VycygpKTtcbiAgICAgICAgdmFyIG0gPSB1dGlscy5hZGRfemVybyhkLmdldFVUQ01pbnV0ZXMoKSk7XG4gICAgICAgIHRpbWUgPSBoICsgXCI6XCIgKyBtO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gXCJcIi5jb25jYXQoZGF0ZSwgXCIgIFwiKS5jb25jYXQodGltZSk7XG4gICAgfSAvLyBIaWdobGlnaHRzIHRoZSBiZWdpbmluZyBvZiBhIHRpbWUgaW50ZXJ2YWxcbiAgICAvLyBUT0RPOiBpbXByb3ZlLiBQcm9ibGVtOiBsZXQncyBzYXkgd2UgaGF2ZSBhIG5ldyBtb250aCxcbiAgICAvLyBidXQgaWYgdGhlcmUgaXMgbm8gZ3JpZCBsaW5lIGluIHBsYWNlLCB0aGVyZVxuICAgIC8vIHdpbGwgYmUgbm8gbW9udGggbmFtZSBvbiB0LWF4aXMuIFNhZC5cbiAgICAvLyBTb2x1dGlvbjogbWFuaXB1bGF0ZSB0aGUgZ3JpZCwgc2tldyBpdCwgeW91IGtub3dcblxuICB9LCB7XG4gICAga2V5OiBcImxibF9oaWdobGlnaHRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gbGJsX2hpZ2hsaWdodCh0KSB7XG4gICAgICB2YXIgdGkgPSB0aGlzLiRwLmludGVydmFsO1xuICAgICAgaWYgKHQgPT09IDApIHJldHVybiB0cnVlO1xuICAgICAgaWYgKHV0aWxzLm1vbnRoX3N0YXJ0KHQpID09PSB0KSByZXR1cm4gdHJ1ZTtcbiAgICAgIGlmICh1dGlscy5kYXlfc3RhcnQodCkgPT09IHQpIHJldHVybiB0cnVlO1xuICAgICAgaWYgKHRpIDw9IGJvdGJhcl9NSU5VVEUxNSAmJiB0ICUgYm90YmFyX0hPVVIgPT09IDApIHJldHVybiB0cnVlO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJtb3VzZW1vdmVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gbW91c2Vtb3ZlKCkge31cbiAgfSwge1xuICAgIGtleTogXCJtb3VzZW91dFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBtb3VzZW91dCgpIHt9XG4gIH0sIHtcbiAgICBrZXk6IFwibW91c2V1cFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBtb3VzZXVwKCkge31cbiAgfSwge1xuICAgIGtleTogXCJtb3VzZWRvd25cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gbW91c2Vkb3duKCkge31cbiAgfV0pO1xuXG4gIHJldHVybiBCb3RiYXI7XG59KCk7XG5cblxuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vbm9kZV9tb2R1bGVzL2JhYmVsLWxvYWRlci9saWIvaW5kZXguanMhLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvaW5kZXguanM/P3Z1ZS1sb2FkZXItb3B0aW9ucyEuL3NyYy9jb21wb25lbnRzL0JvdGJhci52dWU/dnVlJnR5cGU9c2NyaXB0Jmxhbmc9anMmXG4vLyBUaGUgYm90dG9tIGJhciAoeWVwLCB0aGF0IHRoaW5nIHdpdGggYSBidW5jaCBvZiBkYXRlcylcblxuXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIGNvbnN0IEJvdGJhcnZ1ZV90eXBlX3NjcmlwdF9sYW5nX2pzXyA9ICh7XG4gIG5hbWU6ICdCb3RiYXInLFxuICBwcm9wczogWydzdWInLCAnbGF5b3V0JywgJ3JhbmdlJywgJ2ludGVydmFsJywgJ2N1cnNvcicsICdjb2xvcnMnLCAnZm9udCcsICd3aWR0aCcsICdoZWlnaHQnLCAncmVyZW5kZXInLCAndHZfaWQnLCAnY29uZmlnJywgJ3NoYWRlcnMnLCAndGltZXpvbmUnXSxcbiAgbWl4aW5zOiBbY2FudmFzXSxcbiAgbW91bnRlZDogZnVuY3Rpb24gbW91bnRlZCgpIHtcbiAgICB2YXIgZWwgPSB0aGlzLiRyZWZzWydjYW52YXMnXTtcbiAgICB0aGlzLnJlbmRlcmVyID0gbmV3IEJvdGJhcihlbCwgdGhpcyk7XG4gICAgdGhpcy5zZXR1cCgpO1xuICAgIHRoaXMucmVkcmF3KCk7XG4gIH0sXG4gIHJlbmRlcjogZnVuY3Rpb24gcmVuZGVyKGgpIHtcbiAgICB2YXIgc2V0dCA9IHRoaXMuJHByb3BzLmxheW91dC5ib3RiYXI7XG4gICAgcmV0dXJuIHRoaXMuY3JlYXRlX2NhbnZhcyhoLCAnYm90YmFyJywge1xuICAgICAgcG9zaXRpb246IHtcbiAgICAgICAgeDogMCxcbiAgICAgICAgeTogc2V0dC5vZmZzZXQgfHwgMFxuICAgICAgfSxcbiAgICAgIGF0dHJzOiB7XG4gICAgICAgIHJlcmVuZGVyOiB0aGlzLiRwcm9wcy5yZXJlbmRlcixcbiAgICAgICAgd2lkdGg6IHNldHQud2lkdGgsXG4gICAgICAgIGhlaWdodDogc2V0dC5oZWlnaHRcbiAgICAgIH0sXG4gICAgICBzdHlsZToge1xuICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6IHRoaXMuJHByb3BzLmNvbG9ycy5iYWNrXG4gICAgICB9XG4gICAgfSk7XG4gIH0sXG4gIGNvbXB1dGVkOiB7XG4gICAgYm90X3NoYWRlcnM6IGZ1bmN0aW9uIGJvdF9zaGFkZXJzKCkge1xuICAgICAgcmV0dXJuIHRoaXMuJHByb3BzLnNoYWRlcnMuZmlsdGVyKGZ1bmN0aW9uICh4KSB7XG4gICAgICAgIHJldHVybiB4LnRhcmdldCA9PT0gJ2JvdGJhcic7XG4gICAgICB9KTtcbiAgICB9XG4gIH0sXG4gIHdhdGNoOiB7XG4gICAgcmFuZ2U6IHtcbiAgICAgIGhhbmRsZXI6IGZ1bmN0aW9uIGhhbmRsZXIoKSB7XG4gICAgICAgIHRoaXMucmVkcmF3KCk7XG4gICAgICB9LFxuICAgICAgZGVlcDogdHJ1ZVxuICAgIH0sXG4gICAgY3Vyc29yOiB7XG4gICAgICBoYW5kbGVyOiBmdW5jdGlvbiBoYW5kbGVyKCkge1xuICAgICAgICB0aGlzLnJlZHJhdygpO1xuICAgICAgfSxcbiAgICAgIGRlZXA6IHRydWVcbiAgICB9LFxuICAgIHJlcmVuZGVyOiBmdW5jdGlvbiByZXJlbmRlcigpIHtcbiAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICAgIHRoaXMuJG5leHRUaWNrKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIF90aGlzLnJlZHJhdygpO1xuICAgICAgfSk7XG4gICAgfVxuICB9XG59KTtcbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9jb21wb25lbnRzL0JvdGJhci52dWU/dnVlJnR5cGU9c2NyaXB0Jmxhbmc9anMmXG4gLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyBjb25zdCBjb21wb25lbnRzX0JvdGJhcnZ1ZV90eXBlX3NjcmlwdF9sYW5nX2pzXyA9IChCb3RiYXJ2dWVfdHlwZV9zY3JpcHRfbGFuZ19qc18pOyBcbi8vIEVYVEVSTkFMIE1PRFVMRTogLi9ub2RlX21vZHVsZXMvdnVlLXN0eWxlLWxvYWRlci9pbmRleC5qcyEuL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2Rpc3QvY2pzLmpzIS4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL2xvYWRlcnMvc3R5bGVQb3N0TG9hZGVyLmpzIS4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL2luZGV4LmpzPz92dWUtbG9hZGVyLW9wdGlvbnMhLi9zcmMvY29tcG9uZW50cy9Cb3RiYXIudnVlP3Z1ZSZ0eXBlPXN0eWxlJmluZGV4PTAmbGFuZz1jc3MmXG52YXIgQm90YmFydnVlX3R5cGVfc3R5bGVfaW5kZXhfMF9sYW5nX2Nzc18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEyNCk7XG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvY29tcG9uZW50cy9Cb3RiYXIudnVlP3Z1ZSZ0eXBlPXN0eWxlJmluZGV4PTAmbGFuZz1jc3MmXG5cbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9jb21wb25lbnRzL0JvdGJhci52dWVcbnZhciBCb3RiYXJfcmVuZGVyLCBCb3RiYXJfc3RhdGljUmVuZGVyRm5zXG47XG5cbjtcblxuXG4vKiBub3JtYWxpemUgY29tcG9uZW50ICovXG5cbnZhciBCb3RiYXJfY29tcG9uZW50ID0gbm9ybWFsaXplQ29tcG9uZW50KFxuICBjb21wb25lbnRzX0JvdGJhcnZ1ZV90eXBlX3NjcmlwdF9sYW5nX2pzXyxcbiAgQm90YmFyX3JlbmRlcixcbiAgQm90YmFyX3N0YXRpY1JlbmRlckZucyxcbiAgZmFsc2UsXG4gIG51bGwsXG4gIG51bGwsXG4gIG51bGxcbiAgXG4pXG5cbi8qIGhvdCByZWxvYWQgKi9cbmlmIChmYWxzZSkgeyB2YXIgQm90YmFyX2FwaTsgfVxuQm90YmFyX2NvbXBvbmVudC5vcHRpb25zLl9fZmlsZSA9IFwic3JjL2NvbXBvbmVudHMvQm90YmFyLnZ1ZVwiXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIGNvbnN0IGNvbXBvbmVudHNfQm90YmFyID0gKEJvdGJhcl9jb21wb25lbnQuZXhwb3J0cyk7XG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9ub2RlX21vZHVsZXMvYmFiZWwtbG9hZGVyL2xpYi9pbmRleC5qcyEuL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9pbmRleC5qcz8/dnVlLWxvYWRlci1vcHRpb25zIS4vc3JjL2NvbXBvbmVudHMvS2V5Ym9hcmQudnVlP3Z1ZSZ0eXBlPXNjcmlwdCZsYW5nPWpzJlxuLy9cbi8vXG4vL1xuLy9cbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gY29uc3QgS2V5Ym9hcmR2dWVfdHlwZV9zY3JpcHRfbGFuZ19qc18gPSAoe1xuICBuYW1lOiAnS2V5Ym9hcmQnLFxuICBjcmVhdGVkOiBmdW5jdGlvbiBjcmVhdGVkKCkge1xuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdrZXlkb3duJywgdGhpcy5rZXlkb3duKTtcbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigna2V5dXAnLCB0aGlzLmtleXVwKTtcbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigna2V5cHJlc3MnLCB0aGlzLmtleXByZXNzKTtcbiAgICB0aGlzLl9saXN0ZW5lcnMgPSB7fTtcbiAgfSxcbiAgYmVmb3JlRGVzdHJveTogZnVuY3Rpb24gYmVmb3JlRGVzdHJveSgpIHtcbiAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcigna2V5ZG93bicsIHRoaXMua2V5ZG93bik7XG4gICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2tleXVwJywgdGhpcy5rZXl1cCk7XG4gICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2tleXByZXNzJywgdGhpcy5rZXlwcmVzcyk7XG4gIH0sXG4gIHJlbmRlcjogZnVuY3Rpb24gcmVuZGVyKGgpIHtcbiAgICByZXR1cm4gaCgpO1xuICB9LFxuICBtZXRob2RzOiB7XG4gICAga2V5ZG93bjogZnVuY3Rpb24ga2V5ZG93bihldmVudCkge1xuICAgICAgZm9yICh2YXIgaWQgaW4gdGhpcy5fbGlzdGVuZXJzKSB7XG4gICAgICAgIHZhciBsID0gdGhpcy5fbGlzdGVuZXJzW2lkXTtcblxuICAgICAgICBpZiAobCAmJiBsLmtleWRvd24pIHtcbiAgICAgICAgICBsLmtleWRvd24oZXZlbnQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNvbnNvbGUud2FybihcIk5vICdrZXlkb3duJyBsaXN0ZW5lciBmb3IgXCIuY29uY2F0KGlkKSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuICAgIGtleXVwOiBmdW5jdGlvbiBrZXl1cChldmVudCkge1xuICAgICAgZm9yICh2YXIgaWQgaW4gdGhpcy5fbGlzdGVuZXJzKSB7XG4gICAgICAgIHZhciBsID0gdGhpcy5fbGlzdGVuZXJzW2lkXTtcblxuICAgICAgICBpZiAobCAmJiBsLmtleXVwKSB7XG4gICAgICAgICAgbC5rZXl1cChldmVudCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY29uc29sZS53YXJuKFwiTm8gJ2tleXVwJyBsaXN0ZW5lciBmb3IgXCIuY29uY2F0KGlkKSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuICAgIGtleXByZXNzOiBmdW5jdGlvbiBrZXlwcmVzcyhldmVudCkge1xuICAgICAgZm9yICh2YXIgaWQgaW4gdGhpcy5fbGlzdGVuZXJzKSB7XG4gICAgICAgIHZhciBsID0gdGhpcy5fbGlzdGVuZXJzW2lkXTtcblxuICAgICAgICBpZiAobCAmJiBsLmtleXByZXNzKSB7XG4gICAgICAgICAgbC5rZXlwcmVzcyhldmVudCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY29uc29sZS53YXJuKFwiTm8gJ2tleXByZXNzJyBsaXN0ZW5lciBmb3IgXCIuY29uY2F0KGlkKSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuICAgIHJlZ2lzdGVyOiBmdW5jdGlvbiByZWdpc3RlcihsaXN0ZW5lcikge1xuICAgICAgdGhpcy5fbGlzdGVuZXJzW2xpc3RlbmVyLmlkXSA9IGxpc3RlbmVyO1xuICAgIH0sXG4gICAgcmVtb3ZlOiBmdW5jdGlvbiByZW1vdmUobGlzdGVuZXIpIHtcbiAgICAgIGRlbGV0ZSB0aGlzLl9saXN0ZW5lcnNbbGlzdGVuZXIuaWRdO1xuICAgIH1cbiAgfVxufSk7XG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvY29tcG9uZW50cy9LZXlib2FyZC52dWU/dnVlJnR5cGU9c2NyaXB0Jmxhbmc9anMmXG4gLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyBjb25zdCBjb21wb25lbnRzX0tleWJvYXJkdnVlX3R5cGVfc2NyaXB0X2xhbmdfanNfID0gKEtleWJvYXJkdnVlX3R5cGVfc2NyaXB0X2xhbmdfanNfKTsgXG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvY29tcG9uZW50cy9LZXlib2FyZC52dWVcbnZhciBLZXlib2FyZF9yZW5kZXIsIEtleWJvYXJkX3N0YXRpY1JlbmRlckZuc1xuO1xuXG5cblxuLyogbm9ybWFsaXplIGNvbXBvbmVudCAqL1xuO1xudmFyIEtleWJvYXJkX2NvbXBvbmVudCA9IG5vcm1hbGl6ZUNvbXBvbmVudChcbiAgY29tcG9uZW50c19LZXlib2FyZHZ1ZV90eXBlX3NjcmlwdF9sYW5nX2pzXyxcbiAgS2V5Ym9hcmRfcmVuZGVyLFxuICBLZXlib2FyZF9zdGF0aWNSZW5kZXJGbnMsXG4gIGZhbHNlLFxuICBudWxsLFxuICBudWxsLFxuICBudWxsXG4gIFxuKVxuXG4vKiBob3QgcmVsb2FkICovXG5pZiAoZmFsc2UpIHsgdmFyIEtleWJvYXJkX2FwaTsgfVxuS2V5Ym9hcmRfY29tcG9uZW50Lm9wdGlvbnMuX19maWxlID0gXCJzcmMvY29tcG9uZW50cy9LZXlib2FyZC52dWVcIlxuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyBjb25zdCBLZXlib2FyZCA9IChLZXlib2FyZF9jb21wb25lbnQuZXhwb3J0cyk7XG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvbWl4aW5zL2RhdGF0cmFjay5qc1xuLy8gRGF0YSB0cmFja2VyL3dhdGNoZXJcblxuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyBjb25zdCBkYXRhdHJhY2sgPSAoe1xuICBtZXRob2RzOiB7XG4gICAgZGF0YV9jaGFuZ2VkOiBmdW5jdGlvbiBkYXRhX2NoYW5nZWQoKSB7XG4gICAgICB2YXIgbiA9IHRoaXMub2hsY3Y7XG4gICAgICB2YXIgY2hhbmdlZCA9IGZhbHNlO1xuXG4gICAgICBpZiAodGhpcy5fZGF0YV9uMCAhPT0gblswXSAmJiB0aGlzLl9kYXRhX2xlbiAhPT0gbi5sZW5ndGgpIHtcbiAgICAgICAgY2hhbmdlZCA9IHRydWU7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuY2hlY2tfYWxsX2RhdGEoY2hhbmdlZCk7XG5cbiAgICAgIGlmICh0aGlzLnRpX21hcC5pYikge1xuICAgICAgICB0aGlzLnJlaW5kZXhfZGVsdGEoblswXSwgdGhpcy5fZGF0YV9uMCk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuX2RhdGFfbjAgPSBuWzBdO1xuICAgICAgdGhpcy5fZGF0YV9sZW4gPSBuLmxlbmd0aDtcbiAgICAgIHRoaXMuc2F2ZV9kYXRhX3QoKTtcbiAgICAgIHJldHVybiBjaGFuZ2VkO1xuICAgIH0sXG4gICAgY2hlY2tfYWxsX2RhdGE6IGZ1bmN0aW9uIGNoZWNrX2FsbF9kYXRhKGNoYW5nZWQpIHtcbiAgICAgIC8vIElmIGxlbmd0aCBvZiBkYXRhIGluIHRoZSBTdHJ1Y3R1cmUgY2hhbmdlZCBieSA+IDEgcG9pbnRcbiAgICAgIC8vIGVtaXQgYSBzcGVjaWFsIGV2ZW50IGZvciBEQyB0byByZWNhbGMgdGhlIHNjcmlwdHNcbiAgICAgIC8vIFRPRE86IGNoZWNrIG92ZXJsYXlzIGRhdGEgdG9vXG4gICAgICB2YXIgbGVuID0gdGhpcy5fZGF0YV9sZW4gfHwgMDtcblxuICAgICAgaWYgKE1hdGguYWJzKHRoaXMub2hsY3YubGVuZ3RoIC0gbGVuKSA+IDEgfHwgdGhpcy5fZGF0YV9uMCAhPT0gdGhpcy5vaGxjdlswXSkge1xuICAgICAgICB0aGlzLiRlbWl0KCdjdXN0b20tZXZlbnQnLCB7XG4gICAgICAgICAgZXZlbnQ6ICdkYXRhLWxlbi1jaGFuZ2VkJyxcbiAgICAgICAgICBhcmdzOiBbXVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9LFxuICAgIHJlaW5kZXhfZGVsdGE6IGZ1bmN0aW9uIHJlaW5kZXhfZGVsdGEobiwgcCkge1xuICAgICAgbiA9IG4gfHwgW1swXV07XG4gICAgICBwID0gcCB8fCBbWzBdXTtcbiAgICAgIHZhciBkdCA9IG5bMF0gLSBwWzBdO1xuXG4gICAgICBpZiAoZHQgIT09IDAgJiYgdGhpcy5fZGF0YV90KSB7XG4gICAgICAgIC8vIENvbnZlcnQgdCBiYWNrIHRvIGluZGV4XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgLy8gTW9yZSBwcmVjaXNlIG1ldGhvZCBmaXJzdFxuICAgICAgICAgIHZhciBudCA9IHRoaXMuX2RhdGFfdCArIDAuMDE7IC8vIGZpeCBmb3IgdGhlIGZpbHRlciBsaWJcblxuICAgICAgICAgIHZhciByZXMgPSB1dGlscy5mYXN0X25lYXJlc3QodGhpcy5vaGxjdiwgbnQpO1xuICAgICAgICAgIHZhciBjbmRsID0gdGhpcy5vaGxjdltyZXNbMF1dO1xuICAgICAgICAgIHZhciBvZmYgPSAobnQgLSBjbmRsWzBdKSAvIHRoaXMuaW50ZXJ2YWxfbXM7XG4gICAgICAgICAgdGhpc1tcImdvdG9cIl0ocmVzWzBdICsgb2ZmKTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgIHRoaXNbXCJnb3RvXCJdKHRoaXMudGlfbWFwLnQyaSh0aGlzLl9kYXRhX3QpKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG4gICAgc2F2ZV9kYXRhX3Q6IGZ1bmN0aW9uIHNhdmVfZGF0YV90KCkge1xuICAgICAgdGhpcy5fZGF0YV90ID0gdGhpcy50aV9tYXAuaTJ0KHRoaXMucmFuZ2VbMV0pOyAvLyBzYXZlIGFzIHRcbiAgICB9XG4gIH0sXG4gIGRhdGE6IGZ1bmN0aW9uIGRhdGEoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIF9kYXRhX24wOiBudWxsLFxuICAgICAgX2RhdGFfbGVuOiAwLFxuICAgICAgX2RhdGFfdDogMFxuICAgIH07XG4gIH1cbn0pO1xuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL2NvbXBvbmVudHMvanMvdGlfbWFwcGluZy5qc1xuXG5cblxuXG4vLyBUaW1lLWluZGV4IG1hcHBpbmcgKGZvciBub24tbGluZWFyIHQtYXhpcylcblxudmFyIE1BWF9BUlIgPSBNYXRoLnBvdygyLCAzMik7IC8vIDMgTU9ERVMgb2YgaW5kZXggY2FsY3VsYXRpb24gZm9yIG92ZXJsYXlzL3N1YmNoYXJ0czpcbi8vIDo6OiBpbmRleFNyYyA6Ojpcbi8vICogXCJtYXBcIiAgICAgIC0+IHVzZSBUSSBtYXBwaW5nIGZ1bmN0aW9ucyB0byBkZXRlY3QgaW5kZXhcbi8vICAgICAgICAgICAgICAgICAoc2xvd2VzdCwgZm9yIHN0b2NrcyBvbmx5LiBERUZBVUxUKVxuLy9cbi8vICogXCJjYWxjXCIgICAgIC0+IGNhbGN1bGF0ZSBzaGlmdCBiZXR3ZWVuIHN1YiAmIGRhdGFcbi8vICAgICAgICAgICAgICAgICAoZmFzdGVyLCBidXQgb3ZlcmxheSBkYXRhIHNob3VsZCBiZSBwZXJmZWN0bHlcbi8vICAgICAgICAgICAgICAgICAgYWxpZ24gd2l0aCB0aGUgbWFpbiBjaGFydCxcbi8vICAgICAgICAgICAgICAgICAgMS0xIGNhbmRsZS9kYXRhIHBvaW50LiBTdXBwb3J0cyBSZW5rbylcbi8vXG4vLyAqIFwiZGF0YVwiICAgICAtPiBvdmVybGF5IGRhdGEgc2hvdWxkIGNvbWUgd2l0aCBjYW5kbGUgaW5kZXhcbi8vICAgICAgICAgICAgICAgICAoZmFzdGVzdCwgc3VwcG9ydHMgUmVua28pXG5cbnZhciBUSSA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIFRJKCkge1xuICAgIGNsYXNzQ2FsbENoZWNrX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFRJKTtcblxuICAgIHRoaXMuaWIgPSBmYWxzZTtcbiAgfVxuXG4gIGNyZWF0ZUNsYXNzX2NyZWF0ZUNsYXNzKFRJLCBbe1xuICAgIGtleTogXCJpbml0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGluaXQocGFyYW1zLCByZXMpIHtcbiAgICAgIHZhciBzdWIgPSBwYXJhbXMuc3ViLFxuICAgICAgICAgIGludGVydmFsID0gcGFyYW1zLmludGVydmFsLFxuICAgICAgICAgIG1ldGEgPSBwYXJhbXMubWV0YSxcbiAgICAgICAgICAkcCA9IHBhcmFtcy4kcHJvcHMsXG4gICAgICAgICAgaW50ZXJ2YWxfbXMgPSBwYXJhbXMuaW50ZXJ2YWxfbXMsXG4gICAgICAgICAgc3ViX3N0YXJ0ID0gcGFyYW1zLnN1Yl9zdGFydCxcbiAgICAgICAgICBpYiA9IHBhcmFtcy5pYjtcbiAgICAgIHRoaXMudGlfbWFwID0gW107XG4gICAgICB0aGlzLml0X21hcCA9IFtdO1xuICAgICAgdGhpcy5zdWJfaSA9IFtdO1xuICAgICAgdGhpcy5pYiA9IGliO1xuICAgICAgdGhpcy5zdWIgPSByZXM7XG4gICAgICB0aGlzLnNzID0gc3ViX3N0YXJ0O1xuICAgICAgdGhpcy50ZiA9IGludGVydmFsX21zO1xuICAgICAgdmFyIHN0YXJ0ID0gbWV0YS5zdWJfc3RhcnQ7IC8vIFNraXAgbWFwcGluZyBmb3IgdGhlIHJlZ3VsYXIgbW9kZVxuXG4gICAgICBpZiAodGhpcy5pYikge1xuICAgICAgICB0aGlzLm1hcF9zdWIocmVzKTtcbiAgICAgIH1cbiAgICB9IC8vIE1ha2UgbWFwcyBmb3IgdGhlIG1haW4gc3Vic2V0XG5cbiAgfSwge1xuICAgIGtleTogXCJtYXBfc3ViXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG1hcF9zdWIocmVzKSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHJlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgdCA9IHJlc1tpXVswXTtcblxuICAgICAgICB2YXIgX2kgPSB0aGlzLnNzICsgaTtcblxuICAgICAgICB0aGlzLnRpX21hcFt0XSA9IF9pO1xuICAgICAgICB0aGlzLml0X21hcFtfaV0gPSB0OyAvLyBPdmVyd3JpdGUgdCB3aXRoIGlcblxuICAgICAgICB2YXIgY29weSA9IF90b0NvbnN1bWFibGVBcnJheShyZXNbaV0pO1xuXG4gICAgICAgIGNvcHlbMF0gPSBfaTtcbiAgICAgICAgdGhpcy5zdWJfaS5wdXNoKGNvcHkpO1xuICAgICAgfVxuICAgIH0gLy8gTWFwIG92ZXJsYXkgZGF0YVxuICAgIC8vIFRPRE86IHBhcnNlKCkgY2FsbGVkIDMgdGltZXMgaW5zdGVhZCBvZiAyIGZvciAnc3B4X3NhbXBsZS5qc29uJ1xuXG4gIH0sIHtcbiAgICBrZXk6IFwicGFyc2VcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcGFyc2UoZGF0YSwgbW9kZSkge1xuICAgICAgaWYgKCF0aGlzLmliIHx8ICF0aGlzLnN1YlswXSB8fCBtb2RlID09PSAnZGF0YScpIHJldHVybiBkYXRhO1xuICAgICAgdmFyIHJlcyA9IFtdO1xuICAgICAgdmFyIGsgPSAwOyAvLyBDYW5kbGVzdGljayBpbmRleFxuXG4gICAgICBpZiAobW9kZSA9PT0gJ2NhbGMnKSB7XG4gICAgICAgIHZhciBzaGlmdCA9IHV0aWxzLmluZGV4X3NoaWZ0KHRoaXMuc3ViLCBkYXRhKTtcblxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGRhdGEubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICB2YXIgX2kgPSB0aGlzLnNzICsgaTtcblxuICAgICAgICAgIHZhciBjb3B5ID0gX3RvQ29uc3VtYWJsZUFycmF5KGRhdGFbaV0pO1xuXG4gICAgICAgICAgY29weVswXSA9IF9pICsgc2hpZnQ7XG4gICAgICAgICAgcmVzLnB1c2goY29weSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcmVzO1xuICAgICAgfSAvLyBJZiBpbmRpY2F0b3IgZGF0YSBzdGFydHMgYWZ0ZXIgb2hsY3YsIGNhbGMgdGhlIGZpcnN0IGluZGV4XG5cblxuICAgICAgaWYgKGRhdGEubGVuZ3RoKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgdmFyIGsxID0gdXRpbHMuZmFzdF9uZWFyZXN0KHRoaXMuc3ViLCBkYXRhWzBdWzBdKVswXTtcbiAgICAgICAgICBpZiAoazEgIT09IG51bGwgJiYgazEgPj0gMCkgayA9IGsxO1xuICAgICAgICB9IGNhdGNoIChlKSB7fVxuICAgICAgfVxuXG4gICAgICB2YXIgdDAgPSB0aGlzLnN1YlswXVswXTtcbiAgICAgIHZhciB0TiA9IHRoaXMuc3ViW3RoaXMuc3ViLmxlbmd0aCAtIDFdWzBdO1xuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGRhdGEubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIF9jb3B5ID0gX3RvQ29uc3VtYWJsZUFycmF5KGRhdGFbaV0pO1xuXG4gICAgICAgIHZhciB0ayA9IHRoaXMuc3ViW2tdWzBdO1xuICAgICAgICB2YXIgdCA9IGRhdGFbaV1bMF07XG4gICAgICAgIHZhciBpbmRleCA9IHRoaXMudGlfbWFwW3RdO1xuXG4gICAgICAgIGlmIChpbmRleCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgLy8gTGluZWFyIGV4dHJhcG9sYXRpb25cbiAgICAgICAgICBpZiAodCA8IHQwIHx8IHQgPiB0Tikge1xuICAgICAgICAgICAgaW5kZXggPSB0aGlzLnNzICsgayAtICh0ayAtIHQpIC8gdGhpcy50ZjtcbiAgICAgICAgICAgIHQgPSBkYXRhW2kgKyAxXSA/IGRhdGFbaSArIDFdWzBdIDogdW5kZWZpbmVkO1xuICAgICAgICAgIH0gLy8gTGluZWFyIGludGVycG9sYXRpb25cbiAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgdmFyIHRrMiA9IHRoaXMuc3ViW2sgKyAxXVswXTtcbiAgICAgICAgICAgICAgaW5kZXggPSB0ayA9PT0gdGsyID8gdGhpcy5zcyArIGsgOiB0aGlzLnNzICsgayArICh0IC0gdGspIC8gKHRrMiAtIHRrKTtcbiAgICAgICAgICAgICAgdCA9IGRhdGFbaSArIDFdID8gZGF0YVtpICsgMV1bMF0gOiB1bmRlZmluZWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gLy8gUmFjZSBvZiBkYXRhIHBvaW50cyAmIHN1YiBwb2ludHMgKG9obGN2KVxuICAgICAgICAvLyAobGlrZSB0dXJuIGJhc2VkIGluY3JlbWVudHMpXG5cblxuICAgICAgICB3aGlsZSAoayArIDEgPCB0aGlzLnN1Yi5sZW5ndGggLSAxICYmIHQgPiB0aGlzLnN1YltrICsgMV1bMF0pIHtcbiAgICAgICAgICBrKys7XG4gICAgICAgICAgdGsgPSB0aGlzLnN1YltrXVswXTtcbiAgICAgICAgfVxuXG4gICAgICAgIF9jb3B5WzBdID0gaW5kZXg7XG4gICAgICAgIHJlcy5wdXNoKF9jb3B5KTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHJlcztcbiAgICB9IC8vIGluZGV4ID0+IHRpbWVcblxuICB9LCB7XG4gICAga2V5OiBcImkydFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBpMnQoaSkge1xuICAgICAgaWYgKCF0aGlzLmliIHx8ICF0aGlzLnN1Yi5sZW5ndGgpIHJldHVybiBpOyAvLyBSZWd1bGFyIG1vZGVcbiAgICAgIC8vIERpc2NyZXRlIG1hcHBpbmdcblxuICAgICAgdmFyIHJlcyA9IHRoaXMuaXRfbWFwW2ldO1xuICAgICAgaWYgKHJlcyAhPT0gdW5kZWZpbmVkKSByZXR1cm4gcmVzOyAvLyBMaW5lYXIgZXh0cmFwb2xhdGlvblxuICAgICAgZWxzZSBpZiAoaSA+PSB0aGlzLnNzICsgdGhpcy5zdWJfaS5sZW5ndGgpIHtcbiAgICAgICAgICB2YXIgZGkgPSBpIC0gKHRoaXMuc3MgKyB0aGlzLnN1Yl9pLmxlbmd0aCkgKyAxO1xuICAgICAgICAgIHZhciBsYXN0ID0gdGhpcy5zdWJbdGhpcy5zdWIubGVuZ3RoIC0gMV07XG4gICAgICAgICAgcmV0dXJuIGxhc3RbMF0gKyBkaSAqIHRoaXMudGY7XG4gICAgICAgIH0gZWxzZSBpZiAoaSA8IHRoaXMuc3MpIHtcbiAgICAgICAgICB2YXIgX2RpID0gaSAtIHRoaXMuc3M7XG5cbiAgICAgICAgICByZXR1cm4gdGhpcy5zdWJbMF1bMF0gKyBfZGkgKiB0aGlzLnRmO1xuICAgICAgICB9IC8vIExpbmVhciBJbnRlcnBvbGF0aW9uXG5cbiAgICAgIHZhciBpMSA9IE1hdGguZmxvb3IoaSkgLSB0aGlzLnNzO1xuICAgICAgdmFyIGkyID0gaTEgKyAxO1xuICAgICAgdmFyIGxlbiA9IHRoaXMuc3ViLmxlbmd0aDtcbiAgICAgIGlmIChpMiA+PSBsZW4pIGkyID0gbGVuIC0gMTtcbiAgICAgIHZhciBzdWIxID0gdGhpcy5zdWJbaTFdO1xuICAgICAgdmFyIHN1YjIgPSB0aGlzLnN1YltpMl07XG5cbiAgICAgIGlmIChzdWIxICYmIHN1YjIpIHtcbiAgICAgICAgdmFyIHQxID0gc3ViMVswXTtcbiAgICAgICAgdmFyIHQyID0gc3ViMlswXTtcbiAgICAgICAgcmV0dXJuIHQxICsgKHQyIC0gdDEpICogKGkgLSBpMSAtIHRoaXMuc3MpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH0gLy8gTWFwIG9yIGJ5cGFzcyBkZXBlbmRpbmcgb24gdGhlIG1vZGVcblxuICB9LCB7XG4gICAga2V5OiBcImkydF9tb2RlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGkydF9tb2RlKGksIG1vZGUpIHtcbiAgICAgIHJldHVybiBtb2RlID09PSAnZGF0YScgPyBpIDogdGhpcy5pMnQoaSk7XG4gICAgfSAvLyB0aW1lID0+IGluZGV4XG4gICAgLy8gVE9ETzogd2hlbiBzd2l0Y2ggZnJvbSBJQiBtb2RlIHRvIHJlZ3VsYXIgdG9vbHNcbiAgICAvLyBkaXNhcHBlYXIgKGJjIHRoZXJlIGlzIG5vIG1vcmUgbWFwcGluZylcblxuICB9LCB7XG4gICAga2V5OiBcInQyaVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB0MmkodCkge1xuICAgICAgaWYgKCF0aGlzLnN1Yi5sZW5ndGgpIHJldHVybiB1bmRlZmluZWQ7IC8vIERpc2NyZXRlIG1hcHBpbmdcblxuICAgICAgdmFyIHJlcyA9IHRoaXMudGlfbWFwW3RdO1xuICAgICAgaWYgKHJlcyAhPT0gdW5kZWZpbmVkKSByZXR1cm4gcmVzO1xuICAgICAgdmFyIHQwID0gdGhpcy5zdWJbMF1bMF07XG4gICAgICB2YXIgdE4gPSB0aGlzLnN1Ylt0aGlzLnN1Yi5sZW5ndGggLSAxXVswXTsgLy8gTGluZWFyIGV4dHJhcG9sYXRpb25cblxuICAgICAgaWYgKHQgPCB0MCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zcyAtICh0MCAtIHQpIC8gdGhpcy50ZjtcbiAgICAgIH0gZWxzZSBpZiAodCA+IHROKSB7XG4gICAgICAgIHZhciBrID0gdGhpcy5zdWIubGVuZ3RoIC0gMTtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3MgKyBrIC0gKHROIC0gdCkgLyB0aGlzLnRmO1xuICAgICAgfVxuXG4gICAgICB0cnkge1xuICAgICAgICAvLyBMaW5lYXIgSW50ZXJwb2xhdGlvblxuICAgICAgICB2YXIgaSA9IHV0aWxzLmZhc3RfbmVhcmVzdCh0aGlzLnN1YiwgdCk7XG4gICAgICAgIHZhciB0ayA9IHRoaXMuc3ViW2lbMF1dWzBdO1xuICAgICAgICB2YXIgdGsyID0gdGhpcy5zdWJbaVsxXV1bMF07XG5cbiAgICAgICAgdmFyIF9rID0gKHQgLSB0aykgLyAodGsyIC0gdGspO1xuXG4gICAgICAgIHJldHVybiB0aGlzLnNzICsgaVswXSArIF9rICogKGlbMV0gLSBpWzBdKTtcbiAgICAgIH0gY2F0Y2ggKGUpIHt9XG5cbiAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfSAvLyBBdXRvIGRldGVjdDogaXMgaXQgdGltZSBvciBpbmRleD9cbiAgICAvLyBBc3N1bWluZyB0aGF0IGluZGV4LWJhc2VkIG1vZGUgaXMgT05cblxuICB9LCB7XG4gICAga2V5OiBcInNtdGgyaVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzbXRoMmkoc210aCkge1xuICAgICAgaWYgKHNtdGggPiBNQVhfQVJSKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnQyaShzbXRoKTsgLy8gaXQgd2FzIHRpbWVcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIHNtdGg7IC8vIGl0IHdhcyBhbiBpbmRleFxuICAgICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInNtdGgydFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzbXRoMnQoc210aCkge1xuICAgICAgaWYgKHNtdGggPCBNQVhfQVJSKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmkydChzbXRoKTsgLy8gaXQgd2FzIGFuIGluZGV4XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiBzbXRoOyAvLyBpdCB3YXMgdGltZVxuICAgICAgICB9XG4gICAgfSAvLyBHbG9iYWwgVGltZSA9PiBJbmRleCAodXNlcyBhbGwgZGF0YSwgYXBwcm94LiBtZXRob2QpXG4gICAgLy8gVXNlZCBieSB0di5nb3RvKClcblxuICB9LCB7XG4gICAga2V5OiBcImd0MmlcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ3QyaShzbXRoLCBvaGxjdikge1xuICAgICAgaWYgKHNtdGggPiBNQVhfQVJSKSB7XG4gICAgICAgIHZhciBFID0gMC4xOyAvLyBGaXhlcyB0aGUgYXJyYXlzbGljZXIgYnVnXG5cbiAgICAgICAgdmFyIF9VdGlscyRmYXN0X25lYXJlc3QgPSB1dGlscy5mYXN0X25lYXJlc3Qob2hsY3YsIHNtdGggKyBFKSxcbiAgICAgICAgICAgIF9VdGlscyRmYXN0X25lYXJlc3QyID0gX3NsaWNlZFRvQXJyYXkoX1V0aWxzJGZhc3RfbmVhcmVzdCwgMiksXG4gICAgICAgICAgICBpMSA9IF9VdGlscyRmYXN0X25lYXJlc3QyWzBdLFxuICAgICAgICAgICAgaTIgPSBfVXRpbHMkZmFzdF9uZWFyZXN0MlsxXTtcblxuICAgICAgICBpZiAodHlwZW9mIGkxID09PSAnbnVtYmVyJykge1xuICAgICAgICAgIHJldHVybiBpMTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy50Mmkoc210aCk7IC8vIGZhbGxiYWNrXG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIHNtdGg7IC8vIGl0IHdhcyBhbiBpbmRleFxuICAgICAgICB9XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIFRJO1xufSgpO1xuXG5cbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL25vZGVfbW9kdWxlcy9iYWJlbC1sb2FkZXIvbGliL2luZGV4LmpzIS4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL2luZGV4LmpzPz92dWUtbG9hZGVyLW9wdGlvbnMhLi9zcmMvY29tcG9uZW50cy9DaGFydC52dWU/dnVlJnR5cGU9c2NyaXB0Jmxhbmc9anMmXG5cblxuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cblxuXG5cblxuXG5cblxuXG5cblxuXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIGNvbnN0IENoYXJ0dnVlX3R5cGVfc2NyaXB0X2xhbmdfanNfID0gKHtcbiAgbmFtZTogJ0NoYXJ0JyxcbiAgcHJvcHM6IFsndGl0bGVfdHh0JywgJ2RhdGEnLCAnd2lkdGgnLCAnaGVpZ2h0JywgJ2ZvbnQnLCAnY29sb3JzJywgJ292ZXJsYXlzJywgJ3R2X2lkJywgJ2NvbmZpZycsICdidXR0b25zJywgJ3Rvb2xiYXInLCAnaWInLCAnc2tpbicsICd0aW1lem9uZSddLFxuICBtaXhpbnM6IFtzaGFkZXJzLCBkYXRhdHJhY2tdLFxuICBjb21wb25lbnRzOiB7XG4gICAgR3JpZFNlY3Rpb246IFNlY3Rpb24sXG4gICAgQm90YmFyOiBjb21wb25lbnRzX0JvdGJhcixcbiAgICBLZXlib2FyZDogS2V5Ym9hcmRcbiAgfSxcbiAgY3JlYXRlZDogZnVuY3Rpb24gY3JlYXRlZCgpIHtcbiAgICAvLyBDb250ZXh0IGZvciB0ZXh0IG1lYXN1cmVtZW50c1xuICAgIHRoaXMuY3R4ID0gbmV3IGNvbnRleHQodGhpcy4kcHJvcHMpOyAvLyBJbml0aWFsIGxheW91dCAoQWxsIG1lYXN1cm1lbnRzIGZvciB0aGUgY2hhcnQpXG5cbiAgICB0aGlzLmluaXRfcmFuZ2UoKTtcbiAgICB0aGlzLnN1YiA9IHRoaXMuc3Vic2V0KCk7XG4gICAgdXRpbHMub3ZlcndyaXRlKHRoaXMucmFuZ2UsIHRoaXMucmFuZ2UpOyAvLyBGaXggZm9yIElCIG1vZGVcblxuICAgIHRoaXMuX2xheW91dCA9IG5ldyBsYXlvdXQodGhpcyk7IC8vIFVwZGF0ZXMgY3VycmVudCBjdXJzb3IgdmFsdWVzXG5cbiAgICB0aGlzLnVwZGF0ZXIgPSBuZXcgdXBkYXRlcih0aGlzKTtcbiAgICB0aGlzLnVwZGF0ZV9sYXN0X3ZhbHVlcygpO1xuICAgIHRoaXMuaW5pdF9zaGFkZXJzKHRoaXMuc2tpbik7XG4gIH0sXG4gIG1ldGhvZHM6IHtcbiAgICByYW5nZV9jaGFuZ2VkOiBmdW5jdGlvbiByYW5nZV9jaGFuZ2VkKHIpIHtcbiAgICAgIC8vIE92ZXJ3aXRlICYga2VlcCB0aGUgb3JpZ2luYWwgcmVmZXJlbmNlc1xuICAgICAgLy8gUXVpY2sgZml4IGZvciBJQiBtb2RlIChzd2l0Y2ggMiBuZXh0IGxpbmVzKVxuICAgICAgLy8gVE9ETzogd3RmP1xuICAgICAgdmFyIHN1YiA9IHRoaXMuc3Vic2V0KHIpO1xuICAgICAgdXRpbHMub3ZlcndyaXRlKHRoaXMucmFuZ2UsIHIpO1xuICAgICAgdXRpbHMub3ZlcndyaXRlKHRoaXMuc3ViLCBzdWIpO1xuICAgICAgdGhpcy51cGRhdGVfbGF5b3V0KCk7XG4gICAgICB0aGlzLiRlbWl0KCdyYW5nZS1jaGFuZ2VkJywgcik7XG4gICAgICBpZiAodGhpcy4kcHJvcHMuaWIpIHRoaXMuc2F2ZV9kYXRhX3QoKTtcbiAgICB9LFxuICAgIFwiZ290b1wiOiBmdW5jdGlvbiBnb3RvKHQpIHtcbiAgICAgIHZhciBkdCA9IHRoaXMucmFuZ2VbMV0gLSB0aGlzLnJhbmdlWzBdO1xuICAgICAgdGhpcy5yYW5nZV9jaGFuZ2VkKFt0IC0gZHQsIHRdKTtcbiAgICB9LFxuICAgIHNldFJhbmdlOiBmdW5jdGlvbiBzZXRSYW5nZSh0MSwgdDIpIHtcbiAgICAgIHRoaXMucmFuZ2VfY2hhbmdlZChbdDEsIHQyXSk7XG4gICAgfSxcbiAgICBjdXJzb3JfY2hhbmdlZDogZnVuY3Rpb24gY3Vyc29yX2NoYW5nZWQoZSkge1xuICAgICAgaWYgKGUubW9kZSkgdGhpcy5jdXJzb3IubW9kZSA9IGUubW9kZTtcblxuICAgICAgaWYgKHRoaXMuY3Vyc29yLm1vZGUgIT09ICdleHBsb3JlJykge1xuICAgICAgICB0aGlzLnVwZGF0ZXIuc3luYyhlKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMuX2hvb2tfeGNoYW5nZWQpIHRoaXMuY2UoJz94LWNoYW5nZWQnLCBlKTtcbiAgICB9LFxuICAgIGN1cnNvcl9sb2NrZWQ6IGZ1bmN0aW9uIGN1cnNvcl9sb2NrZWQoc3RhdGUpIHtcbiAgICAgIGlmICh0aGlzLmN1cnNvci5zY3JvbGxfbG9jayAmJiBzdGF0ZSkgcmV0dXJuO1xuICAgICAgdGhpcy5jdXJzb3IubG9ja2VkID0gc3RhdGU7XG4gICAgICBpZiAodGhpcy5faG9va194bG9ja2VkKSB0aGlzLmNlKCc/eC1sb2NrZWQnLCBzdGF0ZSk7XG4gICAgfSxcbiAgICBjYWxjX2ludGVydmFsOiBmdW5jdGlvbiBjYWxjX2ludGVydmFsKCkge1xuICAgICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgICAgdmFyIHRmID0gdXRpbHMucGFyc2VfdGYodGhpcy5mb3JjZWRfdGYpO1xuICAgICAgaWYgKHRoaXMub2hsY3YubGVuZ3RoIDwgMiAmJiAhdGYpIHJldHVybjtcbiAgICAgIHRoaXMuaW50ZXJ2YWxfbXMgPSB0ZiB8fCB1dGlscy5kZXRlY3RfaW50ZXJ2YWwodGhpcy5vaGxjdik7XG4gICAgICB0aGlzLmludGVydmFsID0gdGhpcy4kcHJvcHMuaWIgPyAxIDogdGhpcy5pbnRlcnZhbF9tcztcbiAgICAgIHV0aWxzLndhcm4oZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gX3RoaXMuJHByb3BzLmliICYmICFfdGhpcy5jaGFydC50ZjtcbiAgICAgIH0sIGNvbnN0YW50cy5JQl9URl9XQVJOLCBjb25zdGFudHMuU0VDT05EKTtcbiAgICB9LFxuICAgIHNldF95dHJhbnNmb3JtOiBmdW5jdGlvbiBzZXRfeXRyYW5zZm9ybShzKSB7XG4gICAgICB2YXIgb2JqID0gdGhpcy55X3RyYW5zZm9ybXNbcy5ncmlkX2lkXSB8fCB7fTtcbiAgICAgIE9iamVjdC5hc3NpZ24ob2JqLCBzKTtcbiAgICAgIHRoaXMuJHNldCh0aGlzLnlfdHJhbnNmb3Jtcywgcy5ncmlkX2lkLCBvYmopO1xuICAgICAgdGhpcy51cGRhdGVfbGF5b3V0KCk7XG4gICAgICB1dGlscy5vdmVyd3JpdGUodGhpcy5yYW5nZSwgdGhpcy5yYW5nZSk7XG4gICAgfSxcbiAgICBkZWZhdWx0X3JhbmdlOiBmdW5jdGlvbiBkZWZhdWx0X3JhbmdlKCkge1xuICAgICAgdmFyIGRsID0gdGhpcy4kcHJvcHMuY29uZmlnLkRFRkFVTFRfTEVOO1xuICAgICAgdmFyIG1sID0gdGhpcy4kcHJvcHMuY29uZmlnLk1JTklNVU1fTEVOICsgMC41O1xuICAgICAgdmFyIGwgPSB0aGlzLm9obGN2Lmxlbmd0aCAtIDE7XG4gICAgICBpZiAodGhpcy5vaGxjdi5sZW5ndGggPCAyKSByZXR1cm47XG5cbiAgICAgIGlmICh0aGlzLm9obGN2Lmxlbmd0aCA8PSBkbCkge1xuICAgICAgICB2YXIgcyA9IDAsXG4gICAgICAgICAgICBkID0gbWw7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzID0gbCAtIGRsLCBkID0gMC41O1xuICAgICAgfVxuXG4gICAgICBpZiAoIXRoaXMuJHByb3BzLmliKSB7XG4gICAgICAgIHV0aWxzLm92ZXJ3cml0ZSh0aGlzLnJhbmdlLCBbdGhpcy5vaGxjdltzXVswXSAtIHRoaXMuaW50ZXJ2YWwgKiBkLCB0aGlzLm9obGN2W2xdWzBdICsgdGhpcy5pbnRlcnZhbCAqIG1sXSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB1dGlscy5vdmVyd3JpdGUodGhpcy5yYW5nZSwgW3MgLSB0aGlzLmludGVydmFsICogZCwgbCArIHRoaXMuaW50ZXJ2YWwgKiBtbF0pO1xuICAgICAgfVxuICAgIH0sXG4gICAgc3Vic2V0OiBmdW5jdGlvbiBzdWJzZXQocmFuZ2UpIHtcbiAgICAgIGlmIChyYW5nZSA9PT0gdm9pZCAwKSB7XG4gICAgICAgIHJhbmdlID0gdGhpcy5yYW5nZTtcbiAgICAgIH1cblxuICAgICAgdmFyIF90aGlzJGZpbHRlciA9IHRoaXMuZmlsdGVyKHRoaXMub2hsY3YsIHJhbmdlWzBdIC0gdGhpcy5pbnRlcnZhbCwgcmFuZ2VbMV0pLFxuICAgICAgICAgIF90aGlzJGZpbHRlcjIgPSBfc2xpY2VkVG9BcnJheShfdGhpcyRmaWx0ZXIsIDIpLFxuICAgICAgICAgIHJlcyA9IF90aGlzJGZpbHRlcjJbMF0sXG4gICAgICAgICAgaW5kZXggPSBfdGhpcyRmaWx0ZXIyWzFdO1xuXG4gICAgICB0aGlzLnRpX21hcCA9IG5ldyBUSSgpO1xuXG4gICAgICBpZiAocmVzKSB7XG4gICAgICAgIHRoaXMuc3ViX3N0YXJ0ID0gaW5kZXg7XG4gICAgICAgIHRoaXMudGlfbWFwLmluaXQodGhpcywgcmVzKTtcbiAgICAgICAgaWYgKCF0aGlzLiRwcm9wcy5pYikgcmV0dXJuIHJlcyB8fCBbXTtcbiAgICAgICAgcmV0dXJuIHRoaXMudGlfbWFwLnN1Yl9pO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gW107XG4gICAgfSxcbiAgICBjb21tb25fcHJvcHM6IGZ1bmN0aW9uIGNvbW1vbl9wcm9wcygpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHRpdGxlX3R4dDogdGhpcy5jaGFydC5uYW1lIHx8IHRoaXMuJHByb3BzLnRpdGxlX3R4dCxcbiAgICAgICAgbGF5b3V0OiB0aGlzLl9sYXlvdXQsXG4gICAgICAgIHN1YjogdGhpcy5zdWIsXG4gICAgICAgIHJhbmdlOiB0aGlzLnJhbmdlLFxuICAgICAgICBpbnRlcnZhbDogdGhpcy5pbnRlcnZhbCxcbiAgICAgICAgY3Vyc29yOiB0aGlzLmN1cnNvcixcbiAgICAgICAgY29sb3JzOiB0aGlzLiRwcm9wcy5jb2xvcnMsXG4gICAgICAgIGZvbnQ6IHRoaXMuJHByb3BzLmZvbnQsXG4gICAgICAgIHlfdHM6IHRoaXMueV90cmFuc2Zvcm1zLFxuICAgICAgICB0dl9pZDogdGhpcy4kcHJvcHMudHZfaWQsXG4gICAgICAgIGNvbmZpZzogdGhpcy4kcHJvcHMuY29uZmlnLFxuICAgICAgICBidXR0b25zOiB0aGlzLiRwcm9wcy5idXR0b25zLFxuICAgICAgICBtZXRhOiB0aGlzLm1ldGEsXG4gICAgICAgIHNraW46IHRoaXMuJHByb3BzLnNraW5cbiAgICAgIH07XG4gICAgfSxcbiAgICBvdmVybGF5X3N1YnNldDogZnVuY3Rpb24gb3ZlcmxheV9zdWJzZXQoc291cmNlLCBzaWRlKSB7XG4gICAgICB2YXIgX3RoaXMyID0gdGhpcztcblxuICAgICAgcmV0dXJuIHNvdXJjZS5tYXAoZnVuY3Rpb24gKGQsIGkpIHtcbiAgICAgICAgdmFyIHJlcyA9IHV0aWxzLmZhc3RfZmlsdGVyKGQuZGF0YSwgX3RoaXMyLnRpX21hcC5pMnRfbW9kZShfdGhpczIucmFuZ2VbMF0gLSBfdGhpczIuaW50ZXJ2YWwsIGQuaW5kZXhTcmMpLCBfdGhpczIudGlfbWFwLmkydF9tb2RlKF90aGlzMi5yYW5nZVsxXSwgZC5pbmRleFNyYykpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHR5cGU6IGQudHlwZSxcbiAgICAgICAgICBuYW1lOiB1dGlscy5mb3JtYXRfbmFtZShkKSxcbiAgICAgICAgICBkYXRhOiBfdGhpczIudGlfbWFwLnBhcnNlKHJlc1swXSB8fCBbXSwgZC5pbmRleFNyYyB8fCAnbWFwJyksXG4gICAgICAgICAgc2V0dGluZ3M6IGQuc2V0dGluZ3MgfHwgX3RoaXMyLnNldHRpbmdzX292LFxuICAgICAgICAgIGdyaWQ6IGQuZ3JpZCB8fCB7fSxcbiAgICAgICAgICB0ZjogdXRpbHMucGFyc2VfdGYoZC50ZiksXG4gICAgICAgICAgaTA6IHJlc1sxXSxcbiAgICAgICAgICBsb2FkaW5nOiBkLmxvYWRpbmcsXG4gICAgICAgICAgbGFzdDogKF90aGlzMi5sYXN0X3ZhbHVlc1tzaWRlXSB8fCBbXSlbaV1cbiAgICAgICAgfTtcbiAgICAgIH0pO1xuICAgIH0sXG4gICAgc2VjdGlvbl9wcm9wczogZnVuY3Rpb24gc2VjdGlvbl9wcm9wcyhpKSB7XG4gICAgICByZXR1cm4gaSA9PT0gMCA/IHRoaXMubWFpbl9zZWN0aW9uIDogdGhpcy5zdWJfc2VjdGlvbjtcbiAgICB9LFxuICAgIGluaXRfcmFuZ2U6IGZ1bmN0aW9uIGluaXRfcmFuZ2UoKSB7XG4gICAgICB0aGlzLmNhbGNfaW50ZXJ2YWwoKTtcbiAgICAgIHRoaXMuZGVmYXVsdF9yYW5nZSgpO1xuICAgIH0sXG4gICAgbGF5ZXJfbWV0YV9wcm9wczogZnVuY3Rpb24gbGF5ZXJfbWV0YV9wcm9wcyhkKSB7XG4gICAgICAvLyBUT0RPOiBjaGVjayByZWFjdGl2aXR5IHdoZW4gbGF5b3V0IGlzIGNoYW5nZWRcbiAgICAgIGlmICghKGQuZ3JpZF9pZCBpbiB0aGlzLmxheWVyc19tZXRhKSkge1xuICAgICAgICB0aGlzLiRzZXQodGhpcy5sYXllcnNfbWV0YSwgZC5ncmlkX2lkLCB7fSk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuJHNldCh0aGlzLmxheWVyc19tZXRhW2QuZ3JpZF9pZF0sIGQubGF5ZXJfaWQsIGQpOyAvLyBSZXJlbmRlclxuXG4gICAgICB0aGlzLnVwZGF0ZV9sYXlvdXQoKTtcbiAgICB9LFxuICAgIHJlbW92ZV9tZXRhX3Byb3BzOiBmdW5jdGlvbiByZW1vdmVfbWV0YV9wcm9wcyhncmlkX2lkLCBsYXllcl9pZCkge1xuICAgICAgaWYgKGdyaWRfaWQgaW4gdGhpcy5sYXllcnNfbWV0YSkge1xuICAgICAgICB0aGlzLiRkZWxldGUodGhpcy5sYXllcnNfbWV0YVtncmlkX2lkXSwgbGF5ZXJfaWQpO1xuICAgICAgfVxuICAgIH0sXG4gICAgZW1pdF9jdXN0b21fZXZlbnQ6IGZ1bmN0aW9uIGVtaXRfY3VzdG9tX2V2ZW50KGQpIHtcbiAgICAgIHRoaXMub25fc2hhZGVyX2V2ZW50KGQsICdib3RiYXInKTtcbiAgICAgIHRoaXMuJGVtaXQoJ2N1c3RvbS1ldmVudCcsIGQpO1xuXG4gICAgICBpZiAoZC5ldmVudCA9PT0gJ3JlbW92ZS1sYXllci1tZXRhJykge1xuICAgICAgICB0aGlzLnJlbW92ZV9tZXRhX3Byb3BzLmFwcGx5KHRoaXMsIF90b0NvbnN1bWFibGVBcnJheShkLmFyZ3MpKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIHVwZGF0ZV9sYXlvdXQ6IGZ1bmN0aW9uIHVwZGF0ZV9sYXlvdXQoY2xhY190Zikge1xuICAgICAgaWYgKGNsYWNfdGYpIHRoaXMuY2FsY19pbnRlcnZhbCgpO1xuICAgICAgdmFyIGxheSA9IG5ldyBsYXlvdXQodGhpcyk7XG4gICAgICB1dGlscy5jb3B5X2xheW91dCh0aGlzLl9sYXlvdXQsIGxheSk7XG4gICAgICBpZiAodGhpcy5faG9va191cGRhdGUpIHRoaXMuY2UoJz9jaGFydC11cGRhdGUnLCBsYXkpO1xuICAgIH0sXG4gICAgbGVnZW5kX2J1dHRvbl9jbGljazogZnVuY3Rpb24gbGVnZW5kX2J1dHRvbl9jbGljayhldmVudCkge1xuICAgICAgdGhpcy4kZW1pdCgnbGVnZW5kLWJ1dHRvbi1jbGljaycsIGV2ZW50KTtcbiAgICB9LFxuICAgIHJlZ2lzdGVyX2tiOiBmdW5jdGlvbiByZWdpc3Rlcl9rYihldmVudCkge1xuICAgICAgaWYgKCF0aGlzLiRyZWZzLmtleWJvYXJkKSByZXR1cm47XG4gICAgICB0aGlzLiRyZWZzLmtleWJvYXJkLnJlZ2lzdGVyKGV2ZW50KTtcbiAgICB9LFxuICAgIHJlbW92ZV9rYjogZnVuY3Rpb24gcmVtb3ZlX2tiKGV2ZW50KSB7XG4gICAgICBpZiAoIXRoaXMuJHJlZnMua2V5Ym9hcmQpIHJldHVybjtcbiAgICAgIHRoaXMuJHJlZnMua2V5Ym9hcmQucmVtb3ZlKGV2ZW50KTtcbiAgICB9LFxuICAgIHVwZGF0ZV9sYXN0X3ZhbHVlczogZnVuY3Rpb24gdXBkYXRlX2xhc3RfdmFsdWVzKCkge1xuICAgICAgdmFyIF90aGlzMyA9IHRoaXM7XG5cbiAgICAgIHRoaXMubGFzdF9jYW5kbGUgPSB0aGlzLm9obGN2ID8gdGhpcy5vaGxjdlt0aGlzLm9obGN2Lmxlbmd0aCAtIDFdIDogdW5kZWZpbmVkO1xuICAgICAgdGhpcy5sYXN0X3ZhbHVlcyA9IHtcbiAgICAgICAgb25jaGFydDogW10sXG4gICAgICAgIG9mZmNoYXJ0OiBbXVxuICAgICAgfTtcbiAgICAgIHRoaXMub25jaGFydC5mb3JFYWNoKGZ1bmN0aW9uICh4LCBpKSB7XG4gICAgICAgIHZhciBkID0geC5kYXRhIHx8IFtdO1xuICAgICAgICBfdGhpczMubGFzdF92YWx1ZXMub25jaGFydFtpXSA9IGRbZC5sZW5ndGggLSAxXTtcbiAgICAgIH0pO1xuICAgICAgdGhpcy5vZmZjaGFydC5mb3JFYWNoKGZ1bmN0aW9uICh4LCBpKSB7XG4gICAgICAgIHZhciBkID0geC5kYXRhIHx8IFtdO1xuICAgICAgICBfdGhpczMubGFzdF92YWx1ZXMub2ZmY2hhcnRbaV0gPSBkW2QubGVuZ3RoIC0gMV07XG4gICAgICB9KTtcbiAgICB9LFxuICAgIC8vIEhvb2sgZXZlbnRzIGZvciBleHRlbnNpb25zXG4gICAgY2U6IGZ1bmN0aW9uIGNlKGV2ZW50KSB7XG4gICAgICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuID4gMSA/IF9sZW4gLSAxIDogMCksIF9rZXkgPSAxOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgICAgIGFyZ3NbX2tleSAtIDFdID0gYXJndW1lbnRzW19rZXldO1xuICAgICAgfVxuXG4gICAgICB0aGlzLmVtaXRfY3VzdG9tX2V2ZW50KHtcbiAgICAgICAgZXZlbnQ6IGV2ZW50LFxuICAgICAgICBhcmdzOiBhcmdzXG4gICAgICB9KTtcbiAgICB9LFxuICAgIC8vIFNldCBob29rcyBsaXN0IChjYWxsZWQgZnJvbSBhbiBleHRlbnNpb24pXG4gICAgaG9va3M6IGZ1bmN0aW9uIGhvb2tzKCkge1xuICAgICAgdmFyIF90aGlzNCA9IHRoaXM7XG5cbiAgICAgIGZvciAodmFyIF9sZW4yID0gYXJndW1lbnRzLmxlbmd0aCwgbGlzdCA9IG5ldyBBcnJheShfbGVuMiksIF9rZXkyID0gMDsgX2tleTIgPCBfbGVuMjsgX2tleTIrKykge1xuICAgICAgICBsaXN0W19rZXkyXSA9IGFyZ3VtZW50c1tfa2V5Ml07XG4gICAgICB9XG5cbiAgICAgIGxpc3QuZm9yRWFjaChmdW5jdGlvbiAoeCkge1xuICAgICAgICByZXR1cm4gX3RoaXM0W1wiX2hvb2tfXCIuY29uY2F0KHgpXSA9IHRydWU7XG4gICAgICB9KTtcbiAgICB9XG4gIH0sXG4gIGNvbXB1dGVkOiB7XG4gICAgLy8gQ29tcG9uZW50LXNwZWNpZmljIHByb3BzIHN1YnNldHM6XG4gICAgbWFpbl9zZWN0aW9uOiBmdW5jdGlvbiBtYWluX3NlY3Rpb24oKSB7XG4gICAgICB2YXIgcCA9IE9iamVjdC5hc3NpZ24oe30sIHRoaXMuY29tbW9uX3Byb3BzKCkpO1xuICAgICAgcC5kYXRhID0gdGhpcy5vdmVybGF5X3N1YnNldCh0aGlzLm9uY2hhcnQsICdvbmNoYXJ0Jyk7XG4gICAgICBwLmRhdGEucHVzaCh7XG4gICAgICAgIHR5cGU6IHRoaXMuY2hhcnQudHlwZSB8fCAnQ2FuZGxlcycsXG4gICAgICAgIG1haW46IHRydWUsXG4gICAgICAgIGRhdGE6IHRoaXMuc3ViLFxuICAgICAgICBpMDogdGhpcy5zdWJfc3RhcnQsXG4gICAgICAgIHNldHRpbmdzOiB0aGlzLmNoYXJ0LnNldHRpbmdzIHx8IHRoaXMuc2V0dGluZ3Nfb2hsY3YsXG4gICAgICAgIGdyaWQ6IHRoaXMuY2hhcnQuZ3JpZCB8fCB7fSxcbiAgICAgICAgbGFzdDogdGhpcy5sYXN0X2NhbmRsZVxuICAgICAgfSk7XG4gICAgICBwLm92ZXJsYXlzID0gdGhpcy4kcHJvcHMub3ZlcmxheXM7XG4gICAgICByZXR1cm4gcDtcbiAgICB9LFxuICAgIHN1Yl9zZWN0aW9uOiBmdW5jdGlvbiBzdWJfc2VjdGlvbigpIHtcbiAgICAgIHZhciBwID0gT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5jb21tb25fcHJvcHMoKSk7XG4gICAgICBwLmRhdGEgPSB0aGlzLm92ZXJsYXlfc3Vic2V0KHRoaXMub2ZmY2hhcnQsICdvZmZjaGFydCcpO1xuICAgICAgcC5vdmVybGF5cyA9IHRoaXMuJHByb3BzLm92ZXJsYXlzO1xuICAgICAgcmV0dXJuIHA7XG4gICAgfSxcbiAgICBib3RiYXJfcHJvcHM6IGZ1bmN0aW9uIGJvdGJhcl9wcm9wcygpIHtcbiAgICAgIHZhciBwID0gT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5jb21tb25fcHJvcHMoKSk7XG4gICAgICBwLndpZHRoID0gcC5sYXlvdXQuYm90YmFyLndpZHRoO1xuICAgICAgcC5oZWlnaHQgPSBwLmxheW91dC5ib3RiYXIuaGVpZ2h0O1xuICAgICAgcC5yZXJlbmRlciA9IHRoaXMucmVyZW5kZXI7XG4gICAgICByZXR1cm4gcDtcbiAgICB9LFxuICAgIG9mZnN1YjogZnVuY3Rpb24gb2Zmc3ViKCkge1xuICAgICAgcmV0dXJuIHRoaXMub3ZlcmxheV9zdWJzZXQodGhpcy5vZmZjaGFydCwgJ29mZmNoYXJ0Jyk7XG4gICAgfSxcbiAgICAvLyBEYXRhc2V0czogY2FuZGxlcywgb25jaGFydCwgb2ZmY2hhcnQgaW5kaWNhdG9yc1xuICAgIG9obGN2OiBmdW5jdGlvbiBvaGxjdigpIHtcbiAgICAgIHJldHVybiB0aGlzLiRwcm9wcy5kYXRhLm9obGN2IHx8IHRoaXMuY2hhcnQuZGF0YSB8fCBbXTtcbiAgICB9LFxuICAgIGNoYXJ0OiBmdW5jdGlvbiBjaGFydCgpIHtcbiAgICAgIHJldHVybiB0aGlzLiRwcm9wcy5kYXRhLmNoYXJ0IHx8IHtcbiAgICAgICAgZ3JpZDoge31cbiAgICAgIH07XG4gICAgfSxcbiAgICBvbmNoYXJ0OiBmdW5jdGlvbiBvbmNoYXJ0KCkge1xuICAgICAgcmV0dXJuIHRoaXMuJHByb3BzLmRhdGEub25jaGFydCB8fCBbXTtcbiAgICB9LFxuICAgIG9mZmNoYXJ0OiBmdW5jdGlvbiBvZmZjaGFydCgpIHtcbiAgICAgIHJldHVybiB0aGlzLiRwcm9wcy5kYXRhLm9mZmNoYXJ0IHx8IFtdO1xuICAgIH0sXG4gICAgZmlsdGVyOiBmdW5jdGlvbiBmaWx0ZXIoKSB7XG4gICAgICByZXR1cm4gdGhpcy4kcHJvcHMuaWIgPyB1dGlscy5mYXN0X2ZpbHRlcl9pIDogdXRpbHMuZmFzdF9maWx0ZXI7XG4gICAgfSxcbiAgICBzdHlsZXM6IGZ1bmN0aW9uIHN0eWxlcygpIHtcbiAgICAgIHZhciB3ID0gdGhpcy4kcHJvcHMudG9vbGJhciA/IHRoaXMuJHByb3BzLmNvbmZpZy5UT09MQkFSIDogMDtcbiAgICAgIHJldHVybiB7XG4gICAgICAgICdtYXJnaW4tbGVmdCc6IFwiXCIuY29uY2F0KHcsIFwicHhcIilcbiAgICAgIH07XG4gICAgfSxcbiAgICBtZXRhOiBmdW5jdGlvbiBtZXRhKCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgbGFzdDogdGhpcy5sYXN0X2NhbmRsZSxcbiAgICAgICAgc3ViX3N0YXJ0OiB0aGlzLnN1Yl9zdGFydCxcbiAgICAgICAgYWN0aXZhdGVkOiB0aGlzLmFjdGl2YXRlZFxuICAgICAgfTtcbiAgICB9LFxuICAgIGZvcmNlZF90ZjogZnVuY3Rpb24gZm9yY2VkX3RmKCkge1xuICAgICAgcmV0dXJuIHRoaXMuY2hhcnQudGY7XG4gICAgfVxuICB9LFxuICBkYXRhOiBmdW5jdGlvbiBkYXRhKCkge1xuICAgIHJldHVybiB7XG4gICAgICAvLyBDdXJyZW50IGRhdGEgc2xpY2VcbiAgICAgIHN1YjogW10sXG4gICAgICAvLyBUaW1lIHJhbmdlXG4gICAgICByYW5nZTogW10sXG4gICAgICAvLyBDYW5kbGVzdGljayBpbnRlcnZhbFxuICAgICAgaW50ZXJ2YWw6IDAsXG4gICAgICAvLyBDcm9zc2hhaXIgc3RhdGVzXG4gICAgICBjdXJzb3I6IHtcbiAgICAgICAgeDogbnVsbCxcbiAgICAgICAgeTogbnVsbCxcbiAgICAgICAgdDogbnVsbCxcbiAgICAgICAgeSQ6IG51bGwsXG4gICAgICAgIGdyaWRfaWQ6IG51bGwsXG4gICAgICAgIGxvY2tlZDogZmFsc2UsXG4gICAgICAgIHZhbHVlczoge30sXG4gICAgICAgIHNjcm9sbF9sb2NrOiBmYWxzZSxcbiAgICAgICAgbW9kZTogdXRpbHMueG1vZGUoKVxuICAgICAgfSxcbiAgICAgIC8vIEEgdHJpY2sgdG8gcmUtcmVuZGVyIGJvdGJhclxuICAgICAgcmVyZW5kZXI6IDAsXG4gICAgICAvLyBMYXllcnMgbWV0YS1wcm9wcyAoY2hhbmdpbmcgYmVoYXZpb3VyKVxuICAgICAgbGF5ZXJzX21ldGE6IHt9LFxuICAgICAgLy8gWS10cmFuc2Zvcm1zIChmb3IgeS16b29tIGFuZCAtc2hpZnQpXG4gICAgICB5X3RyYW5zZm9ybXM6IHt9LFxuICAgICAgLy8gRGVmYXVsdCBPSExDViBzZXR0aW5ncyAod2hlbiB1c2luZyBEYXRhU3RydWN0dXJlIHYxLjApXG4gICAgICBzZXR0aW5nc19vaGxjdjoge30sXG4gICAgICAvLyBEZWZhdWx0IG92ZXJsYXkgc2V0dGluZ3NcbiAgICAgIHNldHRpbmdzX292OiB7fSxcbiAgICAgIC8vIE1ldGEgZGF0YVxuICAgICAgbGFzdF9jYW5kbGU6IFtdLFxuICAgICAgbGFzdF92YWx1ZXM6IHt9LFxuICAgICAgc3ViX3N0YXJ0OiB1bmRlZmluZWQsXG4gICAgICBhY3RpdmF0ZWQ6IGZhbHNlXG4gICAgfTtcbiAgfSxcbiAgd2F0Y2g6IHtcbiAgICB3aWR0aDogZnVuY3Rpb24gd2lkdGgoKSB7XG4gICAgICB0aGlzLnVwZGF0ZV9sYXlvdXQoKTtcbiAgICAgIGlmICh0aGlzLl9ob29rX3Jlc2l6ZSkgdGhpcy5jZSgnP2NoYXJ0LXJlc2l6ZScpO1xuICAgIH0sXG4gICAgaGVpZ2h0OiBmdW5jdGlvbiBoZWlnaHQoKSB7XG4gICAgICB0aGlzLnVwZGF0ZV9sYXlvdXQoKTtcbiAgICAgIGlmICh0aGlzLl9ob29rX3Jlc2l6ZSkgdGhpcy5jZSgnP2NoYXJ0LXJlc2l6ZScpO1xuICAgIH0sXG4gICAgaWI6IGZ1bmN0aW9uIGliKG53KSB7XG4gICAgICBpZiAoIW53KSB7XG4gICAgICAgIC8vIENoYW5nZSByYW5nZSBpbmRleCA9PiB0aW1lXG4gICAgICAgIHZhciB0MSA9IHRoaXMudGlfbWFwLmkydCh0aGlzLnJhbmdlWzBdKTtcbiAgICAgICAgdmFyIHQyID0gdGhpcy50aV9tYXAuaTJ0KHRoaXMucmFuZ2VbMV0pO1xuICAgICAgICB1dGlscy5vdmVyd3JpdGUodGhpcy5yYW5nZSwgW3QxLCB0Ml0pO1xuICAgICAgICB0aGlzLmludGVydmFsID0gdGhpcy5pbnRlcnZhbF9tcztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuaW5pdF9yYW5nZSgpOyAvLyBUT0RPOiBjYWxjIGluZGV4IHJhbmdlIGluc3RlYWRcblxuICAgICAgICB1dGlscy5vdmVyd3JpdGUodGhpcy5yYW5nZSwgdGhpcy5yYW5nZSk7XG4gICAgICAgIHRoaXMuaW50ZXJ2YWwgPSAxO1xuICAgICAgfVxuXG4gICAgICB2YXIgc3ViID0gdGhpcy5zdWJzZXQoKTtcbiAgICAgIHV0aWxzLm92ZXJ3cml0ZSh0aGlzLnN1Yiwgc3ViKTtcbiAgICAgIHRoaXMudXBkYXRlX2xheW91dCgpO1xuICAgIH0sXG4gICAgdGltZXpvbmU6IGZ1bmN0aW9uIHRpbWV6b25lKCkge1xuICAgICAgdGhpcy51cGRhdGVfbGF5b3V0KCk7XG4gICAgfSxcbiAgICBjb2xvcnM6IGZ1bmN0aW9uIGNvbG9ycygpIHtcbiAgICAgIHV0aWxzLm92ZXJ3cml0ZSh0aGlzLnJhbmdlLCB0aGlzLnJhbmdlKTtcbiAgICB9LFxuICAgIGZvcmNlZF90ZjogZnVuY3Rpb24gZm9yY2VkX3RmKG4sIHApIHtcbiAgICAgIHRoaXMudXBkYXRlX2xheW91dCh0cnVlKTtcbiAgICAgIHRoaXMuY2UoJ2V4ZWMtYWxsLXNjcmlwdHMnKTtcbiAgICB9LFxuICAgIGRhdGE6IHtcbiAgICAgIGhhbmRsZXI6IGZ1bmN0aW9uIGhhbmRsZXIobiwgcCkge1xuICAgICAgICBpZiAoIXRoaXMuc3ViLmxlbmd0aCkgdGhpcy5pbml0X3JhbmdlKCk7XG4gICAgICAgIHZhciBzdWIgPSB0aGlzLnN1YnNldCgpOyAvLyBGaXhlcyBJbmZpbml0ZSBsb29wIHdhcm4sIHdoZW4gdGhlIHN1YnNldCBpcyBlbXB0eVxuICAgICAgICAvLyBUT0RPOiBDb25zaWRlciByZW1vdmluZyAnc3ViJyBmcm9tIGRhdGEgZW50aXJlbHlcblxuICAgICAgICBpZiAodGhpcy5zdWIubGVuZ3RoIHx8IHN1Yi5sZW5ndGgpIHtcbiAgICAgICAgICB1dGlscy5vdmVyd3JpdGUodGhpcy5zdWIsIHN1Yik7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgbncgPSB0aGlzLmRhdGFfY2hhbmdlZCgpO1xuICAgICAgICB0aGlzLnVwZGF0ZV9sYXlvdXQobncpO1xuICAgICAgICB1dGlscy5vdmVyd3JpdGUodGhpcy5yYW5nZSwgdGhpcy5yYW5nZSk7XG4gICAgICAgIHRoaXMuY3Vyc29yLnNjcm9sbF9sb2NrID0gISFuLnNjcm9sbExvY2s7XG5cbiAgICAgICAgaWYgKG4uc2Nyb2xsTG9jayAmJiB0aGlzLmN1cnNvci5sb2NrZWQpIHtcbiAgICAgICAgICB0aGlzLmN1cnNvci5sb2NrZWQgPSBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLl9ob29rX2RhdGEpIHRoaXMuY2UoJz9jaGFydC1kYXRhJywgbncpO1xuICAgICAgICB0aGlzLnVwZGF0ZV9sYXN0X3ZhbHVlcygpOyAvLyBUT0RPOiB1cGRhdGUgbGVnZW5kIHZhbHVlcyBmb3Igb3ZlcmFseXNcblxuICAgICAgICB0aGlzLnJlcmVuZGVyKys7XG4gICAgICB9LFxuICAgICAgZGVlcDogdHJ1ZVxuICAgIH1cbiAgfVxufSk7XG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvY29tcG9uZW50cy9DaGFydC52dWU/dnVlJnR5cGU9c2NyaXB0Jmxhbmc9anMmXG4gLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyBjb25zdCBjb21wb25lbnRzX0NoYXJ0dnVlX3R5cGVfc2NyaXB0X2xhbmdfanNfID0gKENoYXJ0dnVlX3R5cGVfc2NyaXB0X2xhbmdfanNfKTsgXG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvY29tcG9uZW50cy9DaGFydC52dWVcblxuXG5cblxuXG4vKiBub3JtYWxpemUgY29tcG9uZW50ICovXG47XG52YXIgQ2hhcnRfY29tcG9uZW50ID0gbm9ybWFsaXplQ29tcG9uZW50KFxuICBjb21wb25lbnRzX0NoYXJ0dnVlX3R5cGVfc2NyaXB0X2xhbmdfanNfLFxuICBDaGFydHZ1ZV90eXBlX3RlbXBsYXRlX2lkXzRkMDZhNGRlX3JlbmRlcixcbiAgQ2hhcnR2dWVfdHlwZV90ZW1wbGF0ZV9pZF80ZDA2YTRkZV9zdGF0aWNSZW5kZXJGbnMsXG4gIGZhbHNlLFxuICBudWxsLFxuICBudWxsLFxuICBudWxsXG4gIFxuKVxuXG4vKiBob3QgcmVsb2FkICovXG5pZiAoZmFsc2UpIHsgdmFyIENoYXJ0X2FwaTsgfVxuQ2hhcnRfY29tcG9uZW50Lm9wdGlvbnMuX19maWxlID0gXCJzcmMvY29tcG9uZW50cy9DaGFydC52dWVcIlxuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyBjb25zdCBDaGFydCA9IChDaGFydF9jb21wb25lbnQuZXhwb3J0cyk7XG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvbG9hZGVycy90ZW1wbGF0ZUxvYWRlci5qcz8/dnVlLWxvYWRlci1vcHRpb25zIS4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL2luZGV4LmpzPz92dWUtbG9hZGVyLW9wdGlvbnMhLi9zcmMvY29tcG9uZW50cy9Ub29sYmFyLnZ1ZT92dWUmdHlwZT10ZW1wbGF0ZSZpZD0wMjE4ODdmYiZcbnZhciBUb29sYmFydnVlX3R5cGVfdGVtcGxhdGVfaWRfMDIxODg3ZmJfcmVuZGVyID0gZnVuY3Rpb24oKSB7XG4gIHZhciBfdm0gPSB0aGlzXG4gIHZhciBfaCA9IF92bS4kY3JlYXRlRWxlbWVudFxuICB2YXIgX2MgPSBfdm0uX3NlbGYuX2MgfHwgX2hcbiAgcmV0dXJuIF9jKFxuICAgIFwiZGl2XCIsXG4gICAge1xuICAgICAga2V5OiBfdm0udG9vbF9jb3VudCxcbiAgICAgIHN0YXRpY0NsYXNzOiBcInRyYWRpbmctdnVlLXRvb2xiYXJcIixcbiAgICAgIHN0eWxlOiBfdm0uc3R5bGVzXG4gICAgfSxcbiAgICBfdm0uX2woX3ZtLmdyb3VwcywgZnVuY3Rpb24odG9vbCwgaSkge1xuICAgICAgcmV0dXJuIHRvb2wuaWNvbiAmJiAhdG9vbC5oaWRkZW5cbiAgICAgICAgPyBfYyhcInRvb2xiYXItaXRlbVwiLCB7XG4gICAgICAgICAgICBrZXk6IGksXG4gICAgICAgICAgICBhdHRyczoge1xuICAgICAgICAgICAgICBkYXRhOiB0b29sLFxuICAgICAgICAgICAgICBzdWJzOiBfdm0uc3ViX21hcCxcbiAgICAgICAgICAgICAgZGM6IF92bS5kYXRhLFxuICAgICAgICAgICAgICBjb25maWc6IF92bS5jb25maWcsXG4gICAgICAgICAgICAgIGNvbG9yczogX3ZtLmNvbG9ycyxcbiAgICAgICAgICAgICAgc2VsZWN0ZWQ6IF92bS5pc19zZWxlY3RlZCh0b29sKVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIG9uOiB7IFwiaXRlbS1zZWxlY3RlZFwiOiBfdm0uc2VsZWN0ZWQgfVxuICAgICAgICAgIH0pXG4gICAgICAgIDogX3ZtLl9lKClcbiAgICB9KSxcbiAgICAxXG4gIClcbn1cbnZhciBUb29sYmFydnVlX3R5cGVfdGVtcGxhdGVfaWRfMDIxODg3ZmJfc3RhdGljUmVuZGVyRm5zID0gW11cblRvb2xiYXJ2dWVfdHlwZV90ZW1wbGF0ZV9pZF8wMjE4ODdmYl9yZW5kZXIuX3dpdGhTdHJpcHBlZCA9IHRydWVcblxuXG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvY29tcG9uZW50cy9Ub29sYmFyLnZ1ZT92dWUmdHlwZT10ZW1wbGF0ZSZpZD0wMjE4ODdmYiZcblxuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL2xvYWRlcnMvdGVtcGxhdGVMb2FkZXIuanM/P3Z1ZS1sb2FkZXItb3B0aW9ucyEuL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9pbmRleC5qcz8/dnVlLWxvYWRlci1vcHRpb25zIS4vc3JjL2NvbXBvbmVudHMvVG9vbGJhckl0ZW0udnVlP3Z1ZSZ0eXBlPXRlbXBsYXRlJmlkPTIyN2IzYzJlJlxudmFyIFRvb2xiYXJJdGVtdnVlX3R5cGVfdGVtcGxhdGVfaWRfMjI3YjNjMmVfcmVuZGVyID0gZnVuY3Rpb24oKSB7XG4gIHZhciBfdm0gPSB0aGlzXG4gIHZhciBfaCA9IF92bS4kY3JlYXRlRWxlbWVudFxuICB2YXIgX2MgPSBfdm0uX3NlbGYuX2MgfHwgX2hcbiAgcmV0dXJuIF9jKFxuICAgIFwiZGl2XCIsXG4gICAge1xuICAgICAgY2xhc3M6IFtcInRyYWRpbmctdnVlLXRiaXRlbVwiLCBfdm0uc2VsZWN0ZWQgPyBcInNlbGVjdGVkLWl0ZW1cIiA6IFwiXCJdLFxuICAgICAgc3R5bGU6IF92bS5pdGVtX3N0eWxlLFxuICAgICAgb246IHtcbiAgICAgICAgY2xpY2s6IGZ1bmN0aW9uKCRldmVudCkge1xuICAgICAgICAgIHJldHVybiBfdm0uZW1pdF9zZWxlY3RlZChcImNsaWNrXCIpXG4gICAgICAgIH0sXG4gICAgICAgIG1vdXNlZG93bjogX3ZtLm1vdXNlZG93bixcbiAgICAgICAgdG91Y2hzdGFydDogX3ZtLm1vdXNlZG93bixcbiAgICAgICAgdG91Y2hlbmQ6IGZ1bmN0aW9uKCRldmVudCkge1xuICAgICAgICAgIHJldHVybiBfdm0uZW1pdF9zZWxlY3RlZChcInRvdWNoXCIpXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuICAgIFtcbiAgICAgIF9jKFwiZGl2XCIsIHtcbiAgICAgICAgc3RhdGljQ2xhc3M6IFwidHJhZGluZy12dWUtdGJpY29uIHR2anMtcGl4ZWxhdGVkXCIsXG4gICAgICAgIHN0eWxlOiBfdm0uaWNvbl9zdHlsZVxuICAgICAgfSksXG4gICAgICBfdm0uX3YoXCIgXCIpLFxuICAgICAgX3ZtLmRhdGEuZ3JvdXBcbiAgICAgICAgPyBfYyhcbiAgICAgICAgICAgIFwiZGl2XCIsXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIHN0YXRpY0NsYXNzOiBcInRyYWRpbmctdnVlLXRiaXRlbS1leHBcIixcbiAgICAgICAgICAgICAgc3R5bGU6IF92bS5leHBfc3R5bGUsXG4gICAgICAgICAgICAgIG9uOiB7XG4gICAgICAgICAgICAgICAgY2xpY2s6IF92bS5leHBfY2xpY2ssXG4gICAgICAgICAgICAgICAgbW91c2Vkb3duOiBfdm0uZXhwbW91c2Vkb3duLFxuICAgICAgICAgICAgICAgIG1vdXNlb3ZlcjogX3ZtLmV4cG1vdXNlb3ZlcixcbiAgICAgICAgICAgICAgICBtb3VzZWxlYXZlOiBfdm0uZXhwbW91c2VsZWF2ZVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgW192bS5fdihcIlxcbiAgICAgICAg4ZCzXFxuICAgIFwiKV1cbiAgICAgICAgICApXG4gICAgICAgIDogX3ZtLl9lKCksXG4gICAgICBfdm0uX3YoXCIgXCIpLFxuICAgICAgX3ZtLnNob3dfZXhwX2xpc3RcbiAgICAgICAgPyBfYyhcIml0ZW0tbGlzdFwiLCB7XG4gICAgICAgICAgICBhdHRyczoge1xuICAgICAgICAgICAgICBjb25maWc6IF92bS5jb25maWcsXG4gICAgICAgICAgICAgIGl0ZW1zOiBfdm0uZGF0YS5pdGVtcyxcbiAgICAgICAgICAgICAgY29sb3JzOiBfdm0uY29sb3JzLFxuICAgICAgICAgICAgICBkYzogX3ZtLmRjXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgb246IHtcbiAgICAgICAgICAgICAgXCJjbG9zZS1saXN0XCI6IF92bS5jbG9zZV9saXN0LFxuICAgICAgICAgICAgICBcIml0ZW0tc2VsZWN0ZWRcIjogX3ZtLmVtaXRfc2VsZWN0ZWRfc3ViXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSlcbiAgICAgICAgOiBfdm0uX2UoKVxuICAgIF0sXG4gICAgMVxuICApXG59XG52YXIgVG9vbGJhckl0ZW12dWVfdHlwZV90ZW1wbGF0ZV9pZF8yMjdiM2MyZV9zdGF0aWNSZW5kZXJGbnMgPSBbXVxuVG9vbGJhckl0ZW12dWVfdHlwZV90ZW1wbGF0ZV9pZF8yMjdiM2MyZV9yZW5kZXIuX3dpdGhTdHJpcHBlZCA9IHRydWVcblxuXG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvY29tcG9uZW50cy9Ub29sYmFySXRlbS52dWU/dnVlJnR5cGU9dGVtcGxhdGUmaWQ9MjI3YjNjMmUmXG5cbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9sb2FkZXJzL3RlbXBsYXRlTG9hZGVyLmpzPz92dWUtbG9hZGVyLW9wdGlvbnMhLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvaW5kZXguanM/P3Z1ZS1sb2FkZXItb3B0aW9ucyEuL3NyYy9jb21wb25lbnRzL0l0ZW1MaXN0LnZ1ZT92dWUmdHlwZT10ZW1wbGF0ZSZpZD1jNTBiMjNmZSZcbnZhciBJdGVtTGlzdHZ1ZV90eXBlX3RlbXBsYXRlX2lkX2M1MGIyM2ZlX3JlbmRlciA9IGZ1bmN0aW9uKCkge1xuICB2YXIgX3ZtID0gdGhpc1xuICB2YXIgX2ggPSBfdm0uJGNyZWF0ZUVsZW1lbnRcbiAgdmFyIF9jID0gX3ZtLl9zZWxmLl9jIHx8IF9oXG4gIHJldHVybiBfYyhcbiAgICBcImRpdlwiLFxuICAgIHtcbiAgICAgIHN0YXRpY0NsYXNzOiBcInR2anMtaXRlbS1saXN0XCIsXG4gICAgICBzdHlsZTogX3ZtLmxpc3Rfc3R5bGUoKSxcbiAgICAgIG9uOiB7IG1vdXNlZG93bjogX3ZtLnRoaXNtb3VzZWRvd24gfVxuICAgIH0sXG4gICAgX3ZtLl9sKF92bS5pdGVtcywgZnVuY3Rpb24oaXRlbSkge1xuICAgICAgcmV0dXJuICFpdGVtLmhpZGRlblxuICAgICAgICA/IF9jKFxuICAgICAgICAgICAgXCJkaXZcIixcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgY2xhc3M6IF92bS5pdGVtX2NsYXNzKGl0ZW0pLFxuICAgICAgICAgICAgICBzdHlsZTogX3ZtLml0ZW1fc3R5bGUoaXRlbSksXG4gICAgICAgICAgICAgIG9uOiB7XG4gICAgICAgICAgICAgICAgY2xpY2s6IGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiBfdm0uaXRlbV9jbGljayhlLCBpdGVtKVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIFtcbiAgICAgICAgICAgICAgX2MoXCJkaXZcIiwge1xuICAgICAgICAgICAgICAgIHN0YXRpY0NsYXNzOiBcInRyYWRpbmctdnVlLXRiaWNvbiB0dmpzLXBpeGVsYXRlZFwiLFxuICAgICAgICAgICAgICAgIHN0eWxlOiBfdm0uaWNvbl9zdHlsZShpdGVtKVxuICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgX3ZtLl92KFwiIFwiKSxcbiAgICAgICAgICAgICAgX2MoXCJkaXZcIiwgW192bS5fdihfdm0uX3MoaXRlbS50eXBlKSldKVxuICAgICAgICAgICAgXVxuICAgICAgICAgIClcbiAgICAgICAgOiBfdm0uX2UoKVxuICAgIH0pLFxuICAgIDBcbiAgKVxufVxudmFyIEl0ZW1MaXN0dnVlX3R5cGVfdGVtcGxhdGVfaWRfYzUwYjIzZmVfc3RhdGljUmVuZGVyRm5zID0gW11cbkl0ZW1MaXN0dnVlX3R5cGVfdGVtcGxhdGVfaWRfYzUwYjIzZmVfcmVuZGVyLl93aXRoU3RyaXBwZWQgPSB0cnVlXG5cblxuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL2NvbXBvbmVudHMvSXRlbUxpc3QudnVlP3Z1ZSZ0eXBlPXRlbXBsYXRlJmlkPWM1MGIyM2ZlJlxuXG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9ub2RlX21vZHVsZXMvYmFiZWwtbG9hZGVyL2xpYi9pbmRleC5qcyEuL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9pbmRleC5qcz8/dnVlLWxvYWRlci1vcHRpb25zIS4vc3JjL2NvbXBvbmVudHMvSXRlbUxpc3QudnVlP3Z1ZSZ0eXBlPXNjcmlwdCZsYW5nPWpzJlxuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyBjb25zdCBJdGVtTGlzdHZ1ZV90eXBlX3NjcmlwdF9sYW5nX2pzXyA9ICh7XG4gIG5hbWU6ICdJdGVtTGlzdCcsXG4gIHByb3BzOiBbJ2NvbmZpZycsICdpdGVtcycsICdjb2xvcnMnLCAnZGMnXSxcbiAgbW91bnRlZDogZnVuY3Rpb24gbW91bnRlZCgpIHtcbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignbW91c2Vkb3duJywgdGhpcy5vbm1vdXNlZG93bik7XG4gIH0sXG4gIGJlZm9yZURlc3Ryb3k6IGZ1bmN0aW9uIGJlZm9yZURlc3Ryb3koKSB7XG4gICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNlZG93bicsIHRoaXMub25tb3VzZWRvd24pO1xuICB9LFxuICBtZXRob2RzOiB7XG4gICAgbGlzdF9zdHlsZTogZnVuY3Rpb24gbGlzdF9zdHlsZSgpIHtcbiAgICAgIHZhciBjb25mID0gdGhpcy4kcHJvcHMuY29uZmlnO1xuICAgICAgdmFyIHcgPSBjb25mLlRPT0xCQVI7XG4gICAgICB2YXIgYnJkID0gdGhpcy5jb2xvcnMudGJMaXN0Qm9yZGVyIHx8IHRoaXMuY29sb3JzLmdyaWQ7XG4gICAgICB2YXIgYnN0bCA9IFwiMXB4IHNvbGlkIFwiLmNvbmNhdChicmQpO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgbGVmdDogXCJcIi5jb25jYXQodywgXCJweFwiKSxcbiAgICAgICAgYmFja2dyb3VuZDogdGhpcy5jb2xvcnMuYmFjayxcbiAgICAgICAgYm9yZGVyVG9wOiBic3RsLFxuICAgICAgICBib3JkZXJSaWdodDogYnN0bCxcbiAgICAgICAgYm9yZGVyQm90dG9tOiBic3RsXG4gICAgICB9O1xuICAgIH0sXG4gICAgaXRlbV9jbGFzczogZnVuY3Rpb24gaXRlbV9jbGFzcyhpdGVtKSB7XG4gICAgICBpZiAodGhpcy5kYy50b29sID09PSBpdGVtLnR5cGUpIHtcbiAgICAgICAgcmV0dXJuIFwidHZqcy1pdGVtLWxpc3QtaXRlbSBzZWxlY3RlZC1pdGVtXCI7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBcInR2anMtaXRlbS1saXN0LWl0ZW1cIjtcbiAgICB9LFxuICAgIGl0ZW1fc3R5bGU6IGZ1bmN0aW9uIGl0ZW1fc3R5bGUoaXRlbSkge1xuICAgICAgdmFyIGNvbmYgPSB0aGlzLiRwcm9wcy5jb25maWc7XG4gICAgICB2YXIgaCA9IGNvbmYuVEJfSUNPTiArIGNvbmYuVEJfSVRFTV9NICogMiArIDg7XG4gICAgICB2YXIgc2VsID0gdGhpcy5kYy50b29sID09PSBpdGVtLnR5cGU7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBoZWlnaHQ6IFwiXCIuY29uY2F0KGgsIFwicHhcIiksXG4gICAgICAgIGNvbG9yOiBzZWwgPyB1bmRlZmluZWQgOiBcIiM4ODg4ODhcIlxuICAgICAgfTtcbiAgICB9LFxuICAgIGljb25fc3R5bGU6IGZ1bmN0aW9uIGljb25fc3R5bGUoZGF0YSkge1xuICAgICAgdmFyIGNvbmYgPSB0aGlzLiRwcm9wcy5jb25maWc7XG4gICAgICB2YXIgYnIgPSBjb25mLlRCX0lDT05fQlJJO1xuICAgICAgdmFyIGltID0gY29uZi5UQl9JVEVNX007XG4gICAgICByZXR1cm4ge1xuICAgICAgICAnYmFja2dyb3VuZC1pbWFnZSc6IFwidXJsKFwiLmNvbmNhdChkYXRhLmljb24sIFwiKVwiKSxcbiAgICAgICAgJ3dpZHRoJzogJzI1cHgnLFxuICAgICAgICAnaGVpZ2h0JzogJzI1cHgnLFxuICAgICAgICAnbWFyZ2luJzogXCJcIi5jb25jYXQoaW0sIFwicHhcIiksXG4gICAgICAgICdmaWx0ZXInOiBcImJyaWdodG5lc3MoXCIuY29uY2F0KGJyLCBcIilcIilcbiAgICAgIH07XG4gICAgfSxcbiAgICBpdGVtX2NsaWNrOiBmdW5jdGlvbiBpdGVtX2NsaWNrKGUsIGl0ZW0pIHtcbiAgICAgIGUuY2FuY2VsQnViYmxlID0gdHJ1ZTtcbiAgICAgIHRoaXMuJGVtaXQoJ2l0ZW0tc2VsZWN0ZWQnLCBpdGVtKTtcbiAgICAgIHRoaXMuJGVtaXQoJ2Nsb3NlLWxpc3QnKTtcbiAgICB9LFxuICAgIG9ubW91c2Vkb3duOiBmdW5jdGlvbiBvbm1vdXNlZG93bigpIHtcbiAgICAgIHRoaXMuJGVtaXQoJ2Nsb3NlLWxpc3QnKTtcbiAgICB9LFxuICAgIHRoaXNtb3VzZWRvd246IGZ1bmN0aW9uIHRoaXNtb3VzZWRvd24oZSkge1xuICAgICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICB9XG4gIH0sXG4gIGNvbXB1dGVkOiB7fSxcbiAgZGF0YTogZnVuY3Rpb24gZGF0YSgpIHtcbiAgICByZXR1cm4ge307XG4gIH1cbn0pO1xuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL2NvbXBvbmVudHMvSXRlbUxpc3QudnVlP3Z1ZSZ0eXBlPXNjcmlwdCZsYW5nPWpzJlxuIC8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gY29uc3QgY29tcG9uZW50c19JdGVtTGlzdHZ1ZV90eXBlX3NjcmlwdF9sYW5nX2pzXyA9IChJdGVtTGlzdHZ1ZV90eXBlX3NjcmlwdF9sYW5nX2pzXyk7IFxuLy8gRVhURVJOQUwgTU9EVUxFOiAuL25vZGVfbW9kdWxlcy92dWUtc3R5bGUtbG9hZGVyL2luZGV4LmpzIS4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvZGlzdC9janMuanMhLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvbG9hZGVycy9zdHlsZVBvc3RMb2FkZXIuanMhLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvaW5kZXguanM/P3Z1ZS1sb2FkZXItb3B0aW9ucyEuL3NyYy9jb21wb25lbnRzL0l0ZW1MaXN0LnZ1ZT92dWUmdHlwZT1zdHlsZSZpbmRleD0wJmxhbmc9Y3NzJlxudmFyIEl0ZW1MaXN0dnVlX3R5cGVfc3R5bGVfaW5kZXhfMF9sYW5nX2Nzc18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDgwNyk7XG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvY29tcG9uZW50cy9JdGVtTGlzdC52dWU/dnVlJnR5cGU9c3R5bGUmaW5kZXg9MCZsYW5nPWNzcyZcblxuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL2NvbXBvbmVudHMvSXRlbUxpc3QudnVlXG5cblxuXG47XG5cblxuLyogbm9ybWFsaXplIGNvbXBvbmVudCAqL1xuXG52YXIgSXRlbUxpc3RfY29tcG9uZW50ID0gbm9ybWFsaXplQ29tcG9uZW50KFxuICBjb21wb25lbnRzX0l0ZW1MaXN0dnVlX3R5cGVfc2NyaXB0X2xhbmdfanNfLFxuICBJdGVtTGlzdHZ1ZV90eXBlX3RlbXBsYXRlX2lkX2M1MGIyM2ZlX3JlbmRlcixcbiAgSXRlbUxpc3R2dWVfdHlwZV90ZW1wbGF0ZV9pZF9jNTBiMjNmZV9zdGF0aWNSZW5kZXJGbnMsXG4gIGZhbHNlLFxuICBudWxsLFxuICBudWxsLFxuICBudWxsXG4gIFxuKVxuXG4vKiBob3QgcmVsb2FkICovXG5pZiAoZmFsc2UpIHsgdmFyIEl0ZW1MaXN0X2FwaTsgfVxuSXRlbUxpc3RfY29tcG9uZW50Lm9wdGlvbnMuX19maWxlID0gXCJzcmMvY29tcG9uZW50cy9JdGVtTGlzdC52dWVcIlxuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyBjb25zdCBJdGVtTGlzdCA9IChJdGVtTGlzdF9jb21wb25lbnQuZXhwb3J0cyk7XG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9ub2RlX21vZHVsZXMvYmFiZWwtbG9hZGVyL2xpYi9pbmRleC5qcyEuL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9pbmRleC5qcz8/dnVlLWxvYWRlci1vcHRpb25zIS4vc3JjL2NvbXBvbmVudHMvVG9vbGJhckl0ZW0udnVlP3Z1ZSZ0eXBlPXNjcmlwdCZsYW5nPWpzJlxuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG5cblxuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyBjb25zdCBUb29sYmFySXRlbXZ1ZV90eXBlX3NjcmlwdF9sYW5nX2pzXyA9ICh7XG4gIG5hbWU6ICdUb29sYmFySXRlbScsXG4gIHByb3BzOiBbJ2RhdGEnLCAnc2VsZWN0ZWQnLCAnY29sb3JzJywgJ3R2X2lkJywgJ2NvbmZpZycsICdkYycsICdzdWJzJ10sXG4gIGNvbXBvbmVudHM6IHtcbiAgICBJdGVtTGlzdDogSXRlbUxpc3RcbiAgfSxcbiAgbW91bnRlZDogZnVuY3Rpb24gbW91bnRlZCgpIHtcbiAgICBpZiAodGhpcy5kYXRhLmdyb3VwKSB7XG4gICAgICB2YXIgdHlwZSA9IHRoaXMuc3Vic1t0aGlzLmRhdGEuZ3JvdXBdO1xuICAgICAgdmFyIGl0ZW0gPSB0aGlzLmRhdGEuaXRlbXMuZmluZChmdW5jdGlvbiAoeCkge1xuICAgICAgICByZXR1cm4geC50eXBlID09PSB0eXBlO1xuICAgICAgfSk7XG4gICAgICBpZiAoaXRlbSkgdGhpcy5zdWJfaXRlbSA9IGl0ZW07XG4gICAgfVxuICB9LFxuICBtZXRob2RzOiB7XG4gICAgbW91c2Vkb3duOiBmdW5jdGlvbiBtb3VzZWRvd24oZSkge1xuICAgICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgICAgdGhpcy5jbGlja19zdGFydCA9IHV0aWxzLm5vdygpO1xuICAgICAgdGhpcy5jbGlja19pZCA9IHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICBfdGhpcy5zaG93X2V4cF9saXN0ID0gdHJ1ZTtcbiAgICAgIH0sIHRoaXMuY29uZmlnLlRCX0lDT05fSE9MRCk7XG4gICAgfSxcbiAgICBleHBtb3VzZW92ZXI6IGZ1bmN0aW9uIGV4cG1vdXNlb3ZlcigpIHtcbiAgICAgIHRoaXMuZXhwX2hvdmVyID0gdHJ1ZTtcbiAgICB9LFxuICAgIGV4cG1vdXNlbGVhdmU6IGZ1bmN0aW9uIGV4cG1vdXNlbGVhdmUoKSB7XG4gICAgICB0aGlzLmV4cF9ob3ZlciA9IGZhbHNlO1xuICAgIH0sXG4gICAgZXhwbW91c2Vkb3duOiBmdW5jdGlvbiBleHBtb3VzZWRvd24oZSkge1xuICAgICAgaWYgKHRoaXMuc2hvd19leHBfbGlzdCkgZS5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICB9LFxuICAgIGVtaXRfc2VsZWN0ZWQ6IGZ1bmN0aW9uIGVtaXRfc2VsZWN0ZWQoc3JjKSB7XG4gICAgICBpZiAodXRpbHMubm93KCkgLSB0aGlzLmNsaWNrX3N0YXJ0ID4gdGhpcy5jb25maWcuVEJfSUNPTl9IT0xEKSByZXR1cm47XG4gICAgICBjbGVhclRpbWVvdXQodGhpcy5jbGlja19pZCk7IC8vaWYgKFV0aWxzLmlzX21vYmlsZSAmJiBzcmMgPT09ICdjbGljaycpIHJldHVyblxuICAgICAgLy8gVE9ETzogZG91YmxlIGZpcmluZ1xuXG4gICAgICBpZiAoIXRoaXMuZGF0YS5ncm91cCkge1xuICAgICAgICB0aGlzLiRlbWl0KCdpdGVtLXNlbGVjdGVkJywgdGhpcy5kYXRhKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBpdGVtID0gdGhpcy5zdWJfaXRlbSB8fCB0aGlzLmRhdGEuaXRlbXNbMF07XG4gICAgICAgIHRoaXMuJGVtaXQoJ2l0ZW0tc2VsZWN0ZWQnLCBpdGVtKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIGVtaXRfc2VsZWN0ZWRfc3ViOiBmdW5jdGlvbiBlbWl0X3NlbGVjdGVkX3N1YihpdGVtKSB7XG4gICAgICB0aGlzLiRlbWl0KCdpdGVtLXNlbGVjdGVkJywgaXRlbSk7XG4gICAgICB0aGlzLnN1Yl9pdGVtID0gaXRlbTtcbiAgICB9LFxuICAgIGV4cF9jbGljazogZnVuY3Rpb24gZXhwX2NsaWNrKGUpIHtcbiAgICAgIGlmICghdGhpcy5kYXRhLmdyb3VwKSByZXR1cm47XG4gICAgICBlLmNhbmNlbEJ1YmJsZSA9IHRydWU7XG4gICAgICB0aGlzLnNob3dfZXhwX2xpc3QgPSAhdGhpcy5zaG93X2V4cF9saXN0O1xuICAgIH0sXG4gICAgY2xvc2VfbGlzdDogZnVuY3Rpb24gY2xvc2VfbGlzdCgpIHtcbiAgICAgIHRoaXMuc2hvd19leHBfbGlzdCA9IGZhbHNlO1xuICAgIH1cbiAgfSxcbiAgY29tcHV0ZWQ6IHtcbiAgICBpdGVtX3N0eWxlOiBmdW5jdGlvbiBpdGVtX3N0eWxlKCkge1xuICAgICAgaWYgKHRoaXMuJHByb3BzLmRhdGEudHlwZSA9PT0gJ1N5c3RlbTpTcGxpdHRlcicpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3BsaXR0ZXI7XG4gICAgICB9XG5cbiAgICAgIHZhciBjb25mID0gdGhpcy4kcHJvcHMuY29uZmlnO1xuICAgICAgdmFyIGltID0gY29uZi5UQl9JVEVNX007XG4gICAgICB2YXIgbSA9IChjb25mLlRPT0xCQVIgLSBjb25mLlRCX0lDT04pICogMC41IC0gaW07XG4gICAgICB2YXIgcyA9IGNvbmYuVEJfSUNPTiArIGltICogMjtcbiAgICAgIHZhciBiID0gdGhpcy5leHBfaG92ZXIgPyAwIDogMztcbiAgICAgIHJldHVybiB7XG4gICAgICAgICd3aWR0aCc6IFwiXCIuY29uY2F0KHMsIFwicHhcIiksXG4gICAgICAgICdoZWlnaHQnOiBcIlwiLmNvbmNhdChzLCBcInB4XCIpLFxuICAgICAgICAnbWFyZ2luJzogXCI4cHggXCIuY29uY2F0KG0sIFwicHggMHB4IFwiKS5jb25jYXQobSwgXCJweFwiKSxcbiAgICAgICAgJ2JvcmRlci1yYWRpdXMnOiBcIjNweCBcIi5jb25jYXQoYiwgXCJweCBcIikuY29uY2F0KGIsIFwicHggM3B4XCIpXG4gICAgICB9O1xuICAgIH0sXG4gICAgaWNvbl9zdHlsZTogZnVuY3Rpb24gaWNvbl9zdHlsZSgpIHtcbiAgICAgIGlmICh0aGlzLiRwcm9wcy5kYXRhLnR5cGUgPT09ICdTeXN0ZW06U3BsaXR0ZXInKSB7XG4gICAgICAgIHJldHVybiB7fTtcbiAgICAgIH1cblxuICAgICAgdmFyIGNvbmYgPSB0aGlzLiRwcm9wcy5jb25maWc7XG4gICAgICB2YXIgYnIgPSBjb25mLlRCX0lDT05fQlJJO1xuICAgICAgdmFyIHN6ID0gY29uZi5UQl9JQ09OO1xuICAgICAgdmFyIGltID0gY29uZi5UQl9JVEVNX007XG4gICAgICB2YXIgaWMgPSB0aGlzLnN1Yl9pdGVtID8gdGhpcy5zdWJfaXRlbS5pY29uIDogdGhpcy4kcHJvcHMuZGF0YS5pY29uO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgJ2JhY2tncm91bmQtaW1hZ2UnOiBcInVybChcIi5jb25jYXQoaWMsIFwiKVwiKSxcbiAgICAgICAgJ3dpZHRoJzogXCJcIi5jb25jYXQoc3osIFwicHhcIiksXG4gICAgICAgICdoZWlnaHQnOiBcIlwiLmNvbmNhdChzeiwgXCJweFwiKSxcbiAgICAgICAgJ21hcmdpbic6IFwiXCIuY29uY2F0KGltLCBcInB4XCIpLFxuICAgICAgICAnZmlsdGVyJzogXCJicmlnaHRuZXNzKFwiLmNvbmNhdChiciwgXCIpXCIpXG4gICAgICB9O1xuICAgIH0sXG4gICAgZXhwX3N0eWxlOiBmdW5jdGlvbiBleHBfc3R5bGUoKSB7XG4gICAgICB2YXIgY29uZiA9IHRoaXMuJHByb3BzLmNvbmZpZztcbiAgICAgIHZhciBpbSA9IGNvbmYuVEJfSVRFTV9NO1xuICAgICAgdmFyIHMgPSBjb25mLlRCX0lDT04gKiAwLjUgKyBpbTtcbiAgICAgIHZhciBwID0gKGNvbmYuVE9PTEJBUiAtIHMgKiAyKSAvIDQ7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBwYWRkaW5nOiBcIlwiLmNvbmNhdChzLCBcInB4IFwiKS5jb25jYXQocCwgXCJweFwiKSxcbiAgICAgICAgdHJhbnNmb3JtOiB0aGlzLnNob3dfZXhwX2xpc3QgPyBcInNjYWxlKC0wLjYsIDEpXCIgOiBcInNjYWxlWCgwLjYpXCJcbiAgICAgIH07XG4gICAgfSxcbiAgICBzcGxpdHRlcjogZnVuY3Rpb24gc3BsaXR0ZXIoKSB7XG4gICAgICB2YXIgY29uZiA9IHRoaXMuJHByb3BzLmNvbmZpZztcbiAgICAgIHZhciBjb2xvcnMgPSB0aGlzLiRwcm9wcy5jb2xvcnM7XG4gICAgICB2YXIgYyA9IGNvbG9ycy5ncmlkO1xuICAgICAgdmFyIGltID0gY29uZi5UQl9JVEVNX007XG4gICAgICB2YXIgbSA9IChjb25mLlRPT0xCQVIgLSBjb25mLlRCX0lDT04pICogMC41IC0gaW07XG4gICAgICB2YXIgcyA9IGNvbmYuVEJfSUNPTiArIGltICogMjtcbiAgICAgIHJldHVybiB7XG4gICAgICAgICd3aWR0aCc6IFwiXCIuY29uY2F0KHMsIFwicHhcIiksXG4gICAgICAgICdoZWlnaHQnOiAnMXB4JyxcbiAgICAgICAgJ21hcmdpbic6IFwiOHB4IFwiLmNvbmNhdChtLCBcInB4IDhweCBcIikuY29uY2F0KG0sIFwicHhcIiksXG4gICAgICAgICdiYWNrZ3JvdW5kLWNvbG9yJzogY1xuICAgICAgfTtcbiAgICB9XG4gIH0sXG4gIGRhdGE6IGZ1bmN0aW9uIGRhdGEoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGV4cF9ob3ZlcjogZmFsc2UsXG4gICAgICBzaG93X2V4cF9saXN0OiBmYWxzZSxcbiAgICAgIHN1Yl9pdGVtOiBudWxsXG4gICAgfTtcbiAgfVxufSk7XG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvY29tcG9uZW50cy9Ub29sYmFySXRlbS52dWU/dnVlJnR5cGU9c2NyaXB0Jmxhbmc9anMmXG4gLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyBjb25zdCBjb21wb25lbnRzX1Rvb2xiYXJJdGVtdnVlX3R5cGVfc2NyaXB0X2xhbmdfanNfID0gKFRvb2xiYXJJdGVtdnVlX3R5cGVfc2NyaXB0X2xhbmdfanNfKTsgXG4vLyBFWFRFUk5BTCBNT0RVTEU6IC4vbm9kZV9tb2R1bGVzL3Z1ZS1zdHlsZS1sb2FkZXIvaW5kZXguanMhLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9kaXN0L2Nqcy5qcyEuL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9sb2FkZXJzL3N0eWxlUG9zdExvYWRlci5qcyEuL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9pbmRleC5qcz8/dnVlLWxvYWRlci1vcHRpb25zIS4vc3JjL2NvbXBvbmVudHMvVG9vbGJhckl0ZW0udnVlP3Z1ZSZ0eXBlPXN0eWxlJmluZGV4PTAmbGFuZz1jc3MmXG52YXIgVG9vbGJhckl0ZW12dWVfdHlwZV9zdHlsZV9pbmRleF8wX2xhbmdfY3NzXyA9IF9fd2VicGFja19yZXF1aXJlX18oNTAxKTtcbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9jb21wb25lbnRzL1Rvb2xiYXJJdGVtLnZ1ZT92dWUmdHlwZT1zdHlsZSZpbmRleD0wJmxhbmc9Y3NzJlxuXG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvY29tcG9uZW50cy9Ub29sYmFySXRlbS52dWVcblxuXG5cbjtcblxuXG4vKiBub3JtYWxpemUgY29tcG9uZW50ICovXG5cbnZhciBUb29sYmFySXRlbV9jb21wb25lbnQgPSBub3JtYWxpemVDb21wb25lbnQoXG4gIGNvbXBvbmVudHNfVG9vbGJhckl0ZW12dWVfdHlwZV9zY3JpcHRfbGFuZ19qc18sXG4gIFRvb2xiYXJJdGVtdnVlX3R5cGVfdGVtcGxhdGVfaWRfMjI3YjNjMmVfcmVuZGVyLFxuICBUb29sYmFySXRlbXZ1ZV90eXBlX3RlbXBsYXRlX2lkXzIyN2IzYzJlX3N0YXRpY1JlbmRlckZucyxcbiAgZmFsc2UsXG4gIG51bGwsXG4gIG51bGwsXG4gIG51bGxcbiAgXG4pXG5cbi8qIGhvdCByZWxvYWQgKi9cbmlmIChmYWxzZSkgeyB2YXIgVG9vbGJhckl0ZW1fYXBpOyB9XG5Ub29sYmFySXRlbV9jb21wb25lbnQub3B0aW9ucy5fX2ZpbGUgPSBcInNyYy9jb21wb25lbnRzL1Rvb2xiYXJJdGVtLnZ1ZVwiXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIGNvbnN0IFRvb2xiYXJJdGVtID0gKFRvb2xiYXJJdGVtX2NvbXBvbmVudC5leHBvcnRzKTtcbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL25vZGVfbW9kdWxlcy9iYWJlbC1sb2FkZXIvbGliL2luZGV4LmpzIS4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL2luZGV4LmpzPz92dWUtbG9hZGVyLW9wdGlvbnMhLi9zcmMvY29tcG9uZW50cy9Ub29sYmFyLnZ1ZT92dWUmdHlwZT1zY3JpcHQmbGFuZz1qcyZcbmZ1bmN0aW9uIFRvb2xiYXJ2dWVfdHlwZV9zY3JpcHRfbGFuZ19qc19jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyKG8sIGFsbG93QXJyYXlMaWtlKSB7IHZhciBpdDsgaWYgKHR5cGVvZiBTeW1ib2wgPT09IFwidW5kZWZpbmVkXCIgfHwgb1tTeW1ib2wuaXRlcmF0b3JdID09IG51bGwpIHsgaWYgKEFycmF5LmlzQXJyYXkobykgfHwgKGl0ID0gVG9vbGJhcnZ1ZV90eXBlX3NjcmlwdF9sYW5nX2pzX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5KG8pKSB8fCBhbGxvd0FycmF5TGlrZSAmJiBvICYmIHR5cGVvZiBvLmxlbmd0aCA9PT0gXCJudW1iZXJcIikgeyBpZiAoaXQpIG8gPSBpdDsgdmFyIGkgPSAwOyB2YXIgRiA9IGZ1bmN0aW9uIEYoKSB7fTsgcmV0dXJuIHsgczogRiwgbjogZnVuY3Rpb24gbigpIHsgaWYgKGkgPj0gby5sZW5ndGgpIHJldHVybiB7IGRvbmU6IHRydWUgfTsgcmV0dXJuIHsgZG9uZTogZmFsc2UsIHZhbHVlOiBvW2krK10gfTsgfSwgZTogZnVuY3Rpb24gZShfZSkgeyB0aHJvdyBfZTsgfSwgZjogRiB9OyB9IHRocm93IG5ldyBUeXBlRXJyb3IoXCJJbnZhbGlkIGF0dGVtcHQgdG8gaXRlcmF0ZSBub24taXRlcmFibGUgaW5zdGFuY2UuXFxuSW4gb3JkZXIgdG8gYmUgaXRlcmFibGUsIG5vbi1hcnJheSBvYmplY3RzIG11c3QgaGF2ZSBhIFtTeW1ib2wuaXRlcmF0b3JdKCkgbWV0aG9kLlwiKTsgfSB2YXIgbm9ybWFsQ29tcGxldGlvbiA9IHRydWUsIGRpZEVyciA9IGZhbHNlLCBlcnI7IHJldHVybiB7IHM6IGZ1bmN0aW9uIHMoKSB7IGl0ID0gb1tTeW1ib2wuaXRlcmF0b3JdKCk7IH0sIG46IGZ1bmN0aW9uIG4oKSB7IHZhciBzdGVwID0gaXQubmV4dCgpOyBub3JtYWxDb21wbGV0aW9uID0gc3RlcC5kb25lOyByZXR1cm4gc3RlcDsgfSwgZTogZnVuY3Rpb24gZShfZTIpIHsgZGlkRXJyID0gdHJ1ZTsgZXJyID0gX2UyOyB9LCBmOiBmdW5jdGlvbiBmKCkgeyB0cnkgeyBpZiAoIW5vcm1hbENvbXBsZXRpb24gJiYgaXRbXCJyZXR1cm5cIl0gIT0gbnVsbCkgaXRbXCJyZXR1cm5cIl0oKTsgfSBmaW5hbGx5IHsgaWYgKGRpZEVycikgdGhyb3cgZXJyOyB9IH0gfTsgfVxuXG5mdW5jdGlvbiBUb29sYmFydnVlX3R5cGVfc2NyaXB0X2xhbmdfanNfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkobywgbWluTGVuKSB7IGlmICghbykgcmV0dXJuOyBpZiAodHlwZW9mIG8gPT09IFwic3RyaW5nXCIpIHJldHVybiBUb29sYmFydnVlX3R5cGVfc2NyaXB0X2xhbmdfanNfYXJyYXlMaWtlVG9BcnJheShvLCBtaW5MZW4pOyB2YXIgbiA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvKS5zbGljZSg4LCAtMSk7IGlmIChuID09PSBcIk9iamVjdFwiICYmIG8uY29uc3RydWN0b3IpIG4gPSBvLmNvbnN0cnVjdG9yLm5hbWU7IGlmIChuID09PSBcIk1hcFwiIHx8IG4gPT09IFwiU2V0XCIpIHJldHVybiBBcnJheS5mcm9tKG8pOyBpZiAobiA9PT0gXCJBcmd1bWVudHNcIiB8fCAvXig/OlVpfEkpbnQoPzo4fDE2fDMyKSg/OkNsYW1wZWQpP0FycmF5JC8udGVzdChuKSkgcmV0dXJuIFRvb2xiYXJ2dWVfdHlwZV9zY3JpcHRfbGFuZ19qc19hcnJheUxpa2VUb0FycmF5KG8sIG1pbkxlbik7IH1cblxuZnVuY3Rpb24gVG9vbGJhcnZ1ZV90eXBlX3NjcmlwdF9sYW5nX2pzX2FycmF5TGlrZVRvQXJyYXkoYXJyLCBsZW4pIHsgaWYgKGxlbiA9PSBudWxsIHx8IGxlbiA+IGFyci5sZW5ndGgpIGxlbiA9IGFyci5sZW5ndGg7IGZvciAodmFyIGkgPSAwLCBhcnIyID0gbmV3IEFycmF5KGxlbik7IGkgPCBsZW47IGkrKykgeyBhcnIyW2ldID0gYXJyW2ldOyB9IHJldHVybiBhcnIyOyB9XG5cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cblxuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyBjb25zdCBUb29sYmFydnVlX3R5cGVfc2NyaXB0X2xhbmdfanNfID0gKHtcbiAgbmFtZTogJ1Rvb2xiYXInLFxuICBwcm9wczogWydkYXRhJywgJ2hlaWdodCcsICdjb2xvcnMnLCAndHZfaWQnLCAnY29uZmlnJ10sXG4gIGNvbXBvbmVudHM6IHtcbiAgICBUb29sYmFySXRlbTogVG9vbGJhckl0ZW1cbiAgfSxcbiAgbW91bnRlZDogZnVuY3Rpb24gbW91bnRlZCgpIHt9LFxuICBtZXRob2RzOiB7XG4gICAgc2VsZWN0ZWQ6IGZ1bmN0aW9uIHNlbGVjdGVkKHRvb2wpIHtcbiAgICAgIHRoaXMuJGVtaXQoJ2N1c3RvbS1ldmVudCcsIHtcbiAgICAgICAgZXZlbnQ6ICd0b29sLXNlbGVjdGVkJyxcbiAgICAgICAgYXJnczogW3Rvb2wudHlwZV1cbiAgICAgIH0pO1xuXG4gICAgICBpZiAodG9vbC5ncm91cCkge1xuICAgICAgICAvLyBUT0RPOiBlbWl0IHRoZSBzdWIgbWFwIHRvIERDIChzYXZlKVxuICAgICAgICB0aGlzLnN1Yl9tYXBbdG9vbC5ncm91cF0gPSB0b29sLnR5cGU7XG4gICAgICB9XG4gICAgfSxcbiAgICBpc19zZWxlY3RlZDogZnVuY3Rpb24gaXNfc2VsZWN0ZWQodG9vbCkge1xuICAgICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgICAgaWYgKHRvb2wuZ3JvdXApIHtcbiAgICAgICAgcmV0dXJuICEhdG9vbC5pdGVtcy5maW5kKGZ1bmN0aW9uICh4KSB7XG4gICAgICAgICAgcmV0dXJuIHgudHlwZSA9PT0gX3RoaXMuZGF0YS50b29sO1xuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRvb2wudHlwZSA9PT0gdGhpcy5kYXRhLnRvb2w7XG4gICAgfVxuICB9LFxuICBjb21wdXRlZDoge1xuICAgIHN0eWxlczogZnVuY3Rpb24gc3R5bGVzKCkge1xuICAgICAgdmFyIGNvbG9ycyA9IHRoaXMuJHByb3BzLmNvbG9ycztcbiAgICAgIHZhciBiID0gdGhpcy4kcHJvcHMuY29uZmlnLlRCX0JPUkRFUjtcbiAgICAgIHZhciB3ID0gdGhpcy4kcHJvcHMuY29uZmlnLlRPT0xCQVIgLSBiO1xuICAgICAgdmFyIGMgPSBjb2xvcnMuZ3JpZDtcbiAgICAgIHZhciBjYiA9IGNvbG9ycy50YkJhY2sgfHwgY29sb3JzLmJhY2s7XG4gICAgICB2YXIgYnJkID0gY29sb3JzLnRiQm9yZGVyIHx8IGNvbG9ycy5zY2FsZTtcbiAgICAgIHZhciBzdCA9IHRoaXMuJHByb3BzLmNvbmZpZy5UQl9CX1NUWUxFO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgJ3dpZHRoJzogXCJcIi5jb25jYXQodywgXCJweFwiKSxcbiAgICAgICAgJ2hlaWdodCc6IFwiXCIuY29uY2F0KHRoaXMuJHByb3BzLmhlaWdodCAtIDMsIFwicHhcIiksXG4gICAgICAgICdiYWNrZ3JvdW5kLWNvbG9yJzogY2IsXG4gICAgICAgICdib3JkZXItcmlnaHQnOiBcIlwiLmNvbmNhdChiLCBcInB4IFwiKS5jb25jYXQoc3QsIFwiIFwiKS5jb25jYXQoYnJkKVxuICAgICAgfTtcbiAgICB9LFxuICAgIGdyb3VwczogZnVuY3Rpb24gZ3JvdXBzKCkge1xuICAgICAgdmFyIGFyciA9IFtdO1xuXG4gICAgICB2YXIgX2l0ZXJhdG9yID0gVG9vbGJhcnZ1ZV90eXBlX3NjcmlwdF9sYW5nX2pzX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXIodGhpcy5kYXRhLnRvb2xzIHx8IFtdKSxcbiAgICAgICAgICBfc3RlcDtcblxuICAgICAgdHJ5IHtcbiAgICAgICAgZm9yIChfaXRlcmF0b3IucygpOyAhKF9zdGVwID0gX2l0ZXJhdG9yLm4oKSkuZG9uZTspIHtcbiAgICAgICAgICB2YXIgdG9vbCA9IF9zdGVwLnZhbHVlO1xuXG4gICAgICAgICAgaWYgKCF0b29sLmdyb3VwKSB7XG4gICAgICAgICAgICBhcnIucHVzaCh0b29sKTtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHZhciBnID0gYXJyLmZpbmQoZnVuY3Rpb24gKHgpIHtcbiAgICAgICAgICAgIHJldHVybiB4Lmdyb3VwID09PSB0b29sLmdyb3VwO1xuICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgaWYgKCFnKSB7XG4gICAgICAgICAgICBhcnIucHVzaCh7XG4gICAgICAgICAgICAgIGdyb3VwOiB0b29sLmdyb3VwLFxuICAgICAgICAgICAgICBpY29uOiB0b29sLmljb24sXG4gICAgICAgICAgICAgIGl0ZW1zOiBbdG9vbF1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBnLml0ZW1zLnB1c2godG9vbCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgX2l0ZXJhdG9yLmUoZXJyKTtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIF9pdGVyYXRvci5mKCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBhcnI7XG4gICAgfVxuICB9LFxuICB3YXRjaDoge1xuICAgIGRhdGE6IHtcbiAgICAgIGhhbmRsZXI6IGZ1bmN0aW9uIGhhbmRsZXIobikge1xuICAgICAgICAvLyBGb3Igc29tZSByZWFzb24gVnVlLmpzIGRvZXNuJ3Qgd2FudCB0b1xuICAgICAgICAvLyB1cGRhdGUgJ3Rvb2xzJyBhdXRvbWF0aWNhbGx5IHdoZW4gbmV3IGl0ZW1cbiAgICAgICAgLy8gaXMgcHVzaGVkL3JlbW92ZWQuIFlvLCBWdWUsIEkgaGVyZCB5b3VcbiAgICAgICAgLy8geW91IHdhbnQgbW9yZSBkaXJ0eSB0cmlja3M/XG4gICAgICAgIGlmIChuLnRvb2xzKSB0aGlzLnRvb2xfY291bnQgPSBuLnRvb2xzLmxlbmd0aDtcbiAgICAgIH0sXG4gICAgICBkZWVwOiB0cnVlXG4gICAgfVxuICB9LFxuICBkYXRhOiBmdW5jdGlvbiBkYXRhKCkge1xuICAgIHJldHVybiB7XG4gICAgICB0b29sX2NvdW50OiAwLFxuICAgICAgc3ViX21hcDoge31cbiAgICB9O1xuICB9XG59KTtcbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9jb21wb25lbnRzL1Rvb2xiYXIudnVlP3Z1ZSZ0eXBlPXNjcmlwdCZsYW5nPWpzJlxuIC8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gY29uc3QgY29tcG9uZW50c19Ub29sYmFydnVlX3R5cGVfc2NyaXB0X2xhbmdfanNfID0gKFRvb2xiYXJ2dWVfdHlwZV9zY3JpcHRfbGFuZ19qc18pOyBcbi8vIEVYVEVSTkFMIE1PRFVMRTogLi9ub2RlX21vZHVsZXMvdnVlLXN0eWxlLWxvYWRlci9pbmRleC5qcyEuL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2Rpc3QvY2pzLmpzIS4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL2xvYWRlcnMvc3R5bGVQb3N0TG9hZGVyLmpzIS4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL2luZGV4LmpzPz92dWUtbG9hZGVyLW9wdGlvbnMhLi9zcmMvY29tcG9uZW50cy9Ub29sYmFyLnZ1ZT92dWUmdHlwZT1zdHlsZSZpbmRleD0wJmxhbmc9Y3NzJlxudmFyIFRvb2xiYXJ2dWVfdHlwZV9zdHlsZV9pbmRleF8wX2xhbmdfY3NzXyA9IF9fd2VicGFja19yZXF1aXJlX18oMTUzKTtcbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9jb21wb25lbnRzL1Rvb2xiYXIudnVlP3Z1ZSZ0eXBlPXN0eWxlJmluZGV4PTAmbGFuZz1jc3MmXG5cbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9jb21wb25lbnRzL1Rvb2xiYXIudnVlXG5cblxuXG47XG5cblxuLyogbm9ybWFsaXplIGNvbXBvbmVudCAqL1xuXG52YXIgVG9vbGJhcl9jb21wb25lbnQgPSBub3JtYWxpemVDb21wb25lbnQoXG4gIGNvbXBvbmVudHNfVG9vbGJhcnZ1ZV90eXBlX3NjcmlwdF9sYW5nX2pzXyxcbiAgVG9vbGJhcnZ1ZV90eXBlX3RlbXBsYXRlX2lkXzAyMTg4N2ZiX3JlbmRlcixcbiAgVG9vbGJhcnZ1ZV90eXBlX3RlbXBsYXRlX2lkXzAyMTg4N2ZiX3N0YXRpY1JlbmRlckZucyxcbiAgZmFsc2UsXG4gIG51bGwsXG4gIG51bGwsXG4gIG51bGxcbiAgXG4pXG5cbi8qIGhvdCByZWxvYWQgKi9cbmlmIChmYWxzZSkgeyB2YXIgVG9vbGJhcl9hcGk7IH1cblRvb2xiYXJfY29tcG9uZW50Lm9wdGlvbnMuX19maWxlID0gXCJzcmMvY29tcG9uZW50cy9Ub29sYmFyLnZ1ZVwiXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIGNvbnN0IFRvb2xiYXIgPSAoVG9vbGJhcl9jb21wb25lbnQuZXhwb3J0cyk7XG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvbG9hZGVycy90ZW1wbGF0ZUxvYWRlci5qcz8/dnVlLWxvYWRlci1vcHRpb25zIS4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL2luZGV4LmpzPz92dWUtbG9hZGVyLW9wdGlvbnMhLi9zcmMvY29tcG9uZW50cy9XaWRnZXRzLnZ1ZT92dWUmdHlwZT10ZW1wbGF0ZSZpZD01ZmU0MzEyZiZcbnZhciBXaWRnZXRzdnVlX3R5cGVfdGVtcGxhdGVfaWRfNWZlNDMxMmZfcmVuZGVyID0gZnVuY3Rpb24oKSB7XG4gIHZhciBfdm0gPSB0aGlzXG4gIHZhciBfaCA9IF92bS4kY3JlYXRlRWxlbWVudFxuICB2YXIgX2MgPSBfdm0uX3NlbGYuX2MgfHwgX2hcbiAgcmV0dXJuIF9jKFxuICAgIFwiZGl2XCIsXG4gICAge1xuICAgICAgc3RhdGljQ2xhc3M6IFwidHZqcy13aWRnZXRzXCIsXG4gICAgICBzdHlsZTogeyB3aWR0aDogX3ZtLndpZHRoICsgXCJweFwiLCBoZWlnaHQ6IF92bS5oZWlnaHQgKyBcInB4XCIgfVxuICAgIH0sXG4gICAgX3ZtLl9sKE9iamVjdC5rZXlzKF92bS5tYXApLCBmdW5jdGlvbihpZCkge1xuICAgICAgcmV0dXJuIF9jKF92bS5pbml0dyhpZCksIHtcbiAgICAgICAga2V5OiBpZCxcbiAgICAgICAgdGFnOiBcImNvbXBvbmVudFwiLFxuICAgICAgICBhdHRyczoge1xuICAgICAgICAgIGlkOiBpZCxcbiAgICAgICAgICBtYWluOiBfdm0ubWFwW2lkXS5jdHJsLFxuICAgICAgICAgIGRhdGE6IF92bS5tYXBbaWRdLmRhdGEsXG4gICAgICAgICAgdHY6IF92bS50dixcbiAgICAgICAgICBkYzogX3ZtLmRjXG4gICAgICAgIH1cbiAgICAgIH0pXG4gICAgfSksXG4gICAgMVxuICApXG59XG52YXIgV2lkZ2V0c3Z1ZV90eXBlX3RlbXBsYXRlX2lkXzVmZTQzMTJmX3N0YXRpY1JlbmRlckZucyA9IFtdXG5XaWRnZXRzdnVlX3R5cGVfdGVtcGxhdGVfaWRfNWZlNDMxMmZfcmVuZGVyLl93aXRoU3RyaXBwZWQgPSB0cnVlXG5cblxuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL2NvbXBvbmVudHMvV2lkZ2V0cy52dWU/dnVlJnR5cGU9dGVtcGxhdGUmaWQ9NWZlNDMxMmYmXG5cbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL25vZGVfbW9kdWxlcy9iYWJlbC1sb2FkZXIvbGliL2luZGV4LmpzIS4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL2luZGV4LmpzPz92dWUtbG9hZGVyLW9wdGlvbnMhLi9zcmMvY29tcG9uZW50cy9XaWRnZXRzLnZ1ZT92dWUmdHlwZT1zY3JpcHQmbGFuZz1qcyZcbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gY29uc3QgV2lkZ2V0c3Z1ZV90eXBlX3NjcmlwdF9sYW5nX2pzXyA9ICh7XG4gIG5hbWU6ICdXaWRnZXRzJyxcbiAgcHJvcHM6IFsnd2lkdGgnLCAnaGVpZ2h0JywgJ21hcCcsICd0dicsICdkYyddLFxuICBtZXRob2RzOiB7XG4gICAgaW5pdHc6IGZ1bmN0aW9uIGluaXR3KGlkKSB7XG4gICAgICByZXR1cm4gdGhpcy4kcHJvcHMubWFwW2lkXS5jbHM7XG4gICAgfVxuICB9XG59KTtcbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9jb21wb25lbnRzL1dpZGdldHMudnVlP3Z1ZSZ0eXBlPXNjcmlwdCZsYW5nPWpzJlxuIC8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gY29uc3QgY29tcG9uZW50c19XaWRnZXRzdnVlX3R5cGVfc2NyaXB0X2xhbmdfanNfID0gKFdpZGdldHN2dWVfdHlwZV9zY3JpcHRfbGFuZ19qc18pOyBcbi8vIEVYVEVSTkFMIE1PRFVMRTogLi9ub2RlX21vZHVsZXMvdnVlLXN0eWxlLWxvYWRlci9pbmRleC5qcyEuL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2Rpc3QvY2pzLmpzIS4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL2xvYWRlcnMvc3R5bGVQb3N0TG9hZGVyLmpzIS4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL2luZGV4LmpzPz92dWUtbG9hZGVyLW9wdGlvbnMhLi9zcmMvY29tcG9uZW50cy9XaWRnZXRzLnZ1ZT92dWUmdHlwZT1zdHlsZSZpbmRleD0wJmxhbmc9Y3NzJlxudmFyIFdpZGdldHN2dWVfdHlwZV9zdHlsZV9pbmRleF8wX2xhbmdfY3NzXyA9IF9fd2VicGFja19yZXF1aXJlX18oNSk7XG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvY29tcG9uZW50cy9XaWRnZXRzLnZ1ZT92dWUmdHlwZT1zdHlsZSZpbmRleD0wJmxhbmc9Y3NzJlxuXG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvY29tcG9uZW50cy9XaWRnZXRzLnZ1ZVxuXG5cblxuO1xuXG5cbi8qIG5vcm1hbGl6ZSBjb21wb25lbnQgKi9cblxudmFyIFdpZGdldHNfY29tcG9uZW50ID0gbm9ybWFsaXplQ29tcG9uZW50KFxuICBjb21wb25lbnRzX1dpZGdldHN2dWVfdHlwZV9zY3JpcHRfbGFuZ19qc18sXG4gIFdpZGdldHN2dWVfdHlwZV90ZW1wbGF0ZV9pZF81ZmU0MzEyZl9yZW5kZXIsXG4gIFdpZGdldHN2dWVfdHlwZV90ZW1wbGF0ZV9pZF81ZmU0MzEyZl9zdGF0aWNSZW5kZXJGbnMsXG4gIGZhbHNlLFxuICBudWxsLFxuICBudWxsLFxuICBudWxsXG4gIFxuKVxuXG4vKiBob3QgcmVsb2FkICovXG5pZiAoZmFsc2UpIHsgdmFyIFdpZGdldHNfYXBpOyB9XG5XaWRnZXRzX2NvbXBvbmVudC5vcHRpb25zLl9fZmlsZSA9IFwic3JjL2NvbXBvbmVudHMvV2lkZ2V0cy52dWVcIlxuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyBjb25zdCBXaWRnZXRzID0gKFdpZGdldHNfY29tcG9uZW50LmV4cG9ydHMpO1xuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL2xvYWRlcnMvdGVtcGxhdGVMb2FkZXIuanM/P3Z1ZS1sb2FkZXItb3B0aW9ucyEuL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9pbmRleC5qcz8/dnVlLWxvYWRlci1vcHRpb25zIS4vc3JjL2NvbXBvbmVudHMvVGhlVGlwLnZ1ZT92dWUmdHlwZT10ZW1wbGF0ZSZpZD0yYzE3NzBjYyZcbnZhciBUaGVUaXB2dWVfdHlwZV90ZW1wbGF0ZV9pZF8yYzE3NzBjY19yZW5kZXIgPSBmdW5jdGlvbigpIHtcbiAgdmFyIF92bSA9IHRoaXNcbiAgdmFyIF9oID0gX3ZtLiRjcmVhdGVFbGVtZW50XG4gIHZhciBfYyA9IF92bS5fc2VsZi5fYyB8fCBfaFxuICByZXR1cm4gX2MoXCJkaXZcIiwge1xuICAgIHN0YXRpY0NsYXNzOiBcInR2anMtdGhlLXRpcFwiLFxuICAgIHN0eWxlOiBfdm0uc3R5bGUsXG4gICAgZG9tUHJvcHM6IHsgaW5uZXJIVE1MOiBfdm0uX3MoX3ZtLmRhdGEudGV4dCkgfSxcbiAgICBvbjoge1xuICAgICAgbW91c2Vkb3duOiBmdW5jdGlvbigkZXZlbnQpIHtcbiAgICAgICAgcmV0dXJuIF92bS4kZW1pdChcInJlbW92ZS1tZVwiKVxuICAgICAgfVxuICAgIH1cbiAgfSlcbn1cbnZhciBUaGVUaXB2dWVfdHlwZV90ZW1wbGF0ZV9pZF8yYzE3NzBjY19zdGF0aWNSZW5kZXJGbnMgPSBbXVxuVGhlVGlwdnVlX3R5cGVfdGVtcGxhdGVfaWRfMmMxNzcwY2NfcmVuZGVyLl93aXRoU3RyaXBwZWQgPSB0cnVlXG5cblxuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL2NvbXBvbmVudHMvVGhlVGlwLnZ1ZT92dWUmdHlwZT10ZW1wbGF0ZSZpZD0yYzE3NzBjYyZcblxuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vbm9kZV9tb2R1bGVzL2JhYmVsLWxvYWRlci9saWIvaW5kZXguanMhLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvaW5kZXguanM/P3Z1ZS1sb2FkZXItb3B0aW9ucyEuL3NyYy9jb21wb25lbnRzL1RoZVRpcC52dWU/dnVlJnR5cGU9c2NyaXB0Jmxhbmc9anMmXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIGNvbnN0IFRoZVRpcHZ1ZV90eXBlX3NjcmlwdF9sYW5nX2pzXyA9ICh7XG4gIG5hbWU6ICdUaGVUaXAnLFxuICBwcm9wczogWydkYXRhJ10sXG4gIG1vdW50ZWQ6IGZ1bmN0aW9uIG1vdW50ZWQoKSB7XG4gICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIF90aGlzLiRlbWl0KCdyZW1vdmUtbWUnKTtcbiAgICB9LCAzMDAwKTtcbiAgfSxcbiAgY29tcHV0ZWQ6IHtcbiAgICBzdHlsZTogZnVuY3Rpb24gc3R5bGUoKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBiYWNrZ3JvdW5kOiB0aGlzLmRhdGEuY29sb3JcbiAgICAgIH07XG4gICAgfVxuICB9XG59KTtcbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9jb21wb25lbnRzL1RoZVRpcC52dWU/dnVlJnR5cGU9c2NyaXB0Jmxhbmc9anMmXG4gLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyBjb25zdCBjb21wb25lbnRzX1RoZVRpcHZ1ZV90eXBlX3NjcmlwdF9sYW5nX2pzXyA9IChUaGVUaXB2dWVfdHlwZV9zY3JpcHRfbGFuZ19qc18pOyBcbi8vIEVYVEVSTkFMIE1PRFVMRTogLi9ub2RlX21vZHVsZXMvdnVlLXN0eWxlLWxvYWRlci9pbmRleC5qcyEuL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2Rpc3QvY2pzLmpzIS4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL2xvYWRlcnMvc3R5bGVQb3N0TG9hZGVyLmpzIS4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL2luZGV4LmpzPz92dWUtbG9hZGVyLW9wdGlvbnMhLi9zcmMvY29tcG9uZW50cy9UaGVUaXAudnVlP3Z1ZSZ0eXBlPXN0eWxlJmluZGV4PTAmbGFuZz1jc3MmXG52YXIgVGhlVGlwdnVlX3R5cGVfc3R5bGVfaW5kZXhfMF9sYW5nX2Nzc18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQ3Nyk7XG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvY29tcG9uZW50cy9UaGVUaXAudnVlP3Z1ZSZ0eXBlPXN0eWxlJmluZGV4PTAmbGFuZz1jc3MmXG5cbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9jb21wb25lbnRzL1RoZVRpcC52dWVcblxuXG5cbjtcblxuXG4vKiBub3JtYWxpemUgY29tcG9uZW50ICovXG5cbnZhciBUaGVUaXBfY29tcG9uZW50ID0gbm9ybWFsaXplQ29tcG9uZW50KFxuICBjb21wb25lbnRzX1RoZVRpcHZ1ZV90eXBlX3NjcmlwdF9sYW5nX2pzXyxcbiAgVGhlVGlwdnVlX3R5cGVfdGVtcGxhdGVfaWRfMmMxNzcwY2NfcmVuZGVyLFxuICBUaGVUaXB2dWVfdHlwZV90ZW1wbGF0ZV9pZF8yYzE3NzBjY19zdGF0aWNSZW5kZXJGbnMsXG4gIGZhbHNlLFxuICBudWxsLFxuICBudWxsLFxuICBudWxsXG4gIFxuKVxuXG4vKiBob3QgcmVsb2FkICovXG5pZiAoZmFsc2UpIHsgdmFyIFRoZVRpcF9hcGk7IH1cblRoZVRpcF9jb21wb25lbnQub3B0aW9ucy5fX2ZpbGUgPSBcInNyYy9jb21wb25lbnRzL1RoZVRpcC52dWVcIlxuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyBjb25zdCBUaGVUaXAgPSAoVGhlVGlwX2NvbXBvbmVudC5leHBvcnRzKTtcbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9taXhpbnMveGNvbnRyb2wuanNcbmZ1bmN0aW9uIHhjb250cm9sX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXIobywgYWxsb3dBcnJheUxpa2UpIHsgdmFyIGl0OyBpZiAodHlwZW9mIFN5bWJvbCA9PT0gXCJ1bmRlZmluZWRcIiB8fCBvW1N5bWJvbC5pdGVyYXRvcl0gPT0gbnVsbCkgeyBpZiAoQXJyYXkuaXNBcnJheShvKSB8fCAoaXQgPSB4Y29udHJvbF91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheShvKSkgfHwgYWxsb3dBcnJheUxpa2UgJiYgbyAmJiB0eXBlb2Ygby5sZW5ndGggPT09IFwibnVtYmVyXCIpIHsgaWYgKGl0KSBvID0gaXQ7IHZhciBpID0gMDsgdmFyIEYgPSBmdW5jdGlvbiBGKCkge307IHJldHVybiB7IHM6IEYsIG46IGZ1bmN0aW9uIG4oKSB7IGlmIChpID49IG8ubGVuZ3RoKSByZXR1cm4geyBkb25lOiB0cnVlIH07IHJldHVybiB7IGRvbmU6IGZhbHNlLCB2YWx1ZTogb1tpKytdIH07IH0sIGU6IGZ1bmN0aW9uIGUoX2UpIHsgdGhyb3cgX2U7IH0sIGY6IEYgfTsgfSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiSW52YWxpZCBhdHRlbXB0IHRvIGl0ZXJhdGUgbm9uLWl0ZXJhYmxlIGluc3RhbmNlLlxcbkluIG9yZGVyIHRvIGJlIGl0ZXJhYmxlLCBub24tYXJyYXkgb2JqZWN0cyBtdXN0IGhhdmUgYSBbU3ltYm9sLml0ZXJhdG9yXSgpIG1ldGhvZC5cIik7IH0gdmFyIG5vcm1hbENvbXBsZXRpb24gPSB0cnVlLCBkaWRFcnIgPSBmYWxzZSwgZXJyOyByZXR1cm4geyBzOiBmdW5jdGlvbiBzKCkgeyBpdCA9IG9bU3ltYm9sLml0ZXJhdG9yXSgpOyB9LCBuOiBmdW5jdGlvbiBuKCkgeyB2YXIgc3RlcCA9IGl0Lm5leHQoKTsgbm9ybWFsQ29tcGxldGlvbiA9IHN0ZXAuZG9uZTsgcmV0dXJuIHN0ZXA7IH0sIGU6IGZ1bmN0aW9uIGUoX2UyKSB7IGRpZEVyciA9IHRydWU7IGVyciA9IF9lMjsgfSwgZjogZnVuY3Rpb24gZigpIHsgdHJ5IHsgaWYgKCFub3JtYWxDb21wbGV0aW9uICYmIGl0W1wicmV0dXJuXCJdICE9IG51bGwpIGl0W1wicmV0dXJuXCJdKCk7IH0gZmluYWxseSB7IGlmIChkaWRFcnIpIHRocm93IGVycjsgfSB9IH07IH1cblxuZnVuY3Rpb24geGNvbnRyb2xfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkobywgbWluTGVuKSB7IGlmICghbykgcmV0dXJuOyBpZiAodHlwZW9mIG8gPT09IFwic3RyaW5nXCIpIHJldHVybiB4Y29udHJvbF9hcnJheUxpa2VUb0FycmF5KG8sIG1pbkxlbik7IHZhciBuID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG8pLnNsaWNlKDgsIC0xKTsgaWYgKG4gPT09IFwiT2JqZWN0XCIgJiYgby5jb25zdHJ1Y3RvcikgbiA9IG8uY29uc3RydWN0b3IubmFtZTsgaWYgKG4gPT09IFwiTWFwXCIgfHwgbiA9PT0gXCJTZXRcIikgcmV0dXJuIEFycmF5LmZyb20obyk7IGlmIChuID09PSBcIkFyZ3VtZW50c1wiIHx8IC9eKD86VWl8SSludCg/Ojh8MTZ8MzIpKD86Q2xhbXBlZCk/QXJyYXkkLy50ZXN0KG4pKSByZXR1cm4geGNvbnRyb2xfYXJyYXlMaWtlVG9BcnJheShvLCBtaW5MZW4pOyB9XG5cbmZ1bmN0aW9uIHhjb250cm9sX2FycmF5TGlrZVRvQXJyYXkoYXJyLCBsZW4pIHsgaWYgKGxlbiA9PSBudWxsIHx8IGxlbiA+IGFyci5sZW5ndGgpIGxlbiA9IGFyci5sZW5ndGg7IGZvciAodmFyIGkgPSAwLCBhcnIyID0gbmV3IEFycmF5KGxlbik7IGkgPCBsZW47IGkrKykgeyBhcnIyW2ldID0gYXJyW2ldOyB9IHJldHVybiBhcnIyOyB9XG5cbi8vIGV4dGVuc2lvbnMgY29udHJvbFxuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyBjb25zdCB4Y29udHJvbCA9ICh7XG4gIG1vdW50ZWQ6IGZ1bmN0aW9uIG1vdW50ZWQoKSB7XG4gICAgdGhpcy5jdHJsbGlzdCgpO1xuICAgIHRoaXMuc2tpbl9zdHlsZXMoKTtcbiAgfSxcbiAgbWV0aG9kczoge1xuICAgIC8vIEJ1aWxkIC8gcmVidWlsZCBjb21wb25lbnQgbGlzdFxuICAgIGN0cmxsaXN0OiBmdW5jdGlvbiBjdHJsbGlzdCgpIHtcbiAgICAgIHRoaXMuY3RybF9kZXN0cm95KCk7XG4gICAgICB0aGlzLmNvbnRyb2xsZXJzID0gW107XG5cbiAgICAgIHZhciBfaXRlcmF0b3IgPSB4Y29udHJvbF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyKHRoaXMuJHByb3BzLmV4dGVuc2lvbnMpLFxuICAgICAgICAgIF9zdGVwO1xuXG4gICAgICB0cnkge1xuICAgICAgICBmb3IgKF9pdGVyYXRvci5zKCk7ICEoX3N0ZXAgPSBfaXRlcmF0b3IubigpKS5kb25lOykge1xuICAgICAgICAgIHZhciB4ID0gX3N0ZXAudmFsdWU7XG4gICAgICAgICAgdmFyIG5hbWUgPSB4Lk1haW4uX19uYW1lX187XG5cbiAgICAgICAgICBpZiAoIXRoaXMueFNldHRpbmdzW25hbWVdKSB7XG4gICAgICAgICAgICB0aGlzLiRzZXQodGhpcy54U2V0dGluZ3MsIG5hbWUsIHt9KTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB2YXIgbmMgPSBuZXcgeC5NYWluKHRoaXMsIC8vIHR2IGluc3RcbiAgICAgICAgICB0aGlzLmRhdGEsIC8vIGRjXG4gICAgICAgICAgdGhpcy54U2V0dGluZ3NbbmFtZV0gLy8gc2V0dGluZ3NcbiAgICAgICAgICApO1xuICAgICAgICAgIG5jLm5hbWUgPSBuYW1lO1xuICAgICAgICAgIHRoaXMuY29udHJvbGxlcnMucHVzaChuYyk7XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICBfaXRlcmF0b3IuZShlcnIpO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgX2l0ZXJhdG9yLmYoKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXMuY29udHJvbGxlcnM7XG4gICAgfSxcbiAgICAvLyBUT0RPOiBwcmV2ZW50RGVmYXVsdFxuICAgIHByZV9kYzogZnVuY3Rpb24gcHJlX2RjKGUpIHtcbiAgICAgIHZhciBfaXRlcmF0b3IyID0geGNvbnRyb2xfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlcih0aGlzLmNvbnRyb2xsZXJzKSxcbiAgICAgICAgICBfc3RlcDI7XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIGZvciAoX2l0ZXJhdG9yMi5zKCk7ICEoX3N0ZXAyID0gX2l0ZXJhdG9yMi5uKCkpLmRvbmU7KSB7XG4gICAgICAgICAgdmFyIGN0cmwgPSBfc3RlcDIudmFsdWU7XG5cbiAgICAgICAgICBpZiAoY3RybC51cGRhdGUpIHtcbiAgICAgICAgICAgIGN0cmwudXBkYXRlKGUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIF9pdGVyYXRvcjIuZShlcnIpO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgX2l0ZXJhdG9yMi5mKCk7XG4gICAgICB9XG4gICAgfSxcbiAgICBwb3N0X2RjOiBmdW5jdGlvbiBwb3N0X2RjKGUpIHtcbiAgICAgIHZhciBfaXRlcmF0b3IzID0geGNvbnRyb2xfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlcih0aGlzLmNvbnRyb2xsZXJzKSxcbiAgICAgICAgICBfc3RlcDM7XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIGZvciAoX2l0ZXJhdG9yMy5zKCk7ICEoX3N0ZXAzID0gX2l0ZXJhdG9yMy5uKCkpLmRvbmU7KSB7XG4gICAgICAgICAgdmFyIGN0cmwgPSBfc3RlcDMudmFsdWU7XG5cbiAgICAgICAgICBpZiAoY3RybC5wb3N0X3VwZGF0ZSkge1xuICAgICAgICAgICAgY3RybC5wb3N0X3VwZGF0ZShlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICBfaXRlcmF0b3IzLmUoZXJyKTtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIF9pdGVyYXRvcjMuZigpO1xuICAgICAgfVxuICAgIH0sXG4gICAgY3RybF9kZXN0cm95OiBmdW5jdGlvbiBjdHJsX2Rlc3Ryb3koKSB7XG4gICAgICB2YXIgX2l0ZXJhdG9yNCA9IHhjb250cm9sX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXIodGhpcy5jb250cm9sbGVycyksXG4gICAgICAgICAgX3N0ZXA0O1xuXG4gICAgICB0cnkge1xuICAgICAgICBmb3IgKF9pdGVyYXRvcjQucygpOyAhKF9zdGVwNCA9IF9pdGVyYXRvcjQubigpKS5kb25lOykge1xuICAgICAgICAgIHZhciBjdHJsID0gX3N0ZXA0LnZhbHVlO1xuICAgICAgICAgIGlmIChjdHJsLmRlc3Ryb3kpIGN0cmwuZGVzdHJveSgpO1xuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgX2l0ZXJhdG9yNC5lKGVycik7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICBfaXRlcmF0b3I0LmYoKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIHNraW5fc3R5bGVzOiBmdW5jdGlvbiBza2luX3N0eWxlcygpIHtcbiAgICAgIHZhciBpZCA9ICd0dmpzLXNraW4tc3R5bGVzJztcbiAgICAgIHZhciBzdGJyID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoaWQpO1xuXG4gICAgICBpZiAoc3Ricikge1xuICAgICAgICB2YXIgcGFyZW50ID0gc3Rici5wYXJlbnROb2RlO1xuICAgICAgICBwYXJlbnQucmVtb3ZlQ2hpbGQoc3Ricik7XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLnNraW5fcHJvdG8gJiYgdGhpcy5za2luX3Byb3RvLnN0eWxlcykge1xuICAgICAgICB2YXIgc2hlZXQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzdHlsZScpO1xuICAgICAgICBzaGVldC5zZXRBdHRyaWJ1dGUoXCJpZFwiLCBpZCk7XG4gICAgICAgIHNoZWV0LmlubmVySFRNTCA9IHRoaXMuc2tpbl9wcm90by5zdHlsZXM7XG4gICAgICAgIHRoaXMuJGVsLmFwcGVuZENoaWxkKHNoZWV0KTtcbiAgICAgIH1cbiAgICB9XG4gIH0sXG4gIGNvbXB1dGVkOiB7XG4gICAgd3M6IGZ1bmN0aW9uIHdzKCkge1xuICAgICAgdmFyIHdzID0ge307XG5cbiAgICAgIHZhciBfaXRlcmF0b3I1ID0geGNvbnRyb2xfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlcih0aGlzLmNvbnRyb2xsZXJzKSxcbiAgICAgICAgICBfc3RlcDU7XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIGZvciAoX2l0ZXJhdG9yNS5zKCk7ICEoX3N0ZXA1ID0gX2l0ZXJhdG9yNS5uKCkpLmRvbmU7KSB7XG4gICAgICAgICAgdmFyIGN0cmwgPSBfc3RlcDUudmFsdWU7XG5cbiAgICAgICAgICBpZiAoY3RybC53aWRnZXRzKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBpZCBpbiBjdHJsLndpZGdldHMpIHtcbiAgICAgICAgICAgICAgd3NbaWRdID0gY3RybC53aWRnZXRzW2lkXTtcbiAgICAgICAgICAgICAgd3NbaWRdLmN0cmwgPSBjdHJsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIF9pdGVyYXRvcjUuZShlcnIpO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgX2l0ZXJhdG9yNS5mKCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB3cztcbiAgICB9LFxuICAgIHNraW5zOiBmdW5jdGlvbiBza2lucygpIHtcbiAgICAgIHZhciBza3MgPSB7fTtcblxuICAgICAgdmFyIF9pdGVyYXRvcjYgPSB4Y29udHJvbF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyKHRoaXMuJHByb3BzLmV4dGVuc2lvbnMpLFxuICAgICAgICAgIF9zdGVwNjtcblxuICAgICAgdHJ5IHtcbiAgICAgICAgZm9yIChfaXRlcmF0b3I2LnMoKTsgIShfc3RlcDYgPSBfaXRlcmF0b3I2Lm4oKSkuZG9uZTspIHtcbiAgICAgICAgICB2YXIgeCA9IF9zdGVwNi52YWx1ZTtcblxuICAgICAgICAgIGZvciAodmFyIGlkIGluIHguc2tpbnMgfHwge30pIHtcbiAgICAgICAgICAgIHNrc1tpZF0gPSB4LnNraW5zW2lkXTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICBfaXRlcmF0b3I2LmUoZXJyKTtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIF9pdGVyYXRvcjYuZigpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gc2tzO1xuICAgIH0sXG4gICAgc2tpbl9wcm90bzogZnVuY3Rpb24gc2tpbl9wcm90bygpIHtcbiAgICAgIHJldHVybiB0aGlzLnNraW5zW3RoaXMuJHByb3BzLnNraW5dO1xuICAgIH0sXG4gICAgY29sb3JwYWNrOiBmdW5jdGlvbiBjb2xvcnBhY2soKSB7XG4gICAgICB2YXIgc2VsID0gdGhpcy5za2luc1t0aGlzLiRwcm9wcy5za2luXTtcbiAgICAgIHJldHVybiBzZWwgPyBzZWwuY29sb3JzIDogdW5kZWZpbmVkO1xuICAgIH1cbiAgfSxcbiAgd2F0Y2g6IHtcbiAgICAvLyBUT0RPOiBUaGlzIGlzIGZhc3QgJiBkaXJ0eSBmaXgsIG5lZWRcbiAgICAvLyB0byBmaXggdGhlIGFjdHVhbCByZWFjdGl2aXR5IHByb2JsZW1cbiAgICBza2luOiBmdW5jdGlvbiBza2luKG4sIHApIHtcbiAgICAgIGlmIChuICE9PSBwKSB0aGlzLnJlc2V0Q2hhcnQoKTtcbiAgICAgIHRoaXMuc2tpbl9zdHlsZXMoKTtcbiAgICB9LFxuICAgIGV4dGVuc2lvbnM6IGZ1bmN0aW9uIGV4dGVuc2lvbnMoKSB7XG4gICAgICB0aGlzLmN0cmxsaXN0KCk7XG4gICAgfSxcbiAgICB4U2V0dGluZ3M6IHtcbiAgICAgIGhhbmRsZXI6IGZ1bmN0aW9uIGhhbmRsZXIobiwgcCkge1xuICAgICAgICB2YXIgX2l0ZXJhdG9yNyA9IHhjb250cm9sX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXIodGhpcy5jb250cm9sbGVycyksXG4gICAgICAgICAgICBfc3RlcDc7XG5cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBmb3IgKF9pdGVyYXRvcjcucygpOyAhKF9zdGVwNyA9IF9pdGVyYXRvcjcubigpKS5kb25lOykge1xuICAgICAgICAgICAgdmFyIGN0cmwgPSBfc3RlcDcudmFsdWU7XG5cbiAgICAgICAgICAgIGlmIChjdHJsLm9uc2V0dGluZ3MpIHtcbiAgICAgICAgICAgICAgY3RybC5vbnNldHRpbmdzKG4sIHApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgX2l0ZXJhdG9yNy5lKGVycik7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgX2l0ZXJhdG9yNy5mKCk7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBkZWVwOiB0cnVlXG4gICAgfVxuICB9LFxuICBkYXRhOiBmdW5jdGlvbiBkYXRhKCkge1xuICAgIHJldHVybiB7XG4gICAgICBjb250cm9sbGVyczogW11cbiAgICB9O1xuICB9XG59KTtcbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL25vZGVfbW9kdWxlcy9iYWJlbC1sb2FkZXIvbGliL2luZGV4LmpzIS4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL2luZGV4LmpzPz92dWUtbG9hZGVyLW9wdGlvbnMhLi9zcmMvVHJhZGluZ1Z1ZS52dWU/dnVlJnR5cGU9c2NyaXB0Jmxhbmc9anMmXG5cblxuZnVuY3Rpb24gVHJhZGluZ1Z1ZXZ1ZV90eXBlX3NjcmlwdF9sYW5nX2pzX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXIobywgYWxsb3dBcnJheUxpa2UpIHsgdmFyIGl0OyBpZiAodHlwZW9mIFN5bWJvbCA9PT0gXCJ1bmRlZmluZWRcIiB8fCBvW1N5bWJvbC5pdGVyYXRvcl0gPT0gbnVsbCkgeyBpZiAoQXJyYXkuaXNBcnJheShvKSB8fCAoaXQgPSBUcmFkaW5nVnVldnVlX3R5cGVfc2NyaXB0X2xhbmdfanNfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkobykpIHx8IGFsbG93QXJyYXlMaWtlICYmIG8gJiYgdHlwZW9mIG8ubGVuZ3RoID09PSBcIm51bWJlclwiKSB7IGlmIChpdCkgbyA9IGl0OyB2YXIgaSA9IDA7IHZhciBGID0gZnVuY3Rpb24gRigpIHt9OyByZXR1cm4geyBzOiBGLCBuOiBmdW5jdGlvbiBuKCkgeyBpZiAoaSA+PSBvLmxlbmd0aCkgcmV0dXJuIHsgZG9uZTogdHJ1ZSB9OyByZXR1cm4geyBkb25lOiBmYWxzZSwgdmFsdWU6IG9baSsrXSB9OyB9LCBlOiBmdW5jdGlvbiBlKF9lKSB7IHRocm93IF9lOyB9LCBmOiBGIH07IH0gdGhyb3cgbmV3IFR5cGVFcnJvcihcIkludmFsaWQgYXR0ZW1wdCB0byBpdGVyYXRlIG5vbi1pdGVyYWJsZSBpbnN0YW5jZS5cXG5JbiBvcmRlciB0byBiZSBpdGVyYWJsZSwgbm9uLWFycmF5IG9iamVjdHMgbXVzdCBoYXZlIGEgW1N5bWJvbC5pdGVyYXRvcl0oKSBtZXRob2QuXCIpOyB9IHZhciBub3JtYWxDb21wbGV0aW9uID0gdHJ1ZSwgZGlkRXJyID0gZmFsc2UsIGVycjsgcmV0dXJuIHsgczogZnVuY3Rpb24gcygpIHsgaXQgPSBvW1N5bWJvbC5pdGVyYXRvcl0oKTsgfSwgbjogZnVuY3Rpb24gbigpIHsgdmFyIHN0ZXAgPSBpdC5uZXh0KCk7IG5vcm1hbENvbXBsZXRpb24gPSBzdGVwLmRvbmU7IHJldHVybiBzdGVwOyB9LCBlOiBmdW5jdGlvbiBlKF9lMikgeyBkaWRFcnIgPSB0cnVlOyBlcnIgPSBfZTI7IH0sIGY6IGZ1bmN0aW9uIGYoKSB7IHRyeSB7IGlmICghbm9ybWFsQ29tcGxldGlvbiAmJiBpdFtcInJldHVyblwiXSAhPSBudWxsKSBpdFtcInJldHVyblwiXSgpOyB9IGZpbmFsbHkgeyBpZiAoZGlkRXJyKSB0aHJvdyBlcnI7IH0gfSB9OyB9XG5cbmZ1bmN0aW9uIFRyYWRpbmdWdWV2dWVfdHlwZV9zY3JpcHRfbGFuZ19qc191bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheShvLCBtaW5MZW4pIHsgaWYgKCFvKSByZXR1cm47IGlmICh0eXBlb2YgbyA9PT0gXCJzdHJpbmdcIikgcmV0dXJuIFRyYWRpbmdWdWV2dWVfdHlwZV9zY3JpcHRfbGFuZ19qc19hcnJheUxpa2VUb0FycmF5KG8sIG1pbkxlbik7IHZhciBuID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG8pLnNsaWNlKDgsIC0xKTsgaWYgKG4gPT09IFwiT2JqZWN0XCIgJiYgby5jb25zdHJ1Y3RvcikgbiA9IG8uY29uc3RydWN0b3IubmFtZTsgaWYgKG4gPT09IFwiTWFwXCIgfHwgbiA9PT0gXCJTZXRcIikgcmV0dXJuIEFycmF5LmZyb20obyk7IGlmIChuID09PSBcIkFyZ3VtZW50c1wiIHx8IC9eKD86VWl8SSludCg/Ojh8MTZ8MzIpKD86Q2xhbXBlZCk/QXJyYXkkLy50ZXN0KG4pKSByZXR1cm4gVHJhZGluZ1Z1ZXZ1ZV90eXBlX3NjcmlwdF9sYW5nX2pzX2FycmF5TGlrZVRvQXJyYXkobywgbWluTGVuKTsgfVxuXG5mdW5jdGlvbiBUcmFkaW5nVnVldnVlX3R5cGVfc2NyaXB0X2xhbmdfanNfYXJyYXlMaWtlVG9BcnJheShhcnIsIGxlbikgeyBpZiAobGVuID09IG51bGwgfHwgbGVuID4gYXJyLmxlbmd0aCkgbGVuID0gYXJyLmxlbmd0aDsgZm9yICh2YXIgaSA9IDAsIGFycjIgPSBuZXcgQXJyYXkobGVuKTsgaSA8IGxlbjsgaSsrKSB7IGFycjJbaV0gPSBhcnJbaV07IH0gcmV0dXJuIGFycjI7IH1cblxuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cblxuXG5cblxuXG5cbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gY29uc3QgVHJhZGluZ1Z1ZXZ1ZV90eXBlX3NjcmlwdF9sYW5nX2pzXyA9ICh7XG4gIG5hbWU6ICdUcmFkaW5nVnVlJyxcbiAgY29tcG9uZW50czoge1xuICAgIENoYXJ0OiBDaGFydCxcbiAgICBUb29sYmFyOiBUb29sYmFyLFxuICAgIFdpZGdldHM6IFdpZGdldHMsXG4gICAgVGhlVGlwOiBUaGVUaXBcbiAgfSxcbiAgbWl4aW5zOiBbeGNvbnRyb2xdLFxuICBwcm9wczoge1xuICAgIHRpdGxlVHh0OiB7XG4gICAgICB0eXBlOiBTdHJpbmcsXG4gICAgICBcImRlZmF1bHRcIjogJ1RyYWRpbmdWdWUuanMnXG4gICAgfSxcbiAgICBpZDoge1xuICAgICAgdHlwZTogU3RyaW5nLFxuICAgICAgXCJkZWZhdWx0XCI6ICd0cmFkaW5nLXZ1ZS1qcydcbiAgICB9LFxuICAgIHdpZHRoOiB7XG4gICAgICB0eXBlOiBOdW1iZXIsXG4gICAgICBcImRlZmF1bHRcIjogODAwXG4gICAgfSxcbiAgICBoZWlnaHQ6IHtcbiAgICAgIHR5cGU6IE51bWJlcixcbiAgICAgIFwiZGVmYXVsdFwiOiA0MjFcbiAgICB9LFxuICAgIGNvbG9yVGl0bGU6IHtcbiAgICAgIHR5cGU6IFN0cmluZyxcbiAgICAgIFwiZGVmYXVsdFwiOiAnIzQyYjg4MydcbiAgICB9LFxuICAgIGNvbG9yQmFjazoge1xuICAgICAgdHlwZTogU3RyaW5nLFxuICAgICAgXCJkZWZhdWx0XCI6ICcjMTIxODI2J1xuICAgIH0sXG4gICAgY29sb3JHcmlkOiB7XG4gICAgICB0eXBlOiBTdHJpbmcsXG4gICAgICBcImRlZmF1bHRcIjogJyMyZjMyNDAnXG4gICAgfSxcbiAgICBjb2xvclRleHQ6IHtcbiAgICAgIHR5cGU6IFN0cmluZyxcbiAgICAgIFwiZGVmYXVsdFwiOiAnI2RlZGRkZCdcbiAgICB9LFxuICAgIGNvbG9yVGV4dEhMOiB7XG4gICAgICB0eXBlOiBTdHJpbmcsXG4gICAgICBcImRlZmF1bHRcIjogJyNmZmYnXG4gICAgfSxcbiAgICBjb2xvclNjYWxlOiB7XG4gICAgICB0eXBlOiBTdHJpbmcsXG4gICAgICBcImRlZmF1bHRcIjogJyM4MzgzODMnXG4gICAgfSxcbiAgICBjb2xvckNyb3NzOiB7XG4gICAgICB0eXBlOiBTdHJpbmcsXG4gICAgICBcImRlZmF1bHRcIjogJyM4MDkxYTAnXG4gICAgfSxcbiAgICBjb2xvckNhbmRsZVVwOiB7XG4gICAgICB0eXBlOiBTdHJpbmcsXG4gICAgICBcImRlZmF1bHRcIjogJyMyM2E3NzYnXG4gICAgfSxcbiAgICBjb2xvckNhbmRsZUR3OiB7XG4gICAgICB0eXBlOiBTdHJpbmcsXG4gICAgICBcImRlZmF1bHRcIjogJyNlNTQxNTAnXG4gICAgfSxcbiAgICBjb2xvcldpY2tVcDoge1xuICAgICAgdHlwZTogU3RyaW5nLFxuICAgICAgXCJkZWZhdWx0XCI6ICcjMjNhNzc2ODgnXG4gICAgfSxcbiAgICBjb2xvcldpY2tEdzoge1xuICAgICAgdHlwZTogU3RyaW5nLFxuICAgICAgXCJkZWZhdWx0XCI6ICcjZTU0MTUwODgnXG4gICAgfSxcbiAgICBjb2xvcldpY2tTbToge1xuICAgICAgdHlwZTogU3RyaW5nLFxuICAgICAgXCJkZWZhdWx0XCI6ICd0cmFuc3BhcmVudCcgLy8gZGVwcmVjYXRlZFxuXG4gICAgfSxcbiAgICBjb2xvclZvbFVwOiB7XG4gICAgICB0eXBlOiBTdHJpbmcsXG4gICAgICBcImRlZmF1bHRcIjogJyM3OTk5OWU0MidcbiAgICB9LFxuICAgIGNvbG9yVm9sRHc6IHtcbiAgICAgIHR5cGU6IFN0cmluZyxcbiAgICAgIFwiZGVmYXVsdFwiOiAnI2VmNTM1MDQyJ1xuICAgIH0sXG4gICAgY29sb3JQYW5lbDoge1xuICAgICAgdHlwZTogU3RyaW5nLFxuICAgICAgXCJkZWZhdWx0XCI6ICcjNTY1YzY4J1xuICAgIH0sXG4gICAgY29sb3JUYkJhY2s6IHtcbiAgICAgIHR5cGU6IFN0cmluZ1xuICAgIH0sXG4gICAgY29sb3JUYkJvcmRlcjoge1xuICAgICAgdHlwZTogU3RyaW5nLFxuICAgICAgXCJkZWZhdWx0XCI6ICcjODI4MjgyN2QnXG4gICAgfSxcbiAgICBjb2xvcnM6IHtcbiAgICAgIHR5cGU6IE9iamVjdFxuICAgIH0sXG4gICAgZm9udDoge1xuICAgICAgdHlwZTogU3RyaW5nLFxuICAgICAgXCJkZWZhdWx0XCI6IGNvbnN0YW50cy5DaGFydENvbmZpZy5GT05UXG4gICAgfSxcbiAgICB0b29sYmFyOiB7XG4gICAgICB0eXBlOiBCb29sZWFuLFxuICAgICAgXCJkZWZhdWx0XCI6IGZhbHNlXG4gICAgfSxcbiAgICBkYXRhOiB7XG4gICAgICB0eXBlOiBPYmplY3QsXG4gICAgICByZXF1aXJlZDogdHJ1ZVxuICAgIH0sXG4gICAgLy8gWW91ciBvdmVybGF5IGNsYXNzZXMgaGVyZVxuICAgIG92ZXJsYXlzOiB7XG4gICAgICB0eXBlOiBBcnJheSxcbiAgICAgIFwiZGVmYXVsdFwiOiBmdW5jdGlvbiBfZGVmYXVsdCgpIHtcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgfVxuICAgIH0sXG4gICAgLy8gT3ZlcndyaXRlcyBDaGFydENvbmZpZyB2YWx1ZXMsXG4gICAgLy8gc2VlIGNvbnN0YW50cy5qc1xuICAgIGNoYXJ0Q29uZmlnOiB7XG4gICAgICB0eXBlOiBPYmplY3QsXG4gICAgICBcImRlZmF1bHRcIjogZnVuY3Rpb24gX2RlZmF1bHQoKSB7XG4gICAgICAgIHJldHVybiB7fTtcbiAgICAgIH1cbiAgICB9LFxuICAgIGxlZ2VuZEJ1dHRvbnM6IHtcbiAgICAgIHR5cGU6IEFycmF5LFxuICAgICAgXCJkZWZhdWx0XCI6IGZ1bmN0aW9uIF9kZWZhdWx0KCkge1xuICAgICAgICByZXR1cm4gW107XG4gICAgICB9XG4gICAgfSxcbiAgICBpbmRleEJhc2VkOiB7XG4gICAgICB0eXBlOiBCb29sZWFuLFxuICAgICAgXCJkZWZhdWx0XCI6IGZhbHNlXG4gICAgfSxcbiAgICBleHRlbnNpb25zOiB7XG4gICAgICB0eXBlOiBBcnJheSxcbiAgICAgIFwiZGVmYXVsdFwiOiBmdW5jdGlvbiBfZGVmYXVsdCgpIHtcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgfVxuICAgIH0sXG4gICAgeFNldHRpbmdzOiB7XG4gICAgICB0eXBlOiBPYmplY3QsXG4gICAgICBcImRlZmF1bHRcIjogZnVuY3Rpb24gX2RlZmF1bHQoKSB7XG4gICAgICAgIHJldHVybiB7fTtcbiAgICAgIH1cbiAgICB9LFxuICAgIHNraW46IHtcbiAgICAgIHR5cGU6IFN0cmluZyAvLyBTa2luIE5hbWVcblxuICAgIH0sXG4gICAgdGltZXpvbmU6IHtcbiAgICAgIHR5cGU6IE51bWJlcixcbiAgICAgIFwiZGVmYXVsdFwiOiAwXG4gICAgfVxuICB9LFxuICBjb21wdXRlZDoge1xuICAgIC8vIENvcHkgYSBzdWJzZXQgb2YgVHJhZGluZ1Z1ZSBwcm9wc1xuICAgIGNoYXJ0X3Byb3BzOiBmdW5jdGlvbiBjaGFydF9wcm9wcygpIHtcbiAgICAgIHZhciBvZmZzZXQgPSB0aGlzLiRwcm9wcy50b29sYmFyID8gdGhpcy5jaGFydF9jb25maWcuVE9PTEJBUiA6IDA7XG4gICAgICB2YXIgY2hhcnRfcHJvcHMgPSB7XG4gICAgICAgIHRpdGxlX3R4dDogdGhpcy4kcHJvcHMudGl0bGVUeHQsXG4gICAgICAgIG92ZXJsYXlzOiB0aGlzLiRwcm9wcy5vdmVybGF5cy5jb25jYXQodGhpcy5tb2Rfb3ZzKSxcbiAgICAgICAgZGF0YTogdGhpcy5kZWN1YmVkLFxuICAgICAgICB3aWR0aDogdGhpcy4kcHJvcHMud2lkdGggLSBvZmZzZXQsXG4gICAgICAgIGhlaWdodDogdGhpcy4kcHJvcHMuaGVpZ2h0LFxuICAgICAgICBmb250OiB0aGlzLmZvbnRfY29tcCxcbiAgICAgICAgYnV0dG9uczogdGhpcy4kcHJvcHMubGVnZW5kQnV0dG9ucyxcbiAgICAgICAgdG9vbGJhcjogdGhpcy4kcHJvcHMudG9vbGJhcixcbiAgICAgICAgaWI6IHRoaXMuJHByb3BzLmluZGV4QmFzZWQgfHwgdGhpcy5pbmRleF9iYXNlZCB8fCBmYWxzZSxcbiAgICAgICAgY29sb3JzOiBPYmplY3QuYXNzaWduKHt9LCB0aGlzLiRwcm9wcy5jb2xvcnMgfHwgdGhpcy5jb2xvcnBhY2spLFxuICAgICAgICBza2luOiB0aGlzLnNraW5fcHJvdG8sXG4gICAgICAgIHRpbWV6b25lOiB0aGlzLiRwcm9wcy50aW1lem9uZVxuICAgICAgfTtcbiAgICAgIHRoaXMucGFyc2VfY29sb3JzKGNoYXJ0X3Byb3BzLmNvbG9ycyk7XG4gICAgICByZXR1cm4gY2hhcnRfcHJvcHM7XG4gICAgfSxcbiAgICBjaGFydF9jb25maWc6IGZ1bmN0aW9uIGNoYXJ0X2NvbmZpZygpIHtcbiAgICAgIHJldHVybiBPYmplY3QuYXNzaWduKHt9LCBjb25zdGFudHMuQ2hhcnRDb25maWcsIHRoaXMuJHByb3BzLmNoYXJ0Q29uZmlnKTtcbiAgICB9LFxuICAgIGRlY3ViZWQ6IGZ1bmN0aW9uIGRlY3ViZWQoKSB7XG4gICAgICB2YXIgZGF0YSA9IHRoaXMuJHByb3BzLmRhdGE7XG5cbiAgICAgIGlmIChkYXRhLmRhdGEgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAvLyBEYXRhQ3ViZSBkZXRlY3RlZFxuICAgICAgICBkYXRhLmluaXRfdHZqcyh0aGlzKTtcbiAgICAgICAgcmV0dXJuIGRhdGEuZGF0YTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBkYXRhO1xuICAgICAgfVxuICAgIH0sXG4gICAgaW5kZXhfYmFzZWQ6IGZ1bmN0aW9uIGluZGV4X2Jhc2VkKCkge1xuICAgICAgdmFyIGJhc2UgPSB0aGlzLiRwcm9wcy5kYXRhO1xuXG4gICAgICBpZiAoYmFzZS5jaGFydCkge1xuICAgICAgICByZXR1cm4gYmFzZS5jaGFydC5pbmRleEJhc2VkO1xuICAgICAgfSBlbHNlIGlmIChiYXNlLmRhdGEpIHtcbiAgICAgICAgcmV0dXJuIGJhc2UuZGF0YS5jaGFydC5pbmRleEJhc2VkO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSxcbiAgICBtb2Rfb3ZzOiBmdW5jdGlvbiBtb2Rfb3ZzKCkge1xuICAgICAgdmFyIGFyciA9IFtdO1xuXG4gICAgICB2YXIgX2l0ZXJhdG9yID0gVHJhZGluZ1Z1ZXZ1ZV90eXBlX3NjcmlwdF9sYW5nX2pzX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXIodGhpcy4kcHJvcHMuZXh0ZW5zaW9ucyksXG4gICAgICAgICAgX3N0ZXA7XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIGZvciAoX2l0ZXJhdG9yLnMoKTsgIShfc3RlcCA9IF9pdGVyYXRvci5uKCkpLmRvbmU7KSB7XG4gICAgICAgICAgdmFyIHggPSBfc3RlcC52YWx1ZTtcbiAgICAgICAgICBhcnIucHVzaC5hcHBseShhcnIsIF90b0NvbnN1bWFibGVBcnJheShPYmplY3QudmFsdWVzKHgub3ZlcmxheXMpKSk7XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICBfaXRlcmF0b3IuZShlcnIpO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgX2l0ZXJhdG9yLmYoKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGFycjtcbiAgICB9LFxuICAgIGZvbnRfY29tcDogZnVuY3Rpb24gZm9udF9jb21wKCkge1xuICAgICAgcmV0dXJuIHRoaXMuc2tpbl9wcm90byAmJiB0aGlzLnNraW5fcHJvdG8uZm9udCA/IHRoaXMuc2tpbl9wcm90by5mb250IDogdGhpcy5mb250O1xuICAgIH1cbiAgfSxcbiAgZGF0YTogZnVuY3Rpb24gZGF0YSgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgcmVzZXQ6IDAsXG4gICAgICB0aXA6IG51bGxcbiAgICB9O1xuICB9LFxuICBiZWZvcmVEZXN0cm95OiBmdW5jdGlvbiBiZWZvcmVEZXN0cm95KCkge1xuICAgIHRoaXMuY3VzdG9tX2V2ZW50KHtcbiAgICAgIGV2ZW50OiAnYmVmb3JlLWRlc3Ryb3knXG4gICAgfSk7XG4gICAgdGhpcy5jdHJsX2Rlc3Ryb3koKTtcbiAgfSxcbiAgbWV0aG9kczoge1xuICAgIC8vIFRPRE86IHJlc2V0IGV4dGVuc2lvbnM/XG4gICAgcmVzZXRDaGFydDogZnVuY3Rpb24gcmVzZXRDaGFydChyZXNldFJhbmdlKSB7XG4gICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgICBpZiAocmVzZXRSYW5nZSA9PT0gdm9pZCAwKSB7XG4gICAgICAgIHJlc2V0UmFuZ2UgPSB0cnVlO1xuICAgICAgfVxuXG4gICAgICB0aGlzLnJlc2V0Kys7XG4gICAgICB2YXIgcmFuZ2UgPSB0aGlzLmdldFJhbmdlKCk7XG5cbiAgICAgIGlmICghcmVzZXRSYW5nZSAmJiByYW5nZVswXSAmJiByYW5nZVsxXSkge1xuICAgICAgICB0aGlzLiRuZXh0VGljayhmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgcmV0dXJuIF90aGlzLnNldFJhbmdlLmFwcGx5KF90aGlzLCBfdG9Db25zdW1hYmxlQXJyYXkocmFuZ2UpKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuJG5leHRUaWNrKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIF90aGlzLmN1c3RvbV9ldmVudCh7XG4gICAgICAgICAgZXZlbnQ6ICdjaGFydC1yZXNldCcsXG4gICAgICAgICAgYXJnczogW11cbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICB9LFxuICAgIFwiZ290b1wiOiBmdW5jdGlvbiBnb3RvKHQpIHtcbiAgICAgIC8vIFRPRE86IGxpbWl0IGdvdG8gJiBzZXRSYW5nZSAob3V0IG9mIGRhdGEgZXJyb3IpXG4gICAgICBpZiAodGhpcy5jaGFydF9wcm9wcy5pYikge1xuICAgICAgICB2YXIgdGlfbWFwID0gdGhpcy4kcmVmcy5jaGFydC50aV9tYXA7XG4gICAgICAgIHQgPSB0aV9tYXAuZ3QyaSh0LCB0aGlzLiRyZWZzLmNoYXJ0Lm9obGN2KTtcbiAgICAgIH1cblxuICAgICAgdGhpcy4kcmVmcy5jaGFydFtcImdvdG9cIl0odCk7XG4gICAgfSxcbiAgICBzZXRSYW5nZTogZnVuY3Rpb24gc2V0UmFuZ2UodDEsIHQyKSB7XG4gICAgICBpZiAodGhpcy5jaGFydF9wcm9wcy5pYikge1xuICAgICAgICB2YXIgdGlfbWFwID0gdGhpcy4kcmVmcy5jaGFydC50aV9tYXA7XG4gICAgICAgIHZhciBvaGxjdiA9IHRoaXMuJHJlZnMuY2hhcnQub2hsY3Y7XG4gICAgICAgIHQxID0gdGlfbWFwLmd0MmkodDEsIG9obGN2KTtcbiAgICAgICAgdDIgPSB0aV9tYXAuZ3QyaSh0Miwgb2hsY3YpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLiRyZWZzLmNoYXJ0LnNldFJhbmdlKHQxLCB0Mik7XG4gICAgfSxcbiAgICBnZXRSYW5nZTogZnVuY3Rpb24gZ2V0UmFuZ2UoKSB7XG4gICAgICBpZiAodGhpcy5jaGFydF9wcm9wcy5pYikge1xuICAgICAgICB2YXIgdGlfbWFwID0gdGhpcy4kcmVmcy5jaGFydC50aV9tYXA7IC8vIFRpbWUgcmFuZ2UgPT4gaW5kZXggcmFuZ2VcblxuICAgICAgICByZXR1cm4gdGhpcy4kcmVmcy5jaGFydC5yYW5nZS5tYXAoZnVuY3Rpb24gKHgpIHtcbiAgICAgICAgICByZXR1cm4gdGlfbWFwLmkydCh4KTtcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzLiRyZWZzLmNoYXJ0LnJhbmdlO1xuICAgIH0sXG4gICAgZ2V0Q3Vyc29yOiBmdW5jdGlvbiBnZXRDdXJzb3IoKSB7XG4gICAgICB2YXIgY3Vyc29yID0gdGhpcy4kcmVmcy5jaGFydC5jdXJzb3I7XG5cbiAgICAgIGlmICh0aGlzLmNoYXJ0X3Byb3BzLmliKSB7XG4gICAgICAgIHZhciB0aV9tYXAgPSB0aGlzLiRyZWZzLmNoYXJ0LnRpX21hcDtcbiAgICAgICAgdmFyIGNvcHkgPSBPYmplY3QuYXNzaWduKHt9LCBjdXJzb3IpO1xuICAgICAgICBjb3B5LmkgPSBjb3B5LnQ7XG4gICAgICAgIGNvcHkudCA9IHRpX21hcC5pMnQoY29weS50KTtcbiAgICAgICAgcmV0dXJuIGNvcHk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBjdXJzb3I7XG4gICAgfSxcbiAgICBzaG93VGhlVGlwOiBmdW5jdGlvbiBzaG93VGhlVGlwKHRleHQsIGNvbG9yKSB7XG4gICAgICBpZiAoY29sb3IgPT09IHZvaWQgMCkge1xuICAgICAgICBjb2xvciA9IFwib3JhbmdlXCI7XG4gICAgICB9XG5cbiAgICAgIHRoaXMudGlwID0ge1xuICAgICAgICB0ZXh0OiB0ZXh0LFxuICAgICAgICBjb2xvcjogY29sb3JcbiAgICAgIH07XG4gICAgfSxcbiAgICBsZWdlbmRfYnV0dG9uOiBmdW5jdGlvbiBsZWdlbmRfYnV0dG9uKGV2ZW50KSB7XG4gICAgICB0aGlzLmN1c3RvbV9ldmVudCh7XG4gICAgICAgIGV2ZW50OiAnbGVnZW5kLWJ1dHRvbi1jbGljaycsXG4gICAgICAgIGFyZ3M6IFtldmVudF1cbiAgICAgIH0pO1xuICAgIH0sXG4gICAgY3VzdG9tX2V2ZW50OiBmdW5jdGlvbiBjdXN0b21fZXZlbnQoZCkge1xuICAgICAgaWYgKCdhcmdzJyBpbiBkKSB7XG4gICAgICAgIHRoaXMuJGVtaXQuYXBwbHkodGhpcywgW2QuZXZlbnRdLmNvbmNhdChfdG9Db25zdW1hYmxlQXJyYXkoZC5hcmdzKSkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy4kZW1pdChkLmV2ZW50KTtcbiAgICAgIH1cblxuICAgICAgdmFyIGRhdGEgPSB0aGlzLiRwcm9wcy5kYXRhO1xuICAgICAgdmFyIGN0cmwgPSB0aGlzLmNvbnRyb2xsZXJzLmxlbmd0aCAhPT0gMDtcbiAgICAgIGlmIChjdHJsKSB0aGlzLnByZV9kYyhkKTtcblxuICAgICAgaWYgKGRhdGEudHYpIHtcbiAgICAgICAgLy8gSWYgdGhlIGRhdGEgb2JqZWN0IGlzIERhdGFDdWJlXG4gICAgICAgIGRhdGEub25fY3VzdG9tX2V2ZW50KGQuZXZlbnQsIGQuYXJncyk7XG4gICAgICB9XG5cbiAgICAgIGlmIChjdHJsKSB0aGlzLnBvc3RfZGMoZCk7XG4gICAgfSxcbiAgICByYW5nZV9jaGFuZ2VkOiBmdW5jdGlvbiByYW5nZV9jaGFuZ2VkKHIpIHtcbiAgICAgIGlmICh0aGlzLmNoYXJ0X3Byb3BzLmliKSB7XG4gICAgICAgIHZhciB0aV9tYXAgPSB0aGlzLiRyZWZzLmNoYXJ0LnRpX21hcDtcbiAgICAgICAgciA9IHIubWFwKGZ1bmN0aW9uICh4KSB7XG4gICAgICAgICAgcmV0dXJuIHRpX21hcC5pMnQoeCk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICB0aGlzLiRlbWl0KCdyYW5nZS1jaGFuZ2VkJywgcik7XG4gICAgICB0aGlzLmN1c3RvbV9ldmVudCh7XG4gICAgICAgIGV2ZW50OiAncmFuZ2UtY2hhbmdlZCcsXG4gICAgICAgIGFyZ3M6IFtyXVxuICAgICAgfSk7XG4gICAgICBpZiAodGhpcy5vbnJhbmdlKSB0aGlzLm9ucmFuZ2Uocik7XG4gICAgfSxcbiAgICBzZXRfbG9hZGVyOiBmdW5jdGlvbiBzZXRfbG9hZGVyKGRjKSB7XG4gICAgICB2YXIgX3RoaXMyID0gdGhpcztcblxuICAgICAgdGhpcy5vbnJhbmdlID0gZnVuY3Rpb24gKHIpIHtcbiAgICAgICAgdmFyIHBmID0gX3RoaXMyLmNoYXJ0X3Byb3BzLmliID8gJ19tcycgOiAnJztcbiAgICAgICAgdmFyIHRmID0gX3RoaXMyLiRyZWZzLmNoYXJ0WydpbnRlcnZhbCcgKyBwZl07XG4gICAgICAgIGRjLnJhbmdlX2NoYW5nZWQociwgdGYpO1xuICAgICAgfTtcbiAgICB9LFxuICAgIHBhcnNlX2NvbG9yczogZnVuY3Rpb24gcGFyc2VfY29sb3JzKGNvbG9ycykge1xuICAgICAgZm9yICh2YXIgayBpbiB0aGlzLiRwcm9wcykge1xuICAgICAgICBpZiAoay5pbmRleE9mKCdjb2xvcicpID09PSAwICYmIGsgIT09ICdjb2xvcnMnKSB7XG4gICAgICAgICAgdmFyIGsyID0gay5yZXBsYWNlKCdjb2xvcicsICcnKTtcbiAgICAgICAgICBrMiA9IGsyWzBdLnRvTG93ZXJDYXNlKCkgKyBrMi5zbGljZSgxKTtcbiAgICAgICAgICBpZiAoY29sb3JzW2syXSkgY29udGludWU7XG4gICAgICAgICAgY29sb3JzW2syXSA9IHRoaXMuJHByb3BzW2tdO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcbiAgICBtb3VzZWRvd246IGZ1bmN0aW9uIG1vdXNlZG93bigpIHtcbiAgICAgIHRoaXMuJHJlZnMuY2hhcnQuYWN0aXZhdGVkID0gdHJ1ZTtcbiAgICB9LFxuICAgIG1vdXNlbGVhdmU6IGZ1bmN0aW9uIG1vdXNlbGVhdmUoKSB7XG4gICAgICB0aGlzLiRyZWZzLmNoYXJ0LmFjdGl2YXRlZCA9IGZhbHNlO1xuICAgIH1cbiAgfVxufSk7XG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvVHJhZGluZ1Z1ZS52dWU/dnVlJnR5cGU9c2NyaXB0Jmxhbmc9anMmXG4gLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyBjb25zdCBzcmNfVHJhZGluZ1Z1ZXZ1ZV90eXBlX3NjcmlwdF9sYW5nX2pzXyA9IChUcmFkaW5nVnVldnVlX3R5cGVfc2NyaXB0X2xhbmdfanNfKTsgXG4vLyBFWFRFUk5BTCBNT0RVTEU6IC4vbm9kZV9tb2R1bGVzL3Z1ZS1zdHlsZS1sb2FkZXIvaW5kZXguanMhLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9kaXN0L2Nqcy5qcyEuL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9sb2FkZXJzL3N0eWxlUG9zdExvYWRlci5qcyEuL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9pbmRleC5qcz8/dnVlLWxvYWRlci1vcHRpb25zIS4vc3JjL1RyYWRpbmdWdWUudnVlP3Z1ZSZ0eXBlPXN0eWxlJmluZGV4PTAmbGFuZz1jc3MmXG52YXIgVHJhZGluZ1Z1ZXZ1ZV90eXBlX3N0eWxlX2luZGV4XzBfbGFuZ19jc3NfID0gX193ZWJwYWNrX3JlcXVpcmVfXyg4NjMpO1xuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL1RyYWRpbmdWdWUudnVlP3Z1ZSZ0eXBlPXN0eWxlJmluZGV4PTAmbGFuZz1jc3MmXG5cbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9UcmFkaW5nVnVlLnZ1ZVxuXG5cblxuO1xuXG5cbi8qIG5vcm1hbGl6ZSBjb21wb25lbnQgKi9cblxudmFyIFRyYWRpbmdWdWVfY29tcG9uZW50ID0gbm9ybWFsaXplQ29tcG9uZW50KFxuICBzcmNfVHJhZGluZ1Z1ZXZ1ZV90eXBlX3NjcmlwdF9sYW5nX2pzXyxcbiAgcmVuZGVyLFxuICBzdGF0aWNSZW5kZXJGbnMsXG4gIGZhbHNlLFxuICBudWxsLFxuICBudWxsLFxuICBudWxsXG4gIFxuKVxuXG4vKiBob3QgcmVsb2FkICovXG5pZiAoZmFsc2UpIHsgdmFyIFRyYWRpbmdWdWVfYXBpOyB9XG5UcmFkaW5nVnVlX2NvbXBvbmVudC5vcHRpb25zLl9fZmlsZSA9IFwic3JjL1RyYWRpbmdWdWUudnVlXCJcbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gY29uc3QgVHJhZGluZ1Z1ZSA9IChUcmFkaW5nVnVlX2NvbXBvbmVudC5leHBvcnRzKTtcbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9hc3luY1RvR2VuZXJhdG9yLmpzXG5mdW5jdGlvbiBhc3luY0dlbmVyYXRvclN0ZXAoZ2VuLCByZXNvbHZlLCByZWplY3QsIF9uZXh0LCBfdGhyb3csIGtleSwgYXJnKSB7XG4gIHRyeSB7XG4gICAgdmFyIGluZm8gPSBnZW5ba2V5XShhcmcpO1xuICAgIHZhciB2YWx1ZSA9IGluZm8udmFsdWU7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgcmVqZWN0KGVycm9yKTtcbiAgICByZXR1cm47XG4gIH1cblxuICBpZiAoaW5mby5kb25lKSB7XG4gICAgcmVzb2x2ZSh2YWx1ZSk7XG4gIH0gZWxzZSB7XG4gICAgUHJvbWlzZS5yZXNvbHZlKHZhbHVlKS50aGVuKF9uZXh0LCBfdGhyb3cpO1xuICB9XG59XG5cbmZ1bmN0aW9uIF9hc3luY1RvR2VuZXJhdG9yKGZuKSB7XG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzLFxuICAgICAgICBhcmdzID0gYXJndW1lbnRzO1xuICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICB2YXIgZ2VuID0gZm4uYXBwbHkoc2VsZiwgYXJncyk7XG5cbiAgICAgIGZ1bmN0aW9uIF9uZXh0KHZhbHVlKSB7XG4gICAgICAgIGFzeW5jR2VuZXJhdG9yU3RlcChnZW4sIHJlc29sdmUsIHJlamVjdCwgX25leHQsIF90aHJvdywgXCJuZXh0XCIsIHZhbHVlKTtcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gX3Rocm93KGVycikge1xuICAgICAgICBhc3luY0dlbmVyYXRvclN0ZXAoZ2VuLCByZXNvbHZlLCByZWplY3QsIF9uZXh0LCBfdGhyb3csIFwidGhyb3dcIiwgZXJyKTtcbiAgICAgIH1cblxuICAgICAgX25leHQodW5kZWZpbmVkKTtcbiAgICB9KTtcbiAgfTtcbn1cbi8vIEVYVEVSTkFMIE1PRFVMRTogLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvcmVnZW5lcmF0b3IvaW5kZXguanNcbnZhciByZWdlbmVyYXRvciA9IF9fd2VicGFja19yZXF1aXJlX18oNzU3KTtcbnZhciByZWdlbmVyYXRvcl9kZWZhdWx0ID0gLyojX19QVVJFX18qL19fd2VicGFja19yZXF1aXJlX18ubihyZWdlbmVyYXRvcik7XG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvaGVscGVycy90bXAvd3ckJCQuanNvblxuY29uc3Qgd3ckJCRfbmFtZXNwYWNlT2JqZWN0ID0gSlNPTi5wYXJzZSgnW1wiQlRDVUY0RDRHOERjRU1CT0FDQUx1YUIyQXJKZ1hNS2dEUUNtUkFkaERLZ0hRa0FlQURnUGFLb0RPNDV3QWJINkFGOGkyQUN3ODg2YW5TYXNPR2NnRmNBdGdHTWxqUEFETUY1RmFnQ1d6YnNSS2hvaUVxZ1dKeWFBTFFraDdWSWpVYnR1ZzBjS2t6RnF6Wm9BRHdrQVB4MkFJd1NrR0ZSQUF3Q2lVUThtQUFjQkNZVVZIQkl5SWhjd05oeGNhQkUrZ1dpUEtYd0JSRnhFYUFBM0I1NmhyYnNQcWJRK3ByQUFJU0lOUHJzQU1xeThBQkdBRFlrQUlLSWlQQUFuZ0F5K2dEV0pJU2dvS2dBRm9qTUFPN0k1Q1FuQUtJTHJNQUFSQUNTNUFoVCtnQW15Sy93cVBDM1RUMzlKQUFQb0RhRE55QUJ6ZmFRT0lBTWhoZldBSkdRK2xzcUFBMm5FQUxvN2ZhSEU1blM3WFJCM1I3UE43SThpdkJpL1JyN1lZMFQ3ZmNERU9uc0lhVWhqZ01pc21qc1N3QUlXWU9rK2lIMEpBNnBSNUttWTZpUUpIQXQwVVNnbUpFUXQzQXpLV2pCSXpFMGFEMjlLVUtOZ29YME5DVmJqd1p1Y3JuVVJCNWZLUUtqMjRIZ3ZKSVRyMjlvTmJPZUxFNDBDRVV1czdGWVhBVVV5bTN2cFozb3FDbXgzRGtlamJOamRQQkxzVWtZRXRBWUxEWW5IWVJEWmpFT3FHWXFDMUpIZHFBQXdqTEdITHdDMHZNWXpQOWJpMjJyYytwcnRicTBMc0RzZFR1ZGtGZERzU0hrOTRDOTNraHdjb1NPUlVEVC9OWlVUNmFOTFpSWm1TbW5EUlN4V0sxV2F5TVBhNFhWM3ZLaDI3MU96cFdrWWUzMmRYcTc3aVJ3VHgwU1NUTzUyUUJjbHhYTmRMQTNmVjZVZEs5OTFaUTlqM0xTdHRWNVdSbXlmVnN3QnlGQjBGWlVobVMzRkVxWG9ScDEwQ0hsR1RkVU0yQkFHOXVISUloRUQ4Y0N5TzNCczVXQWNnMFJJVEVHSzQ3RUJCMkZNYTBGWVVrREZDVUQyTEk4eTFQWkMrVlFFVEtURThVME04TnBNSVFiRDhQcENpOEo1UWlHQkk1ak4wTlkxbVJvTUZJVDJPRjBTeFBpaEtVZUI2RmdjekxQMkd5MFZCWmNyTWlURjdMZ3FTRU5rNnRORXNaMVZPZk50dWw2T0lOVzB0a0tJczd6OWxBVWlUTFpGUVF6RExNb3g1Tk1FeU9KTmNxM05NRFF6SXFVMGFmNUlqaXFVMklzSHdlU05KNGRqU3lDTXF5L0ljcUUvTEUyNnZLR0hURjA0a3EvNElscXJjZDBiQnFXUzNSem5OYTR6MnUzVHFLb0d1TUN2aWhrdmpkTnk5a2lIckJyS3pNSTJLNFpHazA1QjVSNVAxbUhZVHpNU3EzcFREYWtLaFVwVUpDRW0xYnF3TStoRG8ydnJUb0JvYWl0QURKdnNRS2kxcEt3Yk51clVzU0ZnRUhqcTVjMUJzbEgwTHR5Y2d0dWc1MXQxbktZdnVHZTBtamE0TW9leTlraUpCemJ5R2twR1VmMGNxR2JUU1NTeGtwRHEzQlN3SW93dTlvRlFHeXQxQzFCblcyYkdVR3V5R3FLTWdKYkJ5M3N1VkNjaWRyNHZBY3Zncm16MTUxQUFDVjRBaGVWYU02ZTlnSEdqVTZ0M0xZVEVXaFcwVWVua3hZbHU4cGRPTGJNcXB4QmdYV29iYVZGc0s5a1JKcEx2eVNtcU45MkhBYU9lV0lKeXVMeUdCQk9OVVFVSkhZa0xkRXZZRjRWQzJlakVBQWFnYUpJNmlpU1JvRm9xNmZBTHNvaUhnTXhMczRJdnlFZ051SWlJWmhQZnEyMjBYWVB6OUk1ZWdlUDBjbWx1WVVKVy9BTlA0RFJmUk1Rd1RSM3RlUEErZzd2N05lQnhIWUR3WmdnamlVSkVEd1JBRHJUWGY5OFA0dmo0RVhmb1ZDYXNWQ0prbWkySWVqMkFPL1I2L0JoK245dzRoMkdMZ3hPdURjOEN6M25vdlplcThSb2J5TE52VGV5WXo1YXh6TklmTUhCM1NlbjV1cFFXbDFjWnEyK0hIUUlQOUl6UHdvRVFFYURNOW9IVm12U1c2N0JCQkNDS0hFQ1FVQWhZb05rR3lZWVl3MkNUQm1QTVJZcXdOZ20zUWxncGlDdGtDbTBGbWxQb0NKaFl3bHVNd0NZQUFyRWdlaDFSdmdITEk0WUFBeEZFK2hVQzJ5U2hDRktObERGV1VnT0FXRU1JdkpHSmRCcUFBc2w4UFlOQk5BSmh1TllxeW9BVEY3U0NDSUFBVEFBVGhFUDRsSUFTcWdDRzJIQ0NSb2lOd0lqNktnWUU4aWxFcU5YTDJibUdpRW0wVmZHa2o4S0UyQ0NHMkVrUGc0Z0s2WFNFV3BXOFpoYmdLRDVNZ0cwK2hWSHV6SUxqQUE4a2t2UTBrVHpjd1lsd0dnZXg0RHNHYVVjY2dBQUZRNDJvMkJMREtBcVRKVnNxd0RoR0VzWlV6QXBpaEFXVXNxWWVCQXoxM0FHYVBScW92aXNBU1FBQVNPWHN4WTVZMVRGaDJUUWZwU3hkRDNIMGVjdzVnSmJnbk51ZmN4NUJ6TGxkek5PV0VZTGdVVGdnQUNyd0hCTWNvNWZ5QVVRaEJlQ1c0elJoRkdHUUFvVG9XUnpCTFZhY285cFZKTkFvaElLTTVnNHpLd29weUZNQlFKQk5ha0NWUHM2WTVLK2dqV2xPUUhGaTVGZzBxZ1VRSTRvcHZpc3JwUUplMGZFY3lJQ1dOQVpGV3piaS9BRUkvY1d3ZEJZS0V3YmVVZ3FLS1o4UzRJa0t1MHFGVUYwYnJrY29KQTRRSXgxdHFDa3pnalo1d0hJd2UrZUJHRGJJeGNrN2NGZ3ZoYkRORUZibXBST0EvZ3VNQUgyZ0pIWmp6RVc2QUErc2FaZ213NVhHQTFWcWxBK1JOQUVOc0tiVCtEZG9xZXJpdjZvY2VKUnlFa25IY0FBNHN1ZlpGemtUc0NBbE1lMXJ3bGg1QjBPUVFGTkovajVBMUs4YzJ0d3Z4SERVVHMxTkk1NEF4dVFQY01BQWdsN0VnWmtvU3dleG1DdkIyUlFHNWlCd1N1a2FJMENOdFNlbFVobU9DQjFUMWdCMEt3c2dMdWRpMTFaRlhjd2MyWGNOU3dGQUF5Z3dpZ1NDZHVZSWtEc2FZVzBEcUhTTzBBRE0rUXJoNmY2bDk2QUdZTGthQ1FLWU5TT3hOcnZUUVFkK3hIMkp0cmMyTnRKeDhpdkhIZCtobXJ4aGlOaWxSY2VnZWRHQVlTL1pPd1F2NitTM0RTa0JrRHc3WGh3aS9STVJBQ2dNTjNBSTNCN0RKRndEK3ZkcktsUUtMS0Nyc1ZLd1J5VXdXMEtCb0M2OERDNmpCaEJYbEdYakM0NHJIdFBTaU1sTWFTVmtyd0dKeWRSQlhoQ2MxZ3lJVGlSRzNEbWJYRlhqM000Ukp0Zy9lMERvNnRONGx1TFJxZGlud1QwUENhL1lzMVJlMEl0c0N4eklsQWhhQ3JSUXJJV1ZZOEFjY1FGeGl6QzRKQ0UySVUwK2hrclhiUkpzRDU3VWZuQVAxMG5SSVJJeUNPWHdFWU9BUFk3dE5BS25ZTlU3VUhKWGovS1FLdUlnVXhjdjVlWEZTVjRBQk5NVVV4WGdXZjlRcUJnS2lGQm50aGNwaFVVMFpqNk1hMFFGeWdaNFhsTnNJd1RDVG1SdklDV09OcXVTaHh1WFNuVU44RWFKNEFMMU50RjlLQWgzYnJIQURhOXBldDhXSVNyTTB6UTdMd0RyRGhPc1lBVjJBQnl3QWZVN0VhRWNPRVJ4bGJrRGhJTVIreENqaGZ3TTFPbzRvZGNnVEhBRW9EcFIzdFRnRVlHRDRLdTIybTBCVVBhL1J3QWJQRGNpc2dlZzJ4b0Jva1ZJTkN6Wm5qaDQ0STVpWnhyQUxqd0Fsc0FVMlhSa1daRXA4NXpIRk10eUJxZU1HclkzSkJBN0FFb0lLdXN3emFWMmM2Y1lBOGJpeWR6bmN4d2djOGVMRUFidXh3RHlzOU5Wam5TNmF6UkFjdE9PZURKdHFtZzRTSk14YXVXWi9ZOVRhNWhKOXArcDNiait2OWZBSTQ4QTlHL0h2alFDd29ZcGl3QzJKb0dnbHZyZTI3dkh4dll5NGFMMDhGdHdISGNZTFAvMUY3eXVuSTNNZkI0UytIL2RYTzhEVmlkOHMxM2xQUUMrLzkxSHlLbVAxZXpqSmZ1RG9ld09kRUd6d0xEYmd2OGZOdnRDTGhQblBtREFHczRJUzYrZ0E3MG1aN0FWbm9hZkNNWDU1TitBbUUyby9pMkdYOVNaQlI3UUREWWdCVm84dWNDRGF1VWZRcHBNL2NIZ0YvVUJQYUp0byszYS9PZDRjaGlmSXVXaVl6eEhIbzFyaWwwZjRDSGYwa0dYZm9pcVZmQ01QdnJZbTJnWnl2bU8rTWdaay9JNkZRMGF3MU9tUUR2bGtFUUkvb25NQnMvdmJCQkxBSTBEL3FaZ2xnQVZ3R09FQ2xXQk9EY0xjRUNuN3NpSWZxd0I4TXdPS0tjQldNZ01lTEFHOEVpUEFNZ0FBT1JOcVVISUJFWWpyaXB0U3dBQ0F0N2dBc2JUNXY0NEhUNEFGL0FQaUFaeFMvS0s1RDRRRW1ZS2dJRVRwVHBtZ0xqanFMcTM0T29WUXdHWFExQlNHVHFkcndDaEJ1Z3FabkNmU2NTMEJPNFJpb0EzYndDRG9MeHVnYTVOTG94eGptUnBnckRNQXFDZ0VFWnZZaUhFYmY3T0cvNGg2bGFJR21BeUUzNTM3eWpkVEhxZ0lFQndGaUhhWVdhSUUvZ29IYWhvRlRqdjc1cjZGVENvQUZxRUZKRkd5YnB3Ni9BK0ZMcnlFQkhjNEM3TktZNmxJWUF1Q3JCMkVTQVlpWWhiWVJBVWhvQUdZL3hTcTJFcURNaG9nUkRZaEVDK0kxR3lLSWpPSW9oRXlsRk5Ib2krSThUVmp3Q2FDUEtOSE5FQURNYlJQSUpSRndLNG9vNG9SNDFTd2NwZ1crcll5QUl3aFJ1UTEwckU2Z3ZXYlF3SVEyMVkzTUNvNUFuR3M0Rm1zaCtpVjBFaDlvZXhqQUJ4UmdYSTZ4YlE0NG1Pc3hncTh4QUtLa2FJSG0vUmZtaHdGWXR3QWdVdUpPaUFaT0VzelNLWW1NOUlUdWxnL1FKUXJ4aUtkMmdzL3cyQ09NelJxMnE2bEF3aFgyeE1ic0hZTXk2aU9TYVlxVVMwcUFxNmZRd3dSaHFKcGlLVWM2NVFCMG5BVmMzQVpnZmF3QWpRaGNoYytnUVE3aSt3czZOYW9XQkpaUVVCZ1FETTVoelI4OE1oUW00QWE4RkFuYUVwK2U4b0ZoV2g4b2RLRkFXMmJVcVlnMDRBN0FpUWFVaytnMGVBOXdxcUF1M2FHMmNtNUtaQWFwVUNCcFMwU3cwT3B4RXdyRTVBTm9DZ2VnWVlTZ1JBb09ESzdwbnArUWt5anBpRzdBanh5d1JoZzY0QXlLM3B6QW9CT2Fad1R5aUFXaXptbVJiKzdBOFplYXJBeVpJMjNlR0owczB5S1pCdTc0dFJWaXJwL3BGeU1hMGl1cU1JaUljVVN3Q1NHWmlaMlprVUxhM1JJWllaU3dFWlFJZ0kxWTVBeGhwZ2dnOXhqa2lBTzJVU1htRUVlMnRBOGtoMndVSjJvUWs1TllNNTNNSjJQZ1NnNE1oQUh1L3FRVWx1SU9SQU5PbmNjWnVhVFpLWmdrdEF6cVZZc09ldWRxSG9TT0V3a29RWU55YVdHV1k1aHBudU51ZWl5V1FnR09zd1RwaXVSQVA1NTUyb2ZjYTI5T0ZlQVV0QXN3N0FkeUtnRHltWitRc3c5eDd5VFJWT3BDMCs4YWpjekE1SXNVR284QUJtTlErS1JvZklnT0tBYnFZNHZPcXhxRm9wWDhuYWFaalpYeXpabUdvQW9RN0FlQU9wY1lZQUsrQWUwZWtpRko2bTJodEE1aHJGbGhxQVBhbk9SQUdPZDVlNXdBRXdCNXR3ZEZGeW1SRXdLMklGMGVZRlBvUWdMcGtLb29FSTNlRzJ0d2FJQ2lldXlBOGxyQW1JSUo5eG13U3dMSmdlYzY4b2pzelFOd09DblJvQUNNS3hIRXZxRUV5ZVNNcW9mSVlBcXVBdWJKbGNOd1A2OUpXV2UrYU1MQVkydkJucXpsd2hrcDNCZkY2cEhjNUE4K1MwQ0dzcEdwS1ZENTVobkFOMlJBRnd2NUVPMEFmcExnSHBGeWVBRndERTRvbGdXZ05scitXNDI4RmlJTVRWRG95NE9FVE9INlhJUWthcGNwSGM1RXZoT1J3TVRVeitaeHVPUWs0bTNJVzRjeEN4NGs0SmtKd2NJd3BRY1NvQUhKVGxLSTdVb0FqYVFHem9TQXN3SWxKUUgyd3BKQ2xBY0kxSjdBdEp3QWhjejZ1Y1d3RFFuaU5ackl4K0M4YXh4WTVZN2dvRlFzV2NHVmNRN3M3VjlJMDFQeDkwV0lEeFR4NUFzdVlSdFVmR2l1VGFhQUVoTkZXNGlBendRZzdaWHd6b3FHNkdyWXRWM0Y1czVFUW1VR2FBN3N1Q1dNVmMrZ25xb3A0NWdRekFVTkVPaituY0VoKzRiTXVwYUZyaDlCcG10NmxtWElTMTFKdmFqbHVRTlFueFN3M3hpeGJJbENFUWpROEE1aVAxZGdkZ0NhVGNXMEFOd3R5bG5jZXBJTmxnYlE3R1FKK3VHb2JJSlJqUjVKWWlwTnR3VlcxYXZRT3RncWpSUVFXMDI4WXUwOFIxUll0d2tXZXdqUm1STG9wdXhDOXRPS2Zaa1kvUkp0amVjSXhlOVY5STI4UVFHVXFOVHRkaCt0RUVwTm9kRFJkaFJBZEswVlBJd2RiSW50ZlJldEMrYTZQUlh0VXcvUk9HZjZTSS93Q2dPTkRWRmdzQUlkaE1zZEtna2RnUTBkRmR6b2pSOGRTSnVHSkFpYWZReGVNTjdxZjRqYWdxdFMzdytpZzZLNHlBUndlaXc2N1d5QWp0bTZLQXFkM3R2dFNkcGQ1ZDA5T2Q2ZFMwdGRpOXVkS1dRZ2t3RkdHR1dOT2Vkc1FWeElPQzh0WHhNMVN4b3RzQmt0alEwdDdtckJBdFF0NGtUMXE2dnk1dGRobHRjOVNNaDErSlF1b0JhOXp0OTE3OVpkWm92OUVkRzZ5aGpRNUdIbzZ3aVF1Rk5adHdFRDhBNndMYThTTHlVbTU2U0Q5MWJvdXRyOVhJZXFsdGJvd0RLZ2VGWU03c25BNmhib1BXYXRSZ215V3BTME90RjUvODlOWkE2aHo4YmhiTlkxZnNyb1dkYWRjZGdSMXNqeGxnV3dkQ1FnRkQraXU5QXN2Z2lhWUJWczFOcGdNTnRBMzZCRzhEaURrTjNNQ1NxRFpLU0RNanFzMGNPRUVoZ0p4a21qM01uMFBJaU5zNFcwNG04alNtdzFvaCtHQmp6VlJ0bEl2d2ZtNXhBV2x4S2pWWWVxQm1IRDNoekJxdXVpN0Fld1lqSWlCOXdBUlJkOXA5SXR5VSswWXRKQWw5MHRYUVI5NFRnTmZFT0pYRDN0RXhWczFkNlVxdFNPRE1JamJRY0dZeHFvZXRSQVd4bEFBMlNRanRRVEZTSVRZVFUxSjlnTm9Wa1FQNmNURGdjNlJOLzFEVGl0M0VxVFdEVFJtVEc2WFVPVDZ0QUdFTnFjTWpqSnR0MzZaVGdnQytpUUhkWTRNUmR3K2drWWNoVXc0OVlkUUVxQS9kR0c0cXltQTEraWRXdjZLOEVpcUZhbE9rQno4bzNRWEJlQXFKcFFDUmhoL1pGS05oWlJpQVFnSGhTRGMweitYalc0RTFwUXpCUVlkbWJDQllUUUpSYUt2TUNaWHkrc09nQmdrWmpnanRtT0RGNmsrR2hPdCtSNVVMTUwrZ2c2eUE0QWVRdndJY0tXZUVRMnJKbnE1c0pBYUlpQTJJcjBGTHhPZVk3QzdzT3FOTEdBZExCWTFETkRZaTZJbEwzOVpvTExIQUlCUExNZ0JZQWdiTXpJTENZVEppbHU0b2RpSTZFWVlRWUFVQXRBMks4QUJoQkFWQWxKd2hyd2lJUkEwQThBU2V2S2pnTWg0QVpzTENxMXVRS0E2MXBnRE1EZVpBakVwMVZyUGU5MUM1Mkt1SytLaEswMnhBMCswQXk0UzRMS013Yktlc1NlTkxBa1FnVnJScmRzVUFDNWdGMVlmU0F5UXlycnFvbFlSMWRzcGU4ck1BVlNOU2RTRFNWY0lsKzlIRXAwR28zWnNUL0p4ZWRScmtVVFRRcHJLQXVNSTBYVVpGQ3d5d0ljc0JJUXNCM0pxVVQxelI1QWowYlVielZjYk9xSy93bCtENGRTRUlhaTJTVjBXVGFBV3JiR1ljbDV0cVViZkd6QS95Mmw0SVIxcGd2SU4xd0FxUVJBa1FIbE5ndHdrNUxhaUFlcVpacFZBWkJtK1FEOFJnNVpyQTVvL1pwUXR3RGlqQWg3Q1NGNFd0MDhvUWZDeXd6aWh3YzJwZ2ZtOHdpNEE5SEF6N2dJQUE5QUFIckFDaEI0QUFDcStnZ0k5d1Q2SWwwSHFRZ0lFUVBBZ0lreHZpb0FVSGVBdFlVd3hoMm85YUg3OWJTd0FBSktCM3h1S0NKWXhLckZPK0RKM2xoV2FaTnYyaFhsVHViSis0NmNNSnh5SEJPeUpXc2U1Y0NHT1IyTUtDUUo3U1FJMXFrbk1ucUdzaE1Nc25DTEo4c2dmbkJUVVpPZHNCTzV4OSt6S0FVb0p6MmJwK3RwOVdtcEVhZ1YzYVNMT09TRjhEczBrZVdMVW9qUEFPOE9jZVFIWU8valNrYXQ4TG9OV0FBRHJrQ1BDVDFVallUTURJQXFqWUhVb3pCRUNFRk9kSUQ4THBGNjZGcEtEVkpKRjlLdTVBVElCb2lLZFRES2VKbVloZ0IwSFA0MERpbzlvazAxeHNkMVgvQ2FmY2VrZnFjVXgyYWdCQ2VCNFNNaWNjamllU2NrbWJHTEp5ZFRBS2Z0ZEtkeEc0SHJWcWQzanRQZ0NPemRJYW5sRHlrMUNNZnZBL1ZndVZ1MUxLM29qcGVaZGZMWmROQUlqNUJycmdCVTFwaGdBWjVxbjNVY1RMRUJPWjNtRkxYZGtVSlJQS3ltRDBZSjJOQVNwaDJZN2pjalQ4MjlxOUhlMy9IbURKejV0YmVmNEt6QWhVMXBTRmR2YzUySnFqd3czd0QybGlKWlhGZkFpMnhaQjFlcVdHZmZqSUVtZVpyVGhranpqYk1rRHFEV2VCZFVqbG5XQklpT2ZPZWZLdWNvakdvZWMwRGVlK2VzRCtkb0NCZkJjdWRoY1JjeTJrY3hmSkp4Y0pmSUJKZmtHcGRMZTlkY3VnQzVjbWI1ZjVKNUg5NnNaQUxDN3JwZ3VYUmR6b2lyWnJxbEN5cFUzbUgzZFNvTTVMUlRlQzUzZ0NCVTFxbjN5Tjdnd0VYREJlWE81cDVGMmNWb1hpOW80ZEE4VmlJR2QxT2t5NHpBUkFmc0NLbGpnbSsrV2o3ZURXOGJxY0R5T01DUEhUYmhhbzRiRU42Q3dENUZob1VIa0tDZ0hzMjY5VncwNW1CUjlTK3grZ0Z4NkNBTjdhOUltYzdJbTJBUjhOZTlBeUp1Y21yRmtEa0xNbkJSRWtCTE8zQzFoR3puRkpINGtwY3FBRWZzQ0ZyOUlwZVpJMjhiSDdsZEJ6ZlZ0TnZWaDdRdHVGemhYa3Vkc2tSMEJVcSt2eWlERGV1RHF6L0FqeW1mWkdCTXJXQThMcWtqUzNEbUczRHJWSHMxbURBY3A2S2I5eWtsQkVCT3RpY3V0aklKdnVzTVEwQ1dVTVQwSnFxc1lWN1ZrMDZGVmtEZUh2WXdqN25sT29Bc0ZjZ1RSYmdEZ0V3Q2xBY3NiTVlBRlhURDV2RUNTRzJZQU9Wa2ZBalpSMjBuTnJ1c2gxeFFWMWtLQXczR2dJNjdMY0xrb1FGOGhTVlFFQURxbVVVQ21Ecm1KSmp0MHVKaUVxaFJnREp4UWFCVmlaV0V0eWphaEJiZ21BanJyY0FrQWtDQklCU0t1UDZqNXlBOW1zQzVhY2dhaElBbllFZWU5Q1JoVEUzTGJsbXMzSVBnWGJIejRmQk1JalhaMW1jRWF4RmtCdytzTVRqTUQwREw5ZEJMaVcxSFFMS3BaTTE0cTZJd2ZvUGh4WHRUMlU1UHBHdVNrUmkwaVNoWlZydmlub0JMQnpCTTNUekcxRUZETElQUURNZWR1WVJPeEhVckJKZzJ3ZlFKRXArQ1pnUnNJZ0NOeDk2QlV1Y1MxQklBaTN0NHhJSWd6SE5ITEFGZjRVMXVBTGtUVmt4VENIdEpUQmVnTWdUa0puYkg1VG9YYkk3azRuU3pCOHlhMTNWZ2dTR0FCSXNqQU5BQ1lJUkJ1UkI4YzZEclhkb3JEaENDRFA0Z1E4UWFVSDBBQ1F1aDlRN3FLN3phcENOTG9HV0NJQ1FFbUpFQWxnNEFIZ0NRQkVBK2x3QWt4RWdOZ0NJQlRwL0VPd29nRHRnaUNwQkRoaFVTWW1zTjJIQTRSQUFBS2grejBCd0F2aVc0VDlsbURnQk1BTncvNkhZbkFDM0NFS3pTTFlUd0d3QWZEU21HQUVZUHlEc1QzQWJzZUFIZ0NORkJGMkpaZ0FBRFR3QVJCUU9JMElGTTBtYVFyQitRc3dmV0hnRndCRUFnVS9JZjFQY0ZyRE5KSVJ2aVhZUVNLSkZBb0xnZGlmMUhZaWhINGpDUnhJMGtmNm41RDZ4N2dTSXhrVVNKSkUzWi9VQUFDUXhFQUFSUEFINGxSR0VqK1F6U2ZXSUtJdUE0aU80bEl3a1NNQ0JRMVlWZ0Z3UHpDcGl4NzlZMFJHSS8xQ1NKV0FyQThBbUFmS3ZDT0dTekFic3dvbWdCRUYyRzFoVFJnb2xVUUFIVThBTkFIZ0VRQ3pUc2pCUmlJdW9DTkZkSDNCQlJOV0VVWWFJbEVFanNSZUFYeEZ1eE5FM1krUkZ3ZTRGbWo1RkFvUXh2aUlnTktLMFN6QVlPS3dJRlA2aFZHUWlpZ1JBY0VUZG51QjJJWU90SXpNYmlKekVRai9VQUFMWFJIMGp5Uk9ZaEVSV0tyRklqRmhSQUFBR29ZaVJnMW9sVVk2TXRGRUFZTzhJLzFNMGhORzFoN2dTb3gwZjRpSUNWam1rdEl1eE0wbWxIeFpZQUZtRllLeUtCUzhpUmc5d2NzYXFOOFFkeEZ4L0laY1hTT3hGWm9JUmZtT3dEd0VZRDBCa0FjUVpBTWVOUEhuaUxNN1kvV0JpTVhGMmpJeEZ3ZlViY0czaHRVTE1XaVVrWEdOdUFSQUlnMTRtV3QwSklCMkFvS3pnYkhrUUg1QXZCeUE2d0J4Q29BV1JnU2xBV2lJd01RRzg3SUEwSm14Vy9QZ1dRQXdkN2dSQWZXQW9oUEFYOFBCRUxIc1JNQmhaeDk2K0s0T1VNbUZRbm9TZEVpd1RZa2JDTENDakRnNUlFWUV4S0lCOGpmMHJ1QXdJL0dRQTNZU0FaS0lnTFJMUW5zQW1KSUUxVUQwQkJLTkFTcTQ0RUVSY0I1SENpclV1WW1EdFNMd0NUSVZKMUk3QUhnRzlLYVNMZ2xvdkFPQ0ZMRTNaVkpGd1NZa3duV0NjVG1rTUhIRVQ5Z0ZFMlNSQWVBR1NvS05tQitqL29kb2k0QmNBQURTZUFCQ3RPSnV4QW8rUmVBT3hFUUJxd1hCZ3gwSmZ5WUZMaEhESThBMk9BQUZKR3c4Y1dpRWdCTUR4d09KTGt0d1dZS1dIU25MQThjOFVuUVBsSWpCNDVaZ0NnVHJMY0F2QlB0UUN6U1ZSS0FSdXpNQjV4b0JRVVNvbHVBOFFnVStZaTRPMk5tQXFpUmdjVXVvRGNPaEtBam9Ta3hBYWUwVkduUWtlQU53a0tiY0pDa2pTUXB2aUthVG1LSUNXaWdSL1UvNk84UCtpQWovb0kwLzZBdFArai9RSWdDMG43Sk5KK3dqU2Zzb2dNNFVjTDJISkJEaDNwUTZlc09XRThReU9YVW5xWEZKb0J4QmRoRm9vZ0RRQVRFL1RQcG4wcmRoM0FUSFlBZUl0WVBwR3dIckNNb1dZZUFFWUQ2WFN6K29kQUg1YUFMK1BZRGNDclV0d2JBS2pOeEZOamZ4Y1FMR1FzSTJHM0JmRWVNN2diNGdlbTNCekpXTTdZWVRJaUJLQnVCa3lDbVhUS1JHbkRDWjJBSm1kNlYvRnN6dUJSa2ltWEVDWm1XVGZ4Zkk3Z1Q5aUpsQ3lReGR3MEFwTVRGbG5UUUNJZ01XVEpWL0crSXhaSWdMRG9jTi9HQ2p1Qi8wWDhYYU80RUlWZnhkaWJnU0ZOL0UxWnVCelNJUVBjRUpGQW90RS9xTzBkaU1oRzNBN1JmdVd3TlVrQlJkcCtRZEJFZEVpQ1dCQ2hha285QnJMWnhVUTlBeTBzTE1Ub3NHeGJBQnFDbWdXZ2ppaG1EdkIxcWxCSGFtd0ZvS0dWa2twUUNzSDdrUUREMGFrM3NoUUJzMXNCNndnSXpzMk1OcUQwQVNjZ3VKQUpMb1lHc0RTVExvTjJjQUtCd1NISUJBUU9ITkVHUjFtQjJCeXgvcVB5SEVEc0QrSjI1bmNzanA1eG9DWWdiaG9BTkVKNTM3ZzNEUWdubkVBRFFDbm1nQlBPb0FVRHVDQ3haRUI3ZzljKzdHM0k3bGR5TVF2Yy91ZjZrSG5EelI1NDh5ZWRQTFJEM1p3T3R3Y0RwNXpSRFh6TVFtSVF1S0VBWG1ZaGw1cTh4UkJ2TTg2dkF4K3dBVHprY0ZIbkx6dlNRS0RBRnRpcmdyQk1jTjJDeVAwbFFDUEFpSUZpUnBPQUFnV3RaWE0wVkxvT1MxYUo4WlJRYzJVb09TeUdJWUtzV1lBVHRPUzJtSjRLc0Z2SVI0bm9qdUNnRU04amtNYkFrTTE0Y3NTRm9sV1pzWkVkZ3FEQlI5Q2lDRk9RM1p2NGg0SzVXNE1qTkFDQUpRUVVDbUJRd0Q0VUNCZmdQZk40cldENXc1OEw4cGJNVktVSHVDUUxuQW9paDRUOVJVd2JwY1l5aXBCWkxDdnpoVk9JNkNnRkZncW1TY1JjRnhpZ2hSMkRpQXRwNE9nSWFhSHlFZUFpVlI0UVFiQUNlbVFuU1lMMDdBWWVocjE3eVB3OE12V2JnWDRwSUE3OGtBZ1MvcE1Fb0l4NEIxR2pnSlFncUZ1Q3VsSlVaTmZTcjhBU1ZmQXRXRnVRMmhuZ1pTSkxQNEZtWkFDa3V5VnBMcDh2d015cUMzTWdXQXd5ZWNEaUJVUy9pTjFFZ1J3QTBETUhjbzBVVkJXaVI3a095aFN3cHRCSDRQanZBdG9CYVZBVUJDMTZPdTNxUnM0YVlZaWg4QUlzQVREOFJGdkNoOEJJczV4VndZT3NpekVtTFM4VjZJSllYUUlKUndPNEc0d0NxSXdCU2FTTUZIZ043VTZ3R1NlRXR1Qk15OWxOQVBTU2NzZ2JuSzhNWXM2NWZaUDFoM0tFR0R5NEpSck0xamdBQ3FMa21yRzhyT1hiS2RaM3lncWg1TzhrQXFQbEQ3WFpUOHB1WGZpK1JFSzdaU2JKQlUwQXdwMkkxS21JbnNVa0JIRjJ3RzRTbFNyakRKMmxkd0pVQ3FEVkRkTEJ3Rk1WZEVDZ2VnVHNxVnFBUjZJb2hVWFFLaDRjQ29vZ3l0MFZ1eFhvbjBXbFF2R1dWb0xoaWFJSVlxVUc1VU1kTUswM0ZRUUFFY2hCRkpRdUxjRHNDM0JDNDFZVU1pOEJFcTNBZ2djcWpQSkZVSzRDNStRS3lxdHNBb2NxSDB6V3psV3B0cWhxS2NSS1d3Q3ZsSlMwMm9VUlh3T3liL0RTMGx6TkZLV2t1Sm9PYXVKd1VRdVFFdVNsdHRHK0RNS29lS2cvV09VTkZYbmpFNDMrQ3hCVzE1cVJvbXE1UVl0czAwUUNXMVc4YzZHb0E0bjJET0pYRXhJVDFEeVNYbllkVjBDdlB5SjJ3dndUc08wK2FwNmlFRVBpdWdyNDVRZUFKRUhSV2VVK1N5bEo2aG9WQVRGd1ZCZkk3WXZtUitvRDlqVjZKSjZyNnBnYm9oTzIvYWlvaTVVTGpnQUFBWGhMaUhVVVFSMU53d2RSNnAyaWhVNjFoQ0ZRWk9zRmh6YzdLUEVYR0E5RzZRL1VMdU5pV2RCdW5LQ0JDQ1VmbEdvTVRGSGpzWTVPL2dwS1hGQWJoRnh2aFA2Zk9zaUE2WExzVzA5NnNkUXRMTkFqOW02TDZvbGNvQkpYdnJVb1k2MUlFK3YvUVBnVTVxaU85WENCcWdGdHhsOUFGY3FQQldwUnJha05SVnlzZDFIaWlsQWhibGZRTUJYOVVRUWUyQXVNanJxbzloeHFPNDRjUitnTUZoNFZGSUFpQUNvcXJCcUVoeHlpaGF4d0ZYQ3pTRDVqSUhFTWNJS0lkUVo0OVlRS0xGbHNDa1dJbzdSc2lrTmRoUndZMWtrcXhGRDJOam1PaDQ0Q29lT1Z2bmRHQ1dnRk84M0dZbkg5QlhJY3Fsb3BzUDNyRXA1Q1c1VUFtZ1MzRzNqWkNXNDNncG14Zk1DQ1dEOUtTR0tzV3pROUFxTEh4R2c2eWpYdjBFTTMrcFVBY1FTM01DSDBEbUpQTjNteTNJWEFiZy9ONlFPZ0FKajBCRXFURTNzekZQQU9mMEMwK2JtcytnWnpnQUZJRzRxS0lKZWVOWXFRQkhxV0lNTFVEUVhoMElFVjRTNUFGRUhZQjhrZlFGUkFyUlVUMUpOQWxHSHk1QUw0a3pqREJhdDd2QnJWbHNtSXRiQ3RZNi9VanlEMmhiUkxjWUlYellDR3dDWkNOaU5XSEljTW9zMnZBZHlKZ1Rjc051YXowUldOQXVjc1NSckJycUNyK21nN0FjV1hTNWZkSXdWc05MdDF3eTRDOXNRaWFjcnV3QjQ1M2hnUUhFWE1rWHc4MVpOMk13N0xwYTF6dkJ0Um14WnNRbXJPM2FUenNCbEVJSk5obmh6aWpMTjIyN0JvSTBIM1laRXcxcFpFb1JjbkRVMkMzU2RnbTluMlVIVFJVSDI2V085Qyswc0Izb05PcEhMVG5Oa0pJUGdBT0lFWURvbkdCQVFkY09jSEJEa2gxdzZvZDBPbUhiRHJoM3c2RWNKT1RGVGpoUnlvN09CM0tFN0Q3Y29QVTZ3OGJJT3VZbGFxQjIwYUpRcVpnSC9vUUM0QXliOGcwQ1hTa05rTklzVWhoWlFpdklnQUMyaFZRZzBBVzBqeWsyUmE2TzRnbFRsdHlVcUpDQnlVWTVPUmtJRTBCV2g1bTJtZE5NZ0dyNjE4ek9nRVN6dGp3d3owOFF1NXlJbmtZQko2aGNDNkNPc3ZsVHg4NEY5RUFkUEd6b3oxSjdNOWllVVhaWU96ejBDYzluQTNQZUFNbHdvSkhiMWsrQTB5amwxWnFpOUFCS0FOZkp3QTFKZHdMQkN1NVhaUG1hTDg4dUNxM0VOa1hzdWlmcGhLUXkyaHVaRFZMMmhqZFpRd1dQbnVlN01oemRSZXNGdXdIMjNsWWVrYVVaT0w5dzNCQTlzNlFxZjRQdW5CNGIwcTRQT2lSbm13TzFjaFlldVdzWGFXMkxhUnJEVmVxbXRrZ1JPQThkcnU1QVp0dVFGYlowYkMxODZ6dEc4MHVqd2podThpQXJIam5rMmdGRk5vQlpUWGhqVTNMSldwUkFlS1hMdXpiMGRFMEVmSDBHVENFaHZBZWtid0lTTVp2QUFFcUdZeG0yRWluUXVMVjYrMGprYWhHeUZCU1FnTHlYNmNFSWdlMUFKSm1BZXdLWUNvRWFrOGhoNmxJUHFEUUR3TXFZZnN6c0ZabE1HWFNNQTNVUFJTTUJRWmZoWndkb1hWUEJQQUM4MFhrUm9UVVczTGpHa1FEb09EZisxNEE4S1lPQm8rRGZsV1lqUXN0V3pFY3M0aG16ZjB0T3pzR1VRQld2akRsbHMwS0g3MkdCckEvT0ltajBnRUQvR01PRk1qVzN3alFXbm1Ea3RhQUlYcmRya2JKUGJrSmtQV1BWWlVnd2N3Z3ZFbTFpcFVsT2JBaUxCZ3R3RktqQWlTb3VuRUptSlZhRkF4T1MzSm9ISUE3bFJObHZEb1pTR2Zob2cvREVCeUkvNGE4MG1ibXM0aHhJS2tQYkIwQitCd1BVZmM0azN3ZGhwUWpBSllKODAwTW9IdERmTks1SG9ZTU5Db09TYklDVUkwQVJBMUJVd3UzUktvZXN1Z0tBek5rUnpobllmQUFPSDRsaFM1dy9TRUFOdUdzbEhodEpWNFo5UXBnWWptNVl6WE5xbXFhQWtqRDNRV0d5RnRqYzUwajBBRk9vVnhRM0RSR2dld1NyVHBFWFVqODlncmJFUStsazhqMEh2Z2FJUFlOM1B2bVpZQkFMZzVBV1NwNUJhR1BHRDFTYUFtRDVBZEc3Z1hSd1l6MFk0U3VIL1VEKzRKYVVCR05TaG5qMVlBSTBFWVNPL05DalZZSVNMOGZHUHhINWFtZ0NBOEJnNFBtdzRrVXhxREdqdldyR2JmWlFvZjJjRncwRVNjNFVTaHpLTTRCbEQrcEhJS0llS083QUdMSEhaNGRrTEVJMENVUG9BVkFkZ0ZRS2x2RU5DUktNaklmT01EQVpPbEFsRGlVVlE5Z2Y3V2hVbXFmSnhkUUtkZ0JDbkdBYmxORUF5YUVnRXBsd05TbmtNZEVWTmJnQ29LcCtrTDhmVk8raGxrRlJmaU11dHNEcW8vaWxsUHpCeVlkUVdaQktwekxvQVJuRlA1SDRERUo3VU5vM0MyTUJPVC9xY1UyYkQ4dzVHOGpHaHUwNmdiQ0E4aFRUK2lINHdTanY1L3NrQkxaVzQrQ2Q5T09tMlFBWmtnRDhZUzdhYzdZZUFIUGtrR2dER21xa3pwaDFLNmN3UFlIelR5cFp2Ukl4VkpTRytNWDIvU0h3ZGMzZUxYWTFKbGc5cURNQlphbUVBN1hMZFNhT1BiSHZnVFRWb2lPcWNIdXh3NFc0SWc4Y0h2aDJCY0RoRVk0SVhIRU5KNFNJZGdhZUt5YW1NTXR3QVFhcGcwL3lmb0JicVRZdXJzN0VwSUNGd0dUMGFFZ0ZzZTFNWmNqTlNXMGMxTWZrUHFiYXRKUUExYUUxeUM1NlJvUHlSb0h2Q1lPaFU3enJiWlk3MVNZeGJRWjF6QU0vTDBBVURINCtNZ216RU9ZZ2JnTmFlUThwaG1DQ2N0eU41ZnpvRjRZZ2llT2libEFqRUZuOHd6R09nd1doSUJVZUM2Q2Nnc1VKamdxRndFeXBvd3VJWGZ6dngzQzF1SFUwRVhCQlNGbWdPcHBndFhIVGF5SnkyRnRCam5rSDBzN0FVNnJJZHhMR1FMQmwwRjBIaGI1QVZFek5OQVVDK1JlQUJlaHZDU3BsbUU0bkF1Q0RSTENKOUMxSlpFdStBb1RRSjRTekphRWhrWDVMSTBOWXZxWjVSQ0EwekpBSllDYWN6T0JuUFRlWjBsQ2J2cTZvTDU5Z0lCazZXYW1vMEw3SVBaMXM3UEU3WlRKRXRWbTR2cll0aVk3SWp6LzFlRXlhdXoxd0w0QUxpOFdzK2NlcndqbEt4T0NMUWFER0toTnhOZ2dOeXdvSWNEVG5mTDltaDgrZlFTdmVuaDEvY2FyWThmK3IyV0VyUlc3cEV3YncyMFhTV0hKR29EOVNDdllBUXJZL1Q2cTF2Q3VyWnpqMDhGYk1YRXFLL3IwU29zTWc3UWVRM0VnS3I0dFlLL0FGQ3RWYUdyOTgycmJ4YjVXRXM5TEJsak15NmFKUGxnNlpBMmZNNWFiTUJGbnJMZG14Smk0ZUlodWFxelRsbXMxc3RLME5uaSthVjh0bDJjYlBGWGpyTmlYeUoyYzR0aTBaMlE1L0EwY0FIUDNYaURQbG5XaGJvdlFud3B6NGgyYy9PZXBPTG4vZy9tOTh6c1pPczNXTHo2NXpjOUlhdVFqZGJ6OTVsY3lQMllEUG1talFOazQ1K2RYU1VXUTVBRjEwS0FBYTBsZzNLUmRVcTVFeHNUTDhHTHBCbWd5eGRBRGNYUFl5bCtTOFZ1YnByeGxZcE41aTVRWU13OFduaktta2RaU2FwdjRXRHpwbXZvQ29BWDFzRlhyQ2g0eG16YjVBMEFvclVXa1N3aWVoTTgzRXJKQVpLMjlmQmpqWGF0ZXdiU3drRjB2cG1LSWdoK2dLWmZreU85Y2c2QUliTnRlbFNSbitNMnltMDFhQ091aXdvRHRsWkd6U2NlalZrZUFWM2RYWk1RdnloVjVETUJyNEdJVUUyN3dDc1JBWTZHVm1PQkVCZmp5WjUvVXJldHV1TjBBamFIMjZCYndESFE4QUJVS0pVQ2REdmNZQkFEV3BWaXEyZGhRSHZiZzZKT3lwcEJLTTU2UW50cWN1UXBWVitZTThmYWVhbHhSenpoWXZXN3RtRUlxdEx1VUtVbGxkOG5NSERvVldtS1N5cUZLcHpsUEtKQVppNFNDdGdMaThucmIyTW9uWnJpTHBrN0hhZTloMjB2WEJUTzFsZGNkRlhmaE5zQnUyNHhscnJkTjdjWkNlMmRMSjc1S3BhQUFFVlB0UjlTTnVJSVhaTHRBVUFPa1pWVXEzWTd0d2RCN0tIZkR1dllIOWJ0VDl4SFlNR1IzWGNPd2o3REhTOGxmYlk2Mm9tblRRRCt6MFdFN0oweE8xR2FUckE2UWRvT2xPeERpdUJwMW9jTU9XSEhEdEJ5WjNxQVdkSkhmaE96djBTYzdLQUU3SSs3enNHNzg2ckVndWdEY0x0dU5pN0o4WGpLWGQyWmpWeTcyV0c0WlkxYUFvQkY3dTJhdXZhQnJxMTBKQWRkcW1lVXZyb3BhRzZrZzVsN0dranhPQUFEVmNsdW5NTmJ1TTdSRlRPQUVDemxqeHg2dTY0aUh1cHpreng5MFU4ODQvdW1ua0h0VkN1N1E5M3U4TGhIclo2UWFPQWRCTG5qenhTN0o2OEJwMjlQWGwzRlJLRXJrZWUxODRYb002NEliSFBYTXZUMmxZZjYydElqTmRpbjBQblNLc2hNamUwZ00zck1DdDd0a0VqaTNRWnk3MHoyKzl4a0FmWUQwV01qNnY5K05DSGlsaXJpRU9aOUtjUXRvdnIyZ0hkZGloVHNHNWlRMzAvaHQ5YnF2ZlFmdmJiSDd1MldldEFPZ0FNNGY2dWczKzBtSGVDRWpMZ1hJazFLQ1BLRnMxQ1FSZ2RvdUVjTjJSSE9qZkVvSE1aeE0rV2tUT3BjVzRSVWRLT2JIK29MZ3d5RVlPQUFXR1JBMkRjem9GQXM0ckZyUGdKR3d3elg5QzgyTEFWQTZ3UVpmaHNDQ0dtcHJmbVpuRVJHT2ZrNHpuSTdSYTJaY3IwRzI4SUM1QTdPSU8wMCtoU2d1TUVleDg4c0NESVJrTi9DWkYyUTZBRGxhUWhobTRNK2hNT1M3SUJPd0JvK0ZRRXJLa0t6R3k0T0w0b3VVdzdXQVlTdkRNQnlpVVhLT0F4bW5GOEVyRW43RmdsK0x2RExjNFlEM1BUblZhQ2w4RXE4M3NBM2d4TGpKU3kvOVR6ajZYRnVlenJOdjBBc3ZFNXE0VGx4NGZCa0N2emJtZ1RRUHk1WmVZREFsN2k4OUEwOWpWTTV1WGdhTW1vOVI5Vi9id1F1M0txRFZvdFd6NTFlVVdTZktrY1Q1TEdHWXZRV3pOcTNUTlc1WGdQTDNXeUkra0VKTk1TWUM3d3VVQmtYeWgyRjNoTFRQU0RBZ0cwcnVvUWJJYTBJTGp1VW5EOTJlZURzSGdSVEJVejVyamdNeStlZDYyTExlbGQ0N29EU1hFQlZWNnF3TjFwYk5mNldibnZMNk56YS9FYWQyb2VwMFhzTldYbENTYmdUZ2h5M0FaajZDbHZGdHZzY3hGVytYQ1c0aW5DMit0d2tjTGl1TEc5R3RqTnhia2FrV25ZM3VRMDRBVytaQTJRcllFck10LzZncmUwQWh0emJnV3hPLzlTTGFEdU03eGJWeUZiZjNrTzMwMTREdG00TE9DR2lBY1I4MkR1OExzNjFuQXZRWWdIRWUzZHZBWk5Nc2VrRjA3NHp0ODBRZ2hydGt0RENEa3NzUXpJQWdCZS9tTlBCcjM5ME85OE56cFdrQk55bG01cklJZXdYaHZPM2hMelFOYTRMTmtBZ1BXaXJhRmU0NEJmdTNnOTdxSHBQR0V0M2dDQXI5cmNIQjV2ZmZ2cVYvNzJiWUI4QU5nVzRqTzVBbGQvM0l2Z0JSTkR0SUV5a3JDT2F0OEhtcFZkMzVsSmY4TUlQbHAwaE5CN3V1WWVQMzhIMjk0aDVQMkh4VVA2NUpORHlDdzhJZlhnQzhYRHpOcDNKYnZCZ1JtMkU2QWZ1YmtmUk5hN1dqNlMzdVlnZnByNUFjZGF4OTdkRDV2dXlEVkFLa252akFnbUVBQXhqNHFCK0FidWlCK2J1ZlFaOVNRYWZuRzRIcXo3cDVYcnNBZEVsYUpISGVGVmloMnNLM3I4bExTUWMrM0J1WE9uN2lncWc0K1lsRE5rYnpWbHU2QytXdk1pamwxTUFQaTgrMGtRc1VuLzFLckdjM0VCNVhNWUFmS1lGQ0FwZlMzQUgrK001bytzVWtwcUhRSXVFTVB1SnllRzNnWHZMR2xPYytoZW9QWjdtRDVGNlpmUmUrajlYK0wxdEQ3TGJCOHY4QVNFVE82SysyUk1RRWdWeXlWRnk5TVVDdmVIeTNNVjZ4RGpuOTMxN3oxTTUxSVF6dUpqS2FRTC9GMFNJaGZiWHA3bC9CdGZieFJmZ0FNWHJiNnVIdVk5ZWt2VTNnYjZsOUhjWmY1dldYaTd5SEg2K1FqQ3YrSHViNk45SzhjdHl2bnFHNFZWN1cveEg2RTZiNmE0aG03ZExXTExlM29ibTE3ZURIZStqSVA3cjNsRXUvUGVidnczekwrTjV5OVBmcHZhWDk3d3Q3Sy8vVUt2b0hQN3pDZHEvbWV6Z25XSHQ2Ri9DLzVrb2ZIWDF3NlQ4eUlkTkV2ZlhsTDBON2U4amVKQThOUEg4QURzRExicXZ4SGpiK1o4bUNvekd2ZTlDdkttdHFFVEE3ZWdQNjUwRitsQkMveWZJdnZ0Mkw1dVN5K0NrNW5wbCtDQzlvN2ZjM0dGTEN2SXFrM0FMNzJzWjIwKzZGNURneUpPZEFWM0N1QkZpOVAzUTRSamdRam4wQVlZUUpMTVRYOXEyNWhqZUtJZXJLWCttZlY5ZTBwSnd2M042aWprVWFnSmR1TVFNSWI2TXZCTE1yWXRnSm5LRmVBVysycVhqRWR3QjVvY2pmSlExdnlvNHFxcXgzQjJBRHZwMzc3OHVKdS9mTU5wSGFKckRud0MrcGdqa0xYMWdnMVJBSm9QYzNiTCtacU84eGZad2prTzRLbTlBSlVMQTM5RVBIQU1ZVGMwY3FGa2k3WkVyNWNUTUJvWE53eEVEdTFkUmNoUU8wK0x1Q05GbFFqUjFqbXhpOUhzZHF1WFFtaVN2dk1GejRpQlRUSEVSNFk0Q0pabHJ0RWw1d0FCYVVyNVlCSEFkMDJIUjdBamJZSjdreDE2SVlDZEV4SGtxQjlUeTBEZ0kzbEE2eGxQNC8zNG4wRDc4eCtrRkVHcjhhbU5xQ1Y4Z0F0c0VDOGRvY2dCQUR5QkphSEFEM09WWHdBQ2d2RndGZ0NmQUxkeDNjTjBlVURpTUVrY0lrRzFtL1BveStBcHdRTnlUZE5xUVNBUzlwK0NVMWo4TEFWNERrMEpMZU4wU1ZUQUVlRmc4UDNhZ0lrNXNjUlRWVGRRQUhpSDVvdVBLZ0xOOWFBcWozenN1QW5pQUQ1dnZjaEczZHdEVHRFSzFIdk9qVmFJbUtPalN4Qm5PWnpTVjk1b1lBRlVDbklUMUFxSmxBckVCekY5L1FYeTBDbEEyZUhrRFNnY0FJbDhoY2JRT01Ec1FCRTFjWWQwWGZDZ0RZQU1uekI5RWVPYm5RQnBoRmNFSnNySVBDQXFkS3VEcDBINWQ5U2tuMzB4K0NmbE1Kd0hOM2tmb0VZVTlWWDFMemFOVmwwZnFYa21ING9tS3FBUDB4MWNsbm5nVDlVRGtTQ2JFT3J4UkE4NE5BT1BjV3ZKM2liOTJ2R0gxY01tWER6akFBYVFXUkJaOXkzQjZtYUlzUUdUUVo4bHZIUGw4QkZTTWExQ0FtRVF4UWZsa3FRTHdtQUd2ZVgwRDk2SVNuenlCOEFrb0ppOCtnOXYyNk4wbEx2eW1DZS9NZ05HRThZTnYweUJHSWFKeTNCbkFLa0d5Rmxnc2VTeEJjVkdORG5nZ0REb0Z3MHNRRUxRWWdaVkNJRER3aWZGTkFPQ0xBb3dOT0NpWkM0SnE4VTBJM1dRQytnNnZBR0NhL0pwQWg5Qm1VWU9oOXhnaVlDdjhHQXRKVElCZS9idjBIOUJJUnYxNUFsZ2hWRVlnYWxYZ0tnaFVBRFlKUlFZUW5ZTEJwRnZUL3dXbDRBQW55QVEvL2ZueGVDeC9iakFEOWdtS1JEaVJBdkZRQlVBczNkNFBsUm12ZmJ3aThtY0FnTmNNeVF3Mmc3OWZnSWZ3b0QyQUtFUEN3MGZCS0NSaFgrYlpBbHdsQXhRT3hBRzVkNlJXa2pnN0VBNThEM1lBRFh4NklIRU85OU8zUE9CV1o4ZzBYMzM4RlF1QVZKQytrWTJIeUN3dlFvUEUwOWZXc2pCMER2WW9OK0MrakhhbU5oSmdqNDNTVjVnaVVLVzhSdlFjM3NnWlF5NExsRHByTlFHWUF0UTZrTWg4NlFzWUpOQ2xBQnZFQkQrT01FUE84cFFEVU41Z2ZBWktnV0RaaUNyeG8wTEVRK0djMXlFR1ZVNnhaUTFZTTU5QlF5V2c2QzhBT3dFRkNLQUdWUUpERXdzUUtnaGxBYitpYVF6ZzM0QnFWNWVOWUlMQzE4SXNQdUR0Z3BEMDRWdnZUMFFuOTM0ZmRBYmtBRWZkRlc5SFEwa09ZQW5BbDV6WTk2L0ZEU2FER1hZMElaQ2ZRODBQNzlMUTFrTHhnQ3d0ekJyQ3BrTnZVcXRtMlFhekg1OUFSLzJVb0ovUWF6QjAwUWpvR2M1Wi9kc01lQ25RajAxWUJMa1NrTVNGelBXWHlWREZmRlVMdWdrQTZYd1J3N29PWDJjRGR2WVlJSEQ2USsvVU9CMitlSHhvMG4zVEVGU1FXaUFDejVWclF6LzI0SmVmZGIzM0NIYU44TkRCWGNJOElmREEvSjhKK0NhZlY4THZDR3BZWFVERFB3bkszUkJXaVMybi9ETndzbWdkQzl3MGtQQWpST0tDSjdEd2ZXQ09wOVNnaENQYjVDSWo4S3hBUWdOQ04vRGEzWDhJQWlLdlhjTDU5UUl6S0FXdGp3OUFNS0NkaU9DUElpSGFaUUhwOTVhRG9FMHRnSWdIemFEbjNQS0RYVVIxSVd5MDlxbGVRSVk5a0F6NEc5bE5BSDBKWEE5Z2M4S0h4dU5CMUVJQml6SDNEMWhWSldzQjQwa2NVQ0tVamRRSTRCSUFTQVJCa0pEUUF0S2kwalBQWFNMNDFMQUF5SjQxcHNRUlF5RnpQRFlMZEN2Z2dmbDRpWXZSRUw5RHh3OGdNV0NrdmNOQnFWeWdPY1A2c0wwUmNOQUJsdzhBRE1DN2VaU2d6Q2duQ01LRnhNZ2xpSkFqQXZWNENOQXZJakFQQU5XdlQwS0hEUUNMS0taQ3BncE54bUNMUTRFUG1EdWtIQUplUUxNQ0VLdmMyQXdRUGsxQTNSaUI0Q1dBL2dMajhPQWduQmFqdUFxNUNEQ2pZRU1NL2hrcVlzSm5DeXdtTUZ2d1dHVTBKREMxOFlhT3JDc2dHcFZsUVVvaHNKWVpldk9oQ1I5MkFTQUdZQTRRRGFJUGdXS2MvbjMwS1pKckhBTi9iSVNJdGhpZ0Nmd1I5Z0FmZENSOW1BU0FGWXNZUVc2SVBobUFlTFYrY1pWRVFDT2o0VFlPeTJoYkF6NG42QmtxU1FNK2pYNEdWV3dCTWlDUXl6aDlBVFlJUm8yL09QaUJqYmdIZ0V5SjdDQTZOU0JNaWNySElnSVlsaGxzQ3ZRV0dNd0FFWXJNTnVCL0VUSWpCTk5EUzEwcHd5c1BHTHFBU3d1a3pTZ1d6TmtCK2o2dzg2UGlqS2NiUUttQVIxQnVRazEwdktJQ3VDRG92OFEranNGY21OOFJRWXNyR2VEcGZiSGtzOU9JeklGSWlDbytDS05vMi9BS01xaUp3OFowUkJpNGNNUEVEMG9zU0lYd3hyQ2J3c0Q1QTZNMGhDUW84TEdjMUVBT2RRcUpDNEMyQ1NpNTFFcUVuVmNOZVNMR0Z6UFBNQTBqNEEvZjIzOWRlY3owMEFpWUt0R3NpdzBkMFA4dFNOS1dMNGkzWXlNRUdVNVlnTUtLc3dvdFp5cWdRZ1l1R1NDbHczb0ZWMHBTS2xseDlKUStVbHdqV0lwaU1SSTFZLy8ybDhjVWVnRDdJWUF6Mk1KVkxvdFB4NnNZZ3E2SERpZHpZdGgvUlcyZjRCUk4wZkovMnNDaFlNYXhTWWxHZC96TTlrQTBmMnhkODR3V0JIOE0xYThQVE5qb2FqaHlpV3ZIeUxJaVl2ZnVNNTFnNGxrS0NqSWdGRVZuQ0k0aTlHWEN4K2RFSG5oYU5jOW5qamtvNzd5QWpaUXdMekhqVUFDWUNRQjd3NGlLYTl2SS9zTjhpK2pIZUwzaW9ZVWNNWUNRNC9JR25pNGc3WkhuQ29vL1kyVW9WNHcvaXhKbUFtWEd3aVZ2Rk9JeWp6UFBZQ3I5TzQ3VUpwQzlWRWVMUGpaWTVrS3FqOGdidUxIOWlRRWdGQTVzT0taQ1Y5RGdZVUhVRDkvZGdIRlZxSUFjaVRDMlFVN3hZWWpnS0VPNElSbzlvaEFJOHd0a0h3VDlZdkdJRmkwNVNjSW1BcFFrWEFPakppVDF6ckQ2UWNoS3VpNjRBNlBlalFJMGVpSWlZM1VSMDBpVGdJeU50Z0hJbWdIMGlnVVdzRDVFaFFTK05BaWVnSnozRmp3MFB0MnFDWnZNZHpxQzAvZTBBdFFzcVpBUFdBVkFMeU5yaGNvdnkyRDlwNFZlTnU1YjZQMkppOHRFcStLQkRPL2R3ekhDZS9jcUxIRGlsS3FKcUFhb3NWRDZpK0EwMzA2amJnWnFLbUNHNEhpREdqMzNEcUpvQ3VvNXRFRGNmRXZjbGc4T1Fzb0NJVFhhWFdKY0Evb3lKUHVDQVk4TzA1OUN0T3dHWUF3b21WVVlUUklodHkraVJQTnYxRXQ0a3poTDJDWVk3N3gvTmpnbFFBcUpjVmVKSkJpc2txNEpTalNrekVHWk1LaytpR1hDNFloNE5ZamhZOU15MFMzZzZDSStES0tQUkoxOXB1T0tCZnQ4Z1l4TzFSVDQxd3k2U0xFLzBKQkRaZ3F4TDc5RWxCeEtIODRRdGtITVMzTUlCRnVBdWszbUxUaXBRMzhNc0NCVmM0eVhsN2JNS0pxVFFJcUNRc0J1dzNoTjI4aGduVU4xOFEvY05YUE5PUFE3eTlEWERNNUltaUo0cTBJWGRtM09LUDM4MUF6NU5CTVRQVm9OWUkyUGR6RjBZZ2RLcFUwc004VXVoOG9oTlJFMW9VTjdhbU81QktpUjdCME40MEpxazRBYnpKcWtYOFRvK2xEZ1VPU1lweVNDVkFadGhVQm56YXVQUkFWQUJPTEVSYVNiTEdhSnlVa0syYkFhbEFCSHBUV2lCLzNwU2RnelFGTEN4MWRsTFpUZncvMjI1SjMvY29IWUJRT2ZhQ1RRUkxHNFdZQVphRzRUb1FHNVBZQnVFRkFDVkliaFFBRzRVeEN2UUkySTNKUmFibjBFVXhoVi9qVGpQNERnZzdEelBCTUF1U2MzSWtNZGkwMVExTjdqTzNRMUlwak80NVVMTlN1d3VvQXRUcHJBcUFIakFFNzJPSGpURXZvMmRUeDRpQkluRGtST0lMbmpvNDNZRWx3Z2dZWkxYaTA0emVQMVRrQXIxTjNqOTR3ZUpmeDNVcDVNS2piZ2FOSXZpT2dkNU45U1o0OEtJZmpJb21xeURUVnNFTk5YajgxS1pFL2pFNHBiMi9pVGt6YjNKeCtzT1JNK0RwOFlZSWhEQnc2V01jZ1ZBVFZqbGo1a3RKVW9BV29rT09XUzZBQ0pKYVR6ZzZmMXlTUW81cEpsVXFFaGJuTERhRW5QWGlUR0U1WG5DU0I4V01qUW8zb3BoSnNBREtQY2lFaDZ2TmhMajRXa2tHTzRESzBuVzN6ajJTRkRUY0N3Z21ZVkNwdkF1dGhYcy9BdUJRQ0RSK0Z5bmJaM0FqZ0VmcGhsVFZWTUNma3B5QW1FZWhNWDE4Qk52RWRDRGszUXN3Q1VNWDBWdEo5REVNVFFDV0JVa3lDSUk0OGpiVmdVQUZBTjRERzhjVVk1aFlwSEFVQ0xJa3hYSmwzSFZWTkd0TE1BL2tuY2tjQnpQSlFCeFE0MGowTVRTbTBuRkNtVEFvd01MY1RHb3FpMldRdVE3Y0dEQzRlV2FJSFRZUXJhRndTMEtTMmdQaFRQR3BRT2l4MDBoT0F3RENNbWtCc3VNOG9sMENHRXpJajhUZVFDc0kxUWwwMmRJZEFDd29zQ3JDZDBrNkp6NXJRM3J5TG9idFZtemhJbVhUZEx4ajRZbXNJUk5QL0wwQi9pQWZUYjJBQ0QwbjJPUFRBT1U5TDJoejByZlY4RGZuYTlMNUpiMGtJTmRBVDBqd0tmU0gzQS95aW85QXROV2FnUDA2YkMvUzAzYVgyYWgyc0xESjZTYklxSGpzaWhFdGF6NHhISTFBQU1pN0VhVEZ3ZE44WkFKOUNPSWlMSzlpdmd3MEk5d1h3eTVXMDUwMHg3R3dqYlF1dUl6amNRa0xPUWwxSW0xTDdjZndRUkowallzdlNLY2l4RTZWalVqVXNtOE9GYzBBc3dFQzhoWEVyQjBUc3MzVUx1U2F5TVB3RWhaemVJT2VnckxTVlgzWmRBRHJJaDk3UVpQM3c4RE1XTlUzSmRRVFFIa2dSdE5nM3FDMmlDN1N1MS82T2lPQm8wdlJiTTJ6bHM5RE1zQjFzKzBITWdhRmF1M0x3RkVpb2lTRjQ2RVR3L2Nlc3RnRDRoazFIcEc1aEdnYTRpSjRaR2NkREk0b0tOU0xQNXgwZGdET2RHQVdralA1N05iYkljejJCTEdURlFCTEs5eWV5NjQrUUNlWnVRWHpIZ0FYMmNoVE9CNVZJc0U5OFJ1ZVNBNndXS04rRHo4T0FWZUE3aHdRVVVCWGdHWVVuTGVBamlGTEgwQWJoY0FDM04zWUx1QWh6TDBwaWhsTitsSGttSndwZzRrRUc0NHBCa3g1SjdRUjZHSTBIc2lVM2h5K0lmdFFqeHpQRmJJbGRYVTlqeHVUQmt3Yk51MXcvUENHN0pKc2s3SEZjWnNvRDFHeTgxZWJOcUNoY2N5RXR3VnN0YlA5UUFVbkNCSFYveUplMHUwSE1qeUh5MHJFQ29pVVREc2tiMk96VnMwN09OekFRRGJOb0JMc3VoVFNFeUlXN0oyQWxxWVhNRXN4WGZseGV6UUdON0tyQVBzbS9CdUl3RFNFd1poZnN1NUgyQUFjNTlHQnpRY3VsSEJ5TGNuYktoenVCR0hJRHlwYzRWMlZSSjhKSFB0QVVjdEhLZ2xnbFF1Q3h6Uy9ISE1zQThjaWxGejlSUUREQllwNVNTblBKeVJFc25PcHpyME9uSVp5NWVjQUdaeUcyTHp6WnkrTURuSmFqMU9YblBaemYvUVhKWVk0Y29QTHp6dUljWElUeEpjM1FHbzlxczRrSUR5YU1qd3lCTXZHRzdYUUF0elVvR0FBK2NuZk5TMENWTzhBMUFrU05YMnJ6QVVBK011VHJzMWZLcXhTVFg5TEF6Z0FaWTNQeUlRRmlnQUZTZ0JjbjZSZmZTZk5ZRFhBR3NCWkJRSXczS3gwWmM2RDNSSWxFdmppZHlqY3hnMXN0U012aU1BS1ZWSDFLQ2pQL1hmQlAwSUNsM0s2bzNtQTFOeFF4SVVDQXN6QXZNNERsQWJRSTJDc2pPSXJySko4Q2NDek1CNWFzM2pSRVRMQUFUVUhRMnM5TTNHUTg0QllpSUxPc3dNSE05R0FDR1BUbDZBbVhPdVQ0MGxEUW9ERzB2aU00TE84SWFBb3pnUXV4TVNVNWdvZngxUXJxUUJINW9ucUs1QitvS3RWdkFBUVk0cVVMZnBnS2JhTGV3K09iNzFwSnNReDBMVGkxOFBWTHdpT0NyZ3ZqQnlDbXRObHorQ3RmUkdEUUUxd3hFS0t3QXFIRUs1azBFTW5pRmdqYzMzME80QlFwY3QwVTF6U0NCVkNxdU42QUphWm9uN2h0Q2tQMTBMT2ZmUXBNTFU0N0NPTUtLMGpnc3NMTXNqaFVDQUwvUS94ZGprQTBVSEtDalV5RDJQamJDNThPZVNIQ1lZQ0RpRUNsQ04wRHlnWndVampuQklJczlSTkM0TjJ3ams0azVMVGpNcUJJc3lLQUVxd3NsaVlDbUwxc0RDczg3M0h4VG9pUU5sRE8wTVVNZTlyWTdFRjFqMlFpaE1vQm5OZmtJZmxsdkJvQXRpWXdLMk4vQ2RnSGNOdGpNaXV3bUl6OG9yb3I2TkRnRmpGNkswNDVhSkt5WHMwRGxLeVRNek9QVE5rRXh4bVh6VFVweEN1TE5XREl1bDhvWUNrT1NLSllscjFKU3RZMHdHUFkwdkVqS05EcFk1NHVBQi9vVHdScEJaVVQwUTJjNGdCdVFpQWhiRUgxZjRSMUFRR2JwaTlld29jSWRNZzRzZVNNb1JqTkRDSWZNT0pTaU5BakhHbng5bzRzSk9Uc0VzdE5VQ1VRTW1nSktFazNNTytpMi9UK0NyQ1owMHNPcEtCOFNzTHhqT0VoYUlzUTRvQ2VFOUY0dE9LSFlBMHdzRXM5RklTOHZPLzhMbmJKay84NCtBNk9xU3Q0dFgxQ1ZlQ3ZiMFNUQm1laktFS1l2TVNXSURTbzF3cW1DSkM2eEtrTHUwaGpHTTFjQTF4TXZkV0FnUUxvQ013QUtOQ1RKTWhxT05MazA3cU84VGVveGFPb3lyUzM0ek5MZW9yVE1sQ1dnL3RONWljazc3M2RMUjB6MHJCak9mSDBzT2pFa3NyRk9qQXk5Nk9ETEFQWXpWQ0JKTFdkMmJkSWdkU1U0SlZRTHJBTDBsb2YxSE1RSWdWZUwyQWVVaGkzUzlJTExFRWdBZnpWb2sraHlrNTl3N2d1VWhlRnhLMTBCbEpXTHVrVWt1NEEwazNRTFNTVEFnZ0JMS0Y0QTZITEx2a3Z6TEpLR3kzeEpyS29FdDlJeHhDdFlzQldMU2dGbUlrajF5VnNyWUllVXNjb1hnV1k1bEk3TDJVK1NJWXRXeXo2RUsxSUFjc29Nd095b2NwbkxPeXB4R2FnRUJFMlBDdzA1Q29rdG9YN1Njb09nc3k1OTNMTFZjV3JSN0t5c01hMlRLU2dkY2g3S2dnRGNwcklPeXU4cDNLNnlnOHVPQ2p5NGN2ekxERW1za25LTzRTOHJXd2FsTGNwcVVkeTRnRkhRRTZVb0ZlQk5NMnJTTGdaeWlmM0xLa281YVRpaFd5LzJpakNleWxtMXZMdEE4L2xnMHB5bTNOQXJMYVFyVndybjNIclNmTFNnVld6UHlHVWF0TmVLSzhLZ3ZzaUdzK0xJTWlMd09pb2xBY2dqWHdkaXhFSlh5L3pIaW4zM016eFkyMUtjUnlneDFLWTkyaTE0cUFURDAvSXZHVFFDU1lwY0wzQzNkVm5pRWd3TklmVWw0MnNMSWdONHRLUE9MeXNuM3d3VFNzWVNvdkMwMWRCT29nQkt6dDNXQ2tZTFlvSDRwZU9TbzRFRVFua042TGlTaFNzeUJNTmRGT1ZvZnFQZUF2UUViZGYxeUJaVVYrd01vZUlXK1B0c3N3eGlGYzB4MUJRRmxTVzQ3N3o0cURLdGRFeURSaFZvdWw5aVRaMEQ2eTYwN2lQTlk3S3ZMRG13QW94Wk1FZ2FnSTR1MEQrdFk0R280T0lKL2pOeitNbmVLMVprUWhwT0tyekl2QjNLcXFZMHRNLzlNUW9zRi85STA1S29FamdDb2VKUGlrU2pnUUxDbkttWFJVcm0yQmVPQTE0NDhOTEt6UUl2TEVKUUxBYTRvNkxBRFRBSnl5bFN6cjBvd0UyV2F0YlNTQTlVb3FpYjQzVXMwQjlTK3FLTktQRXJ4SXREV280a3N0S1BFemdLNXplby9qUE9yQWtvUUx3d2VvM3hQQUFhQVFFUnVDSDVlMnprekZpK0ExaVNxdzg0TVNTYWxWMHFXOXhVOFV0OUxneXFreVdLUkxIbE5BcW1nVUNyMUo2SWxRRkNCS3kwQ3VEdHdZVUN1cFNVb2hHeEJxZ3luZHhETEpJcG1QbktLMk5yVi9DZ2dGWkcvTHJ5cVlIQmh5eTkyQ0pqSlEyYVBES2QzVHRIOVJOWWlHcVpybVVwbW9hRHQzV3JVSXIyYXpFRzJpYU5GWkNpQWN5bkswSzBnZ0JHdmpLZWF1SVNXamswZWpWQXF0QUhqT0JqUFNnYUhWZC9VUFRKS1U2dmNoSzFEaGd0OTF5ekNpamdRMXJITTlFR21JdnFtZ0VHYzRSRTJNR0lSNUhrRk5yWmdYOE5ITmZ3NDJ1dHI5a3UycDJDcmFvWnh0cnBpTk9KNThwUzVBS2xkdXEvYndHekpOV3NuRDh2dFg2SGdxUVFEMUxLREZrWDJsRHF1QVRwMVlERmtlNkU3WklpL3hONUFFNnZ0VmpOdGdPT3FvQzA2eWZtTnNFQmRUbUtvTGxNeDI0RVoySDhIaWxQdFZmSnpxRjRHSXFLOUJnTFcxT0lvZ091cDJnOXJPQlE2MExsSVhUVkJqNFRmV1FCeTY3cUc4SW02NzRCYnJmRUVyVHd4bnRiZ1JPSUpEYnBETHE5OHhWakZNY3pDVTEwaCs2L3RSYnFFZ1Jid2FpcTY2ZUFZaEF2ZHpoNHFJSUpYMFFEekt0ZDBFMS8wOWd1UUNRNVkxSFVBMkM3ZXA0VGpVK1ZINlM0QUFPcTZKMEFOZUhQYzdLMkpJQ2pTQW9mMXhobkVpekFvRGJxOWdNOFQ2QTd2MTZpRHFnSklBYkxxaTBNb0EybzFmTWRMcVBZQnRFQzRGYlVrZThyQS8raGpDbEFzVU9Da0J5d3dJYVN4UTN6UEY5SXdvd0pyTEdZc1VKbG9SeTY0TVV6RWs3ZXFaYytzNFlNRUs4c3lOMFVySkNqdEpEaUlRcWFLWXk3ZzZ4V3FCVG80aHJOeWk0WDhUYVNRSWcwdm1NbGd6RHhwTFVLSWhKdFpmU21zTk9MUkdwTDFrYTZFZ3VBeVRNaVNSdHVCV1NwcXErOWtrZ3d0TUxrQXpTSDBBeStFK3NDOVlBRzNDcWtqS3d4bzFxL2EzNHAxcWswb3h2QVNOU25hcGdhNC9XaktqQUlRcEFvcVRNdzdtSUVhQWZaeXJFYXF3cWhJcUlaR3FDRGI5cDhPa3Nwak5LMFVvNkJwUXBkS1NyMHpjeU1zamRRSllFdkJ6d29vaVlxWXNua3hDcDVJQXlJa1NRd1lBQkdoY21zaEd3VWF3T3JKNWdtc3d5TzBqQkZTWWpzQnVpVVJOS2JYSXd1Q3FCVXRNQVMrMFVtcXBwS2JreVNNQnF4THdQeWhHZ1JBSUp5aEtrRTVlQkFCSi9TZ0ZBNVVnSGdCRUFkaE93RW1KVFlpbkpLYVhJc0FEcWJRQUJwcVhrd0JRTDNNYjVxbXdwTGlDaXBOTllUQnEraHdpaWdySitOOHFTS0kxbUFrRzRHNFErdGV0U0pQZmpKVTZLczU5OUFIY04wclFJbzRCeWxBRSsrcUtDckc2V09lYlZTaTBNL3JCSWIrcjFMYW9vcXdkS2pxb0J0bUNRRzlxUGNTN3FpQnBzVGVvbnRQL3JCQXAwdmdhaEczcEFrdFNxamdrVXRKTTZOTy9wazJmeXBTU1BxbHNPMENleTllTTU4R3d1d0RqNG9QY0EwQzhFbW1VcU1yK0U1QURxemtHSGt4b0tFc3NSTGFhcGdEcHFRQk44QWV3SVZlMkhOZ2tZY0VNZXlhNWNVTFFWYTQ5dFFFQlRoRnVZN1ZUMXJWYzdYVHlITXRlenUxQjJCN1RTZ2Q3TjlWdU1KMkJCenRndnRVKzA2UXp3TlZ5dnN3VXJZRnZzd2RDSFQxdzcwV2dRaUV5cVZnRGgwVDJTSVNSMDcyZGpCL3NvSENxU3gxRTRISFg0UThkVUJ6dUFpZE4zbC90eWRXQjNnNTRIWkRqd0JhZFpCd1owMEhBamd3ZGlPTm5VbzVjSEVTbndjaDhQbG9FNWlISHNnRjA1RUR1cjNzVjlhaHpxRHAyTTFub2NET1JoeGl4RmRYeHcrcDJITXRoc1F1SFBoeDRkTmRQaHoxMTh6QTNVTGhuZzIrcWlnemRTUjF0aksrVzNWUjUwQ0IzVVVjck9GUjBQdzFITDNWbjVTK1NubXA1QTlZUFFaNEM2TVBUSUFXZVNQVExRekhXUFVTNEU5WG5rOGNUdGJ4eUY0TTlSeDJLTnJ6WldoVEx2TUZpbmNjUzlLVnJzZEJ5Y2dGZWQvSEd2U0NjQStSS2pDZG0yekhDaWNYdVNSemlkUE1idlhGYnZ1Qm1INzF4V3dmUnNCaDlQb25TY0o5TEp3Q29rMnN3Rm4xZTlmSnhYMWw5TVhWS2QxOUtlb3ZTRzJIZldxY3grUS9RWGc2bkphRlAweldkQUFia3E0WnVVM2w5NWJ1VDNsdDVRK1JIa3g1Q2VSSGxwNVdlU25rSjVVZVVYa0NmYjBqMFFONWJEcGJsUE9MZVU3ay9JWmpxSGtlNVB1VzNsaU84ZVZRQTdBVHpoUUJQT2VnRm1BNGdUemdVQjBPVklGRTZGQVltV0tCK082VHVLQlpnTVR1SmxReEpUcmlBQWtWVHQ4UXRFVlR1d0F0T2hRSE1saWdNVHEwUUxnTFJDMFF5T21lWHV3SjVUemhHQVI1WGp2NDdCTzRUcWs2Sk9xVHBrNmU1VlRyaUJGTytUcFU3UE8veEEwN2RPNG1SMDZ4Ty9UcWs2ak9renVJNmFPbGVXOUl2Ylpwd0Z4L1E5ekRhY1g0QkUzV0Q2Y3FjZ1JEbWNQWEM0MXhIVDQxUElYRE5HRmd6QURCMEZjQkdETGNDRkJVQUtVM1FBSERFcnJLNkxNQUUycE5odVdaeng4QXdJTURXQ0U2c1F6V0NCQTJPcEF0MnNNcnZhRm1BZWdGSk1FR1ZVRFl5QnUvMURrNE1jUlZWY0FFVGVITmE3NlFYUEpLeGdGZC95dWQwek1pUldaNkt3K0p6d2NNNHJxNjcyc0hycjY3SElUWUc1eWY5QjBBRURsaERwMCt6bG9TcnUyN1J1L3J2MjdBdlhSRU1ya2lqYnBtNnR1bmhRb1VwcS9SQk1hR0toK3R1VEIzT29JVG81c3F4QzNBSmJHSzFmck91MHJ1MjZNNjBGa21oZ3pMVmc2ZCt0TEZsZTdBdklIdnU2MXVqQ0JrcVM0cElneE5OdXNIdG9Ba2UyS3l3cERNOXZpSEFHdWg2RXVDbzRZbnJwVnhiTjBtaXNSS0hQbE9UNGU1SHF2ejFJT2REK28yUUM3c3BJTjFUb21GTmNNMTNOMkVJdzlkQnl5ZVBIcG4zVXJJTjlGakwvazBiVW10MHpFeTFkU0JrME5RTFpTMlVaSkFTc2U3cm9OeVRzMUFGTTBsWUg3cFlZMmVzYXlVUzd2VWIxZmd1QVgyRlFMMWVsTkZuTlFlc3J0WXliTEsvRHdveDFjZ0J1RWQ4aWdBSGQ5QU9FRy9WeTJUZ0dVcGg4cERUQTBrUU9XaFd3eWdCMjExakVvS1UyTzQ2RWJyV0hVTHJIeUZhSTlTU3RNMkFSdTNycVNhZGlDZ0crMWFBVDUxMWJ0UWI1M2hENjBicEJjU2RVRVNnQmRVQUlGM2paUVhmc2c2QjhIU0YzS01iZ1l3elc1YXlNMEhNTkVYWkdTeGMxUVpXRTI1cXdVN25QWXgxQjJsc0ZlNldiUUNqN2FIRmxxUmYwZDNIV0RSZVFOM3RwMmhRaURYUWgrM2tBUkNGNUdBTHo1a2pib0FOZFVuUDlxQVllMFdKUmh5NXVRdEF4TU9rU2cycHp6WUhQZ1p0ZCsrNkg3Z3FMV2NBcHRjZ2VYbVA3Z0tNL3FtQWZlemRIQUJEK3EyRFdEZjgzSE9Bb0ppMS91cnpnS0VMR1BCS0RHL3V4UTZVa0pSUUErKzBBZ0g2dFN0Slhpa1JnVWtSbjdsMklPU3VqNzJiemkzYVVBV1ZFMzZVTmJmdXlaR29vbnNxTmpTc0lvQjZvSUhBZGlNVS9Hc2dVQk8rMlNSQUhiZ0FmcG96d0JrU250cEVCNUZOeUFYUVZBZHNMMEIyR2dvaDkramRDYUlsRFdBMmRCL1VWNER0NFhEZTRoblZUK2wxRHpVMnV4eHI0SDdvY2xOQUE5amJyRzc3eUJ5Z1lFQ0dRRzkwb0pxQnFBVkFKS0NCZFcrQTZCbjNvM1FKRExLMkp4M3N2MG44RkNESkFHRHdqSThKU1NJVkJ3TjNOeGFDWVlDUlFoVzdiVHo0d1dOcUQ5Y2MvSWZ1TEJqdXgvVnVBUkpkQ1Y4Ry9CcWdtcVFrUVRObFFCS0NSb0c4NGZCL3dmOEhRT1VEbVFCK1FPRE1TSm5PV05HY3hDMEtVSmVCd2xPaEFpSEloM3dkeXJRQ2NJZHNBc2h5SWVpSGtBYVZsZUJaV0ZJZG1CaGtlNEdRQVlobEVFZVEzWXZPQXlIOGhnb2I4SFZCOWd6ajZRTXNvYjhwdkI4Z0V5SG1ob29ib0xxcVlXbDZHQ2gxUWJqNXVoNFlheUdpaHdVWDBBTEFQUUErQWRvTkFIWUFKaHlJZGtrS0lTZ2VuNktJWllmOEhaSmNVd1VIeEI5dmtFdDU2L3RTMkdXaDl0SkVvdlFjWWFhSG1oOUNTS0dSZ1FuTW9KQzBYL29UWnhJWkFDRndQUE9mdXVIVGhrSk55R2VocTRjK0dpaHJOQVRBOTR2OUJPSGZCMlNWeHlMODlZYW1CaCt6L3UyWlFSOUNWa2xNVFhGaG96ak5lRWJRbFpKUllHTmc5aG1nTWR3Qm9rZ0R5SFBoM3djSGc5RUFmdEtDQit5Z2sxcEtDSVhpZ0JrQWFBRFJHdmgwcUpMb1NBTWJCZTcxZTlnQW02Zmh3a2ZRa0JBQWthNUhsb1dNMUpIQkRja2NwSHFSeUFGcEg2UnNFZTc2a2laRWNVR1JLRDRiNUhKUmhIVGQxc1I4M3pPUXdBQ1VmUWxXaHBrWlpIeGJaMDNmUU9SN29ZVkdlUjM0WVZHazZPNkdsSFhob1VkeFlLUnNmeENIUlI4VWIrRytSclVhRG9LbERjbjlBMlJnMGZwSGpSejRja1ZkWGFWQXJ4WEJqZ1hjSEdvdkhIcEhLQ1FJZDdwUlFQUUZDSDZSNGtZdEdjdUdrY0RCWXh3SHNqOVNSKzBhVEhIUjVvYk5HNDlYRmdUR3hSak1aOUhUWEVMT0c2T2htWUV2eTcyNW5yaVZvT3E2QnFJdUJrZERvUTZ4dmdiRnowc0Yzb2VwU0J1UWVaRDFoNERIckcwUUZRYk9IMGxEUWE2RmNOUGtHaEdoZ2NUMVRKTys3UWVxNE9DaXBYUENvN1R6bFFBRnh0Q1Y2eGtBTGNnc0E5UVhGZ0FBRE1qbWdCQkRBUURWVjVWQXJwVUJ4YlBrSDlRKzBFMk9UZE54eEFkSE15Z1lSVlVWbVZINmlLSU5GWmdCZzg5RWFRQlVRdldtK2p6YXVneGhRV0N6RlI2RTRnUGE2NDNETlU0Sm9BUkxZbEJtRCtncnFPM0swMEh3TzRFaDZzK3lYRlQ4R3FjMGV6aWE0SWdHNUp2Q1FhMitGUmhPOGFaVllGVEp3RUFHbEZabnpnZ25HUlNUZDFnLzFIRlJFaXc5MzBCOTBxd3ZjdzV1Q2dMMWdyY1NkSDRHaTdiRkVSQjlraEYxc3lJUTZhRGFvL2NQa0hCY3pjbnRKWW1Gd2RnSDlSZkVJWEduOWRvSklJcTFFQWNLckg0M1FFUHVEZ2QrY1RXWFRiQVpTYmNwS0NOY2JFNFpWS09WQkNWQnFrY2xCUDhTcFVkUjVLMUxybGo5azBBbmdtUWttZ0VVUk1LWVBIQzVNaWR3c0M5K0p0U09xcHl4aUp4OWo1UWNoRjZwZDFFaUQ1Skh6SXVIVUxiZ080RnFnYVdUNkEzTkM0WlBvVHB5N0pCaHBZOVVhV2dvQTRRQ1RSZWhlS2VyeHRBY20wNEkzQ0tTUUwwMEJzVVhlcTByRUppbnJWY0dDenR6RW0ySnhQcXA4RWFORmo2N2xOTTRFOVEzWUdaWHZIWUZSOGN4SnF3ZGxTQ2RBSmd3Y3dVT0tUaHg2bXlGWlZXYnRxRmRMQ3V5VFVoaFFzVU9jQ3V4V1pIa2NhY2l5TndESlJhNGZ1aTNDSmNHYlJQRllWelBTcWZCQUpKZ1dPcXlOMVpQcEc0czBpcTJjY080ZlBRN2haVWVVbVg4Z3AzWTFiWXdwaEtiT05GczdrbElBYnRPeWoyTVRBd2Z3aW5IcG1FQlMwN0FVQW14d3ZwM21waEJGdzBBak1wQVp1RUJyVS9wMjRCVUh3Wm1zbHowNkVJZ0NNbllacTZMbEkydzI0RTNHSHBvR2NidzVTTHd6eHdHYlU0MHhCZ1FDSUdWaGJGVkhNQkJYMjVnR0JBRkFFaHk0bm8rNHpNWTF2Q042ZGF0U2dDVFZiSHF5V21ZWGg2WmxTWkRodkEwNkc2bllVK2FlNEE4M1RoV3ZzUmlib1R2NVlFM3V4bW5FaVZVRUZtVWk4Z0ZBNWI1VWpzTGhLT0xxZkw5TWl1cVorTUV3REhKdUtvc2s0RjBGd1FWREIxSFF3YXdEemg3aUZ4RkJRaEdNL01wQTc4MERPZ3lqS3dET3o5OHN1MllnelZRS0RJc3hoVU9ESlhneXpQeGlRemtzZWhHNWEzVlhnRFNBbWdjRWFhZFMyempSU2I0c2dZWjhjS3dYTWtZclBlSDlsTjQ1WjJ1MjFKYUN3VFJLNlllNmFhMng1RUZ4akZBcUpWc0RZYTkrYmdIYXdGUWNlMkZhc2tWQVQ3TkhyYXVlb1lEdUxnd1QwV1lEL0htZ2dVSVVHZEJoa1J5WTRCbCtQb0Q3SlNDTy9CdllsQWRnQWNSNkFWdVk5STlnRHVkcUhYMjNPZkxBeDU0MURZQmk1cEZHUVp0dXdVVHNKaWRVZWVkQURNRlRIWWkycVBjbG9BVjU3ZVpYQjE1NHZCazEyc0dBVVJROWdZRHEwVkJXdkV4RmJxQmFlemZiYlBWZHVsYUY3WG9GN3ozV1dya0JCYnREZTFKVEh0RHNESHIxV3RxRDBCajdURWgxYndjRTRrWFpPbEExbzNaaldwb0ZOYmtrYzF1aDFMV3M5aUd6eklKdnR2WVVkUjF2UjFuVy8remRiQUhYSFdBZEV6VkhSOWFaaFAxcGdkWU9RTnVwMFVPSkIzcDFVSFBEa2phaU9WblZJNGNIVXFvVGFsb0lCYUljZGdFaDFrUkZRY2gxSlZYdEtod2wxUDBhWFh6YVBxUXR2SUJtSEpYUU00eTI0dGtyYXpnTzBsNGM1Ri9oM3JiQkhSdHVFZHZKMXRvdDEyMm1SeFI0NUhOSGg3Yk1lUHRwczVWSEZuZzBjUjI3UnpIYS9PZlJ4RDBwMm94MW5iVEhPSEVYYjQ5UlBUNTVqMjlkdUY1aU1UUFNjY2QyODZka3dEMmo2ZzhjNTdMTGg4Y3oydnh6UUFla0hiaXZiNjlVSndrYzcybHZRQnpIMjJKdytwNG5CK2Q3MFAycEp5L2FVblY3alNjeDlESjBuMEJjZGhkeWR2dWNEcVgxOWZGZldySHEyV0R2c3lWN0JEb3ZRZ2d0dGlQMVBNc1JIUTZwNlREcXVpQ3NRRUdPaEFRQXFFQkJmalFFSFUwY09UK1cvbGY1ZitYQkJ2U1JJZzNsMUNGd0VCQXVrMElFQkJpbzhtYVFCeVoxYXJZQjFxd0VDK2FCbHIrV25rLzVCZVhZQWJoR2VRQVZKQWplV2c1TURYeEE2V3NEU1lrQkFCVEhwb0FVWkpidnRlQkRiVEZXOG1pZzVQcW5KWEFIUG9DaklKanozMUg3Q2JvZFVHR1lEazIrV2ZodjVZUDluQWI1WXJZOEp0UlNhcEVpUmxVaFdSb0x6UmhXSHhqN0pmSC9nR29ER0ozeDlnaDJCRTBlMjNXb0dUUW51aVZaelhGZnVoN2Jld3gyVGRBbjFDcWhMZzhBR1dWWjRJWW5yZzBRYVlsR0VsUEhaT1pTRTZDZnZDTWRYWWlhYVVaY1RSUlJYZFM5RmJVOHNWaW9oeFgrbFBGWmxjWk1KT24zaTR6RGdIZlJGa1VsYjFOT1ZyWUc1V1h4cFFsWFJ6MVhNSG9BUHh4aUJpaUh3YUpSYlJRbHR3TnRxYVZyZFZkQjlrdk5WckdVdTJiVWVKcWtMSmk3NlZ3RHhUaFE4NmxCc0xyY1hUdXVyQXFRU2czdXhBRzAwdHYxeUMrNnVDVWVBN2laTzZaK3kxZEpSN29PbFR1MW9QSmdrZnFhSEYrcUFOdWN1VXNvQXRzTnVyd3dpQThlb1pCbVJqb0JOS3FzNjB1cncvVmwvU05YZVRDMWEzSlExaDZBaldXdlJieUlDdUlvekVFQVI2NEpTMFMwMTkxY3pXdlY3TmJ2MDgxZ05jRlVnMXlpYXRXdzFsU2wyOFkrU05hMTRBNjFzYjF5L3Vua0ZXVG9RdXVDM2RFMTJ0WTJTVkFadENUeDAxajFheldGTlgxYWRMMjF0b2tBelV1N3RkTFcyUGZ0ZkxYQjE3N3VIV251QkUwbVRsZ3lkY0k4YTE1TmVDVmlvaHRZelhQVm0vUnpXbE5hajNYWEMxNE5lTFhxa0hkWklqOTFqUm9TZ2pRRkZDblhMMTA1VWhVVlMyOWFYWG0xbGRkelcxMXVsWTdYTjFrTlkvWHcxM2RhK0RGdkZVcVJDRTF3RGZ1VnRsYWFyV3JqYUJkY2JYNzFuZ3NmWDc5WjllZzJOMW90ZTNXRU5yOVpmeGtONVpaY0JzL040dXJXazFvRGUyVXZtMERhYldIMTF0YWcyQzF6dGEzV1MxaWpZcDl2MTVoTElUU3dLdGF5QVVzWGJtaVVpSnhwVVZYQnlURlVaY1pWcFFFZzh6QVBPc0ZodGxFNWZwa1JWdGtCT1hYalR4S21BOXBrWTBKWGVrWFRmSThwRjR5QmVxSi9KUTJWTmpncFF6Vk1HZ3hqWXcyTGxITTBZU0V5ejkwTTJWQVYyd2NOSE42cnRJMlhOeHplTTJJNWhXQm5xVVdqTUJOanJONDRCQzM0Y0lFMVpqSmlPemZlVnpiSE0zZWpuTitEME9Hc0RFUUcwMnJscnpkZldrdHE1YjgzRWVOS0QrbHpOMmdGQXR3dG9MZEFxSWJDeURDMnJOaUxmWnRiTnBJRWJYRk5yUlc2UUw1eVdGbTRiZ1FZQ3FNRVFYR0EvdDZqTlVrYU14a3BVak10dGtaY1BuamkrS1VQTlhQM1RGYmxwQ1Y1U2xlTTE4Y2xmTTArZkVBeDVuNXRoQzJheFJOVCtGWlhWUEsyYjlHR2NaZnF5Vy8yd1lCTmNVc00rZHNCWUFTK1lGYk50Q2V6SlV4V2lWcWZuVHREampsYVdjaFZ1L21qclgrZGZVcTBBQmFXZ3FNTFZwUHM0Y1QvblB0SUZyK2g5eERXa0hUdnM0RnFEVUd5MzdPMXBmdGNFVzFxdGFQN0IxdS9zc0ZrUDB4MDMyRGl6RVFnSEVCd0oxdlc5ekpKMWtkNkJ3cDBLRmhCeW9XNmRGQjBaMTZGekJ4amFPZGVOckZKUnNZRHBxNFA1NnNtNFdNMnloMEtkczJ1RjJFWFpkQXR0OFdXSEVKZjgyQ05EaHlpWlpGMmxHcmJkZERkd2JhbTI5UmV0MFluS1J3N2E3ZGVSd3g0dG1ReGNDNWpGNG5sTVh5ZWR6bk1XQTlTeFlDNXk1TjNVMzVqSFQzVG5ibzljeDNpNDQ5S3h5VDFBbGxibnNjUmVKQWFBaG5IREZMM2FtSFB4Y1I0QWwxeGZudGdsODlyQ1dBbk9VZWtDb2xzNEZ2YnZKaDl2YjBuMnBKWmZhRW5OSmIrNE1sempSWDczdUhKWUE3eHRONGkrM0NsdWZXS1hDblNEcEtjZkk4cHpnNlErS3AxcVdhbkJwY241Nm5XU1ZzMU45T2hYWklZdXpDSGk3ZjlkZ3d5d3RrSmcybTc1akRWWlVCQkRHR0hwQnhWTWxBTHdSdWZxa1NKbURkdmNFbE4xZGswajkvVVB2YzczNnV6UDIyWUc5bWZ2a0k2OXVhSHJISjlydGREWEo5NEF4VE5Ta0JVamFoRnV6dHlRVXJjU01EWUtxOUNrMWI1THdBWWN6bVJQSnZhQTl1cU9lclVONURMZmYvMTVJSS9mYXcxMFNuQTRwaHlLN0Via2hOUHR4TmRDRFJZRGhUNmNmdm1DcFowUE92MVFrWU5HREpKblZwRUVPc055Tzd2ZlErNkxZQVhKTEtPM2xoUy9jdXV6VEJIaEFGWGY4UmljakVvd1ZWQWpGRG5TdFpyUTVJOUNPTTBnUExzMEZob0FSOXJJS3NoWjBkVlkvSGFBTWc5TjlKYlI3R3JqWUQvUzNnT2FGRFBGWjNleVhVbEExbTQ0WldRUERSUFFoMEFDRkxMWHdCRldSWUJSQmg5anZmRkJCRDByWFNBcHlXL09OUmpJeHJYOFJPWEhEZUdWaVRLS2tTQnNGYWFkS0E2Z1BQbVFDdDlrY1lnOWJ0RG9BLzNuOXdXY25ZN1hLdGpUNGM5Q2t5MXdPS0o4amxuMTFQL2RBQmxOeG1CY2hhQUVBL3JOTGJGaG41TjU2bkRPRW9VRDdnOTRvdDZUQStvd0RHSEE1cVJtdEsvQlQ2SCtaZzVEaHFET2FhOXl3S0dvaHdUMHNMbkQvMHZsK1E5SW0vRDVBNTRCVUR4YjBYUkI2MmcrNW14TEc1QXdPcU1XeGdWZ2FRTExXS1ErTVdLQS8yNER4dGlFT3ZEamNsUUJ4b2ZwVGlCdXR2R2xZUmtEOURsUVB6OGZwUWlCYitvU1JyMmFXYkk5MUkveFBJNkNPeWpsVlYxV2lBUnBxeTAveExRQnVBS0NkYWdoRDdMSDFYWkhqeDMvdGZidy9GWTlzQnlXU2xrV3pQZTU0QzVCSFZWYkFRbkc5Nmc3bWhEamExWHVKZUQydGJLMXhBV1FSNk90MkV4Z0VPMk1CWTVrT3M0VVE2Q015RGlTRmFvYlp6STZrT0lqcGhHMlVWRGpLYmVwTjhTVUJoSTdzNnozamdBc2toQWZTaEdRY2hGaW05NnFkTGpXUWNwYzU3TmoxMGoyclA1MTVlUEdHVUhMQ1Z5Q1Q5a0QwUXZHWGtGL3pJRHpZL0FBMmxVazd1N1R5U2srUEhZekNrNXhPQVZtazdwT21UM1VjNU5HVG5FL2RIV1QzL1BkSHZsMms0M0krVDgwY0VoN2xvOEVsWE02cHFIckdzQjdzYWJHaDFSR0g5UXVuRFB3VlBFNjRuR1ZPdW5EY2p5N1lNTjJHN1VkK3JwMjdyRTNDL2wrM1A4bDN4WVpHbzdWbGpzUUxQMjNqdHhMRE1FRHNqZ2NQb0toZzdaTzNHc0JzWlpIRDcxTlpUSGI1dyszU0ZRQTJITHpJa2N6a0lNN0VSZm9SNUNEQUxkTmsweEhlWWNQdGpPeUFkZkpVMDdTQTRMb1FFVGZLM0ZzdlpsRG9jZzVUMlU4VlBpY0FrQlZPbmdOVTVBeU5UOUdDT0FpenpZTXpQOHVrZzZ2ZGx1aHJIS25wckkzMnF5aWcwUWFjdGt0N0F6Vk9mRHRReUZOQ25EcXpoSUswUUZIbFBZemNRLzczR05acWZ6cHRpbEkvYUg2eC8xR0hSZzBOTk9WT3dKSjlpb3pEUUVzZG5QNXo5WUVYUHpScUErWkhNaWNvRk9ZSjhPYmo2c2dyWVhvRkpvb3ppRVY0M1lKdUdWcFR0NXJhaGRpUUttbmEzTnViYms2T3pnWHJlUUdWYWN3aENwN0xQdzBvQ1orNWtla21aakRYaGIxZHR0ZW1nQXFhUTdmS3RBckVOTWZOb291alN2T2ExMlhqNW83YkRzNFhxZG9LNUZrbkxyTTZaTlgrNE1KS1lPcktGaGxZT1RvaXdTTzdIRzd5bGZRWnJNMDBwTlZjUi9well5akVKbUg3WVhaQ25OQTN6aTlEblJ5c1k4ZS9QL2dHY3MyaVIxTWk1eEdremw0ekc1RzhlT2dhQjY0UmpRcHFTTGthRFVLZEJuaTVQS2lXL0ZkbmgrNGNBRERkZ0x2VjNkd0ZqUGJmZTUzY1E3ZjBoSGtQVWlBTmNMODQzWFQzdW5aTHd2aThkZE1VR2hMcEtqS0JSTHl5N2g2alFPVWZYVGI4aUhwY3ZBVDZBNTdSRitvd1ptQnl0OVZ4ZGpidWpJK2dQMFQzWWdjbXlTM3YydENLTWNnRXJRSVFFVzNid25jYjREWUF1UVRLMitBZ2NzUy9YSmJUNWNEUzJyOWJ3MWdzSkxiVFp2MGF1K2tFMmdIRE8vU0t1TW9JRTIwMm5TM0s3VXRsa2JUZlUwTXQxTS9uMmVONnBIbjMydW1mZDZNREx6WjMrb1dxTllPQnovSnQ0K2l2QVVBSE5tSitrSGJESUFFNk9yMVM2VVFNMXBiT2VJZ3ZxWEpqc0k5eUNjUDg5dmd0T2VuU294YXVFWjF1T1NxNUQ0SzRzeUFUMXRPOGhjVUVDWDJ2bGpRbkpZb0NMOWlaU1BHQU5nNmlZeXNLQlMzSlZRYU00YXBucjI4ZFZCdytzNUFldlFWd005bUpsTVp1b3d6eVVBUTBCdUdJUWM0aEJpYzRObXRuWnRaczVJSzZyVFB6dDhrSXhBQ2d5eVd5UHpEd0k3V0F3UmxJL1hia0M4TEFabkQwUit1ajdwUjZtZXl6TTZKcmoyNjVQMnJqdGM4WUJxVkhHOEtrTjNXc21NT245cEFCZjJXbmRwaXNQYThOZEs5QjdDS01CVnJZTVpHRVlCTzBEL2ZzUEVqa0poblJuRHlzMmxSWEQ2d2d4aFFEN0xVT3U3Z1k2N09CVHJzMDIxWW9ybUsvQkE3U1J6TTUxc0ZLeXl1dWlMOUxBUk5sVHFLOXRud1hWYytuTzR6VXM3bk94L0xjN3VBbHo5N3YzT2h1bWM3NEdyYmhjOXR1ZHo1YzlUSXBiNTBVbTUrT0JpL0t0ZVFXRjFJWldMaEZ4NjNRQUx1RjlCbFNCeUVPTlB6Zjg3dTZ2TDJZeFQ0d0xwWTN3WWUwZTB2YlB4VGNYTUJxNTVrU2k4TUJMODN3b3VvN0QyNitpc3NCWTY2MXE0cUFTQ0JlTVFwekdPckNMRGo2UGVnRmsyd0JGaFhzQktCdWo4WTh3QkpqaGhSNlBEUkNzQnlid2pwRUFpQjhBRDRyaEpxT0VyQWs1ZHVOdTZzSUlnZnhFN3VSWjRJL0tQc0R4cldudWxqZzdzNnZCdXBreXhpcHFLTWpSQnlVclV3QXV4c0g4eWtHckx4eHBzdTJDZVhIYk1ReW42aW1CWUxrZmltQWFuS1lHeTVydVpyRHZQcnVGcmVKQi9VQU81cjdSMEQrL3I3UTdydUhqOXpDS08rcHVZN2hxTE12QkFSZm8vdXRMOEM0L3VvTG00SEt3cjdnSXNmTTc3cGNMUkFIN3h0bURCaVRKUUg2NjVEUEFmTnZzek5RMkVOVlRlbnVCT2tRQUpDaVZucDl3L0dQSmlCNDZ3NWt6T2kvUWVIejBKay92cWpZQUF5d0pUWCs4c013N3lIQ0dPTnIyRk1Dci96dG5wQlc1UjdiZXdRazd0SndsTTlML3c4bUlaN3E5ZVFBTGhIL3RMcC9oZTRtODFVRmg3aXFCZzdLOW1NSHpVOW8vN3U1SHBRK3pIMWU0MjlMT2VacE9tZXU5U09VZTU4aElOVytHdjVTZVcva1JJTTVZRHNCYlZJU0dMc0NiM2prYTBWWlpROGNaajRDRTZpQ05EbXZGd2cwUU5FR2RFTGhlK1MwUC9LUGhLOHk2aEhvVndna1RqbkRWOTdibVhzVFFERTltYTM1TkRnMCt5WWhMWEh2UWlmRGVrRGd0c253TmJxcktleUxSaXREYTNKNHF2OExBcDVFQnlucHh1S2ZxZWlYQkJrQ2V1aEQ1NisxUjRKaVNiM0lkWGtza2tnOXpMUHNuOHJ6TE91bnNDZWZVTW44N29LeEc0NWxJZFBZYWkyclFzS3RsRHZwV3g5N2NFaTJKSXRFR3FmYXJxQ3JSQVFaVk0vbE9lUFRwNzU5Mm5nWjdQSE1MYnA4L2NucVptcDZmV253NTRnczZlcHk3WUxNcnM4OEJxaExTZDNGN2VlcmNEZ3NCdFNaNmJkbm5tWjZPQXVlMVUyT0JQbmtiUmVlTlRaUzNlZlJiT3R5K2Vib0pUbEJlYUVKVGllZkFYcWE5Nnk1cm1xZDZkdG1Ya0VKemVCNWtZRkpPVlNzcmpVeUFFb0hpMU1vbjQ5SE95VUx5WU01K3p0a0ZvUENuQ20rYjJuNElaL0ExdkQzOUVLT0pEc1hXcGYzMFg5QVplZTk0bDhpQ29xQkV3S1BlOWlRN3E3Nytqa2dFc1J6eWw2U0RLeC8weUgzYURrcDU5M0pYemsxVjlYWXFBd0p1ZEV2ZkcyUWNjK2g1d2hnUVBXNXIzSHNOKzh6cG56L0lEcU1RN3poNDNRdTRXdzBqdTA3bTY4Q3FUb3VFN0lndHNhdU9KbU5RWGpEWjdCZElURHRWblg1N3VUZ0cwQk01NHhCTFQxNTdJNTBKb2xKcHV5RXhqeEdUL1dpOWJLUXk4cE5hSU5qZU9ZVVQ0ajJXWkZ1bFVBQ3VOd1J2UzJqRGM4K0xTZU81dWdGZUZqSlBmWU9GNHdyM0NpRitkemdWMDFnQVdLQ0MrbXlTc1BBQjFWQzN4N0tyZTJBZjJ6VGxwODZ0OXJlQkhsdDhiZmk4RFEvaExuMUxOK0RnYzMzZUgrdnZnVU4waHZGKytZelNNMG5GWXhGTGxvT2F4Sk15VEgvajdmSDgrRElkb1pzejN3Zk1NN2lpRjVSTW5OdUtWZVliaDdvM1IwQWV5ZzU3TWVxbThzYjdMSHBnZGVuQ05ucjhQdVpnZDVMOWgzaG1DTGYxWVI5NC9kRW9VV2lSVHF4b2F2S0JzY2VITHh4WnUrZWE3WkVIa2ZoQ25YczNEVXBacXhuM1ZPQktBNVNqblFxRExwMGJVZW1NOGpjb0IzeHcyOFRRQ1VmbzFLNEswdndTaDFZSEQ3Yk4zM3lHNTdlYWtKRCt6ZjRNKzk5MVl0WWFkNTJ2TGkwZTdZQjhUQ2dzNHNhNDh6UVN1U3NlUTM5UVdQcEs5c2VFYU1HNm5RdVBvT2pNZVJvU2EvTThMQUgwTmR4MzBDNjVDdmsrdTg3ZGc5WG1GeHI3L0NZTzRzTjN6OGZoNGVJODNyQ1JBUmp5bG5Vdi9SL1Z5Z2VqWFRJM2lzMWd2YTdLYTNKM0c2TWY2eDg4T1Bmc21Vcy9sUFN6c1hLTnVkQUVzNTdIWjhoejhnQ2FKd3g1MEFUYnl6NVExSVB2TSthZlo5cHNaYytkenFLNmMvQXZ6VStDK0JEdytyOHc5dWkyNDNQcmIwbDdxb2lpSTkvN0RTYncwRnpPQXZqVTRlaGoyYm1iOC9UbmludFU5Y3ZwT3FDZDhNeFNPYnFMQWR2Wm1INlBveXVlV1drWDdaeXA5YjI2OXBCU01jYytpRFdDUDRuZDk5MlBrUldCYXdac1JCSTJvbVM2NEIrclR3UFBPU1Uzb0VsMGlWN0VDNVBpMzAxK2lQNnYwaytMZUtWbFNZUlBkVXE2SUZtTzdTMG5neWNlcjJhTHk0c0U0aXJBTkR2M01TQWtiSUJsbW5FMzIxL0lBK2dCY25xKzNWbmFCbW53amRiNzdjOXZpSEdrWnVZT2ZDS3lsb0t1OEYyRkFFZDRJeXc2WGdZUyttdk5IcXIxVXZ2RDRiaHlYaVBvTUdMeUF0ajQ1WSt1TXh0TUxNdmZZd2Y1cmJCK1cxNWFJVzJNMWFRYmsrMGkrNi8raFhNTjN4ZFc1bXVJZTRpSzNkQTJnRXMyd1NHemJCSk5UVW42Y2JkVFVDTm1IWndadmNCdTJDNFY0L093bDl0U1lNbDVPb0JFQlVnWEFHZEZ0YTNITUlNS3pzT1ZuZDZlcWtrUkFiSUdJQjJCZ0xJaDZjdjMwZlFFd3llMFlHNFYvNVFVY3dYWWRFRFZjMVlFRXc2NmdPVFB6QXJsL21maEg0TnRadjVVbXV2KzFVYWUvM0luN3pFMit4eCswQkN3MitkWG81TUR2ekg2b2dSS0wzSmtGZUtQanBPSTBqNHRqaEF6dTg2eGdueFBmdTN2SU5YV2JETzJjWWErYTIxOFRLN2Z2bWJ0eTNZdVFYNTRBRGZuVjdUK2ZYdGUzSCtaVmEvNTNldysyeEVTRUdBVzlWVUJlQ2gvdDVkaWdYZ2RHQmZ2dElkQ0hkaDNrRjErMnIrTGtkQmEvc0h3SjFyeDJYVzFIZmRhdjJBaGZ4MGlGbkhjZ2M4ZC8xdklXcWRJblpEYnFGMG5ZamJtZGFOcVlYWTJsaFpwM2tBUFA0NFdHZHROcDRYbFFDaDM0WFdkd1Jkb2NaMlRuZEVYdWR5UmI1M0FnT09Ka1dhMnhSWkYzYTJzWFpVV0pkMDNTbDJPOUxSYU00ZEZtdm5sM3pPQXhlZDFjZVBYYWp6UGROWGQ5MVIyclhkcDRyRnlkcjEyYVVBM2FSY2V4YXhjQ3h4bTdaZHJXT2VQNXA2RGRvT09adkRidEFISStMTnh6K0xJOW9wNkU5b1Y2ZlZiaExRYUMxNk1SRFh0QnZReExRUGJ4TFlQYUpMUkhqSkxGT0FSN0RjREpPYVBiYVhFSGh4N2EzU0VURlFSei9aUFpnZEJmUVFkVXBaUWRUUGFWTFpBQ1ZPSWZpM3BaRG9kc01KcDVBQnB6ckFjT1l1QkN2YTEyS3ZhdzlWVXlQWERremdBZGpRSW1mL1JrQVpQNlVBT0s2Zy9XT3J5SWVlb3RvZG1hekVDOGlkZmJyNjlmRU56ZUhCZ3dJWURDNWFBaUhEUjVXc3dMZEh3QkdtVHR5TDhYbUFoWFZDNGo4QWRpV05HZFMwbUlLcDIyTGlCWFdjb3JtUUdPUUpIYzc1b0FFOG85MkxocTBBYndGbmZPcWpKdkFDeHZNWFY2MWRNMENNakp5eGZ3SWo0YWZXcnJVZlR0d0VvRStyS2JTUUdncmFRR3lBdjl4bTJDNVR5UWJnVDE3Rzc3ZkFlNGdNL0xBenkvUlg3MWFKallYS1JkRGNDZjM0UjlGd3hna0VvRk0vRlg0RUtLOWFYS1NkRDVBcjVpVG9NWlRGdllvRXFJUm41bEFvVFFwWUhpQldBcHM1RDdJbUFuMUVaNm1BRHNBMm1IUXJmQlo5Qk4yZUpRbGhWb2pKd1BOVERxR1ZvdDRhSnhyQXpRYldIV2VCWVhLUHBQVkpRRDhjSjZoKzNHNEJQbldGemxBVjg3R3ZaVDRib1dWQm1nYjg3OUFWOXIxSk82SWpxQ0dhTWFmR3dpUFNKeGlQUDlxUVhKWDViQXhsU1kzVWRDeUFqZWlCemRsRFAxTlpUVDlJd0NEb2R2aWdvZVVCSVVNSll3QUZ3NkpRSElGNFlXTXhPUEprd1FqRi9McWJQL0wxNlJkUVVRR2RaSUtFQ1NFNWJnUzFrVVV5RDFjcjV3WkdnSWJrUktEWndIWUNuVUk0QmRFZWtFQTVFY2J1NGQwWjJJY1VCaVNFTUt4WWNsQzJNUHZiT0FKeDQ3UUs0aWwrRkRLWmJITEJINUlVeElnejZKS0dCTTQ0Z3RzeUpRQk01QnJJbzV1VVdlcXlneGRRSXpKUXhiN1dsNzRncHZZeTBTTUNFZyt2SjR1VXBDTkFFa0hLZzVnemtneXI0UEZjVUdxZzJrSHdnZWtFR1lSa0Vha1prRkNQTmtIUWd6a0VkZmNrSFVjZmtIZkFRVUhEdllVRkJyWUF4aWc2a0dMcVk2SlNndkVZeWd6UWlMcWVVSHFnMC9hYWcxb0dVWUJNRDJjVDBFL0FGZTZiTlpJN1Q5VmtIc2dtRUdQNURyNFVRRkc3eGc2ckFna2FvRHZrSklpOTNjUzRtZzgzN1FBRmNhN0VRTUVuR1NmaWtnNXl3THdIOEJDQXNxcHJFS1VGOUEwb0dBM1B5ajJnanVCUmdsUkRiN1ltQVZBK3pZb2d4NGpNQUJNR2xqY2x3cmpLTkNKZkhpTEVzRkw0WW1iVlozQWVkNTJxSC9oNzhaYVpmamFOUmdLZWRSZ1RkdGcvZ1Z3YlQ0ZGhTYmc2ZDZPQUtrRzRnMjc3MG1EM0k5ak1zR0pRUkR6ZDFIY0gwNFoyWjQ0THdZdkFCcno3Z3kwRnRtZWQ0N0FZOEVxZ3RzeUFHZnB4aFZWb0ZqZ2h3Q1crQVZ5eGd5UHlKZzdnUkNBckg2Qm1KK0Q5T1M4RzNmUVFZbmd0c3ppbU9FQktHRE9xd1F4Q0crSEdkWjZ3Uk1GNUExaWhwZzgwYk9namtGYkFBZDVsZ3dBeWUrT3NHZVFWOEdyWUViS3RBaWlEeVFWSkpQc1VCQkZnemRBaVVVc0dVUXNjWmpiQ2lESVFrMEVVUTZzRnVnUkR5Q1dNYkF3UXlpRW1UWGlIb3JMaUhvclBzRXRBeW9GRGd6a3dRWkNTVGJNQy9KWWcvMEdmZzhNRnRtWU1GNkVVTUZvUXQwQ1JncWc1TS9kbDVhUTlOWTk3QWNHeGJYSUZWWU93QWdZR3RRb2dKZUJLUTBVRXFRb1V6cVEzRWJHd01NRkNtQk00enJFVDVJUlBVR08rUEZ5dGcwVDV4bU92SmVRK0E2OFF3SHlPelNrQmhzWHdBc0laVFoxbUl1b09QY0RLMnFRVnd4UWxHNmNtRmx5SzNZQ1NaSEZsd2daSU9TdXpKRzU1U1Rsd0FRdUtHWWJRbkxPK0RYeVhFWENHampkTUV1Z29pSHUrYUNwQ2d3ajQ0Y0RuQUVLQUFCUTBRd0FBeExVaEpFbm5CSDJKd1VJUURaSVZnSHFSMFhrY0FmbmtjQldBUHQxN0pqZGNnQUE9PVwiXScpO1xuLy8gRVhURVJOQUwgTU9EVUxFOiAuL25vZGVfbW9kdWxlcy9sei1zdHJpbmcvbGlicy9sei1zdHJpbmcuanNcbnZhciBsel9zdHJpbmcgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDk2MSk7XG52YXIgbHpfc3RyaW5nX2RlZmF1bHQgPSAvKiNfX1BVUkVfXyovX193ZWJwYWNrX3JlcXVpcmVfXy5uKGx6X3N0cmluZyk7XG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvaGVscGVycy9zY3JpcHRfd3dfYXBpLmpzXG5cblxuXG5cbi8vIFdlYndvcmtlciBpbnRlcmZhY2Vcbi8vIENvbXBpbGVkIHdlYndvcmtlciAoc2VlIHdlYnBhY2svd3dfcGx1Z2luLmpzKVxuXG5cblxuIC8vIEZvciB3ZWJ3b3JrZXItbG9hZGVyIHRvIGZpbmQgdGhlIHd3XG5cbnZhciBXZWJXb3JrID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gV2ViV29yayhkYykge1xuICAgIGNsYXNzQ2FsbENoZWNrX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFdlYldvcmspO1xuXG4gICAgdGhpcy5kYyA9IGRjO1xuICAgIHRoaXMudGFza3MgPSB7fTtcblxuICAgIHRoaXMub25ldmVudCA9IGZ1bmN0aW9uICgpIHt9O1xuXG4gICAgdGhpcy5zdGFydCgpO1xuICB9XG5cbiAgY3JlYXRlQ2xhc3NfY3JlYXRlQ2xhc3MoV2ViV29yaywgW3tcbiAgICBrZXk6IFwic3RhcnRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc3RhcnQoKSB7XG4gICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgICBpZiAodGhpcy53b3JrZXIpIHRoaXMud29ya2VyLnRlcm1pbmF0ZSgpOyAvLyBVUkwuY3JlYXRlT2JqZWN0VVJMXG5cbiAgICAgIHdpbmRvdy5VUkwgPSB3aW5kb3cuVVJMIHx8IHdpbmRvdy53ZWJraXRVUkw7XG4gICAgICB2YXIgZGF0YSA9IGx6X3N0cmluZ19kZWZhdWx0KCkuZGVjb21wcmVzc0Zyb21CYXNlNjQod3ckJCRfbmFtZXNwYWNlT2JqZWN0WzBdKTtcbiAgICAgIHZhciBibG9iO1xuXG4gICAgICB0cnkge1xuICAgICAgICBibG9iID0gbmV3IEJsb2IoW2RhdGFdLCB7XG4gICAgICAgICAgdHlwZTogJ2FwcGxpY2F0aW9uL2phdmFzY3JpcHQnXG4gICAgICAgIH0pO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAvLyBCYWNrd2FyZHMtY29tcGF0aWJpbGl0eVxuICAgICAgICB3aW5kb3cuQmxvYkJ1aWxkZXIgPSB3aW5kb3cuQmxvYkJ1aWxkZXIgfHwgd2luZG93LldlYktpdEJsb2JCdWlsZGVyIHx8IHdpbmRvdy5Nb3pCbG9iQnVpbGRlcjtcbiAgICAgICAgYmxvYiA9IG5ldyBCbG9iQnVpbGRlcigpO1xuICAgICAgICBibG9iLmFwcGVuZChkYXRhKTtcbiAgICAgICAgYmxvYiA9IGJsb2IuZ2V0QmxvYigpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLndvcmtlciA9IG5ldyBXb3JrZXIoVVJMLmNyZWF0ZU9iamVjdFVSTChibG9iKSk7XG5cbiAgICAgIHRoaXMud29ya2VyLm9ubWVzc2FnZSA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIHJldHVybiBfdGhpcy5vbm1lc3NhZ2UoZSk7XG4gICAgICB9O1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJzdGFydF9zb2NrZXRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc3RhcnRfc29ja2V0KCkge1xuICAgICAgdmFyIF90aGlzMiA9IHRoaXM7XG5cbiAgICAgIGlmICghdGhpcy5kYy5zZXR0Lm5vZGVfdXJsKSByZXR1cm47XG4gICAgICB0aGlzLnNvY2tldCA9IG5ldyBXZWJTb2NrZXQodGhpcy5kYy5zZXR0Lm5vZGVfdXJsKTtcbiAgICAgIHRoaXMuc29ja2V0LmFkZEV2ZW50TGlzdGVuZXIoJ21lc3NhZ2UnLCBmdW5jdGlvbiAoZSkge1xuICAgICAgICBfdGhpczIub25tZXNzYWdlKHtcbiAgICAgICAgICBkYXRhOiBKU09OLnBhcnNlKGUuZGF0YSlcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICAgIHRoaXMubXNnX3F1ZXVlID0gW107XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInNlbmRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2VuZChtc2csIHR4X2tleXMpIHtcbiAgICAgIGlmICh0aGlzLmRjLnNldHQubm9kZV91cmwpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2VuZF9ub2RlKG1zZywgdHhfa2V5cyk7XG4gICAgICB9XG5cbiAgICAgIGlmICh0eF9rZXlzKSB7XG4gICAgICAgIHZhciB0eF9vYmpzID0gdHhfa2V5cy5tYXAoZnVuY3Rpb24gKGspIHtcbiAgICAgICAgICByZXR1cm4gbXNnLmRhdGFba107XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLndvcmtlci5wb3N0TWVzc2FnZShtc2csIHR4X29ianMpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy53b3JrZXIucG9zdE1lc3NhZ2UobXNnKTtcbiAgICAgIH1cbiAgICB9IC8vIFNlbmQgdG8gbm9kZS5qcyB2aWEgd2Vic29ja2V0XG5cbiAgfSwge1xuICAgIGtleTogXCJzZW5kX25vZGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2VuZF9ub2RlKG1zZywgdHhfa2V5cykge1xuICAgICAgaWYgKCF0aGlzLnNvY2tldCkgdGhpcy5zdGFydF9zb2NrZXQoKTtcblxuICAgICAgaWYgKHRoaXMuc29ja2V0ICYmIHRoaXMuc29ja2V0LnJlYWR5U3RhdGUpIHtcbiAgICAgICAgLy8gU2VuZCB0aGUgb2xkIG1lc3NhZ2VzIGZpcnN0XG4gICAgICAgIHdoaWxlICh0aGlzLm1zZ19xdWV1ZS5sZW5ndGgpIHtcbiAgICAgICAgICB2YXIgbSA9IHRoaXMubXNnX3F1ZXVlLnNoaWZ0KCk7XG4gICAgICAgICAgdGhpcy5zb2NrZXQuc2VuZChKU09OLnN0cmluZ2lmeShtKSk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnNvY2tldC5zZW5kKEpTT04uc3RyaW5naWZ5KG1zZykpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5tc2dfcXVldWUucHVzaChtc2cpO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJvbm1lc3NhZ2VcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gb25tZXNzYWdlKGUpIHtcbiAgICAgIGlmIChlLmRhdGEuaWQgaW4gdGhpcy50YXNrcykge1xuICAgICAgICB0aGlzLnRhc2tzW2UuZGF0YS5pZF0oZS5kYXRhLmRhdGEpO1xuICAgICAgICBkZWxldGUgdGhpcy50YXNrc1tlLmRhdGEuaWRdO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5vbmV2ZW50KGUpO1xuICAgICAgfVxuICAgIH0gLy8gRXhlY3V0ZSBhIHRhc2tcblxuICB9LCB7XG4gICAga2V5OiBcImV4ZWNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIF9leGVjID0gX2FzeW5jVG9HZW5lcmF0b3IoIC8qI19fUFVSRV9fKi9yZWdlbmVyYXRvcl9kZWZhdWx0KCkubWFyayhmdW5jdGlvbiBfY2FsbGVlKHR5cGUsIGRhdGEsIHR4X2tleXMpIHtcbiAgICAgICAgdmFyIF90aGlzMyA9IHRoaXM7XG5cbiAgICAgICAgcmV0dXJuIHJlZ2VuZXJhdG9yX2RlZmF1bHQoKS53cmFwKGZ1bmN0aW9uIF9jYWxsZWUkKF9jb250ZXh0KSB7XG4gICAgICAgICAgd2hpbGUgKDEpIHtcbiAgICAgICAgICAgIHN3aXRjaCAoX2NvbnRleHQucHJldiA9IF9jb250ZXh0Lm5leHQpIHtcbiAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dC5hYnJ1cHQoXCJyZXR1cm5cIiwgbmV3IFByb21pc2UoZnVuY3Rpb24gKHJzLCByaikge1xuICAgICAgICAgICAgICAgICAgdmFyIGlkID0gdXRpbHMudXVpZCgpO1xuXG4gICAgICAgICAgICAgICAgICBfdGhpczMuc2VuZCh7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IHR5cGUsXG4gICAgICAgICAgICAgICAgICAgIGlkOiBpZCxcbiAgICAgICAgICAgICAgICAgICAgZGF0YTogZGF0YVxuICAgICAgICAgICAgICAgICAgfSwgdHhfa2V5cyk7XG5cbiAgICAgICAgICAgICAgICAgIF90aGlzMy50YXNrc1tpZF0gPSBmdW5jdGlvbiAocmVzKSB7XG4gICAgICAgICAgICAgICAgICAgIHJzKHJlcyk7XG4gICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH0pKTtcblxuICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgIGNhc2UgXCJlbmRcIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQuc3RvcCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSwgX2NhbGxlZSk7XG4gICAgICB9KSk7XG5cbiAgICAgIGZ1bmN0aW9uIGV4ZWMoX3gsIF94MiwgX3gzKSB7XG4gICAgICAgIHJldHVybiBfZXhlYy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gZXhlYztcbiAgICB9KCkgLy8gRXhlY3V0ZSBhIHRhc2ssIGJ1dCBqdXN0IGZ1Y2tpbmcgZG8gaXQsXG4gICAgLy8gZG8gbm90IHdhaXQgZm9yIHRoZSByZXN1bHRcblxuICB9LCB7XG4gICAga2V5OiBcImp1c3RcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24ganVzdCh0eXBlLCBkYXRhLCB0eF9rZXlzKSB7XG4gICAgICB2YXIgaWQgPSB1dGlscy51dWlkKCk7XG4gICAgICB0aGlzLnNlbmQoe1xuICAgICAgICB0eXBlOiB0eXBlLFxuICAgICAgICBpZDogaWQsXG4gICAgICAgIGRhdGE6IGRhdGFcbiAgICAgIH0sIHR4X2tleXMpO1xuICAgIH0gLy8gUmVsYXkgYW4gZXZlbnQgZnJvbSBpZnJhbWUgcG9zdE1lc3NhZ2VcbiAgICAvLyAoZm9yIHRoZSBmdXR1cmUpXG5cbiAgfSwge1xuICAgIGtleTogXCJyZWxheVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgX3JlbGF5ID0gX2FzeW5jVG9HZW5lcmF0b3IoIC8qI19fUFVSRV9fKi9yZWdlbmVyYXRvcl9kZWZhdWx0KCkubWFyayhmdW5jdGlvbiBfY2FsbGVlMihldmVudCwganVzdCkge1xuICAgICAgICB2YXIgX3RoaXM0ID0gdGhpcztcblxuICAgICAgICByZXR1cm4gcmVnZW5lcmF0b3JfZGVmYXVsdCgpLndyYXAoZnVuY3Rpb24gX2NhbGxlZTIkKF9jb250ZXh0Mikge1xuICAgICAgICAgIHdoaWxlICgxKSB7XG4gICAgICAgICAgICBzd2l0Y2ggKF9jb250ZXh0Mi5wcmV2ID0gX2NvbnRleHQyLm5leHQpIHtcbiAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgIGlmIChqdXN0ID09PSB2b2lkIDApIHtcbiAgICAgICAgICAgICAgICAgIGp1c3QgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQyLmFicnVwdChcInJldHVyblwiLCBuZXcgUHJvbWlzZShmdW5jdGlvbiAocnMsIHJqKSB7XG4gICAgICAgICAgICAgICAgICBfdGhpczQuc2VuZChldmVudCwgZXZlbnQudHhfa2V5cyk7XG5cbiAgICAgICAgICAgICAgICAgIGlmICghanVzdCkge1xuICAgICAgICAgICAgICAgICAgICBfdGhpczQudGFza3NbZXZlbnQuaWRdID0gZnVuY3Rpb24gKHJlcykge1xuICAgICAgICAgICAgICAgICAgICAgIHJzKHJlcyk7XG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSkpO1xuXG4gICAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgY2FzZSBcImVuZFwiOlxuICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDIuc3RvcCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSwgX2NhbGxlZTIpO1xuICAgICAgfSkpO1xuXG4gICAgICBmdW5jdGlvbiByZWxheShfeDQsIF94NSkge1xuICAgICAgICByZXR1cm4gX3JlbGF5LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiByZWxheTtcbiAgICB9KClcbiAgfSwge1xuICAgIGtleTogXCJkZXN0cm95XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGRlc3Ryb3koKSB7XG4gICAgICBpZiAodGhpcy53b3JrZXIpIHRoaXMud29ya2VyLnRlcm1pbmF0ZSgpO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBXZWJXb3JrO1xufSgpO1xuXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIGNvbnN0IHNjcmlwdF93d19hcGkgPSAoV2ViV29yayk7XG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvaGVscGVycy9zY3JpcHRfdXRpbHMuanNcblxuXG52YXIgRkRFRlMgPSAvKGZ1bmN0aW9uIHwpKFskQS1aX11bMC05QS1aXyRcXC5dKilbXFxzXSo/XFwoKC4qPylcXCkvZ21pO1xudmFyIFNCUkFDS0VUUyA9IC8oWyRBLVpfXVswLTlBLVpfJFxcLl0qKVtcXHNdKj9cXFsoW15cIl5cXFteXFxdXSs/KVxcXS9nbWk7XG52YXIgVEZTVFIgPSAvKFxcZCspKFxcdyopL2dtO1xudmFyIEJVRl9JTkMgPSA1O1xudmFyIHRmX2NhY2hlID0ge307XG5mdW5jdGlvbiBmX2FyZ3Moc3JjKSB7XG4gIEZERUZTLmxhc3RJbmRleCA9IDA7XG4gIHZhciBtID0gRkRFRlMuZXhlYyhzcmMpO1xuXG4gIGlmIChtKSB7XG4gICAgdmFyIGZrZXl3b3JkID0gbVsxXS50cmltKCk7XG4gICAgdmFyIGZuYW1lID0gbVsyXS50cmltKCk7XG4gICAgdmFyIGZhcmdzID0gbVszXS50cmltKCk7XG4gICAgcmV0dXJuIGZhcmdzLnNwbGl0KCcsJykubWFwKGZ1bmN0aW9uICh4KSB7XG4gICAgICByZXR1cm4geC50cmltKCk7XG4gICAgfSk7XG4gIH1cblxuICByZXR1cm4gW107XG59XG5mdW5jdGlvbiBmX2JvZHkoc3JjKSB7XG4gIHJldHVybiBzcmMuc2xpY2Uoc3JjLmluZGV4T2YoXCJ7XCIpICsgMSwgc3JjLmxhc3RJbmRleE9mKFwifVwiKSk7XG59XG5mdW5jdGlvbiB3cmFwX2lkeHMoc3JjLCBwcmUpIHtcbiAgaWYgKHByZSA9PT0gdm9pZCAwKSB7XG4gICAgcHJlID0gJyc7XG4gIH1cblxuICBTQlJBQ0tFVFMubGFzdEluZGV4ID0gMDtcbiAgdmFyIGNoYW5nZWQgPSBmYWxzZTtcblxuICBkbyB7XG4gICAgdmFyIG0gPSBTQlJBQ0tFVFMuZXhlYyhzcmMpO1xuXG4gICAgaWYgKG0pIHtcbiAgICAgIHZhciB2bmFtZSA9IG1bMV0udHJpbSgpO1xuICAgICAgdmFyIHZpbmRleCA9IG1bMl0udHJpbSgpO1xuXG4gICAgICBpZiAodmluZGV4ID09PSAnMCcgfHwgcGFyc2VJbnQodmluZGV4KSA8IEJVRl9JTkMpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIHN3aXRjaCAodm5hbWUpIHtcbiAgICAgICAgY2FzZSAnbGV0JzpcbiAgICAgICAgY2FzZSAndmFyJzpcbiAgICAgICAgY2FzZSAncmV0dXJuJzpcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgIH0gLy9sZXQgd3JhcCA9IGAke3ByZX1fdigke3ZuYW1lfSwgJHt2aW5kZXh9KVske3ZpbmRleH1dYFxuXG5cbiAgICAgIHZhciB3cmFwID0gXCJcIi5jb25jYXQodm5hbWUsIFwiW1wiKS5jb25jYXQocHJlLCBcIl9pKFwiKS5jb25jYXQodmluZGV4LCBcIiwgXCIpLmNvbmNhdCh2bmFtZSwgXCIpXVwiKTtcbiAgICAgIHNyYyA9IHNyYy5yZXBsYWNlKG1bMF0sIHdyYXApO1xuICAgICAgY2hhbmdlZCA9IHRydWU7XG4gICAgfVxuICB9IHdoaWxlIChtKTtcblxuICByZXR1cm4gY2hhbmdlZCA/IHNyYyA6IHNyYztcbn0gLy8gR2V0IGFsbCBtb2R1bGUgaGVscGVyIGNsYXNzZXNcblxuZnVuY3Rpb24gbWFrZV9tb2R1bGVfbGliKG1vZCkge1xuICB2YXIgbGliID0ge307XG5cbiAgZm9yICh2YXIgayBpbiBtb2QpIHtcbiAgICBpZiAoayA9PT0gJ21haW4nIHx8IGsgPT09ICdpZCcpIGNvbnRpbnVlO1xuICAgIHZhciBhID0gZl9hcmdzKG1vZFtrXSk7XG4gICAgbGliW2tdID0gbmV3IEZ1bmN0aW9uKGEsIGZfYm9keShtb2Rba10pKTtcbiAgfVxuXG4gIHJldHVybiBsaWI7XG59XG5mdW5jdGlvbiBnZXRfcmF3X3NyYyhmKSB7XG4gIGlmICh0eXBlb2YgZiA9PT0gJ3N0cmluZycpIHJldHVybiBmO1xuICB2YXIgc3JjID0gZi50b1N0cmluZygpO1xuICByZXR1cm4gc3JjLnNsaWNlKHNyYy5pbmRleE9mKFwie1wiKSArIDEsIHNyYy5sYXN0SW5kZXhPZihcIn1cIikpO1xufSAvLyBHZXQgdGYgaW4gbXMgZnJvbSBwYWlycyBzdWNoIChgMTVgLCBgbWApXG5cbmZ1bmN0aW9uIHRmX2Zyb21fcGFpcihudW0sIHBmKSB7XG4gIHZhciBtdWx0ID0gMTtcblxuICBzd2l0Y2ggKHBmKSB7XG4gICAgY2FzZSAncyc6XG4gICAgICBtdWx0ID0gQ29uc3QuU0VDT05EO1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlICdtJzpcbiAgICAgIG11bHQgPSBDb25zdC5NSU5VVEU7XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgJ0gnOlxuICAgICAgbXVsdCA9IENvbnN0LkhPVVI7XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgJ0QnOlxuICAgICAgbXVsdCA9IENvbnN0LkRBWTtcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSAnVyc6XG4gICAgICBtdWx0ID0gQ29uc3QuV0VFSztcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSAnTSc6XG4gICAgICBtdWx0ID0gQ29uc3QuTU9OVEg7XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgJ1knOlxuICAgICAgbXVsdCA9IENvbnN0LllFQVI7XG4gICAgICBicmVhaztcbiAgfVxuXG4gIHJldHVybiBwYXJzZUludChudW0pICogbXVsdDtcbn1cbmZ1bmN0aW9uIHRmX2Zyb21fc3RyKHN0cikge1xuICBpZiAodHlwZW9mIHN0ciA9PT0gJ251bWJlcicpIHJldHVybiBzdHI7XG4gIGlmICh0Zl9jYWNoZVtzdHJdKSByZXR1cm4gdGZfY2FjaGVbc3RyXTtcbiAgVEZTVFIubGFzdEluZGV4ID0gMDtcbiAgdmFyIG0gPSBURlNUUi5leGVjKHN0cik7XG5cbiAgaWYgKG0pIHtcbiAgICB0Zl9jYWNoZVtzdHJdID0gdGZfZnJvbV9wYWlyKG1bMV0sIG1bMl0pO1xuICAgIHJldHVybiB0Zl9jYWNoZVtzdHJdO1xuICB9XG5cbiAgcmV0dXJuIHVuZGVmaW5lZDtcbn1cbmZ1bmN0aW9uIGdldF9mbl9pZChwcmUsIGlkKSB7XG4gIHJldHVybiBwcmUgKyAnLScgKyBpZC5zcGxpdCgnPC0nKS5wb3AoKTtcbn0gLy8gQXBwbHkgZmlsdGVyIGZvciBhbGwgbmV3IG92ZXJsYXlzXG5cbmZ1bmN0aW9uIG92ZihvYmosIGYpIHtcbiAgdmFyIG53ID0ge307XG5cbiAgZm9yICh2YXIgaWQgaW4gb2JqKSB7XG4gICAgbndbaWRdID0ge307XG5cbiAgICBmb3IgKHZhciBrIGluIG9ialtpZF0pIHtcbiAgICAgIGlmIChrID09PSAnZGF0YScpIGNvbnRpbnVlO1xuICAgICAgbndbaWRdW2tdID0gb2JqW2lkXVtrXTtcbiAgICB9XG5cbiAgICBud1tpZF0uZGF0YSA9IGYob2JqW2lkXS5kYXRhKTtcbiAgfVxuXG4gIHJldHVybiBudztcbn0gLy8gUmV0dXJuIGluZGV4IG9mIHRoZSBuZXh0IGVsZW1lbnQgaW5cbi8vIGRhdGFzZXQgKHNpbmNlIHQpLiBJbXBsOiBzaW1wbGUgYmluYXJ5IHNlYXJjaFxuLy8gVE9ETzogb3B0aW1pemUgKHJlbWVtYmVyIHRoZSBwZW51bHRpbWF0ZVxuLy8gaXRlcmF0aW9uIGFuZCBzdGFydCBmcm9tIHRoZXJlKVxuXG5mdW5jdGlvbiBuZXh0dChkYXRhLCB0LCB0aSkge1xuICBpZiAodGkgPT09IHZvaWQgMCkge1xuICAgIHRpID0gMDtcbiAgfVxuXG4gIHZhciBpMCA9IDA7XG4gIHZhciBpTiA9IGRhdGEubGVuZ3RoIC0gMTtcblxuICB3aGlsZSAoaTAgPD0gaU4pIHtcbiAgICB2YXIgbWlkID0gTWF0aC5mbG9vcigoaTAgKyBpTikgLyAyKTtcblxuICAgIGlmIChkYXRhW21pZF1bdGldID09PSB0KSB7XG4gICAgICByZXR1cm4gbWlkO1xuICAgIH0gZWxzZSBpZiAoZGF0YVttaWRdW3RpXSA8IHQpIHtcbiAgICAgIGkwID0gbWlkICsgMTtcbiAgICB9IGVsc2Uge1xuICAgICAgaU4gPSBtaWQgLSAxO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0IDwgZGF0YVttaWRdW3RpXSA/IG1pZCA6IG1pZCArIDE7XG59IC8vIEVzdGltYXRlZCBzaXplIG9mIGRhdGFzZXRzXG5cbmZ1bmN0aW9uIHNpemVfb2ZfZHNzKGRhdGEpIHtcbiAgdmFyIGJ5dGVzID0gMDtcblxuICBmb3IgKHZhciBpZCBpbiBkYXRhKSB7XG4gICAgaWYgKGRhdGFbaWRdLmRhdGEgJiYgZGF0YVtpZF0uZGF0YVswXSkge1xuICAgICAgdmFyIHMwID0gc2l6ZV9vZihkYXRhW2lkXS5kYXRhWzBdKTtcbiAgICAgIGJ5dGVzICs9IHMwICogZGF0YVtpZF0uZGF0YS5sZW5ndGg7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGJ5dGVzO1xufSAvLyBVc2VkIHRvIG1lYXN1cmUgdGhlIHNpemUgb2YgZGF0YXNldFxuXG5mdW5jdGlvbiBzaXplX29mKG9iamVjdCkge1xuICB2YXIgbGlzdCA9IFtdLFxuICAgICAgc3RhY2sgPSBbb2JqZWN0XSxcbiAgICAgIGJ5dGVzID0gMDtcblxuICB3aGlsZSAoc3RhY2subGVuZ3RoKSB7XG4gICAgdmFyIHZhbHVlID0gc3RhY2sucG9wKCk7XG5cbiAgICB2YXIgdHlwZSA9IF90eXBlb2YodmFsdWUpO1xuXG4gICAgaWYgKHR5cGUgPT09ICdib29sZWFuJykge1xuICAgICAgYnl0ZXMgKz0gNDtcbiAgICB9IGVsc2UgaWYgKHR5cGUgPT09ICdzdHJpbmcnKSB7XG4gICAgICBieXRlcyArPSB2YWx1ZS5sZW5ndGggKiAyO1xuICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gJ251bWJlcicpIHtcbiAgICAgIGJ5dGVzICs9IDg7XG4gICAgfSBlbHNlIGlmICh0eXBlID09PSAnb2JqZWN0JyAmJiBsaXN0LmluZGV4T2YodmFsdWUpID09PSAtMSkge1xuICAgICAgbGlzdC5wdXNoKHZhbHVlKTtcblxuICAgICAgZm9yICh2YXIgaSBpbiB2YWx1ZSkge1xuICAgICAgICBzdGFjay5wdXNoKHZhbHVlW2ldKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gYnl0ZXM7XG59IC8vIFVwZGF0ZSBvbmNoYXJ0L29mZmNoYXJ0XG5cbmZ1bmN0aW9uIHVwZGF0ZShkYXRhLCB2YWwpIHtcbiAgdmFyIGkgPSBkYXRhLmxlbmd0aCAtIDE7XG4gIHZhciBsYXN0ID0gZGF0YVtpXTtcblxuICBpZiAoIWxhc3QgfHwgdmFsWzBdID4gbGFzdFswXSkge1xuICAgIGRhdGEucHVzaCh2YWwpO1xuICB9IGVsc2Uge1xuICAgIGRhdGFbaV0gPSB2YWw7XG4gIH1cbn1cbmZ1bmN0aW9uIHNjcmlwdF91dGlsc19ub3coKSB7XG4gIHJldHVybiBuZXcgRGF0ZSgpLmdldFRpbWUoKTtcbn1cbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9oZWxwZXJzL2RhdGFzZXQuanNcblxuXG5cblxuXG5mdW5jdGlvbiBkYXRhc2V0X2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXIobywgYWxsb3dBcnJheUxpa2UpIHsgdmFyIGl0OyBpZiAodHlwZW9mIFN5bWJvbCA9PT0gXCJ1bmRlZmluZWRcIiB8fCBvW1N5bWJvbC5pdGVyYXRvcl0gPT0gbnVsbCkgeyBpZiAoQXJyYXkuaXNBcnJheShvKSB8fCAoaXQgPSBkYXRhc2V0X3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5KG8pKSB8fCBhbGxvd0FycmF5TGlrZSAmJiBvICYmIHR5cGVvZiBvLmxlbmd0aCA9PT0gXCJudW1iZXJcIikgeyBpZiAoaXQpIG8gPSBpdDsgdmFyIGkgPSAwOyB2YXIgRiA9IGZ1bmN0aW9uIEYoKSB7fTsgcmV0dXJuIHsgczogRiwgbjogZnVuY3Rpb24gbigpIHsgaWYgKGkgPj0gby5sZW5ndGgpIHJldHVybiB7IGRvbmU6IHRydWUgfTsgcmV0dXJuIHsgZG9uZTogZmFsc2UsIHZhbHVlOiBvW2krK10gfTsgfSwgZTogZnVuY3Rpb24gZShfZSkgeyB0aHJvdyBfZTsgfSwgZjogRiB9OyB9IHRocm93IG5ldyBUeXBlRXJyb3IoXCJJbnZhbGlkIGF0dGVtcHQgdG8gaXRlcmF0ZSBub24taXRlcmFibGUgaW5zdGFuY2UuXFxuSW4gb3JkZXIgdG8gYmUgaXRlcmFibGUsIG5vbi1hcnJheSBvYmplY3RzIG11c3QgaGF2ZSBhIFtTeW1ib2wuaXRlcmF0b3JdKCkgbWV0aG9kLlwiKTsgfSB2YXIgbm9ybWFsQ29tcGxldGlvbiA9IHRydWUsIGRpZEVyciA9IGZhbHNlLCBlcnI7IHJldHVybiB7IHM6IGZ1bmN0aW9uIHMoKSB7IGl0ID0gb1tTeW1ib2wuaXRlcmF0b3JdKCk7IH0sIG46IGZ1bmN0aW9uIG4oKSB7IHZhciBzdGVwID0gaXQubmV4dCgpOyBub3JtYWxDb21wbGV0aW9uID0gc3RlcC5kb25lOyByZXR1cm4gc3RlcDsgfSwgZTogZnVuY3Rpb24gZShfZTIpIHsgZGlkRXJyID0gdHJ1ZTsgZXJyID0gX2UyOyB9LCBmOiBmdW5jdGlvbiBmKCkgeyB0cnkgeyBpZiAoIW5vcm1hbENvbXBsZXRpb24gJiYgaXRbXCJyZXR1cm5cIl0gIT0gbnVsbCkgaXRbXCJyZXR1cm5cIl0oKTsgfSBmaW5hbGx5IHsgaWYgKGRpZEVycikgdGhyb3cgZXJyOyB9IH0gfTsgfVxuXG5mdW5jdGlvbiBkYXRhc2V0X3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5KG8sIG1pbkxlbikgeyBpZiAoIW8pIHJldHVybjsgaWYgKHR5cGVvZiBvID09PSBcInN0cmluZ1wiKSByZXR1cm4gZGF0YXNldF9hcnJheUxpa2VUb0FycmF5KG8sIG1pbkxlbik7IHZhciBuID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG8pLnNsaWNlKDgsIC0xKTsgaWYgKG4gPT09IFwiT2JqZWN0XCIgJiYgby5jb25zdHJ1Y3RvcikgbiA9IG8uY29uc3RydWN0b3IubmFtZTsgaWYgKG4gPT09IFwiTWFwXCIgfHwgbiA9PT0gXCJTZXRcIikgcmV0dXJuIEFycmF5LmZyb20obyk7IGlmIChuID09PSBcIkFyZ3VtZW50c1wiIHx8IC9eKD86VWl8SSludCg/Ojh8MTZ8MzIpKD86Q2xhbXBlZCk/QXJyYXkkLy50ZXN0KG4pKSByZXR1cm4gZGF0YXNldF9hcnJheUxpa2VUb0FycmF5KG8sIG1pbkxlbik7IH1cblxuZnVuY3Rpb24gZGF0YXNldF9hcnJheUxpa2VUb0FycmF5KGFyciwgbGVuKSB7IGlmIChsZW4gPT0gbnVsbCB8fCBsZW4gPiBhcnIubGVuZ3RoKSBsZW4gPSBhcnIubGVuZ3RoOyBmb3IgKHZhciBpID0gMCwgYXJyMiA9IG5ldyBBcnJheShsZW4pOyBpIDwgbGVuOyBpKyspIHsgYXJyMltpXSA9IGFycltpXTsgfSByZXR1cm4gYXJyMjsgfVxuXG5cbi8vIERhdGFzZXQgcHJveHkgYmV0d2VlbiB2dWVqcyAmIFdlYldvcmtlclxuXG5cbnZhciBEYXRhc2V0ID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gRGF0YXNldChkYywgZGVzYykge1xuICAgIGNsYXNzQ2FsbENoZWNrX2NsYXNzQ2FsbENoZWNrKHRoaXMsIERhdGFzZXQpO1xuXG4gICAgLy8gVE9ETzogZGF0YXNldCB1cmwgYXJyb3cgZm4gdGVsbHMgV1dcbiAgICAvLyB0byBsb2FkIHRoZSBkcyBkaXJlY3RseSBmcm9tIHdlYlxuICAgIHRoaXMudHlwZSA9IGRlc2MudHlwZTtcbiAgICB0aGlzLmlkID0gZGVzYy5pZDtcbiAgICB0aGlzLmRjID0gZGM7IC8vIFNlbmQgdGhlIGRhdGEgdG8gV1dcblxuICAgIGlmIChkZXNjLmRhdGEpIHtcbiAgICAgIHRoaXMuZGMud3cuanVzdCgndXBsb2FkLWRhdGEnLCBfZGVmaW5lUHJvcGVydHkoe30sIHRoaXMuaWQsIGRlc2MpKTsgLy8gUmVtb3ZlIHRoZSBkYXRhIGZyb20gdGhlIGRlc2NyaXB0b3JcblxuICAgICAgZGVsZXRlIGRlc2MuZGF0YTtcbiAgICB9XG5cbiAgICB2YXIgcHJvdG8gPSBPYmplY3QuZ2V0UHJvdG90eXBlT2YodGhpcyk7XG4gICAgT2JqZWN0LnNldFByb3RvdHlwZU9mKGRlc2MsIHByb3RvKTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZGVzYywgJ2RjJywge1xuICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgIHJldHVybiBkYztcbiAgICAgIH1cbiAgICB9KTtcbiAgfSAvLyBXYXRjaCBmb3IgdGhlIGNoYW5nZXMgb2YgZGVzY3JpcHRvcnNcblxuXG4gIGNyZWF0ZUNsYXNzX2NyZWF0ZUNsYXNzKERhdGFzZXQsIFt7XG4gICAga2V5OiBcInNldFwiLFxuICAgIHZhbHVlOiAvLyBTZXQgZGF0YSAob3ZlcndyaXRlIHRoZSB3aG9sZSBkYXRhc2V0KVxuICAgIGZ1bmN0aW9uIHNldChkYXRhLCBleGVjKSB7XG4gICAgICBpZiAoZXhlYyA9PT0gdm9pZCAwKSB7XG4gICAgICAgIGV4ZWMgPSB0cnVlO1xuICAgICAgfVxuXG4gICAgICB0aGlzLmRjLnd3Lmp1c3QoJ2RhdGFzZXQtb3AnLCB7XG4gICAgICAgIGlkOiB0aGlzLmlkLFxuICAgICAgICB0eXBlOiAnc2V0JyxcbiAgICAgICAgZGF0YTogZGF0YSxcbiAgICAgICAgZXhlYzogZXhlY1xuICAgICAgfSk7XG4gICAgfSAvLyBVcGRhdGUgd2l0aCBuZXcgZGF0YSAoYXJyYXkgb2YgZGF0YSBwb2ludHMpXG5cbiAgfSwge1xuICAgIGtleTogXCJ1cGRhdGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdXBkYXRlKGFycikge1xuICAgICAgdGhpcy5kYy53dy5qdXN0KCd1cGRhdGUtZGF0YScsIF9kZWZpbmVQcm9wZXJ0eSh7fSwgdGhpcy5pZCwgYXJyKSk7XG4gICAgfSAvLyBTZW5kIFdXIGEgY2h1bmsgdG8gbWVyZ2UuIFRoZSBtZXJnZSBhbGdvXG4gICAgLy8gaGVyZSBpcyBzaW1wbGVyIHRoYW4gaW4gREMuIEl0IGp1c3QgYWRkc1xuICAgIC8vIGRhdGEgYXQgdGhlIGJlZ2lubmluZyBvci9hbmQgdGhlIGVuZCBvZiBkc1xuXG4gIH0sIHtcbiAgICBrZXk6IFwibWVyZ2VcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gbWVyZ2UoZGF0YSwgZXhlYykge1xuICAgICAgaWYgKGV4ZWMgPT09IHZvaWQgMCkge1xuICAgICAgICBleGVjID0gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5kYy53dy5qdXN0KCdkYXRhc2V0LW9wJywge1xuICAgICAgICBpZDogdGhpcy5pZCxcbiAgICAgICAgdHlwZTogJ21yZycsXG4gICAgICAgIGRhdGE6IGRhdGEsXG4gICAgICAgIGV4ZWM6IGV4ZWNcbiAgICAgIH0pO1xuICAgIH0gLy8gUmVtb3ZlIHRoZSBkcyBmcm9tIFdXXG5cbiAgfSwge1xuICAgIGtleTogXCJyZW1vdmVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVtb3ZlKGV4ZWMpIHtcbiAgICAgIGlmIChleGVjID09PSB2b2lkIDApIHtcbiAgICAgICAgZXhlYyA9IHRydWU7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuZGMuZGVsKFwiZGF0YXNldHMuXCIuY29uY2F0KHRoaXMuaWQpKTtcbiAgICAgIHRoaXMuZGMud3cuanVzdCgnZGF0YXNldC1vcCcsIHtcbiAgICAgICAgaWQ6IHRoaXMuaWQsXG4gICAgICAgIHR5cGU6ICdkZWwnLFxuICAgICAgICBleGVjOiBleGVjXG4gICAgICB9KTtcbiAgICAgIGRlbGV0ZSB0aGlzLmRjLmRzc1t0aGlzLmlkXTtcbiAgICB9IC8vIEZldGNoIGRhdGEgZnJvbSBXV1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiZGF0YVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgX2RhdGEgPSBfYXN5bmNUb0dlbmVyYXRvciggLyojX19QVVJFX18qL3JlZ2VuZXJhdG9yX2RlZmF1bHQoKS5tYXJrKGZ1bmN0aW9uIF9jYWxsZWUoKSB7XG4gICAgICAgIHZhciBkcztcbiAgICAgICAgcmV0dXJuIHJlZ2VuZXJhdG9yX2RlZmF1bHQoKS53cmFwKGZ1bmN0aW9uIF9jYWxsZWUkKF9jb250ZXh0KSB7XG4gICAgICAgICAgd2hpbGUgKDEpIHtcbiAgICAgICAgICAgIHN3aXRjaCAoX2NvbnRleHQucHJldiA9IF9jb250ZXh0Lm5leHQpIHtcbiAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgIF9jb250ZXh0Lm5leHQgPSAyO1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmRjLnd3LmV4ZWMoJ2dldC1kYXRhc2V0JywgdGhpcy5pZCk7XG5cbiAgICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgIGRzID0gX2NvbnRleHQuc2VudDtcblxuICAgICAgICAgICAgICAgIGlmIChkcykge1xuICAgICAgICAgICAgICAgICAgX2NvbnRleHQubmV4dCA9IDU7XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQuYWJydXB0KFwicmV0dXJuXCIpO1xuXG4gICAgICAgICAgICAgIGNhc2UgNTpcbiAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQuYWJydXB0KFwicmV0dXJuXCIsIGRzLmRhdGEpO1xuXG4gICAgICAgICAgICAgIGNhc2UgNjpcbiAgICAgICAgICAgICAgY2FzZSBcImVuZFwiOlxuICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dC5zdG9wKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9LCBfY2FsbGVlLCB0aGlzKTtcbiAgICAgIH0pKTtcblxuICAgICAgZnVuY3Rpb24gZGF0YSgpIHtcbiAgICAgICAgcmV0dXJuIF9kYXRhLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBkYXRhO1xuICAgIH0oKVxuICB9XSwgW3tcbiAgICBrZXk6IFwid2F0Y2hlclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB3YXRjaGVyKG4sIHApIHtcbiAgICAgIHZhciBuaWRzID0gbi5tYXAoZnVuY3Rpb24gKHgpIHtcbiAgICAgICAgcmV0dXJuIHguaWQ7XG4gICAgICB9KTtcbiAgICAgIHZhciBwaWRzID0gcC5tYXAoZnVuY3Rpb24gKHgpIHtcbiAgICAgICAgcmV0dXJuIHguaWQ7XG4gICAgICB9KTtcblxuICAgICAgdmFyIF9pdGVyYXRvciA9IGRhdGFzZXRfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlcihuaWRzKSxcbiAgICAgICAgICBfc3RlcDtcblxuICAgICAgdHJ5IHtcbiAgICAgICAgZm9yIChfaXRlcmF0b3IucygpOyAhKF9zdGVwID0gX2l0ZXJhdG9yLm4oKSkuZG9uZTspIHtcbiAgICAgICAgICB2YXIgaWQgPSBfc3RlcC52YWx1ZTtcblxuICAgICAgICAgIGlmICghcGlkcy5pbmNsdWRlcyhpZCkpIHtcbiAgICAgICAgICAgIHZhciBkcyA9IG4uZmlsdGVyKGZ1bmN0aW9uICh4KSB7XG4gICAgICAgICAgICAgIHJldHVybiB4LmlkID09PSBpZDtcbiAgICAgICAgICAgIH0pWzBdO1xuICAgICAgICAgICAgdGhpcy5kc3NbaWRdID0gbmV3IERhdGFzZXQodGhpcywgZHMpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIF9pdGVyYXRvci5lKGVycik7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICBfaXRlcmF0b3IuZigpO1xuICAgICAgfVxuXG4gICAgICB2YXIgX2l0ZXJhdG9yMiA9IGRhdGFzZXRfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlcihwaWRzKSxcbiAgICAgICAgICBfc3RlcDI7XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIGZvciAoX2l0ZXJhdG9yMi5zKCk7ICEoX3N0ZXAyID0gX2l0ZXJhdG9yMi5uKCkpLmRvbmU7KSB7XG4gICAgICAgICAgdmFyIGlkID0gX3N0ZXAyLnZhbHVlO1xuXG4gICAgICAgICAgaWYgKCFuaWRzLmluY2x1ZGVzKGlkKSAmJiB0aGlzLmRzc1tpZF0pIHtcbiAgICAgICAgICAgIHRoaXMuZHNzW2lkXS5yZW1vdmUoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICBfaXRlcmF0b3IyLmUoZXJyKTtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIF9pdGVyYXRvcjIuZigpO1xuICAgICAgfVxuICAgIH0gLy8gTWFrZSBhbiBvYmplY3QgZm9yIGRhdGEgdHJhbnNmZXJcblxuICB9LCB7XG4gICAga2V5OiBcIm1ha2VfdHhcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gbWFrZV90eChkYywgdHlwZXMpIHtcbiAgICAgIHZhciBtYWluID0gZGMuZGF0YS5jaGFydC5kYXRhO1xuICAgICAgdmFyIGJhc2UgPSB7fTtcblxuICAgICAgaWYgKHR5cGVzLmZpbmQoZnVuY3Rpb24gKHgpIHtcbiAgICAgICAgcmV0dXJuIHgudHlwZSA9PT0gJ09ITENWJztcbiAgICAgIH0pKSB7XG4gICAgICAgIGJhc2UgPSB7XG4gICAgICAgICAgb2hsY3Y6IG1haW5cbiAgICAgICAgfTtcbiAgICAgIH0gLy8gVE9ETzogYWRkIG1vcmUgc29waGlzdGljYXRlZCBzZWFyY2hcbiAgICAgIC8vICh1c2luZyAnc2NyaXB0LmRhdGFzZXRzJyBwYXJhbWVydGVyKVxuXG4gICAgICAvKmZvciAodmFyIHJlcSBvZiB0eXBlcykge1xuICAgICAgICAgIGxldCBkcyA9IE9iamVjdC52YWx1ZXMoZGMuZHNzIHx8IHt9KVxuICAgICAgICAgICAgICAuZmluZCh4ID0+IHgudHlwZSA9PT0gcmVxLnR5cGUpXG4gICAgICAgICAgaWYgKGRzICYmIGRzLmRhdGEpIHtcbiAgICAgICAgICAgICAgYmFzZVtkcy5pZF0gPSB7XG4gICAgICAgICAgICAgICAgICBpZDogZHMuaWQsXG4gICAgICAgICAgICAgICAgICB0eXBlOiBkcy50eXBlLFxuICAgICAgICAgICAgICAgICAgZGF0YTogZHMuZGF0YVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgfSovXG4gICAgICAvLyBUT0RPOiBEYXRhIHJlcXVlc3QgY2FsbGJhY2sgP1xuXG5cbiAgICAgIHJldHVybiBiYXNlO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBEYXRhc2V0O1xufSgpOyAvLyBEYXRhc2V0IHJlY2lldmVyIChjcmVhdGVkIG9uIFdXKVxuXG5cblxudmFyIERhdGFzZXRXVyA9IC8qI19fUFVSRV9fKi8oLyogdW51c2VkIHB1cmUgZXhwcmVzc2lvbiBvciBzdXBlciAqLyBudWxsICYmIChmdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIERhdGFzZXRXVyhpZCwgZGF0YSkge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBEYXRhc2V0V1cpO1xuXG4gICAgdGhpcy5sYXN0X3VwZCA9IG5vdygpO1xuICAgIHRoaXMuaWQgPSBpZDtcblxuICAgIGlmIChBcnJheS5pc0FycmF5KGRhdGEpKSB7XG4gICAgICAvLyBSZWd1bGFyIGFycmF5XG4gICAgICB0aGlzLmRhdGEgPSBkYXRhO1xuICAgICAgaWYgKGlkID09PSAnb2hsY3YnKSB0aGlzLnR5cGUgPSAnT0hMQ1YnO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBEYXRhc2V0IGRlc2NyaXB0b3JcbiAgICAgIHRoaXMuZGF0YSA9IGRhdGEuZGF0YTtcbiAgICAgIHRoaXMudHlwZSA9IGRhdGEudHlwZTtcbiAgICB9XG4gIH0gLy8gVXBkYXRlIGZyb20gJ3VwZGF0ZS1kYXRhJyBldmVudFxuICAvLyBUT0RPOiBkcyBzaXplIGxpbWl0IChpbiBNQiAvIGRhdGEgcG9pbnRzKVxuXG5cbiAgX2NyZWF0ZUNsYXNzKERhdGFzZXRXVywgW3tcbiAgICBrZXk6IFwibWVyZ2VcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gbWVyZ2UoZGF0YSkge1xuICAgICAgdmFyIGxlbiA9IHRoaXMuZGF0YS5sZW5ndGg7XG5cbiAgICAgIGlmICghbGVuKSB7XG4gICAgICAgIHRoaXMuZGF0YSA9IGRhdGE7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdmFyIHQwID0gdGhpcy5kYXRhWzBdWzBdO1xuICAgICAgdmFyIHROID0gdGhpcy5kYXRhW2xlbiAtIDFdWzBdO1xuICAgICAgdmFyIGwgPSBkYXRhLmZpbHRlcihmdW5jdGlvbiAoeCkge1xuICAgICAgICByZXR1cm4geFswXSA8IHQwO1xuICAgICAgfSk7XG4gICAgICB2YXIgciA9IGRhdGEuZmlsdGVyKGZ1bmN0aW9uICh4KSB7XG4gICAgICAgIHJldHVybiB4WzBdID4gdE47XG4gICAgICB9KTtcbiAgICAgIHRoaXMuZGF0YSA9IGwuY29uY2F0KHRoaXMuZGF0YSwgcik7XG4gICAgfSAvLyBPbiBkYXRhc2V0IG9wZXJhdGlvblxuXG4gIH0sIHtcbiAgICBrZXk6IFwib3BcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gb3Aoc2UsIF9vcCkge1xuICAgICAgdGhpcy5sYXN0X3VwZCA9IG5vdygpO1xuXG4gICAgICBzd2l0Y2ggKF9vcC50eXBlKSB7XG4gICAgICAgIGNhc2UgJ3NldCc6XG4gICAgICAgICAgdGhpcy5kYXRhID0gX29wLmRhdGE7XG4gICAgICAgICAgc2UucmVjYWxjX3NpemUoKTtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlICdkZWwnOlxuICAgICAgICAgIGRlbGV0ZSBzZS5kYXRhW3RoaXMuaWRdO1xuICAgICAgICAgIHNlLnJlY2FsY19zaXplKCk7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSAnbXJnJzpcbiAgICAgICAgICB0aGlzLm1lcmdlKF9vcC5kYXRhKTtcbiAgICAgICAgICBzZS5yZWNhbGNfc2l6ZSgpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgfV0sIFt7XG4gICAga2V5OiBcInVwZGF0ZV9hbGxcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdXBkYXRlX2FsbChzZSwgZGF0YSkge1xuICAgICAgZm9yICh2YXIgayBpbiBkYXRhKSB7XG4gICAgICAgIGlmIChrID09PSAnb2hsY3YnKSBjb250aW51ZTtcbiAgICAgICAgdmFyIGlkID0gay5zcGxpdCgnLicpWzFdIHx8IGs7XG4gICAgICAgIGlmICghc2UuZGF0YVtpZF0pIGNvbnRpbnVlO1xuICAgICAgICB2YXIgYXJyID0gc2UuZGF0YVtpZF0uZGF0YTtcbiAgICAgICAgdmFyIGlOID0gYXJyLmxlbmd0aCAtIDE7XG4gICAgICAgIHZhciBsYXN0ID0gYXJyW2lOXTtcblxuICAgICAgICB2YXIgX2l0ZXJhdG9yMyA9IGRhdGFzZXRfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlcihkYXRhW2tdKSxcbiAgICAgICAgICAgIF9zdGVwMztcblxuICAgICAgICB0cnkge1xuICAgICAgICAgIGZvciAoX2l0ZXJhdG9yMy5zKCk7ICEoX3N0ZXAzID0gX2l0ZXJhdG9yMy5uKCkpLmRvbmU7KSB7XG4gICAgICAgICAgICB2YXIgZHAgPSBfc3RlcDMudmFsdWU7XG5cbiAgICAgICAgICAgIGlmICghbGFzdCB8fCBkcFswXSA+IGxhc3RbMF0pIHtcbiAgICAgICAgICAgICAgYXJyLnB1c2goZHApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgX2l0ZXJhdG9yMy5lKGVycik7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgX2l0ZXJhdG9yMy5mKCk7XG4gICAgICAgIH1cblxuICAgICAgICBzZS5kYXRhW2lkXS5sYXN0X3VwZCA9IG5vdygpO1xuICAgICAgfVxuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBEYXRhc2V0V1c7XG59KCkpKTtcbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9oZWxwZXJzL2RjX2V2ZW50cy5qc1xuXG5cblxuXG5cbmZ1bmN0aW9uIGRjX2V2ZW50c19jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyKG8sIGFsbG93QXJyYXlMaWtlKSB7IHZhciBpdDsgaWYgKHR5cGVvZiBTeW1ib2wgPT09IFwidW5kZWZpbmVkXCIgfHwgb1tTeW1ib2wuaXRlcmF0b3JdID09IG51bGwpIHsgaWYgKEFycmF5LmlzQXJyYXkobykgfHwgKGl0ID0gZGNfZXZlbnRzX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5KG8pKSB8fCBhbGxvd0FycmF5TGlrZSAmJiBvICYmIHR5cGVvZiBvLmxlbmd0aCA9PT0gXCJudW1iZXJcIikgeyBpZiAoaXQpIG8gPSBpdDsgdmFyIGkgPSAwOyB2YXIgRiA9IGZ1bmN0aW9uIEYoKSB7fTsgcmV0dXJuIHsgczogRiwgbjogZnVuY3Rpb24gbigpIHsgaWYgKGkgPj0gby5sZW5ndGgpIHJldHVybiB7IGRvbmU6IHRydWUgfTsgcmV0dXJuIHsgZG9uZTogZmFsc2UsIHZhbHVlOiBvW2krK10gfTsgfSwgZTogZnVuY3Rpb24gZShfZSkgeyB0aHJvdyBfZTsgfSwgZjogRiB9OyB9IHRocm93IG5ldyBUeXBlRXJyb3IoXCJJbnZhbGlkIGF0dGVtcHQgdG8gaXRlcmF0ZSBub24taXRlcmFibGUgaW5zdGFuY2UuXFxuSW4gb3JkZXIgdG8gYmUgaXRlcmFibGUsIG5vbi1hcnJheSBvYmplY3RzIG11c3QgaGF2ZSBhIFtTeW1ib2wuaXRlcmF0b3JdKCkgbWV0aG9kLlwiKTsgfSB2YXIgbm9ybWFsQ29tcGxldGlvbiA9IHRydWUsIGRpZEVyciA9IGZhbHNlLCBlcnI7IHJldHVybiB7IHM6IGZ1bmN0aW9uIHMoKSB7IGl0ID0gb1tTeW1ib2wuaXRlcmF0b3JdKCk7IH0sIG46IGZ1bmN0aW9uIG4oKSB7IHZhciBzdGVwID0gaXQubmV4dCgpOyBub3JtYWxDb21wbGV0aW9uID0gc3RlcC5kb25lOyByZXR1cm4gc3RlcDsgfSwgZTogZnVuY3Rpb24gZShfZTIpIHsgZGlkRXJyID0gdHJ1ZTsgZXJyID0gX2UyOyB9LCBmOiBmdW5jdGlvbiBmKCkgeyB0cnkgeyBpZiAoIW5vcm1hbENvbXBsZXRpb24gJiYgaXRbXCJyZXR1cm5cIl0gIT0gbnVsbCkgaXRbXCJyZXR1cm5cIl0oKTsgfSBmaW5hbGx5IHsgaWYgKGRpZEVycikgdGhyb3cgZXJyOyB9IH0gfTsgfVxuXG5mdW5jdGlvbiBkY19ldmVudHNfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkobywgbWluTGVuKSB7IGlmICghbykgcmV0dXJuOyBpZiAodHlwZW9mIG8gPT09IFwic3RyaW5nXCIpIHJldHVybiBkY19ldmVudHNfYXJyYXlMaWtlVG9BcnJheShvLCBtaW5MZW4pOyB2YXIgbiA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvKS5zbGljZSg4LCAtMSk7IGlmIChuID09PSBcIk9iamVjdFwiICYmIG8uY29uc3RydWN0b3IpIG4gPSBvLmNvbnN0cnVjdG9yLm5hbWU7IGlmIChuID09PSBcIk1hcFwiIHx8IG4gPT09IFwiU2V0XCIpIHJldHVybiBBcnJheS5mcm9tKG8pOyBpZiAobiA9PT0gXCJBcmd1bWVudHNcIiB8fCAvXig/OlVpfEkpbnQoPzo4fDE2fDMyKSg/OkNsYW1wZWQpP0FycmF5JC8udGVzdChuKSkgcmV0dXJuIGRjX2V2ZW50c19hcnJheUxpa2VUb0FycmF5KG8sIG1pbkxlbik7IH1cblxuZnVuY3Rpb24gZGNfZXZlbnRzX2FycmF5TGlrZVRvQXJyYXkoYXJyLCBsZW4pIHsgaWYgKGxlbiA9PSBudWxsIHx8IGxlbiA+IGFyci5sZW5ndGgpIGxlbiA9IGFyci5sZW5ndGg7IGZvciAodmFyIGkgPSAwLCBhcnIyID0gbmV3IEFycmF5KGxlbik7IGkgPCBsZW47IGkrKykgeyBhcnIyW2ldID0gYXJyW2ldOyB9IHJldHVybiBhcnIyOyB9XG5cbi8vIERhdGFDdWJlIGV2ZW50IGhhbmRsZXJzXG5cblxuXG5cblxudmFyIERDRXZlbnRzID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gRENFdmVudHMoKSB7XG4gICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgIGNsYXNzQ2FsbENoZWNrX2NsYXNzQ2FsbENoZWNrKHRoaXMsIERDRXZlbnRzKTtcblxuICAgIHRoaXMud3cgPSBuZXcgc2NyaXB0X3d3X2FwaSh0aGlzKTsgLy8gTGlzdGVuIHRvIHRoZSB3ZWItd29ya2VyIGV2ZW50c1xuXG4gICAgdGhpcy53dy5vbmV2ZW50ID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgIHZhciBfaXRlcmF0b3IgPSBkY19ldmVudHNfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlcihfdGhpcy50di5jb250cm9sbGVycyksXG4gICAgICAgICAgX3N0ZXA7XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIGZvciAoX2l0ZXJhdG9yLnMoKTsgIShfc3RlcCA9IF9pdGVyYXRvci5uKCkpLmRvbmU7KSB7XG4gICAgICAgICAgdmFyIGN0cmwgPSBfc3RlcC52YWx1ZTtcbiAgICAgICAgICBpZiAoY3RybC53dykgY3RybC53dyhlLmRhdGEpO1xuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgX2l0ZXJhdG9yLmUoZXJyKTtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIF9pdGVyYXRvci5mKCk7XG4gICAgICB9XG5cbiAgICAgIHN3aXRjaCAoZS5kYXRhLnR5cGUpIHtcbiAgICAgICAgY2FzZSAncmVxdWVzdC1kYXRhJzpcbiAgICAgICAgICAvLyBUT0RPOiBEYXRhVHVubmVsIGNsYXNzIGZvciBzbWFydGVyIGRhdGEgdHJhbnNmZXJcbiAgICAgICAgICBpZiAoX3RoaXMud3cuX2RhdGFfdXBsb2FkaW5nKSBicmVhaztcbiAgICAgICAgICB2YXIgZGF0YSA9IERhdGFzZXQubWFrZV90eChfdGhpcywgZS5kYXRhLmRhdGEpO1xuXG4gICAgICAgICAgX3RoaXMuc2VuZF9tZXRhXzJfd3coKTtcblxuICAgICAgICAgIF90aGlzLnd3Lmp1c3QoJ3VwbG9hZC1kYXRhJywgZGF0YSk7XG5cbiAgICAgICAgICBfdGhpcy53dy5fZGF0YV91cGxvYWRpbmcgPSB0cnVlO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgJ292ZXJsYXktZGF0YSc6XG4gICAgICAgICAgX3RoaXMub25fb3ZlcmxheV9kYXRhKGUuZGF0YS5kYXRhKTtcblxuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgJ292ZXJsYXktdXBkYXRlJzpcbiAgICAgICAgICBfdGhpcy5vbl9vdmVybGF5X3VwZGF0ZShlLmRhdGEuZGF0YSk7XG5cbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlICdkYXRhLXVwbG9hZGVkJzpcbiAgICAgICAgICBfdGhpcy53dy5fZGF0YV91cGxvYWRpbmcgPSBmYWxzZTtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlICdlbmdpbmUtc3RhdGUnOlxuICAgICAgICAgIF90aGlzLnNlX3N0YXRlID0gT2JqZWN0LmFzc2lnbihfdGhpcy5zZV9zdGF0ZSB8fCB7fSwgZS5kYXRhLmRhdGEpO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgJ21vZGlmeS1vdmVybGF5JzpcbiAgICAgICAgICBfdGhpcy5tb2RpZnlfb3ZlcmxheShlLmRhdGEuZGF0YSk7XG5cbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlICdzY3JpcHQtc2lnbmFsJzpcbiAgICAgICAgICBfdGhpcy50di4kZW1pdCgnc2lnbmFsJywgZS5kYXRhLmRhdGEpO1xuXG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICAgIHZhciBfaXRlcmF0b3IyID0gZGNfZXZlbnRzX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXIoX3RoaXMudHYuY29udHJvbGxlcnMpLFxuICAgICAgICAgIF9zdGVwMjtcblxuICAgICAgdHJ5IHtcbiAgICAgICAgZm9yIChfaXRlcmF0b3IyLnMoKTsgIShfc3RlcDIgPSBfaXRlcmF0b3IyLm4oKSkuZG9uZTspIHtcbiAgICAgICAgICB2YXIgY3RybCA9IF9zdGVwMi52YWx1ZTtcbiAgICAgICAgICBpZiAoY3RybC5wb3N0X3d3KSBjdHJsLnBvc3Rfd3coZS5kYXRhKTtcbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIF9pdGVyYXRvcjIuZShlcnIpO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgX2l0ZXJhdG9yMi5mKCk7XG4gICAgICB9XG4gICAgfTtcbiAgfSAvLyBDYWxsZWQgd2hlbiBvdmVyYWxheS90diBlbWl0cyAnY3VzdG9tLWV2ZW50J1xuXG5cbiAgY3JlYXRlQ2xhc3NfY3JlYXRlQ2xhc3MoRENFdmVudHMsIFt7XG4gICAga2V5OiBcIm9uX2N1c3RvbV9ldmVudFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBvbl9jdXN0b21fZXZlbnQoZXZlbnQsIGFyZ3MpIHtcbiAgICAgIHN3aXRjaCAoZXZlbnQpIHtcbiAgICAgICAgY2FzZSAncmVnaXN0ZXItdG9vbHMnOlxuICAgICAgICAgIHRoaXMucmVnaXN0ZXJfdG9vbHMoYXJncyk7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSAnZXhlYy1zY3JpcHQnOlxuICAgICAgICAgIHRoaXMuZXhlY19zY3JpcHQoYXJncyk7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSAnZXhlYy1hbGwtc2NyaXB0cyc6XG4gICAgICAgICAgdGhpcy5leGVjX2FsbF9zY3JpcHRzKCk7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSAnZGF0YS1sZW4tY2hhbmdlZCc6XG4gICAgICAgICAgdGhpcy5kYXRhX2NoYW5nZWQoYXJncyk7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSAndG9vbC1zZWxlY3RlZCc6XG4gICAgICAgICAgaWYgKCFhcmdzWzBdKSBicmVhazsgLy8gVE9ETzogUXVpY2sgZml4LCBpbnZlc3RpZ2F0ZVxuXG4gICAgICAgICAgaWYgKGFyZ3NbMF0uc3BsaXQoJzonKVswXSA9PT0gJ1N5c3RlbScpIHtcbiAgICAgICAgICAgIHRoaXMuc3lzdGVtX3Rvb2woYXJnc1swXS5zcGxpdCgnOicpWzFdKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHRoaXMudHYuJHNldCh0aGlzLmRhdGEsICd0b29sJywgYXJnc1swXSk7XG5cbiAgICAgICAgICBpZiAoYXJnc1swXSA9PT0gJ0N1cnNvcicpIHtcbiAgICAgICAgICAgIHRoaXMuZHJhd2luZ19tb2RlX29mZigpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgJ2dyaWQtbW91c2Vkb3duJzpcbiAgICAgICAgICB0aGlzLmdyaWRfbW91c2Vkb3duKGFyZ3MpO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgJ2RyYXdpbmctbW9kZS1vZmYnOlxuICAgICAgICAgIHRoaXMuZHJhd2luZ19tb2RlX29mZigpO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgJ2NoYW5nZS1zZXR0aW5ncyc6XG4gICAgICAgICAgdGhpcy5jaGFuZ2Vfc2V0dGluZ3MoYXJncyk7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSAncmFuZ2UtY2hhbmdlZCc6XG4gICAgICAgICAgdGhpcy5zY3JpcHRzX29ucmFuZ2UuYXBwbHkodGhpcywgX3RvQ29uc3VtYWJsZUFycmF5KGFyZ3MpKTtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlICdzY3JvbGwtbG9jayc6XG4gICAgICAgICAgdGhpcy5vbl9zY3JvbGxfbG9jayhhcmdzWzBdKTtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlICdvYmplY3Qtc2VsZWN0ZWQnOlxuICAgICAgICAgIHRoaXMub2JqZWN0X3NlbGVjdGVkKGFyZ3MpO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgJ3JlbW92ZS10b29sJzpcbiAgICAgICAgICB0aGlzLnN5c3RlbV90b29sKCdSZW1vdmUnKTtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlICdiZWZvcmUtZGVzdHJveSc6XG4gICAgICAgICAgdGhpcy5iZWZvcmVfZGVzdHJveSgpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH0gLy8gVHJpZ2dlcmVkIHdoZW4gb25lIG9yIG11bHRpcGxlIHNldHRpbmdzIGFyZSBjaGFuZ2VkXG4gICAgLy8gV2Ugc2VsZWN0IG9ubHkgdGhlIGNoYW5nZWQgb25lcyAmIHJlLWV4ZWMgdGhlbSBvbiB0aGVcbiAgICAvLyB3ZWIgd29ya2VyXG5cbiAgfSwge1xuICAgIGtleTogXCJvbl9zZXR0aW5nc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBvbl9zZXR0aW5ncyh2YWx1ZXMsIHByZXYpIHtcbiAgICAgIHZhciBfdGhpczIgPSB0aGlzO1xuXG4gICAgICBpZiAoIXRoaXMuc2V0dC5zY3JpcHRzKSByZXR1cm47XG4gICAgICB2YXIgZGVsdGEgPSB7fTtcbiAgICAgIHZhciBjaGFuZ2VkID0gZmFsc2U7XG5cbiAgICAgIHZhciBfbG9vcCA9IGZ1bmN0aW9uIF9sb29wKCkge1xuICAgICAgICB2YXIgbiA9IHZhbHVlc1tpXTtcbiAgICAgICAgdmFyIGFyciA9IHByZXYuZmlsdGVyKGZ1bmN0aW9uICh4KSB7XG4gICAgICAgICAgcmV0dXJuIHgudiA9PT0gbi52O1xuICAgICAgICB9KTtcblxuICAgICAgICBpZiAoIWFyci5sZW5ndGggJiYgbi5wLnNldHRpbmdzLiRwcm9wcykge1xuICAgICAgICAgIHZhciBpZCA9IG4ucC5zZXR0aW5ncy4kdXVpZDtcblxuICAgICAgICAgIGlmICh1dGlscy5pc19zY3JfcHJvcHNfdXBkKG4sIHByZXYpICYmIHV0aWxzLmRlbGF5ZWRfZXhlYyhuLnApKSB7XG4gICAgICAgICAgICBkZWx0YVtpZF0gPSBuLnY7XG4gICAgICAgICAgICBjaGFuZ2VkID0gdHJ1ZTtcblxuICAgICAgICAgICAgX3RoaXMyLnR2LiRzZXQobi5wLCAnbG9hZGluZycsIHRydWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB2YWx1ZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgX2xvb3AoKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGNoYW5nZWQgJiYgT2JqZWN0LmtleXMoZGVsdGEpLmxlbmd0aCkge1xuICAgICAgICB2YXIgdGYgPSB0aGlzLnR2LiRyZWZzLmNoYXJ0LmludGVydmFsX21zIHx8IHRoaXMuZGF0YS5jaGFydC50ZjtcbiAgICAgICAgdmFyIHJhbmdlID0gdGhpcy50di5nZXRSYW5nZSgpO1xuICAgICAgICB0aGlzLnd3Lmp1c3QoJ3VwZGF0ZS1vdi1zZXR0aW5ncycsIHtcbiAgICAgICAgICBkZWx0YTogZGVsdGEsXG4gICAgICAgICAgdGY6IHRmLFxuICAgICAgICAgIHJhbmdlOiByYW5nZVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9IC8vIFdoZW4gdGhlIHNldCBvZiAkdXVpZHMgaXMgY2hhbmdlZFxuXG4gIH0sIHtcbiAgICBrZXk6IFwib25faWRzX2NoYW5nZWRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gb25faWRzX2NoYW5nZWQodmFsdWVzLCBwcmV2KSB7XG4gICAgICB2YXIgcmVtID0gcHJldi5maWx0ZXIoZnVuY3Rpb24gKHgpIHtcbiAgICAgICAgcmV0dXJuIHggIT09IHVuZGVmaW5lZCAmJiAhdmFsdWVzLmluY2x1ZGVzKHgpO1xuICAgICAgfSk7XG5cbiAgICAgIGlmIChyZW0ubGVuZ3RoKSB7XG4gICAgICAgIHRoaXMud3cuanVzdCgncmVtb3ZlLXNjcmlwdHMnLCByZW0pO1xuICAgICAgfVxuICAgIH0gLy8gQ29tYmluZSBhbGwgdG9vbHMgYW5kIHRoZWlyIG1vZHNcblxuICB9LCB7XG4gICAga2V5OiBcInJlZ2lzdGVyX3Rvb2xzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJlZ2lzdGVyX3Rvb2xzKHRvb2xzKSB7XG4gICAgICB2YXIgcHJlc2V0ID0ge307XG5cbiAgICAgIHZhciBfaXRlcmF0b3IzID0gZGNfZXZlbnRzX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXIodGhpcy5kYXRhLnRvb2xzIHx8IFtdKSxcbiAgICAgICAgICBfc3RlcDM7XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIGZvciAoX2l0ZXJhdG9yMy5zKCk7ICEoX3N0ZXAzID0gX2l0ZXJhdG9yMy5uKCkpLmRvbmU7KSB7XG4gICAgICAgICAgdmFyIHRvb2wgPSBfc3RlcDMudmFsdWU7XG4gICAgICAgICAgcHJlc2V0W3Rvb2wudHlwZV0gPSB0b29sO1xuICAgICAgICAgIGRlbGV0ZSB0b29sLnR5cGU7XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICBfaXRlcmF0b3IzLmUoZXJyKTtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIF9pdGVyYXRvcjMuZigpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLnR2LiRzZXQodGhpcy5kYXRhLCAndG9vbHMnLCBbXSk7XG4gICAgICB2YXIgbGlzdCA9IFt7XG4gICAgICAgIHR5cGU6ICdDdXJzb3InLFxuICAgICAgICBpY29uOiBpY29uc19uYW1lc3BhY2VPYmplY3RbXCJjdXJzb3IucG5nXCJdXG4gICAgICB9XTtcblxuICAgICAgdmFyIF9pdGVyYXRvcjQgPSBkY19ldmVudHNfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlcih0b29scyksXG4gICAgICAgICAgX3N0ZXA0O1xuXG4gICAgICB0cnkge1xuICAgICAgICBmb3IgKF9pdGVyYXRvcjQucygpOyAhKF9zdGVwNCA9IF9pdGVyYXRvcjQubigpKS5kb25lOykge1xuICAgICAgICAgIHZhciB0b29sID0gX3N0ZXA0LnZhbHVlO1xuICAgICAgICAgIHZhciBwcm90byA9IE9iamVjdC5hc3NpZ24oe30sIHRvb2wuaW5mbyk7XG4gICAgICAgICAgdmFyIHR5cGUgPSB0b29sLmluZm8udHlwZSB8fCAnRGVmYXVsdCc7XG4gICAgICAgICAgcHJvdG8udHlwZSA9IFwiXCIuY29uY2F0KHRvb2wudXNlX2ZvciwgXCI6XCIpLmNvbmNhdCh0eXBlKTtcbiAgICAgICAgICB0aGlzLm1lcmdlX3ByZXNldHMocHJvdG8sIHByZXNldFt0b29sLnVzZV9mb3JdKTtcbiAgICAgICAgICB0aGlzLm1lcmdlX3ByZXNldHMocHJvdG8sIHByZXNldFtwcm90by50eXBlXSk7XG4gICAgICAgICAgZGVsZXRlIHByb3RvLm1vZHM7XG4gICAgICAgICAgbGlzdC5wdXNoKHByb3RvKTtcblxuICAgICAgICAgIGZvciAodmFyIG1vZCBpbiB0b29sLmluZm8ubW9kcykge1xuICAgICAgICAgICAgdmFyIG1wID0gT2JqZWN0LmFzc2lnbih7fSwgcHJvdG8pO1xuICAgICAgICAgICAgbXAgPSBPYmplY3QuYXNzaWduKG1wLCB0b29sLmluZm8ubW9kc1ttb2RdKTtcbiAgICAgICAgICAgIG1wLnR5cGUgPSBcIlwiLmNvbmNhdCh0b29sLnVzZV9mb3IsIFwiOlwiKS5jb25jYXQobW9kKTtcbiAgICAgICAgICAgIHRoaXMubWVyZ2VfcHJlc2V0cyhtcCwgcHJlc2V0W3Rvb2wudXNlX2Zvcl0pO1xuICAgICAgICAgICAgdGhpcy5tZXJnZV9wcmVzZXRzKG1wLCBwcmVzZXRbbXAudHlwZV0pO1xuICAgICAgICAgICAgbGlzdC5wdXNoKG1wKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICBfaXRlcmF0b3I0LmUoZXJyKTtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIF9pdGVyYXRvcjQuZigpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLnR2LiRzZXQodGhpcy5kYXRhLCAndG9vbHMnLCBsaXN0KTtcbiAgICAgIHRoaXMudHYuJHNldCh0aGlzLmRhdGEsICd0b29sJywgJ0N1cnNvcicpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJleGVjX3NjcmlwdFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBleGVjX3NjcmlwdChhcmdzKSB7XG4gICAgICBpZiAoYXJncy5sZW5ndGggJiYgdGhpcy5zZXR0LnNjcmlwdHMpIHtcbiAgICAgICAgdmFyIG9iaiA9IHRoaXMuZ2V0X292ZXJsYXkoYXJnc1swXSk7XG4gICAgICAgIGlmICghb2JqIHx8IG9iai5zY3JpcHRzID09PSBmYWxzZSkgcmV0dXJuO1xuXG4gICAgICAgIGlmIChvYmouc2NyaXB0ICYmIG9iai5zY3JpcHQuc3JjKSB7XG4gICAgICAgICAgYXJnc1swXS5zcmMgPSBvYmouc2NyaXB0LnNyYzsgLy8gb3B0LCBvdmVycmlkZSB0aGUgc3JjXG4gICAgICAgIH0gLy8gUGFyc2Ugc2NyaXB0IHByb3BzICYgZ2V0IHRoZSB2YWx1ZXMgZnJvbSB0aGUgb3ZcbiAgICAgICAgLy8gVE9ETzogcmVtb3ZlIHVubmVjZXNzYXJ5IHNjcmlwdCBpbml0aWFsaXphdGlvbnNcblxuXG4gICAgICAgIHZhciBzID0gb2JqLnNldHRpbmdzO1xuICAgICAgICB2YXIgcHJvcHMgPSBhcmdzWzBdLnNyYy5wcm9wcyB8fCB7fTtcbiAgICAgICAgaWYgKCFzLiR1dWlkKSBzLiR1dWlkID0gXCJcIi5jb25jYXQob2JqLnR5cGUsIFwiLVwiKS5jb25jYXQodXRpbHMudXVpZDIoKSk7XG4gICAgICAgIGFyZ3NbMF0udXVpZCA9IHMuJHV1aWQ7XG4gICAgICAgIGFyZ3NbMF0uc2V0dCA9IHM7XG5cbiAgICAgICAgZm9yICh2YXIgayBpbiBwcm9wcyB8fCB7fSkge1xuICAgICAgICAgIHZhciBwcm90byA9IHByb3BzW2tdO1xuXG4gICAgICAgICAgaWYgKHNba10gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcHJvdG8udmFsID0gc1trXTsgLy8gdXNlIHRoZSBleGlzdGluZyB2YWxcblxuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKHByb3RvLmRlZiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAvLyBUT0RPOiBhZGQgc3VwcG9ydCBvZiBpbmZvIC8gZXJyb3JzIHRvIHRoZSBsZWdlbmRcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXCJPdmVybGF5IFwiLmNvbmNhdChvYmouaWQsIFwiOiBzY3JpcHQgcHJvcCAnXCIpLmNvbmNhdChrLCBcIicgXCIpICsgXCJkb2Vzbid0IGhhdmUgYSBkZWZhdWx0IHZhbHVlXCIpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHNba10gPSBwcm90by52YWwgPSBwcm90by5kZWY7IC8vIHNldCB0aGUgZGVmYXVsdFxuICAgICAgICB9IC8vIFJlbW92ZSBvbGQgcHJvcHMgKGRyb3BwZWQgYnkgdGhlIGN1cnJlbnQgZXhlYylcblxuXG4gICAgICAgIGlmIChzLiRwcm9wcykge1xuICAgICAgICAgIGZvciAodmFyIGsgaW4gcykge1xuICAgICAgICAgICAgaWYgKHMuJHByb3BzLmluY2x1ZGVzKGspICYmICEoayBpbiBwcm9wcykpIHtcbiAgICAgICAgICAgICAgZGVsZXRlIHNba107XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcy4kcHJvcHMgPSBPYmplY3Qua2V5cyhhcmdzWzBdLnNyYy5wcm9wcyB8fCB7fSk7XG4gICAgICAgIHRoaXMudHYuJHNldChvYmosICdsb2FkaW5nJywgdHJ1ZSk7XG4gICAgICAgIHZhciB0ZiA9IHRoaXMudHYuJHJlZnMuY2hhcnQuaW50ZXJ2YWxfbXMgfHwgdGhpcy5kYXRhLmNoYXJ0LnRmO1xuICAgICAgICB2YXIgcmFuZ2UgPSB0aGlzLnR2LmdldFJhbmdlKCk7XG5cbiAgICAgICAgaWYgKG9iai5zY3JpcHQgJiYgb2JqLnNjcmlwdC5vdXRwdXQgIT0gbnVsbCkge1xuICAgICAgICAgIGFyZ3NbMF0ub3V0cHV0ID0gb2JqLnNjcmlwdC5vdXRwdXQ7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnd3Lmp1c3QoJ2V4ZWMtc2NyaXB0Jywge1xuICAgICAgICAgIHM6IGFyZ3NbMF0sXG4gICAgICAgICAgdGY6IHRmLFxuICAgICAgICAgIHJhbmdlOiByYW5nZVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZXhlY19hbGxfc2NyaXB0c1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBleGVjX2FsbF9zY3JpcHRzKCkge1xuICAgICAgaWYgKCF0aGlzLnNldHQuc2NyaXB0cykgcmV0dXJuO1xuICAgICAgdGhpcy5zZXRfbG9hZGluZyh0cnVlKTtcbiAgICAgIHZhciB0ZiA9IHRoaXMudHYuJHJlZnMuY2hhcnQuaW50ZXJ2YWxfbXMgfHwgdGhpcy5kYXRhLmNoYXJ0LnRmO1xuICAgICAgdmFyIHJhbmdlID0gdGhpcy50di5nZXRSYW5nZSgpO1xuICAgICAgdGhpcy53dy5qdXN0KCdleGVjLWFsbC1zY3JpcHRzJywge1xuICAgICAgICB0ZjogdGYsXG4gICAgICAgIHJhbmdlOiByYW5nZVxuICAgICAgfSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInNjcmlwdHNfb25yYW5nZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzY3JpcHRzX29ucmFuZ2Uocikge1xuICAgICAgaWYgKCF0aGlzLnNldHQuc2NyaXB0cykgcmV0dXJuO1xuICAgICAgdmFyIGRlbHRhID0ge307XG4gICAgICB0aGlzLmdldCgnLicpLmZvckVhY2goZnVuY3Rpb24gKHYpIHtcbiAgICAgICAgaWYgKHYuc2NyaXB0ICYmIHYuc2NyaXB0LmV4ZWNPblJhbmdlICYmIHYuc2V0dGluZ3MuJHV1aWQpIHtcbiAgICAgICAgICAvLyBUT0RPOiBleGVjSW50ZXJydXB0IGZsYWc/XG4gICAgICAgICAgaWYgKHV0aWxzLmRlbGF5ZWRfZXhlYyh2KSkge1xuICAgICAgICAgICAgZGVsdGFbdi5zZXR0aW5ncy4kdXVpZF0gPSB2LnNldHRpbmdzO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSk7XG5cbiAgICAgIGlmIChPYmplY3Qua2V5cyhkZWx0YSkubGVuZ3RoKSB7XG4gICAgICAgIHZhciB0ZiA9IHRoaXMudHYuJHJlZnMuY2hhcnQuaW50ZXJ2YWxfbXMgfHwgdGhpcy5kYXRhLmNoYXJ0LnRmO1xuICAgICAgICB2YXIgcmFuZ2UgPSB0aGlzLnR2LmdldFJhbmdlKCk7XG4gICAgICAgIHRoaXMud3cuanVzdCgndXBkYXRlLW92LXNldHRpbmdzJywge1xuICAgICAgICAgIGRlbHRhOiBkZWx0YSxcbiAgICAgICAgICB0ZjogdGYsXG4gICAgICAgICAgcmFuZ2U6IHJhbmdlXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0gLy8gT3ZlcmxheSBtb2RpZmljYXRpb24gZnJvbSBXV1xuXG4gIH0sIHtcbiAgICBrZXk6IFwibW9kaWZ5X292ZXJsYXlcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gbW9kaWZ5X292ZXJsYXkodXBkKSB7XG4gICAgICB2YXIgb2JqID0gdGhpcy5nZXRfb3ZlcmxheSh1cGQpO1xuXG4gICAgICBpZiAob2JqKSB7XG4gICAgICAgIGZvciAodmFyIGsgaW4gdXBkLmZpZWxkcyB8fCB7fSkge1xuICAgICAgICAgIGlmICh0eXBlb2ZfdHlwZW9mKG9ialtrXSkgPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICB0aGlzLm1lcmdlKFwiXCIuY29uY2F0KHVwZC51dWlkLCBcIi5cIikuY29uY2F0KGspLCB1cGQuZmllbGRzW2tdKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy50di4kc2V0KG9iaiwgaywgdXBkLmZpZWxkc1trXSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImRhdGFfY2hhbmdlZFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBkYXRhX2NoYW5nZWQoYXJncykge1xuICAgICAgaWYgKCF0aGlzLnNldHQuc2NyaXB0cykgcmV0dXJuO1xuICAgICAgaWYgKHRoaXMuc2V0dC5kYXRhX2NoYW5nZV9leGVjID09PSBmYWxzZSkgcmV0dXJuO1xuICAgICAgdmFyIG1haW4gPSB0aGlzLmRhdGEuY2hhcnQuZGF0YTtcbiAgICAgIGlmICh0aGlzLnd3Ll9kYXRhX3VwbG9hZGluZykgcmV0dXJuO1xuICAgICAgaWYgKCF0aGlzLnNlX3N0YXRlLnNjcmlwdHMpIHJldHVybjtcbiAgICAgIHRoaXMuc2VuZF9tZXRhXzJfd3coKTtcbiAgICAgIHRoaXMud3cuanVzdCgndXBsb2FkLWRhdGEnLCB7XG4gICAgICAgIG9obGN2OiBtYWluXG4gICAgICB9KTtcbiAgICAgIHRoaXMud3cuX2RhdGFfdXBsb2FkaW5nID0gdHJ1ZTtcbiAgICAgIHRoaXMuc2V0X2xvYWRpbmcodHJ1ZSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInNldF9sb2FkaW5nXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNldF9sb2FkaW5nKGZsYWcpIHtcbiAgICAgIHZhciBza3JyID0gdGhpcy5nZXQoJy4nKS5maWx0ZXIoZnVuY3Rpb24gKHgpIHtcbiAgICAgICAgcmV0dXJuIHguc2V0dGluZ3MuJHByb3BzO1xuICAgICAgfSk7XG5cbiAgICAgIHZhciBfaXRlcmF0b3I1ID0gZGNfZXZlbnRzX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXIoc2tyciksXG4gICAgICAgICAgX3N0ZXA1O1xuXG4gICAgICB0cnkge1xuICAgICAgICBmb3IgKF9pdGVyYXRvcjUucygpOyAhKF9zdGVwNSA9IF9pdGVyYXRvcjUubigpKS5kb25lOykge1xuICAgICAgICAgIHZhciBzID0gX3N0ZXA1LnZhbHVlO1xuICAgICAgICAgIHRoaXMubWVyZ2UoXCJcIi5jb25jYXQocy5pZCksIHtcbiAgICAgICAgICAgIGxvYWRpbmc6IGZsYWdcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIF9pdGVyYXRvcjUuZShlcnIpO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgX2l0ZXJhdG9yNS5mKCk7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInNlbmRfbWV0YV8yX3d3XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNlbmRfbWV0YV8yX3d3KCkge1xuICAgICAgdmFyIHRmID0gdGhpcy50di4kcmVmcy5jaGFydC5pbnRlcnZhbF9tcyB8fCB0aGlzLmRhdGEuY2hhcnQudGY7XG4gICAgICB2YXIgcmFuZ2UgPSB0aGlzLnR2LmdldFJhbmdlKCk7XG4gICAgICB0aGlzLnd3Lmp1c3QoJ3NlbmQtbWV0YS1pbmZvJywge1xuICAgICAgICB0ZjogdGYsXG4gICAgICAgIHJhbmdlOiByYW5nZVxuICAgICAgfSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIm1lcmdlX3ByZXNldHNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gbWVyZ2VfcHJlc2V0cyhwcm90bywgcHJlc2V0KSB7XG4gICAgICBpZiAoIXByZXNldCkgcmV0dXJuO1xuXG4gICAgICBmb3IgKHZhciBrIGluIHByZXNldCkge1xuICAgICAgICBpZiAoayA9PT0gJ3NldHRpbmdzJykge1xuICAgICAgICAgIE9iamVjdC5hc3NpZ24ocHJvdG9ba10sIHByZXNldFtrXSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcHJvdG9ba10gPSBwcmVzZXRba107XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZ3JpZF9tb3VzZWRvd25cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ3JpZF9tb3VzZWRvd24oYXJncykge1xuICAgICAgdmFyIF90aGlzMyA9IHRoaXM7XG5cbiAgICAgIC8vIFRPRE86IHRvb2wgc3RhdGUgZmluaXNoZWQ/XG4gICAgICB0aGlzLm9iamVjdF9zZWxlY3RlZChbXSk7IC8vIFJlbW92ZSB0aGUgcHJldmlvdXMgUmFuZ2VUb29sXG5cbiAgICAgIHZhciByZW0gPSBmdW5jdGlvbiByZW0oKSB7XG4gICAgICAgIHJldHVybiBfdGhpczMuZ2V0KCdSYW5nZVRvb2wnKS5maWx0ZXIoZnVuY3Rpb24gKHgpIHtcbiAgICAgICAgICByZXR1cm4geC5zZXR0aW5ncy5zaGlmdE1vZGU7XG4gICAgICAgIH0pLmZvckVhY2goZnVuY3Rpb24gKHgpIHtcbiAgICAgICAgICByZXR1cm4gX3RoaXMzLmRlbCh4LmlkKTtcbiAgICAgICAgfSk7XG4gICAgICB9O1xuXG4gICAgICBpZiAodGhpcy5kYXRhLnRvb2wgJiYgdGhpcy5kYXRhLnRvb2wgIT09ICdDdXJzb3InICYmICF0aGlzLmRhdGEuZHJhd2luZ01vZGUpIHtcbiAgICAgICAgLy8gUHJldmVudCBmcm9tIFwibnVsbFwiIHRvb2xzICh0b29sIGNyZWF0ZWQgd2l0aCBIT0RMKVxuICAgICAgICBpZiAoYXJnc1sxXS50eXBlICE9PSAndGFwJykge1xuICAgICAgICAgIHRoaXMudHYuJHNldCh0aGlzLmRhdGEsICdkcmF3aW5nTW9kZScsIHRydWUpO1xuICAgICAgICAgIHRoaXMuYnVpbGRfdG9vbChhcmdzWzBdKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLnR2LnNob3dUaGVUaXAoXCI8Yj5Ib2RsPC9iPis8Yj5EcnVnPC9iPiB0byBjcmVhdGUsIFwiICsgXCI8Yj5UYXA8L2I+IHRvIGZpbmlzaCBhIHRvb2xcIik7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAodGhpcy5zZXR0LnNoaWZ0X21lYXN1cmUgJiYgYXJnc1sxXS5zaGlmdEtleSkge1xuICAgICAgICByZW0oKTtcbiAgICAgICAgdGhpcy50di4kbmV4dFRpY2soZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHJldHVybiBfdGhpczMuYnVpbGRfdG9vbChhcmdzWzBdLCAnUmFuZ2VUb29sOlNoaWZ0TW9kZScpO1xuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJlbSgpO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJkcmF3aW5nX21vZGVfb2ZmXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGRyYXdpbmdfbW9kZV9vZmYoKSB7XG4gICAgICB0aGlzLnR2LiRzZXQodGhpcy5kYXRhLCAnZHJhd2luZ01vZGUnLCBmYWxzZSk7XG4gICAgICB0aGlzLnR2LiRzZXQodGhpcy5kYXRhLCAndG9vbCcsICdDdXJzb3InKTtcbiAgICB9IC8vIFBsYWNlIGEgbmV3IHRvb2xcblxuICB9LCB7XG4gICAga2V5OiBcImJ1aWxkX3Rvb2xcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gYnVpbGRfdG9vbChncmlkX2lkLCB0eXBlKSB7XG4gICAgICB2YXIgbGlzdCA9IHRoaXMuZGF0YS50b29scztcbiAgICAgIHR5cGUgPSB0eXBlIHx8IHRoaXMuZGF0YS50b29sO1xuICAgICAgdmFyIHByb3RvID0gbGlzdC5maW5kKGZ1bmN0aW9uICh4KSB7XG4gICAgICAgIHJldHVybiB4LnR5cGUgPT09IHR5cGU7XG4gICAgICB9KTtcbiAgICAgIGlmICghcHJvdG8pIHJldHVybjtcbiAgICAgIHZhciBzZXR0ID0gT2JqZWN0LmFzc2lnbih7fSwgcHJvdG8uc2V0dGluZ3MgfHwge30pO1xuICAgICAgdmFyIGRhdGEgPSAocHJvdG8uZGF0YSB8fCBbXSkuc2xpY2UoKTtcbiAgICAgIGlmICghKCdsZWdlbmQnIGluIHNldHQpKSBzZXR0LmxlZ2VuZCA9IGZhbHNlO1xuICAgICAgaWYgKCEoJ3otaW5kZXgnIGluIHNldHQpKSBzZXR0Wyd6LWluZGV4J10gPSAxMDA7XG4gICAgICBzZXR0LiRzZWxlY3RlZCA9IHRydWU7XG4gICAgICBzZXR0LiRzdGF0ZSA9ICd3aXAnO1xuICAgICAgdmFyIHNpZGUgPSBncmlkX2lkID8gJ29mZmNoYXJ0JyA6ICdvbmNoYXJ0JztcbiAgICAgIHZhciBpZCA9IHRoaXMuYWRkKHNpZGUsIHtcbiAgICAgICAgbmFtZTogcHJvdG8ubmFtZSxcbiAgICAgICAgdHlwZTogdHlwZS5zcGxpdCgnOicpWzBdLFxuICAgICAgICBzZXR0aW5nczogc2V0dCxcbiAgICAgICAgZGF0YTogZGF0YSxcbiAgICAgICAgZ3JpZDoge1xuICAgICAgICAgIGlkOiBncmlkX2lkXG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgc2V0dC4kdXVpZCA9IFwiXCIuY29uY2F0KGlkLCBcIi1cIikuY29uY2F0KHV0aWxzLm5vdygpKTtcbiAgICAgIHRoaXMudHYuJHNldCh0aGlzLmRhdGEsICdzZWxlY3RlZCcsIHNldHQuJHV1aWQpO1xuICAgICAgdGhpcy5hZGRfdHJhc2hfaWNvbigpO1xuICAgIH0gLy8gUmVtb3ZlIHNlbGVjdGVkIC8gUmVtb3ZlIGFsbCwgZXRjXG5cbiAgfSwge1xuICAgIGtleTogXCJzeXN0ZW1fdG9vbFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzeXN0ZW1fdG9vbCh0eXBlKSB7XG4gICAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgICAgY2FzZSAnUmVtb3ZlJzpcbiAgICAgICAgICBpZiAodGhpcy5kYXRhLnNlbGVjdGVkKSB7XG4gICAgICAgICAgICB0aGlzLmRlbCh0aGlzLmRhdGEuc2VsZWN0ZWQpO1xuICAgICAgICAgICAgdGhpcy5yZW1vdmVfdHJhc2hfaWNvbigpO1xuICAgICAgICAgICAgdGhpcy5kcmF3aW5nX21vZGVfb2ZmKCk7XG4gICAgICAgICAgICB0aGlzLm9uX3Njcm9sbF9sb2NrKGZhbHNlKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9IC8vIEFwcGx5IG5ldyBvdmVybGF5IHNldHRpbmdzXG5cbiAgfSwge1xuICAgIGtleTogXCJjaGFuZ2Vfc2V0dGluZ3NcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gY2hhbmdlX3NldHRpbmdzKGFyZ3MpIHtcbiAgICAgIHZhciBzZXR0aW5ncyA9IGFyZ3NbMF07XG4gICAgICBkZWxldGUgc2V0dGluZ3MuaWQ7XG4gICAgICB2YXIgZ3JpZF9pZCA9IGFyZ3NbMV07XG4gICAgICB0aGlzLm1lcmdlKFwiXCIuY29uY2F0KGFyZ3NbM10sIFwiLnNldHRpbmdzXCIpLCBzZXR0aW5ncyk7XG4gICAgfSAvLyBMb2NrIHRoZSBzY3JvbGxpbmcgbWVjaGFuaXNtXG5cbiAgfSwge1xuICAgIGtleTogXCJvbl9zY3JvbGxfbG9ja1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBvbl9zY3JvbGxfbG9jayhmbGFnKSB7XG4gICAgICB0aGlzLnR2LiRzZXQodGhpcy5kYXRhLCAnc2Nyb2xsTG9jaycsIGZsYWcpO1xuICAgIH0gLy8gV2hlbiBuZXcgb2JqZWN0IGlzIHNlbGVjdGVkIC8gdW5zZWxlY3RlZFxuXG4gIH0sIHtcbiAgICBrZXk6IFwib2JqZWN0X3NlbGVjdGVkXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG9iamVjdF9zZWxlY3RlZChhcmdzKSB7XG4gICAgICB2YXIgcSA9IHRoaXMuZGF0YS5zZWxlY3RlZDtcblxuICAgICAgaWYgKHEpIHtcbiAgICAgICAgLy8gQ2hlY2sgaWYgY3VycmVudCBkcmF3aW5nIGlzIGZpbmlzaGVkXG4gICAgICAgIC8vbGV0IHJlcyA9IHRoaXMuZ2V0X29uZShgJHtxfS5zZXR0aW5nc2ApXG4gICAgICAgIC8vaWYgKHJlcyAmJiByZXMuJHN0YXRlICE9PSAnZmluaXNoZWQnKSByZXR1cm5cbiAgICAgICAgdGhpcy5tZXJnZShcIlwiLmNvbmNhdChxLCBcIi5zZXR0aW5nc1wiKSwge1xuICAgICAgICAgICRzZWxlY3RlZDogZmFsc2VcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMucmVtb3ZlX3RyYXNoX2ljb24oKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy50di4kc2V0KHRoaXMuZGF0YSwgJ3NlbGVjdGVkJywgbnVsbCk7XG4gICAgICBpZiAoIWFyZ3MubGVuZ3RoKSByZXR1cm47XG4gICAgICB0aGlzLnR2LiRzZXQodGhpcy5kYXRhLCAnc2VsZWN0ZWQnLCBhcmdzWzJdKTtcbiAgICAgIHRoaXMubWVyZ2UoXCJcIi5jb25jYXQoYXJnc1syXSwgXCIuc2V0dGluZ3NcIiksIHtcbiAgICAgICAgJHNlbGVjdGVkOiB0cnVlXG4gICAgICB9KTtcbiAgICAgIHRoaXMuYWRkX3RyYXNoX2ljb24oKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiYWRkX3RyYXNoX2ljb25cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gYWRkX3RyYXNoX2ljb24oKSB7XG4gICAgICB2YXIgdHlwZSA9ICdTeXN0ZW06UmVtb3ZlJztcblxuICAgICAgaWYgKHRoaXMuZGF0YS50b29scy5maW5kKGZ1bmN0aW9uICh4KSB7XG4gICAgICAgIHJldHVybiB4LnR5cGUgPT09IHR5cGU7XG4gICAgICB9KSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHRoaXMuZGF0YS50b29scy5wdXNoKHtcbiAgICAgICAgdHlwZTogdHlwZSxcbiAgICAgICAgaWNvbjogaWNvbnNfbmFtZXNwYWNlT2JqZWN0W1widHJhc2gucG5nXCJdXG4gICAgICB9KTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwicmVtb3ZlX3RyYXNoX2ljb25cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVtb3ZlX3RyYXNoX2ljb24oKSB7XG4gICAgICAvLyBUT0RPOiBEb2VzIG5vdCBjYWxsIFRvb2xiYXIgcmVuZGVyIChkaXN0ciB2ZXJzaW9uKVxuICAgICAgdmFyIHR5cGUgPSAnU3lzdGVtOlJlbW92ZSc7XG4gICAgICB1dGlscy5vdmVyd3JpdGUodGhpcy5kYXRhLnRvb2xzLCB0aGlzLmRhdGEudG9vbHMuZmlsdGVyKGZ1bmN0aW9uICh4KSB7XG4gICAgICAgIHJldHVybiB4LnR5cGUgIT09IHR5cGU7XG4gICAgICB9KSk7XG4gICAgfSAvLyBTZXQgb3ZlcmxheSBkYXRhIGZyb20gdGhlIHdlYi13b3JrZXJcblxuICB9LCB7XG4gICAga2V5OiBcIm9uX292ZXJsYXlfZGF0YVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBvbl9vdmVybGF5X2RhdGEoZGF0YSkge1xuICAgICAgdmFyIF90aGlzNCA9IHRoaXM7XG5cbiAgICAgIHRoaXMuZ2V0KCcuJykuZm9yRWFjaChmdW5jdGlvbiAoeCkge1xuICAgICAgICBpZiAoeC5zZXR0aW5ncy4kc3ludGgpIF90aGlzNC5kZWwoXCJcIi5jb25jYXQoeC5pZCkpO1xuICAgICAgfSk7XG5cbiAgICAgIHZhciBfaXRlcmF0b3I2ID0gZGNfZXZlbnRzX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXIoZGF0YSksXG4gICAgICAgICAgX3N0ZXA2O1xuXG4gICAgICB0cnkge1xuICAgICAgICBmb3IgKF9pdGVyYXRvcjYucygpOyAhKF9zdGVwNiA9IF9pdGVyYXRvcjYubigpKS5kb25lOykge1xuICAgICAgICAgIHZhciBvdiA9IF9zdGVwNi52YWx1ZTtcbiAgICAgICAgICB2YXIgb2JqID0gdGhpcy5nZXRfb25lKFwiXCIuY29uY2F0KG92LmlkKSk7XG5cbiAgICAgICAgICBpZiAob2JqKSB7XG4gICAgICAgICAgICB0aGlzLnR2LiRzZXQob2JqLCAnbG9hZGluZycsIGZhbHNlKTtcbiAgICAgICAgICAgIGlmICghb3YuZGF0YSkgY29udGludWU7XG4gICAgICAgICAgICBvYmouZGF0YSA9IG92LmRhdGE7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKCFvdi5uZXdfb3ZzKSBjb250aW51ZTtcblxuICAgICAgICAgIGZvciAodmFyIGlkIGluIG92Lm5ld19vdnMub25jaGFydCkge1xuICAgICAgICAgICAgaWYgKCF0aGlzLmdldF9vbmUoXCJvbmNoYXJ0LlwiLmNvbmNhdChpZCkpKSB7XG4gICAgICAgICAgICAgIHRoaXMuYWRkKCdvbmNoYXJ0Jywgb3YubmV3X292cy5vbmNoYXJ0W2lkXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZm9yICh2YXIgaWQgaW4gb3YubmV3X292cy5vZmZjaGFydCkge1xuICAgICAgICAgICAgaWYgKCF0aGlzLmdldF9vbmUoXCJvZmZjaGFydC5cIi5jb25jYXQoaWQpKSkge1xuICAgICAgICAgICAgICB0aGlzLmFkZCgnb2ZmY2hhcnQnLCBvdi5uZXdfb3ZzLm9mZmNoYXJ0W2lkXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgX2l0ZXJhdG9yNi5lKGVycik7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICBfaXRlcmF0b3I2LmYoKTtcbiAgICAgIH1cbiAgICB9IC8vIFB1c2ggb3ZlcmxheSB1cGRhdGVzIGZyb20gdGhlIHdlYi13b3JrZXJcblxuICB9LCB7XG4gICAga2V5OiBcIm9uX292ZXJsYXlfdXBkYXRlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG9uX292ZXJsYXlfdXBkYXRlKGRhdGEpIHtcbiAgICAgIHZhciBfaXRlcmF0b3I3ID0gZGNfZXZlbnRzX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXIoZGF0YSksXG4gICAgICAgICAgX3N0ZXA3O1xuXG4gICAgICB0cnkge1xuICAgICAgICBmb3IgKF9pdGVyYXRvcjcucygpOyAhKF9zdGVwNyA9IF9pdGVyYXRvcjcubigpKS5kb25lOykge1xuICAgICAgICAgIHZhciBvdiA9IF9zdGVwNy52YWx1ZTtcbiAgICAgICAgICBpZiAoIW92LmRhdGEpIGNvbnRpbnVlO1xuICAgICAgICAgIHZhciBvYmogPSB0aGlzLmdldF9vbmUoXCJcIi5jb25jYXQob3YuaWQpKTtcblxuICAgICAgICAgIGlmIChvYmopIHtcbiAgICAgICAgICAgIHRoaXMuZmFzdF9tZXJnZShvYmouZGF0YSwgb3YuZGF0YSwgZmFsc2UpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIF9pdGVyYXRvcjcuZShlcnIpO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgX2l0ZXJhdG9yNy5mKCk7XG4gICAgICB9XG4gICAgfSAvLyBDbGVhbi11cCB1bmZpbmlzaGVkIGJ1c2luZXNzICh0b29scylcblxuICB9LCB7XG4gICAga2V5OiBcImJlZm9yZV9kZXN0cm95XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGJlZm9yZV9kZXN0cm95KCkge1xuICAgICAgdmFyIGYgPSBmdW5jdGlvbiBmKHgpIHtcbiAgICAgICAgcmV0dXJuICF4LnNldHRpbmdzLiRzdGF0ZSB8fCB4LnNldHRpbmdzLiRzdGF0ZSA9PT0gJ2ZpbmlzaGVkJztcbiAgICAgIH07XG5cbiAgICAgIHRoaXMuZGF0YS5vbmNoYXJ0ID0gdGhpcy5kYXRhLm9uY2hhcnQuZmlsdGVyKGYpO1xuICAgICAgdGhpcy5kYXRhLm9mZmNoYXJ0ID0gdGhpcy5kYXRhLm9mZmNoYXJ0LmZpbHRlcihmKTtcbiAgICAgIHRoaXMuZHJhd2luZ19tb2RlX29mZigpO1xuICAgICAgdGhpcy5vbl9zY3JvbGxfbG9jayhmYWxzZSk7XG4gICAgICB0aGlzLm9iamVjdF9zZWxlY3RlZChbXSk7XG4gICAgICB0aGlzLnd3LmRlc3Ryb3koKTtcbiAgICB9IC8vIEdldCBvdmVybGF5IGJ5IGdyaWQtbGF5ZXIgaWRcblxuICB9LCB7XG4gICAga2V5OiBcImdldF9vdmVybGF5XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldF9vdmVybGF5KG9iaikge1xuICAgICAgdmFyIGlkID0gb2JqLmlkIHx8IFwiZ1wiLmNvbmNhdChvYmouZ3JpZF9pZCwgXCJfXCIpLmNvbmNhdChvYmoubGF5ZXJfaWQpO1xuICAgICAgdmFyIGRjaWQgPSBvYmoudXVpZCB8fCB0aGlzLmdsZGNbaWRdO1xuICAgICAgcmV0dXJuIHRoaXMuZ2V0X29uZShcIlwiLmNvbmNhdChkY2lkKSk7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIERDRXZlbnRzO1xufSgpO1xuXG5cbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9oZWxwZXJzL2RjX2NvcmUuanNcblxuXG5cblxuXG5cblxuXG5cbmZ1bmN0aW9uIGRjX2NvcmVfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlcihvLCBhbGxvd0FycmF5TGlrZSkgeyB2YXIgaXQ7IGlmICh0eXBlb2YgU3ltYm9sID09PSBcInVuZGVmaW5lZFwiIHx8IG9bU3ltYm9sLml0ZXJhdG9yXSA9PSBudWxsKSB7IGlmIChBcnJheS5pc0FycmF5KG8pIHx8IChpdCA9IGRjX2NvcmVfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkobykpIHx8IGFsbG93QXJyYXlMaWtlICYmIG8gJiYgdHlwZW9mIG8ubGVuZ3RoID09PSBcIm51bWJlclwiKSB7IGlmIChpdCkgbyA9IGl0OyB2YXIgaSA9IDA7IHZhciBGID0gZnVuY3Rpb24gRigpIHt9OyByZXR1cm4geyBzOiBGLCBuOiBmdW5jdGlvbiBuKCkgeyBpZiAoaSA+PSBvLmxlbmd0aCkgcmV0dXJuIHsgZG9uZTogdHJ1ZSB9OyByZXR1cm4geyBkb25lOiBmYWxzZSwgdmFsdWU6IG9baSsrXSB9OyB9LCBlOiBmdW5jdGlvbiBlKF9lKSB7IHRocm93IF9lOyB9LCBmOiBGIH07IH0gdGhyb3cgbmV3IFR5cGVFcnJvcihcIkludmFsaWQgYXR0ZW1wdCB0byBpdGVyYXRlIG5vbi1pdGVyYWJsZSBpbnN0YW5jZS5cXG5JbiBvcmRlciB0byBiZSBpdGVyYWJsZSwgbm9uLWFycmF5IG9iamVjdHMgbXVzdCBoYXZlIGEgW1N5bWJvbC5pdGVyYXRvcl0oKSBtZXRob2QuXCIpOyB9IHZhciBub3JtYWxDb21wbGV0aW9uID0gdHJ1ZSwgZGlkRXJyID0gZmFsc2UsIGVycjsgcmV0dXJuIHsgczogZnVuY3Rpb24gcygpIHsgaXQgPSBvW1N5bWJvbC5pdGVyYXRvcl0oKTsgfSwgbjogZnVuY3Rpb24gbigpIHsgdmFyIHN0ZXAgPSBpdC5uZXh0KCk7IG5vcm1hbENvbXBsZXRpb24gPSBzdGVwLmRvbmU7IHJldHVybiBzdGVwOyB9LCBlOiBmdW5jdGlvbiBlKF9lMikgeyBkaWRFcnIgPSB0cnVlOyBlcnIgPSBfZTI7IH0sIGY6IGZ1bmN0aW9uIGYoKSB7IHRyeSB7IGlmICghbm9ybWFsQ29tcGxldGlvbiAmJiBpdFtcInJldHVyblwiXSAhPSBudWxsKSBpdFtcInJldHVyblwiXSgpOyB9IGZpbmFsbHkgeyBpZiAoZGlkRXJyKSB0aHJvdyBlcnI7IH0gfSB9OyB9XG5cbmZ1bmN0aW9uIGRjX2NvcmVfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkobywgbWluTGVuKSB7IGlmICghbykgcmV0dXJuOyBpZiAodHlwZW9mIG8gPT09IFwic3RyaW5nXCIpIHJldHVybiBkY19jb3JlX2FycmF5TGlrZVRvQXJyYXkobywgbWluTGVuKTsgdmFyIG4gPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwobykuc2xpY2UoOCwgLTEpOyBpZiAobiA9PT0gXCJPYmplY3RcIiAmJiBvLmNvbnN0cnVjdG9yKSBuID0gby5jb25zdHJ1Y3Rvci5uYW1lOyBpZiAobiA9PT0gXCJNYXBcIiB8fCBuID09PSBcIlNldFwiKSByZXR1cm4gQXJyYXkuZnJvbShvKTsgaWYgKG4gPT09IFwiQXJndW1lbnRzXCIgfHwgL14oPzpVaXxJKW50KD86OHwxNnwzMikoPzpDbGFtcGVkKT9BcnJheSQvLnRlc3QobikpIHJldHVybiBkY19jb3JlX2FycmF5TGlrZVRvQXJyYXkobywgbWluTGVuKTsgfVxuXG5mdW5jdGlvbiBkY19jb3JlX2FycmF5TGlrZVRvQXJyYXkoYXJyLCBsZW4pIHsgaWYgKGxlbiA9PSBudWxsIHx8IGxlbiA+IGFyci5sZW5ndGgpIGxlbiA9IGFyci5sZW5ndGg7IGZvciAodmFyIGkgPSAwLCBhcnIyID0gbmV3IEFycmF5KGxlbik7IGkgPCBsZW47IGkrKykgeyBhcnIyW2ldID0gYXJyW2ldOyB9IHJldHVybiBhcnIyOyB9XG5cbmZ1bmN0aW9uIGRjX2NvcmVfY3JlYXRlU3VwZXIoRGVyaXZlZCkgeyB2YXIgaGFzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCA9IGRjX2NvcmVfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KCk7IHJldHVybiBmdW5jdGlvbiBfY3JlYXRlU3VwZXJJbnRlcm5hbCgpIHsgdmFyIFN1cGVyID0gX2dldFByb3RvdHlwZU9mKERlcml2ZWQpLCByZXN1bHQ7IGlmIChoYXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KSB7IHZhciBOZXdUYXJnZXQgPSBfZ2V0UHJvdG90eXBlT2YodGhpcykuY29uc3RydWN0b3I7IHJlc3VsdCA9IFJlZmxlY3QuY29uc3RydWN0KFN1cGVyLCBhcmd1bWVudHMsIE5ld1RhcmdldCk7IH0gZWxzZSB7IHJlc3VsdCA9IFN1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7IH0gcmV0dXJuIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIHJlc3VsdCk7IH07IH1cblxuZnVuY3Rpb24gZGNfY29yZV9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QoKSB7IGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJ1bmRlZmluZWRcIiB8fCAhUmVmbGVjdC5jb25zdHJ1Y3QpIHJldHVybiBmYWxzZTsgaWYgKFJlZmxlY3QuY29uc3RydWN0LnNoYW0pIHJldHVybiBmYWxzZTsgaWYgKHR5cGVvZiBQcm94eSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gdHJ1ZTsgdHJ5IHsgQm9vbGVhbi5wcm90b3R5cGUudmFsdWVPZi5jYWxsKFJlZmxlY3QuY29uc3RydWN0KEJvb2xlYW4sIFtdLCBmdW5jdGlvbiAoKSB7fSkpOyByZXR1cm4gdHJ1ZTsgfSBjYXRjaCAoZSkgeyByZXR1cm4gZmFsc2U7IH0gfVxuXG4vLyBEYXRhQ3ViZSBcInByaXZhdGVcIiBtZXRob2RzXG5cblxuXG5cbnZhciBEQ0NvcmUgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9EQ0V2ZW50cykge1xuICBfaW5oZXJpdHMoRENDb3JlLCBfRENFdmVudHMpO1xuXG4gIHZhciBfc3VwZXIgPSBkY19jb3JlX2NyZWF0ZVN1cGVyKERDQ29yZSk7XG5cbiAgZnVuY3Rpb24gRENDb3JlKCkge1xuICAgIGNsYXNzQ2FsbENoZWNrX2NsYXNzQ2FsbENoZWNrKHRoaXMsIERDQ29yZSk7XG5cbiAgICByZXR1cm4gX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gIH1cblxuICBjcmVhdGVDbGFzc19jcmVhdGVDbGFzcyhEQ0NvcmUsIFt7XG4gICAga2V5OiBcImluaXRfdHZqc1wiLFxuICAgIHZhbHVlOiAvLyBTZXQgVFYgaW5zdGFuY2UgKG9uY2UpLiBDYWxsZWQgYnkgVHJhZGluZ1Z1ZSBpdHNlbGZcbiAgICBmdW5jdGlvbiBpbml0X3R2anMoJHJvb3QpIHtcbiAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICAgIGlmICghdGhpcy50dikge1xuICAgICAgICB0aGlzLnR2ID0gJHJvb3Q7XG4gICAgICAgIHRoaXMuaW5pdF9kYXRhKCk7XG4gICAgICAgIHRoaXMudXBkYXRlX2lkcygpOyAvLyBMaXN0ZW4gdG8gYWxsIHNldHRpbmcgY2hhbmdlc1xuICAgICAgICAvLyBUT0RPOiB3b3JrcyBvbmx5IHdpdGggbWVyZ2UoKVxuXG4gICAgICAgIHRoaXMudHYuJHdhdGNoKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICByZXR1cm4gX3RoaXMuZ2V0X2J5X3F1ZXJ5KCcuc2V0dGluZ3MnKTtcbiAgICAgICAgfSwgZnVuY3Rpb24gKG4sIHApIHtcbiAgICAgICAgICByZXR1cm4gX3RoaXMub25fc2V0dGluZ3MobiwgcCk7XG4gICAgICAgIH0pOyAvLyBMaXN0ZW4gdG8gYWxsIGluZGljZXMgY2hhbmdlc1xuXG4gICAgICAgIHRoaXMudHYuJHdhdGNoKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICByZXR1cm4gX3RoaXMuZ2V0KCcuJykubWFwKGZ1bmN0aW9uICh4KSB7XG4gICAgICAgICAgICByZXR1cm4geC5zZXR0aW5ncy4kdXVpZDtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSwgZnVuY3Rpb24gKG4sIHApIHtcbiAgICAgICAgICByZXR1cm4gX3RoaXMub25faWRzX2NoYW5nZWQobiwgcCk7XG4gICAgICAgIH0pOyAvLyBXYXRjaCBmb3IgYWxsICdkYXRhc2V0cycgY2hhbmdlc1xuXG4gICAgICAgIHRoaXMudHYuJHdhdGNoKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICByZXR1cm4gX3RoaXMuZ2V0KCdkYXRhc2V0cycpO1xuICAgICAgICB9LCBEYXRhc2V0LndhdGNoZXIuYmluZCh0aGlzKSk7XG4gICAgICB9XG4gICAgfSAvLyBJbml0IERhdGEgU3RydWN0dXJlIHYxLjFcblxuICB9LCB7XG4gICAga2V5OiBcImluaXRfZGF0YVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBpbml0X2RhdGEoJHJvb3QpIHtcbiAgICAgIGlmICghKCdjaGFydCcgaW4gdGhpcy5kYXRhKSkge1xuICAgICAgICB0aGlzLnR2LiRzZXQodGhpcy5kYXRhLCAnY2hhcnQnLCB7XG4gICAgICAgICAgdHlwZTogJ0NhbmRsZXMnLFxuICAgICAgICAgIGRhdGE6IHRoaXMuZGF0YS5vaGxjdiB8fCBbXVxuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgaWYgKCEoJ29uY2hhcnQnIGluIHRoaXMuZGF0YSkpIHtcbiAgICAgICAgdGhpcy50di4kc2V0KHRoaXMuZGF0YSwgJ29uY2hhcnQnLCBbXSk7XG4gICAgICB9XG5cbiAgICAgIGlmICghKCdvZmZjaGFydCcgaW4gdGhpcy5kYXRhKSkge1xuICAgICAgICB0aGlzLnR2LiRzZXQodGhpcy5kYXRhLCAnb2ZmY2hhcnQnLCBbXSk7XG4gICAgICB9XG5cbiAgICAgIGlmICghdGhpcy5kYXRhLmNoYXJ0LnNldHRpbmdzKSB7XG4gICAgICAgIHRoaXMudHYuJHNldCh0aGlzLmRhdGEuY2hhcnQsICdzZXR0aW5ncycsIHt9KTtcbiAgICAgIH0gLy8gUmVtb3ZlIG9obGN2IGN1eiB3ZSBoYXZlIERhdGEgdjEuMV5cblxuXG4gICAgICBkZWxldGUgdGhpcy5kYXRhLm9obGN2O1xuXG4gICAgICBpZiAoISgnZGF0YXNldHMnIGluIHRoaXMuZGF0YSkpIHtcbiAgICAgICAgdGhpcy50di4kc2V0KHRoaXMuZGF0YSwgJ2RhdGFzZXRzJywgW10pO1xuICAgICAgfSAvLyBJbml0IGRhdGFzZXQgcHJveGllc1xuXG5cbiAgICAgIHZhciBfaXRlcmF0b3IgPSBkY19jb3JlX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXIodGhpcy5kYXRhLmRhdGFzZXRzKSxcbiAgICAgICAgICBfc3RlcDtcblxuICAgICAgdHJ5IHtcbiAgICAgICAgZm9yIChfaXRlcmF0b3IucygpOyAhKF9zdGVwID0gX2l0ZXJhdG9yLm4oKSkuZG9uZTspIHtcbiAgICAgICAgICB2YXIgZHMgPSBfc3RlcC52YWx1ZTtcbiAgICAgICAgICBpZiAoIXRoaXMuZHNzKSB0aGlzLmRzcyA9IHt9O1xuICAgICAgICAgIHRoaXMuZHNzW2RzLmlkXSA9IG5ldyBEYXRhc2V0KHRoaXMsIGRzKTtcbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIF9pdGVyYXRvci5lKGVycik7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICBfaXRlcmF0b3IuZigpO1xuICAgICAgfVxuICAgIH0gLy8gUmFuZ2UgY2hhbmdlIGNhbGxiYWNrIChjYWxsZWQgYnkgVHJhZGluZ1Z1ZSlcbiAgICAvLyBUT0RPOiBpbXByb3ZlIChyZWxpYWJsaXR5ICsgY2h1bmsgd2l0aCBsaW1pdGVkIHNpemUpXG5cbiAgfSwge1xuICAgIGtleTogXCJyYW5nZV9jaGFuZ2VkXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBfcmFuZ2VfY2hhbmdlZCA9IF9hc3luY1RvR2VuZXJhdG9yKCAvKiNfX1BVUkVfXyovcmVnZW5lcmF0b3JfZGVmYXVsdCgpLm1hcmsoZnVuY3Rpb24gX2NhbGxlZShyYW5nZSwgdGYsIGNoZWNrKSB7XG4gICAgICAgIHZhciBfdGhpczIgPSB0aGlzO1xuXG4gICAgICAgIHZhciBmaXJzdCwgcHJvbTtcbiAgICAgICAgcmV0dXJuIHJlZ2VuZXJhdG9yX2RlZmF1bHQoKS53cmFwKGZ1bmN0aW9uIF9jYWxsZWUkKF9jb250ZXh0KSB7XG4gICAgICAgICAgd2hpbGUgKDEpIHtcbiAgICAgICAgICAgIHN3aXRjaCAoX2NvbnRleHQucHJldiA9IF9jb250ZXh0Lm5leHQpIHtcbiAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgIGlmIChjaGVjayA9PT0gdm9pZCAwKSB7XG4gICAgICAgICAgICAgICAgICBjaGVjayA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmICh0aGlzLmxvYWRlcikge1xuICAgICAgICAgICAgICAgICAgX2NvbnRleHQubmV4dCA9IDM7XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQuYWJydXB0KFwicmV0dXJuXCIpO1xuXG4gICAgICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5sb2FkaW5nKSB7XG4gICAgICAgICAgICAgICAgICBfY29udGV4dC5uZXh0ID0gMTk7XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBmaXJzdCA9IHRoaXMuZGF0YS5jaGFydC5kYXRhWzBdWzBdO1xuXG4gICAgICAgICAgICAgICAgaWYgKCEocmFuZ2VbMF0gPCBmaXJzdCkpIHtcbiAgICAgICAgICAgICAgICAgIF9jb250ZXh0Lm5leHQgPSAxOTtcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHRoaXMubG9hZGluZyA9IHRydWU7XG4gICAgICAgICAgICAgICAgX2NvbnRleHQubmV4dCA9IDk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHV0aWxzLnBhdXNlKDI1MCk7XG5cbiAgICAgICAgICAgICAgY2FzZSA5OlxuICAgICAgICAgICAgICAgIC8vIExvYWQgYmlnZ2VyIGNodW5rc1xuICAgICAgICAgICAgICAgIHJhbmdlID0gcmFuZ2Uuc2xpY2UoKTsgLy8gY29weVxuXG4gICAgICAgICAgICAgICAgcmFuZ2VbMF0gPSBNYXRoLmZsb29yKHJhbmdlWzBdKTtcbiAgICAgICAgICAgICAgICByYW5nZVsxXSA9IE1hdGguZmxvb3IoZmlyc3QpO1xuICAgICAgICAgICAgICAgIHByb20gPSB0aGlzLmxvYWRlcihyYW5nZSwgdGYsIGZ1bmN0aW9uIChkKSB7XG4gICAgICAgICAgICAgICAgICAvLyBDYWxsYmFjayB3YXlcbiAgICAgICAgICAgICAgICAgIF90aGlzMi5jaHVua19sb2FkZWQoZCk7XG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICBpZiAoIShwcm9tICYmIHByb20udGhlbikpIHtcbiAgICAgICAgICAgICAgICAgIF9jb250ZXh0Lm5leHQgPSAxOTtcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIF9jb250ZXh0LnQwID0gdGhpcztcbiAgICAgICAgICAgICAgICBfY29udGV4dC5uZXh0ID0gMTc7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHByb207XG5cbiAgICAgICAgICAgICAgY2FzZSAxNzpcbiAgICAgICAgICAgICAgICBfY29udGV4dC50MSA9IF9jb250ZXh0LnNlbnQ7XG5cbiAgICAgICAgICAgICAgICBfY29udGV4dC50MC5jaHVua19sb2FkZWQuY2FsbChfY29udGV4dC50MCwgX2NvbnRleHQudDEpO1xuXG4gICAgICAgICAgICAgIGNhc2UgMTk6XG4gICAgICAgICAgICAgICAgaWYgKCFjaGVjaykgdGhpcy5sYXN0X2NodW5rID0gW3JhbmdlLCB0Zl07XG5cbiAgICAgICAgICAgICAgY2FzZSAyMDpcbiAgICAgICAgICAgICAgY2FzZSBcImVuZFwiOlxuICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dC5zdG9wKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9LCBfY2FsbGVlLCB0aGlzKTtcbiAgICAgIH0pKTtcblxuICAgICAgZnVuY3Rpb24gcmFuZ2VfY2hhbmdlZChfeCwgX3gyLCBfeDMpIHtcbiAgICAgICAgcmV0dXJuIF9yYW5nZV9jaGFuZ2VkLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiByYW5nZV9jaGFuZ2VkO1xuICAgIH0oKSAvLyBBIG5ldyBjaHVuayBvZiBkYXRhIGlzIGxvYWRlZFxuICAgIC8vIFRPRE86IGJ1bGxldHByb29mIGZldGNoXG5cbiAgfSwge1xuICAgIGtleTogXCJjaHVua19sb2FkZWRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gY2h1bmtfbG9hZGVkKGRhdGEpIHtcbiAgICAgIC8vIFVwZGF0ZXMgb25seSBjYW5kbGVzdGljayBkYXRhLCBvclxuICAgICAgaWYgKEFycmF5LmlzQXJyYXkoZGF0YSkpIHtcbiAgICAgICAgdGhpcy5tZXJnZSgnY2hhcnQuZGF0YScsIGRhdGEpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gQnVuY2ggb2Ygb3ZlcmxheXMsIGluY2x1ZGluZyBjaGFydC5kYXRhXG4gICAgICAgIGZvciAodmFyIGsgaW4gZGF0YSkge1xuICAgICAgICAgIHRoaXMubWVyZ2UoaywgZGF0YVtrXSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdGhpcy5sb2FkaW5nID0gZmFsc2U7XG5cbiAgICAgIGlmICh0aGlzLmxhc3RfY2h1bmspIHtcbiAgICAgICAgdGhpcy5yYW5nZV9jaGFuZ2VkLmFwcGx5KHRoaXMsIF90b0NvbnN1bWFibGVBcnJheSh0aGlzLmxhc3RfY2h1bmspLmNvbmNhdChbdHJ1ZV0pKTtcbiAgICAgICAgdGhpcy5sYXN0X2NodW5rID0gbnVsbDtcbiAgICAgIH1cbiAgICB9IC8vIFVwZGF0ZSBpZHMgZm9yIGFsbCBvdmVybGF5c1xuXG4gIH0sIHtcbiAgICBrZXk6IFwidXBkYXRlX2lkc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB1cGRhdGVfaWRzKCkge1xuICAgICAgdGhpcy5kYXRhLmNoYXJ0LmlkID0gXCJjaGFydC5cIi5jb25jYXQodGhpcy5kYXRhLmNoYXJ0LnR5cGUpO1xuICAgICAgdmFyIGNvdW50ID0ge307IC8vIGdyaWRfaWQsbGF5ZXJfaWQgPT4gREMgaWQgbWFwcGluZ1xuXG4gICAgICB0aGlzLmdsZGMgPSB7fSwgdGhpcy5kY2dsID0ge307XG5cbiAgICAgIHZhciBfaXRlcmF0b3IyID0gZGNfY29yZV9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyKHRoaXMuZGF0YS5vbmNoYXJ0KSxcbiAgICAgICAgICBfc3RlcDI7XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIGZvciAoX2l0ZXJhdG9yMi5zKCk7ICEoX3N0ZXAyID0gX2l0ZXJhdG9yMi5uKCkpLmRvbmU7KSB7XG4gICAgICAgICAgdmFyIG92ID0gX3N0ZXAyLnZhbHVlO1xuXG4gICAgICAgICAgaWYgKGNvdW50W292LnR5cGVdID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGNvdW50W292LnR5cGVdID0gMDtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB2YXIgaSA9IGNvdW50W292LnR5cGVdKys7XG4gICAgICAgICAgb3YuaWQgPSBcIm9uY2hhcnQuXCIuY29uY2F0KG92LnR5cGUpLmNvbmNhdChpKTtcbiAgICAgICAgICBpZiAoIW92Lm5hbWUpIG92Lm5hbWUgPSBvdi50eXBlICsgXCIgXCIuY29uY2F0KGkpO1xuICAgICAgICAgIGlmICghb3Yuc2V0dGluZ3MpIHRoaXMudHYuJHNldChvdiwgJ3NldHRpbmdzJywge30pOyAvLyBncmlkX2lkLGxheWVyX2lkID0+IERDIGlkIG1hcHBpbmdcblxuICAgICAgICAgIHRoaXMuZ2xkY1tcImcwX1wiLmNvbmNhdChvdi50eXBlLCBcIl9cIikuY29uY2F0KGkpXSA9IG92LmlkO1xuICAgICAgICAgIHRoaXMuZGNnbFtvdi5pZF0gPSBcImcwX1wiLmNvbmNhdChvdi50eXBlLCBcIl9cIikuY29uY2F0KGkpO1xuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgX2l0ZXJhdG9yMi5lKGVycik7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICBfaXRlcmF0b3IyLmYoKTtcbiAgICAgIH1cblxuICAgICAgY291bnQgPSB7fTtcbiAgICAgIHZhciBncmlkcyA9IFt7fV07XG4gICAgICB2YXIgZ2lkID0gMDtcblxuICAgICAgdmFyIF9pdGVyYXRvcjMgPSBkY19jb3JlX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXIodGhpcy5kYXRhLm9mZmNoYXJ0KSxcbiAgICAgICAgICBfc3RlcDM7XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIGZvciAoX2l0ZXJhdG9yMy5zKCk7ICEoX3N0ZXAzID0gX2l0ZXJhdG9yMy5uKCkpLmRvbmU7KSB7XG4gICAgICAgICAgdmFyIG92ID0gX3N0ZXAzLnZhbHVlO1xuXG4gICAgICAgICAgaWYgKGNvdW50W292LnR5cGVdID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGNvdW50W292LnR5cGVdID0gMDtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB2YXIgX2kgPSBjb3VudFtvdi50eXBlXSsrO1xuXG4gICAgICAgICAgb3YuaWQgPSBcIm9mZmNoYXJ0LlwiLmNvbmNhdChvdi50eXBlKS5jb25jYXQoX2kpO1xuICAgICAgICAgIGlmICghb3YubmFtZSkgb3YubmFtZSA9IG92LnR5cGUgKyBcIiBcIi5jb25jYXQoX2kpO1xuICAgICAgICAgIGlmICghb3Yuc2V0dGluZ3MpIHRoaXMudHYuJHNldChvdiwgJ3NldHRpbmdzJywge30pOyAvLyBncmlkX2lkLGxheWVyX2lkID0+IERDIGlkIG1hcHBpbmdcblxuICAgICAgICAgIGdpZCsrO1xuICAgICAgICAgIHZhciByZ2lkID0gKG92LmdyaWQgfHwge30pLmlkIHx8IGdpZDsgLy8gcmVhbCBncmlkX2lkXG4gICAgICAgICAgLy8gV2hlbiB3ZSBtZXJnZSBncmlkLCBza2lwICsrXG5cbiAgICAgICAgICBpZiAoKG92LmdyaWQgfHwge30pLmlkKSBnaWQtLTtcbiAgICAgICAgICBpZiAoIWdyaWRzW3JnaWRdKSBncmlkc1tyZ2lkXSA9IHt9O1xuXG4gICAgICAgICAgaWYgKGdyaWRzW3JnaWRdW292LnR5cGVdID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGdyaWRzW3JnaWRdW292LnR5cGVdID0gMDtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB2YXIgcmkgPSBncmlkc1tyZ2lkXVtvdi50eXBlXSsrO1xuICAgICAgICAgIHRoaXMuZ2xkY1tcImdcIi5jb25jYXQocmdpZCwgXCJfXCIpLmNvbmNhdChvdi50eXBlLCBcIl9cIikuY29uY2F0KHJpKV0gPSBvdi5pZDtcbiAgICAgICAgICB0aGlzLmRjZ2xbb3YuaWRdID0gXCJnXCIuY29uY2F0KHJnaWQsIFwiX1wiKS5jb25jYXQob3YudHlwZSwgXCJfXCIpLmNvbmNhdChyaSk7XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICBfaXRlcmF0b3IzLmUoZXJyKTtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIF9pdGVyYXRvcjMuZigpO1xuICAgICAgfVxuICAgIH0gLy8gVE9ETzogY2hhcnQgcmVmaW5lIChmcm9tIHRoZSBleGNoYW5nZSBjaGFydClcblxuICB9LCB7XG4gICAga2V5OiBcInVwZGF0ZV9jYW5kbGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdXBkYXRlX2NhbmRsZShkYXRhKSB7XG4gICAgICB2YXIgb2hsY3YgPSB0aGlzLmRhdGEuY2hhcnQuZGF0YTtcbiAgICAgIHZhciBsYXN0ID0gb2hsY3Zbb2hsY3YubGVuZ3RoIC0gMV07XG4gICAgICB2YXIgY2FuZGxlID0gZGF0YVsnY2FuZGxlJ107XG4gICAgICB2YXIgdGYgPSB0aGlzLnR2LiRyZWZzLmNoYXJ0LmludGVydmFsX21zO1xuICAgICAgdmFyIHRfbmV4dCA9IGxhc3RbMF0gKyB0ZjtcbiAgICAgIHZhciBub3cgPSBkYXRhLnQgfHwgdXRpbHMubm93KCk7XG4gICAgICB2YXIgdCA9IG5vdyA+PSB0X25leHQgPyBub3cgLSBub3cgJSB0ZiA6IGxhc3RbMF07IC8vIFVwZGF0ZSB0aGUgZW50aXJlIGNhbmRsZVxuXG4gICAgICBpZiAoY2FuZGxlLmxlbmd0aCA+PSA2KSB7XG4gICAgICAgIHQgPSBjYW5kbGVbMF07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjYW5kbGUgPSBbdF0uY29uY2F0KF90b0NvbnN1bWFibGVBcnJheShjYW5kbGUpKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5hZ2cucHVzaCgnb2hsY3YnLCBjYW5kbGUpO1xuICAgICAgdGhpcy51cGRhdGVfb3ZlcmxheXMoZGF0YSwgdCwgdGYpO1xuICAgICAgcmV0dXJuIHQgPj0gdF9uZXh0O1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJ1cGRhdGVfdGlja1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB1cGRhdGVfdGljayhkYXRhKSB7XG4gICAgICB2YXIgb2hsY3YgPSB0aGlzLmRhdGEuY2hhcnQuZGF0YTtcbiAgICAgIHZhciBsYXN0ID0gb2hsY3Zbb2hsY3YubGVuZ3RoIC0gMV07XG4gICAgICB2YXIgdGljayA9IGRhdGFbJ3ByaWNlJ107XG4gICAgICB2YXIgdm9sdW1lID0gZGF0YVsndm9sdW1lJ10gfHwgMDtcbiAgICAgIHZhciB0ZiA9IHRoaXMudHYuJHJlZnMuY2hhcnQuaW50ZXJ2YWxfbXM7XG5cbiAgICAgIGlmICghdGYpIHtcbiAgICAgICAgcmV0dXJuIGNvbnNvbGUud2FybignRGVmaW5lIHRoZSBtYWluIHRpbWVmcmFtZScpO1xuICAgICAgfVxuXG4gICAgICB2YXIgbm93ID0gZGF0YS50IHx8IHV0aWxzLm5vdygpO1xuICAgICAgaWYgKCFsYXN0KSBsYXN0ID0gW25vdyAtIG5vdyAlIHRmXTtcbiAgICAgIHZhciB0X25leHQgPSBsYXN0WzBdICsgdGY7XG4gICAgICB2YXIgdCA9IG5vdyA+PSB0X25leHQgPyBub3cgLSBub3cgJSB0ZiA6IGxhc3RbMF07XG5cbiAgICAgIGlmICgodCA+PSB0X25leHQgfHwgIW9obGN2Lmxlbmd0aCkgJiYgdGljayAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIC8vIEFuZCBuZXcgemVyby1oZWlnaHQgY2FuZGxlXG4gICAgICAgIHZhciBuYyA9IFt0LCB0aWNrLCB0aWNrLCB0aWNrLCB0aWNrLCB2b2x1bWVdO1xuICAgICAgICB0aGlzLmFnZy5wdXNoKCdvaGxjdicsIG5jLCB0Zik7XG4gICAgICAgIG9obGN2LnB1c2gobmMpO1xuICAgICAgICB0aGlzLnNjcm9sbF90byh0KTtcbiAgICAgIH0gZWxzZSBpZiAodGljayAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIC8vIFVwZGF0ZSBhbiBleGlzdGluZyBvbmVcbiAgICAgICAgLy8gVE9ETzogbWFrZSBhIHNlcGFyYXRlIGNsYXNzIFNhbXBsZXJcbiAgICAgICAgbGFzdFsyXSA9IE1hdGgubWF4KHRpY2ssIGxhc3RbMl0pO1xuICAgICAgICBsYXN0WzNdID0gTWF0aC5taW4odGljaywgbGFzdFszXSk7XG4gICAgICAgIGxhc3RbNF0gPSB0aWNrO1xuICAgICAgICBsYXN0WzVdICs9IHZvbHVtZTtcbiAgICAgICAgdGhpcy5hZ2cucHVzaCgnb2hsY3YnLCBsYXN0LCB0Zik7XG4gICAgICB9XG5cbiAgICAgIHRoaXMudXBkYXRlX292ZXJsYXlzKGRhdGEsIHQsIHRmKTtcbiAgICAgIHJldHVybiB0ID49IHRfbmV4dDtcbiAgICB9IC8vIFVwZGF0ZXMgYWxsIG92ZXJsYXlzIHdpdGggZ2l2ZW4gdmFsdWVzLlxuXG4gIH0sIHtcbiAgICBrZXk6IFwidXBkYXRlX292ZXJsYXlzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHVwZGF0ZV9vdmVybGF5cyhkYXRhLCB0LCB0Zikge1xuICAgICAgZm9yICh2YXIgayBpbiBkYXRhKSB7XG4gICAgICAgIGlmIChrID09PSAncHJpY2UnIHx8IGsgPT09ICd2b2x1bWUnIHx8IGsgPT09ICdjYW5kbGUnIHx8IGsgPT09ICd0Jykge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGsuaW5jbHVkZXMoJ2RhdGFzZXRzLicpKSB7XG4gICAgICAgICAgdGhpcy5hZ2cucHVzaChrLCBkYXRhW2tdLCB0Zik7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkoZGF0YVtrXSkpIHtcbiAgICAgICAgICB2YXIgdmFsID0gW2RhdGFba11dO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhbCA9IGRhdGFba107XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIWsuaW5jbHVkZXMoJy5kYXRhJykpIGsgKz0gJy5kYXRhJztcbiAgICAgICAgdGhpcy5hZ2cucHVzaChrLCBbdF0uY29uY2F0KF90b0NvbnN1bWFibGVBcnJheSh2YWwpKSwgdGYpO1xuICAgICAgfVxuICAgIH0gLy8gUmV0dXJucyBhcnJheSBvZiBvYmplY3RzIG1hdGNoaW5nIHF1ZXJ5LlxuICAgIC8vIE9iamVjdCBjb250YWlucyB7IHBhcmVudCwgaW5kZXgsIHZhbHVlIH1cbiAgICAvLyBUT0RPOiBxdWVyeSBjYWNoaW5nXG5cbiAgfSwge1xuICAgIGtleTogXCJnZXRfYnlfcXVlcnlcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0X2J5X3F1ZXJ5KHF1ZXJ5LCBjaHVjaykge1xuICAgICAgdmFyIHR1cGxlID0gcXVlcnkuc3BsaXQoJy4nKTtcblxuICAgICAgc3dpdGNoICh0dXBsZVswXSkge1xuICAgICAgICBjYXNlICdjaGFydCc6XG4gICAgICAgICAgdmFyIHJlc3VsdCA9IHRoaXMuY2hhcnRfYXNfcGl2KHR1cGxlKTtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlICdvbmNoYXJ0JzpcbiAgICAgICAgY2FzZSAnb2ZmY2hhcnQnOlxuICAgICAgICAgIHJlc3VsdCA9IHRoaXMucXVlcnlfc2VhcmNoKHF1ZXJ5LCB0dXBsZSk7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSAnZGF0YXNldHMnOlxuICAgICAgICAgIHJlc3VsdCA9IHRoaXMucXVlcnlfc2VhcmNoKHF1ZXJ5LCB0dXBsZSk7XG5cbiAgICAgICAgICB2YXIgX2l0ZXJhdG9yNCA9IGRjX2NvcmVfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlcihyZXN1bHQpLFxuICAgICAgICAgICAgICBfc3RlcDQ7XG5cbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgZm9yIChfaXRlcmF0b3I0LnMoKTsgIShfc3RlcDQgPSBfaXRlcmF0b3I0Lm4oKSkuZG9uZTspIHtcbiAgICAgICAgICAgICAgdmFyIHIgPSBfc3RlcDQudmFsdWU7XG5cbiAgICAgICAgICAgICAgaWYgKHIuaSA9PT0gJ2RhdGEnKSB7XG4gICAgICAgICAgICAgICAgci52ID0gdGhpcy5kc3Nbci5wLmlkXS5kYXRhKCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgIF9pdGVyYXRvcjQuZShlcnIpO1xuICAgICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICBfaXRlcmF0b3I0LmYoKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIC8qIFNob3VsZCBnZXQoJy4nKSByZXR1cm4gYWxzbyB0aGUgY2hhcnQ/ICovXG5cbiAgICAgICAgICAvKmxldCBjaCA9IHRoaXMuY2hhcnRfYXNfcXVlcnkoW1xuICAgICAgICAgICAgICAnY2hhcnQnLFxuICAgICAgICAgICAgICB0dXBsZVsxXVxuICAgICAgICAgIF0pKi9cbiAgICAgICAgICB2YXIgb24gPSB0aGlzLnF1ZXJ5X3NlYXJjaChxdWVyeSwgWydvbmNoYXJ0JywgdHVwbGVbMF0sIHR1cGxlWzFdXSk7XG4gICAgICAgICAgdmFyIG9mZiA9IHRoaXMucXVlcnlfc2VhcmNoKHF1ZXJ5LCBbJ29mZmNoYXJ0JywgdHVwbGVbMF0sIHR1cGxlWzFdXSk7XG4gICAgICAgICAgcmVzdWx0ID0gW10uY29uY2F0KF90b0NvbnN1bWFibGVBcnJheShvbiksIF90b0NvbnN1bWFibGVBcnJheShvZmYpKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHJlc3VsdC5maWx0ZXIoZnVuY3Rpb24gKHgpIHtcbiAgICAgICAgcmV0dXJuICEoeC52IHx8IHt9KS5sb2NrZWQgfHwgY2h1Y2s7XG4gICAgICB9KTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiY2hhcnRfYXNfcGl2XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNoYXJ0X2FzX3Bpdih0dXBsZSkge1xuICAgICAgdmFyIGZpZWxkID0gdHVwbGVbMV07XG4gICAgICBpZiAoZmllbGQpIHJldHVybiBbe1xuICAgICAgICBwOiB0aGlzLmRhdGEuY2hhcnQsXG4gICAgICAgIGk6IGZpZWxkLFxuICAgICAgICB2OiB0aGlzLmRhdGEuY2hhcnRbZmllbGRdXG4gICAgICB9XTtlbHNlIHJldHVybiBbe1xuICAgICAgICBwOiB0aGlzLmRhdGEsXG4gICAgICAgIGk6ICdjaGFydCcsXG4gICAgICAgIHY6IHRoaXMuZGF0YS5jaGFydFxuICAgICAgfV07XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInF1ZXJ5X3NlYXJjaFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBxdWVyeV9zZWFyY2gocXVlcnksIHR1cGxlKSB7XG4gICAgICB2YXIgX3RoaXMzID0gdGhpcztcblxuICAgICAgdmFyIHNpZGUgPSB0dXBsZVswXTtcbiAgICAgIHZhciBwYXRoID0gdHVwbGVbMV0gfHwgJyc7XG4gICAgICB2YXIgZmllbGQgPSB0dXBsZVsyXTtcbiAgICAgIHZhciBhcnIgPSB0aGlzLmRhdGFbc2lkZV0uZmlsdGVyKGZ1bmN0aW9uICh4KSB7XG4gICAgICAgIHJldHVybiB4LmlkID09PSBxdWVyeSB8fCB4LmlkICYmIHguaWQuaW5jbHVkZXMocGF0aCkgfHwgeC5uYW1lID09PSBxdWVyeSB8fCB4Lm5hbWUgJiYgeC5uYW1lLmluY2x1ZGVzKHBhdGgpIHx8IHF1ZXJ5LmluY2x1ZGVzKCh4LnNldHRpbmdzIHx8IHt9KS4kdXVpZCk7XG4gICAgICB9KTtcblxuICAgICAgaWYgKGZpZWxkKSB7XG4gICAgICAgIHJldHVybiBhcnIubWFwKGZ1bmN0aW9uICh4KSB7XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHA6IHgsXG4gICAgICAgICAgICBpOiBmaWVsZCxcbiAgICAgICAgICAgIHY6IHhbZmllbGRdXG4gICAgICAgICAgfTtcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBhcnIubWFwKGZ1bmN0aW9uICh4LCBpKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgcDogX3RoaXMzLmRhdGFbc2lkZV0sXG4gICAgICAgICAgaTogX3RoaXMzLmRhdGFbc2lkZV0uaW5kZXhPZih4KSxcbiAgICAgICAgICB2OiB4XG4gICAgICAgIH07XG4gICAgICB9KTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwibWVyZ2Vfb2JqZWN0c1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBtZXJnZV9vYmplY3RzKG9iaiwgZGF0YSwgbmV3X29iaikge1xuICAgICAgaWYgKG5ld19vYmogPT09IHZvaWQgMCkge1xuICAgICAgICBuZXdfb2JqID0ge307XG4gICAgICB9XG5cbiAgICAgIC8vIFRoZSBvbmx5IHdheSB0byBnZXQgVnVlIHRvIHVwZGF0ZSBhbGwgc3R1ZmZcbiAgICAgIC8vIHJlYWN0aXZlbHkgaXMgdG8gY3JlYXRlIGEgYnJhbmQgbmV3IG9iamVjdC5cbiAgICAgIC8vIFRPRE86IElzIHRoZXJlIGEgc2ltcGxlciBhcHByb2FjaD9cbiAgICAgIE9iamVjdC5hc3NpZ24obmV3X29iaiwgb2JqLnYpO1xuICAgICAgT2JqZWN0LmFzc2lnbihuZXdfb2JqLCBkYXRhKTtcbiAgICAgIHRoaXMudHYuJHNldChvYmoucCwgb2JqLmksIG5ld19vYmopO1xuICAgIH0gLy8gTWVyZ2Ugb3ZlcmxhcHBpbmcgdGltZSBzZXJpZXNcblxuICB9LCB7XG4gICAga2V5OiBcIm1lcmdlX3RzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG1lcmdlX3RzKG9iaiwgZGF0YSkge1xuICAgICAgLy8gQXNzdW1lIHRoYXQgYm90aCBhcnJheXMgYXJlIHByZS1zb3J0ZWRcbiAgICAgIGlmICghZGF0YS5sZW5ndGgpIHJldHVybiBvYmoudjtcbiAgICAgIHZhciByMSA9IFtvYmoudlswXVswXSwgb2JqLnZbb2JqLnYubGVuZ3RoIC0gMV1bMF1dO1xuICAgICAgdmFyIHIyID0gW2RhdGFbMF1bMF0sIGRhdGFbZGF0YS5sZW5ndGggLSAxXVswXV07IC8vIE92ZXJsYXBcblxuICAgICAgdmFyIG8gPSBbTWF0aC5tYXgocjFbMF0sIHIyWzBdKSwgTWF0aC5taW4ocjFbMV0sIHIyWzFdKV07XG5cbiAgICAgIGlmIChvWzFdID49IG9bMF0pIHtcbiAgICAgICAgdmFyIF9vYmokdiwgX2RhdGE7XG5cbiAgICAgICAgdmFyIF90aGlzJHRzX292ZXJsYXAgPSB0aGlzLnRzX292ZXJsYXAob2JqLnYsIGRhdGEsIG8pLFxuICAgICAgICAgICAgb2QgPSBfdGhpcyR0c19vdmVybGFwLm9kLFxuICAgICAgICAgICAgZDEgPSBfdGhpcyR0c19vdmVybGFwLmQxLFxuICAgICAgICAgICAgZDIgPSBfdGhpcyR0c19vdmVybGFwLmQyO1xuXG4gICAgICAgIChfb2JqJHYgPSBvYmoudikuc3BsaWNlLmFwcGx5KF9vYmokdiwgX3RvQ29uc3VtYWJsZUFycmF5KGQxKSk7XG5cbiAgICAgICAgKF9kYXRhID0gZGF0YSkuc3BsaWNlLmFwcGx5KF9kYXRhLCBfdG9Db25zdW1hYmxlQXJyYXkoZDIpKTsgLy8gRHN0ID09PSBPdmVybGFwID09PSBTcmNcblxuXG4gICAgICAgIGlmICghb2JqLnYubGVuZ3RoICYmICFkYXRhLmxlbmd0aCkge1xuICAgICAgICAgIHRoaXMudHYuJHNldChvYmoucCwgb2JqLmksIG9kKTtcbiAgICAgICAgICByZXR1cm4gb2JqLnY7XG4gICAgICAgIH0gLy8gSWYgc3JjIGlzIHRvdGFsbHkgY29udGFpbmVkIGluIGRzdFxuXG5cbiAgICAgICAgaWYgKCFkYXRhLmxlbmd0aCkge1xuICAgICAgICAgIGRhdGEgPSBvYmoudi5zcGxpY2UoZDFbMF0pO1xuICAgICAgICB9IC8vIElmIGRzdCBpcyB0b3RhbGx5IGNvbnRhaW5lZCBpbiBzcmNcblxuXG4gICAgICAgIGlmICghb2JqLnYubGVuZ3RoKSB7XG4gICAgICAgICAgb2JqLnYgPSBkYXRhLnNwbGljZShkMlswXSk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnR2LiRzZXQob2JqLnAsIG9iai5pLCB0aGlzLmNvbWJpbmUob2JqLnYsIG9kLCBkYXRhKSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLnR2LiRzZXQob2JqLnAsIG9iai5pLCB0aGlzLmNvbWJpbmUob2JqLnYsIFtdLCBkYXRhKSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBvYmoudjtcbiAgICB9IC8vIFRPRE86IHJldmlldyBwZXJmb3JtYW5jZSwgbW92ZSB0byB3b3JrZXJcblxuICB9LCB7XG4gICAga2V5OiBcInRzX292ZXJsYXBcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdHNfb3ZlcmxhcChhcnIxLCBhcnIyLCByYW5nZSkge1xuICAgICAgdmFyIHQxID0gcmFuZ2VbMF07XG4gICAgICB2YXIgdDIgPSByYW5nZVsxXTtcbiAgICAgIHZhciB0cyA9IHt9OyAvLyB0aW1lc3RhbXAgbWFwXG5cbiAgICAgIHZhciBhMSA9IGFycjEuZmlsdGVyKGZ1bmN0aW9uICh4KSB7XG4gICAgICAgIHJldHVybiB4WzBdID49IHQxICYmIHhbMF0gPD0gdDI7XG4gICAgICB9KTtcbiAgICAgIHZhciBhMiA9IGFycjIuZmlsdGVyKGZ1bmN0aW9uICh4KSB7XG4gICAgICAgIHJldHVybiB4WzBdID49IHQxICYmIHhbMF0gPD0gdDI7XG4gICAgICB9KTsgLy8gSW5kaWNlcyBvZiBzZWdtZW50c1xuXG4gICAgICB2YXIgaWQxMSA9IGFycjEuaW5kZXhPZihhMVswXSk7XG4gICAgICB2YXIgaWQxMiA9IGFycjEuaW5kZXhPZihhMVthMS5sZW5ndGggLSAxXSk7XG4gICAgICB2YXIgaWQyMSA9IGFycjIuaW5kZXhPZihhMlswXSk7XG4gICAgICB2YXIgaWQyMiA9IGFycjIuaW5kZXhPZihhMlthMi5sZW5ndGggLSAxXSk7XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYTEubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdHNbYTFbaV1bMF1dID0gYTFbaV07XG4gICAgICB9XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYTIubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdHNbYTJbaV1bMF1dID0gYTJbaV07XG4gICAgICB9XG5cbiAgICAgIHZhciB0c19zb3J0ZWQgPSBPYmplY3Qua2V5cyh0cykuc29ydCgpO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgb2Q6IHRzX3NvcnRlZC5tYXAoZnVuY3Rpb24gKHgpIHtcbiAgICAgICAgICByZXR1cm4gdHNbeF07XG4gICAgICAgIH0pLFxuICAgICAgICBkMTogW2lkMTEsIGlkMTIgLSBpZDExICsgMV0sXG4gICAgICAgIGQyOiBbaWQyMSwgaWQyMiAtIGlkMjEgKyAxXVxuICAgICAgfTtcbiAgICB9IC8vIENvbWJpbmUgcGFydHMgdG9nZXRoZXI6XG4gICAgLy8gKGRlc3RpbmF0aW9uLCBvdmVybGFwLCBzb3VyY2UpXG5cbiAgfSwge1xuICAgIGtleTogXCJjb21iaW5lXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNvbWJpbmUoZHN0LCBvLCBzcmMpIHtcbiAgICAgIGZ1bmN0aW9uIGxhc3QoYXJyKSB7XG4gICAgICAgIHJldHVybiBhcnJbYXJyLmxlbmd0aCAtIDFdWzBdO1xuICAgICAgfVxuXG4gICAgICBpZiAoIWRzdC5sZW5ndGgpIHtcbiAgICAgICAgZHN0ID0gbztcbiAgICAgICAgbyA9IFtdO1xuICAgICAgfVxuXG4gICAgICBpZiAoIXNyYy5sZW5ndGgpIHtcbiAgICAgICAgc3JjID0gbztcbiAgICAgICAgbyA9IFtdO1xuICAgICAgfSAvLyBUaGUgb3ZlcmxhcCByaWdodCBpbiB0aGUgbWlkZGxlXG5cblxuICAgICAgaWYgKHNyY1swXVswXSA+PSBkc3RbMF1bMF0gJiYgbGFzdChzcmMpIDw9IGxhc3QoZHN0KSkge1xuICAgICAgICByZXR1cm4gT2JqZWN0LmFzc2lnbihkc3QsIG8pOyAvLyBUaGUgb3ZlcmxhcCBpcyBvbiB0aGUgcmlnaHRcbiAgICAgIH0gZWxzZSBpZiAobGFzdChzcmMpID4gbGFzdChkc3QpKSB7XG4gICAgICAgIC8vIFBzaCguLi4pIGlzIGZhc3RlciBidXQgY2FuIG92ZXJmbG93IHRoZSBzdGFja1xuICAgICAgICBpZiAoby5sZW5ndGggPCAxMDAwMDAgJiYgc3JjLmxlbmd0aCA8IDEwMDAwMCkge1xuICAgICAgICAgIHZhciBfZHN0O1xuXG4gICAgICAgICAgKF9kc3QgPSBkc3QpLnB1c2guYXBwbHkoX2RzdCwgX3RvQ29uc3VtYWJsZUFycmF5KG8pLmNvbmNhdChfdG9Db25zdW1hYmxlQXJyYXkoc3JjKSkpO1xuXG4gICAgICAgICAgcmV0dXJuIGRzdDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gZHN0LmNvbmNhdChvLCBzcmMpO1xuICAgICAgICB9IC8vIFRoZSBvdmVybGFwIGlzIG9uIHRoZSBsZWZ0XG5cbiAgICAgIH0gZWxzZSBpZiAoc3JjWzBdWzBdIDwgZHN0WzBdWzBdKSB7XG4gICAgICAgIC8vIFB1c2goLi4uKSBpcyBmYXN0ZXIgYnV0IGNhbiBvdmVyZmxvdyB0aGUgc3RhY2tcbiAgICAgICAgaWYgKG8ubGVuZ3RoIDwgMTAwMDAwICYmIHNyYy5sZW5ndGggPCAxMDAwMDApIHtcbiAgICAgICAgICB2YXIgX3NyYztcblxuICAgICAgICAgIChfc3JjID0gc3JjKS5wdXNoLmFwcGx5KF9zcmMsIF90b0NvbnN1bWFibGVBcnJheShvKS5jb25jYXQoX3RvQ29uc3VtYWJsZUFycmF5KGRzdCkpKTtcblxuICAgICAgICAgIHJldHVybiBzcmM7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIHNyYy5jb25jYXQobywgZHN0KTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgfVxuICAgIH0gLy8gU2ltcGxlIGRhdGEtcG9pbnQgbWVyZ2UgKGZhc3RlcilcblxuICB9LCB7XG4gICAga2V5OiBcImZhc3RfbWVyZ2VcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZmFzdF9tZXJnZShkYXRhLCBwb2ludCwgbWFpbikge1xuICAgICAgaWYgKG1haW4gPT09IHZvaWQgMCkge1xuICAgICAgICBtYWluID0gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgaWYgKCFkYXRhKSByZXR1cm47XG4gICAgICB2YXIgbGFzdF90ID0gKGRhdGFbZGF0YS5sZW5ndGggLSAxXSB8fCBbXSlbMF07XG4gICAgICB2YXIgdXBkX3QgPSBwb2ludFswXTtcblxuICAgICAgaWYgKCFkYXRhLmxlbmd0aCB8fCB1cGRfdCA+IGxhc3RfdCkge1xuICAgICAgICBkYXRhLnB1c2gocG9pbnQpO1xuXG4gICAgICAgIGlmIChtYWluICYmIHRoaXMuc2V0dC5hdXRvX3Njcm9sbCkge1xuICAgICAgICAgIHRoaXMuc2Nyb2xsX3RvKHVwZF90KTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmICh1cGRfdCA9PT0gbGFzdF90KSB7XG4gICAgICAgIGlmIChtYWluKSB7XG4gICAgICAgICAgdGhpcy50di4kc2V0KGRhdGEsIGRhdGEubGVuZ3RoIC0gMSwgcG9pbnQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGRhdGFbZGF0YS5sZW5ndGggLSAxXSA9IHBvaW50O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInNjcm9sbF90b1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzY3JvbGxfdG8odCkge1xuICAgICAgaWYgKHRoaXMudHYuJHJlZnMuY2hhcnQuY3Vyc29yLmxvY2tlZCkgcmV0dXJuO1xuICAgICAgdmFyIGxhc3QgPSB0aGlzLnR2LiRyZWZzLmNoYXJ0Lmxhc3RfY2FuZGxlO1xuICAgICAgaWYgKCFsYXN0KSByZXR1cm47XG4gICAgICB2YXIgdGwgPSBsYXN0WzBdO1xuICAgICAgdmFyIGQgPSB0aGlzLnR2LmdldFJhbmdlKClbMV0gLSB0bDtcbiAgICAgIGlmIChkID4gMCkgdGhpcy50dltcImdvdG9cIl0odCArIGQpO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBEQ0NvcmU7XG59KERDRXZlbnRzKTtcblxuXG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvaGVscGVycy9zZXR0X3Byb3h5LmpzXG4vLyBTZW5kcyBhbGwgZGMuc2V0dCBjaGFuZ2VzIHRvIHRoZSB3ZWItd29ya2VyXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIGZ1bmN0aW9uIHNldHRfcHJveHkoc2V0dCwgd3cpIHtcbiAgdmFyIGggPSB7XG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoc2V0dCwgaykge1xuICAgICAgcmV0dXJuIHNldHRba107XG4gICAgfSxcbiAgICBzZXQ6IGZ1bmN0aW9uIHNldChzZXR0LCBrLCB2KSB7XG4gICAgICBzZXR0W2tdID0gdjtcbiAgICAgIHd3Lmp1c3QoJ3VwZGF0ZS1kYy1zZXR0aW5ncycsIHNldHQpO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9O1xuICB3dy5qdXN0KCd1cGRhdGUtZGMtc2V0dGluZ3MnLCBzZXR0KTtcbiAgcmV0dXJuIG5ldyBQcm94eShzZXR0LCBoKTtcbn1cbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9oZWxwZXJzL2FnZ190b29sLmpzXG5cblxuLy8gVGljayBhZ2dyZWdhdGlvblxuXG5cbnZhciBBZ2dUb29sID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gQWdnVG9vbChkYywgX2ludCkge1xuICAgIGlmIChfaW50ID09PSB2b2lkIDApIHtcbiAgICAgIF9pbnQgPSAxMDA7XG4gICAgfVxuXG4gICAgY2xhc3NDYWxsQ2hlY2tfY2xhc3NDYWxsQ2hlY2sodGhpcywgQWdnVG9vbCk7XG5cbiAgICB0aGlzLnN5bWJvbHMgPSB7fTtcbiAgICB0aGlzW1wiaW50XCJdID0gX2ludDsgLy8gSXRhcnZhbCBpbiBtc1xuXG4gICAgdGhpcy5kYyA9IGRjO1xuICAgIHRoaXMuc3RfaWQgPSBudWxsO1xuICAgIHRoaXMuZGF0YV9jaGFuZ2VkID0gZmFsc2U7XG4gIH1cblxuICBjcmVhdGVDbGFzc19jcmVhdGVDbGFzcyhBZ2dUb29sLCBbe1xuICAgIGtleTogXCJwdXNoXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHB1c2goc3ltLCB1cGQsIHRmKSB7XG4gICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgICAvLyBTdGFydCBhdXRvIHVwZGF0ZXNcbiAgICAgIGlmICghdGhpcy5zdF9pZCkge1xuICAgICAgICB0aGlzLnN0X2lkID0gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgcmV0dXJuIF90aGlzLnVwZGF0ZSgpO1xuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgdGYgPSBwYXJzZUludCh0Zik7XG4gICAgICB2YXIgb2xkID0gdGhpcy5zeW1ib2xzW3N5bV07XG4gICAgICB2YXIgdCA9IHV0aWxzLm5vdygpO1xuICAgICAgdmFyIGlzZHMgPSBzeW0uaW5jbHVkZXMoJ2RhdGFzZXRzLicpO1xuICAgICAgdGhpcy5kYXRhX2NoYW5nZWQgPSB0cnVlO1xuXG4gICAgICBpZiAoIW9sZCkge1xuICAgICAgICB0aGlzLnN5bWJvbHNbc3ltXSA9IHtcbiAgICAgICAgICB1cGQ6IHVwZCxcbiAgICAgICAgICB0OiB0LFxuICAgICAgICAgIGRhdGE6IFtdXG4gICAgICAgIH07XG4gICAgICB9IGVsc2UgaWYgKHVwZFswXSA+PSBvbGQudXBkWzBdICsgdGYgJiYgIWlzZHMpIHtcbiAgICAgICAgLy8gUmVmaW5lIHRoZSBwcmV2aW91cyBkYXRhIHBvaW50XG4gICAgICAgIHRoaXMucmVmaW5lKHN5bSwgb2xkLnVwZC5zbGljZSgpKTtcbiAgICAgICAgdGhpcy5zeW1ib2xzW3N5bV0gPSB7XG4gICAgICAgICAgdXBkOiB1cGQsXG4gICAgICAgICAgdDogdCxcbiAgICAgICAgICBkYXRhOiBbXVxuICAgICAgICB9O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gVGljayB1cGRhdGVzIHRoZSBjdXJyZW50XG4gICAgICAgIHRoaXMuc3ltYm9sc1tzeW1dLnVwZCA9IHVwZDtcbiAgICAgICAgdGhpcy5zeW1ib2xzW3N5bV0udCA9IHQ7XG4gICAgICB9XG5cbiAgICAgIGlmIChpc2RzKSB7XG4gICAgICAgIHRoaXMuc3ltYm9sc1tzeW1dLmRhdGEucHVzaCh1cGQpO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJ1cGRhdGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdXBkYXRlKCkge1xuICAgICAgdmFyIF90aGlzMiA9IHRoaXM7XG5cbiAgICAgIHZhciBvdXQgPSB7fTtcblxuICAgICAgZm9yICh2YXIgc3ltIGluIHRoaXMuc3ltYm9scykge1xuICAgICAgICB2YXIgdXBkID0gdGhpcy5zeW1ib2xzW3N5bV0udXBkO1xuXG4gICAgICAgIHN3aXRjaCAoc3ltKSB7XG4gICAgICAgICAgY2FzZSAnb2hsY3YnOlxuICAgICAgICAgICAgdmFyIGRhdGEgPSB0aGlzLmRjLmRhdGEuY2hhcnQuZGF0YTtcbiAgICAgICAgICAgIHRoaXMuZGMuZmFzdF9tZXJnZShkYXRhLCB1cGQpO1xuICAgICAgICAgICAgb3V0Lm9obGN2ID0gZGF0YS5zbGljZSgtMik7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICBpZiAoc3ltLmluY2x1ZGVzKCdkYXRhc2V0cy4nKSkge1xuICAgICAgICAgICAgICB0aGlzLnVwZGF0ZV9kcyhzeW0sIG91dCk7XG4gICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgZGF0YSA9IHRoaXMuZGMuZ2V0X29uZShcIlwiLmNvbmNhdChzeW0pKTtcbiAgICAgICAgICAgIGlmICghZGF0YSkgY29udGludWU7XG4gICAgICAgICAgICB0aGlzLmRjLmZhc3RfbWVyZ2UoZGF0YSwgdXBkLCBmYWxzZSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfSAvLyBUT0RPOiBmaWxsIGdhcHNcblxuXG4gICAgICBpZiAodGhpcy5kYXRhX2NoYW5nZWQpIHtcbiAgICAgICAgdGhpcy5kYy53dy5qdXN0KCd1cGRhdGUtZGF0YScsIG91dCk7XG4gICAgICAgIHRoaXMuZGF0YV9jaGFuZ2VkID0gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gX3RoaXMyLnVwZGF0ZSgpO1xuICAgICAgfSwgdGhpc1tcImludFwiXSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInJlZmluZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByZWZpbmUoc3ltLCB1cGQpIHtcbiAgICAgIGlmIChzeW0gPT09ICdvaGxjdicpIHtcbiAgICAgICAgdmFyIGRhdGEgPSB0aGlzLmRjLmRhdGEuY2hhcnQuZGF0YTtcbiAgICAgICAgdGhpcy5kYy5mYXN0X21lcmdlKGRhdGEsIHVwZCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgZGF0YSA9IHRoaXMuZGMuZ2V0X29uZShcIlwiLmNvbmNhdChzeW0pKTtcbiAgICAgICAgaWYgKCFkYXRhKSByZXR1cm47XG4gICAgICAgIHRoaXMuZGMuZmFzdF9tZXJnZShkYXRhLCB1cGQsIGZhbHNlKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwidXBkYXRlX2RzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHVwZGF0ZV9kcyhzeW0sIG91dCkge1xuICAgICAgdmFyIGRhdGEgPSB0aGlzLnN5bWJvbHNbc3ltXS5kYXRhO1xuXG4gICAgICBpZiAoZGF0YS5sZW5ndGgpIHtcbiAgICAgICAgb3V0W3N5bV0gPSBkYXRhO1xuICAgICAgICB0aGlzLnN5bWJvbHNbc3ltXS5kYXRhID0gW107XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImNsZWFyXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNsZWFyKCkge1xuICAgICAgdGhpcy5zeW1ib2xzID0ge307XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIEFnZ1Rvb2w7XG59KCk7XG5cblxuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL2hlbHBlcnMvZGF0YWN1YmUuanNcblxuXG5cblxuXG5cblxuXG5mdW5jdGlvbiBkYXRhY3ViZV9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyKG8sIGFsbG93QXJyYXlMaWtlKSB7IHZhciBpdDsgaWYgKHR5cGVvZiBTeW1ib2wgPT09IFwidW5kZWZpbmVkXCIgfHwgb1tTeW1ib2wuaXRlcmF0b3JdID09IG51bGwpIHsgaWYgKEFycmF5LmlzQXJyYXkobykgfHwgKGl0ID0gZGF0YWN1YmVfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkobykpIHx8IGFsbG93QXJyYXlMaWtlICYmIG8gJiYgdHlwZW9mIG8ubGVuZ3RoID09PSBcIm51bWJlclwiKSB7IGlmIChpdCkgbyA9IGl0OyB2YXIgaSA9IDA7IHZhciBGID0gZnVuY3Rpb24gRigpIHt9OyByZXR1cm4geyBzOiBGLCBuOiBmdW5jdGlvbiBuKCkgeyBpZiAoaSA+PSBvLmxlbmd0aCkgcmV0dXJuIHsgZG9uZTogdHJ1ZSB9OyByZXR1cm4geyBkb25lOiBmYWxzZSwgdmFsdWU6IG9baSsrXSB9OyB9LCBlOiBmdW5jdGlvbiBlKF9lKSB7IHRocm93IF9lOyB9LCBmOiBGIH07IH0gdGhyb3cgbmV3IFR5cGVFcnJvcihcIkludmFsaWQgYXR0ZW1wdCB0byBpdGVyYXRlIG5vbi1pdGVyYWJsZSBpbnN0YW5jZS5cXG5JbiBvcmRlciB0byBiZSBpdGVyYWJsZSwgbm9uLWFycmF5IG9iamVjdHMgbXVzdCBoYXZlIGEgW1N5bWJvbC5pdGVyYXRvcl0oKSBtZXRob2QuXCIpOyB9IHZhciBub3JtYWxDb21wbGV0aW9uID0gdHJ1ZSwgZGlkRXJyID0gZmFsc2UsIGVycjsgcmV0dXJuIHsgczogZnVuY3Rpb24gcygpIHsgaXQgPSBvW1N5bWJvbC5pdGVyYXRvcl0oKTsgfSwgbjogZnVuY3Rpb24gbigpIHsgdmFyIHN0ZXAgPSBpdC5uZXh0KCk7IG5vcm1hbENvbXBsZXRpb24gPSBzdGVwLmRvbmU7IHJldHVybiBzdGVwOyB9LCBlOiBmdW5jdGlvbiBlKF9lMikgeyBkaWRFcnIgPSB0cnVlOyBlcnIgPSBfZTI7IH0sIGY6IGZ1bmN0aW9uIGYoKSB7IHRyeSB7IGlmICghbm9ybWFsQ29tcGxldGlvbiAmJiBpdFtcInJldHVyblwiXSAhPSBudWxsKSBpdFtcInJldHVyblwiXSgpOyB9IGZpbmFsbHkgeyBpZiAoZGlkRXJyKSB0aHJvdyBlcnI7IH0gfSB9OyB9XG5cbmZ1bmN0aW9uIGRhdGFjdWJlX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5KG8sIG1pbkxlbikgeyBpZiAoIW8pIHJldHVybjsgaWYgKHR5cGVvZiBvID09PSBcInN0cmluZ1wiKSByZXR1cm4gZGF0YWN1YmVfYXJyYXlMaWtlVG9BcnJheShvLCBtaW5MZW4pOyB2YXIgbiA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvKS5zbGljZSg4LCAtMSk7IGlmIChuID09PSBcIk9iamVjdFwiICYmIG8uY29uc3RydWN0b3IpIG4gPSBvLmNvbnN0cnVjdG9yLm5hbWU7IGlmIChuID09PSBcIk1hcFwiIHx8IG4gPT09IFwiU2V0XCIpIHJldHVybiBBcnJheS5mcm9tKG8pOyBpZiAobiA9PT0gXCJBcmd1bWVudHNcIiB8fCAvXig/OlVpfEkpbnQoPzo4fDE2fDMyKSg/OkNsYW1wZWQpP0FycmF5JC8udGVzdChuKSkgcmV0dXJuIGRhdGFjdWJlX2FycmF5TGlrZVRvQXJyYXkobywgbWluTGVuKTsgfVxuXG5mdW5jdGlvbiBkYXRhY3ViZV9hcnJheUxpa2VUb0FycmF5KGFyciwgbGVuKSB7IGlmIChsZW4gPT0gbnVsbCB8fCBsZW4gPiBhcnIubGVuZ3RoKSBsZW4gPSBhcnIubGVuZ3RoOyBmb3IgKHZhciBpID0gMCwgYXJyMiA9IG5ldyBBcnJheShsZW4pOyBpIDwgbGVuOyBpKyspIHsgYXJyMltpXSA9IGFycltpXTsgfSByZXR1cm4gYXJyMjsgfVxuXG5mdW5jdGlvbiBkYXRhY3ViZV9jcmVhdGVTdXBlcihEZXJpdmVkKSB7IHZhciBoYXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0ID0gZGF0YWN1YmVfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KCk7IHJldHVybiBmdW5jdGlvbiBfY3JlYXRlU3VwZXJJbnRlcm5hbCgpIHsgdmFyIFN1cGVyID0gX2dldFByb3RvdHlwZU9mKERlcml2ZWQpLCByZXN1bHQ7IGlmIChoYXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KSB7IHZhciBOZXdUYXJnZXQgPSBfZ2V0UHJvdG90eXBlT2YodGhpcykuY29uc3RydWN0b3I7IHJlc3VsdCA9IFJlZmxlY3QuY29uc3RydWN0KFN1cGVyLCBhcmd1bWVudHMsIE5ld1RhcmdldCk7IH0gZWxzZSB7IHJlc3VsdCA9IFN1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7IH0gcmV0dXJuIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIHJlc3VsdCk7IH07IH1cblxuZnVuY3Rpb24gZGF0YWN1YmVfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KCkgeyBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwidW5kZWZpbmVkXCIgfHwgIVJlZmxlY3QuY29uc3RydWN0KSByZXR1cm4gZmFsc2U7IGlmIChSZWZsZWN0LmNvbnN0cnVjdC5zaGFtKSByZXR1cm4gZmFsc2U7IGlmICh0eXBlb2YgUHJveHkgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIHRydWU7IHRyeSB7IEJvb2xlYW4ucHJvdG90eXBlLnZhbHVlT2YuY2FsbChSZWZsZWN0LmNvbnN0cnVjdChCb29sZWFuLCBbXSwgZnVuY3Rpb24gKCkge30pKTsgcmV0dXJuIHRydWU7IH0gY2F0Y2ggKGUpIHsgcmV0dXJuIGZhbHNlOyB9IH1cblxuLy8gTWFpbiBEYXRhSGVscGVyIGNsYXNzLiBBIGNvbnRhaW5lciBmb3IgZGF0YSxcbi8vIHdoaWNoIHdvcmtzIGFzIGEgcHJveHkgYW5kIENSVUQgaW50ZXJmYWNlXG5cblxuXG4gLy8gSW50ZXJmYWNlIG1ldGhvZHMuIFByaXZhdGUgbWV0aG9kcyBpbiBkY19jb3JlLmpzXG5cbnZhciBEYXRhQ3ViZSA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX0RDQ29yZSkge1xuICBfaW5oZXJpdHMoRGF0YUN1YmUsIF9EQ0NvcmUpO1xuXG4gIHZhciBfc3VwZXIgPSBkYXRhY3ViZV9jcmVhdGVTdXBlcihEYXRhQ3ViZSk7XG5cbiAgZnVuY3Rpb24gRGF0YUN1YmUoZGF0YSwgc2V0dCkge1xuICAgIHZhciBfdGhpcztcblxuICAgIGlmIChkYXRhID09PSB2b2lkIDApIHtcbiAgICAgIGRhdGEgPSB7fTtcbiAgICB9XG5cbiAgICBpZiAoc2V0dCA9PT0gdm9pZCAwKSB7XG4gICAgICBzZXR0ID0ge307XG4gICAgfVxuXG4gICAgY2xhc3NDYWxsQ2hlY2tfY2xhc3NDYWxsQ2hlY2sodGhpcywgRGF0YUN1YmUpO1xuXG4gICAgdmFyIGRlZl9zZXR0ID0ge1xuICAgICAgYWdncmVnYXRpb246IDEwMCxcbiAgICAgIC8vIFVwZGF0ZSBhZ2dyZWdhdGlvbiBpbnRlcnZhbFxuICAgICAgc2NyaXB0X2RlcHRoOiAwLFxuICAgICAgLy8gMCA9PT0gRXhlYyBvbiBhbGwgZGF0YVxuICAgICAgYXV0b19zY3JvbGw6IHRydWUsXG4gICAgICAvLyBBdXRvIHNjcm9sbCB0byBhIG5ldyBjYW5kbGVcbiAgICAgIHNjcmlwdHM6IHRydWUsXG4gICAgICAvLyBFbmFibGUgb3ZlcmxheXMgc2NyaXB0cyxcbiAgICAgIHd3X3JhbV9saW1pdDogMCxcbiAgICAgIC8vIFdlYldvcmtlciBSQU0gbGltaXQgKE1CKVxuICAgICAgbm9kZV91cmw6IG51bGwsXG4gICAgICAvLyBVc2Ugbm9kZS5qcyBpbnN0ZWFkIG9mIFdXXG4gICAgICBzaGlmdF9tZWFzdXJlOiB0cnVlIC8vIERyYXcgbWVhc3VybWVudCBzaGlmdCtjbGlja1xuXG4gICAgfTtcbiAgICBzZXR0ID0gT2JqZWN0LmFzc2lnbihkZWZfc2V0dCwgc2V0dCk7XG4gICAgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzKTtcbiAgICBfdGhpcy5zZXR0ID0gc2V0dDtcbiAgICBfdGhpcy5kYXRhID0gZGF0YTtcbiAgICBfdGhpcy5zZXR0ID0gc2V0dF9wcm94eShzZXR0LCBfdGhpcy53dyk7XG4gICAgX3RoaXMuYWdnID0gbmV3IEFnZ1Rvb2woX2Fzc2VydFRoaXNJbml0aWFsaXplZChfdGhpcyksIHNldHQuYWdncmVnYXRpb24pO1xuICAgIF90aGlzLnNlX3N0YXRlID0ge307IC8vdGhpcy5hZ2cudXBkYXRlID0gdGhpcy5hZ2dfdXBkYXRlLmJpbmQodGhpcylcblxuICAgIHJldHVybiBfdGhpcztcbiAgfSAvLyBBZGQgbmV3IG92ZXJsYXlcblxuXG4gIGNyZWF0ZUNsYXNzX2NyZWF0ZUNsYXNzKERhdGFDdWJlLCBbe1xuICAgIGtleTogXCJhZGRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gYWRkKHNpZGUsIG92ZXJsYXkpIHtcbiAgICAgIGlmIChzaWRlICE9PSAnb25jaGFydCcgJiYgc2lkZSAhPT0gJ29mZmNoYXJ0JyAmJiBzaWRlICE9PSAnZGF0YXNldHMnKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdGhpcy5kYXRhW3NpZGVdLnB1c2gob3ZlcmxheSk7XG4gICAgICB0aGlzLnVwZGF0ZV9pZHMoKTtcbiAgICAgIHJldHVybiBvdmVybGF5LmlkO1xuICAgIH0gLy8gR2V0IGFsbCBvYmplY3RzIG1hdGNoaW5nIHRoZSBxdWVyeVxuXG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldChxdWVyeSkge1xuICAgICAgcmV0dXJuIHRoaXMuZ2V0X2J5X3F1ZXJ5KHF1ZXJ5KS5tYXAoZnVuY3Rpb24gKHgpIHtcbiAgICAgICAgcmV0dXJuIHgudjtcbiAgICAgIH0pO1xuICAgIH0gLy8gR2V0IGZpcnN0IG9iamVjdCBtYXRjaGluZyB0aGUgcXVlcnlcblxuICB9LCB7XG4gICAga2V5OiBcImdldF9vbmVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0X29uZShxdWVyeSkge1xuICAgICAgcmV0dXJuIHRoaXMuZ2V0X2J5X3F1ZXJ5KHF1ZXJ5KS5tYXAoZnVuY3Rpb24gKHgpIHtcbiAgICAgICAgcmV0dXJuIHgudjtcbiAgICAgIH0pWzBdO1xuICAgIH0gLy8gU2V0IGRhdGEgKHJlYWN0aXZlbHkpXG5cbiAgfSwge1xuICAgIGtleTogXCJzZXRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2V0KHF1ZXJ5LCBkYXRhKSB7XG4gICAgICB2YXIgb2JqZWN0cyA9IHRoaXMuZ2V0X2J5X3F1ZXJ5KHF1ZXJ5KTtcblxuICAgICAgdmFyIF9pdGVyYXRvciA9IGRhdGFjdWJlX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXIob2JqZWN0cyksXG4gICAgICAgICAgX3N0ZXA7XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIGZvciAoX2l0ZXJhdG9yLnMoKTsgIShfc3RlcCA9IF9pdGVyYXRvci5uKCkpLmRvbmU7KSB7XG4gICAgICAgICAgdmFyIG9iaiA9IF9zdGVwLnZhbHVlO1xuICAgICAgICAgIHZhciBpID0gb2JqLmkgIT09IHVuZGVmaW5lZCA/IG9iai5pIDogb2JqLnAuaW5kZXhPZihvYmoudik7XG5cbiAgICAgICAgICBpZiAoaSAhPT0gLTEpIHtcbiAgICAgICAgICAgIHRoaXMudHYuJHNldChvYmoucCwgaSwgZGF0YSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgX2l0ZXJhdG9yLmUoZXJyKTtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIF9pdGVyYXRvci5mKCk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMudXBkYXRlX2lkcygpO1xuICAgIH0gLy8gTWVyZ2Ugb2JqZWN0IG9yIGFycmF5IChyZWFjdGl2ZWx5KVxuXG4gIH0sIHtcbiAgICBrZXk6IFwibWVyZ2VcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gbWVyZ2UocXVlcnksIGRhdGEpIHtcbiAgICAgIHZhciBvYmplY3RzID0gdGhpcy5nZXRfYnlfcXVlcnkocXVlcnkpO1xuXG4gICAgICB2YXIgX2l0ZXJhdG9yMiA9IGRhdGFjdWJlX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXIob2JqZWN0cyksXG4gICAgICAgICAgX3N0ZXAyO1xuXG4gICAgICB0cnkge1xuICAgICAgICBmb3IgKF9pdGVyYXRvcjIucygpOyAhKF9zdGVwMiA9IF9pdGVyYXRvcjIubigpKS5kb25lOykge1xuICAgICAgICAgIHZhciBvYmogPSBfc3RlcDIudmFsdWU7XG5cbiAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShvYmoudikpIHtcbiAgICAgICAgICAgIGlmICghQXJyYXkuaXNBcnJheShkYXRhKSkgY29udGludWU7IC8vIElmIGFycmF5IGlzIGEgdGltZXNlcmllcywgbWVyZ2UgaXQgYnkgdGltZXN0YW1wXG4gICAgICAgICAgICAvLyBlbHNlIG1lcmdlIGJ5IGl0ZW0gaW5kZXhcblxuICAgICAgICAgICAgaWYgKG9iai52WzBdICYmIG9iai52WzBdLmxlbmd0aCA+PSAyKSB7XG4gICAgICAgICAgICAgIHRoaXMubWVyZ2VfdHMob2JqLCBkYXRhKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHRoaXMubWVyZ2Vfb2JqZWN0cyhvYmosIGRhdGEsIFtdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZl90eXBlb2Yob2JqLnYpID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgdGhpcy5tZXJnZV9vYmplY3RzKG9iaiwgZGF0YSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgX2l0ZXJhdG9yMi5lKGVycik7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICBfaXRlcmF0b3IyLmYoKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy51cGRhdGVfaWRzKCk7XG4gICAgfSAvLyBSZW1vdmUgYW4gb3ZlcmxheSBieSBxdWVyeSAoaWQvdHlwZS9uYW1lLy4uLilcblxuICB9LCB7XG4gICAga2V5OiBcImRlbFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBkZWwocXVlcnkpIHtcbiAgICAgIHZhciBvYmplY3RzID0gdGhpcy5nZXRfYnlfcXVlcnkocXVlcnkpO1xuXG4gICAgICB2YXIgX2l0ZXJhdG9yMyA9IGRhdGFjdWJlX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXIob2JqZWN0cyksXG4gICAgICAgICAgX3N0ZXAzO1xuXG4gICAgICB0cnkge1xuICAgICAgICBmb3IgKF9pdGVyYXRvcjMucygpOyAhKF9zdGVwMyA9IF9pdGVyYXRvcjMubigpKS5kb25lOykge1xuICAgICAgICAgIHZhciBvYmogPSBfc3RlcDMudmFsdWU7XG4gICAgICAgICAgLy8gRmluZCBjdXJyZW50IGluZGV4IG9mIHRoZSBmaWVsZCAoaWYgbm90IGRlZmluZWQpXG4gICAgICAgICAgdmFyIGkgPSB0eXBlb2Ygb2JqLmkgIT09ICdudW1iZXInID8gb2JqLmkgOiBvYmoucC5pbmRleE9mKG9iai52KTtcblxuICAgICAgICAgIGlmIChpICE9PSAtMSkge1xuICAgICAgICAgICAgdGhpcy50di4kZGVsZXRlKG9iai5wLCBpKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICBfaXRlcmF0b3IzLmUoZXJyKTtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIF9pdGVyYXRvcjMuZigpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLnVwZGF0ZV9pZHMoKTtcbiAgICB9IC8vIFVwZGF0ZS9hcHBlbmQgZGF0YSBwb2ludCwgZGVwZW5kaW5nIG9uIHRpbWVzdGFtcFxuXG4gIH0sIHtcbiAgICBrZXk6IFwidXBkYXRlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHVwZGF0ZShkYXRhKSB7XG4gICAgICBpZiAoZGF0YVsnY2FuZGxlJ10pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudXBkYXRlX2NhbmRsZShkYXRhKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiB0aGlzLnVwZGF0ZV90aWNrKGRhdGEpO1xuICAgICAgfVxuICAgIH0gLy8gTG9jayBvdmVybGF5cyBmcm9tIGJlaW5nIHB1bGxlZCBieSBxdWVyeV9zZWFyY2hcbiAgICAvLyBUT0RPOiBzdWJqZWN0IHRvIHJldmlld1xuXG4gIH0sIHtcbiAgICBrZXk6IFwibG9ja1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBsb2NrKHF1ZXJ5KSB7XG4gICAgICB2YXIgb2JqZWN0cyA9IHRoaXMuZ2V0X2J5X3F1ZXJ5KHF1ZXJ5KTtcbiAgICAgIG9iamVjdHMuZm9yRWFjaChmdW5jdGlvbiAoeCkge1xuICAgICAgICBpZiAoeC52ICYmIHgudi5pZCAmJiB4LnYudHlwZSkge1xuICAgICAgICAgIHgudi5sb2NrZWQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9IC8vIFVubG9jayBvdmVybGF5cyBmcm9tIGJlaW5nIHB1bGxlZCBieSBxdWVyeV9zZWFyY2hcbiAgICAvL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwidW5sb2NrXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHVubG9jayhxdWVyeSkge1xuICAgICAgdmFyIG9iamVjdHMgPSB0aGlzLmdldF9ieV9xdWVyeShxdWVyeSwgdHJ1ZSk7XG4gICAgICBvYmplY3RzLmZvckVhY2goZnVuY3Rpb24gKHgpIHtcbiAgICAgICAgaWYgKHgudiAmJiB4LnYuaWQgJiYgeC52LnR5cGUpIHtcbiAgICAgICAgICB4LnYubG9ja2VkID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0gLy8gU2hvdyBpbmRpY2F0b3JcblxuICB9LCB7XG4gICAga2V5OiBcInNob3dcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2hvdyhxdWVyeSkge1xuICAgICAgaWYgKHF1ZXJ5ID09PSAnb2ZmY2hhcnQnIHx8IHF1ZXJ5ID09PSAnb25jaGFydCcpIHtcbiAgICAgICAgcXVlcnkgKz0gJy4nO1xuICAgICAgfSBlbHNlIGlmIChxdWVyeSA9PT0gJy4nKSB7XG4gICAgICAgIHF1ZXJ5ID0gJyc7XG4gICAgICB9XG5cbiAgICAgIHRoaXMubWVyZ2UocXVlcnkgKyAnLnNldHRpbmdzJywge1xuICAgICAgICBkaXNwbGF5OiB0cnVlXG4gICAgICB9KTtcbiAgICB9IC8vIEhpZGUgaW5kaWNhdG9yXG5cbiAgfSwge1xuICAgIGtleTogXCJoaWRlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGhpZGUocXVlcnkpIHtcbiAgICAgIGlmIChxdWVyeSA9PT0gJ29mZmNoYXJ0JyB8fCBxdWVyeSA9PT0gJ29uY2hhcnQnKSB7XG4gICAgICAgIHF1ZXJ5ICs9ICcuJztcbiAgICAgIH0gZWxzZSBpZiAocXVlcnkgPT09ICcuJykge1xuICAgICAgICBxdWVyeSA9ICcnO1xuICAgICAgfVxuXG4gICAgICB0aGlzLm1lcmdlKHF1ZXJ5ICsgJy5zZXR0aW5ncycsIHtcbiAgICAgICAgZGlzcGxheTogZmFsc2VcbiAgICAgIH0pO1xuICAgIH0gLy8gU2V0IGRhdGEgbG9hZGVyIGNhbGxiYWNrXG5cbiAgfSwge1xuICAgIGtleTogXCJvbnJhbmdlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG9ucmFuZ2UoY2FsbGJhY2spIHtcbiAgICAgIHZhciBfdGhpczIgPSB0aGlzO1xuXG4gICAgICB0aGlzLmxvYWRlciA9IGNhbGxiYWNrO1xuICAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBfdGhpczIudHYuc2V0X2xvYWRlcihjYWxsYmFjayA/IF90aGlzMiA6IG51bGwpO1xuICAgICAgfSwgMCk7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIERhdGFDdWJlO1xufShEQ0NvcmUpO1xuXG5cbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9taXhpbnMvaW50ZXJmYWNlLmpzXG4vLyBIdG1sIGludGVyZmFjZSwgc2hvd24gb24gdG9wIG9mIHRoZSBncmlkLlxuLy8gQ2FuIGJlIHN0YXRpYyAoYSB0b29sdGlwKSBvciBpbnRlcmFjdGl2ZSxcbi8vIGUuZy4gYSBjb250cm9sIHBhbmVsLlxuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyBjb25zdCBtaXhpbnNfaW50ZXJmYWNlID0gKHtcbiAgcHJvcHM6IFsndXgnLCAndXBkYXRlcicsICdjb2xvcnMnLCAnd3JhcHBlciddLFxuICBtb3VudGVkOiBmdW5jdGlvbiBtb3VudGVkKCkge1xuICAgIHRoaXMuXyRlbWl0ID0gdGhpcy4kZW1pdDtcbiAgICB0aGlzLiRlbWl0ID0gdGhpcy5jdXN0b21fZXZlbnQ7XG4gICAgaWYgKHRoaXMuaW5pdCkgdGhpcy5pbml0KCk7XG4gIH0sXG4gIG1ldGhvZHM6IHtcbiAgICBjbG9zZTogZnVuY3Rpb24gY2xvc2UoKSB7XG4gICAgICB0aGlzLiRlbWl0KCdjdXN0b20tZXZlbnQnLCB7XG4gICAgICAgIGV2ZW50OiAnY2xvc2UtaW50ZXJmYWNlJyxcbiAgICAgICAgYXJnczogW3RoaXMuJHByb3BzLnV4LnV1aWRdXG4gICAgICB9KTtcbiAgICB9LFxuICAgIC8vIFRPRE86IGVtaXQgYWxsIHRoZSB3YXkgdG8gdGhlIHV4bGlzdFxuICAgIC8vIGFkZCBhcHBseSB0aGUgY2hhbmdlcyB0aGVyZVxuICAgIG1vZGlmeTogZnVuY3Rpb24gbW9kaWZ5KG9iaikge1xuICAgICAgdGhpcy4kZW1pdCgnY3VzdG9tLWV2ZW50Jywge1xuICAgICAgICBldmVudDogJ21vZGlmeS1pbnRlcmZhY2UnLFxuICAgICAgICBhcmdzOiBbdGhpcy4kcHJvcHMudXgudXVpZCwgb2JqXVxuICAgICAgfSk7XG4gICAgfSxcbiAgICBjdXN0b21fZXZlbnQ6IGZ1bmN0aW9uIGN1c3RvbV9ldmVudChldmVudCkge1xuICAgICAgaWYgKGV2ZW50LnNwbGl0KCc6JylbMF0gPT09ICdob29rJykgcmV0dXJuO1xuXG4gICAgICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuID4gMSA/IF9sZW4gLSAxIDogMCksIF9rZXkgPSAxOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgICAgIGFyZ3NbX2tleSAtIDFdID0gYXJndW1lbnRzW19rZXldO1xuICAgICAgfVxuXG4gICAgICB0aGlzLl8kZW1pdCgnY3VzdG9tLWV2ZW50Jywge1xuICAgICAgICBldmVudDogZXZlbnQsXG4gICAgICAgIGFyZ3M6IGFyZ3NcbiAgICAgIH0pO1xuICAgIH1cbiAgfSxcbiAgY29tcHV0ZWQ6IHtcbiAgICBvdmVybGF5OiBmdW5jdGlvbiBvdmVybGF5KCkge1xuICAgICAgcmV0dXJuIHRoaXMuJHByb3BzLnV4Lm92ZXJsYXk7XG4gICAgfSxcbiAgICBsYXlvdXQ6IGZ1bmN0aW9uIGxheW91dCgpIHtcbiAgICAgIHJldHVybiB0aGlzLm92ZXJsYXkubGF5b3V0O1xuICAgIH0sXG4gICAgdXhyOiBmdW5jdGlvbiB1eHIoKSB7XG4gICAgICByZXR1cm4gdGhpcy4kcHJvcHMudXg7XG4gICAgfVxuICB9LFxuICBkYXRhOiBmdW5jdGlvbiBkYXRhKCkge1xuICAgIHJldHVybiB7fTtcbiAgfVxufSk7XG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvaW5kZXguanNcblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cbnZhciBwcmltaXRpdmVzID0ge1xuICBDYW5kbGU6IENhbmRsZUV4dCxcbiAgVm9sYmFyOiBWb2xiYXJFeHQsXG4gIExpbmU6IExpbmUsXG4gIFBpbjogUGluLFxuICBQcmljZTogUHJpY2UsXG4gIFJheTogUmF5LFxuICBTZWc6IFNlZ1xufTtcblxuVHJhZGluZ1Z1ZS5pbnN0YWxsID0gZnVuY3Rpb24gKFZ1ZSkge1xuICBWdWUuY29tcG9uZW50KFRyYWRpbmdWdWUubmFtZSwgVHJhZGluZ1Z1ZSk7XG59O1xuXG5pZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgd2luZG93LlZ1ZSkge1xuICB3aW5kb3cuVnVlLnVzZShUcmFkaW5nVnVlKTtcbiAgd2luZG93LlRyYWRpbmdWdWVMaWIgPSB7XG4gICAgVHJhZGluZ1Z1ZTogVHJhZGluZ1Z1ZSxcbiAgICBPdmVybGF5OiBvdmVybGF5LFxuICAgIFV0aWxzOiB1dGlscyxcbiAgICBDb25zdGFudHM6IGNvbnN0YW50cyxcbiAgICBDYW5kbGU6IENhbmRsZUV4dCxcbiAgICBWb2xiYXI6IFZvbGJhckV4dCxcbiAgICBsYXlvdXRfY252OiBsYXlvdXRfY252LFxuICAgIGxheW91dF92b2w6IGxheW91dF92b2wsXG4gICAgRGF0YUN1YmU6IERhdGFDdWJlLFxuICAgIFRvb2w6IHRvb2wsXG4gICAgSW50ZXJmYWNlOiBtaXhpbnNfaW50ZXJmYWNlLFxuICAgIHByaW1pdGl2ZXM6IHByaW1pdGl2ZXNcbiAgfTtcbn1cblxuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyBjb25zdCBzcmMgPSAoVHJhZGluZ1Z1ZSk7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIDQxODpcbi8qKiovICgobW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cbi8vIEltcG9ydHNcbnZhciBfX19DU1NfTE9BREVSX0FQSV9JTVBPUlRfX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDY0NSk7XG5leHBvcnRzID0gX19fQ1NTX0xPQURFUl9BUElfSU1QT1JUX19fKGZhbHNlKTtcbi8vIE1vZHVsZVxuZXhwb3J0cy5wdXNoKFttb2R1bGUuaWQsIFwiXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuLyogQW5pdC1ib29zdHJhcCB0YWN0aXggKi9cXG4udHJhZGluZy12dWUgKiwgOjphZnRlciwgOjpiZWZvcmUge1xcbiAgICBib3gtc2l6aW5nOiBjb250ZW50LWJveDtcXG59XFxuLnRyYWRpbmctdnVlIGltZyB7XFxuICAgIHZlcnRpY2FsLWFsaWduOiBpbml0aWFsO1xcbn1cXG5cIiwgXCJcIl0pO1xuLy8gRXhwb3J0c1xubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzO1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyA5NzY6XG4vKioqLyAoKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuXG4vLyBJbXBvcnRzXG52YXIgX19fQ1NTX0xPQURFUl9BUElfSU1QT1JUX19fID0gX193ZWJwYWNrX3JlcXVpcmVfXyg2NDUpO1xuZXhwb3J0cyA9IF9fX0NTU19MT0FERVJfQVBJX0lNUE9SVF9fXyhmYWxzZSk7XG4vLyBNb2R1bGVcbmV4cG9ydHMucHVzaChbbW9kdWxlLmlkLCBcIlxcbi50cmFkaW5nLXZ1ZS1ib3RiYXIge1xcbiAgICBwb3NpdGlvbjogcmVsYXRpdmUgIWltcG9ydGFudDtcXG59XFxuXCIsIFwiXCJdKTtcbi8vIEV4cG9ydHNcbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0cztcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gNDQ5OlxuLyoqKi8gKChtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcblxuLy8gSW1wb3J0c1xudmFyIF9fX0NTU19MT0FERVJfQVBJX0lNUE9SVF9fXyA9IF9fd2VicGFja19yZXF1aXJlX18oNjQ1KTtcbmV4cG9ydHMgPSBfX19DU1NfTE9BREVSX0FQSV9JTVBPUlRfX18oZmFsc2UpO1xuLy8gTW9kdWxlXG5leHBvcnRzLnB1c2goW21vZHVsZS5pZCwgXCJcXG4udC12dWUtbGJ0bi1ncnAge1xcbiAgICBtYXJnaW4tbGVmdDogMC41ZW07XFxufVxcblwiLCBcIlwiXSk7XG4vLyBFeHBvcnRzXG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHM7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIDEwODpcbi8qKiovICgobW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cbi8vIEltcG9ydHNcbnZhciBfX19DU1NfTE9BREVSX0FQSV9JTVBPUlRfX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDY0NSk7XG5leHBvcnRzID0gX19fQ1NTX0xPQURFUl9BUElfSU1QT1JUX19fKGZhbHNlKTtcbi8vIE1vZHVsZVxuZXhwb3J0cy5wdXNoKFttb2R1bGUuaWQsIFwiXFxuLnR2anMtaXRlbS1saXN0IHtcXG4gICAgcG9zaXRpb246IGFic29sdXRlO1xcbiAgICB1c2VyLXNlbGVjdDogbm9uZTtcXG4gICAgbWFyZ2luLXRvcDogLTVweDtcXG59XFxuLnR2anMtaXRlbS1saXN0LWl0ZW0ge1xcbiAgICBkaXNwbGF5OiBmbGV4O1xcbiAgICBhbGlnbi1pdGVtczogY2VudGVyO1xcbiAgICBwYWRkaW5nLXJpZ2h0OiAyMHB4O1xcbiAgICBmb250LXNpemU6IDEuMTVlbTtcXG4gICAgbGV0dGVyLXNwYWNpbmc6IDAuMDVlbTtcXG59XFxuLnR2anMtaXRlbS1saXN0LWl0ZW06aG92ZXIge1xcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiAjNzY4NzgzMTk7XFxufVxcbi50dmpzLWl0ZW0tbGlzdC1pdGVtICoge1xcbiAgICBwb3NpdGlvbjogcmVsYXRpdmUgIWltcG9ydGFudDtcXG59XFxuXCIsIFwiXCJdKTtcbi8vIEV4cG9ydHNcbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0cztcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gOTg4OlxuLyoqKi8gKChtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcblxuLy8gSW1wb3J0c1xudmFyIF9fX0NTU19MT0FERVJfQVBJX0lNUE9SVF9fXyA9IF9fd2VicGFja19yZXF1aXJlX18oNjQ1KTtcbmV4cG9ydHMgPSBfX19DU1NfTE9BREVSX0FQSV9JTVBPUlRfX18oZmFsc2UpO1xuLy8gTW9kdWxlXG5leHBvcnRzLnB1c2goW21vZHVsZS5pZCwgXCJcXG4udHJhZGluZy12dWUtbGVnZW5kIHtcXG4gICAgcG9zaXRpb246IHJlbGF0aXZlO1xcbiAgICB6LWluZGV4OiAxMDA7XFxuICAgIGZvbnQtc2l6ZTogMS4yNWVtO1xcbiAgICBtYXJnaW4tbGVmdDogMTBweDtcXG4gICAgcG9pbnRlci1ldmVudHM6IG5vbmU7XFxuICAgIHRleHQtYWxpZ246IGxlZnQ7XFxuICAgIHVzZXItc2VsZWN0OiBub25lO1xcbiAgICBmb250LXdlaWdodDogMzAwO1xcbn1cXG5AbWVkaWEgKG1pbi1yZXNvbHV0aW9uOiAyeCkge1xcbi50cmFkaW5nLXZ1ZS1sZWdlbmQge1xcbiAgICAgICAgZm9udC13ZWlnaHQ6IDQwMDtcXG59XFxufVxcbi50cmFkaW5nLXZ1ZS1vaGxjdiB7XFxuICAgIHBvaW50ZXItZXZlbnRzOiBub25lO1xcbiAgICBtYXJnaW4tYm90dG9tOiAwLjVlbTtcXG59XFxuLnQtdnVlLWxzcGFuIHtcXG4gICAgZm9udC12YXJpYW50LW51bWVyaWM6IHRhYnVsYXItbnVtcztcXG4gICAgZm9udC1zaXplOiAwLjk1ZW07XFxuICAgIGNvbG9yOiAjOTk5OTk5OyAvKiBUT0RPOiBtb3ZlID0+IHBhcmFtcyAqL1xcbiAgICBtYXJnaW4tbGVmdDogMC4xZW07XFxuICAgIG1hcmdpbi1yaWdodDogMC4yZW07XFxufVxcbi50LXZ1ZS10aXRsZSB7XFxuICAgIG1hcmdpbi1yaWdodDogMC4yNWVtO1xcbiAgICBmb250LXNpemU6IDEuNDVlbTtcXG59XFxuLnQtdnVlLWluZCB7XFxuICAgIG1hcmdpbi1sZWZ0OiAwLjJlbTtcXG4gICAgbWFyZ2luLWJvdHRvbTogMC41ZW07XFxuICAgIGZvbnQtc2l6ZTogMS4wZW07XFxuICAgIG1hcmdpbi10b3A6IDAuM2VtO1xcbn1cXG4udC12dWUtaXZhbHVlIHtcXG4gICAgbWFyZ2luLWxlZnQ6IDAuNWVtO1xcbn1cXG4udC12dWUtdW5rbm93biB7XFxuICAgIGNvbG9yOiAjOTk5OTk5OyAvKiBUT0RPOiBtb3ZlID0+IHBhcmFtcyAqL1xcbn1cXG4udHZqcy1hcHBlYXItZW50ZXItYWN0aXZlLFxcbi50dmpzLWFwcGVhci1sZWF2ZS1hY3RpdmVcXG57XFxuICAgIHRyYW5zaXRpb246IGFsbCAuMjVzIGVhc2U7XFxufVxcbi50dmpzLWFwcGVhci1lbnRlciwgLnR2anMtYXBwZWFyLWxlYXZlLXRvXFxue1xcbiAgICBvcGFjaXR5OiAwO1xcbn1cXG5cIiwgXCJcIl0pO1xuLy8gRXhwb3J0c1xubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzO1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyA0MjM6XG4vKioqLyAoKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuXG4vLyBJbXBvcnRzXG52YXIgX19fQ1NTX0xPQURFUl9BUElfSU1QT1JUX19fID0gX193ZWJwYWNrX3JlcXVpcmVfXyg2NDUpO1xuZXhwb3J0cyA9IF9fX0NTU19MT0FERVJfQVBJX0lNUE9SVF9fXyhmYWxzZSk7XG4vLyBNb2R1bGVcbmV4cG9ydHMucHVzaChbbW9kdWxlLmlkLCBcIlxcbi50LXZ1ZS1sYnRuIHtcXG4gICAgei1pbmRleDogMTAwO1xcbiAgICBwb2ludGVyLWV2ZW50czogYWxsO1xcbiAgICBjdXJzb3I6IHBvaW50ZXI7XFxufVxcblwiLCBcIlwiXSk7XG4vLyBFeHBvcnRzXG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHM7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIDY2MTpcbi8qKiovICgobW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cbi8vIEltcG9ydHNcbnZhciBfX19DU1NfTE9BREVSX0FQSV9JTVBPUlRfX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDY0NSk7XG5leHBvcnRzID0gX19fQ1NTX0xPQURFUl9BUElfSU1QT1JUX19fKGZhbHNlKTtcbi8vIE1vZHVsZVxuZXhwb3J0cy5wdXNoKFttb2R1bGUuaWQsIFwiXFxuLnRyYWRpbmctdnVlLXNlY3Rpb24ge1xcbiAgICBoZWlnaHQ6IDA7XFxuICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTtcXG59XFxuXCIsIFwiXCJdKTtcbi8vIEV4cG9ydHNcbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0cztcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gMTY4OlxuLyoqKi8gKChtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcblxuLy8gSW1wb3J0c1xudmFyIF9fX0NTU19MT0FERVJfQVBJX0lNUE9SVF9fXyA9IF9fd2VicGFja19yZXF1aXJlX18oNjQ1KTtcbmV4cG9ydHMgPSBfX19DU1NfTE9BREVSX0FQSV9JTVBPUlRfX18oZmFsc2UpO1xuLy8gTW9kdWxlXG5leHBvcnRzLnB1c2goW21vZHVsZS5pZCwgXCJcXG4udHZqcy1zcGlubmVyIHtcXG4gICAgZGlzcGxheTogaW5saW5lLWJsb2NrO1xcbiAgICBwb3NpdGlvbjogcmVsYXRpdmU7XFxuICAgIHdpZHRoOiAyMHB4O1xcbiAgICBoZWlnaHQ6IDE2cHg7XFxuICAgIG1hcmdpbjogLTRweCAwcHggLTFweCAwcHg7XFxuICAgIG9wYWNpdHk6IDAuNztcXG59XFxuLnR2anMtc3Bpbm5lciBkaXYge1xcbiAgICBwb3NpdGlvbjogYWJzb2x1dGU7XFxuICAgIHRvcDogOHB4O1xcbiAgICB3aWR0aDogNHB4O1xcbiAgICBoZWlnaHQ6IDRweDtcXG4gICAgYm9yZGVyLXJhZGl1czogNTAlO1xcbiAgICBhbmltYXRpb24tdGltaW5nLWZ1bmN0aW9uOiBjdWJpYy1iZXppZXIoMSwgMSwgMSwgMSk7XFxufVxcbi50dmpzLXNwaW5uZXIgZGl2Om50aC1jaGlsZCgxKSB7XFxuICAgIGxlZnQ6IDJweDtcXG4gICAgYW5pbWF0aW9uOiB0dmpzLXNwaW5uZXIxIDAuNnMgaW5maW5pdGU7XFxuICAgIG9wYWNpdHk6IDAuOTtcXG59XFxuLnR2anMtc3Bpbm5lciBkaXY6bnRoLWNoaWxkKDIpIHtcXG4gICAgbGVmdDogMnB4O1xcbiAgICBhbmltYXRpb246IHR2anMtc3Bpbm5lcjIgMC42cyBpbmZpbml0ZTtcXG59XFxuLnR2anMtc3Bpbm5lciBkaXY6bnRoLWNoaWxkKDMpIHtcXG4gICAgbGVmdDogOXB4O1xcbiAgICBhbmltYXRpb246IHR2anMtc3Bpbm5lcjIgMC42cyBpbmZpbml0ZTtcXG59XFxuLnR2anMtc3Bpbm5lciBkaXY6bnRoLWNoaWxkKDQpIHtcXG4gICAgbGVmdDogMTZweDtcXG4gICAgYW5pbWF0aW9uOiB0dmpzLXNwaW5uZXIzIDAuNnMgaW5maW5pdGU7XFxuICAgIG9wYWNpdHk6IDAuOTtcXG59XFxuQGtleWZyYW1lcyB0dmpzLXNwaW5uZXIxIHtcXG4wJSB7XFxuICAgICAgICB0cmFuc2Zvcm06IHNjYWxlKDApO1xcbn1cXG4xMDAlIHtcXG4gICAgICAgIHRyYW5zZm9ybTogc2NhbGUoMSk7XFxufVxcbn1cXG5Aa2V5ZnJhbWVzIHR2anMtc3Bpbm5lcjMge1xcbjAlIHtcXG4gICAgICAgIHRyYW5zZm9ybTogc2NhbGUoMSk7XFxufVxcbjEwMCUge1xcbiAgICAgICAgdHJhbnNmb3JtOiBzY2FsZSgwKTtcXG59XFxufVxcbkBrZXlmcmFtZXMgdHZqcy1zcGlubmVyMiB7XFxuMCUge1xcbiAgICAgICAgdHJhbnNmb3JtOiB0cmFuc2xhdGUoMCwgMCk7XFxufVxcbjEwMCUge1xcbiAgICAgICAgdHJhbnNmb3JtOiB0cmFuc2xhdGUoN3B4LCAwKTtcXG59XFxufVxcblwiLCBcIlwiXSk7XG4vLyBFeHBvcnRzXG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHM7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIDI5OlxuLyoqKi8gKChtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcblxuLy8gSW1wb3J0c1xudmFyIF9fX0NTU19MT0FERVJfQVBJX0lNUE9SVF9fXyA9IF9fd2VicGFja19yZXF1aXJlX18oNjQ1KTtcbmV4cG9ydHMgPSBfX19DU1NfTE9BREVSX0FQSV9JTVBPUlRfX18oZmFsc2UpO1xuLy8gTW9kdWxlXG5leHBvcnRzLnB1c2goW21vZHVsZS5pZCwgXCJcXG4udHZqcy1kcmlmdC1lbnRlci1hY3RpdmUge1xcbiAgICB0cmFuc2l0aW9uOiBhbGwgLjNzIGVhc2U7XFxufVxcbi50dmpzLWRyaWZ0LWxlYXZlLWFjdGl2ZSB7XFxuICAgIHRyYW5zaXRpb246IGFsbCAuOHMgY3ViaWMtYmV6aWVyKDEuMCwgMC41LCAwLjgsIDEuMCk7XFxufVxcbi50dmpzLWRyaWZ0LWVudGVyLCAudHZqcy1kcmlmdC1sZWF2ZS10b1xcbntcXG4gICAgdHJhbnNmb3JtOiB0cmFuc2xhdGVYKDEwcHgpO1xcbiAgICBvcGFjaXR5OiAwO1xcbn1cXG4udHZqcy10aGUtdGlwIHtcXG4gICAgcG9zaXRpb246IGFic29sdXRlO1xcbiAgICB3aWR0aDogMjAwcHg7XFxuICAgIHRleHQtYWxpZ246IGNlbnRlcjtcXG4gICAgei1pbmRleDogMTAwMDE7XFxuICAgIGNvbG9yOiAjZmZmZmZmO1xcbiAgICBmb250LXNpemU6IDEuNWVtO1xcbiAgICBsaW5lLWhlaWdodDogMS4xNWVtO1xcbiAgICBwYWRkaW5nOiAxMHB4O1xcbiAgICBib3JkZXItcmFkaXVzOiAzcHg7XFxuICAgIHJpZ2h0OiA3MHB4O1xcbiAgICB0b3A6IDEwcHg7XFxuICAgIHRleHQtc2hhZG93OiAxcHggMXB4IGJsYWNrO1xcbn1cXG5cIiwgXCJcIl0pO1xuLy8gRXhwb3J0c1xubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzO1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyA5MzU6XG4vKioqLyAoKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuXG4vLyBJbXBvcnRzXG52YXIgX19fQ1NTX0xPQURFUl9BUElfSU1QT1JUX19fID0gX193ZWJwYWNrX3JlcXVpcmVfXyg2NDUpO1xuZXhwb3J0cyA9IF9fX0NTU19MT0FERVJfQVBJX0lNUE9SVF9fXyhmYWxzZSk7XG4vLyBNb2R1bGVcbmV4cG9ydHMucHVzaChbbW9kdWxlLmlkLCBcIlxcbi50cmFkaW5nLXZ1ZS10b29sYmFyIHtcXG4gICAgcG9zaXRpb246IGFic29sdXRlO1xcbiAgICBib3JkZXItcmlnaHQ6IDFweCBzb2xpZCBibGFjaztcXG4gICAgei1pbmRleDogMTAxO1xcbiAgICBwYWRkaW5nLXRvcDogM3B4O1xcbiAgICB1c2VyLXNlbGVjdDogbm9uZTtcXG59XFxuXCIsIFwiXCJdKTtcbi8vIEV4cG9ydHNcbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0cztcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gMzc5OlxuLyoqKi8gKChtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcblxuLy8gSW1wb3J0c1xudmFyIF9fX0NTU19MT0FERVJfQVBJX0lNUE9SVF9fXyA9IF9fd2VicGFja19yZXF1aXJlX18oNjQ1KTtcbmV4cG9ydHMgPSBfX19DU1NfTE9BREVSX0FQSV9JTVBPUlRfX18oZmFsc2UpO1xuLy8gTW9kdWxlXG5leHBvcnRzLnB1c2goW21vZHVsZS5pZCwgXCJcXG4udHJhZGluZy12dWUtdGJpdGVtIHtcXG59XFxuLnRyYWRpbmctdnVlLXRiaXRlbTpob3ZlciB7XFxuICAgIGJhY2tncm91bmQtY29sb3I6ICM3Njg3ODMxOTtcXG59XFxuLnRyYWRpbmctdnVlLXRiaXRlbS1leHAge1xcbiAgICBwb3NpdGlvbjogYWJzb2x1dGU7XFxuICAgIHJpZ2h0OiAtM3B4O1xcbiAgICBwYWRkaW5nOiAxOC41cHggNXB4O1xcbiAgICBmb250LXN0cmV0Y2g6IGV4dHJhLWNvbmRlbnNlZDtcXG4gICAgdHJhbnNmb3JtOiBzY2FsZVgoMC42KTtcXG4gICAgZm9udC1zaXplOiAwLjZlbTtcXG4gICAgb3BhY2l0eTogMC4wO1xcbiAgICB1c2VyLXNlbGVjdDogbm9uZTtcXG4gICAgbGluZS1oZWlnaHQ6IDA7XFxufVxcbi50cmFkaW5nLXZ1ZS10Yml0ZW06aG92ZXJcXG4udHJhZGluZy12dWUtdGJpdGVtLWV4cCB7XFxuICAgIG9wYWNpdHk6IDAuNTtcXG59XFxuLnRyYWRpbmctdnVlLXRiaXRlbS1leHA6aG92ZXIge1xcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiAjNzY4NzgzMzA7XFxuICAgIG9wYWNpdHk6IDAuOSAhaW1wb3J0YW50O1xcbn1cXG4udHJhZGluZy12dWUtdGJpY29uIHtcXG4gICAgcG9zaXRpb246IGFic29sdXRlO1xcbn1cXG4udHJhZGluZy12dWUtdGJpdGVtLnNlbGVjdGVkLWl0ZW0gPiAudHJhZGluZy12dWUtdGJpY29uLFxcbi50dmpzLWl0ZW0tbGlzdC1pdGVtLnNlbGVjdGVkLWl0ZW0gPiAudHJhZGluZy12dWUtdGJpY29uIHtcXG4gICAgIGZpbHRlcjogYnJpZ2h0bmVzcygxLjQ1KSBzZXBpYSgxKSBodWUtcm90YXRlKDkwZGVnKSBzYXR1cmF0ZSg0LjUpICFpbXBvcnRhbnQ7XFxufVxcbi50dmpzLXBpeGVsYXRlZCB7XFxuICAgIC1tcy1pbnRlcnBvbGF0aW9uLW1vZGU6IG5lYXJlc3QtbmVpZ2hib3I7XFxuICAgIGltYWdlLXJlbmRlcmluZzogLXdlYmtpdC1vcHRpbWl6ZS1jb250cmFzdDtcXG4gICAgaW1hZ2UtcmVuZGVyaW5nOiAtd2Via2l0LWNyaXNwLWVkZ2VzO1xcbiAgICBpbWFnZS1yZW5kZXJpbmc6IC1tb3otY3Jpc3AtZWRnZXM7XFxuICAgIGltYWdlLXJlbmRlcmluZzogLW8tY3Jpc3AtZWRnZXM7XFxuICAgIGltYWdlLXJlbmRlcmluZzogcGl4ZWxhdGVkO1xcbn1cXG5cXG5cIiwgXCJcIl0pO1xuLy8gRXhwb3J0c1xubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzO1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyA3Mjpcbi8qKiovICgobW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cbi8vIEltcG9ydHNcbnZhciBfX19DU1NfTE9BREVSX0FQSV9JTVBPUlRfX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDY0NSk7XG5leHBvcnRzID0gX19fQ1NTX0xPQURFUl9BUElfSU1QT1JUX19fKGZhbHNlKTtcbi8vIE1vZHVsZVxuZXhwb3J0cy5wdXNoKFttb2R1bGUuaWQsIFwiXFxuLnRyYWRpbmctdnVlLXV4LXdyYXBwZXIge1xcbiAgICBwb3NpdGlvbjogYWJzb2x1dGU7XFxuICAgIGRpc3BsYXk6IGZsZXg7XFxufVxcbi50dmpzLXV4LXdyYXBwZXItcGluIHtcXG4gICAgcG9zaXRpb246IGFic29sdXRlO1xcbiAgICB3aWR0aDogOXB4O1xcbiAgICBoZWlnaHQ6IDlweDtcXG4gICAgei1pbmRleDogMTAwO1xcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiAjMjNhNzc2O1xcbiAgICBib3JkZXItcmFkaXVzOiAxMHB4O1xcbiAgICBtYXJnaW4tbGVmdDogLTZweDtcXG4gICAgbWFyZ2luLXRvcDogLTZweDtcXG4gICAgcG9pbnRlci1ldmVudHM6IG5vbmU7XFxufVxcbi50dmpzLXV4LXdyYXBwZXItaGVhZCB7XFxuICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTtcXG4gICAgaGVpZ2h0OiAyM3B4O1xcbiAgICB3aWR0aDogMTAwJTtcXG59XFxuLnR2anMtdXgtd3JhcHBlci1jbG9zZSB7XFxuICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTtcXG4gICAgd2lkdGg6IDExcHg7XFxuICAgIGhlaWdodDogMTFweDtcXG4gICAgZm9udC1zaXplOiAxLjVlbTtcXG4gICAgbGluZS1oZWlnaHQ6IDAuNWVtO1xcbiAgICBwYWRkaW5nOiAxcHggMXB4IDFweCAxcHg7XFxuICAgIGJvcmRlci1yYWRpdXM6IDEwcHg7XFxuICAgIHJpZ2h0OiA1cHg7XFxuICAgIHRvcDogNXB4O1xcbiAgICB1c2VyLXNlbGVjdDogbm9uZTtcXG4gICAgdGV4dC1hbGlnbjogY2VudGVyO1xcbiAgICB6LWluZGV4OiAxMDA7XFxufVxcbi50dmpzLXV4LXdyYXBwZXItY2xvc2UtaGIge1xcbn1cXG4udHZqcy11eC13cmFwcGVyLWNsb3NlOmhvdmVyIHtcXG4gICAgYmFja2dyb3VuZC1jb2xvcjogI0ZGNjA1QyAhaW1wb3J0YW50O1xcbiAgICBjb2xvcjogIzY5MjMyNCAhaW1wb3J0YW50O1xcbn1cXG4udHZqcy11eC13cmFwcGVyLWZ1bGwge1xcbn1cXG5cIiwgXCJcIl0pO1xuLy8gRXhwb3J0c1xubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzO1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyA5ODM6XG4vKioqLyAoKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuXG4vLyBJbXBvcnRzXG52YXIgX19fQ1NTX0xPQURFUl9BUElfSU1QT1JUX19fID0gX193ZWJwYWNrX3JlcXVpcmVfXyg2NDUpO1xuZXhwb3J0cyA9IF9fX0NTU19MT0FERVJfQVBJX0lNUE9SVF9fXyhmYWxzZSk7XG4vLyBNb2R1bGVcbmV4cG9ydHMucHVzaChbbW9kdWxlLmlkLCBcIlxcbi50dmpzLXdpZGdldHMge1xcbiAgICBwb3NpdGlvbjogYWJzb2x1dGU7XFxuICAgIHotaW5kZXg6IDEwMDA7XFxuICAgIHBvaW50ZXItZXZlbnRzOiBub25lO1xcbn1cXG5cIiwgXCJcIl0pO1xuLy8gRXhwb3J0c1xubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzO1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyA2NDU6XG4vKioqLyAoKG1vZHVsZSkgPT4ge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG4vKlxuICBNSVQgTGljZW5zZSBodHRwOi8vd3d3Lm9wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL21pdC1saWNlbnNlLnBocFxuICBBdXRob3IgVG9iaWFzIEtvcHBlcnMgQHNva3JhXG4qL1xuLy8gY3NzIGJhc2UgY29kZSwgaW5qZWN0ZWQgYnkgdGhlIGNzcy1sb2FkZXJcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBmdW5jLW5hbWVzXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uICh1c2VTb3VyY2VNYXApIHtcbiAgdmFyIGxpc3QgPSBbXTsgLy8gcmV0dXJuIHRoZSBsaXN0IG9mIG1vZHVsZXMgYXMgY3NzIHN0cmluZ1xuXG4gIGxpc3QudG9TdHJpbmcgPSBmdW5jdGlvbiB0b1N0cmluZygpIHtcbiAgICByZXR1cm4gdGhpcy5tYXAoZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgIHZhciBjb250ZW50ID0gY3NzV2l0aE1hcHBpbmdUb1N0cmluZyhpdGVtLCB1c2VTb3VyY2VNYXApO1xuXG4gICAgICBpZiAoaXRlbVsyXSkge1xuICAgICAgICByZXR1cm4gXCJAbWVkaWEgXCIuY29uY2F0KGl0ZW1bMl0sIFwiIHtcIikuY29uY2F0KGNvbnRlbnQsIFwifVwiKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGNvbnRlbnQ7XG4gICAgfSkuam9pbignJyk7XG4gIH07IC8vIGltcG9ydCBhIGxpc3Qgb2YgbW9kdWxlcyBpbnRvIHRoZSBsaXN0XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBmdW5jLW5hbWVzXG5cblxuICBsaXN0LmkgPSBmdW5jdGlvbiAobW9kdWxlcywgbWVkaWFRdWVyeSwgZGVkdXBlKSB7XG4gICAgaWYgKHR5cGVvZiBtb2R1bGVzID09PSAnc3RyaW5nJykge1xuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXBhcmFtLXJlYXNzaWduXG4gICAgICBtb2R1bGVzID0gW1tudWxsLCBtb2R1bGVzLCAnJ11dO1xuICAgIH1cblxuICAgIHZhciBhbHJlYWR5SW1wb3J0ZWRNb2R1bGVzID0ge307XG5cbiAgICBpZiAoZGVkdXBlKSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHByZWZlci1kZXN0cnVjdHVyaW5nXG4gICAgICAgIHZhciBpZCA9IHRoaXNbaV1bMF07XG5cbiAgICAgICAgaWYgKGlkICE9IG51bGwpIHtcbiAgICAgICAgICBhbHJlYWR5SW1wb3J0ZWRNb2R1bGVzW2lkXSA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgbW9kdWxlcy5sZW5ndGg7IF9pKyspIHtcbiAgICAgIHZhciBpdGVtID0gW10uY29uY2F0KG1vZHVsZXNbX2ldKTtcblxuICAgICAgaWYgKGRlZHVwZSAmJiBhbHJlYWR5SW1wb3J0ZWRNb2R1bGVzW2l0ZW1bMF1dKSB7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1jb250aW51ZVxuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgaWYgKG1lZGlhUXVlcnkpIHtcbiAgICAgICAgaWYgKCFpdGVtWzJdKSB7XG4gICAgICAgICAgaXRlbVsyXSA9IG1lZGlhUXVlcnk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaXRlbVsyXSA9IFwiXCIuY29uY2F0KG1lZGlhUXVlcnksIFwiIGFuZCBcIikuY29uY2F0KGl0ZW1bMl0pO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGxpc3QucHVzaChpdGVtKTtcbiAgICB9XG4gIH07XG5cbiAgcmV0dXJuIGxpc3Q7XG59O1xuXG5mdW5jdGlvbiBjc3NXaXRoTWFwcGluZ1RvU3RyaW5nKGl0ZW0sIHVzZVNvdXJjZU1hcCkge1xuICB2YXIgY29udGVudCA9IGl0ZW1bMV0gfHwgJyc7IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBwcmVmZXItZGVzdHJ1Y3R1cmluZ1xuXG4gIHZhciBjc3NNYXBwaW5nID0gaXRlbVszXTtcblxuICBpZiAoIWNzc01hcHBpbmcpIHtcbiAgICByZXR1cm4gY29udGVudDtcbiAgfVxuXG4gIGlmICh1c2VTb3VyY2VNYXAgJiYgdHlwZW9mIGJ0b2EgPT09ICdmdW5jdGlvbicpIHtcbiAgICB2YXIgc291cmNlTWFwcGluZyA9IHRvQ29tbWVudChjc3NNYXBwaW5nKTtcbiAgICB2YXIgc291cmNlVVJMcyA9IGNzc01hcHBpbmcuc291cmNlcy5tYXAoZnVuY3Rpb24gKHNvdXJjZSkge1xuICAgICAgcmV0dXJuIFwiLyojIHNvdXJjZVVSTD1cIi5jb25jYXQoY3NzTWFwcGluZy5zb3VyY2VSb290IHx8ICcnKS5jb25jYXQoc291cmNlLCBcIiAqL1wiKTtcbiAgICB9KTtcbiAgICByZXR1cm4gW2NvbnRlbnRdLmNvbmNhdChzb3VyY2VVUkxzKS5jb25jYXQoW3NvdXJjZU1hcHBpbmddKS5qb2luKCdcXG4nKTtcbiAgfVxuXG4gIHJldHVybiBbY29udGVudF0uam9pbignXFxuJyk7XG59IC8vIEFkYXB0ZWQgZnJvbSBjb252ZXJ0LXNvdXJjZS1tYXAgKE1JVClcblxuXG5mdW5jdGlvbiB0b0NvbW1lbnQoc291cmNlTWFwKSB7XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11bmRlZlxuICB2YXIgYmFzZTY0ID0gYnRvYSh1bmVzY2FwZShlbmNvZGVVUklDb21wb25lbnQoSlNPTi5zdHJpbmdpZnkoc291cmNlTWFwKSkpKTtcbiAgdmFyIGRhdGEgPSBcInNvdXJjZU1hcHBpbmdVUkw9ZGF0YTphcHBsaWNhdGlvbi9qc29uO2NoYXJzZXQ9dXRmLTg7YmFzZTY0LFwiLmNvbmNhdChiYXNlNjQpO1xuICByZXR1cm4gXCIvKiMgXCIuY29uY2F0KGRhdGEsIFwiICovXCIpO1xufVxuXG4vKioqLyB9KSxcblxuLyoqKi8gODQwOlxuLyoqKi8gKChtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcblxudmFyIF9fV0VCUEFDS19BTURfREVGSU5FX1JFU1VMVF9fOy8qISBIYW1tZXIuSlMgLSB2Mi4wLjcgLSAyMDE2LTA0LTIyXG4gKiBodHRwOi8vaGFtbWVyanMuZ2l0aHViLmlvL1xuICpcbiAqIENvcHlyaWdodCAoYykgMjAxNiBKb3JpayBUYW5nZWxkZXI7XG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgKi9cbihmdW5jdGlvbih3aW5kb3csIGRvY3VtZW50LCBleHBvcnROYW1lLCB1bmRlZmluZWQpIHtcbiAgJ3VzZSBzdHJpY3QnO1xuXG52YXIgVkVORE9SX1BSRUZJWEVTID0gWycnLCAnd2Via2l0JywgJ01veicsICdNUycsICdtcycsICdvJ107XG52YXIgVEVTVF9FTEVNRU5UID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG5cbnZhciBUWVBFX0ZVTkNUSU9OID0gJ2Z1bmN0aW9uJztcblxudmFyIHJvdW5kID0gTWF0aC5yb3VuZDtcbnZhciBhYnMgPSBNYXRoLmFicztcbnZhciBub3cgPSBEYXRlLm5vdztcblxuLyoqXG4gKiBzZXQgYSB0aW1lb3V0IHdpdGggYSBnaXZlbiBzY29wZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm5cbiAqIEBwYXJhbSB7TnVtYmVyfSB0aW1lb3V0XG4gKiBAcGFyYW0ge09iamVjdH0gY29udGV4dFxuICogQHJldHVybnMge251bWJlcn1cbiAqL1xuZnVuY3Rpb24gc2V0VGltZW91dENvbnRleHQoZm4sIHRpbWVvdXQsIGNvbnRleHQpIHtcbiAgICByZXR1cm4gc2V0VGltZW91dChiaW5kRm4oZm4sIGNvbnRleHQpLCB0aW1lb3V0KTtcbn1cblxuLyoqXG4gKiBpZiB0aGUgYXJndW1lbnQgaXMgYW4gYXJyYXksIHdlIHdhbnQgdG8gZXhlY3V0ZSB0aGUgZm4gb24gZWFjaCBlbnRyeVxuICogaWYgaXQgYWludCBhbiBhcnJheSB3ZSBkb24ndCB3YW50IHRvIGRvIGEgdGhpbmcuXG4gKiB0aGlzIGlzIHVzZWQgYnkgYWxsIHRoZSBtZXRob2RzIHRoYXQgYWNjZXB0IGEgc2luZ2xlIGFuZCBhcnJheSBhcmd1bWVudC5cbiAqIEBwYXJhbSB7KnxBcnJheX0gYXJnXG4gKiBAcGFyYW0ge1N0cmluZ30gZm5cbiAqIEBwYXJhbSB7T2JqZWN0fSBbY29udGV4dF1cbiAqIEByZXR1cm5zIHtCb29sZWFufVxuICovXG5mdW5jdGlvbiBpbnZva2VBcnJheUFyZyhhcmcsIGZuLCBjb250ZXh0KSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoYXJnKSkge1xuICAgICAgICBlYWNoKGFyZywgY29udGV4dFtmbl0sIGNvbnRleHQpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufVxuXG4vKipcbiAqIHdhbGsgb2JqZWN0cyBhbmQgYXJyYXlzXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBpdGVyYXRvclxuICogQHBhcmFtIHtPYmplY3R9IGNvbnRleHRcbiAqL1xuZnVuY3Rpb24gZWFjaChvYmosIGl0ZXJhdG9yLCBjb250ZXh0KSB7XG4gICAgdmFyIGk7XG5cbiAgICBpZiAoIW9iaikge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKG9iai5mb3JFYWNoKSB7XG4gICAgICAgIG9iai5mb3JFYWNoKGl0ZXJhdG9yLCBjb250ZXh0KTtcbiAgICB9IGVsc2UgaWYgKG9iai5sZW5ndGggIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBpID0gMDtcbiAgICAgICAgd2hpbGUgKGkgPCBvYmoubGVuZ3RoKSB7XG4gICAgICAgICAgICBpdGVyYXRvci5jYWxsKGNvbnRleHQsIG9ialtpXSwgaSwgb2JqKTtcbiAgICAgICAgICAgIGkrKztcbiAgICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAgIGZvciAoaSBpbiBvYmopIHtcbiAgICAgICAgICAgIG9iai5oYXNPd25Qcm9wZXJ0eShpKSAmJiBpdGVyYXRvci5jYWxsKGNvbnRleHQsIG9ialtpXSwgaSwgb2JqKTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuLyoqXG4gKiB3cmFwIGEgbWV0aG9kIHdpdGggYSBkZXByZWNhdGlvbiB3YXJuaW5nIGFuZCBzdGFjayB0cmFjZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gbWV0aG9kXG4gKiBAcGFyYW0ge1N0cmluZ30gbmFtZVxuICogQHBhcmFtIHtTdHJpbmd9IG1lc3NhZ2VcbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gQSBuZXcgZnVuY3Rpb24gd3JhcHBpbmcgdGhlIHN1cHBsaWVkIG1ldGhvZC5cbiAqL1xuZnVuY3Rpb24gZGVwcmVjYXRlKG1ldGhvZCwgbmFtZSwgbWVzc2FnZSkge1xuICAgIHZhciBkZXByZWNhdGlvbk1lc3NhZ2UgPSAnREVQUkVDQVRFRCBNRVRIT0Q6ICcgKyBuYW1lICsgJ1xcbicgKyBtZXNzYWdlICsgJyBBVCBcXG4nO1xuICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGUgPSBuZXcgRXJyb3IoJ2dldC1zdGFjay10cmFjZScpO1xuICAgICAgICB2YXIgc3RhY2sgPSBlICYmIGUuc3RhY2sgPyBlLnN0YWNrLnJlcGxhY2UoL15bXlxcKF0rP1tcXG4kXS9nbSwgJycpXG4gICAgICAgICAgICAucmVwbGFjZSgvXlxccythdFxccysvZ20sICcnKVxuICAgICAgICAgICAgLnJlcGxhY2UoL15PYmplY3QuPGFub255bW91cz5cXHMqXFwoL2dtLCAne2Fub255bW91c30oKUAnKSA6ICdVbmtub3duIFN0YWNrIFRyYWNlJztcblxuICAgICAgICB2YXIgbG9nID0gd2luZG93LmNvbnNvbGUgJiYgKHdpbmRvdy5jb25zb2xlLndhcm4gfHwgd2luZG93LmNvbnNvbGUubG9nKTtcbiAgICAgICAgaWYgKGxvZykge1xuICAgICAgICAgICAgbG9nLmNhbGwod2luZG93LmNvbnNvbGUsIGRlcHJlY2F0aW9uTWVzc2FnZSwgc3RhY2spO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtZXRob2QuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9O1xufVxuXG4vKipcbiAqIGV4dGVuZCBvYmplY3QuXG4gKiBtZWFucyB0aGF0IHByb3BlcnRpZXMgaW4gZGVzdCB3aWxsIGJlIG92ZXJ3cml0dGVuIGJ5IHRoZSBvbmVzIGluIHNyYy5cbiAqIEBwYXJhbSB7T2JqZWN0fSB0YXJnZXRcbiAqIEBwYXJhbSB7Li4uT2JqZWN0fSBvYmplY3RzX3RvX2Fzc2lnblxuICogQHJldHVybnMge09iamVjdH0gdGFyZ2V0XG4gKi9cbnZhciBhc3NpZ247XG5pZiAodHlwZW9mIE9iamVjdC5hc3NpZ24gIT09ICdmdW5jdGlvbicpIHtcbiAgICBhc3NpZ24gPSBmdW5jdGlvbiBhc3NpZ24odGFyZ2V0KSB7XG4gICAgICAgIGlmICh0YXJnZXQgPT09IHVuZGVmaW5lZCB8fCB0YXJnZXQgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0Nhbm5vdCBjb252ZXJ0IHVuZGVmaW5lZCBvciBudWxsIHRvIG9iamVjdCcpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIG91dHB1dCA9IE9iamVjdCh0YXJnZXQpO1xuICAgICAgICBmb3IgKHZhciBpbmRleCA9IDE7IGluZGV4IDwgYXJndW1lbnRzLmxlbmd0aDsgaW5kZXgrKykge1xuICAgICAgICAgICAgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpbmRleF07XG4gICAgICAgICAgICBpZiAoc291cmNlICE9PSB1bmRlZmluZWQgJiYgc291cmNlICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgbmV4dEtleSBpbiBzb3VyY2UpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNvdXJjZS5oYXNPd25Qcm9wZXJ0eShuZXh0S2V5KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgb3V0cHV0W25leHRLZXldID0gc291cmNlW25leHRLZXldO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBvdXRwdXQ7XG4gICAgfTtcbn0gZWxzZSB7XG4gICAgYXNzaWduID0gT2JqZWN0LmFzc2lnbjtcbn1cblxuLyoqXG4gKiBleHRlbmQgb2JqZWN0LlxuICogbWVhbnMgdGhhdCBwcm9wZXJ0aWVzIGluIGRlc3Qgd2lsbCBiZSBvdmVyd3JpdHRlbiBieSB0aGUgb25lcyBpbiBzcmMuXG4gKiBAcGFyYW0ge09iamVjdH0gZGVzdFxuICogQHBhcmFtIHtPYmplY3R9IHNyY1xuICogQHBhcmFtIHtCb29sZWFufSBbbWVyZ2U9ZmFsc2VdXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBkZXN0XG4gKi9cbnZhciBleHRlbmQgPSBkZXByZWNhdGUoZnVuY3Rpb24gZXh0ZW5kKGRlc3QsIHNyYywgbWVyZ2UpIHtcbiAgICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKHNyYyk7XG4gICAgdmFyIGkgPSAwO1xuICAgIHdoaWxlIChpIDwga2V5cy5sZW5ndGgpIHtcbiAgICAgICAgaWYgKCFtZXJnZSB8fCAobWVyZ2UgJiYgZGVzdFtrZXlzW2ldXSA9PT0gdW5kZWZpbmVkKSkge1xuICAgICAgICAgICAgZGVzdFtrZXlzW2ldXSA9IHNyY1trZXlzW2ldXTtcbiAgICAgICAgfVxuICAgICAgICBpKys7XG4gICAgfVxuICAgIHJldHVybiBkZXN0O1xufSwgJ2V4dGVuZCcsICdVc2UgYGFzc2lnbmAuJyk7XG5cbi8qKlxuICogbWVyZ2UgdGhlIHZhbHVlcyBmcm9tIHNyYyBpbiB0aGUgZGVzdC5cbiAqIG1lYW5zIHRoYXQgcHJvcGVydGllcyB0aGF0IGV4aXN0IGluIGRlc3Qgd2lsbCBub3QgYmUgb3ZlcndyaXR0ZW4gYnkgc3JjXG4gKiBAcGFyYW0ge09iamVjdH0gZGVzdFxuICogQHBhcmFtIHtPYmplY3R9IHNyY1xuICogQHJldHVybnMge09iamVjdH0gZGVzdFxuICovXG52YXIgbWVyZ2UgPSBkZXByZWNhdGUoZnVuY3Rpb24gbWVyZ2UoZGVzdCwgc3JjKSB7XG4gICAgcmV0dXJuIGV4dGVuZChkZXN0LCBzcmMsIHRydWUpO1xufSwgJ21lcmdlJywgJ1VzZSBgYXNzaWduYC4nKTtcblxuLyoqXG4gKiBzaW1wbGUgY2xhc3MgaW5oZXJpdGFuY2VcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNoaWxkXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBiYXNlXG4gKiBAcGFyYW0ge09iamVjdH0gW3Byb3BlcnRpZXNdXG4gKi9cbmZ1bmN0aW9uIGluaGVyaXQoY2hpbGQsIGJhc2UsIHByb3BlcnRpZXMpIHtcbiAgICB2YXIgYmFzZVAgPSBiYXNlLnByb3RvdHlwZSxcbiAgICAgICAgY2hpbGRQO1xuXG4gICAgY2hpbGRQID0gY2hpbGQucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShiYXNlUCk7XG4gICAgY2hpbGRQLmNvbnN0cnVjdG9yID0gY2hpbGQ7XG4gICAgY2hpbGRQLl9zdXBlciA9IGJhc2VQO1xuXG4gICAgaWYgKHByb3BlcnRpZXMpIHtcbiAgICAgICAgYXNzaWduKGNoaWxkUCwgcHJvcGVydGllcyk7XG4gICAgfVxufVxuXG4vKipcbiAqIHNpbXBsZSBmdW5jdGlvbiBiaW5kXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmblxuICogQHBhcmFtIHtPYmplY3R9IGNvbnRleHRcbiAqIEByZXR1cm5zIHtGdW5jdGlvbn1cbiAqL1xuZnVuY3Rpb24gYmluZEZuKGZuLCBjb250ZXh0KSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIGJvdW5kRm4oKSB7XG4gICAgICAgIHJldHVybiBmbi5hcHBseShjb250ZXh0LCBhcmd1bWVudHMpO1xuICAgIH07XG59XG5cbi8qKlxuICogbGV0IGEgYm9vbGVhbiB2YWx1ZSBhbHNvIGJlIGEgZnVuY3Rpb24gdGhhdCBtdXN0IHJldHVybiBhIGJvb2xlYW5cbiAqIHRoaXMgZmlyc3QgaXRlbSBpbiBhcmdzIHdpbGwgYmUgdXNlZCBhcyB0aGUgY29udGV4dFxuICogQHBhcmFtIHtCb29sZWFufEZ1bmN0aW9ufSB2YWxcbiAqIEBwYXJhbSB7QXJyYXl9IFthcmdzXVxuICogQHJldHVybnMge0Jvb2xlYW59XG4gKi9cbmZ1bmN0aW9uIGJvb2xPckZuKHZhbCwgYXJncykge1xuICAgIGlmICh0eXBlb2YgdmFsID09IFRZUEVfRlVOQ1RJT04pIHtcbiAgICAgICAgcmV0dXJuIHZhbC5hcHBseShhcmdzID8gYXJnc1swXSB8fCB1bmRlZmluZWQgOiB1bmRlZmluZWQsIGFyZ3MpO1xuICAgIH1cbiAgICByZXR1cm4gdmFsO1xufVxuXG4vKipcbiAqIHVzZSB0aGUgdmFsMiB3aGVuIHZhbDEgaXMgdW5kZWZpbmVkXG4gKiBAcGFyYW0geyp9IHZhbDFcbiAqIEBwYXJhbSB7Kn0gdmFsMlxuICogQHJldHVybnMgeyp9XG4gKi9cbmZ1bmN0aW9uIGlmVW5kZWZpbmVkKHZhbDEsIHZhbDIpIHtcbiAgICByZXR1cm4gKHZhbDEgPT09IHVuZGVmaW5lZCkgPyB2YWwyIDogdmFsMTtcbn1cblxuLyoqXG4gKiBhZGRFdmVudExpc3RlbmVyIHdpdGggbXVsdGlwbGUgZXZlbnRzIGF0IG9uY2VcbiAqIEBwYXJhbSB7RXZlbnRUYXJnZXR9IHRhcmdldFxuICogQHBhcmFtIHtTdHJpbmd9IHR5cGVzXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBoYW5kbGVyXG4gKi9cbmZ1bmN0aW9uIGFkZEV2ZW50TGlzdGVuZXJzKHRhcmdldCwgdHlwZXMsIGhhbmRsZXIpIHtcbiAgICBlYWNoKHNwbGl0U3RyKHR5cGVzKSwgZnVuY3Rpb24odHlwZSkge1xuICAgICAgICB0YXJnZXQuYWRkRXZlbnRMaXN0ZW5lcih0eXBlLCBoYW5kbGVyLCBmYWxzZSk7XG4gICAgfSk7XG59XG5cbi8qKlxuICogcmVtb3ZlRXZlbnRMaXN0ZW5lciB3aXRoIG11bHRpcGxlIGV2ZW50cyBhdCBvbmNlXG4gKiBAcGFyYW0ge0V2ZW50VGFyZ2V0fSB0YXJnZXRcbiAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlc1xuICogQHBhcmFtIHtGdW5jdGlvbn0gaGFuZGxlclxuICovXG5mdW5jdGlvbiByZW1vdmVFdmVudExpc3RlbmVycyh0YXJnZXQsIHR5cGVzLCBoYW5kbGVyKSB7XG4gICAgZWFjaChzcGxpdFN0cih0eXBlcyksIGZ1bmN0aW9uKHR5cGUpIHtcbiAgICAgICAgdGFyZ2V0LnJlbW92ZUV2ZW50TGlzdGVuZXIodHlwZSwgaGFuZGxlciwgZmFsc2UpO1xuICAgIH0pO1xufVxuXG4vKipcbiAqIGZpbmQgaWYgYSBub2RlIGlzIGluIHRoZSBnaXZlbiBwYXJlbnRcbiAqIEBtZXRob2QgaGFzUGFyZW50XG4gKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBub2RlXG4gKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBwYXJlbnRcbiAqIEByZXR1cm4ge0Jvb2xlYW59IGZvdW5kXG4gKi9cbmZ1bmN0aW9uIGhhc1BhcmVudChub2RlLCBwYXJlbnQpIHtcbiAgICB3aGlsZSAobm9kZSkge1xuICAgICAgICBpZiAobm9kZSA9PSBwYXJlbnQpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIG5vZGUgPSBub2RlLnBhcmVudE5vZGU7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbn1cblxuLyoqXG4gKiBzbWFsbCBpbmRleE9mIHdyYXBwZXJcbiAqIEBwYXJhbSB7U3RyaW5nfSBzdHJcbiAqIEBwYXJhbSB7U3RyaW5nfSBmaW5kXG4gKiBAcmV0dXJucyB7Qm9vbGVhbn0gZm91bmRcbiAqL1xuZnVuY3Rpb24gaW5TdHIoc3RyLCBmaW5kKSB7XG4gICAgcmV0dXJuIHN0ci5pbmRleE9mKGZpbmQpID4gLTE7XG59XG5cbi8qKlxuICogc3BsaXQgc3RyaW5nIG9uIHdoaXRlc3BhY2VcbiAqIEBwYXJhbSB7U3RyaW5nfSBzdHJcbiAqIEByZXR1cm5zIHtBcnJheX0gd29yZHNcbiAqL1xuZnVuY3Rpb24gc3BsaXRTdHIoc3RyKSB7XG4gICAgcmV0dXJuIHN0ci50cmltKCkuc3BsaXQoL1xccysvZyk7XG59XG5cbi8qKlxuICogZmluZCBpZiBhIGFycmF5IGNvbnRhaW5zIHRoZSBvYmplY3QgdXNpbmcgaW5kZXhPZiBvciBhIHNpbXBsZSBwb2x5RmlsbFxuICogQHBhcmFtIHtBcnJheX0gc3JjXG4gKiBAcGFyYW0ge1N0cmluZ30gZmluZFxuICogQHBhcmFtIHtTdHJpbmd9IFtmaW5kQnlLZXldXG4gKiBAcmV0dXJuIHtCb29sZWFufE51bWJlcn0gZmFsc2Ugd2hlbiBub3QgZm91bmQsIG9yIHRoZSBpbmRleFxuICovXG5mdW5jdGlvbiBpbkFycmF5KHNyYywgZmluZCwgZmluZEJ5S2V5KSB7XG4gICAgaWYgKHNyYy5pbmRleE9mICYmICFmaW5kQnlLZXkpIHtcbiAgICAgICAgcmV0dXJuIHNyYy5pbmRleE9mKGZpbmQpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBpID0gMDtcbiAgICAgICAgd2hpbGUgKGkgPCBzcmMubGVuZ3RoKSB7XG4gICAgICAgICAgICBpZiAoKGZpbmRCeUtleSAmJiBzcmNbaV1bZmluZEJ5S2V5XSA9PSBmaW5kKSB8fCAoIWZpbmRCeUtleSAmJiBzcmNbaV0gPT09IGZpbmQpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpKys7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIC0xO1xuICAgIH1cbn1cblxuLyoqXG4gKiBjb252ZXJ0IGFycmF5LWxpa2Ugb2JqZWN0cyB0byByZWFsIGFycmF5c1xuICogQHBhcmFtIHtPYmplY3R9IG9ialxuICogQHJldHVybnMge0FycmF5fVxuICovXG5mdW5jdGlvbiB0b0FycmF5KG9iaikge1xuICAgIHJldHVybiBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChvYmosIDApO1xufVxuXG4vKipcbiAqIHVuaXF1ZSBhcnJheSB3aXRoIG9iamVjdHMgYmFzZWQgb24gYSBrZXkgKGxpa2UgJ2lkJykgb3IganVzdCBieSB0aGUgYXJyYXkncyB2YWx1ZVxuICogQHBhcmFtIHtBcnJheX0gc3JjIFt7aWQ6MX0se2lkOjJ9LHtpZDoxfV1cbiAqIEBwYXJhbSB7U3RyaW5nfSBba2V5XVxuICogQHBhcmFtIHtCb29sZWFufSBbc29ydD1GYWxzZV1cbiAqIEByZXR1cm5zIHtBcnJheX0gW3tpZDoxfSx7aWQ6Mn1dXG4gKi9cbmZ1bmN0aW9uIHVuaXF1ZUFycmF5KHNyYywga2V5LCBzb3J0KSB7XG4gICAgdmFyIHJlc3VsdHMgPSBbXTtcbiAgICB2YXIgdmFsdWVzID0gW107XG4gICAgdmFyIGkgPSAwO1xuXG4gICAgd2hpbGUgKGkgPCBzcmMubGVuZ3RoKSB7XG4gICAgICAgIHZhciB2YWwgPSBrZXkgPyBzcmNbaV1ba2V5XSA6IHNyY1tpXTtcbiAgICAgICAgaWYgKGluQXJyYXkodmFsdWVzLCB2YWwpIDwgMCkge1xuICAgICAgICAgICAgcmVzdWx0cy5wdXNoKHNyY1tpXSk7XG4gICAgICAgIH1cbiAgICAgICAgdmFsdWVzW2ldID0gdmFsO1xuICAgICAgICBpKys7XG4gICAgfVxuXG4gICAgaWYgKHNvcnQpIHtcbiAgICAgICAgaWYgKCFrZXkpIHtcbiAgICAgICAgICAgIHJlc3VsdHMgPSByZXN1bHRzLnNvcnQoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJlc3VsdHMgPSByZXN1bHRzLnNvcnQoZnVuY3Rpb24gc29ydFVuaXF1ZUFycmF5KGEsIGIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gYVtrZXldID4gYltrZXldO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gcmVzdWx0cztcbn1cblxuLyoqXG4gKiBnZXQgdGhlIHByZWZpeGVkIHByb3BlcnR5XG4gKiBAcGFyYW0ge09iamVjdH0gb2JqXG4gKiBAcGFyYW0ge1N0cmluZ30gcHJvcGVydHlcbiAqIEByZXR1cm5zIHtTdHJpbmd8VW5kZWZpbmVkfSBwcmVmaXhlZFxuICovXG5mdW5jdGlvbiBwcmVmaXhlZChvYmosIHByb3BlcnR5KSB7XG4gICAgdmFyIHByZWZpeCwgcHJvcDtcbiAgICB2YXIgY2FtZWxQcm9wID0gcHJvcGVydHlbMF0udG9VcHBlckNhc2UoKSArIHByb3BlcnR5LnNsaWNlKDEpO1xuXG4gICAgdmFyIGkgPSAwO1xuICAgIHdoaWxlIChpIDwgVkVORE9SX1BSRUZJWEVTLmxlbmd0aCkge1xuICAgICAgICBwcmVmaXggPSBWRU5ET1JfUFJFRklYRVNbaV07XG4gICAgICAgIHByb3AgPSAocHJlZml4KSA/IHByZWZpeCArIGNhbWVsUHJvcCA6IHByb3BlcnR5O1xuXG4gICAgICAgIGlmIChwcm9wIGluIG9iaikge1xuICAgICAgICAgICAgcmV0dXJuIHByb3A7XG4gICAgICAgIH1cbiAgICAgICAgaSsrO1xuICAgIH1cbiAgICByZXR1cm4gdW5kZWZpbmVkO1xufVxuXG4vKipcbiAqIGdldCBhIHVuaXF1ZSBpZFxuICogQHJldHVybnMge251bWJlcn0gdW5pcXVlSWRcbiAqL1xudmFyIF91bmlxdWVJZCA9IDE7XG5mdW5jdGlvbiB1bmlxdWVJZCgpIHtcbiAgICByZXR1cm4gX3VuaXF1ZUlkKys7XG59XG5cbi8qKlxuICogZ2V0IHRoZSB3aW5kb3cgb2JqZWN0IG9mIGFuIGVsZW1lbnRcbiAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGVsZW1lbnRcbiAqIEByZXR1cm5zIHtEb2N1bWVudFZpZXd8V2luZG93fVxuICovXG5mdW5jdGlvbiBnZXRXaW5kb3dGb3JFbGVtZW50KGVsZW1lbnQpIHtcbiAgICB2YXIgZG9jID0gZWxlbWVudC5vd25lckRvY3VtZW50IHx8IGVsZW1lbnQ7XG4gICAgcmV0dXJuIChkb2MuZGVmYXVsdFZpZXcgfHwgZG9jLnBhcmVudFdpbmRvdyB8fCB3aW5kb3cpO1xufVxuXG52YXIgTU9CSUxFX1JFR0VYID0gL21vYmlsZXx0YWJsZXR8aXAoYWR8aG9uZXxvZCl8YW5kcm9pZC9pO1xuXG52YXIgU1VQUE9SVF9UT1VDSCA9ICgnb250b3VjaHN0YXJ0JyBpbiB3aW5kb3cpO1xudmFyIFNVUFBPUlRfUE9JTlRFUl9FVkVOVFMgPSBwcmVmaXhlZCh3aW5kb3csICdQb2ludGVyRXZlbnQnKSAhPT0gdW5kZWZpbmVkO1xudmFyIFNVUFBPUlRfT05MWV9UT1VDSCA9IFNVUFBPUlRfVE9VQ0ggJiYgTU9CSUxFX1JFR0VYLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCk7XG5cbnZhciBJTlBVVF9UWVBFX1RPVUNIID0gJ3RvdWNoJztcbnZhciBJTlBVVF9UWVBFX1BFTiA9ICdwZW4nO1xudmFyIElOUFVUX1RZUEVfTU9VU0UgPSAnbW91c2UnO1xudmFyIElOUFVUX1RZUEVfS0lORUNUID0gJ2tpbmVjdCc7XG5cbnZhciBDT01QVVRFX0lOVEVSVkFMID0gMjU7XG5cbnZhciBJTlBVVF9TVEFSVCA9IDE7XG52YXIgSU5QVVRfTU9WRSA9IDI7XG52YXIgSU5QVVRfRU5EID0gNDtcbnZhciBJTlBVVF9DQU5DRUwgPSA4O1xuXG52YXIgRElSRUNUSU9OX05PTkUgPSAxO1xudmFyIERJUkVDVElPTl9MRUZUID0gMjtcbnZhciBESVJFQ1RJT05fUklHSFQgPSA0O1xudmFyIERJUkVDVElPTl9VUCA9IDg7XG52YXIgRElSRUNUSU9OX0RPV04gPSAxNjtcblxudmFyIERJUkVDVElPTl9IT1JJWk9OVEFMID0gRElSRUNUSU9OX0xFRlQgfCBESVJFQ1RJT05fUklHSFQ7XG52YXIgRElSRUNUSU9OX1ZFUlRJQ0FMID0gRElSRUNUSU9OX1VQIHwgRElSRUNUSU9OX0RPV047XG52YXIgRElSRUNUSU9OX0FMTCA9IERJUkVDVElPTl9IT1JJWk9OVEFMIHwgRElSRUNUSU9OX1ZFUlRJQ0FMO1xuXG52YXIgUFJPUFNfWFkgPSBbJ3gnLCAneSddO1xudmFyIFBST1BTX0NMSUVOVF9YWSA9IFsnY2xpZW50WCcsICdjbGllbnRZJ107XG5cbi8qKlxuICogY3JlYXRlIG5ldyBpbnB1dCB0eXBlIG1hbmFnZXJcbiAqIEBwYXJhbSB7TWFuYWdlcn0gbWFuYWdlclxuICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2tcbiAqIEByZXR1cm5zIHtJbnB1dH1cbiAqIEBjb25zdHJ1Y3RvclxuICovXG5mdW5jdGlvbiBJbnB1dChtYW5hZ2VyLCBjYWxsYmFjaykge1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICB0aGlzLm1hbmFnZXIgPSBtYW5hZ2VyO1xuICAgIHRoaXMuY2FsbGJhY2sgPSBjYWxsYmFjaztcbiAgICB0aGlzLmVsZW1lbnQgPSBtYW5hZ2VyLmVsZW1lbnQ7XG4gICAgdGhpcy50YXJnZXQgPSBtYW5hZ2VyLm9wdGlvbnMuaW5wdXRUYXJnZXQ7XG5cbiAgICAvLyBzbWFsbGVyIHdyYXBwZXIgYXJvdW5kIHRoZSBoYW5kbGVyLCBmb3IgdGhlIHNjb3BlIGFuZCB0aGUgZW5hYmxlZCBzdGF0ZSBvZiB0aGUgbWFuYWdlcixcbiAgICAvLyBzbyB3aGVuIGRpc2FibGVkIHRoZSBpbnB1dCBldmVudHMgYXJlIGNvbXBsZXRlbHkgYnlwYXNzZWQuXG4gICAgdGhpcy5kb21IYW5kbGVyID0gZnVuY3Rpb24oZXYpIHtcbiAgICAgICAgaWYgKGJvb2xPckZuKG1hbmFnZXIub3B0aW9ucy5lbmFibGUsIFttYW5hZ2VyXSkpIHtcbiAgICAgICAgICAgIHNlbGYuaGFuZGxlcihldik7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgdGhpcy5pbml0KCk7XG5cbn1cblxuSW5wdXQucHJvdG90eXBlID0ge1xuICAgIC8qKlxuICAgICAqIHNob3VsZCBoYW5kbGUgdGhlIGlucHV0RXZlbnQgZGF0YSBhbmQgdHJpZ2dlciB0aGUgY2FsbGJhY2tcbiAgICAgKiBAdmlydHVhbFxuICAgICAqL1xuICAgIGhhbmRsZXI6IGZ1bmN0aW9uKCkgeyB9LFxuXG4gICAgLyoqXG4gICAgICogYmluZCB0aGUgZXZlbnRzXG4gICAgICovXG4gICAgaW5pdDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMuZXZFbCAmJiBhZGRFdmVudExpc3RlbmVycyh0aGlzLmVsZW1lbnQsIHRoaXMuZXZFbCwgdGhpcy5kb21IYW5kbGVyKTtcbiAgICAgICAgdGhpcy5ldlRhcmdldCAmJiBhZGRFdmVudExpc3RlbmVycyh0aGlzLnRhcmdldCwgdGhpcy5ldlRhcmdldCwgdGhpcy5kb21IYW5kbGVyKTtcbiAgICAgICAgdGhpcy5ldldpbiAmJiBhZGRFdmVudExpc3RlbmVycyhnZXRXaW5kb3dGb3JFbGVtZW50KHRoaXMuZWxlbWVudCksIHRoaXMuZXZXaW4sIHRoaXMuZG9tSGFuZGxlcik7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIHVuYmluZCB0aGUgZXZlbnRzXG4gICAgICovXG4gICAgZGVzdHJveTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMuZXZFbCAmJiByZW1vdmVFdmVudExpc3RlbmVycyh0aGlzLmVsZW1lbnQsIHRoaXMuZXZFbCwgdGhpcy5kb21IYW5kbGVyKTtcbiAgICAgICAgdGhpcy5ldlRhcmdldCAmJiByZW1vdmVFdmVudExpc3RlbmVycyh0aGlzLnRhcmdldCwgdGhpcy5ldlRhcmdldCwgdGhpcy5kb21IYW5kbGVyKTtcbiAgICAgICAgdGhpcy5ldldpbiAmJiByZW1vdmVFdmVudExpc3RlbmVycyhnZXRXaW5kb3dGb3JFbGVtZW50KHRoaXMuZWxlbWVudCksIHRoaXMuZXZXaW4sIHRoaXMuZG9tSGFuZGxlcik7XG4gICAgfVxufTtcblxuLyoqXG4gKiBjcmVhdGUgbmV3IGlucHV0IHR5cGUgbWFuYWdlclxuICogY2FsbGVkIGJ5IHRoZSBNYW5hZ2VyIGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge0hhbW1lcn0gbWFuYWdlclxuICogQHJldHVybnMge0lucHV0fVxuICovXG5mdW5jdGlvbiBjcmVhdGVJbnB1dEluc3RhbmNlKG1hbmFnZXIpIHtcbiAgICB2YXIgVHlwZTtcbiAgICB2YXIgaW5wdXRDbGFzcyA9IG1hbmFnZXIub3B0aW9ucy5pbnB1dENsYXNzO1xuXG4gICAgaWYgKGlucHV0Q2xhc3MpIHtcbiAgICAgICAgVHlwZSA9IGlucHV0Q2xhc3M7XG4gICAgfSBlbHNlIGlmIChTVVBQT1JUX1BPSU5URVJfRVZFTlRTKSB7XG4gICAgICAgIFR5cGUgPSBQb2ludGVyRXZlbnRJbnB1dDtcbiAgICB9IGVsc2UgaWYgKFNVUFBPUlRfT05MWV9UT1VDSCkge1xuICAgICAgICBUeXBlID0gVG91Y2hJbnB1dDtcbiAgICB9IGVsc2UgaWYgKCFTVVBQT1JUX1RPVUNIKSB7XG4gICAgICAgIFR5cGUgPSBNb3VzZUlucHV0O1xuICAgIH0gZWxzZSB7XG4gICAgICAgIFR5cGUgPSBUb3VjaE1vdXNlSW5wdXQ7XG4gICAgfVxuICAgIHJldHVybiBuZXcgKFR5cGUpKG1hbmFnZXIsIGlucHV0SGFuZGxlcik7XG59XG5cbi8qKlxuICogaGFuZGxlIGlucHV0IGV2ZW50c1xuICogQHBhcmFtIHtNYW5hZ2VyfSBtYW5hZ2VyXG4gKiBAcGFyYW0ge1N0cmluZ30gZXZlbnRUeXBlXG4gKiBAcGFyYW0ge09iamVjdH0gaW5wdXRcbiAqL1xuZnVuY3Rpb24gaW5wdXRIYW5kbGVyKG1hbmFnZXIsIGV2ZW50VHlwZSwgaW5wdXQpIHtcbiAgICB2YXIgcG9pbnRlcnNMZW4gPSBpbnB1dC5wb2ludGVycy5sZW5ndGg7XG4gICAgdmFyIGNoYW5nZWRQb2ludGVyc0xlbiA9IGlucHV0LmNoYW5nZWRQb2ludGVycy5sZW5ndGg7XG4gICAgdmFyIGlzRmlyc3QgPSAoZXZlbnRUeXBlICYgSU5QVVRfU1RBUlQgJiYgKHBvaW50ZXJzTGVuIC0gY2hhbmdlZFBvaW50ZXJzTGVuID09PSAwKSk7XG4gICAgdmFyIGlzRmluYWwgPSAoZXZlbnRUeXBlICYgKElOUFVUX0VORCB8IElOUFVUX0NBTkNFTCkgJiYgKHBvaW50ZXJzTGVuIC0gY2hhbmdlZFBvaW50ZXJzTGVuID09PSAwKSk7XG5cbiAgICBpbnB1dC5pc0ZpcnN0ID0gISFpc0ZpcnN0O1xuICAgIGlucHV0LmlzRmluYWwgPSAhIWlzRmluYWw7XG5cbiAgICBpZiAoaXNGaXJzdCkge1xuICAgICAgICBtYW5hZ2VyLnNlc3Npb24gPSB7fTtcbiAgICB9XG5cbiAgICAvLyBzb3VyY2UgZXZlbnQgaXMgdGhlIG5vcm1hbGl6ZWQgdmFsdWUgb2YgdGhlIGRvbUV2ZW50c1xuICAgIC8vIGxpa2UgJ3RvdWNoc3RhcnQsIG1vdXNldXAsIHBvaW50ZXJkb3duJ1xuICAgIGlucHV0LmV2ZW50VHlwZSA9IGV2ZW50VHlwZTtcblxuICAgIC8vIGNvbXB1dGUgc2NhbGUsIHJvdGF0aW9uIGV0Y1xuICAgIGNvbXB1dGVJbnB1dERhdGEobWFuYWdlciwgaW5wdXQpO1xuXG4gICAgLy8gZW1pdCBzZWNyZXQgZXZlbnRcbiAgICBtYW5hZ2VyLmVtaXQoJ2hhbW1lci5pbnB1dCcsIGlucHV0KTtcblxuICAgIG1hbmFnZXIucmVjb2duaXplKGlucHV0KTtcbiAgICBtYW5hZ2VyLnNlc3Npb24ucHJldklucHV0ID0gaW5wdXQ7XG59XG5cbi8qKlxuICogZXh0ZW5kIHRoZSBkYXRhIHdpdGggc29tZSB1c2FibGUgcHJvcGVydGllcyBsaWtlIHNjYWxlLCByb3RhdGUsIHZlbG9jaXR5IGV0Y1xuICogQHBhcmFtIHtPYmplY3R9IG1hbmFnZXJcbiAqIEBwYXJhbSB7T2JqZWN0fSBpbnB1dFxuICovXG5mdW5jdGlvbiBjb21wdXRlSW5wdXREYXRhKG1hbmFnZXIsIGlucHV0KSB7XG4gICAgdmFyIHNlc3Npb24gPSBtYW5hZ2VyLnNlc3Npb247XG4gICAgdmFyIHBvaW50ZXJzID0gaW5wdXQucG9pbnRlcnM7XG4gICAgdmFyIHBvaW50ZXJzTGVuZ3RoID0gcG9pbnRlcnMubGVuZ3RoO1xuXG4gICAgLy8gc3RvcmUgdGhlIGZpcnN0IGlucHV0IHRvIGNhbGN1bGF0ZSB0aGUgZGlzdGFuY2UgYW5kIGRpcmVjdGlvblxuICAgIGlmICghc2Vzc2lvbi5maXJzdElucHV0KSB7XG4gICAgICAgIHNlc3Npb24uZmlyc3RJbnB1dCA9IHNpbXBsZUNsb25lSW5wdXREYXRhKGlucHV0KTtcbiAgICB9XG5cbiAgICAvLyB0byBjb21wdXRlIHNjYWxlIGFuZCByb3RhdGlvbiB3ZSBuZWVkIHRvIHN0b3JlIHRoZSBtdWx0aXBsZSB0b3VjaGVzXG4gICAgaWYgKHBvaW50ZXJzTGVuZ3RoID4gMSAmJiAhc2Vzc2lvbi5maXJzdE11bHRpcGxlKSB7XG4gICAgICAgIHNlc3Npb24uZmlyc3RNdWx0aXBsZSA9IHNpbXBsZUNsb25lSW5wdXREYXRhKGlucHV0KTtcbiAgICB9IGVsc2UgaWYgKHBvaW50ZXJzTGVuZ3RoID09PSAxKSB7XG4gICAgICAgIHNlc3Npb24uZmlyc3RNdWx0aXBsZSA9IGZhbHNlO1xuICAgIH1cblxuICAgIHZhciBmaXJzdElucHV0ID0gc2Vzc2lvbi5maXJzdElucHV0O1xuICAgIHZhciBmaXJzdE11bHRpcGxlID0gc2Vzc2lvbi5maXJzdE11bHRpcGxlO1xuICAgIHZhciBvZmZzZXRDZW50ZXIgPSBmaXJzdE11bHRpcGxlID8gZmlyc3RNdWx0aXBsZS5jZW50ZXIgOiBmaXJzdElucHV0LmNlbnRlcjtcblxuICAgIHZhciBjZW50ZXIgPSBpbnB1dC5jZW50ZXIgPSBnZXRDZW50ZXIocG9pbnRlcnMpO1xuICAgIGlucHV0LnRpbWVTdGFtcCA9IG5vdygpO1xuICAgIGlucHV0LmRlbHRhVGltZSA9IGlucHV0LnRpbWVTdGFtcCAtIGZpcnN0SW5wdXQudGltZVN0YW1wO1xuXG4gICAgaW5wdXQuYW5nbGUgPSBnZXRBbmdsZShvZmZzZXRDZW50ZXIsIGNlbnRlcik7XG4gICAgaW5wdXQuZGlzdGFuY2UgPSBnZXREaXN0YW5jZShvZmZzZXRDZW50ZXIsIGNlbnRlcik7XG5cbiAgICBjb21wdXRlRGVsdGFYWShzZXNzaW9uLCBpbnB1dCk7XG4gICAgaW5wdXQub2Zmc2V0RGlyZWN0aW9uID0gZ2V0RGlyZWN0aW9uKGlucHV0LmRlbHRhWCwgaW5wdXQuZGVsdGFZKTtcblxuICAgIHZhciBvdmVyYWxsVmVsb2NpdHkgPSBnZXRWZWxvY2l0eShpbnB1dC5kZWx0YVRpbWUsIGlucHV0LmRlbHRhWCwgaW5wdXQuZGVsdGFZKTtcbiAgICBpbnB1dC5vdmVyYWxsVmVsb2NpdHlYID0gb3ZlcmFsbFZlbG9jaXR5Lng7XG4gICAgaW5wdXQub3ZlcmFsbFZlbG9jaXR5WSA9IG92ZXJhbGxWZWxvY2l0eS55O1xuICAgIGlucHV0Lm92ZXJhbGxWZWxvY2l0eSA9IChhYnMob3ZlcmFsbFZlbG9jaXR5LngpID4gYWJzKG92ZXJhbGxWZWxvY2l0eS55KSkgPyBvdmVyYWxsVmVsb2NpdHkueCA6IG92ZXJhbGxWZWxvY2l0eS55O1xuXG4gICAgaW5wdXQuc2NhbGUgPSBmaXJzdE11bHRpcGxlID8gZ2V0U2NhbGUoZmlyc3RNdWx0aXBsZS5wb2ludGVycywgcG9pbnRlcnMpIDogMTtcbiAgICBpbnB1dC5yb3RhdGlvbiA9IGZpcnN0TXVsdGlwbGUgPyBnZXRSb3RhdGlvbihmaXJzdE11bHRpcGxlLnBvaW50ZXJzLCBwb2ludGVycykgOiAwO1xuXG4gICAgaW5wdXQubWF4UG9pbnRlcnMgPSAhc2Vzc2lvbi5wcmV2SW5wdXQgPyBpbnB1dC5wb2ludGVycy5sZW5ndGggOiAoKGlucHV0LnBvaW50ZXJzLmxlbmd0aCA+XG4gICAgICAgIHNlc3Npb24ucHJldklucHV0Lm1heFBvaW50ZXJzKSA/IGlucHV0LnBvaW50ZXJzLmxlbmd0aCA6IHNlc3Npb24ucHJldklucHV0Lm1heFBvaW50ZXJzKTtcblxuICAgIGNvbXB1dGVJbnRlcnZhbElucHV0RGF0YShzZXNzaW9uLCBpbnB1dCk7XG5cbiAgICAvLyBmaW5kIHRoZSBjb3JyZWN0IHRhcmdldFxuICAgIHZhciB0YXJnZXQgPSBtYW5hZ2VyLmVsZW1lbnQ7XG4gICAgaWYgKGhhc1BhcmVudChpbnB1dC5zcmNFdmVudC50YXJnZXQsIHRhcmdldCkpIHtcbiAgICAgICAgdGFyZ2V0ID0gaW5wdXQuc3JjRXZlbnQudGFyZ2V0O1xuICAgIH1cbiAgICBpbnB1dC50YXJnZXQgPSB0YXJnZXQ7XG59XG5cbmZ1bmN0aW9uIGNvbXB1dGVEZWx0YVhZKHNlc3Npb24sIGlucHV0KSB7XG4gICAgdmFyIGNlbnRlciA9IGlucHV0LmNlbnRlcjtcbiAgICB2YXIgb2Zmc2V0ID0gc2Vzc2lvbi5vZmZzZXREZWx0YSB8fCB7fTtcbiAgICB2YXIgcHJldkRlbHRhID0gc2Vzc2lvbi5wcmV2RGVsdGEgfHwge307XG4gICAgdmFyIHByZXZJbnB1dCA9IHNlc3Npb24ucHJldklucHV0IHx8IHt9O1xuXG4gICAgaWYgKGlucHV0LmV2ZW50VHlwZSA9PT0gSU5QVVRfU1RBUlQgfHwgcHJldklucHV0LmV2ZW50VHlwZSA9PT0gSU5QVVRfRU5EKSB7XG4gICAgICAgIHByZXZEZWx0YSA9IHNlc3Npb24ucHJldkRlbHRhID0ge1xuICAgICAgICAgICAgeDogcHJldklucHV0LmRlbHRhWCB8fCAwLFxuICAgICAgICAgICAgeTogcHJldklucHV0LmRlbHRhWSB8fCAwXG4gICAgICAgIH07XG5cbiAgICAgICAgb2Zmc2V0ID0gc2Vzc2lvbi5vZmZzZXREZWx0YSA9IHtcbiAgICAgICAgICAgIHg6IGNlbnRlci54LFxuICAgICAgICAgICAgeTogY2VudGVyLnlcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBpbnB1dC5kZWx0YVggPSBwcmV2RGVsdGEueCArIChjZW50ZXIueCAtIG9mZnNldC54KTtcbiAgICBpbnB1dC5kZWx0YVkgPSBwcmV2RGVsdGEueSArIChjZW50ZXIueSAtIG9mZnNldC55KTtcbn1cblxuLyoqXG4gKiB2ZWxvY2l0eSBpcyBjYWxjdWxhdGVkIGV2ZXJ5IHggbXNcbiAqIEBwYXJhbSB7T2JqZWN0fSBzZXNzaW9uXG4gKiBAcGFyYW0ge09iamVjdH0gaW5wdXRcbiAqL1xuZnVuY3Rpb24gY29tcHV0ZUludGVydmFsSW5wdXREYXRhKHNlc3Npb24sIGlucHV0KSB7XG4gICAgdmFyIGxhc3QgPSBzZXNzaW9uLmxhc3RJbnRlcnZhbCB8fCBpbnB1dCxcbiAgICAgICAgZGVsdGFUaW1lID0gaW5wdXQudGltZVN0YW1wIC0gbGFzdC50aW1lU3RhbXAsXG4gICAgICAgIHZlbG9jaXR5LCB2ZWxvY2l0eVgsIHZlbG9jaXR5WSwgZGlyZWN0aW9uO1xuXG4gICAgaWYgKGlucHV0LmV2ZW50VHlwZSAhPSBJTlBVVF9DQU5DRUwgJiYgKGRlbHRhVGltZSA+IENPTVBVVEVfSU5URVJWQUwgfHwgbGFzdC52ZWxvY2l0eSA9PT0gdW5kZWZpbmVkKSkge1xuICAgICAgICB2YXIgZGVsdGFYID0gaW5wdXQuZGVsdGFYIC0gbGFzdC5kZWx0YVg7XG4gICAgICAgIHZhciBkZWx0YVkgPSBpbnB1dC5kZWx0YVkgLSBsYXN0LmRlbHRhWTtcblxuICAgICAgICB2YXIgdiA9IGdldFZlbG9jaXR5KGRlbHRhVGltZSwgZGVsdGFYLCBkZWx0YVkpO1xuICAgICAgICB2ZWxvY2l0eVggPSB2Lng7XG4gICAgICAgIHZlbG9jaXR5WSA9IHYueTtcbiAgICAgICAgdmVsb2NpdHkgPSAoYWJzKHYueCkgPiBhYnModi55KSkgPyB2LnggOiB2Lnk7XG4gICAgICAgIGRpcmVjdGlvbiA9IGdldERpcmVjdGlvbihkZWx0YVgsIGRlbHRhWSk7XG5cbiAgICAgICAgc2Vzc2lvbi5sYXN0SW50ZXJ2YWwgPSBpbnB1dDtcbiAgICB9IGVsc2Uge1xuICAgICAgICAvLyB1c2UgbGF0ZXN0IHZlbG9jaXR5IGluZm8gaWYgaXQgZG9lc24ndCBvdmVydGFrZSBhIG1pbmltdW0gcGVyaW9kXG4gICAgICAgIHZlbG9jaXR5ID0gbGFzdC52ZWxvY2l0eTtcbiAgICAgICAgdmVsb2NpdHlYID0gbGFzdC52ZWxvY2l0eVg7XG4gICAgICAgIHZlbG9jaXR5WSA9IGxhc3QudmVsb2NpdHlZO1xuICAgICAgICBkaXJlY3Rpb24gPSBsYXN0LmRpcmVjdGlvbjtcbiAgICB9XG5cbiAgICBpbnB1dC52ZWxvY2l0eSA9IHZlbG9jaXR5O1xuICAgIGlucHV0LnZlbG9jaXR5WCA9IHZlbG9jaXR5WDtcbiAgICBpbnB1dC52ZWxvY2l0eVkgPSB2ZWxvY2l0eVk7XG4gICAgaW5wdXQuZGlyZWN0aW9uID0gZGlyZWN0aW9uO1xufVxuXG4vKipcbiAqIGNyZWF0ZSBhIHNpbXBsZSBjbG9uZSBmcm9tIHRoZSBpbnB1dCB1c2VkIGZvciBzdG9yYWdlIG9mIGZpcnN0SW5wdXQgYW5kIGZpcnN0TXVsdGlwbGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBpbnB1dFxuICogQHJldHVybnMge09iamVjdH0gY2xvbmVkSW5wdXREYXRhXG4gKi9cbmZ1bmN0aW9uIHNpbXBsZUNsb25lSW5wdXREYXRhKGlucHV0KSB7XG4gICAgLy8gbWFrZSBhIHNpbXBsZSBjb3B5IG9mIHRoZSBwb2ludGVycyBiZWNhdXNlIHdlIHdpbGwgZ2V0IGEgcmVmZXJlbmNlIGlmIHdlIGRvbid0XG4gICAgLy8gd2Ugb25seSBuZWVkIGNsaWVudFhZIGZvciB0aGUgY2FsY3VsYXRpb25zXG4gICAgdmFyIHBvaW50ZXJzID0gW107XG4gICAgdmFyIGkgPSAwO1xuICAgIHdoaWxlIChpIDwgaW5wdXQucG9pbnRlcnMubGVuZ3RoKSB7XG4gICAgICAgIHBvaW50ZXJzW2ldID0ge1xuICAgICAgICAgICAgY2xpZW50WDogcm91bmQoaW5wdXQucG9pbnRlcnNbaV0uY2xpZW50WCksXG4gICAgICAgICAgICBjbGllbnRZOiByb3VuZChpbnB1dC5wb2ludGVyc1tpXS5jbGllbnRZKVxuICAgICAgICB9O1xuICAgICAgICBpKys7XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgICAgdGltZVN0YW1wOiBub3coKSxcbiAgICAgICAgcG9pbnRlcnM6IHBvaW50ZXJzLFxuICAgICAgICBjZW50ZXI6IGdldENlbnRlcihwb2ludGVycyksXG4gICAgICAgIGRlbHRhWDogaW5wdXQuZGVsdGFYLFxuICAgICAgICBkZWx0YVk6IGlucHV0LmRlbHRhWVxuICAgIH07XG59XG5cbi8qKlxuICogZ2V0IHRoZSBjZW50ZXIgb2YgYWxsIHRoZSBwb2ludGVyc1xuICogQHBhcmFtIHtBcnJheX0gcG9pbnRlcnNcbiAqIEByZXR1cm4ge09iamVjdH0gY2VudGVyIGNvbnRhaW5zIGB4YCBhbmQgYHlgIHByb3BlcnRpZXNcbiAqL1xuZnVuY3Rpb24gZ2V0Q2VudGVyKHBvaW50ZXJzKSB7XG4gICAgdmFyIHBvaW50ZXJzTGVuZ3RoID0gcG9pbnRlcnMubGVuZ3RoO1xuXG4gICAgLy8gbm8gbmVlZCB0byBsb29wIHdoZW4gb25seSBvbmUgdG91Y2hcbiAgICBpZiAocG9pbnRlcnNMZW5ndGggPT09IDEpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHg6IHJvdW5kKHBvaW50ZXJzWzBdLmNsaWVudFgpLFxuICAgICAgICAgICAgeTogcm91bmQocG9pbnRlcnNbMF0uY2xpZW50WSlcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICB2YXIgeCA9IDAsIHkgPSAwLCBpID0gMDtcbiAgICB3aGlsZSAoaSA8IHBvaW50ZXJzTGVuZ3RoKSB7XG4gICAgICAgIHggKz0gcG9pbnRlcnNbaV0uY2xpZW50WDtcbiAgICAgICAgeSArPSBwb2ludGVyc1tpXS5jbGllbnRZO1xuICAgICAgICBpKys7XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgICAgeDogcm91bmQoeCAvIHBvaW50ZXJzTGVuZ3RoKSxcbiAgICAgICAgeTogcm91bmQoeSAvIHBvaW50ZXJzTGVuZ3RoKVxuICAgIH07XG59XG5cbi8qKlxuICogY2FsY3VsYXRlIHRoZSB2ZWxvY2l0eSBiZXR3ZWVuIHR3byBwb2ludHMuIHVuaXQgaXMgaW4gcHggcGVyIG1zLlxuICogQHBhcmFtIHtOdW1iZXJ9IGRlbHRhVGltZVxuICogQHBhcmFtIHtOdW1iZXJ9IHhcbiAqIEBwYXJhbSB7TnVtYmVyfSB5XG4gKiBAcmV0dXJuIHtPYmplY3R9IHZlbG9jaXR5IGB4YCBhbmQgYHlgXG4gKi9cbmZ1bmN0aW9uIGdldFZlbG9jaXR5KGRlbHRhVGltZSwgeCwgeSkge1xuICAgIHJldHVybiB7XG4gICAgICAgIHg6IHggLyBkZWx0YVRpbWUgfHwgMCxcbiAgICAgICAgeTogeSAvIGRlbHRhVGltZSB8fCAwXG4gICAgfTtcbn1cblxuLyoqXG4gKiBnZXQgdGhlIGRpcmVjdGlvbiBiZXR3ZWVuIHR3byBwb2ludHNcbiAqIEBwYXJhbSB7TnVtYmVyfSB4XG4gKiBAcGFyYW0ge051bWJlcn0geVxuICogQHJldHVybiB7TnVtYmVyfSBkaXJlY3Rpb25cbiAqL1xuZnVuY3Rpb24gZ2V0RGlyZWN0aW9uKHgsIHkpIHtcbiAgICBpZiAoeCA9PT0geSkge1xuICAgICAgICByZXR1cm4gRElSRUNUSU9OX05PTkU7XG4gICAgfVxuXG4gICAgaWYgKGFicyh4KSA+PSBhYnMoeSkpIHtcbiAgICAgICAgcmV0dXJuIHggPCAwID8gRElSRUNUSU9OX0xFRlQgOiBESVJFQ1RJT05fUklHSFQ7XG4gICAgfVxuICAgIHJldHVybiB5IDwgMCA/IERJUkVDVElPTl9VUCA6IERJUkVDVElPTl9ET1dOO1xufVxuXG4vKipcbiAqIGNhbGN1bGF0ZSB0aGUgYWJzb2x1dGUgZGlzdGFuY2UgYmV0d2VlbiB0d28gcG9pbnRzXG4gKiBAcGFyYW0ge09iamVjdH0gcDEge3gsIHl9XG4gKiBAcGFyYW0ge09iamVjdH0gcDIge3gsIHl9XG4gKiBAcGFyYW0ge0FycmF5fSBbcHJvcHNdIGNvbnRhaW5pbmcgeCBhbmQgeSBrZXlzXG4gKiBAcmV0dXJuIHtOdW1iZXJ9IGRpc3RhbmNlXG4gKi9cbmZ1bmN0aW9uIGdldERpc3RhbmNlKHAxLCBwMiwgcHJvcHMpIHtcbiAgICBpZiAoIXByb3BzKSB7XG4gICAgICAgIHByb3BzID0gUFJPUFNfWFk7XG4gICAgfVxuICAgIHZhciB4ID0gcDJbcHJvcHNbMF1dIC0gcDFbcHJvcHNbMF1dLFxuICAgICAgICB5ID0gcDJbcHJvcHNbMV1dIC0gcDFbcHJvcHNbMV1dO1xuXG4gICAgcmV0dXJuIE1hdGguc3FydCgoeCAqIHgpICsgKHkgKiB5KSk7XG59XG5cbi8qKlxuICogY2FsY3VsYXRlIHRoZSBhbmdsZSBiZXR3ZWVuIHR3byBjb29yZGluYXRlc1xuICogQHBhcmFtIHtPYmplY3R9IHAxXG4gKiBAcGFyYW0ge09iamVjdH0gcDJcbiAqIEBwYXJhbSB7QXJyYXl9IFtwcm9wc10gY29udGFpbmluZyB4IGFuZCB5IGtleXNcbiAqIEByZXR1cm4ge051bWJlcn0gYW5nbGVcbiAqL1xuZnVuY3Rpb24gZ2V0QW5nbGUocDEsIHAyLCBwcm9wcykge1xuICAgIGlmICghcHJvcHMpIHtcbiAgICAgICAgcHJvcHMgPSBQUk9QU19YWTtcbiAgICB9XG4gICAgdmFyIHggPSBwMltwcm9wc1swXV0gLSBwMVtwcm9wc1swXV0sXG4gICAgICAgIHkgPSBwMltwcm9wc1sxXV0gLSBwMVtwcm9wc1sxXV07XG4gICAgcmV0dXJuIE1hdGguYXRhbjIoeSwgeCkgKiAxODAgLyBNYXRoLlBJO1xufVxuXG4vKipcbiAqIGNhbGN1bGF0ZSB0aGUgcm90YXRpb24gZGVncmVlcyBiZXR3ZWVuIHR3byBwb2ludGVyc2V0c1xuICogQHBhcmFtIHtBcnJheX0gc3RhcnQgYXJyYXkgb2YgcG9pbnRlcnNcbiAqIEBwYXJhbSB7QXJyYXl9IGVuZCBhcnJheSBvZiBwb2ludGVyc1xuICogQHJldHVybiB7TnVtYmVyfSByb3RhdGlvblxuICovXG5mdW5jdGlvbiBnZXRSb3RhdGlvbihzdGFydCwgZW5kKSB7XG4gICAgcmV0dXJuIGdldEFuZ2xlKGVuZFsxXSwgZW5kWzBdLCBQUk9QU19DTElFTlRfWFkpICsgZ2V0QW5nbGUoc3RhcnRbMV0sIHN0YXJ0WzBdLCBQUk9QU19DTElFTlRfWFkpO1xufVxuXG4vKipcbiAqIGNhbGN1bGF0ZSB0aGUgc2NhbGUgZmFjdG9yIGJldHdlZW4gdHdvIHBvaW50ZXJzZXRzXG4gKiBubyBzY2FsZSBpcyAxLCBhbmQgZ29lcyBkb3duIHRvIDAgd2hlbiBwaW5jaGVkIHRvZ2V0aGVyLCBhbmQgYmlnZ2VyIHdoZW4gcGluY2hlZCBvdXRcbiAqIEBwYXJhbSB7QXJyYXl9IHN0YXJ0IGFycmF5IG9mIHBvaW50ZXJzXG4gKiBAcGFyYW0ge0FycmF5fSBlbmQgYXJyYXkgb2YgcG9pbnRlcnNcbiAqIEByZXR1cm4ge051bWJlcn0gc2NhbGVcbiAqL1xuZnVuY3Rpb24gZ2V0U2NhbGUoc3RhcnQsIGVuZCkge1xuICAgIHJldHVybiBnZXREaXN0YW5jZShlbmRbMF0sIGVuZFsxXSwgUFJPUFNfQ0xJRU5UX1hZKSAvIGdldERpc3RhbmNlKHN0YXJ0WzBdLCBzdGFydFsxXSwgUFJPUFNfQ0xJRU5UX1hZKTtcbn1cblxudmFyIE1PVVNFX0lOUFVUX01BUCA9IHtcbiAgICBtb3VzZWRvd246IElOUFVUX1NUQVJULFxuICAgIG1vdXNlbW92ZTogSU5QVVRfTU9WRSxcbiAgICBtb3VzZXVwOiBJTlBVVF9FTkRcbn07XG5cbnZhciBNT1VTRV9FTEVNRU5UX0VWRU5UUyA9ICdtb3VzZWRvd24nO1xudmFyIE1PVVNFX1dJTkRPV19FVkVOVFMgPSAnbW91c2Vtb3ZlIG1vdXNldXAnO1xuXG4vKipcbiAqIE1vdXNlIGV2ZW50cyBpbnB1dFxuICogQGNvbnN0cnVjdG9yXG4gKiBAZXh0ZW5kcyBJbnB1dFxuICovXG5mdW5jdGlvbiBNb3VzZUlucHV0KCkge1xuICAgIHRoaXMuZXZFbCA9IE1PVVNFX0VMRU1FTlRfRVZFTlRTO1xuICAgIHRoaXMuZXZXaW4gPSBNT1VTRV9XSU5ET1dfRVZFTlRTO1xuXG4gICAgdGhpcy5wcmVzc2VkID0gZmFsc2U7IC8vIG1vdXNlZG93biBzdGF0ZVxuXG4gICAgSW5wdXQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn1cblxuaW5oZXJpdChNb3VzZUlucHV0LCBJbnB1dCwge1xuICAgIC8qKlxuICAgICAqIGhhbmRsZSBtb3VzZSBldmVudHNcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZXZcbiAgICAgKi9cbiAgICBoYW5kbGVyOiBmdW5jdGlvbiBNRWhhbmRsZXIoZXYpIHtcbiAgICAgICAgdmFyIGV2ZW50VHlwZSA9IE1PVVNFX0lOUFVUX01BUFtldi50eXBlXTtcblxuICAgICAgICAvLyBvbiBzdGFydCB3ZSB3YW50IHRvIGhhdmUgdGhlIGxlZnQgbW91c2UgYnV0dG9uIGRvd25cbiAgICAgICAgaWYgKGV2ZW50VHlwZSAmIElOUFVUX1NUQVJUICYmIGV2LmJ1dHRvbiA9PT0gMCkge1xuICAgICAgICAgICAgdGhpcy5wcmVzc2VkID0gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChldmVudFR5cGUgJiBJTlBVVF9NT1ZFICYmIGV2LndoaWNoICE9PSAxKSB7XG4gICAgICAgICAgICBldmVudFR5cGUgPSBJTlBVVF9FTkQ7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBtb3VzZSBtdXN0IGJlIGRvd25cbiAgICAgICAgaWYgKCF0aGlzLnByZXNzZWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChldmVudFR5cGUgJiBJTlBVVF9FTkQpIHtcbiAgICAgICAgICAgIHRoaXMucHJlc3NlZCA9IGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5jYWxsYmFjayh0aGlzLm1hbmFnZXIsIGV2ZW50VHlwZSwge1xuICAgICAgICAgICAgcG9pbnRlcnM6IFtldl0sXG4gICAgICAgICAgICBjaGFuZ2VkUG9pbnRlcnM6IFtldl0sXG4gICAgICAgICAgICBwb2ludGVyVHlwZTogSU5QVVRfVFlQRV9NT1VTRSxcbiAgICAgICAgICAgIHNyY0V2ZW50OiBldlxuICAgICAgICB9KTtcbiAgICB9XG59KTtcblxudmFyIFBPSU5URVJfSU5QVVRfTUFQID0ge1xuICAgIHBvaW50ZXJkb3duOiBJTlBVVF9TVEFSVCxcbiAgICBwb2ludGVybW92ZTogSU5QVVRfTU9WRSxcbiAgICBwb2ludGVydXA6IElOUFVUX0VORCxcbiAgICBwb2ludGVyY2FuY2VsOiBJTlBVVF9DQU5DRUwsXG4gICAgcG9pbnRlcm91dDogSU5QVVRfQ0FOQ0VMXG59O1xuXG4vLyBpbiBJRTEwIHRoZSBwb2ludGVyIHR5cGVzIGlzIGRlZmluZWQgYXMgYW4gZW51bVxudmFyIElFMTBfUE9JTlRFUl9UWVBFX0VOVU0gPSB7XG4gICAgMjogSU5QVVRfVFlQRV9UT1VDSCxcbiAgICAzOiBJTlBVVF9UWVBFX1BFTixcbiAgICA0OiBJTlBVVF9UWVBFX01PVVNFLFxuICAgIDU6IElOUFVUX1RZUEVfS0lORUNUIC8vIHNlZSBodHRwczovL3R3aXR0ZXIuY29tL2phY29icm9zc2kvc3RhdHVzLzQ4MDU5NjQzODQ4OTg5MDgxNlxufTtcblxudmFyIFBPSU5URVJfRUxFTUVOVF9FVkVOVFMgPSAncG9pbnRlcmRvd24nO1xudmFyIFBPSU5URVJfV0lORE9XX0VWRU5UUyA9ICdwb2ludGVybW92ZSBwb2ludGVydXAgcG9pbnRlcmNhbmNlbCc7XG5cbi8vIElFMTAgaGFzIHByZWZpeGVkIHN1cHBvcnQsIGFuZCBjYXNlLXNlbnNpdGl2ZVxuaWYgKHdpbmRvdy5NU1BvaW50ZXJFdmVudCAmJiAhd2luZG93LlBvaW50ZXJFdmVudCkge1xuICAgIFBPSU5URVJfRUxFTUVOVF9FVkVOVFMgPSAnTVNQb2ludGVyRG93bic7XG4gICAgUE9JTlRFUl9XSU5ET1dfRVZFTlRTID0gJ01TUG9pbnRlck1vdmUgTVNQb2ludGVyVXAgTVNQb2ludGVyQ2FuY2VsJztcbn1cblxuLyoqXG4gKiBQb2ludGVyIGV2ZW50cyBpbnB1dFxuICogQGNvbnN0cnVjdG9yXG4gKiBAZXh0ZW5kcyBJbnB1dFxuICovXG5mdW5jdGlvbiBQb2ludGVyRXZlbnRJbnB1dCgpIHtcbiAgICB0aGlzLmV2RWwgPSBQT0lOVEVSX0VMRU1FTlRfRVZFTlRTO1xuICAgIHRoaXMuZXZXaW4gPSBQT0lOVEVSX1dJTkRPV19FVkVOVFM7XG5cbiAgICBJbnB1dC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXG4gICAgdGhpcy5zdG9yZSA9ICh0aGlzLm1hbmFnZXIuc2Vzc2lvbi5wb2ludGVyRXZlbnRzID0gW10pO1xufVxuXG5pbmhlcml0KFBvaW50ZXJFdmVudElucHV0LCBJbnB1dCwge1xuICAgIC8qKlxuICAgICAqIGhhbmRsZSBtb3VzZSBldmVudHNcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZXZcbiAgICAgKi9cbiAgICBoYW5kbGVyOiBmdW5jdGlvbiBQRWhhbmRsZXIoZXYpIHtcbiAgICAgICAgdmFyIHN0b3JlID0gdGhpcy5zdG9yZTtcbiAgICAgICAgdmFyIHJlbW92ZVBvaW50ZXIgPSBmYWxzZTtcblxuICAgICAgICB2YXIgZXZlbnRUeXBlTm9ybWFsaXplZCA9IGV2LnR5cGUudG9Mb3dlckNhc2UoKS5yZXBsYWNlKCdtcycsICcnKTtcbiAgICAgICAgdmFyIGV2ZW50VHlwZSA9IFBPSU5URVJfSU5QVVRfTUFQW2V2ZW50VHlwZU5vcm1hbGl6ZWRdO1xuICAgICAgICB2YXIgcG9pbnRlclR5cGUgPSBJRTEwX1BPSU5URVJfVFlQRV9FTlVNW2V2LnBvaW50ZXJUeXBlXSB8fCBldi5wb2ludGVyVHlwZTtcblxuICAgICAgICB2YXIgaXNUb3VjaCA9IChwb2ludGVyVHlwZSA9PSBJTlBVVF9UWVBFX1RPVUNIKTtcblxuICAgICAgICAvLyBnZXQgaW5kZXggb2YgdGhlIGV2ZW50IGluIHRoZSBzdG9yZVxuICAgICAgICB2YXIgc3RvcmVJbmRleCA9IGluQXJyYXkoc3RvcmUsIGV2LnBvaW50ZXJJZCwgJ3BvaW50ZXJJZCcpO1xuXG4gICAgICAgIC8vIHN0YXJ0IGFuZCBtb3VzZSBtdXN0IGJlIGRvd25cbiAgICAgICAgaWYgKGV2ZW50VHlwZSAmIElOUFVUX1NUQVJUICYmIChldi5idXR0b24gPT09IDAgfHwgaXNUb3VjaCkpIHtcbiAgICAgICAgICAgIGlmIChzdG9yZUluZGV4IDwgMCkge1xuICAgICAgICAgICAgICAgIHN0b3JlLnB1c2goZXYpO1xuICAgICAgICAgICAgICAgIHN0b3JlSW5kZXggPSBzdG9yZS5sZW5ndGggLSAxO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKGV2ZW50VHlwZSAmIChJTlBVVF9FTkQgfCBJTlBVVF9DQU5DRUwpKSB7XG4gICAgICAgICAgICByZW1vdmVQb2ludGVyID0gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGl0IG5vdCBmb3VuZCwgc28gdGhlIHBvaW50ZXIgaGFzbid0IGJlZW4gZG93biAoc28gaXQncyBwcm9iYWJseSBhIGhvdmVyKVxuICAgICAgICBpZiAoc3RvcmVJbmRleCA8IDApIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHVwZGF0ZSB0aGUgZXZlbnQgaW4gdGhlIHN0b3JlXG4gICAgICAgIHN0b3JlW3N0b3JlSW5kZXhdID0gZXY7XG5cbiAgICAgICAgdGhpcy5jYWxsYmFjayh0aGlzLm1hbmFnZXIsIGV2ZW50VHlwZSwge1xuICAgICAgICAgICAgcG9pbnRlcnM6IHN0b3JlLFxuICAgICAgICAgICAgY2hhbmdlZFBvaW50ZXJzOiBbZXZdLFxuICAgICAgICAgICAgcG9pbnRlclR5cGU6IHBvaW50ZXJUeXBlLFxuICAgICAgICAgICAgc3JjRXZlbnQ6IGV2XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGlmIChyZW1vdmVQb2ludGVyKSB7XG4gICAgICAgICAgICAvLyByZW1vdmUgZnJvbSB0aGUgc3RvcmVcbiAgICAgICAgICAgIHN0b3JlLnNwbGljZShzdG9yZUluZGV4LCAxKTtcbiAgICAgICAgfVxuICAgIH1cbn0pO1xuXG52YXIgU0lOR0xFX1RPVUNIX0lOUFVUX01BUCA9IHtcbiAgICB0b3VjaHN0YXJ0OiBJTlBVVF9TVEFSVCxcbiAgICB0b3VjaG1vdmU6IElOUFVUX01PVkUsXG4gICAgdG91Y2hlbmQ6IElOUFVUX0VORCxcbiAgICB0b3VjaGNhbmNlbDogSU5QVVRfQ0FOQ0VMXG59O1xuXG52YXIgU0lOR0xFX1RPVUNIX1RBUkdFVF9FVkVOVFMgPSAndG91Y2hzdGFydCc7XG52YXIgU0lOR0xFX1RPVUNIX1dJTkRPV19FVkVOVFMgPSAndG91Y2hzdGFydCB0b3VjaG1vdmUgdG91Y2hlbmQgdG91Y2hjYW5jZWwnO1xuXG4vKipcbiAqIFRvdWNoIGV2ZW50cyBpbnB1dFxuICogQGNvbnN0cnVjdG9yXG4gKiBAZXh0ZW5kcyBJbnB1dFxuICovXG5mdW5jdGlvbiBTaW5nbGVUb3VjaElucHV0KCkge1xuICAgIHRoaXMuZXZUYXJnZXQgPSBTSU5HTEVfVE9VQ0hfVEFSR0VUX0VWRU5UUztcbiAgICB0aGlzLmV2V2luID0gU0lOR0xFX1RPVUNIX1dJTkRPV19FVkVOVFM7XG4gICAgdGhpcy5zdGFydGVkID0gZmFsc2U7XG5cbiAgICBJbnB1dC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufVxuXG5pbmhlcml0KFNpbmdsZVRvdWNoSW5wdXQsIElucHV0LCB7XG4gICAgaGFuZGxlcjogZnVuY3Rpb24gVEVoYW5kbGVyKGV2KSB7XG4gICAgICAgIHZhciB0eXBlID0gU0lOR0xFX1RPVUNIX0lOUFVUX01BUFtldi50eXBlXTtcblxuICAgICAgICAvLyBzaG91bGQgd2UgaGFuZGxlIHRoZSB0b3VjaCBldmVudHM/XG4gICAgICAgIGlmICh0eXBlID09PSBJTlBVVF9TVEFSVCkge1xuICAgICAgICAgICAgdGhpcy5zdGFydGVkID0gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghdGhpcy5zdGFydGVkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgdG91Y2hlcyA9IG5vcm1hbGl6ZVNpbmdsZVRvdWNoZXMuY2FsbCh0aGlzLCBldiwgdHlwZSk7XG5cbiAgICAgICAgLy8gd2hlbiBkb25lLCByZXNldCB0aGUgc3RhcnRlZCBzdGF0ZVxuICAgICAgICBpZiAodHlwZSAmIChJTlBVVF9FTkQgfCBJTlBVVF9DQU5DRUwpICYmIHRvdWNoZXNbMF0ubGVuZ3RoIC0gdG91Y2hlc1sxXS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHRoaXMuc3RhcnRlZCA9IGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5jYWxsYmFjayh0aGlzLm1hbmFnZXIsIHR5cGUsIHtcbiAgICAgICAgICAgIHBvaW50ZXJzOiB0b3VjaGVzWzBdLFxuICAgICAgICAgICAgY2hhbmdlZFBvaW50ZXJzOiB0b3VjaGVzWzFdLFxuICAgICAgICAgICAgcG9pbnRlclR5cGU6IElOUFVUX1RZUEVfVE9VQ0gsXG4gICAgICAgICAgICBzcmNFdmVudDogZXZcbiAgICAgICAgfSk7XG4gICAgfVxufSk7XG5cbi8qKlxuICogQHRoaXMge1RvdWNoSW5wdXR9XG4gKiBAcGFyYW0ge09iamVjdH0gZXZcbiAqIEBwYXJhbSB7TnVtYmVyfSB0eXBlIGZsYWdcbiAqIEByZXR1cm5zIHt1bmRlZmluZWR8QXJyYXl9IFthbGwsIGNoYW5nZWRdXG4gKi9cbmZ1bmN0aW9uIG5vcm1hbGl6ZVNpbmdsZVRvdWNoZXMoZXYsIHR5cGUpIHtcbiAgICB2YXIgYWxsID0gdG9BcnJheShldi50b3VjaGVzKTtcbiAgICB2YXIgY2hhbmdlZCA9IHRvQXJyYXkoZXYuY2hhbmdlZFRvdWNoZXMpO1xuXG4gICAgaWYgKHR5cGUgJiAoSU5QVVRfRU5EIHwgSU5QVVRfQ0FOQ0VMKSkge1xuICAgICAgICBhbGwgPSB1bmlxdWVBcnJheShhbGwuY29uY2F0KGNoYW5nZWQpLCAnaWRlbnRpZmllcicsIHRydWUpO1xuICAgIH1cblxuICAgIHJldHVybiBbYWxsLCBjaGFuZ2VkXTtcbn1cblxudmFyIFRPVUNIX0lOUFVUX01BUCA9IHtcbiAgICB0b3VjaHN0YXJ0OiBJTlBVVF9TVEFSVCxcbiAgICB0b3VjaG1vdmU6IElOUFVUX01PVkUsXG4gICAgdG91Y2hlbmQ6IElOUFVUX0VORCxcbiAgICB0b3VjaGNhbmNlbDogSU5QVVRfQ0FOQ0VMXG59O1xuXG52YXIgVE9VQ0hfVEFSR0VUX0VWRU5UUyA9ICd0b3VjaHN0YXJ0IHRvdWNobW92ZSB0b3VjaGVuZCB0b3VjaGNhbmNlbCc7XG5cbi8qKlxuICogTXVsdGktdXNlciB0b3VjaCBldmVudHMgaW5wdXRcbiAqIEBjb25zdHJ1Y3RvclxuICogQGV4dGVuZHMgSW5wdXRcbiAqL1xuZnVuY3Rpb24gVG91Y2hJbnB1dCgpIHtcbiAgICB0aGlzLmV2VGFyZ2V0ID0gVE9VQ0hfVEFSR0VUX0VWRU5UUztcbiAgICB0aGlzLnRhcmdldElkcyA9IHt9O1xuXG4gICAgSW5wdXQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn1cblxuaW5oZXJpdChUb3VjaElucHV0LCBJbnB1dCwge1xuICAgIGhhbmRsZXI6IGZ1bmN0aW9uIE1URWhhbmRsZXIoZXYpIHtcbiAgICAgICAgdmFyIHR5cGUgPSBUT1VDSF9JTlBVVF9NQVBbZXYudHlwZV07XG4gICAgICAgIHZhciB0b3VjaGVzID0gZ2V0VG91Y2hlcy5jYWxsKHRoaXMsIGV2LCB0eXBlKTtcbiAgICAgICAgaWYgKCF0b3VjaGVzKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmNhbGxiYWNrKHRoaXMubWFuYWdlciwgdHlwZSwge1xuICAgICAgICAgICAgcG9pbnRlcnM6IHRvdWNoZXNbMF0sXG4gICAgICAgICAgICBjaGFuZ2VkUG9pbnRlcnM6IHRvdWNoZXNbMV0sXG4gICAgICAgICAgICBwb2ludGVyVHlwZTogSU5QVVRfVFlQRV9UT1VDSCxcbiAgICAgICAgICAgIHNyY0V2ZW50OiBldlxuICAgICAgICB9KTtcbiAgICB9XG59KTtcblxuLyoqXG4gKiBAdGhpcyB7VG91Y2hJbnB1dH1cbiAqIEBwYXJhbSB7T2JqZWN0fSBldlxuICogQHBhcmFtIHtOdW1iZXJ9IHR5cGUgZmxhZ1xuICogQHJldHVybnMge3VuZGVmaW5lZHxBcnJheX0gW2FsbCwgY2hhbmdlZF1cbiAqL1xuZnVuY3Rpb24gZ2V0VG91Y2hlcyhldiwgdHlwZSkge1xuICAgIHZhciBhbGxUb3VjaGVzID0gdG9BcnJheShldi50b3VjaGVzKTtcbiAgICB2YXIgdGFyZ2V0SWRzID0gdGhpcy50YXJnZXRJZHM7XG5cbiAgICAvLyB3aGVuIHRoZXJlIGlzIG9ubHkgb25lIHRvdWNoLCB0aGUgcHJvY2VzcyBjYW4gYmUgc2ltcGxpZmllZFxuICAgIGlmICh0eXBlICYgKElOUFVUX1NUQVJUIHwgSU5QVVRfTU9WRSkgJiYgYWxsVG91Y2hlcy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgdGFyZ2V0SWRzW2FsbFRvdWNoZXNbMF0uaWRlbnRpZmllcl0gPSB0cnVlO1xuICAgICAgICByZXR1cm4gW2FsbFRvdWNoZXMsIGFsbFRvdWNoZXNdO1xuICAgIH1cblxuICAgIHZhciBpLFxuICAgICAgICB0YXJnZXRUb3VjaGVzLFxuICAgICAgICBjaGFuZ2VkVG91Y2hlcyA9IHRvQXJyYXkoZXYuY2hhbmdlZFRvdWNoZXMpLFxuICAgICAgICBjaGFuZ2VkVGFyZ2V0VG91Y2hlcyA9IFtdLFxuICAgICAgICB0YXJnZXQgPSB0aGlzLnRhcmdldDtcblxuICAgIC8vIGdldCB0YXJnZXQgdG91Y2hlcyBmcm9tIHRvdWNoZXNcbiAgICB0YXJnZXRUb3VjaGVzID0gYWxsVG91Y2hlcy5maWx0ZXIoZnVuY3Rpb24odG91Y2gpIHtcbiAgICAgICAgcmV0dXJuIGhhc1BhcmVudCh0b3VjaC50YXJnZXQsIHRhcmdldCk7XG4gICAgfSk7XG5cbiAgICAvLyBjb2xsZWN0IHRvdWNoZXNcbiAgICBpZiAodHlwZSA9PT0gSU5QVVRfU1RBUlQpIHtcbiAgICAgICAgaSA9IDA7XG4gICAgICAgIHdoaWxlIChpIDwgdGFyZ2V0VG91Y2hlcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHRhcmdldElkc1t0YXJnZXRUb3VjaGVzW2ldLmlkZW50aWZpZXJdID0gdHJ1ZTtcbiAgICAgICAgICAgIGkrKztcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIGZpbHRlciBjaGFuZ2VkIHRvdWNoZXMgdG8gb25seSBjb250YWluIHRvdWNoZXMgdGhhdCBleGlzdCBpbiB0aGUgY29sbGVjdGVkIHRhcmdldCBpZHNcbiAgICBpID0gMDtcbiAgICB3aGlsZSAoaSA8IGNoYW5nZWRUb3VjaGVzLmxlbmd0aCkge1xuICAgICAgICBpZiAodGFyZ2V0SWRzW2NoYW5nZWRUb3VjaGVzW2ldLmlkZW50aWZpZXJdKSB7XG4gICAgICAgICAgICBjaGFuZ2VkVGFyZ2V0VG91Y2hlcy5wdXNoKGNoYW5nZWRUb3VjaGVzW2ldKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGNsZWFudXAgcmVtb3ZlZCB0b3VjaGVzXG4gICAgICAgIGlmICh0eXBlICYgKElOUFVUX0VORCB8IElOUFVUX0NBTkNFTCkpIHtcbiAgICAgICAgICAgIGRlbGV0ZSB0YXJnZXRJZHNbY2hhbmdlZFRvdWNoZXNbaV0uaWRlbnRpZmllcl07XG4gICAgICAgIH1cbiAgICAgICAgaSsrO1xuICAgIH1cblxuICAgIGlmICghY2hhbmdlZFRhcmdldFRvdWNoZXMubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICByZXR1cm4gW1xuICAgICAgICAvLyBtZXJnZSB0YXJnZXRUb3VjaGVzIHdpdGggY2hhbmdlZFRhcmdldFRvdWNoZXMgc28gaXQgY29udGFpbnMgQUxMIHRvdWNoZXMsIGluY2x1ZGluZyAnZW5kJyBhbmQgJ2NhbmNlbCdcbiAgICAgICAgdW5pcXVlQXJyYXkodGFyZ2V0VG91Y2hlcy5jb25jYXQoY2hhbmdlZFRhcmdldFRvdWNoZXMpLCAnaWRlbnRpZmllcicsIHRydWUpLFxuICAgICAgICBjaGFuZ2VkVGFyZ2V0VG91Y2hlc1xuICAgIF07XG59XG5cbi8qKlxuICogQ29tYmluZWQgdG91Y2ggYW5kIG1vdXNlIGlucHV0XG4gKlxuICogVG91Y2ggaGFzIGEgaGlnaGVyIHByaW9yaXR5IHRoZW4gbW91c2UsIGFuZCB3aGlsZSB0b3VjaGluZyBubyBtb3VzZSBldmVudHMgYXJlIGFsbG93ZWQuXG4gKiBUaGlzIGJlY2F1c2UgdG91Y2ggZGV2aWNlcyBhbHNvIGVtaXQgbW91c2UgZXZlbnRzIHdoaWxlIGRvaW5nIGEgdG91Y2guXG4gKlxuICogQGNvbnN0cnVjdG9yXG4gKiBAZXh0ZW5kcyBJbnB1dFxuICovXG5cbnZhciBERURVUF9USU1FT1VUID0gMjUwMDtcbnZhciBERURVUF9ESVNUQU5DRSA9IDI1O1xuXG5mdW5jdGlvbiBUb3VjaE1vdXNlSW5wdXQoKSB7XG4gICAgSW5wdXQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblxuICAgIHZhciBoYW5kbGVyID0gYmluZEZuKHRoaXMuaGFuZGxlciwgdGhpcyk7XG4gICAgdGhpcy50b3VjaCA9IG5ldyBUb3VjaElucHV0KHRoaXMubWFuYWdlciwgaGFuZGxlcik7XG4gICAgdGhpcy5tb3VzZSA9IG5ldyBNb3VzZUlucHV0KHRoaXMubWFuYWdlciwgaGFuZGxlcik7XG5cbiAgICB0aGlzLnByaW1hcnlUb3VjaCA9IG51bGw7XG4gICAgdGhpcy5sYXN0VG91Y2hlcyA9IFtdO1xufVxuXG5pbmhlcml0KFRvdWNoTW91c2VJbnB1dCwgSW5wdXQsIHtcbiAgICAvKipcbiAgICAgKiBoYW5kbGUgbW91c2UgYW5kIHRvdWNoIGV2ZW50c1xuICAgICAqIEBwYXJhbSB7SGFtbWVyfSBtYW5hZ2VyXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGlucHV0RXZlbnRcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gaW5wdXREYXRhXG4gICAgICovXG4gICAgaGFuZGxlcjogZnVuY3Rpb24gVE1FaGFuZGxlcihtYW5hZ2VyLCBpbnB1dEV2ZW50LCBpbnB1dERhdGEpIHtcbiAgICAgICAgdmFyIGlzVG91Y2ggPSAoaW5wdXREYXRhLnBvaW50ZXJUeXBlID09IElOUFVUX1RZUEVfVE9VQ0gpLFxuICAgICAgICAgICAgaXNNb3VzZSA9IChpbnB1dERhdGEucG9pbnRlclR5cGUgPT0gSU5QVVRfVFlQRV9NT1VTRSk7XG5cbiAgICAgICAgaWYgKGlzTW91c2UgJiYgaW5wdXREYXRhLnNvdXJjZUNhcGFiaWxpdGllcyAmJiBpbnB1dERhdGEuc291cmNlQ2FwYWJpbGl0aWVzLmZpcmVzVG91Y2hFdmVudHMpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHdoZW4gd2UncmUgaW4gYSB0b3VjaCBldmVudCwgcmVjb3JkIHRvdWNoZXMgdG8gIGRlLWR1cGUgc3ludGhldGljIG1vdXNlIGV2ZW50XG4gICAgICAgIGlmIChpc1RvdWNoKSB7XG4gICAgICAgICAgICByZWNvcmRUb3VjaGVzLmNhbGwodGhpcywgaW5wdXRFdmVudCwgaW5wdXREYXRhKTtcbiAgICAgICAgfSBlbHNlIGlmIChpc01vdXNlICYmIGlzU3ludGhldGljRXZlbnQuY2FsbCh0aGlzLCBpbnB1dERhdGEpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmNhbGxiYWNrKG1hbmFnZXIsIGlucHV0RXZlbnQsIGlucHV0RGF0YSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIHJlbW92ZSB0aGUgZXZlbnQgbGlzdGVuZXJzXG4gICAgICovXG4gICAgZGVzdHJveTogZnVuY3Rpb24gZGVzdHJveSgpIHtcbiAgICAgICAgdGhpcy50b3VjaC5kZXN0cm95KCk7XG4gICAgICAgIHRoaXMubW91c2UuZGVzdHJveSgpO1xuICAgIH1cbn0pO1xuXG5mdW5jdGlvbiByZWNvcmRUb3VjaGVzKGV2ZW50VHlwZSwgZXZlbnREYXRhKSB7XG4gICAgaWYgKGV2ZW50VHlwZSAmIElOUFVUX1NUQVJUKSB7XG4gICAgICAgIHRoaXMucHJpbWFyeVRvdWNoID0gZXZlbnREYXRhLmNoYW5nZWRQb2ludGVyc1swXS5pZGVudGlmaWVyO1xuICAgICAgICBzZXRMYXN0VG91Y2guY2FsbCh0aGlzLCBldmVudERhdGEpO1xuICAgIH0gZWxzZSBpZiAoZXZlbnRUeXBlICYgKElOUFVUX0VORCB8IElOUFVUX0NBTkNFTCkpIHtcbiAgICAgICAgc2V0TGFzdFRvdWNoLmNhbGwodGhpcywgZXZlbnREYXRhKTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIHNldExhc3RUb3VjaChldmVudERhdGEpIHtcbiAgICB2YXIgdG91Y2ggPSBldmVudERhdGEuY2hhbmdlZFBvaW50ZXJzWzBdO1xuXG4gICAgaWYgKHRvdWNoLmlkZW50aWZpZXIgPT09IHRoaXMucHJpbWFyeVRvdWNoKSB7XG4gICAgICAgIHZhciBsYXN0VG91Y2ggPSB7eDogdG91Y2guY2xpZW50WCwgeTogdG91Y2guY2xpZW50WX07XG4gICAgICAgIHRoaXMubGFzdFRvdWNoZXMucHVzaChsYXN0VG91Y2gpO1xuICAgICAgICB2YXIgbHRzID0gdGhpcy5sYXN0VG91Y2hlcztcbiAgICAgICAgdmFyIHJlbW92ZUxhc3RUb3VjaCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdmFyIGkgPSBsdHMuaW5kZXhPZihsYXN0VG91Y2gpO1xuICAgICAgICAgICAgaWYgKGkgPiAtMSkge1xuICAgICAgICAgICAgICAgIGx0cy5zcGxpY2UoaSwgMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHNldFRpbWVvdXQocmVtb3ZlTGFzdFRvdWNoLCBERURVUF9USU1FT1VUKTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIGlzU3ludGhldGljRXZlbnQoZXZlbnREYXRhKSB7XG4gICAgdmFyIHggPSBldmVudERhdGEuc3JjRXZlbnQuY2xpZW50WCwgeSA9IGV2ZW50RGF0YS5zcmNFdmVudC5jbGllbnRZO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5sYXN0VG91Y2hlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgdCA9IHRoaXMubGFzdFRvdWNoZXNbaV07XG4gICAgICAgIHZhciBkeCA9IE1hdGguYWJzKHggLSB0LngpLCBkeSA9IE1hdGguYWJzKHkgLSB0LnkpO1xuICAgICAgICBpZiAoZHggPD0gREVEVVBfRElTVEFOQ0UgJiYgZHkgPD0gREVEVVBfRElTVEFOQ0UpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbn1cblxudmFyIFBSRUZJWEVEX1RPVUNIX0FDVElPTiA9IHByZWZpeGVkKFRFU1RfRUxFTUVOVC5zdHlsZSwgJ3RvdWNoQWN0aW9uJyk7XG52YXIgTkFUSVZFX1RPVUNIX0FDVElPTiA9IFBSRUZJWEVEX1RPVUNIX0FDVElPTiAhPT0gdW5kZWZpbmVkO1xuXG4vLyBtYWdpY2FsIHRvdWNoQWN0aW9uIHZhbHVlXG52YXIgVE9VQ0hfQUNUSU9OX0NPTVBVVEUgPSAnY29tcHV0ZSc7XG52YXIgVE9VQ0hfQUNUSU9OX0FVVE8gPSAnYXV0byc7XG52YXIgVE9VQ0hfQUNUSU9OX01BTklQVUxBVElPTiA9ICdtYW5pcHVsYXRpb24nOyAvLyBub3QgaW1wbGVtZW50ZWRcbnZhciBUT1VDSF9BQ1RJT05fTk9ORSA9ICdub25lJztcbnZhciBUT1VDSF9BQ1RJT05fUEFOX1ggPSAncGFuLXgnO1xudmFyIFRPVUNIX0FDVElPTl9QQU5fWSA9ICdwYW4teSc7XG52YXIgVE9VQ0hfQUNUSU9OX01BUCA9IGdldFRvdWNoQWN0aW9uUHJvcHMoKTtcblxuLyoqXG4gKiBUb3VjaCBBY3Rpb25cbiAqIHNldHMgdGhlIHRvdWNoQWN0aW9uIHByb3BlcnR5IG9yIHVzZXMgdGhlIGpzIGFsdGVybmF0aXZlXG4gKiBAcGFyYW0ge01hbmFnZXJ9IG1hbmFnZXJcbiAqIEBwYXJhbSB7U3RyaW5nfSB2YWx1ZVxuICogQGNvbnN0cnVjdG9yXG4gKi9cbmZ1bmN0aW9uIFRvdWNoQWN0aW9uKG1hbmFnZXIsIHZhbHVlKSB7XG4gICAgdGhpcy5tYW5hZ2VyID0gbWFuYWdlcjtcbiAgICB0aGlzLnNldCh2YWx1ZSk7XG59XG5cblRvdWNoQWN0aW9uLnByb3RvdHlwZSA9IHtcbiAgICAvKipcbiAgICAgKiBzZXQgdGhlIHRvdWNoQWN0aW9uIHZhbHVlIG9uIHRoZSBlbGVtZW50IG9yIGVuYWJsZSB0aGUgcG9seWZpbGxcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gdmFsdWVcbiAgICAgKi9cbiAgICBzZXQ6IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgIC8vIGZpbmQgb3V0IHRoZSB0b3VjaC1hY3Rpb24gYnkgdGhlIGV2ZW50IGhhbmRsZXJzXG4gICAgICAgIGlmICh2YWx1ZSA9PSBUT1VDSF9BQ1RJT05fQ09NUFVURSkge1xuICAgICAgICAgICAgdmFsdWUgPSB0aGlzLmNvbXB1dGUoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChOQVRJVkVfVE9VQ0hfQUNUSU9OICYmIHRoaXMubWFuYWdlci5lbGVtZW50LnN0eWxlICYmIFRPVUNIX0FDVElPTl9NQVBbdmFsdWVdKSB7XG4gICAgICAgICAgICB0aGlzLm1hbmFnZXIuZWxlbWVudC5zdHlsZVtQUkVGSVhFRF9UT1VDSF9BQ1RJT05dID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5hY3Rpb25zID0gdmFsdWUudG9Mb3dlckNhc2UoKS50cmltKCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIGp1c3QgcmUtc2V0IHRoZSB0b3VjaEFjdGlvbiB2YWx1ZVxuICAgICAqL1xuICAgIHVwZGF0ZTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMuc2V0KHRoaXMubWFuYWdlci5vcHRpb25zLnRvdWNoQWN0aW9uKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogY29tcHV0ZSB0aGUgdmFsdWUgZm9yIHRoZSB0b3VjaEFjdGlvbiBwcm9wZXJ0eSBiYXNlZCBvbiB0aGUgcmVjb2duaXplcidzIHNldHRpbmdzXG4gICAgICogQHJldHVybnMge1N0cmluZ30gdmFsdWVcbiAgICAgKi9cbiAgICBjb21wdXRlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGFjdGlvbnMgPSBbXTtcbiAgICAgICAgZWFjaCh0aGlzLm1hbmFnZXIucmVjb2duaXplcnMsIGZ1bmN0aW9uKHJlY29nbml6ZXIpIHtcbiAgICAgICAgICAgIGlmIChib29sT3JGbihyZWNvZ25pemVyLm9wdGlvbnMuZW5hYmxlLCBbcmVjb2duaXplcl0pKSB7XG4gICAgICAgICAgICAgICAgYWN0aW9ucyA9IGFjdGlvbnMuY29uY2F0KHJlY29nbml6ZXIuZ2V0VG91Y2hBY3Rpb24oKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gY2xlYW5Ub3VjaEFjdGlvbnMoYWN0aW9ucy5qb2luKCcgJykpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiB0aGlzIG1ldGhvZCBpcyBjYWxsZWQgb24gZWFjaCBpbnB1dCBjeWNsZSBhbmQgcHJvdmlkZXMgdGhlIHByZXZlbnRpbmcgb2YgdGhlIGJyb3dzZXIgYmVoYXZpb3JcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gaW5wdXRcbiAgICAgKi9cbiAgICBwcmV2ZW50RGVmYXVsdHM6IGZ1bmN0aW9uKGlucHV0KSB7XG4gICAgICAgIHZhciBzcmNFdmVudCA9IGlucHV0LnNyY0V2ZW50O1xuICAgICAgICB2YXIgZGlyZWN0aW9uID0gaW5wdXQub2Zmc2V0RGlyZWN0aW9uO1xuXG4gICAgICAgIC8vIGlmIHRoZSB0b3VjaCBhY3Rpb24gZGlkIHByZXZlbnRlZCBvbmNlIHRoaXMgc2Vzc2lvblxuICAgICAgICBpZiAodGhpcy5tYW5hZ2VyLnNlc3Npb24ucHJldmVudGVkKSB7XG4gICAgICAgICAgICBzcmNFdmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGFjdGlvbnMgPSB0aGlzLmFjdGlvbnM7XG4gICAgICAgIHZhciBoYXNOb25lID0gaW5TdHIoYWN0aW9ucywgVE9VQ0hfQUNUSU9OX05PTkUpICYmICFUT1VDSF9BQ1RJT05fTUFQW1RPVUNIX0FDVElPTl9OT05FXTtcbiAgICAgICAgdmFyIGhhc1BhblkgPSBpblN0cihhY3Rpb25zLCBUT1VDSF9BQ1RJT05fUEFOX1kpICYmICFUT1VDSF9BQ1RJT05fTUFQW1RPVUNIX0FDVElPTl9QQU5fWV07XG4gICAgICAgIHZhciBoYXNQYW5YID0gaW5TdHIoYWN0aW9ucywgVE9VQ0hfQUNUSU9OX1BBTl9YKSAmJiAhVE9VQ0hfQUNUSU9OX01BUFtUT1VDSF9BQ1RJT05fUEFOX1hdO1xuXG4gICAgICAgIGlmIChoYXNOb25lKSB7XG4gICAgICAgICAgICAvL2RvIG5vdCBwcmV2ZW50IGRlZmF1bHRzIGlmIHRoaXMgaXMgYSB0YXAgZ2VzdHVyZVxuXG4gICAgICAgICAgICB2YXIgaXNUYXBQb2ludGVyID0gaW5wdXQucG9pbnRlcnMubGVuZ3RoID09PSAxO1xuICAgICAgICAgICAgdmFyIGlzVGFwTW92ZW1lbnQgPSBpbnB1dC5kaXN0YW5jZSA8IDI7XG4gICAgICAgICAgICB2YXIgaXNUYXBUb3VjaFRpbWUgPSBpbnB1dC5kZWx0YVRpbWUgPCAyNTA7XG5cbiAgICAgICAgICAgIGlmIChpc1RhcFBvaW50ZXIgJiYgaXNUYXBNb3ZlbWVudCAmJiBpc1RhcFRvdWNoVGltZSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChoYXNQYW5YICYmIGhhc1BhblkpIHtcbiAgICAgICAgICAgIC8vIGBwYW4teCBwYW4teWAgbWVhbnMgYnJvd3NlciBoYW5kbGVzIGFsbCBzY3JvbGxpbmcvcGFubmluZywgZG8gbm90IHByZXZlbnRcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChoYXNOb25lIHx8XG4gICAgICAgICAgICAoaGFzUGFuWSAmJiBkaXJlY3Rpb24gJiBESVJFQ1RJT05fSE9SSVpPTlRBTCkgfHxcbiAgICAgICAgICAgIChoYXNQYW5YICYmIGRpcmVjdGlvbiAmIERJUkVDVElPTl9WRVJUSUNBTCkpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnByZXZlbnRTcmMoc3JjRXZlbnQpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIGNhbGwgcHJldmVudERlZmF1bHQgdG8gcHJldmVudCB0aGUgYnJvd3NlcidzIGRlZmF1bHQgYmVoYXZpb3IgKHNjcm9sbGluZyBpbiBtb3N0IGNhc2VzKVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBzcmNFdmVudFxuICAgICAqL1xuICAgIHByZXZlbnRTcmM6IGZ1bmN0aW9uKHNyY0V2ZW50KSB7XG4gICAgICAgIHRoaXMubWFuYWdlci5zZXNzaW9uLnByZXZlbnRlZCA9IHRydWU7XG4gICAgICAgIHNyY0V2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgfVxufTtcblxuLyoqXG4gKiB3aGVuIHRoZSB0b3VjaEFjdGlvbnMgYXJlIGNvbGxlY3RlZCB0aGV5IGFyZSBub3QgYSB2YWxpZCB2YWx1ZSwgc28gd2UgbmVlZCB0byBjbGVhbiB0aGluZ3MgdXAuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBhY3Rpb25zXG4gKiBAcmV0dXJucyB7Kn1cbiAqL1xuZnVuY3Rpb24gY2xlYW5Ub3VjaEFjdGlvbnMoYWN0aW9ucykge1xuICAgIC8vIG5vbmVcbiAgICBpZiAoaW5TdHIoYWN0aW9ucywgVE9VQ0hfQUNUSU9OX05PTkUpKSB7XG4gICAgICAgIHJldHVybiBUT1VDSF9BQ1RJT05fTk9ORTtcbiAgICB9XG5cbiAgICB2YXIgaGFzUGFuWCA9IGluU3RyKGFjdGlvbnMsIFRPVUNIX0FDVElPTl9QQU5fWCk7XG4gICAgdmFyIGhhc1BhblkgPSBpblN0cihhY3Rpb25zLCBUT1VDSF9BQ1RJT05fUEFOX1kpO1xuXG4gICAgLy8gaWYgYm90aCBwYW4teCBhbmQgcGFuLXkgYXJlIHNldCAoZGlmZmVyZW50IHJlY29nbml6ZXJzXG4gICAgLy8gZm9yIGRpZmZlcmVudCBkaXJlY3Rpb25zLCBlLmcuIGhvcml6b250YWwgcGFuIGJ1dCB2ZXJ0aWNhbCBzd2lwZT8pXG4gICAgLy8gd2UgbmVlZCBub25lIChhcyBvdGhlcndpc2Ugd2l0aCBwYW4teCBwYW4teSBjb21iaW5lZCBub25lIG9mIHRoZXNlXG4gICAgLy8gcmVjb2duaXplcnMgd2lsbCB3b3JrLCBzaW5jZSB0aGUgYnJvd3NlciB3b3VsZCBoYW5kbGUgYWxsIHBhbm5pbmdcbiAgICBpZiAoaGFzUGFuWCAmJiBoYXNQYW5ZKSB7XG4gICAgICAgIHJldHVybiBUT1VDSF9BQ1RJT05fTk9ORTtcbiAgICB9XG5cbiAgICAvLyBwYW4teCBPUiBwYW4teVxuICAgIGlmIChoYXNQYW5YIHx8IGhhc1BhblkpIHtcbiAgICAgICAgcmV0dXJuIGhhc1BhblggPyBUT1VDSF9BQ1RJT05fUEFOX1ggOiBUT1VDSF9BQ1RJT05fUEFOX1k7XG4gICAgfVxuXG4gICAgLy8gbWFuaXB1bGF0aW9uXG4gICAgaWYgKGluU3RyKGFjdGlvbnMsIFRPVUNIX0FDVElPTl9NQU5JUFVMQVRJT04pKSB7XG4gICAgICAgIHJldHVybiBUT1VDSF9BQ1RJT05fTUFOSVBVTEFUSU9OO1xuICAgIH1cblxuICAgIHJldHVybiBUT1VDSF9BQ1RJT05fQVVUTztcbn1cblxuZnVuY3Rpb24gZ2V0VG91Y2hBY3Rpb25Qcm9wcygpIHtcbiAgICBpZiAoIU5BVElWRV9UT1VDSF9BQ1RJT04pIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICB2YXIgdG91Y2hNYXAgPSB7fTtcbiAgICB2YXIgY3NzU3VwcG9ydHMgPSB3aW5kb3cuQ1NTICYmIHdpbmRvdy5DU1Muc3VwcG9ydHM7XG4gICAgWydhdXRvJywgJ21hbmlwdWxhdGlvbicsICdwYW4teScsICdwYW4teCcsICdwYW4teCBwYW4teScsICdub25lJ10uZm9yRWFjaChmdW5jdGlvbih2YWwpIHtcblxuICAgICAgICAvLyBJZiBjc3Muc3VwcG9ydHMgaXMgbm90IHN1cHBvcnRlZCBidXQgdGhlcmUgaXMgbmF0aXZlIHRvdWNoLWFjdGlvbiBhc3N1bWUgaXQgc3VwcG9ydHNcbiAgICAgICAgLy8gYWxsIHZhbHVlcy4gVGhpcyBpcyB0aGUgY2FzZSBmb3IgSUUgMTAgYW5kIDExLlxuICAgICAgICB0b3VjaE1hcFt2YWxdID0gY3NzU3VwcG9ydHMgPyB3aW5kb3cuQ1NTLnN1cHBvcnRzKCd0b3VjaC1hY3Rpb24nLCB2YWwpIDogdHJ1ZTtcbiAgICB9KTtcbiAgICByZXR1cm4gdG91Y2hNYXA7XG59XG5cbi8qKlxuICogUmVjb2duaXplciBmbG93IGV4cGxhaW5lZDsgKlxuICogQWxsIHJlY29nbml6ZXJzIGhhdmUgdGhlIGluaXRpYWwgc3RhdGUgb2YgUE9TU0lCTEUgd2hlbiBhIGlucHV0IHNlc3Npb24gc3RhcnRzLlxuICogVGhlIGRlZmluaXRpb24gb2YgYSBpbnB1dCBzZXNzaW9uIGlzIGZyb20gdGhlIGZpcnN0IGlucHV0IHVudGlsIHRoZSBsYXN0IGlucHV0LCB3aXRoIGFsbCBpdCdzIG1vdmVtZW50IGluIGl0LiAqXG4gKiBFeGFtcGxlIHNlc3Npb24gZm9yIG1vdXNlLWlucHV0OiBtb3VzZWRvd24gLT4gbW91c2Vtb3ZlIC0+IG1vdXNldXBcbiAqXG4gKiBPbiBlYWNoIHJlY29nbml6aW5nIGN5Y2xlIChzZWUgTWFuYWdlci5yZWNvZ25pemUpIHRoZSAucmVjb2duaXplKCkgbWV0aG9kIGlzIGV4ZWN1dGVkXG4gKiB3aGljaCBkZXRlcm1pbmVzIHdpdGggc3RhdGUgaXQgc2hvdWxkIGJlLlxuICpcbiAqIElmIHRoZSByZWNvZ25pemVyIGhhcyB0aGUgc3RhdGUgRkFJTEVELCBDQU5DRUxMRUQgb3IgUkVDT0dOSVpFRCAoZXF1YWxzIEVOREVEKSwgaXQgaXMgcmVzZXQgdG9cbiAqIFBPU1NJQkxFIHRvIGdpdmUgaXQgYW5vdGhlciBjaGFuZ2Ugb24gdGhlIG5leHQgY3ljbGUuXG4gKlxuICogICAgICAgICAgICAgICBQb3NzaWJsZVxuICogICAgICAgICAgICAgICAgICB8XG4gKiAgICAgICAgICAgICstLS0tLSstLS0tLS0tLS0tLS0tLS0rXG4gKiAgICAgICAgICAgIHwgICAgICAgICAgICAgICAgICAgICB8XG4gKiAgICAgICstLS0tLSstLS0tLSsgICAgICAgICAgICAgICB8XG4gKiAgICAgIHwgICAgICAgICAgIHwgICAgICAgICAgICAgICB8XG4gKiAgIEZhaWxlZCAgICAgIENhbmNlbGxlZCAgICAgICAgICB8XG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgKy0tLS0tLS0rLS0tLS0tK1xuICogICAgICAgICAgICAgICAgICAgICAgICAgIHwgICAgICAgICAgICAgIHxcbiAqICAgICAgICAgICAgICAgICAgICAgIFJlY29nbml6ZWQgICAgICAgQmVnYW5cbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8XG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgQ2hhbmdlZFxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHxcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIEVuZGVkL1JlY29nbml6ZWRcbiAqL1xudmFyIFNUQVRFX1BPU1NJQkxFID0gMTtcbnZhciBTVEFURV9CRUdBTiA9IDI7XG52YXIgU1RBVEVfQ0hBTkdFRCA9IDQ7XG52YXIgU1RBVEVfRU5ERUQgPSA4O1xudmFyIFNUQVRFX1JFQ09HTklaRUQgPSBTVEFURV9FTkRFRDtcbnZhciBTVEFURV9DQU5DRUxMRUQgPSAxNjtcbnZhciBTVEFURV9GQUlMRUQgPSAzMjtcblxuLyoqXG4gKiBSZWNvZ25pemVyXG4gKiBFdmVyeSByZWNvZ25pemVyIG5lZWRzIHRvIGV4dGVuZCBmcm9tIHRoaXMgY2xhc3MuXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gKi9cbmZ1bmN0aW9uIFJlY29nbml6ZXIob3B0aW9ucykge1xuICAgIHRoaXMub3B0aW9ucyA9IGFzc2lnbih7fSwgdGhpcy5kZWZhdWx0cywgb3B0aW9ucyB8fCB7fSk7XG5cbiAgICB0aGlzLmlkID0gdW5pcXVlSWQoKTtcblxuICAgIHRoaXMubWFuYWdlciA9IG51bGw7XG5cbiAgICAvLyBkZWZhdWx0IGlzIGVuYWJsZSB0cnVlXG4gICAgdGhpcy5vcHRpb25zLmVuYWJsZSA9IGlmVW5kZWZpbmVkKHRoaXMub3B0aW9ucy5lbmFibGUsIHRydWUpO1xuXG4gICAgdGhpcy5zdGF0ZSA9IFNUQVRFX1BPU1NJQkxFO1xuXG4gICAgdGhpcy5zaW11bHRhbmVvdXMgPSB7fTtcbiAgICB0aGlzLnJlcXVpcmVGYWlsID0gW107XG59XG5cblJlY29nbml6ZXIucHJvdG90eXBlID0ge1xuICAgIC8qKlxuICAgICAqIEB2aXJ0dWFsXG4gICAgICogQHR5cGUge09iamVjdH1cbiAgICAgKi9cbiAgICBkZWZhdWx0czoge30sXG5cbiAgICAvKipcbiAgICAgKiBzZXQgb3B0aW9uc1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gICAgICogQHJldHVybiB7UmVjb2duaXplcn1cbiAgICAgKi9cbiAgICBzZXQ6IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICAgICAgYXNzaWduKHRoaXMub3B0aW9ucywgb3B0aW9ucyk7XG5cbiAgICAgICAgLy8gYWxzbyB1cGRhdGUgdGhlIHRvdWNoQWN0aW9uLCBpbiBjYXNlIHNvbWV0aGluZyBjaGFuZ2VkIGFib3V0IHRoZSBkaXJlY3Rpb25zL2VuYWJsZWQgc3RhdGVcbiAgICAgICAgdGhpcy5tYW5hZ2VyICYmIHRoaXMubWFuYWdlci50b3VjaEFjdGlvbi51cGRhdGUoKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIHJlY29nbml6ZSBzaW11bHRhbmVvdXMgd2l0aCBhbiBvdGhlciByZWNvZ25pemVyLlxuICAgICAqIEBwYXJhbSB7UmVjb2duaXplcn0gb3RoZXJSZWNvZ25pemVyXG4gICAgICogQHJldHVybnMge1JlY29nbml6ZXJ9IHRoaXNcbiAgICAgKi9cbiAgICByZWNvZ25pemVXaXRoOiBmdW5jdGlvbihvdGhlclJlY29nbml6ZXIpIHtcbiAgICAgICAgaWYgKGludm9rZUFycmF5QXJnKG90aGVyUmVjb2duaXplciwgJ3JlY29nbml6ZVdpdGgnLCB0aGlzKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgc2ltdWx0YW5lb3VzID0gdGhpcy5zaW11bHRhbmVvdXM7XG4gICAgICAgIG90aGVyUmVjb2duaXplciA9IGdldFJlY29nbml6ZXJCeU5hbWVJZk1hbmFnZXIob3RoZXJSZWNvZ25pemVyLCB0aGlzKTtcbiAgICAgICAgaWYgKCFzaW11bHRhbmVvdXNbb3RoZXJSZWNvZ25pemVyLmlkXSkge1xuICAgICAgICAgICAgc2ltdWx0YW5lb3VzW290aGVyUmVjb2duaXplci5pZF0gPSBvdGhlclJlY29nbml6ZXI7XG4gICAgICAgICAgICBvdGhlclJlY29nbml6ZXIucmVjb2duaXplV2l0aCh0aGlzKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogZHJvcCB0aGUgc2ltdWx0YW5lb3VzIGxpbmsuIGl0IGRvZXNudCByZW1vdmUgdGhlIGxpbmsgb24gdGhlIG90aGVyIHJlY29nbml6ZXIuXG4gICAgICogQHBhcmFtIHtSZWNvZ25pemVyfSBvdGhlclJlY29nbml6ZXJcbiAgICAgKiBAcmV0dXJucyB7UmVjb2duaXplcn0gdGhpc1xuICAgICAqL1xuICAgIGRyb3BSZWNvZ25pemVXaXRoOiBmdW5jdGlvbihvdGhlclJlY29nbml6ZXIpIHtcbiAgICAgICAgaWYgKGludm9rZUFycmF5QXJnKG90aGVyUmVjb2duaXplciwgJ2Ryb3BSZWNvZ25pemVXaXRoJywgdGhpcykpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG5cbiAgICAgICAgb3RoZXJSZWNvZ25pemVyID0gZ2V0UmVjb2duaXplckJ5TmFtZUlmTWFuYWdlcihvdGhlclJlY29nbml6ZXIsIHRoaXMpO1xuICAgICAgICBkZWxldGUgdGhpcy5zaW11bHRhbmVvdXNbb3RoZXJSZWNvZ25pemVyLmlkXTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIHJlY29nbml6ZXIgY2FuIG9ubHkgcnVuIHdoZW4gYW4gb3RoZXIgaXMgZmFpbGluZ1xuICAgICAqIEBwYXJhbSB7UmVjb2duaXplcn0gb3RoZXJSZWNvZ25pemVyXG4gICAgICogQHJldHVybnMge1JlY29nbml6ZXJ9IHRoaXNcbiAgICAgKi9cbiAgICByZXF1aXJlRmFpbHVyZTogZnVuY3Rpb24ob3RoZXJSZWNvZ25pemVyKSB7XG4gICAgICAgIGlmIChpbnZva2VBcnJheUFyZyhvdGhlclJlY29nbml6ZXIsICdyZXF1aXJlRmFpbHVyZScsIHRoaXMpKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciByZXF1aXJlRmFpbCA9IHRoaXMucmVxdWlyZUZhaWw7XG4gICAgICAgIG90aGVyUmVjb2duaXplciA9IGdldFJlY29nbml6ZXJCeU5hbWVJZk1hbmFnZXIob3RoZXJSZWNvZ25pemVyLCB0aGlzKTtcbiAgICAgICAgaWYgKGluQXJyYXkocmVxdWlyZUZhaWwsIG90aGVyUmVjb2duaXplcikgPT09IC0xKSB7XG4gICAgICAgICAgICByZXF1aXJlRmFpbC5wdXNoKG90aGVyUmVjb2duaXplcik7XG4gICAgICAgICAgICBvdGhlclJlY29nbml6ZXIucmVxdWlyZUZhaWx1cmUodGhpcyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIGRyb3AgdGhlIHJlcXVpcmVGYWlsdXJlIGxpbmsuIGl0IGRvZXMgbm90IHJlbW92ZSB0aGUgbGluayBvbiB0aGUgb3RoZXIgcmVjb2duaXplci5cbiAgICAgKiBAcGFyYW0ge1JlY29nbml6ZXJ9IG90aGVyUmVjb2duaXplclxuICAgICAqIEByZXR1cm5zIHtSZWNvZ25pemVyfSB0aGlzXG4gICAgICovXG4gICAgZHJvcFJlcXVpcmVGYWlsdXJlOiBmdW5jdGlvbihvdGhlclJlY29nbml6ZXIpIHtcbiAgICAgICAgaWYgKGludm9rZUFycmF5QXJnKG90aGVyUmVjb2duaXplciwgJ2Ryb3BSZXF1aXJlRmFpbHVyZScsIHRoaXMpKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuXG4gICAgICAgIG90aGVyUmVjb2duaXplciA9IGdldFJlY29nbml6ZXJCeU5hbWVJZk1hbmFnZXIob3RoZXJSZWNvZ25pemVyLCB0aGlzKTtcbiAgICAgICAgdmFyIGluZGV4ID0gaW5BcnJheSh0aGlzLnJlcXVpcmVGYWlsLCBvdGhlclJlY29nbml6ZXIpO1xuICAgICAgICBpZiAoaW5kZXggPiAtMSkge1xuICAgICAgICAgICAgdGhpcy5yZXF1aXJlRmFpbC5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBoYXMgcmVxdWlyZSBmYWlsdXJlcyBib29sZWFuXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAgICovXG4gICAgaGFzUmVxdWlyZUZhaWx1cmVzOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucmVxdWlyZUZhaWwubGVuZ3RoID4gMDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogaWYgdGhlIHJlY29nbml6ZXIgY2FuIHJlY29nbml6ZSBzaW11bHRhbmVvdXMgd2l0aCBhbiBvdGhlciByZWNvZ25pemVyXG4gICAgICogQHBhcmFtIHtSZWNvZ25pemVyfSBvdGhlclJlY29nbml6ZXJcbiAgICAgKiBAcmV0dXJucyB7Qm9vbGVhbn1cbiAgICAgKi9cbiAgICBjYW5SZWNvZ25pemVXaXRoOiBmdW5jdGlvbihvdGhlclJlY29nbml6ZXIpIHtcbiAgICAgICAgcmV0dXJuICEhdGhpcy5zaW11bHRhbmVvdXNbb3RoZXJSZWNvZ25pemVyLmlkXTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogWW91IHNob3VsZCB1c2UgYHRyeUVtaXRgIGluc3RlYWQgb2YgYGVtaXRgIGRpcmVjdGx5IHRvIGNoZWNrXG4gICAgICogdGhhdCBhbGwgdGhlIG5lZWRlZCByZWNvZ25pemVycyBoYXMgZmFpbGVkIGJlZm9yZSBlbWl0dGluZy5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gaW5wdXRcbiAgICAgKi9cbiAgICBlbWl0OiBmdW5jdGlvbihpbnB1dCkge1xuICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgIHZhciBzdGF0ZSA9IHRoaXMuc3RhdGU7XG5cbiAgICAgICAgZnVuY3Rpb24gZW1pdChldmVudCkge1xuICAgICAgICAgICAgc2VsZi5tYW5hZ2VyLmVtaXQoZXZlbnQsIGlucHV0KTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vICdwYW5zdGFydCcgYW5kICdwYW5tb3ZlJ1xuICAgICAgICBpZiAoc3RhdGUgPCBTVEFURV9FTkRFRCkge1xuICAgICAgICAgICAgZW1pdChzZWxmLm9wdGlvbnMuZXZlbnQgKyBzdGF0ZVN0cihzdGF0ZSkpO1xuICAgICAgICB9XG5cbiAgICAgICAgZW1pdChzZWxmLm9wdGlvbnMuZXZlbnQpOyAvLyBzaW1wbGUgJ2V2ZW50TmFtZScgZXZlbnRzXG5cbiAgICAgICAgaWYgKGlucHV0LmFkZGl0aW9uYWxFdmVudCkgeyAvLyBhZGRpdGlvbmFsIGV2ZW50KHBhbmxlZnQsIHBhbnJpZ2h0LCBwaW5jaGluLCBwaW5jaG91dC4uLilcbiAgICAgICAgICAgIGVtaXQoaW5wdXQuYWRkaXRpb25hbEV2ZW50KTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHBhbmVuZCBhbmQgcGFuY2FuY2VsXG4gICAgICAgIGlmIChzdGF0ZSA+PSBTVEFURV9FTkRFRCkge1xuICAgICAgICAgICAgZW1pdChzZWxmLm9wdGlvbnMuZXZlbnQgKyBzdGF0ZVN0cihzdGF0ZSkpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENoZWNrIHRoYXQgYWxsIHRoZSByZXF1aXJlIGZhaWx1cmUgcmVjb2duaXplcnMgaGFzIGZhaWxlZCxcbiAgICAgKiBpZiB0cnVlLCBpdCBlbWl0cyBhIGdlc3R1cmUgZXZlbnQsXG4gICAgICogb3RoZXJ3aXNlLCBzZXR1cCB0aGUgc3RhdGUgdG8gRkFJTEVELlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBpbnB1dFxuICAgICAqL1xuICAgIHRyeUVtaXQ6IGZ1bmN0aW9uKGlucHV0KSB7XG4gICAgICAgIGlmICh0aGlzLmNhbkVtaXQoKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZW1pdChpbnB1dCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gaXQncyBmYWlsaW5nIGFueXdheVxuICAgICAgICB0aGlzLnN0YXRlID0gU1RBVEVfRkFJTEVEO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBjYW4gd2UgZW1pdD9cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICBjYW5FbWl0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGkgPSAwO1xuICAgICAgICB3aGlsZSAoaSA8IHRoaXMucmVxdWlyZUZhaWwubGVuZ3RoKSB7XG4gICAgICAgICAgICBpZiAoISh0aGlzLnJlcXVpcmVGYWlsW2ldLnN0YXRlICYgKFNUQVRFX0ZBSUxFRCB8IFNUQVRFX1BPU1NJQkxFKSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpKys7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIHVwZGF0ZSB0aGUgcmVjb2duaXplclxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBpbnB1dERhdGFcbiAgICAgKi9cbiAgICByZWNvZ25pemU6IGZ1bmN0aW9uKGlucHV0RGF0YSkge1xuICAgICAgICAvLyBtYWtlIGEgbmV3IGNvcHkgb2YgdGhlIGlucHV0RGF0YVxuICAgICAgICAvLyBzbyB3ZSBjYW4gY2hhbmdlIHRoZSBpbnB1dERhdGEgd2l0aG91dCBtZXNzaW5nIHVwIHRoZSBvdGhlciByZWNvZ25pemVyc1xuICAgICAgICB2YXIgaW5wdXREYXRhQ2xvbmUgPSBhc3NpZ24oe30sIGlucHV0RGF0YSk7XG5cbiAgICAgICAgLy8gaXMgaXMgZW5hYmxlZCBhbmQgYWxsb3cgcmVjb2duaXppbmc/XG4gICAgICAgIGlmICghYm9vbE9yRm4odGhpcy5vcHRpb25zLmVuYWJsZSwgW3RoaXMsIGlucHV0RGF0YUNsb25lXSkpIHtcbiAgICAgICAgICAgIHRoaXMucmVzZXQoKTtcbiAgICAgICAgICAgIHRoaXMuc3RhdGUgPSBTVEFURV9GQUlMRUQ7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICAvLyByZXNldCB3aGVuIHdlJ3ZlIHJlYWNoZWQgdGhlIGVuZFxuICAgICAgICBpZiAodGhpcy5zdGF0ZSAmIChTVEFURV9SRUNPR05JWkVEIHwgU1RBVEVfQ0FOQ0VMTEVEIHwgU1RBVEVfRkFJTEVEKSkge1xuICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IFNUQVRFX1BPU1NJQkxFO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5zdGF0ZSA9IHRoaXMucHJvY2VzcyhpbnB1dERhdGFDbG9uZSk7XG5cbiAgICAgICAgLy8gdGhlIHJlY29nbml6ZXIgaGFzIHJlY29nbml6ZWQgYSBnZXN0dXJlXG4gICAgICAgIC8vIHNvIHRyaWdnZXIgYW4gZXZlbnRcbiAgICAgICAgaWYgKHRoaXMuc3RhdGUgJiAoU1RBVEVfQkVHQU4gfCBTVEFURV9DSEFOR0VEIHwgU1RBVEVfRU5ERUQgfCBTVEFURV9DQU5DRUxMRUQpKSB7XG4gICAgICAgICAgICB0aGlzLnRyeUVtaXQoaW5wdXREYXRhQ2xvbmUpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIHJldHVybiB0aGUgc3RhdGUgb2YgdGhlIHJlY29nbml6ZXJcbiAgICAgKiB0aGUgYWN0dWFsIHJlY29nbml6aW5nIGhhcHBlbnMgaW4gdGhpcyBtZXRob2RcbiAgICAgKiBAdmlydHVhbFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBpbnB1dERhdGFcbiAgICAgKiBAcmV0dXJucyB7Q29uc3R9IFNUQVRFXG4gICAgICovXG4gICAgcHJvY2VzczogZnVuY3Rpb24oaW5wdXREYXRhKSB7IH0sIC8vIGpzaGludCBpZ25vcmU6bGluZVxuXG4gICAgLyoqXG4gICAgICogcmV0dXJuIHRoZSBwcmVmZXJyZWQgdG91Y2gtYWN0aW9uXG4gICAgICogQHZpcnR1YWxcbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9XG4gICAgICovXG4gICAgZ2V0VG91Y2hBY3Rpb246IGZ1bmN0aW9uKCkgeyB9LFxuXG4gICAgLyoqXG4gICAgICogY2FsbGVkIHdoZW4gdGhlIGdlc3R1cmUgaXNuJ3QgYWxsb3dlZCB0byByZWNvZ25pemVcbiAgICAgKiBsaWtlIHdoZW4gYW5vdGhlciBpcyBiZWluZyByZWNvZ25pemVkIG9yIGl0IGlzIGRpc2FibGVkXG4gICAgICogQHZpcnR1YWxcbiAgICAgKi9cbiAgICByZXNldDogZnVuY3Rpb24oKSB7IH1cbn07XG5cbi8qKlxuICogZ2V0IGEgdXNhYmxlIHN0cmluZywgdXNlZCBhcyBldmVudCBwb3N0Zml4XG4gKiBAcGFyYW0ge0NvbnN0fSBzdGF0ZVxuICogQHJldHVybnMge1N0cmluZ30gc3RhdGVcbiAqL1xuZnVuY3Rpb24gc3RhdGVTdHIoc3RhdGUpIHtcbiAgICBpZiAoc3RhdGUgJiBTVEFURV9DQU5DRUxMRUQpIHtcbiAgICAgICAgcmV0dXJuICdjYW5jZWwnO1xuICAgIH0gZWxzZSBpZiAoc3RhdGUgJiBTVEFURV9FTkRFRCkge1xuICAgICAgICByZXR1cm4gJ2VuZCc7XG4gICAgfSBlbHNlIGlmIChzdGF0ZSAmIFNUQVRFX0NIQU5HRUQpIHtcbiAgICAgICAgcmV0dXJuICdtb3ZlJztcbiAgICB9IGVsc2UgaWYgKHN0YXRlICYgU1RBVEVfQkVHQU4pIHtcbiAgICAgICAgcmV0dXJuICdzdGFydCc7XG4gICAgfVxuICAgIHJldHVybiAnJztcbn1cblxuLyoqXG4gKiBkaXJlY3Rpb24gY29ucyB0byBzdHJpbmdcbiAqIEBwYXJhbSB7Q29uc3R9IGRpcmVjdGlvblxuICogQHJldHVybnMge1N0cmluZ31cbiAqL1xuZnVuY3Rpb24gZGlyZWN0aW9uU3RyKGRpcmVjdGlvbikge1xuICAgIGlmIChkaXJlY3Rpb24gPT0gRElSRUNUSU9OX0RPV04pIHtcbiAgICAgICAgcmV0dXJuICdkb3duJztcbiAgICB9IGVsc2UgaWYgKGRpcmVjdGlvbiA9PSBESVJFQ1RJT05fVVApIHtcbiAgICAgICAgcmV0dXJuICd1cCc7XG4gICAgfSBlbHNlIGlmIChkaXJlY3Rpb24gPT0gRElSRUNUSU9OX0xFRlQpIHtcbiAgICAgICAgcmV0dXJuICdsZWZ0JztcbiAgICB9IGVsc2UgaWYgKGRpcmVjdGlvbiA9PSBESVJFQ1RJT05fUklHSFQpIHtcbiAgICAgICAgcmV0dXJuICdyaWdodCc7XG4gICAgfVxuICAgIHJldHVybiAnJztcbn1cblxuLyoqXG4gKiBnZXQgYSByZWNvZ25pemVyIGJ5IG5hbWUgaWYgaXQgaXMgYm91bmQgdG8gYSBtYW5hZ2VyXG4gKiBAcGFyYW0ge1JlY29nbml6ZXJ8U3RyaW5nfSBvdGhlclJlY29nbml6ZXJcbiAqIEBwYXJhbSB7UmVjb2duaXplcn0gcmVjb2duaXplclxuICogQHJldHVybnMge1JlY29nbml6ZXJ9XG4gKi9cbmZ1bmN0aW9uIGdldFJlY29nbml6ZXJCeU5hbWVJZk1hbmFnZXIob3RoZXJSZWNvZ25pemVyLCByZWNvZ25pemVyKSB7XG4gICAgdmFyIG1hbmFnZXIgPSByZWNvZ25pemVyLm1hbmFnZXI7XG4gICAgaWYgKG1hbmFnZXIpIHtcbiAgICAgICAgcmV0dXJuIG1hbmFnZXIuZ2V0KG90aGVyUmVjb2duaXplcik7XG4gICAgfVxuICAgIHJldHVybiBvdGhlclJlY29nbml6ZXI7XG59XG5cbi8qKlxuICogVGhpcyByZWNvZ25pemVyIGlzIGp1c3QgdXNlZCBhcyBhIGJhc2UgZm9yIHRoZSBzaW1wbGUgYXR0cmlidXRlIHJlY29nbml6ZXJzLlxuICogQGNvbnN0cnVjdG9yXG4gKiBAZXh0ZW5kcyBSZWNvZ25pemVyXG4gKi9cbmZ1bmN0aW9uIEF0dHJSZWNvZ25pemVyKCkge1xuICAgIFJlY29nbml6ZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn1cblxuaW5oZXJpdChBdHRyUmVjb2duaXplciwgUmVjb2duaXplciwge1xuICAgIC8qKlxuICAgICAqIEBuYW1lc3BhY2VcbiAgICAgKiBAbWVtYmVyb2YgQXR0clJlY29nbml6ZXJcbiAgICAgKi9cbiAgICBkZWZhdWx0czoge1xuICAgICAgICAvKipcbiAgICAgICAgICogQHR5cGUge051bWJlcn1cbiAgICAgICAgICogQGRlZmF1bHQgMVxuICAgICAgICAgKi9cbiAgICAgICAgcG9pbnRlcnM6IDFcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogVXNlZCB0byBjaGVjayBpZiBpdCB0aGUgcmVjb2duaXplciByZWNlaXZlcyB2YWxpZCBpbnB1dCwgbGlrZSBpbnB1dC5kaXN0YW5jZSA+IDEwLlxuICAgICAqIEBtZW1iZXJvZiBBdHRyUmVjb2duaXplclxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBpbnB1dFxuICAgICAqIEByZXR1cm5zIHtCb29sZWFufSByZWNvZ25pemVkXG4gICAgICovXG4gICAgYXR0clRlc3Q6IGZ1bmN0aW9uKGlucHV0KSB7XG4gICAgICAgIHZhciBvcHRpb25Qb2ludGVycyA9IHRoaXMub3B0aW9ucy5wb2ludGVycztcbiAgICAgICAgcmV0dXJuIG9wdGlvblBvaW50ZXJzID09PSAwIHx8IGlucHV0LnBvaW50ZXJzLmxlbmd0aCA9PT0gb3B0aW9uUG9pbnRlcnM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFByb2Nlc3MgdGhlIGlucHV0IGFuZCByZXR1cm4gdGhlIHN0YXRlIGZvciB0aGUgcmVjb2duaXplclxuICAgICAqIEBtZW1iZXJvZiBBdHRyUmVjb2duaXplclxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBpbnB1dFxuICAgICAqIEByZXR1cm5zIHsqfSBTdGF0ZVxuICAgICAqL1xuICAgIHByb2Nlc3M6IGZ1bmN0aW9uKGlucHV0KSB7XG4gICAgICAgIHZhciBzdGF0ZSA9IHRoaXMuc3RhdGU7XG4gICAgICAgIHZhciBldmVudFR5cGUgPSBpbnB1dC5ldmVudFR5cGU7XG5cbiAgICAgICAgdmFyIGlzUmVjb2duaXplZCA9IHN0YXRlICYgKFNUQVRFX0JFR0FOIHwgU1RBVEVfQ0hBTkdFRCk7XG4gICAgICAgIHZhciBpc1ZhbGlkID0gdGhpcy5hdHRyVGVzdChpbnB1dCk7XG5cbiAgICAgICAgLy8gb24gY2FuY2VsIGlucHV0IGFuZCB3ZSd2ZSByZWNvZ25pemVkIGJlZm9yZSwgcmV0dXJuIFNUQVRFX0NBTkNFTExFRFxuICAgICAgICBpZiAoaXNSZWNvZ25pemVkICYmIChldmVudFR5cGUgJiBJTlBVVF9DQU5DRUwgfHwgIWlzVmFsaWQpKSB7XG4gICAgICAgICAgICByZXR1cm4gc3RhdGUgfCBTVEFURV9DQU5DRUxMRUQ7XG4gICAgICAgIH0gZWxzZSBpZiAoaXNSZWNvZ25pemVkIHx8IGlzVmFsaWQpIHtcbiAgICAgICAgICAgIGlmIChldmVudFR5cGUgJiBJTlBVVF9FTkQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gc3RhdGUgfCBTVEFURV9FTkRFRDtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoIShzdGF0ZSAmIFNUQVRFX0JFR0FOKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBTVEFURV9CRUdBTjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBzdGF0ZSB8IFNUQVRFX0NIQU5HRUQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFNUQVRFX0ZBSUxFRDtcbiAgICB9XG59KTtcblxuLyoqXG4gKiBQYW5cbiAqIFJlY29nbml6ZWQgd2hlbiB0aGUgcG9pbnRlciBpcyBkb3duIGFuZCBtb3ZlZCBpbiB0aGUgYWxsb3dlZCBkaXJlY3Rpb24uXG4gKiBAY29uc3RydWN0b3JcbiAqIEBleHRlbmRzIEF0dHJSZWNvZ25pemVyXG4gKi9cbmZ1bmN0aW9uIFBhblJlY29nbml6ZXIoKSB7XG4gICAgQXR0clJlY29nbml6ZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblxuICAgIHRoaXMucFggPSBudWxsO1xuICAgIHRoaXMucFkgPSBudWxsO1xufVxuXG5pbmhlcml0KFBhblJlY29nbml6ZXIsIEF0dHJSZWNvZ25pemVyLCB7XG4gICAgLyoqXG4gICAgICogQG5hbWVzcGFjZVxuICAgICAqIEBtZW1iZXJvZiBQYW5SZWNvZ25pemVyXG4gICAgICovXG4gICAgZGVmYXVsdHM6IHtcbiAgICAgICAgZXZlbnQ6ICdwYW4nLFxuICAgICAgICB0aHJlc2hvbGQ6IDEwLFxuICAgICAgICBwb2ludGVyczogMSxcbiAgICAgICAgZGlyZWN0aW9uOiBESVJFQ1RJT05fQUxMXG4gICAgfSxcblxuICAgIGdldFRvdWNoQWN0aW9uOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGRpcmVjdGlvbiA9IHRoaXMub3B0aW9ucy5kaXJlY3Rpb247XG4gICAgICAgIHZhciBhY3Rpb25zID0gW107XG4gICAgICAgIGlmIChkaXJlY3Rpb24gJiBESVJFQ1RJT05fSE9SSVpPTlRBTCkge1xuICAgICAgICAgICAgYWN0aW9ucy5wdXNoKFRPVUNIX0FDVElPTl9QQU5fWSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGRpcmVjdGlvbiAmIERJUkVDVElPTl9WRVJUSUNBTCkge1xuICAgICAgICAgICAgYWN0aW9ucy5wdXNoKFRPVUNIX0FDVElPTl9QQU5fWCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGFjdGlvbnM7XG4gICAgfSxcblxuICAgIGRpcmVjdGlvblRlc3Q6IGZ1bmN0aW9uKGlucHV0KSB7XG4gICAgICAgIHZhciBvcHRpb25zID0gdGhpcy5vcHRpb25zO1xuICAgICAgICB2YXIgaGFzTW92ZWQgPSB0cnVlO1xuICAgICAgICB2YXIgZGlzdGFuY2UgPSBpbnB1dC5kaXN0YW5jZTtcbiAgICAgICAgdmFyIGRpcmVjdGlvbiA9IGlucHV0LmRpcmVjdGlvbjtcbiAgICAgICAgdmFyIHggPSBpbnB1dC5kZWx0YVg7XG4gICAgICAgIHZhciB5ID0gaW5wdXQuZGVsdGFZO1xuXG4gICAgICAgIC8vIGxvY2sgdG8gYXhpcz9cbiAgICAgICAgaWYgKCEoZGlyZWN0aW9uICYgb3B0aW9ucy5kaXJlY3Rpb24pKSB7XG4gICAgICAgICAgICBpZiAob3B0aW9ucy5kaXJlY3Rpb24gJiBESVJFQ1RJT05fSE9SSVpPTlRBTCkge1xuICAgICAgICAgICAgICAgIGRpcmVjdGlvbiA9ICh4ID09PSAwKSA/IERJUkVDVElPTl9OT05FIDogKHggPCAwKSA/IERJUkVDVElPTl9MRUZUIDogRElSRUNUSU9OX1JJR0hUO1xuICAgICAgICAgICAgICAgIGhhc01vdmVkID0geCAhPSB0aGlzLnBYO1xuICAgICAgICAgICAgICAgIGRpc3RhbmNlID0gTWF0aC5hYnMoaW5wdXQuZGVsdGFYKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgZGlyZWN0aW9uID0gKHkgPT09IDApID8gRElSRUNUSU9OX05PTkUgOiAoeSA8IDApID8gRElSRUNUSU9OX1VQIDogRElSRUNUSU9OX0RPV047XG4gICAgICAgICAgICAgICAgaGFzTW92ZWQgPSB5ICE9IHRoaXMucFk7XG4gICAgICAgICAgICAgICAgZGlzdGFuY2UgPSBNYXRoLmFicyhpbnB1dC5kZWx0YVkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlucHV0LmRpcmVjdGlvbiA9IGRpcmVjdGlvbjtcbiAgICAgICAgcmV0dXJuIGhhc01vdmVkICYmIGRpc3RhbmNlID4gb3B0aW9ucy50aHJlc2hvbGQgJiYgZGlyZWN0aW9uICYgb3B0aW9ucy5kaXJlY3Rpb247XG4gICAgfSxcblxuICAgIGF0dHJUZXN0OiBmdW5jdGlvbihpbnB1dCkge1xuICAgICAgICByZXR1cm4gQXR0clJlY29nbml6ZXIucHJvdG90eXBlLmF0dHJUZXN0LmNhbGwodGhpcywgaW5wdXQpICYmXG4gICAgICAgICAgICAodGhpcy5zdGF0ZSAmIFNUQVRFX0JFR0FOIHx8ICghKHRoaXMuc3RhdGUgJiBTVEFURV9CRUdBTikgJiYgdGhpcy5kaXJlY3Rpb25UZXN0KGlucHV0KSkpO1xuICAgIH0sXG5cbiAgICBlbWl0OiBmdW5jdGlvbihpbnB1dCkge1xuXG4gICAgICAgIHRoaXMucFggPSBpbnB1dC5kZWx0YVg7XG4gICAgICAgIHRoaXMucFkgPSBpbnB1dC5kZWx0YVk7XG5cbiAgICAgICAgdmFyIGRpcmVjdGlvbiA9IGRpcmVjdGlvblN0cihpbnB1dC5kaXJlY3Rpb24pO1xuXG4gICAgICAgIGlmIChkaXJlY3Rpb24pIHtcbiAgICAgICAgICAgIGlucHV0LmFkZGl0aW9uYWxFdmVudCA9IHRoaXMub3B0aW9ucy5ldmVudCArIGRpcmVjdGlvbjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9zdXBlci5lbWl0LmNhbGwodGhpcywgaW5wdXQpO1xuICAgIH1cbn0pO1xuXG4vKipcbiAqIFBpbmNoXG4gKiBSZWNvZ25pemVkIHdoZW4gdHdvIG9yIG1vcmUgcG9pbnRlcnMgYXJlIG1vdmluZyB0b3dhcmQgKHpvb20taW4pIG9yIGF3YXkgZnJvbSBlYWNoIG90aGVyICh6b29tLW91dCkuXG4gKiBAY29uc3RydWN0b3JcbiAqIEBleHRlbmRzIEF0dHJSZWNvZ25pemVyXG4gKi9cbmZ1bmN0aW9uIFBpbmNoUmVjb2duaXplcigpIHtcbiAgICBBdHRyUmVjb2duaXplci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufVxuXG5pbmhlcml0KFBpbmNoUmVjb2duaXplciwgQXR0clJlY29nbml6ZXIsIHtcbiAgICAvKipcbiAgICAgKiBAbmFtZXNwYWNlXG4gICAgICogQG1lbWJlcm9mIFBpbmNoUmVjb2duaXplclxuICAgICAqL1xuICAgIGRlZmF1bHRzOiB7XG4gICAgICAgIGV2ZW50OiAncGluY2gnLFxuICAgICAgICB0aHJlc2hvbGQ6IDAsXG4gICAgICAgIHBvaW50ZXJzOiAyXG4gICAgfSxcblxuICAgIGdldFRvdWNoQWN0aW9uOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIFtUT1VDSF9BQ1RJT05fTk9ORV07XG4gICAgfSxcblxuICAgIGF0dHJUZXN0OiBmdW5jdGlvbihpbnB1dCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fc3VwZXIuYXR0clRlc3QuY2FsbCh0aGlzLCBpbnB1dCkgJiZcbiAgICAgICAgICAgIChNYXRoLmFicyhpbnB1dC5zY2FsZSAtIDEpID4gdGhpcy5vcHRpb25zLnRocmVzaG9sZCB8fCB0aGlzLnN0YXRlICYgU1RBVEVfQkVHQU4pO1xuICAgIH0sXG5cbiAgICBlbWl0OiBmdW5jdGlvbihpbnB1dCkge1xuICAgICAgICBpZiAoaW5wdXQuc2NhbGUgIT09IDEpIHtcbiAgICAgICAgICAgIHZhciBpbk91dCA9IGlucHV0LnNjYWxlIDwgMSA/ICdpbicgOiAnb3V0JztcbiAgICAgICAgICAgIGlucHV0LmFkZGl0aW9uYWxFdmVudCA9IHRoaXMub3B0aW9ucy5ldmVudCArIGluT3V0O1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3N1cGVyLmVtaXQuY2FsbCh0aGlzLCBpbnB1dCk7XG4gICAgfVxufSk7XG5cbi8qKlxuICogUHJlc3NcbiAqIFJlY29nbml6ZWQgd2hlbiB0aGUgcG9pbnRlciBpcyBkb3duIGZvciB4IG1zIHdpdGhvdXQgYW55IG1vdmVtZW50LlxuICogQGNvbnN0cnVjdG9yXG4gKiBAZXh0ZW5kcyBSZWNvZ25pemVyXG4gKi9cbmZ1bmN0aW9uIFByZXNzUmVjb2duaXplcigpIHtcbiAgICBSZWNvZ25pemVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cbiAgICB0aGlzLl90aW1lciA9IG51bGw7XG4gICAgdGhpcy5faW5wdXQgPSBudWxsO1xufVxuXG5pbmhlcml0KFByZXNzUmVjb2duaXplciwgUmVjb2duaXplciwge1xuICAgIC8qKlxuICAgICAqIEBuYW1lc3BhY2VcbiAgICAgKiBAbWVtYmVyb2YgUHJlc3NSZWNvZ25pemVyXG4gICAgICovXG4gICAgZGVmYXVsdHM6IHtcbiAgICAgICAgZXZlbnQ6ICdwcmVzcycsXG4gICAgICAgIHBvaW50ZXJzOiAxLFxuICAgICAgICB0aW1lOiAyNTEsIC8vIG1pbmltYWwgdGltZSBvZiB0aGUgcG9pbnRlciB0byBiZSBwcmVzc2VkXG4gICAgICAgIHRocmVzaG9sZDogOSAvLyBhIG1pbmltYWwgbW92ZW1lbnQgaXMgb2ssIGJ1dCBrZWVwIGl0IGxvd1xuICAgIH0sXG5cbiAgICBnZXRUb3VjaEFjdGlvbjogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBbVE9VQ0hfQUNUSU9OX0FVVE9dO1xuICAgIH0sXG5cbiAgICBwcm9jZXNzOiBmdW5jdGlvbihpbnB1dCkge1xuICAgICAgICB2YXIgb3B0aW9ucyA9IHRoaXMub3B0aW9ucztcbiAgICAgICAgdmFyIHZhbGlkUG9pbnRlcnMgPSBpbnB1dC5wb2ludGVycy5sZW5ndGggPT09IG9wdGlvbnMucG9pbnRlcnM7XG4gICAgICAgIHZhciB2YWxpZE1vdmVtZW50ID0gaW5wdXQuZGlzdGFuY2UgPCBvcHRpb25zLnRocmVzaG9sZDtcbiAgICAgICAgdmFyIHZhbGlkVGltZSA9IGlucHV0LmRlbHRhVGltZSA+IG9wdGlvbnMudGltZTtcblxuICAgICAgICB0aGlzLl9pbnB1dCA9IGlucHV0O1xuXG4gICAgICAgIC8vIHdlIG9ubHkgYWxsb3cgbGl0dGxlIG1vdmVtZW50XG4gICAgICAgIC8vIGFuZCB3ZSd2ZSByZWFjaGVkIGFuIGVuZCBldmVudCwgc28gYSB0YXAgaXMgcG9zc2libGVcbiAgICAgICAgaWYgKCF2YWxpZE1vdmVtZW50IHx8ICF2YWxpZFBvaW50ZXJzIHx8IChpbnB1dC5ldmVudFR5cGUgJiAoSU5QVVRfRU5EIHwgSU5QVVRfQ0FOQ0VMKSAmJiAhdmFsaWRUaW1lKSkge1xuICAgICAgICAgICAgdGhpcy5yZXNldCgpO1xuICAgICAgICB9IGVsc2UgaWYgKGlucHV0LmV2ZW50VHlwZSAmIElOUFVUX1NUQVJUKSB7XG4gICAgICAgICAgICB0aGlzLnJlc2V0KCk7XG4gICAgICAgICAgICB0aGlzLl90aW1lciA9IHNldFRpbWVvdXRDb250ZXh0KGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHRoaXMuc3RhdGUgPSBTVEFURV9SRUNPR05JWkVEO1xuICAgICAgICAgICAgICAgIHRoaXMudHJ5RW1pdCgpO1xuICAgICAgICAgICAgfSwgb3B0aW9ucy50aW1lLCB0aGlzKTtcbiAgICAgICAgfSBlbHNlIGlmIChpbnB1dC5ldmVudFR5cGUgJiBJTlBVVF9FTkQpIHtcbiAgICAgICAgICAgIHJldHVybiBTVEFURV9SRUNPR05JWkVEO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBTVEFURV9GQUlMRUQ7XG4gICAgfSxcblxuICAgIHJlc2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMuX3RpbWVyKTtcbiAgICB9LFxuXG4gICAgZW1pdDogZnVuY3Rpb24oaW5wdXQpIHtcbiAgICAgICAgaWYgKHRoaXMuc3RhdGUgIT09IFNUQVRFX1JFQ09HTklaRUQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChpbnB1dCAmJiAoaW5wdXQuZXZlbnRUeXBlICYgSU5QVVRfRU5EKSkge1xuICAgICAgICAgICAgdGhpcy5tYW5hZ2VyLmVtaXQodGhpcy5vcHRpb25zLmV2ZW50ICsgJ3VwJywgaW5wdXQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5faW5wdXQudGltZVN0YW1wID0gbm93KCk7XG4gICAgICAgICAgICB0aGlzLm1hbmFnZXIuZW1pdCh0aGlzLm9wdGlvbnMuZXZlbnQsIHRoaXMuX2lucHV0KTtcbiAgICAgICAgfVxuICAgIH1cbn0pO1xuXG4vKipcbiAqIFJvdGF0ZVxuICogUmVjb2duaXplZCB3aGVuIHR3byBvciBtb3JlIHBvaW50ZXIgYXJlIG1vdmluZyBpbiBhIGNpcmN1bGFyIG1vdGlvbi5cbiAqIEBjb25zdHJ1Y3RvclxuICogQGV4dGVuZHMgQXR0clJlY29nbml6ZXJcbiAqL1xuZnVuY3Rpb24gUm90YXRlUmVjb2duaXplcigpIHtcbiAgICBBdHRyUmVjb2duaXplci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufVxuXG5pbmhlcml0KFJvdGF0ZVJlY29nbml6ZXIsIEF0dHJSZWNvZ25pemVyLCB7XG4gICAgLyoqXG4gICAgICogQG5hbWVzcGFjZVxuICAgICAqIEBtZW1iZXJvZiBSb3RhdGVSZWNvZ25pemVyXG4gICAgICovXG4gICAgZGVmYXVsdHM6IHtcbiAgICAgICAgZXZlbnQ6ICdyb3RhdGUnLFxuICAgICAgICB0aHJlc2hvbGQ6IDAsXG4gICAgICAgIHBvaW50ZXJzOiAyXG4gICAgfSxcblxuICAgIGdldFRvdWNoQWN0aW9uOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIFtUT1VDSF9BQ1RJT05fTk9ORV07XG4gICAgfSxcblxuICAgIGF0dHJUZXN0OiBmdW5jdGlvbihpbnB1dCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fc3VwZXIuYXR0clRlc3QuY2FsbCh0aGlzLCBpbnB1dCkgJiZcbiAgICAgICAgICAgIChNYXRoLmFicyhpbnB1dC5yb3RhdGlvbikgPiB0aGlzLm9wdGlvbnMudGhyZXNob2xkIHx8IHRoaXMuc3RhdGUgJiBTVEFURV9CRUdBTik7XG4gICAgfVxufSk7XG5cbi8qKlxuICogU3dpcGVcbiAqIFJlY29nbml6ZWQgd2hlbiB0aGUgcG9pbnRlciBpcyBtb3ZpbmcgZmFzdCAodmVsb2NpdHkpLCB3aXRoIGVub3VnaCBkaXN0YW5jZSBpbiB0aGUgYWxsb3dlZCBkaXJlY3Rpb24uXG4gKiBAY29uc3RydWN0b3JcbiAqIEBleHRlbmRzIEF0dHJSZWNvZ25pemVyXG4gKi9cbmZ1bmN0aW9uIFN3aXBlUmVjb2duaXplcigpIHtcbiAgICBBdHRyUmVjb2duaXplci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufVxuXG5pbmhlcml0KFN3aXBlUmVjb2duaXplciwgQXR0clJlY29nbml6ZXIsIHtcbiAgICAvKipcbiAgICAgKiBAbmFtZXNwYWNlXG4gICAgICogQG1lbWJlcm9mIFN3aXBlUmVjb2duaXplclxuICAgICAqL1xuICAgIGRlZmF1bHRzOiB7XG4gICAgICAgIGV2ZW50OiAnc3dpcGUnLFxuICAgICAgICB0aHJlc2hvbGQ6IDEwLFxuICAgICAgICB2ZWxvY2l0eTogMC4zLFxuICAgICAgICBkaXJlY3Rpb246IERJUkVDVElPTl9IT1JJWk9OVEFMIHwgRElSRUNUSU9OX1ZFUlRJQ0FMLFxuICAgICAgICBwb2ludGVyczogMVxuICAgIH0sXG5cbiAgICBnZXRUb3VjaEFjdGlvbjogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBQYW5SZWNvZ25pemVyLnByb3RvdHlwZS5nZXRUb3VjaEFjdGlvbi5jYWxsKHRoaXMpO1xuICAgIH0sXG5cbiAgICBhdHRyVGVzdDogZnVuY3Rpb24oaW5wdXQpIHtcbiAgICAgICAgdmFyIGRpcmVjdGlvbiA9IHRoaXMub3B0aW9ucy5kaXJlY3Rpb247XG4gICAgICAgIHZhciB2ZWxvY2l0eTtcblxuICAgICAgICBpZiAoZGlyZWN0aW9uICYgKERJUkVDVElPTl9IT1JJWk9OVEFMIHwgRElSRUNUSU9OX1ZFUlRJQ0FMKSkge1xuICAgICAgICAgICAgdmVsb2NpdHkgPSBpbnB1dC5vdmVyYWxsVmVsb2NpdHk7XG4gICAgICAgIH0gZWxzZSBpZiAoZGlyZWN0aW9uICYgRElSRUNUSU9OX0hPUklaT05UQUwpIHtcbiAgICAgICAgICAgIHZlbG9jaXR5ID0gaW5wdXQub3ZlcmFsbFZlbG9jaXR5WDtcbiAgICAgICAgfSBlbHNlIGlmIChkaXJlY3Rpb24gJiBESVJFQ1RJT05fVkVSVElDQUwpIHtcbiAgICAgICAgICAgIHZlbG9jaXR5ID0gaW5wdXQub3ZlcmFsbFZlbG9jaXR5WTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzLl9zdXBlci5hdHRyVGVzdC5jYWxsKHRoaXMsIGlucHV0KSAmJlxuICAgICAgICAgICAgZGlyZWN0aW9uICYgaW5wdXQub2Zmc2V0RGlyZWN0aW9uICYmXG4gICAgICAgICAgICBpbnB1dC5kaXN0YW5jZSA+IHRoaXMub3B0aW9ucy50aHJlc2hvbGQgJiZcbiAgICAgICAgICAgIGlucHV0Lm1heFBvaW50ZXJzID09IHRoaXMub3B0aW9ucy5wb2ludGVycyAmJlxuICAgICAgICAgICAgYWJzKHZlbG9jaXR5KSA+IHRoaXMub3B0aW9ucy52ZWxvY2l0eSAmJiBpbnB1dC5ldmVudFR5cGUgJiBJTlBVVF9FTkQ7XG4gICAgfSxcblxuICAgIGVtaXQ6IGZ1bmN0aW9uKGlucHV0KSB7XG4gICAgICAgIHZhciBkaXJlY3Rpb24gPSBkaXJlY3Rpb25TdHIoaW5wdXQub2Zmc2V0RGlyZWN0aW9uKTtcbiAgICAgICAgaWYgKGRpcmVjdGlvbikge1xuICAgICAgICAgICAgdGhpcy5tYW5hZ2VyLmVtaXQodGhpcy5vcHRpb25zLmV2ZW50ICsgZGlyZWN0aW9uLCBpbnB1dCk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLm1hbmFnZXIuZW1pdCh0aGlzLm9wdGlvbnMuZXZlbnQsIGlucHV0KTtcbiAgICB9XG59KTtcblxuLyoqXG4gKiBBIHRhcCBpcyBlY29nbml6ZWQgd2hlbiB0aGUgcG9pbnRlciBpcyBkb2luZyBhIHNtYWxsIHRhcC9jbGljay4gTXVsdGlwbGUgdGFwcyBhcmUgcmVjb2duaXplZCBpZiB0aGV5IG9jY3VyXG4gKiBiZXR3ZWVuIHRoZSBnaXZlbiBpbnRlcnZhbCBhbmQgcG9zaXRpb24uIFRoZSBkZWxheSBvcHRpb24gY2FuIGJlIHVzZWQgdG8gcmVjb2duaXplIG11bHRpLXRhcHMgd2l0aG91dCBmaXJpbmdcbiAqIGEgc2luZ2xlIHRhcC5cbiAqXG4gKiBUaGUgZXZlbnREYXRhIGZyb20gdGhlIGVtaXR0ZWQgZXZlbnQgY29udGFpbnMgdGhlIHByb3BlcnR5IGB0YXBDb3VudGAsIHdoaWNoIGNvbnRhaW5zIHRoZSBhbW91bnQgb2ZcbiAqIG11bHRpLXRhcHMgYmVpbmcgcmVjb2duaXplZC5cbiAqIEBjb25zdHJ1Y3RvclxuICogQGV4dGVuZHMgUmVjb2duaXplclxuICovXG5mdW5jdGlvbiBUYXBSZWNvZ25pemVyKCkge1xuICAgIFJlY29nbml6ZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblxuICAgIC8vIHByZXZpb3VzIHRpbWUgYW5kIGNlbnRlcixcbiAgICAvLyB1c2VkIGZvciB0YXAgY291bnRpbmdcbiAgICB0aGlzLnBUaW1lID0gZmFsc2U7XG4gICAgdGhpcy5wQ2VudGVyID0gZmFsc2U7XG5cbiAgICB0aGlzLl90aW1lciA9IG51bGw7XG4gICAgdGhpcy5faW5wdXQgPSBudWxsO1xuICAgIHRoaXMuY291bnQgPSAwO1xufVxuXG5pbmhlcml0KFRhcFJlY29nbml6ZXIsIFJlY29nbml6ZXIsIHtcbiAgICAvKipcbiAgICAgKiBAbmFtZXNwYWNlXG4gICAgICogQG1lbWJlcm9mIFBpbmNoUmVjb2duaXplclxuICAgICAqL1xuICAgIGRlZmF1bHRzOiB7XG4gICAgICAgIGV2ZW50OiAndGFwJyxcbiAgICAgICAgcG9pbnRlcnM6IDEsXG4gICAgICAgIHRhcHM6IDEsXG4gICAgICAgIGludGVydmFsOiAzMDAsIC8vIG1heCB0aW1lIGJldHdlZW4gdGhlIG11bHRpLXRhcCB0YXBzXG4gICAgICAgIHRpbWU6IDI1MCwgLy8gbWF4IHRpbWUgb2YgdGhlIHBvaW50ZXIgdG8gYmUgZG93biAobGlrZSBmaW5nZXIgb24gdGhlIHNjcmVlbilcbiAgICAgICAgdGhyZXNob2xkOiA5LCAvLyBhIG1pbmltYWwgbW92ZW1lbnQgaXMgb2ssIGJ1dCBrZWVwIGl0IGxvd1xuICAgICAgICBwb3NUaHJlc2hvbGQ6IDEwIC8vIGEgbXVsdGktdGFwIGNhbiBiZSBhIGJpdCBvZmYgdGhlIGluaXRpYWwgcG9zaXRpb25cbiAgICB9LFxuXG4gICAgZ2V0VG91Y2hBY3Rpb246IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gW1RPVUNIX0FDVElPTl9NQU5JUFVMQVRJT05dO1xuICAgIH0sXG5cbiAgICBwcm9jZXNzOiBmdW5jdGlvbihpbnB1dCkge1xuICAgICAgICB2YXIgb3B0aW9ucyA9IHRoaXMub3B0aW9ucztcblxuICAgICAgICB2YXIgdmFsaWRQb2ludGVycyA9IGlucHV0LnBvaW50ZXJzLmxlbmd0aCA9PT0gb3B0aW9ucy5wb2ludGVycztcbiAgICAgICAgdmFyIHZhbGlkTW92ZW1lbnQgPSBpbnB1dC5kaXN0YW5jZSA8IG9wdGlvbnMudGhyZXNob2xkO1xuICAgICAgICB2YXIgdmFsaWRUb3VjaFRpbWUgPSBpbnB1dC5kZWx0YVRpbWUgPCBvcHRpb25zLnRpbWU7XG5cbiAgICAgICAgdGhpcy5yZXNldCgpO1xuXG4gICAgICAgIGlmICgoaW5wdXQuZXZlbnRUeXBlICYgSU5QVVRfU1RBUlQpICYmICh0aGlzLmNvdW50ID09PSAwKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZmFpbFRpbWVvdXQoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHdlIG9ubHkgYWxsb3cgbGl0dGxlIG1vdmVtZW50XG4gICAgICAgIC8vIGFuZCB3ZSd2ZSByZWFjaGVkIGFuIGVuZCBldmVudCwgc28gYSB0YXAgaXMgcG9zc2libGVcbiAgICAgICAgaWYgKHZhbGlkTW92ZW1lbnQgJiYgdmFsaWRUb3VjaFRpbWUgJiYgdmFsaWRQb2ludGVycykge1xuICAgICAgICAgICAgaWYgKGlucHV0LmV2ZW50VHlwZSAhPSBJTlBVVF9FTkQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5mYWlsVGltZW91dCgpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgdmFsaWRJbnRlcnZhbCA9IHRoaXMucFRpbWUgPyAoaW5wdXQudGltZVN0YW1wIC0gdGhpcy5wVGltZSA8IG9wdGlvbnMuaW50ZXJ2YWwpIDogdHJ1ZTtcbiAgICAgICAgICAgIHZhciB2YWxpZE11bHRpVGFwID0gIXRoaXMucENlbnRlciB8fCBnZXREaXN0YW5jZSh0aGlzLnBDZW50ZXIsIGlucHV0LmNlbnRlcikgPCBvcHRpb25zLnBvc1RocmVzaG9sZDtcblxuICAgICAgICAgICAgdGhpcy5wVGltZSA9IGlucHV0LnRpbWVTdGFtcDtcbiAgICAgICAgICAgIHRoaXMucENlbnRlciA9IGlucHV0LmNlbnRlcjtcblxuICAgICAgICAgICAgaWYgKCF2YWxpZE11bHRpVGFwIHx8ICF2YWxpZEludGVydmFsKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jb3VudCA9IDE7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuY291bnQgKz0gMTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhpcy5faW5wdXQgPSBpbnB1dDtcblxuICAgICAgICAgICAgLy8gaWYgdGFwIGNvdW50IG1hdGNoZXMgd2UgaGF2ZSByZWNvZ25pemVkIGl0LFxuICAgICAgICAgICAgLy8gZWxzZSBpdCBoYXMgYmVnYW4gcmVjb2duaXppbmcuLi5cbiAgICAgICAgICAgIHZhciB0YXBDb3VudCA9IHRoaXMuY291bnQgJSBvcHRpb25zLnRhcHM7XG4gICAgICAgICAgICBpZiAodGFwQ291bnQgPT09IDApIHtcbiAgICAgICAgICAgICAgICAvLyBubyBmYWlsaW5nIHJlcXVpcmVtZW50cywgaW1tZWRpYXRlbHkgdHJpZ2dlciB0aGUgdGFwIGV2ZW50XG4gICAgICAgICAgICAgICAgLy8gb3Igd2FpdCBhcyBsb25nIGFzIHRoZSBtdWx0aXRhcCBpbnRlcnZhbCB0byB0cmlnZ2VyXG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLmhhc1JlcXVpcmVGYWlsdXJlcygpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBTVEFURV9SRUNPR05JWkVEO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3RpbWVyID0gc2V0VGltZW91dENvbnRleHQoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnN0YXRlID0gU1RBVEVfUkVDT0dOSVpFRDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMudHJ5RW1pdCgpO1xuICAgICAgICAgICAgICAgICAgICB9LCBvcHRpb25zLmludGVydmFsLCB0aGlzKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFNUQVRFX0JFR0FOO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gU1RBVEVfRkFJTEVEO1xuICAgIH0sXG5cbiAgICBmYWlsVGltZW91dDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMuX3RpbWVyID0gc2V0VGltZW91dENvbnRleHQoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB0aGlzLnN0YXRlID0gU1RBVEVfRkFJTEVEO1xuICAgICAgICB9LCB0aGlzLm9wdGlvbnMuaW50ZXJ2YWwsIHRoaXMpO1xuICAgICAgICByZXR1cm4gU1RBVEVfRkFJTEVEO1xuICAgIH0sXG5cbiAgICByZXNldDogZnVuY3Rpb24oKSB7XG4gICAgICAgIGNsZWFyVGltZW91dCh0aGlzLl90aW1lcik7XG4gICAgfSxcblxuICAgIGVtaXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAodGhpcy5zdGF0ZSA9PSBTVEFURV9SRUNPR05JWkVEKSB7XG4gICAgICAgICAgICB0aGlzLl9pbnB1dC50YXBDb3VudCA9IHRoaXMuY291bnQ7XG4gICAgICAgICAgICB0aGlzLm1hbmFnZXIuZW1pdCh0aGlzLm9wdGlvbnMuZXZlbnQsIHRoaXMuX2lucHV0KTtcbiAgICAgICAgfVxuICAgIH1cbn0pO1xuXG4vKipcbiAqIFNpbXBsZSB3YXkgdG8gY3JlYXRlIGEgbWFuYWdlciB3aXRoIGEgZGVmYXVsdCBzZXQgb2YgcmVjb2duaXplcnMuXG4gKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBlbGVtZW50XG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdXG4gKiBAY29uc3RydWN0b3JcbiAqL1xuZnVuY3Rpb24gSGFtbWVyKGVsZW1lbnQsIG9wdGlvbnMpIHtcbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgICBvcHRpb25zLnJlY29nbml6ZXJzID0gaWZVbmRlZmluZWQob3B0aW9ucy5yZWNvZ25pemVycywgSGFtbWVyLmRlZmF1bHRzLnByZXNldCk7XG4gICAgcmV0dXJuIG5ldyBNYW5hZ2VyKGVsZW1lbnQsIG9wdGlvbnMpO1xufVxuXG4vKipcbiAqIEBjb25zdCB7c3RyaW5nfVxuICovXG5IYW1tZXIuVkVSU0lPTiA9ICcyLjAuNyc7XG5cbi8qKlxuICogZGVmYXVsdCBzZXR0aW5nc1xuICogQG5hbWVzcGFjZVxuICovXG5IYW1tZXIuZGVmYXVsdHMgPSB7XG4gICAgLyoqXG4gICAgICogc2V0IGlmIERPTSBldmVudHMgYXJlIGJlaW5nIHRyaWdnZXJlZC5cbiAgICAgKiBCdXQgdGhpcyBpcyBzbG93ZXIgYW5kIHVudXNlZCBieSBzaW1wbGUgaW1wbGVtZW50YXRpb25zLCBzbyBkaXNhYmxlZCBieSBkZWZhdWx0LlxuICAgICAqIEB0eXBlIHtCb29sZWFufVxuICAgICAqIEBkZWZhdWx0IGZhbHNlXG4gICAgICovXG4gICAgZG9tRXZlbnRzOiBmYWxzZSxcblxuICAgIC8qKlxuICAgICAqIFRoZSB2YWx1ZSBmb3IgdGhlIHRvdWNoQWN0aW9uIHByb3BlcnR5L2ZhbGxiYWNrLlxuICAgICAqIFdoZW4gc2V0IHRvIGBjb21wdXRlYCBpdCB3aWxsIG1hZ2ljYWxseSBzZXQgdGhlIGNvcnJlY3QgdmFsdWUgYmFzZWQgb24gdGhlIGFkZGVkIHJlY29nbml6ZXJzLlxuICAgICAqIEB0eXBlIHtTdHJpbmd9XG4gICAgICogQGRlZmF1bHQgY29tcHV0ZVxuICAgICAqL1xuICAgIHRvdWNoQWN0aW9uOiBUT1VDSF9BQ1RJT05fQ09NUFVURSxcblxuICAgIC8qKlxuICAgICAqIEB0eXBlIHtCb29sZWFufVxuICAgICAqIEBkZWZhdWx0IHRydWVcbiAgICAgKi9cbiAgICBlbmFibGU6IHRydWUsXG5cbiAgICAvKipcbiAgICAgKiBFWFBFUklNRU5UQUwgRkVBVFVSRSAtLSBjYW4gYmUgcmVtb3ZlZC9jaGFuZ2VkXG4gICAgICogQ2hhbmdlIHRoZSBwYXJlbnQgaW5wdXQgdGFyZ2V0IGVsZW1lbnQuXG4gICAgICogSWYgTnVsbCwgdGhlbiBpdCBpcyBiZWluZyBzZXQgdGhlIHRvIG1haW4gZWxlbWVudC5cbiAgICAgKiBAdHlwZSB7TnVsbHxFdmVudFRhcmdldH1cbiAgICAgKiBAZGVmYXVsdCBudWxsXG4gICAgICovXG4gICAgaW5wdXRUYXJnZXQ6IG51bGwsXG5cbiAgICAvKipcbiAgICAgKiBmb3JjZSBhbiBpbnB1dCBjbGFzc1xuICAgICAqIEB0eXBlIHtOdWxsfEZ1bmN0aW9ufVxuICAgICAqIEBkZWZhdWx0IG51bGxcbiAgICAgKi9cbiAgICBpbnB1dENsYXNzOiBudWxsLFxuXG4gICAgLyoqXG4gICAgICogRGVmYXVsdCByZWNvZ25pemVyIHNldHVwIHdoZW4gY2FsbGluZyBgSGFtbWVyKClgXG4gICAgICogV2hlbiBjcmVhdGluZyBhIG5ldyBNYW5hZ2VyIHRoZXNlIHdpbGwgYmUgc2tpcHBlZC5cbiAgICAgKiBAdHlwZSB7QXJyYXl9XG4gICAgICovXG4gICAgcHJlc2V0OiBbXG4gICAgICAgIC8vIFJlY29nbml6ZXJDbGFzcywgb3B0aW9ucywgW3JlY29nbml6ZVdpdGgsIC4uLl0sIFtyZXF1aXJlRmFpbHVyZSwgLi4uXVxuICAgICAgICBbUm90YXRlUmVjb2duaXplciwge2VuYWJsZTogZmFsc2V9XSxcbiAgICAgICAgW1BpbmNoUmVjb2duaXplciwge2VuYWJsZTogZmFsc2V9LCBbJ3JvdGF0ZSddXSxcbiAgICAgICAgW1N3aXBlUmVjb2duaXplciwge2RpcmVjdGlvbjogRElSRUNUSU9OX0hPUklaT05UQUx9XSxcbiAgICAgICAgW1BhblJlY29nbml6ZXIsIHtkaXJlY3Rpb246IERJUkVDVElPTl9IT1JJWk9OVEFMfSwgWydzd2lwZSddXSxcbiAgICAgICAgW1RhcFJlY29nbml6ZXJdLFxuICAgICAgICBbVGFwUmVjb2duaXplciwge2V2ZW50OiAnZG91YmxldGFwJywgdGFwczogMn0sIFsndGFwJ11dLFxuICAgICAgICBbUHJlc3NSZWNvZ25pemVyXVxuICAgIF0sXG5cbiAgICAvKipcbiAgICAgKiBTb21lIENTUyBwcm9wZXJ0aWVzIGNhbiBiZSB1c2VkIHRvIGltcHJvdmUgdGhlIHdvcmtpbmcgb2YgSGFtbWVyLlxuICAgICAqIEFkZCB0aGVtIHRvIHRoaXMgbWV0aG9kIGFuZCB0aGV5IHdpbGwgYmUgc2V0IHdoZW4gY3JlYXRpbmcgYSBuZXcgTWFuYWdlci5cbiAgICAgKiBAbmFtZXNwYWNlXG4gICAgICovXG4gICAgY3NzUHJvcHM6IHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIERpc2FibGVzIHRleHQgc2VsZWN0aW9uIHRvIGltcHJvdmUgdGhlIGRyYWdnaW5nIGdlc3R1cmUuIE1haW5seSBmb3IgZGVza3RvcCBicm93c2Vycy5cbiAgICAgICAgICogQHR5cGUge1N0cmluZ31cbiAgICAgICAgICogQGRlZmF1bHQgJ25vbmUnXG4gICAgICAgICAqL1xuICAgICAgICB1c2VyU2VsZWN0OiAnbm9uZScsXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIERpc2FibGUgdGhlIFdpbmRvd3MgUGhvbmUgZ3JpcHBlcnMgd2hlbiBwcmVzc2luZyBhbiBlbGVtZW50LlxuICAgICAgICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgICAgICAgKiBAZGVmYXVsdCAnbm9uZSdcbiAgICAgICAgICovXG4gICAgICAgIHRvdWNoU2VsZWN0OiAnbm9uZScsXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIERpc2FibGVzIHRoZSBkZWZhdWx0IGNhbGxvdXQgc2hvd24gd2hlbiB5b3UgdG91Y2ggYW5kIGhvbGQgYSB0b3VjaCB0YXJnZXQuXG4gICAgICAgICAqIE9uIGlPUywgd2hlbiB5b3UgdG91Y2ggYW5kIGhvbGQgYSB0b3VjaCB0YXJnZXQgc3VjaCBhcyBhIGxpbmssIFNhZmFyaSBkaXNwbGF5c1xuICAgICAgICAgKiBhIGNhbGxvdXQgY29udGFpbmluZyBpbmZvcm1hdGlvbiBhYm91dCB0aGUgbGluay4gVGhpcyBwcm9wZXJ0eSBhbGxvd3MgeW91IHRvIGRpc2FibGUgdGhhdCBjYWxsb3V0LlxuICAgICAgICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgICAgICAgKiBAZGVmYXVsdCAnbm9uZSdcbiAgICAgICAgICovXG4gICAgICAgIHRvdWNoQ2FsbG91dDogJ25vbmUnLFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTcGVjaWZpZXMgd2hldGhlciB6b29taW5nIGlzIGVuYWJsZWQuIFVzZWQgYnkgSUUxMD5cbiAgICAgICAgICogQHR5cGUge1N0cmluZ31cbiAgICAgICAgICogQGRlZmF1bHQgJ25vbmUnXG4gICAgICAgICAqL1xuICAgICAgICBjb250ZW50Wm9vbWluZzogJ25vbmUnLFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTcGVjaWZpZXMgdGhhdCBhbiBlbnRpcmUgZWxlbWVudCBzaG91bGQgYmUgZHJhZ2dhYmxlIGluc3RlYWQgb2YgaXRzIGNvbnRlbnRzLiBNYWlubHkgZm9yIGRlc2t0b3AgYnJvd3NlcnMuXG4gICAgICAgICAqIEB0eXBlIHtTdHJpbmd9XG4gICAgICAgICAqIEBkZWZhdWx0ICdub25lJ1xuICAgICAgICAgKi9cbiAgICAgICAgdXNlckRyYWc6ICdub25lJyxcblxuICAgICAgICAvKipcbiAgICAgICAgICogT3ZlcnJpZGVzIHRoZSBoaWdobGlnaHQgY29sb3Igc2hvd24gd2hlbiB0aGUgdXNlciB0YXBzIGEgbGluayBvciBhIEphdmFTY3JpcHRcbiAgICAgICAgICogY2xpY2thYmxlIGVsZW1lbnQgaW4gaU9TLiBUaGlzIHByb3BlcnR5IG9iZXlzIHRoZSBhbHBoYSB2YWx1ZSwgaWYgc3BlY2lmaWVkLlxuICAgICAgICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgICAgICAgKiBAZGVmYXVsdCAncmdiYSgwLDAsMCwwKSdcbiAgICAgICAgICovXG4gICAgICAgIHRhcEhpZ2hsaWdodENvbG9yOiAncmdiYSgwLDAsMCwwKSdcbiAgICB9XG59O1xuXG52YXIgU1RPUCA9IDE7XG52YXIgRk9SQ0VEX1NUT1AgPSAyO1xuXG4vKipcbiAqIE1hbmFnZXJcbiAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGVsZW1lbnRcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc11cbiAqIEBjb25zdHJ1Y3RvclxuICovXG5mdW5jdGlvbiBNYW5hZ2VyKGVsZW1lbnQsIG9wdGlvbnMpIHtcbiAgICB0aGlzLm9wdGlvbnMgPSBhc3NpZ24oe30sIEhhbW1lci5kZWZhdWx0cywgb3B0aW9ucyB8fCB7fSk7XG5cbiAgICB0aGlzLm9wdGlvbnMuaW5wdXRUYXJnZXQgPSB0aGlzLm9wdGlvbnMuaW5wdXRUYXJnZXQgfHwgZWxlbWVudDtcblxuICAgIHRoaXMuaGFuZGxlcnMgPSB7fTtcbiAgICB0aGlzLnNlc3Npb24gPSB7fTtcbiAgICB0aGlzLnJlY29nbml6ZXJzID0gW107XG4gICAgdGhpcy5vbGRDc3NQcm9wcyA9IHt9O1xuXG4gICAgdGhpcy5lbGVtZW50ID0gZWxlbWVudDtcbiAgICB0aGlzLmlucHV0ID0gY3JlYXRlSW5wdXRJbnN0YW5jZSh0aGlzKTtcbiAgICB0aGlzLnRvdWNoQWN0aW9uID0gbmV3IFRvdWNoQWN0aW9uKHRoaXMsIHRoaXMub3B0aW9ucy50b3VjaEFjdGlvbik7XG5cbiAgICB0b2dnbGVDc3NQcm9wcyh0aGlzLCB0cnVlKTtcblxuICAgIGVhY2godGhpcy5vcHRpb25zLnJlY29nbml6ZXJzLCBmdW5jdGlvbihpdGVtKSB7XG4gICAgICAgIHZhciByZWNvZ25pemVyID0gdGhpcy5hZGQobmV3IChpdGVtWzBdKShpdGVtWzFdKSk7XG4gICAgICAgIGl0ZW1bMl0gJiYgcmVjb2duaXplci5yZWNvZ25pemVXaXRoKGl0ZW1bMl0pO1xuICAgICAgICBpdGVtWzNdICYmIHJlY29nbml6ZXIucmVxdWlyZUZhaWx1cmUoaXRlbVszXSk7XG4gICAgfSwgdGhpcyk7XG59XG5cbk1hbmFnZXIucHJvdG90eXBlID0ge1xuICAgIC8qKlxuICAgICAqIHNldCBvcHRpb25zXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAgICAgKiBAcmV0dXJucyB7TWFuYWdlcn1cbiAgICAgKi9cbiAgICBzZXQ6IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICAgICAgYXNzaWduKHRoaXMub3B0aW9ucywgb3B0aW9ucyk7XG5cbiAgICAgICAgLy8gT3B0aW9ucyB0aGF0IG5lZWQgYSBsaXR0bGUgbW9yZSBzZXR1cFxuICAgICAgICBpZiAob3B0aW9ucy50b3VjaEFjdGlvbikge1xuICAgICAgICAgICAgdGhpcy50b3VjaEFjdGlvbi51cGRhdGUoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAob3B0aW9ucy5pbnB1dFRhcmdldCkge1xuICAgICAgICAgICAgLy8gQ2xlYW4gdXAgZXhpc3RpbmcgZXZlbnQgbGlzdGVuZXJzIGFuZCByZWluaXRpYWxpemVcbiAgICAgICAgICAgIHRoaXMuaW5wdXQuZGVzdHJveSgpO1xuICAgICAgICAgICAgdGhpcy5pbnB1dC50YXJnZXQgPSBvcHRpb25zLmlucHV0VGFyZ2V0O1xuICAgICAgICAgICAgdGhpcy5pbnB1dC5pbml0KCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIHN0b3AgcmVjb2duaXppbmcgZm9yIHRoaXMgc2Vzc2lvbi5cbiAgICAgKiBUaGlzIHNlc3Npb24gd2lsbCBiZSBkaXNjYXJkZWQsIHdoZW4gYSBuZXcgW2lucHV0XXN0YXJ0IGV2ZW50IGlzIGZpcmVkLlxuICAgICAqIFdoZW4gZm9yY2VkLCB0aGUgcmVjb2duaXplciBjeWNsZSBpcyBzdG9wcGVkIGltbWVkaWF0ZWx5LlxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2ZvcmNlXVxuICAgICAqL1xuICAgIHN0b3A6IGZ1bmN0aW9uKGZvcmNlKSB7XG4gICAgICAgIHRoaXMuc2Vzc2lvbi5zdG9wcGVkID0gZm9yY2UgPyBGT1JDRURfU1RPUCA6IFNUT1A7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIHJ1biB0aGUgcmVjb2duaXplcnMhXG4gICAgICogY2FsbGVkIGJ5IHRoZSBpbnB1dEhhbmRsZXIgZnVuY3Rpb24gb24gZXZlcnkgbW92ZW1lbnQgb2YgdGhlIHBvaW50ZXJzICh0b3VjaGVzKVxuICAgICAqIGl0IHdhbGtzIHRocm91Z2ggYWxsIHRoZSByZWNvZ25pemVycyBhbmQgdHJpZXMgdG8gZGV0ZWN0IHRoZSBnZXN0dXJlIHRoYXQgaXMgYmVpbmcgbWFkZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBpbnB1dERhdGFcbiAgICAgKi9cbiAgICByZWNvZ25pemU6IGZ1bmN0aW9uKGlucHV0RGF0YSkge1xuICAgICAgICB2YXIgc2Vzc2lvbiA9IHRoaXMuc2Vzc2lvbjtcbiAgICAgICAgaWYgKHNlc3Npb24uc3RvcHBlZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gcnVuIHRoZSB0b3VjaC1hY3Rpb24gcG9seWZpbGxcbiAgICAgICAgdGhpcy50b3VjaEFjdGlvbi5wcmV2ZW50RGVmYXVsdHMoaW5wdXREYXRhKTtcblxuICAgICAgICB2YXIgcmVjb2duaXplcjtcbiAgICAgICAgdmFyIHJlY29nbml6ZXJzID0gdGhpcy5yZWNvZ25pemVycztcblxuICAgICAgICAvLyB0aGlzIGhvbGRzIHRoZSByZWNvZ25pemVyIHRoYXQgaXMgYmVpbmcgcmVjb2duaXplZC5cbiAgICAgICAgLy8gc28gdGhlIHJlY29nbml6ZXIncyBzdGF0ZSBuZWVkcyB0byBiZSBCRUdBTiwgQ0hBTkdFRCwgRU5ERUQgb3IgUkVDT0dOSVpFRFxuICAgICAgICAvLyBpZiBubyByZWNvZ25pemVyIGlzIGRldGVjdGluZyBhIHRoaW5nLCBpdCBpcyBzZXQgdG8gYG51bGxgXG4gICAgICAgIHZhciBjdXJSZWNvZ25pemVyID0gc2Vzc2lvbi5jdXJSZWNvZ25pemVyO1xuXG4gICAgICAgIC8vIHJlc2V0IHdoZW4gdGhlIGxhc3QgcmVjb2duaXplciBpcyByZWNvZ25pemVkXG4gICAgICAgIC8vIG9yIHdoZW4gd2UncmUgaW4gYSBuZXcgc2Vzc2lvblxuICAgICAgICBpZiAoIWN1clJlY29nbml6ZXIgfHwgKGN1clJlY29nbml6ZXIgJiYgY3VyUmVjb2duaXplci5zdGF0ZSAmIFNUQVRFX1JFQ09HTklaRUQpKSB7XG4gICAgICAgICAgICBjdXJSZWNvZ25pemVyID0gc2Vzc2lvbi5jdXJSZWNvZ25pemVyID0gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBpID0gMDtcbiAgICAgICAgd2hpbGUgKGkgPCByZWNvZ25pemVycy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHJlY29nbml6ZXIgPSByZWNvZ25pemVyc1tpXTtcblxuICAgICAgICAgICAgLy8gZmluZCBvdXQgaWYgd2UgYXJlIGFsbG93ZWQgdHJ5IHRvIHJlY29nbml6ZSB0aGUgaW5wdXQgZm9yIHRoaXMgb25lLlxuICAgICAgICAgICAgLy8gMS4gICBhbGxvdyBpZiB0aGUgc2Vzc2lvbiBpcyBOT1QgZm9yY2VkIHN0b3BwZWQgKHNlZSB0aGUgLnN0b3AoKSBtZXRob2QpXG4gICAgICAgICAgICAvLyAyLiAgIGFsbG93IGlmIHdlIHN0aWxsIGhhdmVuJ3QgcmVjb2duaXplZCBhIGdlc3R1cmUgaW4gdGhpcyBzZXNzaW9uLCBvciB0aGUgdGhpcyByZWNvZ25pemVyIGlzIHRoZSBvbmVcbiAgICAgICAgICAgIC8vICAgICAgdGhhdCBpcyBiZWluZyByZWNvZ25pemVkLlxuICAgICAgICAgICAgLy8gMy4gICBhbGxvdyBpZiB0aGUgcmVjb2duaXplciBpcyBhbGxvd2VkIHRvIHJ1biBzaW11bHRhbmVvdXMgd2l0aCB0aGUgY3VycmVudCByZWNvZ25pemVkIHJlY29nbml6ZXIuXG4gICAgICAgICAgICAvLyAgICAgIHRoaXMgY2FuIGJlIHNldHVwIHdpdGggdGhlIGByZWNvZ25pemVXaXRoKClgIG1ldGhvZCBvbiB0aGUgcmVjb2duaXplci5cbiAgICAgICAgICAgIGlmIChzZXNzaW9uLnN0b3BwZWQgIT09IEZPUkNFRF9TVE9QICYmICggLy8gMVxuICAgICAgICAgICAgICAgICAgICAhY3VyUmVjb2duaXplciB8fCByZWNvZ25pemVyID09IGN1clJlY29nbml6ZXIgfHwgLy8gMlxuICAgICAgICAgICAgICAgICAgICByZWNvZ25pemVyLmNhblJlY29nbml6ZVdpdGgoY3VyUmVjb2duaXplcikpKSB7IC8vIDNcbiAgICAgICAgICAgICAgICByZWNvZ25pemVyLnJlY29nbml6ZShpbnB1dERhdGEpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZWNvZ25pemVyLnJlc2V0KCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIGlmIHRoZSByZWNvZ25pemVyIGhhcyBiZWVuIHJlY29nbml6aW5nIHRoZSBpbnB1dCBhcyBhIHZhbGlkIGdlc3R1cmUsIHdlIHdhbnQgdG8gc3RvcmUgdGhpcyBvbmUgYXMgdGhlXG4gICAgICAgICAgICAvLyBjdXJyZW50IGFjdGl2ZSByZWNvZ25pemVyLiBidXQgb25seSBpZiB3ZSBkb24ndCBhbHJlYWR5IGhhdmUgYW4gYWN0aXZlIHJlY29nbml6ZXJcbiAgICAgICAgICAgIGlmICghY3VyUmVjb2duaXplciAmJiByZWNvZ25pemVyLnN0YXRlICYgKFNUQVRFX0JFR0FOIHwgU1RBVEVfQ0hBTkdFRCB8IFNUQVRFX0VOREVEKSkge1xuICAgICAgICAgICAgICAgIGN1clJlY29nbml6ZXIgPSBzZXNzaW9uLmN1clJlY29nbml6ZXIgPSByZWNvZ25pemVyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaSsrO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIGdldCBhIHJlY29nbml6ZXIgYnkgaXRzIGV2ZW50IG5hbWUuXG4gICAgICogQHBhcmFtIHtSZWNvZ25pemVyfFN0cmluZ30gcmVjb2duaXplclxuICAgICAqIEByZXR1cm5zIHtSZWNvZ25pemVyfE51bGx9XG4gICAgICovXG4gICAgZ2V0OiBmdW5jdGlvbihyZWNvZ25pemVyKSB7XG4gICAgICAgIGlmIChyZWNvZ25pemVyIGluc3RhbmNlb2YgUmVjb2duaXplcikge1xuICAgICAgICAgICAgcmV0dXJuIHJlY29nbml6ZXI7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgcmVjb2duaXplcnMgPSB0aGlzLnJlY29nbml6ZXJzO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHJlY29nbml6ZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAocmVjb2duaXplcnNbaV0ub3B0aW9ucy5ldmVudCA9PSByZWNvZ25pemVyKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlY29nbml6ZXJzW2ldO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBhZGQgYSByZWNvZ25pemVyIHRvIHRoZSBtYW5hZ2VyXG4gICAgICogZXhpc3RpbmcgcmVjb2duaXplcnMgd2l0aCB0aGUgc2FtZSBldmVudCBuYW1lIHdpbGwgYmUgcmVtb3ZlZFxuICAgICAqIEBwYXJhbSB7UmVjb2duaXplcn0gcmVjb2duaXplclxuICAgICAqIEByZXR1cm5zIHtSZWNvZ25pemVyfE1hbmFnZXJ9XG4gICAgICovXG4gICAgYWRkOiBmdW5jdGlvbihyZWNvZ25pemVyKSB7XG4gICAgICAgIGlmIChpbnZva2VBcnJheUFyZyhyZWNvZ25pemVyLCAnYWRkJywgdGhpcykpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gcmVtb3ZlIGV4aXN0aW5nXG4gICAgICAgIHZhciBleGlzdGluZyA9IHRoaXMuZ2V0KHJlY29nbml6ZXIub3B0aW9ucy5ldmVudCk7XG4gICAgICAgIGlmIChleGlzdGluZykge1xuICAgICAgICAgICAgdGhpcy5yZW1vdmUoZXhpc3RpbmcpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5yZWNvZ25pemVycy5wdXNoKHJlY29nbml6ZXIpO1xuICAgICAgICByZWNvZ25pemVyLm1hbmFnZXIgPSB0aGlzO1xuXG4gICAgICAgIHRoaXMudG91Y2hBY3Rpb24udXBkYXRlKCk7XG4gICAgICAgIHJldHVybiByZWNvZ25pemVyO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiByZW1vdmUgYSByZWNvZ25pemVyIGJ5IG5hbWUgb3IgaW5zdGFuY2VcbiAgICAgKiBAcGFyYW0ge1JlY29nbml6ZXJ8U3RyaW5nfSByZWNvZ25pemVyXG4gICAgICogQHJldHVybnMge01hbmFnZXJ9XG4gICAgICovXG4gICAgcmVtb3ZlOiBmdW5jdGlvbihyZWNvZ25pemVyKSB7XG4gICAgICAgIGlmIChpbnZva2VBcnJheUFyZyhyZWNvZ25pemVyLCAncmVtb3ZlJywgdGhpcykpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG5cbiAgICAgICAgcmVjb2duaXplciA9IHRoaXMuZ2V0KHJlY29nbml6ZXIpO1xuXG4gICAgICAgIC8vIGxldCdzIG1ha2Ugc3VyZSB0aGlzIHJlY29nbml6ZXIgZXhpc3RzXG4gICAgICAgIGlmIChyZWNvZ25pemVyKSB7XG4gICAgICAgICAgICB2YXIgcmVjb2duaXplcnMgPSB0aGlzLnJlY29nbml6ZXJzO1xuICAgICAgICAgICAgdmFyIGluZGV4ID0gaW5BcnJheShyZWNvZ25pemVycywgcmVjb2duaXplcik7XG5cbiAgICAgICAgICAgIGlmIChpbmRleCAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICByZWNvZ25pemVycy5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgICAgICAgICAgIHRoaXMudG91Y2hBY3Rpb24udXBkYXRlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogYmluZCBldmVudFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBldmVudHNcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBoYW5kbGVyXG4gICAgICogQHJldHVybnMge0V2ZW50RW1pdHRlcn0gdGhpc1xuICAgICAqL1xuICAgIG9uOiBmdW5jdGlvbihldmVudHMsIGhhbmRsZXIpIHtcbiAgICAgICAgaWYgKGV2ZW50cyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGhhbmRsZXIgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGhhbmRsZXJzID0gdGhpcy5oYW5kbGVycztcbiAgICAgICAgZWFjaChzcGxpdFN0cihldmVudHMpLCBmdW5jdGlvbihldmVudCkge1xuICAgICAgICAgICAgaGFuZGxlcnNbZXZlbnRdID0gaGFuZGxlcnNbZXZlbnRdIHx8IFtdO1xuICAgICAgICAgICAgaGFuZGxlcnNbZXZlbnRdLnB1c2goaGFuZGxlcik7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogdW5iaW5kIGV2ZW50LCBsZWF2ZSBlbWl0IGJsYW5rIHRvIHJlbW92ZSBhbGwgaGFuZGxlcnNcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gZXZlbnRzXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2hhbmRsZXJdXG4gICAgICogQHJldHVybnMge0V2ZW50RW1pdHRlcn0gdGhpc1xuICAgICAqL1xuICAgIG9mZjogZnVuY3Rpb24oZXZlbnRzLCBoYW5kbGVyKSB7XG4gICAgICAgIGlmIChldmVudHMgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGhhbmRsZXJzID0gdGhpcy5oYW5kbGVycztcbiAgICAgICAgZWFjaChzcGxpdFN0cihldmVudHMpLCBmdW5jdGlvbihldmVudCkge1xuICAgICAgICAgICAgaWYgKCFoYW5kbGVyKSB7XG4gICAgICAgICAgICAgICAgZGVsZXRlIGhhbmRsZXJzW2V2ZW50XTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgaGFuZGxlcnNbZXZlbnRdICYmIGhhbmRsZXJzW2V2ZW50XS5zcGxpY2UoaW5BcnJheShoYW5kbGVyc1tldmVudF0sIGhhbmRsZXIpLCAxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBlbWl0IGV2ZW50IHRvIHRoZSBsaXN0ZW5lcnNcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gZXZlbnRcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YVxuICAgICAqL1xuICAgIGVtaXQ6IGZ1bmN0aW9uKGV2ZW50LCBkYXRhKSB7XG4gICAgICAgIC8vIHdlIGFsc28gd2FudCB0byB0cmlnZ2VyIGRvbSBldmVudHNcbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5kb21FdmVudHMpIHtcbiAgICAgICAgICAgIHRyaWdnZXJEb21FdmVudChldmVudCwgZGF0YSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBubyBoYW5kbGVycywgc28gc2tpcCBpdCBhbGxcbiAgICAgICAgdmFyIGhhbmRsZXJzID0gdGhpcy5oYW5kbGVyc1tldmVudF0gJiYgdGhpcy5oYW5kbGVyc1tldmVudF0uc2xpY2UoKTtcbiAgICAgICAgaWYgKCFoYW5kbGVycyB8fCAhaGFuZGxlcnMubGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBkYXRhLnR5cGUgPSBldmVudDtcbiAgICAgICAgZGF0YS5wcmV2ZW50RGVmYXVsdCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgZGF0YS5zcmNFdmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICB9O1xuXG4gICAgICAgIHZhciBpID0gMDtcbiAgICAgICAgd2hpbGUgKGkgPCBoYW5kbGVycy5sZW5ndGgpIHtcbiAgICAgICAgICAgIGhhbmRsZXJzW2ldKGRhdGEpO1xuICAgICAgICAgICAgaSsrO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIGRlc3Ryb3kgdGhlIG1hbmFnZXIgYW5kIHVuYmluZHMgYWxsIGV2ZW50c1xuICAgICAqIGl0IGRvZXNuJ3QgdW5iaW5kIGRvbSBldmVudHMsIHRoYXQgaXMgdGhlIHVzZXIgb3duIHJlc3BvbnNpYmlsaXR5XG4gICAgICovXG4gICAgZGVzdHJveTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMuZWxlbWVudCAmJiB0b2dnbGVDc3NQcm9wcyh0aGlzLCBmYWxzZSk7XG5cbiAgICAgICAgdGhpcy5oYW5kbGVycyA9IHt9O1xuICAgICAgICB0aGlzLnNlc3Npb24gPSB7fTtcbiAgICAgICAgdGhpcy5pbnB1dC5kZXN0cm95KCk7XG4gICAgICAgIHRoaXMuZWxlbWVudCA9IG51bGw7XG4gICAgfVxufTtcblxuLyoqXG4gKiBhZGQvcmVtb3ZlIHRoZSBjc3MgcHJvcGVydGllcyBhcyBkZWZpbmVkIGluIG1hbmFnZXIub3B0aW9ucy5jc3NQcm9wc1xuICogQHBhcmFtIHtNYW5hZ2VyfSBtYW5hZ2VyXG4gKiBAcGFyYW0ge0Jvb2xlYW59IGFkZFxuICovXG5mdW5jdGlvbiB0b2dnbGVDc3NQcm9wcyhtYW5hZ2VyLCBhZGQpIHtcbiAgICB2YXIgZWxlbWVudCA9IG1hbmFnZXIuZWxlbWVudDtcbiAgICBpZiAoIWVsZW1lbnQuc3R5bGUpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIgcHJvcDtcbiAgICBlYWNoKG1hbmFnZXIub3B0aW9ucy5jc3NQcm9wcywgZnVuY3Rpb24odmFsdWUsIG5hbWUpIHtcbiAgICAgICAgcHJvcCA9IHByZWZpeGVkKGVsZW1lbnQuc3R5bGUsIG5hbWUpO1xuICAgICAgICBpZiAoYWRkKSB7XG4gICAgICAgICAgICBtYW5hZ2VyLm9sZENzc1Byb3BzW3Byb3BdID0gZWxlbWVudC5zdHlsZVtwcm9wXTtcbiAgICAgICAgICAgIGVsZW1lbnQuc3R5bGVbcHJvcF0gPSB2YWx1ZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGVsZW1lbnQuc3R5bGVbcHJvcF0gPSBtYW5hZ2VyLm9sZENzc1Byb3BzW3Byb3BdIHx8ICcnO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgaWYgKCFhZGQpIHtcbiAgICAgICAgbWFuYWdlci5vbGRDc3NQcm9wcyA9IHt9O1xuICAgIH1cbn1cblxuLyoqXG4gKiB0cmlnZ2VyIGRvbSBldmVudFxuICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50XG4gKiBAcGFyYW0ge09iamVjdH0gZGF0YVxuICovXG5mdW5jdGlvbiB0cmlnZ2VyRG9tRXZlbnQoZXZlbnQsIGRhdGEpIHtcbiAgICB2YXIgZ2VzdHVyZUV2ZW50ID0gZG9jdW1lbnQuY3JlYXRlRXZlbnQoJ0V2ZW50Jyk7XG4gICAgZ2VzdHVyZUV2ZW50LmluaXRFdmVudChldmVudCwgdHJ1ZSwgdHJ1ZSk7XG4gICAgZ2VzdHVyZUV2ZW50Lmdlc3R1cmUgPSBkYXRhO1xuICAgIGRhdGEudGFyZ2V0LmRpc3BhdGNoRXZlbnQoZ2VzdHVyZUV2ZW50KTtcbn1cblxuYXNzaWduKEhhbW1lciwge1xuICAgIElOUFVUX1NUQVJUOiBJTlBVVF9TVEFSVCxcbiAgICBJTlBVVF9NT1ZFOiBJTlBVVF9NT1ZFLFxuICAgIElOUFVUX0VORDogSU5QVVRfRU5ELFxuICAgIElOUFVUX0NBTkNFTDogSU5QVVRfQ0FOQ0VMLFxuXG4gICAgU1RBVEVfUE9TU0lCTEU6IFNUQVRFX1BPU1NJQkxFLFxuICAgIFNUQVRFX0JFR0FOOiBTVEFURV9CRUdBTixcbiAgICBTVEFURV9DSEFOR0VEOiBTVEFURV9DSEFOR0VELFxuICAgIFNUQVRFX0VOREVEOiBTVEFURV9FTkRFRCxcbiAgICBTVEFURV9SRUNPR05JWkVEOiBTVEFURV9SRUNPR05JWkVELFxuICAgIFNUQVRFX0NBTkNFTExFRDogU1RBVEVfQ0FOQ0VMTEVELFxuICAgIFNUQVRFX0ZBSUxFRDogU1RBVEVfRkFJTEVELFxuXG4gICAgRElSRUNUSU9OX05PTkU6IERJUkVDVElPTl9OT05FLFxuICAgIERJUkVDVElPTl9MRUZUOiBESVJFQ1RJT05fTEVGVCxcbiAgICBESVJFQ1RJT05fUklHSFQ6IERJUkVDVElPTl9SSUdIVCxcbiAgICBESVJFQ1RJT05fVVA6IERJUkVDVElPTl9VUCxcbiAgICBESVJFQ1RJT05fRE9XTjogRElSRUNUSU9OX0RPV04sXG4gICAgRElSRUNUSU9OX0hPUklaT05UQUw6IERJUkVDVElPTl9IT1JJWk9OVEFMLFxuICAgIERJUkVDVElPTl9WRVJUSUNBTDogRElSRUNUSU9OX1ZFUlRJQ0FMLFxuICAgIERJUkVDVElPTl9BTEw6IERJUkVDVElPTl9BTEwsXG5cbiAgICBNYW5hZ2VyOiBNYW5hZ2VyLFxuICAgIElucHV0OiBJbnB1dCxcbiAgICBUb3VjaEFjdGlvbjogVG91Y2hBY3Rpb24sXG5cbiAgICBUb3VjaElucHV0OiBUb3VjaElucHV0LFxuICAgIE1vdXNlSW5wdXQ6IE1vdXNlSW5wdXQsXG4gICAgUG9pbnRlckV2ZW50SW5wdXQ6IFBvaW50ZXJFdmVudElucHV0LFxuICAgIFRvdWNoTW91c2VJbnB1dDogVG91Y2hNb3VzZUlucHV0LFxuICAgIFNpbmdsZVRvdWNoSW5wdXQ6IFNpbmdsZVRvdWNoSW5wdXQsXG5cbiAgICBSZWNvZ25pemVyOiBSZWNvZ25pemVyLFxuICAgIEF0dHJSZWNvZ25pemVyOiBBdHRyUmVjb2duaXplcixcbiAgICBUYXA6IFRhcFJlY29nbml6ZXIsXG4gICAgUGFuOiBQYW5SZWNvZ25pemVyLFxuICAgIFN3aXBlOiBTd2lwZVJlY29nbml6ZXIsXG4gICAgUGluY2g6IFBpbmNoUmVjb2duaXplcixcbiAgICBSb3RhdGU6IFJvdGF0ZVJlY29nbml6ZXIsXG4gICAgUHJlc3M6IFByZXNzUmVjb2duaXplcixcblxuICAgIG9uOiBhZGRFdmVudExpc3RlbmVycyxcbiAgICBvZmY6IHJlbW92ZUV2ZW50TGlzdGVuZXJzLFxuICAgIGVhY2g6IGVhY2gsXG4gICAgbWVyZ2U6IG1lcmdlLFxuICAgIGV4dGVuZDogZXh0ZW5kLFxuICAgIGFzc2lnbjogYXNzaWduLFxuICAgIGluaGVyaXQ6IGluaGVyaXQsXG4gICAgYmluZEZuOiBiaW5kRm4sXG4gICAgcHJlZml4ZWQ6IHByZWZpeGVkXG59KTtcblxuLy8gdGhpcyBwcmV2ZW50cyBlcnJvcnMgd2hlbiBIYW1tZXIgaXMgbG9hZGVkIGluIHRoZSBwcmVzZW5jZSBvZiBhbiBBTURcbi8vICBzdHlsZSBsb2FkZXIgYnV0IGJ5IHNjcmlwdCB0YWcsIG5vdCBieSB0aGUgbG9hZGVyLlxudmFyIGZyZWVHbG9iYWwgPSAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgPyB3aW5kb3cgOiAodHlwZW9mIHNlbGYgIT09ICd1bmRlZmluZWQnID8gc2VsZiA6IHt9KSk7IC8vIGpzaGludCBpZ25vcmU6bGluZVxuZnJlZUdsb2JhbC5IYW1tZXIgPSBIYW1tZXI7XG5cbmlmICh0cnVlKSB7XG4gICAgIShfX1dFQlBBQ0tfQU1EX0RFRklORV9SRVNVTFRfXyA9IChmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIEhhbW1lcjtcbiAgICB9KS5jYWxsKGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18sIGV4cG9ydHMsIG1vZHVsZSksXG5cdFx0X19XRUJQQUNLX0FNRF9ERUZJTkVfUkVTVUxUX18gIT09IHVuZGVmaW5lZCAmJiAobW9kdWxlLmV4cG9ydHMgPSBfX1dFQlBBQ0tfQU1EX0RFRklORV9SRVNVTFRfXykpO1xufSBlbHNlIHt9XG5cbn0pKHdpbmRvdywgZG9jdW1lbnQsICdIYW1tZXInKTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gOTgxOlxuLyoqKi8gKChtb2R1bGUpID0+IHtcblxuLypcbiAqIEhhbXN0ZXIuanMgdjEuMS4yXG4gKiAoYykgMjAxMyBNb25vc3BhY2VkIGh0dHA6Ly9tb25vc3BhY2VkLmNvbVxuICogTGljZW5zZTogTUlUXG4gKi9cblxuKGZ1bmN0aW9uKHdpbmRvdywgZG9jdW1lbnQpe1xuJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIEhhbXN0ZXJcbiAqIHVzZSB0aGlzIHRvIGNyZWF0ZSBpbnN0YW5jZXNcbiAqIEByZXR1cm5zIHtIYW1zdGVyLkluc3RhbmNlfVxuICogQGNvbnN0cnVjdG9yXG4gKi9cbnZhciBIYW1zdGVyID0gZnVuY3Rpb24oZWxlbWVudCkge1xuICByZXR1cm4gbmV3IEhhbXN0ZXIuSW5zdGFuY2UoZWxlbWVudCk7XG59O1xuXG4vLyBkZWZhdWx0IGV2ZW50IG5hbWVcbkhhbXN0ZXIuU1VQUE9SVCA9ICd3aGVlbCc7XG5cbi8vIGRlZmF1bHQgRE9NIG1ldGhvZHNcbkhhbXN0ZXIuQUREX0VWRU5UID0gJ2FkZEV2ZW50TGlzdGVuZXInO1xuSGFtc3Rlci5SRU1PVkVfRVZFTlQgPSAncmVtb3ZlRXZlbnRMaXN0ZW5lcic7XG5IYW1zdGVyLlBSRUZJWCA9ICcnO1xuXG4vLyB1bnRpbCBicm93c2VyIGluY29uc2lzdGVuY2llcyBoYXZlIGJlZW4gZml4ZWQuLi5cbkhhbXN0ZXIuUkVBRFkgPSBmYWxzZTtcblxuSGFtc3Rlci5JbnN0YW5jZSA9IGZ1bmN0aW9uKGVsZW1lbnQpe1xuICBpZiAoIUhhbXN0ZXIuUkVBRFkpIHtcbiAgICAvLyBmaXggYnJvd3NlciBpbmNvbnNpc3RlbmNpZXNcbiAgICBIYW1zdGVyLm5vcm1hbGlzZS5icm93c2VyKCk7XG5cbiAgICAvLyBIYW1zdGVyIGlzIHJlYWR5Li4uIVxuICAgIEhhbXN0ZXIuUkVBRFkgPSB0cnVlO1xuICB9XG5cbiAgdGhpcy5lbGVtZW50ID0gZWxlbWVudDtcblxuICAvLyBzdG9yZSBhdHRhY2hlZCBldmVudCBoYW5kbGVyc1xuICB0aGlzLmhhbmRsZXJzID0gW107XG5cbiAgLy8gcmV0dXJuIGluc3RhbmNlXG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBjcmVhdGUgbmV3IGhhbXN0ZXIgaW5zdGFuY2VcbiAqIGFsbCBtZXRob2RzIHNob3VsZCByZXR1cm4gdGhlIGluc3RhbmNlIGl0c2VsZiwgc28gaXQgaXMgY2hhaW5hYmxlLlxuICogQHBhcmFtICAge0hUTUxFbGVtZW50fSAgICAgICBlbGVtZW50XG4gKiBAcmV0dXJucyB7SGFtc3Rlci5JbnN0YW5jZX1cbiAqIEBjb25zdHJ1Y3RvclxuICovXG5IYW1zdGVyLkluc3RhbmNlLnByb3RvdHlwZSA9IHtcbiAgLyoqXG4gICAqIGJpbmQgZXZlbnRzIHRvIHRoZSBpbnN0YW5jZVxuICAgKiBAcGFyYW0gICB7RnVuY3Rpb259ICAgIGhhbmRsZXJcbiAgICogQHBhcmFtICAge0Jvb2xlYW59ICAgICB1c2VDYXB0dXJlXG4gICAqIEByZXR1cm5zIHtIYW1zdGVyLkluc3RhbmNlfVxuICAgKi9cbiAgd2hlZWw6IGZ1bmN0aW9uIG9uRXZlbnQoaGFuZGxlciwgdXNlQ2FwdHVyZSl7XG4gICAgSGFtc3Rlci5ldmVudC5hZGQodGhpcywgSGFtc3Rlci5TVVBQT1JULCBoYW5kbGVyLCB1c2VDYXB0dXJlKTtcblxuICAgIC8vIGhhbmRsZSBNb3pNb3VzZVBpeGVsU2Nyb2xsIGluIG9sZGVyIEZpcmVmb3hcbiAgICBpZiAoSGFtc3Rlci5TVVBQT1JUID09PSAnRE9NTW91c2VTY3JvbGwnKSB7XG4gICAgICBIYW1zdGVyLmV2ZW50LmFkZCh0aGlzLCAnTW96TW91c2VQaXhlbFNjcm9sbCcsIGhhbmRsZXIsIHVzZUNhcHR1cmUpO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xuICB9LFxuXG4gIC8qKlxuICAgKiB1bmJpbmQgZXZlbnRzIHRvIHRoZSBpbnN0YW5jZVxuICAgKiBAcGFyYW0gICB7RnVuY3Rpb259ICAgIGhhbmRsZXJcbiAgICogQHBhcmFtICAge0Jvb2xlYW59ICAgICB1c2VDYXB0dXJlXG4gICAqIEByZXR1cm5zIHtIYW1zdGVyLkluc3RhbmNlfVxuICAgKi9cbiAgdW53aGVlbDogZnVuY3Rpb24gb2ZmRXZlbnQoaGFuZGxlciwgdXNlQ2FwdHVyZSl7XG4gICAgLy8gaWYgbm8gaGFuZGxlciBhcmd1bWVudCxcbiAgICAvLyB1bmJpbmQgdGhlIGxhc3QgYm91bmQgaGFuZGxlciAoaWYgZXhpc3RzKVxuICAgIGlmIChoYW5kbGVyID09PSB1bmRlZmluZWQgJiYgKGhhbmRsZXIgPSB0aGlzLmhhbmRsZXJzLnNsaWNlKC0xKVswXSkpIHtcbiAgICAgIGhhbmRsZXIgPSBoYW5kbGVyLm9yaWdpbmFsO1xuICAgIH1cblxuICAgIEhhbXN0ZXIuZXZlbnQucmVtb3ZlKHRoaXMsIEhhbXN0ZXIuU1VQUE9SVCwgaGFuZGxlciwgdXNlQ2FwdHVyZSk7XG5cbiAgICAvLyBoYW5kbGUgTW96TW91c2VQaXhlbFNjcm9sbCBpbiBvbGRlciBGaXJlZm94XG4gICAgaWYgKEhhbXN0ZXIuU1VQUE9SVCA9PT0gJ0RPTU1vdXNlU2Nyb2xsJykge1xuICAgICAgSGFtc3Rlci5ldmVudC5yZW1vdmUodGhpcywgJ01vek1vdXNlUGl4ZWxTY3JvbGwnLCBoYW5kbGVyLCB1c2VDYXB0dXJlKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfVxufTtcblxuSGFtc3Rlci5ldmVudCA9IHtcbiAgLyoqXG4gICAqIGNyb3NzLWJyb3dzZXIgJ2FkZFdoZWVsTGlzdGVuZXInXG4gICAqIEBwYXJhbSAgIHtJbnN0YW5jZX0gICAgaGFtc3RlclxuICAgKiBAcGFyYW0gICB7U3RyaW5nfSAgICAgIGV2ZW50TmFtZVxuICAgKiBAcGFyYW0gICB7RnVuY3Rpb259ICAgIGhhbmRsZXJcbiAgICogQHBhcmFtICAge0Jvb2xlYW59ICAgICB1c2VDYXB0dXJlXG4gICAqL1xuICBhZGQ6IGZ1bmN0aW9uIGFkZChoYW1zdGVyLCBldmVudE5hbWUsIGhhbmRsZXIsIHVzZUNhcHR1cmUpe1xuICAgIC8vIHN0b3JlIHRoZSBvcmlnaW5hbCBoYW5kbGVyXG4gICAgdmFyIG9yaWdpbmFsSGFuZGxlciA9IGhhbmRsZXI7XG5cbiAgICAvLyByZWRlZmluZSB0aGUgaGFuZGxlclxuICAgIGhhbmRsZXIgPSBmdW5jdGlvbihvcmlnaW5hbEV2ZW50KXtcblxuICAgICAgaWYgKCFvcmlnaW5hbEV2ZW50KSB7XG4gICAgICAgIG9yaWdpbmFsRXZlbnQgPSB3aW5kb3cuZXZlbnQ7XG4gICAgICB9XG5cbiAgICAgIC8vIGNyZWF0ZSBhIG5vcm1hbGlzZWQgZXZlbnQgb2JqZWN0LFxuICAgICAgLy8gYW5kIG5vcm1hbGlzZSBcImRlbHRhc1wiIG9mIHRoZSBtb3VzZSB3aGVlbFxuICAgICAgdmFyIGV2ZW50ID0gSGFtc3Rlci5ub3JtYWxpc2UuZXZlbnQob3JpZ2luYWxFdmVudCksXG4gICAgICAgICAgZGVsdGEgPSBIYW1zdGVyLm5vcm1hbGlzZS5kZWx0YShvcmlnaW5hbEV2ZW50KTtcblxuICAgICAgLy8gZmlyZSB0aGUgb3JpZ2luYWwgaGFuZGxlciB3aXRoIG5vcm1hbGlzZWQgYXJndW1lbnRzXG4gICAgICByZXR1cm4gb3JpZ2luYWxIYW5kbGVyKGV2ZW50LCBkZWx0YVswXSwgZGVsdGFbMV0sIGRlbHRhWzJdKTtcblxuICAgIH07XG5cbiAgICAvLyBjcm9zcy1icm93c2VyIGFkZEV2ZW50TGlzdGVuZXJcbiAgICBoYW1zdGVyLmVsZW1lbnRbSGFtc3Rlci5BRERfRVZFTlRdKEhhbXN0ZXIuUFJFRklYICsgZXZlbnROYW1lLCBoYW5kbGVyLCB1c2VDYXB0dXJlIHx8IGZhbHNlKTtcblxuICAgIC8vIHN0b3JlIG9yaWdpbmFsIGFuZCBub3JtYWxpc2VkIGhhbmRsZXJzIG9uIHRoZSBpbnN0YW5jZVxuICAgIGhhbXN0ZXIuaGFuZGxlcnMucHVzaCh7XG4gICAgICBvcmlnaW5hbDogb3JpZ2luYWxIYW5kbGVyLFxuICAgICAgbm9ybWFsaXNlZDogaGFuZGxlclxuICAgIH0pO1xuICB9LFxuXG4gIC8qKlxuICAgKiByZW1vdmVXaGVlbExpc3RlbmVyXG4gICAqIEBwYXJhbSAgIHtJbnN0YW5jZX0gICAgaGFtc3RlclxuICAgKiBAcGFyYW0gICB7U3RyaW5nfSAgICAgIGV2ZW50TmFtZVxuICAgKiBAcGFyYW0gICB7RnVuY3Rpb259ICAgIGhhbmRsZXJcbiAgICogQHBhcmFtICAge0Jvb2xlYW59ICAgICB1c2VDYXB0dXJlXG4gICAqL1xuICByZW1vdmU6IGZ1bmN0aW9uIHJlbW92ZShoYW1zdGVyLCBldmVudE5hbWUsIGhhbmRsZXIsIHVzZUNhcHR1cmUpe1xuICAgIC8vIGZpbmQgdGhlIG5vcm1hbGlzZWQgaGFuZGxlciBvbiB0aGUgaW5zdGFuY2VcbiAgICB2YXIgb3JpZ2luYWxIYW5kbGVyID0gaGFuZGxlcixcbiAgICAgICAgbG9va3VwID0ge30sXG4gICAgICAgIGhhbmRsZXJzO1xuICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBoYW1zdGVyLmhhbmRsZXJzLmxlbmd0aDsgaSA8IGxlbjsgKytpKSB7XG4gICAgICBsb29rdXBbaGFtc3Rlci5oYW5kbGVyc1tpXS5vcmlnaW5hbF0gPSBoYW1zdGVyLmhhbmRsZXJzW2ldO1xuICAgIH1cbiAgICBoYW5kbGVycyA9IGxvb2t1cFtvcmlnaW5hbEhhbmRsZXJdO1xuICAgIGhhbmRsZXIgPSBoYW5kbGVycy5ub3JtYWxpc2VkO1xuXG4gICAgLy8gY3Jvc3MtYnJvd3NlciByZW1vdmVFdmVudExpc3RlbmVyXG4gICAgaGFtc3Rlci5lbGVtZW50W0hhbXN0ZXIuUkVNT1ZFX0VWRU5UXShIYW1zdGVyLlBSRUZJWCArIGV2ZW50TmFtZSwgaGFuZGxlciwgdXNlQ2FwdHVyZSB8fCBmYWxzZSk7XG5cbiAgICAvLyByZW1vdmUgb3JpZ2luYWwgYW5kIG5vcm1hbGlzZWQgaGFuZGxlcnMgZnJvbSB0aGUgaW5zdGFuY2VcbiAgICBmb3IgKHZhciBoIGluIGhhbXN0ZXIuaGFuZGxlcnMpIHtcbiAgICAgIGlmIChoYW1zdGVyLmhhbmRsZXJzW2hdID09IGhhbmRsZXJzKSB7XG4gICAgICAgIGhhbXN0ZXIuaGFuZGxlcnMuc3BsaWNlKGgsIDEpO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gIH1cbn07XG5cbi8qKlxuICogdGhlc2UgaG9sZCB0aGUgbG93ZXN0IGRlbHRhcyxcbiAqIHVzZWQgdG8gbm9ybWFsaXNlIHRoZSBkZWx0YSB2YWx1ZXNcbiAqIEB0eXBlIHtOdW1iZXJ9XG4gKi9cbnZhciBsb3dlc3REZWx0YSxcbiAgICBsb3dlc3REZWx0YVhZO1xuXG5IYW1zdGVyLm5vcm1hbGlzZSA9IHtcbiAgLyoqXG4gICAqIGZpeCBicm93c2VyIGluY29uc2lzdGVuY2llc1xuICAgKi9cbiAgYnJvd3NlcjogZnVuY3Rpb24gbm9ybWFsaXNlQnJvd3Nlcigpe1xuICAgIC8vIGRldGVjdCBkZXByZWNhdGVkIHdoZWVsIGV2ZW50c1xuICAgIGlmICghKCdvbndoZWVsJyBpbiBkb2N1bWVudCB8fCBkb2N1bWVudC5kb2N1bWVudE1vZGUgPj0gOSkpIHtcbiAgICAgIEhhbXN0ZXIuU1VQUE9SVCA9IGRvY3VtZW50Lm9ubW91c2V3aGVlbCAhPT0gdW5kZWZpbmVkID9cbiAgICAgICAgICAgICAgICAgICAgICAgICdtb3VzZXdoZWVsJyA6IC8vIHdlYmtpdCBhbmQgSUUgPCA5IHN1cHBvcnQgYXQgbGVhc3QgXCJtb3VzZXdoZWVsXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICdET01Nb3VzZVNjcm9sbCc7IC8vIGFzc3VtZSByZW1haW5pbmcgYnJvd3NlcnMgYXJlIG9sZGVyIEZpcmVmb3hcbiAgICB9XG5cbiAgICAvLyBkZXRlY3QgZGVwcmVjYXRlZCBldmVudCBtb2RlbFxuICAgIGlmICghd2luZG93LmFkZEV2ZW50TGlzdGVuZXIpIHtcbiAgICAgIC8vIGFzc3VtZSBJRSA8IDlcbiAgICAgIEhhbXN0ZXIuQUREX0VWRU5UID0gJ2F0dGFjaEV2ZW50JztcbiAgICAgIEhhbXN0ZXIuUkVNT1ZFX0VWRU5UID0gJ2RldGFjaEV2ZW50JztcbiAgICAgIEhhbXN0ZXIuUFJFRklYID0gJ29uJztcbiAgICB9XG5cbiAgfSxcblxuICAvKipcbiAgICogY3JlYXRlIGEgbm9ybWFsaXNlZCBldmVudCBvYmplY3RcbiAgICogQHBhcmFtICAge0Z1bmN0aW9ufSAgICBvcmlnaW5hbEV2ZW50XG4gICAqIEByZXR1cm5zIHtPYmplY3R9ICAgICAgZXZlbnRcbiAgICovXG4gICBldmVudDogZnVuY3Rpb24gbm9ybWFsaXNlRXZlbnQob3JpZ2luYWxFdmVudCl7XG4gICAgdmFyIGV2ZW50ID0ge1xuICAgICAgICAgIC8vIGtlZXAgYSByZWZlcmVuY2UgdG8gdGhlIG9yaWdpbmFsIGV2ZW50IG9iamVjdFxuICAgICAgICAgIG9yaWdpbmFsRXZlbnQ6IG9yaWdpbmFsRXZlbnQsXG4gICAgICAgICAgdGFyZ2V0OiBvcmlnaW5hbEV2ZW50LnRhcmdldCB8fCBvcmlnaW5hbEV2ZW50LnNyY0VsZW1lbnQsXG4gICAgICAgICAgdHlwZTogJ3doZWVsJyxcbiAgICAgICAgICBkZWx0YU1vZGU6IG9yaWdpbmFsRXZlbnQudHlwZSA9PT0gJ01vek1vdXNlUGl4ZWxTY3JvbGwnID8gMCA6IDEsXG4gICAgICAgICAgZGVsdGFYOiAwLFxuICAgICAgICAgIGRlbHRhWjogMCxcbiAgICAgICAgICBwcmV2ZW50RGVmYXVsdDogZnVuY3Rpb24oKXtcbiAgICAgICAgICAgIGlmIChvcmlnaW5hbEV2ZW50LnByZXZlbnREZWZhdWx0KSB7XG4gICAgICAgICAgICAgIG9yaWdpbmFsRXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIG9yaWdpbmFsRXZlbnQucmV0dXJuVmFsdWUgPSBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9LFxuICAgICAgICAgIHN0b3BQcm9wYWdhdGlvbjogZnVuY3Rpb24oKXtcbiAgICAgICAgICAgIGlmIChvcmlnaW5hbEV2ZW50LnN0b3BQcm9wYWdhdGlvbikge1xuICAgICAgICAgICAgICBvcmlnaW5hbEV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgb3JpZ2luYWxFdmVudC5jYW5jZWxCdWJibGUgPSBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAvLyBjYWxjdWxhdGUgZGVsdGFZIChhbmQgZGVsdGFYKSBhY2NvcmRpbmcgdG8gdGhlIGV2ZW50XG5cbiAgICAvLyAnbW91c2V3aGVlbCdcbiAgICBpZiAob3JpZ2luYWxFdmVudC53aGVlbERlbHRhKSB7XG4gICAgICBldmVudC5kZWx0YVkgPSAtIDEvNDAgKiBvcmlnaW5hbEV2ZW50LndoZWVsRGVsdGE7XG4gICAgfVxuICAgIC8vIHdlYmtpdFxuICAgIGlmIChvcmlnaW5hbEV2ZW50LndoZWVsRGVsdGFYKSB7XG4gICAgICBldmVudC5kZWx0YVggPSAtIDEvNDAgKiBvcmlnaW5hbEV2ZW50LndoZWVsRGVsdGFYO1xuICAgIH1cblxuICAgIC8vICdEb21Nb3VzZVNjcm9sbCdcbiAgICBpZiAob3JpZ2luYWxFdmVudC5kZXRhaWwpIHtcbiAgICAgIGV2ZW50LmRlbHRhWSA9IG9yaWdpbmFsRXZlbnQuZGV0YWlsO1xuICAgIH1cblxuICAgIHJldHVybiBldmVudDtcbiAgfSxcblxuICAvKipcbiAgICogbm9ybWFsaXNlICdkZWx0YXMnIG9mIHRoZSBtb3VzZSB3aGVlbFxuICAgKiBAcGFyYW0gICB7RnVuY3Rpb259ICAgIG9yaWdpbmFsRXZlbnRcbiAgICogQHJldHVybnMge0FycmF5fSAgICAgICBkZWx0YXNcbiAgICovXG4gIGRlbHRhOiBmdW5jdGlvbiBub3JtYWxpc2VEZWx0YShvcmlnaW5hbEV2ZW50KXtcbiAgICB2YXIgZGVsdGEgPSAwLFxuICAgICAgZGVsdGFYID0gMCxcbiAgICAgIGRlbHRhWSA9IDAsXG4gICAgICBhYnNEZWx0YSA9IDAsXG4gICAgICBhYnNEZWx0YVhZID0gMCxcbiAgICAgIGZuO1xuXG4gICAgLy8gbm9ybWFsaXNlIGRlbHRhcyBhY2NvcmRpbmcgdG8gdGhlIGV2ZW50XG5cbiAgICAvLyAnd2hlZWwnIGV2ZW50XG4gICAgaWYgKG9yaWdpbmFsRXZlbnQuZGVsdGFZKSB7XG4gICAgICBkZWx0YVkgPSBvcmlnaW5hbEV2ZW50LmRlbHRhWSAqIC0xO1xuICAgICAgZGVsdGEgID0gZGVsdGFZO1xuICAgIH1cbiAgICBpZiAob3JpZ2luYWxFdmVudC5kZWx0YVgpIHtcbiAgICAgIGRlbHRhWCA9IG9yaWdpbmFsRXZlbnQuZGVsdGFYO1xuICAgICAgZGVsdGEgID0gZGVsdGFYICogLTE7XG4gICAgfVxuXG4gICAgLy8gJ21vdXNld2hlZWwnIGV2ZW50XG4gICAgaWYgKG9yaWdpbmFsRXZlbnQud2hlZWxEZWx0YSkge1xuICAgICAgZGVsdGEgPSBvcmlnaW5hbEV2ZW50LndoZWVsRGVsdGE7XG4gICAgfVxuICAgIC8vIHdlYmtpdFxuICAgIGlmIChvcmlnaW5hbEV2ZW50LndoZWVsRGVsdGFZKSB7XG4gICAgICBkZWx0YVkgPSBvcmlnaW5hbEV2ZW50LndoZWVsRGVsdGFZO1xuICAgIH1cbiAgICBpZiAob3JpZ2luYWxFdmVudC53aGVlbERlbHRhWCkge1xuICAgICAgZGVsdGFYID0gb3JpZ2luYWxFdmVudC53aGVlbERlbHRhWCAqIC0xO1xuICAgIH1cblxuICAgIC8vICdEb21Nb3VzZVNjcm9sbCcgZXZlbnRcbiAgICBpZiAob3JpZ2luYWxFdmVudC5kZXRhaWwpIHtcbiAgICAgIGRlbHRhID0gb3JpZ2luYWxFdmVudC5kZXRhaWwgKiAtMTtcbiAgICB9XG5cbiAgICAvLyBEb24ndCByZXR1cm4gTmFOXG4gICAgaWYgKGRlbHRhID09PSAwKSB7XG4gICAgICByZXR1cm4gWzAsIDAsIDBdO1xuICAgIH1cblxuICAgIC8vIGxvb2sgZm9yIGxvd2VzdCBkZWx0YSB0byBub3JtYWxpemUgdGhlIGRlbHRhIHZhbHVlc1xuICAgIGFic0RlbHRhID0gTWF0aC5hYnMoZGVsdGEpO1xuICAgIGlmICghbG93ZXN0RGVsdGEgfHwgYWJzRGVsdGEgPCBsb3dlc3REZWx0YSkge1xuICAgICAgbG93ZXN0RGVsdGEgPSBhYnNEZWx0YTtcbiAgICB9XG4gICAgYWJzRGVsdGFYWSA9IE1hdGgubWF4KE1hdGguYWJzKGRlbHRhWSksIE1hdGguYWJzKGRlbHRhWCkpO1xuICAgIGlmICghbG93ZXN0RGVsdGFYWSB8fCBhYnNEZWx0YVhZIDwgbG93ZXN0RGVsdGFYWSkge1xuICAgICAgbG93ZXN0RGVsdGFYWSA9IGFic0RlbHRhWFk7XG4gICAgfVxuXG4gICAgLy8gY29udmVydCBkZWx0YXMgdG8gd2hvbGUgbnVtYmVyc1xuICAgIGZuID0gZGVsdGEgPiAwID8gJ2Zsb29yJyA6ICdjZWlsJztcbiAgICBkZWx0YSAgPSBNYXRoW2ZuXShkZWx0YSAvIGxvd2VzdERlbHRhKTtcbiAgICBkZWx0YVggPSBNYXRoW2ZuXShkZWx0YVggLyBsb3dlc3REZWx0YVhZKTtcbiAgICBkZWx0YVkgPSBNYXRoW2ZuXShkZWx0YVkgLyBsb3dlc3REZWx0YVhZKTtcblxuICAgIHJldHVybiBbZGVsdGEsIGRlbHRhWCwgZGVsdGFZXTtcbiAgfVxufTtcblxuaWYgKHR5cGVvZiB3aW5kb3cuZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIHdpbmRvdy5kZWZpbmUuYW1kKSB7XG4gIC8vIEFNRFxuICB3aW5kb3cuZGVmaW5lKCdoYW1zdGVyJywgW10sIGZ1bmN0aW9uKCl7XG4gICAgcmV0dXJuIEhhbXN0ZXI7XG4gIH0pO1xufSBlbHNlIGlmICh0cnVlKSB7XG4gIC8vIENvbW1vbkpTXG4gIG1vZHVsZS5leHBvcnRzID0gSGFtc3Rlcjtcbn0gZWxzZSB7fVxuXG59KSh3aW5kb3csIHdpbmRvdy5kb2N1bWVudCk7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIDk2MTpcbi8qKiovICgobW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cbnZhciBfX1dFQlBBQ0tfQU1EX0RFRklORV9SRVNVTFRfXzsvLyBDb3B5cmlnaHQgKGMpIDIwMTMgUGllcm94eSA8cGllcm94eUBwaWVyb3h5Lm5ldD5cbi8vIFRoaXMgd29yayBpcyBmcmVlLiBZb3UgY2FuIHJlZGlzdHJpYnV0ZSBpdCBhbmQvb3IgbW9kaWZ5IGl0XG4vLyB1bmRlciB0aGUgdGVybXMgb2YgdGhlIFdURlBMLCBWZXJzaW9uIDJcbi8vIEZvciBtb3JlIGluZm9ybWF0aW9uIHNlZSBMSUNFTlNFLnR4dCBvciBodHRwOi8vd3d3Lnd0ZnBsLm5ldC9cbi8vXG4vLyBGb3IgbW9yZSBpbmZvcm1hdGlvbiwgdGhlIGhvbWUgcGFnZTpcbi8vIGh0dHA6Ly9waWVyb3h5Lm5ldC9ibG9nL3BhZ2VzL2x6LXN0cmluZy90ZXN0aW5nLmh0bWxcbi8vXG4vLyBMWi1iYXNlZCBjb21wcmVzc2lvbiBhbGdvcml0aG0sIHZlcnNpb24gMS40LjRcbnZhciBMWlN0cmluZyA9IChmdW5jdGlvbigpIHtcblxuLy8gcHJpdmF0ZSBwcm9wZXJ0eVxudmFyIGYgPSBTdHJpbmcuZnJvbUNoYXJDb2RlO1xudmFyIGtleVN0ckJhc2U2NCA9IFwiQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVphYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ejAxMjM0NTY3ODkrLz1cIjtcbnZhciBrZXlTdHJVcmlTYWZlID0gXCJBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWmFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6MDEyMzQ1Njc4OSstJFwiO1xudmFyIGJhc2VSZXZlcnNlRGljID0ge307XG5cbmZ1bmN0aW9uIGdldEJhc2VWYWx1ZShhbHBoYWJldCwgY2hhcmFjdGVyKSB7XG4gIGlmICghYmFzZVJldmVyc2VEaWNbYWxwaGFiZXRdKSB7XG4gICAgYmFzZVJldmVyc2VEaWNbYWxwaGFiZXRdID0ge307XG4gICAgZm9yICh2YXIgaT0wIDsgaTxhbHBoYWJldC5sZW5ndGggOyBpKyspIHtcbiAgICAgIGJhc2VSZXZlcnNlRGljW2FscGhhYmV0XVthbHBoYWJldC5jaGFyQXQoaSldID0gaTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGJhc2VSZXZlcnNlRGljW2FscGhhYmV0XVtjaGFyYWN0ZXJdO1xufVxuXG52YXIgTFpTdHJpbmcgPSB7XG4gIGNvbXByZXNzVG9CYXNlNjQgOiBmdW5jdGlvbiAoaW5wdXQpIHtcbiAgICBpZiAoaW5wdXQgPT0gbnVsbCkgcmV0dXJuIFwiXCI7XG4gICAgdmFyIHJlcyA9IExaU3RyaW5nLl9jb21wcmVzcyhpbnB1dCwgNiwgZnVuY3Rpb24oYSl7cmV0dXJuIGtleVN0ckJhc2U2NC5jaGFyQXQoYSk7fSk7XG4gICAgc3dpdGNoIChyZXMubGVuZ3RoICUgNCkgeyAvLyBUbyBwcm9kdWNlIHZhbGlkIEJhc2U2NFxuICAgIGRlZmF1bHQ6IC8vIFdoZW4gY291bGQgdGhpcyBoYXBwZW4gP1xuICAgIGNhc2UgMCA6IHJldHVybiByZXM7XG4gICAgY2FzZSAxIDogcmV0dXJuIHJlcytcIj09PVwiO1xuICAgIGNhc2UgMiA6IHJldHVybiByZXMrXCI9PVwiO1xuICAgIGNhc2UgMyA6IHJldHVybiByZXMrXCI9XCI7XG4gICAgfVxuICB9LFxuXG4gIGRlY29tcHJlc3NGcm9tQmFzZTY0IDogZnVuY3Rpb24gKGlucHV0KSB7XG4gICAgaWYgKGlucHV0ID09IG51bGwpIHJldHVybiBcIlwiO1xuICAgIGlmIChpbnB1dCA9PSBcIlwiKSByZXR1cm4gbnVsbDtcbiAgICByZXR1cm4gTFpTdHJpbmcuX2RlY29tcHJlc3MoaW5wdXQubGVuZ3RoLCAzMiwgZnVuY3Rpb24oaW5kZXgpIHsgcmV0dXJuIGdldEJhc2VWYWx1ZShrZXlTdHJCYXNlNjQsIGlucHV0LmNoYXJBdChpbmRleCkpOyB9KTtcbiAgfSxcblxuICBjb21wcmVzc1RvVVRGMTYgOiBmdW5jdGlvbiAoaW5wdXQpIHtcbiAgICBpZiAoaW5wdXQgPT0gbnVsbCkgcmV0dXJuIFwiXCI7XG4gICAgcmV0dXJuIExaU3RyaW5nLl9jb21wcmVzcyhpbnB1dCwgMTUsIGZ1bmN0aW9uKGEpe3JldHVybiBmKGErMzIpO30pICsgXCIgXCI7XG4gIH0sXG5cbiAgZGVjb21wcmVzc0Zyb21VVEYxNjogZnVuY3Rpb24gKGNvbXByZXNzZWQpIHtcbiAgICBpZiAoY29tcHJlc3NlZCA9PSBudWxsKSByZXR1cm4gXCJcIjtcbiAgICBpZiAoY29tcHJlc3NlZCA9PSBcIlwiKSByZXR1cm4gbnVsbDtcbiAgICByZXR1cm4gTFpTdHJpbmcuX2RlY29tcHJlc3MoY29tcHJlc3NlZC5sZW5ndGgsIDE2Mzg0LCBmdW5jdGlvbihpbmRleCkgeyByZXR1cm4gY29tcHJlc3NlZC5jaGFyQ29kZUF0KGluZGV4KSAtIDMyOyB9KTtcbiAgfSxcblxuICAvL2NvbXByZXNzIGludG8gdWludDhhcnJheSAoVUNTLTIgYmlnIGVuZGlhbiBmb3JtYXQpXG4gIGNvbXByZXNzVG9VaW50OEFycmF5OiBmdW5jdGlvbiAodW5jb21wcmVzc2VkKSB7XG4gICAgdmFyIGNvbXByZXNzZWQgPSBMWlN0cmluZy5jb21wcmVzcyh1bmNvbXByZXNzZWQpO1xuICAgIHZhciBidWY9bmV3IFVpbnQ4QXJyYXkoY29tcHJlc3NlZC5sZW5ndGgqMik7IC8vIDIgYnl0ZXMgcGVyIGNoYXJhY3RlclxuXG4gICAgZm9yICh2YXIgaT0wLCBUb3RhbExlbj1jb21wcmVzc2VkLmxlbmd0aDsgaTxUb3RhbExlbjsgaSsrKSB7XG4gICAgICB2YXIgY3VycmVudF92YWx1ZSA9IGNvbXByZXNzZWQuY2hhckNvZGVBdChpKTtcbiAgICAgIGJ1ZltpKjJdID0gY3VycmVudF92YWx1ZSA+Pj4gODtcbiAgICAgIGJ1ZltpKjIrMV0gPSBjdXJyZW50X3ZhbHVlICUgMjU2O1xuICAgIH1cbiAgICByZXR1cm4gYnVmO1xuICB9LFxuXG4gIC8vZGVjb21wcmVzcyBmcm9tIHVpbnQ4YXJyYXkgKFVDUy0yIGJpZyBlbmRpYW4gZm9ybWF0KVxuICBkZWNvbXByZXNzRnJvbVVpbnQ4QXJyYXk6ZnVuY3Rpb24gKGNvbXByZXNzZWQpIHtcbiAgICBpZiAoY29tcHJlc3NlZD09PW51bGwgfHwgY29tcHJlc3NlZD09PXVuZGVmaW5lZCl7XG4gICAgICAgIHJldHVybiBMWlN0cmluZy5kZWNvbXByZXNzKGNvbXByZXNzZWQpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBidWY9bmV3IEFycmF5KGNvbXByZXNzZWQubGVuZ3RoLzIpOyAvLyAyIGJ5dGVzIHBlciBjaGFyYWN0ZXJcbiAgICAgICAgZm9yICh2YXIgaT0wLCBUb3RhbExlbj1idWYubGVuZ3RoOyBpPFRvdGFsTGVuOyBpKyspIHtcbiAgICAgICAgICBidWZbaV09Y29tcHJlc3NlZFtpKjJdKjI1Nitjb21wcmVzc2VkW2kqMisxXTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciByZXN1bHQgPSBbXTtcbiAgICAgICAgYnVmLmZvckVhY2goZnVuY3Rpb24gKGMpIHtcbiAgICAgICAgICByZXN1bHQucHVzaChmKGMpKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBMWlN0cmluZy5kZWNvbXByZXNzKHJlc3VsdC5qb2luKCcnKSk7XG5cbiAgICB9XG5cbiAgfSxcblxuXG4gIC8vY29tcHJlc3MgaW50byBhIHN0cmluZyB0aGF0IGlzIGFscmVhZHkgVVJJIGVuY29kZWRcbiAgY29tcHJlc3NUb0VuY29kZWRVUklDb21wb25lbnQ6IGZ1bmN0aW9uIChpbnB1dCkge1xuICAgIGlmIChpbnB1dCA9PSBudWxsKSByZXR1cm4gXCJcIjtcbiAgICByZXR1cm4gTFpTdHJpbmcuX2NvbXByZXNzKGlucHV0LCA2LCBmdW5jdGlvbihhKXtyZXR1cm4ga2V5U3RyVXJpU2FmZS5jaGFyQXQoYSk7fSk7XG4gIH0sXG5cbiAgLy9kZWNvbXByZXNzIGZyb20gYW4gb3V0cHV0IG9mIGNvbXByZXNzVG9FbmNvZGVkVVJJQ29tcG9uZW50XG4gIGRlY29tcHJlc3NGcm9tRW5jb2RlZFVSSUNvbXBvbmVudDpmdW5jdGlvbiAoaW5wdXQpIHtcbiAgICBpZiAoaW5wdXQgPT0gbnVsbCkgcmV0dXJuIFwiXCI7XG4gICAgaWYgKGlucHV0ID09IFwiXCIpIHJldHVybiBudWxsO1xuICAgIGlucHV0ID0gaW5wdXQucmVwbGFjZSgvIC9nLCBcIitcIik7XG4gICAgcmV0dXJuIExaU3RyaW5nLl9kZWNvbXByZXNzKGlucHV0Lmxlbmd0aCwgMzIsIGZ1bmN0aW9uKGluZGV4KSB7IHJldHVybiBnZXRCYXNlVmFsdWUoa2V5U3RyVXJpU2FmZSwgaW5wdXQuY2hhckF0KGluZGV4KSk7IH0pO1xuICB9LFxuXG4gIGNvbXByZXNzOiBmdW5jdGlvbiAodW5jb21wcmVzc2VkKSB7XG4gICAgcmV0dXJuIExaU3RyaW5nLl9jb21wcmVzcyh1bmNvbXByZXNzZWQsIDE2LCBmdW5jdGlvbihhKXtyZXR1cm4gZihhKTt9KTtcbiAgfSxcbiAgX2NvbXByZXNzOiBmdW5jdGlvbiAodW5jb21wcmVzc2VkLCBiaXRzUGVyQ2hhciwgZ2V0Q2hhckZyb21JbnQpIHtcbiAgICBpZiAodW5jb21wcmVzc2VkID09IG51bGwpIHJldHVybiBcIlwiO1xuICAgIHZhciBpLCB2YWx1ZSxcbiAgICAgICAgY29udGV4dF9kaWN0aW9uYXJ5PSB7fSxcbiAgICAgICAgY29udGV4dF9kaWN0aW9uYXJ5VG9DcmVhdGU9IHt9LFxuICAgICAgICBjb250ZXh0X2M9XCJcIixcbiAgICAgICAgY29udGV4dF93Yz1cIlwiLFxuICAgICAgICBjb250ZXh0X3c9XCJcIixcbiAgICAgICAgY29udGV4dF9lbmxhcmdlSW49IDIsIC8vIENvbXBlbnNhdGUgZm9yIHRoZSBmaXJzdCBlbnRyeSB3aGljaCBzaG91bGQgbm90IGNvdW50XG4gICAgICAgIGNvbnRleHRfZGljdFNpemU9IDMsXG4gICAgICAgIGNvbnRleHRfbnVtQml0cz0gMixcbiAgICAgICAgY29udGV4dF9kYXRhPVtdLFxuICAgICAgICBjb250ZXh0X2RhdGFfdmFsPTAsXG4gICAgICAgIGNvbnRleHRfZGF0YV9wb3NpdGlvbj0wLFxuICAgICAgICBpaTtcblxuICAgIGZvciAoaWkgPSAwOyBpaSA8IHVuY29tcHJlc3NlZC5sZW5ndGg7IGlpICs9IDEpIHtcbiAgICAgIGNvbnRleHRfYyA9IHVuY29tcHJlc3NlZC5jaGFyQXQoaWkpO1xuICAgICAgaWYgKCFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoY29udGV4dF9kaWN0aW9uYXJ5LGNvbnRleHRfYykpIHtcbiAgICAgICAgY29udGV4dF9kaWN0aW9uYXJ5W2NvbnRleHRfY10gPSBjb250ZXh0X2RpY3RTaXplKys7XG4gICAgICAgIGNvbnRleHRfZGljdGlvbmFyeVRvQ3JlYXRlW2NvbnRleHRfY10gPSB0cnVlO1xuICAgICAgfVxuXG4gICAgICBjb250ZXh0X3djID0gY29udGV4dF93ICsgY29udGV4dF9jO1xuICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChjb250ZXh0X2RpY3Rpb25hcnksY29udGV4dF93YykpIHtcbiAgICAgICAgY29udGV4dF93ID0gY29udGV4dF93YztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoY29udGV4dF9kaWN0aW9uYXJ5VG9DcmVhdGUsY29udGV4dF93KSkge1xuICAgICAgICAgIGlmIChjb250ZXh0X3cuY2hhckNvZGVBdCgwKTwyNTYpIHtcbiAgICAgICAgICAgIGZvciAoaT0wIDsgaTxjb250ZXh0X251bUJpdHMgOyBpKyspIHtcbiAgICAgICAgICAgICAgY29udGV4dF9kYXRhX3ZhbCA9IChjb250ZXh0X2RhdGFfdmFsIDw8IDEpO1xuICAgICAgICAgICAgICBpZiAoY29udGV4dF9kYXRhX3Bvc2l0aW9uID09IGJpdHNQZXJDaGFyLTEpIHtcbiAgICAgICAgICAgICAgICBjb250ZXh0X2RhdGFfcG9zaXRpb24gPSAwO1xuICAgICAgICAgICAgICAgIGNvbnRleHRfZGF0YS5wdXNoKGdldENoYXJGcm9tSW50KGNvbnRleHRfZGF0YV92YWwpKTtcbiAgICAgICAgICAgICAgICBjb250ZXh0X2RhdGFfdmFsID0gMDtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb250ZXh0X2RhdGFfcG9zaXRpb24rKztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFsdWUgPSBjb250ZXh0X3cuY2hhckNvZGVBdCgwKTtcbiAgICAgICAgICAgIGZvciAoaT0wIDsgaTw4IDsgaSsrKSB7XG4gICAgICAgICAgICAgIGNvbnRleHRfZGF0YV92YWwgPSAoY29udGV4dF9kYXRhX3ZhbCA8PCAxKSB8ICh2YWx1ZSYxKTtcbiAgICAgICAgICAgICAgaWYgKGNvbnRleHRfZGF0YV9wb3NpdGlvbiA9PSBiaXRzUGVyQ2hhci0xKSB7XG4gICAgICAgICAgICAgICAgY29udGV4dF9kYXRhX3Bvc2l0aW9uID0gMDtcbiAgICAgICAgICAgICAgICBjb250ZXh0X2RhdGEucHVzaChnZXRDaGFyRnJvbUludChjb250ZXh0X2RhdGFfdmFsKSk7XG4gICAgICAgICAgICAgICAgY29udGV4dF9kYXRhX3ZhbCA9IDA7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgY29udGV4dF9kYXRhX3Bvc2l0aW9uKys7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgdmFsdWUgPSB2YWx1ZSA+PiAxO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YWx1ZSA9IDE7XG4gICAgICAgICAgICBmb3IgKGk9MCA7IGk8Y29udGV4dF9udW1CaXRzIDsgaSsrKSB7XG4gICAgICAgICAgICAgIGNvbnRleHRfZGF0YV92YWwgPSAoY29udGV4dF9kYXRhX3ZhbCA8PCAxKSB8IHZhbHVlO1xuICAgICAgICAgICAgICBpZiAoY29udGV4dF9kYXRhX3Bvc2l0aW9uID09Yml0c1BlckNoYXItMSkge1xuICAgICAgICAgICAgICAgIGNvbnRleHRfZGF0YV9wb3NpdGlvbiA9IDA7XG4gICAgICAgICAgICAgICAgY29udGV4dF9kYXRhLnB1c2goZ2V0Q2hhckZyb21JbnQoY29udGV4dF9kYXRhX3ZhbCkpO1xuICAgICAgICAgICAgICAgIGNvbnRleHRfZGF0YV92YWwgPSAwO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvbnRleHRfZGF0YV9wb3NpdGlvbisrO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHZhbHVlID0gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhbHVlID0gY29udGV4dF93LmNoYXJDb2RlQXQoMCk7XG4gICAgICAgICAgICBmb3IgKGk9MCA7IGk8MTYgOyBpKyspIHtcbiAgICAgICAgICAgICAgY29udGV4dF9kYXRhX3ZhbCA9IChjb250ZXh0X2RhdGFfdmFsIDw8IDEpIHwgKHZhbHVlJjEpO1xuICAgICAgICAgICAgICBpZiAoY29udGV4dF9kYXRhX3Bvc2l0aW9uID09IGJpdHNQZXJDaGFyLTEpIHtcbiAgICAgICAgICAgICAgICBjb250ZXh0X2RhdGFfcG9zaXRpb24gPSAwO1xuICAgICAgICAgICAgICAgIGNvbnRleHRfZGF0YS5wdXNoKGdldENoYXJGcm9tSW50KGNvbnRleHRfZGF0YV92YWwpKTtcbiAgICAgICAgICAgICAgICBjb250ZXh0X2RhdGFfdmFsID0gMDtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb250ZXh0X2RhdGFfcG9zaXRpb24rKztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB2YWx1ZSA9IHZhbHVlID4+IDE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnRleHRfZW5sYXJnZUluLS07XG4gICAgICAgICAgaWYgKGNvbnRleHRfZW5sYXJnZUluID09IDApIHtcbiAgICAgICAgICAgIGNvbnRleHRfZW5sYXJnZUluID0gTWF0aC5wb3coMiwgY29udGV4dF9udW1CaXRzKTtcbiAgICAgICAgICAgIGNvbnRleHRfbnVtQml0cysrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBkZWxldGUgY29udGV4dF9kaWN0aW9uYXJ5VG9DcmVhdGVbY29udGV4dF93XTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YWx1ZSA9IGNvbnRleHRfZGljdGlvbmFyeVtjb250ZXh0X3ddO1xuICAgICAgICAgIGZvciAoaT0wIDsgaTxjb250ZXh0X251bUJpdHMgOyBpKyspIHtcbiAgICAgICAgICAgIGNvbnRleHRfZGF0YV92YWwgPSAoY29udGV4dF9kYXRhX3ZhbCA8PCAxKSB8ICh2YWx1ZSYxKTtcbiAgICAgICAgICAgIGlmIChjb250ZXh0X2RhdGFfcG9zaXRpb24gPT0gYml0c1BlckNoYXItMSkge1xuICAgICAgICAgICAgICBjb250ZXh0X2RhdGFfcG9zaXRpb24gPSAwO1xuICAgICAgICAgICAgICBjb250ZXh0X2RhdGEucHVzaChnZXRDaGFyRnJvbUludChjb250ZXh0X2RhdGFfdmFsKSk7XG4gICAgICAgICAgICAgIGNvbnRleHRfZGF0YV92YWwgPSAwO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgY29udGV4dF9kYXRhX3Bvc2l0aW9uKys7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YWx1ZSA9IHZhbHVlID4+IDE7XG4gICAgICAgICAgfVxuXG5cbiAgICAgICAgfVxuICAgICAgICBjb250ZXh0X2VubGFyZ2VJbi0tO1xuICAgICAgICBpZiAoY29udGV4dF9lbmxhcmdlSW4gPT0gMCkge1xuICAgICAgICAgIGNvbnRleHRfZW5sYXJnZUluID0gTWF0aC5wb3coMiwgY29udGV4dF9udW1CaXRzKTtcbiAgICAgICAgICBjb250ZXh0X251bUJpdHMrKztcbiAgICAgICAgfVxuICAgICAgICAvLyBBZGQgd2MgdG8gdGhlIGRpY3Rpb25hcnkuXG4gICAgICAgIGNvbnRleHRfZGljdGlvbmFyeVtjb250ZXh0X3djXSA9IGNvbnRleHRfZGljdFNpemUrKztcbiAgICAgICAgY29udGV4dF93ID0gU3RyaW5nKGNvbnRleHRfYyk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gT3V0cHV0IHRoZSBjb2RlIGZvciB3LlxuICAgIGlmIChjb250ZXh0X3cgIT09IFwiXCIpIHtcbiAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoY29udGV4dF9kaWN0aW9uYXJ5VG9DcmVhdGUsY29udGV4dF93KSkge1xuICAgICAgICBpZiAoY29udGV4dF93LmNoYXJDb2RlQXQoMCk8MjU2KSB7XG4gICAgICAgICAgZm9yIChpPTAgOyBpPGNvbnRleHRfbnVtQml0cyA7IGkrKykge1xuICAgICAgICAgICAgY29udGV4dF9kYXRhX3ZhbCA9IChjb250ZXh0X2RhdGFfdmFsIDw8IDEpO1xuICAgICAgICAgICAgaWYgKGNvbnRleHRfZGF0YV9wb3NpdGlvbiA9PSBiaXRzUGVyQ2hhci0xKSB7XG4gICAgICAgICAgICAgIGNvbnRleHRfZGF0YV9wb3NpdGlvbiA9IDA7XG4gICAgICAgICAgICAgIGNvbnRleHRfZGF0YS5wdXNoKGdldENoYXJGcm9tSW50KGNvbnRleHRfZGF0YV92YWwpKTtcbiAgICAgICAgICAgICAgY29udGV4dF9kYXRhX3ZhbCA9IDA7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBjb250ZXh0X2RhdGFfcG9zaXRpb24rKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgdmFsdWUgPSBjb250ZXh0X3cuY2hhckNvZGVBdCgwKTtcbiAgICAgICAgICBmb3IgKGk9MCA7IGk8OCA7IGkrKykge1xuICAgICAgICAgICAgY29udGV4dF9kYXRhX3ZhbCA9IChjb250ZXh0X2RhdGFfdmFsIDw8IDEpIHwgKHZhbHVlJjEpO1xuICAgICAgICAgICAgaWYgKGNvbnRleHRfZGF0YV9wb3NpdGlvbiA9PSBiaXRzUGVyQ2hhci0xKSB7XG4gICAgICAgICAgICAgIGNvbnRleHRfZGF0YV9wb3NpdGlvbiA9IDA7XG4gICAgICAgICAgICAgIGNvbnRleHRfZGF0YS5wdXNoKGdldENoYXJGcm9tSW50KGNvbnRleHRfZGF0YV92YWwpKTtcbiAgICAgICAgICAgICAgY29udGV4dF9kYXRhX3ZhbCA9IDA7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBjb250ZXh0X2RhdGFfcG9zaXRpb24rKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhbHVlID0gdmFsdWUgPj4gMTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFsdWUgPSAxO1xuICAgICAgICAgIGZvciAoaT0wIDsgaTxjb250ZXh0X251bUJpdHMgOyBpKyspIHtcbiAgICAgICAgICAgIGNvbnRleHRfZGF0YV92YWwgPSAoY29udGV4dF9kYXRhX3ZhbCA8PCAxKSB8IHZhbHVlO1xuICAgICAgICAgICAgaWYgKGNvbnRleHRfZGF0YV9wb3NpdGlvbiA9PSBiaXRzUGVyQ2hhci0xKSB7XG4gICAgICAgICAgICAgIGNvbnRleHRfZGF0YV9wb3NpdGlvbiA9IDA7XG4gICAgICAgICAgICAgIGNvbnRleHRfZGF0YS5wdXNoKGdldENoYXJGcm9tSW50KGNvbnRleHRfZGF0YV92YWwpKTtcbiAgICAgICAgICAgICAgY29udGV4dF9kYXRhX3ZhbCA9IDA7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBjb250ZXh0X2RhdGFfcG9zaXRpb24rKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhbHVlID0gMDtcbiAgICAgICAgICB9XG4gICAgICAgICAgdmFsdWUgPSBjb250ZXh0X3cuY2hhckNvZGVBdCgwKTtcbiAgICAgICAgICBmb3IgKGk9MCA7IGk8MTYgOyBpKyspIHtcbiAgICAgICAgICAgIGNvbnRleHRfZGF0YV92YWwgPSAoY29udGV4dF9kYXRhX3ZhbCA8PCAxKSB8ICh2YWx1ZSYxKTtcbiAgICAgICAgICAgIGlmIChjb250ZXh0X2RhdGFfcG9zaXRpb24gPT0gYml0c1BlckNoYXItMSkge1xuICAgICAgICAgICAgICBjb250ZXh0X2RhdGFfcG9zaXRpb24gPSAwO1xuICAgICAgICAgICAgICBjb250ZXh0X2RhdGEucHVzaChnZXRDaGFyRnJvbUludChjb250ZXh0X2RhdGFfdmFsKSk7XG4gICAgICAgICAgICAgIGNvbnRleHRfZGF0YV92YWwgPSAwO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgY29udGV4dF9kYXRhX3Bvc2l0aW9uKys7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YWx1ZSA9IHZhbHVlID4+IDE7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNvbnRleHRfZW5sYXJnZUluLS07XG4gICAgICAgIGlmIChjb250ZXh0X2VubGFyZ2VJbiA9PSAwKSB7XG4gICAgICAgICAgY29udGV4dF9lbmxhcmdlSW4gPSBNYXRoLnBvdygyLCBjb250ZXh0X251bUJpdHMpO1xuICAgICAgICAgIGNvbnRleHRfbnVtQml0cysrO1xuICAgICAgICB9XG4gICAgICAgIGRlbGV0ZSBjb250ZXh0X2RpY3Rpb25hcnlUb0NyZWF0ZVtjb250ZXh0X3ddO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFsdWUgPSBjb250ZXh0X2RpY3Rpb25hcnlbY29udGV4dF93XTtcbiAgICAgICAgZm9yIChpPTAgOyBpPGNvbnRleHRfbnVtQml0cyA7IGkrKykge1xuICAgICAgICAgIGNvbnRleHRfZGF0YV92YWwgPSAoY29udGV4dF9kYXRhX3ZhbCA8PCAxKSB8ICh2YWx1ZSYxKTtcbiAgICAgICAgICBpZiAoY29udGV4dF9kYXRhX3Bvc2l0aW9uID09IGJpdHNQZXJDaGFyLTEpIHtcbiAgICAgICAgICAgIGNvbnRleHRfZGF0YV9wb3NpdGlvbiA9IDA7XG4gICAgICAgICAgICBjb250ZXh0X2RhdGEucHVzaChnZXRDaGFyRnJvbUludChjb250ZXh0X2RhdGFfdmFsKSk7XG4gICAgICAgICAgICBjb250ZXh0X2RhdGFfdmFsID0gMDtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY29udGV4dF9kYXRhX3Bvc2l0aW9uKys7XG4gICAgICAgICAgfVxuICAgICAgICAgIHZhbHVlID0gdmFsdWUgPj4gMTtcbiAgICAgICAgfVxuXG5cbiAgICAgIH1cbiAgICAgIGNvbnRleHRfZW5sYXJnZUluLS07XG4gICAgICBpZiAoY29udGV4dF9lbmxhcmdlSW4gPT0gMCkge1xuICAgICAgICBjb250ZXh0X2VubGFyZ2VJbiA9IE1hdGgucG93KDIsIGNvbnRleHRfbnVtQml0cyk7XG4gICAgICAgIGNvbnRleHRfbnVtQml0cysrO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIE1hcmsgdGhlIGVuZCBvZiB0aGUgc3RyZWFtXG4gICAgdmFsdWUgPSAyO1xuICAgIGZvciAoaT0wIDsgaTxjb250ZXh0X251bUJpdHMgOyBpKyspIHtcbiAgICAgIGNvbnRleHRfZGF0YV92YWwgPSAoY29udGV4dF9kYXRhX3ZhbCA8PCAxKSB8ICh2YWx1ZSYxKTtcbiAgICAgIGlmIChjb250ZXh0X2RhdGFfcG9zaXRpb24gPT0gYml0c1BlckNoYXItMSkge1xuICAgICAgICBjb250ZXh0X2RhdGFfcG9zaXRpb24gPSAwO1xuICAgICAgICBjb250ZXh0X2RhdGEucHVzaChnZXRDaGFyRnJvbUludChjb250ZXh0X2RhdGFfdmFsKSk7XG4gICAgICAgIGNvbnRleHRfZGF0YV92YWwgPSAwO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29udGV4dF9kYXRhX3Bvc2l0aW9uKys7XG4gICAgICB9XG4gICAgICB2YWx1ZSA9IHZhbHVlID4+IDE7XG4gICAgfVxuXG4gICAgLy8gRmx1c2ggdGhlIGxhc3QgY2hhclxuICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICBjb250ZXh0X2RhdGFfdmFsID0gKGNvbnRleHRfZGF0YV92YWwgPDwgMSk7XG4gICAgICBpZiAoY29udGV4dF9kYXRhX3Bvc2l0aW9uID09IGJpdHNQZXJDaGFyLTEpIHtcbiAgICAgICAgY29udGV4dF9kYXRhLnB1c2goZ2V0Q2hhckZyb21JbnQoY29udGV4dF9kYXRhX3ZhbCkpO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGVsc2UgY29udGV4dF9kYXRhX3Bvc2l0aW9uKys7XG4gICAgfVxuICAgIHJldHVybiBjb250ZXh0X2RhdGEuam9pbignJyk7XG4gIH0sXG5cbiAgZGVjb21wcmVzczogZnVuY3Rpb24gKGNvbXByZXNzZWQpIHtcbiAgICBpZiAoY29tcHJlc3NlZCA9PSBudWxsKSByZXR1cm4gXCJcIjtcbiAgICBpZiAoY29tcHJlc3NlZCA9PSBcIlwiKSByZXR1cm4gbnVsbDtcbiAgICByZXR1cm4gTFpTdHJpbmcuX2RlY29tcHJlc3MoY29tcHJlc3NlZC5sZW5ndGgsIDMyNzY4LCBmdW5jdGlvbihpbmRleCkgeyByZXR1cm4gY29tcHJlc3NlZC5jaGFyQ29kZUF0KGluZGV4KTsgfSk7XG4gIH0sXG5cbiAgX2RlY29tcHJlc3M6IGZ1bmN0aW9uIChsZW5ndGgsIHJlc2V0VmFsdWUsIGdldE5leHRWYWx1ZSkge1xuICAgIHZhciBkaWN0aW9uYXJ5ID0gW10sXG4gICAgICAgIG5leHQsXG4gICAgICAgIGVubGFyZ2VJbiA9IDQsXG4gICAgICAgIGRpY3RTaXplID0gNCxcbiAgICAgICAgbnVtQml0cyA9IDMsXG4gICAgICAgIGVudHJ5ID0gXCJcIixcbiAgICAgICAgcmVzdWx0ID0gW10sXG4gICAgICAgIGksXG4gICAgICAgIHcsXG4gICAgICAgIGJpdHMsIHJlc2IsIG1heHBvd2VyLCBwb3dlcixcbiAgICAgICAgYyxcbiAgICAgICAgZGF0YSA9IHt2YWw6Z2V0TmV4dFZhbHVlKDApLCBwb3NpdGlvbjpyZXNldFZhbHVlLCBpbmRleDoxfTtcblxuICAgIGZvciAoaSA9IDA7IGkgPCAzOyBpICs9IDEpIHtcbiAgICAgIGRpY3Rpb25hcnlbaV0gPSBpO1xuICAgIH1cblxuICAgIGJpdHMgPSAwO1xuICAgIG1heHBvd2VyID0gTWF0aC5wb3coMiwyKTtcbiAgICBwb3dlcj0xO1xuICAgIHdoaWxlIChwb3dlciE9bWF4cG93ZXIpIHtcbiAgICAgIHJlc2IgPSBkYXRhLnZhbCAmIGRhdGEucG9zaXRpb247XG4gICAgICBkYXRhLnBvc2l0aW9uID4+PSAxO1xuICAgICAgaWYgKGRhdGEucG9zaXRpb24gPT0gMCkge1xuICAgICAgICBkYXRhLnBvc2l0aW9uID0gcmVzZXRWYWx1ZTtcbiAgICAgICAgZGF0YS52YWwgPSBnZXROZXh0VmFsdWUoZGF0YS5pbmRleCsrKTtcbiAgICAgIH1cbiAgICAgIGJpdHMgfD0gKHJlc2I+MCA/IDEgOiAwKSAqIHBvd2VyO1xuICAgICAgcG93ZXIgPDw9IDE7XG4gICAgfVxuXG4gICAgc3dpdGNoIChuZXh0ID0gYml0cykge1xuICAgICAgY2FzZSAwOlxuICAgICAgICAgIGJpdHMgPSAwO1xuICAgICAgICAgIG1heHBvd2VyID0gTWF0aC5wb3coMiw4KTtcbiAgICAgICAgICBwb3dlcj0xO1xuICAgICAgICAgIHdoaWxlIChwb3dlciE9bWF4cG93ZXIpIHtcbiAgICAgICAgICAgIHJlc2IgPSBkYXRhLnZhbCAmIGRhdGEucG9zaXRpb247XG4gICAgICAgICAgICBkYXRhLnBvc2l0aW9uID4+PSAxO1xuICAgICAgICAgICAgaWYgKGRhdGEucG9zaXRpb24gPT0gMCkge1xuICAgICAgICAgICAgICBkYXRhLnBvc2l0aW9uID0gcmVzZXRWYWx1ZTtcbiAgICAgICAgICAgICAgZGF0YS52YWwgPSBnZXROZXh0VmFsdWUoZGF0YS5pbmRleCsrKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJpdHMgfD0gKHJlc2I+MCA/IDEgOiAwKSAqIHBvd2VyO1xuICAgICAgICAgICAgcG93ZXIgPDw9IDE7XG4gICAgICAgICAgfVxuICAgICAgICBjID0gZihiaXRzKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDE6XG4gICAgICAgICAgYml0cyA9IDA7XG4gICAgICAgICAgbWF4cG93ZXIgPSBNYXRoLnBvdygyLDE2KTtcbiAgICAgICAgICBwb3dlcj0xO1xuICAgICAgICAgIHdoaWxlIChwb3dlciE9bWF4cG93ZXIpIHtcbiAgICAgICAgICAgIHJlc2IgPSBkYXRhLnZhbCAmIGRhdGEucG9zaXRpb247XG4gICAgICAgICAgICBkYXRhLnBvc2l0aW9uID4+PSAxO1xuICAgICAgICAgICAgaWYgKGRhdGEucG9zaXRpb24gPT0gMCkge1xuICAgICAgICAgICAgICBkYXRhLnBvc2l0aW9uID0gcmVzZXRWYWx1ZTtcbiAgICAgICAgICAgICAgZGF0YS52YWwgPSBnZXROZXh0VmFsdWUoZGF0YS5pbmRleCsrKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJpdHMgfD0gKHJlc2I+MCA/IDEgOiAwKSAqIHBvd2VyO1xuICAgICAgICAgICAgcG93ZXIgPDw9IDE7XG4gICAgICAgICAgfVxuICAgICAgICBjID0gZihiaXRzKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDI6XG4gICAgICAgIHJldHVybiBcIlwiO1xuICAgIH1cbiAgICBkaWN0aW9uYXJ5WzNdID0gYztcbiAgICB3ID0gYztcbiAgICByZXN1bHQucHVzaChjKTtcbiAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgaWYgKGRhdGEuaW5kZXggPiBsZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIFwiXCI7XG4gICAgICB9XG5cbiAgICAgIGJpdHMgPSAwO1xuICAgICAgbWF4cG93ZXIgPSBNYXRoLnBvdygyLG51bUJpdHMpO1xuICAgICAgcG93ZXI9MTtcbiAgICAgIHdoaWxlIChwb3dlciE9bWF4cG93ZXIpIHtcbiAgICAgICAgcmVzYiA9IGRhdGEudmFsICYgZGF0YS5wb3NpdGlvbjtcbiAgICAgICAgZGF0YS5wb3NpdGlvbiA+Pj0gMTtcbiAgICAgICAgaWYgKGRhdGEucG9zaXRpb24gPT0gMCkge1xuICAgICAgICAgIGRhdGEucG9zaXRpb24gPSByZXNldFZhbHVlO1xuICAgICAgICAgIGRhdGEudmFsID0gZ2V0TmV4dFZhbHVlKGRhdGEuaW5kZXgrKyk7XG4gICAgICAgIH1cbiAgICAgICAgYml0cyB8PSAocmVzYj4wID8gMSA6IDApICogcG93ZXI7XG4gICAgICAgIHBvd2VyIDw8PSAxO1xuICAgICAgfVxuXG4gICAgICBzd2l0Y2ggKGMgPSBiaXRzKSB7XG4gICAgICAgIGNhc2UgMDpcbiAgICAgICAgICBiaXRzID0gMDtcbiAgICAgICAgICBtYXhwb3dlciA9IE1hdGgucG93KDIsOCk7XG4gICAgICAgICAgcG93ZXI9MTtcbiAgICAgICAgICB3aGlsZSAocG93ZXIhPW1heHBvd2VyKSB7XG4gICAgICAgICAgICByZXNiID0gZGF0YS52YWwgJiBkYXRhLnBvc2l0aW9uO1xuICAgICAgICAgICAgZGF0YS5wb3NpdGlvbiA+Pj0gMTtcbiAgICAgICAgICAgIGlmIChkYXRhLnBvc2l0aW9uID09IDApIHtcbiAgICAgICAgICAgICAgZGF0YS5wb3NpdGlvbiA9IHJlc2V0VmFsdWU7XG4gICAgICAgICAgICAgIGRhdGEudmFsID0gZ2V0TmV4dFZhbHVlKGRhdGEuaW5kZXgrKyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBiaXRzIHw9IChyZXNiPjAgPyAxIDogMCkgKiBwb3dlcjtcbiAgICAgICAgICAgIHBvd2VyIDw8PSAxO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGRpY3Rpb25hcnlbZGljdFNpemUrK10gPSBmKGJpdHMpO1xuICAgICAgICAgIGMgPSBkaWN0U2l6ZS0xO1xuICAgICAgICAgIGVubGFyZ2VJbi0tO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgYml0cyA9IDA7XG4gICAgICAgICAgbWF4cG93ZXIgPSBNYXRoLnBvdygyLDE2KTtcbiAgICAgICAgICBwb3dlcj0xO1xuICAgICAgICAgIHdoaWxlIChwb3dlciE9bWF4cG93ZXIpIHtcbiAgICAgICAgICAgIHJlc2IgPSBkYXRhLnZhbCAmIGRhdGEucG9zaXRpb247XG4gICAgICAgICAgICBkYXRhLnBvc2l0aW9uID4+PSAxO1xuICAgICAgICAgICAgaWYgKGRhdGEucG9zaXRpb24gPT0gMCkge1xuICAgICAgICAgICAgICBkYXRhLnBvc2l0aW9uID0gcmVzZXRWYWx1ZTtcbiAgICAgICAgICAgICAgZGF0YS52YWwgPSBnZXROZXh0VmFsdWUoZGF0YS5pbmRleCsrKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJpdHMgfD0gKHJlc2I+MCA/IDEgOiAwKSAqIHBvd2VyO1xuICAgICAgICAgICAgcG93ZXIgPDw9IDE7XG4gICAgICAgICAgfVxuICAgICAgICAgIGRpY3Rpb25hcnlbZGljdFNpemUrK10gPSBmKGJpdHMpO1xuICAgICAgICAgIGMgPSBkaWN0U2l6ZS0xO1xuICAgICAgICAgIGVubGFyZ2VJbi0tO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgcmV0dXJuIHJlc3VsdC5qb2luKCcnKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGVubGFyZ2VJbiA9PSAwKSB7XG4gICAgICAgIGVubGFyZ2VJbiA9IE1hdGgucG93KDIsIG51bUJpdHMpO1xuICAgICAgICBudW1CaXRzKys7XG4gICAgICB9XG5cbiAgICAgIGlmIChkaWN0aW9uYXJ5W2NdKSB7XG4gICAgICAgIGVudHJ5ID0gZGljdGlvbmFyeVtjXTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChjID09PSBkaWN0U2l6ZSkge1xuICAgICAgICAgIGVudHJ5ID0gdyArIHcuY2hhckF0KDApO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXN1bHQucHVzaChlbnRyeSk7XG5cbiAgICAgIC8vIEFkZCB3K2VudHJ5WzBdIHRvIHRoZSBkaWN0aW9uYXJ5LlxuICAgICAgZGljdGlvbmFyeVtkaWN0U2l6ZSsrXSA9IHcgKyBlbnRyeS5jaGFyQXQoMCk7XG4gICAgICBlbmxhcmdlSW4tLTtcblxuICAgICAgdyA9IGVudHJ5O1xuXG4gICAgICBpZiAoZW5sYXJnZUluID09IDApIHtcbiAgICAgICAgZW5sYXJnZUluID0gTWF0aC5wb3coMiwgbnVtQml0cyk7XG4gICAgICAgIG51bUJpdHMrKztcbiAgICAgIH1cblxuICAgIH1cbiAgfVxufTtcbiAgcmV0dXJuIExaU3RyaW5nO1xufSkoKTtcblxuaWYgKHRydWUpIHtcbiAgIShfX1dFQlBBQ0tfQU1EX0RFRklORV9SRVNVTFRfXyA9IChmdW5jdGlvbiAoKSB7IHJldHVybiBMWlN0cmluZzsgfSkuY2FsbChleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fLCBleHBvcnRzLCBtb2R1bGUpLFxuXHRcdF9fV0VCUEFDS19BTURfREVGSU5FX1JFU1VMVF9fICE9PSB1bmRlZmluZWQgJiYgKG1vZHVsZS5leHBvcnRzID0gX19XRUJQQUNLX0FNRF9ERUZJTkVfUkVTVUxUX18pKTtcbn0gZWxzZSB7fVxuXG5cbi8qKiovIH0pLFxuXG4vKioqLyA2NjY6XG4vKioqLyAoKG1vZHVsZSkgPT4ge1xuXG4vKipcbiAqIENvcHlyaWdodCAoYykgMjAxNC1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICovXG5cbnZhciBydW50aW1lID0gKGZ1bmN0aW9uIChleHBvcnRzKSB7XG4gIFwidXNlIHN0cmljdFwiO1xuXG4gIHZhciBPcCA9IE9iamVjdC5wcm90b3R5cGU7XG4gIHZhciBoYXNPd24gPSBPcC5oYXNPd25Qcm9wZXJ0eTtcbiAgdmFyIHVuZGVmaW5lZDsgLy8gTW9yZSBjb21wcmVzc2libGUgdGhhbiB2b2lkIDAuXG4gIHZhciAkU3ltYm9sID0gdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiID8gU3ltYm9sIDoge307XG4gIHZhciBpdGVyYXRvclN5bWJvbCA9ICRTeW1ib2wuaXRlcmF0b3IgfHwgXCJAQGl0ZXJhdG9yXCI7XG4gIHZhciBhc3luY0l0ZXJhdG9yU3ltYm9sID0gJFN5bWJvbC5hc3luY0l0ZXJhdG9yIHx8IFwiQEBhc3luY0l0ZXJhdG9yXCI7XG4gIHZhciB0b1N0cmluZ1RhZ1N5bWJvbCA9ICRTeW1ib2wudG9TdHJpbmdUYWcgfHwgXCJAQHRvU3RyaW5nVGFnXCI7XG5cbiAgZnVuY3Rpb24gZGVmaW5lKG9iaiwga2V5LCB2YWx1ZSkge1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwge1xuICAgICAgdmFsdWU6IHZhbHVlLFxuICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgIHdyaXRhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgcmV0dXJuIG9ialtrZXldO1xuICB9XG4gIHRyeSB7XG4gICAgLy8gSUUgOCBoYXMgYSBicm9rZW4gT2JqZWN0LmRlZmluZVByb3BlcnR5IHRoYXQgb25seSB3b3JrcyBvbiBET00gb2JqZWN0cy5cbiAgICBkZWZpbmUoe30sIFwiXCIpO1xuICB9IGNhdGNoIChlcnIpIHtcbiAgICBkZWZpbmUgPSBmdW5jdGlvbihvYmosIGtleSwgdmFsdWUpIHtcbiAgICAgIHJldHVybiBvYmpba2V5XSA9IHZhbHVlO1xuICAgIH07XG4gIH1cblxuICBmdW5jdGlvbiB3cmFwKGlubmVyRm4sIG91dGVyRm4sIHNlbGYsIHRyeUxvY3NMaXN0KSB7XG4gICAgLy8gSWYgb3V0ZXJGbiBwcm92aWRlZCBhbmQgb3V0ZXJGbi5wcm90b3R5cGUgaXMgYSBHZW5lcmF0b3IsIHRoZW4gb3V0ZXJGbi5wcm90b3R5cGUgaW5zdGFuY2VvZiBHZW5lcmF0b3IuXG4gICAgdmFyIHByb3RvR2VuZXJhdG9yID0gb3V0ZXJGbiAmJiBvdXRlckZuLnByb3RvdHlwZSBpbnN0YW5jZW9mIEdlbmVyYXRvciA/IG91dGVyRm4gOiBHZW5lcmF0b3I7XG4gICAgdmFyIGdlbmVyYXRvciA9IE9iamVjdC5jcmVhdGUocHJvdG9HZW5lcmF0b3IucHJvdG90eXBlKTtcbiAgICB2YXIgY29udGV4dCA9IG5ldyBDb250ZXh0KHRyeUxvY3NMaXN0IHx8IFtdKTtcblxuICAgIC8vIFRoZSAuX2ludm9rZSBtZXRob2QgdW5pZmllcyB0aGUgaW1wbGVtZW50YXRpb25zIG9mIHRoZSAubmV4dCxcbiAgICAvLyAudGhyb3csIGFuZCAucmV0dXJuIG1ldGhvZHMuXG4gICAgZ2VuZXJhdG9yLl9pbnZva2UgPSBtYWtlSW52b2tlTWV0aG9kKGlubmVyRm4sIHNlbGYsIGNvbnRleHQpO1xuXG4gICAgcmV0dXJuIGdlbmVyYXRvcjtcbiAgfVxuICBleHBvcnRzLndyYXAgPSB3cmFwO1xuXG4gIC8vIFRyeS9jYXRjaCBoZWxwZXIgdG8gbWluaW1pemUgZGVvcHRpbWl6YXRpb25zLiBSZXR1cm5zIGEgY29tcGxldGlvblxuICAvLyByZWNvcmQgbGlrZSBjb250ZXh0LnRyeUVudHJpZXNbaV0uY29tcGxldGlvbi4gVGhpcyBpbnRlcmZhY2UgY291bGRcbiAgLy8gaGF2ZSBiZWVuIChhbmQgd2FzIHByZXZpb3VzbHkpIGRlc2lnbmVkIHRvIHRha2UgYSBjbG9zdXJlIHRvIGJlXG4gIC8vIGludm9rZWQgd2l0aG91dCBhcmd1bWVudHMsIGJ1dCBpbiBhbGwgdGhlIGNhc2VzIHdlIGNhcmUgYWJvdXQgd2VcbiAgLy8gYWxyZWFkeSBoYXZlIGFuIGV4aXN0aW5nIG1ldGhvZCB3ZSB3YW50IHRvIGNhbGwsIHNvIHRoZXJlJ3Mgbm8gbmVlZFxuICAvLyB0byBjcmVhdGUgYSBuZXcgZnVuY3Rpb24gb2JqZWN0LiBXZSBjYW4gZXZlbiBnZXQgYXdheSB3aXRoIGFzc3VtaW5nXG4gIC8vIHRoZSBtZXRob2QgdGFrZXMgZXhhY3RseSBvbmUgYXJndW1lbnQsIHNpbmNlIHRoYXQgaGFwcGVucyB0byBiZSB0cnVlXG4gIC8vIGluIGV2ZXJ5IGNhc2UsIHNvIHdlIGRvbid0IGhhdmUgdG8gdG91Y2ggdGhlIGFyZ3VtZW50cyBvYmplY3QuIFRoZVxuICAvLyBvbmx5IGFkZGl0aW9uYWwgYWxsb2NhdGlvbiByZXF1aXJlZCBpcyB0aGUgY29tcGxldGlvbiByZWNvcmQsIHdoaWNoXG4gIC8vIGhhcyBhIHN0YWJsZSBzaGFwZSBhbmQgc28gaG9wZWZ1bGx5IHNob3VsZCBiZSBjaGVhcCB0byBhbGxvY2F0ZS5cbiAgZnVuY3Rpb24gdHJ5Q2F0Y2goZm4sIG9iaiwgYXJnKSB7XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiB7IHR5cGU6IFwibm9ybWFsXCIsIGFyZzogZm4uY2FsbChvYmosIGFyZykgfTtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIHJldHVybiB7IHR5cGU6IFwidGhyb3dcIiwgYXJnOiBlcnIgfTtcbiAgICB9XG4gIH1cblxuICB2YXIgR2VuU3RhdGVTdXNwZW5kZWRTdGFydCA9IFwic3VzcGVuZGVkU3RhcnRcIjtcbiAgdmFyIEdlblN0YXRlU3VzcGVuZGVkWWllbGQgPSBcInN1c3BlbmRlZFlpZWxkXCI7XG4gIHZhciBHZW5TdGF0ZUV4ZWN1dGluZyA9IFwiZXhlY3V0aW5nXCI7XG4gIHZhciBHZW5TdGF0ZUNvbXBsZXRlZCA9IFwiY29tcGxldGVkXCI7XG5cbiAgLy8gUmV0dXJuaW5nIHRoaXMgb2JqZWN0IGZyb20gdGhlIGlubmVyRm4gaGFzIHRoZSBzYW1lIGVmZmVjdCBhc1xuICAvLyBicmVha2luZyBvdXQgb2YgdGhlIGRpc3BhdGNoIHN3aXRjaCBzdGF0ZW1lbnQuXG4gIHZhciBDb250aW51ZVNlbnRpbmVsID0ge307XG5cbiAgLy8gRHVtbXkgY29uc3RydWN0b3IgZnVuY3Rpb25zIHRoYXQgd2UgdXNlIGFzIHRoZSAuY29uc3RydWN0b3IgYW5kXG4gIC8vIC5jb25zdHJ1Y3Rvci5wcm90b3R5cGUgcHJvcGVydGllcyBmb3IgZnVuY3Rpb25zIHRoYXQgcmV0dXJuIEdlbmVyYXRvclxuICAvLyBvYmplY3RzLiBGb3IgZnVsbCBzcGVjIGNvbXBsaWFuY2UsIHlvdSBtYXkgd2lzaCB0byBjb25maWd1cmUgeW91clxuICAvLyBtaW5pZmllciBub3QgdG8gbWFuZ2xlIHRoZSBuYW1lcyBvZiB0aGVzZSB0d28gZnVuY3Rpb25zLlxuICBmdW5jdGlvbiBHZW5lcmF0b3IoKSB7fVxuICBmdW5jdGlvbiBHZW5lcmF0b3JGdW5jdGlvbigpIHt9XG4gIGZ1bmN0aW9uIEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlKCkge31cblxuICAvLyBUaGlzIGlzIGEgcG9seWZpbGwgZm9yICVJdGVyYXRvclByb3RvdHlwZSUgZm9yIGVudmlyb25tZW50cyB0aGF0XG4gIC8vIGRvbid0IG5hdGl2ZWx5IHN1cHBvcnQgaXQuXG4gIHZhciBJdGVyYXRvclByb3RvdHlwZSA9IHt9O1xuICBJdGVyYXRvclByb3RvdHlwZVtpdGVyYXRvclN5bWJvbF0gPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgdmFyIGdldFByb3RvID0gT2JqZWN0LmdldFByb3RvdHlwZU9mO1xuICB2YXIgTmF0aXZlSXRlcmF0b3JQcm90b3R5cGUgPSBnZXRQcm90byAmJiBnZXRQcm90byhnZXRQcm90byh2YWx1ZXMoW10pKSk7XG4gIGlmIChOYXRpdmVJdGVyYXRvclByb3RvdHlwZSAmJlxuICAgICAgTmF0aXZlSXRlcmF0b3JQcm90b3R5cGUgIT09IE9wICYmXG4gICAgICBoYXNPd24uY2FsbChOYXRpdmVJdGVyYXRvclByb3RvdHlwZSwgaXRlcmF0b3JTeW1ib2wpKSB7XG4gICAgLy8gVGhpcyBlbnZpcm9ubWVudCBoYXMgYSBuYXRpdmUgJUl0ZXJhdG9yUHJvdG90eXBlJTsgdXNlIGl0IGluc3RlYWRcbiAgICAvLyBvZiB0aGUgcG9seWZpbGwuXG4gICAgSXRlcmF0b3JQcm90b3R5cGUgPSBOYXRpdmVJdGVyYXRvclByb3RvdHlwZTtcbiAgfVxuXG4gIHZhciBHcCA9IEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlLnByb3RvdHlwZSA9XG4gICAgR2VuZXJhdG9yLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoSXRlcmF0b3JQcm90b3R5cGUpO1xuICBHZW5lcmF0b3JGdW5jdGlvbi5wcm90b3R5cGUgPSBHcC5jb25zdHJ1Y3RvciA9IEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlO1xuICBHZW5lcmF0b3JGdW5jdGlvblByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IEdlbmVyYXRvckZ1bmN0aW9uO1xuICBHZW5lcmF0b3JGdW5jdGlvbi5kaXNwbGF5TmFtZSA9IGRlZmluZShcbiAgICBHZW5lcmF0b3JGdW5jdGlvblByb3RvdHlwZSxcbiAgICB0b1N0cmluZ1RhZ1N5bWJvbCxcbiAgICBcIkdlbmVyYXRvckZ1bmN0aW9uXCJcbiAgKTtcblxuICAvLyBIZWxwZXIgZm9yIGRlZmluaW5nIHRoZSAubmV4dCwgLnRocm93LCBhbmQgLnJldHVybiBtZXRob2RzIG9mIHRoZVxuICAvLyBJdGVyYXRvciBpbnRlcmZhY2UgaW4gdGVybXMgb2YgYSBzaW5nbGUgLl9pbnZva2UgbWV0aG9kLlxuICBmdW5jdGlvbiBkZWZpbmVJdGVyYXRvck1ldGhvZHMocHJvdG90eXBlKSB7XG4gICAgW1wibmV4dFwiLCBcInRocm93XCIsIFwicmV0dXJuXCJdLmZvckVhY2goZnVuY3Rpb24obWV0aG9kKSB7XG4gICAgICBkZWZpbmUocHJvdG90eXBlLCBtZXRob2QsIGZ1bmN0aW9uKGFyZykge1xuICAgICAgICByZXR1cm4gdGhpcy5faW52b2tlKG1ldGhvZCwgYXJnKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG5cbiAgZXhwb3J0cy5pc0dlbmVyYXRvckZ1bmN0aW9uID0gZnVuY3Rpb24oZ2VuRnVuKSB7XG4gICAgdmFyIGN0b3IgPSB0eXBlb2YgZ2VuRnVuID09PSBcImZ1bmN0aW9uXCIgJiYgZ2VuRnVuLmNvbnN0cnVjdG9yO1xuICAgIHJldHVybiBjdG9yXG4gICAgICA/IGN0b3IgPT09IEdlbmVyYXRvckZ1bmN0aW9uIHx8XG4gICAgICAgIC8vIEZvciB0aGUgbmF0aXZlIEdlbmVyYXRvckZ1bmN0aW9uIGNvbnN0cnVjdG9yLCB0aGUgYmVzdCB3ZSBjYW5cbiAgICAgICAgLy8gZG8gaXMgdG8gY2hlY2sgaXRzIC5uYW1lIHByb3BlcnR5LlxuICAgICAgICAoY3Rvci5kaXNwbGF5TmFtZSB8fCBjdG9yLm5hbWUpID09PSBcIkdlbmVyYXRvckZ1bmN0aW9uXCJcbiAgICAgIDogZmFsc2U7XG4gIH07XG5cbiAgZXhwb3J0cy5tYXJrID0gZnVuY3Rpb24oZ2VuRnVuKSB7XG4gICAgaWYgKE9iamVjdC5zZXRQcm90b3R5cGVPZikge1xuICAgICAgT2JqZWN0LnNldFByb3RvdHlwZU9mKGdlbkZ1biwgR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGUpO1xuICAgIH0gZWxzZSB7XG4gICAgICBnZW5GdW4uX19wcm90b19fID0gR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGU7XG4gICAgICBkZWZpbmUoZ2VuRnVuLCB0b1N0cmluZ1RhZ1N5bWJvbCwgXCJHZW5lcmF0b3JGdW5jdGlvblwiKTtcbiAgICB9XG4gICAgZ2VuRnVuLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoR3ApO1xuICAgIHJldHVybiBnZW5GdW47XG4gIH07XG5cbiAgLy8gV2l0aGluIHRoZSBib2R5IG9mIGFueSBhc3luYyBmdW5jdGlvbiwgYGF3YWl0IHhgIGlzIHRyYW5zZm9ybWVkIHRvXG4gIC8vIGB5aWVsZCByZWdlbmVyYXRvclJ1bnRpbWUuYXdyYXAoeClgLCBzbyB0aGF0IHRoZSBydW50aW1lIGNhbiB0ZXN0XG4gIC8vIGBoYXNPd24uY2FsbCh2YWx1ZSwgXCJfX2F3YWl0XCIpYCB0byBkZXRlcm1pbmUgaWYgdGhlIHlpZWxkZWQgdmFsdWUgaXNcbiAgLy8gbWVhbnQgdG8gYmUgYXdhaXRlZC5cbiAgZXhwb3J0cy5hd3JhcCA9IGZ1bmN0aW9uKGFyZykge1xuICAgIHJldHVybiB7IF9fYXdhaXQ6IGFyZyB9O1xuICB9O1xuXG4gIGZ1bmN0aW9uIEFzeW5jSXRlcmF0b3IoZ2VuZXJhdG9yLCBQcm9taXNlSW1wbCkge1xuICAgIGZ1bmN0aW9uIGludm9rZShtZXRob2QsIGFyZywgcmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICB2YXIgcmVjb3JkID0gdHJ5Q2F0Y2goZ2VuZXJhdG9yW21ldGhvZF0sIGdlbmVyYXRvciwgYXJnKTtcbiAgICAgIGlmIChyZWNvcmQudHlwZSA9PT0gXCJ0aHJvd1wiKSB7XG4gICAgICAgIHJlamVjdChyZWNvcmQuYXJnKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciByZXN1bHQgPSByZWNvcmQuYXJnO1xuICAgICAgICB2YXIgdmFsdWUgPSByZXN1bHQudmFsdWU7XG4gICAgICAgIGlmICh2YWx1ZSAmJlxuICAgICAgICAgICAgdHlwZW9mIHZhbHVlID09PSBcIm9iamVjdFwiICYmXG4gICAgICAgICAgICBoYXNPd24uY2FsbCh2YWx1ZSwgXCJfX2F3YWl0XCIpKSB7XG4gICAgICAgICAgcmV0dXJuIFByb21pc2VJbXBsLnJlc29sdmUodmFsdWUuX19hd2FpdCkudGhlbihmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICAgICAgaW52b2tlKFwibmV4dFwiLCB2YWx1ZSwgcmVzb2x2ZSwgcmVqZWN0KTtcbiAgICAgICAgICB9LCBmdW5jdGlvbihlcnIpIHtcbiAgICAgICAgICAgIGludm9rZShcInRocm93XCIsIGVyciwgcmVzb2x2ZSwgcmVqZWN0KTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBQcm9taXNlSW1wbC5yZXNvbHZlKHZhbHVlKS50aGVuKGZ1bmN0aW9uKHVud3JhcHBlZCkge1xuICAgICAgICAgIC8vIFdoZW4gYSB5aWVsZGVkIFByb21pc2UgaXMgcmVzb2x2ZWQsIGl0cyBmaW5hbCB2YWx1ZSBiZWNvbWVzXG4gICAgICAgICAgLy8gdGhlIC52YWx1ZSBvZiB0aGUgUHJvbWlzZTx7dmFsdWUsZG9uZX0+IHJlc3VsdCBmb3IgdGhlXG4gICAgICAgICAgLy8gY3VycmVudCBpdGVyYXRpb24uXG4gICAgICAgICAgcmVzdWx0LnZhbHVlID0gdW53cmFwcGVkO1xuICAgICAgICAgIHJlc29sdmUocmVzdWx0KTtcbiAgICAgICAgfSwgZnVuY3Rpb24oZXJyb3IpIHtcbiAgICAgICAgICAvLyBJZiBhIHJlamVjdGVkIFByb21pc2Ugd2FzIHlpZWxkZWQsIHRocm93IHRoZSByZWplY3Rpb24gYmFja1xuICAgICAgICAgIC8vIGludG8gdGhlIGFzeW5jIGdlbmVyYXRvciBmdW5jdGlvbiBzbyBpdCBjYW4gYmUgaGFuZGxlZCB0aGVyZS5cbiAgICAgICAgICByZXR1cm4gaW52b2tlKFwidGhyb3dcIiwgZXJyb3IsIHJlc29sdmUsIHJlamVjdCk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBwcmV2aW91c1Byb21pc2U7XG5cbiAgICBmdW5jdGlvbiBlbnF1ZXVlKG1ldGhvZCwgYXJnKSB7XG4gICAgICBmdW5jdGlvbiBjYWxsSW52b2tlV2l0aE1ldGhvZEFuZEFyZygpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlSW1wbChmdW5jdGlvbihyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgICBpbnZva2UobWV0aG9kLCBhcmcsIHJlc29sdmUsIHJlamVjdCk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gcHJldmlvdXNQcm9taXNlID1cbiAgICAgICAgLy8gSWYgZW5xdWV1ZSBoYXMgYmVlbiBjYWxsZWQgYmVmb3JlLCB0aGVuIHdlIHdhbnQgdG8gd2FpdCB1bnRpbFxuICAgICAgICAvLyBhbGwgcHJldmlvdXMgUHJvbWlzZXMgaGF2ZSBiZWVuIHJlc29sdmVkIGJlZm9yZSBjYWxsaW5nIGludm9rZSxcbiAgICAgICAgLy8gc28gdGhhdCByZXN1bHRzIGFyZSBhbHdheXMgZGVsaXZlcmVkIGluIHRoZSBjb3JyZWN0IG9yZGVyLiBJZlxuICAgICAgICAvLyBlbnF1ZXVlIGhhcyBub3QgYmVlbiBjYWxsZWQgYmVmb3JlLCB0aGVuIGl0IGlzIGltcG9ydGFudCB0b1xuICAgICAgICAvLyBjYWxsIGludm9rZSBpbW1lZGlhdGVseSwgd2l0aG91dCB3YWl0aW5nIG9uIGEgY2FsbGJhY2sgdG8gZmlyZSxcbiAgICAgICAgLy8gc28gdGhhdCB0aGUgYXN5bmMgZ2VuZXJhdG9yIGZ1bmN0aW9uIGhhcyB0aGUgb3Bwb3J0dW5pdHkgdG8gZG9cbiAgICAgICAgLy8gYW55IG5lY2Vzc2FyeSBzZXR1cCBpbiBhIHByZWRpY3RhYmxlIHdheS4gVGhpcyBwcmVkaWN0YWJpbGl0eVxuICAgICAgICAvLyBpcyB3aHkgdGhlIFByb21pc2UgY29uc3RydWN0b3Igc3luY2hyb25vdXNseSBpbnZva2VzIGl0c1xuICAgICAgICAvLyBleGVjdXRvciBjYWxsYmFjaywgYW5kIHdoeSBhc3luYyBmdW5jdGlvbnMgc3luY2hyb25vdXNseVxuICAgICAgICAvLyBleGVjdXRlIGNvZGUgYmVmb3JlIHRoZSBmaXJzdCBhd2FpdC4gU2luY2Ugd2UgaW1wbGVtZW50IHNpbXBsZVxuICAgICAgICAvLyBhc3luYyBmdW5jdGlvbnMgaW4gdGVybXMgb2YgYXN5bmMgZ2VuZXJhdG9ycywgaXQgaXMgZXNwZWNpYWxseVxuICAgICAgICAvLyBpbXBvcnRhbnQgdG8gZ2V0IHRoaXMgcmlnaHQsIGV2ZW4gdGhvdWdoIGl0IHJlcXVpcmVzIGNhcmUuXG4gICAgICAgIHByZXZpb3VzUHJvbWlzZSA/IHByZXZpb3VzUHJvbWlzZS50aGVuKFxuICAgICAgICAgIGNhbGxJbnZva2VXaXRoTWV0aG9kQW5kQXJnLFxuICAgICAgICAgIC8vIEF2b2lkIHByb3BhZ2F0aW5nIGZhaWx1cmVzIHRvIFByb21pc2VzIHJldHVybmVkIGJ5IGxhdGVyXG4gICAgICAgICAgLy8gaW52b2NhdGlvbnMgb2YgdGhlIGl0ZXJhdG9yLlxuICAgICAgICAgIGNhbGxJbnZva2VXaXRoTWV0aG9kQW5kQXJnXG4gICAgICAgICkgOiBjYWxsSW52b2tlV2l0aE1ldGhvZEFuZEFyZygpO1xuICAgIH1cblxuICAgIC8vIERlZmluZSB0aGUgdW5pZmllZCBoZWxwZXIgbWV0aG9kIHRoYXQgaXMgdXNlZCB0byBpbXBsZW1lbnQgLm5leHQsXG4gICAgLy8gLnRocm93LCBhbmQgLnJldHVybiAoc2VlIGRlZmluZUl0ZXJhdG9yTWV0aG9kcykuXG4gICAgdGhpcy5faW52b2tlID0gZW5xdWV1ZTtcbiAgfVxuXG4gIGRlZmluZUl0ZXJhdG9yTWV0aG9kcyhBc3luY0l0ZXJhdG9yLnByb3RvdHlwZSk7XG4gIEFzeW5jSXRlcmF0b3IucHJvdG90eXBlW2FzeW5jSXRlcmF0b3JTeW1ib2xdID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzO1xuICB9O1xuICBleHBvcnRzLkFzeW5jSXRlcmF0b3IgPSBBc3luY0l0ZXJhdG9yO1xuXG4gIC8vIE5vdGUgdGhhdCBzaW1wbGUgYXN5bmMgZnVuY3Rpb25zIGFyZSBpbXBsZW1lbnRlZCBvbiB0b3Agb2ZcbiAgLy8gQXN5bmNJdGVyYXRvciBvYmplY3RzOyB0aGV5IGp1c3QgcmV0dXJuIGEgUHJvbWlzZSBmb3IgdGhlIHZhbHVlIG9mXG4gIC8vIHRoZSBmaW5hbCByZXN1bHQgcHJvZHVjZWQgYnkgdGhlIGl0ZXJhdG9yLlxuICBleHBvcnRzLmFzeW5jID0gZnVuY3Rpb24oaW5uZXJGbiwgb3V0ZXJGbiwgc2VsZiwgdHJ5TG9jc0xpc3QsIFByb21pc2VJbXBsKSB7XG4gICAgaWYgKFByb21pc2VJbXBsID09PSB2b2lkIDApIFByb21pc2VJbXBsID0gUHJvbWlzZTtcblxuICAgIHZhciBpdGVyID0gbmV3IEFzeW5jSXRlcmF0b3IoXG4gICAgICB3cmFwKGlubmVyRm4sIG91dGVyRm4sIHNlbGYsIHRyeUxvY3NMaXN0KSxcbiAgICAgIFByb21pc2VJbXBsXG4gICAgKTtcblxuICAgIHJldHVybiBleHBvcnRzLmlzR2VuZXJhdG9yRnVuY3Rpb24ob3V0ZXJGbilcbiAgICAgID8gaXRlciAvLyBJZiBvdXRlckZuIGlzIGEgZ2VuZXJhdG9yLCByZXR1cm4gdGhlIGZ1bGwgaXRlcmF0b3IuXG4gICAgICA6IGl0ZXIubmV4dCgpLnRoZW4oZnVuY3Rpb24ocmVzdWx0KSB7XG4gICAgICAgICAgcmV0dXJuIHJlc3VsdC5kb25lID8gcmVzdWx0LnZhbHVlIDogaXRlci5uZXh0KCk7XG4gICAgICAgIH0pO1xuICB9O1xuXG4gIGZ1bmN0aW9uIG1ha2VJbnZva2VNZXRob2QoaW5uZXJGbiwgc2VsZiwgY29udGV4dCkge1xuICAgIHZhciBzdGF0ZSA9IEdlblN0YXRlU3VzcGVuZGVkU3RhcnQ7XG5cbiAgICByZXR1cm4gZnVuY3Rpb24gaW52b2tlKG1ldGhvZCwgYXJnKSB7XG4gICAgICBpZiAoc3RhdGUgPT09IEdlblN0YXRlRXhlY3V0aW5nKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkdlbmVyYXRvciBpcyBhbHJlYWR5IHJ1bm5pbmdcIik7XG4gICAgICB9XG5cbiAgICAgIGlmIChzdGF0ZSA9PT0gR2VuU3RhdGVDb21wbGV0ZWQpIHtcbiAgICAgICAgaWYgKG1ldGhvZCA9PT0gXCJ0aHJvd1wiKSB7XG4gICAgICAgICAgdGhyb3cgYXJnO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gQmUgZm9yZ2l2aW5nLCBwZXIgMjUuMy4zLjMuMyBvZiB0aGUgc3BlYzpcbiAgICAgICAgLy8gaHR0cHM6Ly9wZW9wbGUubW96aWxsYS5vcmcvfmpvcmVuZG9yZmYvZXM2LWRyYWZ0Lmh0bWwjc2VjLWdlbmVyYXRvcnJlc3VtZVxuICAgICAgICByZXR1cm4gZG9uZVJlc3VsdCgpO1xuICAgICAgfVxuXG4gICAgICBjb250ZXh0Lm1ldGhvZCA9IG1ldGhvZDtcbiAgICAgIGNvbnRleHQuYXJnID0gYXJnO1xuXG4gICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICB2YXIgZGVsZWdhdGUgPSBjb250ZXh0LmRlbGVnYXRlO1xuICAgICAgICBpZiAoZGVsZWdhdGUpIHtcbiAgICAgICAgICB2YXIgZGVsZWdhdGVSZXN1bHQgPSBtYXliZUludm9rZURlbGVnYXRlKGRlbGVnYXRlLCBjb250ZXh0KTtcbiAgICAgICAgICBpZiAoZGVsZWdhdGVSZXN1bHQpIHtcbiAgICAgICAgICAgIGlmIChkZWxlZ2F0ZVJlc3VsdCA9PT0gQ29udGludWVTZW50aW5lbCkgY29udGludWU7XG4gICAgICAgICAgICByZXR1cm4gZGVsZWdhdGVSZXN1bHQ7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGNvbnRleHQubWV0aG9kID09PSBcIm5leHRcIikge1xuICAgICAgICAgIC8vIFNldHRpbmcgY29udGV4dC5fc2VudCBmb3IgbGVnYWN5IHN1cHBvcnQgb2YgQmFiZWwnc1xuICAgICAgICAgIC8vIGZ1bmN0aW9uLnNlbnQgaW1wbGVtZW50YXRpb24uXG4gICAgICAgICAgY29udGV4dC5zZW50ID0gY29udGV4dC5fc2VudCA9IGNvbnRleHQuYXJnO1xuXG4gICAgICAgIH0gZWxzZSBpZiAoY29udGV4dC5tZXRob2QgPT09IFwidGhyb3dcIikge1xuICAgICAgICAgIGlmIChzdGF0ZSA9PT0gR2VuU3RhdGVTdXNwZW5kZWRTdGFydCkge1xuICAgICAgICAgICAgc3RhdGUgPSBHZW5TdGF0ZUNvbXBsZXRlZDtcbiAgICAgICAgICAgIHRocm93IGNvbnRleHQuYXJnO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGNvbnRleHQuZGlzcGF0Y2hFeGNlcHRpb24oY29udGV4dC5hcmcpO1xuXG4gICAgICAgIH0gZWxzZSBpZiAoY29udGV4dC5tZXRob2QgPT09IFwicmV0dXJuXCIpIHtcbiAgICAgICAgICBjb250ZXh0LmFicnVwdChcInJldHVyblwiLCBjb250ZXh0LmFyZyk7XG4gICAgICAgIH1cblxuICAgICAgICBzdGF0ZSA9IEdlblN0YXRlRXhlY3V0aW5nO1xuXG4gICAgICAgIHZhciByZWNvcmQgPSB0cnlDYXRjaChpbm5lckZuLCBzZWxmLCBjb250ZXh0KTtcbiAgICAgICAgaWYgKHJlY29yZC50eXBlID09PSBcIm5vcm1hbFwiKSB7XG4gICAgICAgICAgLy8gSWYgYW4gZXhjZXB0aW9uIGlzIHRocm93biBmcm9tIGlubmVyRm4sIHdlIGxlYXZlIHN0YXRlID09PVxuICAgICAgICAgIC8vIEdlblN0YXRlRXhlY3V0aW5nIGFuZCBsb29wIGJhY2sgZm9yIGFub3RoZXIgaW52b2NhdGlvbi5cbiAgICAgICAgICBzdGF0ZSA9IGNvbnRleHQuZG9uZVxuICAgICAgICAgICAgPyBHZW5TdGF0ZUNvbXBsZXRlZFxuICAgICAgICAgICAgOiBHZW5TdGF0ZVN1c3BlbmRlZFlpZWxkO1xuXG4gICAgICAgICAgaWYgKHJlY29yZC5hcmcgPT09IENvbnRpbnVlU2VudGluZWwpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB2YWx1ZTogcmVjb3JkLmFyZyxcbiAgICAgICAgICAgIGRvbmU6IGNvbnRleHQuZG9uZVxuICAgICAgICAgIH07XG5cbiAgICAgICAgfSBlbHNlIGlmIChyZWNvcmQudHlwZSA9PT0gXCJ0aHJvd1wiKSB7XG4gICAgICAgICAgc3RhdGUgPSBHZW5TdGF0ZUNvbXBsZXRlZDtcbiAgICAgICAgICAvLyBEaXNwYXRjaCB0aGUgZXhjZXB0aW9uIGJ5IGxvb3BpbmcgYmFjayBhcm91bmQgdG8gdGhlXG4gICAgICAgICAgLy8gY29udGV4dC5kaXNwYXRjaEV4Y2VwdGlvbihjb250ZXh0LmFyZykgY2FsbCBhYm92ZS5cbiAgICAgICAgICBjb250ZXh0Lm1ldGhvZCA9IFwidGhyb3dcIjtcbiAgICAgICAgICBjb250ZXh0LmFyZyA9IHJlY29yZC5hcmc7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuICB9XG5cbiAgLy8gQ2FsbCBkZWxlZ2F0ZS5pdGVyYXRvcltjb250ZXh0Lm1ldGhvZF0oY29udGV4dC5hcmcpIGFuZCBoYW5kbGUgdGhlXG4gIC8vIHJlc3VsdCwgZWl0aGVyIGJ5IHJldHVybmluZyBhIHsgdmFsdWUsIGRvbmUgfSByZXN1bHQgZnJvbSB0aGVcbiAgLy8gZGVsZWdhdGUgaXRlcmF0b3IsIG9yIGJ5IG1vZGlmeWluZyBjb250ZXh0Lm1ldGhvZCBhbmQgY29udGV4dC5hcmcsXG4gIC8vIHNldHRpbmcgY29udGV4dC5kZWxlZ2F0ZSB0byBudWxsLCBhbmQgcmV0dXJuaW5nIHRoZSBDb250aW51ZVNlbnRpbmVsLlxuICBmdW5jdGlvbiBtYXliZUludm9rZURlbGVnYXRlKGRlbGVnYXRlLCBjb250ZXh0KSB7XG4gICAgdmFyIG1ldGhvZCA9IGRlbGVnYXRlLml0ZXJhdG9yW2NvbnRleHQubWV0aG9kXTtcbiAgICBpZiAobWV0aG9kID09PSB1bmRlZmluZWQpIHtcbiAgICAgIC8vIEEgLnRocm93IG9yIC5yZXR1cm4gd2hlbiB0aGUgZGVsZWdhdGUgaXRlcmF0b3IgaGFzIG5vIC50aHJvd1xuICAgICAgLy8gbWV0aG9kIGFsd2F5cyB0ZXJtaW5hdGVzIHRoZSB5aWVsZCogbG9vcC5cbiAgICAgIGNvbnRleHQuZGVsZWdhdGUgPSBudWxsO1xuXG4gICAgICBpZiAoY29udGV4dC5tZXRob2QgPT09IFwidGhyb3dcIikge1xuICAgICAgICAvLyBOb3RlOiBbXCJyZXR1cm5cIl0gbXVzdCBiZSB1c2VkIGZvciBFUzMgcGFyc2luZyBjb21wYXRpYmlsaXR5LlxuICAgICAgICBpZiAoZGVsZWdhdGUuaXRlcmF0b3JbXCJyZXR1cm5cIl0pIHtcbiAgICAgICAgICAvLyBJZiB0aGUgZGVsZWdhdGUgaXRlcmF0b3IgaGFzIGEgcmV0dXJuIG1ldGhvZCwgZ2l2ZSBpdCBhXG4gICAgICAgICAgLy8gY2hhbmNlIHRvIGNsZWFuIHVwLlxuICAgICAgICAgIGNvbnRleHQubWV0aG9kID0gXCJyZXR1cm5cIjtcbiAgICAgICAgICBjb250ZXh0LmFyZyA9IHVuZGVmaW5lZDtcbiAgICAgICAgICBtYXliZUludm9rZURlbGVnYXRlKGRlbGVnYXRlLCBjb250ZXh0KTtcblxuICAgICAgICAgIGlmIChjb250ZXh0Lm1ldGhvZCA9PT0gXCJ0aHJvd1wiKSB7XG4gICAgICAgICAgICAvLyBJZiBtYXliZUludm9rZURlbGVnYXRlKGNvbnRleHQpIGNoYW5nZWQgY29udGV4dC5tZXRob2QgZnJvbVxuICAgICAgICAgICAgLy8gXCJyZXR1cm5cIiB0byBcInRocm93XCIsIGxldCB0aGF0IG92ZXJyaWRlIHRoZSBUeXBlRXJyb3IgYmVsb3cuXG4gICAgICAgICAgICByZXR1cm4gQ29udGludWVTZW50aW5lbDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBjb250ZXh0Lm1ldGhvZCA9IFwidGhyb3dcIjtcbiAgICAgICAgY29udGV4dC5hcmcgPSBuZXcgVHlwZUVycm9yKFxuICAgICAgICAgIFwiVGhlIGl0ZXJhdG9yIGRvZXMgbm90IHByb3ZpZGUgYSAndGhyb3cnIG1ldGhvZFwiKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIENvbnRpbnVlU2VudGluZWw7XG4gICAgfVxuXG4gICAgdmFyIHJlY29yZCA9IHRyeUNhdGNoKG1ldGhvZCwgZGVsZWdhdGUuaXRlcmF0b3IsIGNvbnRleHQuYXJnKTtcblxuICAgIGlmIChyZWNvcmQudHlwZSA9PT0gXCJ0aHJvd1wiKSB7XG4gICAgICBjb250ZXh0Lm1ldGhvZCA9IFwidGhyb3dcIjtcbiAgICAgIGNvbnRleHQuYXJnID0gcmVjb3JkLmFyZztcbiAgICAgIGNvbnRleHQuZGVsZWdhdGUgPSBudWxsO1xuICAgICAgcmV0dXJuIENvbnRpbnVlU2VudGluZWw7XG4gICAgfVxuXG4gICAgdmFyIGluZm8gPSByZWNvcmQuYXJnO1xuXG4gICAgaWYgKCEgaW5mbykge1xuICAgICAgY29udGV4dC5tZXRob2QgPSBcInRocm93XCI7XG4gICAgICBjb250ZXh0LmFyZyA9IG5ldyBUeXBlRXJyb3IoXCJpdGVyYXRvciByZXN1bHQgaXMgbm90IGFuIG9iamVjdFwiKTtcbiAgICAgIGNvbnRleHQuZGVsZWdhdGUgPSBudWxsO1xuICAgICAgcmV0dXJuIENvbnRpbnVlU2VudGluZWw7XG4gICAgfVxuXG4gICAgaWYgKGluZm8uZG9uZSkge1xuICAgICAgLy8gQXNzaWduIHRoZSByZXN1bHQgb2YgdGhlIGZpbmlzaGVkIGRlbGVnYXRlIHRvIHRoZSB0ZW1wb3JhcnlcbiAgICAgIC8vIHZhcmlhYmxlIHNwZWNpZmllZCBieSBkZWxlZ2F0ZS5yZXN1bHROYW1lIChzZWUgZGVsZWdhdGVZaWVsZCkuXG4gICAgICBjb250ZXh0W2RlbGVnYXRlLnJlc3VsdE5hbWVdID0gaW5mby52YWx1ZTtcblxuICAgICAgLy8gUmVzdW1lIGV4ZWN1dGlvbiBhdCB0aGUgZGVzaXJlZCBsb2NhdGlvbiAoc2VlIGRlbGVnYXRlWWllbGQpLlxuICAgICAgY29udGV4dC5uZXh0ID0gZGVsZWdhdGUubmV4dExvYztcblxuICAgICAgLy8gSWYgY29udGV4dC5tZXRob2Qgd2FzIFwidGhyb3dcIiBidXQgdGhlIGRlbGVnYXRlIGhhbmRsZWQgdGhlXG4gICAgICAvLyBleGNlcHRpb24sIGxldCB0aGUgb3V0ZXIgZ2VuZXJhdG9yIHByb2NlZWQgbm9ybWFsbHkuIElmXG4gICAgICAvLyBjb250ZXh0Lm1ldGhvZCB3YXMgXCJuZXh0XCIsIGZvcmdldCBjb250ZXh0LmFyZyBzaW5jZSBpdCBoYXMgYmVlblxuICAgICAgLy8gXCJjb25zdW1lZFwiIGJ5IHRoZSBkZWxlZ2F0ZSBpdGVyYXRvci4gSWYgY29udGV4dC5tZXRob2Qgd2FzXG4gICAgICAvLyBcInJldHVyblwiLCBhbGxvdyB0aGUgb3JpZ2luYWwgLnJldHVybiBjYWxsIHRvIGNvbnRpbnVlIGluIHRoZVxuICAgICAgLy8gb3V0ZXIgZ2VuZXJhdG9yLlxuICAgICAgaWYgKGNvbnRleHQubWV0aG9kICE9PSBcInJldHVyblwiKSB7XG4gICAgICAgIGNvbnRleHQubWV0aG9kID0gXCJuZXh0XCI7XG4gICAgICAgIGNvbnRleHQuYXJnID0gdW5kZWZpbmVkO1xuICAgICAgfVxuXG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFJlLXlpZWxkIHRoZSByZXN1bHQgcmV0dXJuZWQgYnkgdGhlIGRlbGVnYXRlIG1ldGhvZC5cbiAgICAgIHJldHVybiBpbmZvO1xuICAgIH1cblxuICAgIC8vIFRoZSBkZWxlZ2F0ZSBpdGVyYXRvciBpcyBmaW5pc2hlZCwgc28gZm9yZ2V0IGl0IGFuZCBjb250aW51ZSB3aXRoXG4gICAgLy8gdGhlIG91dGVyIGdlbmVyYXRvci5cbiAgICBjb250ZXh0LmRlbGVnYXRlID0gbnVsbDtcbiAgICByZXR1cm4gQ29udGludWVTZW50aW5lbDtcbiAgfVxuXG4gIC8vIERlZmluZSBHZW5lcmF0b3IucHJvdG90eXBlLntuZXh0LHRocm93LHJldHVybn0gaW4gdGVybXMgb2YgdGhlXG4gIC8vIHVuaWZpZWQgLl9pbnZva2UgaGVscGVyIG1ldGhvZC5cbiAgZGVmaW5lSXRlcmF0b3JNZXRob2RzKEdwKTtcblxuICBkZWZpbmUoR3AsIHRvU3RyaW5nVGFnU3ltYm9sLCBcIkdlbmVyYXRvclwiKTtcblxuICAvLyBBIEdlbmVyYXRvciBzaG91bGQgYWx3YXlzIHJldHVybiBpdHNlbGYgYXMgdGhlIGl0ZXJhdG9yIG9iamVjdCB3aGVuIHRoZVxuICAvLyBAQGl0ZXJhdG9yIGZ1bmN0aW9uIGlzIGNhbGxlZCBvbiBpdC4gU29tZSBicm93c2VycycgaW1wbGVtZW50YXRpb25zIG9mIHRoZVxuICAvLyBpdGVyYXRvciBwcm90b3R5cGUgY2hhaW4gaW5jb3JyZWN0bHkgaW1wbGVtZW50IHRoaXMsIGNhdXNpbmcgdGhlIEdlbmVyYXRvclxuICAvLyBvYmplY3QgdG8gbm90IGJlIHJldHVybmVkIGZyb20gdGhpcyBjYWxsLiBUaGlzIGVuc3VyZXMgdGhhdCBkb2Vzbid0IGhhcHBlbi5cbiAgLy8gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWdlbmVyYXRvci9pc3N1ZXMvMjc0IGZvciBtb3JlIGRldGFpbHMuXG4gIEdwW2l0ZXJhdG9yU3ltYm9sXSA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIEdwLnRvU3RyaW5nID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIFwiW29iamVjdCBHZW5lcmF0b3JdXCI7XG4gIH07XG5cbiAgZnVuY3Rpb24gcHVzaFRyeUVudHJ5KGxvY3MpIHtcbiAgICB2YXIgZW50cnkgPSB7IHRyeUxvYzogbG9jc1swXSB9O1xuXG4gICAgaWYgKDEgaW4gbG9jcykge1xuICAgICAgZW50cnkuY2F0Y2hMb2MgPSBsb2NzWzFdO1xuICAgIH1cblxuICAgIGlmICgyIGluIGxvY3MpIHtcbiAgICAgIGVudHJ5LmZpbmFsbHlMb2MgPSBsb2NzWzJdO1xuICAgICAgZW50cnkuYWZ0ZXJMb2MgPSBsb2NzWzNdO1xuICAgIH1cblxuICAgIHRoaXMudHJ5RW50cmllcy5wdXNoKGVudHJ5KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHJlc2V0VHJ5RW50cnkoZW50cnkpIHtcbiAgICB2YXIgcmVjb3JkID0gZW50cnkuY29tcGxldGlvbiB8fCB7fTtcbiAgICByZWNvcmQudHlwZSA9IFwibm9ybWFsXCI7XG4gICAgZGVsZXRlIHJlY29yZC5hcmc7XG4gICAgZW50cnkuY29tcGxldGlvbiA9IHJlY29yZDtcbiAgfVxuXG4gIGZ1bmN0aW9uIENvbnRleHQodHJ5TG9jc0xpc3QpIHtcbiAgICAvLyBUaGUgcm9vdCBlbnRyeSBvYmplY3QgKGVmZmVjdGl2ZWx5IGEgdHJ5IHN0YXRlbWVudCB3aXRob3V0IGEgY2F0Y2hcbiAgICAvLyBvciBhIGZpbmFsbHkgYmxvY2spIGdpdmVzIHVzIGEgcGxhY2UgdG8gc3RvcmUgdmFsdWVzIHRocm93biBmcm9tXG4gICAgLy8gbG9jYXRpb25zIHdoZXJlIHRoZXJlIGlzIG5vIGVuY2xvc2luZyB0cnkgc3RhdGVtZW50LlxuICAgIHRoaXMudHJ5RW50cmllcyA9IFt7IHRyeUxvYzogXCJyb290XCIgfV07XG4gICAgdHJ5TG9jc0xpc3QuZm9yRWFjaChwdXNoVHJ5RW50cnksIHRoaXMpO1xuICAgIHRoaXMucmVzZXQodHJ1ZSk7XG4gIH1cblxuICBleHBvcnRzLmtleXMgPSBmdW5jdGlvbihvYmplY3QpIHtcbiAgICB2YXIga2V5cyA9IFtdO1xuICAgIGZvciAodmFyIGtleSBpbiBvYmplY3QpIHtcbiAgICAgIGtleXMucHVzaChrZXkpO1xuICAgIH1cbiAgICBrZXlzLnJldmVyc2UoKTtcblxuICAgIC8vIFJhdGhlciB0aGFuIHJldHVybmluZyBhbiBvYmplY3Qgd2l0aCBhIG5leHQgbWV0aG9kLCB3ZSBrZWVwXG4gICAgLy8gdGhpbmdzIHNpbXBsZSBhbmQgcmV0dXJuIHRoZSBuZXh0IGZ1bmN0aW9uIGl0c2VsZi5cbiAgICByZXR1cm4gZnVuY3Rpb24gbmV4dCgpIHtcbiAgICAgIHdoaWxlIChrZXlzLmxlbmd0aCkge1xuICAgICAgICB2YXIga2V5ID0ga2V5cy5wb3AoKTtcbiAgICAgICAgaWYgKGtleSBpbiBvYmplY3QpIHtcbiAgICAgICAgICBuZXh0LnZhbHVlID0ga2V5O1xuICAgICAgICAgIG5leHQuZG9uZSA9IGZhbHNlO1xuICAgICAgICAgIHJldHVybiBuZXh0O1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIFRvIGF2b2lkIGNyZWF0aW5nIGFuIGFkZGl0aW9uYWwgb2JqZWN0LCB3ZSBqdXN0IGhhbmcgdGhlIC52YWx1ZVxuICAgICAgLy8gYW5kIC5kb25lIHByb3BlcnRpZXMgb2ZmIHRoZSBuZXh0IGZ1bmN0aW9uIG9iamVjdCBpdHNlbGYuIFRoaXNcbiAgICAgIC8vIGFsc28gZW5zdXJlcyB0aGF0IHRoZSBtaW5pZmllciB3aWxsIG5vdCBhbm9ueW1pemUgdGhlIGZ1bmN0aW9uLlxuICAgICAgbmV4dC5kb25lID0gdHJ1ZTtcbiAgICAgIHJldHVybiBuZXh0O1xuICAgIH07XG4gIH07XG5cbiAgZnVuY3Rpb24gdmFsdWVzKGl0ZXJhYmxlKSB7XG4gICAgaWYgKGl0ZXJhYmxlKSB7XG4gICAgICB2YXIgaXRlcmF0b3JNZXRob2QgPSBpdGVyYWJsZVtpdGVyYXRvclN5bWJvbF07XG4gICAgICBpZiAoaXRlcmF0b3JNZXRob2QpIHtcbiAgICAgICAgcmV0dXJuIGl0ZXJhdG9yTWV0aG9kLmNhbGwoaXRlcmFibGUpO1xuICAgICAgfVxuXG4gICAgICBpZiAodHlwZW9mIGl0ZXJhYmxlLm5leHQgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICByZXR1cm4gaXRlcmFibGU7XG4gICAgICB9XG5cbiAgICAgIGlmICghaXNOYU4oaXRlcmFibGUubGVuZ3RoKSkge1xuICAgICAgICB2YXIgaSA9IC0xLCBuZXh0ID0gZnVuY3Rpb24gbmV4dCgpIHtcbiAgICAgICAgICB3aGlsZSAoKytpIDwgaXRlcmFibGUubGVuZ3RoKSB7XG4gICAgICAgICAgICBpZiAoaGFzT3duLmNhbGwoaXRlcmFibGUsIGkpKSB7XG4gICAgICAgICAgICAgIG5leHQudmFsdWUgPSBpdGVyYWJsZVtpXTtcbiAgICAgICAgICAgICAgbmV4dC5kb25lID0gZmFsc2U7XG4gICAgICAgICAgICAgIHJldHVybiBuZXh0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIG5leHQudmFsdWUgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgbmV4dC5kb25lID0gdHJ1ZTtcblxuICAgICAgICAgIHJldHVybiBuZXh0O1xuICAgICAgICB9O1xuXG4gICAgICAgIHJldHVybiBuZXh0Lm5leHQgPSBuZXh0O1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIFJldHVybiBhbiBpdGVyYXRvciB3aXRoIG5vIHZhbHVlcy5cbiAgICByZXR1cm4geyBuZXh0OiBkb25lUmVzdWx0IH07XG4gIH1cbiAgZXhwb3J0cy52YWx1ZXMgPSB2YWx1ZXM7XG5cbiAgZnVuY3Rpb24gZG9uZVJlc3VsdCgpIHtcbiAgICByZXR1cm4geyB2YWx1ZTogdW5kZWZpbmVkLCBkb25lOiB0cnVlIH07XG4gIH1cblxuICBDb250ZXh0LnByb3RvdHlwZSA9IHtcbiAgICBjb25zdHJ1Y3RvcjogQ29udGV4dCxcblxuICAgIHJlc2V0OiBmdW5jdGlvbihza2lwVGVtcFJlc2V0KSB7XG4gICAgICB0aGlzLnByZXYgPSAwO1xuICAgICAgdGhpcy5uZXh0ID0gMDtcbiAgICAgIC8vIFJlc2V0dGluZyBjb250ZXh0Ll9zZW50IGZvciBsZWdhY3kgc3VwcG9ydCBvZiBCYWJlbCdzXG4gICAgICAvLyBmdW5jdGlvbi5zZW50IGltcGxlbWVudGF0aW9uLlxuICAgICAgdGhpcy5zZW50ID0gdGhpcy5fc2VudCA9IHVuZGVmaW5lZDtcbiAgICAgIHRoaXMuZG9uZSA9IGZhbHNlO1xuICAgICAgdGhpcy5kZWxlZ2F0ZSA9IG51bGw7XG5cbiAgICAgIHRoaXMubWV0aG9kID0gXCJuZXh0XCI7XG4gICAgICB0aGlzLmFyZyA9IHVuZGVmaW5lZDtcblxuICAgICAgdGhpcy50cnlFbnRyaWVzLmZvckVhY2gocmVzZXRUcnlFbnRyeSk7XG5cbiAgICAgIGlmICghc2tpcFRlbXBSZXNldCkge1xuICAgICAgICBmb3IgKHZhciBuYW1lIGluIHRoaXMpIHtcbiAgICAgICAgICAvLyBOb3Qgc3VyZSBhYm91dCB0aGUgb3B0aW1hbCBvcmRlciBvZiB0aGVzZSBjb25kaXRpb25zOlxuICAgICAgICAgIGlmIChuYW1lLmNoYXJBdCgwKSA9PT0gXCJ0XCIgJiZcbiAgICAgICAgICAgICAgaGFzT3duLmNhbGwodGhpcywgbmFtZSkgJiZcbiAgICAgICAgICAgICAgIWlzTmFOKCtuYW1lLnNsaWNlKDEpKSkge1xuICAgICAgICAgICAgdGhpc1tuYW1lXSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuXG4gICAgc3RvcDogZnVuY3Rpb24oKSB7XG4gICAgICB0aGlzLmRvbmUgPSB0cnVlO1xuXG4gICAgICB2YXIgcm9vdEVudHJ5ID0gdGhpcy50cnlFbnRyaWVzWzBdO1xuICAgICAgdmFyIHJvb3RSZWNvcmQgPSByb290RW50cnkuY29tcGxldGlvbjtcbiAgICAgIGlmIChyb290UmVjb3JkLnR5cGUgPT09IFwidGhyb3dcIikge1xuICAgICAgICB0aHJvdyByb290UmVjb3JkLmFyZztcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXMucnZhbDtcbiAgICB9LFxuXG4gICAgZGlzcGF0Y2hFeGNlcHRpb246IGZ1bmN0aW9uKGV4Y2VwdGlvbikge1xuICAgICAgaWYgKHRoaXMuZG9uZSkge1xuICAgICAgICB0aHJvdyBleGNlcHRpb247XG4gICAgICB9XG5cbiAgICAgIHZhciBjb250ZXh0ID0gdGhpcztcbiAgICAgIGZ1bmN0aW9uIGhhbmRsZShsb2MsIGNhdWdodCkge1xuICAgICAgICByZWNvcmQudHlwZSA9IFwidGhyb3dcIjtcbiAgICAgICAgcmVjb3JkLmFyZyA9IGV4Y2VwdGlvbjtcbiAgICAgICAgY29udGV4dC5uZXh0ID0gbG9jO1xuXG4gICAgICAgIGlmIChjYXVnaHQpIHtcbiAgICAgICAgICAvLyBJZiB0aGUgZGlzcGF0Y2hlZCBleGNlcHRpb24gd2FzIGNhdWdodCBieSBhIGNhdGNoIGJsb2NrLFxuICAgICAgICAgIC8vIHRoZW4gbGV0IHRoYXQgY2F0Y2ggYmxvY2sgaGFuZGxlIHRoZSBleGNlcHRpb24gbm9ybWFsbHkuXG4gICAgICAgICAgY29udGV4dC5tZXRob2QgPSBcIm5leHRcIjtcbiAgICAgICAgICBjb250ZXh0LmFyZyA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiAhISBjYXVnaHQ7XG4gICAgICB9XG5cbiAgICAgIGZvciAodmFyIGkgPSB0aGlzLnRyeUVudHJpZXMubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICAgICAgdmFyIGVudHJ5ID0gdGhpcy50cnlFbnRyaWVzW2ldO1xuICAgICAgICB2YXIgcmVjb3JkID0gZW50cnkuY29tcGxldGlvbjtcblxuICAgICAgICBpZiAoZW50cnkudHJ5TG9jID09PSBcInJvb3RcIikge1xuICAgICAgICAgIC8vIEV4Y2VwdGlvbiB0aHJvd24gb3V0c2lkZSBvZiBhbnkgdHJ5IGJsb2NrIHRoYXQgY291bGQgaGFuZGxlXG4gICAgICAgICAgLy8gaXQsIHNvIHNldCB0aGUgY29tcGxldGlvbiB2YWx1ZSBvZiB0aGUgZW50aXJlIGZ1bmN0aW9uIHRvXG4gICAgICAgICAgLy8gdGhyb3cgdGhlIGV4Y2VwdGlvbi5cbiAgICAgICAgICByZXR1cm4gaGFuZGxlKFwiZW5kXCIpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGVudHJ5LnRyeUxvYyA8PSB0aGlzLnByZXYpIHtcbiAgICAgICAgICB2YXIgaGFzQ2F0Y2ggPSBoYXNPd24uY2FsbChlbnRyeSwgXCJjYXRjaExvY1wiKTtcbiAgICAgICAgICB2YXIgaGFzRmluYWxseSA9IGhhc093bi5jYWxsKGVudHJ5LCBcImZpbmFsbHlMb2NcIik7XG5cbiAgICAgICAgICBpZiAoaGFzQ2F0Y2ggJiYgaGFzRmluYWxseSkge1xuICAgICAgICAgICAgaWYgKHRoaXMucHJldiA8IGVudHJ5LmNhdGNoTG9jKSB7XG4gICAgICAgICAgICAgIHJldHVybiBoYW5kbGUoZW50cnkuY2F0Y2hMb2MsIHRydWUpO1xuICAgICAgICAgICAgfSBlbHNlIGlmICh0aGlzLnByZXYgPCBlbnRyeS5maW5hbGx5TG9jKSB7XG4gICAgICAgICAgICAgIHJldHVybiBoYW5kbGUoZW50cnkuZmluYWxseUxvYyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICB9IGVsc2UgaWYgKGhhc0NhdGNoKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5wcmV2IDwgZW50cnkuY2F0Y2hMb2MpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGhhbmRsZShlbnRyeS5jYXRjaExvYywgdHJ1ZSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICB9IGVsc2UgaWYgKGhhc0ZpbmFsbHkpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnByZXYgPCBlbnRyeS5maW5hbGx5TG9jKSB7XG4gICAgICAgICAgICAgIHJldHVybiBoYW5kbGUoZW50cnkuZmluYWxseUxvYyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwidHJ5IHN0YXRlbWVudCB3aXRob3V0IGNhdGNoIG9yIGZpbmFsbHlcIik7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcblxuICAgIGFicnVwdDogZnVuY3Rpb24odHlwZSwgYXJnKSB7XG4gICAgICBmb3IgKHZhciBpID0gdGhpcy50cnlFbnRyaWVzLmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgICAgIHZhciBlbnRyeSA9IHRoaXMudHJ5RW50cmllc1tpXTtcbiAgICAgICAgaWYgKGVudHJ5LnRyeUxvYyA8PSB0aGlzLnByZXYgJiZcbiAgICAgICAgICAgIGhhc093bi5jYWxsKGVudHJ5LCBcImZpbmFsbHlMb2NcIikgJiZcbiAgICAgICAgICAgIHRoaXMucHJldiA8IGVudHJ5LmZpbmFsbHlMb2MpIHtcbiAgICAgICAgICB2YXIgZmluYWxseUVudHJ5ID0gZW50cnk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKGZpbmFsbHlFbnRyeSAmJlxuICAgICAgICAgICh0eXBlID09PSBcImJyZWFrXCIgfHxcbiAgICAgICAgICAgdHlwZSA9PT0gXCJjb250aW51ZVwiKSAmJlxuICAgICAgICAgIGZpbmFsbHlFbnRyeS50cnlMb2MgPD0gYXJnICYmXG4gICAgICAgICAgYXJnIDw9IGZpbmFsbHlFbnRyeS5maW5hbGx5TG9jKSB7XG4gICAgICAgIC8vIElnbm9yZSB0aGUgZmluYWxseSBlbnRyeSBpZiBjb250cm9sIGlzIG5vdCBqdW1waW5nIHRvIGFcbiAgICAgICAgLy8gbG9jYXRpb24gb3V0c2lkZSB0aGUgdHJ5L2NhdGNoIGJsb2NrLlxuICAgICAgICBmaW5hbGx5RW50cnkgPSBudWxsO1xuICAgICAgfVxuXG4gICAgICB2YXIgcmVjb3JkID0gZmluYWxseUVudHJ5ID8gZmluYWxseUVudHJ5LmNvbXBsZXRpb24gOiB7fTtcbiAgICAgIHJlY29yZC50eXBlID0gdHlwZTtcbiAgICAgIHJlY29yZC5hcmcgPSBhcmc7XG5cbiAgICAgIGlmIChmaW5hbGx5RW50cnkpIHtcbiAgICAgICAgdGhpcy5tZXRob2QgPSBcIm5leHRcIjtcbiAgICAgICAgdGhpcy5uZXh0ID0gZmluYWxseUVudHJ5LmZpbmFsbHlMb2M7XG4gICAgICAgIHJldHVybiBDb250aW51ZVNlbnRpbmVsO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcy5jb21wbGV0ZShyZWNvcmQpO1xuICAgIH0sXG5cbiAgICBjb21wbGV0ZTogZnVuY3Rpb24ocmVjb3JkLCBhZnRlckxvYykge1xuICAgICAgaWYgKHJlY29yZC50eXBlID09PSBcInRocm93XCIpIHtcbiAgICAgICAgdGhyb3cgcmVjb3JkLmFyZztcbiAgICAgIH1cblxuICAgICAgaWYgKHJlY29yZC50eXBlID09PSBcImJyZWFrXCIgfHxcbiAgICAgICAgICByZWNvcmQudHlwZSA9PT0gXCJjb250aW51ZVwiKSB7XG4gICAgICAgIHRoaXMubmV4dCA9IHJlY29yZC5hcmc7XG4gICAgICB9IGVsc2UgaWYgKHJlY29yZC50eXBlID09PSBcInJldHVyblwiKSB7XG4gICAgICAgIHRoaXMucnZhbCA9IHRoaXMuYXJnID0gcmVjb3JkLmFyZztcbiAgICAgICAgdGhpcy5tZXRob2QgPSBcInJldHVyblwiO1xuICAgICAgICB0aGlzLm5leHQgPSBcImVuZFwiO1xuICAgICAgfSBlbHNlIGlmIChyZWNvcmQudHlwZSA9PT0gXCJub3JtYWxcIiAmJiBhZnRlckxvYykge1xuICAgICAgICB0aGlzLm5leHQgPSBhZnRlckxvYztcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIENvbnRpbnVlU2VudGluZWw7XG4gICAgfSxcblxuICAgIGZpbmlzaDogZnVuY3Rpb24oZmluYWxseUxvYykge1xuICAgICAgZm9yICh2YXIgaSA9IHRoaXMudHJ5RW50cmllcy5sZW5ndGggLSAxOyBpID49IDA7IC0taSkge1xuICAgICAgICB2YXIgZW50cnkgPSB0aGlzLnRyeUVudHJpZXNbaV07XG4gICAgICAgIGlmIChlbnRyeS5maW5hbGx5TG9jID09PSBmaW5hbGx5TG9jKSB7XG4gICAgICAgICAgdGhpcy5jb21wbGV0ZShlbnRyeS5jb21wbGV0aW9uLCBlbnRyeS5hZnRlckxvYyk7XG4gICAgICAgICAgcmVzZXRUcnlFbnRyeShlbnRyeSk7XG4gICAgICAgICAgcmV0dXJuIENvbnRpbnVlU2VudGluZWw7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuXG4gICAgXCJjYXRjaFwiOiBmdW5jdGlvbih0cnlMb2MpIHtcbiAgICAgIGZvciAodmFyIGkgPSB0aGlzLnRyeUVudHJpZXMubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICAgICAgdmFyIGVudHJ5ID0gdGhpcy50cnlFbnRyaWVzW2ldO1xuICAgICAgICBpZiAoZW50cnkudHJ5TG9jID09PSB0cnlMb2MpIHtcbiAgICAgICAgICB2YXIgcmVjb3JkID0gZW50cnkuY29tcGxldGlvbjtcbiAgICAgICAgICBpZiAocmVjb3JkLnR5cGUgPT09IFwidGhyb3dcIikge1xuICAgICAgICAgICAgdmFyIHRocm93biA9IHJlY29yZC5hcmc7XG4gICAgICAgICAgICByZXNldFRyeUVudHJ5KGVudHJ5KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHRocm93bjtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBUaGUgY29udGV4dC5jYXRjaCBtZXRob2QgbXVzdCBvbmx5IGJlIGNhbGxlZCB3aXRoIGEgbG9jYXRpb25cbiAgICAgIC8vIGFyZ3VtZW50IHRoYXQgY29ycmVzcG9uZHMgdG8gYSBrbm93biBjYXRjaCBibG9jay5cbiAgICAgIHRocm93IG5ldyBFcnJvcihcImlsbGVnYWwgY2F0Y2ggYXR0ZW1wdFwiKTtcbiAgICB9LFxuXG4gICAgZGVsZWdhdGVZaWVsZDogZnVuY3Rpb24oaXRlcmFibGUsIHJlc3VsdE5hbWUsIG5leHRMb2MpIHtcbiAgICAgIHRoaXMuZGVsZWdhdGUgPSB7XG4gICAgICAgIGl0ZXJhdG9yOiB2YWx1ZXMoaXRlcmFibGUpLFxuICAgICAgICByZXN1bHROYW1lOiByZXN1bHROYW1lLFxuICAgICAgICBuZXh0TG9jOiBuZXh0TG9jXG4gICAgICB9O1xuXG4gICAgICBpZiAodGhpcy5tZXRob2QgPT09IFwibmV4dFwiKSB7XG4gICAgICAgIC8vIERlbGliZXJhdGVseSBmb3JnZXQgdGhlIGxhc3Qgc2VudCB2YWx1ZSBzbyB0aGF0IHdlIGRvbid0XG4gICAgICAgIC8vIGFjY2lkZW50YWxseSBwYXNzIGl0IG9uIHRvIHRoZSBkZWxlZ2F0ZS5cbiAgICAgICAgdGhpcy5hcmcgPSB1bmRlZmluZWQ7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBDb250aW51ZVNlbnRpbmVsO1xuICAgIH1cbiAgfTtcblxuICAvLyBSZWdhcmRsZXNzIG9mIHdoZXRoZXIgdGhpcyBzY3JpcHQgaXMgZXhlY3V0aW5nIGFzIGEgQ29tbW9uSlMgbW9kdWxlXG4gIC8vIG9yIG5vdCwgcmV0dXJuIHRoZSBydW50aW1lIG9iamVjdCBzbyB0aGF0IHdlIGNhbiBkZWNsYXJlIHRoZSB2YXJpYWJsZVxuICAvLyByZWdlbmVyYXRvclJ1bnRpbWUgaW4gdGhlIG91dGVyIHNjb3BlLCB3aGljaCBhbGxvd3MgdGhpcyBtb2R1bGUgdG8gYmVcbiAgLy8gaW5qZWN0ZWQgZWFzaWx5IGJ5IGBiaW4vcmVnZW5lcmF0b3IgLS1pbmNsdWRlLXJ1bnRpbWUgc2NyaXB0LmpzYC5cbiAgcmV0dXJuIGV4cG9ydHM7XG5cbn0oXG4gIC8vIElmIHRoaXMgc2NyaXB0IGlzIGV4ZWN1dGluZyBhcyBhIENvbW1vbkpTIG1vZHVsZSwgdXNlIG1vZHVsZS5leHBvcnRzXG4gIC8vIGFzIHRoZSByZWdlbmVyYXRvclJ1bnRpbWUgbmFtZXNwYWNlLiBPdGhlcndpc2UgY3JlYXRlIGEgbmV3IGVtcHR5XG4gIC8vIG9iamVjdC4gRWl0aGVyIHdheSwgdGhlIHJlc3VsdGluZyBvYmplY3Qgd2lsbCBiZSB1c2VkIHRvIGluaXRpYWxpemVcbiAgLy8gdGhlIHJlZ2VuZXJhdG9yUnVudGltZSB2YXJpYWJsZSBhdCB0aGUgdG9wIG9mIHRoaXMgZmlsZS5cbiAgIHRydWUgPyBtb2R1bGUuZXhwb3J0cyA6IDBcbikpO1xuXG50cnkge1xuICByZWdlbmVyYXRvclJ1bnRpbWUgPSBydW50aW1lO1xufSBjYXRjaCAoYWNjaWRlbnRhbFN0cmljdE1vZGUpIHtcbiAgLy8gVGhpcyBtb2R1bGUgc2hvdWxkIG5vdCBiZSBydW5uaW5nIGluIHN0cmljdCBtb2RlLCBzbyB0aGUgYWJvdmVcbiAgLy8gYXNzaWdubWVudCBzaG91bGQgYWx3YXlzIHdvcmsgdW5sZXNzIHNvbWV0aGluZyBpcyBtaXNjb25maWd1cmVkLiBKdXN0XG4gIC8vIGluIGNhc2UgcnVudGltZS5qcyBhY2NpZGVudGFsbHkgcnVucyBpbiBzdHJpY3QgbW9kZSwgd2UgY2FuIGVzY2FwZVxuICAvLyBzdHJpY3QgbW9kZSB1c2luZyBhIGdsb2JhbCBGdW5jdGlvbiBjYWxsLiBUaGlzIGNvdWxkIGNvbmNlaXZhYmx5IGZhaWxcbiAgLy8gaWYgYSBDb250ZW50IFNlY3VyaXR5IFBvbGljeSBmb3JiaWRzIHVzaW5nIEZ1bmN0aW9uLCBidXQgaW4gdGhhdCBjYXNlXG4gIC8vIHRoZSBwcm9wZXIgc29sdXRpb24gaXMgdG8gZml4IHRoZSBhY2NpZGVudGFsIHN0cmljdCBtb2RlIHByb2JsZW0uIElmXG4gIC8vIHlvdSd2ZSBtaXNjb25maWd1cmVkIHlvdXIgYnVuZGxlciB0byBmb3JjZSBzdHJpY3QgbW9kZSBhbmQgYXBwbGllZCBhXG4gIC8vIENTUCB0byBmb3JiaWQgRnVuY3Rpb24sIGFuZCB5b3UncmUgbm90IHdpbGxpbmcgdG8gZml4IGVpdGhlciBvZiB0aG9zZVxuICAvLyBwcm9ibGVtcywgcGxlYXNlIGRldGFpbCB5b3VyIHVuaXF1ZSBwcmVkaWNhbWVudCBpbiBhIEdpdEh1YiBpc3N1ZS5cbiAgRnVuY3Rpb24oXCJyXCIsIFwicmVnZW5lcmF0b3JSdW50aW1lID0gclwiKShydW50aW1lKTtcbn1cblxuXG4vKioqLyB9KSxcblxuLyoqKi8gODYzOlxuLyoqKi8gKChtb2R1bGUsIF9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuXG4vLyBzdHlsZS1sb2FkZXI6IEFkZHMgc29tZSBjc3MgdG8gdGhlIERPTSBieSBhZGRpbmcgYSA8c3R5bGU+IHRhZ1xuXG4vLyBsb2FkIHRoZSBzdHlsZXNcbnZhciBjb250ZW50ID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0MTgpO1xuaWYoY29udGVudC5fX2VzTW9kdWxlKSBjb250ZW50ID0gY29udGVudC5kZWZhdWx0O1xuaWYodHlwZW9mIGNvbnRlbnQgPT09ICdzdHJpbmcnKSBjb250ZW50ID0gW1ttb2R1bGUuaWQsIGNvbnRlbnQsICcnXV07XG5pZihjb250ZW50LmxvY2FscykgbW9kdWxlLmV4cG9ydHMgPSBjb250ZW50LmxvY2Fscztcbi8vIGFkZCB0aGUgc3R5bGVzIHRvIHRoZSBET01cbnZhciBhZGQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDM0NikvKiAuZGVmYXVsdCAqLyAuWlxudmFyIHVwZGF0ZSA9IGFkZChcIjU1MGI0N2FiXCIsIGNvbnRlbnQsIGZhbHNlLCB7fSk7XG4vLyBIb3QgTW9kdWxlIFJlcGxhY2VtZW50XG5pZihmYWxzZSkge31cblxuLyoqKi8gfSksXG5cbi8qKiovIDEyNDpcbi8qKiovICgobW9kdWxlLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcblxuLy8gc3R5bGUtbG9hZGVyOiBBZGRzIHNvbWUgY3NzIHRvIHRoZSBET00gYnkgYWRkaW5nIGEgPHN0eWxlPiB0YWdcblxuLy8gbG9hZCB0aGUgc3R5bGVzXG52YXIgY29udGVudCA9IF9fd2VicGFja19yZXF1aXJlX18oOTc2KTtcbmlmKGNvbnRlbnQuX19lc01vZHVsZSkgY29udGVudCA9IGNvbnRlbnQuZGVmYXVsdDtcbmlmKHR5cGVvZiBjb250ZW50ID09PSAnc3RyaW5nJykgY29udGVudCA9IFtbbW9kdWxlLmlkLCBjb250ZW50LCAnJ11dO1xuaWYoY29udGVudC5sb2NhbHMpIG1vZHVsZS5leHBvcnRzID0gY29udGVudC5sb2NhbHM7XG4vLyBhZGQgdGhlIHN0eWxlcyB0byB0aGUgRE9NXG52YXIgYWRkID0gX193ZWJwYWNrX3JlcXVpcmVfXygzNDYpLyogLmRlZmF1bHQgKi8gLlpcbnZhciB1cGRhdGUgPSBhZGQoXCIxYjM0YmZlYlwiLCBjb250ZW50LCBmYWxzZSwge30pO1xuLy8gSG90IE1vZHVsZSBSZXBsYWNlbWVudFxuaWYoZmFsc2UpIHt9XG5cbi8qKiovIH0pLFxuXG4vKioqLyA4ODY6XG4vKioqLyAoKG1vZHVsZSwgX191bnVzZWRfd2VicGFja19leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cbi8vIHN0eWxlLWxvYWRlcjogQWRkcyBzb21lIGNzcyB0byB0aGUgRE9NIGJ5IGFkZGluZyBhIDxzdHlsZT4gdGFnXG5cbi8vIGxvYWQgdGhlIHN0eWxlc1xudmFyIGNvbnRlbnQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQ0OSk7XG5pZihjb250ZW50Ll9fZXNNb2R1bGUpIGNvbnRlbnQgPSBjb250ZW50LmRlZmF1bHQ7XG5pZih0eXBlb2YgY29udGVudCA9PT0gJ3N0cmluZycpIGNvbnRlbnQgPSBbW21vZHVsZS5pZCwgY29udGVudCwgJyddXTtcbmlmKGNvbnRlbnQubG9jYWxzKSBtb2R1bGUuZXhwb3J0cyA9IGNvbnRlbnQubG9jYWxzO1xuLy8gYWRkIHRoZSBzdHlsZXMgdG8gdGhlIERPTVxudmFyIGFkZCA9IF9fd2VicGFja19yZXF1aXJlX18oMzQ2KS8qIC5kZWZhdWx0ICovIC5aXG52YXIgdXBkYXRlID0gYWRkKFwiOTg5NWQzYTZcIiwgY29udGVudCwgZmFsc2UsIHt9KTtcbi8vIEhvdCBNb2R1bGUgUmVwbGFjZW1lbnRcbmlmKGZhbHNlKSB7fVxuXG4vKioqLyB9KSxcblxuLyoqKi8gODA3OlxuLyoqKi8gKChtb2R1bGUsIF9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuXG4vLyBzdHlsZS1sb2FkZXI6IEFkZHMgc29tZSBjc3MgdG8gdGhlIERPTSBieSBhZGRpbmcgYSA8c3R5bGU+IHRhZ1xuXG4vLyBsb2FkIHRoZSBzdHlsZXNcbnZhciBjb250ZW50ID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMDgpO1xuaWYoY29udGVudC5fX2VzTW9kdWxlKSBjb250ZW50ID0gY29udGVudC5kZWZhdWx0O1xuaWYodHlwZW9mIGNvbnRlbnQgPT09ICdzdHJpbmcnKSBjb250ZW50ID0gW1ttb2R1bGUuaWQsIGNvbnRlbnQsICcnXV07XG5pZihjb250ZW50LmxvY2FscykgbW9kdWxlLmV4cG9ydHMgPSBjb250ZW50LmxvY2Fscztcbi8vIGFkZCB0aGUgc3R5bGVzIHRvIHRoZSBET01cbnZhciBhZGQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDM0NikvKiAuZGVmYXVsdCAqLyAuWlxudmFyIHVwZGF0ZSA9IGFkZChcIjgxMzkwMzZhXCIsIGNvbnRlbnQsIGZhbHNlLCB7fSk7XG4vLyBIb3QgTW9kdWxlIFJlcGxhY2VtZW50XG5pZihmYWxzZSkge31cblxuLyoqKi8gfSksXG5cbi8qKiovIDYwMDpcbi8qKiovICgobW9kdWxlLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcblxuLy8gc3R5bGUtbG9hZGVyOiBBZGRzIHNvbWUgY3NzIHRvIHRoZSBET00gYnkgYWRkaW5nIGEgPHN0eWxlPiB0YWdcblxuLy8gbG9hZCB0aGUgc3R5bGVzXG52YXIgY29udGVudCA9IF9fd2VicGFja19yZXF1aXJlX18oOTg4KTtcbmlmKGNvbnRlbnQuX19lc01vZHVsZSkgY29udGVudCA9IGNvbnRlbnQuZGVmYXVsdDtcbmlmKHR5cGVvZiBjb250ZW50ID09PSAnc3RyaW5nJykgY29udGVudCA9IFtbbW9kdWxlLmlkLCBjb250ZW50LCAnJ11dO1xuaWYoY29udGVudC5sb2NhbHMpIG1vZHVsZS5leHBvcnRzID0gY29udGVudC5sb2NhbHM7XG4vLyBhZGQgdGhlIHN0eWxlcyB0byB0aGUgRE9NXG52YXIgYWRkID0gX193ZWJwYWNrX3JlcXVpcmVfXygzNDYpLyogLmRlZmF1bHQgKi8gLlpcbnZhciB1cGRhdGUgPSBhZGQoXCIxZGIwMWMwYlwiLCBjb250ZW50LCBmYWxzZSwge30pO1xuLy8gSG90IE1vZHVsZSBSZXBsYWNlbWVudFxuaWYoZmFsc2UpIHt9XG5cbi8qKiovIH0pLFxuXG4vKioqLyAxNjk6XG4vKioqLyAoKG1vZHVsZSwgX191bnVzZWRfd2VicGFja19leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cbi8vIHN0eWxlLWxvYWRlcjogQWRkcyBzb21lIGNzcyB0byB0aGUgRE9NIGJ5IGFkZGluZyBhIDxzdHlsZT4gdGFnXG5cbi8vIGxvYWQgdGhlIHN0eWxlc1xudmFyIGNvbnRlbnQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQyMyk7XG5pZihjb250ZW50Ll9fZXNNb2R1bGUpIGNvbnRlbnQgPSBjb250ZW50LmRlZmF1bHQ7XG5pZih0eXBlb2YgY29udGVudCA9PT0gJ3N0cmluZycpIGNvbnRlbnQgPSBbW21vZHVsZS5pZCwgY29udGVudCwgJyddXTtcbmlmKGNvbnRlbnQubG9jYWxzKSBtb2R1bGUuZXhwb3J0cyA9IGNvbnRlbnQubG9jYWxzO1xuLy8gYWRkIHRoZSBzdHlsZXMgdG8gdGhlIERPTVxudmFyIGFkZCA9IF9fd2VicGFja19yZXF1aXJlX18oMzQ2KS8qIC5kZWZhdWx0ICovIC5aXG52YXIgdXBkYXRlID0gYWRkKFwiNjhmMjQzZWFcIiwgY29udGVudCwgZmFsc2UsIHt9KTtcbi8vIEhvdCBNb2R1bGUgUmVwbGFjZW1lbnRcbmlmKGZhbHNlKSB7fVxuXG4vKioqLyB9KSxcblxuLyoqKi8gMTE6XG4vKioqLyAoKG1vZHVsZSwgX191bnVzZWRfd2VicGFja19leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cbi8vIHN0eWxlLWxvYWRlcjogQWRkcyBzb21lIGNzcyB0byB0aGUgRE9NIGJ5IGFkZGluZyBhIDxzdHlsZT4gdGFnXG5cbi8vIGxvYWQgdGhlIHN0eWxlc1xudmFyIGNvbnRlbnQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDY2MSk7XG5pZihjb250ZW50Ll9fZXNNb2R1bGUpIGNvbnRlbnQgPSBjb250ZW50LmRlZmF1bHQ7XG5pZih0eXBlb2YgY29udGVudCA9PT0gJ3N0cmluZycpIGNvbnRlbnQgPSBbW21vZHVsZS5pZCwgY29udGVudCwgJyddXTtcbmlmKGNvbnRlbnQubG9jYWxzKSBtb2R1bGUuZXhwb3J0cyA9IGNvbnRlbnQubG9jYWxzO1xuLy8gYWRkIHRoZSBzdHlsZXMgdG8gdGhlIERPTVxudmFyIGFkZCA9IF9fd2VicGFja19yZXF1aXJlX18oMzQ2KS8qIC5kZWZhdWx0ICovIC5aXG52YXIgdXBkYXRlID0gYWRkKFwiMTJkMjMwOWRcIiwgY29udGVudCwgZmFsc2UsIHt9KTtcbi8vIEhvdCBNb2R1bGUgUmVwbGFjZW1lbnRcbmlmKGZhbHNlKSB7fVxuXG4vKioqLyB9KSxcblxuLyoqKi8gMzcyOlxuLyoqKi8gKChtb2R1bGUsIF9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuXG4vLyBzdHlsZS1sb2FkZXI6IEFkZHMgc29tZSBjc3MgdG8gdGhlIERPTSBieSBhZGRpbmcgYSA8c3R5bGU+IHRhZ1xuXG4vLyBsb2FkIHRoZSBzdHlsZXNcbnZhciBjb250ZW50ID0gX193ZWJwYWNrX3JlcXVpcmVfXygxNjgpO1xuaWYoY29udGVudC5fX2VzTW9kdWxlKSBjb250ZW50ID0gY29udGVudC5kZWZhdWx0O1xuaWYodHlwZW9mIGNvbnRlbnQgPT09ICdzdHJpbmcnKSBjb250ZW50ID0gW1ttb2R1bGUuaWQsIGNvbnRlbnQsICcnXV07XG5pZihjb250ZW50LmxvY2FscykgbW9kdWxlLmV4cG9ydHMgPSBjb250ZW50LmxvY2Fscztcbi8vIGFkZCB0aGUgc3R5bGVzIHRvIHRoZSBET01cbnZhciBhZGQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDM0NikvKiAuZGVmYXVsdCAqLyAuWlxudmFyIHVwZGF0ZSA9IGFkZChcIjViNjIwNjA1XCIsIGNvbnRlbnQsIGZhbHNlLCB7fSk7XG4vLyBIb3QgTW9kdWxlIFJlcGxhY2VtZW50XG5pZihmYWxzZSkge31cblxuLyoqKi8gfSksXG5cbi8qKiovIDQ3Nzpcbi8qKiovICgobW9kdWxlLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcblxuLy8gc3R5bGUtbG9hZGVyOiBBZGRzIHNvbWUgY3NzIHRvIHRoZSBET00gYnkgYWRkaW5nIGEgPHN0eWxlPiB0YWdcblxuLy8gbG9hZCB0aGUgc3R5bGVzXG52YXIgY29udGVudCA9IF9fd2VicGFja19yZXF1aXJlX18oMjkpO1xuaWYoY29udGVudC5fX2VzTW9kdWxlKSBjb250ZW50ID0gY29udGVudC5kZWZhdWx0O1xuaWYodHlwZW9mIGNvbnRlbnQgPT09ICdzdHJpbmcnKSBjb250ZW50ID0gW1ttb2R1bGUuaWQsIGNvbnRlbnQsICcnXV07XG5pZihjb250ZW50LmxvY2FscykgbW9kdWxlLmV4cG9ydHMgPSBjb250ZW50LmxvY2Fscztcbi8vIGFkZCB0aGUgc3R5bGVzIHRvIHRoZSBET01cbnZhciBhZGQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDM0NikvKiAuZGVmYXVsdCAqLyAuWlxudmFyIHVwZGF0ZSA9IGFkZChcIjE0M2RmZmFiXCIsIGNvbnRlbnQsIGZhbHNlLCB7fSk7XG4vLyBIb3QgTW9kdWxlIFJlcGxhY2VtZW50XG5pZihmYWxzZSkge31cblxuLyoqKi8gfSksXG5cbi8qKiovIDE1Mzpcbi8qKiovICgobW9kdWxlLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcblxuLy8gc3R5bGUtbG9hZGVyOiBBZGRzIHNvbWUgY3NzIHRvIHRoZSBET00gYnkgYWRkaW5nIGEgPHN0eWxlPiB0YWdcblxuLy8gbG9hZCB0aGUgc3R5bGVzXG52YXIgY29udGVudCA9IF9fd2VicGFja19yZXF1aXJlX18oOTM1KTtcbmlmKGNvbnRlbnQuX19lc01vZHVsZSkgY29udGVudCA9IGNvbnRlbnQuZGVmYXVsdDtcbmlmKHR5cGVvZiBjb250ZW50ID09PSAnc3RyaW5nJykgY29udGVudCA9IFtbbW9kdWxlLmlkLCBjb250ZW50LCAnJ11dO1xuaWYoY29udGVudC5sb2NhbHMpIG1vZHVsZS5leHBvcnRzID0gY29udGVudC5sb2NhbHM7XG4vLyBhZGQgdGhlIHN0eWxlcyB0byB0aGUgRE9NXG52YXIgYWRkID0gX193ZWJwYWNrX3JlcXVpcmVfXygzNDYpLyogLmRlZmF1bHQgKi8gLlpcbnZhciB1cGRhdGUgPSBhZGQoXCJmMzJmZDM2ZVwiLCBjb250ZW50LCBmYWxzZSwge30pO1xuLy8gSG90IE1vZHVsZSBSZXBsYWNlbWVudFxuaWYoZmFsc2UpIHt9XG5cbi8qKiovIH0pLFxuXG4vKioqLyA1MDE6XG4vKioqLyAoKG1vZHVsZSwgX191bnVzZWRfd2VicGFja19leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cbi8vIHN0eWxlLWxvYWRlcjogQWRkcyBzb21lIGNzcyB0byB0aGUgRE9NIGJ5IGFkZGluZyBhIDxzdHlsZT4gdGFnXG5cbi8vIGxvYWQgdGhlIHN0eWxlc1xudmFyIGNvbnRlbnQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDM3OSk7XG5pZihjb250ZW50Ll9fZXNNb2R1bGUpIGNvbnRlbnQgPSBjb250ZW50LmRlZmF1bHQ7XG5pZih0eXBlb2YgY29udGVudCA9PT0gJ3N0cmluZycpIGNvbnRlbnQgPSBbW21vZHVsZS5pZCwgY29udGVudCwgJyddXTtcbmlmKGNvbnRlbnQubG9jYWxzKSBtb2R1bGUuZXhwb3J0cyA9IGNvbnRlbnQubG9jYWxzO1xuLy8gYWRkIHRoZSBzdHlsZXMgdG8gdGhlIERPTVxudmFyIGFkZCA9IF9fd2VicGFja19yZXF1aXJlX18oMzQ2KS8qIC5kZWZhdWx0ICovIC5aXG52YXIgdXBkYXRlID0gYWRkKFwiNjA0YmY1ZWZcIiwgY29udGVudCwgZmFsc2UsIHt9KTtcbi8vIEhvdCBNb2R1bGUgUmVwbGFjZW1lbnRcbmlmKGZhbHNlKSB7fVxuXG4vKioqLyB9KSxcblxuLyoqKi8gNTY1OlxuLyoqKi8gKChtb2R1bGUsIF9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuXG4vLyBzdHlsZS1sb2FkZXI6IEFkZHMgc29tZSBjc3MgdG8gdGhlIERPTSBieSBhZGRpbmcgYSA8c3R5bGU+IHRhZ1xuXG4vLyBsb2FkIHRoZSBzdHlsZXNcbnZhciBjb250ZW50ID0gX193ZWJwYWNrX3JlcXVpcmVfXyg3Mik7XG5pZihjb250ZW50Ll9fZXNNb2R1bGUpIGNvbnRlbnQgPSBjb250ZW50LmRlZmF1bHQ7XG5pZih0eXBlb2YgY29udGVudCA9PT0gJ3N0cmluZycpIGNvbnRlbnQgPSBbW21vZHVsZS5pZCwgY29udGVudCwgJyddXTtcbmlmKGNvbnRlbnQubG9jYWxzKSBtb2R1bGUuZXhwb3J0cyA9IGNvbnRlbnQubG9jYWxzO1xuLy8gYWRkIHRoZSBzdHlsZXMgdG8gdGhlIERPTVxudmFyIGFkZCA9IF9fd2VicGFja19yZXF1aXJlX18oMzQ2KS8qIC5kZWZhdWx0ICovIC5aXG52YXIgdXBkYXRlID0gYWRkKFwiMjFmZGU1NzNcIiwgY29udGVudCwgZmFsc2UsIHt9KTtcbi8vIEhvdCBNb2R1bGUgUmVwbGFjZW1lbnRcbmlmKGZhbHNlKSB7fVxuXG4vKioqLyB9KSxcblxuLyoqKi8gNTpcbi8qKiovICgobW9kdWxlLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcblxuLy8gc3R5bGUtbG9hZGVyOiBBZGRzIHNvbWUgY3NzIHRvIHRoZSBET00gYnkgYWRkaW5nIGEgPHN0eWxlPiB0YWdcblxuLy8gbG9hZCB0aGUgc3R5bGVzXG52YXIgY29udGVudCA9IF9fd2VicGFja19yZXF1aXJlX18oOTgzKTtcbmlmKGNvbnRlbnQuX19lc01vZHVsZSkgY29udGVudCA9IGNvbnRlbnQuZGVmYXVsdDtcbmlmKHR5cGVvZiBjb250ZW50ID09PSAnc3RyaW5nJykgY29udGVudCA9IFtbbW9kdWxlLmlkLCBjb250ZW50LCAnJ11dO1xuaWYoY29udGVudC5sb2NhbHMpIG1vZHVsZS5leHBvcnRzID0gY29udGVudC5sb2NhbHM7XG4vLyBhZGQgdGhlIHN0eWxlcyB0byB0aGUgRE9NXG52YXIgYWRkID0gX193ZWJwYWNrX3JlcXVpcmVfXygzNDYpLyogLmRlZmF1bHQgKi8gLlpcbnZhciB1cGRhdGUgPSBhZGQoXCJmZDgzNjg5ZVwiLCBjb250ZW50LCBmYWxzZSwge30pO1xuLy8gSG90IE1vZHVsZSBSZXBsYWNlbWVudFxuaWYoZmFsc2UpIHt9XG5cbi8qKiovIH0pLFxuXG4vKioqLyAzNDY6XG4vKioqLyAoKF9fdW51c2VkX3dlYnBhY2tfbW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cblwidXNlIHN0cmljdFwiO1xuXG4vLyBFWFBPUlRTXG5fX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywge1xuICBcIlpcIjogKCkgPT4gKC8qIGJpbmRpbmcgKi8gYWRkU3R5bGVzQ2xpZW50KVxufSk7XG5cbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL25vZGVfbW9kdWxlcy92dWUtc3R5bGUtbG9hZGVyL2xpYi9saXN0VG9TdHlsZXMuanNcbi8qKlxuICogVHJhbnNsYXRlcyB0aGUgbGlzdCBmb3JtYXQgcHJvZHVjZWQgYnkgY3NzLWxvYWRlciBpbnRvIHNvbWV0aGluZ1xuICogZWFzaWVyIHRvIG1hbmlwdWxhdGUuXG4gKi9cbmZ1bmN0aW9uIGxpc3RUb1N0eWxlcyAocGFyZW50SWQsIGxpc3QpIHtcbiAgdmFyIHN0eWxlcyA9IFtdXG4gIHZhciBuZXdTdHlsZXMgPSB7fVxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgaXRlbSA9IGxpc3RbaV1cbiAgICB2YXIgaWQgPSBpdGVtWzBdXG4gICAgdmFyIGNzcyA9IGl0ZW1bMV1cbiAgICB2YXIgbWVkaWEgPSBpdGVtWzJdXG4gICAgdmFyIHNvdXJjZU1hcCA9IGl0ZW1bM11cbiAgICB2YXIgcGFydCA9IHtcbiAgICAgIGlkOiBwYXJlbnRJZCArICc6JyArIGksXG4gICAgICBjc3M6IGNzcyxcbiAgICAgIG1lZGlhOiBtZWRpYSxcbiAgICAgIHNvdXJjZU1hcDogc291cmNlTWFwXG4gICAgfVxuICAgIGlmICghbmV3U3R5bGVzW2lkXSkge1xuICAgICAgc3R5bGVzLnB1c2gobmV3U3R5bGVzW2lkXSA9IHsgaWQ6IGlkLCBwYXJ0czogW3BhcnRdIH0pXG4gICAgfSBlbHNlIHtcbiAgICAgIG5ld1N0eWxlc1tpZF0ucGFydHMucHVzaChwYXJ0KVxuICAgIH1cbiAgfVxuICByZXR1cm4gc3R5bGVzXG59XG5cbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL25vZGVfbW9kdWxlcy92dWUtc3R5bGUtbG9hZGVyL2xpYi9hZGRTdHlsZXNDbGllbnQuanNcbi8qXG4gIE1JVCBMaWNlbnNlIGh0dHA6Ly93d3cub3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvbWl0LWxpY2Vuc2UucGhwXG4gIEF1dGhvciBUb2JpYXMgS29wcGVycyBAc29rcmFcbiAgTW9kaWZpZWQgYnkgRXZhbiBZb3UgQHl5eDk5MDgwM1xuKi9cblxuXG5cbnZhciBoYXNEb2N1bWVudCA9IHR5cGVvZiBkb2N1bWVudCAhPT0gJ3VuZGVmaW5lZCdcblxuaWYgKHR5cGVvZiBERUJVRyAhPT0gJ3VuZGVmaW5lZCcgJiYgREVCVUcpIHtcbiAgaWYgKCFoYXNEb2N1bWVudCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAndnVlLXN0eWxlLWxvYWRlciBjYW5ub3QgYmUgdXNlZCBpbiBhIG5vbi1icm93c2VyIGVudmlyb25tZW50LiAnICtcbiAgICBcIlVzZSB7IHRhcmdldDogJ25vZGUnIH0gaW4geW91ciBXZWJwYWNrIGNvbmZpZyB0byBpbmRpY2F0ZSBhIHNlcnZlci1yZW5kZXJpbmcgZW52aXJvbm1lbnQuXCJcbiAgKSB9XG59XG5cbi8qXG50eXBlIFN0eWxlT2JqZWN0ID0ge1xuICBpZDogbnVtYmVyO1xuICBwYXJ0czogQXJyYXk8U3R5bGVPYmplY3RQYXJ0PlxufVxuXG50eXBlIFN0eWxlT2JqZWN0UGFydCA9IHtcbiAgY3NzOiBzdHJpbmc7XG4gIG1lZGlhOiBzdHJpbmc7XG4gIHNvdXJjZU1hcDogP3N0cmluZ1xufVxuKi9cblxudmFyIHN0eWxlc0luRG9tID0gey8qXG4gIFtpZDogbnVtYmVyXToge1xuICAgIGlkOiBudW1iZXIsXG4gICAgcmVmczogbnVtYmVyLFxuICAgIHBhcnRzOiBBcnJheTwob2JqPzogU3R5bGVPYmplY3RQYXJ0KSA9PiB2b2lkPlxuICB9XG4qL31cblxudmFyIGhlYWQgPSBoYXNEb2N1bWVudCAmJiAoZG9jdW1lbnQuaGVhZCB8fCBkb2N1bWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZSgnaGVhZCcpWzBdKVxudmFyIHNpbmdsZXRvbkVsZW1lbnQgPSBudWxsXG52YXIgc2luZ2xldG9uQ291bnRlciA9IDBcbnZhciBpc1Byb2R1Y3Rpb24gPSBmYWxzZVxudmFyIG5vb3AgPSBmdW5jdGlvbiAoKSB7fVxudmFyIG9wdGlvbnMgPSBudWxsXG52YXIgc3NySWRLZXkgPSAnZGF0YS12dWUtc3NyLWlkJ1xuXG4vLyBGb3JjZSBzaW5nbGUtdGFnIHNvbHV0aW9uIG9uIElFNi05LCB3aGljaCBoYXMgYSBoYXJkIGxpbWl0IG9uIHRoZSAjIG9mIDxzdHlsZT5cbi8vIHRhZ3MgaXQgd2lsbCBhbGxvdyBvbiBhIHBhZ2VcbnZhciBpc09sZElFID0gdHlwZW9mIG5hdmlnYXRvciAhPT0gJ3VuZGVmaW5lZCcgJiYgL21zaWUgWzYtOV1cXGIvLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudC50b0xvd2VyQ2FzZSgpKVxuXG5mdW5jdGlvbiBhZGRTdHlsZXNDbGllbnQgKHBhcmVudElkLCBsaXN0LCBfaXNQcm9kdWN0aW9uLCBfb3B0aW9ucykge1xuICBpc1Byb2R1Y3Rpb24gPSBfaXNQcm9kdWN0aW9uXG5cbiAgb3B0aW9ucyA9IF9vcHRpb25zIHx8IHt9XG5cbiAgdmFyIHN0eWxlcyA9IGxpc3RUb1N0eWxlcyhwYXJlbnRJZCwgbGlzdClcbiAgYWRkU3R5bGVzVG9Eb20oc3R5bGVzKVxuXG4gIHJldHVybiBmdW5jdGlvbiB1cGRhdGUgKG5ld0xpc3QpIHtcbiAgICB2YXIgbWF5UmVtb3ZlID0gW11cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHN0eWxlcy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGl0ZW0gPSBzdHlsZXNbaV1cbiAgICAgIHZhciBkb21TdHlsZSA9IHN0eWxlc0luRG9tW2l0ZW0uaWRdXG4gICAgICBkb21TdHlsZS5yZWZzLS1cbiAgICAgIG1heVJlbW92ZS5wdXNoKGRvbVN0eWxlKVxuICAgIH1cbiAgICBpZiAobmV3TGlzdCkge1xuICAgICAgc3R5bGVzID0gbGlzdFRvU3R5bGVzKHBhcmVudElkLCBuZXdMaXN0KVxuICAgICAgYWRkU3R5bGVzVG9Eb20oc3R5bGVzKVxuICAgIH0gZWxzZSB7XG4gICAgICBzdHlsZXMgPSBbXVxuICAgIH1cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG1heVJlbW92ZS5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGRvbVN0eWxlID0gbWF5UmVtb3ZlW2ldXG4gICAgICBpZiAoZG9tU3R5bGUucmVmcyA9PT0gMCkge1xuICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGRvbVN0eWxlLnBhcnRzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgZG9tU3R5bGUucGFydHNbal0oKVxuICAgICAgICB9XG4gICAgICAgIGRlbGV0ZSBzdHlsZXNJbkRvbVtkb21TdHlsZS5pZF1cbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gYWRkU3R5bGVzVG9Eb20gKHN0eWxlcyAvKiBBcnJheTxTdHlsZU9iamVjdD4gKi8pIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdHlsZXMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgaXRlbSA9IHN0eWxlc1tpXVxuICAgIHZhciBkb21TdHlsZSA9IHN0eWxlc0luRG9tW2l0ZW0uaWRdXG4gICAgaWYgKGRvbVN0eWxlKSB7XG4gICAgICBkb21TdHlsZS5yZWZzKytcbiAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgZG9tU3R5bGUucGFydHMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgZG9tU3R5bGUucGFydHNbal0oaXRlbS5wYXJ0c1tqXSlcbiAgICAgIH1cbiAgICAgIGZvciAoOyBqIDwgaXRlbS5wYXJ0cy5sZW5ndGg7IGorKykge1xuICAgICAgICBkb21TdHlsZS5wYXJ0cy5wdXNoKGFkZFN0eWxlKGl0ZW0ucGFydHNbal0pKVxuICAgICAgfVxuICAgICAgaWYgKGRvbVN0eWxlLnBhcnRzLmxlbmd0aCA+IGl0ZW0ucGFydHMubGVuZ3RoKSB7XG4gICAgICAgIGRvbVN0eWxlLnBhcnRzLmxlbmd0aCA9IGl0ZW0ucGFydHMubGVuZ3RoXG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBwYXJ0cyA9IFtdXG4gICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGl0ZW0ucGFydHMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgcGFydHMucHVzaChhZGRTdHlsZShpdGVtLnBhcnRzW2pdKSlcbiAgICAgIH1cbiAgICAgIHN0eWxlc0luRG9tW2l0ZW0uaWRdID0geyBpZDogaXRlbS5pZCwgcmVmczogMSwgcGFydHM6IHBhcnRzIH1cbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gY3JlYXRlU3R5bGVFbGVtZW50ICgpIHtcbiAgdmFyIHN0eWxlRWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3N0eWxlJylcbiAgc3R5bGVFbGVtZW50LnR5cGUgPSAndGV4dC9jc3MnXG4gIGhlYWQuYXBwZW5kQ2hpbGQoc3R5bGVFbGVtZW50KVxuICByZXR1cm4gc3R5bGVFbGVtZW50XG59XG5cbmZ1bmN0aW9uIGFkZFN0eWxlIChvYmogLyogU3R5bGVPYmplY3RQYXJ0ICovKSB7XG4gIHZhciB1cGRhdGUsIHJlbW92ZVxuICB2YXIgc3R5bGVFbGVtZW50ID0gZG9jdW1lbnQucXVlcnlTZWxlY3Rvcignc3R5bGVbJyArIHNzcklkS2V5ICsgJ349XCInICsgb2JqLmlkICsgJ1wiXScpXG5cbiAgaWYgKHN0eWxlRWxlbWVudCkge1xuICAgIGlmIChpc1Byb2R1Y3Rpb24pIHtcbiAgICAgIC8vIGhhcyBTU1Igc3R5bGVzIGFuZCBpbiBwcm9kdWN0aW9uIG1vZGUuXG4gICAgICAvLyBzaW1wbHkgZG8gbm90aGluZy5cbiAgICAgIHJldHVybiBub29wXG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGhhcyBTU1Igc3R5bGVzIGJ1dCBpbiBkZXYgbW9kZS5cbiAgICAgIC8vIGZvciBzb21lIHJlYXNvbiBDaHJvbWUgY2FuJ3QgaGFuZGxlIHNvdXJjZSBtYXAgaW4gc2VydmVyLXJlbmRlcmVkXG4gICAgICAvLyBzdHlsZSB0YWdzIC0gc291cmNlIG1hcHMgaW4gPHN0eWxlPiBvbmx5IHdvcmtzIGlmIHRoZSBzdHlsZSB0YWcgaXNcbiAgICAgIC8vIGNyZWF0ZWQgYW5kIGluc2VydGVkIGR5bmFtaWNhbGx5LiBTbyB3ZSByZW1vdmUgdGhlIHNlcnZlciByZW5kZXJlZFxuICAgICAgLy8gc3R5bGVzIGFuZCBpbmplY3QgbmV3IG9uZXMuXG4gICAgICBzdHlsZUVsZW1lbnQucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChzdHlsZUVsZW1lbnQpXG4gICAgfVxuICB9XG5cbiAgaWYgKGlzT2xkSUUpIHtcbiAgICAvLyB1c2Ugc2luZ2xldG9uIG1vZGUgZm9yIElFOS5cbiAgICB2YXIgc3R5bGVJbmRleCA9IHNpbmdsZXRvbkNvdW50ZXIrK1xuICAgIHN0eWxlRWxlbWVudCA9IHNpbmdsZXRvbkVsZW1lbnQgfHwgKHNpbmdsZXRvbkVsZW1lbnQgPSBjcmVhdGVTdHlsZUVsZW1lbnQoKSlcbiAgICB1cGRhdGUgPSBhcHBseVRvU2luZ2xldG9uVGFnLmJpbmQobnVsbCwgc3R5bGVFbGVtZW50LCBzdHlsZUluZGV4LCBmYWxzZSlcbiAgICByZW1vdmUgPSBhcHBseVRvU2luZ2xldG9uVGFnLmJpbmQobnVsbCwgc3R5bGVFbGVtZW50LCBzdHlsZUluZGV4LCB0cnVlKVxuICB9IGVsc2Uge1xuICAgIC8vIHVzZSBtdWx0aS1zdHlsZS10YWcgbW9kZSBpbiBhbGwgb3RoZXIgY2FzZXNcbiAgICBzdHlsZUVsZW1lbnQgPSBjcmVhdGVTdHlsZUVsZW1lbnQoKVxuICAgIHVwZGF0ZSA9IGFwcGx5VG9UYWcuYmluZChudWxsLCBzdHlsZUVsZW1lbnQpXG4gICAgcmVtb3ZlID0gZnVuY3Rpb24gKCkge1xuICAgICAgc3R5bGVFbGVtZW50LnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoc3R5bGVFbGVtZW50KVxuICAgIH1cbiAgfVxuXG4gIHVwZGF0ZShvYmopXG5cbiAgcmV0dXJuIGZ1bmN0aW9uIHVwZGF0ZVN0eWxlIChuZXdPYmogLyogU3R5bGVPYmplY3RQYXJ0ICovKSB7XG4gICAgaWYgKG5ld09iaikge1xuICAgICAgaWYgKG5ld09iai5jc3MgPT09IG9iai5jc3MgJiZcbiAgICAgICAgICBuZXdPYmoubWVkaWEgPT09IG9iai5tZWRpYSAmJlxuICAgICAgICAgIG5ld09iai5zb3VyY2VNYXAgPT09IG9iai5zb3VyY2VNYXApIHtcbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG4gICAgICB1cGRhdGUob2JqID0gbmV3T2JqKVxuICAgIH0gZWxzZSB7XG4gICAgICByZW1vdmUoKVxuICAgIH1cbiAgfVxufVxuXG52YXIgcmVwbGFjZVRleHQgPSAoZnVuY3Rpb24gKCkge1xuICB2YXIgdGV4dFN0b3JlID0gW11cblxuICByZXR1cm4gZnVuY3Rpb24gKGluZGV4LCByZXBsYWNlbWVudCkge1xuICAgIHRleHRTdG9yZVtpbmRleF0gPSByZXBsYWNlbWVudFxuICAgIHJldHVybiB0ZXh0U3RvcmUuZmlsdGVyKEJvb2xlYW4pLmpvaW4oJ1xcbicpXG4gIH1cbn0pKClcblxuZnVuY3Rpb24gYXBwbHlUb1NpbmdsZXRvblRhZyAoc3R5bGVFbGVtZW50LCBpbmRleCwgcmVtb3ZlLCBvYmopIHtcbiAgdmFyIGNzcyA9IHJlbW92ZSA/ICcnIDogb2JqLmNzc1xuXG4gIGlmIChzdHlsZUVsZW1lbnQuc3R5bGVTaGVldCkge1xuICAgIHN0eWxlRWxlbWVudC5zdHlsZVNoZWV0LmNzc1RleHQgPSByZXBsYWNlVGV4dChpbmRleCwgY3NzKVxuICB9IGVsc2Uge1xuICAgIHZhciBjc3NOb2RlID0gZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoY3NzKVxuICAgIHZhciBjaGlsZE5vZGVzID0gc3R5bGVFbGVtZW50LmNoaWxkTm9kZXNcbiAgICBpZiAoY2hpbGROb2Rlc1tpbmRleF0pIHN0eWxlRWxlbWVudC5yZW1vdmVDaGlsZChjaGlsZE5vZGVzW2luZGV4XSlcbiAgICBpZiAoY2hpbGROb2Rlcy5sZW5ndGgpIHtcbiAgICAgIHN0eWxlRWxlbWVudC5pbnNlcnRCZWZvcmUoY3NzTm9kZSwgY2hpbGROb2Rlc1tpbmRleF0pXG4gICAgfSBlbHNlIHtcbiAgICAgIHN0eWxlRWxlbWVudC5hcHBlbmRDaGlsZChjc3NOb2RlKVxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBhcHBseVRvVGFnIChzdHlsZUVsZW1lbnQsIG9iaikge1xuICB2YXIgY3NzID0gb2JqLmNzc1xuICB2YXIgbWVkaWEgPSBvYmoubWVkaWFcbiAgdmFyIHNvdXJjZU1hcCA9IG9iai5zb3VyY2VNYXBcblxuICBpZiAobWVkaWEpIHtcbiAgICBzdHlsZUVsZW1lbnQuc2V0QXR0cmlidXRlKCdtZWRpYScsIG1lZGlhKVxuICB9XG4gIGlmIChvcHRpb25zLnNzcklkKSB7XG4gICAgc3R5bGVFbGVtZW50LnNldEF0dHJpYnV0ZShzc3JJZEtleSwgb2JqLmlkKVxuICB9XG5cbiAgaWYgKHNvdXJjZU1hcCkge1xuICAgIC8vIGh0dHBzOi8vZGV2ZWxvcGVyLmNocm9tZS5jb20vZGV2dG9vbHMvZG9jcy9qYXZhc2NyaXB0LWRlYnVnZ2luZ1xuICAgIC8vIHRoaXMgbWFrZXMgc291cmNlIG1hcHMgaW5zaWRlIHN0eWxlIHRhZ3Mgd29yayBwcm9wZXJseSBpbiBDaHJvbWVcbiAgICBjc3MgKz0gJ1xcbi8qIyBzb3VyY2VVUkw9JyArIHNvdXJjZU1hcC5zb3VyY2VzWzBdICsgJyAqLydcbiAgICAvLyBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vYS8yNjYwMzg3NVxuICAgIGNzcyArPSAnXFxuLyojIHNvdXJjZU1hcHBpbmdVUkw9ZGF0YTphcHBsaWNhdGlvbi9qc29uO2Jhc2U2NCwnICsgYnRvYSh1bmVzY2FwZShlbmNvZGVVUklDb21wb25lbnQoSlNPTi5zdHJpbmdpZnkoc291cmNlTWFwKSkpKSArICcgKi8nXG4gIH1cblxuICBpZiAoc3R5bGVFbGVtZW50LnN0eWxlU2hlZXQpIHtcbiAgICBzdHlsZUVsZW1lbnQuc3R5bGVTaGVldC5jc3NUZXh0ID0gY3NzXG4gIH0gZWxzZSB7XG4gICAgd2hpbGUgKHN0eWxlRWxlbWVudC5maXJzdENoaWxkKSB7XG4gICAgICBzdHlsZUVsZW1lbnQucmVtb3ZlQ2hpbGQoc3R5bGVFbGVtZW50LmZpcnN0Q2hpbGQpXG4gICAgfVxuICAgIHN0eWxlRWxlbWVudC5hcHBlbmRDaGlsZChkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShjc3MpKVxuICB9XG59XG5cblxuLyoqKi8gfSlcblxuLyoqKioqKi8gXHR9KTtcbi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKioqKioqLyBcdC8vIFRoZSBtb2R1bGUgY2FjaGVcbi8qKioqKiovIFx0dmFyIF9fd2VicGFja19tb2R1bGVfY2FjaGVfXyA9IHt9O1xuLyoqKioqKi8gXHRcbi8qKioqKiovIFx0Ly8gVGhlIHJlcXVpcmUgZnVuY3Rpb25cbi8qKioqKiovIFx0ZnVuY3Rpb24gX193ZWJwYWNrX3JlcXVpcmVfXyhtb2R1bGVJZCkge1xuLyoqKioqKi8gXHRcdC8vIENoZWNrIGlmIG1vZHVsZSBpcyBpbiBjYWNoZVxuLyoqKioqKi8gXHRcdGlmKF9fd2VicGFja19tb2R1bGVfY2FjaGVfX1ttb2R1bGVJZF0pIHtcbi8qKioqKiovIFx0XHRcdHJldHVybiBfX3dlYnBhY2tfbW9kdWxlX2NhY2hlX19bbW9kdWxlSWRdLmV4cG9ydHM7XG4vKioqKioqLyBcdFx0fVxuLyoqKioqKi8gXHRcdC8vIENyZWF0ZSBhIG5ldyBtb2R1bGUgKGFuZCBwdXQgaXQgaW50byB0aGUgY2FjaGUpXG4vKioqKioqLyBcdFx0dmFyIG1vZHVsZSA9IF9fd2VicGFja19tb2R1bGVfY2FjaGVfX1ttb2R1bGVJZF0gPSB7XG4vKioqKioqLyBcdFx0XHRpZDogbW9kdWxlSWQsXG4vKioqKioqLyBcdFx0XHQvLyBubyBtb2R1bGUubG9hZGVkIG5lZWRlZFxuLyoqKioqKi8gXHRcdFx0ZXhwb3J0czoge31cbi8qKioqKiovIFx0XHR9O1xuLyoqKioqKi8gXHRcbi8qKioqKiovIFx0XHQvLyBFeGVjdXRlIHRoZSBtb2R1bGUgZnVuY3Rpb25cbi8qKioqKiovIFx0XHRfX3dlYnBhY2tfbW9kdWxlc19fW21vZHVsZUlkXShtb2R1bGUsIG1vZHVsZS5leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKTtcbi8qKioqKiovIFx0XG4vKioqKioqLyBcdFx0Ly8gUmV0dXJuIHRoZSBleHBvcnRzIG9mIHRoZSBtb2R1bGVcbi8qKioqKiovIFx0XHRyZXR1cm4gbW9kdWxlLmV4cG9ydHM7XG4vKioqKioqLyBcdH1cbi8qKioqKiovIFx0XG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKioqKi8gXHQvKiB3ZWJwYWNrL3J1bnRpbWUvY29tcGF0IGdldCBkZWZhdWx0IGV4cG9ydCAqL1xuLyoqKioqKi8gXHQoKCkgPT4ge1xuLyoqKioqKi8gXHRcdC8vIGdldERlZmF1bHRFeHBvcnQgZnVuY3Rpb24gZm9yIGNvbXBhdGliaWxpdHkgd2l0aCBub24taGFybW9ueSBtb2R1bGVzXG4vKioqKioqLyBcdFx0X193ZWJwYWNrX3JlcXVpcmVfXy5uID0gKG1vZHVsZSkgPT4ge1xuLyoqKioqKi8gXHRcdFx0dmFyIGdldHRlciA9IG1vZHVsZSAmJiBtb2R1bGUuX19lc01vZHVsZSA/XG4vKioqKioqLyBcdFx0XHRcdCgpID0+IChtb2R1bGVbJ2RlZmF1bHQnXSkgOlxuLyoqKioqKi8gXHRcdFx0XHQoKSA9PiAobW9kdWxlKTtcbi8qKioqKiovIFx0XHRcdF9fd2VicGFja19yZXF1aXJlX18uZChnZXR0ZXIsIHsgYTogZ2V0dGVyIH0pO1xuLyoqKioqKi8gXHRcdFx0cmV0dXJuIGdldHRlcjtcbi8qKioqKiovIFx0XHR9O1xuLyoqKioqKi8gXHR9KSgpO1xuLyoqKioqKi8gXHRcbi8qKioqKiovIFx0Lyogd2VicGFjay9ydW50aW1lL2RlZmluZSBwcm9wZXJ0eSBnZXR0ZXJzICovXG4vKioqKioqLyBcdCgoKSA9PiB7XG4vKioqKioqLyBcdFx0Ly8gZGVmaW5lIGdldHRlciBmdW5jdGlvbnMgZm9yIGhhcm1vbnkgZXhwb3J0c1xuLyoqKioqKi8gXHRcdF9fd2VicGFja19yZXF1aXJlX18uZCA9IChleHBvcnRzLCBkZWZpbml0aW9uKSA9PiB7XG4vKioqKioqLyBcdFx0XHRmb3IodmFyIGtleSBpbiBkZWZpbml0aW9uKSB7XG4vKioqKioqLyBcdFx0XHRcdGlmKF9fd2VicGFja19yZXF1aXJlX18ubyhkZWZpbml0aW9uLCBrZXkpICYmICFfX3dlYnBhY2tfcmVxdWlyZV9fLm8oZXhwb3J0cywga2V5KSkge1xuLyoqKioqKi8gXHRcdFx0XHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBrZXksIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBkZWZpbml0aW9uW2tleV0gfSk7XG4vKioqKioqLyBcdFx0XHRcdH1cbi8qKioqKiovIFx0XHRcdH1cbi8qKioqKiovIFx0XHR9O1xuLyoqKioqKi8gXHR9KSgpO1xuLyoqKioqKi8gXHRcbi8qKioqKiovIFx0Lyogd2VicGFjay9ydW50aW1lL2hhc093blByb3BlcnR5IHNob3J0aGFuZCAqL1xuLyoqKioqKi8gXHQoKCkgPT4ge1xuLyoqKioqKi8gXHRcdF9fd2VicGFja19yZXF1aXJlX18ubyA9IChvYmosIHByb3ApID0+IChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBwcm9wKSlcbi8qKioqKiovIFx0fSkoKTtcbi8qKioqKiovIFx0XG4vKioqKioqLyBcdC8qIHdlYnBhY2svcnVudGltZS9tYWtlIG5hbWVzcGFjZSBvYmplY3QgKi9cbi8qKioqKiovIFx0KCgpID0+IHtcbi8qKioqKiovIFx0XHQvLyBkZWZpbmUgX19lc01vZHVsZSBvbiBleHBvcnRzXG4vKioqKioqLyBcdFx0X193ZWJwYWNrX3JlcXVpcmVfXy5yID0gKGV4cG9ydHMpID0+IHtcbi8qKioqKiovIFx0XHRcdGlmKHR5cGVvZiBTeW1ib2wgIT09ICd1bmRlZmluZWQnICYmIFN5bWJvbC50b1N0cmluZ1RhZykge1xuLyoqKioqKi8gXHRcdFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgU3ltYm9sLnRvU3RyaW5nVGFnLCB7IHZhbHVlOiAnTW9kdWxlJyB9KTtcbi8qKioqKiovIFx0XHRcdH1cbi8qKioqKiovIFx0XHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG4vKioqKioqLyBcdFx0fTtcbi8qKioqKiovIFx0fSkoKTtcbi8qKioqKiovIFx0XG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKioqKi8gXHRcbi8qKioqKiovIFx0Ly8gc3RhcnR1cFxuLyoqKioqKi8gXHQvLyBMb2FkIGVudHJ5IG1vZHVsZSBhbmQgcmV0dXJuIGV4cG9ydHNcbi8qKioqKiovIFx0Ly8gVGhpcyBlbnRyeSBtb2R1bGUgZG9lc24ndCB0ZWxsIGFib3V0IGl0J3MgdG9wLWxldmVsIGRlY2xhcmF0aW9ucyBzbyBpdCBjYW4ndCBiZSBpbmxpbmVkXG4vKioqKioqLyBcdHZhciBfX3dlYnBhY2tfZXhwb3J0c19fID0gX193ZWJwYWNrX3JlcXVpcmVfXyg4NTEpO1xuLyoqKioqKi8gXHRcbi8qKioqKiovIFx0cmV0dXJuIF9fd2VicGFja19leHBvcnRzX187XG4vKioqKioqLyB9KSgpXG47XG59KTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXRyYWRpbmctdnVlLmpzLm1hcCIsIi8qIVxuICogVFZKUyBPdmVybGF5cyAtIHYwLjUuMCAtIEZyaSBKdWwgMDkgMjAyMVxuICogICAgIGh0dHBzOi8vZ2l0aHViLmNvbS90dmpzeC90cmFkaW5nLXZ1ZS1qc1xuICogICAgIENvcHlyaWdodCAoYykgMjAyMCBjNDUxIENvZGUncyBBbGwgUmlnaHQ7XG4gKiAgICAgTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlXG4gKi9cbihmdW5jdGlvbiB3ZWJwYWNrVW5pdmVyc2FsTW9kdWxlRGVmaW5pdGlvbihyb290LCBmYWN0b3J5KSB7XG4gICAgaWYgKCFyb290Wyd0cmFkaW5nLXZ1ZS1qcyddKSB7XG4gICAgICAgIHJvb3RbJ3RyYWRpbmctdnVlLWpzJ10gPSByb290WydUcmFkaW5nVnVlSnMnXVxuICAgIH1cblx0aWYodHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgPT09ICdvYmplY3QnKVxuXHRcdG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeShyZXF1aXJlKFwidHJhZGluZy12dWUtanNcIikpO1xuXHRlbHNlIGlmKHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZClcblx0XHRkZWZpbmUoW1widHJhZGluZy12dWUtanNcIl0sIGZhY3RvcnkpO1xuXHRlbHNlIGlmKHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0Jylcblx0XHRleHBvcnRzW1wiVHZqc092ZXJsYXlzXCJdID0gZmFjdG9yeShyZXF1aXJlKFwidHJhZGluZy12dWUtanNcIikpO1xuXHRlbHNlXG5cdFx0cm9vdFtcIlR2anNPdmVybGF5c1wiXSA9IGZhY3Rvcnkocm9vdFtcInRyYWRpbmctdnVlLWpzXCJdKTtcbn0pKHNlbGYsIGZ1bmN0aW9uKF9fV0VCUEFDS19FWFRFUk5BTF9NT0RVTEVfXzk1NF9fKSB7XG5yZXR1cm4gLyoqKioqKi8gKCgpID0+IHsgLy8gd2VicGFja0Jvb3RzdHJhcFxuLyoqKioqKi8gXHRcInVzZSBzdHJpY3RcIjtcbi8qKioqKiovIFx0dmFyIF9fd2VicGFja19tb2R1bGVzX18gPSAoe1xuXG4vKioqLyA5NTQ6XG4vKioqLyAoKG1vZHVsZSkgPT4ge1xuXG5tb2R1bGUuZXhwb3J0cyA9IF9fV0VCUEFDS19FWFRFUk5BTF9NT0RVTEVfXzk1NF9fO1xuXG4vKioqLyB9KVxuXG4vKioqKioqLyBcdH0pO1xuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKioqKiovIFx0Ly8gVGhlIG1vZHVsZSBjYWNoZVxuLyoqKioqKi8gXHR2YXIgX193ZWJwYWNrX21vZHVsZV9jYWNoZV9fID0ge307XG4vKioqKioqLyBcdFxuLyoqKioqKi8gXHQvLyBUaGUgcmVxdWlyZSBmdW5jdGlvblxuLyoqKioqKi8gXHRmdW5jdGlvbiBfX3dlYnBhY2tfcmVxdWlyZV9fKG1vZHVsZUlkKSB7XG4vKioqKioqLyBcdFx0Ly8gQ2hlY2sgaWYgbW9kdWxlIGlzIGluIGNhY2hlXG4vKioqKioqLyBcdFx0dmFyIGNhY2hlZE1vZHVsZSA9IF9fd2VicGFja19tb2R1bGVfY2FjaGVfX1ttb2R1bGVJZF07XG4vKioqKioqLyBcdFx0aWYgKGNhY2hlZE1vZHVsZSAhPT0gdW5kZWZpbmVkKSB7XG4vKioqKioqLyBcdFx0XHRyZXR1cm4gY2FjaGVkTW9kdWxlLmV4cG9ydHM7XG4vKioqKioqLyBcdFx0fVxuLyoqKioqKi8gXHRcdC8vIENyZWF0ZSBhIG5ldyBtb2R1bGUgKGFuZCBwdXQgaXQgaW50byB0aGUgY2FjaGUpXG4vKioqKioqLyBcdFx0dmFyIG1vZHVsZSA9IF9fd2VicGFja19tb2R1bGVfY2FjaGVfX1ttb2R1bGVJZF0gPSB7XG4vKioqKioqLyBcdFx0XHQvLyBubyBtb2R1bGUuaWQgbmVlZGVkXG4vKioqKioqLyBcdFx0XHQvLyBubyBtb2R1bGUubG9hZGVkIG5lZWRlZFxuLyoqKioqKi8gXHRcdFx0ZXhwb3J0czoge31cbi8qKioqKiovIFx0XHR9O1xuLyoqKioqKi8gXHRcbi8qKioqKiovIFx0XHQvLyBFeGVjdXRlIHRoZSBtb2R1bGUgZnVuY3Rpb25cbi8qKioqKiovIFx0XHRfX3dlYnBhY2tfbW9kdWxlc19fW21vZHVsZUlkXShtb2R1bGUsIG1vZHVsZS5leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKTtcbi8qKioqKiovIFx0XG4vKioqKioqLyBcdFx0Ly8gUmV0dXJuIHRoZSBleHBvcnRzIG9mIHRoZSBtb2R1bGVcbi8qKioqKiovIFx0XHRyZXR1cm4gbW9kdWxlLmV4cG9ydHM7XG4vKioqKioqLyBcdH1cbi8qKioqKiovIFx0XG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKioqKi8gXHQvKiB3ZWJwYWNrL3J1bnRpbWUvZGVmaW5lIHByb3BlcnR5IGdldHRlcnMgKi9cbi8qKioqKiovIFx0KCgpID0+IHtcbi8qKioqKiovIFx0XHQvLyBkZWZpbmUgZ2V0dGVyIGZ1bmN0aW9ucyBmb3IgaGFybW9ueSBleHBvcnRzXG4vKioqKioqLyBcdFx0X193ZWJwYWNrX3JlcXVpcmVfXy5kID0gKGV4cG9ydHMsIGRlZmluaXRpb24pID0+IHtcbi8qKioqKiovIFx0XHRcdGZvcih2YXIga2V5IGluIGRlZmluaXRpb24pIHtcbi8qKioqKiovIFx0XHRcdFx0aWYoX193ZWJwYWNrX3JlcXVpcmVfXy5vKGRlZmluaXRpb24sIGtleSkgJiYgIV9fd2VicGFja19yZXF1aXJlX18ubyhleHBvcnRzLCBrZXkpKSB7XG4vKioqKioqLyBcdFx0XHRcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIGtleSwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGRlZmluaXRpb25ba2V5XSB9KTtcbi8qKioqKiovIFx0XHRcdFx0fVxuLyoqKioqKi8gXHRcdFx0fVxuLyoqKioqKi8gXHRcdH07XG4vKioqKioqLyBcdH0pKCk7XG4vKioqKioqLyBcdFxuLyoqKioqKi8gXHQvKiB3ZWJwYWNrL3J1bnRpbWUvaGFzT3duUHJvcGVydHkgc2hvcnRoYW5kICovXG4vKioqKioqLyBcdCgoKSA9PiB7XG4vKioqKioqLyBcdFx0X193ZWJwYWNrX3JlcXVpcmVfXy5vID0gKG9iaiwgcHJvcCkgPT4gKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIHByb3ApKVxuLyoqKioqKi8gXHR9KSgpO1xuLyoqKioqKi8gXHRcbi8qKioqKiovIFx0Lyogd2VicGFjay9ydW50aW1lL21ha2UgbmFtZXNwYWNlIG9iamVjdCAqL1xuLyoqKioqKi8gXHQoKCkgPT4ge1xuLyoqKioqKi8gXHRcdC8vIGRlZmluZSBfX2VzTW9kdWxlIG9uIGV4cG9ydHNcbi8qKioqKiovIFx0XHRfX3dlYnBhY2tfcmVxdWlyZV9fLnIgPSAoZXhwb3J0cykgPT4ge1xuLyoqKioqKi8gXHRcdFx0aWYodHlwZW9mIFN5bWJvbCAhPT0gJ3VuZGVmaW5lZCcgJiYgU3ltYm9sLnRvU3RyaW5nVGFnKSB7XG4vKioqKioqLyBcdFx0XHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBTeW1ib2wudG9TdHJpbmdUYWcsIHsgdmFsdWU6ICdNb2R1bGUnIH0pO1xuLyoqKioqKi8gXHRcdFx0fVxuLyoqKioqKi8gXHRcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcbi8qKioqKiovIFx0XHR9O1xuLyoqKioqKi8gXHR9KSgpO1xuLyoqKioqKi8gXHRcbi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG52YXIgX193ZWJwYWNrX2V4cG9ydHNfXyA9IHt9O1xuLy8gVGhpcyBlbnRyeSBuZWVkIHRvIGJlIHdyYXBwZWQgaW4gYW4gSUlGRSBiZWNhdXNlIGl0IG5lZWQgdG8gYmUgaXNvbGF0ZWQgYWdhaW5zdCBvdGhlciBtb2R1bGVzIGluIHRoZSBjaHVuay5cbigoKSA9PiB7XG4vLyBFU00gQ09NUEFUIEZMQUdcbl9fd2VicGFja19yZXF1aXJlX18ucihfX3dlYnBhY2tfZXhwb3J0c19fKTtcblxuLy8gRVhQT1JUU1xuX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIHtcbiAgXCJBTE1BXCI6ICgpID0+ICgvKiByZWV4cG9ydCAqLyBBTE1BKSxcbiAgXCJBVFJcIjogKCkgPT4gKC8qIHJlZXhwb3J0ICovIEFUUiksXG4gIFwiQVRScFwiOiAoKSA9PiAoLyogcmVleHBvcnQgKi8gQVRScCksXG4gIFwiQXJlYTUxXCI6ICgpID0+ICgvKiByZWV4cG9ydCAqLyBBcmVhNTEpLFxuICBcIkJCXCI6ICgpID0+ICgvKiByZWV4cG9ydCAqLyBCQiksXG4gIFwiQkJXXCI6ICgpID0+ICgvKiByZWV4cG9ydCAqLyBCQlcpLFxuICBcIkNDSVwiOiAoKSA9PiAoLyogcmVleHBvcnQgKi8gQ0NJKSxcbiAgXCJDTU9cIjogKCkgPT4gKC8qIHJlZXhwb3J0ICovIENNTyksXG4gIFwiQ09HXCI6ICgpID0+ICgvKiByZWV4cG9ydCAqLyBDT0cpLFxuICBcIkRIaXN0b2dyYW1cIjogKCkgPT4gKC8qIHJlZXhwb3J0ICovIERIaXN0b2dyYW0pLFxuICBcIkRNSVwiOiAoKSA9PiAoLyogcmVleHBvcnQgKi8gRE1JKSxcbiAgXCJFTUFcIjogKCkgPT4gKC8qIHJlZXhwb3J0ICovIEVNQSksXG4gIFwiSE1BXCI6ICgpID0+ICgvKiByZWV4cG9ydCAqLyBITUEpLFxuICBcIkhpc3RvZ3JhbVwiOiAoKSA9PiAoLyogcmVleHBvcnQgKi8gSGlzdG9ncmFtKSxcbiAgXCJJY2hpXCI6ICgpID0+ICgvKiByZWV4cG9ydCAqLyBJY2hpKSxcbiAgXCJJY2hpbW9rdVwiOiAoKSA9PiAoLyogcmVleHBvcnQgKi8gSWNoaW1va3UpLFxuICBcIktDXCI6ICgpID0+ICgvKiByZWV4cG9ydCAqLyBLQyksXG4gIFwiS0NXXCI6ICgpID0+ICgvKiByZWV4cG9ydCAqLyBLQ1cpLFxuICBcIkxvbmdTaG9ydFRyYWRlc1wiOiAoKSA9PiAoLyogcmVleHBvcnQgKi8gTG9uZ1Nob3J0VHJhZGVzKSxcbiAgXCJNQUNEXCI6ICgpID0+ICgvKiByZWV4cG9ydCAqLyBNQUNEKSxcbiAgXCJNRklcIjogKCkgPT4gKC8qIHJlZXhwb3J0ICovIE1GSSksXG4gIFwiTU9NXCI6ICgpID0+ICgvKiByZWV4cG9ydCAqLyBNT00pLFxuICBcIk1hcmtlcnNcIjogKCkgPT4gKC8qIHJlZXhwb3J0ICovIE1hcmtlcnMpLFxuICBcIlBsb3RDcm9zc1wiOiAoKSA9PiAoLyogcmVleHBvcnQgKi8gUGxvdENyb3NzKSxcbiAgXCJST0NcIjogKCkgPT4gKC8qIHJlZXhwb3J0ICovIFJPQyksXG4gIFwiUlNJXCI6ICgpID0+ICgvKiByZWV4cG9ydCAqLyBSU0kpLFxuICBcIlJpYmJvblwiOiAoKSA9PiAoLyogcmVleHBvcnQgKi8gUmliYm9uKSxcbiAgXCJTQVJcIjogKCkgPT4gKC8qIHJlZXhwb3J0ICovIFNBUiksXG4gIFwiU01BXCI6ICgpID0+ICgvKiByZWV4cG9ydCAqLyBTTUEpLFxuICBcIlNXTUFcIjogKCkgPT4gKC8qIHJlZXhwb3J0ICovIFNXTUEpLFxuICBcIlN0b2NoXCI6ICgpID0+ICgvKiByZWV4cG9ydCAqLyBTdG9jaCksXG4gIFwiVFNJXCI6ICgpID0+ICgvKiByZWV4cG9ydCAqLyBUU0kpLFxuICBcIlRyYWRlc1BsdXNcIjogKCkgPT4gKC8qIHJlZXhwb3J0ICovIFRyYWRlc1BsdXMpLFxuICBcIlZXTUFcIjogKCkgPT4gKC8qIHJlZXhwb3J0ICovIFZXTUEpLFxuICBcIldpbGxpYW1zUlwiOiAoKSA9PiAoLyogcmVleHBvcnQgKi8gV2lsbGlhbXNSKSxcbiAgXCJYT2hsY0JhcnNcIjogKCkgPT4gKC8qIHJlZXhwb3J0ICovIFhPaGxjQmFycyksXG4gIFwiZGVmYXVsdFwiOiAoKSA9PiAoLyogYmluZGluZyAqLyBpbmRleF9wcm9kKVxufSk7XG5cbi8vIEVYVEVSTkFMIE1PRFVMRTogZXh0ZXJuYWwgXCJ0cmFkaW5nLXZ1ZS1qc1wiXG52YXIgZXh0ZXJuYWxfdHJhZGluZ192dWVfanNfID0gX193ZWJwYWNrX3JlcXVpcmVfXyg5NTQpO1xuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vbm9kZV9tb2R1bGVzL2JhYmVsLWxvYWRlci9saWIvaW5kZXguanMhLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvaW5kZXguanM/P3Z1ZS1sb2FkZXItb3B0aW9ucyEuL3NyYy9vdmVybGF5cy9BTE1BL0FMTUEudnVlP3Z1ZSZ0eXBlPXNjcmlwdCZsYW5nPWpzJlxuXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIGNvbnN0IEFMTUF2dWVfdHlwZV9zY3JpcHRfbGFuZ19qc18gPSAoe1xuICBuYW1lOiAnQUxNQScsXG4gIG1peGluczogW2V4dGVybmFsX3RyYWRpbmdfdnVlX2pzXy5PdmVybGF5XSxcbiAgbWV0aG9kczoge1xuICAgIG1ldGFfaW5mbzogZnVuY3Rpb24gbWV0YV9pbmZvKCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgYXV0aG9yOiAnU3RkU3F1YWQnLFxuICAgICAgICB2ZXJzaW9uOiAnMS4wLjAnLFxuICAgICAgICBkZXNjOiAnQXJuYXVkIExlZ291eCBNb3ZpbmcgQXZlcmFnZScsXG4gICAgICAgIHByZXNldDoge1xuICAgICAgICAgIG5hbWU6ICdBTE1BICRsZW5ndGggJG9mZnNldCAkc2lnbWEnLFxuICAgICAgICAgIHNpZGU6ICdvbmNoYXJ0JyxcbiAgICAgICAgICBzZXR0aW5nczoge1xuICAgICAgICAgICAgbGluZVdpZHRoOiAwLjc1LFxuICAgICAgICAgICAgY29sb3I6ICcjNTU5ZGUwJ1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9LFxuICAgIHVzZV9mb3I6IGZ1bmN0aW9uIHVzZV9mb3IoKSB7XG4gICAgICByZXR1cm4gWydBTE1BJ107XG4gICAgfSxcbiAgICBjYWxjOiBmdW5jdGlvbiBjYWxjKCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgcHJvcHM6IHtcbiAgICAgICAgICBsZW5ndGg6IHtcbiAgICAgICAgICAgIGRlZjogMTAsXG4gICAgICAgICAgICB0ZXh0OiAnTGVuZ3RoJ1xuICAgICAgICAgIH0sXG4gICAgICAgICAgb2Zmc2V0OiB7XG4gICAgICAgICAgICBkZWY6IDAuOSxcbiAgICAgICAgICAgIHRleHQ6ICdPZmZzZXQnXG4gICAgICAgICAgfSxcbiAgICAgICAgICBzaWdtYToge1xuICAgICAgICAgICAgZGVmOiA1LFxuICAgICAgICAgICAgdGV4dDogJ1NpZ21hJ1xuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgY29uZjoge1xuICAgICAgICAgIHJlbmRlcmVyOiAnU3BsaW5lJ1xuICAgICAgICB9LFxuICAgICAgICB1cGRhdGU6IFwiXFxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gYWxtYShjbG9zZSwgbGVuZ3RoLCBvZmZzZXQsIHNpZ21hKVswXVxcbiAgICAgICAgICAgICAgICBcIlxuICAgICAgfTtcbiAgICB9XG4gIH1cbn0pO1xuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL292ZXJsYXlzL0FMTUEvQUxNQS52dWU/dnVlJnR5cGU9c2NyaXB0Jmxhbmc9anMmXG4gLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyBjb25zdCBBTE1BX0FMTUF2dWVfdHlwZV9zY3JpcHRfbGFuZ19qc18gPSAoQUxNQXZ1ZV90eXBlX3NjcmlwdF9sYW5nX2pzXyk7IFxuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3J1bnRpbWUvY29tcG9uZW50Tm9ybWFsaXplci5qc1xuLyogZ2xvYmFscyBfX1ZVRV9TU1JfQ09OVEVYVF9fICovXG5cbi8vIElNUE9SVEFOVDogRG8gTk9UIHVzZSBFUzIwMTUgZmVhdHVyZXMgaW4gdGhpcyBmaWxlIChleGNlcHQgZm9yIG1vZHVsZXMpLlxuLy8gVGhpcyBtb2R1bGUgaXMgYSBydW50aW1lIHV0aWxpdHkgZm9yIGNsZWFuZXIgY29tcG9uZW50IG1vZHVsZSBvdXRwdXQgYW5kIHdpbGxcbi8vIGJlIGluY2x1ZGVkIGluIHRoZSBmaW5hbCB3ZWJwYWNrIHVzZXIgYnVuZGxlLlxuXG5mdW5jdGlvbiBub3JtYWxpemVDb21wb25lbnQgKFxuICBzY3JpcHRFeHBvcnRzLFxuICByZW5kZXIsXG4gIHN0YXRpY1JlbmRlckZucyxcbiAgZnVuY3Rpb25hbFRlbXBsYXRlLFxuICBpbmplY3RTdHlsZXMsXG4gIHNjb3BlSWQsXG4gIG1vZHVsZUlkZW50aWZpZXIsIC8qIHNlcnZlciBvbmx5ICovXG4gIHNoYWRvd01vZGUgLyogdnVlLWNsaSBvbmx5ICovXG4pIHtcbiAgLy8gVnVlLmV4dGVuZCBjb25zdHJ1Y3RvciBleHBvcnQgaW50ZXJvcFxuICB2YXIgb3B0aW9ucyA9IHR5cGVvZiBzY3JpcHRFeHBvcnRzID09PSAnZnVuY3Rpb24nXG4gICAgPyBzY3JpcHRFeHBvcnRzLm9wdGlvbnNcbiAgICA6IHNjcmlwdEV4cG9ydHNcblxuICAvLyByZW5kZXIgZnVuY3Rpb25zXG4gIGlmIChyZW5kZXIpIHtcbiAgICBvcHRpb25zLnJlbmRlciA9IHJlbmRlclxuICAgIG9wdGlvbnMuc3RhdGljUmVuZGVyRm5zID0gc3RhdGljUmVuZGVyRm5zXG4gICAgb3B0aW9ucy5fY29tcGlsZWQgPSB0cnVlXG4gIH1cblxuICAvLyBmdW5jdGlvbmFsIHRlbXBsYXRlXG4gIGlmIChmdW5jdGlvbmFsVGVtcGxhdGUpIHtcbiAgICBvcHRpb25zLmZ1bmN0aW9uYWwgPSB0cnVlXG4gIH1cblxuICAvLyBzY29wZWRJZFxuICBpZiAoc2NvcGVJZCkge1xuICAgIG9wdGlvbnMuX3Njb3BlSWQgPSAnZGF0YS12LScgKyBzY29wZUlkXG4gIH1cblxuICB2YXIgaG9va1xuICBpZiAobW9kdWxlSWRlbnRpZmllcikgeyAvLyBzZXJ2ZXIgYnVpbGRcbiAgICBob29rID0gZnVuY3Rpb24gKGNvbnRleHQpIHtcbiAgICAgIC8vIDIuMyBpbmplY3Rpb25cbiAgICAgIGNvbnRleHQgPVxuICAgICAgICBjb250ZXh0IHx8IC8vIGNhY2hlZCBjYWxsXG4gICAgICAgICh0aGlzLiR2bm9kZSAmJiB0aGlzLiR2bm9kZS5zc3JDb250ZXh0KSB8fCAvLyBzdGF0ZWZ1bFxuICAgICAgICAodGhpcy5wYXJlbnQgJiYgdGhpcy5wYXJlbnQuJHZub2RlICYmIHRoaXMucGFyZW50LiR2bm9kZS5zc3JDb250ZXh0KSAvLyBmdW5jdGlvbmFsXG4gICAgICAvLyAyLjIgd2l0aCBydW5Jbk5ld0NvbnRleHQ6IHRydWVcbiAgICAgIGlmICghY29udGV4dCAmJiB0eXBlb2YgX19WVUVfU1NSX0NPTlRFWFRfXyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgY29udGV4dCA9IF9fVlVFX1NTUl9DT05URVhUX19cbiAgICAgIH1cbiAgICAgIC8vIGluamVjdCBjb21wb25lbnQgc3R5bGVzXG4gICAgICBpZiAoaW5qZWN0U3R5bGVzKSB7XG4gICAgICAgIGluamVjdFN0eWxlcy5jYWxsKHRoaXMsIGNvbnRleHQpXG4gICAgICB9XG4gICAgICAvLyByZWdpc3RlciBjb21wb25lbnQgbW9kdWxlIGlkZW50aWZpZXIgZm9yIGFzeW5jIGNodW5rIGluZmVycmVuY2VcbiAgICAgIGlmIChjb250ZXh0ICYmIGNvbnRleHQuX3JlZ2lzdGVyZWRDb21wb25lbnRzKSB7XG4gICAgICAgIGNvbnRleHQuX3JlZ2lzdGVyZWRDb21wb25lbnRzLmFkZChtb2R1bGVJZGVudGlmaWVyKVxuICAgICAgfVxuICAgIH1cbiAgICAvLyB1c2VkIGJ5IHNzciBpbiBjYXNlIGNvbXBvbmVudCBpcyBjYWNoZWQgYW5kIGJlZm9yZUNyZWF0ZVxuICAgIC8vIG5ldmVyIGdldHMgY2FsbGVkXG4gICAgb3B0aW9ucy5fc3NyUmVnaXN0ZXIgPSBob29rXG4gIH0gZWxzZSBpZiAoaW5qZWN0U3R5bGVzKSB7XG4gICAgaG9vayA9IHNoYWRvd01vZGVcbiAgICAgID8gZnVuY3Rpb24gKCkge1xuICAgICAgICBpbmplY3RTdHlsZXMuY2FsbChcbiAgICAgICAgICB0aGlzLFxuICAgICAgICAgIChvcHRpb25zLmZ1bmN0aW9uYWwgPyB0aGlzLnBhcmVudCA6IHRoaXMpLiRyb290LiRvcHRpb25zLnNoYWRvd1Jvb3RcbiAgICAgICAgKVxuICAgICAgfVxuICAgICAgOiBpbmplY3RTdHlsZXNcbiAgfVxuXG4gIGlmIChob29rKSB7XG4gICAgaWYgKG9wdGlvbnMuZnVuY3Rpb25hbCkge1xuICAgICAgLy8gZm9yIHRlbXBsYXRlLW9ubHkgaG90LXJlbG9hZCBiZWNhdXNlIGluIHRoYXQgY2FzZSB0aGUgcmVuZGVyIGZuIGRvZXNuJ3RcbiAgICAgIC8vIGdvIHRocm91Z2ggdGhlIG5vcm1hbGl6ZXJcbiAgICAgIG9wdGlvbnMuX2luamVjdFN0eWxlcyA9IGhvb2tcbiAgICAgIC8vIHJlZ2lzdGVyIGZvciBmdW5jdGlvbmFsIGNvbXBvbmVudCBpbiB2dWUgZmlsZVxuICAgICAgdmFyIG9yaWdpbmFsUmVuZGVyID0gb3B0aW9ucy5yZW5kZXJcbiAgICAgIG9wdGlvbnMucmVuZGVyID0gZnVuY3Rpb24gcmVuZGVyV2l0aFN0eWxlSW5qZWN0aW9uIChoLCBjb250ZXh0KSB7XG4gICAgICAgIGhvb2suY2FsbChjb250ZXh0KVxuICAgICAgICByZXR1cm4gb3JpZ2luYWxSZW5kZXIoaCwgY29udGV4dClcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gaW5qZWN0IGNvbXBvbmVudCByZWdpc3RyYXRpb24gYXMgYmVmb3JlQ3JlYXRlIGhvb2tcbiAgICAgIHZhciBleGlzdGluZyA9IG9wdGlvbnMuYmVmb3JlQ3JlYXRlXG4gICAgICBvcHRpb25zLmJlZm9yZUNyZWF0ZSA9IGV4aXN0aW5nXG4gICAgICAgID8gW10uY29uY2F0KGV4aXN0aW5nLCBob29rKVxuICAgICAgICA6IFtob29rXVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiB7XG4gICAgZXhwb3J0czogc2NyaXB0RXhwb3J0cyxcbiAgICBvcHRpb25zOiBvcHRpb25zXG4gIH1cbn1cblxuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL292ZXJsYXlzL0FMTUEvQUxNQS52dWVcbnZhciByZW5kZXIsIHN0YXRpY1JlbmRlckZuc1xuO1xuXG5cblxuLyogbm9ybWFsaXplIGNvbXBvbmVudCAqL1xuO1xudmFyIGNvbXBvbmVudCA9IG5vcm1hbGl6ZUNvbXBvbmVudChcbiAgQUxNQV9BTE1BdnVlX3R5cGVfc2NyaXB0X2xhbmdfanNfLFxuICByZW5kZXIsXG4gIHN0YXRpY1JlbmRlckZucyxcbiAgZmFsc2UsXG4gIG51bGwsXG4gIG51bGwsXG4gIG51bGxcbiAgXG4pXG5cbi8qIGhvdCByZWxvYWQgKi9cbmlmIChmYWxzZSkgeyB2YXIgYXBpOyB9XG5jb21wb25lbnQub3B0aW9ucy5fX2ZpbGUgPSBcInNyYy9vdmVybGF5cy9BTE1BL0FMTUEudnVlXCJcbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gY29uc3QgQUxNQSA9IChjb21wb25lbnQuZXhwb3J0cyk7XG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9ub2RlX21vZHVsZXMvYmFiZWwtbG9hZGVyL2xpYi9pbmRleC5qcyEuL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9pbmRleC5qcz8/dnVlLWxvYWRlci1vcHRpb25zIS4vc3JjL292ZXJsYXlzL0FUUi9BVFIudnVlP3Z1ZSZ0eXBlPXNjcmlwdCZsYW5nPWpzJlxuXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIGNvbnN0IEFUUnZ1ZV90eXBlX3NjcmlwdF9sYW5nX2pzXyA9ICh7XG4gIG5hbWU6ICdBVFInLFxuICBtaXhpbnM6IFtleHRlcm5hbF90cmFkaW5nX3Z1ZV9qc18uT3ZlcmxheV0sXG4gIG1ldGhvZHM6IHtcbiAgICBtZXRhX2luZm86IGZ1bmN0aW9uIG1ldGFfaW5mbygpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGF1dGhvcjogJ1N0ZFNxdWFkJyxcbiAgICAgICAgdmVyc2lvbjogJzEuMC4wJyxcbiAgICAgICAgZGVzYzogJ0F2ZXJhZ2UgVHJ1ZSBSYW5nZScsXG4gICAgICAgIHByZXNldDoge1xuICAgICAgICAgIG5hbWU6ICdBVFIgJGxlbmd0aCcsXG4gICAgICAgICAgc2lkZTogJ29mZmNoYXJ0JyxcbiAgICAgICAgICBzZXR0aW5nczoge1xuICAgICAgICAgICAgbGluZVdpZHRoOiAwLjc1LFxuICAgICAgICAgICAgY29sb3I6ICcjZTUyNDY4J1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9LFxuICAgIHVzZV9mb3I6IGZ1bmN0aW9uIHVzZV9mb3IoKSB7XG4gICAgICByZXR1cm4gWydBVFInXTtcbiAgICB9LFxuICAgIGNhbGM6IGZ1bmN0aW9uIGNhbGMoKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBwcm9wczoge1xuICAgICAgICAgIGxlbmd0aDoge1xuICAgICAgICAgICAgZGVmOiAxNSxcbiAgICAgICAgICAgIHRleHQ6ICdMZW5ndGgnXG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBjb25mOiB7XG4gICAgICAgICAgcmVuZGVyZXI6ICdTcGxpbmUnXG4gICAgICAgIH0sXG4gICAgICAgIHVwZGF0ZTogXCJcXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBhdHIobGVuZ3RoKVswXVxcbiAgICAgICAgICAgICAgICBcIlxuICAgICAgfTtcbiAgICB9XG4gIH1cbn0pO1xuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL292ZXJsYXlzL0FUUi9BVFIudnVlP3Z1ZSZ0eXBlPXNjcmlwdCZsYW5nPWpzJlxuIC8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gY29uc3QgQVRSX0FUUnZ1ZV90eXBlX3NjcmlwdF9sYW5nX2pzXyA9IChBVFJ2dWVfdHlwZV9zY3JpcHRfbGFuZ19qc18pOyBcbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9vdmVybGF5cy9BVFIvQVRSLnZ1ZVxudmFyIEFUUl9yZW5kZXIsIEFUUl9zdGF0aWNSZW5kZXJGbnNcbjtcblxuXG5cbi8qIG5vcm1hbGl6ZSBjb21wb25lbnQgKi9cbjtcbnZhciBBVFJfY29tcG9uZW50ID0gbm9ybWFsaXplQ29tcG9uZW50KFxuICBBVFJfQVRSdnVlX3R5cGVfc2NyaXB0X2xhbmdfanNfLFxuICBBVFJfcmVuZGVyLFxuICBBVFJfc3RhdGljUmVuZGVyRm5zLFxuICBmYWxzZSxcbiAgbnVsbCxcbiAgbnVsbCxcbiAgbnVsbFxuICBcbilcblxuLyogaG90IHJlbG9hZCAqL1xuaWYgKGZhbHNlKSB7IHZhciBBVFJfYXBpOyB9XG5BVFJfY29tcG9uZW50Lm9wdGlvbnMuX19maWxlID0gXCJzcmMvb3ZlcmxheXMvQVRSL0FUUi52dWVcIlxuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyBjb25zdCBBVFIgPSAoQVRSX2NvbXBvbmVudC5leHBvcnRzKTtcbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL25vZGVfbW9kdWxlcy9iYWJlbC1sb2FkZXIvbGliL2luZGV4LmpzIS4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL2luZGV4LmpzPz92dWUtbG9hZGVyLW9wdGlvbnMhLi9zcmMvb3ZlcmxheXMvQVRScC9BVFJwLnZ1ZT92dWUmdHlwZT1zY3JpcHQmbGFuZz1qcyZcblxuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyBjb25zdCBBVFJwdnVlX3R5cGVfc2NyaXB0X2xhbmdfanNfID0gKHtcbiAgbmFtZTogJ0FUUnAnLFxuICBtaXhpbnM6IFtleHRlcm5hbF90cmFkaW5nX3Z1ZV9qc18uT3ZlcmxheV0sXG4gIG1ldGhvZHM6IHtcbiAgICBtZXRhX2luZm86IGZ1bmN0aW9uIG1ldGFfaW5mbygpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGF1dGhvcjogJ1N0ZFNxdWFkJyxcbiAgICAgICAgdmVyc2lvbjogJzEuMC4wJyxcbiAgICAgICAgZGVzYzogJ0F2ZXJhZ2UgVHJ1ZSBSYW5nZSwgJScsXG4gICAgICAgIHByZXNldDoge1xuICAgICAgICAgIG5hbWU6ICdBVFIlICRsZW5ndGgnLFxuICAgICAgICAgIHNpZGU6ICdvZmZjaGFydCcsXG4gICAgICAgICAgc2V0dGluZ3M6IHtcbiAgICAgICAgICAgIGxpbmVXaWR0aDogMC43NSxcbiAgICAgICAgICAgIGNvbG9yOiAnI2Y0NDMzNidcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfSxcbiAgICB1c2VfZm9yOiBmdW5jdGlvbiB1c2VfZm9yKCkge1xuICAgICAgcmV0dXJuIFsnQVRScCddO1xuICAgIH0sXG4gICAgY2FsYzogZnVuY3Rpb24gY2FsYygpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHByb3BzOiB7XG4gICAgICAgICAgbGVuZ3RoOiB7XG4gICAgICAgICAgICBkZWY6IDE1LFxuICAgICAgICAgICAgdGV4dDogJ0xlbmd0aCdcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIGNvbmY6IHtcbiAgICAgICAgICByZW5kZXJlcjogJ1NwbGluZSdcbiAgICAgICAgfSxcbiAgICAgICAgdXBkYXRlOiBcIlxcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIDEwMCAqIGF0cihsZW5ndGgpWzBdIC8gY2xvc2VbMF1cXG4gICAgICAgICAgICAgICAgXCJcbiAgICAgIH07XG4gICAgfVxuICB9XG59KTtcbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9vdmVybGF5cy9BVFJwL0FUUnAudnVlP3Z1ZSZ0eXBlPXNjcmlwdCZsYW5nPWpzJlxuIC8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gY29uc3QgQVRScF9BVFJwdnVlX3R5cGVfc2NyaXB0X2xhbmdfanNfID0gKEFUUnB2dWVfdHlwZV9zY3JpcHRfbGFuZ19qc18pOyBcbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9vdmVybGF5cy9BVFJwL0FUUnAudnVlXG52YXIgQVRScF9yZW5kZXIsIEFUUnBfc3RhdGljUmVuZGVyRm5zXG47XG5cblxuXG4vKiBub3JtYWxpemUgY29tcG9uZW50ICovXG47XG52YXIgQVRScF9jb21wb25lbnQgPSBub3JtYWxpemVDb21wb25lbnQoXG4gIEFUUnBfQVRScHZ1ZV90eXBlX3NjcmlwdF9sYW5nX2pzXyxcbiAgQVRScF9yZW5kZXIsXG4gIEFUUnBfc3RhdGljUmVuZGVyRm5zLFxuICBmYWxzZSxcbiAgbnVsbCxcbiAgbnVsbCxcbiAgbnVsbFxuICBcbilcblxuLyogaG90IHJlbG9hZCAqL1xuaWYgKGZhbHNlKSB7IHZhciBBVFJwX2FwaTsgfVxuQVRScF9jb21wb25lbnQub3B0aW9ucy5fX2ZpbGUgPSBcInNyYy9vdmVybGF5cy9BVFJwL0FUUnAudnVlXCJcbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gY29uc3QgQVRScCA9IChBVFJwX2NvbXBvbmVudC5leHBvcnRzKTtcbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL25vZGVfbW9kdWxlcy9iYWJlbC1sb2FkZXIvbGliL2luZGV4LmpzIS4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL2luZGV4LmpzPz92dWUtbG9hZGVyLW9wdGlvbnMhLi9zcmMvb3ZlcmxheXMvQXJlYTUxL0FyZWE1MS52dWU/dnVlJnR5cGU9c2NyaXB0Jmxhbmc9anMmXG5mdW5jdGlvbiBfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlcihvLCBhbGxvd0FycmF5TGlrZSkgeyB2YXIgaXQgPSB0eXBlb2YgU3ltYm9sICE9PSBcInVuZGVmaW5lZFwiICYmIG9bU3ltYm9sLml0ZXJhdG9yXSB8fCBvW1wiQEBpdGVyYXRvclwiXTsgaWYgKCFpdCkgeyBpZiAoQXJyYXkuaXNBcnJheShvKSB8fCAoaXQgPSBfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkobykpIHx8IGFsbG93QXJyYXlMaWtlICYmIG8gJiYgdHlwZW9mIG8ubGVuZ3RoID09PSBcIm51bWJlclwiKSB7IGlmIChpdCkgbyA9IGl0OyB2YXIgaSA9IDA7IHZhciBGID0gZnVuY3Rpb24gRigpIHt9OyByZXR1cm4geyBzOiBGLCBuOiBmdW5jdGlvbiBuKCkgeyBpZiAoaSA+PSBvLmxlbmd0aCkgcmV0dXJuIHsgZG9uZTogdHJ1ZSB9OyByZXR1cm4geyBkb25lOiBmYWxzZSwgdmFsdWU6IG9baSsrXSB9OyB9LCBlOiBmdW5jdGlvbiBlKF9lKSB7IHRocm93IF9lOyB9LCBmOiBGIH07IH0gdGhyb3cgbmV3IFR5cGVFcnJvcihcIkludmFsaWQgYXR0ZW1wdCB0byBpdGVyYXRlIG5vbi1pdGVyYWJsZSBpbnN0YW5jZS5cXG5JbiBvcmRlciB0byBiZSBpdGVyYWJsZSwgbm9uLWFycmF5IG9iamVjdHMgbXVzdCBoYXZlIGEgW1N5bWJvbC5pdGVyYXRvcl0oKSBtZXRob2QuXCIpOyB9IHZhciBub3JtYWxDb21wbGV0aW9uID0gdHJ1ZSwgZGlkRXJyID0gZmFsc2UsIGVycjsgcmV0dXJuIHsgczogZnVuY3Rpb24gcygpIHsgaXQgPSBpdC5jYWxsKG8pOyB9LCBuOiBmdW5jdGlvbiBuKCkgeyB2YXIgc3RlcCA9IGl0Lm5leHQoKTsgbm9ybWFsQ29tcGxldGlvbiA9IHN0ZXAuZG9uZTsgcmV0dXJuIHN0ZXA7IH0sIGU6IGZ1bmN0aW9uIGUoX2UyKSB7IGRpZEVyciA9IHRydWU7IGVyciA9IF9lMjsgfSwgZjogZnVuY3Rpb24gZigpIHsgdHJ5IHsgaWYgKCFub3JtYWxDb21wbGV0aW9uICYmIGl0W1wicmV0dXJuXCJdICE9IG51bGwpIGl0W1wicmV0dXJuXCJdKCk7IH0gZmluYWxseSB7IGlmIChkaWRFcnIpIHRocm93IGVycjsgfSB9IH07IH1cblxuZnVuY3Rpb24gX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5KG8sIG1pbkxlbikgeyBpZiAoIW8pIHJldHVybjsgaWYgKHR5cGVvZiBvID09PSBcInN0cmluZ1wiKSByZXR1cm4gX2FycmF5TGlrZVRvQXJyYXkobywgbWluTGVuKTsgdmFyIG4gPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwobykuc2xpY2UoOCwgLTEpOyBpZiAobiA9PT0gXCJPYmplY3RcIiAmJiBvLmNvbnN0cnVjdG9yKSBuID0gby5jb25zdHJ1Y3Rvci5uYW1lOyBpZiAobiA9PT0gXCJNYXBcIiB8fCBuID09PSBcIlNldFwiKSByZXR1cm4gQXJyYXkuZnJvbShvKTsgaWYgKG4gPT09IFwiQXJndW1lbnRzXCIgfHwgL14oPzpVaXxJKW50KD86OHwxNnwzMikoPzpDbGFtcGVkKT9BcnJheSQvLnRlc3QobikpIHJldHVybiBfYXJyYXlMaWtlVG9BcnJheShvLCBtaW5MZW4pOyB9XG5cbmZ1bmN0aW9uIF9hcnJheUxpa2VUb0FycmF5KGFyciwgbGVuKSB7IGlmIChsZW4gPT0gbnVsbCB8fCBsZW4gPiBhcnIubGVuZ3RoKSBsZW4gPSBhcnIubGVuZ3RoOyBmb3IgKHZhciBpID0gMCwgYXJyMiA9IG5ldyBBcnJheShsZW4pOyBpIDwgbGVuOyBpKyspIHsgYXJyMltpXSA9IGFycltpXTsgfSByZXR1cm4gYXJyMjsgfVxuXG5cbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gY29uc3QgQXJlYTUxdnVlX3R5cGVfc2NyaXB0X2xhbmdfanNfID0gKHtcbiAgbmFtZTogJ0FyZWE1MScsXG4gIG1peGluczogW2V4dGVybmFsX3RyYWRpbmdfdnVlX2pzXy5PdmVybGF5XSxcbiAgbWV0aG9kczoge1xuICAgIG1ldGFfaW5mbzogZnVuY3Rpb24gbWV0YV9pbmZvKCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgYXV0aG9yOiAn8J+RvScsXG4gICAgICAgIHZlcnNpb246ICcxLjAuMCcsXG4gICAgICAgIGRlc2M6ICdHcmFkaWVudCBhcmVhIGNoYXJ0J1xuICAgICAgfTtcbiAgICB9LFxuICAgIGRyYXc6IGZ1bmN0aW9uIGRyYXcoY3R4KSB7XG4gICAgICB2YXIgbGF5b3V0ID0gdGhpcy4kcHJvcHMubGF5b3V0O1xuICAgICAgdmFyIGRhdGEgPSB0aGlzLiRwcm9wcy5kYXRhO1xuICAgICAgdmFyIGdyZCA9IGN0eC5jcmVhdGVMaW5lYXJHcmFkaWVudCgwLCAwLCAwLCBsYXlvdXQuaGVpZ2h0KTtcbiAgICAgIGdyZC5hZGRDb2xvclN0b3AoMCwgdGhpcy5iYWNrMSk7XG4gICAgICBncmQuYWRkQ29sb3JTdG9wKDEsIHRoaXMuYmFjazIpOyAvLyBMaW5lXG5cbiAgICAgIGN0eC5saW5lV2lkdGggPSB0aGlzLmxpbmVfd2lkdGg7XG4gICAgICBjdHguc3Ryb2tlU3R5bGUgPSB0aGlzLmNvbG9yO1xuICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuXG4gICAgICB2YXIgX2l0ZXJhdG9yID0gX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXIoZGF0YSksXG4gICAgICAgICAgX3N0ZXA7XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIGZvciAoX2l0ZXJhdG9yLnMoKTsgIShfc3RlcCA9IF9pdGVyYXRvci5uKCkpLmRvbmU7KSB7XG4gICAgICAgICAgdmFyIHAgPSBfc3RlcC52YWx1ZTtcbiAgICAgICAgICB2YXIgeCA9IGxheW91dC50MnNjcmVlbihwWzBdKTtcbiAgICAgICAgICB2YXIgeSA9IGxheW91dC4kMnNjcmVlbihwWzFdKTtcbiAgICAgICAgICBjdHgubGluZVRvKHgsIHkpO1xuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgX2l0ZXJhdG9yLmUoZXJyKTtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIF9pdGVyYXRvci5mKCk7XG4gICAgICB9XG5cbiAgICAgIGN0eC5zdHJva2UoKTsgLy8gQXJlYVxuXG4gICAgICBjdHguZmlsbFN0eWxlID0gZ3JkO1xuICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgdmFyIHAwID0gKGRhdGFbMF0gfHwgW10pWzBdO1xuICAgICAgdmFyIHBOID0gKGRhdGFbZGF0YS5sZW5ndGggLSAxXSB8fCBbXSlbMF07XG4gICAgICBjdHgubGluZVRvKGxheW91dC50MnNjcmVlbihwMCksIGxheW91dC5oZWlnaHQpO1xuXG4gICAgICB2YXIgX2l0ZXJhdG9yMiA9IF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyKGRhdGEpLFxuICAgICAgICAgIF9zdGVwMjtcblxuICAgICAgdHJ5IHtcbiAgICAgICAgZm9yIChfaXRlcmF0b3IyLnMoKTsgIShfc3RlcDIgPSBfaXRlcmF0b3IyLm4oKSkuZG9uZTspIHtcbiAgICAgICAgICB2YXIgcCA9IF9zdGVwMi52YWx1ZTtcblxuICAgICAgICAgIHZhciBfeCA9IGxheW91dC50MnNjcmVlbihwWzBdKTtcblxuICAgICAgICAgIHZhciBfeSA9IGxheW91dC4kMnNjcmVlbihwWzFdKTtcblxuICAgICAgICAgIGN0eC5saW5lVG8oX3gsIF95KTtcbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIF9pdGVyYXRvcjIuZShlcnIpO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgX2l0ZXJhdG9yMi5mKCk7XG4gICAgICB9XG5cbiAgICAgIGN0eC5saW5lVG8obGF5b3V0LnQyc2NyZWVuKHBOKSwgbGF5b3V0LmhlaWdodCk7XG4gICAgICBjdHguZmlsbCgpO1xuICAgIH0sXG4gICAgdXNlX2ZvcjogZnVuY3Rpb24gdXNlX2ZvcigpIHtcbiAgICAgIHJldHVybiBbJ0FyZWE1MSddO1xuICAgIH0sXG4gICAgZGF0YV9jb2xvcnM6IGZ1bmN0aW9uIGRhdGFfY29sb3JzKCkge1xuICAgICAgcmV0dXJuIFt0aGlzLmNvbG9yXTtcbiAgICB9XG4gIH0sXG4gIC8vIERlZmluZSBpbnRlcm5hbCBzZXR0aW5nICYgY29uc3RhbnRzIGhlcmVcbiAgY29tcHV0ZWQ6IHtcbiAgICBzZXR0OiBmdW5jdGlvbiBzZXR0KCkge1xuICAgICAgcmV0dXJuIHRoaXMuJHByb3BzLnNldHRpbmdzO1xuICAgIH0sXG4gICAgbGluZV93aWR0aDogZnVuY3Rpb24gbGluZV93aWR0aCgpIHtcbiAgICAgIHJldHVybiB0aGlzLnNldHQubGluZVdpZHRoIHx8IDEuMjU7XG4gICAgfSxcbiAgICBjb2xvcjogZnVuY3Rpb24gY29sb3IoKSB7XG4gICAgICByZXR1cm4gdGhpcy5zZXR0LmNvbG9yIHx8ICcjMmZkNjhmJztcbiAgICB9LFxuICAgIGJhY2sxOiBmdW5jdGlvbiBiYWNrMSgpIHtcbiAgICAgIHJldHVybiB0aGlzLnNldHQuYmFjazEgfHwgdGhpcy5jb2xvciArICcxNSc7XG4gICAgfSxcbiAgICBiYWNrMjogZnVuY3Rpb24gYmFjazIoKSB7XG4gICAgICByZXR1cm4gdGhpcy5zZXR0LmJhY2syIHx8IHRoaXMuY29sb3IgKyAnMDEnO1xuICAgIH1cbiAgfSxcbiAgZGF0YTogZnVuY3Rpb24gZGF0YSgpIHtcbiAgICByZXR1cm4ge307XG4gIH1cbn0pO1xuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL292ZXJsYXlzL0FyZWE1MS9BcmVhNTEudnVlP3Z1ZSZ0eXBlPXNjcmlwdCZsYW5nPWpzJlxuIC8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gY29uc3QgQXJlYTUxX0FyZWE1MXZ1ZV90eXBlX3NjcmlwdF9sYW5nX2pzXyA9IChBcmVhNTF2dWVfdHlwZV9zY3JpcHRfbGFuZ19qc18pOyBcbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9vdmVybGF5cy9BcmVhNTEvQXJlYTUxLnZ1ZVxudmFyIEFyZWE1MV9yZW5kZXIsIEFyZWE1MV9zdGF0aWNSZW5kZXJGbnNcbjtcblxuXG5cbi8qIG5vcm1hbGl6ZSBjb21wb25lbnQgKi9cbjtcbnZhciBBcmVhNTFfY29tcG9uZW50ID0gbm9ybWFsaXplQ29tcG9uZW50KFxuICBBcmVhNTFfQXJlYTUxdnVlX3R5cGVfc2NyaXB0X2xhbmdfanNfLFxuICBBcmVhNTFfcmVuZGVyLFxuICBBcmVhNTFfc3RhdGljUmVuZGVyRm5zLFxuICBmYWxzZSxcbiAgbnVsbCxcbiAgbnVsbCxcbiAgbnVsbFxuICBcbilcblxuLyogaG90IHJlbG9hZCAqL1xuaWYgKGZhbHNlKSB7IHZhciBBcmVhNTFfYXBpOyB9XG5BcmVhNTFfY29tcG9uZW50Lm9wdGlvbnMuX19maWxlID0gXCJzcmMvb3ZlcmxheXMvQXJlYTUxL0FyZWE1MS52dWVcIlxuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyBjb25zdCBBcmVhNTEgPSAoQXJlYTUxX2NvbXBvbmVudC5leHBvcnRzKTtcbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL25vZGVfbW9kdWxlcy9iYWJlbC1sb2FkZXIvbGliL2luZGV4LmpzIS4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL2luZGV4LmpzPz92dWUtbG9hZGVyLW9wdGlvbnMhLi9zcmMvb3ZlcmxheXMvQkIvQkIudnVlP3Z1ZSZ0eXBlPXNjcmlwdCZsYW5nPWpzJlxuXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIGNvbnN0IEJCdnVlX3R5cGVfc2NyaXB0X2xhbmdfanNfID0gKHtcbiAgbmFtZTogJ0JCJyxcbiAgbWl4aW5zOiBbZXh0ZXJuYWxfdHJhZGluZ192dWVfanNfLk92ZXJsYXldLFxuICBtZXRob2RzOiB7XG4gICAgbWV0YV9pbmZvOiBmdW5jdGlvbiBtZXRhX2luZm8oKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBhdXRob3I6ICdTdGRTcXVhZCcsXG4gICAgICAgIHZlcnNpb246ICcxLjAuMCcsXG4gICAgICAgIGRlc2M6ICdCb2xsaW5nZXIgQmFuZHMnLFxuICAgICAgICBwcmVzZXQ6IHtcbiAgICAgICAgICBuYW1lOiAnQkIgJGxlbmd0aCAkc3RkZGV2JyxcbiAgICAgICAgICBzaWRlOiAnb25jaGFydCcsXG4gICAgICAgICAgc2V0dGluZ3M6IHtcbiAgICAgICAgICAgIGxpbmVXaWR0aDogMC43NSxcbiAgICAgICAgICAgIGNvbG9yOiAnIzJjYzZjOWFiJyxcbiAgICAgICAgICAgIHNob3dNaWQ6IHRydWUsXG4gICAgICAgICAgICBiYWNrQ29sb3I6ICcjMmNjNmM5MGEnXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9O1xuICAgIH0sXG4gICAgdXNlX2ZvcjogZnVuY3Rpb24gdXNlX2ZvcigpIHtcbiAgICAgIHJldHVybiBbJ0JCJ107XG4gICAgfSxcbiAgICBjYWxjOiBmdW5jdGlvbiBjYWxjKCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgcHJvcHM6IHtcbiAgICAgICAgICBsZW5ndGg6IHtcbiAgICAgICAgICAgIGRlZjogMjEsXG4gICAgICAgICAgICB0ZXh0OiAnTGVuZ3RoJ1xuICAgICAgICAgIH0sXG4gICAgICAgICAgc3RkZGV2OiB7XG4gICAgICAgICAgICBkZWY6IDIsXG4gICAgICAgICAgICB0ZXh0OiAnU3RkRGV2J1xuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgY29uZjoge1xuICAgICAgICAgIHJlbmRlcmVyOiAnQ2hhbm5lbCdcbiAgICAgICAgfSxcbiAgICAgICAgdXBkYXRlOiBcIlxcbiAgICAgICAgICAgICAgICAgICAgbGV0IFttLCBoLCBsXSA9IGJiKGNsb3NlLCBsZW5ndGgsIHN0ZGRldilcXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbaFswXSwgbVswXSwgbFswXV1cXG4gICAgICAgICAgICAgICAgXCJcbiAgICAgIH07XG4gICAgfVxuICB9XG59KTtcbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9vdmVybGF5cy9CQi9CQi52dWU/dnVlJnR5cGU9c2NyaXB0Jmxhbmc9anMmXG4gLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyBjb25zdCBCQl9CQnZ1ZV90eXBlX3NjcmlwdF9sYW5nX2pzXyA9IChCQnZ1ZV90eXBlX3NjcmlwdF9sYW5nX2pzXyk7IFxuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL292ZXJsYXlzL0JCL0JCLnZ1ZVxudmFyIEJCX3JlbmRlciwgQkJfc3RhdGljUmVuZGVyRm5zXG47XG5cblxuXG4vKiBub3JtYWxpemUgY29tcG9uZW50ICovXG47XG52YXIgQkJfY29tcG9uZW50ID0gbm9ybWFsaXplQ29tcG9uZW50KFxuICBCQl9CQnZ1ZV90eXBlX3NjcmlwdF9sYW5nX2pzXyxcbiAgQkJfcmVuZGVyLFxuICBCQl9zdGF0aWNSZW5kZXJGbnMsXG4gIGZhbHNlLFxuICBudWxsLFxuICBudWxsLFxuICBudWxsXG4gIFxuKVxuXG4vKiBob3QgcmVsb2FkICovXG5pZiAoZmFsc2UpIHsgdmFyIEJCX2FwaTsgfVxuQkJfY29tcG9uZW50Lm9wdGlvbnMuX19maWxlID0gXCJzcmMvb3ZlcmxheXMvQkIvQkIudnVlXCJcbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gY29uc3QgQkIgPSAoQkJfY29tcG9uZW50LmV4cG9ydHMpO1xuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vbm9kZV9tb2R1bGVzL2JhYmVsLWxvYWRlci9saWIvaW5kZXguanMhLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvaW5kZXguanM/P3Z1ZS1sb2FkZXItb3B0aW9ucyEuL3NyYy9vdmVybGF5cy9CQlcvQkJXLnZ1ZT92dWUmdHlwZT1zY3JpcHQmbGFuZz1qcyZcblxuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyBjb25zdCBCQld2dWVfdHlwZV9zY3JpcHRfbGFuZ19qc18gPSAoe1xuICBuYW1lOiAnQkJXJyxcbiAgbWl4aW5zOiBbZXh0ZXJuYWxfdHJhZGluZ192dWVfanNfLk92ZXJsYXldLFxuICBtZXRob2RzOiB7XG4gICAgbWV0YV9pbmZvOiBmdW5jdGlvbiBtZXRhX2luZm8oKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBhdXRob3I6ICdTdGRTcXVhZCcsXG4gICAgICAgIHZlcnNpb246ICcxLjAuMCcsXG4gICAgICAgIGRlc2M6ICdCb2xsaW5nZXIgQmFuZHMgV2lkdGgnLFxuICAgICAgICBwcmVzZXQ6IHtcbiAgICAgICAgICBuYW1lOiAnQkJXICRsZW5ndGggJHN0ZGRldicsXG4gICAgICAgICAgc2lkZTogJ29mZmNoYXJ0JyxcbiAgICAgICAgICBzZXR0aW5nczoge1xuICAgICAgICAgICAgbGluZVdpZHRoOiAwLjc1LFxuICAgICAgICAgICAgY29sb3I6ICcjMmNjNmM5YWInXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9O1xuICAgIH0sXG4gICAgdXNlX2ZvcjogZnVuY3Rpb24gdXNlX2ZvcigpIHtcbiAgICAgIHJldHVybiBbJ0JCVyddO1xuICAgIH0sXG4gICAgY2FsYzogZnVuY3Rpb24gY2FsYygpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHByb3BzOiB7XG4gICAgICAgICAgbGVuZ3RoOiB7XG4gICAgICAgICAgICBkZWY6IDIxLFxuICAgICAgICAgICAgdGV4dDogJ0xlbmd0aCdcbiAgICAgICAgICB9LFxuICAgICAgICAgIHN0ZGRldjoge1xuICAgICAgICAgICAgZGVmOiAyLFxuICAgICAgICAgICAgdGV4dDogJ1N0ZERldidcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIGNvbmY6IHtcbiAgICAgICAgICByZW5kZXJlcjogJ1NwbGluZSdcbiAgICAgICAgfSxcbiAgICAgICAgdXBkYXRlOiBcIlxcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGJidyhjbG9zZSwgbGVuZ3RoLCBzdGRkZXYpWzBdXFxuICAgICAgICAgICAgICAgIFwiXG4gICAgICB9O1xuICAgIH1cbiAgfVxufSk7XG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvb3ZlcmxheXMvQkJXL0JCVy52dWU/dnVlJnR5cGU9c2NyaXB0Jmxhbmc9anMmXG4gLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyBjb25zdCBCQldfQkJXdnVlX3R5cGVfc2NyaXB0X2xhbmdfanNfID0gKEJCV3Z1ZV90eXBlX3NjcmlwdF9sYW5nX2pzXyk7IFxuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL292ZXJsYXlzL0JCVy9CQlcudnVlXG52YXIgQkJXX3JlbmRlciwgQkJXX3N0YXRpY1JlbmRlckZuc1xuO1xuXG5cblxuLyogbm9ybWFsaXplIGNvbXBvbmVudCAqL1xuO1xudmFyIEJCV19jb21wb25lbnQgPSBub3JtYWxpemVDb21wb25lbnQoXG4gIEJCV19CQld2dWVfdHlwZV9zY3JpcHRfbGFuZ19qc18sXG4gIEJCV19yZW5kZXIsXG4gIEJCV19zdGF0aWNSZW5kZXJGbnMsXG4gIGZhbHNlLFxuICBudWxsLFxuICBudWxsLFxuICBudWxsXG4gIFxuKVxuXG4vKiBob3QgcmVsb2FkICovXG5pZiAoZmFsc2UpIHsgdmFyIEJCV19hcGk7IH1cbkJCV19jb21wb25lbnQub3B0aW9ucy5fX2ZpbGUgPSBcInNyYy9vdmVybGF5cy9CQlcvQkJXLnZ1ZVwiXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIGNvbnN0IEJCVyA9IChCQldfY29tcG9uZW50LmV4cG9ydHMpO1xuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vbm9kZV9tb2R1bGVzL2JhYmVsLWxvYWRlci9saWIvaW5kZXguanMhLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvaW5kZXguanM/P3Z1ZS1sb2FkZXItb3B0aW9ucyEuL3NyYy9vdmVybGF5cy9DQ0kvQ0NJLnZ1ZT92dWUmdHlwZT1zY3JpcHQmbGFuZz1qcyZcblxuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyBjb25zdCBDQ0l2dWVfdHlwZV9zY3JpcHRfbGFuZ19qc18gPSAoe1xuICBuYW1lOiAnQ0NJJyxcbiAgbWl4aW5zOiBbZXh0ZXJuYWxfdHJhZGluZ192dWVfanNfLk92ZXJsYXldLFxuICBtZXRob2RzOiB7XG4gICAgbWV0YV9pbmZvOiBmdW5jdGlvbiBtZXRhX2luZm8oKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBhdXRob3I6ICdTdGRTcXVhZCcsXG4gICAgICAgIHZlcnNpb246ICcxLjAuMCcsXG4gICAgICAgIGRlc2M6ICdDb21tb2RpdHkgQ2hhbm5lbCBJbmRleCcsXG4gICAgICAgIHByZXNldDoge1xuICAgICAgICAgIG5hbWU6ICdDQ0kgJGxlbmd0aCcsXG4gICAgICAgICAgc2lkZTogJ29mZmNoYXJ0JyxcbiAgICAgICAgICBzZXR0aW5nczoge1xuICAgICAgICAgICAgbGluZVdpZHRoOiAwLjc1LFxuICAgICAgICAgICAgY29sb3I6ICcjZTI4YTNkZWUnLFxuICAgICAgICAgICAgYmFja0NvbG9yOiAnI2UyOGEzZDExJyxcbiAgICAgICAgICAgIGJhbmRDb2xvcjogJyNhYWFhYWEnLFxuICAgICAgICAgICAgdXBwZXI6IDEwMCxcbiAgICAgICAgICAgIGxvd2VyOiAtMTAwXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9O1xuICAgIH0sXG4gICAgdXNlX2ZvcjogZnVuY3Rpb24gdXNlX2ZvcigpIHtcbiAgICAgIHJldHVybiBbJ0NDSSddO1xuICAgIH0sXG4gICAgY2FsYzogZnVuY3Rpb24gY2FsYygpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHByb3BzOiB7XG4gICAgICAgICAgbGVuZ3RoOiB7XG4gICAgICAgICAgICBkZWY6IDIxLFxuICAgICAgICAgICAgdGV4dDogJ0xlbmd0aCdcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIGNvbmY6IHtcbiAgICAgICAgICByZW5kZXJlcjogJ1JhbmdlJ1xuICAgICAgICB9LFxuICAgICAgICB1cGRhdGU6IFwicmV0dXJuIGNjaShjbG9zZSwgbGVuZ3RoKVswXVwiXG4gICAgICB9O1xuICAgIH1cbiAgfVxufSk7XG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvb3ZlcmxheXMvQ0NJL0NDSS52dWU/dnVlJnR5cGU9c2NyaXB0Jmxhbmc9anMmXG4gLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyBjb25zdCBDQ0lfQ0NJdnVlX3R5cGVfc2NyaXB0X2xhbmdfanNfID0gKENDSXZ1ZV90eXBlX3NjcmlwdF9sYW5nX2pzXyk7IFxuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL292ZXJsYXlzL0NDSS9DQ0kudnVlXG52YXIgQ0NJX3JlbmRlciwgQ0NJX3N0YXRpY1JlbmRlckZuc1xuO1xuXG5cblxuLyogbm9ybWFsaXplIGNvbXBvbmVudCAqL1xuO1xudmFyIENDSV9jb21wb25lbnQgPSBub3JtYWxpemVDb21wb25lbnQoXG4gIENDSV9DQ0l2dWVfdHlwZV9zY3JpcHRfbGFuZ19qc18sXG4gIENDSV9yZW5kZXIsXG4gIENDSV9zdGF0aWNSZW5kZXJGbnMsXG4gIGZhbHNlLFxuICBudWxsLFxuICBudWxsLFxuICBudWxsXG4gIFxuKVxuXG4vKiBob3QgcmVsb2FkICovXG5pZiAoZmFsc2UpIHsgdmFyIENDSV9hcGk7IH1cbkNDSV9jb21wb25lbnQub3B0aW9ucy5fX2ZpbGUgPSBcInNyYy9vdmVybGF5cy9DQ0kvQ0NJLnZ1ZVwiXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIGNvbnN0IENDSSA9IChDQ0lfY29tcG9uZW50LmV4cG9ydHMpO1xuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vbm9kZV9tb2R1bGVzL2JhYmVsLWxvYWRlci9saWIvaW5kZXguanMhLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvaW5kZXguanM/P3Z1ZS1sb2FkZXItb3B0aW9ucyEuL3NyYy9vdmVybGF5cy9DTU8vQ01PLnZ1ZT92dWUmdHlwZT1zY3JpcHQmbGFuZz1qcyZcblxuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyBjb25zdCBDTU92dWVfdHlwZV9zY3JpcHRfbGFuZ19qc18gPSAoe1xuICBuYW1lOiAnQ01PJyxcbiAgbWl4aW5zOiBbZXh0ZXJuYWxfdHJhZGluZ192dWVfanNfLk92ZXJsYXldLFxuICBtZXRob2RzOiB7XG4gICAgbWV0YV9pbmZvOiBmdW5jdGlvbiBtZXRhX2luZm8oKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBhdXRob3I6ICdTdGRTcXVhZCcsXG4gICAgICAgIHZlcnNpb246ICcxLjAuMCcsXG4gICAgICAgIGRlc2M6ICdDaGFuZGUgTW9tZW50dW0gT3NjaWxsYXRvcicsXG4gICAgICAgIHByZXNldDoge1xuICAgICAgICAgIG5hbWU6ICdDTU8gJGxlbmd0aCcsXG4gICAgICAgICAgc2lkZTogJ29mZmNoYXJ0JyxcbiAgICAgICAgICBzZXR0aW5nczoge1xuICAgICAgICAgICAgbGluZVdpZHRoOiAwLjc1LFxuICAgICAgICAgICAgY29sb3I6ICcjNTU5ZGUwJ1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9LFxuICAgIHVzZV9mb3I6IGZ1bmN0aW9uIHVzZV9mb3IoKSB7XG4gICAgICByZXR1cm4gWydDTU8nXTtcbiAgICB9LFxuICAgIGNhbGM6IGZ1bmN0aW9uIGNhbGMoKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBwcm9wczoge1xuICAgICAgICAgIGxlbmd0aDoge1xuICAgICAgICAgICAgZGVmOiAxMCxcbiAgICAgICAgICAgIHRleHQ6ICdMZW5ndGgnXG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBjb25mOiB7XG4gICAgICAgICAgcmVuZGVyZXI6ICdTcGxpbmUnXG4gICAgICAgIH0sXG4gICAgICAgIHVwZGF0ZTogXCJyZXR1cm4gY21vKGNsb3NlLCBsZW5ndGgpWzBdXCJcbiAgICAgIH07XG4gICAgfVxuICB9XG59KTtcbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9vdmVybGF5cy9DTU8vQ01PLnZ1ZT92dWUmdHlwZT1zY3JpcHQmbGFuZz1qcyZcbiAvKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIGNvbnN0IENNT19DTU92dWVfdHlwZV9zY3JpcHRfbGFuZ19qc18gPSAoQ01PdnVlX3R5cGVfc2NyaXB0X2xhbmdfanNfKTsgXG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvb3ZlcmxheXMvQ01PL0NNTy52dWVcbnZhciBDTU9fcmVuZGVyLCBDTU9fc3RhdGljUmVuZGVyRm5zXG47XG5cblxuXG4vKiBub3JtYWxpemUgY29tcG9uZW50ICovXG47XG52YXIgQ01PX2NvbXBvbmVudCA9IG5vcm1hbGl6ZUNvbXBvbmVudChcbiAgQ01PX0NNT3Z1ZV90eXBlX3NjcmlwdF9sYW5nX2pzXyxcbiAgQ01PX3JlbmRlcixcbiAgQ01PX3N0YXRpY1JlbmRlckZucyxcbiAgZmFsc2UsXG4gIG51bGwsXG4gIG51bGwsXG4gIG51bGxcbiAgXG4pXG5cbi8qIGhvdCByZWxvYWQgKi9cbmlmIChmYWxzZSkgeyB2YXIgQ01PX2FwaTsgfVxuQ01PX2NvbXBvbmVudC5vcHRpb25zLl9fZmlsZSA9IFwic3JjL292ZXJsYXlzL0NNTy9DTU8udnVlXCJcbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gY29uc3QgQ01PID0gKENNT19jb21wb25lbnQuZXhwb3J0cyk7XG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9ub2RlX21vZHVsZXMvYmFiZWwtbG9hZGVyL2xpYi9pbmRleC5qcyEuL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9pbmRleC5qcz8/dnVlLWxvYWRlci1vcHRpb25zIS4vc3JjL292ZXJsYXlzL0NPRy9DT0cudnVlP3Z1ZSZ0eXBlPXNjcmlwdCZsYW5nPWpzJlxuXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIGNvbnN0IENPR3Z1ZV90eXBlX3NjcmlwdF9sYW5nX2pzXyA9ICh7XG4gIG5hbWU6ICdDT0cnLFxuICBtaXhpbnM6IFtleHRlcm5hbF90cmFkaW5nX3Z1ZV9qc18uT3ZlcmxheV0sXG4gIG1ldGhvZHM6IHtcbiAgICBtZXRhX2luZm86IGZ1bmN0aW9uIG1ldGFfaW5mbygpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGF1dGhvcjogJ1N0ZFNxdWFkJyxcbiAgICAgICAgdmVyc2lvbjogJzEuMC4wJyxcbiAgICAgICAgZGVzYzogJ0NlbnRlciBvZiBHcmF2aXR5JyxcbiAgICAgICAgcHJlc2V0OiB7XG4gICAgICAgICAgbmFtZTogJ0NPRyAkbGVuZ3RoJyxcbiAgICAgICAgICBzaWRlOiAnb2ZmY2hhcnQnLFxuICAgICAgICAgIHNldHRpbmdzOiB7XG4gICAgICAgICAgICBsaW5lV2lkdGg6IDAuNzUsXG4gICAgICAgICAgICBjb2xvcjogJyM1NTlkZTAnXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9O1xuICAgIH0sXG4gICAgdXNlX2ZvcjogZnVuY3Rpb24gdXNlX2ZvcigpIHtcbiAgICAgIHJldHVybiBbJ0NPRyddO1xuICAgIH0sXG4gICAgY2FsYzogZnVuY3Rpb24gY2FsYygpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHByb3BzOiB7XG4gICAgICAgICAgbGVuZ3RoOiB7XG4gICAgICAgICAgICBkZWY6IDEwLFxuICAgICAgICAgICAgdGV4dDogJ0xlbmd0aCdcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIGNvbmY6IHtcbiAgICAgICAgICByZW5kZXJlcjogJ1NwbGluZSdcbiAgICAgICAgfSxcbiAgICAgICAgdXBkYXRlOiBcInJldHVybiBjb2coY2xvc2UsIGxlbmd0aClbMF1cIlxuICAgICAgfTtcbiAgICB9XG4gIH1cbn0pO1xuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL292ZXJsYXlzL0NPRy9DT0cudnVlP3Z1ZSZ0eXBlPXNjcmlwdCZsYW5nPWpzJlxuIC8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gY29uc3QgQ09HX0NPR3Z1ZV90eXBlX3NjcmlwdF9sYW5nX2pzXyA9IChDT0d2dWVfdHlwZV9zY3JpcHRfbGFuZ19qc18pOyBcbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9vdmVybGF5cy9DT0cvQ09HLnZ1ZVxudmFyIENPR19yZW5kZXIsIENPR19zdGF0aWNSZW5kZXJGbnNcbjtcblxuXG5cbi8qIG5vcm1hbGl6ZSBjb21wb25lbnQgKi9cbjtcbnZhciBDT0dfY29tcG9uZW50ID0gbm9ybWFsaXplQ29tcG9uZW50KFxuICBDT0dfQ09HdnVlX3R5cGVfc2NyaXB0X2xhbmdfanNfLFxuICBDT0dfcmVuZGVyLFxuICBDT0dfc3RhdGljUmVuZGVyRm5zLFxuICBmYWxzZSxcbiAgbnVsbCxcbiAgbnVsbCxcbiAgbnVsbFxuICBcbilcblxuLyogaG90IHJlbG9hZCAqL1xuaWYgKGZhbHNlKSB7IHZhciBDT0dfYXBpOyB9XG5DT0dfY29tcG9uZW50Lm9wdGlvbnMuX19maWxlID0gXCJzcmMvb3ZlcmxheXMvQ09HL0NPRy52dWVcIlxuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyBjb25zdCBDT0cgPSAoQ09HX2NvbXBvbmVudC5leHBvcnRzKTtcbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL25vZGVfbW9kdWxlcy9iYWJlbC1sb2FkZXIvbGliL2luZGV4LmpzIS4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL2luZGV4LmpzPz92dWUtbG9hZGVyLW9wdGlvbnMhLi9zcmMvb3ZlcmxheXMvREhpc3RvZ3JhbS9ESGlzdG9ncmFtLnZ1ZT92dWUmdHlwZT1zY3JpcHQmbGFuZz1qcyZcbmZ1bmN0aW9uIERIaXN0b2dyYW12dWVfdHlwZV9zY3JpcHRfbGFuZ19qc19jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyKG8sIGFsbG93QXJyYXlMaWtlKSB7IHZhciBpdCA9IHR5cGVvZiBTeW1ib2wgIT09IFwidW5kZWZpbmVkXCIgJiYgb1tTeW1ib2wuaXRlcmF0b3JdIHx8IG9bXCJAQGl0ZXJhdG9yXCJdOyBpZiAoIWl0KSB7IGlmIChBcnJheS5pc0FycmF5KG8pIHx8IChpdCA9IERIaXN0b2dyYW12dWVfdHlwZV9zY3JpcHRfbGFuZ19qc191bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheShvKSkgfHwgYWxsb3dBcnJheUxpa2UgJiYgbyAmJiB0eXBlb2Ygby5sZW5ndGggPT09IFwibnVtYmVyXCIpIHsgaWYgKGl0KSBvID0gaXQ7IHZhciBpID0gMDsgdmFyIEYgPSBmdW5jdGlvbiBGKCkge307IHJldHVybiB7IHM6IEYsIG46IGZ1bmN0aW9uIG4oKSB7IGlmIChpID49IG8ubGVuZ3RoKSByZXR1cm4geyBkb25lOiB0cnVlIH07IHJldHVybiB7IGRvbmU6IGZhbHNlLCB2YWx1ZTogb1tpKytdIH07IH0sIGU6IGZ1bmN0aW9uIGUoX2UpIHsgdGhyb3cgX2U7IH0sIGY6IEYgfTsgfSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiSW52YWxpZCBhdHRlbXB0IHRvIGl0ZXJhdGUgbm9uLWl0ZXJhYmxlIGluc3RhbmNlLlxcbkluIG9yZGVyIHRvIGJlIGl0ZXJhYmxlLCBub24tYXJyYXkgb2JqZWN0cyBtdXN0IGhhdmUgYSBbU3ltYm9sLml0ZXJhdG9yXSgpIG1ldGhvZC5cIik7IH0gdmFyIG5vcm1hbENvbXBsZXRpb24gPSB0cnVlLCBkaWRFcnIgPSBmYWxzZSwgZXJyOyByZXR1cm4geyBzOiBmdW5jdGlvbiBzKCkgeyBpdCA9IGl0LmNhbGwobyk7IH0sIG46IGZ1bmN0aW9uIG4oKSB7IHZhciBzdGVwID0gaXQubmV4dCgpOyBub3JtYWxDb21wbGV0aW9uID0gc3RlcC5kb25lOyByZXR1cm4gc3RlcDsgfSwgZTogZnVuY3Rpb24gZShfZTIpIHsgZGlkRXJyID0gdHJ1ZTsgZXJyID0gX2UyOyB9LCBmOiBmdW5jdGlvbiBmKCkgeyB0cnkgeyBpZiAoIW5vcm1hbENvbXBsZXRpb24gJiYgaXRbXCJyZXR1cm5cIl0gIT0gbnVsbCkgaXRbXCJyZXR1cm5cIl0oKTsgfSBmaW5hbGx5IHsgaWYgKGRpZEVycikgdGhyb3cgZXJyOyB9IH0gfTsgfVxuXG5mdW5jdGlvbiBESGlzdG9ncmFtdnVlX3R5cGVfc2NyaXB0X2xhbmdfanNfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkobywgbWluTGVuKSB7IGlmICghbykgcmV0dXJuOyBpZiAodHlwZW9mIG8gPT09IFwic3RyaW5nXCIpIHJldHVybiBESGlzdG9ncmFtdnVlX3R5cGVfc2NyaXB0X2xhbmdfanNfYXJyYXlMaWtlVG9BcnJheShvLCBtaW5MZW4pOyB2YXIgbiA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvKS5zbGljZSg4LCAtMSk7IGlmIChuID09PSBcIk9iamVjdFwiICYmIG8uY29uc3RydWN0b3IpIG4gPSBvLmNvbnN0cnVjdG9yLm5hbWU7IGlmIChuID09PSBcIk1hcFwiIHx8IG4gPT09IFwiU2V0XCIpIHJldHVybiBBcnJheS5mcm9tKG8pOyBpZiAobiA9PT0gXCJBcmd1bWVudHNcIiB8fCAvXig/OlVpfEkpbnQoPzo4fDE2fDMyKSg/OkNsYW1wZWQpP0FycmF5JC8udGVzdChuKSkgcmV0dXJuIERIaXN0b2dyYW12dWVfdHlwZV9zY3JpcHRfbGFuZ19qc19hcnJheUxpa2VUb0FycmF5KG8sIG1pbkxlbik7IH1cblxuZnVuY3Rpb24gREhpc3RvZ3JhbXZ1ZV90eXBlX3NjcmlwdF9sYW5nX2pzX2FycmF5TGlrZVRvQXJyYXkoYXJyLCBsZW4pIHsgaWYgKGxlbiA9PSBudWxsIHx8IGxlbiA+IGFyci5sZW5ndGgpIGxlbiA9IGFyci5sZW5ndGg7IGZvciAodmFyIGkgPSAwLCBhcnIyID0gbmV3IEFycmF5KGxlbik7IGkgPCBsZW47IGkrKykgeyBhcnIyW2ldID0gYXJyW2ldOyB9IHJldHVybiBhcnIyOyB9XG5cblxuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyBjb25zdCBESGlzdG9ncmFtdnVlX3R5cGVfc2NyaXB0X2xhbmdfanNfID0gKHtcbiAgbmFtZTogXCJESGlzdG9ncmFtXCIsXG4gIG1peGluczogW2V4dGVybmFsX3RyYWRpbmdfdnVlX2pzXy5PdmVybGF5XSxcbiAgbWV0aG9kczoge1xuICAgIG1ldGFfaW5mbzogZnVuY3Rpb24gbWV0YV9pbmZvKCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgYXV0aG9yOiBcIkFjaWQzY3JvY29cIixcbiAgICAgICAgdmVyc2lvbjogXCIxLjAuMFwiLFxuICAgICAgICBkZXNjOiBcIkRvdWJsZSBIaXN0b2dyYW0gUGxvdFwiLFxuICAgICAgICBwcmVzZXQ6IHtcbiAgICAgICAgICBuYW1lOiBcIkRIaXN0b2dyYW1cIixcbiAgICAgICAgICBzaWRlOiBcIm9mZmNoYXJ0XCIsXG4gICAgICAgICAgc2V0dGluZ3M6IHtcbiAgICAgICAgICAgIGhpc3RXaWR0aDogNCxcbiAgICAgICAgICAgIHRocmVzaG9sZFNpemU6IDAsXG4gICAgICAgICAgICBwb3NDb2xvcjogXCIjMzVhNzc2XCIsXG4gICAgICAgICAgICBuZWdDb2xvcjogXCIjZTU0MTUwXCJcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfSxcbiAgICBkcmF3OiBmdW5jdGlvbiBkcmF3KGN0eCkge1xuICAgICAgY3R4LmxpbmVXaWR0aCA9IHRoaXMuaGlzdF93aWR0aDtcbiAgICAgIGN0eC5zdHJva2VTdHlsZSA9IHRoaXMuY29sb3I7XG4gICAgICB2YXIgbGF5b3V0ID0gdGhpcy4kcHJvcHMubGF5b3V0O1xuICAgICAgdmFyIGJhc2UgPSBsYXlvdXQuJDJzY3JlZW4oMCkgKyAwLjU7XG4gICAgICB2YXIgb2ZmID0gdGhpcy5oaXN0X3dpZHRoICUgMiA/IDAgOiAwLjU7IC8vIENvbG9yIGNoYW5nZWRcblxuICAgICAgdmFyIGNoYW5nZWQgPSBmYWxzZTtcblxuICAgICAgdmFyIF9pdGVyYXRvciA9IERIaXN0b2dyYW12dWVfdHlwZV9zY3JpcHRfbGFuZ19qc19jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyKHRoaXMuJHByb3BzLmRhdGEpLFxuICAgICAgICAgIF9zdGVwO1xuXG4gICAgICB0cnkge1xuICAgICAgICBmb3IgKF9pdGVyYXRvci5zKCk7ICEoX3N0ZXAgPSBfaXRlcmF0b3IubigpKS5kb25lOykge1xuICAgICAgICAgIHZhciBwID0gX3N0ZXAudmFsdWU7XG4gICAgICAgICAgdmFyIHBvc192YWx1ZSA9IHBbMV07XG4gICAgICAgICAgdmFyIG5lZ192YWx1ZSA9IHBbMl07XG4gICAgICAgICAgdmFyIHggPSBsYXlvdXQudDJzY3JlZW4ocFswXSkgLSBvZmY7XG4gICAgICAgICAgdmFyIHkxID0gbGF5b3V0LiQyc2NyZWVuKHBvc192YWx1ZSkgLSAwLjU7XG4gICAgICAgICAgdmFyIHkyID0gbGF5b3V0LiQyc2NyZWVuKG5lZ192YWx1ZSkgLSAwLjU7XG5cbiAgICAgICAgICBpZiAocG9zX3ZhbHVlID4gdGhpcy50aHJlc2hvbGRfc2l6ZSkge1xuICAgICAgICAgICAgY3R4LnN0cm9rZVN0eWxlID0gdGhpcy5wb3NfY29sb3I7XG4gICAgICAgICAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgICAgICAgICBjdHgubW92ZVRvKHgsIGJhc2UpO1xuICAgICAgICAgICAgY3R4LmxpbmVUbyh4LCB5MSk7XG4gICAgICAgICAgICBjdHguc3Ryb2tlKCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKG5lZ192YWx1ZSA8IC10aGlzLnRocmVzaG9sZF9zaXplKSB7XG4gICAgICAgICAgICBjdHguc3Ryb2tlU3R5bGUgPSB0aGlzLm5lZ19jb2xvcjtcbiAgICAgICAgICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICAgICAgICAgIGN0eC5tb3ZlVG8oeCwgYmFzZSk7XG4gICAgICAgICAgICBjdHgubGluZVRvKHgsIHkyKTtcbiAgICAgICAgICAgIGN0eC5zdHJva2UoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICBfaXRlcmF0b3IuZShlcnIpO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgX2l0ZXJhdG9yLmYoKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIHVzZV9mb3I6IGZ1bmN0aW9uIHVzZV9mb3IoKSB7XG4gICAgICByZXR1cm4gW1wiREhpc3RvZ3JhbVwiXTtcbiAgICB9LFxuICAgIGxlZ2VuZDogZnVuY3Rpb24gbGVnZW5kKHZhbHVlcykge1xuICAgICAgdmFyIHhzID0gdmFsdWVzLnNsaWNlKDEsIDMpLm1hcChmdW5jdGlvbiAoeCkge1xuICAgICAgICByZXR1cm4geC50b0ZpeGVkKE1hdGguYWJzKHgpID4gMC4wMDEgPyA0IDogOCk7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiBbe1xuICAgICAgICB2YWx1ZTogeHNbMF0sXG4gICAgICAgIGNvbG9yOiB0aGlzLnBvc19jb2xvclxuICAgICAgfSwge1xuICAgICAgICB2YWx1ZTogeHNbMV0sXG4gICAgICAgIGNvbG9yOiB0aGlzLm5lZ19jb2xvclxuICAgICAgfV07XG4gICAgfVxuICB9LFxuICAvLyBEZWZpbmUgaW50ZXJuYWwgc2V0dGluZyAmIGNvbnN0YW50cyBoZXJlXG4gIGNvbXB1dGVkOiB7XG4gICAgc2V0dDogZnVuY3Rpb24gc2V0dCgpIHtcbiAgICAgIHJldHVybiB0aGlzLiRwcm9wcy5zZXR0aW5ncztcbiAgICB9LFxuICAgIGhpc3Rfd2lkdGg6IGZ1bmN0aW9uIGhpc3Rfd2lkdGgoKSB7XG4gICAgICByZXR1cm4gdGhpcy5zZXR0Lmhpc3RXaWR0aCB8fCA0O1xuICAgIH0sXG4gICAgdGhyZXNob2xkX3NpemU6IGZ1bmN0aW9uIHRocmVzaG9sZF9zaXplKCkge1xuICAgICAgcmV0dXJuIHRoaXMuc2V0dC50aHJlc2hvbGRTaXplIHx8IDA7XG4gICAgfSxcbiAgICBwb3NfY29sb3I6IGZ1bmN0aW9uIHBvc19jb2xvcigpIHtcbiAgICAgIHJldHVybiB0aGlzLnNldHQucG9zQ29sb3IgfHwgXCIjMzVhNzc2XCI7XG4gICAgfSxcbiAgICBuZWdfY29sb3I6IGZ1bmN0aW9uIG5lZ19jb2xvcigpIHtcbiAgICAgIHJldHVybiB0aGlzLnNldHQubmVnQ29sb3IgfHwgXCIjZTU0MTUwXCI7XG4gICAgfVxuICB9LFxuICBkYXRhOiBmdW5jdGlvbiBkYXRhKCkge1xuICAgIHJldHVybiB7fTtcbiAgfVxufSk7XG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvb3ZlcmxheXMvREhpc3RvZ3JhbS9ESGlzdG9ncmFtLnZ1ZT92dWUmdHlwZT1zY3JpcHQmbGFuZz1qcyZcbiAvKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIGNvbnN0IERIaXN0b2dyYW1fREhpc3RvZ3JhbXZ1ZV90eXBlX3NjcmlwdF9sYW5nX2pzXyA9IChESGlzdG9ncmFtdnVlX3R5cGVfc2NyaXB0X2xhbmdfanNfKTsgXG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvb3ZlcmxheXMvREhpc3RvZ3JhbS9ESGlzdG9ncmFtLnZ1ZVxudmFyIERIaXN0b2dyYW1fcmVuZGVyLCBESGlzdG9ncmFtX3N0YXRpY1JlbmRlckZuc1xuO1xuXG5cblxuLyogbm9ybWFsaXplIGNvbXBvbmVudCAqL1xuO1xudmFyIERIaXN0b2dyYW1fY29tcG9uZW50ID0gbm9ybWFsaXplQ29tcG9uZW50KFxuICBESGlzdG9ncmFtX0RIaXN0b2dyYW12dWVfdHlwZV9zY3JpcHRfbGFuZ19qc18sXG4gIERIaXN0b2dyYW1fcmVuZGVyLFxuICBESGlzdG9ncmFtX3N0YXRpY1JlbmRlckZucyxcbiAgZmFsc2UsXG4gIG51bGwsXG4gIG51bGwsXG4gIG51bGxcbiAgXG4pXG5cbi8qIGhvdCByZWxvYWQgKi9cbmlmIChmYWxzZSkgeyB2YXIgREhpc3RvZ3JhbV9hcGk7IH1cbkRIaXN0b2dyYW1fY29tcG9uZW50Lm9wdGlvbnMuX19maWxlID0gXCJzcmMvb3ZlcmxheXMvREhpc3RvZ3JhbS9ESGlzdG9ncmFtLnZ1ZVwiXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIGNvbnN0IERIaXN0b2dyYW0gPSAoREhpc3RvZ3JhbV9jb21wb25lbnQuZXhwb3J0cyk7XG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9ub2RlX21vZHVsZXMvYmFiZWwtbG9hZGVyL2xpYi9pbmRleC5qcyEuL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9pbmRleC5qcz8/dnVlLWxvYWRlci1vcHRpb25zIS4vc3JjL292ZXJsYXlzL0RNSS9ETUkudnVlP3Z1ZSZ0eXBlPXNjcmlwdCZsYW5nPWpzJlxuXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIGNvbnN0IERNSXZ1ZV90eXBlX3NjcmlwdF9sYW5nX2pzXyA9ICh7XG4gIG5hbWU6ICdETUknLFxuICBtaXhpbnM6IFtleHRlcm5hbF90cmFkaW5nX3Z1ZV9qc18uT3ZlcmxheV0sXG4gIG1ldGhvZHM6IHtcbiAgICBtZXRhX2luZm86IGZ1bmN0aW9uIG1ldGFfaW5mbygpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGF1dGhvcjogJ1N0ZFNxdWFkJyxcbiAgICAgICAgdmVyc2lvbjogJzEuMC4wJyxcbiAgICAgICAgZGVzYzogJ0RpcmVjdGlvbmFsIE1vdmVtZW50IEluZGV4JyxcbiAgICAgICAgcHJlc2V0OiB7XG4gICAgICAgICAgbmFtZTogJ0RNSSAkbGVuZ3RoICRzbW9vdGgnLFxuICAgICAgICAgIHNpZGU6ICdvZmZjaGFydCcsXG4gICAgICAgICAgc2V0dGluZ3M6IHtcbiAgICAgICAgICAgIGxpbmVXaWR0aDogMC43NSxcbiAgICAgICAgICAgIGNvbG9yczogW1wiI2VmMTM2MFwiLCBcIiMzNzgyZjJcIiwgXCIjZjQ4NzA5XCJdXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9O1xuICAgIH0sXG4gICAgdXNlX2ZvcjogZnVuY3Rpb24gdXNlX2ZvcigpIHtcbiAgICAgIHJldHVybiBbJ0RNSSddO1xuICAgIH0sXG4gICAgY2FsYzogZnVuY3Rpb24gY2FsYygpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHByb3BzOiB7XG4gICAgICAgICAgbGVuZ3RoOiB7XG4gICAgICAgICAgICBkZWY6IDE1LFxuICAgICAgICAgICAgdGV4dDogJ0RJIExlbmd0aCdcbiAgICAgICAgICB9LFxuICAgICAgICAgIHNtb290aDoge1xuICAgICAgICAgICAgZGVmOiAxNSxcbiAgICAgICAgICAgIHRleHQ6ICdBRFggU21vdGhpbmcnXG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBjb25mOiB7XG4gICAgICAgICAgcmVuZGVyZXI6ICdTcGxpbmVzJ1xuICAgICAgICB9LFxuICAgICAgICB1cGRhdGU6IFwiXFxuICAgICAgICAgICAgICAgICAgICBsZXQgW2FkeCwgZHAsIGRuXSA9IGRtaShsZW5ndGgsIHNtb290aClcXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbYWR4WzBdLCBkcFswXSwgZG5bMF1dXFxuICAgICAgICAgICAgICAgIFwiXG4gICAgICB9O1xuICAgIH1cbiAgfVxufSk7XG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvb3ZlcmxheXMvRE1JL0RNSS52dWU/dnVlJnR5cGU9c2NyaXB0Jmxhbmc9anMmXG4gLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyBjb25zdCBETUlfRE1JdnVlX3R5cGVfc2NyaXB0X2xhbmdfanNfID0gKERNSXZ1ZV90eXBlX3NjcmlwdF9sYW5nX2pzXyk7IFxuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL292ZXJsYXlzL0RNSS9ETUkudnVlXG52YXIgRE1JX3JlbmRlciwgRE1JX3N0YXRpY1JlbmRlckZuc1xuO1xuXG5cblxuLyogbm9ybWFsaXplIGNvbXBvbmVudCAqL1xuO1xudmFyIERNSV9jb21wb25lbnQgPSBub3JtYWxpemVDb21wb25lbnQoXG4gIERNSV9ETUl2dWVfdHlwZV9zY3JpcHRfbGFuZ19qc18sXG4gIERNSV9yZW5kZXIsXG4gIERNSV9zdGF0aWNSZW5kZXJGbnMsXG4gIGZhbHNlLFxuICBudWxsLFxuICBudWxsLFxuICBudWxsXG4gIFxuKVxuXG4vKiBob3QgcmVsb2FkICovXG5pZiAoZmFsc2UpIHsgdmFyIERNSV9hcGk7IH1cbkRNSV9jb21wb25lbnQub3B0aW9ucy5fX2ZpbGUgPSBcInNyYy9vdmVybGF5cy9ETUkvRE1JLnZ1ZVwiXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIGNvbnN0IERNSSA9IChETUlfY29tcG9uZW50LmV4cG9ydHMpO1xuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vbm9kZV9tb2R1bGVzL2JhYmVsLWxvYWRlci9saWIvaW5kZXguanMhLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvaW5kZXguanM/P3Z1ZS1sb2FkZXItb3B0aW9ucyEuL3NyYy9vdmVybGF5cy9FTUEvRU1BLnZ1ZT92dWUmdHlwZT1zY3JpcHQmbGFuZz1qcyZcblxuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyBjb25zdCBFTUF2dWVfdHlwZV9zY3JpcHRfbGFuZ19qc18gPSAoe1xuICBuYW1lOiAnRU1BJyxcbiAgbWl4aW5zOiBbZXh0ZXJuYWxfdHJhZGluZ192dWVfanNfLk92ZXJsYXldLFxuICBtZXRob2RzOiB7XG4gICAgbWV0YV9pbmZvOiBmdW5jdGlvbiBtZXRhX2luZm8oKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBhdXRob3I6ICdTdGRTcXVhZCcsXG4gICAgICAgIHZlcnNpb246ICcxLjAuMCcsXG4gICAgICAgIGRlc2M6ICdFeHBvbmVudGlhbCBNb3ZpbmcgQXZlcmFnZScsXG4gICAgICAgIHByZXNldDoge1xuICAgICAgICAgIG5hbWU6ICdFTUEgJGxlbmd0aCcsXG4gICAgICAgICAgc2lkZTogJ29uY2hhcnQnLFxuICAgICAgICAgIHNldHRpbmdzOiB7XG4gICAgICAgICAgICBsaW5lV2lkdGg6IDAuNzUsXG4gICAgICAgICAgICBjb2xvcjogJyNmNzg5MGMnXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9O1xuICAgIH0sXG4gICAgdXNlX2ZvcjogZnVuY3Rpb24gdXNlX2ZvcigpIHtcbiAgICAgIHJldHVybiBbJ0VNQSddO1xuICAgIH0sXG4gICAgY2FsYzogZnVuY3Rpb24gY2FsYygpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHByb3BzOiB7XG4gICAgICAgICAgbGVuZ3RoOiB7XG4gICAgICAgICAgICBkZWY6IDEyLFxuICAgICAgICAgICAgdGV4dDogJ0xlbmd0aCdcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIGNvbmY6IHtcbiAgICAgICAgICByZW5kZXJlcjogJ1NwbGluZSdcbiAgICAgICAgfSxcbiAgICAgICAgdXBkYXRlOiBcIlxcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGVtYShjbG9zZSwgbGVuZ3RoKVswXVxcbiAgICAgICAgICAgICAgICBcIlxuICAgICAgfTtcbiAgICB9XG4gIH1cbn0pO1xuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL292ZXJsYXlzL0VNQS9FTUEudnVlP3Z1ZSZ0eXBlPXNjcmlwdCZsYW5nPWpzJlxuIC8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gY29uc3QgRU1BX0VNQXZ1ZV90eXBlX3NjcmlwdF9sYW5nX2pzXyA9IChFTUF2dWVfdHlwZV9zY3JpcHRfbGFuZ19qc18pOyBcbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9vdmVybGF5cy9FTUEvRU1BLnZ1ZVxudmFyIEVNQV9yZW5kZXIsIEVNQV9zdGF0aWNSZW5kZXJGbnNcbjtcblxuXG5cbi8qIG5vcm1hbGl6ZSBjb21wb25lbnQgKi9cbjtcbnZhciBFTUFfY29tcG9uZW50ID0gbm9ybWFsaXplQ29tcG9uZW50KFxuICBFTUFfRU1BdnVlX3R5cGVfc2NyaXB0X2xhbmdfanNfLFxuICBFTUFfcmVuZGVyLFxuICBFTUFfc3RhdGljUmVuZGVyRm5zLFxuICBmYWxzZSxcbiAgbnVsbCxcbiAgbnVsbCxcbiAgbnVsbFxuICBcbilcblxuLyogaG90IHJlbG9hZCAqL1xuaWYgKGZhbHNlKSB7IHZhciBFTUFfYXBpOyB9XG5FTUFfY29tcG9uZW50Lm9wdGlvbnMuX19maWxlID0gXCJzcmMvb3ZlcmxheXMvRU1BL0VNQS52dWVcIlxuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyBjb25zdCBFTUEgPSAoRU1BX2NvbXBvbmVudC5leHBvcnRzKTtcbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL25vZGVfbW9kdWxlcy9iYWJlbC1sb2FkZXIvbGliL2luZGV4LmpzIS4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL2luZGV4LmpzPz92dWUtbG9hZGVyLW9wdGlvbnMhLi9zcmMvb3ZlcmxheXMvSE1BL0hNQS52dWU/dnVlJnR5cGU9c2NyaXB0Jmxhbmc9anMmXG5cbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gY29uc3QgSE1BdnVlX3R5cGVfc2NyaXB0X2xhbmdfanNfID0gKHtcbiAgbmFtZTogJ0hNQScsXG4gIG1peGluczogW2V4dGVybmFsX3RyYWRpbmdfdnVlX2pzXy5PdmVybGF5XSxcbiAgbWV0aG9kczoge1xuICAgIG1ldGFfaW5mbzogZnVuY3Rpb24gbWV0YV9pbmZvKCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgYXV0aG9yOiAnU3RkU3F1YWQnLFxuICAgICAgICB2ZXJzaW9uOiAnMS4wLjAnLFxuICAgICAgICBkZXNjOiAnSHVsbCBNb3ZpbmcgQXZlcmFnZScsXG4gICAgICAgIHByZXNldDoge1xuICAgICAgICAgIG5hbWU6ICdITUEgJGxlbmd0aCcsXG4gICAgICAgICAgc2lkZTogJ29uY2hhcnQnLFxuICAgICAgICAgIHNldHRpbmdzOiB7XG4gICAgICAgICAgICBsaW5lV2lkdGg6IDAuNzUsXG4gICAgICAgICAgICBjb2xvcjogJyMzYWY0NzUnXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9O1xuICAgIH0sXG4gICAgdXNlX2ZvcjogZnVuY3Rpb24gdXNlX2ZvcigpIHtcbiAgICAgIHJldHVybiBbJ0hNQSddO1xuICAgIH0sXG4gICAgY2FsYzogZnVuY3Rpb24gY2FsYygpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHByb3BzOiB7XG4gICAgICAgICAgbGVuZ3RoOiB7XG4gICAgICAgICAgICBkZWY6IDEwLFxuICAgICAgICAgICAgdGV4dDogJ0xlbmd0aCdcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIGNvbmY6IHtcbiAgICAgICAgICByZW5kZXJlcjogJ1NwbGluZSdcbiAgICAgICAgfSxcbiAgICAgICAgdXBkYXRlOiBcIlxcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGhtYShjbG9zZSwgbGVuZ3RoKVswXVxcbiAgICAgICAgICAgICAgICBcIlxuICAgICAgfTtcbiAgICB9XG4gIH1cbn0pO1xuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL292ZXJsYXlzL0hNQS9ITUEudnVlP3Z1ZSZ0eXBlPXNjcmlwdCZsYW5nPWpzJlxuIC8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gY29uc3QgSE1BX0hNQXZ1ZV90eXBlX3NjcmlwdF9sYW5nX2pzXyA9IChITUF2dWVfdHlwZV9zY3JpcHRfbGFuZ19qc18pOyBcbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9vdmVybGF5cy9ITUEvSE1BLnZ1ZVxudmFyIEhNQV9yZW5kZXIsIEhNQV9zdGF0aWNSZW5kZXJGbnNcbjtcblxuXG5cbi8qIG5vcm1hbGl6ZSBjb21wb25lbnQgKi9cbjtcbnZhciBITUFfY29tcG9uZW50ID0gbm9ybWFsaXplQ29tcG9uZW50KFxuICBITUFfSE1BdnVlX3R5cGVfc2NyaXB0X2xhbmdfanNfLFxuICBITUFfcmVuZGVyLFxuICBITUFfc3RhdGljUmVuZGVyRm5zLFxuICBmYWxzZSxcbiAgbnVsbCxcbiAgbnVsbCxcbiAgbnVsbFxuICBcbilcblxuLyogaG90IHJlbG9hZCAqL1xuaWYgKGZhbHNlKSB7IHZhciBITUFfYXBpOyB9XG5ITUFfY29tcG9uZW50Lm9wdGlvbnMuX19maWxlID0gXCJzcmMvb3ZlcmxheXMvSE1BL0hNQS52dWVcIlxuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyBjb25zdCBITUEgPSAoSE1BX2NvbXBvbmVudC5leHBvcnRzKTtcbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL25vZGVfbW9kdWxlcy9iYWJlbC1sb2FkZXIvbGliL2luZGV4LmpzIS4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL2luZGV4LmpzPz92dWUtbG9hZGVyLW9wdGlvbnMhLi9zcmMvb3ZlcmxheXMvSGlzdG9ncmFtL0hpc3RvZ3JhbS52dWU/dnVlJnR5cGU9c2NyaXB0Jmxhbmc9anMmXG5mdW5jdGlvbiBIaXN0b2dyYW12dWVfdHlwZV9zY3JpcHRfbGFuZ19qc19jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyKG8sIGFsbG93QXJyYXlMaWtlKSB7IHZhciBpdCA9IHR5cGVvZiBTeW1ib2wgIT09IFwidW5kZWZpbmVkXCIgJiYgb1tTeW1ib2wuaXRlcmF0b3JdIHx8IG9bXCJAQGl0ZXJhdG9yXCJdOyBpZiAoIWl0KSB7IGlmIChBcnJheS5pc0FycmF5KG8pIHx8IChpdCA9IEhpc3RvZ3JhbXZ1ZV90eXBlX3NjcmlwdF9sYW5nX2pzX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5KG8pKSB8fCBhbGxvd0FycmF5TGlrZSAmJiBvICYmIHR5cGVvZiBvLmxlbmd0aCA9PT0gXCJudW1iZXJcIikgeyBpZiAoaXQpIG8gPSBpdDsgdmFyIGkgPSAwOyB2YXIgRiA9IGZ1bmN0aW9uIEYoKSB7fTsgcmV0dXJuIHsgczogRiwgbjogZnVuY3Rpb24gbigpIHsgaWYgKGkgPj0gby5sZW5ndGgpIHJldHVybiB7IGRvbmU6IHRydWUgfTsgcmV0dXJuIHsgZG9uZTogZmFsc2UsIHZhbHVlOiBvW2krK10gfTsgfSwgZTogZnVuY3Rpb24gZShfZSkgeyB0aHJvdyBfZTsgfSwgZjogRiB9OyB9IHRocm93IG5ldyBUeXBlRXJyb3IoXCJJbnZhbGlkIGF0dGVtcHQgdG8gaXRlcmF0ZSBub24taXRlcmFibGUgaW5zdGFuY2UuXFxuSW4gb3JkZXIgdG8gYmUgaXRlcmFibGUsIG5vbi1hcnJheSBvYmplY3RzIG11c3QgaGF2ZSBhIFtTeW1ib2wuaXRlcmF0b3JdKCkgbWV0aG9kLlwiKTsgfSB2YXIgbm9ybWFsQ29tcGxldGlvbiA9IHRydWUsIGRpZEVyciA9IGZhbHNlLCBlcnI7IHJldHVybiB7IHM6IGZ1bmN0aW9uIHMoKSB7IGl0ID0gaXQuY2FsbChvKTsgfSwgbjogZnVuY3Rpb24gbigpIHsgdmFyIHN0ZXAgPSBpdC5uZXh0KCk7IG5vcm1hbENvbXBsZXRpb24gPSBzdGVwLmRvbmU7IHJldHVybiBzdGVwOyB9LCBlOiBmdW5jdGlvbiBlKF9lMikgeyBkaWRFcnIgPSB0cnVlOyBlcnIgPSBfZTI7IH0sIGY6IGZ1bmN0aW9uIGYoKSB7IHRyeSB7IGlmICghbm9ybWFsQ29tcGxldGlvbiAmJiBpdFtcInJldHVyblwiXSAhPSBudWxsKSBpdFtcInJldHVyblwiXSgpOyB9IGZpbmFsbHkgeyBpZiAoZGlkRXJyKSB0aHJvdyBlcnI7IH0gfSB9OyB9XG5cbmZ1bmN0aW9uIEhpc3RvZ3JhbXZ1ZV90eXBlX3NjcmlwdF9sYW5nX2pzX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5KG8sIG1pbkxlbikgeyBpZiAoIW8pIHJldHVybjsgaWYgKHR5cGVvZiBvID09PSBcInN0cmluZ1wiKSByZXR1cm4gSGlzdG9ncmFtdnVlX3R5cGVfc2NyaXB0X2xhbmdfanNfYXJyYXlMaWtlVG9BcnJheShvLCBtaW5MZW4pOyB2YXIgbiA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvKS5zbGljZSg4LCAtMSk7IGlmIChuID09PSBcIk9iamVjdFwiICYmIG8uY29uc3RydWN0b3IpIG4gPSBvLmNvbnN0cnVjdG9yLm5hbWU7IGlmIChuID09PSBcIk1hcFwiIHx8IG4gPT09IFwiU2V0XCIpIHJldHVybiBBcnJheS5mcm9tKG8pOyBpZiAobiA9PT0gXCJBcmd1bWVudHNcIiB8fCAvXig/OlVpfEkpbnQoPzo4fDE2fDMyKSg/OkNsYW1wZWQpP0FycmF5JC8udGVzdChuKSkgcmV0dXJuIEhpc3RvZ3JhbXZ1ZV90eXBlX3NjcmlwdF9sYW5nX2pzX2FycmF5TGlrZVRvQXJyYXkobywgbWluTGVuKTsgfVxuXG5mdW5jdGlvbiBIaXN0b2dyYW12dWVfdHlwZV9zY3JpcHRfbGFuZ19qc19hcnJheUxpa2VUb0FycmF5KGFyciwgbGVuKSB7IGlmIChsZW4gPT0gbnVsbCB8fCBsZW4gPiBhcnIubGVuZ3RoKSBsZW4gPSBhcnIubGVuZ3RoOyBmb3IgKHZhciBpID0gMCwgYXJyMiA9IG5ldyBBcnJheShsZW4pOyBpIDwgbGVuOyBpKyspIHsgYXJyMltpXSA9IGFycltpXTsgfSByZXR1cm4gYXJyMjsgfVxuXG5cbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gY29uc3QgSGlzdG9ncmFtdnVlX3R5cGVfc2NyaXB0X2xhbmdfanNfID0gKHtcbiAgbmFtZTogJ0hpc3RvZ3JhbScsXG4gIG1peGluczogW2V4dGVybmFsX3RyYWRpbmdfdnVlX2pzXy5PdmVybGF5XSxcbiAgbWV0aG9kczoge1xuICAgIG1ldGFfaW5mbzogZnVuY3Rpb24gbWV0YV9pbmZvKCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgYXV0aG9yOiAnU3RkU3F1YWQnLFxuICAgICAgICB2ZXJzaW9uOiAnMS4wLjAnLFxuICAgICAgICBkZXNjOiAnSGlzdG9ncmFtIHBsb3QnXG4gICAgICB9O1xuICAgIH0sXG4gICAgZHJhdzogZnVuY3Rpb24gZHJhdyhjdHgpIHtcbiAgICAgIGN0eC5saW5lV2lkdGggPSB0aGlzLmxpbmVfd2lkdGg7XG4gICAgICBjdHguc3Ryb2tlU3R5bGUgPSB0aGlzLmNvbG9yO1xuICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgdmFyIGxheW91dCA9IHRoaXMuJHByb3BzLmxheW91dDtcbiAgICAgIHZhciBiYXNlID0gbGF5b3V0LiQyc2NyZWVuKDApICsgMC41O1xuICAgICAgdmFyIG9mZiA9IHRoaXMubGluZV93aWR0aCAlIDIgPyAwIDogMC41OyAvLyBDb2xvciBjaGFuZ2VkXG5cbiAgICAgIHZhciBjaGFuZ2VkID0gZmFsc2U7XG5cbiAgICAgIHZhciBfaXRlcmF0b3IgPSBIaXN0b2dyYW12dWVfdHlwZV9zY3JpcHRfbGFuZ19qc19jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyKHRoaXMuJHByb3BzLmRhdGEpLFxuICAgICAgICAgIF9zdGVwO1xuXG4gICAgICB0cnkge1xuICAgICAgICBmb3IgKF9pdGVyYXRvci5zKCk7ICEoX3N0ZXAgPSBfaXRlcmF0b3IubigpKS5kb25lOykge1xuICAgICAgICAgIHZhciBwID0gX3N0ZXAudmFsdWU7XG4gICAgICAgICAgdmFyIHggPSBsYXlvdXQudDJzY3JlZW4ocFswXSkgLSBvZmY7XG4gICAgICAgICAgdmFyIHkgPSBsYXlvdXQuJDJzY3JlZW4ocFsxXSkgLSAwLjU7XG4gICAgICAgICAgdmFyIF9jaGFuZ2VkID0gZmFsc2U7XG5cbiAgICAgICAgICBpZiAocFsyXSkge1xuICAgICAgICAgICAgaWYgKGN0eC5zdHJva2VTdHlsZSAhPT0gcFsyXSkge1xuICAgICAgICAgICAgICBjdHguc3Ryb2tlKCk7XG4gICAgICAgICAgICAgIF9jaGFuZ2VkID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY3R4LnN0cm9rZVN0eWxlID0gcFsyXTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKGN0eC5zdHJva2VTdHlsZSAhPT0gdGhpcy5jb2xvcikge1xuICAgICAgICAgICAgICBjdHguc3Ryb2tlKCk7XG4gICAgICAgICAgICAgIF9jaGFuZ2VkID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY3R4LnN0cm9rZVN0eWxlID0gdGhpcy5jb2xvcjtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoX2NoYW5nZWQpIGN0eC5iZWdpblBhdGgoKTtcbiAgICAgICAgICBjdHgubW92ZVRvKHgsIGJhc2UpO1xuICAgICAgICAgIGN0eC5saW5lVG8oeCwgeSk7XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICBfaXRlcmF0b3IuZShlcnIpO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgX2l0ZXJhdG9yLmYoKTtcbiAgICAgIH1cblxuICAgICAgY3R4LnN0cm9rZSgpO1xuICAgIH0sXG4gICAgdXNlX2ZvcjogZnVuY3Rpb24gdXNlX2ZvcigpIHtcbiAgICAgIHJldHVybiBbJ0hpc3RvZ3JhbSddO1xuICAgIH0sXG4gICAgbGVnZW5kOiBmdW5jdGlvbiBsZWdlbmQodmFsdWVzKSB7XG4gICAgICB2YXIgeCA9IHZhbHVlc1sxXTtcblxuICAgICAgaWYgKHR5cGVvZiB4ID09PSBcIm51bWJlclwiKSB7XG4gICAgICAgIHggPSB4LnRvRml4ZWQoTWF0aC5hYnMoeCkgPiAwLjAwMSA/IDQgOiA4KTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIFt7XG4gICAgICAgIHZhbHVlOiB4LFxuICAgICAgICBjb2xvcjogdmFsdWVzWzJdIHx8IHRoaXMuY29sb3JcbiAgICAgIH1dO1xuICAgIH1cbiAgfSxcbiAgLy8gRGVmaW5lIGludGVybmFsIHNldHRpbmcgJiBjb25zdGFudHMgaGVyZVxuICBjb21wdXRlZDoge1xuICAgIHNldHQ6IGZ1bmN0aW9uIHNldHQoKSB7XG4gICAgICByZXR1cm4gdGhpcy4kcHJvcHMuc2V0dGluZ3M7XG4gICAgfSxcbiAgICBsaW5lX3dpZHRoOiBmdW5jdGlvbiBsaW5lX3dpZHRoKCkge1xuICAgICAgcmV0dXJuIHRoaXMuc2V0dC5saW5lV2lkdGggfHwgMjtcbiAgICB9LFxuICAgIGNvbG9yOiBmdW5jdGlvbiBjb2xvcigpIHtcbiAgICAgIHZhciBuID0gdGhpcy4kcHJvcHMubnVtICUgNTtcbiAgICAgIHJldHVybiB0aGlzLnNldHQuY29sb3IgfHwgdGhpcy5DT0xPUlNbbl07XG4gICAgfVxuICB9LFxuICBkYXRhOiBmdW5jdGlvbiBkYXRhKCkge1xuICAgIHJldHVybiB7XG4gICAgICBDT0xPUlM6IFsnIzg4ODg4OCcsICcjNDJiMjhhJywgJyM1NjkxY2UnLCAnIzYxMmZmOScsICcjZDUwYjkwJywgJyNmZjIzMTYnXVxuICAgIH07XG4gIH1cbn0pO1xuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL292ZXJsYXlzL0hpc3RvZ3JhbS9IaXN0b2dyYW0udnVlP3Z1ZSZ0eXBlPXNjcmlwdCZsYW5nPWpzJlxuIC8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gY29uc3QgSGlzdG9ncmFtX0hpc3RvZ3JhbXZ1ZV90eXBlX3NjcmlwdF9sYW5nX2pzXyA9IChIaXN0b2dyYW12dWVfdHlwZV9zY3JpcHRfbGFuZ19qc18pOyBcbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9vdmVybGF5cy9IaXN0b2dyYW0vSGlzdG9ncmFtLnZ1ZVxudmFyIEhpc3RvZ3JhbV9yZW5kZXIsIEhpc3RvZ3JhbV9zdGF0aWNSZW5kZXJGbnNcbjtcblxuXG5cbi8qIG5vcm1hbGl6ZSBjb21wb25lbnQgKi9cbjtcbnZhciBIaXN0b2dyYW1fY29tcG9uZW50ID0gbm9ybWFsaXplQ29tcG9uZW50KFxuICBIaXN0b2dyYW1fSGlzdG9ncmFtdnVlX3R5cGVfc2NyaXB0X2xhbmdfanNfLFxuICBIaXN0b2dyYW1fcmVuZGVyLFxuICBIaXN0b2dyYW1fc3RhdGljUmVuZGVyRm5zLFxuICBmYWxzZSxcbiAgbnVsbCxcbiAgbnVsbCxcbiAgbnVsbFxuICBcbilcblxuLyogaG90IHJlbG9hZCAqL1xuaWYgKGZhbHNlKSB7IHZhciBIaXN0b2dyYW1fYXBpOyB9XG5IaXN0b2dyYW1fY29tcG9uZW50Lm9wdGlvbnMuX19maWxlID0gXCJzcmMvb3ZlcmxheXMvSGlzdG9ncmFtL0hpc3RvZ3JhbS52dWVcIlxuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyBjb25zdCBIaXN0b2dyYW0gPSAoSGlzdG9ncmFtX2NvbXBvbmVudC5leHBvcnRzKTtcbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL25vZGVfbW9kdWxlcy9iYWJlbC1sb2FkZXIvbGliL2luZGV4LmpzIS4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL2luZGV4LmpzPz92dWUtbG9hZGVyLW9wdGlvbnMhLi9zcmMvb3ZlcmxheXMvSWNoaS9JY2hpLnZ1ZT92dWUmdHlwZT1zY3JpcHQmbGFuZz1qcyZcbi8vIENsb3VkIHJlbmRlcmVyLiAoSWNoaW1va3UpXG5cbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gY29uc3QgSWNoaXZ1ZV90eXBlX3NjcmlwdF9sYW5nX2pzXyA9ICh7XG4gIG5hbWU6ICdJY2hpJyxcbiAgbWl4aW5zOiBbZXh0ZXJuYWxfdHJhZGluZ192dWVfanNfLk92ZXJsYXldLFxuICBtZXRob2RzOiB7XG4gICAgbWV0YV9pbmZvOiBmdW5jdGlvbiBtZXRhX2luZm8oKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBhdXRob3I6ICdDNDUxJyxcbiAgICAgICAgdmVyc2lvbjogJzEuMC4wJyxcbiAgICAgICAgZGVzYzogJ0ljaGltb2t1IENsb3VkIGJhc2VkIG9uIHNjcmlwdHMnXG4gICAgICB9O1xuICAgIH0sXG4gICAgZHJhdzogZnVuY3Rpb24gZHJhdyhjdHgpIHtcbiAgICAgIGN0eC5saW5lV2lkdGggPSB0aGlzLmxpbmVfd2lkdGg7XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy4kcHJvcHMuZGF0YS5sZW5ndGggLSAxOyBpKyspIHtcbiAgICAgICAgdmFyIHAxID0gdGhpcy5tYXBwKHRoaXMuJHByb3BzLmRhdGFbaV0pO1xuICAgICAgICB2YXIgcDIgPSB0aGlzLm1hcHAodGhpcy4kcHJvcHMuZGF0YVtpICsgMV0pO1xuICAgICAgICBpZiAoIXAyKSBjb250aW51ZTtcbiAgICAgICAgaWYgKHAxLnkxICE9PSBwMS55MSkgY29udGludWU7IC8vIEZpeCBOYU5cbiAgICAgICAgLy8gQmFja2dyb3VuZFxuXG4gICAgICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICAgICAgY3R4LmZpbGxTdHlsZSA9IHAxLnkxIDwgcDEueTIgPyB0aGlzLmJhY2sxIDogdGhpcy5iYWNrMjtcbiAgICAgICAgY3R4Lm1vdmVUbyhwMS54LCBwMS55MSk7XG4gICAgICAgIGN0eC5saW5lVG8ocDIueCArIDAuMSwgcDIueTEpO1xuICAgICAgICBjdHgubGluZVRvKHAyLnggKyAwLjEsIHAyLnkyKTtcbiAgICAgICAgY3R4LmxpbmVUbyhwMS54LCBwMS55Mik7XG4gICAgICAgIGN0eC5maWxsKCk7IC8vIExpbmVzXG5cbiAgICAgICAgaWYgKCF0aGlzLmRyYXdfbGluZXMpIGNvbnRpbnVlO1xuICAgICAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgICAgIGN0eC5zdHJva2VTdHlsZSA9IHRoaXMuY29sb3IxO1xuICAgICAgICBjdHgubW92ZVRvKHAxLngsIHAxLnkxKTtcbiAgICAgICAgY3R4LmxpbmVUbyhwMi54LCBwMi55MSk7XG4gICAgICAgIGN0eC5zdHJva2UoKTtcbiAgICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgICBjdHguc3Ryb2tlU3R5bGUgPSB0aGlzLmNvbG9yMjtcbiAgICAgICAgY3R4Lm1vdmVUbyhwMS54LCBwMS55Mik7XG4gICAgICAgIGN0eC5saW5lVG8ocDIueCwgcDIueTIpO1xuICAgICAgICBjdHguc3Ryb2tlKCk7XG4gICAgICB9XG4gICAgfSxcbiAgICBtYXBwOiBmdW5jdGlvbiBtYXBwKHApIHtcbiAgICAgIHZhciBsYXlvdXQgPSB0aGlzLiRwcm9wcy5sYXlvdXQ7XG4gICAgICByZXR1cm4gcCAmJiB7XG4gICAgICAgIHg6IGxheW91dC50MnNjcmVlbihwWzBdKSxcbiAgICAgICAgeTE6IGxheW91dC4kMnNjcmVlbihwWzFdKSxcbiAgICAgICAgeTI6IGxheW91dC4kMnNjcmVlbihwWzJdKVxuICAgICAgfTtcbiAgICB9LFxuICAgIHVzZV9mb3I6IGZ1bmN0aW9uIHVzZV9mb3IoKSB7XG4gICAgICByZXR1cm4gWydJY2hpJ107XG4gICAgfSxcbiAgICBkYXRhX2NvbG9yczogZnVuY3Rpb24gZGF0YV9jb2xvcnMoKSB7XG4gICAgICByZXR1cm4gW3RoaXMuY29sb3IxLCB0aGlzLmNvbG9yMl07XG4gICAgfSxcbiAgICBjYWxjOiBmdW5jdGlvbiBjYWxjKCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgcHJvcHM6IHtcbiAgICAgICAgICBDUDoge1xuICAgICAgICAgICAgZGVmOiA5LFxuICAgICAgICAgICAgdGV4dDogJ0NvbnZlcnNpb24gTGluZSBMZW5ndGgnXG4gICAgICAgICAgfSxcbiAgICAgICAgICBCUDoge1xuICAgICAgICAgICAgZGVmOiAyNixcbiAgICAgICAgICAgIHRleHQ6ICdCYXNlIExpbmUgTGVuZ3RoJ1xuICAgICAgICAgIH0sXG4gICAgICAgICAgTFNQOiB7XG4gICAgICAgICAgICBkZWY6IDUyLFxuICAgICAgICAgICAgdGV4dDogJ0xhZ2dpbmcgU3BhbiAyIExlbmd0aCdcbiAgICAgICAgICB9LFxuICAgICAgICAgIERJWjoge1xuICAgICAgICAgICAgZGVmOiAyNixcbiAgICAgICAgICAgIHRleHQ6ICdEaXNwbGFjZW1lbnQnXG4gICAgICAgICAgfSxcbiAgICAgICAgICBiYXNlQ29sb3I6IHtcbiAgICAgICAgICAgIGRlZjogJ2Jyb3duJyxcbiAgICAgICAgICAgIHRleHQ6ICdCYXNlIExpbmUgQ29sb3InXG4gICAgICAgICAgfSxcbiAgICAgICAgICBjb252ZXJzaW9uQ29sb3I6IHtcbiAgICAgICAgICAgIGRlZjogJ2xpZ2h0Ymx1ZScsXG4gICAgICAgICAgICB0ZXh0OiAnQ29udmVyc2lvbiBMaW5lIENvbG9yJ1xuICAgICAgICAgIH0sXG4gICAgICAgICAgbGFnZ2luZ0NvbG9yOiB7XG4gICAgICAgICAgICBkZWY6ICcjNjZDQzY2JyxcbiAgICAgICAgICAgIHRleHQ6ICdMYWdnaW5nIFNwYW4gQ29sb3InXG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB1cGRhdGU6IFwiXFxuICAgICAgICAgICAgICAgICAgICBsZXQgZG9uY2hpYW4gPSAobGVuLCBpZCkgPT4gdHMoXFxuICAgICAgICAgICAgICAgICAgICAgICAgYXZnKGxvd2VzdChsb3csIGxlbilbMF0sIGhpZ2hlc3QoaGlnaCwgbGVuKVswXSksIGlkXFxuICAgICAgICAgICAgICAgICAgICApXFxuICAgICAgICAgICAgICAgICAgICBsZXQgY29udmVyc2lvbkxpbmUgPSBkb25jaGlhbihDUCwgMSlcXG4gICAgICAgICAgICAgICAgICAgIGxldCBiYXNlTGluZSA9IGRvbmNoaWFuKEJQLCAyKVxcbiAgICAgICAgICAgICAgICAgICAgbGV0IGxlYWRMaW5lMSA9IHRzKGF2Zyhjb252ZXJzaW9uTGluZVswXSwgYmFzZUxpbmVbMF0pKVxcbiAgICAgICAgICAgICAgICAgICAgbGV0IGxlYWRMaW5lMiA9IGRvbmNoaWFuKExTUCwgMylcXG4gICAgICAgICAgICAgICAgICAgIGxldCBsYWdnaW5nID0gdHMoY2xvc2VbMF0pXFxuXFxuXFxuICAgICAgICAgICAgICAgICAgICBvZmZzZXQodGhpcywgRElaIC0gMSlcXG4gICAgICAgICAgICAgICAgICAgIG9mZnNldChsYWdnaW5nLCAtRElaICsgMSlcXG4gICAgICAgICAgICAgICAgICAgIG9uY2hhcnQoW2NvbnZlcnNpb25MaW5lLCBiYXNlTGluZV0sICdCYXNlIExpbmVzJywge1xcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbG9yczogW2NvbnZlcnNpb25Db2xvciwgYmFzZUNvbG9yXVxcbiAgICAgICAgICAgICAgICAgICAgfSlcXG4gICAgICAgICAgICAgICAgICAgIG9uY2hhcnQobGFnZ2luZywgJ0xhZ2dpbmcgU3BhbicsIHtcXG4gICAgICAgICAgICAgICAgICAgICAgICBjb2xvcjogbGFnZ2luZ0NvbG9yXFxuICAgICAgICAgICAgICAgICAgICB9KVxcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFtsZWFkTGluZTFbMF0sIGxlYWRMaW5lMlswXV1cXG4gICAgICAgICAgICAgICAgXCJcbiAgICAgIH07XG4gICAgfVxuICB9LFxuICAvLyBEZWZpbmUgaW50ZXJuYWwgc2V0dGluZyAmIGNvbnN0YW50cyBoZXJlXG4gIGNvbXB1dGVkOiB7XG4gICAgc2V0dDogZnVuY3Rpb24gc2V0dCgpIHtcbiAgICAgIHJldHVybiB0aGlzLiRwcm9wcy5zZXR0aW5ncztcbiAgICB9LFxuICAgIGxpbmVfd2lkdGg6IGZ1bmN0aW9uIGxpbmVfd2lkdGgoKSB7XG4gICAgICByZXR1cm4gdGhpcy5zZXR0LmxpbmVXaWR0aCB8fCAwLjc1O1xuICAgIH0sXG4gICAgY29sb3IxOiBmdW5jdGlvbiBjb2xvcjEoKSB7XG4gICAgICByZXR1cm4gdGhpcy5zZXR0LmNvbG9yMSB8fCAnbGlnaHRncmVlbic7XG4gICAgfSxcbiAgICBjb2xvcjI6IGZ1bmN0aW9uIGNvbG9yMigpIHtcbiAgICAgIHJldHVybiB0aGlzLnNldHQuY29sb3IyIHx8ICdvcmFuZ2UnO1xuICAgIH0sXG4gICAgYmFjazE6IGZ1bmN0aW9uIGJhY2sxKCkge1xuICAgICAgcmV0dXJuIHRoaXMuc2V0dC5iYWNrMSB8fCAnIzc5ZmY5ZTIyJztcbiAgICB9LFxuICAgIGJhY2syOiBmdW5jdGlvbiBiYWNrMigpIHtcbiAgICAgIHJldHVybiB0aGlzLnNldHQuYmFjazIgfHwgJyNlZjUzNTAyMic7XG4gICAgfSxcbiAgICBkcmF3X2xpbmVzOiBmdW5jdGlvbiBkcmF3X2xpbmVzKCkge1xuICAgICAgcmV0dXJuIHRoaXMuc2V0dC5kcmF3TGluZXM7XG4gICAgfVxuICB9LFxuICBkYXRhOiBmdW5jdGlvbiBkYXRhKCkge1xuICAgIHJldHVybiB7XG4gICAgICBDT0xPUlM6IFsnIzQyYjI4YScsICcjNTY5MWNlJywgJyM2MTJmZjknLCAnI2Q1MGI5MCcsICcjZmYyMzE2J11cbiAgICB9O1xuICB9XG59KTtcbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9vdmVybGF5cy9JY2hpL0ljaGkudnVlP3Z1ZSZ0eXBlPXNjcmlwdCZsYW5nPWpzJlxuIC8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gY29uc3QgSWNoaV9JY2hpdnVlX3R5cGVfc2NyaXB0X2xhbmdfanNfID0gKEljaGl2dWVfdHlwZV9zY3JpcHRfbGFuZ19qc18pOyBcbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9vdmVybGF5cy9JY2hpL0ljaGkudnVlXG52YXIgSWNoaV9yZW5kZXIsIEljaGlfc3RhdGljUmVuZGVyRm5zXG47XG5cblxuXG4vKiBub3JtYWxpemUgY29tcG9uZW50ICovXG47XG52YXIgSWNoaV9jb21wb25lbnQgPSBub3JtYWxpemVDb21wb25lbnQoXG4gIEljaGlfSWNoaXZ1ZV90eXBlX3NjcmlwdF9sYW5nX2pzXyxcbiAgSWNoaV9yZW5kZXIsXG4gIEljaGlfc3RhdGljUmVuZGVyRm5zLFxuICBmYWxzZSxcbiAgbnVsbCxcbiAgbnVsbCxcbiAgbnVsbFxuICBcbilcblxuLyogaG90IHJlbG9hZCAqL1xuaWYgKGZhbHNlKSB7IHZhciBJY2hpX2FwaTsgfVxuSWNoaV9jb21wb25lbnQub3B0aW9ucy5fX2ZpbGUgPSBcInNyYy9vdmVybGF5cy9JY2hpL0ljaGkudnVlXCJcbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gY29uc3QgSWNoaSA9IChJY2hpX2NvbXBvbmVudC5leHBvcnRzKTtcbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL25vZGVfbW9kdWxlcy9iYWJlbC1sb2FkZXIvbGliL2luZGV4LmpzIS4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL2luZGV4LmpzPz92dWUtbG9hZGVyLW9wdGlvbnMhLi9zcmMvb3ZlcmxheXMvSWNoaW1va3UvSWNoaW1va3UudnVlP3Z1ZSZ0eXBlPXNjcmlwdCZsYW5nPWpzJlxuZnVuY3Rpb24gSWNoaW1va3V2dWVfdHlwZV9zY3JpcHRfbGFuZ19qc19jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyKG8sIGFsbG93QXJyYXlMaWtlKSB7IHZhciBpdCA9IHR5cGVvZiBTeW1ib2wgIT09IFwidW5kZWZpbmVkXCIgJiYgb1tTeW1ib2wuaXRlcmF0b3JdIHx8IG9bXCJAQGl0ZXJhdG9yXCJdOyBpZiAoIWl0KSB7IGlmIChBcnJheS5pc0FycmF5KG8pIHx8IChpdCA9IEljaGltb2t1dnVlX3R5cGVfc2NyaXB0X2xhbmdfanNfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkobykpIHx8IGFsbG93QXJyYXlMaWtlICYmIG8gJiYgdHlwZW9mIG8ubGVuZ3RoID09PSBcIm51bWJlclwiKSB7IGlmIChpdCkgbyA9IGl0OyB2YXIgaSA9IDA7IHZhciBGID0gZnVuY3Rpb24gRigpIHt9OyByZXR1cm4geyBzOiBGLCBuOiBmdW5jdGlvbiBuKCkgeyBpZiAoaSA+PSBvLmxlbmd0aCkgcmV0dXJuIHsgZG9uZTogdHJ1ZSB9OyByZXR1cm4geyBkb25lOiBmYWxzZSwgdmFsdWU6IG9baSsrXSB9OyB9LCBlOiBmdW5jdGlvbiBlKF9lKSB7IHRocm93IF9lOyB9LCBmOiBGIH07IH0gdGhyb3cgbmV3IFR5cGVFcnJvcihcIkludmFsaWQgYXR0ZW1wdCB0byBpdGVyYXRlIG5vbi1pdGVyYWJsZSBpbnN0YW5jZS5cXG5JbiBvcmRlciB0byBiZSBpdGVyYWJsZSwgbm9uLWFycmF5IG9iamVjdHMgbXVzdCBoYXZlIGEgW1N5bWJvbC5pdGVyYXRvcl0oKSBtZXRob2QuXCIpOyB9IHZhciBub3JtYWxDb21wbGV0aW9uID0gdHJ1ZSwgZGlkRXJyID0gZmFsc2UsIGVycjsgcmV0dXJuIHsgczogZnVuY3Rpb24gcygpIHsgaXQgPSBpdC5jYWxsKG8pOyB9LCBuOiBmdW5jdGlvbiBuKCkgeyB2YXIgc3RlcCA9IGl0Lm5leHQoKTsgbm9ybWFsQ29tcGxldGlvbiA9IHN0ZXAuZG9uZTsgcmV0dXJuIHN0ZXA7IH0sIGU6IGZ1bmN0aW9uIGUoX2UyKSB7IGRpZEVyciA9IHRydWU7IGVyciA9IF9lMjsgfSwgZjogZnVuY3Rpb24gZigpIHsgdHJ5IHsgaWYgKCFub3JtYWxDb21wbGV0aW9uICYmIGl0W1wicmV0dXJuXCJdICE9IG51bGwpIGl0W1wicmV0dXJuXCJdKCk7IH0gZmluYWxseSB7IGlmIChkaWRFcnIpIHRocm93IGVycjsgfSB9IH07IH1cblxuZnVuY3Rpb24gSWNoaW1va3V2dWVfdHlwZV9zY3JpcHRfbGFuZ19qc191bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheShvLCBtaW5MZW4pIHsgaWYgKCFvKSByZXR1cm47IGlmICh0eXBlb2YgbyA9PT0gXCJzdHJpbmdcIikgcmV0dXJuIEljaGltb2t1dnVlX3R5cGVfc2NyaXB0X2xhbmdfanNfYXJyYXlMaWtlVG9BcnJheShvLCBtaW5MZW4pOyB2YXIgbiA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvKS5zbGljZSg4LCAtMSk7IGlmIChuID09PSBcIk9iamVjdFwiICYmIG8uY29uc3RydWN0b3IpIG4gPSBvLmNvbnN0cnVjdG9yLm5hbWU7IGlmIChuID09PSBcIk1hcFwiIHx8IG4gPT09IFwiU2V0XCIpIHJldHVybiBBcnJheS5mcm9tKG8pOyBpZiAobiA9PT0gXCJBcmd1bWVudHNcIiB8fCAvXig/OlVpfEkpbnQoPzo4fDE2fDMyKSg/OkNsYW1wZWQpP0FycmF5JC8udGVzdChuKSkgcmV0dXJuIEljaGltb2t1dnVlX3R5cGVfc2NyaXB0X2xhbmdfanNfYXJyYXlMaWtlVG9BcnJheShvLCBtaW5MZW4pOyB9XG5cbmZ1bmN0aW9uIEljaGltb2t1dnVlX3R5cGVfc2NyaXB0X2xhbmdfanNfYXJyYXlMaWtlVG9BcnJheShhcnIsIGxlbikgeyBpZiAobGVuID09IG51bGwgfHwgbGVuID4gYXJyLmxlbmd0aCkgbGVuID0gYXJyLmxlbmd0aDsgZm9yICh2YXIgaSA9IDAsIGFycjIgPSBuZXcgQXJyYXkobGVuKTsgaSA8IGxlbjsgaSsrKSB7IGFycjJbaV0gPSBhcnJbaV07IH0gcmV0dXJuIGFycjI7IH1cblxuLy9JY2hpbW9rdSBJbmRpY2F0b3IgT3ZlcmxheS4gRXhwZWN0ZWQgRm9ybWF0OiBbIDx0aW1lc3RhbXA+LCA8Q29udmVyc2lvbkxpbmU+LCA8QmFzZUxpbmU+LCA8TGVhZDE+LCA8TGVhZDI+LCA8TGFnZ2luZz4gXVxuXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIGNvbnN0IEljaGltb2t1dnVlX3R5cGVfc2NyaXB0X2xhbmdfanNfID0gKHtcbiAgbmFtZTogXCJJY2hpbW9rdVwiLFxuICBtaXhpbnM6IFtleHRlcm5hbF90cmFkaW5nX3Z1ZV9qc18uT3ZlcmxheV0sXG4gIGRhdGE6IGZ1bmN0aW9uIGRhdGEoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGN0eFRlbmthbjoge30sXG4gICAgICBjdHhLaWp1bjoge30sXG4gICAgICBjdHhTZW5rb3VTcGFuQToge30sXG4gICAgICBjdHhTZW5rb3VTcGFuQjoge30sXG4gICAgICBjdHhDaGlua291OiB7fSxcbiAgICAgIGN0eEZpbGxLdW1vOiB7fSxcbiAgICAgIHRlbmthbjogW10sXG4gICAgICBraWp1bjogW10sXG4gICAgICBzZW5rb3VTcGFuQTogW10sXG4gICAgICBzZW5rb3VTcGFuQjogW10sXG4gICAgICBjaGlua291OiBbXSxcbiAgICAgIG9mZnNldDogMjYsXG4gICAgICB0ZW5rYW5MaW5lV2lkdGg6IDEsXG4gICAgICBraWp1bkxpbmVXaWR0aDogMSxcbiAgICAgIHNlbmtvdVNwYW5BTGluZVdpZHRoOiAxLFxuICAgICAgc2Vua291U3BhbkJMaW5lV2lkdGg6IDEsXG4gICAgICBjaGlua291TGluZVdpZHRoOiAxLFxuICAgICAgY29sb3JUZW5rYW46IFwiIzUyQTYzNFwiLFxuICAgICAgY29sb3JLaWp1bjogXCIjNTJBNTlEXCIsXG4gICAgICBjb2xvclNlbmtvdVNwYW5BOiBcIiM0Mzg2MjVcIixcbiAgICAgIGNvbG9yU2Vua291U3BhbkI6IFwiI2JkMDAzY1wiLFxuICAgICAgY29sb3JDaGlua291OiBcIiNCRjJBNjRcIixcbiAgICAgIGNvbG9yS3Vtb1VwOiBcIiMwNjNmMGZcIixcbiAgICAgIGNvbG9yS3Vtb0Rvd246IFwiIzM5MWMxOVwiLFxuICAgICAgc2hvd1RlbmthbjogdHJ1ZSxcbiAgICAgIHNob3dLaWp1bjogdHJ1ZSxcbiAgICAgIHNob3dTZW5rb3VTcGFuQTogdHJ1ZSxcbiAgICAgIHNob3dTZW5rb3VTcGFuQjogdHJ1ZSxcbiAgICAgIHNob3dDaGlua291OiB0cnVlLFxuICAgICAgc2hvd0ZpbGxLdW1vOiB0cnVlXG4gICAgfTtcbiAgfSxcbiAgY29tcHV0ZWQ6IHtcbiAgICBzZXR0OiBmdW5jdGlvbiBzZXR0KCkge1xuICAgICAgcmV0dXJuIHRoaXMuJHByb3BzLnNldHRpbmdzO1xuICAgIH0sXG4gICAgdGVua2FuX2NvbG9yOiBmdW5jdGlvbiB0ZW5rYW5fY29sb3IoKSB7XG4gICAgICByZXR1cm4gdGhpcy5zZXR0Wyd0ZW5rYW4tY29sb3InXSB8fCB0aGlzLmNvbG9yVGVua2FuO1xuICAgIH0sXG4gICAga2lqdW5fY29sb3I6IGZ1bmN0aW9uIGtpanVuX2NvbG9yKCkge1xuICAgICAgcmV0dXJuIHRoaXMuc2V0dFsna2lqdW4tY29sb3InXSB8fCB0aGlzLmNvbG9yS2lqdW47XG4gICAgfSxcbiAgICBzZW5rb3Vfc3BhbkFfY29sb3I6IGZ1bmN0aW9uIHNlbmtvdV9zcGFuQV9jb2xvcigpIHtcbiAgICAgIHJldHVybiB0aGlzLnNldHRbJ3NlbmtvdV9zcGFuQV9jb2xvciddIHx8IHRoaXMuY29sb3JTZW5rb3VTcGFuQTtcbiAgICB9LFxuICAgIHNlbmtvdV9zcGFuQl9jb2xvcjogZnVuY3Rpb24gc2Vua291X3NwYW5CX2NvbG9yKCkge1xuICAgICAgcmV0dXJuIHRoaXMuc2V0dFsnc2Vua291X3NwYW5CX2NvbG9yJ10gfHwgdGhpcy5jb2xvclNlbmtvdVNwYW5CO1xuICAgIH0sXG4gICAgY2hpbmtvdV9jb2xvcjogZnVuY3Rpb24gY2hpbmtvdV9jb2xvcigpIHtcbiAgICAgIHJldHVybiB0aGlzLnNldHRbJ2NoaW5rb3VfY29sb3InXSB8fCB0aGlzLmNvbG9yQ2hpbmtvdTtcbiAgICB9LFxuICAgIGt1bW9fdXBfY29sb3I6IGZ1bmN0aW9uIGt1bW9fdXBfY29sb3IoKSB7XG4gICAgICByZXR1cm4gdGhpcy5zZXR0WydrdW1vX3VwX2NvbG9yJ10gfHwgdGhpcy5jb2xvckt1bW9VcDtcbiAgICB9LFxuICAgIGt1bW9fZG93bl9jb2xvcjogZnVuY3Rpb24ga3Vtb19kb3duX2NvbG9yKCkge1xuICAgICAgcmV0dXJuIHRoaXMuc2V0dFsna3Vtb19kb3duX2NvbG9yJ10gfHwgdGhpcy5jb2xvckt1bW9Eb3duO1xuICAgIH0sXG4gICAgdGVua2FuX2xpbmVfd2lkdGg6IGZ1bmN0aW9uIHRlbmthbl9saW5lX3dpZHRoKCkge1xuICAgICAgcmV0dXJuIHRoaXMuc2V0dFsndGVua2FuX2xpbmVfd2lkdGgnXSB8fCB0aGlzLnRlbmthbkxpbmVXaWR0aDtcbiAgICB9LFxuICAgIGtpanVuX2xpbmVfd2lkdGg6IGZ1bmN0aW9uIGtpanVuX2xpbmVfd2lkdGgoKSB7XG4gICAgICByZXR1cm4gdGhpcy5zZXR0WydraWp1bl9saW5lX3dpZHRoJ10gfHwgdGhpcy5raWp1bkxpbmVXaWR0aDtcbiAgICB9LFxuICAgIHNlbmtvdV9zcGFuQV9saW5lX3dpZHRoOiBmdW5jdGlvbiBzZW5rb3Vfc3BhbkFfbGluZV93aWR0aCgpIHtcbiAgICAgIHJldHVybiB0aGlzLnNldHRbJ3NlbmtvdV9zcGFuQV9saW5lX3dpZHRoJ10gfHwgdGhpcy5zZW5rb3VTcGFuQUxpbmVXaWR0aDtcbiAgICB9LFxuICAgIHNlbmtvdV9zcGFuQl9saW5lX3dpZHRoOiBmdW5jdGlvbiBzZW5rb3Vfc3BhbkJfbGluZV93aWR0aCgpIHtcbiAgICAgIHJldHVybiB0aGlzLnNldHRbJ3NlbmtvdV9zcGFuQl9saW5lX3dpZHRoJ10gfHwgdGhpcy5zZW5rb3VTcGFuQkxpbmVXaWR0aDtcbiAgICB9LFxuICAgIGNoaW5rb3VfbGluZV93aWR0aDogZnVuY3Rpb24gY2hpbmtvdV9saW5lX3dpZHRoKCkge1xuICAgICAgcmV0dXJuIHRoaXMuc2V0dFsnY2hpbmtvdV9saW5lX3dpZHRoJ10gfHwgdGhpcy5jaGlua291TGluZVdpZHRoO1xuICAgIH1cbiAgfSxcbiAgbWV0aG9kczoge1xuICAgIG1ldGFfaW5mbzogZnVuY3Rpb24gbWV0YV9pbmZvKCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgYXV0aG9yOiBcIlN1ZGVlcCBCYXRyYVwiLFxuICAgICAgICB2ZXJzaW9uOiBcIjEuMC4wXCJcbiAgICAgIH07XG4gICAgfSxcbiAgICBkcmF3OiBmdW5jdGlvbiBkcmF3KGN0eCkge1xuICAgICAgdmFyIGxheW91dCA9IHRoaXMuJHByb3BzLmxheW91dDtcbiAgICAgIHZhciBwcm9wc1N1YiA9IHRoaXMuJHByb3BzLnN1YjtcbiAgICAgIHRoaXMuY3R4VGVua2FuID0gY3R4O1xuICAgICAgdGhpcy5jdHhLaWp1biA9IGN0eDtcbiAgICAgIHRoaXMuY3R4U2Vua291U3BhbkEgPSBjdHg7XG4gICAgICB0aGlzLmN0eFNlbmtvdVNwYW5CID0gY3R4O1xuICAgICAgdGhpcy5jdHhDaGlua291ID0gY3R4O1xuICAgICAgdGhpcy5jdHhGaWxsS3VtbyA9IGN0eDtcbiAgICAgIHZhciBzdWJkYXRhID0gdGhpcy4kcHJvcHMuZGF0YS5zbGljZSgwLCBwcm9wc1N1Yi5sZW5ndGgpO1xuICAgICAgdmFyIHN1YmRhdGFTZW5rb3VTcGFuID0gdGhpcy4kcHJvcHMuZGF0YS5zbGljZSgwLCBwcm9wc1N1Yi5sZW5ndGggKyB0aGlzLm9mZnNldCk7XG4gICAgICB2YXIgc3ViZGF0YUNoaW5rb3UgPSB0aGlzLiRwcm9wcy5kYXRhLnNsaWNlKDAsIHByb3BzU3ViLmxlbmd0aCAtIHRoaXMub2Zmc2V0KTtcblxuICAgICAgaWYgKHRoaXMuc2hvd0ZpbGxLdW1vKSB7XG4gICAgICAgIHRoaXMuY3R4RmlsbEt1bW8uYmVnaW5QYXRoKCk7XG4gICAgICAgIHZhciBpbmQgPSAwO1xuXG4gICAgICAgIHZhciBfaXRlcmF0b3IgPSBJY2hpbW9rdXZ1ZV90eXBlX3NjcmlwdF9sYW5nX2pzX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXIoc3ViZGF0YVNlbmtvdVNwYW4pLFxuICAgICAgICAgICAgX3N0ZXA7XG5cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBmb3IgKF9pdGVyYXRvci5zKCk7ICEoX3N0ZXAgPSBfaXRlcmF0b3IubigpKS5kb25lOykge1xuICAgICAgICAgICAgdmFyIGN1cnJJdGVtID0gX3N0ZXAudmFsdWU7XG5cbiAgICAgICAgICAgIGlmIChpbmQgPiAxKSB7XG4gICAgICAgICAgICAgIHZhciBwMSA9IHRoaXMubWFwX3NlbmtvdV9zcGFuX3ZhbHVlcyhzdWJkYXRhU2Vua291U3BhbltpbmQgLSAxXSk7XG4gICAgICAgICAgICAgIHZhciBwMiA9IHRoaXMubWFwX3NlbmtvdV9zcGFuX3ZhbHVlcyhjdXJySXRlbSk7XG4gICAgICAgICAgICAgIHRoaXMuY3R4U2Vua291U3BhbkIuYmVnaW5QYXRoKCk7XG4gICAgICAgICAgICAgIHRoaXMuY3R4U2Vua291U3BhbkIubW92ZVRvKHAxLngsIHAxLnNlbmtvdVNwYW5BKTtcbiAgICAgICAgICAgICAgdGhpcy5jdHhTZW5rb3VTcGFuQi5saW5lVG8ocDIueCArIDAuMSwgcDIuc2Vua291U3BhbkEpO1xuICAgICAgICAgICAgICB0aGlzLmN0eFNlbmtvdVNwYW5CLmxpbmVUbyhwMi54ICsgMC4xLCBwMi5zZW5rb3VTcGFuQik7XG4gICAgICAgICAgICAgIHRoaXMuY3R4U2Vua291U3BhbkIubGluZVRvKHAxLngsIHAxLnNlbmtvdVNwYW5CKTtcblxuICAgICAgICAgICAgICBpZiAocDEuc2Vua291U3BhbkEgPj0gcDEuc2Vua291U3BhbkIpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmN0eFNlbmtvdVNwYW5CLmZpbGxTdHlsZSA9IHRoaXMua3Vtb19kb3duX2NvbG9yO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuY3R4U2Vua291U3BhbkIuZmlsbFN0eWxlID0gdGhpcy5rdW1vX3VwX2NvbG9yO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgdGhpcy5jdHhTZW5rb3VTcGFuQi5maWxsKCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGluZCsrO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgX2l0ZXJhdG9yLmUoZXJyKTtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICBfaXRlcmF0b3IuZigpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5jdHhTZW5rb3VTcGFuQi5zdHJva2UoKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMuc2hvd1Rlbmthbikge1xuICAgICAgICB0aGlzLmN0eFRlbmthbi5iZWdpblBhdGgoKTtcblxuICAgICAgICB2YXIgX2l0ZXJhdG9yMiA9IEljaGltb2t1dnVlX3R5cGVfc2NyaXB0X2xhbmdfanNfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlcihzdWJkYXRhKSxcbiAgICAgICAgICAgIF9zdGVwMjtcblxuICAgICAgICB0cnkge1xuICAgICAgICAgIGZvciAoX2l0ZXJhdG9yMi5zKCk7ICEoX3N0ZXAyID0gX2l0ZXJhdG9yMi5uKCkpLmRvbmU7KSB7XG4gICAgICAgICAgICB2YXIgcFRlbmthbiA9IF9zdGVwMi52YWx1ZTtcbiAgICAgICAgICAgIHRoaXMuY3R4VGVua2FuLnN0cm9rZVN0eWxlID0gdGhpcy50ZW5rYW5fY29sb3I7XG4gICAgICAgICAgICB0aGlzLmN0eFRlbmthbi5saW5lV2lkdGggPSB0aGlzLnRlbmthbl9saW5lX3dpZHRoO1xuICAgICAgICAgICAgdGhpcy5jdHhUZW5rYW4ubGluZVRvKGxheW91dC50MnNjcmVlbihwVGVua2FuWzBdKSwgbGF5b3V0LiQyc2NyZWVuKHBUZW5rYW5bMV0pKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgIF9pdGVyYXRvcjIuZShlcnIpO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgIF9pdGVyYXRvcjIuZigpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5jdHhUZW5rYW4uc3Ryb2tlKCk7XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLnNob3dLaWp1bikge1xuICAgICAgICB0aGlzLmN0eEtpanVuLmJlZ2luUGF0aCgpO1xuXG4gICAgICAgIHZhciBfaXRlcmF0b3IzID0gSWNoaW1va3V2dWVfdHlwZV9zY3JpcHRfbGFuZ19qc19jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyKHN1YmRhdGEpLFxuICAgICAgICAgICAgX3N0ZXAzO1xuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgZm9yIChfaXRlcmF0b3IzLnMoKTsgIShfc3RlcDMgPSBfaXRlcmF0b3IzLm4oKSkuZG9uZTspIHtcbiAgICAgICAgICAgIHZhciBwS2lqdW4gPSBfc3RlcDMudmFsdWU7XG4gICAgICAgICAgICB0aGlzLmN0eEtpanVuLnN0cm9rZVN0eWxlID0gdGhpcy5raWp1bl9jb2xvcjtcbiAgICAgICAgICAgIHRoaXMuY3R4S2lqdW4ubGluZVdpZHRoID0gdGhpcy5raWp1bl9saW5lX3dpZHRoO1xuICAgICAgICAgICAgdGhpcy5jdHhLaWp1bi5saW5lVG8obGF5b3V0LnQyc2NyZWVuKHBLaWp1blswXSksIGxheW91dC4kMnNjcmVlbihwS2lqdW5bMl0pKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgIF9pdGVyYXRvcjMuZShlcnIpO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgIF9pdGVyYXRvcjMuZigpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5jdHhLaWp1bi5zdHJva2UoKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMuc2hvd1NlbmtvdVNwYW5BKSB7XG4gICAgICAgIHRoaXMuY3R4U2Vua291U3BhbkEuYmVnaW5QYXRoKCk7XG5cbiAgICAgICAgdmFyIF9pdGVyYXRvcjQgPSBJY2hpbW9rdXZ1ZV90eXBlX3NjcmlwdF9sYW5nX2pzX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXIoc3ViZGF0YVNlbmtvdVNwYW4pLFxuICAgICAgICAgICAgX3N0ZXA0O1xuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgZm9yIChfaXRlcmF0b3I0LnMoKTsgIShfc3RlcDQgPSBfaXRlcmF0b3I0Lm4oKSkuZG9uZTspIHtcbiAgICAgICAgICAgIHZhciBwU2Vua291U3BhbkEgPSBfc3RlcDQudmFsdWU7XG4gICAgICAgICAgICB0aGlzLmN0eFNlbmtvdVNwYW5BLnN0cm9rZVN0eWxlID0gdGhpcy5zZW5rb3Vfc3BhbkFfY29sb3I7XG4gICAgICAgICAgICB0aGlzLmN0eFNlbmtvdVNwYW5BLmxpbmVXaWR0aCA9IHRoaXMuc2Vua291X3NwYW5BX2xpbmVfd2lkdGg7XG4gICAgICAgICAgICB0aGlzLmN0eFNlbmtvdVNwYW5BLmxpbmVUbyhsYXlvdXQudDJzY3JlZW4ocFNlbmtvdVNwYW5BWzBdKSwgbGF5b3V0LiQyc2NyZWVuKHBTZW5rb3VTcGFuQVszXSkpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgX2l0ZXJhdG9yNC5lKGVycik7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgX2l0ZXJhdG9yNC5mKCk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmN0eFNlbmtvdVNwYW5BLnN0cm9rZSgpO1xuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5jb2xvclNlbmtvdVNwYW5CKSB7XG4gICAgICAgIHRoaXMuY3R4U2Vua291U3BhbkIuYmVnaW5QYXRoKCk7XG5cbiAgICAgICAgdmFyIF9pdGVyYXRvcjUgPSBJY2hpbW9rdXZ1ZV90eXBlX3NjcmlwdF9sYW5nX2pzX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXIoc3ViZGF0YVNlbmtvdVNwYW4pLFxuICAgICAgICAgICAgX3N0ZXA1O1xuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgZm9yIChfaXRlcmF0b3I1LnMoKTsgIShfc3RlcDUgPSBfaXRlcmF0b3I1Lm4oKSkuZG9uZTspIHtcbiAgICAgICAgICAgIHZhciBwU2Vua291U3BhbkIgPSBfc3RlcDUudmFsdWU7XG4gICAgICAgICAgICB0aGlzLmN0eFNlbmtvdVNwYW5CLnN0cm9rZVN0eWxlID0gdGhpcy5zZW5rb3Vfc3BhbkJfY29sb3I7XG4gICAgICAgICAgICB0aGlzLmN0eFNlbmtvdVNwYW5CLmxpbmVXaWR0aCA9IHRoaXMuc2Vua291X3NwYW5CX2xpbmVfd2lkdGg7XG4gICAgICAgICAgICB0aGlzLmN0eFNlbmtvdVNwYW5CLmxpbmVUbyhsYXlvdXQudDJzY3JlZW4ocFNlbmtvdVNwYW5CWzBdKSwgbGF5b3V0LiQyc2NyZWVuKHBTZW5rb3VTcGFuQls0XSkpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgX2l0ZXJhdG9yNS5lKGVycik7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgX2l0ZXJhdG9yNS5mKCk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmN0eFNlbmtvdVNwYW5CLnN0cm9rZSgpO1xuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5zaG93Q2hpbmtvdSkge1xuICAgICAgICB0aGlzLmN0eENoaW5rb3UuYmVnaW5QYXRoKCk7XG5cbiAgICAgICAgdmFyIF9pdGVyYXRvcjYgPSBJY2hpbW9rdXZ1ZV90eXBlX3NjcmlwdF9sYW5nX2pzX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXIoc3ViZGF0YUNoaW5rb3UpLFxuICAgICAgICAgICAgX3N0ZXA2O1xuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgZm9yIChfaXRlcmF0b3I2LnMoKTsgIShfc3RlcDYgPSBfaXRlcmF0b3I2Lm4oKSkuZG9uZTspIHtcbiAgICAgICAgICAgIHZhciBwQ2hpa291ID0gX3N0ZXA2LnZhbHVlO1xuICAgICAgICAgICAgdGhpcy5jdHhDaGlua291LnN0cm9rZVN0eWxlID0gdGhpcy5jaGlua291X2NvbG9yO1xuICAgICAgICAgICAgdGhpcy5jdHhDaGlua291LmxpbmVXaWR0aCA9IHRoaXMuY2hpbmtvdV9saW5lX3dpZHRoO1xuICAgICAgICAgICAgdGhpcy5jdHhDaGlua291LmxpbmVUbyhsYXlvdXQudDJzY3JlZW4ocENoaWtvdVswXSksIGxheW91dC4kMnNjcmVlbihwQ2hpa291WzVdKSk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICBfaXRlcmF0b3I2LmUoZXJyKTtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICBfaXRlcmF0b3I2LmYoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuY3R4Q2hpbmtvdS5zdHJva2UoKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIG1hcF9zZW5rb3Vfc3Bhbl92YWx1ZXM6IGZ1bmN0aW9uIG1hcF9zZW5rb3Vfc3Bhbl92YWx1ZXMocCkge1xuICAgICAgdmFyIGxheW91dCA9IHRoaXMuJHByb3BzLmxheW91dDtcbiAgICAgIHJldHVybiBwICYmIHtcbiAgICAgICAgeDogbGF5b3V0LnQyc2NyZWVuKHBbMF0pLFxuICAgICAgICBzZW5rb3VTcGFuQTogbGF5b3V0LiQyc2NyZWVuKHBbM10pLFxuICAgICAgICBzZW5rb3VTcGFuQjogbGF5b3V0LiQyc2NyZWVuKHBbNF0pXG4gICAgICB9O1xuICAgIH0sXG4gICAgdXNlX2ZvcjogZnVuY3Rpb24gdXNlX2ZvcigpIHtcbiAgICAgIHJldHVybiBbXCJJY2hpbW9rdVwiXTtcbiAgICB9LFxuICAgIGRhdGFfY29sb3JzOiBmdW5jdGlvbiBkYXRhX2NvbG9ycygpIHtcbiAgICAgIHZhciBjb2xvcnMgPSBbXTtcbiAgICAgIGNvbG9ycy5wdXNoKHRoaXMudGVua2FuX2NvbG9yKTtcbiAgICAgIGNvbG9ycy5wdXNoKHRoaXMua2lqdW5fY29sb3IpO1xuICAgICAgY29sb3JzLnB1c2godGhpcy5zZW5rb3Vfc3BhbkFfY29sb3IpO1xuICAgICAgY29sb3JzLnB1c2godGhpcy5zZW5rb3Vfc3BhbkJfY29sb3IpO1xuICAgICAgY29sb3JzLnB1c2godGhpcy5jaGlua291X2NvbG9yKTtcbiAgICAgIHJldHVybiBjb2xvcnM7XG4gICAgfVxuICB9XG59KTtcbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9vdmVybGF5cy9JY2hpbW9rdS9JY2hpbW9rdS52dWU/dnVlJnR5cGU9c2NyaXB0Jmxhbmc9anMmXG4gLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyBjb25zdCBJY2hpbW9rdV9JY2hpbW9rdXZ1ZV90eXBlX3NjcmlwdF9sYW5nX2pzXyA9IChJY2hpbW9rdXZ1ZV90eXBlX3NjcmlwdF9sYW5nX2pzXyk7IFxuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL292ZXJsYXlzL0ljaGltb2t1L0ljaGltb2t1LnZ1ZVxudmFyIEljaGltb2t1X3JlbmRlciwgSWNoaW1va3Vfc3RhdGljUmVuZGVyRm5zXG47XG5cblxuXG4vKiBub3JtYWxpemUgY29tcG9uZW50ICovXG47XG52YXIgSWNoaW1va3VfY29tcG9uZW50ID0gbm9ybWFsaXplQ29tcG9uZW50KFxuICBJY2hpbW9rdV9JY2hpbW9rdXZ1ZV90eXBlX3NjcmlwdF9sYW5nX2pzXyxcbiAgSWNoaW1va3VfcmVuZGVyLFxuICBJY2hpbW9rdV9zdGF0aWNSZW5kZXJGbnMsXG4gIGZhbHNlLFxuICBudWxsLFxuICBudWxsLFxuICBudWxsXG4gIFxuKVxuXG4vKiBob3QgcmVsb2FkICovXG5pZiAoZmFsc2UpIHsgdmFyIEljaGltb2t1X2FwaTsgfVxuSWNoaW1va3VfY29tcG9uZW50Lm9wdGlvbnMuX19maWxlID0gXCJzcmMvb3ZlcmxheXMvSWNoaW1va3UvSWNoaW1va3UudnVlXCJcbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gY29uc3QgSWNoaW1va3UgPSAoSWNoaW1va3VfY29tcG9uZW50LmV4cG9ydHMpO1xuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vbm9kZV9tb2R1bGVzL2JhYmVsLWxvYWRlci9saWIvaW5kZXguanMhLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvaW5kZXguanM/P3Z1ZS1sb2FkZXItb3B0aW9ucyEuL3NyYy9vdmVybGF5cy9LQy9LQy52dWU/dnVlJnR5cGU9c2NyaXB0Jmxhbmc9anMmXG5cbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gY29uc3QgS0N2dWVfdHlwZV9zY3JpcHRfbGFuZ19qc18gPSAoe1xuICBuYW1lOiAnS0MnLFxuICBtaXhpbnM6IFtleHRlcm5hbF90cmFkaW5nX3Z1ZV9qc18uT3ZlcmxheV0sXG4gIG1ldGhvZHM6IHtcbiAgICBtZXRhX2luZm86IGZ1bmN0aW9uIG1ldGFfaW5mbygpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGF1dGhvcjogJ1N0ZFNxdWFkJyxcbiAgICAgICAgdmVyc2lvbjogJzEuMC4wJyxcbiAgICAgICAgZGVzYzogJ0tlbHRuZXIgQ2hhbm5lbHMnLFxuICAgICAgICBwcmVzZXQ6IHtcbiAgICAgICAgICBuYW1lOiAnS0MgJGxlbmd0aCAkbXVsdCcsXG4gICAgICAgICAgc2lkZTogJ29uY2hhcnQnLFxuICAgICAgICAgIHNldHRpbmdzOiB7XG4gICAgICAgICAgICBsaW5lV2lkdGg6IDAuNzUsXG4gICAgICAgICAgICBjb2xvcjogJyM0YzhkZmZhYicsXG4gICAgICAgICAgICBzaG93TWlkOiB0cnVlLFxuICAgICAgICAgICAgYmFja0NvbG9yOiAnIzRjOGRmZjBhJ1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9LFxuICAgIHVzZV9mb3I6IGZ1bmN0aW9uIHVzZV9mb3IoKSB7XG4gICAgICByZXR1cm4gWydLQyddO1xuICAgIH0sXG4gICAgY2FsYzogZnVuY3Rpb24gY2FsYygpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHByb3BzOiB7XG4gICAgICAgICAgbGVuZ3RoOiB7XG4gICAgICAgICAgICBkZWY6IDIwLFxuICAgICAgICAgICAgdGV4dDogJ0xlbmd0aCdcbiAgICAgICAgICB9LFxuICAgICAgICAgIG11bHQ6IHtcbiAgICAgICAgICAgIGRlZjogMSxcbiAgICAgICAgICAgIHRleHQ6ICdNdWx0aXBsaWVyJ1xuICAgICAgICAgIH0sXG4gICAgICAgICAgdXNlX3RyOiB7XG4gICAgICAgICAgICBkZWY6IHRydWUsXG4gICAgICAgICAgICB0ZXh0OiAnVXNlIFRydWUgUmFuZ2UnXG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBjb25mOiB7XG4gICAgICAgICAgcmVuZGVyZXI6ICdDaGFubmVsJ1xuICAgICAgICB9LFxuICAgICAgICB1cGRhdGU6IFwiXFxuICAgICAgICAgICAgICAgICAgICBsZXQgW20sIGgsIGxdID0ga2MoY2xvc2UsIGxlbmd0aCwgbXVsdCwgdXNlX3RyKVxcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFtoWzBdLCBtWzBdLCBsWzBdXVxcbiAgICAgICAgICAgICAgICBcIlxuICAgICAgfTtcbiAgICB9XG4gIH1cbn0pO1xuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL292ZXJsYXlzL0tDL0tDLnZ1ZT92dWUmdHlwZT1zY3JpcHQmbGFuZz1qcyZcbiAvKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIGNvbnN0IEtDX0tDdnVlX3R5cGVfc2NyaXB0X2xhbmdfanNfID0gKEtDdnVlX3R5cGVfc2NyaXB0X2xhbmdfanNfKTsgXG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvb3ZlcmxheXMvS0MvS0MudnVlXG52YXIgS0NfcmVuZGVyLCBLQ19zdGF0aWNSZW5kZXJGbnNcbjtcblxuXG5cbi8qIG5vcm1hbGl6ZSBjb21wb25lbnQgKi9cbjtcbnZhciBLQ19jb21wb25lbnQgPSBub3JtYWxpemVDb21wb25lbnQoXG4gIEtDX0tDdnVlX3R5cGVfc2NyaXB0X2xhbmdfanNfLFxuICBLQ19yZW5kZXIsXG4gIEtDX3N0YXRpY1JlbmRlckZucyxcbiAgZmFsc2UsXG4gIG51bGwsXG4gIG51bGwsXG4gIG51bGxcbiAgXG4pXG5cbi8qIGhvdCByZWxvYWQgKi9cbmlmIChmYWxzZSkgeyB2YXIgS0NfYXBpOyB9XG5LQ19jb21wb25lbnQub3B0aW9ucy5fX2ZpbGUgPSBcInNyYy9vdmVybGF5cy9LQy9LQy52dWVcIlxuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyBjb25zdCBLQyA9IChLQ19jb21wb25lbnQuZXhwb3J0cyk7XG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9ub2RlX21vZHVsZXMvYmFiZWwtbG9hZGVyL2xpYi9pbmRleC5qcyEuL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9pbmRleC5qcz8/dnVlLWxvYWRlci1vcHRpb25zIS4vc3JjL292ZXJsYXlzL0tDVy9LQ1cudnVlP3Z1ZSZ0eXBlPXNjcmlwdCZsYW5nPWpzJlxuXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIGNvbnN0IEtDV3Z1ZV90eXBlX3NjcmlwdF9sYW5nX2pzXyA9ICh7XG4gIG5hbWU6ICdLQ1cnLFxuICBtaXhpbnM6IFtleHRlcm5hbF90cmFkaW5nX3Z1ZV9qc18uT3ZlcmxheV0sXG4gIG1ldGhvZHM6IHtcbiAgICBtZXRhX2luZm86IGZ1bmN0aW9uIG1ldGFfaW5mbygpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGF1dGhvcjogJ1N0ZFNxdWFkJyxcbiAgICAgICAgdmVyc2lvbjogJzEuMC4wJyxcbiAgICAgICAgZGVzYzogJ0tlbHRuZXIgQ2hhbm5lbHMgV2lkdGgnLFxuICAgICAgICBwcmVzZXQ6IHtcbiAgICAgICAgICBuYW1lOiAnS0NXICRsZW5ndGggJG11bHQnLFxuICAgICAgICAgIHNpZGU6ICdvZmZjaGFydCcsXG4gICAgICAgICAgc2V0dGluZ3M6IHtcbiAgICAgICAgICAgIGxpbmVXaWR0aDogMC43NSxcbiAgICAgICAgICAgIGNvbG9yOiAnIzRjOGRmZmFiJ1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9LFxuICAgIHVzZV9mb3I6IGZ1bmN0aW9uIHVzZV9mb3IoKSB7XG4gICAgICByZXR1cm4gWydLQ1cnXTtcbiAgICB9LFxuICAgIGNhbGM6IGZ1bmN0aW9uIGNhbGMoKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBwcm9wczoge1xuICAgICAgICAgIGxlbmd0aDoge1xuICAgICAgICAgICAgZGVmOiAyMCxcbiAgICAgICAgICAgIHRleHQ6ICdMZW5ndGgnXG4gICAgICAgICAgfSxcbiAgICAgICAgICBtdWx0OiB7XG4gICAgICAgICAgICBkZWY6IDEsXG4gICAgICAgICAgICB0ZXh0OiAnTXVsdGlwbGllcidcbiAgICAgICAgICB9LFxuICAgICAgICAgIHVzZV90cjoge1xuICAgICAgICAgICAgZGVmOiB0cnVlLFxuICAgICAgICAgICAgdGV4dDogJ1VzZSBUcnVlIFJhbmdlJ1xuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgY29uZjoge1xuICAgICAgICAgIHJlbmRlcmVyOiAnU3BsaW5lJ1xuICAgICAgICB9LFxuICAgICAgICB1cGRhdGU6IFwiXFxuICAgICAgICAgICAgICAgICAgICByZXR1cm4ga2N3KGNsb3NlLCBsZW5ndGgsIG11bHQsIHVzZV90cilbMF1cXG4gICAgICAgICAgICAgICAgXCJcbiAgICAgIH07XG4gICAgfVxuICB9XG59KTtcbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9vdmVybGF5cy9LQ1cvS0NXLnZ1ZT92dWUmdHlwZT1zY3JpcHQmbGFuZz1qcyZcbiAvKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIGNvbnN0IEtDV19LQ1d2dWVfdHlwZV9zY3JpcHRfbGFuZ19qc18gPSAoS0NXdnVlX3R5cGVfc2NyaXB0X2xhbmdfanNfKTsgXG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvb3ZlcmxheXMvS0NXL0tDVy52dWVcbnZhciBLQ1dfcmVuZGVyLCBLQ1dfc3RhdGljUmVuZGVyRm5zXG47XG5cblxuXG4vKiBub3JtYWxpemUgY29tcG9uZW50ICovXG47XG52YXIgS0NXX2NvbXBvbmVudCA9IG5vcm1hbGl6ZUNvbXBvbmVudChcbiAgS0NXX0tDV3Z1ZV90eXBlX3NjcmlwdF9sYW5nX2pzXyxcbiAgS0NXX3JlbmRlcixcbiAgS0NXX3N0YXRpY1JlbmRlckZucyxcbiAgZmFsc2UsXG4gIG51bGwsXG4gIG51bGwsXG4gIG51bGxcbiAgXG4pXG5cbi8qIGhvdCByZWxvYWQgKi9cbmlmIChmYWxzZSkgeyB2YXIgS0NXX2FwaTsgfVxuS0NXX2NvbXBvbmVudC5vcHRpb25zLl9fZmlsZSA9IFwic3JjL292ZXJsYXlzL0tDVy9LQ1cudnVlXCJcbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gY29uc3QgS0NXID0gKEtDV19jb21wb25lbnQuZXhwb3J0cyk7XG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9ub2RlX21vZHVsZXMvYmFiZWwtbG9hZGVyL2xpYi9pbmRleC5qcyEuL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9pbmRleC5qcz8/dnVlLWxvYWRlci1vcHRpb25zIS4vc3JjL292ZXJsYXlzL0xvbmdTaG9ydFRyYWRlcy9Mb25nU2hvcnRUcmFkZXMudnVlP3Z1ZSZ0eXBlPXNjcmlwdCZsYW5nPWpzJlxuZnVuY3Rpb24gTG9uZ1Nob3J0VHJhZGVzdnVlX3R5cGVfc2NyaXB0X2xhbmdfanNfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlcihvLCBhbGxvd0FycmF5TGlrZSkgeyB2YXIgaXQgPSB0eXBlb2YgU3ltYm9sICE9PSBcInVuZGVmaW5lZFwiICYmIG9bU3ltYm9sLml0ZXJhdG9yXSB8fCBvW1wiQEBpdGVyYXRvclwiXTsgaWYgKCFpdCkgeyBpZiAoQXJyYXkuaXNBcnJheShvKSB8fCAoaXQgPSBMb25nU2hvcnRUcmFkZXN2dWVfdHlwZV9zY3JpcHRfbGFuZ19qc191bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheShvKSkgfHwgYWxsb3dBcnJheUxpa2UgJiYgbyAmJiB0eXBlb2Ygby5sZW5ndGggPT09IFwibnVtYmVyXCIpIHsgaWYgKGl0KSBvID0gaXQ7IHZhciBpID0gMDsgdmFyIEYgPSBmdW5jdGlvbiBGKCkge307IHJldHVybiB7IHM6IEYsIG46IGZ1bmN0aW9uIG4oKSB7IGlmIChpID49IG8ubGVuZ3RoKSByZXR1cm4geyBkb25lOiB0cnVlIH07IHJldHVybiB7IGRvbmU6IGZhbHNlLCB2YWx1ZTogb1tpKytdIH07IH0sIGU6IGZ1bmN0aW9uIGUoX2UpIHsgdGhyb3cgX2U7IH0sIGY6IEYgfTsgfSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiSW52YWxpZCBhdHRlbXB0IHRvIGl0ZXJhdGUgbm9uLWl0ZXJhYmxlIGluc3RhbmNlLlxcbkluIG9yZGVyIHRvIGJlIGl0ZXJhYmxlLCBub24tYXJyYXkgb2JqZWN0cyBtdXN0IGhhdmUgYSBbU3ltYm9sLml0ZXJhdG9yXSgpIG1ldGhvZC5cIik7IH0gdmFyIG5vcm1hbENvbXBsZXRpb24gPSB0cnVlLCBkaWRFcnIgPSBmYWxzZSwgZXJyOyByZXR1cm4geyBzOiBmdW5jdGlvbiBzKCkgeyBpdCA9IGl0LmNhbGwobyk7IH0sIG46IGZ1bmN0aW9uIG4oKSB7IHZhciBzdGVwID0gaXQubmV4dCgpOyBub3JtYWxDb21wbGV0aW9uID0gc3RlcC5kb25lOyByZXR1cm4gc3RlcDsgfSwgZTogZnVuY3Rpb24gZShfZTIpIHsgZGlkRXJyID0gdHJ1ZTsgZXJyID0gX2UyOyB9LCBmOiBmdW5jdGlvbiBmKCkgeyB0cnkgeyBpZiAoIW5vcm1hbENvbXBsZXRpb24gJiYgaXRbXCJyZXR1cm5cIl0gIT0gbnVsbCkgaXRbXCJyZXR1cm5cIl0oKTsgfSBmaW5hbGx5IHsgaWYgKGRpZEVycikgdGhyb3cgZXJyOyB9IH0gfTsgfVxuXG5mdW5jdGlvbiBMb25nU2hvcnRUcmFkZXN2dWVfdHlwZV9zY3JpcHRfbGFuZ19qc191bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheShvLCBtaW5MZW4pIHsgaWYgKCFvKSByZXR1cm47IGlmICh0eXBlb2YgbyA9PT0gXCJzdHJpbmdcIikgcmV0dXJuIExvbmdTaG9ydFRyYWRlc3Z1ZV90eXBlX3NjcmlwdF9sYW5nX2pzX2FycmF5TGlrZVRvQXJyYXkobywgbWluTGVuKTsgdmFyIG4gPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwobykuc2xpY2UoOCwgLTEpOyBpZiAobiA9PT0gXCJPYmplY3RcIiAmJiBvLmNvbnN0cnVjdG9yKSBuID0gby5jb25zdHJ1Y3Rvci5uYW1lOyBpZiAobiA9PT0gXCJNYXBcIiB8fCBuID09PSBcIlNldFwiKSByZXR1cm4gQXJyYXkuZnJvbShvKTsgaWYgKG4gPT09IFwiQXJndW1lbnRzXCIgfHwgL14oPzpVaXxJKW50KD86OHwxNnwzMikoPzpDbGFtcGVkKT9BcnJheSQvLnRlc3QobikpIHJldHVybiBMb25nU2hvcnRUcmFkZXN2dWVfdHlwZV9zY3JpcHRfbGFuZ19qc19hcnJheUxpa2VUb0FycmF5KG8sIG1pbkxlbik7IH1cblxuZnVuY3Rpb24gTG9uZ1Nob3J0VHJhZGVzdnVlX3R5cGVfc2NyaXB0X2xhbmdfanNfYXJyYXlMaWtlVG9BcnJheShhcnIsIGxlbikgeyBpZiAobGVuID09IG51bGwgfHwgbGVuID4gYXJyLmxlbmd0aCkgbGVuID0gYXJyLmxlbmd0aDsgZm9yICh2YXIgaSA9IDAsIGFycjIgPSBuZXcgQXJyYXkobGVuKTsgaSA8IGxlbjsgaSsrKSB7IGFycjJbaV0gPSBhcnJbaV07IH0gcmV0dXJuIGFycjI7IH1cblxuLy9Mb25nIFNob3J0IE92ZXJsYXkuIEV4cGVjdGVkIEZvcm1hdDogWyA8dGltZXN0YW1wPiwgPFNob3J0OjAgTG9uZzoxIFNob3J0Q292ZXI6IDIgTG9uZ0NvdmVyOjM+LCA8UHJpY2UgQ2hhbmdlPiwgPFBlcmNlbnQgUHJpY2UgQ2hhbmdlPiwgPE9wZW4gUHJpY2U+LCA8SGlnaCBQcmljZT4sIDxMb3cgUHJpY2U+LCA8Q2xvc2UgUHJpY2U+IF1cblxuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyBjb25zdCBMb25nU2hvcnRUcmFkZXN2dWVfdHlwZV9zY3JpcHRfbGFuZ19qc18gPSAoe1xuICBuYW1lOiAnTG9uZ1Nob3J0VHJhZGVzJyxcbiAgbWl4aW5zOiBbZXh0ZXJuYWxfdHJhZGluZ192dWVfanNfLk92ZXJsYXldLFxuICBjb21wdXRlZDoge1xuICAgIHNldHQ6IGZ1bmN0aW9uIHNldHQoKSB7XG4gICAgICByZXR1cm4gdGhpcy4kcHJvcHMuc2V0dGluZ3M7XG4gICAgfSxcbiAgICBkZWZhdWx0X2ZvbnQ6IGZ1bmN0aW9uIGRlZmF1bHRfZm9udCgpIHtcbiAgICAgIHJldHVybiAnMTJweCAnICsgdGhpcy4kcHJvcHMuZm9udC5zcGxpdCgncHgnKS5wb3AoKTtcbiAgICB9LFxuICAgIGN1cnJlbmN5X3N5bWJvbDogZnVuY3Rpb24gY3VycmVuY3lfc3ltYm9sKCkge1xuICAgICAgcmV0dXJuIHRoaXMuc2V0dC5jdXJyZW5jeSB8fCAn4oK5JztcbiAgICB9LFxuICAgIGxvbmdfY29sb3I6IGZ1bmN0aW9uIGxvbmdfY29sb3IoKSB7XG4gICAgICByZXR1cm4gdGhpcy5zZXR0LmxvbmdDb2xvciB8fCAnIzYzZGY4OSc7XG4gICAgfSxcbiAgICBzaG9ydF9jb2xvcjogZnVuY3Rpb24gc2hvcnRfY29sb3IoKSB7XG4gICAgICByZXR1cm4gdGhpcy5zZXR0LnNob3J0Q29sb3IgfHwgJyNmZmQ1ODEnO1xuICAgIH0sXG4gICAgbG9uZ19jb3Zlcl9jb2xvcjogZnVuY3Rpb24gbG9uZ19jb3Zlcl9jb2xvcigpIHtcbiAgICAgIHJldHVybiB0aGlzLnNldHQubG9uZ0NvdmVyQ29sb3IgfHwgJyNmYzdlMmYnO1xuICAgIH0sXG4gICAgc2hvcnRfY292ZXJfY29sb3I6IGZ1bmN0aW9uIHNob3J0X2NvdmVyX2NvbG9yKCkge1xuICAgICAgcmV0dXJuIHRoaXMuc2V0dC5zaG9ydENvdmVyQ29sb3IgfHwgJyNmZjZiZDYnO1xuICAgIH0sXG4gICAgbGFiZWxfY29sb3I6IGZ1bmN0aW9uIGxhYmVsX2NvbG9yKCkge1xuICAgICAgcmV0dXJuICcjNEJFQ0Y5JztcbiAgICB9LFxuICAgIG1hcmtlcl9zaXplOiBmdW5jdGlvbiBtYXJrZXJfc2l6ZSgpIHtcbiAgICAgIHJldHVybiB0aGlzLnNldHQubWFya2VyU2l6ZSB8fCA1O1xuICAgIH0sXG4gICAgc2hvd19sYWJlbDogZnVuY3Rpb24gc2hvd19sYWJlbCgpIHtcbiAgICAgIHJldHVybiB0aGlzLnNldHQuc2hvd0xhYmVsICE9PSBmYWxzZTtcbiAgICB9LFxuICAgIG5ld19mb250OiBmdW5jdGlvbiBuZXdfZm9udCgpIHtcbiAgICAgIHJldHVybiB0aGlzLnNldHQuZm9udCB8fCB0aGlzLmRlZmF1bHRfZm9udDtcbiAgICB9XG4gIH0sXG4gIG1ldGhvZHM6IHtcbiAgICBtZXRhX2luZm86IGZ1bmN0aW9uIG1ldGFfaW5mbygpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGF1dGhvcjogJ1N1ZGVlcCBCYXRyYScsXG4gICAgICAgIHZlcnNpb246ICcxLjAuMSdcbiAgICAgIH07XG4gICAgfSxcbiAgICBkcmF3OiBmdW5jdGlvbiBkcmF3KGN0eCkge1xuICAgICAgdmFyIGxheW91dCA9IHRoaXMuJHByb3BzLmxheW91dDtcbiAgICAgIGN0eC5saW5lV2lkdGggPSAxLjU7XG4gICAgICBjdHguc3Ryb2tlU3R5bGUgPSAnYmxhY2snO1xuXG4gICAgICB2YXIgX2l0ZXJhdG9yID0gTG9uZ1Nob3J0VHJhZGVzdnVlX3R5cGVfc2NyaXB0X2xhbmdfanNfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlcih0aGlzLiRwcm9wcy5kYXRhKSxcbiAgICAgICAgICBfc3RlcDtcblxuICAgICAgdHJ5IHtcbiAgICAgICAgZm9yIChfaXRlcmF0b3IucygpOyAhKF9zdGVwID0gX2l0ZXJhdG9yLm4oKSkuZG9uZTspIHtcbiAgICAgICAgICB2YXIgcCA9IF9zdGVwLnZhbHVlO1xuICAgICAgICAgIHZhciB0cmFkZVRpbWUgPSBwWzBdO1xuICAgICAgICAgIHZhciBsb25nU2hvcnRFbnRyeUV4aXQgPSBwWzFdO1xuICAgICAgICAgIHZhciBwcmljZUNoYW5nZSA9IHBbMl07XG4gICAgICAgICAgdmFyIHBlcmNlbnRQcmljZUNoYW5nZSA9IHBbM107XG4gICAgICAgICAgdmFyIG9wZW5QcmljZSA9IHBbNF07XG4gICAgICAgICAgdmFyIGhpZ2hQcmljZSA9IHBbNV07XG4gICAgICAgICAgdmFyIGxvd1ByaWNlID0gcFs2XTtcbiAgICAgICAgICB2YXIgY2xvc2VQcmljZSA9IHBbN107XG4gICAgICAgICAgdmFyIHggPSBsYXlvdXQudDJzY3JlZW4odHJhZGVUaW1lKTtcbiAgICAgICAgICB2YXIgbG93UHJpY2VZID0gbGF5b3V0LiQyc2NyZWVuKGxvd1ByaWNlKTtcbiAgICAgICAgICB2YXIgaGlnaFByaWNlWSA9IGxheW91dC4kMnNjcmVlbihoaWdoUHJpY2UpO1xuXG4gICAgICAgICAgc3dpdGNoIChsb25nU2hvcnRFbnRyeUV4aXQpIHtcbiAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgdGhpcy5maWxsZWRBcnJvd0Rvd25GaWxsZWRCb3R0b20oY3R4LCB4LCBoaWdoUHJpY2VZIC0gMjUsIDUsIDUsIDMsIDIwLCB0aGlzLnNob3J0X2NvbG9yKTtcbiAgICAgICAgICAgICAgdGhpcy5kcmF3X2xhYmVsKGN0eCwgeCArIDMwLCBoaWdoUHJpY2VZIC0gMzUsIHRoaXMuY3VycmVuY3lfc3ltYm9sICsgY2xvc2VQcmljZSk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgIHRoaXMuZmlsbGVkQXJyb3dVcEZpbGxlZEJvdHRvbShjdHgsIHgsIGxvd1ByaWNlWSArIDIwLCA1LCA1LCAzLCAyMCwgdGhpcy5sb25nX2NvbG9yKTtcbiAgICAgICAgICAgICAgdGhpcy5kcmF3X2xhYmVsKGN0eCwgeCArIDMwLCBsb3dQcmljZVkgKyA0MCwgdGhpcy5jdXJyZW5jeV9zeW1ib2wgKyBjbG9zZVByaWNlKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgdGhpcy51cFRyaWFuZ2xlKGN0eCwgeCwgbG93UHJpY2VZICsgMjUsIDUsIDcsIHRoaXMuc2hvcnRfY292ZXJfY29sb3IpO1xuXG4gICAgICAgICAgICAgIGlmICh0aGlzLnNob3dfbGFiZWwgJiYgcHJpY2VDaGFuZ2UpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmRyYXdfbGFiZWwoY3R4LCB4LCBsb3dQcmljZVkgKyA1MCwgcHJpY2VDaGFuZ2UgKyBcIiAoXCIgKyBwZXJjZW50UHJpY2VDaGFuZ2UgKyBcIilcIik7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgICB0aGlzLmRvd25UcmlhbmdsZShjdHgsIHgsIGhpZ2hQcmljZVkgLSAyNSwgNSwgNywgdGhpcy5sb25nX2NvdmVyX2NvbG9yKTtcblxuICAgICAgICAgICAgICBpZiAodGhpcy5zaG93X2xhYmVsICYmIHByaWNlQ2hhbmdlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5kcmF3X2xhYmVsKGN0eCwgeCwgaGlnaFByaWNlWSAtIDQ1LCBwcmljZUNoYW5nZSArIFwiIChcIiArIHBlcmNlbnRQcmljZUNoYW5nZSArIFwiKVwiKTtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICBjdHguZmlsbFN0eWxlID0gJ2JsYWNrJztcbiAgICAgICAgICB9IC8vIHRoaXMuc2ltcGxlQXJyb3dVcChjdHgsIHgsIHogLSAyNSwgJyM4NGU1YjEnKVxuICAgICAgICAgIC8vIHRoaXMuc2ltcGxlQXJyb3dEb3duKGN0eCwgeCwgeiAtIDI1LCAnIzg0ZTViMScpXG4gICAgICAgICAgLy8gdGhpcy5maWxsZWRBcnJvd1VwKGN0eCwgeCwgeiAtIDI1LCA1LCA1LCAyMCwgJyM4NGU1YjEnKVxuICAgICAgICAgIC8vIHRoaXMuZmlsbGVkRG93bkFycm93KGN0eCwgeCwgeiAtIDI1LCA1LCA1LCAyMCwgJyM4NGU1YjEnKVxuICAgICAgICAgIC8vIHRoaXMuZmlsbGVkQXJyb3dVcEZpbGxlZEJvdHRvbShjdHgsIHgsIHogLSAyNSwgNSwgNSwgMywgMjAsICcjODRlNWIxJylcbiAgICAgICAgICAvLyB0aGlzLmZpbGxlZEFycm93RG93bkZpbGxlZEJvdHRvbShjdHgsIHgsIHogLSAyNSwgNSwgNSwgMywgMjAsICcjODRlNWIxJylcbiAgICAgICAgICAvLyB0aGlzLnVwVHJpYW5nbGUoY3R4LCB4LCB6LTYwLCA1LCA3LCAnIzg0ZTViMScpXG4gICAgICAgICAgLy8gdGhpcy5kb3duVHJpYW5nbGUoY3R4LCB4LCB6IC0gMjUsIDUsIDcsICcjODRlNWIxJylcblxuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgX2l0ZXJhdG9yLmUoZXJyKTtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIF9pdGVyYXRvci5mKCk7XG4gICAgICB9XG4gICAgfSxcbiAgICBkcmF3X2xhYmVsOiBmdW5jdGlvbiBkcmF3X2xhYmVsKGN0eCwgeCwgeSwgbGFiZWxUZXh0KSB7XG4gICAgICBjdHguZmlsbFN0eWxlID0gdGhpcy5sYWJlbF9jb2xvcjtcbiAgICAgIGN0eC5mb250ID0gdGhpcy5uZXdfZm9udDtcbiAgICAgIGN0eC50ZXh0QWxpZ24gPSAnY2VudGVyJztcbiAgICAgIGN0eC5maWxsVGV4dChsYWJlbFRleHQsIHgsIHkpO1xuICAgIH0sXG4gICAgdXNlX2ZvcjogZnVuY3Rpb24gdXNlX2ZvcigpIHtcbiAgICAgIHJldHVybiBbJ0xvbmdTaG9ydFRyYWRlcyddO1xuICAgIH0sXG4gICAgbGVnZW5kOiBmdW5jdGlvbiBsZWdlbmQodmFsdWVzKSB7XG4gICAgICBzd2l0Y2ggKHZhbHVlc1sxXSkge1xuICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgdmFyIHBvcyA9ICdTaG9ydCc7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSAxOlxuICAgICAgICAgIHBvcyA9ICdMb25nJztcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgcG9zID0gJ1Nob3J0IENvdmVyJztcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgcG9zID0gJ0xvbmcgQ292ZXInO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgcG9zID0gJ1Vua25vd24nO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gW3tcbiAgICAgICAgdmFsdWU6IHBvc1xuICAgICAgfSwge1xuICAgICAgICB2YWx1ZTogdmFsdWVzWzJdLnRvRml4ZWQoNCksXG4gICAgICAgIGNvbG9yOiB0aGlzLiRwcm9wcy5jb2xvcnMuY29sb3JUZXh0XG4gICAgICB9XS5jb25jYXQodmFsdWVzWzNdID8gW3tcbiAgICAgICAgdmFsdWU6IHZhbHVlc1szXVxuICAgICAgfV0gOiBbXSk7XG4gICAgfSxcbiAgICBzaW1wbGVBcnJvd1VwOiBmdW5jdGlvbiBzaW1wbGVBcnJvd1VwKGN0eCwgeCwgeSwgY29sb3IpIHtcbiAgICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICAgIGN0eC5maWxsU3R5bGUgPSBjb2xvcjtcbiAgICAgIGN0eC5zdHJva2VTdHlsZSA9IGNvbG9yO1xuICAgICAgY3R4Lm1vdmVUbyh4IC0gNSwgeSArIDUpO1xuICAgICAgY3R4LmxpbmVUbyh4LCB5KTtcbiAgICAgIGN0eC5saW5lVG8oeCArIDUsIHkgKyA1KTtcbiAgICAgIGN0eC5tb3ZlVG8oeCwgeSk7XG4gICAgICBjdHgubGluZVRvKHgsIHkgKyAxNSk7XG4gICAgICBjdHguc3Ryb2tlKCk7XG4gICAgICBjdHguY2xvc2VQYXRoKCk7XG4gICAgfSxcbiAgICBzaW1wbGVBcnJvd0Rvd246IGZ1bmN0aW9uIHNpbXBsZUFycm93RG93bihjdHgsIHgsIHksIGNvbG9yKSB7XG4gICAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgICBjdHguZmlsbFN0eWxlID0gY29sb3I7XG4gICAgICBjdHguc3Ryb2tlU3R5bGUgPSBjb2xvcjtcbiAgICAgIGN0eC5tb3ZlVG8oeCAtIDUsIHkgLSA1KTtcbiAgICAgIGN0eC5saW5lVG8oeCwgeSk7XG4gICAgICBjdHgubGluZVRvKHggKyA1LCB5IC0gNSk7XG4gICAgICBjdHgubW92ZVRvKHgsIHkpO1xuICAgICAgY3R4LmxpbmVUbyh4LCB5IC0gMTUpO1xuICAgICAgY3R4LnN0cm9rZSgpO1xuICAgICAgY3R4LmNsb3NlUGF0aCgpO1xuICAgIH0sXG4gICAgZmlsbGVkQXJyb3dVcDogZnVuY3Rpb24gZmlsbGVkQXJyb3dVcChjdHgsIHgsIHksIHdpZHRoLCBoZWlnaHQsIGRlcHRoLCBjb2xvcikge1xuICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgY3R4LmZpbGxTdHlsZSA9IGNvbG9yO1xuICAgICAgY3R4LnN0cm9rZVN0eWxlID0gY29sb3I7XG4gICAgICBjdHgubW92ZVRvKHggLSB3aWR0aCwgeSArIGhlaWdodCk7XG4gICAgICBjdHgubGluZVRvKHgsIHkpO1xuICAgICAgY3R4LmxpbmVUbyh4ICsgd2lkdGgsIHkgKyBoZWlnaHQpO1xuICAgICAgY3R4Lm1vdmVUbyh4LCB5KTtcbiAgICAgIGN0eC5saW5lVG8oeCwgeSArIGRlcHRoKTtcbiAgICAgIGN0eC5maWxsKCk7XG4gICAgICBjdHguc3Ryb2tlKCk7XG4gICAgICBjdHguY2xvc2VQYXRoKCk7XG4gICAgfSxcbiAgICBmaWxsZWREb3duQXJyb3c6IGZ1bmN0aW9uIGZpbGxlZERvd25BcnJvdyhjdHgsIHgsIHksIHdpZHRoLCBoZWlnaHQsIGRlcHRoLCBjb2xvcikge1xuICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgY3R4LmZpbGxTdHlsZSA9IGNvbG9yO1xuICAgICAgY3R4LnN0cm9rZVN0eWxlID0gY29sb3I7XG4gICAgICBjdHgubW92ZVRvKHggLSB3aWR0aCwgeSAtIGhlaWdodCk7XG4gICAgICBjdHgubGluZVRvKHgsIHkpO1xuICAgICAgY3R4LmxpbmVUbyh4ICsgd2lkdGgsIHkgLSBoZWlnaHQpO1xuICAgICAgY3R4Lm1vdmVUbyh4LCB5KTtcbiAgICAgIGN0eC5saW5lVG8oeCwgeSAtIGRlcHRoKTtcbiAgICAgIGN0eC5maWxsKCk7XG4gICAgICBjdHguc3Ryb2tlKCk7XG4gICAgICBjdHguY2xvc2VQYXRoKCk7XG4gICAgfSxcbiAgICBmaWxsZWRBcnJvd1VwRmlsbGVkQm90dG9tOiBmdW5jdGlvbiBmaWxsZWRBcnJvd1VwRmlsbGVkQm90dG9tKGN0eCwgeCwgeSwgd2lkdGgsIGhlaWdodCwgYm90dG9tLCBkZXB0aCwgY29sb3IpIHtcbiAgICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICAgIGN0eC5maWxsU3R5bGUgPSBjb2xvcjtcbiAgICAgIGN0eC5zdHJva2VTdHlsZSA9IGNvbG9yO1xuICAgICAgY3R4Lm1vdmVUbyh4IC0gd2lkdGgsIHkgKyBoZWlnaHQpO1xuICAgICAgY3R4LmxpbmVUbyh4LCB5KTtcbiAgICAgIGN0eC5saW5lVG8oeCArIHdpZHRoLCB5ICsgaGVpZ2h0KTtcbiAgICAgIGN0eC5tb3ZlVG8oeCwgeSk7XG4gICAgICBjdHgucmVjdCh4IC0gYm90dG9tIC8gMiwgeSArIGhlaWdodCwgYm90dG9tLCBkZXB0aCk7XG4gICAgICBjdHguZmlsbCgpO1xuICAgICAgY3R4LnN0cm9rZSgpO1xuICAgICAgY3R4LmNsb3NlUGF0aCgpO1xuICAgIH0sXG4gICAgZmlsbGVkQXJyb3dEb3duRmlsbGVkQm90dG9tOiBmdW5jdGlvbiBmaWxsZWRBcnJvd0Rvd25GaWxsZWRCb3R0b20oY3R4LCB4LCB5LCB3aWR0aCwgaGVpZ2h0LCBib3R0b20sIGRlcHRoLCBjb2xvcikge1xuICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgY3R4LmZpbGxTdHlsZSA9IGNvbG9yO1xuICAgICAgY3R4LnN0cm9rZVN0eWxlID0gY29sb3I7XG4gICAgICBjdHgubW92ZVRvKHggLSB3aWR0aCwgeSAtIGhlaWdodCk7XG4gICAgICBjdHgubGluZVRvKHgsIHkpO1xuICAgICAgY3R4LmxpbmVUbyh4ICsgd2lkdGgsIHkgLSBoZWlnaHQpO1xuICAgICAgY3R4Lm1vdmVUbyh4LCB5KTtcbiAgICAgIGN0eC5yZWN0KHggLSBib3R0b20gLyAyLCB5IC0gaGVpZ2h0IC0gZGVwdGgsIGJvdHRvbSwgZGVwdGgpO1xuICAgICAgY3R4LmZpbGwoKTtcbiAgICAgIGN0eC5zdHJva2UoKTtcbiAgICAgIGN0eC5jbG9zZVBhdGgoKTtcbiAgICB9LFxuICAgIHVwVHJpYW5nbGU6IGZ1bmN0aW9uIHVwVHJpYW5nbGUoY3R4LCB4LCB5LCB3aWR0aCwgaGVpZ2h0LCBjb2xvcikge1xuICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgY3R4LmZpbGxTdHlsZSA9IGNvbG9yO1xuICAgICAgY3R4LnN0cm9rZVN0eWxlID0gY29sb3I7XG4gICAgICBjdHgubW92ZVRvKHggLSB3aWR0aCwgeSArIGhlaWdodCk7XG4gICAgICBjdHgubGluZVRvKHgsIHkpO1xuICAgICAgY3R4LmxpbmVUbyh4ICsgd2lkdGgsIHkgKyBoZWlnaHQpO1xuICAgICAgY3R4LmZpbGwoKTtcbiAgICAgIGN0eC5zdHJva2UoKTtcbiAgICAgIGN0eC5jbG9zZVBhdGgoKTtcbiAgICB9LFxuICAgIGRvd25UcmlhbmdsZTogZnVuY3Rpb24gZG93blRyaWFuZ2xlKGN0eCwgeCwgeSwgd2lkdGgsIGhlaWdodCwgY29sb3IpIHtcbiAgICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICAgIGN0eC5maWxsU3R5bGUgPSBjb2xvcjtcbiAgICAgIGN0eC5zdHJva2VTdHlsZSA9IGNvbG9yO1xuICAgICAgY3R4Lm1vdmVUbyh4IC0gd2lkdGgsIHkgLSBoZWlnaHQpO1xuICAgICAgY3R4LmxpbmVUbyh4LCB5KTtcbiAgICAgIGN0eC5saW5lVG8oeCArIHdpZHRoLCB5IC0gaGVpZ2h0KTtcbiAgICAgIGN0eC5maWxsKCk7XG4gICAgICBjdHguc3Ryb2tlKCk7XG4gICAgICBjdHguY2xvc2VQYXRoKCk7XG4gICAgfVxuICB9XG59KTtcbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9vdmVybGF5cy9Mb25nU2hvcnRUcmFkZXMvTG9uZ1Nob3J0VHJhZGVzLnZ1ZT92dWUmdHlwZT1zY3JpcHQmbGFuZz1qcyZcbiAvKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIGNvbnN0IExvbmdTaG9ydFRyYWRlc19Mb25nU2hvcnRUcmFkZXN2dWVfdHlwZV9zY3JpcHRfbGFuZ19qc18gPSAoTG9uZ1Nob3J0VHJhZGVzdnVlX3R5cGVfc2NyaXB0X2xhbmdfanNfKTsgXG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvb3ZlcmxheXMvTG9uZ1Nob3J0VHJhZGVzL0xvbmdTaG9ydFRyYWRlcy52dWVcbnZhciBMb25nU2hvcnRUcmFkZXNfcmVuZGVyLCBMb25nU2hvcnRUcmFkZXNfc3RhdGljUmVuZGVyRm5zXG47XG5cblxuXG4vKiBub3JtYWxpemUgY29tcG9uZW50ICovXG47XG52YXIgTG9uZ1Nob3J0VHJhZGVzX2NvbXBvbmVudCA9IG5vcm1hbGl6ZUNvbXBvbmVudChcbiAgTG9uZ1Nob3J0VHJhZGVzX0xvbmdTaG9ydFRyYWRlc3Z1ZV90eXBlX3NjcmlwdF9sYW5nX2pzXyxcbiAgTG9uZ1Nob3J0VHJhZGVzX3JlbmRlcixcbiAgTG9uZ1Nob3J0VHJhZGVzX3N0YXRpY1JlbmRlckZucyxcbiAgZmFsc2UsXG4gIG51bGwsXG4gIG51bGwsXG4gIG51bGxcbiAgXG4pXG5cbi8qIGhvdCByZWxvYWQgKi9cbmlmIChmYWxzZSkgeyB2YXIgTG9uZ1Nob3J0VHJhZGVzX2FwaTsgfVxuTG9uZ1Nob3J0VHJhZGVzX2NvbXBvbmVudC5vcHRpb25zLl9fZmlsZSA9IFwic3JjL292ZXJsYXlzL0xvbmdTaG9ydFRyYWRlcy9Mb25nU2hvcnRUcmFkZXMudnVlXCJcbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gY29uc3QgTG9uZ1Nob3J0VHJhZGVzID0gKExvbmdTaG9ydFRyYWRlc19jb21wb25lbnQuZXhwb3J0cyk7XG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9ub2RlX21vZHVsZXMvYmFiZWwtbG9hZGVyL2xpYi9pbmRleC5qcyEuL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9pbmRleC5qcz8/dnVlLWxvYWRlci1vcHRpb25zIS4vc3JjL292ZXJsYXlzL01BQ0QvTUFDRC52dWU/dnVlJnR5cGU9c2NyaXB0Jmxhbmc9anMmXG5mdW5jdGlvbiBNQUNEdnVlX3R5cGVfc2NyaXB0X2xhbmdfanNfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlcihvLCBhbGxvd0FycmF5TGlrZSkgeyB2YXIgaXQgPSB0eXBlb2YgU3ltYm9sICE9PSBcInVuZGVmaW5lZFwiICYmIG9bU3ltYm9sLml0ZXJhdG9yXSB8fCBvW1wiQEBpdGVyYXRvclwiXTsgaWYgKCFpdCkgeyBpZiAoQXJyYXkuaXNBcnJheShvKSB8fCAoaXQgPSBNQUNEdnVlX3R5cGVfc2NyaXB0X2xhbmdfanNfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkobykpIHx8IGFsbG93QXJyYXlMaWtlICYmIG8gJiYgdHlwZW9mIG8ubGVuZ3RoID09PSBcIm51bWJlclwiKSB7IGlmIChpdCkgbyA9IGl0OyB2YXIgaSA9IDA7IHZhciBGID0gZnVuY3Rpb24gRigpIHt9OyByZXR1cm4geyBzOiBGLCBuOiBmdW5jdGlvbiBuKCkgeyBpZiAoaSA+PSBvLmxlbmd0aCkgcmV0dXJuIHsgZG9uZTogdHJ1ZSB9OyByZXR1cm4geyBkb25lOiBmYWxzZSwgdmFsdWU6IG9baSsrXSB9OyB9LCBlOiBmdW5jdGlvbiBlKF9lKSB7IHRocm93IF9lOyB9LCBmOiBGIH07IH0gdGhyb3cgbmV3IFR5cGVFcnJvcihcIkludmFsaWQgYXR0ZW1wdCB0byBpdGVyYXRlIG5vbi1pdGVyYWJsZSBpbnN0YW5jZS5cXG5JbiBvcmRlciB0byBiZSBpdGVyYWJsZSwgbm9uLWFycmF5IG9iamVjdHMgbXVzdCBoYXZlIGEgW1N5bWJvbC5pdGVyYXRvcl0oKSBtZXRob2QuXCIpOyB9IHZhciBub3JtYWxDb21wbGV0aW9uID0gdHJ1ZSwgZGlkRXJyID0gZmFsc2UsIGVycjsgcmV0dXJuIHsgczogZnVuY3Rpb24gcygpIHsgaXQgPSBpdC5jYWxsKG8pOyB9LCBuOiBmdW5jdGlvbiBuKCkgeyB2YXIgc3RlcCA9IGl0Lm5leHQoKTsgbm9ybWFsQ29tcGxldGlvbiA9IHN0ZXAuZG9uZTsgcmV0dXJuIHN0ZXA7IH0sIGU6IGZ1bmN0aW9uIGUoX2UyKSB7IGRpZEVyciA9IHRydWU7IGVyciA9IF9lMjsgfSwgZjogZnVuY3Rpb24gZigpIHsgdHJ5IHsgaWYgKCFub3JtYWxDb21wbGV0aW9uICYmIGl0W1wicmV0dXJuXCJdICE9IG51bGwpIGl0W1wicmV0dXJuXCJdKCk7IH0gZmluYWxseSB7IGlmIChkaWRFcnIpIHRocm93IGVycjsgfSB9IH07IH1cblxuZnVuY3Rpb24gTUFDRHZ1ZV90eXBlX3NjcmlwdF9sYW5nX2pzX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5KG8sIG1pbkxlbikgeyBpZiAoIW8pIHJldHVybjsgaWYgKHR5cGVvZiBvID09PSBcInN0cmluZ1wiKSByZXR1cm4gTUFDRHZ1ZV90eXBlX3NjcmlwdF9sYW5nX2pzX2FycmF5TGlrZVRvQXJyYXkobywgbWluTGVuKTsgdmFyIG4gPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwobykuc2xpY2UoOCwgLTEpOyBpZiAobiA9PT0gXCJPYmplY3RcIiAmJiBvLmNvbnN0cnVjdG9yKSBuID0gby5jb25zdHJ1Y3Rvci5uYW1lOyBpZiAobiA9PT0gXCJNYXBcIiB8fCBuID09PSBcIlNldFwiKSByZXR1cm4gQXJyYXkuZnJvbShvKTsgaWYgKG4gPT09IFwiQXJndW1lbnRzXCIgfHwgL14oPzpVaXxJKW50KD86OHwxNnwzMikoPzpDbGFtcGVkKT9BcnJheSQvLnRlc3QobikpIHJldHVybiBNQUNEdnVlX3R5cGVfc2NyaXB0X2xhbmdfanNfYXJyYXlMaWtlVG9BcnJheShvLCBtaW5MZW4pOyB9XG5cbmZ1bmN0aW9uIE1BQ0R2dWVfdHlwZV9zY3JpcHRfbGFuZ19qc19hcnJheUxpa2VUb0FycmF5KGFyciwgbGVuKSB7IGlmIChsZW4gPT0gbnVsbCB8fCBsZW4gPiBhcnIubGVuZ3RoKSBsZW4gPSBhcnIubGVuZ3RoOyBmb3IgKHZhciBpID0gMCwgYXJyMiA9IG5ldyBBcnJheShsZW4pOyBpIDwgbGVuOyBpKyspIHsgYXJyMltpXSA9IGFycltpXTsgfSByZXR1cm4gYXJyMjsgfVxuXG4vLyBUT0RPOiBwYXNzIGNvbG9ycyBmcm9tIHNldHRpbmdzIHRvIHRoZSBzY3JpcHRcbi8vIFRPRE86IGhpc3QgbGluZXMgPT4gcmVjYW5nbGVzIChsaWtlIGluIHZvbGJhci5qcylcblxuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyBjb25zdCBNQUNEdnVlX3R5cGVfc2NyaXB0X2xhbmdfanNfID0gKHtcbiAgbmFtZTogJ01BQ0QnLFxuICBtaXhpbnM6IFtleHRlcm5hbF90cmFkaW5nX3Z1ZV9qc18uT3ZlcmxheV0sXG4gIG1ldGhvZHM6IHtcbiAgICBtZXRhX2luZm86IGZ1bmN0aW9uIG1ldGFfaW5mbygpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGF1dGhvcjogJ1N0ZFNxdWFkJyxcbiAgICAgICAgdmVyc2lvbjogJzEuMC4yJyxcbiAgICAgICAgZGVzYzogJ01vdmluZyBBdmVyYWdlIENvbnZlcmdlbmNlL0RpdmVyZ2VuY2UnLFxuICAgICAgICBwcmVzZXQ6IHtcbiAgICAgICAgICBuYW1lOiAnTUFDRCAkZmFzdCAkc2xvdyAkc21vb3RoJyxcbiAgICAgICAgICBzaWRlOiAnb2ZmY2hhcnQnLFxuICAgICAgICAgIHNldHRpbmdzOiB7XG4gICAgICAgICAgICBoaXN0V2lkdGg6IDQsXG4gICAgICAgICAgICBtYWNkV2lkdGg6IDEsXG4gICAgICAgICAgICBzaWduYWxXaWR0aDogMSxcbiAgICAgICAgICAgIGRlZkNvbG9yOiBcIiM0MmIyOGFcIixcbiAgICAgICAgICAgIG1hY2RDb2xvcjogXCIjMzc4MmYyXCIsXG4gICAgICAgICAgICBzaWduYWxDb2xvcjogXCIjZjQ4NzA5XCIsXG4gICAgICAgICAgICBoaXN0Q29sb3JzOiBbXCIjMzVhNzc2XCIsIFwiIzc5ZTBiM1wiLCBcIiNlNTQxNTBcIiwgXCIjZWE5NjllXCJdXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9O1xuICAgIH0sXG4gICAgZHJhdzogZnVuY3Rpb24gZHJhdyhjdHgpIHtcbiAgICAgIHZhciBsYXlvdXQgPSB0aGlzLiRwcm9wcy5sYXlvdXQ7IC8vIEhJU1RPR1JBTVxuXG4gICAgICB2YXIgYmFzZSA9IGxheW91dC4kMnNjcmVlbigwKSArIDAuNTtcbiAgICAgIHZhciBvZmYgPSB0aGlzLmhpc3Rfd2lkdGggJSAyID8gMCA6IDAuNTtcbiAgICAgIGN0eC5saW5lV2lkdGggPSB0aGlzLmhpc3Rfd2lkdGg7XG4gICAgICBjdHguc3Ryb2tlU3R5bGUgPSB0aGlzLmNvbG9yO1xuICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuXG4gICAgICB2YXIgX2l0ZXJhdG9yID0gTUFDRHZ1ZV90eXBlX3NjcmlwdF9sYW5nX2pzX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXIodGhpcy4kcHJvcHMuZGF0YSksXG4gICAgICAgICAgX3N0ZXA7XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIGZvciAoX2l0ZXJhdG9yLnMoKTsgIShfc3RlcCA9IF9pdGVyYXRvci5uKCkpLmRvbmU7KSB7XG4gICAgICAgICAgdmFyIHAgPSBfc3RlcC52YWx1ZTtcbiAgICAgICAgICB2YXIgeCA9IGxheW91dC50MnNjcmVlbihwWzBdKSAtIG9mZjtcbiAgICAgICAgICB2YXIgeSA9IGxheW91dC4kMnNjcmVlbihwWzFdKSAtIDAuNTtcbiAgICAgICAgICBjdHguc3Ryb2tlU3R5bGUgPSB0aGlzLnNldHQuaGlzdENvbG9yc1twWzRdXTtcbiAgICAgICAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgICAgICAgY3R4Lm1vdmVUbyh4LCBiYXNlKTtcbiAgICAgICAgICBjdHgubGluZVRvKHgsIHkpO1xuICAgICAgICAgIGN0eC5zdHJva2UoKTtcbiAgICAgICAgfSAvLyBNQUNEIExJTkVcblxuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIF9pdGVyYXRvci5lKGVycik7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICBfaXRlcmF0b3IuZigpO1xuICAgICAgfVxuXG4gICAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgICBjdHgubGluZVdpZHRoID0gdGhpcy5tYWNkX3dpZHRoO1xuICAgICAgY3R4LnN0cm9rZVN0eWxlID0gdGhpcy5tYWNkX2NvbG9yO1xuXG4gICAgICB2YXIgX2l0ZXJhdG9yMiA9IE1BQ0R2dWVfdHlwZV9zY3JpcHRfbGFuZ19qc19jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyKHRoaXMuJHByb3BzLmRhdGEpLFxuICAgICAgICAgIF9zdGVwMjtcblxuICAgICAgdHJ5IHtcbiAgICAgICAgZm9yIChfaXRlcmF0b3IyLnMoKTsgIShfc3RlcDIgPSBfaXRlcmF0b3IyLm4oKSkuZG9uZTspIHtcbiAgICAgICAgICB2YXIgcCA9IF9zdGVwMi52YWx1ZTtcblxuICAgICAgICAgIHZhciBfeCA9IGxheW91dC50MnNjcmVlbihwWzBdKTtcblxuICAgICAgICAgIHZhciBfeSA9IGxheW91dC4kMnNjcmVlbihwWzJdKTtcblxuICAgICAgICAgIGN0eC5saW5lVG8oX3gsIF95KTtcbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIF9pdGVyYXRvcjIuZShlcnIpO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgX2l0ZXJhdG9yMi5mKCk7XG4gICAgICB9XG5cbiAgICAgIGN0eC5zdHJva2UoKTsgLy8gU0lHTkFMIExJTkVcblxuICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgY3R4LmxpbmVXaWR0aCA9IHRoaXMuc2lnbmFsX3dpZHRoO1xuICAgICAgY3R4LnN0cm9rZVN0eWxlID0gdGhpcy5zaWduYWxfY29sb3I7XG5cbiAgICAgIHZhciBfaXRlcmF0b3IzID0gTUFDRHZ1ZV90eXBlX3NjcmlwdF9sYW5nX2pzX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXIodGhpcy4kcHJvcHMuZGF0YSksXG4gICAgICAgICAgX3N0ZXAzO1xuXG4gICAgICB0cnkge1xuICAgICAgICBmb3IgKF9pdGVyYXRvcjMucygpOyAhKF9zdGVwMyA9IF9pdGVyYXRvcjMubigpKS5kb25lOykge1xuICAgICAgICAgIHZhciBwID0gX3N0ZXAzLnZhbHVlO1xuXG4gICAgICAgICAgdmFyIF94MiA9IGxheW91dC50MnNjcmVlbihwWzBdKTtcblxuICAgICAgICAgIHZhciBfeTIgPSBsYXlvdXQuJDJzY3JlZW4ocFszXSk7XG5cbiAgICAgICAgICBjdHgubGluZVRvKF94MiwgX3kyKTtcbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIF9pdGVyYXRvcjMuZShlcnIpO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgX2l0ZXJhdG9yMy5mKCk7XG4gICAgICB9XG5cbiAgICAgIGN0eC5zdHJva2UoKTtcbiAgICB9LFxuICAgIHVzZV9mb3I6IGZ1bmN0aW9uIHVzZV9mb3IoKSB7XG4gICAgICByZXR1cm4gWydNQUNEJ107XG4gICAgfSxcbiAgICBsZWdlbmQ6IGZ1bmN0aW9uIGxlZ2VuZCh2YWx1ZXMpIHtcbiAgICAgIHZhciB4cyA9IHZhbHVlcy5zbGljZSgxLCA0KS5tYXAoZnVuY3Rpb24gKHgpIHtcbiAgICAgICAgcmV0dXJuIHgudG9GaXhlZChNYXRoLmFicyh4KSA+IDAuMDAxID8gNCA6IDgpO1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gW3tcbiAgICAgICAgdmFsdWU6IHhzWzBdLFxuICAgICAgICBjb2xvcjogdGhpcy5oaXN0X2NvbG9yc1t2YWx1ZXNbNF1dXG4gICAgICB9LCB7XG4gICAgICAgIHZhbHVlOiB4c1sxXSxcbiAgICAgICAgY29sb3I6IHRoaXMubWFjZF9jb2xvclxuICAgICAgfSwge1xuICAgICAgICB2YWx1ZTogeHNbMl0sXG4gICAgICAgIGNvbG9yOiB0aGlzLnNpZ25hbF9jb2xvclxuICAgICAgfV07XG4gICAgfSxcbiAgICBjYWxjOiBmdW5jdGlvbiBjYWxjKCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgcHJvcHM6IHtcbiAgICAgICAgICBmYXN0OiB7XG4gICAgICAgICAgICBkZWY6IDEyLFxuICAgICAgICAgICAgdGV4dDogJ0Zhc3QgTGVuZ3RoJ1xuICAgICAgICAgIH0sXG4gICAgICAgICAgc2xvdzoge1xuICAgICAgICAgICAgZGVmOiAyNixcbiAgICAgICAgICAgIHRleHQ6ICdTbG93IExlbmd0aCdcbiAgICAgICAgICB9LFxuICAgICAgICAgIHNtb290aDoge1xuICAgICAgICAgICAgZGVmOiA5LFxuICAgICAgICAgICAgdGV4dDogJ1NpZ25hbCBFTUEnXG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB1cGRhdGU6IFwiXFxuICAgICAgICAgICAgICAgICAgICBsZXQgW21hY2QsIHNpZ25hbCwgaGlzdF0gPVxcbiAgICAgICAgICAgICAgICAgICAgICAgIG1hY2QoY2xvc2UsIGZhc3QsIHNsb3csIHNtb290aClcXG5cXG4gICAgICAgICAgICAgICAgICAgIGlmIChoaXN0WzBdID49IDApIHtcXG4gICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGNvbG9yID0gMFxcbiAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaGlzdFswXSA8IGhpc3RbMV0pIGNvbG9yID0gMVxcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgICAgICAgICAgICAgICBjb2xvciA9IDJcXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaGlzdFswXSA+IGhpc3RbMV0pIGNvbG9yID0gM1xcbiAgICAgICAgICAgICAgICAgICAgfVxcblxcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFtoaXN0WzBdLCBtYWNkWzBdLCBzaWduYWxbMF0sIGNvbG9yXVxcbiAgICAgICAgICAgICAgICBcIlxuICAgICAgfTtcbiAgICB9XG4gIH0sXG4gIC8vIERlZmluZSBpbnRlcm5hbCBzZXR0aW5nICYgY29uc3RhbnRzIGhlcmVcbiAgY29tcHV0ZWQ6IHtcbiAgICBzZXR0OiBmdW5jdGlvbiBzZXR0KCkge1xuICAgICAgcmV0dXJuIHRoaXMuJHByb3BzLnNldHRpbmdzO1xuICAgIH0sXG4gICAgaGlzdF93aWR0aDogZnVuY3Rpb24gaGlzdF93aWR0aCgpIHtcbiAgICAgIHJldHVybiB0aGlzLnNldHQuaGlzdFdpZHRoIHx8IDQ7XG4gICAgfSxcbiAgICBtYWNkX3dpZHRoOiBmdW5jdGlvbiBtYWNkX3dpZHRoKCkge1xuICAgICAgcmV0dXJuIHRoaXMuc2V0dC5tYWNkV2lkdGggfHwgMTtcbiAgICB9LFxuICAgIHNpZ25hbF93aWR0aDogZnVuY3Rpb24gc2lnbmFsX3dpZHRoKCkge1xuICAgICAgcmV0dXJuIHRoaXMuc2V0dC5zaWduYWxXaWR0aCB8fCAxO1xuICAgIH0sXG4gICAgY29sb3I6IGZ1bmN0aW9uIGNvbG9yKCkge1xuICAgICAgcmV0dXJuIHRoaXMuc2V0dC5kZWZDb2xvciB8fCBcIiM0MmIyOGFcIjtcbiAgICB9LFxuICAgIG1hY2RfY29sb3I6IGZ1bmN0aW9uIG1hY2RfY29sb3IoKSB7XG4gICAgICByZXR1cm4gdGhpcy5zZXR0Lm1hY2RDb2xvciB8fCBcIiMzNzgyZjJcIjtcbiAgICB9LFxuICAgIHNpZ25hbF9jb2xvcjogZnVuY3Rpb24gc2lnbmFsX2NvbG9yKCkge1xuICAgICAgcmV0dXJuIHRoaXMuc2V0dC5zaWduYWxDb2xvciB8fCBcIiNmNDg3MDlcIjtcbiAgICB9LFxuICAgIGhpc3RfY29sb3JzOiBmdW5jdGlvbiBoaXN0X2NvbG9ycygpIHtcbiAgICAgIHJldHVybiB0aGlzLnNldHQuaGlzdENvbG9ycztcbiAgICB9XG4gIH1cbn0pO1xuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL292ZXJsYXlzL01BQ0QvTUFDRC52dWU/dnVlJnR5cGU9c2NyaXB0Jmxhbmc9anMmXG4gLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyBjb25zdCBNQUNEX01BQ0R2dWVfdHlwZV9zY3JpcHRfbGFuZ19qc18gPSAoTUFDRHZ1ZV90eXBlX3NjcmlwdF9sYW5nX2pzXyk7IFxuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL292ZXJsYXlzL01BQ0QvTUFDRC52dWVcbnZhciBNQUNEX3JlbmRlciwgTUFDRF9zdGF0aWNSZW5kZXJGbnNcbjtcblxuXG5cbi8qIG5vcm1hbGl6ZSBjb21wb25lbnQgKi9cbjtcbnZhciBNQUNEX2NvbXBvbmVudCA9IG5vcm1hbGl6ZUNvbXBvbmVudChcbiAgTUFDRF9NQUNEdnVlX3R5cGVfc2NyaXB0X2xhbmdfanNfLFxuICBNQUNEX3JlbmRlcixcbiAgTUFDRF9zdGF0aWNSZW5kZXJGbnMsXG4gIGZhbHNlLFxuICBudWxsLFxuICBudWxsLFxuICBudWxsXG4gIFxuKVxuXG4vKiBob3QgcmVsb2FkICovXG5pZiAoZmFsc2UpIHsgdmFyIE1BQ0RfYXBpOyB9XG5NQUNEX2NvbXBvbmVudC5vcHRpb25zLl9fZmlsZSA9IFwic3JjL292ZXJsYXlzL01BQ0QvTUFDRC52dWVcIlxuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyBjb25zdCBNQUNEID0gKE1BQ0RfY29tcG9uZW50LmV4cG9ydHMpO1xuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vbm9kZV9tb2R1bGVzL2JhYmVsLWxvYWRlci9saWIvaW5kZXguanMhLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvaW5kZXguanM/P3Z1ZS1sb2FkZXItb3B0aW9ucyEuL3NyYy9vdmVybGF5cy9NRkkvTUZJLnZ1ZT92dWUmdHlwZT1zY3JpcHQmbGFuZz1qcyZcblxuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyBjb25zdCBNRkl2dWVfdHlwZV9zY3JpcHRfbGFuZ19qc18gPSAoe1xuICBuYW1lOiAnTUZJJyxcbiAgbWl4aW5zOiBbZXh0ZXJuYWxfdHJhZGluZ192dWVfanNfLk92ZXJsYXldLFxuICBtZXRob2RzOiB7XG4gICAgbWV0YV9pbmZvOiBmdW5jdGlvbiBtZXRhX2luZm8oKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBhdXRob3I6ICdTdGRTcXVhZCcsXG4gICAgICAgIHZlcnNpb246ICcxLjAuMCcsXG4gICAgICAgIGRlc2M6ICdNb25leSBGbG93IEluZGV4JyxcbiAgICAgICAgcHJlc2V0OiB7XG4gICAgICAgICAgbmFtZTogJ01GSSAkbGVuZ3RoJyxcbiAgICAgICAgICBzaWRlOiAnb2ZmY2hhcnQnLFxuICAgICAgICAgIHNldHRpbmdzOiB7XG4gICAgICAgICAgICBsaW5lV2lkdGg6IDAuNzUsXG4gICAgICAgICAgICBjb2xvcjogJyM4NWM0MjdlZScsXG4gICAgICAgICAgICBiYW5kQ29sb3I6ICcjYWFhYWFhJyxcbiAgICAgICAgICAgIGJhY2tDb2xvcjogJyM4NWM0MjcxMScsXG4gICAgICAgICAgICB1cHBlcjogODAsXG4gICAgICAgICAgICBsb3dlcjogMjBcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfSxcbiAgICB1c2VfZm9yOiBmdW5jdGlvbiB1c2VfZm9yKCkge1xuICAgICAgcmV0dXJuIFsnTUZJJ107XG4gICAgfSxcbiAgICBjYWxjOiBmdW5jdGlvbiBjYWxjKCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgcHJvcHM6IHtcbiAgICAgICAgICBsZW5ndGg6IHtcbiAgICAgICAgICAgIGRlZjogMTQsXG4gICAgICAgICAgICB0ZXh0OiAnTGVuZ3RoJ1xuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgY29uZjoge1xuICAgICAgICAgIHJlbmRlcmVyOiAnUmFuZ2UnXG4gICAgICAgIH0sXG4gICAgICAgIHVwZGF0ZTogXCJcXG4gICAgICAgICAgICAgICAgICAgIGxldCBobGMzID0gdHMoKGhpZ2hbMF0gKyBsb3dbMF0gKyBjbG9zZVswXSkgLyAzKVxcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG1maShobGMzLCBsZW5ndGgpWzBdXFxuICAgICAgICAgICAgICAgIFwiXG4gICAgICB9O1xuICAgIH1cbiAgfVxufSk7XG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvb3ZlcmxheXMvTUZJL01GSS52dWU/dnVlJnR5cGU9c2NyaXB0Jmxhbmc9anMmXG4gLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyBjb25zdCBNRklfTUZJdnVlX3R5cGVfc2NyaXB0X2xhbmdfanNfID0gKE1GSXZ1ZV90eXBlX3NjcmlwdF9sYW5nX2pzXyk7IFxuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL292ZXJsYXlzL01GSS9NRkkudnVlXG52YXIgTUZJX3JlbmRlciwgTUZJX3N0YXRpY1JlbmRlckZuc1xuO1xuXG5cblxuLyogbm9ybWFsaXplIGNvbXBvbmVudCAqL1xuO1xudmFyIE1GSV9jb21wb25lbnQgPSBub3JtYWxpemVDb21wb25lbnQoXG4gIE1GSV9NRkl2dWVfdHlwZV9zY3JpcHRfbGFuZ19qc18sXG4gIE1GSV9yZW5kZXIsXG4gIE1GSV9zdGF0aWNSZW5kZXJGbnMsXG4gIGZhbHNlLFxuICBudWxsLFxuICBudWxsLFxuICBudWxsXG4gIFxuKVxuXG4vKiBob3QgcmVsb2FkICovXG5pZiAoZmFsc2UpIHsgdmFyIE1GSV9hcGk7IH1cbk1GSV9jb21wb25lbnQub3B0aW9ucy5fX2ZpbGUgPSBcInNyYy9vdmVybGF5cy9NRkkvTUZJLnZ1ZVwiXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIGNvbnN0IE1GSSA9IChNRklfY29tcG9uZW50LmV4cG9ydHMpO1xuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vbm9kZV9tb2R1bGVzL2JhYmVsLWxvYWRlci9saWIvaW5kZXguanMhLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvaW5kZXguanM/P3Z1ZS1sb2FkZXItb3B0aW9ucyEuL3NyYy9vdmVybGF5cy9NT00vTU9NLnZ1ZT92dWUmdHlwZT1zY3JpcHQmbGFuZz1qcyZcblxuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyBjb25zdCBNT012dWVfdHlwZV9zY3JpcHRfbGFuZ19qc18gPSAoe1xuICBuYW1lOiAnTU9NJyxcbiAgbWl4aW5zOiBbZXh0ZXJuYWxfdHJhZGluZ192dWVfanNfLk92ZXJsYXldLFxuICBtZXRob2RzOiB7XG4gICAgbWV0YV9pbmZvOiBmdW5jdGlvbiBtZXRhX2luZm8oKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBhdXRob3I6ICdTdGRTcXVhZCcsXG4gICAgICAgIHZlcnNpb246ICcxLjAuMCcsXG4gICAgICAgIGRlc2M6ICdNb21lbnR1bScsXG4gICAgICAgIHByZXNldDoge1xuICAgICAgICAgIG5hbWU6ICdNT00gJGxlbmd0aCcsXG4gICAgICAgICAgc2lkZTogJ29mZmNoYXJ0JyxcbiAgICAgICAgICBzZXR0aW5nczoge1xuICAgICAgICAgICAgbGluZVdpZHRoOiAwLjc1LFxuICAgICAgICAgICAgY29sb3I6ICcjYmNjNDI3ZWUnXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9O1xuICAgIH0sXG4gICAgdXNlX2ZvcjogZnVuY3Rpb24gdXNlX2ZvcigpIHtcbiAgICAgIHJldHVybiBbJ01PTSddO1xuICAgIH0sXG4gICAgY2FsYzogZnVuY3Rpb24gY2FsYygpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHByb3BzOiB7XG4gICAgICAgICAgbGVuZ3RoOiB7XG4gICAgICAgICAgICBkZWY6IDExLFxuICAgICAgICAgICAgdGV4dDogJ0xlbmd0aCdcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIGNvbmY6IHtcbiAgICAgICAgICByZW5kZXJlcjogJ1NwbGluZSdcbiAgICAgICAgfSxcbiAgICAgICAgdXBkYXRlOiBcIlxcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG1vbShjbG9zZSwgbGVuZ3RoKVswXVxcbiAgICAgICAgICAgICAgICBcIlxuICAgICAgfTtcbiAgICB9XG4gIH1cbn0pO1xuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL292ZXJsYXlzL01PTS9NT00udnVlP3Z1ZSZ0eXBlPXNjcmlwdCZsYW5nPWpzJlxuIC8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gY29uc3QgTU9NX01PTXZ1ZV90eXBlX3NjcmlwdF9sYW5nX2pzXyA9IChNT012dWVfdHlwZV9zY3JpcHRfbGFuZ19qc18pOyBcbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9vdmVybGF5cy9NT00vTU9NLnZ1ZVxudmFyIE1PTV9yZW5kZXIsIE1PTV9zdGF0aWNSZW5kZXJGbnNcbjtcblxuXG5cbi8qIG5vcm1hbGl6ZSBjb21wb25lbnQgKi9cbjtcbnZhciBNT01fY29tcG9uZW50ID0gbm9ybWFsaXplQ29tcG9uZW50KFxuICBNT01fTU9NdnVlX3R5cGVfc2NyaXB0X2xhbmdfanNfLFxuICBNT01fcmVuZGVyLFxuICBNT01fc3RhdGljUmVuZGVyRm5zLFxuICBmYWxzZSxcbiAgbnVsbCxcbiAgbnVsbCxcbiAgbnVsbFxuICBcbilcblxuLyogaG90IHJlbG9hZCAqL1xuaWYgKGZhbHNlKSB7IHZhciBNT01fYXBpOyB9XG5NT01fY29tcG9uZW50Lm9wdGlvbnMuX19maWxlID0gXCJzcmMvb3ZlcmxheXMvTU9NL01PTS52dWVcIlxuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyBjb25zdCBNT00gPSAoTU9NX2NvbXBvbmVudC5leHBvcnRzKTtcbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL25vZGVfbW9kdWxlcy9iYWJlbC1sb2FkZXIvbGliL2luZGV4LmpzIS4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL2luZGV4LmpzPz92dWUtbG9hZGVyLW9wdGlvbnMhLi9zcmMvb3ZlcmxheXMvTWFya2Vycy9NYXJrZXJzLnZ1ZT92dWUmdHlwZT1zY3JpcHQmbGFuZz1qcyZcbmZ1bmN0aW9uIE1hcmtlcnN2dWVfdHlwZV9zY3JpcHRfbGFuZ19qc19jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyKG8sIGFsbG93QXJyYXlMaWtlKSB7IHZhciBpdCA9IHR5cGVvZiBTeW1ib2wgIT09IFwidW5kZWZpbmVkXCIgJiYgb1tTeW1ib2wuaXRlcmF0b3JdIHx8IG9bXCJAQGl0ZXJhdG9yXCJdOyBpZiAoIWl0KSB7IGlmIChBcnJheS5pc0FycmF5KG8pIHx8IChpdCA9IE1hcmtlcnN2dWVfdHlwZV9zY3JpcHRfbGFuZ19qc191bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheShvKSkgfHwgYWxsb3dBcnJheUxpa2UgJiYgbyAmJiB0eXBlb2Ygby5sZW5ndGggPT09IFwibnVtYmVyXCIpIHsgaWYgKGl0KSBvID0gaXQ7IHZhciBpID0gMDsgdmFyIEYgPSBmdW5jdGlvbiBGKCkge307IHJldHVybiB7IHM6IEYsIG46IGZ1bmN0aW9uIG4oKSB7IGlmIChpID49IG8ubGVuZ3RoKSByZXR1cm4geyBkb25lOiB0cnVlIH07IHJldHVybiB7IGRvbmU6IGZhbHNlLCB2YWx1ZTogb1tpKytdIH07IH0sIGU6IGZ1bmN0aW9uIGUoX2UpIHsgdGhyb3cgX2U7IH0sIGY6IEYgfTsgfSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiSW52YWxpZCBhdHRlbXB0IHRvIGl0ZXJhdGUgbm9uLWl0ZXJhYmxlIGluc3RhbmNlLlxcbkluIG9yZGVyIHRvIGJlIGl0ZXJhYmxlLCBub24tYXJyYXkgb2JqZWN0cyBtdXN0IGhhdmUgYSBbU3ltYm9sLml0ZXJhdG9yXSgpIG1ldGhvZC5cIik7IH0gdmFyIG5vcm1hbENvbXBsZXRpb24gPSB0cnVlLCBkaWRFcnIgPSBmYWxzZSwgZXJyOyByZXR1cm4geyBzOiBmdW5jdGlvbiBzKCkgeyBpdCA9IGl0LmNhbGwobyk7IH0sIG46IGZ1bmN0aW9uIG4oKSB7IHZhciBzdGVwID0gaXQubmV4dCgpOyBub3JtYWxDb21wbGV0aW9uID0gc3RlcC5kb25lOyByZXR1cm4gc3RlcDsgfSwgZTogZnVuY3Rpb24gZShfZTIpIHsgZGlkRXJyID0gdHJ1ZTsgZXJyID0gX2UyOyB9LCBmOiBmdW5jdGlvbiBmKCkgeyB0cnkgeyBpZiAoIW5vcm1hbENvbXBsZXRpb24gJiYgaXRbXCJyZXR1cm5cIl0gIT0gbnVsbCkgaXRbXCJyZXR1cm5cIl0oKTsgfSBmaW5hbGx5IHsgaWYgKGRpZEVycikgdGhyb3cgZXJyOyB9IH0gfTsgfVxuXG5mdW5jdGlvbiBNYXJrZXJzdnVlX3R5cGVfc2NyaXB0X2xhbmdfanNfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkobywgbWluTGVuKSB7IGlmICghbykgcmV0dXJuOyBpZiAodHlwZW9mIG8gPT09IFwic3RyaW5nXCIpIHJldHVybiBNYXJrZXJzdnVlX3R5cGVfc2NyaXB0X2xhbmdfanNfYXJyYXlMaWtlVG9BcnJheShvLCBtaW5MZW4pOyB2YXIgbiA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvKS5zbGljZSg4LCAtMSk7IGlmIChuID09PSBcIk9iamVjdFwiICYmIG8uY29uc3RydWN0b3IpIG4gPSBvLmNvbnN0cnVjdG9yLm5hbWU7IGlmIChuID09PSBcIk1hcFwiIHx8IG4gPT09IFwiU2V0XCIpIHJldHVybiBBcnJheS5mcm9tKG8pOyBpZiAobiA9PT0gXCJBcmd1bWVudHNcIiB8fCAvXig/OlVpfEkpbnQoPzo4fDE2fDMyKSg/OkNsYW1wZWQpP0FycmF5JC8udGVzdChuKSkgcmV0dXJuIE1hcmtlcnN2dWVfdHlwZV9zY3JpcHRfbGFuZ19qc19hcnJheUxpa2VUb0FycmF5KG8sIG1pbkxlbik7IH1cblxuZnVuY3Rpb24gTWFya2Vyc3Z1ZV90eXBlX3NjcmlwdF9sYW5nX2pzX2FycmF5TGlrZVRvQXJyYXkoYXJyLCBsZW4pIHsgaWYgKGxlbiA9PSBudWxsIHx8IGxlbiA+IGFyci5sZW5ndGgpIGxlbiA9IGFyci5sZW5ndGg7IGZvciAodmFyIGkgPSAwLCBhcnIyID0gbmV3IEFycmF5KGxlbik7IGkgPCBsZW47IGkrKykgeyBhcnIyW2ldID0gYXJyW2ldOyB9IHJldHVybiBhcnIyOyB9XG5cblxuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyBjb25zdCBNYXJrZXJzdnVlX3R5cGVfc2NyaXB0X2xhbmdfanNfID0gKHtcbiAgbmFtZTogJ01hcmtlcnMnLFxuICBtaXhpbnM6IFtleHRlcm5hbF90cmFkaW5nX3Z1ZV9qc18uT3ZlcmxheV0sXG4gIG1ldGhvZHM6IHtcbiAgICBtZXRhX2luZm86IGZ1bmN0aW9uIG1ldGFfaW5mbygpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGF1dGhvcjogJ0M0NTEnLFxuICAgICAgICB2ZXJzaW9uOiAnMS4wLjEnLFxuICAgICAgICBkZXNjOiAnSW50ZXJhY3RpdmUgbWFya2VycydcbiAgICAgIH07XG4gICAgfSxcbiAgICBpbml0OiBmdW5jdGlvbiBpbml0KCkge1xuICAgICAgdGhpcy5tb3VzZS5vbignbW91c2Vtb3ZlJywgZnVuY3Rpb24gKCkge30pO1xuICAgIH0sXG4gICAgZHJhdzogZnVuY3Rpb24gZHJhdyhjdHgpIHtcbiAgICAgIGN0eC5saW5lV2lkdGggPSAxLjU7XG4gICAgICBjdHguc3Ryb2tlU3R5bGUgPSAnYmxhY2snO1xuICAgICAgZG9jdW1lbnQuYm9keS5zdHlsZS5jdXJzb3IgPSAnYXV0byc7XG4gICAgICB0aGlzLnNlbGVjdGVkID0gbnVsbDtcblxuICAgICAgdmFyIF9pdGVyYXRvciA9IE1hcmtlcnN2dWVfdHlwZV9zY3JpcHRfbGFuZ19qc19jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyKHRoaXMuJHByb3BzLmRhdGEpLFxuICAgICAgICAgIF9zdGVwO1xuXG4gICAgICB0cnkge1xuICAgICAgICBmb3IgKF9pdGVyYXRvci5zKCk7ICEoX3N0ZXAgPSBfaXRlcmF0b3IubigpKS5kb25lOykge1xuICAgICAgICAgIHZhciBwID0gX3N0ZXAudmFsdWU7XG4gICAgICAgICAgdGhpcy5kcmF3X3BvaW50KGN0eCwgcCk7XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICBfaXRlcmF0b3IuZShlcnIpO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgX2l0ZXJhdG9yLmYoKTtcbiAgICAgIH1cblxuICAgICAgdmFyIGYgPSB0aGlzLmRhdGEuZmluZChmdW5jdGlvbiAoeCkge1xuICAgICAgICByZXR1cm4geFsxXS5zZWw7XG4gICAgICB9KTtcblxuICAgICAgaWYgKGYpIHtcbiAgICAgICAgdGhpcy5kcmF3X3BvaW50KGN0eCwgZik7XG4gICAgICB9XG4gICAgfSxcbiAgICBkcmF3X3BvaW50OiBmdW5jdGlvbiBkcmF3X3BvaW50KGN0eCwgcCkge1xuICAgICAgdmFyIGxheW91dCA9IHRoaXMuJHByb3BzLmxheW91dDtcbiAgICAgIHZhciBzdHJva2UgPSB0aGlzLmNvbG9ycy5iYWNrO1xuICAgICAgdmFyIGZpbGwgPSBwWzFdLmNvbG9yIHx8ICdvcmFuZ2UnO1xuICAgICAgdmFyIHJhZGl1cyA9IDI7XG4gICAgICB2YXIgaGVpZ2h0ID0gcFsxXS5zZWwgPyAyMCA6IDE0O1xuICAgICAgdmFyIHdpZHRoID0gcFsxXS5zZWwgPyAxNyA6IDEzO1xuICAgICAgdmFyIHggPSBsYXlvdXQudDJzY3JlZW4ocFswXSkgLSB3aWR0aCAqIDAuNTtcbiAgICAgIHZhciB5ID0gbGF5b3V0LiQyc2NyZWVuKHBbMV0uJCkgLSAocFsxXS5zZWwgPyAyNyA6IDIwKTsgLy8gQ29sbGlzaW9uc1xuXG4gICAgICBpZiAodGhpcy5tb3VzZS54ID4geCAmJiB0aGlzLm1vdXNlLnggPCB4ICsgd2lkdGggJiYgdGhpcy5tb3VzZS55ID4geSAmJiB0aGlzLm1vdXNlLnkgPCB5ICsgaGVpZ2h0KSB7XG4gICAgICAgIGRvY3VtZW50LmJvZHkuc3R5bGUuY3Vyc29yID0gJ3BvaW50ZXInO1xuICAgICAgICB0aGlzLnNlbGVjdGVkID0gcDtcbiAgICAgICAgc3Ryb2tlID0gdGhpcy5jb2xvcnMudGV4dDtcbiAgICAgIH1cblxuICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgY3R4Lm1vdmVUbyh4ICsgcmFkaXVzLCB5KTtcbiAgICAgIGN0eC5saW5lVG8oeCArIHdpZHRoIC0gcmFkaXVzLCB5KTtcbiAgICAgIGN0eC5xdWFkcmF0aWNDdXJ2ZVRvKHggKyB3aWR0aCwgeSwgeCArIHdpZHRoLCB5ICsgcmFkaXVzKTtcbiAgICAgIGN0eC5saW5lVG8oeCArIHdpZHRoLCB5ICsgaGVpZ2h0IC0gcmFkaXVzKTtcbiAgICAgIGN0eC5xdWFkcmF0aWNDdXJ2ZVRvKHggKyB3aWR0aCwgeSArIGhlaWdodCwgeCArIHdpZHRoIC0gcmFkaXVzLCB5ICsgaGVpZ2h0KTtcbiAgICAgIGN0eC5saW5lVG8oeCArIHdpZHRoICogMSAvIDIsIHkgKyBoZWlnaHQgKyBoZWlnaHQgLyA1KTtcbiAgICAgIGN0eC5saW5lVG8oeCArIHJhZGl1cywgeSArIGhlaWdodCk7XG4gICAgICBjdHgucXVhZHJhdGljQ3VydmVUbyh4LCB5ICsgaGVpZ2h0LCB4LCB5ICsgaGVpZ2h0IC0gcmFkaXVzKTtcbiAgICAgIGN0eC5saW5lVG8oeCwgeSArIHJhZGl1cyk7XG4gICAgICBjdHgucXVhZHJhdGljQ3VydmVUbyh4LCB5LCB4ICsgcmFkaXVzLCB5KTtcbiAgICAgIGN0eC5saW5lV2lkdGggPSAxO1xuICAgICAgY3R4LmNsb3NlUGF0aCgpO1xuICAgICAgY3R4LmZpbGxTdHlsZSA9IGZpbGw7XG4gICAgICBjdHguc3Ryb2tlU3R5bGUgPSBzdHJva2U7XG4gICAgICBjdHguZmlsbCgpO1xuICAgICAgY3R4LnN0cm9rZSgpO1xuICAgICAgY3R4LnRleHRBbGlnbiA9ICdjZW50ZXInO1xuICAgICAgY3R4LmZpbGxTdHlsZSA9IHBbMV0udGV4dENvbG9yIHx8IHRoaXMuY29sb3JzLmJhY2s7XG4gICAgICBjdHguZm9udCA9IFwiXCIuY29uY2F0KHBbMV0uc2VsID8gMTUgOiAxMSwgXCJweCBBcmlhbFwiKTtcbiAgICAgIGN0eC5maWxsVGV4dChwWzFdLnRleHQgfHwgJyQnLCB4ICsgd2lkdGggLyAyLCB5ICsgaGVpZ2h0ICogMC44KTtcbiAgICB9LFxuICAgIHVzZV9mb3I6IGZ1bmN0aW9uIHVzZV9mb3IoKSB7XG4gICAgICByZXR1cm4gWydNYXJrZXJzJ107XG4gICAgfSxcbiAgICBsZWdlbmQ6IGZ1bmN0aW9uIGxlZ2VuZCgpIHtcbiAgICAgIHJldHVybiBbXTtcbiAgICB9LFxuICAgIG1vdXNlZG93bjogZnVuY3Rpb24gbW91c2Vkb3duKCkge1xuICAgICAgdGhpcy4kZW1pdCgnbWFya2VyLXNlbGVjdGVkJywgdGhpcy5zZWxlY3RlZCk7XG4gICAgfVxuICB9LFxuICAvLyBEZWZpbmUgaW50ZXJuYWwgc2V0dGluZyAmIGNvbnN0YW50cyBoZXJlXG4gIGNvbXB1dGVkOiB7XG4gICAgc2V0dDogZnVuY3Rpb24gc2V0dCgpIHtcbiAgICAgIHJldHVybiB0aGlzLiRwcm9wcy5zZXR0aW5ncztcbiAgICB9LFxuICAgIGRlZmF1bHRfZm9udDogZnVuY3Rpb24gZGVmYXVsdF9mb250KCkge1xuICAgICAgcmV0dXJuICcxMnB4ICcgKyB0aGlzLiRwcm9wcy5mb250LnNwbGl0KCdweCcpLnBvcCgpO1xuICAgIH0sXG4gICAgbmV3X2ZvbnQ6IGZ1bmN0aW9uIG5ld19mb250KCkge1xuICAgICAgcmV0dXJuIHRoaXMuc2V0dC5mb250IHx8IHRoaXMuZGVmYXVsdF9mb250O1xuICAgIH1cbiAgfSxcbiAgZGF0YTogZnVuY3Rpb24gZGF0YSgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgc2VsZWN0ZWQ6IG51bGxcbiAgICB9O1xuICB9XG59KTtcbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9vdmVybGF5cy9NYXJrZXJzL01hcmtlcnMudnVlP3Z1ZSZ0eXBlPXNjcmlwdCZsYW5nPWpzJlxuIC8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gY29uc3QgTWFya2Vyc19NYXJrZXJzdnVlX3R5cGVfc2NyaXB0X2xhbmdfanNfID0gKE1hcmtlcnN2dWVfdHlwZV9zY3JpcHRfbGFuZ19qc18pOyBcbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9vdmVybGF5cy9NYXJrZXJzL01hcmtlcnMudnVlXG52YXIgTWFya2Vyc19yZW5kZXIsIE1hcmtlcnNfc3RhdGljUmVuZGVyRm5zXG47XG5cblxuXG4vKiBub3JtYWxpemUgY29tcG9uZW50ICovXG47XG52YXIgTWFya2Vyc19jb21wb25lbnQgPSBub3JtYWxpemVDb21wb25lbnQoXG4gIE1hcmtlcnNfTWFya2Vyc3Z1ZV90eXBlX3NjcmlwdF9sYW5nX2pzXyxcbiAgTWFya2Vyc19yZW5kZXIsXG4gIE1hcmtlcnNfc3RhdGljUmVuZGVyRm5zLFxuICBmYWxzZSxcbiAgbnVsbCxcbiAgbnVsbCxcbiAgbnVsbFxuICBcbilcblxuLyogaG90IHJlbG9hZCAqL1xuaWYgKGZhbHNlKSB7IHZhciBNYXJrZXJzX2FwaTsgfVxuTWFya2Vyc19jb21wb25lbnQub3B0aW9ucy5fX2ZpbGUgPSBcInNyYy9vdmVybGF5cy9NYXJrZXJzL01hcmtlcnMudnVlXCJcbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gY29uc3QgTWFya2VycyA9IChNYXJrZXJzX2NvbXBvbmVudC5leHBvcnRzKTtcbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL25vZGVfbW9kdWxlcy9iYWJlbC1sb2FkZXIvbGliL2luZGV4LmpzIS4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL2luZGV4LmpzPz92dWUtbG9hZGVyLW9wdGlvbnMhLi9zcmMvb3ZlcmxheXMvUGxvdENyb3NzL1Bsb3RDcm9zcy52dWU/dnVlJnR5cGU9c2NyaXB0Jmxhbmc9anMmXG5mdW5jdGlvbiBQbG90Q3Jvc3N2dWVfdHlwZV9zY3JpcHRfbGFuZ19qc19jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyKG8sIGFsbG93QXJyYXlMaWtlKSB7IHZhciBpdCA9IHR5cGVvZiBTeW1ib2wgIT09IFwidW5kZWZpbmVkXCIgJiYgb1tTeW1ib2wuaXRlcmF0b3JdIHx8IG9bXCJAQGl0ZXJhdG9yXCJdOyBpZiAoIWl0KSB7IGlmIChBcnJheS5pc0FycmF5KG8pIHx8IChpdCA9IFBsb3RDcm9zc3Z1ZV90eXBlX3NjcmlwdF9sYW5nX2pzX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5KG8pKSB8fCBhbGxvd0FycmF5TGlrZSAmJiBvICYmIHR5cGVvZiBvLmxlbmd0aCA9PT0gXCJudW1iZXJcIikgeyBpZiAoaXQpIG8gPSBpdDsgdmFyIGkgPSAwOyB2YXIgRiA9IGZ1bmN0aW9uIEYoKSB7fTsgcmV0dXJuIHsgczogRiwgbjogZnVuY3Rpb24gbigpIHsgaWYgKGkgPj0gby5sZW5ndGgpIHJldHVybiB7IGRvbmU6IHRydWUgfTsgcmV0dXJuIHsgZG9uZTogZmFsc2UsIHZhbHVlOiBvW2krK10gfTsgfSwgZTogZnVuY3Rpb24gZShfZSkgeyB0aHJvdyBfZTsgfSwgZjogRiB9OyB9IHRocm93IG5ldyBUeXBlRXJyb3IoXCJJbnZhbGlkIGF0dGVtcHQgdG8gaXRlcmF0ZSBub24taXRlcmFibGUgaW5zdGFuY2UuXFxuSW4gb3JkZXIgdG8gYmUgaXRlcmFibGUsIG5vbi1hcnJheSBvYmplY3RzIG11c3QgaGF2ZSBhIFtTeW1ib2wuaXRlcmF0b3JdKCkgbWV0aG9kLlwiKTsgfSB2YXIgbm9ybWFsQ29tcGxldGlvbiA9IHRydWUsIGRpZEVyciA9IGZhbHNlLCBlcnI7IHJldHVybiB7IHM6IGZ1bmN0aW9uIHMoKSB7IGl0ID0gaXQuY2FsbChvKTsgfSwgbjogZnVuY3Rpb24gbigpIHsgdmFyIHN0ZXAgPSBpdC5uZXh0KCk7IG5vcm1hbENvbXBsZXRpb24gPSBzdGVwLmRvbmU7IHJldHVybiBzdGVwOyB9LCBlOiBmdW5jdGlvbiBlKF9lMikgeyBkaWRFcnIgPSB0cnVlOyBlcnIgPSBfZTI7IH0sIGY6IGZ1bmN0aW9uIGYoKSB7IHRyeSB7IGlmICghbm9ybWFsQ29tcGxldGlvbiAmJiBpdFtcInJldHVyblwiXSAhPSBudWxsKSBpdFtcInJldHVyblwiXSgpOyB9IGZpbmFsbHkgeyBpZiAoZGlkRXJyKSB0aHJvdyBlcnI7IH0gfSB9OyB9XG5cbmZ1bmN0aW9uIFBsb3RDcm9zc3Z1ZV90eXBlX3NjcmlwdF9sYW5nX2pzX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5KG8sIG1pbkxlbikgeyBpZiAoIW8pIHJldHVybjsgaWYgKHR5cGVvZiBvID09PSBcInN0cmluZ1wiKSByZXR1cm4gUGxvdENyb3NzdnVlX3R5cGVfc2NyaXB0X2xhbmdfanNfYXJyYXlMaWtlVG9BcnJheShvLCBtaW5MZW4pOyB2YXIgbiA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvKS5zbGljZSg4LCAtMSk7IGlmIChuID09PSBcIk9iamVjdFwiICYmIG8uY29uc3RydWN0b3IpIG4gPSBvLmNvbnN0cnVjdG9yLm5hbWU7IGlmIChuID09PSBcIk1hcFwiIHx8IG4gPT09IFwiU2V0XCIpIHJldHVybiBBcnJheS5mcm9tKG8pOyBpZiAobiA9PT0gXCJBcmd1bWVudHNcIiB8fCAvXig/OlVpfEkpbnQoPzo4fDE2fDMyKSg/OkNsYW1wZWQpP0FycmF5JC8udGVzdChuKSkgcmV0dXJuIFBsb3RDcm9zc3Z1ZV90eXBlX3NjcmlwdF9sYW5nX2pzX2FycmF5TGlrZVRvQXJyYXkobywgbWluTGVuKTsgfVxuXG5mdW5jdGlvbiBQbG90Q3Jvc3N2dWVfdHlwZV9zY3JpcHRfbGFuZ19qc19hcnJheUxpa2VUb0FycmF5KGFyciwgbGVuKSB7IGlmIChsZW4gPT0gbnVsbCB8fCBsZW4gPiBhcnIubGVuZ3RoKSBsZW4gPSBhcnIubGVuZ3RoOyBmb3IgKHZhciBpID0gMCwgYXJyMiA9IG5ldyBBcnJheShsZW4pOyBpIDwgbGVuOyBpKyspIHsgYXJyMltpXSA9IGFycltpXTsgfSByZXR1cm4gYXJyMjsgfVxuXG5cbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gY29uc3QgUGxvdENyb3NzdnVlX3R5cGVfc2NyaXB0X2xhbmdfanNfID0gKHtcbiAgbmFtZTogJ1Bsb3RDcm9zcycsXG4gIG1peGluczogW2V4dGVybmFsX3RyYWRpbmdfdnVlX2pzXy5PdmVybGF5XSxcbiAgbWV0aG9kczoge1xuICAgIG1ldGFfaW5mbzogZnVuY3Rpb24gbWV0YV9pbmZvKCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgYXV0aG9yOiAnU3RkU3F1YWQnLFxuICAgICAgICB2ZXJzaW9uOiAnMS4wLjAnLFxuICAgICAgICBkZXNjOiAnUGxvdCBsaW5lIHdpdGggY3Jvc3NlcydcbiAgICAgIH07XG4gICAgfSxcbiAgICBkcmF3OiBmdW5jdGlvbiBkcmF3KGN0eCkge1xuICAgICAgdmFyIHcgPSBjdHgubGluZVdpZHRoID0gdGhpcy5saW5lX3dpZHRoO1xuICAgICAgY3R4LnN0cm9rZVN0eWxlID0gdGhpcy5jb2xvcjtcbiAgICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICAgIHZhciBsYXlvdXQgPSB0aGlzLiRwcm9wcy5sYXlvdXQ7XG4gICAgICB2YXIgYmFzZSA9IGxheW91dC4kMnNjcmVlbigwKSArIDAuNTtcbiAgICAgIHZhciBvZmYgPSB0aGlzLmxpbmVfd2lkdGggJSAyID8gMCA6IDAuNTtcbiAgICAgIHZhciBvZmYyID0gdGhpcy5saW5lX3dpZHRoICUgMiA/IDAuNSA6IDE7IC8vIENvbG9yIGNoYW5nZWRcblxuICAgICAgdmFyIGNoYW5nZWQgPSBmYWxzZTtcblxuICAgICAgdmFyIF9pdGVyYXRvciA9IFBsb3RDcm9zc3Z1ZV90eXBlX3NjcmlwdF9sYW5nX2pzX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXIodGhpcy4kcHJvcHMuZGF0YSksXG4gICAgICAgICAgX3N0ZXA7XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIGZvciAoX2l0ZXJhdG9yLnMoKTsgIShfc3RlcCA9IF9pdGVyYXRvci5uKCkpLmRvbmU7KSB7XG4gICAgICAgICAgdmFyIHAgPSBfc3RlcC52YWx1ZTtcbiAgICAgICAgICB2YXIgeCA9IGxheW91dC50MnNjcmVlbihwWzBdKSAtIG9mZjtcbiAgICAgICAgICB2YXIgeSA9IGxheW91dC4kMnNjcmVlbihwWzFdKSAtIG9mZjtcbiAgICAgICAgICB2YXIgX2NoYW5nZWQgPSBmYWxzZTtcblxuICAgICAgICAgIGlmIChwWzJdKSB7XG4gICAgICAgICAgICBpZiAoY3R4LnN0cm9rZVN0eWxlICE9PSBwWzJdKSB7XG4gICAgICAgICAgICAgIGN0eC5zdHJva2UoKTtcbiAgICAgICAgICAgICAgX2NoYW5nZWQgPSB0cnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjdHguc3Ryb2tlU3R5bGUgPSBwWzJdO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAoY3R4LnN0cm9rZVN0eWxlICE9PSB0aGlzLmNvbG9yKSB7XG4gICAgICAgICAgICAgIGN0eC5zdHJva2UoKTtcbiAgICAgICAgICAgICAgX2NoYW5nZWQgPSB0cnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjdHguc3Ryb2tlU3R5bGUgPSB0aGlzLmNvbG9yO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChfY2hhbmdlZCkgY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgICAgIGN0eC5tb3ZlVG8oeCwgeSAtIHcgKiAyICsgb2ZmMik7XG4gICAgICAgICAgY3R4LmxpbmVUbyh4LCB5ICsgdyAqIDIgLSBvZmYyKTtcbiAgICAgICAgICBjdHgubW92ZVRvKHggLSB3ICogMiArIG9mZjIsIHkpO1xuICAgICAgICAgIGN0eC5saW5lVG8oeCArIHcgKiAyIC0gb2ZmMiwgeSk7XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICBfaXRlcmF0b3IuZShlcnIpO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgX2l0ZXJhdG9yLmYoKTtcbiAgICAgIH1cblxuICAgICAgY3R4LnN0cm9rZSgpO1xuICAgIH0sXG4gICAgdXNlX2ZvcjogZnVuY3Rpb24gdXNlX2ZvcigpIHtcbiAgICAgIHJldHVybiBbJ1Bsb3RDcm9zcyddO1xuICAgIH0sXG4gICAgbGVnZW5kOiBmdW5jdGlvbiBsZWdlbmQodmFsdWVzKSB7XG4gICAgICB2YXIgeCA9IHZhbHVlc1sxXTtcblxuICAgICAgaWYgKHR5cGVvZiB4ID09PSBcIm51bWJlclwiKSB7XG4gICAgICAgIHggPSB4LnRvRml4ZWQoTWF0aC5hYnMoeCkgPiAwLjAwMSA/IDQgOiA4KTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIFt7XG4gICAgICAgIHZhbHVlOiB4LFxuICAgICAgICBjb2xvcjogdmFsdWVzWzJdIHx8IHRoaXMuY29sb3JcbiAgICAgIH1dO1xuICAgIH1cbiAgfSxcbiAgLy8gRGVmaW5lIGludGVybmFsIHNldHRpbmcgJiBjb25zdGFudHMgaGVyZVxuICBjb21wdXRlZDoge1xuICAgIHNldHQ6IGZ1bmN0aW9uIHNldHQoKSB7XG4gICAgICByZXR1cm4gdGhpcy4kcHJvcHMuc2V0dGluZ3M7XG4gICAgfSxcbiAgICBsaW5lX3dpZHRoOiBmdW5jdGlvbiBsaW5lX3dpZHRoKCkge1xuICAgICAgcmV0dXJuIHRoaXMuc2V0dC5saW5lV2lkdGggfHwgMjtcbiAgICB9LFxuICAgIGNvbG9yOiBmdW5jdGlvbiBjb2xvcigpIHtcbiAgICAgIHZhciBuID0gdGhpcy4kcHJvcHMubnVtICUgNTtcbiAgICAgIHJldHVybiB0aGlzLnNldHQuY29sb3IgfHwgdGhpcy5DT0xPUlNbbl07XG4gICAgfVxuICB9LFxuICBkYXRhOiBmdW5jdGlvbiBkYXRhKCkge1xuICAgIHJldHVybiB7XG4gICAgICBDT0xPUlM6IFsnIzg4ODg4OCcsICcjNDJiMjhhJywgJyM1NjkxY2UnLCAnIzYxMmZmOScsICcjZDUwYjkwJywgJyNmZjIzMTYnXVxuICAgIH07XG4gIH1cbn0pO1xuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL292ZXJsYXlzL1Bsb3RDcm9zcy9QbG90Q3Jvc3MudnVlP3Z1ZSZ0eXBlPXNjcmlwdCZsYW5nPWpzJlxuIC8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gY29uc3QgUGxvdENyb3NzX1Bsb3RDcm9zc3Z1ZV90eXBlX3NjcmlwdF9sYW5nX2pzXyA9IChQbG90Q3Jvc3N2dWVfdHlwZV9zY3JpcHRfbGFuZ19qc18pOyBcbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9vdmVybGF5cy9QbG90Q3Jvc3MvUGxvdENyb3NzLnZ1ZVxudmFyIFBsb3RDcm9zc19yZW5kZXIsIFBsb3RDcm9zc19zdGF0aWNSZW5kZXJGbnNcbjtcblxuXG5cbi8qIG5vcm1hbGl6ZSBjb21wb25lbnQgKi9cbjtcbnZhciBQbG90Q3Jvc3NfY29tcG9uZW50ID0gbm9ybWFsaXplQ29tcG9uZW50KFxuICBQbG90Q3Jvc3NfUGxvdENyb3NzdnVlX3R5cGVfc2NyaXB0X2xhbmdfanNfLFxuICBQbG90Q3Jvc3NfcmVuZGVyLFxuICBQbG90Q3Jvc3Nfc3RhdGljUmVuZGVyRm5zLFxuICBmYWxzZSxcbiAgbnVsbCxcbiAgbnVsbCxcbiAgbnVsbFxuICBcbilcblxuLyogaG90IHJlbG9hZCAqL1xuaWYgKGZhbHNlKSB7IHZhciBQbG90Q3Jvc3NfYXBpOyB9XG5QbG90Q3Jvc3NfY29tcG9uZW50Lm9wdGlvbnMuX19maWxlID0gXCJzcmMvb3ZlcmxheXMvUGxvdENyb3NzL1Bsb3RDcm9zcy52dWVcIlxuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyBjb25zdCBQbG90Q3Jvc3MgPSAoUGxvdENyb3NzX2NvbXBvbmVudC5leHBvcnRzKTtcbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL25vZGVfbW9kdWxlcy9iYWJlbC1sb2FkZXIvbGliL2luZGV4LmpzIS4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL2luZGV4LmpzPz92dWUtbG9hZGVyLW9wdGlvbnMhLi9zcmMvb3ZlcmxheXMvUk9DL1JPQy52dWU/dnVlJnR5cGU9c2NyaXB0Jmxhbmc9anMmXG5cbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gY29uc3QgUk9DdnVlX3R5cGVfc2NyaXB0X2xhbmdfanNfID0gKHtcbiAgbmFtZTogJ1JPQycsXG4gIG1peGluczogW2V4dGVybmFsX3RyYWRpbmdfdnVlX2pzXy5PdmVybGF5XSxcbiAgbWV0aG9kczoge1xuICAgIG1ldGFfaW5mbzogZnVuY3Rpb24gbWV0YV9pbmZvKCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgYXV0aG9yOiAnU3RkU3F1YWQnLFxuICAgICAgICB2ZXJzaW9uOiAnMS4wLjAnLFxuICAgICAgICBkZXNjOiAnUmF0ZSBvZiBDaGFuZ2UnLFxuICAgICAgICBwcmVzZXQ6IHtcbiAgICAgICAgICBuYW1lOiAnUk9DICRsZW5ndGgnLFxuICAgICAgICAgIHNpZGU6ICdvZmZjaGFydCcsXG4gICAgICAgICAgc2V0dGluZ3M6IHtcbiAgICAgICAgICAgIGxpbmVXaWR0aDogMC43NSxcbiAgICAgICAgICAgIGNvbG9yOiAnIzI3OWZjNCdcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfSxcbiAgICB1c2VfZm9yOiBmdW5jdGlvbiB1c2VfZm9yKCkge1xuICAgICAgcmV0dXJuIFsnUk9DJ107XG4gICAgfSxcbiAgICBjYWxjOiBmdW5jdGlvbiBjYWxjKCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgcHJvcHM6IHtcbiAgICAgICAgICBsZW5ndGg6IHtcbiAgICAgICAgICAgIGRlZjogOSxcbiAgICAgICAgICAgIHRleHQ6ICdMZW5ndGgnXG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBjb25mOiB7XG4gICAgICAgICAgcmVuZGVyZXI6ICdTcGxpbmUnXG4gICAgICAgIH0sXG4gICAgICAgIHVwZGF0ZTogXCJcXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByb2MoY2xvc2UsIGxlbmd0aClbMF1cXG4gICAgICAgICAgICAgICAgXCJcbiAgICAgIH07XG4gICAgfVxuICB9XG59KTtcbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9vdmVybGF5cy9ST0MvUk9DLnZ1ZT92dWUmdHlwZT1zY3JpcHQmbGFuZz1qcyZcbiAvKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIGNvbnN0IFJPQ19ST0N2dWVfdHlwZV9zY3JpcHRfbGFuZ19qc18gPSAoUk9DdnVlX3R5cGVfc2NyaXB0X2xhbmdfanNfKTsgXG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvb3ZlcmxheXMvUk9DL1JPQy52dWVcbnZhciBST0NfcmVuZGVyLCBST0Nfc3RhdGljUmVuZGVyRm5zXG47XG5cblxuXG4vKiBub3JtYWxpemUgY29tcG9uZW50ICovXG47XG52YXIgUk9DX2NvbXBvbmVudCA9IG5vcm1hbGl6ZUNvbXBvbmVudChcbiAgUk9DX1JPQ3Z1ZV90eXBlX3NjcmlwdF9sYW5nX2pzXyxcbiAgUk9DX3JlbmRlcixcbiAgUk9DX3N0YXRpY1JlbmRlckZucyxcbiAgZmFsc2UsXG4gIG51bGwsXG4gIG51bGwsXG4gIG51bGxcbiAgXG4pXG5cbi8qIGhvdCByZWxvYWQgKi9cbmlmIChmYWxzZSkgeyB2YXIgUk9DX2FwaTsgfVxuUk9DX2NvbXBvbmVudC5vcHRpb25zLl9fZmlsZSA9IFwic3JjL292ZXJsYXlzL1JPQy9ST0MudnVlXCJcbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gY29uc3QgUk9DID0gKFJPQ19jb21wb25lbnQuZXhwb3J0cyk7XG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9ub2RlX21vZHVsZXMvYmFiZWwtbG9hZGVyL2xpYi9pbmRleC5qcyEuL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9pbmRleC5qcz8/dnVlLWxvYWRlci1vcHRpb25zIS4vc3JjL292ZXJsYXlzL1JTSS9SU0kudnVlP3Z1ZSZ0eXBlPXNjcmlwdCZsYW5nPWpzJlxuXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIGNvbnN0IFJTSXZ1ZV90eXBlX3NjcmlwdF9sYW5nX2pzXyA9ICh7XG4gIG5hbWU6ICdSU0knLFxuICBtaXhpbnM6IFtleHRlcm5hbF90cmFkaW5nX3Z1ZV9qc18uT3ZlcmxheV0sXG4gIG1ldGhvZHM6IHtcbiAgICBtZXRhX2luZm86IGZ1bmN0aW9uIG1ldGFfaW5mbygpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGF1dGhvcjogJ1N0ZFNxdWFkJyxcbiAgICAgICAgdmVyc2lvbjogJzEuMC4wJyxcbiAgICAgICAgZGVzYzogJ1JlbGF0aXZlIFN0cmVuZ3RoIEluZGV4JyxcbiAgICAgICAgcHJlc2V0OiB7XG4gICAgICAgICAgbmFtZTogJ1JTSSAkbGVuZ3RoJyxcbiAgICAgICAgICBzaWRlOiAnb2ZmY2hhcnQnLFxuICAgICAgICAgIHNldHRpbmdzOiB7XG4gICAgICAgICAgICBsaW5lV2lkdGg6IDAuNzUsXG4gICAgICAgICAgICBjb2xvcjogJyNlYzIwNmUnLFxuICAgICAgICAgICAgYmFuZENvbG9yOiAnI2FhYScsXG4gICAgICAgICAgICBiYWNrQ29sb3I6ICcjOWI5YmEzMTYnXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9O1xuICAgIH0sXG4gICAgdXNlX2ZvcjogZnVuY3Rpb24gdXNlX2ZvcigpIHtcbiAgICAgIHJldHVybiBbJ1JTSSddO1xuICAgIH0sXG4gICAgY2FsYzogZnVuY3Rpb24gY2FsYygpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHByb3BzOiB7XG4gICAgICAgICAgbGVuZ3RoOiB7XG4gICAgICAgICAgICBkZWY6IDE0LFxuICAgICAgICAgICAgdGV4dDogJ0xlbmd0aCdcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIGNvbmY6IHtcbiAgICAgICAgICByZW5kZXJlcjogJ1JhbmdlJ1xuICAgICAgICB9LFxuICAgICAgICB1cGRhdGU6IFwicmV0dXJuIHJzaShjbG9zZSwgbGVuZ3RoKVswXVwiXG4gICAgICB9O1xuICAgIH1cbiAgfVxufSk7XG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvb3ZlcmxheXMvUlNJL1JTSS52dWU/dnVlJnR5cGU9c2NyaXB0Jmxhbmc9anMmXG4gLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyBjb25zdCBSU0lfUlNJdnVlX3R5cGVfc2NyaXB0X2xhbmdfanNfID0gKFJTSXZ1ZV90eXBlX3NjcmlwdF9sYW5nX2pzXyk7IFxuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL292ZXJsYXlzL1JTSS9SU0kudnVlXG52YXIgUlNJX3JlbmRlciwgUlNJX3N0YXRpY1JlbmRlckZuc1xuO1xuXG5cblxuLyogbm9ybWFsaXplIGNvbXBvbmVudCAqL1xuO1xudmFyIFJTSV9jb21wb25lbnQgPSBub3JtYWxpemVDb21wb25lbnQoXG4gIFJTSV9SU0l2dWVfdHlwZV9zY3JpcHRfbGFuZ19qc18sXG4gIFJTSV9yZW5kZXIsXG4gIFJTSV9zdGF0aWNSZW5kZXJGbnMsXG4gIGZhbHNlLFxuICBudWxsLFxuICBudWxsLFxuICBudWxsXG4gIFxuKVxuXG4vKiBob3QgcmVsb2FkICovXG5pZiAoZmFsc2UpIHsgdmFyIFJTSV9hcGk7IH1cblJTSV9jb21wb25lbnQub3B0aW9ucy5fX2ZpbGUgPSBcInNyYy9vdmVybGF5cy9SU0kvUlNJLnZ1ZVwiXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIGNvbnN0IFJTSSA9IChSU0lfY29tcG9uZW50LmV4cG9ydHMpO1xuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vbm9kZV9tb2R1bGVzL2JhYmVsLWxvYWRlci9saWIvaW5kZXguanMhLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvaW5kZXguanM/P3Z1ZS1sb2FkZXItb3B0aW9ucyEuL3NyYy9vdmVybGF5cy9SaWJib24vUmliYm9uLnZ1ZT92dWUmdHlwZT1zY3JpcHQmbGFuZz1qcyZcblxuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyBjb25zdCBSaWJib252dWVfdHlwZV9zY3JpcHRfbGFuZ19qc18gPSAoe1xuICBuYW1lOiAnUmliYm9uJyxcbiAgbWl4aW5zOiBbZXh0ZXJuYWxfdHJhZGluZ192dWVfanNfLk92ZXJsYXldLFxuICBtZXRob2RzOiB7XG4gICAgbWV0YV9pbmZvOiBmdW5jdGlvbiBtZXRhX2luZm8oKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBhdXRob3I6ICdTdGRTcXVhZCcsXG4gICAgICAgIHZlcnNpb246ICcxLjAuMCcsXG4gICAgICAgIGRlc2M6ICdNb3ZpbmcgQXZlcmFnZSBSaWJib24nLFxuICAgICAgICBwcmVzZXQ6IHtcbiAgICAgICAgICBuYW1lOiAnRU1BIHggJG51bWJlcicsXG4gICAgICAgICAgc2lkZTogJ29uY2hhcnQnLFxuICAgICAgICAgIHNldHRpbmdzOiB7XG4gICAgICAgICAgICBsaW5lV2lkdGg6IDAuNzUsXG4gICAgICAgICAgICBjb2xvcnM6IFtcIiMzYWFhZjRlZVwiXVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9LFxuICAgIHVzZV9mb3I6IGZ1bmN0aW9uIHVzZV9mb3IoKSB7XG4gICAgICByZXR1cm4gWydSaWJib24nXTtcbiAgICB9LFxuICAgIGNhbGM6IGZ1bmN0aW9uIGNhbGMoKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBwcm9wczoge1xuICAgICAgICAgIHN0YXJ0OiB7XG4gICAgICAgICAgICBkZWY6IDEwLFxuICAgICAgICAgICAgdGV4dDogJ1N0YXJ0IExlbmd0aCdcbiAgICAgICAgICB9LFxuICAgICAgICAgIG51bWJlcjoge1xuICAgICAgICAgICAgZGVmOiA1LFxuICAgICAgICAgICAgdGV4dDogJ051bWJlciBvZiBMaW5lcydcbiAgICAgICAgICB9LFxuICAgICAgICAgIHN0ZXA6IHtcbiAgICAgICAgICAgIGRlZjogMTAsXG4gICAgICAgICAgICB0ZXh0OiAnTGVuZ3RoIFN0ZXAnXG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBjb25mOiB7XG4gICAgICAgICAgcmVuZGVyZXI6ICdTcGxpbmVzJ1xuICAgICAgICB9LFxuICAgICAgICB1cGRhdGU6IFwiXFxuICAgICAgICAgICAgICAgICAgICB0aGlzWzBdID0gW11cXG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbnVtYmVyOyBpKyspIHtcXG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgbCA9IHN0YXJ0ICsgaSAqIHN0ZXBcXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzWzBdLnB1c2goZW1hKGNsb3NlLCBsKVswXSlcXG4gICAgICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICAgICAgXCJcbiAgICAgIH07XG4gICAgfVxuICB9XG59KTtcbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9vdmVybGF5cy9SaWJib24vUmliYm9uLnZ1ZT92dWUmdHlwZT1zY3JpcHQmbGFuZz1qcyZcbiAvKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIGNvbnN0IFJpYmJvbl9SaWJib252dWVfdHlwZV9zY3JpcHRfbGFuZ19qc18gPSAoUmliYm9udnVlX3R5cGVfc2NyaXB0X2xhbmdfanNfKTsgXG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvb3ZlcmxheXMvUmliYm9uL1JpYmJvbi52dWVcbnZhciBSaWJib25fcmVuZGVyLCBSaWJib25fc3RhdGljUmVuZGVyRm5zXG47XG5cblxuXG4vKiBub3JtYWxpemUgY29tcG9uZW50ICovXG47XG52YXIgUmliYm9uX2NvbXBvbmVudCA9IG5vcm1hbGl6ZUNvbXBvbmVudChcbiAgUmliYm9uX1JpYmJvbnZ1ZV90eXBlX3NjcmlwdF9sYW5nX2pzXyxcbiAgUmliYm9uX3JlbmRlcixcbiAgUmliYm9uX3N0YXRpY1JlbmRlckZucyxcbiAgZmFsc2UsXG4gIG51bGwsXG4gIG51bGwsXG4gIG51bGxcbiAgXG4pXG5cbi8qIGhvdCByZWxvYWQgKi9cbmlmIChmYWxzZSkgeyB2YXIgUmliYm9uX2FwaTsgfVxuUmliYm9uX2NvbXBvbmVudC5vcHRpb25zLl9fZmlsZSA9IFwic3JjL292ZXJsYXlzL1JpYmJvbi9SaWJib24udnVlXCJcbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gY29uc3QgUmliYm9uID0gKFJpYmJvbl9jb21wb25lbnQuZXhwb3J0cyk7XG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9ub2RlX21vZHVsZXMvYmFiZWwtbG9hZGVyL2xpYi9pbmRleC5qcyEuL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9pbmRleC5qcz8/dnVlLWxvYWRlci1vcHRpb25zIS4vc3JjL292ZXJsYXlzL1NBUi9TQVIudnVlP3Z1ZSZ0eXBlPXNjcmlwdCZsYW5nPWpzJlxuXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIGNvbnN0IFNBUnZ1ZV90eXBlX3NjcmlwdF9sYW5nX2pzXyA9ICh7XG4gIG5hbWU6ICdTQVInLFxuICBtaXhpbnM6IFtleHRlcm5hbF90cmFkaW5nX3Z1ZV9qc18uT3ZlcmxheV0sXG4gIG1ldGhvZHM6IHtcbiAgICBtZXRhX2luZm86IGZ1bmN0aW9uIG1ldGFfaW5mbygpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGF1dGhvcjogJ1N0ZFNxdWFkJyxcbiAgICAgICAgdmVyc2lvbjogJzEuMC4wJyxcbiAgICAgICAgZGVzYzogJ1BhcmFib2xpYyBTQVInLFxuICAgICAgICBwcmVzZXQ6IHtcbiAgICAgICAgICBuYW1lOiAnU0FSICRzdGFydCAkaW5jICRtYXgnLFxuICAgICAgICAgIHNpZGU6ICdvbmNoYXJ0JyxcbiAgICAgICAgICBzZXR0aW5nczoge1xuICAgICAgICAgICAgbGluZVdpZHRoOiAyLFxuICAgICAgICAgICAgY29sb3I6ICcjMzVhOWM2J1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9LFxuICAgIHVzZV9mb3I6IGZ1bmN0aW9uIHVzZV9mb3IoKSB7XG4gICAgICByZXR1cm4gWydTQVInXTtcbiAgICB9LFxuICAgIGNhbGM6IGZ1bmN0aW9uIGNhbGMoKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBwcm9wczoge1xuICAgICAgICAgIHN0YXJ0OiB7XG4gICAgICAgICAgICBkZWY6IDAuMDIsXG4gICAgICAgICAgICB0ZXh0OiAnU3RhcnQnXG4gICAgICAgICAgfSxcbiAgICAgICAgICBpbmM6IHtcbiAgICAgICAgICAgIGRlZjogMC4wMixcbiAgICAgICAgICAgIHRleHQ6ICdJbmNyZW1lbnQnXG4gICAgICAgICAgfSxcbiAgICAgICAgICBtYXg6IHtcbiAgICAgICAgICAgIGRlZjogMC4yLFxuICAgICAgICAgICAgdGV4dDogJ01heGltdW0nXG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBjb25mOiB7XG4gICAgICAgICAgcmVuZGVyZXI6ICdQbG90Q3Jvc3MnXG4gICAgICAgIH0sXG4gICAgICAgIHVwZGF0ZTogXCJcXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBzYXIoc3RhcnQsIGluYywgbWF4KVswXVxcbiAgICAgICAgICAgICAgICBcIlxuICAgICAgfTtcbiAgICB9XG4gIH1cbn0pO1xuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL292ZXJsYXlzL1NBUi9TQVIudnVlP3Z1ZSZ0eXBlPXNjcmlwdCZsYW5nPWpzJlxuIC8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gY29uc3QgU0FSX1NBUnZ1ZV90eXBlX3NjcmlwdF9sYW5nX2pzXyA9IChTQVJ2dWVfdHlwZV9zY3JpcHRfbGFuZ19qc18pOyBcbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9vdmVybGF5cy9TQVIvU0FSLnZ1ZVxudmFyIFNBUl9yZW5kZXIsIFNBUl9zdGF0aWNSZW5kZXJGbnNcbjtcblxuXG5cbi8qIG5vcm1hbGl6ZSBjb21wb25lbnQgKi9cbjtcbnZhciBTQVJfY29tcG9uZW50ID0gbm9ybWFsaXplQ29tcG9uZW50KFxuICBTQVJfU0FSdnVlX3R5cGVfc2NyaXB0X2xhbmdfanNfLFxuICBTQVJfcmVuZGVyLFxuICBTQVJfc3RhdGljUmVuZGVyRm5zLFxuICBmYWxzZSxcbiAgbnVsbCxcbiAgbnVsbCxcbiAgbnVsbFxuICBcbilcblxuLyogaG90IHJlbG9hZCAqL1xuaWYgKGZhbHNlKSB7IHZhciBTQVJfYXBpOyB9XG5TQVJfY29tcG9uZW50Lm9wdGlvbnMuX19maWxlID0gXCJzcmMvb3ZlcmxheXMvU0FSL1NBUi52dWVcIlxuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyBjb25zdCBTQVIgPSAoU0FSX2NvbXBvbmVudC5leHBvcnRzKTtcbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL25vZGVfbW9kdWxlcy9iYWJlbC1sb2FkZXIvbGliL2luZGV4LmpzIS4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL2luZGV4LmpzPz92dWUtbG9hZGVyLW9wdGlvbnMhLi9zcmMvb3ZlcmxheXMvU01BL1NNQS52dWU/dnVlJnR5cGU9c2NyaXB0Jmxhbmc9anMmXG5cbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gY29uc3QgU01BdnVlX3R5cGVfc2NyaXB0X2xhbmdfanNfID0gKHtcbiAgbmFtZTogJ1NNQScsXG4gIG1peGluczogW2V4dGVybmFsX3RyYWRpbmdfdnVlX2pzXy5PdmVybGF5XSxcbiAgbWV0aG9kczoge1xuICAgIG1ldGFfaW5mbzogZnVuY3Rpb24gbWV0YV9pbmZvKCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgYXV0aG9yOiAnU3RkU3F1YWQnLFxuICAgICAgICB2ZXJzaW9uOiAnMS4wLjAnLFxuICAgICAgICBkZXNjOiAnU2ltcGxlIE1vdmluZyBBdmVyYWdlJyxcbiAgICAgICAgcHJlc2V0OiB7XG4gICAgICAgICAgbmFtZTogJ1NNQSAkbGVuZ3RoJyxcbiAgICAgICAgICBzaWRlOiAnb25jaGFydCcsXG4gICAgICAgICAgc2V0dGluZ3M6IHtcbiAgICAgICAgICAgIGxpbmVXaWR0aDogMC43NSxcbiAgICAgICAgICAgIGNvbG9yOiAnI2QxMzg1YydcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfSxcbiAgICB1c2VfZm9yOiBmdW5jdGlvbiB1c2VfZm9yKCkge1xuICAgICAgcmV0dXJuIFsnU01BJ107XG4gICAgfSxcbiAgICBjYWxjOiBmdW5jdGlvbiBjYWxjKCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgcHJvcHM6IHtcbiAgICAgICAgICBsZW5ndGg6IHtcbiAgICAgICAgICAgIGRlZjogMjUsXG4gICAgICAgICAgICB0ZXh0OiAnTGVuZ3RoJ1xuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgY29uZjoge1xuICAgICAgICAgIHJlbmRlcmVyOiAnU3BsaW5lJ1xuICAgICAgICB9LFxuICAgICAgICB1cGRhdGU6IFwiXFxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gc21hKGNsb3NlLCBsZW5ndGgpWzBdXFxuICAgICAgICAgICAgICAgIFwiXG4gICAgICB9O1xuICAgIH1cbiAgfVxufSk7XG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvb3ZlcmxheXMvU01BL1NNQS52dWU/dnVlJnR5cGU9c2NyaXB0Jmxhbmc9anMmXG4gLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyBjb25zdCBTTUFfU01BdnVlX3R5cGVfc2NyaXB0X2xhbmdfanNfID0gKFNNQXZ1ZV90eXBlX3NjcmlwdF9sYW5nX2pzXyk7IFxuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL292ZXJsYXlzL1NNQS9TTUEudnVlXG52YXIgU01BX3JlbmRlciwgU01BX3N0YXRpY1JlbmRlckZuc1xuO1xuXG5cblxuLyogbm9ybWFsaXplIGNvbXBvbmVudCAqL1xuO1xudmFyIFNNQV9jb21wb25lbnQgPSBub3JtYWxpemVDb21wb25lbnQoXG4gIFNNQV9TTUF2dWVfdHlwZV9zY3JpcHRfbGFuZ19qc18sXG4gIFNNQV9yZW5kZXIsXG4gIFNNQV9zdGF0aWNSZW5kZXJGbnMsXG4gIGZhbHNlLFxuICBudWxsLFxuICBudWxsLFxuICBudWxsXG4gIFxuKVxuXG4vKiBob3QgcmVsb2FkICovXG5pZiAoZmFsc2UpIHsgdmFyIFNNQV9hcGk7IH1cblNNQV9jb21wb25lbnQub3B0aW9ucy5fX2ZpbGUgPSBcInNyYy9vdmVybGF5cy9TTUEvU01BLnZ1ZVwiXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIGNvbnN0IFNNQSA9IChTTUFfY29tcG9uZW50LmV4cG9ydHMpO1xuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vbm9kZV9tb2R1bGVzL2JhYmVsLWxvYWRlci9saWIvaW5kZXguanMhLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvaW5kZXguanM/P3Z1ZS1sb2FkZXItb3B0aW9ucyEuL3NyYy9vdmVybGF5cy9TV01BL1NXTUEudnVlP3Z1ZSZ0eXBlPXNjcmlwdCZsYW5nPWpzJlxuXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIGNvbnN0IFNXTUF2dWVfdHlwZV9zY3JpcHRfbGFuZ19qc18gPSAoe1xuICBuYW1lOiAnU1dNQScsXG4gIG1peGluczogW2V4dGVybmFsX3RyYWRpbmdfdnVlX2pzXy5PdmVybGF5XSxcbiAgbWV0aG9kczoge1xuICAgIG1ldGFfaW5mbzogZnVuY3Rpb24gbWV0YV9pbmZvKCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgYXV0aG9yOiAnU3RkU3F1YWQnLFxuICAgICAgICB2ZXJzaW9uOiAnMS4wLjAnLFxuICAgICAgICBkZXNjOiAnU3ltbWV0cmljYWxseSBXZWlnaHRlZCBNb3ZpbmcgQXZlcmFnZScsXG4gICAgICAgIHByZXNldDoge1xuICAgICAgICAgIG5hbWU6ICdTV01BJyxcbiAgICAgICAgICBzaWRlOiAnb25jaGFydCcsXG4gICAgICAgICAgc2V0dGluZ3M6IHtcbiAgICAgICAgICAgIGxpbmVXaWR0aDogMC43NSxcbiAgICAgICAgICAgIGNvbG9yOiAnI2U1NzQ0MCdcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfSxcbiAgICB1c2VfZm9yOiBmdW5jdGlvbiB1c2VfZm9yKCkge1xuICAgICAgcmV0dXJuIFsnU1dNQSddO1xuICAgIH0sXG4gICAgY2FsYzogZnVuY3Rpb24gY2FsYygpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHByb3BzOiB7fSxcbiAgICAgICAgY29uZjoge1xuICAgICAgICAgIHJlbmRlcmVyOiAnU3BsaW5lJ1xuICAgICAgICB9LFxuICAgICAgICB1cGRhdGU6IFwiXFxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gc3dtYShjbG9zZSlbMF1cXG4gICAgICAgICAgICAgICAgXCJcbiAgICAgIH07XG4gICAgfVxuICB9XG59KTtcbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9vdmVybGF5cy9TV01BL1NXTUEudnVlP3Z1ZSZ0eXBlPXNjcmlwdCZsYW5nPWpzJlxuIC8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gY29uc3QgU1dNQV9TV01BdnVlX3R5cGVfc2NyaXB0X2xhbmdfanNfID0gKFNXTUF2dWVfdHlwZV9zY3JpcHRfbGFuZ19qc18pOyBcbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9vdmVybGF5cy9TV01BL1NXTUEudnVlXG52YXIgU1dNQV9yZW5kZXIsIFNXTUFfc3RhdGljUmVuZGVyRm5zXG47XG5cblxuXG4vKiBub3JtYWxpemUgY29tcG9uZW50ICovXG47XG52YXIgU1dNQV9jb21wb25lbnQgPSBub3JtYWxpemVDb21wb25lbnQoXG4gIFNXTUFfU1dNQXZ1ZV90eXBlX3NjcmlwdF9sYW5nX2pzXyxcbiAgU1dNQV9yZW5kZXIsXG4gIFNXTUFfc3RhdGljUmVuZGVyRm5zLFxuICBmYWxzZSxcbiAgbnVsbCxcbiAgbnVsbCxcbiAgbnVsbFxuICBcbilcblxuLyogaG90IHJlbG9hZCAqL1xuaWYgKGZhbHNlKSB7IHZhciBTV01BX2FwaTsgfVxuU1dNQV9jb21wb25lbnQub3B0aW9ucy5fX2ZpbGUgPSBcInNyYy9vdmVybGF5cy9TV01BL1NXTUEudnVlXCJcbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gY29uc3QgU1dNQSA9IChTV01BX2NvbXBvbmVudC5leHBvcnRzKTtcbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL25vZGVfbW9kdWxlcy9iYWJlbC1sb2FkZXIvbGliL2luZGV4LmpzIS4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL2luZGV4LmpzPz92dWUtbG9hZGVyLW9wdGlvbnMhLi9zcmMvb3ZlcmxheXMvU3RvY2gvU3RvY2gudnVlP3Z1ZSZ0eXBlPXNjcmlwdCZsYW5nPWpzJlxuZnVuY3Rpb24gU3RvY2h2dWVfdHlwZV9zY3JpcHRfbGFuZ19qc19jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyKG8sIGFsbG93QXJyYXlMaWtlKSB7IHZhciBpdCA9IHR5cGVvZiBTeW1ib2wgIT09IFwidW5kZWZpbmVkXCIgJiYgb1tTeW1ib2wuaXRlcmF0b3JdIHx8IG9bXCJAQGl0ZXJhdG9yXCJdOyBpZiAoIWl0KSB7IGlmIChBcnJheS5pc0FycmF5KG8pIHx8IChpdCA9IFN0b2NodnVlX3R5cGVfc2NyaXB0X2xhbmdfanNfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkobykpIHx8IGFsbG93QXJyYXlMaWtlICYmIG8gJiYgdHlwZW9mIG8ubGVuZ3RoID09PSBcIm51bWJlclwiKSB7IGlmIChpdCkgbyA9IGl0OyB2YXIgaSA9IDA7IHZhciBGID0gZnVuY3Rpb24gRigpIHt9OyByZXR1cm4geyBzOiBGLCBuOiBmdW5jdGlvbiBuKCkgeyBpZiAoaSA+PSBvLmxlbmd0aCkgcmV0dXJuIHsgZG9uZTogdHJ1ZSB9OyByZXR1cm4geyBkb25lOiBmYWxzZSwgdmFsdWU6IG9baSsrXSB9OyB9LCBlOiBmdW5jdGlvbiBlKF9lKSB7IHRocm93IF9lOyB9LCBmOiBGIH07IH0gdGhyb3cgbmV3IFR5cGVFcnJvcihcIkludmFsaWQgYXR0ZW1wdCB0byBpdGVyYXRlIG5vbi1pdGVyYWJsZSBpbnN0YW5jZS5cXG5JbiBvcmRlciB0byBiZSBpdGVyYWJsZSwgbm9uLWFycmF5IG9iamVjdHMgbXVzdCBoYXZlIGEgW1N5bWJvbC5pdGVyYXRvcl0oKSBtZXRob2QuXCIpOyB9IHZhciBub3JtYWxDb21wbGV0aW9uID0gdHJ1ZSwgZGlkRXJyID0gZmFsc2UsIGVycjsgcmV0dXJuIHsgczogZnVuY3Rpb24gcygpIHsgaXQgPSBpdC5jYWxsKG8pOyB9LCBuOiBmdW5jdGlvbiBuKCkgeyB2YXIgc3RlcCA9IGl0Lm5leHQoKTsgbm9ybWFsQ29tcGxldGlvbiA9IHN0ZXAuZG9uZTsgcmV0dXJuIHN0ZXA7IH0sIGU6IGZ1bmN0aW9uIGUoX2UyKSB7IGRpZEVyciA9IHRydWU7IGVyciA9IF9lMjsgfSwgZjogZnVuY3Rpb24gZigpIHsgdHJ5IHsgaWYgKCFub3JtYWxDb21wbGV0aW9uICYmIGl0W1wicmV0dXJuXCJdICE9IG51bGwpIGl0W1wicmV0dXJuXCJdKCk7IH0gZmluYWxseSB7IGlmIChkaWRFcnIpIHRocm93IGVycjsgfSB9IH07IH1cblxuZnVuY3Rpb24gU3RvY2h2dWVfdHlwZV9zY3JpcHRfbGFuZ19qc191bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheShvLCBtaW5MZW4pIHsgaWYgKCFvKSByZXR1cm47IGlmICh0eXBlb2YgbyA9PT0gXCJzdHJpbmdcIikgcmV0dXJuIFN0b2NodnVlX3R5cGVfc2NyaXB0X2xhbmdfanNfYXJyYXlMaWtlVG9BcnJheShvLCBtaW5MZW4pOyB2YXIgbiA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvKS5zbGljZSg4LCAtMSk7IGlmIChuID09PSBcIk9iamVjdFwiICYmIG8uY29uc3RydWN0b3IpIG4gPSBvLmNvbnN0cnVjdG9yLm5hbWU7IGlmIChuID09PSBcIk1hcFwiIHx8IG4gPT09IFwiU2V0XCIpIHJldHVybiBBcnJheS5mcm9tKG8pOyBpZiAobiA9PT0gXCJBcmd1bWVudHNcIiB8fCAvXig/OlVpfEkpbnQoPzo4fDE2fDMyKSg/OkNsYW1wZWQpP0FycmF5JC8udGVzdChuKSkgcmV0dXJuIFN0b2NodnVlX3R5cGVfc2NyaXB0X2xhbmdfanNfYXJyYXlMaWtlVG9BcnJheShvLCBtaW5MZW4pOyB9XG5cbmZ1bmN0aW9uIFN0b2NodnVlX3R5cGVfc2NyaXB0X2xhbmdfanNfYXJyYXlMaWtlVG9BcnJheShhcnIsIGxlbikgeyBpZiAobGVuID09IG51bGwgfHwgbGVuID4gYXJyLmxlbmd0aCkgbGVuID0gYXJyLmxlbmd0aDsgZm9yICh2YXIgaSA9IDAsIGFycjIgPSBuZXcgQXJyYXkobGVuKTsgaSA8IGxlbjsgaSsrKSB7IGFycjJbaV0gPSBhcnJbaV07IH0gcmV0dXJuIGFycjI7IH1cblxuXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIGNvbnN0IFN0b2NodnVlX3R5cGVfc2NyaXB0X2xhbmdfanNfID0gKHtcbiAgbmFtZTogJ1N0b2NoJyxcbiAgbWl4aW5zOiBbZXh0ZXJuYWxfdHJhZGluZ192dWVfanNfLk92ZXJsYXldLFxuICBtZXRob2RzOiB7XG4gICAgbWV0YV9pbmZvOiBmdW5jdGlvbiBtZXRhX2luZm8oKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBhdXRob3I6ICdTdGRTcXVhZCcsXG4gICAgICAgIHZlcnNpb246ICcxLjAuMCcsXG4gICAgICAgIGRlc2M6ICdTdG9jaGFzdGljJyxcbiAgICAgICAgcHJlc2V0OiB7XG4gICAgICAgICAgbmFtZTogJ1N0b2NoICRwYXJhbV9rICRwYXJhbV9kICRzbW9vdGgnLFxuICAgICAgICAgIHNpZGU6ICdvZmZjaGFydCcsXG4gICAgICAgICAgc2V0dGluZ3M6IHtcbiAgICAgICAgICAgIGxpbmVXaWR0aDogMC43NSxcbiAgICAgICAgICAgIGtDb2xvcjogJyMzNzgyZjInLFxuICAgICAgICAgICAgZENvbG9yOiAnI2Y0ODcwOScsXG4gICAgICAgICAgICBiYW5kQ29sb3I6ICcjZGRkJyxcbiAgICAgICAgICAgIGJhY2tDb2xvcjogJyMzODFlOWMxNidcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfSxcbiAgICBkcmF3OiBmdW5jdGlvbiBkcmF3KGN0eCkge1xuICAgICAgdmFyIGxheW91dCA9IHRoaXMuJHByb3BzLmxheW91dDtcbiAgICAgIHZhciB1cHBlciA9IGxheW91dC4kMnNjcmVlbih0aGlzLnNldHQudXBwZXIgfHwgODApO1xuICAgICAgdmFyIGxvd2VyID0gbGF5b3V0LiQyc2NyZWVuKHRoaXMuc2V0dC5sb3dlciB8fCAyMCk7IC8vIEtcblxuICAgICAgY3R4LmxpbmVXaWR0aCA9IHRoaXMubGluZV93aWR0aDtcbiAgICAgIGN0eC5zdHJva2VTdHlsZSA9IHRoaXMua19jb2xvcjtcbiAgICAgIGN0eC5iZWdpblBhdGgoKTtcblxuICAgICAgdmFyIF9pdGVyYXRvciA9IFN0b2NodnVlX3R5cGVfc2NyaXB0X2xhbmdfanNfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlcih0aGlzLiRwcm9wcy5kYXRhKSxcbiAgICAgICAgICBfc3RlcDtcblxuICAgICAgdHJ5IHtcbiAgICAgICAgZm9yIChfaXRlcmF0b3IucygpOyAhKF9zdGVwID0gX2l0ZXJhdG9yLm4oKSkuZG9uZTspIHtcbiAgICAgICAgICB2YXIgcCA9IF9zdGVwLnZhbHVlO1xuICAgICAgICAgIHZhciB4ID0gbGF5b3V0LnQyc2NyZWVuKHBbMF0pO1xuICAgICAgICAgIHZhciB5ID0gbGF5b3V0LiQyc2NyZWVuKHBbMV0pO1xuICAgICAgICAgIGN0eC5saW5lVG8oeCwgeSk7XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICBfaXRlcmF0b3IuZShlcnIpO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgX2l0ZXJhdG9yLmYoKTtcbiAgICAgIH1cblxuICAgICAgY3R4LnN0cm9rZSgpOyAvLyBEXG5cbiAgICAgIGN0eC5saW5lV2lkdGggPSB0aGlzLmxpbmVfd2lkdGg7XG4gICAgICBjdHguc3Ryb2tlU3R5bGUgPSB0aGlzLmRfY29sb3I7XG4gICAgICBjdHguYmVnaW5QYXRoKCk7XG5cbiAgICAgIHZhciBfaXRlcmF0b3IyID0gU3RvY2h2dWVfdHlwZV9zY3JpcHRfbGFuZ19qc19jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyKHRoaXMuJHByb3BzLmRhdGEpLFxuICAgICAgICAgIF9zdGVwMjtcblxuICAgICAgdHJ5IHtcbiAgICAgICAgZm9yIChfaXRlcmF0b3IyLnMoKTsgIShfc3RlcDIgPSBfaXRlcmF0b3IyLm4oKSkuZG9uZTspIHtcbiAgICAgICAgICB2YXIgcCA9IF9zdGVwMi52YWx1ZTtcblxuICAgICAgICAgIHZhciBfeCA9IGxheW91dC50MnNjcmVlbihwWzBdKTtcblxuICAgICAgICAgIHZhciBfeSA9IGxheW91dC4kMnNjcmVlbihwWzJdKTtcblxuICAgICAgICAgIGN0eC5saW5lVG8oX3gsIF95KTtcbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIF9pdGVyYXRvcjIuZShlcnIpO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgX2l0ZXJhdG9yMi5mKCk7XG4gICAgICB9XG5cbiAgICAgIGN0eC5zdHJva2UoKTtcbiAgICAgIGN0eC5zdHJva2VTdHlsZSA9IHRoaXMuYmFuZF9jb2xvcjtcbiAgICAgIGN0eC5zZXRMaW5lRGFzaChbNV0pOyAvLyBXaWxsIGJlIHJlbW92ZWQgYWZ0ZXIgZHJhdygpXG5cbiAgICAgIGN0eC5iZWdpblBhdGgoKTsgLy8gRmlsbCB0aGUgYXJlYSBiZXR3ZWVuIHRoZSBiYW5kc1xuXG4gICAgICBjdHguZmlsbFN0eWxlID0gdGhpcy5iYWNrX2NvbG9yO1xuICAgICAgY3R4LmZpbGxSZWN0KDAsIHVwcGVyLCBsYXlvdXQud2lkdGgsIGxvd2VyIC0gdXBwZXIpOyAvLyBVcHBlciBiYW5kXG5cbiAgICAgIGN0eC5tb3ZlVG8oMCwgdXBwZXIpO1xuICAgICAgY3R4LmxpbmVUbyhsYXlvdXQud2lkdGgsIHVwcGVyKTsgLy8gTG93ZXIgYmFuZFxuXG4gICAgICBjdHgubW92ZVRvKDAsIGxvd2VyKTtcbiAgICAgIGN0eC5saW5lVG8obGF5b3V0LndpZHRoLCBsb3dlcik7XG4gICAgICBjdHguc3Ryb2tlKCk7XG4gICAgfSxcbiAgICB1c2VfZm9yOiBmdW5jdGlvbiB1c2VfZm9yKCkge1xuICAgICAgcmV0dXJuIFsnU3RvY2gnXTtcbiAgICB9LFxuICAgIGRhdGFfY29sb3JzOiBmdW5jdGlvbiBkYXRhX2NvbG9ycygpIHtcbiAgICAgIHJldHVybiBbdGhpcy5jb2xvcl07XG4gICAgfSxcbiAgICB5X3JhbmdlOiBmdW5jdGlvbiB5X3JhbmdlKGhpLCBsbykge1xuICAgICAgcmV0dXJuIFtNYXRoLm1heChoaSwgdGhpcy5zZXR0LnVwcGVyIHx8IDgwKSwgTWF0aC5taW4obG8sIHRoaXMuc2V0dC5sb3dlciB8fCAyMCldO1xuICAgIH0sXG4gICAgY2FsYzogZnVuY3Rpb24gY2FsYygpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHByb3BzOiB7XG4gICAgICAgICAgcGFyYW1fazoge1xuICAgICAgICAgICAgZGVmOiAxNCxcbiAgICAgICAgICAgIHRleHQ6ICdLJ1xuICAgICAgICAgIH0sXG4gICAgICAgICAgcGFyYW1fZDoge1xuICAgICAgICAgICAgZGVmOiAzLFxuICAgICAgICAgICAgdGV4dDogJ0QnXG4gICAgICAgICAgfSxcbiAgICAgICAgICBzbW9vdGg6IHtcbiAgICAgICAgICAgIGRlZjogMyxcbiAgICAgICAgICAgIHRleHQ6ICdTbW9vdGgnXG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB1cGRhdGU6IFwiXFxuICAgICAgICAgICAgICAgICAgICBsZXQgayA9IHNtYShzdG9jaChjbG9zZSwgaGlnaCwgbG93LCBwYXJhbV9rKSwgc21vb3RoKVxcbiAgICAgICAgICAgICAgICAgICAgbGV0IGQgPSBzbWEoaywgcGFyYW1fZClcXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBba1swXSwgZFswXV1cXG4gICAgICAgICAgICAgICAgXCJcbiAgICAgIH07XG4gICAgfVxuICB9LFxuICBjb21wdXRlZDoge1xuICAgIHNldHQ6IGZ1bmN0aW9uIHNldHQoKSB7XG4gICAgICByZXR1cm4gdGhpcy4kcHJvcHMuc2V0dGluZ3M7XG4gICAgfSxcbiAgICBsaW5lX3dpZHRoOiBmdW5jdGlvbiBsaW5lX3dpZHRoKCkge1xuICAgICAgcmV0dXJuIHRoaXMuc2V0dC5saW5lV2lkdGggfHwgMC43NTtcbiAgICB9LFxuICAgIGtfY29sb3I6IGZ1bmN0aW9uIGtfY29sb3IoKSB7XG4gICAgICByZXR1cm4gdGhpcy5zZXR0LmtDb2xvciB8fCAnIzM3ODJmMic7XG4gICAgfSxcbiAgICBkX2NvbG9yOiBmdW5jdGlvbiBkX2NvbG9yKCkge1xuICAgICAgcmV0dXJuIHRoaXMuc2V0dC5kQ29sb3IgfHwgJyNmNDg3MDknO1xuICAgIH0sXG4gICAgYmFuZF9jb2xvcjogZnVuY3Rpb24gYmFuZF9jb2xvcigpIHtcbiAgICAgIHJldHVybiB0aGlzLnNldHQuYmFuZENvbG9yIHx8ICcjZGRkJztcbiAgICB9LFxuICAgIGJhY2tfY29sb3I6IGZ1bmN0aW9uIGJhY2tfY29sb3IoKSB7XG4gICAgICByZXR1cm4gdGhpcy5zZXR0LmJhY2tDb2xvciB8fCAnIzM4MWU5YzE2JztcbiAgICB9XG4gIH1cbn0pO1xuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL292ZXJsYXlzL1N0b2NoL1N0b2NoLnZ1ZT92dWUmdHlwZT1zY3JpcHQmbGFuZz1qcyZcbiAvKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIGNvbnN0IFN0b2NoX1N0b2NodnVlX3R5cGVfc2NyaXB0X2xhbmdfanNfID0gKFN0b2NodnVlX3R5cGVfc2NyaXB0X2xhbmdfanNfKTsgXG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvb3ZlcmxheXMvU3RvY2gvU3RvY2gudnVlXG52YXIgU3RvY2hfcmVuZGVyLCBTdG9jaF9zdGF0aWNSZW5kZXJGbnNcbjtcblxuXG5cbi8qIG5vcm1hbGl6ZSBjb21wb25lbnQgKi9cbjtcbnZhciBTdG9jaF9jb21wb25lbnQgPSBub3JtYWxpemVDb21wb25lbnQoXG4gIFN0b2NoX1N0b2NodnVlX3R5cGVfc2NyaXB0X2xhbmdfanNfLFxuICBTdG9jaF9yZW5kZXIsXG4gIFN0b2NoX3N0YXRpY1JlbmRlckZucyxcbiAgZmFsc2UsXG4gIG51bGwsXG4gIG51bGwsXG4gIG51bGxcbiAgXG4pXG5cbi8qIGhvdCByZWxvYWQgKi9cbmlmIChmYWxzZSkgeyB2YXIgU3RvY2hfYXBpOyB9XG5TdG9jaF9jb21wb25lbnQub3B0aW9ucy5fX2ZpbGUgPSBcInNyYy9vdmVybGF5cy9TdG9jaC9TdG9jaC52dWVcIlxuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyBjb25zdCBTdG9jaCA9IChTdG9jaF9jb21wb25lbnQuZXhwb3J0cyk7XG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9ub2RlX21vZHVsZXMvYmFiZWwtbG9hZGVyL2xpYi9pbmRleC5qcyEuL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9pbmRleC5qcz8/dnVlLWxvYWRlci1vcHRpb25zIS4vc3JjL292ZXJsYXlzL1RTSS9UU0kudnVlP3Z1ZSZ0eXBlPXNjcmlwdCZsYW5nPWpzJlxuXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIGNvbnN0IFRTSXZ1ZV90eXBlX3NjcmlwdF9sYW5nX2pzXyA9ICh7XG4gIG5hbWU6ICdUU0knLFxuICBtaXhpbnM6IFtleHRlcm5hbF90cmFkaW5nX3Z1ZV9qc18uT3ZlcmxheV0sXG4gIG1ldGhvZHM6IHtcbiAgICBtZXRhX2luZm86IGZ1bmN0aW9uIG1ldGFfaW5mbygpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGF1dGhvcjogJ1N0ZFNxdWFkJyxcbiAgICAgICAgdmVyc2lvbjogJzEuMC4wJyxcbiAgICAgICAgZGVzYzogJ1RydWUgU3RyZW5ndGggSW5kZXgnLFxuICAgICAgICBwcmVzZXQ6IHtcbiAgICAgICAgICBuYW1lOiAnVFNJICRsb25nICRzaG9ydCAkc2lnbmFsJyxcbiAgICAgICAgICBzaWRlOiAnb2ZmY2hhcnQnLFxuICAgICAgICAgIHNldHRpbmdzOiB7XG4gICAgICAgICAgICBsaW5lV2lkdGg6IDAuNzUsXG4gICAgICAgICAgICBjb2xvcnM6IFtcIiMzYmIzZTRcIiwgXCIjZjcwNDZkXCJdXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9O1xuICAgIH0sXG4gICAgdXNlX2ZvcjogZnVuY3Rpb24gdXNlX2ZvcigpIHtcbiAgICAgIHJldHVybiBbJ1RTSSddO1xuICAgIH0sXG4gICAgY2FsYzogZnVuY3Rpb24gY2FsYygpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHByb3BzOiB7XG4gICAgICAgICAgXCJsb25nXCI6IHtcbiAgICAgICAgICAgIGRlZjogMjUsXG4gICAgICAgICAgICB0ZXh0OiAnTG9uZyBMZW5ndGgnXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcInNob3J0XCI6IHtcbiAgICAgICAgICAgIGRlZjogMTMsXG4gICAgICAgICAgICB0ZXh0OiAnU2hvcnQgTGVuZ3RoJ1xuICAgICAgICAgIH0sXG4gICAgICAgICAgc2lnbmFsOiB7XG4gICAgICAgICAgICBkZWY6IDEzLFxuICAgICAgICAgICAgdGV4dDogJ1NpZ25hbCBMZW5ndGgnXG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBjb25mOiB7XG4gICAgICAgICAgcmVuZGVyZXI6ICdTcGxpbmVzJ1xuICAgICAgICB9LFxuICAgICAgICB1cGRhdGU6IFwiXFxuICAgICAgICAgICAgICAgICAgICBsZXQgdmFsID0gdHNpKGNsb3NlLCBzaG9ydCwgbG9uZylcXG4gICAgICAgICAgICAgICAgICAgIGxldCBzaWcgPSBlbWEodmFsLCBzaWduYWwpXFxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gW3ZhbFswXSAqIDEwMCwgc2lnWzBdICogMTAwXVxcbiAgICAgICAgICAgICAgICBcIlxuICAgICAgfTtcbiAgICB9XG4gIH1cbn0pO1xuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL292ZXJsYXlzL1RTSS9UU0kudnVlP3Z1ZSZ0eXBlPXNjcmlwdCZsYW5nPWpzJlxuIC8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gY29uc3QgVFNJX1RTSXZ1ZV90eXBlX3NjcmlwdF9sYW5nX2pzXyA9IChUU0l2dWVfdHlwZV9zY3JpcHRfbGFuZ19qc18pOyBcbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9vdmVybGF5cy9UU0kvVFNJLnZ1ZVxudmFyIFRTSV9yZW5kZXIsIFRTSV9zdGF0aWNSZW5kZXJGbnNcbjtcblxuXG5cbi8qIG5vcm1hbGl6ZSBjb21wb25lbnQgKi9cbjtcbnZhciBUU0lfY29tcG9uZW50ID0gbm9ybWFsaXplQ29tcG9uZW50KFxuICBUU0lfVFNJdnVlX3R5cGVfc2NyaXB0X2xhbmdfanNfLFxuICBUU0lfcmVuZGVyLFxuICBUU0lfc3RhdGljUmVuZGVyRm5zLFxuICBmYWxzZSxcbiAgbnVsbCxcbiAgbnVsbCxcbiAgbnVsbFxuICBcbilcblxuLyogaG90IHJlbG9hZCAqL1xuaWYgKGZhbHNlKSB7IHZhciBUU0lfYXBpOyB9XG5UU0lfY29tcG9uZW50Lm9wdGlvbnMuX19maWxlID0gXCJzcmMvb3ZlcmxheXMvVFNJL1RTSS52dWVcIlxuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyBjb25zdCBUU0kgPSAoVFNJX2NvbXBvbmVudC5leHBvcnRzKTtcbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL25vZGVfbW9kdWxlcy9iYWJlbC1sb2FkZXIvbGliL2luZGV4LmpzIS4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL2luZGV4LmpzPz92dWUtbG9hZGVyLW9wdGlvbnMhLi9zcmMvb3ZlcmxheXMvVHJhZGVzUGx1cy9UcmFkZXNQbHVzLnZ1ZT92dWUmdHlwZT1zY3JpcHQmbGFuZz1qcyZcbmZ1bmN0aW9uIFRyYWRlc1BsdXN2dWVfdHlwZV9zY3JpcHRfbGFuZ19qc19jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyKG8sIGFsbG93QXJyYXlMaWtlKSB7IHZhciBpdCA9IHR5cGVvZiBTeW1ib2wgIT09IFwidW5kZWZpbmVkXCIgJiYgb1tTeW1ib2wuaXRlcmF0b3JdIHx8IG9bXCJAQGl0ZXJhdG9yXCJdOyBpZiAoIWl0KSB7IGlmIChBcnJheS5pc0FycmF5KG8pIHx8IChpdCA9IFRyYWRlc1BsdXN2dWVfdHlwZV9zY3JpcHRfbGFuZ19qc191bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheShvKSkgfHwgYWxsb3dBcnJheUxpa2UgJiYgbyAmJiB0eXBlb2Ygby5sZW5ndGggPT09IFwibnVtYmVyXCIpIHsgaWYgKGl0KSBvID0gaXQ7IHZhciBpID0gMDsgdmFyIEYgPSBmdW5jdGlvbiBGKCkge307IHJldHVybiB7IHM6IEYsIG46IGZ1bmN0aW9uIG4oKSB7IGlmIChpID49IG8ubGVuZ3RoKSByZXR1cm4geyBkb25lOiB0cnVlIH07IHJldHVybiB7IGRvbmU6IGZhbHNlLCB2YWx1ZTogb1tpKytdIH07IH0sIGU6IGZ1bmN0aW9uIGUoX2UpIHsgdGhyb3cgX2U7IH0sIGY6IEYgfTsgfSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiSW52YWxpZCBhdHRlbXB0IHRvIGl0ZXJhdGUgbm9uLWl0ZXJhYmxlIGluc3RhbmNlLlxcbkluIG9yZGVyIHRvIGJlIGl0ZXJhYmxlLCBub24tYXJyYXkgb2JqZWN0cyBtdXN0IGhhdmUgYSBbU3ltYm9sLml0ZXJhdG9yXSgpIG1ldGhvZC5cIik7IH0gdmFyIG5vcm1hbENvbXBsZXRpb24gPSB0cnVlLCBkaWRFcnIgPSBmYWxzZSwgZXJyOyByZXR1cm4geyBzOiBmdW5jdGlvbiBzKCkgeyBpdCA9IGl0LmNhbGwobyk7IH0sIG46IGZ1bmN0aW9uIG4oKSB7IHZhciBzdGVwID0gaXQubmV4dCgpOyBub3JtYWxDb21wbGV0aW9uID0gc3RlcC5kb25lOyByZXR1cm4gc3RlcDsgfSwgZTogZnVuY3Rpb24gZShfZTIpIHsgZGlkRXJyID0gdHJ1ZTsgZXJyID0gX2UyOyB9LCBmOiBmdW5jdGlvbiBmKCkgeyB0cnkgeyBpZiAoIW5vcm1hbENvbXBsZXRpb24gJiYgaXRbXCJyZXR1cm5cIl0gIT0gbnVsbCkgaXRbXCJyZXR1cm5cIl0oKTsgfSBmaW5hbGx5IHsgaWYgKGRpZEVycikgdGhyb3cgZXJyOyB9IH0gfTsgfVxuXG5mdW5jdGlvbiBUcmFkZXNQbHVzdnVlX3R5cGVfc2NyaXB0X2xhbmdfanNfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkobywgbWluTGVuKSB7IGlmICghbykgcmV0dXJuOyBpZiAodHlwZW9mIG8gPT09IFwic3RyaW5nXCIpIHJldHVybiBUcmFkZXNQbHVzdnVlX3R5cGVfc2NyaXB0X2xhbmdfanNfYXJyYXlMaWtlVG9BcnJheShvLCBtaW5MZW4pOyB2YXIgbiA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvKS5zbGljZSg4LCAtMSk7IGlmIChuID09PSBcIk9iamVjdFwiICYmIG8uY29uc3RydWN0b3IpIG4gPSBvLmNvbnN0cnVjdG9yLm5hbWU7IGlmIChuID09PSBcIk1hcFwiIHx8IG4gPT09IFwiU2V0XCIpIHJldHVybiBBcnJheS5mcm9tKG8pOyBpZiAobiA9PT0gXCJBcmd1bWVudHNcIiB8fCAvXig/OlVpfEkpbnQoPzo4fDE2fDMyKSg/OkNsYW1wZWQpP0FycmF5JC8udGVzdChuKSkgcmV0dXJuIFRyYWRlc1BsdXN2dWVfdHlwZV9zY3JpcHRfbGFuZ19qc19hcnJheUxpa2VUb0FycmF5KG8sIG1pbkxlbik7IH1cblxuZnVuY3Rpb24gVHJhZGVzUGx1c3Z1ZV90eXBlX3NjcmlwdF9sYW5nX2pzX2FycmF5TGlrZVRvQXJyYXkoYXJyLCBsZW4pIHsgaWYgKGxlbiA9PSBudWxsIHx8IGxlbiA+IGFyci5sZW5ndGgpIGxlbiA9IGFyci5sZW5ndGg7IGZvciAodmFyIGkgPSAwLCBhcnIyID0gbmV3IEFycmF5KGxlbik7IGkgPCBsZW47IGkrKykgeyBhcnIyW2ldID0gYXJyW2ldOyB9IHJldHVybiBhcnIyOyB9XG5cblxudmFyIENST1NTID0gXCJtNTEyLjAwMSA4NC44NTMtODQuODUzLTg0Ljg1My0xNzEuMTQ3IDE3MS4xNDctMTcxLjE0OC0xNzEuMTQ3LTg0Ljg1M1xcbjg0Ljg1MyAxNzEuMTQ4IDE3MS4xNDctMTcxLjE0OCAxNzEuMTQ4IDg0Ljg1MyA4NC44NTMgMTcxLjE0OC0xNzEuMTQ3XFxuMTcxLjE0NyAxNzEuMTQ3IDg0Ljg1My04NC44NTMtMTcxLjE0OC0xNzEuMTQ4elwiO1xuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyBjb25zdCBUcmFkZXNQbHVzdnVlX3R5cGVfc2NyaXB0X2xhbmdfanNfID0gKHtcbiAgbmFtZTogJ1RyYWRlc1BsdXMnLFxuICBtaXhpbnM6IFtleHRlcm5hbF90cmFkaW5nX3Z1ZV9qc18uT3ZlcmxheV0sXG4gIG1ldGhvZHM6IHtcbiAgICBtZXRhX2luZm86IGZ1bmN0aW9uIG1ldGFfaW5mbygpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGF1dGhvcjogJ0M0NTEnLFxuICAgICAgICB2ZXJzaW9uOiAnMS4wLjEnLFxuICAgICAgICBkZXNjOiAnVHJhZGVzIG92ZXJsYXkgd2l0aCBzdG9wcydcbiAgICAgIH07XG4gICAgfSxcbiAgICBkcmF3OiBmdW5jdGlvbiBkcmF3KGN0eCkge1xuICAgICAgdmFyIGxheW91dCA9IHRoaXMuJHByb3BzLmxheW91dDtcbiAgICAgIGN0eC5zdHJva2VTdHlsZSA9ICdibGFjayc7XG5cbiAgICAgIHZhciBfaXRlcmF0b3IgPSBUcmFkZXNQbHVzdnVlX3R5cGVfc2NyaXB0X2xhbmdfanNfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlcih0aGlzLiRwcm9wcy5kYXRhKSxcbiAgICAgICAgICBfc3RlcDtcblxuICAgICAgdHJ5IHtcbiAgICAgICAgZm9yIChfaXRlcmF0b3IucygpOyAhKF9zdGVwID0gX2l0ZXJhdG9yLm4oKSkuZG9uZTspIHtcbiAgICAgICAgICB2YXIgcCA9IF9zdGVwLnZhbHVlO1xuICAgICAgICAgIGN0eC5maWxsU3R5bGUgPSBwWzFdID8gdGhpcy5idXlfY29sb3IgOiB0aGlzLnNlbGxfY29sb3I7XG4gICAgICAgICAgdmFyIHggPSBsYXlvdXQudDJzY3JlZW4ocFswXSk7IC8vIHggLSBNYXBwaW5nXG5cbiAgICAgICAgICB2YXIgeSA9IGxheW91dC4kMnNjcmVlbihwWzJdKTsgLy8geSAtIE1hcHBpbmdcblxuICAgICAgICAgIGlmIChwWzNdID09PSAnU3RvcCcpIHtcbiAgICAgICAgICAgIHRoaXMuZHJhd19jcm9zcyhjdHgsIHgsIHkpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmRyYXdfY2lyY2xlKGN0eCwgeCwgeSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKHRoaXMuc2hvd19sYWJlbCAmJiBwWzNdICYmIHBbM10gIT09ICdTdG9wJykge1xuICAgICAgICAgICAgdGhpcy5kcmF3X2xhYmVsKGN0eCwgeCwgeSwgcCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgX2l0ZXJhdG9yLmUoZXJyKTtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIF9pdGVyYXRvci5mKCk7XG4gICAgICB9XG4gICAgfSxcbiAgICBkcmF3X2xhYmVsOiBmdW5jdGlvbiBkcmF3X2xhYmVsKGN0eCwgeCwgeSwgcCkge1xuICAgICAgY3R4LmZpbGxTdHlsZSA9IHRoaXMubGFiZWxfY29sb3I7XG4gICAgICBjdHguZm9udCA9IHRoaXMubmV3X2ZvbnQ7XG4gICAgICBjdHgudGV4dEFsaWduID0gJ2NlbnRlcic7XG4gICAgICBjdHguZmlsbFRleHQocFszXSwgeCwgeSAtIDI1KTtcbiAgICB9LFxuICAgIGRyYXdfY2lyY2xlOiBmdW5jdGlvbiBkcmF3X2NpcmNsZShjdHgsIHgsIHkpIHtcbiAgICAgIGN0eC5saW5lV2lkdGggPSAxLjU7XG4gICAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgICBjdHguYXJjKHgsIHksIHRoaXMubWFya2VyX3NpemUgKyAwLjUsIDAsIE1hdGguUEkgKiAyLCB0cnVlKTtcbiAgICAgIGN0eC5maWxsKCk7XG4gICAgICBjdHguc3Ryb2tlKCk7XG4gICAgfSxcbiAgICBkcmF3X2Nyb3NzOiBmdW5jdGlvbiBkcmF3X2Nyb3NzKGN0eCwgeCwgeSkge1xuICAgICAgY3R4LnNhdmUoKTtcbiAgICAgIHZhciBwID0gbmV3IFBhdGgyRChDUk9TUyk7XG4gICAgICBjdHgubGluZVdpZHRoID0gMTUwO1xuICAgICAgY3R4LnRyYW5zbGF0ZSh4IC0gNSwgeSAtIDUpO1xuICAgICAgY3R4LnNjYWxlKDAuMDE3NSwgMC4wMTc1KTtcbiAgICAgIGN0eC5zdHJva2UocCk7XG4gICAgICBjdHguZmlsbChwKTtcbiAgICAgIGN0eC5zY2FsZSgxLCAxKTtcbiAgICAgIGN0eC5yZXN0b3JlKCk7XG4gICAgfSxcbiAgICB1c2VfZm9yOiBmdW5jdGlvbiB1c2VfZm9yKCkge1xuICAgICAgcmV0dXJuIFsnVHJhZGVzUGx1cyddO1xuICAgIH0sXG4gICAgLy8gRGVmaW5lcyBsZWdlbmQgZm9ybWF0ICh2YWx1ZXMgJiBjb2xvcnMpXG4gICAgbGVnZW5kOiBmdW5jdGlvbiBsZWdlbmQodmFsdWVzKSB7XG4gICAgICBzd2l0Y2ggKHZhbHVlc1sxXSkge1xuICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgdmFyIHBvcyA9ICdTZWxsJztcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgcG9zID0gJ0J1eSc7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICBwb3MgPSAnVW5rbm93bic7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBbe1xuICAgICAgICB2YWx1ZTogcG9zXG4gICAgICB9LCB7XG4gICAgICAgIHZhbHVlOiB2YWx1ZXNbMl0udG9GaXhlZCg0KSxcbiAgICAgICAgY29sb3I6IHRoaXMuJHByb3BzLmNvbG9ycy5jb2xvclRleHRcbiAgICAgIH1dLmNvbmNhdCh2YWx1ZXNbM10gPyBbe1xuICAgICAgICB2YWx1ZTogdmFsdWVzWzNdXG4gICAgICB9XSA6IFtdKTtcbiAgICB9XG4gIH0sXG4gIC8vIERlZmluZSBpbnRlcm5hbCBzZXR0aW5nICYgY29uc3RhbnRzIGhlcmVcbiAgY29tcHV0ZWQ6IHtcbiAgICBzZXR0OiBmdW5jdGlvbiBzZXR0KCkge1xuICAgICAgcmV0dXJuIHRoaXMuJHByb3BzLnNldHRpbmdzO1xuICAgIH0sXG4gICAgZGVmYXVsdF9mb250OiBmdW5jdGlvbiBkZWZhdWx0X2ZvbnQoKSB7XG4gICAgICByZXR1cm4gJzEycHggJyArIHRoaXMuJHByb3BzLmZvbnQuc3BsaXQoJ3B4JykucG9wKCk7XG4gICAgfSxcbiAgICBidXlfY29sb3I6IGZ1bmN0aW9uIGJ1eV9jb2xvcigpIHtcbiAgICAgIHJldHVybiB0aGlzLnNldHQuYnV5Q29sb3IgfHwgJyM2M2RmODknO1xuICAgIH0sXG4gICAgc2VsbF9jb2xvcjogZnVuY3Rpb24gc2VsbF9jb2xvcigpIHtcbiAgICAgIHJldHVybiB0aGlzLnNldHQuc2VsbENvbG9yIHx8ICcjZWM0NjYyJztcbiAgICB9LFxuICAgIGxhYmVsX2NvbG9yOiBmdW5jdGlvbiBsYWJlbF9jb2xvcigpIHtcbiAgICAgIHJldHVybiB0aGlzLnNldHQubGFiZWxDb2xvciB8fCB0aGlzLmNvbG9ycy50ZXh0O1xuICAgIH0sXG4gICAgbWFya2VyX3NpemU6IGZ1bmN0aW9uIG1hcmtlcl9zaXplKCkge1xuICAgICAgcmV0dXJuIHRoaXMuc2V0dC5tYXJrZXJTaXplIHx8IDU7XG4gICAgfSxcbiAgICBzaG93X2xhYmVsOiBmdW5jdGlvbiBzaG93X2xhYmVsKCkge1xuICAgICAgcmV0dXJuIHRoaXMuc2V0dC5zaG93TGFiZWwgIT09IGZhbHNlO1xuICAgIH0sXG4gICAgbmV3X2ZvbnQ6IGZ1bmN0aW9uIG5ld19mb250KCkge1xuICAgICAgcmV0dXJuIHRoaXMuc2V0dC5mb250IHx8IHRoaXMuZGVmYXVsdF9mb250O1xuICAgIH1cbiAgfVxufSk7XG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvb3ZlcmxheXMvVHJhZGVzUGx1cy9UcmFkZXNQbHVzLnZ1ZT92dWUmdHlwZT1zY3JpcHQmbGFuZz1qcyZcbiAvKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIGNvbnN0IFRyYWRlc1BsdXNfVHJhZGVzUGx1c3Z1ZV90eXBlX3NjcmlwdF9sYW5nX2pzXyA9IChUcmFkZXNQbHVzdnVlX3R5cGVfc2NyaXB0X2xhbmdfanNfKTsgXG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvb3ZlcmxheXMvVHJhZGVzUGx1cy9UcmFkZXNQbHVzLnZ1ZVxudmFyIFRyYWRlc1BsdXNfcmVuZGVyLCBUcmFkZXNQbHVzX3N0YXRpY1JlbmRlckZuc1xuO1xuXG5cblxuLyogbm9ybWFsaXplIGNvbXBvbmVudCAqL1xuO1xudmFyIFRyYWRlc1BsdXNfY29tcG9uZW50ID0gbm9ybWFsaXplQ29tcG9uZW50KFxuICBUcmFkZXNQbHVzX1RyYWRlc1BsdXN2dWVfdHlwZV9zY3JpcHRfbGFuZ19qc18sXG4gIFRyYWRlc1BsdXNfcmVuZGVyLFxuICBUcmFkZXNQbHVzX3N0YXRpY1JlbmRlckZucyxcbiAgZmFsc2UsXG4gIG51bGwsXG4gIG51bGwsXG4gIG51bGxcbiAgXG4pXG5cbi8qIGhvdCByZWxvYWQgKi9cbmlmIChmYWxzZSkgeyB2YXIgVHJhZGVzUGx1c19hcGk7IH1cblRyYWRlc1BsdXNfY29tcG9uZW50Lm9wdGlvbnMuX19maWxlID0gXCJzcmMvb3ZlcmxheXMvVHJhZGVzUGx1cy9UcmFkZXNQbHVzLnZ1ZVwiXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIGNvbnN0IFRyYWRlc1BsdXMgPSAoVHJhZGVzUGx1c19jb21wb25lbnQuZXhwb3J0cyk7XG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9ub2RlX21vZHVsZXMvYmFiZWwtbG9hZGVyL2xpYi9pbmRleC5qcyEuL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9pbmRleC5qcz8/dnVlLWxvYWRlci1vcHRpb25zIS4vc3JjL292ZXJsYXlzL1ZXTUEvVldNQS52dWU/dnVlJnR5cGU9c2NyaXB0Jmxhbmc9anMmXG5cbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gY29uc3QgVldNQXZ1ZV90eXBlX3NjcmlwdF9sYW5nX2pzXyA9ICh7XG4gIG5hbWU6ICdWV01BJyxcbiAgbWl4aW5zOiBbZXh0ZXJuYWxfdHJhZGluZ192dWVfanNfLk92ZXJsYXldLFxuICBtZXRob2RzOiB7XG4gICAgbWV0YV9pbmZvOiBmdW5jdGlvbiBtZXRhX2luZm8oKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBhdXRob3I6ICdTdGRTcXVhZCcsXG4gICAgICAgIHZlcnNpb246ICcxLjAuMCcsXG4gICAgICAgIGRlc2M6ICdWb2x1bWUgV2VpZ2h0ZWQgTW92aW5nIEF2ZXJhZ2UnLFxuICAgICAgICBwcmVzZXQ6IHtcbiAgICAgICAgICBuYW1lOiAnVldNQSAkbGVuZ3RoJyxcbiAgICAgICAgICBzaWRlOiAnb25jaGFydCcsXG4gICAgICAgICAgc2V0dGluZ3M6IHtcbiAgICAgICAgICAgIGxpbmVXaWR0aDogMC43NSxcbiAgICAgICAgICAgIGNvbG9yOiAnI2RiMDY3MCdcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfSxcbiAgICB1c2VfZm9yOiBmdW5jdGlvbiB1c2VfZm9yKCkge1xuICAgICAgcmV0dXJuIFsnVldNQSddO1xuICAgIH0sXG4gICAgY2FsYzogZnVuY3Rpb24gY2FsYygpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHByb3BzOiB7XG4gICAgICAgICAgbGVuZ3RoOiB7XG4gICAgICAgICAgICBkZWY6IDIwLFxuICAgICAgICAgICAgdGV4dDogJ0xlbmd0aCdcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIGNvbmY6IHtcbiAgICAgICAgICByZW5kZXJlcjogJ1NwbGluZSdcbiAgICAgICAgfSxcbiAgICAgICAgdXBkYXRlOiBcIlxcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHZ3bWEoY2xvc2UsIGxlbmd0aClbMF1cXG4gICAgICAgICAgICAgICAgXCJcbiAgICAgIH07XG4gICAgfVxuICB9XG59KTtcbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9vdmVybGF5cy9WV01BL1ZXTUEudnVlP3Z1ZSZ0eXBlPXNjcmlwdCZsYW5nPWpzJlxuIC8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gY29uc3QgVldNQV9WV01BdnVlX3R5cGVfc2NyaXB0X2xhbmdfanNfID0gKFZXTUF2dWVfdHlwZV9zY3JpcHRfbGFuZ19qc18pOyBcbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9vdmVybGF5cy9WV01BL1ZXTUEudnVlXG52YXIgVldNQV9yZW5kZXIsIFZXTUFfc3RhdGljUmVuZGVyRm5zXG47XG5cblxuXG4vKiBub3JtYWxpemUgY29tcG9uZW50ICovXG47XG52YXIgVldNQV9jb21wb25lbnQgPSBub3JtYWxpemVDb21wb25lbnQoXG4gIFZXTUFfVldNQXZ1ZV90eXBlX3NjcmlwdF9sYW5nX2pzXyxcbiAgVldNQV9yZW5kZXIsXG4gIFZXTUFfc3RhdGljUmVuZGVyRm5zLFxuICBmYWxzZSxcbiAgbnVsbCxcbiAgbnVsbCxcbiAgbnVsbFxuICBcbilcblxuLyogaG90IHJlbG9hZCAqL1xuaWYgKGZhbHNlKSB7IHZhciBWV01BX2FwaTsgfVxuVldNQV9jb21wb25lbnQub3B0aW9ucy5fX2ZpbGUgPSBcInNyYy9vdmVybGF5cy9WV01BL1ZXTUEudnVlXCJcbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gY29uc3QgVldNQSA9IChWV01BX2NvbXBvbmVudC5leHBvcnRzKTtcbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL25vZGVfbW9kdWxlcy9iYWJlbC1sb2FkZXIvbGliL2luZGV4LmpzIS4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL2luZGV4LmpzPz92dWUtbG9hZGVyLW9wdGlvbnMhLi9zcmMvb3ZlcmxheXMvV2lsbGlhbXNSL1dpbGxpYW1zUi52dWU/dnVlJnR5cGU9c2NyaXB0Jmxhbmc9anMmXG5cbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gY29uc3QgV2lsbGlhbXNSdnVlX3R5cGVfc2NyaXB0X2xhbmdfanNfID0gKHtcbiAgbmFtZTogJ1dpbGxpYW1zUicsXG4gIG1peGluczogW2V4dGVybmFsX3RyYWRpbmdfdnVlX2pzXy5PdmVybGF5XSxcbiAgbWV0aG9kczoge1xuICAgIG1ldGFfaW5mbzogZnVuY3Rpb24gbWV0YV9pbmZvKCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgYXV0aG9yOiAnU3RkU3F1YWQnLFxuICAgICAgICB2ZXJzaW9uOiAnMS4wLjAnLFxuICAgICAgICBkZXNjOiAnV2lsbGlhbXMgJVInLFxuICAgICAgICBwcmVzZXQ6IHtcbiAgICAgICAgICBuYW1lOiAnJVIgJGxlbmd0aCcsXG4gICAgICAgICAgc2lkZTogJ29mZmNoYXJ0JyxcbiAgICAgICAgICBzZXR0aW5nczoge1xuICAgICAgICAgICAgbGluZVdpZHRoOiAwLjc1LFxuICAgICAgICAgICAgY29sb3I6ICcjMDk4MGU4JyxcbiAgICAgICAgICAgIGJhbmRDb2xvcjogJyNhYWEnLFxuICAgICAgICAgICAgYmFja0NvbG9yOiAnIzliOWJhMzE2JyxcbiAgICAgICAgICAgIHVwcGVyOiAtMjAsXG4gICAgICAgICAgICBsb3dlcjogLTgwXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9O1xuICAgIH0sXG4gICAgdXNlX2ZvcjogZnVuY3Rpb24gdXNlX2ZvcigpIHtcbiAgICAgIHJldHVybiBbJ1dpbGxpYW1zUiddO1xuICAgIH0sXG4gICAgY2FsYzogZnVuY3Rpb24gY2FsYygpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHByb3BzOiB7XG4gICAgICAgICAgbGVuZ3RoOiB7XG4gICAgICAgICAgICBkZWY6IDE0LFxuICAgICAgICAgICAgdGV4dDogJ0xlbmd0aCdcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIGNvbmY6IHtcbiAgICAgICAgICByZW5kZXJlcjogJ1JhbmdlJ1xuICAgICAgICB9LFxuICAgICAgICB1cGRhdGU6IFwiXFxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gd3ByKGxlbmd0aClbMF1cXG4gICAgICAgICAgICAgICAgXCJcbiAgICAgIH07XG4gICAgfVxuICB9XG59KTtcbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9vdmVybGF5cy9XaWxsaWFtc1IvV2lsbGlhbXNSLnZ1ZT92dWUmdHlwZT1zY3JpcHQmbGFuZz1qcyZcbiAvKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIGNvbnN0IFdpbGxpYW1zUl9XaWxsaWFtc1J2dWVfdHlwZV9zY3JpcHRfbGFuZ19qc18gPSAoV2lsbGlhbXNSdnVlX3R5cGVfc2NyaXB0X2xhbmdfanNfKTsgXG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvb3ZlcmxheXMvV2lsbGlhbXNSL1dpbGxpYW1zUi52dWVcbnZhciBXaWxsaWFtc1JfcmVuZGVyLCBXaWxsaWFtc1Jfc3RhdGljUmVuZGVyRm5zXG47XG5cblxuXG4vKiBub3JtYWxpemUgY29tcG9uZW50ICovXG47XG52YXIgV2lsbGlhbXNSX2NvbXBvbmVudCA9IG5vcm1hbGl6ZUNvbXBvbmVudChcbiAgV2lsbGlhbXNSX1dpbGxpYW1zUnZ1ZV90eXBlX3NjcmlwdF9sYW5nX2pzXyxcbiAgV2lsbGlhbXNSX3JlbmRlcixcbiAgV2lsbGlhbXNSX3N0YXRpY1JlbmRlckZucyxcbiAgZmFsc2UsXG4gIG51bGwsXG4gIG51bGwsXG4gIG51bGxcbiAgXG4pXG5cbi8qIGhvdCByZWxvYWQgKi9cbmlmIChmYWxzZSkgeyB2YXIgV2lsbGlhbXNSX2FwaTsgfVxuV2lsbGlhbXNSX2NvbXBvbmVudC5vcHRpb25zLl9fZmlsZSA9IFwic3JjL292ZXJsYXlzL1dpbGxpYW1zUi9XaWxsaWFtc1IudnVlXCJcbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gY29uc3QgV2lsbGlhbXNSID0gKFdpbGxpYW1zUl9jb21wb25lbnQuZXhwb3J0cyk7XG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vYXJyYXlMaWtlVG9BcnJheS5qc1xuZnVuY3Rpb24gYXJyYXlMaWtlVG9BcnJheV9hcnJheUxpa2VUb0FycmF5KGFyciwgbGVuKSB7XG4gIGlmIChsZW4gPT0gbnVsbCB8fCBsZW4gPiBhcnIubGVuZ3RoKSBsZW4gPSBhcnIubGVuZ3RoO1xuXG4gIGZvciAodmFyIGkgPSAwLCBhcnIyID0gbmV3IEFycmF5KGxlbik7IGkgPCBsZW47IGkrKykge1xuICAgIGFycjJbaV0gPSBhcnJbaV07XG4gIH1cblxuICByZXR1cm4gYXJyMjtcbn1cbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9hcnJheVdpdGhvdXRIb2xlcy5qc1xuXG5mdW5jdGlvbiBfYXJyYXlXaXRob3V0SG9sZXMoYXJyKSB7XG4gIGlmIChBcnJheS5pc0FycmF5KGFycikpIHJldHVybiBhcnJheUxpa2VUb0FycmF5X2FycmF5TGlrZVRvQXJyYXkoYXJyKTtcbn1cbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9pdGVyYWJsZVRvQXJyYXkuanNcbmZ1bmN0aW9uIF9pdGVyYWJsZVRvQXJyYXkoaXRlcikge1xuICBpZiAodHlwZW9mIFN5bWJvbCAhPT0gXCJ1bmRlZmluZWRcIiAmJiBpdGVyW1N5bWJvbC5pdGVyYXRvcl0gIT0gbnVsbCB8fCBpdGVyW1wiQEBpdGVyYXRvclwiXSAhPSBudWxsKSByZXR1cm4gQXJyYXkuZnJvbShpdGVyKTtcbn1cbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheS5qc1xuXG5mdW5jdGlvbiB1bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheV91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheShvLCBtaW5MZW4pIHtcbiAgaWYgKCFvKSByZXR1cm47XG4gIGlmICh0eXBlb2YgbyA9PT0gXCJzdHJpbmdcIikgcmV0dXJuIGFycmF5TGlrZVRvQXJyYXlfYXJyYXlMaWtlVG9BcnJheShvLCBtaW5MZW4pO1xuICB2YXIgbiA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvKS5zbGljZSg4LCAtMSk7XG4gIGlmIChuID09PSBcIk9iamVjdFwiICYmIG8uY29uc3RydWN0b3IpIG4gPSBvLmNvbnN0cnVjdG9yLm5hbWU7XG4gIGlmIChuID09PSBcIk1hcFwiIHx8IG4gPT09IFwiU2V0XCIpIHJldHVybiBBcnJheS5mcm9tKG8pO1xuICBpZiAobiA9PT0gXCJBcmd1bWVudHNcIiB8fCAvXig/OlVpfEkpbnQoPzo4fDE2fDMyKSg/OkNsYW1wZWQpP0FycmF5JC8udGVzdChuKSkgcmV0dXJuIGFycmF5TGlrZVRvQXJyYXlfYXJyYXlMaWtlVG9BcnJheShvLCBtaW5MZW4pO1xufVxuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL25vbkl0ZXJhYmxlU3ByZWFkLmpzXG5mdW5jdGlvbiBfbm9uSXRlcmFibGVTcHJlYWQoKSB7XG4gIHRocm93IG5ldyBUeXBlRXJyb3IoXCJJbnZhbGlkIGF0dGVtcHQgdG8gc3ByZWFkIG5vbi1pdGVyYWJsZSBpbnN0YW5jZS5cXG5JbiBvcmRlciB0byBiZSBpdGVyYWJsZSwgbm9uLWFycmF5IG9iamVjdHMgbXVzdCBoYXZlIGEgW1N5bWJvbC5pdGVyYXRvcl0oKSBtZXRob2QuXCIpO1xufVxuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL3RvQ29uc3VtYWJsZUFycmF5LmpzXG5cblxuXG5cbmZ1bmN0aW9uIF90b0NvbnN1bWFibGVBcnJheShhcnIpIHtcbiAgcmV0dXJuIF9hcnJheVdpdGhvdXRIb2xlcyhhcnIpIHx8IF9pdGVyYWJsZVRvQXJyYXkoYXJyKSB8fCB1bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheV91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheShhcnIpIHx8IF9ub25JdGVyYWJsZVNwcmVhZCgpO1xufVxuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL2NsYXNzQ2FsbENoZWNrLmpzXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7XG4gIGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTtcbiAgfVxufVxuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL2NyZWF0ZUNsYXNzLmpzXG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldO1xuICAgIGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTtcbiAgICBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7XG4gICAgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7XG4gIH1cbn1cblxuZnVuY3Rpb24gX2NyZWF0ZUNsYXNzKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykge1xuICBpZiAocHJvdG9Qcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTtcbiAgaWYgKHN0YXRpY1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpO1xuICByZXR1cm4gQ29uc3RydWN0b3I7XG59XG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvb3ZlcmxheXMvWE9obGNCYXJzL3ByaW1pdGl2ZXMveG9obGNiYXIuanNcblxuXG5cbi8vIE9obGMgb2JqZWN0IGZvciBPaGxjcyBvdmVybGF5XG52YXIgWE9obGNCYXIgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBYT2hsY0JhcihvdmVybGF5LCBjdHgsIGRhdGEpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgWE9obGNCYXIpO1xuXG4gICAgdGhpcy5jdHggPSBjdHg7XG4gICAgdGhpcy5zZWxmID0gb3ZlcmxheTtcbiAgICB0aGlzLnN0eWxlID0gZGF0YS5yYXdbNl0gfHwgdGhpcy5zZWxmO1xuXG4gICAgdGhpcy5fZHJhdyhkYXRhKTtcbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhYT2hsY0JhciwgW3tcbiAgICBrZXk6IFwiX2RyYXdcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2RyYXcoZGF0YSkge1xuICAgICAgdmFyIGxpbmVfd2lkdGggPSB0aGlzLnN0eWxlLmxpbmVXaWR0aDtcbiAgICAgIHZhciBobGNfb25seSA9IHRoaXMuc3R5bGUuY2hhcnRUeXBlID09IFwiSExDXCI7XG4gICAgICB2YXIgbGluZV93aWR0aF9oYWxmID0gbGluZV93aWR0aCAvIDI7IC8vIEJhciBjb2xvclxuXG4gICAgICB2YXIgYmFyX2NvbG9yID0gZGF0YS5jIDw9IGRhdGEubyA/IHRoaXMuc3R5bGUudXBCYXJDb2xvciA6IHRoaXMuc3R5bGUuZG93bkJhckNvbG9yO1xuICAgICAgdmFyIHdpZHRoID0gTWF0aC5tYXgoZGF0YS53LCAxKTtcbiAgICAgIHZhciBoYWxmd2lkdGggPSBNYXRoLm1heChNYXRoLmZsb29yKHdpZHRoICogMC41KSwgMSk7XG4gICAgICB2YXIgaGVpZ2h0ID0gTWF0aC5hYnMoZGF0YS5vIC0gZGF0YS5jKTtcbiAgICAgIHZhciBtYXhfaCA9IGRhdGEuYyA9PT0gZGF0YS5vID8gMSA6IDI7XG4gICAgICB2YXIgcyA9IGxpbmVfd2lkdGggJSAyID09PSAwID8gMCA6IDAuNTsgLy8gRHJhdyB0aGUgbGluZSBmcm9tIGxvdyB0byBoaWdoIGFuZCBvcGVuIGFuZCBjbG9zZSBhbHNvXG5cbiAgICAgIHRoaXMuY3R4LnN0cm9rZVN0eWxlID0gYmFyX2NvbG9yO1xuICAgICAgdGhpcy5jdHgubGluZVdpZHRoID0gbGluZV93aWR0aDtcbiAgICAgIHRoaXMuY3R4LmJlZ2luUGF0aCgpOyAvLyBEcmF3IGhpZ2ggdG8gbG93XG5cbiAgICAgIHRoaXMuY3R4Lm1vdmVUbyhNYXRoLmZsb29yKGRhdGEueCAtIGxpbmVfd2lkdGhfaGFsZikgKyBzLCBNYXRoLmZsb29yKGRhdGEuaCkpO1xuICAgICAgdGhpcy5jdHgubGluZVRvKE1hdGguZmxvb3IoZGF0YS54IC0gbGluZV93aWR0aF9oYWxmKSArIHMsIE1hdGguZmxvb3IoZGF0YS5sKSk7XG5cbiAgICAgIGlmICh3aWR0aCA+IDEpIHtcbiAgICAgICAgLy8gRHJhdyBvcGVuIG5vdGNoXG4gICAgICAgIGlmIChobGNfb25seSkge1xuICAgICAgICAgIC8vIE5vIG9wZW4gcHJpY2UgaW4gY29uc2lkZXJhdGlvblxuICAgICAgICAgIC8vIERyYXcgb3BlbiBub3RjaCB3aXRoIGNsb3NlIHByaWNlXG4gICAgICAgICAgdGhpcy5jdHgubW92ZVRvKE1hdGguZmxvb3IoZGF0YS54IC0gaGFsZndpZHRoIC0gbGluZV93aWR0aF9oYWxmIC0gMSksIE1hdGguZmxvb3IoZGF0YS5jKSAtIHMpO1xuICAgICAgICAgIHRoaXMuY3R4LmxpbmVUbyhNYXRoLmZsb29yKGRhdGEueCAtIGxpbmVfd2lkdGhfaGFsZiksIE1hdGguZmxvb3IoZGF0YS5jKSAtIHMpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIERyYXcgb3BlbiBub3RjaCB3aXRoIG9wZW4gcHJpY2VcbiAgICAgICAgICB0aGlzLmN0eC5tb3ZlVG8oTWF0aC5mbG9vcihkYXRhLnggLSBoYWxmd2lkdGggLSBsaW5lX3dpZHRoX2hhbGYgLSAxKSwgTWF0aC5mbG9vcihkYXRhLm8pIC0gcyk7XG4gICAgICAgICAgdGhpcy5jdHgubGluZVRvKE1hdGguZmxvb3IoZGF0YS54IC0gbGluZV93aWR0aF9oYWxmKSwgTWF0aC5mbG9vcihkYXRhLm8pIC0gcyk7XG4gICAgICAgIH0gLy8gRHJhdyBjbG9zZSBub3RjaFxuXG5cbiAgICAgICAgdGhpcy5jdHgubW92ZVRvKE1hdGguZmxvb3IoZGF0YS54IC0gbGluZV93aWR0aF9oYWxmKSwgTWF0aC5mbG9vcihkYXRhLmMpIC0gcyk7XG4gICAgICAgIHRoaXMuY3R4LmxpbmVUbyhNYXRoLmZsb29yKGRhdGEueCArIGhhbGZ3aWR0aCAtIGxpbmVfd2lkdGhfaGFsZiArIDEpLCBNYXRoLmZsb29yKGRhdGEuYykgLSBzKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5jdHguc3Ryb2tlKCk7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIFhPaGxjQmFyO1xufSgpO1xuXG5cbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9vdmVybGF5cy9YT2hsY0JhcnMvcHJpbWl0aXZlcy94dm9sYmFyLmpzXG5cblxuXG52YXIgWFZvbGJhciA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIFhWb2xiYXIob3ZlcmxheSwgY3R4LCBkYXRhLCBiYXJEYXRhLCB0aGluVm9sdW1lQmFyKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFhWb2xiYXIpO1xuXG4gICAgdGhpcy5jdHggPSBjdHg7XG4gICAgdGhpcy4kcCA9IG92ZXJsYXkuJHByb3BzO1xuICAgIHRoaXMuc2VsZiA9IG92ZXJsYXk7XG4gICAgdGhpcy5zdHlsZSA9IGRhdGEucmF3WzZdIHx8IHRoaXMuc2VsZjtcblxuICAgIHRoaXMuX2RyYXcoZGF0YSwgYmFyRGF0YSwgdGhpblZvbHVtZUJhcik7XG4gIH1cblxuICBfY3JlYXRlQ2xhc3MoWFZvbGJhciwgW3tcbiAgICBrZXk6IFwiX2RyYXdcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2RyYXcoZGF0YSwgYmFyRGF0YSwgdGhpblZvbHVtZUJhcikge1xuICAgICAgaWYgKHRoaW5Wb2x1bWVCYXIpIHtcbiAgICAgICAgLy8gVGhpbiBWb2x1bWUgQmFyXG4gICAgICAgIHZhciBiYXJfY29sb3IgPSBkYXRhLmdyZWVuID8gdGhpcy5zdHlsZS51cFZvbEJhckNvbG9yIDogdGhpcy5zdHlsZS5kb3duVm9sQmFyQ29sb3I7XG4gICAgICAgIHZhciBsaW5lX3dpZHRoID0gdGhpcy5zdHlsZS52b2xCYXJXaWR0aDtcbiAgICAgICAgdmFyIGxpbmVfd2lkdGhfaGFsZiA9IGxpbmVfd2lkdGggLyAyO1xuICAgICAgICB2YXIgeTAgPSB0aGlzLiRwLmxheW91dC5oZWlnaHQ7XG4gICAgICAgIHZhciB3ID0gZGF0YS54MiAtIGRhdGEueDE7XG4gICAgICAgIHZhciBoID0gTWF0aC5mbG9vcihkYXRhLmgpO1xuICAgICAgICB0aGlzLmN0eC5zdHJva2VTdHlsZSA9IGJhcl9jb2xvcjtcbiAgICAgICAgdGhpcy5jdHgubGluZVdpZHRoID0gbGluZV93aWR0aDtcbiAgICAgICAgdGhpcy5jdHguYmVnaW5QYXRoKCk7IC8vIERyYXcgaGlnaCB0byBsb3dcblxuICAgICAgICB0aGlzLmN0eC5tb3ZlVG8oTWF0aC5mbG9vcihiYXJEYXRhLnggLSBsaW5lX3dpZHRoX2hhbGYpLCBNYXRoLmZsb29yKHkwIC0gaCAtIDAuNSkpO1xuICAgICAgICB0aGlzLmN0eC5saW5lVG8oTWF0aC5mbG9vcihiYXJEYXRhLnggLSBsaW5lX3dpZHRoX2hhbGYpLCBNYXRoLmZsb29yKHkwICsgMC41KSk7XG4gICAgICAgIHRoaXMuY3R4LnN0cm9rZSgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gVGhpY2sgVm9sdW1lIEJhclxuICAgICAgICB2YXIgX3kgPSB0aGlzLiRwLmxheW91dC5oZWlnaHQ7XG5cbiAgICAgICAgdmFyIF93ID0gZGF0YS54MiAtIGRhdGEueDE7XG5cbiAgICAgICAgdmFyIF9oID0gTWF0aC5mbG9vcihkYXRhLmgpO1xuXG4gICAgICAgIHRoaXMuY3R4LmZpbGxTdHlsZSA9IGRhdGEuZ3JlZW4gPyB0aGlzLnN0eWxlLnVwVm9sQmFyQ29sb3IgOiB0aGlzLnN0eWxlLmRvd25Wb2xCYXJDb2xvcjtcbiAgICAgICAgdGhpcy5jdHguZmlsbFJlY3QoTWF0aC5mbG9vcihkYXRhLngxKSwgTWF0aC5mbG9vcihfeSAtIF9oIC0gMC41KSwgTWF0aC5mbG9vcihfdyksIE1hdGguZmxvb3IoX2ggKyAxKSk7XG4gICAgICB9XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIFhWb2xiYXI7XG59KCk7XG5cblxuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vbm9kZV9tb2R1bGVzL2JhYmVsLWxvYWRlci9saWIvaW5kZXguanMhLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvaW5kZXguanM/P3Z1ZS1sb2FkZXItb3B0aW9ucyEuL3NyYy9vdmVybGF5cy9YT2hsY0JhcnMvWE9obGNCYXJzLnZ1ZT92dWUmdHlwZT1zY3JpcHQmbGFuZz1qcyZcblxuXG5mdW5jdGlvbiBYT2hsY0JhcnN2dWVfdHlwZV9zY3JpcHRfbGFuZ19qc19jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyKG8sIGFsbG93QXJyYXlMaWtlKSB7IHZhciBpdCA9IHR5cGVvZiBTeW1ib2wgIT09IFwidW5kZWZpbmVkXCIgJiYgb1tTeW1ib2wuaXRlcmF0b3JdIHx8IG9bXCJAQGl0ZXJhdG9yXCJdOyBpZiAoIWl0KSB7IGlmIChBcnJheS5pc0FycmF5KG8pIHx8IChpdCA9IFhPaGxjQmFyc3Z1ZV90eXBlX3NjcmlwdF9sYW5nX2pzX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5KG8pKSB8fCBhbGxvd0FycmF5TGlrZSAmJiBvICYmIHR5cGVvZiBvLmxlbmd0aCA9PT0gXCJudW1iZXJcIikgeyBpZiAoaXQpIG8gPSBpdDsgdmFyIGkgPSAwOyB2YXIgRiA9IGZ1bmN0aW9uIEYoKSB7fTsgcmV0dXJuIHsgczogRiwgbjogZnVuY3Rpb24gbigpIHsgaWYgKGkgPj0gby5sZW5ndGgpIHJldHVybiB7IGRvbmU6IHRydWUgfTsgcmV0dXJuIHsgZG9uZTogZmFsc2UsIHZhbHVlOiBvW2krK10gfTsgfSwgZTogZnVuY3Rpb24gZShfZSkgeyB0aHJvdyBfZTsgfSwgZjogRiB9OyB9IHRocm93IG5ldyBUeXBlRXJyb3IoXCJJbnZhbGlkIGF0dGVtcHQgdG8gaXRlcmF0ZSBub24taXRlcmFibGUgaW5zdGFuY2UuXFxuSW4gb3JkZXIgdG8gYmUgaXRlcmFibGUsIG5vbi1hcnJheSBvYmplY3RzIG11c3QgaGF2ZSBhIFtTeW1ib2wuaXRlcmF0b3JdKCkgbWV0aG9kLlwiKTsgfSB2YXIgbm9ybWFsQ29tcGxldGlvbiA9IHRydWUsIGRpZEVyciA9IGZhbHNlLCBlcnI7IHJldHVybiB7IHM6IGZ1bmN0aW9uIHMoKSB7IGl0ID0gaXQuY2FsbChvKTsgfSwgbjogZnVuY3Rpb24gbigpIHsgdmFyIHN0ZXAgPSBpdC5uZXh0KCk7IG5vcm1hbENvbXBsZXRpb24gPSBzdGVwLmRvbmU7IHJldHVybiBzdGVwOyB9LCBlOiBmdW5jdGlvbiBlKF9lMikgeyBkaWRFcnIgPSB0cnVlOyBlcnIgPSBfZTI7IH0sIGY6IGZ1bmN0aW9uIGYoKSB7IHRyeSB7IGlmICghbm9ybWFsQ29tcGxldGlvbiAmJiBpdFtcInJldHVyblwiXSAhPSBudWxsKSBpdFtcInJldHVyblwiXSgpOyB9IGZpbmFsbHkgeyBpZiAoZGlkRXJyKSB0aHJvdyBlcnI7IH0gfSB9OyB9XG5cbmZ1bmN0aW9uIFhPaGxjQmFyc3Z1ZV90eXBlX3NjcmlwdF9sYW5nX2pzX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5KG8sIG1pbkxlbikgeyBpZiAoIW8pIHJldHVybjsgaWYgKHR5cGVvZiBvID09PSBcInN0cmluZ1wiKSByZXR1cm4gWE9obGNCYXJzdnVlX3R5cGVfc2NyaXB0X2xhbmdfanNfYXJyYXlMaWtlVG9BcnJheShvLCBtaW5MZW4pOyB2YXIgbiA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvKS5zbGljZSg4LCAtMSk7IGlmIChuID09PSBcIk9iamVjdFwiICYmIG8uY29uc3RydWN0b3IpIG4gPSBvLmNvbnN0cnVjdG9yLm5hbWU7IGlmIChuID09PSBcIk1hcFwiIHx8IG4gPT09IFwiU2V0XCIpIHJldHVybiBBcnJheS5mcm9tKG8pOyBpZiAobiA9PT0gXCJBcmd1bWVudHNcIiB8fCAvXig/OlVpfEkpbnQoPzo4fDE2fDMyKSg/OkNsYW1wZWQpP0FycmF5JC8udGVzdChuKSkgcmV0dXJuIFhPaGxjQmFyc3Z1ZV90eXBlX3NjcmlwdF9sYW5nX2pzX2FycmF5TGlrZVRvQXJyYXkobywgbWluTGVuKTsgfVxuXG5mdW5jdGlvbiBYT2hsY0JhcnN2dWVfdHlwZV9zY3JpcHRfbGFuZ19qc19hcnJheUxpa2VUb0FycmF5KGFyciwgbGVuKSB7IGlmIChsZW4gPT0gbnVsbCB8fCBsZW4gPiBhcnIubGVuZ3RoKSBsZW4gPSBhcnIubGVuZ3RoOyBmb3IgKHZhciBpID0gMCwgYXJyMiA9IG5ldyBBcnJheShsZW4pOyBpIDwgbGVuOyBpKyspIHsgYXJyMltpXSA9IGFycltpXTsgfSByZXR1cm4gYXJyMjsgfVxuXG4vLyBSZW5lZHJlciBmb3Igb2hsY2JhciArIHZvbHVtZSAob3B0aW9uYWwpXG4vLyBJdCBjYW4gYmUgdXNlZCBhcyB0aGUgbWFpbiBjaGFydCBvciBhbiBpbmRpY2F0b3JcblxuXG5cbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gY29uc3QgWE9obGNCYXJzdnVlX3R5cGVfc2NyaXB0X2xhbmdfanNfID0gKHtcbiAgbmFtZTogJ1hPaGxjQmFycycsXG4gIG1peGluczogW2V4dGVybmFsX3RyYWRpbmdfdnVlX2pzXy5PdmVybGF5XSxcbiAgbWV0aG9kczoge1xuICAgIG1ldGFfaW5mbzogZnVuY3Rpb24gbWV0YV9pbmZvKCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgYXV0aG9yOiAnWCcsXG4gICAgICAgIHZlcnNpb246ICcxLjMuMCcsXG4gICAgICAgIGRlc2M6ICdCYXIgQ2hhcnQnXG4gICAgICB9O1xuICAgIH0sXG4gICAgaW5pdDogZnVuY3Rpb24gaW5pdCgpIHsvL3RoaXMucHJpY2UgPSBuZXcgUHJpY2UodGhpcykgLy8gVE9ETzpcbiAgICB9LFxuICAgIGRyYXc6IGZ1bmN0aW9uIGRyYXcoY3R4KSB7XG4gICAgICAvL2NvbnNvbGUubG9nKFwiWE9obGNCYXIuZHJhdygpIGNhbGxlZC4gdGhpcy4kcHJvcHMuZGF0YS5sZW5ndGggPSBcIiArIHRoaXMuJHByb3BzLmRhdGEubGVuZ3RoKVxuICAgICAgLy8gcmVuZGVyIGFzIG1haW4gY2hhcnQ6XG4gICAgICBpZiAodGhpcy4kcHJvcHMuc3ViID09PSB0aGlzLiRwcm9wcy5kYXRhKSB7XG4gICAgICAgIHZhciBjbnYgPSB7XG4gICAgICAgICAgb2hsY2JhcnM6IHRoaXMuJHByb3BzLmxheW91dC5jYW5kbGVzLFxuICAgICAgICAgIHZvbHVtZTogdGhpcy4kcHJvcHMubGF5b3V0LnZvbHVtZVxuICAgICAgICB9OyAvLyBFbHNlLCBhcyBvZmZjaGFydCAvIG9uY2hhcnQgaW5kaWNhdG9yOlxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY252ID0gKDAsZXh0ZXJuYWxfdHJhZGluZ192dWVfanNfLmxheW91dF9jbnYpKHRoaXMpO1xuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5zaG93X3ZvbHVtZSkge1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNudi52b2x1bWUubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICB2YXIgdm9sdW1lRGF0YSA9IGNudi52b2x1bWVbaV07XG4gICAgICAgICAgdmFyIF9iYXJEYXRhID0gY252Lm9obGNiYXJzW2ldO1xuICAgICAgICAgIG5ldyBYVm9sYmFyKHRoaXMsIGN0eCwgdm9sdW1lRGF0YSwgX2JhckRhdGEpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHZhciBfaXRlcmF0b3IgPSBYT2hsY0JhcnN2dWVfdHlwZV9zY3JpcHRfbGFuZ19qc19jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyKGNudi5vaGxjYmFycyksXG4gICAgICAgICAgX3N0ZXA7XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIGZvciAoX2l0ZXJhdG9yLnMoKTsgIShfc3RlcCA9IF9pdGVyYXRvci5uKCkpLmRvbmU7KSB7XG4gICAgICAgICAgdmFyIGJhckRhdGEgPSBfc3RlcC52YWx1ZTtcbiAgICAgICAgICBuZXcgWE9obGNCYXIodGhpcywgY3R4LCBiYXJEYXRhKTtcbiAgICAgICAgfSAvL2lmICh0aGlzLnByaWNlX2xpbmUpIHRoaXMucHJpY2UuZHJhdyhjdHgpICAvLyBUT0RPOlxuXG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgX2l0ZXJhdG9yLmUoZXJyKTtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIF9pdGVyYXRvci5mKCk7XG4gICAgICB9XG4gICAgfSxcbiAgICB1c2VfZm9yOiBmdW5jdGlvbiB1c2VfZm9yKCkge1xuICAgICAgcmV0dXJuIFsnWE9obGNCYXJzJ107XG4gICAgfSxcbiAgICAvLyBXaGVuIGFkZGVkIGFzIG9mZmNoYXJ0IG92ZXJsYXlcbiAgICB5X3JhbmdlOiBmdW5jdGlvbiB5X3JhbmdlKCkge1xuICAgICAgcmV0dXJuIFtNYXRoLm1heC5hcHBseShNYXRoLCBfdG9Db25zdW1hYmxlQXJyYXkodGhpcy4kcHJvcHMuc3ViLm1hcChmdW5jdGlvbiAoeCkge1xuICAgICAgICByZXR1cm4geFsyXTtcbiAgICAgIH0pKSksIE1hdGgubWluLmFwcGx5KE1hdGgsIF90b0NvbnN1bWFibGVBcnJheSh0aGlzLiRwcm9wcy5zdWIubWFwKGZ1bmN0aW9uICh4KSB7XG4gICAgICAgIHJldHVybiB4WzNdO1xuICAgICAgfSkpKV07XG4gICAgfVxuICB9LFxuICAvLyBEZWZpbmUgaW50ZXJuYWwgc2V0dGluZyAmIGNvbnN0YW50cyBoZXJlXG4gIGNvbXB1dGVkOiB7XG4gICAgc2V0dDogZnVuY3Rpb24gc2V0dCgpIHtcbiAgICAgIHJldHVybiB0aGlzLiRwcm9wcy5zZXR0aW5ncztcbiAgICB9LFxuICAgIHNob3dfdm9sdW1lOiBmdW5jdGlvbiBzaG93X3ZvbHVtZSgpIHtcbiAgICAgIHJldHVybiAnc2hvd1ZvbHVtZScgaW4gdGhpcy5zZXR0ID8gdGhpcy5zZXR0LnNob3dWb2x1bWUgOiB0cnVlO1xuICAgIH0sXG4gICAgcHJpY2VfbGluZTogZnVuY3Rpb24gcHJpY2VfbGluZSgpIHtcbiAgICAgIHJldHVybiAncHJpY2VMaW5lJyBpbiB0aGlzLnNldHQgPyB0aGlzLnNldHQucHJpY2VMaW5lIDogdHJ1ZTtcbiAgICB9LFxuICAgIHVwVm9sQmFyQ29sb3I6IGZ1bmN0aW9uIHVwVm9sQmFyQ29sb3IoKSB7XG4gICAgICByZXR1cm4gdGhpcy5zZXR0LnVwQmFyQ29sb3IgfHwgXCIjMjNhNzc2NTVcIjtcbiAgICB9LFxuICAgIGRvd25Wb2xCYXJDb2xvcjogZnVuY3Rpb24gZG93blZvbEJhckNvbG9yKCkge1xuICAgICAgcmV0dXJuIHRoaXMuc2V0dC5kb3duQmFyQ29sb3IgfHwgXCIjZTU0MTUwNTVcIjtcbiAgICB9LFxuICAgIHZvbEJhcldpZHRoOiBmdW5jdGlvbiB2b2xCYXJXaWR0aCgpIHtcbiAgICAgIHJldHVybiB0aGlzLnNldHQuYmFyV2lkdGggfHwgMjtcbiAgICB9LFxuICAgIHVwQmFyQ29sb3I6IGZ1bmN0aW9uIHVwQmFyQ29sb3IoKSB7XG4gICAgICByZXR1cm4gdGhpcy5zZXR0LnVwQmFyQ29sb3IgfHwgXCIjMjNhNzc2XCI7XG4gICAgfSxcbiAgICBkb3duQmFyQ29sb3I6IGZ1bmN0aW9uIGRvd25CYXJDb2xvcigpIHtcbiAgICAgIHJldHVybiB0aGlzLnNldHQuZG93bkJhckNvbG9yIHx8IFwiI2U1NDE1MFwiO1xuICAgIH0sXG4gICAgYmFyV2lkdGg6IGZ1bmN0aW9uIGJhcldpZHRoKCkge1xuICAgICAgcmV0dXJuIHRoaXMuc2V0dC5iYXJXaWR0aCB8fCAxO1xuICAgIH0sXG4gICAgaGxjT25seTogZnVuY3Rpb24gaGxjT25seSgpIHtcbiAgICAgIHJldHVybiB0aGlzLnNldHQuaGxjT25seSB8fCBmYWxzZTtcbiAgICB9LFxuICAgIGxpbmVXaWR0aDogZnVuY3Rpb24gbGluZVdpZHRoKCkge1xuICAgICAgcmV0dXJuIHRoaXMuc2V0dC5saW5lV2lkdGggfHwgMTtcbiAgICB9XG4gIH0sXG4gIGRhdGE6IGZ1bmN0aW9uIGRhdGEoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHByaWNlOiB7fVxuICAgIH07XG4gIH1cbn0pO1xuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL292ZXJsYXlzL1hPaGxjQmFycy9YT2hsY0JhcnMudnVlP3Z1ZSZ0eXBlPXNjcmlwdCZsYW5nPWpzJlxuIC8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gY29uc3QgWE9obGNCYXJzX1hPaGxjQmFyc3Z1ZV90eXBlX3NjcmlwdF9sYW5nX2pzXyA9IChYT2hsY0JhcnN2dWVfdHlwZV9zY3JpcHRfbGFuZ19qc18pOyBcbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9vdmVybGF5cy9YT2hsY0JhcnMvWE9obGNCYXJzLnZ1ZVxudmFyIFhPaGxjQmFyc19yZW5kZXIsIFhPaGxjQmFyc19zdGF0aWNSZW5kZXJGbnNcbjtcblxuXG5cbi8qIG5vcm1hbGl6ZSBjb21wb25lbnQgKi9cbjtcbnZhciBYT2hsY0JhcnNfY29tcG9uZW50ID0gbm9ybWFsaXplQ29tcG9uZW50KFxuICBYT2hsY0JhcnNfWE9obGNCYXJzdnVlX3R5cGVfc2NyaXB0X2xhbmdfanNfLFxuICBYT2hsY0JhcnNfcmVuZGVyLFxuICBYT2hsY0JhcnNfc3RhdGljUmVuZGVyRm5zLFxuICBmYWxzZSxcbiAgbnVsbCxcbiAgbnVsbCxcbiAgbnVsbFxuICBcbilcblxuLyogaG90IHJlbG9hZCAqL1xuaWYgKGZhbHNlKSB7IHZhciBYT2hsY0JhcnNfYXBpOyB9XG5YT2hsY0JhcnNfY29tcG9uZW50Lm9wdGlvbnMuX19maWxlID0gXCJzcmMvb3ZlcmxheXMvWE9obGNCYXJzL1hPaGxjQmFycy52dWVcIlxuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyBjb25zdCBYT2hsY0JhcnMgPSAoWE9obGNCYXJzX2NvbXBvbmVudC5leHBvcnRzKTtcbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9pbmRleF9wcm9kLmpzXG4vLyAtLS0tLS0tLSBQcm9kdWN0aW9uIG92ZXJsYXkgaW5kZXggLS0tLS0tLS0tXG4vLyAgICAgICEgVEhJUyBGSUxFIFdBUyBBVVRPLUdFTkVSQVRFRCAhXG4vL1xuLy8gRG8gbm90IGNvbW1pdCB0aGlzIGZpbGUsIHRoZSBmaW5hbCBpbmRleCBpc1xuLy8gY29tcGlsZWQgYnkgdGhlIHJlcG8gb3duZXIsIHVzZSBpbmRleF9kZXYuanMgdG9cbi8vIGV4cGVyaW1lbnQ6ICducG0gcnVuIGNvbXBpbGUnXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG52YXIgUGFjayA9IHtcbiAgQUxNQTogQUxNQSxcbiAgQVRSOiBBVFIsXG4gIEFUUnA6IEFUUnAsXG4gIEFyZWE1MTogQXJlYTUxLFxuICBCQjogQkIsXG4gIEJCVzogQkJXLFxuICBDQ0k6IENDSSxcbiAgQ01POiBDTU8sXG4gIENPRzogQ09HLFxuICBESGlzdG9ncmFtOiBESGlzdG9ncmFtLFxuICBETUk6IERNSSxcbiAgRU1BOiBFTUEsXG4gIEhNQTogSE1BLFxuICBIaXN0b2dyYW06IEhpc3RvZ3JhbSxcbiAgSWNoaTogSWNoaSxcbiAgSWNoaW1va3U6IEljaGltb2t1LFxuICBLQzogS0MsXG4gIEtDVzogS0NXLFxuICBMb25nU2hvcnRUcmFkZXM6IExvbmdTaG9ydFRyYWRlcyxcbiAgTUFDRDogTUFDRCxcbiAgTUZJOiBNRkksXG4gIE1PTTogTU9NLFxuICBNYXJrZXJzOiBNYXJrZXJzLFxuICBQbG90Q3Jvc3M6IFBsb3RDcm9zcyxcbiAgUk9DOiBST0MsXG4gIFJTSTogUlNJLFxuICBSaWJib246IFJpYmJvbixcbiAgU0FSOiBTQVIsXG4gIFNNQTogU01BLFxuICBTV01BOiBTV01BLFxuICBTdG9jaDogU3RvY2gsXG4gIFRTSTogVFNJLFxuICBUcmFkZXNQbHVzOiBUcmFkZXNQbHVzLFxuICBWV01BOiBWV01BLFxuICBXaWxsaWFtc1I6IFdpbGxpYW1zUixcbiAgWE9obGNCYXJzOiBYT2hsY0JhcnNcbn07XG5cbmlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB3aW5kb3cuVnVlKSB7XG4gIHdpbmRvdy5UdmpzT3ZlcmxheXMgPSBQYWNrO1xufVxuXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIGNvbnN0IGluZGV4X3Byb2QgPSAoUGFjayk7XG5cbn0pKCk7XG5cbi8qKioqKiovIFx0cmV0dXJuIF9fd2VicGFja19leHBvcnRzX187XG4vKioqKioqLyB9KSgpXG47XG59KTsiLCJpbXBvcnQgeyByZW5kZXIsIHN0YXRpY1JlbmRlckZucyB9IGZyb20gXCIuL01haW4udnVlP3Z1ZSZ0eXBlPXRlbXBsYXRlJmlkPTNmZmFlNmIyJlwiXG5pbXBvcnQgc2NyaXB0IGZyb20gXCIuL01haW4udnVlP3Z1ZSZ0eXBlPXNjcmlwdCZsYW5nPWpzJlwiXG5leHBvcnQgKiBmcm9tIFwiLi9NYWluLnZ1ZT92dWUmdHlwZT1zY3JpcHQmbGFuZz1qcyZcIlxuaW1wb3J0IHN0eWxlMCBmcm9tIFwiLi9NYWluLnZ1ZT92dWUmdHlwZT1zdHlsZSZpbmRleD0wJmxhbmc9Y3NzJlwiXG5cblxuLyogbm9ybWFsaXplIGNvbXBvbmVudCAqL1xuaW1wb3J0IG5vcm1hbGl6ZXIgZnJvbSBcIiEuLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvcnVudGltZS9jb21wb25lbnROb3JtYWxpemVyLmpzXCJcbnZhciBjb21wb25lbnQgPSBub3JtYWxpemVyKFxuICBzY3JpcHQsXG4gIHJlbmRlcixcbiAgc3RhdGljUmVuZGVyRm5zLFxuICBmYWxzZSxcbiAgbnVsbCxcbiAgbnVsbCxcbiAgbnVsbFxuICBcbilcblxuLyogaG90IHJlbG9hZCAqL1xuaWYgKG1vZHVsZS5ob3QpIHtcbiAgdmFyIGFwaSA9IHJlcXVpcmUoXCJDOlxcXFx4YW1wcFxcXFxodGRvY3NcXFxcbm9kZV9tb2R1bGVzXFxcXHZ1ZS1ob3QtcmVsb2FkLWFwaVxcXFxkaXN0XFxcXGluZGV4LmpzXCIpXG4gIGFwaS5pbnN0YWxsKHJlcXVpcmUoJ3Z1ZScpKVxuICBpZiAoYXBpLmNvbXBhdGlibGUpIHtcbiAgICBtb2R1bGUuaG90LmFjY2VwdCgpXG4gICAgaWYgKCFhcGkuaXNSZWNvcmRlZCgnM2ZmYWU2YjInKSkge1xuICAgICAgYXBpLmNyZWF0ZVJlY29yZCgnM2ZmYWU2YjInLCBjb21wb25lbnQub3B0aW9ucylcbiAgICB9IGVsc2Uge1xuICAgICAgYXBpLnJlbG9hZCgnM2ZmYWU2YjInLCBjb21wb25lbnQub3B0aW9ucylcbiAgICB9XG4gICAgbW9kdWxlLmhvdC5hY2NlcHQoXCIuL01haW4udnVlP3Z1ZSZ0eXBlPXRlbXBsYXRlJmlkPTNmZmFlNmIyJlwiLCBmdW5jdGlvbiAoKSB7XG4gICAgICBhcGkucmVyZW5kZXIoJzNmZmFlNmIyJywge1xuICAgICAgICByZW5kZXI6IHJlbmRlcixcbiAgICAgICAgc3RhdGljUmVuZGVyRm5zOiBzdGF0aWNSZW5kZXJGbnNcbiAgICAgIH0pXG4gICAgfSlcbiAgfVxufVxuY29tcG9uZW50Lm9wdGlvbnMuX19maWxlID0gXCJzcmMvTWFpbi52dWVcIlxuZXhwb3J0IGRlZmF1bHQgY29tcG9uZW50LmV4cG9ydHMiLCJpbXBvcnQgeyByZW5kZXIsIHN0YXRpY1JlbmRlckZucyB9IGZyb20gXCIuL1N0ZElucHV0LnZ1ZT92dWUmdHlwZT10ZW1wbGF0ZSZpZD01ZTFmMWMxNyZcIlxuaW1wb3J0IHNjcmlwdCBmcm9tIFwiLi9TdGRJbnB1dC52dWU/dnVlJnR5cGU9c2NyaXB0Jmxhbmc9anMmXCJcbmV4cG9ydCAqIGZyb20gXCIuL1N0ZElucHV0LnZ1ZT92dWUmdHlwZT1zY3JpcHQmbGFuZz1qcyZcIlxuaW1wb3J0IHN0eWxlMCBmcm9tIFwiLi9TdGRJbnB1dC52dWU/dnVlJnR5cGU9c3R5bGUmaW5kZXg9MCZsYW5nPWNzcyZcIlxuXG5cbi8qIG5vcm1hbGl6ZSBjb21wb25lbnQgKi9cbmltcG9ydCBub3JtYWxpemVyIGZyb20gXCIhLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3J1bnRpbWUvY29tcG9uZW50Tm9ybWFsaXplci5qc1wiXG52YXIgY29tcG9uZW50ID0gbm9ybWFsaXplcihcbiAgc2NyaXB0LFxuICByZW5kZXIsXG4gIHN0YXRpY1JlbmRlckZucyxcbiAgZmFsc2UsXG4gIG51bGwsXG4gIG51bGwsXG4gIG51bGxcbiAgXG4pXG5cbi8qIGhvdCByZWxvYWQgKi9cbmlmIChtb2R1bGUuaG90KSB7XG4gIHZhciBhcGkgPSByZXF1aXJlKFwiQzpcXFxceGFtcHBcXFxcaHRkb2NzXFxcXG5vZGVfbW9kdWxlc1xcXFx2dWUtaG90LXJlbG9hZC1hcGlcXFxcZGlzdFxcXFxpbmRleC5qc1wiKVxuICBhcGkuaW5zdGFsbChyZXF1aXJlKCd2dWUnKSlcbiAgaWYgKGFwaS5jb21wYXRpYmxlKSB7XG4gICAgbW9kdWxlLmhvdC5hY2NlcHQoKVxuICAgIGlmICghYXBpLmlzUmVjb3JkZWQoJzVlMWYxYzE3JykpIHtcbiAgICAgIGFwaS5jcmVhdGVSZWNvcmQoJzVlMWYxYzE3JywgY29tcG9uZW50Lm9wdGlvbnMpXG4gICAgfSBlbHNlIHtcbiAgICAgIGFwaS5yZWxvYWQoJzVlMWYxYzE3JywgY29tcG9uZW50Lm9wdGlvbnMpXG4gICAgfVxuICAgIG1vZHVsZS5ob3QuYWNjZXB0KFwiLi9TdGRJbnB1dC52dWU/dnVlJnR5cGU9dGVtcGxhdGUmaWQ9NWUxZjFjMTcmXCIsIGZ1bmN0aW9uICgpIHtcbiAgICAgIGFwaS5yZXJlbmRlcignNWUxZjFjMTcnLCB7XG4gICAgICAgIHJlbmRlcjogcmVuZGVyLFxuICAgICAgICBzdGF0aWNSZW5kZXJGbnM6IHN0YXRpY1JlbmRlckZuc1xuICAgICAgfSlcbiAgICB9KVxuICB9XG59XG5jb21wb25lbnQub3B0aW9ucy5fX2ZpbGUgPSBcInNyYy9jb21wb25lbnRzL1N0ZElucHV0LnZ1ZVwiXG5leHBvcnQgZGVmYXVsdCBjb21wb25lbnQuZXhwb3J0cyIsImltcG9ydCB7IHJlbmRlciwgc3RhdGljUmVuZGVyRm5zIH0gZnJvbSBcIi4vV2luZG93LnZ1ZT92dWUmdHlwZT10ZW1wbGF0ZSZpZD01YjAzMGEyMCZcIlxuaW1wb3J0IHNjcmlwdCBmcm9tIFwiLi9XaW5kb3cudnVlP3Z1ZSZ0eXBlPXNjcmlwdCZsYW5nPWpzJlwiXG5leHBvcnQgKiBmcm9tIFwiLi9XaW5kb3cudnVlP3Z1ZSZ0eXBlPXNjcmlwdCZsYW5nPWpzJlwiXG5pbXBvcnQgc3R5bGUwIGZyb20gXCIuL1dpbmRvdy52dWU/dnVlJnR5cGU9c3R5bGUmaW5kZXg9MCZsYW5nPWNzcyZcIlxuXG5cbi8qIG5vcm1hbGl6ZSBjb21wb25lbnQgKi9cbmltcG9ydCBub3JtYWxpemVyIGZyb20gXCIhLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3J1bnRpbWUvY29tcG9uZW50Tm9ybWFsaXplci5qc1wiXG52YXIgY29tcG9uZW50ID0gbm9ybWFsaXplcihcbiAgc2NyaXB0LFxuICByZW5kZXIsXG4gIHN0YXRpY1JlbmRlckZucyxcbiAgZmFsc2UsXG4gIG51bGwsXG4gIG51bGwsXG4gIG51bGxcbiAgXG4pXG5cbi8qIGhvdCByZWxvYWQgKi9cbmlmIChtb2R1bGUuaG90KSB7XG4gIHZhciBhcGkgPSByZXF1aXJlKFwiQzpcXFxceGFtcHBcXFxcaHRkb2NzXFxcXG5vZGVfbW9kdWxlc1xcXFx2dWUtaG90LXJlbG9hZC1hcGlcXFxcZGlzdFxcXFxpbmRleC5qc1wiKVxuICBhcGkuaW5zdGFsbChyZXF1aXJlKCd2dWUnKSlcbiAgaWYgKGFwaS5jb21wYXRpYmxlKSB7XG4gICAgbW9kdWxlLmhvdC5hY2NlcHQoKVxuICAgIGlmICghYXBpLmlzUmVjb3JkZWQoJzViMDMwYTIwJykpIHtcbiAgICAgIGFwaS5jcmVhdGVSZWNvcmQoJzViMDMwYTIwJywgY29tcG9uZW50Lm9wdGlvbnMpXG4gICAgfSBlbHNlIHtcbiAgICAgIGFwaS5yZWxvYWQoJzViMDMwYTIwJywgY29tcG9uZW50Lm9wdGlvbnMpXG4gICAgfVxuICAgIG1vZHVsZS5ob3QuYWNjZXB0KFwiLi9XaW5kb3cudnVlP3Z1ZSZ0eXBlPXRlbXBsYXRlJmlkPTViMDMwYTIwJlwiLCBmdW5jdGlvbiAoKSB7XG4gICAgICBhcGkucmVyZW5kZXIoJzViMDMwYTIwJywge1xuICAgICAgICByZW5kZXI6IHJlbmRlcixcbiAgICAgICAgc3RhdGljUmVuZGVyRm5zOiBzdGF0aWNSZW5kZXJGbnNcbiAgICAgIH0pXG4gICAgfSlcbiAgfVxufVxuY29tcG9uZW50Lm9wdGlvbnMuX19maWxlID0gXCJzcmMvY29tcG9uZW50cy9XaW5kb3cudnVlXCJcbmV4cG9ydCBkZWZhdWx0IGNvbXBvbmVudC5leHBvcnRzIiwiaW1wb3J0IHsgcmVuZGVyLCBzdGF0aWNSZW5kZXJGbnMgfSBmcm9tIFwiLi9TcGxpdHRlci52dWU/dnVlJnR5cGU9dGVtcGxhdGUmaWQ9MTg5ZmNjYWQmc2NvcGVkPXRydWUmXCJcbmltcG9ydCBzY3JpcHQgZnJvbSBcIi4vU3BsaXR0ZXIudnVlP3Z1ZSZ0eXBlPXNjcmlwdCZsYW5nPWpzJlwiXG5leHBvcnQgKiBmcm9tIFwiLi9TcGxpdHRlci52dWU/dnVlJnR5cGU9c2NyaXB0Jmxhbmc9anMmXCJcbmltcG9ydCBzdHlsZTAgZnJvbSBcIi4vU3BsaXR0ZXIudnVlP3Z1ZSZ0eXBlPXN0eWxlJmluZGV4PTAmaWQ9MTg5ZmNjYWQmc2NvcGVkPXRydWUmbGFuZz1jc3MmXCJcblxuXG4vKiBub3JtYWxpemUgY29tcG9uZW50ICovXG5pbXBvcnQgbm9ybWFsaXplciBmcm9tIFwiIS4uLy4uLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9ydW50aW1lL2NvbXBvbmVudE5vcm1hbGl6ZXIuanNcIlxudmFyIGNvbXBvbmVudCA9IG5vcm1hbGl6ZXIoXG4gIHNjcmlwdCxcbiAgcmVuZGVyLFxuICBzdGF0aWNSZW5kZXJGbnMsXG4gIGZhbHNlLFxuICBudWxsLFxuICBcIjE4OWZjY2FkXCIsXG4gIG51bGxcbiAgXG4pXG5cbi8qIGhvdCByZWxvYWQgKi9cbmlmIChtb2R1bGUuaG90KSB7XG4gIHZhciBhcGkgPSByZXF1aXJlKFwiQzpcXFxceGFtcHBcXFxcaHRkb2NzXFxcXG5vZGVfbW9kdWxlc1xcXFx2dWUtaG90LXJlbG9hZC1hcGlcXFxcZGlzdFxcXFxpbmRleC5qc1wiKVxuICBhcGkuaW5zdGFsbChyZXF1aXJlKCd2dWUnKSlcbiAgaWYgKGFwaS5jb21wYXRpYmxlKSB7XG4gICAgbW9kdWxlLmhvdC5hY2NlcHQoKVxuICAgIGlmICghYXBpLmlzUmVjb3JkZWQoJzE4OWZjY2FkJykpIHtcbiAgICAgIGFwaS5jcmVhdGVSZWNvcmQoJzE4OWZjY2FkJywgY29tcG9uZW50Lm9wdGlvbnMpXG4gICAgfSBlbHNlIHtcbiAgICAgIGFwaS5yZWxvYWQoJzE4OWZjY2FkJywgY29tcG9uZW50Lm9wdGlvbnMpXG4gICAgfVxuICAgIG1vZHVsZS5ob3QuYWNjZXB0KFwiLi9TcGxpdHRlci52dWU/dnVlJnR5cGU9dGVtcGxhdGUmaWQ9MTg5ZmNjYWQmc2NvcGVkPXRydWUmXCIsIGZ1bmN0aW9uICgpIHtcbiAgICAgIGFwaS5yZXJlbmRlcignMTg5ZmNjYWQnLCB7XG4gICAgICAgIHJlbmRlcjogcmVuZGVyLFxuICAgICAgICBzdGF0aWNSZW5kZXJGbnM6IHN0YXRpY1JlbmRlckZuc1xuICAgICAgfSlcbiAgICB9KVxuICB9XG59XG5jb21wb25lbnQub3B0aW9ucy5fX2ZpbGUgPSBcInNyYy9leHRlbnNpb25zL2dyaWQtcmVzaXplL1NwbGl0dGVyLnZ1ZVwiXG5leHBvcnQgZGVmYXVsdCBjb21wb25lbnQuZXhwb3J0cyIsImltcG9ydCB7IHJlbmRlciwgc3RhdGljUmVuZGVyRm5zIH0gZnJvbSBcIi4vQWRkV2luLnZ1ZT92dWUmdHlwZT10ZW1wbGF0ZSZpZD01MzQwOGFjNyZzY29wZWQ9dHJ1ZSZcIlxuaW1wb3J0IHNjcmlwdCBmcm9tIFwiLi9BZGRXaW4udnVlP3Z1ZSZ0eXBlPXNjcmlwdCZsYW5nPWpzJlwiXG5leHBvcnQgKiBmcm9tIFwiLi9BZGRXaW4udnVlP3Z1ZSZ0eXBlPXNjcmlwdCZsYW5nPWpzJlwiXG5pbXBvcnQgc3R5bGUwIGZyb20gXCIuL0FkZFdpbi52dWU/dnVlJnR5cGU9c3R5bGUmaW5kZXg9MCZpZD01MzQwOGFjNyZzY29wZWQ9dHJ1ZSZsYW5nPWNzcyZcIlxuXG5cbi8qIG5vcm1hbGl6ZSBjb21wb25lbnQgKi9cbmltcG9ydCBub3JtYWxpemVyIGZyb20gXCIhLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3J1bnRpbWUvY29tcG9uZW50Tm9ybWFsaXplci5qc1wiXG52YXIgY29tcG9uZW50ID0gbm9ybWFsaXplcihcbiAgc2NyaXB0LFxuICByZW5kZXIsXG4gIHN0YXRpY1JlbmRlckZucyxcbiAgZmFsc2UsXG4gIG51bGwsXG4gIFwiNTM0MDhhYzdcIixcbiAgbnVsbFxuICBcbilcblxuLyogaG90IHJlbG9hZCAqL1xuaWYgKG1vZHVsZS5ob3QpIHtcbiAgdmFyIGFwaSA9IHJlcXVpcmUoXCJDOlxcXFx4YW1wcFxcXFxodGRvY3NcXFxcbm9kZV9tb2R1bGVzXFxcXHZ1ZS1ob3QtcmVsb2FkLWFwaVxcXFxkaXN0XFxcXGluZGV4LmpzXCIpXG4gIGFwaS5pbnN0YWxsKHJlcXVpcmUoJ3Z1ZScpKVxuICBpZiAoYXBpLmNvbXBhdGlibGUpIHtcbiAgICBtb2R1bGUuaG90LmFjY2VwdCgpXG4gICAgaWYgKCFhcGkuaXNSZWNvcmRlZCgnNTM0MDhhYzcnKSkge1xuICAgICAgYXBpLmNyZWF0ZVJlY29yZCgnNTM0MDhhYzcnLCBjb21wb25lbnQub3B0aW9ucylcbiAgICB9IGVsc2Uge1xuICAgICAgYXBpLnJlbG9hZCgnNTM0MDhhYzcnLCBjb21wb25lbnQub3B0aW9ucylcbiAgICB9XG4gICAgbW9kdWxlLmhvdC5hY2NlcHQoXCIuL0FkZFdpbi52dWU/dnVlJnR5cGU9dGVtcGxhdGUmaWQ9NTM0MDhhYzcmc2NvcGVkPXRydWUmXCIsIGZ1bmN0aW9uICgpIHtcbiAgICAgIGFwaS5yZXJlbmRlcignNTM0MDhhYzcnLCB7XG4gICAgICAgIHJlbmRlcjogcmVuZGVyLFxuICAgICAgICBzdGF0aWNSZW5kZXJGbnM6IHN0YXRpY1JlbmRlckZuc1xuICAgICAgfSlcbiAgICB9KVxuICB9XG59XG5jb21wb25lbnQub3B0aW9ucy5fX2ZpbGUgPSBcInNyYy9leHRlbnNpb25zL2xlZ2VuZC1idXR0b25zL0FkZFdpbi52dWVcIlxuZXhwb3J0IGRlZmF1bHQgY29tcG9uZW50LmV4cG9ydHMiLCJpbXBvcnQgeyByZW5kZXIsIHN0YXRpY1JlbmRlckZucyB9IGZyb20gXCIuL1NldHRpbmdzV2luLnZ1ZT92dWUmdHlwZT10ZW1wbGF0ZSZpZD01ZDIyM2IwZSZzY29wZWQ9dHJ1ZSZcIlxuaW1wb3J0IHNjcmlwdCBmcm9tIFwiLi9TZXR0aW5nc1dpbi52dWU/dnVlJnR5cGU9c2NyaXB0Jmxhbmc9anMmXCJcbmV4cG9ydCAqIGZyb20gXCIuL1NldHRpbmdzV2luLnZ1ZT92dWUmdHlwZT1zY3JpcHQmbGFuZz1qcyZcIlxuaW1wb3J0IHN0eWxlMCBmcm9tIFwiLi9TZXR0aW5nc1dpbi52dWU/dnVlJnR5cGU9c3R5bGUmaW5kZXg9MCZpZD01ZDIyM2IwZSZzY29wZWQ9dHJ1ZSZsYW5nPWNzcyZcIlxuXG5cbi8qIG5vcm1hbGl6ZSBjb21wb25lbnQgKi9cbmltcG9ydCBub3JtYWxpemVyIGZyb20gXCIhLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3J1bnRpbWUvY29tcG9uZW50Tm9ybWFsaXplci5qc1wiXG52YXIgY29tcG9uZW50ID0gbm9ybWFsaXplcihcbiAgc2NyaXB0LFxuICByZW5kZXIsXG4gIHN0YXRpY1JlbmRlckZucyxcbiAgZmFsc2UsXG4gIG51bGwsXG4gIFwiNWQyMjNiMGVcIixcbiAgbnVsbFxuICBcbilcblxuLyogaG90IHJlbG9hZCAqL1xuaWYgKG1vZHVsZS5ob3QpIHtcbiAgdmFyIGFwaSA9IHJlcXVpcmUoXCJDOlxcXFx4YW1wcFxcXFxodGRvY3NcXFxcbm9kZV9tb2R1bGVzXFxcXHZ1ZS1ob3QtcmVsb2FkLWFwaVxcXFxkaXN0XFxcXGluZGV4LmpzXCIpXG4gIGFwaS5pbnN0YWxsKHJlcXVpcmUoJ3Z1ZScpKVxuICBpZiAoYXBpLmNvbXBhdGlibGUpIHtcbiAgICBtb2R1bGUuaG90LmFjY2VwdCgpXG4gICAgaWYgKCFhcGkuaXNSZWNvcmRlZCgnNWQyMjNiMGUnKSkge1xuICAgICAgYXBpLmNyZWF0ZVJlY29yZCgnNWQyMjNiMGUnLCBjb21wb25lbnQub3B0aW9ucylcbiAgICB9IGVsc2Uge1xuICAgICAgYXBpLnJlbG9hZCgnNWQyMjNiMGUnLCBjb21wb25lbnQub3B0aW9ucylcbiAgICB9XG4gICAgbW9kdWxlLmhvdC5hY2NlcHQoXCIuL1NldHRpbmdzV2luLnZ1ZT92dWUmdHlwZT10ZW1wbGF0ZSZpZD01ZDIyM2IwZSZzY29wZWQ9dHJ1ZSZcIiwgZnVuY3Rpb24gKCkge1xuICAgICAgYXBpLnJlcmVuZGVyKCc1ZDIyM2IwZScsIHtcbiAgICAgICAgcmVuZGVyOiByZW5kZXIsXG4gICAgICAgIHN0YXRpY1JlbmRlckZuczogc3RhdGljUmVuZGVyRm5zXG4gICAgICB9KVxuICAgIH0pXG4gIH1cbn1cbmNvbXBvbmVudC5vcHRpb25zLl9fZmlsZSA9IFwic3JjL2V4dGVuc2lvbnMvc2V0dGluZ3Mtd2luL1NldHRpbmdzV2luLnZ1ZVwiXG5leHBvcnQgZGVmYXVsdCBjb21wb25lbnQuZXhwb3J0cyIsImltcG9ydCBtb2QgZnJvbSBcIi0hLi4vbm9kZV9tb2R1bGVzL2JhYmVsLWxvYWRlci9saWIvaW5kZXguanM/P2Nsb25lZFJ1bGVTZXQtNVswXS5ydWxlc1swXS51c2VbMF0hLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL2luZGV4LmpzPz92dWUtbG9hZGVyLW9wdGlvbnMhLi9NYWluLnZ1ZT92dWUmdHlwZT1zY3JpcHQmbGFuZz1qcyZcIjsgZXhwb3J0IGRlZmF1bHQgbW9kOyBleHBvcnQgKiBmcm9tIFwiLSEuLi9ub2RlX21vZHVsZXMvYmFiZWwtbG9hZGVyL2xpYi9pbmRleC5qcz8/Y2xvbmVkUnVsZVNldC01WzBdLnJ1bGVzWzBdLnVzZVswXSEuLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvaW5kZXguanM/P3Z1ZS1sb2FkZXItb3B0aW9ucyEuL01haW4udnVlP3Z1ZSZ0eXBlPXNjcmlwdCZsYW5nPWpzJlwiIiwiaW1wb3J0IG1vZCBmcm9tIFwiLSEuLi8uLi9ub2RlX21vZHVsZXMvYmFiZWwtbG9hZGVyL2xpYi9pbmRleC5qcz8/Y2xvbmVkUnVsZVNldC01WzBdLnJ1bGVzWzBdLnVzZVswXSEuLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvaW5kZXguanM/P3Z1ZS1sb2FkZXItb3B0aW9ucyEuL1N0ZElucHV0LnZ1ZT92dWUmdHlwZT1zY3JpcHQmbGFuZz1qcyZcIjsgZXhwb3J0IGRlZmF1bHQgbW9kOyBleHBvcnQgKiBmcm9tIFwiLSEuLi8uLi9ub2RlX21vZHVsZXMvYmFiZWwtbG9hZGVyL2xpYi9pbmRleC5qcz8/Y2xvbmVkUnVsZVNldC01WzBdLnJ1bGVzWzBdLnVzZVswXSEuLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvaW5kZXguanM/P3Z1ZS1sb2FkZXItb3B0aW9ucyEuL1N0ZElucHV0LnZ1ZT92dWUmdHlwZT1zY3JpcHQmbGFuZz1qcyZcIiIsImltcG9ydCBtb2QgZnJvbSBcIi0hLi4vLi4vbm9kZV9tb2R1bGVzL2JhYmVsLWxvYWRlci9saWIvaW5kZXguanM/P2Nsb25lZFJ1bGVTZXQtNVswXS5ydWxlc1swXS51c2VbMF0hLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL2luZGV4LmpzPz92dWUtbG9hZGVyLW9wdGlvbnMhLi9XaW5kb3cudnVlP3Z1ZSZ0eXBlPXNjcmlwdCZsYW5nPWpzJlwiOyBleHBvcnQgZGVmYXVsdCBtb2Q7IGV4cG9ydCAqIGZyb20gXCItIS4uLy4uL25vZGVfbW9kdWxlcy9iYWJlbC1sb2FkZXIvbGliL2luZGV4LmpzPz9jbG9uZWRSdWxlU2V0LTVbMF0ucnVsZXNbMF0udXNlWzBdIS4uLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9pbmRleC5qcz8/dnVlLWxvYWRlci1vcHRpb25zIS4vV2luZG93LnZ1ZT92dWUmdHlwZT1zY3JpcHQmbGFuZz1qcyZcIiIsImltcG9ydCBtb2QgZnJvbSBcIi0hLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2JhYmVsLWxvYWRlci9saWIvaW5kZXguanM/P2Nsb25lZFJ1bGVTZXQtNVswXS5ydWxlc1swXS51c2VbMF0hLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL2luZGV4LmpzPz92dWUtbG9hZGVyLW9wdGlvbnMhLi9TcGxpdHRlci52dWU/dnVlJnR5cGU9c2NyaXB0Jmxhbmc9anMmXCI7IGV4cG9ydCBkZWZhdWx0IG1vZDsgZXhwb3J0ICogZnJvbSBcIi0hLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2JhYmVsLWxvYWRlci9saWIvaW5kZXguanM/P2Nsb25lZFJ1bGVTZXQtNVswXS5ydWxlc1swXS51c2VbMF0hLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL2luZGV4LmpzPz92dWUtbG9hZGVyLW9wdGlvbnMhLi9TcGxpdHRlci52dWU/dnVlJnR5cGU9c2NyaXB0Jmxhbmc9anMmXCIiLCJpbXBvcnQgbW9kIGZyb20gXCItIS4uLy4uLy4uL25vZGVfbW9kdWxlcy9iYWJlbC1sb2FkZXIvbGliL2luZGV4LmpzPz9jbG9uZWRSdWxlU2V0LTVbMF0ucnVsZXNbMF0udXNlWzBdIS4uLy4uLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9pbmRleC5qcz8/dnVlLWxvYWRlci1vcHRpb25zIS4vQWRkV2luLnZ1ZT92dWUmdHlwZT1zY3JpcHQmbGFuZz1qcyZcIjsgZXhwb3J0IGRlZmF1bHQgbW9kOyBleHBvcnQgKiBmcm9tIFwiLSEuLi8uLi8uLi9ub2RlX21vZHVsZXMvYmFiZWwtbG9hZGVyL2xpYi9pbmRleC5qcz8/Y2xvbmVkUnVsZVNldC01WzBdLnJ1bGVzWzBdLnVzZVswXSEuLi8uLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvaW5kZXguanM/P3Z1ZS1sb2FkZXItb3B0aW9ucyEuL0FkZFdpbi52dWU/dnVlJnR5cGU9c2NyaXB0Jmxhbmc9anMmXCIiLCJpbXBvcnQgbW9kIGZyb20gXCItIS4uLy4uLy4uL25vZGVfbW9kdWxlcy9iYWJlbC1sb2FkZXIvbGliL2luZGV4LmpzPz9jbG9uZWRSdWxlU2V0LTVbMF0ucnVsZXNbMF0udXNlWzBdIS4uLy4uLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9pbmRleC5qcz8/dnVlLWxvYWRlci1vcHRpb25zIS4vU2V0dGluZ3NXaW4udnVlP3Z1ZSZ0eXBlPXNjcmlwdCZsYW5nPWpzJlwiOyBleHBvcnQgZGVmYXVsdCBtb2Q7IGV4cG9ydCAqIGZyb20gXCItIS4uLy4uLy4uL25vZGVfbW9kdWxlcy9iYWJlbC1sb2FkZXIvbGliL2luZGV4LmpzPz9jbG9uZWRSdWxlU2V0LTVbMF0ucnVsZXNbMF0udXNlWzBdIS4uLy4uLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9pbmRleC5qcz8/dnVlLWxvYWRlci1vcHRpb25zIS4vU2V0dGluZ3NXaW4udnVlP3Z1ZSZ0eXBlPXNjcmlwdCZsYW5nPWpzJlwiIiwiZXhwb3J0ICogZnJvbSBcIi0hLi4vbm9kZV9tb2R1bGVzL3N0eWxlLWxvYWRlci9kaXN0L2Nqcy5qcyEuLi9ub2RlX21vZHVsZXMvbGFyYXZlbC1taXgvbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvZGlzdC9janMuanM/P2Nsb25lZFJ1bGVTZXQtNjVbMF0ucnVsZXNbMF0udXNlWzFdIS4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9sb2FkZXJzL3N0eWxlUG9zdExvYWRlci5qcyEuLi9ub2RlX21vZHVsZXMvcG9zdGNzcy1sb2FkZXIvZGlzdC9janMuanM/P2Nsb25lZFJ1bGVTZXQtNjVbMF0ucnVsZXNbMF0udXNlWzJdIS4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9pbmRleC5qcz8/dnVlLWxvYWRlci1vcHRpb25zIS4vTWFpbi52dWU/dnVlJnR5cGU9c3R5bGUmaW5kZXg9MCZsYW5nPWNzcyZcIiIsImV4cG9ydCAqIGZyb20gXCItIS4uLy4uL25vZGVfbW9kdWxlcy9zdHlsZS1sb2FkZXIvZGlzdC9janMuanMhLi4vLi4vbm9kZV9tb2R1bGVzL2xhcmF2ZWwtbWl4L25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2Rpc3QvY2pzLmpzPz9jbG9uZWRSdWxlU2V0LTY1WzBdLnJ1bGVzWzBdLnVzZVsxXSEuLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvbG9hZGVycy9zdHlsZVBvc3RMb2FkZXIuanMhLi4vLi4vbm9kZV9tb2R1bGVzL3Bvc3Rjc3MtbG9hZGVyL2Rpc3QvY2pzLmpzPz9jbG9uZWRSdWxlU2V0LTY1WzBdLnJ1bGVzWzBdLnVzZVsyXSEuLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvaW5kZXguanM/P3Z1ZS1sb2FkZXItb3B0aW9ucyEuL1N0ZElucHV0LnZ1ZT92dWUmdHlwZT1zdHlsZSZpbmRleD0wJmxhbmc9Y3NzJlwiIiwiZXhwb3J0ICogZnJvbSBcIi0hLi4vLi4vbm9kZV9tb2R1bGVzL3N0eWxlLWxvYWRlci9kaXN0L2Nqcy5qcyEuLi8uLi9ub2RlX21vZHVsZXMvbGFyYXZlbC1taXgvbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvZGlzdC9janMuanM/P2Nsb25lZFJ1bGVTZXQtNjVbMF0ucnVsZXNbMF0udXNlWzFdIS4uLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9sb2FkZXJzL3N0eWxlUG9zdExvYWRlci5qcyEuLi8uLi9ub2RlX21vZHVsZXMvcG9zdGNzcy1sb2FkZXIvZGlzdC9janMuanM/P2Nsb25lZFJ1bGVTZXQtNjVbMF0ucnVsZXNbMF0udXNlWzJdIS4uLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9pbmRleC5qcz8/dnVlLWxvYWRlci1vcHRpb25zIS4vV2luZG93LnZ1ZT92dWUmdHlwZT1zdHlsZSZpbmRleD0wJmxhbmc9Y3NzJlwiIiwiZXhwb3J0ICogZnJvbSBcIi0hLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3N0eWxlLWxvYWRlci9kaXN0L2Nqcy5qcyEuLi8uLi8uLi9ub2RlX21vZHVsZXMvbGFyYXZlbC1taXgvbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvZGlzdC9janMuanM/P2Nsb25lZFJ1bGVTZXQtNjVbMF0ucnVsZXNbMF0udXNlWzFdIS4uLy4uLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9sb2FkZXJzL3N0eWxlUG9zdExvYWRlci5qcyEuLi8uLi8uLi9ub2RlX21vZHVsZXMvcG9zdGNzcy1sb2FkZXIvZGlzdC9janMuanM/P2Nsb25lZFJ1bGVTZXQtNjVbMF0ucnVsZXNbMF0udXNlWzJdIS4uLy4uLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9pbmRleC5qcz8/dnVlLWxvYWRlci1vcHRpb25zIS4vU3BsaXR0ZXIudnVlP3Z1ZSZ0eXBlPXN0eWxlJmluZGV4PTAmaWQ9MTg5ZmNjYWQmc2NvcGVkPXRydWUmbGFuZz1jc3MmXCIiLCJleHBvcnQgKiBmcm9tIFwiLSEuLi8uLi8uLi9ub2RlX21vZHVsZXMvc3R5bGUtbG9hZGVyL2Rpc3QvY2pzLmpzIS4uLy4uLy4uL25vZGVfbW9kdWxlcy9sYXJhdmVsLW1peC9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9kaXN0L2Nqcy5qcz8/Y2xvbmVkUnVsZVNldC02NVswXS5ydWxlc1swXS51c2VbMV0hLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL2xvYWRlcnMvc3R5bGVQb3N0TG9hZGVyLmpzIS4uLy4uLy4uL25vZGVfbW9kdWxlcy9wb3N0Y3NzLWxvYWRlci9kaXN0L2Nqcy5qcz8/Y2xvbmVkUnVsZVNldC02NVswXS5ydWxlc1swXS51c2VbMl0hLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL2luZGV4LmpzPz92dWUtbG9hZGVyLW9wdGlvbnMhLi9BZGRXaW4udnVlP3Z1ZSZ0eXBlPXN0eWxlJmluZGV4PTAmaWQ9NTM0MDhhYzcmc2NvcGVkPXRydWUmbGFuZz1jc3MmXCIiLCJleHBvcnQgKiBmcm9tIFwiLSEuLi8uLi8uLi9ub2RlX21vZHVsZXMvc3R5bGUtbG9hZGVyL2Rpc3QvY2pzLmpzIS4uLy4uLy4uL25vZGVfbW9kdWxlcy9sYXJhdmVsLW1peC9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9kaXN0L2Nqcy5qcz8/Y2xvbmVkUnVsZVNldC02NVswXS5ydWxlc1swXS51c2VbMV0hLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL2xvYWRlcnMvc3R5bGVQb3N0TG9hZGVyLmpzIS4uLy4uLy4uL25vZGVfbW9kdWxlcy9wb3N0Y3NzLWxvYWRlci9kaXN0L2Nqcy5qcz8/Y2xvbmVkUnVsZVNldC02NVswXS5ydWxlc1swXS51c2VbMl0hLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL2luZGV4LmpzPz92dWUtbG9hZGVyLW9wdGlvbnMhLi9TZXR0aW5nc1dpbi52dWU/dnVlJnR5cGU9c3R5bGUmaW5kZXg9MCZpZD01ZDIyM2IwZSZzY29wZWQ9dHJ1ZSZsYW5nPWNzcyZcIiIsImV4cG9ydCAqIGZyb20gXCItIS4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9sb2FkZXJzL3RlbXBsYXRlTG9hZGVyLmpzPz92dWUtbG9hZGVyLW9wdGlvbnMhLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL2luZGV4LmpzPz92dWUtbG9hZGVyLW9wdGlvbnMhLi9NYWluLnZ1ZT92dWUmdHlwZT10ZW1wbGF0ZSZpZD0zZmZhZTZiMiZcIiIsImV4cG9ydCAqIGZyb20gXCItIS4uLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9sb2FkZXJzL3RlbXBsYXRlTG9hZGVyLmpzPz92dWUtbG9hZGVyLW9wdGlvbnMhLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL2luZGV4LmpzPz92dWUtbG9hZGVyLW9wdGlvbnMhLi9TdGRJbnB1dC52dWU/dnVlJnR5cGU9dGVtcGxhdGUmaWQ9NWUxZjFjMTcmXCIiLCJleHBvcnQgKiBmcm9tIFwiLSEuLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvbG9hZGVycy90ZW1wbGF0ZUxvYWRlci5qcz8/dnVlLWxvYWRlci1vcHRpb25zIS4uLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9pbmRleC5qcz8/dnVlLWxvYWRlci1vcHRpb25zIS4vV2luZG93LnZ1ZT92dWUmdHlwZT10ZW1wbGF0ZSZpZD01YjAzMGEyMCZcIiIsImV4cG9ydCAqIGZyb20gXCItIS4uLy4uLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9sb2FkZXJzL3RlbXBsYXRlTG9hZGVyLmpzPz92dWUtbG9hZGVyLW9wdGlvbnMhLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL2luZGV4LmpzPz92dWUtbG9hZGVyLW9wdGlvbnMhLi9TcGxpdHRlci52dWU/dnVlJnR5cGU9dGVtcGxhdGUmaWQ9MTg5ZmNjYWQmc2NvcGVkPXRydWUmXCIiLCJleHBvcnQgKiBmcm9tIFwiLSEuLi8uLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvbG9hZGVycy90ZW1wbGF0ZUxvYWRlci5qcz8/dnVlLWxvYWRlci1vcHRpb25zIS4uLy4uLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9pbmRleC5qcz8/dnVlLWxvYWRlci1vcHRpb25zIS4vQWRkV2luLnZ1ZT92dWUmdHlwZT10ZW1wbGF0ZSZpZD01MzQwOGFjNyZzY29wZWQ9dHJ1ZSZcIiIsImV4cG9ydCAqIGZyb20gXCItIS4uLy4uLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9sb2FkZXJzL3RlbXBsYXRlTG9hZGVyLmpzPz92dWUtbG9hZGVyLW9wdGlvbnMhLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL2luZGV4LmpzPz92dWUtbG9hZGVyLW9wdGlvbnMhLi9TZXR0aW5nc1dpbi52dWU/dnVlJnR5cGU9dGVtcGxhdGUmaWQ9NWQyMjNiMGUmc2NvcGVkPXRydWUmXCIiLCJ2YXIgcmVuZGVyID0gZnVuY3Rpb24gKCkge1xuICB2YXIgX3ZtID0gdGhpc1xuICB2YXIgX2ggPSBfdm0uJGNyZWF0ZUVsZW1lbnRcbiAgdmFyIF9jID0gX3ZtLl9zZWxmLl9jIHx8IF9oXG4gIHJldHVybiBfYyhcbiAgICBcImRpdlwiLFxuICAgIHtcbiAgICAgIHN0YXRpY0NsYXNzOlxuICAgICAgICBcImZsZXgtc3RhcnQgY29sLTEwIGNvbC14bGwtMTAgY29sLXhsLTEwIGNvbC1sZy0xMCBjb2wtbWQtOSBjb2wtc20tMTJcIixcbiAgICB9LFxuICAgIFtcbiAgICAgIF9jKFwiZGl2XCIsIHsgYXR0cnM6IHsgaWQ6IFwidHZqcy1oZWFkZXJcIiB9IH0sIFtcbiAgICAgICAgX2MoXCJhXCIsIFtcbiAgICAgICAgICBfYyhcbiAgICAgICAgICAgIFwic3BhblwiLFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICBzdGF0aWNDbGFzczogXCJtZS0xIGJhZGdlIGJnLWxpZ2h0LXNlY29uZGFyeVwiLFxuICAgICAgICAgICAgICBvbjogeyBjbGljazogX3ZtLmNhbmRsZXMgfSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBbXG4gICAgICAgICAgICAgIF9jKFwiaVwiLCB7IHN0YXRpY0NsYXNzOiBcImJpIGJpLWJhci1jaGFydFwiIH0pLFxuICAgICAgICAgICAgICBfYyhcImRpdlwiLCB7IHN0YXRpY0NsYXNzOiBcImQtbWQtaW5saW5lIGQtbm9uZVwiIH0sIFtcbiAgICAgICAgICAgICAgICBfdm0uX3YoXCIgIENhbmRsZXNcIiksXG4gICAgICAgICAgICAgIF0pLFxuICAgICAgICAgICAgXVxuICAgICAgICAgICksXG4gICAgICAgIF0pLFxuICAgICAgICBfdm0uX3YoXCIgXCIpLFxuICAgICAgICBfYyhcImFcIiwgW1xuICAgICAgICAgIF9jKFxuICAgICAgICAgICAgXCJzcGFuXCIsXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIHN0YXRpY0NsYXNzOiBcIm1lLTEgYmFkZ2UgYmctbGlnaHQtc2Vjb25kYXJ5XCIsXG4gICAgICAgICAgICAgIG9uOiB7IGNsaWNrOiBfdm0uc3BsaW5lIH0sXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgW1xuICAgICAgICAgICAgICBfYyhcImlcIiwgeyBzdGF0aWNDbGFzczogXCJiaSBiaS1ncmFwaC11cFwiIH0pLFxuICAgICAgICAgICAgICBfYyhcImRpdlwiLCB7IHN0YXRpY0NsYXNzOiBcImQtbWQtaW5saW5lIGQtbm9uZVwiIH0sIFtcbiAgICAgICAgICAgICAgICBfdm0uX3YoXCIgIFNwbGluZVwiKSxcbiAgICAgICAgICAgICAgXSksXG4gICAgICAgICAgICBdXG4gICAgICAgICAgKSxcbiAgICAgICAgXSksXG4gICAgICAgIF92bS5fdihcIiBcIiksXG4gICAgICAgIF92bS5fbSgwKSxcbiAgICAgICAgX3ZtLl92KFwiIFwiKSxcbiAgICAgICAgX3ZtLl9tKDEpLFxuICAgICAgICBfdm0uX3YoXCIgXCIpLFxuICAgICAgICBfdm0uX20oMiksXG4gICAgICBdKSxcbiAgICAgIF92bS5fdihcIiBcIiksXG4gICAgICBfYyhcbiAgICAgICAgXCJkaXZcIixcbiAgICAgICAge1xuICAgICAgICAgIHN0YXRpY0NsYXNzOlxuICAgICAgICAgICAgXCJjb2xsYXBzZSBjb2wtbGctNCBjb2wtbWQtNSBjb2wtc20tNiBwb3NpdGlvbi1hYnNvbHV0ZSBzdGlja3ktdG9wIGNhcmQtMTEwIFwiLFxuICAgICAgICAgIGF0dHJzOiB7IGlkOiBcImNvbGxhcHNlSW5mb3NcIiB9LFxuICAgICAgICB9LFxuICAgICAgICBbXG4gICAgICAgICAgX2MoXG4gICAgICAgICAgICBcImRpdlwiLFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICBzdGF0aWNDbGFzczogXCJjYXJkXCIsXG4gICAgICAgICAgICAgIHN0YXRpY1N0eWxlOiB7XG4gICAgICAgICAgICAgICAgYmFja2dyb3VuZDogXCIjMTMxNzIyZTYhaW1wb3J0YW50XCIsXG4gICAgICAgICAgICAgICAgXCJib3gtc2hhZG93XCI6IFwiMCA0cHggMjRweCAwIHJnYigwIDAgMCAvIDMwJSlcIixcbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBbXG4gICAgICAgICAgICAgIF9jKFwiZGl2XCIsIHsgc3RhdGljQ2xhc3M6IFwiY2FyZC1oZWFkZXJcIiB9LCBbXG4gICAgICAgICAgICAgICAgX2MoXCJkaXZcIiwgeyBzdGF0aWNDbGFzczogXCJjb2wtbWQtOFwiIH0sIFtcbiAgICAgICAgICAgICAgICAgIF9jKFwiaDRcIiwgeyBzdGF0aWNDbGFzczogXCJjYXJkLXRpdGxlXCIgfSwgW1xuICAgICAgICAgICAgICAgICAgICBfdm0uX3YoXG4gICAgICAgICAgICAgICAgICAgICAgXCJcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXCIgK1xuICAgICAgICAgICAgICAgICAgICAgICAgX3ZtLl9zKF92bS5zeW1ib2wpICtcbiAgICAgICAgICAgICAgICAgICAgICAgIFwiXFxuICAgICAgICAgICAgICAgICAgICAgICAgXCJcbiAgICAgICAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICAgICAgIF0pLFxuICAgICAgICAgICAgICAgIF0pLFxuICAgICAgICAgICAgICBdKSxcbiAgICAgICAgICAgICAgX3ZtLl92KFwiIFwiKSxcbiAgICAgICAgICAgICAgX3ZtLl9tKDMpLFxuICAgICAgICAgICAgXVxuICAgICAgICAgICksXG4gICAgICAgIF1cbiAgICAgICksXG4gICAgICBfdm0uX3YoXCIgXCIpLFxuICAgICAgX3ZtLl9tKDQpLFxuICAgICAgX3ZtLl92KFwiIFwiKSxcbiAgICAgIF92bS5fbSg1KSxcbiAgICAgIF92bS5fdihcIiBcIiksXG4gICAgICBfYyhcbiAgICAgICAgXCJkaXZcIixcbiAgICAgICAgeyBzdGF0aWNDbGFzczogXCJhcHAtY29udGFpbmVyXCIsIHN0YXRpY1N0eWxlOiB7IFwibWFyZ2luLXRvcFwiOiBcIjQwcHhcIiB9IH0sXG4gICAgICAgIFtcbiAgICAgICAgICBfYyhcInRyYWRpbmctdnVlXCIsIHtcbiAgICAgICAgICAgIGtleTogX3ZtLnJlc2V0a2V5LFxuICAgICAgICAgICAgcmVmOiBcInR2anNcIixcbiAgICAgICAgICAgIGF0dHJzOiB7XG4gICAgICAgICAgICAgIGRhdGE6IF92bS5kYyxcbiAgICAgICAgICAgICAgd2lkdGg6IF92bS53aWR0aCxcbiAgICAgICAgICAgICAgaGVpZ2h0OiBfdm0uaGVpZ2h0LFxuICAgICAgICAgICAgICBcInRpdGxlLXR4dFwiOiBfdm0udGl0bGUsXG4gICAgICAgICAgICAgIFwiY29sb3ItdGl0bGVcIjogXCIjZmY5ZjQzXCIsXG4gICAgICAgICAgICAgIFwibGVnZW5kLWJ1dHRvbnNcIjogW1xuICAgICAgICAgICAgICAgIFwiZGlzcGxheVwiLFxuICAgICAgICAgICAgICAgIFwic2V0dGluZ3NcIixcbiAgICAgICAgICAgICAgICBcInVwXCIsXG4gICAgICAgICAgICAgICAgXCJkb3duXCIsXG4gICAgICAgICAgICAgICAgXCJhZGRcIixcbiAgICAgICAgICAgICAgICBcInJlbW92ZVwiLFxuICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICBcImNoYXJ0LWNvbmZpZ1wiOiB7IERFRkFVTFRfTEVOOiA2MCwgTUlOX1pPT006IDEgfSxcbiAgICAgICAgICAgICAgdG9vbGJhcjogdHJ1ZSxcbiAgICAgICAgICAgICAgXCJjb2xvci1iYWNrXCI6IF92bS5jb2xvcnMuY29sb3JCYWNrLFxuICAgICAgICAgICAgICBcImNvbG9yLWdyaWRcIjogX3ZtLmNvbG9ycy5jb2xvckdyaWQsXG4gICAgICAgICAgICAgIFwiY29sb3ItdGV4dFwiOiBfdm0uY29sb3JzLmNvbG9yVGV4dCxcbiAgICAgICAgICAgICAgZXh0ZW5zaW9uczogX3ZtLmV4dCxcbiAgICAgICAgICAgICAgb3ZlcmxheXM6IF92bS5vdnMsXG4gICAgICAgICAgICAgIG5pZ2h0OiBfdm0ubmlnaHQsXG4gICAgICAgICAgICAgIHJlc2V0a2V5OiBfdm0ucmVzZXRrZXksXG4gICAgICAgICAgICAgIFwieC1zZXR0aW5nc1wiOiBfdm0ueHNldHQsXG4gICAgICAgICAgICAgIHRpbWV6b25lOiBfdm0udGltZXpvbmUsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgIH0pLFxuICAgICAgICBdLFxuICAgICAgICAxXG4gICAgICApLFxuICAgIF1cbiAgKVxufVxudmFyIHN0YXRpY1JlbmRlckZucyA9IFtcbiAgZnVuY3Rpb24gKCkge1xuICAgIHZhciBfdm0gPSB0aGlzXG4gICAgdmFyIF9oID0gX3ZtLiRjcmVhdGVFbGVtZW50XG4gICAgdmFyIF9jID0gX3ZtLl9zZWxmLl9jIHx8IF9oXG4gICAgcmV0dXJuIF9jKFwiYVwiLCBbXG4gICAgICBfYyhcbiAgICAgICAgXCJzcGFuXCIsXG4gICAgICAgIHtcbiAgICAgICAgICBzdGF0aWNDbGFzczogXCJtZS0xIGJhZGdlIGJnLWxpZ2h0LWluZm9cIixcbiAgICAgICAgICBhdHRyczoge1xuICAgICAgICAgICAgaWQ6IFwidG9nZ2xlSW5mb1wiLFxuICAgICAgICAgICAgXCJkYXRhLWJzLXRvZ2dsZVwiOiBcImNvbGxhcHNlXCIsXG4gICAgICAgICAgICBcImRhdGEtYnMtdGFyZ2V0XCI6IFwiI2NvbGxhcHNlSW5mb3NcIixcbiAgICAgICAgICAgIFwiYXJpYS1leHBhbmRlZFwiOiBcImZhbHNlXCIsXG4gICAgICAgICAgICBcImFyaWEtY29udHJvbHNcIjogXCJjb2xsYXBzZUluZm9zXCIsXG4gICAgICAgICAgfSxcbiAgICAgICAgfSxcbiAgICAgICAgW1xuICAgICAgICAgIF9jKFwiaVwiLCB7IHN0YXRpY0NsYXNzOiBcImJpIGJpLWluZm8tY2lyY2xlXCIgfSksXG4gICAgICAgICAgX2MoXCJkaXZcIiwgeyBzdGF0aWNDbGFzczogXCJkLW1kLWlubGluZSBkLW5vbmVcIiB9LCBbX3ZtLl92KFwiICBJbmZvXCIpXSksXG4gICAgICAgIF1cbiAgICAgICksXG4gICAgXSlcbiAgfSxcbiAgZnVuY3Rpb24gKCkge1xuICAgIHZhciBfdm0gPSB0aGlzXG4gICAgdmFyIF9oID0gX3ZtLiRjcmVhdGVFbGVtZW50XG4gICAgdmFyIF9jID0gX3ZtLl9zZWxmLl9jIHx8IF9oXG4gICAgcmV0dXJuIF9jKFwiYVwiLCBbXG4gICAgICBfYyhcbiAgICAgICAgXCJzcGFuXCIsXG4gICAgICAgIHtcbiAgICAgICAgICBzdGF0aWNDbGFzczogXCJtZS0xIGJhZGdlIGJnLWxpZ2h0LXByaW1hcnkgXCIsXG4gICAgICAgICAgYXR0cnM6IHtcbiAgICAgICAgICAgIGlkOiBcInRvZ2dsZURlcHRoXCIsXG4gICAgICAgICAgICBcImRhdGEtYnMtdG9nZ2xlXCI6IFwiY29sbGFwc2VcIixcbiAgICAgICAgICAgIFwiZGF0YS1icy10YXJnZXRcIjogXCIjY29sbGFwc2VEZXB0aFwiLFxuICAgICAgICAgICAgXCJhcmlhLWV4cGFuZGVkXCI6IFwiZmFsc2VcIixcbiAgICAgICAgICAgIFwiYXJpYS1jb250cm9sc1wiOiBcImNvbGxhcHNlRGVwdGhcIixcbiAgICAgICAgICB9LFxuICAgICAgICB9LFxuICAgICAgICBbXG4gICAgICAgICAgX2MoXCJpXCIsIHsgc3RhdGljQ2xhc3M6IFwiYmkgYmkta2FuYmFuXCIgfSksXG4gICAgICAgICAgX2MoXCJkaXZcIiwgeyBzdGF0aWNDbGFzczogXCJkLW1kLWlubGluZSBkLW5vbmVcIiB9LCBbXG4gICAgICAgICAgICBfdm0uX3YoXCIgIERlcHRoIFZpZXdcIiksXG4gICAgICAgICAgXSksXG4gICAgICAgIF1cbiAgICAgICksXG4gICAgXSlcbiAgfSxcbiAgZnVuY3Rpb24gKCkge1xuICAgIHZhciBfdm0gPSB0aGlzXG4gICAgdmFyIF9oID0gX3ZtLiRjcmVhdGVFbGVtZW50XG4gICAgdmFyIF9jID0gX3ZtLl9zZWxmLl9jIHx8IF9oXG4gICAgcmV0dXJuIF9jKFwiYVwiLCBbXG4gICAgICBfYyhcbiAgICAgICAgXCJzcGFuXCIsXG4gICAgICAgIHtcbiAgICAgICAgICBzdGF0aWNDbGFzczogXCJtZS0xIGJhZGdlIGJnLWxpZ2h0LXdhcm5pbmcgXCIsXG4gICAgICAgICAgYXR0cnM6IHtcbiAgICAgICAgICAgIGlkOiBcInRvZ2dsZU9yZGVyc1wiLFxuICAgICAgICAgICAgXCJkYXRhLWJzLXRvZ2dsZVwiOiBcImNvbGxhcHNlXCIsXG4gICAgICAgICAgICBcImRhdGEtYnMtdGFyZ2V0XCI6IFwiI2NvbGxhcHNlT3JkZXJzXCIsXG4gICAgICAgICAgICBcImFyaWEtZXhwYW5kZWRcIjogXCJmYWxzZVwiLFxuICAgICAgICAgICAgXCJhcmlhLWNvbnRyb2xzXCI6IFwiY29sbGFwc2VPcmRlcnNcIixcbiAgICAgICAgICB9LFxuICAgICAgICB9LFxuICAgICAgICBbXG4gICAgICAgICAgX2MoXCJpXCIsIHsgc3RhdGljQ2xhc3M6IFwiYmkgYmktZmlsZS1iYXItZ3JhcGhcIiB9KSxcbiAgICAgICAgICBfYyhcImRpdlwiLCB7IHN0YXRpY0NsYXNzOiBcImQtbWQtaW5saW5lIGQtbm9uZVwiIH0sIFtcbiAgICAgICAgICAgIF92bS5fdihcIiAgT3JkZXIgQm9va1wiKSxcbiAgICAgICAgICBdKSxcbiAgICAgICAgXVxuICAgICAgKSxcbiAgICBdKVxuICB9LFxuICBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIF92bSA9IHRoaXNcbiAgICB2YXIgX2ggPSBfdm0uJGNyZWF0ZUVsZW1lbnRcbiAgICB2YXIgX2MgPSBfdm0uX3NlbGYuX2MgfHwgX2hcbiAgICByZXR1cm4gX2MoXCJkaXZcIiwgeyBzdGF0aWNDbGFzczogXCJjYXJkLWNvbnRlbnRcIiB9LCBbXG4gICAgICBfYyhcImRpdlwiLCB7IHN0YXRpY0NsYXNzOiBcImNhcmQtYm9keVwiIH0sIFtcbiAgICAgICAgX2MoXCJkaXZcIiwgeyBzdGF0aWNDbGFzczogXCJyb3dcIiB9LCBbXG4gICAgICAgICAgX2MoXCJkaXZcIiwgeyBzdGF0aWNDbGFzczogXCJjb2wtOFwiIH0sIFtcbiAgICAgICAgICAgIF9jKFxuICAgICAgICAgICAgICBcImRpdlwiLFxuICAgICAgICAgICAgICB7IHN0YXRpY0NsYXNzOiBcInRleHQtc3RhcnQgZnMtMVwiLCBhdHRyczogeyBpZDogXCJzaG93X2JcIiB9IH0sXG4gICAgICAgICAgICAgIFtcbiAgICAgICAgICAgICAgICBfdm0uX3YoXG4gICAgICAgICAgICAgICAgICBcIlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC4uLlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJcbiAgICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgICBdXG4gICAgICAgICAgICApLFxuICAgICAgICAgIF0pLFxuICAgICAgICAgIF92bS5fdihcIiBcIiksXG4gICAgICAgICAgX2MoXCJkaXZcIiwgeyBzdGF0aWNDbGFzczogXCJjb2wtNFwiIH0sIFtcbiAgICAgICAgICAgIF9jKFxuICAgICAgICAgICAgICBcImRpdlwiLFxuICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgc3RhdGljQ2xhc3M6IFwidGV4dC1lbmRcIixcbiAgICAgICAgICAgICAgICBzdGF0aWNTdHlsZTogeyBcImZvbnQtc2l6ZVwiOiBcIjE0cHhcIiB9LFxuICAgICAgICAgICAgICAgIGF0dHJzOiB7IGlkOiBcInNob3dfcFwiIH0sXG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIFtcbiAgICAgICAgICAgICAgICBfdm0uX3YoXG4gICAgICAgICAgICAgICAgICBcIlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC4uLlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJcbiAgICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgICBdXG4gICAgICAgICAgICApLFxuICAgICAgICAgICAgX3ZtLl92KFwiIFwiKSxcbiAgICAgICAgICAgIF9jKFxuICAgICAgICAgICAgICBcImRpdlwiLFxuICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgc3RhdGljQ2xhc3M6IFwidGV4dC1lbmRcIixcbiAgICAgICAgICAgICAgICBzdGF0aWNTdHlsZTogeyBcImZvbnQtc2l6ZVwiOiBcIjE0cHhcIiB9LFxuICAgICAgICAgICAgICAgIGF0dHJzOiB7IGlkOiBcInNob3dfUFwiIH0sXG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIFtcbiAgICAgICAgICAgICAgICBfdm0uX3YoXG4gICAgICAgICAgICAgICAgICBcIlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC4uLlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJcbiAgICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgICBdXG4gICAgICAgICAgICApLFxuICAgICAgICAgIF0pLFxuICAgICAgICBdKSxcbiAgICAgICAgX3ZtLl92KFwiIFwiKSxcbiAgICAgICAgX2MoXCJkaXZcIiwgeyBzdGF0aWNDbGFzczogXCJyb3cgbXQtMVwiIH0sIFtcbiAgICAgICAgICBfYyhcbiAgICAgICAgICAgIFwiZGl2XCIsXG4gICAgICAgICAgICB7IHN0YXRpY0NsYXNzOiBcInByb2dyZXNzXCIsIGF0dHJzOiB7IGlkOiBcIm15UmFuZ2VDb2xvclwiIH0gfSxcbiAgICAgICAgICAgIFtcbiAgICAgICAgICAgICAgX2MoXCJkaXZcIiwge1xuICAgICAgICAgICAgICAgIHN0YXRpY0NsYXNzOlxuICAgICAgICAgICAgICAgICAgXCJwcm9ncmVzcy1iYXIgcHJvZ3Jlc3MtYmFyLXN0cmlwZWQgcHJvZ3Jlc3MtYmFyLWFuaW1hdGVkXCIsXG4gICAgICAgICAgICAgICAgc3RhdGljU3R5bGU6IHsgd2lkdGg6IFwiODAlXCIgfSxcbiAgICAgICAgICAgICAgICBhdHRyczoge1xuICAgICAgICAgICAgICAgICAgaWQ6IFwibXlSYW5nZVwiLFxuICAgICAgICAgICAgICAgICAgcm9sZTogXCJwcm9ncmVzc2JhclwiLFxuICAgICAgICAgICAgICAgICAgXCJhcmlhLXZhbHVlbm93XCI6IFwiNTBcIixcbiAgICAgICAgICAgICAgICAgIFwiYXJpYS12YWx1ZW1pblwiOiBcIjBcIixcbiAgICAgICAgICAgICAgICAgIFwiYXJpYS12YWx1ZW1heFwiOiBcIjEwMFwiLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgXVxuICAgICAgICAgICksXG4gICAgICAgIF0pLFxuICAgICAgICBfdm0uX3YoXCIgXCIpLFxuICAgICAgICBfYyhcbiAgICAgICAgICBcImRpdlwiLFxuICAgICAgICAgIHtcbiAgICAgICAgICAgIHN0YXRpY0NsYXNzOlxuICAgICAgICAgICAgICBcInJvdyBkLWZsZXgganVzdGlmeS1jb250ZW50LWJldHdlZW4gYWxpZ24taXRlbXMtY2VudGVyXCIsXG4gICAgICAgICAgfSxcbiAgICAgICAgICBbXG4gICAgICAgICAgICBfYyhcImRpdlwiLCB7XG4gICAgICAgICAgICAgIHN0YXRpY0NsYXNzOiBcImNvbCB0ZXh0LXN0YXJ0IHRleHQtZGFuZ2VyXCIsXG4gICAgICAgICAgICAgIHN0YXRpY1N0eWxlOiB7IFwiZm9udC1zaXplXCI6IFwiMTBweFwiIH0sXG4gICAgICAgICAgICAgIGF0dHJzOiB7IGlkOiBcInNob3dfbFwiIH0sXG4gICAgICAgICAgICB9KSxcbiAgICAgICAgICAgIF92bS5fdihcIiBcIiksXG4gICAgICAgICAgICBfYyhcbiAgICAgICAgICAgICAgXCJkaXZcIixcbiAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHN0YXRpY0NsYXNzOiBcImNvbCB0ZXh0LWRhcmsgdGV4dC1jZW50ZXJcIixcbiAgICAgICAgICAgICAgICBzdGF0aWNTdHlsZTogeyBcImZvbnQtc2l6ZVwiOiBcIjEwcHhcIiB9LFxuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICBbXG4gICAgICAgICAgICAgICAgX3ZtLl92KFxuICAgICAgICAgICAgICAgICAgXCJcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIERheSBSYW5nZVxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIlxuICAgICAgICAgICAgICAgICksXG4gICAgICAgICAgICAgIF1cbiAgICAgICAgICAgICksXG4gICAgICAgICAgICBfdm0uX3YoXCIgXCIpLFxuICAgICAgICAgICAgX2MoXCJkaXZcIiwge1xuICAgICAgICAgICAgICBzdGF0aWNDbGFzczogXCJjb2wgdGV4dC1lbmQgdGV4dC1zdWNjZXNzXCIsXG4gICAgICAgICAgICAgIHN0YXRpY1N0eWxlOiB7IFwiZm9udC1zaXplXCI6IFwiMTBweFwiIH0sXG4gICAgICAgICAgICAgIGF0dHJzOiB7IGlkOiBcInNob3dfaFwiIH0sXG4gICAgICAgICAgICB9KSxcbiAgICAgICAgICBdXG4gICAgICAgICksXG4gICAgICAgIF92bS5fdihcIiBcIiksXG4gICAgICAgIF9jKFwiZGl2XCIsIHsgc3RhdGljQ2xhc3M6IFwicm93IG10LTFcIiB9LCBbXG4gICAgICAgICAgX2MoXCJzbWFsbFwiLCB7IHN0YXRpY0NsYXNzOiBcImNvbCB0ZXh0LXN0YXJ0IHRleHQtZGFyayBjbGVhcmZpeFwiIH0sIFtcbiAgICAgICAgICAgIF92bS5fdihcIlZvbHVtZSAyNEhcIiksXG4gICAgICAgICAgXSksXG4gICAgICAgICAgX3ZtLl92KFwiIFwiKSxcbiAgICAgICAgICBfYyhcInNtYWxsXCIsIHtcbiAgICAgICAgICAgIHN0YXRpY0NsYXNzOiBcImNvbCB0ZXh0LWVuZCB0ZXh0LXdhcm5pbmcgY2xlYXJmaXhcIixcbiAgICAgICAgICAgIGF0dHJzOiB7IGlkOiBcInNob3dfdlwiIH0sXG4gICAgICAgICAgfSksXG4gICAgICAgICAgX3ZtLl92KFwiIFwiKSxcbiAgICAgICAgICBfYyhcImhyXCIpLFxuICAgICAgICBdKSxcbiAgICAgICAgX3ZtLl92KFwiIFwiKSxcbiAgICAgICAgX2MoXCJkaXZcIiwgeyBzdGF0aWNDbGFzczogXCJyb3dcIiB9LCBbXG4gICAgICAgICAgX2MoXCJzbWFsbFwiLCB7IHN0YXRpY0NsYXNzOiBcImNvbCB0ZXh0LXN0YXJ0IHRleHQtZGFyayBjbGVhcmZpeFwiIH0sIFtcbiAgICAgICAgICAgIF92bS5fdihcIk1hcmtldCBDYXBcIiksXG4gICAgICAgICAgXSksXG4gICAgICAgICAgX3ZtLl92KFwiIFwiKSxcbiAgICAgICAgICBfYyhcInNtYWxsXCIsIHtcbiAgICAgICAgICAgIHN0YXRpY0NsYXNzOiBcImNvbCB0ZXh0LWVuZCB0ZXh0LXdhcm5pbmcgY2xlYXJmaXhcIixcbiAgICAgICAgICAgIGF0dHJzOiB7IGlkOiBcInNob3dfbWNcIiB9LFxuICAgICAgICAgIH0pLFxuICAgICAgICAgIF92bS5fdihcIiBcIiksXG4gICAgICAgICAgX2MoXCJoclwiKSxcbiAgICAgICAgXSksXG4gICAgICAgIF92bS5fdihcIiBcIiksXG4gICAgICAgIF9jKFwiZGl2XCIsIHsgc3RhdGljQ2xhc3M6IFwicm93XCIgfSwgW1xuICAgICAgICAgIF9jKFwic21hbGxcIiwgeyBzdGF0aWNDbGFzczogXCJjb2wgdGV4dC1zdGFydCB0ZXh0LWRhcmsgY2xlYXJmaXhcIiB9LCBbXG4gICAgICAgICAgICBfdm0uX3YoXCJUb3RhbCBTdXBwbHlcIiksXG4gICAgICAgICAgXSksXG4gICAgICAgICAgX3ZtLl92KFwiIFwiKSxcbiAgICAgICAgICBfYyhcInNtYWxsXCIsIHtcbiAgICAgICAgICAgIHN0YXRpY0NsYXNzOiBcImNvbCB0ZXh0LWVuZCB0ZXh0LXdhcm5pbmcgY2xlYXJmaXhcIixcbiAgICAgICAgICAgIGF0dHJzOiB7IGlkOiBcInNob3dfdHNcIiB9LFxuICAgICAgICAgIH0pLFxuICAgICAgICAgIF92bS5fdihcIiBcIiksXG4gICAgICAgICAgX2MoXCJoclwiKSxcbiAgICAgICAgXSksXG4gICAgICBdKSxcbiAgICBdKVxuICB9LFxuICBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIF92bSA9IHRoaXNcbiAgICB2YXIgX2ggPSBfdm0uJGNyZWF0ZUVsZW1lbnRcbiAgICB2YXIgX2MgPSBfdm0uX3NlbGYuX2MgfHwgX2hcbiAgICByZXR1cm4gX2MoXG4gICAgICBcImRpdlwiLFxuICAgICAge1xuICAgICAgICBzdGF0aWNDbGFzczpcbiAgICAgICAgICBcImNvbGxhcHNlIGNvbC1sZy02IGNvbC1tZC0xMCBjb2wtc20tMTIgY29sLTEyIHBvc2l0aW9uLWFic29sdXRlIHN0aWNreS10b3AgY2FyZC0xMTAgXCIsXG4gICAgICAgIGF0dHJzOiB7IGlkOiBcImNvbGxhcHNlRGVwdGhcIiB9LFxuICAgICAgfSxcbiAgICAgIFtcbiAgICAgICAgX2MoXG4gICAgICAgICAgXCJkaXZcIixcbiAgICAgICAgICB7XG4gICAgICAgICAgICBzdGF0aWNDbGFzczogXCJjYXJkXCIsXG4gICAgICAgICAgICBzdGF0aWNTdHlsZToge1xuICAgICAgICAgICAgICBiYWNrZ3JvdW5kOiBcIiMxMzE3MjJlNiFpbXBvcnRhbnRcIixcbiAgICAgICAgICAgICAgXCJib3gtc2hhZG93XCI6IFwiMCA0cHggMjRweCAwIHJnYigwIDAgMCAvIDMwJSlcIixcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgfSxcbiAgICAgICAgICBbXG4gICAgICAgICAgICBfYyhcImRpdlwiLCB7IHN0YXRpY0NsYXNzOiBcImNhcmQtY29udGVudFwiIH0sIFtcbiAgICAgICAgICAgICAgX2MoXCJkaXZcIiwgeyBhdHRyczogeyBpZDogXCJjaGFydGRpdlwiIH0gfSksXG4gICAgICAgICAgICBdKSxcbiAgICAgICAgICBdXG4gICAgICAgICksXG4gICAgICBdXG4gICAgKVxuICB9LFxuICBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIF92bSA9IHRoaXNcbiAgICB2YXIgX2ggPSBfdm0uJGNyZWF0ZUVsZW1lbnRcbiAgICB2YXIgX2MgPSBfdm0uX3NlbGYuX2MgfHwgX2hcbiAgICByZXR1cm4gX2MoXG4gICAgICBcImRpdlwiLFxuICAgICAge1xuICAgICAgICBzdGF0aWNDbGFzczpcbiAgICAgICAgICBcImNvbGxhcHNlIGNvbC1sZy00IGNvbC1tZC00IGNvbC1zbS02IGNvbC0xMiBwb3NpdGlvbi1hYnNvbHV0ZSBzdGlja3ktdG9wIGNhcmQtMTEwXCIsXG4gICAgICAgIHN0YXRpY1N0eWxlOiB7IFwibWF4LXdpZHRoXCI6IFwiMjgwcHhcIiB9LFxuICAgICAgICBhdHRyczogeyBpZDogXCJjb2xsYXBzZU9yZGVyc1wiIH0sXG4gICAgICB9LFxuICAgICAgW1xuICAgICAgICBfYyhcbiAgICAgICAgICBcImRpdlwiLFxuICAgICAgICAgIHtcbiAgICAgICAgICAgIHN0YXRpY0NsYXNzOiBcImNhcmRcIixcbiAgICAgICAgICAgIHN0YXRpY1N0eWxlOiB7XG4gICAgICAgICAgICAgIGJhY2tncm91bmQ6IFwiIzEzMTcyMmU2IWltcG9ydGFudFwiLFxuICAgICAgICAgICAgICBcImJveC1zaGFkb3dcIjogXCIwIDRweCAyNHB4IDAgcmdiKDAgMCAwIC8gMzAlKVwiLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICB9LFxuICAgICAgICAgIFtcbiAgICAgICAgICAgIF9jKFwiZGl2XCIsIHsgc3RhdGljQ2xhc3M6IFwiY2FyZC1jb250ZW50IG15LTFcIiB9LCBbXG4gICAgICAgICAgICAgIF9jKFwiZGl2XCIsIHsgc3RhdGljQ2xhc3M6IFwiYm94XCIgfSwgW1xuICAgICAgICAgICAgICAgIF9jKFwidGFibGVcIiwgW1xuICAgICAgICAgICAgICAgICAgX2MoXCJ0aGVhZFwiLCBbXG4gICAgICAgICAgICAgICAgICAgIF9jKFwidHJcIiwgeyBzdGF0aWNDbGFzczogXCJtYi0xXCIgfSwgW1xuICAgICAgICAgICAgICAgICAgICAgIF9jKFwidGhcIiwgeyBzdGF0aWNDbGFzczogXCJ0ZXh0LXN0YXJ0IHBzLTEgdGV4dC1kYXJrXCIgfSwgW1xuICAgICAgICAgICAgICAgICAgICAgICAgX3ZtLl92KFxuICAgICAgICAgICAgICAgICAgICAgICAgICBcIlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBQcmljZVxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiXG4gICAgICAgICAgICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgICAgICAgICAgIF0pLFxuICAgICAgICAgICAgICAgICAgICAgIF92bS5fdihcIiBcIiksXG4gICAgICAgICAgICAgICAgICAgICAgX2MoXCJ0aFwiLCB7IHN0YXRpY0NsYXNzOiBcInRleHQtY2VudGVyIHBzLTEgdGV4dC1kYXJrXCIgfSwgW1xuICAgICAgICAgICAgICAgICAgICAgICAgX3ZtLl92KFxuICAgICAgICAgICAgICAgICAgICAgICAgICBcIlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBRdWFudGl0eVxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiXG4gICAgICAgICAgICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgICAgICAgICAgIF0pLFxuICAgICAgICAgICAgICAgICAgICAgIF92bS5fdihcIiBcIiksXG4gICAgICAgICAgICAgICAgICAgICAgX2MoXCJ0aFwiLCB7IHN0YXRpY0NsYXNzOiBcInRleHQtZW5kIHBlLTEgdGV4dC1kYXJrXCIgfSwgW1xuICAgICAgICAgICAgICAgICAgICAgICAgX3ZtLl92KFxuICAgICAgICAgICAgICAgICAgICAgICAgICBcIlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBUb3RhbFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiXG4gICAgICAgICAgICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgICAgICAgICAgIF0pLFxuICAgICAgICAgICAgICAgICAgICBdKSxcbiAgICAgICAgICAgICAgICAgIF0pLFxuICAgICAgICAgICAgICAgIF0pLFxuICAgICAgICAgICAgICAgIF92bS5fdihcIiBcIiksXG4gICAgICAgICAgICAgICAgX2MoXCJ0YWJsZVwiLCB7IHN0YXRpY0NsYXNzOiBcImFza3NcIiB9KSxcbiAgICAgICAgICAgICAgICBfdm0uX3YoXCIgXCIpLFxuICAgICAgICAgICAgICAgIF9jKFwiZGl2XCIsIHsgc3RhdGljQ2xhc3M6IFwibmV3ZXN0XCIgfSksXG4gICAgICAgICAgICAgICAgX3ZtLl92KFwiIFwiKSxcbiAgICAgICAgICAgICAgICBfYyhcInRhYmxlXCIsIHsgc3RhdGljQ2xhc3M6IFwiYmlkc1wiIH0pLFxuICAgICAgICAgICAgICBdKSxcbiAgICAgICAgICAgIF0pLFxuICAgICAgICAgIF1cbiAgICAgICAgKSxcbiAgICAgIF1cbiAgICApXG4gIH0sXG5dXG5yZW5kZXIuX3dpdGhTdHJpcHBlZCA9IHRydWVcblxuZXhwb3J0IHsgcmVuZGVyLCBzdGF0aWNSZW5kZXJGbnMgfSIsInZhciByZW5kZXIgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBfdm0gPSB0aGlzXG4gIHZhciBfaCA9IF92bS4kY3JlYXRlRWxlbWVudFxuICB2YXIgX2MgPSBfdm0uX3NlbGYuX2MgfHwgX2hcbiAgcmV0dXJuIF9jKFwic3BhblwiLCBbXG4gICAgX3ZtLnR5cGUgPT09IFwidGV4dFwiIHx8ICFfdm0udHlwZVxuICAgICAgPyBfYyhcImlucHV0XCIsIHtcbiAgICAgICAgICBzdGF0aWNDbGFzczogXCJ0dmpzLXN0ZC1pbnB1dFwiLFxuICAgICAgICAgIHN0eWxlOiBfdm0uc3R5bGUsXG4gICAgICAgICAgYXR0cnM6IHsgcGxhY2Vob2xkZXI6IF92bS5uYW1lIH0sXG4gICAgICAgICAgZG9tUHJvcHM6IHsgdmFsdWU6IF92bS52YWx1ZSB9LFxuICAgICAgICAgIG9uOiB7XG4gICAgICAgICAgICBjaGFuZ2U6IGZ1bmN0aW9uICgkZXZlbnQpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIF92bS4kZW1pdChcImNoYW5nZVwiLCAkZXZlbnQudGFyZ2V0LnZhbHVlKVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGlucHV0OiBmdW5jdGlvbiAoJGV2ZW50KSB7XG4gICAgICAgICAgICAgIHJldHVybiBfdm0uJGVtaXQoXCJpbnB1dFwiLCAkZXZlbnQudGFyZ2V0LnZhbHVlKVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICB9LFxuICAgICAgICB9KVxuICAgICAgOiBfdm0udHlwZSA9PT0gXCJzZWxlY3RcIlxuICAgICAgPyBfYyhcbiAgICAgICAgICBcInNlbGVjdFwiLFxuICAgICAgICAgIHtcbiAgICAgICAgICAgIHN0YXRpY0NsYXNzOiBcInR2anMtc3RkLWlucHV0XCIsXG4gICAgICAgICAgICBzdHlsZTogX3ZtLnN0eWxlLFxuICAgICAgICAgICAgZG9tUHJvcHM6IHsgdmFsdWU6IF92bS52YWx1ZSB9LFxuICAgICAgICAgICAgb246IHtcbiAgICAgICAgICAgICAgaW5wdXQ6IGZ1bmN0aW9uICgkZXZlbnQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gX3ZtLiRlbWl0KFwiaW5wdXRcIiwgJGV2ZW50LnRhcmdldC52YWx1ZSlcbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgfSxcbiAgICAgICAgICBfdm0uX2woX3ZtLmxpc3QsIGZ1bmN0aW9uIChvcHQpIHtcbiAgICAgICAgICAgIHJldHVybiBfYyhcIm9wdGlvblwiLCBbX3ZtLl92KF92bS5fcyhvcHQpKV0pXG4gICAgICAgICAgfSksXG4gICAgICAgICAgMFxuICAgICAgICApXG4gICAgICA6IF92bS5fZSgpLFxuICBdKVxufVxudmFyIHN0YXRpY1JlbmRlckZucyA9IFtdXG5yZW5kZXIuX3dpdGhTdHJpcHBlZCA9IHRydWVcblxuZXhwb3J0IHsgcmVuZGVyLCBzdGF0aWNSZW5kZXJGbnMgfSIsInZhciByZW5kZXIgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBfdm0gPSB0aGlzXG4gIHZhciBfaCA9IF92bS4kY3JlYXRlRWxlbWVudFxuICB2YXIgX2MgPSBfdm0uX3NlbGYuX2MgfHwgX2hcbiAgcmV0dXJuIF9jKFxuICAgIFwiZGl2XCIsXG4gICAgeyByZWY6IFwid2luXCIsIHN0YXRpY0NsYXNzOiBcInR2anMteC13aW5kb3dcIiwgc3R5bGU6IF92bS5zdHlsZSB9LFxuICAgIFtcbiAgICAgIF9jKFwiZGl2XCIsIHsgc3RhdGljQ2xhc3M6IFwidHZqcy14LXdpbmRvdy1oZWFkXCIgfSwgW1xuICAgICAgICBfYyhcbiAgICAgICAgICBcImRpdlwiLFxuICAgICAgICAgIHtcbiAgICAgICAgICAgIHN0YXRpY0NsYXNzOiBcInR2anMteC13aW5kb3ctdGl0bGVcIixcbiAgICAgICAgICAgIG9uOiB7IG1vdXNlZG93bjogX3ZtLm9uTW91c2VEb3duIH0sXG4gICAgICAgICAgfSxcbiAgICAgICAgICBbX3ZtLl92KFwiXFxuICAgICAgICAgICAgICAgIFwiICsgX3ZtLl9zKF92bS50aXRsZSkgKyBcIlxcbiAgICAgICAgICAgIFwiKV1cbiAgICAgICAgKSxcbiAgICAgICAgX3ZtLl92KFwiIFwiKSxcbiAgICAgICAgX2MoXG4gICAgICAgICAgXCJkaXZcIixcbiAgICAgICAgICB7XG4gICAgICAgICAgICBzdGF0aWNDbGFzczogXCJ0dmpzLXgtd2luZG93LWNsb3NlXCIsXG4gICAgICAgICAgICBvbjoge1xuICAgICAgICAgICAgICBjbGljazogZnVuY3Rpb24gKCRldmVudCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBfdm0uJGVtaXQoXCJjbG9zZVwiKVxuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICB9LFxuICAgICAgICAgIFtfdm0uX3YoXCJcXG4gICAgICAgICAgICAgICAg4pWzXFxuICAgICAgICAgICAgXCIpXVxuICAgICAgICApLFxuICAgICAgXSksXG4gICAgICBfdm0uX3YoXCIgXCIpLFxuICAgICAgX2MoXCJkaXZcIiwgeyBzdGF0aWNDbGFzczogXCJ0dmpzLXgtd2luZG93LWJvZHlcIiB9LCBbX3ZtLl90KFwiZGVmYXVsdFwiKV0sIDIpLFxuICAgIF1cbiAgKVxufVxudmFyIHN0YXRpY1JlbmRlckZucyA9IFtdXG5yZW5kZXIuX3dpdGhTdHJpcHBlZCA9IHRydWVcblxuZXhwb3J0IHsgcmVuZGVyLCBzdGF0aWNSZW5kZXJGbnMgfSIsInZhciByZW5kZXIgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBfdm0gPSB0aGlzXG4gIHZhciBfaCA9IF92bS4kY3JlYXRlRWxlbWVudFxuICB2YXIgX2MgPSBfdm0uX3NlbGYuX2MgfHwgX2hcbiAgcmV0dXJuIF9jKFwic3BhblwiLCB7XG4gICAgc3RhdGljQ2xhc3M6IFwiaC1zcGxpdHRlclwiLFxuICAgIHN0eWxlOiBfdm0uaHNfc3R5bGUsXG4gICAgb246IHsgbW91c2Vkb3duOiBfdm0uaHNfbW91c2Vkb3duIH0sXG4gIH0pXG59XG52YXIgc3RhdGljUmVuZGVyRm5zID0gW11cbnJlbmRlci5fd2l0aFN0cmlwcGVkID0gdHJ1ZVxuXG5leHBvcnQgeyByZW5kZXIsIHN0YXRpY1JlbmRlckZucyB9IiwidmFyIHJlbmRlciA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIF92bSA9IHRoaXNcbiAgdmFyIF9oID0gX3ZtLiRjcmVhdGVFbGVtZW50XG4gIHZhciBfYyA9IF92bS5fc2VsZi5fYyB8fCBfaFxuICByZXR1cm4gX2MoXG4gICAgXCJ3aW5kb3dcIixcbiAgICB7XG4gICAgICBzdGF0aWNDbGFzczogXCJhZGQtd2luXCIsXG4gICAgICBhdHRyczogeyB0aXRsZTogXCJBZGQgSW5kaWNhdG9yXCIsIHR2OiBfdm0udHYgfSxcbiAgICAgIG9uOiB7IGNsb3NlOiBfdm0ub25fY2xvc2UgfSxcbiAgICB9LFxuICAgIFtcbiAgICAgIF9jKFxuICAgICAgICBcImRpdlwiLFxuICAgICAgICB7IHN0YXRpY0NsYXNzOiBcImFkZC13aW4tbGlzdFwiIH0sXG4gICAgICAgIF92bS5fbChfdm0ub3ZzLCBmdW5jdGlvbiAob3YpIHtcbiAgICAgICAgICByZXR1cm4gX2MoXG4gICAgICAgICAgICBcImRpdlwiLFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICBzdGF0aWNDbGFzczogXCJhZGQtd2luLWl0ZW1cIixcbiAgICAgICAgICAgICAgb246IHtcbiAgICAgICAgICAgICAgICBjbGljazogZnVuY3Rpb24gKCRldmVudCkge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIF92bS5vbl9jbGljayhvdi5uYW1lKVxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgW1xuICAgICAgICAgICAgICBfYyhcInNwYW5cIiwgW192bS5fdihfdm0uX3Mob3YubmFtZSkpXSksXG4gICAgICAgICAgICAgIF92bS5fdihcIiBcIiksXG4gICAgICAgICAgICAgIF9jKFwic3BhblwiLCB7IHN0YXRpY0NsYXNzOiBcImFkZC13aW4taXRlbS1kZXNjXCIgfSwgW1xuICAgICAgICAgICAgICAgIF92bS5fdihcbiAgICAgICAgICAgICAgICAgIFwiXFxuICAgICAgICAgICAgICAgIFwiICtcbiAgICAgICAgICAgICAgICAgICAgX3ZtLl9zKG92Lm1ldGhvZHMubWV0YV9pbmZvKCkuZGVzYykgK1xuICAgICAgICAgICAgICAgICAgICBcIlxcbiAgICAgICAgICAgIFwiXG4gICAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICAgXSksXG4gICAgICAgICAgICBdXG4gICAgICAgICAgKVxuICAgICAgICB9KSxcbiAgICAgICAgMFxuICAgICAgKSxcbiAgICBdXG4gIClcbn1cbnZhciBzdGF0aWNSZW5kZXJGbnMgPSBbXVxucmVuZGVyLl93aXRoU3RyaXBwZWQgPSB0cnVlXG5cbmV4cG9ydCB7IHJlbmRlciwgc3RhdGljUmVuZGVyRm5zIH0iLCJ2YXIgcmVuZGVyID0gZnVuY3Rpb24gKCkge1xuICB2YXIgX3ZtID0gdGhpc1xuICB2YXIgX2ggPSBfdm0uJGNyZWF0ZUVsZW1lbnRcbiAgdmFyIF9jID0gX3ZtLl9zZWxmLl9jIHx8IF9oXG4gIHJldHVybiBfYyhcbiAgICBcIndpbmRvd1wiLFxuICAgIHtcbiAgICAgIHN0YXRpY0NsYXNzOiBcInNldHQtd2luXCIsXG4gICAgICBhdHRyczogeyB0aXRsZTogX3ZtLmRhdGEub3YubmFtZSwgdHY6IF92bS50diB9LFxuICAgICAgb246IHsgY2xvc2U6IF92bS5vbl9jbG9zZSB9LFxuICAgIH0sXG4gICAgW1xuICAgICAgX3ZtLl9sKF92bS5zZXR0bGlzdCwgZnVuY3Rpb24gKGspIHtcbiAgICAgICAgcmV0dXJuIF9jKFxuICAgICAgICAgIFwiZGl2XCIsXG4gICAgICAgICAgeyBzdGF0aWNDbGFzczogXCJzZXR0LXdpbi1pdGVtXCIgfSxcbiAgICAgICAgICBbXG4gICAgICAgICAgICBfYyhcImxhYmVsXCIsIFtfdm0uX3YoX3ZtLl9zKF92bS5zMmQoaykpKV0pLFxuICAgICAgICAgICAgX3ZtLl92KFwiIFwiKSxcbiAgICAgICAgICAgIF9jKFwic3RkLWlucHV0XCIsIHtcbiAgICAgICAgICAgICAgYXR0cnM6IHsgdmFsdWU6IF92bS5zZXR0W2tdIH0sXG4gICAgICAgICAgICAgIG9uOiB7XG4gICAgICAgICAgICAgICAgaW5wdXQ6IGZ1bmN0aW9uICgkZXZlbnQpIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiBfdm0udXBkYXRlX3NldHQoaywgJGV2ZW50KVxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9KSxcbiAgICAgICAgICBdLFxuICAgICAgICAgIDFcbiAgICAgICAgKVxuICAgICAgfSksXG4gICAgICBfdm0uX3YoXCIgXCIpLFxuICAgICAgIV92bS5zZXR0bGlzdC5sZW5ndGhcbiAgICAgICAgPyBfYyhcInNwYW5cIiwgeyBzdGF0aWNDbGFzczogXCJzZXR0LXdpbi1lbXB0eVwiIH0sIFtcbiAgICAgICAgICAgIF9jKFwiaVwiLCBbX3ZtLl92KFwiTm8gc2NyaXB0IHNldHRpbmdzXCIpXSksXG4gICAgICAgICAgXSlcbiAgICAgICAgOiBfdm0uX2UoKSxcbiAgICBdLFxuICAgIDJcbiAgKVxufVxudmFyIHN0YXRpY1JlbmRlckZucyA9IFtdXG5yZW5kZXIuX3dpdGhTdHJpcHBlZCA9IHRydWVcblxuZXhwb3J0IHsgcmVuZGVyLCBzdGF0aWNSZW5kZXJGbnMgfSIsIi8qIGdsb2JhbHMgX19WVUVfU1NSX0NPTlRFWFRfXyAqL1xuXG4vLyBJTVBPUlRBTlQ6IERvIE5PVCB1c2UgRVMyMDE1IGZlYXR1cmVzIGluIHRoaXMgZmlsZSAoZXhjZXB0IGZvciBtb2R1bGVzKS5cbi8vIFRoaXMgbW9kdWxlIGlzIGEgcnVudGltZSB1dGlsaXR5IGZvciBjbGVhbmVyIGNvbXBvbmVudCBtb2R1bGUgb3V0cHV0IGFuZCB3aWxsXG4vLyBiZSBpbmNsdWRlZCBpbiB0aGUgZmluYWwgd2VicGFjayB1c2VyIGJ1bmRsZS5cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gbm9ybWFsaXplQ29tcG9uZW50IChcbiAgc2NyaXB0RXhwb3J0cyxcbiAgcmVuZGVyLFxuICBzdGF0aWNSZW5kZXJGbnMsXG4gIGZ1bmN0aW9uYWxUZW1wbGF0ZSxcbiAgaW5qZWN0U3R5bGVzLFxuICBzY29wZUlkLFxuICBtb2R1bGVJZGVudGlmaWVyLCAvKiBzZXJ2ZXIgb25seSAqL1xuICBzaGFkb3dNb2RlIC8qIHZ1ZS1jbGkgb25seSAqL1xuKSB7XG4gIC8vIFZ1ZS5leHRlbmQgY29uc3RydWN0b3IgZXhwb3J0IGludGVyb3BcbiAgdmFyIG9wdGlvbnMgPSB0eXBlb2Ygc2NyaXB0RXhwb3J0cyA9PT0gJ2Z1bmN0aW9uJ1xuICAgID8gc2NyaXB0RXhwb3J0cy5vcHRpb25zXG4gICAgOiBzY3JpcHRFeHBvcnRzXG5cbiAgLy8gcmVuZGVyIGZ1bmN0aW9uc1xuICBpZiAocmVuZGVyKSB7XG4gICAgb3B0aW9ucy5yZW5kZXIgPSByZW5kZXJcbiAgICBvcHRpb25zLnN0YXRpY1JlbmRlckZucyA9IHN0YXRpY1JlbmRlckZuc1xuICAgIG9wdGlvbnMuX2NvbXBpbGVkID0gdHJ1ZVxuICB9XG5cbiAgLy8gZnVuY3Rpb25hbCB0ZW1wbGF0ZVxuICBpZiAoZnVuY3Rpb25hbFRlbXBsYXRlKSB7XG4gICAgb3B0aW9ucy5mdW5jdGlvbmFsID0gdHJ1ZVxuICB9XG5cbiAgLy8gc2NvcGVkSWRcbiAgaWYgKHNjb3BlSWQpIHtcbiAgICBvcHRpb25zLl9zY29wZUlkID0gJ2RhdGEtdi0nICsgc2NvcGVJZFxuICB9XG5cbiAgdmFyIGhvb2tcbiAgaWYgKG1vZHVsZUlkZW50aWZpZXIpIHsgLy8gc2VydmVyIGJ1aWxkXG4gICAgaG9vayA9IGZ1bmN0aW9uIChjb250ZXh0KSB7XG4gICAgICAvLyAyLjMgaW5qZWN0aW9uXG4gICAgICBjb250ZXh0ID1cbiAgICAgICAgY29udGV4dCB8fCAvLyBjYWNoZWQgY2FsbFxuICAgICAgICAodGhpcy4kdm5vZGUgJiYgdGhpcy4kdm5vZGUuc3NyQ29udGV4dCkgfHwgLy8gc3RhdGVmdWxcbiAgICAgICAgKHRoaXMucGFyZW50ICYmIHRoaXMucGFyZW50LiR2bm9kZSAmJiB0aGlzLnBhcmVudC4kdm5vZGUuc3NyQ29udGV4dCkgLy8gZnVuY3Rpb25hbFxuICAgICAgLy8gMi4yIHdpdGggcnVuSW5OZXdDb250ZXh0OiB0cnVlXG4gICAgICBpZiAoIWNvbnRleHQgJiYgdHlwZW9mIF9fVlVFX1NTUl9DT05URVhUX18gIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIGNvbnRleHQgPSBfX1ZVRV9TU1JfQ09OVEVYVF9fXG4gICAgICB9XG4gICAgICAvLyBpbmplY3QgY29tcG9uZW50IHN0eWxlc1xuICAgICAgaWYgKGluamVjdFN0eWxlcykge1xuICAgICAgICBpbmplY3RTdHlsZXMuY2FsbCh0aGlzLCBjb250ZXh0KVxuICAgICAgfVxuICAgICAgLy8gcmVnaXN0ZXIgY29tcG9uZW50IG1vZHVsZSBpZGVudGlmaWVyIGZvciBhc3luYyBjaHVuayBpbmZlcnJlbmNlXG4gICAgICBpZiAoY29udGV4dCAmJiBjb250ZXh0Ll9yZWdpc3RlcmVkQ29tcG9uZW50cykge1xuICAgICAgICBjb250ZXh0Ll9yZWdpc3RlcmVkQ29tcG9uZW50cy5hZGQobW9kdWxlSWRlbnRpZmllcilcbiAgICAgIH1cbiAgICB9XG4gICAgLy8gdXNlZCBieSBzc3IgaW4gY2FzZSBjb21wb25lbnQgaXMgY2FjaGVkIGFuZCBiZWZvcmVDcmVhdGVcbiAgICAvLyBuZXZlciBnZXRzIGNhbGxlZFxuICAgIG9wdGlvbnMuX3NzclJlZ2lzdGVyID0gaG9va1xuICB9IGVsc2UgaWYgKGluamVjdFN0eWxlcykge1xuICAgIGhvb2sgPSBzaGFkb3dNb2RlXG4gICAgICA/IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaW5qZWN0U3R5bGVzLmNhbGwoXG4gICAgICAgICAgdGhpcyxcbiAgICAgICAgICAob3B0aW9ucy5mdW5jdGlvbmFsID8gdGhpcy5wYXJlbnQgOiB0aGlzKS4kcm9vdC4kb3B0aW9ucy5zaGFkb3dSb290XG4gICAgICAgIClcbiAgICAgIH1cbiAgICAgIDogaW5qZWN0U3R5bGVzXG4gIH1cblxuICBpZiAoaG9vaykge1xuICAgIGlmIChvcHRpb25zLmZ1bmN0aW9uYWwpIHtcbiAgICAgIC8vIGZvciB0ZW1wbGF0ZS1vbmx5IGhvdC1yZWxvYWQgYmVjYXVzZSBpbiB0aGF0IGNhc2UgdGhlIHJlbmRlciBmbiBkb2Vzbid0XG4gICAgICAvLyBnbyB0aHJvdWdoIHRoZSBub3JtYWxpemVyXG4gICAgICBvcHRpb25zLl9pbmplY3RTdHlsZXMgPSBob29rXG4gICAgICAvLyByZWdpc3RlciBmb3IgZnVuY3Rpb25hbCBjb21wb25lbnQgaW4gdnVlIGZpbGVcbiAgICAgIHZhciBvcmlnaW5hbFJlbmRlciA9IG9wdGlvbnMucmVuZGVyXG4gICAgICBvcHRpb25zLnJlbmRlciA9IGZ1bmN0aW9uIHJlbmRlcldpdGhTdHlsZUluamVjdGlvbiAoaCwgY29udGV4dCkge1xuICAgICAgICBob29rLmNhbGwoY29udGV4dClcbiAgICAgICAgcmV0dXJuIG9yaWdpbmFsUmVuZGVyKGgsIGNvbnRleHQpXG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGluamVjdCBjb21wb25lbnQgcmVnaXN0cmF0aW9uIGFzIGJlZm9yZUNyZWF0ZSBob29rXG4gICAgICB2YXIgZXhpc3RpbmcgPSBvcHRpb25zLmJlZm9yZUNyZWF0ZVxuICAgICAgb3B0aW9ucy5iZWZvcmVDcmVhdGUgPSBleGlzdGluZ1xuICAgICAgICA/IFtdLmNvbmNhdChleGlzdGluZywgaG9vaylcbiAgICAgICAgOiBbaG9va11cbiAgICB9XG4gIH1cblxuICByZXR1cm4ge1xuICAgIGV4cG9ydHM6IHNjcmlwdEV4cG9ydHMsXG4gICAgb3B0aW9uczogb3B0aW9uc1xuICB9XG59XG4iLCIvKiFcbiAqIFZ1ZS5qcyB2Mi42LjE0XG4gKiAoYykgMjAxNC0yMDIxIEV2YW4gWW91XG4gKiBSZWxlYXNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG4gKi9cbi8qICAqL1xuXG52YXIgZW1wdHlPYmplY3QgPSBPYmplY3QuZnJlZXplKHt9KTtcblxuLy8gVGhlc2UgaGVscGVycyBwcm9kdWNlIGJldHRlciBWTSBjb2RlIGluIEpTIGVuZ2luZXMgZHVlIHRvIHRoZWlyXG4vLyBleHBsaWNpdG5lc3MgYW5kIGZ1bmN0aW9uIGlubGluaW5nLlxuZnVuY3Rpb24gaXNVbmRlZiAodikge1xuICByZXR1cm4gdiA9PT0gdW5kZWZpbmVkIHx8IHYgPT09IG51bGxcbn1cblxuZnVuY3Rpb24gaXNEZWYgKHYpIHtcbiAgcmV0dXJuIHYgIT09IHVuZGVmaW5lZCAmJiB2ICE9PSBudWxsXG59XG5cbmZ1bmN0aW9uIGlzVHJ1ZSAodikge1xuICByZXR1cm4gdiA9PT0gdHJ1ZVxufVxuXG5mdW5jdGlvbiBpc0ZhbHNlICh2KSB7XG4gIHJldHVybiB2ID09PSBmYWxzZVxufVxuXG4vKipcbiAqIENoZWNrIGlmIHZhbHVlIGlzIHByaW1pdGl2ZS5cbiAqL1xuZnVuY3Rpb24gaXNQcmltaXRpdmUgKHZhbHVlKSB7XG4gIHJldHVybiAoXG4gICAgdHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJyB8fFxuICAgIHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicgfHxcbiAgICAvLyAkZmxvdy1kaXNhYmxlLWxpbmVcbiAgICB0eXBlb2YgdmFsdWUgPT09ICdzeW1ib2wnIHx8XG4gICAgdHlwZW9mIHZhbHVlID09PSAnYm9vbGVhbidcbiAgKVxufVxuXG4vKipcbiAqIFF1aWNrIG9iamVjdCBjaGVjayAtIHRoaXMgaXMgcHJpbWFyaWx5IHVzZWQgdG8gdGVsbFxuICogT2JqZWN0cyBmcm9tIHByaW1pdGl2ZSB2YWx1ZXMgd2hlbiB3ZSBrbm93IHRoZSB2YWx1ZVxuICogaXMgYSBKU09OLWNvbXBsaWFudCB0eXBlLlxuICovXG5mdW5jdGlvbiBpc09iamVjdCAob2JqKSB7XG4gIHJldHVybiBvYmogIT09IG51bGwgJiYgdHlwZW9mIG9iaiA9PT0gJ29iamVjdCdcbn1cblxuLyoqXG4gKiBHZXQgdGhlIHJhdyB0eXBlIHN0cmluZyBvZiBhIHZhbHVlLCBlLmcuLCBbb2JqZWN0IE9iamVjdF0uXG4gKi9cbnZhciBfdG9TdHJpbmcgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nO1xuXG5mdW5jdGlvbiB0b1Jhd1R5cGUgKHZhbHVlKSB7XG4gIHJldHVybiBfdG9TdHJpbmcuY2FsbCh2YWx1ZSkuc2xpY2UoOCwgLTEpXG59XG5cbi8qKlxuICogU3RyaWN0IG9iamVjdCB0eXBlIGNoZWNrLiBPbmx5IHJldHVybnMgdHJ1ZVxuICogZm9yIHBsYWluIEphdmFTY3JpcHQgb2JqZWN0cy5cbiAqL1xuZnVuY3Rpb24gaXNQbGFpbk9iamVjdCAob2JqKSB7XG4gIHJldHVybiBfdG9TdHJpbmcuY2FsbChvYmopID09PSAnW29iamVjdCBPYmplY3RdJ1xufVxuXG5mdW5jdGlvbiBpc1JlZ0V4cCAodikge1xuICByZXR1cm4gX3RvU3RyaW5nLmNhbGwodikgPT09ICdbb2JqZWN0IFJlZ0V4cF0nXG59XG5cbi8qKlxuICogQ2hlY2sgaWYgdmFsIGlzIGEgdmFsaWQgYXJyYXkgaW5kZXguXG4gKi9cbmZ1bmN0aW9uIGlzVmFsaWRBcnJheUluZGV4ICh2YWwpIHtcbiAgdmFyIG4gPSBwYXJzZUZsb2F0KFN0cmluZyh2YWwpKTtcbiAgcmV0dXJuIG4gPj0gMCAmJiBNYXRoLmZsb29yKG4pID09PSBuICYmIGlzRmluaXRlKHZhbClcbn1cblxuZnVuY3Rpb24gaXNQcm9taXNlICh2YWwpIHtcbiAgcmV0dXJuIChcbiAgICBpc0RlZih2YWwpICYmXG4gICAgdHlwZW9mIHZhbC50aGVuID09PSAnZnVuY3Rpb24nICYmXG4gICAgdHlwZW9mIHZhbC5jYXRjaCA9PT0gJ2Z1bmN0aW9uJ1xuICApXG59XG5cbi8qKlxuICogQ29udmVydCBhIHZhbHVlIHRvIGEgc3RyaW5nIHRoYXQgaXMgYWN0dWFsbHkgcmVuZGVyZWQuXG4gKi9cbmZ1bmN0aW9uIHRvU3RyaW5nICh2YWwpIHtcbiAgcmV0dXJuIHZhbCA9PSBudWxsXG4gICAgPyAnJ1xuICAgIDogQXJyYXkuaXNBcnJheSh2YWwpIHx8IChpc1BsYWluT2JqZWN0KHZhbCkgJiYgdmFsLnRvU3RyaW5nID09PSBfdG9TdHJpbmcpXG4gICAgICA/IEpTT04uc3RyaW5naWZ5KHZhbCwgbnVsbCwgMilcbiAgICAgIDogU3RyaW5nKHZhbClcbn1cblxuLyoqXG4gKiBDb252ZXJ0IGFuIGlucHV0IHZhbHVlIHRvIGEgbnVtYmVyIGZvciBwZXJzaXN0ZW5jZS5cbiAqIElmIHRoZSBjb252ZXJzaW9uIGZhaWxzLCByZXR1cm4gb3JpZ2luYWwgc3RyaW5nLlxuICovXG5mdW5jdGlvbiB0b051bWJlciAodmFsKSB7XG4gIHZhciBuID0gcGFyc2VGbG9hdCh2YWwpO1xuICByZXR1cm4gaXNOYU4obikgPyB2YWwgOiBuXG59XG5cbi8qKlxuICogTWFrZSBhIG1hcCBhbmQgcmV0dXJuIGEgZnVuY3Rpb24gZm9yIGNoZWNraW5nIGlmIGEga2V5XG4gKiBpcyBpbiB0aGF0IG1hcC5cbiAqL1xuZnVuY3Rpb24gbWFrZU1hcCAoXG4gIHN0cixcbiAgZXhwZWN0c0xvd2VyQ2FzZVxuKSB7XG4gIHZhciBtYXAgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICB2YXIgbGlzdCA9IHN0ci5zcGxpdCgnLCcpO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyBpKyspIHtcbiAgICBtYXBbbGlzdFtpXV0gPSB0cnVlO1xuICB9XG4gIHJldHVybiBleHBlY3RzTG93ZXJDYXNlXG4gICAgPyBmdW5jdGlvbiAodmFsKSB7IHJldHVybiBtYXBbdmFsLnRvTG93ZXJDYXNlKCldOyB9XG4gICAgOiBmdW5jdGlvbiAodmFsKSB7IHJldHVybiBtYXBbdmFsXTsgfVxufVxuXG4vKipcbiAqIENoZWNrIGlmIGEgdGFnIGlzIGEgYnVpbHQtaW4gdGFnLlxuICovXG52YXIgaXNCdWlsdEluVGFnID0gbWFrZU1hcCgnc2xvdCxjb21wb25lbnQnLCB0cnVlKTtcblxuLyoqXG4gKiBDaGVjayBpZiBhbiBhdHRyaWJ1dGUgaXMgYSByZXNlcnZlZCBhdHRyaWJ1dGUuXG4gKi9cbnZhciBpc1Jlc2VydmVkQXR0cmlidXRlID0gbWFrZU1hcCgna2V5LHJlZixzbG90LHNsb3Qtc2NvcGUsaXMnKTtcblxuLyoqXG4gKiBSZW1vdmUgYW4gaXRlbSBmcm9tIGFuIGFycmF5LlxuICovXG5mdW5jdGlvbiByZW1vdmUgKGFyciwgaXRlbSkge1xuICBpZiAoYXJyLmxlbmd0aCkge1xuICAgIHZhciBpbmRleCA9IGFyci5pbmRleE9mKGl0ZW0pO1xuICAgIGlmIChpbmRleCA+IC0xKSB7XG4gICAgICByZXR1cm4gYXJyLnNwbGljZShpbmRleCwgMSlcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBDaGVjayB3aGV0aGVyIGFuIG9iamVjdCBoYXMgdGhlIHByb3BlcnR5LlxuICovXG52YXIgaGFzT3duUHJvcGVydHkgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xuZnVuY3Rpb24gaGFzT3duIChvYmosIGtleSkge1xuICByZXR1cm4gaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGtleSlcbn1cblxuLyoqXG4gKiBDcmVhdGUgYSBjYWNoZWQgdmVyc2lvbiBvZiBhIHB1cmUgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIGNhY2hlZCAoZm4pIHtcbiAgdmFyIGNhY2hlID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgcmV0dXJuIChmdW5jdGlvbiBjYWNoZWRGbiAoc3RyKSB7XG4gICAgdmFyIGhpdCA9IGNhY2hlW3N0cl07XG4gICAgcmV0dXJuIGhpdCB8fCAoY2FjaGVbc3RyXSA9IGZuKHN0cikpXG4gIH0pXG59XG5cbi8qKlxuICogQ2FtZWxpemUgYSBoeXBoZW4tZGVsaW1pdGVkIHN0cmluZy5cbiAqL1xudmFyIGNhbWVsaXplUkUgPSAvLShcXHcpL2c7XG52YXIgY2FtZWxpemUgPSBjYWNoZWQoZnVuY3Rpb24gKHN0cikge1xuICByZXR1cm4gc3RyLnJlcGxhY2UoY2FtZWxpemVSRSwgZnVuY3Rpb24gKF8sIGMpIHsgcmV0dXJuIGMgPyBjLnRvVXBwZXJDYXNlKCkgOiAnJzsgfSlcbn0pO1xuXG4vKipcbiAqIENhcGl0YWxpemUgYSBzdHJpbmcuXG4gKi9cbnZhciBjYXBpdGFsaXplID0gY2FjaGVkKGZ1bmN0aW9uIChzdHIpIHtcbiAgcmV0dXJuIHN0ci5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSArIHN0ci5zbGljZSgxKVxufSk7XG5cbi8qKlxuICogSHlwaGVuYXRlIGEgY2FtZWxDYXNlIHN0cmluZy5cbiAqL1xudmFyIGh5cGhlbmF0ZVJFID0gL1xcQihbQS1aXSkvZztcbnZhciBoeXBoZW5hdGUgPSBjYWNoZWQoZnVuY3Rpb24gKHN0cikge1xuICByZXR1cm4gc3RyLnJlcGxhY2UoaHlwaGVuYXRlUkUsICctJDEnKS50b0xvd2VyQ2FzZSgpXG59KTtcblxuLyoqXG4gKiBTaW1wbGUgYmluZCBwb2x5ZmlsbCBmb3IgZW52aXJvbm1lbnRzIHRoYXQgZG8gbm90IHN1cHBvcnQgaXQsXG4gKiBlLmcuLCBQaGFudG9tSlMgMS54LiBUZWNobmljYWxseSwgd2UgZG9uJ3QgbmVlZCB0aGlzIGFueW1vcmVcbiAqIHNpbmNlIG5hdGl2ZSBiaW5kIGlzIG5vdyBwZXJmb3JtYW50IGVub3VnaCBpbiBtb3N0IGJyb3dzZXJzLlxuICogQnV0IHJlbW92aW5nIGl0IHdvdWxkIG1lYW4gYnJlYWtpbmcgY29kZSB0aGF0IHdhcyBhYmxlIHRvIHJ1biBpblxuICogUGhhbnRvbUpTIDEueCwgc28gdGhpcyBtdXN0IGJlIGtlcHQgZm9yIGJhY2t3YXJkIGNvbXBhdGliaWxpdHkuXG4gKi9cblxuLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbmZ1bmN0aW9uIHBvbHlmaWxsQmluZCAoZm4sIGN0eCkge1xuICBmdW5jdGlvbiBib3VuZEZuIChhKSB7XG4gICAgdmFyIGwgPSBhcmd1bWVudHMubGVuZ3RoO1xuICAgIHJldHVybiBsXG4gICAgICA/IGwgPiAxXG4gICAgICAgID8gZm4uYXBwbHkoY3R4LCBhcmd1bWVudHMpXG4gICAgICAgIDogZm4uY2FsbChjdHgsIGEpXG4gICAgICA6IGZuLmNhbGwoY3R4KVxuICB9XG5cbiAgYm91bmRGbi5fbGVuZ3RoID0gZm4ubGVuZ3RoO1xuICByZXR1cm4gYm91bmRGblxufVxuXG5mdW5jdGlvbiBuYXRpdmVCaW5kIChmbiwgY3R4KSB7XG4gIHJldHVybiBmbi5iaW5kKGN0eClcbn1cblxudmFyIGJpbmQgPSBGdW5jdGlvbi5wcm90b3R5cGUuYmluZFxuICA/IG5hdGl2ZUJpbmRcbiAgOiBwb2x5ZmlsbEJpbmQ7XG5cbi8qKlxuICogQ29udmVydCBhbiBBcnJheS1saWtlIG9iamVjdCB0byBhIHJlYWwgQXJyYXkuXG4gKi9cbmZ1bmN0aW9uIHRvQXJyYXkgKGxpc3QsIHN0YXJ0KSB7XG4gIHN0YXJ0ID0gc3RhcnQgfHwgMDtcbiAgdmFyIGkgPSBsaXN0Lmxlbmd0aCAtIHN0YXJ0O1xuICB2YXIgcmV0ID0gbmV3IEFycmF5KGkpO1xuICB3aGlsZSAoaS0tKSB7XG4gICAgcmV0W2ldID0gbGlzdFtpICsgc3RhcnRdO1xuICB9XG4gIHJldHVybiByZXRcbn1cblxuLyoqXG4gKiBNaXggcHJvcGVydGllcyBpbnRvIHRhcmdldCBvYmplY3QuXG4gKi9cbmZ1bmN0aW9uIGV4dGVuZCAodG8sIF9mcm9tKSB7XG4gIGZvciAodmFyIGtleSBpbiBfZnJvbSkge1xuICAgIHRvW2tleV0gPSBfZnJvbVtrZXldO1xuICB9XG4gIHJldHVybiB0b1xufVxuXG4vKipcbiAqIE1lcmdlIGFuIEFycmF5IG9mIE9iamVjdHMgaW50byBhIHNpbmdsZSBPYmplY3QuXG4gKi9cbmZ1bmN0aW9uIHRvT2JqZWN0IChhcnIpIHtcbiAgdmFyIHJlcyA9IHt9O1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGFyci5sZW5ndGg7IGkrKykge1xuICAgIGlmIChhcnJbaV0pIHtcbiAgICAgIGV4dGVuZChyZXMsIGFycltpXSk7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXNcbn1cblxuLyogZXNsaW50LWRpc2FibGUgbm8tdW51c2VkLXZhcnMgKi9cblxuLyoqXG4gKiBQZXJmb3JtIG5vIG9wZXJhdGlvbi5cbiAqIFN0dWJiaW5nIGFyZ3MgdG8gbWFrZSBGbG93IGhhcHB5IHdpdGhvdXQgbGVhdmluZyB1c2VsZXNzIHRyYW5zcGlsZWQgY29kZVxuICogd2l0aCAuLi5yZXN0IChodHRwczovL2Zsb3cub3JnL2Jsb2cvMjAxNy8wNS8wNy9TdHJpY3QtRnVuY3Rpb24tQ2FsbC1Bcml0eS8pLlxuICovXG5mdW5jdGlvbiBub29wIChhLCBiLCBjKSB7fVxuXG4vKipcbiAqIEFsd2F5cyByZXR1cm4gZmFsc2UuXG4gKi9cbnZhciBubyA9IGZ1bmN0aW9uIChhLCBiLCBjKSB7IHJldHVybiBmYWxzZTsgfTtcblxuLyogZXNsaW50LWVuYWJsZSBuby11bnVzZWQtdmFycyAqL1xuXG4vKipcbiAqIFJldHVybiB0aGUgc2FtZSB2YWx1ZS5cbiAqL1xudmFyIGlkZW50aXR5ID0gZnVuY3Rpb24gKF8pIHsgcmV0dXJuIF87IH07XG5cbi8qKlxuICogR2VuZXJhdGUgYSBzdHJpbmcgY29udGFpbmluZyBzdGF0aWMga2V5cyBmcm9tIGNvbXBpbGVyIG1vZHVsZXMuXG4gKi9cbmZ1bmN0aW9uIGdlblN0YXRpY0tleXMgKG1vZHVsZXMpIHtcbiAgcmV0dXJuIG1vZHVsZXMucmVkdWNlKGZ1bmN0aW9uIChrZXlzLCBtKSB7XG4gICAgcmV0dXJuIGtleXMuY29uY2F0KG0uc3RhdGljS2V5cyB8fCBbXSlcbiAgfSwgW10pLmpvaW4oJywnKVxufVxuXG4vKipcbiAqIENoZWNrIGlmIHR3byB2YWx1ZXMgYXJlIGxvb3NlbHkgZXF1YWwgLSB0aGF0IGlzLFxuICogaWYgdGhleSBhcmUgcGxhaW4gb2JqZWN0cywgZG8gdGhleSBoYXZlIHRoZSBzYW1lIHNoYXBlP1xuICovXG5mdW5jdGlvbiBsb29zZUVxdWFsIChhLCBiKSB7XG4gIGlmIChhID09PSBiKSB7IHJldHVybiB0cnVlIH1cbiAgdmFyIGlzT2JqZWN0QSA9IGlzT2JqZWN0KGEpO1xuICB2YXIgaXNPYmplY3RCID0gaXNPYmplY3QoYik7XG4gIGlmIChpc09iamVjdEEgJiYgaXNPYmplY3RCKSB7XG4gICAgdHJ5IHtcbiAgICAgIHZhciBpc0FycmF5QSA9IEFycmF5LmlzQXJyYXkoYSk7XG4gICAgICB2YXIgaXNBcnJheUIgPSBBcnJheS5pc0FycmF5KGIpO1xuICAgICAgaWYgKGlzQXJyYXlBICYmIGlzQXJyYXlCKSB7XG4gICAgICAgIHJldHVybiBhLmxlbmd0aCA9PT0gYi5sZW5ndGggJiYgYS5ldmVyeShmdW5jdGlvbiAoZSwgaSkge1xuICAgICAgICAgIHJldHVybiBsb29zZUVxdWFsKGUsIGJbaV0pXG4gICAgICAgIH0pXG4gICAgICB9IGVsc2UgaWYgKGEgaW5zdGFuY2VvZiBEYXRlICYmIGIgaW5zdGFuY2VvZiBEYXRlKSB7XG4gICAgICAgIHJldHVybiBhLmdldFRpbWUoKSA9PT0gYi5nZXRUaW1lKClcbiAgICAgIH0gZWxzZSBpZiAoIWlzQXJyYXlBICYmICFpc0FycmF5Qikge1xuICAgICAgICB2YXIga2V5c0EgPSBPYmplY3Qua2V5cyhhKTtcbiAgICAgICAgdmFyIGtleXNCID0gT2JqZWN0LmtleXMoYik7XG4gICAgICAgIHJldHVybiBrZXlzQS5sZW5ndGggPT09IGtleXNCLmxlbmd0aCAmJiBrZXlzQS5ldmVyeShmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgICAgcmV0dXJuIGxvb3NlRXF1YWwoYVtrZXldLCBiW2tleV0pXG4gICAgICAgIH0pXG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgIH1cbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfVxuICB9IGVsc2UgaWYgKCFpc09iamVjdEEgJiYgIWlzT2JqZWN0Qikge1xuICAgIHJldHVybiBTdHJpbmcoYSkgPT09IFN0cmluZyhiKVxuICB9IGVsc2Uge1xuICAgIHJldHVybiBmYWxzZVxuICB9XG59XG5cbi8qKlxuICogUmV0dXJuIHRoZSBmaXJzdCBpbmRleCBhdCB3aGljaCBhIGxvb3NlbHkgZXF1YWwgdmFsdWUgY2FuIGJlXG4gKiBmb3VuZCBpbiB0aGUgYXJyYXkgKGlmIHZhbHVlIGlzIGEgcGxhaW4gb2JqZWN0LCB0aGUgYXJyYXkgbXVzdFxuICogY29udGFpbiBhbiBvYmplY3Qgb2YgdGhlIHNhbWUgc2hhcGUpLCBvciAtMSBpZiBpdCBpcyBub3QgcHJlc2VudC5cbiAqL1xuZnVuY3Rpb24gbG9vc2VJbmRleE9mIChhcnIsIHZhbCkge1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGFyci5sZW5ndGg7IGkrKykge1xuICAgIGlmIChsb29zZUVxdWFsKGFycltpXSwgdmFsKSkgeyByZXR1cm4gaSB9XG4gIH1cbiAgcmV0dXJuIC0xXG59XG5cbi8qKlxuICogRW5zdXJlIGEgZnVuY3Rpb24gaXMgY2FsbGVkIG9ubHkgb25jZS5cbiAqL1xuZnVuY3Rpb24gb25jZSAoZm4pIHtcbiAgdmFyIGNhbGxlZCA9IGZhbHNlO1xuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIGlmICghY2FsbGVkKSB7XG4gICAgICBjYWxsZWQgPSB0cnVlO1xuICAgICAgZm4uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG4gIH1cbn1cblxudmFyIFNTUl9BVFRSID0gJ2RhdGEtc2VydmVyLXJlbmRlcmVkJztcblxudmFyIEFTU0VUX1RZUEVTID0gW1xuICAnY29tcG9uZW50JyxcbiAgJ2RpcmVjdGl2ZScsXG4gICdmaWx0ZXInXG5dO1xuXG52YXIgTElGRUNZQ0xFX0hPT0tTID0gW1xuICAnYmVmb3JlQ3JlYXRlJyxcbiAgJ2NyZWF0ZWQnLFxuICAnYmVmb3JlTW91bnQnLFxuICAnbW91bnRlZCcsXG4gICdiZWZvcmVVcGRhdGUnLFxuICAndXBkYXRlZCcsXG4gICdiZWZvcmVEZXN0cm95JyxcbiAgJ2Rlc3Ryb3llZCcsXG4gICdhY3RpdmF0ZWQnLFxuICAnZGVhY3RpdmF0ZWQnLFxuICAnZXJyb3JDYXB0dXJlZCcsXG4gICdzZXJ2ZXJQcmVmZXRjaCdcbl07XG5cbi8qICAqL1xuXG5cblxudmFyIGNvbmZpZyA9ICh7XG4gIC8qKlxuICAgKiBPcHRpb24gbWVyZ2Ugc3RyYXRlZ2llcyAodXNlZCBpbiBjb3JlL3V0aWwvb3B0aW9ucylcbiAgICovXG4gIC8vICRmbG93LWRpc2FibGUtbGluZVxuICBvcHRpb25NZXJnZVN0cmF0ZWdpZXM6IE9iamVjdC5jcmVhdGUobnVsbCksXG5cbiAgLyoqXG4gICAqIFdoZXRoZXIgdG8gc3VwcHJlc3Mgd2FybmluZ3MuXG4gICAqL1xuICBzaWxlbnQ6IGZhbHNlLFxuXG4gIC8qKlxuICAgKiBTaG93IHByb2R1Y3Rpb24gbW9kZSB0aXAgbWVzc2FnZSBvbiBib290P1xuICAgKi9cbiAgcHJvZHVjdGlvblRpcDogcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyxcblxuICAvKipcbiAgICogV2hldGhlciB0byBlbmFibGUgZGV2dG9vbHNcbiAgICovXG4gIGRldnRvb2xzOiBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nLFxuXG4gIC8qKlxuICAgKiBXaGV0aGVyIHRvIHJlY29yZCBwZXJmXG4gICAqL1xuICBwZXJmb3JtYW5jZTogZmFsc2UsXG5cbiAgLyoqXG4gICAqIEVycm9yIGhhbmRsZXIgZm9yIHdhdGNoZXIgZXJyb3JzXG4gICAqL1xuICBlcnJvckhhbmRsZXI6IG51bGwsXG5cbiAgLyoqXG4gICAqIFdhcm4gaGFuZGxlciBmb3Igd2F0Y2hlciB3YXJuc1xuICAgKi9cbiAgd2FybkhhbmRsZXI6IG51bGwsXG5cbiAgLyoqXG4gICAqIElnbm9yZSBjZXJ0YWluIGN1c3RvbSBlbGVtZW50c1xuICAgKi9cbiAgaWdub3JlZEVsZW1lbnRzOiBbXSxcblxuICAvKipcbiAgICogQ3VzdG9tIHVzZXIga2V5IGFsaWFzZXMgZm9yIHYtb25cbiAgICovXG4gIC8vICRmbG93LWRpc2FibGUtbGluZVxuICBrZXlDb2RlczogT2JqZWN0LmNyZWF0ZShudWxsKSxcblxuICAvKipcbiAgICogQ2hlY2sgaWYgYSB0YWcgaXMgcmVzZXJ2ZWQgc28gdGhhdCBpdCBjYW5ub3QgYmUgcmVnaXN0ZXJlZCBhcyBhXG4gICAqIGNvbXBvbmVudC4gVGhpcyBpcyBwbGF0Zm9ybS1kZXBlbmRlbnQgYW5kIG1heSBiZSBvdmVyd3JpdHRlbi5cbiAgICovXG4gIGlzUmVzZXJ2ZWRUYWc6IG5vLFxuXG4gIC8qKlxuICAgKiBDaGVjayBpZiBhbiBhdHRyaWJ1dGUgaXMgcmVzZXJ2ZWQgc28gdGhhdCBpdCBjYW5ub3QgYmUgdXNlZCBhcyBhIGNvbXBvbmVudFxuICAgKiBwcm9wLiBUaGlzIGlzIHBsYXRmb3JtLWRlcGVuZGVudCBhbmQgbWF5IGJlIG92ZXJ3cml0dGVuLlxuICAgKi9cbiAgaXNSZXNlcnZlZEF0dHI6IG5vLFxuXG4gIC8qKlxuICAgKiBDaGVjayBpZiBhIHRhZyBpcyBhbiB1bmtub3duIGVsZW1lbnQuXG4gICAqIFBsYXRmb3JtLWRlcGVuZGVudC5cbiAgICovXG4gIGlzVW5rbm93bkVsZW1lbnQ6IG5vLFxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIG5hbWVzcGFjZSBvZiBhbiBlbGVtZW50XG4gICAqL1xuICBnZXRUYWdOYW1lc3BhY2U6IG5vb3AsXG5cbiAgLyoqXG4gICAqIFBhcnNlIHRoZSByZWFsIHRhZyBuYW1lIGZvciB0aGUgc3BlY2lmaWMgcGxhdGZvcm0uXG4gICAqL1xuICBwYXJzZVBsYXRmb3JtVGFnTmFtZTogaWRlbnRpdHksXG5cbiAgLyoqXG4gICAqIENoZWNrIGlmIGFuIGF0dHJpYnV0ZSBtdXN0IGJlIGJvdW5kIHVzaW5nIHByb3BlcnR5LCBlLmcuIHZhbHVlXG4gICAqIFBsYXRmb3JtLWRlcGVuZGVudC5cbiAgICovXG4gIG11c3RVc2VQcm9wOiBubyxcblxuICAvKipcbiAgICogUGVyZm9ybSB1cGRhdGVzIGFzeW5jaHJvbm91c2x5LiBJbnRlbmRlZCB0byBiZSB1c2VkIGJ5IFZ1ZSBUZXN0IFV0aWxzXG4gICAqIFRoaXMgd2lsbCBzaWduaWZpY2FudGx5IHJlZHVjZSBwZXJmb3JtYW5jZSBpZiBzZXQgdG8gZmFsc2UuXG4gICAqL1xuICBhc3luYzogdHJ1ZSxcblxuICAvKipcbiAgICogRXhwb3NlZCBmb3IgbGVnYWN5IHJlYXNvbnNcbiAgICovXG4gIF9saWZlY3ljbGVIb29rczogTElGRUNZQ0xFX0hPT0tTXG59KTtcblxuLyogICovXG5cbi8qKlxuICogdW5pY29kZSBsZXR0ZXJzIHVzZWQgZm9yIHBhcnNpbmcgaHRtbCB0YWdzLCBjb21wb25lbnQgbmFtZXMgYW5kIHByb3BlcnR5IHBhdGhzLlxuICogdXNpbmcgaHR0cHM6Ly93d3cudzMub3JnL1RSL2h0bWw1My9zZW1hbnRpY3Mtc2NyaXB0aW5nLmh0bWwjcG90ZW50aWFsY3VzdG9tZWxlbWVudG5hbWVcbiAqIHNraXBwaW5nIFxcdTEwMDAwLVxcdUVGRkZGIGR1ZSB0byBpdCBmcmVlemluZyB1cCBQaGFudG9tSlNcbiAqL1xudmFyIHVuaWNvZGVSZWdFeHAgPSAvYS16QS1aXFx1MDBCN1xcdTAwQzAtXFx1MDBENlxcdTAwRDgtXFx1MDBGNlxcdTAwRjgtXFx1MDM3RFxcdTAzN0YtXFx1MUZGRlxcdTIwMEMtXFx1MjAwRFxcdTIwM0YtXFx1MjA0MFxcdTIwNzAtXFx1MjE4RlxcdTJDMDAtXFx1MkZFRlxcdTMwMDEtXFx1RDdGRlxcdUY5MDAtXFx1RkRDRlxcdUZERjAtXFx1RkZGRC87XG5cbi8qKlxuICogQ2hlY2sgaWYgYSBzdHJpbmcgc3RhcnRzIHdpdGggJCBvciBfXG4gKi9cbmZ1bmN0aW9uIGlzUmVzZXJ2ZWQgKHN0cikge1xuICB2YXIgYyA9IChzdHIgKyAnJykuY2hhckNvZGVBdCgwKTtcbiAgcmV0dXJuIGMgPT09IDB4MjQgfHwgYyA9PT0gMHg1RlxufVxuXG4vKipcbiAqIERlZmluZSBhIHByb3BlcnR5LlxuICovXG5mdW5jdGlvbiBkZWYgKG9iaiwga2V5LCB2YWwsIGVudW1lcmFibGUpIHtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwga2V5LCB7XG4gICAgdmFsdWU6IHZhbCxcbiAgICBlbnVtZXJhYmxlOiAhIWVudW1lcmFibGUsXG4gICAgd3JpdGFibGU6IHRydWUsXG4gICAgY29uZmlndXJhYmxlOiB0cnVlXG4gIH0pO1xufVxuXG4vKipcbiAqIFBhcnNlIHNpbXBsZSBwYXRoLlxuICovXG52YXIgYmFpbFJFID0gbmV3IFJlZ0V4cCgoXCJbXlwiICsgKHVuaWNvZGVSZWdFeHAuc291cmNlKSArIFwiLiRfXFxcXGRdXCIpKTtcbmZ1bmN0aW9uIHBhcnNlUGF0aCAocGF0aCkge1xuICBpZiAoYmFpbFJFLnRlc3QocGF0aCkpIHtcbiAgICByZXR1cm5cbiAgfVxuICB2YXIgc2VnbWVudHMgPSBwYXRoLnNwbGl0KCcuJyk7XG4gIHJldHVybiBmdW5jdGlvbiAob2JqKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzZWdtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKCFvYmopIHsgcmV0dXJuIH1cbiAgICAgIG9iaiA9IG9ialtzZWdtZW50c1tpXV07XG4gICAgfVxuICAgIHJldHVybiBvYmpcbiAgfVxufVxuXG4vKiAgKi9cblxuLy8gY2FuIHdlIHVzZSBfX3Byb3RvX18/XG52YXIgaGFzUHJvdG8gPSAnX19wcm90b19fJyBpbiB7fTtcblxuLy8gQnJvd3NlciBlbnZpcm9ubWVudCBzbmlmZmluZ1xudmFyIGluQnJvd3NlciA9IHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnO1xudmFyIGluV2VleCA9IHR5cGVvZiBXWEVudmlyb25tZW50ICE9PSAndW5kZWZpbmVkJyAmJiAhIVdYRW52aXJvbm1lbnQucGxhdGZvcm07XG52YXIgd2VleFBsYXRmb3JtID0gaW5XZWV4ICYmIFdYRW52aXJvbm1lbnQucGxhdGZvcm0udG9Mb3dlckNhc2UoKTtcbnZhciBVQSA9IGluQnJvd3NlciAmJiB3aW5kb3cubmF2aWdhdG9yLnVzZXJBZ2VudC50b0xvd2VyQ2FzZSgpO1xudmFyIGlzSUUgPSBVQSAmJiAvbXNpZXx0cmlkZW50Ly50ZXN0KFVBKTtcbnZhciBpc0lFOSA9IFVBICYmIFVBLmluZGV4T2YoJ21zaWUgOS4wJykgPiAwO1xudmFyIGlzRWRnZSA9IFVBICYmIFVBLmluZGV4T2YoJ2VkZ2UvJykgPiAwO1xudmFyIGlzQW5kcm9pZCA9IChVQSAmJiBVQS5pbmRleE9mKCdhbmRyb2lkJykgPiAwKSB8fCAod2VleFBsYXRmb3JtID09PSAnYW5kcm9pZCcpO1xudmFyIGlzSU9TID0gKFVBICYmIC9pcGhvbmV8aXBhZHxpcG9kfGlvcy8udGVzdChVQSkpIHx8ICh3ZWV4UGxhdGZvcm0gPT09ICdpb3MnKTtcbnZhciBpc0Nocm9tZSA9IFVBICYmIC9jaHJvbWVcXC9cXGQrLy50ZXN0KFVBKSAmJiAhaXNFZGdlO1xudmFyIGlzUGhhbnRvbUpTID0gVUEgJiYgL3BoYW50b21qcy8udGVzdChVQSk7XG52YXIgaXNGRiA9IFVBICYmIFVBLm1hdGNoKC9maXJlZm94XFwvKFxcZCspLyk7XG5cbi8vIEZpcmVmb3ggaGFzIGEgXCJ3YXRjaFwiIGZ1bmN0aW9uIG9uIE9iamVjdC5wcm90b3R5cGUuLi5cbnZhciBuYXRpdmVXYXRjaCA9ICh7fSkud2F0Y2g7XG5cbnZhciBzdXBwb3J0c1Bhc3NpdmUgPSBmYWxzZTtcbmlmIChpbkJyb3dzZXIpIHtcbiAgdHJ5IHtcbiAgICB2YXIgb3B0cyA9IHt9O1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvcHRzLCAncGFzc2l2ZScsICh7XG4gICAgICBnZXQ6IGZ1bmN0aW9uIGdldCAoKSB7XG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgICAgIHN1cHBvcnRzUGFzc2l2ZSA9IHRydWU7XG4gICAgICB9XG4gICAgfSkpOyAvLyBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svZmxvdy9pc3N1ZXMvMjg1XG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3Rlc3QtcGFzc2l2ZScsIG51bGwsIG9wdHMpO1xuICB9IGNhdGNoIChlKSB7fVxufVxuXG4vLyB0aGlzIG5lZWRzIHRvIGJlIGxhenktZXZhbGVkIGJlY2F1c2UgdnVlIG1heSBiZSByZXF1aXJlZCBiZWZvcmVcbi8vIHZ1ZS1zZXJ2ZXItcmVuZGVyZXIgY2FuIHNldCBWVUVfRU5WXG52YXIgX2lzU2VydmVyO1xudmFyIGlzU2VydmVyUmVuZGVyaW5nID0gZnVuY3Rpb24gKCkge1xuICBpZiAoX2lzU2VydmVyID09PSB1bmRlZmluZWQpIHtcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICBpZiAoIWluQnJvd3NlciAmJiAhaW5XZWV4ICYmIHR5cGVvZiBnbG9iYWwgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAvLyBkZXRlY3QgcHJlc2VuY2Ugb2YgdnVlLXNlcnZlci1yZW5kZXJlciBhbmQgYXZvaWRcbiAgICAgIC8vIFdlYnBhY2sgc2hpbW1pbmcgdGhlIHByb2Nlc3NcbiAgICAgIF9pc1NlcnZlciA9IGdsb2JhbFsncHJvY2VzcyddICYmIGdsb2JhbFsncHJvY2VzcyddLmVudi5WVUVfRU5WID09PSAnc2VydmVyJztcbiAgICB9IGVsc2Uge1xuICAgICAgX2lzU2VydmVyID0gZmFsc2U7XG4gICAgfVxuICB9XG4gIHJldHVybiBfaXNTZXJ2ZXJcbn07XG5cbi8vIGRldGVjdCBkZXZ0b29sc1xudmFyIGRldnRvb2xzID0gaW5Ccm93c2VyICYmIHdpbmRvdy5fX1ZVRV9ERVZUT09MU19HTE9CQUxfSE9PS19fO1xuXG4vKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuZnVuY3Rpb24gaXNOYXRpdmUgKEN0b3IpIHtcbiAgcmV0dXJuIHR5cGVvZiBDdG9yID09PSAnZnVuY3Rpb24nICYmIC9uYXRpdmUgY29kZS8udGVzdChDdG9yLnRvU3RyaW5nKCkpXG59XG5cbnZhciBoYXNTeW1ib2wgPVxuICB0eXBlb2YgU3ltYm9sICE9PSAndW5kZWZpbmVkJyAmJiBpc05hdGl2ZShTeW1ib2wpICYmXG4gIHR5cGVvZiBSZWZsZWN0ICE9PSAndW5kZWZpbmVkJyAmJiBpc05hdGl2ZShSZWZsZWN0Lm93bktleXMpO1xuXG52YXIgX1NldDtcbi8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqLyAvLyAkZmxvdy1kaXNhYmxlLWxpbmVcbmlmICh0eXBlb2YgU2V0ICE9PSAndW5kZWZpbmVkJyAmJiBpc05hdGl2ZShTZXQpKSB7XG4gIC8vIHVzZSBuYXRpdmUgU2V0IHdoZW4gYXZhaWxhYmxlLlxuICBfU2V0ID0gU2V0O1xufSBlbHNlIHtcbiAgLy8gYSBub24tc3RhbmRhcmQgU2V0IHBvbHlmaWxsIHRoYXQgb25seSB3b3JrcyB3aXRoIHByaW1pdGl2ZSBrZXlzLlxuICBfU2V0ID0gLypAX19QVVJFX18qLyhmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gU2V0ICgpIHtcbiAgICAgIHRoaXMuc2V0ID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICB9XG4gICAgU2V0LnByb3RvdHlwZS5oYXMgPSBmdW5jdGlvbiBoYXMgKGtleSkge1xuICAgICAgcmV0dXJuIHRoaXMuc2V0W2tleV0gPT09IHRydWVcbiAgICB9O1xuICAgIFNldC5wcm90b3R5cGUuYWRkID0gZnVuY3Rpb24gYWRkIChrZXkpIHtcbiAgICAgIHRoaXMuc2V0W2tleV0gPSB0cnVlO1xuICAgIH07XG4gICAgU2V0LnByb3RvdHlwZS5jbGVhciA9IGZ1bmN0aW9uIGNsZWFyICgpIHtcbiAgICAgIHRoaXMuc2V0ID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICB9O1xuXG4gICAgcmV0dXJuIFNldDtcbiAgfSgpKTtcbn1cblxuLyogICovXG5cbnZhciB3YXJuID0gbm9vcDtcbnZhciB0aXAgPSBub29wO1xudmFyIGdlbmVyYXRlQ29tcG9uZW50VHJhY2UgPSAobm9vcCk7IC8vIHdvcmsgYXJvdW5kIGZsb3cgY2hlY2tcbnZhciBmb3JtYXRDb21wb25lbnROYW1lID0gKG5vb3ApO1xuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICB2YXIgaGFzQ29uc29sZSA9IHR5cGVvZiBjb25zb2xlICE9PSAndW5kZWZpbmVkJztcbiAgdmFyIGNsYXNzaWZ5UkUgPSAvKD86XnxbLV9dKShcXHcpL2c7XG4gIHZhciBjbGFzc2lmeSA9IGZ1bmN0aW9uIChzdHIpIHsgcmV0dXJuIHN0clxuICAgIC5yZXBsYWNlKGNsYXNzaWZ5UkUsIGZ1bmN0aW9uIChjKSB7IHJldHVybiBjLnRvVXBwZXJDYXNlKCk7IH0pXG4gICAgLnJlcGxhY2UoL1stX10vZywgJycpOyB9O1xuXG4gIHdhcm4gPSBmdW5jdGlvbiAobXNnLCB2bSkge1xuICAgIHZhciB0cmFjZSA9IHZtID8gZ2VuZXJhdGVDb21wb25lbnRUcmFjZSh2bSkgOiAnJztcblxuICAgIGlmIChjb25maWcud2FybkhhbmRsZXIpIHtcbiAgICAgIGNvbmZpZy53YXJuSGFuZGxlci5jYWxsKG51bGwsIG1zZywgdm0sIHRyYWNlKTtcbiAgICB9IGVsc2UgaWYgKGhhc0NvbnNvbGUgJiYgKCFjb25maWcuc2lsZW50KSkge1xuICAgICAgY29uc29sZS5lcnJvcigoXCJbVnVlIHdhcm5dOiBcIiArIG1zZyArIHRyYWNlKSk7XG4gICAgfVxuICB9O1xuXG4gIHRpcCA9IGZ1bmN0aW9uIChtc2csIHZtKSB7XG4gICAgaWYgKGhhc0NvbnNvbGUgJiYgKCFjb25maWcuc2lsZW50KSkge1xuICAgICAgY29uc29sZS53YXJuKFwiW1Z1ZSB0aXBdOiBcIiArIG1zZyArIChcbiAgICAgICAgdm0gPyBnZW5lcmF0ZUNvbXBvbmVudFRyYWNlKHZtKSA6ICcnXG4gICAgICApKTtcbiAgICB9XG4gIH07XG5cbiAgZm9ybWF0Q29tcG9uZW50TmFtZSA9IGZ1bmN0aW9uICh2bSwgaW5jbHVkZUZpbGUpIHtcbiAgICBpZiAodm0uJHJvb3QgPT09IHZtKSB7XG4gICAgICByZXR1cm4gJzxSb290PidcbiAgICB9XG4gICAgdmFyIG9wdGlvbnMgPSB0eXBlb2Ygdm0gPT09ICdmdW5jdGlvbicgJiYgdm0uY2lkICE9IG51bGxcbiAgICAgID8gdm0ub3B0aW9uc1xuICAgICAgOiB2bS5faXNWdWVcbiAgICAgICAgPyB2bS4kb3B0aW9ucyB8fCB2bS5jb25zdHJ1Y3Rvci5vcHRpb25zXG4gICAgICAgIDogdm07XG4gICAgdmFyIG5hbWUgPSBvcHRpb25zLm5hbWUgfHwgb3B0aW9ucy5fY29tcG9uZW50VGFnO1xuICAgIHZhciBmaWxlID0gb3B0aW9ucy5fX2ZpbGU7XG4gICAgaWYgKCFuYW1lICYmIGZpbGUpIHtcbiAgICAgIHZhciBtYXRjaCA9IGZpbGUubWF0Y2goLyhbXi9cXFxcXSspXFwudnVlJC8pO1xuICAgICAgbmFtZSA9IG1hdGNoICYmIG1hdGNoWzFdO1xuICAgIH1cblxuICAgIHJldHVybiAoXG4gICAgICAobmFtZSA/IChcIjxcIiArIChjbGFzc2lmeShuYW1lKSkgKyBcIj5cIikgOiBcIjxBbm9ueW1vdXM+XCIpICtcbiAgICAgIChmaWxlICYmIGluY2x1ZGVGaWxlICE9PSBmYWxzZSA/IChcIiBhdCBcIiArIGZpbGUpIDogJycpXG4gICAgKVxuICB9O1xuXG4gIHZhciByZXBlYXQgPSBmdW5jdGlvbiAoc3RyLCBuKSB7XG4gICAgdmFyIHJlcyA9ICcnO1xuICAgIHdoaWxlIChuKSB7XG4gICAgICBpZiAobiAlIDIgPT09IDEpIHsgcmVzICs9IHN0cjsgfVxuICAgICAgaWYgKG4gPiAxKSB7IHN0ciArPSBzdHI7IH1cbiAgICAgIG4gPj49IDE7XG4gICAgfVxuICAgIHJldHVybiByZXNcbiAgfTtcblxuICBnZW5lcmF0ZUNvbXBvbmVudFRyYWNlID0gZnVuY3Rpb24gKHZtKSB7XG4gICAgaWYgKHZtLl9pc1Z1ZSAmJiB2bS4kcGFyZW50KSB7XG4gICAgICB2YXIgdHJlZSA9IFtdO1xuICAgICAgdmFyIGN1cnJlbnRSZWN1cnNpdmVTZXF1ZW5jZSA9IDA7XG4gICAgICB3aGlsZSAodm0pIHtcbiAgICAgICAgaWYgKHRyZWUubGVuZ3RoID4gMCkge1xuICAgICAgICAgIHZhciBsYXN0ID0gdHJlZVt0cmVlLmxlbmd0aCAtIDFdO1xuICAgICAgICAgIGlmIChsYXN0LmNvbnN0cnVjdG9yID09PSB2bS5jb25zdHJ1Y3Rvcikge1xuICAgICAgICAgICAgY3VycmVudFJlY3Vyc2l2ZVNlcXVlbmNlKys7XG4gICAgICAgICAgICB2bSA9IHZtLiRwYXJlbnQ7XG4gICAgICAgICAgICBjb250aW51ZVxuICAgICAgICAgIH0gZWxzZSBpZiAoY3VycmVudFJlY3Vyc2l2ZVNlcXVlbmNlID4gMCkge1xuICAgICAgICAgICAgdHJlZVt0cmVlLmxlbmd0aCAtIDFdID0gW2xhc3QsIGN1cnJlbnRSZWN1cnNpdmVTZXF1ZW5jZV07XG4gICAgICAgICAgICBjdXJyZW50UmVjdXJzaXZlU2VxdWVuY2UgPSAwO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0cmVlLnB1c2godm0pO1xuICAgICAgICB2bSA9IHZtLiRwYXJlbnQ7XG4gICAgICB9XG4gICAgICByZXR1cm4gJ1xcblxcbmZvdW5kIGluXFxuXFxuJyArIHRyZWVcbiAgICAgICAgLm1hcChmdW5jdGlvbiAodm0sIGkpIHsgcmV0dXJuIChcIlwiICsgKGkgPT09IDAgPyAnLS0tPiAnIDogcmVwZWF0KCcgJywgNSArIGkgKiAyKSkgKyAoQXJyYXkuaXNBcnJheSh2bSlcbiAgICAgICAgICAgID8gKChmb3JtYXRDb21wb25lbnROYW1lKHZtWzBdKSkgKyBcIi4uLiAoXCIgKyAodm1bMV0pICsgXCIgcmVjdXJzaXZlIGNhbGxzKVwiKVxuICAgICAgICAgICAgOiBmb3JtYXRDb21wb25lbnROYW1lKHZtKSkpOyB9KVxuICAgICAgICAuam9pbignXFxuJylcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIChcIlxcblxcbihmb3VuZCBpbiBcIiArIChmb3JtYXRDb21wb25lbnROYW1lKHZtKSkgKyBcIilcIilcbiAgICB9XG4gIH07XG59XG5cbi8qICAqL1xuXG52YXIgdWlkID0gMDtcblxuLyoqXG4gKiBBIGRlcCBpcyBhbiBvYnNlcnZhYmxlIHRoYXQgY2FuIGhhdmUgbXVsdGlwbGVcbiAqIGRpcmVjdGl2ZXMgc3Vic2NyaWJpbmcgdG8gaXQuXG4gKi9cbnZhciBEZXAgPSBmdW5jdGlvbiBEZXAgKCkge1xuICB0aGlzLmlkID0gdWlkKys7XG4gIHRoaXMuc3VicyA9IFtdO1xufTtcblxuRGVwLnByb3RvdHlwZS5hZGRTdWIgPSBmdW5jdGlvbiBhZGRTdWIgKHN1Yikge1xuICB0aGlzLnN1YnMucHVzaChzdWIpO1xufTtcblxuRGVwLnByb3RvdHlwZS5yZW1vdmVTdWIgPSBmdW5jdGlvbiByZW1vdmVTdWIgKHN1Yikge1xuICByZW1vdmUodGhpcy5zdWJzLCBzdWIpO1xufTtcblxuRGVwLnByb3RvdHlwZS5kZXBlbmQgPSBmdW5jdGlvbiBkZXBlbmQgKCkge1xuICBpZiAoRGVwLnRhcmdldCkge1xuICAgIERlcC50YXJnZXQuYWRkRGVwKHRoaXMpO1xuICB9XG59O1xuXG5EZXAucHJvdG90eXBlLm5vdGlmeSA9IGZ1bmN0aW9uIG5vdGlmeSAoKSB7XG4gIC8vIHN0YWJpbGl6ZSB0aGUgc3Vic2NyaWJlciBsaXN0IGZpcnN0XG4gIHZhciBzdWJzID0gdGhpcy5zdWJzLnNsaWNlKCk7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmICFjb25maWcuYXN5bmMpIHtcbiAgICAvLyBzdWJzIGFyZW4ndCBzb3J0ZWQgaW4gc2NoZWR1bGVyIGlmIG5vdCBydW5uaW5nIGFzeW5jXG4gICAgLy8gd2UgbmVlZCB0byBzb3J0IHRoZW0gbm93IHRvIG1ha2Ugc3VyZSB0aGV5IGZpcmUgaW4gY29ycmVjdFxuICAgIC8vIG9yZGVyXG4gICAgc3Vicy5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7IHJldHVybiBhLmlkIC0gYi5pZDsgfSk7XG4gIH1cbiAgZm9yICh2YXIgaSA9IDAsIGwgPSBzdWJzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgIHN1YnNbaV0udXBkYXRlKCk7XG4gIH1cbn07XG5cbi8vIFRoZSBjdXJyZW50IHRhcmdldCB3YXRjaGVyIGJlaW5nIGV2YWx1YXRlZC5cbi8vIFRoaXMgaXMgZ2xvYmFsbHkgdW5pcXVlIGJlY2F1c2Ugb25seSBvbmUgd2F0Y2hlclxuLy8gY2FuIGJlIGV2YWx1YXRlZCBhdCBhIHRpbWUuXG5EZXAudGFyZ2V0ID0gbnVsbDtcbnZhciB0YXJnZXRTdGFjayA9IFtdO1xuXG5mdW5jdGlvbiBwdXNoVGFyZ2V0ICh0YXJnZXQpIHtcbiAgdGFyZ2V0U3RhY2sucHVzaCh0YXJnZXQpO1xuICBEZXAudGFyZ2V0ID0gdGFyZ2V0O1xufVxuXG5mdW5jdGlvbiBwb3BUYXJnZXQgKCkge1xuICB0YXJnZXRTdGFjay5wb3AoKTtcbiAgRGVwLnRhcmdldCA9IHRhcmdldFN0YWNrW3RhcmdldFN0YWNrLmxlbmd0aCAtIDFdO1xufVxuXG4vKiAgKi9cblxudmFyIFZOb2RlID0gZnVuY3Rpb24gVk5vZGUgKFxuICB0YWcsXG4gIGRhdGEsXG4gIGNoaWxkcmVuLFxuICB0ZXh0LFxuICBlbG0sXG4gIGNvbnRleHQsXG4gIGNvbXBvbmVudE9wdGlvbnMsXG4gIGFzeW5jRmFjdG9yeVxuKSB7XG4gIHRoaXMudGFnID0gdGFnO1xuICB0aGlzLmRhdGEgPSBkYXRhO1xuICB0aGlzLmNoaWxkcmVuID0gY2hpbGRyZW47XG4gIHRoaXMudGV4dCA9IHRleHQ7XG4gIHRoaXMuZWxtID0gZWxtO1xuICB0aGlzLm5zID0gdW5kZWZpbmVkO1xuICB0aGlzLmNvbnRleHQgPSBjb250ZXh0O1xuICB0aGlzLmZuQ29udGV4dCA9IHVuZGVmaW5lZDtcbiAgdGhpcy5mbk9wdGlvbnMgPSB1bmRlZmluZWQ7XG4gIHRoaXMuZm5TY29wZUlkID0gdW5kZWZpbmVkO1xuICB0aGlzLmtleSA9IGRhdGEgJiYgZGF0YS5rZXk7XG4gIHRoaXMuY29tcG9uZW50T3B0aW9ucyA9IGNvbXBvbmVudE9wdGlvbnM7XG4gIHRoaXMuY29tcG9uZW50SW5zdGFuY2UgPSB1bmRlZmluZWQ7XG4gIHRoaXMucGFyZW50ID0gdW5kZWZpbmVkO1xuICB0aGlzLnJhdyA9IGZhbHNlO1xuICB0aGlzLmlzU3RhdGljID0gZmFsc2U7XG4gIHRoaXMuaXNSb290SW5zZXJ0ID0gdHJ1ZTtcbiAgdGhpcy5pc0NvbW1lbnQgPSBmYWxzZTtcbiAgdGhpcy5pc0Nsb25lZCA9IGZhbHNlO1xuICB0aGlzLmlzT25jZSA9IGZhbHNlO1xuICB0aGlzLmFzeW5jRmFjdG9yeSA9IGFzeW5jRmFjdG9yeTtcbiAgdGhpcy5hc3luY01ldGEgPSB1bmRlZmluZWQ7XG4gIHRoaXMuaXNBc3luY1BsYWNlaG9sZGVyID0gZmFsc2U7XG59O1xuXG52YXIgcHJvdG90eXBlQWNjZXNzb3JzID0geyBjaGlsZDogeyBjb25maWd1cmFibGU6IHRydWUgfSB9O1xuXG4vLyBERVBSRUNBVEVEOiBhbGlhcyBmb3IgY29tcG9uZW50SW5zdGFuY2UgZm9yIGJhY2t3YXJkcyBjb21wYXQuXG4vKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xucHJvdG90eXBlQWNjZXNzb3JzLmNoaWxkLmdldCA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMuY29tcG9uZW50SW5zdGFuY2Vcbn07XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKCBWTm9kZS5wcm90b3R5cGUsIHByb3RvdHlwZUFjY2Vzc29ycyApO1xuXG52YXIgY3JlYXRlRW1wdHlWTm9kZSA9IGZ1bmN0aW9uICh0ZXh0KSB7XG4gIGlmICggdGV4dCA9PT0gdm9pZCAwICkgdGV4dCA9ICcnO1xuXG4gIHZhciBub2RlID0gbmV3IFZOb2RlKCk7XG4gIG5vZGUudGV4dCA9IHRleHQ7XG4gIG5vZGUuaXNDb21tZW50ID0gdHJ1ZTtcbiAgcmV0dXJuIG5vZGVcbn07XG5cbmZ1bmN0aW9uIGNyZWF0ZVRleHRWTm9kZSAodmFsKSB7XG4gIHJldHVybiBuZXcgVk5vZGUodW5kZWZpbmVkLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgU3RyaW5nKHZhbCkpXG59XG5cbi8vIG9wdGltaXplZCBzaGFsbG93IGNsb25lXG4vLyB1c2VkIGZvciBzdGF0aWMgbm9kZXMgYW5kIHNsb3Qgbm9kZXMgYmVjYXVzZSB0aGV5IG1heSBiZSByZXVzZWQgYWNyb3NzXG4vLyBtdWx0aXBsZSByZW5kZXJzLCBjbG9uaW5nIHRoZW0gYXZvaWRzIGVycm9ycyB3aGVuIERPTSBtYW5pcHVsYXRpb25zIHJlbHlcbi8vIG9uIHRoZWlyIGVsbSByZWZlcmVuY2UuXG5mdW5jdGlvbiBjbG9uZVZOb2RlICh2bm9kZSkge1xuICB2YXIgY2xvbmVkID0gbmV3IFZOb2RlKFxuICAgIHZub2RlLnRhZyxcbiAgICB2bm9kZS5kYXRhLFxuICAgIC8vICM3OTc1XG4gICAgLy8gY2xvbmUgY2hpbGRyZW4gYXJyYXkgdG8gYXZvaWQgbXV0YXRpbmcgb3JpZ2luYWwgaW4gY2FzZSBvZiBjbG9uaW5nXG4gICAgLy8gYSBjaGlsZC5cbiAgICB2bm9kZS5jaGlsZHJlbiAmJiB2bm9kZS5jaGlsZHJlbi5zbGljZSgpLFxuICAgIHZub2RlLnRleHQsXG4gICAgdm5vZGUuZWxtLFxuICAgIHZub2RlLmNvbnRleHQsXG4gICAgdm5vZGUuY29tcG9uZW50T3B0aW9ucyxcbiAgICB2bm9kZS5hc3luY0ZhY3RvcnlcbiAgKTtcbiAgY2xvbmVkLm5zID0gdm5vZGUubnM7XG4gIGNsb25lZC5pc1N0YXRpYyA9IHZub2RlLmlzU3RhdGljO1xuICBjbG9uZWQua2V5ID0gdm5vZGUua2V5O1xuICBjbG9uZWQuaXNDb21tZW50ID0gdm5vZGUuaXNDb21tZW50O1xuICBjbG9uZWQuZm5Db250ZXh0ID0gdm5vZGUuZm5Db250ZXh0O1xuICBjbG9uZWQuZm5PcHRpb25zID0gdm5vZGUuZm5PcHRpb25zO1xuICBjbG9uZWQuZm5TY29wZUlkID0gdm5vZGUuZm5TY29wZUlkO1xuICBjbG9uZWQuYXN5bmNNZXRhID0gdm5vZGUuYXN5bmNNZXRhO1xuICBjbG9uZWQuaXNDbG9uZWQgPSB0cnVlO1xuICByZXR1cm4gY2xvbmVkXG59XG5cbi8qXG4gKiBub3QgdHlwZSBjaGVja2luZyB0aGlzIGZpbGUgYmVjYXVzZSBmbG93IGRvZXNuJ3QgcGxheSB3ZWxsIHdpdGhcbiAqIGR5bmFtaWNhbGx5IGFjY2Vzc2luZyBtZXRob2RzIG9uIEFycmF5IHByb3RvdHlwZVxuICovXG5cbnZhciBhcnJheVByb3RvID0gQXJyYXkucHJvdG90eXBlO1xudmFyIGFycmF5TWV0aG9kcyA9IE9iamVjdC5jcmVhdGUoYXJyYXlQcm90byk7XG5cbnZhciBtZXRob2RzVG9QYXRjaCA9IFtcbiAgJ3B1c2gnLFxuICAncG9wJyxcbiAgJ3NoaWZ0JyxcbiAgJ3Vuc2hpZnQnLFxuICAnc3BsaWNlJyxcbiAgJ3NvcnQnLFxuICAncmV2ZXJzZSdcbl07XG5cbi8qKlxuICogSW50ZXJjZXB0IG11dGF0aW5nIG1ldGhvZHMgYW5kIGVtaXQgZXZlbnRzXG4gKi9cbm1ldGhvZHNUb1BhdGNoLmZvckVhY2goZnVuY3Rpb24gKG1ldGhvZCkge1xuICAvLyBjYWNoZSBvcmlnaW5hbCBtZXRob2RcbiAgdmFyIG9yaWdpbmFsID0gYXJyYXlQcm90b1ttZXRob2RdO1xuICBkZWYoYXJyYXlNZXRob2RzLCBtZXRob2QsIGZ1bmN0aW9uIG11dGF0b3IgKCkge1xuICAgIHZhciBhcmdzID0gW10sIGxlbiA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gICAgd2hpbGUgKCBsZW4tLSApIGFyZ3NbIGxlbiBdID0gYXJndW1lbnRzWyBsZW4gXTtcblxuICAgIHZhciByZXN1bHQgPSBvcmlnaW5hbC5hcHBseSh0aGlzLCBhcmdzKTtcbiAgICB2YXIgb2IgPSB0aGlzLl9fb2JfXztcbiAgICB2YXIgaW5zZXJ0ZWQ7XG4gICAgc3dpdGNoIChtZXRob2QpIHtcbiAgICAgIGNhc2UgJ3B1c2gnOlxuICAgICAgY2FzZSAndW5zaGlmdCc6XG4gICAgICAgIGluc2VydGVkID0gYXJncztcbiAgICAgICAgYnJlYWtcbiAgICAgIGNhc2UgJ3NwbGljZSc6XG4gICAgICAgIGluc2VydGVkID0gYXJncy5zbGljZSgyKTtcbiAgICAgICAgYnJlYWtcbiAgICB9XG4gICAgaWYgKGluc2VydGVkKSB7IG9iLm9ic2VydmVBcnJheShpbnNlcnRlZCk7IH1cbiAgICAvLyBub3RpZnkgY2hhbmdlXG4gICAgb2IuZGVwLm5vdGlmeSgpO1xuICAgIHJldHVybiByZXN1bHRcbiAgfSk7XG59KTtcblxuLyogICovXG5cbnZhciBhcnJheUtleXMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhhcnJheU1ldGhvZHMpO1xuXG4vKipcbiAqIEluIHNvbWUgY2FzZXMgd2UgbWF5IHdhbnQgdG8gZGlzYWJsZSBvYnNlcnZhdGlvbiBpbnNpZGUgYSBjb21wb25lbnQnc1xuICogdXBkYXRlIGNvbXB1dGF0aW9uLlxuICovXG52YXIgc2hvdWxkT2JzZXJ2ZSA9IHRydWU7XG5cbmZ1bmN0aW9uIHRvZ2dsZU9ic2VydmluZyAodmFsdWUpIHtcbiAgc2hvdWxkT2JzZXJ2ZSA9IHZhbHVlO1xufVxuXG4vKipcbiAqIE9ic2VydmVyIGNsYXNzIHRoYXQgaXMgYXR0YWNoZWQgdG8gZWFjaCBvYnNlcnZlZFxuICogb2JqZWN0LiBPbmNlIGF0dGFjaGVkLCB0aGUgb2JzZXJ2ZXIgY29udmVydHMgdGhlIHRhcmdldFxuICogb2JqZWN0J3MgcHJvcGVydHkga2V5cyBpbnRvIGdldHRlci9zZXR0ZXJzIHRoYXRcbiAqIGNvbGxlY3QgZGVwZW5kZW5jaWVzIGFuZCBkaXNwYXRjaCB1cGRhdGVzLlxuICovXG52YXIgT2JzZXJ2ZXIgPSBmdW5jdGlvbiBPYnNlcnZlciAodmFsdWUpIHtcbiAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICB0aGlzLmRlcCA9IG5ldyBEZXAoKTtcbiAgdGhpcy52bUNvdW50ID0gMDtcbiAgZGVmKHZhbHVlLCAnX19vYl9fJywgdGhpcyk7XG4gIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgIGlmIChoYXNQcm90bykge1xuICAgICAgcHJvdG9BdWdtZW50KHZhbHVlLCBhcnJheU1ldGhvZHMpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb3B5QXVnbWVudCh2YWx1ZSwgYXJyYXlNZXRob2RzLCBhcnJheUtleXMpO1xuICAgIH1cbiAgICB0aGlzLm9ic2VydmVBcnJheSh2YWx1ZSk7XG4gIH0gZWxzZSB7XG4gICAgdGhpcy53YWxrKHZhbHVlKTtcbiAgfVxufTtcblxuLyoqXG4gKiBXYWxrIHRocm91Z2ggYWxsIHByb3BlcnRpZXMgYW5kIGNvbnZlcnQgdGhlbSBpbnRvXG4gKiBnZXR0ZXIvc2V0dGVycy4gVGhpcyBtZXRob2Qgc2hvdWxkIG9ubHkgYmUgY2FsbGVkIHdoZW5cbiAqIHZhbHVlIHR5cGUgaXMgT2JqZWN0LlxuICovXG5PYnNlcnZlci5wcm90b3R5cGUud2FsayA9IGZ1bmN0aW9uIHdhbGsgKG9iaikge1xuICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKG9iaik7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7IGkrKykge1xuICAgIGRlZmluZVJlYWN0aXZlJCQxKG9iaiwga2V5c1tpXSk7XG4gIH1cbn07XG5cbi8qKlxuICogT2JzZXJ2ZSBhIGxpc3Qgb2YgQXJyYXkgaXRlbXMuXG4gKi9cbk9ic2VydmVyLnByb3RvdHlwZS5vYnNlcnZlQXJyYXkgPSBmdW5jdGlvbiBvYnNlcnZlQXJyYXkgKGl0ZW1zKSB7XG4gIGZvciAodmFyIGkgPSAwLCBsID0gaXRlbXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgb2JzZXJ2ZShpdGVtc1tpXSk7XG4gIH1cbn07XG5cbi8vIGhlbHBlcnNcblxuLyoqXG4gKiBBdWdtZW50IGEgdGFyZ2V0IE9iamVjdCBvciBBcnJheSBieSBpbnRlcmNlcHRpbmdcbiAqIHRoZSBwcm90b3R5cGUgY2hhaW4gdXNpbmcgX19wcm90b19fXG4gKi9cbmZ1bmN0aW9uIHByb3RvQXVnbWVudCAodGFyZ2V0LCBzcmMpIHtcbiAgLyogZXNsaW50LWRpc2FibGUgbm8tcHJvdG8gKi9cbiAgdGFyZ2V0Ll9fcHJvdG9fXyA9IHNyYztcbiAgLyogZXNsaW50LWVuYWJsZSBuby1wcm90byAqL1xufVxuXG4vKipcbiAqIEF1Z21lbnQgYSB0YXJnZXQgT2JqZWN0IG9yIEFycmF5IGJ5IGRlZmluaW5nXG4gKiBoaWRkZW4gcHJvcGVydGllcy5cbiAqL1xuLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbmZ1bmN0aW9uIGNvcHlBdWdtZW50ICh0YXJnZXQsIHNyYywga2V5cykge1xuICBmb3IgKHZhciBpID0gMCwgbCA9IGtleXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgdmFyIGtleSA9IGtleXNbaV07XG4gICAgZGVmKHRhcmdldCwga2V5LCBzcmNba2V5XSk7XG4gIH1cbn1cblxuLyoqXG4gKiBBdHRlbXB0IHRvIGNyZWF0ZSBhbiBvYnNlcnZlciBpbnN0YW5jZSBmb3IgYSB2YWx1ZSxcbiAqIHJldHVybnMgdGhlIG5ldyBvYnNlcnZlciBpZiBzdWNjZXNzZnVsbHkgb2JzZXJ2ZWQsXG4gKiBvciB0aGUgZXhpc3Rpbmcgb2JzZXJ2ZXIgaWYgdGhlIHZhbHVlIGFscmVhZHkgaGFzIG9uZS5cbiAqL1xuZnVuY3Rpb24gb2JzZXJ2ZSAodmFsdWUsIGFzUm9vdERhdGEpIHtcbiAgaWYgKCFpc09iamVjdCh2YWx1ZSkgfHwgdmFsdWUgaW5zdGFuY2VvZiBWTm9kZSkge1xuICAgIHJldHVyblxuICB9XG4gIHZhciBvYjtcbiAgaWYgKGhhc093bih2YWx1ZSwgJ19fb2JfXycpICYmIHZhbHVlLl9fb2JfXyBpbnN0YW5jZW9mIE9ic2VydmVyKSB7XG4gICAgb2IgPSB2YWx1ZS5fX29iX187XG4gIH0gZWxzZSBpZiAoXG4gICAgc2hvdWxkT2JzZXJ2ZSAmJlxuICAgICFpc1NlcnZlclJlbmRlcmluZygpICYmXG4gICAgKEFycmF5LmlzQXJyYXkodmFsdWUpIHx8IGlzUGxhaW5PYmplY3QodmFsdWUpKSAmJlxuICAgIE9iamVjdC5pc0V4dGVuc2libGUodmFsdWUpICYmXG4gICAgIXZhbHVlLl9pc1Z1ZVxuICApIHtcbiAgICBvYiA9IG5ldyBPYnNlcnZlcih2YWx1ZSk7XG4gIH1cbiAgaWYgKGFzUm9vdERhdGEgJiYgb2IpIHtcbiAgICBvYi52bUNvdW50Kys7XG4gIH1cbiAgcmV0dXJuIG9iXG59XG5cbi8qKlxuICogRGVmaW5lIGEgcmVhY3RpdmUgcHJvcGVydHkgb24gYW4gT2JqZWN0LlxuICovXG5mdW5jdGlvbiBkZWZpbmVSZWFjdGl2ZSQkMSAoXG4gIG9iaixcbiAga2V5LFxuICB2YWwsXG4gIGN1c3RvbVNldHRlcixcbiAgc2hhbGxvd1xuKSB7XG4gIHZhciBkZXAgPSBuZXcgRGVwKCk7XG5cbiAgdmFyIHByb3BlcnR5ID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmosIGtleSk7XG4gIGlmIChwcm9wZXJ0eSAmJiBwcm9wZXJ0eS5jb25maWd1cmFibGUgPT09IGZhbHNlKSB7XG4gICAgcmV0dXJuXG4gIH1cblxuICAvLyBjYXRlciBmb3IgcHJlLWRlZmluZWQgZ2V0dGVyL3NldHRlcnNcbiAgdmFyIGdldHRlciA9IHByb3BlcnR5ICYmIHByb3BlcnR5LmdldDtcbiAgdmFyIHNldHRlciA9IHByb3BlcnR5ICYmIHByb3BlcnR5LnNldDtcbiAgaWYgKCghZ2V0dGVyIHx8IHNldHRlcikgJiYgYXJndW1lbnRzLmxlbmd0aCA9PT0gMikge1xuICAgIHZhbCA9IG9ialtrZXldO1xuICB9XG5cbiAgdmFyIGNoaWxkT2IgPSAhc2hhbGxvdyAmJiBvYnNlcnZlKHZhbCk7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwge1xuICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgIGdldDogZnVuY3Rpb24gcmVhY3RpdmVHZXR0ZXIgKCkge1xuICAgICAgdmFyIHZhbHVlID0gZ2V0dGVyID8gZ2V0dGVyLmNhbGwob2JqKSA6IHZhbDtcbiAgICAgIGlmIChEZXAudGFyZ2V0KSB7XG4gICAgICAgIGRlcC5kZXBlbmQoKTtcbiAgICAgICAgaWYgKGNoaWxkT2IpIHtcbiAgICAgICAgICBjaGlsZE9iLmRlcC5kZXBlbmQoKTtcbiAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgICAgIGRlcGVuZEFycmF5KHZhbHVlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiB2YWx1ZVxuICAgIH0sXG4gICAgc2V0OiBmdW5jdGlvbiByZWFjdGl2ZVNldHRlciAobmV3VmFsKSB7XG4gICAgICB2YXIgdmFsdWUgPSBnZXR0ZXIgPyBnZXR0ZXIuY2FsbChvYmopIDogdmFsO1xuICAgICAgLyogZXNsaW50LWRpc2FibGUgbm8tc2VsZi1jb21wYXJlICovXG4gICAgICBpZiAobmV3VmFsID09PSB2YWx1ZSB8fCAobmV3VmFsICE9PSBuZXdWYWwgJiYgdmFsdWUgIT09IHZhbHVlKSkge1xuICAgICAgICByZXR1cm5cbiAgICAgIH1cbiAgICAgIC8qIGVzbGludC1lbmFibGUgbm8tc2VsZi1jb21wYXJlICovXG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiBjdXN0b21TZXR0ZXIpIHtcbiAgICAgICAgY3VzdG9tU2V0dGVyKCk7XG4gICAgICB9XG4gICAgICAvLyAjNzk4MTogZm9yIGFjY2Vzc29yIHByb3BlcnRpZXMgd2l0aG91dCBzZXR0ZXJcbiAgICAgIGlmIChnZXR0ZXIgJiYgIXNldHRlcikgeyByZXR1cm4gfVxuICAgICAgaWYgKHNldHRlcikge1xuICAgICAgICBzZXR0ZXIuY2FsbChvYmosIG5ld1ZhbCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YWwgPSBuZXdWYWw7XG4gICAgICB9XG4gICAgICBjaGlsZE9iID0gIXNoYWxsb3cgJiYgb2JzZXJ2ZShuZXdWYWwpO1xuICAgICAgZGVwLm5vdGlmeSgpO1xuICAgIH1cbiAgfSk7XG59XG5cbi8qKlxuICogU2V0IGEgcHJvcGVydHkgb24gYW4gb2JqZWN0LiBBZGRzIHRoZSBuZXcgcHJvcGVydHkgYW5kXG4gKiB0cmlnZ2VycyBjaGFuZ2Ugbm90aWZpY2F0aW9uIGlmIHRoZSBwcm9wZXJ0eSBkb2Vzbid0XG4gKiBhbHJlYWR5IGV4aXN0LlxuICovXG5mdW5jdGlvbiBzZXQgKHRhcmdldCwga2V5LCB2YWwpIHtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiZcbiAgICAoaXNVbmRlZih0YXJnZXQpIHx8IGlzUHJpbWl0aXZlKHRhcmdldCkpXG4gICkge1xuICAgIHdhcm4oKFwiQ2Fubm90IHNldCByZWFjdGl2ZSBwcm9wZXJ0eSBvbiB1bmRlZmluZWQsIG51bGwsIG9yIHByaW1pdGl2ZSB2YWx1ZTogXCIgKyAoKHRhcmdldCkpKSk7XG4gIH1cbiAgaWYgKEFycmF5LmlzQXJyYXkodGFyZ2V0KSAmJiBpc1ZhbGlkQXJyYXlJbmRleChrZXkpKSB7XG4gICAgdGFyZ2V0Lmxlbmd0aCA9IE1hdGgubWF4KHRhcmdldC5sZW5ndGgsIGtleSk7XG4gICAgdGFyZ2V0LnNwbGljZShrZXksIDEsIHZhbCk7XG4gICAgcmV0dXJuIHZhbFxuICB9XG4gIGlmIChrZXkgaW4gdGFyZ2V0ICYmICEoa2V5IGluIE9iamVjdC5wcm90b3R5cGUpKSB7XG4gICAgdGFyZ2V0W2tleV0gPSB2YWw7XG4gICAgcmV0dXJuIHZhbFxuICB9XG4gIHZhciBvYiA9ICh0YXJnZXQpLl9fb2JfXztcbiAgaWYgKHRhcmdldC5faXNWdWUgfHwgKG9iICYmIG9iLnZtQ291bnQpKSB7XG4gICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiB3YXJuKFxuICAgICAgJ0F2b2lkIGFkZGluZyByZWFjdGl2ZSBwcm9wZXJ0aWVzIHRvIGEgVnVlIGluc3RhbmNlIG9yIGl0cyByb290ICRkYXRhICcgK1xuICAgICAgJ2F0IHJ1bnRpbWUgLSBkZWNsYXJlIGl0IHVwZnJvbnQgaW4gdGhlIGRhdGEgb3B0aW9uLidcbiAgICApO1xuICAgIHJldHVybiB2YWxcbiAgfVxuICBpZiAoIW9iKSB7XG4gICAgdGFyZ2V0W2tleV0gPSB2YWw7XG4gICAgcmV0dXJuIHZhbFxuICB9XG4gIGRlZmluZVJlYWN0aXZlJCQxKG9iLnZhbHVlLCBrZXksIHZhbCk7XG4gIG9iLmRlcC5ub3RpZnkoKTtcbiAgcmV0dXJuIHZhbFxufVxuXG4vKipcbiAqIERlbGV0ZSBhIHByb3BlcnR5IGFuZCB0cmlnZ2VyIGNoYW5nZSBpZiBuZWNlc3NhcnkuXG4gKi9cbmZ1bmN0aW9uIGRlbCAodGFyZ2V0LCBrZXkpIHtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiZcbiAgICAoaXNVbmRlZih0YXJnZXQpIHx8IGlzUHJpbWl0aXZlKHRhcmdldCkpXG4gICkge1xuICAgIHdhcm4oKFwiQ2Fubm90IGRlbGV0ZSByZWFjdGl2ZSBwcm9wZXJ0eSBvbiB1bmRlZmluZWQsIG51bGwsIG9yIHByaW1pdGl2ZSB2YWx1ZTogXCIgKyAoKHRhcmdldCkpKSk7XG4gIH1cbiAgaWYgKEFycmF5LmlzQXJyYXkodGFyZ2V0KSAmJiBpc1ZhbGlkQXJyYXlJbmRleChrZXkpKSB7XG4gICAgdGFyZ2V0LnNwbGljZShrZXksIDEpO1xuICAgIHJldHVyblxuICB9XG4gIHZhciBvYiA9ICh0YXJnZXQpLl9fb2JfXztcbiAgaWYgKHRhcmdldC5faXNWdWUgfHwgKG9iICYmIG9iLnZtQ291bnQpKSB7XG4gICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiB3YXJuKFxuICAgICAgJ0F2b2lkIGRlbGV0aW5nIHByb3BlcnRpZXMgb24gYSBWdWUgaW5zdGFuY2Ugb3IgaXRzIHJvb3QgJGRhdGEgJyArXG4gICAgICAnLSBqdXN0IHNldCBpdCB0byBudWxsLidcbiAgICApO1xuICAgIHJldHVyblxuICB9XG4gIGlmICghaGFzT3duKHRhcmdldCwga2V5KSkge1xuICAgIHJldHVyblxuICB9XG4gIGRlbGV0ZSB0YXJnZXRba2V5XTtcbiAgaWYgKCFvYikge1xuICAgIHJldHVyblxuICB9XG4gIG9iLmRlcC5ub3RpZnkoKTtcbn1cblxuLyoqXG4gKiBDb2xsZWN0IGRlcGVuZGVuY2llcyBvbiBhcnJheSBlbGVtZW50cyB3aGVuIHRoZSBhcnJheSBpcyB0b3VjaGVkLCBzaW5jZVxuICogd2UgY2Fubm90IGludGVyY2VwdCBhcnJheSBlbGVtZW50IGFjY2VzcyBsaWtlIHByb3BlcnR5IGdldHRlcnMuXG4gKi9cbmZ1bmN0aW9uIGRlcGVuZEFycmF5ICh2YWx1ZSkge1xuICBmb3IgKHZhciBlID0gKHZvaWQgMCksIGkgPSAwLCBsID0gdmFsdWUubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgZSA9IHZhbHVlW2ldO1xuICAgIGUgJiYgZS5fX29iX18gJiYgZS5fX29iX18uZGVwLmRlcGVuZCgpO1xuICAgIGlmIChBcnJheS5pc0FycmF5KGUpKSB7XG4gICAgICBkZXBlbmRBcnJheShlKTtcbiAgICB9XG4gIH1cbn1cblxuLyogICovXG5cbi8qKlxuICogT3B0aW9uIG92ZXJ3cml0aW5nIHN0cmF0ZWdpZXMgYXJlIGZ1bmN0aW9ucyB0aGF0IGhhbmRsZVxuICogaG93IHRvIG1lcmdlIGEgcGFyZW50IG9wdGlvbiB2YWx1ZSBhbmQgYSBjaGlsZCBvcHRpb25cbiAqIHZhbHVlIGludG8gdGhlIGZpbmFsIHZhbHVlLlxuICovXG52YXIgc3RyYXRzID0gY29uZmlnLm9wdGlvbk1lcmdlU3RyYXRlZ2llcztcblxuLyoqXG4gKiBPcHRpb25zIHdpdGggcmVzdHJpY3Rpb25zXG4gKi9cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIHN0cmF0cy5lbCA9IHN0cmF0cy5wcm9wc0RhdGEgPSBmdW5jdGlvbiAocGFyZW50LCBjaGlsZCwgdm0sIGtleSkge1xuICAgIGlmICghdm0pIHtcbiAgICAgIHdhcm4oXG4gICAgICAgIFwib3B0aW9uIFxcXCJcIiArIGtleSArIFwiXFxcIiBjYW4gb25seSBiZSB1c2VkIGR1cmluZyBpbnN0YW5jZSBcIiArXG4gICAgICAgICdjcmVhdGlvbiB3aXRoIHRoZSBgbmV3YCBrZXl3b3JkLidcbiAgICAgICk7XG4gICAgfVxuICAgIHJldHVybiBkZWZhdWx0U3RyYXQocGFyZW50LCBjaGlsZClcbiAgfTtcbn1cblxuLyoqXG4gKiBIZWxwZXIgdGhhdCByZWN1cnNpdmVseSBtZXJnZXMgdHdvIGRhdGEgb2JqZWN0cyB0b2dldGhlci5cbiAqL1xuZnVuY3Rpb24gbWVyZ2VEYXRhICh0bywgZnJvbSkge1xuICBpZiAoIWZyb20pIHsgcmV0dXJuIHRvIH1cbiAgdmFyIGtleSwgdG9WYWwsIGZyb21WYWw7XG5cbiAgdmFyIGtleXMgPSBoYXNTeW1ib2xcbiAgICA/IFJlZmxlY3Qub3duS2V5cyhmcm9tKVxuICAgIDogT2JqZWN0LmtleXMoZnJvbSk7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAga2V5ID0ga2V5c1tpXTtcbiAgICAvLyBpbiBjYXNlIHRoZSBvYmplY3QgaXMgYWxyZWFkeSBvYnNlcnZlZC4uLlxuICAgIGlmIChrZXkgPT09ICdfX29iX18nKSB7IGNvbnRpbnVlIH1cbiAgICB0b1ZhbCA9IHRvW2tleV07XG4gICAgZnJvbVZhbCA9IGZyb21ba2V5XTtcbiAgICBpZiAoIWhhc093bih0bywga2V5KSkge1xuICAgICAgc2V0KHRvLCBrZXksIGZyb21WYWwpO1xuICAgIH0gZWxzZSBpZiAoXG4gICAgICB0b1ZhbCAhPT0gZnJvbVZhbCAmJlxuICAgICAgaXNQbGFpbk9iamVjdCh0b1ZhbCkgJiZcbiAgICAgIGlzUGxhaW5PYmplY3QoZnJvbVZhbClcbiAgICApIHtcbiAgICAgIG1lcmdlRGF0YSh0b1ZhbCwgZnJvbVZhbCk7XG4gICAgfVxuICB9XG4gIHJldHVybiB0b1xufVxuXG4vKipcbiAqIERhdGFcbiAqL1xuZnVuY3Rpb24gbWVyZ2VEYXRhT3JGbiAoXG4gIHBhcmVudFZhbCxcbiAgY2hpbGRWYWwsXG4gIHZtXG4pIHtcbiAgaWYgKCF2bSkge1xuICAgIC8vIGluIGEgVnVlLmV4dGVuZCBtZXJnZSwgYm90aCBzaG91bGQgYmUgZnVuY3Rpb25zXG4gICAgaWYgKCFjaGlsZFZhbCkge1xuICAgICAgcmV0dXJuIHBhcmVudFZhbFxuICAgIH1cbiAgICBpZiAoIXBhcmVudFZhbCkge1xuICAgICAgcmV0dXJuIGNoaWxkVmFsXG4gICAgfVxuICAgIC8vIHdoZW4gcGFyZW50VmFsICYgY2hpbGRWYWwgYXJlIGJvdGggcHJlc2VudCxcbiAgICAvLyB3ZSBuZWVkIHRvIHJldHVybiBhIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyB0aGVcbiAgICAvLyBtZXJnZWQgcmVzdWx0IG9mIGJvdGggZnVuY3Rpb25zLi4uIG5vIG5lZWQgdG9cbiAgICAvLyBjaGVjayBpZiBwYXJlbnRWYWwgaXMgYSBmdW5jdGlvbiBoZXJlIGJlY2F1c2VcbiAgICAvLyBpdCBoYXMgdG8gYmUgYSBmdW5jdGlvbiB0byBwYXNzIHByZXZpb3VzIG1lcmdlcy5cbiAgICByZXR1cm4gZnVuY3Rpb24gbWVyZ2VkRGF0YUZuICgpIHtcbiAgICAgIHJldHVybiBtZXJnZURhdGEoXG4gICAgICAgIHR5cGVvZiBjaGlsZFZhbCA9PT0gJ2Z1bmN0aW9uJyA/IGNoaWxkVmFsLmNhbGwodGhpcywgdGhpcykgOiBjaGlsZFZhbCxcbiAgICAgICAgdHlwZW9mIHBhcmVudFZhbCA9PT0gJ2Z1bmN0aW9uJyA/IHBhcmVudFZhbC5jYWxsKHRoaXMsIHRoaXMpIDogcGFyZW50VmFsXG4gICAgICApXG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHJldHVybiBmdW5jdGlvbiBtZXJnZWRJbnN0YW5jZURhdGFGbiAoKSB7XG4gICAgICAvLyBpbnN0YW5jZSBtZXJnZVxuICAgICAgdmFyIGluc3RhbmNlRGF0YSA9IHR5cGVvZiBjaGlsZFZhbCA9PT0gJ2Z1bmN0aW9uJ1xuICAgICAgICA/IGNoaWxkVmFsLmNhbGwodm0sIHZtKVxuICAgICAgICA6IGNoaWxkVmFsO1xuICAgICAgdmFyIGRlZmF1bHREYXRhID0gdHlwZW9mIHBhcmVudFZhbCA9PT0gJ2Z1bmN0aW9uJ1xuICAgICAgICA/IHBhcmVudFZhbC5jYWxsKHZtLCB2bSlcbiAgICAgICAgOiBwYXJlbnRWYWw7XG4gICAgICBpZiAoaW5zdGFuY2VEYXRhKSB7XG4gICAgICAgIHJldHVybiBtZXJnZURhdGEoaW5zdGFuY2VEYXRhLCBkZWZhdWx0RGF0YSlcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBkZWZhdWx0RGF0YVxuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5zdHJhdHMuZGF0YSA9IGZ1bmN0aW9uIChcbiAgcGFyZW50VmFsLFxuICBjaGlsZFZhbCxcbiAgdm1cbikge1xuICBpZiAoIXZtKSB7XG4gICAgaWYgKGNoaWxkVmFsICYmIHR5cGVvZiBjaGlsZFZhbCAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiB3YXJuKFxuICAgICAgICAnVGhlIFwiZGF0YVwiIG9wdGlvbiBzaG91bGQgYmUgYSBmdW5jdGlvbiAnICtcbiAgICAgICAgJ3RoYXQgcmV0dXJucyBhIHBlci1pbnN0YW5jZSB2YWx1ZSBpbiBjb21wb25lbnQgJyArXG4gICAgICAgICdkZWZpbml0aW9ucy4nLFxuICAgICAgICB2bVxuICAgICAgKTtcblxuICAgICAgcmV0dXJuIHBhcmVudFZhbFxuICAgIH1cbiAgICByZXR1cm4gbWVyZ2VEYXRhT3JGbihwYXJlbnRWYWwsIGNoaWxkVmFsKVxuICB9XG5cbiAgcmV0dXJuIG1lcmdlRGF0YU9yRm4ocGFyZW50VmFsLCBjaGlsZFZhbCwgdm0pXG59O1xuXG4vKipcbiAqIEhvb2tzIGFuZCBwcm9wcyBhcmUgbWVyZ2VkIGFzIGFycmF5cy5cbiAqL1xuZnVuY3Rpb24gbWVyZ2VIb29rIChcbiAgcGFyZW50VmFsLFxuICBjaGlsZFZhbFxuKSB7XG4gIHZhciByZXMgPSBjaGlsZFZhbFxuICAgID8gcGFyZW50VmFsXG4gICAgICA/IHBhcmVudFZhbC5jb25jYXQoY2hpbGRWYWwpXG4gICAgICA6IEFycmF5LmlzQXJyYXkoY2hpbGRWYWwpXG4gICAgICAgID8gY2hpbGRWYWxcbiAgICAgICAgOiBbY2hpbGRWYWxdXG4gICAgOiBwYXJlbnRWYWw7XG4gIHJldHVybiByZXNcbiAgICA/IGRlZHVwZUhvb2tzKHJlcylcbiAgICA6IHJlc1xufVxuXG5mdW5jdGlvbiBkZWR1cGVIb29rcyAoaG9va3MpIHtcbiAgdmFyIHJlcyA9IFtdO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGhvb2tzLmxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKHJlcy5pbmRleE9mKGhvb2tzW2ldKSA9PT0gLTEpIHtcbiAgICAgIHJlcy5wdXNoKGhvb2tzW2ldKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc1xufVxuXG5MSUZFQ1lDTEVfSE9PS1MuZm9yRWFjaChmdW5jdGlvbiAoaG9vaykge1xuICBzdHJhdHNbaG9va10gPSBtZXJnZUhvb2s7XG59KTtcblxuLyoqXG4gKiBBc3NldHNcbiAqXG4gKiBXaGVuIGEgdm0gaXMgcHJlc2VudCAoaW5zdGFuY2UgY3JlYXRpb24pLCB3ZSBuZWVkIHRvIGRvXG4gKiBhIHRocmVlLXdheSBtZXJnZSBiZXR3ZWVuIGNvbnN0cnVjdG9yIG9wdGlvbnMsIGluc3RhbmNlXG4gKiBvcHRpb25zIGFuZCBwYXJlbnQgb3B0aW9ucy5cbiAqL1xuZnVuY3Rpb24gbWVyZ2VBc3NldHMgKFxuICBwYXJlbnRWYWwsXG4gIGNoaWxkVmFsLFxuICB2bSxcbiAga2V5XG4pIHtcbiAgdmFyIHJlcyA9IE9iamVjdC5jcmVhdGUocGFyZW50VmFsIHx8IG51bGwpO1xuICBpZiAoY2hpbGRWYWwpIHtcbiAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIGFzc2VydE9iamVjdFR5cGUoa2V5LCBjaGlsZFZhbCwgdm0pO1xuICAgIHJldHVybiBleHRlbmQocmVzLCBjaGlsZFZhbClcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gcmVzXG4gIH1cbn1cblxuQVNTRVRfVFlQRVMuZm9yRWFjaChmdW5jdGlvbiAodHlwZSkge1xuICBzdHJhdHNbdHlwZSArICdzJ10gPSBtZXJnZUFzc2V0cztcbn0pO1xuXG4vKipcbiAqIFdhdGNoZXJzLlxuICpcbiAqIFdhdGNoZXJzIGhhc2hlcyBzaG91bGQgbm90IG92ZXJ3cml0ZSBvbmVcbiAqIGFub3RoZXIsIHNvIHdlIG1lcmdlIHRoZW0gYXMgYXJyYXlzLlxuICovXG5zdHJhdHMud2F0Y2ggPSBmdW5jdGlvbiAoXG4gIHBhcmVudFZhbCxcbiAgY2hpbGRWYWwsXG4gIHZtLFxuICBrZXlcbikge1xuICAvLyB3b3JrIGFyb3VuZCBGaXJlZm94J3MgT2JqZWN0LnByb3RvdHlwZS53YXRjaC4uLlxuICBpZiAocGFyZW50VmFsID09PSBuYXRpdmVXYXRjaCkgeyBwYXJlbnRWYWwgPSB1bmRlZmluZWQ7IH1cbiAgaWYgKGNoaWxkVmFsID09PSBuYXRpdmVXYXRjaCkgeyBjaGlsZFZhbCA9IHVuZGVmaW5lZDsgfVxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgaWYgKCFjaGlsZFZhbCkgeyByZXR1cm4gT2JqZWN0LmNyZWF0ZShwYXJlbnRWYWwgfHwgbnVsbCkgfVxuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIGFzc2VydE9iamVjdFR5cGUoa2V5LCBjaGlsZFZhbCwgdm0pO1xuICB9XG4gIGlmICghcGFyZW50VmFsKSB7IHJldHVybiBjaGlsZFZhbCB9XG4gIHZhciByZXQgPSB7fTtcbiAgZXh0ZW5kKHJldCwgcGFyZW50VmFsKTtcbiAgZm9yICh2YXIga2V5JDEgaW4gY2hpbGRWYWwpIHtcbiAgICB2YXIgcGFyZW50ID0gcmV0W2tleSQxXTtcbiAgICB2YXIgY2hpbGQgPSBjaGlsZFZhbFtrZXkkMV07XG4gICAgaWYgKHBhcmVudCAmJiAhQXJyYXkuaXNBcnJheShwYXJlbnQpKSB7XG4gICAgICBwYXJlbnQgPSBbcGFyZW50XTtcbiAgICB9XG4gICAgcmV0W2tleSQxXSA9IHBhcmVudFxuICAgICAgPyBwYXJlbnQuY29uY2F0KGNoaWxkKVxuICAgICAgOiBBcnJheS5pc0FycmF5KGNoaWxkKSA/IGNoaWxkIDogW2NoaWxkXTtcbiAgfVxuICByZXR1cm4gcmV0XG59O1xuXG4vKipcbiAqIE90aGVyIG9iamVjdCBoYXNoZXMuXG4gKi9cbnN0cmF0cy5wcm9wcyA9XG5zdHJhdHMubWV0aG9kcyA9XG5zdHJhdHMuaW5qZWN0ID1cbnN0cmF0cy5jb21wdXRlZCA9IGZ1bmN0aW9uIChcbiAgcGFyZW50VmFsLFxuICBjaGlsZFZhbCxcbiAgdm0sXG4gIGtleVxuKSB7XG4gIGlmIChjaGlsZFZhbCAmJiBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgYXNzZXJ0T2JqZWN0VHlwZShrZXksIGNoaWxkVmFsLCB2bSk7XG4gIH1cbiAgaWYgKCFwYXJlbnRWYWwpIHsgcmV0dXJuIGNoaWxkVmFsIH1cbiAgdmFyIHJldCA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gIGV4dGVuZChyZXQsIHBhcmVudFZhbCk7XG4gIGlmIChjaGlsZFZhbCkgeyBleHRlbmQocmV0LCBjaGlsZFZhbCk7IH1cbiAgcmV0dXJuIHJldFxufTtcbnN0cmF0cy5wcm92aWRlID0gbWVyZ2VEYXRhT3JGbjtcblxuLyoqXG4gKiBEZWZhdWx0IHN0cmF0ZWd5LlxuICovXG52YXIgZGVmYXVsdFN0cmF0ID0gZnVuY3Rpb24gKHBhcmVudFZhbCwgY2hpbGRWYWwpIHtcbiAgcmV0dXJuIGNoaWxkVmFsID09PSB1bmRlZmluZWRcbiAgICA/IHBhcmVudFZhbFxuICAgIDogY2hpbGRWYWxcbn07XG5cbi8qKlxuICogVmFsaWRhdGUgY29tcG9uZW50IG5hbWVzXG4gKi9cbmZ1bmN0aW9uIGNoZWNrQ29tcG9uZW50cyAob3B0aW9ucykge1xuICBmb3IgKHZhciBrZXkgaW4gb3B0aW9ucy5jb21wb25lbnRzKSB7XG4gICAgdmFsaWRhdGVDb21wb25lbnROYW1lKGtleSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gdmFsaWRhdGVDb21wb25lbnROYW1lIChuYW1lKSB7XG4gIGlmICghbmV3IFJlZ0V4cCgoXCJeW2EtekEtWl1bXFxcXC1cXFxcLjAtOV9cIiArICh1bmljb2RlUmVnRXhwLnNvdXJjZSkgKyBcIl0qJFwiKSkudGVzdChuYW1lKSkge1xuICAgIHdhcm4oXG4gICAgICAnSW52YWxpZCBjb21wb25lbnQgbmFtZTogXCInICsgbmFtZSArICdcIi4gQ29tcG9uZW50IG5hbWVzICcgK1xuICAgICAgJ3Nob3VsZCBjb25mb3JtIHRvIHZhbGlkIGN1c3RvbSBlbGVtZW50IG5hbWUgaW4gaHRtbDUgc3BlY2lmaWNhdGlvbi4nXG4gICAgKTtcbiAgfVxuICBpZiAoaXNCdWlsdEluVGFnKG5hbWUpIHx8IGNvbmZpZy5pc1Jlc2VydmVkVGFnKG5hbWUpKSB7XG4gICAgd2FybihcbiAgICAgICdEbyBub3QgdXNlIGJ1aWx0LWluIG9yIHJlc2VydmVkIEhUTUwgZWxlbWVudHMgYXMgY29tcG9uZW50ICcgK1xuICAgICAgJ2lkOiAnICsgbmFtZVxuICAgICk7XG4gIH1cbn1cblxuLyoqXG4gKiBFbnN1cmUgYWxsIHByb3BzIG9wdGlvbiBzeW50YXggYXJlIG5vcm1hbGl6ZWQgaW50byB0aGVcbiAqIE9iamVjdC1iYXNlZCBmb3JtYXQuXG4gKi9cbmZ1bmN0aW9uIG5vcm1hbGl6ZVByb3BzIChvcHRpb25zLCB2bSkge1xuICB2YXIgcHJvcHMgPSBvcHRpb25zLnByb3BzO1xuICBpZiAoIXByb3BzKSB7IHJldHVybiB9XG4gIHZhciByZXMgPSB7fTtcbiAgdmFyIGksIHZhbCwgbmFtZTtcbiAgaWYgKEFycmF5LmlzQXJyYXkocHJvcHMpKSB7XG4gICAgaSA9IHByb3BzLmxlbmd0aDtcbiAgICB3aGlsZSAoaS0tKSB7XG4gICAgICB2YWwgPSBwcm9wc1tpXTtcbiAgICAgIGlmICh0eXBlb2YgdmFsID09PSAnc3RyaW5nJykge1xuICAgICAgICBuYW1lID0gY2FtZWxpemUodmFsKTtcbiAgICAgICAgcmVzW25hbWVdID0geyB0eXBlOiBudWxsIH07XG4gICAgICB9IGVsc2UgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgd2FybigncHJvcHMgbXVzdCBiZSBzdHJpbmdzIHdoZW4gdXNpbmcgYXJyYXkgc3ludGF4LicpO1xuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIGlmIChpc1BsYWluT2JqZWN0KHByb3BzKSkge1xuICAgIGZvciAodmFyIGtleSBpbiBwcm9wcykge1xuICAgICAgdmFsID0gcHJvcHNba2V5XTtcbiAgICAgIG5hbWUgPSBjYW1lbGl6ZShrZXkpO1xuICAgICAgcmVzW25hbWVdID0gaXNQbGFpbk9iamVjdCh2YWwpXG4gICAgICAgID8gdmFsXG4gICAgICAgIDogeyB0eXBlOiB2YWwgfTtcbiAgICB9XG4gIH0gZWxzZSBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIHdhcm4oXG4gICAgICBcIkludmFsaWQgdmFsdWUgZm9yIG9wdGlvbiBcXFwicHJvcHNcXFwiOiBleHBlY3RlZCBhbiBBcnJheSBvciBhbiBPYmplY3QsIFwiICtcbiAgICAgIFwiYnV0IGdvdCBcIiArICh0b1Jhd1R5cGUocHJvcHMpKSArIFwiLlwiLFxuICAgICAgdm1cbiAgICApO1xuICB9XG4gIG9wdGlvbnMucHJvcHMgPSByZXM7XG59XG5cbi8qKlxuICogTm9ybWFsaXplIGFsbCBpbmplY3Rpb25zIGludG8gT2JqZWN0LWJhc2VkIGZvcm1hdFxuICovXG5mdW5jdGlvbiBub3JtYWxpemVJbmplY3QgKG9wdGlvbnMsIHZtKSB7XG4gIHZhciBpbmplY3QgPSBvcHRpb25zLmluamVjdDtcbiAgaWYgKCFpbmplY3QpIHsgcmV0dXJuIH1cbiAgdmFyIG5vcm1hbGl6ZWQgPSBvcHRpb25zLmluamVjdCA9IHt9O1xuICBpZiAoQXJyYXkuaXNBcnJheShpbmplY3QpKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBpbmplY3QubGVuZ3RoOyBpKyspIHtcbiAgICAgIG5vcm1hbGl6ZWRbaW5qZWN0W2ldXSA9IHsgZnJvbTogaW5qZWN0W2ldIH07XG4gICAgfVxuICB9IGVsc2UgaWYgKGlzUGxhaW5PYmplY3QoaW5qZWN0KSkge1xuICAgIGZvciAodmFyIGtleSBpbiBpbmplY3QpIHtcbiAgICAgIHZhciB2YWwgPSBpbmplY3Rba2V5XTtcbiAgICAgIG5vcm1hbGl6ZWRba2V5XSA9IGlzUGxhaW5PYmplY3QodmFsKVxuICAgICAgICA/IGV4dGVuZCh7IGZyb206IGtleSB9LCB2YWwpXG4gICAgICAgIDogeyBmcm9tOiB2YWwgfTtcbiAgICB9XG4gIH0gZWxzZSBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIHdhcm4oXG4gICAgICBcIkludmFsaWQgdmFsdWUgZm9yIG9wdGlvbiBcXFwiaW5qZWN0XFxcIjogZXhwZWN0ZWQgYW4gQXJyYXkgb3IgYW4gT2JqZWN0LCBcIiArXG4gICAgICBcImJ1dCBnb3QgXCIgKyAodG9SYXdUeXBlKGluamVjdCkpICsgXCIuXCIsXG4gICAgICB2bVxuICAgICk7XG4gIH1cbn1cblxuLyoqXG4gKiBOb3JtYWxpemUgcmF3IGZ1bmN0aW9uIGRpcmVjdGl2ZXMgaW50byBvYmplY3QgZm9ybWF0LlxuICovXG5mdW5jdGlvbiBub3JtYWxpemVEaXJlY3RpdmVzIChvcHRpb25zKSB7XG4gIHZhciBkaXJzID0gb3B0aW9ucy5kaXJlY3RpdmVzO1xuICBpZiAoZGlycykge1xuICAgIGZvciAodmFyIGtleSBpbiBkaXJzKSB7XG4gICAgICB2YXIgZGVmJCQxID0gZGlyc1trZXldO1xuICAgICAgaWYgKHR5cGVvZiBkZWYkJDEgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgZGlyc1trZXldID0geyBiaW5kOiBkZWYkJDEsIHVwZGF0ZTogZGVmJCQxIH07XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGFzc2VydE9iamVjdFR5cGUgKG5hbWUsIHZhbHVlLCB2bSkge1xuICBpZiAoIWlzUGxhaW5PYmplY3QodmFsdWUpKSB7XG4gICAgd2FybihcbiAgICAgIFwiSW52YWxpZCB2YWx1ZSBmb3Igb3B0aW9uIFxcXCJcIiArIG5hbWUgKyBcIlxcXCI6IGV4cGVjdGVkIGFuIE9iamVjdCwgXCIgK1xuICAgICAgXCJidXQgZ290IFwiICsgKHRvUmF3VHlwZSh2YWx1ZSkpICsgXCIuXCIsXG4gICAgICB2bVxuICAgICk7XG4gIH1cbn1cblxuLyoqXG4gKiBNZXJnZSB0d28gb3B0aW9uIG9iamVjdHMgaW50byBhIG5ldyBvbmUuXG4gKiBDb3JlIHV0aWxpdHkgdXNlZCBpbiBib3RoIGluc3RhbnRpYXRpb24gYW5kIGluaGVyaXRhbmNlLlxuICovXG5mdW5jdGlvbiBtZXJnZU9wdGlvbnMgKFxuICBwYXJlbnQsXG4gIGNoaWxkLFxuICB2bVxuKSB7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgY2hlY2tDb21wb25lbnRzKGNoaWxkKTtcbiAgfVxuXG4gIGlmICh0eXBlb2YgY2hpbGQgPT09ICdmdW5jdGlvbicpIHtcbiAgICBjaGlsZCA9IGNoaWxkLm9wdGlvbnM7XG4gIH1cblxuICBub3JtYWxpemVQcm9wcyhjaGlsZCwgdm0pO1xuICBub3JtYWxpemVJbmplY3QoY2hpbGQsIHZtKTtcbiAgbm9ybWFsaXplRGlyZWN0aXZlcyhjaGlsZCk7XG5cbiAgLy8gQXBwbHkgZXh0ZW5kcyBhbmQgbWl4aW5zIG9uIHRoZSBjaGlsZCBvcHRpb25zLFxuICAvLyBidXQgb25seSBpZiBpdCBpcyBhIHJhdyBvcHRpb25zIG9iamVjdCB0aGF0IGlzbid0XG4gIC8vIHRoZSByZXN1bHQgb2YgYW5vdGhlciBtZXJnZU9wdGlvbnMgY2FsbC5cbiAgLy8gT25seSBtZXJnZWQgb3B0aW9ucyBoYXMgdGhlIF9iYXNlIHByb3BlcnR5LlxuICBpZiAoIWNoaWxkLl9iYXNlKSB7XG4gICAgaWYgKGNoaWxkLmV4dGVuZHMpIHtcbiAgICAgIHBhcmVudCA9IG1lcmdlT3B0aW9ucyhwYXJlbnQsIGNoaWxkLmV4dGVuZHMsIHZtKTtcbiAgICB9XG4gICAgaWYgKGNoaWxkLm1peGlucykge1xuICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSBjaGlsZC5taXhpbnMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgIHBhcmVudCA9IG1lcmdlT3B0aW9ucyhwYXJlbnQsIGNoaWxkLm1peGluc1tpXSwgdm0pO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHZhciBvcHRpb25zID0ge307XG4gIHZhciBrZXk7XG4gIGZvciAoa2V5IGluIHBhcmVudCkge1xuICAgIG1lcmdlRmllbGQoa2V5KTtcbiAgfVxuICBmb3IgKGtleSBpbiBjaGlsZCkge1xuICAgIGlmICghaGFzT3duKHBhcmVudCwga2V5KSkge1xuICAgICAgbWVyZ2VGaWVsZChrZXkpO1xuICAgIH1cbiAgfVxuICBmdW5jdGlvbiBtZXJnZUZpZWxkIChrZXkpIHtcbiAgICB2YXIgc3RyYXQgPSBzdHJhdHNba2V5XSB8fCBkZWZhdWx0U3RyYXQ7XG4gICAgb3B0aW9uc1trZXldID0gc3RyYXQocGFyZW50W2tleV0sIGNoaWxkW2tleV0sIHZtLCBrZXkpO1xuICB9XG4gIHJldHVybiBvcHRpb25zXG59XG5cbi8qKlxuICogUmVzb2x2ZSBhbiBhc3NldC5cbiAqIFRoaXMgZnVuY3Rpb24gaXMgdXNlZCBiZWNhdXNlIGNoaWxkIGluc3RhbmNlcyBuZWVkIGFjY2Vzc1xuICogdG8gYXNzZXRzIGRlZmluZWQgaW4gaXRzIGFuY2VzdG9yIGNoYWluLlxuICovXG5mdW5jdGlvbiByZXNvbHZlQXNzZXQgKFxuICBvcHRpb25zLFxuICB0eXBlLFxuICBpZCxcbiAgd2Fybk1pc3Npbmdcbikge1xuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgaWYgKHR5cGVvZiBpZCAhPT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm5cbiAgfVxuICB2YXIgYXNzZXRzID0gb3B0aW9uc1t0eXBlXTtcbiAgLy8gY2hlY2sgbG9jYWwgcmVnaXN0cmF0aW9uIHZhcmlhdGlvbnMgZmlyc3RcbiAgaWYgKGhhc093bihhc3NldHMsIGlkKSkgeyByZXR1cm4gYXNzZXRzW2lkXSB9XG4gIHZhciBjYW1lbGl6ZWRJZCA9IGNhbWVsaXplKGlkKTtcbiAgaWYgKGhhc093bihhc3NldHMsIGNhbWVsaXplZElkKSkgeyByZXR1cm4gYXNzZXRzW2NhbWVsaXplZElkXSB9XG4gIHZhciBQYXNjYWxDYXNlSWQgPSBjYXBpdGFsaXplKGNhbWVsaXplZElkKTtcbiAgaWYgKGhhc093bihhc3NldHMsIFBhc2NhbENhc2VJZCkpIHsgcmV0dXJuIGFzc2V0c1tQYXNjYWxDYXNlSWRdIH1cbiAgLy8gZmFsbGJhY2sgdG8gcHJvdG90eXBlIGNoYWluXG4gIHZhciByZXMgPSBhc3NldHNbaWRdIHx8IGFzc2V0c1tjYW1lbGl6ZWRJZF0gfHwgYXNzZXRzW1Bhc2NhbENhc2VJZF07XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIHdhcm5NaXNzaW5nICYmICFyZXMpIHtcbiAgICB3YXJuKFxuICAgICAgJ0ZhaWxlZCB0byByZXNvbHZlICcgKyB0eXBlLnNsaWNlKDAsIC0xKSArICc6ICcgKyBpZCxcbiAgICAgIG9wdGlvbnNcbiAgICApO1xuICB9XG4gIHJldHVybiByZXNcbn1cblxuLyogICovXG5cblxuXG5mdW5jdGlvbiB2YWxpZGF0ZVByb3AgKFxuICBrZXksXG4gIHByb3BPcHRpb25zLFxuICBwcm9wc0RhdGEsXG4gIHZtXG4pIHtcbiAgdmFyIHByb3AgPSBwcm9wT3B0aW9uc1trZXldO1xuICB2YXIgYWJzZW50ID0gIWhhc093bihwcm9wc0RhdGEsIGtleSk7XG4gIHZhciB2YWx1ZSA9IHByb3BzRGF0YVtrZXldO1xuICAvLyBib29sZWFuIGNhc3RpbmdcbiAgdmFyIGJvb2xlYW5JbmRleCA9IGdldFR5cGVJbmRleChCb29sZWFuLCBwcm9wLnR5cGUpO1xuICBpZiAoYm9vbGVhbkluZGV4ID4gLTEpIHtcbiAgICBpZiAoYWJzZW50ICYmICFoYXNPd24ocHJvcCwgJ2RlZmF1bHQnKSkge1xuICAgICAgdmFsdWUgPSBmYWxzZTtcbiAgICB9IGVsc2UgaWYgKHZhbHVlID09PSAnJyB8fCB2YWx1ZSA9PT0gaHlwaGVuYXRlKGtleSkpIHtcbiAgICAgIC8vIG9ubHkgY2FzdCBlbXB0eSBzdHJpbmcgLyBzYW1lIG5hbWUgdG8gYm9vbGVhbiBpZlxuICAgICAgLy8gYm9vbGVhbiBoYXMgaGlnaGVyIHByaW9yaXR5XG4gICAgICB2YXIgc3RyaW5nSW5kZXggPSBnZXRUeXBlSW5kZXgoU3RyaW5nLCBwcm9wLnR5cGUpO1xuICAgICAgaWYgKHN0cmluZ0luZGV4IDwgMCB8fCBib29sZWFuSW5kZXggPCBzdHJpbmdJbmRleCkge1xuICAgICAgICB2YWx1ZSA9IHRydWU7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIC8vIGNoZWNrIGRlZmF1bHQgdmFsdWVcbiAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICB2YWx1ZSA9IGdldFByb3BEZWZhdWx0VmFsdWUodm0sIHByb3AsIGtleSk7XG4gICAgLy8gc2luY2UgdGhlIGRlZmF1bHQgdmFsdWUgaXMgYSBmcmVzaCBjb3B5LFxuICAgIC8vIG1ha2Ugc3VyZSB0byBvYnNlcnZlIGl0LlxuICAgIHZhciBwcmV2U2hvdWxkT2JzZXJ2ZSA9IHNob3VsZE9ic2VydmU7XG4gICAgdG9nZ2xlT2JzZXJ2aW5nKHRydWUpO1xuICAgIG9ic2VydmUodmFsdWUpO1xuICAgIHRvZ2dsZU9ic2VydmluZyhwcmV2U2hvdWxkT2JzZXJ2ZSk7XG4gIH1cbiAgaWYgKFxuICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiZcbiAgICAvLyBza2lwIHZhbGlkYXRpb24gZm9yIHdlZXggcmVjeWNsZS1saXN0IGNoaWxkIGNvbXBvbmVudCBwcm9wc1xuICAgICEoZmFsc2UpXG4gICkge1xuICAgIGFzc2VydFByb3AocHJvcCwga2V5LCB2YWx1ZSwgdm0sIGFic2VudCk7XG4gIH1cbiAgcmV0dXJuIHZhbHVlXG59XG5cbi8qKlxuICogR2V0IHRoZSBkZWZhdWx0IHZhbHVlIG9mIGEgcHJvcC5cbiAqL1xuZnVuY3Rpb24gZ2V0UHJvcERlZmF1bHRWYWx1ZSAodm0sIHByb3AsIGtleSkge1xuICAvLyBubyBkZWZhdWx0LCByZXR1cm4gdW5kZWZpbmVkXG4gIGlmICghaGFzT3duKHByb3AsICdkZWZhdWx0JykpIHtcbiAgICByZXR1cm4gdW5kZWZpbmVkXG4gIH1cbiAgdmFyIGRlZiA9IHByb3AuZGVmYXVsdDtcbiAgLy8gd2FybiBhZ2FpbnN0IG5vbi1mYWN0b3J5IGRlZmF1bHRzIGZvciBPYmplY3QgJiBBcnJheVxuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiBpc09iamVjdChkZWYpKSB7XG4gICAgd2FybihcbiAgICAgICdJbnZhbGlkIGRlZmF1bHQgdmFsdWUgZm9yIHByb3AgXCInICsga2V5ICsgJ1wiOiAnICtcbiAgICAgICdQcm9wcyB3aXRoIHR5cGUgT2JqZWN0L0FycmF5IG11c3QgdXNlIGEgZmFjdG9yeSBmdW5jdGlvbiAnICtcbiAgICAgICd0byByZXR1cm4gdGhlIGRlZmF1bHQgdmFsdWUuJyxcbiAgICAgIHZtXG4gICAgKTtcbiAgfVxuICAvLyB0aGUgcmF3IHByb3AgdmFsdWUgd2FzIGFsc28gdW5kZWZpbmVkIGZyb20gcHJldmlvdXMgcmVuZGVyLFxuICAvLyByZXR1cm4gcHJldmlvdXMgZGVmYXVsdCB2YWx1ZSB0byBhdm9pZCB1bm5lY2Vzc2FyeSB3YXRjaGVyIHRyaWdnZXJcbiAgaWYgKHZtICYmIHZtLiRvcHRpb25zLnByb3BzRGF0YSAmJlxuICAgIHZtLiRvcHRpb25zLnByb3BzRGF0YVtrZXldID09PSB1bmRlZmluZWQgJiZcbiAgICB2bS5fcHJvcHNba2V5XSAhPT0gdW5kZWZpbmVkXG4gICkge1xuICAgIHJldHVybiB2bS5fcHJvcHNba2V5XVxuICB9XG4gIC8vIGNhbGwgZmFjdG9yeSBmdW5jdGlvbiBmb3Igbm9uLUZ1bmN0aW9uIHR5cGVzXG4gIC8vIGEgdmFsdWUgaXMgRnVuY3Rpb24gaWYgaXRzIHByb3RvdHlwZSBpcyBmdW5jdGlvbiBldmVuIGFjcm9zcyBkaWZmZXJlbnQgZXhlY3V0aW9uIGNvbnRleHRcbiAgcmV0dXJuIHR5cGVvZiBkZWYgPT09ICdmdW5jdGlvbicgJiYgZ2V0VHlwZShwcm9wLnR5cGUpICE9PSAnRnVuY3Rpb24nXG4gICAgPyBkZWYuY2FsbCh2bSlcbiAgICA6IGRlZlxufVxuXG4vKipcbiAqIEFzc2VydCB3aGV0aGVyIGEgcHJvcCBpcyB2YWxpZC5cbiAqL1xuZnVuY3Rpb24gYXNzZXJ0UHJvcCAoXG4gIHByb3AsXG4gIG5hbWUsXG4gIHZhbHVlLFxuICB2bSxcbiAgYWJzZW50XG4pIHtcbiAgaWYgKHByb3AucmVxdWlyZWQgJiYgYWJzZW50KSB7XG4gICAgd2FybihcbiAgICAgICdNaXNzaW5nIHJlcXVpcmVkIHByb3A6IFwiJyArIG5hbWUgKyAnXCInLFxuICAgICAgdm1cbiAgICApO1xuICAgIHJldHVyblxuICB9XG4gIGlmICh2YWx1ZSA9PSBudWxsICYmICFwcm9wLnJlcXVpcmVkKSB7XG4gICAgcmV0dXJuXG4gIH1cbiAgdmFyIHR5cGUgPSBwcm9wLnR5cGU7XG4gIHZhciB2YWxpZCA9ICF0eXBlIHx8IHR5cGUgPT09IHRydWU7XG4gIHZhciBleHBlY3RlZFR5cGVzID0gW107XG4gIGlmICh0eXBlKSB7XG4gICAgaWYgKCFBcnJheS5pc0FycmF5KHR5cGUpKSB7XG4gICAgICB0eXBlID0gW3R5cGVdO1xuICAgIH1cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHR5cGUubGVuZ3RoICYmICF2YWxpZDsgaSsrKSB7XG4gICAgICB2YXIgYXNzZXJ0ZWRUeXBlID0gYXNzZXJ0VHlwZSh2YWx1ZSwgdHlwZVtpXSwgdm0pO1xuICAgICAgZXhwZWN0ZWRUeXBlcy5wdXNoKGFzc2VydGVkVHlwZS5leHBlY3RlZFR5cGUgfHwgJycpO1xuICAgICAgdmFsaWQgPSBhc3NlcnRlZFR5cGUudmFsaWQ7XG4gICAgfVxuICB9XG5cbiAgdmFyIGhhdmVFeHBlY3RlZFR5cGVzID0gZXhwZWN0ZWRUeXBlcy5zb21lKGZ1bmN0aW9uICh0KSB7IHJldHVybiB0OyB9KTtcbiAgaWYgKCF2YWxpZCAmJiBoYXZlRXhwZWN0ZWRUeXBlcykge1xuICAgIHdhcm4oXG4gICAgICBnZXRJbnZhbGlkVHlwZU1lc3NhZ2UobmFtZSwgdmFsdWUsIGV4cGVjdGVkVHlwZXMpLFxuICAgICAgdm1cbiAgICApO1xuICAgIHJldHVyblxuICB9XG4gIHZhciB2YWxpZGF0b3IgPSBwcm9wLnZhbGlkYXRvcjtcbiAgaWYgKHZhbGlkYXRvcikge1xuICAgIGlmICghdmFsaWRhdG9yKHZhbHVlKSkge1xuICAgICAgd2FybihcbiAgICAgICAgJ0ludmFsaWQgcHJvcDogY3VzdG9tIHZhbGlkYXRvciBjaGVjayBmYWlsZWQgZm9yIHByb3AgXCInICsgbmFtZSArICdcIi4nLFxuICAgICAgICB2bVxuICAgICAgKTtcbiAgICB9XG4gIH1cbn1cblxudmFyIHNpbXBsZUNoZWNrUkUgPSAvXihTdHJpbmd8TnVtYmVyfEJvb2xlYW58RnVuY3Rpb258U3ltYm9sfEJpZ0ludCkkLztcblxuZnVuY3Rpb24gYXNzZXJ0VHlwZSAodmFsdWUsIHR5cGUsIHZtKSB7XG4gIHZhciB2YWxpZDtcbiAgdmFyIGV4cGVjdGVkVHlwZSA9IGdldFR5cGUodHlwZSk7XG4gIGlmIChzaW1wbGVDaGVja1JFLnRlc3QoZXhwZWN0ZWRUeXBlKSkge1xuICAgIHZhciB0ID0gdHlwZW9mIHZhbHVlO1xuICAgIHZhbGlkID0gdCA9PT0gZXhwZWN0ZWRUeXBlLnRvTG93ZXJDYXNlKCk7XG4gICAgLy8gZm9yIHByaW1pdGl2ZSB3cmFwcGVyIG9iamVjdHNcbiAgICBpZiAoIXZhbGlkICYmIHQgPT09ICdvYmplY3QnKSB7XG4gICAgICB2YWxpZCA9IHZhbHVlIGluc3RhbmNlb2YgdHlwZTtcbiAgICB9XG4gIH0gZWxzZSBpZiAoZXhwZWN0ZWRUeXBlID09PSAnT2JqZWN0Jykge1xuICAgIHZhbGlkID0gaXNQbGFpbk9iamVjdCh2YWx1ZSk7XG4gIH0gZWxzZSBpZiAoZXhwZWN0ZWRUeXBlID09PSAnQXJyYXknKSB7XG4gICAgdmFsaWQgPSBBcnJheS5pc0FycmF5KHZhbHVlKTtcbiAgfSBlbHNlIHtcbiAgICB0cnkge1xuICAgICAgdmFsaWQgPSB2YWx1ZSBpbnN0YW5jZW9mIHR5cGU7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgd2FybignSW52YWxpZCBwcm9wIHR5cGU6IFwiJyArIFN0cmluZyh0eXBlKSArICdcIiBpcyBub3QgYSBjb25zdHJ1Y3RvcicsIHZtKTtcbiAgICAgIHZhbGlkID0gZmFsc2U7XG4gICAgfVxuICB9XG4gIHJldHVybiB7XG4gICAgdmFsaWQ6IHZhbGlkLFxuICAgIGV4cGVjdGVkVHlwZTogZXhwZWN0ZWRUeXBlXG4gIH1cbn1cblxudmFyIGZ1bmN0aW9uVHlwZUNoZWNrUkUgPSAvXlxccypmdW5jdGlvbiAoXFx3KykvO1xuXG4vKipcbiAqIFVzZSBmdW5jdGlvbiBzdHJpbmcgbmFtZSB0byBjaGVjayBidWlsdC1pbiB0eXBlcyxcbiAqIGJlY2F1c2UgYSBzaW1wbGUgZXF1YWxpdHkgY2hlY2sgd2lsbCBmYWlsIHdoZW4gcnVubmluZ1xuICogYWNyb3NzIGRpZmZlcmVudCB2bXMgLyBpZnJhbWVzLlxuICovXG5mdW5jdGlvbiBnZXRUeXBlIChmbikge1xuICB2YXIgbWF0Y2ggPSBmbiAmJiBmbi50b1N0cmluZygpLm1hdGNoKGZ1bmN0aW9uVHlwZUNoZWNrUkUpO1xuICByZXR1cm4gbWF0Y2ggPyBtYXRjaFsxXSA6ICcnXG59XG5cbmZ1bmN0aW9uIGlzU2FtZVR5cGUgKGEsIGIpIHtcbiAgcmV0dXJuIGdldFR5cGUoYSkgPT09IGdldFR5cGUoYilcbn1cblxuZnVuY3Rpb24gZ2V0VHlwZUluZGV4ICh0eXBlLCBleHBlY3RlZFR5cGVzKSB7XG4gIGlmICghQXJyYXkuaXNBcnJheShleHBlY3RlZFR5cGVzKSkge1xuICAgIHJldHVybiBpc1NhbWVUeXBlKGV4cGVjdGVkVHlwZXMsIHR5cGUpID8gMCA6IC0xXG4gIH1cbiAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IGV4cGVjdGVkVHlwZXMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICBpZiAoaXNTYW1lVHlwZShleHBlY3RlZFR5cGVzW2ldLCB0eXBlKSkge1xuICAgICAgcmV0dXJuIGlcbiAgICB9XG4gIH1cbiAgcmV0dXJuIC0xXG59XG5cbmZ1bmN0aW9uIGdldEludmFsaWRUeXBlTWVzc2FnZSAobmFtZSwgdmFsdWUsIGV4cGVjdGVkVHlwZXMpIHtcbiAgdmFyIG1lc3NhZ2UgPSBcIkludmFsaWQgcHJvcDogdHlwZSBjaGVjayBmYWlsZWQgZm9yIHByb3AgXFxcIlwiICsgbmFtZSArIFwiXFxcIi5cIiArXG4gICAgXCIgRXhwZWN0ZWQgXCIgKyAoZXhwZWN0ZWRUeXBlcy5tYXAoY2FwaXRhbGl6ZSkuam9pbignLCAnKSk7XG4gIHZhciBleHBlY3RlZFR5cGUgPSBleHBlY3RlZFR5cGVzWzBdO1xuICB2YXIgcmVjZWl2ZWRUeXBlID0gdG9SYXdUeXBlKHZhbHVlKTtcbiAgLy8gY2hlY2sgaWYgd2UgbmVlZCB0byBzcGVjaWZ5IGV4cGVjdGVkIHZhbHVlXG4gIGlmIChcbiAgICBleHBlY3RlZFR5cGVzLmxlbmd0aCA9PT0gMSAmJlxuICAgIGlzRXhwbGljYWJsZShleHBlY3RlZFR5cGUpICYmXG4gICAgaXNFeHBsaWNhYmxlKHR5cGVvZiB2YWx1ZSkgJiZcbiAgICAhaXNCb29sZWFuKGV4cGVjdGVkVHlwZSwgcmVjZWl2ZWRUeXBlKVxuICApIHtcbiAgICBtZXNzYWdlICs9IFwiIHdpdGggdmFsdWUgXCIgKyAoc3R5bGVWYWx1ZSh2YWx1ZSwgZXhwZWN0ZWRUeXBlKSk7XG4gIH1cbiAgbWVzc2FnZSArPSBcIiwgZ290IFwiICsgcmVjZWl2ZWRUeXBlICsgXCIgXCI7XG4gIC8vIGNoZWNrIGlmIHdlIG5lZWQgdG8gc3BlY2lmeSByZWNlaXZlZCB2YWx1ZVxuICBpZiAoaXNFeHBsaWNhYmxlKHJlY2VpdmVkVHlwZSkpIHtcbiAgICBtZXNzYWdlICs9IFwid2l0aCB2YWx1ZSBcIiArIChzdHlsZVZhbHVlKHZhbHVlLCByZWNlaXZlZFR5cGUpKSArIFwiLlwiO1xuICB9XG4gIHJldHVybiBtZXNzYWdlXG59XG5cbmZ1bmN0aW9uIHN0eWxlVmFsdWUgKHZhbHVlLCB0eXBlKSB7XG4gIGlmICh0eXBlID09PSAnU3RyaW5nJykge1xuICAgIHJldHVybiAoXCJcXFwiXCIgKyB2YWx1ZSArIFwiXFxcIlwiKVxuICB9IGVsc2UgaWYgKHR5cGUgPT09ICdOdW1iZXInKSB7XG4gICAgcmV0dXJuIChcIlwiICsgKE51bWJlcih2YWx1ZSkpKVxuICB9IGVsc2Uge1xuICAgIHJldHVybiAoXCJcIiArIHZhbHVlKVxuICB9XG59XG5cbnZhciBFWFBMSUNBQkxFX1RZUEVTID0gWydzdHJpbmcnLCAnbnVtYmVyJywgJ2Jvb2xlYW4nXTtcbmZ1bmN0aW9uIGlzRXhwbGljYWJsZSAodmFsdWUpIHtcbiAgcmV0dXJuIEVYUExJQ0FCTEVfVFlQRVMuc29tZShmdW5jdGlvbiAoZWxlbSkgeyByZXR1cm4gdmFsdWUudG9Mb3dlckNhc2UoKSA9PT0gZWxlbTsgfSlcbn1cblxuZnVuY3Rpb24gaXNCb29sZWFuICgpIHtcbiAgdmFyIGFyZ3MgPSBbXSwgbGVuID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgd2hpbGUgKCBsZW4tLSApIGFyZ3NbIGxlbiBdID0gYXJndW1lbnRzWyBsZW4gXTtcblxuICByZXR1cm4gYXJncy5zb21lKGZ1bmN0aW9uIChlbGVtKSB7IHJldHVybiBlbGVtLnRvTG93ZXJDYXNlKCkgPT09ICdib29sZWFuJzsgfSlcbn1cblxuLyogICovXG5cbmZ1bmN0aW9uIGhhbmRsZUVycm9yIChlcnIsIHZtLCBpbmZvKSB7XG4gIC8vIERlYWN0aXZhdGUgZGVwcyB0cmFja2luZyB3aGlsZSBwcm9jZXNzaW5nIGVycm9yIGhhbmRsZXIgdG8gYXZvaWQgcG9zc2libGUgaW5maW5pdGUgcmVuZGVyaW5nLlxuICAvLyBTZWU6IGh0dHBzOi8vZ2l0aHViLmNvbS92dWVqcy92dWV4L2lzc3Vlcy8xNTA1XG4gIHB1c2hUYXJnZXQoKTtcbiAgdHJ5IHtcbiAgICBpZiAodm0pIHtcbiAgICAgIHZhciBjdXIgPSB2bTtcbiAgICAgIHdoaWxlICgoY3VyID0gY3VyLiRwYXJlbnQpKSB7XG4gICAgICAgIHZhciBob29rcyA9IGN1ci4kb3B0aW9ucy5lcnJvckNhcHR1cmVkO1xuICAgICAgICBpZiAoaG9va3MpIHtcbiAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGhvb2tzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICB2YXIgY2FwdHVyZSA9IGhvb2tzW2ldLmNhbGwoY3VyLCBlcnIsIHZtLCBpbmZvKSA9PT0gZmFsc2U7XG4gICAgICAgICAgICAgIGlmIChjYXB0dXJlKSB7IHJldHVybiB9XG4gICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgIGdsb2JhbEhhbmRsZUVycm9yKGUsIGN1ciwgJ2Vycm9yQ2FwdHVyZWQgaG9vaycpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBnbG9iYWxIYW5kbGVFcnJvcihlcnIsIHZtLCBpbmZvKTtcbiAgfSBmaW5hbGx5IHtcbiAgICBwb3BUYXJnZXQoKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBpbnZva2VXaXRoRXJyb3JIYW5kbGluZyAoXG4gIGhhbmRsZXIsXG4gIGNvbnRleHQsXG4gIGFyZ3MsXG4gIHZtLFxuICBpbmZvXG4pIHtcbiAgdmFyIHJlcztcbiAgdHJ5IHtcbiAgICByZXMgPSBhcmdzID8gaGFuZGxlci5hcHBseShjb250ZXh0LCBhcmdzKSA6IGhhbmRsZXIuY2FsbChjb250ZXh0KTtcbiAgICBpZiAocmVzICYmICFyZXMuX2lzVnVlICYmIGlzUHJvbWlzZShyZXMpICYmICFyZXMuX2hhbmRsZWQpIHtcbiAgICAgIHJlcy5jYXRjaChmdW5jdGlvbiAoZSkgeyByZXR1cm4gaGFuZGxlRXJyb3IoZSwgdm0sIGluZm8gKyBcIiAoUHJvbWlzZS9hc3luYylcIik7IH0pO1xuICAgICAgLy8gaXNzdWUgIzk1MTFcbiAgICAgIC8vIGF2b2lkIGNhdGNoIHRyaWdnZXJpbmcgbXVsdGlwbGUgdGltZXMgd2hlbiBuZXN0ZWQgY2FsbHNcbiAgICAgIHJlcy5faGFuZGxlZCA9IHRydWU7XG4gICAgfVxuICB9IGNhdGNoIChlKSB7XG4gICAgaGFuZGxlRXJyb3IoZSwgdm0sIGluZm8pO1xuICB9XG4gIHJldHVybiByZXNcbn1cblxuZnVuY3Rpb24gZ2xvYmFsSGFuZGxlRXJyb3IgKGVyciwgdm0sIGluZm8pIHtcbiAgaWYgKGNvbmZpZy5lcnJvckhhbmRsZXIpIHtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIGNvbmZpZy5lcnJvckhhbmRsZXIuY2FsbChudWxsLCBlcnIsIHZtLCBpbmZvKVxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIC8vIGlmIHRoZSB1c2VyIGludGVudGlvbmFsbHkgdGhyb3dzIHRoZSBvcmlnaW5hbCBlcnJvciBpbiB0aGUgaGFuZGxlcixcbiAgICAgIC8vIGRvIG5vdCBsb2cgaXQgdHdpY2VcbiAgICAgIGlmIChlICE9PSBlcnIpIHtcbiAgICAgICAgbG9nRXJyb3IoZSwgbnVsbCwgJ2NvbmZpZy5lcnJvckhhbmRsZXInKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgbG9nRXJyb3IoZXJyLCB2bSwgaW5mbyk7XG59XG5cbmZ1bmN0aW9uIGxvZ0Vycm9yIChlcnIsIHZtLCBpbmZvKSB7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgd2FybigoXCJFcnJvciBpbiBcIiArIGluZm8gKyBcIjogXFxcIlwiICsgKGVyci50b1N0cmluZygpKSArIFwiXFxcIlwiKSwgdm0pO1xuICB9XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG4gIGlmICgoaW5Ccm93c2VyIHx8IGluV2VleCkgJiYgdHlwZW9mIGNvbnNvbGUgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgY29uc29sZS5lcnJvcihlcnIpO1xuICB9IGVsc2Uge1xuICAgIHRocm93IGVyclxuICB9XG59XG5cbi8qICAqL1xuXG52YXIgaXNVc2luZ01pY3JvVGFzayA9IGZhbHNlO1xuXG52YXIgY2FsbGJhY2tzID0gW107XG52YXIgcGVuZGluZyA9IGZhbHNlO1xuXG5mdW5jdGlvbiBmbHVzaENhbGxiYWNrcyAoKSB7XG4gIHBlbmRpbmcgPSBmYWxzZTtcbiAgdmFyIGNvcGllcyA9IGNhbGxiYWNrcy5zbGljZSgwKTtcbiAgY2FsbGJhY2tzLmxlbmd0aCA9IDA7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgY29waWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgY29waWVzW2ldKCk7XG4gIH1cbn1cblxuLy8gSGVyZSB3ZSBoYXZlIGFzeW5jIGRlZmVycmluZyB3cmFwcGVycyB1c2luZyBtaWNyb3Rhc2tzLlxuLy8gSW4gMi41IHdlIHVzZWQgKG1hY3JvKSB0YXNrcyAoaW4gY29tYmluYXRpb24gd2l0aCBtaWNyb3Rhc2tzKS5cbi8vIEhvd2V2ZXIsIGl0IGhhcyBzdWJ0bGUgcHJvYmxlbXMgd2hlbiBzdGF0ZSBpcyBjaGFuZ2VkIHJpZ2h0IGJlZm9yZSByZXBhaW50XG4vLyAoZS5nLiAjNjgxMywgb3V0LWluIHRyYW5zaXRpb25zKS5cbi8vIEFsc28sIHVzaW5nIChtYWNybykgdGFza3MgaW4gZXZlbnQgaGFuZGxlciB3b3VsZCBjYXVzZSBzb21lIHdlaXJkIGJlaGF2aW9yc1xuLy8gdGhhdCBjYW5ub3QgYmUgY2lyY3VtdmVudGVkIChlLmcuICM3MTA5LCAjNzE1MywgIzc1NDYsICM3ODM0LCAjODEwOSkuXG4vLyBTbyB3ZSBub3cgdXNlIG1pY3JvdGFza3MgZXZlcnl3aGVyZSwgYWdhaW4uXG4vLyBBIG1ham9yIGRyYXdiYWNrIG9mIHRoaXMgdHJhZGVvZmYgaXMgdGhhdCB0aGVyZSBhcmUgc29tZSBzY2VuYXJpb3Ncbi8vIHdoZXJlIG1pY3JvdGFza3MgaGF2ZSB0b28gaGlnaCBhIHByaW9yaXR5IGFuZCBmaXJlIGluIGJldHdlZW4gc3VwcG9zZWRseVxuLy8gc2VxdWVudGlhbCBldmVudHMgKGUuZy4gIzQ1MjEsICM2NjkwLCB3aGljaCBoYXZlIHdvcmthcm91bmRzKVxuLy8gb3IgZXZlbiBiZXR3ZWVuIGJ1YmJsaW5nIG9mIHRoZSBzYW1lIGV2ZW50ICgjNjU2NikuXG52YXIgdGltZXJGdW5jO1xuXG4vLyBUaGUgbmV4dFRpY2sgYmVoYXZpb3IgbGV2ZXJhZ2VzIHRoZSBtaWNyb3Rhc2sgcXVldWUsIHdoaWNoIGNhbiBiZSBhY2Nlc3NlZFxuLy8gdmlhIGVpdGhlciBuYXRpdmUgUHJvbWlzZS50aGVuIG9yIE11dGF0aW9uT2JzZXJ2ZXIuXG4vLyBNdXRhdGlvbk9ic2VydmVyIGhhcyB3aWRlciBzdXBwb3J0LCBob3dldmVyIGl0IGlzIHNlcmlvdXNseSBidWdnZWQgaW5cbi8vIFVJV2ViVmlldyBpbiBpT1MgPj0gOS4zLjMgd2hlbiB0cmlnZ2VyZWQgaW4gdG91Y2ggZXZlbnQgaGFuZGxlcnMuIEl0XG4vLyBjb21wbGV0ZWx5IHN0b3BzIHdvcmtpbmcgYWZ0ZXIgdHJpZ2dlcmluZyBhIGZldyB0aW1lcy4uLiBzbywgaWYgbmF0aXZlXG4vLyBQcm9taXNlIGlzIGF2YWlsYWJsZSwgd2Ugd2lsbCB1c2UgaXQ6XG4vKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCwgJGZsb3ctZGlzYWJsZS1saW5lICovXG5pZiAodHlwZW9mIFByb21pc2UgIT09ICd1bmRlZmluZWQnICYmIGlzTmF0aXZlKFByb21pc2UpKSB7XG4gIHZhciBwID0gUHJvbWlzZS5yZXNvbHZlKCk7XG4gIHRpbWVyRnVuYyA9IGZ1bmN0aW9uICgpIHtcbiAgICBwLnRoZW4oZmx1c2hDYWxsYmFja3MpO1xuICAgIC8vIEluIHByb2JsZW1hdGljIFVJV2ViVmlld3MsIFByb21pc2UudGhlbiBkb2Vzbid0IGNvbXBsZXRlbHkgYnJlYWssIGJ1dFxuICAgIC8vIGl0IGNhbiBnZXQgc3R1Y2sgaW4gYSB3ZWlyZCBzdGF0ZSB3aGVyZSBjYWxsYmFja3MgYXJlIHB1c2hlZCBpbnRvIHRoZVxuICAgIC8vIG1pY3JvdGFzayBxdWV1ZSBidXQgdGhlIHF1ZXVlIGlzbid0IGJlaW5nIGZsdXNoZWQsIHVudGlsIHRoZSBicm93c2VyXG4gICAgLy8gbmVlZHMgdG8gZG8gc29tZSBvdGhlciB3b3JrLCBlLmcuIGhhbmRsZSBhIHRpbWVyLiBUaGVyZWZvcmUgd2UgY2FuXG4gICAgLy8gXCJmb3JjZVwiIHRoZSBtaWNyb3Rhc2sgcXVldWUgdG8gYmUgZmx1c2hlZCBieSBhZGRpbmcgYW4gZW1wdHkgdGltZXIuXG4gICAgaWYgKGlzSU9TKSB7IHNldFRpbWVvdXQobm9vcCk7IH1cbiAgfTtcbiAgaXNVc2luZ01pY3JvVGFzayA9IHRydWU7XG59IGVsc2UgaWYgKCFpc0lFICYmIHR5cGVvZiBNdXRhdGlvbk9ic2VydmVyICE9PSAndW5kZWZpbmVkJyAmJiAoXG4gIGlzTmF0aXZlKE11dGF0aW9uT2JzZXJ2ZXIpIHx8XG4gIC8vIFBoYW50b21KUyBhbmQgaU9TIDcueFxuICBNdXRhdGlvbk9ic2VydmVyLnRvU3RyaW5nKCkgPT09ICdbb2JqZWN0IE11dGF0aW9uT2JzZXJ2ZXJDb25zdHJ1Y3Rvcl0nXG4pKSB7XG4gIC8vIFVzZSBNdXRhdGlvbk9ic2VydmVyIHdoZXJlIG5hdGl2ZSBQcm9taXNlIGlzIG5vdCBhdmFpbGFibGUsXG4gIC8vIGUuZy4gUGhhbnRvbUpTLCBpT1M3LCBBbmRyb2lkIDQuNFxuICAvLyAoIzY0NjYgTXV0YXRpb25PYnNlcnZlciBpcyB1bnJlbGlhYmxlIGluIElFMTEpXG4gIHZhciBjb3VudGVyID0gMTtcbiAgdmFyIG9ic2VydmVyID0gbmV3IE11dGF0aW9uT2JzZXJ2ZXIoZmx1c2hDYWxsYmFja3MpO1xuICB2YXIgdGV4dE5vZGUgPSBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShTdHJpbmcoY291bnRlcikpO1xuICBvYnNlcnZlci5vYnNlcnZlKHRleHROb2RlLCB7XG4gICAgY2hhcmFjdGVyRGF0YTogdHJ1ZVxuICB9KTtcbiAgdGltZXJGdW5jID0gZnVuY3Rpb24gKCkge1xuICAgIGNvdW50ZXIgPSAoY291bnRlciArIDEpICUgMjtcbiAgICB0ZXh0Tm9kZS5kYXRhID0gU3RyaW5nKGNvdW50ZXIpO1xuICB9O1xuICBpc1VzaW5nTWljcm9UYXNrID0gdHJ1ZTtcbn0gZWxzZSBpZiAodHlwZW9mIHNldEltbWVkaWF0ZSAhPT0gJ3VuZGVmaW5lZCcgJiYgaXNOYXRpdmUoc2V0SW1tZWRpYXRlKSkge1xuICAvLyBGYWxsYmFjayB0byBzZXRJbW1lZGlhdGUuXG4gIC8vIFRlY2huaWNhbGx5IGl0IGxldmVyYWdlcyB0aGUgKG1hY3JvKSB0YXNrIHF1ZXVlLFxuICAvLyBidXQgaXQgaXMgc3RpbGwgYSBiZXR0ZXIgY2hvaWNlIHRoYW4gc2V0VGltZW91dC5cbiAgdGltZXJGdW5jID0gZnVuY3Rpb24gKCkge1xuICAgIHNldEltbWVkaWF0ZShmbHVzaENhbGxiYWNrcyk7XG4gIH07XG59IGVsc2Uge1xuICAvLyBGYWxsYmFjayB0byBzZXRUaW1lb3V0LlxuICB0aW1lckZ1bmMgPSBmdW5jdGlvbiAoKSB7XG4gICAgc2V0VGltZW91dChmbHVzaENhbGxiYWNrcywgMCk7XG4gIH07XG59XG5cbmZ1bmN0aW9uIG5leHRUaWNrIChjYiwgY3R4KSB7XG4gIHZhciBfcmVzb2x2ZTtcbiAgY2FsbGJhY2tzLnB1c2goZnVuY3Rpb24gKCkge1xuICAgIGlmIChjYikge1xuICAgICAgdHJ5IHtcbiAgICAgICAgY2IuY2FsbChjdHgpO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBoYW5kbGVFcnJvcihlLCBjdHgsICduZXh0VGljaycpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoX3Jlc29sdmUpIHtcbiAgICAgIF9yZXNvbHZlKGN0eCk7XG4gICAgfVxuICB9KTtcbiAgaWYgKCFwZW5kaW5nKSB7XG4gICAgcGVuZGluZyA9IHRydWU7XG4gICAgdGltZXJGdW5jKCk7XG4gIH1cbiAgLy8gJGZsb3ctZGlzYWJsZS1saW5lXG4gIGlmICghY2IgJiYgdHlwZW9mIFByb21pc2UgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlKSB7XG4gICAgICBfcmVzb2x2ZSA9IHJlc29sdmU7XG4gICAgfSlcbiAgfVxufVxuXG4vKiAgKi9cblxudmFyIG1hcms7XG52YXIgbWVhc3VyZTtcblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgdmFyIHBlcmYgPSBpbkJyb3dzZXIgJiYgd2luZG93LnBlcmZvcm1hbmNlO1xuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgaWYgKFxuICAgIHBlcmYgJiZcbiAgICBwZXJmLm1hcmsgJiZcbiAgICBwZXJmLm1lYXN1cmUgJiZcbiAgICBwZXJmLmNsZWFyTWFya3MgJiZcbiAgICBwZXJmLmNsZWFyTWVhc3VyZXNcbiAgKSB7XG4gICAgbWFyayA9IGZ1bmN0aW9uICh0YWcpIHsgcmV0dXJuIHBlcmYubWFyayh0YWcpOyB9O1xuICAgIG1lYXN1cmUgPSBmdW5jdGlvbiAobmFtZSwgc3RhcnRUYWcsIGVuZFRhZykge1xuICAgICAgcGVyZi5tZWFzdXJlKG5hbWUsIHN0YXJ0VGFnLCBlbmRUYWcpO1xuICAgICAgcGVyZi5jbGVhck1hcmtzKHN0YXJ0VGFnKTtcbiAgICAgIHBlcmYuY2xlYXJNYXJrcyhlbmRUYWcpO1xuICAgICAgLy8gcGVyZi5jbGVhck1lYXN1cmVzKG5hbWUpXG4gICAgfTtcbiAgfVxufVxuXG4vKiBub3QgdHlwZSBjaGVja2luZyB0aGlzIGZpbGUgYmVjYXVzZSBmbG93IGRvZXNuJ3QgcGxheSB3ZWxsIHdpdGggUHJveHkgKi9cblxudmFyIGluaXRQcm94eTtcblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgdmFyIGFsbG93ZWRHbG9iYWxzID0gbWFrZU1hcChcbiAgICAnSW5maW5pdHksdW5kZWZpbmVkLE5hTixpc0Zpbml0ZSxpc05hTiwnICtcbiAgICAncGFyc2VGbG9hdCxwYXJzZUludCxkZWNvZGVVUkksZGVjb2RlVVJJQ29tcG9uZW50LGVuY29kZVVSSSxlbmNvZGVVUklDb21wb25lbnQsJyArXG4gICAgJ01hdGgsTnVtYmVyLERhdGUsQXJyYXksT2JqZWN0LEJvb2xlYW4sU3RyaW5nLFJlZ0V4cCxNYXAsU2V0LEpTT04sSW50bCxCaWdJbnQsJyArXG4gICAgJ3JlcXVpcmUnIC8vIGZvciBXZWJwYWNrL0Jyb3dzZXJpZnlcbiAgKTtcblxuICB2YXIgd2Fybk5vblByZXNlbnQgPSBmdW5jdGlvbiAodGFyZ2V0LCBrZXkpIHtcbiAgICB3YXJuKFxuICAgICAgXCJQcm9wZXJ0eSBvciBtZXRob2QgXFxcIlwiICsga2V5ICsgXCJcXFwiIGlzIG5vdCBkZWZpbmVkIG9uIHRoZSBpbnN0YW5jZSBidXQgXCIgK1xuICAgICAgJ3JlZmVyZW5jZWQgZHVyaW5nIHJlbmRlci4gTWFrZSBzdXJlIHRoYXQgdGhpcyBwcm9wZXJ0eSBpcyByZWFjdGl2ZSwgJyArXG4gICAgICAnZWl0aGVyIGluIHRoZSBkYXRhIG9wdGlvbiwgb3IgZm9yIGNsYXNzLWJhc2VkIGNvbXBvbmVudHMsIGJ5ICcgK1xuICAgICAgJ2luaXRpYWxpemluZyB0aGUgcHJvcGVydHkuICcgK1xuICAgICAgJ1NlZTogaHR0cHM6Ly92dWVqcy5vcmcvdjIvZ3VpZGUvcmVhY3Rpdml0eS5odG1sI0RlY2xhcmluZy1SZWFjdGl2ZS1Qcm9wZXJ0aWVzLicsXG4gICAgICB0YXJnZXRcbiAgICApO1xuICB9O1xuXG4gIHZhciB3YXJuUmVzZXJ2ZWRQcmVmaXggPSBmdW5jdGlvbiAodGFyZ2V0LCBrZXkpIHtcbiAgICB3YXJuKFxuICAgICAgXCJQcm9wZXJ0eSBcXFwiXCIgKyBrZXkgKyBcIlxcXCIgbXVzdCBiZSBhY2Nlc3NlZCB3aXRoIFxcXCIkZGF0YS5cIiArIGtleSArIFwiXFxcIiBiZWNhdXNlIFwiICtcbiAgICAgICdwcm9wZXJ0aWVzIHN0YXJ0aW5nIHdpdGggXCIkXCIgb3IgXCJfXCIgYXJlIG5vdCBwcm94aWVkIGluIHRoZSBWdWUgaW5zdGFuY2UgdG8gJyArXG4gICAgICAncHJldmVudCBjb25mbGljdHMgd2l0aCBWdWUgaW50ZXJuYWxzLiAnICtcbiAgICAgICdTZWU6IGh0dHBzOi8vdnVlanMub3JnL3YyL2FwaS8jZGF0YScsXG4gICAgICB0YXJnZXRcbiAgICApO1xuICB9O1xuXG4gIHZhciBoYXNQcm94eSA9XG4gICAgdHlwZW9mIFByb3h5ICE9PSAndW5kZWZpbmVkJyAmJiBpc05hdGl2ZShQcm94eSk7XG5cbiAgaWYgKGhhc1Byb3h5KSB7XG4gICAgdmFyIGlzQnVpbHRJbk1vZGlmaWVyID0gbWFrZU1hcCgnc3RvcCxwcmV2ZW50LHNlbGYsY3RybCxzaGlmdCxhbHQsbWV0YSxleGFjdCcpO1xuICAgIGNvbmZpZy5rZXlDb2RlcyA9IG5ldyBQcm94eShjb25maWcua2V5Q29kZXMsIHtcbiAgICAgIHNldDogZnVuY3Rpb24gc2V0ICh0YXJnZXQsIGtleSwgdmFsdWUpIHtcbiAgICAgICAgaWYgKGlzQnVpbHRJbk1vZGlmaWVyKGtleSkpIHtcbiAgICAgICAgICB3YXJuKChcIkF2b2lkIG92ZXJ3cml0aW5nIGJ1aWx0LWluIG1vZGlmaWVyIGluIGNvbmZpZy5rZXlDb2RlczogLlwiICsga2V5KSk7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGFyZ2V0W2tleV0gPSB2YWx1ZTtcbiAgICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICB2YXIgaGFzSGFuZGxlciA9IHtcbiAgICBoYXM6IGZ1bmN0aW9uIGhhcyAodGFyZ2V0LCBrZXkpIHtcbiAgICAgIHZhciBoYXMgPSBrZXkgaW4gdGFyZ2V0O1xuICAgICAgdmFyIGlzQWxsb3dlZCA9IGFsbG93ZWRHbG9iYWxzKGtleSkgfHxcbiAgICAgICAgKHR5cGVvZiBrZXkgPT09ICdzdHJpbmcnICYmIGtleS5jaGFyQXQoMCkgPT09ICdfJyAmJiAhKGtleSBpbiB0YXJnZXQuJGRhdGEpKTtcbiAgICAgIGlmICghaGFzICYmICFpc0FsbG93ZWQpIHtcbiAgICAgICAgaWYgKGtleSBpbiB0YXJnZXQuJGRhdGEpIHsgd2FyblJlc2VydmVkUHJlZml4KHRhcmdldCwga2V5KTsgfVxuICAgICAgICBlbHNlIHsgd2Fybk5vblByZXNlbnQodGFyZ2V0LCBrZXkpOyB9XG4gICAgICB9XG4gICAgICByZXR1cm4gaGFzIHx8ICFpc0FsbG93ZWRcbiAgICB9XG4gIH07XG5cbiAgdmFyIGdldEhhbmRsZXIgPSB7XG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQgKHRhcmdldCwga2V5KSB7XG4gICAgICBpZiAodHlwZW9mIGtleSA9PT0gJ3N0cmluZycgJiYgIShrZXkgaW4gdGFyZ2V0KSkge1xuICAgICAgICBpZiAoa2V5IGluIHRhcmdldC4kZGF0YSkgeyB3YXJuUmVzZXJ2ZWRQcmVmaXgodGFyZ2V0LCBrZXkpOyB9XG4gICAgICAgIGVsc2UgeyB3YXJuTm9uUHJlc2VudCh0YXJnZXQsIGtleSk7IH1cbiAgICAgIH1cbiAgICAgIHJldHVybiB0YXJnZXRba2V5XVxuICAgIH1cbiAgfTtcblxuICBpbml0UHJveHkgPSBmdW5jdGlvbiBpbml0UHJveHkgKHZtKSB7XG4gICAgaWYgKGhhc1Byb3h5KSB7XG4gICAgICAvLyBkZXRlcm1pbmUgd2hpY2ggcHJveHkgaGFuZGxlciB0byB1c2VcbiAgICAgIHZhciBvcHRpb25zID0gdm0uJG9wdGlvbnM7XG4gICAgICB2YXIgaGFuZGxlcnMgPSBvcHRpb25zLnJlbmRlciAmJiBvcHRpb25zLnJlbmRlci5fd2l0aFN0cmlwcGVkXG4gICAgICAgID8gZ2V0SGFuZGxlclxuICAgICAgICA6IGhhc0hhbmRsZXI7XG4gICAgICB2bS5fcmVuZGVyUHJveHkgPSBuZXcgUHJveHkodm0sIGhhbmRsZXJzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdm0uX3JlbmRlclByb3h5ID0gdm07XG4gICAgfVxuICB9O1xufVxuXG4vKiAgKi9cblxudmFyIHNlZW5PYmplY3RzID0gbmV3IF9TZXQoKTtcblxuLyoqXG4gKiBSZWN1cnNpdmVseSB0cmF2ZXJzZSBhbiBvYmplY3QgdG8gZXZva2UgYWxsIGNvbnZlcnRlZFxuICogZ2V0dGVycywgc28gdGhhdCBldmVyeSBuZXN0ZWQgcHJvcGVydHkgaW5zaWRlIHRoZSBvYmplY3RcbiAqIGlzIGNvbGxlY3RlZCBhcyBhIFwiZGVlcFwiIGRlcGVuZGVuY3kuXG4gKi9cbmZ1bmN0aW9uIHRyYXZlcnNlICh2YWwpIHtcbiAgX3RyYXZlcnNlKHZhbCwgc2Vlbk9iamVjdHMpO1xuICBzZWVuT2JqZWN0cy5jbGVhcigpO1xufVxuXG5mdW5jdGlvbiBfdHJhdmVyc2UgKHZhbCwgc2Vlbikge1xuICB2YXIgaSwga2V5cztcbiAgdmFyIGlzQSA9IEFycmF5LmlzQXJyYXkodmFsKTtcbiAgaWYgKCghaXNBICYmICFpc09iamVjdCh2YWwpKSB8fCBPYmplY3QuaXNGcm96ZW4odmFsKSB8fCB2YWwgaW5zdGFuY2VvZiBWTm9kZSkge1xuICAgIHJldHVyblxuICB9XG4gIGlmICh2YWwuX19vYl9fKSB7XG4gICAgdmFyIGRlcElkID0gdmFsLl9fb2JfXy5kZXAuaWQ7XG4gICAgaWYgKHNlZW4uaGFzKGRlcElkKSkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuICAgIHNlZW4uYWRkKGRlcElkKTtcbiAgfVxuICBpZiAoaXNBKSB7XG4gICAgaSA9IHZhbC5sZW5ndGg7XG4gICAgd2hpbGUgKGktLSkgeyBfdHJhdmVyc2UodmFsW2ldLCBzZWVuKTsgfVxuICB9IGVsc2Uge1xuICAgIGtleXMgPSBPYmplY3Qua2V5cyh2YWwpO1xuICAgIGkgPSBrZXlzLmxlbmd0aDtcbiAgICB3aGlsZSAoaS0tKSB7IF90cmF2ZXJzZSh2YWxba2V5c1tpXV0sIHNlZW4pOyB9XG4gIH1cbn1cblxuLyogICovXG5cbnZhciBub3JtYWxpemVFdmVudCA9IGNhY2hlZChmdW5jdGlvbiAobmFtZSkge1xuICB2YXIgcGFzc2l2ZSA9IG5hbWUuY2hhckF0KDApID09PSAnJic7XG4gIG5hbWUgPSBwYXNzaXZlID8gbmFtZS5zbGljZSgxKSA6IG5hbWU7XG4gIHZhciBvbmNlJCQxID0gbmFtZS5jaGFyQXQoMCkgPT09ICd+JzsgLy8gUHJlZml4ZWQgbGFzdCwgY2hlY2tlZCBmaXJzdFxuICBuYW1lID0gb25jZSQkMSA/IG5hbWUuc2xpY2UoMSkgOiBuYW1lO1xuICB2YXIgY2FwdHVyZSA9IG5hbWUuY2hhckF0KDApID09PSAnISc7XG4gIG5hbWUgPSBjYXB0dXJlID8gbmFtZS5zbGljZSgxKSA6IG5hbWU7XG4gIHJldHVybiB7XG4gICAgbmFtZTogbmFtZSxcbiAgICBvbmNlOiBvbmNlJCQxLFxuICAgIGNhcHR1cmU6IGNhcHR1cmUsXG4gICAgcGFzc2l2ZTogcGFzc2l2ZVxuICB9XG59KTtcblxuZnVuY3Rpb24gY3JlYXRlRm5JbnZva2VyIChmbnMsIHZtKSB7XG4gIGZ1bmN0aW9uIGludm9rZXIgKCkge1xuICAgIHZhciBhcmd1bWVudHMkMSA9IGFyZ3VtZW50cztcblxuICAgIHZhciBmbnMgPSBpbnZva2VyLmZucztcbiAgICBpZiAoQXJyYXkuaXNBcnJheShmbnMpKSB7XG4gICAgICB2YXIgY2xvbmVkID0gZm5zLnNsaWNlKCk7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNsb25lZC5sZW5ndGg7IGkrKykge1xuICAgICAgICBpbnZva2VXaXRoRXJyb3JIYW5kbGluZyhjbG9uZWRbaV0sIG51bGwsIGFyZ3VtZW50cyQxLCB2bSwgXCJ2LW9uIGhhbmRsZXJcIik7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIHJldHVybiBoYW5kbGVyIHJldHVybiB2YWx1ZSBmb3Igc2luZ2xlIGhhbmRsZXJzXG4gICAgICByZXR1cm4gaW52b2tlV2l0aEVycm9ySGFuZGxpbmcoZm5zLCBudWxsLCBhcmd1bWVudHMsIHZtLCBcInYtb24gaGFuZGxlclwiKVxuICAgIH1cbiAgfVxuICBpbnZva2VyLmZucyA9IGZucztcbiAgcmV0dXJuIGludm9rZXJcbn1cblxuZnVuY3Rpb24gdXBkYXRlTGlzdGVuZXJzIChcbiAgb24sXG4gIG9sZE9uLFxuICBhZGQsXG4gIHJlbW92ZSQkMSxcbiAgY3JlYXRlT25jZUhhbmRsZXIsXG4gIHZtXG4pIHtcbiAgdmFyIG5hbWUsIGRlZiQkMSwgY3VyLCBvbGQsIGV2ZW50O1xuICBmb3IgKG5hbWUgaW4gb24pIHtcbiAgICBkZWYkJDEgPSBjdXIgPSBvbltuYW1lXTtcbiAgICBvbGQgPSBvbGRPbltuYW1lXTtcbiAgICBldmVudCA9IG5vcm1hbGl6ZUV2ZW50KG5hbWUpO1xuICAgIGlmIChpc1VuZGVmKGN1cikpIHtcbiAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgd2FybihcbiAgICAgICAgXCJJbnZhbGlkIGhhbmRsZXIgZm9yIGV2ZW50IFxcXCJcIiArIChldmVudC5uYW1lKSArIFwiXFxcIjogZ290IFwiICsgU3RyaW5nKGN1ciksXG4gICAgICAgIHZtXG4gICAgICApO1xuICAgIH0gZWxzZSBpZiAoaXNVbmRlZihvbGQpKSB7XG4gICAgICBpZiAoaXNVbmRlZihjdXIuZm5zKSkge1xuICAgICAgICBjdXIgPSBvbltuYW1lXSA9IGNyZWF0ZUZuSW52b2tlcihjdXIsIHZtKTtcbiAgICAgIH1cbiAgICAgIGlmIChpc1RydWUoZXZlbnQub25jZSkpIHtcbiAgICAgICAgY3VyID0gb25bbmFtZV0gPSBjcmVhdGVPbmNlSGFuZGxlcihldmVudC5uYW1lLCBjdXIsIGV2ZW50LmNhcHR1cmUpO1xuICAgICAgfVxuICAgICAgYWRkKGV2ZW50Lm5hbWUsIGN1ciwgZXZlbnQuY2FwdHVyZSwgZXZlbnQucGFzc2l2ZSwgZXZlbnQucGFyYW1zKTtcbiAgICB9IGVsc2UgaWYgKGN1ciAhPT0gb2xkKSB7XG4gICAgICBvbGQuZm5zID0gY3VyO1xuICAgICAgb25bbmFtZV0gPSBvbGQ7XG4gICAgfVxuICB9XG4gIGZvciAobmFtZSBpbiBvbGRPbikge1xuICAgIGlmIChpc1VuZGVmKG9uW25hbWVdKSkge1xuICAgICAgZXZlbnQgPSBub3JtYWxpemVFdmVudChuYW1lKTtcbiAgICAgIHJlbW92ZSQkMShldmVudC5uYW1lLCBvbGRPbltuYW1lXSwgZXZlbnQuY2FwdHVyZSk7XG4gICAgfVxuICB9XG59XG5cbi8qICAqL1xuXG5mdW5jdGlvbiBtZXJnZVZOb2RlSG9vayAoZGVmLCBob29rS2V5LCBob29rKSB7XG4gIGlmIChkZWYgaW5zdGFuY2VvZiBWTm9kZSkge1xuICAgIGRlZiA9IGRlZi5kYXRhLmhvb2sgfHwgKGRlZi5kYXRhLmhvb2sgPSB7fSk7XG4gIH1cbiAgdmFyIGludm9rZXI7XG4gIHZhciBvbGRIb29rID0gZGVmW2hvb2tLZXldO1xuXG4gIGZ1bmN0aW9uIHdyYXBwZWRIb29rICgpIHtcbiAgICBob29rLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgLy8gaW1wb3J0YW50OiByZW1vdmUgbWVyZ2VkIGhvb2sgdG8gZW5zdXJlIGl0J3MgY2FsbGVkIG9ubHkgb25jZVxuICAgIC8vIGFuZCBwcmV2ZW50IG1lbW9yeSBsZWFrXG4gICAgcmVtb3ZlKGludm9rZXIuZm5zLCB3cmFwcGVkSG9vayk7XG4gIH1cblxuICBpZiAoaXNVbmRlZihvbGRIb29rKSkge1xuICAgIC8vIG5vIGV4aXN0aW5nIGhvb2tcbiAgICBpbnZva2VyID0gY3JlYXRlRm5JbnZva2VyKFt3cmFwcGVkSG9va10pO1xuICB9IGVsc2Uge1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgIGlmIChpc0RlZihvbGRIb29rLmZucykgJiYgaXNUcnVlKG9sZEhvb2subWVyZ2VkKSkge1xuICAgICAgLy8gYWxyZWFkeSBhIG1lcmdlZCBpbnZva2VyXG4gICAgICBpbnZva2VyID0gb2xkSG9vaztcbiAgICAgIGludm9rZXIuZm5zLnB1c2god3JhcHBlZEhvb2spO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBleGlzdGluZyBwbGFpbiBob29rXG4gICAgICBpbnZva2VyID0gY3JlYXRlRm5JbnZva2VyKFtvbGRIb29rLCB3cmFwcGVkSG9va10pO1xuICAgIH1cbiAgfVxuXG4gIGludm9rZXIubWVyZ2VkID0gdHJ1ZTtcbiAgZGVmW2hvb2tLZXldID0gaW52b2tlcjtcbn1cblxuLyogICovXG5cbmZ1bmN0aW9uIGV4dHJhY3RQcm9wc0Zyb21WTm9kZURhdGEgKFxuICBkYXRhLFxuICBDdG9yLFxuICB0YWdcbikge1xuICAvLyB3ZSBhcmUgb25seSBleHRyYWN0aW5nIHJhdyB2YWx1ZXMgaGVyZS5cbiAgLy8gdmFsaWRhdGlvbiBhbmQgZGVmYXVsdCB2YWx1ZXMgYXJlIGhhbmRsZWQgaW4gdGhlIGNoaWxkXG4gIC8vIGNvbXBvbmVudCBpdHNlbGYuXG4gIHZhciBwcm9wT3B0aW9ucyA9IEN0b3Iub3B0aW9ucy5wcm9wcztcbiAgaWYgKGlzVW5kZWYocHJvcE9wdGlvbnMpKSB7XG4gICAgcmV0dXJuXG4gIH1cbiAgdmFyIHJlcyA9IHt9O1xuICB2YXIgYXR0cnMgPSBkYXRhLmF0dHJzO1xuICB2YXIgcHJvcHMgPSBkYXRhLnByb3BzO1xuICBpZiAoaXNEZWYoYXR0cnMpIHx8IGlzRGVmKHByb3BzKSkge1xuICAgIGZvciAodmFyIGtleSBpbiBwcm9wT3B0aW9ucykge1xuICAgICAgdmFyIGFsdEtleSA9IGh5cGhlbmF0ZShrZXkpO1xuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgdmFyIGtleUluTG93ZXJDYXNlID0ga2V5LnRvTG93ZXJDYXNlKCk7XG4gICAgICAgIGlmIChcbiAgICAgICAgICBrZXkgIT09IGtleUluTG93ZXJDYXNlICYmXG4gICAgICAgICAgYXR0cnMgJiYgaGFzT3duKGF0dHJzLCBrZXlJbkxvd2VyQ2FzZSlcbiAgICAgICAgKSB7XG4gICAgICAgICAgdGlwKFxuICAgICAgICAgICAgXCJQcm9wIFxcXCJcIiArIGtleUluTG93ZXJDYXNlICsgXCJcXFwiIGlzIHBhc3NlZCB0byBjb21wb25lbnQgXCIgK1xuICAgICAgICAgICAgKGZvcm1hdENvbXBvbmVudE5hbWUodGFnIHx8IEN0b3IpKSArIFwiLCBidXQgdGhlIGRlY2xhcmVkIHByb3AgbmFtZSBpc1wiICtcbiAgICAgICAgICAgIFwiIFxcXCJcIiArIGtleSArIFwiXFxcIi4gXCIgK1xuICAgICAgICAgICAgXCJOb3RlIHRoYXQgSFRNTCBhdHRyaWJ1dGVzIGFyZSBjYXNlLWluc2Vuc2l0aXZlIGFuZCBjYW1lbENhc2VkIFwiICtcbiAgICAgICAgICAgIFwicHJvcHMgbmVlZCB0byB1c2UgdGhlaXIga2ViYWItY2FzZSBlcXVpdmFsZW50cyB3aGVuIHVzaW5nIGluLURPTSBcIiArXG4gICAgICAgICAgICBcInRlbXBsYXRlcy4gWW91IHNob3VsZCBwcm9iYWJseSB1c2UgXFxcIlwiICsgYWx0S2V5ICsgXCJcXFwiIGluc3RlYWQgb2YgXFxcIlwiICsga2V5ICsgXCJcXFwiLlwiXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgY2hlY2tQcm9wKHJlcywgcHJvcHMsIGtleSwgYWx0S2V5LCB0cnVlKSB8fFxuICAgICAgY2hlY2tQcm9wKHJlcywgYXR0cnMsIGtleSwgYWx0S2V5LCBmYWxzZSk7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXNcbn1cblxuZnVuY3Rpb24gY2hlY2tQcm9wIChcbiAgcmVzLFxuICBoYXNoLFxuICBrZXksXG4gIGFsdEtleSxcbiAgcHJlc2VydmVcbikge1xuICBpZiAoaXNEZWYoaGFzaCkpIHtcbiAgICBpZiAoaGFzT3duKGhhc2gsIGtleSkpIHtcbiAgICAgIHJlc1trZXldID0gaGFzaFtrZXldO1xuICAgICAgaWYgKCFwcmVzZXJ2ZSkge1xuICAgICAgICBkZWxldGUgaGFzaFtrZXldO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRydWVcbiAgICB9IGVsc2UgaWYgKGhhc093bihoYXNoLCBhbHRLZXkpKSB7XG4gICAgICByZXNba2V5XSA9IGhhc2hbYWx0S2V5XTtcbiAgICAgIGlmICghcHJlc2VydmUpIHtcbiAgICAgICAgZGVsZXRlIGhhc2hbYWx0S2V5XTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0cnVlXG4gICAgfVxuICB9XG4gIHJldHVybiBmYWxzZVxufVxuXG4vKiAgKi9cblxuLy8gVGhlIHRlbXBsYXRlIGNvbXBpbGVyIGF0dGVtcHRzIHRvIG1pbmltaXplIHRoZSBuZWVkIGZvciBub3JtYWxpemF0aW9uIGJ5XG4vLyBzdGF0aWNhbGx5IGFuYWx5emluZyB0aGUgdGVtcGxhdGUgYXQgY29tcGlsZSB0aW1lLlxuLy9cbi8vIEZvciBwbGFpbiBIVE1MIG1hcmt1cCwgbm9ybWFsaXphdGlvbiBjYW4gYmUgY29tcGxldGVseSBza2lwcGVkIGJlY2F1c2UgdGhlXG4vLyBnZW5lcmF0ZWQgcmVuZGVyIGZ1bmN0aW9uIGlzIGd1YXJhbnRlZWQgdG8gcmV0dXJuIEFycmF5PFZOb2RlPi4gVGhlcmUgYXJlXG4vLyB0d28gY2FzZXMgd2hlcmUgZXh0cmEgbm9ybWFsaXphdGlvbiBpcyBuZWVkZWQ6XG5cbi8vIDEuIFdoZW4gdGhlIGNoaWxkcmVuIGNvbnRhaW5zIGNvbXBvbmVudHMgLSBiZWNhdXNlIGEgZnVuY3Rpb25hbCBjb21wb25lbnRcbi8vIG1heSByZXR1cm4gYW4gQXJyYXkgaW5zdGVhZCBvZiBhIHNpbmdsZSByb290LiBJbiB0aGlzIGNhc2UsIGp1c3QgYSBzaW1wbGVcbi8vIG5vcm1hbGl6YXRpb24gaXMgbmVlZGVkIC0gaWYgYW55IGNoaWxkIGlzIGFuIEFycmF5LCB3ZSBmbGF0dGVuIHRoZSB3aG9sZVxuLy8gdGhpbmcgd2l0aCBBcnJheS5wcm90b3R5cGUuY29uY2F0LiBJdCBpcyBndWFyYW50ZWVkIHRvIGJlIG9ubHkgMS1sZXZlbCBkZWVwXG4vLyBiZWNhdXNlIGZ1bmN0aW9uYWwgY29tcG9uZW50cyBhbHJlYWR5IG5vcm1hbGl6ZSB0aGVpciBvd24gY2hpbGRyZW4uXG5mdW5jdGlvbiBzaW1wbGVOb3JtYWxpemVDaGlsZHJlbiAoY2hpbGRyZW4pIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgIGlmIChBcnJheS5pc0FycmF5KGNoaWxkcmVuW2ldKSkge1xuICAgICAgcmV0dXJuIEFycmF5LnByb3RvdHlwZS5jb25jYXQuYXBwbHkoW10sIGNoaWxkcmVuKVxuICAgIH1cbiAgfVxuICByZXR1cm4gY2hpbGRyZW5cbn1cblxuLy8gMi4gV2hlbiB0aGUgY2hpbGRyZW4gY29udGFpbnMgY29uc3RydWN0cyB0aGF0IGFsd2F5cyBnZW5lcmF0ZWQgbmVzdGVkIEFycmF5cyxcbi8vIGUuZy4gPHRlbXBsYXRlPiwgPHNsb3Q+LCB2LWZvciwgb3Igd2hlbiB0aGUgY2hpbGRyZW4gaXMgcHJvdmlkZWQgYnkgdXNlclxuLy8gd2l0aCBoYW5kLXdyaXR0ZW4gcmVuZGVyIGZ1bmN0aW9ucyAvIEpTWC4gSW4gc3VjaCBjYXNlcyBhIGZ1bGwgbm9ybWFsaXphdGlvblxuLy8gaXMgbmVlZGVkIHRvIGNhdGVyIHRvIGFsbCBwb3NzaWJsZSB0eXBlcyBvZiBjaGlsZHJlbiB2YWx1ZXMuXG5mdW5jdGlvbiBub3JtYWxpemVDaGlsZHJlbiAoY2hpbGRyZW4pIHtcbiAgcmV0dXJuIGlzUHJpbWl0aXZlKGNoaWxkcmVuKVxuICAgID8gW2NyZWF0ZVRleHRWTm9kZShjaGlsZHJlbildXG4gICAgOiBBcnJheS5pc0FycmF5KGNoaWxkcmVuKVxuICAgICAgPyBub3JtYWxpemVBcnJheUNoaWxkcmVuKGNoaWxkcmVuKVxuICAgICAgOiB1bmRlZmluZWRcbn1cblxuZnVuY3Rpb24gaXNUZXh0Tm9kZSAobm9kZSkge1xuICByZXR1cm4gaXNEZWYobm9kZSkgJiYgaXNEZWYobm9kZS50ZXh0KSAmJiBpc0ZhbHNlKG5vZGUuaXNDb21tZW50KVxufVxuXG5mdW5jdGlvbiBub3JtYWxpemVBcnJheUNoaWxkcmVuIChjaGlsZHJlbiwgbmVzdGVkSW5kZXgpIHtcbiAgdmFyIHJlcyA9IFtdO1xuICB2YXIgaSwgYywgbGFzdEluZGV4LCBsYXN0O1xuICBmb3IgKGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICBjID0gY2hpbGRyZW5baV07XG4gICAgaWYgKGlzVW5kZWYoYykgfHwgdHlwZW9mIGMgPT09ICdib29sZWFuJykgeyBjb250aW51ZSB9XG4gICAgbGFzdEluZGV4ID0gcmVzLmxlbmd0aCAtIDE7XG4gICAgbGFzdCA9IHJlc1tsYXN0SW5kZXhdO1xuICAgIC8vICBuZXN0ZWRcbiAgICBpZiAoQXJyYXkuaXNBcnJheShjKSkge1xuICAgICAgaWYgKGMubGVuZ3RoID4gMCkge1xuICAgICAgICBjID0gbm9ybWFsaXplQXJyYXlDaGlsZHJlbihjLCAoKG5lc3RlZEluZGV4IHx8ICcnKSArIFwiX1wiICsgaSkpO1xuICAgICAgICAvLyBtZXJnZSBhZGphY2VudCB0ZXh0IG5vZGVzXG4gICAgICAgIGlmIChpc1RleHROb2RlKGNbMF0pICYmIGlzVGV4dE5vZGUobGFzdCkpIHtcbiAgICAgICAgICByZXNbbGFzdEluZGV4XSA9IGNyZWF0ZVRleHRWTm9kZShsYXN0LnRleHQgKyAoY1swXSkudGV4dCk7XG4gICAgICAgICAgYy5zaGlmdCgpO1xuICAgICAgICB9XG4gICAgICAgIHJlcy5wdXNoLmFwcGx5KHJlcywgYyk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChpc1ByaW1pdGl2ZShjKSkge1xuICAgICAgaWYgKGlzVGV4dE5vZGUobGFzdCkpIHtcbiAgICAgICAgLy8gbWVyZ2UgYWRqYWNlbnQgdGV4dCBub2Rlc1xuICAgICAgICAvLyB0aGlzIGlzIG5lY2Vzc2FyeSBmb3IgU1NSIGh5ZHJhdGlvbiBiZWNhdXNlIHRleHQgbm9kZXMgYXJlXG4gICAgICAgIC8vIGVzc2VudGlhbGx5IG1lcmdlZCB3aGVuIHJlbmRlcmVkIHRvIEhUTUwgc3RyaW5nc1xuICAgICAgICByZXNbbGFzdEluZGV4XSA9IGNyZWF0ZVRleHRWTm9kZShsYXN0LnRleHQgKyBjKTtcbiAgICAgIH0gZWxzZSBpZiAoYyAhPT0gJycpIHtcbiAgICAgICAgLy8gY29udmVydCBwcmltaXRpdmUgdG8gdm5vZGVcbiAgICAgICAgcmVzLnB1c2goY3JlYXRlVGV4dFZOb2RlKGMpKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKGlzVGV4dE5vZGUoYykgJiYgaXNUZXh0Tm9kZShsYXN0KSkge1xuICAgICAgICAvLyBtZXJnZSBhZGphY2VudCB0ZXh0IG5vZGVzXG4gICAgICAgIHJlc1tsYXN0SW5kZXhdID0gY3JlYXRlVGV4dFZOb2RlKGxhc3QudGV4dCArIGMudGV4dCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBkZWZhdWx0IGtleSBmb3IgbmVzdGVkIGFycmF5IGNoaWxkcmVuIChsaWtlbHkgZ2VuZXJhdGVkIGJ5IHYtZm9yKVxuICAgICAgICBpZiAoaXNUcnVlKGNoaWxkcmVuLl9pc1ZMaXN0KSAmJlxuICAgICAgICAgIGlzRGVmKGMudGFnKSAmJlxuICAgICAgICAgIGlzVW5kZWYoYy5rZXkpICYmXG4gICAgICAgICAgaXNEZWYobmVzdGVkSW5kZXgpKSB7XG4gICAgICAgICAgYy5rZXkgPSBcIl9fdmxpc3RcIiArIG5lc3RlZEluZGV4ICsgXCJfXCIgKyBpICsgXCJfX1wiO1xuICAgICAgICB9XG4gICAgICAgIHJlcy5wdXNoKGMpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzXG59XG5cbi8qICAqL1xuXG5mdW5jdGlvbiBpbml0UHJvdmlkZSAodm0pIHtcbiAgdmFyIHByb3ZpZGUgPSB2bS4kb3B0aW9ucy5wcm92aWRlO1xuICBpZiAocHJvdmlkZSkge1xuICAgIHZtLl9wcm92aWRlZCA9IHR5cGVvZiBwcm92aWRlID09PSAnZnVuY3Rpb24nXG4gICAgICA/IHByb3ZpZGUuY2FsbCh2bSlcbiAgICAgIDogcHJvdmlkZTtcbiAgfVxufVxuXG5mdW5jdGlvbiBpbml0SW5qZWN0aW9ucyAodm0pIHtcbiAgdmFyIHJlc3VsdCA9IHJlc29sdmVJbmplY3Qodm0uJG9wdGlvbnMuaW5qZWN0LCB2bSk7XG4gIGlmIChyZXN1bHQpIHtcbiAgICB0b2dnbGVPYnNlcnZpbmcoZmFsc2UpO1xuICAgIE9iamVjdC5rZXlzKHJlc3VsdCkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgZGVmaW5lUmVhY3RpdmUkJDEodm0sIGtleSwgcmVzdWx0W2tleV0sIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICB3YXJuKFxuICAgICAgICAgICAgXCJBdm9pZCBtdXRhdGluZyBhbiBpbmplY3RlZCB2YWx1ZSBkaXJlY3RseSBzaW5jZSB0aGUgY2hhbmdlcyB3aWxsIGJlIFwiICtcbiAgICAgICAgICAgIFwib3ZlcndyaXR0ZW4gd2hlbmV2ZXIgdGhlIHByb3ZpZGVkIGNvbXBvbmVudCByZS1yZW5kZXJzLiBcIiArXG4gICAgICAgICAgICBcImluamVjdGlvbiBiZWluZyBtdXRhdGVkOiBcXFwiXCIgKyBrZXkgKyBcIlxcXCJcIixcbiAgICAgICAgICAgIHZtXG4gICAgICAgICAgKTtcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBkZWZpbmVSZWFjdGl2ZSQkMSh2bSwga2V5LCByZXN1bHRba2V5XSk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgdG9nZ2xlT2JzZXJ2aW5nKHRydWUpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHJlc29sdmVJbmplY3QgKGluamVjdCwgdm0pIHtcbiAgaWYgKGluamVjdCkge1xuICAgIC8vIGluamVjdCBpcyA6YW55IGJlY2F1c2UgZmxvdyBpcyBub3Qgc21hcnQgZW5vdWdoIHRvIGZpZ3VyZSBvdXQgY2FjaGVkXG4gICAgdmFyIHJlc3VsdCA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgdmFyIGtleXMgPSBoYXNTeW1ib2xcbiAgICAgID8gUmVmbGVjdC5vd25LZXlzKGluamVjdClcbiAgICAgIDogT2JqZWN0LmtleXMoaW5qZWN0KTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGtleSA9IGtleXNbaV07XG4gICAgICAvLyAjNjU3NCBpbiBjYXNlIHRoZSBpbmplY3Qgb2JqZWN0IGlzIG9ic2VydmVkLi4uXG4gICAgICBpZiAoa2V5ID09PSAnX19vYl9fJykgeyBjb250aW51ZSB9XG4gICAgICB2YXIgcHJvdmlkZUtleSA9IGluamVjdFtrZXldLmZyb207XG4gICAgICB2YXIgc291cmNlID0gdm07XG4gICAgICB3aGlsZSAoc291cmNlKSB7XG4gICAgICAgIGlmIChzb3VyY2UuX3Byb3ZpZGVkICYmIGhhc093bihzb3VyY2UuX3Byb3ZpZGVkLCBwcm92aWRlS2V5KSkge1xuICAgICAgICAgIHJlc3VsdFtrZXldID0gc291cmNlLl9wcm92aWRlZFtwcm92aWRlS2V5XTtcbiAgICAgICAgICBicmVha1xuICAgICAgICB9XG4gICAgICAgIHNvdXJjZSA9IHNvdXJjZS4kcGFyZW50O1xuICAgICAgfVxuICAgICAgaWYgKCFzb3VyY2UpIHtcbiAgICAgICAgaWYgKCdkZWZhdWx0JyBpbiBpbmplY3Rba2V5XSkge1xuICAgICAgICAgIHZhciBwcm92aWRlRGVmYXVsdCA9IGluamVjdFtrZXldLmRlZmF1bHQ7XG4gICAgICAgICAgcmVzdWx0W2tleV0gPSB0eXBlb2YgcHJvdmlkZURlZmF1bHQgPT09ICdmdW5jdGlvbidcbiAgICAgICAgICAgID8gcHJvdmlkZURlZmF1bHQuY2FsbCh2bSlcbiAgICAgICAgICAgIDogcHJvdmlkZURlZmF1bHQ7XG4gICAgICAgIH0gZWxzZSBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICAgIHdhcm4oKFwiSW5qZWN0aW9uIFxcXCJcIiArIGtleSArIFwiXFxcIiBub3QgZm91bmRcIiksIHZtKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0XG4gIH1cbn1cblxuLyogICovXG5cblxuXG4vKipcbiAqIFJ1bnRpbWUgaGVscGVyIGZvciByZXNvbHZpbmcgcmF3IGNoaWxkcmVuIFZOb2RlcyBpbnRvIGEgc2xvdCBvYmplY3QuXG4gKi9cbmZ1bmN0aW9uIHJlc29sdmVTbG90cyAoXG4gIGNoaWxkcmVuLFxuICBjb250ZXh0XG4pIHtcbiAgaWYgKCFjaGlsZHJlbiB8fCAhY2hpbGRyZW4ubGVuZ3RoKSB7XG4gICAgcmV0dXJuIHt9XG4gIH1cbiAgdmFyIHNsb3RzID0ge307XG4gIGZvciAodmFyIGkgPSAwLCBsID0gY2hpbGRyZW4ubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgdmFyIGNoaWxkID0gY2hpbGRyZW5baV07XG4gICAgdmFyIGRhdGEgPSBjaGlsZC5kYXRhO1xuICAgIC8vIHJlbW92ZSBzbG90IGF0dHJpYnV0ZSBpZiB0aGUgbm9kZSBpcyByZXNvbHZlZCBhcyBhIFZ1ZSBzbG90IG5vZGVcbiAgICBpZiAoZGF0YSAmJiBkYXRhLmF0dHJzICYmIGRhdGEuYXR0cnMuc2xvdCkge1xuICAgICAgZGVsZXRlIGRhdGEuYXR0cnMuc2xvdDtcbiAgICB9XG4gICAgLy8gbmFtZWQgc2xvdHMgc2hvdWxkIG9ubHkgYmUgcmVzcGVjdGVkIGlmIHRoZSB2bm9kZSB3YXMgcmVuZGVyZWQgaW4gdGhlXG4gICAgLy8gc2FtZSBjb250ZXh0LlxuICAgIGlmICgoY2hpbGQuY29udGV4dCA9PT0gY29udGV4dCB8fCBjaGlsZC5mbkNvbnRleHQgPT09IGNvbnRleHQpICYmXG4gICAgICBkYXRhICYmIGRhdGEuc2xvdCAhPSBudWxsXG4gICAgKSB7XG4gICAgICB2YXIgbmFtZSA9IGRhdGEuc2xvdDtcbiAgICAgIHZhciBzbG90ID0gKHNsb3RzW25hbWVdIHx8IChzbG90c1tuYW1lXSA9IFtdKSk7XG4gICAgICBpZiAoY2hpbGQudGFnID09PSAndGVtcGxhdGUnKSB7XG4gICAgICAgIHNsb3QucHVzaC5hcHBseShzbG90LCBjaGlsZC5jaGlsZHJlbiB8fCBbXSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzbG90LnB1c2goY2hpbGQpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAoc2xvdHMuZGVmYXVsdCB8fCAoc2xvdHMuZGVmYXVsdCA9IFtdKSkucHVzaChjaGlsZCk7XG4gICAgfVxuICB9XG4gIC8vIGlnbm9yZSBzbG90cyB0aGF0IGNvbnRhaW5zIG9ubHkgd2hpdGVzcGFjZVxuICBmb3IgKHZhciBuYW1lJDEgaW4gc2xvdHMpIHtcbiAgICBpZiAoc2xvdHNbbmFtZSQxXS5ldmVyeShpc1doaXRlc3BhY2UpKSB7XG4gICAgICBkZWxldGUgc2xvdHNbbmFtZSQxXTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHNsb3RzXG59XG5cbmZ1bmN0aW9uIGlzV2hpdGVzcGFjZSAobm9kZSkge1xuICByZXR1cm4gKG5vZGUuaXNDb21tZW50ICYmICFub2RlLmFzeW5jRmFjdG9yeSkgfHwgbm9kZS50ZXh0ID09PSAnICdcbn1cblxuLyogICovXG5cbmZ1bmN0aW9uIGlzQXN5bmNQbGFjZWhvbGRlciAobm9kZSkge1xuICByZXR1cm4gbm9kZS5pc0NvbW1lbnQgJiYgbm9kZS5hc3luY0ZhY3Rvcnlcbn1cblxuLyogICovXG5cbmZ1bmN0aW9uIG5vcm1hbGl6ZVNjb3BlZFNsb3RzIChcbiAgc2xvdHMsXG4gIG5vcm1hbFNsb3RzLFxuICBwcmV2U2xvdHNcbikge1xuICB2YXIgcmVzO1xuICB2YXIgaGFzTm9ybWFsU2xvdHMgPSBPYmplY3Qua2V5cyhub3JtYWxTbG90cykubGVuZ3RoID4gMDtcbiAgdmFyIGlzU3RhYmxlID0gc2xvdHMgPyAhIXNsb3RzLiRzdGFibGUgOiAhaGFzTm9ybWFsU2xvdHM7XG4gIHZhciBrZXkgPSBzbG90cyAmJiBzbG90cy4ka2V5O1xuICBpZiAoIXNsb3RzKSB7XG4gICAgcmVzID0ge307XG4gIH0gZWxzZSBpZiAoc2xvdHMuX25vcm1hbGl6ZWQpIHtcbiAgICAvLyBmYXN0IHBhdGggMTogY2hpbGQgY29tcG9uZW50IHJlLXJlbmRlciBvbmx5LCBwYXJlbnQgZGlkIG5vdCBjaGFuZ2VcbiAgICByZXR1cm4gc2xvdHMuX25vcm1hbGl6ZWRcbiAgfSBlbHNlIGlmIChcbiAgICBpc1N0YWJsZSAmJlxuICAgIHByZXZTbG90cyAmJlxuICAgIHByZXZTbG90cyAhPT0gZW1wdHlPYmplY3QgJiZcbiAgICBrZXkgPT09IHByZXZTbG90cy4ka2V5ICYmXG4gICAgIWhhc05vcm1hbFNsb3RzICYmXG4gICAgIXByZXZTbG90cy4kaGFzTm9ybWFsXG4gICkge1xuICAgIC8vIGZhc3QgcGF0aCAyOiBzdGFibGUgc2NvcGVkIHNsb3RzIHcvIG5vIG5vcm1hbCBzbG90cyB0byBwcm94eSxcbiAgICAvLyBvbmx5IG5lZWQgdG8gbm9ybWFsaXplIG9uY2VcbiAgICByZXR1cm4gcHJldlNsb3RzXG4gIH0gZWxzZSB7XG4gICAgcmVzID0ge307XG4gICAgZm9yICh2YXIga2V5JDEgaW4gc2xvdHMpIHtcbiAgICAgIGlmIChzbG90c1trZXkkMV0gJiYga2V5JDFbMF0gIT09ICckJykge1xuICAgICAgICByZXNba2V5JDFdID0gbm9ybWFsaXplU2NvcGVkU2xvdChub3JtYWxTbG90cywga2V5JDEsIHNsb3RzW2tleSQxXSk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIC8vIGV4cG9zZSBub3JtYWwgc2xvdHMgb24gc2NvcGVkU2xvdHNcbiAgZm9yICh2YXIga2V5JDIgaW4gbm9ybWFsU2xvdHMpIHtcbiAgICBpZiAoIShrZXkkMiBpbiByZXMpKSB7XG4gICAgICByZXNba2V5JDJdID0gcHJveHlOb3JtYWxTbG90KG5vcm1hbFNsb3RzLCBrZXkkMik7XG4gICAgfVxuICB9XG4gIC8vIGF2b3JpYXogc2VlbXMgdG8gbW9jayBhIG5vbi1leHRlbnNpYmxlICRzY29wZWRTbG90cyBvYmplY3RcbiAgLy8gYW5kIHdoZW4gdGhhdCBpcyBwYXNzZWQgZG93biB0aGlzIHdvdWxkIGNhdXNlIGFuIGVycm9yXG4gIGlmIChzbG90cyAmJiBPYmplY3QuaXNFeHRlbnNpYmxlKHNsb3RzKSkge1xuICAgIChzbG90cykuX25vcm1hbGl6ZWQgPSByZXM7XG4gIH1cbiAgZGVmKHJlcywgJyRzdGFibGUnLCBpc1N0YWJsZSk7XG4gIGRlZihyZXMsICcka2V5Jywga2V5KTtcbiAgZGVmKHJlcywgJyRoYXNOb3JtYWwnLCBoYXNOb3JtYWxTbG90cyk7XG4gIHJldHVybiByZXNcbn1cblxuZnVuY3Rpb24gbm9ybWFsaXplU2NvcGVkU2xvdChub3JtYWxTbG90cywga2V5LCBmbikge1xuICB2YXIgbm9ybWFsaXplZCA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgcmVzID0gYXJndW1lbnRzLmxlbmd0aCA/IGZuLmFwcGx5KG51bGwsIGFyZ3VtZW50cykgOiBmbih7fSk7XG4gICAgcmVzID0gcmVzICYmIHR5cGVvZiByZXMgPT09ICdvYmplY3QnICYmICFBcnJheS5pc0FycmF5KHJlcylcbiAgICAgID8gW3Jlc10gLy8gc2luZ2xlIHZub2RlXG4gICAgICA6IG5vcm1hbGl6ZUNoaWxkcmVuKHJlcyk7XG4gICAgdmFyIHZub2RlID0gcmVzICYmIHJlc1swXTtcbiAgICByZXR1cm4gcmVzICYmIChcbiAgICAgICF2bm9kZSB8fFxuICAgICAgKHJlcy5sZW5ndGggPT09IDEgJiYgdm5vZGUuaXNDb21tZW50ICYmICFpc0FzeW5jUGxhY2Vob2xkZXIodm5vZGUpKSAvLyAjOTY1OCwgIzEwMzkxXG4gICAgKSA/IHVuZGVmaW5lZFxuICAgICAgOiByZXNcbiAgfTtcbiAgLy8gdGhpcyBpcyBhIHNsb3QgdXNpbmcgdGhlIG5ldyB2LXNsb3Qgc3ludGF4IHdpdGhvdXQgc2NvcGUuIGFsdGhvdWdoIGl0IGlzXG4gIC8vIGNvbXBpbGVkIGFzIGEgc2NvcGVkIHNsb3QsIHJlbmRlciBmbiB1c2VycyB3b3VsZCBleHBlY3QgaXQgdG8gYmUgcHJlc2VudFxuICAvLyBvbiB0aGlzLiRzbG90cyBiZWNhdXNlIHRoZSB1c2FnZSBpcyBzZW1hbnRpY2FsbHkgYSBub3JtYWwgc2xvdC5cbiAgaWYgKGZuLnByb3h5KSB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG5vcm1hbFNsb3RzLCBrZXksIHtcbiAgICAgIGdldDogbm9ybWFsaXplZCxcbiAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgfVxuICByZXR1cm4gbm9ybWFsaXplZFxufVxuXG5mdW5jdGlvbiBwcm94eU5vcm1hbFNsb3Qoc2xvdHMsIGtleSkge1xuICByZXR1cm4gZnVuY3Rpb24gKCkgeyByZXR1cm4gc2xvdHNba2V5XTsgfVxufVxuXG4vKiAgKi9cblxuLyoqXG4gKiBSdW50aW1lIGhlbHBlciBmb3IgcmVuZGVyaW5nIHYtZm9yIGxpc3RzLlxuICovXG5mdW5jdGlvbiByZW5kZXJMaXN0IChcbiAgdmFsLFxuICByZW5kZXJcbikge1xuICB2YXIgcmV0LCBpLCBsLCBrZXlzLCBrZXk7XG4gIGlmIChBcnJheS5pc0FycmF5KHZhbCkgfHwgdHlwZW9mIHZhbCA9PT0gJ3N0cmluZycpIHtcbiAgICByZXQgPSBuZXcgQXJyYXkodmFsLmxlbmd0aCk7XG4gICAgZm9yIChpID0gMCwgbCA9IHZhbC5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgIHJldFtpXSA9IHJlbmRlcih2YWxbaV0sIGkpO1xuICAgIH1cbiAgfSBlbHNlIGlmICh0eXBlb2YgdmFsID09PSAnbnVtYmVyJykge1xuICAgIHJldCA9IG5ldyBBcnJheSh2YWwpO1xuICAgIGZvciAoaSA9IDA7IGkgPCB2YWw7IGkrKykge1xuICAgICAgcmV0W2ldID0gcmVuZGVyKGkgKyAxLCBpKTtcbiAgICB9XG4gIH0gZWxzZSBpZiAoaXNPYmplY3QodmFsKSkge1xuICAgIGlmIChoYXNTeW1ib2wgJiYgdmFsW1N5bWJvbC5pdGVyYXRvcl0pIHtcbiAgICAgIHJldCA9IFtdO1xuICAgICAgdmFyIGl0ZXJhdG9yID0gdmFsW1N5bWJvbC5pdGVyYXRvcl0oKTtcbiAgICAgIHZhciByZXN1bHQgPSBpdGVyYXRvci5uZXh0KCk7XG4gICAgICB3aGlsZSAoIXJlc3VsdC5kb25lKSB7XG4gICAgICAgIHJldC5wdXNoKHJlbmRlcihyZXN1bHQudmFsdWUsIHJldC5sZW5ndGgpKTtcbiAgICAgICAgcmVzdWx0ID0gaXRlcmF0b3IubmV4dCgpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBrZXlzID0gT2JqZWN0LmtleXModmFsKTtcbiAgICAgIHJldCA9IG5ldyBBcnJheShrZXlzLmxlbmd0aCk7XG4gICAgICBmb3IgKGkgPSAwLCBsID0ga2V5cy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAga2V5ID0ga2V5c1tpXTtcbiAgICAgICAgcmV0W2ldID0gcmVuZGVyKHZhbFtrZXldLCBrZXksIGkpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBpZiAoIWlzRGVmKHJldCkpIHtcbiAgICByZXQgPSBbXTtcbiAgfVxuICAocmV0KS5faXNWTGlzdCA9IHRydWU7XG4gIHJldHVybiByZXRcbn1cblxuLyogICovXG5cbi8qKlxuICogUnVudGltZSBoZWxwZXIgZm9yIHJlbmRlcmluZyA8c2xvdD5cbiAqL1xuZnVuY3Rpb24gcmVuZGVyU2xvdCAoXG4gIG5hbWUsXG4gIGZhbGxiYWNrUmVuZGVyLFxuICBwcm9wcyxcbiAgYmluZE9iamVjdFxuKSB7XG4gIHZhciBzY29wZWRTbG90Rm4gPSB0aGlzLiRzY29wZWRTbG90c1tuYW1lXTtcbiAgdmFyIG5vZGVzO1xuICBpZiAoc2NvcGVkU2xvdEZuKSB7XG4gICAgLy8gc2NvcGVkIHNsb3RcbiAgICBwcm9wcyA9IHByb3BzIHx8IHt9O1xuICAgIGlmIChiaW5kT2JqZWN0KSB7XG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiAhaXNPYmplY3QoYmluZE9iamVjdCkpIHtcbiAgICAgICAgd2Fybignc2xvdCB2LWJpbmQgd2l0aG91dCBhcmd1bWVudCBleHBlY3RzIGFuIE9iamVjdCcsIHRoaXMpO1xuICAgICAgfVxuICAgICAgcHJvcHMgPSBleHRlbmQoZXh0ZW5kKHt9LCBiaW5kT2JqZWN0KSwgcHJvcHMpO1xuICAgIH1cbiAgICBub2RlcyA9XG4gICAgICBzY29wZWRTbG90Rm4ocHJvcHMpIHx8XG4gICAgICAodHlwZW9mIGZhbGxiYWNrUmVuZGVyID09PSAnZnVuY3Rpb24nID8gZmFsbGJhY2tSZW5kZXIoKSA6IGZhbGxiYWNrUmVuZGVyKTtcbiAgfSBlbHNlIHtcbiAgICBub2RlcyA9XG4gICAgICB0aGlzLiRzbG90c1tuYW1lXSB8fFxuICAgICAgKHR5cGVvZiBmYWxsYmFja1JlbmRlciA9PT0gJ2Z1bmN0aW9uJyA/IGZhbGxiYWNrUmVuZGVyKCkgOiBmYWxsYmFja1JlbmRlcik7XG4gIH1cblxuICB2YXIgdGFyZ2V0ID0gcHJvcHMgJiYgcHJvcHMuc2xvdDtcbiAgaWYgKHRhcmdldCkge1xuICAgIHJldHVybiB0aGlzLiRjcmVhdGVFbGVtZW50KCd0ZW1wbGF0ZScsIHsgc2xvdDogdGFyZ2V0IH0sIG5vZGVzKVxuICB9IGVsc2Uge1xuICAgIHJldHVybiBub2Rlc1xuICB9XG59XG5cbi8qICAqL1xuXG4vKipcbiAqIFJ1bnRpbWUgaGVscGVyIGZvciByZXNvbHZpbmcgZmlsdGVyc1xuICovXG5mdW5jdGlvbiByZXNvbHZlRmlsdGVyIChpZCkge1xuICByZXR1cm4gcmVzb2x2ZUFzc2V0KHRoaXMuJG9wdGlvbnMsICdmaWx0ZXJzJywgaWQsIHRydWUpIHx8IGlkZW50aXR5XG59XG5cbi8qICAqL1xuXG5mdW5jdGlvbiBpc0tleU5vdE1hdGNoIChleHBlY3QsIGFjdHVhbCkge1xuICBpZiAoQXJyYXkuaXNBcnJheShleHBlY3QpKSB7XG4gICAgcmV0dXJuIGV4cGVjdC5pbmRleE9mKGFjdHVhbCkgPT09IC0xXG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGV4cGVjdCAhPT0gYWN0dWFsXG4gIH1cbn1cblxuLyoqXG4gKiBSdW50aW1lIGhlbHBlciBmb3IgY2hlY2tpbmcga2V5Q29kZXMgZnJvbSBjb25maWcuXG4gKiBleHBvc2VkIGFzIFZ1ZS5wcm90b3R5cGUuX2tcbiAqIHBhc3NpbmcgaW4gZXZlbnRLZXlOYW1lIGFzIGxhc3QgYXJndW1lbnQgc2VwYXJhdGVseSBmb3IgYmFja3dhcmRzIGNvbXBhdFxuICovXG5mdW5jdGlvbiBjaGVja0tleUNvZGVzIChcbiAgZXZlbnRLZXlDb2RlLFxuICBrZXksXG4gIGJ1aWx0SW5LZXlDb2RlLFxuICBldmVudEtleU5hbWUsXG4gIGJ1aWx0SW5LZXlOYW1lXG4pIHtcbiAgdmFyIG1hcHBlZEtleUNvZGUgPSBjb25maWcua2V5Q29kZXNba2V5XSB8fCBidWlsdEluS2V5Q29kZTtcbiAgaWYgKGJ1aWx0SW5LZXlOYW1lICYmIGV2ZW50S2V5TmFtZSAmJiAhY29uZmlnLmtleUNvZGVzW2tleV0pIHtcbiAgICByZXR1cm4gaXNLZXlOb3RNYXRjaChidWlsdEluS2V5TmFtZSwgZXZlbnRLZXlOYW1lKVxuICB9IGVsc2UgaWYgKG1hcHBlZEtleUNvZGUpIHtcbiAgICByZXR1cm4gaXNLZXlOb3RNYXRjaChtYXBwZWRLZXlDb2RlLCBldmVudEtleUNvZGUpXG4gIH0gZWxzZSBpZiAoZXZlbnRLZXlOYW1lKSB7XG4gICAgcmV0dXJuIGh5cGhlbmF0ZShldmVudEtleU5hbWUpICE9PSBrZXlcbiAgfVxuICByZXR1cm4gZXZlbnRLZXlDb2RlID09PSB1bmRlZmluZWRcbn1cblxuLyogICovXG5cbi8qKlxuICogUnVudGltZSBoZWxwZXIgZm9yIG1lcmdpbmcgdi1iaW5kPVwib2JqZWN0XCIgaW50byBhIFZOb2RlJ3MgZGF0YS5cbiAqL1xuZnVuY3Rpb24gYmluZE9iamVjdFByb3BzIChcbiAgZGF0YSxcbiAgdGFnLFxuICB2YWx1ZSxcbiAgYXNQcm9wLFxuICBpc1N5bmNcbikge1xuICBpZiAodmFsdWUpIHtcbiAgICBpZiAoIWlzT2JqZWN0KHZhbHVlKSkge1xuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiB3YXJuKFxuICAgICAgICAndi1iaW5kIHdpdGhvdXQgYXJndW1lbnQgZXhwZWN0cyBhbiBPYmplY3Qgb3IgQXJyYXkgdmFsdWUnLFxuICAgICAgICB0aGlzXG4gICAgICApO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgdmFsdWUgPSB0b09iamVjdCh2YWx1ZSk7XG4gICAgICB9XG4gICAgICB2YXIgaGFzaDtcbiAgICAgIHZhciBsb29wID0gZnVuY3Rpb24gKCBrZXkgKSB7XG4gICAgICAgIGlmIChcbiAgICAgICAgICBrZXkgPT09ICdjbGFzcycgfHxcbiAgICAgICAgICBrZXkgPT09ICdzdHlsZScgfHxcbiAgICAgICAgICBpc1Jlc2VydmVkQXR0cmlidXRlKGtleSlcbiAgICAgICAgKSB7XG4gICAgICAgICAgaGFzaCA9IGRhdGE7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFyIHR5cGUgPSBkYXRhLmF0dHJzICYmIGRhdGEuYXR0cnMudHlwZTtcbiAgICAgICAgICBoYXNoID0gYXNQcm9wIHx8IGNvbmZpZy5tdXN0VXNlUHJvcCh0YWcsIHR5cGUsIGtleSlcbiAgICAgICAgICAgID8gZGF0YS5kb21Qcm9wcyB8fCAoZGF0YS5kb21Qcm9wcyA9IHt9KVxuICAgICAgICAgICAgOiBkYXRhLmF0dHJzIHx8IChkYXRhLmF0dHJzID0ge30pO1xuICAgICAgICB9XG4gICAgICAgIHZhciBjYW1lbGl6ZWRLZXkgPSBjYW1lbGl6ZShrZXkpO1xuICAgICAgICB2YXIgaHlwaGVuYXRlZEtleSA9IGh5cGhlbmF0ZShrZXkpO1xuICAgICAgICBpZiAoIShjYW1lbGl6ZWRLZXkgaW4gaGFzaCkgJiYgIShoeXBoZW5hdGVkS2V5IGluIGhhc2gpKSB7XG4gICAgICAgICAgaGFzaFtrZXldID0gdmFsdWVba2V5XTtcblxuICAgICAgICAgIGlmIChpc1N5bmMpIHtcbiAgICAgICAgICAgIHZhciBvbiA9IGRhdGEub24gfHwgKGRhdGEub24gPSB7fSk7XG4gICAgICAgICAgICBvblsoXCJ1cGRhdGU6XCIgKyBrZXkpXSA9IGZ1bmN0aW9uICgkZXZlbnQpIHtcbiAgICAgICAgICAgICAgdmFsdWVba2V5XSA9ICRldmVudDtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICBmb3IgKHZhciBrZXkgaW4gdmFsdWUpIGxvb3AoIGtleSApO1xuICAgIH1cbiAgfVxuICByZXR1cm4gZGF0YVxufVxuXG4vKiAgKi9cblxuLyoqXG4gKiBSdW50aW1lIGhlbHBlciBmb3IgcmVuZGVyaW5nIHN0YXRpYyB0cmVlcy5cbiAqL1xuZnVuY3Rpb24gcmVuZGVyU3RhdGljIChcbiAgaW5kZXgsXG4gIGlzSW5Gb3Jcbikge1xuICB2YXIgY2FjaGVkID0gdGhpcy5fc3RhdGljVHJlZXMgfHwgKHRoaXMuX3N0YXRpY1RyZWVzID0gW10pO1xuICB2YXIgdHJlZSA9IGNhY2hlZFtpbmRleF07XG4gIC8vIGlmIGhhcyBhbHJlYWR5LXJlbmRlcmVkIHN0YXRpYyB0cmVlIGFuZCBub3QgaW5zaWRlIHYtZm9yLFxuICAvLyB3ZSBjYW4gcmV1c2UgdGhlIHNhbWUgdHJlZS5cbiAgaWYgKHRyZWUgJiYgIWlzSW5Gb3IpIHtcbiAgICByZXR1cm4gdHJlZVxuICB9XG4gIC8vIG90aGVyd2lzZSwgcmVuZGVyIGEgZnJlc2ggdHJlZS5cbiAgdHJlZSA9IGNhY2hlZFtpbmRleF0gPSB0aGlzLiRvcHRpb25zLnN0YXRpY1JlbmRlckZuc1tpbmRleF0uY2FsbChcbiAgICB0aGlzLl9yZW5kZXJQcm94eSxcbiAgICBudWxsLFxuICAgIHRoaXMgLy8gZm9yIHJlbmRlciBmbnMgZ2VuZXJhdGVkIGZvciBmdW5jdGlvbmFsIGNvbXBvbmVudCB0ZW1wbGF0ZXNcbiAgKTtcbiAgbWFya1N0YXRpYyh0cmVlLCAoXCJfX3N0YXRpY19fXCIgKyBpbmRleCksIGZhbHNlKTtcbiAgcmV0dXJuIHRyZWVcbn1cblxuLyoqXG4gKiBSdW50aW1lIGhlbHBlciBmb3Igdi1vbmNlLlxuICogRWZmZWN0aXZlbHkgaXQgbWVhbnMgbWFya2luZyB0aGUgbm9kZSBhcyBzdGF0aWMgd2l0aCBhIHVuaXF1ZSBrZXkuXG4gKi9cbmZ1bmN0aW9uIG1hcmtPbmNlIChcbiAgdHJlZSxcbiAgaW5kZXgsXG4gIGtleVxuKSB7XG4gIG1hcmtTdGF0aWModHJlZSwgKFwiX19vbmNlX19cIiArIGluZGV4ICsgKGtleSA/IChcIl9cIiArIGtleSkgOiBcIlwiKSksIHRydWUpO1xuICByZXR1cm4gdHJlZVxufVxuXG5mdW5jdGlvbiBtYXJrU3RhdGljIChcbiAgdHJlZSxcbiAga2V5LFxuICBpc09uY2Vcbikge1xuICBpZiAoQXJyYXkuaXNBcnJheSh0cmVlKSkge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdHJlZS5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKHRyZWVbaV0gJiYgdHlwZW9mIHRyZWVbaV0gIT09ICdzdHJpbmcnKSB7XG4gICAgICAgIG1hcmtTdGF0aWNOb2RlKHRyZWVbaV0sIChrZXkgKyBcIl9cIiArIGkpLCBpc09uY2UpO1xuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBtYXJrU3RhdGljTm9kZSh0cmVlLCBrZXksIGlzT25jZSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gbWFya1N0YXRpY05vZGUgKG5vZGUsIGtleSwgaXNPbmNlKSB7XG4gIG5vZGUuaXNTdGF0aWMgPSB0cnVlO1xuICBub2RlLmtleSA9IGtleTtcbiAgbm9kZS5pc09uY2UgPSBpc09uY2U7XG59XG5cbi8qICAqL1xuXG5mdW5jdGlvbiBiaW5kT2JqZWN0TGlzdGVuZXJzIChkYXRhLCB2YWx1ZSkge1xuICBpZiAodmFsdWUpIHtcbiAgICBpZiAoIWlzUGxhaW5PYmplY3QodmFsdWUpKSB7XG4gICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIHdhcm4oXG4gICAgICAgICd2LW9uIHdpdGhvdXQgYXJndW1lbnQgZXhwZWN0cyBhbiBPYmplY3QgdmFsdWUnLFxuICAgICAgICB0aGlzXG4gICAgICApO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgb24gPSBkYXRhLm9uID0gZGF0YS5vbiA/IGV4dGVuZCh7fSwgZGF0YS5vbikgOiB7fTtcbiAgICAgIGZvciAodmFyIGtleSBpbiB2YWx1ZSkge1xuICAgICAgICB2YXIgZXhpc3RpbmcgPSBvbltrZXldO1xuICAgICAgICB2YXIgb3VycyA9IHZhbHVlW2tleV07XG4gICAgICAgIG9uW2tleV0gPSBleGlzdGluZyA/IFtdLmNvbmNhdChleGlzdGluZywgb3VycykgOiBvdXJzO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gZGF0YVxufVxuXG4vKiAgKi9cblxuZnVuY3Rpb24gcmVzb2x2ZVNjb3BlZFNsb3RzIChcbiAgZm5zLCAvLyBzZWUgZmxvdy92bm9kZVxuICByZXMsXG4gIC8vIHRoZSBmb2xsb3dpbmcgYXJlIGFkZGVkIGluIDIuNlxuICBoYXNEeW5hbWljS2V5cyxcbiAgY29udGVudEhhc2hLZXlcbikge1xuICByZXMgPSByZXMgfHwgeyAkc3RhYmxlOiAhaGFzRHluYW1pY0tleXMgfTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBmbnMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgc2xvdCA9IGZuc1tpXTtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShzbG90KSkge1xuICAgICAgcmVzb2x2ZVNjb3BlZFNsb3RzKHNsb3QsIHJlcywgaGFzRHluYW1pY0tleXMpO1xuICAgIH0gZWxzZSBpZiAoc2xvdCkge1xuICAgICAgLy8gbWFya2VyIGZvciByZXZlcnNlIHByb3h5aW5nIHYtc2xvdCB3aXRob3V0IHNjb3BlIG9uIHRoaXMuJHNsb3RzXG4gICAgICBpZiAoc2xvdC5wcm94eSkge1xuICAgICAgICBzbG90LmZuLnByb3h5ID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIHJlc1tzbG90LmtleV0gPSBzbG90LmZuO1xuICAgIH1cbiAgfVxuICBpZiAoY29udGVudEhhc2hLZXkpIHtcbiAgICAocmVzKS4ka2V5ID0gY29udGVudEhhc2hLZXk7XG4gIH1cbiAgcmV0dXJuIHJlc1xufVxuXG4vKiAgKi9cblxuZnVuY3Rpb24gYmluZER5bmFtaWNLZXlzIChiYXNlT2JqLCB2YWx1ZXMpIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCB2YWx1ZXMubGVuZ3RoOyBpICs9IDIpIHtcbiAgICB2YXIga2V5ID0gdmFsdWVzW2ldO1xuICAgIGlmICh0eXBlb2Yga2V5ID09PSAnc3RyaW5nJyAmJiBrZXkpIHtcbiAgICAgIGJhc2VPYmpbdmFsdWVzW2ldXSA9IHZhbHVlc1tpICsgMV07XG4gICAgfSBlbHNlIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIGtleSAhPT0gJycgJiYga2V5ICE9PSBudWxsKSB7XG4gICAgICAvLyBudWxsIGlzIGEgc3BlY2lhbCB2YWx1ZSBmb3IgZXhwbGljaXRseSByZW1vdmluZyBhIGJpbmRpbmdcbiAgICAgIHdhcm4oXG4gICAgICAgIChcIkludmFsaWQgdmFsdWUgZm9yIGR5bmFtaWMgZGlyZWN0aXZlIGFyZ3VtZW50IChleHBlY3RlZCBzdHJpbmcgb3IgbnVsbCk6IFwiICsga2V5KSxcbiAgICAgICAgdGhpc1xuICAgICAgKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGJhc2VPYmpcbn1cblxuLy8gaGVscGVyIHRvIGR5bmFtaWNhbGx5IGFwcGVuZCBtb2RpZmllciBydW50aW1lIG1hcmtlcnMgdG8gZXZlbnQgbmFtZXMuXG4vLyBlbnN1cmUgb25seSBhcHBlbmQgd2hlbiB2YWx1ZSBpcyBhbHJlYWR5IHN0cmluZywgb3RoZXJ3aXNlIGl0IHdpbGwgYmUgY2FzdFxuLy8gdG8gc3RyaW5nIGFuZCBjYXVzZSB0aGUgdHlwZSBjaGVjayB0byBtaXNzLlxuZnVuY3Rpb24gcHJlcGVuZE1vZGlmaWVyICh2YWx1ZSwgc3ltYm9sKSB7XG4gIHJldHVybiB0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnID8gc3ltYm9sICsgdmFsdWUgOiB2YWx1ZVxufVxuXG4vKiAgKi9cblxuZnVuY3Rpb24gaW5zdGFsbFJlbmRlckhlbHBlcnMgKHRhcmdldCkge1xuICB0YXJnZXQuX28gPSBtYXJrT25jZTtcbiAgdGFyZ2V0Ll9uID0gdG9OdW1iZXI7XG4gIHRhcmdldC5fcyA9IHRvU3RyaW5nO1xuICB0YXJnZXQuX2wgPSByZW5kZXJMaXN0O1xuICB0YXJnZXQuX3QgPSByZW5kZXJTbG90O1xuICB0YXJnZXQuX3EgPSBsb29zZUVxdWFsO1xuICB0YXJnZXQuX2kgPSBsb29zZUluZGV4T2Y7XG4gIHRhcmdldC5fbSA9IHJlbmRlclN0YXRpYztcbiAgdGFyZ2V0Ll9mID0gcmVzb2x2ZUZpbHRlcjtcbiAgdGFyZ2V0Ll9rID0gY2hlY2tLZXlDb2RlcztcbiAgdGFyZ2V0Ll9iID0gYmluZE9iamVjdFByb3BzO1xuICB0YXJnZXQuX3YgPSBjcmVhdGVUZXh0Vk5vZGU7XG4gIHRhcmdldC5fZSA9IGNyZWF0ZUVtcHR5Vk5vZGU7XG4gIHRhcmdldC5fdSA9IHJlc29sdmVTY29wZWRTbG90cztcbiAgdGFyZ2V0Ll9nID0gYmluZE9iamVjdExpc3RlbmVycztcbiAgdGFyZ2V0Ll9kID0gYmluZER5bmFtaWNLZXlzO1xuICB0YXJnZXQuX3AgPSBwcmVwZW5kTW9kaWZpZXI7XG59XG5cbi8qICAqL1xuXG5mdW5jdGlvbiBGdW5jdGlvbmFsUmVuZGVyQ29udGV4dCAoXG4gIGRhdGEsXG4gIHByb3BzLFxuICBjaGlsZHJlbixcbiAgcGFyZW50LFxuICBDdG9yXG4pIHtcbiAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgdmFyIG9wdGlvbnMgPSBDdG9yLm9wdGlvbnM7XG4gIC8vIGVuc3VyZSB0aGUgY3JlYXRlRWxlbWVudCBmdW5jdGlvbiBpbiBmdW5jdGlvbmFsIGNvbXBvbmVudHNcbiAgLy8gZ2V0cyBhIHVuaXF1ZSBjb250ZXh0IC0gdGhpcyBpcyBuZWNlc3NhcnkgZm9yIGNvcnJlY3QgbmFtZWQgc2xvdCBjaGVja1xuICB2YXIgY29udGV4dFZtO1xuICBpZiAoaGFzT3duKHBhcmVudCwgJ191aWQnKSkge1xuICAgIGNvbnRleHRWbSA9IE9iamVjdC5jcmVhdGUocGFyZW50KTtcbiAgICAvLyAkZmxvdy1kaXNhYmxlLWxpbmVcbiAgICBjb250ZXh0Vm0uX29yaWdpbmFsID0gcGFyZW50O1xuICB9IGVsc2Uge1xuICAgIC8vIHRoZSBjb250ZXh0IHZtIHBhc3NlZCBpbiBpcyBhIGZ1bmN0aW9uYWwgY29udGV4dCBhcyB3ZWxsLlxuICAgIC8vIGluIHRoaXMgY2FzZSB3ZSB3YW50IHRvIG1ha2Ugc3VyZSB3ZSBhcmUgYWJsZSB0byBnZXQgYSBob2xkIHRvIHRoZVxuICAgIC8vIHJlYWwgY29udGV4dCBpbnN0YW5jZS5cbiAgICBjb250ZXh0Vm0gPSBwYXJlbnQ7XG4gICAgLy8gJGZsb3ctZGlzYWJsZS1saW5lXG4gICAgcGFyZW50ID0gcGFyZW50Ll9vcmlnaW5hbDtcbiAgfVxuICB2YXIgaXNDb21waWxlZCA9IGlzVHJ1ZShvcHRpb25zLl9jb21waWxlZCk7XG4gIHZhciBuZWVkTm9ybWFsaXphdGlvbiA9ICFpc0NvbXBpbGVkO1xuXG4gIHRoaXMuZGF0YSA9IGRhdGE7XG4gIHRoaXMucHJvcHMgPSBwcm9wcztcbiAgdGhpcy5jaGlsZHJlbiA9IGNoaWxkcmVuO1xuICB0aGlzLnBhcmVudCA9IHBhcmVudDtcbiAgdGhpcy5saXN0ZW5lcnMgPSBkYXRhLm9uIHx8IGVtcHR5T2JqZWN0O1xuICB0aGlzLmluamVjdGlvbnMgPSByZXNvbHZlSW5qZWN0KG9wdGlvbnMuaW5qZWN0LCBwYXJlbnQpO1xuICB0aGlzLnNsb3RzID0gZnVuY3Rpb24gKCkge1xuICAgIGlmICghdGhpcyQxLiRzbG90cykge1xuICAgICAgbm9ybWFsaXplU2NvcGVkU2xvdHMoXG4gICAgICAgIGRhdGEuc2NvcGVkU2xvdHMsXG4gICAgICAgIHRoaXMkMS4kc2xvdHMgPSByZXNvbHZlU2xvdHMoY2hpbGRyZW4sIHBhcmVudClcbiAgICAgICk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzJDEuJHNsb3RzXG4gIH07XG5cbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsICdzY29wZWRTbG90cycsICh7XG4gICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCAoKSB7XG4gICAgICByZXR1cm4gbm9ybWFsaXplU2NvcGVkU2xvdHMoZGF0YS5zY29wZWRTbG90cywgdGhpcy5zbG90cygpKVxuICAgIH1cbiAgfSkpO1xuXG4gIC8vIHN1cHBvcnQgZm9yIGNvbXBpbGVkIGZ1bmN0aW9uYWwgdGVtcGxhdGVcbiAgaWYgKGlzQ29tcGlsZWQpIHtcbiAgICAvLyBleHBvc2luZyAkb3B0aW9ucyBmb3IgcmVuZGVyU3RhdGljKClcbiAgICB0aGlzLiRvcHRpb25zID0gb3B0aW9ucztcbiAgICAvLyBwcmUtcmVzb2x2ZSBzbG90cyBmb3IgcmVuZGVyU2xvdCgpXG4gICAgdGhpcy4kc2xvdHMgPSB0aGlzLnNsb3RzKCk7XG4gICAgdGhpcy4kc2NvcGVkU2xvdHMgPSBub3JtYWxpemVTY29wZWRTbG90cyhkYXRhLnNjb3BlZFNsb3RzLCB0aGlzLiRzbG90cyk7XG4gIH1cblxuICBpZiAob3B0aW9ucy5fc2NvcGVJZCkge1xuICAgIHRoaXMuX2MgPSBmdW5jdGlvbiAoYSwgYiwgYywgZCkge1xuICAgICAgdmFyIHZub2RlID0gY3JlYXRlRWxlbWVudChjb250ZXh0Vm0sIGEsIGIsIGMsIGQsIG5lZWROb3JtYWxpemF0aW9uKTtcbiAgICAgIGlmICh2bm9kZSAmJiAhQXJyYXkuaXNBcnJheSh2bm9kZSkpIHtcbiAgICAgICAgdm5vZGUuZm5TY29wZUlkID0gb3B0aW9ucy5fc2NvcGVJZDtcbiAgICAgICAgdm5vZGUuZm5Db250ZXh0ID0gcGFyZW50O1xuICAgICAgfVxuICAgICAgcmV0dXJuIHZub2RlXG4gICAgfTtcbiAgfSBlbHNlIHtcbiAgICB0aGlzLl9jID0gZnVuY3Rpb24gKGEsIGIsIGMsIGQpIHsgcmV0dXJuIGNyZWF0ZUVsZW1lbnQoY29udGV4dFZtLCBhLCBiLCBjLCBkLCBuZWVkTm9ybWFsaXphdGlvbik7IH07XG4gIH1cbn1cblxuaW5zdGFsbFJlbmRlckhlbHBlcnMoRnVuY3Rpb25hbFJlbmRlckNvbnRleHQucHJvdG90eXBlKTtcblxuZnVuY3Rpb24gY3JlYXRlRnVuY3Rpb25hbENvbXBvbmVudCAoXG4gIEN0b3IsXG4gIHByb3BzRGF0YSxcbiAgZGF0YSxcbiAgY29udGV4dFZtLFxuICBjaGlsZHJlblxuKSB7XG4gIHZhciBvcHRpb25zID0gQ3Rvci5vcHRpb25zO1xuICB2YXIgcHJvcHMgPSB7fTtcbiAgdmFyIHByb3BPcHRpb25zID0gb3B0aW9ucy5wcm9wcztcbiAgaWYgKGlzRGVmKHByb3BPcHRpb25zKSkge1xuICAgIGZvciAodmFyIGtleSBpbiBwcm9wT3B0aW9ucykge1xuICAgICAgcHJvcHNba2V5XSA9IHZhbGlkYXRlUHJvcChrZXksIHByb3BPcHRpb25zLCBwcm9wc0RhdGEgfHwgZW1wdHlPYmplY3QpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBpZiAoaXNEZWYoZGF0YS5hdHRycykpIHsgbWVyZ2VQcm9wcyhwcm9wcywgZGF0YS5hdHRycyk7IH1cbiAgICBpZiAoaXNEZWYoZGF0YS5wcm9wcykpIHsgbWVyZ2VQcm9wcyhwcm9wcywgZGF0YS5wcm9wcyk7IH1cbiAgfVxuXG4gIHZhciByZW5kZXJDb250ZXh0ID0gbmV3IEZ1bmN0aW9uYWxSZW5kZXJDb250ZXh0KFxuICAgIGRhdGEsXG4gICAgcHJvcHMsXG4gICAgY2hpbGRyZW4sXG4gICAgY29udGV4dFZtLFxuICAgIEN0b3JcbiAgKTtcblxuICB2YXIgdm5vZGUgPSBvcHRpb25zLnJlbmRlci5jYWxsKG51bGwsIHJlbmRlckNvbnRleHQuX2MsIHJlbmRlckNvbnRleHQpO1xuXG4gIGlmICh2bm9kZSBpbnN0YW5jZW9mIFZOb2RlKSB7XG4gICAgcmV0dXJuIGNsb25lQW5kTWFya0Z1bmN0aW9uYWxSZXN1bHQodm5vZGUsIGRhdGEsIHJlbmRlckNvbnRleHQucGFyZW50LCBvcHRpb25zLCByZW5kZXJDb250ZXh0KVxuICB9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkodm5vZGUpKSB7XG4gICAgdmFyIHZub2RlcyA9IG5vcm1hbGl6ZUNoaWxkcmVuKHZub2RlKSB8fCBbXTtcbiAgICB2YXIgcmVzID0gbmV3IEFycmF5KHZub2Rlcy5sZW5ndGgpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdm5vZGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICByZXNbaV0gPSBjbG9uZUFuZE1hcmtGdW5jdGlvbmFsUmVzdWx0KHZub2Rlc1tpXSwgZGF0YSwgcmVuZGVyQ29udGV4dC5wYXJlbnQsIG9wdGlvbnMsIHJlbmRlckNvbnRleHQpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzXG4gIH1cbn1cblxuZnVuY3Rpb24gY2xvbmVBbmRNYXJrRnVuY3Rpb25hbFJlc3VsdCAodm5vZGUsIGRhdGEsIGNvbnRleHRWbSwgb3B0aW9ucywgcmVuZGVyQ29udGV4dCkge1xuICAvLyAjNzgxNyBjbG9uZSBub2RlIGJlZm9yZSBzZXR0aW5nIGZuQ29udGV4dCwgb3RoZXJ3aXNlIGlmIHRoZSBub2RlIGlzIHJldXNlZFxuICAvLyAoZS5nLiBpdCB3YXMgZnJvbSBhIGNhY2hlZCBub3JtYWwgc2xvdCkgdGhlIGZuQ29udGV4dCBjYXVzZXMgbmFtZWQgc2xvdHNcbiAgLy8gdGhhdCBzaG91bGQgbm90IGJlIG1hdGNoZWQgdG8gbWF0Y2guXG4gIHZhciBjbG9uZSA9IGNsb25lVk5vZGUodm5vZGUpO1xuICBjbG9uZS5mbkNvbnRleHQgPSBjb250ZXh0Vm07XG4gIGNsb25lLmZuT3B0aW9ucyA9IG9wdGlvbnM7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgKGNsb25lLmRldnRvb2xzTWV0YSA9IGNsb25lLmRldnRvb2xzTWV0YSB8fCB7fSkucmVuZGVyQ29udGV4dCA9IHJlbmRlckNvbnRleHQ7XG4gIH1cbiAgaWYgKGRhdGEuc2xvdCkge1xuICAgIChjbG9uZS5kYXRhIHx8IChjbG9uZS5kYXRhID0ge30pKS5zbG90ID0gZGF0YS5zbG90O1xuICB9XG4gIHJldHVybiBjbG9uZVxufVxuXG5mdW5jdGlvbiBtZXJnZVByb3BzICh0bywgZnJvbSkge1xuICBmb3IgKHZhciBrZXkgaW4gZnJvbSkge1xuICAgIHRvW2NhbWVsaXplKGtleSldID0gZnJvbVtrZXldO1xuICB9XG59XG5cbi8qICAqL1xuXG4vKiAgKi9cblxuLyogICovXG5cbi8qICAqL1xuXG4vLyBpbmxpbmUgaG9va3MgdG8gYmUgaW52b2tlZCBvbiBjb21wb25lbnQgVk5vZGVzIGR1cmluZyBwYXRjaFxudmFyIGNvbXBvbmVudFZOb2RlSG9va3MgPSB7XG4gIGluaXQ6IGZ1bmN0aW9uIGluaXQgKHZub2RlLCBoeWRyYXRpbmcpIHtcbiAgICBpZiAoXG4gICAgICB2bm9kZS5jb21wb25lbnRJbnN0YW5jZSAmJlxuICAgICAgIXZub2RlLmNvbXBvbmVudEluc3RhbmNlLl9pc0Rlc3Ryb3llZCAmJlxuICAgICAgdm5vZGUuZGF0YS5rZWVwQWxpdmVcbiAgICApIHtcbiAgICAgIC8vIGtlcHQtYWxpdmUgY29tcG9uZW50cywgdHJlYXQgYXMgYSBwYXRjaFxuICAgICAgdmFyIG1vdW50ZWROb2RlID0gdm5vZGU7IC8vIHdvcmsgYXJvdW5kIGZsb3dcbiAgICAgIGNvbXBvbmVudFZOb2RlSG9va3MucHJlcGF0Y2gobW91bnRlZE5vZGUsIG1vdW50ZWROb2RlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIGNoaWxkID0gdm5vZGUuY29tcG9uZW50SW5zdGFuY2UgPSBjcmVhdGVDb21wb25lbnRJbnN0YW5jZUZvclZub2RlKFxuICAgICAgICB2bm9kZSxcbiAgICAgICAgYWN0aXZlSW5zdGFuY2VcbiAgICAgICk7XG4gICAgICBjaGlsZC4kbW91bnQoaHlkcmF0aW5nID8gdm5vZGUuZWxtIDogdW5kZWZpbmVkLCBoeWRyYXRpbmcpO1xuICAgIH1cbiAgfSxcblxuICBwcmVwYXRjaDogZnVuY3Rpb24gcHJlcGF0Y2ggKG9sZFZub2RlLCB2bm9kZSkge1xuICAgIHZhciBvcHRpb25zID0gdm5vZGUuY29tcG9uZW50T3B0aW9ucztcbiAgICB2YXIgY2hpbGQgPSB2bm9kZS5jb21wb25lbnRJbnN0YW5jZSA9IG9sZFZub2RlLmNvbXBvbmVudEluc3RhbmNlO1xuICAgIHVwZGF0ZUNoaWxkQ29tcG9uZW50KFxuICAgICAgY2hpbGQsXG4gICAgICBvcHRpb25zLnByb3BzRGF0YSwgLy8gdXBkYXRlZCBwcm9wc1xuICAgICAgb3B0aW9ucy5saXN0ZW5lcnMsIC8vIHVwZGF0ZWQgbGlzdGVuZXJzXG4gICAgICB2bm9kZSwgLy8gbmV3IHBhcmVudCB2bm9kZVxuICAgICAgb3B0aW9ucy5jaGlsZHJlbiAvLyBuZXcgY2hpbGRyZW5cbiAgICApO1xuICB9LFxuXG4gIGluc2VydDogZnVuY3Rpb24gaW5zZXJ0ICh2bm9kZSkge1xuICAgIHZhciBjb250ZXh0ID0gdm5vZGUuY29udGV4dDtcbiAgICB2YXIgY29tcG9uZW50SW5zdGFuY2UgPSB2bm9kZS5jb21wb25lbnRJbnN0YW5jZTtcbiAgICBpZiAoIWNvbXBvbmVudEluc3RhbmNlLl9pc01vdW50ZWQpIHtcbiAgICAgIGNvbXBvbmVudEluc3RhbmNlLl9pc01vdW50ZWQgPSB0cnVlO1xuICAgICAgY2FsbEhvb2soY29tcG9uZW50SW5zdGFuY2UsICdtb3VudGVkJyk7XG4gICAgfVxuICAgIGlmICh2bm9kZS5kYXRhLmtlZXBBbGl2ZSkge1xuICAgICAgaWYgKGNvbnRleHQuX2lzTW91bnRlZCkge1xuICAgICAgICAvLyB2dWUtcm91dGVyIzEyMTJcbiAgICAgICAgLy8gRHVyaW5nIHVwZGF0ZXMsIGEga2VwdC1hbGl2ZSBjb21wb25lbnQncyBjaGlsZCBjb21wb25lbnRzIG1heVxuICAgICAgICAvLyBjaGFuZ2UsIHNvIGRpcmVjdGx5IHdhbGtpbmcgdGhlIHRyZWUgaGVyZSBtYXkgY2FsbCBhY3RpdmF0ZWQgaG9va3NcbiAgICAgICAgLy8gb24gaW5jb3JyZWN0IGNoaWxkcmVuLiBJbnN0ZWFkIHdlIHB1c2ggdGhlbSBpbnRvIGEgcXVldWUgd2hpY2ggd2lsbFxuICAgICAgICAvLyBiZSBwcm9jZXNzZWQgYWZ0ZXIgdGhlIHdob2xlIHBhdGNoIHByb2Nlc3MgZW5kZWQuXG4gICAgICAgIHF1ZXVlQWN0aXZhdGVkQ29tcG9uZW50KGNvbXBvbmVudEluc3RhbmNlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGFjdGl2YXRlQ2hpbGRDb21wb25lbnQoY29tcG9uZW50SW5zdGFuY2UsIHRydWUgLyogZGlyZWN0ICovKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sXG5cbiAgZGVzdHJveTogZnVuY3Rpb24gZGVzdHJveSAodm5vZGUpIHtcbiAgICB2YXIgY29tcG9uZW50SW5zdGFuY2UgPSB2bm9kZS5jb21wb25lbnRJbnN0YW5jZTtcbiAgICBpZiAoIWNvbXBvbmVudEluc3RhbmNlLl9pc0Rlc3Ryb3llZCkge1xuICAgICAgaWYgKCF2bm9kZS5kYXRhLmtlZXBBbGl2ZSkge1xuICAgICAgICBjb21wb25lbnRJbnN0YW5jZS4kZGVzdHJveSgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZGVhY3RpdmF0ZUNoaWxkQ29tcG9uZW50KGNvbXBvbmVudEluc3RhbmNlLCB0cnVlIC8qIGRpcmVjdCAqLyk7XG4gICAgICB9XG4gICAgfVxuICB9XG59O1xuXG52YXIgaG9va3NUb01lcmdlID0gT2JqZWN0LmtleXMoY29tcG9uZW50Vk5vZGVIb29rcyk7XG5cbmZ1bmN0aW9uIGNyZWF0ZUNvbXBvbmVudCAoXG4gIEN0b3IsXG4gIGRhdGEsXG4gIGNvbnRleHQsXG4gIGNoaWxkcmVuLFxuICB0YWdcbikge1xuICBpZiAoaXNVbmRlZihDdG9yKSkge1xuICAgIHJldHVyblxuICB9XG5cbiAgdmFyIGJhc2VDdG9yID0gY29udGV4dC4kb3B0aW9ucy5fYmFzZTtcblxuICAvLyBwbGFpbiBvcHRpb25zIG9iamVjdDogdHVybiBpdCBpbnRvIGEgY29uc3RydWN0b3JcbiAgaWYgKGlzT2JqZWN0KEN0b3IpKSB7XG4gICAgQ3RvciA9IGJhc2VDdG9yLmV4dGVuZChDdG9yKTtcbiAgfVxuXG4gIC8vIGlmIGF0IHRoaXMgc3RhZ2UgaXQncyBub3QgYSBjb25zdHJ1Y3RvciBvciBhbiBhc3luYyBjb21wb25lbnQgZmFjdG9yeSxcbiAgLy8gcmVqZWN0LlxuICBpZiAodHlwZW9mIEN0b3IgIT09ICdmdW5jdGlvbicpIHtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgd2FybigoXCJJbnZhbGlkIENvbXBvbmVudCBkZWZpbml0aW9uOiBcIiArIChTdHJpbmcoQ3RvcikpKSwgY29udGV4dCk7XG4gICAgfVxuICAgIHJldHVyblxuICB9XG5cbiAgLy8gYXN5bmMgY29tcG9uZW50XG4gIHZhciBhc3luY0ZhY3Rvcnk7XG4gIGlmIChpc1VuZGVmKEN0b3IuY2lkKSkge1xuICAgIGFzeW5jRmFjdG9yeSA9IEN0b3I7XG4gICAgQ3RvciA9IHJlc29sdmVBc3luY0NvbXBvbmVudChhc3luY0ZhY3RvcnksIGJhc2VDdG9yKTtcbiAgICBpZiAoQ3RvciA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAvLyByZXR1cm4gYSBwbGFjZWhvbGRlciBub2RlIGZvciBhc3luYyBjb21wb25lbnQsIHdoaWNoIGlzIHJlbmRlcmVkXG4gICAgICAvLyBhcyBhIGNvbW1lbnQgbm9kZSBidXQgcHJlc2VydmVzIGFsbCB0aGUgcmF3IGluZm9ybWF0aW9uIGZvciB0aGUgbm9kZS5cbiAgICAgIC8vIHRoZSBpbmZvcm1hdGlvbiB3aWxsIGJlIHVzZWQgZm9yIGFzeW5jIHNlcnZlci1yZW5kZXJpbmcgYW5kIGh5ZHJhdGlvbi5cbiAgICAgIHJldHVybiBjcmVhdGVBc3luY1BsYWNlaG9sZGVyKFxuICAgICAgICBhc3luY0ZhY3RvcnksXG4gICAgICAgIGRhdGEsXG4gICAgICAgIGNvbnRleHQsXG4gICAgICAgIGNoaWxkcmVuLFxuICAgICAgICB0YWdcbiAgICAgIClcbiAgICB9XG4gIH1cblxuICBkYXRhID0gZGF0YSB8fCB7fTtcblxuICAvLyByZXNvbHZlIGNvbnN0cnVjdG9yIG9wdGlvbnMgaW4gY2FzZSBnbG9iYWwgbWl4aW5zIGFyZSBhcHBsaWVkIGFmdGVyXG4gIC8vIGNvbXBvbmVudCBjb25zdHJ1Y3RvciBjcmVhdGlvblxuICByZXNvbHZlQ29uc3RydWN0b3JPcHRpb25zKEN0b3IpO1xuXG4gIC8vIHRyYW5zZm9ybSBjb21wb25lbnQgdi1tb2RlbCBkYXRhIGludG8gcHJvcHMgJiBldmVudHNcbiAgaWYgKGlzRGVmKGRhdGEubW9kZWwpKSB7XG4gICAgdHJhbnNmb3JtTW9kZWwoQ3Rvci5vcHRpb25zLCBkYXRhKTtcbiAgfVxuXG4gIC8vIGV4dHJhY3QgcHJvcHNcbiAgdmFyIHByb3BzRGF0YSA9IGV4dHJhY3RQcm9wc0Zyb21WTm9kZURhdGEoZGF0YSwgQ3RvciwgdGFnKTtcblxuICAvLyBmdW5jdGlvbmFsIGNvbXBvbmVudFxuICBpZiAoaXNUcnVlKEN0b3Iub3B0aW9ucy5mdW5jdGlvbmFsKSkge1xuICAgIHJldHVybiBjcmVhdGVGdW5jdGlvbmFsQ29tcG9uZW50KEN0b3IsIHByb3BzRGF0YSwgZGF0YSwgY29udGV4dCwgY2hpbGRyZW4pXG4gIH1cblxuICAvLyBleHRyYWN0IGxpc3RlbmVycywgc2luY2UgdGhlc2UgbmVlZHMgdG8gYmUgdHJlYXRlZCBhc1xuICAvLyBjaGlsZCBjb21wb25lbnQgbGlzdGVuZXJzIGluc3RlYWQgb2YgRE9NIGxpc3RlbmVyc1xuICB2YXIgbGlzdGVuZXJzID0gZGF0YS5vbjtcbiAgLy8gcmVwbGFjZSB3aXRoIGxpc3RlbmVycyB3aXRoIC5uYXRpdmUgbW9kaWZpZXJcbiAgLy8gc28gaXQgZ2V0cyBwcm9jZXNzZWQgZHVyaW5nIHBhcmVudCBjb21wb25lbnQgcGF0Y2guXG4gIGRhdGEub24gPSBkYXRhLm5hdGl2ZU9uO1xuXG4gIGlmIChpc1RydWUoQ3Rvci5vcHRpb25zLmFic3RyYWN0KSkge1xuICAgIC8vIGFic3RyYWN0IGNvbXBvbmVudHMgZG8gbm90IGtlZXAgYW55dGhpbmdcbiAgICAvLyBvdGhlciB0aGFuIHByb3BzICYgbGlzdGVuZXJzICYgc2xvdFxuXG4gICAgLy8gd29yayBhcm91bmQgZmxvd1xuICAgIHZhciBzbG90ID0gZGF0YS5zbG90O1xuICAgIGRhdGEgPSB7fTtcbiAgICBpZiAoc2xvdCkge1xuICAgICAgZGF0YS5zbG90ID0gc2xvdDtcbiAgICB9XG4gIH1cblxuICAvLyBpbnN0YWxsIGNvbXBvbmVudCBtYW5hZ2VtZW50IGhvb2tzIG9udG8gdGhlIHBsYWNlaG9sZGVyIG5vZGVcbiAgaW5zdGFsbENvbXBvbmVudEhvb2tzKGRhdGEpO1xuXG4gIC8vIHJldHVybiBhIHBsYWNlaG9sZGVyIHZub2RlXG4gIHZhciBuYW1lID0gQ3Rvci5vcHRpb25zLm5hbWUgfHwgdGFnO1xuICB2YXIgdm5vZGUgPSBuZXcgVk5vZGUoXG4gICAgKFwidnVlLWNvbXBvbmVudC1cIiArIChDdG9yLmNpZCkgKyAobmFtZSA/IChcIi1cIiArIG5hbWUpIDogJycpKSxcbiAgICBkYXRhLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCBjb250ZXh0LFxuICAgIHsgQ3RvcjogQ3RvciwgcHJvcHNEYXRhOiBwcm9wc0RhdGEsIGxpc3RlbmVyczogbGlzdGVuZXJzLCB0YWc6IHRhZywgY2hpbGRyZW46IGNoaWxkcmVuIH0sXG4gICAgYXN5bmNGYWN0b3J5XG4gICk7XG5cbiAgcmV0dXJuIHZub2RlXG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUNvbXBvbmVudEluc3RhbmNlRm9yVm5vZGUgKFxuICAvLyB3ZSBrbm93IGl0J3MgTW91bnRlZENvbXBvbmVudFZOb2RlIGJ1dCBmbG93IGRvZXNuJ3RcbiAgdm5vZGUsXG4gIC8vIGFjdGl2ZUluc3RhbmNlIGluIGxpZmVjeWNsZSBzdGF0ZVxuICBwYXJlbnRcbikge1xuICB2YXIgb3B0aW9ucyA9IHtcbiAgICBfaXNDb21wb25lbnQ6IHRydWUsXG4gICAgX3BhcmVudFZub2RlOiB2bm9kZSxcbiAgICBwYXJlbnQ6IHBhcmVudFxuICB9O1xuICAvLyBjaGVjayBpbmxpbmUtdGVtcGxhdGUgcmVuZGVyIGZ1bmN0aW9uc1xuICB2YXIgaW5saW5lVGVtcGxhdGUgPSB2bm9kZS5kYXRhLmlubGluZVRlbXBsYXRlO1xuICBpZiAoaXNEZWYoaW5saW5lVGVtcGxhdGUpKSB7XG4gICAgb3B0aW9ucy5yZW5kZXIgPSBpbmxpbmVUZW1wbGF0ZS5yZW5kZXI7XG4gICAgb3B0aW9ucy5zdGF0aWNSZW5kZXJGbnMgPSBpbmxpbmVUZW1wbGF0ZS5zdGF0aWNSZW5kZXJGbnM7XG4gIH1cbiAgcmV0dXJuIG5ldyB2bm9kZS5jb21wb25lbnRPcHRpb25zLkN0b3Iob3B0aW9ucylcbn1cblxuZnVuY3Rpb24gaW5zdGFsbENvbXBvbmVudEhvb2tzIChkYXRhKSB7XG4gIHZhciBob29rcyA9IGRhdGEuaG9vayB8fCAoZGF0YS5ob29rID0ge30pO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGhvb2tzVG9NZXJnZS5sZW5ndGg7IGkrKykge1xuICAgIHZhciBrZXkgPSBob29rc1RvTWVyZ2VbaV07XG4gICAgdmFyIGV4aXN0aW5nID0gaG9va3Nba2V5XTtcbiAgICB2YXIgdG9NZXJnZSA9IGNvbXBvbmVudFZOb2RlSG9va3Nba2V5XTtcbiAgICBpZiAoZXhpc3RpbmcgIT09IHRvTWVyZ2UgJiYgIShleGlzdGluZyAmJiBleGlzdGluZy5fbWVyZ2VkKSkge1xuICAgICAgaG9va3Nba2V5XSA9IGV4aXN0aW5nID8gbWVyZ2VIb29rJDEodG9NZXJnZSwgZXhpc3RpbmcpIDogdG9NZXJnZTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gbWVyZ2VIb29rJDEgKGYxLCBmMikge1xuICB2YXIgbWVyZ2VkID0gZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAvLyBmbG93IGNvbXBsYWlucyBhYm91dCBleHRyYSBhcmdzIHdoaWNoIGlzIHdoeSB3ZSB1c2UgYW55XG4gICAgZjEoYSwgYik7XG4gICAgZjIoYSwgYik7XG4gIH07XG4gIG1lcmdlZC5fbWVyZ2VkID0gdHJ1ZTtcbiAgcmV0dXJuIG1lcmdlZFxufVxuXG4vLyB0cmFuc2Zvcm0gY29tcG9uZW50IHYtbW9kZWwgaW5mbyAodmFsdWUgYW5kIGNhbGxiYWNrKSBpbnRvXG4vLyBwcm9wIGFuZCBldmVudCBoYW5kbGVyIHJlc3BlY3RpdmVseS5cbmZ1bmN0aW9uIHRyYW5zZm9ybU1vZGVsIChvcHRpb25zLCBkYXRhKSB7XG4gIHZhciBwcm9wID0gKG9wdGlvbnMubW9kZWwgJiYgb3B0aW9ucy5tb2RlbC5wcm9wKSB8fCAndmFsdWUnO1xuICB2YXIgZXZlbnQgPSAob3B0aW9ucy5tb2RlbCAmJiBvcHRpb25zLm1vZGVsLmV2ZW50KSB8fCAnaW5wdXQnXG4gIDsoZGF0YS5hdHRycyB8fCAoZGF0YS5hdHRycyA9IHt9KSlbcHJvcF0gPSBkYXRhLm1vZGVsLnZhbHVlO1xuICB2YXIgb24gPSBkYXRhLm9uIHx8IChkYXRhLm9uID0ge30pO1xuICB2YXIgZXhpc3RpbmcgPSBvbltldmVudF07XG4gIHZhciBjYWxsYmFjayA9IGRhdGEubW9kZWwuY2FsbGJhY2s7XG4gIGlmIChpc0RlZihleGlzdGluZykpIHtcbiAgICBpZiAoXG4gICAgICBBcnJheS5pc0FycmF5KGV4aXN0aW5nKVxuICAgICAgICA/IGV4aXN0aW5nLmluZGV4T2YoY2FsbGJhY2spID09PSAtMVxuICAgICAgICA6IGV4aXN0aW5nICE9PSBjYWxsYmFja1xuICAgICkge1xuICAgICAgb25bZXZlbnRdID0gW2NhbGxiYWNrXS5jb25jYXQoZXhpc3RpbmcpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBvbltldmVudF0gPSBjYWxsYmFjaztcbiAgfVxufVxuXG4vKiAgKi9cblxudmFyIFNJTVBMRV9OT1JNQUxJWkUgPSAxO1xudmFyIEFMV0FZU19OT1JNQUxJWkUgPSAyO1xuXG4vLyB3cmFwcGVyIGZ1bmN0aW9uIGZvciBwcm92aWRpbmcgYSBtb3JlIGZsZXhpYmxlIGludGVyZmFjZVxuLy8gd2l0aG91dCBnZXR0aW5nIHllbGxlZCBhdCBieSBmbG93XG5mdW5jdGlvbiBjcmVhdGVFbGVtZW50IChcbiAgY29udGV4dCxcbiAgdGFnLFxuICBkYXRhLFxuICBjaGlsZHJlbixcbiAgbm9ybWFsaXphdGlvblR5cGUsXG4gIGFsd2F5c05vcm1hbGl6ZVxuKSB7XG4gIGlmIChBcnJheS5pc0FycmF5KGRhdGEpIHx8IGlzUHJpbWl0aXZlKGRhdGEpKSB7XG4gICAgbm9ybWFsaXphdGlvblR5cGUgPSBjaGlsZHJlbjtcbiAgICBjaGlsZHJlbiA9IGRhdGE7XG4gICAgZGF0YSA9IHVuZGVmaW5lZDtcbiAgfVxuICBpZiAoaXNUcnVlKGFsd2F5c05vcm1hbGl6ZSkpIHtcbiAgICBub3JtYWxpemF0aW9uVHlwZSA9IEFMV0FZU19OT1JNQUxJWkU7XG4gIH1cbiAgcmV0dXJuIF9jcmVhdGVFbGVtZW50KGNvbnRleHQsIHRhZywgZGF0YSwgY2hpbGRyZW4sIG5vcm1hbGl6YXRpb25UeXBlKVxufVxuXG5mdW5jdGlvbiBfY3JlYXRlRWxlbWVudCAoXG4gIGNvbnRleHQsXG4gIHRhZyxcbiAgZGF0YSxcbiAgY2hpbGRyZW4sXG4gIG5vcm1hbGl6YXRpb25UeXBlXG4pIHtcbiAgaWYgKGlzRGVmKGRhdGEpICYmIGlzRGVmKChkYXRhKS5fX29iX18pKSB7XG4gICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiB3YXJuKFxuICAgICAgXCJBdm9pZCB1c2luZyBvYnNlcnZlZCBkYXRhIG9iamVjdCBhcyB2bm9kZSBkYXRhOiBcIiArIChKU09OLnN0cmluZ2lmeShkYXRhKSkgKyBcIlxcblwiICtcbiAgICAgICdBbHdheXMgY3JlYXRlIGZyZXNoIHZub2RlIGRhdGEgb2JqZWN0cyBpbiBlYWNoIHJlbmRlciEnLFxuICAgICAgY29udGV4dFxuICAgICk7XG4gICAgcmV0dXJuIGNyZWF0ZUVtcHR5Vk5vZGUoKVxuICB9XG4gIC8vIG9iamVjdCBzeW50YXggaW4gdi1iaW5kXG4gIGlmIChpc0RlZihkYXRhKSAmJiBpc0RlZihkYXRhLmlzKSkge1xuICAgIHRhZyA9IGRhdGEuaXM7XG4gIH1cbiAgaWYgKCF0YWcpIHtcbiAgICAvLyBpbiBjYXNlIG9mIGNvbXBvbmVudCA6aXMgc2V0IHRvIGZhbHN5IHZhbHVlXG4gICAgcmV0dXJuIGNyZWF0ZUVtcHR5Vk5vZGUoKVxuICB9XG4gIC8vIHdhcm4gYWdhaW5zdCBub24tcHJpbWl0aXZlIGtleVxuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJlxuICAgIGlzRGVmKGRhdGEpICYmIGlzRGVmKGRhdGEua2V5KSAmJiAhaXNQcmltaXRpdmUoZGF0YS5rZXkpXG4gICkge1xuICAgIHtcbiAgICAgIHdhcm4oXG4gICAgICAgICdBdm9pZCB1c2luZyBub24tcHJpbWl0aXZlIHZhbHVlIGFzIGtleSwgJyArXG4gICAgICAgICd1c2Ugc3RyaW5nL251bWJlciB2YWx1ZSBpbnN0ZWFkLicsXG4gICAgICAgIGNvbnRleHRcbiAgICAgICk7XG4gICAgfVxuICB9XG4gIC8vIHN1cHBvcnQgc2luZ2xlIGZ1bmN0aW9uIGNoaWxkcmVuIGFzIGRlZmF1bHQgc2NvcGVkIHNsb3RcbiAgaWYgKEFycmF5LmlzQXJyYXkoY2hpbGRyZW4pICYmXG4gICAgdHlwZW9mIGNoaWxkcmVuWzBdID09PSAnZnVuY3Rpb24nXG4gICkge1xuICAgIGRhdGEgPSBkYXRhIHx8IHt9O1xuICAgIGRhdGEuc2NvcGVkU2xvdHMgPSB7IGRlZmF1bHQ6IGNoaWxkcmVuWzBdIH07XG4gICAgY2hpbGRyZW4ubGVuZ3RoID0gMDtcbiAgfVxuICBpZiAobm9ybWFsaXphdGlvblR5cGUgPT09IEFMV0FZU19OT1JNQUxJWkUpIHtcbiAgICBjaGlsZHJlbiA9IG5vcm1hbGl6ZUNoaWxkcmVuKGNoaWxkcmVuKTtcbiAgfSBlbHNlIGlmIChub3JtYWxpemF0aW9uVHlwZSA9PT0gU0lNUExFX05PUk1BTElaRSkge1xuICAgIGNoaWxkcmVuID0gc2ltcGxlTm9ybWFsaXplQ2hpbGRyZW4oY2hpbGRyZW4pO1xuICB9XG4gIHZhciB2bm9kZSwgbnM7XG4gIGlmICh0eXBlb2YgdGFnID09PSAnc3RyaW5nJykge1xuICAgIHZhciBDdG9yO1xuICAgIG5zID0gKGNvbnRleHQuJHZub2RlICYmIGNvbnRleHQuJHZub2RlLm5zKSB8fCBjb25maWcuZ2V0VGFnTmFtZXNwYWNlKHRhZyk7XG4gICAgaWYgKGNvbmZpZy5pc1Jlc2VydmVkVGFnKHRhZykpIHtcbiAgICAgIC8vIHBsYXRmb3JtIGJ1aWx0LWluIGVsZW1lbnRzXG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiBpc0RlZihkYXRhKSAmJiBpc0RlZihkYXRhLm5hdGl2ZU9uKSAmJiBkYXRhLnRhZyAhPT0gJ2NvbXBvbmVudCcpIHtcbiAgICAgICAgd2FybihcbiAgICAgICAgICAoXCJUaGUgLm5hdGl2ZSBtb2RpZmllciBmb3Igdi1vbiBpcyBvbmx5IHZhbGlkIG9uIGNvbXBvbmVudHMgYnV0IGl0IHdhcyB1c2VkIG9uIDxcIiArIHRhZyArIFwiPi5cIiksXG4gICAgICAgICAgY29udGV4dFxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgdm5vZGUgPSBuZXcgVk5vZGUoXG4gICAgICAgIGNvbmZpZy5wYXJzZVBsYXRmb3JtVGFnTmFtZSh0YWcpLCBkYXRhLCBjaGlsZHJlbixcbiAgICAgICAgdW5kZWZpbmVkLCB1bmRlZmluZWQsIGNvbnRleHRcbiAgICAgICk7XG4gICAgfSBlbHNlIGlmICgoIWRhdGEgfHwgIWRhdGEucHJlKSAmJiBpc0RlZihDdG9yID0gcmVzb2x2ZUFzc2V0KGNvbnRleHQuJG9wdGlvbnMsICdjb21wb25lbnRzJywgdGFnKSkpIHtcbiAgICAgIC8vIGNvbXBvbmVudFxuICAgICAgdm5vZGUgPSBjcmVhdGVDb21wb25lbnQoQ3RvciwgZGF0YSwgY29udGV4dCwgY2hpbGRyZW4sIHRhZyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIHVua25vd24gb3IgdW5saXN0ZWQgbmFtZXNwYWNlZCBlbGVtZW50c1xuICAgICAgLy8gY2hlY2sgYXQgcnVudGltZSBiZWNhdXNlIGl0IG1heSBnZXQgYXNzaWduZWQgYSBuYW1lc3BhY2Ugd2hlbiBpdHNcbiAgICAgIC8vIHBhcmVudCBub3JtYWxpemVzIGNoaWxkcmVuXG4gICAgICB2bm9kZSA9IG5ldyBWTm9kZShcbiAgICAgICAgdGFnLCBkYXRhLCBjaGlsZHJlbixcbiAgICAgICAgdW5kZWZpbmVkLCB1bmRlZmluZWQsIGNvbnRleHRcbiAgICAgICk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIC8vIGRpcmVjdCBjb21wb25lbnQgb3B0aW9ucyAvIGNvbnN0cnVjdG9yXG4gICAgdm5vZGUgPSBjcmVhdGVDb21wb25lbnQodGFnLCBkYXRhLCBjb250ZXh0LCBjaGlsZHJlbik7XG4gIH1cbiAgaWYgKEFycmF5LmlzQXJyYXkodm5vZGUpKSB7XG4gICAgcmV0dXJuIHZub2RlXG4gIH0gZWxzZSBpZiAoaXNEZWYodm5vZGUpKSB7XG4gICAgaWYgKGlzRGVmKG5zKSkgeyBhcHBseU5TKHZub2RlLCBucyk7IH1cbiAgICBpZiAoaXNEZWYoZGF0YSkpIHsgcmVnaXN0ZXJEZWVwQmluZGluZ3MoZGF0YSk7IH1cbiAgICByZXR1cm4gdm5vZGVcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gY3JlYXRlRW1wdHlWTm9kZSgpXG4gIH1cbn1cblxuZnVuY3Rpb24gYXBwbHlOUyAodm5vZGUsIG5zLCBmb3JjZSkge1xuICB2bm9kZS5ucyA9IG5zO1xuICBpZiAodm5vZGUudGFnID09PSAnZm9yZWlnbk9iamVjdCcpIHtcbiAgICAvLyB1c2UgZGVmYXVsdCBuYW1lc3BhY2UgaW5zaWRlIGZvcmVpZ25PYmplY3RcbiAgICBucyA9IHVuZGVmaW5lZDtcbiAgICBmb3JjZSA9IHRydWU7XG4gIH1cbiAgaWYgKGlzRGVmKHZub2RlLmNoaWxkcmVuKSkge1xuICAgIGZvciAodmFyIGkgPSAwLCBsID0gdm5vZGUuY2hpbGRyZW4ubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICB2YXIgY2hpbGQgPSB2bm9kZS5jaGlsZHJlbltpXTtcbiAgICAgIGlmIChpc0RlZihjaGlsZC50YWcpICYmIChcbiAgICAgICAgaXNVbmRlZihjaGlsZC5ucykgfHwgKGlzVHJ1ZShmb3JjZSkgJiYgY2hpbGQudGFnICE9PSAnc3ZnJykpKSB7XG4gICAgICAgIGFwcGx5TlMoY2hpbGQsIG5zLCBmb3JjZSk7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbi8vIHJlZiAjNTMxOFxuLy8gbmVjZXNzYXJ5IHRvIGVuc3VyZSBwYXJlbnQgcmUtcmVuZGVyIHdoZW4gZGVlcCBiaW5kaW5ncyBsaWtlIDpzdHlsZSBhbmRcbi8vIDpjbGFzcyBhcmUgdXNlZCBvbiBzbG90IG5vZGVzXG5mdW5jdGlvbiByZWdpc3RlckRlZXBCaW5kaW5ncyAoZGF0YSkge1xuICBpZiAoaXNPYmplY3QoZGF0YS5zdHlsZSkpIHtcbiAgICB0cmF2ZXJzZShkYXRhLnN0eWxlKTtcbiAgfVxuICBpZiAoaXNPYmplY3QoZGF0YS5jbGFzcykpIHtcbiAgICB0cmF2ZXJzZShkYXRhLmNsYXNzKTtcbiAgfVxufVxuXG4vKiAgKi9cblxuZnVuY3Rpb24gaW5pdFJlbmRlciAodm0pIHtcbiAgdm0uX3Zub2RlID0gbnVsbDsgLy8gdGhlIHJvb3Qgb2YgdGhlIGNoaWxkIHRyZWVcbiAgdm0uX3N0YXRpY1RyZWVzID0gbnVsbDsgLy8gdi1vbmNlIGNhY2hlZCB0cmVlc1xuICB2YXIgb3B0aW9ucyA9IHZtLiRvcHRpb25zO1xuICB2YXIgcGFyZW50Vm5vZGUgPSB2bS4kdm5vZGUgPSBvcHRpb25zLl9wYXJlbnRWbm9kZTsgLy8gdGhlIHBsYWNlaG9sZGVyIG5vZGUgaW4gcGFyZW50IHRyZWVcbiAgdmFyIHJlbmRlckNvbnRleHQgPSBwYXJlbnRWbm9kZSAmJiBwYXJlbnRWbm9kZS5jb250ZXh0O1xuICB2bS4kc2xvdHMgPSByZXNvbHZlU2xvdHMob3B0aW9ucy5fcmVuZGVyQ2hpbGRyZW4sIHJlbmRlckNvbnRleHQpO1xuICB2bS4kc2NvcGVkU2xvdHMgPSBlbXB0eU9iamVjdDtcbiAgLy8gYmluZCB0aGUgY3JlYXRlRWxlbWVudCBmbiB0byB0aGlzIGluc3RhbmNlXG4gIC8vIHNvIHRoYXQgd2UgZ2V0IHByb3BlciByZW5kZXIgY29udGV4dCBpbnNpZGUgaXQuXG4gIC8vIGFyZ3Mgb3JkZXI6IHRhZywgZGF0YSwgY2hpbGRyZW4sIG5vcm1hbGl6YXRpb25UeXBlLCBhbHdheXNOb3JtYWxpemVcbiAgLy8gaW50ZXJuYWwgdmVyc2lvbiBpcyB1c2VkIGJ5IHJlbmRlciBmdW5jdGlvbnMgY29tcGlsZWQgZnJvbSB0ZW1wbGF0ZXNcbiAgdm0uX2MgPSBmdW5jdGlvbiAoYSwgYiwgYywgZCkgeyByZXR1cm4gY3JlYXRlRWxlbWVudCh2bSwgYSwgYiwgYywgZCwgZmFsc2UpOyB9O1xuICAvLyBub3JtYWxpemF0aW9uIGlzIGFsd2F5cyBhcHBsaWVkIGZvciB0aGUgcHVibGljIHZlcnNpb24sIHVzZWQgaW5cbiAgLy8gdXNlci13cml0dGVuIHJlbmRlciBmdW5jdGlvbnMuXG4gIHZtLiRjcmVhdGVFbGVtZW50ID0gZnVuY3Rpb24gKGEsIGIsIGMsIGQpIHsgcmV0dXJuIGNyZWF0ZUVsZW1lbnQodm0sIGEsIGIsIGMsIGQsIHRydWUpOyB9O1xuXG4gIC8vICRhdHRycyAmICRsaXN0ZW5lcnMgYXJlIGV4cG9zZWQgZm9yIGVhc2llciBIT0MgY3JlYXRpb24uXG4gIC8vIHRoZXkgbmVlZCB0byBiZSByZWFjdGl2ZSBzbyB0aGF0IEhPQ3MgdXNpbmcgdGhlbSBhcmUgYWx3YXlzIHVwZGF0ZWRcbiAgdmFyIHBhcmVudERhdGEgPSBwYXJlbnRWbm9kZSAmJiBwYXJlbnRWbm9kZS5kYXRhO1xuXG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgZGVmaW5lUmVhY3RpdmUkJDEodm0sICckYXR0cnMnLCBwYXJlbnREYXRhICYmIHBhcmVudERhdGEuYXR0cnMgfHwgZW1wdHlPYmplY3QsIGZ1bmN0aW9uICgpIHtcbiAgICAgICFpc1VwZGF0aW5nQ2hpbGRDb21wb25lbnQgJiYgd2FybihcIiRhdHRycyBpcyByZWFkb25seS5cIiwgdm0pO1xuICAgIH0sIHRydWUpO1xuICAgIGRlZmluZVJlYWN0aXZlJCQxKHZtLCAnJGxpc3RlbmVycycsIG9wdGlvbnMuX3BhcmVudExpc3RlbmVycyB8fCBlbXB0eU9iamVjdCwgZnVuY3Rpb24gKCkge1xuICAgICAgIWlzVXBkYXRpbmdDaGlsZENvbXBvbmVudCAmJiB3YXJuKFwiJGxpc3RlbmVycyBpcyByZWFkb25seS5cIiwgdm0pO1xuICAgIH0sIHRydWUpO1xuICB9IGVsc2Uge1xuICAgIGRlZmluZVJlYWN0aXZlJCQxKHZtLCAnJGF0dHJzJywgcGFyZW50RGF0YSAmJiBwYXJlbnREYXRhLmF0dHJzIHx8IGVtcHR5T2JqZWN0LCBudWxsLCB0cnVlKTtcbiAgICBkZWZpbmVSZWFjdGl2ZSQkMSh2bSwgJyRsaXN0ZW5lcnMnLCBvcHRpb25zLl9wYXJlbnRMaXN0ZW5lcnMgfHwgZW1wdHlPYmplY3QsIG51bGwsIHRydWUpO1xuICB9XG59XG5cbnZhciBjdXJyZW50UmVuZGVyaW5nSW5zdGFuY2UgPSBudWxsO1xuXG5mdW5jdGlvbiByZW5kZXJNaXhpbiAoVnVlKSB7XG4gIC8vIGluc3RhbGwgcnVudGltZSBjb252ZW5pZW5jZSBoZWxwZXJzXG4gIGluc3RhbGxSZW5kZXJIZWxwZXJzKFZ1ZS5wcm90b3R5cGUpO1xuXG4gIFZ1ZS5wcm90b3R5cGUuJG5leHRUaWNrID0gZnVuY3Rpb24gKGZuKSB7XG4gICAgcmV0dXJuIG5leHRUaWNrKGZuLCB0aGlzKVxuICB9O1xuXG4gIFZ1ZS5wcm90b3R5cGUuX3JlbmRlciA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgdm0gPSB0aGlzO1xuICAgIHZhciByZWYgPSB2bS4kb3B0aW9ucztcbiAgICB2YXIgcmVuZGVyID0gcmVmLnJlbmRlcjtcbiAgICB2YXIgX3BhcmVudFZub2RlID0gcmVmLl9wYXJlbnRWbm9kZTtcblxuICAgIGlmIChfcGFyZW50Vm5vZGUpIHtcbiAgICAgIHZtLiRzY29wZWRTbG90cyA9IG5vcm1hbGl6ZVNjb3BlZFNsb3RzKFxuICAgICAgICBfcGFyZW50Vm5vZGUuZGF0YS5zY29wZWRTbG90cyxcbiAgICAgICAgdm0uJHNsb3RzLFxuICAgICAgICB2bS4kc2NvcGVkU2xvdHNcbiAgICAgICk7XG4gICAgfVxuXG4gICAgLy8gc2V0IHBhcmVudCB2bm9kZS4gdGhpcyBhbGxvd3MgcmVuZGVyIGZ1bmN0aW9ucyB0byBoYXZlIGFjY2Vzc1xuICAgIC8vIHRvIHRoZSBkYXRhIG9uIHRoZSBwbGFjZWhvbGRlciBub2RlLlxuICAgIHZtLiR2bm9kZSA9IF9wYXJlbnRWbm9kZTtcbiAgICAvLyByZW5kZXIgc2VsZlxuICAgIHZhciB2bm9kZTtcbiAgICB0cnkge1xuICAgICAgLy8gVGhlcmUncyBubyBuZWVkIHRvIG1haW50YWluIGEgc3RhY2sgYmVjYXVzZSBhbGwgcmVuZGVyIGZucyBhcmUgY2FsbGVkXG4gICAgICAvLyBzZXBhcmF0ZWx5IGZyb20gb25lIGFub3RoZXIuIE5lc3RlZCBjb21wb25lbnQncyByZW5kZXIgZm5zIGFyZSBjYWxsZWRcbiAgICAgIC8vIHdoZW4gcGFyZW50IGNvbXBvbmVudCBpcyBwYXRjaGVkLlxuICAgICAgY3VycmVudFJlbmRlcmluZ0luc3RhbmNlID0gdm07XG4gICAgICB2bm9kZSA9IHJlbmRlci5jYWxsKHZtLl9yZW5kZXJQcm94eSwgdm0uJGNyZWF0ZUVsZW1lbnQpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGhhbmRsZUVycm9yKGUsIHZtLCBcInJlbmRlclwiKTtcbiAgICAgIC8vIHJldHVybiBlcnJvciByZW5kZXIgcmVzdWx0LFxuICAgICAgLy8gb3IgcHJldmlvdXMgdm5vZGUgdG8gcHJldmVudCByZW5kZXIgZXJyb3IgY2F1c2luZyBibGFuayBjb21wb25lbnRcbiAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiB2bS4kb3B0aW9ucy5yZW5kZXJFcnJvcikge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIHZub2RlID0gdm0uJG9wdGlvbnMucmVuZGVyRXJyb3IuY2FsbCh2bS5fcmVuZGVyUHJveHksIHZtLiRjcmVhdGVFbGVtZW50LCBlKTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgIGhhbmRsZUVycm9yKGUsIHZtLCBcInJlbmRlckVycm9yXCIpO1xuICAgICAgICAgIHZub2RlID0gdm0uX3Zub2RlO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2bm9kZSA9IHZtLl92bm9kZTtcbiAgICAgIH1cbiAgICB9IGZpbmFsbHkge1xuICAgICAgY3VycmVudFJlbmRlcmluZ0luc3RhbmNlID0gbnVsbDtcbiAgICB9XG4gICAgLy8gaWYgdGhlIHJldHVybmVkIGFycmF5IGNvbnRhaW5zIG9ubHkgYSBzaW5nbGUgbm9kZSwgYWxsb3cgaXRcbiAgICBpZiAoQXJyYXkuaXNBcnJheSh2bm9kZSkgJiYgdm5vZGUubGVuZ3RoID09PSAxKSB7XG4gICAgICB2bm9kZSA9IHZub2RlWzBdO1xuICAgIH1cbiAgICAvLyByZXR1cm4gZW1wdHkgdm5vZGUgaW4gY2FzZSB0aGUgcmVuZGVyIGZ1bmN0aW9uIGVycm9yZWQgb3V0XG4gICAgaWYgKCEodm5vZGUgaW5zdGFuY2VvZiBWTm9kZSkpIHtcbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIEFycmF5LmlzQXJyYXkodm5vZGUpKSB7XG4gICAgICAgIHdhcm4oXG4gICAgICAgICAgJ011bHRpcGxlIHJvb3Qgbm9kZXMgcmV0dXJuZWQgZnJvbSByZW5kZXIgZnVuY3Rpb24uIFJlbmRlciBmdW5jdGlvbiAnICtcbiAgICAgICAgICAnc2hvdWxkIHJldHVybiBhIHNpbmdsZSByb290IG5vZGUuJyxcbiAgICAgICAgICB2bVxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgdm5vZGUgPSBjcmVhdGVFbXB0eVZOb2RlKCk7XG4gICAgfVxuICAgIC8vIHNldCBwYXJlbnRcbiAgICB2bm9kZS5wYXJlbnQgPSBfcGFyZW50Vm5vZGU7XG4gICAgcmV0dXJuIHZub2RlXG4gIH07XG59XG5cbi8qICAqL1xuXG5mdW5jdGlvbiBlbnN1cmVDdG9yIChjb21wLCBiYXNlKSB7XG4gIGlmIChcbiAgICBjb21wLl9fZXNNb2R1bGUgfHxcbiAgICAoaGFzU3ltYm9sICYmIGNvbXBbU3ltYm9sLnRvU3RyaW5nVGFnXSA9PT0gJ01vZHVsZScpXG4gICkge1xuICAgIGNvbXAgPSBjb21wLmRlZmF1bHQ7XG4gIH1cbiAgcmV0dXJuIGlzT2JqZWN0KGNvbXApXG4gICAgPyBiYXNlLmV4dGVuZChjb21wKVxuICAgIDogY29tcFxufVxuXG5mdW5jdGlvbiBjcmVhdGVBc3luY1BsYWNlaG9sZGVyIChcbiAgZmFjdG9yeSxcbiAgZGF0YSxcbiAgY29udGV4dCxcbiAgY2hpbGRyZW4sXG4gIHRhZ1xuKSB7XG4gIHZhciBub2RlID0gY3JlYXRlRW1wdHlWTm9kZSgpO1xuICBub2RlLmFzeW5jRmFjdG9yeSA9IGZhY3Rvcnk7XG4gIG5vZGUuYXN5bmNNZXRhID0geyBkYXRhOiBkYXRhLCBjb250ZXh0OiBjb250ZXh0LCBjaGlsZHJlbjogY2hpbGRyZW4sIHRhZzogdGFnIH07XG4gIHJldHVybiBub2RlXG59XG5cbmZ1bmN0aW9uIHJlc29sdmVBc3luY0NvbXBvbmVudCAoXG4gIGZhY3RvcnksXG4gIGJhc2VDdG9yXG4pIHtcbiAgaWYgKGlzVHJ1ZShmYWN0b3J5LmVycm9yKSAmJiBpc0RlZihmYWN0b3J5LmVycm9yQ29tcCkpIHtcbiAgICByZXR1cm4gZmFjdG9yeS5lcnJvckNvbXBcbiAgfVxuXG4gIGlmIChpc0RlZihmYWN0b3J5LnJlc29sdmVkKSkge1xuICAgIHJldHVybiBmYWN0b3J5LnJlc29sdmVkXG4gIH1cblxuICB2YXIgb3duZXIgPSBjdXJyZW50UmVuZGVyaW5nSW5zdGFuY2U7XG4gIGlmIChvd25lciAmJiBpc0RlZihmYWN0b3J5Lm93bmVycykgJiYgZmFjdG9yeS5vd25lcnMuaW5kZXhPZihvd25lcikgPT09IC0xKSB7XG4gICAgLy8gYWxyZWFkeSBwZW5kaW5nXG4gICAgZmFjdG9yeS5vd25lcnMucHVzaChvd25lcik7XG4gIH1cblxuICBpZiAoaXNUcnVlKGZhY3RvcnkubG9hZGluZykgJiYgaXNEZWYoZmFjdG9yeS5sb2FkaW5nQ29tcCkpIHtcbiAgICByZXR1cm4gZmFjdG9yeS5sb2FkaW5nQ29tcFxuICB9XG5cbiAgaWYgKG93bmVyICYmICFpc0RlZihmYWN0b3J5Lm93bmVycykpIHtcbiAgICB2YXIgb3duZXJzID0gZmFjdG9yeS5vd25lcnMgPSBbb3duZXJdO1xuICAgIHZhciBzeW5jID0gdHJ1ZTtcbiAgICB2YXIgdGltZXJMb2FkaW5nID0gbnVsbDtcbiAgICB2YXIgdGltZXJUaW1lb3V0ID0gbnVsbFxuXG4gICAgOyhvd25lcikuJG9uKCdob29rOmRlc3Ryb3llZCcsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIHJlbW92ZShvd25lcnMsIG93bmVyKTsgfSk7XG5cbiAgICB2YXIgZm9yY2VSZW5kZXIgPSBmdW5jdGlvbiAocmVuZGVyQ29tcGxldGVkKSB7XG4gICAgICBmb3IgKHZhciBpID0gMCwgbCA9IG93bmVycy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgKG93bmVyc1tpXSkuJGZvcmNlVXBkYXRlKCk7XG4gICAgICB9XG5cbiAgICAgIGlmIChyZW5kZXJDb21wbGV0ZWQpIHtcbiAgICAgICAgb3duZXJzLmxlbmd0aCA9IDA7XG4gICAgICAgIGlmICh0aW1lckxvYWRpbmcgIT09IG51bGwpIHtcbiAgICAgICAgICBjbGVhclRpbWVvdXQodGltZXJMb2FkaW5nKTtcbiAgICAgICAgICB0aW1lckxvYWRpbmcgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aW1lclRpbWVvdXQgIT09IG51bGwpIHtcbiAgICAgICAgICBjbGVhclRpbWVvdXQodGltZXJUaW1lb3V0KTtcbiAgICAgICAgICB0aW1lclRpbWVvdXQgPSBudWxsO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcblxuICAgIHZhciByZXNvbHZlID0gb25jZShmdW5jdGlvbiAocmVzKSB7XG4gICAgICAvLyBjYWNoZSByZXNvbHZlZFxuICAgICAgZmFjdG9yeS5yZXNvbHZlZCA9IGVuc3VyZUN0b3IocmVzLCBiYXNlQ3Rvcik7XG4gICAgICAvLyBpbnZva2UgY2FsbGJhY2tzIG9ubHkgaWYgdGhpcyBpcyBub3QgYSBzeW5jaHJvbm91cyByZXNvbHZlXG4gICAgICAvLyAoYXN5bmMgcmVzb2x2ZXMgYXJlIHNoaW1tZWQgYXMgc3luY2hyb25vdXMgZHVyaW5nIFNTUilcbiAgICAgIGlmICghc3luYykge1xuICAgICAgICBmb3JjZVJlbmRlcih0cnVlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG93bmVycy5sZW5ndGggPSAwO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgdmFyIHJlamVjdCA9IG9uY2UoZnVuY3Rpb24gKHJlYXNvbikge1xuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiB3YXJuKFxuICAgICAgICBcIkZhaWxlZCB0byByZXNvbHZlIGFzeW5jIGNvbXBvbmVudDogXCIgKyAoU3RyaW5nKGZhY3RvcnkpKSArXG4gICAgICAgIChyZWFzb24gPyAoXCJcXG5SZWFzb246IFwiICsgcmVhc29uKSA6ICcnKVxuICAgICAgKTtcbiAgICAgIGlmIChpc0RlZihmYWN0b3J5LmVycm9yQ29tcCkpIHtcbiAgICAgICAgZmFjdG9yeS5lcnJvciA9IHRydWU7XG4gICAgICAgIGZvcmNlUmVuZGVyKHRydWUpO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgdmFyIHJlcyA9IGZhY3RvcnkocmVzb2x2ZSwgcmVqZWN0KTtcblxuICAgIGlmIChpc09iamVjdChyZXMpKSB7XG4gICAgICBpZiAoaXNQcm9taXNlKHJlcykpIHtcbiAgICAgICAgLy8gKCkgPT4gUHJvbWlzZVxuICAgICAgICBpZiAoaXNVbmRlZihmYWN0b3J5LnJlc29sdmVkKSkge1xuICAgICAgICAgIHJlcy50aGVuKHJlc29sdmUsIHJlamVjdCk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoaXNQcm9taXNlKHJlcy5jb21wb25lbnQpKSB7XG4gICAgICAgIHJlcy5jb21wb25lbnQudGhlbihyZXNvbHZlLCByZWplY3QpO1xuXG4gICAgICAgIGlmIChpc0RlZihyZXMuZXJyb3IpKSB7XG4gICAgICAgICAgZmFjdG9yeS5lcnJvckNvbXAgPSBlbnN1cmVDdG9yKHJlcy5lcnJvciwgYmFzZUN0b3IpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGlzRGVmKHJlcy5sb2FkaW5nKSkge1xuICAgICAgICAgIGZhY3RvcnkubG9hZGluZ0NvbXAgPSBlbnN1cmVDdG9yKHJlcy5sb2FkaW5nLCBiYXNlQ3Rvcik7XG4gICAgICAgICAgaWYgKHJlcy5kZWxheSA9PT0gMCkge1xuICAgICAgICAgICAgZmFjdG9yeS5sb2FkaW5nID0gdHJ1ZTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGltZXJMb2FkaW5nID0gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgIHRpbWVyTG9hZGluZyA9IG51bGw7XG4gICAgICAgICAgICAgIGlmIChpc1VuZGVmKGZhY3RvcnkucmVzb2x2ZWQpICYmIGlzVW5kZWYoZmFjdG9yeS5lcnJvcikpIHtcbiAgICAgICAgICAgICAgICBmYWN0b3J5LmxvYWRpbmcgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGZvcmNlUmVuZGVyKGZhbHNlKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwgcmVzLmRlbGF5IHx8IDIwMCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGlzRGVmKHJlcy50aW1lb3V0KSkge1xuICAgICAgICAgIHRpbWVyVGltZW91dCA9IHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdGltZXJUaW1lb3V0ID0gbnVsbDtcbiAgICAgICAgICAgIGlmIChpc1VuZGVmKGZhY3RvcnkucmVzb2x2ZWQpKSB7XG4gICAgICAgICAgICAgIHJlamVjdChcbiAgICAgICAgICAgICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nXG4gICAgICAgICAgICAgICAgICA/IChcInRpbWVvdXQgKFwiICsgKHJlcy50aW1lb3V0KSArIFwibXMpXCIpXG4gICAgICAgICAgICAgICAgICA6IG51bGxcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9LCByZXMudGltZW91dCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBzeW5jID0gZmFsc2U7XG4gICAgLy8gcmV0dXJuIGluIGNhc2UgcmVzb2x2ZWQgc3luY2hyb25vdXNseVxuICAgIHJldHVybiBmYWN0b3J5LmxvYWRpbmdcbiAgICAgID8gZmFjdG9yeS5sb2FkaW5nQ29tcFxuICAgICAgOiBmYWN0b3J5LnJlc29sdmVkXG4gIH1cbn1cblxuLyogICovXG5cbmZ1bmN0aW9uIGdldEZpcnN0Q29tcG9uZW50Q2hpbGQgKGNoaWxkcmVuKSB7XG4gIGlmIChBcnJheS5pc0FycmF5KGNoaWxkcmVuKSkge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBjID0gY2hpbGRyZW5baV07XG4gICAgICBpZiAoaXNEZWYoYykgJiYgKGlzRGVmKGMuY29tcG9uZW50T3B0aW9ucykgfHwgaXNBc3luY1BsYWNlaG9sZGVyKGMpKSkge1xuICAgICAgICByZXR1cm4gY1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG4vKiAgKi9cblxuLyogICovXG5cbmZ1bmN0aW9uIGluaXRFdmVudHMgKHZtKSB7XG4gIHZtLl9ldmVudHMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICB2bS5faGFzSG9va0V2ZW50ID0gZmFsc2U7XG4gIC8vIGluaXQgcGFyZW50IGF0dGFjaGVkIGV2ZW50c1xuICB2YXIgbGlzdGVuZXJzID0gdm0uJG9wdGlvbnMuX3BhcmVudExpc3RlbmVycztcbiAgaWYgKGxpc3RlbmVycykge1xuICAgIHVwZGF0ZUNvbXBvbmVudExpc3RlbmVycyh2bSwgbGlzdGVuZXJzKTtcbiAgfVxufVxuXG52YXIgdGFyZ2V0O1xuXG5mdW5jdGlvbiBhZGQgKGV2ZW50LCBmbikge1xuICB0YXJnZXQuJG9uKGV2ZW50LCBmbik7XG59XG5cbmZ1bmN0aW9uIHJlbW92ZSQxIChldmVudCwgZm4pIHtcbiAgdGFyZ2V0LiRvZmYoZXZlbnQsIGZuKTtcbn1cblxuZnVuY3Rpb24gY3JlYXRlT25jZUhhbmRsZXIgKGV2ZW50LCBmbikge1xuICB2YXIgX3RhcmdldCA9IHRhcmdldDtcbiAgcmV0dXJuIGZ1bmN0aW9uIG9uY2VIYW5kbGVyICgpIHtcbiAgICB2YXIgcmVzID0gZm4uYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbiAgICBpZiAocmVzICE9PSBudWxsKSB7XG4gICAgICBfdGFyZ2V0LiRvZmYoZXZlbnQsIG9uY2VIYW5kbGVyKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gdXBkYXRlQ29tcG9uZW50TGlzdGVuZXJzIChcbiAgdm0sXG4gIGxpc3RlbmVycyxcbiAgb2xkTGlzdGVuZXJzXG4pIHtcbiAgdGFyZ2V0ID0gdm07XG4gIHVwZGF0ZUxpc3RlbmVycyhsaXN0ZW5lcnMsIG9sZExpc3RlbmVycyB8fCB7fSwgYWRkLCByZW1vdmUkMSwgY3JlYXRlT25jZUhhbmRsZXIsIHZtKTtcbiAgdGFyZ2V0ID0gdW5kZWZpbmVkO1xufVxuXG5mdW5jdGlvbiBldmVudHNNaXhpbiAoVnVlKSB7XG4gIHZhciBob29rUkUgPSAvXmhvb2s6LztcbiAgVnVlLnByb3RvdHlwZS4kb24gPSBmdW5jdGlvbiAoZXZlbnQsIGZuKSB7XG4gICAgdmFyIHZtID0gdGhpcztcbiAgICBpZiAoQXJyYXkuaXNBcnJheShldmVudCkpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gZXZlbnQubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgIHZtLiRvbihldmVudFtpXSwgZm4pO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAodm0uX2V2ZW50c1tldmVudF0gfHwgKHZtLl9ldmVudHNbZXZlbnRdID0gW10pKS5wdXNoKGZuKTtcbiAgICAgIC8vIG9wdGltaXplIGhvb2s6ZXZlbnQgY29zdCBieSB1c2luZyBhIGJvb2xlYW4gZmxhZyBtYXJrZWQgYXQgcmVnaXN0cmF0aW9uXG4gICAgICAvLyBpbnN0ZWFkIG9mIGEgaGFzaCBsb29rdXBcbiAgICAgIGlmIChob29rUkUudGVzdChldmVudCkpIHtcbiAgICAgICAgdm0uX2hhc0hvb2tFdmVudCA9IHRydWU7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB2bVxuICB9O1xuXG4gIFZ1ZS5wcm90b3R5cGUuJG9uY2UgPSBmdW5jdGlvbiAoZXZlbnQsIGZuKSB7XG4gICAgdmFyIHZtID0gdGhpcztcbiAgICBmdW5jdGlvbiBvbiAoKSB7XG4gICAgICB2bS4kb2ZmKGV2ZW50LCBvbik7XG4gICAgICBmbi5hcHBseSh2bSwgYXJndW1lbnRzKTtcbiAgICB9XG4gICAgb24uZm4gPSBmbjtcbiAgICB2bS4kb24oZXZlbnQsIG9uKTtcbiAgICByZXR1cm4gdm1cbiAgfTtcblxuICBWdWUucHJvdG90eXBlLiRvZmYgPSBmdW5jdGlvbiAoZXZlbnQsIGZuKSB7XG4gICAgdmFyIHZtID0gdGhpcztcbiAgICAvLyBhbGxcbiAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICAgIHZtLl9ldmVudHMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgICAgcmV0dXJuIHZtXG4gICAgfVxuICAgIC8vIGFycmF5IG9mIGV2ZW50c1xuICAgIGlmIChBcnJheS5pc0FycmF5KGV2ZW50KSkge1xuICAgICAgZm9yICh2YXIgaSQxID0gMCwgbCA9IGV2ZW50Lmxlbmd0aDsgaSQxIDwgbDsgaSQxKyspIHtcbiAgICAgICAgdm0uJG9mZihldmVudFtpJDFdLCBmbik7XG4gICAgICB9XG4gICAgICByZXR1cm4gdm1cbiAgICB9XG4gICAgLy8gc3BlY2lmaWMgZXZlbnRcbiAgICB2YXIgY2JzID0gdm0uX2V2ZW50c1tldmVudF07XG4gICAgaWYgKCFjYnMpIHtcbiAgICAgIHJldHVybiB2bVxuICAgIH1cbiAgICBpZiAoIWZuKSB7XG4gICAgICB2bS5fZXZlbnRzW2V2ZW50XSA9IG51bGw7XG4gICAgICByZXR1cm4gdm1cbiAgICB9XG4gICAgLy8gc3BlY2lmaWMgaGFuZGxlclxuICAgIHZhciBjYjtcbiAgICB2YXIgaSA9IGNicy5sZW5ndGg7XG4gICAgd2hpbGUgKGktLSkge1xuICAgICAgY2IgPSBjYnNbaV07XG4gICAgICBpZiAoY2IgPT09IGZuIHx8IGNiLmZuID09PSBmbikge1xuICAgICAgICBjYnMuc3BsaWNlKGksIDEpO1xuICAgICAgICBicmVha1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdm1cbiAgfTtcblxuICBWdWUucHJvdG90eXBlLiRlbWl0ID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgdmFyIHZtID0gdGhpcztcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgdmFyIGxvd2VyQ2FzZUV2ZW50ID0gZXZlbnQudG9Mb3dlckNhc2UoKTtcbiAgICAgIGlmIChsb3dlckNhc2VFdmVudCAhPT0gZXZlbnQgJiYgdm0uX2V2ZW50c1tsb3dlckNhc2VFdmVudF0pIHtcbiAgICAgICAgdGlwKFxuICAgICAgICAgIFwiRXZlbnQgXFxcIlwiICsgbG93ZXJDYXNlRXZlbnQgKyBcIlxcXCIgaXMgZW1pdHRlZCBpbiBjb21wb25lbnQgXCIgK1xuICAgICAgICAgIChmb3JtYXRDb21wb25lbnROYW1lKHZtKSkgKyBcIiBidXQgdGhlIGhhbmRsZXIgaXMgcmVnaXN0ZXJlZCBmb3IgXFxcIlwiICsgZXZlbnQgKyBcIlxcXCIuIFwiICtcbiAgICAgICAgICBcIk5vdGUgdGhhdCBIVE1MIGF0dHJpYnV0ZXMgYXJlIGNhc2UtaW5zZW5zaXRpdmUgYW5kIHlvdSBjYW5ub3QgdXNlIFwiICtcbiAgICAgICAgICBcInYtb24gdG8gbGlzdGVuIHRvIGNhbWVsQ2FzZSBldmVudHMgd2hlbiB1c2luZyBpbi1ET00gdGVtcGxhdGVzLiBcIiArXG4gICAgICAgICAgXCJZb3Ugc2hvdWxkIHByb2JhYmx5IHVzZSBcXFwiXCIgKyAoaHlwaGVuYXRlKGV2ZW50KSkgKyBcIlxcXCIgaW5zdGVhZCBvZiBcXFwiXCIgKyBldmVudCArIFwiXFxcIi5cIlxuICAgICAgICApO1xuICAgICAgfVxuICAgIH1cbiAgICB2YXIgY2JzID0gdm0uX2V2ZW50c1tldmVudF07XG4gICAgaWYgKGNicykge1xuICAgICAgY2JzID0gY2JzLmxlbmd0aCA+IDEgPyB0b0FycmF5KGNicykgOiBjYnM7XG4gICAgICB2YXIgYXJncyA9IHRvQXJyYXkoYXJndW1lbnRzLCAxKTtcbiAgICAgIHZhciBpbmZvID0gXCJldmVudCBoYW5kbGVyIGZvciBcXFwiXCIgKyBldmVudCArIFwiXFxcIlwiO1xuICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSBjYnMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgIGludm9rZVdpdGhFcnJvckhhbmRsaW5nKGNic1tpXSwgdm0sIGFyZ3MsIHZtLCBpbmZvKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHZtXG4gIH07XG59XG5cbi8qICAqL1xuXG52YXIgYWN0aXZlSW5zdGFuY2UgPSBudWxsO1xudmFyIGlzVXBkYXRpbmdDaGlsZENvbXBvbmVudCA9IGZhbHNlO1xuXG5mdW5jdGlvbiBzZXRBY3RpdmVJbnN0YW5jZSh2bSkge1xuICB2YXIgcHJldkFjdGl2ZUluc3RhbmNlID0gYWN0aXZlSW5zdGFuY2U7XG4gIGFjdGl2ZUluc3RhbmNlID0gdm07XG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgYWN0aXZlSW5zdGFuY2UgPSBwcmV2QWN0aXZlSW5zdGFuY2U7XG4gIH1cbn1cblxuZnVuY3Rpb24gaW5pdExpZmVjeWNsZSAodm0pIHtcbiAgdmFyIG9wdGlvbnMgPSB2bS4kb3B0aW9ucztcblxuICAvLyBsb2NhdGUgZmlyc3Qgbm9uLWFic3RyYWN0IHBhcmVudFxuICB2YXIgcGFyZW50ID0gb3B0aW9ucy5wYXJlbnQ7XG4gIGlmIChwYXJlbnQgJiYgIW9wdGlvbnMuYWJzdHJhY3QpIHtcbiAgICB3aGlsZSAocGFyZW50LiRvcHRpb25zLmFic3RyYWN0ICYmIHBhcmVudC4kcGFyZW50KSB7XG4gICAgICBwYXJlbnQgPSBwYXJlbnQuJHBhcmVudDtcbiAgICB9XG4gICAgcGFyZW50LiRjaGlsZHJlbi5wdXNoKHZtKTtcbiAgfVxuXG4gIHZtLiRwYXJlbnQgPSBwYXJlbnQ7XG4gIHZtLiRyb290ID0gcGFyZW50ID8gcGFyZW50LiRyb290IDogdm07XG5cbiAgdm0uJGNoaWxkcmVuID0gW107XG4gIHZtLiRyZWZzID0ge307XG5cbiAgdm0uX3dhdGNoZXIgPSBudWxsO1xuICB2bS5faW5hY3RpdmUgPSBudWxsO1xuICB2bS5fZGlyZWN0SW5hY3RpdmUgPSBmYWxzZTtcbiAgdm0uX2lzTW91bnRlZCA9IGZhbHNlO1xuICB2bS5faXNEZXN0cm95ZWQgPSBmYWxzZTtcbiAgdm0uX2lzQmVpbmdEZXN0cm95ZWQgPSBmYWxzZTtcbn1cblxuZnVuY3Rpb24gbGlmZWN5Y2xlTWl4aW4gKFZ1ZSkge1xuICBWdWUucHJvdG90eXBlLl91cGRhdGUgPSBmdW5jdGlvbiAodm5vZGUsIGh5ZHJhdGluZykge1xuICAgIHZhciB2bSA9IHRoaXM7XG4gICAgdmFyIHByZXZFbCA9IHZtLiRlbDtcbiAgICB2YXIgcHJldlZub2RlID0gdm0uX3Zub2RlO1xuICAgIHZhciByZXN0b3JlQWN0aXZlSW5zdGFuY2UgPSBzZXRBY3RpdmVJbnN0YW5jZSh2bSk7XG4gICAgdm0uX3Zub2RlID0gdm5vZGU7XG4gICAgLy8gVnVlLnByb3RvdHlwZS5fX3BhdGNoX18gaXMgaW5qZWN0ZWQgaW4gZW50cnkgcG9pbnRzXG4gICAgLy8gYmFzZWQgb24gdGhlIHJlbmRlcmluZyBiYWNrZW5kIHVzZWQuXG4gICAgaWYgKCFwcmV2Vm5vZGUpIHtcbiAgICAgIC8vIGluaXRpYWwgcmVuZGVyXG4gICAgICB2bS4kZWwgPSB2bS5fX3BhdGNoX18odm0uJGVsLCB2bm9kZSwgaHlkcmF0aW5nLCBmYWxzZSAvKiByZW1vdmVPbmx5ICovKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gdXBkYXRlc1xuICAgICAgdm0uJGVsID0gdm0uX19wYXRjaF9fKHByZXZWbm9kZSwgdm5vZGUpO1xuICAgIH1cbiAgICByZXN0b3JlQWN0aXZlSW5zdGFuY2UoKTtcbiAgICAvLyB1cGRhdGUgX192dWVfXyByZWZlcmVuY2VcbiAgICBpZiAocHJldkVsKSB7XG4gICAgICBwcmV2RWwuX192dWVfXyA9IG51bGw7XG4gICAgfVxuICAgIGlmICh2bS4kZWwpIHtcbiAgICAgIHZtLiRlbC5fX3Z1ZV9fID0gdm07XG4gICAgfVxuICAgIC8vIGlmIHBhcmVudCBpcyBhbiBIT0MsIHVwZGF0ZSBpdHMgJGVsIGFzIHdlbGxcbiAgICBpZiAodm0uJHZub2RlICYmIHZtLiRwYXJlbnQgJiYgdm0uJHZub2RlID09PSB2bS4kcGFyZW50Ll92bm9kZSkge1xuICAgICAgdm0uJHBhcmVudC4kZWwgPSB2bS4kZWw7XG4gICAgfVxuICAgIC8vIHVwZGF0ZWQgaG9vayBpcyBjYWxsZWQgYnkgdGhlIHNjaGVkdWxlciB0byBlbnN1cmUgdGhhdCBjaGlsZHJlbiBhcmVcbiAgICAvLyB1cGRhdGVkIGluIGEgcGFyZW50J3MgdXBkYXRlZCBob29rLlxuICB9O1xuXG4gIFZ1ZS5wcm90b3R5cGUuJGZvcmNlVXBkYXRlID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciB2bSA9IHRoaXM7XG4gICAgaWYgKHZtLl93YXRjaGVyKSB7XG4gICAgICB2bS5fd2F0Y2hlci51cGRhdGUoKTtcbiAgICB9XG4gIH07XG5cbiAgVnVlLnByb3RvdHlwZS4kZGVzdHJveSA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgdm0gPSB0aGlzO1xuICAgIGlmICh2bS5faXNCZWluZ0Rlc3Ryb3llZCkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuICAgIGNhbGxIb29rKHZtLCAnYmVmb3JlRGVzdHJveScpO1xuICAgIHZtLl9pc0JlaW5nRGVzdHJveWVkID0gdHJ1ZTtcbiAgICAvLyByZW1vdmUgc2VsZiBmcm9tIHBhcmVudFxuICAgIHZhciBwYXJlbnQgPSB2bS4kcGFyZW50O1xuICAgIGlmIChwYXJlbnQgJiYgIXBhcmVudC5faXNCZWluZ0Rlc3Ryb3llZCAmJiAhdm0uJG9wdGlvbnMuYWJzdHJhY3QpIHtcbiAgICAgIHJlbW92ZShwYXJlbnQuJGNoaWxkcmVuLCB2bSk7XG4gICAgfVxuICAgIC8vIHRlYXJkb3duIHdhdGNoZXJzXG4gICAgaWYgKHZtLl93YXRjaGVyKSB7XG4gICAgICB2bS5fd2F0Y2hlci50ZWFyZG93bigpO1xuICAgIH1cbiAgICB2YXIgaSA9IHZtLl93YXRjaGVycy5sZW5ndGg7XG4gICAgd2hpbGUgKGktLSkge1xuICAgICAgdm0uX3dhdGNoZXJzW2ldLnRlYXJkb3duKCk7XG4gICAgfVxuICAgIC8vIHJlbW92ZSByZWZlcmVuY2UgZnJvbSBkYXRhIG9iXG4gICAgLy8gZnJvemVuIG9iamVjdCBtYXkgbm90IGhhdmUgb2JzZXJ2ZXIuXG4gICAgaWYgKHZtLl9kYXRhLl9fb2JfXykge1xuICAgICAgdm0uX2RhdGEuX19vYl9fLnZtQ291bnQtLTtcbiAgICB9XG4gICAgLy8gY2FsbCB0aGUgbGFzdCBob29rLi4uXG4gICAgdm0uX2lzRGVzdHJveWVkID0gdHJ1ZTtcbiAgICAvLyBpbnZva2UgZGVzdHJveSBob29rcyBvbiBjdXJyZW50IHJlbmRlcmVkIHRyZWVcbiAgICB2bS5fX3BhdGNoX18odm0uX3Zub2RlLCBudWxsKTtcbiAgICAvLyBmaXJlIGRlc3Ryb3llZCBob29rXG4gICAgY2FsbEhvb2sodm0sICdkZXN0cm95ZWQnKTtcbiAgICAvLyB0dXJuIG9mZiBhbGwgaW5zdGFuY2UgbGlzdGVuZXJzLlxuICAgIHZtLiRvZmYoKTtcbiAgICAvLyByZW1vdmUgX192dWVfXyByZWZlcmVuY2VcbiAgICBpZiAodm0uJGVsKSB7XG4gICAgICB2bS4kZWwuX192dWVfXyA9IG51bGw7XG4gICAgfVxuICAgIC8vIHJlbGVhc2UgY2lyY3VsYXIgcmVmZXJlbmNlICgjNjc1OSlcbiAgICBpZiAodm0uJHZub2RlKSB7XG4gICAgICB2bS4kdm5vZGUucGFyZW50ID0gbnVsbDtcbiAgICB9XG4gIH07XG59XG5cbmZ1bmN0aW9uIG1vdW50Q29tcG9uZW50IChcbiAgdm0sXG4gIGVsLFxuICBoeWRyYXRpbmdcbikge1xuICB2bS4kZWwgPSBlbDtcbiAgaWYgKCF2bS4kb3B0aW9ucy5yZW5kZXIpIHtcbiAgICB2bS4kb3B0aW9ucy5yZW5kZXIgPSBjcmVhdGVFbXB0eVZOb2RlO1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgIGlmICgodm0uJG9wdGlvbnMudGVtcGxhdGUgJiYgdm0uJG9wdGlvbnMudGVtcGxhdGUuY2hhckF0KDApICE9PSAnIycpIHx8XG4gICAgICAgIHZtLiRvcHRpb25zLmVsIHx8IGVsKSB7XG4gICAgICAgIHdhcm4oXG4gICAgICAgICAgJ1lvdSBhcmUgdXNpbmcgdGhlIHJ1bnRpbWUtb25seSBidWlsZCBvZiBWdWUgd2hlcmUgdGhlIHRlbXBsYXRlICcgK1xuICAgICAgICAgICdjb21waWxlciBpcyBub3QgYXZhaWxhYmxlLiBFaXRoZXIgcHJlLWNvbXBpbGUgdGhlIHRlbXBsYXRlcyBpbnRvICcgK1xuICAgICAgICAgICdyZW5kZXIgZnVuY3Rpb25zLCBvciB1c2UgdGhlIGNvbXBpbGVyLWluY2x1ZGVkIGJ1aWxkLicsXG4gICAgICAgICAgdm1cbiAgICAgICAgKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHdhcm4oXG4gICAgICAgICAgJ0ZhaWxlZCB0byBtb3VudCBjb21wb25lbnQ6IHRlbXBsYXRlIG9yIHJlbmRlciBmdW5jdGlvbiBub3QgZGVmaW5lZC4nLFxuICAgICAgICAgIHZtXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGNhbGxIb29rKHZtLCAnYmVmb3JlTW91bnQnKTtcblxuICB2YXIgdXBkYXRlQ29tcG9uZW50O1xuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgY29uZmlnLnBlcmZvcm1hbmNlICYmIG1hcmspIHtcbiAgICB1cGRhdGVDb21wb25lbnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgbmFtZSA9IHZtLl9uYW1lO1xuICAgICAgdmFyIGlkID0gdm0uX3VpZDtcbiAgICAgIHZhciBzdGFydFRhZyA9IFwidnVlLXBlcmYtc3RhcnQ6XCIgKyBpZDtcbiAgICAgIHZhciBlbmRUYWcgPSBcInZ1ZS1wZXJmLWVuZDpcIiArIGlkO1xuXG4gICAgICBtYXJrKHN0YXJ0VGFnKTtcbiAgICAgIHZhciB2bm9kZSA9IHZtLl9yZW5kZXIoKTtcbiAgICAgIG1hcmsoZW5kVGFnKTtcbiAgICAgIG1lYXN1cmUoKFwidnVlIFwiICsgbmFtZSArIFwiIHJlbmRlclwiKSwgc3RhcnRUYWcsIGVuZFRhZyk7XG5cbiAgICAgIG1hcmsoc3RhcnRUYWcpO1xuICAgICAgdm0uX3VwZGF0ZSh2bm9kZSwgaHlkcmF0aW5nKTtcbiAgICAgIG1hcmsoZW5kVGFnKTtcbiAgICAgIG1lYXN1cmUoKFwidnVlIFwiICsgbmFtZSArIFwiIHBhdGNoXCIpLCBzdGFydFRhZywgZW5kVGFnKTtcbiAgICB9O1xuICB9IGVsc2Uge1xuICAgIHVwZGF0ZUNvbXBvbmVudCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZtLl91cGRhdGUodm0uX3JlbmRlcigpLCBoeWRyYXRpbmcpO1xuICAgIH07XG4gIH1cblxuICAvLyB3ZSBzZXQgdGhpcyB0byB2bS5fd2F0Y2hlciBpbnNpZGUgdGhlIHdhdGNoZXIncyBjb25zdHJ1Y3RvclxuICAvLyBzaW5jZSB0aGUgd2F0Y2hlcidzIGluaXRpYWwgcGF0Y2ggbWF5IGNhbGwgJGZvcmNlVXBkYXRlIChlLmcuIGluc2lkZSBjaGlsZFxuICAvLyBjb21wb25lbnQncyBtb3VudGVkIGhvb2spLCB3aGljaCByZWxpZXMgb24gdm0uX3dhdGNoZXIgYmVpbmcgYWxyZWFkeSBkZWZpbmVkXG4gIG5ldyBXYXRjaGVyKHZtLCB1cGRhdGVDb21wb25lbnQsIG5vb3AsIHtcbiAgICBiZWZvcmU6IGZ1bmN0aW9uIGJlZm9yZSAoKSB7XG4gICAgICBpZiAodm0uX2lzTW91bnRlZCAmJiAhdm0uX2lzRGVzdHJveWVkKSB7XG4gICAgICAgIGNhbGxIb29rKHZtLCAnYmVmb3JlVXBkYXRlJyk7XG4gICAgICB9XG4gICAgfVxuICB9LCB0cnVlIC8qIGlzUmVuZGVyV2F0Y2hlciAqLyk7XG4gIGh5ZHJhdGluZyA9IGZhbHNlO1xuXG4gIC8vIG1hbnVhbGx5IG1vdW50ZWQgaW5zdGFuY2UsIGNhbGwgbW91bnRlZCBvbiBzZWxmXG4gIC8vIG1vdW50ZWQgaXMgY2FsbGVkIGZvciByZW5kZXItY3JlYXRlZCBjaGlsZCBjb21wb25lbnRzIGluIGl0cyBpbnNlcnRlZCBob29rXG4gIGlmICh2bS4kdm5vZGUgPT0gbnVsbCkge1xuICAgIHZtLl9pc01vdW50ZWQgPSB0cnVlO1xuICAgIGNhbGxIb29rKHZtLCAnbW91bnRlZCcpO1xuICB9XG4gIHJldHVybiB2bVxufVxuXG5mdW5jdGlvbiB1cGRhdGVDaGlsZENvbXBvbmVudCAoXG4gIHZtLFxuICBwcm9wc0RhdGEsXG4gIGxpc3RlbmVycyxcbiAgcGFyZW50Vm5vZGUsXG4gIHJlbmRlckNoaWxkcmVuXG4pIHtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICBpc1VwZGF0aW5nQ2hpbGRDb21wb25lbnQgPSB0cnVlO1xuICB9XG5cbiAgLy8gZGV0ZXJtaW5lIHdoZXRoZXIgY29tcG9uZW50IGhhcyBzbG90IGNoaWxkcmVuXG4gIC8vIHdlIG5lZWQgdG8gZG8gdGhpcyBiZWZvcmUgb3ZlcndyaXRpbmcgJG9wdGlvbnMuX3JlbmRlckNoaWxkcmVuLlxuXG4gIC8vIGNoZWNrIGlmIHRoZXJlIGFyZSBkeW5hbWljIHNjb3BlZFNsb3RzIChoYW5kLXdyaXR0ZW4gb3IgY29tcGlsZWQgYnV0IHdpdGhcbiAgLy8gZHluYW1pYyBzbG90IG5hbWVzKS4gU3RhdGljIHNjb3BlZCBzbG90cyBjb21waWxlZCBmcm9tIHRlbXBsYXRlIGhhcyB0aGVcbiAgLy8gXCIkc3RhYmxlXCIgbWFya2VyLlxuICB2YXIgbmV3U2NvcGVkU2xvdHMgPSBwYXJlbnRWbm9kZS5kYXRhLnNjb3BlZFNsb3RzO1xuICB2YXIgb2xkU2NvcGVkU2xvdHMgPSB2bS4kc2NvcGVkU2xvdHM7XG4gIHZhciBoYXNEeW5hbWljU2NvcGVkU2xvdCA9ICEhKFxuICAgIChuZXdTY29wZWRTbG90cyAmJiAhbmV3U2NvcGVkU2xvdHMuJHN0YWJsZSkgfHxcbiAgICAob2xkU2NvcGVkU2xvdHMgIT09IGVtcHR5T2JqZWN0ICYmICFvbGRTY29wZWRTbG90cy4kc3RhYmxlKSB8fFxuICAgIChuZXdTY29wZWRTbG90cyAmJiB2bS4kc2NvcGVkU2xvdHMuJGtleSAhPT0gbmV3U2NvcGVkU2xvdHMuJGtleSkgfHxcbiAgICAoIW5ld1Njb3BlZFNsb3RzICYmIHZtLiRzY29wZWRTbG90cy4ka2V5KVxuICApO1xuXG4gIC8vIEFueSBzdGF0aWMgc2xvdCBjaGlsZHJlbiBmcm9tIHRoZSBwYXJlbnQgbWF5IGhhdmUgY2hhbmdlZCBkdXJpbmcgcGFyZW50J3NcbiAgLy8gdXBkYXRlLiBEeW5hbWljIHNjb3BlZCBzbG90cyBtYXkgYWxzbyBoYXZlIGNoYW5nZWQuIEluIHN1Y2ggY2FzZXMsIGEgZm9yY2VkXG4gIC8vIHVwZGF0ZSBpcyBuZWNlc3NhcnkgdG8gZW5zdXJlIGNvcnJlY3RuZXNzLlxuICB2YXIgbmVlZHNGb3JjZVVwZGF0ZSA9ICEhKFxuICAgIHJlbmRlckNoaWxkcmVuIHx8ICAgICAgICAgICAgICAgLy8gaGFzIG5ldyBzdGF0aWMgc2xvdHNcbiAgICB2bS4kb3B0aW9ucy5fcmVuZGVyQ2hpbGRyZW4gfHwgIC8vIGhhcyBvbGQgc3RhdGljIHNsb3RzXG4gICAgaGFzRHluYW1pY1Njb3BlZFNsb3RcbiAgKTtcblxuICB2bS4kb3B0aW9ucy5fcGFyZW50Vm5vZGUgPSBwYXJlbnRWbm9kZTtcbiAgdm0uJHZub2RlID0gcGFyZW50Vm5vZGU7IC8vIHVwZGF0ZSB2bSdzIHBsYWNlaG9sZGVyIG5vZGUgd2l0aG91dCByZS1yZW5kZXJcblxuICBpZiAodm0uX3Zub2RlKSB7IC8vIHVwZGF0ZSBjaGlsZCB0cmVlJ3MgcGFyZW50XG4gICAgdm0uX3Zub2RlLnBhcmVudCA9IHBhcmVudFZub2RlO1xuICB9XG4gIHZtLiRvcHRpb25zLl9yZW5kZXJDaGlsZHJlbiA9IHJlbmRlckNoaWxkcmVuO1xuXG4gIC8vIHVwZGF0ZSAkYXR0cnMgYW5kICRsaXN0ZW5lcnMgaGFzaFxuICAvLyB0aGVzZSBhcmUgYWxzbyByZWFjdGl2ZSBzbyB0aGV5IG1heSB0cmlnZ2VyIGNoaWxkIHVwZGF0ZSBpZiB0aGUgY2hpbGRcbiAgLy8gdXNlZCB0aGVtIGR1cmluZyByZW5kZXJcbiAgdm0uJGF0dHJzID0gcGFyZW50Vm5vZGUuZGF0YS5hdHRycyB8fCBlbXB0eU9iamVjdDtcbiAgdm0uJGxpc3RlbmVycyA9IGxpc3RlbmVycyB8fCBlbXB0eU9iamVjdDtcblxuICAvLyB1cGRhdGUgcHJvcHNcbiAgaWYgKHByb3BzRGF0YSAmJiB2bS4kb3B0aW9ucy5wcm9wcykge1xuICAgIHRvZ2dsZU9ic2VydmluZyhmYWxzZSk7XG4gICAgdmFyIHByb3BzID0gdm0uX3Byb3BzO1xuICAgIHZhciBwcm9wS2V5cyA9IHZtLiRvcHRpb25zLl9wcm9wS2V5cyB8fCBbXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BLZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIga2V5ID0gcHJvcEtleXNbaV07XG4gICAgICB2YXIgcHJvcE9wdGlvbnMgPSB2bS4kb3B0aW9ucy5wcm9wczsgLy8gd3RmIGZsb3c/XG4gICAgICBwcm9wc1trZXldID0gdmFsaWRhdGVQcm9wKGtleSwgcHJvcE9wdGlvbnMsIHByb3BzRGF0YSwgdm0pO1xuICAgIH1cbiAgICB0b2dnbGVPYnNlcnZpbmcodHJ1ZSk7XG4gICAgLy8ga2VlcCBhIGNvcHkgb2YgcmF3IHByb3BzRGF0YVxuICAgIHZtLiRvcHRpb25zLnByb3BzRGF0YSA9IHByb3BzRGF0YTtcbiAgfVxuXG4gIC8vIHVwZGF0ZSBsaXN0ZW5lcnNcbiAgbGlzdGVuZXJzID0gbGlzdGVuZXJzIHx8IGVtcHR5T2JqZWN0O1xuICB2YXIgb2xkTGlzdGVuZXJzID0gdm0uJG9wdGlvbnMuX3BhcmVudExpc3RlbmVycztcbiAgdm0uJG9wdGlvbnMuX3BhcmVudExpc3RlbmVycyA9IGxpc3RlbmVycztcbiAgdXBkYXRlQ29tcG9uZW50TGlzdGVuZXJzKHZtLCBsaXN0ZW5lcnMsIG9sZExpc3RlbmVycyk7XG5cbiAgLy8gcmVzb2x2ZSBzbG90cyArIGZvcmNlIHVwZGF0ZSBpZiBoYXMgY2hpbGRyZW5cbiAgaWYgKG5lZWRzRm9yY2VVcGRhdGUpIHtcbiAgICB2bS4kc2xvdHMgPSByZXNvbHZlU2xvdHMocmVuZGVyQ2hpbGRyZW4sIHBhcmVudFZub2RlLmNvbnRleHQpO1xuICAgIHZtLiRmb3JjZVVwZGF0ZSgpO1xuICB9XG5cbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICBpc1VwZGF0aW5nQ2hpbGRDb21wb25lbnQgPSBmYWxzZTtcbiAgfVxufVxuXG5mdW5jdGlvbiBpc0luSW5hY3RpdmVUcmVlICh2bSkge1xuICB3aGlsZSAodm0gJiYgKHZtID0gdm0uJHBhcmVudCkpIHtcbiAgICBpZiAodm0uX2luYWN0aXZlKSB7IHJldHVybiB0cnVlIH1cbiAgfVxuICByZXR1cm4gZmFsc2Vcbn1cblxuZnVuY3Rpb24gYWN0aXZhdGVDaGlsZENvbXBvbmVudCAodm0sIGRpcmVjdCkge1xuICBpZiAoZGlyZWN0KSB7XG4gICAgdm0uX2RpcmVjdEluYWN0aXZlID0gZmFsc2U7XG4gICAgaWYgKGlzSW5JbmFjdGl2ZVRyZWUodm0pKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG4gIH0gZWxzZSBpZiAodm0uX2RpcmVjdEluYWN0aXZlKSB7XG4gICAgcmV0dXJuXG4gIH1cbiAgaWYgKHZtLl9pbmFjdGl2ZSB8fCB2bS5faW5hY3RpdmUgPT09IG51bGwpIHtcbiAgICB2bS5faW5hY3RpdmUgPSBmYWxzZTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHZtLiRjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgYWN0aXZhdGVDaGlsZENvbXBvbmVudCh2bS4kY2hpbGRyZW5baV0pO1xuICAgIH1cbiAgICBjYWxsSG9vayh2bSwgJ2FjdGl2YXRlZCcpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGRlYWN0aXZhdGVDaGlsZENvbXBvbmVudCAodm0sIGRpcmVjdCkge1xuICBpZiAoZGlyZWN0KSB7XG4gICAgdm0uX2RpcmVjdEluYWN0aXZlID0gdHJ1ZTtcbiAgICBpZiAoaXNJbkluYWN0aXZlVHJlZSh2bSkpIHtcbiAgICAgIHJldHVyblxuICAgIH1cbiAgfVxuICBpZiAoIXZtLl9pbmFjdGl2ZSkge1xuICAgIHZtLl9pbmFjdGl2ZSA9IHRydWU7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB2bS4kY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgIGRlYWN0aXZhdGVDaGlsZENvbXBvbmVudCh2bS4kY2hpbGRyZW5baV0pO1xuICAgIH1cbiAgICBjYWxsSG9vayh2bSwgJ2RlYWN0aXZhdGVkJyk7XG4gIH1cbn1cblxuZnVuY3Rpb24gY2FsbEhvb2sgKHZtLCBob29rKSB7XG4gIC8vICM3NTczIGRpc2FibGUgZGVwIGNvbGxlY3Rpb24gd2hlbiBpbnZva2luZyBsaWZlY3ljbGUgaG9va3NcbiAgcHVzaFRhcmdldCgpO1xuICB2YXIgaGFuZGxlcnMgPSB2bS4kb3B0aW9uc1tob29rXTtcbiAgdmFyIGluZm8gPSBob29rICsgXCIgaG9va1wiO1xuICBpZiAoaGFuZGxlcnMpIHtcbiAgICBmb3IgKHZhciBpID0gMCwgaiA9IGhhbmRsZXJzLmxlbmd0aDsgaSA8IGo7IGkrKykge1xuICAgICAgaW52b2tlV2l0aEVycm9ySGFuZGxpbmcoaGFuZGxlcnNbaV0sIHZtLCBudWxsLCB2bSwgaW5mbyk7XG4gICAgfVxuICB9XG4gIGlmICh2bS5faGFzSG9va0V2ZW50KSB7XG4gICAgdm0uJGVtaXQoJ2hvb2s6JyArIGhvb2spO1xuICB9XG4gIHBvcFRhcmdldCgpO1xufVxuXG4vKiAgKi9cblxudmFyIE1BWF9VUERBVEVfQ09VTlQgPSAxMDA7XG5cbnZhciBxdWV1ZSA9IFtdO1xudmFyIGFjdGl2YXRlZENoaWxkcmVuID0gW107XG52YXIgaGFzID0ge307XG52YXIgY2lyY3VsYXIgPSB7fTtcbnZhciB3YWl0aW5nID0gZmFsc2U7XG52YXIgZmx1c2hpbmcgPSBmYWxzZTtcbnZhciBpbmRleCA9IDA7XG5cbi8qKlxuICogUmVzZXQgdGhlIHNjaGVkdWxlcidzIHN0YXRlLlxuICovXG5mdW5jdGlvbiByZXNldFNjaGVkdWxlclN0YXRlICgpIHtcbiAgaW5kZXggPSBxdWV1ZS5sZW5ndGggPSBhY3RpdmF0ZWRDaGlsZHJlbi5sZW5ndGggPSAwO1xuICBoYXMgPSB7fTtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICBjaXJjdWxhciA9IHt9O1xuICB9XG4gIHdhaXRpbmcgPSBmbHVzaGluZyA9IGZhbHNlO1xufVxuXG4vLyBBc3luYyBlZGdlIGNhc2UgIzY1NjYgcmVxdWlyZXMgc2F2aW5nIHRoZSB0aW1lc3RhbXAgd2hlbiBldmVudCBsaXN0ZW5lcnMgYXJlXG4vLyBhdHRhY2hlZC4gSG93ZXZlciwgY2FsbGluZyBwZXJmb3JtYW5jZS5ub3coKSBoYXMgYSBwZXJmIG92ZXJoZWFkIGVzcGVjaWFsbHlcbi8vIGlmIHRoZSBwYWdlIGhhcyB0aG91c2FuZHMgb2YgZXZlbnQgbGlzdGVuZXJzLiBJbnN0ZWFkLCB3ZSB0YWtlIGEgdGltZXN0YW1wXG4vLyBldmVyeSB0aW1lIHRoZSBzY2hlZHVsZXIgZmx1c2hlcyBhbmQgdXNlIHRoYXQgZm9yIGFsbCBldmVudCBsaXN0ZW5lcnNcbi8vIGF0dGFjaGVkIGR1cmluZyB0aGF0IGZsdXNoLlxudmFyIGN1cnJlbnRGbHVzaFRpbWVzdGFtcCA9IDA7XG5cbi8vIEFzeW5jIGVkZ2UgY2FzZSBmaXggcmVxdWlyZXMgc3RvcmluZyBhbiBldmVudCBsaXN0ZW5lcidzIGF0dGFjaCB0aW1lc3RhbXAuXG52YXIgZ2V0Tm93ID0gRGF0ZS5ub3c7XG5cbi8vIERldGVybWluZSB3aGF0IGV2ZW50IHRpbWVzdGFtcCB0aGUgYnJvd3NlciBpcyB1c2luZy4gQW5ub3lpbmdseSwgdGhlXG4vLyB0aW1lc3RhbXAgY2FuIGVpdGhlciBiZSBoaS1yZXMgKHJlbGF0aXZlIHRvIHBhZ2UgbG9hZCkgb3IgbG93LXJlc1xuLy8gKHJlbGF0aXZlIHRvIFVOSVggZXBvY2gpLCBzbyBpbiBvcmRlciB0byBjb21wYXJlIHRpbWUgd2UgaGF2ZSB0byB1c2UgdGhlXG4vLyBzYW1lIHRpbWVzdGFtcCB0eXBlIHdoZW4gc2F2aW5nIHRoZSBmbHVzaCB0aW1lc3RhbXAuXG4vLyBBbGwgSUUgdmVyc2lvbnMgdXNlIGxvdy1yZXMgZXZlbnQgdGltZXN0YW1wcywgYW5kIGhhdmUgcHJvYmxlbWF0aWMgY2xvY2tcbi8vIGltcGxlbWVudGF0aW9ucyAoIzk2MzIpXG5pZiAoaW5Ccm93c2VyICYmICFpc0lFKSB7XG4gIHZhciBwZXJmb3JtYW5jZSA9IHdpbmRvdy5wZXJmb3JtYW5jZTtcbiAgaWYgKFxuICAgIHBlcmZvcm1hbmNlICYmXG4gICAgdHlwZW9mIHBlcmZvcm1hbmNlLm5vdyA9PT0gJ2Z1bmN0aW9uJyAmJlxuICAgIGdldE5vdygpID4gZG9jdW1lbnQuY3JlYXRlRXZlbnQoJ0V2ZW50JykudGltZVN0YW1wXG4gICkge1xuICAgIC8vIGlmIHRoZSBldmVudCB0aW1lc3RhbXAsIGFsdGhvdWdoIGV2YWx1YXRlZCBBRlRFUiB0aGUgRGF0ZS5ub3coKSwgaXNcbiAgICAvLyBzbWFsbGVyIHRoYW4gaXQsIGl0IG1lYW5zIHRoZSBldmVudCBpcyB1c2luZyBhIGhpLXJlcyB0aW1lc3RhbXAsXG4gICAgLy8gYW5kIHdlIG5lZWQgdG8gdXNlIHRoZSBoaS1yZXMgdmVyc2lvbiBmb3IgZXZlbnQgbGlzdGVuZXIgdGltZXN0YW1wcyBhc1xuICAgIC8vIHdlbGwuXG4gICAgZ2V0Tm93ID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gcGVyZm9ybWFuY2Uubm93KCk7IH07XG4gIH1cbn1cblxuLyoqXG4gKiBGbHVzaCBib3RoIHF1ZXVlcyBhbmQgcnVuIHRoZSB3YXRjaGVycy5cbiAqL1xuZnVuY3Rpb24gZmx1c2hTY2hlZHVsZXJRdWV1ZSAoKSB7XG4gIGN1cnJlbnRGbHVzaFRpbWVzdGFtcCA9IGdldE5vdygpO1xuICBmbHVzaGluZyA9IHRydWU7XG4gIHZhciB3YXRjaGVyLCBpZDtcblxuICAvLyBTb3J0IHF1ZXVlIGJlZm9yZSBmbHVzaC5cbiAgLy8gVGhpcyBlbnN1cmVzIHRoYXQ6XG4gIC8vIDEuIENvbXBvbmVudHMgYXJlIHVwZGF0ZWQgZnJvbSBwYXJlbnQgdG8gY2hpbGQuIChiZWNhdXNlIHBhcmVudCBpcyBhbHdheXNcbiAgLy8gICAgY3JlYXRlZCBiZWZvcmUgdGhlIGNoaWxkKVxuICAvLyAyLiBBIGNvbXBvbmVudCdzIHVzZXIgd2F0Y2hlcnMgYXJlIHJ1biBiZWZvcmUgaXRzIHJlbmRlciB3YXRjaGVyIChiZWNhdXNlXG4gIC8vICAgIHVzZXIgd2F0Y2hlcnMgYXJlIGNyZWF0ZWQgYmVmb3JlIHRoZSByZW5kZXIgd2F0Y2hlcilcbiAgLy8gMy4gSWYgYSBjb21wb25lbnQgaXMgZGVzdHJveWVkIGR1cmluZyBhIHBhcmVudCBjb21wb25lbnQncyB3YXRjaGVyIHJ1bixcbiAgLy8gICAgaXRzIHdhdGNoZXJzIGNhbiBiZSBza2lwcGVkLlxuICBxdWV1ZS5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7IHJldHVybiBhLmlkIC0gYi5pZDsgfSk7XG5cbiAgLy8gZG8gbm90IGNhY2hlIGxlbmd0aCBiZWNhdXNlIG1vcmUgd2F0Y2hlcnMgbWlnaHQgYmUgcHVzaGVkXG4gIC8vIGFzIHdlIHJ1biBleGlzdGluZyB3YXRjaGVyc1xuICBmb3IgKGluZGV4ID0gMDsgaW5kZXggPCBxdWV1ZS5sZW5ndGg7IGluZGV4KyspIHtcbiAgICB3YXRjaGVyID0gcXVldWVbaW5kZXhdO1xuICAgIGlmICh3YXRjaGVyLmJlZm9yZSkge1xuICAgICAgd2F0Y2hlci5iZWZvcmUoKTtcbiAgICB9XG4gICAgaWQgPSB3YXRjaGVyLmlkO1xuICAgIGhhc1tpZF0gPSBudWxsO1xuICAgIHdhdGNoZXIucnVuKCk7XG4gICAgLy8gaW4gZGV2IGJ1aWxkLCBjaGVjayBhbmQgc3RvcCBjaXJjdWxhciB1cGRhdGVzLlxuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIGhhc1tpZF0gIT0gbnVsbCkge1xuICAgICAgY2lyY3VsYXJbaWRdID0gKGNpcmN1bGFyW2lkXSB8fCAwKSArIDE7XG4gICAgICBpZiAoY2lyY3VsYXJbaWRdID4gTUFYX1VQREFURV9DT1VOVCkge1xuICAgICAgICB3YXJuKFxuICAgICAgICAgICdZb3UgbWF5IGhhdmUgYW4gaW5maW5pdGUgdXBkYXRlIGxvb3AgJyArIChcbiAgICAgICAgICAgIHdhdGNoZXIudXNlclxuICAgICAgICAgICAgICA/IChcImluIHdhdGNoZXIgd2l0aCBleHByZXNzaW9uIFxcXCJcIiArICh3YXRjaGVyLmV4cHJlc3Npb24pICsgXCJcXFwiXCIpXG4gICAgICAgICAgICAgIDogXCJpbiBhIGNvbXBvbmVudCByZW5kZXIgZnVuY3Rpb24uXCJcbiAgICAgICAgICApLFxuICAgICAgICAgIHdhdGNoZXIudm1cbiAgICAgICAgKTtcbiAgICAgICAgYnJlYWtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvLyBrZWVwIGNvcGllcyBvZiBwb3N0IHF1ZXVlcyBiZWZvcmUgcmVzZXR0aW5nIHN0YXRlXG4gIHZhciBhY3RpdmF0ZWRRdWV1ZSA9IGFjdGl2YXRlZENoaWxkcmVuLnNsaWNlKCk7XG4gIHZhciB1cGRhdGVkUXVldWUgPSBxdWV1ZS5zbGljZSgpO1xuXG4gIHJlc2V0U2NoZWR1bGVyU3RhdGUoKTtcblxuICAvLyBjYWxsIGNvbXBvbmVudCB1cGRhdGVkIGFuZCBhY3RpdmF0ZWQgaG9va3NcbiAgY2FsbEFjdGl2YXRlZEhvb2tzKGFjdGl2YXRlZFF1ZXVlKTtcbiAgY2FsbFVwZGF0ZWRIb29rcyh1cGRhdGVkUXVldWUpO1xuXG4gIC8vIGRldnRvb2wgaG9va1xuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgaWYgKGRldnRvb2xzICYmIGNvbmZpZy5kZXZ0b29scykge1xuICAgIGRldnRvb2xzLmVtaXQoJ2ZsdXNoJyk7XG4gIH1cbn1cblxuZnVuY3Rpb24gY2FsbFVwZGF0ZWRIb29rcyAocXVldWUpIHtcbiAgdmFyIGkgPSBxdWV1ZS5sZW5ndGg7XG4gIHdoaWxlIChpLS0pIHtcbiAgICB2YXIgd2F0Y2hlciA9IHF1ZXVlW2ldO1xuICAgIHZhciB2bSA9IHdhdGNoZXIudm07XG4gICAgaWYgKHZtLl93YXRjaGVyID09PSB3YXRjaGVyICYmIHZtLl9pc01vdW50ZWQgJiYgIXZtLl9pc0Rlc3Ryb3llZCkge1xuICAgICAgY2FsbEhvb2sodm0sICd1cGRhdGVkJyk7XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogUXVldWUgYSBrZXB0LWFsaXZlIGNvbXBvbmVudCB0aGF0IHdhcyBhY3RpdmF0ZWQgZHVyaW5nIHBhdGNoLlxuICogVGhlIHF1ZXVlIHdpbGwgYmUgcHJvY2Vzc2VkIGFmdGVyIHRoZSBlbnRpcmUgdHJlZSBoYXMgYmVlbiBwYXRjaGVkLlxuICovXG5mdW5jdGlvbiBxdWV1ZUFjdGl2YXRlZENvbXBvbmVudCAodm0pIHtcbiAgLy8gc2V0dGluZyBfaW5hY3RpdmUgdG8gZmFsc2UgaGVyZSBzbyB0aGF0IGEgcmVuZGVyIGZ1bmN0aW9uIGNhblxuICAvLyByZWx5IG9uIGNoZWNraW5nIHdoZXRoZXIgaXQncyBpbiBhbiBpbmFjdGl2ZSB0cmVlIChlLmcuIHJvdXRlci12aWV3KVxuICB2bS5faW5hY3RpdmUgPSBmYWxzZTtcbiAgYWN0aXZhdGVkQ2hpbGRyZW4ucHVzaCh2bSk7XG59XG5cbmZ1bmN0aW9uIGNhbGxBY3RpdmF0ZWRIb29rcyAocXVldWUpIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBxdWV1ZS5sZW5ndGg7IGkrKykge1xuICAgIHF1ZXVlW2ldLl9pbmFjdGl2ZSA9IHRydWU7XG4gICAgYWN0aXZhdGVDaGlsZENvbXBvbmVudChxdWV1ZVtpXSwgdHJ1ZSAvKiB0cnVlICovKTtcbiAgfVxufVxuXG4vKipcbiAqIFB1c2ggYSB3YXRjaGVyIGludG8gdGhlIHdhdGNoZXIgcXVldWUuXG4gKiBKb2JzIHdpdGggZHVwbGljYXRlIElEcyB3aWxsIGJlIHNraXBwZWQgdW5sZXNzIGl0J3NcbiAqIHB1c2hlZCB3aGVuIHRoZSBxdWV1ZSBpcyBiZWluZyBmbHVzaGVkLlxuICovXG5mdW5jdGlvbiBxdWV1ZVdhdGNoZXIgKHdhdGNoZXIpIHtcbiAgdmFyIGlkID0gd2F0Y2hlci5pZDtcbiAgaWYgKGhhc1tpZF0gPT0gbnVsbCkge1xuICAgIGhhc1tpZF0gPSB0cnVlO1xuICAgIGlmICghZmx1c2hpbmcpIHtcbiAgICAgIHF1ZXVlLnB1c2god2F0Y2hlcik7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGlmIGFscmVhZHkgZmx1c2hpbmcsIHNwbGljZSB0aGUgd2F0Y2hlciBiYXNlZCBvbiBpdHMgaWRcbiAgICAgIC8vIGlmIGFscmVhZHkgcGFzdCBpdHMgaWQsIGl0IHdpbGwgYmUgcnVuIG5leHQgaW1tZWRpYXRlbHkuXG4gICAgICB2YXIgaSA9IHF1ZXVlLmxlbmd0aCAtIDE7XG4gICAgICB3aGlsZSAoaSA+IGluZGV4ICYmIHF1ZXVlW2ldLmlkID4gd2F0Y2hlci5pZCkge1xuICAgICAgICBpLS07XG4gICAgICB9XG4gICAgICBxdWV1ZS5zcGxpY2UoaSArIDEsIDAsIHdhdGNoZXIpO1xuICAgIH1cbiAgICAvLyBxdWV1ZSB0aGUgZmx1c2hcbiAgICBpZiAoIXdhaXRpbmcpIHtcbiAgICAgIHdhaXRpbmcgPSB0cnVlO1xuXG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiAhY29uZmlnLmFzeW5jKSB7XG4gICAgICAgIGZsdXNoU2NoZWR1bGVyUXVldWUoKTtcbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG4gICAgICBuZXh0VGljayhmbHVzaFNjaGVkdWxlclF1ZXVlKTtcbiAgICB9XG4gIH1cbn1cblxuLyogICovXG5cblxuXG52YXIgdWlkJDIgPSAwO1xuXG4vKipcbiAqIEEgd2F0Y2hlciBwYXJzZXMgYW4gZXhwcmVzc2lvbiwgY29sbGVjdHMgZGVwZW5kZW5jaWVzLFxuICogYW5kIGZpcmVzIGNhbGxiYWNrIHdoZW4gdGhlIGV4cHJlc3Npb24gdmFsdWUgY2hhbmdlcy5cbiAqIFRoaXMgaXMgdXNlZCBmb3IgYm90aCB0aGUgJHdhdGNoKCkgYXBpIGFuZCBkaXJlY3RpdmVzLlxuICovXG52YXIgV2F0Y2hlciA9IGZ1bmN0aW9uIFdhdGNoZXIgKFxuICB2bSxcbiAgZXhwT3JGbixcbiAgY2IsXG4gIG9wdGlvbnMsXG4gIGlzUmVuZGVyV2F0Y2hlclxuKSB7XG4gIHRoaXMudm0gPSB2bTtcbiAgaWYgKGlzUmVuZGVyV2F0Y2hlcikge1xuICAgIHZtLl93YXRjaGVyID0gdGhpcztcbiAgfVxuICB2bS5fd2F0Y2hlcnMucHVzaCh0aGlzKTtcbiAgLy8gb3B0aW9uc1xuICBpZiAob3B0aW9ucykge1xuICAgIHRoaXMuZGVlcCA9ICEhb3B0aW9ucy5kZWVwO1xuICAgIHRoaXMudXNlciA9ICEhb3B0aW9ucy51c2VyO1xuICAgIHRoaXMubGF6eSA9ICEhb3B0aW9ucy5sYXp5O1xuICAgIHRoaXMuc3luYyA9ICEhb3B0aW9ucy5zeW5jO1xuICAgIHRoaXMuYmVmb3JlID0gb3B0aW9ucy5iZWZvcmU7XG4gIH0gZWxzZSB7XG4gICAgdGhpcy5kZWVwID0gdGhpcy51c2VyID0gdGhpcy5sYXp5ID0gdGhpcy5zeW5jID0gZmFsc2U7XG4gIH1cbiAgdGhpcy5jYiA9IGNiO1xuICB0aGlzLmlkID0gKyt1aWQkMjsgLy8gdWlkIGZvciBiYXRjaGluZ1xuICB0aGlzLmFjdGl2ZSA9IHRydWU7XG4gIHRoaXMuZGlydHkgPSB0aGlzLmxhenk7IC8vIGZvciBsYXp5IHdhdGNoZXJzXG4gIHRoaXMuZGVwcyA9IFtdO1xuICB0aGlzLm5ld0RlcHMgPSBbXTtcbiAgdGhpcy5kZXBJZHMgPSBuZXcgX1NldCgpO1xuICB0aGlzLm5ld0RlcElkcyA9IG5ldyBfU2V0KCk7XG4gIHRoaXMuZXhwcmVzc2lvbiA9IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbidcbiAgICA/IGV4cE9yRm4udG9TdHJpbmcoKVxuICAgIDogJyc7XG4gIC8vIHBhcnNlIGV4cHJlc3Npb24gZm9yIGdldHRlclxuICBpZiAodHlwZW9mIGV4cE9yRm4gPT09ICdmdW5jdGlvbicpIHtcbiAgICB0aGlzLmdldHRlciA9IGV4cE9yRm47XG4gIH0gZWxzZSB7XG4gICAgdGhpcy5nZXR0ZXIgPSBwYXJzZVBhdGgoZXhwT3JGbik7XG4gICAgaWYgKCF0aGlzLmdldHRlcikge1xuICAgICAgdGhpcy5nZXR0ZXIgPSBub29wO1xuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiB3YXJuKFxuICAgICAgICBcIkZhaWxlZCB3YXRjaGluZyBwYXRoOiBcXFwiXCIgKyBleHBPckZuICsgXCJcXFwiIFwiICtcbiAgICAgICAgJ1dhdGNoZXIgb25seSBhY2NlcHRzIHNpbXBsZSBkb3QtZGVsaW1pdGVkIHBhdGhzLiAnICtcbiAgICAgICAgJ0ZvciBmdWxsIGNvbnRyb2wsIHVzZSBhIGZ1bmN0aW9uIGluc3RlYWQuJyxcbiAgICAgICAgdm1cbiAgICAgICk7XG4gICAgfVxuICB9XG4gIHRoaXMudmFsdWUgPSB0aGlzLmxhenlcbiAgICA/IHVuZGVmaW5lZFxuICAgIDogdGhpcy5nZXQoKTtcbn07XG5cbi8qKlxuICogRXZhbHVhdGUgdGhlIGdldHRlciwgYW5kIHJlLWNvbGxlY3QgZGVwZW5kZW5jaWVzLlxuICovXG5XYXRjaGVyLnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbiBnZXQgKCkge1xuICBwdXNoVGFyZ2V0KHRoaXMpO1xuICB2YXIgdmFsdWU7XG4gIHZhciB2bSA9IHRoaXMudm07XG4gIHRyeSB7XG4gICAgdmFsdWUgPSB0aGlzLmdldHRlci5jYWxsKHZtLCB2bSk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICBpZiAodGhpcy51c2VyKSB7XG4gICAgICBoYW5kbGVFcnJvcihlLCB2bSwgKFwiZ2V0dGVyIGZvciB3YXRjaGVyIFxcXCJcIiArICh0aGlzLmV4cHJlc3Npb24pICsgXCJcXFwiXCIpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgZVxuICAgIH1cbiAgfSBmaW5hbGx5IHtcbiAgICAvLyBcInRvdWNoXCIgZXZlcnkgcHJvcGVydHkgc28gdGhleSBhcmUgYWxsIHRyYWNrZWQgYXNcbiAgICAvLyBkZXBlbmRlbmNpZXMgZm9yIGRlZXAgd2F0Y2hpbmdcbiAgICBpZiAodGhpcy5kZWVwKSB7XG4gICAgICB0cmF2ZXJzZSh2YWx1ZSk7XG4gICAgfVxuICAgIHBvcFRhcmdldCgpO1xuICAgIHRoaXMuY2xlYW51cERlcHMoKTtcbiAgfVxuICByZXR1cm4gdmFsdWVcbn07XG5cbi8qKlxuICogQWRkIGEgZGVwZW5kZW5jeSB0byB0aGlzIGRpcmVjdGl2ZS5cbiAqL1xuV2F0Y2hlci5wcm90b3R5cGUuYWRkRGVwID0gZnVuY3Rpb24gYWRkRGVwIChkZXApIHtcbiAgdmFyIGlkID0gZGVwLmlkO1xuICBpZiAoIXRoaXMubmV3RGVwSWRzLmhhcyhpZCkpIHtcbiAgICB0aGlzLm5ld0RlcElkcy5hZGQoaWQpO1xuICAgIHRoaXMubmV3RGVwcy5wdXNoKGRlcCk7XG4gICAgaWYgKCF0aGlzLmRlcElkcy5oYXMoaWQpKSB7XG4gICAgICBkZXAuYWRkU3ViKHRoaXMpO1xuICAgIH1cbiAgfVxufTtcblxuLyoqXG4gKiBDbGVhbiB1cCBmb3IgZGVwZW5kZW5jeSBjb2xsZWN0aW9uLlxuICovXG5XYXRjaGVyLnByb3RvdHlwZS5jbGVhbnVwRGVwcyA9IGZ1bmN0aW9uIGNsZWFudXBEZXBzICgpIHtcbiAgdmFyIGkgPSB0aGlzLmRlcHMubGVuZ3RoO1xuICB3aGlsZSAoaS0tKSB7XG4gICAgdmFyIGRlcCA9IHRoaXMuZGVwc1tpXTtcbiAgICBpZiAoIXRoaXMubmV3RGVwSWRzLmhhcyhkZXAuaWQpKSB7XG4gICAgICBkZXAucmVtb3ZlU3ViKHRoaXMpO1xuICAgIH1cbiAgfVxuICB2YXIgdG1wID0gdGhpcy5kZXBJZHM7XG4gIHRoaXMuZGVwSWRzID0gdGhpcy5uZXdEZXBJZHM7XG4gIHRoaXMubmV3RGVwSWRzID0gdG1wO1xuICB0aGlzLm5ld0RlcElkcy5jbGVhcigpO1xuICB0bXAgPSB0aGlzLmRlcHM7XG4gIHRoaXMuZGVwcyA9IHRoaXMubmV3RGVwcztcbiAgdGhpcy5uZXdEZXBzID0gdG1wO1xuICB0aGlzLm5ld0RlcHMubGVuZ3RoID0gMDtcbn07XG5cbi8qKlxuICogU3Vic2NyaWJlciBpbnRlcmZhY2UuXG4gKiBXaWxsIGJlIGNhbGxlZCB3aGVuIGEgZGVwZW5kZW5jeSBjaGFuZ2VzLlxuICovXG5XYXRjaGVyLnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbiB1cGRhdGUgKCkge1xuICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICBpZiAodGhpcy5sYXp5KSB7XG4gICAgdGhpcy5kaXJ0eSA9IHRydWU7XG4gIH0gZWxzZSBpZiAodGhpcy5zeW5jKSB7XG4gICAgdGhpcy5ydW4oKTtcbiAgfSBlbHNlIHtcbiAgICBxdWV1ZVdhdGNoZXIodGhpcyk7XG4gIH1cbn07XG5cbi8qKlxuICogU2NoZWR1bGVyIGpvYiBpbnRlcmZhY2UuXG4gKiBXaWxsIGJlIGNhbGxlZCBieSB0aGUgc2NoZWR1bGVyLlxuICovXG5XYXRjaGVyLnByb3RvdHlwZS5ydW4gPSBmdW5jdGlvbiBydW4gKCkge1xuICBpZiAodGhpcy5hY3RpdmUpIHtcbiAgICB2YXIgdmFsdWUgPSB0aGlzLmdldCgpO1xuICAgIGlmIChcbiAgICAgIHZhbHVlICE9PSB0aGlzLnZhbHVlIHx8XG4gICAgICAvLyBEZWVwIHdhdGNoZXJzIGFuZCB3YXRjaGVycyBvbiBPYmplY3QvQXJyYXlzIHNob3VsZCBmaXJlIGV2ZW5cbiAgICAgIC8vIHdoZW4gdGhlIHZhbHVlIGlzIHRoZSBzYW1lLCBiZWNhdXNlIHRoZSB2YWx1ZSBtYXlcbiAgICAgIC8vIGhhdmUgbXV0YXRlZC5cbiAgICAgIGlzT2JqZWN0KHZhbHVlKSB8fFxuICAgICAgdGhpcy5kZWVwXG4gICAgKSB7XG4gICAgICAvLyBzZXQgbmV3IHZhbHVlXG4gICAgICB2YXIgb2xkVmFsdWUgPSB0aGlzLnZhbHVlO1xuICAgICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICAgICAgaWYgKHRoaXMudXNlcikge1xuICAgICAgICB2YXIgaW5mbyA9IFwiY2FsbGJhY2sgZm9yIHdhdGNoZXIgXFxcIlwiICsgKHRoaXMuZXhwcmVzc2lvbikgKyBcIlxcXCJcIjtcbiAgICAgICAgaW52b2tlV2l0aEVycm9ySGFuZGxpbmcodGhpcy5jYiwgdGhpcy52bSwgW3ZhbHVlLCBvbGRWYWx1ZV0sIHRoaXMudm0sIGluZm8pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5jYi5jYWxsKHRoaXMudm0sIHZhbHVlLCBvbGRWYWx1ZSk7XG4gICAgICB9XG4gICAgfVxuICB9XG59O1xuXG4vKipcbiAqIEV2YWx1YXRlIHRoZSB2YWx1ZSBvZiB0aGUgd2F0Y2hlci5cbiAqIFRoaXMgb25seSBnZXRzIGNhbGxlZCBmb3IgbGF6eSB3YXRjaGVycy5cbiAqL1xuV2F0Y2hlci5wcm90b3R5cGUuZXZhbHVhdGUgPSBmdW5jdGlvbiBldmFsdWF0ZSAoKSB7XG4gIHRoaXMudmFsdWUgPSB0aGlzLmdldCgpO1xuICB0aGlzLmRpcnR5ID0gZmFsc2U7XG59O1xuXG4vKipcbiAqIERlcGVuZCBvbiBhbGwgZGVwcyBjb2xsZWN0ZWQgYnkgdGhpcyB3YXRjaGVyLlxuICovXG5XYXRjaGVyLnByb3RvdHlwZS5kZXBlbmQgPSBmdW5jdGlvbiBkZXBlbmQgKCkge1xuICB2YXIgaSA9IHRoaXMuZGVwcy5sZW5ndGg7XG4gIHdoaWxlIChpLS0pIHtcbiAgICB0aGlzLmRlcHNbaV0uZGVwZW5kKCk7XG4gIH1cbn07XG5cbi8qKlxuICogUmVtb3ZlIHNlbGYgZnJvbSBhbGwgZGVwZW5kZW5jaWVzJyBzdWJzY3JpYmVyIGxpc3QuXG4gKi9cbldhdGNoZXIucHJvdG90eXBlLnRlYXJkb3duID0gZnVuY3Rpb24gdGVhcmRvd24gKCkge1xuICBpZiAodGhpcy5hY3RpdmUpIHtcbiAgICAvLyByZW1vdmUgc2VsZiBmcm9tIHZtJ3Mgd2F0Y2hlciBsaXN0XG4gICAgLy8gdGhpcyBpcyBhIHNvbWV3aGF0IGV4cGVuc2l2ZSBvcGVyYXRpb24gc28gd2Ugc2tpcCBpdFxuICAgIC8vIGlmIHRoZSB2bSBpcyBiZWluZyBkZXN0cm95ZWQuXG4gICAgaWYgKCF0aGlzLnZtLl9pc0JlaW5nRGVzdHJveWVkKSB7XG4gICAgICByZW1vdmUodGhpcy52bS5fd2F0Y2hlcnMsIHRoaXMpO1xuICAgIH1cbiAgICB2YXIgaSA9IHRoaXMuZGVwcy5sZW5ndGg7XG4gICAgd2hpbGUgKGktLSkge1xuICAgICAgdGhpcy5kZXBzW2ldLnJlbW92ZVN1Yih0aGlzKTtcbiAgICB9XG4gICAgdGhpcy5hY3RpdmUgPSBmYWxzZTtcbiAgfVxufTtcblxuLyogICovXG5cbnZhciBzaGFyZWRQcm9wZXJ0eURlZmluaXRpb24gPSB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBub29wLFxuICBzZXQ6IG5vb3Bcbn07XG5cbmZ1bmN0aW9uIHByb3h5ICh0YXJnZXQsIHNvdXJjZUtleSwga2V5KSB7XG4gIHNoYXJlZFByb3BlcnR5RGVmaW5pdGlvbi5nZXQgPSBmdW5jdGlvbiBwcm94eUdldHRlciAoKSB7XG4gICAgcmV0dXJuIHRoaXNbc291cmNlS2V5XVtrZXldXG4gIH07XG4gIHNoYXJlZFByb3BlcnR5RGVmaW5pdGlvbi5zZXQgPSBmdW5jdGlvbiBwcm94eVNldHRlciAodmFsKSB7XG4gICAgdGhpc1tzb3VyY2VLZXldW2tleV0gPSB2YWw7XG4gIH07XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgc2hhcmVkUHJvcGVydHlEZWZpbml0aW9uKTtcbn1cblxuZnVuY3Rpb24gaW5pdFN0YXRlICh2bSkge1xuICB2bS5fd2F0Y2hlcnMgPSBbXTtcbiAgdmFyIG9wdHMgPSB2bS4kb3B0aW9ucztcbiAgaWYgKG9wdHMucHJvcHMpIHsgaW5pdFByb3BzKHZtLCBvcHRzLnByb3BzKTsgfVxuICBpZiAob3B0cy5tZXRob2RzKSB7IGluaXRNZXRob2RzKHZtLCBvcHRzLm1ldGhvZHMpOyB9XG4gIGlmIChvcHRzLmRhdGEpIHtcbiAgICBpbml0RGF0YSh2bSk7XG4gIH0gZWxzZSB7XG4gICAgb2JzZXJ2ZSh2bS5fZGF0YSA9IHt9LCB0cnVlIC8qIGFzUm9vdERhdGEgKi8pO1xuICB9XG4gIGlmIChvcHRzLmNvbXB1dGVkKSB7IGluaXRDb21wdXRlZCh2bSwgb3B0cy5jb21wdXRlZCk7IH1cbiAgaWYgKG9wdHMud2F0Y2ggJiYgb3B0cy53YXRjaCAhPT0gbmF0aXZlV2F0Y2gpIHtcbiAgICBpbml0V2F0Y2godm0sIG9wdHMud2F0Y2gpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGluaXRQcm9wcyAodm0sIHByb3BzT3B0aW9ucykge1xuICB2YXIgcHJvcHNEYXRhID0gdm0uJG9wdGlvbnMucHJvcHNEYXRhIHx8IHt9O1xuICB2YXIgcHJvcHMgPSB2bS5fcHJvcHMgPSB7fTtcbiAgLy8gY2FjaGUgcHJvcCBrZXlzIHNvIHRoYXQgZnV0dXJlIHByb3BzIHVwZGF0ZXMgY2FuIGl0ZXJhdGUgdXNpbmcgQXJyYXlcbiAgLy8gaW5zdGVhZCBvZiBkeW5hbWljIG9iamVjdCBrZXkgZW51bWVyYXRpb24uXG4gIHZhciBrZXlzID0gdm0uJG9wdGlvbnMuX3Byb3BLZXlzID0gW107XG4gIHZhciBpc1Jvb3QgPSAhdm0uJHBhcmVudDtcbiAgLy8gcm9vdCBpbnN0YW5jZSBwcm9wcyBzaG91bGQgYmUgY29udmVydGVkXG4gIGlmICghaXNSb290KSB7XG4gICAgdG9nZ2xlT2JzZXJ2aW5nKGZhbHNlKTtcbiAgfVxuICB2YXIgbG9vcCA9IGZ1bmN0aW9uICgga2V5ICkge1xuICAgIGtleXMucHVzaChrZXkpO1xuICAgIHZhciB2YWx1ZSA9IHZhbGlkYXRlUHJvcChrZXksIHByb3BzT3B0aW9ucywgcHJvcHNEYXRhLCB2bSk7XG4gICAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgdmFyIGh5cGhlbmF0ZWRLZXkgPSBoeXBoZW5hdGUoa2V5KTtcbiAgICAgIGlmIChpc1Jlc2VydmVkQXR0cmlidXRlKGh5cGhlbmF0ZWRLZXkpIHx8XG4gICAgICAgICAgY29uZmlnLmlzUmVzZXJ2ZWRBdHRyKGh5cGhlbmF0ZWRLZXkpKSB7XG4gICAgICAgIHdhcm4oXG4gICAgICAgICAgKFwiXFxcIlwiICsgaHlwaGVuYXRlZEtleSArIFwiXFxcIiBpcyBhIHJlc2VydmVkIGF0dHJpYnV0ZSBhbmQgY2Fubm90IGJlIHVzZWQgYXMgY29tcG9uZW50IHByb3AuXCIpLFxuICAgICAgICAgIHZtXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICBkZWZpbmVSZWFjdGl2ZSQkMShwcm9wcywga2V5LCB2YWx1ZSwgZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoIWlzUm9vdCAmJiAhaXNVcGRhdGluZ0NoaWxkQ29tcG9uZW50KSB7XG4gICAgICAgICAgd2FybihcbiAgICAgICAgICAgIFwiQXZvaWQgbXV0YXRpbmcgYSBwcm9wIGRpcmVjdGx5IHNpbmNlIHRoZSB2YWx1ZSB3aWxsIGJlIFwiICtcbiAgICAgICAgICAgIFwib3ZlcndyaXR0ZW4gd2hlbmV2ZXIgdGhlIHBhcmVudCBjb21wb25lbnQgcmUtcmVuZGVycy4gXCIgK1xuICAgICAgICAgICAgXCJJbnN0ZWFkLCB1c2UgYSBkYXRhIG9yIGNvbXB1dGVkIHByb3BlcnR5IGJhc2VkIG9uIHRoZSBwcm9wJ3MgXCIgK1xuICAgICAgICAgICAgXCJ2YWx1ZS4gUHJvcCBiZWluZyBtdXRhdGVkOiBcXFwiXCIgKyBrZXkgKyBcIlxcXCJcIixcbiAgICAgICAgICAgIHZtXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGRlZmluZVJlYWN0aXZlJCQxKHByb3BzLCBrZXksIHZhbHVlKTtcbiAgICB9XG4gICAgLy8gc3RhdGljIHByb3BzIGFyZSBhbHJlYWR5IHByb3hpZWQgb24gdGhlIGNvbXBvbmVudCdzIHByb3RvdHlwZVxuICAgIC8vIGR1cmluZyBWdWUuZXh0ZW5kKCkuIFdlIG9ubHkgbmVlZCB0byBwcm94eSBwcm9wcyBkZWZpbmVkIGF0XG4gICAgLy8gaW5zdGFudGlhdGlvbiBoZXJlLlxuICAgIGlmICghKGtleSBpbiB2bSkpIHtcbiAgICAgIHByb3h5KHZtLCBcIl9wcm9wc1wiLCBrZXkpO1xuICAgIH1cbiAgfTtcblxuICBmb3IgKHZhciBrZXkgaW4gcHJvcHNPcHRpb25zKSBsb29wKCBrZXkgKTtcbiAgdG9nZ2xlT2JzZXJ2aW5nKHRydWUpO1xufVxuXG5mdW5jdGlvbiBpbml0RGF0YSAodm0pIHtcbiAgdmFyIGRhdGEgPSB2bS4kb3B0aW9ucy5kYXRhO1xuICBkYXRhID0gdm0uX2RhdGEgPSB0eXBlb2YgZGF0YSA9PT0gJ2Z1bmN0aW9uJ1xuICAgID8gZ2V0RGF0YShkYXRhLCB2bSlcbiAgICA6IGRhdGEgfHwge307XG4gIGlmICghaXNQbGFpbk9iamVjdChkYXRhKSkge1xuICAgIGRhdGEgPSB7fTtcbiAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIHdhcm4oXG4gICAgICAnZGF0YSBmdW5jdGlvbnMgc2hvdWxkIHJldHVybiBhbiBvYmplY3Q6XFxuJyArXG4gICAgICAnaHR0cHM6Ly92dWVqcy5vcmcvdjIvZ3VpZGUvY29tcG9uZW50cy5odG1sI2RhdGEtTXVzdC1CZS1hLUZ1bmN0aW9uJyxcbiAgICAgIHZtXG4gICAgKTtcbiAgfVxuICAvLyBwcm94eSBkYXRhIG9uIGluc3RhbmNlXG4gIHZhciBrZXlzID0gT2JqZWN0LmtleXMoZGF0YSk7XG4gIHZhciBwcm9wcyA9IHZtLiRvcHRpb25zLnByb3BzO1xuICB2YXIgbWV0aG9kcyA9IHZtLiRvcHRpb25zLm1ldGhvZHM7XG4gIHZhciBpID0ga2V5cy5sZW5ndGg7XG4gIHdoaWxlIChpLS0pIHtcbiAgICB2YXIga2V5ID0ga2V5c1tpXTtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgaWYgKG1ldGhvZHMgJiYgaGFzT3duKG1ldGhvZHMsIGtleSkpIHtcbiAgICAgICAgd2FybihcbiAgICAgICAgICAoXCJNZXRob2QgXFxcIlwiICsga2V5ICsgXCJcXFwiIGhhcyBhbHJlYWR5IGJlZW4gZGVmaW5lZCBhcyBhIGRhdGEgcHJvcGVydHkuXCIpLFxuICAgICAgICAgIHZtXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChwcm9wcyAmJiBoYXNPd24ocHJvcHMsIGtleSkpIHtcbiAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgd2FybihcbiAgICAgICAgXCJUaGUgZGF0YSBwcm9wZXJ0eSBcXFwiXCIgKyBrZXkgKyBcIlxcXCIgaXMgYWxyZWFkeSBkZWNsYXJlZCBhcyBhIHByb3AuIFwiICtcbiAgICAgICAgXCJVc2UgcHJvcCBkZWZhdWx0IHZhbHVlIGluc3RlYWQuXCIsXG4gICAgICAgIHZtXG4gICAgICApO1xuICAgIH0gZWxzZSBpZiAoIWlzUmVzZXJ2ZWQoa2V5KSkge1xuICAgICAgcHJveHkodm0sIFwiX2RhdGFcIiwga2V5KTtcbiAgICB9XG4gIH1cbiAgLy8gb2JzZXJ2ZSBkYXRhXG4gIG9ic2VydmUoZGF0YSwgdHJ1ZSAvKiBhc1Jvb3REYXRhICovKTtcbn1cblxuZnVuY3Rpb24gZ2V0RGF0YSAoZGF0YSwgdm0pIHtcbiAgLy8gIzc1NzMgZGlzYWJsZSBkZXAgY29sbGVjdGlvbiB3aGVuIGludm9raW5nIGRhdGEgZ2V0dGVyc1xuICBwdXNoVGFyZ2V0KCk7XG4gIHRyeSB7XG4gICAgcmV0dXJuIGRhdGEuY2FsbCh2bSwgdm0pXG4gIH0gY2F0Y2ggKGUpIHtcbiAgICBoYW5kbGVFcnJvcihlLCB2bSwgXCJkYXRhKClcIik7XG4gICAgcmV0dXJuIHt9XG4gIH0gZmluYWxseSB7XG4gICAgcG9wVGFyZ2V0KCk7XG4gIH1cbn1cblxudmFyIGNvbXB1dGVkV2F0Y2hlck9wdGlvbnMgPSB7IGxhenk6IHRydWUgfTtcblxuZnVuY3Rpb24gaW5pdENvbXB1dGVkICh2bSwgY29tcHV0ZWQpIHtcbiAgLy8gJGZsb3ctZGlzYWJsZS1saW5lXG4gIHZhciB3YXRjaGVycyA9IHZtLl9jb21wdXRlZFdhdGNoZXJzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgLy8gY29tcHV0ZWQgcHJvcGVydGllcyBhcmUganVzdCBnZXR0ZXJzIGR1cmluZyBTU1JcbiAgdmFyIGlzU1NSID0gaXNTZXJ2ZXJSZW5kZXJpbmcoKTtcblxuICBmb3IgKHZhciBrZXkgaW4gY29tcHV0ZWQpIHtcbiAgICB2YXIgdXNlckRlZiA9IGNvbXB1dGVkW2tleV07XG4gICAgdmFyIGdldHRlciA9IHR5cGVvZiB1c2VyRGVmID09PSAnZnVuY3Rpb24nID8gdXNlckRlZiA6IHVzZXJEZWYuZ2V0O1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIGdldHRlciA9PSBudWxsKSB7XG4gICAgICB3YXJuKFxuICAgICAgICAoXCJHZXR0ZXIgaXMgbWlzc2luZyBmb3IgY29tcHV0ZWQgcHJvcGVydHkgXFxcIlwiICsga2V5ICsgXCJcXFwiLlwiKSxcbiAgICAgICAgdm1cbiAgICAgICk7XG4gICAgfVxuXG4gICAgaWYgKCFpc1NTUikge1xuICAgICAgLy8gY3JlYXRlIGludGVybmFsIHdhdGNoZXIgZm9yIHRoZSBjb21wdXRlZCBwcm9wZXJ0eS5cbiAgICAgIHdhdGNoZXJzW2tleV0gPSBuZXcgV2F0Y2hlcihcbiAgICAgICAgdm0sXG4gICAgICAgIGdldHRlciB8fCBub29wLFxuICAgICAgICBub29wLFxuICAgICAgICBjb21wdXRlZFdhdGNoZXJPcHRpb25zXG4gICAgICApO1xuICAgIH1cblxuICAgIC8vIGNvbXBvbmVudC1kZWZpbmVkIGNvbXB1dGVkIHByb3BlcnRpZXMgYXJlIGFscmVhZHkgZGVmaW5lZCBvbiB0aGVcbiAgICAvLyBjb21wb25lbnQgcHJvdG90eXBlLiBXZSBvbmx5IG5lZWQgdG8gZGVmaW5lIGNvbXB1dGVkIHByb3BlcnRpZXMgZGVmaW5lZFxuICAgIC8vIGF0IGluc3RhbnRpYXRpb24gaGVyZS5cbiAgICBpZiAoIShrZXkgaW4gdm0pKSB7XG4gICAgICBkZWZpbmVDb21wdXRlZCh2bSwga2V5LCB1c2VyRGVmKTtcbiAgICB9IGVsc2UgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIGlmIChrZXkgaW4gdm0uJGRhdGEpIHtcbiAgICAgICAgd2FybigoXCJUaGUgY29tcHV0ZWQgcHJvcGVydHkgXFxcIlwiICsga2V5ICsgXCJcXFwiIGlzIGFscmVhZHkgZGVmaW5lZCBpbiBkYXRhLlwiKSwgdm0pO1xuICAgICAgfSBlbHNlIGlmICh2bS4kb3B0aW9ucy5wcm9wcyAmJiBrZXkgaW4gdm0uJG9wdGlvbnMucHJvcHMpIHtcbiAgICAgICAgd2FybigoXCJUaGUgY29tcHV0ZWQgcHJvcGVydHkgXFxcIlwiICsga2V5ICsgXCJcXFwiIGlzIGFscmVhZHkgZGVmaW5lZCBhcyBhIHByb3AuXCIpLCB2bSk7XG4gICAgICB9IGVsc2UgaWYgKHZtLiRvcHRpb25zLm1ldGhvZHMgJiYga2V5IGluIHZtLiRvcHRpb25zLm1ldGhvZHMpIHtcbiAgICAgICAgd2FybigoXCJUaGUgY29tcHV0ZWQgcHJvcGVydHkgXFxcIlwiICsga2V5ICsgXCJcXFwiIGlzIGFscmVhZHkgZGVmaW5lZCBhcyBhIG1ldGhvZC5cIiksIHZtKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gZGVmaW5lQ29tcHV0ZWQgKFxuICB0YXJnZXQsXG4gIGtleSxcbiAgdXNlckRlZlxuKSB7XG4gIHZhciBzaG91bGRDYWNoZSA9ICFpc1NlcnZlclJlbmRlcmluZygpO1xuICBpZiAodHlwZW9mIHVzZXJEZWYgPT09ICdmdW5jdGlvbicpIHtcbiAgICBzaGFyZWRQcm9wZXJ0eURlZmluaXRpb24uZ2V0ID0gc2hvdWxkQ2FjaGVcbiAgICAgID8gY3JlYXRlQ29tcHV0ZWRHZXR0ZXIoa2V5KVxuICAgICAgOiBjcmVhdGVHZXR0ZXJJbnZva2VyKHVzZXJEZWYpO1xuICAgIHNoYXJlZFByb3BlcnR5RGVmaW5pdGlvbi5zZXQgPSBub29wO1xuICB9IGVsc2Uge1xuICAgIHNoYXJlZFByb3BlcnR5RGVmaW5pdGlvbi5nZXQgPSB1c2VyRGVmLmdldFxuICAgICAgPyBzaG91bGRDYWNoZSAmJiB1c2VyRGVmLmNhY2hlICE9PSBmYWxzZVxuICAgICAgICA/IGNyZWF0ZUNvbXB1dGVkR2V0dGVyKGtleSlcbiAgICAgICAgOiBjcmVhdGVHZXR0ZXJJbnZva2VyKHVzZXJEZWYuZ2V0KVxuICAgICAgOiBub29wO1xuICAgIHNoYXJlZFByb3BlcnR5RGVmaW5pdGlvbi5zZXQgPSB1c2VyRGVmLnNldCB8fCBub29wO1xuICB9XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmXG4gICAgICBzaGFyZWRQcm9wZXJ0eURlZmluaXRpb24uc2V0ID09PSBub29wKSB7XG4gICAgc2hhcmVkUHJvcGVydHlEZWZpbml0aW9uLnNldCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHdhcm4oXG4gICAgICAgIChcIkNvbXB1dGVkIHByb3BlcnR5IFxcXCJcIiArIGtleSArIFwiXFxcIiB3YXMgYXNzaWduZWQgdG8gYnV0IGl0IGhhcyBubyBzZXR0ZXIuXCIpLFxuICAgICAgICB0aGlzXG4gICAgICApO1xuICAgIH07XG4gIH1cbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCBzaGFyZWRQcm9wZXJ0eURlZmluaXRpb24pO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVDb21wdXRlZEdldHRlciAoa2V5KSB7XG4gIHJldHVybiBmdW5jdGlvbiBjb21wdXRlZEdldHRlciAoKSB7XG4gICAgdmFyIHdhdGNoZXIgPSB0aGlzLl9jb21wdXRlZFdhdGNoZXJzICYmIHRoaXMuX2NvbXB1dGVkV2F0Y2hlcnNba2V5XTtcbiAgICBpZiAod2F0Y2hlcikge1xuICAgICAgaWYgKHdhdGNoZXIuZGlydHkpIHtcbiAgICAgICAgd2F0Y2hlci5ldmFsdWF0ZSgpO1xuICAgICAgfVxuICAgICAgaWYgKERlcC50YXJnZXQpIHtcbiAgICAgICAgd2F0Y2hlci5kZXBlbmQoKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB3YXRjaGVyLnZhbHVlXG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUdldHRlckludm9rZXIoZm4pIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIGNvbXB1dGVkR2V0dGVyICgpIHtcbiAgICByZXR1cm4gZm4uY2FsbCh0aGlzLCB0aGlzKVxuICB9XG59XG5cbmZ1bmN0aW9uIGluaXRNZXRob2RzICh2bSwgbWV0aG9kcykge1xuICB2YXIgcHJvcHMgPSB2bS4kb3B0aW9ucy5wcm9wcztcbiAgZm9yICh2YXIga2V5IGluIG1ldGhvZHMpIHtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgaWYgKHR5cGVvZiBtZXRob2RzW2tleV0gIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgd2FybihcbiAgICAgICAgICBcIk1ldGhvZCBcXFwiXCIgKyBrZXkgKyBcIlxcXCIgaGFzIHR5cGUgXFxcIlwiICsgKHR5cGVvZiBtZXRob2RzW2tleV0pICsgXCJcXFwiIGluIHRoZSBjb21wb25lbnQgZGVmaW5pdGlvbi4gXCIgK1xuICAgICAgICAgIFwiRGlkIHlvdSByZWZlcmVuY2UgdGhlIGZ1bmN0aW9uIGNvcnJlY3RseT9cIixcbiAgICAgICAgICB2bVxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgaWYgKHByb3BzICYmIGhhc093bihwcm9wcywga2V5KSkge1xuICAgICAgICB3YXJuKFxuICAgICAgICAgIChcIk1ldGhvZCBcXFwiXCIgKyBrZXkgKyBcIlxcXCIgaGFzIGFscmVhZHkgYmVlbiBkZWZpbmVkIGFzIGEgcHJvcC5cIiksXG4gICAgICAgICAgdm1cbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIGlmICgoa2V5IGluIHZtKSAmJiBpc1Jlc2VydmVkKGtleSkpIHtcbiAgICAgICAgd2FybihcbiAgICAgICAgICBcIk1ldGhvZCBcXFwiXCIgKyBrZXkgKyBcIlxcXCIgY29uZmxpY3RzIHdpdGggYW4gZXhpc3RpbmcgVnVlIGluc3RhbmNlIG1ldGhvZC4gXCIgK1xuICAgICAgICAgIFwiQXZvaWQgZGVmaW5pbmcgY29tcG9uZW50IG1ldGhvZHMgdGhhdCBzdGFydCB3aXRoIF8gb3IgJC5cIlxuICAgICAgICApO1xuICAgICAgfVxuICAgIH1cbiAgICB2bVtrZXldID0gdHlwZW9mIG1ldGhvZHNba2V5XSAhPT0gJ2Z1bmN0aW9uJyA/IG5vb3AgOiBiaW5kKG1ldGhvZHNba2V5XSwgdm0pO1xuICB9XG59XG5cbmZ1bmN0aW9uIGluaXRXYXRjaCAodm0sIHdhdGNoKSB7XG4gIGZvciAodmFyIGtleSBpbiB3YXRjaCkge1xuICAgIHZhciBoYW5kbGVyID0gd2F0Y2hba2V5XTtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShoYW5kbGVyKSkge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBoYW5kbGVyLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNyZWF0ZVdhdGNoZXIodm0sIGtleSwgaGFuZGxlcltpXSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGNyZWF0ZVdhdGNoZXIodm0sIGtleSwgaGFuZGxlcik7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZVdhdGNoZXIgKFxuICB2bSxcbiAgZXhwT3JGbixcbiAgaGFuZGxlcixcbiAgb3B0aW9uc1xuKSB7XG4gIGlmIChpc1BsYWluT2JqZWN0KGhhbmRsZXIpKSB7XG4gICAgb3B0aW9ucyA9IGhhbmRsZXI7XG4gICAgaGFuZGxlciA9IGhhbmRsZXIuaGFuZGxlcjtcbiAgfVxuICBpZiAodHlwZW9mIGhhbmRsZXIgPT09ICdzdHJpbmcnKSB7XG4gICAgaGFuZGxlciA9IHZtW2hhbmRsZXJdO1xuICB9XG4gIHJldHVybiB2bS4kd2F0Y2goZXhwT3JGbiwgaGFuZGxlciwgb3B0aW9ucylcbn1cblxuZnVuY3Rpb24gc3RhdGVNaXhpbiAoVnVlKSB7XG4gIC8vIGZsb3cgc29tZWhvdyBoYXMgcHJvYmxlbXMgd2l0aCBkaXJlY3RseSBkZWNsYXJlZCBkZWZpbml0aW9uIG9iamVjdFxuICAvLyB3aGVuIHVzaW5nIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSwgc28gd2UgaGF2ZSB0byBwcm9jZWR1cmFsbHkgYnVpbGQgdXBcbiAgLy8gdGhlIG9iamVjdCBoZXJlLlxuICB2YXIgZGF0YURlZiA9IHt9O1xuICBkYXRhRGVmLmdldCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX2RhdGEgfTtcbiAgdmFyIHByb3BzRGVmID0ge307XG4gIHByb3BzRGVmLmdldCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX3Byb3BzIH07XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgZGF0YURlZi5zZXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICB3YXJuKFxuICAgICAgICAnQXZvaWQgcmVwbGFjaW5nIGluc3RhbmNlIHJvb3QgJGRhdGEuICcgK1xuICAgICAgICAnVXNlIG5lc3RlZCBkYXRhIHByb3BlcnRpZXMgaW5zdGVhZC4nLFxuICAgICAgICB0aGlzXG4gICAgICApO1xuICAgIH07XG4gICAgcHJvcHNEZWYuc2V0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgd2FybihcIiRwcm9wcyBpcyByZWFkb25seS5cIiwgdGhpcyk7XG4gICAgfTtcbiAgfVxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVnVlLnByb3RvdHlwZSwgJyRkYXRhJywgZGF0YURlZik7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShWdWUucHJvdG90eXBlLCAnJHByb3BzJywgcHJvcHNEZWYpO1xuXG4gIFZ1ZS5wcm90b3R5cGUuJHNldCA9IHNldDtcbiAgVnVlLnByb3RvdHlwZS4kZGVsZXRlID0gZGVsO1xuXG4gIFZ1ZS5wcm90b3R5cGUuJHdhdGNoID0gZnVuY3Rpb24gKFxuICAgIGV4cE9yRm4sXG4gICAgY2IsXG4gICAgb3B0aW9uc1xuICApIHtcbiAgICB2YXIgdm0gPSB0aGlzO1xuICAgIGlmIChpc1BsYWluT2JqZWN0KGNiKSkge1xuICAgICAgcmV0dXJuIGNyZWF0ZVdhdGNoZXIodm0sIGV4cE9yRm4sIGNiLCBvcHRpb25zKVxuICAgIH1cbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgICBvcHRpb25zLnVzZXIgPSB0cnVlO1xuICAgIHZhciB3YXRjaGVyID0gbmV3IFdhdGNoZXIodm0sIGV4cE9yRm4sIGNiLCBvcHRpb25zKTtcbiAgICBpZiAob3B0aW9ucy5pbW1lZGlhdGUpIHtcbiAgICAgIHZhciBpbmZvID0gXCJjYWxsYmFjayBmb3IgaW1tZWRpYXRlIHdhdGNoZXIgXFxcIlwiICsgKHdhdGNoZXIuZXhwcmVzc2lvbikgKyBcIlxcXCJcIjtcbiAgICAgIHB1c2hUYXJnZXQoKTtcbiAgICAgIGludm9rZVdpdGhFcnJvckhhbmRsaW5nKGNiLCB2bSwgW3dhdGNoZXIudmFsdWVdLCB2bSwgaW5mbyk7XG4gICAgICBwb3BUYXJnZXQoKTtcbiAgICB9XG4gICAgcmV0dXJuIGZ1bmN0aW9uIHVud2F0Y2hGbiAoKSB7XG4gICAgICB3YXRjaGVyLnRlYXJkb3duKCk7XG4gICAgfVxuICB9O1xufVxuXG4vKiAgKi9cblxudmFyIHVpZCQzID0gMDtcblxuZnVuY3Rpb24gaW5pdE1peGluIChWdWUpIHtcbiAgVnVlLnByb3RvdHlwZS5faW5pdCA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgdmFyIHZtID0gdGhpcztcbiAgICAvLyBhIHVpZFxuICAgIHZtLl91aWQgPSB1aWQkMysrO1xuXG4gICAgdmFyIHN0YXJ0VGFnLCBlbmRUYWc7XG4gICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgY29uZmlnLnBlcmZvcm1hbmNlICYmIG1hcmspIHtcbiAgICAgIHN0YXJ0VGFnID0gXCJ2dWUtcGVyZi1zdGFydDpcIiArICh2bS5fdWlkKTtcbiAgICAgIGVuZFRhZyA9IFwidnVlLXBlcmYtZW5kOlwiICsgKHZtLl91aWQpO1xuICAgICAgbWFyayhzdGFydFRhZyk7XG4gICAgfVxuXG4gICAgLy8gYSBmbGFnIHRvIGF2b2lkIHRoaXMgYmVpbmcgb2JzZXJ2ZWRcbiAgICB2bS5faXNWdWUgPSB0cnVlO1xuICAgIC8vIG1lcmdlIG9wdGlvbnNcbiAgICBpZiAob3B0aW9ucyAmJiBvcHRpb25zLl9pc0NvbXBvbmVudCkge1xuICAgICAgLy8gb3B0aW1pemUgaW50ZXJuYWwgY29tcG9uZW50IGluc3RhbnRpYXRpb25cbiAgICAgIC8vIHNpbmNlIGR5bmFtaWMgb3B0aW9ucyBtZXJnaW5nIGlzIHByZXR0eSBzbG93LCBhbmQgbm9uZSBvZiB0aGVcbiAgICAgIC8vIGludGVybmFsIGNvbXBvbmVudCBvcHRpb25zIG5lZWRzIHNwZWNpYWwgdHJlYXRtZW50LlxuICAgICAgaW5pdEludGVybmFsQ29tcG9uZW50KHZtLCBvcHRpb25zKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdm0uJG9wdGlvbnMgPSBtZXJnZU9wdGlvbnMoXG4gICAgICAgIHJlc29sdmVDb25zdHJ1Y3Rvck9wdGlvbnModm0uY29uc3RydWN0b3IpLFxuICAgICAgICBvcHRpb25zIHx8IHt9LFxuICAgICAgICB2bVxuICAgICAgKTtcbiAgICB9XG4gICAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgaW5pdFByb3h5KHZtKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdm0uX3JlbmRlclByb3h5ID0gdm07XG4gICAgfVxuICAgIC8vIGV4cG9zZSByZWFsIHNlbGZcbiAgICB2bS5fc2VsZiA9IHZtO1xuICAgIGluaXRMaWZlY3ljbGUodm0pO1xuICAgIGluaXRFdmVudHModm0pO1xuICAgIGluaXRSZW5kZXIodm0pO1xuICAgIGNhbGxIb29rKHZtLCAnYmVmb3JlQ3JlYXRlJyk7XG4gICAgaW5pdEluamVjdGlvbnModm0pOyAvLyByZXNvbHZlIGluamVjdGlvbnMgYmVmb3JlIGRhdGEvcHJvcHNcbiAgICBpbml0U3RhdGUodm0pO1xuICAgIGluaXRQcm92aWRlKHZtKTsgLy8gcmVzb2x2ZSBwcm92aWRlIGFmdGVyIGRhdGEvcHJvcHNcbiAgICBjYWxsSG9vayh2bSwgJ2NyZWF0ZWQnKTtcblxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIGNvbmZpZy5wZXJmb3JtYW5jZSAmJiBtYXJrKSB7XG4gICAgICB2bS5fbmFtZSA9IGZvcm1hdENvbXBvbmVudE5hbWUodm0sIGZhbHNlKTtcbiAgICAgIG1hcmsoZW5kVGFnKTtcbiAgICAgIG1lYXN1cmUoKFwidnVlIFwiICsgKHZtLl9uYW1lKSArIFwiIGluaXRcIiksIHN0YXJ0VGFnLCBlbmRUYWcpO1xuICAgIH1cblxuICAgIGlmICh2bS4kb3B0aW9ucy5lbCkge1xuICAgICAgdm0uJG1vdW50KHZtLiRvcHRpb25zLmVsKTtcbiAgICB9XG4gIH07XG59XG5cbmZ1bmN0aW9uIGluaXRJbnRlcm5hbENvbXBvbmVudCAodm0sIG9wdGlvbnMpIHtcbiAgdmFyIG9wdHMgPSB2bS4kb3B0aW9ucyA9IE9iamVjdC5jcmVhdGUodm0uY29uc3RydWN0b3Iub3B0aW9ucyk7XG4gIC8vIGRvaW5nIHRoaXMgYmVjYXVzZSBpdCdzIGZhc3RlciB0aGFuIGR5bmFtaWMgZW51bWVyYXRpb24uXG4gIHZhciBwYXJlbnRWbm9kZSA9IG9wdGlvbnMuX3BhcmVudFZub2RlO1xuICBvcHRzLnBhcmVudCA9IG9wdGlvbnMucGFyZW50O1xuICBvcHRzLl9wYXJlbnRWbm9kZSA9IHBhcmVudFZub2RlO1xuXG4gIHZhciB2bm9kZUNvbXBvbmVudE9wdGlvbnMgPSBwYXJlbnRWbm9kZS5jb21wb25lbnRPcHRpb25zO1xuICBvcHRzLnByb3BzRGF0YSA9IHZub2RlQ29tcG9uZW50T3B0aW9ucy5wcm9wc0RhdGE7XG4gIG9wdHMuX3BhcmVudExpc3RlbmVycyA9IHZub2RlQ29tcG9uZW50T3B0aW9ucy5saXN0ZW5lcnM7XG4gIG9wdHMuX3JlbmRlckNoaWxkcmVuID0gdm5vZGVDb21wb25lbnRPcHRpb25zLmNoaWxkcmVuO1xuICBvcHRzLl9jb21wb25lbnRUYWcgPSB2bm9kZUNvbXBvbmVudE9wdGlvbnMudGFnO1xuXG4gIGlmIChvcHRpb25zLnJlbmRlcikge1xuICAgIG9wdHMucmVuZGVyID0gb3B0aW9ucy5yZW5kZXI7XG4gICAgb3B0cy5zdGF0aWNSZW5kZXJGbnMgPSBvcHRpb25zLnN0YXRpY1JlbmRlckZucztcbiAgfVxufVxuXG5mdW5jdGlvbiByZXNvbHZlQ29uc3RydWN0b3JPcHRpb25zIChDdG9yKSB7XG4gIHZhciBvcHRpb25zID0gQ3Rvci5vcHRpb25zO1xuICBpZiAoQ3Rvci5zdXBlcikge1xuICAgIHZhciBzdXBlck9wdGlvbnMgPSByZXNvbHZlQ29uc3RydWN0b3JPcHRpb25zKEN0b3Iuc3VwZXIpO1xuICAgIHZhciBjYWNoZWRTdXBlck9wdGlvbnMgPSBDdG9yLnN1cGVyT3B0aW9ucztcbiAgICBpZiAoc3VwZXJPcHRpb25zICE9PSBjYWNoZWRTdXBlck9wdGlvbnMpIHtcbiAgICAgIC8vIHN1cGVyIG9wdGlvbiBjaGFuZ2VkLFxuICAgICAgLy8gbmVlZCB0byByZXNvbHZlIG5ldyBvcHRpb25zLlxuICAgICAgQ3Rvci5zdXBlck9wdGlvbnMgPSBzdXBlck9wdGlvbnM7XG4gICAgICAvLyBjaGVjayBpZiB0aGVyZSBhcmUgYW55IGxhdGUtbW9kaWZpZWQvYXR0YWNoZWQgb3B0aW9ucyAoIzQ5NzYpXG4gICAgICB2YXIgbW9kaWZpZWRPcHRpb25zID0gcmVzb2x2ZU1vZGlmaWVkT3B0aW9ucyhDdG9yKTtcbiAgICAgIC8vIHVwZGF0ZSBiYXNlIGV4dGVuZCBvcHRpb25zXG4gICAgICBpZiAobW9kaWZpZWRPcHRpb25zKSB7XG4gICAgICAgIGV4dGVuZChDdG9yLmV4dGVuZE9wdGlvbnMsIG1vZGlmaWVkT3B0aW9ucyk7XG4gICAgICB9XG4gICAgICBvcHRpb25zID0gQ3Rvci5vcHRpb25zID0gbWVyZ2VPcHRpb25zKHN1cGVyT3B0aW9ucywgQ3Rvci5leHRlbmRPcHRpb25zKTtcbiAgICAgIGlmIChvcHRpb25zLm5hbWUpIHtcbiAgICAgICAgb3B0aW9ucy5jb21wb25lbnRzW29wdGlvbnMubmFtZV0gPSBDdG9yO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gb3B0aW9uc1xufVxuXG5mdW5jdGlvbiByZXNvbHZlTW9kaWZpZWRPcHRpb25zIChDdG9yKSB7XG4gIHZhciBtb2RpZmllZDtcbiAgdmFyIGxhdGVzdCA9IEN0b3Iub3B0aW9ucztcbiAgdmFyIHNlYWxlZCA9IEN0b3Iuc2VhbGVkT3B0aW9ucztcbiAgZm9yICh2YXIga2V5IGluIGxhdGVzdCkge1xuICAgIGlmIChsYXRlc3Rba2V5XSAhPT0gc2VhbGVkW2tleV0pIHtcbiAgICAgIGlmICghbW9kaWZpZWQpIHsgbW9kaWZpZWQgPSB7fTsgfVxuICAgICAgbW9kaWZpZWRba2V5XSA9IGxhdGVzdFtrZXldO1xuICAgIH1cbiAgfVxuICByZXR1cm4gbW9kaWZpZWRcbn1cblxuZnVuY3Rpb24gVnVlIChvcHRpb25zKSB7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmXG4gICAgISh0aGlzIGluc3RhbmNlb2YgVnVlKVxuICApIHtcbiAgICB3YXJuKCdWdWUgaXMgYSBjb25zdHJ1Y3RvciBhbmQgc2hvdWxkIGJlIGNhbGxlZCB3aXRoIHRoZSBgbmV3YCBrZXl3b3JkJyk7XG4gIH1cbiAgdGhpcy5faW5pdChvcHRpb25zKTtcbn1cblxuaW5pdE1peGluKFZ1ZSk7XG5zdGF0ZU1peGluKFZ1ZSk7XG5ldmVudHNNaXhpbihWdWUpO1xubGlmZWN5Y2xlTWl4aW4oVnVlKTtcbnJlbmRlck1peGluKFZ1ZSk7XG5cbi8qICAqL1xuXG5mdW5jdGlvbiBpbml0VXNlIChWdWUpIHtcbiAgVnVlLnVzZSA9IGZ1bmN0aW9uIChwbHVnaW4pIHtcbiAgICB2YXIgaW5zdGFsbGVkUGx1Z2lucyA9ICh0aGlzLl9pbnN0YWxsZWRQbHVnaW5zIHx8ICh0aGlzLl9pbnN0YWxsZWRQbHVnaW5zID0gW10pKTtcbiAgICBpZiAoaW5zdGFsbGVkUGx1Z2lucy5pbmRleE9mKHBsdWdpbikgPiAtMSkge1xuICAgICAgcmV0dXJuIHRoaXNcbiAgICB9XG5cbiAgICAvLyBhZGRpdGlvbmFsIHBhcmFtZXRlcnNcbiAgICB2YXIgYXJncyA9IHRvQXJyYXkoYXJndW1lbnRzLCAxKTtcbiAgICBhcmdzLnVuc2hpZnQodGhpcyk7XG4gICAgaWYgKHR5cGVvZiBwbHVnaW4uaW5zdGFsbCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgcGx1Z2luLmluc3RhbGwuYXBwbHkocGx1Z2luLCBhcmdzKTtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBwbHVnaW4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHBsdWdpbi5hcHBseShudWxsLCBhcmdzKTtcbiAgICB9XG4gICAgaW5zdGFsbGVkUGx1Z2lucy5wdXNoKHBsdWdpbik7XG4gICAgcmV0dXJuIHRoaXNcbiAgfTtcbn1cblxuLyogICovXG5cbmZ1bmN0aW9uIGluaXRNaXhpbiQxIChWdWUpIHtcbiAgVnVlLm1peGluID0gZnVuY3Rpb24gKG1peGluKSB7XG4gICAgdGhpcy5vcHRpb25zID0gbWVyZ2VPcHRpb25zKHRoaXMub3B0aW9ucywgbWl4aW4pO1xuICAgIHJldHVybiB0aGlzXG4gIH07XG59XG5cbi8qICAqL1xuXG5mdW5jdGlvbiBpbml0RXh0ZW5kIChWdWUpIHtcbiAgLyoqXG4gICAqIEVhY2ggaW5zdGFuY2UgY29uc3RydWN0b3IsIGluY2x1ZGluZyBWdWUsIGhhcyBhIHVuaXF1ZVxuICAgKiBjaWQuIFRoaXMgZW5hYmxlcyB1cyB0byBjcmVhdGUgd3JhcHBlZCBcImNoaWxkXG4gICAqIGNvbnN0cnVjdG9yc1wiIGZvciBwcm90b3R5cGFsIGluaGVyaXRhbmNlIGFuZCBjYWNoZSB0aGVtLlxuICAgKi9cbiAgVnVlLmNpZCA9IDA7XG4gIHZhciBjaWQgPSAxO1xuXG4gIC8qKlxuICAgKiBDbGFzcyBpbmhlcml0YW5jZVxuICAgKi9cbiAgVnVlLmV4dGVuZCA9IGZ1bmN0aW9uIChleHRlbmRPcHRpb25zKSB7XG4gICAgZXh0ZW5kT3B0aW9ucyA9IGV4dGVuZE9wdGlvbnMgfHwge307XG4gICAgdmFyIFN1cGVyID0gdGhpcztcbiAgICB2YXIgU3VwZXJJZCA9IFN1cGVyLmNpZDtcbiAgICB2YXIgY2FjaGVkQ3RvcnMgPSBleHRlbmRPcHRpb25zLl9DdG9yIHx8IChleHRlbmRPcHRpb25zLl9DdG9yID0ge30pO1xuICAgIGlmIChjYWNoZWRDdG9yc1tTdXBlcklkXSkge1xuICAgICAgcmV0dXJuIGNhY2hlZEN0b3JzW1N1cGVySWRdXG4gICAgfVxuXG4gICAgdmFyIG5hbWUgPSBleHRlbmRPcHRpb25zLm5hbWUgfHwgU3VwZXIub3B0aW9ucy5uYW1lO1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIG5hbWUpIHtcbiAgICAgIHZhbGlkYXRlQ29tcG9uZW50TmFtZShuYW1lKTtcbiAgICB9XG5cbiAgICB2YXIgU3ViID0gZnVuY3Rpb24gVnVlQ29tcG9uZW50IChvcHRpb25zKSB7XG4gICAgICB0aGlzLl9pbml0KG9wdGlvbnMpO1xuICAgIH07XG4gICAgU3ViLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoU3VwZXIucHJvdG90eXBlKTtcbiAgICBTdWIucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gU3ViO1xuICAgIFN1Yi5jaWQgPSBjaWQrKztcbiAgICBTdWIub3B0aW9ucyA9IG1lcmdlT3B0aW9ucyhcbiAgICAgIFN1cGVyLm9wdGlvbnMsXG4gICAgICBleHRlbmRPcHRpb25zXG4gICAgKTtcbiAgICBTdWJbJ3N1cGVyJ10gPSBTdXBlcjtcblxuICAgIC8vIEZvciBwcm9wcyBhbmQgY29tcHV0ZWQgcHJvcGVydGllcywgd2UgZGVmaW5lIHRoZSBwcm94eSBnZXR0ZXJzIG9uXG4gICAgLy8gdGhlIFZ1ZSBpbnN0YW5jZXMgYXQgZXh0ZW5zaW9uIHRpbWUsIG9uIHRoZSBleHRlbmRlZCBwcm90b3R5cGUuIFRoaXNcbiAgICAvLyBhdm9pZHMgT2JqZWN0LmRlZmluZVByb3BlcnR5IGNhbGxzIGZvciBlYWNoIGluc3RhbmNlIGNyZWF0ZWQuXG4gICAgaWYgKFN1Yi5vcHRpb25zLnByb3BzKSB7XG4gICAgICBpbml0UHJvcHMkMShTdWIpO1xuICAgIH1cbiAgICBpZiAoU3ViLm9wdGlvbnMuY29tcHV0ZWQpIHtcbiAgICAgIGluaXRDb21wdXRlZCQxKFN1Yik7XG4gICAgfVxuXG4gICAgLy8gYWxsb3cgZnVydGhlciBleHRlbnNpb24vbWl4aW4vcGx1Z2luIHVzYWdlXG4gICAgU3ViLmV4dGVuZCA9IFN1cGVyLmV4dGVuZDtcbiAgICBTdWIubWl4aW4gPSBTdXBlci5taXhpbjtcbiAgICBTdWIudXNlID0gU3VwZXIudXNlO1xuXG4gICAgLy8gY3JlYXRlIGFzc2V0IHJlZ2lzdGVycywgc28gZXh0ZW5kZWQgY2xhc3Nlc1xuICAgIC8vIGNhbiBoYXZlIHRoZWlyIHByaXZhdGUgYXNzZXRzIHRvby5cbiAgICBBU1NFVF9UWVBFUy5mb3JFYWNoKGZ1bmN0aW9uICh0eXBlKSB7XG4gICAgICBTdWJbdHlwZV0gPSBTdXBlclt0eXBlXTtcbiAgICB9KTtcbiAgICAvLyBlbmFibGUgcmVjdXJzaXZlIHNlbGYtbG9va3VwXG4gICAgaWYgKG5hbWUpIHtcbiAgICAgIFN1Yi5vcHRpb25zLmNvbXBvbmVudHNbbmFtZV0gPSBTdWI7XG4gICAgfVxuXG4gICAgLy8ga2VlcCBhIHJlZmVyZW5jZSB0byB0aGUgc3VwZXIgb3B0aW9ucyBhdCBleHRlbnNpb24gdGltZS5cbiAgICAvLyBsYXRlciBhdCBpbnN0YW50aWF0aW9uIHdlIGNhbiBjaGVjayBpZiBTdXBlcidzIG9wdGlvbnMgaGF2ZVxuICAgIC8vIGJlZW4gdXBkYXRlZC5cbiAgICBTdWIuc3VwZXJPcHRpb25zID0gU3VwZXIub3B0aW9ucztcbiAgICBTdWIuZXh0ZW5kT3B0aW9ucyA9IGV4dGVuZE9wdGlvbnM7XG4gICAgU3ViLnNlYWxlZE9wdGlvbnMgPSBleHRlbmQoe30sIFN1Yi5vcHRpb25zKTtcblxuICAgIC8vIGNhY2hlIGNvbnN0cnVjdG9yXG4gICAgY2FjaGVkQ3RvcnNbU3VwZXJJZF0gPSBTdWI7XG4gICAgcmV0dXJuIFN1YlxuICB9O1xufVxuXG5mdW5jdGlvbiBpbml0UHJvcHMkMSAoQ29tcCkge1xuICB2YXIgcHJvcHMgPSBDb21wLm9wdGlvbnMucHJvcHM7XG4gIGZvciAodmFyIGtleSBpbiBwcm9wcykge1xuICAgIHByb3h5KENvbXAucHJvdG90eXBlLCBcIl9wcm9wc1wiLCBrZXkpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGluaXRDb21wdXRlZCQxIChDb21wKSB7XG4gIHZhciBjb21wdXRlZCA9IENvbXAub3B0aW9ucy5jb21wdXRlZDtcbiAgZm9yICh2YXIga2V5IGluIGNvbXB1dGVkKSB7XG4gICAgZGVmaW5lQ29tcHV0ZWQoQ29tcC5wcm90b3R5cGUsIGtleSwgY29tcHV0ZWRba2V5XSk7XG4gIH1cbn1cblxuLyogICovXG5cbmZ1bmN0aW9uIGluaXRBc3NldFJlZ2lzdGVycyAoVnVlKSB7XG4gIC8qKlxuICAgKiBDcmVhdGUgYXNzZXQgcmVnaXN0cmF0aW9uIG1ldGhvZHMuXG4gICAqL1xuICBBU1NFVF9UWVBFUy5mb3JFYWNoKGZ1bmN0aW9uICh0eXBlKSB7XG4gICAgVnVlW3R5cGVdID0gZnVuY3Rpb24gKFxuICAgICAgaWQsXG4gICAgICBkZWZpbml0aW9uXG4gICAgKSB7XG4gICAgICBpZiAoIWRlZmluaXRpb24pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMub3B0aW9uc1t0eXBlICsgJ3MnXVtpZF1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiB0eXBlID09PSAnY29tcG9uZW50Jykge1xuICAgICAgICAgIHZhbGlkYXRlQ29tcG9uZW50TmFtZShpZCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGUgPT09ICdjb21wb25lbnQnICYmIGlzUGxhaW5PYmplY3QoZGVmaW5pdGlvbikpIHtcbiAgICAgICAgICBkZWZpbml0aW9uLm5hbWUgPSBkZWZpbml0aW9uLm5hbWUgfHwgaWQ7XG4gICAgICAgICAgZGVmaW5pdGlvbiA9IHRoaXMub3B0aW9ucy5fYmFzZS5leHRlbmQoZGVmaW5pdGlvbik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGUgPT09ICdkaXJlY3RpdmUnICYmIHR5cGVvZiBkZWZpbml0aW9uID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgZGVmaW5pdGlvbiA9IHsgYmluZDogZGVmaW5pdGlvbiwgdXBkYXRlOiBkZWZpbml0aW9uIH07XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5vcHRpb25zW3R5cGUgKyAncyddW2lkXSA9IGRlZmluaXRpb247XG4gICAgICAgIHJldHVybiBkZWZpbml0aW9uXG4gICAgICB9XG4gICAgfTtcbiAgfSk7XG59XG5cbi8qICAqL1xuXG5cblxuXG5cbmZ1bmN0aW9uIGdldENvbXBvbmVudE5hbWUgKG9wdHMpIHtcbiAgcmV0dXJuIG9wdHMgJiYgKG9wdHMuQ3Rvci5vcHRpb25zLm5hbWUgfHwgb3B0cy50YWcpXG59XG5cbmZ1bmN0aW9uIG1hdGNoZXMgKHBhdHRlcm4sIG5hbWUpIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkocGF0dGVybikpIHtcbiAgICByZXR1cm4gcGF0dGVybi5pbmRleE9mKG5hbWUpID4gLTFcbiAgfSBlbHNlIGlmICh0eXBlb2YgcGF0dGVybiA9PT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gcGF0dGVybi5zcGxpdCgnLCcpLmluZGV4T2YobmFtZSkgPiAtMVxuICB9IGVsc2UgaWYgKGlzUmVnRXhwKHBhdHRlcm4pKSB7XG4gICAgcmV0dXJuIHBhdHRlcm4udGVzdChuYW1lKVxuICB9XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gIHJldHVybiBmYWxzZVxufVxuXG5mdW5jdGlvbiBwcnVuZUNhY2hlIChrZWVwQWxpdmVJbnN0YW5jZSwgZmlsdGVyKSB7XG4gIHZhciBjYWNoZSA9IGtlZXBBbGl2ZUluc3RhbmNlLmNhY2hlO1xuICB2YXIga2V5cyA9IGtlZXBBbGl2ZUluc3RhbmNlLmtleXM7XG4gIHZhciBfdm5vZGUgPSBrZWVwQWxpdmVJbnN0YW5jZS5fdm5vZGU7XG4gIGZvciAodmFyIGtleSBpbiBjYWNoZSkge1xuICAgIHZhciBlbnRyeSA9IGNhY2hlW2tleV07XG4gICAgaWYgKGVudHJ5KSB7XG4gICAgICB2YXIgbmFtZSA9IGVudHJ5Lm5hbWU7XG4gICAgICBpZiAobmFtZSAmJiAhZmlsdGVyKG5hbWUpKSB7XG4gICAgICAgIHBydW5lQ2FjaGVFbnRyeShjYWNoZSwga2V5LCBrZXlzLCBfdm5vZGUpO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBwcnVuZUNhY2hlRW50cnkgKFxuICBjYWNoZSxcbiAga2V5LFxuICBrZXlzLFxuICBjdXJyZW50XG4pIHtcbiAgdmFyIGVudHJ5ID0gY2FjaGVba2V5XTtcbiAgaWYgKGVudHJ5ICYmICghY3VycmVudCB8fCBlbnRyeS50YWcgIT09IGN1cnJlbnQudGFnKSkge1xuICAgIGVudHJ5LmNvbXBvbmVudEluc3RhbmNlLiRkZXN0cm95KCk7XG4gIH1cbiAgY2FjaGVba2V5XSA9IG51bGw7XG4gIHJlbW92ZShrZXlzLCBrZXkpO1xufVxuXG52YXIgcGF0dGVyblR5cGVzID0gW1N0cmluZywgUmVnRXhwLCBBcnJheV07XG5cbnZhciBLZWVwQWxpdmUgPSB7XG4gIG5hbWU6ICdrZWVwLWFsaXZlJyxcbiAgYWJzdHJhY3Q6IHRydWUsXG5cbiAgcHJvcHM6IHtcbiAgICBpbmNsdWRlOiBwYXR0ZXJuVHlwZXMsXG4gICAgZXhjbHVkZTogcGF0dGVyblR5cGVzLFxuICAgIG1heDogW1N0cmluZywgTnVtYmVyXVxuICB9LFxuXG4gIG1ldGhvZHM6IHtcbiAgICBjYWNoZVZOb2RlOiBmdW5jdGlvbiBjYWNoZVZOb2RlKCkge1xuICAgICAgdmFyIHJlZiA9IHRoaXM7XG4gICAgICB2YXIgY2FjaGUgPSByZWYuY2FjaGU7XG4gICAgICB2YXIga2V5cyA9IHJlZi5rZXlzO1xuICAgICAgdmFyIHZub2RlVG9DYWNoZSA9IHJlZi52bm9kZVRvQ2FjaGU7XG4gICAgICB2YXIga2V5VG9DYWNoZSA9IHJlZi5rZXlUb0NhY2hlO1xuICAgICAgaWYgKHZub2RlVG9DYWNoZSkge1xuICAgICAgICB2YXIgdGFnID0gdm5vZGVUb0NhY2hlLnRhZztcbiAgICAgICAgdmFyIGNvbXBvbmVudEluc3RhbmNlID0gdm5vZGVUb0NhY2hlLmNvbXBvbmVudEluc3RhbmNlO1xuICAgICAgICB2YXIgY29tcG9uZW50T3B0aW9ucyA9IHZub2RlVG9DYWNoZS5jb21wb25lbnRPcHRpb25zO1xuICAgICAgICBjYWNoZVtrZXlUb0NhY2hlXSA9IHtcbiAgICAgICAgICBuYW1lOiBnZXRDb21wb25lbnROYW1lKGNvbXBvbmVudE9wdGlvbnMpLFxuICAgICAgICAgIHRhZzogdGFnLFxuICAgICAgICAgIGNvbXBvbmVudEluc3RhbmNlOiBjb21wb25lbnRJbnN0YW5jZSxcbiAgICAgICAgfTtcbiAgICAgICAga2V5cy5wdXNoKGtleVRvQ2FjaGUpO1xuICAgICAgICAvLyBwcnVuZSBvbGRlc3QgZW50cnlcbiAgICAgICAgaWYgKHRoaXMubWF4ICYmIGtleXMubGVuZ3RoID4gcGFyc2VJbnQodGhpcy5tYXgpKSB7XG4gICAgICAgICAgcHJ1bmVDYWNoZUVudHJ5KGNhY2hlLCBrZXlzWzBdLCBrZXlzLCB0aGlzLl92bm9kZSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy52bm9kZVRvQ2FjaGUgPSBudWxsO1xuICAgICAgfVxuICAgIH1cbiAgfSxcblxuICBjcmVhdGVkOiBmdW5jdGlvbiBjcmVhdGVkICgpIHtcbiAgICB0aGlzLmNhY2hlID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICB0aGlzLmtleXMgPSBbXTtcbiAgfSxcblxuICBkZXN0cm95ZWQ6IGZ1bmN0aW9uIGRlc3Ryb3llZCAoKSB7XG4gICAgZm9yICh2YXIga2V5IGluIHRoaXMuY2FjaGUpIHtcbiAgICAgIHBydW5lQ2FjaGVFbnRyeSh0aGlzLmNhY2hlLCBrZXksIHRoaXMua2V5cyk7XG4gICAgfVxuICB9LFxuXG4gIG1vdW50ZWQ6IGZ1bmN0aW9uIG1vdW50ZWQgKCkge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gICAgdGhpcy5jYWNoZVZOb2RlKCk7XG4gICAgdGhpcy4kd2F0Y2goJ2luY2x1ZGUnLCBmdW5jdGlvbiAodmFsKSB7XG4gICAgICBwcnVuZUNhY2hlKHRoaXMkMSwgZnVuY3Rpb24gKG5hbWUpIHsgcmV0dXJuIG1hdGNoZXModmFsLCBuYW1lKTsgfSk7XG4gICAgfSk7XG4gICAgdGhpcy4kd2F0Y2goJ2V4Y2x1ZGUnLCBmdW5jdGlvbiAodmFsKSB7XG4gICAgICBwcnVuZUNhY2hlKHRoaXMkMSwgZnVuY3Rpb24gKG5hbWUpIHsgcmV0dXJuICFtYXRjaGVzKHZhbCwgbmFtZSk7IH0pO1xuICAgIH0pO1xuICB9LFxuXG4gIHVwZGF0ZWQ6IGZ1bmN0aW9uIHVwZGF0ZWQgKCkge1xuICAgIHRoaXMuY2FjaGVWTm9kZSgpO1xuICB9LFxuXG4gIHJlbmRlcjogZnVuY3Rpb24gcmVuZGVyICgpIHtcbiAgICB2YXIgc2xvdCA9IHRoaXMuJHNsb3RzLmRlZmF1bHQ7XG4gICAgdmFyIHZub2RlID0gZ2V0Rmlyc3RDb21wb25lbnRDaGlsZChzbG90KTtcbiAgICB2YXIgY29tcG9uZW50T3B0aW9ucyA9IHZub2RlICYmIHZub2RlLmNvbXBvbmVudE9wdGlvbnM7XG4gICAgaWYgKGNvbXBvbmVudE9wdGlvbnMpIHtcbiAgICAgIC8vIGNoZWNrIHBhdHRlcm5cbiAgICAgIHZhciBuYW1lID0gZ2V0Q29tcG9uZW50TmFtZShjb21wb25lbnRPcHRpb25zKTtcbiAgICAgIHZhciByZWYgPSB0aGlzO1xuICAgICAgdmFyIGluY2x1ZGUgPSByZWYuaW5jbHVkZTtcbiAgICAgIHZhciBleGNsdWRlID0gcmVmLmV4Y2x1ZGU7XG4gICAgICBpZiAoXG4gICAgICAgIC8vIG5vdCBpbmNsdWRlZFxuICAgICAgICAoaW5jbHVkZSAmJiAoIW5hbWUgfHwgIW1hdGNoZXMoaW5jbHVkZSwgbmFtZSkpKSB8fFxuICAgICAgICAvLyBleGNsdWRlZFxuICAgICAgICAoZXhjbHVkZSAmJiBuYW1lICYmIG1hdGNoZXMoZXhjbHVkZSwgbmFtZSkpXG4gICAgICApIHtcbiAgICAgICAgcmV0dXJuIHZub2RlXG4gICAgICB9XG5cbiAgICAgIHZhciByZWYkMSA9IHRoaXM7XG4gICAgICB2YXIgY2FjaGUgPSByZWYkMS5jYWNoZTtcbiAgICAgIHZhciBrZXlzID0gcmVmJDEua2V5cztcbiAgICAgIHZhciBrZXkgPSB2bm9kZS5rZXkgPT0gbnVsbFxuICAgICAgICAvLyBzYW1lIGNvbnN0cnVjdG9yIG1heSBnZXQgcmVnaXN0ZXJlZCBhcyBkaWZmZXJlbnQgbG9jYWwgY29tcG9uZW50c1xuICAgICAgICAvLyBzbyBjaWQgYWxvbmUgaXMgbm90IGVub3VnaCAoIzMyNjkpXG4gICAgICAgID8gY29tcG9uZW50T3B0aW9ucy5DdG9yLmNpZCArIChjb21wb25lbnRPcHRpb25zLnRhZyA/IChcIjo6XCIgKyAoY29tcG9uZW50T3B0aW9ucy50YWcpKSA6ICcnKVxuICAgICAgICA6IHZub2RlLmtleTtcbiAgICAgIGlmIChjYWNoZVtrZXldKSB7XG4gICAgICAgIHZub2RlLmNvbXBvbmVudEluc3RhbmNlID0gY2FjaGVba2V5XS5jb21wb25lbnRJbnN0YW5jZTtcbiAgICAgICAgLy8gbWFrZSBjdXJyZW50IGtleSBmcmVzaGVzdFxuICAgICAgICByZW1vdmUoa2V5cywga2V5KTtcbiAgICAgICAga2V5cy5wdXNoKGtleSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBkZWxheSBzZXR0aW5nIHRoZSBjYWNoZSB1bnRpbCB1cGRhdGVcbiAgICAgICAgdGhpcy52bm9kZVRvQ2FjaGUgPSB2bm9kZTtcbiAgICAgICAgdGhpcy5rZXlUb0NhY2hlID0ga2V5O1xuICAgICAgfVxuXG4gICAgICB2bm9kZS5kYXRhLmtlZXBBbGl2ZSA9IHRydWU7XG4gICAgfVxuICAgIHJldHVybiB2bm9kZSB8fCAoc2xvdCAmJiBzbG90WzBdKVxuICB9XG59O1xuXG52YXIgYnVpbHRJbkNvbXBvbmVudHMgPSB7XG4gIEtlZXBBbGl2ZTogS2VlcEFsaXZlXG59O1xuXG4vKiAgKi9cblxuZnVuY3Rpb24gaW5pdEdsb2JhbEFQSSAoVnVlKSB7XG4gIC8vIGNvbmZpZ1xuICB2YXIgY29uZmlnRGVmID0ge307XG4gIGNvbmZpZ0RlZi5nZXQgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBjb25maWc7IH07XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgY29uZmlnRGVmLnNldCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHdhcm4oXG4gICAgICAgICdEbyBub3QgcmVwbGFjZSB0aGUgVnVlLmNvbmZpZyBvYmplY3QsIHNldCBpbmRpdmlkdWFsIGZpZWxkcyBpbnN0ZWFkLidcbiAgICAgICk7XG4gICAgfTtcbiAgfVxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVnVlLCAnY29uZmlnJywgY29uZmlnRGVmKTtcblxuICAvLyBleHBvc2VkIHV0aWwgbWV0aG9kcy5cbiAgLy8gTk9URTogdGhlc2UgYXJlIG5vdCBjb25zaWRlcmVkIHBhcnQgb2YgdGhlIHB1YmxpYyBBUEkgLSBhdm9pZCByZWx5aW5nIG9uXG4gIC8vIHRoZW0gdW5sZXNzIHlvdSBhcmUgYXdhcmUgb2YgdGhlIHJpc2suXG4gIFZ1ZS51dGlsID0ge1xuICAgIHdhcm46IHdhcm4sXG4gICAgZXh0ZW5kOiBleHRlbmQsXG4gICAgbWVyZ2VPcHRpb25zOiBtZXJnZU9wdGlvbnMsXG4gICAgZGVmaW5lUmVhY3RpdmU6IGRlZmluZVJlYWN0aXZlJCQxXG4gIH07XG5cbiAgVnVlLnNldCA9IHNldDtcbiAgVnVlLmRlbGV0ZSA9IGRlbDtcbiAgVnVlLm5leHRUaWNrID0gbmV4dFRpY2s7XG5cbiAgLy8gMi42IGV4cGxpY2l0IG9ic2VydmFibGUgQVBJXG4gIFZ1ZS5vYnNlcnZhYmxlID0gZnVuY3Rpb24gKG9iaikge1xuICAgIG9ic2VydmUob2JqKTtcbiAgICByZXR1cm4gb2JqXG4gIH07XG5cbiAgVnVlLm9wdGlvbnMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICBBU1NFVF9UWVBFUy5mb3JFYWNoKGZ1bmN0aW9uICh0eXBlKSB7XG4gICAgVnVlLm9wdGlvbnNbdHlwZSArICdzJ10gPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICB9KTtcblxuICAvLyB0aGlzIGlzIHVzZWQgdG8gaWRlbnRpZnkgdGhlIFwiYmFzZVwiIGNvbnN0cnVjdG9yIHRvIGV4dGVuZCBhbGwgcGxhaW4tb2JqZWN0XG4gIC8vIGNvbXBvbmVudHMgd2l0aCBpbiBXZWV4J3MgbXVsdGktaW5zdGFuY2Ugc2NlbmFyaW9zLlxuICBWdWUub3B0aW9ucy5fYmFzZSA9IFZ1ZTtcblxuICBleHRlbmQoVnVlLm9wdGlvbnMuY29tcG9uZW50cywgYnVpbHRJbkNvbXBvbmVudHMpO1xuXG4gIGluaXRVc2UoVnVlKTtcbiAgaW5pdE1peGluJDEoVnVlKTtcbiAgaW5pdEV4dGVuZChWdWUpO1xuICBpbml0QXNzZXRSZWdpc3RlcnMoVnVlKTtcbn1cblxuaW5pdEdsb2JhbEFQSShWdWUpO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoVnVlLnByb3RvdHlwZSwgJyRpc1NlcnZlcicsIHtcbiAgZ2V0OiBpc1NlcnZlclJlbmRlcmluZ1xufSk7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShWdWUucHJvdG90eXBlLCAnJHNzckNvbnRleHQnLCB7XG4gIGdldDogZnVuY3Rpb24gZ2V0ICgpIHtcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgIHJldHVybiB0aGlzLiR2bm9kZSAmJiB0aGlzLiR2bm9kZS5zc3JDb250ZXh0XG4gIH1cbn0pO1xuXG4vLyBleHBvc2UgRnVuY3Rpb25hbFJlbmRlckNvbnRleHQgZm9yIHNzciBydW50aW1lIGhlbHBlciBpbnN0YWxsYXRpb25cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShWdWUsICdGdW5jdGlvbmFsUmVuZGVyQ29udGV4dCcsIHtcbiAgdmFsdWU6IEZ1bmN0aW9uYWxSZW5kZXJDb250ZXh0XG59KTtcblxuVnVlLnZlcnNpb24gPSAnMi42LjE0JztcblxuLyogICovXG5cbi8vIHRoZXNlIGFyZSByZXNlcnZlZCBmb3Igd2ViIGJlY2F1c2UgdGhleSBhcmUgZGlyZWN0bHkgY29tcGlsZWQgYXdheVxuLy8gZHVyaW5nIHRlbXBsYXRlIGNvbXBpbGF0aW9uXG52YXIgaXNSZXNlcnZlZEF0dHIgPSBtYWtlTWFwKCdzdHlsZSxjbGFzcycpO1xuXG4vLyBhdHRyaWJ1dGVzIHRoYXQgc2hvdWxkIGJlIHVzaW5nIHByb3BzIGZvciBiaW5kaW5nXG52YXIgYWNjZXB0VmFsdWUgPSBtYWtlTWFwKCdpbnB1dCx0ZXh0YXJlYSxvcHRpb24sc2VsZWN0LHByb2dyZXNzJyk7XG52YXIgbXVzdFVzZVByb3AgPSBmdW5jdGlvbiAodGFnLCB0eXBlLCBhdHRyKSB7XG4gIHJldHVybiAoXG4gICAgKGF0dHIgPT09ICd2YWx1ZScgJiYgYWNjZXB0VmFsdWUodGFnKSkgJiYgdHlwZSAhPT0gJ2J1dHRvbicgfHxcbiAgICAoYXR0ciA9PT0gJ3NlbGVjdGVkJyAmJiB0YWcgPT09ICdvcHRpb24nKSB8fFxuICAgIChhdHRyID09PSAnY2hlY2tlZCcgJiYgdGFnID09PSAnaW5wdXQnKSB8fFxuICAgIChhdHRyID09PSAnbXV0ZWQnICYmIHRhZyA9PT0gJ3ZpZGVvJylcbiAgKVxufTtcblxudmFyIGlzRW51bWVyYXRlZEF0dHIgPSBtYWtlTWFwKCdjb250ZW50ZWRpdGFibGUsZHJhZ2dhYmxlLHNwZWxsY2hlY2snKTtcblxudmFyIGlzVmFsaWRDb250ZW50RWRpdGFibGVWYWx1ZSA9IG1ha2VNYXAoJ2V2ZW50cyxjYXJldCx0eXBpbmcscGxhaW50ZXh0LW9ubHknKTtcblxudmFyIGNvbnZlcnRFbnVtZXJhdGVkVmFsdWUgPSBmdW5jdGlvbiAoa2V5LCB2YWx1ZSkge1xuICByZXR1cm4gaXNGYWxzeUF0dHJWYWx1ZSh2YWx1ZSkgfHwgdmFsdWUgPT09ICdmYWxzZSdcbiAgICA/ICdmYWxzZSdcbiAgICAvLyBhbGxvdyBhcmJpdHJhcnkgc3RyaW5nIHZhbHVlIGZvciBjb250ZW50ZWRpdGFibGVcbiAgICA6IGtleSA9PT0gJ2NvbnRlbnRlZGl0YWJsZScgJiYgaXNWYWxpZENvbnRlbnRFZGl0YWJsZVZhbHVlKHZhbHVlKVxuICAgICAgPyB2YWx1ZVxuICAgICAgOiAndHJ1ZSdcbn07XG5cbnZhciBpc0Jvb2xlYW5BdHRyID0gbWFrZU1hcChcbiAgJ2FsbG93ZnVsbHNjcmVlbixhc3luYyxhdXRvZm9jdXMsYXV0b3BsYXksY2hlY2tlZCxjb21wYWN0LGNvbnRyb2xzLGRlY2xhcmUsJyArXG4gICdkZWZhdWx0LGRlZmF1bHRjaGVja2VkLGRlZmF1bHRtdXRlZCxkZWZhdWx0c2VsZWN0ZWQsZGVmZXIsZGlzYWJsZWQsJyArXG4gICdlbmFibGVkLGZvcm1ub3ZhbGlkYXRlLGhpZGRlbixpbmRldGVybWluYXRlLGluZXJ0LGlzbWFwLGl0ZW1zY29wZSxsb29wLG11bHRpcGxlLCcgK1xuICAnbXV0ZWQsbm9ocmVmLG5vcmVzaXplLG5vc2hhZGUsbm92YWxpZGF0ZSxub3dyYXAsb3BlbixwYXVzZW9uZXhpdCxyZWFkb25seSwnICtcbiAgJ3JlcXVpcmVkLHJldmVyc2VkLHNjb3BlZCxzZWFtbGVzcyxzZWxlY3RlZCxzb3J0YWJsZSwnICtcbiAgJ3RydWVzcGVlZCx0eXBlbXVzdG1hdGNoLHZpc2libGUnXG4pO1xuXG52YXIgeGxpbmtOUyA9ICdodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rJztcblxudmFyIGlzWGxpbmsgPSBmdW5jdGlvbiAobmFtZSkge1xuICByZXR1cm4gbmFtZS5jaGFyQXQoNSkgPT09ICc6JyAmJiBuYW1lLnNsaWNlKDAsIDUpID09PSAneGxpbmsnXG59O1xuXG52YXIgZ2V0WGxpbmtQcm9wID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgcmV0dXJuIGlzWGxpbmsobmFtZSkgPyBuYW1lLnNsaWNlKDYsIG5hbWUubGVuZ3RoKSA6ICcnXG59O1xuXG52YXIgaXNGYWxzeUF0dHJWYWx1ZSA9IGZ1bmN0aW9uICh2YWwpIHtcbiAgcmV0dXJuIHZhbCA9PSBudWxsIHx8IHZhbCA9PT0gZmFsc2Vcbn07XG5cbi8qICAqL1xuXG5mdW5jdGlvbiBnZW5DbGFzc0ZvclZub2RlICh2bm9kZSkge1xuICB2YXIgZGF0YSA9IHZub2RlLmRhdGE7XG4gIHZhciBwYXJlbnROb2RlID0gdm5vZGU7XG4gIHZhciBjaGlsZE5vZGUgPSB2bm9kZTtcbiAgd2hpbGUgKGlzRGVmKGNoaWxkTm9kZS5jb21wb25lbnRJbnN0YW5jZSkpIHtcbiAgICBjaGlsZE5vZGUgPSBjaGlsZE5vZGUuY29tcG9uZW50SW5zdGFuY2UuX3Zub2RlO1xuICAgIGlmIChjaGlsZE5vZGUgJiYgY2hpbGROb2RlLmRhdGEpIHtcbiAgICAgIGRhdGEgPSBtZXJnZUNsYXNzRGF0YShjaGlsZE5vZGUuZGF0YSwgZGF0YSk7XG4gICAgfVxuICB9XG4gIHdoaWxlIChpc0RlZihwYXJlbnROb2RlID0gcGFyZW50Tm9kZS5wYXJlbnQpKSB7XG4gICAgaWYgKHBhcmVudE5vZGUgJiYgcGFyZW50Tm9kZS5kYXRhKSB7XG4gICAgICBkYXRhID0gbWVyZ2VDbGFzc0RhdGEoZGF0YSwgcGFyZW50Tm9kZS5kYXRhKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlbmRlckNsYXNzKGRhdGEuc3RhdGljQ2xhc3MsIGRhdGEuY2xhc3MpXG59XG5cbmZ1bmN0aW9uIG1lcmdlQ2xhc3NEYXRhIChjaGlsZCwgcGFyZW50KSB7XG4gIHJldHVybiB7XG4gICAgc3RhdGljQ2xhc3M6IGNvbmNhdChjaGlsZC5zdGF0aWNDbGFzcywgcGFyZW50LnN0YXRpY0NsYXNzKSxcbiAgICBjbGFzczogaXNEZWYoY2hpbGQuY2xhc3MpXG4gICAgICA/IFtjaGlsZC5jbGFzcywgcGFyZW50LmNsYXNzXVxuICAgICAgOiBwYXJlbnQuY2xhc3NcbiAgfVxufVxuXG5mdW5jdGlvbiByZW5kZXJDbGFzcyAoXG4gIHN0YXRpY0NsYXNzLFxuICBkeW5hbWljQ2xhc3Ncbikge1xuICBpZiAoaXNEZWYoc3RhdGljQ2xhc3MpIHx8IGlzRGVmKGR5bmFtaWNDbGFzcykpIHtcbiAgICByZXR1cm4gY29uY2F0KHN0YXRpY0NsYXNzLCBzdHJpbmdpZnlDbGFzcyhkeW5hbWljQ2xhc3MpKVxuICB9XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gIHJldHVybiAnJ1xufVxuXG5mdW5jdGlvbiBjb25jYXQgKGEsIGIpIHtcbiAgcmV0dXJuIGEgPyBiID8gKGEgKyAnICcgKyBiKSA6IGEgOiAoYiB8fCAnJylcbn1cblxuZnVuY3Rpb24gc3RyaW5naWZ5Q2xhc3MgKHZhbHVlKSB7XG4gIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgIHJldHVybiBzdHJpbmdpZnlBcnJheSh2YWx1ZSlcbiAgfVxuICBpZiAoaXNPYmplY3QodmFsdWUpKSB7XG4gICAgcmV0dXJuIHN0cmluZ2lmeU9iamVjdCh2YWx1ZSlcbiAgfVxuICBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xuICAgIHJldHVybiB2YWx1ZVxuICB9XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gIHJldHVybiAnJ1xufVxuXG5mdW5jdGlvbiBzdHJpbmdpZnlBcnJheSAodmFsdWUpIHtcbiAgdmFyIHJlcyA9ICcnO1xuICB2YXIgc3RyaW5naWZpZWQ7XG4gIGZvciAodmFyIGkgPSAwLCBsID0gdmFsdWUubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgaWYgKGlzRGVmKHN0cmluZ2lmaWVkID0gc3RyaW5naWZ5Q2xhc3ModmFsdWVbaV0pKSAmJiBzdHJpbmdpZmllZCAhPT0gJycpIHtcbiAgICAgIGlmIChyZXMpIHsgcmVzICs9ICcgJzsgfVxuICAgICAgcmVzICs9IHN0cmluZ2lmaWVkO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzXG59XG5cbmZ1bmN0aW9uIHN0cmluZ2lmeU9iamVjdCAodmFsdWUpIHtcbiAgdmFyIHJlcyA9ICcnO1xuICBmb3IgKHZhciBrZXkgaW4gdmFsdWUpIHtcbiAgICBpZiAodmFsdWVba2V5XSkge1xuICAgICAgaWYgKHJlcykgeyByZXMgKz0gJyAnOyB9XG4gICAgICByZXMgKz0ga2V5O1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzXG59XG5cbi8qICAqL1xuXG52YXIgbmFtZXNwYWNlTWFwID0ge1xuICBzdmc6ICdodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZycsXG4gIG1hdGg6ICdodHRwOi8vd3d3LnczLm9yZy8xOTk4L01hdGgvTWF0aE1MJ1xufTtcblxudmFyIGlzSFRNTFRhZyA9IG1ha2VNYXAoXG4gICdodG1sLGJvZHksYmFzZSxoZWFkLGxpbmssbWV0YSxzdHlsZSx0aXRsZSwnICtcbiAgJ2FkZHJlc3MsYXJ0aWNsZSxhc2lkZSxmb290ZXIsaGVhZGVyLGgxLGgyLGgzLGg0LGg1LGg2LGhncm91cCxuYXYsc2VjdGlvbiwnICtcbiAgJ2RpdixkZCxkbCxkdCxmaWdjYXB0aW9uLGZpZ3VyZSxwaWN0dXJlLGhyLGltZyxsaSxtYWluLG9sLHAscHJlLHVsLCcgK1xuICAnYSxiLGFiYnIsYmRpLGJkbyxicixjaXRlLGNvZGUsZGF0YSxkZm4sZW0saSxrYmQsbWFyayxxLHJwLHJ0LHJ0YyxydWJ5LCcgK1xuICAncyxzYW1wLHNtYWxsLHNwYW4sc3Ryb25nLHN1YixzdXAsdGltZSx1LHZhcix3YnIsYXJlYSxhdWRpbyxtYXAsdHJhY2ssdmlkZW8sJyArXG4gICdlbWJlZCxvYmplY3QscGFyYW0sc291cmNlLGNhbnZhcyxzY3JpcHQsbm9zY3JpcHQsZGVsLGlucywnICtcbiAgJ2NhcHRpb24sY29sLGNvbGdyb3VwLHRhYmxlLHRoZWFkLHRib2R5LHRkLHRoLHRyLCcgK1xuICAnYnV0dG9uLGRhdGFsaXN0LGZpZWxkc2V0LGZvcm0saW5wdXQsbGFiZWwsbGVnZW5kLG1ldGVyLG9wdGdyb3VwLG9wdGlvbiwnICtcbiAgJ291dHB1dCxwcm9ncmVzcyxzZWxlY3QsdGV4dGFyZWEsJyArXG4gICdkZXRhaWxzLGRpYWxvZyxtZW51LG1lbnVpdGVtLHN1bW1hcnksJyArXG4gICdjb250ZW50LGVsZW1lbnQsc2hhZG93LHRlbXBsYXRlLGJsb2NrcXVvdGUsaWZyYW1lLHRmb290J1xuKTtcblxuLy8gdGhpcyBtYXAgaXMgaW50ZW50aW9uYWxseSBzZWxlY3RpdmUsIG9ubHkgY292ZXJpbmcgU1ZHIGVsZW1lbnRzIHRoYXQgbWF5XG4vLyBjb250YWluIGNoaWxkIGVsZW1lbnRzLlxudmFyIGlzU1ZHID0gbWFrZU1hcChcbiAgJ3N2ZyxhbmltYXRlLGNpcmNsZSxjbGlwcGF0aCxjdXJzb3IsZGVmcyxkZXNjLGVsbGlwc2UsZmlsdGVyLGZvbnQtZmFjZSwnICtcbiAgJ2ZvcmVpZ25vYmplY3QsZyxnbHlwaCxpbWFnZSxsaW5lLG1hcmtlcixtYXNrLG1pc3NpbmctZ2x5cGgscGF0aCxwYXR0ZXJuLCcgK1xuICAncG9seWdvbixwb2x5bGluZSxyZWN0LHN3aXRjaCxzeW1ib2wsdGV4dCx0ZXh0cGF0aCx0c3Bhbix1c2UsdmlldycsXG4gIHRydWVcbik7XG5cbnZhciBpc1ByZVRhZyA9IGZ1bmN0aW9uICh0YWcpIHsgcmV0dXJuIHRhZyA9PT0gJ3ByZSc7IH07XG5cbnZhciBpc1Jlc2VydmVkVGFnID0gZnVuY3Rpb24gKHRhZykge1xuICByZXR1cm4gaXNIVE1MVGFnKHRhZykgfHwgaXNTVkcodGFnKVxufTtcblxuZnVuY3Rpb24gZ2V0VGFnTmFtZXNwYWNlICh0YWcpIHtcbiAgaWYgKGlzU1ZHKHRhZykpIHtcbiAgICByZXR1cm4gJ3N2ZydcbiAgfVxuICAvLyBiYXNpYyBzdXBwb3J0IGZvciBNYXRoTUxcbiAgLy8gbm90ZSBpdCBkb2Vzbid0IHN1cHBvcnQgb3RoZXIgTWF0aE1MIGVsZW1lbnRzIGJlaW5nIGNvbXBvbmVudCByb290c1xuICBpZiAodGFnID09PSAnbWF0aCcpIHtcbiAgICByZXR1cm4gJ21hdGgnXG4gIH1cbn1cblxudmFyIHVua25vd25FbGVtZW50Q2FjaGUgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuZnVuY3Rpb24gaXNVbmtub3duRWxlbWVudCAodGFnKSB7XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICBpZiAoIWluQnJvd3Nlcikge1xuICAgIHJldHVybiB0cnVlXG4gIH1cbiAgaWYgKGlzUmVzZXJ2ZWRUYWcodGFnKSkge1xuICAgIHJldHVybiBmYWxzZVxuICB9XG4gIHRhZyA9IHRhZy50b0xvd2VyQ2FzZSgpO1xuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgaWYgKHVua25vd25FbGVtZW50Q2FjaGVbdGFnXSAhPSBudWxsKSB7XG4gICAgcmV0dXJuIHVua25vd25FbGVtZW50Q2FjaGVbdGFnXVxuICB9XG4gIHZhciBlbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQodGFnKTtcbiAgaWYgKHRhZy5pbmRleE9mKCctJykgPiAtMSkge1xuICAgIC8vIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9hLzI4MjEwMzY0LzEwNzAyNDRcbiAgICByZXR1cm4gKHVua25vd25FbGVtZW50Q2FjaGVbdGFnXSA9IChcbiAgICAgIGVsLmNvbnN0cnVjdG9yID09PSB3aW5kb3cuSFRNTFVua25vd25FbGVtZW50IHx8XG4gICAgICBlbC5jb25zdHJ1Y3RvciA9PT0gd2luZG93LkhUTUxFbGVtZW50XG4gICAgKSlcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gKHVua25vd25FbGVtZW50Q2FjaGVbdGFnXSA9IC9IVE1MVW5rbm93bkVsZW1lbnQvLnRlc3QoZWwudG9TdHJpbmcoKSkpXG4gIH1cbn1cblxudmFyIGlzVGV4dElucHV0VHlwZSA9IG1ha2VNYXAoJ3RleHQsbnVtYmVyLHBhc3N3b3JkLHNlYXJjaCxlbWFpbCx0ZWwsdXJsJyk7XG5cbi8qICAqL1xuXG4vKipcbiAqIFF1ZXJ5IGFuIGVsZW1lbnQgc2VsZWN0b3IgaWYgaXQncyBub3QgYW4gZWxlbWVudCBhbHJlYWR5LlxuICovXG5mdW5jdGlvbiBxdWVyeSAoZWwpIHtcbiAgaWYgKHR5cGVvZiBlbCA9PT0gJ3N0cmluZycpIHtcbiAgICB2YXIgc2VsZWN0ZWQgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKGVsKTtcbiAgICBpZiAoIXNlbGVjdGVkKSB7XG4gICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIHdhcm4oXG4gICAgICAgICdDYW5ub3QgZmluZCBlbGVtZW50OiAnICsgZWxcbiAgICAgICk7XG4gICAgICByZXR1cm4gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2JylcbiAgICB9XG4gICAgcmV0dXJuIHNlbGVjdGVkXG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGVsXG4gIH1cbn1cblxuLyogICovXG5cbmZ1bmN0aW9uIGNyZWF0ZUVsZW1lbnQkMSAodGFnTmFtZSwgdm5vZGUpIHtcbiAgdmFyIGVsbSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQodGFnTmFtZSk7XG4gIGlmICh0YWdOYW1lICE9PSAnc2VsZWN0Jykge1xuICAgIHJldHVybiBlbG1cbiAgfVxuICAvLyBmYWxzZSBvciBudWxsIHdpbGwgcmVtb3ZlIHRoZSBhdHRyaWJ1dGUgYnV0IHVuZGVmaW5lZCB3aWxsIG5vdFxuICBpZiAodm5vZGUuZGF0YSAmJiB2bm9kZS5kYXRhLmF0dHJzICYmIHZub2RlLmRhdGEuYXR0cnMubXVsdGlwbGUgIT09IHVuZGVmaW5lZCkge1xuICAgIGVsbS5zZXRBdHRyaWJ1dGUoJ211bHRpcGxlJywgJ211bHRpcGxlJyk7XG4gIH1cbiAgcmV0dXJuIGVsbVxufVxuXG5mdW5jdGlvbiBjcmVhdGVFbGVtZW50TlMgKG5hbWVzcGFjZSwgdGFnTmFtZSkge1xuICByZXR1cm4gZG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TKG5hbWVzcGFjZU1hcFtuYW1lc3BhY2VdLCB0YWdOYW1lKVxufVxuXG5mdW5jdGlvbiBjcmVhdGVUZXh0Tm9kZSAodGV4dCkge1xuICByZXR1cm4gZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUodGV4dClcbn1cblxuZnVuY3Rpb24gY3JlYXRlQ29tbWVudCAodGV4dCkge1xuICByZXR1cm4gZG9jdW1lbnQuY3JlYXRlQ29tbWVudCh0ZXh0KVxufVxuXG5mdW5jdGlvbiBpbnNlcnRCZWZvcmUgKHBhcmVudE5vZGUsIG5ld05vZGUsIHJlZmVyZW5jZU5vZGUpIHtcbiAgcGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUobmV3Tm9kZSwgcmVmZXJlbmNlTm9kZSk7XG59XG5cbmZ1bmN0aW9uIHJlbW92ZUNoaWxkIChub2RlLCBjaGlsZCkge1xuICBub2RlLnJlbW92ZUNoaWxkKGNoaWxkKTtcbn1cblxuZnVuY3Rpb24gYXBwZW5kQ2hpbGQgKG5vZGUsIGNoaWxkKSB7XG4gIG5vZGUuYXBwZW5kQ2hpbGQoY2hpbGQpO1xufVxuXG5mdW5jdGlvbiBwYXJlbnROb2RlIChub2RlKSB7XG4gIHJldHVybiBub2RlLnBhcmVudE5vZGVcbn1cblxuZnVuY3Rpb24gbmV4dFNpYmxpbmcgKG5vZGUpIHtcbiAgcmV0dXJuIG5vZGUubmV4dFNpYmxpbmdcbn1cblxuZnVuY3Rpb24gdGFnTmFtZSAobm9kZSkge1xuICByZXR1cm4gbm9kZS50YWdOYW1lXG59XG5cbmZ1bmN0aW9uIHNldFRleHRDb250ZW50IChub2RlLCB0ZXh0KSB7XG4gIG5vZGUudGV4dENvbnRlbnQgPSB0ZXh0O1xufVxuXG5mdW5jdGlvbiBzZXRTdHlsZVNjb3BlIChub2RlLCBzY29wZUlkKSB7XG4gIG5vZGUuc2V0QXR0cmlidXRlKHNjb3BlSWQsICcnKTtcbn1cblxudmFyIG5vZGVPcHMgPSAvKiNfX1BVUkVfXyovT2JqZWN0LmZyZWV6ZSh7XG4gIGNyZWF0ZUVsZW1lbnQ6IGNyZWF0ZUVsZW1lbnQkMSxcbiAgY3JlYXRlRWxlbWVudE5TOiBjcmVhdGVFbGVtZW50TlMsXG4gIGNyZWF0ZVRleHROb2RlOiBjcmVhdGVUZXh0Tm9kZSxcbiAgY3JlYXRlQ29tbWVudDogY3JlYXRlQ29tbWVudCxcbiAgaW5zZXJ0QmVmb3JlOiBpbnNlcnRCZWZvcmUsXG4gIHJlbW92ZUNoaWxkOiByZW1vdmVDaGlsZCxcbiAgYXBwZW5kQ2hpbGQ6IGFwcGVuZENoaWxkLFxuICBwYXJlbnROb2RlOiBwYXJlbnROb2RlLFxuICBuZXh0U2libGluZzogbmV4dFNpYmxpbmcsXG4gIHRhZ05hbWU6IHRhZ05hbWUsXG4gIHNldFRleHRDb250ZW50OiBzZXRUZXh0Q29udGVudCxcbiAgc2V0U3R5bGVTY29wZTogc2V0U3R5bGVTY29wZVxufSk7XG5cbi8qICAqL1xuXG52YXIgcmVmID0ge1xuICBjcmVhdGU6IGZ1bmN0aW9uIGNyZWF0ZSAoXywgdm5vZGUpIHtcbiAgICByZWdpc3RlclJlZih2bm9kZSk7XG4gIH0sXG4gIHVwZGF0ZTogZnVuY3Rpb24gdXBkYXRlIChvbGRWbm9kZSwgdm5vZGUpIHtcbiAgICBpZiAob2xkVm5vZGUuZGF0YS5yZWYgIT09IHZub2RlLmRhdGEucmVmKSB7XG4gICAgICByZWdpc3RlclJlZihvbGRWbm9kZSwgdHJ1ZSk7XG4gICAgICByZWdpc3RlclJlZih2bm9kZSk7XG4gICAgfVxuICB9LFxuICBkZXN0cm95OiBmdW5jdGlvbiBkZXN0cm95ICh2bm9kZSkge1xuICAgIHJlZ2lzdGVyUmVmKHZub2RlLCB0cnVlKTtcbiAgfVxufTtcblxuZnVuY3Rpb24gcmVnaXN0ZXJSZWYgKHZub2RlLCBpc1JlbW92YWwpIHtcbiAgdmFyIGtleSA9IHZub2RlLmRhdGEucmVmO1xuICBpZiAoIWlzRGVmKGtleSkpIHsgcmV0dXJuIH1cblxuICB2YXIgdm0gPSB2bm9kZS5jb250ZXh0O1xuICB2YXIgcmVmID0gdm5vZGUuY29tcG9uZW50SW5zdGFuY2UgfHwgdm5vZGUuZWxtO1xuICB2YXIgcmVmcyA9IHZtLiRyZWZzO1xuICBpZiAoaXNSZW1vdmFsKSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkocmVmc1trZXldKSkge1xuICAgICAgcmVtb3ZlKHJlZnNba2V5XSwgcmVmKTtcbiAgICB9IGVsc2UgaWYgKHJlZnNba2V5XSA9PT0gcmVmKSB7XG4gICAgICByZWZzW2tleV0gPSB1bmRlZmluZWQ7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGlmICh2bm9kZS5kYXRhLnJlZkluRm9yKSB7XG4gICAgICBpZiAoIUFycmF5LmlzQXJyYXkocmVmc1trZXldKSkge1xuICAgICAgICByZWZzW2tleV0gPSBbcmVmXTtcbiAgICAgIH0gZWxzZSBpZiAocmVmc1trZXldLmluZGV4T2YocmVmKSA8IDApIHtcbiAgICAgICAgLy8gJGZsb3ctZGlzYWJsZS1saW5lXG4gICAgICAgIHJlZnNba2V5XS5wdXNoKHJlZik7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlZnNba2V5XSA9IHJlZjtcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBWaXJ0dWFsIERPTSBwYXRjaGluZyBhbGdvcml0aG0gYmFzZWQgb24gU25hYmJkb20gYnlcbiAqIFNpbW9uIEZyaWlzIFZpbmR1bSAoQHBhbGRlcGluZClcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZVxuICogaHR0cHM6Ly9naXRodWIuY29tL3BhbGRlcGluZC9zbmFiYmRvbS9ibG9iL21hc3Rlci9MSUNFTlNFXG4gKlxuICogbW9kaWZpZWQgYnkgRXZhbiBZb3UgKEB5eXg5OTA4MDMpXG4gKlxuICogTm90IHR5cGUtY2hlY2tpbmcgdGhpcyBiZWNhdXNlIHRoaXMgZmlsZSBpcyBwZXJmLWNyaXRpY2FsIGFuZCB0aGUgY29zdFxuICogb2YgbWFraW5nIGZsb3cgdW5kZXJzdGFuZCBpdCBpcyBub3Qgd29ydGggaXQuXG4gKi9cblxudmFyIGVtcHR5Tm9kZSA9IG5ldyBWTm9kZSgnJywge30sIFtdKTtcblxudmFyIGhvb2tzID0gWydjcmVhdGUnLCAnYWN0aXZhdGUnLCAndXBkYXRlJywgJ3JlbW92ZScsICdkZXN0cm95J107XG5cbmZ1bmN0aW9uIHNhbWVWbm9kZSAoYSwgYikge1xuICByZXR1cm4gKFxuICAgIGEua2V5ID09PSBiLmtleSAmJlxuICAgIGEuYXN5bmNGYWN0b3J5ID09PSBiLmFzeW5jRmFjdG9yeSAmJiAoXG4gICAgICAoXG4gICAgICAgIGEudGFnID09PSBiLnRhZyAmJlxuICAgICAgICBhLmlzQ29tbWVudCA9PT0gYi5pc0NvbW1lbnQgJiZcbiAgICAgICAgaXNEZWYoYS5kYXRhKSA9PT0gaXNEZWYoYi5kYXRhKSAmJlxuICAgICAgICBzYW1lSW5wdXRUeXBlKGEsIGIpXG4gICAgICApIHx8IChcbiAgICAgICAgaXNUcnVlKGEuaXNBc3luY1BsYWNlaG9sZGVyKSAmJlxuICAgICAgICBpc1VuZGVmKGIuYXN5bmNGYWN0b3J5LmVycm9yKVxuICAgICAgKVxuICAgIClcbiAgKVxufVxuXG5mdW5jdGlvbiBzYW1lSW5wdXRUeXBlIChhLCBiKSB7XG4gIGlmIChhLnRhZyAhPT0gJ2lucHV0JykgeyByZXR1cm4gdHJ1ZSB9XG4gIHZhciBpO1xuICB2YXIgdHlwZUEgPSBpc0RlZihpID0gYS5kYXRhKSAmJiBpc0RlZihpID0gaS5hdHRycykgJiYgaS50eXBlO1xuICB2YXIgdHlwZUIgPSBpc0RlZihpID0gYi5kYXRhKSAmJiBpc0RlZihpID0gaS5hdHRycykgJiYgaS50eXBlO1xuICByZXR1cm4gdHlwZUEgPT09IHR5cGVCIHx8IGlzVGV4dElucHV0VHlwZSh0eXBlQSkgJiYgaXNUZXh0SW5wdXRUeXBlKHR5cGVCKVxufVxuXG5mdW5jdGlvbiBjcmVhdGVLZXlUb09sZElkeCAoY2hpbGRyZW4sIGJlZ2luSWR4LCBlbmRJZHgpIHtcbiAgdmFyIGksIGtleTtcbiAgdmFyIG1hcCA9IHt9O1xuICBmb3IgKGkgPSBiZWdpbklkeDsgaSA8PSBlbmRJZHg7ICsraSkge1xuICAgIGtleSA9IGNoaWxkcmVuW2ldLmtleTtcbiAgICBpZiAoaXNEZWYoa2V5KSkgeyBtYXBba2V5XSA9IGk7IH1cbiAgfVxuICByZXR1cm4gbWFwXG59XG5cbmZ1bmN0aW9uIGNyZWF0ZVBhdGNoRnVuY3Rpb24gKGJhY2tlbmQpIHtcbiAgdmFyIGksIGo7XG4gIHZhciBjYnMgPSB7fTtcblxuICB2YXIgbW9kdWxlcyA9IGJhY2tlbmQubW9kdWxlcztcbiAgdmFyIG5vZGVPcHMgPSBiYWNrZW5kLm5vZGVPcHM7XG5cbiAgZm9yIChpID0gMDsgaSA8IGhvb2tzLmxlbmd0aDsgKytpKSB7XG4gICAgY2JzW2hvb2tzW2ldXSA9IFtdO1xuICAgIGZvciAoaiA9IDA7IGogPCBtb2R1bGVzLmxlbmd0aDsgKytqKSB7XG4gICAgICBpZiAoaXNEZWYobW9kdWxlc1tqXVtob29rc1tpXV0pKSB7XG4gICAgICAgIGNic1tob29rc1tpXV0ucHVzaChtb2R1bGVzW2pdW2hvb2tzW2ldXSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gZW1wdHlOb2RlQXQgKGVsbSkge1xuICAgIHJldHVybiBuZXcgVk5vZGUobm9kZU9wcy50YWdOYW1lKGVsbSkudG9Mb3dlckNhc2UoKSwge30sIFtdLCB1bmRlZmluZWQsIGVsbSlcbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZVJtQ2IgKGNoaWxkRWxtLCBsaXN0ZW5lcnMpIHtcbiAgICBmdW5jdGlvbiByZW1vdmUkJDEgKCkge1xuICAgICAgaWYgKC0tcmVtb3ZlJCQxLmxpc3RlbmVycyA9PT0gMCkge1xuICAgICAgICByZW1vdmVOb2RlKGNoaWxkRWxtKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmVtb3ZlJCQxLmxpc3RlbmVycyA9IGxpc3RlbmVycztcbiAgICByZXR1cm4gcmVtb3ZlJCQxXG4gIH1cblxuICBmdW5jdGlvbiByZW1vdmVOb2RlIChlbCkge1xuICAgIHZhciBwYXJlbnQgPSBub2RlT3BzLnBhcmVudE5vZGUoZWwpO1xuICAgIC8vIGVsZW1lbnQgbWF5IGhhdmUgYWxyZWFkeSBiZWVuIHJlbW92ZWQgZHVlIHRvIHYtaHRtbCAvIHYtdGV4dFxuICAgIGlmIChpc0RlZihwYXJlbnQpKSB7XG4gICAgICBub2RlT3BzLnJlbW92ZUNoaWxkKHBhcmVudCwgZWwpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGlzVW5rbm93bkVsZW1lbnQkJDEgKHZub2RlLCBpblZQcmUpIHtcbiAgICByZXR1cm4gKFxuICAgICAgIWluVlByZSAmJlxuICAgICAgIXZub2RlLm5zICYmXG4gICAgICAhKFxuICAgICAgICBjb25maWcuaWdub3JlZEVsZW1lbnRzLmxlbmd0aCAmJlxuICAgICAgICBjb25maWcuaWdub3JlZEVsZW1lbnRzLnNvbWUoZnVuY3Rpb24gKGlnbm9yZSkge1xuICAgICAgICAgIHJldHVybiBpc1JlZ0V4cChpZ25vcmUpXG4gICAgICAgICAgICA/IGlnbm9yZS50ZXN0KHZub2RlLnRhZylcbiAgICAgICAgICAgIDogaWdub3JlID09PSB2bm9kZS50YWdcbiAgICAgICAgfSlcbiAgICAgICkgJiZcbiAgICAgIGNvbmZpZy5pc1Vua25vd25FbGVtZW50KHZub2RlLnRhZylcbiAgICApXG4gIH1cblxuICB2YXIgY3JlYXRpbmdFbG1JblZQcmUgPSAwO1xuXG4gIGZ1bmN0aW9uIGNyZWF0ZUVsbSAoXG4gICAgdm5vZGUsXG4gICAgaW5zZXJ0ZWRWbm9kZVF1ZXVlLFxuICAgIHBhcmVudEVsbSxcbiAgICByZWZFbG0sXG4gICAgbmVzdGVkLFxuICAgIG93bmVyQXJyYXksXG4gICAgaW5kZXhcbiAgKSB7XG4gICAgaWYgKGlzRGVmKHZub2RlLmVsbSkgJiYgaXNEZWYob3duZXJBcnJheSkpIHtcbiAgICAgIC8vIFRoaXMgdm5vZGUgd2FzIHVzZWQgaW4gYSBwcmV2aW91cyByZW5kZXIhXG4gICAgICAvLyBub3cgaXQncyB1c2VkIGFzIGEgbmV3IG5vZGUsIG92ZXJ3cml0aW5nIGl0cyBlbG0gd291bGQgY2F1c2VcbiAgICAgIC8vIHBvdGVudGlhbCBwYXRjaCBlcnJvcnMgZG93biB0aGUgcm9hZCB3aGVuIGl0J3MgdXNlZCBhcyBhbiBpbnNlcnRpb25cbiAgICAgIC8vIHJlZmVyZW5jZSBub2RlLiBJbnN0ZWFkLCB3ZSBjbG9uZSB0aGUgbm9kZSBvbi1kZW1hbmQgYmVmb3JlIGNyZWF0aW5nXG4gICAgICAvLyBhc3NvY2lhdGVkIERPTSBlbGVtZW50IGZvciBpdC5cbiAgICAgIHZub2RlID0gb3duZXJBcnJheVtpbmRleF0gPSBjbG9uZVZOb2RlKHZub2RlKTtcbiAgICB9XG5cbiAgICB2bm9kZS5pc1Jvb3RJbnNlcnQgPSAhbmVzdGVkOyAvLyBmb3IgdHJhbnNpdGlvbiBlbnRlciBjaGVja1xuICAgIGlmIChjcmVhdGVDb21wb25lbnQodm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSwgcGFyZW50RWxtLCByZWZFbG0pKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICB2YXIgZGF0YSA9IHZub2RlLmRhdGE7XG4gICAgdmFyIGNoaWxkcmVuID0gdm5vZGUuY2hpbGRyZW47XG4gICAgdmFyIHRhZyA9IHZub2RlLnRhZztcbiAgICBpZiAoaXNEZWYodGFnKSkge1xuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgaWYgKGRhdGEgJiYgZGF0YS5wcmUpIHtcbiAgICAgICAgICBjcmVhdGluZ0VsbUluVlByZSsrO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpc1Vua25vd25FbGVtZW50JCQxKHZub2RlLCBjcmVhdGluZ0VsbUluVlByZSkpIHtcbiAgICAgICAgICB3YXJuKFxuICAgICAgICAgICAgJ1Vua25vd24gY3VzdG9tIGVsZW1lbnQ6IDwnICsgdGFnICsgJz4gLSBkaWQgeW91ICcgK1xuICAgICAgICAgICAgJ3JlZ2lzdGVyIHRoZSBjb21wb25lbnQgY29ycmVjdGx5PyBGb3IgcmVjdXJzaXZlIGNvbXBvbmVudHMsICcgK1xuICAgICAgICAgICAgJ21ha2Ugc3VyZSB0byBwcm92aWRlIHRoZSBcIm5hbWVcIiBvcHRpb24uJyxcbiAgICAgICAgICAgIHZub2RlLmNvbnRleHRcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHZub2RlLmVsbSA9IHZub2RlLm5zXG4gICAgICAgID8gbm9kZU9wcy5jcmVhdGVFbGVtZW50TlModm5vZGUubnMsIHRhZylcbiAgICAgICAgOiBub2RlT3BzLmNyZWF0ZUVsZW1lbnQodGFnLCB2bm9kZSk7XG4gICAgICBzZXRTY29wZSh2bm9kZSk7XG5cbiAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAge1xuICAgICAgICBjcmVhdGVDaGlsZHJlbih2bm9kZSwgY2hpbGRyZW4sIGluc2VydGVkVm5vZGVRdWV1ZSk7XG4gICAgICAgIGlmIChpc0RlZihkYXRhKSkge1xuICAgICAgICAgIGludm9rZUNyZWF0ZUhvb2tzKHZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUpO1xuICAgICAgICB9XG4gICAgICAgIGluc2VydChwYXJlbnRFbG0sIHZub2RlLmVsbSwgcmVmRWxtKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgZGF0YSAmJiBkYXRhLnByZSkge1xuICAgICAgICBjcmVhdGluZ0VsbUluVlByZS0tO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoaXNUcnVlKHZub2RlLmlzQ29tbWVudCkpIHtcbiAgICAgIHZub2RlLmVsbSA9IG5vZGVPcHMuY3JlYXRlQ29tbWVudCh2bm9kZS50ZXh0KTtcbiAgICAgIGluc2VydChwYXJlbnRFbG0sIHZub2RlLmVsbSwgcmVmRWxtKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdm5vZGUuZWxtID0gbm9kZU9wcy5jcmVhdGVUZXh0Tm9kZSh2bm9kZS50ZXh0KTtcbiAgICAgIGluc2VydChwYXJlbnRFbG0sIHZub2RlLmVsbSwgcmVmRWxtKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBjcmVhdGVDb21wb25lbnQgKHZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUsIHBhcmVudEVsbSwgcmVmRWxtKSB7XG4gICAgdmFyIGkgPSB2bm9kZS5kYXRhO1xuICAgIGlmIChpc0RlZihpKSkge1xuICAgICAgdmFyIGlzUmVhY3RpdmF0ZWQgPSBpc0RlZih2bm9kZS5jb21wb25lbnRJbnN0YW5jZSkgJiYgaS5rZWVwQWxpdmU7XG4gICAgICBpZiAoaXNEZWYoaSA9IGkuaG9vaykgJiYgaXNEZWYoaSA9IGkuaW5pdCkpIHtcbiAgICAgICAgaSh2bm9kZSwgZmFsc2UgLyogaHlkcmF0aW5nICovKTtcbiAgICAgIH1cbiAgICAgIC8vIGFmdGVyIGNhbGxpbmcgdGhlIGluaXQgaG9vaywgaWYgdGhlIHZub2RlIGlzIGEgY2hpbGQgY29tcG9uZW50XG4gICAgICAvLyBpdCBzaG91bGQndmUgY3JlYXRlZCBhIGNoaWxkIGluc3RhbmNlIGFuZCBtb3VudGVkIGl0LiB0aGUgY2hpbGRcbiAgICAgIC8vIGNvbXBvbmVudCBhbHNvIGhhcyBzZXQgdGhlIHBsYWNlaG9sZGVyIHZub2RlJ3MgZWxtLlxuICAgICAgLy8gaW4gdGhhdCBjYXNlIHdlIGNhbiBqdXN0IHJldHVybiB0aGUgZWxlbWVudCBhbmQgYmUgZG9uZS5cbiAgICAgIGlmIChpc0RlZih2bm9kZS5jb21wb25lbnRJbnN0YW5jZSkpIHtcbiAgICAgICAgaW5pdENvbXBvbmVudCh2bm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlKTtcbiAgICAgICAgaW5zZXJ0KHBhcmVudEVsbSwgdm5vZGUuZWxtLCByZWZFbG0pO1xuICAgICAgICBpZiAoaXNUcnVlKGlzUmVhY3RpdmF0ZWQpKSB7XG4gICAgICAgICAgcmVhY3RpdmF0ZUNvbXBvbmVudCh2bm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlLCBwYXJlbnRFbG0sIHJlZkVsbSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWVcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBpbml0Q29tcG9uZW50ICh2bm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlKSB7XG4gICAgaWYgKGlzRGVmKHZub2RlLmRhdGEucGVuZGluZ0luc2VydCkpIHtcbiAgICAgIGluc2VydGVkVm5vZGVRdWV1ZS5wdXNoLmFwcGx5KGluc2VydGVkVm5vZGVRdWV1ZSwgdm5vZGUuZGF0YS5wZW5kaW5nSW5zZXJ0KTtcbiAgICAgIHZub2RlLmRhdGEucGVuZGluZ0luc2VydCA9IG51bGw7XG4gICAgfVxuICAgIHZub2RlLmVsbSA9IHZub2RlLmNvbXBvbmVudEluc3RhbmNlLiRlbDtcbiAgICBpZiAoaXNQYXRjaGFibGUodm5vZGUpKSB7XG4gICAgICBpbnZva2VDcmVhdGVIb29rcyh2bm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlKTtcbiAgICAgIHNldFNjb3BlKHZub2RlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gZW1wdHkgY29tcG9uZW50IHJvb3QuXG4gICAgICAvLyBza2lwIGFsbCBlbGVtZW50LXJlbGF0ZWQgbW9kdWxlcyBleGNlcHQgZm9yIHJlZiAoIzM0NTUpXG4gICAgICByZWdpc3RlclJlZih2bm9kZSk7XG4gICAgICAvLyBtYWtlIHN1cmUgdG8gaW52b2tlIHRoZSBpbnNlcnQgaG9va1xuICAgICAgaW5zZXJ0ZWRWbm9kZVF1ZXVlLnB1c2godm5vZGUpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHJlYWN0aXZhdGVDb21wb25lbnQgKHZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUsIHBhcmVudEVsbSwgcmVmRWxtKSB7XG4gICAgdmFyIGk7XG4gICAgLy8gaGFjayBmb3IgIzQzMzk6IGEgcmVhY3RpdmF0ZWQgY29tcG9uZW50IHdpdGggaW5uZXIgdHJhbnNpdGlvblxuICAgIC8vIGRvZXMgbm90IHRyaWdnZXIgYmVjYXVzZSB0aGUgaW5uZXIgbm9kZSdzIGNyZWF0ZWQgaG9va3MgYXJlIG5vdCBjYWxsZWRcbiAgICAvLyBhZ2Fpbi4gSXQncyBub3QgaWRlYWwgdG8gaW52b2x2ZSBtb2R1bGUtc3BlY2lmaWMgbG9naWMgaW4gaGVyZSBidXRcbiAgICAvLyB0aGVyZSBkb2Vzbid0IHNlZW0gdG8gYmUgYSBiZXR0ZXIgd2F5IHRvIGRvIGl0LlxuICAgIHZhciBpbm5lck5vZGUgPSB2bm9kZTtcbiAgICB3aGlsZSAoaW5uZXJOb2RlLmNvbXBvbmVudEluc3RhbmNlKSB7XG4gICAgICBpbm5lck5vZGUgPSBpbm5lck5vZGUuY29tcG9uZW50SW5zdGFuY2UuX3Zub2RlO1xuICAgICAgaWYgKGlzRGVmKGkgPSBpbm5lck5vZGUuZGF0YSkgJiYgaXNEZWYoaSA9IGkudHJhbnNpdGlvbikpIHtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGNicy5hY3RpdmF0ZS5sZW5ndGg7ICsraSkge1xuICAgICAgICAgIGNicy5hY3RpdmF0ZVtpXShlbXB0eU5vZGUsIGlubmVyTm9kZSk7XG4gICAgICAgIH1cbiAgICAgICAgaW5zZXJ0ZWRWbm9kZVF1ZXVlLnB1c2goaW5uZXJOb2RlKTtcbiAgICAgICAgYnJlYWtcbiAgICAgIH1cbiAgICB9XG4gICAgLy8gdW5saWtlIGEgbmV3bHkgY3JlYXRlZCBjb21wb25lbnQsXG4gICAgLy8gYSByZWFjdGl2YXRlZCBrZWVwLWFsaXZlIGNvbXBvbmVudCBkb2Vzbid0IGluc2VydCBpdHNlbGZcbiAgICBpbnNlcnQocGFyZW50RWxtLCB2bm9kZS5lbG0sIHJlZkVsbSk7XG4gIH1cblxuICBmdW5jdGlvbiBpbnNlcnQgKHBhcmVudCwgZWxtLCByZWYkJDEpIHtcbiAgICBpZiAoaXNEZWYocGFyZW50KSkge1xuICAgICAgaWYgKGlzRGVmKHJlZiQkMSkpIHtcbiAgICAgICAgaWYgKG5vZGVPcHMucGFyZW50Tm9kZShyZWYkJDEpID09PSBwYXJlbnQpIHtcbiAgICAgICAgICBub2RlT3BzLmluc2VydEJlZm9yZShwYXJlbnQsIGVsbSwgcmVmJCQxKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbm9kZU9wcy5hcHBlbmRDaGlsZChwYXJlbnQsIGVsbSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gY3JlYXRlQ2hpbGRyZW4gKHZub2RlLCBjaGlsZHJlbiwgaW5zZXJ0ZWRWbm9kZVF1ZXVlKSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoY2hpbGRyZW4pKSB7XG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICBjaGVja0R1cGxpY2F0ZUtleXMoY2hpbGRyZW4pO1xuICAgICAgfVxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7ICsraSkge1xuICAgICAgICBjcmVhdGVFbG0oY2hpbGRyZW5baV0sIGluc2VydGVkVm5vZGVRdWV1ZSwgdm5vZGUuZWxtLCBudWxsLCB0cnVlLCBjaGlsZHJlbiwgaSk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChpc1ByaW1pdGl2ZSh2bm9kZS50ZXh0KSkge1xuICAgICAgbm9kZU9wcy5hcHBlbmRDaGlsZCh2bm9kZS5lbG0sIG5vZGVPcHMuY3JlYXRlVGV4dE5vZGUoU3RyaW5nKHZub2RlLnRleHQpKSk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gaXNQYXRjaGFibGUgKHZub2RlKSB7XG4gICAgd2hpbGUgKHZub2RlLmNvbXBvbmVudEluc3RhbmNlKSB7XG4gICAgICB2bm9kZSA9IHZub2RlLmNvbXBvbmVudEluc3RhbmNlLl92bm9kZTtcbiAgICB9XG4gICAgcmV0dXJuIGlzRGVmKHZub2RlLnRhZylcbiAgfVxuXG4gIGZ1bmN0aW9uIGludm9rZUNyZWF0ZUhvb2tzICh2bm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlKSB7XG4gICAgZm9yICh2YXIgaSQxID0gMDsgaSQxIDwgY2JzLmNyZWF0ZS5sZW5ndGg7ICsraSQxKSB7XG4gICAgICBjYnMuY3JlYXRlW2kkMV0oZW1wdHlOb2RlLCB2bm9kZSk7XG4gICAgfVxuICAgIGkgPSB2bm9kZS5kYXRhLmhvb2s7IC8vIFJldXNlIHZhcmlhYmxlXG4gICAgaWYgKGlzRGVmKGkpKSB7XG4gICAgICBpZiAoaXNEZWYoaS5jcmVhdGUpKSB7IGkuY3JlYXRlKGVtcHR5Tm9kZSwgdm5vZGUpOyB9XG4gICAgICBpZiAoaXNEZWYoaS5pbnNlcnQpKSB7IGluc2VydGVkVm5vZGVRdWV1ZS5wdXNoKHZub2RlKTsgfVxuICAgIH1cbiAgfVxuXG4gIC8vIHNldCBzY29wZSBpZCBhdHRyaWJ1dGUgZm9yIHNjb3BlZCBDU1MuXG4gIC8vIHRoaXMgaXMgaW1wbGVtZW50ZWQgYXMgYSBzcGVjaWFsIGNhc2UgdG8gYXZvaWQgdGhlIG92ZXJoZWFkXG4gIC8vIG9mIGdvaW5nIHRocm91Z2ggdGhlIG5vcm1hbCBhdHRyaWJ1dGUgcGF0Y2hpbmcgcHJvY2Vzcy5cbiAgZnVuY3Rpb24gc2V0U2NvcGUgKHZub2RlKSB7XG4gICAgdmFyIGk7XG4gICAgaWYgKGlzRGVmKGkgPSB2bm9kZS5mblNjb3BlSWQpKSB7XG4gICAgICBub2RlT3BzLnNldFN0eWxlU2NvcGUodm5vZGUuZWxtLCBpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIGFuY2VzdG9yID0gdm5vZGU7XG4gICAgICB3aGlsZSAoYW5jZXN0b3IpIHtcbiAgICAgICAgaWYgKGlzRGVmKGkgPSBhbmNlc3Rvci5jb250ZXh0KSAmJiBpc0RlZihpID0gaS4kb3B0aW9ucy5fc2NvcGVJZCkpIHtcbiAgICAgICAgICBub2RlT3BzLnNldFN0eWxlU2NvcGUodm5vZGUuZWxtLCBpKTtcbiAgICAgICAgfVxuICAgICAgICBhbmNlc3RvciA9IGFuY2VzdG9yLnBhcmVudDtcbiAgICAgIH1cbiAgICB9XG4gICAgLy8gZm9yIHNsb3QgY29udGVudCB0aGV5IHNob3VsZCBhbHNvIGdldCB0aGUgc2NvcGVJZCBmcm9tIHRoZSBob3N0IGluc3RhbmNlLlxuICAgIGlmIChpc0RlZihpID0gYWN0aXZlSW5zdGFuY2UpICYmXG4gICAgICBpICE9PSB2bm9kZS5jb250ZXh0ICYmXG4gICAgICBpICE9PSB2bm9kZS5mbkNvbnRleHQgJiZcbiAgICAgIGlzRGVmKGkgPSBpLiRvcHRpb25zLl9zY29wZUlkKVxuICAgICkge1xuICAgICAgbm9kZU9wcy5zZXRTdHlsZVNjb3BlKHZub2RlLmVsbSwgaSk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gYWRkVm5vZGVzIChwYXJlbnRFbG0sIHJlZkVsbSwgdm5vZGVzLCBzdGFydElkeCwgZW5kSWR4LCBpbnNlcnRlZFZub2RlUXVldWUpIHtcbiAgICBmb3IgKDsgc3RhcnRJZHggPD0gZW5kSWR4OyArK3N0YXJ0SWR4KSB7XG4gICAgICBjcmVhdGVFbG0odm5vZGVzW3N0YXJ0SWR4XSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlLCBwYXJlbnRFbG0sIHJlZkVsbSwgZmFsc2UsIHZub2Rlcywgc3RhcnRJZHgpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGludm9rZURlc3Ryb3lIb29rICh2bm9kZSkge1xuICAgIHZhciBpLCBqO1xuICAgIHZhciBkYXRhID0gdm5vZGUuZGF0YTtcbiAgICBpZiAoaXNEZWYoZGF0YSkpIHtcbiAgICAgIGlmIChpc0RlZihpID0gZGF0YS5ob29rKSAmJiBpc0RlZihpID0gaS5kZXN0cm95KSkgeyBpKHZub2RlKTsgfVxuICAgICAgZm9yIChpID0gMDsgaSA8IGNicy5kZXN0cm95Lmxlbmd0aDsgKytpKSB7IGNicy5kZXN0cm95W2ldKHZub2RlKTsgfVxuICAgIH1cbiAgICBpZiAoaXNEZWYoaSA9IHZub2RlLmNoaWxkcmVuKSkge1xuICAgICAgZm9yIChqID0gMDsgaiA8IHZub2RlLmNoaWxkcmVuLmxlbmd0aDsgKytqKSB7XG4gICAgICAgIGludm9rZURlc3Ryb3lIb29rKHZub2RlLmNoaWxkcmVuW2pdKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiByZW1vdmVWbm9kZXMgKHZub2Rlcywgc3RhcnRJZHgsIGVuZElkeCkge1xuICAgIGZvciAoOyBzdGFydElkeCA8PSBlbmRJZHg7ICsrc3RhcnRJZHgpIHtcbiAgICAgIHZhciBjaCA9IHZub2Rlc1tzdGFydElkeF07XG4gICAgICBpZiAoaXNEZWYoY2gpKSB7XG4gICAgICAgIGlmIChpc0RlZihjaC50YWcpKSB7XG4gICAgICAgICAgcmVtb3ZlQW5kSW52b2tlUmVtb3ZlSG9vayhjaCk7XG4gICAgICAgICAgaW52b2tlRGVzdHJveUhvb2soY2gpO1xuICAgICAgICB9IGVsc2UgeyAvLyBUZXh0IG5vZGVcbiAgICAgICAgICByZW1vdmVOb2RlKGNoLmVsbSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiByZW1vdmVBbmRJbnZva2VSZW1vdmVIb29rICh2bm9kZSwgcm0pIHtcbiAgICBpZiAoaXNEZWYocm0pIHx8IGlzRGVmKHZub2RlLmRhdGEpKSB7XG4gICAgICB2YXIgaTtcbiAgICAgIHZhciBsaXN0ZW5lcnMgPSBjYnMucmVtb3ZlLmxlbmd0aCArIDE7XG4gICAgICBpZiAoaXNEZWYocm0pKSB7XG4gICAgICAgIC8vIHdlIGhhdmUgYSByZWN1cnNpdmVseSBwYXNzZWQgZG93biBybSBjYWxsYmFja1xuICAgICAgICAvLyBpbmNyZWFzZSB0aGUgbGlzdGVuZXJzIGNvdW50XG4gICAgICAgIHJtLmxpc3RlbmVycyArPSBsaXN0ZW5lcnM7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBkaXJlY3RseSByZW1vdmluZ1xuICAgICAgICBybSA9IGNyZWF0ZVJtQ2Iodm5vZGUuZWxtLCBsaXN0ZW5lcnMpO1xuICAgICAgfVxuICAgICAgLy8gcmVjdXJzaXZlbHkgaW52b2tlIGhvb2tzIG9uIGNoaWxkIGNvbXBvbmVudCByb290IG5vZGVcbiAgICAgIGlmIChpc0RlZihpID0gdm5vZGUuY29tcG9uZW50SW5zdGFuY2UpICYmIGlzRGVmKGkgPSBpLl92bm9kZSkgJiYgaXNEZWYoaS5kYXRhKSkge1xuICAgICAgICByZW1vdmVBbmRJbnZva2VSZW1vdmVIb29rKGksIHJtKTtcbiAgICAgIH1cbiAgICAgIGZvciAoaSA9IDA7IGkgPCBjYnMucmVtb3ZlLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIGNicy5yZW1vdmVbaV0odm5vZGUsIHJtKTtcbiAgICAgIH1cbiAgICAgIGlmIChpc0RlZihpID0gdm5vZGUuZGF0YS5ob29rKSAmJiBpc0RlZihpID0gaS5yZW1vdmUpKSB7XG4gICAgICAgIGkodm5vZGUsIHJtKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJtKCk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlbW92ZU5vZGUodm5vZGUuZWxtKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiB1cGRhdGVDaGlsZHJlbiAocGFyZW50RWxtLCBvbGRDaCwgbmV3Q2gsIGluc2VydGVkVm5vZGVRdWV1ZSwgcmVtb3ZlT25seSkge1xuICAgIHZhciBvbGRTdGFydElkeCA9IDA7XG4gICAgdmFyIG5ld1N0YXJ0SWR4ID0gMDtcbiAgICB2YXIgb2xkRW5kSWR4ID0gb2xkQ2gubGVuZ3RoIC0gMTtcbiAgICB2YXIgb2xkU3RhcnRWbm9kZSA9IG9sZENoWzBdO1xuICAgIHZhciBvbGRFbmRWbm9kZSA9IG9sZENoW29sZEVuZElkeF07XG4gICAgdmFyIG5ld0VuZElkeCA9IG5ld0NoLmxlbmd0aCAtIDE7XG4gICAgdmFyIG5ld1N0YXJ0Vm5vZGUgPSBuZXdDaFswXTtcbiAgICB2YXIgbmV3RW5kVm5vZGUgPSBuZXdDaFtuZXdFbmRJZHhdO1xuICAgIHZhciBvbGRLZXlUb0lkeCwgaWR4SW5PbGQsIHZub2RlVG9Nb3ZlLCByZWZFbG07XG5cbiAgICAvLyByZW1vdmVPbmx5IGlzIGEgc3BlY2lhbCBmbGFnIHVzZWQgb25seSBieSA8dHJhbnNpdGlvbi1ncm91cD5cbiAgICAvLyB0byBlbnN1cmUgcmVtb3ZlZCBlbGVtZW50cyBzdGF5IGluIGNvcnJlY3QgcmVsYXRpdmUgcG9zaXRpb25zXG4gICAgLy8gZHVyaW5nIGxlYXZpbmcgdHJhbnNpdGlvbnNcbiAgICB2YXIgY2FuTW92ZSA9ICFyZW1vdmVPbmx5O1xuXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIGNoZWNrRHVwbGljYXRlS2V5cyhuZXdDaCk7XG4gICAgfVxuXG4gICAgd2hpbGUgKG9sZFN0YXJ0SWR4IDw9IG9sZEVuZElkeCAmJiBuZXdTdGFydElkeCA8PSBuZXdFbmRJZHgpIHtcbiAgICAgIGlmIChpc1VuZGVmKG9sZFN0YXJ0Vm5vZGUpKSB7XG4gICAgICAgIG9sZFN0YXJ0Vm5vZGUgPSBvbGRDaFsrK29sZFN0YXJ0SWR4XTsgLy8gVm5vZGUgaGFzIGJlZW4gbW92ZWQgbGVmdFxuICAgICAgfSBlbHNlIGlmIChpc1VuZGVmKG9sZEVuZFZub2RlKSkge1xuICAgICAgICBvbGRFbmRWbm9kZSA9IG9sZENoWy0tb2xkRW5kSWR4XTtcbiAgICAgIH0gZWxzZSBpZiAoc2FtZVZub2RlKG9sZFN0YXJ0Vm5vZGUsIG5ld1N0YXJ0Vm5vZGUpKSB7XG4gICAgICAgIHBhdGNoVm5vZGUob2xkU3RhcnRWbm9kZSwgbmV3U3RhcnRWbm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlLCBuZXdDaCwgbmV3U3RhcnRJZHgpO1xuICAgICAgICBvbGRTdGFydFZub2RlID0gb2xkQ2hbKytvbGRTdGFydElkeF07XG4gICAgICAgIG5ld1N0YXJ0Vm5vZGUgPSBuZXdDaFsrK25ld1N0YXJ0SWR4XTtcbiAgICAgIH0gZWxzZSBpZiAoc2FtZVZub2RlKG9sZEVuZFZub2RlLCBuZXdFbmRWbm9kZSkpIHtcbiAgICAgICAgcGF0Y2hWbm9kZShvbGRFbmRWbm9kZSwgbmV3RW5kVm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSwgbmV3Q2gsIG5ld0VuZElkeCk7XG4gICAgICAgIG9sZEVuZFZub2RlID0gb2xkQ2hbLS1vbGRFbmRJZHhdO1xuICAgICAgICBuZXdFbmRWbm9kZSA9IG5ld0NoWy0tbmV3RW5kSWR4XTtcbiAgICAgIH0gZWxzZSBpZiAoc2FtZVZub2RlKG9sZFN0YXJ0Vm5vZGUsIG5ld0VuZFZub2RlKSkgeyAvLyBWbm9kZSBtb3ZlZCByaWdodFxuICAgICAgICBwYXRjaFZub2RlKG9sZFN0YXJ0Vm5vZGUsIG5ld0VuZFZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUsIG5ld0NoLCBuZXdFbmRJZHgpO1xuICAgICAgICBjYW5Nb3ZlICYmIG5vZGVPcHMuaW5zZXJ0QmVmb3JlKHBhcmVudEVsbSwgb2xkU3RhcnRWbm9kZS5lbG0sIG5vZGVPcHMubmV4dFNpYmxpbmcob2xkRW5kVm5vZGUuZWxtKSk7XG4gICAgICAgIG9sZFN0YXJ0Vm5vZGUgPSBvbGRDaFsrK29sZFN0YXJ0SWR4XTtcbiAgICAgICAgbmV3RW5kVm5vZGUgPSBuZXdDaFstLW5ld0VuZElkeF07XG4gICAgICB9IGVsc2UgaWYgKHNhbWVWbm9kZShvbGRFbmRWbm9kZSwgbmV3U3RhcnRWbm9kZSkpIHsgLy8gVm5vZGUgbW92ZWQgbGVmdFxuICAgICAgICBwYXRjaFZub2RlKG9sZEVuZFZub2RlLCBuZXdTdGFydFZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUsIG5ld0NoLCBuZXdTdGFydElkeCk7XG4gICAgICAgIGNhbk1vdmUgJiYgbm9kZU9wcy5pbnNlcnRCZWZvcmUocGFyZW50RWxtLCBvbGRFbmRWbm9kZS5lbG0sIG9sZFN0YXJ0Vm5vZGUuZWxtKTtcbiAgICAgICAgb2xkRW5kVm5vZGUgPSBvbGRDaFstLW9sZEVuZElkeF07XG4gICAgICAgIG5ld1N0YXJ0Vm5vZGUgPSBuZXdDaFsrK25ld1N0YXJ0SWR4XTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChpc1VuZGVmKG9sZEtleVRvSWR4KSkgeyBvbGRLZXlUb0lkeCA9IGNyZWF0ZUtleVRvT2xkSWR4KG9sZENoLCBvbGRTdGFydElkeCwgb2xkRW5kSWR4KTsgfVxuICAgICAgICBpZHhJbk9sZCA9IGlzRGVmKG5ld1N0YXJ0Vm5vZGUua2V5KVxuICAgICAgICAgID8gb2xkS2V5VG9JZHhbbmV3U3RhcnRWbm9kZS5rZXldXG4gICAgICAgICAgOiBmaW5kSWR4SW5PbGQobmV3U3RhcnRWbm9kZSwgb2xkQ2gsIG9sZFN0YXJ0SWR4LCBvbGRFbmRJZHgpO1xuICAgICAgICBpZiAoaXNVbmRlZihpZHhJbk9sZCkpIHsgLy8gTmV3IGVsZW1lbnRcbiAgICAgICAgICBjcmVhdGVFbG0obmV3U3RhcnRWbm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlLCBwYXJlbnRFbG0sIG9sZFN0YXJ0Vm5vZGUuZWxtLCBmYWxzZSwgbmV3Q2gsIG5ld1N0YXJ0SWR4KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2bm9kZVRvTW92ZSA9IG9sZENoW2lkeEluT2xkXTtcbiAgICAgICAgICBpZiAoc2FtZVZub2RlKHZub2RlVG9Nb3ZlLCBuZXdTdGFydFZub2RlKSkge1xuICAgICAgICAgICAgcGF0Y2hWbm9kZSh2bm9kZVRvTW92ZSwgbmV3U3RhcnRWbm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlLCBuZXdDaCwgbmV3U3RhcnRJZHgpO1xuICAgICAgICAgICAgb2xkQ2hbaWR4SW5PbGRdID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgY2FuTW92ZSAmJiBub2RlT3BzLmluc2VydEJlZm9yZShwYXJlbnRFbG0sIHZub2RlVG9Nb3ZlLmVsbSwgb2xkU3RhcnRWbm9kZS5lbG0pO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBzYW1lIGtleSBidXQgZGlmZmVyZW50IGVsZW1lbnQuIHRyZWF0IGFzIG5ldyBlbGVtZW50XG4gICAgICAgICAgICBjcmVhdGVFbG0obmV3U3RhcnRWbm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlLCBwYXJlbnRFbG0sIG9sZFN0YXJ0Vm5vZGUuZWxtLCBmYWxzZSwgbmV3Q2gsIG5ld1N0YXJ0SWR4KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgbmV3U3RhcnRWbm9kZSA9IG5ld0NoWysrbmV3U3RhcnRJZHhdO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAob2xkU3RhcnRJZHggPiBvbGRFbmRJZHgpIHtcbiAgICAgIHJlZkVsbSA9IGlzVW5kZWYobmV3Q2hbbmV3RW5kSWR4ICsgMV0pID8gbnVsbCA6IG5ld0NoW25ld0VuZElkeCArIDFdLmVsbTtcbiAgICAgIGFkZFZub2RlcyhwYXJlbnRFbG0sIHJlZkVsbSwgbmV3Q2gsIG5ld1N0YXJ0SWR4LCBuZXdFbmRJZHgsIGluc2VydGVkVm5vZGVRdWV1ZSk7XG4gICAgfSBlbHNlIGlmIChuZXdTdGFydElkeCA+IG5ld0VuZElkeCkge1xuICAgICAgcmVtb3ZlVm5vZGVzKG9sZENoLCBvbGRTdGFydElkeCwgb2xkRW5kSWR4KTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBjaGVja0R1cGxpY2F0ZUtleXMgKGNoaWxkcmVuKSB7XG4gICAgdmFyIHNlZW5LZXlzID0ge307XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIHZub2RlID0gY2hpbGRyZW5baV07XG4gICAgICB2YXIga2V5ID0gdm5vZGUua2V5O1xuICAgICAgaWYgKGlzRGVmKGtleSkpIHtcbiAgICAgICAgaWYgKHNlZW5LZXlzW2tleV0pIHtcbiAgICAgICAgICB3YXJuKFxuICAgICAgICAgICAgKFwiRHVwbGljYXRlIGtleXMgZGV0ZWN0ZWQ6ICdcIiArIGtleSArIFwiJy4gVGhpcyBtYXkgY2F1c2UgYW4gdXBkYXRlIGVycm9yLlwiKSxcbiAgICAgICAgICAgIHZub2RlLmNvbnRleHRcbiAgICAgICAgICApO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHNlZW5LZXlzW2tleV0gPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gZmluZElkeEluT2xkIChub2RlLCBvbGRDaCwgc3RhcnQsIGVuZCkge1xuICAgIGZvciAodmFyIGkgPSBzdGFydDsgaSA8IGVuZDsgaSsrKSB7XG4gICAgICB2YXIgYyA9IG9sZENoW2ldO1xuICAgICAgaWYgKGlzRGVmKGMpICYmIHNhbWVWbm9kZShub2RlLCBjKSkgeyByZXR1cm4gaSB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gcGF0Y2hWbm9kZSAoXG4gICAgb2xkVm5vZGUsXG4gICAgdm5vZGUsXG4gICAgaW5zZXJ0ZWRWbm9kZVF1ZXVlLFxuICAgIG93bmVyQXJyYXksXG4gICAgaW5kZXgsXG4gICAgcmVtb3ZlT25seVxuICApIHtcbiAgICBpZiAob2xkVm5vZGUgPT09IHZub2RlKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICBpZiAoaXNEZWYodm5vZGUuZWxtKSAmJiBpc0RlZihvd25lckFycmF5KSkge1xuICAgICAgLy8gY2xvbmUgcmV1c2VkIHZub2RlXG4gICAgICB2bm9kZSA9IG93bmVyQXJyYXlbaW5kZXhdID0gY2xvbmVWTm9kZSh2bm9kZSk7XG4gICAgfVxuXG4gICAgdmFyIGVsbSA9IHZub2RlLmVsbSA9IG9sZFZub2RlLmVsbTtcblxuICAgIGlmIChpc1RydWUob2xkVm5vZGUuaXNBc3luY1BsYWNlaG9sZGVyKSkge1xuICAgICAgaWYgKGlzRGVmKHZub2RlLmFzeW5jRmFjdG9yeS5yZXNvbHZlZCkpIHtcbiAgICAgICAgaHlkcmF0ZShvbGRWbm9kZS5lbG0sIHZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdm5vZGUuaXNBc3luY1BsYWNlaG9sZGVyID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIC8vIHJldXNlIGVsZW1lbnQgZm9yIHN0YXRpYyB0cmVlcy5cbiAgICAvLyBub3RlIHdlIG9ubHkgZG8gdGhpcyBpZiB0aGUgdm5vZGUgaXMgY2xvbmVkIC1cbiAgICAvLyBpZiB0aGUgbmV3IG5vZGUgaXMgbm90IGNsb25lZCBpdCBtZWFucyB0aGUgcmVuZGVyIGZ1bmN0aW9ucyBoYXZlIGJlZW5cbiAgICAvLyByZXNldCBieSB0aGUgaG90LXJlbG9hZC1hcGkgYW5kIHdlIG5lZWQgdG8gZG8gYSBwcm9wZXIgcmUtcmVuZGVyLlxuICAgIGlmIChpc1RydWUodm5vZGUuaXNTdGF0aWMpICYmXG4gICAgICBpc1RydWUob2xkVm5vZGUuaXNTdGF0aWMpICYmXG4gICAgICB2bm9kZS5rZXkgPT09IG9sZFZub2RlLmtleSAmJlxuICAgICAgKGlzVHJ1ZSh2bm9kZS5pc0Nsb25lZCkgfHwgaXNUcnVlKHZub2RlLmlzT25jZSkpXG4gICAgKSB7XG4gICAgICB2bm9kZS5jb21wb25lbnRJbnN0YW5jZSA9IG9sZFZub2RlLmNvbXBvbmVudEluc3RhbmNlO1xuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgdmFyIGk7XG4gICAgdmFyIGRhdGEgPSB2bm9kZS5kYXRhO1xuICAgIGlmIChpc0RlZihkYXRhKSAmJiBpc0RlZihpID0gZGF0YS5ob29rKSAmJiBpc0RlZihpID0gaS5wcmVwYXRjaCkpIHtcbiAgICAgIGkob2xkVm5vZGUsIHZub2RlKTtcbiAgICB9XG5cbiAgICB2YXIgb2xkQ2ggPSBvbGRWbm9kZS5jaGlsZHJlbjtcbiAgICB2YXIgY2ggPSB2bm9kZS5jaGlsZHJlbjtcbiAgICBpZiAoaXNEZWYoZGF0YSkgJiYgaXNQYXRjaGFibGUodm5vZGUpKSB7XG4gICAgICBmb3IgKGkgPSAwOyBpIDwgY2JzLnVwZGF0ZS5sZW5ndGg7ICsraSkgeyBjYnMudXBkYXRlW2ldKG9sZFZub2RlLCB2bm9kZSk7IH1cbiAgICAgIGlmIChpc0RlZihpID0gZGF0YS5ob29rKSAmJiBpc0RlZihpID0gaS51cGRhdGUpKSB7IGkob2xkVm5vZGUsIHZub2RlKTsgfVxuICAgIH1cbiAgICBpZiAoaXNVbmRlZih2bm9kZS50ZXh0KSkge1xuICAgICAgaWYgKGlzRGVmKG9sZENoKSAmJiBpc0RlZihjaCkpIHtcbiAgICAgICAgaWYgKG9sZENoICE9PSBjaCkgeyB1cGRhdGVDaGlsZHJlbihlbG0sIG9sZENoLCBjaCwgaW5zZXJ0ZWRWbm9kZVF1ZXVlLCByZW1vdmVPbmx5KTsgfVxuICAgICAgfSBlbHNlIGlmIChpc0RlZihjaCkpIHtcbiAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgICBjaGVja0R1cGxpY2F0ZUtleXMoY2gpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpc0RlZihvbGRWbm9kZS50ZXh0KSkgeyBub2RlT3BzLnNldFRleHRDb250ZW50KGVsbSwgJycpOyB9XG4gICAgICAgIGFkZFZub2RlcyhlbG0sIG51bGwsIGNoLCAwLCBjaC5sZW5ndGggLSAxLCBpbnNlcnRlZFZub2RlUXVldWUpO1xuICAgICAgfSBlbHNlIGlmIChpc0RlZihvbGRDaCkpIHtcbiAgICAgICAgcmVtb3ZlVm5vZGVzKG9sZENoLCAwLCBvbGRDaC5sZW5ndGggLSAxKTtcbiAgICAgIH0gZWxzZSBpZiAoaXNEZWYob2xkVm5vZGUudGV4dCkpIHtcbiAgICAgICAgbm9kZU9wcy5zZXRUZXh0Q29udGVudChlbG0sICcnKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKG9sZFZub2RlLnRleHQgIT09IHZub2RlLnRleHQpIHtcbiAgICAgIG5vZGVPcHMuc2V0VGV4dENvbnRlbnQoZWxtLCB2bm9kZS50ZXh0KTtcbiAgICB9XG4gICAgaWYgKGlzRGVmKGRhdGEpKSB7XG4gICAgICBpZiAoaXNEZWYoaSA9IGRhdGEuaG9vaykgJiYgaXNEZWYoaSA9IGkucG9zdHBhdGNoKSkgeyBpKG9sZFZub2RlLCB2bm9kZSk7IH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBpbnZva2VJbnNlcnRIb29rICh2bm9kZSwgcXVldWUsIGluaXRpYWwpIHtcbiAgICAvLyBkZWxheSBpbnNlcnQgaG9va3MgZm9yIGNvbXBvbmVudCByb290IG5vZGVzLCBpbnZva2UgdGhlbSBhZnRlciB0aGVcbiAgICAvLyBlbGVtZW50IGlzIHJlYWxseSBpbnNlcnRlZFxuICAgIGlmIChpc1RydWUoaW5pdGlhbCkgJiYgaXNEZWYodm5vZGUucGFyZW50KSkge1xuICAgICAgdm5vZGUucGFyZW50LmRhdGEucGVuZGluZ0luc2VydCA9IHF1ZXVlO1xuICAgIH0gZWxzZSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHF1ZXVlLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIHF1ZXVlW2ldLmRhdGEuaG9vay5pbnNlcnQocXVldWVbaV0pO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHZhciBoeWRyYXRpb25CYWlsZWQgPSBmYWxzZTtcbiAgLy8gbGlzdCBvZiBtb2R1bGVzIHRoYXQgY2FuIHNraXAgY3JlYXRlIGhvb2sgZHVyaW5nIGh5ZHJhdGlvbiBiZWNhdXNlIHRoZXlcbiAgLy8gYXJlIGFscmVhZHkgcmVuZGVyZWQgb24gdGhlIGNsaWVudCBvciBoYXMgbm8gbmVlZCBmb3IgaW5pdGlhbGl6YXRpb25cbiAgLy8gTm90ZTogc3R5bGUgaXMgZXhjbHVkZWQgYmVjYXVzZSBpdCByZWxpZXMgb24gaW5pdGlhbCBjbG9uZSBmb3IgZnV0dXJlXG4gIC8vIGRlZXAgdXBkYXRlcyAoIzcwNjMpLlxuICB2YXIgaXNSZW5kZXJlZE1vZHVsZSA9IG1ha2VNYXAoJ2F0dHJzLGNsYXNzLHN0YXRpY0NsYXNzLHN0YXRpY1N0eWxlLGtleScpO1xuXG4gIC8vIE5vdGU6IHRoaXMgaXMgYSBicm93c2VyLW9ubHkgZnVuY3Rpb24gc28gd2UgY2FuIGFzc3VtZSBlbG1zIGFyZSBET00gbm9kZXMuXG4gIGZ1bmN0aW9uIGh5ZHJhdGUgKGVsbSwgdm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSwgaW5WUHJlKSB7XG4gICAgdmFyIGk7XG4gICAgdmFyIHRhZyA9IHZub2RlLnRhZztcbiAgICB2YXIgZGF0YSA9IHZub2RlLmRhdGE7XG4gICAgdmFyIGNoaWxkcmVuID0gdm5vZGUuY2hpbGRyZW47XG4gICAgaW5WUHJlID0gaW5WUHJlIHx8IChkYXRhICYmIGRhdGEucHJlKTtcbiAgICB2bm9kZS5lbG0gPSBlbG07XG5cbiAgICBpZiAoaXNUcnVlKHZub2RlLmlzQ29tbWVudCkgJiYgaXNEZWYodm5vZGUuYXN5bmNGYWN0b3J5KSkge1xuICAgICAgdm5vZGUuaXNBc3luY1BsYWNlaG9sZGVyID0gdHJ1ZTtcbiAgICAgIHJldHVybiB0cnVlXG4gICAgfVxuICAgIC8vIGFzc2VydCBub2RlIG1hdGNoXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIGlmICghYXNzZXJ0Tm9kZU1hdGNoKGVsbSwgdm5vZGUsIGluVlByZSkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICB9XG4gICAgfVxuICAgIGlmIChpc0RlZihkYXRhKSkge1xuICAgICAgaWYgKGlzRGVmKGkgPSBkYXRhLmhvb2spICYmIGlzRGVmKGkgPSBpLmluaXQpKSB7IGkodm5vZGUsIHRydWUgLyogaHlkcmF0aW5nICovKTsgfVxuICAgICAgaWYgKGlzRGVmKGkgPSB2bm9kZS5jb21wb25lbnRJbnN0YW5jZSkpIHtcbiAgICAgICAgLy8gY2hpbGQgY29tcG9uZW50LiBpdCBzaG91bGQgaGF2ZSBoeWRyYXRlZCBpdHMgb3duIHRyZWUuXG4gICAgICAgIGluaXRDb21wb25lbnQodm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSk7XG4gICAgICAgIHJldHVybiB0cnVlXG4gICAgICB9XG4gICAgfVxuICAgIGlmIChpc0RlZih0YWcpKSB7XG4gICAgICBpZiAoaXNEZWYoY2hpbGRyZW4pKSB7XG4gICAgICAgIC8vIGVtcHR5IGVsZW1lbnQsIGFsbG93IGNsaWVudCB0byBwaWNrIHVwIGFuZCBwb3B1bGF0ZSBjaGlsZHJlblxuICAgICAgICBpZiAoIWVsbS5oYXNDaGlsZE5vZGVzKCkpIHtcbiAgICAgICAgICBjcmVhdGVDaGlsZHJlbih2bm9kZSwgY2hpbGRyZW4sIGluc2VydGVkVm5vZGVRdWV1ZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gdi1odG1sIGFuZCBkb21Qcm9wczogaW5uZXJIVE1MXG4gICAgICAgICAgaWYgKGlzRGVmKGkgPSBkYXRhKSAmJiBpc0RlZihpID0gaS5kb21Qcm9wcykgJiYgaXNEZWYoaSA9IGkuaW5uZXJIVE1MKSkge1xuICAgICAgICAgICAgaWYgKGkgIT09IGVsbS5pbm5lckhUTUwpIHtcbiAgICAgICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICAgICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmXG4gICAgICAgICAgICAgICAgdHlwZW9mIGNvbnNvbGUgIT09ICd1bmRlZmluZWQnICYmXG4gICAgICAgICAgICAgICAgIWh5ZHJhdGlvbkJhaWxlZFxuICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICBoeWRyYXRpb25CYWlsZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybignUGFyZW50OiAnLCBlbG0pO1xuICAgICAgICAgICAgICAgIGNvbnNvbGUud2Fybignc2VydmVyIGlubmVySFRNTDogJywgaSk7XG4gICAgICAgICAgICAgICAgY29uc29sZS53YXJuKCdjbGllbnQgaW5uZXJIVE1MOiAnLCBlbG0uaW5uZXJIVE1MKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gaXRlcmF0ZSBhbmQgY29tcGFyZSBjaGlsZHJlbiBsaXN0c1xuICAgICAgICAgICAgdmFyIGNoaWxkcmVuTWF0Y2ggPSB0cnVlO1xuICAgICAgICAgICAgdmFyIGNoaWxkTm9kZSA9IGVsbS5maXJzdENoaWxkO1xuICAgICAgICAgICAgZm9yICh2YXIgaSQxID0gMDsgaSQxIDwgY2hpbGRyZW4ubGVuZ3RoOyBpJDErKykge1xuICAgICAgICAgICAgICBpZiAoIWNoaWxkTm9kZSB8fCAhaHlkcmF0ZShjaGlsZE5vZGUsIGNoaWxkcmVuW2kkMV0sIGluc2VydGVkVm5vZGVRdWV1ZSwgaW5WUHJlKSkge1xuICAgICAgICAgICAgICAgIGNoaWxkcmVuTWF0Y2ggPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBicmVha1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGNoaWxkTm9kZSA9IGNoaWxkTm9kZS5uZXh0U2libGluZztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGlmIGNoaWxkTm9kZSBpcyBub3QgbnVsbCwgaXQgbWVhbnMgdGhlIGFjdHVhbCBjaGlsZE5vZGVzIGxpc3QgaXNcbiAgICAgICAgICAgIC8vIGxvbmdlciB0aGFuIHRoZSB2aXJ0dWFsIGNoaWxkcmVuIGxpc3QuXG4gICAgICAgICAgICBpZiAoIWNoaWxkcmVuTWF0Y2ggfHwgY2hpbGROb2RlKSB7XG4gICAgICAgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJlxuICAgICAgICAgICAgICAgIHR5cGVvZiBjb25zb2xlICE9PSAndW5kZWZpbmVkJyAmJlxuICAgICAgICAgICAgICAgICFoeWRyYXRpb25CYWlsZWRcbiAgICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgaHlkcmF0aW9uQmFpbGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oJ1BhcmVudDogJywgZWxtKTtcbiAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oJ01pc21hdGNoaW5nIGNoaWxkTm9kZXMgdnMuIFZOb2RlczogJywgZWxtLmNoaWxkTm9kZXMsIGNoaWxkcmVuKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChpc0RlZihkYXRhKSkge1xuICAgICAgICB2YXIgZnVsbEludm9rZSA9IGZhbHNlO1xuICAgICAgICBmb3IgKHZhciBrZXkgaW4gZGF0YSkge1xuICAgICAgICAgIGlmICghaXNSZW5kZXJlZE1vZHVsZShrZXkpKSB7XG4gICAgICAgICAgICBmdWxsSW52b2tlID0gdHJ1ZTtcbiAgICAgICAgICAgIGludm9rZUNyZWF0ZUhvb2tzKHZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUpO1xuICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFmdWxsSW52b2tlICYmIGRhdGFbJ2NsYXNzJ10pIHtcbiAgICAgICAgICAvLyBlbnN1cmUgY29sbGVjdGluZyBkZXBzIGZvciBkZWVwIGNsYXNzIGJpbmRpbmdzIGZvciBmdXR1cmUgdXBkYXRlc1xuICAgICAgICAgIHRyYXZlcnNlKGRhdGFbJ2NsYXNzJ10pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChlbG0uZGF0YSAhPT0gdm5vZGUudGV4dCkge1xuICAgICAgZWxtLmRhdGEgPSB2bm9kZS50ZXh0O1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZVxuICB9XG5cbiAgZnVuY3Rpb24gYXNzZXJ0Tm9kZU1hdGNoIChub2RlLCB2bm9kZSwgaW5WUHJlKSB7XG4gICAgaWYgKGlzRGVmKHZub2RlLnRhZykpIHtcbiAgICAgIHJldHVybiB2bm9kZS50YWcuaW5kZXhPZigndnVlLWNvbXBvbmVudCcpID09PSAwIHx8IChcbiAgICAgICAgIWlzVW5rbm93bkVsZW1lbnQkJDEodm5vZGUsIGluVlByZSkgJiZcbiAgICAgICAgdm5vZGUudGFnLnRvTG93ZXJDYXNlKCkgPT09IChub2RlLnRhZ05hbWUgJiYgbm9kZS50YWdOYW1lLnRvTG93ZXJDYXNlKCkpXG4gICAgICApXG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBub2RlLm5vZGVUeXBlID09PSAodm5vZGUuaXNDb21tZW50ID8gOCA6IDMpXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZ1bmN0aW9uIHBhdGNoIChvbGRWbm9kZSwgdm5vZGUsIGh5ZHJhdGluZywgcmVtb3ZlT25seSkge1xuICAgIGlmIChpc1VuZGVmKHZub2RlKSkge1xuICAgICAgaWYgKGlzRGVmKG9sZFZub2RlKSkgeyBpbnZva2VEZXN0cm95SG9vayhvbGRWbm9kZSk7IH1cbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIHZhciBpc0luaXRpYWxQYXRjaCA9IGZhbHNlO1xuICAgIHZhciBpbnNlcnRlZFZub2RlUXVldWUgPSBbXTtcblxuICAgIGlmIChpc1VuZGVmKG9sZFZub2RlKSkge1xuICAgICAgLy8gZW1wdHkgbW91bnQgKGxpa2VseSBhcyBjb21wb25lbnQpLCBjcmVhdGUgbmV3IHJvb3QgZWxlbWVudFxuICAgICAgaXNJbml0aWFsUGF0Y2ggPSB0cnVlO1xuICAgICAgY3JlYXRlRWxtKHZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgaXNSZWFsRWxlbWVudCA9IGlzRGVmKG9sZFZub2RlLm5vZGVUeXBlKTtcbiAgICAgIGlmICghaXNSZWFsRWxlbWVudCAmJiBzYW1lVm5vZGUob2xkVm5vZGUsIHZub2RlKSkge1xuICAgICAgICAvLyBwYXRjaCBleGlzdGluZyByb290IG5vZGVcbiAgICAgICAgcGF0Y2hWbm9kZShvbGRWbm9kZSwgdm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSwgbnVsbCwgbnVsbCwgcmVtb3ZlT25seSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoaXNSZWFsRWxlbWVudCkge1xuICAgICAgICAgIC8vIG1vdW50aW5nIHRvIGEgcmVhbCBlbGVtZW50XG4gICAgICAgICAgLy8gY2hlY2sgaWYgdGhpcyBpcyBzZXJ2ZXItcmVuZGVyZWQgY29udGVudCBhbmQgaWYgd2UgY2FuIHBlcmZvcm1cbiAgICAgICAgICAvLyBhIHN1Y2Nlc3NmdWwgaHlkcmF0aW9uLlxuICAgICAgICAgIGlmIChvbGRWbm9kZS5ub2RlVHlwZSA9PT0gMSAmJiBvbGRWbm9kZS5oYXNBdHRyaWJ1dGUoU1NSX0FUVFIpKSB7XG4gICAgICAgICAgICBvbGRWbm9kZS5yZW1vdmVBdHRyaWJ1dGUoU1NSX0FUVFIpO1xuICAgICAgICAgICAgaHlkcmF0aW5nID0gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGlzVHJ1ZShoeWRyYXRpbmcpKSB7XG4gICAgICAgICAgICBpZiAoaHlkcmF0ZShvbGRWbm9kZSwgdm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSkpIHtcbiAgICAgICAgICAgICAgaW52b2tlSW5zZXJ0SG9vayh2bm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlLCB0cnVlKTtcbiAgICAgICAgICAgICAgcmV0dXJuIG9sZFZub2RlXG4gICAgICAgICAgICB9IGVsc2UgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgICAgICAgd2FybihcbiAgICAgICAgICAgICAgICAnVGhlIGNsaWVudC1zaWRlIHJlbmRlcmVkIHZpcnR1YWwgRE9NIHRyZWUgaXMgbm90IG1hdGNoaW5nICcgK1xuICAgICAgICAgICAgICAgICdzZXJ2ZXItcmVuZGVyZWQgY29udGVudC4gVGhpcyBpcyBsaWtlbHkgY2F1c2VkIGJ5IGluY29ycmVjdCAnICtcbiAgICAgICAgICAgICAgICAnSFRNTCBtYXJrdXAsIGZvciBleGFtcGxlIG5lc3RpbmcgYmxvY2stbGV2ZWwgZWxlbWVudHMgaW5zaWRlICcgK1xuICAgICAgICAgICAgICAgICc8cD4sIG9yIG1pc3NpbmcgPHRib2R5Pi4gQmFpbGluZyBoeWRyYXRpb24gYW5kIHBlcmZvcm1pbmcgJyArXG4gICAgICAgICAgICAgICAgJ2Z1bGwgY2xpZW50LXNpZGUgcmVuZGVyLidcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgLy8gZWl0aGVyIG5vdCBzZXJ2ZXItcmVuZGVyZWQsIG9yIGh5ZHJhdGlvbiBmYWlsZWQuXG4gICAgICAgICAgLy8gY3JlYXRlIGFuIGVtcHR5IG5vZGUgYW5kIHJlcGxhY2UgaXRcbiAgICAgICAgICBvbGRWbm9kZSA9IGVtcHR5Tm9kZUF0KG9sZFZub2RlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHJlcGxhY2luZyBleGlzdGluZyBlbGVtZW50XG4gICAgICAgIHZhciBvbGRFbG0gPSBvbGRWbm9kZS5lbG07XG4gICAgICAgIHZhciBwYXJlbnRFbG0gPSBub2RlT3BzLnBhcmVudE5vZGUob2xkRWxtKTtcblxuICAgICAgICAvLyBjcmVhdGUgbmV3IG5vZGVcbiAgICAgICAgY3JlYXRlRWxtKFxuICAgICAgICAgIHZub2RlLFxuICAgICAgICAgIGluc2VydGVkVm5vZGVRdWV1ZSxcbiAgICAgICAgICAvLyBleHRyZW1lbHkgcmFyZSBlZGdlIGNhc2U6IGRvIG5vdCBpbnNlcnQgaWYgb2xkIGVsZW1lbnQgaXMgaW4gYVxuICAgICAgICAgIC8vIGxlYXZpbmcgdHJhbnNpdGlvbi4gT25seSBoYXBwZW5zIHdoZW4gY29tYmluaW5nIHRyYW5zaXRpb24gK1xuICAgICAgICAgIC8vIGtlZXAtYWxpdmUgKyBIT0NzLiAoIzQ1OTApXG4gICAgICAgICAgb2xkRWxtLl9sZWF2ZUNiID8gbnVsbCA6IHBhcmVudEVsbSxcbiAgICAgICAgICBub2RlT3BzLm5leHRTaWJsaW5nKG9sZEVsbSlcbiAgICAgICAgKTtcblxuICAgICAgICAvLyB1cGRhdGUgcGFyZW50IHBsYWNlaG9sZGVyIG5vZGUgZWxlbWVudCwgcmVjdXJzaXZlbHlcbiAgICAgICAgaWYgKGlzRGVmKHZub2RlLnBhcmVudCkpIHtcbiAgICAgICAgICB2YXIgYW5jZXN0b3IgPSB2bm9kZS5wYXJlbnQ7XG4gICAgICAgICAgdmFyIHBhdGNoYWJsZSA9IGlzUGF0Y2hhYmxlKHZub2RlKTtcbiAgICAgICAgICB3aGlsZSAoYW5jZXN0b3IpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2JzLmRlc3Ryb3kubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgICAgY2JzLmRlc3Ryb3lbaV0oYW5jZXN0b3IpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYW5jZXN0b3IuZWxtID0gdm5vZGUuZWxtO1xuICAgICAgICAgICAgaWYgKHBhdGNoYWJsZSkge1xuICAgICAgICAgICAgICBmb3IgKHZhciBpJDEgPSAwOyBpJDEgPCBjYnMuY3JlYXRlLmxlbmd0aDsgKytpJDEpIHtcbiAgICAgICAgICAgICAgICBjYnMuY3JlYXRlW2kkMV0oZW1wdHlOb2RlLCBhbmNlc3Rvcik7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgLy8gIzY1MTNcbiAgICAgICAgICAgICAgLy8gaW52b2tlIGluc2VydCBob29rcyB0aGF0IG1heSBoYXZlIGJlZW4gbWVyZ2VkIGJ5IGNyZWF0ZSBob29rcy5cbiAgICAgICAgICAgICAgLy8gZS5nLiBmb3IgZGlyZWN0aXZlcyB0aGF0IHVzZXMgdGhlIFwiaW5zZXJ0ZWRcIiBob29rLlxuICAgICAgICAgICAgICB2YXIgaW5zZXJ0ID0gYW5jZXN0b3IuZGF0YS5ob29rLmluc2VydDtcbiAgICAgICAgICAgICAgaWYgKGluc2VydC5tZXJnZWQpIHtcbiAgICAgICAgICAgICAgICAvLyBzdGFydCBhdCBpbmRleCAxIHRvIGF2b2lkIHJlLWludm9raW5nIGNvbXBvbmVudCBtb3VudGVkIGhvb2tcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpJDIgPSAxOyBpJDIgPCBpbnNlcnQuZm5zLmxlbmd0aDsgaSQyKyspIHtcbiAgICAgICAgICAgICAgICAgIGluc2VydC5mbnNbaSQyXSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgcmVnaXN0ZXJSZWYoYW5jZXN0b3IpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYW5jZXN0b3IgPSBhbmNlc3Rvci5wYXJlbnQ7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gZGVzdHJveSBvbGQgbm9kZVxuICAgICAgICBpZiAoaXNEZWYocGFyZW50RWxtKSkge1xuICAgICAgICAgIHJlbW92ZVZub2Rlcyhbb2xkVm5vZGVdLCAwLCAwKTtcbiAgICAgICAgfSBlbHNlIGlmIChpc0RlZihvbGRWbm9kZS50YWcpKSB7XG4gICAgICAgICAgaW52b2tlRGVzdHJveUhvb2sob2xkVm5vZGUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgaW52b2tlSW5zZXJ0SG9vayh2bm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlLCBpc0luaXRpYWxQYXRjaCk7XG4gICAgcmV0dXJuIHZub2RlLmVsbVxuICB9XG59XG5cbi8qICAqL1xuXG52YXIgZGlyZWN0aXZlcyA9IHtcbiAgY3JlYXRlOiB1cGRhdGVEaXJlY3RpdmVzLFxuICB1cGRhdGU6IHVwZGF0ZURpcmVjdGl2ZXMsXG4gIGRlc3Ryb3k6IGZ1bmN0aW9uIHVuYmluZERpcmVjdGl2ZXMgKHZub2RlKSB7XG4gICAgdXBkYXRlRGlyZWN0aXZlcyh2bm9kZSwgZW1wdHlOb2RlKTtcbiAgfVxufTtcblxuZnVuY3Rpb24gdXBkYXRlRGlyZWN0aXZlcyAob2xkVm5vZGUsIHZub2RlKSB7XG4gIGlmIChvbGRWbm9kZS5kYXRhLmRpcmVjdGl2ZXMgfHwgdm5vZGUuZGF0YS5kaXJlY3RpdmVzKSB7XG4gICAgX3VwZGF0ZShvbGRWbm9kZSwgdm5vZGUpO1xuICB9XG59XG5cbmZ1bmN0aW9uIF91cGRhdGUgKG9sZFZub2RlLCB2bm9kZSkge1xuICB2YXIgaXNDcmVhdGUgPSBvbGRWbm9kZSA9PT0gZW1wdHlOb2RlO1xuICB2YXIgaXNEZXN0cm95ID0gdm5vZGUgPT09IGVtcHR5Tm9kZTtcbiAgdmFyIG9sZERpcnMgPSBub3JtYWxpemVEaXJlY3RpdmVzJDEob2xkVm5vZGUuZGF0YS5kaXJlY3RpdmVzLCBvbGRWbm9kZS5jb250ZXh0KTtcbiAgdmFyIG5ld0RpcnMgPSBub3JtYWxpemVEaXJlY3RpdmVzJDEodm5vZGUuZGF0YS5kaXJlY3RpdmVzLCB2bm9kZS5jb250ZXh0KTtcblxuICB2YXIgZGlyc1dpdGhJbnNlcnQgPSBbXTtcbiAgdmFyIGRpcnNXaXRoUG9zdHBhdGNoID0gW107XG5cbiAgdmFyIGtleSwgb2xkRGlyLCBkaXI7XG4gIGZvciAoa2V5IGluIG5ld0RpcnMpIHtcbiAgICBvbGREaXIgPSBvbGREaXJzW2tleV07XG4gICAgZGlyID0gbmV3RGlyc1trZXldO1xuICAgIGlmICghb2xkRGlyKSB7XG4gICAgICAvLyBuZXcgZGlyZWN0aXZlLCBiaW5kXG4gICAgICBjYWxsSG9vayQxKGRpciwgJ2JpbmQnLCB2bm9kZSwgb2xkVm5vZGUpO1xuICAgICAgaWYgKGRpci5kZWYgJiYgZGlyLmRlZi5pbnNlcnRlZCkge1xuICAgICAgICBkaXJzV2l0aEluc2VydC5wdXNoKGRpcik7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGV4aXN0aW5nIGRpcmVjdGl2ZSwgdXBkYXRlXG4gICAgICBkaXIub2xkVmFsdWUgPSBvbGREaXIudmFsdWU7XG4gICAgICBkaXIub2xkQXJnID0gb2xkRGlyLmFyZztcbiAgICAgIGNhbGxIb29rJDEoZGlyLCAndXBkYXRlJywgdm5vZGUsIG9sZFZub2RlKTtcbiAgICAgIGlmIChkaXIuZGVmICYmIGRpci5kZWYuY29tcG9uZW50VXBkYXRlZCkge1xuICAgICAgICBkaXJzV2l0aFBvc3RwYXRjaC5wdXNoKGRpcik7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgaWYgKGRpcnNXaXRoSW5zZXJ0Lmxlbmd0aCkge1xuICAgIHZhciBjYWxsSW5zZXJ0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBkaXJzV2l0aEluc2VydC5sZW5ndGg7IGkrKykge1xuICAgICAgICBjYWxsSG9vayQxKGRpcnNXaXRoSW5zZXJ0W2ldLCAnaW5zZXJ0ZWQnLCB2bm9kZSwgb2xkVm5vZGUpO1xuICAgICAgfVxuICAgIH07XG4gICAgaWYgKGlzQ3JlYXRlKSB7XG4gICAgICBtZXJnZVZOb2RlSG9vayh2bm9kZSwgJ2luc2VydCcsIGNhbGxJbnNlcnQpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjYWxsSW5zZXJ0KCk7XG4gICAgfVxuICB9XG5cbiAgaWYgKGRpcnNXaXRoUG9zdHBhdGNoLmxlbmd0aCkge1xuICAgIG1lcmdlVk5vZGVIb29rKHZub2RlLCAncG9zdHBhdGNoJywgZnVuY3Rpb24gKCkge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBkaXJzV2l0aFBvc3RwYXRjaC5sZW5ndGg7IGkrKykge1xuICAgICAgICBjYWxsSG9vayQxKGRpcnNXaXRoUG9zdHBhdGNoW2ldLCAnY29tcG9uZW50VXBkYXRlZCcsIHZub2RlLCBvbGRWbm9kZSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICBpZiAoIWlzQ3JlYXRlKSB7XG4gICAgZm9yIChrZXkgaW4gb2xkRGlycykge1xuICAgICAgaWYgKCFuZXdEaXJzW2tleV0pIHtcbiAgICAgICAgLy8gbm8gbG9uZ2VyIHByZXNlbnQsIHVuYmluZFxuICAgICAgICBjYWxsSG9vayQxKG9sZERpcnNba2V5XSwgJ3VuYmluZCcsIG9sZFZub2RlLCBvbGRWbm9kZSwgaXNEZXN0cm95KTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxudmFyIGVtcHR5TW9kaWZpZXJzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcblxuZnVuY3Rpb24gbm9ybWFsaXplRGlyZWN0aXZlcyQxIChcbiAgZGlycyxcbiAgdm1cbikge1xuICB2YXIgcmVzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgaWYgKCFkaXJzKSB7XG4gICAgLy8gJGZsb3ctZGlzYWJsZS1saW5lXG4gICAgcmV0dXJuIHJlc1xuICB9XG4gIHZhciBpLCBkaXI7XG4gIGZvciAoaSA9IDA7IGkgPCBkaXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgZGlyID0gZGlyc1tpXTtcbiAgICBpZiAoIWRpci5tb2RpZmllcnMpIHtcbiAgICAgIC8vICRmbG93LWRpc2FibGUtbGluZVxuICAgICAgZGlyLm1vZGlmaWVycyA9IGVtcHR5TW9kaWZpZXJzO1xuICAgIH1cbiAgICByZXNbZ2V0UmF3RGlyTmFtZShkaXIpXSA9IGRpcjtcbiAgICBkaXIuZGVmID0gcmVzb2x2ZUFzc2V0KHZtLiRvcHRpb25zLCAnZGlyZWN0aXZlcycsIGRpci5uYW1lLCB0cnVlKTtcbiAgfVxuICAvLyAkZmxvdy1kaXNhYmxlLWxpbmVcbiAgcmV0dXJuIHJlc1xufVxuXG5mdW5jdGlvbiBnZXRSYXdEaXJOYW1lIChkaXIpIHtcbiAgcmV0dXJuIGRpci5yYXdOYW1lIHx8ICgoZGlyLm5hbWUpICsgXCIuXCIgKyAoT2JqZWN0LmtleXMoZGlyLm1vZGlmaWVycyB8fCB7fSkuam9pbignLicpKSlcbn1cblxuZnVuY3Rpb24gY2FsbEhvb2skMSAoZGlyLCBob29rLCB2bm9kZSwgb2xkVm5vZGUsIGlzRGVzdHJveSkge1xuICB2YXIgZm4gPSBkaXIuZGVmICYmIGRpci5kZWZbaG9va107XG4gIGlmIChmbikge1xuICAgIHRyeSB7XG4gICAgICBmbih2bm9kZS5lbG0sIGRpciwgdm5vZGUsIG9sZFZub2RlLCBpc0Rlc3Ryb3kpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGhhbmRsZUVycm9yKGUsIHZub2RlLmNvbnRleHQsIChcImRpcmVjdGl2ZSBcIiArIChkaXIubmFtZSkgKyBcIiBcIiArIGhvb2sgKyBcIiBob29rXCIpKTtcbiAgICB9XG4gIH1cbn1cblxudmFyIGJhc2VNb2R1bGVzID0gW1xuICByZWYsXG4gIGRpcmVjdGl2ZXNcbl07XG5cbi8qICAqL1xuXG5mdW5jdGlvbiB1cGRhdGVBdHRycyAob2xkVm5vZGUsIHZub2RlKSB7XG4gIHZhciBvcHRzID0gdm5vZGUuY29tcG9uZW50T3B0aW9ucztcbiAgaWYgKGlzRGVmKG9wdHMpICYmIG9wdHMuQ3Rvci5vcHRpb25zLmluaGVyaXRBdHRycyA9PT0gZmFsc2UpIHtcbiAgICByZXR1cm5cbiAgfVxuICBpZiAoaXNVbmRlZihvbGRWbm9kZS5kYXRhLmF0dHJzKSAmJiBpc1VuZGVmKHZub2RlLmRhdGEuYXR0cnMpKSB7XG4gICAgcmV0dXJuXG4gIH1cbiAgdmFyIGtleSwgY3VyLCBvbGQ7XG4gIHZhciBlbG0gPSB2bm9kZS5lbG07XG4gIHZhciBvbGRBdHRycyA9IG9sZFZub2RlLmRhdGEuYXR0cnMgfHwge307XG4gIHZhciBhdHRycyA9IHZub2RlLmRhdGEuYXR0cnMgfHwge307XG4gIC8vIGNsb25lIG9ic2VydmVkIG9iamVjdHMsIGFzIHRoZSB1c2VyIHByb2JhYmx5IHdhbnRzIHRvIG11dGF0ZSBpdFxuICBpZiAoaXNEZWYoYXR0cnMuX19vYl9fKSkge1xuICAgIGF0dHJzID0gdm5vZGUuZGF0YS5hdHRycyA9IGV4dGVuZCh7fSwgYXR0cnMpO1xuICB9XG5cbiAgZm9yIChrZXkgaW4gYXR0cnMpIHtcbiAgICBjdXIgPSBhdHRyc1trZXldO1xuICAgIG9sZCA9IG9sZEF0dHJzW2tleV07XG4gICAgaWYgKG9sZCAhPT0gY3VyKSB7XG4gICAgICBzZXRBdHRyKGVsbSwga2V5LCBjdXIsIHZub2RlLmRhdGEucHJlKTtcbiAgICB9XG4gIH1cbiAgLy8gIzQzOTE6IGluIElFOSwgc2V0dGluZyB0eXBlIGNhbiByZXNldCB2YWx1ZSBmb3IgaW5wdXRbdHlwZT1yYWRpb11cbiAgLy8gIzY2NjY6IElFL0VkZ2UgZm9yY2VzIHByb2dyZXNzIHZhbHVlIGRvd24gdG8gMSBiZWZvcmUgc2V0dGluZyBhIG1heFxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgaWYgKChpc0lFIHx8IGlzRWRnZSkgJiYgYXR0cnMudmFsdWUgIT09IG9sZEF0dHJzLnZhbHVlKSB7XG4gICAgc2V0QXR0cihlbG0sICd2YWx1ZScsIGF0dHJzLnZhbHVlKTtcbiAgfVxuICBmb3IgKGtleSBpbiBvbGRBdHRycykge1xuICAgIGlmIChpc1VuZGVmKGF0dHJzW2tleV0pKSB7XG4gICAgICBpZiAoaXNYbGluayhrZXkpKSB7XG4gICAgICAgIGVsbS5yZW1vdmVBdHRyaWJ1dGVOUyh4bGlua05TLCBnZXRYbGlua1Byb3Aoa2V5KSk7XG4gICAgICB9IGVsc2UgaWYgKCFpc0VudW1lcmF0ZWRBdHRyKGtleSkpIHtcbiAgICAgICAgZWxtLnJlbW92ZUF0dHJpYnV0ZShrZXkpO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBzZXRBdHRyIChlbCwga2V5LCB2YWx1ZSwgaXNJblByZSkge1xuICBpZiAoaXNJblByZSB8fCBlbC50YWdOYW1lLmluZGV4T2YoJy0nKSA+IC0xKSB7XG4gICAgYmFzZVNldEF0dHIoZWwsIGtleSwgdmFsdWUpO1xuICB9IGVsc2UgaWYgKGlzQm9vbGVhbkF0dHIoa2V5KSkge1xuICAgIC8vIHNldCBhdHRyaWJ1dGUgZm9yIGJsYW5rIHZhbHVlXG4gICAgLy8gZS5nLiA8b3B0aW9uIGRpc2FibGVkPlNlbGVjdCBvbmU8L29wdGlvbj5cbiAgICBpZiAoaXNGYWxzeUF0dHJWYWx1ZSh2YWx1ZSkpIHtcbiAgICAgIGVsLnJlbW92ZUF0dHJpYnV0ZShrZXkpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyB0ZWNobmljYWxseSBhbGxvd2Z1bGxzY3JlZW4gaXMgYSBib29sZWFuIGF0dHJpYnV0ZSBmb3IgPGlmcmFtZT4sXG4gICAgICAvLyBidXQgRmxhc2ggZXhwZWN0cyBhIHZhbHVlIG9mIFwidHJ1ZVwiIHdoZW4gdXNlZCBvbiA8ZW1iZWQ+IHRhZ1xuICAgICAgdmFsdWUgPSBrZXkgPT09ICdhbGxvd2Z1bGxzY3JlZW4nICYmIGVsLnRhZ05hbWUgPT09ICdFTUJFRCdcbiAgICAgICAgPyAndHJ1ZSdcbiAgICAgICAgOiBrZXk7XG4gICAgICBlbC5zZXRBdHRyaWJ1dGUoa2V5LCB2YWx1ZSk7XG4gICAgfVxuICB9IGVsc2UgaWYgKGlzRW51bWVyYXRlZEF0dHIoa2V5KSkge1xuICAgIGVsLnNldEF0dHJpYnV0ZShrZXksIGNvbnZlcnRFbnVtZXJhdGVkVmFsdWUoa2V5LCB2YWx1ZSkpO1xuICB9IGVsc2UgaWYgKGlzWGxpbmsoa2V5KSkge1xuICAgIGlmIChpc0ZhbHN5QXR0clZhbHVlKHZhbHVlKSkge1xuICAgICAgZWwucmVtb3ZlQXR0cmlidXRlTlMoeGxpbmtOUywgZ2V0WGxpbmtQcm9wKGtleSkpO1xuICAgIH0gZWxzZSB7XG4gICAgICBlbC5zZXRBdHRyaWJ1dGVOUyh4bGlua05TLCBrZXksIHZhbHVlKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgYmFzZVNldEF0dHIoZWwsIGtleSwgdmFsdWUpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGJhc2VTZXRBdHRyIChlbCwga2V5LCB2YWx1ZSkge1xuICBpZiAoaXNGYWxzeUF0dHJWYWx1ZSh2YWx1ZSkpIHtcbiAgICBlbC5yZW1vdmVBdHRyaWJ1dGUoa2V5KTtcbiAgfSBlbHNlIHtcbiAgICAvLyAjNzEzODogSUUxMCAmIDExIGZpcmVzIGlucHV0IGV2ZW50IHdoZW4gc2V0dGluZyBwbGFjZWhvbGRlciBvblxuICAgIC8vIDx0ZXh0YXJlYT4uLi4gYmxvY2sgdGhlIGZpcnN0IGlucHV0IGV2ZW50IGFuZCByZW1vdmUgdGhlIGJsb2NrZXJcbiAgICAvLyBpbW1lZGlhdGVseS5cbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICBpZiAoXG4gICAgICBpc0lFICYmICFpc0lFOSAmJlxuICAgICAgZWwudGFnTmFtZSA9PT0gJ1RFWFRBUkVBJyAmJlxuICAgICAga2V5ID09PSAncGxhY2Vob2xkZXInICYmIHZhbHVlICE9PSAnJyAmJiAhZWwuX19pZXBoXG4gICAgKSB7XG4gICAgICB2YXIgYmxvY2tlciA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIGUuc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uKCk7XG4gICAgICAgIGVsLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2lucHV0JywgYmxvY2tlcik7XG4gICAgICB9O1xuICAgICAgZWwuYWRkRXZlbnRMaXN0ZW5lcignaW5wdXQnLCBibG9ja2VyKTtcbiAgICAgIC8vICRmbG93LWRpc2FibGUtbGluZVxuICAgICAgZWwuX19pZXBoID0gdHJ1ZTsgLyogSUUgcGxhY2Vob2xkZXIgcGF0Y2hlZCAqL1xuICAgIH1cbiAgICBlbC5zZXRBdHRyaWJ1dGUoa2V5LCB2YWx1ZSk7XG4gIH1cbn1cblxudmFyIGF0dHJzID0ge1xuICBjcmVhdGU6IHVwZGF0ZUF0dHJzLFxuICB1cGRhdGU6IHVwZGF0ZUF0dHJzXG59O1xuXG4vKiAgKi9cblxuZnVuY3Rpb24gdXBkYXRlQ2xhc3MgKG9sZFZub2RlLCB2bm9kZSkge1xuICB2YXIgZWwgPSB2bm9kZS5lbG07XG4gIHZhciBkYXRhID0gdm5vZGUuZGF0YTtcbiAgdmFyIG9sZERhdGEgPSBvbGRWbm9kZS5kYXRhO1xuICBpZiAoXG4gICAgaXNVbmRlZihkYXRhLnN0YXRpY0NsYXNzKSAmJlxuICAgIGlzVW5kZWYoZGF0YS5jbGFzcykgJiYgKFxuICAgICAgaXNVbmRlZihvbGREYXRhKSB8fCAoXG4gICAgICAgIGlzVW5kZWYob2xkRGF0YS5zdGF0aWNDbGFzcykgJiZcbiAgICAgICAgaXNVbmRlZihvbGREYXRhLmNsYXNzKVxuICAgICAgKVxuICAgIClcbiAgKSB7XG4gICAgcmV0dXJuXG4gIH1cblxuICB2YXIgY2xzID0gZ2VuQ2xhc3NGb3JWbm9kZSh2bm9kZSk7XG5cbiAgLy8gaGFuZGxlIHRyYW5zaXRpb24gY2xhc3Nlc1xuICB2YXIgdHJhbnNpdGlvbkNsYXNzID0gZWwuX3RyYW5zaXRpb25DbGFzc2VzO1xuICBpZiAoaXNEZWYodHJhbnNpdGlvbkNsYXNzKSkge1xuICAgIGNscyA9IGNvbmNhdChjbHMsIHN0cmluZ2lmeUNsYXNzKHRyYW5zaXRpb25DbGFzcykpO1xuICB9XG5cbiAgLy8gc2V0IHRoZSBjbGFzc1xuICBpZiAoY2xzICE9PSBlbC5fcHJldkNsYXNzKSB7XG4gICAgZWwuc2V0QXR0cmlidXRlKCdjbGFzcycsIGNscyk7XG4gICAgZWwuX3ByZXZDbGFzcyA9IGNscztcbiAgfVxufVxuXG52YXIga2xhc3MgPSB7XG4gIGNyZWF0ZTogdXBkYXRlQ2xhc3MsXG4gIHVwZGF0ZTogdXBkYXRlQ2xhc3Ncbn07XG5cbi8qICAqL1xuXG52YXIgdmFsaWREaXZpc2lvbkNoYXJSRSA9IC9bXFx3KS4rXFwtXyRcXF1dLztcblxuZnVuY3Rpb24gcGFyc2VGaWx0ZXJzIChleHApIHtcbiAgdmFyIGluU2luZ2xlID0gZmFsc2U7XG4gIHZhciBpbkRvdWJsZSA9IGZhbHNlO1xuICB2YXIgaW5UZW1wbGF0ZVN0cmluZyA9IGZhbHNlO1xuICB2YXIgaW5SZWdleCA9IGZhbHNlO1xuICB2YXIgY3VybHkgPSAwO1xuICB2YXIgc3F1YXJlID0gMDtcbiAgdmFyIHBhcmVuID0gMDtcbiAgdmFyIGxhc3RGaWx0ZXJJbmRleCA9IDA7XG4gIHZhciBjLCBwcmV2LCBpLCBleHByZXNzaW9uLCBmaWx0ZXJzO1xuXG4gIGZvciAoaSA9IDA7IGkgPCBleHAubGVuZ3RoOyBpKyspIHtcbiAgICBwcmV2ID0gYztcbiAgICBjID0gZXhwLmNoYXJDb2RlQXQoaSk7XG4gICAgaWYgKGluU2luZ2xlKSB7XG4gICAgICBpZiAoYyA9PT0gMHgyNyAmJiBwcmV2ICE9PSAweDVDKSB7IGluU2luZ2xlID0gZmFsc2U7IH1cbiAgICB9IGVsc2UgaWYgKGluRG91YmxlKSB7XG4gICAgICBpZiAoYyA9PT0gMHgyMiAmJiBwcmV2ICE9PSAweDVDKSB7IGluRG91YmxlID0gZmFsc2U7IH1cbiAgICB9IGVsc2UgaWYgKGluVGVtcGxhdGVTdHJpbmcpIHtcbiAgICAgIGlmIChjID09PSAweDYwICYmIHByZXYgIT09IDB4NUMpIHsgaW5UZW1wbGF0ZVN0cmluZyA9IGZhbHNlOyB9XG4gICAgfSBlbHNlIGlmIChpblJlZ2V4KSB7XG4gICAgICBpZiAoYyA9PT0gMHgyZiAmJiBwcmV2ICE9PSAweDVDKSB7IGluUmVnZXggPSBmYWxzZTsgfVxuICAgIH0gZWxzZSBpZiAoXG4gICAgICBjID09PSAweDdDICYmIC8vIHBpcGVcbiAgICAgIGV4cC5jaGFyQ29kZUF0KGkgKyAxKSAhPT0gMHg3QyAmJlxuICAgICAgZXhwLmNoYXJDb2RlQXQoaSAtIDEpICE9PSAweDdDICYmXG4gICAgICAhY3VybHkgJiYgIXNxdWFyZSAmJiAhcGFyZW5cbiAgICApIHtcbiAgICAgIGlmIChleHByZXNzaW9uID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgLy8gZmlyc3QgZmlsdGVyLCBlbmQgb2YgZXhwcmVzc2lvblxuICAgICAgICBsYXN0RmlsdGVySW5kZXggPSBpICsgMTtcbiAgICAgICAgZXhwcmVzc2lvbiA9IGV4cC5zbGljZSgwLCBpKS50cmltKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwdXNoRmlsdGVyKCk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHN3aXRjaCAoYykge1xuICAgICAgICBjYXNlIDB4MjI6IGluRG91YmxlID0gdHJ1ZTsgYnJlYWsgICAgICAgICAvLyBcIlxuICAgICAgICBjYXNlIDB4Mjc6IGluU2luZ2xlID0gdHJ1ZTsgYnJlYWsgICAgICAgICAvLyAnXG4gICAgICAgIGNhc2UgMHg2MDogaW5UZW1wbGF0ZVN0cmluZyA9IHRydWU7IGJyZWFrIC8vIGBcbiAgICAgICAgY2FzZSAweDI4OiBwYXJlbisrOyBicmVhayAgICAgICAgICAgICAgICAgLy8gKFxuICAgICAgICBjYXNlIDB4Mjk6IHBhcmVuLS07IGJyZWFrICAgICAgICAgICAgICAgICAvLyApXG4gICAgICAgIGNhc2UgMHg1Qjogc3F1YXJlKys7IGJyZWFrICAgICAgICAgICAgICAgIC8vIFtcbiAgICAgICAgY2FzZSAweDVEOiBzcXVhcmUtLTsgYnJlYWsgICAgICAgICAgICAgICAgLy8gXVxuICAgICAgICBjYXNlIDB4N0I6IGN1cmx5Kys7IGJyZWFrICAgICAgICAgICAgICAgICAvLyB7XG4gICAgICAgIGNhc2UgMHg3RDogY3VybHktLTsgYnJlYWsgICAgICAgICAgICAgICAgIC8vIH1cbiAgICAgIH1cbiAgICAgIGlmIChjID09PSAweDJmKSB7IC8vIC9cbiAgICAgICAgdmFyIGogPSBpIC0gMTtcbiAgICAgICAgdmFyIHAgPSAodm9pZCAwKTtcbiAgICAgICAgLy8gZmluZCBmaXJzdCBub24td2hpdGVzcGFjZSBwcmV2IGNoYXJcbiAgICAgICAgZm9yICg7IGogPj0gMDsgai0tKSB7XG4gICAgICAgICAgcCA9IGV4cC5jaGFyQXQoaik7XG4gICAgICAgICAgaWYgKHAgIT09ICcgJykgeyBicmVhayB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFwIHx8ICF2YWxpZERpdmlzaW9uQ2hhclJFLnRlc3QocCkpIHtcbiAgICAgICAgICBpblJlZ2V4ID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGlmIChleHByZXNzaW9uID09PSB1bmRlZmluZWQpIHtcbiAgICBleHByZXNzaW9uID0gZXhwLnNsaWNlKDAsIGkpLnRyaW0oKTtcbiAgfSBlbHNlIGlmIChsYXN0RmlsdGVySW5kZXggIT09IDApIHtcbiAgICBwdXNoRmlsdGVyKCk7XG4gIH1cblxuICBmdW5jdGlvbiBwdXNoRmlsdGVyICgpIHtcbiAgICAoZmlsdGVycyB8fCAoZmlsdGVycyA9IFtdKSkucHVzaChleHAuc2xpY2UobGFzdEZpbHRlckluZGV4LCBpKS50cmltKCkpO1xuICAgIGxhc3RGaWx0ZXJJbmRleCA9IGkgKyAxO1xuICB9XG5cbiAgaWYgKGZpbHRlcnMpIHtcbiAgICBmb3IgKGkgPSAwOyBpIDwgZmlsdGVycy5sZW5ndGg7IGkrKykge1xuICAgICAgZXhwcmVzc2lvbiA9IHdyYXBGaWx0ZXIoZXhwcmVzc2lvbiwgZmlsdGVyc1tpXSk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGV4cHJlc3Npb25cbn1cblxuZnVuY3Rpb24gd3JhcEZpbHRlciAoZXhwLCBmaWx0ZXIpIHtcbiAgdmFyIGkgPSBmaWx0ZXIuaW5kZXhPZignKCcpO1xuICBpZiAoaSA8IDApIHtcbiAgICAvLyBfZjogcmVzb2x2ZUZpbHRlclxuICAgIHJldHVybiAoXCJfZihcXFwiXCIgKyBmaWx0ZXIgKyBcIlxcXCIpKFwiICsgZXhwICsgXCIpXCIpXG4gIH0gZWxzZSB7XG4gICAgdmFyIG5hbWUgPSBmaWx0ZXIuc2xpY2UoMCwgaSk7XG4gICAgdmFyIGFyZ3MgPSBmaWx0ZXIuc2xpY2UoaSArIDEpO1xuICAgIHJldHVybiAoXCJfZihcXFwiXCIgKyBuYW1lICsgXCJcXFwiKShcIiArIGV4cCArIChhcmdzICE9PSAnKScgPyAnLCcgKyBhcmdzIDogYXJncykpXG4gIH1cbn1cblxuLyogICovXG5cblxuXG4vKiBlc2xpbnQtZGlzYWJsZSBuby11bnVzZWQtdmFycyAqL1xuZnVuY3Rpb24gYmFzZVdhcm4gKG1zZywgcmFuZ2UpIHtcbiAgY29uc29sZS5lcnJvcigoXCJbVnVlIGNvbXBpbGVyXTogXCIgKyBtc2cpKTtcbn1cbi8qIGVzbGludC1lbmFibGUgbm8tdW51c2VkLXZhcnMgKi9cblxuZnVuY3Rpb24gcGx1Y2tNb2R1bGVGdW5jdGlvbiAoXG4gIG1vZHVsZXMsXG4gIGtleVxuKSB7XG4gIHJldHVybiBtb2R1bGVzXG4gICAgPyBtb2R1bGVzLm1hcChmdW5jdGlvbiAobSkgeyByZXR1cm4gbVtrZXldOyB9KS5maWx0ZXIoZnVuY3Rpb24gKF8pIHsgcmV0dXJuIF87IH0pXG4gICAgOiBbXVxufVxuXG5mdW5jdGlvbiBhZGRQcm9wIChlbCwgbmFtZSwgdmFsdWUsIHJhbmdlLCBkeW5hbWljKSB7XG4gIChlbC5wcm9wcyB8fCAoZWwucHJvcHMgPSBbXSkpLnB1c2gocmFuZ2VTZXRJdGVtKHsgbmFtZTogbmFtZSwgdmFsdWU6IHZhbHVlLCBkeW5hbWljOiBkeW5hbWljIH0sIHJhbmdlKSk7XG4gIGVsLnBsYWluID0gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIGFkZEF0dHIgKGVsLCBuYW1lLCB2YWx1ZSwgcmFuZ2UsIGR5bmFtaWMpIHtcbiAgdmFyIGF0dHJzID0gZHluYW1pY1xuICAgID8gKGVsLmR5bmFtaWNBdHRycyB8fCAoZWwuZHluYW1pY0F0dHJzID0gW10pKVxuICAgIDogKGVsLmF0dHJzIHx8IChlbC5hdHRycyA9IFtdKSk7XG4gIGF0dHJzLnB1c2gocmFuZ2VTZXRJdGVtKHsgbmFtZTogbmFtZSwgdmFsdWU6IHZhbHVlLCBkeW5hbWljOiBkeW5hbWljIH0sIHJhbmdlKSk7XG4gIGVsLnBsYWluID0gZmFsc2U7XG59XG5cbi8vIGFkZCBhIHJhdyBhdHRyICh1c2UgdGhpcyBpbiBwcmVUcmFuc2Zvcm1zKVxuZnVuY3Rpb24gYWRkUmF3QXR0ciAoZWwsIG5hbWUsIHZhbHVlLCByYW5nZSkge1xuICBlbC5hdHRyc01hcFtuYW1lXSA9IHZhbHVlO1xuICBlbC5hdHRyc0xpc3QucHVzaChyYW5nZVNldEl0ZW0oeyBuYW1lOiBuYW1lLCB2YWx1ZTogdmFsdWUgfSwgcmFuZ2UpKTtcbn1cblxuZnVuY3Rpb24gYWRkRGlyZWN0aXZlIChcbiAgZWwsXG4gIG5hbWUsXG4gIHJhd05hbWUsXG4gIHZhbHVlLFxuICBhcmcsXG4gIGlzRHluYW1pY0FyZyxcbiAgbW9kaWZpZXJzLFxuICByYW5nZVxuKSB7XG4gIChlbC5kaXJlY3RpdmVzIHx8IChlbC5kaXJlY3RpdmVzID0gW10pKS5wdXNoKHJhbmdlU2V0SXRlbSh7XG4gICAgbmFtZTogbmFtZSxcbiAgICByYXdOYW1lOiByYXdOYW1lLFxuICAgIHZhbHVlOiB2YWx1ZSxcbiAgICBhcmc6IGFyZyxcbiAgICBpc0R5bmFtaWNBcmc6IGlzRHluYW1pY0FyZyxcbiAgICBtb2RpZmllcnM6IG1vZGlmaWVyc1xuICB9LCByYW5nZSkpO1xuICBlbC5wbGFpbiA9IGZhbHNlO1xufVxuXG5mdW5jdGlvbiBwcmVwZW5kTW9kaWZpZXJNYXJrZXIgKHN5bWJvbCwgbmFtZSwgZHluYW1pYykge1xuICByZXR1cm4gZHluYW1pY1xuICAgID8gKFwiX3AoXCIgKyBuYW1lICsgXCIsXFxcIlwiICsgc3ltYm9sICsgXCJcXFwiKVwiKVxuICAgIDogc3ltYm9sICsgbmFtZSAvLyBtYXJrIHRoZSBldmVudCBhcyBjYXB0dXJlZFxufVxuXG5mdW5jdGlvbiBhZGRIYW5kbGVyIChcbiAgZWwsXG4gIG5hbWUsXG4gIHZhbHVlLFxuICBtb2RpZmllcnMsXG4gIGltcG9ydGFudCxcbiAgd2FybixcbiAgcmFuZ2UsXG4gIGR5bmFtaWNcbikge1xuICBtb2RpZmllcnMgPSBtb2RpZmllcnMgfHwgZW1wdHlPYmplY3Q7XG4gIC8vIHdhcm4gcHJldmVudCBhbmQgcGFzc2l2ZSBtb2RpZmllclxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgaWYgKFxuICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgd2FybiAmJlxuICAgIG1vZGlmaWVycy5wcmV2ZW50ICYmIG1vZGlmaWVycy5wYXNzaXZlXG4gICkge1xuICAgIHdhcm4oXG4gICAgICAncGFzc2l2ZSBhbmQgcHJldmVudCBjYW5cXCd0IGJlIHVzZWQgdG9nZXRoZXIuICcgK1xuICAgICAgJ1Bhc3NpdmUgaGFuZGxlciBjYW5cXCd0IHByZXZlbnQgZGVmYXVsdCBldmVudC4nLFxuICAgICAgcmFuZ2VcbiAgICApO1xuICB9XG5cbiAgLy8gbm9ybWFsaXplIGNsaWNrLnJpZ2h0IGFuZCBjbGljay5taWRkbGUgc2luY2UgdGhleSBkb24ndCBhY3R1YWxseSBmaXJlXG4gIC8vIHRoaXMgaXMgdGVjaG5pY2FsbHkgYnJvd3Nlci1zcGVjaWZpYywgYnV0IGF0IGxlYXN0IGZvciBub3cgYnJvd3NlcnMgYXJlXG4gIC8vIHRoZSBvbmx5IHRhcmdldCBlbnZzIHRoYXQgaGF2ZSByaWdodC9taWRkbGUgY2xpY2tzLlxuICBpZiAobW9kaWZpZXJzLnJpZ2h0KSB7XG4gICAgaWYgKGR5bmFtaWMpIHtcbiAgICAgIG5hbWUgPSBcIihcIiArIG5hbWUgKyBcIik9PT0nY2xpY2snPydjb250ZXh0bWVudSc6KFwiICsgbmFtZSArIFwiKVwiO1xuICAgIH0gZWxzZSBpZiAobmFtZSA9PT0gJ2NsaWNrJykge1xuICAgICAgbmFtZSA9ICdjb250ZXh0bWVudSc7XG4gICAgICBkZWxldGUgbW9kaWZpZXJzLnJpZ2h0O1xuICAgIH1cbiAgfSBlbHNlIGlmIChtb2RpZmllcnMubWlkZGxlKSB7XG4gICAgaWYgKGR5bmFtaWMpIHtcbiAgICAgIG5hbWUgPSBcIihcIiArIG5hbWUgKyBcIik9PT0nY2xpY2snPydtb3VzZXVwJzooXCIgKyBuYW1lICsgXCIpXCI7XG4gICAgfSBlbHNlIGlmIChuYW1lID09PSAnY2xpY2snKSB7XG4gICAgICBuYW1lID0gJ21vdXNldXAnO1xuICAgIH1cbiAgfVxuXG4gIC8vIGNoZWNrIGNhcHR1cmUgbW9kaWZpZXJcbiAgaWYgKG1vZGlmaWVycy5jYXB0dXJlKSB7XG4gICAgZGVsZXRlIG1vZGlmaWVycy5jYXB0dXJlO1xuICAgIG5hbWUgPSBwcmVwZW5kTW9kaWZpZXJNYXJrZXIoJyEnLCBuYW1lLCBkeW5hbWljKTtcbiAgfVxuICBpZiAobW9kaWZpZXJzLm9uY2UpIHtcbiAgICBkZWxldGUgbW9kaWZpZXJzLm9uY2U7XG4gICAgbmFtZSA9IHByZXBlbmRNb2RpZmllck1hcmtlcignficsIG5hbWUsIGR5bmFtaWMpO1xuICB9XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICBpZiAobW9kaWZpZXJzLnBhc3NpdmUpIHtcbiAgICBkZWxldGUgbW9kaWZpZXJzLnBhc3NpdmU7XG4gICAgbmFtZSA9IHByZXBlbmRNb2RpZmllck1hcmtlcignJicsIG5hbWUsIGR5bmFtaWMpO1xuICB9XG5cbiAgdmFyIGV2ZW50cztcbiAgaWYgKG1vZGlmaWVycy5uYXRpdmUpIHtcbiAgICBkZWxldGUgbW9kaWZpZXJzLm5hdGl2ZTtcbiAgICBldmVudHMgPSBlbC5uYXRpdmVFdmVudHMgfHwgKGVsLm5hdGl2ZUV2ZW50cyA9IHt9KTtcbiAgfSBlbHNlIHtcbiAgICBldmVudHMgPSBlbC5ldmVudHMgfHwgKGVsLmV2ZW50cyA9IHt9KTtcbiAgfVxuXG4gIHZhciBuZXdIYW5kbGVyID0gcmFuZ2VTZXRJdGVtKHsgdmFsdWU6IHZhbHVlLnRyaW0oKSwgZHluYW1pYzogZHluYW1pYyB9LCByYW5nZSk7XG4gIGlmIChtb2RpZmllcnMgIT09IGVtcHR5T2JqZWN0KSB7XG4gICAgbmV3SGFuZGxlci5tb2RpZmllcnMgPSBtb2RpZmllcnM7XG4gIH1cblxuICB2YXIgaGFuZGxlcnMgPSBldmVudHNbbmFtZV07XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICBpZiAoQXJyYXkuaXNBcnJheShoYW5kbGVycykpIHtcbiAgICBpbXBvcnRhbnQgPyBoYW5kbGVycy51bnNoaWZ0KG5ld0hhbmRsZXIpIDogaGFuZGxlcnMucHVzaChuZXdIYW5kbGVyKTtcbiAgfSBlbHNlIGlmIChoYW5kbGVycykge1xuICAgIGV2ZW50c1tuYW1lXSA9IGltcG9ydGFudCA/IFtuZXdIYW5kbGVyLCBoYW5kbGVyc10gOiBbaGFuZGxlcnMsIG5ld0hhbmRsZXJdO1xuICB9IGVsc2Uge1xuICAgIGV2ZW50c1tuYW1lXSA9IG5ld0hhbmRsZXI7XG4gIH1cblxuICBlbC5wbGFpbiA9IGZhbHNlO1xufVxuXG5mdW5jdGlvbiBnZXRSYXdCaW5kaW5nQXR0ciAoXG4gIGVsLFxuICBuYW1lXG4pIHtcbiAgcmV0dXJuIGVsLnJhd0F0dHJzTWFwWyc6JyArIG5hbWVdIHx8XG4gICAgZWwucmF3QXR0cnNNYXBbJ3YtYmluZDonICsgbmFtZV0gfHxcbiAgICBlbC5yYXdBdHRyc01hcFtuYW1lXVxufVxuXG5mdW5jdGlvbiBnZXRCaW5kaW5nQXR0ciAoXG4gIGVsLFxuICBuYW1lLFxuICBnZXRTdGF0aWNcbikge1xuICB2YXIgZHluYW1pY1ZhbHVlID1cbiAgICBnZXRBbmRSZW1vdmVBdHRyKGVsLCAnOicgKyBuYW1lKSB8fFxuICAgIGdldEFuZFJlbW92ZUF0dHIoZWwsICd2LWJpbmQ6JyArIG5hbWUpO1xuICBpZiAoZHluYW1pY1ZhbHVlICE9IG51bGwpIHtcbiAgICByZXR1cm4gcGFyc2VGaWx0ZXJzKGR5bmFtaWNWYWx1ZSlcbiAgfSBlbHNlIGlmIChnZXRTdGF0aWMgIT09IGZhbHNlKSB7XG4gICAgdmFyIHN0YXRpY1ZhbHVlID0gZ2V0QW5kUmVtb3ZlQXR0cihlbCwgbmFtZSk7XG4gICAgaWYgKHN0YXRpY1ZhbHVlICE9IG51bGwpIHtcbiAgICAgIHJldHVybiBKU09OLnN0cmluZ2lmeShzdGF0aWNWYWx1ZSlcbiAgICB9XG4gIH1cbn1cblxuLy8gbm90ZTogdGhpcyBvbmx5IHJlbW92ZXMgdGhlIGF0dHIgZnJvbSB0aGUgQXJyYXkgKGF0dHJzTGlzdCkgc28gdGhhdCBpdFxuLy8gZG9lc24ndCBnZXQgcHJvY2Vzc2VkIGJ5IHByb2Nlc3NBdHRycy5cbi8vIEJ5IGRlZmF1bHQgaXQgZG9lcyBOT1QgcmVtb3ZlIGl0IGZyb20gdGhlIG1hcCAoYXR0cnNNYXApIGJlY2F1c2UgdGhlIG1hcCBpc1xuLy8gbmVlZGVkIGR1cmluZyBjb2RlZ2VuLlxuZnVuY3Rpb24gZ2V0QW5kUmVtb3ZlQXR0ciAoXG4gIGVsLFxuICBuYW1lLFxuICByZW1vdmVGcm9tTWFwXG4pIHtcbiAgdmFyIHZhbDtcbiAgaWYgKCh2YWwgPSBlbC5hdHRyc01hcFtuYW1lXSkgIT0gbnVsbCkge1xuICAgIHZhciBsaXN0ID0gZWwuYXR0cnNMaXN0O1xuICAgIGZvciAodmFyIGkgPSAwLCBsID0gbGlzdC5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgIGlmIChsaXN0W2ldLm5hbWUgPT09IG5hbWUpIHtcbiAgICAgICAgbGlzdC5zcGxpY2UoaSwgMSk7XG4gICAgICAgIGJyZWFrXG4gICAgICB9XG4gICAgfVxuICB9XG4gIGlmIChyZW1vdmVGcm9tTWFwKSB7XG4gICAgZGVsZXRlIGVsLmF0dHJzTWFwW25hbWVdO1xuICB9XG4gIHJldHVybiB2YWxcbn1cblxuZnVuY3Rpb24gZ2V0QW5kUmVtb3ZlQXR0ckJ5UmVnZXggKFxuICBlbCxcbiAgbmFtZVxuKSB7XG4gIHZhciBsaXN0ID0gZWwuYXR0cnNMaXN0O1xuICBmb3IgKHZhciBpID0gMCwgbCA9IGxpc3QubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgdmFyIGF0dHIgPSBsaXN0W2ldO1xuICAgIGlmIChuYW1lLnRlc3QoYXR0ci5uYW1lKSkge1xuICAgICAgbGlzdC5zcGxpY2UoaSwgMSk7XG4gICAgICByZXR1cm4gYXR0clxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiByYW5nZVNldEl0ZW0gKFxuICBpdGVtLFxuICByYW5nZVxuKSB7XG4gIGlmIChyYW5nZSkge1xuICAgIGlmIChyYW5nZS5zdGFydCAhPSBudWxsKSB7XG4gICAgICBpdGVtLnN0YXJ0ID0gcmFuZ2Uuc3RhcnQ7XG4gICAgfVxuICAgIGlmIChyYW5nZS5lbmQgIT0gbnVsbCkge1xuICAgICAgaXRlbS5lbmQgPSByYW5nZS5lbmQ7XG4gICAgfVxuICB9XG4gIHJldHVybiBpdGVtXG59XG5cbi8qICAqL1xuXG4vKipcbiAqIENyb3NzLXBsYXRmb3JtIGNvZGUgZ2VuZXJhdGlvbiBmb3IgY29tcG9uZW50IHYtbW9kZWxcbiAqL1xuZnVuY3Rpb24gZ2VuQ29tcG9uZW50TW9kZWwgKFxuICBlbCxcbiAgdmFsdWUsXG4gIG1vZGlmaWVyc1xuKSB7XG4gIHZhciByZWYgPSBtb2RpZmllcnMgfHwge307XG4gIHZhciBudW1iZXIgPSByZWYubnVtYmVyO1xuICB2YXIgdHJpbSA9IHJlZi50cmltO1xuXG4gIHZhciBiYXNlVmFsdWVFeHByZXNzaW9uID0gJyQkdic7XG4gIHZhciB2YWx1ZUV4cHJlc3Npb24gPSBiYXNlVmFsdWVFeHByZXNzaW9uO1xuICBpZiAodHJpbSkge1xuICAgIHZhbHVlRXhwcmVzc2lvbiA9XG4gICAgICBcIih0eXBlb2YgXCIgKyBiYXNlVmFsdWVFeHByZXNzaW9uICsgXCIgPT09ICdzdHJpbmcnXCIgK1xuICAgICAgXCI/IFwiICsgYmFzZVZhbHVlRXhwcmVzc2lvbiArIFwiLnRyaW0oKVwiICtcbiAgICAgIFwiOiBcIiArIGJhc2VWYWx1ZUV4cHJlc3Npb24gKyBcIilcIjtcbiAgfVxuICBpZiAobnVtYmVyKSB7XG4gICAgdmFsdWVFeHByZXNzaW9uID0gXCJfbihcIiArIHZhbHVlRXhwcmVzc2lvbiArIFwiKVwiO1xuICB9XG4gIHZhciBhc3NpZ25tZW50ID0gZ2VuQXNzaWdubWVudENvZGUodmFsdWUsIHZhbHVlRXhwcmVzc2lvbik7XG5cbiAgZWwubW9kZWwgPSB7XG4gICAgdmFsdWU6IChcIihcIiArIHZhbHVlICsgXCIpXCIpLFxuICAgIGV4cHJlc3Npb246IEpTT04uc3RyaW5naWZ5KHZhbHVlKSxcbiAgICBjYWxsYmFjazogKFwiZnVuY3Rpb24gKFwiICsgYmFzZVZhbHVlRXhwcmVzc2lvbiArIFwiKSB7XCIgKyBhc3NpZ25tZW50ICsgXCJ9XCIpXG4gIH07XG59XG5cbi8qKlxuICogQ3Jvc3MtcGxhdGZvcm0gY29kZWdlbiBoZWxwZXIgZm9yIGdlbmVyYXRpbmcgdi1tb2RlbCB2YWx1ZSBhc3NpZ25tZW50IGNvZGUuXG4gKi9cbmZ1bmN0aW9uIGdlbkFzc2lnbm1lbnRDb2RlIChcbiAgdmFsdWUsXG4gIGFzc2lnbm1lbnRcbikge1xuICB2YXIgcmVzID0gcGFyc2VNb2RlbCh2YWx1ZSk7XG4gIGlmIChyZXMua2V5ID09PSBudWxsKSB7XG4gICAgcmV0dXJuICh2YWx1ZSArIFwiPVwiICsgYXNzaWdubWVudClcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gKFwiJHNldChcIiArIChyZXMuZXhwKSArIFwiLCBcIiArIChyZXMua2V5KSArIFwiLCBcIiArIGFzc2lnbm1lbnQgKyBcIilcIilcbiAgfVxufVxuXG4vKipcbiAqIFBhcnNlIGEgdi1tb2RlbCBleHByZXNzaW9uIGludG8gYSBiYXNlIHBhdGggYW5kIGEgZmluYWwga2V5IHNlZ21lbnQuXG4gKiBIYW5kbGVzIGJvdGggZG90LXBhdGggYW5kIHBvc3NpYmxlIHNxdWFyZSBicmFja2V0cy5cbiAqXG4gKiBQb3NzaWJsZSBjYXNlczpcbiAqXG4gKiAtIHRlc3RcbiAqIC0gdGVzdFtrZXldXG4gKiAtIHRlc3RbdGVzdDFba2V5XV1cbiAqIC0gdGVzdFtcImFcIl1ba2V5XVxuICogLSB4eHgudGVzdFthW2FdLnRlc3QxW2tleV1dXG4gKiAtIHRlc3QueHh4LmFbXCJhc2FcIl1bdGVzdDFba2V5XV1cbiAqXG4gKi9cblxudmFyIGxlbiwgc3RyLCBjaHIsIGluZGV4JDEsIGV4cHJlc3Npb25Qb3MsIGV4cHJlc3Npb25FbmRQb3M7XG5cblxuXG5mdW5jdGlvbiBwYXJzZU1vZGVsICh2YWwpIHtcbiAgLy8gRml4IGh0dHBzOi8vZ2l0aHViLmNvbS92dWVqcy92dWUvcHVsbC83NzMwXG4gIC8vIGFsbG93IHYtbW9kZWw9XCJvYmoudmFsIFwiICh0cmFpbGluZyB3aGl0ZXNwYWNlKVxuICB2YWwgPSB2YWwudHJpbSgpO1xuICBsZW4gPSB2YWwubGVuZ3RoO1xuXG4gIGlmICh2YWwuaW5kZXhPZignWycpIDwgMCB8fCB2YWwubGFzdEluZGV4T2YoJ10nKSA8IGxlbiAtIDEpIHtcbiAgICBpbmRleCQxID0gdmFsLmxhc3RJbmRleE9mKCcuJyk7XG4gICAgaWYgKGluZGV4JDEgPiAtMSkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgZXhwOiB2YWwuc2xpY2UoMCwgaW5kZXgkMSksXG4gICAgICAgIGtleTogJ1wiJyArIHZhbC5zbGljZShpbmRleCQxICsgMSkgKyAnXCInXG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGV4cDogdmFsLFxuICAgICAgICBrZXk6IG51bGxcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBzdHIgPSB2YWw7XG4gIGluZGV4JDEgPSBleHByZXNzaW9uUG9zID0gZXhwcmVzc2lvbkVuZFBvcyA9IDA7XG5cbiAgd2hpbGUgKCFlb2YoKSkge1xuICAgIGNociA9IG5leHQoKTtcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICBpZiAoaXNTdHJpbmdTdGFydChjaHIpKSB7XG4gICAgICBwYXJzZVN0cmluZyhjaHIpO1xuICAgIH0gZWxzZSBpZiAoY2hyID09PSAweDVCKSB7XG4gICAgICBwYXJzZUJyYWNrZXQoY2hyKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4ge1xuICAgIGV4cDogdmFsLnNsaWNlKDAsIGV4cHJlc3Npb25Qb3MpLFxuICAgIGtleTogdmFsLnNsaWNlKGV4cHJlc3Npb25Qb3MgKyAxLCBleHByZXNzaW9uRW5kUG9zKVxuICB9XG59XG5cbmZ1bmN0aW9uIG5leHQgKCkge1xuICByZXR1cm4gc3RyLmNoYXJDb2RlQXQoKytpbmRleCQxKVxufVxuXG5mdW5jdGlvbiBlb2YgKCkge1xuICByZXR1cm4gaW5kZXgkMSA+PSBsZW5cbn1cblxuZnVuY3Rpb24gaXNTdHJpbmdTdGFydCAoY2hyKSB7XG4gIHJldHVybiBjaHIgPT09IDB4MjIgfHwgY2hyID09PSAweDI3XG59XG5cbmZ1bmN0aW9uIHBhcnNlQnJhY2tldCAoY2hyKSB7XG4gIHZhciBpbkJyYWNrZXQgPSAxO1xuICBleHByZXNzaW9uUG9zID0gaW5kZXgkMTtcbiAgd2hpbGUgKCFlb2YoKSkge1xuICAgIGNociA9IG5leHQoKTtcbiAgICBpZiAoaXNTdHJpbmdTdGFydChjaHIpKSB7XG4gICAgICBwYXJzZVN0cmluZyhjaHIpO1xuICAgICAgY29udGludWVcbiAgICB9XG4gICAgaWYgKGNociA9PT0gMHg1QikgeyBpbkJyYWNrZXQrKzsgfVxuICAgIGlmIChjaHIgPT09IDB4NUQpIHsgaW5CcmFja2V0LS07IH1cbiAgICBpZiAoaW5CcmFja2V0ID09PSAwKSB7XG4gICAgICBleHByZXNzaW9uRW5kUG9zID0gaW5kZXgkMTtcbiAgICAgIGJyZWFrXG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHBhcnNlU3RyaW5nIChjaHIpIHtcbiAgdmFyIHN0cmluZ1F1b3RlID0gY2hyO1xuICB3aGlsZSAoIWVvZigpKSB7XG4gICAgY2hyID0gbmV4dCgpO1xuICAgIGlmIChjaHIgPT09IHN0cmluZ1F1b3RlKSB7XG4gICAgICBicmVha1xuICAgIH1cbiAgfVxufVxuXG4vKiAgKi9cblxudmFyIHdhcm4kMTtcblxuLy8gaW4gc29tZSBjYXNlcywgdGhlIGV2ZW50IHVzZWQgaGFzIHRvIGJlIGRldGVybWluZWQgYXQgcnVudGltZVxuLy8gc28gd2UgdXNlZCBzb21lIHJlc2VydmVkIHRva2VucyBkdXJpbmcgY29tcGlsZS5cbnZhciBSQU5HRV9UT0tFTiA9ICdfX3InO1xudmFyIENIRUNLQk9YX1JBRElPX1RPS0VOID0gJ19fYyc7XG5cbmZ1bmN0aW9uIG1vZGVsIChcbiAgZWwsXG4gIGRpcixcbiAgX3dhcm5cbikge1xuICB3YXJuJDEgPSBfd2FybjtcbiAgdmFyIHZhbHVlID0gZGlyLnZhbHVlO1xuICB2YXIgbW9kaWZpZXJzID0gZGlyLm1vZGlmaWVycztcbiAgdmFyIHRhZyA9IGVsLnRhZztcbiAgdmFyIHR5cGUgPSBlbC5hdHRyc01hcC50eXBlO1xuXG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgLy8gaW5wdXRzIHdpdGggdHlwZT1cImZpbGVcIiBhcmUgcmVhZCBvbmx5IGFuZCBzZXR0aW5nIHRoZSBpbnB1dCdzXG4gICAgLy8gdmFsdWUgd2lsbCB0aHJvdyBhbiBlcnJvci5cbiAgICBpZiAodGFnID09PSAnaW5wdXQnICYmIHR5cGUgPT09ICdmaWxlJykge1xuICAgICAgd2FybiQxKFxuICAgICAgICBcIjxcIiArIChlbC50YWcpICsgXCIgdi1tb2RlbD1cXFwiXCIgKyB2YWx1ZSArIFwiXFxcIiB0eXBlPVxcXCJmaWxlXFxcIj46XFxuXCIgK1xuICAgICAgICBcIkZpbGUgaW5wdXRzIGFyZSByZWFkIG9ubHkuIFVzZSBhIHYtb246Y2hhbmdlIGxpc3RlbmVyIGluc3RlYWQuXCIsXG4gICAgICAgIGVsLnJhd0F0dHJzTWFwWyd2LW1vZGVsJ11cbiAgICAgICk7XG4gICAgfVxuICB9XG5cbiAgaWYgKGVsLmNvbXBvbmVudCkge1xuICAgIGdlbkNvbXBvbmVudE1vZGVsKGVsLCB2YWx1ZSwgbW9kaWZpZXJzKTtcbiAgICAvLyBjb21wb25lbnQgdi1tb2RlbCBkb2Vzbid0IG5lZWQgZXh0cmEgcnVudGltZVxuICAgIHJldHVybiBmYWxzZVxuICB9IGVsc2UgaWYgKHRhZyA9PT0gJ3NlbGVjdCcpIHtcbiAgICBnZW5TZWxlY3QoZWwsIHZhbHVlLCBtb2RpZmllcnMpO1xuICB9IGVsc2UgaWYgKHRhZyA9PT0gJ2lucHV0JyAmJiB0eXBlID09PSAnY2hlY2tib3gnKSB7XG4gICAgZ2VuQ2hlY2tib3hNb2RlbChlbCwgdmFsdWUsIG1vZGlmaWVycyk7XG4gIH0gZWxzZSBpZiAodGFnID09PSAnaW5wdXQnICYmIHR5cGUgPT09ICdyYWRpbycpIHtcbiAgICBnZW5SYWRpb01vZGVsKGVsLCB2YWx1ZSwgbW9kaWZpZXJzKTtcbiAgfSBlbHNlIGlmICh0YWcgPT09ICdpbnB1dCcgfHwgdGFnID09PSAndGV4dGFyZWEnKSB7XG4gICAgZ2VuRGVmYXVsdE1vZGVsKGVsLCB2YWx1ZSwgbW9kaWZpZXJzKTtcbiAgfSBlbHNlIGlmICghY29uZmlnLmlzUmVzZXJ2ZWRUYWcodGFnKSkge1xuICAgIGdlbkNvbXBvbmVudE1vZGVsKGVsLCB2YWx1ZSwgbW9kaWZpZXJzKTtcbiAgICAvLyBjb21wb25lbnQgdi1tb2RlbCBkb2Vzbid0IG5lZWQgZXh0cmEgcnVudGltZVxuICAgIHJldHVybiBmYWxzZVxuICB9IGVsc2UgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICB3YXJuJDEoXG4gICAgICBcIjxcIiArIChlbC50YWcpICsgXCIgdi1tb2RlbD1cXFwiXCIgKyB2YWx1ZSArIFwiXFxcIj46IFwiICtcbiAgICAgIFwidi1tb2RlbCBpcyBub3Qgc3VwcG9ydGVkIG9uIHRoaXMgZWxlbWVudCB0eXBlLiBcIiArXG4gICAgICAnSWYgeW91IGFyZSB3b3JraW5nIHdpdGggY29udGVudGVkaXRhYmxlLCBpdFxcJ3MgcmVjb21tZW5kZWQgdG8gJyArXG4gICAgICAnd3JhcCBhIGxpYnJhcnkgZGVkaWNhdGVkIGZvciB0aGF0IHB1cnBvc2UgaW5zaWRlIGEgY3VzdG9tIGNvbXBvbmVudC4nLFxuICAgICAgZWwucmF3QXR0cnNNYXBbJ3YtbW9kZWwnXVxuICAgICk7XG4gIH1cblxuICAvLyBlbnN1cmUgcnVudGltZSBkaXJlY3RpdmUgbWV0YWRhdGFcbiAgcmV0dXJuIHRydWVcbn1cblxuZnVuY3Rpb24gZ2VuQ2hlY2tib3hNb2RlbCAoXG4gIGVsLFxuICB2YWx1ZSxcbiAgbW9kaWZpZXJzXG4pIHtcbiAgdmFyIG51bWJlciA9IG1vZGlmaWVycyAmJiBtb2RpZmllcnMubnVtYmVyO1xuICB2YXIgdmFsdWVCaW5kaW5nID0gZ2V0QmluZGluZ0F0dHIoZWwsICd2YWx1ZScpIHx8ICdudWxsJztcbiAgdmFyIHRydWVWYWx1ZUJpbmRpbmcgPSBnZXRCaW5kaW5nQXR0cihlbCwgJ3RydWUtdmFsdWUnKSB8fCAndHJ1ZSc7XG4gIHZhciBmYWxzZVZhbHVlQmluZGluZyA9IGdldEJpbmRpbmdBdHRyKGVsLCAnZmFsc2UtdmFsdWUnKSB8fCAnZmFsc2UnO1xuICBhZGRQcm9wKGVsLCAnY2hlY2tlZCcsXG4gICAgXCJBcnJheS5pc0FycmF5KFwiICsgdmFsdWUgKyBcIilcIiArXG4gICAgXCI/X2koXCIgKyB2YWx1ZSArIFwiLFwiICsgdmFsdWVCaW5kaW5nICsgXCIpPi0xXCIgKyAoXG4gICAgICB0cnVlVmFsdWVCaW5kaW5nID09PSAndHJ1ZSdcbiAgICAgICAgPyAoXCI6KFwiICsgdmFsdWUgKyBcIilcIilcbiAgICAgICAgOiAoXCI6X3EoXCIgKyB2YWx1ZSArIFwiLFwiICsgdHJ1ZVZhbHVlQmluZGluZyArIFwiKVwiKVxuICAgIClcbiAgKTtcbiAgYWRkSGFuZGxlcihlbCwgJ2NoYW5nZScsXG4gICAgXCJ2YXIgJCRhPVwiICsgdmFsdWUgKyBcIixcIiArXG4gICAgICAgICckJGVsPSRldmVudC50YXJnZXQsJyArXG4gICAgICAgIFwiJCRjPSQkZWwuY2hlY2tlZD8oXCIgKyB0cnVlVmFsdWVCaW5kaW5nICsgXCIpOihcIiArIGZhbHNlVmFsdWVCaW5kaW5nICsgXCIpO1wiICtcbiAgICAnaWYoQXJyYXkuaXNBcnJheSgkJGEpKXsnICtcbiAgICAgIFwidmFyICQkdj1cIiArIChudW1iZXIgPyAnX24oJyArIHZhbHVlQmluZGluZyArICcpJyA6IHZhbHVlQmluZGluZykgKyBcIixcIiArXG4gICAgICAgICAgJyQkaT1faSgkJGEsJCR2KTsnICtcbiAgICAgIFwiaWYoJCRlbC5jaGVja2VkKXskJGk8MCYmKFwiICsgKGdlbkFzc2lnbm1lbnRDb2RlKHZhbHVlLCAnJCRhLmNvbmNhdChbJCR2XSknKSkgKyBcIil9XCIgK1xuICAgICAgXCJlbHNleyQkaT4tMSYmKFwiICsgKGdlbkFzc2lnbm1lbnRDb2RlKHZhbHVlLCAnJCRhLnNsaWNlKDAsJCRpKS5jb25jYXQoJCRhLnNsaWNlKCQkaSsxKSknKSkgKyBcIil9XCIgK1xuICAgIFwifWVsc2V7XCIgKyAoZ2VuQXNzaWdubWVudENvZGUodmFsdWUsICckJGMnKSkgKyBcIn1cIixcbiAgICBudWxsLCB0cnVlXG4gICk7XG59XG5cbmZ1bmN0aW9uIGdlblJhZGlvTW9kZWwgKFxuICBlbCxcbiAgdmFsdWUsXG4gIG1vZGlmaWVyc1xuKSB7XG4gIHZhciBudW1iZXIgPSBtb2RpZmllcnMgJiYgbW9kaWZpZXJzLm51bWJlcjtcbiAgdmFyIHZhbHVlQmluZGluZyA9IGdldEJpbmRpbmdBdHRyKGVsLCAndmFsdWUnKSB8fCAnbnVsbCc7XG4gIHZhbHVlQmluZGluZyA9IG51bWJlciA/IChcIl9uKFwiICsgdmFsdWVCaW5kaW5nICsgXCIpXCIpIDogdmFsdWVCaW5kaW5nO1xuICBhZGRQcm9wKGVsLCAnY2hlY2tlZCcsIChcIl9xKFwiICsgdmFsdWUgKyBcIixcIiArIHZhbHVlQmluZGluZyArIFwiKVwiKSk7XG4gIGFkZEhhbmRsZXIoZWwsICdjaGFuZ2UnLCBnZW5Bc3NpZ25tZW50Q29kZSh2YWx1ZSwgdmFsdWVCaW5kaW5nKSwgbnVsbCwgdHJ1ZSk7XG59XG5cbmZ1bmN0aW9uIGdlblNlbGVjdCAoXG4gIGVsLFxuICB2YWx1ZSxcbiAgbW9kaWZpZXJzXG4pIHtcbiAgdmFyIG51bWJlciA9IG1vZGlmaWVycyAmJiBtb2RpZmllcnMubnVtYmVyO1xuICB2YXIgc2VsZWN0ZWRWYWwgPSBcIkFycmF5LnByb3RvdHlwZS5maWx0ZXJcIiArXG4gICAgXCIuY2FsbCgkZXZlbnQudGFyZ2V0Lm9wdGlvbnMsZnVuY3Rpb24obyl7cmV0dXJuIG8uc2VsZWN0ZWR9KVwiICtcbiAgICBcIi5tYXAoZnVuY3Rpb24obyl7dmFyIHZhbCA9IFxcXCJfdmFsdWVcXFwiIGluIG8gPyBvLl92YWx1ZSA6IG8udmFsdWU7XCIgK1xuICAgIFwicmV0dXJuIFwiICsgKG51bWJlciA/ICdfbih2YWwpJyA6ICd2YWwnKSArIFwifSlcIjtcblxuICB2YXIgYXNzaWdubWVudCA9ICckZXZlbnQudGFyZ2V0Lm11bHRpcGxlID8gJCRzZWxlY3RlZFZhbCA6ICQkc2VsZWN0ZWRWYWxbMF0nO1xuICB2YXIgY29kZSA9IFwidmFyICQkc2VsZWN0ZWRWYWwgPSBcIiArIHNlbGVjdGVkVmFsICsgXCI7XCI7XG4gIGNvZGUgPSBjb2RlICsgXCIgXCIgKyAoZ2VuQXNzaWdubWVudENvZGUodmFsdWUsIGFzc2lnbm1lbnQpKTtcbiAgYWRkSGFuZGxlcihlbCwgJ2NoYW5nZScsIGNvZGUsIG51bGwsIHRydWUpO1xufVxuXG5mdW5jdGlvbiBnZW5EZWZhdWx0TW9kZWwgKFxuICBlbCxcbiAgdmFsdWUsXG4gIG1vZGlmaWVyc1xuKSB7XG4gIHZhciB0eXBlID0gZWwuYXR0cnNNYXAudHlwZTtcblxuICAvLyB3YXJuIGlmIHYtYmluZDp2YWx1ZSBjb25mbGljdHMgd2l0aCB2LW1vZGVsXG4gIC8vIGV4Y2VwdCBmb3IgaW5wdXRzIHdpdGggdi1iaW5kOnR5cGVcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICB2YXIgdmFsdWUkMSA9IGVsLmF0dHJzTWFwWyd2LWJpbmQ6dmFsdWUnXSB8fCBlbC5hdHRyc01hcFsnOnZhbHVlJ107XG4gICAgdmFyIHR5cGVCaW5kaW5nID0gZWwuYXR0cnNNYXBbJ3YtYmluZDp0eXBlJ10gfHwgZWwuYXR0cnNNYXBbJzp0eXBlJ107XG4gICAgaWYgKHZhbHVlJDEgJiYgIXR5cGVCaW5kaW5nKSB7XG4gICAgICB2YXIgYmluZGluZyA9IGVsLmF0dHJzTWFwWyd2LWJpbmQ6dmFsdWUnXSA/ICd2LWJpbmQ6dmFsdWUnIDogJzp2YWx1ZSc7XG4gICAgICB3YXJuJDEoXG4gICAgICAgIGJpbmRpbmcgKyBcIj1cXFwiXCIgKyB2YWx1ZSQxICsgXCJcXFwiIGNvbmZsaWN0cyB3aXRoIHYtbW9kZWwgb24gdGhlIHNhbWUgZWxlbWVudCBcIiArXG4gICAgICAgICdiZWNhdXNlIHRoZSBsYXR0ZXIgYWxyZWFkeSBleHBhbmRzIHRvIGEgdmFsdWUgYmluZGluZyBpbnRlcm5hbGx5JyxcbiAgICAgICAgZWwucmF3QXR0cnNNYXBbYmluZGluZ11cbiAgICAgICk7XG4gICAgfVxuICB9XG5cbiAgdmFyIHJlZiA9IG1vZGlmaWVycyB8fCB7fTtcbiAgdmFyIGxhenkgPSByZWYubGF6eTtcbiAgdmFyIG51bWJlciA9IHJlZi5udW1iZXI7XG4gIHZhciB0cmltID0gcmVmLnRyaW07XG4gIHZhciBuZWVkQ29tcG9zaXRpb25HdWFyZCA9ICFsYXp5ICYmIHR5cGUgIT09ICdyYW5nZSc7XG4gIHZhciBldmVudCA9IGxhenlcbiAgICA/ICdjaGFuZ2UnXG4gICAgOiB0eXBlID09PSAncmFuZ2UnXG4gICAgICA/IFJBTkdFX1RPS0VOXG4gICAgICA6ICdpbnB1dCc7XG5cbiAgdmFyIHZhbHVlRXhwcmVzc2lvbiA9ICckZXZlbnQudGFyZ2V0LnZhbHVlJztcbiAgaWYgKHRyaW0pIHtcbiAgICB2YWx1ZUV4cHJlc3Npb24gPSBcIiRldmVudC50YXJnZXQudmFsdWUudHJpbSgpXCI7XG4gIH1cbiAgaWYgKG51bWJlcikge1xuICAgIHZhbHVlRXhwcmVzc2lvbiA9IFwiX24oXCIgKyB2YWx1ZUV4cHJlc3Npb24gKyBcIilcIjtcbiAgfVxuXG4gIHZhciBjb2RlID0gZ2VuQXNzaWdubWVudENvZGUodmFsdWUsIHZhbHVlRXhwcmVzc2lvbik7XG4gIGlmIChuZWVkQ29tcG9zaXRpb25HdWFyZCkge1xuICAgIGNvZGUgPSBcImlmKCRldmVudC50YXJnZXQuY29tcG9zaW5nKXJldHVybjtcIiArIGNvZGU7XG4gIH1cblxuICBhZGRQcm9wKGVsLCAndmFsdWUnLCAoXCIoXCIgKyB2YWx1ZSArIFwiKVwiKSk7XG4gIGFkZEhhbmRsZXIoZWwsIGV2ZW50LCBjb2RlLCBudWxsLCB0cnVlKTtcbiAgaWYgKHRyaW0gfHwgbnVtYmVyKSB7XG4gICAgYWRkSGFuZGxlcihlbCwgJ2JsdXInLCAnJGZvcmNlVXBkYXRlKCknKTtcbiAgfVxufVxuXG4vKiAgKi9cblxuLy8gbm9ybWFsaXplIHYtbW9kZWwgZXZlbnQgdG9rZW5zIHRoYXQgY2FuIG9ubHkgYmUgZGV0ZXJtaW5lZCBhdCBydW50aW1lLlxuLy8gaXQncyBpbXBvcnRhbnQgdG8gcGxhY2UgdGhlIGV2ZW50IGFzIHRoZSBmaXJzdCBpbiB0aGUgYXJyYXkgYmVjYXVzZVxuLy8gdGhlIHdob2xlIHBvaW50IGlzIGVuc3VyaW5nIHRoZSB2LW1vZGVsIGNhbGxiYWNrIGdldHMgY2FsbGVkIGJlZm9yZVxuLy8gdXNlci1hdHRhY2hlZCBoYW5kbGVycy5cbmZ1bmN0aW9uIG5vcm1hbGl6ZUV2ZW50cyAob24pIHtcbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gIGlmIChpc0RlZihvbltSQU5HRV9UT0tFTl0pKSB7XG4gICAgLy8gSUUgaW5wdXRbdHlwZT1yYW5nZV0gb25seSBzdXBwb3J0cyBgY2hhbmdlYCBldmVudFxuICAgIHZhciBldmVudCA9IGlzSUUgPyAnY2hhbmdlJyA6ICdpbnB1dCc7XG4gICAgb25bZXZlbnRdID0gW10uY29uY2F0KG9uW1JBTkdFX1RPS0VOXSwgb25bZXZlbnRdIHx8IFtdKTtcbiAgICBkZWxldGUgb25bUkFOR0VfVE9LRU5dO1xuICB9XG4gIC8vIFRoaXMgd2FzIG9yaWdpbmFsbHkgaW50ZW5kZWQgdG8gZml4ICM0NTIxIGJ1dCBubyBsb25nZXIgbmVjZXNzYXJ5XG4gIC8vIGFmdGVyIDIuNS4gS2VlcGluZyBpdCBmb3IgYmFja3dhcmRzIGNvbXBhdCB3aXRoIGdlbmVyYXRlZCBjb2RlIGZyb20gPCAyLjRcbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gIGlmIChpc0RlZihvbltDSEVDS0JPWF9SQURJT19UT0tFTl0pKSB7XG4gICAgb24uY2hhbmdlID0gW10uY29uY2F0KG9uW0NIRUNLQk9YX1JBRElPX1RPS0VOXSwgb24uY2hhbmdlIHx8IFtdKTtcbiAgICBkZWxldGUgb25bQ0hFQ0tCT1hfUkFESU9fVE9LRU5dO1xuICB9XG59XG5cbnZhciB0YXJnZXQkMTtcblxuZnVuY3Rpb24gY3JlYXRlT25jZUhhbmRsZXIkMSAoZXZlbnQsIGhhbmRsZXIsIGNhcHR1cmUpIHtcbiAgdmFyIF90YXJnZXQgPSB0YXJnZXQkMTsgLy8gc2F2ZSBjdXJyZW50IHRhcmdldCBlbGVtZW50IGluIGNsb3N1cmVcbiAgcmV0dXJuIGZ1bmN0aW9uIG9uY2VIYW5kbGVyICgpIHtcbiAgICB2YXIgcmVzID0gaGFuZGxlci5hcHBseShudWxsLCBhcmd1bWVudHMpO1xuICAgIGlmIChyZXMgIT09IG51bGwpIHtcbiAgICAgIHJlbW92ZSQyKGV2ZW50LCBvbmNlSGFuZGxlciwgY2FwdHVyZSwgX3RhcmdldCk7XG4gICAgfVxuICB9XG59XG5cbi8vICM5NDQ2OiBGaXJlZm94IDw9IDUzIChpbiBwYXJ0aWN1bGFyLCBFU1IgNTIpIGhhcyBpbmNvcnJlY3QgRXZlbnQudGltZVN0YW1wXG4vLyBpbXBsZW1lbnRhdGlvbiBhbmQgZG9lcyBub3QgZmlyZSBtaWNyb3Rhc2tzIGluIGJldHdlZW4gZXZlbnQgcHJvcGFnYXRpb24sIHNvXG4vLyBzYWZlIHRvIGV4Y2x1ZGUuXG52YXIgdXNlTWljcm90YXNrRml4ID0gaXNVc2luZ01pY3JvVGFzayAmJiAhKGlzRkYgJiYgTnVtYmVyKGlzRkZbMV0pIDw9IDUzKTtcblxuZnVuY3Rpb24gYWRkJDEgKFxuICBuYW1lLFxuICBoYW5kbGVyLFxuICBjYXB0dXJlLFxuICBwYXNzaXZlXG4pIHtcbiAgLy8gYXN5bmMgZWRnZSBjYXNlICM2NTY2OiBpbm5lciBjbGljayBldmVudCB0cmlnZ2VycyBwYXRjaCwgZXZlbnQgaGFuZGxlclxuICAvLyBhdHRhY2hlZCB0byBvdXRlciBlbGVtZW50IGR1cmluZyBwYXRjaCwgYW5kIHRyaWdnZXJlZCBhZ2Fpbi4gVGhpc1xuICAvLyBoYXBwZW5zIGJlY2F1c2UgYnJvd3NlcnMgZmlyZSBtaWNyb3Rhc2sgdGlja3MgYmV0d2VlbiBldmVudCBwcm9wYWdhdGlvbi5cbiAgLy8gdGhlIHNvbHV0aW9uIGlzIHNpbXBsZTogd2Ugc2F2ZSB0aGUgdGltZXN0YW1wIHdoZW4gYSBoYW5kbGVyIGlzIGF0dGFjaGVkLFxuICAvLyBhbmQgdGhlIGhhbmRsZXIgd291bGQgb25seSBmaXJlIGlmIHRoZSBldmVudCBwYXNzZWQgdG8gaXQgd2FzIGZpcmVkXG4gIC8vIEFGVEVSIGl0IHdhcyBhdHRhY2hlZC5cbiAgaWYgKHVzZU1pY3JvdGFza0ZpeCkge1xuICAgIHZhciBhdHRhY2hlZFRpbWVzdGFtcCA9IGN1cnJlbnRGbHVzaFRpbWVzdGFtcDtcbiAgICB2YXIgb3JpZ2luYWwgPSBoYW5kbGVyO1xuICAgIGhhbmRsZXIgPSBvcmlnaW5hbC5fd3JhcHBlciA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICBpZiAoXG4gICAgICAgIC8vIG5vIGJ1YmJsaW5nLCBzaG91bGQgYWx3YXlzIGZpcmUuXG4gICAgICAgIC8vIHRoaXMgaXMganVzdCBhIHNhZmV0eSBuZXQgaW4gY2FzZSBldmVudC50aW1lU3RhbXAgaXMgdW5yZWxpYWJsZSBpblxuICAgICAgICAvLyBjZXJ0YWluIHdlaXJkIGVudmlyb25tZW50cy4uLlxuICAgICAgICBlLnRhcmdldCA9PT0gZS5jdXJyZW50VGFyZ2V0IHx8XG4gICAgICAgIC8vIGV2ZW50IGlzIGZpcmVkIGFmdGVyIGhhbmRsZXIgYXR0YWNobWVudFxuICAgICAgICBlLnRpbWVTdGFtcCA+PSBhdHRhY2hlZFRpbWVzdGFtcCB8fFxuICAgICAgICAvLyBiYWlsIGZvciBlbnZpcm9ubWVudHMgdGhhdCBoYXZlIGJ1Z2d5IGV2ZW50LnRpbWVTdGFtcCBpbXBsZW1lbnRhdGlvbnNcbiAgICAgICAgLy8gIzk0NjIgaU9TIDkgYnVnOiBldmVudC50aW1lU3RhbXAgaXMgMCBhZnRlciBoaXN0b3J5LnB1c2hTdGF0ZVxuICAgICAgICAvLyAjOTY4MSBRdFdlYkVuZ2luZSBldmVudC50aW1lU3RhbXAgaXMgbmVnYXRpdmUgdmFsdWVcbiAgICAgICAgZS50aW1lU3RhbXAgPD0gMCB8fFxuICAgICAgICAvLyAjOTQ0OCBiYWlsIGlmIGV2ZW50IGlzIGZpcmVkIGluIGFub3RoZXIgZG9jdW1lbnQgaW4gYSBtdWx0aS1wYWdlXG4gICAgICAgIC8vIGVsZWN0cm9uL253LmpzIGFwcCwgc2luY2UgZXZlbnQudGltZVN0YW1wIHdpbGwgYmUgdXNpbmcgYSBkaWZmZXJlbnRcbiAgICAgICAgLy8gc3RhcnRpbmcgcmVmZXJlbmNlXG4gICAgICAgIGUudGFyZ2V0Lm93bmVyRG9jdW1lbnQgIT09IGRvY3VtZW50XG4gICAgICApIHtcbiAgICAgICAgcmV0dXJuIG9yaWdpbmFsLmFwcGx5KHRoaXMsIGFyZ3VtZW50cylcbiAgICAgIH1cbiAgICB9O1xuICB9XG4gIHRhcmdldCQxLmFkZEV2ZW50TGlzdGVuZXIoXG4gICAgbmFtZSxcbiAgICBoYW5kbGVyLFxuICAgIHN1cHBvcnRzUGFzc2l2ZVxuICAgICAgPyB7IGNhcHR1cmU6IGNhcHR1cmUsIHBhc3NpdmU6IHBhc3NpdmUgfVxuICAgICAgOiBjYXB0dXJlXG4gICk7XG59XG5cbmZ1bmN0aW9uIHJlbW92ZSQyIChcbiAgbmFtZSxcbiAgaGFuZGxlcixcbiAgY2FwdHVyZSxcbiAgX3RhcmdldFxuKSB7XG4gIChfdGFyZ2V0IHx8IHRhcmdldCQxKS5yZW1vdmVFdmVudExpc3RlbmVyKFxuICAgIG5hbWUsXG4gICAgaGFuZGxlci5fd3JhcHBlciB8fCBoYW5kbGVyLFxuICAgIGNhcHR1cmVcbiAgKTtcbn1cblxuZnVuY3Rpb24gdXBkYXRlRE9NTGlzdGVuZXJzIChvbGRWbm9kZSwgdm5vZGUpIHtcbiAgaWYgKGlzVW5kZWYob2xkVm5vZGUuZGF0YS5vbikgJiYgaXNVbmRlZih2bm9kZS5kYXRhLm9uKSkge1xuICAgIHJldHVyblxuICB9XG4gIHZhciBvbiA9IHZub2RlLmRhdGEub24gfHwge307XG4gIHZhciBvbGRPbiA9IG9sZFZub2RlLmRhdGEub24gfHwge307XG4gIHRhcmdldCQxID0gdm5vZGUuZWxtO1xuICBub3JtYWxpemVFdmVudHMob24pO1xuICB1cGRhdGVMaXN0ZW5lcnMob24sIG9sZE9uLCBhZGQkMSwgcmVtb3ZlJDIsIGNyZWF0ZU9uY2VIYW5kbGVyJDEsIHZub2RlLmNvbnRleHQpO1xuICB0YXJnZXQkMSA9IHVuZGVmaW5lZDtcbn1cblxudmFyIGV2ZW50cyA9IHtcbiAgY3JlYXRlOiB1cGRhdGVET01MaXN0ZW5lcnMsXG4gIHVwZGF0ZTogdXBkYXRlRE9NTGlzdGVuZXJzXG59O1xuXG4vKiAgKi9cblxudmFyIHN2Z0NvbnRhaW5lcjtcblxuZnVuY3Rpb24gdXBkYXRlRE9NUHJvcHMgKG9sZFZub2RlLCB2bm9kZSkge1xuICBpZiAoaXNVbmRlZihvbGRWbm9kZS5kYXRhLmRvbVByb3BzKSAmJiBpc1VuZGVmKHZub2RlLmRhdGEuZG9tUHJvcHMpKSB7XG4gICAgcmV0dXJuXG4gIH1cbiAgdmFyIGtleSwgY3VyO1xuICB2YXIgZWxtID0gdm5vZGUuZWxtO1xuICB2YXIgb2xkUHJvcHMgPSBvbGRWbm9kZS5kYXRhLmRvbVByb3BzIHx8IHt9O1xuICB2YXIgcHJvcHMgPSB2bm9kZS5kYXRhLmRvbVByb3BzIHx8IHt9O1xuICAvLyBjbG9uZSBvYnNlcnZlZCBvYmplY3RzLCBhcyB0aGUgdXNlciBwcm9iYWJseSB3YW50cyB0byBtdXRhdGUgaXRcbiAgaWYgKGlzRGVmKHByb3BzLl9fb2JfXykpIHtcbiAgICBwcm9wcyA9IHZub2RlLmRhdGEuZG9tUHJvcHMgPSBleHRlbmQoe30sIHByb3BzKTtcbiAgfVxuXG4gIGZvciAoa2V5IGluIG9sZFByb3BzKSB7XG4gICAgaWYgKCEoa2V5IGluIHByb3BzKSkge1xuICAgICAgZWxtW2tleV0gPSAnJztcbiAgICB9XG4gIH1cblxuICBmb3IgKGtleSBpbiBwcm9wcykge1xuICAgIGN1ciA9IHByb3BzW2tleV07XG4gICAgLy8gaWdub3JlIGNoaWxkcmVuIGlmIHRoZSBub2RlIGhhcyB0ZXh0Q29udGVudCBvciBpbm5lckhUTUwsXG4gICAgLy8gYXMgdGhlc2Ugd2lsbCB0aHJvdyBhd2F5IGV4aXN0aW5nIERPTSBub2RlcyBhbmQgY2F1c2UgcmVtb3ZhbCBlcnJvcnNcbiAgICAvLyBvbiBzdWJzZXF1ZW50IHBhdGNoZXMgKCMzMzYwKVxuICAgIGlmIChrZXkgPT09ICd0ZXh0Q29udGVudCcgfHwga2V5ID09PSAnaW5uZXJIVE1MJykge1xuICAgICAgaWYgKHZub2RlLmNoaWxkcmVuKSB7IHZub2RlLmNoaWxkcmVuLmxlbmd0aCA9IDA7IH1cbiAgICAgIGlmIChjdXIgPT09IG9sZFByb3BzW2tleV0pIHsgY29udGludWUgfVxuICAgICAgLy8gIzY2MDEgd29yayBhcm91bmQgQ2hyb21lIHZlcnNpb24gPD0gNTUgYnVnIHdoZXJlIHNpbmdsZSB0ZXh0Tm9kZVxuICAgICAgLy8gcmVwbGFjZWQgYnkgaW5uZXJIVE1ML3RleHRDb250ZW50IHJldGFpbnMgaXRzIHBhcmVudE5vZGUgcHJvcGVydHlcbiAgICAgIGlmIChlbG0uY2hpbGROb2Rlcy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgZWxtLnJlbW92ZUNoaWxkKGVsbS5jaGlsZE5vZGVzWzBdKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoa2V5ID09PSAndmFsdWUnICYmIGVsbS50YWdOYW1lICE9PSAnUFJPR1JFU1MnKSB7XG4gICAgICAvLyBzdG9yZSB2YWx1ZSBhcyBfdmFsdWUgYXMgd2VsbCBzaW5jZVxuICAgICAgLy8gbm9uLXN0cmluZyB2YWx1ZXMgd2lsbCBiZSBzdHJpbmdpZmllZFxuICAgICAgZWxtLl92YWx1ZSA9IGN1cjtcbiAgICAgIC8vIGF2b2lkIHJlc2V0dGluZyBjdXJzb3IgcG9zaXRpb24gd2hlbiB2YWx1ZSBpcyB0aGUgc2FtZVxuICAgICAgdmFyIHN0ckN1ciA9IGlzVW5kZWYoY3VyKSA/ICcnIDogU3RyaW5nKGN1cik7XG4gICAgICBpZiAoc2hvdWxkVXBkYXRlVmFsdWUoZWxtLCBzdHJDdXIpKSB7XG4gICAgICAgIGVsbS52YWx1ZSA9IHN0ckN1cjtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGtleSA9PT0gJ2lubmVySFRNTCcgJiYgaXNTVkcoZWxtLnRhZ05hbWUpICYmIGlzVW5kZWYoZWxtLmlubmVySFRNTCkpIHtcbiAgICAgIC8vIElFIGRvZXNuJ3Qgc3VwcG9ydCBpbm5lckhUTUwgZm9yIFNWRyBlbGVtZW50c1xuICAgICAgc3ZnQ29udGFpbmVyID0gc3ZnQ29udGFpbmVyIHx8IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgc3ZnQ29udGFpbmVyLmlubmVySFRNTCA9IFwiPHN2Zz5cIiArIGN1ciArIFwiPC9zdmc+XCI7XG4gICAgICB2YXIgc3ZnID0gc3ZnQ29udGFpbmVyLmZpcnN0Q2hpbGQ7XG4gICAgICB3aGlsZSAoZWxtLmZpcnN0Q2hpbGQpIHtcbiAgICAgICAgZWxtLnJlbW92ZUNoaWxkKGVsbS5maXJzdENoaWxkKTtcbiAgICAgIH1cbiAgICAgIHdoaWxlIChzdmcuZmlyc3RDaGlsZCkge1xuICAgICAgICBlbG0uYXBwZW5kQ2hpbGQoc3ZnLmZpcnN0Q2hpbGQpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoXG4gICAgICAvLyBza2lwIHRoZSB1cGRhdGUgaWYgb2xkIGFuZCBuZXcgVkRPTSBzdGF0ZSBpcyB0aGUgc2FtZS5cbiAgICAgIC8vIGB2YWx1ZWAgaXMgaGFuZGxlZCBzZXBhcmF0ZWx5IGJlY2F1c2UgdGhlIERPTSB2YWx1ZSBtYXkgYmUgdGVtcG9yYXJpbHlcbiAgICAgIC8vIG91dCBvZiBzeW5jIHdpdGggVkRPTSBzdGF0ZSBkdWUgdG8gZm9jdXMsIGNvbXBvc2l0aW9uIGFuZCBtb2RpZmllcnMuXG4gICAgICAvLyBUaGlzICAjNDUyMSBieSBza2lwcGluZyB0aGUgdW5uZWNlc3NhcnkgYGNoZWNrZWRgIHVwZGF0ZS5cbiAgICAgIGN1ciAhPT0gb2xkUHJvcHNba2V5XVxuICAgICkge1xuICAgICAgLy8gc29tZSBwcm9wZXJ0eSB1cGRhdGVzIGNhbiB0aHJvd1xuICAgICAgLy8gZS5nLiBgdmFsdWVgIG9uIDxwcm9ncmVzcz4gdy8gbm9uLWZpbml0ZSB2YWx1ZVxuICAgICAgdHJ5IHtcbiAgICAgICAgZWxtW2tleV0gPSBjdXI7XG4gICAgICB9IGNhdGNoIChlKSB7fVxuICAgIH1cbiAgfVxufVxuXG4vLyBjaGVjayBwbGF0Zm9ybXMvd2ViL3V0aWwvYXR0cnMuanMgYWNjZXB0VmFsdWVcblxuXG5mdW5jdGlvbiBzaG91bGRVcGRhdGVWYWx1ZSAoZWxtLCBjaGVja1ZhbCkge1xuICByZXR1cm4gKCFlbG0uY29tcG9zaW5nICYmIChcbiAgICBlbG0udGFnTmFtZSA9PT0gJ09QVElPTicgfHxcbiAgICBpc05vdEluRm9jdXNBbmREaXJ0eShlbG0sIGNoZWNrVmFsKSB8fFxuICAgIGlzRGlydHlXaXRoTW9kaWZpZXJzKGVsbSwgY2hlY2tWYWwpXG4gICkpXG59XG5cbmZ1bmN0aW9uIGlzTm90SW5Gb2N1c0FuZERpcnR5IChlbG0sIGNoZWNrVmFsKSB7XG4gIC8vIHJldHVybiB0cnVlIHdoZW4gdGV4dGJveCAoLm51bWJlciBhbmQgLnRyaW0pIGxvc2VzIGZvY3VzIGFuZCBpdHMgdmFsdWUgaXNcbiAgLy8gbm90IGVxdWFsIHRvIHRoZSB1cGRhdGVkIHZhbHVlXG4gIHZhciBub3RJbkZvY3VzID0gdHJ1ZTtcbiAgLy8gIzYxNTdcbiAgLy8gd29yayBhcm91bmQgSUUgYnVnIHdoZW4gYWNjZXNzaW5nIGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQgaW4gYW4gaWZyYW1lXG4gIHRyeSB7IG5vdEluRm9jdXMgPSBkb2N1bWVudC5hY3RpdmVFbGVtZW50ICE9PSBlbG07IH0gY2F0Y2ggKGUpIHt9XG4gIHJldHVybiBub3RJbkZvY3VzICYmIGVsbS52YWx1ZSAhPT0gY2hlY2tWYWxcbn1cblxuZnVuY3Rpb24gaXNEaXJ0eVdpdGhNb2RpZmllcnMgKGVsbSwgbmV3VmFsKSB7XG4gIHZhciB2YWx1ZSA9IGVsbS52YWx1ZTtcbiAgdmFyIG1vZGlmaWVycyA9IGVsbS5fdk1vZGlmaWVyczsgLy8gaW5qZWN0ZWQgYnkgdi1tb2RlbCBydW50aW1lXG4gIGlmIChpc0RlZihtb2RpZmllcnMpKSB7XG4gICAgaWYgKG1vZGlmaWVycy5udW1iZXIpIHtcbiAgICAgIHJldHVybiB0b051bWJlcih2YWx1ZSkgIT09IHRvTnVtYmVyKG5ld1ZhbClcbiAgICB9XG4gICAgaWYgKG1vZGlmaWVycy50cmltKSB7XG4gICAgICByZXR1cm4gdmFsdWUudHJpbSgpICE9PSBuZXdWYWwudHJpbSgpXG4gICAgfVxuICB9XG4gIHJldHVybiB2YWx1ZSAhPT0gbmV3VmFsXG59XG5cbnZhciBkb21Qcm9wcyA9IHtcbiAgY3JlYXRlOiB1cGRhdGVET01Qcm9wcyxcbiAgdXBkYXRlOiB1cGRhdGVET01Qcm9wc1xufTtcblxuLyogICovXG5cbnZhciBwYXJzZVN0eWxlVGV4dCA9IGNhY2hlZChmdW5jdGlvbiAoY3NzVGV4dCkge1xuICB2YXIgcmVzID0ge307XG4gIHZhciBsaXN0RGVsaW1pdGVyID0gLzsoPyFbXihdKlxcKSkvZztcbiAgdmFyIHByb3BlcnR5RGVsaW1pdGVyID0gLzooLispLztcbiAgY3NzVGV4dC5zcGxpdChsaXN0RGVsaW1pdGVyKS5mb3JFYWNoKGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgaWYgKGl0ZW0pIHtcbiAgICAgIHZhciB0bXAgPSBpdGVtLnNwbGl0KHByb3BlcnR5RGVsaW1pdGVyKTtcbiAgICAgIHRtcC5sZW5ndGggPiAxICYmIChyZXNbdG1wWzBdLnRyaW0oKV0gPSB0bXBbMV0udHJpbSgpKTtcbiAgICB9XG4gIH0pO1xuICByZXR1cm4gcmVzXG59KTtcblxuLy8gbWVyZ2Ugc3RhdGljIGFuZCBkeW5hbWljIHN0eWxlIGRhdGEgb24gdGhlIHNhbWUgdm5vZGVcbmZ1bmN0aW9uIG5vcm1hbGl6ZVN0eWxlRGF0YSAoZGF0YSkge1xuICB2YXIgc3R5bGUgPSBub3JtYWxpemVTdHlsZUJpbmRpbmcoZGF0YS5zdHlsZSk7XG4gIC8vIHN0YXRpYyBzdHlsZSBpcyBwcmUtcHJvY2Vzc2VkIGludG8gYW4gb2JqZWN0IGR1cmluZyBjb21waWxhdGlvblxuICAvLyBhbmQgaXMgYWx3YXlzIGEgZnJlc2ggb2JqZWN0LCBzbyBpdCdzIHNhZmUgdG8gbWVyZ2UgaW50byBpdFxuICByZXR1cm4gZGF0YS5zdGF0aWNTdHlsZVxuICAgID8gZXh0ZW5kKGRhdGEuc3RhdGljU3R5bGUsIHN0eWxlKVxuICAgIDogc3R5bGVcbn1cblxuLy8gbm9ybWFsaXplIHBvc3NpYmxlIGFycmF5IC8gc3RyaW5nIHZhbHVlcyBpbnRvIE9iamVjdFxuZnVuY3Rpb24gbm9ybWFsaXplU3R5bGVCaW5kaW5nIChiaW5kaW5nU3R5bGUpIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkoYmluZGluZ1N0eWxlKSkge1xuICAgIHJldHVybiB0b09iamVjdChiaW5kaW5nU3R5bGUpXG4gIH1cbiAgaWYgKHR5cGVvZiBiaW5kaW5nU3R5bGUgPT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIHBhcnNlU3R5bGVUZXh0KGJpbmRpbmdTdHlsZSlcbiAgfVxuICByZXR1cm4gYmluZGluZ1N0eWxlXG59XG5cbi8qKlxuICogcGFyZW50IGNvbXBvbmVudCBzdHlsZSBzaG91bGQgYmUgYWZ0ZXIgY2hpbGQnc1xuICogc28gdGhhdCBwYXJlbnQgY29tcG9uZW50J3Mgc3R5bGUgY291bGQgb3ZlcnJpZGUgaXRcbiAqL1xuZnVuY3Rpb24gZ2V0U3R5bGUgKHZub2RlLCBjaGVja0NoaWxkKSB7XG4gIHZhciByZXMgPSB7fTtcbiAgdmFyIHN0eWxlRGF0YTtcblxuICBpZiAoY2hlY2tDaGlsZCkge1xuICAgIHZhciBjaGlsZE5vZGUgPSB2bm9kZTtcbiAgICB3aGlsZSAoY2hpbGROb2RlLmNvbXBvbmVudEluc3RhbmNlKSB7XG4gICAgICBjaGlsZE5vZGUgPSBjaGlsZE5vZGUuY29tcG9uZW50SW5zdGFuY2UuX3Zub2RlO1xuICAgICAgaWYgKFxuICAgICAgICBjaGlsZE5vZGUgJiYgY2hpbGROb2RlLmRhdGEgJiZcbiAgICAgICAgKHN0eWxlRGF0YSA9IG5vcm1hbGl6ZVN0eWxlRGF0YShjaGlsZE5vZGUuZGF0YSkpXG4gICAgICApIHtcbiAgICAgICAgZXh0ZW5kKHJlcywgc3R5bGVEYXRhKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBpZiAoKHN0eWxlRGF0YSA9IG5vcm1hbGl6ZVN0eWxlRGF0YSh2bm9kZS5kYXRhKSkpIHtcbiAgICBleHRlbmQocmVzLCBzdHlsZURhdGEpO1xuICB9XG5cbiAgdmFyIHBhcmVudE5vZGUgPSB2bm9kZTtcbiAgd2hpbGUgKChwYXJlbnROb2RlID0gcGFyZW50Tm9kZS5wYXJlbnQpKSB7XG4gICAgaWYgKHBhcmVudE5vZGUuZGF0YSAmJiAoc3R5bGVEYXRhID0gbm9ybWFsaXplU3R5bGVEYXRhKHBhcmVudE5vZGUuZGF0YSkpKSB7XG4gICAgICBleHRlbmQocmVzLCBzdHlsZURhdGEpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzXG59XG5cbi8qICAqL1xuXG52YXIgY3NzVmFyUkUgPSAvXi0tLztcbnZhciBpbXBvcnRhbnRSRSA9IC9cXHMqIWltcG9ydGFudCQvO1xudmFyIHNldFByb3AgPSBmdW5jdGlvbiAoZWwsIG5hbWUsIHZhbCkge1xuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgaWYgKGNzc1ZhclJFLnRlc3QobmFtZSkpIHtcbiAgICBlbC5zdHlsZS5zZXRQcm9wZXJ0eShuYW1lLCB2YWwpO1xuICB9IGVsc2UgaWYgKGltcG9ydGFudFJFLnRlc3QodmFsKSkge1xuICAgIGVsLnN0eWxlLnNldFByb3BlcnR5KGh5cGhlbmF0ZShuYW1lKSwgdmFsLnJlcGxhY2UoaW1wb3J0YW50UkUsICcnKSwgJ2ltcG9ydGFudCcpO1xuICB9IGVsc2Uge1xuICAgIHZhciBub3JtYWxpemVkTmFtZSA9IG5vcm1hbGl6ZShuYW1lKTtcbiAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWwpKSB7XG4gICAgICAvLyBTdXBwb3J0IHZhbHVlcyBhcnJheSBjcmVhdGVkIGJ5IGF1dG9wcmVmaXhlciwgZS5nLlxuICAgICAgLy8ge2Rpc3BsYXk6IFtcIi13ZWJraXQtYm94XCIsIFwiLW1zLWZsZXhib3hcIiwgXCJmbGV4XCJdfVxuICAgICAgLy8gU2V0IHRoZW0gb25lIGJ5IG9uZSwgYW5kIHRoZSBicm93c2VyIHdpbGwgb25seSBzZXQgdGhvc2UgaXQgY2FuIHJlY29nbml6ZVxuICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IHZhbC5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICBlbC5zdHlsZVtub3JtYWxpemVkTmFtZV0gPSB2YWxbaV07XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGVsLnN0eWxlW25vcm1hbGl6ZWROYW1lXSA9IHZhbDtcbiAgICB9XG4gIH1cbn07XG5cbnZhciB2ZW5kb3JOYW1lcyA9IFsnV2Via2l0JywgJ01veicsICdtcyddO1xuXG52YXIgZW1wdHlTdHlsZTtcbnZhciBub3JtYWxpemUgPSBjYWNoZWQoZnVuY3Rpb24gKHByb3ApIHtcbiAgZW1wdHlTdHlsZSA9IGVtcHR5U3R5bGUgfHwgZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jykuc3R5bGU7XG4gIHByb3AgPSBjYW1lbGl6ZShwcm9wKTtcbiAgaWYgKHByb3AgIT09ICdmaWx0ZXInICYmIChwcm9wIGluIGVtcHR5U3R5bGUpKSB7XG4gICAgcmV0dXJuIHByb3BcbiAgfVxuICB2YXIgY2FwTmFtZSA9IHByb3AuY2hhckF0KDApLnRvVXBwZXJDYXNlKCkgKyBwcm9wLnNsaWNlKDEpO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHZlbmRvck5hbWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIG5hbWUgPSB2ZW5kb3JOYW1lc1tpXSArIGNhcE5hbWU7XG4gICAgaWYgKG5hbWUgaW4gZW1wdHlTdHlsZSkge1xuICAgICAgcmV0dXJuIG5hbWVcbiAgICB9XG4gIH1cbn0pO1xuXG5mdW5jdGlvbiB1cGRhdGVTdHlsZSAob2xkVm5vZGUsIHZub2RlKSB7XG4gIHZhciBkYXRhID0gdm5vZGUuZGF0YTtcbiAgdmFyIG9sZERhdGEgPSBvbGRWbm9kZS5kYXRhO1xuXG4gIGlmIChpc1VuZGVmKGRhdGEuc3RhdGljU3R5bGUpICYmIGlzVW5kZWYoZGF0YS5zdHlsZSkgJiZcbiAgICBpc1VuZGVmKG9sZERhdGEuc3RhdGljU3R5bGUpICYmIGlzVW5kZWYob2xkRGF0YS5zdHlsZSlcbiAgKSB7XG4gICAgcmV0dXJuXG4gIH1cblxuICB2YXIgY3VyLCBuYW1lO1xuICB2YXIgZWwgPSB2bm9kZS5lbG07XG4gIHZhciBvbGRTdGF0aWNTdHlsZSA9IG9sZERhdGEuc3RhdGljU3R5bGU7XG4gIHZhciBvbGRTdHlsZUJpbmRpbmcgPSBvbGREYXRhLm5vcm1hbGl6ZWRTdHlsZSB8fCBvbGREYXRhLnN0eWxlIHx8IHt9O1xuXG4gIC8vIGlmIHN0YXRpYyBzdHlsZSBleGlzdHMsIHN0eWxlYmluZGluZyBhbHJlYWR5IG1lcmdlZCBpbnRvIGl0IHdoZW4gZG9pbmcgbm9ybWFsaXplU3R5bGVEYXRhXG4gIHZhciBvbGRTdHlsZSA9IG9sZFN0YXRpY1N0eWxlIHx8IG9sZFN0eWxlQmluZGluZztcblxuICB2YXIgc3R5bGUgPSBub3JtYWxpemVTdHlsZUJpbmRpbmcodm5vZGUuZGF0YS5zdHlsZSkgfHwge307XG5cbiAgLy8gc3RvcmUgbm9ybWFsaXplZCBzdHlsZSB1bmRlciBhIGRpZmZlcmVudCBrZXkgZm9yIG5leHQgZGlmZlxuICAvLyBtYWtlIHN1cmUgdG8gY2xvbmUgaXQgaWYgaXQncyByZWFjdGl2ZSwgc2luY2UgdGhlIHVzZXIgbGlrZWx5IHdhbnRzXG4gIC8vIHRvIG11dGF0ZSBpdC5cbiAgdm5vZGUuZGF0YS5ub3JtYWxpemVkU3R5bGUgPSBpc0RlZihzdHlsZS5fX29iX18pXG4gICAgPyBleHRlbmQoe30sIHN0eWxlKVxuICAgIDogc3R5bGU7XG5cbiAgdmFyIG5ld1N0eWxlID0gZ2V0U3R5bGUodm5vZGUsIHRydWUpO1xuXG4gIGZvciAobmFtZSBpbiBvbGRTdHlsZSkge1xuICAgIGlmIChpc1VuZGVmKG5ld1N0eWxlW25hbWVdKSkge1xuICAgICAgc2V0UHJvcChlbCwgbmFtZSwgJycpO1xuICAgIH1cbiAgfVxuICBmb3IgKG5hbWUgaW4gbmV3U3R5bGUpIHtcbiAgICBjdXIgPSBuZXdTdHlsZVtuYW1lXTtcbiAgICBpZiAoY3VyICE9PSBvbGRTdHlsZVtuYW1lXSkge1xuICAgICAgLy8gaWU5IHNldHRpbmcgdG8gbnVsbCBoYXMgbm8gZWZmZWN0LCBtdXN0IHVzZSBlbXB0eSBzdHJpbmdcbiAgICAgIHNldFByb3AoZWwsIG5hbWUsIGN1ciA9PSBudWxsID8gJycgOiBjdXIpO1xuICAgIH1cbiAgfVxufVxuXG52YXIgc3R5bGUgPSB7XG4gIGNyZWF0ZTogdXBkYXRlU3R5bGUsXG4gIHVwZGF0ZTogdXBkYXRlU3R5bGVcbn07XG5cbi8qICAqL1xuXG52YXIgd2hpdGVzcGFjZVJFID0gL1xccysvO1xuXG4vKipcbiAqIEFkZCBjbGFzcyB3aXRoIGNvbXBhdGliaWxpdHkgZm9yIFNWRyBzaW5jZSBjbGFzc0xpc3QgaXMgbm90IHN1cHBvcnRlZCBvblxuICogU1ZHIGVsZW1lbnRzIGluIElFXG4gKi9cbmZ1bmN0aW9uIGFkZENsYXNzIChlbCwgY2xzKSB7XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICBpZiAoIWNscyB8fCAhKGNscyA9IGNscy50cmltKCkpKSB7XG4gICAgcmV0dXJuXG4gIH1cblxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICBpZiAoZWwuY2xhc3NMaXN0KSB7XG4gICAgaWYgKGNscy5pbmRleE9mKCcgJykgPiAtMSkge1xuICAgICAgY2xzLnNwbGl0KHdoaXRlc3BhY2VSRSkuZm9yRWFjaChmdW5jdGlvbiAoYykgeyByZXR1cm4gZWwuY2xhc3NMaXN0LmFkZChjKTsgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGVsLmNsYXNzTGlzdC5hZGQoY2xzKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgdmFyIGN1ciA9IFwiIFwiICsgKGVsLmdldEF0dHJpYnV0ZSgnY2xhc3MnKSB8fCAnJykgKyBcIiBcIjtcbiAgICBpZiAoY3VyLmluZGV4T2YoJyAnICsgY2xzICsgJyAnKSA8IDApIHtcbiAgICAgIGVsLnNldEF0dHJpYnV0ZSgnY2xhc3MnLCAoY3VyICsgY2xzKS50cmltKCkpO1xuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIFJlbW92ZSBjbGFzcyB3aXRoIGNvbXBhdGliaWxpdHkgZm9yIFNWRyBzaW5jZSBjbGFzc0xpc3QgaXMgbm90IHN1cHBvcnRlZCBvblxuICogU1ZHIGVsZW1lbnRzIGluIElFXG4gKi9cbmZ1bmN0aW9uIHJlbW92ZUNsYXNzIChlbCwgY2xzKSB7XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICBpZiAoIWNscyB8fCAhKGNscyA9IGNscy50cmltKCkpKSB7XG4gICAgcmV0dXJuXG4gIH1cblxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICBpZiAoZWwuY2xhc3NMaXN0KSB7XG4gICAgaWYgKGNscy5pbmRleE9mKCcgJykgPiAtMSkge1xuICAgICAgY2xzLnNwbGl0KHdoaXRlc3BhY2VSRSkuZm9yRWFjaChmdW5jdGlvbiAoYykgeyByZXR1cm4gZWwuY2xhc3NMaXN0LnJlbW92ZShjKTsgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGVsLmNsYXNzTGlzdC5yZW1vdmUoY2xzKTtcbiAgICB9XG4gICAgaWYgKCFlbC5jbGFzc0xpc3QubGVuZ3RoKSB7XG4gICAgICBlbC5yZW1vdmVBdHRyaWJ1dGUoJ2NsYXNzJyk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHZhciBjdXIgPSBcIiBcIiArIChlbC5nZXRBdHRyaWJ1dGUoJ2NsYXNzJykgfHwgJycpICsgXCIgXCI7XG4gICAgdmFyIHRhciA9ICcgJyArIGNscyArICcgJztcbiAgICB3aGlsZSAoY3VyLmluZGV4T2YodGFyKSA+PSAwKSB7XG4gICAgICBjdXIgPSBjdXIucmVwbGFjZSh0YXIsICcgJyk7XG4gICAgfVxuICAgIGN1ciA9IGN1ci50cmltKCk7XG4gICAgaWYgKGN1cikge1xuICAgICAgZWwuc2V0QXR0cmlidXRlKCdjbGFzcycsIGN1cik7XG4gICAgfSBlbHNlIHtcbiAgICAgIGVsLnJlbW92ZUF0dHJpYnV0ZSgnY2xhc3MnKTtcbiAgICB9XG4gIH1cbn1cblxuLyogICovXG5cbmZ1bmN0aW9uIHJlc29sdmVUcmFuc2l0aW9uIChkZWYkJDEpIHtcbiAgaWYgKCFkZWYkJDEpIHtcbiAgICByZXR1cm5cbiAgfVxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICBpZiAodHlwZW9mIGRlZiQkMSA9PT0gJ29iamVjdCcpIHtcbiAgICB2YXIgcmVzID0ge307XG4gICAgaWYgKGRlZiQkMS5jc3MgIT09IGZhbHNlKSB7XG4gICAgICBleHRlbmQocmVzLCBhdXRvQ3NzVHJhbnNpdGlvbihkZWYkJDEubmFtZSB8fCAndicpKTtcbiAgICB9XG4gICAgZXh0ZW5kKHJlcywgZGVmJCQxKTtcbiAgICByZXR1cm4gcmVzXG4gIH0gZWxzZSBpZiAodHlwZW9mIGRlZiQkMSA9PT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gYXV0b0Nzc1RyYW5zaXRpb24oZGVmJCQxKVxuICB9XG59XG5cbnZhciBhdXRvQ3NzVHJhbnNpdGlvbiA9IGNhY2hlZChmdW5jdGlvbiAobmFtZSkge1xuICByZXR1cm4ge1xuICAgIGVudGVyQ2xhc3M6IChuYW1lICsgXCItZW50ZXJcIiksXG4gICAgZW50ZXJUb0NsYXNzOiAobmFtZSArIFwiLWVudGVyLXRvXCIpLFxuICAgIGVudGVyQWN0aXZlQ2xhc3M6IChuYW1lICsgXCItZW50ZXItYWN0aXZlXCIpLFxuICAgIGxlYXZlQ2xhc3M6IChuYW1lICsgXCItbGVhdmVcIiksXG4gICAgbGVhdmVUb0NsYXNzOiAobmFtZSArIFwiLWxlYXZlLXRvXCIpLFxuICAgIGxlYXZlQWN0aXZlQ2xhc3M6IChuYW1lICsgXCItbGVhdmUtYWN0aXZlXCIpXG4gIH1cbn0pO1xuXG52YXIgaGFzVHJhbnNpdGlvbiA9IGluQnJvd3NlciAmJiAhaXNJRTk7XG52YXIgVFJBTlNJVElPTiA9ICd0cmFuc2l0aW9uJztcbnZhciBBTklNQVRJT04gPSAnYW5pbWF0aW9uJztcblxuLy8gVHJhbnNpdGlvbiBwcm9wZXJ0eS9ldmVudCBzbmlmZmluZ1xudmFyIHRyYW5zaXRpb25Qcm9wID0gJ3RyYW5zaXRpb24nO1xudmFyIHRyYW5zaXRpb25FbmRFdmVudCA9ICd0cmFuc2l0aW9uZW5kJztcbnZhciBhbmltYXRpb25Qcm9wID0gJ2FuaW1hdGlvbic7XG52YXIgYW5pbWF0aW9uRW5kRXZlbnQgPSAnYW5pbWF0aW9uZW5kJztcbmlmIChoYXNUcmFuc2l0aW9uKSB7XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICBpZiAod2luZG93Lm9udHJhbnNpdGlvbmVuZCA9PT0gdW5kZWZpbmVkICYmXG4gICAgd2luZG93Lm9ud2Via2l0dHJhbnNpdGlvbmVuZCAhPT0gdW5kZWZpbmVkXG4gICkge1xuICAgIHRyYW5zaXRpb25Qcm9wID0gJ1dlYmtpdFRyYW5zaXRpb24nO1xuICAgIHRyYW5zaXRpb25FbmRFdmVudCA9ICd3ZWJraXRUcmFuc2l0aW9uRW5kJztcbiAgfVxuICBpZiAod2luZG93Lm9uYW5pbWF0aW9uZW5kID09PSB1bmRlZmluZWQgJiZcbiAgICB3aW5kb3cub253ZWJraXRhbmltYXRpb25lbmQgIT09IHVuZGVmaW5lZFxuICApIHtcbiAgICBhbmltYXRpb25Qcm9wID0gJ1dlYmtpdEFuaW1hdGlvbic7XG4gICAgYW5pbWF0aW9uRW5kRXZlbnQgPSAnd2Via2l0QW5pbWF0aW9uRW5kJztcbiAgfVxufVxuXG4vLyBiaW5kaW5nIHRvIHdpbmRvdyBpcyBuZWNlc3NhcnkgdG8gbWFrZSBob3QgcmVsb2FkIHdvcmsgaW4gSUUgaW4gc3RyaWN0IG1vZGVcbnZhciByYWYgPSBpbkJyb3dzZXJcbiAgPyB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lXG4gICAgPyB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lLmJpbmQod2luZG93KVxuICAgIDogc2V0VGltZW91dFxuICA6IC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovIGZ1bmN0aW9uIChmbikgeyByZXR1cm4gZm4oKTsgfTtcblxuZnVuY3Rpb24gbmV4dEZyYW1lIChmbikge1xuICByYWYoZnVuY3Rpb24gKCkge1xuICAgIHJhZihmbik7XG4gIH0pO1xufVxuXG5mdW5jdGlvbiBhZGRUcmFuc2l0aW9uQ2xhc3MgKGVsLCBjbHMpIHtcbiAgdmFyIHRyYW5zaXRpb25DbGFzc2VzID0gZWwuX3RyYW5zaXRpb25DbGFzc2VzIHx8IChlbC5fdHJhbnNpdGlvbkNsYXNzZXMgPSBbXSk7XG4gIGlmICh0cmFuc2l0aW9uQ2xhc3Nlcy5pbmRleE9mKGNscykgPCAwKSB7XG4gICAgdHJhbnNpdGlvbkNsYXNzZXMucHVzaChjbHMpO1xuICAgIGFkZENsYXNzKGVsLCBjbHMpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHJlbW92ZVRyYW5zaXRpb25DbGFzcyAoZWwsIGNscykge1xuICBpZiAoZWwuX3RyYW5zaXRpb25DbGFzc2VzKSB7XG4gICAgcmVtb3ZlKGVsLl90cmFuc2l0aW9uQ2xhc3NlcywgY2xzKTtcbiAgfVxuICByZW1vdmVDbGFzcyhlbCwgY2xzKTtcbn1cblxuZnVuY3Rpb24gd2hlblRyYW5zaXRpb25FbmRzIChcbiAgZWwsXG4gIGV4cGVjdGVkVHlwZSxcbiAgY2Jcbikge1xuICB2YXIgcmVmID0gZ2V0VHJhbnNpdGlvbkluZm8oZWwsIGV4cGVjdGVkVHlwZSk7XG4gIHZhciB0eXBlID0gcmVmLnR5cGU7XG4gIHZhciB0aW1lb3V0ID0gcmVmLnRpbWVvdXQ7XG4gIHZhciBwcm9wQ291bnQgPSByZWYucHJvcENvdW50O1xuICBpZiAoIXR5cGUpIHsgcmV0dXJuIGNiKCkgfVxuICB2YXIgZXZlbnQgPSB0eXBlID09PSBUUkFOU0lUSU9OID8gdHJhbnNpdGlvbkVuZEV2ZW50IDogYW5pbWF0aW9uRW5kRXZlbnQ7XG4gIHZhciBlbmRlZCA9IDA7XG4gIHZhciBlbmQgPSBmdW5jdGlvbiAoKSB7XG4gICAgZWwucmVtb3ZlRXZlbnRMaXN0ZW5lcihldmVudCwgb25FbmQpO1xuICAgIGNiKCk7XG4gIH07XG4gIHZhciBvbkVuZCA9IGZ1bmN0aW9uIChlKSB7XG4gICAgaWYgKGUudGFyZ2V0ID09PSBlbCkge1xuICAgICAgaWYgKCsrZW5kZWQgPj0gcHJvcENvdW50KSB7XG4gICAgICAgIGVuZCgpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcbiAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgaWYgKGVuZGVkIDwgcHJvcENvdW50KSB7XG4gICAgICBlbmQoKTtcbiAgICB9XG4gIH0sIHRpbWVvdXQgKyAxKTtcbiAgZWwuYWRkRXZlbnRMaXN0ZW5lcihldmVudCwgb25FbmQpO1xufVxuXG52YXIgdHJhbnNmb3JtUkUgPSAvXFxiKHRyYW5zZm9ybXxhbGwpKCx8JCkvO1xuXG5mdW5jdGlvbiBnZXRUcmFuc2l0aW9uSW5mbyAoZWwsIGV4cGVjdGVkVHlwZSkge1xuICB2YXIgc3R5bGVzID0gd2luZG93LmdldENvbXB1dGVkU3R5bGUoZWwpO1xuICAvLyBKU0RPTSBtYXkgcmV0dXJuIHVuZGVmaW5lZCBmb3IgdHJhbnNpdGlvbiBwcm9wZXJ0aWVzXG4gIHZhciB0cmFuc2l0aW9uRGVsYXlzID0gKHN0eWxlc1t0cmFuc2l0aW9uUHJvcCArICdEZWxheSddIHx8ICcnKS5zcGxpdCgnLCAnKTtcbiAgdmFyIHRyYW5zaXRpb25EdXJhdGlvbnMgPSAoc3R5bGVzW3RyYW5zaXRpb25Qcm9wICsgJ0R1cmF0aW9uJ10gfHwgJycpLnNwbGl0KCcsICcpO1xuICB2YXIgdHJhbnNpdGlvblRpbWVvdXQgPSBnZXRUaW1lb3V0KHRyYW5zaXRpb25EZWxheXMsIHRyYW5zaXRpb25EdXJhdGlvbnMpO1xuICB2YXIgYW5pbWF0aW9uRGVsYXlzID0gKHN0eWxlc1thbmltYXRpb25Qcm9wICsgJ0RlbGF5J10gfHwgJycpLnNwbGl0KCcsICcpO1xuICB2YXIgYW5pbWF0aW9uRHVyYXRpb25zID0gKHN0eWxlc1thbmltYXRpb25Qcm9wICsgJ0R1cmF0aW9uJ10gfHwgJycpLnNwbGl0KCcsICcpO1xuICB2YXIgYW5pbWF0aW9uVGltZW91dCA9IGdldFRpbWVvdXQoYW5pbWF0aW9uRGVsYXlzLCBhbmltYXRpb25EdXJhdGlvbnMpO1xuXG4gIHZhciB0eXBlO1xuICB2YXIgdGltZW91dCA9IDA7XG4gIHZhciBwcm9wQ291bnQgPSAwO1xuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgaWYgKGV4cGVjdGVkVHlwZSA9PT0gVFJBTlNJVElPTikge1xuICAgIGlmICh0cmFuc2l0aW9uVGltZW91dCA+IDApIHtcbiAgICAgIHR5cGUgPSBUUkFOU0lUSU9OO1xuICAgICAgdGltZW91dCA9IHRyYW5zaXRpb25UaW1lb3V0O1xuICAgICAgcHJvcENvdW50ID0gdHJhbnNpdGlvbkR1cmF0aW9ucy5sZW5ndGg7XG4gICAgfVxuICB9IGVsc2UgaWYgKGV4cGVjdGVkVHlwZSA9PT0gQU5JTUFUSU9OKSB7XG4gICAgaWYgKGFuaW1hdGlvblRpbWVvdXQgPiAwKSB7XG4gICAgICB0eXBlID0gQU5JTUFUSU9OO1xuICAgICAgdGltZW91dCA9IGFuaW1hdGlvblRpbWVvdXQ7XG4gICAgICBwcm9wQ291bnQgPSBhbmltYXRpb25EdXJhdGlvbnMubGVuZ3RoO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB0aW1lb3V0ID0gTWF0aC5tYXgodHJhbnNpdGlvblRpbWVvdXQsIGFuaW1hdGlvblRpbWVvdXQpO1xuICAgIHR5cGUgPSB0aW1lb3V0ID4gMFxuICAgICAgPyB0cmFuc2l0aW9uVGltZW91dCA+IGFuaW1hdGlvblRpbWVvdXRcbiAgICAgICAgPyBUUkFOU0lUSU9OXG4gICAgICAgIDogQU5JTUFUSU9OXG4gICAgICA6IG51bGw7XG4gICAgcHJvcENvdW50ID0gdHlwZVxuICAgICAgPyB0eXBlID09PSBUUkFOU0lUSU9OXG4gICAgICAgID8gdHJhbnNpdGlvbkR1cmF0aW9ucy5sZW5ndGhcbiAgICAgICAgOiBhbmltYXRpb25EdXJhdGlvbnMubGVuZ3RoXG4gICAgICA6IDA7XG4gIH1cbiAgdmFyIGhhc1RyYW5zZm9ybSA9XG4gICAgdHlwZSA9PT0gVFJBTlNJVElPTiAmJlxuICAgIHRyYW5zZm9ybVJFLnRlc3Qoc3R5bGVzW3RyYW5zaXRpb25Qcm9wICsgJ1Byb3BlcnR5J10pO1xuICByZXR1cm4ge1xuICAgIHR5cGU6IHR5cGUsXG4gICAgdGltZW91dDogdGltZW91dCxcbiAgICBwcm9wQ291bnQ6IHByb3BDb3VudCxcbiAgICBoYXNUcmFuc2Zvcm06IGhhc1RyYW5zZm9ybVxuICB9XG59XG5cbmZ1bmN0aW9uIGdldFRpbWVvdXQgKGRlbGF5cywgZHVyYXRpb25zKSB7XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gIHdoaWxlIChkZWxheXMubGVuZ3RoIDwgZHVyYXRpb25zLmxlbmd0aCkge1xuICAgIGRlbGF5cyA9IGRlbGF5cy5jb25jYXQoZGVsYXlzKTtcbiAgfVxuXG4gIHJldHVybiBNYXRoLm1heC5hcHBseShudWxsLCBkdXJhdGlvbnMubWFwKGZ1bmN0aW9uIChkLCBpKSB7XG4gICAgcmV0dXJuIHRvTXMoZCkgKyB0b01zKGRlbGF5c1tpXSlcbiAgfSkpXG59XG5cbi8vIE9sZCB2ZXJzaW9ucyBvZiBDaHJvbWl1bSAoYmVsb3cgNjEuMC4zMTYzLjEwMCkgZm9ybWF0cyBmbG9hdGluZyBwb2ludGVyIG51bWJlcnNcbi8vIGluIGEgbG9jYWxlLWRlcGVuZGVudCB3YXksIHVzaW5nIGEgY29tbWEgaW5zdGVhZCBvZiBhIGRvdC5cbi8vIElmIGNvbW1hIGlzIG5vdCByZXBsYWNlZCB3aXRoIGEgZG90LCB0aGUgaW5wdXQgd2lsbCBiZSByb3VuZGVkIGRvd24gKGkuZS4gYWN0aW5nXG4vLyBhcyBhIGZsb29yIGZ1bmN0aW9uKSBjYXVzaW5nIHVuZXhwZWN0ZWQgYmVoYXZpb3JzXG5mdW5jdGlvbiB0b01zIChzKSB7XG4gIHJldHVybiBOdW1iZXIocy5zbGljZSgwLCAtMSkucmVwbGFjZSgnLCcsICcuJykpICogMTAwMFxufVxuXG4vKiAgKi9cblxuZnVuY3Rpb24gZW50ZXIgKHZub2RlLCB0b2dnbGVEaXNwbGF5KSB7XG4gIHZhciBlbCA9IHZub2RlLmVsbTtcblxuICAvLyBjYWxsIGxlYXZlIGNhbGxiYWNrIG5vd1xuICBpZiAoaXNEZWYoZWwuX2xlYXZlQ2IpKSB7XG4gICAgZWwuX2xlYXZlQ2IuY2FuY2VsbGVkID0gdHJ1ZTtcbiAgICBlbC5fbGVhdmVDYigpO1xuICB9XG5cbiAgdmFyIGRhdGEgPSByZXNvbHZlVHJhbnNpdGlvbih2bm9kZS5kYXRhLnRyYW5zaXRpb24pO1xuICBpZiAoaXNVbmRlZihkYXRhKSkge1xuICAgIHJldHVyblxuICB9XG5cbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gIGlmIChpc0RlZihlbC5fZW50ZXJDYikgfHwgZWwubm9kZVR5cGUgIT09IDEpIHtcbiAgICByZXR1cm5cbiAgfVxuXG4gIHZhciBjc3MgPSBkYXRhLmNzcztcbiAgdmFyIHR5cGUgPSBkYXRhLnR5cGU7XG4gIHZhciBlbnRlckNsYXNzID0gZGF0YS5lbnRlckNsYXNzO1xuICB2YXIgZW50ZXJUb0NsYXNzID0gZGF0YS5lbnRlclRvQ2xhc3M7XG4gIHZhciBlbnRlckFjdGl2ZUNsYXNzID0gZGF0YS5lbnRlckFjdGl2ZUNsYXNzO1xuICB2YXIgYXBwZWFyQ2xhc3MgPSBkYXRhLmFwcGVhckNsYXNzO1xuICB2YXIgYXBwZWFyVG9DbGFzcyA9IGRhdGEuYXBwZWFyVG9DbGFzcztcbiAgdmFyIGFwcGVhckFjdGl2ZUNsYXNzID0gZGF0YS5hcHBlYXJBY3RpdmVDbGFzcztcbiAgdmFyIGJlZm9yZUVudGVyID0gZGF0YS5iZWZvcmVFbnRlcjtcbiAgdmFyIGVudGVyID0gZGF0YS5lbnRlcjtcbiAgdmFyIGFmdGVyRW50ZXIgPSBkYXRhLmFmdGVyRW50ZXI7XG4gIHZhciBlbnRlckNhbmNlbGxlZCA9IGRhdGEuZW50ZXJDYW5jZWxsZWQ7XG4gIHZhciBiZWZvcmVBcHBlYXIgPSBkYXRhLmJlZm9yZUFwcGVhcjtcbiAgdmFyIGFwcGVhciA9IGRhdGEuYXBwZWFyO1xuICB2YXIgYWZ0ZXJBcHBlYXIgPSBkYXRhLmFmdGVyQXBwZWFyO1xuICB2YXIgYXBwZWFyQ2FuY2VsbGVkID0gZGF0YS5hcHBlYXJDYW5jZWxsZWQ7XG4gIHZhciBkdXJhdGlvbiA9IGRhdGEuZHVyYXRpb247XG5cbiAgLy8gYWN0aXZlSW5zdGFuY2Ugd2lsbCBhbHdheXMgYmUgdGhlIDx0cmFuc2l0aW9uPiBjb21wb25lbnQgbWFuYWdpbmcgdGhpc1xuICAvLyB0cmFuc2l0aW9uLiBPbmUgZWRnZSBjYXNlIHRvIGNoZWNrIGlzIHdoZW4gdGhlIDx0cmFuc2l0aW9uPiBpcyBwbGFjZWRcbiAgLy8gYXMgdGhlIHJvb3Qgbm9kZSBvZiBhIGNoaWxkIGNvbXBvbmVudC4gSW4gdGhhdCBjYXNlIHdlIG5lZWQgdG8gY2hlY2tcbiAgLy8gPHRyYW5zaXRpb24+J3MgcGFyZW50IGZvciBhcHBlYXIgY2hlY2suXG4gIHZhciBjb250ZXh0ID0gYWN0aXZlSW5zdGFuY2U7XG4gIHZhciB0cmFuc2l0aW9uTm9kZSA9IGFjdGl2ZUluc3RhbmNlLiR2bm9kZTtcbiAgd2hpbGUgKHRyYW5zaXRpb25Ob2RlICYmIHRyYW5zaXRpb25Ob2RlLnBhcmVudCkge1xuICAgIGNvbnRleHQgPSB0cmFuc2l0aW9uTm9kZS5jb250ZXh0O1xuICAgIHRyYW5zaXRpb25Ob2RlID0gdHJhbnNpdGlvbk5vZGUucGFyZW50O1xuICB9XG5cbiAgdmFyIGlzQXBwZWFyID0gIWNvbnRleHQuX2lzTW91bnRlZCB8fCAhdm5vZGUuaXNSb290SW5zZXJ0O1xuXG4gIGlmIChpc0FwcGVhciAmJiAhYXBwZWFyICYmIGFwcGVhciAhPT0gJycpIHtcbiAgICByZXR1cm5cbiAgfVxuXG4gIHZhciBzdGFydENsYXNzID0gaXNBcHBlYXIgJiYgYXBwZWFyQ2xhc3NcbiAgICA/IGFwcGVhckNsYXNzXG4gICAgOiBlbnRlckNsYXNzO1xuICB2YXIgYWN0aXZlQ2xhc3MgPSBpc0FwcGVhciAmJiBhcHBlYXJBY3RpdmVDbGFzc1xuICAgID8gYXBwZWFyQWN0aXZlQ2xhc3NcbiAgICA6IGVudGVyQWN0aXZlQ2xhc3M7XG4gIHZhciB0b0NsYXNzID0gaXNBcHBlYXIgJiYgYXBwZWFyVG9DbGFzc1xuICAgID8gYXBwZWFyVG9DbGFzc1xuICAgIDogZW50ZXJUb0NsYXNzO1xuXG4gIHZhciBiZWZvcmVFbnRlckhvb2sgPSBpc0FwcGVhclxuICAgID8gKGJlZm9yZUFwcGVhciB8fCBiZWZvcmVFbnRlcilcbiAgICA6IGJlZm9yZUVudGVyO1xuICB2YXIgZW50ZXJIb29rID0gaXNBcHBlYXJcbiAgICA/ICh0eXBlb2YgYXBwZWFyID09PSAnZnVuY3Rpb24nID8gYXBwZWFyIDogZW50ZXIpXG4gICAgOiBlbnRlcjtcbiAgdmFyIGFmdGVyRW50ZXJIb29rID0gaXNBcHBlYXJcbiAgICA/IChhZnRlckFwcGVhciB8fCBhZnRlckVudGVyKVxuICAgIDogYWZ0ZXJFbnRlcjtcbiAgdmFyIGVudGVyQ2FuY2VsbGVkSG9vayA9IGlzQXBwZWFyXG4gICAgPyAoYXBwZWFyQ2FuY2VsbGVkIHx8IGVudGVyQ2FuY2VsbGVkKVxuICAgIDogZW50ZXJDYW5jZWxsZWQ7XG5cbiAgdmFyIGV4cGxpY2l0RW50ZXJEdXJhdGlvbiA9IHRvTnVtYmVyKFxuICAgIGlzT2JqZWN0KGR1cmF0aW9uKVxuICAgICAgPyBkdXJhdGlvbi5lbnRlclxuICAgICAgOiBkdXJhdGlvblxuICApO1xuXG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIGV4cGxpY2l0RW50ZXJEdXJhdGlvbiAhPSBudWxsKSB7XG4gICAgY2hlY2tEdXJhdGlvbihleHBsaWNpdEVudGVyRHVyYXRpb24sICdlbnRlcicsIHZub2RlKTtcbiAgfVxuXG4gIHZhciBleHBlY3RzQ1NTID0gY3NzICE9PSBmYWxzZSAmJiAhaXNJRTk7XG4gIHZhciB1c2VyV2FudHNDb250cm9sID0gZ2V0SG9va0FyZ3VtZW50c0xlbmd0aChlbnRlckhvb2spO1xuXG4gIHZhciBjYiA9IGVsLl9lbnRlckNiID0gb25jZShmdW5jdGlvbiAoKSB7XG4gICAgaWYgKGV4cGVjdHNDU1MpIHtcbiAgICAgIHJlbW92ZVRyYW5zaXRpb25DbGFzcyhlbCwgdG9DbGFzcyk7XG4gICAgICByZW1vdmVUcmFuc2l0aW9uQ2xhc3MoZWwsIGFjdGl2ZUNsYXNzKTtcbiAgICB9XG4gICAgaWYgKGNiLmNhbmNlbGxlZCkge1xuICAgICAgaWYgKGV4cGVjdHNDU1MpIHtcbiAgICAgICAgcmVtb3ZlVHJhbnNpdGlvbkNsYXNzKGVsLCBzdGFydENsYXNzKTtcbiAgICAgIH1cbiAgICAgIGVudGVyQ2FuY2VsbGVkSG9vayAmJiBlbnRlckNhbmNlbGxlZEhvb2soZWwpO1xuICAgIH0gZWxzZSB7XG4gICAgICBhZnRlckVudGVySG9vayAmJiBhZnRlckVudGVySG9vayhlbCk7XG4gICAgfVxuICAgIGVsLl9lbnRlckNiID0gbnVsbDtcbiAgfSk7XG5cbiAgaWYgKCF2bm9kZS5kYXRhLnNob3cpIHtcbiAgICAvLyByZW1vdmUgcGVuZGluZyBsZWF2ZSBlbGVtZW50IG9uIGVudGVyIGJ5IGluamVjdGluZyBhbiBpbnNlcnQgaG9va1xuICAgIG1lcmdlVk5vZGVIb29rKHZub2RlLCAnaW5zZXJ0JywgZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIHBhcmVudCA9IGVsLnBhcmVudE5vZGU7XG4gICAgICB2YXIgcGVuZGluZ05vZGUgPSBwYXJlbnQgJiYgcGFyZW50Ll9wZW5kaW5nICYmIHBhcmVudC5fcGVuZGluZ1t2bm9kZS5rZXldO1xuICAgICAgaWYgKHBlbmRpbmdOb2RlICYmXG4gICAgICAgIHBlbmRpbmdOb2RlLnRhZyA9PT0gdm5vZGUudGFnICYmXG4gICAgICAgIHBlbmRpbmdOb2RlLmVsbS5fbGVhdmVDYlxuICAgICAgKSB7XG4gICAgICAgIHBlbmRpbmdOb2RlLmVsbS5fbGVhdmVDYigpO1xuICAgICAgfVxuICAgICAgZW50ZXJIb29rICYmIGVudGVySG9vayhlbCwgY2IpO1xuICAgIH0pO1xuICB9XG5cbiAgLy8gc3RhcnQgZW50ZXIgdHJhbnNpdGlvblxuICBiZWZvcmVFbnRlckhvb2sgJiYgYmVmb3JlRW50ZXJIb29rKGVsKTtcbiAgaWYgKGV4cGVjdHNDU1MpIHtcbiAgICBhZGRUcmFuc2l0aW9uQ2xhc3MoZWwsIHN0YXJ0Q2xhc3MpO1xuICAgIGFkZFRyYW5zaXRpb25DbGFzcyhlbCwgYWN0aXZlQ2xhc3MpO1xuICAgIG5leHRGcmFtZShmdW5jdGlvbiAoKSB7XG4gICAgICByZW1vdmVUcmFuc2l0aW9uQ2xhc3MoZWwsIHN0YXJ0Q2xhc3MpO1xuICAgICAgaWYgKCFjYi5jYW5jZWxsZWQpIHtcbiAgICAgICAgYWRkVHJhbnNpdGlvbkNsYXNzKGVsLCB0b0NsYXNzKTtcbiAgICAgICAgaWYgKCF1c2VyV2FudHNDb250cm9sKSB7XG4gICAgICAgICAgaWYgKGlzVmFsaWREdXJhdGlvbihleHBsaWNpdEVudGVyRHVyYXRpb24pKSB7XG4gICAgICAgICAgICBzZXRUaW1lb3V0KGNiLCBleHBsaWNpdEVudGVyRHVyYXRpb24pO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB3aGVuVHJhbnNpdGlvbkVuZHMoZWwsIHR5cGUsIGNiKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIGlmICh2bm9kZS5kYXRhLnNob3cpIHtcbiAgICB0b2dnbGVEaXNwbGF5ICYmIHRvZ2dsZURpc3BsYXkoKTtcbiAgICBlbnRlckhvb2sgJiYgZW50ZXJIb29rKGVsLCBjYik7XG4gIH1cblxuICBpZiAoIWV4cGVjdHNDU1MgJiYgIXVzZXJXYW50c0NvbnRyb2wpIHtcbiAgICBjYigpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGxlYXZlICh2bm9kZSwgcm0pIHtcbiAgdmFyIGVsID0gdm5vZGUuZWxtO1xuXG4gIC8vIGNhbGwgZW50ZXIgY2FsbGJhY2sgbm93XG4gIGlmIChpc0RlZihlbC5fZW50ZXJDYikpIHtcbiAgICBlbC5fZW50ZXJDYi5jYW5jZWxsZWQgPSB0cnVlO1xuICAgIGVsLl9lbnRlckNiKCk7XG4gIH1cblxuICB2YXIgZGF0YSA9IHJlc29sdmVUcmFuc2l0aW9uKHZub2RlLmRhdGEudHJhbnNpdGlvbik7XG4gIGlmIChpc1VuZGVmKGRhdGEpIHx8IGVsLm5vZGVUeXBlICE9PSAxKSB7XG4gICAgcmV0dXJuIHJtKClcbiAgfVxuXG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICBpZiAoaXNEZWYoZWwuX2xlYXZlQ2IpKSB7XG4gICAgcmV0dXJuXG4gIH1cblxuICB2YXIgY3NzID0gZGF0YS5jc3M7XG4gIHZhciB0eXBlID0gZGF0YS50eXBlO1xuICB2YXIgbGVhdmVDbGFzcyA9IGRhdGEubGVhdmVDbGFzcztcbiAgdmFyIGxlYXZlVG9DbGFzcyA9IGRhdGEubGVhdmVUb0NsYXNzO1xuICB2YXIgbGVhdmVBY3RpdmVDbGFzcyA9IGRhdGEubGVhdmVBY3RpdmVDbGFzcztcbiAgdmFyIGJlZm9yZUxlYXZlID0gZGF0YS5iZWZvcmVMZWF2ZTtcbiAgdmFyIGxlYXZlID0gZGF0YS5sZWF2ZTtcbiAgdmFyIGFmdGVyTGVhdmUgPSBkYXRhLmFmdGVyTGVhdmU7XG4gIHZhciBsZWF2ZUNhbmNlbGxlZCA9IGRhdGEubGVhdmVDYW5jZWxsZWQ7XG4gIHZhciBkZWxheUxlYXZlID0gZGF0YS5kZWxheUxlYXZlO1xuICB2YXIgZHVyYXRpb24gPSBkYXRhLmR1cmF0aW9uO1xuXG4gIHZhciBleHBlY3RzQ1NTID0gY3NzICE9PSBmYWxzZSAmJiAhaXNJRTk7XG4gIHZhciB1c2VyV2FudHNDb250cm9sID0gZ2V0SG9va0FyZ3VtZW50c0xlbmd0aChsZWF2ZSk7XG5cbiAgdmFyIGV4cGxpY2l0TGVhdmVEdXJhdGlvbiA9IHRvTnVtYmVyKFxuICAgIGlzT2JqZWN0KGR1cmF0aW9uKVxuICAgICAgPyBkdXJhdGlvbi5sZWF2ZVxuICAgICAgOiBkdXJhdGlvblxuICApO1xuXG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIGlzRGVmKGV4cGxpY2l0TGVhdmVEdXJhdGlvbikpIHtcbiAgICBjaGVja0R1cmF0aW9uKGV4cGxpY2l0TGVhdmVEdXJhdGlvbiwgJ2xlYXZlJywgdm5vZGUpO1xuICB9XG5cbiAgdmFyIGNiID0gZWwuX2xlYXZlQ2IgPSBvbmNlKGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoZWwucGFyZW50Tm9kZSAmJiBlbC5wYXJlbnROb2RlLl9wZW5kaW5nKSB7XG4gICAgICBlbC5wYXJlbnROb2RlLl9wZW5kaW5nW3Zub2RlLmtleV0gPSBudWxsO1xuICAgIH1cbiAgICBpZiAoZXhwZWN0c0NTUykge1xuICAgICAgcmVtb3ZlVHJhbnNpdGlvbkNsYXNzKGVsLCBsZWF2ZVRvQ2xhc3MpO1xuICAgICAgcmVtb3ZlVHJhbnNpdGlvbkNsYXNzKGVsLCBsZWF2ZUFjdGl2ZUNsYXNzKTtcbiAgICB9XG4gICAgaWYgKGNiLmNhbmNlbGxlZCkge1xuICAgICAgaWYgKGV4cGVjdHNDU1MpIHtcbiAgICAgICAgcmVtb3ZlVHJhbnNpdGlvbkNsYXNzKGVsLCBsZWF2ZUNsYXNzKTtcbiAgICAgIH1cbiAgICAgIGxlYXZlQ2FuY2VsbGVkICYmIGxlYXZlQ2FuY2VsbGVkKGVsKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcm0oKTtcbiAgICAgIGFmdGVyTGVhdmUgJiYgYWZ0ZXJMZWF2ZShlbCk7XG4gICAgfVxuICAgIGVsLl9sZWF2ZUNiID0gbnVsbDtcbiAgfSk7XG5cbiAgaWYgKGRlbGF5TGVhdmUpIHtcbiAgICBkZWxheUxlYXZlKHBlcmZvcm1MZWF2ZSk7XG4gIH0gZWxzZSB7XG4gICAgcGVyZm9ybUxlYXZlKCk7XG4gIH1cblxuICBmdW5jdGlvbiBwZXJmb3JtTGVhdmUgKCkge1xuICAgIC8vIHRoZSBkZWxheWVkIGxlYXZlIG1heSBoYXZlIGFscmVhZHkgYmVlbiBjYW5jZWxsZWRcbiAgICBpZiAoY2IuY2FuY2VsbGVkKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG4gICAgLy8gcmVjb3JkIGxlYXZpbmcgZWxlbWVudFxuICAgIGlmICghdm5vZGUuZGF0YS5zaG93ICYmIGVsLnBhcmVudE5vZGUpIHtcbiAgICAgIChlbC5wYXJlbnROb2RlLl9wZW5kaW5nIHx8IChlbC5wYXJlbnROb2RlLl9wZW5kaW5nID0ge30pKVsodm5vZGUua2V5KV0gPSB2bm9kZTtcbiAgICB9XG4gICAgYmVmb3JlTGVhdmUgJiYgYmVmb3JlTGVhdmUoZWwpO1xuICAgIGlmIChleHBlY3RzQ1NTKSB7XG4gICAgICBhZGRUcmFuc2l0aW9uQ2xhc3MoZWwsIGxlYXZlQ2xhc3MpO1xuICAgICAgYWRkVHJhbnNpdGlvbkNsYXNzKGVsLCBsZWF2ZUFjdGl2ZUNsYXNzKTtcbiAgICAgIG5leHRGcmFtZShmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJlbW92ZVRyYW5zaXRpb25DbGFzcyhlbCwgbGVhdmVDbGFzcyk7XG4gICAgICAgIGlmICghY2IuY2FuY2VsbGVkKSB7XG4gICAgICAgICAgYWRkVHJhbnNpdGlvbkNsYXNzKGVsLCBsZWF2ZVRvQ2xhc3MpO1xuICAgICAgICAgIGlmICghdXNlcldhbnRzQ29udHJvbCkge1xuICAgICAgICAgICAgaWYgKGlzVmFsaWREdXJhdGlvbihleHBsaWNpdExlYXZlRHVyYXRpb24pKSB7XG4gICAgICAgICAgICAgIHNldFRpbWVvdXQoY2IsIGV4cGxpY2l0TGVhdmVEdXJhdGlvbik7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICB3aGVuVHJhbnNpdGlvbkVuZHMoZWwsIHR5cGUsIGNiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgICBsZWF2ZSAmJiBsZWF2ZShlbCwgY2IpO1xuICAgIGlmICghZXhwZWN0c0NTUyAmJiAhdXNlcldhbnRzQ29udHJvbCkge1xuICAgICAgY2IoKTtcbiAgICB9XG4gIH1cbn1cblxuLy8gb25seSB1c2VkIGluIGRldiBtb2RlXG5mdW5jdGlvbiBjaGVja0R1cmF0aW9uICh2YWwsIG5hbWUsIHZub2RlKSB7XG4gIGlmICh0eXBlb2YgdmFsICE9PSAnbnVtYmVyJykge1xuICAgIHdhcm4oXG4gICAgICBcIjx0cmFuc2l0aW9uPiBleHBsaWNpdCBcIiArIG5hbWUgKyBcIiBkdXJhdGlvbiBpcyBub3QgYSB2YWxpZCBudW1iZXIgLSBcIiArXG4gICAgICBcImdvdCBcIiArIChKU09OLnN0cmluZ2lmeSh2YWwpKSArIFwiLlwiLFxuICAgICAgdm5vZGUuY29udGV4dFxuICAgICk7XG4gIH0gZWxzZSBpZiAoaXNOYU4odmFsKSkge1xuICAgIHdhcm4oXG4gICAgICBcIjx0cmFuc2l0aW9uPiBleHBsaWNpdCBcIiArIG5hbWUgKyBcIiBkdXJhdGlvbiBpcyBOYU4gLSBcIiArXG4gICAgICAndGhlIGR1cmF0aW9uIGV4cHJlc3Npb24gbWlnaHQgYmUgaW5jb3JyZWN0LicsXG4gICAgICB2bm9kZS5jb250ZXh0XG4gICAgKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBpc1ZhbGlkRHVyYXRpb24gKHZhbCkge1xuICByZXR1cm4gdHlwZW9mIHZhbCA9PT0gJ251bWJlcicgJiYgIWlzTmFOKHZhbClcbn1cblxuLyoqXG4gKiBOb3JtYWxpemUgYSB0cmFuc2l0aW9uIGhvb2sncyBhcmd1bWVudCBsZW5ndGguIFRoZSBob29rIG1heSBiZTpcbiAqIC0gYSBtZXJnZWQgaG9vayAoaW52b2tlcikgd2l0aCB0aGUgb3JpZ2luYWwgaW4gLmZuc1xuICogLSBhIHdyYXBwZWQgY29tcG9uZW50IG1ldGhvZCAoY2hlY2sgLl9sZW5ndGgpXG4gKiAtIGEgcGxhaW4gZnVuY3Rpb24gKC5sZW5ndGgpXG4gKi9cbmZ1bmN0aW9uIGdldEhvb2tBcmd1bWVudHNMZW5ndGggKGZuKSB7XG4gIGlmIChpc1VuZGVmKGZuKSkge1xuICAgIHJldHVybiBmYWxzZVxuICB9XG4gIHZhciBpbnZva2VyRm5zID0gZm4uZm5zO1xuICBpZiAoaXNEZWYoaW52b2tlckZucykpIHtcbiAgICAvLyBpbnZva2VyXG4gICAgcmV0dXJuIGdldEhvb2tBcmd1bWVudHNMZW5ndGgoXG4gICAgICBBcnJheS5pc0FycmF5KGludm9rZXJGbnMpXG4gICAgICAgID8gaW52b2tlckZuc1swXVxuICAgICAgICA6IGludm9rZXJGbnNcbiAgICApXG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIChmbi5fbGVuZ3RoIHx8IGZuLmxlbmd0aCkgPiAxXG4gIH1cbn1cblxuZnVuY3Rpb24gX2VudGVyIChfLCB2bm9kZSkge1xuICBpZiAodm5vZGUuZGF0YS5zaG93ICE9PSB0cnVlKSB7XG4gICAgZW50ZXIodm5vZGUpO1xuICB9XG59XG5cbnZhciB0cmFuc2l0aW9uID0gaW5Ccm93c2VyID8ge1xuICBjcmVhdGU6IF9lbnRlcixcbiAgYWN0aXZhdGU6IF9lbnRlcixcbiAgcmVtb3ZlOiBmdW5jdGlvbiByZW1vdmUkJDEgKHZub2RlLCBybSkge1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG4gICAgaWYgKHZub2RlLmRhdGEuc2hvdyAhPT0gdHJ1ZSkge1xuICAgICAgbGVhdmUodm5vZGUsIHJtKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcm0oKTtcbiAgICB9XG4gIH1cbn0gOiB7fTtcblxudmFyIHBsYXRmb3JtTW9kdWxlcyA9IFtcbiAgYXR0cnMsXG4gIGtsYXNzLFxuICBldmVudHMsXG4gIGRvbVByb3BzLFxuICBzdHlsZSxcbiAgdHJhbnNpdGlvblxuXTtcblxuLyogICovXG5cbi8vIHRoZSBkaXJlY3RpdmUgbW9kdWxlIHNob3VsZCBiZSBhcHBsaWVkIGxhc3QsIGFmdGVyIGFsbFxuLy8gYnVpbHQtaW4gbW9kdWxlcyBoYXZlIGJlZW4gYXBwbGllZC5cbnZhciBtb2R1bGVzID0gcGxhdGZvcm1Nb2R1bGVzLmNvbmNhdChiYXNlTW9kdWxlcyk7XG5cbnZhciBwYXRjaCA9IGNyZWF0ZVBhdGNoRnVuY3Rpb24oeyBub2RlT3BzOiBub2RlT3BzLCBtb2R1bGVzOiBtb2R1bGVzIH0pO1xuXG4vKipcbiAqIE5vdCB0eXBlIGNoZWNraW5nIHRoaXMgZmlsZSBiZWNhdXNlIGZsb3cgZG9lc24ndCBsaWtlIGF0dGFjaGluZ1xuICogcHJvcGVydGllcyB0byBFbGVtZW50cy5cbiAqL1xuXG4vKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbmlmIChpc0lFOSkge1xuICAvLyBodHRwOi8vd3d3Lm1hdHRzNDExLmNvbS9wb3N0L2ludGVybmV0LWV4cGxvcmVyLTktb25pbnB1dC9cbiAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignc2VsZWN0aW9uY2hhbmdlJywgZnVuY3Rpb24gKCkge1xuICAgIHZhciBlbCA9IGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQ7XG4gICAgaWYgKGVsICYmIGVsLnZtb2RlbCkge1xuICAgICAgdHJpZ2dlcihlbCwgJ2lucHV0Jyk7XG4gICAgfVxuICB9KTtcbn1cblxudmFyIGRpcmVjdGl2ZSA9IHtcbiAgaW5zZXJ0ZWQ6IGZ1bmN0aW9uIGluc2VydGVkIChlbCwgYmluZGluZywgdm5vZGUsIG9sZFZub2RlKSB7XG4gICAgaWYgKHZub2RlLnRhZyA9PT0gJ3NlbGVjdCcpIHtcbiAgICAgIC8vICM2OTAzXG4gICAgICBpZiAob2xkVm5vZGUuZWxtICYmICFvbGRWbm9kZS5lbG0uX3ZPcHRpb25zKSB7XG4gICAgICAgIG1lcmdlVk5vZGVIb29rKHZub2RlLCAncG9zdHBhdGNoJywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgIGRpcmVjdGl2ZS5jb21wb25lbnRVcGRhdGVkKGVsLCBiaW5kaW5nLCB2bm9kZSk7XG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc2V0U2VsZWN0ZWQoZWwsIGJpbmRpbmcsIHZub2RlLmNvbnRleHQpO1xuICAgICAgfVxuICAgICAgZWwuX3ZPcHRpb25zID0gW10ubWFwLmNhbGwoZWwub3B0aW9ucywgZ2V0VmFsdWUpO1xuICAgIH0gZWxzZSBpZiAodm5vZGUudGFnID09PSAndGV4dGFyZWEnIHx8IGlzVGV4dElucHV0VHlwZShlbC50eXBlKSkge1xuICAgICAgZWwuX3ZNb2RpZmllcnMgPSBiaW5kaW5nLm1vZGlmaWVycztcbiAgICAgIGlmICghYmluZGluZy5tb2RpZmllcnMubGF6eSkge1xuICAgICAgICBlbC5hZGRFdmVudExpc3RlbmVyKCdjb21wb3NpdGlvbnN0YXJ0Jywgb25Db21wb3NpdGlvblN0YXJ0KTtcbiAgICAgICAgZWwuYWRkRXZlbnRMaXN0ZW5lcignY29tcG9zaXRpb25lbmQnLCBvbkNvbXBvc2l0aW9uRW5kKTtcbiAgICAgICAgLy8gU2FmYXJpIDwgMTAuMiAmIFVJV2ViVmlldyBkb2Vzbid0IGZpcmUgY29tcG9zaXRpb25lbmQgd2hlblxuICAgICAgICAvLyBzd2l0Y2hpbmcgZm9jdXMgYmVmb3JlIGNvbmZpcm1pbmcgY29tcG9zaXRpb24gY2hvaWNlXG4gICAgICAgIC8vIHRoaXMgYWxzbyBmaXhlcyB0aGUgaXNzdWUgd2hlcmUgc29tZSBicm93c2VycyBlLmcuIGlPUyBDaHJvbWVcbiAgICAgICAgLy8gZmlyZXMgXCJjaGFuZ2VcIiBpbnN0ZWFkIG9mIFwiaW5wdXRcIiBvbiBhdXRvY29tcGxldGUuXG4gICAgICAgIGVsLmFkZEV2ZW50TGlzdGVuZXIoJ2NoYW5nZScsIG9uQ29tcG9zaXRpb25FbmQpO1xuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgICAgaWYgKGlzSUU5KSB7XG4gICAgICAgICAgZWwudm1vZGVsID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfSxcblxuICBjb21wb25lbnRVcGRhdGVkOiBmdW5jdGlvbiBjb21wb25lbnRVcGRhdGVkIChlbCwgYmluZGluZywgdm5vZGUpIHtcbiAgICBpZiAodm5vZGUudGFnID09PSAnc2VsZWN0Jykge1xuICAgICAgc2V0U2VsZWN0ZWQoZWwsIGJpbmRpbmcsIHZub2RlLmNvbnRleHQpO1xuICAgICAgLy8gaW4gY2FzZSB0aGUgb3B0aW9ucyByZW5kZXJlZCBieSB2LWZvciBoYXZlIGNoYW5nZWQsXG4gICAgICAvLyBpdCdzIHBvc3NpYmxlIHRoYXQgdGhlIHZhbHVlIGlzIG91dC1vZi1zeW5jIHdpdGggdGhlIHJlbmRlcmVkIG9wdGlvbnMuXG4gICAgICAvLyBkZXRlY3Qgc3VjaCBjYXNlcyBhbmQgZmlsdGVyIG91dCB2YWx1ZXMgdGhhdCBubyBsb25nZXIgaGFzIGEgbWF0Y2hpbmdcbiAgICAgIC8vIG9wdGlvbiBpbiB0aGUgRE9NLlxuICAgICAgdmFyIHByZXZPcHRpb25zID0gZWwuX3ZPcHRpb25zO1xuICAgICAgdmFyIGN1ck9wdGlvbnMgPSBlbC5fdk9wdGlvbnMgPSBbXS5tYXAuY2FsbChlbC5vcHRpb25zLCBnZXRWYWx1ZSk7XG4gICAgICBpZiAoY3VyT3B0aW9ucy5zb21lKGZ1bmN0aW9uIChvLCBpKSB7IHJldHVybiAhbG9vc2VFcXVhbChvLCBwcmV2T3B0aW9uc1tpXSk7IH0pKSB7XG4gICAgICAgIC8vIHRyaWdnZXIgY2hhbmdlIGV2ZW50IGlmXG4gICAgICAgIC8vIG5vIG1hdGNoaW5nIG9wdGlvbiBmb3VuZCBmb3IgYXQgbGVhc3Qgb25lIHZhbHVlXG4gICAgICAgIHZhciBuZWVkUmVzZXQgPSBlbC5tdWx0aXBsZVxuICAgICAgICAgID8gYmluZGluZy52YWx1ZS5zb21lKGZ1bmN0aW9uICh2KSB7IHJldHVybiBoYXNOb01hdGNoaW5nT3B0aW9uKHYsIGN1ck9wdGlvbnMpOyB9KVxuICAgICAgICAgIDogYmluZGluZy52YWx1ZSAhPT0gYmluZGluZy5vbGRWYWx1ZSAmJiBoYXNOb01hdGNoaW5nT3B0aW9uKGJpbmRpbmcudmFsdWUsIGN1ck9wdGlvbnMpO1xuICAgICAgICBpZiAobmVlZFJlc2V0KSB7XG4gICAgICAgICAgdHJpZ2dlcihlbCwgJ2NoYW5nZScpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG59O1xuXG5mdW5jdGlvbiBzZXRTZWxlY3RlZCAoZWwsIGJpbmRpbmcsIHZtKSB7XG4gIGFjdHVhbGx5U2V0U2VsZWN0ZWQoZWwsIGJpbmRpbmcsIHZtKTtcbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gIGlmIChpc0lFIHx8IGlzRWRnZSkge1xuICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgYWN0dWFsbHlTZXRTZWxlY3RlZChlbCwgYmluZGluZywgdm0pO1xuICAgIH0sIDApO1xuICB9XG59XG5cbmZ1bmN0aW9uIGFjdHVhbGx5U2V0U2VsZWN0ZWQgKGVsLCBiaW5kaW5nLCB2bSkge1xuICB2YXIgdmFsdWUgPSBiaW5kaW5nLnZhbHVlO1xuICB2YXIgaXNNdWx0aXBsZSA9IGVsLm11bHRpcGxlO1xuICBpZiAoaXNNdWx0aXBsZSAmJiAhQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIHdhcm4oXG4gICAgICBcIjxzZWxlY3QgbXVsdGlwbGUgdi1tb2RlbD1cXFwiXCIgKyAoYmluZGluZy5leHByZXNzaW9uKSArIFwiXFxcIj4gXCIgK1xuICAgICAgXCJleHBlY3RzIGFuIEFycmF5IHZhbHVlIGZvciBpdHMgYmluZGluZywgYnV0IGdvdCBcIiArIChPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodmFsdWUpLnNsaWNlKDgsIC0xKSksXG4gICAgICB2bVxuICAgICk7XG4gICAgcmV0dXJuXG4gIH1cbiAgdmFyIHNlbGVjdGVkLCBvcHRpb247XG4gIGZvciAodmFyIGkgPSAwLCBsID0gZWwub3B0aW9ucy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICBvcHRpb24gPSBlbC5vcHRpb25zW2ldO1xuICAgIGlmIChpc011bHRpcGxlKSB7XG4gICAgICBzZWxlY3RlZCA9IGxvb3NlSW5kZXhPZih2YWx1ZSwgZ2V0VmFsdWUob3B0aW9uKSkgPiAtMTtcbiAgICAgIGlmIChvcHRpb24uc2VsZWN0ZWQgIT09IHNlbGVjdGVkKSB7XG4gICAgICAgIG9wdGlvbi5zZWxlY3RlZCA9IHNlbGVjdGVkO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBpZiAobG9vc2VFcXVhbChnZXRWYWx1ZShvcHRpb24pLCB2YWx1ZSkpIHtcbiAgICAgICAgaWYgKGVsLnNlbGVjdGVkSW5kZXggIT09IGkpIHtcbiAgICAgICAgICBlbC5zZWxlY3RlZEluZGV4ID0gaTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm5cbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgaWYgKCFpc011bHRpcGxlKSB7XG4gICAgZWwuc2VsZWN0ZWRJbmRleCA9IC0xO1xuICB9XG59XG5cbmZ1bmN0aW9uIGhhc05vTWF0Y2hpbmdPcHRpb24gKHZhbHVlLCBvcHRpb25zKSB7XG4gIHJldHVybiBvcHRpb25zLmV2ZXJ5KGZ1bmN0aW9uIChvKSB7IHJldHVybiAhbG9vc2VFcXVhbChvLCB2YWx1ZSk7IH0pXG59XG5cbmZ1bmN0aW9uIGdldFZhbHVlIChvcHRpb24pIHtcbiAgcmV0dXJuICdfdmFsdWUnIGluIG9wdGlvblxuICAgID8gb3B0aW9uLl92YWx1ZVxuICAgIDogb3B0aW9uLnZhbHVlXG59XG5cbmZ1bmN0aW9uIG9uQ29tcG9zaXRpb25TdGFydCAoZSkge1xuICBlLnRhcmdldC5jb21wb3NpbmcgPSB0cnVlO1xufVxuXG5mdW5jdGlvbiBvbkNvbXBvc2l0aW9uRW5kIChlKSB7XG4gIC8vIHByZXZlbnQgdHJpZ2dlcmluZyBhbiBpbnB1dCBldmVudCBmb3Igbm8gcmVhc29uXG4gIGlmICghZS50YXJnZXQuY29tcG9zaW5nKSB7IHJldHVybiB9XG4gIGUudGFyZ2V0LmNvbXBvc2luZyA9IGZhbHNlO1xuICB0cmlnZ2VyKGUudGFyZ2V0LCAnaW5wdXQnKTtcbn1cblxuZnVuY3Rpb24gdHJpZ2dlciAoZWwsIHR5cGUpIHtcbiAgdmFyIGUgPSBkb2N1bWVudC5jcmVhdGVFdmVudCgnSFRNTEV2ZW50cycpO1xuICBlLmluaXRFdmVudCh0eXBlLCB0cnVlLCB0cnVlKTtcbiAgZWwuZGlzcGF0Y2hFdmVudChlKTtcbn1cblxuLyogICovXG5cbi8vIHJlY3Vyc2l2ZWx5IHNlYXJjaCBmb3IgcG9zc2libGUgdHJhbnNpdGlvbiBkZWZpbmVkIGluc2lkZSB0aGUgY29tcG9uZW50IHJvb3RcbmZ1bmN0aW9uIGxvY2F0ZU5vZGUgKHZub2RlKSB7XG4gIHJldHVybiB2bm9kZS5jb21wb25lbnRJbnN0YW5jZSAmJiAoIXZub2RlLmRhdGEgfHwgIXZub2RlLmRhdGEudHJhbnNpdGlvbilcbiAgICA/IGxvY2F0ZU5vZGUodm5vZGUuY29tcG9uZW50SW5zdGFuY2UuX3Zub2RlKVxuICAgIDogdm5vZGVcbn1cblxudmFyIHNob3cgPSB7XG4gIGJpbmQ6IGZ1bmN0aW9uIGJpbmQgKGVsLCByZWYsIHZub2RlKSB7XG4gICAgdmFyIHZhbHVlID0gcmVmLnZhbHVlO1xuXG4gICAgdm5vZGUgPSBsb2NhdGVOb2RlKHZub2RlKTtcbiAgICB2YXIgdHJhbnNpdGlvbiQkMSA9IHZub2RlLmRhdGEgJiYgdm5vZGUuZGF0YS50cmFuc2l0aW9uO1xuICAgIHZhciBvcmlnaW5hbERpc3BsYXkgPSBlbC5fX3ZPcmlnaW5hbERpc3BsYXkgPVxuICAgICAgZWwuc3R5bGUuZGlzcGxheSA9PT0gJ25vbmUnID8gJycgOiBlbC5zdHlsZS5kaXNwbGF5O1xuICAgIGlmICh2YWx1ZSAmJiB0cmFuc2l0aW9uJCQxKSB7XG4gICAgICB2bm9kZS5kYXRhLnNob3cgPSB0cnVlO1xuICAgICAgZW50ZXIodm5vZGUsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZWwuc3R5bGUuZGlzcGxheSA9IG9yaWdpbmFsRGlzcGxheTtcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBlbC5zdHlsZS5kaXNwbGF5ID0gdmFsdWUgPyBvcmlnaW5hbERpc3BsYXkgOiAnbm9uZSc7XG4gICAgfVxuICB9LFxuXG4gIHVwZGF0ZTogZnVuY3Rpb24gdXBkYXRlIChlbCwgcmVmLCB2bm9kZSkge1xuICAgIHZhciB2YWx1ZSA9IHJlZi52YWx1ZTtcbiAgICB2YXIgb2xkVmFsdWUgPSByZWYub2xkVmFsdWU7XG5cbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICBpZiAoIXZhbHVlID09PSAhb2xkVmFsdWUpIHsgcmV0dXJuIH1cbiAgICB2bm9kZSA9IGxvY2F0ZU5vZGUodm5vZGUpO1xuICAgIHZhciB0cmFuc2l0aW9uJCQxID0gdm5vZGUuZGF0YSAmJiB2bm9kZS5kYXRhLnRyYW5zaXRpb247XG4gICAgaWYgKHRyYW5zaXRpb24kJDEpIHtcbiAgICAgIHZub2RlLmRhdGEuc2hvdyA9IHRydWU7XG4gICAgICBpZiAodmFsdWUpIHtcbiAgICAgICAgZW50ZXIodm5vZGUsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBlbC5zdHlsZS5kaXNwbGF5ID0gZWwuX192T3JpZ2luYWxEaXNwbGF5O1xuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGxlYXZlKHZub2RlLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgZWwuc3R5bGUuZGlzcGxheSA9ICdub25lJztcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGVsLnN0eWxlLmRpc3BsYXkgPSB2YWx1ZSA/IGVsLl9fdk9yaWdpbmFsRGlzcGxheSA6ICdub25lJztcbiAgICB9XG4gIH0sXG5cbiAgdW5iaW5kOiBmdW5jdGlvbiB1bmJpbmQgKFxuICAgIGVsLFxuICAgIGJpbmRpbmcsXG4gICAgdm5vZGUsXG4gICAgb2xkVm5vZGUsXG4gICAgaXNEZXN0cm95XG4gICkge1xuICAgIGlmICghaXNEZXN0cm95KSB7XG4gICAgICBlbC5zdHlsZS5kaXNwbGF5ID0gZWwuX192T3JpZ2luYWxEaXNwbGF5O1xuICAgIH1cbiAgfVxufTtcblxudmFyIHBsYXRmb3JtRGlyZWN0aXZlcyA9IHtcbiAgbW9kZWw6IGRpcmVjdGl2ZSxcbiAgc2hvdzogc2hvd1xufTtcblxuLyogICovXG5cbnZhciB0cmFuc2l0aW9uUHJvcHMgPSB7XG4gIG5hbWU6IFN0cmluZyxcbiAgYXBwZWFyOiBCb29sZWFuLFxuICBjc3M6IEJvb2xlYW4sXG4gIG1vZGU6IFN0cmluZyxcbiAgdHlwZTogU3RyaW5nLFxuICBlbnRlckNsYXNzOiBTdHJpbmcsXG4gIGxlYXZlQ2xhc3M6IFN0cmluZyxcbiAgZW50ZXJUb0NsYXNzOiBTdHJpbmcsXG4gIGxlYXZlVG9DbGFzczogU3RyaW5nLFxuICBlbnRlckFjdGl2ZUNsYXNzOiBTdHJpbmcsXG4gIGxlYXZlQWN0aXZlQ2xhc3M6IFN0cmluZyxcbiAgYXBwZWFyQ2xhc3M6IFN0cmluZyxcbiAgYXBwZWFyQWN0aXZlQ2xhc3M6IFN0cmluZyxcbiAgYXBwZWFyVG9DbGFzczogU3RyaW5nLFxuICBkdXJhdGlvbjogW051bWJlciwgU3RyaW5nLCBPYmplY3RdXG59O1xuXG4vLyBpbiBjYXNlIHRoZSBjaGlsZCBpcyBhbHNvIGFuIGFic3RyYWN0IGNvbXBvbmVudCwgZS5nLiA8a2VlcC1hbGl2ZT5cbi8vIHdlIHdhbnQgdG8gcmVjdXJzaXZlbHkgcmV0cmlldmUgdGhlIHJlYWwgY29tcG9uZW50IHRvIGJlIHJlbmRlcmVkXG5mdW5jdGlvbiBnZXRSZWFsQ2hpbGQgKHZub2RlKSB7XG4gIHZhciBjb21wT3B0aW9ucyA9IHZub2RlICYmIHZub2RlLmNvbXBvbmVudE9wdGlvbnM7XG4gIGlmIChjb21wT3B0aW9ucyAmJiBjb21wT3B0aW9ucy5DdG9yLm9wdGlvbnMuYWJzdHJhY3QpIHtcbiAgICByZXR1cm4gZ2V0UmVhbENoaWxkKGdldEZpcnN0Q29tcG9uZW50Q2hpbGQoY29tcE9wdGlvbnMuY2hpbGRyZW4pKVxuICB9IGVsc2Uge1xuICAgIHJldHVybiB2bm9kZVxuICB9XG59XG5cbmZ1bmN0aW9uIGV4dHJhY3RUcmFuc2l0aW9uRGF0YSAoY29tcCkge1xuICB2YXIgZGF0YSA9IHt9O1xuICB2YXIgb3B0aW9ucyA9IGNvbXAuJG9wdGlvbnM7XG4gIC8vIHByb3BzXG4gIGZvciAodmFyIGtleSBpbiBvcHRpb25zLnByb3BzRGF0YSkge1xuICAgIGRhdGFba2V5XSA9IGNvbXBba2V5XTtcbiAgfVxuICAvLyBldmVudHMuXG4gIC8vIGV4dHJhY3QgbGlzdGVuZXJzIGFuZCBwYXNzIHRoZW0gZGlyZWN0bHkgdG8gdGhlIHRyYW5zaXRpb24gbWV0aG9kc1xuICB2YXIgbGlzdGVuZXJzID0gb3B0aW9ucy5fcGFyZW50TGlzdGVuZXJzO1xuICBmb3IgKHZhciBrZXkkMSBpbiBsaXN0ZW5lcnMpIHtcbiAgICBkYXRhW2NhbWVsaXplKGtleSQxKV0gPSBsaXN0ZW5lcnNba2V5JDFdO1xuICB9XG4gIHJldHVybiBkYXRhXG59XG5cbmZ1bmN0aW9uIHBsYWNlaG9sZGVyIChoLCByYXdDaGlsZCkge1xuICBpZiAoL1xcZC1rZWVwLWFsaXZlJC8udGVzdChyYXdDaGlsZC50YWcpKSB7XG4gICAgcmV0dXJuIGgoJ2tlZXAtYWxpdmUnLCB7XG4gICAgICBwcm9wczogcmF3Q2hpbGQuY29tcG9uZW50T3B0aW9ucy5wcm9wc0RhdGFcbiAgICB9KVxuICB9XG59XG5cbmZ1bmN0aW9uIGhhc1BhcmVudFRyYW5zaXRpb24gKHZub2RlKSB7XG4gIHdoaWxlICgodm5vZGUgPSB2bm9kZS5wYXJlbnQpKSB7XG4gICAgaWYgKHZub2RlLmRhdGEudHJhbnNpdGlvbikge1xuICAgICAgcmV0dXJuIHRydWVcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gaXNTYW1lQ2hpbGQgKGNoaWxkLCBvbGRDaGlsZCkge1xuICByZXR1cm4gb2xkQ2hpbGQua2V5ID09PSBjaGlsZC5rZXkgJiYgb2xkQ2hpbGQudGFnID09PSBjaGlsZC50YWdcbn1cblxudmFyIGlzTm90VGV4dE5vZGUgPSBmdW5jdGlvbiAoYykgeyByZXR1cm4gYy50YWcgfHwgaXNBc3luY1BsYWNlaG9sZGVyKGMpOyB9O1xuXG52YXIgaXNWU2hvd0RpcmVjdGl2ZSA9IGZ1bmN0aW9uIChkKSB7IHJldHVybiBkLm5hbWUgPT09ICdzaG93JzsgfTtcblxudmFyIFRyYW5zaXRpb24gPSB7XG4gIG5hbWU6ICd0cmFuc2l0aW9uJyxcbiAgcHJvcHM6IHRyYW5zaXRpb25Qcm9wcyxcbiAgYWJzdHJhY3Q6IHRydWUsXG5cbiAgcmVuZGVyOiBmdW5jdGlvbiByZW5kZXIgKGgpIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICAgIHZhciBjaGlsZHJlbiA9IHRoaXMuJHNsb3RzLmRlZmF1bHQ7XG4gICAgaWYgKCFjaGlsZHJlbikge1xuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgLy8gZmlsdGVyIG91dCB0ZXh0IG5vZGVzIChwb3NzaWJsZSB3aGl0ZXNwYWNlcylcbiAgICBjaGlsZHJlbiA9IGNoaWxkcmVuLmZpbHRlcihpc05vdFRleHROb2RlKTtcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICBpZiAoIWNoaWxkcmVuLmxlbmd0aCkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgLy8gd2FybiBtdWx0aXBsZSBlbGVtZW50c1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIGNoaWxkcmVuLmxlbmd0aCA+IDEpIHtcbiAgICAgIHdhcm4oXG4gICAgICAgICc8dHJhbnNpdGlvbj4gY2FuIG9ubHkgYmUgdXNlZCBvbiBhIHNpbmdsZSBlbGVtZW50LiBVc2UgJyArXG4gICAgICAgICc8dHJhbnNpdGlvbi1ncm91cD4gZm9yIGxpc3RzLicsXG4gICAgICAgIHRoaXMuJHBhcmVudFxuICAgICAgKTtcbiAgICB9XG5cbiAgICB2YXIgbW9kZSA9IHRoaXMubW9kZTtcblxuICAgIC8vIHdhcm4gaW52YWxpZCBtb2RlXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiZcbiAgICAgIG1vZGUgJiYgbW9kZSAhPT0gJ2luLW91dCcgJiYgbW9kZSAhPT0gJ291dC1pbidcbiAgICApIHtcbiAgICAgIHdhcm4oXG4gICAgICAgICdpbnZhbGlkIDx0cmFuc2l0aW9uPiBtb2RlOiAnICsgbW9kZSxcbiAgICAgICAgdGhpcy4kcGFyZW50XG4gICAgICApO1xuICAgIH1cblxuICAgIHZhciByYXdDaGlsZCA9IGNoaWxkcmVuWzBdO1xuXG4gICAgLy8gaWYgdGhpcyBpcyBhIGNvbXBvbmVudCByb290IG5vZGUgYW5kIHRoZSBjb21wb25lbnQnc1xuICAgIC8vIHBhcmVudCBjb250YWluZXIgbm9kZSBhbHNvIGhhcyB0cmFuc2l0aW9uLCBza2lwLlxuICAgIGlmIChoYXNQYXJlbnRUcmFuc2l0aW9uKHRoaXMuJHZub2RlKSkge1xuICAgICAgcmV0dXJuIHJhd0NoaWxkXG4gICAgfVxuXG4gICAgLy8gYXBwbHkgdHJhbnNpdGlvbiBkYXRhIHRvIGNoaWxkXG4gICAgLy8gdXNlIGdldFJlYWxDaGlsZCgpIHRvIGlnbm9yZSBhYnN0cmFjdCBjb21wb25lbnRzIGUuZy4ga2VlcC1hbGl2ZVxuICAgIHZhciBjaGlsZCA9IGdldFJlYWxDaGlsZChyYXdDaGlsZCk7XG4gICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgaWYgKCFjaGlsZCkge1xuICAgICAgcmV0dXJuIHJhd0NoaWxkXG4gICAgfVxuXG4gICAgaWYgKHRoaXMuX2xlYXZpbmcpIHtcbiAgICAgIHJldHVybiBwbGFjZWhvbGRlcihoLCByYXdDaGlsZClcbiAgICB9XG5cbiAgICAvLyBlbnN1cmUgYSBrZXkgdGhhdCBpcyB1bmlxdWUgdG8gdGhlIHZub2RlIHR5cGUgYW5kIHRvIHRoaXMgdHJhbnNpdGlvblxuICAgIC8vIGNvbXBvbmVudCBpbnN0YW5jZS4gVGhpcyBrZXkgd2lsbCBiZSB1c2VkIHRvIHJlbW92ZSBwZW5kaW5nIGxlYXZpbmcgbm9kZXNcbiAgICAvLyBkdXJpbmcgZW50ZXJpbmcuXG4gICAgdmFyIGlkID0gXCJfX3RyYW5zaXRpb24tXCIgKyAodGhpcy5fdWlkKSArIFwiLVwiO1xuICAgIGNoaWxkLmtleSA9IGNoaWxkLmtleSA9PSBudWxsXG4gICAgICA/IGNoaWxkLmlzQ29tbWVudFxuICAgICAgICA/IGlkICsgJ2NvbW1lbnQnXG4gICAgICAgIDogaWQgKyBjaGlsZC50YWdcbiAgICAgIDogaXNQcmltaXRpdmUoY2hpbGQua2V5KVxuICAgICAgICA/IChTdHJpbmcoY2hpbGQua2V5KS5pbmRleE9mKGlkKSA9PT0gMCA/IGNoaWxkLmtleSA6IGlkICsgY2hpbGQua2V5KVxuICAgICAgICA6IGNoaWxkLmtleTtcblxuICAgIHZhciBkYXRhID0gKGNoaWxkLmRhdGEgfHwgKGNoaWxkLmRhdGEgPSB7fSkpLnRyYW5zaXRpb24gPSBleHRyYWN0VHJhbnNpdGlvbkRhdGEodGhpcyk7XG4gICAgdmFyIG9sZFJhd0NoaWxkID0gdGhpcy5fdm5vZGU7XG4gICAgdmFyIG9sZENoaWxkID0gZ2V0UmVhbENoaWxkKG9sZFJhd0NoaWxkKTtcblxuICAgIC8vIG1hcmsgdi1zaG93XG4gICAgLy8gc28gdGhhdCB0aGUgdHJhbnNpdGlvbiBtb2R1bGUgY2FuIGhhbmQgb3ZlciB0aGUgY29udHJvbCB0byB0aGUgZGlyZWN0aXZlXG4gICAgaWYgKGNoaWxkLmRhdGEuZGlyZWN0aXZlcyAmJiBjaGlsZC5kYXRhLmRpcmVjdGl2ZXMuc29tZShpc1ZTaG93RGlyZWN0aXZlKSkge1xuICAgICAgY2hpbGQuZGF0YS5zaG93ID0gdHJ1ZTtcbiAgICB9XG5cbiAgICBpZiAoXG4gICAgICBvbGRDaGlsZCAmJlxuICAgICAgb2xkQ2hpbGQuZGF0YSAmJlxuICAgICAgIWlzU2FtZUNoaWxkKGNoaWxkLCBvbGRDaGlsZCkgJiZcbiAgICAgICFpc0FzeW5jUGxhY2Vob2xkZXIob2xkQ2hpbGQpICYmXG4gICAgICAvLyAjNjY4NyBjb21wb25lbnQgcm9vdCBpcyBhIGNvbW1lbnQgbm9kZVxuICAgICAgIShvbGRDaGlsZC5jb21wb25lbnRJbnN0YW5jZSAmJiBvbGRDaGlsZC5jb21wb25lbnRJbnN0YW5jZS5fdm5vZGUuaXNDb21tZW50KVxuICAgICkge1xuICAgICAgLy8gcmVwbGFjZSBvbGQgY2hpbGQgdHJhbnNpdGlvbiBkYXRhIHdpdGggZnJlc2ggb25lXG4gICAgICAvLyBpbXBvcnRhbnQgZm9yIGR5bmFtaWMgdHJhbnNpdGlvbnMhXG4gICAgICB2YXIgb2xkRGF0YSA9IG9sZENoaWxkLmRhdGEudHJhbnNpdGlvbiA9IGV4dGVuZCh7fSwgZGF0YSk7XG4gICAgICAvLyBoYW5kbGUgdHJhbnNpdGlvbiBtb2RlXG4gICAgICBpZiAobW9kZSA9PT0gJ291dC1pbicpIHtcbiAgICAgICAgLy8gcmV0dXJuIHBsYWNlaG9sZGVyIG5vZGUgYW5kIHF1ZXVlIHVwZGF0ZSB3aGVuIGxlYXZlIGZpbmlzaGVzXG4gICAgICAgIHRoaXMuX2xlYXZpbmcgPSB0cnVlO1xuICAgICAgICBtZXJnZVZOb2RlSG9vayhvbGREYXRhLCAnYWZ0ZXJMZWF2ZScsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICB0aGlzJDEuX2xlYXZpbmcgPSBmYWxzZTtcbiAgICAgICAgICB0aGlzJDEuJGZvcmNlVXBkYXRlKCk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gcGxhY2Vob2xkZXIoaCwgcmF3Q2hpbGQpXG4gICAgICB9IGVsc2UgaWYgKG1vZGUgPT09ICdpbi1vdXQnKSB7XG4gICAgICAgIGlmIChpc0FzeW5jUGxhY2Vob2xkZXIoY2hpbGQpKSB7XG4gICAgICAgICAgcmV0dXJuIG9sZFJhd0NoaWxkXG4gICAgICAgIH1cbiAgICAgICAgdmFyIGRlbGF5ZWRMZWF2ZTtcbiAgICAgICAgdmFyIHBlcmZvcm1MZWF2ZSA9IGZ1bmN0aW9uICgpIHsgZGVsYXllZExlYXZlKCk7IH07XG4gICAgICAgIG1lcmdlVk5vZGVIb29rKGRhdGEsICdhZnRlckVudGVyJywgcGVyZm9ybUxlYXZlKTtcbiAgICAgICAgbWVyZ2VWTm9kZUhvb2soZGF0YSwgJ2VudGVyQ2FuY2VsbGVkJywgcGVyZm9ybUxlYXZlKTtcbiAgICAgICAgbWVyZ2VWTm9kZUhvb2sob2xkRGF0YSwgJ2RlbGF5TGVhdmUnLCBmdW5jdGlvbiAobGVhdmUpIHsgZGVsYXllZExlYXZlID0gbGVhdmU7IH0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiByYXdDaGlsZFxuICB9XG59O1xuXG4vKiAgKi9cblxudmFyIHByb3BzID0gZXh0ZW5kKHtcbiAgdGFnOiBTdHJpbmcsXG4gIG1vdmVDbGFzczogU3RyaW5nXG59LCB0cmFuc2l0aW9uUHJvcHMpO1xuXG5kZWxldGUgcHJvcHMubW9kZTtcblxudmFyIFRyYW5zaXRpb25Hcm91cCA9IHtcbiAgcHJvcHM6IHByb3BzLFxuXG4gIGJlZm9yZU1vdW50OiBmdW5jdGlvbiBiZWZvcmVNb3VudCAoKSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgICB2YXIgdXBkYXRlID0gdGhpcy5fdXBkYXRlO1xuICAgIHRoaXMuX3VwZGF0ZSA9IGZ1bmN0aW9uICh2bm9kZSwgaHlkcmF0aW5nKSB7XG4gICAgICB2YXIgcmVzdG9yZUFjdGl2ZUluc3RhbmNlID0gc2V0QWN0aXZlSW5zdGFuY2UodGhpcyQxKTtcbiAgICAgIC8vIGZvcmNlIHJlbW92aW5nIHBhc3NcbiAgICAgIHRoaXMkMS5fX3BhdGNoX18oXG4gICAgICAgIHRoaXMkMS5fdm5vZGUsXG4gICAgICAgIHRoaXMkMS5rZXB0LFxuICAgICAgICBmYWxzZSwgLy8gaHlkcmF0aW5nXG4gICAgICAgIHRydWUgLy8gcmVtb3ZlT25seSAoIWltcG9ydGFudCwgYXZvaWRzIHVubmVjZXNzYXJ5IG1vdmVzKVxuICAgICAgKTtcbiAgICAgIHRoaXMkMS5fdm5vZGUgPSB0aGlzJDEua2VwdDtcbiAgICAgIHJlc3RvcmVBY3RpdmVJbnN0YW5jZSgpO1xuICAgICAgdXBkYXRlLmNhbGwodGhpcyQxLCB2bm9kZSwgaHlkcmF0aW5nKTtcbiAgICB9O1xuICB9LFxuXG4gIHJlbmRlcjogZnVuY3Rpb24gcmVuZGVyIChoKSB7XG4gICAgdmFyIHRhZyA9IHRoaXMudGFnIHx8IHRoaXMuJHZub2RlLmRhdGEudGFnIHx8ICdzcGFuJztcbiAgICB2YXIgbWFwID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICB2YXIgcHJldkNoaWxkcmVuID0gdGhpcy5wcmV2Q2hpbGRyZW4gPSB0aGlzLmNoaWxkcmVuO1xuICAgIHZhciByYXdDaGlsZHJlbiA9IHRoaXMuJHNsb3RzLmRlZmF1bHQgfHwgW107XG4gICAgdmFyIGNoaWxkcmVuID0gdGhpcy5jaGlsZHJlbiA9IFtdO1xuICAgIHZhciB0cmFuc2l0aW9uRGF0YSA9IGV4dHJhY3RUcmFuc2l0aW9uRGF0YSh0aGlzKTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcmF3Q2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBjID0gcmF3Q2hpbGRyZW5baV07XG4gICAgICBpZiAoYy50YWcpIHtcbiAgICAgICAgaWYgKGMua2V5ICE9IG51bGwgJiYgU3RyaW5nKGMua2V5KS5pbmRleE9mKCdfX3ZsaXN0JykgIT09IDApIHtcbiAgICAgICAgICBjaGlsZHJlbi5wdXNoKGMpO1xuICAgICAgICAgIG1hcFtjLmtleV0gPSBjXG4gICAgICAgICAgOyhjLmRhdGEgfHwgKGMuZGF0YSA9IHt9KSkudHJhbnNpdGlvbiA9IHRyYW5zaXRpb25EYXRhO1xuICAgICAgICB9IGVsc2UgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgICB2YXIgb3B0cyA9IGMuY29tcG9uZW50T3B0aW9ucztcbiAgICAgICAgICB2YXIgbmFtZSA9IG9wdHMgPyAob3B0cy5DdG9yLm9wdGlvbnMubmFtZSB8fCBvcHRzLnRhZyB8fCAnJykgOiBjLnRhZztcbiAgICAgICAgICB3YXJuKChcIjx0cmFuc2l0aW9uLWdyb3VwPiBjaGlsZHJlbiBtdXN0IGJlIGtleWVkOiA8XCIgKyBuYW1lICsgXCI+XCIpKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChwcmV2Q2hpbGRyZW4pIHtcbiAgICAgIHZhciBrZXB0ID0gW107XG4gICAgICB2YXIgcmVtb3ZlZCA9IFtdO1xuICAgICAgZm9yICh2YXIgaSQxID0gMDsgaSQxIDwgcHJldkNoaWxkcmVuLmxlbmd0aDsgaSQxKyspIHtcbiAgICAgICAgdmFyIGMkMSA9IHByZXZDaGlsZHJlbltpJDFdO1xuICAgICAgICBjJDEuZGF0YS50cmFuc2l0aW9uID0gdHJhbnNpdGlvbkRhdGE7XG4gICAgICAgIGMkMS5kYXRhLnBvcyA9IGMkMS5lbG0uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICAgIGlmIChtYXBbYyQxLmtleV0pIHtcbiAgICAgICAgICBrZXB0LnB1c2goYyQxKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZW1vdmVkLnB1c2goYyQxKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdGhpcy5rZXB0ID0gaCh0YWcsIG51bGwsIGtlcHQpO1xuICAgICAgdGhpcy5yZW1vdmVkID0gcmVtb3ZlZDtcbiAgICB9XG5cbiAgICByZXR1cm4gaCh0YWcsIG51bGwsIGNoaWxkcmVuKVxuICB9LFxuXG4gIHVwZGF0ZWQ6IGZ1bmN0aW9uIHVwZGF0ZWQgKCkge1xuICAgIHZhciBjaGlsZHJlbiA9IHRoaXMucHJldkNoaWxkcmVuO1xuICAgIHZhciBtb3ZlQ2xhc3MgPSB0aGlzLm1vdmVDbGFzcyB8fCAoKHRoaXMubmFtZSB8fCAndicpICsgJy1tb3ZlJyk7XG4gICAgaWYgKCFjaGlsZHJlbi5sZW5ndGggfHwgIXRoaXMuaGFzTW92ZShjaGlsZHJlblswXS5lbG0sIG1vdmVDbGFzcykpIHtcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIC8vIHdlIGRpdmlkZSB0aGUgd29yayBpbnRvIHRocmVlIGxvb3BzIHRvIGF2b2lkIG1peGluZyBET00gcmVhZHMgYW5kIHdyaXRlc1xuICAgIC8vIGluIGVhY2ggaXRlcmF0aW9uIC0gd2hpY2ggaGVscHMgcHJldmVudCBsYXlvdXQgdGhyYXNoaW5nLlxuICAgIGNoaWxkcmVuLmZvckVhY2goY2FsbFBlbmRpbmdDYnMpO1xuICAgIGNoaWxkcmVuLmZvckVhY2gocmVjb3JkUG9zaXRpb24pO1xuICAgIGNoaWxkcmVuLmZvckVhY2goYXBwbHlUcmFuc2xhdGlvbik7XG5cbiAgICAvLyBmb3JjZSByZWZsb3cgdG8gcHV0IGV2ZXJ5dGhpbmcgaW4gcG9zaXRpb25cbiAgICAvLyBhc3NpZ24gdG8gdGhpcyB0byBhdm9pZCBiZWluZyByZW1vdmVkIGluIHRyZWUtc2hha2luZ1xuICAgIC8vICRmbG93LWRpc2FibGUtbGluZVxuICAgIHRoaXMuX3JlZmxvdyA9IGRvY3VtZW50LmJvZHkub2Zmc2V0SGVpZ2h0O1xuXG4gICAgY2hpbGRyZW4uZm9yRWFjaChmdW5jdGlvbiAoYykge1xuICAgICAgaWYgKGMuZGF0YS5tb3ZlZCkge1xuICAgICAgICB2YXIgZWwgPSBjLmVsbTtcbiAgICAgICAgdmFyIHMgPSBlbC5zdHlsZTtcbiAgICAgICAgYWRkVHJhbnNpdGlvbkNsYXNzKGVsLCBtb3ZlQ2xhc3MpO1xuICAgICAgICBzLnRyYW5zZm9ybSA9IHMuV2Via2l0VHJhbnNmb3JtID0gcy50cmFuc2l0aW9uRHVyYXRpb24gPSAnJztcbiAgICAgICAgZWwuYWRkRXZlbnRMaXN0ZW5lcih0cmFuc2l0aW9uRW5kRXZlbnQsIGVsLl9tb3ZlQ2IgPSBmdW5jdGlvbiBjYiAoZSkge1xuICAgICAgICAgIGlmIChlICYmIGUudGFyZ2V0ICE9PSBlbCkge1xuICAgICAgICAgICAgcmV0dXJuXG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICghZSB8fCAvdHJhbnNmb3JtJC8udGVzdChlLnByb3BlcnR5TmFtZSkpIHtcbiAgICAgICAgICAgIGVsLnJlbW92ZUV2ZW50TGlzdGVuZXIodHJhbnNpdGlvbkVuZEV2ZW50LCBjYik7XG4gICAgICAgICAgICBlbC5fbW92ZUNiID0gbnVsbDtcbiAgICAgICAgICAgIHJlbW92ZVRyYW5zaXRpb25DbGFzcyhlbCwgbW92ZUNsYXNzKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0pO1xuICB9LFxuXG4gIG1ldGhvZHM6IHtcbiAgICBoYXNNb3ZlOiBmdW5jdGlvbiBoYXNNb3ZlIChlbCwgbW92ZUNsYXNzKSB7XG4gICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgIGlmICghaGFzVHJhbnNpdGlvbikge1xuICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgIH1cbiAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgaWYgKHRoaXMuX2hhc01vdmUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2hhc01vdmVcbiAgICAgIH1cbiAgICAgIC8vIERldGVjdCB3aGV0aGVyIGFuIGVsZW1lbnQgd2l0aCB0aGUgbW92ZSBjbGFzcyBhcHBsaWVkIGhhc1xuICAgICAgLy8gQ1NTIHRyYW5zaXRpb25zLiBTaW5jZSB0aGUgZWxlbWVudCBtYXkgYmUgaW5zaWRlIGFuIGVudGVyaW5nXG4gICAgICAvLyB0cmFuc2l0aW9uIGF0IHRoaXMgdmVyeSBtb21lbnQsIHdlIG1ha2UgYSBjbG9uZSBvZiBpdCBhbmQgcmVtb3ZlXG4gICAgICAvLyBhbGwgb3RoZXIgdHJhbnNpdGlvbiBjbGFzc2VzIGFwcGxpZWQgdG8gZW5zdXJlIG9ubHkgdGhlIG1vdmUgY2xhc3NcbiAgICAgIC8vIGlzIGFwcGxpZWQuXG4gICAgICB2YXIgY2xvbmUgPSBlbC5jbG9uZU5vZGUoKTtcbiAgICAgIGlmIChlbC5fdHJhbnNpdGlvbkNsYXNzZXMpIHtcbiAgICAgICAgZWwuX3RyYW5zaXRpb25DbGFzc2VzLmZvckVhY2goZnVuY3Rpb24gKGNscykgeyByZW1vdmVDbGFzcyhjbG9uZSwgY2xzKTsgfSk7XG4gICAgICB9XG4gICAgICBhZGRDbGFzcyhjbG9uZSwgbW92ZUNsYXNzKTtcbiAgICAgIGNsb25lLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG4gICAgICB0aGlzLiRlbC5hcHBlbmRDaGlsZChjbG9uZSk7XG4gICAgICB2YXIgaW5mbyA9IGdldFRyYW5zaXRpb25JbmZvKGNsb25lKTtcbiAgICAgIHRoaXMuJGVsLnJlbW92ZUNoaWxkKGNsb25lKTtcbiAgICAgIHJldHVybiAodGhpcy5faGFzTW92ZSA9IGluZm8uaGFzVHJhbnNmb3JtKVxuICAgIH1cbiAgfVxufTtcblxuZnVuY3Rpb24gY2FsbFBlbmRpbmdDYnMgKGMpIHtcbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gIGlmIChjLmVsbS5fbW92ZUNiKSB7XG4gICAgYy5lbG0uX21vdmVDYigpO1xuICB9XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICBpZiAoYy5lbG0uX2VudGVyQ2IpIHtcbiAgICBjLmVsbS5fZW50ZXJDYigpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHJlY29yZFBvc2l0aW9uIChjKSB7XG4gIGMuZGF0YS5uZXdQb3MgPSBjLmVsbS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbn1cblxuZnVuY3Rpb24gYXBwbHlUcmFuc2xhdGlvbiAoYykge1xuICB2YXIgb2xkUG9zID0gYy5kYXRhLnBvcztcbiAgdmFyIG5ld1BvcyA9IGMuZGF0YS5uZXdQb3M7XG4gIHZhciBkeCA9IG9sZFBvcy5sZWZ0IC0gbmV3UG9zLmxlZnQ7XG4gIHZhciBkeSA9IG9sZFBvcy50b3AgLSBuZXdQb3MudG9wO1xuICBpZiAoZHggfHwgZHkpIHtcbiAgICBjLmRhdGEubW92ZWQgPSB0cnVlO1xuICAgIHZhciBzID0gYy5lbG0uc3R5bGU7XG4gICAgcy50cmFuc2Zvcm0gPSBzLldlYmtpdFRyYW5zZm9ybSA9IFwidHJhbnNsYXRlKFwiICsgZHggKyBcInB4LFwiICsgZHkgKyBcInB4KVwiO1xuICAgIHMudHJhbnNpdGlvbkR1cmF0aW9uID0gJzBzJztcbiAgfVxufVxuXG52YXIgcGxhdGZvcm1Db21wb25lbnRzID0ge1xuICBUcmFuc2l0aW9uOiBUcmFuc2l0aW9uLFxuICBUcmFuc2l0aW9uR3JvdXA6IFRyYW5zaXRpb25Hcm91cFxufTtcblxuLyogICovXG5cbi8vIGluc3RhbGwgcGxhdGZvcm0gc3BlY2lmaWMgdXRpbHNcblZ1ZS5jb25maWcubXVzdFVzZVByb3AgPSBtdXN0VXNlUHJvcDtcblZ1ZS5jb25maWcuaXNSZXNlcnZlZFRhZyA9IGlzUmVzZXJ2ZWRUYWc7XG5WdWUuY29uZmlnLmlzUmVzZXJ2ZWRBdHRyID0gaXNSZXNlcnZlZEF0dHI7XG5WdWUuY29uZmlnLmdldFRhZ05hbWVzcGFjZSA9IGdldFRhZ05hbWVzcGFjZTtcblZ1ZS5jb25maWcuaXNVbmtub3duRWxlbWVudCA9IGlzVW5rbm93bkVsZW1lbnQ7XG5cbi8vIGluc3RhbGwgcGxhdGZvcm0gcnVudGltZSBkaXJlY3RpdmVzICYgY29tcG9uZW50c1xuZXh0ZW5kKFZ1ZS5vcHRpb25zLmRpcmVjdGl2ZXMsIHBsYXRmb3JtRGlyZWN0aXZlcyk7XG5leHRlbmQoVnVlLm9wdGlvbnMuY29tcG9uZW50cywgcGxhdGZvcm1Db21wb25lbnRzKTtcblxuLy8gaW5zdGFsbCBwbGF0Zm9ybSBwYXRjaCBmdW5jdGlvblxuVnVlLnByb3RvdHlwZS5fX3BhdGNoX18gPSBpbkJyb3dzZXIgPyBwYXRjaCA6IG5vb3A7XG5cbi8vIHB1YmxpYyBtb3VudCBtZXRob2RcblZ1ZS5wcm90b3R5cGUuJG1vdW50ID0gZnVuY3Rpb24gKFxuICBlbCxcbiAgaHlkcmF0aW5nXG4pIHtcbiAgZWwgPSBlbCAmJiBpbkJyb3dzZXIgPyBxdWVyeShlbCkgOiB1bmRlZmluZWQ7XG4gIHJldHVybiBtb3VudENvbXBvbmVudCh0aGlzLCBlbCwgaHlkcmF0aW5nKVxufTtcblxuLy8gZGV2dG9vbHMgZ2xvYmFsIGhvb2tcbi8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG5pZiAoaW5Ccm93c2VyKSB7XG4gIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgIGlmIChjb25maWcuZGV2dG9vbHMpIHtcbiAgICAgIGlmIChkZXZ0b29scykge1xuICAgICAgICBkZXZ0b29scy5lbWl0KCdpbml0JywgVnVlKTtcbiAgICAgIH0gZWxzZSBpZiAoXG4gICAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiZcbiAgICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICd0ZXN0J1xuICAgICAgKSB7XG4gICAgICAgIGNvbnNvbGVbY29uc29sZS5pbmZvID8gJ2luZm8nIDogJ2xvZyddKFxuICAgICAgICAgICdEb3dubG9hZCB0aGUgVnVlIERldnRvb2xzIGV4dGVuc2lvbiBmb3IgYSBiZXR0ZXIgZGV2ZWxvcG1lbnQgZXhwZXJpZW5jZTpcXG4nICtcbiAgICAgICAgICAnaHR0cHM6Ly9naXRodWIuY29tL3Z1ZWpzL3Z1ZS1kZXZ0b29scydcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiZcbiAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAndGVzdCcgJiZcbiAgICAgIGNvbmZpZy5wcm9kdWN0aW9uVGlwICE9PSBmYWxzZSAmJlxuICAgICAgdHlwZW9mIGNvbnNvbGUgIT09ICd1bmRlZmluZWQnXG4gICAgKSB7XG4gICAgICBjb25zb2xlW2NvbnNvbGUuaW5mbyA/ICdpbmZvJyA6ICdsb2cnXShcbiAgICAgICAgXCJZb3UgYXJlIHJ1bm5pbmcgVnVlIGluIGRldmVsb3BtZW50IG1vZGUuXFxuXCIgK1xuICAgICAgICBcIk1ha2Ugc3VyZSB0byB0dXJuIG9uIHByb2R1Y3Rpb24gbW9kZSB3aGVuIGRlcGxveWluZyBmb3IgcHJvZHVjdGlvbi5cXG5cIiArXG4gICAgICAgIFwiU2VlIG1vcmUgdGlwcyBhdCBodHRwczovL3Z1ZWpzLm9yZy9ndWlkZS9kZXBsb3ltZW50Lmh0bWxcIlxuICAgICAgKTtcbiAgICB9XG4gIH0sIDApO1xufVxuXG4vKiAgKi9cblxudmFyIGRlZmF1bHRUYWdSRSA9IC9cXHtcXHsoKD86LnxcXHI/XFxuKSs/KVxcfVxcfS9nO1xudmFyIHJlZ2V4RXNjYXBlUkUgPSAvWy0uKis/XiR7fSgpfFtcXF1cXC9cXFxcXS9nO1xuXG52YXIgYnVpbGRSZWdleCA9IGNhY2hlZChmdW5jdGlvbiAoZGVsaW1pdGVycykge1xuICB2YXIgb3BlbiA9IGRlbGltaXRlcnNbMF0ucmVwbGFjZShyZWdleEVzY2FwZVJFLCAnXFxcXCQmJyk7XG4gIHZhciBjbG9zZSA9IGRlbGltaXRlcnNbMV0ucmVwbGFjZShyZWdleEVzY2FwZVJFLCAnXFxcXCQmJyk7XG4gIHJldHVybiBuZXcgUmVnRXhwKG9wZW4gKyAnKCg/Oi58XFxcXG4pKz8pJyArIGNsb3NlLCAnZycpXG59KTtcblxuXG5cbmZ1bmN0aW9uIHBhcnNlVGV4dCAoXG4gIHRleHQsXG4gIGRlbGltaXRlcnNcbikge1xuICB2YXIgdGFnUkUgPSBkZWxpbWl0ZXJzID8gYnVpbGRSZWdleChkZWxpbWl0ZXJzKSA6IGRlZmF1bHRUYWdSRTtcbiAgaWYgKCF0YWdSRS50ZXN0KHRleHQpKSB7XG4gICAgcmV0dXJuXG4gIH1cbiAgdmFyIHRva2VucyA9IFtdO1xuICB2YXIgcmF3VG9rZW5zID0gW107XG4gIHZhciBsYXN0SW5kZXggPSB0YWdSRS5sYXN0SW5kZXggPSAwO1xuICB2YXIgbWF0Y2gsIGluZGV4LCB0b2tlblZhbHVlO1xuICB3aGlsZSAoKG1hdGNoID0gdGFnUkUuZXhlYyh0ZXh0KSkpIHtcbiAgICBpbmRleCA9IG1hdGNoLmluZGV4O1xuICAgIC8vIHB1c2ggdGV4dCB0b2tlblxuICAgIGlmIChpbmRleCA+IGxhc3RJbmRleCkge1xuICAgICAgcmF3VG9rZW5zLnB1c2godG9rZW5WYWx1ZSA9IHRleHQuc2xpY2UobGFzdEluZGV4LCBpbmRleCkpO1xuICAgICAgdG9rZW5zLnB1c2goSlNPTi5zdHJpbmdpZnkodG9rZW5WYWx1ZSkpO1xuICAgIH1cbiAgICAvLyB0YWcgdG9rZW5cbiAgICB2YXIgZXhwID0gcGFyc2VGaWx0ZXJzKG1hdGNoWzFdLnRyaW0oKSk7XG4gICAgdG9rZW5zLnB1c2goKFwiX3MoXCIgKyBleHAgKyBcIilcIikpO1xuICAgIHJhd1Rva2Vucy5wdXNoKHsgJ0BiaW5kaW5nJzogZXhwIH0pO1xuICAgIGxhc3RJbmRleCA9IGluZGV4ICsgbWF0Y2hbMF0ubGVuZ3RoO1xuICB9XG4gIGlmIChsYXN0SW5kZXggPCB0ZXh0Lmxlbmd0aCkge1xuICAgIHJhd1Rva2Vucy5wdXNoKHRva2VuVmFsdWUgPSB0ZXh0LnNsaWNlKGxhc3RJbmRleCkpO1xuICAgIHRva2Vucy5wdXNoKEpTT04uc3RyaW5naWZ5KHRva2VuVmFsdWUpKTtcbiAgfVxuICByZXR1cm4ge1xuICAgIGV4cHJlc3Npb246IHRva2Vucy5qb2luKCcrJyksXG4gICAgdG9rZW5zOiByYXdUb2tlbnNcbiAgfVxufVxuXG4vKiAgKi9cblxuZnVuY3Rpb24gdHJhbnNmb3JtTm9kZSAoZWwsIG9wdGlvbnMpIHtcbiAgdmFyIHdhcm4gPSBvcHRpb25zLndhcm4gfHwgYmFzZVdhcm47XG4gIHZhciBzdGF0aWNDbGFzcyA9IGdldEFuZFJlbW92ZUF0dHIoZWwsICdjbGFzcycpO1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiBzdGF0aWNDbGFzcykge1xuICAgIHZhciByZXMgPSBwYXJzZVRleHQoc3RhdGljQ2xhc3MsIG9wdGlvbnMuZGVsaW1pdGVycyk7XG4gICAgaWYgKHJlcykge1xuICAgICAgd2FybihcbiAgICAgICAgXCJjbGFzcz1cXFwiXCIgKyBzdGF0aWNDbGFzcyArIFwiXFxcIjogXCIgK1xuICAgICAgICAnSW50ZXJwb2xhdGlvbiBpbnNpZGUgYXR0cmlidXRlcyBoYXMgYmVlbiByZW1vdmVkLiAnICtcbiAgICAgICAgJ1VzZSB2LWJpbmQgb3IgdGhlIGNvbG9uIHNob3J0aGFuZCBpbnN0ZWFkLiBGb3IgZXhhbXBsZSwgJyArXG4gICAgICAgICdpbnN0ZWFkIG9mIDxkaXYgY2xhc3M9XCJ7eyB2YWwgfX1cIj4sIHVzZSA8ZGl2IDpjbGFzcz1cInZhbFwiPi4nLFxuICAgICAgICBlbC5yYXdBdHRyc01hcFsnY2xhc3MnXVxuICAgICAgKTtcbiAgICB9XG4gIH1cbiAgaWYgKHN0YXRpY0NsYXNzKSB7XG4gICAgZWwuc3RhdGljQ2xhc3MgPSBKU09OLnN0cmluZ2lmeShzdGF0aWNDbGFzcyk7XG4gIH1cbiAgdmFyIGNsYXNzQmluZGluZyA9IGdldEJpbmRpbmdBdHRyKGVsLCAnY2xhc3MnLCBmYWxzZSAvKiBnZXRTdGF0aWMgKi8pO1xuICBpZiAoY2xhc3NCaW5kaW5nKSB7XG4gICAgZWwuY2xhc3NCaW5kaW5nID0gY2xhc3NCaW5kaW5nO1xuICB9XG59XG5cbmZ1bmN0aW9uIGdlbkRhdGEgKGVsKSB7XG4gIHZhciBkYXRhID0gJyc7XG4gIGlmIChlbC5zdGF0aWNDbGFzcykge1xuICAgIGRhdGEgKz0gXCJzdGF0aWNDbGFzczpcIiArIChlbC5zdGF0aWNDbGFzcykgKyBcIixcIjtcbiAgfVxuICBpZiAoZWwuY2xhc3NCaW5kaW5nKSB7XG4gICAgZGF0YSArPSBcImNsYXNzOlwiICsgKGVsLmNsYXNzQmluZGluZykgKyBcIixcIjtcbiAgfVxuICByZXR1cm4gZGF0YVxufVxuXG52YXIga2xhc3MkMSA9IHtcbiAgc3RhdGljS2V5czogWydzdGF0aWNDbGFzcyddLFxuICB0cmFuc2Zvcm1Ob2RlOiB0cmFuc2Zvcm1Ob2RlLFxuICBnZW5EYXRhOiBnZW5EYXRhXG59O1xuXG4vKiAgKi9cblxuZnVuY3Rpb24gdHJhbnNmb3JtTm9kZSQxIChlbCwgb3B0aW9ucykge1xuICB2YXIgd2FybiA9IG9wdGlvbnMud2FybiB8fCBiYXNlV2FybjtcbiAgdmFyIHN0YXRpY1N0eWxlID0gZ2V0QW5kUmVtb3ZlQXR0cihlbCwgJ3N0eWxlJyk7XG4gIGlmIChzdGF0aWNTdHlsZSkge1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICB2YXIgcmVzID0gcGFyc2VUZXh0KHN0YXRpY1N0eWxlLCBvcHRpb25zLmRlbGltaXRlcnMpO1xuICAgICAgaWYgKHJlcykge1xuICAgICAgICB3YXJuKFxuICAgICAgICAgIFwic3R5bGU9XFxcIlwiICsgc3RhdGljU3R5bGUgKyBcIlxcXCI6IFwiICtcbiAgICAgICAgICAnSW50ZXJwb2xhdGlvbiBpbnNpZGUgYXR0cmlidXRlcyBoYXMgYmVlbiByZW1vdmVkLiAnICtcbiAgICAgICAgICAnVXNlIHYtYmluZCBvciB0aGUgY29sb24gc2hvcnRoYW5kIGluc3RlYWQuIEZvciBleGFtcGxlLCAnICtcbiAgICAgICAgICAnaW5zdGVhZCBvZiA8ZGl2IHN0eWxlPVwie3sgdmFsIH19XCI+LCB1c2UgPGRpdiA6c3R5bGU9XCJ2YWxcIj4uJyxcbiAgICAgICAgICBlbC5yYXdBdHRyc01hcFsnc3R5bGUnXVxuICAgICAgICApO1xuICAgICAgfVxuICAgIH1cbiAgICBlbC5zdGF0aWNTdHlsZSA9IEpTT04uc3RyaW5naWZ5KHBhcnNlU3R5bGVUZXh0KHN0YXRpY1N0eWxlKSk7XG4gIH1cblxuICB2YXIgc3R5bGVCaW5kaW5nID0gZ2V0QmluZGluZ0F0dHIoZWwsICdzdHlsZScsIGZhbHNlIC8qIGdldFN0YXRpYyAqLyk7XG4gIGlmIChzdHlsZUJpbmRpbmcpIHtcbiAgICBlbC5zdHlsZUJpbmRpbmcgPSBzdHlsZUJpbmRpbmc7XG4gIH1cbn1cblxuZnVuY3Rpb24gZ2VuRGF0YSQxIChlbCkge1xuICB2YXIgZGF0YSA9ICcnO1xuICBpZiAoZWwuc3RhdGljU3R5bGUpIHtcbiAgICBkYXRhICs9IFwic3RhdGljU3R5bGU6XCIgKyAoZWwuc3RhdGljU3R5bGUpICsgXCIsXCI7XG4gIH1cbiAgaWYgKGVsLnN0eWxlQmluZGluZykge1xuICAgIGRhdGEgKz0gXCJzdHlsZTooXCIgKyAoZWwuc3R5bGVCaW5kaW5nKSArIFwiKSxcIjtcbiAgfVxuICByZXR1cm4gZGF0YVxufVxuXG52YXIgc3R5bGUkMSA9IHtcbiAgc3RhdGljS2V5czogWydzdGF0aWNTdHlsZSddLFxuICB0cmFuc2Zvcm1Ob2RlOiB0cmFuc2Zvcm1Ob2RlJDEsXG4gIGdlbkRhdGE6IGdlbkRhdGEkMVxufTtcblxuLyogICovXG5cbnZhciBkZWNvZGVyO1xuXG52YXIgaGUgPSB7XG4gIGRlY29kZTogZnVuY3Rpb24gZGVjb2RlIChodG1sKSB7XG4gICAgZGVjb2RlciA9IGRlY29kZXIgfHwgZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgZGVjb2Rlci5pbm5lckhUTUwgPSBodG1sO1xuICAgIHJldHVybiBkZWNvZGVyLnRleHRDb250ZW50XG4gIH1cbn07XG5cbi8qICAqL1xuXG52YXIgaXNVbmFyeVRhZyA9IG1ha2VNYXAoXG4gICdhcmVhLGJhc2UsYnIsY29sLGVtYmVkLGZyYW1lLGhyLGltZyxpbnB1dCxpc2luZGV4LGtleWdlbiwnICtcbiAgJ2xpbmssbWV0YSxwYXJhbSxzb3VyY2UsdHJhY2ssd2JyJ1xuKTtcblxuLy8gRWxlbWVudHMgdGhhdCB5b3UgY2FuLCBpbnRlbnRpb25hbGx5LCBsZWF2ZSBvcGVuXG4vLyAoYW5kIHdoaWNoIGNsb3NlIHRoZW1zZWx2ZXMpXG52YXIgY2FuQmVMZWZ0T3BlblRhZyA9IG1ha2VNYXAoXG4gICdjb2xncm91cCxkZCxkdCxsaSxvcHRpb25zLHAsdGQsdGZvb3QsdGgsdGhlYWQsdHIsc291cmNlJ1xuKTtcblxuLy8gSFRNTDUgdGFncyBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9pbmRpY2VzLmh0bWwjZWxlbWVudHMtM1xuLy8gUGhyYXNpbmcgQ29udGVudCBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9kb20uaHRtbCNwaHJhc2luZy1jb250ZW50XG52YXIgaXNOb25QaHJhc2luZ1RhZyA9IG1ha2VNYXAoXG4gICdhZGRyZXNzLGFydGljbGUsYXNpZGUsYmFzZSxibG9ja3F1b3RlLGJvZHksY2FwdGlvbixjb2wsY29sZ3JvdXAsZGQsJyArXG4gICdkZXRhaWxzLGRpYWxvZyxkaXYsZGwsZHQsZmllbGRzZXQsZmlnY2FwdGlvbixmaWd1cmUsZm9vdGVyLGZvcm0sJyArXG4gICdoMSxoMixoMyxoNCxoNSxoNixoZWFkLGhlYWRlcixoZ3JvdXAsaHIsaHRtbCxsZWdlbmQsbGksbWVudWl0ZW0sbWV0YSwnICtcbiAgJ29wdGdyb3VwLG9wdGlvbixwYXJhbSxycCxydCxzb3VyY2Usc3R5bGUsc3VtbWFyeSx0Ym9keSx0ZCx0Zm9vdCx0aCx0aGVhZCwnICtcbiAgJ3RpdGxlLHRyLHRyYWNrJ1xuKTtcblxuLyoqXG4gKiBOb3QgdHlwZS1jaGVja2luZyB0aGlzIGZpbGUgYmVjYXVzZSBpdCdzIG1vc3RseSB2ZW5kb3IgY29kZS5cbiAqL1xuXG4vLyBSZWd1bGFyIEV4cHJlc3Npb25zIGZvciBwYXJzaW5nIHRhZ3MgYW5kIGF0dHJpYnV0ZXNcbnZhciBhdHRyaWJ1dGUgPSAvXlxccyooW15cXHNcIic8PlxcLz1dKykoPzpcXHMqKD0pXFxzKig/OlwiKFteXCJdKilcIit8JyhbXiddKiknK3woW15cXHNcIic9PD5gXSspKSk/LztcbnZhciBkeW5hbWljQXJnQXR0cmlidXRlID0gL15cXHMqKCg/OnYtW1xcdy1dKzp8QHw6fCMpXFxbW149XSs/XFxdW15cXHNcIic8PlxcLz1dKikoPzpcXHMqKD0pXFxzKig/OlwiKFteXCJdKilcIit8JyhbXiddKiknK3woW15cXHNcIic9PD5gXSspKSk/LztcbnZhciBuY25hbWUgPSBcIlthLXpBLVpfXVtcXFxcLVxcXFwuMC05X2EtekEtWlwiICsgKHVuaWNvZGVSZWdFeHAuc291cmNlKSArIFwiXSpcIjtcbnZhciBxbmFtZUNhcHR1cmUgPSBcIigoPzpcIiArIG5jbmFtZSArIFwiXFxcXDopP1wiICsgbmNuYW1lICsgXCIpXCI7XG52YXIgc3RhcnRUYWdPcGVuID0gbmV3IFJlZ0V4cCgoXCJePFwiICsgcW5hbWVDYXB0dXJlKSk7XG52YXIgc3RhcnRUYWdDbG9zZSA9IC9eXFxzKihcXC8/KT4vO1xudmFyIGVuZFRhZyA9IG5ldyBSZWdFeHAoKFwiXjxcXFxcL1wiICsgcW5hbWVDYXB0dXJlICsgXCJbXj5dKj5cIikpO1xudmFyIGRvY3R5cGUgPSAvXjwhRE9DVFlQRSBbXj5dKz4vaTtcbi8vICM3Mjk4OiBlc2NhcGUgLSB0byBhdm9pZCBiZWluZyBwYXNzZWQgYXMgSFRNTCBjb21tZW50IHdoZW4gaW5saW5lZCBpbiBwYWdlXG52YXIgY29tbWVudCA9IC9ePCFcXC0tLztcbnZhciBjb25kaXRpb25hbENvbW1lbnQgPSAvXjwhXFxbLztcblxuLy8gU3BlY2lhbCBFbGVtZW50cyAoY2FuIGNvbnRhaW4gYW55dGhpbmcpXG52YXIgaXNQbGFpblRleHRFbGVtZW50ID0gbWFrZU1hcCgnc2NyaXB0LHN0eWxlLHRleHRhcmVhJywgdHJ1ZSk7XG52YXIgcmVDYWNoZSA9IHt9O1xuXG52YXIgZGVjb2RpbmdNYXAgPSB7XG4gICcmbHQ7JzogJzwnLFxuICAnJmd0Oyc6ICc+JyxcbiAgJyZxdW90Oyc6ICdcIicsXG4gICcmYW1wOyc6ICcmJyxcbiAgJyYjMTA7JzogJ1xcbicsXG4gICcmIzk7JzogJ1xcdCcsXG4gICcmIzM5Oyc6IFwiJ1wiXG59O1xudmFyIGVuY29kZWRBdHRyID0gLyYoPzpsdHxndHxxdW90fGFtcHwjMzkpOy9nO1xudmFyIGVuY29kZWRBdHRyV2l0aE5ld0xpbmVzID0gLyYoPzpsdHxndHxxdW90fGFtcHwjMzl8IzEwfCM5KTsvZztcblxuLy8gIzU5OTJcbnZhciBpc0lnbm9yZU5ld2xpbmVUYWcgPSBtYWtlTWFwKCdwcmUsdGV4dGFyZWEnLCB0cnVlKTtcbnZhciBzaG91bGRJZ25vcmVGaXJzdE5ld2xpbmUgPSBmdW5jdGlvbiAodGFnLCBodG1sKSB7IHJldHVybiB0YWcgJiYgaXNJZ25vcmVOZXdsaW5lVGFnKHRhZykgJiYgaHRtbFswXSA9PT0gJ1xcbic7IH07XG5cbmZ1bmN0aW9uIGRlY29kZUF0dHIgKHZhbHVlLCBzaG91bGREZWNvZGVOZXdsaW5lcykge1xuICB2YXIgcmUgPSBzaG91bGREZWNvZGVOZXdsaW5lcyA/IGVuY29kZWRBdHRyV2l0aE5ld0xpbmVzIDogZW5jb2RlZEF0dHI7XG4gIHJldHVybiB2YWx1ZS5yZXBsYWNlKHJlLCBmdW5jdGlvbiAobWF0Y2gpIHsgcmV0dXJuIGRlY29kaW5nTWFwW21hdGNoXTsgfSlcbn1cblxuZnVuY3Rpb24gcGFyc2VIVE1MIChodG1sLCBvcHRpb25zKSB7XG4gIHZhciBzdGFjayA9IFtdO1xuICB2YXIgZXhwZWN0SFRNTCA9IG9wdGlvbnMuZXhwZWN0SFRNTDtcbiAgdmFyIGlzVW5hcnlUYWckJDEgPSBvcHRpb25zLmlzVW5hcnlUYWcgfHwgbm87XG4gIHZhciBjYW5CZUxlZnRPcGVuVGFnJCQxID0gb3B0aW9ucy5jYW5CZUxlZnRPcGVuVGFnIHx8IG5vO1xuICB2YXIgaW5kZXggPSAwO1xuICB2YXIgbGFzdCwgbGFzdFRhZztcbiAgd2hpbGUgKGh0bWwpIHtcbiAgICBsYXN0ID0gaHRtbDtcbiAgICAvLyBNYWtlIHN1cmUgd2UncmUgbm90IGluIGEgcGxhaW50ZXh0IGNvbnRlbnQgZWxlbWVudCBsaWtlIHNjcmlwdC9zdHlsZVxuICAgIGlmICghbGFzdFRhZyB8fCAhaXNQbGFpblRleHRFbGVtZW50KGxhc3RUYWcpKSB7XG4gICAgICB2YXIgdGV4dEVuZCA9IGh0bWwuaW5kZXhPZignPCcpO1xuICAgICAgaWYgKHRleHRFbmQgPT09IDApIHtcbiAgICAgICAgLy8gQ29tbWVudDpcbiAgICAgICAgaWYgKGNvbW1lbnQudGVzdChodG1sKSkge1xuICAgICAgICAgIHZhciBjb21tZW50RW5kID0gaHRtbC5pbmRleE9mKCctLT4nKTtcblxuICAgICAgICAgIGlmIChjb21tZW50RW5kID49IDApIHtcbiAgICAgICAgICAgIGlmIChvcHRpb25zLnNob3VsZEtlZXBDb21tZW50KSB7XG4gICAgICAgICAgICAgIG9wdGlvbnMuY29tbWVudChodG1sLnN1YnN0cmluZyg0LCBjb21tZW50RW5kKSwgaW5kZXgsIGluZGV4ICsgY29tbWVudEVuZCArIDMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYWR2YW5jZShjb21tZW50RW5kICsgMyk7XG4gICAgICAgICAgICBjb250aW51ZVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGh0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvQ29uZGl0aW9uYWxfY29tbWVudCNEb3dubGV2ZWwtcmV2ZWFsZWRfY29uZGl0aW9uYWxfY29tbWVudFxuICAgICAgICBpZiAoY29uZGl0aW9uYWxDb21tZW50LnRlc3QoaHRtbCkpIHtcbiAgICAgICAgICB2YXIgY29uZGl0aW9uYWxFbmQgPSBodG1sLmluZGV4T2YoJ10+Jyk7XG5cbiAgICAgICAgICBpZiAoY29uZGl0aW9uYWxFbmQgPj0gMCkge1xuICAgICAgICAgICAgYWR2YW5jZShjb25kaXRpb25hbEVuZCArIDIpO1xuICAgICAgICAgICAgY29udGludWVcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBEb2N0eXBlOlxuICAgICAgICB2YXIgZG9jdHlwZU1hdGNoID0gaHRtbC5tYXRjaChkb2N0eXBlKTtcbiAgICAgICAgaWYgKGRvY3R5cGVNYXRjaCkge1xuICAgICAgICAgIGFkdmFuY2UoZG9jdHlwZU1hdGNoWzBdLmxlbmd0aCk7XG4gICAgICAgICAgY29udGludWVcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEVuZCB0YWc6XG4gICAgICAgIHZhciBlbmRUYWdNYXRjaCA9IGh0bWwubWF0Y2goZW5kVGFnKTtcbiAgICAgICAgaWYgKGVuZFRhZ01hdGNoKSB7XG4gICAgICAgICAgdmFyIGN1ckluZGV4ID0gaW5kZXg7XG4gICAgICAgICAgYWR2YW5jZShlbmRUYWdNYXRjaFswXS5sZW5ndGgpO1xuICAgICAgICAgIHBhcnNlRW5kVGFnKGVuZFRhZ01hdGNoWzFdLCBjdXJJbmRleCwgaW5kZXgpO1xuICAgICAgICAgIGNvbnRpbnVlXG4gICAgICAgIH1cblxuICAgICAgICAvLyBTdGFydCB0YWc6XG4gICAgICAgIHZhciBzdGFydFRhZ01hdGNoID0gcGFyc2VTdGFydFRhZygpO1xuICAgICAgICBpZiAoc3RhcnRUYWdNYXRjaCkge1xuICAgICAgICAgIGhhbmRsZVN0YXJ0VGFnKHN0YXJ0VGFnTWF0Y2gpO1xuICAgICAgICAgIGlmIChzaG91bGRJZ25vcmVGaXJzdE5ld2xpbmUoc3RhcnRUYWdNYXRjaC50YWdOYW1lLCBodG1sKSkge1xuICAgICAgICAgICAgYWR2YW5jZSgxKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgY29udGludWVcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB2YXIgdGV4dCA9ICh2b2lkIDApLCByZXN0ID0gKHZvaWQgMCksIG5leHQgPSAodm9pZCAwKTtcbiAgICAgIGlmICh0ZXh0RW5kID49IDApIHtcbiAgICAgICAgcmVzdCA9IGh0bWwuc2xpY2UodGV4dEVuZCk7XG4gICAgICAgIHdoaWxlIChcbiAgICAgICAgICAhZW5kVGFnLnRlc3QocmVzdCkgJiZcbiAgICAgICAgICAhc3RhcnRUYWdPcGVuLnRlc3QocmVzdCkgJiZcbiAgICAgICAgICAhY29tbWVudC50ZXN0KHJlc3QpICYmXG4gICAgICAgICAgIWNvbmRpdGlvbmFsQ29tbWVudC50ZXN0KHJlc3QpXG4gICAgICAgICkge1xuICAgICAgICAgIC8vIDwgaW4gcGxhaW4gdGV4dCwgYmUgZm9yZ2l2aW5nIGFuZCB0cmVhdCBpdCBhcyB0ZXh0XG4gICAgICAgICAgbmV4dCA9IHJlc3QuaW5kZXhPZignPCcsIDEpO1xuICAgICAgICAgIGlmIChuZXh0IDwgMCkgeyBicmVhayB9XG4gICAgICAgICAgdGV4dEVuZCArPSBuZXh0O1xuICAgICAgICAgIHJlc3QgPSBodG1sLnNsaWNlKHRleHRFbmQpO1xuICAgICAgICB9XG4gICAgICAgIHRleHQgPSBodG1sLnN1YnN0cmluZygwLCB0ZXh0RW5kKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHRleHRFbmQgPCAwKSB7XG4gICAgICAgIHRleHQgPSBodG1sO1xuICAgICAgfVxuXG4gICAgICBpZiAodGV4dCkge1xuICAgICAgICBhZHZhbmNlKHRleHQubGVuZ3RoKTtcbiAgICAgIH1cblxuICAgICAgaWYgKG9wdGlvbnMuY2hhcnMgJiYgdGV4dCkge1xuICAgICAgICBvcHRpb25zLmNoYXJzKHRleHQsIGluZGV4IC0gdGV4dC5sZW5ndGgsIGluZGV4KTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIGVuZFRhZ0xlbmd0aCA9IDA7XG4gICAgICB2YXIgc3RhY2tlZFRhZyA9IGxhc3RUYWcudG9Mb3dlckNhc2UoKTtcbiAgICAgIHZhciByZVN0YWNrZWRUYWcgPSByZUNhY2hlW3N0YWNrZWRUYWddIHx8IChyZUNhY2hlW3N0YWNrZWRUYWddID0gbmV3IFJlZ0V4cCgnKFtcXFxcc1xcXFxTXSo/KSg8LycgKyBzdGFja2VkVGFnICsgJ1tePl0qPiknLCAnaScpKTtcbiAgICAgIHZhciByZXN0JDEgPSBodG1sLnJlcGxhY2UocmVTdGFja2VkVGFnLCBmdW5jdGlvbiAoYWxsLCB0ZXh0LCBlbmRUYWcpIHtcbiAgICAgICAgZW5kVGFnTGVuZ3RoID0gZW5kVGFnLmxlbmd0aDtcbiAgICAgICAgaWYgKCFpc1BsYWluVGV4dEVsZW1lbnQoc3RhY2tlZFRhZykgJiYgc3RhY2tlZFRhZyAhPT0gJ25vc2NyaXB0Jykge1xuICAgICAgICAgIHRleHQgPSB0ZXh0XG4gICAgICAgICAgICAucmVwbGFjZSgvPCFcXC0tKFtcXHNcXFNdKj8pLS0+L2csICckMScpIC8vICM3Mjk4XG4gICAgICAgICAgICAucmVwbGFjZSgvPCFcXFtDREFUQVxcWyhbXFxzXFxTXSo/KV1dPi9nLCAnJDEnKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc2hvdWxkSWdub3JlRmlyc3ROZXdsaW5lKHN0YWNrZWRUYWcsIHRleHQpKSB7XG4gICAgICAgICAgdGV4dCA9IHRleHQuc2xpY2UoMSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9wdGlvbnMuY2hhcnMpIHtcbiAgICAgICAgICBvcHRpb25zLmNoYXJzKHRleHQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAnJ1xuICAgICAgfSk7XG4gICAgICBpbmRleCArPSBodG1sLmxlbmd0aCAtIHJlc3QkMS5sZW5ndGg7XG4gICAgICBodG1sID0gcmVzdCQxO1xuICAgICAgcGFyc2VFbmRUYWcoc3RhY2tlZFRhZywgaW5kZXggLSBlbmRUYWdMZW5ndGgsIGluZGV4KTtcbiAgICB9XG5cbiAgICBpZiAoaHRtbCA9PT0gbGFzdCkge1xuICAgICAgb3B0aW9ucy5jaGFycyAmJiBvcHRpb25zLmNoYXJzKGh0bWwpO1xuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgIXN0YWNrLmxlbmd0aCAmJiBvcHRpb25zLndhcm4pIHtcbiAgICAgICAgb3B0aW9ucy53YXJuKChcIk1hbC1mb3JtYXR0ZWQgdGFnIGF0IGVuZCBvZiB0ZW1wbGF0ZTogXFxcIlwiICsgaHRtbCArIFwiXFxcIlwiKSwgeyBzdGFydDogaW5kZXggKyBodG1sLmxlbmd0aCB9KTtcbiAgICAgIH1cbiAgICAgIGJyZWFrXG4gICAgfVxuICB9XG5cbiAgLy8gQ2xlYW4gdXAgYW55IHJlbWFpbmluZyB0YWdzXG4gIHBhcnNlRW5kVGFnKCk7XG5cbiAgZnVuY3Rpb24gYWR2YW5jZSAobikge1xuICAgIGluZGV4ICs9IG47XG4gICAgaHRtbCA9IGh0bWwuc3Vic3RyaW5nKG4pO1xuICB9XG5cbiAgZnVuY3Rpb24gcGFyc2VTdGFydFRhZyAoKSB7XG4gICAgdmFyIHN0YXJ0ID0gaHRtbC5tYXRjaChzdGFydFRhZ09wZW4pO1xuICAgIGlmIChzdGFydCkge1xuICAgICAgdmFyIG1hdGNoID0ge1xuICAgICAgICB0YWdOYW1lOiBzdGFydFsxXSxcbiAgICAgICAgYXR0cnM6IFtdLFxuICAgICAgICBzdGFydDogaW5kZXhcbiAgICAgIH07XG4gICAgICBhZHZhbmNlKHN0YXJ0WzBdLmxlbmd0aCk7XG4gICAgICB2YXIgZW5kLCBhdHRyO1xuICAgICAgd2hpbGUgKCEoZW5kID0gaHRtbC5tYXRjaChzdGFydFRhZ0Nsb3NlKSkgJiYgKGF0dHIgPSBodG1sLm1hdGNoKGR5bmFtaWNBcmdBdHRyaWJ1dGUpIHx8IGh0bWwubWF0Y2goYXR0cmlidXRlKSkpIHtcbiAgICAgICAgYXR0ci5zdGFydCA9IGluZGV4O1xuICAgICAgICBhZHZhbmNlKGF0dHJbMF0ubGVuZ3RoKTtcbiAgICAgICAgYXR0ci5lbmQgPSBpbmRleDtcbiAgICAgICAgbWF0Y2guYXR0cnMucHVzaChhdHRyKTtcbiAgICAgIH1cbiAgICAgIGlmIChlbmQpIHtcbiAgICAgICAgbWF0Y2gudW5hcnlTbGFzaCA9IGVuZFsxXTtcbiAgICAgICAgYWR2YW5jZShlbmRbMF0ubGVuZ3RoKTtcbiAgICAgICAgbWF0Y2guZW5kID0gaW5kZXg7XG4gICAgICAgIHJldHVybiBtYXRjaFxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGhhbmRsZVN0YXJ0VGFnIChtYXRjaCkge1xuICAgIHZhciB0YWdOYW1lID0gbWF0Y2gudGFnTmFtZTtcbiAgICB2YXIgdW5hcnlTbGFzaCA9IG1hdGNoLnVuYXJ5U2xhc2g7XG5cbiAgICBpZiAoZXhwZWN0SFRNTCkge1xuICAgICAgaWYgKGxhc3RUYWcgPT09ICdwJyAmJiBpc05vblBocmFzaW5nVGFnKHRhZ05hbWUpKSB7XG4gICAgICAgIHBhcnNlRW5kVGFnKGxhc3RUYWcpO1xuICAgICAgfVxuICAgICAgaWYgKGNhbkJlTGVmdE9wZW5UYWckJDEodGFnTmFtZSkgJiYgbGFzdFRhZyA9PT0gdGFnTmFtZSkge1xuICAgICAgICBwYXJzZUVuZFRhZyh0YWdOYW1lKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgdW5hcnkgPSBpc1VuYXJ5VGFnJCQxKHRhZ05hbWUpIHx8ICEhdW5hcnlTbGFzaDtcblxuICAgIHZhciBsID0gbWF0Y2guYXR0cnMubGVuZ3RoO1xuICAgIHZhciBhdHRycyA9IG5ldyBBcnJheShsKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGw7IGkrKykge1xuICAgICAgdmFyIGFyZ3MgPSBtYXRjaC5hdHRyc1tpXTtcbiAgICAgIHZhciB2YWx1ZSA9IGFyZ3NbM10gfHwgYXJnc1s0XSB8fCBhcmdzWzVdIHx8ICcnO1xuICAgICAgdmFyIHNob3VsZERlY29kZU5ld2xpbmVzID0gdGFnTmFtZSA9PT0gJ2EnICYmIGFyZ3NbMV0gPT09ICdocmVmJ1xuICAgICAgICA/IG9wdGlvbnMuc2hvdWxkRGVjb2RlTmV3bGluZXNGb3JIcmVmXG4gICAgICAgIDogb3B0aW9ucy5zaG91bGREZWNvZGVOZXdsaW5lcztcbiAgICAgIGF0dHJzW2ldID0ge1xuICAgICAgICBuYW1lOiBhcmdzWzFdLFxuICAgICAgICB2YWx1ZTogZGVjb2RlQXR0cih2YWx1ZSwgc2hvdWxkRGVjb2RlTmV3bGluZXMpXG4gICAgICB9O1xuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgb3B0aW9ucy5vdXRwdXRTb3VyY2VSYW5nZSkge1xuICAgICAgICBhdHRyc1tpXS5zdGFydCA9IGFyZ3Muc3RhcnQgKyBhcmdzWzBdLm1hdGNoKC9eXFxzKi8pLmxlbmd0aDtcbiAgICAgICAgYXR0cnNbaV0uZW5kID0gYXJncy5lbmQ7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKCF1bmFyeSkge1xuICAgICAgc3RhY2sucHVzaCh7IHRhZzogdGFnTmFtZSwgbG93ZXJDYXNlZFRhZzogdGFnTmFtZS50b0xvd2VyQ2FzZSgpLCBhdHRyczogYXR0cnMsIHN0YXJ0OiBtYXRjaC5zdGFydCwgZW5kOiBtYXRjaC5lbmQgfSk7XG4gICAgICBsYXN0VGFnID0gdGFnTmFtZTtcbiAgICB9XG5cbiAgICBpZiAob3B0aW9ucy5zdGFydCkge1xuICAgICAgb3B0aW9ucy5zdGFydCh0YWdOYW1lLCBhdHRycywgdW5hcnksIG1hdGNoLnN0YXJ0LCBtYXRjaC5lbmQpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHBhcnNlRW5kVGFnICh0YWdOYW1lLCBzdGFydCwgZW5kKSB7XG4gICAgdmFyIHBvcywgbG93ZXJDYXNlZFRhZ05hbWU7XG4gICAgaWYgKHN0YXJ0ID09IG51bGwpIHsgc3RhcnQgPSBpbmRleDsgfVxuICAgIGlmIChlbmQgPT0gbnVsbCkgeyBlbmQgPSBpbmRleDsgfVxuXG4gICAgLy8gRmluZCB0aGUgY2xvc2VzdCBvcGVuZWQgdGFnIG9mIHRoZSBzYW1lIHR5cGVcbiAgICBpZiAodGFnTmFtZSkge1xuICAgICAgbG93ZXJDYXNlZFRhZ05hbWUgPSB0YWdOYW1lLnRvTG93ZXJDYXNlKCk7XG4gICAgICBmb3IgKHBvcyA9IHN0YWNrLmxlbmd0aCAtIDE7IHBvcyA+PSAwOyBwb3MtLSkge1xuICAgICAgICBpZiAoc3RhY2tbcG9zXS5sb3dlckNhc2VkVGFnID09PSBsb3dlckNhc2VkVGFnTmFtZSkge1xuICAgICAgICAgIGJyZWFrXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gSWYgbm8gdGFnIG5hbWUgaXMgcHJvdmlkZWQsIGNsZWFuIHNob3BcbiAgICAgIHBvcyA9IDA7XG4gICAgfVxuXG4gICAgaWYgKHBvcyA+PSAwKSB7XG4gICAgICAvLyBDbG9zZSBhbGwgdGhlIG9wZW4gZWxlbWVudHMsIHVwIHRoZSBzdGFja1xuICAgICAgZm9yICh2YXIgaSA9IHN0YWNrLmxlbmd0aCAtIDE7IGkgPj0gcG9zOyBpLS0pIHtcbiAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiZcbiAgICAgICAgICAoaSA+IHBvcyB8fCAhdGFnTmFtZSkgJiZcbiAgICAgICAgICBvcHRpb25zLndhcm5cbiAgICAgICAgKSB7XG4gICAgICAgICAgb3B0aW9ucy53YXJuKFxuICAgICAgICAgICAgKFwidGFnIDxcIiArIChzdGFja1tpXS50YWcpICsgXCI+IGhhcyBubyBtYXRjaGluZyBlbmQgdGFnLlwiKSxcbiAgICAgICAgICAgIHsgc3RhcnQ6IHN0YWNrW2ldLnN0YXJ0LCBlbmQ6IHN0YWNrW2ldLmVuZCB9XG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAob3B0aW9ucy5lbmQpIHtcbiAgICAgICAgICBvcHRpb25zLmVuZChzdGFja1tpXS50YWcsIHN0YXJ0LCBlbmQpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIFJlbW92ZSB0aGUgb3BlbiBlbGVtZW50cyBmcm9tIHRoZSBzdGFja1xuICAgICAgc3RhY2subGVuZ3RoID0gcG9zO1xuICAgICAgbGFzdFRhZyA9IHBvcyAmJiBzdGFja1twb3MgLSAxXS50YWc7XG4gICAgfSBlbHNlIGlmIChsb3dlckNhc2VkVGFnTmFtZSA9PT0gJ2JyJykge1xuICAgICAgaWYgKG9wdGlvbnMuc3RhcnQpIHtcbiAgICAgICAgb3B0aW9ucy5zdGFydCh0YWdOYW1lLCBbXSwgdHJ1ZSwgc3RhcnQsIGVuZCk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChsb3dlckNhc2VkVGFnTmFtZSA9PT0gJ3AnKSB7XG4gICAgICBpZiAob3B0aW9ucy5zdGFydCkge1xuICAgICAgICBvcHRpb25zLnN0YXJ0KHRhZ05hbWUsIFtdLCBmYWxzZSwgc3RhcnQsIGVuZCk7XG4gICAgICB9XG4gICAgICBpZiAob3B0aW9ucy5lbmQpIHtcbiAgICAgICAgb3B0aW9ucy5lbmQodGFnTmFtZSwgc3RhcnQsIGVuZCk7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbi8qICAqL1xuXG52YXIgb25SRSA9IC9eQHxedi1vbjovO1xudmFyIGRpclJFID0gL152LXxeQHxeOnxeIy87XG52YXIgZm9yQWxpYXNSRSA9IC8oW1xcc1xcU10qPylcXHMrKD86aW58b2YpXFxzKyhbXFxzXFxTXSopLztcbnZhciBmb3JJdGVyYXRvclJFID0gLywoW14sXFx9XFxdXSopKD86LChbXixcXH1cXF1dKikpPyQvO1xudmFyIHN0cmlwUGFyZW5zUkUgPSAvXlxcKHxcXCkkL2c7XG52YXIgZHluYW1pY0FyZ1JFID0gL15cXFsuKlxcXSQvO1xuXG52YXIgYXJnUkUgPSAvOiguKikkLztcbnZhciBiaW5kUkUgPSAvXjp8XlxcLnxedi1iaW5kOi87XG52YXIgbW9kaWZpZXJSRSA9IC9cXC5bXi5cXF1dKyg/PVteXFxdXSokKS9nO1xuXG52YXIgc2xvdFJFID0gL152LXNsb3QoOnwkKXxeIy87XG5cbnZhciBsaW5lQnJlYWtSRSA9IC9bXFxyXFxuXS87XG52YXIgd2hpdGVzcGFjZVJFJDEgPSAvWyBcXGZcXHRcXHJcXG5dKy9nO1xuXG52YXIgaW52YWxpZEF0dHJpYnV0ZVJFID0gL1tcXHNcIic8PlxcLz1dLztcblxudmFyIGRlY29kZUhUTUxDYWNoZWQgPSBjYWNoZWQoaGUuZGVjb2RlKTtcblxudmFyIGVtcHR5U2xvdFNjb3BlVG9rZW4gPSBcIl9lbXB0eV9cIjtcblxuLy8gY29uZmlndXJhYmxlIHN0YXRlXG52YXIgd2FybiQyO1xudmFyIGRlbGltaXRlcnM7XG52YXIgdHJhbnNmb3JtcztcbnZhciBwcmVUcmFuc2Zvcm1zO1xudmFyIHBvc3RUcmFuc2Zvcm1zO1xudmFyIHBsYXRmb3JtSXNQcmVUYWc7XG52YXIgcGxhdGZvcm1NdXN0VXNlUHJvcDtcbnZhciBwbGF0Zm9ybUdldFRhZ05hbWVzcGFjZTtcbnZhciBtYXliZUNvbXBvbmVudDtcblxuZnVuY3Rpb24gY3JlYXRlQVNURWxlbWVudCAoXG4gIHRhZyxcbiAgYXR0cnMsXG4gIHBhcmVudFxuKSB7XG4gIHJldHVybiB7XG4gICAgdHlwZTogMSxcbiAgICB0YWc6IHRhZyxcbiAgICBhdHRyc0xpc3Q6IGF0dHJzLFxuICAgIGF0dHJzTWFwOiBtYWtlQXR0cnNNYXAoYXR0cnMpLFxuICAgIHJhd0F0dHJzTWFwOiB7fSxcbiAgICBwYXJlbnQ6IHBhcmVudCxcbiAgICBjaGlsZHJlbjogW11cbiAgfVxufVxuXG4vKipcbiAqIENvbnZlcnQgSFRNTCBzdHJpbmcgdG8gQVNULlxuICovXG5mdW5jdGlvbiBwYXJzZSAoXG4gIHRlbXBsYXRlLFxuICBvcHRpb25zXG4pIHtcbiAgd2FybiQyID0gb3B0aW9ucy53YXJuIHx8IGJhc2VXYXJuO1xuXG4gIHBsYXRmb3JtSXNQcmVUYWcgPSBvcHRpb25zLmlzUHJlVGFnIHx8IG5vO1xuICBwbGF0Zm9ybU11c3RVc2VQcm9wID0gb3B0aW9ucy5tdXN0VXNlUHJvcCB8fCBubztcbiAgcGxhdGZvcm1HZXRUYWdOYW1lc3BhY2UgPSBvcHRpb25zLmdldFRhZ05hbWVzcGFjZSB8fCBubztcbiAgdmFyIGlzUmVzZXJ2ZWRUYWcgPSBvcHRpb25zLmlzUmVzZXJ2ZWRUYWcgfHwgbm87XG4gIG1heWJlQ29tcG9uZW50ID0gZnVuY3Rpb24gKGVsKSB7IHJldHVybiAhIShcbiAgICBlbC5jb21wb25lbnQgfHxcbiAgICBlbC5hdHRyc01hcFsnOmlzJ10gfHxcbiAgICBlbC5hdHRyc01hcFsndi1iaW5kOmlzJ10gfHxcbiAgICAhKGVsLmF0dHJzTWFwLmlzID8gaXNSZXNlcnZlZFRhZyhlbC5hdHRyc01hcC5pcykgOiBpc1Jlc2VydmVkVGFnKGVsLnRhZykpXG4gICk7IH07XG4gIHRyYW5zZm9ybXMgPSBwbHVja01vZHVsZUZ1bmN0aW9uKG9wdGlvbnMubW9kdWxlcywgJ3RyYW5zZm9ybU5vZGUnKTtcbiAgcHJlVHJhbnNmb3JtcyA9IHBsdWNrTW9kdWxlRnVuY3Rpb24ob3B0aW9ucy5tb2R1bGVzLCAncHJlVHJhbnNmb3JtTm9kZScpO1xuICBwb3N0VHJhbnNmb3JtcyA9IHBsdWNrTW9kdWxlRnVuY3Rpb24ob3B0aW9ucy5tb2R1bGVzLCAncG9zdFRyYW5zZm9ybU5vZGUnKTtcblxuICBkZWxpbWl0ZXJzID0gb3B0aW9ucy5kZWxpbWl0ZXJzO1xuXG4gIHZhciBzdGFjayA9IFtdO1xuICB2YXIgcHJlc2VydmVXaGl0ZXNwYWNlID0gb3B0aW9ucy5wcmVzZXJ2ZVdoaXRlc3BhY2UgIT09IGZhbHNlO1xuICB2YXIgd2hpdGVzcGFjZU9wdGlvbiA9IG9wdGlvbnMud2hpdGVzcGFjZTtcbiAgdmFyIHJvb3Q7XG4gIHZhciBjdXJyZW50UGFyZW50O1xuICB2YXIgaW5WUHJlID0gZmFsc2U7XG4gIHZhciBpblByZSA9IGZhbHNlO1xuICB2YXIgd2FybmVkID0gZmFsc2U7XG5cbiAgZnVuY3Rpb24gd2Fybk9uY2UgKG1zZywgcmFuZ2UpIHtcbiAgICBpZiAoIXdhcm5lZCkge1xuICAgICAgd2FybmVkID0gdHJ1ZTtcbiAgICAgIHdhcm4kMihtc2csIHJhbmdlKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBjbG9zZUVsZW1lbnQgKGVsZW1lbnQpIHtcbiAgICB0cmltRW5kaW5nV2hpdGVzcGFjZShlbGVtZW50KTtcbiAgICBpZiAoIWluVlByZSAmJiAhZWxlbWVudC5wcm9jZXNzZWQpIHtcbiAgICAgIGVsZW1lbnQgPSBwcm9jZXNzRWxlbWVudChlbGVtZW50LCBvcHRpb25zKTtcbiAgICB9XG4gICAgLy8gdHJlZSBtYW5hZ2VtZW50XG4gICAgaWYgKCFzdGFjay5sZW5ndGggJiYgZWxlbWVudCAhPT0gcm9vdCkge1xuICAgICAgLy8gYWxsb3cgcm9vdCBlbGVtZW50cyB3aXRoIHYtaWYsIHYtZWxzZS1pZiBhbmQgdi1lbHNlXG4gICAgICBpZiAocm9vdC5pZiAmJiAoZWxlbWVudC5lbHNlaWYgfHwgZWxlbWVudC5lbHNlKSkge1xuICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICAgIGNoZWNrUm9vdENvbnN0cmFpbnRzKGVsZW1lbnQpO1xuICAgICAgICB9XG4gICAgICAgIGFkZElmQ29uZGl0aW9uKHJvb3QsIHtcbiAgICAgICAgICBleHA6IGVsZW1lbnQuZWxzZWlmLFxuICAgICAgICAgIGJsb2NrOiBlbGVtZW50XG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgIHdhcm5PbmNlKFxuICAgICAgICAgIFwiQ29tcG9uZW50IHRlbXBsYXRlIHNob3VsZCBjb250YWluIGV4YWN0bHkgb25lIHJvb3QgZWxlbWVudC4gXCIgK1xuICAgICAgICAgIFwiSWYgeW91IGFyZSB1c2luZyB2LWlmIG9uIG11bHRpcGxlIGVsZW1lbnRzLCBcIiArXG4gICAgICAgICAgXCJ1c2Ugdi1lbHNlLWlmIHRvIGNoYWluIHRoZW0gaW5zdGVhZC5cIixcbiAgICAgICAgICB7IHN0YXJ0OiBlbGVtZW50LnN0YXJ0IH1cbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGN1cnJlbnRQYXJlbnQgJiYgIWVsZW1lbnQuZm9yYmlkZGVuKSB7XG4gICAgICBpZiAoZWxlbWVudC5lbHNlaWYgfHwgZWxlbWVudC5lbHNlKSB7XG4gICAgICAgIHByb2Nlc3NJZkNvbmRpdGlvbnMoZWxlbWVudCwgY3VycmVudFBhcmVudCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoZWxlbWVudC5zbG90U2NvcGUpIHtcbiAgICAgICAgICAvLyBzY29wZWQgc2xvdFxuICAgICAgICAgIC8vIGtlZXAgaXQgaW4gdGhlIGNoaWxkcmVuIGxpc3Qgc28gdGhhdCB2LWVsc2UoLWlmKSBjb25kaXRpb25zIGNhblxuICAgICAgICAgIC8vIGZpbmQgaXQgYXMgdGhlIHByZXYgbm9kZS5cbiAgICAgICAgICB2YXIgbmFtZSA9IGVsZW1lbnQuc2xvdFRhcmdldCB8fCAnXCJkZWZhdWx0XCInXG4gICAgICAgICAgOyhjdXJyZW50UGFyZW50LnNjb3BlZFNsb3RzIHx8IChjdXJyZW50UGFyZW50LnNjb3BlZFNsb3RzID0ge30pKVtuYW1lXSA9IGVsZW1lbnQ7XG4gICAgICAgIH1cbiAgICAgICAgY3VycmVudFBhcmVudC5jaGlsZHJlbi5wdXNoKGVsZW1lbnQpO1xuICAgICAgICBlbGVtZW50LnBhcmVudCA9IGN1cnJlbnRQYXJlbnQ7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gZmluYWwgY2hpbGRyZW4gY2xlYW51cFxuICAgIC8vIGZpbHRlciBvdXQgc2NvcGVkIHNsb3RzXG4gICAgZWxlbWVudC5jaGlsZHJlbiA9IGVsZW1lbnQuY2hpbGRyZW4uZmlsdGVyKGZ1bmN0aW9uIChjKSB7IHJldHVybiAhKGMpLnNsb3RTY29wZTsgfSk7XG4gICAgLy8gcmVtb3ZlIHRyYWlsaW5nIHdoaXRlc3BhY2Ugbm9kZSBhZ2FpblxuICAgIHRyaW1FbmRpbmdXaGl0ZXNwYWNlKGVsZW1lbnQpO1xuXG4gICAgLy8gY2hlY2sgcHJlIHN0YXRlXG4gICAgaWYgKGVsZW1lbnQucHJlKSB7XG4gICAgICBpblZQcmUgPSBmYWxzZTtcbiAgICB9XG4gICAgaWYgKHBsYXRmb3JtSXNQcmVUYWcoZWxlbWVudC50YWcpKSB7XG4gICAgICBpblByZSA9IGZhbHNlO1xuICAgIH1cbiAgICAvLyBhcHBseSBwb3N0LXRyYW5zZm9ybXNcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHBvc3RUcmFuc2Zvcm1zLmxlbmd0aDsgaSsrKSB7XG4gICAgICBwb3N0VHJhbnNmb3Jtc1tpXShlbGVtZW50LCBvcHRpb25zKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiB0cmltRW5kaW5nV2hpdGVzcGFjZSAoZWwpIHtcbiAgICAvLyByZW1vdmUgdHJhaWxpbmcgd2hpdGVzcGFjZSBub2RlXG4gICAgaWYgKCFpblByZSkge1xuICAgICAgdmFyIGxhc3ROb2RlO1xuICAgICAgd2hpbGUgKFxuICAgICAgICAobGFzdE5vZGUgPSBlbC5jaGlsZHJlbltlbC5jaGlsZHJlbi5sZW5ndGggLSAxXSkgJiZcbiAgICAgICAgbGFzdE5vZGUudHlwZSA9PT0gMyAmJlxuICAgICAgICBsYXN0Tm9kZS50ZXh0ID09PSAnICdcbiAgICAgICkge1xuICAgICAgICBlbC5jaGlsZHJlbi5wb3AoKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBjaGVja1Jvb3RDb25zdHJhaW50cyAoZWwpIHtcbiAgICBpZiAoZWwudGFnID09PSAnc2xvdCcgfHwgZWwudGFnID09PSAndGVtcGxhdGUnKSB7XG4gICAgICB3YXJuT25jZShcbiAgICAgICAgXCJDYW5ub3QgdXNlIDxcIiArIChlbC50YWcpICsgXCI+IGFzIGNvbXBvbmVudCByb290IGVsZW1lbnQgYmVjYXVzZSBpdCBtYXkgXCIgK1xuICAgICAgICAnY29udGFpbiBtdWx0aXBsZSBub2Rlcy4nLFxuICAgICAgICB7IHN0YXJ0OiBlbC5zdGFydCB9XG4gICAgICApO1xuICAgIH1cbiAgICBpZiAoZWwuYXR0cnNNYXAuaGFzT3duUHJvcGVydHkoJ3YtZm9yJykpIHtcbiAgICAgIHdhcm5PbmNlKFxuICAgICAgICAnQ2Fubm90IHVzZSB2LWZvciBvbiBzdGF0ZWZ1bCBjb21wb25lbnQgcm9vdCBlbGVtZW50IGJlY2F1c2UgJyArXG4gICAgICAgICdpdCByZW5kZXJzIG11bHRpcGxlIGVsZW1lbnRzLicsXG4gICAgICAgIGVsLnJhd0F0dHJzTWFwWyd2LWZvciddXG4gICAgICApO1xuICAgIH1cbiAgfVxuXG4gIHBhcnNlSFRNTCh0ZW1wbGF0ZSwge1xuICAgIHdhcm46IHdhcm4kMixcbiAgICBleHBlY3RIVE1MOiBvcHRpb25zLmV4cGVjdEhUTUwsXG4gICAgaXNVbmFyeVRhZzogb3B0aW9ucy5pc1VuYXJ5VGFnLFxuICAgIGNhbkJlTGVmdE9wZW5UYWc6IG9wdGlvbnMuY2FuQmVMZWZ0T3BlblRhZyxcbiAgICBzaG91bGREZWNvZGVOZXdsaW5lczogb3B0aW9ucy5zaG91bGREZWNvZGVOZXdsaW5lcyxcbiAgICBzaG91bGREZWNvZGVOZXdsaW5lc0ZvckhyZWY6IG9wdGlvbnMuc2hvdWxkRGVjb2RlTmV3bGluZXNGb3JIcmVmLFxuICAgIHNob3VsZEtlZXBDb21tZW50OiBvcHRpb25zLmNvbW1lbnRzLFxuICAgIG91dHB1dFNvdXJjZVJhbmdlOiBvcHRpb25zLm91dHB1dFNvdXJjZVJhbmdlLFxuICAgIHN0YXJ0OiBmdW5jdGlvbiBzdGFydCAodGFnLCBhdHRycywgdW5hcnksIHN0YXJ0JDEsIGVuZCkge1xuICAgICAgLy8gY2hlY2sgbmFtZXNwYWNlLlxuICAgICAgLy8gaW5oZXJpdCBwYXJlbnQgbnMgaWYgdGhlcmUgaXMgb25lXG4gICAgICB2YXIgbnMgPSAoY3VycmVudFBhcmVudCAmJiBjdXJyZW50UGFyZW50Lm5zKSB8fCBwbGF0Zm9ybUdldFRhZ05hbWVzcGFjZSh0YWcpO1xuXG4gICAgICAvLyBoYW5kbGUgSUUgc3ZnIGJ1Z1xuICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICBpZiAoaXNJRSAmJiBucyA9PT0gJ3N2ZycpIHtcbiAgICAgICAgYXR0cnMgPSBndWFyZElFU1ZHQnVnKGF0dHJzKTtcbiAgICAgIH1cblxuICAgICAgdmFyIGVsZW1lbnQgPSBjcmVhdGVBU1RFbGVtZW50KHRhZywgYXR0cnMsIGN1cnJlbnRQYXJlbnQpO1xuICAgICAgaWYgKG5zKSB7XG4gICAgICAgIGVsZW1lbnQubnMgPSBucztcbiAgICAgIH1cblxuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgaWYgKG9wdGlvbnMub3V0cHV0U291cmNlUmFuZ2UpIHtcbiAgICAgICAgICBlbGVtZW50LnN0YXJ0ID0gc3RhcnQkMTtcbiAgICAgICAgICBlbGVtZW50LmVuZCA9IGVuZDtcbiAgICAgICAgICBlbGVtZW50LnJhd0F0dHJzTWFwID0gZWxlbWVudC5hdHRyc0xpc3QucmVkdWNlKGZ1bmN0aW9uIChjdW11bGF0ZWQsIGF0dHIpIHtcbiAgICAgICAgICAgIGN1bXVsYXRlZFthdHRyLm5hbWVdID0gYXR0cjtcbiAgICAgICAgICAgIHJldHVybiBjdW11bGF0ZWRcbiAgICAgICAgICB9LCB7fSk7XG4gICAgICAgIH1cbiAgICAgICAgYXR0cnMuZm9yRWFjaChmdW5jdGlvbiAoYXR0cikge1xuICAgICAgICAgIGlmIChpbnZhbGlkQXR0cmlidXRlUkUudGVzdChhdHRyLm5hbWUpKSB7XG4gICAgICAgICAgICB3YXJuJDIoXG4gICAgICAgICAgICAgIFwiSW52YWxpZCBkeW5hbWljIGFyZ3VtZW50IGV4cHJlc3Npb246IGF0dHJpYnV0ZSBuYW1lcyBjYW5ub3QgY29udGFpbiBcIiArXG4gICAgICAgICAgICAgIFwic3BhY2VzLCBxdW90ZXMsIDwsID4sIC8gb3IgPS5cIixcbiAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHN0YXJ0OiBhdHRyLnN0YXJ0ICsgYXR0ci5uYW1lLmluZGV4T2YoXCJbXCIpLFxuICAgICAgICAgICAgICAgIGVuZDogYXR0ci5zdGFydCArIGF0dHIubmFtZS5sZW5ndGhcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICBpZiAoaXNGb3JiaWRkZW5UYWcoZWxlbWVudCkgJiYgIWlzU2VydmVyUmVuZGVyaW5nKCkpIHtcbiAgICAgICAgZWxlbWVudC5mb3JiaWRkZW4gPSB0cnVlO1xuICAgICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIHdhcm4kMihcbiAgICAgICAgICAnVGVtcGxhdGVzIHNob3VsZCBvbmx5IGJlIHJlc3BvbnNpYmxlIGZvciBtYXBwaW5nIHRoZSBzdGF0ZSB0byB0aGUgJyArXG4gICAgICAgICAgJ1VJLiBBdm9pZCBwbGFjaW5nIHRhZ3Mgd2l0aCBzaWRlLWVmZmVjdHMgaW4geW91ciB0ZW1wbGF0ZXMsIHN1Y2ggYXMgJyArXG4gICAgICAgICAgXCI8XCIgKyB0YWcgKyBcIj5cIiArICcsIGFzIHRoZXkgd2lsbCBub3QgYmUgcGFyc2VkLicsXG4gICAgICAgICAgeyBzdGFydDogZWxlbWVudC5zdGFydCB9XG4gICAgICAgICk7XG4gICAgICB9XG5cbiAgICAgIC8vIGFwcGx5IHByZS10cmFuc2Zvcm1zXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHByZVRyYW5zZm9ybXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgZWxlbWVudCA9IHByZVRyYW5zZm9ybXNbaV0oZWxlbWVudCwgb3B0aW9ucykgfHwgZWxlbWVudDtcbiAgICAgIH1cblxuICAgICAgaWYgKCFpblZQcmUpIHtcbiAgICAgICAgcHJvY2Vzc1ByZShlbGVtZW50KTtcbiAgICAgICAgaWYgKGVsZW1lbnQucHJlKSB7XG4gICAgICAgICAgaW5WUHJlID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKHBsYXRmb3JtSXNQcmVUYWcoZWxlbWVudC50YWcpKSB7XG4gICAgICAgIGluUHJlID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIGlmIChpblZQcmUpIHtcbiAgICAgICAgcHJvY2Vzc1Jhd0F0dHJzKGVsZW1lbnQpO1xuICAgICAgfSBlbHNlIGlmICghZWxlbWVudC5wcm9jZXNzZWQpIHtcbiAgICAgICAgLy8gc3RydWN0dXJhbCBkaXJlY3RpdmVzXG4gICAgICAgIHByb2Nlc3NGb3IoZWxlbWVudCk7XG4gICAgICAgIHByb2Nlc3NJZihlbGVtZW50KTtcbiAgICAgICAgcHJvY2Vzc09uY2UoZWxlbWVudCk7XG4gICAgICB9XG5cbiAgICAgIGlmICghcm9vdCkge1xuICAgICAgICByb290ID0gZWxlbWVudDtcbiAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgICBjaGVja1Jvb3RDb25zdHJhaW50cyhyb290KTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoIXVuYXJ5KSB7XG4gICAgICAgIGN1cnJlbnRQYXJlbnQgPSBlbGVtZW50O1xuICAgICAgICBzdGFjay5wdXNoKGVsZW1lbnQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY2xvc2VFbGVtZW50KGVsZW1lbnQpO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICBlbmQ6IGZ1bmN0aW9uIGVuZCAodGFnLCBzdGFydCwgZW5kJDEpIHtcbiAgICAgIHZhciBlbGVtZW50ID0gc3RhY2tbc3RhY2subGVuZ3RoIC0gMV07XG4gICAgICAvLyBwb3Agc3RhY2tcbiAgICAgIHN0YWNrLmxlbmd0aCAtPSAxO1xuICAgICAgY3VycmVudFBhcmVudCA9IHN0YWNrW3N0YWNrLmxlbmd0aCAtIDFdO1xuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgb3B0aW9ucy5vdXRwdXRTb3VyY2VSYW5nZSkge1xuICAgICAgICBlbGVtZW50LmVuZCA9IGVuZCQxO1xuICAgICAgfVxuICAgICAgY2xvc2VFbGVtZW50KGVsZW1lbnQpO1xuICAgIH0sXG5cbiAgICBjaGFyczogZnVuY3Rpb24gY2hhcnMgKHRleHQsIHN0YXJ0LCBlbmQpIHtcbiAgICAgIGlmICghY3VycmVudFBhcmVudCkge1xuICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICAgIGlmICh0ZXh0ID09PSB0ZW1wbGF0ZSkge1xuICAgICAgICAgICAgd2Fybk9uY2UoXG4gICAgICAgICAgICAgICdDb21wb25lbnQgdGVtcGxhdGUgcmVxdWlyZXMgYSByb290IGVsZW1lbnQsIHJhdGhlciB0aGFuIGp1c3QgdGV4dC4nLFxuICAgICAgICAgICAgICB7IHN0YXJ0OiBzdGFydCB9XG4gICAgICAgICAgICApO1xuICAgICAgICAgIH0gZWxzZSBpZiAoKHRleHQgPSB0ZXh0LnRyaW0oKSkpIHtcbiAgICAgICAgICAgIHdhcm5PbmNlKFxuICAgICAgICAgICAgICAoXCJ0ZXh0IFxcXCJcIiArIHRleHQgKyBcIlxcXCIgb3V0c2lkZSByb290IGVsZW1lbnQgd2lsbCBiZSBpZ25vcmVkLlwiKSxcbiAgICAgICAgICAgICAgeyBzdGFydDogc3RhcnQgfVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG4gICAgICAvLyBJRSB0ZXh0YXJlYSBwbGFjZWhvbGRlciBidWdcbiAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgaWYgKGlzSUUgJiZcbiAgICAgICAgY3VycmVudFBhcmVudC50YWcgPT09ICd0ZXh0YXJlYScgJiZcbiAgICAgICAgY3VycmVudFBhcmVudC5hdHRyc01hcC5wbGFjZWhvbGRlciA9PT0gdGV4dFxuICAgICAgKSB7XG4gICAgICAgIHJldHVyblxuICAgICAgfVxuICAgICAgdmFyIGNoaWxkcmVuID0gY3VycmVudFBhcmVudC5jaGlsZHJlbjtcbiAgICAgIGlmIChpblByZSB8fCB0ZXh0LnRyaW0oKSkge1xuICAgICAgICB0ZXh0ID0gaXNUZXh0VGFnKGN1cnJlbnRQYXJlbnQpID8gdGV4dCA6IGRlY29kZUhUTUxDYWNoZWQodGV4dCk7XG4gICAgICB9IGVsc2UgaWYgKCFjaGlsZHJlbi5sZW5ndGgpIHtcbiAgICAgICAgLy8gcmVtb3ZlIHRoZSB3aGl0ZXNwYWNlLW9ubHkgbm9kZSByaWdodCBhZnRlciBhbiBvcGVuaW5nIHRhZ1xuICAgICAgICB0ZXh0ID0gJyc7XG4gICAgICB9IGVsc2UgaWYgKHdoaXRlc3BhY2VPcHRpb24pIHtcbiAgICAgICAgaWYgKHdoaXRlc3BhY2VPcHRpb24gPT09ICdjb25kZW5zZScpIHtcbiAgICAgICAgICAvLyBpbiBjb25kZW5zZSBtb2RlLCByZW1vdmUgdGhlIHdoaXRlc3BhY2Ugbm9kZSBpZiBpdCBjb250YWluc1xuICAgICAgICAgIC8vIGxpbmUgYnJlYWssIG90aGVyd2lzZSBjb25kZW5zZSB0byBhIHNpbmdsZSBzcGFjZVxuICAgICAgICAgIHRleHQgPSBsaW5lQnJlYWtSRS50ZXN0KHRleHQpID8gJycgOiAnICc7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGV4dCA9ICcgJztcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGV4dCA9IHByZXNlcnZlV2hpdGVzcGFjZSA/ICcgJyA6ICcnO1xuICAgICAgfVxuICAgICAgaWYgKHRleHQpIHtcbiAgICAgICAgaWYgKCFpblByZSAmJiB3aGl0ZXNwYWNlT3B0aW9uID09PSAnY29uZGVuc2UnKSB7XG4gICAgICAgICAgLy8gY29uZGVuc2UgY29uc2VjdXRpdmUgd2hpdGVzcGFjZXMgaW50byBzaW5nbGUgc3BhY2VcbiAgICAgICAgICB0ZXh0ID0gdGV4dC5yZXBsYWNlKHdoaXRlc3BhY2VSRSQxLCAnICcpO1xuICAgICAgICB9XG4gICAgICAgIHZhciByZXM7XG4gICAgICAgIHZhciBjaGlsZDtcbiAgICAgICAgaWYgKCFpblZQcmUgJiYgdGV4dCAhPT0gJyAnICYmIChyZXMgPSBwYXJzZVRleHQodGV4dCwgZGVsaW1pdGVycykpKSB7XG4gICAgICAgICAgY2hpbGQgPSB7XG4gICAgICAgICAgICB0eXBlOiAyLFxuICAgICAgICAgICAgZXhwcmVzc2lvbjogcmVzLmV4cHJlc3Npb24sXG4gICAgICAgICAgICB0b2tlbnM6IHJlcy50b2tlbnMsXG4gICAgICAgICAgICB0ZXh0OiB0ZXh0XG4gICAgICAgICAgfTtcbiAgICAgICAgfSBlbHNlIGlmICh0ZXh0ICE9PSAnICcgfHwgIWNoaWxkcmVuLmxlbmd0aCB8fCBjaGlsZHJlbltjaGlsZHJlbi5sZW5ndGggLSAxXS50ZXh0ICE9PSAnICcpIHtcbiAgICAgICAgICBjaGlsZCA9IHtcbiAgICAgICAgICAgIHR5cGU6IDMsXG4gICAgICAgICAgICB0ZXh0OiB0ZXh0XG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY2hpbGQpIHtcbiAgICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiBvcHRpb25zLm91dHB1dFNvdXJjZVJhbmdlKSB7XG4gICAgICAgICAgICBjaGlsZC5zdGFydCA9IHN0YXJ0O1xuICAgICAgICAgICAgY2hpbGQuZW5kID0gZW5kO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjaGlsZHJlbi5wdXNoKGNoaWxkKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG4gICAgY29tbWVudDogZnVuY3Rpb24gY29tbWVudCAodGV4dCwgc3RhcnQsIGVuZCkge1xuICAgICAgLy8gYWRkaW5nIGFueXRoaW5nIGFzIGEgc2libGluZyB0byB0aGUgcm9vdCBub2RlIGlzIGZvcmJpZGRlblxuICAgICAgLy8gY29tbWVudHMgc2hvdWxkIHN0aWxsIGJlIGFsbG93ZWQsIGJ1dCBpZ25vcmVkXG4gICAgICBpZiAoY3VycmVudFBhcmVudCkge1xuICAgICAgICB2YXIgY2hpbGQgPSB7XG4gICAgICAgICAgdHlwZTogMyxcbiAgICAgICAgICB0ZXh0OiB0ZXh0LFxuICAgICAgICAgIGlzQ29tbWVudDogdHJ1ZVxuICAgICAgICB9O1xuICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiBvcHRpb25zLm91dHB1dFNvdXJjZVJhbmdlKSB7XG4gICAgICAgICAgY2hpbGQuc3RhcnQgPSBzdGFydDtcbiAgICAgICAgICBjaGlsZC5lbmQgPSBlbmQ7XG4gICAgICAgIH1cbiAgICAgICAgY3VycmVudFBhcmVudC5jaGlsZHJlbi5wdXNoKGNoaWxkKTtcbiAgICAgIH1cbiAgICB9XG4gIH0pO1xuICByZXR1cm4gcm9vdFxufVxuXG5mdW5jdGlvbiBwcm9jZXNzUHJlIChlbCkge1xuICBpZiAoZ2V0QW5kUmVtb3ZlQXR0cihlbCwgJ3YtcHJlJykgIT0gbnVsbCkge1xuICAgIGVsLnByZSA9IHRydWU7XG4gIH1cbn1cblxuZnVuY3Rpb24gcHJvY2Vzc1Jhd0F0dHJzIChlbCkge1xuICB2YXIgbGlzdCA9IGVsLmF0dHJzTGlzdDtcbiAgdmFyIGxlbiA9IGxpc3QubGVuZ3RoO1xuICBpZiAobGVuKSB7XG4gICAgdmFyIGF0dHJzID0gZWwuYXR0cnMgPSBuZXcgQXJyYXkobGVuKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICBhdHRyc1tpXSA9IHtcbiAgICAgICAgbmFtZTogbGlzdFtpXS5uYW1lLFxuICAgICAgICB2YWx1ZTogSlNPTi5zdHJpbmdpZnkobGlzdFtpXS52YWx1ZSlcbiAgICAgIH07XG4gICAgICBpZiAobGlzdFtpXS5zdGFydCAhPSBudWxsKSB7XG4gICAgICAgIGF0dHJzW2ldLnN0YXJ0ID0gbGlzdFtpXS5zdGFydDtcbiAgICAgICAgYXR0cnNbaV0uZW5kID0gbGlzdFtpXS5lbmQ7XG4gICAgICB9XG4gICAgfVxuICB9IGVsc2UgaWYgKCFlbC5wcmUpIHtcbiAgICAvLyBub24gcm9vdCBub2RlIGluIHByZSBibG9ja3Mgd2l0aCBubyBhdHRyaWJ1dGVzXG4gICAgZWwucGxhaW4gPSB0cnVlO1xuICB9XG59XG5cbmZ1bmN0aW9uIHByb2Nlc3NFbGVtZW50IChcbiAgZWxlbWVudCxcbiAgb3B0aW9uc1xuKSB7XG4gIHByb2Nlc3NLZXkoZWxlbWVudCk7XG5cbiAgLy8gZGV0ZXJtaW5lIHdoZXRoZXIgdGhpcyBpcyBhIHBsYWluIGVsZW1lbnQgYWZ0ZXJcbiAgLy8gcmVtb3Zpbmcgc3RydWN0dXJhbCBhdHRyaWJ1dGVzXG4gIGVsZW1lbnQucGxhaW4gPSAoXG4gICAgIWVsZW1lbnQua2V5ICYmXG4gICAgIWVsZW1lbnQuc2NvcGVkU2xvdHMgJiZcbiAgICAhZWxlbWVudC5hdHRyc0xpc3QubGVuZ3RoXG4gICk7XG5cbiAgcHJvY2Vzc1JlZihlbGVtZW50KTtcbiAgcHJvY2Vzc1Nsb3RDb250ZW50KGVsZW1lbnQpO1xuICBwcm9jZXNzU2xvdE91dGxldChlbGVtZW50KTtcbiAgcHJvY2Vzc0NvbXBvbmVudChlbGVtZW50KTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCB0cmFuc2Zvcm1zLmxlbmd0aDsgaSsrKSB7XG4gICAgZWxlbWVudCA9IHRyYW5zZm9ybXNbaV0oZWxlbWVudCwgb3B0aW9ucykgfHwgZWxlbWVudDtcbiAgfVxuICBwcm9jZXNzQXR0cnMoZWxlbWVudCk7XG4gIHJldHVybiBlbGVtZW50XG59XG5cbmZ1bmN0aW9uIHByb2Nlc3NLZXkgKGVsKSB7XG4gIHZhciBleHAgPSBnZXRCaW5kaW5nQXR0cihlbCwgJ2tleScpO1xuICBpZiAoZXhwKSB7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIGlmIChlbC50YWcgPT09ICd0ZW1wbGF0ZScpIHtcbiAgICAgICAgd2FybiQyKFxuICAgICAgICAgIFwiPHRlbXBsYXRlPiBjYW5ub3QgYmUga2V5ZWQuIFBsYWNlIHRoZSBrZXkgb24gcmVhbCBlbGVtZW50cyBpbnN0ZWFkLlwiLFxuICAgICAgICAgIGdldFJhd0JpbmRpbmdBdHRyKGVsLCAna2V5JylcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIGlmIChlbC5mb3IpIHtcbiAgICAgICAgdmFyIGl0ZXJhdG9yID0gZWwuaXRlcmF0b3IyIHx8IGVsLml0ZXJhdG9yMTtcbiAgICAgICAgdmFyIHBhcmVudCA9IGVsLnBhcmVudDtcbiAgICAgICAgaWYgKGl0ZXJhdG9yICYmIGl0ZXJhdG9yID09PSBleHAgJiYgcGFyZW50ICYmIHBhcmVudC50YWcgPT09ICd0cmFuc2l0aW9uLWdyb3VwJykge1xuICAgICAgICAgIHdhcm4kMihcbiAgICAgICAgICAgIFwiRG8gbm90IHVzZSB2LWZvciBpbmRleCBhcyBrZXkgb24gPHRyYW5zaXRpb24tZ3JvdXA+IGNoaWxkcmVuLCBcIiArXG4gICAgICAgICAgICBcInRoaXMgaXMgdGhlIHNhbWUgYXMgbm90IHVzaW5nIGtleXMuXCIsXG4gICAgICAgICAgICBnZXRSYXdCaW5kaW5nQXR0cihlbCwgJ2tleScpLFxuICAgICAgICAgICAgdHJ1ZSAvKiB0aXAgKi9cbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGVsLmtleSA9IGV4cDtcbiAgfVxufVxuXG5mdW5jdGlvbiBwcm9jZXNzUmVmIChlbCkge1xuICB2YXIgcmVmID0gZ2V0QmluZGluZ0F0dHIoZWwsICdyZWYnKTtcbiAgaWYgKHJlZikge1xuICAgIGVsLnJlZiA9IHJlZjtcbiAgICBlbC5yZWZJbkZvciA9IGNoZWNrSW5Gb3IoZWwpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHByb2Nlc3NGb3IgKGVsKSB7XG4gIHZhciBleHA7XG4gIGlmICgoZXhwID0gZ2V0QW5kUmVtb3ZlQXR0cihlbCwgJ3YtZm9yJykpKSB7XG4gICAgdmFyIHJlcyA9IHBhcnNlRm9yKGV4cCk7XG4gICAgaWYgKHJlcykge1xuICAgICAgZXh0ZW5kKGVsLCByZXMpO1xuICAgIH0gZWxzZSBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgd2FybiQyKFxuICAgICAgICAoXCJJbnZhbGlkIHYtZm9yIGV4cHJlc3Npb246IFwiICsgZXhwKSxcbiAgICAgICAgZWwucmF3QXR0cnNNYXBbJ3YtZm9yJ11cbiAgICAgICk7XG4gICAgfVxuICB9XG59XG5cblxuXG5mdW5jdGlvbiBwYXJzZUZvciAoZXhwKSB7XG4gIHZhciBpbk1hdGNoID0gZXhwLm1hdGNoKGZvckFsaWFzUkUpO1xuICBpZiAoIWluTWF0Y2gpIHsgcmV0dXJuIH1cbiAgdmFyIHJlcyA9IHt9O1xuICByZXMuZm9yID0gaW5NYXRjaFsyXS50cmltKCk7XG4gIHZhciBhbGlhcyA9IGluTWF0Y2hbMV0udHJpbSgpLnJlcGxhY2Uoc3RyaXBQYXJlbnNSRSwgJycpO1xuICB2YXIgaXRlcmF0b3JNYXRjaCA9IGFsaWFzLm1hdGNoKGZvckl0ZXJhdG9yUkUpO1xuICBpZiAoaXRlcmF0b3JNYXRjaCkge1xuICAgIHJlcy5hbGlhcyA9IGFsaWFzLnJlcGxhY2UoZm9ySXRlcmF0b3JSRSwgJycpLnRyaW0oKTtcbiAgICByZXMuaXRlcmF0b3IxID0gaXRlcmF0b3JNYXRjaFsxXS50cmltKCk7XG4gICAgaWYgKGl0ZXJhdG9yTWF0Y2hbMl0pIHtcbiAgICAgIHJlcy5pdGVyYXRvcjIgPSBpdGVyYXRvck1hdGNoWzJdLnRyaW0oKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgcmVzLmFsaWFzID0gYWxpYXM7XG4gIH1cbiAgcmV0dXJuIHJlc1xufVxuXG5mdW5jdGlvbiBwcm9jZXNzSWYgKGVsKSB7XG4gIHZhciBleHAgPSBnZXRBbmRSZW1vdmVBdHRyKGVsLCAndi1pZicpO1xuICBpZiAoZXhwKSB7XG4gICAgZWwuaWYgPSBleHA7XG4gICAgYWRkSWZDb25kaXRpb24oZWwsIHtcbiAgICAgIGV4cDogZXhwLFxuICAgICAgYmxvY2s6IGVsXG4gICAgfSk7XG4gIH0gZWxzZSB7XG4gICAgaWYgKGdldEFuZFJlbW92ZUF0dHIoZWwsICd2LWVsc2UnKSAhPSBudWxsKSB7XG4gICAgICBlbC5lbHNlID0gdHJ1ZTtcbiAgICB9XG4gICAgdmFyIGVsc2VpZiA9IGdldEFuZFJlbW92ZUF0dHIoZWwsICd2LWVsc2UtaWYnKTtcbiAgICBpZiAoZWxzZWlmKSB7XG4gICAgICBlbC5lbHNlaWYgPSBlbHNlaWY7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHByb2Nlc3NJZkNvbmRpdGlvbnMgKGVsLCBwYXJlbnQpIHtcbiAgdmFyIHByZXYgPSBmaW5kUHJldkVsZW1lbnQocGFyZW50LmNoaWxkcmVuKTtcbiAgaWYgKHByZXYgJiYgcHJldi5pZikge1xuICAgIGFkZElmQ29uZGl0aW9uKHByZXYsIHtcbiAgICAgIGV4cDogZWwuZWxzZWlmLFxuICAgICAgYmxvY2s6IGVsXG4gICAgfSk7XG4gIH0gZWxzZSBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIHdhcm4kMihcbiAgICAgIFwidi1cIiArIChlbC5lbHNlaWYgPyAoJ2Vsc2UtaWY9XCInICsgZWwuZWxzZWlmICsgJ1wiJykgOiAnZWxzZScpICsgXCIgXCIgK1xuICAgICAgXCJ1c2VkIG9uIGVsZW1lbnQgPFwiICsgKGVsLnRhZykgKyBcIj4gd2l0aG91dCBjb3JyZXNwb25kaW5nIHYtaWYuXCIsXG4gICAgICBlbC5yYXdBdHRyc01hcFtlbC5lbHNlaWYgPyAndi1lbHNlLWlmJyA6ICd2LWVsc2UnXVxuICAgICk7XG4gIH1cbn1cblxuZnVuY3Rpb24gZmluZFByZXZFbGVtZW50IChjaGlsZHJlbikge1xuICB2YXIgaSA9IGNoaWxkcmVuLmxlbmd0aDtcbiAgd2hpbGUgKGktLSkge1xuICAgIGlmIChjaGlsZHJlbltpXS50eXBlID09PSAxKSB7XG4gICAgICByZXR1cm4gY2hpbGRyZW5baV1cbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgY2hpbGRyZW5baV0udGV4dCAhPT0gJyAnKSB7XG4gICAgICAgIHdhcm4kMihcbiAgICAgICAgICBcInRleHQgXFxcIlwiICsgKGNoaWxkcmVuW2ldLnRleHQudHJpbSgpKSArIFwiXFxcIiBiZXR3ZWVuIHYtaWYgYW5kIHYtZWxzZSgtaWYpIFwiICtcbiAgICAgICAgICBcIndpbGwgYmUgaWdub3JlZC5cIixcbiAgICAgICAgICBjaGlsZHJlbltpXVxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgY2hpbGRyZW4ucG9wKCk7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGFkZElmQ29uZGl0aW9uIChlbCwgY29uZGl0aW9uKSB7XG4gIGlmICghZWwuaWZDb25kaXRpb25zKSB7XG4gICAgZWwuaWZDb25kaXRpb25zID0gW107XG4gIH1cbiAgZWwuaWZDb25kaXRpb25zLnB1c2goY29uZGl0aW9uKTtcbn1cblxuZnVuY3Rpb24gcHJvY2Vzc09uY2UgKGVsKSB7XG4gIHZhciBvbmNlJCQxID0gZ2V0QW5kUmVtb3ZlQXR0cihlbCwgJ3Ytb25jZScpO1xuICBpZiAob25jZSQkMSAhPSBudWxsKSB7XG4gICAgZWwub25jZSA9IHRydWU7XG4gIH1cbn1cblxuLy8gaGFuZGxlIGNvbnRlbnQgYmVpbmcgcGFzc2VkIHRvIGEgY29tcG9uZW50IGFzIHNsb3QsXG4vLyBlLmcuIDx0ZW1wbGF0ZSBzbG90PVwieHh4XCI+LCA8ZGl2IHNsb3Qtc2NvcGU9XCJ4eHhcIj5cbmZ1bmN0aW9uIHByb2Nlc3NTbG90Q29udGVudCAoZWwpIHtcbiAgdmFyIHNsb3RTY29wZTtcbiAgaWYgKGVsLnRhZyA9PT0gJ3RlbXBsYXRlJykge1xuICAgIHNsb3RTY29wZSA9IGdldEFuZFJlbW92ZUF0dHIoZWwsICdzY29wZScpO1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIHNsb3RTY29wZSkge1xuICAgICAgd2FybiQyKFxuICAgICAgICBcInRoZSBcXFwic2NvcGVcXFwiIGF0dHJpYnV0ZSBmb3Igc2NvcGVkIHNsb3RzIGhhdmUgYmVlbiBkZXByZWNhdGVkIGFuZCBcIiArXG4gICAgICAgIFwicmVwbGFjZWQgYnkgXFxcInNsb3Qtc2NvcGVcXFwiIHNpbmNlIDIuNS4gVGhlIG5ldyBcXFwic2xvdC1zY29wZVxcXCIgYXR0cmlidXRlIFwiICtcbiAgICAgICAgXCJjYW4gYWxzbyBiZSB1c2VkIG9uIHBsYWluIGVsZW1lbnRzIGluIGFkZGl0aW9uIHRvIDx0ZW1wbGF0ZT4gdG8gXCIgK1xuICAgICAgICBcImRlbm90ZSBzY29wZWQgc2xvdHMuXCIsXG4gICAgICAgIGVsLnJhd0F0dHJzTWFwWydzY29wZSddLFxuICAgICAgICB0cnVlXG4gICAgICApO1xuICAgIH1cbiAgICBlbC5zbG90U2NvcGUgPSBzbG90U2NvcGUgfHwgZ2V0QW5kUmVtb3ZlQXR0cihlbCwgJ3Nsb3Qtc2NvcGUnKTtcbiAgfSBlbHNlIGlmICgoc2xvdFNjb3BlID0gZ2V0QW5kUmVtb3ZlQXR0cihlbCwgJ3Nsb3Qtc2NvcGUnKSkpIHtcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiBlbC5hdHRyc01hcFsndi1mb3InXSkge1xuICAgICAgd2FybiQyKFxuICAgICAgICBcIkFtYmlndW91cyBjb21iaW5lZCB1c2FnZSBvZiBzbG90LXNjb3BlIGFuZCB2LWZvciBvbiA8XCIgKyAoZWwudGFnKSArIFwiPiBcIiArXG4gICAgICAgIFwiKHYtZm9yIHRha2VzIGhpZ2hlciBwcmlvcml0eSkuIFVzZSBhIHdyYXBwZXIgPHRlbXBsYXRlPiBmb3IgdGhlIFwiICtcbiAgICAgICAgXCJzY29wZWQgc2xvdCB0byBtYWtlIGl0IGNsZWFyZXIuXCIsXG4gICAgICAgIGVsLnJhd0F0dHJzTWFwWydzbG90LXNjb3BlJ10sXG4gICAgICAgIHRydWVcbiAgICAgICk7XG4gICAgfVxuICAgIGVsLnNsb3RTY29wZSA9IHNsb3RTY29wZTtcbiAgfVxuXG4gIC8vIHNsb3Q9XCJ4eHhcIlxuICB2YXIgc2xvdFRhcmdldCA9IGdldEJpbmRpbmdBdHRyKGVsLCAnc2xvdCcpO1xuICBpZiAoc2xvdFRhcmdldCkge1xuICAgIGVsLnNsb3RUYXJnZXQgPSBzbG90VGFyZ2V0ID09PSAnXCJcIicgPyAnXCJkZWZhdWx0XCInIDogc2xvdFRhcmdldDtcbiAgICBlbC5zbG90VGFyZ2V0RHluYW1pYyA9ICEhKGVsLmF0dHJzTWFwWyc6c2xvdCddIHx8IGVsLmF0dHJzTWFwWyd2LWJpbmQ6c2xvdCddKTtcbiAgICAvLyBwcmVzZXJ2ZSBzbG90IGFzIGFuIGF0dHJpYnV0ZSBmb3IgbmF0aXZlIHNoYWRvdyBET00gY29tcGF0XG4gICAgLy8gb25seSBmb3Igbm9uLXNjb3BlZCBzbG90cy5cbiAgICBpZiAoZWwudGFnICE9PSAndGVtcGxhdGUnICYmICFlbC5zbG90U2NvcGUpIHtcbiAgICAgIGFkZEF0dHIoZWwsICdzbG90Jywgc2xvdFRhcmdldCwgZ2V0UmF3QmluZGluZ0F0dHIoZWwsICdzbG90JykpO1xuICAgIH1cbiAgfVxuXG4gIC8vIDIuNiB2LXNsb3Qgc3ludGF4XG4gIHtcbiAgICBpZiAoZWwudGFnID09PSAndGVtcGxhdGUnKSB7XG4gICAgICAvLyB2LXNsb3Qgb24gPHRlbXBsYXRlPlxuICAgICAgdmFyIHNsb3RCaW5kaW5nID0gZ2V0QW5kUmVtb3ZlQXR0ckJ5UmVnZXgoZWwsIHNsb3RSRSk7XG4gICAgICBpZiAoc2xvdEJpbmRpbmcpIHtcbiAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgICBpZiAoZWwuc2xvdFRhcmdldCB8fCBlbC5zbG90U2NvcGUpIHtcbiAgICAgICAgICAgIHdhcm4kMihcbiAgICAgICAgICAgICAgXCJVbmV4cGVjdGVkIG1peGVkIHVzYWdlIG9mIGRpZmZlcmVudCBzbG90IHN5bnRheGVzLlwiLFxuICAgICAgICAgICAgICBlbFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGVsLnBhcmVudCAmJiAhbWF5YmVDb21wb25lbnQoZWwucGFyZW50KSkge1xuICAgICAgICAgICAgd2FybiQyKFxuICAgICAgICAgICAgICBcIjx0ZW1wbGF0ZSB2LXNsb3Q+IGNhbiBvbmx5IGFwcGVhciBhdCB0aGUgcm9vdCBsZXZlbCBpbnNpZGUgXCIgK1xuICAgICAgICAgICAgICBcInRoZSByZWNlaXZpbmcgY29tcG9uZW50XCIsXG4gICAgICAgICAgICAgIGVsXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB2YXIgcmVmID0gZ2V0U2xvdE5hbWUoc2xvdEJpbmRpbmcpO1xuICAgICAgICB2YXIgbmFtZSA9IHJlZi5uYW1lO1xuICAgICAgICB2YXIgZHluYW1pYyA9IHJlZi5keW5hbWljO1xuICAgICAgICBlbC5zbG90VGFyZ2V0ID0gbmFtZTtcbiAgICAgICAgZWwuc2xvdFRhcmdldER5bmFtaWMgPSBkeW5hbWljO1xuICAgICAgICBlbC5zbG90U2NvcGUgPSBzbG90QmluZGluZy52YWx1ZSB8fCBlbXB0eVNsb3RTY29wZVRva2VuOyAvLyBmb3JjZSBpdCBpbnRvIGEgc2NvcGVkIHNsb3QgZm9yIHBlcmZcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gdi1zbG90IG9uIGNvbXBvbmVudCwgZGVub3RlcyBkZWZhdWx0IHNsb3RcbiAgICAgIHZhciBzbG90QmluZGluZyQxID0gZ2V0QW5kUmVtb3ZlQXR0ckJ5UmVnZXgoZWwsIHNsb3RSRSk7XG4gICAgICBpZiAoc2xvdEJpbmRpbmckMSkge1xuICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICAgIGlmICghbWF5YmVDb21wb25lbnQoZWwpKSB7XG4gICAgICAgICAgICB3YXJuJDIoXG4gICAgICAgICAgICAgIFwidi1zbG90IGNhbiBvbmx5IGJlIHVzZWQgb24gY29tcG9uZW50cyBvciA8dGVtcGxhdGU+LlwiLFxuICAgICAgICAgICAgICBzbG90QmluZGluZyQxXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoZWwuc2xvdFNjb3BlIHx8IGVsLnNsb3RUYXJnZXQpIHtcbiAgICAgICAgICAgIHdhcm4kMihcbiAgICAgICAgICAgICAgXCJVbmV4cGVjdGVkIG1peGVkIHVzYWdlIG9mIGRpZmZlcmVudCBzbG90IHN5bnRheGVzLlwiLFxuICAgICAgICAgICAgICBlbFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGVsLnNjb3BlZFNsb3RzKSB7XG4gICAgICAgICAgICB3YXJuJDIoXG4gICAgICAgICAgICAgIFwiVG8gYXZvaWQgc2NvcGUgYW1iaWd1aXR5LCB0aGUgZGVmYXVsdCBzbG90IHNob3VsZCBhbHNvIHVzZSBcIiArXG4gICAgICAgICAgICAgIFwiPHRlbXBsYXRlPiBzeW50YXggd2hlbiB0aGVyZSBhcmUgb3RoZXIgbmFtZWQgc2xvdHMuXCIsXG4gICAgICAgICAgICAgIHNsb3RCaW5kaW5nJDFcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIGFkZCB0aGUgY29tcG9uZW50J3MgY2hpbGRyZW4gdG8gaXRzIGRlZmF1bHQgc2xvdFxuICAgICAgICB2YXIgc2xvdHMgPSBlbC5zY29wZWRTbG90cyB8fCAoZWwuc2NvcGVkU2xvdHMgPSB7fSk7XG4gICAgICAgIHZhciByZWYkMSA9IGdldFNsb3ROYW1lKHNsb3RCaW5kaW5nJDEpO1xuICAgICAgICB2YXIgbmFtZSQxID0gcmVmJDEubmFtZTtcbiAgICAgICAgdmFyIGR5bmFtaWMkMSA9IHJlZiQxLmR5bmFtaWM7XG4gICAgICAgIHZhciBzbG90Q29udGFpbmVyID0gc2xvdHNbbmFtZSQxXSA9IGNyZWF0ZUFTVEVsZW1lbnQoJ3RlbXBsYXRlJywgW10sIGVsKTtcbiAgICAgICAgc2xvdENvbnRhaW5lci5zbG90VGFyZ2V0ID0gbmFtZSQxO1xuICAgICAgICBzbG90Q29udGFpbmVyLnNsb3RUYXJnZXREeW5hbWljID0gZHluYW1pYyQxO1xuICAgICAgICBzbG90Q29udGFpbmVyLmNoaWxkcmVuID0gZWwuY2hpbGRyZW4uZmlsdGVyKGZ1bmN0aW9uIChjKSB7XG4gICAgICAgICAgaWYgKCFjLnNsb3RTY29wZSkge1xuICAgICAgICAgICAgYy5wYXJlbnQgPSBzbG90Q29udGFpbmVyO1xuICAgICAgICAgICAgcmV0dXJuIHRydWVcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBzbG90Q29udGFpbmVyLnNsb3RTY29wZSA9IHNsb3RCaW5kaW5nJDEudmFsdWUgfHwgZW1wdHlTbG90U2NvcGVUb2tlbjtcbiAgICAgICAgLy8gcmVtb3ZlIGNoaWxkcmVuIGFzIHRoZXkgYXJlIHJldHVybmVkIGZyb20gc2NvcGVkU2xvdHMgbm93XG4gICAgICAgIGVsLmNoaWxkcmVuID0gW107XG4gICAgICAgIC8vIG1hcmsgZWwgbm9uLXBsYWluIHNvIGRhdGEgZ2V0cyBnZW5lcmF0ZWRcbiAgICAgICAgZWwucGxhaW4gPSBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gZ2V0U2xvdE5hbWUgKGJpbmRpbmcpIHtcbiAgdmFyIG5hbWUgPSBiaW5kaW5nLm5hbWUucmVwbGFjZShzbG90UkUsICcnKTtcbiAgaWYgKCFuYW1lKSB7XG4gICAgaWYgKGJpbmRpbmcubmFtZVswXSAhPT0gJyMnKSB7XG4gICAgICBuYW1lID0gJ2RlZmF1bHQnO1xuICAgIH0gZWxzZSBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgd2FybiQyKFxuICAgICAgICBcInYtc2xvdCBzaG9ydGhhbmQgc3ludGF4IHJlcXVpcmVzIGEgc2xvdCBuYW1lLlwiLFxuICAgICAgICBiaW5kaW5nXG4gICAgICApO1xuICAgIH1cbiAgfVxuICByZXR1cm4gZHluYW1pY0FyZ1JFLnRlc3QobmFtZSlcbiAgICAvLyBkeW5hbWljIFtuYW1lXVxuICAgID8geyBuYW1lOiBuYW1lLnNsaWNlKDEsIC0xKSwgZHluYW1pYzogdHJ1ZSB9XG4gICAgLy8gc3RhdGljIG5hbWVcbiAgICA6IHsgbmFtZTogKFwiXFxcIlwiICsgbmFtZSArIFwiXFxcIlwiKSwgZHluYW1pYzogZmFsc2UgfVxufVxuXG4vLyBoYW5kbGUgPHNsb3QvPiBvdXRsZXRzXG5mdW5jdGlvbiBwcm9jZXNzU2xvdE91dGxldCAoZWwpIHtcbiAgaWYgKGVsLnRhZyA9PT0gJ3Nsb3QnKSB7XG4gICAgZWwuc2xvdE5hbWUgPSBnZXRCaW5kaW5nQXR0cihlbCwgJ25hbWUnKTtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiBlbC5rZXkpIHtcbiAgICAgIHdhcm4kMihcbiAgICAgICAgXCJga2V5YCBkb2VzIG5vdCB3b3JrIG9uIDxzbG90PiBiZWNhdXNlIHNsb3RzIGFyZSBhYnN0cmFjdCBvdXRsZXRzIFwiICtcbiAgICAgICAgXCJhbmQgY2FuIHBvc3NpYmx5IGV4cGFuZCBpbnRvIG11bHRpcGxlIGVsZW1lbnRzLiBcIiArXG4gICAgICAgIFwiVXNlIHRoZSBrZXkgb24gYSB3cmFwcGluZyBlbGVtZW50IGluc3RlYWQuXCIsXG4gICAgICAgIGdldFJhd0JpbmRpbmdBdHRyKGVsLCAna2V5JylcbiAgICAgICk7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHByb2Nlc3NDb21wb25lbnQgKGVsKSB7XG4gIHZhciBiaW5kaW5nO1xuICBpZiAoKGJpbmRpbmcgPSBnZXRCaW5kaW5nQXR0cihlbCwgJ2lzJykpKSB7XG4gICAgZWwuY29tcG9uZW50ID0gYmluZGluZztcbiAgfVxuICBpZiAoZ2V0QW5kUmVtb3ZlQXR0cihlbCwgJ2lubGluZS10ZW1wbGF0ZScpICE9IG51bGwpIHtcbiAgICBlbC5pbmxpbmVUZW1wbGF0ZSA9IHRydWU7XG4gIH1cbn1cblxuZnVuY3Rpb24gcHJvY2Vzc0F0dHJzIChlbCkge1xuICB2YXIgbGlzdCA9IGVsLmF0dHJzTGlzdDtcbiAgdmFyIGksIGwsIG5hbWUsIHJhd05hbWUsIHZhbHVlLCBtb2RpZmllcnMsIHN5bmNHZW4sIGlzRHluYW1pYztcbiAgZm9yIChpID0gMCwgbCA9IGxpc3QubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgbmFtZSA9IHJhd05hbWUgPSBsaXN0W2ldLm5hbWU7XG4gICAgdmFsdWUgPSBsaXN0W2ldLnZhbHVlO1xuICAgIGlmIChkaXJSRS50ZXN0KG5hbWUpKSB7XG4gICAgICAvLyBtYXJrIGVsZW1lbnQgYXMgZHluYW1pY1xuICAgICAgZWwuaGFzQmluZGluZ3MgPSB0cnVlO1xuICAgICAgLy8gbW9kaWZpZXJzXG4gICAgICBtb2RpZmllcnMgPSBwYXJzZU1vZGlmaWVycyhuYW1lLnJlcGxhY2UoZGlyUkUsICcnKSk7XG4gICAgICAvLyBzdXBwb3J0IC5mb28gc2hvcnRoYW5kIHN5bnRheCBmb3IgdGhlIC5wcm9wIG1vZGlmaWVyXG4gICAgICBpZiAobW9kaWZpZXJzKSB7XG4gICAgICAgIG5hbWUgPSBuYW1lLnJlcGxhY2UobW9kaWZpZXJSRSwgJycpO1xuICAgICAgfVxuICAgICAgaWYgKGJpbmRSRS50ZXN0KG5hbWUpKSB7IC8vIHYtYmluZFxuICAgICAgICBuYW1lID0gbmFtZS5yZXBsYWNlKGJpbmRSRSwgJycpO1xuICAgICAgICB2YWx1ZSA9IHBhcnNlRmlsdGVycyh2YWx1ZSk7XG4gICAgICAgIGlzRHluYW1pYyA9IGR5bmFtaWNBcmdSRS50ZXN0KG5hbWUpO1xuICAgICAgICBpZiAoaXNEeW5hbWljKSB7XG4gICAgICAgICAgbmFtZSA9IG5hbWUuc2xpY2UoMSwgLTEpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChcbiAgICAgICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmXG4gICAgICAgICAgdmFsdWUudHJpbSgpLmxlbmd0aCA9PT0gMFxuICAgICAgICApIHtcbiAgICAgICAgICB3YXJuJDIoXG4gICAgICAgICAgICAoXCJUaGUgdmFsdWUgZm9yIGEgdi1iaW5kIGV4cHJlc3Npb24gY2Fubm90IGJlIGVtcHR5LiBGb3VuZCBpbiBcXFwidi1iaW5kOlwiICsgbmFtZSArIFwiXFxcIlwiKVxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1vZGlmaWVycykge1xuICAgICAgICAgIGlmIChtb2RpZmllcnMucHJvcCAmJiAhaXNEeW5hbWljKSB7XG4gICAgICAgICAgICBuYW1lID0gY2FtZWxpemUobmFtZSk7XG4gICAgICAgICAgICBpZiAobmFtZSA9PT0gJ2lubmVySHRtbCcpIHsgbmFtZSA9ICdpbm5lckhUTUwnOyB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChtb2RpZmllcnMuY2FtZWwgJiYgIWlzRHluYW1pYykge1xuICAgICAgICAgICAgbmFtZSA9IGNhbWVsaXplKG5hbWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAobW9kaWZpZXJzLnN5bmMpIHtcbiAgICAgICAgICAgIHN5bmNHZW4gPSBnZW5Bc3NpZ25tZW50Q29kZSh2YWx1ZSwgXCIkZXZlbnRcIik7XG4gICAgICAgICAgICBpZiAoIWlzRHluYW1pYykge1xuICAgICAgICAgICAgICBhZGRIYW5kbGVyKFxuICAgICAgICAgICAgICAgIGVsLFxuICAgICAgICAgICAgICAgIChcInVwZGF0ZTpcIiArIChjYW1lbGl6ZShuYW1lKSkpLFxuICAgICAgICAgICAgICAgIHN5bmNHZW4sXG4gICAgICAgICAgICAgICAgbnVsbCxcbiAgICAgICAgICAgICAgICBmYWxzZSxcbiAgICAgICAgICAgICAgICB3YXJuJDIsXG4gICAgICAgICAgICAgICAgbGlzdFtpXVxuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICBpZiAoaHlwaGVuYXRlKG5hbWUpICE9PSBjYW1lbGl6ZShuYW1lKSkge1xuICAgICAgICAgICAgICAgIGFkZEhhbmRsZXIoXG4gICAgICAgICAgICAgICAgICBlbCxcbiAgICAgICAgICAgICAgICAgIChcInVwZGF0ZTpcIiArIChoeXBoZW5hdGUobmFtZSkpKSxcbiAgICAgICAgICAgICAgICAgIHN5bmNHZW4sXG4gICAgICAgICAgICAgICAgICBudWxsLFxuICAgICAgICAgICAgICAgICAgZmFsc2UsXG4gICAgICAgICAgICAgICAgICB3YXJuJDIsXG4gICAgICAgICAgICAgICAgICBsaXN0W2ldXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgLy8gaGFuZGxlciB3LyBkeW5hbWljIGV2ZW50IG5hbWVcbiAgICAgICAgICAgICAgYWRkSGFuZGxlcihcbiAgICAgICAgICAgICAgICBlbCxcbiAgICAgICAgICAgICAgICAoXCJcXFwidXBkYXRlOlxcXCIrKFwiICsgbmFtZSArIFwiKVwiKSxcbiAgICAgICAgICAgICAgICBzeW5jR2VuLFxuICAgICAgICAgICAgICAgIG51bGwsXG4gICAgICAgICAgICAgICAgZmFsc2UsXG4gICAgICAgICAgICAgICAgd2FybiQyLFxuICAgICAgICAgICAgICAgIGxpc3RbaV0sXG4gICAgICAgICAgICAgICAgdHJ1ZSAvLyBkeW5hbWljXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICgobW9kaWZpZXJzICYmIG1vZGlmaWVycy5wcm9wKSB8fCAoXG4gICAgICAgICAgIWVsLmNvbXBvbmVudCAmJiBwbGF0Zm9ybU11c3RVc2VQcm9wKGVsLnRhZywgZWwuYXR0cnNNYXAudHlwZSwgbmFtZSlcbiAgICAgICAgKSkge1xuICAgICAgICAgIGFkZFByb3AoZWwsIG5hbWUsIHZhbHVlLCBsaXN0W2ldLCBpc0R5bmFtaWMpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGFkZEF0dHIoZWwsIG5hbWUsIHZhbHVlLCBsaXN0W2ldLCBpc0R5bmFtaWMpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKG9uUkUudGVzdChuYW1lKSkgeyAvLyB2LW9uXG4gICAgICAgIG5hbWUgPSBuYW1lLnJlcGxhY2Uob25SRSwgJycpO1xuICAgICAgICBpc0R5bmFtaWMgPSBkeW5hbWljQXJnUkUudGVzdChuYW1lKTtcbiAgICAgICAgaWYgKGlzRHluYW1pYykge1xuICAgICAgICAgIG5hbWUgPSBuYW1lLnNsaWNlKDEsIC0xKTtcbiAgICAgICAgfVxuICAgICAgICBhZGRIYW5kbGVyKGVsLCBuYW1lLCB2YWx1ZSwgbW9kaWZpZXJzLCBmYWxzZSwgd2FybiQyLCBsaXN0W2ldLCBpc0R5bmFtaWMpO1xuICAgICAgfSBlbHNlIHsgLy8gbm9ybWFsIGRpcmVjdGl2ZXNcbiAgICAgICAgbmFtZSA9IG5hbWUucmVwbGFjZShkaXJSRSwgJycpO1xuICAgICAgICAvLyBwYXJzZSBhcmdcbiAgICAgICAgdmFyIGFyZ01hdGNoID0gbmFtZS5tYXRjaChhcmdSRSk7XG4gICAgICAgIHZhciBhcmcgPSBhcmdNYXRjaCAmJiBhcmdNYXRjaFsxXTtcbiAgICAgICAgaXNEeW5hbWljID0gZmFsc2U7XG4gICAgICAgIGlmIChhcmcpIHtcbiAgICAgICAgICBuYW1lID0gbmFtZS5zbGljZSgwLCAtKGFyZy5sZW5ndGggKyAxKSk7XG4gICAgICAgICAgaWYgKGR5bmFtaWNBcmdSRS50ZXN0KGFyZykpIHtcbiAgICAgICAgICAgIGFyZyA9IGFyZy5zbGljZSgxLCAtMSk7XG4gICAgICAgICAgICBpc0R5bmFtaWMgPSB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBhZGREaXJlY3RpdmUoZWwsIG5hbWUsIHJhd05hbWUsIHZhbHVlLCBhcmcsIGlzRHluYW1pYywgbW9kaWZpZXJzLCBsaXN0W2ldKTtcbiAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgbmFtZSA9PT0gJ21vZGVsJykge1xuICAgICAgICAgIGNoZWNrRm9yQWxpYXNNb2RlbChlbCwgdmFsdWUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGxpdGVyYWwgYXR0cmlidXRlXG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICB2YXIgcmVzID0gcGFyc2VUZXh0KHZhbHVlLCBkZWxpbWl0ZXJzKTtcbiAgICAgICAgaWYgKHJlcykge1xuICAgICAgICAgIHdhcm4kMihcbiAgICAgICAgICAgIG5hbWUgKyBcIj1cXFwiXCIgKyB2YWx1ZSArIFwiXFxcIjogXCIgK1xuICAgICAgICAgICAgJ0ludGVycG9sYXRpb24gaW5zaWRlIGF0dHJpYnV0ZXMgaGFzIGJlZW4gcmVtb3ZlZC4gJyArXG4gICAgICAgICAgICAnVXNlIHYtYmluZCBvciB0aGUgY29sb24gc2hvcnRoYW5kIGluc3RlYWQuIEZvciBleGFtcGxlLCAnICtcbiAgICAgICAgICAgICdpbnN0ZWFkIG9mIDxkaXYgaWQ9XCJ7eyB2YWwgfX1cIj4sIHVzZSA8ZGl2IDppZD1cInZhbFwiPi4nLFxuICAgICAgICAgICAgbGlzdFtpXVxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGFkZEF0dHIoZWwsIG5hbWUsIEpTT04uc3RyaW5naWZ5KHZhbHVlKSwgbGlzdFtpXSk7XG4gICAgICAvLyAjNjg4NyBmaXJlZm94IGRvZXNuJ3QgdXBkYXRlIG11dGVkIHN0YXRlIGlmIHNldCB2aWEgYXR0cmlidXRlXG4gICAgICAvLyBldmVuIGltbWVkaWF0ZWx5IGFmdGVyIGVsZW1lbnQgY3JlYXRpb25cbiAgICAgIGlmICghZWwuY29tcG9uZW50ICYmXG4gICAgICAgICAgbmFtZSA9PT0gJ211dGVkJyAmJlxuICAgICAgICAgIHBsYXRmb3JtTXVzdFVzZVByb3AoZWwudGFnLCBlbC5hdHRyc01hcC50eXBlLCBuYW1lKSkge1xuICAgICAgICBhZGRQcm9wKGVsLCBuYW1lLCAndHJ1ZScsIGxpc3RbaV0pO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBjaGVja0luRm9yIChlbCkge1xuICB2YXIgcGFyZW50ID0gZWw7XG4gIHdoaWxlIChwYXJlbnQpIHtcbiAgICBpZiAocGFyZW50LmZvciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH1cbiAgICBwYXJlbnQgPSBwYXJlbnQucGFyZW50O1xuICB9XG4gIHJldHVybiBmYWxzZVxufVxuXG5mdW5jdGlvbiBwYXJzZU1vZGlmaWVycyAobmFtZSkge1xuICB2YXIgbWF0Y2ggPSBuYW1lLm1hdGNoKG1vZGlmaWVyUkUpO1xuICBpZiAobWF0Y2gpIHtcbiAgICB2YXIgcmV0ID0ge307XG4gICAgbWF0Y2guZm9yRWFjaChmdW5jdGlvbiAobSkgeyByZXRbbS5zbGljZSgxKV0gPSB0cnVlOyB9KTtcbiAgICByZXR1cm4gcmV0XG4gIH1cbn1cblxuZnVuY3Rpb24gbWFrZUF0dHJzTWFwIChhdHRycykge1xuICB2YXIgbWFwID0ge307XG4gIGZvciAodmFyIGkgPSAwLCBsID0gYXR0cnMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgaWYgKFxuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJlxuICAgICAgbWFwW2F0dHJzW2ldLm5hbWVdICYmICFpc0lFICYmICFpc0VkZ2VcbiAgICApIHtcbiAgICAgIHdhcm4kMignZHVwbGljYXRlIGF0dHJpYnV0ZTogJyArIGF0dHJzW2ldLm5hbWUsIGF0dHJzW2ldKTtcbiAgICB9XG4gICAgbWFwW2F0dHJzW2ldLm5hbWVdID0gYXR0cnNbaV0udmFsdWU7XG4gIH1cbiAgcmV0dXJuIG1hcFxufVxuXG4vLyBmb3Igc2NyaXB0IChlLmcuIHR5cGU9XCJ4L3RlbXBsYXRlXCIpIG9yIHN0eWxlLCBkbyBub3QgZGVjb2RlIGNvbnRlbnRcbmZ1bmN0aW9uIGlzVGV4dFRhZyAoZWwpIHtcbiAgcmV0dXJuIGVsLnRhZyA9PT0gJ3NjcmlwdCcgfHwgZWwudGFnID09PSAnc3R5bGUnXG59XG5cbmZ1bmN0aW9uIGlzRm9yYmlkZGVuVGFnIChlbCkge1xuICByZXR1cm4gKFxuICAgIGVsLnRhZyA9PT0gJ3N0eWxlJyB8fFxuICAgIChlbC50YWcgPT09ICdzY3JpcHQnICYmIChcbiAgICAgICFlbC5hdHRyc01hcC50eXBlIHx8XG4gICAgICBlbC5hdHRyc01hcC50eXBlID09PSAndGV4dC9qYXZhc2NyaXB0J1xuICAgICkpXG4gIClcbn1cblxudmFyIGllTlNCdWcgPSAvXnhtbG5zOk5TXFxkKy87XG52YXIgaWVOU1ByZWZpeCA9IC9eTlNcXGQrOi87XG5cbi8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG5mdW5jdGlvbiBndWFyZElFU1ZHQnVnIChhdHRycykge1xuICB2YXIgcmVzID0gW107XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgYXR0cnMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgYXR0ciA9IGF0dHJzW2ldO1xuICAgIGlmICghaWVOU0J1Zy50ZXN0KGF0dHIubmFtZSkpIHtcbiAgICAgIGF0dHIubmFtZSA9IGF0dHIubmFtZS5yZXBsYWNlKGllTlNQcmVmaXgsICcnKTtcbiAgICAgIHJlcy5wdXNoKGF0dHIpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzXG59XG5cbmZ1bmN0aW9uIGNoZWNrRm9yQWxpYXNNb2RlbCAoZWwsIHZhbHVlKSB7XG4gIHZhciBfZWwgPSBlbDtcbiAgd2hpbGUgKF9lbCkge1xuICAgIGlmIChfZWwuZm9yICYmIF9lbC5hbGlhcyA9PT0gdmFsdWUpIHtcbiAgICAgIHdhcm4kMihcbiAgICAgICAgXCI8XCIgKyAoZWwudGFnKSArIFwiIHYtbW9kZWw9XFxcIlwiICsgdmFsdWUgKyBcIlxcXCI+OiBcIiArXG4gICAgICAgIFwiWW91IGFyZSBiaW5kaW5nIHYtbW9kZWwgZGlyZWN0bHkgdG8gYSB2LWZvciBpdGVyYXRpb24gYWxpYXMuIFwiICtcbiAgICAgICAgXCJUaGlzIHdpbGwgbm90IGJlIGFibGUgdG8gbW9kaWZ5IHRoZSB2LWZvciBzb3VyY2UgYXJyYXkgYmVjYXVzZSBcIiArXG4gICAgICAgIFwid3JpdGluZyB0byB0aGUgYWxpYXMgaXMgbGlrZSBtb2RpZnlpbmcgYSBmdW5jdGlvbiBsb2NhbCB2YXJpYWJsZS4gXCIgK1xuICAgICAgICBcIkNvbnNpZGVyIHVzaW5nIGFuIGFycmF5IG9mIG9iamVjdHMgYW5kIHVzZSB2LW1vZGVsIG9uIGFuIG9iamVjdCBwcm9wZXJ0eSBpbnN0ZWFkLlwiLFxuICAgICAgICBlbC5yYXdBdHRyc01hcFsndi1tb2RlbCddXG4gICAgICApO1xuICAgIH1cbiAgICBfZWwgPSBfZWwucGFyZW50O1xuICB9XG59XG5cbi8qICAqL1xuXG5mdW5jdGlvbiBwcmVUcmFuc2Zvcm1Ob2RlIChlbCwgb3B0aW9ucykge1xuICBpZiAoZWwudGFnID09PSAnaW5wdXQnKSB7XG4gICAgdmFyIG1hcCA9IGVsLmF0dHJzTWFwO1xuICAgIGlmICghbWFwWyd2LW1vZGVsJ10pIHtcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIHZhciB0eXBlQmluZGluZztcbiAgICBpZiAobWFwWyc6dHlwZSddIHx8IG1hcFsndi1iaW5kOnR5cGUnXSkge1xuICAgICAgdHlwZUJpbmRpbmcgPSBnZXRCaW5kaW5nQXR0cihlbCwgJ3R5cGUnKTtcbiAgICB9XG4gICAgaWYgKCFtYXAudHlwZSAmJiAhdHlwZUJpbmRpbmcgJiYgbWFwWyd2LWJpbmQnXSkge1xuICAgICAgdHlwZUJpbmRpbmcgPSBcIihcIiArIChtYXBbJ3YtYmluZCddKSArIFwiKS50eXBlXCI7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVCaW5kaW5nKSB7XG4gICAgICB2YXIgaWZDb25kaXRpb24gPSBnZXRBbmRSZW1vdmVBdHRyKGVsLCAndi1pZicsIHRydWUpO1xuICAgICAgdmFyIGlmQ29uZGl0aW9uRXh0cmEgPSBpZkNvbmRpdGlvbiA/IChcIiYmKFwiICsgaWZDb25kaXRpb24gKyBcIilcIikgOiBcIlwiO1xuICAgICAgdmFyIGhhc0Vsc2UgPSBnZXRBbmRSZW1vdmVBdHRyKGVsLCAndi1lbHNlJywgdHJ1ZSkgIT0gbnVsbDtcbiAgICAgIHZhciBlbHNlSWZDb25kaXRpb24gPSBnZXRBbmRSZW1vdmVBdHRyKGVsLCAndi1lbHNlLWlmJywgdHJ1ZSk7XG4gICAgICAvLyAxLiBjaGVja2JveFxuICAgICAgdmFyIGJyYW5jaDAgPSBjbG9uZUFTVEVsZW1lbnQoZWwpO1xuICAgICAgLy8gcHJvY2VzcyBmb3Igb24gdGhlIG1haW4gbm9kZVxuICAgICAgcHJvY2Vzc0ZvcihicmFuY2gwKTtcbiAgICAgIGFkZFJhd0F0dHIoYnJhbmNoMCwgJ3R5cGUnLCAnY2hlY2tib3gnKTtcbiAgICAgIHByb2Nlc3NFbGVtZW50KGJyYW5jaDAsIG9wdGlvbnMpO1xuICAgICAgYnJhbmNoMC5wcm9jZXNzZWQgPSB0cnVlOyAvLyBwcmV2ZW50IGl0IGZyb20gZG91YmxlLXByb2Nlc3NlZFxuICAgICAgYnJhbmNoMC5pZiA9IFwiKFwiICsgdHlwZUJpbmRpbmcgKyBcIik9PT0nY2hlY2tib3gnXCIgKyBpZkNvbmRpdGlvbkV4dHJhO1xuICAgICAgYWRkSWZDb25kaXRpb24oYnJhbmNoMCwge1xuICAgICAgICBleHA6IGJyYW5jaDAuaWYsXG4gICAgICAgIGJsb2NrOiBicmFuY2gwXG4gICAgICB9KTtcbiAgICAgIC8vIDIuIGFkZCByYWRpbyBlbHNlLWlmIGNvbmRpdGlvblxuICAgICAgdmFyIGJyYW5jaDEgPSBjbG9uZUFTVEVsZW1lbnQoZWwpO1xuICAgICAgZ2V0QW5kUmVtb3ZlQXR0cihicmFuY2gxLCAndi1mb3InLCB0cnVlKTtcbiAgICAgIGFkZFJhd0F0dHIoYnJhbmNoMSwgJ3R5cGUnLCAncmFkaW8nKTtcbiAgICAgIHByb2Nlc3NFbGVtZW50KGJyYW5jaDEsIG9wdGlvbnMpO1xuICAgICAgYWRkSWZDb25kaXRpb24oYnJhbmNoMCwge1xuICAgICAgICBleHA6IFwiKFwiICsgdHlwZUJpbmRpbmcgKyBcIik9PT0ncmFkaW8nXCIgKyBpZkNvbmRpdGlvbkV4dHJhLFxuICAgICAgICBibG9jazogYnJhbmNoMVxuICAgICAgfSk7XG4gICAgICAvLyAzLiBvdGhlclxuICAgICAgdmFyIGJyYW5jaDIgPSBjbG9uZUFTVEVsZW1lbnQoZWwpO1xuICAgICAgZ2V0QW5kUmVtb3ZlQXR0cihicmFuY2gyLCAndi1mb3InLCB0cnVlKTtcbiAgICAgIGFkZFJhd0F0dHIoYnJhbmNoMiwgJzp0eXBlJywgdHlwZUJpbmRpbmcpO1xuICAgICAgcHJvY2Vzc0VsZW1lbnQoYnJhbmNoMiwgb3B0aW9ucyk7XG4gICAgICBhZGRJZkNvbmRpdGlvbihicmFuY2gwLCB7XG4gICAgICAgIGV4cDogaWZDb25kaXRpb24sXG4gICAgICAgIGJsb2NrOiBicmFuY2gyXG4gICAgICB9KTtcblxuICAgICAgaWYgKGhhc0Vsc2UpIHtcbiAgICAgICAgYnJhbmNoMC5lbHNlID0gdHJ1ZTtcbiAgICAgIH0gZWxzZSBpZiAoZWxzZUlmQ29uZGl0aW9uKSB7XG4gICAgICAgIGJyYW5jaDAuZWxzZWlmID0gZWxzZUlmQ29uZGl0aW9uO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gYnJhbmNoMFxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBjbG9uZUFTVEVsZW1lbnQgKGVsKSB7XG4gIHJldHVybiBjcmVhdGVBU1RFbGVtZW50KGVsLnRhZywgZWwuYXR0cnNMaXN0LnNsaWNlKCksIGVsLnBhcmVudClcbn1cblxudmFyIG1vZGVsJDEgPSB7XG4gIHByZVRyYW5zZm9ybU5vZGU6IHByZVRyYW5zZm9ybU5vZGVcbn07XG5cbnZhciBtb2R1bGVzJDEgPSBbXG4gIGtsYXNzJDEsXG4gIHN0eWxlJDEsXG4gIG1vZGVsJDFcbl07XG5cbi8qICAqL1xuXG5mdW5jdGlvbiB0ZXh0IChlbCwgZGlyKSB7XG4gIGlmIChkaXIudmFsdWUpIHtcbiAgICBhZGRQcm9wKGVsLCAndGV4dENvbnRlbnQnLCAoXCJfcyhcIiArIChkaXIudmFsdWUpICsgXCIpXCIpLCBkaXIpO1xuICB9XG59XG5cbi8qICAqL1xuXG5mdW5jdGlvbiBodG1sIChlbCwgZGlyKSB7XG4gIGlmIChkaXIudmFsdWUpIHtcbiAgICBhZGRQcm9wKGVsLCAnaW5uZXJIVE1MJywgKFwiX3MoXCIgKyAoZGlyLnZhbHVlKSArIFwiKVwiKSwgZGlyKTtcbiAgfVxufVxuXG52YXIgZGlyZWN0aXZlcyQxID0ge1xuICBtb2RlbDogbW9kZWwsXG4gIHRleHQ6IHRleHQsXG4gIGh0bWw6IGh0bWxcbn07XG5cbi8qICAqL1xuXG52YXIgYmFzZU9wdGlvbnMgPSB7XG4gIGV4cGVjdEhUTUw6IHRydWUsXG4gIG1vZHVsZXM6IG1vZHVsZXMkMSxcbiAgZGlyZWN0aXZlczogZGlyZWN0aXZlcyQxLFxuICBpc1ByZVRhZzogaXNQcmVUYWcsXG4gIGlzVW5hcnlUYWc6IGlzVW5hcnlUYWcsXG4gIG11c3RVc2VQcm9wOiBtdXN0VXNlUHJvcCxcbiAgY2FuQmVMZWZ0T3BlblRhZzogY2FuQmVMZWZ0T3BlblRhZyxcbiAgaXNSZXNlcnZlZFRhZzogaXNSZXNlcnZlZFRhZyxcbiAgZ2V0VGFnTmFtZXNwYWNlOiBnZXRUYWdOYW1lc3BhY2UsXG4gIHN0YXRpY0tleXM6IGdlblN0YXRpY0tleXMobW9kdWxlcyQxKVxufTtcblxuLyogICovXG5cbnZhciBpc1N0YXRpY0tleTtcbnZhciBpc1BsYXRmb3JtUmVzZXJ2ZWRUYWc7XG5cbnZhciBnZW5TdGF0aWNLZXlzQ2FjaGVkID0gY2FjaGVkKGdlblN0YXRpY0tleXMkMSk7XG5cbi8qKlxuICogR29hbCBvZiB0aGUgb3B0aW1pemVyOiB3YWxrIHRoZSBnZW5lcmF0ZWQgdGVtcGxhdGUgQVNUIHRyZWVcbiAqIGFuZCBkZXRlY3Qgc3ViLXRyZWVzIHRoYXQgYXJlIHB1cmVseSBzdGF0aWMsIGkuZS4gcGFydHMgb2ZcbiAqIHRoZSBET00gdGhhdCBuZXZlciBuZWVkcyB0byBjaGFuZ2UuXG4gKlxuICogT25jZSB3ZSBkZXRlY3QgdGhlc2Ugc3ViLXRyZWVzLCB3ZSBjYW46XG4gKlxuICogMS4gSG9pc3QgdGhlbSBpbnRvIGNvbnN0YW50cywgc28gdGhhdCB3ZSBubyBsb25nZXIgbmVlZCB0b1xuICogICAgY3JlYXRlIGZyZXNoIG5vZGVzIGZvciB0aGVtIG9uIGVhY2ggcmUtcmVuZGVyO1xuICogMi4gQ29tcGxldGVseSBza2lwIHRoZW0gaW4gdGhlIHBhdGNoaW5nIHByb2Nlc3MuXG4gKi9cbmZ1bmN0aW9uIG9wdGltaXplIChyb290LCBvcHRpb25zKSB7XG4gIGlmICghcm9vdCkgeyByZXR1cm4gfVxuICBpc1N0YXRpY0tleSA9IGdlblN0YXRpY0tleXNDYWNoZWQob3B0aW9ucy5zdGF0aWNLZXlzIHx8ICcnKTtcbiAgaXNQbGF0Zm9ybVJlc2VydmVkVGFnID0gb3B0aW9ucy5pc1Jlc2VydmVkVGFnIHx8IG5vO1xuICAvLyBmaXJzdCBwYXNzOiBtYXJrIGFsbCBub24tc3RhdGljIG5vZGVzLlxuICBtYXJrU3RhdGljJDEocm9vdCk7XG4gIC8vIHNlY29uZCBwYXNzOiBtYXJrIHN0YXRpYyByb290cy5cbiAgbWFya1N0YXRpY1Jvb3RzKHJvb3QsIGZhbHNlKTtcbn1cblxuZnVuY3Rpb24gZ2VuU3RhdGljS2V5cyQxIChrZXlzKSB7XG4gIHJldHVybiBtYWtlTWFwKFxuICAgICd0eXBlLHRhZyxhdHRyc0xpc3QsYXR0cnNNYXAscGxhaW4scGFyZW50LGNoaWxkcmVuLGF0dHJzLHN0YXJ0LGVuZCxyYXdBdHRyc01hcCcgK1xuICAgIChrZXlzID8gJywnICsga2V5cyA6ICcnKVxuICApXG59XG5cbmZ1bmN0aW9uIG1hcmtTdGF0aWMkMSAobm9kZSkge1xuICBub2RlLnN0YXRpYyA9IGlzU3RhdGljKG5vZGUpO1xuICBpZiAobm9kZS50eXBlID09PSAxKSB7XG4gICAgLy8gZG8gbm90IG1ha2UgY29tcG9uZW50IHNsb3QgY29udGVudCBzdGF0aWMuIHRoaXMgYXZvaWRzXG4gICAgLy8gMS4gY29tcG9uZW50cyBub3QgYWJsZSB0byBtdXRhdGUgc2xvdCBub2Rlc1xuICAgIC8vIDIuIHN0YXRpYyBzbG90IGNvbnRlbnQgZmFpbHMgZm9yIGhvdC1yZWxvYWRpbmdcbiAgICBpZiAoXG4gICAgICAhaXNQbGF0Zm9ybVJlc2VydmVkVGFnKG5vZGUudGFnKSAmJlxuICAgICAgbm9kZS50YWcgIT09ICdzbG90JyAmJlxuICAgICAgbm9kZS5hdHRyc01hcFsnaW5saW5lLXRlbXBsYXRlJ10gPT0gbnVsbFxuICAgICkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuICAgIGZvciAodmFyIGkgPSAwLCBsID0gbm9kZS5jaGlsZHJlbi5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgIHZhciBjaGlsZCA9IG5vZGUuY2hpbGRyZW5baV07XG4gICAgICBtYXJrU3RhdGljJDEoY2hpbGQpO1xuICAgICAgaWYgKCFjaGlsZC5zdGF0aWMpIHtcbiAgICAgICAgbm9kZS5zdGF0aWMgPSBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKG5vZGUuaWZDb25kaXRpb25zKSB7XG4gICAgICBmb3IgKHZhciBpJDEgPSAxLCBsJDEgPSBub2RlLmlmQ29uZGl0aW9ucy5sZW5ndGg7IGkkMSA8IGwkMTsgaSQxKyspIHtcbiAgICAgICAgdmFyIGJsb2NrID0gbm9kZS5pZkNvbmRpdGlvbnNbaSQxXS5ibG9jaztcbiAgICAgICAgbWFya1N0YXRpYyQxKGJsb2NrKTtcbiAgICAgICAgaWYgKCFibG9jay5zdGF0aWMpIHtcbiAgICAgICAgICBub2RlLnN0YXRpYyA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIG1hcmtTdGF0aWNSb290cyAobm9kZSwgaXNJbkZvcikge1xuICBpZiAobm9kZS50eXBlID09PSAxKSB7XG4gICAgaWYgKG5vZGUuc3RhdGljIHx8IG5vZGUub25jZSkge1xuICAgICAgbm9kZS5zdGF0aWNJbkZvciA9IGlzSW5Gb3I7XG4gICAgfVxuICAgIC8vIEZvciBhIG5vZGUgdG8gcXVhbGlmeSBhcyBhIHN0YXRpYyByb290LCBpdCBzaG91bGQgaGF2ZSBjaGlsZHJlbiB0aGF0XG4gICAgLy8gYXJlIG5vdCBqdXN0IHN0YXRpYyB0ZXh0LiBPdGhlcndpc2UgdGhlIGNvc3Qgb2YgaG9pc3Rpbmcgb3V0IHdpbGxcbiAgICAvLyBvdXR3ZWlnaCB0aGUgYmVuZWZpdHMgYW5kIGl0J3MgYmV0dGVyIG9mZiB0byBqdXN0IGFsd2F5cyByZW5kZXIgaXQgZnJlc2guXG4gICAgaWYgKG5vZGUuc3RhdGljICYmIG5vZGUuY2hpbGRyZW4ubGVuZ3RoICYmICEoXG4gICAgICBub2RlLmNoaWxkcmVuLmxlbmd0aCA9PT0gMSAmJlxuICAgICAgbm9kZS5jaGlsZHJlblswXS50eXBlID09PSAzXG4gICAgKSkge1xuICAgICAgbm9kZS5zdGF0aWNSb290ID0gdHJ1ZTtcbiAgICAgIHJldHVyblxuICAgIH0gZWxzZSB7XG4gICAgICBub2RlLnN0YXRpY1Jvb3QgPSBmYWxzZTtcbiAgICB9XG4gICAgaWYgKG5vZGUuY2hpbGRyZW4pIHtcbiAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gbm9kZS5jaGlsZHJlbi5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgbWFya1N0YXRpY1Jvb3RzKG5vZGUuY2hpbGRyZW5baV0sIGlzSW5Gb3IgfHwgISFub2RlLmZvcik7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChub2RlLmlmQ29uZGl0aW9ucykge1xuICAgICAgZm9yICh2YXIgaSQxID0gMSwgbCQxID0gbm9kZS5pZkNvbmRpdGlvbnMubGVuZ3RoOyBpJDEgPCBsJDE7IGkkMSsrKSB7XG4gICAgICAgIG1hcmtTdGF0aWNSb290cyhub2RlLmlmQ29uZGl0aW9uc1tpJDFdLmJsb2NrLCBpc0luRm9yKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gaXNTdGF0aWMgKG5vZGUpIHtcbiAgaWYgKG5vZGUudHlwZSA9PT0gMikgeyAvLyBleHByZXNzaW9uXG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cbiAgaWYgKG5vZGUudHlwZSA9PT0gMykgeyAvLyB0ZXh0XG4gICAgcmV0dXJuIHRydWVcbiAgfVxuICByZXR1cm4gISEobm9kZS5wcmUgfHwgKFxuICAgICFub2RlLmhhc0JpbmRpbmdzICYmIC8vIG5vIGR5bmFtaWMgYmluZGluZ3NcbiAgICAhbm9kZS5pZiAmJiAhbm9kZS5mb3IgJiYgLy8gbm90IHYtaWYgb3Igdi1mb3Igb3Igdi1lbHNlXG4gICAgIWlzQnVpbHRJblRhZyhub2RlLnRhZykgJiYgLy8gbm90IGEgYnVpbHQtaW5cbiAgICBpc1BsYXRmb3JtUmVzZXJ2ZWRUYWcobm9kZS50YWcpICYmIC8vIG5vdCBhIGNvbXBvbmVudFxuICAgICFpc0RpcmVjdENoaWxkT2ZUZW1wbGF0ZUZvcihub2RlKSAmJlxuICAgIE9iamVjdC5rZXlzKG5vZGUpLmV2ZXJ5KGlzU3RhdGljS2V5KVxuICApKVxufVxuXG5mdW5jdGlvbiBpc0RpcmVjdENoaWxkT2ZUZW1wbGF0ZUZvciAobm9kZSkge1xuICB3aGlsZSAobm9kZS5wYXJlbnQpIHtcbiAgICBub2RlID0gbm9kZS5wYXJlbnQ7XG4gICAgaWYgKG5vZGUudGFnICE9PSAndGVtcGxhdGUnKSB7XG4gICAgICByZXR1cm4gZmFsc2VcbiAgICB9XG4gICAgaWYgKG5vZGUuZm9yKSB7XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH1cbiAgfVxuICByZXR1cm4gZmFsc2Vcbn1cblxuLyogICovXG5cbnZhciBmbkV4cFJFID0gL14oW1xcdyRfXSt8XFwoW14pXSo/XFwpKVxccyo9PnxeZnVuY3Rpb24oPzpcXHMrW1xcdyRdKyk/XFxzKlxcKC87XG52YXIgZm5JbnZva2VSRSA9IC9cXChbXildKj9cXCk7KiQvO1xudmFyIHNpbXBsZVBhdGhSRSA9IC9eW0EtWmEtel8kXVtcXHckXSooPzpcXC5bQS1aYS16XyRdW1xcdyRdKnxcXFsnW14nXSo/J118XFxbXCJbXlwiXSo/XCJdfFxcW1xcZCtdfFxcW1tBLVphLXpfJF1bXFx3JF0qXSkqJC87XG5cbi8vIEtleWJvYXJkRXZlbnQua2V5Q29kZSBhbGlhc2VzXG52YXIga2V5Q29kZXMgPSB7XG4gIGVzYzogMjcsXG4gIHRhYjogOSxcbiAgZW50ZXI6IDEzLFxuICBzcGFjZTogMzIsXG4gIHVwOiAzOCxcbiAgbGVmdDogMzcsXG4gIHJpZ2h0OiAzOSxcbiAgZG93bjogNDAsXG4gICdkZWxldGUnOiBbOCwgNDZdXG59O1xuXG4vLyBLZXlib2FyZEV2ZW50LmtleSBhbGlhc2VzXG52YXIga2V5TmFtZXMgPSB7XG4gIC8vICM3ODgwOiBJRTExIGFuZCBFZGdlIHVzZSBgRXNjYCBmb3IgRXNjYXBlIGtleSBuYW1lLlxuICBlc2M6IFsnRXNjJywgJ0VzY2FwZSddLFxuICB0YWI6ICdUYWInLFxuICBlbnRlcjogJ0VudGVyJyxcbiAgLy8gIzkxMTI6IElFMTEgdXNlcyBgU3BhY2ViYXJgIGZvciBTcGFjZSBrZXkgbmFtZS5cbiAgc3BhY2U6IFsnICcsICdTcGFjZWJhciddLFxuICAvLyAjNzgwNjogSUUxMSB1c2VzIGtleSBuYW1lcyB3aXRob3V0IGBBcnJvd2AgcHJlZml4IGZvciBhcnJvdyBrZXlzLlxuICB1cDogWydVcCcsICdBcnJvd1VwJ10sXG4gIGxlZnQ6IFsnTGVmdCcsICdBcnJvd0xlZnQnXSxcbiAgcmlnaHQ6IFsnUmlnaHQnLCAnQXJyb3dSaWdodCddLFxuICBkb3duOiBbJ0Rvd24nLCAnQXJyb3dEb3duJ10sXG4gIC8vICM5MTEyOiBJRTExIHVzZXMgYERlbGAgZm9yIERlbGV0ZSBrZXkgbmFtZS5cbiAgJ2RlbGV0ZSc6IFsnQmFja3NwYWNlJywgJ0RlbGV0ZScsICdEZWwnXVxufTtcblxuLy8gIzQ4Njg6IG1vZGlmaWVycyB0aGF0IHByZXZlbnQgdGhlIGV4ZWN1dGlvbiBvZiB0aGUgbGlzdGVuZXJcbi8vIG5lZWQgdG8gZXhwbGljaXRseSByZXR1cm4gbnVsbCBzbyB0aGF0IHdlIGNhbiBkZXRlcm1pbmUgd2hldGhlciB0byByZW1vdmVcbi8vIHRoZSBsaXN0ZW5lciBmb3IgLm9uY2VcbnZhciBnZW5HdWFyZCA9IGZ1bmN0aW9uIChjb25kaXRpb24pIHsgcmV0dXJuIChcImlmKFwiICsgY29uZGl0aW9uICsgXCIpcmV0dXJuIG51bGw7XCIpOyB9O1xuXG52YXIgbW9kaWZpZXJDb2RlID0ge1xuICBzdG9wOiAnJGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpOycsXG4gIHByZXZlbnQ6ICckZXZlbnQucHJldmVudERlZmF1bHQoKTsnLFxuICBzZWxmOiBnZW5HdWFyZChcIiRldmVudC50YXJnZXQgIT09ICRldmVudC5jdXJyZW50VGFyZ2V0XCIpLFxuICBjdHJsOiBnZW5HdWFyZChcIiEkZXZlbnQuY3RybEtleVwiKSxcbiAgc2hpZnQ6IGdlbkd1YXJkKFwiISRldmVudC5zaGlmdEtleVwiKSxcbiAgYWx0OiBnZW5HdWFyZChcIiEkZXZlbnQuYWx0S2V5XCIpLFxuICBtZXRhOiBnZW5HdWFyZChcIiEkZXZlbnQubWV0YUtleVwiKSxcbiAgbGVmdDogZ2VuR3VhcmQoXCInYnV0dG9uJyBpbiAkZXZlbnQgJiYgJGV2ZW50LmJ1dHRvbiAhPT0gMFwiKSxcbiAgbWlkZGxlOiBnZW5HdWFyZChcIididXR0b24nIGluICRldmVudCAmJiAkZXZlbnQuYnV0dG9uICE9PSAxXCIpLFxuICByaWdodDogZ2VuR3VhcmQoXCInYnV0dG9uJyBpbiAkZXZlbnQgJiYgJGV2ZW50LmJ1dHRvbiAhPT0gMlwiKVxufTtcblxuZnVuY3Rpb24gZ2VuSGFuZGxlcnMgKFxuICBldmVudHMsXG4gIGlzTmF0aXZlXG4pIHtcbiAgdmFyIHByZWZpeCA9IGlzTmF0aXZlID8gJ25hdGl2ZU9uOicgOiAnb246JztcbiAgdmFyIHN0YXRpY0hhbmRsZXJzID0gXCJcIjtcbiAgdmFyIGR5bmFtaWNIYW5kbGVycyA9IFwiXCI7XG4gIGZvciAodmFyIG5hbWUgaW4gZXZlbnRzKSB7XG4gICAgdmFyIGhhbmRsZXJDb2RlID0gZ2VuSGFuZGxlcihldmVudHNbbmFtZV0pO1xuICAgIGlmIChldmVudHNbbmFtZV0gJiYgZXZlbnRzW25hbWVdLmR5bmFtaWMpIHtcbiAgICAgIGR5bmFtaWNIYW5kbGVycyArPSBuYW1lICsgXCIsXCIgKyBoYW5kbGVyQ29kZSArIFwiLFwiO1xuICAgIH0gZWxzZSB7XG4gICAgICBzdGF0aWNIYW5kbGVycyArPSBcIlxcXCJcIiArIG5hbWUgKyBcIlxcXCI6XCIgKyBoYW5kbGVyQ29kZSArIFwiLFwiO1xuICAgIH1cbiAgfVxuICBzdGF0aWNIYW5kbGVycyA9IFwie1wiICsgKHN0YXRpY0hhbmRsZXJzLnNsaWNlKDAsIC0xKSkgKyBcIn1cIjtcbiAgaWYgKGR5bmFtaWNIYW5kbGVycykge1xuICAgIHJldHVybiBwcmVmaXggKyBcIl9kKFwiICsgc3RhdGljSGFuZGxlcnMgKyBcIixbXCIgKyAoZHluYW1pY0hhbmRsZXJzLnNsaWNlKDAsIC0xKSkgKyBcIl0pXCJcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gcHJlZml4ICsgc3RhdGljSGFuZGxlcnNcbiAgfVxufVxuXG5mdW5jdGlvbiBnZW5IYW5kbGVyIChoYW5kbGVyKSB7XG4gIGlmICghaGFuZGxlcikge1xuICAgIHJldHVybiAnZnVuY3Rpb24oKXt9J1xuICB9XG5cbiAgaWYgKEFycmF5LmlzQXJyYXkoaGFuZGxlcikpIHtcbiAgICByZXR1cm4gKFwiW1wiICsgKGhhbmRsZXIubWFwKGZ1bmN0aW9uIChoYW5kbGVyKSB7IHJldHVybiBnZW5IYW5kbGVyKGhhbmRsZXIpOyB9KS5qb2luKCcsJykpICsgXCJdXCIpXG4gIH1cblxuICB2YXIgaXNNZXRob2RQYXRoID0gc2ltcGxlUGF0aFJFLnRlc3QoaGFuZGxlci52YWx1ZSk7XG4gIHZhciBpc0Z1bmN0aW9uRXhwcmVzc2lvbiA9IGZuRXhwUkUudGVzdChoYW5kbGVyLnZhbHVlKTtcbiAgdmFyIGlzRnVuY3Rpb25JbnZvY2F0aW9uID0gc2ltcGxlUGF0aFJFLnRlc3QoaGFuZGxlci52YWx1ZS5yZXBsYWNlKGZuSW52b2tlUkUsICcnKSk7XG5cbiAgaWYgKCFoYW5kbGVyLm1vZGlmaWVycykge1xuICAgIGlmIChpc01ldGhvZFBhdGggfHwgaXNGdW5jdGlvbkV4cHJlc3Npb24pIHtcbiAgICAgIHJldHVybiBoYW5kbGVyLnZhbHVlXG4gICAgfVxuICAgIHJldHVybiAoXCJmdW5jdGlvbigkZXZlbnQpe1wiICsgKGlzRnVuY3Rpb25JbnZvY2F0aW9uID8gKFwicmV0dXJuIFwiICsgKGhhbmRsZXIudmFsdWUpKSA6IGhhbmRsZXIudmFsdWUpICsgXCJ9XCIpIC8vIGlubGluZSBzdGF0ZW1lbnRcbiAgfSBlbHNlIHtcbiAgICB2YXIgY29kZSA9ICcnO1xuICAgIHZhciBnZW5Nb2RpZmllckNvZGUgPSAnJztcbiAgICB2YXIga2V5cyA9IFtdO1xuICAgIGZvciAodmFyIGtleSBpbiBoYW5kbGVyLm1vZGlmaWVycykge1xuICAgICAgaWYgKG1vZGlmaWVyQ29kZVtrZXldKSB7XG4gICAgICAgIGdlbk1vZGlmaWVyQ29kZSArPSBtb2RpZmllckNvZGVba2V5XTtcbiAgICAgICAgLy8gbGVmdC9yaWdodFxuICAgICAgICBpZiAoa2V5Q29kZXNba2V5XSkge1xuICAgICAgICAgIGtleXMucHVzaChrZXkpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKGtleSA9PT0gJ2V4YWN0Jykge1xuICAgICAgICB2YXIgbW9kaWZpZXJzID0gKGhhbmRsZXIubW9kaWZpZXJzKTtcbiAgICAgICAgZ2VuTW9kaWZpZXJDb2RlICs9IGdlbkd1YXJkKFxuICAgICAgICAgIFsnY3RybCcsICdzaGlmdCcsICdhbHQnLCAnbWV0YSddXG4gICAgICAgICAgICAuZmlsdGVyKGZ1bmN0aW9uIChrZXlNb2RpZmllcikgeyByZXR1cm4gIW1vZGlmaWVyc1trZXlNb2RpZmllcl07IH0pXG4gICAgICAgICAgICAubWFwKGZ1bmN0aW9uIChrZXlNb2RpZmllcikgeyByZXR1cm4gKFwiJGV2ZW50LlwiICsga2V5TW9kaWZpZXIgKyBcIktleVwiKTsgfSlcbiAgICAgICAgICAgIC5qb2luKCd8fCcpXG4gICAgICAgICk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBrZXlzLnB1c2goa2V5KTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGtleXMubGVuZ3RoKSB7XG4gICAgICBjb2RlICs9IGdlbktleUZpbHRlcihrZXlzKTtcbiAgICB9XG4gICAgLy8gTWFrZSBzdXJlIG1vZGlmaWVycyBsaWtlIHByZXZlbnQgYW5kIHN0b3AgZ2V0IGV4ZWN1dGVkIGFmdGVyIGtleSBmaWx0ZXJpbmdcbiAgICBpZiAoZ2VuTW9kaWZpZXJDb2RlKSB7XG4gICAgICBjb2RlICs9IGdlbk1vZGlmaWVyQ29kZTtcbiAgICB9XG4gICAgdmFyIGhhbmRsZXJDb2RlID0gaXNNZXRob2RQYXRoXG4gICAgICA/IChcInJldHVybiBcIiArIChoYW5kbGVyLnZhbHVlKSArIFwiLmFwcGx5KG51bGwsIGFyZ3VtZW50cylcIilcbiAgICAgIDogaXNGdW5jdGlvbkV4cHJlc3Npb25cbiAgICAgICAgPyAoXCJyZXR1cm4gKFwiICsgKGhhbmRsZXIudmFsdWUpICsgXCIpLmFwcGx5KG51bGwsIGFyZ3VtZW50cylcIilcbiAgICAgICAgOiBpc0Z1bmN0aW9uSW52b2NhdGlvblxuICAgICAgICAgID8gKFwicmV0dXJuIFwiICsgKGhhbmRsZXIudmFsdWUpKVxuICAgICAgICAgIDogaGFuZGxlci52YWx1ZTtcbiAgICByZXR1cm4gKFwiZnVuY3Rpb24oJGV2ZW50KXtcIiArIGNvZGUgKyBoYW5kbGVyQ29kZSArIFwifVwiKVxuICB9XG59XG5cbmZ1bmN0aW9uIGdlbktleUZpbHRlciAoa2V5cykge1xuICByZXR1cm4gKFxuICAgIC8vIG1ha2Ugc3VyZSB0aGUga2V5IGZpbHRlcnMgb25seSBhcHBseSB0byBLZXlib2FyZEV2ZW50c1xuICAgIC8vICM5NDQxOiBjYW4ndCB1c2UgJ2tleUNvZGUnIGluICRldmVudCBiZWNhdXNlIENocm9tZSBhdXRvZmlsbCBmaXJlcyBmYWtlXG4gICAgLy8ga2V5IGV2ZW50cyB0aGF0IGRvIG5vdCBoYXZlIGtleUNvZGUgcHJvcGVydHkuLi5cbiAgICBcImlmKCEkZXZlbnQudHlwZS5pbmRleE9mKCdrZXknKSYmXCIgK1xuICAgIChrZXlzLm1hcChnZW5GaWx0ZXJDb2RlKS5qb2luKCcmJicpKSArIFwiKXJldHVybiBudWxsO1wiXG4gIClcbn1cblxuZnVuY3Rpb24gZ2VuRmlsdGVyQ29kZSAoa2V5KSB7XG4gIHZhciBrZXlWYWwgPSBwYXJzZUludChrZXksIDEwKTtcbiAgaWYgKGtleVZhbCkge1xuICAgIHJldHVybiAoXCIkZXZlbnQua2V5Q29kZSE9PVwiICsga2V5VmFsKVxuICB9XG4gIHZhciBrZXlDb2RlID0ga2V5Q29kZXNba2V5XTtcbiAgdmFyIGtleU5hbWUgPSBrZXlOYW1lc1trZXldO1xuICByZXR1cm4gKFxuICAgIFwiX2soJGV2ZW50LmtleUNvZGUsXCIgK1xuICAgIChKU09OLnN0cmluZ2lmeShrZXkpKSArIFwiLFwiICtcbiAgICAoSlNPTi5zdHJpbmdpZnkoa2V5Q29kZSkpICsgXCIsXCIgK1xuICAgIFwiJGV2ZW50LmtleSxcIiArXG4gICAgXCJcIiArIChKU09OLnN0cmluZ2lmeShrZXlOYW1lKSkgK1xuICAgIFwiKVwiXG4gIClcbn1cblxuLyogICovXG5cbmZ1bmN0aW9uIG9uIChlbCwgZGlyKSB7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIGRpci5tb2RpZmllcnMpIHtcbiAgICB3YXJuKFwidi1vbiB3aXRob3V0IGFyZ3VtZW50IGRvZXMgbm90IHN1cHBvcnQgbW9kaWZpZXJzLlwiKTtcbiAgfVxuICBlbC53cmFwTGlzdGVuZXJzID0gZnVuY3Rpb24gKGNvZGUpIHsgcmV0dXJuIChcIl9nKFwiICsgY29kZSArIFwiLFwiICsgKGRpci52YWx1ZSkgKyBcIilcIik7IH07XG59XG5cbi8qICAqL1xuXG5mdW5jdGlvbiBiaW5kJDEgKGVsLCBkaXIpIHtcbiAgZWwud3JhcERhdGEgPSBmdW5jdGlvbiAoY29kZSkge1xuICAgIHJldHVybiAoXCJfYihcIiArIGNvZGUgKyBcIiwnXCIgKyAoZWwudGFnKSArIFwiJyxcIiArIChkaXIudmFsdWUpICsgXCIsXCIgKyAoZGlyLm1vZGlmaWVycyAmJiBkaXIubW9kaWZpZXJzLnByb3AgPyAndHJ1ZScgOiAnZmFsc2UnKSArIChkaXIubW9kaWZpZXJzICYmIGRpci5tb2RpZmllcnMuc3luYyA/ICcsdHJ1ZScgOiAnJykgKyBcIilcIilcbiAgfTtcbn1cblxuLyogICovXG5cbnZhciBiYXNlRGlyZWN0aXZlcyA9IHtcbiAgb246IG9uLFxuICBiaW5kOiBiaW5kJDEsXG4gIGNsb2FrOiBub29wXG59O1xuXG4vKiAgKi9cblxuXG5cblxuXG52YXIgQ29kZWdlblN0YXRlID0gZnVuY3Rpb24gQ29kZWdlblN0YXRlIChvcHRpb25zKSB7XG4gIHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG4gIHRoaXMud2FybiA9IG9wdGlvbnMud2FybiB8fCBiYXNlV2FybjtcbiAgdGhpcy50cmFuc2Zvcm1zID0gcGx1Y2tNb2R1bGVGdW5jdGlvbihvcHRpb25zLm1vZHVsZXMsICd0cmFuc2Zvcm1Db2RlJyk7XG4gIHRoaXMuZGF0YUdlbkZucyA9IHBsdWNrTW9kdWxlRnVuY3Rpb24ob3B0aW9ucy5tb2R1bGVzLCAnZ2VuRGF0YScpO1xuICB0aGlzLmRpcmVjdGl2ZXMgPSBleHRlbmQoZXh0ZW5kKHt9LCBiYXNlRGlyZWN0aXZlcyksIG9wdGlvbnMuZGlyZWN0aXZlcyk7XG4gIHZhciBpc1Jlc2VydmVkVGFnID0gb3B0aW9ucy5pc1Jlc2VydmVkVGFnIHx8IG5vO1xuICB0aGlzLm1heWJlQ29tcG9uZW50ID0gZnVuY3Rpb24gKGVsKSB7IHJldHVybiAhIWVsLmNvbXBvbmVudCB8fCAhaXNSZXNlcnZlZFRhZyhlbC50YWcpOyB9O1xuICB0aGlzLm9uY2VJZCA9IDA7XG4gIHRoaXMuc3RhdGljUmVuZGVyRm5zID0gW107XG4gIHRoaXMucHJlID0gZmFsc2U7XG59O1xuXG5cblxuZnVuY3Rpb24gZ2VuZXJhdGUgKFxuICBhc3QsXG4gIG9wdGlvbnNcbikge1xuICB2YXIgc3RhdGUgPSBuZXcgQ29kZWdlblN0YXRlKG9wdGlvbnMpO1xuICAvLyBmaXggIzExNDgzLCBSb290IGxldmVsIDxzY3JpcHQ+IHRhZ3Mgc2hvdWxkIG5vdCBiZSByZW5kZXJlZC5cbiAgdmFyIGNvZGUgPSBhc3QgPyAoYXN0LnRhZyA9PT0gJ3NjcmlwdCcgPyAnbnVsbCcgOiBnZW5FbGVtZW50KGFzdCwgc3RhdGUpKSA6ICdfYyhcImRpdlwiKSc7XG4gIHJldHVybiB7XG4gICAgcmVuZGVyOiAoXCJ3aXRoKHRoaXMpe3JldHVybiBcIiArIGNvZGUgKyBcIn1cIiksXG4gICAgc3RhdGljUmVuZGVyRm5zOiBzdGF0ZS5zdGF0aWNSZW5kZXJGbnNcbiAgfVxufVxuXG5mdW5jdGlvbiBnZW5FbGVtZW50IChlbCwgc3RhdGUpIHtcbiAgaWYgKGVsLnBhcmVudCkge1xuICAgIGVsLnByZSA9IGVsLnByZSB8fCBlbC5wYXJlbnQucHJlO1xuICB9XG5cbiAgaWYgKGVsLnN0YXRpY1Jvb3QgJiYgIWVsLnN0YXRpY1Byb2Nlc3NlZCkge1xuICAgIHJldHVybiBnZW5TdGF0aWMoZWwsIHN0YXRlKVxuICB9IGVsc2UgaWYgKGVsLm9uY2UgJiYgIWVsLm9uY2VQcm9jZXNzZWQpIHtcbiAgICByZXR1cm4gZ2VuT25jZShlbCwgc3RhdGUpXG4gIH0gZWxzZSBpZiAoZWwuZm9yICYmICFlbC5mb3JQcm9jZXNzZWQpIHtcbiAgICByZXR1cm4gZ2VuRm9yKGVsLCBzdGF0ZSlcbiAgfSBlbHNlIGlmIChlbC5pZiAmJiAhZWwuaWZQcm9jZXNzZWQpIHtcbiAgICByZXR1cm4gZ2VuSWYoZWwsIHN0YXRlKVxuICB9IGVsc2UgaWYgKGVsLnRhZyA9PT0gJ3RlbXBsYXRlJyAmJiAhZWwuc2xvdFRhcmdldCAmJiAhc3RhdGUucHJlKSB7XG4gICAgcmV0dXJuIGdlbkNoaWxkcmVuKGVsLCBzdGF0ZSkgfHwgJ3ZvaWQgMCdcbiAgfSBlbHNlIGlmIChlbC50YWcgPT09ICdzbG90Jykge1xuICAgIHJldHVybiBnZW5TbG90KGVsLCBzdGF0ZSlcbiAgfSBlbHNlIHtcbiAgICAvLyBjb21wb25lbnQgb3IgZWxlbWVudFxuICAgIHZhciBjb2RlO1xuICAgIGlmIChlbC5jb21wb25lbnQpIHtcbiAgICAgIGNvZGUgPSBnZW5Db21wb25lbnQoZWwuY29tcG9uZW50LCBlbCwgc3RhdGUpO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgZGF0YTtcbiAgICAgIGlmICghZWwucGxhaW4gfHwgKGVsLnByZSAmJiBzdGF0ZS5tYXliZUNvbXBvbmVudChlbCkpKSB7XG4gICAgICAgIGRhdGEgPSBnZW5EYXRhJDIoZWwsIHN0YXRlKTtcbiAgICAgIH1cblxuICAgICAgdmFyIGNoaWxkcmVuID0gZWwuaW5saW5lVGVtcGxhdGUgPyBudWxsIDogZ2VuQ2hpbGRyZW4oZWwsIHN0YXRlLCB0cnVlKTtcbiAgICAgIGNvZGUgPSBcIl9jKCdcIiArIChlbC50YWcpICsgXCInXCIgKyAoZGF0YSA/IChcIixcIiArIGRhdGEpIDogJycpICsgKGNoaWxkcmVuID8gKFwiLFwiICsgY2hpbGRyZW4pIDogJycpICsgXCIpXCI7XG4gICAgfVxuICAgIC8vIG1vZHVsZSB0cmFuc2Zvcm1zXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdGF0ZS50cmFuc2Zvcm1zLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb2RlID0gc3RhdGUudHJhbnNmb3Jtc1tpXShlbCwgY29kZSk7XG4gICAgfVxuICAgIHJldHVybiBjb2RlXG4gIH1cbn1cblxuLy8gaG9pc3Qgc3RhdGljIHN1Yi10cmVlcyBvdXRcbmZ1bmN0aW9uIGdlblN0YXRpYyAoZWwsIHN0YXRlKSB7XG4gIGVsLnN0YXRpY1Byb2Nlc3NlZCA9IHRydWU7XG4gIC8vIFNvbWUgZWxlbWVudHMgKHRlbXBsYXRlcykgbmVlZCB0byBiZWhhdmUgZGlmZmVyZW50bHkgaW5zaWRlIG9mIGEgdi1wcmVcbiAgLy8gbm9kZS4gIEFsbCBwcmUgbm9kZXMgYXJlIHN0YXRpYyByb290cywgc28gd2UgY2FuIHVzZSB0aGlzIGFzIGEgbG9jYXRpb24gdG9cbiAgLy8gd3JhcCBhIHN0YXRlIGNoYW5nZSBhbmQgcmVzZXQgaXQgdXBvbiBleGl0aW5nIHRoZSBwcmUgbm9kZS5cbiAgdmFyIG9yaWdpbmFsUHJlU3RhdGUgPSBzdGF0ZS5wcmU7XG4gIGlmIChlbC5wcmUpIHtcbiAgICBzdGF0ZS5wcmUgPSBlbC5wcmU7XG4gIH1cbiAgc3RhdGUuc3RhdGljUmVuZGVyRm5zLnB1c2goKFwid2l0aCh0aGlzKXtyZXR1cm4gXCIgKyAoZ2VuRWxlbWVudChlbCwgc3RhdGUpKSArIFwifVwiKSk7XG4gIHN0YXRlLnByZSA9IG9yaWdpbmFsUHJlU3RhdGU7XG4gIHJldHVybiAoXCJfbShcIiArIChzdGF0ZS5zdGF0aWNSZW5kZXJGbnMubGVuZ3RoIC0gMSkgKyAoZWwuc3RhdGljSW5Gb3IgPyAnLHRydWUnIDogJycpICsgXCIpXCIpXG59XG5cbi8vIHYtb25jZVxuZnVuY3Rpb24gZ2VuT25jZSAoZWwsIHN0YXRlKSB7XG4gIGVsLm9uY2VQcm9jZXNzZWQgPSB0cnVlO1xuICBpZiAoZWwuaWYgJiYgIWVsLmlmUHJvY2Vzc2VkKSB7XG4gICAgcmV0dXJuIGdlbklmKGVsLCBzdGF0ZSlcbiAgfSBlbHNlIGlmIChlbC5zdGF0aWNJbkZvcikge1xuICAgIHZhciBrZXkgPSAnJztcbiAgICB2YXIgcGFyZW50ID0gZWwucGFyZW50O1xuICAgIHdoaWxlIChwYXJlbnQpIHtcbiAgICAgIGlmIChwYXJlbnQuZm9yKSB7XG4gICAgICAgIGtleSA9IHBhcmVudC5rZXk7XG4gICAgICAgIGJyZWFrXG4gICAgICB9XG4gICAgICBwYXJlbnQgPSBwYXJlbnQucGFyZW50O1xuICAgIH1cbiAgICBpZiAoIWtleSkge1xuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiBzdGF0ZS53YXJuKFxuICAgICAgICBcInYtb25jZSBjYW4gb25seSBiZSB1c2VkIGluc2lkZSB2LWZvciB0aGF0IGlzIGtleWVkLiBcIixcbiAgICAgICAgZWwucmF3QXR0cnNNYXBbJ3Ytb25jZSddXG4gICAgICApO1xuICAgICAgcmV0dXJuIGdlbkVsZW1lbnQoZWwsIHN0YXRlKVxuICAgIH1cbiAgICByZXR1cm4gKFwiX28oXCIgKyAoZ2VuRWxlbWVudChlbCwgc3RhdGUpKSArIFwiLFwiICsgKHN0YXRlLm9uY2VJZCsrKSArIFwiLFwiICsga2V5ICsgXCIpXCIpXG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGdlblN0YXRpYyhlbCwgc3RhdGUpXG4gIH1cbn1cblxuZnVuY3Rpb24gZ2VuSWYgKFxuICBlbCxcbiAgc3RhdGUsXG4gIGFsdEdlbixcbiAgYWx0RW1wdHlcbikge1xuICBlbC5pZlByb2Nlc3NlZCA9IHRydWU7IC8vIGF2b2lkIHJlY3Vyc2lvblxuICByZXR1cm4gZ2VuSWZDb25kaXRpb25zKGVsLmlmQ29uZGl0aW9ucy5zbGljZSgpLCBzdGF0ZSwgYWx0R2VuLCBhbHRFbXB0eSlcbn1cblxuZnVuY3Rpb24gZ2VuSWZDb25kaXRpb25zIChcbiAgY29uZGl0aW9ucyxcbiAgc3RhdGUsXG4gIGFsdEdlbixcbiAgYWx0RW1wdHlcbikge1xuICBpZiAoIWNvbmRpdGlvbnMubGVuZ3RoKSB7XG4gICAgcmV0dXJuIGFsdEVtcHR5IHx8ICdfZSgpJ1xuICB9XG5cbiAgdmFyIGNvbmRpdGlvbiA9IGNvbmRpdGlvbnMuc2hpZnQoKTtcbiAgaWYgKGNvbmRpdGlvbi5leHApIHtcbiAgICByZXR1cm4gKFwiKFwiICsgKGNvbmRpdGlvbi5leHApICsgXCIpP1wiICsgKGdlblRlcm5hcnlFeHAoY29uZGl0aW9uLmJsb2NrKSkgKyBcIjpcIiArIChnZW5JZkNvbmRpdGlvbnMoY29uZGl0aW9ucywgc3RhdGUsIGFsdEdlbiwgYWx0RW1wdHkpKSlcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gKFwiXCIgKyAoZ2VuVGVybmFyeUV4cChjb25kaXRpb24uYmxvY2spKSlcbiAgfVxuXG4gIC8vIHYtaWYgd2l0aCB2LW9uY2Ugc2hvdWxkIGdlbmVyYXRlIGNvZGUgbGlrZSAoYSk/X20oMCk6X20oMSlcbiAgZnVuY3Rpb24gZ2VuVGVybmFyeUV4cCAoZWwpIHtcbiAgICByZXR1cm4gYWx0R2VuXG4gICAgICA/IGFsdEdlbihlbCwgc3RhdGUpXG4gICAgICA6IGVsLm9uY2VcbiAgICAgICAgPyBnZW5PbmNlKGVsLCBzdGF0ZSlcbiAgICAgICAgOiBnZW5FbGVtZW50KGVsLCBzdGF0ZSlcbiAgfVxufVxuXG5mdW5jdGlvbiBnZW5Gb3IgKFxuICBlbCxcbiAgc3RhdGUsXG4gIGFsdEdlbixcbiAgYWx0SGVscGVyXG4pIHtcbiAgdmFyIGV4cCA9IGVsLmZvcjtcbiAgdmFyIGFsaWFzID0gZWwuYWxpYXM7XG4gIHZhciBpdGVyYXRvcjEgPSBlbC5pdGVyYXRvcjEgPyAoXCIsXCIgKyAoZWwuaXRlcmF0b3IxKSkgOiAnJztcbiAgdmFyIGl0ZXJhdG9yMiA9IGVsLml0ZXJhdG9yMiA/IChcIixcIiArIChlbC5pdGVyYXRvcjIpKSA6ICcnO1xuXG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmXG4gICAgc3RhdGUubWF5YmVDb21wb25lbnQoZWwpICYmXG4gICAgZWwudGFnICE9PSAnc2xvdCcgJiZcbiAgICBlbC50YWcgIT09ICd0ZW1wbGF0ZScgJiZcbiAgICAhZWwua2V5XG4gICkge1xuICAgIHN0YXRlLndhcm4oXG4gICAgICBcIjxcIiArIChlbC50YWcpICsgXCIgdi1mb3I9XFxcIlwiICsgYWxpYXMgKyBcIiBpbiBcIiArIGV4cCArIFwiXFxcIj46IGNvbXBvbmVudCBsaXN0cyByZW5kZXJlZCB3aXRoIFwiICtcbiAgICAgIFwidi1mb3Igc2hvdWxkIGhhdmUgZXhwbGljaXQga2V5cy4gXCIgK1xuICAgICAgXCJTZWUgaHR0cHM6Ly92dWVqcy5vcmcvZ3VpZGUvbGlzdC5odG1sI2tleSBmb3IgbW9yZSBpbmZvLlwiLFxuICAgICAgZWwucmF3QXR0cnNNYXBbJ3YtZm9yJ10sXG4gICAgICB0cnVlIC8qIHRpcCAqL1xuICAgICk7XG4gIH1cblxuICBlbC5mb3JQcm9jZXNzZWQgPSB0cnVlOyAvLyBhdm9pZCByZWN1cnNpb25cbiAgcmV0dXJuIChhbHRIZWxwZXIgfHwgJ19sJykgKyBcIigoXCIgKyBleHAgKyBcIiksXCIgK1xuICAgIFwiZnVuY3Rpb24oXCIgKyBhbGlhcyArIGl0ZXJhdG9yMSArIGl0ZXJhdG9yMiArIFwiKXtcIiArXG4gICAgICBcInJldHVybiBcIiArICgoYWx0R2VuIHx8IGdlbkVsZW1lbnQpKGVsLCBzdGF0ZSkpICtcbiAgICAnfSknXG59XG5cbmZ1bmN0aW9uIGdlbkRhdGEkMiAoZWwsIHN0YXRlKSB7XG4gIHZhciBkYXRhID0gJ3snO1xuXG4gIC8vIGRpcmVjdGl2ZXMgZmlyc3QuXG4gIC8vIGRpcmVjdGl2ZXMgbWF5IG11dGF0ZSB0aGUgZWwncyBvdGhlciBwcm9wZXJ0aWVzIGJlZm9yZSB0aGV5IGFyZSBnZW5lcmF0ZWQuXG4gIHZhciBkaXJzID0gZ2VuRGlyZWN0aXZlcyhlbCwgc3RhdGUpO1xuICBpZiAoZGlycykgeyBkYXRhICs9IGRpcnMgKyAnLCc7IH1cblxuICAvLyBrZXlcbiAgaWYgKGVsLmtleSkge1xuICAgIGRhdGEgKz0gXCJrZXk6XCIgKyAoZWwua2V5KSArIFwiLFwiO1xuICB9XG4gIC8vIHJlZlxuICBpZiAoZWwucmVmKSB7XG4gICAgZGF0YSArPSBcInJlZjpcIiArIChlbC5yZWYpICsgXCIsXCI7XG4gIH1cbiAgaWYgKGVsLnJlZkluRm9yKSB7XG4gICAgZGF0YSArPSBcInJlZkluRm9yOnRydWUsXCI7XG4gIH1cbiAgLy8gcHJlXG4gIGlmIChlbC5wcmUpIHtcbiAgICBkYXRhICs9IFwicHJlOnRydWUsXCI7XG4gIH1cbiAgLy8gcmVjb3JkIG9yaWdpbmFsIHRhZyBuYW1lIGZvciBjb21wb25lbnRzIHVzaW5nIFwiaXNcIiBhdHRyaWJ1dGVcbiAgaWYgKGVsLmNvbXBvbmVudCkge1xuICAgIGRhdGEgKz0gXCJ0YWc6XFxcIlwiICsgKGVsLnRhZykgKyBcIlxcXCIsXCI7XG4gIH1cbiAgLy8gbW9kdWxlIGRhdGEgZ2VuZXJhdGlvbiBmdW5jdGlvbnNcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdGF0ZS5kYXRhR2VuRm5zLmxlbmd0aDsgaSsrKSB7XG4gICAgZGF0YSArPSBzdGF0ZS5kYXRhR2VuRm5zW2ldKGVsKTtcbiAgfVxuICAvLyBhdHRyaWJ1dGVzXG4gIGlmIChlbC5hdHRycykge1xuICAgIGRhdGEgKz0gXCJhdHRyczpcIiArIChnZW5Qcm9wcyhlbC5hdHRycykpICsgXCIsXCI7XG4gIH1cbiAgLy8gRE9NIHByb3BzXG4gIGlmIChlbC5wcm9wcykge1xuICAgIGRhdGEgKz0gXCJkb21Qcm9wczpcIiArIChnZW5Qcm9wcyhlbC5wcm9wcykpICsgXCIsXCI7XG4gIH1cbiAgLy8gZXZlbnQgaGFuZGxlcnNcbiAgaWYgKGVsLmV2ZW50cykge1xuICAgIGRhdGEgKz0gKGdlbkhhbmRsZXJzKGVsLmV2ZW50cywgZmFsc2UpKSArIFwiLFwiO1xuICB9XG4gIGlmIChlbC5uYXRpdmVFdmVudHMpIHtcbiAgICBkYXRhICs9IChnZW5IYW5kbGVycyhlbC5uYXRpdmVFdmVudHMsIHRydWUpKSArIFwiLFwiO1xuICB9XG4gIC8vIHNsb3QgdGFyZ2V0XG4gIC8vIG9ubHkgZm9yIG5vbi1zY29wZWQgc2xvdHNcbiAgaWYgKGVsLnNsb3RUYXJnZXQgJiYgIWVsLnNsb3RTY29wZSkge1xuICAgIGRhdGEgKz0gXCJzbG90OlwiICsgKGVsLnNsb3RUYXJnZXQpICsgXCIsXCI7XG4gIH1cbiAgLy8gc2NvcGVkIHNsb3RzXG4gIGlmIChlbC5zY29wZWRTbG90cykge1xuICAgIGRhdGEgKz0gKGdlblNjb3BlZFNsb3RzKGVsLCBlbC5zY29wZWRTbG90cywgc3RhdGUpKSArIFwiLFwiO1xuICB9XG4gIC8vIGNvbXBvbmVudCB2LW1vZGVsXG4gIGlmIChlbC5tb2RlbCkge1xuICAgIGRhdGEgKz0gXCJtb2RlbDp7dmFsdWU6XCIgKyAoZWwubW9kZWwudmFsdWUpICsgXCIsY2FsbGJhY2s6XCIgKyAoZWwubW9kZWwuY2FsbGJhY2spICsgXCIsZXhwcmVzc2lvbjpcIiArIChlbC5tb2RlbC5leHByZXNzaW9uKSArIFwifSxcIjtcbiAgfVxuICAvLyBpbmxpbmUtdGVtcGxhdGVcbiAgaWYgKGVsLmlubGluZVRlbXBsYXRlKSB7XG4gICAgdmFyIGlubGluZVRlbXBsYXRlID0gZ2VuSW5saW5lVGVtcGxhdGUoZWwsIHN0YXRlKTtcbiAgICBpZiAoaW5saW5lVGVtcGxhdGUpIHtcbiAgICAgIGRhdGEgKz0gaW5saW5lVGVtcGxhdGUgKyBcIixcIjtcbiAgICB9XG4gIH1cbiAgZGF0YSA9IGRhdGEucmVwbGFjZSgvLCQvLCAnJykgKyAnfSc7XG4gIC8vIHYtYmluZCBkeW5hbWljIGFyZ3VtZW50IHdyYXBcbiAgLy8gdi1iaW5kIHdpdGggZHluYW1pYyBhcmd1bWVudHMgbXVzdCBiZSBhcHBsaWVkIHVzaW5nIHRoZSBzYW1lIHYtYmluZCBvYmplY3RcbiAgLy8gbWVyZ2UgaGVscGVyIHNvIHRoYXQgY2xhc3Mvc3R5bGUvbXVzdFVzZVByb3AgYXR0cnMgYXJlIGhhbmRsZWQgY29ycmVjdGx5LlxuICBpZiAoZWwuZHluYW1pY0F0dHJzKSB7XG4gICAgZGF0YSA9IFwiX2IoXCIgKyBkYXRhICsgXCIsXFxcIlwiICsgKGVsLnRhZykgKyBcIlxcXCIsXCIgKyAoZ2VuUHJvcHMoZWwuZHluYW1pY0F0dHJzKSkgKyBcIilcIjtcbiAgfVxuICAvLyB2LWJpbmQgZGF0YSB3cmFwXG4gIGlmIChlbC53cmFwRGF0YSkge1xuICAgIGRhdGEgPSBlbC53cmFwRGF0YShkYXRhKTtcbiAgfVxuICAvLyB2LW9uIGRhdGEgd3JhcFxuICBpZiAoZWwud3JhcExpc3RlbmVycykge1xuICAgIGRhdGEgPSBlbC53cmFwTGlzdGVuZXJzKGRhdGEpO1xuICB9XG4gIHJldHVybiBkYXRhXG59XG5cbmZ1bmN0aW9uIGdlbkRpcmVjdGl2ZXMgKGVsLCBzdGF0ZSkge1xuICB2YXIgZGlycyA9IGVsLmRpcmVjdGl2ZXM7XG4gIGlmICghZGlycykgeyByZXR1cm4gfVxuICB2YXIgcmVzID0gJ2RpcmVjdGl2ZXM6Wyc7XG4gIHZhciBoYXNSdW50aW1lID0gZmFsc2U7XG4gIHZhciBpLCBsLCBkaXIsIG5lZWRSdW50aW1lO1xuICBmb3IgKGkgPSAwLCBsID0gZGlycy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICBkaXIgPSBkaXJzW2ldO1xuICAgIG5lZWRSdW50aW1lID0gdHJ1ZTtcbiAgICB2YXIgZ2VuID0gc3RhdGUuZGlyZWN0aXZlc1tkaXIubmFtZV07XG4gICAgaWYgKGdlbikge1xuICAgICAgLy8gY29tcGlsZS10aW1lIGRpcmVjdGl2ZSB0aGF0IG1hbmlwdWxhdGVzIEFTVC5cbiAgICAgIC8vIHJldHVybnMgdHJ1ZSBpZiBpdCBhbHNvIG5lZWRzIGEgcnVudGltZSBjb3VudGVycGFydC5cbiAgICAgIG5lZWRSdW50aW1lID0gISFnZW4oZWwsIGRpciwgc3RhdGUud2Fybik7XG4gICAgfVxuICAgIGlmIChuZWVkUnVudGltZSkge1xuICAgICAgaGFzUnVudGltZSA9IHRydWU7XG4gICAgICByZXMgKz0gXCJ7bmFtZTpcXFwiXCIgKyAoZGlyLm5hbWUpICsgXCJcXFwiLHJhd05hbWU6XFxcIlwiICsgKGRpci5yYXdOYW1lKSArIFwiXFxcIlwiICsgKGRpci52YWx1ZSA/IChcIix2YWx1ZTooXCIgKyAoZGlyLnZhbHVlKSArIFwiKSxleHByZXNzaW9uOlwiICsgKEpTT04uc3RyaW5naWZ5KGRpci52YWx1ZSkpKSA6ICcnKSArIChkaXIuYXJnID8gKFwiLGFyZzpcIiArIChkaXIuaXNEeW5hbWljQXJnID8gZGlyLmFyZyA6IChcIlxcXCJcIiArIChkaXIuYXJnKSArIFwiXFxcIlwiKSkpIDogJycpICsgKGRpci5tb2RpZmllcnMgPyAoXCIsbW9kaWZpZXJzOlwiICsgKEpTT04uc3RyaW5naWZ5KGRpci5tb2RpZmllcnMpKSkgOiAnJykgKyBcIn0sXCI7XG4gICAgfVxuICB9XG4gIGlmIChoYXNSdW50aW1lKSB7XG4gICAgcmV0dXJuIHJlcy5zbGljZSgwLCAtMSkgKyAnXSdcbiAgfVxufVxuXG5mdW5jdGlvbiBnZW5JbmxpbmVUZW1wbGF0ZSAoZWwsIHN0YXRlKSB7XG4gIHZhciBhc3QgPSBlbC5jaGlsZHJlblswXTtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgKFxuICAgIGVsLmNoaWxkcmVuLmxlbmd0aCAhPT0gMSB8fCBhc3QudHlwZSAhPT0gMVxuICApKSB7XG4gICAgc3RhdGUud2FybihcbiAgICAgICdJbmxpbmUtdGVtcGxhdGUgY29tcG9uZW50cyBtdXN0IGhhdmUgZXhhY3RseSBvbmUgY2hpbGQgZWxlbWVudC4nLFxuICAgICAgeyBzdGFydDogZWwuc3RhcnQgfVxuICAgICk7XG4gIH1cbiAgaWYgKGFzdCAmJiBhc3QudHlwZSA9PT0gMSkge1xuICAgIHZhciBpbmxpbmVSZW5kZXJGbnMgPSBnZW5lcmF0ZShhc3QsIHN0YXRlLm9wdGlvbnMpO1xuICAgIHJldHVybiAoXCJpbmxpbmVUZW1wbGF0ZTp7cmVuZGVyOmZ1bmN0aW9uKCl7XCIgKyAoaW5saW5lUmVuZGVyRm5zLnJlbmRlcikgKyBcIn0sc3RhdGljUmVuZGVyRm5zOltcIiArIChpbmxpbmVSZW5kZXJGbnMuc3RhdGljUmVuZGVyRm5zLm1hcChmdW5jdGlvbiAoY29kZSkgeyByZXR1cm4gKFwiZnVuY3Rpb24oKXtcIiArIGNvZGUgKyBcIn1cIik7IH0pLmpvaW4oJywnKSkgKyBcIl19XCIpXG4gIH1cbn1cblxuZnVuY3Rpb24gZ2VuU2NvcGVkU2xvdHMgKFxuICBlbCxcbiAgc2xvdHMsXG4gIHN0YXRlXG4pIHtcbiAgLy8gYnkgZGVmYXVsdCBzY29wZWQgc2xvdHMgYXJlIGNvbnNpZGVyZWQgXCJzdGFibGVcIiwgdGhpcyBhbGxvd3MgY2hpbGRcbiAgLy8gY29tcG9uZW50cyB3aXRoIG9ubHkgc2NvcGVkIHNsb3RzIHRvIHNraXAgZm9yY2VkIHVwZGF0ZXMgZnJvbSBwYXJlbnQuXG4gIC8vIGJ1dCBpbiBzb21lIGNhc2VzIHdlIGhhdmUgdG8gYmFpbC1vdXQgb2YgdGhpcyBvcHRpbWl6YXRpb25cbiAgLy8gZm9yIGV4YW1wbGUgaWYgdGhlIHNsb3QgY29udGFpbnMgZHluYW1pYyBuYW1lcywgaGFzIHYtaWYgb3Igdi1mb3Igb24gdGhlbS4uLlxuICB2YXIgbmVlZHNGb3JjZVVwZGF0ZSA9IGVsLmZvciB8fCBPYmplY3Qua2V5cyhzbG90cykuc29tZShmdW5jdGlvbiAoa2V5KSB7XG4gICAgdmFyIHNsb3QgPSBzbG90c1trZXldO1xuICAgIHJldHVybiAoXG4gICAgICBzbG90LnNsb3RUYXJnZXREeW5hbWljIHx8XG4gICAgICBzbG90LmlmIHx8XG4gICAgICBzbG90LmZvciB8fFxuICAgICAgY29udGFpbnNTbG90Q2hpbGQoc2xvdCkgLy8gaXMgcGFzc2luZyBkb3duIHNsb3QgZnJvbSBwYXJlbnQgd2hpY2ggbWF5IGJlIGR5bmFtaWNcbiAgICApXG4gIH0pO1xuXG4gIC8vICM5NTM0OiBpZiBhIGNvbXBvbmVudCB3aXRoIHNjb3BlZCBzbG90cyBpcyBpbnNpZGUgYSBjb25kaXRpb25hbCBicmFuY2gsXG4gIC8vIGl0J3MgcG9zc2libGUgZm9yIHRoZSBzYW1lIGNvbXBvbmVudCB0byBiZSByZXVzZWQgYnV0IHdpdGggZGlmZmVyZW50XG4gIC8vIGNvbXBpbGVkIHNsb3QgY29udGVudC4gVG8gYXZvaWQgdGhhdCwgd2UgZ2VuZXJhdGUgYSB1bmlxdWUga2V5IGJhc2VkIG9uXG4gIC8vIHRoZSBnZW5lcmF0ZWQgY29kZSBvZiBhbGwgdGhlIHNsb3QgY29udGVudHMuXG4gIHZhciBuZWVkc0tleSA9ICEhZWwuaWY7XG5cbiAgLy8gT1Igd2hlbiBpdCBpcyBpbnNpZGUgYW5vdGhlciBzY29wZWQgc2xvdCBvciB2LWZvciAodGhlIHJlYWN0aXZpdHkgbWF5IGJlXG4gIC8vIGRpc2Nvbm5lY3RlZCBkdWUgdG8gdGhlIGludGVybWVkaWF0ZSBzY29wZSB2YXJpYWJsZSlcbiAgLy8gIzk0MzgsICM5NTA2XG4gIC8vIFRPRE86IHRoaXMgY2FuIGJlIGZ1cnRoZXIgb3B0aW1pemVkIGJ5IHByb3Blcmx5IGFuYWx5emluZyBpbi1zY29wZSBiaW5kaW5nc1xuICAvLyBhbmQgc2tpcCBmb3JjZSB1cGRhdGluZyBvbmVzIHRoYXQgZG8gbm90IGFjdHVhbGx5IHVzZSBzY29wZSB2YXJpYWJsZXMuXG4gIGlmICghbmVlZHNGb3JjZVVwZGF0ZSkge1xuICAgIHZhciBwYXJlbnQgPSBlbC5wYXJlbnQ7XG4gICAgd2hpbGUgKHBhcmVudCkge1xuICAgICAgaWYgKFxuICAgICAgICAocGFyZW50LnNsb3RTY29wZSAmJiBwYXJlbnQuc2xvdFNjb3BlICE9PSBlbXB0eVNsb3RTY29wZVRva2VuKSB8fFxuICAgICAgICBwYXJlbnQuZm9yXG4gICAgICApIHtcbiAgICAgICAgbmVlZHNGb3JjZVVwZGF0ZSA9IHRydWU7XG4gICAgICAgIGJyZWFrXG4gICAgICB9XG4gICAgICBpZiAocGFyZW50LmlmKSB7XG4gICAgICAgIG5lZWRzS2V5ID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIHBhcmVudCA9IHBhcmVudC5wYXJlbnQ7XG4gICAgfVxuICB9XG5cbiAgdmFyIGdlbmVyYXRlZFNsb3RzID0gT2JqZWN0LmtleXMoc2xvdHMpXG4gICAgLm1hcChmdW5jdGlvbiAoa2V5KSB7IHJldHVybiBnZW5TY29wZWRTbG90KHNsb3RzW2tleV0sIHN0YXRlKTsgfSlcbiAgICAuam9pbignLCcpO1xuXG4gIHJldHVybiAoXCJzY29wZWRTbG90czpfdShbXCIgKyBnZW5lcmF0ZWRTbG90cyArIFwiXVwiICsgKG5lZWRzRm9yY2VVcGRhdGUgPyBcIixudWxsLHRydWVcIiA6IFwiXCIpICsgKCFuZWVkc0ZvcmNlVXBkYXRlICYmIG5lZWRzS2V5ID8gKFwiLG51bGwsZmFsc2UsXCIgKyAoaGFzaChnZW5lcmF0ZWRTbG90cykpKSA6IFwiXCIpICsgXCIpXCIpXG59XG5cbmZ1bmN0aW9uIGhhc2goc3RyKSB7XG4gIHZhciBoYXNoID0gNTM4MTtcbiAgdmFyIGkgPSBzdHIubGVuZ3RoO1xuICB3aGlsZShpKSB7XG4gICAgaGFzaCA9IChoYXNoICogMzMpIF4gc3RyLmNoYXJDb2RlQXQoLS1pKTtcbiAgfVxuICByZXR1cm4gaGFzaCA+Pj4gMFxufVxuXG5mdW5jdGlvbiBjb250YWluc1Nsb3RDaGlsZCAoZWwpIHtcbiAgaWYgKGVsLnR5cGUgPT09IDEpIHtcbiAgICBpZiAoZWwudGFnID09PSAnc2xvdCcpIHtcbiAgICAgIHJldHVybiB0cnVlXG4gICAgfVxuICAgIHJldHVybiBlbC5jaGlsZHJlbi5zb21lKGNvbnRhaW5zU2xvdENoaWxkKVxuICB9XG4gIHJldHVybiBmYWxzZVxufVxuXG5mdW5jdGlvbiBnZW5TY29wZWRTbG90IChcbiAgZWwsXG4gIHN0YXRlXG4pIHtcbiAgdmFyIGlzTGVnYWN5U3ludGF4ID0gZWwuYXR0cnNNYXBbJ3Nsb3Qtc2NvcGUnXTtcbiAgaWYgKGVsLmlmICYmICFlbC5pZlByb2Nlc3NlZCAmJiAhaXNMZWdhY3lTeW50YXgpIHtcbiAgICByZXR1cm4gZ2VuSWYoZWwsIHN0YXRlLCBnZW5TY29wZWRTbG90LCBcIm51bGxcIilcbiAgfVxuICBpZiAoZWwuZm9yICYmICFlbC5mb3JQcm9jZXNzZWQpIHtcbiAgICByZXR1cm4gZ2VuRm9yKGVsLCBzdGF0ZSwgZ2VuU2NvcGVkU2xvdClcbiAgfVxuICB2YXIgc2xvdFNjb3BlID0gZWwuc2xvdFNjb3BlID09PSBlbXB0eVNsb3RTY29wZVRva2VuXG4gICAgPyBcIlwiXG4gICAgOiBTdHJpbmcoZWwuc2xvdFNjb3BlKTtcbiAgdmFyIGZuID0gXCJmdW5jdGlvbihcIiArIHNsb3RTY29wZSArIFwiKXtcIiArXG4gICAgXCJyZXR1cm4gXCIgKyAoZWwudGFnID09PSAndGVtcGxhdGUnXG4gICAgICA/IGVsLmlmICYmIGlzTGVnYWN5U3ludGF4XG4gICAgICAgID8gKFwiKFwiICsgKGVsLmlmKSArIFwiKT9cIiArIChnZW5DaGlsZHJlbihlbCwgc3RhdGUpIHx8ICd1bmRlZmluZWQnKSArIFwiOnVuZGVmaW5lZFwiKVxuICAgICAgICA6IGdlbkNoaWxkcmVuKGVsLCBzdGF0ZSkgfHwgJ3VuZGVmaW5lZCdcbiAgICAgIDogZ2VuRWxlbWVudChlbCwgc3RhdGUpKSArIFwifVwiO1xuICAvLyByZXZlcnNlIHByb3h5IHYtc2xvdCB3aXRob3V0IHNjb3BlIG9uIHRoaXMuJHNsb3RzXG4gIHZhciByZXZlcnNlUHJveHkgPSBzbG90U2NvcGUgPyBcIlwiIDogXCIscHJveHk6dHJ1ZVwiO1xuICByZXR1cm4gKFwie2tleTpcIiArIChlbC5zbG90VGFyZ2V0IHx8IFwiXFxcImRlZmF1bHRcXFwiXCIpICsgXCIsZm46XCIgKyBmbiArIHJldmVyc2VQcm94eSArIFwifVwiKVxufVxuXG5mdW5jdGlvbiBnZW5DaGlsZHJlbiAoXG4gIGVsLFxuICBzdGF0ZSxcbiAgY2hlY2tTa2lwLFxuICBhbHRHZW5FbGVtZW50LFxuICBhbHRHZW5Ob2RlXG4pIHtcbiAgdmFyIGNoaWxkcmVuID0gZWwuY2hpbGRyZW47XG4gIGlmIChjaGlsZHJlbi5sZW5ndGgpIHtcbiAgICB2YXIgZWwkMSA9IGNoaWxkcmVuWzBdO1xuICAgIC8vIG9wdGltaXplIHNpbmdsZSB2LWZvclxuICAgIGlmIChjaGlsZHJlbi5sZW5ndGggPT09IDEgJiZcbiAgICAgIGVsJDEuZm9yICYmXG4gICAgICBlbCQxLnRhZyAhPT0gJ3RlbXBsYXRlJyAmJlxuICAgICAgZWwkMS50YWcgIT09ICdzbG90J1xuICAgICkge1xuICAgICAgdmFyIG5vcm1hbGl6YXRpb25UeXBlID0gY2hlY2tTa2lwXG4gICAgICAgID8gc3RhdGUubWF5YmVDb21wb25lbnQoZWwkMSkgPyBcIiwxXCIgOiBcIiwwXCJcbiAgICAgICAgOiBcIlwiO1xuICAgICAgcmV0dXJuIChcIlwiICsgKChhbHRHZW5FbGVtZW50IHx8IGdlbkVsZW1lbnQpKGVsJDEsIHN0YXRlKSkgKyBub3JtYWxpemF0aW9uVHlwZSlcbiAgICB9XG4gICAgdmFyIG5vcm1hbGl6YXRpb25UeXBlJDEgPSBjaGVja1NraXBcbiAgICAgID8gZ2V0Tm9ybWFsaXphdGlvblR5cGUoY2hpbGRyZW4sIHN0YXRlLm1heWJlQ29tcG9uZW50KVxuICAgICAgOiAwO1xuICAgIHZhciBnZW4gPSBhbHRHZW5Ob2RlIHx8IGdlbk5vZGU7XG4gICAgcmV0dXJuIChcIltcIiArIChjaGlsZHJlbi5tYXAoZnVuY3Rpb24gKGMpIHsgcmV0dXJuIGdlbihjLCBzdGF0ZSk7IH0pLmpvaW4oJywnKSkgKyBcIl1cIiArIChub3JtYWxpemF0aW9uVHlwZSQxID8gKFwiLFwiICsgbm9ybWFsaXphdGlvblR5cGUkMSkgOiAnJykpXG4gIH1cbn1cblxuLy8gZGV0ZXJtaW5lIHRoZSBub3JtYWxpemF0aW9uIG5lZWRlZCBmb3IgdGhlIGNoaWxkcmVuIGFycmF5LlxuLy8gMDogbm8gbm9ybWFsaXphdGlvbiBuZWVkZWRcbi8vIDE6IHNpbXBsZSBub3JtYWxpemF0aW9uIG5lZWRlZCAocG9zc2libGUgMS1sZXZlbCBkZWVwIG5lc3RlZCBhcnJheSlcbi8vIDI6IGZ1bGwgbm9ybWFsaXphdGlvbiBuZWVkZWRcbmZ1bmN0aW9uIGdldE5vcm1hbGl6YXRpb25UeXBlIChcbiAgY2hpbGRyZW4sXG4gIG1heWJlQ29tcG9uZW50XG4pIHtcbiAgdmFyIHJlcyA9IDA7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgZWwgPSBjaGlsZHJlbltpXTtcbiAgICBpZiAoZWwudHlwZSAhPT0gMSkge1xuICAgICAgY29udGludWVcbiAgICB9XG4gICAgaWYgKG5lZWRzTm9ybWFsaXphdGlvbihlbCkgfHxcbiAgICAgICAgKGVsLmlmQ29uZGl0aW9ucyAmJiBlbC5pZkNvbmRpdGlvbnMuc29tZShmdW5jdGlvbiAoYykgeyByZXR1cm4gbmVlZHNOb3JtYWxpemF0aW9uKGMuYmxvY2spOyB9KSkpIHtcbiAgICAgIHJlcyA9IDI7XG4gICAgICBicmVha1xuICAgIH1cbiAgICBpZiAobWF5YmVDb21wb25lbnQoZWwpIHx8XG4gICAgICAgIChlbC5pZkNvbmRpdGlvbnMgJiYgZWwuaWZDb25kaXRpb25zLnNvbWUoZnVuY3Rpb24gKGMpIHsgcmV0dXJuIG1heWJlQ29tcG9uZW50KGMuYmxvY2spOyB9KSkpIHtcbiAgICAgIHJlcyA9IDE7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXNcbn1cblxuZnVuY3Rpb24gbmVlZHNOb3JtYWxpemF0aW9uIChlbCkge1xuICByZXR1cm4gZWwuZm9yICE9PSB1bmRlZmluZWQgfHwgZWwudGFnID09PSAndGVtcGxhdGUnIHx8IGVsLnRhZyA9PT0gJ3Nsb3QnXG59XG5cbmZ1bmN0aW9uIGdlbk5vZGUgKG5vZGUsIHN0YXRlKSB7XG4gIGlmIChub2RlLnR5cGUgPT09IDEpIHtcbiAgICByZXR1cm4gZ2VuRWxlbWVudChub2RlLCBzdGF0ZSlcbiAgfSBlbHNlIGlmIChub2RlLnR5cGUgPT09IDMgJiYgbm9kZS5pc0NvbW1lbnQpIHtcbiAgICByZXR1cm4gZ2VuQ29tbWVudChub2RlKVxuICB9IGVsc2Uge1xuICAgIHJldHVybiBnZW5UZXh0KG5vZGUpXG4gIH1cbn1cblxuZnVuY3Rpb24gZ2VuVGV4dCAodGV4dCkge1xuICByZXR1cm4gKFwiX3YoXCIgKyAodGV4dC50eXBlID09PSAyXG4gICAgPyB0ZXh0LmV4cHJlc3Npb24gLy8gbm8gbmVlZCBmb3IgKCkgYmVjYXVzZSBhbHJlYWR5IHdyYXBwZWQgaW4gX3MoKVxuICAgIDogdHJhbnNmb3JtU3BlY2lhbE5ld2xpbmVzKEpTT04uc3RyaW5naWZ5KHRleHQudGV4dCkpKSArIFwiKVwiKVxufVxuXG5mdW5jdGlvbiBnZW5Db21tZW50IChjb21tZW50KSB7XG4gIHJldHVybiAoXCJfZShcIiArIChKU09OLnN0cmluZ2lmeShjb21tZW50LnRleHQpKSArIFwiKVwiKVxufVxuXG5mdW5jdGlvbiBnZW5TbG90IChlbCwgc3RhdGUpIHtcbiAgdmFyIHNsb3ROYW1lID0gZWwuc2xvdE5hbWUgfHwgJ1wiZGVmYXVsdFwiJztcbiAgdmFyIGNoaWxkcmVuID0gZ2VuQ2hpbGRyZW4oZWwsIHN0YXRlKTtcbiAgdmFyIHJlcyA9IFwiX3QoXCIgKyBzbG90TmFtZSArIChjaGlsZHJlbiA/IChcIixmdW5jdGlvbigpe3JldHVybiBcIiArIGNoaWxkcmVuICsgXCJ9XCIpIDogJycpO1xuICB2YXIgYXR0cnMgPSBlbC5hdHRycyB8fCBlbC5keW5hbWljQXR0cnNcbiAgICA/IGdlblByb3BzKChlbC5hdHRycyB8fCBbXSkuY29uY2F0KGVsLmR5bmFtaWNBdHRycyB8fCBbXSkubWFwKGZ1bmN0aW9uIChhdHRyKSB7IHJldHVybiAoe1xuICAgICAgICAvLyBzbG90IHByb3BzIGFyZSBjYW1lbGl6ZWRcbiAgICAgICAgbmFtZTogY2FtZWxpemUoYXR0ci5uYW1lKSxcbiAgICAgICAgdmFsdWU6IGF0dHIudmFsdWUsXG4gICAgICAgIGR5bmFtaWM6IGF0dHIuZHluYW1pY1xuICAgICAgfSk7IH0pKVxuICAgIDogbnVsbDtcbiAgdmFyIGJpbmQkJDEgPSBlbC5hdHRyc01hcFsndi1iaW5kJ107XG4gIGlmICgoYXR0cnMgfHwgYmluZCQkMSkgJiYgIWNoaWxkcmVuKSB7XG4gICAgcmVzICs9IFwiLG51bGxcIjtcbiAgfVxuICBpZiAoYXR0cnMpIHtcbiAgICByZXMgKz0gXCIsXCIgKyBhdHRycztcbiAgfVxuICBpZiAoYmluZCQkMSkge1xuICAgIHJlcyArPSAoYXR0cnMgPyAnJyA6ICcsbnVsbCcpICsgXCIsXCIgKyBiaW5kJCQxO1xuICB9XG4gIHJldHVybiByZXMgKyAnKSdcbn1cblxuLy8gY29tcG9uZW50TmFtZSBpcyBlbC5jb21wb25lbnQsIHRha2UgaXQgYXMgYXJndW1lbnQgdG8gc2h1biBmbG93J3MgcGVzc2ltaXN0aWMgcmVmaW5lbWVudFxuZnVuY3Rpb24gZ2VuQ29tcG9uZW50IChcbiAgY29tcG9uZW50TmFtZSxcbiAgZWwsXG4gIHN0YXRlXG4pIHtcbiAgdmFyIGNoaWxkcmVuID0gZWwuaW5saW5lVGVtcGxhdGUgPyBudWxsIDogZ2VuQ2hpbGRyZW4oZWwsIHN0YXRlLCB0cnVlKTtcbiAgcmV0dXJuIChcIl9jKFwiICsgY29tcG9uZW50TmFtZSArIFwiLFwiICsgKGdlbkRhdGEkMihlbCwgc3RhdGUpKSArIChjaGlsZHJlbiA/IChcIixcIiArIGNoaWxkcmVuKSA6ICcnKSArIFwiKVwiKVxufVxuXG5mdW5jdGlvbiBnZW5Qcm9wcyAocHJvcHMpIHtcbiAgdmFyIHN0YXRpY1Byb3BzID0gXCJcIjtcbiAgdmFyIGR5bmFtaWNQcm9wcyA9IFwiXCI7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgcHJvcCA9IHByb3BzW2ldO1xuICAgIHZhciB2YWx1ZSA9IHRyYW5zZm9ybVNwZWNpYWxOZXdsaW5lcyhwcm9wLnZhbHVlKTtcbiAgICBpZiAocHJvcC5keW5hbWljKSB7XG4gICAgICBkeW5hbWljUHJvcHMgKz0gKHByb3AubmFtZSkgKyBcIixcIiArIHZhbHVlICsgXCIsXCI7XG4gICAgfSBlbHNlIHtcbiAgICAgIHN0YXRpY1Byb3BzICs9IFwiXFxcIlwiICsgKHByb3AubmFtZSkgKyBcIlxcXCI6XCIgKyB2YWx1ZSArIFwiLFwiO1xuICAgIH1cbiAgfVxuICBzdGF0aWNQcm9wcyA9IFwie1wiICsgKHN0YXRpY1Byb3BzLnNsaWNlKDAsIC0xKSkgKyBcIn1cIjtcbiAgaWYgKGR5bmFtaWNQcm9wcykge1xuICAgIHJldHVybiAoXCJfZChcIiArIHN0YXRpY1Byb3BzICsgXCIsW1wiICsgKGR5bmFtaWNQcm9wcy5zbGljZSgwLCAtMSkpICsgXCJdKVwiKVxuICB9IGVsc2Uge1xuICAgIHJldHVybiBzdGF0aWNQcm9wc1xuICB9XG59XG5cbi8vICMzODk1LCAjNDI2OFxuZnVuY3Rpb24gdHJhbnNmb3JtU3BlY2lhbE5ld2xpbmVzICh0ZXh0KSB7XG4gIHJldHVybiB0ZXh0XG4gICAgLnJlcGxhY2UoL1xcdTIwMjgvZywgJ1xcXFx1MjAyOCcpXG4gICAgLnJlcGxhY2UoL1xcdTIwMjkvZywgJ1xcXFx1MjAyOScpXG59XG5cbi8qICAqL1xuXG5cblxuLy8gdGhlc2Uga2V5d29yZHMgc2hvdWxkIG5vdCBhcHBlYXIgaW5zaWRlIGV4cHJlc3Npb25zLCBidXQgb3BlcmF0b3JzIGxpa2Vcbi8vIHR5cGVvZiwgaW5zdGFuY2VvZiBhbmQgaW4gYXJlIGFsbG93ZWRcbnZhciBwcm9oaWJpdGVkS2V5d29yZFJFID0gbmV3IFJlZ0V4cCgnXFxcXGInICsgKFxuICAnZG8saWYsZm9yLGxldCxuZXcsdHJ5LHZhcixjYXNlLGVsc2Usd2l0aCxhd2FpdCxicmVhayxjYXRjaCxjbGFzcyxjb25zdCwnICtcbiAgJ3N1cGVyLHRocm93LHdoaWxlLHlpZWxkLGRlbGV0ZSxleHBvcnQsaW1wb3J0LHJldHVybixzd2l0Y2gsZGVmYXVsdCwnICtcbiAgJ2V4dGVuZHMsZmluYWxseSxjb250aW51ZSxkZWJ1Z2dlcixmdW5jdGlvbixhcmd1bWVudHMnXG4pLnNwbGl0KCcsJykuam9pbignXFxcXGJ8XFxcXGInKSArICdcXFxcYicpO1xuXG4vLyB0aGVzZSB1bmFyeSBvcGVyYXRvcnMgc2hvdWxkIG5vdCBiZSB1c2VkIGFzIHByb3BlcnR5L21ldGhvZCBuYW1lc1xudmFyIHVuYXJ5T3BlcmF0b3JzUkUgPSBuZXcgUmVnRXhwKCdcXFxcYicgKyAoXG4gICdkZWxldGUsdHlwZW9mLHZvaWQnXG4pLnNwbGl0KCcsJykuam9pbignXFxcXHMqXFxcXChbXlxcXFwpXSpcXFxcKXxcXFxcYicpICsgJ1xcXFxzKlxcXFwoW15cXFxcKV0qXFxcXCknKTtcblxuLy8gc3RyaXAgc3RyaW5ncyBpbiBleHByZXNzaW9uc1xudmFyIHN0cmlwU3RyaW5nUkUgPSAvJyg/OlteJ1xcXFxdfFxcXFwuKSonfFwiKD86W15cIlxcXFxdfFxcXFwuKSpcInxgKD86W15gXFxcXF18XFxcXC4pKlxcJFxce3xcXH0oPzpbXmBcXFxcXXxcXFxcLikqYHxgKD86W15gXFxcXF18XFxcXC4pKmAvZztcblxuLy8gZGV0ZWN0IHByb2JsZW1hdGljIGV4cHJlc3Npb25zIGluIGEgdGVtcGxhdGVcbmZ1bmN0aW9uIGRldGVjdEVycm9ycyAoYXN0LCB3YXJuKSB7XG4gIGlmIChhc3QpIHtcbiAgICBjaGVja05vZGUoYXN0LCB3YXJuKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBjaGVja05vZGUgKG5vZGUsIHdhcm4pIHtcbiAgaWYgKG5vZGUudHlwZSA9PT0gMSkge1xuICAgIGZvciAodmFyIG5hbWUgaW4gbm9kZS5hdHRyc01hcCkge1xuICAgICAgaWYgKGRpclJFLnRlc3QobmFtZSkpIHtcbiAgICAgICAgdmFyIHZhbHVlID0gbm9kZS5hdHRyc01hcFtuYW1lXTtcbiAgICAgICAgaWYgKHZhbHVlKSB7XG4gICAgICAgICAgdmFyIHJhbmdlID0gbm9kZS5yYXdBdHRyc01hcFtuYW1lXTtcbiAgICAgICAgICBpZiAobmFtZSA9PT0gJ3YtZm9yJykge1xuICAgICAgICAgICAgY2hlY2tGb3Iobm9kZSwgKFwidi1mb3I9XFxcIlwiICsgdmFsdWUgKyBcIlxcXCJcIiksIHdhcm4sIHJhbmdlKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKG5hbWUgPT09ICd2LXNsb3QnIHx8IG5hbWVbMF0gPT09ICcjJykge1xuICAgICAgICAgICAgY2hlY2tGdW5jdGlvblBhcmFtZXRlckV4cHJlc3Npb24odmFsdWUsIChuYW1lICsgXCI9XFxcIlwiICsgdmFsdWUgKyBcIlxcXCJcIiksIHdhcm4sIHJhbmdlKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKG9uUkUudGVzdChuYW1lKSkge1xuICAgICAgICAgICAgY2hlY2tFdmVudCh2YWx1ZSwgKG5hbWUgKyBcIj1cXFwiXCIgKyB2YWx1ZSArIFwiXFxcIlwiKSwgd2FybiwgcmFuZ2UpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjaGVja0V4cHJlc3Npb24odmFsdWUsIChuYW1lICsgXCI9XFxcIlwiICsgdmFsdWUgKyBcIlxcXCJcIiksIHdhcm4sIHJhbmdlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKG5vZGUuY2hpbGRyZW4pIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbm9kZS5jaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgICBjaGVja05vZGUobm9kZS5jaGlsZHJlbltpXSwgd2Fybik7XG4gICAgICB9XG4gICAgfVxuICB9IGVsc2UgaWYgKG5vZGUudHlwZSA9PT0gMikge1xuICAgIGNoZWNrRXhwcmVzc2lvbihub2RlLmV4cHJlc3Npb24sIG5vZGUudGV4dCwgd2Fybiwgbm9kZSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gY2hlY2tFdmVudCAoZXhwLCB0ZXh0LCB3YXJuLCByYW5nZSkge1xuICB2YXIgc3RyaXBwZWQgPSBleHAucmVwbGFjZShzdHJpcFN0cmluZ1JFLCAnJyk7XG4gIHZhciBrZXl3b3JkTWF0Y2ggPSBzdHJpcHBlZC5tYXRjaCh1bmFyeU9wZXJhdG9yc1JFKTtcbiAgaWYgKGtleXdvcmRNYXRjaCAmJiBzdHJpcHBlZC5jaGFyQXQoa2V5d29yZE1hdGNoLmluZGV4IC0gMSkgIT09ICckJykge1xuICAgIHdhcm4oXG4gICAgICBcImF2b2lkIHVzaW5nIEphdmFTY3JpcHQgdW5hcnkgb3BlcmF0b3IgYXMgcHJvcGVydHkgbmFtZTogXCIgK1xuICAgICAgXCJcXFwiXCIgKyAoa2V5d29yZE1hdGNoWzBdKSArIFwiXFxcIiBpbiBleHByZXNzaW9uIFwiICsgKHRleHQudHJpbSgpKSxcbiAgICAgIHJhbmdlXG4gICAgKTtcbiAgfVxuICBjaGVja0V4cHJlc3Npb24oZXhwLCB0ZXh0LCB3YXJuLCByYW5nZSk7XG59XG5cbmZ1bmN0aW9uIGNoZWNrRm9yIChub2RlLCB0ZXh0LCB3YXJuLCByYW5nZSkge1xuICBjaGVja0V4cHJlc3Npb24obm9kZS5mb3IgfHwgJycsIHRleHQsIHdhcm4sIHJhbmdlKTtcbiAgY2hlY2tJZGVudGlmaWVyKG5vZGUuYWxpYXMsICd2LWZvciBhbGlhcycsIHRleHQsIHdhcm4sIHJhbmdlKTtcbiAgY2hlY2tJZGVudGlmaWVyKG5vZGUuaXRlcmF0b3IxLCAndi1mb3IgaXRlcmF0b3InLCB0ZXh0LCB3YXJuLCByYW5nZSk7XG4gIGNoZWNrSWRlbnRpZmllcihub2RlLml0ZXJhdG9yMiwgJ3YtZm9yIGl0ZXJhdG9yJywgdGV4dCwgd2FybiwgcmFuZ2UpO1xufVxuXG5mdW5jdGlvbiBjaGVja0lkZW50aWZpZXIgKFxuICBpZGVudCxcbiAgdHlwZSxcbiAgdGV4dCxcbiAgd2FybixcbiAgcmFuZ2Vcbikge1xuICBpZiAodHlwZW9mIGlkZW50ID09PSAnc3RyaW5nJykge1xuICAgIHRyeSB7XG4gICAgICBuZXcgRnVuY3Rpb24oKFwidmFyIFwiICsgaWRlbnQgKyBcIj1fXCIpKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICB3YXJuKChcImludmFsaWQgXCIgKyB0eXBlICsgXCIgXFxcIlwiICsgaWRlbnQgKyBcIlxcXCIgaW4gZXhwcmVzc2lvbjogXCIgKyAodGV4dC50cmltKCkpKSwgcmFuZ2UpO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBjaGVja0V4cHJlc3Npb24gKGV4cCwgdGV4dCwgd2FybiwgcmFuZ2UpIHtcbiAgdHJ5IHtcbiAgICBuZXcgRnVuY3Rpb24oKFwicmV0dXJuIFwiICsgZXhwKSk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICB2YXIga2V5d29yZE1hdGNoID0gZXhwLnJlcGxhY2Uoc3RyaXBTdHJpbmdSRSwgJycpLm1hdGNoKHByb2hpYml0ZWRLZXl3b3JkUkUpO1xuICAgIGlmIChrZXl3b3JkTWF0Y2gpIHtcbiAgICAgIHdhcm4oXG4gICAgICAgIFwiYXZvaWQgdXNpbmcgSmF2YVNjcmlwdCBrZXl3b3JkIGFzIHByb3BlcnR5IG5hbWU6IFwiICtcbiAgICAgICAgXCJcXFwiXCIgKyAoa2V5d29yZE1hdGNoWzBdKSArIFwiXFxcIlxcbiAgUmF3IGV4cHJlc3Npb246IFwiICsgKHRleHQudHJpbSgpKSxcbiAgICAgICAgcmFuZ2VcbiAgICAgICk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHdhcm4oXG4gICAgICAgIFwiaW52YWxpZCBleHByZXNzaW9uOiBcIiArIChlLm1lc3NhZ2UpICsgXCIgaW5cXG5cXG5cIiArXG4gICAgICAgIFwiICAgIFwiICsgZXhwICsgXCJcXG5cXG5cIiArXG4gICAgICAgIFwiICBSYXcgZXhwcmVzc2lvbjogXCIgKyAodGV4dC50cmltKCkpICsgXCJcXG5cIixcbiAgICAgICAgcmFuZ2VcbiAgICAgICk7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGNoZWNrRnVuY3Rpb25QYXJhbWV0ZXJFeHByZXNzaW9uIChleHAsIHRleHQsIHdhcm4sIHJhbmdlKSB7XG4gIHRyeSB7XG4gICAgbmV3IEZ1bmN0aW9uKGV4cCwgJycpO1xuICB9IGNhdGNoIChlKSB7XG4gICAgd2FybihcbiAgICAgIFwiaW52YWxpZCBmdW5jdGlvbiBwYXJhbWV0ZXIgZXhwcmVzc2lvbjogXCIgKyAoZS5tZXNzYWdlKSArIFwiIGluXFxuXFxuXCIgK1xuICAgICAgXCIgICAgXCIgKyBleHAgKyBcIlxcblxcblwiICtcbiAgICAgIFwiICBSYXcgZXhwcmVzc2lvbjogXCIgKyAodGV4dC50cmltKCkpICsgXCJcXG5cIixcbiAgICAgIHJhbmdlXG4gICAgKTtcbiAgfVxufVxuXG4vKiAgKi9cblxudmFyIHJhbmdlID0gMjtcblxuZnVuY3Rpb24gZ2VuZXJhdGVDb2RlRnJhbWUgKFxuICBzb3VyY2UsXG4gIHN0YXJ0LFxuICBlbmRcbikge1xuICBpZiAoIHN0YXJ0ID09PSB2b2lkIDAgKSBzdGFydCA9IDA7XG4gIGlmICggZW5kID09PSB2b2lkIDAgKSBlbmQgPSBzb3VyY2UubGVuZ3RoO1xuXG4gIHZhciBsaW5lcyA9IHNvdXJjZS5zcGxpdCgvXFxyP1xcbi8pO1xuICB2YXIgY291bnQgPSAwO1xuICB2YXIgcmVzID0gW107XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGluZXMubGVuZ3RoOyBpKyspIHtcbiAgICBjb3VudCArPSBsaW5lc1tpXS5sZW5ndGggKyAxO1xuICAgIGlmIChjb3VudCA+PSBzdGFydCkge1xuICAgICAgZm9yICh2YXIgaiA9IGkgLSByYW5nZTsgaiA8PSBpICsgcmFuZ2UgfHwgZW5kID4gY291bnQ7IGorKykge1xuICAgICAgICBpZiAoaiA8IDAgfHwgaiA+PSBsaW5lcy5sZW5ndGgpIHsgY29udGludWUgfVxuICAgICAgICByZXMucHVzaCgoXCJcIiArIChqICsgMSkgKyAocmVwZWF0JDEoXCIgXCIsIDMgLSBTdHJpbmcoaiArIDEpLmxlbmd0aCkpICsgXCJ8ICBcIiArIChsaW5lc1tqXSkpKTtcbiAgICAgICAgdmFyIGxpbmVMZW5ndGggPSBsaW5lc1tqXS5sZW5ndGg7XG4gICAgICAgIGlmIChqID09PSBpKSB7XG4gICAgICAgICAgLy8gcHVzaCB1bmRlcmxpbmVcbiAgICAgICAgICB2YXIgcGFkID0gc3RhcnQgLSAoY291bnQgLSBsaW5lTGVuZ3RoKSArIDE7XG4gICAgICAgICAgdmFyIGxlbmd0aCA9IGVuZCA+IGNvdW50ID8gbGluZUxlbmd0aCAtIHBhZCA6IGVuZCAtIHN0YXJ0O1xuICAgICAgICAgIHJlcy5wdXNoKFwiICAgfCAgXCIgKyByZXBlYXQkMShcIiBcIiwgcGFkKSArIHJlcGVhdCQxKFwiXlwiLCBsZW5ndGgpKTtcbiAgICAgICAgfSBlbHNlIGlmIChqID4gaSkge1xuICAgICAgICAgIGlmIChlbmQgPiBjb3VudCkge1xuICAgICAgICAgICAgdmFyIGxlbmd0aCQxID0gTWF0aC5taW4oZW5kIC0gY291bnQsIGxpbmVMZW5ndGgpO1xuICAgICAgICAgICAgcmVzLnB1c2goXCIgICB8ICBcIiArIHJlcGVhdCQxKFwiXlwiLCBsZW5ndGgkMSkpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjb3VudCArPSBsaW5lTGVuZ3RoICsgMTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgYnJlYWtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlcy5qb2luKCdcXG4nKVxufVxuXG5mdW5jdGlvbiByZXBlYXQkMSAoc3RyLCBuKSB7XG4gIHZhciByZXN1bHQgPSAnJztcbiAgaWYgKG4gPiAwKSB7XG4gICAgd2hpbGUgKHRydWUpIHsgLy8gZXNsaW50LWRpc2FibGUtbGluZVxuICAgICAgaWYgKG4gJiAxKSB7IHJlc3VsdCArPSBzdHI7IH1cbiAgICAgIG4gPj4+PSAxO1xuICAgICAgaWYgKG4gPD0gMCkgeyBicmVhayB9XG4gICAgICBzdHIgKz0gc3RyO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzdWx0XG59XG5cbi8qICAqL1xuXG5cblxuZnVuY3Rpb24gY3JlYXRlRnVuY3Rpb24gKGNvZGUsIGVycm9ycykge1xuICB0cnkge1xuICAgIHJldHVybiBuZXcgRnVuY3Rpb24oY29kZSlcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgZXJyb3JzLnB1c2goeyBlcnI6IGVyciwgY29kZTogY29kZSB9KTtcbiAgICByZXR1cm4gbm9vcFxuICB9XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUNvbXBpbGVUb0Z1bmN0aW9uRm4gKGNvbXBpbGUpIHtcbiAgdmFyIGNhY2hlID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcblxuICByZXR1cm4gZnVuY3Rpb24gY29tcGlsZVRvRnVuY3Rpb25zIChcbiAgICB0ZW1wbGF0ZSxcbiAgICBvcHRpb25zLFxuICAgIHZtXG4gICkge1xuICAgIG9wdGlvbnMgPSBleHRlbmQoe30sIG9wdGlvbnMpO1xuICAgIHZhciB3YXJuJCQxID0gb3B0aW9ucy53YXJuIHx8IHdhcm47XG4gICAgZGVsZXRlIG9wdGlvbnMud2FybjtcblxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAvLyBkZXRlY3QgcG9zc2libGUgQ1NQIHJlc3RyaWN0aW9uXG4gICAgICB0cnkge1xuICAgICAgICBuZXcgRnVuY3Rpb24oJ3JldHVybiAxJyk7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGlmIChlLnRvU3RyaW5nKCkubWF0Y2goL3Vuc2FmZS1ldmFsfENTUC8pKSB7XG4gICAgICAgICAgd2FybiQkMShcbiAgICAgICAgICAgICdJdCBzZWVtcyB5b3UgYXJlIHVzaW5nIHRoZSBzdGFuZGFsb25lIGJ1aWxkIG9mIFZ1ZS5qcyBpbiBhbiAnICtcbiAgICAgICAgICAgICdlbnZpcm9ubWVudCB3aXRoIENvbnRlbnQgU2VjdXJpdHkgUG9saWN5IHRoYXQgcHJvaGliaXRzIHVuc2FmZS1ldmFsLiAnICtcbiAgICAgICAgICAgICdUaGUgdGVtcGxhdGUgY29tcGlsZXIgY2Fubm90IHdvcmsgaW4gdGhpcyBlbnZpcm9ubWVudC4gQ29uc2lkZXIgJyArXG4gICAgICAgICAgICAncmVsYXhpbmcgdGhlIHBvbGljeSB0byBhbGxvdyB1bnNhZmUtZXZhbCBvciBwcmUtY29tcGlsaW5nIHlvdXIgJyArXG4gICAgICAgICAgICAndGVtcGxhdGVzIGludG8gcmVuZGVyIGZ1bmN0aW9ucy4nXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIC8vIGNoZWNrIGNhY2hlXG4gICAgdmFyIGtleSA9IG9wdGlvbnMuZGVsaW1pdGVyc1xuICAgICAgPyBTdHJpbmcob3B0aW9ucy5kZWxpbWl0ZXJzKSArIHRlbXBsYXRlXG4gICAgICA6IHRlbXBsYXRlO1xuICAgIGlmIChjYWNoZVtrZXldKSB7XG4gICAgICByZXR1cm4gY2FjaGVba2V5XVxuICAgIH1cblxuICAgIC8vIGNvbXBpbGVcbiAgICB2YXIgY29tcGlsZWQgPSBjb21waWxlKHRlbXBsYXRlLCBvcHRpb25zKTtcblxuICAgIC8vIGNoZWNrIGNvbXBpbGF0aW9uIGVycm9ycy90aXBzXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIGlmIChjb21waWxlZC5lcnJvcnMgJiYgY29tcGlsZWQuZXJyb3JzLmxlbmd0aCkge1xuICAgICAgICBpZiAob3B0aW9ucy5vdXRwdXRTb3VyY2VSYW5nZSkge1xuICAgICAgICAgIGNvbXBpbGVkLmVycm9ycy5mb3JFYWNoKGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICB3YXJuJCQxKFxuICAgICAgICAgICAgICBcIkVycm9yIGNvbXBpbGluZyB0ZW1wbGF0ZTpcXG5cXG5cIiArIChlLm1zZykgKyBcIlxcblxcblwiICtcbiAgICAgICAgICAgICAgZ2VuZXJhdGVDb2RlRnJhbWUodGVtcGxhdGUsIGUuc3RhcnQsIGUuZW5kKSxcbiAgICAgICAgICAgICAgdm1cbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgd2FybiQkMShcbiAgICAgICAgICAgIFwiRXJyb3IgY29tcGlsaW5nIHRlbXBsYXRlOlxcblxcblwiICsgdGVtcGxhdGUgKyBcIlxcblxcblwiICtcbiAgICAgICAgICAgIGNvbXBpbGVkLmVycm9ycy5tYXAoZnVuY3Rpb24gKGUpIHsgcmV0dXJuIChcIi0gXCIgKyBlKTsgfSkuam9pbignXFxuJykgKyAnXFxuJyxcbiAgICAgICAgICAgIHZtXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGNvbXBpbGVkLnRpcHMgJiYgY29tcGlsZWQudGlwcy5sZW5ndGgpIHtcbiAgICAgICAgaWYgKG9wdGlvbnMub3V0cHV0U291cmNlUmFuZ2UpIHtcbiAgICAgICAgICBjb21waWxlZC50aXBzLmZvckVhY2goZnVuY3Rpb24gKGUpIHsgcmV0dXJuIHRpcChlLm1zZywgdm0pOyB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjb21waWxlZC50aXBzLmZvckVhY2goZnVuY3Rpb24gKG1zZykgeyByZXR1cm4gdGlwKG1zZywgdm0pOyB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIC8vIHR1cm4gY29kZSBpbnRvIGZ1bmN0aW9uc1xuICAgIHZhciByZXMgPSB7fTtcbiAgICB2YXIgZm5HZW5FcnJvcnMgPSBbXTtcbiAgICByZXMucmVuZGVyID0gY3JlYXRlRnVuY3Rpb24oY29tcGlsZWQucmVuZGVyLCBmbkdlbkVycm9ycyk7XG4gICAgcmVzLnN0YXRpY1JlbmRlckZucyA9IGNvbXBpbGVkLnN0YXRpY1JlbmRlckZucy5tYXAoZnVuY3Rpb24gKGNvZGUpIHtcbiAgICAgIHJldHVybiBjcmVhdGVGdW5jdGlvbihjb2RlLCBmbkdlbkVycm9ycylcbiAgICB9KTtcblxuICAgIC8vIGNoZWNrIGZ1bmN0aW9uIGdlbmVyYXRpb24gZXJyb3JzLlxuICAgIC8vIHRoaXMgc2hvdWxkIG9ubHkgaGFwcGVuIGlmIHRoZXJlIGlzIGEgYnVnIGluIHRoZSBjb21waWxlciBpdHNlbGYuXG4gICAgLy8gbW9zdGx5IGZvciBjb2RlZ2VuIGRldmVsb3BtZW50IHVzZVxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICBpZiAoKCFjb21waWxlZC5lcnJvcnMgfHwgIWNvbXBpbGVkLmVycm9ycy5sZW5ndGgpICYmIGZuR2VuRXJyb3JzLmxlbmd0aCkge1xuICAgICAgICB3YXJuJCQxKFxuICAgICAgICAgIFwiRmFpbGVkIHRvIGdlbmVyYXRlIHJlbmRlciBmdW5jdGlvbjpcXG5cXG5cIiArXG4gICAgICAgICAgZm5HZW5FcnJvcnMubWFwKGZ1bmN0aW9uIChyZWYpIHtcbiAgICAgICAgICAgIHZhciBlcnIgPSByZWYuZXJyO1xuICAgICAgICAgICAgdmFyIGNvZGUgPSByZWYuY29kZTtcblxuICAgICAgICAgICAgcmV0dXJuICgoZXJyLnRvU3RyaW5nKCkpICsgXCIgaW5cXG5cXG5cIiArIGNvZGUgKyBcIlxcblwiKTtcbiAgICAgICAgfSkuam9pbignXFxuJyksXG4gICAgICAgICAgdm1cbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gKGNhY2hlW2tleV0gPSByZXMpXG4gIH1cbn1cblxuLyogICovXG5cbmZ1bmN0aW9uIGNyZWF0ZUNvbXBpbGVyQ3JlYXRvciAoYmFzZUNvbXBpbGUpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIGNyZWF0ZUNvbXBpbGVyIChiYXNlT3B0aW9ucykge1xuICAgIGZ1bmN0aW9uIGNvbXBpbGUgKFxuICAgICAgdGVtcGxhdGUsXG4gICAgICBvcHRpb25zXG4gICAgKSB7XG4gICAgICB2YXIgZmluYWxPcHRpb25zID0gT2JqZWN0LmNyZWF0ZShiYXNlT3B0aW9ucyk7XG4gICAgICB2YXIgZXJyb3JzID0gW107XG4gICAgICB2YXIgdGlwcyA9IFtdO1xuXG4gICAgICB2YXIgd2FybiA9IGZ1bmN0aW9uIChtc2csIHJhbmdlLCB0aXApIHtcbiAgICAgICAgKHRpcCA/IHRpcHMgOiBlcnJvcnMpLnB1c2gobXNnKTtcbiAgICAgIH07XG5cbiAgICAgIGlmIChvcHRpb25zKSB7XG4gICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIG9wdGlvbnMub3V0cHV0U291cmNlUmFuZ2UpIHtcbiAgICAgICAgICAvLyAkZmxvdy1kaXNhYmxlLWxpbmVcbiAgICAgICAgICB2YXIgbGVhZGluZ1NwYWNlTGVuZ3RoID0gdGVtcGxhdGUubWF0Y2goL15cXHMqLylbMF0ubGVuZ3RoO1xuXG4gICAgICAgICAgd2FybiA9IGZ1bmN0aW9uIChtc2csIHJhbmdlLCB0aXApIHtcbiAgICAgICAgICAgIHZhciBkYXRhID0geyBtc2c6IG1zZyB9O1xuICAgICAgICAgICAgaWYgKHJhbmdlKSB7XG4gICAgICAgICAgICAgIGlmIChyYW5nZS5zdGFydCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgZGF0YS5zdGFydCA9IHJhbmdlLnN0YXJ0ICsgbGVhZGluZ1NwYWNlTGVuZ3RoO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmIChyYW5nZS5lbmQgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGRhdGEuZW5kID0gcmFuZ2UuZW5kICsgbGVhZGluZ1NwYWNlTGVuZ3RoO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAodGlwID8gdGlwcyA6IGVycm9ycykucHVzaChkYXRhKTtcbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIC8vIG1lcmdlIGN1c3RvbSBtb2R1bGVzXG4gICAgICAgIGlmIChvcHRpb25zLm1vZHVsZXMpIHtcbiAgICAgICAgICBmaW5hbE9wdGlvbnMubW9kdWxlcyA9XG4gICAgICAgICAgICAoYmFzZU9wdGlvbnMubW9kdWxlcyB8fCBbXSkuY29uY2F0KG9wdGlvbnMubW9kdWxlcyk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gbWVyZ2UgY3VzdG9tIGRpcmVjdGl2ZXNcbiAgICAgICAgaWYgKG9wdGlvbnMuZGlyZWN0aXZlcykge1xuICAgICAgICAgIGZpbmFsT3B0aW9ucy5kaXJlY3RpdmVzID0gZXh0ZW5kKFxuICAgICAgICAgICAgT2JqZWN0LmNyZWF0ZShiYXNlT3B0aW9ucy5kaXJlY3RpdmVzIHx8IG51bGwpLFxuICAgICAgICAgICAgb3B0aW9ucy5kaXJlY3RpdmVzXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBjb3B5IG90aGVyIG9wdGlvbnNcbiAgICAgICAgZm9yICh2YXIga2V5IGluIG9wdGlvbnMpIHtcbiAgICAgICAgICBpZiAoa2V5ICE9PSAnbW9kdWxlcycgJiYga2V5ICE9PSAnZGlyZWN0aXZlcycpIHtcbiAgICAgICAgICAgIGZpbmFsT3B0aW9uc1trZXldID0gb3B0aW9uc1trZXldO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBmaW5hbE9wdGlvbnMud2FybiA9IHdhcm47XG5cbiAgICAgIHZhciBjb21waWxlZCA9IGJhc2VDb21waWxlKHRlbXBsYXRlLnRyaW0oKSwgZmluYWxPcHRpb25zKTtcbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgIGRldGVjdEVycm9ycyhjb21waWxlZC5hc3QsIHdhcm4pO1xuICAgICAgfVxuICAgICAgY29tcGlsZWQuZXJyb3JzID0gZXJyb3JzO1xuICAgICAgY29tcGlsZWQudGlwcyA9IHRpcHM7XG4gICAgICByZXR1cm4gY29tcGlsZWRcbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgY29tcGlsZTogY29tcGlsZSxcbiAgICAgIGNvbXBpbGVUb0Z1bmN0aW9uczogY3JlYXRlQ29tcGlsZVRvRnVuY3Rpb25Gbihjb21waWxlKVxuICAgIH1cbiAgfVxufVxuXG4vKiAgKi9cblxuLy8gYGNyZWF0ZUNvbXBpbGVyQ3JlYXRvcmAgYWxsb3dzIGNyZWF0aW5nIGNvbXBpbGVycyB0aGF0IHVzZSBhbHRlcm5hdGl2ZVxuLy8gcGFyc2VyL29wdGltaXplci9jb2RlZ2VuLCBlLmcgdGhlIFNTUiBvcHRpbWl6aW5nIGNvbXBpbGVyLlxuLy8gSGVyZSB3ZSBqdXN0IGV4cG9ydCBhIGRlZmF1bHQgY29tcGlsZXIgdXNpbmcgdGhlIGRlZmF1bHQgcGFydHMuXG52YXIgY3JlYXRlQ29tcGlsZXIgPSBjcmVhdGVDb21waWxlckNyZWF0b3IoZnVuY3Rpb24gYmFzZUNvbXBpbGUgKFxuICB0ZW1wbGF0ZSxcbiAgb3B0aW9uc1xuKSB7XG4gIHZhciBhc3QgPSBwYXJzZSh0ZW1wbGF0ZS50cmltKCksIG9wdGlvbnMpO1xuICBpZiAob3B0aW9ucy5vcHRpbWl6ZSAhPT0gZmFsc2UpIHtcbiAgICBvcHRpbWl6ZShhc3QsIG9wdGlvbnMpO1xuICB9XG4gIHZhciBjb2RlID0gZ2VuZXJhdGUoYXN0LCBvcHRpb25zKTtcbiAgcmV0dXJuIHtcbiAgICBhc3Q6IGFzdCxcbiAgICByZW5kZXI6IGNvZGUucmVuZGVyLFxuICAgIHN0YXRpY1JlbmRlckZuczogY29kZS5zdGF0aWNSZW5kZXJGbnNcbiAgfVxufSk7XG5cbi8qICAqL1xuXG52YXIgcmVmJDEgPSBjcmVhdGVDb21waWxlcihiYXNlT3B0aW9ucyk7XG52YXIgY29tcGlsZSA9IHJlZiQxLmNvbXBpbGU7XG52YXIgY29tcGlsZVRvRnVuY3Rpb25zID0gcmVmJDEuY29tcGlsZVRvRnVuY3Rpb25zO1xuXG4vKiAgKi9cblxuLy8gY2hlY2sgd2hldGhlciBjdXJyZW50IGJyb3dzZXIgZW5jb2RlcyBhIGNoYXIgaW5zaWRlIGF0dHJpYnV0ZSB2YWx1ZXNcbnZhciBkaXY7XG5mdW5jdGlvbiBnZXRTaG91bGREZWNvZGUgKGhyZWYpIHtcbiAgZGl2ID0gZGl2IHx8IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICBkaXYuaW5uZXJIVE1MID0gaHJlZiA/IFwiPGEgaHJlZj1cXFwiXFxuXFxcIi8+XCIgOiBcIjxkaXYgYT1cXFwiXFxuXFxcIi8+XCI7XG4gIHJldHVybiBkaXYuaW5uZXJIVE1MLmluZGV4T2YoJyYjMTA7JykgPiAwXG59XG5cbi8vICMzNjYzOiBJRSBlbmNvZGVzIG5ld2xpbmVzIGluc2lkZSBhdHRyaWJ1dGUgdmFsdWVzIHdoaWxlIG90aGVyIGJyb3dzZXJzIGRvbid0XG52YXIgc2hvdWxkRGVjb2RlTmV3bGluZXMgPSBpbkJyb3dzZXIgPyBnZXRTaG91bGREZWNvZGUoZmFsc2UpIDogZmFsc2U7XG4vLyAjNjgyODogY2hyb21lIGVuY29kZXMgY29udGVudCBpbiBhW2hyZWZdXG52YXIgc2hvdWxkRGVjb2RlTmV3bGluZXNGb3JIcmVmID0gaW5Ccm93c2VyID8gZ2V0U2hvdWxkRGVjb2RlKHRydWUpIDogZmFsc2U7XG5cbi8qICAqL1xuXG52YXIgaWRUb1RlbXBsYXRlID0gY2FjaGVkKGZ1bmN0aW9uIChpZCkge1xuICB2YXIgZWwgPSBxdWVyeShpZCk7XG4gIHJldHVybiBlbCAmJiBlbC5pbm5lckhUTUxcbn0pO1xuXG52YXIgbW91bnQgPSBWdWUucHJvdG90eXBlLiRtb3VudDtcblZ1ZS5wcm90b3R5cGUuJG1vdW50ID0gZnVuY3Rpb24gKFxuICBlbCxcbiAgaHlkcmF0aW5nXG4pIHtcbiAgZWwgPSBlbCAmJiBxdWVyeShlbCk7XG5cbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gIGlmIChlbCA9PT0gZG9jdW1lbnQuYm9keSB8fCBlbCA9PT0gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50KSB7XG4gICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiB3YXJuKFxuICAgICAgXCJEbyBub3QgbW91bnQgVnVlIHRvIDxodG1sPiBvciA8Ym9keT4gLSBtb3VudCB0byBub3JtYWwgZWxlbWVudHMgaW5zdGVhZC5cIlxuICAgICk7XG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG4gIHZhciBvcHRpb25zID0gdGhpcy4kb3B0aW9ucztcbiAgLy8gcmVzb2x2ZSB0ZW1wbGF0ZS9lbCBhbmQgY29udmVydCB0byByZW5kZXIgZnVuY3Rpb25cbiAgaWYgKCFvcHRpb25zLnJlbmRlcikge1xuICAgIHZhciB0ZW1wbGF0ZSA9IG9wdGlvbnMudGVtcGxhdGU7XG4gICAgaWYgKHRlbXBsYXRlKSB7XG4gICAgICBpZiAodHlwZW9mIHRlbXBsYXRlID09PSAnc3RyaW5nJykge1xuICAgICAgICBpZiAodGVtcGxhdGUuY2hhckF0KDApID09PSAnIycpIHtcbiAgICAgICAgICB0ZW1wbGF0ZSA9IGlkVG9UZW1wbGF0ZSh0ZW1wbGF0ZSk7XG4gICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgIXRlbXBsYXRlKSB7XG4gICAgICAgICAgICB3YXJuKFxuICAgICAgICAgICAgICAoXCJUZW1wbGF0ZSBlbGVtZW50IG5vdCBmb3VuZCBvciBpcyBlbXB0eTogXCIgKyAob3B0aW9ucy50ZW1wbGF0ZSkpLFxuICAgICAgICAgICAgICB0aGlzXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmICh0ZW1wbGF0ZS5ub2RlVHlwZSkge1xuICAgICAgICB0ZW1wbGF0ZSA9IHRlbXBsYXRlLmlubmVySFRNTDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgICAgd2FybignaW52YWxpZCB0ZW1wbGF0ZSBvcHRpb246JyArIHRlbXBsYXRlLCB0aGlzKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpc1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoZWwpIHtcbiAgICAgIHRlbXBsYXRlID0gZ2V0T3V0ZXJIVE1MKGVsKTtcbiAgICB9XG4gICAgaWYgKHRlbXBsYXRlKSB7XG4gICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIGNvbmZpZy5wZXJmb3JtYW5jZSAmJiBtYXJrKSB7XG4gICAgICAgIG1hcmsoJ2NvbXBpbGUnKTtcbiAgICAgIH1cblxuICAgICAgdmFyIHJlZiA9IGNvbXBpbGVUb0Z1bmN0aW9ucyh0ZW1wbGF0ZSwge1xuICAgICAgICBvdXRwdXRTb3VyY2VSYW5nZTogcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyxcbiAgICAgICAgc2hvdWxkRGVjb2RlTmV3bGluZXM6IHNob3VsZERlY29kZU5ld2xpbmVzLFxuICAgICAgICBzaG91bGREZWNvZGVOZXdsaW5lc0ZvckhyZWY6IHNob3VsZERlY29kZU5ld2xpbmVzRm9ySHJlZixcbiAgICAgICAgZGVsaW1pdGVyczogb3B0aW9ucy5kZWxpbWl0ZXJzLFxuICAgICAgICBjb21tZW50czogb3B0aW9ucy5jb21tZW50c1xuICAgICAgfSwgdGhpcyk7XG4gICAgICB2YXIgcmVuZGVyID0gcmVmLnJlbmRlcjtcbiAgICAgIHZhciBzdGF0aWNSZW5kZXJGbnMgPSByZWYuc3RhdGljUmVuZGVyRm5zO1xuICAgICAgb3B0aW9ucy5yZW5kZXIgPSByZW5kZXI7XG4gICAgICBvcHRpb25zLnN0YXRpY1JlbmRlckZucyA9IHN0YXRpY1JlbmRlckZucztcblxuICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiBjb25maWcucGVyZm9ybWFuY2UgJiYgbWFyaykge1xuICAgICAgICBtYXJrKCdjb21waWxlIGVuZCcpO1xuICAgICAgICBtZWFzdXJlKChcInZ1ZSBcIiArICh0aGlzLl9uYW1lKSArIFwiIGNvbXBpbGVcIiksICdjb21waWxlJywgJ2NvbXBpbGUgZW5kJyk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiBtb3VudC5jYWxsKHRoaXMsIGVsLCBoeWRyYXRpbmcpXG59O1xuXG4vKipcbiAqIEdldCBvdXRlckhUTUwgb2YgZWxlbWVudHMsIHRha2luZyBjYXJlXG4gKiBvZiBTVkcgZWxlbWVudHMgaW4gSUUgYXMgd2VsbC5cbiAqL1xuZnVuY3Rpb24gZ2V0T3V0ZXJIVE1MIChlbCkge1xuICBpZiAoZWwub3V0ZXJIVE1MKSB7XG4gICAgcmV0dXJuIGVsLm91dGVySFRNTFxuICB9IGVsc2Uge1xuICAgIHZhciBjb250YWluZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICBjb250YWluZXIuYXBwZW5kQ2hpbGQoZWwuY2xvbmVOb2RlKHRydWUpKTtcbiAgICByZXR1cm4gY29udGFpbmVyLmlubmVySFRNTFxuICB9XG59XG5cblZ1ZS5jb21waWxlID0gY29tcGlsZVRvRnVuY3Rpb25zO1xuXG5leHBvcnQgZGVmYXVsdCBWdWU7XG4iLCIvLyBUaGUgbW9kdWxlIGNhY2hlXG52YXIgX193ZWJwYWNrX21vZHVsZV9jYWNoZV9fID0ge307XG5cbi8vIFRoZSByZXF1aXJlIGZ1bmN0aW9uXG5mdW5jdGlvbiBfX3dlYnBhY2tfcmVxdWlyZV9fKG1vZHVsZUlkKSB7XG5cdC8vIENoZWNrIGlmIG1vZHVsZSBpcyBpbiBjYWNoZVxuXHR2YXIgY2FjaGVkTW9kdWxlID0gX193ZWJwYWNrX21vZHVsZV9jYWNoZV9fW21vZHVsZUlkXTtcblx0aWYgKGNhY2hlZE1vZHVsZSAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0cmV0dXJuIGNhY2hlZE1vZHVsZS5leHBvcnRzO1xuXHR9XG5cdC8vIENyZWF0ZSBhIG5ldyBtb2R1bGUgKGFuZCBwdXQgaXQgaW50byB0aGUgY2FjaGUpXG5cdHZhciBtb2R1bGUgPSBfX3dlYnBhY2tfbW9kdWxlX2NhY2hlX19bbW9kdWxlSWRdID0ge1xuXHRcdGlkOiBtb2R1bGVJZCxcblx0XHQvLyBubyBtb2R1bGUubG9hZGVkIG5lZWRlZFxuXHRcdGV4cG9ydHM6IHt9XG5cdH07XG5cblx0Ly8gRXhlY3V0ZSB0aGUgbW9kdWxlIGZ1bmN0aW9uXG5cdF9fd2VicGFja19tb2R1bGVzX19bbW9kdWxlSWRdKG1vZHVsZSwgbW9kdWxlLmV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pO1xuXG5cdC8vIFJldHVybiB0aGUgZXhwb3J0cyBvZiB0aGUgbW9kdWxlXG5cdHJldHVybiBtb2R1bGUuZXhwb3J0cztcbn1cblxuLy8gZXhwb3NlIHRoZSBtb2R1bGVzIG9iamVjdCAoX193ZWJwYWNrX21vZHVsZXNfXylcbl9fd2VicGFja19yZXF1aXJlX18ubSA9IF9fd2VicGFja19tb2R1bGVzX187XG5cbiIsInZhciBkZWZlcnJlZCA9IFtdO1xuX193ZWJwYWNrX3JlcXVpcmVfXy5PID0gKHJlc3VsdCwgY2h1bmtJZHMsIGZuLCBwcmlvcml0eSkgPT4ge1xuXHRpZihjaHVua0lkcykge1xuXHRcdHByaW9yaXR5ID0gcHJpb3JpdHkgfHwgMDtcblx0XHRmb3IodmFyIGkgPSBkZWZlcnJlZC5sZW5ndGg7IGkgPiAwICYmIGRlZmVycmVkW2kgLSAxXVsyXSA+IHByaW9yaXR5OyBpLS0pIGRlZmVycmVkW2ldID0gZGVmZXJyZWRbaSAtIDFdO1xuXHRcdGRlZmVycmVkW2ldID0gW2NodW5rSWRzLCBmbiwgcHJpb3JpdHldO1xuXHRcdHJldHVybjtcblx0fVxuXHR2YXIgbm90RnVsZmlsbGVkID0gSW5maW5pdHk7XG5cdGZvciAodmFyIGkgPSAwOyBpIDwgZGVmZXJyZWQubGVuZ3RoOyBpKyspIHtcblx0XHR2YXIgW2NodW5rSWRzLCBmbiwgcHJpb3JpdHldID0gZGVmZXJyZWRbaV07XG5cdFx0dmFyIGZ1bGZpbGxlZCA9IHRydWU7XG5cdFx0Zm9yICh2YXIgaiA9IDA7IGogPCBjaHVua0lkcy5sZW5ndGg7IGorKykge1xuXHRcdFx0aWYgKChwcmlvcml0eSAmIDEgPT09IDAgfHwgbm90RnVsZmlsbGVkID49IHByaW9yaXR5KSAmJiBPYmplY3Qua2V5cyhfX3dlYnBhY2tfcmVxdWlyZV9fLk8pLmV2ZXJ5KChrZXkpID0+IChfX3dlYnBhY2tfcmVxdWlyZV9fLk9ba2V5XShjaHVua0lkc1tqXSkpKSkge1xuXHRcdFx0XHRjaHVua0lkcy5zcGxpY2Uoai0tLCAxKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGZ1bGZpbGxlZCA9IGZhbHNlO1xuXHRcdFx0XHRpZihwcmlvcml0eSA8IG5vdEZ1bGZpbGxlZCkgbm90RnVsZmlsbGVkID0gcHJpb3JpdHk7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdGlmKGZ1bGZpbGxlZCkge1xuXHRcdFx0ZGVmZXJyZWQuc3BsaWNlKGktLSwgMSlcblx0XHRcdHZhciByID0gZm4oKTtcblx0XHRcdGlmIChyICE9PSB1bmRlZmluZWQpIHJlc3VsdCA9IHI7XG5cdFx0fVxuXHR9XG5cdHJldHVybiByZXN1bHQ7XG59OyIsIi8vIGdldERlZmF1bHRFeHBvcnQgZnVuY3Rpb24gZm9yIGNvbXBhdGliaWxpdHkgd2l0aCBub24taGFybW9ueSBtb2R1bGVzXG5fX3dlYnBhY2tfcmVxdWlyZV9fLm4gPSAobW9kdWxlKSA9PiB7XG5cdHZhciBnZXR0ZXIgPSBtb2R1bGUgJiYgbW9kdWxlLl9fZXNNb2R1bGUgP1xuXHRcdCgpID0+IChtb2R1bGVbJ2RlZmF1bHQnXSkgOlxuXHRcdCgpID0+IChtb2R1bGUpO1xuXHRfX3dlYnBhY2tfcmVxdWlyZV9fLmQoZ2V0dGVyLCB7IGE6IGdldHRlciB9KTtcblx0cmV0dXJuIGdldHRlcjtcbn07IiwiLy8gZGVmaW5lIGdldHRlciBmdW5jdGlvbnMgZm9yIGhhcm1vbnkgZXhwb3J0c1xuX193ZWJwYWNrX3JlcXVpcmVfXy5kID0gKGV4cG9ydHMsIGRlZmluaXRpb24pID0+IHtcblx0Zm9yKHZhciBrZXkgaW4gZGVmaW5pdGlvbikge1xuXHRcdGlmKF9fd2VicGFja19yZXF1aXJlX18ubyhkZWZpbml0aW9uLCBrZXkpICYmICFfX3dlYnBhY2tfcmVxdWlyZV9fLm8oZXhwb3J0cywga2V5KSkge1xuXHRcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIGtleSwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGRlZmluaXRpb25ba2V5XSB9KTtcblx0XHR9XG5cdH1cbn07IiwiX193ZWJwYWNrX3JlcXVpcmVfXy5nID0gKGZ1bmN0aW9uKCkge1xuXHRpZiAodHlwZW9mIGdsb2JhbFRoaXMgPT09ICdvYmplY3QnKSByZXR1cm4gZ2xvYmFsVGhpcztcblx0dHJ5IHtcblx0XHRyZXR1cm4gdGhpcyB8fCBuZXcgRnVuY3Rpb24oJ3JldHVybiB0aGlzJykoKTtcblx0fSBjYXRjaCAoZSkge1xuXHRcdGlmICh0eXBlb2Ygd2luZG93ID09PSAnb2JqZWN0JykgcmV0dXJuIHdpbmRvdztcblx0fVxufSkoKTsiLCJfX3dlYnBhY2tfcmVxdWlyZV9fLm8gPSAob2JqLCBwcm9wKSA9PiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwgcHJvcCkpIiwiLy8gZGVmaW5lIF9fZXNNb2R1bGUgb24gZXhwb3J0c1xuX193ZWJwYWNrX3JlcXVpcmVfXy5yID0gKGV4cG9ydHMpID0+IHtcblx0aWYodHlwZW9mIFN5bWJvbCAhPT0gJ3VuZGVmaW5lZCcgJiYgU3ltYm9sLnRvU3RyaW5nVGFnKSB7XG5cdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFN5bWJvbC50b1N0cmluZ1RhZywgeyB2YWx1ZTogJ01vZHVsZScgfSk7XG5cdH1cblx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcbn07IiwiLy8gbm8gYmFzZVVSSVxuXG4vLyBvYmplY3QgdG8gc3RvcmUgbG9hZGVkIGFuZCBsb2FkaW5nIGNodW5rc1xuLy8gdW5kZWZpbmVkID0gY2h1bmsgbm90IGxvYWRlZCwgbnVsbCA9IGNodW5rIHByZWxvYWRlZC9wcmVmZXRjaGVkXG4vLyBbcmVzb2x2ZSwgcmVqZWN0LCBQcm9taXNlXSA9IGNodW5rIGxvYWRpbmcsIDAgPSBjaHVuayBsb2FkZWRcbnZhciBpbnN0YWxsZWRDaHVua3MgPSB7XG5cdFwiL2pzL21haW5cIjogMCxcblx0XCJjc3MvYmFzZS9wbHVnaW5zL2V4dGVuc2lvbnMvZXh0LWNvbXBvbmVudC1tZWRpYS1wbGF5ZXJcIjogMCxcblx0XCJjc3MvYmFzZS9wbHVnaW5zL2V4dGVuc2lvbnMvZXh0LWNvbXBvbmVudC1kcmFnLWRyb3BcIjogMCxcblx0XCJjc3MvYmFzZS9wbHVnaW5zL2V4dGVuc2lvbnMvZXh0LWNvbXBvbmVudC1jb250ZXh0LW1lbnVcIjogMCxcblx0XCJjc3MvYmFzZS9wbHVnaW5zL2NoYXJ0cy9jaGFydC1hcGV4XCI6IDAsXG5cdFwiY3NzL3N0eWxlXCI6IDAsXG5cdFwiY3NzL292ZXJyaWRlc1wiOiAwLFxuXHRcImNzcy9jb3JlXCI6IDAsXG5cdFwiY3NzL2Jhc2UvdGhlbWVzL2RhcmstbGF5b3V0XCI6IDAsXG5cdFwiY3NzL2Jhc2UvY29yZS9taXhpbnMvdHJhbnNpdGlvbnNcIjogMCxcblx0XCJjc3MvYmFzZS9jb3JlL21peGlucy9tYWluLW1lbnUtbWl4aW5cIjogMCxcblx0XCJjc3MvYmFzZS9jb3JlL21peGlucy9oZXgycmdiXCI6IDAsXG5cdFwiY3NzL2Jhc2UvY29yZS9taXhpbnMvYWxlcnRcIjogMCxcblx0XCJjc3MvYmFzZS9jb3JlL21lbnUvbWVudS10eXBlcy92ZXJ0aWNhbC1vdmVybGF5LW1lbnVcIjogMCxcblx0XCJjc3MvYmFzZS9jb3JlL21lbnUvbWVudS10eXBlcy92ZXJ0aWNhbC1tZW51XCI6IDAsXG5cdFwiY3NzL2Jhc2UvY29yZS9tZW51L21lbnUtdHlwZXMvaG9yaXpvbnRhbC1tZW51XCI6IDAsXG5cdFwiY3NzL2Jhc2UvY29yZS9jb2xvcnMvcGFsZXR0ZS12YXJpYWJsZXNcIjogMCxcblx0XCJjc3MvYmFzZS9jb3JlL2NvbG9ycy9wYWxldHRlLW5vdWlcIjogMCxcblx0XCJjc3MvYmFzZS9jb3JlL2NvbG9ycy9wYWxldHRlLWdyYWRpZW50XCI6IDAsXG5cdFwiY3NzL2Jhc2UvcGFnZXMvdWktZmVhdGhlclwiOiAwLFxuXHRcImNzcy9iYXNlL3BhZ2VzL3BhZ2UtcHJvZmlsZVwiOiAwLFxuXHRcImNzcy9iYXNlL3BhZ2VzL3BhZ2UtcHJpY2luZ1wiOiAwLFxuXHRcImNzcy9iYXNlL3BhZ2VzL3BhZ2UtbWlzY1wiOiAwLFxuXHRcImNzcy9iYXNlL3BhZ2VzL3BhZ2Uta25vd2xlZGdlLWJhc2VcIjogMCxcblx0XCJjc3MvYmFzZS9wYWdlcy9wYWdlLWZhcVwiOiAwLFxuXHRcImNzcy9iYXNlL3BhZ2VzL3BhZ2UtY29taW5nLXNvb25cIjogMCxcblx0XCJjc3MvYmFzZS9wYWdlcy9wYWdlLWJsb2dcIjogMCxcblx0XCJjc3MvYmFzZS9wYWdlcy9tb2RhbC1jcmVhdGUtYXBwXCI6IDAsXG5cdFwiY3NzL2Jhc2UvcGFnZXMvZGFzaGJvYXJkLWVjb21tZXJjZVwiOiAwLFxuXHRcImNzcy9iYXNlL3BhZ2VzL2F1dGhlbnRpY2F0aW9uXCI6IDAsXG5cdFwiY3NzL2Jhc2UvcGFnZXMvYXBwLXRvZG9cIjogMCxcblx0XCJjc3MvYmFzZS9wYWdlcy9hcHAta2FuYmFuXCI6IDAsXG5cdFwiY3NzL2Jhc2UvcGFnZXMvYXBwLWludm9pY2VcIjogMCxcblx0XCJjc3MvYmFzZS9wYWdlcy9hcHAtaW52b2ljZS1wcmludFwiOiAwLFxuXHRcImNzcy9iYXNlL3BhZ2VzL2FwcC1pbnZvaWNlLWxpc3RcIjogMCxcblx0XCJjc3MvYmFzZS9wYWdlcy9hcHAtZmlsZS1tYW5hZ2VyXCI6IDAsXG5cdFwiY3NzL2Jhc2UvcGFnZXMvYXBwLWVtYWlsXCI6IDAsXG5cdFwiY3NzL2Jhc2UvcGFnZXMvYXBwLWVjb21tZXJjZVwiOiAwLFxuXHRcImNzcy9iYXNlL3BhZ2VzL2FwcC1lY29tbWVyY2UtZGV0YWlsc1wiOiAwLFxuXHRcImNzcy9iYXNlL3BhZ2VzL2FwcC1jaGF0XCI6IDAsXG5cdFwiY3NzL2Jhc2UvcGFnZXMvYXBwLWNoYXQtbGlzdFwiOiAwLFxuXHRcImNzcy9iYXNlL3BhZ2VzL2FwcC1jYWxlbmRhclwiOiAwLFxuXHRcImNzcy9iYXNlL3BsdWdpbnMvdWkvY29taW5nLXNvb25cIjogMCxcblx0XCJjc3MvYmFzZS9wbHVnaW5zL21hcHMvbWFwLWxlYWZsZXRcIjogMCxcblx0XCJjc3MvYmFzZS9wbHVnaW5zL2Zvcm1zL3BpY2tlcnMvZm9ybS1waWNrYWRhdGVcIjogMCxcblx0XCJjc3MvYmFzZS9wbHVnaW5zL2Zvcm1zL3BpY2tlcnMvZm9ybS1mbGF0LXBpY2tyXCI6IDAsXG5cdFwiY3NzL2Jhc2UvcGx1Z2lucy9mb3Jtcy9mb3JtLXdpemFyZFwiOiAwLFxuXHRcImNzcy9iYXNlL3BsdWdpbnMvZm9ybXMvZm9ybS12YWxpZGF0aW9uXCI6IDAsXG5cdFwiY3NzL2Jhc2UvcGx1Z2lucy9mb3Jtcy9mb3JtLXF1aWxsLWVkaXRvclwiOiAwLFxuXHRcImNzcy9iYXNlL3BsdWdpbnMvZm9ybXMvZm9ybS1udW1iZXItaW5wdXRcIjogMCxcblx0XCJjc3MvYmFzZS9wbHVnaW5zL2Zvcm1zL2Zvcm0tZmlsZS11cGxvYWRlclwiOiAwLFxuXHRcImNzcy9iYXNlL3BsdWdpbnMvZXh0ZW5zaW9ucy9leHQtY29tcG9uZW50LXRyZWVcIjogMCxcblx0XCJjc3MvYmFzZS9wbHVnaW5zL2V4dGVuc2lvbnMvZXh0LWNvbXBvbmVudC10b3VyXCI6IDAsXG5cdFwiY3NzL2Jhc2UvcGx1Z2lucy9leHRlbnNpb25zL2V4dC1jb21wb25lbnQtdG9hc3RyXCI6IDAsXG5cdFwiY3NzL2Jhc2UvcGx1Z2lucy9leHRlbnNpb25zL2V4dC1jb21wb25lbnQtc3dpcGVyXCI6IDAsXG5cdFwiY3NzL2Jhc2UvcGx1Z2lucy9leHRlbnNpb25zL2V4dC1jb21wb25lbnQtc3dlZXQtYWxlcnRzXCI6IDAsXG5cdFwiY3NzL2Jhc2UvcGx1Z2lucy9leHRlbnNpb25zL2V4dC1jb21wb25lbnQtc2xpZGVyc1wiOiAwLFxuXHRcImNzcy9iYXNlL3BsdWdpbnMvZXh0ZW5zaW9ucy9leHQtY29tcG9uZW50LXJhdGluZ3NcIjogMFxufTtcblxuLy8gbm8gY2h1bmsgb24gZGVtYW5kIGxvYWRpbmdcblxuLy8gbm8gcHJlZmV0Y2hpbmdcblxuLy8gbm8gcHJlbG9hZGVkXG5cbi8vIG5vIEhNUlxuXG4vLyBubyBITVIgbWFuaWZlc3RcblxuX193ZWJwYWNrX3JlcXVpcmVfXy5PLmogPSAoY2h1bmtJZCkgPT4gKGluc3RhbGxlZENodW5rc1tjaHVua0lkXSA9PT0gMCk7XG5cbi8vIGluc3RhbGwgYSBKU09OUCBjYWxsYmFjayBmb3IgY2h1bmsgbG9hZGluZ1xudmFyIHdlYnBhY2tKc29ucENhbGxiYWNrID0gKHBhcmVudENodW5rTG9hZGluZ0Z1bmN0aW9uLCBkYXRhKSA9PiB7XG5cdHZhciBbY2h1bmtJZHMsIG1vcmVNb2R1bGVzLCBydW50aW1lXSA9IGRhdGE7XG5cdC8vIGFkZCBcIm1vcmVNb2R1bGVzXCIgdG8gdGhlIG1vZHVsZXMgb2JqZWN0LFxuXHQvLyB0aGVuIGZsYWcgYWxsIFwiY2h1bmtJZHNcIiBhcyBsb2FkZWQgYW5kIGZpcmUgY2FsbGJhY2tcblx0dmFyIG1vZHVsZUlkLCBjaHVua0lkLCBpID0gMDtcblx0aWYoY2h1bmtJZHMuc29tZSgoaWQpID0+IChpbnN0YWxsZWRDaHVua3NbaWRdICE9PSAwKSkpIHtcblx0XHRmb3IobW9kdWxlSWQgaW4gbW9yZU1vZHVsZXMpIHtcblx0XHRcdGlmKF9fd2VicGFja19yZXF1aXJlX18ubyhtb3JlTW9kdWxlcywgbW9kdWxlSWQpKSB7XG5cdFx0XHRcdF9fd2VicGFja19yZXF1aXJlX18ubVttb2R1bGVJZF0gPSBtb3JlTW9kdWxlc1ttb2R1bGVJZF07XG5cdFx0XHR9XG5cdFx0fVxuXHRcdGlmKHJ1bnRpbWUpIHZhciByZXN1bHQgPSBydW50aW1lKF9fd2VicGFja19yZXF1aXJlX18pO1xuXHR9XG5cdGlmKHBhcmVudENodW5rTG9hZGluZ0Z1bmN0aW9uKSBwYXJlbnRDaHVua0xvYWRpbmdGdW5jdGlvbihkYXRhKTtcblx0Zm9yKDtpIDwgY2h1bmtJZHMubGVuZ3RoOyBpKyspIHtcblx0XHRjaHVua0lkID0gY2h1bmtJZHNbaV07XG5cdFx0aWYoX193ZWJwYWNrX3JlcXVpcmVfXy5vKGluc3RhbGxlZENodW5rcywgY2h1bmtJZCkgJiYgaW5zdGFsbGVkQ2h1bmtzW2NodW5rSWRdKSB7XG5cdFx0XHRpbnN0YWxsZWRDaHVua3NbY2h1bmtJZF1bMF0oKTtcblx0XHR9XG5cdFx0aW5zdGFsbGVkQ2h1bmtzW2NodW5rSWRdID0gMDtcblx0fVxuXHRyZXR1cm4gX193ZWJwYWNrX3JlcXVpcmVfXy5PKHJlc3VsdCk7XG59XG5cbnZhciBjaHVua0xvYWRpbmdHbG9iYWwgPSBzZWxmW1wid2VicGFja0NodW5rXCJdID0gc2VsZltcIndlYnBhY2tDaHVua1wiXSB8fCBbXTtcbmNodW5rTG9hZGluZ0dsb2JhbC5mb3JFYWNoKHdlYnBhY2tKc29ucENhbGxiYWNrLmJpbmQobnVsbCwgMCkpO1xuY2h1bmtMb2FkaW5nR2xvYmFsLnB1c2ggPSB3ZWJwYWNrSnNvbnBDYWxsYmFjay5iaW5kKG51bGwsIGNodW5rTG9hZGluZ0dsb2JhbC5wdXNoLmJpbmQoY2h1bmtMb2FkaW5nR2xvYmFsKSk7IiwiX193ZWJwYWNrX3JlcXVpcmVfXy5uYyA9IHVuZGVmaW5lZDsiLCIiLCIvLyBzdGFydHVwXG4vLyBMb2FkIGVudHJ5IG1vZHVsZSBhbmQgcmV0dXJuIGV4cG9ydHNcbi8vIFRoaXMgZW50cnkgbW9kdWxlIGRlcGVuZHMgb24gb3RoZXIgbG9hZGVkIGNodW5rcyBhbmQgZXhlY3V0aW9uIG5lZWQgdG8gYmUgZGVsYXllZFxuX193ZWJwYWNrX3JlcXVpcmVfXy5PKHVuZGVmaW5lZCwgW1wiY3NzL2Jhc2UvcGx1Z2lucy9leHRlbnNpb25zL2V4dC1jb21wb25lbnQtbWVkaWEtcGxheWVyXCIsXCJjc3MvYmFzZS9wbHVnaW5zL2V4dGVuc2lvbnMvZXh0LWNvbXBvbmVudC1kcmFnLWRyb3BcIixcImNzcy9iYXNlL3BsdWdpbnMvZXh0ZW5zaW9ucy9leHQtY29tcG9uZW50LWNvbnRleHQtbWVudVwiLFwiY3NzL2Jhc2UvcGx1Z2lucy9jaGFydHMvY2hhcnQtYXBleFwiLFwiY3NzL3N0eWxlXCIsXCJjc3Mvb3ZlcnJpZGVzXCIsXCJjc3MvY29yZVwiLFwiY3NzL2Jhc2UvdGhlbWVzL2RhcmstbGF5b3V0XCIsXCJjc3MvYmFzZS9jb3JlL21peGlucy90cmFuc2l0aW9uc1wiLFwiY3NzL2Jhc2UvY29yZS9taXhpbnMvbWFpbi1tZW51LW1peGluXCIsXCJjc3MvYmFzZS9jb3JlL21peGlucy9oZXgycmdiXCIsXCJjc3MvYmFzZS9jb3JlL21peGlucy9hbGVydFwiLFwiY3NzL2Jhc2UvY29yZS9tZW51L21lbnUtdHlwZXMvdmVydGljYWwtb3ZlcmxheS1tZW51XCIsXCJjc3MvYmFzZS9jb3JlL21lbnUvbWVudS10eXBlcy92ZXJ0aWNhbC1tZW51XCIsXCJjc3MvYmFzZS9jb3JlL21lbnUvbWVudS10eXBlcy9ob3Jpem9udGFsLW1lbnVcIixcImNzcy9iYXNlL2NvcmUvY29sb3JzL3BhbGV0dGUtdmFyaWFibGVzXCIsXCJjc3MvYmFzZS9jb3JlL2NvbG9ycy9wYWxldHRlLW5vdWlcIixcImNzcy9iYXNlL2NvcmUvY29sb3JzL3BhbGV0dGUtZ3JhZGllbnRcIixcImNzcy9iYXNlL3BhZ2VzL3VpLWZlYXRoZXJcIixcImNzcy9iYXNlL3BhZ2VzL3BhZ2UtcHJvZmlsZVwiLFwiY3NzL2Jhc2UvcGFnZXMvcGFnZS1wcmljaW5nXCIsXCJjc3MvYmFzZS9wYWdlcy9wYWdlLW1pc2NcIixcImNzcy9iYXNlL3BhZ2VzL3BhZ2Uta25vd2xlZGdlLWJhc2VcIixcImNzcy9iYXNlL3BhZ2VzL3BhZ2UtZmFxXCIsXCJjc3MvYmFzZS9wYWdlcy9wYWdlLWNvbWluZy1zb29uXCIsXCJjc3MvYmFzZS9wYWdlcy9wYWdlLWJsb2dcIixcImNzcy9iYXNlL3BhZ2VzL21vZGFsLWNyZWF0ZS1hcHBcIixcImNzcy9iYXNlL3BhZ2VzL2Rhc2hib2FyZC1lY29tbWVyY2VcIixcImNzcy9iYXNlL3BhZ2VzL2F1dGhlbnRpY2F0aW9uXCIsXCJjc3MvYmFzZS9wYWdlcy9hcHAtdG9kb1wiLFwiY3NzL2Jhc2UvcGFnZXMvYXBwLWthbmJhblwiLFwiY3NzL2Jhc2UvcGFnZXMvYXBwLWludm9pY2VcIixcImNzcy9iYXNlL3BhZ2VzL2FwcC1pbnZvaWNlLXByaW50XCIsXCJjc3MvYmFzZS9wYWdlcy9hcHAtaW52b2ljZS1saXN0XCIsXCJjc3MvYmFzZS9wYWdlcy9hcHAtZmlsZS1tYW5hZ2VyXCIsXCJjc3MvYmFzZS9wYWdlcy9hcHAtZW1haWxcIixcImNzcy9iYXNlL3BhZ2VzL2FwcC1lY29tbWVyY2VcIixcImNzcy9iYXNlL3BhZ2VzL2FwcC1lY29tbWVyY2UtZGV0YWlsc1wiLFwiY3NzL2Jhc2UvcGFnZXMvYXBwLWNoYXRcIixcImNzcy9iYXNlL3BhZ2VzL2FwcC1jaGF0LWxpc3RcIixcImNzcy9iYXNlL3BhZ2VzL2FwcC1jYWxlbmRhclwiLFwiY3NzL2Jhc2UvcGx1Z2lucy91aS9jb21pbmctc29vblwiLFwiY3NzL2Jhc2UvcGx1Z2lucy9tYXBzL21hcC1sZWFmbGV0XCIsXCJjc3MvYmFzZS9wbHVnaW5zL2Zvcm1zL3BpY2tlcnMvZm9ybS1waWNrYWRhdGVcIixcImNzcy9iYXNlL3BsdWdpbnMvZm9ybXMvcGlja2Vycy9mb3JtLWZsYXQtcGlja3JcIixcImNzcy9iYXNlL3BsdWdpbnMvZm9ybXMvZm9ybS13aXphcmRcIixcImNzcy9iYXNlL3BsdWdpbnMvZm9ybXMvZm9ybS12YWxpZGF0aW9uXCIsXCJjc3MvYmFzZS9wbHVnaW5zL2Zvcm1zL2Zvcm0tcXVpbGwtZWRpdG9yXCIsXCJjc3MvYmFzZS9wbHVnaW5zL2Zvcm1zL2Zvcm0tbnVtYmVyLWlucHV0XCIsXCJjc3MvYmFzZS9wbHVnaW5zL2Zvcm1zL2Zvcm0tZmlsZS11cGxvYWRlclwiLFwiY3NzL2Jhc2UvcGx1Z2lucy9leHRlbnNpb25zL2V4dC1jb21wb25lbnQtdHJlZVwiLFwiY3NzL2Jhc2UvcGx1Z2lucy9leHRlbnNpb25zL2V4dC1jb21wb25lbnQtdG91clwiLFwiY3NzL2Jhc2UvcGx1Z2lucy9leHRlbnNpb25zL2V4dC1jb21wb25lbnQtdG9hc3RyXCIsXCJjc3MvYmFzZS9wbHVnaW5zL2V4dGVuc2lvbnMvZXh0LWNvbXBvbmVudC1zd2lwZXJcIixcImNzcy9iYXNlL3BsdWdpbnMvZXh0ZW5zaW9ucy9leHQtY29tcG9uZW50LXN3ZWV0LWFsZXJ0c1wiLFwiY3NzL2Jhc2UvcGx1Z2lucy9leHRlbnNpb25zL2V4dC1jb21wb25lbnQtc2xpZGVyc1wiLFwiY3NzL2Jhc2UvcGx1Z2lucy9leHRlbnNpb25zL2V4dC1jb21wb25lbnQtcmF0aW5nc1wiXSwgKCkgPT4gKF9fd2VicGFja19yZXF1aXJlX18oXCIuL3NyYy9tYWluLmpzXCIpKSlcbl9fd2VicGFja19yZXF1aXJlX18uTyh1bmRlZmluZWQsIFtcImNzcy9iYXNlL3BsdWdpbnMvZXh0ZW5zaW9ucy9leHQtY29tcG9uZW50LW1lZGlhLXBsYXllclwiLFwiY3NzL2Jhc2UvcGx1Z2lucy9leHRlbnNpb25zL2V4dC1jb21wb25lbnQtZHJhZy1kcm9wXCIsXCJjc3MvYmFzZS9wbHVnaW5zL2V4dGVuc2lvbnMvZXh0LWNvbXBvbmVudC1jb250ZXh0LW1lbnVcIixcImNzcy9iYXNlL3BsdWdpbnMvY2hhcnRzL2NoYXJ0LWFwZXhcIixcImNzcy9zdHlsZVwiLFwiY3NzL292ZXJyaWRlc1wiLFwiY3NzL2NvcmVcIixcImNzcy9iYXNlL3RoZW1lcy9kYXJrLWxheW91dFwiLFwiY3NzL2Jhc2UvY29yZS9taXhpbnMvdHJhbnNpdGlvbnNcIixcImNzcy9iYXNlL2NvcmUvbWl4aW5zL21haW4tbWVudS1taXhpblwiLFwiY3NzL2Jhc2UvY29yZS9taXhpbnMvaGV4MnJnYlwiLFwiY3NzL2Jhc2UvY29yZS9taXhpbnMvYWxlcnRcIixcImNzcy9iYXNlL2NvcmUvbWVudS9tZW51LXR5cGVzL3ZlcnRpY2FsLW92ZXJsYXktbWVudVwiLFwiY3NzL2Jhc2UvY29yZS9tZW51L21lbnUtdHlwZXMvdmVydGljYWwtbWVudVwiLFwiY3NzL2Jhc2UvY29yZS9tZW51L21lbnUtdHlwZXMvaG9yaXpvbnRhbC1tZW51XCIsXCJjc3MvYmFzZS9jb3JlL2NvbG9ycy9wYWxldHRlLXZhcmlhYmxlc1wiLFwiY3NzL2Jhc2UvY29yZS9jb2xvcnMvcGFsZXR0ZS1ub3VpXCIsXCJjc3MvYmFzZS9jb3JlL2NvbG9ycy9wYWxldHRlLWdyYWRpZW50XCIsXCJjc3MvYmFzZS9wYWdlcy91aS1mZWF0aGVyXCIsXCJjc3MvYmFzZS9wYWdlcy9wYWdlLXByb2ZpbGVcIixcImNzcy9iYXNlL3BhZ2VzL3BhZ2UtcHJpY2luZ1wiLFwiY3NzL2Jhc2UvcGFnZXMvcGFnZS1taXNjXCIsXCJjc3MvYmFzZS9wYWdlcy9wYWdlLWtub3dsZWRnZS1iYXNlXCIsXCJjc3MvYmFzZS9wYWdlcy9wYWdlLWZhcVwiLFwiY3NzL2Jhc2UvcGFnZXMvcGFnZS1jb21pbmctc29vblwiLFwiY3NzL2Jhc2UvcGFnZXMvcGFnZS1ibG9nXCIsXCJjc3MvYmFzZS9wYWdlcy9tb2RhbC1jcmVhdGUtYXBwXCIsXCJjc3MvYmFzZS9wYWdlcy9kYXNoYm9hcmQtZWNvbW1lcmNlXCIsXCJjc3MvYmFzZS9wYWdlcy9hdXRoZW50aWNhdGlvblwiLFwiY3NzL2Jhc2UvcGFnZXMvYXBwLXRvZG9cIixcImNzcy9iYXNlL3BhZ2VzL2FwcC1rYW5iYW5cIixcImNzcy9iYXNlL3BhZ2VzL2FwcC1pbnZvaWNlXCIsXCJjc3MvYmFzZS9wYWdlcy9hcHAtaW52b2ljZS1wcmludFwiLFwiY3NzL2Jhc2UvcGFnZXMvYXBwLWludm9pY2UtbGlzdFwiLFwiY3NzL2Jhc2UvcGFnZXMvYXBwLWZpbGUtbWFuYWdlclwiLFwiY3NzL2Jhc2UvcGFnZXMvYXBwLWVtYWlsXCIsXCJjc3MvYmFzZS9wYWdlcy9hcHAtZWNvbW1lcmNlXCIsXCJjc3MvYmFzZS9wYWdlcy9hcHAtZWNvbW1lcmNlLWRldGFpbHNcIixcImNzcy9iYXNlL3BhZ2VzL2FwcC1jaGF0XCIsXCJjc3MvYmFzZS9wYWdlcy9hcHAtY2hhdC1saXN0XCIsXCJjc3MvYmFzZS9wYWdlcy9hcHAtY2FsZW5kYXJcIixcImNzcy9iYXNlL3BsdWdpbnMvdWkvY29taW5nLXNvb25cIixcImNzcy9iYXNlL3BsdWdpbnMvbWFwcy9tYXAtbGVhZmxldFwiLFwiY3NzL2Jhc2UvcGx1Z2lucy9mb3Jtcy9waWNrZXJzL2Zvcm0tcGlja2FkYXRlXCIsXCJjc3MvYmFzZS9wbHVnaW5zL2Zvcm1zL3BpY2tlcnMvZm9ybS1mbGF0LXBpY2tyXCIsXCJjc3MvYmFzZS9wbHVnaW5zL2Zvcm1zL2Zvcm0td2l6YXJkXCIsXCJjc3MvYmFzZS9wbHVnaW5zL2Zvcm1zL2Zvcm0tdmFsaWRhdGlvblwiLFwiY3NzL2Jhc2UvcGx1Z2lucy9mb3Jtcy9mb3JtLXF1aWxsLWVkaXRvclwiLFwiY3NzL2Jhc2UvcGx1Z2lucy9mb3Jtcy9mb3JtLW51bWJlci1pbnB1dFwiLFwiY3NzL2Jhc2UvcGx1Z2lucy9mb3Jtcy9mb3JtLWZpbGUtdXBsb2FkZXJcIixcImNzcy9iYXNlL3BsdWdpbnMvZXh0ZW5zaW9ucy9leHQtY29tcG9uZW50LXRyZWVcIixcImNzcy9iYXNlL3BsdWdpbnMvZXh0ZW5zaW9ucy9leHQtY29tcG9uZW50LXRvdXJcIixcImNzcy9iYXNlL3BsdWdpbnMvZXh0ZW5zaW9ucy9leHQtY29tcG9uZW50LXRvYXN0clwiLFwiY3NzL2Jhc2UvcGx1Z2lucy9leHRlbnNpb25zL2V4dC1jb21wb25lbnQtc3dpcGVyXCIsXCJjc3MvYmFzZS9wbHVnaW5zL2V4dGVuc2lvbnMvZXh0LWNvbXBvbmVudC1zd2VldC1hbGVydHNcIixcImNzcy9iYXNlL3BsdWdpbnMvZXh0ZW5zaW9ucy9leHQtY29tcG9uZW50LXNsaWRlcnNcIixcImNzcy9iYXNlL3BsdWdpbnMvZXh0ZW5zaW9ucy9leHQtY29tcG9uZW50LXJhdGluZ3NcIl0sICgpID0+IChfX3dlYnBhY2tfcmVxdWlyZV9fKFwiLi9yZXNvdXJjZXMvc2Nzcy9iYXNlL3BsdWdpbnMvY2hhcnRzL2NoYXJ0LWFwZXguc2Nzc1wiKSkpXG5fX3dlYnBhY2tfcmVxdWlyZV9fLk8odW5kZWZpbmVkLCBbXCJjc3MvYmFzZS9wbHVnaW5zL2V4dGVuc2lvbnMvZXh0LWNvbXBvbmVudC1tZWRpYS1wbGF5ZXJcIixcImNzcy9iYXNlL3BsdWdpbnMvZXh0ZW5zaW9ucy9leHQtY29tcG9uZW50LWRyYWctZHJvcFwiLFwiY3NzL2Jhc2UvcGx1Z2lucy9leHRlbnNpb25zL2V4dC1jb21wb25lbnQtY29udGV4dC1tZW51XCIsXCJjc3MvYmFzZS9wbHVnaW5zL2NoYXJ0cy9jaGFydC1hcGV4XCIsXCJjc3Mvc3R5bGVcIixcImNzcy9vdmVycmlkZXNcIixcImNzcy9jb3JlXCIsXCJjc3MvYmFzZS90aGVtZXMvZGFyay1sYXlvdXRcIixcImNzcy9iYXNlL2NvcmUvbWl4aW5zL3RyYW5zaXRpb25zXCIsXCJjc3MvYmFzZS9jb3JlL21peGlucy9tYWluLW1lbnUtbWl4aW5cIixcImNzcy9iYXNlL2NvcmUvbWl4aW5zL2hleDJyZ2JcIixcImNzcy9iYXNlL2NvcmUvbWl4aW5zL2FsZXJ0XCIsXCJjc3MvYmFzZS9jb3JlL21lbnUvbWVudS10eXBlcy92ZXJ0aWNhbC1vdmVybGF5LW1lbnVcIixcImNzcy9iYXNlL2NvcmUvbWVudS9tZW51LXR5cGVzL3ZlcnRpY2FsLW1lbnVcIixcImNzcy9iYXNlL2NvcmUvbWVudS9tZW51LXR5cGVzL2hvcml6b250YWwtbWVudVwiLFwiY3NzL2Jhc2UvY29yZS9jb2xvcnMvcGFsZXR0ZS12YXJpYWJsZXNcIixcImNzcy9iYXNlL2NvcmUvY29sb3JzL3BhbGV0dGUtbm91aVwiLFwiY3NzL2Jhc2UvY29yZS9jb2xvcnMvcGFsZXR0ZS1ncmFkaWVudFwiLFwiY3NzL2Jhc2UvcGFnZXMvdWktZmVhdGhlclwiLFwiY3NzL2Jhc2UvcGFnZXMvcGFnZS1wcm9maWxlXCIsXCJjc3MvYmFzZS9wYWdlcy9wYWdlLXByaWNpbmdcIixcImNzcy9iYXNlL3BhZ2VzL3BhZ2UtbWlzY1wiLFwiY3NzL2Jhc2UvcGFnZXMvcGFnZS1rbm93bGVkZ2UtYmFzZVwiLFwiY3NzL2Jhc2UvcGFnZXMvcGFnZS1mYXFcIixcImNzcy9iYXNlL3BhZ2VzL3BhZ2UtY29taW5nLXNvb25cIixcImNzcy9iYXNlL3BhZ2VzL3BhZ2UtYmxvZ1wiLFwiY3NzL2Jhc2UvcGFnZXMvbW9kYWwtY3JlYXRlLWFwcFwiLFwiY3NzL2Jhc2UvcGFnZXMvZGFzaGJvYXJkLWVjb21tZXJjZVwiLFwiY3NzL2Jhc2UvcGFnZXMvYXV0aGVudGljYXRpb25cIixcImNzcy9iYXNlL3BhZ2VzL2FwcC10b2RvXCIsXCJjc3MvYmFzZS9wYWdlcy9hcHAta2FuYmFuXCIsXCJjc3MvYmFzZS9wYWdlcy9hcHAtaW52b2ljZVwiLFwiY3NzL2Jhc2UvcGFnZXMvYXBwLWludm9pY2UtcHJpbnRcIixcImNzcy9iYXNlL3BhZ2VzL2FwcC1pbnZvaWNlLWxpc3RcIixcImNzcy9iYXNlL3BhZ2VzL2FwcC1maWxlLW1hbmFnZXJcIixcImNzcy9iYXNlL3BhZ2VzL2FwcC1lbWFpbFwiLFwiY3NzL2Jhc2UvcGFnZXMvYXBwLWVjb21tZXJjZVwiLFwiY3NzL2Jhc2UvcGFnZXMvYXBwLWVjb21tZXJjZS1kZXRhaWxzXCIsXCJjc3MvYmFzZS9wYWdlcy9hcHAtY2hhdFwiLFwiY3NzL2Jhc2UvcGFnZXMvYXBwLWNoYXQtbGlzdFwiLFwiY3NzL2Jhc2UvcGFnZXMvYXBwLWNhbGVuZGFyXCIsXCJjc3MvYmFzZS9wbHVnaW5zL3VpL2NvbWluZy1zb29uXCIsXCJjc3MvYmFzZS9wbHVnaW5zL21hcHMvbWFwLWxlYWZsZXRcIixcImNzcy9iYXNlL3BsdWdpbnMvZm9ybXMvcGlja2Vycy9mb3JtLXBpY2thZGF0ZVwiLFwiY3NzL2Jhc2UvcGx1Z2lucy9mb3Jtcy9waWNrZXJzL2Zvcm0tZmxhdC1waWNrclwiLFwiY3NzL2Jhc2UvcGx1Z2lucy9mb3Jtcy9mb3JtLXdpemFyZFwiLFwiY3NzL2Jhc2UvcGx1Z2lucy9mb3Jtcy9mb3JtLXZhbGlkYXRpb25cIixcImNzcy9iYXNlL3BsdWdpbnMvZm9ybXMvZm9ybS1xdWlsbC1lZGl0b3JcIixcImNzcy9iYXNlL3BsdWdpbnMvZm9ybXMvZm9ybS1udW1iZXItaW5wdXRcIixcImNzcy9iYXNlL3BsdWdpbnMvZm9ybXMvZm9ybS1maWxlLXVwbG9hZGVyXCIsXCJjc3MvYmFzZS9wbHVnaW5zL2V4dGVuc2lvbnMvZXh0LWNvbXBvbmVudC10cmVlXCIsXCJjc3MvYmFzZS9wbHVnaW5zL2V4dGVuc2lvbnMvZXh0LWNvbXBvbmVudC10b3VyXCIsXCJjc3MvYmFzZS9wbHVnaW5zL2V4dGVuc2lvbnMvZXh0LWNvbXBvbmVudC10b2FzdHJcIixcImNzcy9iYXNlL3BsdWdpbnMvZXh0ZW5zaW9ucy9leHQtY29tcG9uZW50LXN3aXBlclwiLFwiY3NzL2Jhc2UvcGx1Z2lucy9leHRlbnNpb25zL2V4dC1jb21wb25lbnQtc3dlZXQtYWxlcnRzXCIsXCJjc3MvYmFzZS9wbHVnaW5zL2V4dGVuc2lvbnMvZXh0LWNvbXBvbmVudC1zbGlkZXJzXCIsXCJjc3MvYmFzZS9wbHVnaW5zL2V4dGVuc2lvbnMvZXh0LWNvbXBvbmVudC1yYXRpbmdzXCJdLCAoKSA9PiAoX193ZWJwYWNrX3JlcXVpcmVfXyhcIi4vcmVzb3VyY2VzL3Njc3MvYmFzZS9wbHVnaW5zL2V4dGVuc2lvbnMvZXh0LWNvbXBvbmVudC1jb250ZXh0LW1lbnUuc2Nzc1wiKSkpXG5fX3dlYnBhY2tfcmVxdWlyZV9fLk8odW5kZWZpbmVkLCBbXCJjc3MvYmFzZS9wbHVnaW5zL2V4dGVuc2lvbnMvZXh0LWNvbXBvbmVudC1tZWRpYS1wbGF5ZXJcIixcImNzcy9iYXNlL3BsdWdpbnMvZXh0ZW5zaW9ucy9leHQtY29tcG9uZW50LWRyYWctZHJvcFwiLFwiY3NzL2Jhc2UvcGx1Z2lucy9leHRlbnNpb25zL2V4dC1jb21wb25lbnQtY29udGV4dC1tZW51XCIsXCJjc3MvYmFzZS9wbHVnaW5zL2NoYXJ0cy9jaGFydC1hcGV4XCIsXCJjc3Mvc3R5bGVcIixcImNzcy9vdmVycmlkZXNcIixcImNzcy9jb3JlXCIsXCJjc3MvYmFzZS90aGVtZXMvZGFyay1sYXlvdXRcIixcImNzcy9iYXNlL2NvcmUvbWl4aW5zL3RyYW5zaXRpb25zXCIsXCJjc3MvYmFzZS9jb3JlL21peGlucy9tYWluLW1lbnUtbWl4aW5cIixcImNzcy9iYXNlL2NvcmUvbWl4aW5zL2hleDJyZ2JcIixcImNzcy9iYXNlL2NvcmUvbWl4aW5zL2FsZXJ0XCIsXCJjc3MvYmFzZS9jb3JlL21lbnUvbWVudS10eXBlcy92ZXJ0aWNhbC1vdmVybGF5LW1lbnVcIixcImNzcy9iYXNlL2NvcmUvbWVudS9tZW51LXR5cGVzL3ZlcnRpY2FsLW1lbnVcIixcImNzcy9iYXNlL2NvcmUvbWVudS9tZW51LXR5cGVzL2hvcml6b250YWwtbWVudVwiLFwiY3NzL2Jhc2UvY29yZS9jb2xvcnMvcGFsZXR0ZS12YXJpYWJsZXNcIixcImNzcy9iYXNlL2NvcmUvY29sb3JzL3BhbGV0dGUtbm91aVwiLFwiY3NzL2Jhc2UvY29yZS9jb2xvcnMvcGFsZXR0ZS1ncmFkaWVudFwiLFwiY3NzL2Jhc2UvcGFnZXMvdWktZmVhdGhlclwiLFwiY3NzL2Jhc2UvcGFnZXMvcGFnZS1wcm9maWxlXCIsXCJjc3MvYmFzZS9wYWdlcy9wYWdlLXByaWNpbmdcIixcImNzcy9iYXNlL3BhZ2VzL3BhZ2UtbWlzY1wiLFwiY3NzL2Jhc2UvcGFnZXMvcGFnZS1rbm93bGVkZ2UtYmFzZVwiLFwiY3NzL2Jhc2UvcGFnZXMvcGFnZS1mYXFcIixcImNzcy9iYXNlL3BhZ2VzL3BhZ2UtY29taW5nLXNvb25cIixcImNzcy9iYXNlL3BhZ2VzL3BhZ2UtYmxvZ1wiLFwiY3NzL2Jhc2UvcGFnZXMvbW9kYWwtY3JlYXRlLWFwcFwiLFwiY3NzL2Jhc2UvcGFnZXMvZGFzaGJvYXJkLWVjb21tZXJjZVwiLFwiY3NzL2Jhc2UvcGFnZXMvYXV0aGVudGljYXRpb25cIixcImNzcy9iYXNlL3BhZ2VzL2FwcC10b2RvXCIsXCJjc3MvYmFzZS9wYWdlcy9hcHAta2FuYmFuXCIsXCJjc3MvYmFzZS9wYWdlcy9hcHAtaW52b2ljZVwiLFwiY3NzL2Jhc2UvcGFnZXMvYXBwLWludm9pY2UtcHJpbnRcIixcImNzcy9iYXNlL3BhZ2VzL2FwcC1pbnZvaWNlLWxpc3RcIixcImNzcy9iYXNlL3BhZ2VzL2FwcC1maWxlLW1hbmFnZXJcIixcImNzcy9iYXNlL3BhZ2VzL2FwcC1lbWFpbFwiLFwiY3NzL2Jhc2UvcGFnZXMvYXBwLWVjb21tZXJjZVwiLFwiY3NzL2Jhc2UvcGFnZXMvYXBwLWVjb21tZXJjZS1kZXRhaWxzXCIsXCJjc3MvYmFzZS9wYWdlcy9hcHAtY2hhdFwiLFwiY3NzL2Jhc2UvcGFnZXMvYXBwLWNoYXQtbGlzdFwiLFwiY3NzL2Jhc2UvcGFnZXMvYXBwLWNhbGVuZGFyXCIsXCJjc3MvYmFzZS9wbHVnaW5zL3VpL2NvbWluZy1zb29uXCIsXCJjc3MvYmFzZS9wbHVnaW5zL21hcHMvbWFwLWxlYWZsZXRcIixcImNzcy9iYXNlL3BsdWdpbnMvZm9ybXMvcGlja2Vycy9mb3JtLXBpY2thZGF0ZVwiLFwiY3NzL2Jhc2UvcGx1Z2lucy9mb3Jtcy9waWNrZXJzL2Zvcm0tZmxhdC1waWNrclwiLFwiY3NzL2Jhc2UvcGx1Z2lucy9mb3Jtcy9mb3JtLXdpemFyZFwiLFwiY3NzL2Jhc2UvcGx1Z2lucy9mb3Jtcy9mb3JtLXZhbGlkYXRpb25cIixcImNzcy9iYXNlL3BsdWdpbnMvZm9ybXMvZm9ybS1xdWlsbC1lZGl0b3JcIixcImNzcy9iYXNlL3BsdWdpbnMvZm9ybXMvZm9ybS1udW1iZXItaW5wdXRcIixcImNzcy9iYXNlL3BsdWdpbnMvZm9ybXMvZm9ybS1maWxlLXVwbG9hZGVyXCIsXCJjc3MvYmFzZS9wbHVnaW5zL2V4dGVuc2lvbnMvZXh0LWNvbXBvbmVudC10cmVlXCIsXCJjc3MvYmFzZS9wbHVnaW5zL2V4dGVuc2lvbnMvZXh0LWNvbXBvbmVudC10b3VyXCIsXCJjc3MvYmFzZS9wbHVnaW5zL2V4dGVuc2lvbnMvZXh0LWNvbXBvbmVudC10b2FzdHJcIixcImNzcy9iYXNlL3BsdWdpbnMvZXh0ZW5zaW9ucy9leHQtY29tcG9uZW50LXN3aXBlclwiLFwiY3NzL2Jhc2UvcGx1Z2lucy9leHRlbnNpb25zL2V4dC1jb21wb25lbnQtc3dlZXQtYWxlcnRzXCIsXCJjc3MvYmFzZS9wbHVnaW5zL2V4dGVuc2lvbnMvZXh0LWNvbXBvbmVudC1zbGlkZXJzXCIsXCJjc3MvYmFzZS9wbHVnaW5zL2V4dGVuc2lvbnMvZXh0LWNvbXBvbmVudC1yYXRpbmdzXCJdLCAoKSA9PiAoX193ZWJwYWNrX3JlcXVpcmVfXyhcIi4vcmVzb3VyY2VzL3Njc3MvYmFzZS9wbHVnaW5zL2V4dGVuc2lvbnMvZXh0LWNvbXBvbmVudC1kcmFnLWRyb3Auc2Nzc1wiKSkpXG5fX3dlYnBhY2tfcmVxdWlyZV9fLk8odW5kZWZpbmVkLCBbXCJjc3MvYmFzZS9wbHVnaW5zL2V4dGVuc2lvbnMvZXh0LWNvbXBvbmVudC1tZWRpYS1wbGF5ZXJcIixcImNzcy9iYXNlL3BsdWdpbnMvZXh0ZW5zaW9ucy9leHQtY29tcG9uZW50LWRyYWctZHJvcFwiLFwiY3NzL2Jhc2UvcGx1Z2lucy9leHRlbnNpb25zL2V4dC1jb21wb25lbnQtY29udGV4dC1tZW51XCIsXCJjc3MvYmFzZS9wbHVnaW5zL2NoYXJ0cy9jaGFydC1hcGV4XCIsXCJjc3Mvc3R5bGVcIixcImNzcy9vdmVycmlkZXNcIixcImNzcy9jb3JlXCIsXCJjc3MvYmFzZS90aGVtZXMvZGFyay1sYXlvdXRcIixcImNzcy9iYXNlL2NvcmUvbWl4aW5zL3RyYW5zaXRpb25zXCIsXCJjc3MvYmFzZS9jb3JlL21peGlucy9tYWluLW1lbnUtbWl4aW5cIixcImNzcy9iYXNlL2NvcmUvbWl4aW5zL2hleDJyZ2JcIixcImNzcy9iYXNlL2NvcmUvbWl4aW5zL2FsZXJ0XCIsXCJjc3MvYmFzZS9jb3JlL21lbnUvbWVudS10eXBlcy92ZXJ0aWNhbC1vdmVybGF5LW1lbnVcIixcImNzcy9iYXNlL2NvcmUvbWVudS9tZW51LXR5cGVzL3ZlcnRpY2FsLW1lbnVcIixcImNzcy9iYXNlL2NvcmUvbWVudS9tZW51LXR5cGVzL2hvcml6b250YWwtbWVudVwiLFwiY3NzL2Jhc2UvY29yZS9jb2xvcnMvcGFsZXR0ZS12YXJpYWJsZXNcIixcImNzcy9iYXNlL2NvcmUvY29sb3JzL3BhbGV0dGUtbm91aVwiLFwiY3NzL2Jhc2UvY29yZS9jb2xvcnMvcGFsZXR0ZS1ncmFkaWVudFwiLFwiY3NzL2Jhc2UvcGFnZXMvdWktZmVhdGhlclwiLFwiY3NzL2Jhc2UvcGFnZXMvcGFnZS1wcm9maWxlXCIsXCJjc3MvYmFzZS9wYWdlcy9wYWdlLXByaWNpbmdcIixcImNzcy9iYXNlL3BhZ2VzL3BhZ2UtbWlzY1wiLFwiY3NzL2Jhc2UvcGFnZXMvcGFnZS1rbm93bGVkZ2UtYmFzZVwiLFwiY3NzL2Jhc2UvcGFnZXMvcGFnZS1mYXFcIixcImNzcy9iYXNlL3BhZ2VzL3BhZ2UtY29taW5nLXNvb25cIixcImNzcy9iYXNlL3BhZ2VzL3BhZ2UtYmxvZ1wiLFwiY3NzL2Jhc2UvcGFnZXMvbW9kYWwtY3JlYXRlLWFwcFwiLFwiY3NzL2Jhc2UvcGFnZXMvZGFzaGJvYXJkLWVjb21tZXJjZVwiLFwiY3NzL2Jhc2UvcGFnZXMvYXV0aGVudGljYXRpb25cIixcImNzcy9iYXNlL3BhZ2VzL2FwcC10b2RvXCIsXCJjc3MvYmFzZS9wYWdlcy9hcHAta2FuYmFuXCIsXCJjc3MvYmFzZS9wYWdlcy9hcHAtaW52b2ljZVwiLFwiY3NzL2Jhc2UvcGFnZXMvYXBwLWludm9pY2UtcHJpbnRcIixcImNzcy9iYXNlL3BhZ2VzL2FwcC1pbnZvaWNlLWxpc3RcIixcImNzcy9iYXNlL3BhZ2VzL2FwcC1maWxlLW1hbmFnZXJcIixcImNzcy9iYXNlL3BhZ2VzL2FwcC1lbWFpbFwiLFwiY3NzL2Jhc2UvcGFnZXMvYXBwLWVjb21tZXJjZVwiLFwiY3NzL2Jhc2UvcGFnZXMvYXBwLWVjb21tZXJjZS1kZXRhaWxzXCIsXCJjc3MvYmFzZS9wYWdlcy9hcHAtY2hhdFwiLFwiY3NzL2Jhc2UvcGFnZXMvYXBwLWNoYXQtbGlzdFwiLFwiY3NzL2Jhc2UvcGFnZXMvYXBwLWNhbGVuZGFyXCIsXCJjc3MvYmFzZS9wbHVnaW5zL3VpL2NvbWluZy1zb29uXCIsXCJjc3MvYmFzZS9wbHVnaW5zL21hcHMvbWFwLWxlYWZsZXRcIixcImNzcy9iYXNlL3BsdWdpbnMvZm9ybXMvcGlja2Vycy9mb3JtLXBpY2thZGF0ZVwiLFwiY3NzL2Jhc2UvcGx1Z2lucy9mb3Jtcy9waWNrZXJzL2Zvcm0tZmxhdC1waWNrclwiLFwiY3NzL2Jhc2UvcGx1Z2lucy9mb3Jtcy9mb3JtLXdpemFyZFwiLFwiY3NzL2Jhc2UvcGx1Z2lucy9mb3Jtcy9mb3JtLXZhbGlkYXRpb25cIixcImNzcy9iYXNlL3BsdWdpbnMvZm9ybXMvZm9ybS1xdWlsbC1lZGl0b3JcIixcImNzcy9iYXNlL3BsdWdpbnMvZm9ybXMvZm9ybS1udW1iZXItaW5wdXRcIixcImNzcy9iYXNlL3BsdWdpbnMvZm9ybXMvZm9ybS1maWxlLXVwbG9hZGVyXCIsXCJjc3MvYmFzZS9wbHVnaW5zL2V4dGVuc2lvbnMvZXh0LWNvbXBvbmVudC10cmVlXCIsXCJjc3MvYmFzZS9wbHVnaW5zL2V4dGVuc2lvbnMvZXh0LWNvbXBvbmVudC10b3VyXCIsXCJjc3MvYmFzZS9wbHVnaW5zL2V4dGVuc2lvbnMvZXh0LWNvbXBvbmVudC10b2FzdHJcIixcImNzcy9iYXNlL3BsdWdpbnMvZXh0ZW5zaW9ucy9leHQtY29tcG9uZW50LXN3aXBlclwiLFwiY3NzL2Jhc2UvcGx1Z2lucy9leHRlbnNpb25zL2V4dC1jb21wb25lbnQtc3dlZXQtYWxlcnRzXCIsXCJjc3MvYmFzZS9wbHVnaW5zL2V4dGVuc2lvbnMvZXh0LWNvbXBvbmVudC1zbGlkZXJzXCIsXCJjc3MvYmFzZS9wbHVnaW5zL2V4dGVuc2lvbnMvZXh0LWNvbXBvbmVudC1yYXRpbmdzXCJdLCAoKSA9PiAoX193ZWJwYWNrX3JlcXVpcmVfXyhcIi4vcmVzb3VyY2VzL3Njc3MvYmFzZS9wbHVnaW5zL2V4dGVuc2lvbnMvZXh0LWNvbXBvbmVudC1tZWRpYS1wbGF5ZXIuc2Nzc1wiKSkpXG5fX3dlYnBhY2tfcmVxdWlyZV9fLk8odW5kZWZpbmVkLCBbXCJjc3MvYmFzZS9wbHVnaW5zL2V4dGVuc2lvbnMvZXh0LWNvbXBvbmVudC1tZWRpYS1wbGF5ZXJcIixcImNzcy9iYXNlL3BsdWdpbnMvZXh0ZW5zaW9ucy9leHQtY29tcG9uZW50LWRyYWctZHJvcFwiLFwiY3NzL2Jhc2UvcGx1Z2lucy9leHRlbnNpb25zL2V4dC1jb21wb25lbnQtY29udGV4dC1tZW51XCIsXCJjc3MvYmFzZS9wbHVnaW5zL2NoYXJ0cy9jaGFydC1hcGV4XCIsXCJjc3Mvc3R5bGVcIixcImNzcy9vdmVycmlkZXNcIixcImNzcy9jb3JlXCIsXCJjc3MvYmFzZS90aGVtZXMvZGFyay1sYXlvdXRcIixcImNzcy9iYXNlL2NvcmUvbWl4aW5zL3RyYW5zaXRpb25zXCIsXCJjc3MvYmFzZS9jb3JlL21peGlucy9tYWluLW1lbnUtbWl4aW5cIixcImNzcy9iYXNlL2NvcmUvbWl4aW5zL2hleDJyZ2JcIixcImNzcy9iYXNlL2NvcmUvbWl4aW5zL2FsZXJ0XCIsXCJjc3MvYmFzZS9jb3JlL21lbnUvbWVudS10eXBlcy92ZXJ0aWNhbC1vdmVybGF5LW1lbnVcIixcImNzcy9iYXNlL2NvcmUvbWVudS9tZW51LXR5cGVzL3ZlcnRpY2FsLW1lbnVcIixcImNzcy9iYXNlL2NvcmUvbWVudS9tZW51LXR5cGVzL2hvcml6b250YWwtbWVudVwiLFwiY3NzL2Jhc2UvY29yZS9jb2xvcnMvcGFsZXR0ZS12YXJpYWJsZXNcIixcImNzcy9iYXNlL2NvcmUvY29sb3JzL3BhbGV0dGUtbm91aVwiLFwiY3NzL2Jhc2UvY29yZS9jb2xvcnMvcGFsZXR0ZS1ncmFkaWVudFwiLFwiY3NzL2Jhc2UvcGFnZXMvdWktZmVhdGhlclwiLFwiY3NzL2Jhc2UvcGFnZXMvcGFnZS1wcm9maWxlXCIsXCJjc3MvYmFzZS9wYWdlcy9wYWdlLXByaWNpbmdcIixcImNzcy9iYXNlL3BhZ2VzL3BhZ2UtbWlzY1wiLFwiY3NzL2Jhc2UvcGFnZXMvcGFnZS1rbm93bGVkZ2UtYmFzZVwiLFwiY3NzL2Jhc2UvcGFnZXMvcGFnZS1mYXFcIixcImNzcy9iYXNlL3BhZ2VzL3BhZ2UtY29taW5nLXNvb25cIixcImNzcy9iYXNlL3BhZ2VzL3BhZ2UtYmxvZ1wiLFwiY3NzL2Jhc2UvcGFnZXMvbW9kYWwtY3JlYXRlLWFwcFwiLFwiY3NzL2Jhc2UvcGFnZXMvZGFzaGJvYXJkLWVjb21tZXJjZVwiLFwiY3NzL2Jhc2UvcGFnZXMvYXV0aGVudGljYXRpb25cIixcImNzcy9iYXNlL3BhZ2VzL2FwcC10b2RvXCIsXCJjc3MvYmFzZS9wYWdlcy9hcHAta2FuYmFuXCIsXCJjc3MvYmFzZS9wYWdlcy9hcHAtaW52b2ljZVwiLFwiY3NzL2Jhc2UvcGFnZXMvYXBwLWludm9pY2UtcHJpbnRcIixcImNzcy9iYXNlL3BhZ2VzL2FwcC1pbnZvaWNlLWxpc3RcIixcImNzcy9iYXNlL3BhZ2VzL2FwcC1maWxlLW1hbmFnZXJcIixcImNzcy9iYXNlL3BhZ2VzL2FwcC1lbWFpbFwiLFwiY3NzL2Jhc2UvcGFnZXMvYXBwLWVjb21tZXJjZVwiLFwiY3NzL2Jhc2UvcGFnZXMvYXBwLWVjb21tZXJjZS1kZXRhaWxzXCIsXCJjc3MvYmFzZS9wYWdlcy9hcHAtY2hhdFwiLFwiY3NzL2Jhc2UvcGFnZXMvYXBwLWNoYXQtbGlzdFwiLFwiY3NzL2Jhc2UvcGFnZXMvYXBwLWNhbGVuZGFyXCIsXCJjc3MvYmFzZS9wbHVnaW5zL3VpL2NvbWluZy1zb29uXCIsXCJjc3MvYmFzZS9wbHVnaW5zL21hcHMvbWFwLWxlYWZsZXRcIixcImNzcy9iYXNlL3BsdWdpbnMvZm9ybXMvcGlja2Vycy9mb3JtLXBpY2thZGF0ZVwiLFwiY3NzL2Jhc2UvcGx1Z2lucy9mb3Jtcy9waWNrZXJzL2Zvcm0tZmxhdC1waWNrclwiLFwiY3NzL2Jhc2UvcGx1Z2lucy9mb3Jtcy9mb3JtLXdpemFyZFwiLFwiY3NzL2Jhc2UvcGx1Z2lucy9mb3Jtcy9mb3JtLXZhbGlkYXRpb25cIixcImNzcy9iYXNlL3BsdWdpbnMvZm9ybXMvZm9ybS1xdWlsbC1lZGl0b3JcIixcImNzcy9iYXNlL3BsdWdpbnMvZm9ybXMvZm9ybS1udW1iZXItaW5wdXRcIixcImNzcy9iYXNlL3BsdWdpbnMvZm9ybXMvZm9ybS1maWxlLXVwbG9hZGVyXCIsXCJjc3MvYmFzZS9wbHVnaW5zL2V4dGVuc2lvbnMvZXh0LWNvbXBvbmVudC10cmVlXCIsXCJjc3MvYmFzZS9wbHVnaW5zL2V4dGVuc2lvbnMvZXh0LWNvbXBvbmVudC10b3VyXCIsXCJjc3MvYmFzZS9wbHVnaW5zL2V4dGVuc2lvbnMvZXh0LWNvbXBvbmVudC10b2FzdHJcIixcImNzcy9iYXNlL3BsdWdpbnMvZXh0ZW5zaW9ucy9leHQtY29tcG9uZW50LXN3aXBlclwiLFwiY3NzL2Jhc2UvcGx1Z2lucy9leHRlbnNpb25zL2V4dC1jb21wb25lbnQtc3dlZXQtYWxlcnRzXCIsXCJjc3MvYmFzZS9wbHVnaW5zL2V4dGVuc2lvbnMvZXh0LWNvbXBvbmVudC1zbGlkZXJzXCIsXCJjc3MvYmFzZS9wbHVnaW5zL2V4dGVuc2lvbnMvZXh0LWNvbXBvbmVudC1yYXRpbmdzXCJdLCAoKSA9PiAoX193ZWJwYWNrX3JlcXVpcmVfXyhcIi4vcmVzb3VyY2VzL3Njc3MvYmFzZS9wbHVnaW5zL2V4dGVuc2lvbnMvZXh0LWNvbXBvbmVudC1yYXRpbmdzLnNjc3NcIikpKVxuX193ZWJwYWNrX3JlcXVpcmVfXy5PKHVuZGVmaW5lZCwgW1wiY3NzL2Jhc2UvcGx1Z2lucy9leHRlbnNpb25zL2V4dC1jb21wb25lbnQtbWVkaWEtcGxheWVyXCIsXCJjc3MvYmFzZS9wbHVnaW5zL2V4dGVuc2lvbnMvZXh0LWNvbXBvbmVudC1kcmFnLWRyb3BcIixcImNzcy9iYXNlL3BsdWdpbnMvZXh0ZW5zaW9ucy9leHQtY29tcG9uZW50LWNvbnRleHQtbWVudVwiLFwiY3NzL2Jhc2UvcGx1Z2lucy9jaGFydHMvY2hhcnQtYXBleFwiLFwiY3NzL3N0eWxlXCIsXCJjc3Mvb3ZlcnJpZGVzXCIsXCJjc3MvY29yZVwiLFwiY3NzL2Jhc2UvdGhlbWVzL2RhcmstbGF5b3V0XCIsXCJjc3MvYmFzZS9jb3JlL21peGlucy90cmFuc2l0aW9uc1wiLFwiY3NzL2Jhc2UvY29yZS9taXhpbnMvbWFpbi1tZW51LW1peGluXCIsXCJjc3MvYmFzZS9jb3JlL21peGlucy9oZXgycmdiXCIsXCJjc3MvYmFzZS9jb3JlL21peGlucy9hbGVydFwiLFwiY3NzL2Jhc2UvY29yZS9tZW51L21lbnUtdHlwZXMvdmVydGljYWwtb3ZlcmxheS1tZW51XCIsXCJjc3MvYmFzZS9jb3JlL21lbnUvbWVudS10eXBlcy92ZXJ0aWNhbC1tZW51XCIsXCJjc3MvYmFzZS9jb3JlL21lbnUvbWVudS10eXBlcy9ob3Jpem9udGFsLW1lbnVcIixcImNzcy9iYXNlL2NvcmUvY29sb3JzL3BhbGV0dGUtdmFyaWFibGVzXCIsXCJjc3MvYmFzZS9jb3JlL2NvbG9ycy9wYWxldHRlLW5vdWlcIixcImNzcy9iYXNlL2NvcmUvY29sb3JzL3BhbGV0dGUtZ3JhZGllbnRcIixcImNzcy9iYXNlL3BhZ2VzL3VpLWZlYXRoZXJcIixcImNzcy9iYXNlL3BhZ2VzL3BhZ2UtcHJvZmlsZVwiLFwiY3NzL2Jhc2UvcGFnZXMvcGFnZS1wcmljaW5nXCIsXCJjc3MvYmFzZS9wYWdlcy9wYWdlLW1pc2NcIixcImNzcy9iYXNlL3BhZ2VzL3BhZ2Uta25vd2xlZGdlLWJhc2VcIixcImNzcy9iYXNlL3BhZ2VzL3BhZ2UtZmFxXCIsXCJjc3MvYmFzZS9wYWdlcy9wYWdlLWNvbWluZy1zb29uXCIsXCJjc3MvYmFzZS9wYWdlcy9wYWdlLWJsb2dcIixcImNzcy9iYXNlL3BhZ2VzL21vZGFsLWNyZWF0ZS1hcHBcIixcImNzcy9iYXNlL3BhZ2VzL2Rhc2hib2FyZC1lY29tbWVyY2VcIixcImNzcy9iYXNlL3BhZ2VzL2F1dGhlbnRpY2F0aW9uXCIsXCJjc3MvYmFzZS9wYWdlcy9hcHAtdG9kb1wiLFwiY3NzL2Jhc2UvcGFnZXMvYXBwLWthbmJhblwiLFwiY3NzL2Jhc2UvcGFnZXMvYXBwLWludm9pY2VcIixcImNzcy9iYXNlL3BhZ2VzL2FwcC1pbnZvaWNlLXByaW50XCIsXCJjc3MvYmFzZS9wYWdlcy9hcHAtaW52b2ljZS1saXN0XCIsXCJjc3MvYmFzZS9wYWdlcy9hcHAtZmlsZS1tYW5hZ2VyXCIsXCJjc3MvYmFzZS9wYWdlcy9hcHAtZW1haWxcIixcImNzcy9iYXNlL3BhZ2VzL2FwcC1lY29tbWVyY2VcIixcImNzcy9iYXNlL3BhZ2VzL2FwcC1lY29tbWVyY2UtZGV0YWlsc1wiLFwiY3NzL2Jhc2UvcGFnZXMvYXBwLWNoYXRcIixcImNzcy9iYXNlL3BhZ2VzL2FwcC1jaGF0LWxpc3RcIixcImNzcy9iYXNlL3BhZ2VzL2FwcC1jYWxlbmRhclwiLFwiY3NzL2Jhc2UvcGx1Z2lucy91aS9jb21pbmctc29vblwiLFwiY3NzL2Jhc2UvcGx1Z2lucy9tYXBzL21hcC1sZWFmbGV0XCIsXCJjc3MvYmFzZS9wbHVnaW5zL2Zvcm1zL3BpY2tlcnMvZm9ybS1waWNrYWRhdGVcIixcImNzcy9iYXNlL3BsdWdpbnMvZm9ybXMvcGlja2Vycy9mb3JtLWZsYXQtcGlja3JcIixcImNzcy9iYXNlL3BsdWdpbnMvZm9ybXMvZm9ybS13aXphcmRcIixcImNzcy9iYXNlL3BsdWdpbnMvZm9ybXMvZm9ybS12YWxpZGF0aW9uXCIsXCJjc3MvYmFzZS9wbHVnaW5zL2Zvcm1zL2Zvcm0tcXVpbGwtZWRpdG9yXCIsXCJjc3MvYmFzZS9wbHVnaW5zL2Zvcm1zL2Zvcm0tbnVtYmVyLWlucHV0XCIsXCJjc3MvYmFzZS9wbHVnaW5zL2Zvcm1zL2Zvcm0tZmlsZS11cGxvYWRlclwiLFwiY3NzL2Jhc2UvcGx1Z2lucy9leHRlbnNpb25zL2V4dC1jb21wb25lbnQtdHJlZVwiLFwiY3NzL2Jhc2UvcGx1Z2lucy9leHRlbnNpb25zL2V4dC1jb21wb25lbnQtdG91clwiLFwiY3NzL2Jhc2UvcGx1Z2lucy9leHRlbnNpb25zL2V4dC1jb21wb25lbnQtdG9hc3RyXCIsXCJjc3MvYmFzZS9wbHVnaW5zL2V4dGVuc2lvbnMvZXh0LWNvbXBvbmVudC1zd2lwZXJcIixcImNzcy9iYXNlL3BsdWdpbnMvZXh0ZW5zaW9ucy9leHQtY29tcG9uZW50LXN3ZWV0LWFsZXJ0c1wiLFwiY3NzL2Jhc2UvcGx1Z2lucy9leHRlbnNpb25zL2V4dC1jb21wb25lbnQtc2xpZGVyc1wiLFwiY3NzL2Jhc2UvcGx1Z2lucy9leHRlbnNpb25zL2V4dC1jb21wb25lbnQtcmF0aW5nc1wiXSwgKCkgPT4gKF9fd2VicGFja19yZXF1aXJlX18oXCIuL3Jlc291cmNlcy9zY3NzL2Jhc2UvcGx1Z2lucy9leHRlbnNpb25zL2V4dC1jb21wb25lbnQtc2xpZGVycy5zY3NzXCIpKSlcbl9fd2VicGFja19yZXF1aXJlX18uTyh1bmRlZmluZWQsIFtcImNzcy9iYXNlL3BsdWdpbnMvZXh0ZW5zaW9ucy9leHQtY29tcG9uZW50LW1lZGlhLXBsYXllclwiLFwiY3NzL2Jhc2UvcGx1Z2lucy9leHRlbnNpb25zL2V4dC1jb21wb25lbnQtZHJhZy1kcm9wXCIsXCJjc3MvYmFzZS9wbHVnaW5zL2V4dGVuc2lvbnMvZXh0LWNvbXBvbmVudC1jb250ZXh0LW1lbnVcIixcImNzcy9iYXNlL3BsdWdpbnMvY2hhcnRzL2NoYXJ0LWFwZXhcIixcImNzcy9zdHlsZVwiLFwiY3NzL292ZXJyaWRlc1wiLFwiY3NzL2NvcmVcIixcImNzcy9iYXNlL3RoZW1lcy9kYXJrLWxheW91dFwiLFwiY3NzL2Jhc2UvY29yZS9taXhpbnMvdHJhbnNpdGlvbnNcIixcImNzcy9iYXNlL2NvcmUvbWl4aW5zL21haW4tbWVudS1taXhpblwiLFwiY3NzL2Jhc2UvY29yZS9taXhpbnMvaGV4MnJnYlwiLFwiY3NzL2Jhc2UvY29yZS9taXhpbnMvYWxlcnRcIixcImNzcy9iYXNlL2NvcmUvbWVudS9tZW51LXR5cGVzL3ZlcnRpY2FsLW92ZXJsYXktbWVudVwiLFwiY3NzL2Jhc2UvY29yZS9tZW51L21lbnUtdHlwZXMvdmVydGljYWwtbWVudVwiLFwiY3NzL2Jhc2UvY29yZS9tZW51L21lbnUtdHlwZXMvaG9yaXpvbnRhbC1tZW51XCIsXCJjc3MvYmFzZS9jb3JlL2NvbG9ycy9wYWxldHRlLXZhcmlhYmxlc1wiLFwiY3NzL2Jhc2UvY29yZS9jb2xvcnMvcGFsZXR0ZS1ub3VpXCIsXCJjc3MvYmFzZS9jb3JlL2NvbG9ycy9wYWxldHRlLWdyYWRpZW50XCIsXCJjc3MvYmFzZS9wYWdlcy91aS1mZWF0aGVyXCIsXCJjc3MvYmFzZS9wYWdlcy9wYWdlLXByb2ZpbGVcIixcImNzcy9iYXNlL3BhZ2VzL3BhZ2UtcHJpY2luZ1wiLFwiY3NzL2Jhc2UvcGFnZXMvcGFnZS1taXNjXCIsXCJjc3MvYmFzZS9wYWdlcy9wYWdlLWtub3dsZWRnZS1iYXNlXCIsXCJjc3MvYmFzZS9wYWdlcy9wYWdlLWZhcVwiLFwiY3NzL2Jhc2UvcGFnZXMvcGFnZS1jb21pbmctc29vblwiLFwiY3NzL2Jhc2UvcGFnZXMvcGFnZS1ibG9nXCIsXCJjc3MvYmFzZS9wYWdlcy9tb2RhbC1jcmVhdGUtYXBwXCIsXCJjc3MvYmFzZS9wYWdlcy9kYXNoYm9hcmQtZWNvbW1lcmNlXCIsXCJjc3MvYmFzZS9wYWdlcy9hdXRoZW50aWNhdGlvblwiLFwiY3NzL2Jhc2UvcGFnZXMvYXBwLXRvZG9cIixcImNzcy9iYXNlL3BhZ2VzL2FwcC1rYW5iYW5cIixcImNzcy9iYXNlL3BhZ2VzL2FwcC1pbnZvaWNlXCIsXCJjc3MvYmFzZS9wYWdlcy9hcHAtaW52b2ljZS1wcmludFwiLFwiY3NzL2Jhc2UvcGFnZXMvYXBwLWludm9pY2UtbGlzdFwiLFwiY3NzL2Jhc2UvcGFnZXMvYXBwLWZpbGUtbWFuYWdlclwiLFwiY3NzL2Jhc2UvcGFnZXMvYXBwLWVtYWlsXCIsXCJjc3MvYmFzZS9wYWdlcy9hcHAtZWNvbW1lcmNlXCIsXCJjc3MvYmFzZS9wYWdlcy9hcHAtZWNvbW1lcmNlLWRldGFpbHNcIixcImNzcy9iYXNlL3BhZ2VzL2FwcC1jaGF0XCIsXCJjc3MvYmFzZS9wYWdlcy9hcHAtY2hhdC1saXN0XCIsXCJjc3MvYmFzZS9wYWdlcy9hcHAtY2FsZW5kYXJcIixcImNzcy9iYXNlL3BsdWdpbnMvdWkvY29taW5nLXNvb25cIixcImNzcy9iYXNlL3BsdWdpbnMvbWFwcy9tYXAtbGVhZmxldFwiLFwiY3NzL2Jhc2UvcGx1Z2lucy9mb3Jtcy9waWNrZXJzL2Zvcm0tcGlja2FkYXRlXCIsXCJjc3MvYmFzZS9wbHVnaW5zL2Zvcm1zL3BpY2tlcnMvZm9ybS1mbGF0LXBpY2tyXCIsXCJjc3MvYmFzZS9wbHVnaW5zL2Zvcm1zL2Zvcm0td2l6YXJkXCIsXCJjc3MvYmFzZS9wbHVnaW5zL2Zvcm1zL2Zvcm0tdmFsaWRhdGlvblwiLFwiY3NzL2Jhc2UvcGx1Z2lucy9mb3Jtcy9mb3JtLXF1aWxsLWVkaXRvclwiLFwiY3NzL2Jhc2UvcGx1Z2lucy9mb3Jtcy9mb3JtLW51bWJlci1pbnB1dFwiLFwiY3NzL2Jhc2UvcGx1Z2lucy9mb3Jtcy9mb3JtLWZpbGUtdXBsb2FkZXJcIixcImNzcy9iYXNlL3BsdWdpbnMvZXh0ZW5zaW9ucy9leHQtY29tcG9uZW50LXRyZWVcIixcImNzcy9iYXNlL3BsdWdpbnMvZXh0ZW5zaW9ucy9leHQtY29tcG9uZW50LXRvdXJcIixcImNzcy9iYXNlL3BsdWdpbnMvZXh0ZW5zaW9ucy9leHQtY29tcG9uZW50LXRvYXN0clwiLFwiY3NzL2Jhc2UvcGx1Z2lucy9leHRlbnNpb25zL2V4dC1jb21wb25lbnQtc3dpcGVyXCIsXCJjc3MvYmFzZS9wbHVnaW5zL2V4dGVuc2lvbnMvZXh0LWNvbXBvbmVudC1zd2VldC1hbGVydHNcIixcImNzcy9iYXNlL3BsdWdpbnMvZXh0ZW5zaW9ucy9leHQtY29tcG9uZW50LXNsaWRlcnNcIixcImNzcy9iYXNlL3BsdWdpbnMvZXh0ZW5zaW9ucy9leHQtY29tcG9uZW50LXJhdGluZ3NcIl0sICgpID0+IChfX3dlYnBhY2tfcmVxdWlyZV9fKFwiLi9yZXNvdXJjZXMvc2Nzcy9iYXNlL3BsdWdpbnMvZXh0ZW5zaW9ucy9leHQtY29tcG9uZW50LXN3ZWV0LWFsZXJ0cy5zY3NzXCIpKSlcbl9fd2VicGFja19yZXF1aXJlX18uTyh1bmRlZmluZWQsIFtcImNzcy9iYXNlL3BsdWdpbnMvZXh0ZW5zaW9ucy9leHQtY29tcG9uZW50LW1lZGlhLXBsYXllclwiLFwiY3NzL2Jhc2UvcGx1Z2lucy9leHRlbnNpb25zL2V4dC1jb21wb25lbnQtZHJhZy1kcm9wXCIsXCJjc3MvYmFzZS9wbHVnaW5zL2V4dGVuc2lvbnMvZXh0LWNvbXBvbmVudC1jb250ZXh0LW1lbnVcIixcImNzcy9iYXNlL3BsdWdpbnMvY2hhcnRzL2NoYXJ0LWFwZXhcIixcImNzcy9zdHlsZVwiLFwiY3NzL292ZXJyaWRlc1wiLFwiY3NzL2NvcmVcIixcImNzcy9iYXNlL3RoZW1lcy9kYXJrLWxheW91dFwiLFwiY3NzL2Jhc2UvY29yZS9taXhpbnMvdHJhbnNpdGlvbnNcIixcImNzcy9iYXNlL2NvcmUvbWl4aW5zL21haW4tbWVudS1taXhpblwiLFwiY3NzL2Jhc2UvY29yZS9taXhpbnMvaGV4MnJnYlwiLFwiY3NzL2Jhc2UvY29yZS9taXhpbnMvYWxlcnRcIixcImNzcy9iYXNlL2NvcmUvbWVudS9tZW51LXR5cGVzL3ZlcnRpY2FsLW92ZXJsYXktbWVudVwiLFwiY3NzL2Jhc2UvY29yZS9tZW51L21lbnUtdHlwZXMvdmVydGljYWwtbWVudVwiLFwiY3NzL2Jhc2UvY29yZS9tZW51L21lbnUtdHlwZXMvaG9yaXpvbnRhbC1tZW51XCIsXCJjc3MvYmFzZS9jb3JlL2NvbG9ycy9wYWxldHRlLXZhcmlhYmxlc1wiLFwiY3NzL2Jhc2UvY29yZS9jb2xvcnMvcGFsZXR0ZS1ub3VpXCIsXCJjc3MvYmFzZS9jb3JlL2NvbG9ycy9wYWxldHRlLWdyYWRpZW50XCIsXCJjc3MvYmFzZS9wYWdlcy91aS1mZWF0aGVyXCIsXCJjc3MvYmFzZS9wYWdlcy9wYWdlLXByb2ZpbGVcIixcImNzcy9iYXNlL3BhZ2VzL3BhZ2UtcHJpY2luZ1wiLFwiY3NzL2Jhc2UvcGFnZXMvcGFnZS1taXNjXCIsXCJjc3MvYmFzZS9wYWdlcy9wYWdlLWtub3dsZWRnZS1iYXNlXCIsXCJjc3MvYmFzZS9wYWdlcy9wYWdlLWZhcVwiLFwiY3NzL2Jhc2UvcGFnZXMvcGFnZS1jb21pbmctc29vblwiLFwiY3NzL2Jhc2UvcGFnZXMvcGFnZS1ibG9nXCIsXCJjc3MvYmFzZS9wYWdlcy9tb2RhbC1jcmVhdGUtYXBwXCIsXCJjc3MvYmFzZS9wYWdlcy9kYXNoYm9hcmQtZWNvbW1lcmNlXCIsXCJjc3MvYmFzZS9wYWdlcy9hdXRoZW50aWNhdGlvblwiLFwiY3NzL2Jhc2UvcGFnZXMvYXBwLXRvZG9cIixcImNzcy9iYXNlL3BhZ2VzL2FwcC1rYW5iYW5cIixcImNzcy9iYXNlL3BhZ2VzL2FwcC1pbnZvaWNlXCIsXCJjc3MvYmFzZS9wYWdlcy9hcHAtaW52b2ljZS1wcmludFwiLFwiY3NzL2Jhc2UvcGFnZXMvYXBwLWludm9pY2UtbGlzdFwiLFwiY3NzL2Jhc2UvcGFnZXMvYXBwLWZpbGUtbWFuYWdlclwiLFwiY3NzL2Jhc2UvcGFnZXMvYXBwLWVtYWlsXCIsXCJjc3MvYmFzZS9wYWdlcy9hcHAtZWNvbW1lcmNlXCIsXCJjc3MvYmFzZS9wYWdlcy9hcHAtZWNvbW1lcmNlLWRldGFpbHNcIixcImNzcy9iYXNlL3BhZ2VzL2FwcC1jaGF0XCIsXCJjc3MvYmFzZS9wYWdlcy9hcHAtY2hhdC1saXN0XCIsXCJjc3MvYmFzZS9wYWdlcy9hcHAtY2FsZW5kYXJcIixcImNzcy9iYXNlL3BsdWdpbnMvdWkvY29taW5nLXNvb25cIixcImNzcy9iYXNlL3BsdWdpbnMvbWFwcy9tYXAtbGVhZmxldFwiLFwiY3NzL2Jhc2UvcGx1Z2lucy9mb3Jtcy9waWNrZXJzL2Zvcm0tcGlja2FkYXRlXCIsXCJjc3MvYmFzZS9wbHVnaW5zL2Zvcm1zL3BpY2tlcnMvZm9ybS1mbGF0LXBpY2tyXCIsXCJjc3MvYmFzZS9wbHVnaW5zL2Zvcm1zL2Zvcm0td2l6YXJkXCIsXCJjc3MvYmFzZS9wbHVnaW5zL2Zvcm1zL2Zvcm0tdmFsaWRhdGlvblwiLFwiY3NzL2Jhc2UvcGx1Z2lucy9mb3Jtcy9mb3JtLXF1aWxsLWVkaXRvclwiLFwiY3NzL2Jhc2UvcGx1Z2lucy9mb3Jtcy9mb3JtLW51bWJlci1pbnB1dFwiLFwiY3NzL2Jhc2UvcGx1Z2lucy9mb3Jtcy9mb3JtLWZpbGUtdXBsb2FkZXJcIixcImNzcy9iYXNlL3BsdWdpbnMvZXh0ZW5zaW9ucy9leHQtY29tcG9uZW50LXRyZWVcIixcImNzcy9iYXNlL3BsdWdpbnMvZXh0ZW5zaW9ucy9leHQtY29tcG9uZW50LXRvdXJcIixcImNzcy9iYXNlL3BsdWdpbnMvZXh0ZW5zaW9ucy9leHQtY29tcG9uZW50LXRvYXN0clwiLFwiY3NzL2Jhc2UvcGx1Z2lucy9leHRlbnNpb25zL2V4dC1jb21wb25lbnQtc3dpcGVyXCIsXCJjc3MvYmFzZS9wbHVnaW5zL2V4dGVuc2lvbnMvZXh0LWNvbXBvbmVudC1zd2VldC1hbGVydHNcIixcImNzcy9iYXNlL3BsdWdpbnMvZXh0ZW5zaW9ucy9leHQtY29tcG9uZW50LXNsaWRlcnNcIixcImNzcy9iYXNlL3BsdWdpbnMvZXh0ZW5zaW9ucy9leHQtY29tcG9uZW50LXJhdGluZ3NcIl0sICgpID0+IChfX3dlYnBhY2tfcmVxdWlyZV9fKFwiLi9yZXNvdXJjZXMvc2Nzcy9iYXNlL3BsdWdpbnMvZXh0ZW5zaW9ucy9leHQtY29tcG9uZW50LXN3aXBlci5zY3NzXCIpKSlcbl9fd2VicGFja19yZXF1aXJlX18uTyh1bmRlZmluZWQsIFtcImNzcy9iYXNlL3BsdWdpbnMvZXh0ZW5zaW9ucy9leHQtY29tcG9uZW50LW1lZGlhLXBsYXllclwiLFwiY3NzL2Jhc2UvcGx1Z2lucy9leHRlbnNpb25zL2V4dC1jb21wb25lbnQtZHJhZy1kcm9wXCIsXCJjc3MvYmFzZS9wbHVnaW5zL2V4dGVuc2lvbnMvZXh0LWNvbXBvbmVudC1jb250ZXh0LW1lbnVcIixcImNzcy9iYXNlL3BsdWdpbnMvY2hhcnRzL2NoYXJ0LWFwZXhcIixcImNzcy9zdHlsZVwiLFwiY3NzL292ZXJyaWRlc1wiLFwiY3NzL2NvcmVcIixcImNzcy9iYXNlL3RoZW1lcy9kYXJrLWxheW91dFwiLFwiY3NzL2Jhc2UvY29yZS9taXhpbnMvdHJhbnNpdGlvbnNcIixcImNzcy9iYXNlL2NvcmUvbWl4aW5zL21haW4tbWVudS1taXhpblwiLFwiY3NzL2Jhc2UvY29yZS9taXhpbnMvaGV4MnJnYlwiLFwiY3NzL2Jhc2UvY29yZS9taXhpbnMvYWxlcnRcIixcImNzcy9iYXNlL2NvcmUvbWVudS9tZW51LXR5cGVzL3ZlcnRpY2FsLW92ZXJsYXktbWVudVwiLFwiY3NzL2Jhc2UvY29yZS9tZW51L21lbnUtdHlwZXMvdmVydGljYWwtbWVudVwiLFwiY3NzL2Jhc2UvY29yZS9tZW51L21lbnUtdHlwZXMvaG9yaXpvbnRhbC1tZW51XCIsXCJjc3MvYmFzZS9jb3JlL2NvbG9ycy9wYWxldHRlLXZhcmlhYmxlc1wiLFwiY3NzL2Jhc2UvY29yZS9jb2xvcnMvcGFsZXR0ZS1ub3VpXCIsXCJjc3MvYmFzZS9jb3JlL2NvbG9ycy9wYWxldHRlLWdyYWRpZW50XCIsXCJjc3MvYmFzZS9wYWdlcy91aS1mZWF0aGVyXCIsXCJjc3MvYmFzZS9wYWdlcy9wYWdlLXByb2ZpbGVcIixcImNzcy9iYXNlL3BhZ2VzL3BhZ2UtcHJpY2luZ1wiLFwiY3NzL2Jhc2UvcGFnZXMvcGFnZS1taXNjXCIsXCJjc3MvYmFzZS9wYWdlcy9wYWdlLWtub3dsZWRnZS1iYXNlXCIsXCJjc3MvYmFzZS9wYWdlcy9wYWdlLWZhcVwiLFwiY3NzL2Jhc2UvcGFnZXMvcGFnZS1jb21pbmctc29vblwiLFwiY3NzL2Jhc2UvcGFnZXMvcGFnZS1ibG9nXCIsXCJjc3MvYmFzZS9wYWdlcy9tb2RhbC1jcmVhdGUtYXBwXCIsXCJjc3MvYmFzZS9wYWdlcy9kYXNoYm9hcmQtZWNvbW1lcmNlXCIsXCJjc3MvYmFzZS9wYWdlcy9hdXRoZW50aWNhdGlvblwiLFwiY3NzL2Jhc2UvcGFnZXMvYXBwLXRvZG9cIixcImNzcy9iYXNlL3BhZ2VzL2FwcC1rYW5iYW5cIixcImNzcy9iYXNlL3BhZ2VzL2FwcC1pbnZvaWNlXCIsXCJjc3MvYmFzZS9wYWdlcy9hcHAtaW52b2ljZS1wcmludFwiLFwiY3NzL2Jhc2UvcGFnZXMvYXBwLWludm9pY2UtbGlzdFwiLFwiY3NzL2Jhc2UvcGFnZXMvYXBwLWZpbGUtbWFuYWdlclwiLFwiY3NzL2Jhc2UvcGFnZXMvYXBwLWVtYWlsXCIsXCJjc3MvYmFzZS9wYWdlcy9hcHAtZWNvbW1lcmNlXCIsXCJjc3MvYmFzZS9wYWdlcy9hcHAtZWNvbW1lcmNlLWRldGFpbHNcIixcImNzcy9iYXNlL3BhZ2VzL2FwcC1jaGF0XCIsXCJjc3MvYmFzZS9wYWdlcy9hcHAtY2hhdC1saXN0XCIsXCJjc3MvYmFzZS9wYWdlcy9hcHAtY2FsZW5kYXJcIixcImNzcy9iYXNlL3BsdWdpbnMvdWkvY29taW5nLXNvb25cIixcImNzcy9iYXNlL3BsdWdpbnMvbWFwcy9tYXAtbGVhZmxldFwiLFwiY3NzL2Jhc2UvcGx1Z2lucy9mb3Jtcy9waWNrZXJzL2Zvcm0tcGlja2FkYXRlXCIsXCJjc3MvYmFzZS9wbHVnaW5zL2Zvcm1zL3BpY2tlcnMvZm9ybS1mbGF0LXBpY2tyXCIsXCJjc3MvYmFzZS9wbHVnaW5zL2Zvcm1zL2Zvcm0td2l6YXJkXCIsXCJjc3MvYmFzZS9wbHVnaW5zL2Zvcm1zL2Zvcm0tdmFsaWRhdGlvblwiLFwiY3NzL2Jhc2UvcGx1Z2lucy9mb3Jtcy9mb3JtLXF1aWxsLWVkaXRvclwiLFwiY3NzL2Jhc2UvcGx1Z2lucy9mb3Jtcy9mb3JtLW51bWJlci1pbnB1dFwiLFwiY3NzL2Jhc2UvcGx1Z2lucy9mb3Jtcy9mb3JtLWZpbGUtdXBsb2FkZXJcIixcImNzcy9iYXNlL3BsdWdpbnMvZXh0ZW5zaW9ucy9leHQtY29tcG9uZW50LXRyZWVcIixcImNzcy9iYXNlL3BsdWdpbnMvZXh0ZW5zaW9ucy9leHQtY29tcG9uZW50LXRvdXJcIixcImNzcy9iYXNlL3BsdWdpbnMvZXh0ZW5zaW9ucy9leHQtY29tcG9uZW50LXRvYXN0clwiLFwiY3NzL2Jhc2UvcGx1Z2lucy9leHRlbnNpb25zL2V4dC1jb21wb25lbnQtc3dpcGVyXCIsXCJjc3MvYmFzZS9wbHVnaW5zL2V4dGVuc2lvbnMvZXh0LWNvbXBvbmVudC1zd2VldC1hbGVydHNcIixcImNzcy9iYXNlL3BsdWdpbnMvZXh0ZW5zaW9ucy9leHQtY29tcG9uZW50LXNsaWRlcnNcIixcImNzcy9iYXNlL3BsdWdpbnMvZXh0ZW5zaW9ucy9leHQtY29tcG9uZW50LXJhdGluZ3NcIl0sICgpID0+IChfX3dlYnBhY2tfcmVxdWlyZV9fKFwiLi9yZXNvdXJjZXMvc2Nzcy9iYXNlL3BsdWdpbnMvZXh0ZW5zaW9ucy9leHQtY29tcG9uZW50LXRvYXN0ci5zY3NzXCIpKSlcbl9fd2VicGFja19yZXF1aXJlX18uTyh1bmRlZmluZWQsIFtcImNzcy9iYXNlL3BsdWdpbnMvZXh0ZW5zaW9ucy9leHQtY29tcG9uZW50LW1lZGlhLXBsYXllclwiLFwiY3NzL2Jhc2UvcGx1Z2lucy9leHRlbnNpb25zL2V4dC1jb21wb25lbnQtZHJhZy1kcm9wXCIsXCJjc3MvYmFzZS9wbHVnaW5zL2V4dGVuc2lvbnMvZXh0LWNvbXBvbmVudC1jb250ZXh0LW1lbnVcIixcImNzcy9iYXNlL3BsdWdpbnMvY2hhcnRzL2NoYXJ0LWFwZXhcIixcImNzcy9zdHlsZVwiLFwiY3NzL292ZXJyaWRlc1wiLFwiY3NzL2NvcmVcIixcImNzcy9iYXNlL3RoZW1lcy9kYXJrLWxheW91dFwiLFwiY3NzL2Jhc2UvY29yZS9taXhpbnMvdHJhbnNpdGlvbnNcIixcImNzcy9iYXNlL2NvcmUvbWl4aW5zL21haW4tbWVudS1taXhpblwiLFwiY3NzL2Jhc2UvY29yZS9taXhpbnMvaGV4MnJnYlwiLFwiY3NzL2Jhc2UvY29yZS9taXhpbnMvYWxlcnRcIixcImNzcy9iYXNlL2NvcmUvbWVudS9tZW51LXR5cGVzL3ZlcnRpY2FsLW92ZXJsYXktbWVudVwiLFwiY3NzL2Jhc2UvY29yZS9tZW51L21lbnUtdHlwZXMvdmVydGljYWwtbWVudVwiLFwiY3NzL2Jhc2UvY29yZS9tZW51L21lbnUtdHlwZXMvaG9yaXpvbnRhbC1tZW51XCIsXCJjc3MvYmFzZS9jb3JlL2NvbG9ycy9wYWxldHRlLXZhcmlhYmxlc1wiLFwiY3NzL2Jhc2UvY29yZS9jb2xvcnMvcGFsZXR0ZS1ub3VpXCIsXCJjc3MvYmFzZS9jb3JlL2NvbG9ycy9wYWxldHRlLWdyYWRpZW50XCIsXCJjc3MvYmFzZS9wYWdlcy91aS1mZWF0aGVyXCIsXCJjc3MvYmFzZS9wYWdlcy9wYWdlLXByb2ZpbGVcIixcImNzcy9iYXNlL3BhZ2VzL3BhZ2UtcHJpY2luZ1wiLFwiY3NzL2Jhc2UvcGFnZXMvcGFnZS1taXNjXCIsXCJjc3MvYmFzZS9wYWdlcy9wYWdlLWtub3dsZWRnZS1iYXNlXCIsXCJjc3MvYmFzZS9wYWdlcy9wYWdlLWZhcVwiLFwiY3NzL2Jhc2UvcGFnZXMvcGFnZS1jb21pbmctc29vblwiLFwiY3NzL2Jhc2UvcGFnZXMvcGFnZS1ibG9nXCIsXCJjc3MvYmFzZS9wYWdlcy9tb2RhbC1jcmVhdGUtYXBwXCIsXCJjc3MvYmFzZS9wYWdlcy9kYXNoYm9hcmQtZWNvbW1lcmNlXCIsXCJjc3MvYmFzZS9wYWdlcy9hdXRoZW50aWNhdGlvblwiLFwiY3NzL2Jhc2UvcGFnZXMvYXBwLXRvZG9cIixcImNzcy9iYXNlL3BhZ2VzL2FwcC1rYW5iYW5cIixcImNzcy9iYXNlL3BhZ2VzL2FwcC1pbnZvaWNlXCIsXCJjc3MvYmFzZS9wYWdlcy9hcHAtaW52b2ljZS1wcmludFwiLFwiY3NzL2Jhc2UvcGFnZXMvYXBwLWludm9pY2UtbGlzdFwiLFwiY3NzL2Jhc2UvcGFnZXMvYXBwLWZpbGUtbWFuYWdlclwiLFwiY3NzL2Jhc2UvcGFnZXMvYXBwLWVtYWlsXCIsXCJjc3MvYmFzZS9wYWdlcy9hcHAtZWNvbW1lcmNlXCIsXCJjc3MvYmFzZS9wYWdlcy9hcHAtZWNvbW1lcmNlLWRldGFpbHNcIixcImNzcy9iYXNlL3BhZ2VzL2FwcC1jaGF0XCIsXCJjc3MvYmFzZS9wYWdlcy9hcHAtY2hhdC1saXN0XCIsXCJjc3MvYmFzZS9wYWdlcy9hcHAtY2FsZW5kYXJcIixcImNzcy9iYXNlL3BsdWdpbnMvdWkvY29taW5nLXNvb25cIixcImNzcy9iYXNlL3BsdWdpbnMvbWFwcy9tYXAtbGVhZmxldFwiLFwiY3NzL2Jhc2UvcGx1Z2lucy9mb3Jtcy9waWNrZXJzL2Zvcm0tcGlja2FkYXRlXCIsXCJjc3MvYmFzZS9wbHVnaW5zL2Zvcm1zL3BpY2tlcnMvZm9ybS1mbGF0LXBpY2tyXCIsXCJjc3MvYmFzZS9wbHVnaW5zL2Zvcm1zL2Zvcm0td2l6YXJkXCIsXCJjc3MvYmFzZS9wbHVnaW5zL2Zvcm1zL2Zvcm0tdmFsaWRhdGlvblwiLFwiY3NzL2Jhc2UvcGx1Z2lucy9mb3Jtcy9mb3JtLXF1aWxsLWVkaXRvclwiLFwiY3NzL2Jhc2UvcGx1Z2lucy9mb3Jtcy9mb3JtLW51bWJlci1pbnB1dFwiLFwiY3NzL2Jhc2UvcGx1Z2lucy9mb3Jtcy9mb3JtLWZpbGUtdXBsb2FkZXJcIixcImNzcy9iYXNlL3BsdWdpbnMvZXh0ZW5zaW9ucy9leHQtY29tcG9uZW50LXRyZWVcIixcImNzcy9iYXNlL3BsdWdpbnMvZXh0ZW5zaW9ucy9leHQtY29tcG9uZW50LXRvdXJcIixcImNzcy9iYXNlL3BsdWdpbnMvZXh0ZW5zaW9ucy9leHQtY29tcG9uZW50LXRvYXN0clwiLFwiY3NzL2Jhc2UvcGx1Z2lucy9leHRlbnNpb25zL2V4dC1jb21wb25lbnQtc3dpcGVyXCIsXCJjc3MvYmFzZS9wbHVnaW5zL2V4dGVuc2lvbnMvZXh0LWNvbXBvbmVudC1zd2VldC1hbGVydHNcIixcImNzcy9iYXNlL3BsdWdpbnMvZXh0ZW5zaW9ucy9leHQtY29tcG9uZW50LXNsaWRlcnNcIixcImNzcy9iYXNlL3BsdWdpbnMvZXh0ZW5zaW9ucy9leHQtY29tcG9uZW50LXJhdGluZ3NcIl0sICgpID0+IChfX3dlYnBhY2tfcmVxdWlyZV9fKFwiLi9yZXNvdXJjZXMvc2Nzcy9iYXNlL3BsdWdpbnMvZXh0ZW5zaW9ucy9leHQtY29tcG9uZW50LXRvdXIuc2Nzc1wiKSkpXG5fX3dlYnBhY2tfcmVxdWlyZV9fLk8odW5kZWZpbmVkLCBbXCJjc3MvYmFzZS9wbHVnaW5zL2V4dGVuc2lvbnMvZXh0LWNvbXBvbmVudC1tZWRpYS1wbGF5ZXJcIixcImNzcy9iYXNlL3BsdWdpbnMvZXh0ZW5zaW9ucy9leHQtY29tcG9uZW50LWRyYWctZHJvcFwiLFwiY3NzL2Jhc2UvcGx1Z2lucy9leHRlbnNpb25zL2V4dC1jb21wb25lbnQtY29udGV4dC1tZW51XCIsXCJjc3MvYmFzZS9wbHVnaW5zL2NoYXJ0cy9jaGFydC1hcGV4XCIsXCJjc3Mvc3R5bGVcIixcImNzcy9vdmVycmlkZXNcIixcImNzcy9jb3JlXCIsXCJjc3MvYmFzZS90aGVtZXMvZGFyay1sYXlvdXRcIixcImNzcy9iYXNlL2NvcmUvbWl4aW5zL3RyYW5zaXRpb25zXCIsXCJjc3MvYmFzZS9jb3JlL21peGlucy9tYWluLW1lbnUtbWl4aW5cIixcImNzcy9iYXNlL2NvcmUvbWl4aW5zL2hleDJyZ2JcIixcImNzcy9iYXNlL2NvcmUvbWl4aW5zL2FsZXJ0XCIsXCJjc3MvYmFzZS9jb3JlL21lbnUvbWVudS10eXBlcy92ZXJ0aWNhbC1vdmVybGF5LW1lbnVcIixcImNzcy9iYXNlL2NvcmUvbWVudS9tZW51LXR5cGVzL3ZlcnRpY2FsLW1lbnVcIixcImNzcy9iYXNlL2NvcmUvbWVudS9tZW51LXR5cGVzL2hvcml6b250YWwtbWVudVwiLFwiY3NzL2Jhc2UvY29yZS9jb2xvcnMvcGFsZXR0ZS12YXJpYWJsZXNcIixcImNzcy9iYXNlL2NvcmUvY29sb3JzL3BhbGV0dGUtbm91aVwiLFwiY3NzL2Jhc2UvY29yZS9jb2xvcnMvcGFsZXR0ZS1ncmFkaWVudFwiLFwiY3NzL2Jhc2UvcGFnZXMvdWktZmVhdGhlclwiLFwiY3NzL2Jhc2UvcGFnZXMvcGFnZS1wcm9maWxlXCIsXCJjc3MvYmFzZS9wYWdlcy9wYWdlLXByaWNpbmdcIixcImNzcy9iYXNlL3BhZ2VzL3BhZ2UtbWlzY1wiLFwiY3NzL2Jhc2UvcGFnZXMvcGFnZS1rbm93bGVkZ2UtYmFzZVwiLFwiY3NzL2Jhc2UvcGFnZXMvcGFnZS1mYXFcIixcImNzcy9iYXNlL3BhZ2VzL3BhZ2UtY29taW5nLXNvb25cIixcImNzcy9iYXNlL3BhZ2VzL3BhZ2UtYmxvZ1wiLFwiY3NzL2Jhc2UvcGFnZXMvbW9kYWwtY3JlYXRlLWFwcFwiLFwiY3NzL2Jhc2UvcGFnZXMvZGFzaGJvYXJkLWVjb21tZXJjZVwiLFwiY3NzL2Jhc2UvcGFnZXMvYXV0aGVudGljYXRpb25cIixcImNzcy9iYXNlL3BhZ2VzL2FwcC10b2RvXCIsXCJjc3MvYmFzZS9wYWdlcy9hcHAta2FuYmFuXCIsXCJjc3MvYmFzZS9wYWdlcy9hcHAtaW52b2ljZVwiLFwiY3NzL2Jhc2UvcGFnZXMvYXBwLWludm9pY2UtcHJpbnRcIixcImNzcy9iYXNlL3BhZ2VzL2FwcC1pbnZvaWNlLWxpc3RcIixcImNzcy9iYXNlL3BhZ2VzL2FwcC1maWxlLW1hbmFnZXJcIixcImNzcy9iYXNlL3BhZ2VzL2FwcC1lbWFpbFwiLFwiY3NzL2Jhc2UvcGFnZXMvYXBwLWVjb21tZXJjZVwiLFwiY3NzL2Jhc2UvcGFnZXMvYXBwLWVjb21tZXJjZS1kZXRhaWxzXCIsXCJjc3MvYmFzZS9wYWdlcy9hcHAtY2hhdFwiLFwiY3NzL2Jhc2UvcGFnZXMvYXBwLWNoYXQtbGlzdFwiLFwiY3NzL2Jhc2UvcGFnZXMvYXBwLWNhbGVuZGFyXCIsXCJjc3MvYmFzZS9wbHVnaW5zL3VpL2NvbWluZy1zb29uXCIsXCJjc3MvYmFzZS9wbHVnaW5zL21hcHMvbWFwLWxlYWZsZXRcIixcImNzcy9iYXNlL3BsdWdpbnMvZm9ybXMvcGlja2Vycy9mb3JtLXBpY2thZGF0ZVwiLFwiY3NzL2Jhc2UvcGx1Z2lucy9mb3Jtcy9waWNrZXJzL2Zvcm0tZmxhdC1waWNrclwiLFwiY3NzL2Jhc2UvcGx1Z2lucy9mb3Jtcy9mb3JtLXdpemFyZFwiLFwiY3NzL2Jhc2UvcGx1Z2lucy9mb3Jtcy9mb3JtLXZhbGlkYXRpb25cIixcImNzcy9iYXNlL3BsdWdpbnMvZm9ybXMvZm9ybS1xdWlsbC1lZGl0b3JcIixcImNzcy9iYXNlL3BsdWdpbnMvZm9ybXMvZm9ybS1udW1iZXItaW5wdXRcIixcImNzcy9iYXNlL3BsdWdpbnMvZm9ybXMvZm9ybS1maWxlLXVwbG9hZGVyXCIsXCJjc3MvYmFzZS9wbHVnaW5zL2V4dGVuc2lvbnMvZXh0LWNvbXBvbmVudC10cmVlXCIsXCJjc3MvYmFzZS9wbHVnaW5zL2V4dGVuc2lvbnMvZXh0LWNvbXBvbmVudC10b3VyXCIsXCJjc3MvYmFzZS9wbHVnaW5zL2V4dGVuc2lvbnMvZXh0LWNvbXBvbmVudC10b2FzdHJcIixcImNzcy9iYXNlL3BsdWdpbnMvZXh0ZW5zaW9ucy9leHQtY29tcG9uZW50LXN3aXBlclwiLFwiY3NzL2Jhc2UvcGx1Z2lucy9leHRlbnNpb25zL2V4dC1jb21wb25lbnQtc3dlZXQtYWxlcnRzXCIsXCJjc3MvYmFzZS9wbHVnaW5zL2V4dGVuc2lvbnMvZXh0LWNvbXBvbmVudC1zbGlkZXJzXCIsXCJjc3MvYmFzZS9wbHVnaW5zL2V4dGVuc2lvbnMvZXh0LWNvbXBvbmVudC1yYXRpbmdzXCJdLCAoKSA9PiAoX193ZWJwYWNrX3JlcXVpcmVfXyhcIi4vcmVzb3VyY2VzL3Njc3MvYmFzZS9wbHVnaW5zL2V4dGVuc2lvbnMvZXh0LWNvbXBvbmVudC10cmVlLnNjc3NcIikpKVxuX193ZWJwYWNrX3JlcXVpcmVfXy5PKHVuZGVmaW5lZCwgW1wiY3NzL2Jhc2UvcGx1Z2lucy9leHRlbnNpb25zL2V4dC1jb21wb25lbnQtbWVkaWEtcGxheWVyXCIsXCJjc3MvYmFzZS9wbHVnaW5zL2V4dGVuc2lvbnMvZXh0LWNvbXBvbmVudC1kcmFnLWRyb3BcIixcImNzcy9iYXNlL3BsdWdpbnMvZXh0ZW5zaW9ucy9leHQtY29tcG9uZW50LWNvbnRleHQtbWVudVwiLFwiY3NzL2Jhc2UvcGx1Z2lucy9jaGFydHMvY2hhcnQtYXBleFwiLFwiY3NzL3N0eWxlXCIsXCJjc3Mvb3ZlcnJpZGVzXCIsXCJjc3MvY29yZVwiLFwiY3NzL2Jhc2UvdGhlbWVzL2RhcmstbGF5b3V0XCIsXCJjc3MvYmFzZS9jb3JlL21peGlucy90cmFuc2l0aW9uc1wiLFwiY3NzL2Jhc2UvY29yZS9taXhpbnMvbWFpbi1tZW51LW1peGluXCIsXCJjc3MvYmFzZS9jb3JlL21peGlucy9oZXgycmdiXCIsXCJjc3MvYmFzZS9jb3JlL21peGlucy9hbGVydFwiLFwiY3NzL2Jhc2UvY29yZS9tZW51L21lbnUtdHlwZXMvdmVydGljYWwtb3ZlcmxheS1tZW51XCIsXCJjc3MvYmFzZS9jb3JlL21lbnUvbWVudS10eXBlcy92ZXJ0aWNhbC1tZW51XCIsXCJjc3MvYmFzZS9jb3JlL21lbnUvbWVudS10eXBlcy9ob3Jpem9udGFsLW1lbnVcIixcImNzcy9iYXNlL2NvcmUvY29sb3JzL3BhbGV0dGUtdmFyaWFibGVzXCIsXCJjc3MvYmFzZS9jb3JlL2NvbG9ycy9wYWxldHRlLW5vdWlcIixcImNzcy9iYXNlL2NvcmUvY29sb3JzL3BhbGV0dGUtZ3JhZGllbnRcIixcImNzcy9iYXNlL3BhZ2VzL3VpLWZlYXRoZXJcIixcImNzcy9iYXNlL3BhZ2VzL3BhZ2UtcHJvZmlsZVwiLFwiY3NzL2Jhc2UvcGFnZXMvcGFnZS1wcmljaW5nXCIsXCJjc3MvYmFzZS9wYWdlcy9wYWdlLW1pc2NcIixcImNzcy9iYXNlL3BhZ2VzL3BhZ2Uta25vd2xlZGdlLWJhc2VcIixcImNzcy9iYXNlL3BhZ2VzL3BhZ2UtZmFxXCIsXCJjc3MvYmFzZS9wYWdlcy9wYWdlLWNvbWluZy1zb29uXCIsXCJjc3MvYmFzZS9wYWdlcy9wYWdlLWJsb2dcIixcImNzcy9iYXNlL3BhZ2VzL21vZGFsLWNyZWF0ZS1hcHBcIixcImNzcy9iYXNlL3BhZ2VzL2Rhc2hib2FyZC1lY29tbWVyY2VcIixcImNzcy9iYXNlL3BhZ2VzL2F1dGhlbnRpY2F0aW9uXCIsXCJjc3MvYmFzZS9wYWdlcy9hcHAtdG9kb1wiLFwiY3NzL2Jhc2UvcGFnZXMvYXBwLWthbmJhblwiLFwiY3NzL2Jhc2UvcGFnZXMvYXBwLWludm9pY2VcIixcImNzcy9iYXNlL3BhZ2VzL2FwcC1pbnZvaWNlLXByaW50XCIsXCJjc3MvYmFzZS9wYWdlcy9hcHAtaW52b2ljZS1saXN0XCIsXCJjc3MvYmFzZS9wYWdlcy9hcHAtZmlsZS1tYW5hZ2VyXCIsXCJjc3MvYmFzZS9wYWdlcy9hcHAtZW1haWxcIixcImNzcy9iYXNlL3BhZ2VzL2FwcC1lY29tbWVyY2VcIixcImNzcy9iYXNlL3BhZ2VzL2FwcC1lY29tbWVyY2UtZGV0YWlsc1wiLFwiY3NzL2Jhc2UvcGFnZXMvYXBwLWNoYXRcIixcImNzcy9iYXNlL3BhZ2VzL2FwcC1jaGF0LWxpc3RcIixcImNzcy9iYXNlL3BhZ2VzL2FwcC1jYWxlbmRhclwiLFwiY3NzL2Jhc2UvcGx1Z2lucy91aS9jb21pbmctc29vblwiLFwiY3NzL2Jhc2UvcGx1Z2lucy9tYXBzL21hcC1sZWFmbGV0XCIsXCJjc3MvYmFzZS9wbHVnaW5zL2Zvcm1zL3BpY2tlcnMvZm9ybS1waWNrYWRhdGVcIixcImNzcy9iYXNlL3BsdWdpbnMvZm9ybXMvcGlja2Vycy9mb3JtLWZsYXQtcGlja3JcIixcImNzcy9iYXNlL3BsdWdpbnMvZm9ybXMvZm9ybS13aXphcmRcIixcImNzcy9iYXNlL3BsdWdpbnMvZm9ybXMvZm9ybS12YWxpZGF0aW9uXCIsXCJjc3MvYmFzZS9wbHVnaW5zL2Zvcm1zL2Zvcm0tcXVpbGwtZWRpdG9yXCIsXCJjc3MvYmFzZS9wbHVnaW5zL2Zvcm1zL2Zvcm0tbnVtYmVyLWlucHV0XCIsXCJjc3MvYmFzZS9wbHVnaW5zL2Zvcm1zL2Zvcm0tZmlsZS11cGxvYWRlclwiLFwiY3NzL2Jhc2UvcGx1Z2lucy9leHRlbnNpb25zL2V4dC1jb21wb25lbnQtdHJlZVwiLFwiY3NzL2Jhc2UvcGx1Z2lucy9leHRlbnNpb25zL2V4dC1jb21wb25lbnQtdG91clwiLFwiY3NzL2Jhc2UvcGx1Z2lucy9leHRlbnNpb25zL2V4dC1jb21wb25lbnQtdG9hc3RyXCIsXCJjc3MvYmFzZS9wbHVnaW5zL2V4dGVuc2lvbnMvZXh0LWNvbXBvbmVudC1zd2lwZXJcIixcImNzcy9iYXNlL3BsdWdpbnMvZXh0ZW5zaW9ucy9leHQtY29tcG9uZW50LXN3ZWV0LWFsZXJ0c1wiLFwiY3NzL2Jhc2UvcGx1Z2lucy9leHRlbnNpb25zL2V4dC1jb21wb25lbnQtc2xpZGVyc1wiLFwiY3NzL2Jhc2UvcGx1Z2lucy9leHRlbnNpb25zL2V4dC1jb21wb25lbnQtcmF0aW5nc1wiXSwgKCkgPT4gKF9fd2VicGFja19yZXF1aXJlX18oXCIuL3Jlc291cmNlcy9zY3NzL2Jhc2UvcGx1Z2lucy9mb3Jtcy9mb3JtLWZpbGUtdXBsb2FkZXIuc2Nzc1wiKSkpXG5fX3dlYnBhY2tfcmVxdWlyZV9fLk8odW5kZWZpbmVkLCBbXCJjc3MvYmFzZS9wbHVnaW5zL2V4dGVuc2lvbnMvZXh0LWNvbXBvbmVudC1tZWRpYS1wbGF5ZXJcIixcImNzcy9iYXNlL3BsdWdpbnMvZXh0ZW5zaW9ucy9leHQtY29tcG9uZW50LWRyYWctZHJvcFwiLFwiY3NzL2Jhc2UvcGx1Z2lucy9leHRlbnNpb25zL2V4dC1jb21wb25lbnQtY29udGV4dC1tZW51XCIsXCJjc3MvYmFzZS9wbHVnaW5zL2NoYXJ0cy9jaGFydC1hcGV4XCIsXCJjc3Mvc3R5bGVcIixcImNzcy9vdmVycmlkZXNcIixcImNzcy9jb3JlXCIsXCJjc3MvYmFzZS90aGVtZXMvZGFyay1sYXlvdXRcIixcImNzcy9iYXNlL2NvcmUvbWl4aW5zL3RyYW5zaXRpb25zXCIsXCJjc3MvYmFzZS9jb3JlL21peGlucy9tYWluLW1lbnUtbWl4aW5cIixcImNzcy9iYXNlL2NvcmUvbWl4aW5zL2hleDJyZ2JcIixcImNzcy9iYXNlL2NvcmUvbWl4aW5zL2FsZXJ0XCIsXCJjc3MvYmFzZS9jb3JlL21lbnUvbWVudS10eXBlcy92ZXJ0aWNhbC1vdmVybGF5LW1lbnVcIixcImNzcy9iYXNlL2NvcmUvbWVudS9tZW51LXR5cGVzL3ZlcnRpY2FsLW1lbnVcIixcImNzcy9iYXNlL2NvcmUvbWVudS9tZW51LXR5cGVzL2hvcml6b250YWwtbWVudVwiLFwiY3NzL2Jhc2UvY29yZS9jb2xvcnMvcGFsZXR0ZS12YXJpYWJsZXNcIixcImNzcy9iYXNlL2NvcmUvY29sb3JzL3BhbGV0dGUtbm91aVwiLFwiY3NzL2Jhc2UvY29yZS9jb2xvcnMvcGFsZXR0ZS1ncmFkaWVudFwiLFwiY3NzL2Jhc2UvcGFnZXMvdWktZmVhdGhlclwiLFwiY3NzL2Jhc2UvcGFnZXMvcGFnZS1wcm9maWxlXCIsXCJjc3MvYmFzZS9wYWdlcy9wYWdlLXByaWNpbmdcIixcImNzcy9iYXNlL3BhZ2VzL3BhZ2UtbWlzY1wiLFwiY3NzL2Jhc2UvcGFnZXMvcGFnZS1rbm93bGVkZ2UtYmFzZVwiLFwiY3NzL2Jhc2UvcGFnZXMvcGFnZS1mYXFcIixcImNzcy9iYXNlL3BhZ2VzL3BhZ2UtY29taW5nLXNvb25cIixcImNzcy9iYXNlL3BhZ2VzL3BhZ2UtYmxvZ1wiLFwiY3NzL2Jhc2UvcGFnZXMvbW9kYWwtY3JlYXRlLWFwcFwiLFwiY3NzL2Jhc2UvcGFnZXMvZGFzaGJvYXJkLWVjb21tZXJjZVwiLFwiY3NzL2Jhc2UvcGFnZXMvYXV0aGVudGljYXRpb25cIixcImNzcy9iYXNlL3BhZ2VzL2FwcC10b2RvXCIsXCJjc3MvYmFzZS9wYWdlcy9hcHAta2FuYmFuXCIsXCJjc3MvYmFzZS9wYWdlcy9hcHAtaW52b2ljZVwiLFwiY3NzL2Jhc2UvcGFnZXMvYXBwLWludm9pY2UtcHJpbnRcIixcImNzcy9iYXNlL3BhZ2VzL2FwcC1pbnZvaWNlLWxpc3RcIixcImNzcy9iYXNlL3BhZ2VzL2FwcC1maWxlLW1hbmFnZXJcIixcImNzcy9iYXNlL3BhZ2VzL2FwcC1lbWFpbFwiLFwiY3NzL2Jhc2UvcGFnZXMvYXBwLWVjb21tZXJjZVwiLFwiY3NzL2Jhc2UvcGFnZXMvYXBwLWVjb21tZXJjZS1kZXRhaWxzXCIsXCJjc3MvYmFzZS9wYWdlcy9hcHAtY2hhdFwiLFwiY3NzL2Jhc2UvcGFnZXMvYXBwLWNoYXQtbGlzdFwiLFwiY3NzL2Jhc2UvcGFnZXMvYXBwLWNhbGVuZGFyXCIsXCJjc3MvYmFzZS9wbHVnaW5zL3VpL2NvbWluZy1zb29uXCIsXCJjc3MvYmFzZS9wbHVnaW5zL21hcHMvbWFwLWxlYWZsZXRcIixcImNzcy9iYXNlL3BsdWdpbnMvZm9ybXMvcGlja2Vycy9mb3JtLXBpY2thZGF0ZVwiLFwiY3NzL2Jhc2UvcGx1Z2lucy9mb3Jtcy9waWNrZXJzL2Zvcm0tZmxhdC1waWNrclwiLFwiY3NzL2Jhc2UvcGx1Z2lucy9mb3Jtcy9mb3JtLXdpemFyZFwiLFwiY3NzL2Jhc2UvcGx1Z2lucy9mb3Jtcy9mb3JtLXZhbGlkYXRpb25cIixcImNzcy9iYXNlL3BsdWdpbnMvZm9ybXMvZm9ybS1xdWlsbC1lZGl0b3JcIixcImNzcy9iYXNlL3BsdWdpbnMvZm9ybXMvZm9ybS1udW1iZXItaW5wdXRcIixcImNzcy9iYXNlL3BsdWdpbnMvZm9ybXMvZm9ybS1maWxlLXVwbG9hZGVyXCIsXCJjc3MvYmFzZS9wbHVnaW5zL2V4dGVuc2lvbnMvZXh0LWNvbXBvbmVudC10cmVlXCIsXCJjc3MvYmFzZS9wbHVnaW5zL2V4dGVuc2lvbnMvZXh0LWNvbXBvbmVudC10b3VyXCIsXCJjc3MvYmFzZS9wbHVnaW5zL2V4dGVuc2lvbnMvZXh0LWNvbXBvbmVudC10b2FzdHJcIixcImNzcy9iYXNlL3BsdWdpbnMvZXh0ZW5zaW9ucy9leHQtY29tcG9uZW50LXN3aXBlclwiLFwiY3NzL2Jhc2UvcGx1Z2lucy9leHRlbnNpb25zL2V4dC1jb21wb25lbnQtc3dlZXQtYWxlcnRzXCIsXCJjc3MvYmFzZS9wbHVnaW5zL2V4dGVuc2lvbnMvZXh0LWNvbXBvbmVudC1zbGlkZXJzXCIsXCJjc3MvYmFzZS9wbHVnaW5zL2V4dGVuc2lvbnMvZXh0LWNvbXBvbmVudC1yYXRpbmdzXCJdLCAoKSA9PiAoX193ZWJwYWNrX3JlcXVpcmVfXyhcIi4vcmVzb3VyY2VzL3Njc3MvYmFzZS9wbHVnaW5zL2Zvcm1zL2Zvcm0tbnVtYmVyLWlucHV0LnNjc3NcIikpKVxuX193ZWJwYWNrX3JlcXVpcmVfXy5PKHVuZGVmaW5lZCwgW1wiY3NzL2Jhc2UvcGx1Z2lucy9leHRlbnNpb25zL2V4dC1jb21wb25lbnQtbWVkaWEtcGxheWVyXCIsXCJjc3MvYmFzZS9wbHVnaW5zL2V4dGVuc2lvbnMvZXh0LWNvbXBvbmVudC1kcmFnLWRyb3BcIixcImNzcy9iYXNlL3BsdWdpbnMvZXh0ZW5zaW9ucy9leHQtY29tcG9uZW50LWNvbnRleHQtbWVudVwiLFwiY3NzL2Jhc2UvcGx1Z2lucy9jaGFydHMvY2hhcnQtYXBleFwiLFwiY3NzL3N0eWxlXCIsXCJjc3Mvb3ZlcnJpZGVzXCIsXCJjc3MvY29yZVwiLFwiY3NzL2Jhc2UvdGhlbWVzL2RhcmstbGF5b3V0XCIsXCJjc3MvYmFzZS9jb3JlL21peGlucy90cmFuc2l0aW9uc1wiLFwiY3NzL2Jhc2UvY29yZS9taXhpbnMvbWFpbi1tZW51LW1peGluXCIsXCJjc3MvYmFzZS9jb3JlL21peGlucy9oZXgycmdiXCIsXCJjc3MvYmFzZS9jb3JlL21peGlucy9hbGVydFwiLFwiY3NzL2Jhc2UvY29yZS9tZW51L21lbnUtdHlwZXMvdmVydGljYWwtb3ZlcmxheS1tZW51XCIsXCJjc3MvYmFzZS9jb3JlL21lbnUvbWVudS10eXBlcy92ZXJ0aWNhbC1tZW51XCIsXCJjc3MvYmFzZS9jb3JlL21lbnUvbWVudS10eXBlcy9ob3Jpem9udGFsLW1lbnVcIixcImNzcy9iYXNlL2NvcmUvY29sb3JzL3BhbGV0dGUtdmFyaWFibGVzXCIsXCJjc3MvYmFzZS9jb3JlL2NvbG9ycy9wYWxldHRlLW5vdWlcIixcImNzcy9iYXNlL2NvcmUvY29sb3JzL3BhbGV0dGUtZ3JhZGllbnRcIixcImNzcy9iYXNlL3BhZ2VzL3VpLWZlYXRoZXJcIixcImNzcy9iYXNlL3BhZ2VzL3BhZ2UtcHJvZmlsZVwiLFwiY3NzL2Jhc2UvcGFnZXMvcGFnZS1wcmljaW5nXCIsXCJjc3MvYmFzZS9wYWdlcy9wYWdlLW1pc2NcIixcImNzcy9iYXNlL3BhZ2VzL3BhZ2Uta25vd2xlZGdlLWJhc2VcIixcImNzcy9iYXNlL3BhZ2VzL3BhZ2UtZmFxXCIsXCJjc3MvYmFzZS9wYWdlcy9wYWdlLWNvbWluZy1zb29uXCIsXCJjc3MvYmFzZS9wYWdlcy9wYWdlLWJsb2dcIixcImNzcy9iYXNlL3BhZ2VzL21vZGFsLWNyZWF0ZS1hcHBcIixcImNzcy9iYXNlL3BhZ2VzL2Rhc2hib2FyZC1lY29tbWVyY2VcIixcImNzcy9iYXNlL3BhZ2VzL2F1dGhlbnRpY2F0aW9uXCIsXCJjc3MvYmFzZS9wYWdlcy9hcHAtdG9kb1wiLFwiY3NzL2Jhc2UvcGFnZXMvYXBwLWthbmJhblwiLFwiY3NzL2Jhc2UvcGFnZXMvYXBwLWludm9pY2VcIixcImNzcy9iYXNlL3BhZ2VzL2FwcC1pbnZvaWNlLXByaW50XCIsXCJjc3MvYmFzZS9wYWdlcy9hcHAtaW52b2ljZS1saXN0XCIsXCJjc3MvYmFzZS9wYWdlcy9hcHAtZmlsZS1tYW5hZ2VyXCIsXCJjc3MvYmFzZS9wYWdlcy9hcHAtZW1haWxcIixcImNzcy9iYXNlL3BhZ2VzL2FwcC1lY29tbWVyY2VcIixcImNzcy9iYXNlL3BhZ2VzL2FwcC1lY29tbWVyY2UtZGV0YWlsc1wiLFwiY3NzL2Jhc2UvcGFnZXMvYXBwLWNoYXRcIixcImNzcy9iYXNlL3BhZ2VzL2FwcC1jaGF0LWxpc3RcIixcImNzcy9iYXNlL3BhZ2VzL2FwcC1jYWxlbmRhclwiLFwiY3NzL2Jhc2UvcGx1Z2lucy91aS9jb21pbmctc29vblwiLFwiY3NzL2Jhc2UvcGx1Z2lucy9tYXBzL21hcC1sZWFmbGV0XCIsXCJjc3MvYmFzZS9wbHVnaW5zL2Zvcm1zL3BpY2tlcnMvZm9ybS1waWNrYWRhdGVcIixcImNzcy9iYXNlL3BsdWdpbnMvZm9ybXMvcGlja2Vycy9mb3JtLWZsYXQtcGlja3JcIixcImNzcy9iYXNlL3BsdWdpbnMvZm9ybXMvZm9ybS13aXphcmRcIixcImNzcy9iYXNlL3BsdWdpbnMvZm9ybXMvZm9ybS12YWxpZGF0aW9uXCIsXCJjc3MvYmFzZS9wbHVnaW5zL2Zvcm1zL2Zvcm0tcXVpbGwtZWRpdG9yXCIsXCJjc3MvYmFzZS9wbHVnaW5zL2Zvcm1zL2Zvcm0tbnVtYmVyLWlucHV0XCIsXCJjc3MvYmFzZS9wbHVnaW5zL2Zvcm1zL2Zvcm0tZmlsZS11cGxvYWRlclwiLFwiY3NzL2Jhc2UvcGx1Z2lucy9leHRlbnNpb25zL2V4dC1jb21wb25lbnQtdHJlZVwiLFwiY3NzL2Jhc2UvcGx1Z2lucy9leHRlbnNpb25zL2V4dC1jb21wb25lbnQtdG91clwiLFwiY3NzL2Jhc2UvcGx1Z2lucy9leHRlbnNpb25zL2V4dC1jb21wb25lbnQtdG9hc3RyXCIsXCJjc3MvYmFzZS9wbHVnaW5zL2V4dGVuc2lvbnMvZXh0LWNvbXBvbmVudC1zd2lwZXJcIixcImNzcy9iYXNlL3BsdWdpbnMvZXh0ZW5zaW9ucy9leHQtY29tcG9uZW50LXN3ZWV0LWFsZXJ0c1wiLFwiY3NzL2Jhc2UvcGx1Z2lucy9leHRlbnNpb25zL2V4dC1jb21wb25lbnQtc2xpZGVyc1wiLFwiY3NzL2Jhc2UvcGx1Z2lucy9leHRlbnNpb25zL2V4dC1jb21wb25lbnQtcmF0aW5nc1wiXSwgKCkgPT4gKF9fd2VicGFja19yZXF1aXJlX18oXCIuL3Jlc291cmNlcy9zY3NzL2Jhc2UvcGx1Z2lucy9mb3Jtcy9mb3JtLXF1aWxsLWVkaXRvci5zY3NzXCIpKSlcbl9fd2VicGFja19yZXF1aXJlX18uTyh1bmRlZmluZWQsIFtcImNzcy9iYXNlL3BsdWdpbnMvZXh0ZW5zaW9ucy9leHQtY29tcG9uZW50LW1lZGlhLXBsYXllclwiLFwiY3NzL2Jhc2UvcGx1Z2lucy9leHRlbnNpb25zL2V4dC1jb21wb25lbnQtZHJhZy1kcm9wXCIsXCJjc3MvYmFzZS9wbHVnaW5zL2V4dGVuc2lvbnMvZXh0LWNvbXBvbmVudC1jb250ZXh0LW1lbnVcIixcImNzcy9iYXNlL3BsdWdpbnMvY2hhcnRzL2NoYXJ0LWFwZXhcIixcImNzcy9zdHlsZVwiLFwiY3NzL292ZXJyaWRlc1wiLFwiY3NzL2NvcmVcIixcImNzcy9iYXNlL3RoZW1lcy9kYXJrLWxheW91dFwiLFwiY3NzL2Jhc2UvY29yZS9taXhpbnMvdHJhbnNpdGlvbnNcIixcImNzcy9iYXNlL2NvcmUvbWl4aW5zL21haW4tbWVudS1taXhpblwiLFwiY3NzL2Jhc2UvY29yZS9taXhpbnMvaGV4MnJnYlwiLFwiY3NzL2Jhc2UvY29yZS9taXhpbnMvYWxlcnRcIixcImNzcy9iYXNlL2NvcmUvbWVudS9tZW51LXR5cGVzL3ZlcnRpY2FsLW92ZXJsYXktbWVudVwiLFwiY3NzL2Jhc2UvY29yZS9tZW51L21lbnUtdHlwZXMvdmVydGljYWwtbWVudVwiLFwiY3NzL2Jhc2UvY29yZS9tZW51L21lbnUtdHlwZXMvaG9yaXpvbnRhbC1tZW51XCIsXCJjc3MvYmFzZS9jb3JlL2NvbG9ycy9wYWxldHRlLXZhcmlhYmxlc1wiLFwiY3NzL2Jhc2UvY29yZS9jb2xvcnMvcGFsZXR0ZS1ub3VpXCIsXCJjc3MvYmFzZS9jb3JlL2NvbG9ycy9wYWxldHRlLWdyYWRpZW50XCIsXCJjc3MvYmFzZS9wYWdlcy91aS1mZWF0aGVyXCIsXCJjc3MvYmFzZS9wYWdlcy9wYWdlLXByb2ZpbGVcIixcImNzcy9iYXNlL3BhZ2VzL3BhZ2UtcHJpY2luZ1wiLFwiY3NzL2Jhc2UvcGFnZXMvcGFnZS1taXNjXCIsXCJjc3MvYmFzZS9wYWdlcy9wYWdlLWtub3dsZWRnZS1iYXNlXCIsXCJjc3MvYmFzZS9wYWdlcy9wYWdlLWZhcVwiLFwiY3NzL2Jhc2UvcGFnZXMvcGFnZS1jb21pbmctc29vblwiLFwiY3NzL2Jhc2UvcGFnZXMvcGFnZS1ibG9nXCIsXCJjc3MvYmFzZS9wYWdlcy9tb2RhbC1jcmVhdGUtYXBwXCIsXCJjc3MvYmFzZS9wYWdlcy9kYXNoYm9hcmQtZWNvbW1lcmNlXCIsXCJjc3MvYmFzZS9wYWdlcy9hdXRoZW50aWNhdGlvblwiLFwiY3NzL2Jhc2UvcGFnZXMvYXBwLXRvZG9cIixcImNzcy9iYXNlL3BhZ2VzL2FwcC1rYW5iYW5cIixcImNzcy9iYXNlL3BhZ2VzL2FwcC1pbnZvaWNlXCIsXCJjc3MvYmFzZS9wYWdlcy9hcHAtaW52b2ljZS1wcmludFwiLFwiY3NzL2Jhc2UvcGFnZXMvYXBwLWludm9pY2UtbGlzdFwiLFwiY3NzL2Jhc2UvcGFnZXMvYXBwLWZpbGUtbWFuYWdlclwiLFwiY3NzL2Jhc2UvcGFnZXMvYXBwLWVtYWlsXCIsXCJjc3MvYmFzZS9wYWdlcy9hcHAtZWNvbW1lcmNlXCIsXCJjc3MvYmFzZS9wYWdlcy9hcHAtZWNvbW1lcmNlLWRldGFpbHNcIixcImNzcy9iYXNlL3BhZ2VzL2FwcC1jaGF0XCIsXCJjc3MvYmFzZS9wYWdlcy9hcHAtY2hhdC1saXN0XCIsXCJjc3MvYmFzZS9wYWdlcy9hcHAtY2FsZW5kYXJcIixcImNzcy9iYXNlL3BsdWdpbnMvdWkvY29taW5nLXNvb25cIixcImNzcy9iYXNlL3BsdWdpbnMvbWFwcy9tYXAtbGVhZmxldFwiLFwiY3NzL2Jhc2UvcGx1Z2lucy9mb3Jtcy9waWNrZXJzL2Zvcm0tcGlja2FkYXRlXCIsXCJjc3MvYmFzZS9wbHVnaW5zL2Zvcm1zL3BpY2tlcnMvZm9ybS1mbGF0LXBpY2tyXCIsXCJjc3MvYmFzZS9wbHVnaW5zL2Zvcm1zL2Zvcm0td2l6YXJkXCIsXCJjc3MvYmFzZS9wbHVnaW5zL2Zvcm1zL2Zvcm0tdmFsaWRhdGlvblwiLFwiY3NzL2Jhc2UvcGx1Z2lucy9mb3Jtcy9mb3JtLXF1aWxsLWVkaXRvclwiLFwiY3NzL2Jhc2UvcGx1Z2lucy9mb3Jtcy9mb3JtLW51bWJlci1pbnB1dFwiLFwiY3NzL2Jhc2UvcGx1Z2lucy9mb3Jtcy9mb3JtLWZpbGUtdXBsb2FkZXJcIixcImNzcy9iYXNlL3BsdWdpbnMvZXh0ZW5zaW9ucy9leHQtY29tcG9uZW50LXRyZWVcIixcImNzcy9iYXNlL3BsdWdpbnMvZXh0ZW5zaW9ucy9leHQtY29tcG9uZW50LXRvdXJcIixcImNzcy9iYXNlL3BsdWdpbnMvZXh0ZW5zaW9ucy9leHQtY29tcG9uZW50LXRvYXN0clwiLFwiY3NzL2Jhc2UvcGx1Z2lucy9leHRlbnNpb25zL2V4dC1jb21wb25lbnQtc3dpcGVyXCIsXCJjc3MvYmFzZS9wbHVnaW5zL2V4dGVuc2lvbnMvZXh0LWNvbXBvbmVudC1zd2VldC1hbGVydHNcIixcImNzcy9iYXNlL3BsdWdpbnMvZXh0ZW5zaW9ucy9leHQtY29tcG9uZW50LXNsaWRlcnNcIixcImNzcy9iYXNlL3BsdWdpbnMvZXh0ZW5zaW9ucy9leHQtY29tcG9uZW50LXJhdGluZ3NcIl0sICgpID0+IChfX3dlYnBhY2tfcmVxdWlyZV9fKFwiLi9yZXNvdXJjZXMvc2Nzcy9iYXNlL3BsdWdpbnMvZm9ybXMvZm9ybS12YWxpZGF0aW9uLnNjc3NcIikpKVxuX193ZWJwYWNrX3JlcXVpcmVfXy5PKHVuZGVmaW5lZCwgW1wiY3NzL2Jhc2UvcGx1Z2lucy9leHRlbnNpb25zL2V4dC1jb21wb25lbnQtbWVkaWEtcGxheWVyXCIsXCJjc3MvYmFzZS9wbHVnaW5zL2V4dGVuc2lvbnMvZXh0LWNvbXBvbmVudC1kcmFnLWRyb3BcIixcImNzcy9iYXNlL3BsdWdpbnMvZXh0ZW5zaW9ucy9leHQtY29tcG9uZW50LWNvbnRleHQtbWVudVwiLFwiY3NzL2Jhc2UvcGx1Z2lucy9jaGFydHMvY2hhcnQtYXBleFwiLFwiY3NzL3N0eWxlXCIsXCJjc3Mvb3ZlcnJpZGVzXCIsXCJjc3MvY29yZVwiLFwiY3NzL2Jhc2UvdGhlbWVzL2RhcmstbGF5b3V0XCIsXCJjc3MvYmFzZS9jb3JlL21peGlucy90cmFuc2l0aW9uc1wiLFwiY3NzL2Jhc2UvY29yZS9taXhpbnMvbWFpbi1tZW51LW1peGluXCIsXCJjc3MvYmFzZS9jb3JlL21peGlucy9oZXgycmdiXCIsXCJjc3MvYmFzZS9jb3JlL21peGlucy9hbGVydFwiLFwiY3NzL2Jhc2UvY29yZS9tZW51L21lbnUtdHlwZXMvdmVydGljYWwtb3ZlcmxheS1tZW51XCIsXCJjc3MvYmFzZS9jb3JlL21lbnUvbWVudS10eXBlcy92ZXJ0aWNhbC1tZW51XCIsXCJjc3MvYmFzZS9jb3JlL21lbnUvbWVudS10eXBlcy9ob3Jpem9udGFsLW1lbnVcIixcImNzcy9iYXNlL2NvcmUvY29sb3JzL3BhbGV0dGUtdmFyaWFibGVzXCIsXCJjc3MvYmFzZS9jb3JlL2NvbG9ycy9wYWxldHRlLW5vdWlcIixcImNzcy9iYXNlL2NvcmUvY29sb3JzL3BhbGV0dGUtZ3JhZGllbnRcIixcImNzcy9iYXNlL3BhZ2VzL3VpLWZlYXRoZXJcIixcImNzcy9iYXNlL3BhZ2VzL3BhZ2UtcHJvZmlsZVwiLFwiY3NzL2Jhc2UvcGFnZXMvcGFnZS1wcmljaW5nXCIsXCJjc3MvYmFzZS9wYWdlcy9wYWdlLW1pc2NcIixcImNzcy9iYXNlL3BhZ2VzL3BhZ2Uta25vd2xlZGdlLWJhc2VcIixcImNzcy9iYXNlL3BhZ2VzL3BhZ2UtZmFxXCIsXCJjc3MvYmFzZS9wYWdlcy9wYWdlLWNvbWluZy1zb29uXCIsXCJjc3MvYmFzZS9wYWdlcy9wYWdlLWJsb2dcIixcImNzcy9iYXNlL3BhZ2VzL21vZGFsLWNyZWF0ZS1hcHBcIixcImNzcy9iYXNlL3BhZ2VzL2Rhc2hib2FyZC1lY29tbWVyY2VcIixcImNzcy9iYXNlL3BhZ2VzL2F1dGhlbnRpY2F0aW9uXCIsXCJjc3MvYmFzZS9wYWdlcy9hcHAtdG9kb1wiLFwiY3NzL2Jhc2UvcGFnZXMvYXBwLWthbmJhblwiLFwiY3NzL2Jhc2UvcGFnZXMvYXBwLWludm9pY2VcIixcImNzcy9iYXNlL3BhZ2VzL2FwcC1pbnZvaWNlLXByaW50XCIsXCJjc3MvYmFzZS9wYWdlcy9hcHAtaW52b2ljZS1saXN0XCIsXCJjc3MvYmFzZS9wYWdlcy9hcHAtZmlsZS1tYW5hZ2VyXCIsXCJjc3MvYmFzZS9wYWdlcy9hcHAtZW1haWxcIixcImNzcy9iYXNlL3BhZ2VzL2FwcC1lY29tbWVyY2VcIixcImNzcy9iYXNlL3BhZ2VzL2FwcC1lY29tbWVyY2UtZGV0YWlsc1wiLFwiY3NzL2Jhc2UvcGFnZXMvYXBwLWNoYXRcIixcImNzcy9iYXNlL3BhZ2VzL2FwcC1jaGF0LWxpc3RcIixcImNzcy9iYXNlL3BhZ2VzL2FwcC1jYWxlbmRhclwiLFwiY3NzL2Jhc2UvcGx1Z2lucy91aS9jb21pbmctc29vblwiLFwiY3NzL2Jhc2UvcGx1Z2lucy9tYXBzL21hcC1sZWFmbGV0XCIsXCJjc3MvYmFzZS9wbHVnaW5zL2Zvcm1zL3BpY2tlcnMvZm9ybS1waWNrYWRhdGVcIixcImNzcy9iYXNlL3BsdWdpbnMvZm9ybXMvcGlja2Vycy9mb3JtLWZsYXQtcGlja3JcIixcImNzcy9iYXNlL3BsdWdpbnMvZm9ybXMvZm9ybS13aXphcmRcIixcImNzcy9iYXNlL3BsdWdpbnMvZm9ybXMvZm9ybS12YWxpZGF0aW9uXCIsXCJjc3MvYmFzZS9wbHVnaW5zL2Zvcm1zL2Zvcm0tcXVpbGwtZWRpdG9yXCIsXCJjc3MvYmFzZS9wbHVnaW5zL2Zvcm1zL2Zvcm0tbnVtYmVyLWlucHV0XCIsXCJjc3MvYmFzZS9wbHVnaW5zL2Zvcm1zL2Zvcm0tZmlsZS11cGxvYWRlclwiLFwiY3NzL2Jhc2UvcGx1Z2lucy9leHRlbnNpb25zL2V4dC1jb21wb25lbnQtdHJlZVwiLFwiY3NzL2Jhc2UvcGx1Z2lucy9leHRlbnNpb25zL2V4dC1jb21wb25lbnQtdG91clwiLFwiY3NzL2Jhc2UvcGx1Z2lucy9leHRlbnNpb25zL2V4dC1jb21wb25lbnQtdG9hc3RyXCIsXCJjc3MvYmFzZS9wbHVnaW5zL2V4dGVuc2lvbnMvZXh0LWNvbXBvbmVudC1zd2lwZXJcIixcImNzcy9iYXNlL3BsdWdpbnMvZXh0ZW5zaW9ucy9leHQtY29tcG9uZW50LXN3ZWV0LWFsZXJ0c1wiLFwiY3NzL2Jhc2UvcGx1Z2lucy9leHRlbnNpb25zL2V4dC1jb21wb25lbnQtc2xpZGVyc1wiLFwiY3NzL2Jhc2UvcGx1Z2lucy9leHRlbnNpb25zL2V4dC1jb21wb25lbnQtcmF0aW5nc1wiXSwgKCkgPT4gKF9fd2VicGFja19yZXF1aXJlX18oXCIuL3Jlc291cmNlcy9zY3NzL2Jhc2UvcGx1Z2lucy9mb3Jtcy9mb3JtLXdpemFyZC5zY3NzXCIpKSlcbl9fd2VicGFja19yZXF1aXJlX18uTyh1bmRlZmluZWQsIFtcImNzcy9iYXNlL3BsdWdpbnMvZXh0ZW5zaW9ucy9leHQtY29tcG9uZW50LW1lZGlhLXBsYXllclwiLFwiY3NzL2Jhc2UvcGx1Z2lucy9leHRlbnNpb25zL2V4dC1jb21wb25lbnQtZHJhZy1kcm9wXCIsXCJjc3MvYmFzZS9wbHVnaW5zL2V4dGVuc2lvbnMvZXh0LWNvbXBvbmVudC1jb250ZXh0LW1lbnVcIixcImNzcy9iYXNlL3BsdWdpbnMvY2hhcnRzL2NoYXJ0LWFwZXhcIixcImNzcy9zdHlsZVwiLFwiY3NzL292ZXJyaWRlc1wiLFwiY3NzL2NvcmVcIixcImNzcy9iYXNlL3RoZW1lcy9kYXJrLWxheW91dFwiLFwiY3NzL2Jhc2UvY29yZS9taXhpbnMvdHJhbnNpdGlvbnNcIixcImNzcy9iYXNlL2NvcmUvbWl4aW5zL21haW4tbWVudS1taXhpblwiLFwiY3NzL2Jhc2UvY29yZS9taXhpbnMvaGV4MnJnYlwiLFwiY3NzL2Jhc2UvY29yZS9taXhpbnMvYWxlcnRcIixcImNzcy9iYXNlL2NvcmUvbWVudS9tZW51LXR5cGVzL3ZlcnRpY2FsLW92ZXJsYXktbWVudVwiLFwiY3NzL2Jhc2UvY29yZS9tZW51L21lbnUtdHlwZXMvdmVydGljYWwtbWVudVwiLFwiY3NzL2Jhc2UvY29yZS9tZW51L21lbnUtdHlwZXMvaG9yaXpvbnRhbC1tZW51XCIsXCJjc3MvYmFzZS9jb3JlL2NvbG9ycy9wYWxldHRlLXZhcmlhYmxlc1wiLFwiY3NzL2Jhc2UvY29yZS9jb2xvcnMvcGFsZXR0ZS1ub3VpXCIsXCJjc3MvYmFzZS9jb3JlL2NvbG9ycy9wYWxldHRlLWdyYWRpZW50XCIsXCJjc3MvYmFzZS9wYWdlcy91aS1mZWF0aGVyXCIsXCJjc3MvYmFzZS9wYWdlcy9wYWdlLXByb2ZpbGVcIixcImNzcy9iYXNlL3BhZ2VzL3BhZ2UtcHJpY2luZ1wiLFwiY3NzL2Jhc2UvcGFnZXMvcGFnZS1taXNjXCIsXCJjc3MvYmFzZS9wYWdlcy9wYWdlLWtub3dsZWRnZS1iYXNlXCIsXCJjc3MvYmFzZS9wYWdlcy9wYWdlLWZhcVwiLFwiY3NzL2Jhc2UvcGFnZXMvcGFnZS1jb21pbmctc29vblwiLFwiY3NzL2Jhc2UvcGFnZXMvcGFnZS1ibG9nXCIsXCJjc3MvYmFzZS9wYWdlcy9tb2RhbC1jcmVhdGUtYXBwXCIsXCJjc3MvYmFzZS9wYWdlcy9kYXNoYm9hcmQtZWNvbW1lcmNlXCIsXCJjc3MvYmFzZS9wYWdlcy9hdXRoZW50aWNhdGlvblwiLFwiY3NzL2Jhc2UvcGFnZXMvYXBwLXRvZG9cIixcImNzcy9iYXNlL3BhZ2VzL2FwcC1rYW5iYW5cIixcImNzcy9iYXNlL3BhZ2VzL2FwcC1pbnZvaWNlXCIsXCJjc3MvYmFzZS9wYWdlcy9hcHAtaW52b2ljZS1wcmludFwiLFwiY3NzL2Jhc2UvcGFnZXMvYXBwLWludm9pY2UtbGlzdFwiLFwiY3NzL2Jhc2UvcGFnZXMvYXBwLWZpbGUtbWFuYWdlclwiLFwiY3NzL2Jhc2UvcGFnZXMvYXBwLWVtYWlsXCIsXCJjc3MvYmFzZS9wYWdlcy9hcHAtZWNvbW1lcmNlXCIsXCJjc3MvYmFzZS9wYWdlcy9hcHAtZWNvbW1lcmNlLWRldGFpbHNcIixcImNzcy9iYXNlL3BhZ2VzL2FwcC1jaGF0XCIsXCJjc3MvYmFzZS9wYWdlcy9hcHAtY2hhdC1saXN0XCIsXCJjc3MvYmFzZS9wYWdlcy9hcHAtY2FsZW5kYXJcIixcImNzcy9iYXNlL3BsdWdpbnMvdWkvY29taW5nLXNvb25cIixcImNzcy9iYXNlL3BsdWdpbnMvbWFwcy9tYXAtbGVhZmxldFwiLFwiY3NzL2Jhc2UvcGx1Z2lucy9mb3Jtcy9waWNrZXJzL2Zvcm0tcGlja2FkYXRlXCIsXCJjc3MvYmFzZS9wbHVnaW5zL2Zvcm1zL3BpY2tlcnMvZm9ybS1mbGF0LXBpY2tyXCIsXCJjc3MvYmFzZS9wbHVnaW5zL2Zvcm1zL2Zvcm0td2l6YXJkXCIsXCJjc3MvYmFzZS9wbHVnaW5zL2Zvcm1zL2Zvcm0tdmFsaWRhdGlvblwiLFwiY3NzL2Jhc2UvcGx1Z2lucy9mb3Jtcy9mb3JtLXF1aWxsLWVkaXRvclwiLFwiY3NzL2Jhc2UvcGx1Z2lucy9mb3Jtcy9mb3JtLW51bWJlci1pbnB1dFwiLFwiY3NzL2Jhc2UvcGx1Z2lucy9mb3Jtcy9mb3JtLWZpbGUtdXBsb2FkZXJcIixcImNzcy9iYXNlL3BsdWdpbnMvZXh0ZW5zaW9ucy9leHQtY29tcG9uZW50LXRyZWVcIixcImNzcy9iYXNlL3BsdWdpbnMvZXh0ZW5zaW9ucy9leHQtY29tcG9uZW50LXRvdXJcIixcImNzcy9iYXNlL3BsdWdpbnMvZXh0ZW5zaW9ucy9leHQtY29tcG9uZW50LXRvYXN0clwiLFwiY3NzL2Jhc2UvcGx1Z2lucy9leHRlbnNpb25zL2V4dC1jb21wb25lbnQtc3dpcGVyXCIsXCJjc3MvYmFzZS9wbHVnaW5zL2V4dGVuc2lvbnMvZXh0LWNvbXBvbmVudC1zd2VldC1hbGVydHNcIixcImNzcy9iYXNlL3BsdWdpbnMvZXh0ZW5zaW9ucy9leHQtY29tcG9uZW50LXNsaWRlcnNcIixcImNzcy9iYXNlL3BsdWdpbnMvZXh0ZW5zaW9ucy9leHQtY29tcG9uZW50LXJhdGluZ3NcIl0sICgpID0+IChfX3dlYnBhY2tfcmVxdWlyZV9fKFwiLi9yZXNvdXJjZXMvc2Nzcy9iYXNlL3BsdWdpbnMvZm9ybXMvcGlja2Vycy9mb3JtLWZsYXQtcGlja3Iuc2Nzc1wiKSkpXG5fX3dlYnBhY2tfcmVxdWlyZV9fLk8odW5kZWZpbmVkLCBbXCJjc3MvYmFzZS9wbHVnaW5zL2V4dGVuc2lvbnMvZXh0LWNvbXBvbmVudC1tZWRpYS1wbGF5ZXJcIixcImNzcy9iYXNlL3BsdWdpbnMvZXh0ZW5zaW9ucy9leHQtY29tcG9uZW50LWRyYWctZHJvcFwiLFwiY3NzL2Jhc2UvcGx1Z2lucy9leHRlbnNpb25zL2V4dC1jb21wb25lbnQtY29udGV4dC1tZW51XCIsXCJjc3MvYmFzZS9wbHVnaW5zL2NoYXJ0cy9jaGFydC1hcGV4XCIsXCJjc3Mvc3R5bGVcIixcImNzcy9vdmVycmlkZXNcIixcImNzcy9jb3JlXCIsXCJjc3MvYmFzZS90aGVtZXMvZGFyay1sYXlvdXRcIixcImNzcy9iYXNlL2NvcmUvbWl4aW5zL3RyYW5zaXRpb25zXCIsXCJjc3MvYmFzZS9jb3JlL21peGlucy9tYWluLW1lbnUtbWl4aW5cIixcImNzcy9iYXNlL2NvcmUvbWl4aW5zL2hleDJyZ2JcIixcImNzcy9iYXNlL2NvcmUvbWl4aW5zL2FsZXJ0XCIsXCJjc3MvYmFzZS9jb3JlL21lbnUvbWVudS10eXBlcy92ZXJ0aWNhbC1vdmVybGF5LW1lbnVcIixcImNzcy9iYXNlL2NvcmUvbWVudS9tZW51LXR5cGVzL3ZlcnRpY2FsLW1lbnVcIixcImNzcy9iYXNlL2NvcmUvbWVudS9tZW51LXR5cGVzL2hvcml6b250YWwtbWVudVwiLFwiY3NzL2Jhc2UvY29yZS9jb2xvcnMvcGFsZXR0ZS12YXJpYWJsZXNcIixcImNzcy9iYXNlL2NvcmUvY29sb3JzL3BhbGV0dGUtbm91aVwiLFwiY3NzL2Jhc2UvY29yZS9jb2xvcnMvcGFsZXR0ZS1ncmFkaWVudFwiLFwiY3NzL2Jhc2UvcGFnZXMvdWktZmVhdGhlclwiLFwiY3NzL2Jhc2UvcGFnZXMvcGFnZS1wcm9maWxlXCIsXCJjc3MvYmFzZS9wYWdlcy9wYWdlLXByaWNpbmdcIixcImNzcy9iYXNlL3BhZ2VzL3BhZ2UtbWlzY1wiLFwiY3NzL2Jhc2UvcGFnZXMvcGFnZS1rbm93bGVkZ2UtYmFzZVwiLFwiY3NzL2Jhc2UvcGFnZXMvcGFnZS1mYXFcIixcImNzcy9iYXNlL3BhZ2VzL3BhZ2UtY29taW5nLXNvb25cIixcImNzcy9iYXNlL3BhZ2VzL3BhZ2UtYmxvZ1wiLFwiY3NzL2Jhc2UvcGFnZXMvbW9kYWwtY3JlYXRlLWFwcFwiLFwiY3NzL2Jhc2UvcGFnZXMvZGFzaGJvYXJkLWVjb21tZXJjZVwiLFwiY3NzL2Jhc2UvcGFnZXMvYXV0aGVudGljYXRpb25cIixcImNzcy9iYXNlL3BhZ2VzL2FwcC10b2RvXCIsXCJjc3MvYmFzZS9wYWdlcy9hcHAta2FuYmFuXCIsXCJjc3MvYmFzZS9wYWdlcy9hcHAtaW52b2ljZVwiLFwiY3NzL2Jhc2UvcGFnZXMvYXBwLWludm9pY2UtcHJpbnRcIixcImNzcy9iYXNlL3BhZ2VzL2FwcC1pbnZvaWNlLWxpc3RcIixcImNzcy9iYXNlL3BhZ2VzL2FwcC1maWxlLW1hbmFnZXJcIixcImNzcy9iYXNlL3BhZ2VzL2FwcC1lbWFpbFwiLFwiY3NzL2Jhc2UvcGFnZXMvYXBwLWVjb21tZXJjZVwiLFwiY3NzL2Jhc2UvcGFnZXMvYXBwLWVjb21tZXJjZS1kZXRhaWxzXCIsXCJjc3MvYmFzZS9wYWdlcy9hcHAtY2hhdFwiLFwiY3NzL2Jhc2UvcGFnZXMvYXBwLWNoYXQtbGlzdFwiLFwiY3NzL2Jhc2UvcGFnZXMvYXBwLWNhbGVuZGFyXCIsXCJjc3MvYmFzZS9wbHVnaW5zL3VpL2NvbWluZy1zb29uXCIsXCJjc3MvYmFzZS9wbHVnaW5zL21hcHMvbWFwLWxlYWZsZXRcIixcImNzcy9iYXNlL3BsdWdpbnMvZm9ybXMvcGlja2Vycy9mb3JtLXBpY2thZGF0ZVwiLFwiY3NzL2Jhc2UvcGx1Z2lucy9mb3Jtcy9waWNrZXJzL2Zvcm0tZmxhdC1waWNrclwiLFwiY3NzL2Jhc2UvcGx1Z2lucy9mb3Jtcy9mb3JtLXdpemFyZFwiLFwiY3NzL2Jhc2UvcGx1Z2lucy9mb3Jtcy9mb3JtLXZhbGlkYXRpb25cIixcImNzcy9iYXNlL3BsdWdpbnMvZm9ybXMvZm9ybS1xdWlsbC1lZGl0b3JcIixcImNzcy9iYXNlL3BsdWdpbnMvZm9ybXMvZm9ybS1udW1iZXItaW5wdXRcIixcImNzcy9iYXNlL3BsdWdpbnMvZm9ybXMvZm9ybS1maWxlLXVwbG9hZGVyXCIsXCJjc3MvYmFzZS9wbHVnaW5zL2V4dGVuc2lvbnMvZXh0LWNvbXBvbmVudC10cmVlXCIsXCJjc3MvYmFzZS9wbHVnaW5zL2V4dGVuc2lvbnMvZXh0LWNvbXBvbmVudC10b3VyXCIsXCJjc3MvYmFzZS9wbHVnaW5zL2V4dGVuc2lvbnMvZXh0LWNvbXBvbmVudC10b2FzdHJcIixcImNzcy9iYXNlL3BsdWdpbnMvZXh0ZW5zaW9ucy9leHQtY29tcG9uZW50LXN3aXBlclwiLFwiY3NzL2Jhc2UvcGx1Z2lucy9leHRlbnNpb25zL2V4dC1jb21wb25lbnQtc3dlZXQtYWxlcnRzXCIsXCJjc3MvYmFzZS9wbHVnaW5zL2V4dGVuc2lvbnMvZXh0LWNvbXBvbmVudC1zbGlkZXJzXCIsXCJjc3MvYmFzZS9wbHVnaW5zL2V4dGVuc2lvbnMvZXh0LWNvbXBvbmVudC1yYXRpbmdzXCJdLCAoKSA9PiAoX193ZWJwYWNrX3JlcXVpcmVfXyhcIi4vcmVzb3VyY2VzL3Njc3MvYmFzZS9wbHVnaW5zL2Zvcm1zL3BpY2tlcnMvZm9ybS1waWNrYWRhdGUuc2Nzc1wiKSkpXG5fX3dlYnBhY2tfcmVxdWlyZV9fLk8odW5kZWZpbmVkLCBbXCJjc3MvYmFzZS9wbHVnaW5zL2V4dGVuc2lvbnMvZXh0LWNvbXBvbmVudC1tZWRpYS1wbGF5ZXJcIixcImNzcy9iYXNlL3BsdWdpbnMvZXh0ZW5zaW9ucy9leHQtY29tcG9uZW50LWRyYWctZHJvcFwiLFwiY3NzL2Jhc2UvcGx1Z2lucy9leHRlbnNpb25zL2V4dC1jb21wb25lbnQtY29udGV4dC1tZW51XCIsXCJjc3MvYmFzZS9wbHVnaW5zL2NoYXJ0cy9jaGFydC1hcGV4XCIsXCJjc3Mvc3R5bGVcIixcImNzcy9vdmVycmlkZXNcIixcImNzcy9jb3JlXCIsXCJjc3MvYmFzZS90aGVtZXMvZGFyay1sYXlvdXRcIixcImNzcy9iYXNlL2NvcmUvbWl4aW5zL3RyYW5zaXRpb25zXCIsXCJjc3MvYmFzZS9jb3JlL21peGlucy9tYWluLW1lbnUtbWl4aW5cIixcImNzcy9iYXNlL2NvcmUvbWl4aW5zL2hleDJyZ2JcIixcImNzcy9iYXNlL2NvcmUvbWl4aW5zL2FsZXJ0XCIsXCJjc3MvYmFzZS9jb3JlL21lbnUvbWVudS10eXBlcy92ZXJ0aWNhbC1vdmVybGF5LW1lbnVcIixcImNzcy9iYXNlL2NvcmUvbWVudS9tZW51LXR5cGVzL3ZlcnRpY2FsLW1lbnVcIixcImNzcy9iYXNlL2NvcmUvbWVudS9tZW51LXR5cGVzL2hvcml6b250YWwtbWVudVwiLFwiY3NzL2Jhc2UvY29yZS9jb2xvcnMvcGFsZXR0ZS12YXJpYWJsZXNcIixcImNzcy9iYXNlL2NvcmUvY29sb3JzL3BhbGV0dGUtbm91aVwiLFwiY3NzL2Jhc2UvY29yZS9jb2xvcnMvcGFsZXR0ZS1ncmFkaWVudFwiLFwiY3NzL2Jhc2UvcGFnZXMvdWktZmVhdGhlclwiLFwiY3NzL2Jhc2UvcGFnZXMvcGFnZS1wcm9maWxlXCIsXCJjc3MvYmFzZS9wYWdlcy9wYWdlLXByaWNpbmdcIixcImNzcy9iYXNlL3BhZ2VzL3BhZ2UtbWlzY1wiLFwiY3NzL2Jhc2UvcGFnZXMvcGFnZS1rbm93bGVkZ2UtYmFzZVwiLFwiY3NzL2Jhc2UvcGFnZXMvcGFnZS1mYXFcIixcImNzcy9iYXNlL3BhZ2VzL3BhZ2UtY29taW5nLXNvb25cIixcImNzcy9iYXNlL3BhZ2VzL3BhZ2UtYmxvZ1wiLFwiY3NzL2Jhc2UvcGFnZXMvbW9kYWwtY3JlYXRlLWFwcFwiLFwiY3NzL2Jhc2UvcGFnZXMvZGFzaGJvYXJkLWVjb21tZXJjZVwiLFwiY3NzL2Jhc2UvcGFnZXMvYXV0aGVudGljYXRpb25cIixcImNzcy9iYXNlL3BhZ2VzL2FwcC10b2RvXCIsXCJjc3MvYmFzZS9wYWdlcy9hcHAta2FuYmFuXCIsXCJjc3MvYmFzZS9wYWdlcy9hcHAtaW52b2ljZVwiLFwiY3NzL2Jhc2UvcGFnZXMvYXBwLWludm9pY2UtcHJpbnRcIixcImNzcy9iYXNlL3BhZ2VzL2FwcC1pbnZvaWNlLWxpc3RcIixcImNzcy9iYXNlL3BhZ2VzL2FwcC1maWxlLW1hbmFnZXJcIixcImNzcy9iYXNlL3BhZ2VzL2FwcC1lbWFpbFwiLFwiY3NzL2Jhc2UvcGFnZXMvYXBwLWVjb21tZXJjZVwiLFwiY3NzL2Jhc2UvcGFnZXMvYXBwLWVjb21tZXJjZS1kZXRhaWxzXCIsXCJjc3MvYmFzZS9wYWdlcy9hcHAtY2hhdFwiLFwiY3NzL2Jhc2UvcGFnZXMvYXBwLWNoYXQtbGlzdFwiLFwiY3NzL2Jhc2UvcGFnZXMvYXBwLWNhbGVuZGFyXCIsXCJjc3MvYmFzZS9wbHVnaW5zL3VpL2NvbWluZy1zb29uXCIsXCJjc3MvYmFzZS9wbHVnaW5zL21hcHMvbWFwLWxlYWZsZXRcIixcImNzcy9iYXNlL3BsdWdpbnMvZm9ybXMvcGlja2Vycy9mb3JtLXBpY2thZGF0ZVwiLFwiY3NzL2Jhc2UvcGx1Z2lucy9mb3Jtcy9waWNrZXJzL2Zvcm0tZmxhdC1waWNrclwiLFwiY3NzL2Jhc2UvcGx1Z2lucy9mb3Jtcy9mb3JtLXdpemFyZFwiLFwiY3NzL2Jhc2UvcGx1Z2lucy9mb3Jtcy9mb3JtLXZhbGlkYXRpb25cIixcImNzcy9iYXNlL3BsdWdpbnMvZm9ybXMvZm9ybS1xdWlsbC1lZGl0b3JcIixcImNzcy9iYXNlL3BsdWdpbnMvZm9ybXMvZm9ybS1udW1iZXItaW5wdXRcIixcImNzcy9iYXNlL3BsdWdpbnMvZm9ybXMvZm9ybS1maWxlLXVwbG9hZGVyXCIsXCJjc3MvYmFzZS9wbHVnaW5zL2V4dGVuc2lvbnMvZXh0LWNvbXBvbmVudC10cmVlXCIsXCJjc3MvYmFzZS9wbHVnaW5zL2V4dGVuc2lvbnMvZXh0LWNvbXBvbmVudC10b3VyXCIsXCJjc3MvYmFzZS9wbHVnaW5zL2V4dGVuc2lvbnMvZXh0LWNvbXBvbmVudC10b2FzdHJcIixcImNzcy9iYXNlL3BsdWdpbnMvZXh0ZW5zaW9ucy9leHQtY29tcG9uZW50LXN3aXBlclwiLFwiY3NzL2Jhc2UvcGx1Z2lucy9leHRlbnNpb25zL2V4dC1jb21wb25lbnQtc3dlZXQtYWxlcnRzXCIsXCJjc3MvYmFzZS9wbHVnaW5zL2V4dGVuc2lvbnMvZXh0LWNvbXBvbmVudC1zbGlkZXJzXCIsXCJjc3MvYmFzZS9wbHVnaW5zL2V4dGVuc2lvbnMvZXh0LWNvbXBvbmVudC1yYXRpbmdzXCJdLCAoKSA9PiAoX193ZWJwYWNrX3JlcXVpcmVfXyhcIi4vcmVzb3VyY2VzL3Njc3MvYmFzZS9wbHVnaW5zL21hcHMvbWFwLWxlYWZsZXQuc2Nzc1wiKSkpXG5fX3dlYnBhY2tfcmVxdWlyZV9fLk8odW5kZWZpbmVkLCBbXCJjc3MvYmFzZS9wbHVnaW5zL2V4dGVuc2lvbnMvZXh0LWNvbXBvbmVudC1tZWRpYS1wbGF5ZXJcIixcImNzcy9iYXNlL3BsdWdpbnMvZXh0ZW5zaW9ucy9leHQtY29tcG9uZW50LWRyYWctZHJvcFwiLFwiY3NzL2Jhc2UvcGx1Z2lucy9leHRlbnNpb25zL2V4dC1jb21wb25lbnQtY29udGV4dC1tZW51XCIsXCJjc3MvYmFzZS9wbHVnaW5zL2NoYXJ0cy9jaGFydC1hcGV4XCIsXCJjc3Mvc3R5bGVcIixcImNzcy9vdmVycmlkZXNcIixcImNzcy9jb3JlXCIsXCJjc3MvYmFzZS90aGVtZXMvZGFyay1sYXlvdXRcIixcImNzcy9iYXNlL2NvcmUvbWl4aW5zL3RyYW5zaXRpb25zXCIsXCJjc3MvYmFzZS9jb3JlL21peGlucy9tYWluLW1lbnUtbWl4aW5cIixcImNzcy9iYXNlL2NvcmUvbWl4aW5zL2hleDJyZ2JcIixcImNzcy9iYXNlL2NvcmUvbWl4aW5zL2FsZXJ0XCIsXCJjc3MvYmFzZS9jb3JlL21lbnUvbWVudS10eXBlcy92ZXJ0aWNhbC1vdmVybGF5LW1lbnVcIixcImNzcy9iYXNlL2NvcmUvbWVudS9tZW51LXR5cGVzL3ZlcnRpY2FsLW1lbnVcIixcImNzcy9iYXNlL2NvcmUvbWVudS9tZW51LXR5cGVzL2hvcml6b250YWwtbWVudVwiLFwiY3NzL2Jhc2UvY29yZS9jb2xvcnMvcGFsZXR0ZS12YXJpYWJsZXNcIixcImNzcy9iYXNlL2NvcmUvY29sb3JzL3BhbGV0dGUtbm91aVwiLFwiY3NzL2Jhc2UvY29yZS9jb2xvcnMvcGFsZXR0ZS1ncmFkaWVudFwiLFwiY3NzL2Jhc2UvcGFnZXMvdWktZmVhdGhlclwiLFwiY3NzL2Jhc2UvcGFnZXMvcGFnZS1wcm9maWxlXCIsXCJjc3MvYmFzZS9wYWdlcy9wYWdlLXByaWNpbmdcIixcImNzcy9iYXNlL3BhZ2VzL3BhZ2UtbWlzY1wiLFwiY3NzL2Jhc2UvcGFnZXMvcGFnZS1rbm93bGVkZ2UtYmFzZVwiLFwiY3NzL2Jhc2UvcGFnZXMvcGFnZS1mYXFcIixcImNzcy9iYXNlL3BhZ2VzL3BhZ2UtY29taW5nLXNvb25cIixcImNzcy9iYXNlL3BhZ2VzL3BhZ2UtYmxvZ1wiLFwiY3NzL2Jhc2UvcGFnZXMvbW9kYWwtY3JlYXRlLWFwcFwiLFwiY3NzL2Jhc2UvcGFnZXMvZGFzaGJvYXJkLWVjb21tZXJjZVwiLFwiY3NzL2Jhc2UvcGFnZXMvYXV0aGVudGljYXRpb25cIixcImNzcy9iYXNlL3BhZ2VzL2FwcC10b2RvXCIsXCJjc3MvYmFzZS9wYWdlcy9hcHAta2FuYmFuXCIsXCJjc3MvYmFzZS9wYWdlcy9hcHAtaW52b2ljZVwiLFwiY3NzL2Jhc2UvcGFnZXMvYXBwLWludm9pY2UtcHJpbnRcIixcImNzcy9iYXNlL3BhZ2VzL2FwcC1pbnZvaWNlLWxpc3RcIixcImNzcy9iYXNlL3BhZ2VzL2FwcC1maWxlLW1hbmFnZXJcIixcImNzcy9iYXNlL3BhZ2VzL2FwcC1lbWFpbFwiLFwiY3NzL2Jhc2UvcGFnZXMvYXBwLWVjb21tZXJjZVwiLFwiY3NzL2Jhc2UvcGFnZXMvYXBwLWVjb21tZXJjZS1kZXRhaWxzXCIsXCJjc3MvYmFzZS9wYWdlcy9hcHAtY2hhdFwiLFwiY3NzL2Jhc2UvcGFnZXMvYXBwLWNoYXQtbGlzdFwiLFwiY3NzL2Jhc2UvcGFnZXMvYXBwLWNhbGVuZGFyXCIsXCJjc3MvYmFzZS9wbHVnaW5zL3VpL2NvbWluZy1zb29uXCIsXCJjc3MvYmFzZS9wbHVnaW5zL21hcHMvbWFwLWxlYWZsZXRcIixcImNzcy9iYXNlL3BsdWdpbnMvZm9ybXMvcGlja2Vycy9mb3JtLXBpY2thZGF0ZVwiLFwiY3NzL2Jhc2UvcGx1Z2lucy9mb3Jtcy9waWNrZXJzL2Zvcm0tZmxhdC1waWNrclwiLFwiY3NzL2Jhc2UvcGx1Z2lucy9mb3Jtcy9mb3JtLXdpemFyZFwiLFwiY3NzL2Jhc2UvcGx1Z2lucy9mb3Jtcy9mb3JtLXZhbGlkYXRpb25cIixcImNzcy9iYXNlL3BsdWdpbnMvZm9ybXMvZm9ybS1xdWlsbC1lZGl0b3JcIixcImNzcy9iYXNlL3BsdWdpbnMvZm9ybXMvZm9ybS1udW1iZXItaW5wdXRcIixcImNzcy9iYXNlL3BsdWdpbnMvZm9ybXMvZm9ybS1maWxlLXVwbG9hZGVyXCIsXCJjc3MvYmFzZS9wbHVnaW5zL2V4dGVuc2lvbnMvZXh0LWNvbXBvbmVudC10cmVlXCIsXCJjc3MvYmFzZS9wbHVnaW5zL2V4dGVuc2lvbnMvZXh0LWNvbXBvbmVudC10b3VyXCIsXCJjc3MvYmFzZS9wbHVnaW5zL2V4dGVuc2lvbnMvZXh0LWNvbXBvbmVudC10b2FzdHJcIixcImNzcy9iYXNlL3BsdWdpbnMvZXh0ZW5zaW9ucy9leHQtY29tcG9uZW50LXN3aXBlclwiLFwiY3NzL2Jhc2UvcGx1Z2lucy9leHRlbnNpb25zL2V4dC1jb21wb25lbnQtc3dlZXQtYWxlcnRzXCIsXCJjc3MvYmFzZS9wbHVnaW5zL2V4dGVuc2lvbnMvZXh0LWNvbXBvbmVudC1zbGlkZXJzXCIsXCJjc3MvYmFzZS9wbHVnaW5zL2V4dGVuc2lvbnMvZXh0LWNvbXBvbmVudC1yYXRpbmdzXCJdLCAoKSA9PiAoX193ZWJwYWNrX3JlcXVpcmVfXyhcIi4vcmVzb3VyY2VzL3Njc3MvYmFzZS9wbHVnaW5zL3VpL2NvbWluZy1zb29uLnNjc3NcIikpKVxuX193ZWJwYWNrX3JlcXVpcmVfXy5PKHVuZGVmaW5lZCwgW1wiY3NzL2Jhc2UvcGx1Z2lucy9leHRlbnNpb25zL2V4dC1jb21wb25lbnQtbWVkaWEtcGxheWVyXCIsXCJjc3MvYmFzZS9wbHVnaW5zL2V4dGVuc2lvbnMvZXh0LWNvbXBvbmVudC1kcmFnLWRyb3BcIixcImNzcy9iYXNlL3BsdWdpbnMvZXh0ZW5zaW9ucy9leHQtY29tcG9uZW50LWNvbnRleHQtbWVudVwiLFwiY3NzL2Jhc2UvcGx1Z2lucy9jaGFydHMvY2hhcnQtYXBleFwiLFwiY3NzL3N0eWxlXCIsXCJjc3Mvb3ZlcnJpZGVzXCIsXCJjc3MvY29yZVwiLFwiY3NzL2Jhc2UvdGhlbWVzL2RhcmstbGF5b3V0XCIsXCJjc3MvYmFzZS9jb3JlL21peGlucy90cmFuc2l0aW9uc1wiLFwiY3NzL2Jhc2UvY29yZS9taXhpbnMvbWFpbi1tZW51LW1peGluXCIsXCJjc3MvYmFzZS9jb3JlL21peGlucy9oZXgycmdiXCIsXCJjc3MvYmFzZS9jb3JlL21peGlucy9hbGVydFwiLFwiY3NzL2Jhc2UvY29yZS9tZW51L21lbnUtdHlwZXMvdmVydGljYWwtb3ZlcmxheS1tZW51XCIsXCJjc3MvYmFzZS9jb3JlL21lbnUvbWVudS10eXBlcy92ZXJ0aWNhbC1tZW51XCIsXCJjc3MvYmFzZS9jb3JlL21lbnUvbWVudS10eXBlcy9ob3Jpem9udGFsLW1lbnVcIixcImNzcy9iYXNlL2NvcmUvY29sb3JzL3BhbGV0dGUtdmFyaWFibGVzXCIsXCJjc3MvYmFzZS9jb3JlL2NvbG9ycy9wYWxldHRlLW5vdWlcIixcImNzcy9iYXNlL2NvcmUvY29sb3JzL3BhbGV0dGUtZ3JhZGllbnRcIixcImNzcy9iYXNlL3BhZ2VzL3VpLWZlYXRoZXJcIixcImNzcy9iYXNlL3BhZ2VzL3BhZ2UtcHJvZmlsZVwiLFwiY3NzL2Jhc2UvcGFnZXMvcGFnZS1wcmljaW5nXCIsXCJjc3MvYmFzZS9wYWdlcy9wYWdlLW1pc2NcIixcImNzcy9iYXNlL3BhZ2VzL3BhZ2Uta25vd2xlZGdlLWJhc2VcIixcImNzcy9iYXNlL3BhZ2VzL3BhZ2UtZmFxXCIsXCJjc3MvYmFzZS9wYWdlcy9wYWdlLWNvbWluZy1zb29uXCIsXCJjc3MvYmFzZS9wYWdlcy9wYWdlLWJsb2dcIixcImNzcy9iYXNlL3BhZ2VzL21vZGFsLWNyZWF0ZS1hcHBcIixcImNzcy9iYXNlL3BhZ2VzL2Rhc2hib2FyZC1lY29tbWVyY2VcIixcImNzcy9iYXNlL3BhZ2VzL2F1dGhlbnRpY2F0aW9uXCIsXCJjc3MvYmFzZS9wYWdlcy9hcHAtdG9kb1wiLFwiY3NzL2Jhc2UvcGFnZXMvYXBwLWthbmJhblwiLFwiY3NzL2Jhc2UvcGFnZXMvYXBwLWludm9pY2VcIixcImNzcy9iYXNlL3BhZ2VzL2FwcC1pbnZvaWNlLXByaW50XCIsXCJjc3MvYmFzZS9wYWdlcy9hcHAtaW52b2ljZS1saXN0XCIsXCJjc3MvYmFzZS9wYWdlcy9hcHAtZmlsZS1tYW5hZ2VyXCIsXCJjc3MvYmFzZS9wYWdlcy9hcHAtZW1haWxcIixcImNzcy9iYXNlL3BhZ2VzL2FwcC1lY29tbWVyY2VcIixcImNzcy9iYXNlL3BhZ2VzL2FwcC1lY29tbWVyY2UtZGV0YWlsc1wiLFwiY3NzL2Jhc2UvcGFnZXMvYXBwLWNoYXRcIixcImNzcy9iYXNlL3BhZ2VzL2FwcC1jaGF0LWxpc3RcIixcImNzcy9iYXNlL3BhZ2VzL2FwcC1jYWxlbmRhclwiLFwiY3NzL2Jhc2UvcGx1Z2lucy91aS9jb21pbmctc29vblwiLFwiY3NzL2Jhc2UvcGx1Z2lucy9tYXBzL21hcC1sZWFmbGV0XCIsXCJjc3MvYmFzZS9wbHVnaW5zL2Zvcm1zL3BpY2tlcnMvZm9ybS1waWNrYWRhdGVcIixcImNzcy9iYXNlL3BsdWdpbnMvZm9ybXMvcGlja2Vycy9mb3JtLWZsYXQtcGlja3JcIixcImNzcy9iYXNlL3BsdWdpbnMvZm9ybXMvZm9ybS13aXphcmRcIixcImNzcy9iYXNlL3BsdWdpbnMvZm9ybXMvZm9ybS12YWxpZGF0aW9uXCIsXCJjc3MvYmFzZS9wbHVnaW5zL2Zvcm1zL2Zvcm0tcXVpbGwtZWRpdG9yXCIsXCJjc3MvYmFzZS9wbHVnaW5zL2Zvcm1zL2Zvcm0tbnVtYmVyLWlucHV0XCIsXCJjc3MvYmFzZS9wbHVnaW5zL2Zvcm1zL2Zvcm0tZmlsZS11cGxvYWRlclwiLFwiY3NzL2Jhc2UvcGx1Z2lucy9leHRlbnNpb25zL2V4dC1jb21wb25lbnQtdHJlZVwiLFwiY3NzL2Jhc2UvcGx1Z2lucy9leHRlbnNpb25zL2V4dC1jb21wb25lbnQtdG91clwiLFwiY3NzL2Jhc2UvcGx1Z2lucy9leHRlbnNpb25zL2V4dC1jb21wb25lbnQtdG9hc3RyXCIsXCJjc3MvYmFzZS9wbHVnaW5zL2V4dGVuc2lvbnMvZXh0LWNvbXBvbmVudC1zd2lwZXJcIixcImNzcy9iYXNlL3BsdWdpbnMvZXh0ZW5zaW9ucy9leHQtY29tcG9uZW50LXN3ZWV0LWFsZXJ0c1wiLFwiY3NzL2Jhc2UvcGx1Z2lucy9leHRlbnNpb25zL2V4dC1jb21wb25lbnQtc2xpZGVyc1wiLFwiY3NzL2Jhc2UvcGx1Z2lucy9leHRlbnNpb25zL2V4dC1jb21wb25lbnQtcmF0aW5nc1wiXSwgKCkgPT4gKF9fd2VicGFja19yZXF1aXJlX18oXCIuL3Jlc291cmNlcy9zY3NzL2Jhc2UvcGFnZXMvYXBwLWNhbGVuZGFyLnNjc3NcIikpKVxuX193ZWJwYWNrX3JlcXVpcmVfXy5PKHVuZGVmaW5lZCwgW1wiY3NzL2Jhc2UvcGx1Z2lucy9leHRlbnNpb25zL2V4dC1jb21wb25lbnQtbWVkaWEtcGxheWVyXCIsXCJjc3MvYmFzZS9wbHVnaW5zL2V4dGVuc2lvbnMvZXh0LWNvbXBvbmVudC1kcmFnLWRyb3BcIixcImNzcy9iYXNlL3BsdWdpbnMvZXh0ZW5zaW9ucy9leHQtY29tcG9uZW50LWNvbnRleHQtbWVudVwiLFwiY3NzL2Jhc2UvcGx1Z2lucy9jaGFydHMvY2hhcnQtYXBleFwiLFwiY3NzL3N0eWxlXCIsXCJjc3Mvb3ZlcnJpZGVzXCIsXCJjc3MvY29yZVwiLFwiY3NzL2Jhc2UvdGhlbWVzL2RhcmstbGF5b3V0XCIsXCJjc3MvYmFzZS9jb3JlL21peGlucy90cmFuc2l0aW9uc1wiLFwiY3NzL2Jhc2UvY29yZS9taXhpbnMvbWFpbi1tZW51LW1peGluXCIsXCJjc3MvYmFzZS9jb3JlL21peGlucy9oZXgycmdiXCIsXCJjc3MvYmFzZS9jb3JlL21peGlucy9hbGVydFwiLFwiY3NzL2Jhc2UvY29yZS9tZW51L21lbnUtdHlwZXMvdmVydGljYWwtb3ZlcmxheS1tZW51XCIsXCJjc3MvYmFzZS9jb3JlL21lbnUvbWVudS10eXBlcy92ZXJ0aWNhbC1tZW51XCIsXCJjc3MvYmFzZS9jb3JlL21lbnUvbWVudS10eXBlcy9ob3Jpem9udGFsLW1lbnVcIixcImNzcy9iYXNlL2NvcmUvY29sb3JzL3BhbGV0dGUtdmFyaWFibGVzXCIsXCJjc3MvYmFzZS9jb3JlL2NvbG9ycy9wYWxldHRlLW5vdWlcIixcImNzcy9iYXNlL2NvcmUvY29sb3JzL3BhbGV0dGUtZ3JhZGllbnRcIixcImNzcy9iYXNlL3BhZ2VzL3VpLWZlYXRoZXJcIixcImNzcy9iYXNlL3BhZ2VzL3BhZ2UtcHJvZmlsZVwiLFwiY3NzL2Jhc2UvcGFnZXMvcGFnZS1wcmljaW5nXCIsXCJjc3MvYmFzZS9wYWdlcy9wYWdlLW1pc2NcIixcImNzcy9iYXNlL3BhZ2VzL3BhZ2Uta25vd2xlZGdlLWJhc2VcIixcImNzcy9iYXNlL3BhZ2VzL3BhZ2UtZmFxXCIsXCJjc3MvYmFzZS9wYWdlcy9wYWdlLWNvbWluZy1zb29uXCIsXCJjc3MvYmFzZS9wYWdlcy9wYWdlLWJsb2dcIixcImNzcy9iYXNlL3BhZ2VzL21vZGFsLWNyZWF0ZS1hcHBcIixcImNzcy9iYXNlL3BhZ2VzL2Rhc2hib2FyZC1lY29tbWVyY2VcIixcImNzcy9iYXNlL3BhZ2VzL2F1dGhlbnRpY2F0aW9uXCIsXCJjc3MvYmFzZS9wYWdlcy9hcHAtdG9kb1wiLFwiY3NzL2Jhc2UvcGFnZXMvYXBwLWthbmJhblwiLFwiY3NzL2Jhc2UvcGFnZXMvYXBwLWludm9pY2VcIixcImNzcy9iYXNlL3BhZ2VzL2FwcC1pbnZvaWNlLXByaW50XCIsXCJjc3MvYmFzZS9wYWdlcy9hcHAtaW52b2ljZS1saXN0XCIsXCJjc3MvYmFzZS9wYWdlcy9hcHAtZmlsZS1tYW5hZ2VyXCIsXCJjc3MvYmFzZS9wYWdlcy9hcHAtZW1haWxcIixcImNzcy9iYXNlL3BhZ2VzL2FwcC1lY29tbWVyY2VcIixcImNzcy9iYXNlL3BhZ2VzL2FwcC1lY29tbWVyY2UtZGV0YWlsc1wiLFwiY3NzL2Jhc2UvcGFnZXMvYXBwLWNoYXRcIixcImNzcy9iYXNlL3BhZ2VzL2FwcC1jaGF0LWxpc3RcIixcImNzcy9iYXNlL3BhZ2VzL2FwcC1jYWxlbmRhclwiLFwiY3NzL2Jhc2UvcGx1Z2lucy91aS9jb21pbmctc29vblwiLFwiY3NzL2Jhc2UvcGx1Z2lucy9tYXBzL21hcC1sZWFmbGV0XCIsXCJjc3MvYmFzZS9wbHVnaW5zL2Zvcm1zL3BpY2tlcnMvZm9ybS1waWNrYWRhdGVcIixcImNzcy9iYXNlL3BsdWdpbnMvZm9ybXMvcGlja2Vycy9mb3JtLWZsYXQtcGlja3JcIixcImNzcy9iYXNlL3BsdWdpbnMvZm9ybXMvZm9ybS13aXphcmRcIixcImNzcy9iYXNlL3BsdWdpbnMvZm9ybXMvZm9ybS12YWxpZGF0aW9uXCIsXCJjc3MvYmFzZS9wbHVnaW5zL2Zvcm1zL2Zvcm0tcXVpbGwtZWRpdG9yXCIsXCJjc3MvYmFzZS9wbHVnaW5zL2Zvcm1zL2Zvcm0tbnVtYmVyLWlucHV0XCIsXCJjc3MvYmFzZS9wbHVnaW5zL2Zvcm1zL2Zvcm0tZmlsZS11cGxvYWRlclwiLFwiY3NzL2Jhc2UvcGx1Z2lucy9leHRlbnNpb25zL2V4dC1jb21wb25lbnQtdHJlZVwiLFwiY3NzL2Jhc2UvcGx1Z2lucy9leHRlbnNpb25zL2V4dC1jb21wb25lbnQtdG91clwiLFwiY3NzL2Jhc2UvcGx1Z2lucy9leHRlbnNpb25zL2V4dC1jb21wb25lbnQtdG9hc3RyXCIsXCJjc3MvYmFzZS9wbHVnaW5zL2V4dGVuc2lvbnMvZXh0LWNvbXBvbmVudC1zd2lwZXJcIixcImNzcy9iYXNlL3BsdWdpbnMvZXh0ZW5zaW9ucy9leHQtY29tcG9uZW50LXN3ZWV0LWFsZXJ0c1wiLFwiY3NzL2Jhc2UvcGx1Z2lucy9leHRlbnNpb25zL2V4dC1jb21wb25lbnQtc2xpZGVyc1wiLFwiY3NzL2Jhc2UvcGx1Z2lucy9leHRlbnNpb25zL2V4dC1jb21wb25lbnQtcmF0aW5nc1wiXSwgKCkgPT4gKF9fd2VicGFja19yZXF1aXJlX18oXCIuL3Jlc291cmNlcy9zY3NzL2Jhc2UvcGFnZXMvYXBwLWNoYXQtbGlzdC5zY3NzXCIpKSlcbl9fd2VicGFja19yZXF1aXJlX18uTyh1bmRlZmluZWQsIFtcImNzcy9iYXNlL3BsdWdpbnMvZXh0ZW5zaW9ucy9leHQtY29tcG9uZW50LW1lZGlhLXBsYXllclwiLFwiY3NzL2Jhc2UvcGx1Z2lucy9leHRlbnNpb25zL2V4dC1jb21wb25lbnQtZHJhZy1kcm9wXCIsXCJjc3MvYmFzZS9wbHVnaW5zL2V4dGVuc2lvbnMvZXh0LWNvbXBvbmVudC1jb250ZXh0LW1lbnVcIixcImNzcy9iYXNlL3BsdWdpbnMvY2hhcnRzL2NoYXJ0LWFwZXhcIixcImNzcy9zdHlsZVwiLFwiY3NzL292ZXJyaWRlc1wiLFwiY3NzL2NvcmVcIixcImNzcy9iYXNlL3RoZW1lcy9kYXJrLWxheW91dFwiLFwiY3NzL2Jhc2UvY29yZS9taXhpbnMvdHJhbnNpdGlvbnNcIixcImNzcy9iYXNlL2NvcmUvbWl4aW5zL21haW4tbWVudS1taXhpblwiLFwiY3NzL2Jhc2UvY29yZS9taXhpbnMvaGV4MnJnYlwiLFwiY3NzL2Jhc2UvY29yZS9taXhpbnMvYWxlcnRcIixcImNzcy9iYXNlL2NvcmUvbWVudS9tZW51LXR5cGVzL3ZlcnRpY2FsLW92ZXJsYXktbWVudVwiLFwiY3NzL2Jhc2UvY29yZS9tZW51L21lbnUtdHlwZXMvdmVydGljYWwtbWVudVwiLFwiY3NzL2Jhc2UvY29yZS9tZW51L21lbnUtdHlwZXMvaG9yaXpvbnRhbC1tZW51XCIsXCJjc3MvYmFzZS9jb3JlL2NvbG9ycy9wYWxldHRlLXZhcmlhYmxlc1wiLFwiY3NzL2Jhc2UvY29yZS9jb2xvcnMvcGFsZXR0ZS1ub3VpXCIsXCJjc3MvYmFzZS9jb3JlL2NvbG9ycy9wYWxldHRlLWdyYWRpZW50XCIsXCJjc3MvYmFzZS9wYWdlcy91aS1mZWF0aGVyXCIsXCJjc3MvYmFzZS9wYWdlcy9wYWdlLXByb2ZpbGVcIixcImNzcy9iYXNlL3BhZ2VzL3BhZ2UtcHJpY2luZ1wiLFwiY3NzL2Jhc2UvcGFnZXMvcGFnZS1taXNjXCIsXCJjc3MvYmFzZS9wYWdlcy9wYWdlLWtub3dsZWRnZS1iYXNlXCIsXCJjc3MvYmFzZS9wYWdlcy9wYWdlLWZhcVwiLFwiY3NzL2Jhc2UvcGFnZXMvcGFnZS1jb21pbmctc29vblwiLFwiY3NzL2Jhc2UvcGFnZXMvcGFnZS1ibG9nXCIsXCJjc3MvYmFzZS9wYWdlcy9tb2RhbC1jcmVhdGUtYXBwXCIsXCJjc3MvYmFzZS9wYWdlcy9kYXNoYm9hcmQtZWNvbW1lcmNlXCIsXCJjc3MvYmFzZS9wYWdlcy9hdXRoZW50aWNhdGlvblwiLFwiY3NzL2Jhc2UvcGFnZXMvYXBwLXRvZG9cIixcImNzcy9iYXNlL3BhZ2VzL2FwcC1rYW5iYW5cIixcImNzcy9iYXNlL3BhZ2VzL2FwcC1pbnZvaWNlXCIsXCJjc3MvYmFzZS9wYWdlcy9hcHAtaW52b2ljZS1wcmludFwiLFwiY3NzL2Jhc2UvcGFnZXMvYXBwLWludm9pY2UtbGlzdFwiLFwiY3NzL2Jhc2UvcGFnZXMvYXBwLWZpbGUtbWFuYWdlclwiLFwiY3NzL2Jhc2UvcGFnZXMvYXBwLWVtYWlsXCIsXCJjc3MvYmFzZS9wYWdlcy9hcHAtZWNvbW1lcmNlXCIsXCJjc3MvYmFzZS9wYWdlcy9hcHAtZWNvbW1lcmNlLWRldGFpbHNcIixcImNzcy9iYXNlL3BhZ2VzL2FwcC1jaGF0XCIsXCJjc3MvYmFzZS9wYWdlcy9hcHAtY2hhdC1saXN0XCIsXCJjc3MvYmFzZS9wYWdlcy9hcHAtY2FsZW5kYXJcIixcImNzcy9iYXNlL3BsdWdpbnMvdWkvY29taW5nLXNvb25cIixcImNzcy9iYXNlL3BsdWdpbnMvbWFwcy9tYXAtbGVhZmxldFwiLFwiY3NzL2Jhc2UvcGx1Z2lucy9mb3Jtcy9waWNrZXJzL2Zvcm0tcGlja2FkYXRlXCIsXCJjc3MvYmFzZS9wbHVnaW5zL2Zvcm1zL3BpY2tlcnMvZm9ybS1mbGF0LXBpY2tyXCIsXCJjc3MvYmFzZS9wbHVnaW5zL2Zvcm1zL2Zvcm0td2l6YXJkXCIsXCJjc3MvYmFzZS9wbHVnaW5zL2Zvcm1zL2Zvcm0tdmFsaWRhdGlvblwiLFwiY3NzL2Jhc2UvcGx1Z2lucy9mb3Jtcy9mb3JtLXF1aWxsLWVkaXRvclwiLFwiY3NzL2Jhc2UvcGx1Z2lucy9mb3Jtcy9mb3JtLW51bWJlci1pbnB1dFwiLFwiY3NzL2Jhc2UvcGx1Z2lucy9mb3Jtcy9mb3JtLWZpbGUtdXBsb2FkZXJcIixcImNzcy9iYXNlL3BsdWdpbnMvZXh0ZW5zaW9ucy9leHQtY29tcG9uZW50LXRyZWVcIixcImNzcy9iYXNlL3BsdWdpbnMvZXh0ZW5zaW9ucy9leHQtY29tcG9uZW50LXRvdXJcIixcImNzcy9iYXNlL3BsdWdpbnMvZXh0ZW5zaW9ucy9leHQtY29tcG9uZW50LXRvYXN0clwiLFwiY3NzL2Jhc2UvcGx1Z2lucy9leHRlbnNpb25zL2V4dC1jb21wb25lbnQtc3dpcGVyXCIsXCJjc3MvYmFzZS9wbHVnaW5zL2V4dGVuc2lvbnMvZXh0LWNvbXBvbmVudC1zd2VldC1hbGVydHNcIixcImNzcy9iYXNlL3BsdWdpbnMvZXh0ZW5zaW9ucy9leHQtY29tcG9uZW50LXNsaWRlcnNcIixcImNzcy9iYXNlL3BsdWdpbnMvZXh0ZW5zaW9ucy9leHQtY29tcG9uZW50LXJhdGluZ3NcIl0sICgpID0+IChfX3dlYnBhY2tfcmVxdWlyZV9fKFwiLi9yZXNvdXJjZXMvc2Nzcy9iYXNlL3BhZ2VzL2FwcC1jaGF0LnNjc3NcIikpKVxuX193ZWJwYWNrX3JlcXVpcmVfXy5PKHVuZGVmaW5lZCwgW1wiY3NzL2Jhc2UvcGx1Z2lucy9leHRlbnNpb25zL2V4dC1jb21wb25lbnQtbWVkaWEtcGxheWVyXCIsXCJjc3MvYmFzZS9wbHVnaW5zL2V4dGVuc2lvbnMvZXh0LWNvbXBvbmVudC1kcmFnLWRyb3BcIixcImNzcy9iYXNlL3BsdWdpbnMvZXh0ZW5zaW9ucy9leHQtY29tcG9uZW50LWNvbnRleHQtbWVudVwiLFwiY3NzL2Jhc2UvcGx1Z2lucy9jaGFydHMvY2hhcnQtYXBleFwiLFwiY3NzL3N0eWxlXCIsXCJjc3Mvb3ZlcnJpZGVzXCIsXCJjc3MvY29yZVwiLFwiY3NzL2Jhc2UvdGhlbWVzL2RhcmstbGF5b3V0XCIsXCJjc3MvYmFzZS9jb3JlL21peGlucy90cmFuc2l0aW9uc1wiLFwiY3NzL2Jhc2UvY29yZS9taXhpbnMvbWFpbi1tZW51LW1peGluXCIsXCJjc3MvYmFzZS9jb3JlL21peGlucy9oZXgycmdiXCIsXCJjc3MvYmFzZS9jb3JlL21peGlucy9hbGVydFwiLFwiY3NzL2Jhc2UvY29yZS9tZW51L21lbnUtdHlwZXMvdmVydGljYWwtb3ZlcmxheS1tZW51XCIsXCJjc3MvYmFzZS9jb3JlL21lbnUvbWVudS10eXBlcy92ZXJ0aWNhbC1tZW51XCIsXCJjc3MvYmFzZS9jb3JlL21lbnUvbWVudS10eXBlcy9ob3Jpem9udGFsLW1lbnVcIixcImNzcy9iYXNlL2NvcmUvY29sb3JzL3BhbGV0dGUtdmFyaWFibGVzXCIsXCJjc3MvYmFzZS9jb3JlL2NvbG9ycy9wYWxldHRlLW5vdWlcIixcImNzcy9iYXNlL2NvcmUvY29sb3JzL3BhbGV0dGUtZ3JhZGllbnRcIixcImNzcy9iYXNlL3BhZ2VzL3VpLWZlYXRoZXJcIixcImNzcy9iYXNlL3BhZ2VzL3BhZ2UtcHJvZmlsZVwiLFwiY3NzL2Jhc2UvcGFnZXMvcGFnZS1wcmljaW5nXCIsXCJjc3MvYmFzZS9wYWdlcy9wYWdlLW1pc2NcIixcImNzcy9iYXNlL3BhZ2VzL3BhZ2Uta25vd2xlZGdlLWJhc2VcIixcImNzcy9iYXNlL3BhZ2VzL3BhZ2UtZmFxXCIsXCJjc3MvYmFzZS9wYWdlcy9wYWdlLWNvbWluZy1zb29uXCIsXCJjc3MvYmFzZS9wYWdlcy9wYWdlLWJsb2dcIixcImNzcy9iYXNlL3BhZ2VzL21vZGFsLWNyZWF0ZS1hcHBcIixcImNzcy9iYXNlL3BhZ2VzL2Rhc2hib2FyZC1lY29tbWVyY2VcIixcImNzcy9iYXNlL3BhZ2VzL2F1dGhlbnRpY2F0aW9uXCIsXCJjc3MvYmFzZS9wYWdlcy9hcHAtdG9kb1wiLFwiY3NzL2Jhc2UvcGFnZXMvYXBwLWthbmJhblwiLFwiY3NzL2Jhc2UvcGFnZXMvYXBwLWludm9pY2VcIixcImNzcy9iYXNlL3BhZ2VzL2FwcC1pbnZvaWNlLXByaW50XCIsXCJjc3MvYmFzZS9wYWdlcy9hcHAtaW52b2ljZS1saXN0XCIsXCJjc3MvYmFzZS9wYWdlcy9hcHAtZmlsZS1tYW5hZ2VyXCIsXCJjc3MvYmFzZS9wYWdlcy9hcHAtZW1haWxcIixcImNzcy9iYXNlL3BhZ2VzL2FwcC1lY29tbWVyY2VcIixcImNzcy9iYXNlL3BhZ2VzL2FwcC1lY29tbWVyY2UtZGV0YWlsc1wiLFwiY3NzL2Jhc2UvcGFnZXMvYXBwLWNoYXRcIixcImNzcy9iYXNlL3BhZ2VzL2FwcC1jaGF0LWxpc3RcIixcImNzcy9iYXNlL3BhZ2VzL2FwcC1jYWxlbmRhclwiLFwiY3NzL2Jhc2UvcGx1Z2lucy91aS9jb21pbmctc29vblwiLFwiY3NzL2Jhc2UvcGx1Z2lucy9tYXBzL21hcC1sZWFmbGV0XCIsXCJjc3MvYmFzZS9wbHVnaW5zL2Zvcm1zL3BpY2tlcnMvZm9ybS1waWNrYWRhdGVcIixcImNzcy9iYXNlL3BsdWdpbnMvZm9ybXMvcGlja2Vycy9mb3JtLWZsYXQtcGlja3JcIixcImNzcy9iYXNlL3BsdWdpbnMvZm9ybXMvZm9ybS13aXphcmRcIixcImNzcy9iYXNlL3BsdWdpbnMvZm9ybXMvZm9ybS12YWxpZGF0aW9uXCIsXCJjc3MvYmFzZS9wbHVnaW5zL2Zvcm1zL2Zvcm0tcXVpbGwtZWRpdG9yXCIsXCJjc3MvYmFzZS9wbHVnaW5zL2Zvcm1zL2Zvcm0tbnVtYmVyLWlucHV0XCIsXCJjc3MvYmFzZS9wbHVnaW5zL2Zvcm1zL2Zvcm0tZmlsZS11cGxvYWRlclwiLFwiY3NzL2Jhc2UvcGx1Z2lucy9leHRlbnNpb25zL2V4dC1jb21wb25lbnQtdHJlZVwiLFwiY3NzL2Jhc2UvcGx1Z2lucy9leHRlbnNpb25zL2V4dC1jb21wb25lbnQtdG91clwiLFwiY3NzL2Jhc2UvcGx1Z2lucy9leHRlbnNpb25zL2V4dC1jb21wb25lbnQtdG9hc3RyXCIsXCJjc3MvYmFzZS9wbHVnaW5zL2V4dGVuc2lvbnMvZXh0LWNvbXBvbmVudC1zd2lwZXJcIixcImNzcy9iYXNlL3BsdWdpbnMvZXh0ZW5zaW9ucy9leHQtY29tcG9uZW50LXN3ZWV0LWFsZXJ0c1wiLFwiY3NzL2Jhc2UvcGx1Z2lucy9leHRlbnNpb25zL2V4dC1jb21wb25lbnQtc2xpZGVyc1wiLFwiY3NzL2Jhc2UvcGx1Z2lucy9leHRlbnNpb25zL2V4dC1jb21wb25lbnQtcmF0aW5nc1wiXSwgKCkgPT4gKF9fd2VicGFja19yZXF1aXJlX18oXCIuL3Jlc291cmNlcy9zY3NzL2Jhc2UvcGFnZXMvYXBwLWVjb21tZXJjZS1kZXRhaWxzLnNjc3NcIikpKVxuX193ZWJwYWNrX3JlcXVpcmVfXy5PKHVuZGVmaW5lZCwgW1wiY3NzL2Jhc2UvcGx1Z2lucy9leHRlbnNpb25zL2V4dC1jb21wb25lbnQtbWVkaWEtcGxheWVyXCIsXCJjc3MvYmFzZS9wbHVnaW5zL2V4dGVuc2lvbnMvZXh0LWNvbXBvbmVudC1kcmFnLWRyb3BcIixcImNzcy9iYXNlL3BsdWdpbnMvZXh0ZW5zaW9ucy9leHQtY29tcG9uZW50LWNvbnRleHQtbWVudVwiLFwiY3NzL2Jhc2UvcGx1Z2lucy9jaGFydHMvY2hhcnQtYXBleFwiLFwiY3NzL3N0eWxlXCIsXCJjc3Mvb3ZlcnJpZGVzXCIsXCJjc3MvY29yZVwiLFwiY3NzL2Jhc2UvdGhlbWVzL2RhcmstbGF5b3V0XCIsXCJjc3MvYmFzZS9jb3JlL21peGlucy90cmFuc2l0aW9uc1wiLFwiY3NzL2Jhc2UvY29yZS9taXhpbnMvbWFpbi1tZW51LW1peGluXCIsXCJjc3MvYmFzZS9jb3JlL21peGlucy9oZXgycmdiXCIsXCJjc3MvYmFzZS9jb3JlL21peGlucy9hbGVydFwiLFwiY3NzL2Jhc2UvY29yZS9tZW51L21lbnUtdHlwZXMvdmVydGljYWwtb3ZlcmxheS1tZW51XCIsXCJjc3MvYmFzZS9jb3JlL21lbnUvbWVudS10eXBlcy92ZXJ0aWNhbC1tZW51XCIsXCJjc3MvYmFzZS9jb3JlL21lbnUvbWVudS10eXBlcy9ob3Jpem9udGFsLW1lbnVcIixcImNzcy9iYXNlL2NvcmUvY29sb3JzL3BhbGV0dGUtdmFyaWFibGVzXCIsXCJjc3MvYmFzZS9jb3JlL2NvbG9ycy9wYWxldHRlLW5vdWlcIixcImNzcy9iYXNlL2NvcmUvY29sb3JzL3BhbGV0dGUtZ3JhZGllbnRcIixcImNzcy9iYXNlL3BhZ2VzL3VpLWZlYXRoZXJcIixcImNzcy9iYXNlL3BhZ2VzL3BhZ2UtcHJvZmlsZVwiLFwiY3NzL2Jhc2UvcGFnZXMvcGFnZS1wcmljaW5nXCIsXCJjc3MvYmFzZS9wYWdlcy9wYWdlLW1pc2NcIixcImNzcy9iYXNlL3BhZ2VzL3BhZ2Uta25vd2xlZGdlLWJhc2VcIixcImNzcy9iYXNlL3BhZ2VzL3BhZ2UtZmFxXCIsXCJjc3MvYmFzZS9wYWdlcy9wYWdlLWNvbWluZy1zb29uXCIsXCJjc3MvYmFzZS9wYWdlcy9wYWdlLWJsb2dcIixcImNzcy9iYXNlL3BhZ2VzL21vZGFsLWNyZWF0ZS1hcHBcIixcImNzcy9iYXNlL3BhZ2VzL2Rhc2hib2FyZC1lY29tbWVyY2VcIixcImNzcy9iYXNlL3BhZ2VzL2F1dGhlbnRpY2F0aW9uXCIsXCJjc3MvYmFzZS9wYWdlcy9hcHAtdG9kb1wiLFwiY3NzL2Jhc2UvcGFnZXMvYXBwLWthbmJhblwiLFwiY3NzL2Jhc2UvcGFnZXMvYXBwLWludm9pY2VcIixcImNzcy9iYXNlL3BhZ2VzL2FwcC1pbnZvaWNlLXByaW50XCIsXCJjc3MvYmFzZS9wYWdlcy9hcHAtaW52b2ljZS1saXN0XCIsXCJjc3MvYmFzZS9wYWdlcy9hcHAtZmlsZS1tYW5hZ2VyXCIsXCJjc3MvYmFzZS9wYWdlcy9hcHAtZW1haWxcIixcImNzcy9iYXNlL3BhZ2VzL2FwcC1lY29tbWVyY2VcIixcImNzcy9iYXNlL3BhZ2VzL2FwcC1lY29tbWVyY2UtZGV0YWlsc1wiLFwiY3NzL2Jhc2UvcGFnZXMvYXBwLWNoYXRcIixcImNzcy9iYXNlL3BhZ2VzL2FwcC1jaGF0LWxpc3RcIixcImNzcy9iYXNlL3BhZ2VzL2FwcC1jYWxlbmRhclwiLFwiY3NzL2Jhc2UvcGx1Z2lucy91aS9jb21pbmctc29vblwiLFwiY3NzL2Jhc2UvcGx1Z2lucy9tYXBzL21hcC1sZWFmbGV0XCIsXCJjc3MvYmFzZS9wbHVnaW5zL2Zvcm1zL3BpY2tlcnMvZm9ybS1waWNrYWRhdGVcIixcImNzcy9iYXNlL3BsdWdpbnMvZm9ybXMvcGlja2Vycy9mb3JtLWZsYXQtcGlja3JcIixcImNzcy9iYXNlL3BsdWdpbnMvZm9ybXMvZm9ybS13aXphcmRcIixcImNzcy9iYXNlL3BsdWdpbnMvZm9ybXMvZm9ybS12YWxpZGF0aW9uXCIsXCJjc3MvYmFzZS9wbHVnaW5zL2Zvcm1zL2Zvcm0tcXVpbGwtZWRpdG9yXCIsXCJjc3MvYmFzZS9wbHVnaW5zL2Zvcm1zL2Zvcm0tbnVtYmVyLWlucHV0XCIsXCJjc3MvYmFzZS9wbHVnaW5zL2Zvcm1zL2Zvcm0tZmlsZS11cGxvYWRlclwiLFwiY3NzL2Jhc2UvcGx1Z2lucy9leHRlbnNpb25zL2V4dC1jb21wb25lbnQtdHJlZVwiLFwiY3NzL2Jhc2UvcGx1Z2lucy9leHRlbnNpb25zL2V4dC1jb21wb25lbnQtdG91clwiLFwiY3NzL2Jhc2UvcGx1Z2lucy9leHRlbnNpb25zL2V4dC1jb21wb25lbnQtdG9hc3RyXCIsXCJjc3MvYmFzZS9wbHVnaW5zL2V4dGVuc2lvbnMvZXh0LWNvbXBvbmVudC1zd2lwZXJcIixcImNzcy9iYXNlL3BsdWdpbnMvZXh0ZW5zaW9ucy9leHQtY29tcG9uZW50LXN3ZWV0LWFsZXJ0c1wiLFwiY3NzL2Jhc2UvcGx1Z2lucy9leHRlbnNpb25zL2V4dC1jb21wb25lbnQtc2xpZGVyc1wiLFwiY3NzL2Jhc2UvcGx1Z2lucy9leHRlbnNpb25zL2V4dC1jb21wb25lbnQtcmF0aW5nc1wiXSwgKCkgPT4gKF9fd2VicGFja19yZXF1aXJlX18oXCIuL3Jlc291cmNlcy9zY3NzL2Jhc2UvcGFnZXMvYXBwLWVjb21tZXJjZS5zY3NzXCIpKSlcbl9fd2VicGFja19yZXF1aXJlX18uTyh1bmRlZmluZWQsIFtcImNzcy9iYXNlL3BsdWdpbnMvZXh0ZW5zaW9ucy9leHQtY29tcG9uZW50LW1lZGlhLXBsYXllclwiLFwiY3NzL2Jhc2UvcGx1Z2lucy9leHRlbnNpb25zL2V4dC1jb21wb25lbnQtZHJhZy1kcm9wXCIsXCJjc3MvYmFzZS9wbHVnaW5zL2V4dGVuc2lvbnMvZXh0LWNvbXBvbmVudC1jb250ZXh0LW1lbnVcIixcImNzcy9iYXNlL3BsdWdpbnMvY2hhcnRzL2NoYXJ0LWFwZXhcIixcImNzcy9zdHlsZVwiLFwiY3NzL292ZXJyaWRlc1wiLFwiY3NzL2NvcmVcIixcImNzcy9iYXNlL3RoZW1lcy9kYXJrLWxheW91dFwiLFwiY3NzL2Jhc2UvY29yZS9taXhpbnMvdHJhbnNpdGlvbnNcIixcImNzcy9iYXNlL2NvcmUvbWl4aW5zL21haW4tbWVudS1taXhpblwiLFwiY3NzL2Jhc2UvY29yZS9taXhpbnMvaGV4MnJnYlwiLFwiY3NzL2Jhc2UvY29yZS9taXhpbnMvYWxlcnRcIixcImNzcy9iYXNlL2NvcmUvbWVudS9tZW51LXR5cGVzL3ZlcnRpY2FsLW92ZXJsYXktbWVudVwiLFwiY3NzL2Jhc2UvY29yZS9tZW51L21lbnUtdHlwZXMvdmVydGljYWwtbWVudVwiLFwiY3NzL2Jhc2UvY29yZS9tZW51L21lbnUtdHlwZXMvaG9yaXpvbnRhbC1tZW51XCIsXCJjc3MvYmFzZS9jb3JlL2NvbG9ycy9wYWxldHRlLXZhcmlhYmxlc1wiLFwiY3NzL2Jhc2UvY29yZS9jb2xvcnMvcGFsZXR0ZS1ub3VpXCIsXCJjc3MvYmFzZS9jb3JlL2NvbG9ycy9wYWxldHRlLWdyYWRpZW50XCIsXCJjc3MvYmFzZS9wYWdlcy91aS1mZWF0aGVyXCIsXCJjc3MvYmFzZS9wYWdlcy9wYWdlLXByb2ZpbGVcIixcImNzcy9iYXNlL3BhZ2VzL3BhZ2UtcHJpY2luZ1wiLFwiY3NzL2Jhc2UvcGFnZXMvcGFnZS1taXNjXCIsXCJjc3MvYmFzZS9wYWdlcy9wYWdlLWtub3dsZWRnZS1iYXNlXCIsXCJjc3MvYmFzZS9wYWdlcy9wYWdlLWZhcVwiLFwiY3NzL2Jhc2UvcGFnZXMvcGFnZS1jb21pbmctc29vblwiLFwiY3NzL2Jhc2UvcGFnZXMvcGFnZS1ibG9nXCIsXCJjc3MvYmFzZS9wYWdlcy9tb2RhbC1jcmVhdGUtYXBwXCIsXCJjc3MvYmFzZS9wYWdlcy9kYXNoYm9hcmQtZWNvbW1lcmNlXCIsXCJjc3MvYmFzZS9wYWdlcy9hdXRoZW50aWNhdGlvblwiLFwiY3NzL2Jhc2UvcGFnZXMvYXBwLXRvZG9cIixcImNzcy9iYXNlL3BhZ2VzL2FwcC1rYW5iYW5cIixcImNzcy9iYXNlL3BhZ2VzL2FwcC1pbnZvaWNlXCIsXCJjc3MvYmFzZS9wYWdlcy9hcHAtaW52b2ljZS1wcmludFwiLFwiY3NzL2Jhc2UvcGFnZXMvYXBwLWludm9pY2UtbGlzdFwiLFwiY3NzL2Jhc2UvcGFnZXMvYXBwLWZpbGUtbWFuYWdlclwiLFwiY3NzL2Jhc2UvcGFnZXMvYXBwLWVtYWlsXCIsXCJjc3MvYmFzZS9wYWdlcy9hcHAtZWNvbW1lcmNlXCIsXCJjc3MvYmFzZS9wYWdlcy9hcHAtZWNvbW1lcmNlLWRldGFpbHNcIixcImNzcy9iYXNlL3BhZ2VzL2FwcC1jaGF0XCIsXCJjc3MvYmFzZS9wYWdlcy9hcHAtY2hhdC1saXN0XCIsXCJjc3MvYmFzZS9wYWdlcy9hcHAtY2FsZW5kYXJcIixcImNzcy9iYXNlL3BsdWdpbnMvdWkvY29taW5nLXNvb25cIixcImNzcy9iYXNlL3BsdWdpbnMvbWFwcy9tYXAtbGVhZmxldFwiLFwiY3NzL2Jhc2UvcGx1Z2lucy9mb3Jtcy9waWNrZXJzL2Zvcm0tcGlja2FkYXRlXCIsXCJjc3MvYmFzZS9wbHVnaW5zL2Zvcm1zL3BpY2tlcnMvZm9ybS1mbGF0LXBpY2tyXCIsXCJjc3MvYmFzZS9wbHVnaW5zL2Zvcm1zL2Zvcm0td2l6YXJkXCIsXCJjc3MvYmFzZS9wbHVnaW5zL2Zvcm1zL2Zvcm0tdmFsaWRhdGlvblwiLFwiY3NzL2Jhc2UvcGx1Z2lucy9mb3Jtcy9mb3JtLXF1aWxsLWVkaXRvclwiLFwiY3NzL2Jhc2UvcGx1Z2lucy9mb3Jtcy9mb3JtLW51bWJlci1pbnB1dFwiLFwiY3NzL2Jhc2UvcGx1Z2lucy9mb3Jtcy9mb3JtLWZpbGUtdXBsb2FkZXJcIixcImNzcy9iYXNlL3BsdWdpbnMvZXh0ZW5zaW9ucy9leHQtY29tcG9uZW50LXRyZWVcIixcImNzcy9iYXNlL3BsdWdpbnMvZXh0ZW5zaW9ucy9leHQtY29tcG9uZW50LXRvdXJcIixcImNzcy9iYXNlL3BsdWdpbnMvZXh0ZW5zaW9ucy9leHQtY29tcG9uZW50LXRvYXN0clwiLFwiY3NzL2Jhc2UvcGx1Z2lucy9leHRlbnNpb25zL2V4dC1jb21wb25lbnQtc3dpcGVyXCIsXCJjc3MvYmFzZS9wbHVnaW5zL2V4dGVuc2lvbnMvZXh0LWNvbXBvbmVudC1zd2VldC1hbGVydHNcIixcImNzcy9iYXNlL3BsdWdpbnMvZXh0ZW5zaW9ucy9leHQtY29tcG9uZW50LXNsaWRlcnNcIixcImNzcy9iYXNlL3BsdWdpbnMvZXh0ZW5zaW9ucy9leHQtY29tcG9uZW50LXJhdGluZ3NcIl0sICgpID0+IChfX3dlYnBhY2tfcmVxdWlyZV9fKFwiLi9yZXNvdXJjZXMvc2Nzcy9iYXNlL3BhZ2VzL2FwcC1lbWFpbC5zY3NzXCIpKSlcbl9fd2VicGFja19yZXF1aXJlX18uTyh1bmRlZmluZWQsIFtcImNzcy9iYXNlL3BsdWdpbnMvZXh0ZW5zaW9ucy9leHQtY29tcG9uZW50LW1lZGlhLXBsYXllclwiLFwiY3NzL2Jhc2UvcGx1Z2lucy9leHRlbnNpb25zL2V4dC1jb21wb25lbnQtZHJhZy1kcm9wXCIsXCJjc3MvYmFzZS9wbHVnaW5zL2V4dGVuc2lvbnMvZXh0LWNvbXBvbmVudC1jb250ZXh0LW1lbnVcIixcImNzcy9iYXNlL3BsdWdpbnMvY2hhcnRzL2NoYXJ0LWFwZXhcIixcImNzcy9zdHlsZVwiLFwiY3NzL292ZXJyaWRlc1wiLFwiY3NzL2NvcmVcIixcImNzcy9iYXNlL3RoZW1lcy9kYXJrLWxheW91dFwiLFwiY3NzL2Jhc2UvY29yZS9taXhpbnMvdHJhbnNpdGlvbnNcIixcImNzcy9iYXNlL2NvcmUvbWl4aW5zL21haW4tbWVudS1taXhpblwiLFwiY3NzL2Jhc2UvY29yZS9taXhpbnMvaGV4MnJnYlwiLFwiY3NzL2Jhc2UvY29yZS9taXhpbnMvYWxlcnRcIixcImNzcy9iYXNlL2NvcmUvbWVudS9tZW51LXR5cGVzL3ZlcnRpY2FsLW92ZXJsYXktbWVudVwiLFwiY3NzL2Jhc2UvY29yZS9tZW51L21lbnUtdHlwZXMvdmVydGljYWwtbWVudVwiLFwiY3NzL2Jhc2UvY29yZS9tZW51L21lbnUtdHlwZXMvaG9yaXpvbnRhbC1tZW51XCIsXCJjc3MvYmFzZS9jb3JlL2NvbG9ycy9wYWxldHRlLXZhcmlhYmxlc1wiLFwiY3NzL2Jhc2UvY29yZS9jb2xvcnMvcGFsZXR0ZS1ub3VpXCIsXCJjc3MvYmFzZS9jb3JlL2NvbG9ycy9wYWxldHRlLWdyYWRpZW50XCIsXCJjc3MvYmFzZS9wYWdlcy91aS1mZWF0aGVyXCIsXCJjc3MvYmFzZS9wYWdlcy9wYWdlLXByb2ZpbGVcIixcImNzcy9iYXNlL3BhZ2VzL3BhZ2UtcHJpY2luZ1wiLFwiY3NzL2Jhc2UvcGFnZXMvcGFnZS1taXNjXCIsXCJjc3MvYmFzZS9wYWdlcy9wYWdlLWtub3dsZWRnZS1iYXNlXCIsXCJjc3MvYmFzZS9wYWdlcy9wYWdlLWZhcVwiLFwiY3NzL2Jhc2UvcGFnZXMvcGFnZS1jb21pbmctc29vblwiLFwiY3NzL2Jhc2UvcGFnZXMvcGFnZS1ibG9nXCIsXCJjc3MvYmFzZS9wYWdlcy9tb2RhbC1jcmVhdGUtYXBwXCIsXCJjc3MvYmFzZS9wYWdlcy9kYXNoYm9hcmQtZWNvbW1lcmNlXCIsXCJjc3MvYmFzZS9wYWdlcy9hdXRoZW50aWNhdGlvblwiLFwiY3NzL2Jhc2UvcGFnZXMvYXBwLXRvZG9cIixcImNzcy9iYXNlL3BhZ2VzL2FwcC1rYW5iYW5cIixcImNzcy9iYXNlL3BhZ2VzL2FwcC1pbnZvaWNlXCIsXCJjc3MvYmFzZS9wYWdlcy9hcHAtaW52b2ljZS1wcmludFwiLFwiY3NzL2Jhc2UvcGFnZXMvYXBwLWludm9pY2UtbGlzdFwiLFwiY3NzL2Jhc2UvcGFnZXMvYXBwLWZpbGUtbWFuYWdlclwiLFwiY3NzL2Jhc2UvcGFnZXMvYXBwLWVtYWlsXCIsXCJjc3MvYmFzZS9wYWdlcy9hcHAtZWNvbW1lcmNlXCIsXCJjc3MvYmFzZS9wYWdlcy9hcHAtZWNvbW1lcmNlLWRldGFpbHNcIixcImNzcy9iYXNlL3BhZ2VzL2FwcC1jaGF0XCIsXCJjc3MvYmFzZS9wYWdlcy9hcHAtY2hhdC1saXN0XCIsXCJjc3MvYmFzZS9wYWdlcy9hcHAtY2FsZW5kYXJcIixcImNzcy9iYXNlL3BsdWdpbnMvdWkvY29taW5nLXNvb25cIixcImNzcy9iYXNlL3BsdWdpbnMvbWFwcy9tYXAtbGVhZmxldFwiLFwiY3NzL2Jhc2UvcGx1Z2lucy9mb3Jtcy9waWNrZXJzL2Zvcm0tcGlja2FkYXRlXCIsXCJjc3MvYmFzZS9wbHVnaW5zL2Zvcm1zL3BpY2tlcnMvZm9ybS1mbGF0LXBpY2tyXCIsXCJjc3MvYmFzZS9wbHVnaW5zL2Zvcm1zL2Zvcm0td2l6YXJkXCIsXCJjc3MvYmFzZS9wbHVnaW5zL2Zvcm1zL2Zvcm0tdmFsaWRhdGlvblwiLFwiY3NzL2Jhc2UvcGx1Z2lucy9mb3Jtcy9mb3JtLXF1aWxsLWVkaXRvclwiLFwiY3NzL2Jhc2UvcGx1Z2lucy9mb3Jtcy9mb3JtLW51bWJlci1pbnB1dFwiLFwiY3NzL2Jhc2UvcGx1Z2lucy9mb3Jtcy9mb3JtLWZpbGUtdXBsb2FkZXJcIixcImNzcy9iYXNlL3BsdWdpbnMvZXh0ZW5zaW9ucy9leHQtY29tcG9uZW50LXRyZWVcIixcImNzcy9iYXNlL3BsdWdpbnMvZXh0ZW5zaW9ucy9leHQtY29tcG9uZW50LXRvdXJcIixcImNzcy9iYXNlL3BsdWdpbnMvZXh0ZW5zaW9ucy9leHQtY29tcG9uZW50LXRvYXN0clwiLFwiY3NzL2Jhc2UvcGx1Z2lucy9leHRlbnNpb25zL2V4dC1jb21wb25lbnQtc3dpcGVyXCIsXCJjc3MvYmFzZS9wbHVnaW5zL2V4dGVuc2lvbnMvZXh0LWNvbXBvbmVudC1zd2VldC1hbGVydHNcIixcImNzcy9iYXNlL3BsdWdpbnMvZXh0ZW5zaW9ucy9leHQtY29tcG9uZW50LXNsaWRlcnNcIixcImNzcy9iYXNlL3BsdWdpbnMvZXh0ZW5zaW9ucy9leHQtY29tcG9uZW50LXJhdGluZ3NcIl0sICgpID0+IChfX3dlYnBhY2tfcmVxdWlyZV9fKFwiLi9yZXNvdXJjZXMvc2Nzcy9iYXNlL3BhZ2VzL2FwcC1maWxlLW1hbmFnZXIuc2Nzc1wiKSkpXG5fX3dlYnBhY2tfcmVxdWlyZV9fLk8odW5kZWZpbmVkLCBbXCJjc3MvYmFzZS9wbHVnaW5zL2V4dGVuc2lvbnMvZXh0LWNvbXBvbmVudC1tZWRpYS1wbGF5ZXJcIixcImNzcy9iYXNlL3BsdWdpbnMvZXh0ZW5zaW9ucy9leHQtY29tcG9uZW50LWRyYWctZHJvcFwiLFwiY3NzL2Jhc2UvcGx1Z2lucy9leHRlbnNpb25zL2V4dC1jb21wb25lbnQtY29udGV4dC1tZW51XCIsXCJjc3MvYmFzZS9wbHVnaW5zL2NoYXJ0cy9jaGFydC1hcGV4XCIsXCJjc3Mvc3R5bGVcIixcImNzcy9vdmVycmlkZXNcIixcImNzcy9jb3JlXCIsXCJjc3MvYmFzZS90aGVtZXMvZGFyay1sYXlvdXRcIixcImNzcy9iYXNlL2NvcmUvbWl4aW5zL3RyYW5zaXRpb25zXCIsXCJjc3MvYmFzZS9jb3JlL21peGlucy9tYWluLW1lbnUtbWl4aW5cIixcImNzcy9iYXNlL2NvcmUvbWl4aW5zL2hleDJyZ2JcIixcImNzcy9iYXNlL2NvcmUvbWl4aW5zL2FsZXJ0XCIsXCJjc3MvYmFzZS9jb3JlL21lbnUvbWVudS10eXBlcy92ZXJ0aWNhbC1vdmVybGF5LW1lbnVcIixcImNzcy9iYXNlL2NvcmUvbWVudS9tZW51LXR5cGVzL3ZlcnRpY2FsLW1lbnVcIixcImNzcy9iYXNlL2NvcmUvbWVudS9tZW51LXR5cGVzL2hvcml6b250YWwtbWVudVwiLFwiY3NzL2Jhc2UvY29yZS9jb2xvcnMvcGFsZXR0ZS12YXJpYWJsZXNcIixcImNzcy9iYXNlL2NvcmUvY29sb3JzL3BhbGV0dGUtbm91aVwiLFwiY3NzL2Jhc2UvY29yZS9jb2xvcnMvcGFsZXR0ZS1ncmFkaWVudFwiLFwiY3NzL2Jhc2UvcGFnZXMvdWktZmVhdGhlclwiLFwiY3NzL2Jhc2UvcGFnZXMvcGFnZS1wcm9maWxlXCIsXCJjc3MvYmFzZS9wYWdlcy9wYWdlLXByaWNpbmdcIixcImNzcy9iYXNlL3BhZ2VzL3BhZ2UtbWlzY1wiLFwiY3NzL2Jhc2UvcGFnZXMvcGFnZS1rbm93bGVkZ2UtYmFzZVwiLFwiY3NzL2Jhc2UvcGFnZXMvcGFnZS1mYXFcIixcImNzcy9iYXNlL3BhZ2VzL3BhZ2UtY29taW5nLXNvb25cIixcImNzcy9iYXNlL3BhZ2VzL3BhZ2UtYmxvZ1wiLFwiY3NzL2Jhc2UvcGFnZXMvbW9kYWwtY3JlYXRlLWFwcFwiLFwiY3NzL2Jhc2UvcGFnZXMvZGFzaGJvYXJkLWVjb21tZXJjZVwiLFwiY3NzL2Jhc2UvcGFnZXMvYXV0aGVudGljYXRpb25cIixcImNzcy9iYXNlL3BhZ2VzL2FwcC10b2RvXCIsXCJjc3MvYmFzZS9wYWdlcy9hcHAta2FuYmFuXCIsXCJjc3MvYmFzZS9wYWdlcy9hcHAtaW52b2ljZVwiLFwiY3NzL2Jhc2UvcGFnZXMvYXBwLWludm9pY2UtcHJpbnRcIixcImNzcy9iYXNlL3BhZ2VzL2FwcC1pbnZvaWNlLWxpc3RcIixcImNzcy9iYXNlL3BhZ2VzL2FwcC1maWxlLW1hbmFnZXJcIixcImNzcy9iYXNlL3BhZ2VzL2FwcC1lbWFpbFwiLFwiY3NzL2Jhc2UvcGFnZXMvYXBwLWVjb21tZXJjZVwiLFwiY3NzL2Jhc2UvcGFnZXMvYXBwLWVjb21tZXJjZS1kZXRhaWxzXCIsXCJjc3MvYmFzZS9wYWdlcy9hcHAtY2hhdFwiLFwiY3NzL2Jhc2UvcGFnZXMvYXBwLWNoYXQtbGlzdFwiLFwiY3NzL2Jhc2UvcGFnZXMvYXBwLWNhbGVuZGFyXCIsXCJjc3MvYmFzZS9wbHVnaW5zL3VpL2NvbWluZy1zb29uXCIsXCJjc3MvYmFzZS9wbHVnaW5zL21hcHMvbWFwLWxlYWZsZXRcIixcImNzcy9iYXNlL3BsdWdpbnMvZm9ybXMvcGlja2Vycy9mb3JtLXBpY2thZGF0ZVwiLFwiY3NzL2Jhc2UvcGx1Z2lucy9mb3Jtcy9waWNrZXJzL2Zvcm0tZmxhdC1waWNrclwiLFwiY3NzL2Jhc2UvcGx1Z2lucy9mb3Jtcy9mb3JtLXdpemFyZFwiLFwiY3NzL2Jhc2UvcGx1Z2lucy9mb3Jtcy9mb3JtLXZhbGlkYXRpb25cIixcImNzcy9iYXNlL3BsdWdpbnMvZm9ybXMvZm9ybS1xdWlsbC1lZGl0b3JcIixcImNzcy9iYXNlL3BsdWdpbnMvZm9ybXMvZm9ybS1udW1iZXItaW5wdXRcIixcImNzcy9iYXNlL3BsdWdpbnMvZm9ybXMvZm9ybS1maWxlLXVwbG9hZGVyXCIsXCJjc3MvYmFzZS9wbHVnaW5zL2V4dGVuc2lvbnMvZXh0LWNvbXBvbmVudC10cmVlXCIsXCJjc3MvYmFzZS9wbHVnaW5zL2V4dGVuc2lvbnMvZXh0LWNvbXBvbmVudC10b3VyXCIsXCJjc3MvYmFzZS9wbHVnaW5zL2V4dGVuc2lvbnMvZXh0LWNvbXBvbmVudC10b2FzdHJcIixcImNzcy9iYXNlL3BsdWdpbnMvZXh0ZW5zaW9ucy9leHQtY29tcG9uZW50LXN3aXBlclwiLFwiY3NzL2Jhc2UvcGx1Z2lucy9leHRlbnNpb25zL2V4dC1jb21wb25lbnQtc3dlZXQtYWxlcnRzXCIsXCJjc3MvYmFzZS9wbHVnaW5zL2V4dGVuc2lvbnMvZXh0LWNvbXBvbmVudC1zbGlkZXJzXCIsXCJjc3MvYmFzZS9wbHVnaW5zL2V4dGVuc2lvbnMvZXh0LWNvbXBvbmVudC1yYXRpbmdzXCJdLCAoKSA9PiAoX193ZWJwYWNrX3JlcXVpcmVfXyhcIi4vcmVzb3VyY2VzL3Njc3MvYmFzZS9wYWdlcy9hcHAtaW52b2ljZS1saXN0LnNjc3NcIikpKVxuX193ZWJwYWNrX3JlcXVpcmVfXy5PKHVuZGVmaW5lZCwgW1wiY3NzL2Jhc2UvcGx1Z2lucy9leHRlbnNpb25zL2V4dC1jb21wb25lbnQtbWVkaWEtcGxheWVyXCIsXCJjc3MvYmFzZS9wbHVnaW5zL2V4dGVuc2lvbnMvZXh0LWNvbXBvbmVudC1kcmFnLWRyb3BcIixcImNzcy9iYXNlL3BsdWdpbnMvZXh0ZW5zaW9ucy9leHQtY29tcG9uZW50LWNvbnRleHQtbWVudVwiLFwiY3NzL2Jhc2UvcGx1Z2lucy9jaGFydHMvY2hhcnQtYXBleFwiLFwiY3NzL3N0eWxlXCIsXCJjc3Mvb3ZlcnJpZGVzXCIsXCJjc3MvY29yZVwiLFwiY3NzL2Jhc2UvdGhlbWVzL2RhcmstbGF5b3V0XCIsXCJjc3MvYmFzZS9jb3JlL21peGlucy90cmFuc2l0aW9uc1wiLFwiY3NzL2Jhc2UvY29yZS9taXhpbnMvbWFpbi1tZW51LW1peGluXCIsXCJjc3MvYmFzZS9jb3JlL21peGlucy9oZXgycmdiXCIsXCJjc3MvYmFzZS9jb3JlL21peGlucy9hbGVydFwiLFwiY3NzL2Jhc2UvY29yZS9tZW51L21lbnUtdHlwZXMvdmVydGljYWwtb3ZlcmxheS1tZW51XCIsXCJjc3MvYmFzZS9jb3JlL21lbnUvbWVudS10eXBlcy92ZXJ0aWNhbC1tZW51XCIsXCJjc3MvYmFzZS9jb3JlL21lbnUvbWVudS10eXBlcy9ob3Jpem9udGFsLW1lbnVcIixcImNzcy9iYXNlL2NvcmUvY29sb3JzL3BhbGV0dGUtdmFyaWFibGVzXCIsXCJjc3MvYmFzZS9jb3JlL2NvbG9ycy9wYWxldHRlLW5vdWlcIixcImNzcy9iYXNlL2NvcmUvY29sb3JzL3BhbGV0dGUtZ3JhZGllbnRcIixcImNzcy9iYXNlL3BhZ2VzL3VpLWZlYXRoZXJcIixcImNzcy9iYXNlL3BhZ2VzL3BhZ2UtcHJvZmlsZVwiLFwiY3NzL2Jhc2UvcGFnZXMvcGFnZS1wcmljaW5nXCIsXCJjc3MvYmFzZS9wYWdlcy9wYWdlLW1pc2NcIixcImNzcy9iYXNlL3BhZ2VzL3BhZ2Uta25vd2xlZGdlLWJhc2VcIixcImNzcy9iYXNlL3BhZ2VzL3BhZ2UtZmFxXCIsXCJjc3MvYmFzZS9wYWdlcy9wYWdlLWNvbWluZy1zb29uXCIsXCJjc3MvYmFzZS9wYWdlcy9wYWdlLWJsb2dcIixcImNzcy9iYXNlL3BhZ2VzL21vZGFsLWNyZWF0ZS1hcHBcIixcImNzcy9iYXNlL3BhZ2VzL2Rhc2hib2FyZC1lY29tbWVyY2VcIixcImNzcy9iYXNlL3BhZ2VzL2F1dGhlbnRpY2F0aW9uXCIsXCJjc3MvYmFzZS9wYWdlcy9hcHAtdG9kb1wiLFwiY3NzL2Jhc2UvcGFnZXMvYXBwLWthbmJhblwiLFwiY3NzL2Jhc2UvcGFnZXMvYXBwLWludm9pY2VcIixcImNzcy9iYXNlL3BhZ2VzL2FwcC1pbnZvaWNlLXByaW50XCIsXCJjc3MvYmFzZS9wYWdlcy9hcHAtaW52b2ljZS1saXN0XCIsXCJjc3MvYmFzZS9wYWdlcy9hcHAtZmlsZS1tYW5hZ2VyXCIsXCJjc3MvYmFzZS9wYWdlcy9hcHAtZW1haWxcIixcImNzcy9iYXNlL3BhZ2VzL2FwcC1lY29tbWVyY2VcIixcImNzcy9iYXNlL3BhZ2VzL2FwcC1lY29tbWVyY2UtZGV0YWlsc1wiLFwiY3NzL2Jhc2UvcGFnZXMvYXBwLWNoYXRcIixcImNzcy9iYXNlL3BhZ2VzL2FwcC1jaGF0LWxpc3RcIixcImNzcy9iYXNlL3BhZ2VzL2FwcC1jYWxlbmRhclwiLFwiY3NzL2Jhc2UvcGx1Z2lucy91aS9jb21pbmctc29vblwiLFwiY3NzL2Jhc2UvcGx1Z2lucy9tYXBzL21hcC1sZWFmbGV0XCIsXCJjc3MvYmFzZS9wbHVnaW5zL2Zvcm1zL3BpY2tlcnMvZm9ybS1waWNrYWRhdGVcIixcImNzcy9iYXNlL3BsdWdpbnMvZm9ybXMvcGlja2Vycy9mb3JtLWZsYXQtcGlja3JcIixcImNzcy9iYXNlL3BsdWdpbnMvZm9ybXMvZm9ybS13aXphcmRcIixcImNzcy9iYXNlL3BsdWdpbnMvZm9ybXMvZm9ybS12YWxpZGF0aW9uXCIsXCJjc3MvYmFzZS9wbHVnaW5zL2Zvcm1zL2Zvcm0tcXVpbGwtZWRpdG9yXCIsXCJjc3MvYmFzZS9wbHVnaW5zL2Zvcm1zL2Zvcm0tbnVtYmVyLWlucHV0XCIsXCJjc3MvYmFzZS9wbHVnaW5zL2Zvcm1zL2Zvcm0tZmlsZS11cGxvYWRlclwiLFwiY3NzL2Jhc2UvcGx1Z2lucy9leHRlbnNpb25zL2V4dC1jb21wb25lbnQtdHJlZVwiLFwiY3NzL2Jhc2UvcGx1Z2lucy9leHRlbnNpb25zL2V4dC1jb21wb25lbnQtdG91clwiLFwiY3NzL2Jhc2UvcGx1Z2lucy9leHRlbnNpb25zL2V4dC1jb21wb25lbnQtdG9hc3RyXCIsXCJjc3MvYmFzZS9wbHVnaW5zL2V4dGVuc2lvbnMvZXh0LWNvbXBvbmVudC1zd2lwZXJcIixcImNzcy9iYXNlL3BsdWdpbnMvZXh0ZW5zaW9ucy9leHQtY29tcG9uZW50LXN3ZWV0LWFsZXJ0c1wiLFwiY3NzL2Jhc2UvcGx1Z2lucy9leHRlbnNpb25zL2V4dC1jb21wb25lbnQtc2xpZGVyc1wiLFwiY3NzL2Jhc2UvcGx1Z2lucy9leHRlbnNpb25zL2V4dC1jb21wb25lbnQtcmF0aW5nc1wiXSwgKCkgPT4gKF9fd2VicGFja19yZXF1aXJlX18oXCIuL3Jlc291cmNlcy9zY3NzL2Jhc2UvcGFnZXMvYXBwLWludm9pY2UtcHJpbnQuc2Nzc1wiKSkpXG5fX3dlYnBhY2tfcmVxdWlyZV9fLk8odW5kZWZpbmVkLCBbXCJjc3MvYmFzZS9wbHVnaW5zL2V4dGVuc2lvbnMvZXh0LWNvbXBvbmVudC1tZWRpYS1wbGF5ZXJcIixcImNzcy9iYXNlL3BsdWdpbnMvZXh0ZW5zaW9ucy9leHQtY29tcG9uZW50LWRyYWctZHJvcFwiLFwiY3NzL2Jhc2UvcGx1Z2lucy9leHRlbnNpb25zL2V4dC1jb21wb25lbnQtY29udGV4dC1tZW51XCIsXCJjc3MvYmFzZS9wbHVnaW5zL2NoYXJ0cy9jaGFydC1hcGV4XCIsXCJjc3Mvc3R5bGVcIixcImNzcy9vdmVycmlkZXNcIixcImNzcy9jb3JlXCIsXCJjc3MvYmFzZS90aGVtZXMvZGFyay1sYXlvdXRcIixcImNzcy9iYXNlL2NvcmUvbWl4aW5zL3RyYW5zaXRpb25zXCIsXCJjc3MvYmFzZS9jb3JlL21peGlucy9tYWluLW1lbnUtbWl4aW5cIixcImNzcy9iYXNlL2NvcmUvbWl4aW5zL2hleDJyZ2JcIixcImNzcy9iYXNlL2NvcmUvbWl4aW5zL2FsZXJ0XCIsXCJjc3MvYmFzZS9jb3JlL21lbnUvbWVudS10eXBlcy92ZXJ0aWNhbC1vdmVybGF5LW1lbnVcIixcImNzcy9iYXNlL2NvcmUvbWVudS9tZW51LXR5cGVzL3ZlcnRpY2FsLW1lbnVcIixcImNzcy9iYXNlL2NvcmUvbWVudS9tZW51LXR5cGVzL2hvcml6b250YWwtbWVudVwiLFwiY3NzL2Jhc2UvY29yZS9jb2xvcnMvcGFsZXR0ZS12YXJpYWJsZXNcIixcImNzcy9iYXNlL2NvcmUvY29sb3JzL3BhbGV0dGUtbm91aVwiLFwiY3NzL2Jhc2UvY29yZS9jb2xvcnMvcGFsZXR0ZS1ncmFkaWVudFwiLFwiY3NzL2Jhc2UvcGFnZXMvdWktZmVhdGhlclwiLFwiY3NzL2Jhc2UvcGFnZXMvcGFnZS1wcm9maWxlXCIsXCJjc3MvYmFzZS9wYWdlcy9wYWdlLXByaWNpbmdcIixcImNzcy9iYXNlL3BhZ2VzL3BhZ2UtbWlzY1wiLFwiY3NzL2Jhc2UvcGFnZXMvcGFnZS1rbm93bGVkZ2UtYmFzZVwiLFwiY3NzL2Jhc2UvcGFnZXMvcGFnZS1mYXFcIixcImNzcy9iYXNlL3BhZ2VzL3BhZ2UtY29taW5nLXNvb25cIixcImNzcy9iYXNlL3BhZ2VzL3BhZ2UtYmxvZ1wiLFwiY3NzL2Jhc2UvcGFnZXMvbW9kYWwtY3JlYXRlLWFwcFwiLFwiY3NzL2Jhc2UvcGFnZXMvZGFzaGJvYXJkLWVjb21tZXJjZVwiLFwiY3NzL2Jhc2UvcGFnZXMvYXV0aGVudGljYXRpb25cIixcImNzcy9iYXNlL3BhZ2VzL2FwcC10b2RvXCIsXCJjc3MvYmFzZS9wYWdlcy9hcHAta2FuYmFuXCIsXCJjc3MvYmFzZS9wYWdlcy9hcHAtaW52b2ljZVwiLFwiY3NzL2Jhc2UvcGFnZXMvYXBwLWludm9pY2UtcHJpbnRcIixcImNzcy9iYXNlL3BhZ2VzL2FwcC1pbnZvaWNlLWxpc3RcIixcImNzcy9iYXNlL3BhZ2VzL2FwcC1maWxlLW1hbmFnZXJcIixcImNzcy9iYXNlL3BhZ2VzL2FwcC1lbWFpbFwiLFwiY3NzL2Jhc2UvcGFnZXMvYXBwLWVjb21tZXJjZVwiLFwiY3NzL2Jhc2UvcGFnZXMvYXBwLWVjb21tZXJjZS1kZXRhaWxzXCIsXCJjc3MvYmFzZS9wYWdlcy9hcHAtY2hhdFwiLFwiY3NzL2Jhc2UvcGFnZXMvYXBwLWNoYXQtbGlzdFwiLFwiY3NzL2Jhc2UvcGFnZXMvYXBwLWNhbGVuZGFyXCIsXCJjc3MvYmFzZS9wbHVnaW5zL3VpL2NvbWluZy1zb29uXCIsXCJjc3MvYmFzZS9wbHVnaW5zL21hcHMvbWFwLWxlYWZsZXRcIixcImNzcy9iYXNlL3BsdWdpbnMvZm9ybXMvcGlja2Vycy9mb3JtLXBpY2thZGF0ZVwiLFwiY3NzL2Jhc2UvcGx1Z2lucy9mb3Jtcy9waWNrZXJzL2Zvcm0tZmxhdC1waWNrclwiLFwiY3NzL2Jhc2UvcGx1Z2lucy9mb3Jtcy9mb3JtLXdpemFyZFwiLFwiY3NzL2Jhc2UvcGx1Z2lucy9mb3Jtcy9mb3JtLXZhbGlkYXRpb25cIixcImNzcy9iYXNlL3BsdWdpbnMvZm9ybXMvZm9ybS1xdWlsbC1lZGl0b3JcIixcImNzcy9iYXNlL3BsdWdpbnMvZm9ybXMvZm9ybS1udW1iZXItaW5wdXRcIixcImNzcy9iYXNlL3BsdWdpbnMvZm9ybXMvZm9ybS1maWxlLXVwbG9hZGVyXCIsXCJjc3MvYmFzZS9wbHVnaW5zL2V4dGVuc2lvbnMvZXh0LWNvbXBvbmVudC10cmVlXCIsXCJjc3MvYmFzZS9wbHVnaW5zL2V4dGVuc2lvbnMvZXh0LWNvbXBvbmVudC10b3VyXCIsXCJjc3MvYmFzZS9wbHVnaW5zL2V4dGVuc2lvbnMvZXh0LWNvbXBvbmVudC10b2FzdHJcIixcImNzcy9iYXNlL3BsdWdpbnMvZXh0ZW5zaW9ucy9leHQtY29tcG9uZW50LXN3aXBlclwiLFwiY3NzL2Jhc2UvcGx1Z2lucy9leHRlbnNpb25zL2V4dC1jb21wb25lbnQtc3dlZXQtYWxlcnRzXCIsXCJjc3MvYmFzZS9wbHVnaW5zL2V4dGVuc2lvbnMvZXh0LWNvbXBvbmVudC1zbGlkZXJzXCIsXCJjc3MvYmFzZS9wbHVnaW5zL2V4dGVuc2lvbnMvZXh0LWNvbXBvbmVudC1yYXRpbmdzXCJdLCAoKSA9PiAoX193ZWJwYWNrX3JlcXVpcmVfXyhcIi4vcmVzb3VyY2VzL3Njc3MvYmFzZS9wYWdlcy9hcHAtaW52b2ljZS5zY3NzXCIpKSlcbl9fd2VicGFja19yZXF1aXJlX18uTyh1bmRlZmluZWQsIFtcImNzcy9iYXNlL3BsdWdpbnMvZXh0ZW5zaW9ucy9leHQtY29tcG9uZW50LW1lZGlhLXBsYXllclwiLFwiY3NzL2Jhc2UvcGx1Z2lucy9leHRlbnNpb25zL2V4dC1jb21wb25lbnQtZHJhZy1kcm9wXCIsXCJjc3MvYmFzZS9wbHVnaW5zL2V4dGVuc2lvbnMvZXh0LWNvbXBvbmVudC1jb250ZXh0LW1lbnVcIixcImNzcy9iYXNlL3BsdWdpbnMvY2hhcnRzL2NoYXJ0LWFwZXhcIixcImNzcy9zdHlsZVwiLFwiY3NzL292ZXJyaWRlc1wiLFwiY3NzL2NvcmVcIixcImNzcy9iYXNlL3RoZW1lcy9kYXJrLWxheW91dFwiLFwiY3NzL2Jhc2UvY29yZS9taXhpbnMvdHJhbnNpdGlvbnNcIixcImNzcy9iYXNlL2NvcmUvbWl4aW5zL21haW4tbWVudS1taXhpblwiLFwiY3NzL2Jhc2UvY29yZS9taXhpbnMvaGV4MnJnYlwiLFwiY3NzL2Jhc2UvY29yZS9taXhpbnMvYWxlcnRcIixcImNzcy9iYXNlL2NvcmUvbWVudS9tZW51LXR5cGVzL3ZlcnRpY2FsLW92ZXJsYXktbWVudVwiLFwiY3NzL2Jhc2UvY29yZS9tZW51L21lbnUtdHlwZXMvdmVydGljYWwtbWVudVwiLFwiY3NzL2Jhc2UvY29yZS9tZW51L21lbnUtdHlwZXMvaG9yaXpvbnRhbC1tZW51XCIsXCJjc3MvYmFzZS9jb3JlL2NvbG9ycy9wYWxldHRlLXZhcmlhYmxlc1wiLFwiY3NzL2Jhc2UvY29yZS9jb2xvcnMvcGFsZXR0ZS1ub3VpXCIsXCJjc3MvYmFzZS9jb3JlL2NvbG9ycy9wYWxldHRlLWdyYWRpZW50XCIsXCJjc3MvYmFzZS9wYWdlcy91aS1mZWF0aGVyXCIsXCJjc3MvYmFzZS9wYWdlcy9wYWdlLXByb2ZpbGVcIixcImNzcy9iYXNlL3BhZ2VzL3BhZ2UtcHJpY2luZ1wiLFwiY3NzL2Jhc2UvcGFnZXMvcGFnZS1taXNjXCIsXCJjc3MvYmFzZS9wYWdlcy9wYWdlLWtub3dsZWRnZS1iYXNlXCIsXCJjc3MvYmFzZS9wYWdlcy9wYWdlLWZhcVwiLFwiY3NzL2Jhc2UvcGFnZXMvcGFnZS1jb21pbmctc29vblwiLFwiY3NzL2Jhc2UvcGFnZXMvcGFnZS1ibG9nXCIsXCJjc3MvYmFzZS9wYWdlcy9tb2RhbC1jcmVhdGUtYXBwXCIsXCJjc3MvYmFzZS9wYWdlcy9kYXNoYm9hcmQtZWNvbW1lcmNlXCIsXCJjc3MvYmFzZS9wYWdlcy9hdXRoZW50aWNhdGlvblwiLFwiY3NzL2Jhc2UvcGFnZXMvYXBwLXRvZG9cIixcImNzcy9iYXNlL3BhZ2VzL2FwcC1rYW5iYW5cIixcImNzcy9iYXNlL3BhZ2VzL2FwcC1pbnZvaWNlXCIsXCJjc3MvYmFzZS9wYWdlcy9hcHAtaW52b2ljZS1wcmludFwiLFwiY3NzL2Jhc2UvcGFnZXMvYXBwLWludm9pY2UtbGlzdFwiLFwiY3NzL2Jhc2UvcGFnZXMvYXBwLWZpbGUtbWFuYWdlclwiLFwiY3NzL2Jhc2UvcGFnZXMvYXBwLWVtYWlsXCIsXCJjc3MvYmFzZS9wYWdlcy9hcHAtZWNvbW1lcmNlXCIsXCJjc3MvYmFzZS9wYWdlcy9hcHAtZWNvbW1lcmNlLWRldGFpbHNcIixcImNzcy9iYXNlL3BhZ2VzL2FwcC1jaGF0XCIsXCJjc3MvYmFzZS9wYWdlcy9hcHAtY2hhdC1saXN0XCIsXCJjc3MvYmFzZS9wYWdlcy9hcHAtY2FsZW5kYXJcIixcImNzcy9iYXNlL3BsdWdpbnMvdWkvY29taW5nLXNvb25cIixcImNzcy9iYXNlL3BsdWdpbnMvbWFwcy9tYXAtbGVhZmxldFwiLFwiY3NzL2Jhc2UvcGx1Z2lucy9mb3Jtcy9waWNrZXJzL2Zvcm0tcGlja2FkYXRlXCIsXCJjc3MvYmFzZS9wbHVnaW5zL2Zvcm1zL3BpY2tlcnMvZm9ybS1mbGF0LXBpY2tyXCIsXCJjc3MvYmFzZS9wbHVnaW5zL2Zvcm1zL2Zvcm0td2l6YXJkXCIsXCJjc3MvYmFzZS9wbHVnaW5zL2Zvcm1zL2Zvcm0tdmFsaWRhdGlvblwiLFwiY3NzL2Jhc2UvcGx1Z2lucy9mb3Jtcy9mb3JtLXF1aWxsLWVkaXRvclwiLFwiY3NzL2Jhc2UvcGx1Z2lucy9mb3Jtcy9mb3JtLW51bWJlci1pbnB1dFwiLFwiY3NzL2Jhc2UvcGx1Z2lucy9mb3Jtcy9mb3JtLWZpbGUtdXBsb2FkZXJcIixcImNzcy9iYXNlL3BsdWdpbnMvZXh0ZW5zaW9ucy9leHQtY29tcG9uZW50LXRyZWVcIixcImNzcy9iYXNlL3BsdWdpbnMvZXh0ZW5zaW9ucy9leHQtY29tcG9uZW50LXRvdXJcIixcImNzcy9iYXNlL3BsdWdpbnMvZXh0ZW5zaW9ucy9leHQtY29tcG9uZW50LXRvYXN0clwiLFwiY3NzL2Jhc2UvcGx1Z2lucy9leHRlbnNpb25zL2V4dC1jb21wb25lbnQtc3dpcGVyXCIsXCJjc3MvYmFzZS9wbHVnaW5zL2V4dGVuc2lvbnMvZXh0LWNvbXBvbmVudC1zd2VldC1hbGVydHNcIixcImNzcy9iYXNlL3BsdWdpbnMvZXh0ZW5zaW9ucy9leHQtY29tcG9uZW50LXNsaWRlcnNcIixcImNzcy9iYXNlL3BsdWdpbnMvZXh0ZW5zaW9ucy9leHQtY29tcG9uZW50LXJhdGluZ3NcIl0sICgpID0+IChfX3dlYnBhY2tfcmVxdWlyZV9fKFwiLi9yZXNvdXJjZXMvc2Nzcy9iYXNlL3BhZ2VzL2FwcC1rYW5iYW4uc2Nzc1wiKSkpXG5fX3dlYnBhY2tfcmVxdWlyZV9fLk8odW5kZWZpbmVkLCBbXCJjc3MvYmFzZS9wbHVnaW5zL2V4dGVuc2lvbnMvZXh0LWNvbXBvbmVudC1tZWRpYS1wbGF5ZXJcIixcImNzcy9iYXNlL3BsdWdpbnMvZXh0ZW5zaW9ucy9leHQtY29tcG9uZW50LWRyYWctZHJvcFwiLFwiY3NzL2Jhc2UvcGx1Z2lucy9leHRlbnNpb25zL2V4dC1jb21wb25lbnQtY29udGV4dC1tZW51XCIsXCJjc3MvYmFzZS9wbHVnaW5zL2NoYXJ0cy9jaGFydC1hcGV4XCIsXCJjc3Mvc3R5bGVcIixcImNzcy9vdmVycmlkZXNcIixcImNzcy9jb3JlXCIsXCJjc3MvYmFzZS90aGVtZXMvZGFyay1sYXlvdXRcIixcImNzcy9iYXNlL2NvcmUvbWl4aW5zL3RyYW5zaXRpb25zXCIsXCJjc3MvYmFzZS9jb3JlL21peGlucy9tYWluLW1lbnUtbWl4aW5cIixcImNzcy9iYXNlL2NvcmUvbWl4aW5zL2hleDJyZ2JcIixcImNzcy9iYXNlL2NvcmUvbWl4aW5zL2FsZXJ0XCIsXCJjc3MvYmFzZS9jb3JlL21lbnUvbWVudS10eXBlcy92ZXJ0aWNhbC1vdmVybGF5LW1lbnVcIixcImNzcy9iYXNlL2NvcmUvbWVudS9tZW51LXR5cGVzL3ZlcnRpY2FsLW1lbnVcIixcImNzcy9iYXNlL2NvcmUvbWVudS9tZW51LXR5cGVzL2hvcml6b250YWwtbWVudVwiLFwiY3NzL2Jhc2UvY29yZS9jb2xvcnMvcGFsZXR0ZS12YXJpYWJsZXNcIixcImNzcy9iYXNlL2NvcmUvY29sb3JzL3BhbGV0dGUtbm91aVwiLFwiY3NzL2Jhc2UvY29yZS9jb2xvcnMvcGFsZXR0ZS1ncmFkaWVudFwiLFwiY3NzL2Jhc2UvcGFnZXMvdWktZmVhdGhlclwiLFwiY3NzL2Jhc2UvcGFnZXMvcGFnZS1wcm9maWxlXCIsXCJjc3MvYmFzZS9wYWdlcy9wYWdlLXByaWNpbmdcIixcImNzcy9iYXNlL3BhZ2VzL3BhZ2UtbWlzY1wiLFwiY3NzL2Jhc2UvcGFnZXMvcGFnZS1rbm93bGVkZ2UtYmFzZVwiLFwiY3NzL2Jhc2UvcGFnZXMvcGFnZS1mYXFcIixcImNzcy9iYXNlL3BhZ2VzL3BhZ2UtY29taW5nLXNvb25cIixcImNzcy9iYXNlL3BhZ2VzL3BhZ2UtYmxvZ1wiLFwiY3NzL2Jhc2UvcGFnZXMvbW9kYWwtY3JlYXRlLWFwcFwiLFwiY3NzL2Jhc2UvcGFnZXMvZGFzaGJvYXJkLWVjb21tZXJjZVwiLFwiY3NzL2Jhc2UvcGFnZXMvYXV0aGVudGljYXRpb25cIixcImNzcy9iYXNlL3BhZ2VzL2FwcC10b2RvXCIsXCJjc3MvYmFzZS9wYWdlcy9hcHAta2FuYmFuXCIsXCJjc3MvYmFzZS9wYWdlcy9hcHAtaW52b2ljZVwiLFwiY3NzL2Jhc2UvcGFnZXMvYXBwLWludm9pY2UtcHJpbnRcIixcImNzcy9iYXNlL3BhZ2VzL2FwcC1pbnZvaWNlLWxpc3RcIixcImNzcy9iYXNlL3BhZ2VzL2FwcC1maWxlLW1hbmFnZXJcIixcImNzcy9iYXNlL3BhZ2VzL2FwcC1lbWFpbFwiLFwiY3NzL2Jhc2UvcGFnZXMvYXBwLWVjb21tZXJjZVwiLFwiY3NzL2Jhc2UvcGFnZXMvYXBwLWVjb21tZXJjZS1kZXRhaWxzXCIsXCJjc3MvYmFzZS9wYWdlcy9hcHAtY2hhdFwiLFwiY3NzL2Jhc2UvcGFnZXMvYXBwLWNoYXQtbGlzdFwiLFwiY3NzL2Jhc2UvcGFnZXMvYXBwLWNhbGVuZGFyXCIsXCJjc3MvYmFzZS9wbHVnaW5zL3VpL2NvbWluZy1zb29uXCIsXCJjc3MvYmFzZS9wbHVnaW5zL21hcHMvbWFwLWxlYWZsZXRcIixcImNzcy9iYXNlL3BsdWdpbnMvZm9ybXMvcGlja2Vycy9mb3JtLXBpY2thZGF0ZVwiLFwiY3NzL2Jhc2UvcGx1Z2lucy9mb3Jtcy9waWNrZXJzL2Zvcm0tZmxhdC1waWNrclwiLFwiY3NzL2Jhc2UvcGx1Z2lucy9mb3Jtcy9mb3JtLXdpemFyZFwiLFwiY3NzL2Jhc2UvcGx1Z2lucy9mb3Jtcy9mb3JtLXZhbGlkYXRpb25cIixcImNzcy9iYXNlL3BsdWdpbnMvZm9ybXMvZm9ybS1xdWlsbC1lZGl0b3JcIixcImNzcy9iYXNlL3BsdWdpbnMvZm9ybXMvZm9ybS1udW1iZXItaW5wdXRcIixcImNzcy9iYXNlL3BsdWdpbnMvZm9ybXMvZm9ybS1maWxlLXVwbG9hZGVyXCIsXCJjc3MvYmFzZS9wbHVnaW5zL2V4dGVuc2lvbnMvZXh0LWNvbXBvbmVudC10cmVlXCIsXCJjc3MvYmFzZS9wbHVnaW5zL2V4dGVuc2lvbnMvZXh0LWNvbXBvbmVudC10b3VyXCIsXCJjc3MvYmFzZS9wbHVnaW5zL2V4dGVuc2lvbnMvZXh0LWNvbXBvbmVudC10b2FzdHJcIixcImNzcy9iYXNlL3BsdWdpbnMvZXh0ZW5zaW9ucy9leHQtY29tcG9uZW50LXN3aXBlclwiLFwiY3NzL2Jhc2UvcGx1Z2lucy9leHRlbnNpb25zL2V4dC1jb21wb25lbnQtc3dlZXQtYWxlcnRzXCIsXCJjc3MvYmFzZS9wbHVnaW5zL2V4dGVuc2lvbnMvZXh0LWNvbXBvbmVudC1zbGlkZXJzXCIsXCJjc3MvYmFzZS9wbHVnaW5zL2V4dGVuc2lvbnMvZXh0LWNvbXBvbmVudC1yYXRpbmdzXCJdLCAoKSA9PiAoX193ZWJwYWNrX3JlcXVpcmVfXyhcIi4vcmVzb3VyY2VzL3Njc3MvYmFzZS9wYWdlcy9hcHAtdG9kby5zY3NzXCIpKSlcbl9fd2VicGFja19yZXF1aXJlX18uTyh1bmRlZmluZWQsIFtcImNzcy9iYXNlL3BsdWdpbnMvZXh0ZW5zaW9ucy9leHQtY29tcG9uZW50LW1lZGlhLXBsYXllclwiLFwiY3NzL2Jhc2UvcGx1Z2lucy9leHRlbnNpb25zL2V4dC1jb21wb25lbnQtZHJhZy1kcm9wXCIsXCJjc3MvYmFzZS9wbHVnaW5zL2V4dGVuc2lvbnMvZXh0LWNvbXBvbmVudC1jb250ZXh0LW1lbnVcIixcImNzcy9iYXNlL3BsdWdpbnMvY2hhcnRzL2NoYXJ0LWFwZXhcIixcImNzcy9zdHlsZVwiLFwiY3NzL292ZXJyaWRlc1wiLFwiY3NzL2NvcmVcIixcImNzcy9iYXNlL3RoZW1lcy9kYXJrLWxheW91dFwiLFwiY3NzL2Jhc2UvY29yZS9taXhpbnMvdHJhbnNpdGlvbnNcIixcImNzcy9iYXNlL2NvcmUvbWl4aW5zL21haW4tbWVudS1taXhpblwiLFwiY3NzL2Jhc2UvY29yZS9taXhpbnMvaGV4MnJnYlwiLFwiY3NzL2Jhc2UvY29yZS9taXhpbnMvYWxlcnRcIixcImNzcy9iYXNlL2NvcmUvbWVudS9tZW51LXR5cGVzL3ZlcnRpY2FsLW92ZXJsYXktbWVudVwiLFwiY3NzL2Jhc2UvY29yZS9tZW51L21lbnUtdHlwZXMvdmVydGljYWwtbWVudVwiLFwiY3NzL2Jhc2UvY29yZS9tZW51L21lbnUtdHlwZXMvaG9yaXpvbnRhbC1tZW51XCIsXCJjc3MvYmFzZS9jb3JlL2NvbG9ycy9wYWxldHRlLXZhcmlhYmxlc1wiLFwiY3NzL2Jhc2UvY29yZS9jb2xvcnMvcGFsZXR0ZS1ub3VpXCIsXCJjc3MvYmFzZS9jb3JlL2NvbG9ycy9wYWxldHRlLWdyYWRpZW50XCIsXCJjc3MvYmFzZS9wYWdlcy91aS1mZWF0aGVyXCIsXCJjc3MvYmFzZS9wYWdlcy9wYWdlLXByb2ZpbGVcIixcImNzcy9iYXNlL3BhZ2VzL3BhZ2UtcHJpY2luZ1wiLFwiY3NzL2Jhc2UvcGFnZXMvcGFnZS1taXNjXCIsXCJjc3MvYmFzZS9wYWdlcy9wYWdlLWtub3dsZWRnZS1iYXNlXCIsXCJjc3MvYmFzZS9wYWdlcy9wYWdlLWZhcVwiLFwiY3NzL2Jhc2UvcGFnZXMvcGFnZS1jb21pbmctc29vblwiLFwiY3NzL2Jhc2UvcGFnZXMvcGFnZS1ibG9nXCIsXCJjc3MvYmFzZS9wYWdlcy9tb2RhbC1jcmVhdGUtYXBwXCIsXCJjc3MvYmFzZS9wYWdlcy9kYXNoYm9hcmQtZWNvbW1lcmNlXCIsXCJjc3MvYmFzZS9wYWdlcy9hdXRoZW50aWNhdGlvblwiLFwiY3NzL2Jhc2UvcGFnZXMvYXBwLXRvZG9cIixcImNzcy9iYXNlL3BhZ2VzL2FwcC1rYW5iYW5cIixcImNzcy9iYXNlL3BhZ2VzL2FwcC1pbnZvaWNlXCIsXCJjc3MvYmFzZS9wYWdlcy9hcHAtaW52b2ljZS1wcmludFwiLFwiY3NzL2Jhc2UvcGFnZXMvYXBwLWludm9pY2UtbGlzdFwiLFwiY3NzL2Jhc2UvcGFnZXMvYXBwLWZpbGUtbWFuYWdlclwiLFwiY3NzL2Jhc2UvcGFnZXMvYXBwLWVtYWlsXCIsXCJjc3MvYmFzZS9wYWdlcy9hcHAtZWNvbW1lcmNlXCIsXCJjc3MvYmFzZS9wYWdlcy9hcHAtZWNvbW1lcmNlLWRldGFpbHNcIixcImNzcy9iYXNlL3BhZ2VzL2FwcC1jaGF0XCIsXCJjc3MvYmFzZS9wYWdlcy9hcHAtY2hhdC1saXN0XCIsXCJjc3MvYmFzZS9wYWdlcy9hcHAtY2FsZW5kYXJcIixcImNzcy9iYXNlL3BsdWdpbnMvdWkvY29taW5nLXNvb25cIixcImNzcy9iYXNlL3BsdWdpbnMvbWFwcy9tYXAtbGVhZmxldFwiLFwiY3NzL2Jhc2UvcGx1Z2lucy9mb3Jtcy9waWNrZXJzL2Zvcm0tcGlja2FkYXRlXCIsXCJjc3MvYmFzZS9wbHVnaW5zL2Zvcm1zL3BpY2tlcnMvZm9ybS1mbGF0LXBpY2tyXCIsXCJjc3MvYmFzZS9wbHVnaW5zL2Zvcm1zL2Zvcm0td2l6YXJkXCIsXCJjc3MvYmFzZS9wbHVnaW5zL2Zvcm1zL2Zvcm0tdmFsaWRhdGlvblwiLFwiY3NzL2Jhc2UvcGx1Z2lucy9mb3Jtcy9mb3JtLXF1aWxsLWVkaXRvclwiLFwiY3NzL2Jhc2UvcGx1Z2lucy9mb3Jtcy9mb3JtLW51bWJlci1pbnB1dFwiLFwiY3NzL2Jhc2UvcGx1Z2lucy9mb3Jtcy9mb3JtLWZpbGUtdXBsb2FkZXJcIixcImNzcy9iYXNlL3BsdWdpbnMvZXh0ZW5zaW9ucy9leHQtY29tcG9uZW50LXRyZWVcIixcImNzcy9iYXNlL3BsdWdpbnMvZXh0ZW5zaW9ucy9leHQtY29tcG9uZW50LXRvdXJcIixcImNzcy9iYXNlL3BsdWdpbnMvZXh0ZW5zaW9ucy9leHQtY29tcG9uZW50LXRvYXN0clwiLFwiY3NzL2Jhc2UvcGx1Z2lucy9leHRlbnNpb25zL2V4dC1jb21wb25lbnQtc3dpcGVyXCIsXCJjc3MvYmFzZS9wbHVnaW5zL2V4dGVuc2lvbnMvZXh0LWNvbXBvbmVudC1zd2VldC1hbGVydHNcIixcImNzcy9iYXNlL3BsdWdpbnMvZXh0ZW5zaW9ucy9leHQtY29tcG9uZW50LXNsaWRlcnNcIixcImNzcy9iYXNlL3BsdWdpbnMvZXh0ZW5zaW9ucy9leHQtY29tcG9uZW50LXJhdGluZ3NcIl0sICgpID0+IChfX3dlYnBhY2tfcmVxdWlyZV9fKFwiLi9yZXNvdXJjZXMvc2Nzcy9iYXNlL3BhZ2VzL2F1dGhlbnRpY2F0aW9uLnNjc3NcIikpKVxuX193ZWJwYWNrX3JlcXVpcmVfXy5PKHVuZGVmaW5lZCwgW1wiY3NzL2Jhc2UvcGx1Z2lucy9leHRlbnNpb25zL2V4dC1jb21wb25lbnQtbWVkaWEtcGxheWVyXCIsXCJjc3MvYmFzZS9wbHVnaW5zL2V4dGVuc2lvbnMvZXh0LWNvbXBvbmVudC1kcmFnLWRyb3BcIixcImNzcy9iYXNlL3BsdWdpbnMvZXh0ZW5zaW9ucy9leHQtY29tcG9uZW50LWNvbnRleHQtbWVudVwiLFwiY3NzL2Jhc2UvcGx1Z2lucy9jaGFydHMvY2hhcnQtYXBleFwiLFwiY3NzL3N0eWxlXCIsXCJjc3Mvb3ZlcnJpZGVzXCIsXCJjc3MvY29yZVwiLFwiY3NzL2Jhc2UvdGhlbWVzL2RhcmstbGF5b3V0XCIsXCJjc3MvYmFzZS9jb3JlL21peGlucy90cmFuc2l0aW9uc1wiLFwiY3NzL2Jhc2UvY29yZS9taXhpbnMvbWFpbi1tZW51LW1peGluXCIsXCJjc3MvYmFzZS9jb3JlL21peGlucy9oZXgycmdiXCIsXCJjc3MvYmFzZS9jb3JlL21peGlucy9hbGVydFwiLFwiY3NzL2Jhc2UvY29yZS9tZW51L21lbnUtdHlwZXMvdmVydGljYWwtb3ZlcmxheS1tZW51XCIsXCJjc3MvYmFzZS9jb3JlL21lbnUvbWVudS10eXBlcy92ZXJ0aWNhbC1tZW51XCIsXCJjc3MvYmFzZS9jb3JlL21lbnUvbWVudS10eXBlcy9ob3Jpem9udGFsLW1lbnVcIixcImNzcy9iYXNlL2NvcmUvY29sb3JzL3BhbGV0dGUtdmFyaWFibGVzXCIsXCJjc3MvYmFzZS9jb3JlL2NvbG9ycy9wYWxldHRlLW5vdWlcIixcImNzcy9iYXNlL2NvcmUvY29sb3JzL3BhbGV0dGUtZ3JhZGllbnRcIixcImNzcy9iYXNlL3BhZ2VzL3VpLWZlYXRoZXJcIixcImNzcy9iYXNlL3BhZ2VzL3BhZ2UtcHJvZmlsZVwiLFwiY3NzL2Jhc2UvcGFnZXMvcGFnZS1wcmljaW5nXCIsXCJjc3MvYmFzZS9wYWdlcy9wYWdlLW1pc2NcIixcImNzcy9iYXNlL3BhZ2VzL3BhZ2Uta25vd2xlZGdlLWJhc2VcIixcImNzcy9iYXNlL3BhZ2VzL3BhZ2UtZmFxXCIsXCJjc3MvYmFzZS9wYWdlcy9wYWdlLWNvbWluZy1zb29uXCIsXCJjc3MvYmFzZS9wYWdlcy9wYWdlLWJsb2dcIixcImNzcy9iYXNlL3BhZ2VzL21vZGFsLWNyZWF0ZS1hcHBcIixcImNzcy9iYXNlL3BhZ2VzL2Rhc2hib2FyZC1lY29tbWVyY2VcIixcImNzcy9iYXNlL3BhZ2VzL2F1dGhlbnRpY2F0aW9uXCIsXCJjc3MvYmFzZS9wYWdlcy9hcHAtdG9kb1wiLFwiY3NzL2Jhc2UvcGFnZXMvYXBwLWthbmJhblwiLFwiY3NzL2Jhc2UvcGFnZXMvYXBwLWludm9pY2VcIixcImNzcy9iYXNlL3BhZ2VzL2FwcC1pbnZvaWNlLXByaW50XCIsXCJjc3MvYmFzZS9wYWdlcy9hcHAtaW52b2ljZS1saXN0XCIsXCJjc3MvYmFzZS9wYWdlcy9hcHAtZmlsZS1tYW5hZ2VyXCIsXCJjc3MvYmFzZS9wYWdlcy9hcHAtZW1haWxcIixcImNzcy9iYXNlL3BhZ2VzL2FwcC1lY29tbWVyY2VcIixcImNzcy9iYXNlL3BhZ2VzL2FwcC1lY29tbWVyY2UtZGV0YWlsc1wiLFwiY3NzL2Jhc2UvcGFnZXMvYXBwLWNoYXRcIixcImNzcy9iYXNlL3BhZ2VzL2FwcC1jaGF0LWxpc3RcIixcImNzcy9iYXNlL3BhZ2VzL2FwcC1jYWxlbmRhclwiLFwiY3NzL2Jhc2UvcGx1Z2lucy91aS9jb21pbmctc29vblwiLFwiY3NzL2Jhc2UvcGx1Z2lucy9tYXBzL21hcC1sZWFmbGV0XCIsXCJjc3MvYmFzZS9wbHVnaW5zL2Zvcm1zL3BpY2tlcnMvZm9ybS1waWNrYWRhdGVcIixcImNzcy9iYXNlL3BsdWdpbnMvZm9ybXMvcGlja2Vycy9mb3JtLWZsYXQtcGlja3JcIixcImNzcy9iYXNlL3BsdWdpbnMvZm9ybXMvZm9ybS13aXphcmRcIixcImNzcy9iYXNlL3BsdWdpbnMvZm9ybXMvZm9ybS12YWxpZGF0aW9uXCIsXCJjc3MvYmFzZS9wbHVnaW5zL2Zvcm1zL2Zvcm0tcXVpbGwtZWRpdG9yXCIsXCJjc3MvYmFzZS9wbHVnaW5zL2Zvcm1zL2Zvcm0tbnVtYmVyLWlucHV0XCIsXCJjc3MvYmFzZS9wbHVnaW5zL2Zvcm1zL2Zvcm0tZmlsZS11cGxvYWRlclwiLFwiY3NzL2Jhc2UvcGx1Z2lucy9leHRlbnNpb25zL2V4dC1jb21wb25lbnQtdHJlZVwiLFwiY3NzL2Jhc2UvcGx1Z2lucy9leHRlbnNpb25zL2V4dC1jb21wb25lbnQtdG91clwiLFwiY3NzL2Jhc2UvcGx1Z2lucy9leHRlbnNpb25zL2V4dC1jb21wb25lbnQtdG9hc3RyXCIsXCJjc3MvYmFzZS9wbHVnaW5zL2V4dGVuc2lvbnMvZXh0LWNvbXBvbmVudC1zd2lwZXJcIixcImNzcy9iYXNlL3BsdWdpbnMvZXh0ZW5zaW9ucy9leHQtY29tcG9uZW50LXN3ZWV0LWFsZXJ0c1wiLFwiY3NzL2Jhc2UvcGx1Z2lucy9leHRlbnNpb25zL2V4dC1jb21wb25lbnQtc2xpZGVyc1wiLFwiY3NzL2Jhc2UvcGx1Z2lucy9leHRlbnNpb25zL2V4dC1jb21wb25lbnQtcmF0aW5nc1wiXSwgKCkgPT4gKF9fd2VicGFja19yZXF1aXJlX18oXCIuL3Jlc291cmNlcy9zY3NzL2Jhc2UvcGFnZXMvZGFzaGJvYXJkLWVjb21tZXJjZS5zY3NzXCIpKSlcbl9fd2VicGFja19yZXF1aXJlX18uTyh1bmRlZmluZWQsIFtcImNzcy9iYXNlL3BsdWdpbnMvZXh0ZW5zaW9ucy9leHQtY29tcG9uZW50LW1lZGlhLXBsYXllclwiLFwiY3NzL2Jhc2UvcGx1Z2lucy9leHRlbnNpb25zL2V4dC1jb21wb25lbnQtZHJhZy1kcm9wXCIsXCJjc3MvYmFzZS9wbHVnaW5zL2V4dGVuc2lvbnMvZXh0LWNvbXBvbmVudC1jb250ZXh0LW1lbnVcIixcImNzcy9iYXNlL3BsdWdpbnMvY2hhcnRzL2NoYXJ0LWFwZXhcIixcImNzcy9zdHlsZVwiLFwiY3NzL292ZXJyaWRlc1wiLFwiY3NzL2NvcmVcIixcImNzcy9iYXNlL3RoZW1lcy9kYXJrLWxheW91dFwiLFwiY3NzL2Jhc2UvY29yZS9taXhpbnMvdHJhbnNpdGlvbnNcIixcImNzcy9iYXNlL2NvcmUvbWl4aW5zL21haW4tbWVudS1taXhpblwiLFwiY3NzL2Jhc2UvY29yZS9taXhpbnMvaGV4MnJnYlwiLFwiY3NzL2Jhc2UvY29yZS9taXhpbnMvYWxlcnRcIixcImNzcy9iYXNlL2NvcmUvbWVudS9tZW51LXR5cGVzL3ZlcnRpY2FsLW92ZXJsYXktbWVudVwiLFwiY3NzL2Jhc2UvY29yZS9tZW51L21lbnUtdHlwZXMvdmVydGljYWwtbWVudVwiLFwiY3NzL2Jhc2UvY29yZS9tZW51L21lbnUtdHlwZXMvaG9yaXpvbnRhbC1tZW51XCIsXCJjc3MvYmFzZS9jb3JlL2NvbG9ycy9wYWxldHRlLXZhcmlhYmxlc1wiLFwiY3NzL2Jhc2UvY29yZS9jb2xvcnMvcGFsZXR0ZS1ub3VpXCIsXCJjc3MvYmFzZS9jb3JlL2NvbG9ycy9wYWxldHRlLWdyYWRpZW50XCIsXCJjc3MvYmFzZS9wYWdlcy91aS1mZWF0aGVyXCIsXCJjc3MvYmFzZS9wYWdlcy9wYWdlLXByb2ZpbGVcIixcImNzcy9iYXNlL3BhZ2VzL3BhZ2UtcHJpY2luZ1wiLFwiY3NzL2Jhc2UvcGFnZXMvcGFnZS1taXNjXCIsXCJjc3MvYmFzZS9wYWdlcy9wYWdlLWtub3dsZWRnZS1iYXNlXCIsXCJjc3MvYmFzZS9wYWdlcy9wYWdlLWZhcVwiLFwiY3NzL2Jhc2UvcGFnZXMvcGFnZS1jb21pbmctc29vblwiLFwiY3NzL2Jhc2UvcGFnZXMvcGFnZS1ibG9nXCIsXCJjc3MvYmFzZS9wYWdlcy9tb2RhbC1jcmVhdGUtYXBwXCIsXCJjc3MvYmFzZS9wYWdlcy9kYXNoYm9hcmQtZWNvbW1lcmNlXCIsXCJjc3MvYmFzZS9wYWdlcy9hdXRoZW50aWNhdGlvblwiLFwiY3NzL2Jhc2UvcGFnZXMvYXBwLXRvZG9cIixcImNzcy9iYXNlL3BhZ2VzL2FwcC1rYW5iYW5cIixcImNzcy9iYXNlL3BhZ2VzL2FwcC1pbnZvaWNlXCIsXCJjc3MvYmFzZS9wYWdlcy9hcHAtaW52b2ljZS1wcmludFwiLFwiY3NzL2Jhc2UvcGFnZXMvYXBwLWludm9pY2UtbGlzdFwiLFwiY3NzL2Jhc2UvcGFnZXMvYXBwLWZpbGUtbWFuYWdlclwiLFwiY3NzL2Jhc2UvcGFnZXMvYXBwLWVtYWlsXCIsXCJjc3MvYmFzZS9wYWdlcy9hcHAtZWNvbW1lcmNlXCIsXCJjc3MvYmFzZS9wYWdlcy9hcHAtZWNvbW1lcmNlLWRldGFpbHNcIixcImNzcy9iYXNlL3BhZ2VzL2FwcC1jaGF0XCIsXCJjc3MvYmFzZS9wYWdlcy9hcHAtY2hhdC1saXN0XCIsXCJjc3MvYmFzZS9wYWdlcy9hcHAtY2FsZW5kYXJcIixcImNzcy9iYXNlL3BsdWdpbnMvdWkvY29taW5nLXNvb25cIixcImNzcy9iYXNlL3BsdWdpbnMvbWFwcy9tYXAtbGVhZmxldFwiLFwiY3NzL2Jhc2UvcGx1Z2lucy9mb3Jtcy9waWNrZXJzL2Zvcm0tcGlja2FkYXRlXCIsXCJjc3MvYmFzZS9wbHVnaW5zL2Zvcm1zL3BpY2tlcnMvZm9ybS1mbGF0LXBpY2tyXCIsXCJjc3MvYmFzZS9wbHVnaW5zL2Zvcm1zL2Zvcm0td2l6YXJkXCIsXCJjc3MvYmFzZS9wbHVnaW5zL2Zvcm1zL2Zvcm0tdmFsaWRhdGlvblwiLFwiY3NzL2Jhc2UvcGx1Z2lucy9mb3Jtcy9mb3JtLXF1aWxsLWVkaXRvclwiLFwiY3NzL2Jhc2UvcGx1Z2lucy9mb3Jtcy9mb3JtLW51bWJlci1pbnB1dFwiLFwiY3NzL2Jhc2UvcGx1Z2lucy9mb3Jtcy9mb3JtLWZpbGUtdXBsb2FkZXJcIixcImNzcy9iYXNlL3BsdWdpbnMvZXh0ZW5zaW9ucy9leHQtY29tcG9uZW50LXRyZWVcIixcImNzcy9iYXNlL3BsdWdpbnMvZXh0ZW5zaW9ucy9leHQtY29tcG9uZW50LXRvdXJcIixcImNzcy9iYXNlL3BsdWdpbnMvZXh0ZW5zaW9ucy9leHQtY29tcG9uZW50LXRvYXN0clwiLFwiY3NzL2Jhc2UvcGx1Z2lucy9leHRlbnNpb25zL2V4dC1jb21wb25lbnQtc3dpcGVyXCIsXCJjc3MvYmFzZS9wbHVnaW5zL2V4dGVuc2lvbnMvZXh0LWNvbXBvbmVudC1zd2VldC1hbGVydHNcIixcImNzcy9iYXNlL3BsdWdpbnMvZXh0ZW5zaW9ucy9leHQtY29tcG9uZW50LXNsaWRlcnNcIixcImNzcy9iYXNlL3BsdWdpbnMvZXh0ZW5zaW9ucy9leHQtY29tcG9uZW50LXJhdGluZ3NcIl0sICgpID0+IChfX3dlYnBhY2tfcmVxdWlyZV9fKFwiLi9yZXNvdXJjZXMvc2Nzcy9iYXNlL3BhZ2VzL21vZGFsLWNyZWF0ZS1hcHAuc2Nzc1wiKSkpXG5fX3dlYnBhY2tfcmVxdWlyZV9fLk8odW5kZWZpbmVkLCBbXCJjc3MvYmFzZS9wbHVnaW5zL2V4dGVuc2lvbnMvZXh0LWNvbXBvbmVudC1tZWRpYS1wbGF5ZXJcIixcImNzcy9iYXNlL3BsdWdpbnMvZXh0ZW5zaW9ucy9leHQtY29tcG9uZW50LWRyYWctZHJvcFwiLFwiY3NzL2Jhc2UvcGx1Z2lucy9leHRlbnNpb25zL2V4dC1jb21wb25lbnQtY29udGV4dC1tZW51XCIsXCJjc3MvYmFzZS9wbHVnaW5zL2NoYXJ0cy9jaGFydC1hcGV4XCIsXCJjc3Mvc3R5bGVcIixcImNzcy9vdmVycmlkZXNcIixcImNzcy9jb3JlXCIsXCJjc3MvYmFzZS90aGVtZXMvZGFyay1sYXlvdXRcIixcImNzcy9iYXNlL2NvcmUvbWl4aW5zL3RyYW5zaXRpb25zXCIsXCJjc3MvYmFzZS9jb3JlL21peGlucy9tYWluLW1lbnUtbWl4aW5cIixcImNzcy9iYXNlL2NvcmUvbWl4aW5zL2hleDJyZ2JcIixcImNzcy9iYXNlL2NvcmUvbWl4aW5zL2FsZXJ0XCIsXCJjc3MvYmFzZS9jb3JlL21lbnUvbWVudS10eXBlcy92ZXJ0aWNhbC1vdmVybGF5LW1lbnVcIixcImNzcy9iYXNlL2NvcmUvbWVudS9tZW51LXR5cGVzL3ZlcnRpY2FsLW1lbnVcIixcImNzcy9iYXNlL2NvcmUvbWVudS9tZW51LXR5cGVzL2hvcml6b250YWwtbWVudVwiLFwiY3NzL2Jhc2UvY29yZS9jb2xvcnMvcGFsZXR0ZS12YXJpYWJsZXNcIixcImNzcy9iYXNlL2NvcmUvY29sb3JzL3BhbGV0dGUtbm91aVwiLFwiY3NzL2Jhc2UvY29yZS9jb2xvcnMvcGFsZXR0ZS1ncmFkaWVudFwiLFwiY3NzL2Jhc2UvcGFnZXMvdWktZmVhdGhlclwiLFwiY3NzL2Jhc2UvcGFnZXMvcGFnZS1wcm9maWxlXCIsXCJjc3MvYmFzZS9wYWdlcy9wYWdlLXByaWNpbmdcIixcImNzcy9iYXNlL3BhZ2VzL3BhZ2UtbWlzY1wiLFwiY3NzL2Jhc2UvcGFnZXMvcGFnZS1rbm93bGVkZ2UtYmFzZVwiLFwiY3NzL2Jhc2UvcGFnZXMvcGFnZS1mYXFcIixcImNzcy9iYXNlL3BhZ2VzL3BhZ2UtY29taW5nLXNvb25cIixcImNzcy9iYXNlL3BhZ2VzL3BhZ2UtYmxvZ1wiLFwiY3NzL2Jhc2UvcGFnZXMvbW9kYWwtY3JlYXRlLWFwcFwiLFwiY3NzL2Jhc2UvcGFnZXMvZGFzaGJvYXJkLWVjb21tZXJjZVwiLFwiY3NzL2Jhc2UvcGFnZXMvYXV0aGVudGljYXRpb25cIixcImNzcy9iYXNlL3BhZ2VzL2FwcC10b2RvXCIsXCJjc3MvYmFzZS9wYWdlcy9hcHAta2FuYmFuXCIsXCJjc3MvYmFzZS9wYWdlcy9hcHAtaW52b2ljZVwiLFwiY3NzL2Jhc2UvcGFnZXMvYXBwLWludm9pY2UtcHJpbnRcIixcImNzcy9iYXNlL3BhZ2VzL2FwcC1pbnZvaWNlLWxpc3RcIixcImNzcy9iYXNlL3BhZ2VzL2FwcC1maWxlLW1hbmFnZXJcIixcImNzcy9iYXNlL3BhZ2VzL2FwcC1lbWFpbFwiLFwiY3NzL2Jhc2UvcGFnZXMvYXBwLWVjb21tZXJjZVwiLFwiY3NzL2Jhc2UvcGFnZXMvYXBwLWVjb21tZXJjZS1kZXRhaWxzXCIsXCJjc3MvYmFzZS9wYWdlcy9hcHAtY2hhdFwiLFwiY3NzL2Jhc2UvcGFnZXMvYXBwLWNoYXQtbGlzdFwiLFwiY3NzL2Jhc2UvcGFnZXMvYXBwLWNhbGVuZGFyXCIsXCJjc3MvYmFzZS9wbHVnaW5zL3VpL2NvbWluZy1zb29uXCIsXCJjc3MvYmFzZS9wbHVnaW5zL21hcHMvbWFwLWxlYWZsZXRcIixcImNzcy9iYXNlL3BsdWdpbnMvZm9ybXMvcGlja2Vycy9mb3JtLXBpY2thZGF0ZVwiLFwiY3NzL2Jhc2UvcGx1Z2lucy9mb3Jtcy9waWNrZXJzL2Zvcm0tZmxhdC1waWNrclwiLFwiY3NzL2Jhc2UvcGx1Z2lucy9mb3Jtcy9mb3JtLXdpemFyZFwiLFwiY3NzL2Jhc2UvcGx1Z2lucy9mb3Jtcy9mb3JtLXZhbGlkYXRpb25cIixcImNzcy9iYXNlL3BsdWdpbnMvZm9ybXMvZm9ybS1xdWlsbC1lZGl0b3JcIixcImNzcy9iYXNlL3BsdWdpbnMvZm9ybXMvZm9ybS1udW1iZXItaW5wdXRcIixcImNzcy9iYXNlL3BsdWdpbnMvZm9ybXMvZm9ybS1maWxlLXVwbG9hZGVyXCIsXCJjc3MvYmFzZS9wbHVnaW5zL2V4dGVuc2lvbnMvZXh0LWNvbXBvbmVudC10cmVlXCIsXCJjc3MvYmFzZS9wbHVnaW5zL2V4dGVuc2lvbnMvZXh0LWNvbXBvbmVudC10b3VyXCIsXCJjc3MvYmFzZS9wbHVnaW5zL2V4dGVuc2lvbnMvZXh0LWNvbXBvbmVudC10b2FzdHJcIixcImNzcy9iYXNlL3BsdWdpbnMvZXh0ZW5zaW9ucy9leHQtY29tcG9uZW50LXN3aXBlclwiLFwiY3NzL2Jhc2UvcGx1Z2lucy9leHRlbnNpb25zL2V4dC1jb21wb25lbnQtc3dlZXQtYWxlcnRzXCIsXCJjc3MvYmFzZS9wbHVnaW5zL2V4dGVuc2lvbnMvZXh0LWNvbXBvbmVudC1zbGlkZXJzXCIsXCJjc3MvYmFzZS9wbHVnaW5zL2V4dGVuc2lvbnMvZXh0LWNvbXBvbmVudC1yYXRpbmdzXCJdLCAoKSA9PiAoX193ZWJwYWNrX3JlcXVpcmVfXyhcIi4vcmVzb3VyY2VzL3Njc3MvYmFzZS9wYWdlcy9wYWdlLWJsb2cuc2Nzc1wiKSkpXG5fX3dlYnBhY2tfcmVxdWlyZV9fLk8odW5kZWZpbmVkLCBbXCJjc3MvYmFzZS9wbHVnaW5zL2V4dGVuc2lvbnMvZXh0LWNvbXBvbmVudC1tZWRpYS1wbGF5ZXJcIixcImNzcy9iYXNlL3BsdWdpbnMvZXh0ZW5zaW9ucy9leHQtY29tcG9uZW50LWRyYWctZHJvcFwiLFwiY3NzL2Jhc2UvcGx1Z2lucy9leHRlbnNpb25zL2V4dC1jb21wb25lbnQtY29udGV4dC1tZW51XCIsXCJjc3MvYmFzZS9wbHVnaW5zL2NoYXJ0cy9jaGFydC1hcGV4XCIsXCJjc3Mvc3R5bGVcIixcImNzcy9vdmVycmlkZXNcIixcImNzcy9jb3JlXCIsXCJjc3MvYmFzZS90aGVtZXMvZGFyay1sYXlvdXRcIixcImNzcy9iYXNlL2NvcmUvbWl4aW5zL3RyYW5zaXRpb25zXCIsXCJjc3MvYmFzZS9jb3JlL21peGlucy9tYWluLW1lbnUtbWl4aW5cIixcImNzcy9iYXNlL2NvcmUvbWl4aW5zL2hleDJyZ2JcIixcImNzcy9iYXNlL2NvcmUvbWl4aW5zL2FsZXJ0XCIsXCJjc3MvYmFzZS9jb3JlL21lbnUvbWVudS10eXBlcy92ZXJ0aWNhbC1vdmVybGF5LW1lbnVcIixcImNzcy9iYXNlL2NvcmUvbWVudS9tZW51LXR5cGVzL3ZlcnRpY2FsLW1lbnVcIixcImNzcy9iYXNlL2NvcmUvbWVudS9tZW51LXR5cGVzL2hvcml6b250YWwtbWVudVwiLFwiY3NzL2Jhc2UvY29yZS9jb2xvcnMvcGFsZXR0ZS12YXJpYWJsZXNcIixcImNzcy9iYXNlL2NvcmUvY29sb3JzL3BhbGV0dGUtbm91aVwiLFwiY3NzL2Jhc2UvY29yZS9jb2xvcnMvcGFsZXR0ZS1ncmFkaWVudFwiLFwiY3NzL2Jhc2UvcGFnZXMvdWktZmVhdGhlclwiLFwiY3NzL2Jhc2UvcGFnZXMvcGFnZS1wcm9maWxlXCIsXCJjc3MvYmFzZS9wYWdlcy9wYWdlLXByaWNpbmdcIixcImNzcy9iYXNlL3BhZ2VzL3BhZ2UtbWlzY1wiLFwiY3NzL2Jhc2UvcGFnZXMvcGFnZS1rbm93bGVkZ2UtYmFzZVwiLFwiY3NzL2Jhc2UvcGFnZXMvcGFnZS1mYXFcIixcImNzcy9iYXNlL3BhZ2VzL3BhZ2UtY29taW5nLXNvb25cIixcImNzcy9iYXNlL3BhZ2VzL3BhZ2UtYmxvZ1wiLFwiY3NzL2Jhc2UvcGFnZXMvbW9kYWwtY3JlYXRlLWFwcFwiLFwiY3NzL2Jhc2UvcGFnZXMvZGFzaGJvYXJkLWVjb21tZXJjZVwiLFwiY3NzL2Jhc2UvcGFnZXMvYXV0aGVudGljYXRpb25cIixcImNzcy9iYXNlL3BhZ2VzL2FwcC10b2RvXCIsXCJjc3MvYmFzZS9wYWdlcy9hcHAta2FuYmFuXCIsXCJjc3MvYmFzZS9wYWdlcy9hcHAtaW52b2ljZVwiLFwiY3NzL2Jhc2UvcGFnZXMvYXBwLWludm9pY2UtcHJpbnRcIixcImNzcy9iYXNlL3BhZ2VzL2FwcC1pbnZvaWNlLWxpc3RcIixcImNzcy9iYXNlL3BhZ2VzL2FwcC1maWxlLW1hbmFnZXJcIixcImNzcy9iYXNlL3BhZ2VzL2FwcC1lbWFpbFwiLFwiY3NzL2Jhc2UvcGFnZXMvYXBwLWVjb21tZXJjZVwiLFwiY3NzL2Jhc2UvcGFnZXMvYXBwLWVjb21tZXJjZS1kZXRhaWxzXCIsXCJjc3MvYmFzZS9wYWdlcy9hcHAtY2hhdFwiLFwiY3NzL2Jhc2UvcGFnZXMvYXBwLWNoYXQtbGlzdFwiLFwiY3NzL2Jhc2UvcGFnZXMvYXBwLWNhbGVuZGFyXCIsXCJjc3MvYmFzZS9wbHVnaW5zL3VpL2NvbWluZy1zb29uXCIsXCJjc3MvYmFzZS9wbHVnaW5zL21hcHMvbWFwLWxlYWZsZXRcIixcImNzcy9iYXNlL3BsdWdpbnMvZm9ybXMvcGlja2Vycy9mb3JtLXBpY2thZGF0ZVwiLFwiY3NzL2Jhc2UvcGx1Z2lucy9mb3Jtcy9waWNrZXJzL2Zvcm0tZmxhdC1waWNrclwiLFwiY3NzL2Jhc2UvcGx1Z2lucy9mb3Jtcy9mb3JtLXdpemFyZFwiLFwiY3NzL2Jhc2UvcGx1Z2lucy9mb3Jtcy9mb3JtLXZhbGlkYXRpb25cIixcImNzcy9iYXNlL3BsdWdpbnMvZm9ybXMvZm9ybS1xdWlsbC1lZGl0b3JcIixcImNzcy9iYXNlL3BsdWdpbnMvZm9ybXMvZm9ybS1udW1iZXItaW5wdXRcIixcImNzcy9iYXNlL3BsdWdpbnMvZm9ybXMvZm9ybS1maWxlLXVwbG9hZGVyXCIsXCJjc3MvYmFzZS9wbHVnaW5zL2V4dGVuc2lvbnMvZXh0LWNvbXBvbmVudC10cmVlXCIsXCJjc3MvYmFzZS9wbHVnaW5zL2V4dGVuc2lvbnMvZXh0LWNvbXBvbmVudC10b3VyXCIsXCJjc3MvYmFzZS9wbHVnaW5zL2V4dGVuc2lvbnMvZXh0LWNvbXBvbmVudC10b2FzdHJcIixcImNzcy9iYXNlL3BsdWdpbnMvZXh0ZW5zaW9ucy9leHQtY29tcG9uZW50LXN3aXBlclwiLFwiY3NzL2Jhc2UvcGx1Z2lucy9leHRlbnNpb25zL2V4dC1jb21wb25lbnQtc3dlZXQtYWxlcnRzXCIsXCJjc3MvYmFzZS9wbHVnaW5zL2V4dGVuc2lvbnMvZXh0LWNvbXBvbmVudC1zbGlkZXJzXCIsXCJjc3MvYmFzZS9wbHVnaW5zL2V4dGVuc2lvbnMvZXh0LWNvbXBvbmVudC1yYXRpbmdzXCJdLCAoKSA9PiAoX193ZWJwYWNrX3JlcXVpcmVfXyhcIi4vcmVzb3VyY2VzL3Njc3MvYmFzZS9wYWdlcy9wYWdlLWNvbWluZy1zb29uLnNjc3NcIikpKVxuX193ZWJwYWNrX3JlcXVpcmVfXy5PKHVuZGVmaW5lZCwgW1wiY3NzL2Jhc2UvcGx1Z2lucy9leHRlbnNpb25zL2V4dC1jb21wb25lbnQtbWVkaWEtcGxheWVyXCIsXCJjc3MvYmFzZS9wbHVnaW5zL2V4dGVuc2lvbnMvZXh0LWNvbXBvbmVudC1kcmFnLWRyb3BcIixcImNzcy9iYXNlL3BsdWdpbnMvZXh0ZW5zaW9ucy9leHQtY29tcG9uZW50LWNvbnRleHQtbWVudVwiLFwiY3NzL2Jhc2UvcGx1Z2lucy9jaGFydHMvY2hhcnQtYXBleFwiLFwiY3NzL3N0eWxlXCIsXCJjc3Mvb3ZlcnJpZGVzXCIsXCJjc3MvY29yZVwiLFwiY3NzL2Jhc2UvdGhlbWVzL2RhcmstbGF5b3V0XCIsXCJjc3MvYmFzZS9jb3JlL21peGlucy90cmFuc2l0aW9uc1wiLFwiY3NzL2Jhc2UvY29yZS9taXhpbnMvbWFpbi1tZW51LW1peGluXCIsXCJjc3MvYmFzZS9jb3JlL21peGlucy9oZXgycmdiXCIsXCJjc3MvYmFzZS9jb3JlL21peGlucy9hbGVydFwiLFwiY3NzL2Jhc2UvY29yZS9tZW51L21lbnUtdHlwZXMvdmVydGljYWwtb3ZlcmxheS1tZW51XCIsXCJjc3MvYmFzZS9jb3JlL21lbnUvbWVudS10eXBlcy92ZXJ0aWNhbC1tZW51XCIsXCJjc3MvYmFzZS9jb3JlL21lbnUvbWVudS10eXBlcy9ob3Jpem9udGFsLW1lbnVcIixcImNzcy9iYXNlL2NvcmUvY29sb3JzL3BhbGV0dGUtdmFyaWFibGVzXCIsXCJjc3MvYmFzZS9jb3JlL2NvbG9ycy9wYWxldHRlLW5vdWlcIixcImNzcy9iYXNlL2NvcmUvY29sb3JzL3BhbGV0dGUtZ3JhZGllbnRcIixcImNzcy9iYXNlL3BhZ2VzL3VpLWZlYXRoZXJcIixcImNzcy9iYXNlL3BhZ2VzL3BhZ2UtcHJvZmlsZVwiLFwiY3NzL2Jhc2UvcGFnZXMvcGFnZS1wcmljaW5nXCIsXCJjc3MvYmFzZS9wYWdlcy9wYWdlLW1pc2NcIixcImNzcy9iYXNlL3BhZ2VzL3BhZ2Uta25vd2xlZGdlLWJhc2VcIixcImNzcy9iYXNlL3BhZ2VzL3BhZ2UtZmFxXCIsXCJjc3MvYmFzZS9wYWdlcy9wYWdlLWNvbWluZy1zb29uXCIsXCJjc3MvYmFzZS9wYWdlcy9wYWdlLWJsb2dcIixcImNzcy9iYXNlL3BhZ2VzL21vZGFsLWNyZWF0ZS1hcHBcIixcImNzcy9iYXNlL3BhZ2VzL2Rhc2hib2FyZC1lY29tbWVyY2VcIixcImNzcy9iYXNlL3BhZ2VzL2F1dGhlbnRpY2F0aW9uXCIsXCJjc3MvYmFzZS9wYWdlcy9hcHAtdG9kb1wiLFwiY3NzL2Jhc2UvcGFnZXMvYXBwLWthbmJhblwiLFwiY3NzL2Jhc2UvcGFnZXMvYXBwLWludm9pY2VcIixcImNzcy9iYXNlL3BhZ2VzL2FwcC1pbnZvaWNlLXByaW50XCIsXCJjc3MvYmFzZS9wYWdlcy9hcHAtaW52b2ljZS1saXN0XCIsXCJjc3MvYmFzZS9wYWdlcy9hcHAtZmlsZS1tYW5hZ2VyXCIsXCJjc3MvYmFzZS9wYWdlcy9hcHAtZW1haWxcIixcImNzcy9iYXNlL3BhZ2VzL2FwcC1lY29tbWVyY2VcIixcImNzcy9iYXNlL3BhZ2VzL2FwcC1lY29tbWVyY2UtZGV0YWlsc1wiLFwiY3NzL2Jhc2UvcGFnZXMvYXBwLWNoYXRcIixcImNzcy9iYXNlL3BhZ2VzL2FwcC1jaGF0LWxpc3RcIixcImNzcy9iYXNlL3BhZ2VzL2FwcC1jYWxlbmRhclwiLFwiY3NzL2Jhc2UvcGx1Z2lucy91aS9jb21pbmctc29vblwiLFwiY3NzL2Jhc2UvcGx1Z2lucy9tYXBzL21hcC1sZWFmbGV0XCIsXCJjc3MvYmFzZS9wbHVnaW5zL2Zvcm1zL3BpY2tlcnMvZm9ybS1waWNrYWRhdGVcIixcImNzcy9iYXNlL3BsdWdpbnMvZm9ybXMvcGlja2Vycy9mb3JtLWZsYXQtcGlja3JcIixcImNzcy9iYXNlL3BsdWdpbnMvZm9ybXMvZm9ybS13aXphcmRcIixcImNzcy9iYXNlL3BsdWdpbnMvZm9ybXMvZm9ybS12YWxpZGF0aW9uXCIsXCJjc3MvYmFzZS9wbHVnaW5zL2Zvcm1zL2Zvcm0tcXVpbGwtZWRpdG9yXCIsXCJjc3MvYmFzZS9wbHVnaW5zL2Zvcm1zL2Zvcm0tbnVtYmVyLWlucHV0XCIsXCJjc3MvYmFzZS9wbHVnaW5zL2Zvcm1zL2Zvcm0tZmlsZS11cGxvYWRlclwiLFwiY3NzL2Jhc2UvcGx1Z2lucy9leHRlbnNpb25zL2V4dC1jb21wb25lbnQtdHJlZVwiLFwiY3NzL2Jhc2UvcGx1Z2lucy9leHRlbnNpb25zL2V4dC1jb21wb25lbnQtdG91clwiLFwiY3NzL2Jhc2UvcGx1Z2lucy9leHRlbnNpb25zL2V4dC1jb21wb25lbnQtdG9hc3RyXCIsXCJjc3MvYmFzZS9wbHVnaW5zL2V4dGVuc2lvbnMvZXh0LWNvbXBvbmVudC1zd2lwZXJcIixcImNzcy9iYXNlL3BsdWdpbnMvZXh0ZW5zaW9ucy9leHQtY29tcG9uZW50LXN3ZWV0LWFsZXJ0c1wiLFwiY3NzL2Jhc2UvcGx1Z2lucy9leHRlbnNpb25zL2V4dC1jb21wb25lbnQtc2xpZGVyc1wiLFwiY3NzL2Jhc2UvcGx1Z2lucy9leHRlbnNpb25zL2V4dC1jb21wb25lbnQtcmF0aW5nc1wiXSwgKCkgPT4gKF9fd2VicGFja19yZXF1aXJlX18oXCIuL3Jlc291cmNlcy9zY3NzL2Jhc2UvcGFnZXMvcGFnZS1mYXEuc2Nzc1wiKSkpXG5fX3dlYnBhY2tfcmVxdWlyZV9fLk8odW5kZWZpbmVkLCBbXCJjc3MvYmFzZS9wbHVnaW5zL2V4dGVuc2lvbnMvZXh0LWNvbXBvbmVudC1tZWRpYS1wbGF5ZXJcIixcImNzcy9iYXNlL3BsdWdpbnMvZXh0ZW5zaW9ucy9leHQtY29tcG9uZW50LWRyYWctZHJvcFwiLFwiY3NzL2Jhc2UvcGx1Z2lucy9leHRlbnNpb25zL2V4dC1jb21wb25lbnQtY29udGV4dC1tZW51XCIsXCJjc3MvYmFzZS9wbHVnaW5zL2NoYXJ0cy9jaGFydC1hcGV4XCIsXCJjc3Mvc3R5bGVcIixcImNzcy9vdmVycmlkZXNcIixcImNzcy9jb3JlXCIsXCJjc3MvYmFzZS90aGVtZXMvZGFyay1sYXlvdXRcIixcImNzcy9iYXNlL2NvcmUvbWl4aW5zL3RyYW5zaXRpb25zXCIsXCJjc3MvYmFzZS9jb3JlL21peGlucy9tYWluLW1lbnUtbWl4aW5cIixcImNzcy9iYXNlL2NvcmUvbWl4aW5zL2hleDJyZ2JcIixcImNzcy9iYXNlL2NvcmUvbWl4aW5zL2FsZXJ0XCIsXCJjc3MvYmFzZS9jb3JlL21lbnUvbWVudS10eXBlcy92ZXJ0aWNhbC1vdmVybGF5LW1lbnVcIixcImNzcy9iYXNlL2NvcmUvbWVudS9tZW51LXR5cGVzL3ZlcnRpY2FsLW1lbnVcIixcImNzcy9iYXNlL2NvcmUvbWVudS9tZW51LXR5cGVzL2hvcml6b250YWwtbWVudVwiLFwiY3NzL2Jhc2UvY29yZS9jb2xvcnMvcGFsZXR0ZS12YXJpYWJsZXNcIixcImNzcy9iYXNlL2NvcmUvY29sb3JzL3BhbGV0dGUtbm91aVwiLFwiY3NzL2Jhc2UvY29yZS9jb2xvcnMvcGFsZXR0ZS1ncmFkaWVudFwiLFwiY3NzL2Jhc2UvcGFnZXMvdWktZmVhdGhlclwiLFwiY3NzL2Jhc2UvcGFnZXMvcGFnZS1wcm9maWxlXCIsXCJjc3MvYmFzZS9wYWdlcy9wYWdlLXByaWNpbmdcIixcImNzcy9iYXNlL3BhZ2VzL3BhZ2UtbWlzY1wiLFwiY3NzL2Jhc2UvcGFnZXMvcGFnZS1rbm93bGVkZ2UtYmFzZVwiLFwiY3NzL2Jhc2UvcGFnZXMvcGFnZS1mYXFcIixcImNzcy9iYXNlL3BhZ2VzL3BhZ2UtY29taW5nLXNvb25cIixcImNzcy9iYXNlL3BhZ2VzL3BhZ2UtYmxvZ1wiLFwiY3NzL2Jhc2UvcGFnZXMvbW9kYWwtY3JlYXRlLWFwcFwiLFwiY3NzL2Jhc2UvcGFnZXMvZGFzaGJvYXJkLWVjb21tZXJjZVwiLFwiY3NzL2Jhc2UvcGFnZXMvYXV0aGVudGljYXRpb25cIixcImNzcy9iYXNlL3BhZ2VzL2FwcC10b2RvXCIsXCJjc3MvYmFzZS9wYWdlcy9hcHAta2FuYmFuXCIsXCJjc3MvYmFzZS9wYWdlcy9hcHAtaW52b2ljZVwiLFwiY3NzL2Jhc2UvcGFnZXMvYXBwLWludm9pY2UtcHJpbnRcIixcImNzcy9iYXNlL3BhZ2VzL2FwcC1pbnZvaWNlLWxpc3RcIixcImNzcy9iYXNlL3BhZ2VzL2FwcC1maWxlLW1hbmFnZXJcIixcImNzcy9iYXNlL3BhZ2VzL2FwcC1lbWFpbFwiLFwiY3NzL2Jhc2UvcGFnZXMvYXBwLWVjb21tZXJjZVwiLFwiY3NzL2Jhc2UvcGFnZXMvYXBwLWVjb21tZXJjZS1kZXRhaWxzXCIsXCJjc3MvYmFzZS9wYWdlcy9hcHAtY2hhdFwiLFwiY3NzL2Jhc2UvcGFnZXMvYXBwLWNoYXQtbGlzdFwiLFwiY3NzL2Jhc2UvcGFnZXMvYXBwLWNhbGVuZGFyXCIsXCJjc3MvYmFzZS9wbHVnaW5zL3VpL2NvbWluZy1zb29uXCIsXCJjc3MvYmFzZS9wbHVnaW5zL21hcHMvbWFwLWxlYWZsZXRcIixcImNzcy9iYXNlL3BsdWdpbnMvZm9ybXMvcGlja2Vycy9mb3JtLXBpY2thZGF0ZVwiLFwiY3NzL2Jhc2UvcGx1Z2lucy9mb3Jtcy9waWNrZXJzL2Zvcm0tZmxhdC1waWNrclwiLFwiY3NzL2Jhc2UvcGx1Z2lucy9mb3Jtcy9mb3JtLXdpemFyZFwiLFwiY3NzL2Jhc2UvcGx1Z2lucy9mb3Jtcy9mb3JtLXZhbGlkYXRpb25cIixcImNzcy9iYXNlL3BsdWdpbnMvZm9ybXMvZm9ybS1xdWlsbC1lZGl0b3JcIixcImNzcy9iYXNlL3BsdWdpbnMvZm9ybXMvZm9ybS1udW1iZXItaW5wdXRcIixcImNzcy9iYXNlL3BsdWdpbnMvZm9ybXMvZm9ybS1maWxlLXVwbG9hZGVyXCIsXCJjc3MvYmFzZS9wbHVnaW5zL2V4dGVuc2lvbnMvZXh0LWNvbXBvbmVudC10cmVlXCIsXCJjc3MvYmFzZS9wbHVnaW5zL2V4dGVuc2lvbnMvZXh0LWNvbXBvbmVudC10b3VyXCIsXCJjc3MvYmFzZS9wbHVnaW5zL2V4dGVuc2lvbnMvZXh0LWNvbXBvbmVudC10b2FzdHJcIixcImNzcy9iYXNlL3BsdWdpbnMvZXh0ZW5zaW9ucy9leHQtY29tcG9uZW50LXN3aXBlclwiLFwiY3NzL2Jhc2UvcGx1Z2lucy9leHRlbnNpb25zL2V4dC1jb21wb25lbnQtc3dlZXQtYWxlcnRzXCIsXCJjc3MvYmFzZS9wbHVnaW5zL2V4dGVuc2lvbnMvZXh0LWNvbXBvbmVudC1zbGlkZXJzXCIsXCJjc3MvYmFzZS9wbHVnaW5zL2V4dGVuc2lvbnMvZXh0LWNvbXBvbmVudC1yYXRpbmdzXCJdLCAoKSA9PiAoX193ZWJwYWNrX3JlcXVpcmVfXyhcIi4vcmVzb3VyY2VzL3Njc3MvYmFzZS9wYWdlcy9wYWdlLWtub3dsZWRnZS1iYXNlLnNjc3NcIikpKVxuX193ZWJwYWNrX3JlcXVpcmVfXy5PKHVuZGVmaW5lZCwgW1wiY3NzL2Jhc2UvcGx1Z2lucy9leHRlbnNpb25zL2V4dC1jb21wb25lbnQtbWVkaWEtcGxheWVyXCIsXCJjc3MvYmFzZS9wbHVnaW5zL2V4dGVuc2lvbnMvZXh0LWNvbXBvbmVudC1kcmFnLWRyb3BcIixcImNzcy9iYXNlL3BsdWdpbnMvZXh0ZW5zaW9ucy9leHQtY29tcG9uZW50LWNvbnRleHQtbWVudVwiLFwiY3NzL2Jhc2UvcGx1Z2lucy9jaGFydHMvY2hhcnQtYXBleFwiLFwiY3NzL3N0eWxlXCIsXCJjc3Mvb3ZlcnJpZGVzXCIsXCJjc3MvY29yZVwiLFwiY3NzL2Jhc2UvdGhlbWVzL2RhcmstbGF5b3V0XCIsXCJjc3MvYmFzZS9jb3JlL21peGlucy90cmFuc2l0aW9uc1wiLFwiY3NzL2Jhc2UvY29yZS9taXhpbnMvbWFpbi1tZW51LW1peGluXCIsXCJjc3MvYmFzZS9jb3JlL21peGlucy9oZXgycmdiXCIsXCJjc3MvYmFzZS9jb3JlL21peGlucy9hbGVydFwiLFwiY3NzL2Jhc2UvY29yZS9tZW51L21lbnUtdHlwZXMvdmVydGljYWwtb3ZlcmxheS1tZW51XCIsXCJjc3MvYmFzZS9jb3JlL21lbnUvbWVudS10eXBlcy92ZXJ0aWNhbC1tZW51XCIsXCJjc3MvYmFzZS9jb3JlL21lbnUvbWVudS10eXBlcy9ob3Jpem9udGFsLW1lbnVcIixcImNzcy9iYXNlL2NvcmUvY29sb3JzL3BhbGV0dGUtdmFyaWFibGVzXCIsXCJjc3MvYmFzZS9jb3JlL2NvbG9ycy9wYWxldHRlLW5vdWlcIixcImNzcy9iYXNlL2NvcmUvY29sb3JzL3BhbGV0dGUtZ3JhZGllbnRcIixcImNzcy9iYXNlL3BhZ2VzL3VpLWZlYXRoZXJcIixcImNzcy9iYXNlL3BhZ2VzL3BhZ2UtcHJvZmlsZVwiLFwiY3NzL2Jhc2UvcGFnZXMvcGFnZS1wcmljaW5nXCIsXCJjc3MvYmFzZS9wYWdlcy9wYWdlLW1pc2NcIixcImNzcy9iYXNlL3BhZ2VzL3BhZ2Uta25vd2xlZGdlLWJhc2VcIixcImNzcy9iYXNlL3BhZ2VzL3BhZ2UtZmFxXCIsXCJjc3MvYmFzZS9wYWdlcy9wYWdlLWNvbWluZy1zb29uXCIsXCJjc3MvYmFzZS9wYWdlcy9wYWdlLWJsb2dcIixcImNzcy9iYXNlL3BhZ2VzL21vZGFsLWNyZWF0ZS1hcHBcIixcImNzcy9iYXNlL3BhZ2VzL2Rhc2hib2FyZC1lY29tbWVyY2VcIixcImNzcy9iYXNlL3BhZ2VzL2F1dGhlbnRpY2F0aW9uXCIsXCJjc3MvYmFzZS9wYWdlcy9hcHAtdG9kb1wiLFwiY3NzL2Jhc2UvcGFnZXMvYXBwLWthbmJhblwiLFwiY3NzL2Jhc2UvcGFnZXMvYXBwLWludm9pY2VcIixcImNzcy9iYXNlL3BhZ2VzL2FwcC1pbnZvaWNlLXByaW50XCIsXCJjc3MvYmFzZS9wYWdlcy9hcHAtaW52b2ljZS1saXN0XCIsXCJjc3MvYmFzZS9wYWdlcy9hcHAtZmlsZS1tYW5hZ2VyXCIsXCJjc3MvYmFzZS9wYWdlcy9hcHAtZW1haWxcIixcImNzcy9iYXNlL3BhZ2VzL2FwcC1lY29tbWVyY2VcIixcImNzcy9iYXNlL3BhZ2VzL2FwcC1lY29tbWVyY2UtZGV0YWlsc1wiLFwiY3NzL2Jhc2UvcGFnZXMvYXBwLWNoYXRcIixcImNzcy9iYXNlL3BhZ2VzL2FwcC1jaGF0LWxpc3RcIixcImNzcy9iYXNlL3BhZ2VzL2FwcC1jYWxlbmRhclwiLFwiY3NzL2Jhc2UvcGx1Z2lucy91aS9jb21pbmctc29vblwiLFwiY3NzL2Jhc2UvcGx1Z2lucy9tYXBzL21hcC1sZWFmbGV0XCIsXCJjc3MvYmFzZS9wbHVnaW5zL2Zvcm1zL3BpY2tlcnMvZm9ybS1waWNrYWRhdGVcIixcImNzcy9iYXNlL3BsdWdpbnMvZm9ybXMvcGlja2Vycy9mb3JtLWZsYXQtcGlja3JcIixcImNzcy9iYXNlL3BsdWdpbnMvZm9ybXMvZm9ybS13aXphcmRcIixcImNzcy9iYXNlL3BsdWdpbnMvZm9ybXMvZm9ybS12YWxpZGF0aW9uXCIsXCJjc3MvYmFzZS9wbHVnaW5zL2Zvcm1zL2Zvcm0tcXVpbGwtZWRpdG9yXCIsXCJjc3MvYmFzZS9wbHVnaW5zL2Zvcm1zL2Zvcm0tbnVtYmVyLWlucHV0XCIsXCJjc3MvYmFzZS9wbHVnaW5zL2Zvcm1zL2Zvcm0tZmlsZS11cGxvYWRlclwiLFwiY3NzL2Jhc2UvcGx1Z2lucy9leHRlbnNpb25zL2V4dC1jb21wb25lbnQtdHJlZVwiLFwiY3NzL2Jhc2UvcGx1Z2lucy9leHRlbnNpb25zL2V4dC1jb21wb25lbnQtdG91clwiLFwiY3NzL2Jhc2UvcGx1Z2lucy9leHRlbnNpb25zL2V4dC1jb21wb25lbnQtdG9hc3RyXCIsXCJjc3MvYmFzZS9wbHVnaW5zL2V4dGVuc2lvbnMvZXh0LWNvbXBvbmVudC1zd2lwZXJcIixcImNzcy9iYXNlL3BsdWdpbnMvZXh0ZW5zaW9ucy9leHQtY29tcG9uZW50LXN3ZWV0LWFsZXJ0c1wiLFwiY3NzL2Jhc2UvcGx1Z2lucy9leHRlbnNpb25zL2V4dC1jb21wb25lbnQtc2xpZGVyc1wiLFwiY3NzL2Jhc2UvcGx1Z2lucy9leHRlbnNpb25zL2V4dC1jb21wb25lbnQtcmF0aW5nc1wiXSwgKCkgPT4gKF9fd2VicGFja19yZXF1aXJlX18oXCIuL3Jlc291cmNlcy9zY3NzL2Jhc2UvcGFnZXMvcGFnZS1taXNjLnNjc3NcIikpKVxuX193ZWJwYWNrX3JlcXVpcmVfXy5PKHVuZGVmaW5lZCwgW1wiY3NzL2Jhc2UvcGx1Z2lucy9leHRlbnNpb25zL2V4dC1jb21wb25lbnQtbWVkaWEtcGxheWVyXCIsXCJjc3MvYmFzZS9wbHVnaW5zL2V4dGVuc2lvbnMvZXh0LWNvbXBvbmVudC1kcmFnLWRyb3BcIixcImNzcy9iYXNlL3BsdWdpbnMvZXh0ZW5zaW9ucy9leHQtY29tcG9uZW50LWNvbnRleHQtbWVudVwiLFwiY3NzL2Jhc2UvcGx1Z2lucy9jaGFydHMvY2hhcnQtYXBleFwiLFwiY3NzL3N0eWxlXCIsXCJjc3Mvb3ZlcnJpZGVzXCIsXCJjc3MvY29yZVwiLFwiY3NzL2Jhc2UvdGhlbWVzL2RhcmstbGF5b3V0XCIsXCJjc3MvYmFzZS9jb3JlL21peGlucy90cmFuc2l0aW9uc1wiLFwiY3NzL2Jhc2UvY29yZS9taXhpbnMvbWFpbi1tZW51LW1peGluXCIsXCJjc3MvYmFzZS9jb3JlL21peGlucy9oZXgycmdiXCIsXCJjc3MvYmFzZS9jb3JlL21peGlucy9hbGVydFwiLFwiY3NzL2Jhc2UvY29yZS9tZW51L21lbnUtdHlwZXMvdmVydGljYWwtb3ZlcmxheS1tZW51XCIsXCJjc3MvYmFzZS9jb3JlL21lbnUvbWVudS10eXBlcy92ZXJ0aWNhbC1tZW51XCIsXCJjc3MvYmFzZS9jb3JlL21lbnUvbWVudS10eXBlcy9ob3Jpem9udGFsLW1lbnVcIixcImNzcy9iYXNlL2NvcmUvY29sb3JzL3BhbGV0dGUtdmFyaWFibGVzXCIsXCJjc3MvYmFzZS9jb3JlL2NvbG9ycy9wYWxldHRlLW5vdWlcIixcImNzcy9iYXNlL2NvcmUvY29sb3JzL3BhbGV0dGUtZ3JhZGllbnRcIixcImNzcy9iYXNlL3BhZ2VzL3VpLWZlYXRoZXJcIixcImNzcy9iYXNlL3BhZ2VzL3BhZ2UtcHJvZmlsZVwiLFwiY3NzL2Jhc2UvcGFnZXMvcGFnZS1wcmljaW5nXCIsXCJjc3MvYmFzZS9wYWdlcy9wYWdlLW1pc2NcIixcImNzcy9iYXNlL3BhZ2VzL3BhZ2Uta25vd2xlZGdlLWJhc2VcIixcImNzcy9iYXNlL3BhZ2VzL3BhZ2UtZmFxXCIsXCJjc3MvYmFzZS9wYWdlcy9wYWdlLWNvbWluZy1zb29uXCIsXCJjc3MvYmFzZS9wYWdlcy9wYWdlLWJsb2dcIixcImNzcy9iYXNlL3BhZ2VzL21vZGFsLWNyZWF0ZS1hcHBcIixcImNzcy9iYXNlL3BhZ2VzL2Rhc2hib2FyZC1lY29tbWVyY2VcIixcImNzcy9iYXNlL3BhZ2VzL2F1dGhlbnRpY2F0aW9uXCIsXCJjc3MvYmFzZS9wYWdlcy9hcHAtdG9kb1wiLFwiY3NzL2Jhc2UvcGFnZXMvYXBwLWthbmJhblwiLFwiY3NzL2Jhc2UvcGFnZXMvYXBwLWludm9pY2VcIixcImNzcy9iYXNlL3BhZ2VzL2FwcC1pbnZvaWNlLXByaW50XCIsXCJjc3MvYmFzZS9wYWdlcy9hcHAtaW52b2ljZS1saXN0XCIsXCJjc3MvYmFzZS9wYWdlcy9hcHAtZmlsZS1tYW5hZ2VyXCIsXCJjc3MvYmFzZS9wYWdlcy9hcHAtZW1haWxcIixcImNzcy9iYXNlL3BhZ2VzL2FwcC1lY29tbWVyY2VcIixcImNzcy9iYXNlL3BhZ2VzL2FwcC1lY29tbWVyY2UtZGV0YWlsc1wiLFwiY3NzL2Jhc2UvcGFnZXMvYXBwLWNoYXRcIixcImNzcy9iYXNlL3BhZ2VzL2FwcC1jaGF0LWxpc3RcIixcImNzcy9iYXNlL3BhZ2VzL2FwcC1jYWxlbmRhclwiLFwiY3NzL2Jhc2UvcGx1Z2lucy91aS9jb21pbmctc29vblwiLFwiY3NzL2Jhc2UvcGx1Z2lucy9tYXBzL21hcC1sZWFmbGV0XCIsXCJjc3MvYmFzZS9wbHVnaW5zL2Zvcm1zL3BpY2tlcnMvZm9ybS1waWNrYWRhdGVcIixcImNzcy9iYXNlL3BsdWdpbnMvZm9ybXMvcGlja2Vycy9mb3JtLWZsYXQtcGlja3JcIixcImNzcy9iYXNlL3BsdWdpbnMvZm9ybXMvZm9ybS13aXphcmRcIixcImNzcy9iYXNlL3BsdWdpbnMvZm9ybXMvZm9ybS12YWxpZGF0aW9uXCIsXCJjc3MvYmFzZS9wbHVnaW5zL2Zvcm1zL2Zvcm0tcXVpbGwtZWRpdG9yXCIsXCJjc3MvYmFzZS9wbHVnaW5zL2Zvcm1zL2Zvcm0tbnVtYmVyLWlucHV0XCIsXCJjc3MvYmFzZS9wbHVnaW5zL2Zvcm1zL2Zvcm0tZmlsZS11cGxvYWRlclwiLFwiY3NzL2Jhc2UvcGx1Z2lucy9leHRlbnNpb25zL2V4dC1jb21wb25lbnQtdHJlZVwiLFwiY3NzL2Jhc2UvcGx1Z2lucy9leHRlbnNpb25zL2V4dC1jb21wb25lbnQtdG91clwiLFwiY3NzL2Jhc2UvcGx1Z2lucy9leHRlbnNpb25zL2V4dC1jb21wb25lbnQtdG9hc3RyXCIsXCJjc3MvYmFzZS9wbHVnaW5zL2V4dGVuc2lvbnMvZXh0LWNvbXBvbmVudC1zd2lwZXJcIixcImNzcy9iYXNlL3BsdWdpbnMvZXh0ZW5zaW9ucy9leHQtY29tcG9uZW50LXN3ZWV0LWFsZXJ0c1wiLFwiY3NzL2Jhc2UvcGx1Z2lucy9leHRlbnNpb25zL2V4dC1jb21wb25lbnQtc2xpZGVyc1wiLFwiY3NzL2Jhc2UvcGx1Z2lucy9leHRlbnNpb25zL2V4dC1jb21wb25lbnQtcmF0aW5nc1wiXSwgKCkgPT4gKF9fd2VicGFja19yZXF1aXJlX18oXCIuL3Jlc291cmNlcy9zY3NzL2Jhc2UvcGFnZXMvcGFnZS1wcmljaW5nLnNjc3NcIikpKVxuX193ZWJwYWNrX3JlcXVpcmVfXy5PKHVuZGVmaW5lZCwgW1wiY3NzL2Jhc2UvcGx1Z2lucy9leHRlbnNpb25zL2V4dC1jb21wb25lbnQtbWVkaWEtcGxheWVyXCIsXCJjc3MvYmFzZS9wbHVnaW5zL2V4dGVuc2lvbnMvZXh0LWNvbXBvbmVudC1kcmFnLWRyb3BcIixcImNzcy9iYXNlL3BsdWdpbnMvZXh0ZW5zaW9ucy9leHQtY29tcG9uZW50LWNvbnRleHQtbWVudVwiLFwiY3NzL2Jhc2UvcGx1Z2lucy9jaGFydHMvY2hhcnQtYXBleFwiLFwiY3NzL3N0eWxlXCIsXCJjc3Mvb3ZlcnJpZGVzXCIsXCJjc3MvY29yZVwiLFwiY3NzL2Jhc2UvdGhlbWVzL2RhcmstbGF5b3V0XCIsXCJjc3MvYmFzZS9jb3JlL21peGlucy90cmFuc2l0aW9uc1wiLFwiY3NzL2Jhc2UvY29yZS9taXhpbnMvbWFpbi1tZW51LW1peGluXCIsXCJjc3MvYmFzZS9jb3JlL21peGlucy9oZXgycmdiXCIsXCJjc3MvYmFzZS9jb3JlL21peGlucy9hbGVydFwiLFwiY3NzL2Jhc2UvY29yZS9tZW51L21lbnUtdHlwZXMvdmVydGljYWwtb3ZlcmxheS1tZW51XCIsXCJjc3MvYmFzZS9jb3JlL21lbnUvbWVudS10eXBlcy92ZXJ0aWNhbC1tZW51XCIsXCJjc3MvYmFzZS9jb3JlL21lbnUvbWVudS10eXBlcy9ob3Jpem9udGFsLW1lbnVcIixcImNzcy9iYXNlL2NvcmUvY29sb3JzL3BhbGV0dGUtdmFyaWFibGVzXCIsXCJjc3MvYmFzZS9jb3JlL2NvbG9ycy9wYWxldHRlLW5vdWlcIixcImNzcy9iYXNlL2NvcmUvY29sb3JzL3BhbGV0dGUtZ3JhZGllbnRcIixcImNzcy9iYXNlL3BhZ2VzL3VpLWZlYXRoZXJcIixcImNzcy9iYXNlL3BhZ2VzL3BhZ2UtcHJvZmlsZVwiLFwiY3NzL2Jhc2UvcGFnZXMvcGFnZS1wcmljaW5nXCIsXCJjc3MvYmFzZS9wYWdlcy9wYWdlLW1pc2NcIixcImNzcy9iYXNlL3BhZ2VzL3BhZ2Uta25vd2xlZGdlLWJhc2VcIixcImNzcy9iYXNlL3BhZ2VzL3BhZ2UtZmFxXCIsXCJjc3MvYmFzZS9wYWdlcy9wYWdlLWNvbWluZy1zb29uXCIsXCJjc3MvYmFzZS9wYWdlcy9wYWdlLWJsb2dcIixcImNzcy9iYXNlL3BhZ2VzL21vZGFsLWNyZWF0ZS1hcHBcIixcImNzcy9iYXNlL3BhZ2VzL2Rhc2hib2FyZC1lY29tbWVyY2VcIixcImNzcy9iYXNlL3BhZ2VzL2F1dGhlbnRpY2F0aW9uXCIsXCJjc3MvYmFzZS9wYWdlcy9hcHAtdG9kb1wiLFwiY3NzL2Jhc2UvcGFnZXMvYXBwLWthbmJhblwiLFwiY3NzL2Jhc2UvcGFnZXMvYXBwLWludm9pY2VcIixcImNzcy9iYXNlL3BhZ2VzL2FwcC1pbnZvaWNlLXByaW50XCIsXCJjc3MvYmFzZS9wYWdlcy9hcHAtaW52b2ljZS1saXN0XCIsXCJjc3MvYmFzZS9wYWdlcy9hcHAtZmlsZS1tYW5hZ2VyXCIsXCJjc3MvYmFzZS9wYWdlcy9hcHAtZW1haWxcIixcImNzcy9iYXNlL3BhZ2VzL2FwcC1lY29tbWVyY2VcIixcImNzcy9iYXNlL3BhZ2VzL2FwcC1lY29tbWVyY2UtZGV0YWlsc1wiLFwiY3NzL2Jhc2UvcGFnZXMvYXBwLWNoYXRcIixcImNzcy9iYXNlL3BhZ2VzL2FwcC1jaGF0LWxpc3RcIixcImNzcy9iYXNlL3BhZ2VzL2FwcC1jYWxlbmRhclwiLFwiY3NzL2Jhc2UvcGx1Z2lucy91aS9jb21pbmctc29vblwiLFwiY3NzL2Jhc2UvcGx1Z2lucy9tYXBzL21hcC1sZWFmbGV0XCIsXCJjc3MvYmFzZS9wbHVnaW5zL2Zvcm1zL3BpY2tlcnMvZm9ybS1waWNrYWRhdGVcIixcImNzcy9iYXNlL3BsdWdpbnMvZm9ybXMvcGlja2Vycy9mb3JtLWZsYXQtcGlja3JcIixcImNzcy9iYXNlL3BsdWdpbnMvZm9ybXMvZm9ybS13aXphcmRcIixcImNzcy9iYXNlL3BsdWdpbnMvZm9ybXMvZm9ybS12YWxpZGF0aW9uXCIsXCJjc3MvYmFzZS9wbHVnaW5zL2Zvcm1zL2Zvcm0tcXVpbGwtZWRpdG9yXCIsXCJjc3MvYmFzZS9wbHVnaW5zL2Zvcm1zL2Zvcm0tbnVtYmVyLWlucHV0XCIsXCJjc3MvYmFzZS9wbHVnaW5zL2Zvcm1zL2Zvcm0tZmlsZS11cGxvYWRlclwiLFwiY3NzL2Jhc2UvcGx1Z2lucy9leHRlbnNpb25zL2V4dC1jb21wb25lbnQtdHJlZVwiLFwiY3NzL2Jhc2UvcGx1Z2lucy9leHRlbnNpb25zL2V4dC1jb21wb25lbnQtdG91clwiLFwiY3NzL2Jhc2UvcGx1Z2lucy9leHRlbnNpb25zL2V4dC1jb21wb25lbnQtdG9hc3RyXCIsXCJjc3MvYmFzZS9wbHVnaW5zL2V4dGVuc2lvbnMvZXh0LWNvbXBvbmVudC1zd2lwZXJcIixcImNzcy9iYXNlL3BsdWdpbnMvZXh0ZW5zaW9ucy9leHQtY29tcG9uZW50LXN3ZWV0LWFsZXJ0c1wiLFwiY3NzL2Jhc2UvcGx1Z2lucy9leHRlbnNpb25zL2V4dC1jb21wb25lbnQtc2xpZGVyc1wiLFwiY3NzL2Jhc2UvcGx1Z2lucy9leHRlbnNpb25zL2V4dC1jb21wb25lbnQtcmF0aW5nc1wiXSwgKCkgPT4gKF9fd2VicGFja19yZXF1aXJlX18oXCIuL3Jlc291cmNlcy9zY3NzL2Jhc2UvcGFnZXMvcGFnZS1wcm9maWxlLnNjc3NcIikpKVxuX193ZWJwYWNrX3JlcXVpcmVfXy5PKHVuZGVmaW5lZCwgW1wiY3NzL2Jhc2UvcGx1Z2lucy9leHRlbnNpb25zL2V4dC1jb21wb25lbnQtbWVkaWEtcGxheWVyXCIsXCJjc3MvYmFzZS9wbHVnaW5zL2V4dGVuc2lvbnMvZXh0LWNvbXBvbmVudC1kcmFnLWRyb3BcIixcImNzcy9iYXNlL3BsdWdpbnMvZXh0ZW5zaW9ucy9leHQtY29tcG9uZW50LWNvbnRleHQtbWVudVwiLFwiY3NzL2Jhc2UvcGx1Z2lucy9jaGFydHMvY2hhcnQtYXBleFwiLFwiY3NzL3N0eWxlXCIsXCJjc3Mvb3ZlcnJpZGVzXCIsXCJjc3MvY29yZVwiLFwiY3NzL2Jhc2UvdGhlbWVzL2RhcmstbGF5b3V0XCIsXCJjc3MvYmFzZS9jb3JlL21peGlucy90cmFuc2l0aW9uc1wiLFwiY3NzL2Jhc2UvY29yZS9taXhpbnMvbWFpbi1tZW51LW1peGluXCIsXCJjc3MvYmFzZS9jb3JlL21peGlucy9oZXgycmdiXCIsXCJjc3MvYmFzZS9jb3JlL21peGlucy9hbGVydFwiLFwiY3NzL2Jhc2UvY29yZS9tZW51L21lbnUtdHlwZXMvdmVydGljYWwtb3ZlcmxheS1tZW51XCIsXCJjc3MvYmFzZS9jb3JlL21lbnUvbWVudS10eXBlcy92ZXJ0aWNhbC1tZW51XCIsXCJjc3MvYmFzZS9jb3JlL21lbnUvbWVudS10eXBlcy9ob3Jpem9udGFsLW1lbnVcIixcImNzcy9iYXNlL2NvcmUvY29sb3JzL3BhbGV0dGUtdmFyaWFibGVzXCIsXCJjc3MvYmFzZS9jb3JlL2NvbG9ycy9wYWxldHRlLW5vdWlcIixcImNzcy9iYXNlL2NvcmUvY29sb3JzL3BhbGV0dGUtZ3JhZGllbnRcIixcImNzcy9iYXNlL3BhZ2VzL3VpLWZlYXRoZXJcIixcImNzcy9iYXNlL3BhZ2VzL3BhZ2UtcHJvZmlsZVwiLFwiY3NzL2Jhc2UvcGFnZXMvcGFnZS1wcmljaW5nXCIsXCJjc3MvYmFzZS9wYWdlcy9wYWdlLW1pc2NcIixcImNzcy9iYXNlL3BhZ2VzL3BhZ2Uta25vd2xlZGdlLWJhc2VcIixcImNzcy9iYXNlL3BhZ2VzL3BhZ2UtZmFxXCIsXCJjc3MvYmFzZS9wYWdlcy9wYWdlLWNvbWluZy1zb29uXCIsXCJjc3MvYmFzZS9wYWdlcy9wYWdlLWJsb2dcIixcImNzcy9iYXNlL3BhZ2VzL21vZGFsLWNyZWF0ZS1hcHBcIixcImNzcy9iYXNlL3BhZ2VzL2Rhc2hib2FyZC1lY29tbWVyY2VcIixcImNzcy9iYXNlL3BhZ2VzL2F1dGhlbnRpY2F0aW9uXCIsXCJjc3MvYmFzZS9wYWdlcy9hcHAtdG9kb1wiLFwiY3NzL2Jhc2UvcGFnZXMvYXBwLWthbmJhblwiLFwiY3NzL2Jhc2UvcGFnZXMvYXBwLWludm9pY2VcIixcImNzcy9iYXNlL3BhZ2VzL2FwcC1pbnZvaWNlLXByaW50XCIsXCJjc3MvYmFzZS9wYWdlcy9hcHAtaW52b2ljZS1saXN0XCIsXCJjc3MvYmFzZS9wYWdlcy9hcHAtZmlsZS1tYW5hZ2VyXCIsXCJjc3MvYmFzZS9wYWdlcy9hcHAtZW1haWxcIixcImNzcy9iYXNlL3BhZ2VzL2FwcC1lY29tbWVyY2VcIixcImNzcy9iYXNlL3BhZ2VzL2FwcC1lY29tbWVyY2UtZGV0YWlsc1wiLFwiY3NzL2Jhc2UvcGFnZXMvYXBwLWNoYXRcIixcImNzcy9iYXNlL3BhZ2VzL2FwcC1jaGF0LWxpc3RcIixcImNzcy9iYXNlL3BhZ2VzL2FwcC1jYWxlbmRhclwiLFwiY3NzL2Jhc2UvcGx1Z2lucy91aS9jb21pbmctc29vblwiLFwiY3NzL2Jhc2UvcGx1Z2lucy9tYXBzL21hcC1sZWFmbGV0XCIsXCJjc3MvYmFzZS9wbHVnaW5zL2Zvcm1zL3BpY2tlcnMvZm9ybS1waWNrYWRhdGVcIixcImNzcy9iYXNlL3BsdWdpbnMvZm9ybXMvcGlja2Vycy9mb3JtLWZsYXQtcGlja3JcIixcImNzcy9iYXNlL3BsdWdpbnMvZm9ybXMvZm9ybS13aXphcmRcIixcImNzcy9iYXNlL3BsdWdpbnMvZm9ybXMvZm9ybS12YWxpZGF0aW9uXCIsXCJjc3MvYmFzZS9wbHVnaW5zL2Zvcm1zL2Zvcm0tcXVpbGwtZWRpdG9yXCIsXCJjc3MvYmFzZS9wbHVnaW5zL2Zvcm1zL2Zvcm0tbnVtYmVyLWlucHV0XCIsXCJjc3MvYmFzZS9wbHVnaW5zL2Zvcm1zL2Zvcm0tZmlsZS11cGxvYWRlclwiLFwiY3NzL2Jhc2UvcGx1Z2lucy9leHRlbnNpb25zL2V4dC1jb21wb25lbnQtdHJlZVwiLFwiY3NzL2Jhc2UvcGx1Z2lucy9leHRlbnNpb25zL2V4dC1jb21wb25lbnQtdG91clwiLFwiY3NzL2Jhc2UvcGx1Z2lucy9leHRlbnNpb25zL2V4dC1jb21wb25lbnQtdG9hc3RyXCIsXCJjc3MvYmFzZS9wbHVnaW5zL2V4dGVuc2lvbnMvZXh0LWNvbXBvbmVudC1zd2lwZXJcIixcImNzcy9iYXNlL3BsdWdpbnMvZXh0ZW5zaW9ucy9leHQtY29tcG9uZW50LXN3ZWV0LWFsZXJ0c1wiLFwiY3NzL2Jhc2UvcGx1Z2lucy9leHRlbnNpb25zL2V4dC1jb21wb25lbnQtc2xpZGVyc1wiLFwiY3NzL2Jhc2UvcGx1Z2lucy9leHRlbnNpb25zL2V4dC1jb21wb25lbnQtcmF0aW5nc1wiXSwgKCkgPT4gKF9fd2VicGFja19yZXF1aXJlX18oXCIuL3Jlc291cmNlcy9zY3NzL2Jhc2UvcGFnZXMvdWktZmVhdGhlci5zY3NzXCIpKSlcbl9fd2VicGFja19yZXF1aXJlX18uTyh1bmRlZmluZWQsIFtcImNzcy9iYXNlL3BsdWdpbnMvZXh0ZW5zaW9ucy9leHQtY29tcG9uZW50LW1lZGlhLXBsYXllclwiLFwiY3NzL2Jhc2UvcGx1Z2lucy9leHRlbnNpb25zL2V4dC1jb21wb25lbnQtZHJhZy1kcm9wXCIsXCJjc3MvYmFzZS9wbHVnaW5zL2V4dGVuc2lvbnMvZXh0LWNvbXBvbmVudC1jb250ZXh0LW1lbnVcIixcImNzcy9iYXNlL3BsdWdpbnMvY2hhcnRzL2NoYXJ0LWFwZXhcIixcImNzcy9zdHlsZVwiLFwiY3NzL292ZXJyaWRlc1wiLFwiY3NzL2NvcmVcIixcImNzcy9iYXNlL3RoZW1lcy9kYXJrLWxheW91dFwiLFwiY3NzL2Jhc2UvY29yZS9taXhpbnMvdHJhbnNpdGlvbnNcIixcImNzcy9iYXNlL2NvcmUvbWl4aW5zL21haW4tbWVudS1taXhpblwiLFwiY3NzL2Jhc2UvY29yZS9taXhpbnMvaGV4MnJnYlwiLFwiY3NzL2Jhc2UvY29yZS9taXhpbnMvYWxlcnRcIixcImNzcy9iYXNlL2NvcmUvbWVudS9tZW51LXR5cGVzL3ZlcnRpY2FsLW92ZXJsYXktbWVudVwiLFwiY3NzL2Jhc2UvY29yZS9tZW51L21lbnUtdHlwZXMvdmVydGljYWwtbWVudVwiLFwiY3NzL2Jhc2UvY29yZS9tZW51L21lbnUtdHlwZXMvaG9yaXpvbnRhbC1tZW51XCIsXCJjc3MvYmFzZS9jb3JlL2NvbG9ycy9wYWxldHRlLXZhcmlhYmxlc1wiLFwiY3NzL2Jhc2UvY29yZS9jb2xvcnMvcGFsZXR0ZS1ub3VpXCIsXCJjc3MvYmFzZS9jb3JlL2NvbG9ycy9wYWxldHRlLWdyYWRpZW50XCIsXCJjc3MvYmFzZS9wYWdlcy91aS1mZWF0aGVyXCIsXCJjc3MvYmFzZS9wYWdlcy9wYWdlLXByb2ZpbGVcIixcImNzcy9iYXNlL3BhZ2VzL3BhZ2UtcHJpY2luZ1wiLFwiY3NzL2Jhc2UvcGFnZXMvcGFnZS1taXNjXCIsXCJjc3MvYmFzZS9wYWdlcy9wYWdlLWtub3dsZWRnZS1iYXNlXCIsXCJjc3MvYmFzZS9wYWdlcy9wYWdlLWZhcVwiLFwiY3NzL2Jhc2UvcGFnZXMvcGFnZS1jb21pbmctc29vblwiLFwiY3NzL2Jhc2UvcGFnZXMvcGFnZS1ibG9nXCIsXCJjc3MvYmFzZS9wYWdlcy9tb2RhbC1jcmVhdGUtYXBwXCIsXCJjc3MvYmFzZS9wYWdlcy9kYXNoYm9hcmQtZWNvbW1lcmNlXCIsXCJjc3MvYmFzZS9wYWdlcy9hdXRoZW50aWNhdGlvblwiLFwiY3NzL2Jhc2UvcGFnZXMvYXBwLXRvZG9cIixcImNzcy9iYXNlL3BhZ2VzL2FwcC1rYW5iYW5cIixcImNzcy9iYXNlL3BhZ2VzL2FwcC1pbnZvaWNlXCIsXCJjc3MvYmFzZS9wYWdlcy9hcHAtaW52b2ljZS1wcmludFwiLFwiY3NzL2Jhc2UvcGFnZXMvYXBwLWludm9pY2UtbGlzdFwiLFwiY3NzL2Jhc2UvcGFnZXMvYXBwLWZpbGUtbWFuYWdlclwiLFwiY3NzL2Jhc2UvcGFnZXMvYXBwLWVtYWlsXCIsXCJjc3MvYmFzZS9wYWdlcy9hcHAtZWNvbW1lcmNlXCIsXCJjc3MvYmFzZS9wYWdlcy9hcHAtZWNvbW1lcmNlLWRldGFpbHNcIixcImNzcy9iYXNlL3BhZ2VzL2FwcC1jaGF0XCIsXCJjc3MvYmFzZS9wYWdlcy9hcHAtY2hhdC1saXN0XCIsXCJjc3MvYmFzZS9wYWdlcy9hcHAtY2FsZW5kYXJcIixcImNzcy9iYXNlL3BsdWdpbnMvdWkvY29taW5nLXNvb25cIixcImNzcy9iYXNlL3BsdWdpbnMvbWFwcy9tYXAtbGVhZmxldFwiLFwiY3NzL2Jhc2UvcGx1Z2lucy9mb3Jtcy9waWNrZXJzL2Zvcm0tcGlja2FkYXRlXCIsXCJjc3MvYmFzZS9wbHVnaW5zL2Zvcm1zL3BpY2tlcnMvZm9ybS1mbGF0LXBpY2tyXCIsXCJjc3MvYmFzZS9wbHVnaW5zL2Zvcm1zL2Zvcm0td2l6YXJkXCIsXCJjc3MvYmFzZS9wbHVnaW5zL2Zvcm1zL2Zvcm0tdmFsaWRhdGlvblwiLFwiY3NzL2Jhc2UvcGx1Z2lucy9mb3Jtcy9mb3JtLXF1aWxsLWVkaXRvclwiLFwiY3NzL2Jhc2UvcGx1Z2lucy9mb3Jtcy9mb3JtLW51bWJlci1pbnB1dFwiLFwiY3NzL2Jhc2UvcGx1Z2lucy9mb3Jtcy9mb3JtLWZpbGUtdXBsb2FkZXJcIixcImNzcy9iYXNlL3BsdWdpbnMvZXh0ZW5zaW9ucy9leHQtY29tcG9uZW50LXRyZWVcIixcImNzcy9iYXNlL3BsdWdpbnMvZXh0ZW5zaW9ucy9leHQtY29tcG9uZW50LXRvdXJcIixcImNzcy9iYXNlL3BsdWdpbnMvZXh0ZW5zaW9ucy9leHQtY29tcG9uZW50LXRvYXN0clwiLFwiY3NzL2Jhc2UvcGx1Z2lucy9leHRlbnNpb25zL2V4dC1jb21wb25lbnQtc3dpcGVyXCIsXCJjc3MvYmFzZS9wbHVnaW5zL2V4dGVuc2lvbnMvZXh0LWNvbXBvbmVudC1zd2VldC1hbGVydHNcIixcImNzcy9iYXNlL3BsdWdpbnMvZXh0ZW5zaW9ucy9leHQtY29tcG9uZW50LXNsaWRlcnNcIixcImNzcy9iYXNlL3BsdWdpbnMvZXh0ZW5zaW9ucy9leHQtY29tcG9uZW50LXJhdGluZ3NcIl0sICgpID0+IChfX3dlYnBhY2tfcmVxdWlyZV9fKFwiLi9yZXNvdXJjZXMvc2Nzcy9iYXNlL2NvcmUvY29sb3JzL3BhbGV0dGUtZ3JhZGllbnQuc2Nzc1wiKSkpXG5fX3dlYnBhY2tfcmVxdWlyZV9fLk8odW5kZWZpbmVkLCBbXCJjc3MvYmFzZS9wbHVnaW5zL2V4dGVuc2lvbnMvZXh0LWNvbXBvbmVudC1tZWRpYS1wbGF5ZXJcIixcImNzcy9iYXNlL3BsdWdpbnMvZXh0ZW5zaW9ucy9leHQtY29tcG9uZW50LWRyYWctZHJvcFwiLFwiY3NzL2Jhc2UvcGx1Z2lucy9leHRlbnNpb25zL2V4dC1jb21wb25lbnQtY29udGV4dC1tZW51XCIsXCJjc3MvYmFzZS9wbHVnaW5zL2NoYXJ0cy9jaGFydC1hcGV4XCIsXCJjc3Mvc3R5bGVcIixcImNzcy9vdmVycmlkZXNcIixcImNzcy9jb3JlXCIsXCJjc3MvYmFzZS90aGVtZXMvZGFyay1sYXlvdXRcIixcImNzcy9iYXNlL2NvcmUvbWl4aW5zL3RyYW5zaXRpb25zXCIsXCJjc3MvYmFzZS9jb3JlL21peGlucy9tYWluLW1lbnUtbWl4aW5cIixcImNzcy9iYXNlL2NvcmUvbWl4aW5zL2hleDJyZ2JcIixcImNzcy9iYXNlL2NvcmUvbWl4aW5zL2FsZXJ0XCIsXCJjc3MvYmFzZS9jb3JlL21lbnUvbWVudS10eXBlcy92ZXJ0aWNhbC1vdmVybGF5LW1lbnVcIixcImNzcy9iYXNlL2NvcmUvbWVudS9tZW51LXR5cGVzL3ZlcnRpY2FsLW1lbnVcIixcImNzcy9iYXNlL2NvcmUvbWVudS9tZW51LXR5cGVzL2hvcml6b250YWwtbWVudVwiLFwiY3NzL2Jhc2UvY29yZS9jb2xvcnMvcGFsZXR0ZS12YXJpYWJsZXNcIixcImNzcy9iYXNlL2NvcmUvY29sb3JzL3BhbGV0dGUtbm91aVwiLFwiY3NzL2Jhc2UvY29yZS9jb2xvcnMvcGFsZXR0ZS1ncmFkaWVudFwiLFwiY3NzL2Jhc2UvcGFnZXMvdWktZmVhdGhlclwiLFwiY3NzL2Jhc2UvcGFnZXMvcGFnZS1wcm9maWxlXCIsXCJjc3MvYmFzZS9wYWdlcy9wYWdlLXByaWNpbmdcIixcImNzcy9iYXNlL3BhZ2VzL3BhZ2UtbWlzY1wiLFwiY3NzL2Jhc2UvcGFnZXMvcGFnZS1rbm93bGVkZ2UtYmFzZVwiLFwiY3NzL2Jhc2UvcGFnZXMvcGFnZS1mYXFcIixcImNzcy9iYXNlL3BhZ2VzL3BhZ2UtY29taW5nLXNvb25cIixcImNzcy9iYXNlL3BhZ2VzL3BhZ2UtYmxvZ1wiLFwiY3NzL2Jhc2UvcGFnZXMvbW9kYWwtY3JlYXRlLWFwcFwiLFwiY3NzL2Jhc2UvcGFnZXMvZGFzaGJvYXJkLWVjb21tZXJjZVwiLFwiY3NzL2Jhc2UvcGFnZXMvYXV0aGVudGljYXRpb25cIixcImNzcy9iYXNlL3BhZ2VzL2FwcC10b2RvXCIsXCJjc3MvYmFzZS9wYWdlcy9hcHAta2FuYmFuXCIsXCJjc3MvYmFzZS9wYWdlcy9hcHAtaW52b2ljZVwiLFwiY3NzL2Jhc2UvcGFnZXMvYXBwLWludm9pY2UtcHJpbnRcIixcImNzcy9iYXNlL3BhZ2VzL2FwcC1pbnZvaWNlLWxpc3RcIixcImNzcy9iYXNlL3BhZ2VzL2FwcC1maWxlLW1hbmFnZXJcIixcImNzcy9iYXNlL3BhZ2VzL2FwcC1lbWFpbFwiLFwiY3NzL2Jhc2UvcGFnZXMvYXBwLWVjb21tZXJjZVwiLFwiY3NzL2Jhc2UvcGFnZXMvYXBwLWVjb21tZXJjZS1kZXRhaWxzXCIsXCJjc3MvYmFzZS9wYWdlcy9hcHAtY2hhdFwiLFwiY3NzL2Jhc2UvcGFnZXMvYXBwLWNoYXQtbGlzdFwiLFwiY3NzL2Jhc2UvcGFnZXMvYXBwLWNhbGVuZGFyXCIsXCJjc3MvYmFzZS9wbHVnaW5zL3VpL2NvbWluZy1zb29uXCIsXCJjc3MvYmFzZS9wbHVnaW5zL21hcHMvbWFwLWxlYWZsZXRcIixcImNzcy9iYXNlL3BsdWdpbnMvZm9ybXMvcGlja2Vycy9mb3JtLXBpY2thZGF0ZVwiLFwiY3NzL2Jhc2UvcGx1Z2lucy9mb3Jtcy9waWNrZXJzL2Zvcm0tZmxhdC1waWNrclwiLFwiY3NzL2Jhc2UvcGx1Z2lucy9mb3Jtcy9mb3JtLXdpemFyZFwiLFwiY3NzL2Jhc2UvcGx1Z2lucy9mb3Jtcy9mb3JtLXZhbGlkYXRpb25cIixcImNzcy9iYXNlL3BsdWdpbnMvZm9ybXMvZm9ybS1xdWlsbC1lZGl0b3JcIixcImNzcy9iYXNlL3BsdWdpbnMvZm9ybXMvZm9ybS1udW1iZXItaW5wdXRcIixcImNzcy9iYXNlL3BsdWdpbnMvZm9ybXMvZm9ybS1maWxlLXVwbG9hZGVyXCIsXCJjc3MvYmFzZS9wbHVnaW5zL2V4dGVuc2lvbnMvZXh0LWNvbXBvbmVudC10cmVlXCIsXCJjc3MvYmFzZS9wbHVnaW5zL2V4dGVuc2lvbnMvZXh0LWNvbXBvbmVudC10b3VyXCIsXCJjc3MvYmFzZS9wbHVnaW5zL2V4dGVuc2lvbnMvZXh0LWNvbXBvbmVudC10b2FzdHJcIixcImNzcy9iYXNlL3BsdWdpbnMvZXh0ZW5zaW9ucy9leHQtY29tcG9uZW50LXN3aXBlclwiLFwiY3NzL2Jhc2UvcGx1Z2lucy9leHRlbnNpb25zL2V4dC1jb21wb25lbnQtc3dlZXQtYWxlcnRzXCIsXCJjc3MvYmFzZS9wbHVnaW5zL2V4dGVuc2lvbnMvZXh0LWNvbXBvbmVudC1zbGlkZXJzXCIsXCJjc3MvYmFzZS9wbHVnaW5zL2V4dGVuc2lvbnMvZXh0LWNvbXBvbmVudC1yYXRpbmdzXCJdLCAoKSA9PiAoX193ZWJwYWNrX3JlcXVpcmVfXyhcIi4vcmVzb3VyY2VzL3Njc3MvYmFzZS9jb3JlL2NvbG9ycy9wYWxldHRlLW5vdWkuc2Nzc1wiKSkpXG5fX3dlYnBhY2tfcmVxdWlyZV9fLk8odW5kZWZpbmVkLCBbXCJjc3MvYmFzZS9wbHVnaW5zL2V4dGVuc2lvbnMvZXh0LWNvbXBvbmVudC1tZWRpYS1wbGF5ZXJcIixcImNzcy9iYXNlL3BsdWdpbnMvZXh0ZW5zaW9ucy9leHQtY29tcG9uZW50LWRyYWctZHJvcFwiLFwiY3NzL2Jhc2UvcGx1Z2lucy9leHRlbnNpb25zL2V4dC1jb21wb25lbnQtY29udGV4dC1tZW51XCIsXCJjc3MvYmFzZS9wbHVnaW5zL2NoYXJ0cy9jaGFydC1hcGV4XCIsXCJjc3Mvc3R5bGVcIixcImNzcy9vdmVycmlkZXNcIixcImNzcy9jb3JlXCIsXCJjc3MvYmFzZS90aGVtZXMvZGFyay1sYXlvdXRcIixcImNzcy9iYXNlL2NvcmUvbWl4aW5zL3RyYW5zaXRpb25zXCIsXCJjc3MvYmFzZS9jb3JlL21peGlucy9tYWluLW1lbnUtbWl4aW5cIixcImNzcy9iYXNlL2NvcmUvbWl4aW5zL2hleDJyZ2JcIixcImNzcy9iYXNlL2NvcmUvbWl4aW5zL2FsZXJ0XCIsXCJjc3MvYmFzZS9jb3JlL21lbnUvbWVudS10eXBlcy92ZXJ0aWNhbC1vdmVybGF5LW1lbnVcIixcImNzcy9iYXNlL2NvcmUvbWVudS9tZW51LXR5cGVzL3ZlcnRpY2FsLW1lbnVcIixcImNzcy9iYXNlL2NvcmUvbWVudS9tZW51LXR5cGVzL2hvcml6b250YWwtbWVudVwiLFwiY3NzL2Jhc2UvY29yZS9jb2xvcnMvcGFsZXR0ZS12YXJpYWJsZXNcIixcImNzcy9iYXNlL2NvcmUvY29sb3JzL3BhbGV0dGUtbm91aVwiLFwiY3NzL2Jhc2UvY29yZS9jb2xvcnMvcGFsZXR0ZS1ncmFkaWVudFwiLFwiY3NzL2Jhc2UvcGFnZXMvdWktZmVhdGhlclwiLFwiY3NzL2Jhc2UvcGFnZXMvcGFnZS1wcm9maWxlXCIsXCJjc3MvYmFzZS9wYWdlcy9wYWdlLXByaWNpbmdcIixcImNzcy9iYXNlL3BhZ2VzL3BhZ2UtbWlzY1wiLFwiY3NzL2Jhc2UvcGFnZXMvcGFnZS1rbm93bGVkZ2UtYmFzZVwiLFwiY3NzL2Jhc2UvcGFnZXMvcGFnZS1mYXFcIixcImNzcy9iYXNlL3BhZ2VzL3BhZ2UtY29taW5nLXNvb25cIixcImNzcy9iYXNlL3BhZ2VzL3BhZ2UtYmxvZ1wiLFwiY3NzL2Jhc2UvcGFnZXMvbW9kYWwtY3JlYXRlLWFwcFwiLFwiY3NzL2Jhc2UvcGFnZXMvZGFzaGJvYXJkLWVjb21tZXJjZVwiLFwiY3NzL2Jhc2UvcGFnZXMvYXV0aGVudGljYXRpb25cIixcImNzcy9iYXNlL3BhZ2VzL2FwcC10b2RvXCIsXCJjc3MvYmFzZS9wYWdlcy9hcHAta2FuYmFuXCIsXCJjc3MvYmFzZS9wYWdlcy9hcHAtaW52b2ljZVwiLFwiY3NzL2Jhc2UvcGFnZXMvYXBwLWludm9pY2UtcHJpbnRcIixcImNzcy9iYXNlL3BhZ2VzL2FwcC1pbnZvaWNlLWxpc3RcIixcImNzcy9iYXNlL3BhZ2VzL2FwcC1maWxlLW1hbmFnZXJcIixcImNzcy9iYXNlL3BhZ2VzL2FwcC1lbWFpbFwiLFwiY3NzL2Jhc2UvcGFnZXMvYXBwLWVjb21tZXJjZVwiLFwiY3NzL2Jhc2UvcGFnZXMvYXBwLWVjb21tZXJjZS1kZXRhaWxzXCIsXCJjc3MvYmFzZS9wYWdlcy9hcHAtY2hhdFwiLFwiY3NzL2Jhc2UvcGFnZXMvYXBwLWNoYXQtbGlzdFwiLFwiY3NzL2Jhc2UvcGFnZXMvYXBwLWNhbGVuZGFyXCIsXCJjc3MvYmFzZS9wbHVnaW5zL3VpL2NvbWluZy1zb29uXCIsXCJjc3MvYmFzZS9wbHVnaW5zL21hcHMvbWFwLWxlYWZsZXRcIixcImNzcy9iYXNlL3BsdWdpbnMvZm9ybXMvcGlja2Vycy9mb3JtLXBpY2thZGF0ZVwiLFwiY3NzL2Jhc2UvcGx1Z2lucy9mb3Jtcy9waWNrZXJzL2Zvcm0tZmxhdC1waWNrclwiLFwiY3NzL2Jhc2UvcGx1Z2lucy9mb3Jtcy9mb3JtLXdpemFyZFwiLFwiY3NzL2Jhc2UvcGx1Z2lucy9mb3Jtcy9mb3JtLXZhbGlkYXRpb25cIixcImNzcy9iYXNlL3BsdWdpbnMvZm9ybXMvZm9ybS1xdWlsbC1lZGl0b3JcIixcImNzcy9iYXNlL3BsdWdpbnMvZm9ybXMvZm9ybS1udW1iZXItaW5wdXRcIixcImNzcy9iYXNlL3BsdWdpbnMvZm9ybXMvZm9ybS1maWxlLXVwbG9hZGVyXCIsXCJjc3MvYmFzZS9wbHVnaW5zL2V4dGVuc2lvbnMvZXh0LWNvbXBvbmVudC10cmVlXCIsXCJjc3MvYmFzZS9wbHVnaW5zL2V4dGVuc2lvbnMvZXh0LWNvbXBvbmVudC10b3VyXCIsXCJjc3MvYmFzZS9wbHVnaW5zL2V4dGVuc2lvbnMvZXh0LWNvbXBvbmVudC10b2FzdHJcIixcImNzcy9iYXNlL3BsdWdpbnMvZXh0ZW5zaW9ucy9leHQtY29tcG9uZW50LXN3aXBlclwiLFwiY3NzL2Jhc2UvcGx1Z2lucy9leHRlbnNpb25zL2V4dC1jb21wb25lbnQtc3dlZXQtYWxlcnRzXCIsXCJjc3MvYmFzZS9wbHVnaW5zL2V4dGVuc2lvbnMvZXh0LWNvbXBvbmVudC1zbGlkZXJzXCIsXCJjc3MvYmFzZS9wbHVnaW5zL2V4dGVuc2lvbnMvZXh0LWNvbXBvbmVudC1yYXRpbmdzXCJdLCAoKSA9PiAoX193ZWJwYWNrX3JlcXVpcmVfXyhcIi4vcmVzb3VyY2VzL3Njc3MvYmFzZS9jb3JlL2NvbG9ycy9wYWxldHRlLXZhcmlhYmxlcy5zY3NzXCIpKSlcbl9fd2VicGFja19yZXF1aXJlX18uTyh1bmRlZmluZWQsIFtcImNzcy9iYXNlL3BsdWdpbnMvZXh0ZW5zaW9ucy9leHQtY29tcG9uZW50LW1lZGlhLXBsYXllclwiLFwiY3NzL2Jhc2UvcGx1Z2lucy9leHRlbnNpb25zL2V4dC1jb21wb25lbnQtZHJhZy1kcm9wXCIsXCJjc3MvYmFzZS9wbHVnaW5zL2V4dGVuc2lvbnMvZXh0LWNvbXBvbmVudC1jb250ZXh0LW1lbnVcIixcImNzcy9iYXNlL3BsdWdpbnMvY2hhcnRzL2NoYXJ0LWFwZXhcIixcImNzcy9zdHlsZVwiLFwiY3NzL292ZXJyaWRlc1wiLFwiY3NzL2NvcmVcIixcImNzcy9iYXNlL3RoZW1lcy9kYXJrLWxheW91dFwiLFwiY3NzL2Jhc2UvY29yZS9taXhpbnMvdHJhbnNpdGlvbnNcIixcImNzcy9iYXNlL2NvcmUvbWl4aW5zL21haW4tbWVudS1taXhpblwiLFwiY3NzL2Jhc2UvY29yZS9taXhpbnMvaGV4MnJnYlwiLFwiY3NzL2Jhc2UvY29yZS9taXhpbnMvYWxlcnRcIixcImNzcy9iYXNlL2NvcmUvbWVudS9tZW51LXR5cGVzL3ZlcnRpY2FsLW92ZXJsYXktbWVudVwiLFwiY3NzL2Jhc2UvY29yZS9tZW51L21lbnUtdHlwZXMvdmVydGljYWwtbWVudVwiLFwiY3NzL2Jhc2UvY29yZS9tZW51L21lbnUtdHlwZXMvaG9yaXpvbnRhbC1tZW51XCIsXCJjc3MvYmFzZS9jb3JlL2NvbG9ycy9wYWxldHRlLXZhcmlhYmxlc1wiLFwiY3NzL2Jhc2UvY29yZS9jb2xvcnMvcGFsZXR0ZS1ub3VpXCIsXCJjc3MvYmFzZS9jb3JlL2NvbG9ycy9wYWxldHRlLWdyYWRpZW50XCIsXCJjc3MvYmFzZS9wYWdlcy91aS1mZWF0aGVyXCIsXCJjc3MvYmFzZS9wYWdlcy9wYWdlLXByb2ZpbGVcIixcImNzcy9iYXNlL3BhZ2VzL3BhZ2UtcHJpY2luZ1wiLFwiY3NzL2Jhc2UvcGFnZXMvcGFnZS1taXNjXCIsXCJjc3MvYmFzZS9wYWdlcy9wYWdlLWtub3dsZWRnZS1iYXNlXCIsXCJjc3MvYmFzZS9wYWdlcy9wYWdlLWZhcVwiLFwiY3NzL2Jhc2UvcGFnZXMvcGFnZS1jb21pbmctc29vblwiLFwiY3NzL2Jhc2UvcGFnZXMvcGFnZS1ibG9nXCIsXCJjc3MvYmFzZS9wYWdlcy9tb2RhbC1jcmVhdGUtYXBwXCIsXCJjc3MvYmFzZS9wYWdlcy9kYXNoYm9hcmQtZWNvbW1lcmNlXCIsXCJjc3MvYmFzZS9wYWdlcy9hdXRoZW50aWNhdGlvblwiLFwiY3NzL2Jhc2UvcGFnZXMvYXBwLXRvZG9cIixcImNzcy9iYXNlL3BhZ2VzL2FwcC1rYW5iYW5cIixcImNzcy9iYXNlL3BhZ2VzL2FwcC1pbnZvaWNlXCIsXCJjc3MvYmFzZS9wYWdlcy9hcHAtaW52b2ljZS1wcmludFwiLFwiY3NzL2Jhc2UvcGFnZXMvYXBwLWludm9pY2UtbGlzdFwiLFwiY3NzL2Jhc2UvcGFnZXMvYXBwLWZpbGUtbWFuYWdlclwiLFwiY3NzL2Jhc2UvcGFnZXMvYXBwLWVtYWlsXCIsXCJjc3MvYmFzZS9wYWdlcy9hcHAtZWNvbW1lcmNlXCIsXCJjc3MvYmFzZS9wYWdlcy9hcHAtZWNvbW1lcmNlLWRldGFpbHNcIixcImNzcy9iYXNlL3BhZ2VzL2FwcC1jaGF0XCIsXCJjc3MvYmFzZS9wYWdlcy9hcHAtY2hhdC1saXN0XCIsXCJjc3MvYmFzZS9wYWdlcy9hcHAtY2FsZW5kYXJcIixcImNzcy9iYXNlL3BsdWdpbnMvdWkvY29taW5nLXNvb25cIixcImNzcy9iYXNlL3BsdWdpbnMvbWFwcy9tYXAtbGVhZmxldFwiLFwiY3NzL2Jhc2UvcGx1Z2lucy9mb3Jtcy9waWNrZXJzL2Zvcm0tcGlja2FkYXRlXCIsXCJjc3MvYmFzZS9wbHVnaW5zL2Zvcm1zL3BpY2tlcnMvZm9ybS1mbGF0LXBpY2tyXCIsXCJjc3MvYmFzZS9wbHVnaW5zL2Zvcm1zL2Zvcm0td2l6YXJkXCIsXCJjc3MvYmFzZS9wbHVnaW5zL2Zvcm1zL2Zvcm0tdmFsaWRhdGlvblwiLFwiY3NzL2Jhc2UvcGx1Z2lucy9mb3Jtcy9mb3JtLXF1aWxsLWVkaXRvclwiLFwiY3NzL2Jhc2UvcGx1Z2lucy9mb3Jtcy9mb3JtLW51bWJlci1pbnB1dFwiLFwiY3NzL2Jhc2UvcGx1Z2lucy9mb3Jtcy9mb3JtLWZpbGUtdXBsb2FkZXJcIixcImNzcy9iYXNlL3BsdWdpbnMvZXh0ZW5zaW9ucy9leHQtY29tcG9uZW50LXRyZWVcIixcImNzcy9iYXNlL3BsdWdpbnMvZXh0ZW5zaW9ucy9leHQtY29tcG9uZW50LXRvdXJcIixcImNzcy9iYXNlL3BsdWdpbnMvZXh0ZW5zaW9ucy9leHQtY29tcG9uZW50LXRvYXN0clwiLFwiY3NzL2Jhc2UvcGx1Z2lucy9leHRlbnNpb25zL2V4dC1jb21wb25lbnQtc3dpcGVyXCIsXCJjc3MvYmFzZS9wbHVnaW5zL2V4dGVuc2lvbnMvZXh0LWNvbXBvbmVudC1zd2VldC1hbGVydHNcIixcImNzcy9iYXNlL3BsdWdpbnMvZXh0ZW5zaW9ucy9leHQtY29tcG9uZW50LXNsaWRlcnNcIixcImNzcy9iYXNlL3BsdWdpbnMvZXh0ZW5zaW9ucy9leHQtY29tcG9uZW50LXJhdGluZ3NcIl0sICgpID0+IChfX3dlYnBhY2tfcmVxdWlyZV9fKFwiLi9yZXNvdXJjZXMvc2Nzcy9iYXNlL2NvcmUvbWVudS9tZW51LXR5cGVzL2hvcml6b250YWwtbWVudS5zY3NzXCIpKSlcbl9fd2VicGFja19yZXF1aXJlX18uTyh1bmRlZmluZWQsIFtcImNzcy9iYXNlL3BsdWdpbnMvZXh0ZW5zaW9ucy9leHQtY29tcG9uZW50LW1lZGlhLXBsYXllclwiLFwiY3NzL2Jhc2UvcGx1Z2lucy9leHRlbnNpb25zL2V4dC1jb21wb25lbnQtZHJhZy1kcm9wXCIsXCJjc3MvYmFzZS9wbHVnaW5zL2V4dGVuc2lvbnMvZXh0LWNvbXBvbmVudC1jb250ZXh0LW1lbnVcIixcImNzcy9iYXNlL3BsdWdpbnMvY2hhcnRzL2NoYXJ0LWFwZXhcIixcImNzcy9zdHlsZVwiLFwiY3NzL292ZXJyaWRlc1wiLFwiY3NzL2NvcmVcIixcImNzcy9iYXNlL3RoZW1lcy9kYXJrLWxheW91dFwiLFwiY3NzL2Jhc2UvY29yZS9taXhpbnMvdHJhbnNpdGlvbnNcIixcImNzcy9iYXNlL2NvcmUvbWl4aW5zL21haW4tbWVudS1taXhpblwiLFwiY3NzL2Jhc2UvY29yZS9taXhpbnMvaGV4MnJnYlwiLFwiY3NzL2Jhc2UvY29yZS9taXhpbnMvYWxlcnRcIixcImNzcy9iYXNlL2NvcmUvbWVudS9tZW51LXR5cGVzL3ZlcnRpY2FsLW92ZXJsYXktbWVudVwiLFwiY3NzL2Jhc2UvY29yZS9tZW51L21lbnUtdHlwZXMvdmVydGljYWwtbWVudVwiLFwiY3NzL2Jhc2UvY29yZS9tZW51L21lbnUtdHlwZXMvaG9yaXpvbnRhbC1tZW51XCIsXCJjc3MvYmFzZS9jb3JlL2NvbG9ycy9wYWxldHRlLXZhcmlhYmxlc1wiLFwiY3NzL2Jhc2UvY29yZS9jb2xvcnMvcGFsZXR0ZS1ub3VpXCIsXCJjc3MvYmFzZS9jb3JlL2NvbG9ycy9wYWxldHRlLWdyYWRpZW50XCIsXCJjc3MvYmFzZS9wYWdlcy91aS1mZWF0aGVyXCIsXCJjc3MvYmFzZS9wYWdlcy9wYWdlLXByb2ZpbGVcIixcImNzcy9iYXNlL3BhZ2VzL3BhZ2UtcHJpY2luZ1wiLFwiY3NzL2Jhc2UvcGFnZXMvcGFnZS1taXNjXCIsXCJjc3MvYmFzZS9wYWdlcy9wYWdlLWtub3dsZWRnZS1iYXNlXCIsXCJjc3MvYmFzZS9wYWdlcy9wYWdlLWZhcVwiLFwiY3NzL2Jhc2UvcGFnZXMvcGFnZS1jb21pbmctc29vblwiLFwiY3NzL2Jhc2UvcGFnZXMvcGFnZS1ibG9nXCIsXCJjc3MvYmFzZS9wYWdlcy9tb2RhbC1jcmVhdGUtYXBwXCIsXCJjc3MvYmFzZS9wYWdlcy9kYXNoYm9hcmQtZWNvbW1lcmNlXCIsXCJjc3MvYmFzZS9wYWdlcy9hdXRoZW50aWNhdGlvblwiLFwiY3NzL2Jhc2UvcGFnZXMvYXBwLXRvZG9cIixcImNzcy9iYXNlL3BhZ2VzL2FwcC1rYW5iYW5cIixcImNzcy9iYXNlL3BhZ2VzL2FwcC1pbnZvaWNlXCIsXCJjc3MvYmFzZS9wYWdlcy9hcHAtaW52b2ljZS1wcmludFwiLFwiY3NzL2Jhc2UvcGFnZXMvYXBwLWludm9pY2UtbGlzdFwiLFwiY3NzL2Jhc2UvcGFnZXMvYXBwLWZpbGUtbWFuYWdlclwiLFwiY3NzL2Jhc2UvcGFnZXMvYXBwLWVtYWlsXCIsXCJjc3MvYmFzZS9wYWdlcy9hcHAtZWNvbW1lcmNlXCIsXCJjc3MvYmFzZS9wYWdlcy9hcHAtZWNvbW1lcmNlLWRldGFpbHNcIixcImNzcy9iYXNlL3BhZ2VzL2FwcC1jaGF0XCIsXCJjc3MvYmFzZS9wYWdlcy9hcHAtY2hhdC1saXN0XCIsXCJjc3MvYmFzZS9wYWdlcy9hcHAtY2FsZW5kYXJcIixcImNzcy9iYXNlL3BsdWdpbnMvdWkvY29taW5nLXNvb25cIixcImNzcy9iYXNlL3BsdWdpbnMvbWFwcy9tYXAtbGVhZmxldFwiLFwiY3NzL2Jhc2UvcGx1Z2lucy9mb3Jtcy9waWNrZXJzL2Zvcm0tcGlja2FkYXRlXCIsXCJjc3MvYmFzZS9wbHVnaW5zL2Zvcm1zL3BpY2tlcnMvZm9ybS1mbGF0LXBpY2tyXCIsXCJjc3MvYmFzZS9wbHVnaW5zL2Zvcm1zL2Zvcm0td2l6YXJkXCIsXCJjc3MvYmFzZS9wbHVnaW5zL2Zvcm1zL2Zvcm0tdmFsaWRhdGlvblwiLFwiY3NzL2Jhc2UvcGx1Z2lucy9mb3Jtcy9mb3JtLXF1aWxsLWVkaXRvclwiLFwiY3NzL2Jhc2UvcGx1Z2lucy9mb3Jtcy9mb3JtLW51bWJlci1pbnB1dFwiLFwiY3NzL2Jhc2UvcGx1Z2lucy9mb3Jtcy9mb3JtLWZpbGUtdXBsb2FkZXJcIixcImNzcy9iYXNlL3BsdWdpbnMvZXh0ZW5zaW9ucy9leHQtY29tcG9uZW50LXRyZWVcIixcImNzcy9iYXNlL3BsdWdpbnMvZXh0ZW5zaW9ucy9leHQtY29tcG9uZW50LXRvdXJcIixcImNzcy9iYXNlL3BsdWdpbnMvZXh0ZW5zaW9ucy9leHQtY29tcG9uZW50LXRvYXN0clwiLFwiY3NzL2Jhc2UvcGx1Z2lucy9leHRlbnNpb25zL2V4dC1jb21wb25lbnQtc3dpcGVyXCIsXCJjc3MvYmFzZS9wbHVnaW5zL2V4dGVuc2lvbnMvZXh0LWNvbXBvbmVudC1zd2VldC1hbGVydHNcIixcImNzcy9iYXNlL3BsdWdpbnMvZXh0ZW5zaW9ucy9leHQtY29tcG9uZW50LXNsaWRlcnNcIixcImNzcy9iYXNlL3BsdWdpbnMvZXh0ZW5zaW9ucy9leHQtY29tcG9uZW50LXJhdGluZ3NcIl0sICgpID0+IChfX3dlYnBhY2tfcmVxdWlyZV9fKFwiLi9yZXNvdXJjZXMvc2Nzcy9iYXNlL2NvcmUvbWVudS9tZW51LXR5cGVzL3ZlcnRpY2FsLW1lbnUuc2Nzc1wiKSkpXG5fX3dlYnBhY2tfcmVxdWlyZV9fLk8odW5kZWZpbmVkLCBbXCJjc3MvYmFzZS9wbHVnaW5zL2V4dGVuc2lvbnMvZXh0LWNvbXBvbmVudC1tZWRpYS1wbGF5ZXJcIixcImNzcy9iYXNlL3BsdWdpbnMvZXh0ZW5zaW9ucy9leHQtY29tcG9uZW50LWRyYWctZHJvcFwiLFwiY3NzL2Jhc2UvcGx1Z2lucy9leHRlbnNpb25zL2V4dC1jb21wb25lbnQtY29udGV4dC1tZW51XCIsXCJjc3MvYmFzZS9wbHVnaW5zL2NoYXJ0cy9jaGFydC1hcGV4XCIsXCJjc3Mvc3R5bGVcIixcImNzcy9vdmVycmlkZXNcIixcImNzcy9jb3JlXCIsXCJjc3MvYmFzZS90aGVtZXMvZGFyay1sYXlvdXRcIixcImNzcy9iYXNlL2NvcmUvbWl4aW5zL3RyYW5zaXRpb25zXCIsXCJjc3MvYmFzZS9jb3JlL21peGlucy9tYWluLW1lbnUtbWl4aW5cIixcImNzcy9iYXNlL2NvcmUvbWl4aW5zL2hleDJyZ2JcIixcImNzcy9iYXNlL2NvcmUvbWl4aW5zL2FsZXJ0XCIsXCJjc3MvYmFzZS9jb3JlL21lbnUvbWVudS10eXBlcy92ZXJ0aWNhbC1vdmVybGF5LW1lbnVcIixcImNzcy9iYXNlL2NvcmUvbWVudS9tZW51LXR5cGVzL3ZlcnRpY2FsLW1lbnVcIixcImNzcy9iYXNlL2NvcmUvbWVudS9tZW51LXR5cGVzL2hvcml6b250YWwtbWVudVwiLFwiY3NzL2Jhc2UvY29yZS9jb2xvcnMvcGFsZXR0ZS12YXJpYWJsZXNcIixcImNzcy9iYXNlL2NvcmUvY29sb3JzL3BhbGV0dGUtbm91aVwiLFwiY3NzL2Jhc2UvY29yZS9jb2xvcnMvcGFsZXR0ZS1ncmFkaWVudFwiLFwiY3NzL2Jhc2UvcGFnZXMvdWktZmVhdGhlclwiLFwiY3NzL2Jhc2UvcGFnZXMvcGFnZS1wcm9maWxlXCIsXCJjc3MvYmFzZS9wYWdlcy9wYWdlLXByaWNpbmdcIixcImNzcy9iYXNlL3BhZ2VzL3BhZ2UtbWlzY1wiLFwiY3NzL2Jhc2UvcGFnZXMvcGFnZS1rbm93bGVkZ2UtYmFzZVwiLFwiY3NzL2Jhc2UvcGFnZXMvcGFnZS1mYXFcIixcImNzcy9iYXNlL3BhZ2VzL3BhZ2UtY29taW5nLXNvb25cIixcImNzcy9iYXNlL3BhZ2VzL3BhZ2UtYmxvZ1wiLFwiY3NzL2Jhc2UvcGFnZXMvbW9kYWwtY3JlYXRlLWFwcFwiLFwiY3NzL2Jhc2UvcGFnZXMvZGFzaGJvYXJkLWVjb21tZXJjZVwiLFwiY3NzL2Jhc2UvcGFnZXMvYXV0aGVudGljYXRpb25cIixcImNzcy9iYXNlL3BhZ2VzL2FwcC10b2RvXCIsXCJjc3MvYmFzZS9wYWdlcy9hcHAta2FuYmFuXCIsXCJjc3MvYmFzZS9wYWdlcy9hcHAtaW52b2ljZVwiLFwiY3NzL2Jhc2UvcGFnZXMvYXBwLWludm9pY2UtcHJpbnRcIixcImNzcy9iYXNlL3BhZ2VzL2FwcC1pbnZvaWNlLWxpc3RcIixcImNzcy9iYXNlL3BhZ2VzL2FwcC1maWxlLW1hbmFnZXJcIixcImNzcy9iYXNlL3BhZ2VzL2FwcC1lbWFpbFwiLFwiY3NzL2Jhc2UvcGFnZXMvYXBwLWVjb21tZXJjZVwiLFwiY3NzL2Jhc2UvcGFnZXMvYXBwLWVjb21tZXJjZS1kZXRhaWxzXCIsXCJjc3MvYmFzZS9wYWdlcy9hcHAtY2hhdFwiLFwiY3NzL2Jhc2UvcGFnZXMvYXBwLWNoYXQtbGlzdFwiLFwiY3NzL2Jhc2UvcGFnZXMvYXBwLWNhbGVuZGFyXCIsXCJjc3MvYmFzZS9wbHVnaW5zL3VpL2NvbWluZy1zb29uXCIsXCJjc3MvYmFzZS9wbHVnaW5zL21hcHMvbWFwLWxlYWZsZXRcIixcImNzcy9iYXNlL3BsdWdpbnMvZm9ybXMvcGlja2Vycy9mb3JtLXBpY2thZGF0ZVwiLFwiY3NzL2Jhc2UvcGx1Z2lucy9mb3Jtcy9waWNrZXJzL2Zvcm0tZmxhdC1waWNrclwiLFwiY3NzL2Jhc2UvcGx1Z2lucy9mb3Jtcy9mb3JtLXdpemFyZFwiLFwiY3NzL2Jhc2UvcGx1Z2lucy9mb3Jtcy9mb3JtLXZhbGlkYXRpb25cIixcImNzcy9iYXNlL3BsdWdpbnMvZm9ybXMvZm9ybS1xdWlsbC1lZGl0b3JcIixcImNzcy9iYXNlL3BsdWdpbnMvZm9ybXMvZm9ybS1udW1iZXItaW5wdXRcIixcImNzcy9iYXNlL3BsdWdpbnMvZm9ybXMvZm9ybS1maWxlLXVwbG9hZGVyXCIsXCJjc3MvYmFzZS9wbHVnaW5zL2V4dGVuc2lvbnMvZXh0LWNvbXBvbmVudC10cmVlXCIsXCJjc3MvYmFzZS9wbHVnaW5zL2V4dGVuc2lvbnMvZXh0LWNvbXBvbmVudC10b3VyXCIsXCJjc3MvYmFzZS9wbHVnaW5zL2V4dGVuc2lvbnMvZXh0LWNvbXBvbmVudC10b2FzdHJcIixcImNzcy9iYXNlL3BsdWdpbnMvZXh0ZW5zaW9ucy9leHQtY29tcG9uZW50LXN3aXBlclwiLFwiY3NzL2Jhc2UvcGx1Z2lucy9leHRlbnNpb25zL2V4dC1jb21wb25lbnQtc3dlZXQtYWxlcnRzXCIsXCJjc3MvYmFzZS9wbHVnaW5zL2V4dGVuc2lvbnMvZXh0LWNvbXBvbmVudC1zbGlkZXJzXCIsXCJjc3MvYmFzZS9wbHVnaW5zL2V4dGVuc2lvbnMvZXh0LWNvbXBvbmVudC1yYXRpbmdzXCJdLCAoKSA9PiAoX193ZWJwYWNrX3JlcXVpcmVfXyhcIi4vcmVzb3VyY2VzL3Njc3MvYmFzZS9jb3JlL21lbnUvbWVudS10eXBlcy92ZXJ0aWNhbC1vdmVybGF5LW1lbnUuc2Nzc1wiKSkpXG5fX3dlYnBhY2tfcmVxdWlyZV9fLk8odW5kZWZpbmVkLCBbXCJjc3MvYmFzZS9wbHVnaW5zL2V4dGVuc2lvbnMvZXh0LWNvbXBvbmVudC1tZWRpYS1wbGF5ZXJcIixcImNzcy9iYXNlL3BsdWdpbnMvZXh0ZW5zaW9ucy9leHQtY29tcG9uZW50LWRyYWctZHJvcFwiLFwiY3NzL2Jhc2UvcGx1Z2lucy9leHRlbnNpb25zL2V4dC1jb21wb25lbnQtY29udGV4dC1tZW51XCIsXCJjc3MvYmFzZS9wbHVnaW5zL2NoYXJ0cy9jaGFydC1hcGV4XCIsXCJjc3Mvc3R5bGVcIixcImNzcy9vdmVycmlkZXNcIixcImNzcy9jb3JlXCIsXCJjc3MvYmFzZS90aGVtZXMvZGFyay1sYXlvdXRcIixcImNzcy9iYXNlL2NvcmUvbWl4aW5zL3RyYW5zaXRpb25zXCIsXCJjc3MvYmFzZS9jb3JlL21peGlucy9tYWluLW1lbnUtbWl4aW5cIixcImNzcy9iYXNlL2NvcmUvbWl4aW5zL2hleDJyZ2JcIixcImNzcy9iYXNlL2NvcmUvbWl4aW5zL2FsZXJ0XCIsXCJjc3MvYmFzZS9jb3JlL21lbnUvbWVudS10eXBlcy92ZXJ0aWNhbC1vdmVybGF5LW1lbnVcIixcImNzcy9iYXNlL2NvcmUvbWVudS9tZW51LXR5cGVzL3ZlcnRpY2FsLW1lbnVcIixcImNzcy9iYXNlL2NvcmUvbWVudS9tZW51LXR5cGVzL2hvcml6b250YWwtbWVudVwiLFwiY3NzL2Jhc2UvY29yZS9jb2xvcnMvcGFsZXR0ZS12YXJpYWJsZXNcIixcImNzcy9iYXNlL2NvcmUvY29sb3JzL3BhbGV0dGUtbm91aVwiLFwiY3NzL2Jhc2UvY29yZS9jb2xvcnMvcGFsZXR0ZS1ncmFkaWVudFwiLFwiY3NzL2Jhc2UvcGFnZXMvdWktZmVhdGhlclwiLFwiY3NzL2Jhc2UvcGFnZXMvcGFnZS1wcm9maWxlXCIsXCJjc3MvYmFzZS9wYWdlcy9wYWdlLXByaWNpbmdcIixcImNzcy9iYXNlL3BhZ2VzL3BhZ2UtbWlzY1wiLFwiY3NzL2Jhc2UvcGFnZXMvcGFnZS1rbm93bGVkZ2UtYmFzZVwiLFwiY3NzL2Jhc2UvcGFnZXMvcGFnZS1mYXFcIixcImNzcy9iYXNlL3BhZ2VzL3BhZ2UtY29taW5nLXNvb25cIixcImNzcy9iYXNlL3BhZ2VzL3BhZ2UtYmxvZ1wiLFwiY3NzL2Jhc2UvcGFnZXMvbW9kYWwtY3JlYXRlLWFwcFwiLFwiY3NzL2Jhc2UvcGFnZXMvZGFzaGJvYXJkLWVjb21tZXJjZVwiLFwiY3NzL2Jhc2UvcGFnZXMvYXV0aGVudGljYXRpb25cIixcImNzcy9iYXNlL3BhZ2VzL2FwcC10b2RvXCIsXCJjc3MvYmFzZS9wYWdlcy9hcHAta2FuYmFuXCIsXCJjc3MvYmFzZS9wYWdlcy9hcHAtaW52b2ljZVwiLFwiY3NzL2Jhc2UvcGFnZXMvYXBwLWludm9pY2UtcHJpbnRcIixcImNzcy9iYXNlL3BhZ2VzL2FwcC1pbnZvaWNlLWxpc3RcIixcImNzcy9iYXNlL3BhZ2VzL2FwcC1maWxlLW1hbmFnZXJcIixcImNzcy9iYXNlL3BhZ2VzL2FwcC1lbWFpbFwiLFwiY3NzL2Jhc2UvcGFnZXMvYXBwLWVjb21tZXJjZVwiLFwiY3NzL2Jhc2UvcGFnZXMvYXBwLWVjb21tZXJjZS1kZXRhaWxzXCIsXCJjc3MvYmFzZS9wYWdlcy9hcHAtY2hhdFwiLFwiY3NzL2Jhc2UvcGFnZXMvYXBwLWNoYXQtbGlzdFwiLFwiY3NzL2Jhc2UvcGFnZXMvYXBwLWNhbGVuZGFyXCIsXCJjc3MvYmFzZS9wbHVnaW5zL3VpL2NvbWluZy1zb29uXCIsXCJjc3MvYmFzZS9wbHVnaW5zL21hcHMvbWFwLWxlYWZsZXRcIixcImNzcy9iYXNlL3BsdWdpbnMvZm9ybXMvcGlja2Vycy9mb3JtLXBpY2thZGF0ZVwiLFwiY3NzL2Jhc2UvcGx1Z2lucy9mb3Jtcy9waWNrZXJzL2Zvcm0tZmxhdC1waWNrclwiLFwiY3NzL2Jhc2UvcGx1Z2lucy9mb3Jtcy9mb3JtLXdpemFyZFwiLFwiY3NzL2Jhc2UvcGx1Z2lucy9mb3Jtcy9mb3JtLXZhbGlkYXRpb25cIixcImNzcy9iYXNlL3BsdWdpbnMvZm9ybXMvZm9ybS1xdWlsbC1lZGl0b3JcIixcImNzcy9iYXNlL3BsdWdpbnMvZm9ybXMvZm9ybS1udW1iZXItaW5wdXRcIixcImNzcy9iYXNlL3BsdWdpbnMvZm9ybXMvZm9ybS1maWxlLXVwbG9hZGVyXCIsXCJjc3MvYmFzZS9wbHVnaW5zL2V4dGVuc2lvbnMvZXh0LWNvbXBvbmVudC10cmVlXCIsXCJjc3MvYmFzZS9wbHVnaW5zL2V4dGVuc2lvbnMvZXh0LWNvbXBvbmVudC10b3VyXCIsXCJjc3MvYmFzZS9wbHVnaW5zL2V4dGVuc2lvbnMvZXh0LWNvbXBvbmVudC10b2FzdHJcIixcImNzcy9iYXNlL3BsdWdpbnMvZXh0ZW5zaW9ucy9leHQtY29tcG9uZW50LXN3aXBlclwiLFwiY3NzL2Jhc2UvcGx1Z2lucy9leHRlbnNpb25zL2V4dC1jb21wb25lbnQtc3dlZXQtYWxlcnRzXCIsXCJjc3MvYmFzZS9wbHVnaW5zL2V4dGVuc2lvbnMvZXh0LWNvbXBvbmVudC1zbGlkZXJzXCIsXCJjc3MvYmFzZS9wbHVnaW5zL2V4dGVuc2lvbnMvZXh0LWNvbXBvbmVudC1yYXRpbmdzXCJdLCAoKSA9PiAoX193ZWJwYWNrX3JlcXVpcmVfXyhcIi4vcmVzb3VyY2VzL3Njc3MvYmFzZS9jb3JlL21peGlucy9hbGVydC5zY3NzXCIpKSlcbl9fd2VicGFja19yZXF1aXJlX18uTyh1bmRlZmluZWQsIFtcImNzcy9iYXNlL3BsdWdpbnMvZXh0ZW5zaW9ucy9leHQtY29tcG9uZW50LW1lZGlhLXBsYXllclwiLFwiY3NzL2Jhc2UvcGx1Z2lucy9leHRlbnNpb25zL2V4dC1jb21wb25lbnQtZHJhZy1kcm9wXCIsXCJjc3MvYmFzZS9wbHVnaW5zL2V4dGVuc2lvbnMvZXh0LWNvbXBvbmVudC1jb250ZXh0LW1lbnVcIixcImNzcy9iYXNlL3BsdWdpbnMvY2hhcnRzL2NoYXJ0LWFwZXhcIixcImNzcy9zdHlsZVwiLFwiY3NzL292ZXJyaWRlc1wiLFwiY3NzL2NvcmVcIixcImNzcy9iYXNlL3RoZW1lcy9kYXJrLWxheW91dFwiLFwiY3NzL2Jhc2UvY29yZS9taXhpbnMvdHJhbnNpdGlvbnNcIixcImNzcy9iYXNlL2NvcmUvbWl4aW5zL21haW4tbWVudS1taXhpblwiLFwiY3NzL2Jhc2UvY29yZS9taXhpbnMvaGV4MnJnYlwiLFwiY3NzL2Jhc2UvY29yZS9taXhpbnMvYWxlcnRcIixcImNzcy9iYXNlL2NvcmUvbWVudS9tZW51LXR5cGVzL3ZlcnRpY2FsLW92ZXJsYXktbWVudVwiLFwiY3NzL2Jhc2UvY29yZS9tZW51L21lbnUtdHlwZXMvdmVydGljYWwtbWVudVwiLFwiY3NzL2Jhc2UvY29yZS9tZW51L21lbnUtdHlwZXMvaG9yaXpvbnRhbC1tZW51XCIsXCJjc3MvYmFzZS9jb3JlL2NvbG9ycy9wYWxldHRlLXZhcmlhYmxlc1wiLFwiY3NzL2Jhc2UvY29yZS9jb2xvcnMvcGFsZXR0ZS1ub3VpXCIsXCJjc3MvYmFzZS9jb3JlL2NvbG9ycy9wYWxldHRlLWdyYWRpZW50XCIsXCJjc3MvYmFzZS9wYWdlcy91aS1mZWF0aGVyXCIsXCJjc3MvYmFzZS9wYWdlcy9wYWdlLXByb2ZpbGVcIixcImNzcy9iYXNlL3BhZ2VzL3BhZ2UtcHJpY2luZ1wiLFwiY3NzL2Jhc2UvcGFnZXMvcGFnZS1taXNjXCIsXCJjc3MvYmFzZS9wYWdlcy9wYWdlLWtub3dsZWRnZS1iYXNlXCIsXCJjc3MvYmFzZS9wYWdlcy9wYWdlLWZhcVwiLFwiY3NzL2Jhc2UvcGFnZXMvcGFnZS1jb21pbmctc29vblwiLFwiY3NzL2Jhc2UvcGFnZXMvcGFnZS1ibG9nXCIsXCJjc3MvYmFzZS9wYWdlcy9tb2RhbC1jcmVhdGUtYXBwXCIsXCJjc3MvYmFzZS9wYWdlcy9kYXNoYm9hcmQtZWNvbW1lcmNlXCIsXCJjc3MvYmFzZS9wYWdlcy9hdXRoZW50aWNhdGlvblwiLFwiY3NzL2Jhc2UvcGFnZXMvYXBwLXRvZG9cIixcImNzcy9iYXNlL3BhZ2VzL2FwcC1rYW5iYW5cIixcImNzcy9iYXNlL3BhZ2VzL2FwcC1pbnZvaWNlXCIsXCJjc3MvYmFzZS9wYWdlcy9hcHAtaW52b2ljZS1wcmludFwiLFwiY3NzL2Jhc2UvcGFnZXMvYXBwLWludm9pY2UtbGlzdFwiLFwiY3NzL2Jhc2UvcGFnZXMvYXBwLWZpbGUtbWFuYWdlclwiLFwiY3NzL2Jhc2UvcGFnZXMvYXBwLWVtYWlsXCIsXCJjc3MvYmFzZS9wYWdlcy9hcHAtZWNvbW1lcmNlXCIsXCJjc3MvYmFzZS9wYWdlcy9hcHAtZWNvbW1lcmNlLWRldGFpbHNcIixcImNzcy9iYXNlL3BhZ2VzL2FwcC1jaGF0XCIsXCJjc3MvYmFzZS9wYWdlcy9hcHAtY2hhdC1saXN0XCIsXCJjc3MvYmFzZS9wYWdlcy9hcHAtY2FsZW5kYXJcIixcImNzcy9iYXNlL3BsdWdpbnMvdWkvY29taW5nLXNvb25cIixcImNzcy9iYXNlL3BsdWdpbnMvbWFwcy9tYXAtbGVhZmxldFwiLFwiY3NzL2Jhc2UvcGx1Z2lucy9mb3Jtcy9waWNrZXJzL2Zvcm0tcGlja2FkYXRlXCIsXCJjc3MvYmFzZS9wbHVnaW5zL2Zvcm1zL3BpY2tlcnMvZm9ybS1mbGF0LXBpY2tyXCIsXCJjc3MvYmFzZS9wbHVnaW5zL2Zvcm1zL2Zvcm0td2l6YXJkXCIsXCJjc3MvYmFzZS9wbHVnaW5zL2Zvcm1zL2Zvcm0tdmFsaWRhdGlvblwiLFwiY3NzL2Jhc2UvcGx1Z2lucy9mb3Jtcy9mb3JtLXF1aWxsLWVkaXRvclwiLFwiY3NzL2Jhc2UvcGx1Z2lucy9mb3Jtcy9mb3JtLW51bWJlci1pbnB1dFwiLFwiY3NzL2Jhc2UvcGx1Z2lucy9mb3Jtcy9mb3JtLWZpbGUtdXBsb2FkZXJcIixcImNzcy9iYXNlL3BsdWdpbnMvZXh0ZW5zaW9ucy9leHQtY29tcG9uZW50LXRyZWVcIixcImNzcy9iYXNlL3BsdWdpbnMvZXh0ZW5zaW9ucy9leHQtY29tcG9uZW50LXRvdXJcIixcImNzcy9iYXNlL3BsdWdpbnMvZXh0ZW5zaW9ucy9leHQtY29tcG9uZW50LXRvYXN0clwiLFwiY3NzL2Jhc2UvcGx1Z2lucy9leHRlbnNpb25zL2V4dC1jb21wb25lbnQtc3dpcGVyXCIsXCJjc3MvYmFzZS9wbHVnaW5zL2V4dGVuc2lvbnMvZXh0LWNvbXBvbmVudC1zd2VldC1hbGVydHNcIixcImNzcy9iYXNlL3BsdWdpbnMvZXh0ZW5zaW9ucy9leHQtY29tcG9uZW50LXNsaWRlcnNcIixcImNzcy9iYXNlL3BsdWdpbnMvZXh0ZW5zaW9ucy9leHQtY29tcG9uZW50LXJhdGluZ3NcIl0sICgpID0+IChfX3dlYnBhY2tfcmVxdWlyZV9fKFwiLi9yZXNvdXJjZXMvc2Nzcy9iYXNlL2NvcmUvbWl4aW5zL2hleDJyZ2Iuc2Nzc1wiKSkpXG5fX3dlYnBhY2tfcmVxdWlyZV9fLk8odW5kZWZpbmVkLCBbXCJjc3MvYmFzZS9wbHVnaW5zL2V4dGVuc2lvbnMvZXh0LWNvbXBvbmVudC1tZWRpYS1wbGF5ZXJcIixcImNzcy9iYXNlL3BsdWdpbnMvZXh0ZW5zaW9ucy9leHQtY29tcG9uZW50LWRyYWctZHJvcFwiLFwiY3NzL2Jhc2UvcGx1Z2lucy9leHRlbnNpb25zL2V4dC1jb21wb25lbnQtY29udGV4dC1tZW51XCIsXCJjc3MvYmFzZS9wbHVnaW5zL2NoYXJ0cy9jaGFydC1hcGV4XCIsXCJjc3Mvc3R5bGVcIixcImNzcy9vdmVycmlkZXNcIixcImNzcy9jb3JlXCIsXCJjc3MvYmFzZS90aGVtZXMvZGFyay1sYXlvdXRcIixcImNzcy9iYXNlL2NvcmUvbWl4aW5zL3RyYW5zaXRpb25zXCIsXCJjc3MvYmFzZS9jb3JlL21peGlucy9tYWluLW1lbnUtbWl4aW5cIixcImNzcy9iYXNlL2NvcmUvbWl4aW5zL2hleDJyZ2JcIixcImNzcy9iYXNlL2NvcmUvbWl4aW5zL2FsZXJ0XCIsXCJjc3MvYmFzZS9jb3JlL21lbnUvbWVudS10eXBlcy92ZXJ0aWNhbC1vdmVybGF5LW1lbnVcIixcImNzcy9iYXNlL2NvcmUvbWVudS9tZW51LXR5cGVzL3ZlcnRpY2FsLW1lbnVcIixcImNzcy9iYXNlL2NvcmUvbWVudS9tZW51LXR5cGVzL2hvcml6b250YWwtbWVudVwiLFwiY3NzL2Jhc2UvY29yZS9jb2xvcnMvcGFsZXR0ZS12YXJpYWJsZXNcIixcImNzcy9iYXNlL2NvcmUvY29sb3JzL3BhbGV0dGUtbm91aVwiLFwiY3NzL2Jhc2UvY29yZS9jb2xvcnMvcGFsZXR0ZS1ncmFkaWVudFwiLFwiY3NzL2Jhc2UvcGFnZXMvdWktZmVhdGhlclwiLFwiY3NzL2Jhc2UvcGFnZXMvcGFnZS1wcm9maWxlXCIsXCJjc3MvYmFzZS9wYWdlcy9wYWdlLXByaWNpbmdcIixcImNzcy9iYXNlL3BhZ2VzL3BhZ2UtbWlzY1wiLFwiY3NzL2Jhc2UvcGFnZXMvcGFnZS1rbm93bGVkZ2UtYmFzZVwiLFwiY3NzL2Jhc2UvcGFnZXMvcGFnZS1mYXFcIixcImNzcy9iYXNlL3BhZ2VzL3BhZ2UtY29taW5nLXNvb25cIixcImNzcy9iYXNlL3BhZ2VzL3BhZ2UtYmxvZ1wiLFwiY3NzL2Jhc2UvcGFnZXMvbW9kYWwtY3JlYXRlLWFwcFwiLFwiY3NzL2Jhc2UvcGFnZXMvZGFzaGJvYXJkLWVjb21tZXJjZVwiLFwiY3NzL2Jhc2UvcGFnZXMvYXV0aGVudGljYXRpb25cIixcImNzcy9iYXNlL3BhZ2VzL2FwcC10b2RvXCIsXCJjc3MvYmFzZS9wYWdlcy9hcHAta2FuYmFuXCIsXCJjc3MvYmFzZS9wYWdlcy9hcHAtaW52b2ljZVwiLFwiY3NzL2Jhc2UvcGFnZXMvYXBwLWludm9pY2UtcHJpbnRcIixcImNzcy9iYXNlL3BhZ2VzL2FwcC1pbnZvaWNlLWxpc3RcIixcImNzcy9iYXNlL3BhZ2VzL2FwcC1maWxlLW1hbmFnZXJcIixcImNzcy9iYXNlL3BhZ2VzL2FwcC1lbWFpbFwiLFwiY3NzL2Jhc2UvcGFnZXMvYXBwLWVjb21tZXJjZVwiLFwiY3NzL2Jhc2UvcGFnZXMvYXBwLWVjb21tZXJjZS1kZXRhaWxzXCIsXCJjc3MvYmFzZS9wYWdlcy9hcHAtY2hhdFwiLFwiY3NzL2Jhc2UvcGFnZXMvYXBwLWNoYXQtbGlzdFwiLFwiY3NzL2Jhc2UvcGFnZXMvYXBwLWNhbGVuZGFyXCIsXCJjc3MvYmFzZS9wbHVnaW5zL3VpL2NvbWluZy1zb29uXCIsXCJjc3MvYmFzZS9wbHVnaW5zL21hcHMvbWFwLWxlYWZsZXRcIixcImNzcy9iYXNlL3BsdWdpbnMvZm9ybXMvcGlja2Vycy9mb3JtLXBpY2thZGF0ZVwiLFwiY3NzL2Jhc2UvcGx1Z2lucy9mb3Jtcy9waWNrZXJzL2Zvcm0tZmxhdC1waWNrclwiLFwiY3NzL2Jhc2UvcGx1Z2lucy9mb3Jtcy9mb3JtLXdpemFyZFwiLFwiY3NzL2Jhc2UvcGx1Z2lucy9mb3Jtcy9mb3JtLXZhbGlkYXRpb25cIixcImNzcy9iYXNlL3BsdWdpbnMvZm9ybXMvZm9ybS1xdWlsbC1lZGl0b3JcIixcImNzcy9iYXNlL3BsdWdpbnMvZm9ybXMvZm9ybS1udW1iZXItaW5wdXRcIixcImNzcy9iYXNlL3BsdWdpbnMvZm9ybXMvZm9ybS1maWxlLXVwbG9hZGVyXCIsXCJjc3MvYmFzZS9wbHVnaW5zL2V4dGVuc2lvbnMvZXh0LWNvbXBvbmVudC10cmVlXCIsXCJjc3MvYmFzZS9wbHVnaW5zL2V4dGVuc2lvbnMvZXh0LWNvbXBvbmVudC10b3VyXCIsXCJjc3MvYmFzZS9wbHVnaW5zL2V4dGVuc2lvbnMvZXh0LWNvbXBvbmVudC10b2FzdHJcIixcImNzcy9iYXNlL3BsdWdpbnMvZXh0ZW5zaW9ucy9leHQtY29tcG9uZW50LXN3aXBlclwiLFwiY3NzL2Jhc2UvcGx1Z2lucy9leHRlbnNpb25zL2V4dC1jb21wb25lbnQtc3dlZXQtYWxlcnRzXCIsXCJjc3MvYmFzZS9wbHVnaW5zL2V4dGVuc2lvbnMvZXh0LWNvbXBvbmVudC1zbGlkZXJzXCIsXCJjc3MvYmFzZS9wbHVnaW5zL2V4dGVuc2lvbnMvZXh0LWNvbXBvbmVudC1yYXRpbmdzXCJdLCAoKSA9PiAoX193ZWJwYWNrX3JlcXVpcmVfXyhcIi4vcmVzb3VyY2VzL3Njc3MvYmFzZS9jb3JlL21peGlucy9tYWluLW1lbnUtbWl4aW4uc2Nzc1wiKSkpXG5fX3dlYnBhY2tfcmVxdWlyZV9fLk8odW5kZWZpbmVkLCBbXCJjc3MvYmFzZS9wbHVnaW5zL2V4dGVuc2lvbnMvZXh0LWNvbXBvbmVudC1tZWRpYS1wbGF5ZXJcIixcImNzcy9iYXNlL3BsdWdpbnMvZXh0ZW5zaW9ucy9leHQtY29tcG9uZW50LWRyYWctZHJvcFwiLFwiY3NzL2Jhc2UvcGx1Z2lucy9leHRlbnNpb25zL2V4dC1jb21wb25lbnQtY29udGV4dC1tZW51XCIsXCJjc3MvYmFzZS9wbHVnaW5zL2NoYXJ0cy9jaGFydC1hcGV4XCIsXCJjc3Mvc3R5bGVcIixcImNzcy9vdmVycmlkZXNcIixcImNzcy9jb3JlXCIsXCJjc3MvYmFzZS90aGVtZXMvZGFyay1sYXlvdXRcIixcImNzcy9iYXNlL2NvcmUvbWl4aW5zL3RyYW5zaXRpb25zXCIsXCJjc3MvYmFzZS9jb3JlL21peGlucy9tYWluLW1lbnUtbWl4aW5cIixcImNzcy9iYXNlL2NvcmUvbWl4aW5zL2hleDJyZ2JcIixcImNzcy9iYXNlL2NvcmUvbWl4aW5zL2FsZXJ0XCIsXCJjc3MvYmFzZS9jb3JlL21lbnUvbWVudS10eXBlcy92ZXJ0aWNhbC1vdmVybGF5LW1lbnVcIixcImNzcy9iYXNlL2NvcmUvbWVudS9tZW51LXR5cGVzL3ZlcnRpY2FsLW1lbnVcIixcImNzcy9iYXNlL2NvcmUvbWVudS9tZW51LXR5cGVzL2hvcml6b250YWwtbWVudVwiLFwiY3NzL2Jhc2UvY29yZS9jb2xvcnMvcGFsZXR0ZS12YXJpYWJsZXNcIixcImNzcy9iYXNlL2NvcmUvY29sb3JzL3BhbGV0dGUtbm91aVwiLFwiY3NzL2Jhc2UvY29yZS9jb2xvcnMvcGFsZXR0ZS1ncmFkaWVudFwiLFwiY3NzL2Jhc2UvcGFnZXMvdWktZmVhdGhlclwiLFwiY3NzL2Jhc2UvcGFnZXMvcGFnZS1wcm9maWxlXCIsXCJjc3MvYmFzZS9wYWdlcy9wYWdlLXByaWNpbmdcIixcImNzcy9iYXNlL3BhZ2VzL3BhZ2UtbWlzY1wiLFwiY3NzL2Jhc2UvcGFnZXMvcGFnZS1rbm93bGVkZ2UtYmFzZVwiLFwiY3NzL2Jhc2UvcGFnZXMvcGFnZS1mYXFcIixcImNzcy9iYXNlL3BhZ2VzL3BhZ2UtY29taW5nLXNvb25cIixcImNzcy9iYXNlL3BhZ2VzL3BhZ2UtYmxvZ1wiLFwiY3NzL2Jhc2UvcGFnZXMvbW9kYWwtY3JlYXRlLWFwcFwiLFwiY3NzL2Jhc2UvcGFnZXMvZGFzaGJvYXJkLWVjb21tZXJjZVwiLFwiY3NzL2Jhc2UvcGFnZXMvYXV0aGVudGljYXRpb25cIixcImNzcy9iYXNlL3BhZ2VzL2FwcC10b2RvXCIsXCJjc3MvYmFzZS9wYWdlcy9hcHAta2FuYmFuXCIsXCJjc3MvYmFzZS9wYWdlcy9hcHAtaW52b2ljZVwiLFwiY3NzL2Jhc2UvcGFnZXMvYXBwLWludm9pY2UtcHJpbnRcIixcImNzcy9iYXNlL3BhZ2VzL2FwcC1pbnZvaWNlLWxpc3RcIixcImNzcy9iYXNlL3BhZ2VzL2FwcC1maWxlLW1hbmFnZXJcIixcImNzcy9iYXNlL3BhZ2VzL2FwcC1lbWFpbFwiLFwiY3NzL2Jhc2UvcGFnZXMvYXBwLWVjb21tZXJjZVwiLFwiY3NzL2Jhc2UvcGFnZXMvYXBwLWVjb21tZXJjZS1kZXRhaWxzXCIsXCJjc3MvYmFzZS9wYWdlcy9hcHAtY2hhdFwiLFwiY3NzL2Jhc2UvcGFnZXMvYXBwLWNoYXQtbGlzdFwiLFwiY3NzL2Jhc2UvcGFnZXMvYXBwLWNhbGVuZGFyXCIsXCJjc3MvYmFzZS9wbHVnaW5zL3VpL2NvbWluZy1zb29uXCIsXCJjc3MvYmFzZS9wbHVnaW5zL21hcHMvbWFwLWxlYWZsZXRcIixcImNzcy9iYXNlL3BsdWdpbnMvZm9ybXMvcGlja2Vycy9mb3JtLXBpY2thZGF0ZVwiLFwiY3NzL2Jhc2UvcGx1Z2lucy9mb3Jtcy9waWNrZXJzL2Zvcm0tZmxhdC1waWNrclwiLFwiY3NzL2Jhc2UvcGx1Z2lucy9mb3Jtcy9mb3JtLXdpemFyZFwiLFwiY3NzL2Jhc2UvcGx1Z2lucy9mb3Jtcy9mb3JtLXZhbGlkYXRpb25cIixcImNzcy9iYXNlL3BsdWdpbnMvZm9ybXMvZm9ybS1xdWlsbC1lZGl0b3JcIixcImNzcy9iYXNlL3BsdWdpbnMvZm9ybXMvZm9ybS1udW1iZXItaW5wdXRcIixcImNzcy9iYXNlL3BsdWdpbnMvZm9ybXMvZm9ybS1maWxlLXVwbG9hZGVyXCIsXCJjc3MvYmFzZS9wbHVnaW5zL2V4dGVuc2lvbnMvZXh0LWNvbXBvbmVudC10cmVlXCIsXCJjc3MvYmFzZS9wbHVnaW5zL2V4dGVuc2lvbnMvZXh0LWNvbXBvbmVudC10b3VyXCIsXCJjc3MvYmFzZS9wbHVnaW5zL2V4dGVuc2lvbnMvZXh0LWNvbXBvbmVudC10b2FzdHJcIixcImNzcy9iYXNlL3BsdWdpbnMvZXh0ZW5zaW9ucy9leHQtY29tcG9uZW50LXN3aXBlclwiLFwiY3NzL2Jhc2UvcGx1Z2lucy9leHRlbnNpb25zL2V4dC1jb21wb25lbnQtc3dlZXQtYWxlcnRzXCIsXCJjc3MvYmFzZS9wbHVnaW5zL2V4dGVuc2lvbnMvZXh0LWNvbXBvbmVudC1zbGlkZXJzXCIsXCJjc3MvYmFzZS9wbHVnaW5zL2V4dGVuc2lvbnMvZXh0LWNvbXBvbmVudC1yYXRpbmdzXCJdLCAoKSA9PiAoX193ZWJwYWNrX3JlcXVpcmVfXyhcIi4vcmVzb3VyY2VzL3Njc3MvYmFzZS9jb3JlL21peGlucy90cmFuc2l0aW9ucy5zY3NzXCIpKSlcbl9fd2VicGFja19yZXF1aXJlX18uTyh1bmRlZmluZWQsIFtcImNzcy9iYXNlL3BsdWdpbnMvZXh0ZW5zaW9ucy9leHQtY29tcG9uZW50LW1lZGlhLXBsYXllclwiLFwiY3NzL2Jhc2UvcGx1Z2lucy9leHRlbnNpb25zL2V4dC1jb21wb25lbnQtZHJhZy1kcm9wXCIsXCJjc3MvYmFzZS9wbHVnaW5zL2V4dGVuc2lvbnMvZXh0LWNvbXBvbmVudC1jb250ZXh0LW1lbnVcIixcImNzcy9iYXNlL3BsdWdpbnMvY2hhcnRzL2NoYXJ0LWFwZXhcIixcImNzcy9zdHlsZVwiLFwiY3NzL292ZXJyaWRlc1wiLFwiY3NzL2NvcmVcIixcImNzcy9iYXNlL3RoZW1lcy9kYXJrLWxheW91dFwiLFwiY3NzL2Jhc2UvY29yZS9taXhpbnMvdHJhbnNpdGlvbnNcIixcImNzcy9iYXNlL2NvcmUvbWl4aW5zL21haW4tbWVudS1taXhpblwiLFwiY3NzL2Jhc2UvY29yZS9taXhpbnMvaGV4MnJnYlwiLFwiY3NzL2Jhc2UvY29yZS9taXhpbnMvYWxlcnRcIixcImNzcy9iYXNlL2NvcmUvbWVudS9tZW51LXR5cGVzL3ZlcnRpY2FsLW92ZXJsYXktbWVudVwiLFwiY3NzL2Jhc2UvY29yZS9tZW51L21lbnUtdHlwZXMvdmVydGljYWwtbWVudVwiLFwiY3NzL2Jhc2UvY29yZS9tZW51L21lbnUtdHlwZXMvaG9yaXpvbnRhbC1tZW51XCIsXCJjc3MvYmFzZS9jb3JlL2NvbG9ycy9wYWxldHRlLXZhcmlhYmxlc1wiLFwiY3NzL2Jhc2UvY29yZS9jb2xvcnMvcGFsZXR0ZS1ub3VpXCIsXCJjc3MvYmFzZS9jb3JlL2NvbG9ycy9wYWxldHRlLWdyYWRpZW50XCIsXCJjc3MvYmFzZS9wYWdlcy91aS1mZWF0aGVyXCIsXCJjc3MvYmFzZS9wYWdlcy9wYWdlLXByb2ZpbGVcIixcImNzcy9iYXNlL3BhZ2VzL3BhZ2UtcHJpY2luZ1wiLFwiY3NzL2Jhc2UvcGFnZXMvcGFnZS1taXNjXCIsXCJjc3MvYmFzZS9wYWdlcy9wYWdlLWtub3dsZWRnZS1iYXNlXCIsXCJjc3MvYmFzZS9wYWdlcy9wYWdlLWZhcVwiLFwiY3NzL2Jhc2UvcGFnZXMvcGFnZS1jb21pbmctc29vblwiLFwiY3NzL2Jhc2UvcGFnZXMvcGFnZS1ibG9nXCIsXCJjc3MvYmFzZS9wYWdlcy9tb2RhbC1jcmVhdGUtYXBwXCIsXCJjc3MvYmFzZS9wYWdlcy9kYXNoYm9hcmQtZWNvbW1lcmNlXCIsXCJjc3MvYmFzZS9wYWdlcy9hdXRoZW50aWNhdGlvblwiLFwiY3NzL2Jhc2UvcGFnZXMvYXBwLXRvZG9cIixcImNzcy9iYXNlL3BhZ2VzL2FwcC1rYW5iYW5cIixcImNzcy9iYXNlL3BhZ2VzL2FwcC1pbnZvaWNlXCIsXCJjc3MvYmFzZS9wYWdlcy9hcHAtaW52b2ljZS1wcmludFwiLFwiY3NzL2Jhc2UvcGFnZXMvYXBwLWludm9pY2UtbGlzdFwiLFwiY3NzL2Jhc2UvcGFnZXMvYXBwLWZpbGUtbWFuYWdlclwiLFwiY3NzL2Jhc2UvcGFnZXMvYXBwLWVtYWlsXCIsXCJjc3MvYmFzZS9wYWdlcy9hcHAtZWNvbW1lcmNlXCIsXCJjc3MvYmFzZS9wYWdlcy9hcHAtZWNvbW1lcmNlLWRldGFpbHNcIixcImNzcy9iYXNlL3BhZ2VzL2FwcC1jaGF0XCIsXCJjc3MvYmFzZS9wYWdlcy9hcHAtY2hhdC1saXN0XCIsXCJjc3MvYmFzZS9wYWdlcy9hcHAtY2FsZW5kYXJcIixcImNzcy9iYXNlL3BsdWdpbnMvdWkvY29taW5nLXNvb25cIixcImNzcy9iYXNlL3BsdWdpbnMvbWFwcy9tYXAtbGVhZmxldFwiLFwiY3NzL2Jhc2UvcGx1Z2lucy9mb3Jtcy9waWNrZXJzL2Zvcm0tcGlja2FkYXRlXCIsXCJjc3MvYmFzZS9wbHVnaW5zL2Zvcm1zL3BpY2tlcnMvZm9ybS1mbGF0LXBpY2tyXCIsXCJjc3MvYmFzZS9wbHVnaW5zL2Zvcm1zL2Zvcm0td2l6YXJkXCIsXCJjc3MvYmFzZS9wbHVnaW5zL2Zvcm1zL2Zvcm0tdmFsaWRhdGlvblwiLFwiY3NzL2Jhc2UvcGx1Z2lucy9mb3Jtcy9mb3JtLXF1aWxsLWVkaXRvclwiLFwiY3NzL2Jhc2UvcGx1Z2lucy9mb3Jtcy9mb3JtLW51bWJlci1pbnB1dFwiLFwiY3NzL2Jhc2UvcGx1Z2lucy9mb3Jtcy9mb3JtLWZpbGUtdXBsb2FkZXJcIixcImNzcy9iYXNlL3BsdWdpbnMvZXh0ZW5zaW9ucy9leHQtY29tcG9uZW50LXRyZWVcIixcImNzcy9iYXNlL3BsdWdpbnMvZXh0ZW5zaW9ucy9leHQtY29tcG9uZW50LXRvdXJcIixcImNzcy9iYXNlL3BsdWdpbnMvZXh0ZW5zaW9ucy9leHQtY29tcG9uZW50LXRvYXN0clwiLFwiY3NzL2Jhc2UvcGx1Z2lucy9leHRlbnNpb25zL2V4dC1jb21wb25lbnQtc3dpcGVyXCIsXCJjc3MvYmFzZS9wbHVnaW5zL2V4dGVuc2lvbnMvZXh0LWNvbXBvbmVudC1zd2VldC1hbGVydHNcIixcImNzcy9iYXNlL3BsdWdpbnMvZXh0ZW5zaW9ucy9leHQtY29tcG9uZW50LXNsaWRlcnNcIixcImNzcy9iYXNlL3BsdWdpbnMvZXh0ZW5zaW9ucy9leHQtY29tcG9uZW50LXJhdGluZ3NcIl0sICgpID0+IChfX3dlYnBhY2tfcmVxdWlyZV9fKFwiLi9yZXNvdXJjZXMvc2Nzcy9iYXNlL3RoZW1lcy9kYXJrLWxheW91dC5zY3NzXCIpKSlcbl9fd2VicGFja19yZXF1aXJlX18uTyh1bmRlZmluZWQsIFtcImNzcy9iYXNlL3BsdWdpbnMvZXh0ZW5zaW9ucy9leHQtY29tcG9uZW50LW1lZGlhLXBsYXllclwiLFwiY3NzL2Jhc2UvcGx1Z2lucy9leHRlbnNpb25zL2V4dC1jb21wb25lbnQtZHJhZy1kcm9wXCIsXCJjc3MvYmFzZS9wbHVnaW5zL2V4dGVuc2lvbnMvZXh0LWNvbXBvbmVudC1jb250ZXh0LW1lbnVcIixcImNzcy9iYXNlL3BsdWdpbnMvY2hhcnRzL2NoYXJ0LWFwZXhcIixcImNzcy9zdHlsZVwiLFwiY3NzL292ZXJyaWRlc1wiLFwiY3NzL2NvcmVcIixcImNzcy9iYXNlL3RoZW1lcy9kYXJrLWxheW91dFwiLFwiY3NzL2Jhc2UvY29yZS9taXhpbnMvdHJhbnNpdGlvbnNcIixcImNzcy9iYXNlL2NvcmUvbWl4aW5zL21haW4tbWVudS1taXhpblwiLFwiY3NzL2Jhc2UvY29yZS9taXhpbnMvaGV4MnJnYlwiLFwiY3NzL2Jhc2UvY29yZS9taXhpbnMvYWxlcnRcIixcImNzcy9iYXNlL2NvcmUvbWVudS9tZW51LXR5cGVzL3ZlcnRpY2FsLW92ZXJsYXktbWVudVwiLFwiY3NzL2Jhc2UvY29yZS9tZW51L21lbnUtdHlwZXMvdmVydGljYWwtbWVudVwiLFwiY3NzL2Jhc2UvY29yZS9tZW51L21lbnUtdHlwZXMvaG9yaXpvbnRhbC1tZW51XCIsXCJjc3MvYmFzZS9jb3JlL2NvbG9ycy9wYWxldHRlLXZhcmlhYmxlc1wiLFwiY3NzL2Jhc2UvY29yZS9jb2xvcnMvcGFsZXR0ZS1ub3VpXCIsXCJjc3MvYmFzZS9jb3JlL2NvbG9ycy9wYWxldHRlLWdyYWRpZW50XCIsXCJjc3MvYmFzZS9wYWdlcy91aS1mZWF0aGVyXCIsXCJjc3MvYmFzZS9wYWdlcy9wYWdlLXByb2ZpbGVcIixcImNzcy9iYXNlL3BhZ2VzL3BhZ2UtcHJpY2luZ1wiLFwiY3NzL2Jhc2UvcGFnZXMvcGFnZS1taXNjXCIsXCJjc3MvYmFzZS9wYWdlcy9wYWdlLWtub3dsZWRnZS1iYXNlXCIsXCJjc3MvYmFzZS9wYWdlcy9wYWdlLWZhcVwiLFwiY3NzL2Jhc2UvcGFnZXMvcGFnZS1jb21pbmctc29vblwiLFwiY3NzL2Jhc2UvcGFnZXMvcGFnZS1ibG9nXCIsXCJjc3MvYmFzZS9wYWdlcy9tb2RhbC1jcmVhdGUtYXBwXCIsXCJjc3MvYmFzZS9wYWdlcy9kYXNoYm9hcmQtZWNvbW1lcmNlXCIsXCJjc3MvYmFzZS9wYWdlcy9hdXRoZW50aWNhdGlvblwiLFwiY3NzL2Jhc2UvcGFnZXMvYXBwLXRvZG9cIixcImNzcy9iYXNlL3BhZ2VzL2FwcC1rYW5iYW5cIixcImNzcy9iYXNlL3BhZ2VzL2FwcC1pbnZvaWNlXCIsXCJjc3MvYmFzZS9wYWdlcy9hcHAtaW52b2ljZS1wcmludFwiLFwiY3NzL2Jhc2UvcGFnZXMvYXBwLWludm9pY2UtbGlzdFwiLFwiY3NzL2Jhc2UvcGFnZXMvYXBwLWZpbGUtbWFuYWdlclwiLFwiY3NzL2Jhc2UvcGFnZXMvYXBwLWVtYWlsXCIsXCJjc3MvYmFzZS9wYWdlcy9hcHAtZWNvbW1lcmNlXCIsXCJjc3MvYmFzZS9wYWdlcy9hcHAtZWNvbW1lcmNlLWRldGFpbHNcIixcImNzcy9iYXNlL3BhZ2VzL2FwcC1jaGF0XCIsXCJjc3MvYmFzZS9wYWdlcy9hcHAtY2hhdC1saXN0XCIsXCJjc3MvYmFzZS9wYWdlcy9hcHAtY2FsZW5kYXJcIixcImNzcy9iYXNlL3BsdWdpbnMvdWkvY29taW5nLXNvb25cIixcImNzcy9iYXNlL3BsdWdpbnMvbWFwcy9tYXAtbGVhZmxldFwiLFwiY3NzL2Jhc2UvcGx1Z2lucy9mb3Jtcy9waWNrZXJzL2Zvcm0tcGlja2FkYXRlXCIsXCJjc3MvYmFzZS9wbHVnaW5zL2Zvcm1zL3BpY2tlcnMvZm9ybS1mbGF0LXBpY2tyXCIsXCJjc3MvYmFzZS9wbHVnaW5zL2Zvcm1zL2Zvcm0td2l6YXJkXCIsXCJjc3MvYmFzZS9wbHVnaW5zL2Zvcm1zL2Zvcm0tdmFsaWRhdGlvblwiLFwiY3NzL2Jhc2UvcGx1Z2lucy9mb3Jtcy9mb3JtLXF1aWxsLWVkaXRvclwiLFwiY3NzL2Jhc2UvcGx1Z2lucy9mb3Jtcy9mb3JtLW51bWJlci1pbnB1dFwiLFwiY3NzL2Jhc2UvcGx1Z2lucy9mb3Jtcy9mb3JtLWZpbGUtdXBsb2FkZXJcIixcImNzcy9iYXNlL3BsdWdpbnMvZXh0ZW5zaW9ucy9leHQtY29tcG9uZW50LXRyZWVcIixcImNzcy9iYXNlL3BsdWdpbnMvZXh0ZW5zaW9ucy9leHQtY29tcG9uZW50LXRvdXJcIixcImNzcy9iYXNlL3BsdWdpbnMvZXh0ZW5zaW9ucy9leHQtY29tcG9uZW50LXRvYXN0clwiLFwiY3NzL2Jhc2UvcGx1Z2lucy9leHRlbnNpb25zL2V4dC1jb21wb25lbnQtc3dpcGVyXCIsXCJjc3MvYmFzZS9wbHVnaW5zL2V4dGVuc2lvbnMvZXh0LWNvbXBvbmVudC1zd2VldC1hbGVydHNcIixcImNzcy9iYXNlL3BsdWdpbnMvZXh0ZW5zaW9ucy9leHQtY29tcG9uZW50LXNsaWRlcnNcIixcImNzcy9iYXNlL3BsdWdpbnMvZXh0ZW5zaW9ucy9leHQtY29tcG9uZW50LXJhdGluZ3NcIl0sICgpID0+IChfX3dlYnBhY2tfcmVxdWlyZV9fKFwiLi9yZXNvdXJjZXMvc2Nzcy9jb3JlLnNjc3NcIikpKVxuX193ZWJwYWNrX3JlcXVpcmVfXy5PKHVuZGVmaW5lZCwgW1wiY3NzL2Jhc2UvcGx1Z2lucy9leHRlbnNpb25zL2V4dC1jb21wb25lbnQtbWVkaWEtcGxheWVyXCIsXCJjc3MvYmFzZS9wbHVnaW5zL2V4dGVuc2lvbnMvZXh0LWNvbXBvbmVudC1kcmFnLWRyb3BcIixcImNzcy9iYXNlL3BsdWdpbnMvZXh0ZW5zaW9ucy9leHQtY29tcG9uZW50LWNvbnRleHQtbWVudVwiLFwiY3NzL2Jhc2UvcGx1Z2lucy9jaGFydHMvY2hhcnQtYXBleFwiLFwiY3NzL3N0eWxlXCIsXCJjc3Mvb3ZlcnJpZGVzXCIsXCJjc3MvY29yZVwiLFwiY3NzL2Jhc2UvdGhlbWVzL2RhcmstbGF5b3V0XCIsXCJjc3MvYmFzZS9jb3JlL21peGlucy90cmFuc2l0aW9uc1wiLFwiY3NzL2Jhc2UvY29yZS9taXhpbnMvbWFpbi1tZW51LW1peGluXCIsXCJjc3MvYmFzZS9jb3JlL21peGlucy9oZXgycmdiXCIsXCJjc3MvYmFzZS9jb3JlL21peGlucy9hbGVydFwiLFwiY3NzL2Jhc2UvY29yZS9tZW51L21lbnUtdHlwZXMvdmVydGljYWwtb3ZlcmxheS1tZW51XCIsXCJjc3MvYmFzZS9jb3JlL21lbnUvbWVudS10eXBlcy92ZXJ0aWNhbC1tZW51XCIsXCJjc3MvYmFzZS9jb3JlL21lbnUvbWVudS10eXBlcy9ob3Jpem9udGFsLW1lbnVcIixcImNzcy9iYXNlL2NvcmUvY29sb3JzL3BhbGV0dGUtdmFyaWFibGVzXCIsXCJjc3MvYmFzZS9jb3JlL2NvbG9ycy9wYWxldHRlLW5vdWlcIixcImNzcy9iYXNlL2NvcmUvY29sb3JzL3BhbGV0dGUtZ3JhZGllbnRcIixcImNzcy9iYXNlL3BhZ2VzL3VpLWZlYXRoZXJcIixcImNzcy9iYXNlL3BhZ2VzL3BhZ2UtcHJvZmlsZVwiLFwiY3NzL2Jhc2UvcGFnZXMvcGFnZS1wcmljaW5nXCIsXCJjc3MvYmFzZS9wYWdlcy9wYWdlLW1pc2NcIixcImNzcy9iYXNlL3BhZ2VzL3BhZ2Uta25vd2xlZGdlLWJhc2VcIixcImNzcy9iYXNlL3BhZ2VzL3BhZ2UtZmFxXCIsXCJjc3MvYmFzZS9wYWdlcy9wYWdlLWNvbWluZy1zb29uXCIsXCJjc3MvYmFzZS9wYWdlcy9wYWdlLWJsb2dcIixcImNzcy9iYXNlL3BhZ2VzL21vZGFsLWNyZWF0ZS1hcHBcIixcImNzcy9iYXNlL3BhZ2VzL2Rhc2hib2FyZC1lY29tbWVyY2VcIixcImNzcy9iYXNlL3BhZ2VzL2F1dGhlbnRpY2F0aW9uXCIsXCJjc3MvYmFzZS9wYWdlcy9hcHAtdG9kb1wiLFwiY3NzL2Jhc2UvcGFnZXMvYXBwLWthbmJhblwiLFwiY3NzL2Jhc2UvcGFnZXMvYXBwLWludm9pY2VcIixcImNzcy9iYXNlL3BhZ2VzL2FwcC1pbnZvaWNlLXByaW50XCIsXCJjc3MvYmFzZS9wYWdlcy9hcHAtaW52b2ljZS1saXN0XCIsXCJjc3MvYmFzZS9wYWdlcy9hcHAtZmlsZS1tYW5hZ2VyXCIsXCJjc3MvYmFzZS9wYWdlcy9hcHAtZW1haWxcIixcImNzcy9iYXNlL3BhZ2VzL2FwcC1lY29tbWVyY2VcIixcImNzcy9iYXNlL3BhZ2VzL2FwcC1lY29tbWVyY2UtZGV0YWlsc1wiLFwiY3NzL2Jhc2UvcGFnZXMvYXBwLWNoYXRcIixcImNzcy9iYXNlL3BhZ2VzL2FwcC1jaGF0LWxpc3RcIixcImNzcy9iYXNlL3BhZ2VzL2FwcC1jYWxlbmRhclwiLFwiY3NzL2Jhc2UvcGx1Z2lucy91aS9jb21pbmctc29vblwiLFwiY3NzL2Jhc2UvcGx1Z2lucy9tYXBzL21hcC1sZWFmbGV0XCIsXCJjc3MvYmFzZS9wbHVnaW5zL2Zvcm1zL3BpY2tlcnMvZm9ybS1waWNrYWRhdGVcIixcImNzcy9iYXNlL3BsdWdpbnMvZm9ybXMvcGlja2Vycy9mb3JtLWZsYXQtcGlja3JcIixcImNzcy9iYXNlL3BsdWdpbnMvZm9ybXMvZm9ybS13aXphcmRcIixcImNzcy9iYXNlL3BsdWdpbnMvZm9ybXMvZm9ybS12YWxpZGF0aW9uXCIsXCJjc3MvYmFzZS9wbHVnaW5zL2Zvcm1zL2Zvcm0tcXVpbGwtZWRpdG9yXCIsXCJjc3MvYmFzZS9wbHVnaW5zL2Zvcm1zL2Zvcm0tbnVtYmVyLWlucHV0XCIsXCJjc3MvYmFzZS9wbHVnaW5zL2Zvcm1zL2Zvcm0tZmlsZS11cGxvYWRlclwiLFwiY3NzL2Jhc2UvcGx1Z2lucy9leHRlbnNpb25zL2V4dC1jb21wb25lbnQtdHJlZVwiLFwiY3NzL2Jhc2UvcGx1Z2lucy9leHRlbnNpb25zL2V4dC1jb21wb25lbnQtdG91clwiLFwiY3NzL2Jhc2UvcGx1Z2lucy9leHRlbnNpb25zL2V4dC1jb21wb25lbnQtdG9hc3RyXCIsXCJjc3MvYmFzZS9wbHVnaW5zL2V4dGVuc2lvbnMvZXh0LWNvbXBvbmVudC1zd2lwZXJcIixcImNzcy9iYXNlL3BsdWdpbnMvZXh0ZW5zaW9ucy9leHQtY29tcG9uZW50LXN3ZWV0LWFsZXJ0c1wiLFwiY3NzL2Jhc2UvcGx1Z2lucy9leHRlbnNpb25zL2V4dC1jb21wb25lbnQtc2xpZGVyc1wiLFwiY3NzL2Jhc2UvcGx1Z2lucy9leHRlbnNpb25zL2V4dC1jb21wb25lbnQtcmF0aW5nc1wiXSwgKCkgPT4gKF9fd2VicGFja19yZXF1aXJlX18oXCIuL3Jlc291cmNlcy9zY3NzL292ZXJyaWRlcy5zY3NzXCIpKSlcbnZhciBfX3dlYnBhY2tfZXhwb3J0c19fID0gX193ZWJwYWNrX3JlcXVpcmVfXy5PKHVuZGVmaW5lZCwgW1wiY3NzL2Jhc2UvcGx1Z2lucy9leHRlbnNpb25zL2V4dC1jb21wb25lbnQtbWVkaWEtcGxheWVyXCIsXCJjc3MvYmFzZS9wbHVnaW5zL2V4dGVuc2lvbnMvZXh0LWNvbXBvbmVudC1kcmFnLWRyb3BcIixcImNzcy9iYXNlL3BsdWdpbnMvZXh0ZW5zaW9ucy9leHQtY29tcG9uZW50LWNvbnRleHQtbWVudVwiLFwiY3NzL2Jhc2UvcGx1Z2lucy9jaGFydHMvY2hhcnQtYXBleFwiLFwiY3NzL3N0eWxlXCIsXCJjc3Mvb3ZlcnJpZGVzXCIsXCJjc3MvY29yZVwiLFwiY3NzL2Jhc2UvdGhlbWVzL2RhcmstbGF5b3V0XCIsXCJjc3MvYmFzZS9jb3JlL21peGlucy90cmFuc2l0aW9uc1wiLFwiY3NzL2Jhc2UvY29yZS9taXhpbnMvbWFpbi1tZW51LW1peGluXCIsXCJjc3MvYmFzZS9jb3JlL21peGlucy9oZXgycmdiXCIsXCJjc3MvYmFzZS9jb3JlL21peGlucy9hbGVydFwiLFwiY3NzL2Jhc2UvY29yZS9tZW51L21lbnUtdHlwZXMvdmVydGljYWwtb3ZlcmxheS1tZW51XCIsXCJjc3MvYmFzZS9jb3JlL21lbnUvbWVudS10eXBlcy92ZXJ0aWNhbC1tZW51XCIsXCJjc3MvYmFzZS9jb3JlL21lbnUvbWVudS10eXBlcy9ob3Jpem9udGFsLW1lbnVcIixcImNzcy9iYXNlL2NvcmUvY29sb3JzL3BhbGV0dGUtdmFyaWFibGVzXCIsXCJjc3MvYmFzZS9jb3JlL2NvbG9ycy9wYWxldHRlLW5vdWlcIixcImNzcy9iYXNlL2NvcmUvY29sb3JzL3BhbGV0dGUtZ3JhZGllbnRcIixcImNzcy9iYXNlL3BhZ2VzL3VpLWZlYXRoZXJcIixcImNzcy9iYXNlL3BhZ2VzL3BhZ2UtcHJvZmlsZVwiLFwiY3NzL2Jhc2UvcGFnZXMvcGFnZS1wcmljaW5nXCIsXCJjc3MvYmFzZS9wYWdlcy9wYWdlLW1pc2NcIixcImNzcy9iYXNlL3BhZ2VzL3BhZ2Uta25vd2xlZGdlLWJhc2VcIixcImNzcy9iYXNlL3BhZ2VzL3BhZ2UtZmFxXCIsXCJjc3MvYmFzZS9wYWdlcy9wYWdlLWNvbWluZy1zb29uXCIsXCJjc3MvYmFzZS9wYWdlcy9wYWdlLWJsb2dcIixcImNzcy9iYXNlL3BhZ2VzL21vZGFsLWNyZWF0ZS1hcHBcIixcImNzcy9iYXNlL3BhZ2VzL2Rhc2hib2FyZC1lY29tbWVyY2VcIixcImNzcy9iYXNlL3BhZ2VzL2F1dGhlbnRpY2F0aW9uXCIsXCJjc3MvYmFzZS9wYWdlcy9hcHAtdG9kb1wiLFwiY3NzL2Jhc2UvcGFnZXMvYXBwLWthbmJhblwiLFwiY3NzL2Jhc2UvcGFnZXMvYXBwLWludm9pY2VcIixcImNzcy9iYXNlL3BhZ2VzL2FwcC1pbnZvaWNlLXByaW50XCIsXCJjc3MvYmFzZS9wYWdlcy9hcHAtaW52b2ljZS1saXN0XCIsXCJjc3MvYmFzZS9wYWdlcy9hcHAtZmlsZS1tYW5hZ2VyXCIsXCJjc3MvYmFzZS9wYWdlcy9hcHAtZW1haWxcIixcImNzcy9iYXNlL3BhZ2VzL2FwcC1lY29tbWVyY2VcIixcImNzcy9iYXNlL3BhZ2VzL2FwcC1lY29tbWVyY2UtZGV0YWlsc1wiLFwiY3NzL2Jhc2UvcGFnZXMvYXBwLWNoYXRcIixcImNzcy9iYXNlL3BhZ2VzL2FwcC1jaGF0LWxpc3RcIixcImNzcy9iYXNlL3BhZ2VzL2FwcC1jYWxlbmRhclwiLFwiY3NzL2Jhc2UvcGx1Z2lucy91aS9jb21pbmctc29vblwiLFwiY3NzL2Jhc2UvcGx1Z2lucy9tYXBzL21hcC1sZWFmbGV0XCIsXCJjc3MvYmFzZS9wbHVnaW5zL2Zvcm1zL3BpY2tlcnMvZm9ybS1waWNrYWRhdGVcIixcImNzcy9iYXNlL3BsdWdpbnMvZm9ybXMvcGlja2Vycy9mb3JtLWZsYXQtcGlja3JcIixcImNzcy9iYXNlL3BsdWdpbnMvZm9ybXMvZm9ybS13aXphcmRcIixcImNzcy9iYXNlL3BsdWdpbnMvZm9ybXMvZm9ybS12YWxpZGF0aW9uXCIsXCJjc3MvYmFzZS9wbHVnaW5zL2Zvcm1zL2Zvcm0tcXVpbGwtZWRpdG9yXCIsXCJjc3MvYmFzZS9wbHVnaW5zL2Zvcm1zL2Zvcm0tbnVtYmVyLWlucHV0XCIsXCJjc3MvYmFzZS9wbHVnaW5zL2Zvcm1zL2Zvcm0tZmlsZS11cGxvYWRlclwiLFwiY3NzL2Jhc2UvcGx1Z2lucy9leHRlbnNpb25zL2V4dC1jb21wb25lbnQtdHJlZVwiLFwiY3NzL2Jhc2UvcGx1Z2lucy9leHRlbnNpb25zL2V4dC1jb21wb25lbnQtdG91clwiLFwiY3NzL2Jhc2UvcGx1Z2lucy9leHRlbnNpb25zL2V4dC1jb21wb25lbnQtdG9hc3RyXCIsXCJjc3MvYmFzZS9wbHVnaW5zL2V4dGVuc2lvbnMvZXh0LWNvbXBvbmVudC1zd2lwZXJcIixcImNzcy9iYXNlL3BsdWdpbnMvZXh0ZW5zaW9ucy9leHQtY29tcG9uZW50LXN3ZWV0LWFsZXJ0c1wiLFwiY3NzL2Jhc2UvcGx1Z2lucy9leHRlbnNpb25zL2V4dC1jb21wb25lbnQtc2xpZGVyc1wiLFwiY3NzL2Jhc2UvcGx1Z2lucy9leHRlbnNpb25zL2V4dC1jb21wb25lbnQtcmF0aW5nc1wiXSwgKCkgPT4gKF9fd2VicGFja19yZXF1aXJlX18oXCIuL3Jlc291cmNlcy9hc3NldHMvc2Nzcy9zdHlsZS5zY3NzXCIpKSlcbl9fd2VicGFja19leHBvcnRzX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fLk8oX193ZWJwYWNrX2V4cG9ydHNfXyk7XG4iLCIiXSwibmFtZXMiOlsiTWFpbiIsIl9fbmFtZV9fIiwid2lkZ2V0cyIsImNvbXBvbmVudHMiLCJvdmVybGF5cyIsImNvbG9ycGFja3MiLCJza2lucyIsIlBhY2siLCJTZXR0aW5nc1dpbiIsIm5hbWUiLCJUcmFkaW5nVnVlIiwiZGF0YSIsImRjIiwidGl0bGUiLCJ3aWR0aCIsImhlaWdodCIsImxvZ19zY2FsZSIsInN5bWJvbCIsImluZGV4X2Jhc2VkIiwidGltZXpvbmUiLCJ4c2V0dCIsIm1pbl9oZWlnaHQiLCJvdnMiLCJleHQiLCJuaWdodCIsInRvcCIsInJlc2V0a2V5IiwiY29tcHV0ZWQiLCJjb2xvcnMiLCJjb2xvckJhY2siLCJjb2xvckdyaWQiLCJjb2xvclRleHQiLCJtb3VudGVkIiwid2luZG93IiwiYmVmb3JlRGVzdHJveSIsIm1ldGhvZHMiLCJvblJlc2l6ZSIsInNwbGluZSIsImNhbmRsZXMiLCJ4YmFycyIsInRyYWRlIiwid2luX3F1ZXJ5IiwiYiIsInJlc2V0Iiwic3RhdGUiLCJvbnNlbGVjdCIsImlkIiwidGltZXpvbmVkIiwibG9hZF9jaHVuayIsInJhbmdlIiwidDEiLCJ0MiIsIngiLCJzeW1ib2xiZyIsInkiLCJwYWlyYmciLCJxIiwiZmV0Y2giLCJyIiwicGFyc2VfYmluYW5jZSIsImZvcm1hdCIsIm9uX3RyYWRlcyIsInQiLCJwcmljZSIsInZvbHVtZSIsImRhdGFzIiwicGFyc2VGbG9hdCIsInByb3BzIiwic3R5bGUiLCJtaXhpbnMiLCJ3dyIsIndoIiwibGVmdCIsInR2dyIsInR2aCIsImhzX3N0eWxlIiwiZHJhZyIsImhzX21vdXNlZG93biIsImUiLCJ0eXBlIiwiaDEiLCJoMiIsIlV0aWxzIiwiaHNfbW91c2V1cCIsImhzX21vdXNlbW92ZSIsIm5ld19oMiIsImhzX21vdXNlbGVhdmUiLCJXaW5kb3ciLCJzZXR0Iiwib25fY2xvc2UiLCJvbl9jbGljayIsInNpZGUiLCJpbmRleCIsIlN0ZElucHV0Iiwic2V0dGxpc3QiLCJzMmQiLCJzdHIiLCJ1cGRhdGVfc2V0dCIsImsiLCJ2YWwiLCJ2YWxOIiwib25Nb3VzZURvd24iLCJldmVudCIsInByZXZlbnREZWZhdWx0Iiwib2Zmc2V0X3giLCJjbGllbnRYIiwib2Zmc2V0X3kiLCJjbGllbnRZIiwiZG9jdW1lbnQiLCJvbm1vdXNldXAiLCJzdG9wZHJhZyIsIm9ubW91c2Vtb3ZlIiwib25kcmFnIiwiU2hhcmVkIiwidHYiLCJ1c2Vfd2luZG93IiwieGNoYXJ0bGluayQiLCJzaGFyZWQiLCJ0YXJnZXRzIiwib25zZXR0aW5ncyIsImFsbCIsImNsZWFyVGltZW91dCIsInJlc2V0X2lkIiwicnVsZXMiLCJyZWZzIiwibWV0YSIsImVsIiwiZ2V0RWxlbWVudEJ5SWQiLCJjb21iaW5lIiwic2V0VGltZW91dCIsImNvbWJpbmVkIiwiZ2ViY24iLCJlbHMiLCJyYW5rIiwiZHN0IiwicGFpciIsIk9iamVjdCIsImtleXMiLCJBcnJheSIsImlzQXJyYXkiLCJkIiwiYXNzaWduIiwib3V0Iiwic3BsaXRyIiwibWF0Y2hlcyIsInB1c2giLCJzb3J0IiwiYSIsInNyYyIsImluY2x1ZGVzIiwicnVsZSIsInRyaW0iLCJzcGxpdCIsIm1hcCIsInR1cCIsImxlbmd0aCIsImNvbXBpbGUiLCIkcmVmcyIsImNoYXJ0IiwiaG9va3MiLCIkd2F0Y2giLCJnZXQiLCJmaWx0ZXIiLCJzZXR0aW5ncyIsIiRzdGF0ZSIsIm9udG9vbHMiLCJiaW5kIiwiY3Vyc29yIiwiYXJncyIsIm1haW4iLCJfbGF5b3V0IiwiZ3JpZHMiLCJncmlkX2lkIiwibWMiLCIkIiwieSQiLCJnIiwieHgiLCJpc1giLCJ5eSIsImlzWSIsInVwZCIsInQyc2NyZWVuIiwiJDJzY3JlZW4iLCJjdXJzb3JfY2hhbmdlZCIsIm5vdyIsIkRhdGUiLCJnZXRUaW1lIiwicG9zaXRpb24iLCJsb2NrIiwibiIsInAiLCJyZW0iLCJyZW1vdmVkIiwiJHV1aWQiLCJ0b29scyIsImNvcHlfdG9vbHMiLCJmb3JFYWNoIiwiZGVsIiwidG9vbCIsInV1aWQiLCJleGkiLCJnZXRfb25lIiwiJHNldCIsImNvcHkiLCIkc2VsZWN0ZWQiLCJzZWMiLCJncmlkIiwiJGNoaWxkcmVuIiwib3YiLCJwaW5zIiwicmVfaW5pdCIsImFkZCIsIl9faWRfXyIsIk1hdGgiLCJyYW5kb20iLCJvYmoiLCJtb2QiLCJKU09OIiwicGFyc2UiLCJzdHJpbmdpZnkiLCJpZHMiLCJwcmV2IiwibGlzdCIsIlZ1ZSIsIlNwbGl0dGVyIiwiJGVsIiwiYWRkRXZlbnRMaXN0ZW5lciIsIm9ubW91c2VsZWF2ZSIsInBsYWNlX3NwbGl0dGVycyIsImNhbGNfaGVpZ2h0cyIsIm9uZ3JpZHMiLCJyZW1vdmVfd2lkZ2V0cyIsInMiLCJpIiwiZzEiLCJnMiIsInV1aWQyIiwic2V0IiwiY2xzIiwiZ3JpZDEiLCJncmlkMiIsImhzIiwic3VtIiwicmVkdWNlIiwiaCIsImdyaWRfb3ZzIiwib2ZmY2hhcnQiLCJ1bmRlZmluZWQiLCIkZGVsZXRlIiwicmVtb3ZlRXZlbnRMaXN0ZW5lciIsIm1vdXNldXAiLCJtb3VzZWxlYXZlIiwiYWRkX3N0eWxlIiwic3RiciIsInNoZWV0UGFyZW50IiwicGFyZW50Tm9kZSIsInJlbW92ZUNoaWxkIiwic2hlZXQiLCJjcmVhdGVFbGVtZW50Iiwic2V0QXR0cmlidXRlIiwiaW5uZXJIVE1MIiwiYm9keSIsImFwcGVuZENoaWxkIiwicmVtX3N0eWxlIiwiQWRkV2luIiwib25idXR0b24iLCJkYXRhSW5kZXgiLCJvbmNoYXJ0IiwiYnV0dG9uIiwiZGlzcGxheSIsImZsYWciLCJzcGxpY2UiLCJpMCIsImkxIiwidXBkYXRlX2lkcyIsImF2Z19ncmlkX2giLCJ1bnNoaWZ0IiwiZiIsInZhbHVlcyIsImZpbmQiLCJjb25zb2xlIiwibG9nIiwicHJlc2V0IiwiZ2V0X3ByZXNldCIsInByb3RvIiwibWV0YV9pbmZvIiwiZ2giLCJzZXR0MmRlc2MiLCJzZXRDaGFyQXQiLCJjaHIiLCJzdWJzdHJpbmciLCJyZXBsYWNlIiwidHVwbGUiLCJ0b1VwcGVyQ2FzZSIsImpvaW4iLCJDaGFydExpbmsiLCJHcmlkUmVzaXplIiwiTGVnZW5kQnV0dG9ucyIsIkFwcCIsInJlbmRlciIsIlN0cmVhbSIsInVybCIsIndzIiwiV2ViU29ja2V0IiwiY2IiLCJvbm9wZW4iLCJvbm1lc3NhZ2UiLCJvbnRyYWRlcyIsIm9mZiIsImNsb3NlIiwiU0VDT05EIiwiTUlOVVRFIiwiTUlOVVRFMyIsIk1JTlVURTUiLCJNSU5VVEUxNSIsIk1JTlVURTMwIiwiSE9VUiIsIkhPVVI0IiwiSE9VUjEyIiwiREFZIiwiV0VFSyIsIk1PTlRIIiwiWUVBUiIsIk1PTlRITUFQIiwiVElNRVNDQUxFUyIsIiRTQ0FMRVMiLCJDaGFydENvbmZpZyIsIlNCTUlOIiwiU0JNQVgiLCJJbmZpbml0eSIsIlRPT0xCQVIiLCJUQl9JQ09OIiwiVEJfSVRFTV9NIiwiVEJfSUNPTl9CUkkiLCJUQl9JQ09OX0hPTEQiLCJUQl9CT1JERVIiLCJUQl9CX1NUWUxFIiwiVE9PTF9DT0xMIiwiRVhQQU5EIiwiQ0FORExFVyIsIkdSSURYIiwiR1JJRFkiLCJCT1RCQVIiLCJQQU5IRUlHSFQiLCJERUZBVUxUX0xFTiIsIk1JTklNVU1fTEVOIiwiTUlOX1pPT00iLCJNQVhfWk9PTSIsIlZPTFNDQUxFIiwiVVhfT1BBQ0lUWSIsIlpPT01fTU9ERSIsIkxfQlROX1NJWkUiLCJMX0JUTl9NQVJHSU4iLCJTQ1JPTExfV0hFRUwiLCJGT05UIiwiSUJfVEZfV0FSTiIsIk1BUF9VTklUIiwibWFwX3VuaXQiLCJJbmRleGVkQXJyYXkiLCJDb25zdCIsIm5hbWUyTmFtZSIsImNsYW1wIiwibnVtIiwibWluIiwibWF4IiwiYWRkX3plcm8iLCJkYXlfc3RhcnQiLCJzdGFydCIsInNldFVUQ0hvdXJzIiwibW9udGhfc3RhcnQiLCJkYXRlIiwiVVRDIiwiZ2V0RnVsbFllYXIiLCJnZXRNb250aCIsInllYXJfc3RhcnQiLCJnZXRfeWVhciIsImdldFVUQ0Z1bGxZZWFyIiwiZ2V0X21vbnRoIiwiZ2V0VVRDTW9udGgiLCJuZWFyZXN0X2EiLCJhcnJheSIsImRpc3QiLCJ4aSIsImFicyIsInJvdW5kIiwiZGVjaW1hbHMiLCJ0b0ZpeGVkIiwic3RyaXAiLCJudW1iZXIiLCJ0b1ByZWNpc2lvbiIsImdldF9kYXkiLCJnZXREYXRlIiwib3ZlcndyaXRlIiwiYXJyIiwibmV3X2FyciIsImNvcHlfbGF5b3V0IiwibmV3X29iaiIsIm0iLCJkZXRlY3RfaW50ZXJ2YWwiLCJvaGxjdiIsImxlbiIsInNsaWNlIiwiZ2V0X251bV9pZCIsInBhcnNlSW50IiwicG9wIiwiZmFzdF9maWx0ZXIiLCJpYSIsInJlcyIsImdldFJhbmdlIiwidmFscG9zIiwibmV4dCIsImZhc3RfZmlsdGVyX2kiLCJmbG9vciIsImkyIiwiZmFzdF9uZWFyZXN0IiwibmV4dGxvdyIsIm5leHRoaWdoIiwicGF1c2UiLCJkZWxheSIsIlByb21pc2UiLCJycyIsInJqIiwic21hcnRfd2hlZWwiLCJkZWx0YSIsInNpZ24iLCJnZXRfZGVsdGFYIiwib3JpZ2luYWxFdmVudCIsImRlbHRhWCIsImdldF9kZWx0YVkiLCJkZWx0YVkiLCJhcHBseV9vcGFjaXR5IiwiYyIsIm9wIiwidG9TdHJpbmciLCJwYXJzZV90ZiIsInNtdGgiLCJpbmRleF9zaGlmdCIsInN1YiIsImZpcnN0Iiwic2Vjb25kIiwiaiIsIm1lYXN1cmVUZXh0IiwiY3R4IiwidGV4dCIsInR2X2lkIiwibWVhc3VyZVRleHRPcmciLCJkb2MiLCJiYXNlIiwiZm9udCIsImlubmVyVGV4dCIsIm9mZnNldFdpZHRoIiwidGVtcCIsInYiLCJ3YXJuIiwiaXNfc2NyX3Byb3BzX3VwZCIsIiRwcm9wcyIsInNvbWUiLCJkZWxheWVkX2V4ZWMiLCJzY3JpcHQiLCJleGVjSW50ZXJ2YWwiLCJkdCIsIiRsYXN0X2V4ZWMiLCJmb3JtYXRfbmFtZSIsInJlZyIsIlJlZ0V4cCIsInhtb2RlIiwiaXNfbW9iaWxlIiwiZGVmYXVsdF9wcmV2ZW50ZWQiLCJvcmlnaW5hbCIsImRlZmF1bHRQcmV2ZW50ZWQiLCJ3IiwibmF2aWdhdG9yIiwibWF4VG91Y2hQb2ludHMiLCJtc01heFRvdWNoUG9pbnRzIiwiRG9jdW1lbnRUb3VjaCJdLCJzb3VyY2VSb290IjoiIn0=