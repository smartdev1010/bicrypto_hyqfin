(self["webpackChunk"] = self["webpackChunk"] || []).push([["resources_src_Pages_bot_BotTradePage_vue"],{

/***/ "./node_modules/babel-loader/lib/index.js??clonedRuleSet-5[0].rules[0].use[0]!./node_modules/vue-loader/lib/index.js??vue-loader-options!./resources/src/Pages/bot/BotTradePage.vue?vue&type=script&lang=js&":
/*!*******************************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/babel-loader/lib/index.js??clonedRuleSet-5[0].rules[0].use[0]!./node_modules/vue-loader/lib/index.js??vue-loader-options!./resources/src/Pages/bot/BotTradePage.vue?vue&type=script&lang=js& ***!
  \*******************************************************************************************************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var core_js_modules_es_object_to_string_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! core-js/modules/es.object.to-string.js */ "./node_modules/core-js/modules/es.object.to-string.js");
/* harmony import */ var core_js_modules_es_object_to_string_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es_object_to_string_js__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var core_js_modules_es_array_for_each_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! core-js/modules/es.array.for-each.js */ "./node_modules/core-js/modules/es.array.for-each.js");
/* harmony import */ var core_js_modules_es_array_for_each_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es_array_for_each_js__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var core_js_modules_web_dom_collections_for_each_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! core-js/modules/web.dom-collections.for-each.js */ "./node_modules/core-js/modules/web.dom-collections.for-each.js");
/* harmony import */ var core_js_modules_web_dom_collections_for_each_js__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_web_dom_collections_for_each_js__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var vue_grid_layout__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! vue-grid-layout */ "./node_modules/vue-grid-layout/dist/vue-grid-layout.common.js");
/* harmony import */ var vue_grid_layout__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(vue_grid_layout__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var _components_trading_Marketinfo_vue__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../components/trading/Marketinfo.vue */ "./resources/src/components/trading/Marketinfo.vue");
/* harmony import */ var _components_trading_Tradingview_vue__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../components/trading/Tradingview.vue */ "./resources/src/components/trading/Tradingview.vue");
/* harmony import */ var _components_trading_Orderbook_vue__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../components/trading/Orderbook.vue */ "./resources/src/components/trading/Orderbook.vue");
/* harmony import */ var _components_trading_Markets_vue__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../../components/trading/Markets.vue */ "./resources/src/components/trading/Markets.vue");
/* harmony import */ var _components_bot_Trades_vue__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../../components/bot/Trades.vue */ "./resources/src/components/bot/Trades.vue");



//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//






var testLayouts = {
  xs: [{
    x: 0,
    y: 17,
    w: 2,
    h: 7,
    i: "0"
  }, // Markets
  {
    x: 0,
    y: 13,
    w: 2,
    h: 7,
    i: "1"
  }, // Trades
  {
    x: 0,
    y: 0,
    w: 6,
    h: 1,
    i: "2"
  }, // Marketinfo
  {
    x: 0,
    y: 1,
    w: 4,
    h: 6,
    i: "3"
  }, // Tradingview
  {
    x: 0,
    y: 7,
    w: 4,
    h: 6,
    i: "4"
  }, // Order
  {
    x: 2,
    y: 13,
    w: 2,
    h: 14,
    i: "5"
  } // Orderbook
  ],
  sm: [{
    x: 0,
    y: 16,
    w: 3,
    h: 8,
    i: "0"
  }, // Markets
  {
    x: 3,
    y: 16,
    w: 3,
    h: 8,
    i: "1"
  }, // Trades
  {
    x: 0,
    y: 0,
    w: 6,
    h: 2,
    i: "2"
  }, // Marketinfo
  {
    x: 0,
    y: 2,
    w: 4,
    h: 8,
    i: "3"
  }, // Tradingview
  {
    x: 0,
    y: 10,
    w: 4,
    h: 6,
    i: "4"
  }, // Order
  {
    x: 4,
    y: 2,
    w: 2,
    h: 14,
    i: "5"
  } // Orderbook
  ],
  md: [{
    x: 0,
    y: 0,
    w: 3,
    h: 8,
    i: "0"
  }, // Markets
  {
    x: 0,
    y: 10,
    w: 3,
    h: 8,
    i: "1"
  }, // Trades
  {
    x: 3,
    y: 0,
    w: 7,
    h: 2,
    i: "2"
  }, // Marketinfo
  {
    x: 3,
    y: 2,
    w: 5,
    h: 8,
    i: "3"
  }, // Tradingview
  {
    x: 3,
    y: 10,
    w: 5,
    h: 6,
    i: "4"
  }, // Order
  {
    x: 8,
    y: 4,
    w: 2,
    h: 14,
    i: "5"
  } // Orderbook
  ],
  lg: [{
    x: 0,
    y: 0,
    w: 3,
    h: 8,
    i: "0"
  }, // Markets
  {
    x: 0,
    y: 10,
    w: 3,
    h: 8,
    i: "1"
  }, // Trades
  {
    x: 3,
    y: 0,
    w: 6,
    h: 2,
    i: "2"
  }, // Marketinfo
  {
    x: 3,
    y: 2,
    w: 6,
    h: 8,
    i: "3"
  }, // Tradingview
  {
    x: 3,
    y: 10,
    w: 6,
    h: 6,
    i: "4"
  }, // Order
  {
    x: 9,
    y: 0,
    w: 3,
    h: 16,
    i: "5"
  } // Orderbook
  ]
};
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  // component list
  components: {
    Marketinfo: _components_trading_Marketinfo_vue__WEBPACK_IMPORTED_MODULE_4__["default"],
    Tradingview: _components_trading_Tradingview_vue__WEBPACK_IMPORTED_MODULE_5__["default"],
    Orderbook: _components_trading_Orderbook_vue__WEBPACK_IMPORTED_MODULE_6__["default"],
    Markets: _components_trading_Markets_vue__WEBPACK_IMPORTED_MODULE_7__["default"],
    Trades: _components_bot_Trades_vue__WEBPACK_IMPORTED_MODULE_8__["default"],
    GridLayout: vue_grid_layout__WEBPACK_IMPORTED_MODULE_3__.GridLayout,
    GridItem: vue_grid_layout__WEBPACK_IMPORTED_MODULE_3__.GridItem
  },
  // component data
  data: function data() {
    return {
      symbol: this.$route.params.symbol,
      currency: this.$route.params.currency,
      activeItem: "pills-market",
      pairs: null,
      provider: null,
      provide: null,
      limit: null,
      user: [],
      gnl: [],
      layouts: testLayouts,
      layout: testLayouts["lg"],
      draggable: true,
      resizable: true,
      responsive: true,
      bot_timing: null,
      bot_times: null,
      bot_type: null,
      runningBot: null,
      loading: false,
      timing: null,
      amount: null,
      balance: null,
      bot_id: null,
      type: null,
      min_amount: null,
      max_amount: null
    };
  },
  watch: {
    eventLog: function eventLog() {
      var eventsDiv = this.$refs.eventsDiv;
      eventsDiv.scrollTop = eventsDiv.scrollHeight;
    },
    $route: function $route(to, from) {
      this.symbol = this.$route.params.symbol;
      this.currency = this.$route.params.currency;
    }
  },
  // custom methods
  methods: {
    Order: function Order() {
      var _this = this;

      this.$http.post("/user/store/bot", {
        amount: this.amount,
        botTime: this.timing,
        bot_id: this.bot_id,
        currency: this.currency,
        symbol: this.symbol,
        type: this.type
      }).then(function (response) {
        _this.$toast[response.data.type](response.data.message);

        _this.fetchData();

        _this.fetchWallet();
      })["catch"](function (error) {})["finally"](function () {
        _this.loading = false;
      });
    },
    setBot: function setBot(bot) {
      this.$refs.selectBot.innerText = bot.title;
      this.bot_id = bot.id;
      var times = [];
      this.bot_timing.forEach(function (timing) {
        if (timing.bot_id === bot.id) {
          times.push(timing);
        }
      });
      this.bot_times = times;
      this.min_amount = bot.limits.min_bot_amount;
      this.max_amount = bot.limits.max_bot_amount;
      $("#botTypeModal").modal("hide");
    },
    setTiming: function setTiming(duration, type) {
      if (duration != 1) {
        this.$refs.botTimed.innerText = duration + " " + type + "s";
      } else {
        this.$refs.botTimed.innerText = duration + " " + type;
      }

      this.type = type;
      this.timing = duration;
    },
    fetchWallet: function fetchWallet() {
      var _this2 = this;

      this.$http.post("/user/fetch/wallet", {
        type: "trading",
        symbol: this.symbol
      }).then(function (response) {
        _this2.balance = response.data.balance;
      });
    },
    createWallet: function createWallet() {
      var _this3 = this;

      this.loading = true, this.$http.post("/user/wallet/j/create", {
        type: "funding",
        symbol: this.symbol
      }).then(function (response) {
        _this3.fetchWallet();

        _this3.$toast[response.data.type](response.data.message);
      })["catch"](function (error) {
        _this3.$toast.error(error.response.data);
      })["finally"](function () {
        _this3.loading = false;
      });
    },
    isActive: function isActive(menuItem) {
      return this.activeItem === menuItem;
    },
    setActive: function setActive(menuItem) {
      this.activeItem = menuItem;
    },
    fetchData: function fetchData() {
      var _this4 = this;

      this.$http.post("/user/fetch/bot/info", {
        symbol: this.$route.params.symbol,
        currency: this.$route.params.currency
      }).then(function (response) {
        _this4.user = response.data.user, _this4.provider = response.data.provider, _this4.bot_timing = response.data.bot_timing, _this4.bot_type = response.data.bot_type, _this4.runningBot = response.data.runningBot, _this4.provide = response.data.provide, _this4.pairs = response.data.pairs, _this4.gnl = response.data.gnl, _this4.limit = response.data.limit;
      });
    },
    goBack: function goBack() {
      window.history.length > 1 ? this.$router.go(-1) : this.$router.push("/");
    }
  },
  created: function created() {
    this.fetchData();
    this.fetchWallet();
  },
  mounted: function mounted() {
    var _this5 = this;

    /*const plugin = document.createElement("script");
    plugin.setAttribute(
        "src",
        "/vendors/js/ccxt.js"
    );
    plugin.async = true;
    document.head.appendChild(plugin);*/
    window.addEventListener("hashchange", function (e) {
      _this5.fetchData();
    });
    window.addEventListener("load", function (e) {
      _this5.fetchData();
    });
  },
  // on component destroyed
  destroyed: function destroyed() {}
});

/***/ }),

/***/ "./node_modules/babel-loader/lib/index.js??clonedRuleSet-5[0].rules[0].use[0]!./node_modules/vue-loader/lib/index.js??vue-loader-options!./resources/src/components/bot/Trades.vue?vue&type=script&lang=js&":
/*!******************************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/babel-loader/lib/index.js??clonedRuleSet-5[0].rules[0].use[0]!./node_modules/vue-loader/lib/index.js??vue-loader-options!./resources/src/components/bot/Trades.vue?vue&type=script&lang=js& ***!
  \******************************************************************************************************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var C_xampp_htdocs_node_modules_babel_runtime_helpers_esm_regeneratorRuntime_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./node_modules/@babel/runtime/helpers/esm/regeneratorRuntime.js */ "./node_modules/@babel/runtime/helpers/esm/regeneratorRuntime.js");
/* harmony import */ var C_xampp_htdocs_node_modules_babel_runtime_helpers_esm_asyncToGenerator_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js */ "./node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js");
/* harmony import */ var core_js_modules_es_regexp_exec_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! core-js/modules/es.regexp.exec.js */ "./node_modules/core-js/modules/es.regexp.exec.js");
/* harmony import */ var core_js_modules_es_regexp_exec_js__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es_regexp_exec_js__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var core_js_modules_es_string_split_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! core-js/modules/es.string.split.js */ "./node_modules/core-js/modules/es.string.split.js");
/* harmony import */ var core_js_modules_es_string_split_js__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es_string_split_js__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var core_js_modules_web_timers_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! core-js/modules/web.timers.js */ "./node_modules/core-js/modules/web.timers.js");
/* harmony import */ var core_js_modules_web_timers_js__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_web_timers_js__WEBPACK_IMPORTED_MODULE_4__);
/* harmony import */ var core_js_modules_es_array_fill_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! core-js/modules/es.array.fill.js */ "./node_modules/core-js/modules/es.array.fill.js");
/* harmony import */ var core_js_modules_es_array_fill_js__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es_array_fill_js__WEBPACK_IMPORTED_MODULE_5__);






//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
// component
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  props: ["symbol", "currency", "runningBot"],
  // component list
  components: {},
  // component data
  data: function data() {
    return {
      status: true
    };
  },
  computed: {},
  // custom methods
  methods: {
    updateTrades: function updateTrades(res) {
      var lastId = "";
      var color = "";
      var tabled = document.getElementById("tradeTable");

      for (var i = 0; i < res.length; i++) {
        if (res[i]["id"] > lastId) {
          if (res[i]["side"] == "sell") {
            color = "rgb(246,70,93)";
          } else {
            color = "rgb(14,203,129)";
          }

          var row = $("<tr>").append($("<td>").css("color", color).addClass("price").append($("<span>").text(res[i]["price"]))).append($("<td>").addClass("amount").append($("<span>").text(res[i]["amount"]))).append($('<td class="text-end">').addClass("time").append($("<span>").text(this.formatTime(res[i]["datetime"]))));
          $(".trade").prepend(row);
          lastId = res[i]["id"];
        }

        if (tabled.rows.length > 5) {
          tabled.deleteRow(tabled.rows.length - 1);
        }
      }
    },
    loopTrades: function loopTrades() {
      var _this = this;

      return (0,C_xampp_htdocs_node_modules_babel_runtime_helpers_esm_asyncToGenerator_js__WEBPACK_IMPORTED_MODULE_1__["default"])( /*#__PURE__*/(0,C_xampp_htdocs_node_modules_babel_runtime_helpers_esm_regeneratorRuntime_js__WEBPACK_IMPORTED_MODULE_0__["default"])().mark(function _callee() {
        var res;
        return (0,C_xampp_htdocs_node_modules_babel_runtime_helpers_esm_regeneratorRuntime_js__WEBPACK_IMPORTED_MODULE_0__["default"])().wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                if (!(_this.status == true)) {
                  _context.next = 17;
                  break;
                }

                if (!document.hidden) {
                  _context.next = 5;
                  break;
                }

                _context.next = 4;
                return ccxt.sleep(1000);

              case 4:
                return _context.abrupt("continue", 0);

              case 5:
                _context.prev = 5;
                _context.next = 8;
                return exchange.watchTrades(_this.symbol + "/" + _this.currency);

              case 8:
                res = _context.sent;

                _this.updateTrades(res);

                _context.next = 15;
                break;

              case 12:
                _context.prev = 12;
                _context.t0 = _context["catch"](5);
                return _context.abrupt("break", 17);

              case 15:
                _context.next = 0;
                break;

              case 17:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, null, [[5, 12]]);
      }))();
    },
    formatTime: function formatTime(time) {
      return time.split("T")[1].split(".")[0];
    }
  },
  // on component created
  created: function created() {
    var i = 0,
        delay = 5000,
        value = 0,
        valueStore = 0,
        tick = 1,
        tickStore = 1,
        tickDiff = 0,
        tickDiffValue = 0;

    function valBetween(v, min, max) {
      return Math.min(max, Math.max(min, v));
    }

    (function loop() {
      value = Math.ceil(Math.random() * 10);
      tick = valBetween(Math.ceil(value / 10 * 28), 1, 28);
      tickDiff = Math.abs(tick - tickStore);
      tickDiffValue = Math.abs(value - valueStore) / tickDiff;
      var counter = 0,
          valueStoreTemp = valueStore,
          tickStoreTemp = tickStore;

      if (value > valueStore) {
        for (i = tickStoreTemp; i <= tick; i++) {
          (function (i) {
            setTimeout(function () {
              $("#gauge").css("box-shadow", "0 0 32px rgba(21, 55, 172, 0.25), inset 0 -192px 192px -240px " + $("#gauge path:nth-child(" + i + ")")[0].style.fill + ", inset 0 0 2px -1px " + $("#gauge path:nth-child(" + i + ")")[0].style.fill);
              $("#gauge path:nth-child(" + i + ")").show();
              $("#gauge-label").css("color", $("#gauge path:nth-child(" + i + ")")[0].style.fill).text(Math.ceil(valueStoreTemp + tickDiffValue * Math.abs(tickStoreTemp - i)));

              if (i == tick) {
                $("#gauge-label").text(value);
              }
            }, 50 * counter);
            counter++;
          })(i);
        }
      } else if (value < valueStore) {
        for (i = tickStoreTemp; i >= tick; i--) {
          (function (i) {
            setTimeout(function () {
              $("#gauge").css("box-shadow", "0 0 32px rgba(21, 55, 172, 0.25), inset 0 -192px 192px -240px " + $("#gauge path:nth-child(" + i + ")")[0].style.fill + ", inset 0 0 2px -1px " + $("#gauge path:nth-child(" + i + ")")[0].style.fill);
              $("#gauge path:nth-child(" + i + ")").hide();
              $("#gauge-label").css("color", $("#gauge path:nth-child(" + i + ")")[0].style.fill).text(Math.floor(valueStoreTemp - tickDiffValue * Math.abs(tickStoreTemp - i)));

              if (i == tick) {
                $("#gauge-label").text(value);
              }
            }, 50 * counter);
            counter++;
          })(i);
        }
      }

      valueStore = value;
      tickStore = tick;
      window.setTimeout(loop, delay);
    })();
  },
  // on component mounted
  mounted: function mounted() {
    this.loopTrades();
  },
  // on component destroyed
  destroyed: function destroyed() {}
});

/***/ }),

/***/ "./node_modules/babel-loader/lib/index.js??clonedRuleSet-5[0].rules[0].use[0]!./node_modules/vue-loader/lib/index.js??vue-loader-options!./resources/src/components/trading/Marketinfo.vue?vue&type=script&lang=js&":
/*!**************************************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/babel-loader/lib/index.js??clonedRuleSet-5[0].rules[0].use[0]!./node_modules/vue-loader/lib/index.js??vue-loader-options!./resources/src/components/trading/Marketinfo.vue?vue&type=script&lang=js& ***!
  \**************************************************************************************************************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var C_xampp_htdocs_node_modules_babel_runtime_helpers_esm_regeneratorRuntime_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./node_modules/@babel/runtime/helpers/esm/regeneratorRuntime.js */ "./node_modules/@babel/runtime/helpers/esm/regeneratorRuntime.js");
/* harmony import */ var C_xampp_htdocs_node_modules_babel_runtime_helpers_esm_asyncToGenerator_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js */ "./node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js");


//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
// component
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  props: ['provider', 'symbol', 'currency'],
  // component list
  components: {},
  // component data
  data: function data() {
    return {
      last_price: '',
      day_change: '',
      status: true
    };
  },
  // custom methods
  methods: {
    updateTicker: function updateTicker(tick) {
      var _this = this;

      return (0,C_xampp_htdocs_node_modules_babel_runtime_helpers_esm_asyncToGenerator_js__WEBPACK_IMPORTED_MODULE_1__["default"])( /*#__PURE__*/(0,C_xampp_htdocs_node_modules_babel_runtime_helpers_esm_regeneratorRuntime_js__WEBPACK_IMPORTED_MODULE_0__["default"])().mark(function _callee() {
        var tickElement, tickIcon, percentageElement, percentageIcon, day_volume_currency, day_high, day_low, day_volume_pair;
        return (0,C_xampp_htdocs_node_modules_babel_runtime_helpers_esm_regeneratorRuntime_js__WEBPACK_IMPORTED_MODULE_0__["default"])().wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                _this.tickElements = $('.last_price');
                _this.tickIcons = $('.last_price-icon');
                tickElement = _this.tickElements;
                tickIcon = _this.tickIcons;

                if (!_this.last_price || tick['last'] > _this.last_price) {
                  tickElement.text(tick['last']);
                  tickElement.toggleClass('text-success');
                  tickIcon.toggleClass('bi-arrow-up text-success');
                } else if (tick['last'] < _this.last_price) {
                  tickElement.text(tick['last']);
                  tickElement.toggleClass('text-danger');
                  tickIcon.toggleClass('bi-arrow-down text-danger');
                }

                _this.last_price = tick['last'];

                if (_this.provide != 'coinbasepro') {
                  _this.percentageElements = $('.day_change');
                  _this.percentageIcons = $('.day_change-icon');
                  percentageElement = _this.percentageElements;
                  percentageIcon = _this.percentageIcons;

                  if (!_this.day_change || tick['percentage'] > _this.day_change) {
                    percentageElement.text(tick['percentage'] + '%');
                    percentageElement.toggleClass('text-success');
                    percentageIcon.toggleClass('bi-arrow-up text-success');
                  } else if (tick['percentage'] < _this.day_change) {
                    percentageElement.text(tick['percentage'] + '%');
                    percentageElement.toggleClass('text-danger');
                    percentageIcon.toggleClass('bi-arrow-down text-danger');
                  }

                  _this.day_change = tick['percentage'];
                  _this.day_volume_currencys = $('.day_volume_currency');
                  day_volume_currency = _this.day_volume_currencys;
                  day_volume_currency.text(new Intl.NumberFormat().format(tick['quoteVolume']));
                }

                _this.day_highs = $('.day_high');
                day_high = _this.day_highs;
                day_high.text(_this.formatPrice(tick['high']));
                _this.day_lows = $('.day_low');
                day_low = _this.day_lows;
                day_low.text(_this.formatPrice(tick['low']));
                _this.day_volume_pairs = $('.day_volume_pair');
                day_volume_pair = _this.day_volume_pairs;
                day_volume_pair.text(new Intl.NumberFormat().format(tick['baseVolume']));

              case 16:
              case "end":
                return _context.stop();
            }
          }
        }, _callee);
      }))();
    },
    loopTicker: function loopTicker() {
      var _this2 = this;

      return (0,C_xampp_htdocs_node_modules_babel_runtime_helpers_esm_asyncToGenerator_js__WEBPACK_IMPORTED_MODULE_1__["default"])( /*#__PURE__*/(0,C_xampp_htdocs_node_modules_babel_runtime_helpers_esm_regeneratorRuntime_js__WEBPACK_IMPORTED_MODULE_0__["default"])().mark(function _callee2() {
        var ticker;
        return (0,C_xampp_htdocs_node_modules_babel_runtime_helpers_esm_regeneratorRuntime_js__WEBPACK_IMPORTED_MODULE_0__["default"])().wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                if (!(_this2.status == true)) {
                  _context2.next = 17;
                  break;
                }

                if (!document.hidden) {
                  _context2.next = 5;
                  break;
                }

                _context2.next = 4;
                return ccxt.sleep(1000);

              case 4:
                return _context2.abrupt("continue", 0);

              case 5:
                _context2.prev = 5;
                _context2.next = 8;
                return exchange.watchTicker(_this2.symbol + '/' + _this2.currency);

              case 8:
                ticker = _context2.sent;

                _this2.updateTicker(ticker);

                _context2.next = 15;
                break;

              case 12:
                _context2.prev = 12;
                _context2.t0 = _context2["catch"](5);
                return _context2.abrupt("break", 17);

              case 15:
                _context2.next = 0;
                break;

              case 17:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee2, null, [[5, 12]]);
      }))();
    },
    formatPrice: function formatPrice(price) {
      return ccxt.decimalToPrecision(price, ccxt.ROUND, 9, ccxt.SIGNIFICANT_DIGITS, ccxt.PAD_WITH_ZERO);
    },
    wsClose: function wsClose() {
      var _this3 = this;

      return (0,C_xampp_htdocs_node_modules_babel_runtime_helpers_esm_asyncToGenerator_js__WEBPACK_IMPORTED_MODULE_1__["default"])( /*#__PURE__*/(0,C_xampp_htdocs_node_modules_babel_runtime_helpers_esm_regeneratorRuntime_js__WEBPACK_IMPORTED_MODULE_0__["default"])().mark(function _callee3() {
        return (0,C_xampp_htdocs_node_modules_babel_runtime_helpers_esm_regeneratorRuntime_js__WEBPACK_IMPORTED_MODULE_0__["default"])().wrap(function _callee3$(_context3) {
          while (1) {
            switch (_context3.prev = _context3.next) {
              case 0:
                _this3.status = false;
                _context3.next = 3;
                return exchange.close();

              case 3:
              case "end":
                return _context3.stop();
            }
          }
        }, _callee3);
      }))();
    }
  },
  // on component created
  created: function created() {},
  // on component mounted
  mounted: function mounted() {
    this.loopTicker();
  },
  // on component destroyed
  destroyed: function destroyed() {}
});

/***/ }),

/***/ "./node_modules/babel-loader/lib/index.js??clonedRuleSet-5[0].rules[0].use[0]!./node_modules/vue-loader/lib/index.js??vue-loader-options!./resources/src/components/trading/Markets.vue?vue&type=script&lang=js&":
/*!***********************************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/babel-loader/lib/index.js??clonedRuleSet-5[0].rules[0].use[0]!./node_modules/vue-loader/lib/index.js??vue-loader-options!./resources/src/components/trading/Markets.vue?vue&type=script&lang=js& ***!
  \***********************************************************************************************************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var C_xampp_htdocs_node_modules_babel_runtime_helpers_esm_regeneratorRuntime_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./node_modules/@babel/runtime/helpers/esm/regeneratorRuntime.js */ "./node_modules/@babel/runtime/helpers/esm/regeneratorRuntime.js");
/* harmony import */ var C_xampp_htdocs_node_modules_babel_runtime_helpers_esm_asyncToGenerator_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js */ "./node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js");
/* harmony import */ var C_xampp_htdocs_node_modules_babel_runtime_helpers_esm_slicedToArray_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./node_modules/@babel/runtime/helpers/esm/slicedToArray.js */ "./node_modules/@babel/runtime/helpers/esm/slicedToArray.js");
/* harmony import */ var core_js_modules_es_object_entries_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! core-js/modules/es.object.entries.js */ "./node_modules/core-js/modules/es.object.entries.js");
/* harmony import */ var core_js_modules_es_object_entries_js__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es_object_entries_js__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var core_js_modules_es_regexp_exec_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! core-js/modules/es.regexp.exec.js */ "./node_modules/core-js/modules/es.regexp.exec.js");
/* harmony import */ var core_js_modules_es_regexp_exec_js__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es_regexp_exec_js__WEBPACK_IMPORTED_MODULE_4__);
/* harmony import */ var core_js_modules_es_string_replace_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! core-js/modules/es.string.replace.js */ "./node_modules/core-js/modules/es.string.replace.js");
/* harmony import */ var core_js_modules_es_string_replace_js__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es_string_replace_js__WEBPACK_IMPORTED_MODULE_5__);
/* harmony import */ var core_js_modules_es_array_for_each_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! core-js/modules/es.array.for-each.js */ "./node_modules/core-js/modules/es.array.for-each.js");
/* harmony import */ var core_js_modules_es_array_for_each_js__WEBPACK_IMPORTED_MODULE_6___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es_array_for_each_js__WEBPACK_IMPORTED_MODULE_6__);
/* harmony import */ var core_js_modules_es_object_to_string_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! core-js/modules/es.object.to-string.js */ "./node_modules/core-js/modules/es.object.to-string.js");
/* harmony import */ var core_js_modules_es_object_to_string_js__WEBPACK_IMPORTED_MODULE_7___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es_object_to_string_js__WEBPACK_IMPORTED_MODULE_7__);
/* harmony import */ var core_js_modules_web_dom_collections_for_each_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! core-js/modules/web.dom-collections.for-each.js */ "./node_modules/core-js/modules/web.dom-collections.for-each.js");
/* harmony import */ var core_js_modules_web_dom_collections_for_each_js__WEBPACK_IMPORTED_MODULE_8___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_web_dom_collections_for_each_js__WEBPACK_IMPORTED_MODULE_8__);
/* harmony import */ var core_js_modules_es_array_sort_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! core-js/modules/es.array.sort.js */ "./node_modules/core-js/modules/es.array.sort.js");
/* harmony import */ var core_js_modules_es_array_sort_js__WEBPACK_IMPORTED_MODULE_9___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es_array_sort_js__WEBPACK_IMPORTED_MODULE_9__);
/* harmony import */ var core_js_modules_es_array_filter_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! core-js/modules/es.array.filter.js */ "./node_modules/core-js/modules/es.array.filter.js");
/* harmony import */ var core_js_modules_es_array_filter_js__WEBPACK_IMPORTED_MODULE_10___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es_array_filter_js__WEBPACK_IMPORTED_MODULE_10__);
/* harmony import */ var core_js_modules_es_array_index_of_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! core-js/modules/es.array.index-of.js */ "./node_modules/core-js/modules/es.array.index-of.js");
/* harmony import */ var core_js_modules_es_array_index_of_js__WEBPACK_IMPORTED_MODULE_11___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es_array_index_of_js__WEBPACK_IMPORTED_MODULE_11__);
/* harmony import */ var core_js_modules_es_string_trim_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! core-js/modules/es.string.trim.js */ "./node_modules/core-js/modules/es.string.trim.js");
/* harmony import */ var core_js_modules_es_string_trim_js__WEBPACK_IMPORTED_MODULE_12___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es_string_trim_js__WEBPACK_IMPORTED_MODULE_12__);













//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
// component
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  props: ["pairs", "provider"],
  // component list
  components: {},
  // component data
  data: function data() {
    return {
      favs: [],
      old: [],
      markets: [],
      activeItem: "fav",
      status: true
    };
  },
  computed: {},
  // custom methods
  methods: {
    fetchMarkets: function fetchMarkets() {
      var _this = this;

      this.$http.post("/data/markets/markets.json").then(function (response) {
        _this.markets = response.data[_this.provider];
      });
    },
    fetchFavs: function fetchFavs() {
      var _this2 = this;

      this.$http.post("/user/watchlist/data").then(function (response) {
        _this2.favs = response.data.favs;
      });
    },
    isActive: function isActive(menuItem) {
      return this.activeItem === menuItem;
    },
    setActive: function setActive(menuItem) {
      this.activeItem = menuItem;
    },
    scrollLeft: function scrollLeft() {
      var leftPos = $(".nf").scrollLeft();
      $(".nf").animate({
        scrollLeft: leftPos - 200
      }, 800);
    },
    scrollRight: function scrollRight() {
      var leftPos = $(".nf").scrollLeft();
      $(".nf").animate({
        scrollLeft: leftPos + 200
      }, 800);
    },
    addToWatchlist: function addToWatchlist(currency, pair) {
      var _this3 = this;

      this.$http.post("/user/watchlist/store", {
        currency: currency,
        pair: pair
      }).then(function (response) {
        _this3.$toast[response.data.type](response.data.message);
      })["catch"](function (error) {
        _this3.$toast.error(error.response.data);
      });
    },
    removeFromWatchlist: function removeFromWatchlist(id) {
      var _this4 = this;

      this.$http.post("/user/watchlist/delete", {
        id: id
      }).then(function (response) {
        _this4.$toast.success(response.data.message);

        _this4.fetchFavs();
      })["catch"](function (error) {
        _this4.$toast.error("Market Already Removed From Watchlist");
      });
    },
    handle: function handle(tickers) {
      this.tickerElements = this.tickerElements || {};
      this.tickerIcons = this.tickerIcons || {};
      this.changeElements = this.changeElements || {};

      for (var _i = 0, _Object$entries = Object.entries(tickers); _i < _Object$entries.length; _i++) {
        var _Object$entries$_i = (0,C_xampp_htdocs_node_modules_babel_runtime_helpers_esm_slicedToArray_js__WEBPACK_IMPORTED_MODULE_2__["default"])(_Object$entries[_i], 2),
            symbol = _Object$entries$_i[0],
            ticker = _Object$entries$_i[1];

        var symbolWithoutSlash = symbol.replace("/", "");

        if (!(symbol in this.tickerElements)) {
          this.tickerElements[symbol] = $(".tic-" + symbolWithoutSlash);
        }

        if (!(symbol in this.tickerIcons)) {
          this.tickerIcons[symbol] = $(".tic-" + symbolWithoutSlash + "-icon");
        }

        var tickerElement = this.tickerElements[symbol];
        var tickerIcon = this.tickerIcons[symbol];

        if (!this.old[symbol] || ticker["last"] > this.old[symbol]) {
          tickerElement.text(ticker["last"]);
          tickerElement.toggleClass("text-success");
          tickerIcon.toggleClass("bi-arrow-up text-success");
        } else if (ticker["last"] < this.old[symbol]) {
          tickerElement.text(ticker["last"]);
          tickerElement.toggleClass("text-danger");
          tickerIcon.toggleClass("bi-arrow-down text-danger");
        }

        this.old[symbol] = ticker["last"];

        if (!(symbol in this.changeElements)) {
          this.changeElements[symbol] = $(".change-" + symbolWithoutSlash);
        }

        var changeElement = this.changeElements[symbol];

        if (ticker["change"] > 0) {
          changeElement.text(this.formatTotal(ticker["change"]) + "%");
          changeElement.addClass("text-success").removeClass("text-danger");
        } else if (ticker["change"] < 0) {
          changeElement.text(this.formatTotal(ticker["change"]) + "%");
          changeElement.addClass("text-danger").removeClass("text-success");
        } else {
          changeElement.text(this.formatTotal(ticker["change"]) + "%");
        }
      }
    },
    loop: function loop() {
      var _this5 = this;

      return (0,C_xampp_htdocs_node_modules_babel_runtime_helpers_esm_asyncToGenerator_js__WEBPACK_IMPORTED_MODULE_1__["default"])( /*#__PURE__*/(0,C_xampp_htdocs_node_modules_babel_runtime_helpers_esm_regeneratorRuntime_js__WEBPACK_IMPORTED_MODULE_0__["default"])().mark(function _callee() {
        var tickers;
        return (0,C_xampp_htdocs_node_modules_babel_runtime_helpers_esm_regeneratorRuntime_js__WEBPACK_IMPORTED_MODULE_0__["default"])().wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                if (!(_this5.status == true)) {
                  _context.next = 17;
                  break;
                }

                if (!document.hidden) {
                  _context.next = 5;
                  break;
                }

                _context.next = 4;
                return ccxt.sleep(1000);

              case 4:
                return _context.abrupt("continue", 0);

              case 5:
                _context.prev = 5;
                _context.next = 8;
                return exchange.fetchTickers();

              case 8:
                tickers = _context.sent;

                _this5.handle(tickers);

                _context.next = 15;
                break;

              case 12:
                _context.prev = 12;
                _context.t0 = _context["catch"](5);
                return _context.abrupt("break", 17);

              case 15:
                _context.next = 0;
                break;

              case 17:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, null, [[5, 12]]);
      }))();
    },
    formatTotal: function formatTotal(total) {
      return ccxt.decimalToPrecision(total, ccxt.ROUND, 3, ccxt.DECIMAL_PLACES, ccxt.PAD_WITH_ZERO);
    },
    wsClose: function wsClose() {
      var _this6 = this;

      return (0,C_xampp_htdocs_node_modules_babel_runtime_helpers_esm_asyncToGenerator_js__WEBPACK_IMPORTED_MODULE_1__["default"])( /*#__PURE__*/(0,C_xampp_htdocs_node_modules_babel_runtime_helpers_esm_regeneratorRuntime_js__WEBPACK_IMPORTED_MODULE_0__["default"])().mark(function _callee2() {
        return (0,C_xampp_htdocs_node_modules_babel_runtime_helpers_esm_regeneratorRuntime_js__WEBPACK_IMPORTED_MODULE_0__["default"])().wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                _this6.status = false;
                _context2.next = 3;
                return exchange.close();

              case 3:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee2);
      }))();
    }
  },
  // on component created
  created: function created() {
    this.fetchFavs();
    this.fetchMarkets();
  },
  // on component mounted
  mounted: function mounted() {
    this.loop();
  },
  // on component mounted
  beforeUpdate: function beforeUpdate() {
    this.pairs.forEach(function (pair) {
      var tr_elements = $(".custom-data-table-" + pair + " tbody tr");
      $(document).on("input", "input[name=search_table]", function () {
        var search = $(this).val().toUpperCase();
        var match = tr_elements.filter(function (idx, elem) {
          return $(elem).text().trim().toUpperCase().indexOf(search) >= 0 ? elem : null;
        }).sort();
        var table_content = $(".custom-data-table-" + pair + " tbody");

        if (match.length == 0) {
          table_content.html('<tr><td colspan="100%" class="text-center">Data Not Found</td></tr>');
        } else {
          table_content.html(match);
        }
      });
    });
    var tr_elements = $(".custom-data-table-fav tbody tr");
    $(document).on("input", "input[name=search_table_fav]", function () {
      var search = $(this).val().toUpperCase();
      var match = tr_elements.filter(function (idx, elem) {
        return $(elem).text().trim().toUpperCase().indexOf(search) >= 0 ? elem : null;
      }).sort();
      var table_content = $(".custom-data-table-fav tbody");

      if (match.length == 0) {
        table_content.html('<tr><td colspan="100%" class="text-center">Data Not Found</td></tr>');
      } else {
        table_content.html(match);
      }
    });
  },
  unmounted: function unmounted() {
    this.wsClose();
  },
  // on component destroyed
  destroyed: function destroyed() {
    this.wsClose();
  }
});

/***/ }),

/***/ "./node_modules/babel-loader/lib/index.js??clonedRuleSet-5[0].rules[0].use[0]!./node_modules/vue-loader/lib/index.js??vue-loader-options!./resources/src/components/trading/Orderbook.vue?vue&type=script&lang=js&":
/*!*************************************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/babel-loader/lib/index.js??clonedRuleSet-5[0].rules[0].use[0]!./node_modules/vue-loader/lib/index.js??vue-loader-options!./resources/src/components/trading/Orderbook.vue?vue&type=script&lang=js& ***!
  \*************************************************************************************************************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var C_xampp_htdocs_node_modules_babel_runtime_helpers_esm_regeneratorRuntime_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./node_modules/@babel/runtime/helpers/esm/regeneratorRuntime.js */ "./node_modules/@babel/runtime/helpers/esm/regeneratorRuntime.js");
/* harmony import */ var C_xampp_htdocs_node_modules_babel_runtime_helpers_esm_asyncToGenerator_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js */ "./node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js");
/* harmony import */ var core_js_modules_es_array_sort_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! core-js/modules/es.array.sort.js */ "./node_modules/core-js/modules/es.array.sort.js");
/* harmony import */ var core_js_modules_es_array_sort_js__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es_array_sort_js__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var core_js_modules_es_array_concat_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! core-js/modules/es.array.concat.js */ "./node_modules/core-js/modules/es.array.concat.js");
/* harmony import */ var core_js_modules_es_array_concat_js__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es_array_concat_js__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var core_js_modules_es_number_constructor_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! core-js/modules/es.number.constructor.js */ "./node_modules/core-js/modules/es.number.constructor.js");
/* harmony import */ var core_js_modules_es_number_constructor_js__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es_number_constructor_js__WEBPACK_IMPORTED_MODULE_4__);
/* harmony import */ var core_js_modules_es_array_for_each_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! core-js/modules/es.array.for-each.js */ "./node_modules/core-js/modules/es.array.for-each.js");
/* harmony import */ var core_js_modules_es_array_for_each_js__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es_array_for_each_js__WEBPACK_IMPORTED_MODULE_5__);
/* harmony import */ var core_js_modules_es_object_to_string_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! core-js/modules/es.object.to-string.js */ "./node_modules/core-js/modules/es.object.to-string.js");
/* harmony import */ var core_js_modules_es_object_to_string_js__WEBPACK_IMPORTED_MODULE_6___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es_object_to_string_js__WEBPACK_IMPORTED_MODULE_6__);
/* harmony import */ var core_js_modules_web_dom_collections_for_each_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! core-js/modules/web.dom-collections.for-each.js */ "./node_modules/core-js/modules/web.dom-collections.for-each.js");
/* harmony import */ var core_js_modules_web_dom_collections_for_each_js__WEBPACK_IMPORTED_MODULE_7___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_web_dom_collections_for_each_js__WEBPACK_IMPORTED_MODULE_7__);
/* harmony import */ var core_js_modules_es_regexp_exec_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! core-js/modules/es.regexp.exec.js */ "./node_modules/core-js/modules/es.regexp.exec.js");
/* harmony import */ var core_js_modules_es_regexp_exec_js__WEBPACK_IMPORTED_MODULE_8___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es_regexp_exec_js__WEBPACK_IMPORTED_MODULE_8__);
/* harmony import */ var core_js_modules_es_string_replace_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! core-js/modules/es.string.replace.js */ "./node_modules/core-js/modules/es.string.replace.js");
/* harmony import */ var core_js_modules_es_string_replace_js__WEBPACK_IMPORTED_MODULE_9___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es_string_replace_js__WEBPACK_IMPORTED_MODULE_9__);
/* harmony import */ var core_js_modules_es_number_to_fixed_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! core-js/modules/es.number.to-fixed.js */ "./node_modules/core-js/modules/es.number.to-fixed.js");
/* harmony import */ var core_js_modules_es_number_to_fixed_js__WEBPACK_IMPORTED_MODULE_10___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es_number_to_fixed_js__WEBPACK_IMPORTED_MODULE_10__);
/* harmony import */ var core_js_modules_es_string_split_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! core-js/modules/es.string.split.js */ "./node_modules/core-js/modules/es.string.split.js");
/* harmony import */ var core_js_modules_es_string_split_js__WEBPACK_IMPORTED_MODULE_11___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es_string_split_js__WEBPACK_IMPORTED_MODULE_11__);
/* harmony import */ var core_js_modules_es_array_join_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! core-js/modules/es.array.join.js */ "./node_modules/core-js/modules/es.array.join.js");
/* harmony import */ var core_js_modules_es_array_join_js__WEBPACK_IMPORTED_MODULE_12___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es_array_join_js__WEBPACK_IMPORTED_MODULE_12__);
/* harmony import */ var core_js_modules_es_date_now_js__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! core-js/modules/es.date.now.js */ "./node_modules/core-js/modules/es.date.now.js");
/* harmony import */ var core_js_modules_es_date_now_js__WEBPACK_IMPORTED_MODULE_13___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es_date_now_js__WEBPACK_IMPORTED_MODULE_13__);
/* harmony import */ var core_js_modules_es_date_to_string_js__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! core-js/modules/es.date.to-string.js */ "./node_modules/core-js/modules/es.date.to-string.js");
/* harmony import */ var core_js_modules_es_date_to_string_js__WEBPACK_IMPORTED_MODULE_14___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es_date_to_string_js__WEBPACK_IMPORTED_MODULE_14__);
/* harmony import */ var core_js_modules_es_parse_int_js__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! core-js/modules/es.parse-int.js */ "./node_modules/core-js/modules/es.parse-int.js");
/* harmony import */ var core_js_modules_es_parse_int_js__WEBPACK_IMPORTED_MODULE_15___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es_parse_int_js__WEBPACK_IMPORTED_MODULE_15__);
















//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
// component
var computBarWidth = {
  width: 250,
  sortDepth: {
    sort: function sort(e) {
      return e.sort(function (e, t) {
        return e[1] - t[1];
      }), e;
    },
    median: function median(e) {
      var t = Math.floor(e.length / 3 * 2);
      return e[t][1] < 1 ? 1 : e[t][1];
    },
    medianUnit: function medianUnit(e, t, n) {
      var r = new Array(e);
      r = r[0];
      var o = new Array(t);
      o = o[0], r = r.concat(o);
      var i = this.median(this.sort(r)) / n;
      return o = r = null, i;
    },
    width: function width(e, t) {
      if (0 == t) return 1;
      var n = Math.round(Number(e) / t);
      return n <= 0 ? 1 : 160 < n ? 160 : n;
    }
  },
  init: function init(e, t) {
    var n = [],
        r = [];
    e.forEach(function (e) {
      n.push(e);
    }), t.forEach(function (e) {
      r.push(e);
    });
    var o = this.sortDepth.medianUnit(n, r, 48);
    e.forEach(function (e) {
      e.push({
        width: computBarWidth.sortDepth.width(e[1], o) * computBarWidth.width / 100
      });
    }), t.forEach(function (e) {
      e.push({
        width: computBarWidth.sortDepth.width(e[1], o) * computBarWidth.width / 100
      });
    });
  }
};

function number_format(number, decimals, decPoint, thousandsSep) {
  number = (number + "").replace(/[^0-9+\-Ee.]/g, "");
  var n = !isFinite(+number) ? 0 : +number;
  var prec = !isFinite(+decimals) ? 0 : Math.abs(decimals);
  var sep = typeof thousandsSep === "undefined" ? "," : thousandsSep;
  var dec = typeof decPoint === "undefined" ? "." : decPoint;
  var s = "";

  var toFixedFix = function toFixedFix(n, prec) {
    var k = Math.pow(10, prec);
    return "" + (Math.round(n * k) / k).toFixed(prec);
  }; // @todo: for IE parseFloat(0.55).toFixed(0) = 0;


  s = (prec ? toFixedFix(n, prec) : "" + Math.round(n)).split(".");

  if (s[0].length > 3) {
    s[0] = s[0].replace(/\B(?=(?:\d{3})+(?!\d))/g, sep);
  }

  if ((s[1] || "").length < prec) {
    s[1] = s[1] || "";
    s[1] += new Array(prec - s[1].length + 1).join("0");
  }

  return s.join(dec);
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  props: ["symbol", "currency"],
  // component list
  components: {},
  // component data
  data: function data() {
    return {
      sideLength: 20,
      refreshRate: 500,
      bestAsker: "",
      lastUpdated: "",
      activeItem: "pills-graph",
      status: true,
      data: {}
    };
  },
  // custom methods
  methods: {
    isActive: function isActive(menuItem) {
      return this.activeItem === menuItem;
    },
    setActive: function setActive(menuItem) {
      this.activeItem = menuItem;
    },
    updateOrderbook: function updateOrderbook(data) {
      var _this = this;

      return (0,C_xampp_htdocs_node_modules_babel_runtime_helpers_esm_asyncToGenerator_js__WEBPACK_IMPORTED_MODULE_1__["default"])( /*#__PURE__*/(0,C_xampp_htdocs_node_modules_babel_runtime_helpers_esm_regeneratorRuntime_js__WEBPACK_IMPORTED_MODULE_0__["default"])().mark(function _callee() {
        var now, best_ask, best_ask_Icon, bestAsk, bestBid;
        return (0,C_xampp_htdocs_node_modules_babel_runtime_helpers_esm_regeneratorRuntime_js__WEBPACK_IMPORTED_MODULE_0__["default"])().wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                now = Date.now();

                if (!(!_this.lastUpdated || now - _this.lastUpdated > _this.refreshRate)) {
                  _context.next = 21;
                  break;
                }

                computBarWidth.init(data.bids, data.asks);
                $(".asks,.bids,.asks_only,.bids_only").empty();
                $.each(data.asks, function (index, item) {
                  var row = $("<tr>").append($('<td class="tdd">').css("color", "rgb(246,70,93)").addClass("price").append($("<span>").text(item[0]))).append($('<td class="tdd">').addClass("quantity").append($("<span>").text(item[1]))).append($('<td class="tdd">').addClass("btc").append($("<span>").text(number_format(item[0] * item[1], 2, ","))).append($("<div>").addClass("percent").css("width", item[2].width + "px")));
                  if (index > 16) row.hide();
                  $(".asks").prepend(row);
                  var rowy = $("<tr>").append($('<td class="tdd">').css("color", "rgb(246,70,93)").addClass("price").append($("<span>").text(item[0]))).append($('<td class="tdd">').addClass("quantity").append($("<span>").text(item[1].toFixed(2)))).append($('<td class="tdd">').addClass("btc").append($("<span>").text(number_format(item[0] * item[1], 2, ","))).append($("<div>").addClass("percent").css("width", item[2].width + "px")));
                  if (index > 20) rowy.hide();
                  $(".asks_only").prepend(rowy);
                });
                $.each(data.bids, function (index, item) {
                  var row = $("<tr>").append($('<td class="tdd">').css("color", "rgb(14,203,129)").addClass("price").append($("<span>").text(item[0]))).append($('<td class="tdd">').addClass("quantity").append($("<span>").text(item[1]))).append($('<td class="tdd">').addClass("btc").append($("<span>").text(number_format(item[0] * item[1], 2, ","))).append($("<div>").addClass("percent").css("width", item[2].width + "px")));
                  if (index > 16) row.hide();
                  $(".bids").prepend(row);
                  var rowy = $("<tr>").append($('<td class="tdd">').css("color", "rgb(14,203,129)").addClass("price").append($("<span>").text(item[0]))).append($('<td class="tdd">').addClass("quantity").append($("<span>").text(item[1]))).append($('<td class="tdd">').addClass("btc").append($("<span>").text(number_format(item[0] * item[1], 2, ","))).append($("<div>").addClass("percent").css("width", item[2].width + "px")));
                  if (index > 20) rowy.hide();
                  $(".bids_only").prepend(rowy);
                });
                _this.best_asks = $(".best_ask");
                _this.best_ask_Icons = $(".best_ask_icon");
                best_ask = _this.best_asks;
                best_ask_Icon = _this.best_ask_Icons;

                if (!_this.bestAsker || data.asks[0][0] > _this.bestAsker) {
                  best_ask.text(data.asks[0][0]);
                  best_ask.toggleClass("text-success");
                  best_ask_Icon.addClass("bi-arrow-up text-success").removeClass("bi-arrow-down text-danger");
                } else if (data.asks[0][0] < _this.bestAsker) {
                  best_ask.text(data.asks[0][0]);
                  best_ask.toggleClass("text-danger");
                  best_ask_Icon.addClass("bi-arrow-down text-danger").removeClass("bi-arrow-up text-success");
                }

                _this.bestAsker = data.asks[0][0];
                _this.bestAskText = $("#bestAsk");
                bestAsk = _this.bestAskText;
                bestAsk.val(data.asks[0][0]);
                _this.bestBidText = $("#bestBid");
                bestBid = _this.bestBidText;
                bestBid.val(data.bids[0][0]);
                _this.lastUpdated = now;
                _context.next = 23;
                break;

              case 21:
                _context.next = 23;
                return ccxt.sleep(parseInt(_this.refreshRate / 2));

              case 23:
              case "end":
                return _context.stop();
            }
          }
        }, _callee);
      }))();
    },
    loopOrderbook: function loopOrderbook() {
      var _this2 = this;

      return (0,C_xampp_htdocs_node_modules_babel_runtime_helpers_esm_asyncToGenerator_js__WEBPACK_IMPORTED_MODULE_1__["default"])( /*#__PURE__*/(0,C_xampp_htdocs_node_modules_babel_runtime_helpers_esm_regeneratorRuntime_js__WEBPACK_IMPORTED_MODULE_0__["default"])().mark(function _callee2() {
        var data;
        return (0,C_xampp_htdocs_node_modules_babel_runtime_helpers_esm_regeneratorRuntime_js__WEBPACK_IMPORTED_MODULE_0__["default"])().wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                if (!(_this2.status == true)) {
                  _context2.next = 17;
                  break;
                }

                if (!document.hidden) {
                  _context2.next = 5;
                  break;
                }

                _context2.next = 4;
                return ccxt.sleep(1000);

              case 4:
                return _context2.abrupt("continue", 0);

              case 5:
                _context2.prev = 5;
                _context2.next = 8;
                return exchange.watchOrderBook(_this2.symbol + "/" + _this2.currency, _this2.sideLength);

              case 8:
                data = _context2.sent;

                _this2.updateOrderbook(data);

                _context2.next = 15;
                break;

              case 12:
                _context2.prev = 12;
                _context2.t0 = _context2["catch"](5);
                return _context2.abrupt("break", 17);

              case 15:
                _context2.next = 0;
                break;

              case 17:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee2, null, [[5, 12]]);
      }))();
    }
  },
  // on component created
  created: function created() {
    this.loopOrderbook();
  },
  // on component mounted
  mounted: function mounted() {}
});

/***/ }),

/***/ "./node_modules/babel-loader/lib/index.js??clonedRuleSet-5[0].rules[0].use[0]!./node_modules/vue-loader/lib/index.js??vue-loader-options!./resources/src/components/trading/Tradingview.vue?vue&type=script&lang=js&":
/*!***************************************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/babel-loader/lib/index.js??clonedRuleSet-5[0].rules[0].use[0]!./node_modules/vue-loader/lib/index.js??vue-loader-options!./resources/src/components/trading/Tradingview.vue?vue&type=script&lang=js& ***!
  \***************************************************************************************************************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
//
//
//
//
//
//
// component
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  props: ["provide", "symbol", "currency"],
  // component list
  components: {},
  // component data
  data: function data() {
    return {};
  },
  // custom methods
  methods: {},
  // on component created
  created: function created() {},
  // on component mounted
  mounted: function mounted() {
    new TradingView.widget({
      width: "100%",
      height: "100%",
      symbol: this.provide + ":" + this.symbol + this.currency,
      interval: "H",
      timezone: "Etc/UTC",
      theme: "dark",
      style: "1",
      locale: "en",
      toolbar_bg: "#f1f3f6",
      enable_publishing: false,
      hide_legend: true,
      save_image: false,
      container_id: "tradingview"
    });
  },
  // on component destroyed
  destroyed: function destroyed() {}
});

/***/ }),

/***/ "./node_modules/core-js/internals/object-to-array.js":
/*!***********************************************************!*\
  !*** ./node_modules/core-js/internals/object-to-array.js ***!
  \***********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var DESCRIPTORS = __webpack_require__(/*! ../internals/descriptors */ "./node_modules/core-js/internals/descriptors.js");
var uncurryThis = __webpack_require__(/*! ../internals/function-uncurry-this */ "./node_modules/core-js/internals/function-uncurry-this.js");
var objectKeys = __webpack_require__(/*! ../internals/object-keys */ "./node_modules/core-js/internals/object-keys.js");
var toIndexedObject = __webpack_require__(/*! ../internals/to-indexed-object */ "./node_modules/core-js/internals/to-indexed-object.js");
var $propertyIsEnumerable = (__webpack_require__(/*! ../internals/object-property-is-enumerable */ "./node_modules/core-js/internals/object-property-is-enumerable.js").f);

var propertyIsEnumerable = uncurryThis($propertyIsEnumerable);
var push = uncurryThis([].push);

// `Object.{ entries, values }` methods implementation
var createMethod = function (TO_ENTRIES) {
  return function (it) {
    var O = toIndexedObject(it);
    var keys = objectKeys(O);
    var length = keys.length;
    var i = 0;
    var result = [];
    var key;
    while (length > i) {
      key = keys[i++];
      if (!DESCRIPTORS || propertyIsEnumerable(O, key)) {
        push(result, TO_ENTRIES ? [key, O[key]] : O[key]);
      }
    }
    return result;
  };
};

module.exports = {
  // `Object.entries` method
  // https://tc39.es/ecma262/#sec-object.entries
  entries: createMethod(true),
  // `Object.values` method
  // https://tc39.es/ecma262/#sec-object.values
  values: createMethod(false)
};


/***/ }),

/***/ "./node_modules/core-js/modules/es.object.entries.js":
/*!***********************************************************!*\
  !*** ./node_modules/core-js/modules/es.object.entries.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

var $ = __webpack_require__(/*! ../internals/export */ "./node_modules/core-js/internals/export.js");
var $entries = (__webpack_require__(/*! ../internals/object-to-array */ "./node_modules/core-js/internals/object-to-array.js").entries);

// `Object.entries` method
// https://tc39.es/ecma262/#sec-object.entries
$({ target: 'Object', stat: true }, {
  entries: function entries(O) {
    return $entries(O);
  }
});


/***/ }),

/***/ "./node_modules/laravel-mix/node_modules/css-loader/dist/cjs.js??clonedRuleSet-69[0].rules[0].use[1]!./node_modules/vue-loader/lib/loaders/stylePostLoader.js!./node_modules/laravel-mix/node_modules/postcss-loader/dist/cjs.js??clonedRuleSet-69[0].rules[0].use[2]!./node_modules/vue-loader/lib/index.js??vue-loader-options!./resources/src/components/trading/Markets.vue?vue&type=style&index=0&lang=css&":
/*!***********************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/laravel-mix/node_modules/css-loader/dist/cjs.js??clonedRuleSet-69[0].rules[0].use[1]!./node_modules/vue-loader/lib/loaders/stylePostLoader.js!./node_modules/laravel-mix/node_modules/postcss-loader/dist/cjs.js??clonedRuleSet-69[0].rules[0].use[2]!./node_modules/vue-loader/lib/index.js??vue-loader-options!./resources/src/components/trading/Markets.vue?vue&type=style&index=0&lang=css& ***!
  \***********************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _node_modules_laravel_mix_node_modules_css_loader_dist_runtime_cssWithMappingToString_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../../node_modules/laravel-mix/node_modules/css-loader/dist/runtime/cssWithMappingToString.js */ "./node_modules/laravel-mix/node_modules/css-loader/dist/runtime/cssWithMappingToString.js");
/* harmony import */ var _node_modules_laravel_mix_node_modules_css_loader_dist_runtime_cssWithMappingToString_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_laravel_mix_node_modules_css_loader_dist_runtime_cssWithMappingToString_js__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _node_modules_laravel_mix_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../../node_modules/laravel-mix/node_modules/css-loader/dist/runtime/api.js */ "./node_modules/laravel-mix/node_modules/css-loader/dist/runtime/api.js");
/* harmony import */ var _node_modules_laravel_mix_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_node_modules_laravel_mix_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__);
// Imports


var ___CSS_LOADER_EXPORT___ = _node_modules_laravel_mix_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default()((_node_modules_laravel_mix_node_modules_css_loader_dist_runtime_cssWithMappingToString_js__WEBPACK_IMPORTED_MODULE_0___default()));
// Module
___CSS_LOADER_EXPORT___.push([module.id, "\n.not-watchlisted:hover .bi-star {\n    color: rgb(255, 159, 67) !important;\n}\n.watchlisted:hover .bi-star-fill {\n    color: rgb(130, 134, 139) !important;\n}\n", "",{"version":3,"sources":["webpack://./resources/src/components/trading/Markets.vue"],"names":[],"mappings":";AA+bA;IACA,mCAAA;AACA;AACA;IACA,oCAAA;AACA","sourcesContent":["<template>\n    <div>\n        <div class=\"d-flex justify-content-between align-items-center\">\n            <button class=\"btn btn-icon\" style=\"position: relative; top: -5px\">\n                <i\n                    class=\"bi bi-chevron-left text-warning fs-4\"\n                    @click.prevent=\"scrollLeft()\"\n                ></i>\n            </button>\n            <ul\n                class=\"nav nav-tabs nf\"\n                role=\"tablist\"\n                style=\"overflow-x: hidden\"\n            >\n                <li class=\"nav-item\">\n                    <a\n                        class=\"nav-link\"\n                        @click.prevent=\"setActive('fav')\"\n                        :class=\"{ active: isActive('fav') }\"\n                        href=\"#fav\"\n                        ><i class=\"bi bi-star\"></i\n                    ></a>\n                </li>\n                <li\n                    class=\"nav-item\"\n                    v-for=\"(pair, index) in pairs\"\n                    :key=\"index\"\n                >\n                    <a\n                        class=\"nav-link\"\n                        @click.prevent=\"setActive(pair)\"\n                        :class=\"{ active: isActive(pair) }\"\n                        href=\"#profile\"\n                        >{{ pair }}</a\n                    >\n                </li>\n            </ul>\n            <button class=\"btn btn-icon\" style=\"position: relative; top: -5px\">\n                <i\n                    class=\"bi bi-chevron-right text-warning fs-4\"\n                    @click.prevent=\"scrollRight()\"\n                ></i>\n            </button>\n        </div>\n        <div class=\"tab-content\" id=\"myTabContent\">\n            <div\n                class=\"tab-pane fade\"\n                :class=\"{ 'active show': isActive('fav') }\"\n                id=\"fav\"\n            >\n                <div class=\"row\">\n                    <div class=\"col-12 card-search custom-data-search\">\n                        <div class=\"input-group input-group-sm px-1 mb-1\">\n                            <span\n                                class=\"input-group-text text-dark border-0\"\n                                id=\"basic-addon1\"\n                                ><i class=\"bi bi-search\"></i\n                            ></span>\n                            <input\n                                type=\"text\"\n                                name=\"search_table_fav\"\n                                class=\"form-control form-control-sm text-dark border-0\"\n                                placeholder=\"Search...\"\n                            />\n                        </div>\n                    </div>\n                </div>\n                <table\n                    class=\"table text-dark table-sm table-borderless tableFixHead custom-data-table-fav\"\n                >\n                    <thead class=\"text-muted\">\n                        <th scope=\"col\">Pair</th>\n                        <th class=\"d-lg-none d-xl-block\" scope=\"col\">Change</th>\n                        <th scope=\"col\">Price</th>\n                    </thead>\n                    <tbody>\n                        <tr v-for=\"(fav, index) in favs\" :key=\"index\">\n                            <td>\n                                <div class=\"d-flex justify-content-start\">\n                                    <form\n                                        @submit.prevent=\"\n                                            removeFromWatchlist(fav.id)\n                                        \"\n                                    >\n                                        <button\n                                            type=\"submit\"\n                                            class=\"watchlisted\"\n                                            style=\"\n                                                background: transparent;\n                                                border: transparent;\n                                            \"\n                                        >\n                                            <i\n                                                class=\"me-1 text-warning bi bi-star-fill\"\n                                            ></i>\n                                        </button>\n                                    </form>\n                                    <router-link\n                                        :to=\"\n                                            '../' +\n                                            fav.currency +\n                                            '/' +\n                                            fav.pair\n                                        \"\n                                    >\n                                        <span class=\"text-dark fw-bold\">{{\n                                            fav.currency\n                                        }}</span\n                                        >/<span\n                                            class=\"text-secondary fw-bold\"\n                                            >{{ fav.pair }}</span\n                                        >\n                                    </router-link>\n                                </div>\n                            </td>\n\n                            <td class=\"d-lg-none d-xl-block\">\n                                <span\n                                    :class=\"'change-' + fav.currency + fav.pair\"\n                                ></span>\n                            </td>\n                            <td>\n                                <span\n                                    :class=\"'tic-' + fav.currency + fav.pair\"\n                                ></span\n                                ><i\n                                    :class=\"\n                                        'tic-' +\n                                        fav.currency +\n                                        fav.pair +\n                                        '-icon bi'\n                                    \"\n                                ></i>\n                            </td>\n                        </tr>\n                    </tbody>\n                </table>\n            </div>\n            <div\n                class=\"tab-pane fade\"\n                v-for=\"(mark, index) in markets\"\n                :key=\"index\"\n                :class=\"{ 'active show': isActive(index) }\"\n                :id=\"{ index }\"\n            >\n                <div class=\"row\">\n                    <div class=\"col-12 card-search custom-data-search\">\n                        <div class=\"input-group input-group-sm px-1 mb-1\">\n                            <span\n                                class=\"input-group-text text-dark border-0\"\n                                id=\"basic-addon1\"\n                                ><i class=\"bi bi-search\"></i\n                            ></span>\n                            <input\n                                type=\"text\"\n                                name=\"search_table\"\n                                class=\"form-control form-control-sm text-dark border-0\"\n                                placeholder=\"Search...\"\n                            />\n                        </div>\n                    </div>\n                </div>\n                <table\n                    class=\"table text-dark table-sm table-borderless tableFixHead\"\n                    :class=\"'custom-data-table-' + index\"\n                >\n                    <thead class=\"text-muted\">\n                        <th scope=\"col\">Pair</th>\n                    </thead>\n                    <tbody>\n                        <tr v-for=\"(market, index) in mark\" :key=\"index\">\n                            <td>\n                                <div class=\"d-flex justify-content-start\">\n                                    <form\n                                        @submit.prevent=\"\n                                            addToWatchlist(\n                                                market.currency,\n                                                market.pair\n                                            )\n                                        \"\n                                    >\n                                        <button\n                                            type=\"submit\"\n                                            class=\"not-watchlisted\"\n                                            style=\"\n                                                background: transparent;\n                                                border: transparent;\n                                            \"\n                                        >\n                                            <i\n                                                class=\"me-1 text-secondary bi bi-star\"\n                                            ></i>\n                                        </button>\n                                    </form>\n                                    <router-link\n                                        :to=\"\n                                            '../' +\n                                            market.currency +\n                                            '/' +\n                                            market.pair\n                                        \"\n                                    >\n                                        <span class=\"text-dark fw-bold\">{{\n                                            market.currency\n                                        }}</span\n                                        >/<span\n                                            class=\"text-secondary fw-bold\"\n                                            >{{ market.pair }}</span\n                                        >\n                                    </router-link>\n                                </div>\n                            </td>\n                        </tr>\n                    </tbody>\n                </table>\n            </div>\n        </div>\n    </div>\n</template>\n\n<script>\n// component\nexport default {\n    props: [\"pairs\", \"provider\"],\n    // component list\n    components: {},\n\n    // component data\n    data() {\n        return {\n            favs: [],\n            old: [],\n            markets: [],\n            activeItem: \"fav\",\n            status: true,\n        };\n    },\n    computed: {},\n\n    // custom methods\n    methods: {\n        fetchMarkets() {\n            this.$http.post(\"/data/markets/markets.json\").then((response) => {\n                this.markets = response.data[this.provider];\n            });\n        },\n        fetchFavs() {\n            this.$http.post(\"/user/watchlist/data\").then((response) => {\n                this.favs = response.data.favs;\n            });\n        },\n        isActive(menuItem) {\n            return this.activeItem === menuItem;\n        },\n        setActive(menuItem) {\n            this.activeItem = menuItem;\n        },\n        scrollLeft() {\n            var leftPos = $(\".nf\").scrollLeft();\n            $(\".nf\").animate({ scrollLeft: leftPos - 200 }, 800);\n        },\n        scrollRight() {\n            var leftPos = $(\".nf\").scrollLeft();\n            $(\".nf\").animate({ scrollLeft: leftPos + 200 }, 800);\n        },\n        addToWatchlist(currency, pair) {\n            this.$http\n                .post(\"/user/watchlist/store\", {\n                    currency: currency,\n                    pair: pair,\n                })\n                .then((response) => {\n                    this.$toast[response.data.type](response.data.message);\n                })\n                .catch((error) => {\n                    this.$toast.error(error.response.data);\n                });\n        },\n        removeFromWatchlist(id) {\n            this.$http\n                .post(\"/user/watchlist/delete\", {\n                    id: id,\n                })\n                .then((response) => {\n                    this.$toast.success(response.data.message);\n                    this.fetchFavs();\n                })\n                .catch((error) => {\n                    this.$toast.error(\"Market Already Removed From Watchlist\");\n                });\n        },\n        handle(tickers) {\n            this.tickerElements = this.tickerElements || {};\n            this.tickerIcons = this.tickerIcons || {};\n            this.changeElements = this.changeElements || {};\n            for (const [symbol, ticker] of Object.entries(tickers)) {\n                const symbolWithoutSlash = symbol.replace(\"/\", \"\");\n                if (!(symbol in this.tickerElements)) {\n                    this.tickerElements[symbol] = $(\n                        \".tic-\" + symbolWithoutSlash\n                    );\n                }\n                if (!(symbol in this.tickerIcons)) {\n                    this.tickerIcons[symbol] = $(\n                        \".tic-\" + symbolWithoutSlash + \"-icon\"\n                    );\n                }\n                const tickerElement = this.tickerElements[symbol];\n                const tickerIcon = this.tickerIcons[symbol];\n                if (!this.old[symbol] || ticker[\"last\"] > this.old[symbol]) {\n                    tickerElement.text(ticker[\"last\"]);\n                    tickerElement.toggleClass(\"text-success\");\n                    tickerIcon.toggleClass(\"bi-arrow-up text-success\");\n                } else if (ticker[\"last\"] < this.old[symbol]) {\n                    tickerElement.text(ticker[\"last\"]);\n                    tickerElement.toggleClass(\"text-danger\");\n                    tickerIcon.toggleClass(\"bi-arrow-down text-danger\");\n                }\n                this.old[symbol] = ticker[\"last\"];\n                if (!(symbol in this.changeElements)) {\n                    this.changeElements[symbol] = $(\n                        \".change-\" + symbolWithoutSlash\n                    );\n                }\n                const changeElement = this.changeElements[symbol];\n                if (ticker[\"change\"] > 0) {\n                    changeElement.text(\n                        this.formatTotal(ticker[\"change\"]) + \"%\"\n                    );\n                    changeElement\n                        .addClass(\"text-success\")\n                        .removeClass(\"text-danger\");\n                } else if (ticker[\"change\"] < 0) {\n                    changeElement.text(\n                        this.formatTotal(ticker[\"change\"]) + \"%\"\n                    );\n                    changeElement\n                        .addClass(\"text-danger\")\n                        .removeClass(\"text-success\");\n                } else {\n                    changeElement.text(\n                        this.formatTotal(ticker[\"change\"]) + \"%\"\n                    );\n                }\n            }\n        },\n\n        async loop() {\n            while (this.status == true) {\n                if (document.hidden) {\n                    await ccxt.sleep(1000);\n                    continue;\n                }\n                try {\n                    const tickers = await exchange.fetchTickers();\n                    this.handle(tickers);\n                } catch (e) {\n                    break;\n                }\n            }\n        },\n        formatTotal(total) {\n            return ccxt.decimalToPrecision(\n                total,\n                ccxt.ROUND,\n                3,\n                ccxt.DECIMAL_PLACES,\n                ccxt.PAD_WITH_ZERO\n            );\n        },\n        async wsClose() {\n            this.status = false;\n            await exchange.close();\n        },\n    },\n\n    // on component created\n    created() {\n        this.fetchFavs();\n        this.fetchMarkets();\n    },\n\n    // on component mounted\n    mounted() {\n        this.loop();\n    },\n    // on component mounted\n    beforeUpdate() {\n        this.pairs.forEach((pair) => {\n            var tr_elements = $(\".custom-data-table-\" + pair + \" tbody tr\");\n            $(document).on(\"input\", \"input[name=search_table]\", function () {\n                var search = $(this).val().toUpperCase();\n                var match = tr_elements\n                    .filter(function (idx, elem) {\n                        return $(elem)\n                            .text()\n                            .trim()\n                            .toUpperCase()\n                            .indexOf(search) >= 0\n                            ? elem\n                            : null;\n                    })\n                    .sort();\n                var table_content = $(\".custom-data-table-\" + pair + \" tbody\");\n                if (match.length == 0) {\n                    table_content.html(\n                        '<tr><td colspan=\"100%\" class=\"text-center\">Data Not Found</td></tr>'\n                    );\n                } else {\n                    table_content.html(match);\n                }\n            });\n        });\n        var tr_elements = $(\".custom-data-table-fav tbody tr\");\n        $(document).on(\"input\", \"input[name=search_table_fav]\", function () {\n            var search = $(this).val().toUpperCase();\n            var match = tr_elements\n                .filter(function (idx, elem) {\n                    return $(elem)\n                        .text()\n                        .trim()\n                        .toUpperCase()\n                        .indexOf(search) >= 0\n                        ? elem\n                        : null;\n                })\n                .sort();\n            var table_content = $(\".custom-data-table-fav tbody\");\n            if (match.length == 0) {\n                table_content.html(\n                    '<tr><td colspan=\"100%\" class=\"text-center\">Data Not Found</td></tr>'\n                );\n            } else {\n                table_content.html(match);\n            }\n        });\n    },\n    unmounted() {\n        this.wsClose();\n    },\n    // on component destroyed\n    destroyed() {\n        this.wsClose();\n    },\n};\n</script>\n<style>\n.not-watchlisted:hover .bi-star {\n    color: rgb(255, 159, 67) !important;\n}\n.watchlisted:hover .bi-star-fill {\n    color: rgb(130, 134, 139) !important;\n}\n</style>\n"],"sourceRoot":""}]);
// Exports
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (___CSS_LOADER_EXPORT___);


/***/ }),

/***/ "./node_modules/laravel-mix/node_modules/css-loader/dist/cjs.js??clonedRuleSet-72[0].rules[0].use[1]!./node_modules/vue-loader/lib/loaders/stylePostLoader.js!./node_modules/laravel-mix/node_modules/postcss-loader/dist/cjs.js??clonedRuleSet-72[0].rules[0].use[2]!./node_modules/sass-loader/dist/cjs.js??clonedRuleSet-72[0].rules[0].use[3]!./node_modules/sass-loader/dist/cjs.js??clonedRuleSet-82[0].rules[0].use[0]!./node_modules/vue-loader/lib/index.js??vue-loader-options!./resources/src/Pages/bot/BotTradePage.vue?vue&type=style&index=0&lang=scss&scope=true&":
/*!***************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/laravel-mix/node_modules/css-loader/dist/cjs.js??clonedRuleSet-72[0].rules[0].use[1]!./node_modules/vue-loader/lib/loaders/stylePostLoader.js!./node_modules/laravel-mix/node_modules/postcss-loader/dist/cjs.js??clonedRuleSet-72[0].rules[0].use[2]!./node_modules/sass-loader/dist/cjs.js??clonedRuleSet-72[0].rules[0].use[3]!./node_modules/sass-loader/dist/cjs.js??clonedRuleSet-82[0].rules[0].use[0]!./node_modules/vue-loader/lib/index.js??vue-loader-options!./resources/src/Pages/bot/BotTradePage.vue?vue&type=style&index=0&lang=scss&scope=true& ***!
  \***************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _node_modules_laravel_mix_node_modules_css_loader_dist_runtime_cssWithMappingToString_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../../node_modules/laravel-mix/node_modules/css-loader/dist/runtime/cssWithMappingToString.js */ "./node_modules/laravel-mix/node_modules/css-loader/dist/runtime/cssWithMappingToString.js");
/* harmony import */ var _node_modules_laravel_mix_node_modules_css_loader_dist_runtime_cssWithMappingToString_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_laravel_mix_node_modules_css_loader_dist_runtime_cssWithMappingToString_js__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _node_modules_laravel_mix_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../../node_modules/laravel-mix/node_modules/css-loader/dist/runtime/api.js */ "./node_modules/laravel-mix/node_modules/css-loader/dist/runtime/api.js");
/* harmony import */ var _node_modules_laravel_mix_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_node_modules_laravel_mix_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__);
// Imports


var ___CSS_LOADER_EXPORT___ = _node_modules_laravel_mix_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default()((_node_modules_laravel_mix_node_modules_css_loader_dist_runtime_cssWithMappingToString_js__WEBPACK_IMPORTED_MODULE_0___default()));
// Module
___CSS_LOADER_EXPORT___.push([module.id, ":root {\n  --theme-background-base: #171b29;\n  --theme-background-300: #d6dae8;\n  --theme-background-o75: rgba(41, 49, 74, 0.75);\n  --theme-background-o20: rgba(41, 49, 74, 0.2);\n  --theme-color-o75: rgba(213, 240, 233, 0.75);\n}\ntable {\n  border-collapse: collapse;\n  width: 100%;\n  font-size: 11px;\n  font-weight: 500;\n  color: #b7bdc6;\n  overflow: hidden;\n  width: 100%;\n}\n.tdd {\n  position: relative;\n  height: 18px;\n  line-height: 18px;\n}\ntd {\n  height: 12px;\n  line-height: 12px;\n}\ntd span {\n  position: relative;\n  z-index: 2;\n}\ntd .percent {\n  position: absolute;\n  top: 0;\n  bottom: 0;\n}\n[dir=ltr] td .percent {\n  right: 0;\n}\n[dir=rtl] td .percent {\n  left: 0;\n}\ntd.price {\n  width: 30%;\n}\n[dir=ltr] td.price span {\n  padding-left: 5px;\n}\n[dir=rtl] td.price span {\n  padding-right: 5px;\n}\ntd.quantity {\n  width: 30%;\n}\n[dir=ltr] td.quantity {\n  text-align: right;\n}\n[dir=rtl] td.quantity {\n  text-align: left;\n}\ntd.time {\n  width: 40%;\n  color: #999;\n}\n[dir=ltr] td.time {\n  text-align: right;\n  padding-right: 5px;\n}\n[dir=rtl] td.time {\n  text-align: left;\n  padding-left: 5px;\n}\ntd.btc {\n  width: 40%;\n}\n[dir=ltr] td.btc {\n  text-align: right;\n  padding-right: 5px;\n}\n[dir=rtl] td.btc {\n  text-align: left;\n  padding-left: 5px;\n}\n[dir] table.asks .percent {\n  background-color: rgba(246, 70, 94, 0.2);\n}\n[dir] table.bids .percent {\n  background-color: rgba(14, 203, 129, 0.2);\n}\n[dir] table.asks_only .percent {\n  background-color: rgba(246, 70, 94, 0.2);\n}\n[dir] table.bids_only .percent {\n  background-color: rgba(14, 203, 129, 0.2);\n}\n.order-loader {\n  position: relative;\n  top: 120px;\n  width: 100%;\n  height: 100%;\n  z-index: 9999;\n}\n[dir] .order-loader {\n  background: rgba(0, 0, 0, 0.7098039216);\n}\n[dir=ltr] .order-loader {\n  right: 0px;\n}\n[dir=rtl] .order-loader {\n  left: 0px;\n}\n.se-pre-con2 {\n  position: absolute;\n  top: 50%;\n}\n[dir=ltr] .se-pre-con2 {\n  left: 50%;\n}\n[dir=rtl] .se-pre-con2 {\n  right: 50%;\n}\n.hidden {\n  display: none;\n}\n@media (max-width: 767.98px) {\nhtml[dir] body.navbar-sticky .app-content {\n    padding: 4.65rem 0 0 0 !important;\n}\n}", "",{"version":3,"sources":["webpack://./resources/src/Pages/bot/BotTradePage.vue"],"names":[],"mappings":"AAAA;EACE,gCAAA;EACA,+BAAA;EACA,8CAAA;EACA,6CAAA;EACA,4CAAA;AACF;AAEA;EACE,yBAAA;EACA,WAAA;EACA,eAAA;EACA,gBAAA;EACA,cAAA;EACA,gBAAA;EACA,WAAA;AACF;AAEA;EACE,kBAAA;EACA,YAAA;EACA,iBAAA;AACF;AAEA;EACE,YAAA;EACA,iBAAA;AACF;AACA;EACE,kBAAA;EACA,UAAA;AAEF;AAAA;EACE,kBAAA;EACA,MAAA;EACA,SAAA;AAIF;AAPA;EAIE,QAAA;AAGF;AAPA;EAIE,OAAA;AAGF;AAAA;EACE,UAAA;AAGF;AADA;EACE,iBAAA;AAIF;AALA;EACE,kBAAA;AAIF;AADA;EACE,UAAA;AAKF;AANA;EAEE,iBAAA;AAIF;AANA;EAEE,gBAAA;AAIF;AADA;EACE,UAAA;EAEA,WAAA;AAKF;AARA;EAEE,iBAAA;EAEA,kBAAA;AAIF;AARA;EAEE,gBAAA;EAEA,iBAAA;AAIF;AADA;EACE,UAAA;AAMF;AAPA;EAEE,iBAAA;EACA,kBAAA;AAIF;AAPA;EAEE,gBAAA;EACA,iBAAA;AAIF;AADA;EACE,wCAAA;AAIF;AADA;EACE,yCAAA;AAIF;AADA;EACE,wCAAA;AAIF;AADA;EACE,yCAAA;AAIF;AADA;EACE,kBAAA;EAEA,UAAA;EACA,WAAA;EACA,YAAA;EACA,aAAA;AAKF;AAXA;EAOE,uCAAA;AAIF;AAXA;EAEE,UAAA;AASF;AAXA;EAEE,SAAA;AASF;AADA;EACE,kBAAA;EACA,QAAA;AAKF;AAPA;EAGE,SAAA;AAIF;AAPA;EAGE,UAAA;AAIF;AADA;EACE,aAAA;AAIF;AADA;AACE;IACE,iCAAA;AAIF;AACF","sourcesContent":[":root {\n  --theme-background-base: #171b29;\n  --theme-background-300: #d6dae8;\n  --theme-background-o75: rgba(41, 49, 74, 0.75);\n  --theme-background-o20: rgba(41, 49, 74, 0.2);\n  --theme-color-o75: rgba(213, 240, 233, 0.75);\n}\n\ntable {\n  border-collapse: collapse;\n  width: 100%;\n  font-size: 11px;\n  font-weight: 500;\n  color: #b7bdc6;\n  overflow: hidden;\n  width: 100%;\n}\n\n.tdd {\n  position: relative;\n  height: 18px;\n  line-height: 18px;\n}\n\ntd {\n  height: 12px;\n  line-height: 12px;\n}\ntd span {\n  position: relative;\n  z-index: 2;\n}\ntd .percent {\n  position: absolute;\n  top: 0;\n  bottom: 0;\n  right: 0;\n}\n\ntd.price {\n  width: 30%;\n}\ntd.price span {\n  padding-left: 5px;\n}\n\ntd.quantity {\n  width: 30%;\n  text-align: right;\n}\n\ntd.time {\n  width: 40%;\n  text-align: right;\n  color: #999;\n  padding-right: 5px;\n}\n\ntd.btc {\n  width: 40%;\n  text-align: right;\n  padding-right: 5px;\n}\n\ntable.asks .percent {\n  background-color: rgba(246, 70, 94, 0.2);\n}\n\ntable.bids .percent {\n  background-color: rgba(14, 203, 129, 0.2);\n}\n\ntable.asks_only .percent {\n  background-color: rgba(246, 70, 94, 0.2);\n}\n\ntable.bids_only .percent {\n  background-color: rgba(14, 203, 129, 0.2);\n}\n\n.order-loader {\n  position: relative;\n  right: 0px;\n  top: 120px;\n  width: 100%;\n  height: 100%;\n  z-index: 9999;\n  background: rgba(0, 0, 0, 0.7098039216);\n}\n\n.se-pre-con2 {\n  position: absolute;\n  top: 50%;\n  left: 50%;\n}\n\n.hidden {\n  display: none;\n}\n\n@media (max-width: 767.98px) {\n  html body.navbar-sticky .app-content {\n    padding: 4.65rem 0 0 0 !important;\n  }\n}"],"sourceRoot":""}]);
// Exports
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (___CSS_LOADER_EXPORT___);


/***/ }),

/***/ "./node_modules/style-loader/dist/cjs.js!./node_modules/laravel-mix/node_modules/css-loader/dist/cjs.js??clonedRuleSet-69[0].rules[0].use[1]!./node_modules/vue-loader/lib/loaders/stylePostLoader.js!./node_modules/laravel-mix/node_modules/postcss-loader/dist/cjs.js??clonedRuleSet-69[0].rules[0].use[2]!./node_modules/vue-loader/lib/index.js??vue-loader-options!./resources/src/components/trading/Markets.vue?vue&type=style&index=0&lang=css&":
/*!***************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/style-loader/dist/cjs.js!./node_modules/laravel-mix/node_modules/css-loader/dist/cjs.js??clonedRuleSet-69[0].rules[0].use[1]!./node_modules/vue-loader/lib/loaders/stylePostLoader.js!./node_modules/laravel-mix/node_modules/postcss-loader/dist/cjs.js??clonedRuleSet-69[0].rules[0].use[2]!./node_modules/vue-loader/lib/index.js??vue-loader-options!./resources/src/components/trading/Markets.vue?vue&type=style&index=0&lang=css& ***!
  \***************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! !../../../../node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js */ "./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js");
/* harmony import */ var _node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _node_modules_laravel_mix_node_modules_css_loader_dist_cjs_js_clonedRuleSet_69_0_rules_0_use_1_node_modules_vue_loader_lib_loaders_stylePostLoader_js_node_modules_laravel_mix_node_modules_postcss_loader_dist_cjs_js_clonedRuleSet_69_0_rules_0_use_2_node_modules_vue_loader_lib_index_js_vue_loader_options_Markets_vue_vue_type_style_index_0_lang_css___WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! !!../../../../node_modules/laravel-mix/node_modules/css-loader/dist/cjs.js??clonedRuleSet-69[0].rules[0].use[1]!../../../../node_modules/vue-loader/lib/loaders/stylePostLoader.js!../../../../node_modules/laravel-mix/node_modules/postcss-loader/dist/cjs.js??clonedRuleSet-69[0].rules[0].use[2]!../../../../node_modules/vue-loader/lib/index.js??vue-loader-options!./Markets.vue?vue&type=style&index=0&lang=css& */ "./node_modules/laravel-mix/node_modules/css-loader/dist/cjs.js??clonedRuleSet-69[0].rules[0].use[1]!./node_modules/vue-loader/lib/loaders/stylePostLoader.js!./node_modules/laravel-mix/node_modules/postcss-loader/dist/cjs.js??clonedRuleSet-69[0].rules[0].use[2]!./node_modules/vue-loader/lib/index.js??vue-loader-options!./resources/src/components/trading/Markets.vue?vue&type=style&index=0&lang=css&");

            

var options = {};

options.insert = "head";
options.singleton = false;

var update = _node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default()(_node_modules_laravel_mix_node_modules_css_loader_dist_cjs_js_clonedRuleSet_69_0_rules_0_use_1_node_modules_vue_loader_lib_loaders_stylePostLoader_js_node_modules_laravel_mix_node_modules_postcss_loader_dist_cjs_js_clonedRuleSet_69_0_rules_0_use_2_node_modules_vue_loader_lib_index_js_vue_loader_options_Markets_vue_vue_type_style_index_0_lang_css___WEBPACK_IMPORTED_MODULE_1__["default"], options);



/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (_node_modules_laravel_mix_node_modules_css_loader_dist_cjs_js_clonedRuleSet_69_0_rules_0_use_1_node_modules_vue_loader_lib_loaders_stylePostLoader_js_node_modules_laravel_mix_node_modules_postcss_loader_dist_cjs_js_clonedRuleSet_69_0_rules_0_use_2_node_modules_vue_loader_lib_index_js_vue_loader_options_Markets_vue_vue_type_style_index_0_lang_css___WEBPACK_IMPORTED_MODULE_1__["default"].locals || {});

/***/ }),

/***/ "./node_modules/style-loader/dist/cjs.js!./node_modules/laravel-mix/node_modules/css-loader/dist/cjs.js??clonedRuleSet-72[0].rules[0].use[1]!./node_modules/vue-loader/lib/loaders/stylePostLoader.js!./node_modules/laravel-mix/node_modules/postcss-loader/dist/cjs.js??clonedRuleSet-72[0].rules[0].use[2]!./node_modules/sass-loader/dist/cjs.js??clonedRuleSet-72[0].rules[0].use[3]!./node_modules/sass-loader/dist/cjs.js??clonedRuleSet-82[0].rules[0].use[0]!./node_modules/vue-loader/lib/index.js??vue-loader-options!./resources/src/Pages/bot/BotTradePage.vue?vue&type=style&index=0&lang=scss&scope=true&":
/*!*******************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/style-loader/dist/cjs.js!./node_modules/laravel-mix/node_modules/css-loader/dist/cjs.js??clonedRuleSet-72[0].rules[0].use[1]!./node_modules/vue-loader/lib/loaders/stylePostLoader.js!./node_modules/laravel-mix/node_modules/postcss-loader/dist/cjs.js??clonedRuleSet-72[0].rules[0].use[2]!./node_modules/sass-loader/dist/cjs.js??clonedRuleSet-72[0].rules[0].use[3]!./node_modules/sass-loader/dist/cjs.js??clonedRuleSet-82[0].rules[0].use[0]!./node_modules/vue-loader/lib/index.js??vue-loader-options!./resources/src/Pages/bot/BotTradePage.vue?vue&type=style&index=0&lang=scss&scope=true& ***!
  \*******************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! !../../../../node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js */ "./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js");
/* harmony import */ var _node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _node_modules_laravel_mix_node_modules_css_loader_dist_cjs_js_clonedRuleSet_72_0_rules_0_use_1_node_modules_vue_loader_lib_loaders_stylePostLoader_js_node_modules_laravel_mix_node_modules_postcss_loader_dist_cjs_js_clonedRuleSet_72_0_rules_0_use_2_node_modules_sass_loader_dist_cjs_js_clonedRuleSet_72_0_rules_0_use_3_node_modules_sass_loader_dist_cjs_js_clonedRuleSet_82_0_rules_0_use_0_node_modules_vue_loader_lib_index_js_vue_loader_options_BotTradePage_vue_vue_type_style_index_0_lang_scss_scope_true___WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! !!../../../../node_modules/laravel-mix/node_modules/css-loader/dist/cjs.js??clonedRuleSet-72[0].rules[0].use[1]!../../../../node_modules/vue-loader/lib/loaders/stylePostLoader.js!../../../../node_modules/laravel-mix/node_modules/postcss-loader/dist/cjs.js??clonedRuleSet-72[0].rules[0].use[2]!../../../../node_modules/sass-loader/dist/cjs.js??clonedRuleSet-72[0].rules[0].use[3]!../../../../node_modules/sass-loader/dist/cjs.js??clonedRuleSet-82[0].rules[0].use[0]!../../../../node_modules/vue-loader/lib/index.js??vue-loader-options!./BotTradePage.vue?vue&type=style&index=0&lang=scss&scope=true& */ "./node_modules/laravel-mix/node_modules/css-loader/dist/cjs.js??clonedRuleSet-72[0].rules[0].use[1]!./node_modules/vue-loader/lib/loaders/stylePostLoader.js!./node_modules/laravel-mix/node_modules/postcss-loader/dist/cjs.js??clonedRuleSet-72[0].rules[0].use[2]!./node_modules/sass-loader/dist/cjs.js??clonedRuleSet-72[0].rules[0].use[3]!./node_modules/sass-loader/dist/cjs.js??clonedRuleSet-82[0].rules[0].use[0]!./node_modules/vue-loader/lib/index.js??vue-loader-options!./resources/src/Pages/bot/BotTradePage.vue?vue&type=style&index=0&lang=scss&scope=true&");

            

var options = {};

options.insert = "head";
options.singleton = false;

var update = _node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default()(_node_modules_laravel_mix_node_modules_css_loader_dist_cjs_js_clonedRuleSet_72_0_rules_0_use_1_node_modules_vue_loader_lib_loaders_stylePostLoader_js_node_modules_laravel_mix_node_modules_postcss_loader_dist_cjs_js_clonedRuleSet_72_0_rules_0_use_2_node_modules_sass_loader_dist_cjs_js_clonedRuleSet_72_0_rules_0_use_3_node_modules_sass_loader_dist_cjs_js_clonedRuleSet_82_0_rules_0_use_0_node_modules_vue_loader_lib_index_js_vue_loader_options_BotTradePage_vue_vue_type_style_index_0_lang_scss_scope_true___WEBPACK_IMPORTED_MODULE_1__["default"], options);



/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (_node_modules_laravel_mix_node_modules_css_loader_dist_cjs_js_clonedRuleSet_72_0_rules_0_use_1_node_modules_vue_loader_lib_loaders_stylePostLoader_js_node_modules_laravel_mix_node_modules_postcss_loader_dist_cjs_js_clonedRuleSet_72_0_rules_0_use_2_node_modules_sass_loader_dist_cjs_js_clonedRuleSet_72_0_rules_0_use_3_node_modules_sass_loader_dist_cjs_js_clonedRuleSet_82_0_rules_0_use_0_node_modules_vue_loader_lib_index_js_vue_loader_options_BotTradePage_vue_vue_type_style_index_0_lang_scss_scope_true___WEBPACK_IMPORTED_MODULE_1__["default"].locals || {});

/***/ }),

/***/ "./node_modules/vue-grid-layout/dist/vue-grid-layout.common.js":
/*!*********************************************************************!*\
  !*** ./node_modules/vue-grid-layout/dist/vue-grid-layout.common.js ***!
  \*********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/*! vue-grid-layout - 2.3.12 | (c) 2015, 2021  Gustavo Santos (JBay Solutions) <gustavo.santos@jbaysolutions.com> (http://www.jbaysolutions.com) | https://github.com/jbaysolutions/vue-grid-layout */
module.exports =
/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __nested_webpack_require_386__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __nested_webpack_require_386__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__nested_webpack_require_386__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__nested_webpack_require_386__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__nested_webpack_require_386__.d = function(exports, name, getter) {
/******/ 		if(!__nested_webpack_require_386__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__nested_webpack_require_386__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__nested_webpack_require_386__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __nested_webpack_require_386__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__nested_webpack_require_386__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __nested_webpack_require_386__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__nested_webpack_require_386__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__nested_webpack_require_386__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__nested_webpack_require_386__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__nested_webpack_require_386__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __nested_webpack_require_386__(__nested_webpack_require_386__.s = "fb15");
/******/ })
/************************************************************************/
/******/ ({

/***/ "01f9":
/***/ (function(module, exports, __nested_webpack_require_3862__) {

"use strict";

var LIBRARY = __nested_webpack_require_3862__("2d00");
var $export = __nested_webpack_require_3862__("5ca1");
var redefine = __nested_webpack_require_3862__("2aba");
var hide = __nested_webpack_require_3862__("32e9");
var Iterators = __nested_webpack_require_3862__("84f2");
var $iterCreate = __nested_webpack_require_3862__("41a0");
var setToStringTag = __nested_webpack_require_3862__("7f20");
var getPrototypeOf = __nested_webpack_require_3862__("38fd");
var ITERATOR = __nested_webpack_require_3862__("2b4c")('iterator');
var BUGGY = !([].keys && 'next' in [].keys()); // Safari has buggy iterators w/o `next`
var FF_ITERATOR = '@@iterator';
var KEYS = 'keys';
var VALUES = 'values';

var returnThis = function () { return this; };

module.exports = function (Base, NAME, Constructor, next, DEFAULT, IS_SET, FORCED) {
  $iterCreate(Constructor, NAME, next);
  var getMethod = function (kind) {
    if (!BUGGY && kind in proto) return proto[kind];
    switch (kind) {
      case KEYS: return function keys() { return new Constructor(this, kind); };
      case VALUES: return function values() { return new Constructor(this, kind); };
    } return function entries() { return new Constructor(this, kind); };
  };
  var TAG = NAME + ' Iterator';
  var DEF_VALUES = DEFAULT == VALUES;
  var VALUES_BUG = false;
  var proto = Base.prototype;
  var $native = proto[ITERATOR] || proto[FF_ITERATOR] || DEFAULT && proto[DEFAULT];
  var $default = $native || getMethod(DEFAULT);
  var $entries = DEFAULT ? !DEF_VALUES ? $default : getMethod('entries') : undefined;
  var $anyNative = NAME == 'Array' ? proto.entries || $native : $native;
  var methods, key, IteratorPrototype;
  // Fix native
  if ($anyNative) {
    IteratorPrototype = getPrototypeOf($anyNative.call(new Base()));
    if (IteratorPrototype !== Object.prototype && IteratorPrototype.next) {
      // Set @@toStringTag to native iterators
      setToStringTag(IteratorPrototype, TAG, true);
      // fix for some old engines
      if (!LIBRARY && typeof IteratorPrototype[ITERATOR] != 'function') hide(IteratorPrototype, ITERATOR, returnThis);
    }
  }
  // fix Array#{values, @@iterator}.name in V8 / FF
  if (DEF_VALUES && $native && $native.name !== VALUES) {
    VALUES_BUG = true;
    $default = function values() { return $native.call(this); };
  }
  // Define iterator
  if ((!LIBRARY || FORCED) && (BUGGY || VALUES_BUG || !proto[ITERATOR])) {
    hide(proto, ITERATOR, $default);
  }
  // Plug for library
  Iterators[NAME] = $default;
  Iterators[TAG] = returnThis;
  if (DEFAULT) {
    methods = {
      values: DEF_VALUES ? $default : getMethod(VALUES),
      keys: IS_SET ? $default : getMethod(KEYS),
      entries: $entries
    };
    if (FORCED) for (key in methods) {
      if (!(key in proto)) redefine(proto, key, methods[key]);
    } else $export($export.P + $export.F * (BUGGY || VALUES_BUG), NAME, methods);
  }
  return methods;
};


/***/ }),

/***/ "02f4":
/***/ (function(module, exports, __nested_webpack_require_6768__) {

var toInteger = __nested_webpack_require_6768__("4588");
var defined = __nested_webpack_require_6768__("be13");
// true  -> String#at
// false -> String#codePointAt
module.exports = function (TO_STRING) {
  return function (that, pos) {
    var s = String(defined(that));
    var i = toInteger(pos);
    var l = s.length;
    var a, b;
    if (i < 0 || i >= l) return TO_STRING ? '' : undefined;
    a = s.charCodeAt(i);
    return a < 0xd800 || a > 0xdbff || i + 1 === l || (b = s.charCodeAt(i + 1)) < 0xdc00 || b > 0xdfff
      ? TO_STRING ? s.charAt(i) : a
      : TO_STRING ? s.slice(i, i + 2) : (a - 0xd800 << 10) + (b - 0xdc00) + 0x10000;
  };
};


/***/ }),

/***/ "0390":
/***/ (function(module, exports, __nested_webpack_require_7481__) {

"use strict";

var at = __nested_webpack_require_7481__("02f4")(true);

 // `AdvanceStringIndex` abstract operation
// https://tc39.github.io/ecma262/#sec-advancestringindex
module.exports = function (S, index, unicode) {
  return index + (unicode ? at(S, index).length : 1);
};


/***/ }),

/***/ "0bfb":
/***/ (function(module, exports, __nested_webpack_require_7832__) {

"use strict";

// 21.2.5.3 get RegExp.prototype.flags
var anObject = __nested_webpack_require_7832__("cb7c");
module.exports = function () {
  var that = anObject(this);
  var result = '';
  if (that.global) result += 'g';
  if (that.ignoreCase) result += 'i';
  if (that.multiline) result += 'm';
  if (that.unicode) result += 'u';
  if (that.sticky) result += 'y';
  return result;
};


/***/ }),

/***/ "0d58":
/***/ (function(module, exports, __nested_webpack_require_8291__) {

// 19.1.2.14 / 15.2.3.14 Object.keys(O)
var $keys = __nested_webpack_require_8291__("ce10");
var enumBugKeys = __nested_webpack_require_8291__("e11e");

module.exports = Object.keys || function keys(O) {
  return $keys(O, enumBugKeys);
};


/***/ }),

/***/ "1156":
/***/ (function(module, exports, __nested_webpack_require_8590__) {

// style-loader: Adds some css to the DOM by adding a <style> tag

// load the styles
var content = __nested_webpack_require_8590__("ad20");
if(typeof content === 'string') content = [[module.i, content, '']];
if(content.locals) module.exports = content.locals;
// add the styles to the DOM
var add = __nested_webpack_require_8590__("499e").default
var update = add("c1ec597e", content, true, {"sourceMap":false,"shadowMode":false});

/***/ }),

/***/ "11e9":
/***/ (function(module, exports, __nested_webpack_require_9083__) {

var pIE = __nested_webpack_require_9083__("52a7");
var createDesc = __nested_webpack_require_9083__("4630");
var toIObject = __nested_webpack_require_9083__("6821");
var toPrimitive = __nested_webpack_require_9083__("6a99");
var has = __nested_webpack_require_9083__("69a8");
var IE8_DOM_DEFINE = __nested_webpack_require_9083__("c69a");
var gOPD = Object.getOwnPropertyDescriptor;

exports.f = __nested_webpack_require_9083__("9e1e") ? gOPD : function getOwnPropertyDescriptor(O, P) {
  O = toIObject(O);
  P = toPrimitive(P, true);
  if (IE8_DOM_DEFINE) try {
    return gOPD(O, P);
  } catch (e) { /* empty */ }
  if (has(O, P)) return createDesc(!pIE.f.call(O, P), O[P]);
};


/***/ }),

/***/ "1495":
/***/ (function(module, exports, __nested_webpack_require_9762__) {

var dP = __nested_webpack_require_9762__("86cc");
var anObject = __nested_webpack_require_9762__("cb7c");
var getKeys = __nested_webpack_require_9762__("0d58");

module.exports = __nested_webpack_require_9762__("9e1e") ? Object.defineProperties : function defineProperties(O, Properties) {
  anObject(O);
  var keys = getKeys(Properties);
  var length = keys.length;
  var i = 0;
  var P;
  while (length > i) dP.f(O, P = keys[i++], Properties[P]);
  return O;
};


/***/ }),

/***/ "18d2":
/***/ (function(module, exports, __nested_webpack_require_10262__) {

"use strict";
/**
 * Resize detection strategy that injects objects to elements in order to detect resize events.
 * Heavily inspired by: http://www.backalleycoder.com/2013/03/18/cross-browser-event-based-element-resize-detection/
 */



var browserDetector = __nested_webpack_require_10262__("18e9");

module.exports = function(options) {
    options             = options || {};
    var reporter        = options.reporter;
    var batchProcessor  = options.batchProcessor;
    var getState        = options.stateHandler.getState;

    if(!reporter) {
        throw new Error("Missing required dependency: reporter.");
    }

    /**
     * Adds a resize event listener to the element.
     * @public
     * @param {element} element The element that should have the listener added.
     * @param {function} listener The listener callback to be called for each resize event of the element. The element will be given as a parameter to the listener callback.
     */
    function addListener(element, listener) {
        function listenerProxy() {
            listener(element);
        }

        if(browserDetector.isIE(8)) {
            //IE 8 does not support object, but supports the resize event directly on elements.
            getState(element).object = {
                proxy: listenerProxy
            };
            element.attachEvent("onresize", listenerProxy);
        } else {
            var object = getObject(element);

            if(!object) {
                throw new Error("Element is not detectable by this strategy.");
            }

            object.contentDocument.defaultView.addEventListener("resize", listenerProxy);
        }
    }

    function buildCssTextString(rules) {
        var seperator = options.important ? " !important; " : "; ";

        return (rules.join(seperator) + seperator).trim();
    }

    /**
     * Makes an element detectable and ready to be listened for resize events. Will call the callback when the element is ready to be listened for resize changes.
     * @private
     * @param {object} options Optional options object.
     * @param {element} element The element to make detectable
     * @param {function} callback The callback to be called when the element is ready to be listened for resize changes. Will be called with the element as first parameter.
     */
    function makeDetectable(options, element, callback) {
        if (!callback) {
            callback = element;
            element = options;
            options = null;
        }

        options = options || {};
        var debug = options.debug;

        function injectObject(element, callback) {
            var OBJECT_STYLE = buildCssTextString(["display: block", "position: absolute", "top: 0", "left: 0", "width: 100%", "height: 100%", "border: none", "padding: 0", "margin: 0", "opacity: 0", "z-index: -1000", "pointer-events: none"]);

            //The target element needs to be positioned (everything except static) so the absolute positioned object will be positioned relative to the target element.

            // Position altering may be performed directly or on object load, depending on if style resolution is possible directly or not.
            var positionCheckPerformed = false;

            // The element may not yet be attached to the DOM, and therefore the style object may be empty in some browsers.
            // Since the style object is a reference, it will be updated as soon as the element is attached to the DOM.
            var style = window.getComputedStyle(element);
            var width = element.offsetWidth;
            var height = element.offsetHeight;

            getState(element).startSize = {
                width: width,
                height: height
            };

            function mutateDom() {
                function alterPositionStyles() {
                    if(style.position === "static") {
                        element.style.setProperty("position", "relative", options.important ? "important" : "");

                        var removeRelativeStyles = function(reporter, element, style, property) {
                            function getNumericalValue(value) {
                                return value.replace(/[^-\d\.]/g, "");
                            }

                            var value = style[property];

                            if(value !== "auto" && getNumericalValue(value) !== "0") {
                                reporter.warn("An element that is positioned static has style." + property + "=" + value + " which is ignored due to the static positioning. The element will need to be positioned relative, so the style." + property + " will be set to 0. Element: ", element);
                                element.style.setProperty(property, "0", options.important ? "important" : "");
                            }
                        };

                        //Check so that there are no accidental styles that will make the element styled differently now that is is relative.
                        //If there are any, set them to 0 (this should be okay with the user since the style properties did nothing before [since the element was positioned static] anyway).
                        removeRelativeStyles(reporter, element, style, "top");
                        removeRelativeStyles(reporter, element, style, "right");
                        removeRelativeStyles(reporter, element, style, "bottom");
                        removeRelativeStyles(reporter, element, style, "left");
                    }
                }

                function onObjectLoad() {
                    // The object has been loaded, which means that the element now is guaranteed to be attached to the DOM.
                    if (!positionCheckPerformed) {
                        alterPositionStyles();
                    }

                    /*jshint validthis: true */

                    function getDocument(element, callback) {
                        //Opera 12 seem to call the object.onload before the actual document has been created.
                        //So if it is not present, poll it with an timeout until it is present.
                        //TODO: Could maybe be handled better with object.onreadystatechange or similar.
                        if(!element.contentDocument) {
                            var state = getState(element);
                            if (state.checkForObjectDocumentTimeoutId) {
                                window.clearTimeout(state.checkForObjectDocumentTimeoutId);
                            }
                            state.checkForObjectDocumentTimeoutId = setTimeout(function checkForObjectDocument() {
                                state.checkForObjectDocumentTimeoutId = 0;
                                getDocument(element, callback);
                            }, 100);

                            return;
                        }

                        callback(element.contentDocument);
                    }

                    //Mutating the object element here seems to fire another load event.
                    //Mutating the inner document of the object element is fine though.
                    var objectElement = this;

                    //Create the style element to be added to the object.
                    getDocument(objectElement, function onObjectDocumentReady(objectDocument) {
                        //Notify that the element is ready to be listened to.
                        callback(element);
                    });
                }

                // The element may be detached from the DOM, and some browsers does not support style resolving of detached elements.
                // The alterPositionStyles needs to be delayed until we know the element has been attached to the DOM (which we are sure of when the onObjectLoad has been fired), if style resolution is not possible.
                if (style.position !== "") {
                    alterPositionStyles(style);
                    positionCheckPerformed = true;
                }

                //Add an object element as a child to the target element that will be listened to for resize events.
                var object = document.createElement("object");
                object.style.cssText = OBJECT_STYLE;
                object.tabIndex = -1;
                object.type = "text/html";
                object.setAttribute("aria-hidden", "true");
                object.onload = onObjectLoad;

                //Safari: This must occur before adding the object to the DOM.
                //IE: Does not like that this happens before, even if it is also added after.
                if(!browserDetector.isIE()) {
                    object.data = "about:blank";
                }

                if (!getState(element)) {
                    // The element has been uninstalled before the actual loading happened.
                    return;
                }

                element.appendChild(object);
                getState(element).object = object;

                //IE: This must occur after adding the object to the DOM.
                if(browserDetector.isIE()) {
                    object.data = "about:blank";
                }
            }

            if(batchProcessor) {
                batchProcessor.add(mutateDom);
            } else {
                mutateDom();
            }
        }

        if(browserDetector.isIE(8)) {
            //IE 8 does not support objects properly. Luckily they do support the resize event.
            //So do not inject the object and notify that the element is already ready to be listened to.
            //The event handler for the resize event is attached in the utils.addListener instead.
            callback(element);
        } else {
            injectObject(element, callback);
        }
    }

    /**
     * Returns the child object of the target element.
     * @private
     * @param {element} element The target element.
     * @returns The object element of the target.
     */
    function getObject(element) {
        return getState(element).object;
    }

    function uninstall(element) {
        if (!getState(element)) {
            return;
        }

        var object = getObject(element);

        if (!object) {
            return;
        }

        if (browserDetector.isIE(8)) {
            element.detachEvent("onresize", object.proxy);
        } else {
            element.removeChild(object);
        }

        if (getState(element).checkForObjectDocumentTimeoutId) {
            window.clearTimeout(getState(element).checkForObjectDocumentTimeoutId);
        }

        delete getState(element).object;
    }

    return {
        makeDetectable: makeDetectable,
        addListener: addListener,
        uninstall: uninstall
    };
};


/***/ }),

/***/ "18e9":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var detector = module.exports = {};

detector.isIE = function(version) {
    function isAnyIeVersion() {
        var agent = navigator.userAgent.toLowerCase();
        return agent.indexOf("msie") !== -1 || agent.indexOf("trident") !== -1 || agent.indexOf(" edge/") !== -1;
    }

    if(!isAnyIeVersion()) {
        return false;
    }

    if(!version) {
        return true;
    }

    //Shamelessly stolen from https://gist.github.com/padolsey/527683
    var ieVersion = (function(){
        var undef,
            v = 3,
            div = document.createElement("div"),
            all = div.getElementsByTagName("i");

        do {
            div.innerHTML = "<!--[if gt IE " + (++v) + "]><i></i><![endif]-->";
        }
        while (all[0]);

        return v > 4 ? v : undef;
    }());

    return version === ieVersion;
};

detector.isLegacyOpera = function() {
    return !!window.opera;
};


/***/ }),

/***/ "1ca7":
/***/ (function(module, __webpack_exports__, __nested_webpack_require_22207__) {

"use strict";
/* harmony export (binding) */ __nested_webpack_require_22207__.d(__webpack_exports__, "b", function() { return getDocumentDir; });
/* unused harmony export setDocumentDir */
/* harmony export (binding) */ __nested_webpack_require_22207__.d(__webpack_exports__, "a", function() { return addWindowEventListener; });
/* harmony export (binding) */ __nested_webpack_require_22207__.d(__webpack_exports__, "c", function() { return removeWindowEventListener; });
var currentDir
/*: "ltr" | "rtl" | "auto"*/
= "auto"; // let currentDir = "auto";

function hasDocument() {
  return typeof document !== "undefined";
}

function hasWindow() {
  return typeof window !== "undefined";
}

function getDocumentDir() {
  if (!hasDocument()) {
    return currentDir;
  }

  var direction = typeof document.dir !== "undefined" ? document.dir : document.getElementsByTagName("html")[0].getAttribute("dir");
  return direction;
}
function setDocumentDir(dir
/*: "ltr" | "rtl" | "auto"*/
) {
  // export function setDocumentDir(dir){
  if (!hasDocument) {
    currentDir = dir;
    return;
  }

  var html = document.getElementsByTagName("html")[0];
  html.setAttribute("dir", dir);
}
function addWindowEventListener(event
/*:string*/
, callback
/*: () => mixed*/
) {
  if (!hasWindow) {
    callback();
    return;
  }

  window.addEventListener(event, callback);
}
function removeWindowEventListener(event
/*:string*/
, callback
/*: () => mixed*/
) {
  if (!hasWindow) {
    return;
  }

  window.removeEventListener(event, callback);
}

/***/ }),

/***/ "214f":
/***/ (function(module, exports, __nested_webpack_require_23785__) {

"use strict";

__nested_webpack_require_23785__("b0c5");
var redefine = __nested_webpack_require_23785__("2aba");
var hide = __nested_webpack_require_23785__("32e9");
var fails = __nested_webpack_require_23785__("79e5");
var defined = __nested_webpack_require_23785__("be13");
var wks = __nested_webpack_require_23785__("2b4c");
var regexpExec = __nested_webpack_require_23785__("520a");

var SPECIES = wks('species');

var REPLACE_SUPPORTS_NAMED_GROUPS = !fails(function () {
  // #replace needs built-in support for named groups.
  // #match works fine because it just return the exec results, even if it has
  // a "grops" property.
  var re = /./;
  re.exec = function () {
    var result = [];
    result.groups = { a: '7' };
    return result;
  };
  return ''.replace(re, '$<a>') !== '7';
});

var SPLIT_WORKS_WITH_OVERWRITTEN_EXEC = (function () {
  // Chrome 51 has a buggy "split" implementation when RegExp#exec !== nativeExec
  var re = /(?:)/;
  var originalExec = re.exec;
  re.exec = function () { return originalExec.apply(this, arguments); };
  var result = 'ab'.split(re);
  return result.length === 2 && result[0] === 'a' && result[1] === 'b';
})();

module.exports = function (KEY, length, exec) {
  var SYMBOL = wks(KEY);

  var DELEGATES_TO_SYMBOL = !fails(function () {
    // String methods call symbol-named RegEp methods
    var O = {};
    O[SYMBOL] = function () { return 7; };
    return ''[KEY](O) != 7;
  });

  var DELEGATES_TO_EXEC = DELEGATES_TO_SYMBOL ? !fails(function () {
    // Symbol-named RegExp methods call .exec
    var execCalled = false;
    var re = /a/;
    re.exec = function () { execCalled = true; return null; };
    if (KEY === 'split') {
      // RegExp[@@split] doesn't call the regex's exec method, but first creates
      // a new one. We need to return the patched regex when creating the new one.
      re.constructor = {};
      re.constructor[SPECIES] = function () { return re; };
    }
    re[SYMBOL]('');
    return !execCalled;
  }) : undefined;

  if (
    !DELEGATES_TO_SYMBOL ||
    !DELEGATES_TO_EXEC ||
    (KEY === 'replace' && !REPLACE_SUPPORTS_NAMED_GROUPS) ||
    (KEY === 'split' && !SPLIT_WORKS_WITH_OVERWRITTEN_EXEC)
  ) {
    var nativeRegExpMethod = /./[SYMBOL];
    var fns = exec(
      defined,
      SYMBOL,
      ''[KEY],
      function maybeCallNative(nativeMethod, regexp, str, arg2, forceStringMethod) {
        if (regexp.exec === regexpExec) {
          if (DELEGATES_TO_SYMBOL && !forceStringMethod) {
            // The native String method already delegates to @@method (this
            // polyfilled function), leasing to infinite recursion.
            // We avoid it by directly calling the native @@method method.
            return { done: true, value: nativeRegExpMethod.call(regexp, str, arg2) };
          }
          return { done: true, value: nativeMethod.call(str, regexp, arg2) };
        }
        return { done: false };
      }
    );
    var strfn = fns[0];
    var rxfn = fns[1];

    redefine(String.prototype, KEY, strfn);
    hide(RegExp.prototype, SYMBOL, length == 2
      // 21.2.5.8 RegExp.prototype[@@replace](string, replaceValue)
      // 21.2.5.11 RegExp.prototype[@@split](string, limit)
      ? function (string, arg) { return rxfn.call(string, this, arg); }
      // 21.2.5.6 RegExp.prototype[@@match](string)
      // 21.2.5.9 RegExp.prototype[@@search](string)
      : function (string) { return rxfn.call(string, this); }
    );
  }
};


/***/ }),

/***/ "230e":
/***/ (function(module, exports, __nested_webpack_require_27242__) {

var isObject = __nested_webpack_require_27242__("d3f4");
var document = __nested_webpack_require_27242__("7726").document;
// typeof document.createElement is 'object' in old IE
var is = isObject(document) && isObject(document.createElement);
module.exports = function (it) {
  return is ? document.createElement(it) : {};
};


/***/ }),

/***/ "2350":
/***/ (function(module, exports) {

/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/
// css base code, injected by the css-loader
module.exports = function(useSourceMap) {
	var list = [];

	// return the list of modules as css string
	list.toString = function toString() {
		return this.map(function (item) {
			var content = cssWithMappingToString(item, useSourceMap);
			if(item[2]) {
				return "@media " + item[2] + "{" + content + "}";
			} else {
				return content;
			}
		}).join("");
	};

	// import a list of modules into the list
	list.i = function(modules, mediaQuery) {
		if(typeof modules === "string")
			modules = [[null, modules, ""]];
		var alreadyImportedModules = {};
		for(var i = 0; i < this.length; i++) {
			var id = this[i][0];
			if(typeof id === "number")
				alreadyImportedModules[id] = true;
		}
		for(i = 0; i < modules.length; i++) {
			var item = modules[i];
			// skip already imported module
			// this implementation is not 100% perfect for weird media query combinations
			//  when a module is imported multiple times with different media queries.
			//  I hope this will never occur (Hey this way we have smaller bundles)
			if(typeof item[0] !== "number" || !alreadyImportedModules[item[0]]) {
				if(mediaQuery && !item[2]) {
					item[2] = mediaQuery;
				} else if(mediaQuery) {
					item[2] = "(" + item[2] + ") and (" + mediaQuery + ")";
				}
				list.push(item);
			}
		}
	};
	return list;
};

function cssWithMappingToString(item, useSourceMap) {
	var content = item[1] || '';
	var cssMapping = item[3];
	if (!cssMapping) {
		return content;
	}

	if (useSourceMap && typeof btoa === 'function') {
		var sourceMapping = toComment(cssMapping);
		var sourceURLs = cssMapping.sources.map(function (source) {
			return '/*# sourceURL=' + cssMapping.sourceRoot + source + ' */'
		});

		return [content].concat(sourceURLs).concat([sourceMapping]).join('\n');
	}

	return [content].join('\n');
}

// Adapted from convert-source-map (MIT)
function toComment(sourceMap) {
	// eslint-disable-next-line no-undef
	var base64 = btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap))));
	var data = 'sourceMappingURL=data:application/json;charset=utf-8;base64,' + base64;

	return '/*# ' + data + ' */';
}


/***/ }),

/***/ "23c6":
/***/ (function(module, exports, __nested_webpack_require_29949__) {

// getting tag from 19.1.3.6 Object.prototype.toString()
var cof = __nested_webpack_require_29949__("2d95");
var TAG = __nested_webpack_require_29949__("2b4c")('toStringTag');
// ES3 wrong here
var ARG = cof(function () { return arguments; }()) == 'Arguments';

// fallback for IE11 Script Access Denied error
var tryGet = function (it, key) {
  try {
    return it[key];
  } catch (e) { /* empty */ }
};

module.exports = function (it) {
  var O, T, B;
  return it === undefined ? 'Undefined' : it === null ? 'Null'
    // @@toStringTag case
    : typeof (T = tryGet(O = Object(it), TAG)) == 'string' ? T
    // builtinTag case
    : ARG ? cof(O)
    // ES3 arguments fallback
    : (B = cof(O)) == 'Object' && typeof O.callee == 'function' ? 'Arguments' : B;
};


/***/ }),

/***/ "2621":
/***/ (function(module, exports) {

exports.f = Object.getOwnPropertySymbols;


/***/ }),

/***/ "2877":
/***/ (function(module, __webpack_exports__, __nested_webpack_require_30888__) {

"use strict";
/* harmony export (binding) */ __nested_webpack_require_30888__.d(__webpack_exports__, "a", function() { return normalizeComponent; });
/* globals __VUE_SSR_CONTEXT__ */

// IMPORTANT: Do NOT use ES2015 features in this file (except for modules).
// This module is a runtime utility for cleaner component module output and will
// be included in the final webpack user bundle.

function normalizeComponent (
  scriptExports,
  render,
  staticRenderFns,
  functionalTemplate,
  injectStyles,
  scopeId,
  moduleIdentifier, /* server only */
  shadowMode /* vue-cli only */
) {
  // Vue.extend constructor export interop
  var options = typeof scriptExports === 'function'
    ? scriptExports.options
    : scriptExports

  // render functions
  if (render) {
    options.render = render
    options.staticRenderFns = staticRenderFns
    options._compiled = true
  }

  // functional template
  if (functionalTemplate) {
    options.functional = true
  }

  // scopedId
  if (scopeId) {
    options._scopeId = 'data-v-' + scopeId
  }

  var hook
  if (moduleIdentifier) { // server build
    hook = function (context) {
      // 2.3 injection
      context =
        context || // cached call
        (this.$vnode && this.$vnode.ssrContext) || // stateful
        (this.parent && this.parent.$vnode && this.parent.$vnode.ssrContext) // functional
      // 2.2 with runInNewContext: true
      if (!context && typeof __VUE_SSR_CONTEXT__ !== 'undefined') {
        context = __VUE_SSR_CONTEXT__
      }
      // inject component styles
      if (injectStyles) {
        injectStyles.call(this, context)
      }
      // register component module identifier for async chunk inferrence
      if (context && context._registeredComponents) {
        context._registeredComponents.add(moduleIdentifier)
      }
    }
    // used by ssr in case component is cached and beforeCreate
    // never gets called
    options._ssrRegister = hook
  } else if (injectStyles) {
    hook = shadowMode
      ? function () {
        injectStyles.call(
          this,
          (options.functional ? this.parent : this).$root.$options.shadowRoot
        )
      }
      : injectStyles
  }

  if (hook) {
    if (options.functional) {
      // for template-only hot-reload because in that case the render fn doesn't
      // go through the normalizer
      options._injectStyles = hook
      // register for functional component in vue file
      var originalRender = options.render
      options.render = function renderWithStyleInjection (h, context) {
        hook.call(context)
        return originalRender(h, context)
      }
    } else {
      // inject component registration as beforeCreate hook
      var existing = options.beforeCreate
      options.beforeCreate = existing
        ? [].concat(existing, hook)
        : [hook]
    }
  }

  return {
    exports: scriptExports,
    options: options
  }
}


/***/ }),

/***/ "2aba":
/***/ (function(module, exports, __nested_webpack_require_33865__) {

var global = __nested_webpack_require_33865__("7726");
var hide = __nested_webpack_require_33865__("32e9");
var has = __nested_webpack_require_33865__("69a8");
var SRC = __nested_webpack_require_33865__("ca5a")('src');
var $toString = __nested_webpack_require_33865__("fa5b");
var TO_STRING = 'toString';
var TPL = ('' + $toString).split(TO_STRING);

__nested_webpack_require_33865__("8378").inspectSource = function (it) {
  return $toString.call(it);
};

(module.exports = function (O, key, val, safe) {
  var isFunction = typeof val == 'function';
  if (isFunction) has(val, 'name') || hide(val, 'name', key);
  if (O[key] === val) return;
  if (isFunction) has(val, SRC) || hide(val, SRC, O[key] ? '' + O[key] : TPL.join(String(key)));
  if (O === global) {
    O[key] = val;
  } else if (!safe) {
    delete O[key];
    hide(O, key, val);
  } else if (O[key]) {
    O[key] = val;
  } else {
    hide(O, key, val);
  }
// add fake Function#toString for correct work wrapped methods / constructors with methods like LoDash isNative
})(Function.prototype, TO_STRING, function toString() {
  return typeof this == 'function' && this[SRC] || $toString.call(this);
});


/***/ }),

/***/ "2aeb":
/***/ (function(module, exports, __nested_webpack_require_35039__) {

// 19.1.2.2 / 15.2.3.5 Object.create(O [, Properties])
var anObject = __nested_webpack_require_35039__("cb7c");
var dPs = __nested_webpack_require_35039__("1495");
var enumBugKeys = __nested_webpack_require_35039__("e11e");
var IE_PROTO = __nested_webpack_require_35039__("613b")('IE_PROTO');
var Empty = function () { /* empty */ };
var PROTOTYPE = 'prototype';

// Create object with fake `null` prototype: use iframe Object with cleared prototype
var createDict = function () {
  // Thrash, waste and sodomy: IE GC bug
  var iframe = __nested_webpack_require_35039__("230e")('iframe');
  var i = enumBugKeys.length;
  var lt = '<';
  var gt = '>';
  var iframeDocument;
  iframe.style.display = 'none';
  __nested_webpack_require_35039__("fab2").appendChild(iframe);
  iframe.src = 'javascript:'; // eslint-disable-line no-script-url
  // createDict = iframe.contentWindow.Object;
  // html.removeChild(iframe);
  iframeDocument = iframe.contentWindow.document;
  iframeDocument.open();
  iframeDocument.write(lt + 'script' + gt + 'document.F=Object' + lt + '/script' + gt);
  iframeDocument.close();
  createDict = iframeDocument.F;
  while (i--) delete createDict[PROTOTYPE][enumBugKeys[i]];
  return createDict();
};

module.exports = Object.create || function create(O, Properties) {
  var result;
  if (O !== null) {
    Empty[PROTOTYPE] = anObject(O);
    result = new Empty();
    Empty[PROTOTYPE] = null;
    // add "__proto__" for Object.getPrototypeOf polyfill
    result[IE_PROTO] = O;
  } else result = createDict();
  return Properties === undefined ? result : dPs(result, Properties);
};


/***/ }),

/***/ "2af9":
/***/ (function(module, __webpack_exports__, __nested_webpack_require_36662__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(global) {/* harmony export (binding) */ __nested_webpack_require_36662__.d(__webpack_exports__, "d", function() { return install; });
/* harmony import */ var core_js_modules_es6_function_name__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_36662__("7f7f");
/* harmony import */ var core_js_modules_es6_function_name__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__nested_webpack_require_36662__.n(core_js_modules_es6_function_name__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var core_js_modules_es6_array_iterator__WEBPACK_IMPORTED_MODULE_1__ = __nested_webpack_require_36662__("cadf");
/* harmony import */ var core_js_modules_es6_array_iterator__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__nested_webpack_require_36662__.n(core_js_modules_es6_array_iterator__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var core_js_modules_es6_object_keys__WEBPACK_IMPORTED_MODULE_2__ = __nested_webpack_require_36662__("456d");
/* harmony import */ var core_js_modules_es6_object_keys__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__nested_webpack_require_36662__.n(core_js_modules_es6_object_keys__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var core_js_modules_web_dom_iterable__WEBPACK_IMPORTED_MODULE_3__ = __nested_webpack_require_36662__("ac6a");
/* harmony import */ var core_js_modules_web_dom_iterable__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__nested_webpack_require_36662__.n(core_js_modules_web_dom_iterable__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var _GridItem_vue__WEBPACK_IMPORTED_MODULE_4__ = __nested_webpack_require_36662__("bc21");
/* harmony reexport (safe) */ __nested_webpack_require_36662__.d(__webpack_exports__, "a", function() { return _GridItem_vue__WEBPACK_IMPORTED_MODULE_4__["a"]; });

/* harmony import */ var _GridLayout_vue__WEBPACK_IMPORTED_MODULE_5__ = __nested_webpack_require_36662__("37c8");
/* harmony reexport (safe) */ __nested_webpack_require_36662__.d(__webpack_exports__, "b", function() { return _GridLayout_vue__WEBPACK_IMPORTED_MODULE_5__["a"]; });






 // import ResponsiveGridLayout from './ResponsiveGridLayout.vue';

var VueGridLayout = {
  // ResponsiveGridLayout,
  GridLayout: _GridLayout_vue__WEBPACK_IMPORTED_MODULE_5__[/* default */ "a"],
  GridItem: _GridItem_vue__WEBPACK_IMPORTED_MODULE_4__[/* default */ "a"]
};
function install(Vue) {
  if (install.installed) return;
  install.installed = true;
  Object.keys(VueGridLayout).forEach(function (name) {
    Vue.component(name, VueGridLayout[name]);
  });
}
var plugin = {
  install: install
};
var GlobalVue = null;

if (typeof window !== 'undefined') {
  GlobalVue = window.Vue;
} else if (typeof global !== 'undefined') {
  GlobalVue = global.Vue;
}

if (GlobalVue) {
  GlobalVue.use(plugin);
}

/* harmony default export */ __webpack_exports__["c"] = (VueGridLayout);

/* WEBPACK VAR INJECTION */}.call(this, __nested_webpack_require_36662__("c8ba")))

/***/ }),

/***/ "2b4c":
/***/ (function(module, exports, __nested_webpack_require_39542__) {

var store = __nested_webpack_require_39542__("5537")('wks');
var uid = __nested_webpack_require_39542__("ca5a");
var Symbol = __nested_webpack_require_39542__("7726").Symbol;
var USE_SYMBOL = typeof Symbol == 'function';

var $exports = module.exports = function (name) {
  return store[name] || (store[name] =
    USE_SYMBOL && Symbol[name] || (USE_SYMBOL ? Symbol : uid)('Symbol.' + name));
};

$exports.store = store;


/***/ }),

/***/ "2cef":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = function() {
    var idCount = 1;

    /**
     * Generates a new unique id in the context.
     * @public
     * @returns {number} A unique id in the context.
     */
    function generate() {
        return idCount++;
    }

    return {
        generate: generate
    };
};


/***/ }),

/***/ "2d00":
/***/ (function(module, exports) {

module.exports = false;


/***/ }),

/***/ "2d95":
/***/ (function(module, exports) {

var toString = {}.toString;

module.exports = function (it) {
  return toString.call(it).slice(8, -1);
};


/***/ }),

/***/ "2f21":
/***/ (function(module, exports, __nested_webpack_require_40658__) {

"use strict";

var fails = __nested_webpack_require_40658__("79e5");

module.exports = function (method, arg) {
  return !!method && fails(function () {
    // eslint-disable-next-line no-useless-call
    arg ? method.call(null, function () { /* empty */ }, 1) : method.call(null);
  });
};


/***/ }),

/***/ "32e9":
/***/ (function(module, exports, __nested_webpack_require_41020__) {

var dP = __nested_webpack_require_41020__("86cc");
var createDesc = __nested_webpack_require_41020__("4630");
module.exports = __nested_webpack_require_41020__("9e1e") ? function (object, key, value) {
  return dP.f(object, key, createDesc(1, value));
} : function (object, key, value) {
  object[key] = value;
  return object;
};


/***/ }),

/***/ "37c8":
/***/ (function(module, __webpack_exports__, __nested_webpack_require_41408__) {

"use strict";

// CONCATENATED MODULE: ./node_modules/cache-loader/dist/cjs.js?{"cacheDirectory":"node_modules/.cache/vue-loader","cacheIdentifier":"048e26c0-vue-loader-template"}!./node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!./node_modules/cache-loader/dist/cjs.js??ref--0-0!./node_modules/vue-loader/lib??vue-loader-options!./src/components/GridLayout.vue?vue&type=template&id=db3b5a1c&
var render = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('div',{ref:"item",staticClass:"vue-grid-layout",style:(_vm.mergedStyle)},[_vm._t("default"),_c('grid-item',{directives:[{name:"show",rawName:"v-show",value:(_vm.isDragging),expression:"isDragging"}],staticClass:"vue-grid-placeholder",attrs:{"x":_vm.placeholder.x,"y":_vm.placeholder.y,"w":_vm.placeholder.w,"h":_vm.placeholder.h,"i":_vm.placeholder.i}})],2)}
var staticRenderFns = []


// CONCATENATED MODULE: ./src/components/GridLayout.vue?vue&type=template&id=db3b5a1c&

// EXTERNAL MODULE: ./node_modules/core-js/modules/es7.object.get-own-property-descriptors.js
var es7_object_get_own_property_descriptors = __nested_webpack_require_41408__("8e6e");

// EXTERNAL MODULE: ./node_modules/core-js/modules/es6.array.iterator.js
var es6_array_iterator = __nested_webpack_require_41408__("cadf");

// EXTERNAL MODULE: ./node_modules/core-js/modules/es6.object.keys.js
var es6_object_keys = __nested_webpack_require_41408__("456d");

// EXTERNAL MODULE: ./node_modules/core-js/modules/es6.object.assign.js
var es6_object_assign = __nested_webpack_require_41408__("f751");

// EXTERNAL MODULE: ./node_modules/core-js/modules/es6.number.is-finite.js
var es6_number_is_finite = __nested_webpack_require_41408__("fca0");

// EXTERNAL MODULE: ./node_modules/core-js/modules/web.dom.iterable.js
var web_dom_iterable = __nested_webpack_require_41408__("ac6a");

// CONCATENATED MODULE: ./node_modules/@babel/runtime/helpers/esm/defineProperty.js
function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}
// EXTERNAL MODULE: ./node_modules/core-js/modules/es6.number.constructor.js
var es6_number_constructor = __nested_webpack_require_41408__("c5f6");

// EXTERNAL MODULE: external {"commonjs":"vue","commonjs2":"vue","root":"Vue"}
var external_commonjs_vue_commonjs2_vue_root_Vue_ = __nested_webpack_require_41408__("8bbf");
var external_commonjs_vue_commonjs2_vue_root_Vue_default = /*#__PURE__*/__nested_webpack_require_41408__.n(external_commonjs_vue_commonjs2_vue_root_Vue_);

// EXTERNAL MODULE: ./src/helpers/utils.js
var utils = __nested_webpack_require_41408__("a2b6");

// EXTERNAL MODULE: ./src/helpers/responsiveUtils.js
var responsiveUtils = __nested_webpack_require_41408__("97a7");

// EXTERNAL MODULE: ./src/components/GridItem.vue + 69 modules
var GridItem = __nested_webpack_require_41408__("bc21");

// EXTERNAL MODULE: ./src/helpers/DOM.js
var DOM = __nested_webpack_require_41408__("1ca7");

// CONCATENATED MODULE: ./node_modules/cache-loader/dist/cjs.js??ref--12-0!./node_modules/thread-loader/dist/cjs.js!./node_modules/babel-loader/lib!./node_modules/cache-loader/dist/cjs.js??ref--0-0!./node_modules/vue-loader/lib??vue-loader-options!./src/components/GridLayout.vue?vue&type=script&lang=js&









function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//


var elementResizeDetectorMaker = __nested_webpack_require_41408__("eec4");


 //var eventBus = require('./eventBus');



/* harmony default export */ var GridLayoutvue_type_script_lang_js_ = ({
  name: "GridLayout",
  provide: function provide() {
    return {
      eventBus: null,
      layout: this
    };
  },
  components: {
    GridItem: GridItem["a" /* default */]
  },
  props: {
    // If true, the container height swells and contracts to fit contents
    autoSize: {
      type: Boolean,
      default: true
    },
    colNum: {
      type: Number,
      default: 12
    },
    rowHeight: {
      type: Number,
      default: 150
    },
    maxRows: {
      type: Number,
      default: Infinity
    },
    margin: {
      type: Array,
      default: function _default() {
        return [10, 10];
      }
    },
    isDraggable: {
      type: Boolean,
      default: true
    },
    isResizable: {
      type: Boolean,
      default: true
    },
    isMirrored: {
      type: Boolean,
      default: false
    },
    useCssTransforms: {
      type: Boolean,
      default: true
    },
    verticalCompact: {
      type: Boolean,
      default: true
    },
    layout: {
      type: Array,
      required: true
    },
    responsive: {
      type: Boolean,
      default: false
    },
    responsiveLayouts: {
      type: Object,
      default: function _default() {
        return {};
      }
    },
    breakpoints: {
      type: Object,
      default: function _default() {
        return {
          lg: 1200,
          md: 996,
          sm: 768,
          xs: 480,
          xxs: 0
        };
      }
    },
    cols: {
      type: Object,
      default: function _default() {
        return {
          lg: 12,
          md: 10,
          sm: 6,
          xs: 4,
          xxs: 2
        };
      }
    },
    preventCollision: {
      type: Boolean,
      default: false
    },
    useStyleCursor: {
      type: Boolean,
      default: true
    }
  },
  data: function data() {
    return {
      width: null,
      mergedStyle: {},
      lastLayoutLength: 0,
      isDragging: false,
      placeholder: {
        x: 0,
        y: 0,
        w: 0,
        h: 0,
        i: -1
      },
      layouts: {},
      // array to store all layouts from different breakpoints
      lastBreakpoint: null,
      // store last active breakpoint
      originalLayout: null // store original Layout

    };
  },
  created: function created() {
    var self = this; // Accessible refernces of functions for removing in beforeDestroy

    self.resizeEventHandler = function (eventType, i, x, y, h, w) {
      self.resizeEvent(eventType, i, x, y, h, w);
    };

    self.dragEventHandler = function (eventType, i, x, y, h, w) {
      self.dragEvent(eventType, i, x, y, h, w);
    };

    self._provided.eventBus = new external_commonjs_vue_commonjs2_vue_root_Vue_default.a();
    self.eventBus = self._provided.eventBus;
    self.eventBus.$on('resizeEvent', self.resizeEventHandler);
    self.eventBus.$on('dragEvent', self.dragEventHandler);
    self.$emit('layout-created', self.layout);
  },
  beforeDestroy: function beforeDestroy() {
    //Remove listeners
    this.eventBus.$off('resizeEvent', this.resizeEventHandler);
    this.eventBus.$off('dragEvent', this.dragEventHandler);
    this.eventBus.$destroy();
    Object(DOM["c" /* removeWindowEventListener */])("resize", this.onWindowResize);

    if (this.erd) {
      this.erd.uninstall(this.$refs.item);
    }
  },
  beforeMount: function beforeMount() {
    this.$emit('layout-before-mount', this.layout);
  },
  mounted: function mounted() {
    this.$emit('layout-mounted', this.layout);
    this.$nextTick(function () {
      Object(utils["l" /* validateLayout */])(this.layout);
      this.originalLayout = this.layout;
      var self = this;
      this.$nextTick(function () {
        self.onWindowResize();
        self.initResponsiveFeatures(); //self.width = self.$el.offsetWidth;

        Object(DOM["a" /* addWindowEventListener */])('resize', self.onWindowResize);
        Object(utils["c" /* compact */])(self.layout, self.verticalCompact);
        self.$emit('layout-updated', self.layout);
        self.updateHeight();
        self.$nextTick(function () {
          this.erd = elementResizeDetectorMaker({
            strategy: "scroll",
            //<- For ultra performance.
            // See https://github.com/wnr/element-resize-detector/issues/110 about callOnAdd.
            callOnAdd: false
          });
          this.erd.listenTo(self.$refs.item, function () {
            self.onWindowResize();
          });
        });
      });
    });
  },
  watch: {
    width: function width(newval, oldval) {
      var self = this;
      this.$nextTick(function () {
        var _this = this;

        //this.$broadcast("updateWidth", this.width);
        this.eventBus.$emit("updateWidth", this.width);

        if (oldval === null) {
          /*
              If oldval == null is when the width has never been
              set before. That only occurs when mouting is
              finished, and onWindowResize has been called and
              this.width has been changed the first time after it
              got set to null in the constructor. It is now time
              to issue layout-ready events as the GridItems have
              their sizes configured properly.
               The reason for emitting the layout-ready events on
              the next tick is to allow for the newly-emitted
              updateWidth event (above) to have reached the
              children GridItem-s and had their effect, so we're
              sure that they have the final size before we emit
              layout-ready (for this GridLayout) and
              item-layout-ready (for the GridItem-s).
               This way any client event handlers can reliably
              invistigate stable sizes of GridItem-s.
          */
          this.$nextTick(function () {
            _this.$emit('layout-ready', self.layout);
          });
        }

        this.updateHeight();
      });
    },
    layout: function layout() {
      this.layoutUpdate();
    },
    colNum: function colNum(val) {
      this.eventBus.$emit("setColNum", val);
    },
    rowHeight: function rowHeight() {
      this.eventBus.$emit("setRowHeight", this.rowHeight);
    },
    isDraggable: function isDraggable() {
      this.eventBus.$emit("setDraggable", this.isDraggable);
    },
    isResizable: function isResizable() {
      this.eventBus.$emit("setResizable", this.isResizable);
    },
    responsive: function responsive() {
      if (!this.responsive) {
        this.$emit('update:layout', this.originalLayout);
        this.eventBus.$emit("setColNum", this.colNum);
      }

      this.onWindowResize();
    },
    maxRows: function maxRows() {
      this.eventBus.$emit("setMaxRows", this.maxRows);
    },
    margin: function margin() {
      this.updateHeight();
    }
  },
  methods: {
    layoutUpdate: function layoutUpdate() {
      if (this.layout !== undefined && this.originalLayout !== null) {
        if (this.layout.length !== this.originalLayout.length) {
          // console.log("### LAYOUT UPDATE!", this.layout.length, this.originalLayout.length);
          var diff = this.findDifference(this.layout, this.originalLayout);

          if (diff.length > 0) {
            // console.log(diff);
            if (this.layout.length > this.originalLayout.length) {
              this.originalLayout = this.originalLayout.concat(diff);
            } else {
              this.originalLayout = this.originalLayout.filter(function (obj) {
                return !diff.some(function (obj2) {
                  return obj.i === obj2.i;
                });
              });
            }
          }

          this.lastLayoutLength = this.layout.length;
          this.initResponsiveFeatures();
        }

        Object(utils["c" /* compact */])(this.layout, this.verticalCompact);
        this.eventBus.$emit("updateWidth", this.width);
        this.updateHeight();
        this.$emit('layout-updated', this.layout);
      }
    },
    updateHeight: function updateHeight() {
      this.mergedStyle = {
        height: this.containerHeight()
      };
    },
    onWindowResize: function onWindowResize() {
      if (this.$refs !== null && this.$refs.item !== null && this.$refs.item !== undefined) {
        this.width = this.$refs.item.offsetWidth;
      }

      this.eventBus.$emit("resizeEvent");
    },
    containerHeight: function containerHeight() {
      if (!this.autoSize) return; // console.log("bottom: " + bottom(this.layout))
      // console.log("rowHeight + margins: " + (this.rowHeight + this.margin[1]) + this.margin[1])

      var containerHeight = Object(utils["a" /* bottom */])(this.layout) * (this.rowHeight + this.margin[1]) + this.margin[1] + 'px';
      return containerHeight;
    },
    dragEvent: function dragEvent(eventName, id, x, y, h, w) {
      //console.log(eventName + " id=" + id + ", x=" + x + ", y=" + y);
      var l = Object(utils["f" /* getLayoutItem */])(this.layout, id); //GetLayoutItem sometimes returns null object

      if (l === undefined || l === null) {
        l = {
          x: 0,
          y: 0
        };
      }

      if (eventName === "dragmove" || eventName === "dragstart") {
        this.placeholder.i = id;
        this.placeholder.x = l.x;
        this.placeholder.y = l.y;
        this.placeholder.w = w;
        this.placeholder.h = h;
        this.$nextTick(function () {
          this.isDragging = true;
        }); //this.$broadcast("updateWidth", this.width);

        this.eventBus.$emit("updateWidth", this.width);
      } else {
        this.$nextTick(function () {
          this.isDragging = false;
        });
      } // Move the element to the dragged location.


      this.layout = Object(utils["g" /* moveElement */])(this.layout, l, x, y, true, this.preventCollision);
      Object(utils["c" /* compact */])(this.layout, this.verticalCompact); // needed because vue can't detect changes on array element properties

      this.eventBus.$emit("compact");
      this.updateHeight();
      if (eventName === 'dragend') this.$emit('layout-updated', this.layout);
    },
    resizeEvent: function resizeEvent(eventName, id, x, y, h, w) {
      var l = Object(utils["f" /* getLayoutItem */])(this.layout, id); //GetLayoutItem sometimes return null object

      if (l === undefined || l === null) {
        l = {
          h: 0,
          w: 0
        };
      }

      var hasCollisions;

      if (this.preventCollision) {
        var collisions = Object(utils["e" /* getAllCollisions */])(this.layout, _objectSpread(_objectSpread({}, l), {}, {
          w: w,
          h: h
        })).filter(function (layoutItem) {
          return layoutItem.i !== l.i;
        });
        hasCollisions = collisions.length > 0; // If we're colliding, we need adjust the placeholder.

        if (hasCollisions) {
          // adjust w && h to maximum allowed space
          var leastX = Infinity,
              leastY = Infinity;
          collisions.forEach(function (layoutItem) {
            if (layoutItem.x > l.x) leastX = Math.min(leastX, layoutItem.x);
            if (layoutItem.y > l.y) leastY = Math.min(leastY, layoutItem.y);
          });
          if (Number.isFinite(leastX)) l.w = leastX - l.x;
          if (Number.isFinite(leastY)) l.h = leastY - l.y;
        }
      }

      if (!hasCollisions) {
        // Set new width and height.
        l.w = w;
        l.h = h;
      }

      if (eventName === "resizestart" || eventName === "resizemove") {
        this.placeholder.i = id;
        this.placeholder.x = x;
        this.placeholder.y = y;
        this.placeholder.w = l.w;
        this.placeholder.h = l.h;
        this.$nextTick(function () {
          this.isDragging = true;
        }); //this.$broadcast("updateWidth", this.width);

        this.eventBus.$emit("updateWidth", this.width);
      } else {
        this.$nextTick(function () {
          this.isDragging = false;
        });
      }

      if (this.responsive) this.responsiveGridLayout();
      Object(utils["c" /* compact */])(this.layout, this.verticalCompact);
      this.eventBus.$emit("compact");
      this.updateHeight();
      if (eventName === 'resizeend') this.$emit('layout-updated', this.layout);
    },
    // finds or generates new layouts for set breakpoints
    responsiveGridLayout: function responsiveGridLayout() {
      var newBreakpoint = Object(responsiveUtils["b" /* getBreakpointFromWidth */])(this.breakpoints, this.width);
      var newCols = Object(responsiveUtils["c" /* getColsFromBreakpoint */])(newBreakpoint, this.cols); // save actual layout in layouts

      if (this.lastBreakpoint != null && !this.layouts[this.lastBreakpoint]) this.layouts[this.lastBreakpoint] = Object(utils["b" /* cloneLayout */])(this.layout); // Find or generate a new layout.

      var layout = Object(responsiveUtils["a" /* findOrGenerateResponsiveLayout */])(this.originalLayout, this.layouts, this.breakpoints, newBreakpoint, this.lastBreakpoint, newCols, this.verticalCompact); // Store the new layout.

      this.layouts[newBreakpoint] = layout;

      if (this.lastBreakpoint !== newBreakpoint) {
        this.$emit('breakpoint-changed', newBreakpoint, layout);
      } // new prop sync


      this.$emit('update:layout', layout);
      this.lastBreakpoint = newBreakpoint;
      this.eventBus.$emit("setColNum", Object(responsiveUtils["c" /* getColsFromBreakpoint */])(newBreakpoint, this.cols));
    },
    // clear all responsive layouts
    initResponsiveFeatures: function initResponsiveFeatures() {
      // clear layouts
      this.layouts = Object.assign({}, this.responsiveLayouts);
    },
    // find difference in layouts
    findDifference: function findDifference(layout, originalLayout) {
      //Find values that are in result1 but not in result2
      var uniqueResultOne = layout.filter(function (obj) {
        return !originalLayout.some(function (obj2) {
          return obj.i === obj2.i;
        });
      }); //Find values that are in result2 but not in result1

      var uniqueResultTwo = originalLayout.filter(function (obj) {
        return !layout.some(function (obj2) {
          return obj.i === obj2.i;
        });
      }); //Combine the two arrays of unique entries#

      return uniqueResultOne.concat(uniqueResultTwo);
    }
  }
});
// CONCATENATED MODULE: ./src/components/GridLayout.vue?vue&type=script&lang=js&
 /* harmony default export */ var components_GridLayoutvue_type_script_lang_js_ = (GridLayoutvue_type_script_lang_js_); 
// EXTERNAL MODULE: ./src/components/GridLayout.vue?vue&type=style&index=0&lang=css&
var GridLayoutvue_type_style_index_0_lang_css_ = __nested_webpack_require_41408__("e279");

// EXTERNAL MODULE: ./node_modules/vue-loader/lib/runtime/componentNormalizer.js
var componentNormalizer = __nested_webpack_require_41408__("2877");

// CONCATENATED MODULE: ./src/components/GridLayout.vue






/* normalize component */

var component = Object(componentNormalizer["a" /* default */])(
  components_GridLayoutvue_type_script_lang_js_,
  render,
  staticRenderFns,
  false,
  null,
  null,
  null
  
)

/* harmony default export */ var GridLayout = __webpack_exports__["a"] = (component.exports);

/***/ }),

/***/ "38fd":
/***/ (function(module, exports, __nested_webpack_require_60978__) {

// 19.1.2.9 / 15.2.3.2 Object.getPrototypeOf(O)
var has = __nested_webpack_require_60978__("69a8");
var toObject = __nested_webpack_require_60978__("4bf8");
var IE_PROTO = __nested_webpack_require_60978__("613b")('IE_PROTO');
var ObjectProto = Object.prototype;

module.exports = Object.getPrototypeOf || function (O) {
  O = toObject(O);
  if (has(O, IE_PROTO)) return O[IE_PROTO];
  if (typeof O.constructor == 'function' && O instanceof O.constructor) {
    return O.constructor.prototype;
  } return O instanceof Object ? ObjectProto : null;
};


/***/ }),

/***/ "41a0":
/***/ (function(module, exports, __nested_webpack_require_61572__) {

"use strict";

var create = __nested_webpack_require_61572__("2aeb");
var descriptor = __nested_webpack_require_61572__("4630");
var setToStringTag = __nested_webpack_require_61572__("7f20");
var IteratorPrototype = {};

// 25.1.2.1.1 %IteratorPrototype%[@@iterator]()
__nested_webpack_require_61572__("32e9")(IteratorPrototype, __nested_webpack_require_61572__("2b4c")('iterator'), function () { return this; });

module.exports = function (Constructor, NAME, next) {
  Constructor.prototype = create(IteratorPrototype, { next: descriptor(1, next) });
  setToStringTag(Constructor, NAME + ' Iterator');
};


/***/ }),

/***/ "456d":
/***/ (function(module, exports, __nested_webpack_require_62198__) {

// 19.1.2.14 Object.keys(O)
var toObject = __nested_webpack_require_62198__("4bf8");
var $keys = __nested_webpack_require_62198__("0d58");

__nested_webpack_require_62198__("5eda")('keys', function () {
  return function keys(it) {
    return $keys(toObject(it));
  };
});


/***/ }),

/***/ "4588":
/***/ (function(module, exports) {

// 7.1.4 ToInteger
var ceil = Math.ceil;
var floor = Math.floor;
module.exports = function (it) {
  return isNaN(it = +it) ? 0 : (it > 0 ? floor : ceil)(it);
};


/***/ }),

/***/ "4630":
/***/ (function(module, exports) {

module.exports = function (bitmap, value) {
  return {
    enumerable: !(bitmap & 1),
    configurable: !(bitmap & 2),
    writable: !(bitmap & 4),
    value: value
  };
};


/***/ }),

/***/ "4917":
/***/ (function(module, exports, __nested_webpack_require_62976__) {

"use strict";


var anObject = __nested_webpack_require_62976__("cb7c");
var toLength = __nested_webpack_require_62976__("9def");
var advanceStringIndex = __nested_webpack_require_62976__("0390");
var regExpExec = __nested_webpack_require_62976__("5f1b");

// @@match logic
__nested_webpack_require_62976__("214f")('match', 1, function (defined, MATCH, $match, maybeCallNative) {
  return [
    // `String.prototype.match` method
    // https://tc39.github.io/ecma262/#sec-string.prototype.match
    function match(regexp) {
      var O = defined(this);
      var fn = regexp == undefined ? undefined : regexp[MATCH];
      return fn !== undefined ? fn.call(regexp, O) : new RegExp(regexp)[MATCH](String(O));
    },
    // `RegExp.prototype[@@match]` method
    // https://tc39.github.io/ecma262/#sec-regexp.prototype-@@match
    function (regexp) {
      var res = maybeCallNative($match, regexp, this);
      if (res.done) return res.value;
      var rx = anObject(regexp);
      var S = String(this);
      if (!rx.global) return regExpExec(rx, S);
      var fullUnicode = rx.unicode;
      rx.lastIndex = 0;
      var A = [];
      var n = 0;
      var result;
      while ((result = regExpExec(rx, S)) !== null) {
        var matchStr = String(result[0]);
        A[n] = matchStr;
        if (matchStr === '') rx.lastIndex = advanceStringIndex(S, toLength(rx.lastIndex), fullUnicode);
        n++;
      }
      return n === 0 ? null : A;
    }
  ];
});


/***/ }),

/***/ "499e":
/***/ (function(module, __webpack_exports__, __nested_webpack_require_64466__) {

"use strict";
// ESM COMPAT FLAG
__nested_webpack_require_64466__.r(__webpack_exports__);

// EXPORTS
__nested_webpack_require_64466__.d(__webpack_exports__, "default", function() { return /* binding */ addStylesClient; });

// CONCATENATED MODULE: ./node_modules/vue-style-loader/lib/listToStyles.js
/**
 * Translates the list format produced by css-loader into something
 * easier to manipulate.
 */
function listToStyles (parentId, list) {
  var styles = []
  var newStyles = {}
  for (var i = 0; i < list.length; i++) {
    var item = list[i]
    var id = item[0]
    var css = item[1]
    var media = item[2]
    var sourceMap = item[3]
    var part = {
      id: parentId + ':' + i,
      css: css,
      media: media,
      sourceMap: sourceMap
    }
    if (!newStyles[id]) {
      styles.push(newStyles[id] = { id: id, parts: [part] })
    } else {
      newStyles[id].parts.push(part)
    }
  }
  return styles
}

// CONCATENATED MODULE: ./node_modules/vue-style-loader/lib/addStylesClient.js
/*
  MIT License http://www.opensource.org/licenses/mit-license.php
  Author Tobias Koppers @sokra
  Modified by Evan You @yyx990803
*/



var hasDocument = typeof document !== 'undefined'

if (typeof DEBUG !== 'undefined' && DEBUG) {
  if (!hasDocument) {
    throw new Error(
    'vue-style-loader cannot be used in a non-browser environment. ' +
    "Use { target: 'node' } in your Webpack config to indicate a server-rendering environment."
  ) }
}

/*
type StyleObject = {
  id: number;
  parts: Array<StyleObjectPart>
}

type StyleObjectPart = {
  css: string;
  media: string;
  sourceMap: ?string
}
*/

var stylesInDom = {/*
  [id: number]: {
    id: number,
    refs: number,
    parts: Array<(obj?: StyleObjectPart) => void>
  }
*/}

var head = hasDocument && (document.head || document.getElementsByTagName('head')[0])
var singletonElement = null
var singletonCounter = 0
var isProduction = false
var noop = function () {}
var options = null
var ssrIdKey = 'data-vue-ssr-id'

// Force single-tag solution on IE6-9, which has a hard limit on the # of <style>
// tags it will allow on a page
var isOldIE = typeof navigator !== 'undefined' && /msie [6-9]\b/.test(navigator.userAgent.toLowerCase())

function addStylesClient (parentId, list, _isProduction, _options) {
  isProduction = _isProduction

  options = _options || {}

  var styles = listToStyles(parentId, list)
  addStylesToDom(styles)

  return function update (newList) {
    var mayRemove = []
    for (var i = 0; i < styles.length; i++) {
      var item = styles[i]
      var domStyle = stylesInDom[item.id]
      domStyle.refs--
      mayRemove.push(domStyle)
    }
    if (newList) {
      styles = listToStyles(parentId, newList)
      addStylesToDom(styles)
    } else {
      styles = []
    }
    for (var i = 0; i < mayRemove.length; i++) {
      var domStyle = mayRemove[i]
      if (domStyle.refs === 0) {
        for (var j = 0; j < domStyle.parts.length; j++) {
          domStyle.parts[j]()
        }
        delete stylesInDom[domStyle.id]
      }
    }
  }
}

function addStylesToDom (styles /* Array<StyleObject> */) {
  for (var i = 0; i < styles.length; i++) {
    var item = styles[i]
    var domStyle = stylesInDom[item.id]
    if (domStyle) {
      domStyle.refs++
      for (var j = 0; j < domStyle.parts.length; j++) {
        domStyle.parts[j](item.parts[j])
      }
      for (; j < item.parts.length; j++) {
        domStyle.parts.push(addStyle(item.parts[j]))
      }
      if (domStyle.parts.length > item.parts.length) {
        domStyle.parts.length = item.parts.length
      }
    } else {
      var parts = []
      for (var j = 0; j < item.parts.length; j++) {
        parts.push(addStyle(item.parts[j]))
      }
      stylesInDom[item.id] = { id: item.id, refs: 1, parts: parts }
    }
  }
}

function createStyleElement () {
  var styleElement = document.createElement('style')
  styleElement.type = 'text/css'
  head.appendChild(styleElement)
  return styleElement
}

function addStyle (obj /* StyleObjectPart */) {
  var update, remove
  var styleElement = document.querySelector('style[' + ssrIdKey + '~="' + obj.id + '"]')

  if (styleElement) {
    if (isProduction) {
      // has SSR styles and in production mode.
      // simply do nothing.
      return noop
    } else {
      // has SSR styles but in dev mode.
      // for some reason Chrome can't handle source map in server-rendered
      // style tags - source maps in <style> only works if the style tag is
      // created and inserted dynamically. So we remove the server rendered
      // styles and inject new ones.
      styleElement.parentNode.removeChild(styleElement)
    }
  }

  if (isOldIE) {
    // use singleton mode for IE9.
    var styleIndex = singletonCounter++
    styleElement = singletonElement || (singletonElement = createStyleElement())
    update = applyToSingletonTag.bind(null, styleElement, styleIndex, false)
    remove = applyToSingletonTag.bind(null, styleElement, styleIndex, true)
  } else {
    // use multi-style-tag mode in all other cases
    styleElement = createStyleElement()
    update = applyToTag.bind(null, styleElement)
    remove = function () {
      styleElement.parentNode.removeChild(styleElement)
    }
  }

  update(obj)

  return function updateStyle (newObj /* StyleObjectPart */) {
    if (newObj) {
      if (newObj.css === obj.css &&
          newObj.media === obj.media &&
          newObj.sourceMap === obj.sourceMap) {
        return
      }
      update(obj = newObj)
    } else {
      remove()
    }
  }
}

var replaceText = (function () {
  var textStore = []

  return function (index, replacement) {
    textStore[index] = replacement
    return textStore.filter(Boolean).join('\n')
  }
})()

function applyToSingletonTag (styleElement, index, remove, obj) {
  var css = remove ? '' : obj.css

  if (styleElement.styleSheet) {
    styleElement.styleSheet.cssText = replaceText(index, css)
  } else {
    var cssNode = document.createTextNode(css)
    var childNodes = styleElement.childNodes
    if (childNodes[index]) styleElement.removeChild(childNodes[index])
    if (childNodes.length) {
      styleElement.insertBefore(cssNode, childNodes[index])
    } else {
      styleElement.appendChild(cssNode)
    }
  }
}

function applyToTag (styleElement, obj) {
  var css = obj.css
  var media = obj.media
  var sourceMap = obj.sourceMap

  if (media) {
    styleElement.setAttribute('media', media)
  }
  if (options.ssrId) {
    styleElement.setAttribute(ssrIdKey, obj.id)
  }

  if (sourceMap) {
    // https://developer.chrome.com/devtools/docs/javascript-debugging
    // this makes source maps inside style tags work properly in Chrome
    css += '\n/*# sourceURL=' + sourceMap.sources[0] + ' */'
    // http://stackoverflow.com/a/26603875
    css += '\n/*# sourceMappingURL=data:application/json;base64,' + btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap)))) + ' */'
  }

  if (styleElement.styleSheet) {
    styleElement.styleSheet.cssText = css
  } else {
    while (styleElement.firstChild) {
      styleElement.removeChild(styleElement.firstChild)
    }
    styleElement.appendChild(document.createTextNode(css))
  }
}


/***/ }),

/***/ "49ad":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = function(idHandler) {
    var eventListeners = {};

    /**
     * Gets all listeners for the given element.
     * @public
     * @param {element} element The element to get all listeners for.
     * @returns All listeners for the given element.
     */
    function getListeners(element) {
        var id = idHandler.get(element);

        if (id === undefined) {
            return [];
        }

        return eventListeners[id] || [];
    }

    /**
     * Stores the given listener for the given element. Will not actually add the listener to the element.
     * @public
     * @param {element} element The element that should have the listener added.
     * @param {function} listener The callback that the element has added.
     */
    function addListener(element, listener) {
        var id = idHandler.get(element);

        if(!eventListeners[id]) {
            eventListeners[id] = [];
        }

        eventListeners[id].push(listener);
    }

    function removeListener(element, listener) {
        var listeners = getListeners(element);
        for (var i = 0, len = listeners.length; i < len; ++i) {
            if (listeners[i] === listener) {
              listeners.splice(i, 1);
              break;
            }
        }
    }

    function removeAllListeners(element) {
      var listeners = getListeners(element);
      if (!listeners) { return; }
      listeners.length = 0;
    }

    return {
        get: getListeners,
        add: addListener,
        removeListener: removeListener,
        removeAllListeners: removeAllListeners
    };
};


/***/ }),

/***/ "4bf8":
/***/ (function(module, exports, __nested_webpack_require_73397__) {

// 7.1.13 ToObject(argument)
var defined = __nested_webpack_require_73397__("be13");
module.exports = function (it) {
  return Object(defined(it));
};


/***/ }),

/***/ "5058":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = function(options) {
    var idGenerator     = options.idGenerator;
    var getState        = options.stateHandler.getState;

    /**
     * Gets the resize detector id of the element.
     * @public
     * @param {element} element The target element to get the id of.
     * @returns {string|number|null} The id of the element. Null if it has no id.
     */
    function getId(element) {
        var state = getState(element);

        if (state && state.id !== undefined) {
            return state.id;
        }

        return null;
    }

    /**
     * Sets the resize detector id of the element. Requires the element to have a resize detector state initialized.
     * @public
     * @param {element} element The target element to set the id of.
     * @returns {string|number|null} The id of the element.
     */
    function setId(element) {
        var state = getState(element);

        if (!state) {
            throw new Error("setId required the element to have a resize detection state.");
        }

        var id = idGenerator.generate();

        state.id = id;

        return id;
    }

    return {
        get: getId,
        set: setId
    };
};


/***/ }),

/***/ "50bf":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var utils = module.exports = {};

utils.getOption = getOption;

function getOption(options, name, defaultValue) {
    var value = options[name];

    if((value === undefined || value === null) && defaultValue !== undefined) {
        return defaultValue;
    }

    return value;
}


/***/ }),

/***/ "520a":
/***/ (function(module, exports, __nested_webpack_require_75288__) {

"use strict";


var regexpFlags = __nested_webpack_require_75288__("0bfb");

var nativeExec = RegExp.prototype.exec;
// This always refers to the native implementation, because the
// String#replace polyfill uses ./fix-regexp-well-known-symbol-logic.js,
// which loads this file before patching the method.
var nativeReplace = String.prototype.replace;

var patchedExec = nativeExec;

var LAST_INDEX = 'lastIndex';

var UPDATES_LAST_INDEX_WRONG = (function () {
  var re1 = /a/,
      re2 = /b*/g;
  nativeExec.call(re1, 'a');
  nativeExec.call(re2, 'a');
  return re1[LAST_INDEX] !== 0 || re2[LAST_INDEX] !== 0;
})();

// nonparticipating capturing group, copied from es5-shim's String#split patch.
var NPCG_INCLUDED = /()??/.exec('')[1] !== undefined;

var PATCH = UPDATES_LAST_INDEX_WRONG || NPCG_INCLUDED;

if (PATCH) {
  patchedExec = function exec(str) {
    var re = this;
    var lastIndex, reCopy, match, i;

    if (NPCG_INCLUDED) {
      reCopy = new RegExp('^' + re.source + '$(?!\\s)', regexpFlags.call(re));
    }
    if (UPDATES_LAST_INDEX_WRONG) lastIndex = re[LAST_INDEX];

    match = nativeExec.call(re, str);

    if (UPDATES_LAST_INDEX_WRONG && match) {
      re[LAST_INDEX] = re.global ? match.index + match[0].length : lastIndex;
    }
    if (NPCG_INCLUDED && match && match.length > 1) {
      // Fix browsers whose `exec` methods don't consistently return `undefined`
      // for NPCG, like IE8. NOTE: This doesn' work for /(.?)?/
      // eslint-disable-next-line no-loop-func
      nativeReplace.call(match[0], reCopy, function () {
        for (i = 1; i < arguments.length - 2; i++) {
          if (arguments[i] === undefined) match[i] = undefined;
        }
      });
    }

    return match;
  };
}

module.exports = patchedExec;


/***/ }),

/***/ "52a7":
/***/ (function(module, exports) {

exports.f = {}.propertyIsEnumerable;


/***/ }),

/***/ "5537":
/***/ (function(module, exports, __nested_webpack_require_77221__) {

var core = __nested_webpack_require_77221__("8378");
var global = __nested_webpack_require_77221__("7726");
var SHARED = '__core-js_shared__';
var store = global[SHARED] || (global[SHARED] = {});

(module.exports = function (key, value) {
  return store[key] || (store[key] = value !== undefined ? value : {});
})('versions', []).push({
  version: core.version,
  mode: __nested_webpack_require_77221__("2d00") ? 'pure' : 'global',
  copyright: '© 2020 Denis Pushkarev (zloirock.ru)'
});


/***/ }),

/***/ "55dd":
/***/ (function(module, exports, __nested_webpack_require_77754__) {

"use strict";

var $export = __nested_webpack_require_77754__("5ca1");
var aFunction = __nested_webpack_require_77754__("d8e8");
var toObject = __nested_webpack_require_77754__("4bf8");
var fails = __nested_webpack_require_77754__("79e5");
var $sort = [].sort;
var test = [1, 2, 3];

$export($export.P + $export.F * (fails(function () {
  // IE8-
  test.sort(undefined);
}) || !fails(function () {
  // V8 bug
  test.sort(null);
  // Old WebKit
}) || !__nested_webpack_require_77754__("2f21")($sort)), 'Array', {
  // 22.1.3.25 Array.prototype.sort(comparefn)
  sort: function sort(comparefn) {
    return comparefn === undefined
      ? $sort.call(toObject(this))
      : $sort.call(toObject(this), aFunction(comparefn));
  }
});


/***/ }),

/***/ "5be5":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = function(options) {
    var getState = options.stateHandler.getState;

    /**
     * Tells if the element has been made detectable and ready to be listened for resize events.
     * @public
     * @param {element} The element to check.
     * @returns {boolean} True or false depending on if the element is detectable or not.
     */
    function isDetectable(element) {
        var state = getState(element);
        return state && !!state.isDetectable;
    }

    /**
     * Marks the element that it has been made detectable and ready to be listened for resize events.
     * @public
     * @param {element} The element to mark.
     */
    function markAsDetectable(element) {
        getState(element).isDetectable = true;
    }

    /**
     * Tells if the element is busy or not.
     * @public
     * @param {element} The element to check.
     * @returns {boolean} True or false depending on if the element is busy or not.
     */
    function isBusy(element) {
        return !!getState(element).busy;
    }

    /**
     * Marks the object is busy and should not be made detectable.
     * @public
     * @param {element} element The element to mark.
     * @param {boolean} busy If the element is busy or not.
     */
    function markBusy(element, busy) {
        getState(element).busy = !!busy;
    }

    return {
        isDetectable: isDetectable,
        markAsDetectable: markAsDetectable,
        isBusy: isBusy,
        markBusy: markBusy
    };
};


/***/ }),

/***/ "5ca1":
/***/ (function(module, exports, __nested_webpack_require_80094__) {

var global = __nested_webpack_require_80094__("7726");
var core = __nested_webpack_require_80094__("8378");
var hide = __nested_webpack_require_80094__("32e9");
var redefine = __nested_webpack_require_80094__("2aba");
var ctx = __nested_webpack_require_80094__("9b43");
var PROTOTYPE = 'prototype';

var $export = function (type, name, source) {
  var IS_FORCED = type & $export.F;
  var IS_GLOBAL = type & $export.G;
  var IS_STATIC = type & $export.S;
  var IS_PROTO = type & $export.P;
  var IS_BIND = type & $export.B;
  var target = IS_GLOBAL ? global : IS_STATIC ? global[name] || (global[name] = {}) : (global[name] || {})[PROTOTYPE];
  var exports = IS_GLOBAL ? core : core[name] || (core[name] = {});
  var expProto = exports[PROTOTYPE] || (exports[PROTOTYPE] = {});
  var key, own, out, exp;
  if (IS_GLOBAL) source = name;
  for (key in source) {
    // contains in native
    own = !IS_FORCED && target && target[key] !== undefined;
    // export native or passed
    out = (own ? target : source)[key];
    // bind timers to global for call from export context
    exp = IS_BIND && own ? ctx(out, global) : IS_PROTO && typeof out == 'function' ? ctx(Function.call, out) : out;
    // extend global
    if (target) redefine(target, key, out, type & $export.U);
    // export
    if (exports[key] != out) hide(exports, key, exp);
    if (IS_PROTO && expProto[key] != out) expProto[key] = out;
  }
};
global.core = core;
// type bitmap
$export.F = 1;   // forced
$export.G = 2;   // global
$export.S = 4;   // static
$export.P = 8;   // proto
$export.B = 16;  // bind
$export.W = 32;  // wrap
$export.U = 64;  // safe
$export.R = 128; // real proto method for `library`
module.exports = $export;


/***/ }),

/***/ "5dbc":
/***/ (function(module, exports, __nested_webpack_require_81819__) {

var isObject = __nested_webpack_require_81819__("d3f4");
var setPrototypeOf = __nested_webpack_require_81819__("8b97").set;
module.exports = function (that, target, C) {
  var S = target.constructor;
  var P;
  if (S !== C && typeof S == 'function' && (P = S.prototype) !== C.prototype && isObject(P) && setPrototypeOf) {
    setPrototypeOf(that, P);
  } return that;
};


/***/ }),

/***/ "5ed4":
/***/ (function(module, __webpack_exports__, __nested_webpack_require_82260__) {

"use strict";
/* harmony import */ var _node_modules_vue_style_loader_index_js_ref_6_oneOf_1_0_node_modules_css_loader_index_js_ref_6_oneOf_1_1_node_modules_vue_loader_lib_loaders_stylePostLoader_js_node_modules_postcss_loader_src_index_js_ref_6_oneOf_1_2_node_modules_postcss_loader_src_index_js_ref_6_oneOf_1_3_node_modules_cache_loader_dist_cjs_js_ref_0_0_node_modules_vue_loader_lib_index_js_vue_loader_options_GridItem_vue_vue_type_style_index_0_lang_css___WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_82260__("6e21");
/* harmony import */ var _node_modules_vue_style_loader_index_js_ref_6_oneOf_1_0_node_modules_css_loader_index_js_ref_6_oneOf_1_1_node_modules_vue_loader_lib_loaders_stylePostLoader_js_node_modules_postcss_loader_src_index_js_ref_6_oneOf_1_2_node_modules_postcss_loader_src_index_js_ref_6_oneOf_1_3_node_modules_cache_loader_dist_cjs_js_ref_0_0_node_modules_vue_loader_lib_index_js_vue_loader_options_GridItem_vue_vue_type_style_index_0_lang_css___WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__nested_webpack_require_82260__.n(_node_modules_vue_style_loader_index_js_ref_6_oneOf_1_0_node_modules_css_loader_index_js_ref_6_oneOf_1_1_node_modules_vue_loader_lib_loaders_stylePostLoader_js_node_modules_postcss_loader_src_index_js_ref_6_oneOf_1_2_node_modules_postcss_loader_src_index_js_ref_6_oneOf_1_3_node_modules_cache_loader_dist_cjs_js_ref_0_0_node_modules_vue_loader_lib_index_js_vue_loader_options_GridItem_vue_vue_type_style_index_0_lang_css___WEBPACK_IMPORTED_MODULE_0__);
/* unused harmony reexport * */


/***/ }),

/***/ "5eda":
/***/ (function(module, exports, __nested_webpack_require_83871__) {

// most Object methods by ES6 should accept primitives
var $export = __nested_webpack_require_83871__("5ca1");
var core = __nested_webpack_require_83871__("8378");
var fails = __nested_webpack_require_83871__("79e5");
module.exports = function (KEY, exec) {
  var fn = (core.Object || {})[KEY] || Object[KEY];
  var exp = {};
  exp[KEY] = exec(fn);
  $export($export.S + $export.F * fails(function () { fn(1); }), 'Object', exp);
};


/***/ }),

/***/ "5f1b":
/***/ (function(module, exports, __nested_webpack_require_84349__) {

"use strict";


var classof = __nested_webpack_require_84349__("23c6");
var builtinExec = RegExp.prototype.exec;

 // `RegExpExec` abstract operation
// https://tc39.github.io/ecma262/#sec-regexpexec
module.exports = function (R, S) {
  var exec = R.exec;
  if (typeof exec === 'function') {
    var result = exec.call(R, S);
    if (typeof result !== 'object') {
      throw new TypeError('RegExp exec method returned something other than an Object or null');
    }
    return result;
  }
  if (classof(R) !== 'RegExp') {
    throw new TypeError('RegExp#exec called on incompatible receiver');
  }
  return builtinExec.call(R, S);
};


/***/ }),

/***/ "613b":
/***/ (function(module, exports, __nested_webpack_require_85055__) {

var shared = __nested_webpack_require_85055__("5537")('keys');
var uid = __nested_webpack_require_85055__("ca5a");
module.exports = function (key) {
  return shared[key] || (shared[key] = uid(key));
};


/***/ }),

/***/ "626a":
/***/ (function(module, exports, __nested_webpack_require_85315__) {

// fallback for non-array-like ES3 and non-enumerable old V8 strings
var cof = __nested_webpack_require_85315__("2d95");
// eslint-disable-next-line no-prototype-builtins
module.exports = Object('z').propertyIsEnumerable(0) ? Object : function (it) {
  return cof(it) == 'String' ? it.split('') : Object(it);
};


/***/ }),

/***/ "6821":
/***/ (function(module, exports, __nested_webpack_require_85698__) {

// to indexed object, toObject with fallback for non-array-like ES3 strings
var IObject = __nested_webpack_require_85698__("626a");
var defined = __nested_webpack_require_85698__("be13");
module.exports = function (it) {
  return IObject(defined(it));
};


/***/ }),

/***/ "69a8":
/***/ (function(module, exports) {

var hasOwnProperty = {}.hasOwnProperty;
module.exports = function (it, key) {
  return hasOwnProperty.call(it, key);
};


/***/ }),

/***/ "6a99":
/***/ (function(module, exports, __nested_webpack_require_86194__) {

// 7.1.1 ToPrimitive(input [, PreferredType])
var isObject = __nested_webpack_require_86194__("d3f4");
// instead of the ES6 spec version, we didn't implement @@toPrimitive case
// and the second argument - flag - preferred type is a string
module.exports = function (it, S) {
  if (!isObject(it)) return it;
  var fn, val;
  if (S && typeof (fn = it.toString) == 'function' && !isObject(val = fn.call(it))) return val;
  if (typeof (fn = it.valueOf) == 'function' && !isObject(val = fn.call(it))) return val;
  if (!S && typeof (fn = it.toString) == 'function' && !isObject(val = fn.call(it))) return val;
  throw TypeError("Can't convert object to primitive value");
};


/***/ }),

/***/ "6e21":
/***/ (function(module, exports, __nested_webpack_require_86937__) {

// style-loader: Adds some css to the DOM by adding a <style> tag

// load the styles
var content = __nested_webpack_require_86937__("9cbe");
if(typeof content === 'string') content = [[module.i, content, '']];
if(content.locals) module.exports = content.locals;
// add the styles to the DOM
var add = __nested_webpack_require_86937__("499e").default
var update = add("3cbd0c21", content, true, {"sourceMap":false,"shadowMode":false});

/***/ }),

/***/ "7333":
/***/ (function(module, exports, __nested_webpack_require_87430__) {

"use strict";

// 19.1.2.1 Object.assign(target, source, ...)
var DESCRIPTORS = __nested_webpack_require_87430__("9e1e");
var getKeys = __nested_webpack_require_87430__("0d58");
var gOPS = __nested_webpack_require_87430__("2621");
var pIE = __nested_webpack_require_87430__("52a7");
var toObject = __nested_webpack_require_87430__("4bf8");
var IObject = __nested_webpack_require_87430__("626a");
var $assign = Object.assign;

// should work with symbols and should have deterministic property order (V8 bug)
module.exports = !$assign || __nested_webpack_require_87430__("79e5")(function () {
  var A = {};
  var B = {};
  // eslint-disable-next-line no-undef
  var S = Symbol();
  var K = 'abcdefghijklmnopqrst';
  A[S] = 7;
  K.split('').forEach(function (k) { B[k] = k; });
  return $assign({}, A)[S] != 7 || Object.keys($assign({}, B)).join('') != K;
}) ? function assign(target, source) { // eslint-disable-line no-unused-vars
  var T = toObject(target);
  var aLen = arguments.length;
  var index = 1;
  var getSymbols = gOPS.f;
  var isEnum = pIE.f;
  while (aLen > index) {
    var S = IObject(arguments[index++]);
    var keys = getSymbols ? getKeys(S).concat(getSymbols(S)) : getKeys(S);
    var length = keys.length;
    var j = 0;
    var key;
    while (length > j) {
      key = keys[j++];
      if (!DESCRIPTORS || isEnum.call(S, key)) T[key] = S[key];
    }
  } return T;
} : $assign;


/***/ }),

/***/ "7726":
/***/ (function(module, exports) {

// https://github.com/zloirock/core-js/issues/86#issuecomment-115759028
var global = module.exports = typeof window != 'undefined' && window.Math == Math
  ? window : typeof self != 'undefined' && self.Math == Math ? self
  // eslint-disable-next-line no-new-func
  : Function('return this')();
if (typeof __g == 'number') __g = global; // eslint-disable-line no-undef


/***/ }),

/***/ "77f1":
/***/ (function(module, exports, __nested_webpack_require_89255__) {

var toInteger = __nested_webpack_require_89255__("4588");
var max = Math.max;
var min = Math.min;
module.exports = function (index, length) {
  index = toInteger(index);
  return index < 0 ? max(index + length, 0) : min(index, length);
};


/***/ }),

/***/ "79e5":
/***/ (function(module, exports) {

module.exports = function (exec) {
  try {
    return !!exec();
  } catch (e) {
    return true;
  }
};


/***/ }),

/***/ "7f20":
/***/ (function(module, exports, __nested_webpack_require_89732__) {

var def = __nested_webpack_require_89732__("86cc").f;
var has = __nested_webpack_require_89732__("69a8");
var TAG = __nested_webpack_require_89732__("2b4c")('toStringTag');

module.exports = function (it, tag, stat) {
  if (it && !has(it = stat ? it : it.prototype, TAG)) def(it, TAG, { configurable: true, value: tag });
};


/***/ }),

/***/ "7f7f":
/***/ (function(module, exports, __nested_webpack_require_90102__) {

var dP = __nested_webpack_require_90102__("86cc").f;
var FProto = Function.prototype;
var nameRE = /^\s*function ([^ (]*)/;
var NAME = 'name';

// 19.2.4.2 name
NAME in FProto || __nested_webpack_require_90102__("9e1e") && dP(FProto, NAME, {
  configurable: true,
  get: function () {
    try {
      return ('' + this).match(nameRE)[1];
    } catch (e) {
      return '';
    }
  }
});


/***/ }),

/***/ "8378":
/***/ (function(module, exports) {

var core = module.exports = { version: '2.6.12' };
if (typeof __e == 'number') __e = core; // eslint-disable-line no-undef


/***/ }),

/***/ "84f2":
/***/ (function(module, exports) {

module.exports = {};


/***/ }),

/***/ "86cc":
/***/ (function(module, exports, __nested_webpack_require_90817__) {

var anObject = __nested_webpack_require_90817__("cb7c");
var IE8_DOM_DEFINE = __nested_webpack_require_90817__("c69a");
var toPrimitive = __nested_webpack_require_90817__("6a99");
var dP = Object.defineProperty;

exports.f = __nested_webpack_require_90817__("9e1e") ? Object.defineProperty : function defineProperty(O, P, Attributes) {
  anObject(O);
  P = toPrimitive(P, true);
  anObject(Attributes);
  if (IE8_DOM_DEFINE) try {
    return dP(O, P, Attributes);
  } catch (e) { /* empty */ }
  if ('get' in Attributes || 'set' in Attributes) throw TypeError('Accessors not supported!');
  if ('value' in Attributes) O[P] = Attributes.value;
  return O;
};


/***/ }),

/***/ "8b97":
/***/ (function(module, exports, __nested_webpack_require_91507__) {

// Works with __proto__ only. Old v8 can't work with null proto objects.
/* eslint-disable no-proto */
var isObject = __nested_webpack_require_91507__("d3f4");
var anObject = __nested_webpack_require_91507__("cb7c");
var check = function (O, proto) {
  anObject(O);
  if (!isObject(proto) && proto !== null) throw TypeError(proto + ": can't set as prototype!");
};
module.exports = {
  set: Object.setPrototypeOf || ('__proto__' in {} ? // eslint-disable-line
    function (test, buggy, set) {
      try {
        set = __nested_webpack_require_91507__("9b43")(Function.call, __nested_webpack_require_91507__("11e9").f(Object.prototype, '__proto__').set, 2);
        set(test, []);
        buggy = !(test instanceof Array);
      } catch (e) { buggy = true; }
      return function setPrototypeOf(O, proto) {
        check(O, proto);
        if (buggy) O.__proto__ = proto;
        else set(O, proto);
        return O;
      };
    }({}, false) : undefined),
  check: check
};


/***/ }),

/***/ "8bbf":
/***/ (function(module, exports) {

module.exports = __webpack_require__(/*! vue */ "./node_modules/vue/dist/vue.esm.js");

/***/ }),

/***/ "8e6e":
/***/ (function(module, exports, __nested_webpack_require_92612__) {

// https://github.com/tc39/proposal-object-getownpropertydescriptors
var $export = __nested_webpack_require_92612__("5ca1");
var ownKeys = __nested_webpack_require_92612__("990b");
var toIObject = __nested_webpack_require_92612__("6821");
var gOPD = __nested_webpack_require_92612__("11e9");
var createProperty = __nested_webpack_require_92612__("f1ae");

$export($export.S, 'Object', {
  getOwnPropertyDescriptors: function getOwnPropertyDescriptors(object) {
    var O = toIObject(object);
    var getDesc = gOPD.f;
    var keys = ownKeys(O);
    var result = {};
    var i = 0;
    var key, desc;
    while (keys.length > i) {
      desc = getDesc(O, key = keys[i++]);
      if (desc !== undefined) createProperty(result, key, desc);
    }
    return result;
  }
});


/***/ }),

/***/ "9093":
/***/ (function(module, exports, __nested_webpack_require_93401__) {

// 19.1.2.7 / 15.2.3.4 Object.getOwnPropertyNames(O)
var $keys = __nested_webpack_require_93401__("ce10");
var hiddenKeys = __nested_webpack_require_93401__("e11e").concat('length', 'prototype');

exports.f = Object.getOwnPropertyNames || function getOwnPropertyNames(O) {
  return $keys(O, hiddenKeys);
};


/***/ }),

/***/ "97a7":
/***/ (function(module, __webpack_exports__, __nested_webpack_require_93778__) {

"use strict";
/* harmony export (binding) */ __nested_webpack_require_93778__.d(__webpack_exports__, "b", function() { return getBreakpointFromWidth; });
/* harmony export (binding) */ __nested_webpack_require_93778__.d(__webpack_exports__, "c", function() { return getColsFromBreakpoint; });
/* harmony export (binding) */ __nested_webpack_require_93778__.d(__webpack_exports__, "a", function() { return findOrGenerateResponsiveLayout; });
/* unused harmony export generateResponsiveLayout */
/* unused harmony export sortBreakpoints */
/* harmony import */ var core_js_modules_es6_array_sort__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_93778__("55dd");
/* harmony import */ var core_js_modules_es6_array_sort__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__nested_webpack_require_93778__.n(core_js_modules_es6_array_sort__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var core_js_modules_web_dom_iterable__WEBPACK_IMPORTED_MODULE_1__ = __nested_webpack_require_93778__("ac6a");
/* harmony import */ var core_js_modules_web_dom_iterable__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__nested_webpack_require_93778__.n(core_js_modules_web_dom_iterable__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var core_js_modules_es6_array_iterator__WEBPACK_IMPORTED_MODULE_2__ = __nested_webpack_require_93778__("cadf");
/* harmony import */ var core_js_modules_es6_array_iterator__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__nested_webpack_require_93778__.n(core_js_modules_es6_array_iterator__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var core_js_modules_es6_object_keys__WEBPACK_IMPORTED_MODULE_3__ = __nested_webpack_require_93778__("456d");
/* harmony import */ var core_js_modules_es6_object_keys__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__nested_webpack_require_93778__.n(core_js_modules_es6_object_keys__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_4__ = __nested_webpack_require_93778__("a2b6");




// @flow


/*:: import type {Layout} from './utils';*/

/*:: export type ResponsiveLayout = {lg?: Layout, md?: Layout, sm?: Layout, xs?: Layout, xxs?: Layout};*/

/*:: type Breakpoint = string;*/

/**
 * Given a width, find the highest breakpoint that matches is valid for it (width > breakpoint).
 *
 * @param  {Object} breakpoints Breakpoints object (e.g. {lg: 1200, md: 960, ...})
 * @param  {Number} width Screen width.
 * @return {String}       Highest breakpoint that is less than width.
 */

/*:: type Breakpoints = {lg?: number, md?: number, sm?: number, xs?: number, xxs?: number};*/

function getBreakpointFromWidth(breakpoints
/*: Breakpoints*/
, width
/*: number*/
)
/*: Breakpoint*/
{
  var sorted = sortBreakpoints(breakpoints);
  var matching = sorted[0];

  for (var i = 1, len = sorted.length; i < len; i++) {
    var breakpointName = sorted[i];
    if (width > breakpoints[breakpointName]) matching = breakpointName;
  }

  return matching;
}
/**
 * Given a breakpoint, get the # of cols set for it.
 * @param  {String} breakpoint Breakpoint name.
 * @param  {Object} cols       Map of breakpoints to cols.
 * @return {Number}            Number of cols.
 */

function getColsFromBreakpoint(breakpoint
/*: Breakpoint*/
, cols
/*: Breakpoints*/
)
/*: number*/
{
  if (!cols[breakpoint]) {
    throw new Error("ResponsiveGridLayout: `cols` entry for breakpoint " + breakpoint + " is missing!");
  }

  return cols[breakpoint];
}
/**
 * Given existing layouts and a new breakpoint, find or generate a new layout.
 *
 * This finds the layout above the new one and generates from it, if it exists.
 *
 * @param  {Array} orgLayout     Original layout.
 * @param  {Object} layouts     Existing layouts.
 * @param  {Array} breakpoints All breakpoints.
 * @param  {String} breakpoint New breakpoint.
 * @param  {String} breakpoint Last breakpoint (for fallback).
 * @param  {Number} cols       Column count at new breakpoint.
 * @param  {Boolean} verticalCompact Whether or not to compact the layout
 *   vertically.
 * @return {Array}             New layout.
 */

function findOrGenerateResponsiveLayout(orgLayout
/*: Layout*/
, layouts
/*: ResponsiveLayout*/
, breakpoints
/*: Breakpoints*/
, breakpoint
/*: Breakpoint*/
, lastBreakpoint
/*: Breakpoint*/
, cols
/*: number*/
, verticalCompact
/*: boolean*/
)
/*: Layout*/
{
  // If it already exists, just return it.
  if (layouts[breakpoint]) return Object(_utils__WEBPACK_IMPORTED_MODULE_4__[/* cloneLayout */ "b"])(layouts[breakpoint]); // Find or generate the next layout

  var layout = orgLayout;
  var breakpointsSorted = sortBreakpoints(breakpoints);
  var breakpointsAbove = breakpointsSorted.slice(breakpointsSorted.indexOf(breakpoint));

  for (var i = 0, len = breakpointsAbove.length; i < len; i++) {
    var b = breakpointsAbove[i];

    if (layouts[b]) {
      layout = layouts[b];
      break;
    }
  }

  layout = Object(_utils__WEBPACK_IMPORTED_MODULE_4__[/* cloneLayout */ "b"])(layout || []); // clone layout so we don't modify existing items

  return Object(_utils__WEBPACK_IMPORTED_MODULE_4__[/* compact */ "c"])(Object(_utils__WEBPACK_IMPORTED_MODULE_4__[/* correctBounds */ "d"])(layout, {
    cols: cols
  }), verticalCompact);
}
function generateResponsiveLayout(layout
/*: Layout*/
, breakpoints
/*: Breakpoints*/
, breakpoint
/*: Breakpoint*/
, lastBreakpoint
/*: Breakpoint*/
, cols
/*: number*/
, verticalCompact
/*: boolean*/
)
/*: Layout*/
{
  // If it already exists, just return it.

  /*if (layouts[breakpoint]) return cloneLayout(layouts[breakpoint]);
  // Find or generate the next layout
  let layout = layouts[lastBreakpoint];*/

  /*const breakpointsSorted = sortBreakpoints(breakpoints);
  const breakpointsAbove = breakpointsSorted.slice(breakpointsSorted.indexOf(breakpoint));
  for (let i = 0, len = breakpointsAbove.length; i < len; i++) {
  const b = breakpointsAbove[i];
  if (layouts[b]) {
    layout = layouts[b];
    break;
  }
  }*/
  layout = Object(_utils__WEBPACK_IMPORTED_MODULE_4__[/* cloneLayout */ "b"])(layout || []); // clone layout so we don't modify existing items

  return Object(_utils__WEBPACK_IMPORTED_MODULE_4__[/* compact */ "c"])(Object(_utils__WEBPACK_IMPORTED_MODULE_4__[/* correctBounds */ "d"])(layout, {
    cols: cols
  }), verticalCompact);
}
/**
 * Given breakpoints, return an array of breakpoints sorted by width. This is usually
 * e.g. ['xxs', 'xs', 'sm', ...]
 *
 * @param  {Object} breakpoints Key/value pair of breakpoint names to widths.
 * @return {Array}              Sorted breakpoints.
 */

function sortBreakpoints(breakpoints
/*: Breakpoints*/
)
/*: Array<Breakpoint>*/
{
  var keys
  /*: Array<string>*/
  = Object.keys(breakpoints);
  return keys.sort(function (a, b) {
    return breakpoints[a] - breakpoints[b];
  });
}

/***/ }),

/***/ "990b":
/***/ (function(module, exports, __nested_webpack_require_100528__) {

// all object keys, includes non-enumerable and symbols
var gOPN = __nested_webpack_require_100528__("9093");
var gOPS = __nested_webpack_require_100528__("2621");
var anObject = __nested_webpack_require_100528__("cb7c");
var Reflect = __nested_webpack_require_100528__("7726").Reflect;
module.exports = Reflect && Reflect.ownKeys || function ownKeys(it) {
  var keys = gOPN.f(anObject(it));
  var getSymbols = gOPS.f;
  return getSymbols ? keys.concat(getSymbols(it)) : keys;
};


/***/ }),

/***/ "9b43":
/***/ (function(module, exports, __nested_webpack_require_101036__) {

// optional / simple context binding
var aFunction = __nested_webpack_require_101036__("d8e8");
module.exports = function (fn, that, length) {
  aFunction(fn);
  if (that === undefined) return fn;
  switch (length) {
    case 1: return function (a) {
      return fn.call(that, a);
    };
    case 2: return function (a, b) {
      return fn.call(that, a, b);
    };
    case 3: return function (a, b, c) {
      return fn.call(that, a, b, c);
    };
  }
  return function (/* ...args */) {
    return fn.apply(that, arguments);
  };
};


/***/ }),

/***/ "9c6c":
/***/ (function(module, exports, __nested_webpack_require_101643__) {

// 22.1.3.31 Array.prototype[@@unscopables]
var UNSCOPABLES = __nested_webpack_require_101643__("2b4c")('unscopables');
var ArrayProto = Array.prototype;
if (ArrayProto[UNSCOPABLES] == undefined) __nested_webpack_require_101643__("32e9")(ArrayProto, UNSCOPABLES, {});
module.exports = function (key) {
  ArrayProto[UNSCOPABLES][key] = true;
};


/***/ }),

/***/ "9cbe":
/***/ (function(module, exports, __nested_webpack_require_102043__) {

exports = module.exports = __nested_webpack_require_102043__("2350")(false);
// imports


// module
exports.push([module.i, ".vue-grid-item{-webkit-transition:all .2s ease;transition:all .2s ease;-webkit-transition-property:left,top,right;transition-property:left,top,right}.vue-grid-item.no-touch{-ms-touch-action:none;touch-action:none}.vue-grid-item.cssTransforms{-webkit-transition-property:-webkit-transform;transition-property:-webkit-transform;transition-property:transform;transition-property:transform,-webkit-transform;left:0;right:auto}.vue-grid-item.cssTransforms.render-rtl{left:auto;right:0}.vue-grid-item.resizing{opacity:.6;z-index:3}.vue-grid-item.vue-draggable-dragging{-webkit-transition:none;transition:none;z-index:3}.vue-grid-item.vue-grid-placeholder{background:red;opacity:.2;-webkit-transition-duration:.1s;transition-duration:.1s;z-index:2;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;-o-user-select:none;user-select:none}.vue-grid-item>.vue-resizable-handle{position:absolute;width:20px;height:20px;bottom:0;right:0;background:url(\"data:image/svg+xml;base64,PHN2ZyBzdHlsZT0iYmFja2dyb3VuZC1jb2xvcjojZmZmZmZmMDAiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgd2lkdGg9IjYiIGhlaWdodD0iNiI+PHBhdGggZD0iTTYgNkgwVjQuMmg0LjJWMEg2djZ6IiBvcGFjaXR5PSIuMzAyIi8+PC9zdmc+\");background-position:100% 100%;padding:0 3px 3px 0;background-repeat:no-repeat;background-origin:content-box;-webkit-box-sizing:border-box;box-sizing:border-box;cursor:se-resize}.vue-grid-item>.vue-rtl-resizable-handle{bottom:0;left:0;background:url(data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTAiIGhlaWdodD0iMTAiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+PHBhdGggZmlsbD0ibm9uZSIgZD0iTS0xLTFoMTJ2MTJILTF6Ii8+PGc+PHBhdGggc3Ryb2tlLWxpbmVjYXA9InVuZGVmaW5lZCIgc3Ryb2tlLWxpbmVqb2luPSJ1bmRlZmluZWQiIHN0cm9rZS13aWR0aD0iMS41IiBzdHJva2U9IiMwMDAiIGZpbGw9Im5vbmUiIGQ9Ik0xNDQuODIxLTM4LjM5M2wtMjAuMzU3LTMxLjc4NSIvPjxwYXRoIHN0cm9rZT0iIzY2NiIgc3Ryb2tlLWxpbmVjYXA9InVuZGVmaW5lZCIgc3Ryb2tlLWxpbmVqb2luPSJ1bmRlZmluZWQiIHN0cm9rZS13aWR0aD0iMiIgZmlsbD0ibm9uZSIgZD0iTS45NDctLjAxOHY5LjEyNU0tLjY1NiA5aDEwLjczIi8+PC9nPjwvc3ZnPg==);background-position:0 100%;padding-left:3px;background-repeat:no-repeat;background-origin:content-box;cursor:sw-resize;right:auto}.vue-grid-item.disable-userselect{-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}", ""]);

// exports


/***/ }),

/***/ "9def":
/***/ (function(module, exports, __nested_webpack_require_104505__) {

// 7.1.15 ToLength
var toInteger = __nested_webpack_require_104505__("4588");
var min = Math.min;
module.exports = function (it) {
  return it > 0 ? min(toInteger(it), 0x1fffffffffffff) : 0; // pow(2, 53) - 1 == 9007199254740991
};


/***/ }),

/***/ "9e1e":
/***/ (function(module, exports, __nested_webpack_require_104807__) {

// Thank's IE8 for his funny defineProperty
module.exports = !__nested_webpack_require_104807__("79e5")(function () {
  return Object.defineProperty({}, 'a', { get: function () { return 7; } }).a != 7;
});


/***/ }),

/***/ "a2b6":
/***/ (function(module, __webpack_exports__, __nested_webpack_require_105095__) {

"use strict";
/* harmony export (binding) */ __nested_webpack_require_105095__.d(__webpack_exports__, "a", function() { return bottom; });
/* harmony export (binding) */ __nested_webpack_require_105095__.d(__webpack_exports__, "b", function() { return cloneLayout; });
/* unused harmony export cloneLayoutItem */
/* unused harmony export collides */
/* harmony export (binding) */ __nested_webpack_require_105095__.d(__webpack_exports__, "c", function() { return compact; });
/* unused harmony export compactItem */
/* harmony export (binding) */ __nested_webpack_require_105095__.d(__webpack_exports__, "d", function() { return correctBounds; });
/* harmony export (binding) */ __nested_webpack_require_105095__.d(__webpack_exports__, "f", function() { return getLayoutItem; });
/* unused harmony export getFirstCollision */
/* harmony export (binding) */ __nested_webpack_require_105095__.d(__webpack_exports__, "e", function() { return getAllCollisions; });
/* unused harmony export getStatics */
/* harmony export (binding) */ __nested_webpack_require_105095__.d(__webpack_exports__, "g", function() { return moveElement; });
/* unused harmony export moveElementAwayFromCollision */
/* unused harmony export perc */
/* harmony export (binding) */ __nested_webpack_require_105095__.d(__webpack_exports__, "j", function() { return setTransform; });
/* harmony export (binding) */ __nested_webpack_require_105095__.d(__webpack_exports__, "k", function() { return setTransformRtl; });
/* harmony export (binding) */ __nested_webpack_require_105095__.d(__webpack_exports__, "h", function() { return setTopLeft; });
/* harmony export (binding) */ __nested_webpack_require_105095__.d(__webpack_exports__, "i", function() { return setTopRight; });
/* unused harmony export sortLayoutItemsByRowCol */
/* harmony export (binding) */ __nested_webpack_require_105095__.d(__webpack_exports__, "l", function() { return validateLayout; });
/* unused harmony export autoBindHandlers */
/* unused harmony export createMarkup */
/* unused harmony export IS_UNITLESS */
/* unused harmony export addPx */
/* unused harmony export hyphenateRE */
/* unused harmony export hyphenate */
/* unused harmony export findItemInArray */
/* unused harmony export findAndRemove */
/* harmony import */ var core_js_modules_es6_regexp_replace__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_105095__("a481");
/* harmony import */ var core_js_modules_es6_regexp_replace__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__nested_webpack_require_105095__.n(core_js_modules_es6_regexp_replace__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var core_js_modules_es6_array_iterator__WEBPACK_IMPORTED_MODULE_1__ = __nested_webpack_require_105095__("cadf");
/* harmony import */ var core_js_modules_es6_array_iterator__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__nested_webpack_require_105095__.n(core_js_modules_es6_array_iterator__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var core_js_modules_es6_object_keys__WEBPACK_IMPORTED_MODULE_2__ = __nested_webpack_require_105095__("456d");
/* harmony import */ var core_js_modules_es6_object_keys__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__nested_webpack_require_105095__.n(core_js_modules_es6_object_keys__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var core_js_modules_web_dom_iterable__WEBPACK_IMPORTED_MODULE_3__ = __nested_webpack_require_105095__("ac6a");
/* harmony import */ var core_js_modules_web_dom_iterable__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__nested_webpack_require_105095__.n(core_js_modules_web_dom_iterable__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var core_js_modules_es6_array_sort__WEBPACK_IMPORTED_MODULE_4__ = __nested_webpack_require_105095__("55dd");
/* harmony import */ var core_js_modules_es6_array_sort__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__nested_webpack_require_105095__.n(core_js_modules_es6_array_sort__WEBPACK_IMPORTED_MODULE_4__);





// @flow

/*:: export type LayoutItemRequired = {w: number, h: number, x: number, y: number, i: string};*/

/*:: export type LayoutItem = LayoutItemRequired &
                         {minW?: number, minH?: number, maxW?: number, maxH?: number,
                          moved?: boolean, static?: boolean,
                          isDraggable?: ?boolean, isResizable?: ?boolean};*/

// export type Position = {left: number, top: number, width: number, height: number};

/*
export type DragCallbackData = {
  node: HTMLElement,
  x: number, y: number,
  deltaX: number, deltaY: number,
  lastX: number, lastY: number
};
*/
// export type DragEvent = {e: Event} & DragCallbackData;

/*:: export type Layout = Array<LayoutItem>;*/

// export type ResizeEvent = {e: Event, node: HTMLElement, size: Size};
// const isProduction = process.env.NODE_ENV === 'production';

/**
 * Return the bottom coordinate of the layout.
 *
 * @param  {Array} layout Layout array.
 * @return {Number}       Bottom coordinate.
 */

/*:: export type Size = {width: number, height: number};*/

function bottom(layout
/*: Layout*/
)
/*: number*/
{
  var max = 0,
      bottomY;

  for (var i = 0, len = layout.length; i < len; i++) {
    bottomY = layout[i].y + layout[i].h;
    if (bottomY > max) max = bottomY;
  }

  return max;
}
function cloneLayout(layout
/*: Layout*/
)
/*: Layout*/
{
  var newLayout = Array(layout.length);

  for (var i = 0, len = layout.length; i < len; i++) {
    newLayout[i] = cloneLayoutItem(layout[i]);
  }

  return newLayout;
} // Fast path to cloning, since this is monomorphic

function cloneLayoutItem(layoutItem
/*: LayoutItem*/
)
/*: LayoutItem*/
{
  /*return {
    w: layoutItem.w, h: layoutItem.h, x: layoutItem.x, y: layoutItem.y, i: layoutItem.i,
    minW: layoutItem.minW, maxW: layoutItem.maxW, minH: layoutItem.minH, maxH: layoutItem.maxH,
    moved: Boolean(layoutItem.moved), static: Boolean(layoutItem.static),
    // These can be null
    isDraggable: layoutItem.isDraggable, isResizable: layoutItem.isResizable
  };*/
  return JSON.parse(JSON.stringify(layoutItem));
}
/**
 * Given two layoutitems, check if they collide.
 *
 * @return {Boolean}   True if colliding.
 */

function collides(l1
/*: LayoutItem*/
, l2
/*: LayoutItem*/
)
/*: boolean*/
{
  if (l1 === l2) return false; // same element

  if (l1.x + l1.w <= l2.x) return false; // l1 is left of l2

  if (l1.x >= l2.x + l2.w) return false; // l1 is right of l2

  if (l1.y + l1.h <= l2.y) return false; // l1 is above l2

  if (l1.y >= l2.y + l2.h) return false; // l1 is below l2

  return true; // boxes overlap
}
/**
 * Given a layout, compact it. This involves going down each y coordinate and removing gaps
 * between items.
 *
 * @param  {Array} layout Layout.
 * @param  {Boolean} verticalCompact Whether or not to compact the layout
 *   vertically.
 * @return {Array}       Compacted Layout.
 */

function compact(layout
/*: Layout*/
, verticalCompact
/*: Boolean*/
)
/*: Layout*/
{
  // Statics go in the compareWith array right away so items flow around them.
  var compareWith = getStatics(layout); // We go through the items by row and column.

  var sorted = sortLayoutItemsByRowCol(layout); // Holding for new items.

  var out = Array(layout.length);

  for (var i = 0, len = sorted.length; i < len; i++) {
    var l = sorted[i]; // Don't move static elements

    if (!l.static) {
      l = compactItem(compareWith, l, verticalCompact); // Add to comparison array. We only collide with items before this one.
      // Statics are already in this array.

      compareWith.push(l);
    } // Add to output array to make sure they still come out in the right order.


    out[layout.indexOf(l)] = l; // Clear moved flag, if it exists.

    l.moved = false;
  }

  return out;
}
/**
 * Compact an item in the layout.
 */

function compactItem(compareWith
/*: Layout*/
, l
/*: LayoutItem*/
, verticalCompact
/*: boolean*/
)
/*: LayoutItem*/
{
  if (verticalCompact) {
    // Move the element up as far as it can go without colliding.
    while (l.y > 0 && !getFirstCollision(compareWith, l)) {
      l.y--;
    }
  } // Move it down, and keep moving it down if it's colliding.


  var collides;

  while (collides = getFirstCollision(compareWith, l)) {
    l.y = collides.y + collides.h;
  }

  return l;
}
/**
 * Given a layout, make sure all elements fit within its bounds.
 *
 * @param  {Array} layout Layout array.
 * @param  {Number} bounds Number of columns.
 */

function correctBounds(layout
/*: Layout*/
, bounds
/*: {cols: number}*/
)
/*: Layout*/
{
  var collidesWith = getStatics(layout);

  for (var i = 0, len = layout.length; i < len; i++) {
    var l = layout[i]; // Overflows right

    if (l.x + l.w > bounds.cols) l.x = bounds.cols - l.w; // Overflows left

    if (l.x < 0) {
      l.x = 0;
      l.w = bounds.cols;
    }

    if (!l.static) collidesWith.push(l);else {
      // If this is static and collides with other statics, we must move it down.
      // We have to do something nicer than just letting them overlap.
      while (getFirstCollision(collidesWith, l)) {
        l.y++;
      }
    }
  }

  return layout;
}
/**
 * Get a layout item by ID. Used so we can override later on if necessary.
 *
 * @param  {Array}  layout Layout array.
 * @param  {String} id     ID
 * @return {LayoutItem}    Item at ID.
 */

function getLayoutItem(layout
/*: Layout*/
, id
/*: string*/
)
/*: ?LayoutItem*/
{
  for (var i = 0, len = layout.length; i < len; i++) {
    if (layout[i].i === id) return layout[i];
  }
}
/**
 * Returns the first item this layout collides with.
 * It doesn't appear to matter which order we approach this from, although
 * perhaps that is the wrong thing to do.
 *
 * @param  {Object} layoutItem Layout item.
 * @return {Object|undefined}  A colliding layout item, or undefined.
 */

function getFirstCollision(layout
/*: Layout*/
, layoutItem
/*: LayoutItem*/
)
/*: ?LayoutItem*/
{
  for (var i = 0, len = layout.length; i < len; i++) {
    if (collides(layout[i], layoutItem)) return layout[i];
  }
}
function getAllCollisions(layout
/*: Layout*/
, layoutItem
/*: LayoutItem*/
)
/*: Array<LayoutItem>*/
{
  return layout.filter(function (l) {
    return collides(l, layoutItem);
  });
}
/**
 * Get all static elements.
 * @param  {Array} layout Array of layout objects.
 * @return {Array}        Array of static layout items..
 */

function getStatics(layout
/*: Layout*/
)
/*: Array<LayoutItem>*/
{
  //return [];
  return layout.filter(function (l) {
    return l.static;
  });
}
/**
 * Move an element. Responsible for doing cascading movements of other elements.
 *
 * @param  {Array}      layout Full layout to modify.
 * @param  {LayoutItem} l      element to move.
 * @param  {Number}     [x]    X position in grid units.
 * @param  {Number}     [y]    Y position in grid units.
 * @param  {Boolean}    [isUserAction] If true, designates that the item we're moving is
 *                                     being dragged/resized by th euser.
 */

function moveElement(layout
/*: Layout*/
, l
/*: LayoutItem*/
, x
/*: Number*/
, y
/*: Number*/
, isUserAction
/*: Boolean*/
, preventCollision
/*: Boolean*/
)
/*: Layout*/
{
  if (l.static) return layout; // Short-circuit if nothing to do.
  //if (l.y === y && l.x === x) return layout;

  var oldX = l.x;
  var oldY = l.y;
  var movingUp = y && l.y > y; // This is quite a bit faster than extending the object

  if (typeof x === 'number') l.x = x;
  if (typeof y === 'number') l.y = y;
  l.moved = true; // If this collides with anything, move it.
  // When doing this comparison, we have to sort the items we compare with
  // to ensure, in the case of multiple collisions, that we're getting the
  // nearest collision.

  var sorted = sortLayoutItemsByRowCol(layout);
  if (movingUp) sorted = sorted.reverse();
  var collisions = getAllCollisions(sorted, l);

  if (preventCollision && collisions.length) {
    l.x = oldX;
    l.y = oldY;
    l.moved = false;
    return layout;
  } // Move each item that collides away from this element.


  for (var i = 0, len = collisions.length; i < len; i++) {
    var collision = collisions[i]; // console.log('resolving collision between', l.i, 'at', l.y, 'and', collision.i, 'at', collision.y);
    // Short circuit so we can't infinite loop

    if (collision.moved) continue; // This makes it feel a bit more precise by waiting to swap for just a bit when moving up.

    if (l.y > collision.y && l.y - collision.y > collision.h / 4) continue; // Don't move static items - we have to move *this* element away

    if (collision.static) {
      layout = moveElementAwayFromCollision(layout, collision, l, isUserAction);
    } else {
      layout = moveElementAwayFromCollision(layout, l, collision, isUserAction);
    }
  }

  return layout;
}
/**
 * This is where the magic needs to happen - given a collision, move an element away from the collision.
 * We attempt to move it up if there's room, otherwise it goes below.
 *
 * @param  {Array} layout            Full layout to modify.
 * @param  {LayoutItem} collidesWith Layout item we're colliding with.
 * @param  {LayoutItem} itemToMove   Layout item we're moving.
 * @param  {Boolean} [isUserAction]  If true, designates that the item we're moving is being dragged/resized
 *                                   by the user.
 */

function moveElementAwayFromCollision(layout
/*: Layout*/
, collidesWith
/*: LayoutItem*/
, itemToMove
/*: LayoutItem*/
, isUserAction
/*: ?boolean*/
)
/*: Layout*/
{
  var preventCollision = false; // we're already colliding
  // If there is enough space above the collision to put this element, move it there.
  // We only do this on the main collision as this can get funky in cascades and cause
  // unwanted swapping behavior.

  if (isUserAction) {
    // Make a mock item so we don't modify the item here, only modify in moveElement.
    var fakeItem
    /*: LayoutItem*/
    = {
      x: itemToMove.x,
      y: itemToMove.y,
      w: itemToMove.w,
      h: itemToMove.h,
      i: '-1'
    };
    fakeItem.y = Math.max(collidesWith.y - itemToMove.h, 0);

    if (!getFirstCollision(layout, fakeItem)) {
      return moveElement(layout, itemToMove, undefined, fakeItem.y, preventCollision);
    }
  } // Previously this was optimized to move below the collision directly, but this can cause problems
  // with cascading moves, as an item may actually leapflog a collision and cause a reversal in order.


  return moveElement(layout, itemToMove, undefined, itemToMove.y + 1, preventCollision);
}
/**
 * Helper to convert a number to a percentage string.
 *
 * @param  {Number} num Any number
 * @return {String}     That number as a percentage.
 */

function perc(num
/*: number*/
)
/*: string*/
{
  return num * 100 + '%';
}
function setTransform(top, left, width, height)
/*: Object*/
{
  // Replace unitless items with px
  var translate = "translate3d(" + left + "px," + top + "px, 0)";
  return {
    transform: translate,
    WebkitTransform: translate,
    MozTransform: translate,
    msTransform: translate,
    OTransform: translate,
    width: width + "px",
    height: height + "px",
    position: 'absolute'
  };
}
/**
 * Just like the setTransform method, but instead it will return a negative value of right.
 *
 * @param top
 * @param right
 * @param width
 * @param height
 * @returns {{transform: string, WebkitTransform: string, MozTransform: string, msTransform: string, OTransform: string, width: string, height: string, position: string}}
 */

function setTransformRtl(top, right, width, height)
/*: Object*/
{
  // Replace unitless items with px
  var translate = "translate3d(" + right * -1 + "px," + top + "px, 0)";
  return {
    transform: translate,
    WebkitTransform: translate,
    MozTransform: translate,
    msTransform: translate,
    OTransform: translate,
    width: width + "px",
    height: height + "px",
    position: 'absolute'
  };
}
function setTopLeft(top, left, width, height)
/*: Object*/
{
  return {
    top: top + "px",
    left: left + "px",
    width: width + "px",
    height: height + "px",
    position: 'absolute'
  };
}
/**
 * Just like the setTopLeft method, but instead, it will return a right property instead of left.
 *
 * @param top
 * @param right
 * @param width
 * @param height
 * @returns {{top: string, right: string, width: string, height: string, position: string}}
 */

function setTopRight(top, right, width, height)
/*: Object*/
{
  return {
    top: top + "px",
    right: right + "px",
    width: width + "px",
    height: height + "px",
    position: 'absolute'
  };
}
/**
 * Get layout items sorted from top left to right and down.
 *
 * @return {Array} Array of layout objects.
 * @return {Array}        Layout, sorted static items first.
 */

function sortLayoutItemsByRowCol(layout
/*: Layout*/
)
/*: Layout*/
{
  return [].concat(layout).sort(function (a, b) {
    if (a.y === b.y && a.x === b.x) {
      return 0;
    }

    if (a.y > b.y || a.y === b.y && a.x > b.x) {
      return 1;
    }

    return -1;
  });
}
/**
 * Generate a layout using the initialLayout and children as a template.
 * Missing entries will be added, extraneous ones will be truncated.
 *
 * @param  {Array}  initialLayout Layout passed in through props.
 * @param  {String} breakpoint    Current responsive breakpoint.
 * @param  {Boolean} verticalCompact Whether or not to compact the layout vertically.
 * @return {Array}                Working layout.
 */

/*
export function synchronizeLayoutWithChildren(initialLayout: Layout, children: Array<React.Element>|React.Element,
                                              cols: number, verticalCompact: boolean): Layout {
  // ensure 'children' is always an array
  if (!Array.isArray(children)) {
    children = [children];
  }
  initialLayout = initialLayout || [];

  // Generate one layout item per child.
  let layout: Layout = [];
  for (let i = 0, len = children.length; i < len; i++) {
    let newItem;
    const child = children[i];

    // Don't overwrite if it already exists.
    const exists = getLayoutItem(initialLayout, child.key || "1" /!* FIXME satisfies Flow *!/);
    if (exists) {
      newItem = exists;
    } else {
      const g = child.props._grid;

      // Hey, this item has a _grid property, use it.
      if (g) {
        if (!isProduction) {
          validateLayout([g], 'ReactGridLayout.children');
        }
        // Validated; add it to the layout. Bottom 'y' possible is the bottom of the layout.
        // This allows you to do nice stuff like specify {y: Infinity}
        if (verticalCompact) {
          newItem = cloneLayoutItem({...g, y: Math.min(bottom(layout), g.y), i: child.key});
        } else {
          newItem = cloneLayoutItem({...g, y: g.y, i: child.key});
        }
      }
      // Nothing provided: ensure this is added to the bottom
      else {
        newItem = cloneLayoutItem({w: 1, h: 1, x: 0, y: bottom(layout), i: child.key || "1"});
      }
    }
    layout[i] = newItem;
  }

  // Correct the layout.
  layout = correctBounds(layout, {cols: cols});
  layout = compact(layout, verticalCompact);

  return layout;
}
*/

/**
 * Validate a layout. Throws errors.
 *
 * @param  {Array}  layout        Array of layout items.
 * @param  {String} [contextName] Context name for errors.
 * @throw  {Error}                Validation error.
 */

function validateLayout(layout
/*: Layout*/
, contextName
/*: string*/
)
/*: void*/
{
  contextName = contextName || "Layout";
  var subProps = ['x', 'y', 'w', 'h'];
  if (!Array.isArray(layout)) throw new Error(contextName + " must be an array!");

  for (var i = 0, len = layout.length; i < len; i++) {
    var item = layout[i];

    for (var j = 0; j < subProps.length; j++) {
      if (typeof item[subProps[j]] !== 'number') {
        throw new Error('VueGridLayout: ' + contextName + '[' + i + '].' + subProps[j] + ' must be a number!');
      }
    }

    if (item.i && typeof item.i !== 'string') {// number is also ok, so comment the error
      // TODO confirm if commenting the line below doesn't cause unexpected problems
      // throw new Error('VueGridLayout: ' + contextName + '[' + i + '].i must be a string!');
    }

    if (item.static !== undefined && typeof item.static !== 'boolean') {
      throw new Error('VueGridLayout: ' + contextName + '[' + i + '].static must be a boolean!');
    }
  }
} // Flow can't really figure this out, so we just use Object

function autoBindHandlers(el
/*: Object*/
, fns
/*: Array<string>*/
)
/*: void*/
{
  fns.forEach(function (key) {
    return el[key] = el[key].bind(el);
  });
}
/**
 * Convert a JS object to CSS string. Similar to React's output of CSS.
 * @param obj
 * @returns {string}
 */

function createMarkup(obj) {
  var keys = Object.keys(obj);
  if (!keys.length) return '';
  var i,
      len = keys.length;
  var result = '';

  for (i = 0; i < len; i++) {
    var key = keys[i];
    var val = obj[key];
    result += hyphenate(key) + ':' + addPx(key, val) + ';';
  }

  return result;
}
/* The following list is defined in React's core */

var IS_UNITLESS = {
  animationIterationCount: true,
  boxFlex: true,
  boxFlexGroup: true,
  boxOrdinalGroup: true,
  columnCount: true,
  flex: true,
  flexGrow: true,
  flexPositive: true,
  flexShrink: true,
  flexNegative: true,
  flexOrder: true,
  gridRow: true,
  gridColumn: true,
  fontWeight: true,
  lineClamp: true,
  lineHeight: true,
  opacity: true,
  order: true,
  orphans: true,
  tabSize: true,
  widows: true,
  zIndex: true,
  zoom: true,
  // SVG-related properties
  fillOpacity: true,
  stopOpacity: true,
  strokeDashoffset: true,
  strokeOpacity: true,
  strokeWidth: true
};
/**
 * Will add px to the end of style values which are Numbers.
 * @param name
 * @param value
 * @returns {*}
 */

function addPx(name, value) {
  if (typeof value === 'number' && !IS_UNITLESS[name]) {
    return value + 'px';
  } else {
    return value;
  }
}
/**
 * Hyphenate a camelCase string.
 *
 * @param {String} str
 * @return {String}
 */

var hyphenateRE = /([a-z\d])([A-Z])/g;
function hyphenate(str) {
  return str.replace(hyphenateRE, '$1-$2').toLowerCase();
}
function findItemInArray(array, property, value) {
  for (var i = 0; i < array.length; i++) {
    if (array[i][property] == value) return true;
  }

  return false;
}
function findAndRemove(array, property, value) {
  array.forEach(function (result, index) {
    if (result[property] === value) {
      //Remove from array
      array.splice(index, 1);
    }
  });
}

/***/ }),

/***/ "a481":
/***/ (function(module, exports, __nested_webpack_require_127539__) {

"use strict";


var anObject = __nested_webpack_require_127539__("cb7c");
var toObject = __nested_webpack_require_127539__("4bf8");
var toLength = __nested_webpack_require_127539__("9def");
var toInteger = __nested_webpack_require_127539__("4588");
var advanceStringIndex = __nested_webpack_require_127539__("0390");
var regExpExec = __nested_webpack_require_127539__("5f1b");
var max = Math.max;
var min = Math.min;
var floor = Math.floor;
var SUBSTITUTION_SYMBOLS = /\$([$&`']|\d\d?|<[^>]*>)/g;
var SUBSTITUTION_SYMBOLS_NO_NAMED = /\$([$&`']|\d\d?)/g;

var maybeToString = function (it) {
  return it === undefined ? it : String(it);
};

// @@replace logic
__nested_webpack_require_127539__("214f")('replace', 2, function (defined, REPLACE, $replace, maybeCallNative) {
  return [
    // `String.prototype.replace` method
    // https://tc39.github.io/ecma262/#sec-string.prototype.replace
    function replace(searchValue, replaceValue) {
      var O = defined(this);
      var fn = searchValue == undefined ? undefined : searchValue[REPLACE];
      return fn !== undefined
        ? fn.call(searchValue, O, replaceValue)
        : $replace.call(String(O), searchValue, replaceValue);
    },
    // `RegExp.prototype[@@replace]` method
    // https://tc39.github.io/ecma262/#sec-regexp.prototype-@@replace
    function (regexp, replaceValue) {
      var res = maybeCallNative($replace, regexp, this, replaceValue);
      if (res.done) return res.value;

      var rx = anObject(regexp);
      var S = String(this);
      var functionalReplace = typeof replaceValue === 'function';
      if (!functionalReplace) replaceValue = String(replaceValue);
      var global = rx.global;
      if (global) {
        var fullUnicode = rx.unicode;
        rx.lastIndex = 0;
      }
      var results = [];
      while (true) {
        var result = regExpExec(rx, S);
        if (result === null) break;
        results.push(result);
        if (!global) break;
        var matchStr = String(result[0]);
        if (matchStr === '') rx.lastIndex = advanceStringIndex(S, toLength(rx.lastIndex), fullUnicode);
      }
      var accumulatedResult = '';
      var nextSourcePosition = 0;
      for (var i = 0; i < results.length; i++) {
        result = results[i];
        var matched = String(result[0]);
        var position = max(min(toInteger(result.index), S.length), 0);
        var captures = [];
        // NOTE: This is equivalent to
        //   captures = result.slice(1).map(maybeToString)
        // but for some reason `nativeSlice.call(result, 1, result.length)` (called in
        // the slice polyfill when slicing native arrays) "doesn't work" in safari 9 and
        // causes a crash (https://pastebin.com/N21QzeQA) when trying to debug it.
        for (var j = 1; j < result.length; j++) captures.push(maybeToString(result[j]));
        var namedCaptures = result.groups;
        if (functionalReplace) {
          var replacerArgs = [matched].concat(captures, position, S);
          if (namedCaptures !== undefined) replacerArgs.push(namedCaptures);
          var replacement = String(replaceValue.apply(undefined, replacerArgs));
        } else {
          replacement = getSubstitution(matched, S, position, captures, namedCaptures, replaceValue);
        }
        if (position >= nextSourcePosition) {
          accumulatedResult += S.slice(nextSourcePosition, position) + replacement;
          nextSourcePosition = position + matched.length;
        }
      }
      return accumulatedResult + S.slice(nextSourcePosition);
    }
  ];

    // https://tc39.github.io/ecma262/#sec-getsubstitution
  function getSubstitution(matched, str, position, captures, namedCaptures, replacement) {
    var tailPos = position + matched.length;
    var m = captures.length;
    var symbols = SUBSTITUTION_SYMBOLS_NO_NAMED;
    if (namedCaptures !== undefined) {
      namedCaptures = toObject(namedCaptures);
      symbols = SUBSTITUTION_SYMBOLS;
    }
    return $replace.call(replacement, symbols, function (match, ch) {
      var capture;
      switch (ch.charAt(0)) {
        case '$': return '$';
        case '&': return matched;
        case '`': return str.slice(0, position);
        case "'": return str.slice(tailPos);
        case '<':
          capture = namedCaptures[ch.slice(1, -1)];
          break;
        default: // \d\d?
          var n = +ch;
          if (n === 0) return match;
          if (n > m) {
            var f = floor(n / 10);
            if (f === 0) return match;
            if (f <= m) return captures[f - 1] === undefined ? ch.charAt(1) : captures[f - 1] + ch.charAt(1);
            return match;
          }
          capture = captures[n - 1];
      }
      return capture === undefined ? '' : capture;
    });
  }
});


/***/ }),

/***/ "aa77":
/***/ (function(module, exports, __nested_webpack_require_132285__) {

var $export = __nested_webpack_require_132285__("5ca1");
var defined = __nested_webpack_require_132285__("be13");
var fails = __nested_webpack_require_132285__("79e5");
var spaces = __nested_webpack_require_132285__("fdef");
var space = '[' + spaces + ']';
var non = '\u200b\u0085';
var ltrim = RegExp('^' + space + space + '*');
var rtrim = RegExp(space + space + '*$');

var exporter = function (KEY, exec, ALIAS) {
  var exp = {};
  var FORCE = fails(function () {
    return !!spaces[KEY]() || non[KEY]() != non;
  });
  var fn = exp[KEY] = FORCE ? exec(trim) : spaces[KEY];
  if (ALIAS) exp[ALIAS] = fn;
  $export($export.P + $export.F * FORCE, 'String', exp);
};

// 1 -> String#trimLeft
// 2 -> String#trimRight
// 3 -> String#trim
var trim = exporter.trim = function (string, TYPE) {
  string = String(defined(string));
  if (TYPE & 1) string = string.replace(ltrim, '');
  if (TYPE & 2) string = string.replace(rtrim, '');
  return string;
};

module.exports = exporter;


/***/ }),

/***/ "abb4":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/* global console: false */

/**
 * Reporter that handles the reporting of logs, warnings and errors.
 * @public
 * @param {boolean} quiet Tells if the reporter should be quiet or not.
 */
module.exports = function(quiet) {
    function noop() {
        //Does nothing.
    }

    var reporter = {
        log: noop,
        warn: noop,
        error: noop
    };

    if(!quiet && window.console) {
        var attachFunction = function(reporter, name) {
            //The proxy is needed to be able to call the method with the console context,
            //since we cannot use bind.
            reporter[name] = function reporterProxy() {
                var f = console[name];
                if (f.apply) { //IE9 does not support console.log.apply :)
                    f.apply(console, arguments);
                } else {
                    for (var i = 0; i < arguments.length; i++) {
                        f(arguments[i]);
                    }
                }
            };
        };

        attachFunction(reporter, "log");
        attachFunction(reporter, "warn");
        attachFunction(reporter, "error");
    }

    return reporter;
};

/***/ }),

/***/ "ac6a":
/***/ (function(module, exports, __nested_webpack_require_134552__) {

var $iterators = __nested_webpack_require_134552__("cadf");
var getKeys = __nested_webpack_require_134552__("0d58");
var redefine = __nested_webpack_require_134552__("2aba");
var global = __nested_webpack_require_134552__("7726");
var hide = __nested_webpack_require_134552__("32e9");
var Iterators = __nested_webpack_require_134552__("84f2");
var wks = __nested_webpack_require_134552__("2b4c");
var ITERATOR = wks('iterator');
var TO_STRING_TAG = wks('toStringTag');
var ArrayValues = Iterators.Array;

var DOMIterables = {
  CSSRuleList: true, // TODO: Not spec compliant, should be false.
  CSSStyleDeclaration: false,
  CSSValueList: false,
  ClientRectList: false,
  DOMRectList: false,
  DOMStringList: false,
  DOMTokenList: true,
  DataTransferItemList: false,
  FileList: false,
  HTMLAllCollection: false,
  HTMLCollection: false,
  HTMLFormElement: false,
  HTMLSelectElement: false,
  MediaList: true, // TODO: Not spec compliant, should be false.
  MimeTypeArray: false,
  NamedNodeMap: false,
  NodeList: true,
  PaintRequestList: false,
  Plugin: false,
  PluginArray: false,
  SVGLengthList: false,
  SVGNumberList: false,
  SVGPathSegList: false,
  SVGPointList: false,
  SVGStringList: false,
  SVGTransformList: false,
  SourceBufferList: false,
  StyleSheetList: true, // TODO: Not spec compliant, should be false.
  TextTrackCueList: false,
  TextTrackList: false,
  TouchList: false
};

for (var collections = getKeys(DOMIterables), i = 0; i < collections.length; i++) {
  var NAME = collections[i];
  var explicit = DOMIterables[NAME];
  var Collection = global[NAME];
  var proto = Collection && Collection.prototype;
  var key;
  if (proto) {
    if (!proto[ITERATOR]) hide(proto, ITERATOR, ArrayValues);
    if (!proto[TO_STRING_TAG]) hide(proto, TO_STRING_TAG, NAME);
    Iterators[NAME] = ArrayValues;
    if (explicit) for (key in $iterators) if (!proto[key]) redefine(proto, key, $iterators[key], true);
  }
}


/***/ }),

/***/ "ad20":
/***/ (function(module, exports, __nested_webpack_require_136479__) {

exports = module.exports = __nested_webpack_require_136479__("2350")(false);
// imports


// module
exports.push([module.i, ".vue-grid-layout{position:relative;-webkit-transition:height .2s ease;transition:height .2s ease}", ""]);

// exports


/***/ }),

/***/ "b0c5":
/***/ (function(module, exports, __nested_webpack_require_136792__) {

"use strict";

var regexpExec = __nested_webpack_require_136792__("520a");
__nested_webpack_require_136792__("5ca1")({
  target: 'RegExp',
  proto: true,
  forced: regexpExec !== /./.exec
}, {
  exec: regexpExec
});


/***/ }),

/***/ "b770":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var utils = module.exports = {};

/**
 * Loops through the collection and calls the callback for each element. if the callback returns truthy, the loop is broken and returns the same value.
 * @public
 * @param {*} collection The collection to loop through. Needs to have a length property set and have indices set from 0 to length - 1.
 * @param {function} callback The callback to be called for each element. The element will be given as a parameter to the callback. If this callback returns truthy, the loop is broken and the same value is returned.
 * @returns {*} The value that a callback has returned (if truthy). Otherwise nothing.
 */
utils.forEach = function(collection, callback) {
    for(var i = 0; i < collection.length; i++) {
        var result = callback(collection[i]);
        if(result) {
            return result;
        }
    }
};


/***/ }),

/***/ "bc21":
/***/ (function(module, __webpack_exports__, __nested_webpack_require_138031__) {

"use strict";

// NAMESPACE OBJECT: ./node_modules/@interactjs/snappers/all.js
var all_namespaceObject = {};
__nested_webpack_require_138031__.r(all_namespaceObject);
__nested_webpack_require_138031__.d(all_namespaceObject, "edgeTarget", function() { return edgeTarget; });
__nested_webpack_require_138031__.d(all_namespaceObject, "elements", function() { return snappers_elements; });
__nested_webpack_require_138031__.d(all_namespaceObject, "grid", function() { return grid; });

// CONCATENATED MODULE: ./node_modules/cache-loader/dist/cjs.js?{"cacheDirectory":"node_modules/.cache/vue-loader","cacheIdentifier":"048e26c0-vue-loader-template"}!./node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!./node_modules/cache-loader/dist/cjs.js??ref--0-0!./node_modules/vue-loader/lib??vue-loader-options!./src/components/GridItem.vue?vue&type=template&id=7eed73a4&
var render = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('div',{ref:"item",staticClass:"vue-grid-item",class:_vm.classObj,style:(_vm.style)},[_vm._t("default"),(_vm.resizableAndNotStatic)?_c('span',{ref:"handle",class:_vm.resizableHandleClass}):_vm._e()],2)}
var staticRenderFns = []


// CONCATENATED MODULE: ./src/components/GridItem.vue?vue&type=template&id=7eed73a4&

// EXTERNAL MODULE: ./node_modules/core-js/modules/es6.regexp.replace.js
var es6_regexp_replace = __nested_webpack_require_138031__("a481");

// EXTERNAL MODULE: ./node_modules/core-js/modules/es6.regexp.match.js
var es6_regexp_match = __nested_webpack_require_138031__("4917");

// EXTERNAL MODULE: ./node_modules/core-js/modules/es6.number.constructor.js
var es6_number_constructor = __nested_webpack_require_138031__("c5f6");

// EXTERNAL MODULE: ./src/helpers/utils.js
var utils = __nested_webpack_require_138031__("a2b6");

// CONCATENATED MODULE: ./src/helpers/draggableUtils.js
// Get {x, y} positions from event.
function getControlPosition(e) {
  return offsetXYFromParentOf(e);
} // Get from offsetParent

function offsetXYFromParentOf(evt) {
  var offsetParent = evt.target.offsetParent || document.body;
  var offsetParentRect = evt.offsetParent === document.body ? {
    left: 0,
    top: 0
  } : offsetParent.getBoundingClientRect();
  var x = evt.clientX + offsetParent.scrollLeft - offsetParentRect.left;
  var y = evt.clientY + offsetParent.scrollTop - offsetParentRect.top;
  /*const x = Math.round(evt.clientX + offsetParent.scrollLeft - offsetParentRect.left);
  const y = Math.round(evt.clientY + offsetParent.scrollTop - offsetParentRect.top);*/

  return {
    x: x,
    y: y
  };
} // Create an data object exposed by <DraggableCore>'s events

function createCoreData(lastX, lastY, x, y) {
  // State changes are often (but not always!) async. We want the latest value.
  var isStart = !isNum(lastX);

  if (isStart) {
    // If this is our first move, use the x and y as last coords.
    return {
      deltaX: 0,
      deltaY: 0,
      lastX: x,
      lastY: y,
      x: x,
      y: y
    };
  } else {
    // Otherwise calculate proper values.
    return {
      deltaX: x - lastX,
      deltaY: y - lastY,
      lastX: lastX,
      lastY: lastY,
      x: x,
      y: y
    };
  }
}

function isNum(num) {
  return typeof num === 'number' && !isNaN(num);
}
// EXTERNAL MODULE: ./src/helpers/responsiveUtils.js
var responsiveUtils = __nested_webpack_require_138031__("97a7");

// EXTERNAL MODULE: ./src/helpers/DOM.js
var DOM = __nested_webpack_require_138031__("1ca7");

// CONCATENATED MODULE: ./node_modules/@interactjs/utils/domObjects.js
const domObjects = {
  init,
  document: null,
  DocumentFragment: null,
  SVGElement: null,
  SVGSVGElement: null,
  SVGElementInstance: null,
  Element: null,
  HTMLElement: null,
  Event: null,
  Touch: null,
  PointerEvent: null
};

function blank() {}

/* harmony default export */ var utils_domObjects = (domObjects);

function init(window) {
  const win = window;
  domObjects.document = win.document;
  domObjects.DocumentFragment = win.DocumentFragment || blank;
  domObjects.SVGElement = win.SVGElement || blank;
  domObjects.SVGSVGElement = win.SVGSVGElement || blank;
  domObjects.SVGElementInstance = win.SVGElementInstance || blank;
  domObjects.Element = win.Element || blank;
  domObjects.HTMLElement = win.HTMLElement || domObjects.Element;
  domObjects.Event = win.Event;
  domObjects.Touch = win.Touch || blank;
  domObjects.PointerEvent = win.PointerEvent || win.MSPointerEvent;
}
//# sourceMappingURL=domObjects.js.map
// CONCATENATED MODULE: ./node_modules/@interactjs/utils/isWindow.js
/* harmony default export */ var isWindow = (thing => !!(thing && thing.Window) && thing instanceof thing.Window);
//# sourceMappingURL=isWindow.js.map
// CONCATENATED MODULE: ./node_modules/@interactjs/utils/window.js

let realWindow = undefined;
let win = undefined;

function window_init(window) {
  // get wrapped window if using Shadow DOM polyfill
  realWindow = window; // create a TextNode

  const el = window.document.createTextNode(''); // check if it's wrapped by a polyfill

  if (el.ownerDocument !== window.document && typeof window.wrap === 'function' && window.wrap(el) === el) {
    // use wrapped window
    window = window.wrap(window);
  }

  win = window;
}

if (typeof window !== 'undefined' && !!window) {
  window_init(window);
}

function getWindow(node) {
  if (isWindow(node)) {
    return node;
  }

  const rootNode = node.ownerDocument || node;
  return rootNode.defaultView || win.window;
}
//# sourceMappingURL=window.js.map
// CONCATENATED MODULE: ./node_modules/@interactjs/utils/is.js



const is_window = thing => thing === win || isWindow(thing);

const docFrag = thing => object(thing) && thing.nodeType === 11;

const object = thing => !!thing && typeof thing === 'object';

const func = thing => typeof thing === 'function';

const number = thing => typeof thing === 'number';

const bool = thing => typeof thing === 'boolean';

const string = thing => typeof thing === 'string';

const is_element = thing => {
  if (!thing || typeof thing !== 'object') {
    return false;
  } // eslint-disable-next-line import/no-named-as-default-member


  const _window = getWindow(thing) || win;

  return /object|function/.test(typeof _window.Element) ? thing instanceof _window.Element // DOM2
  : thing.nodeType === 1 && typeof thing.nodeName === 'string';
};

const plainObject = thing => object(thing) && !!thing.constructor && /function Object\b/.test(thing.constructor.toString());

const array = thing => object(thing) && typeof thing.length !== 'undefined' && func(thing.splice);

/* harmony default export */ var is = ({
  window: is_window,
  docFrag,
  object,
  func,
  number,
  bool,
  string,
  element: is_element,
  plainObject,
  array
});
//# sourceMappingURL=is.js.map
// CONCATENATED MODULE: ./node_modules/@interactjs/utils/browser.js



const browser = {
  init: browser_init,
  supportsTouch: null,
  supportsPointerEvent: null,
  isIOS7: null,
  isIOS: null,
  isIe9: null,
  isOperaMobile: null,
  prefixedMatchesSelector: null,
  pEventTypes: null,
  wheelEvent: null
};

function browser_init(window) {
  const Element = utils_domObjects.Element;
  const navigator = win.navigator; // Does the browser support touch input?

  browser.supportsTouch = 'ontouchstart' in window || is.func(window.DocumentTouch) && utils_domObjects.document instanceof window.DocumentTouch; // Does the browser support PointerEvents

  browser.supportsPointerEvent = navigator.pointerEnabled !== false && !!utils_domObjects.PointerEvent;
  browser.isIOS = /iP(hone|od|ad)/.test(navigator.platform); // scrolling doesn't change the result of getClientRects on iOS 7

  browser.isIOS7 = /iP(hone|od|ad)/.test(navigator.platform) && /OS 7[^\d]/.test(navigator.appVersion);
  browser.isIe9 = /MSIE 9/.test(navigator.userAgent); // Opera Mobile must be handled differently

  browser.isOperaMobile = navigator.appName === 'Opera' && browser.supportsTouch && /Presto/.test(navigator.userAgent); // prefix matchesSelector

  browser.prefixedMatchesSelector = 'matches' in Element.prototype ? 'matches' : 'webkitMatchesSelector' in Element.prototype ? 'webkitMatchesSelector' : 'mozMatchesSelector' in Element.prototype ? 'mozMatchesSelector' : 'oMatchesSelector' in Element.prototype ? 'oMatchesSelector' : 'msMatchesSelector';
  browser.pEventTypes = browser.supportsPointerEvent ? utils_domObjects.PointerEvent === window.MSPointerEvent ? {
    up: 'MSPointerUp',
    down: 'MSPointerDown',
    over: 'mouseover',
    out: 'mouseout',
    move: 'MSPointerMove',
    cancel: 'MSPointerCancel'
  } : {
    up: 'pointerup',
    down: 'pointerdown',
    over: 'pointerover',
    out: 'pointerout',
    move: 'pointermove',
    cancel: 'pointercancel'
  } : null; // because Webkit and Opera still use 'mousewheel' event type

  browser.wheelEvent = 'onmousewheel' in utils_domObjects.document ? 'mousewheel' : 'wheel';
}

/* harmony default export */ var utils_browser = (browser);
//# sourceMappingURL=browser.js.map
// CONCATENATED MODULE: ./node_modules/@interactjs/utils/arr.js
const contains = (array, target) => array.indexOf(target) !== -1;
const arr_remove = (array, target) => array.splice(array.indexOf(target), 1);
const merge = (target, source) => {
  for (const item of source) {
    target.push(item);
  }

  return target;
};
const from = source => merge([], source);
const findIndex = (array, func) => {
  for (let i = 0; i < array.length; i++) {
    if (func(array[i], i, array)) {
      return i;
    }
  }

  return -1;
};
const find = (array, func) => array[findIndex(array, func)];
//# sourceMappingURL=arr.js.map
// CONCATENATED MODULE: ./node_modules/@interactjs/utils/clone.js

 // tslint:disable-next-line ban-types

function clone(source) {
  const dest = {};

  for (const prop in source) {
    const value = source[prop];

    if (is.plainObject(value)) {
      dest[prop] = clone(value);
    } else if (is.array(value)) {
      dest[prop] = from(value);
    } else {
      dest[prop] = value;
    }
  }

  return dest;
}
//# sourceMappingURL=clone.js.map
// CONCATENATED MODULE: ./node_modules/@interactjs/utils/extend.js
function extend(dest, source) {
  for (const prop in source) {
    dest[prop] = source[prop];
  }

  const ret = dest;
  return ret;
}
//# sourceMappingURL=extend.js.map
// CONCATENATED MODULE: ./node_modules/@interactjs/utils/raf.js
let lastTime = 0;
let request;
let cancel;

function raf_init(window) {
  request = window.requestAnimationFrame;
  cancel = window.cancelAnimationFrame;

  if (!request) {
    const vendors = ['ms', 'moz', 'webkit', 'o'];

    for (const vendor of vendors) {
      request = window[`${vendor}RequestAnimationFrame`];
      cancel = window[`${vendor}CancelAnimationFrame`] || window[`${vendor}CancelRequestAnimationFrame`];
    }
  }

  request = request && request.bind(window);
  cancel = cancel && cancel.bind(window);

  if (!request) {
    request = callback => {
      const currTime = Date.now();
      const timeToCall = Math.max(0, 16 - (currTime - lastTime)); // eslint-disable-next-line node/no-callback-literal

      const token = window.setTimeout(() => {
        callback(currTime + timeToCall);
      }, timeToCall);
      lastTime = currTime + timeToCall;
      return token;
    };

    cancel = token => clearTimeout(token);
  }
}

/* harmony default export */ var raf = ({
  request: callback => request(callback),
  cancel: token => cancel(token),
  init: raf_init
});
//# sourceMappingURL=raf.js.map
// CONCATENATED MODULE: ./node_modules/@interactjs/utils/normalizeListeners.js


function normalize(type, listeners, result) {
  result = result || {};

  if (is.string(type) && type.search(' ') !== -1) {
    type = split(type);
  }

  if (is.array(type)) {
    return type.reduce((acc, t) => extend(acc, normalize(t, listeners, result)), result);
  } // ({ type: fn }) -> ('', { type: fn })


  if (is.object(type)) {
    listeners = type;
    type = '';
  }

  if (is.func(listeners)) {
    result[type] = result[type] || [];
    result[type].push(listeners);
  } else if (is.array(listeners)) {
    for (const l of listeners) {
      normalize(type, l, result);
    }
  } else if (is.object(listeners)) {
    for (const prefix in listeners) {
      const combinedTypes = split(prefix).map(p => `${type}${p}`);
      normalize(combinedTypes, listeners[prefix], result);
    }
  }

  return result;
}

function split(type) {
  return type.trim().split(/ +/);
}
//# sourceMappingURL=normalizeListeners.js.map
// CONCATENATED MODULE: ./node_modules/@interactjs/core/Eventable.js




function fireUntilImmediateStopped(event, listeners) {
  for (const listener of listeners) {
    if (event.immediatePropagationStopped) {
      break;
    }

    listener(event);
  }
}

class Eventable_Eventable {
  constructor(options) {
    this.options = void 0;
    this.types = {};
    this.propagationStopped = false;
    this.immediatePropagationStopped = false;
    this.global = void 0;
    this.options = extend({}, options || {});
  }

  fire(event) {
    let listeners;
    const global = this.global; // Interactable#on() listeners
    // tslint:disable no-conditional-assignment

    if (listeners = this.types[event.type]) {
      fireUntilImmediateStopped(event, listeners);
    } // interact.on() listeners


    if (!event.propagationStopped && global && (listeners = global[event.type])) {
      fireUntilImmediateStopped(event, listeners);
    }
  }

  on(type, listener) {
    const listeners = normalize(type, listener);

    for (type in listeners) {
      this.types[type] = merge(this.types[type] || [], listeners[type]);
    }
  }

  off(type, listener) {
    const listeners = normalize(type, listener);

    for (type in listeners) {
      const eventList = this.types[type];

      if (!eventList || !eventList.length) {
        continue;
      }

      for (const subListener of listeners[type]) {
        const index = eventList.indexOf(subListener);

        if (index !== -1) {
          eventList.splice(index, 1);
        }
      }
    }
  }

  getRect(_element) {
    return null;
  }

}
//# sourceMappingURL=Eventable.js.map
// CONCATENATED MODULE: ./node_modules/@interactjs/utils/domUtils.js




function nodeContains(parent, child) {
  if (parent.contains) {
    return parent.contains(child);
  }

  while (child) {
    if (child === parent) {
      return true;
    }

    child = child.parentNode;
  }

  return false;
}
function domUtils_closest(element, selector) {
  while (is.element(element)) {
    if (matchesSelector(element, selector)) {
      return element;
    }

    element = parentNode(element);
  }

  return null;
}
function parentNode(node) {
  let parent = node.parentNode;

  if (is.docFrag(parent)) {
    // skip past #shado-root fragments
    // tslint:disable-next-line
    while ((parent = parent.host) && is.docFrag(parent)) {
      continue;
    }

    return parent;
  }

  return parent;
}
function matchesSelector(element, selector) {
  // remove /deep/ from selectors if shadowDOM polyfill is used
  if (win !== realWindow) {
    selector = selector.replace(/\/deep\//g, ' ');
  }

  return element[utils_browser.prefixedMatchesSelector](selector);
}

const getParent = el => el.parentNode || el.host; // Test for the element that's "above" all other qualifiers


function indexOfDeepestElement(elements) {
  let deepestNodeParents = [];
  let deepestNodeIndex;

  for (let i = 0; i < elements.length; i++) {
    const currentNode = elements[i];
    const deepestNode = elements[deepestNodeIndex]; // node may appear in elements array multiple times

    if (!currentNode || i === deepestNodeIndex) {
      continue;
    }

    if (!deepestNode) {
      deepestNodeIndex = i;
      continue;
    }

    const currentNodeParent = getParent(currentNode);
    const deepestNodeParent = getParent(deepestNode); // check if the deepest or current are document.documentElement/rootElement
    // - if the current node is, do nothing and continue

    if (currentNodeParent === currentNode.ownerDocument) {
      continue;
    } // - if deepest is, update with the current node and continue to next
    else if (deepestNodeParent === currentNode.ownerDocument) {
        deepestNodeIndex = i;
        continue;
      } // compare zIndex of siblings


    if (currentNodeParent === deepestNodeParent) {
      if (zIndexIsHigherThan(currentNode, deepestNode)) {
        deepestNodeIndex = i;
      }

      continue;
    } // populate the ancestry array for the latest deepest node


    deepestNodeParents = deepestNodeParents.length ? deepestNodeParents : getNodeParents(deepestNode);
    let ancestryStart; // if the deepest node is an HTMLElement and the current node is a non root svg element

    if (deepestNode instanceof utils_domObjects.HTMLElement && currentNode instanceof utils_domObjects.SVGElement && !(currentNode instanceof utils_domObjects.SVGSVGElement)) {
      // TODO: is this check necessary? Was this for HTML elements embedded in SVG?
      if (currentNode === deepestNodeParent) {
        continue;
      }

      ancestryStart = currentNode.ownerSVGElement;
    } else {
      ancestryStart = currentNode;
    }

    const currentNodeParents = getNodeParents(ancestryStart, deepestNode.ownerDocument);
    let commonIndex = 0; // get (position of closest common ancestor) + 1

    while (currentNodeParents[commonIndex] && currentNodeParents[commonIndex] === deepestNodeParents[commonIndex]) {
      commonIndex++;
    }

    const parents = [currentNodeParents[commonIndex - 1], currentNodeParents[commonIndex], deepestNodeParents[commonIndex]];
    let child = parents[0].lastChild;

    while (child) {
      if (child === parents[1]) {
        deepestNodeIndex = i;
        deepestNodeParents = currentNodeParents;
        break;
      } else if (child === parents[2]) {
        break;
      }

      child = child.previousSibling;
    }
  }

  return deepestNodeIndex;
}

function getNodeParents(node, limit) {
  const parents = [];
  let parent = node;
  let parentParent;

  while ((parentParent = getParent(parent)) && parent !== limit && parentParent !== parent.ownerDocument) {
    parents.unshift(parent);
    parent = parentParent;
  }

  return parents;
}

function zIndexIsHigherThan(higherNode, lowerNode) {
  const higherIndex = parseInt(getWindow(higherNode).getComputedStyle(higherNode).zIndex, 10) || 0;
  const lowerIndex = parseInt(getWindow(lowerNode).getComputedStyle(lowerNode).zIndex, 10) || 0;
  return higherIndex >= lowerIndex;
}

function matchesUpTo(element, selector, limit) {
  while (is.element(element)) {
    if (matchesSelector(element, selector)) {
      return true;
    }

    element = parentNode(element);

    if (element === limit) {
      return matchesSelector(element, selector);
    }
  }

  return false;
}
function getActualElement(element) {
  return element.correspondingUseElement || element;
}
function getScrollXY(relevantWindow) {
  relevantWindow = relevantWindow || win;
  return {
    x: relevantWindow.scrollX || relevantWindow.document.documentElement.scrollLeft,
    y: relevantWindow.scrollY || relevantWindow.document.documentElement.scrollTop
  };
}
function getElementClientRect(element) {
  const clientRect = element instanceof utils_domObjects.SVGElement ? element.getBoundingClientRect() : element.getClientRects()[0];
  return clientRect && {
    left: clientRect.left,
    right: clientRect.right,
    top: clientRect.top,
    bottom: clientRect.bottom,
    width: clientRect.width || clientRect.right - clientRect.left,
    height: clientRect.height || clientRect.bottom - clientRect.top
  };
}
function getElementRect(element) {
  const clientRect = getElementClientRect(element);

  if (!utils_browser.isIOS7 && clientRect) {
    const scroll = getScrollXY(getWindow(element));
    clientRect.left += scroll.x;
    clientRect.right += scroll.x;
    clientRect.top += scroll.y;
    clientRect.bottom += scroll.y;
  }

  return clientRect;
}
function getPath(node) {
  const path = [];

  while (node) {
    path.push(node);
    node = parentNode(node);
  }

  return path;
}
function trySelector(value) {
  if (!is.string(value)) {
    return false;
  } // an exception will be raised if it is invalid


  utils_domObjects.document.querySelector(value);
  return true;
}
//# sourceMappingURL=domUtils.js.map
// CONCATENATED MODULE: ./node_modules/@interactjs/utils/rect.js



function getStringOptionResult(value, target, element) {
  if (value === 'parent') {
    return parentNode(element);
  }

  if (value === 'self') {
    return target.getRect(element);
  }

  return domUtils_closest(element, value);
}
function resolveRectLike(value, target, element, functionArgs) {
  let returnValue = value;

  if (is.string(returnValue)) {
    returnValue = getStringOptionResult(returnValue, target, element);
  } else if (is.func(returnValue)) {
    returnValue = returnValue(...functionArgs);
  }

  if (is.element(returnValue)) {
    returnValue = getElementRect(returnValue);
  }

  return returnValue;
}
function rectToXY(rect) {
  return rect && {
    x: 'x' in rect ? rect.x : rect.left,
    y: 'y' in rect ? rect.y : rect.top
  };
}
function xywhToTlbr(rect) {
  if (rect && !('left' in rect && 'top' in rect)) {
    rect = extend({}, rect);
    rect.left = rect.x || 0;
    rect.top = rect.y || 0;
    rect.right = rect.right || rect.left + rect.width;
    rect.bottom = rect.bottom || rect.top + rect.height;
  }

  return rect;
}
function tlbrToXywh(rect) {
  if (rect && !('x' in rect && 'y' in rect)) {
    rect = extend({}, rect);
    rect.x = rect.left || 0;
    rect.y = rect.top || 0;
    rect.width = rect.width || (rect.right || 0) - rect.x;
    rect.height = rect.height || (rect.bottom || 0) - rect.y;
  }

  return rect;
}
function addEdges(edges, rect, delta) {
  if (edges.left) {
    rect.left += delta.x;
  }

  if (edges.right) {
    rect.right += delta.x;
  }

  if (edges.top) {
    rect.top += delta.y;
  }

  if (edges.bottom) {
    rect.bottom += delta.y;
  }

  rect.width = rect.right - rect.left;
  rect.height = rect.bottom - rect.top;
}
//# sourceMappingURL=rect.js.map
// CONCATENATED MODULE: ./node_modules/@interactjs/utils/getOriginXY.js

/* harmony default export */ var getOriginXY = (function (target, element, actionName) {
  const actionOptions = target.options[actionName];
  const actionOrigin = actionOptions && actionOptions.origin;
  const origin = actionOrigin || target.options.origin;
  const originRect = resolveRectLike(origin, target, element, [target && element]);
  return rectToXY(originRect) || {
    x: 0,
    y: 0
  };
});
//# sourceMappingURL=getOriginXY.js.map
// CONCATENATED MODULE: ./node_modules/@interactjs/utils/hypot.js
/* harmony default export */ var hypot = ((x, y) => Math.sqrt(x * x + y * y));
//# sourceMappingURL=hypot.js.map
// CONCATENATED MODULE: ./node_modules/@interactjs/core/BaseEvent.js
class BaseEvent {
  constructor(interaction) {
    this.type = void 0;
    this.target = void 0;
    this.currentTarget = void 0;
    this.interactable = void 0;
    this._interaction = void 0;
    this.timeStamp = void 0;
    this.immediatePropagationStopped = false;
    this.propagationStopped = false;
    this._interaction = interaction;
  }

  preventDefault() {}
  /**
   * Don't call any other listeners (even on the current target)
   */


  stopPropagation() {
    this.propagationStopped = true;
  }
  /**
   * Don't call listeners on the remaining targets
   */


  stopImmediatePropagation() {
    this.immediatePropagationStopped = this.propagationStopped = true;
  }

} // defined outside of class definition to avoid assignment of undefined during
// construction

// getters and setters defined here to support typescript 3.6 and below which
// don't support getter and setters in .d.ts files
Object.defineProperty(BaseEvent.prototype, 'interaction', {
  get() {
    return this._interaction._proxy;
  },

  set() {}

});
//# sourceMappingURL=BaseEvent.js.map
// CONCATENATED MODULE: ./node_modules/@interactjs/core/defaultOptions.js
// eslint-disable-next-line @typescript-eslint/no-empty-interface
// export interface Options extends BaseDefaults, PerActionDefaults {}
const defaultOptions_defaults = {
  base: {
    preventDefault: 'auto',
    deltaSource: 'page'
  },
  perAction: {
    enabled: false,
    origin: {
      x: 0,
      y: 0
    }
  },
  actions: {}
};
//# sourceMappingURL=defaultOptions.js.map
// CONCATENATED MODULE: ./node_modules/@interactjs/core/InteractEvent.js





class InteractEvent_InteractEvent extends BaseEvent {
  // resize

  /** */
  constructor(interaction, event, actionName, phase, element, preEnd, type) {
    super(interaction);
    this.target = void 0;
    this.currentTarget = void 0;
    this.relatedTarget = null;
    this.screenX = void 0;
    this.screenY = void 0;
    this.button = void 0;
    this.buttons = void 0;
    this.ctrlKey = void 0;
    this.shiftKey = void 0;
    this.altKey = void 0;
    this.metaKey = void 0;
    this.page = void 0;
    this.client = void 0;
    this.delta = void 0;
    this.rect = void 0;
    this.x0 = void 0;
    this.y0 = void 0;
    this.t0 = void 0;
    this.dt = void 0;
    this.duration = void 0;
    this.clientX0 = void 0;
    this.clientY0 = void 0;
    this.velocity = void 0;
    this.speed = void 0;
    this.swipe = void 0;
    this.timeStamp = void 0;
    this.axes = void 0;
    this.preEnd = void 0;
    element = element || interaction.element;
    const target = interaction.interactable;
    const deltaSource = (target && target.options || defaultOptions_defaults).deltaSource;
    const origin = getOriginXY(target, element, actionName);
    const starting = phase === 'start';
    const ending = phase === 'end';
    const prevEvent = starting ? this : interaction.prevEvent;
    const coords = starting ? interaction.coords.start : ending ? {
      page: prevEvent.page,
      client: prevEvent.client,
      timeStamp: interaction.coords.cur.timeStamp
    } : interaction.coords.cur;
    this.page = extend({}, coords.page);
    this.client = extend({}, coords.client);
    this.rect = extend({}, interaction.rect);
    this.timeStamp = coords.timeStamp;

    if (!ending) {
      this.page.x -= origin.x;
      this.page.y -= origin.y;
      this.client.x -= origin.x;
      this.client.y -= origin.y;
    }

    this.ctrlKey = event.ctrlKey;
    this.altKey = event.altKey;
    this.shiftKey = event.shiftKey;
    this.metaKey = event.metaKey;
    this.button = event.button;
    this.buttons = event.buttons;
    this.target = element;
    this.currentTarget = element;
    this.preEnd = preEnd;
    this.type = type || actionName + (phase || '');
    this.interactable = target;
    this.t0 = starting ? interaction.pointers[interaction.pointers.length - 1].downTime : prevEvent.t0;
    this.x0 = interaction.coords.start.page.x - origin.x;
    this.y0 = interaction.coords.start.page.y - origin.y;
    this.clientX0 = interaction.coords.start.client.x - origin.x;
    this.clientY0 = interaction.coords.start.client.y - origin.y;

    if (starting || ending) {
      this.delta = {
        x: 0,
        y: 0
      };
    } else {
      this.delta = {
        x: this[deltaSource].x - prevEvent[deltaSource].x,
        y: this[deltaSource].y - prevEvent[deltaSource].y
      };
    }

    this.dt = interaction.coords.delta.timeStamp;
    this.duration = this.timeStamp - this.t0; // velocity and speed in pixels per second

    this.velocity = extend({}, interaction.coords.velocity[deltaSource]);
    this.speed = hypot(this.velocity.x, this.velocity.y);
    this.swipe = ending || phase === 'inertiastart' ? this.getSwipe() : null;
  }

  getSwipe() {
    const interaction = this._interaction;

    if (interaction.prevEvent.speed < 600 || this.timeStamp - interaction.prevEvent.timeStamp > 150) {
      return null;
    }

    let angle = 180 * Math.atan2(interaction.prevEvent.velocityY, interaction.prevEvent.velocityX) / Math.PI;
    const overlap = 22.5;

    if (angle < 0) {
      angle += 360;
    }

    const left = 135 - overlap <= angle && angle < 225 + overlap;
    const up = 225 - overlap <= angle && angle < 315 + overlap;
    const right = !left && (315 - overlap <= angle || angle < 45 + overlap);
    const down = !up && 45 - overlap <= angle && angle < 135 + overlap;
    return {
      up,
      down,
      left,
      right,
      angle,
      speed: interaction.prevEvent.speed,
      velocity: {
        x: interaction.prevEvent.velocityX,
        y: interaction.prevEvent.velocityY
      }
    };
  }

  preventDefault() {}
  /**
   * Don't call listeners on the remaining targets
   */


  stopImmediatePropagation() {
    this.immediatePropagationStopped = this.propagationStopped = true;
  }
  /**
   * Don't call any other listeners (even on the current target)
   */


  stopPropagation() {
    this.propagationStopped = true;
  }

} // getters and setters defined here to support typescript 3.6 and below which
// don't support getter and setters in .d.ts files

Object.defineProperties(InteractEvent_InteractEvent.prototype, {
  pageX: {
    get() {
      return this.page.x;
    },

    set(value) {
      this.page.x = value;
    }

  },
  pageY: {
    get() {
      return this.page.y;
    },

    set(value) {
      this.page.y = value;
    }

  },
  clientX: {
    get() {
      return this.client.x;
    },

    set(value) {
      this.client.x = value;
    }

  },
  clientY: {
    get() {
      return this.client.y;
    },

    set(value) {
      this.client.y = value;
    }

  },
  dx: {
    get() {
      return this.delta.x;
    },

    set(value) {
      this.delta.x = value;
    }

  },
  dy: {
    get() {
      return this.delta.y;
    },

    set(value) {
      this.delta.y = value;
    }

  },
  velocityX: {
    get() {
      return this.velocity.x;
    },

    set(value) {
      this.velocity.x = value;
    }

  },
  velocityY: {
    get() {
      return this.velocity.y;
    },

    set(value) {
      this.velocity.y = value;
    }

  }
});
//# sourceMappingURL=InteractEvent.js.map
// CONCATENATED MODULE: ./node_modules/@interactjs/core/isNonNativeEvent.js
function isNonNativeEvent(type, actions) {
  if (actions.phaselessTypes[type]) {
    return true;
  }

  for (const name in actions.map) {
    if (type.indexOf(name) === 0 && type.substr(name.length) in actions.phases) {
      return true;
    }
  }

  return false;
}
//# sourceMappingURL=isNonNativeEvent.js.map
// CONCATENATED MODULE: ./node_modules/@interactjs/core/Interactable.js
/* eslint-disable no-dupe-class-members */











/** */
class Interactable_Interactable {
  /** @internal */
  get _defaults() {
    return {
      base: {},
      perAction: {},
      actions: {}
    };
  }

  /** */
  constructor(target, options, defaultContext, scopeEvents) {
    this.options = void 0;
    this._actions = void 0;
    this.target = void 0;
    this.events = new Eventable_Eventable();
    this._context = void 0;
    this._win = void 0;
    this._doc = void 0;
    this._scopeEvents = void 0;
    this._rectChecker = void 0;
    this._actions = options.actions;
    this.target = target;
    this._context = options.context || defaultContext;
    this._win = getWindow(trySelector(target) ? this._context : target);
    this._doc = this._win.document;
    this._scopeEvents = scopeEvents;
    this.set(options);
  }

  setOnEvents(actionName, phases) {
    if (is.func(phases.onstart)) {
      this.on(`${actionName}start`, phases.onstart);
    }

    if (is.func(phases.onmove)) {
      this.on(`${actionName}move`, phases.onmove);
    }

    if (is.func(phases.onend)) {
      this.on(`${actionName}end`, phases.onend);
    }

    if (is.func(phases.oninertiastart)) {
      this.on(`${actionName}inertiastart`, phases.oninertiastart);
    }

    return this;
  }

  updatePerActionListeners(actionName, prev, cur) {
    if (is.array(prev) || is.object(prev)) {
      this.off(actionName, prev);
    }

    if (is.array(cur) || is.object(cur)) {
      this.on(actionName, cur);
    }
  }

  setPerAction(actionName, options) {
    const defaults = this._defaults; // for all the default per-action options

    for (const optionName_ in options) {
      const optionName = optionName_;
      const actionOptions = this.options[actionName];
      const optionValue = options[optionName]; // remove old event listeners and add new ones

      if (optionName === 'listeners') {
        this.updatePerActionListeners(actionName, actionOptions.listeners, optionValue);
      } // if the option value is an array


      if (is.array(optionValue)) {
        actionOptions[optionName] = from(optionValue);
      } // if the option value is an object
      else if (is.plainObject(optionValue)) {
          // copy the object
          actionOptions[optionName] = extend(actionOptions[optionName] || {}, clone(optionValue)); // set anabled field to true if it exists in the defaults

          if (is.object(defaults.perAction[optionName]) && 'enabled' in defaults.perAction[optionName]) {
            actionOptions[optionName].enabled = optionValue.enabled !== false;
          }
        } // if the option value is a boolean and the default is an object
        else if (is.bool(optionValue) && is.object(defaults.perAction[optionName])) {
            actionOptions[optionName].enabled = optionValue;
          } // if it's anything else, do a plain assignment
          else {
              actionOptions[optionName] = optionValue;
            }
    }
  }
  /**
   * The default function to get an Interactables bounding rect. Can be
   * overridden using {@link Interactable.rectChecker}.
   *
   * @param {Element} [element] The element to measure.
   * @return {Rect} The object's bounding rectangle.
   */


  getRect(element) {
    element = element || (is.element(this.target) ? this.target : null);

    if (is.string(this.target)) {
      element = element || this._context.querySelector(this.target);
    }

    return getElementRect(element);
  }
  /**
   * Returns or sets the function used to calculate the interactable's
   * element's rectangle
   *
   * @param {function} [checker] A function which returns this Interactable's
   * bounding rectangle. See {@link Interactable.getRect}
   * @return {function | object} The checker function or this Interactable
   */


  rectChecker(checker) {
    if (is.func(checker)) {
      this._rectChecker = checker;

      this.getRect = element => {
        const rect = extend({}, this._rectChecker(element));

        if (!('width' in rect)) {
          rect.width = rect.right - rect.left;
          rect.height = rect.bottom - rect.top;
        }

        return rect;
      };

      return this;
    }

    if (checker === null) {
      delete this.getRect;
      delete this._rectChecker;
      return this;
    }

    return this.getRect;
  }

  _backCompatOption(optionName, newValue) {
    if (trySelector(newValue) || is.object(newValue)) {
      this.options[optionName] = newValue;

      for (const action in this._actions.map) {
        this.options[action][optionName] = newValue;
      }

      return this;
    }

    return this.options[optionName];
  }
  /**
   * Gets or sets the origin of the Interactable's element.  The x and y
   * of the origin will be subtracted from action event coordinates.
   *
   * @param {Element | object | string} [origin] An HTML or SVG Element whose
   * rect will be used, an object eg. { x: 0, y: 0 } or string 'parent', 'self'
   * or any CSS selector
   *
   * @return {object} The current origin or this Interactable
   */


  origin(newValue) {
    return this._backCompatOption('origin', newValue);
  }
  /**
   * Returns or sets the mouse coordinate types used to calculate the
   * movement of the pointer.
   *
   * @param {string} [newValue] Use 'client' if you will be scrolling while
   * interacting; Use 'page' if you want autoScroll to work
   * @return {string | object} The current deltaSource or this Interactable
   */


  deltaSource(newValue) {
    if (newValue === 'page' || newValue === 'client') {
      this.options.deltaSource = newValue;
      return this;
    }

    return this.options.deltaSource;
  }
  /**
   * Gets the selector context Node of the Interactable. The default is
   * `window.document`.
   *
   * @return {Node} The context Node of this Interactable
   */


  context() {
    return this._context;
  }

  inContext(element) {
    return this._context === element.ownerDocument || nodeContains(this._context, element);
  }

  testIgnoreAllow(options, targetNode, eventTarget) {
    return !this.testIgnore(options.ignoreFrom, targetNode, eventTarget) && this.testAllow(options.allowFrom, targetNode, eventTarget);
  }

  testAllow(allowFrom, targetNode, element) {
    if (!allowFrom) {
      return true;
    }

    if (!is.element(element)) {
      return false;
    }

    if (is.string(allowFrom)) {
      return matchesUpTo(element, allowFrom, targetNode);
    } else if (is.element(allowFrom)) {
      return nodeContains(allowFrom, element);
    }

    return false;
  }

  testIgnore(ignoreFrom, targetNode, element) {
    if (!ignoreFrom || !is.element(element)) {
      return false;
    }

    if (is.string(ignoreFrom)) {
      return matchesUpTo(element, ignoreFrom, targetNode);
    } else if (is.element(ignoreFrom)) {
      return nodeContains(ignoreFrom, element);
    }

    return false;
  }
  /**
   * Calls listeners for the given InteractEvent type bound globally
   * and directly to this Interactable
   *
   * @param {InteractEvent} iEvent The InteractEvent object to be fired on this
   * Interactable
   * @return {Interactable} this Interactable
   */


  fire(iEvent) {
    this.events.fire(iEvent);
    return this;
  }

  _onOff(method, typeArg, listenerArg, options) {
    if (is.object(typeArg) && !is.array(typeArg)) {
      options = listenerArg;
      listenerArg = null;
    }

    const addRemove = method === 'on' ? 'add' : 'remove';
    const listeners = normalize(typeArg, listenerArg);

    for (let type in listeners) {
      if (type === 'wheel') {
        type = utils_browser.wheelEvent;
      }

      for (const listener of listeners[type]) {
        // if it is an action event type
        if (isNonNativeEvent(type, this._actions)) {
          this.events[method](type, listener);
        } // delegated event
        else if (is.string(this.target)) {
            this._scopeEvents[`${addRemove}Delegate`](this.target, this._context, type, listener, options);
          } // remove listener from this Interactable's element
          else {
              this._scopeEvents[addRemove](this.target, type, listener, options);
            }
      }
    }

    return this;
  }
  /**
   * Binds a listener for an InteractEvent, pointerEvent or DOM event.
   *
   * @param {string | array | object} types The types of events to listen
   * for
   * @param {function | array | object} [listener] The event listener function(s)
   * @param {object | boolean} [options] options object or useCapture flag for
   * addEventListener
   * @return {Interactable} This Interactable
   */


  on(types, listener, options) {
    return this._onOff('on', types, listener, options);
  }
  /**
   * Removes an InteractEvent, pointerEvent or DOM event listener.
   *
   * @param {string | array | object} types The types of events that were
   * listened for
   * @param {function | array | object} [listener] The event listener function(s)
   * @param {object | boolean} [options] options object or useCapture flag for
   * removeEventListener
   * @return {Interactable} This Interactable
   */


  off(types, listener, options) {
    return this._onOff('off', types, listener, options);
  }
  /**
   * Reset the options of this Interactable
   *
   * @param {object} options The new settings to apply
   * @return {object} This Interactable
   */


  set(options) {
    const defaults = this._defaults;

    if (!is.object(options)) {
      options = {};
    }

    this.options = clone(defaults.base);

    for (const actionName_ in this._actions.methodDict) {
      const actionName = actionName_;
      const methodName = this._actions.methodDict[actionName];
      this.options[actionName] = {};
      this.setPerAction(actionName, extend(extend({}, defaults.perAction), defaults.actions[actionName]));
      this[methodName](options[actionName]);
    }

    for (const setting in options) {
      if (is.func(this[setting])) {
        this[setting](options[setting]);
      }
    }

    return this;
  }
  /**
   * Remove this interactable from the list of interactables and remove it's
   * action capabilities and event listeners
   */


  unset() {
    if (is.string(this.target)) {
      // remove delegated events
      for (const type in this._scopeEvents.delegatedEvents) {
        const delegated = this._scopeEvents.delegatedEvents[type];

        for (let i = delegated.length - 1; i >= 0; i--) {
          const {
            selector,
            context,
            listeners
          } = delegated[i];

          if (selector === this.target && context === this._context) {
            delegated.splice(i, 1);
          }

          for (let l = listeners.length - 1; l >= 0; l--) {
            this._scopeEvents.removeDelegate(this.target, this._context, type, listeners[l][0], listeners[l][1]);
          }
        }
      }
    } else {
      this._scopeEvents.remove(this.target, 'all');
    }
  }

}
//# sourceMappingURL=Interactable.js.map
// CONCATENATED MODULE: ./node_modules/@interactjs/core/InteractableSet.js




class InteractableSet_InteractableSet {
  // all set interactables
  constructor(scope) {
    this.list = [];
    this.selectorMap = {};
    this.scope = void 0;
    this.scope = scope;
    scope.addListeners({
      'interactable:unset': ({
        interactable
      }) => {
        const {
          target,
          _context: context
        } = interactable;
        const targetMappings = is.string(target) ? this.selectorMap[target] : target[this.scope.id];
        const targetIndex = findIndex(targetMappings, m => m.context === context);

        if (targetMappings[targetIndex]) {
          // Destroying mappingInfo's context and interactable
          targetMappings[targetIndex].context = null;
          targetMappings[targetIndex].interactable = null;
        }

        targetMappings.splice(targetIndex, 1);
      }
    });
  }

  new(target, options) {
    options = extend(options || {}, {
      actions: this.scope.actions
    });
    const interactable = new this.scope.Interactable(target, options, this.scope.document, this.scope.events);
    const mappingInfo = {
      context: interactable._context,
      interactable
    };
    this.scope.addDocument(interactable._doc);
    this.list.push(interactable);

    if (is.string(target)) {
      if (!this.selectorMap[target]) {
        this.selectorMap[target] = [];
      }

      this.selectorMap[target].push(mappingInfo);
    } else {
      if (!interactable.target[this.scope.id]) {
        Object.defineProperty(target, this.scope.id, {
          value: [],
          configurable: true
        });
      }

      target[this.scope.id].push(mappingInfo);
    }

    this.scope.fire('interactable:new', {
      target,
      options,
      interactable,
      win: this.scope._win
    });
    return interactable;
  }

  get(target, options) {
    const context = options && options.context || this.scope.document;
    const isSelector = is.string(target);
    const targetMappings = isSelector ? this.selectorMap[target] : target[this.scope.id];

    if (!targetMappings) {
      return null;
    }

    const found = find(targetMappings, m => m.context === context && (isSelector || m.interactable.inContext(target)));
    return found && found.interactable;
  }

  forEachMatch(node, callback) {
    for (const interactable of this.list) {
      let ret;

      if ((is.string(interactable.target) // target is a selector and the element matches
      ? is.element(node) && matchesSelector(node, interactable.target) : // target is the element
      node === interactable.target) && // the element is in context
      interactable.inContext(node)) {
        ret = callback(interactable);
      }

      if (ret !== undefined) {
        return ret;
      }
    }
  }

}
//# sourceMappingURL=InteractableSet.js.map
// CONCATENATED MODULE: ./node_modules/@interactjs/utils/pointerExtend.js
function pointerExtend(dest, source) {
  for (const prop in source) {
    const prefixedPropREs = pointerExtend.prefixedPropREs;
    let deprecated = false; // skip deprecated prefixed properties

    for (const vendor in prefixedPropREs) {
      if (prop.indexOf(vendor) === 0 && prefixedPropREs[vendor].test(prop)) {
        deprecated = true;
        break;
      }
    }

    if (!deprecated && typeof source[prop] !== 'function') {
      dest[prop] = source[prop];
    }
  }

  return dest;
}

pointerExtend.prefixedPropREs = {
  webkit: /(Movement[XY]|Radius[XY]|RotationAngle|Force)$/,
  moz: /(Pressure)$/
};
/* harmony default export */ var utils_pointerExtend = (pointerExtend);
//# sourceMappingURL=pointerExtend.js.map
// CONCATENATED MODULE: ./node_modules/@interactjs/utils/pointerUtils.js






function copyCoords(dest, src) {
  dest.page = dest.page || {};
  dest.page.x = src.page.x;
  dest.page.y = src.page.y;
  dest.client = dest.client || {};
  dest.client.x = src.client.x;
  dest.client.y = src.client.y;
  dest.timeStamp = src.timeStamp;
}
function setCoordDeltas(targetObj, prev, cur) {
  targetObj.page.x = cur.page.x - prev.page.x;
  targetObj.page.y = cur.page.y - prev.page.y;
  targetObj.client.x = cur.client.x - prev.client.x;
  targetObj.client.y = cur.client.y - prev.client.y;
  targetObj.timeStamp = cur.timeStamp - prev.timeStamp;
}
function setCoordVelocity(targetObj, delta) {
  const dt = Math.max(delta.timeStamp / 1000, 0.001);
  targetObj.page.x = delta.page.x / dt;
  targetObj.page.y = delta.page.y / dt;
  targetObj.client.x = delta.client.x / dt;
  targetObj.client.y = delta.client.y / dt;
  targetObj.timeStamp = dt;
}
function setZeroCoords(targetObj) {
  targetObj.page.x = 0;
  targetObj.page.y = 0;
  targetObj.client.x = 0;
  targetObj.client.y = 0;
}
function isNativePointer(pointer) {
  return pointer instanceof utils_domObjects.Event || pointer instanceof utils_domObjects.Touch;
} // Get specified X/Y coords for mouse or event.touches[0]

function getXY(type, pointer, xy) {
  xy = xy || {};
  type = type || 'page';
  xy.x = pointer[type + 'X'];
  xy.y = pointer[type + 'Y'];
  return xy;
}
function getPageXY(pointer, page) {
  page = page || {
    x: 0,
    y: 0
  }; // Opera Mobile handles the viewport and scrolling oddly

  if (utils_browser.isOperaMobile && isNativePointer(pointer)) {
    getXY('screen', pointer, page);
    page.x += window.scrollX;
    page.y += window.scrollY;
  } else {
    getXY('page', pointer, page);
  }

  return page;
}
function getClientXY(pointer, client) {
  client = client || {};

  if (utils_browser.isOperaMobile && isNativePointer(pointer)) {
    // Opera Mobile handles the viewport and scrolling oddly
    getXY('screen', pointer, client);
  } else {
    getXY('client', pointer, client);
  }

  return client;
}
function getPointerId(pointer) {
  return is.number(pointer.pointerId) ? pointer.pointerId : pointer.identifier;
}
function setCoords(dest, pointers, timeStamp) {
  const pointer = pointers.length > 1 ? pointerAverage(pointers) : pointers[0];
  getPageXY(pointer, dest.page);
  getClientXY(pointer, dest.client);
  dest.timeStamp = timeStamp;
}
function getTouchPair(event) {
  const touches = []; // array of touches is supplied

  if (is.array(event)) {
    touches[0] = event[0];
    touches[1] = event[1];
  } // an event
  else {
      if (event.type === 'touchend') {
        if (event.touches.length === 1) {
          touches[0] = event.touches[0];
          touches[1] = event.changedTouches[0];
        } else if (event.touches.length === 0) {
          touches[0] = event.changedTouches[0];
          touches[1] = event.changedTouches[1];
        }
      } else {
        touches[0] = event.touches[0];
        touches[1] = event.touches[1];
      }
    }

  return touches;
}
function pointerAverage(pointers) {
  const average = {
    pageX: 0,
    pageY: 0,
    clientX: 0,
    clientY: 0,
    screenX: 0,
    screenY: 0
  };

  for (const pointer of pointers) {
    for (const prop in average) {
      average[prop] += pointer[prop];
    }
  }

  for (const prop in average) {
    average[prop] /= pointers.length;
  }

  return average;
}
function touchBBox(event) {
  if (!event.length) {
    return null;
  }

  const touches = getTouchPair(event);
  const minX = Math.min(touches[0].pageX, touches[1].pageX);
  const minY = Math.min(touches[0].pageY, touches[1].pageY);
  const maxX = Math.max(touches[0].pageX, touches[1].pageX);
  const maxY = Math.max(touches[0].pageY, touches[1].pageY);
  return {
    x: minX,
    y: minY,
    left: minX,
    top: minY,
    right: maxX,
    bottom: maxY,
    width: maxX - minX,
    height: maxY - minY
  };
}
function touchDistance(event, deltaSource) {
  const sourceX = deltaSource + 'X';
  const sourceY = deltaSource + 'Y';
  const touches = getTouchPair(event);
  const dx = touches[0][sourceX] - touches[1][sourceX];
  const dy = touches[0][sourceY] - touches[1][sourceY];
  return hypot(dx, dy);
}
function touchAngle(event, deltaSource) {
  const sourceX = deltaSource + 'X';
  const sourceY = deltaSource + 'Y';
  const touches = getTouchPair(event);
  const dx = touches[1][sourceX] - touches[0][sourceX];
  const dy = touches[1][sourceY] - touches[0][sourceY];
  const angle = 180 * Math.atan2(dy, dx) / Math.PI;
  return angle;
}
function getPointerType(pointer) {
  return is.string(pointer.pointerType) ? pointer.pointerType : is.number(pointer.pointerType) ? [undefined, undefined, 'touch', 'pen', 'mouse'][pointer.pointerType] // if the PointerEvent API isn't available, then the "pointer" must
  // be either a MouseEvent, TouchEvent, or Touch object
  : /touch/.test(pointer.type) || pointer instanceof utils_domObjects.Touch ? 'touch' : 'mouse';
} // [ event.target, event.currentTarget ]

function getEventTargets(event) {
  const path = is.func(event.composedPath) ? event.composedPath() : event.path;
  return [getActualElement(path ? path[0] : event.target), getActualElement(event.currentTarget)];
}
function newCoords() {
  return {
    page: {
      x: 0,
      y: 0
    },
    client: {
      x: 0,
      y: 0
    },
    timeStamp: 0
  };
}
function coordsToEvent(coords) {
  const event = {
    coords,

    get page() {
      return this.coords.page;
    },

    get client() {
      return this.coords.client;
    },

    get timeStamp() {
      return this.coords.timeStamp;
    },

    get pageX() {
      return this.coords.page.x;
    },

    get pageY() {
      return this.coords.page.y;
    },

    get clientX() {
      return this.coords.client.x;
    },

    get clientY() {
      return this.coords.client.y;
    },

    get pointerId() {
      return this.coords.pointerId;
    },

    get target() {
      return this.coords.target;
    },

    get type() {
      return this.coords.type;
    },

    get pointerType() {
      return this.coords.pointerType;
    },

    get buttons() {
      return this.coords.buttons;
    },

    preventDefault() {}

  };
  return event;
}

//# sourceMappingURL=pointerUtils.js.map
// CONCATENATED MODULE: ./node_modules/@interactjs/core/events.js








function install(scope) {
  const targets = [];
  const delegatedEvents = {};
  const documents = [];
  const eventsMethods = {
    add,
    remove,
    addDelegate,
    removeDelegate,
    delegateListener,
    delegateUseCapture,
    delegatedEvents,
    documents,
    targets,
    supportsOptions: false,
    supportsPassive: false
  }; // check if browser supports passive events and options arg

  scope.document.createElement('div').addEventListener('test', null, {
    get capture() {
      return eventsMethods.supportsOptions = true;
    },

    get passive() {
      return eventsMethods.supportsPassive = true;
    }

  });
  scope.events = eventsMethods;

  function add(eventTarget, type, listener, optionalArg) {
    const options = getOptions(optionalArg);
    let target = find(targets, t => t.eventTarget === eventTarget);

    if (!target) {
      target = {
        eventTarget,
        events: {}
      };
      targets.push(target);
    }

    if (!target.events[type]) {
      target.events[type] = [];
    }

    if (eventTarget.addEventListener && !contains(target.events[type], listener)) {
      eventTarget.addEventListener(type, listener, eventsMethods.supportsOptions ? options : options.capture);
      target.events[type].push(listener);
    }
  }

  function remove(eventTarget, type, listener, optionalArg) {
    const options = getOptions(optionalArg);
    const targetIndex = findIndex(targets, t => t.eventTarget === eventTarget);
    const target = targets[targetIndex];

    if (!target || !target.events) {
      return;
    }

    if (type === 'all') {
      for (type in target.events) {
        if (target.events.hasOwnProperty(type)) {
          remove(eventTarget, type, 'all');
        }
      }

      return;
    }

    let typeIsEmpty = false;
    const typeListeners = target.events[type];

    if (typeListeners) {
      if (listener === 'all') {
        for (let i = typeListeners.length - 1; i >= 0; i--) {
          remove(eventTarget, type, typeListeners[i], options);
        }

        return;
      } else {
        for (let i = 0; i < typeListeners.length; i++) {
          if (typeListeners[i] === listener) {
            eventTarget.removeEventListener(type, listener, eventsMethods.supportsOptions ? options : options.capture);
            typeListeners.splice(i, 1);

            if (typeListeners.length === 0) {
              delete target.events[type];
              typeIsEmpty = true;
            }

            break;
          }
        }
      }
    }

    if (typeIsEmpty && !Object.keys(target.events).length) {
      targets.splice(targetIndex, 1);
    }
  }

  function addDelegate(selector, context, type, listener, optionalArg) {
    const options = getOptions(optionalArg);

    if (!delegatedEvents[type]) {
      delegatedEvents[type] = []; // add delegate listener functions

      for (const doc of documents) {
        add(doc, type, delegateListener);
        add(doc, type, delegateUseCapture, true);
      }
    }

    const delegates = delegatedEvents[type];
    let delegate = find(delegates, d => d.selector === selector && d.context === context);

    if (!delegate) {
      delegate = {
        selector,
        context,
        listeners: []
      };
      delegates.push(delegate);
    }

    delegate.listeners.push([listener, options]);
  }

  function removeDelegate(selector, context, type, listener, optionalArg) {
    const options = getOptions(optionalArg);
    const delegates = delegatedEvents[type];
    let matchFound = false;
    let index;

    if (!delegates) {
      return;
    } // count from last index of delegated to 0


    for (index = delegates.length - 1; index >= 0; index--) {
      const cur = delegates[index]; // look for matching selector and context Node

      if (cur.selector === selector && cur.context === context) {
        const {
          listeners
        } = cur; // each item of the listeners array is an array: [function, capture, passive]

        for (let i = listeners.length - 1; i >= 0; i--) {
          const [fn, {
            capture,
            passive
          }] = listeners[i]; // check if the listener functions and capture and passive flags match

          if (fn === listener && capture === options.capture && passive === options.passive) {
            // remove the listener from the array of listeners
            listeners.splice(i, 1); // if all listeners for this target have been removed
            // remove the target from the delegates array

            if (!listeners.length) {
              delegates.splice(index, 1); // remove delegate function from context

              remove(context, type, delegateListener);
              remove(context, type, delegateUseCapture, true);
            } // only remove one listener


            matchFound = true;
            break;
          }
        }

        if (matchFound) {
          break;
        }
      }
    }
  } // bound to the interactable context when a DOM event
  // listener is added to a selector interactable


  function delegateListener(event, optionalArg) {
    const options = getOptions(optionalArg);
    const fakeEvent = new events_FakeEvent(event);
    const delegates = delegatedEvents[event.type];
    const [eventTarget] = getEventTargets(event);
    let element = eventTarget; // climb up document tree looking for selector matches

    while (is.element(element)) {
      for (let i = 0; i < delegates.length; i++) {
        const cur = delegates[i];
        const {
          selector,
          context
        } = cur;

        if (matchesSelector(element, selector) && nodeContains(context, eventTarget) && nodeContains(context, element)) {
          const {
            listeners
          } = cur;
          fakeEvent.currentTarget = element;

          for (const [fn, {
            capture,
            passive
          }] of listeners) {
            if (capture === options.capture && passive === options.passive) {
              fn(fakeEvent);
            }
          }
        }
      }

      element = parentNode(element);
    }
  }

  function delegateUseCapture(event) {
    return delegateListener.call(this, event, true);
  } // for type inferrence


  return eventsMethods;
}

class events_FakeEvent {
  constructor(originalEvent) {
    this.currentTarget = void 0;
    this.originalEvent = void 0;
    this.type = void 0;
    this.originalEvent = originalEvent; // duplicate the event so that currentTarget can be changed

    utils_pointerExtend(this, originalEvent);
  }

  preventOriginalDefault() {
    this.originalEvent.preventDefault();
  }

  stopPropagation() {
    this.originalEvent.stopPropagation();
  }

  stopImmediatePropagation() {
    this.originalEvent.stopImmediatePropagation();
  }

}

function getOptions(param) {
  if (!is.object(param)) {
    return {
      capture: !!param,
      passive: false
    };
  }

  const options = extend({}, param);
  options.capture = !!param.capture;
  options.passive = !!param.passive;
  return options;
}

/* harmony default export */ var events = ({
  id: 'events',
  install
});
//# sourceMappingURL=events.js.map
// CONCATENATED MODULE: ./node_modules/@interactjs/utils/misc.js

function warnOnce(method, message) {
  let warned = false;
  return function () {
    if (!warned) {
      win.console.warn(message);
      warned = true;
    }

    return method.apply(this, arguments);
  };
}
function copyAction(dest, src) {
  dest.name = src.name;
  dest.axis = src.axis;
  dest.edges = src.edges;
  return dest;
}
//# sourceMappingURL=misc.js.map
// CONCATENATED MODULE: ./node_modules/@interactjs/core/interactStatic.js
/** @module interact */






function createInteractStatic(scope) {
  /**
   * ```js
   * interact('#draggable').draggable(true)
   *
   * var rectables = interact('rect')
   * rectables
   *   .gesturable(true)
   *   .on('gesturemove', function (event) {
   *       // ...
   *   })
   * ```
   *
   * The methods of this variable can be used to set elements as interactables
   * and also to change various default settings.
   *
   * Calling it as a function and passing an element or a valid CSS selector
   * string returns an Interactable object which has various methods to configure
   * it.
   *
   * @global
   *
   * @param {Element | string} target The HTML or SVG Element to interact with
   * or CSS selector
   * @return {Interactable}
   */
  const interact = (target, options) => {
    let interactable = scope.interactables.get(target, options);

    if (!interactable) {
      interactable = scope.interactables.new(target, options);
      interactable.events.global = interact.globalEvents;
    }

    return interactable;
  }; // expose the functions used to calculate multi-touch properties


  interact.getPointerAverage = pointerAverage;
  interact.getTouchBBox = touchBBox;
  interact.getTouchDistance = touchDistance;
  interact.getTouchAngle = touchAngle;
  interact.getElementRect = getElementRect;
  interact.getElementClientRect = getElementClientRect;
  interact.matchesSelector = matchesSelector;
  interact.closest = domUtils_closest;
  interact.globalEvents = {}; // eslint-disable-next-line no-undef

  interact.version = "1.10.2";
  interact.scope = scope;
  /**
  * Use a plugin
  *
  * @alias module:interact.use
  *
   */

  interact.use = function (plugin, options) {
    this.scope.usePlugin(plugin, options);
    return this;
  };
  /**
   * Check if an element or selector has been set with the {@link interact}
   * function
   *
   * @alias module:interact.isSet
   *
   * @param {Target} target The Element or string being searched for
   * @param {object} options
   * @return {boolean} Indicates if the element or CSS selector was previously
   * passed to interact
   */


  interact.isSet = function (target, options) {
    return !!this.scope.interactables.get(target, options && options.context);
  };
  /**
   * @deprecated
   * Add a global listener for an InteractEvent or adds a DOM event to `document`
   *
   * @alias module:interact.on
   *
   * @param {string | array | object} type The types of events to listen for
   * @param {function} listener The function event (s)
   * @param {object | boolean} [options] object or useCapture flag for
   * addEventListener
   * @return {object} interact
   */


  interact.on = warnOnce(function on(type, listener, options) {
    if (is.string(type) && type.search(' ') !== -1) {
      type = type.trim().split(/ +/);
    }

    if (is.array(type)) {
      for (const eventType of type) {
        this.on(eventType, listener, options);
      }

      return this;
    }

    if (is.object(type)) {
      for (const prop in type) {
        this.on(prop, type[prop], listener);
      }

      return this;
    } // if it is an InteractEvent type, add listener to globalEvents


    if (isNonNativeEvent(type, this.scope.actions)) {
      // if this type of event was never bound
      if (!this.globalEvents[type]) {
        this.globalEvents[type] = [listener];
      } else {
        this.globalEvents[type].push(listener);
      }
    } // If non InteractEvent type, addEventListener to document
    else {
        this.scope.events.add(this.scope.document, type, listener, {
          options
        });
      }

    return this;
  }, 'The interact.on() method is being deprecated');
  /**
   * @deprecated
   * Removes a global InteractEvent listener or DOM event from `document`
   *
   * @alias module:interact.off
   *
   * @param {string | array | object} type The types of events that were listened
   * for
   * @param {function} listener The listener function to be removed
   * @param {object | boolean} options [options] object or useCapture flag for
   * removeEventListener
   * @return {object} interact
   */

  interact.off = warnOnce(function off(type, listener, options) {
    if (is.string(type) && type.search(' ') !== -1) {
      type = type.trim().split(/ +/);
    }

    if (is.array(type)) {
      for (const eventType of type) {
        this.off(eventType, listener, options);
      }

      return this;
    }

    if (is.object(type)) {
      for (const prop in type) {
        this.off(prop, type[prop], listener);
      }

      return this;
    }

    if (isNonNativeEvent(type, this.scope.actions)) {
      let index;

      if (type in this.globalEvents && (index = this.globalEvents[type].indexOf(listener)) !== -1) {
        this.globalEvents[type].splice(index, 1);
      }
    } else {
      this.scope.events.remove(this.scope.document, type, listener, options);
    }

    return this;
  }, 'The interact.off() method is being deprecated');

  interact.debug = function () {
    return this.scope;
  };
  /**
   * @alias module:interact.supportsTouch
   *
   * @return {boolean} Whether or not the browser supports touch input
   */


  interact.supportsTouch = function () {
    return utils_browser.supportsTouch;
  };
  /**
   * @alias module:interact.supportsPointerEvent
   *
   * @return {boolean} Whether or not the browser supports PointerEvents
   */


  interact.supportsPointerEvent = function () {
    return utils_browser.supportsPointerEvent;
  };
  /**
   * Cancels all interactions (end events are not fired)
   *
   * @alias module:interact.stop
   *
   * @return {object} interact
   */


  interact.stop = function () {
    for (const interaction of this.scope.interactions.list) {
      interaction.stop();
    }

    return this;
  };
  /**
   * Returns or sets the distance the pointer must be moved before an action
   * sequence occurs. This also affects tolerance for tap events.
   *
   * @alias module:interact.pointerMoveTolerance
   *
   * @param {number} [newValue] The movement from the start position must be greater than this value
   * @return {interact | number}
   */


  interact.pointerMoveTolerance = function (newValue) {
    if (is.number(newValue)) {
      this.scope.interactions.pointerMoveTolerance = newValue;
      return this;
    }

    return this.scope.interactions.pointerMoveTolerance;
  };

  interact.addDocument = function (doc, options) {
    this.scope.addDocument(doc, options);
  };

  interact.removeDocument = function (doc) {
    this.scope.removeDocument(doc);
  };

  return interact;
}
//# sourceMappingURL=interactStatic.js.map
// CONCATENATED MODULE: ./node_modules/@interactjs/core/PointerInfo.js
class PointerInfo {
  constructor(id, pointer, event, downTime, downTarget) {
    this.id = void 0;
    this.pointer = void 0;
    this.event = void 0;
    this.downTime = void 0;
    this.downTarget = void 0;
    this.id = id;
    this.pointer = pointer;
    this.event = event;
    this.downTime = downTime;
    this.downTarget = downTarget;
  }

}
//# sourceMappingURL=PointerInfo.js.map
// CONCATENATED MODULE: ./node_modules/@interactjs/core/Interaction.js








let _ProxyValues;

(function (_ProxyValues) {
  _ProxyValues["interactable"] = "";
  _ProxyValues["element"] = "";
  _ProxyValues["prepared"] = "";
  _ProxyValues["pointerIsDown"] = "";
  _ProxyValues["pointerWasMoved"] = "";
  _ProxyValues["_proxy"] = "";
})(_ProxyValues || (_ProxyValues = {}));

let _ProxyMethods;

(function (_ProxyMethods) {
  _ProxyMethods["start"] = "";
  _ProxyMethods["move"] = "";
  _ProxyMethods["end"] = "";
  _ProxyMethods["stop"] = "";
  _ProxyMethods["interacting"] = "";
})(_ProxyMethods || (_ProxyMethods = {}));

let idCounter = 0;
class Interaction_Interaction {
  // current interactable being interacted with
  // the target element of the interactable
  // action that's ready to be fired on next move event
  // keep track of added pointers
  // pointerdown/mousedown/touchstart event
  // previous action event

  /** @internal */
  get pointerMoveTolerance() {
    return 1;
  }
  /**
   * @alias Interaction.prototype.move
   */


  /** */
  constructor({
    pointerType,
    scopeFire
  }) {
    this.interactable = null;
    this.element = null;
    this.rect = void 0;
    this._rects = void 0;
    this.edges = void 0;
    this._scopeFire = void 0;
    this.prepared = {
      name: null,
      axis: null,
      edges: null
    };
    this.pointerType = void 0;
    this.pointers = [];
    this.downEvent = null;
    this.downPointer = {};
    this._latestPointer = {
      pointer: null,
      event: null,
      eventTarget: null
    };
    this.prevEvent = null;
    this.pointerIsDown = false;
    this.pointerWasMoved = false;
    this._interacting = false;
    this._ending = false;
    this._stopped = true;
    this._proxy = null;
    this.simulation = null;
    this.doMove = warnOnce(function (signalArg) {
      this.move(signalArg);
    }, 'The interaction.doMove() method has been renamed to interaction.move()');
    this.coords = {
      // Starting InteractEvent pointer coordinates
      start: newCoords(),
      // Previous native pointer move event coordinates
      prev: newCoords(),
      // current native pointer move event coordinates
      cur: newCoords(),
      // Change in coordinates and time of the pointer
      delta: newCoords(),
      // pointer velocity
      velocity: newCoords()
    };
    this._id = idCounter++;
    this._scopeFire = scopeFire;
    this.pointerType = pointerType;
    const that = this;
    this._proxy = {};

    for (const key in _ProxyValues) {
      Object.defineProperty(this._proxy, key, {
        get() {
          return that[key];
        }

      });
    }

    for (const key in _ProxyMethods) {
      Object.defineProperty(this._proxy, key, {
        value: (...args) => that[key](...args)
      });
    }

    this._scopeFire('interactions:new', {
      interaction: this
    });
  }

  pointerDown(pointer, event, eventTarget) {
    const pointerIndex = this.updatePointer(pointer, event, eventTarget, true);
    const pointerInfo = this.pointers[pointerIndex];

    this._scopeFire('interactions:down', {
      pointer,
      event,
      eventTarget,
      pointerIndex,
      pointerInfo,
      type: 'down',
      interaction: this
    });
  }
  /**
   * ```js
   * interact(target)
   *   .draggable({
   *     // disable the default drag start by down->move
   *     manualStart: true
   *   })
   *   // start dragging after the user holds the pointer down
   *   .on('hold', function (event) {
   *     var interaction = event.interaction
   *
   *     if (!interaction.interacting()) {
   *       interaction.start({ name: 'drag' },
   *                         event.interactable,
   *                         event.currentTarget)
   *     }
   * })
   * ```
   *
   * Start an action with the given Interactable and Element as tartgets. The
   * action must be enabled for the target Interactable and an appropriate
   * number of pointers must be held down - 1 for drag/resize, 2 for gesture.
   *
   * Use it with `interactable.<action>able({ manualStart: false })` to always
   * [start actions manually](https://github.com/taye/interact.js/issues/114)
   *
   * @param {object} action   The action to be performed - drag, resize, etc.
   * @param {Interactable} target  The Interactable to target
   * @param {Element} element The DOM Element to target
   * @return {Boolean} Whether the interaction was successfully started
   */


  start(action, interactable, element) {
    if (this.interacting() || !this.pointerIsDown || this.pointers.length < (action.name === 'gesture' ? 2 : 1) || !interactable.options[action.name].enabled) {
      return false;
    }

    copyAction(this.prepared, action);
    this.interactable = interactable;
    this.element = element;
    this.rect = interactable.getRect(element);
    this.edges = this.prepared.edges ? extend({}, this.prepared.edges) : {
      left: true,
      right: true,
      top: true,
      bottom: true
    };
    this._stopped = false;
    this._interacting = this._doPhase({
      interaction: this,
      event: this.downEvent,
      phase: 'start'
    }) && !this._stopped;
    return this._interacting;
  }

  pointerMove(pointer, event, eventTarget) {
    if (!this.simulation && !(this.modification && this.modification.endResult)) {
      this.updatePointer(pointer, event, eventTarget, false);
    }

    const duplicateMove = this.coords.cur.page.x === this.coords.prev.page.x && this.coords.cur.page.y === this.coords.prev.page.y && this.coords.cur.client.x === this.coords.prev.client.x && this.coords.cur.client.y === this.coords.prev.client.y;
    let dx;
    let dy; // register movement greater than pointerMoveTolerance

    if (this.pointerIsDown && !this.pointerWasMoved) {
      dx = this.coords.cur.client.x - this.coords.start.client.x;
      dy = this.coords.cur.client.y - this.coords.start.client.y;
      this.pointerWasMoved = hypot(dx, dy) > this.pointerMoveTolerance;
    }

    const pointerIndex = this.getPointerIndex(pointer);
    const signalArg = {
      pointer,
      pointerIndex,
      pointerInfo: this.pointers[pointerIndex],
      event,
      type: 'move',
      eventTarget,
      dx,
      dy,
      duplicate: duplicateMove,
      interaction: this
    };

    if (!duplicateMove) {
      // set pointer coordinate, time changes and velocity
      setCoordVelocity(this.coords.velocity, this.coords.delta);
    }

    this._scopeFire('interactions:move', signalArg);

    if (!duplicateMove && !this.simulation) {
      // if interacting, fire an 'action-move' signal etc
      if (this.interacting()) {
        signalArg.type = null;
        this.move(signalArg);
      }

      if (this.pointerWasMoved) {
        copyCoords(this.coords.prev, this.coords.cur);
      }
    }
  }
  /**
   * ```js
   * interact(target)
   *   .draggable(true)
   *   .on('dragmove', function (event) {
   *     if (someCondition) {
   *       // change the snap settings
   *       event.interactable.draggable({ snap: { targets: [] }})
   *       // fire another move event with re-calculated snap
   *       event.interaction.move()
   *     }
   *   })
   * ```
   *
   * Force a move of the current action at the same coordinates. Useful if
   * snap/restrict has been changed and you want a movement with the new
   * settings.
   */


  move(signalArg) {
    if (!signalArg || !signalArg.event) {
      setZeroCoords(this.coords.delta);
    }

    signalArg = extend({
      pointer: this._latestPointer.pointer,
      event: this._latestPointer.event,
      eventTarget: this._latestPointer.eventTarget,
      interaction: this
    }, signalArg || {});
    signalArg.phase = 'move';

    this._doPhase(signalArg);
  } // End interact move events and stop auto-scroll unless simulation is running


  pointerUp(pointer, event, eventTarget, curEventTarget) {
    let pointerIndex = this.getPointerIndex(pointer);

    if (pointerIndex === -1) {
      pointerIndex = this.updatePointer(pointer, event, eventTarget, false);
    }

    const type = /cancel$/i.test(event.type) ? 'cancel' : 'up';

    this._scopeFire(`interactions:${type}`, {
      pointer,
      pointerIndex,
      pointerInfo: this.pointers[pointerIndex],
      event,
      eventTarget,
      type: type,
      curEventTarget,
      interaction: this
    });

    if (!this.simulation) {
      this.end(event);
    }

    this.removePointer(pointer, event);
  }

  documentBlur(event) {
    this.end(event);

    this._scopeFire('interactions:blur', {
      event,
      type: 'blur',
      interaction: this
    });
  }
  /**
   * ```js
   * interact(target)
   *   .draggable(true)
   *   .on('move', function (event) {
   *     if (event.pageX > 1000) {
   *       // end the current action
   *       event.interaction.end()
   *       // stop all further listeners from being called
   *       event.stopImmediatePropagation()
   *     }
   *   })
   * ```
   *
   * @param {PointerEvent} [event]
   */


  end(event) {
    this._ending = true;
    event = event || this._latestPointer.event;
    let endPhaseResult;

    if (this.interacting()) {
      endPhaseResult = this._doPhase({
        event,
        interaction: this,
        phase: 'end'
      });
    }

    this._ending = false;

    if (endPhaseResult === true) {
      this.stop();
    }
  }

  currentAction() {
    return this._interacting ? this.prepared.name : null;
  }

  interacting() {
    return this._interacting;
  }
  /** */


  stop() {
    this._scopeFire('interactions:stop', {
      interaction: this
    });

    this.interactable = this.element = null;
    this._interacting = false;
    this._stopped = true;
    this.prepared.name = this.prevEvent = null;
  }

  getPointerIndex(pointer) {
    const pointerId = getPointerId(pointer); // mouse and pen interactions may have only one pointer

    return this.pointerType === 'mouse' || this.pointerType === 'pen' ? this.pointers.length - 1 : findIndex(this.pointers, curPointer => curPointer.id === pointerId);
  }

  getPointerInfo(pointer) {
    return this.pointers[this.getPointerIndex(pointer)];
  }

  updatePointer(pointer, event, eventTarget, down) {
    const id = getPointerId(pointer);
    let pointerIndex = this.getPointerIndex(pointer);
    let pointerInfo = this.pointers[pointerIndex];
    down = down === false ? false : down || /(down|start)$/i.test(event.type);

    if (!pointerInfo) {
      pointerInfo = new PointerInfo(id, pointer, event, null, null);
      pointerIndex = this.pointers.length;
      this.pointers.push(pointerInfo);
    } else {
      pointerInfo.pointer = pointer;
    }

    setCoords(this.coords.cur, this.pointers.map(p => p.pointer), this._now());
    setCoordDeltas(this.coords.delta, this.coords.prev, this.coords.cur);

    if (down) {
      this.pointerIsDown = true;
      pointerInfo.downTime = this.coords.cur.timeStamp;
      pointerInfo.downTarget = eventTarget;
      utils_pointerExtend(this.downPointer, pointer);

      if (!this.interacting()) {
        copyCoords(this.coords.start, this.coords.cur);
        copyCoords(this.coords.prev, this.coords.cur);
        this.downEvent = event;
        this.pointerWasMoved = false;
      }
    }

    this._updateLatestPointer(pointer, event, eventTarget);

    this._scopeFire('interactions:update-pointer', {
      pointer,
      event,
      eventTarget,
      down,
      pointerInfo,
      pointerIndex,
      interaction: this
    });

    return pointerIndex;
  }

  removePointer(pointer, event) {
    const pointerIndex = this.getPointerIndex(pointer);

    if (pointerIndex === -1) {
      return;
    }

    const pointerInfo = this.pointers[pointerIndex];

    this._scopeFire('interactions:remove-pointer', {
      pointer,
      event,
      eventTarget: null,
      pointerIndex,
      pointerInfo,
      interaction: this
    });

    this.pointers.splice(pointerIndex, 1);
    this.pointerIsDown = false;
  }

  _updateLatestPointer(pointer, event, eventTarget) {
    this._latestPointer.pointer = pointer;
    this._latestPointer.event = event;
    this._latestPointer.eventTarget = eventTarget;
  }

  destroy() {
    this._latestPointer.pointer = null;
    this._latestPointer.event = null;
    this._latestPointer.eventTarget = null;
  }

  _createPreparedEvent(event, phase, preEnd, type) {
    return new InteractEvent_InteractEvent(this, event, this.prepared.name, phase, this.element, preEnd, type);
  }

  _fireEvent(iEvent) {
    this.interactable.fire(iEvent);

    if (!this.prevEvent || iEvent.timeStamp >= this.prevEvent.timeStamp) {
      this.prevEvent = iEvent;
    }
  }

  _doPhase(signalArg) {
    const {
      event,
      phase,
      preEnd,
      type
    } = signalArg;
    const {
      rect
    } = this;

    if (rect && phase === 'move') {
      // update the rect changes due to pointer move
      addEdges(this.edges, rect, this.coords.delta[this.interactable.options.deltaSource]);
      rect.width = rect.right - rect.left;
      rect.height = rect.bottom - rect.top;
    }

    const beforeResult = this._scopeFire(`interactions:before-action-${phase}`, signalArg);

    if (beforeResult === false) {
      return false;
    }

    const iEvent = signalArg.iEvent = this._createPreparedEvent(event, phase, preEnd, type);

    this._scopeFire(`interactions:action-${phase}`, signalArg);

    if (phase === 'start') {
      this.prevEvent = iEvent;
    }

    this._fireEvent(iEvent);

    this._scopeFire(`interactions:after-action-${phase}`, signalArg);

    return true;
  }

  _now() {
    return Date.now();
  }

}
/* harmony default export */ var core_Interaction = (Interaction_Interaction);

//# sourceMappingURL=Interaction.js.map
// CONCATENATED MODULE: ./node_modules/@interactjs/core/interactablePreventDefault.js





function preventDefault(newValue) {
  if (/^(always|never|auto)$/.test(newValue)) {
    this.options.preventDefault = newValue;
    return this;
  }

  if (is.bool(newValue)) {
    this.options.preventDefault = newValue ? 'always' : 'never';
    return this;
  }

  return this.options.preventDefault;
}

function checkAndPreventDefault(interactable, scope, event) {
  const setting = interactable.options.preventDefault;

  if (setting === 'never') {
    return;
  }

  if (setting === 'always') {
    event.preventDefault();
    return;
  } // setting === 'auto'
  // if the browser supports passive event listeners and isn't running on iOS,
  // don't preventDefault of touch{start,move} events. CSS touch-action and
  // user-select should be used instead of calling event.preventDefault().


  if (scope.events.supportsPassive && /^touch(start|move)$/.test(event.type)) {
    const doc = getWindow(event.target).document;
    const docOptions = scope.getDocOptions(doc);

    if (!(docOptions && docOptions.events) || docOptions.events.passive !== false) {
      return;
    }
  } // don't preventDefault of pointerdown events


  if (/^(mouse|pointer|touch)*(down|start)/i.test(event.type)) {
    return;
  } // don't preventDefault on editable elements


  if (is.element(event.target) && matchesSelector(event.target, 'input,select,textarea,[contenteditable=true],[contenteditable=true] *')) {
    return;
  }

  event.preventDefault();
}

function onInteractionEvent({
  interaction,
  event
}) {
  if (interaction.interactable) {
    interaction.interactable.checkAndPreventDefault(event);
  }
}

function interactablePreventDefault_install(scope) {
  /** @lends Interactable */
  const {
    Interactable
  } = scope;
  /**
   * Returns or sets whether to prevent the browser's default behaviour in
   * response to pointer events. Can be set to:
   *  - `'always'` to always prevent
   *  - `'never'` to never prevent
   *  - `'auto'` to let interact.js try to determine what would be best
   *
   * @param {string} [newValue] `'always'`, `'never'` or `'auto'`
   * @return {string | Interactable} The current setting or this Interactable
   */

  Interactable.prototype.preventDefault = preventDefault;

  Interactable.prototype.checkAndPreventDefault = function (event) {
    return checkAndPreventDefault(this, scope, event);
  }; // prevent native HTML5 drag on interact.js target elements


  scope.interactions.docEvents.push({
    type: 'dragstart',

    listener(event) {
      for (const interaction of scope.interactions.list) {
        if (interaction.element && (interaction.element === event.target || nodeContains(interaction.element, event.target))) {
          interaction.interactable.checkAndPreventDefault(event);
          return;
        }
      }
    }

  });
}
/* harmony default export */ var interactablePreventDefault = ({
  id: 'core/interactablePreventDefault',
  install: interactablePreventDefault_install,
  listeners: ['down', 'move', 'up', 'cancel'].reduce((acc, eventType) => {
    acc[`interactions:${eventType}`] = onInteractionEvent;
    return acc;
  }, {})
});
//# sourceMappingURL=interactablePreventDefault.js.map
// CONCATENATED MODULE: ./node_modules/@interactjs/core/interactionFinder.js

const finder = {
  methodOrder: ['simulationResume', 'mouseOrPen', 'hasPointer', 'idle'],

  search(details) {
    for (const method of finder.methodOrder) {
      const interaction = finder[method](details);

      if (interaction) {
        return interaction;
      }
    }

    return null;
  },

  // try to resume simulation with a new pointer
  simulationResume({
    pointerType,
    eventType,
    eventTarget,
    scope
  }) {
    if (!/down|start/i.test(eventType)) {
      return null;
    }

    for (const interaction of scope.interactions.list) {
      let element = eventTarget;

      if (interaction.simulation && interaction.simulation.allowResume && interaction.pointerType === pointerType) {
        while (element) {
          // if the element is the interaction element
          if (element === interaction.element) {
            return interaction;
          }

          element = parentNode(element);
        }
      }
    }

    return null;
  },

  // if it's a mouse or pen interaction
  mouseOrPen({
    pointerId,
    pointerType,
    eventType,
    scope
  }) {
    if (pointerType !== 'mouse' && pointerType !== 'pen') {
      return null;
    }

    let firstNonActive;

    for (const interaction of scope.interactions.list) {
      if (interaction.pointerType === pointerType) {
        // if it's a down event, skip interactions with running simulations
        if (interaction.simulation && !hasPointerId(interaction, pointerId)) {
          continue;
        } // if the interaction is active, return it immediately


        if (interaction.interacting()) {
          return interaction;
        } // otherwise save it and look for another active interaction
        else if (!firstNonActive) {
            firstNonActive = interaction;
          }
      }
    } // if no active mouse interaction was found use the first inactive mouse
    // interaction


    if (firstNonActive) {
      return firstNonActive;
    } // find any mouse or pen interaction.
    // ignore the interaction if the eventType is a *down, and a simulation
    // is active


    for (const interaction of scope.interactions.list) {
      if (interaction.pointerType === pointerType && !(/down/i.test(eventType) && interaction.simulation)) {
        return interaction;
      }
    }

    return null;
  },

  // get interaction that has this pointer
  hasPointer({
    pointerId,
    scope
  }) {
    for (const interaction of scope.interactions.list) {
      if (hasPointerId(interaction, pointerId)) {
        return interaction;
      }
    }

    return null;
  },

  // get first idle interaction with a matching pointerType
  idle({
    pointerType,
    scope
  }) {
    for (const interaction of scope.interactions.list) {
      // if there's already a pointer held down
      if (interaction.pointers.length === 1) {
        const target = interaction.interactable; // don't add this pointer if there is a target interactable and it
        // isn't gesturable

        if (target && !(target.options.gesture && target.options.gesture.enabled)) {
          continue;
        }
      } // maximum of 2 pointers per interaction
      else if (interaction.pointers.length >= 2) {
          continue;
        }

      if (!interaction.interacting() && pointerType === interaction.pointerType) {
        return interaction;
      }
    }

    return null;
  }

};

function hasPointerId(interaction, pointerId) {
  return interaction.pointers.some(({
    id
  }) => id === pointerId);
}

/* harmony default export */ var interactionFinder = (finder);
//# sourceMappingURL=interactionFinder.js.map
// CONCATENATED MODULE: ./node_modules/@interactjs/core/interactions.js








const methodNames = ['pointerDown', 'pointerMove', 'pointerUp', 'updatePointer', 'removePointer', 'windowBlur'];

function interactions_install(scope) {
  const listeners = {};

  for (const method of methodNames) {
    listeners[method] = doOnInteractions(method, scope);
  }

  const pEventTypes = utils_browser.pEventTypes;
  let docEvents;

  if (utils_domObjects.PointerEvent) {
    docEvents = [{
      type: pEventTypes.down,
      listener: releasePointersOnRemovedEls
    }, {
      type: pEventTypes.down,
      listener: listeners.pointerDown
    }, {
      type: pEventTypes.move,
      listener: listeners.pointerMove
    }, {
      type: pEventTypes.up,
      listener: listeners.pointerUp
    }, {
      type: pEventTypes.cancel,
      listener: listeners.pointerUp
    }];
  } else {
    docEvents = [{
      type: 'mousedown',
      listener: listeners.pointerDown
    }, {
      type: 'mousemove',
      listener: listeners.pointerMove
    }, {
      type: 'mouseup',
      listener: listeners.pointerUp
    }, {
      type: 'touchstart',
      listener: releasePointersOnRemovedEls
    }, {
      type: 'touchstart',
      listener: listeners.pointerDown
    }, {
      type: 'touchmove',
      listener: listeners.pointerMove
    }, {
      type: 'touchend',
      listener: listeners.pointerUp
    }, {
      type: 'touchcancel',
      listener: listeners.pointerUp
    }];
  }

  docEvents.push({
    type: 'blur',

    listener(event) {
      for (const interaction of scope.interactions.list) {
        interaction.documentBlur(event);
      }
    }

  }); // for ignoring browser's simulated mouse events

  scope.prevTouchTime = 0;
  scope.Interaction = class extends core_Interaction {
    get pointerMoveTolerance() {
      return scope.interactions.pointerMoveTolerance;
    }

    set pointerMoveTolerance(value) {
      scope.interactions.pointerMoveTolerance = value;
    }

    _now() {
      return scope.now();
    }

  };
  scope.interactions = {
    // all active and idle interactions
    list: [],

    new(options) {
      options.scopeFire = (name, arg) => scope.fire(name, arg);

      const interaction = new scope.Interaction(options);
      scope.interactions.list.push(interaction);
      return interaction;
    },

    listeners,
    docEvents,
    pointerMoveTolerance: 1
  };

  function releasePointersOnRemovedEls() {
    // for all inactive touch interactions with pointers down
    for (const interaction of scope.interactions.list) {
      if (!interaction.pointerIsDown || interaction.pointerType !== 'touch' || interaction._interacting) {
        continue;
      } // if a pointer is down on an element that is no longer in the DOM tree


      for (const pointer of interaction.pointers) {
        if (!scope.documents.some(({
          doc
        }) => nodeContains(doc, pointer.downTarget))) {
          // remove the pointer from the interaction
          interaction.removePointer(pointer.pointer, pointer.event);
        }
      }
    }
  }

  scope.usePlugin(interactablePreventDefault);
}

function doOnInteractions(method, scope) {
  return function (event) {
    const interactions = scope.interactions.list;
    const pointerType = getPointerType(event);
    const [eventTarget, curEventTarget] = getEventTargets(event);
    const matches = []; // [ [pointer, interaction], ...]

    if (/^touch/.test(event.type)) {
      scope.prevTouchTime = scope.now(); // @ts-expect-error

      for (const changedTouch of event.changedTouches) {
        const pointer = changedTouch;
        const pointerId = getPointerId(pointer);
        const searchDetails = {
          pointer,
          pointerId,
          pointerType,
          eventType: event.type,
          eventTarget,
          curEventTarget,
          scope
        };
        const interaction = getInteraction(searchDetails);
        matches.push([searchDetails.pointer, searchDetails.eventTarget, searchDetails.curEventTarget, interaction]);
      }
    } else {
      let invalidPointer = false;

      if (!utils_browser.supportsPointerEvent && /mouse/.test(event.type)) {
        // ignore mouse events while touch interactions are active
        for (let i = 0; i < interactions.length && !invalidPointer; i++) {
          invalidPointer = interactions[i].pointerType !== 'mouse' && interactions[i].pointerIsDown;
        } // try to ignore mouse events that are simulated by the browser
        // after a touch event


        invalidPointer = invalidPointer || scope.now() - scope.prevTouchTime < 500 || // on iOS and Firefox Mobile, MouseEvent.timeStamp is zero if simulated
        event.timeStamp === 0;
      }

      if (!invalidPointer) {
        const searchDetails = {
          pointer: event,
          pointerId: getPointerId(event),
          pointerType,
          eventType: event.type,
          curEventTarget,
          eventTarget,
          scope
        };
        const interaction = getInteraction(searchDetails);
        matches.push([searchDetails.pointer, searchDetails.eventTarget, searchDetails.curEventTarget, interaction]);
      }
    } // eslint-disable-next-line no-shadow


    for (const [pointer, eventTarget, curEventTarget, interaction] of matches) {
      interaction[method](pointer, event, eventTarget, curEventTarget);
    }
  };
}

function getInteraction(searchDetails) {
  const {
    pointerType,
    scope
  } = searchDetails;
  const foundInteraction = interactionFinder.search(searchDetails);
  const signalArg = {
    interaction: foundInteraction,
    searchDetails
  };
  scope.fire('interactions:find', signalArg);
  return signalArg.interaction || scope.interactions.new({
    pointerType
  });
}

function onDocSignal({
  doc,
  scope,
  options
}, eventMethodName) {
  const {
    interactions: {
      docEvents
    },
    events
  } = scope;
  const eventMethod = events[eventMethodName];

  if (scope.browser.isIOS && !options.events) {
    options.events = {
      passive: false
    };
  } // delegate event listener


  for (const eventType in events.delegatedEvents) {
    eventMethod(doc, eventType, events.delegateListener);
    eventMethod(doc, eventType, events.delegateUseCapture, true);
  }

  const eventOptions = options && options.events;

  for (const {
    type,
    listener
  } of docEvents) {
    eventMethod(doc, type, listener, eventOptions);
  }
}

const interactions_interactions = {
  id: 'core/interactions',
  install: interactions_install,
  listeners: {
    'scope:add-document': arg => onDocSignal(arg, 'add'),
    'scope:remove-document': arg => onDocSignal(arg, 'remove'),
    'interactable:unset': ({
      interactable
    }, scope) => {
      // Stop and destroy related interactions when an Interactable is unset
      for (let i = scope.interactions.list.length - 1; i >= 0; i--) {
        const interaction = scope.interactions.list[i];

        if (interaction.interactable !== interactable) {
          continue;
        }

        interaction.stop();
        scope.fire('interactions:destroy', {
          interaction
        });
        interaction.destroy();

        if (scope.interactions.list.length > 2) {
          scope.interactions.list.splice(i, 1);
        }
      }
    }
  },
  onDocSignal,
  doOnInteractions,
  methodNames
};
/* harmony default export */ var core_interactions = (interactions_interactions);
//# sourceMappingURL=interactions.js.map
// CONCATENATED MODULE: ./node_modules/@interactjs/core/scope.js














class scope_Scope {
  // main window
  // main document
  // main window
  // all documents being listened to
  constructor() {
    this.id = `__interact_scope_${Math.floor(Math.random() * 100)}`;
    this.isInitialized = false;
    this.listenerMaps = [];
    this.browser = utils_browser;
    this.defaults = clone(defaultOptions_defaults);
    this.Eventable = Eventable_Eventable;
    this.actions = {
      map: {},
      phases: {
        start: true,
        move: true,
        end: true
      },
      methodDict: {},
      phaselessTypes: {}
    };
    this.interactStatic = createInteractStatic(this);
    this.InteractEvent = InteractEvent_InteractEvent;
    this.Interactable = void 0;
    this.interactables = new InteractableSet_InteractableSet(this);
    this._win = void 0;
    this.document = void 0;
    this.window = void 0;
    this.documents = [];
    this._plugins = {
      list: [],
      map: {}
    };

    this.onWindowUnload = event => this.removeDocument(event.target);

    const scope = this;
    this.Interactable = class extends Interactable_Interactable {
      get _defaults() {
        return scope.defaults;
      }

      set(options) {
        super.set(options);
        scope.fire('interactable:set', {
          options,
          interactable: this
        });
        return this;
      }

      unset() {
        super.unset();
        scope.interactables.list.splice(scope.interactables.list.indexOf(this), 1);
        scope.fire('interactable:unset', {
          interactable: this
        });
      }

    };
  }

  addListeners(map, id) {
    this.listenerMaps.push({
      id,
      map
    });
  }

  fire(name, arg) {
    for (const {
      map: {
        [name]: listener
      }
    } of this.listenerMaps) {
      if (!!listener && listener(arg, this, name) === false) {
        return false;
      }
    }
  }

  init(window) {
    return this.isInitialized ? this : initScope(this, window);
  }

  pluginIsInstalled(plugin) {
    return this._plugins.map[plugin.id] || this._plugins.list.indexOf(plugin) !== -1;
  }

  usePlugin(plugin, options) {
    if (!this.isInitialized) {
      return this;
    }

    if (this.pluginIsInstalled(plugin)) {
      return this;
    }

    if (plugin.id) {
      this._plugins.map[plugin.id] = plugin;
    }

    this._plugins.list.push(plugin);

    if (plugin.install) {
      plugin.install(this, options);
    }

    if (plugin.listeners && plugin.before) {
      let index = 0;
      const len = this.listenerMaps.length;
      const before = plugin.before.reduce((acc, id) => {
        acc[id] = true;
        acc[pluginIdRoot(id)] = true;
        return acc;
      }, {});

      for (; index < len; index++) {
        const otherId = this.listenerMaps[index].id;

        if (before[otherId] || before[pluginIdRoot(otherId)]) {
          break;
        }
      }

      this.listenerMaps.splice(index, 0, {
        id: plugin.id,
        map: plugin.listeners
      });
    } else if (plugin.listeners) {
      this.listenerMaps.push({
        id: plugin.id,
        map: plugin.listeners
      });
    }

    return this;
  }

  addDocument(doc, options) {
    // do nothing if document is already known
    if (this.getDocIndex(doc) !== -1) {
      return false;
    }

    const window = getWindow(doc);
    options = options ? extend({}, options) : {};
    this.documents.push({
      doc,
      options
    });
    this.events.documents.push(doc); // don't add an unload event for the main document
    // so that the page may be cached in browser history

    if (doc !== this.document) {
      this.events.add(window, 'unload', this.onWindowUnload);
    }

    this.fire('scope:add-document', {
      doc,
      window,
      scope: this,
      options
    });
  }

  removeDocument(doc) {
    const index = this.getDocIndex(doc);
    const window = getWindow(doc);
    const options = this.documents[index].options;
    this.events.remove(window, 'unload', this.onWindowUnload);
    this.documents.splice(index, 1);
    this.events.documents.splice(index, 1);
    this.fire('scope:remove-document', {
      doc,
      window,
      scope: this,
      options
    });
  }

  getDocIndex(doc) {
    for (let i = 0; i < this.documents.length; i++) {
      if (this.documents[i].doc === doc) {
        return i;
      }
    }

    return -1;
  }

  getDocOptions(doc) {
    const docIndex = this.getDocIndex(doc);
    return docIndex === -1 ? null : this.documents[docIndex].options;
  }

  now() {
    return (this.window.Date || Date).now();
  }

}
function initScope(scope, window) {
  scope.isInitialized = true;
  window_init(window);
  utils_domObjects.init(window);
  utils_browser.init(window);
  raf.init(window);
  scope.window = window;
  scope.document = window.document;
  scope.usePlugin(core_interactions);
  scope.usePlugin(events);
  return scope;
}

function pluginIdRoot(id) {
  return id && id.replace(/\/.*$/, '');
}
//# sourceMappingURL=scope.js.map
// CONCATENATED MODULE: ./node_modules/@interactjs/interact/index.js

const interact_scope = new scope_Scope();
const interact_interact = interact_scope.interactStatic;
/* harmony default export */ var _interactjs_interact = (interact_interact);
const interact_init = win => interact_scope.init(win);

if (typeof window === 'object' && !!window) {
  interact_init(window);
}
//# sourceMappingURL=index.js.map
// CONCATENATED MODULE: ./node_modules/@interactjs/auto-start/InteractableMethods.js




function InteractableMethods_install(scope) {
  const {
    /** @lends Interactable */
    Interactable // tslint:disable-line no-shadowed-variable

  } = scope;

  Interactable.prototype.getAction = function getAction(pointer, event, interaction, element) {
    const action = defaultActionChecker(this, event, interaction, element, scope);

    if (this.options.actionChecker) {
      return this.options.actionChecker(pointer, event, action, this, element, interaction);
    }

    return action;
  };
  /**
   * If the target of the `mousedown`, `pointerdown` or `touchstart` event or any
   * of it's parents match the given CSS selector or Element, no
   * drag/resize/gesture is started.
   *
   * @deprecated
   * Don't use this method. Instead set the `ignoreFrom` option for each action
   * or for `pointerEvents`
   *
   * ```js
   * interact(targett)
   *   .draggable({
   *     ignoreFrom: 'input, textarea, a[href]'',
   *   })
   *   .pointerEvents({
   *     ignoreFrom: '[no-pointer]',
   *   })
   * ```
   *
   * @param {string | Element | null} [newValue] a CSS selector string, an
   * Element or `null` to not ignore any elements
   * @return {string | Element | object} The current ignoreFrom value or this
   * Interactable
   */


  Interactable.prototype.ignoreFrom = warnOnce(function (newValue) {
    return this._backCompatOption('ignoreFrom', newValue);
  }, 'Interactable.ignoreFrom() has been deprecated. Use Interactble.draggable({ignoreFrom: newValue}).');
  /**
   *
   * A drag/resize/gesture is started only If the target of the `mousedown`,
   * `pointerdown` or `touchstart` event or any of it's parents match the given
   * CSS selector or Element.
   *
   * @deprecated
   * Don't use this method. Instead set the `allowFrom` option for each action
   * or for `pointerEvents`
   *
   * ```js
   * interact(targett)
   *   .resizable({
   *     allowFrom: '.resize-handle',
   *   .pointerEvents({
   *     allowFrom: '.handle',,
   *   })
   * ```
   *
   * @param {string | Element | null} [newValue] a CSS selector string, an
   * Element or `null` to allow from any element
   * @return {string | Element | object} The current allowFrom value or this
   * Interactable
   */

  Interactable.prototype.allowFrom = warnOnce(function (newValue) {
    return this._backCompatOption('allowFrom', newValue);
  }, 'Interactable.allowFrom() has been deprecated. Use Interactble.draggable({allowFrom: newValue}).');
  /**
   * ```js
   * interact('.resize-drag')
   *   .resizable(true)
   *   .draggable(true)
   *   .actionChecker(function (pointer, event, action, interactable, element, interaction) {
   *
   *     if (interact.matchesSelector(event.target, '.drag-handle')) {
   *       // force drag with handle target
   *       action.name = drag
   *     }
   *     else {
   *       // resize from the top and right edges
   *       action.name  = 'resize'
   *       action.edges = { top: true, right: true }
   *     }
   *
   *     return action
   * })
   * ```
   *
   * Returns or sets the function used to check action to be performed on
   * pointerDown
   *
   * @param {function | null} [checker] A function which takes a pointer event,
   * defaultAction string, interactable, element and interaction as parameters
   * and returns an object with name property 'drag' 'resize' or 'gesture' and
   * optionally an `edges` object with boolean 'top', 'left', 'bottom' and right
   * props.
   * @return {Function | Interactable} The checker function or this Interactable
   */

  Interactable.prototype.actionChecker = actionChecker;
  /**
   * Returns or sets whether the the cursor should be changed depending on the
   * action that would be performed if the mouse were pressed and dragged.
   *
   * @param {boolean} [newValue]
   * @return {boolean | Interactable} The current setting or this Interactable
   */

  Interactable.prototype.styleCursor = styleCursor;
}

function defaultActionChecker(interactable, event, interaction, element, scope) {
  const rect = interactable.getRect(element);
  const buttons = event.buttons || {
    0: 1,
    1: 4,
    3: 8,
    4: 16
  }[event.button];
  const arg = {
    action: null,
    interactable,
    interaction,
    element,
    rect,
    buttons
  };
  scope.fire('auto-start:check', arg);
  return arg.action;
}

function styleCursor(newValue) {
  if (is.bool(newValue)) {
    this.options.styleCursor = newValue;
    return this;
  }

  if (newValue === null) {
    delete this.options.styleCursor;
    return this;
  }

  return this.options.styleCursor;
}

function actionChecker(checker) {
  if (is.func(checker)) {
    this.options.actionChecker = checker;
    return this;
  }

  if (checker === null) {
    delete this.options.actionChecker;
    return this;
  }

  return this.options.actionChecker;
}

/* harmony default export */ var InteractableMethods = ({
  id: 'auto-start/interactableMethods',
  install: InteractableMethods_install
});
//# sourceMappingURL=InteractableMethods.js.map
// CONCATENATED MODULE: ./node_modules/@interactjs/auto-start/base.js







function base_install(scope) {
  const {
    interactStatic: interact,
    defaults
  } = scope;
  scope.usePlugin(InteractableMethods);
  defaults.base.actionChecker = null;
  defaults.base.styleCursor = true;
  extend(defaults.perAction, {
    manualStart: false,
    max: Infinity,
    maxPerElement: 1,
    allowFrom: null,
    ignoreFrom: null,
    // only allow left button by default
    // see https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent/buttons#Return_value
    mouseButtons: 1
  });
  /**
   * Returns or sets the maximum number of concurrent interactions allowed.  By
   * default only 1 interaction is allowed at a time (for backwards
   * compatibility). To allow multiple interactions on the same Interactables and
   * elements, you need to enable it in the draggable, resizable and gesturable
   * `'max'` and `'maxPerElement'` options.
   *
   * @alias module:interact.maxInteractions
   *
   * @param {number} [newValue] Any number. newValue <= 0 means no interactions.
   */

  interact.maxInteractions = newValue => maxInteractions(newValue, scope);

  scope.autoStart = {
    // Allow this many interactions to happen simultaneously
    maxInteractions: Infinity,
    withinInteractionLimit,
    cursorElement: null
  };
}

function prepareOnDown({
  interaction,
  pointer,
  event,
  eventTarget
}, scope) {
  if (interaction.interacting()) {
    return;
  }

  const actionInfo = getActionInfo(interaction, pointer, event, eventTarget, scope);
  prepare(interaction, actionInfo, scope);
}

function prepareOnMove({
  interaction,
  pointer,
  event,
  eventTarget
}, scope) {
  if (interaction.pointerType !== 'mouse' || interaction.pointerIsDown || interaction.interacting()) {
    return;
  }

  const actionInfo = getActionInfo(interaction, pointer, event, eventTarget, scope);
  prepare(interaction, actionInfo, scope);
}

function startOnMove(arg, scope) {
  const {
    interaction
  } = arg;

  if (!interaction.pointerIsDown || interaction.interacting() || !interaction.pointerWasMoved || !interaction.prepared.name) {
    return;
  }

  scope.fire('autoStart:before-start', arg);
  const {
    interactable
  } = interaction;
  const actionName = interaction.prepared.name;

  if (actionName && interactable) {
    // check manualStart and interaction limit
    if (interactable.options[actionName].manualStart || !withinInteractionLimit(interactable, interaction.element, interaction.prepared, scope)) {
      interaction.stop();
    } else {
      interaction.start(interaction.prepared, interactable, interaction.element);
      setInteractionCursor(interaction, scope);
    }
  }
}

function clearCursorOnStop({
  interaction
}, scope) {
  const {
    interactable
  } = interaction;

  if (interactable && interactable.options.styleCursor) {
    setCursor(interaction.element, '', scope);
  }
} // Check if the current interactable supports the action.
// If so, return the validated action. Otherwise, return null


function validateAction(action, interactable, element, eventTarget, scope) {
  if (interactable.testIgnoreAllow(interactable.options[action.name], element, eventTarget) && interactable.options[action.name].enabled && withinInteractionLimit(interactable, element, action, scope)) {
    return action;
  }

  return null;
}

function validateMatches(interaction, pointer, event, matches, matchElements, eventTarget, scope) {
  for (let i = 0, len = matches.length; i < len; i++) {
    const match = matches[i];
    const matchElement = matchElements[i];
    const matchAction = match.getAction(pointer, event, interaction, matchElement);

    if (!matchAction) {
      continue;
    }

    const action = validateAction(matchAction, match, matchElement, eventTarget, scope);

    if (action) {
      return {
        action,
        interactable: match,
        element: matchElement
      };
    }
  }

  return {
    action: null,
    interactable: null,
    element: null
  };
}

function getActionInfo(interaction, pointer, event, eventTarget, scope) {
  let matches = [];
  let matchElements = [];
  let element = eventTarget;

  function pushMatches(interactable) {
    matches.push(interactable);
    matchElements.push(element);
  }

  while (is.element(element)) {
    matches = [];
    matchElements = [];
    scope.interactables.forEachMatch(element, pushMatches);
    const actionInfo = validateMatches(interaction, pointer, event, matches, matchElements, eventTarget, scope);

    if (actionInfo.action && !actionInfo.interactable.options[actionInfo.action.name].manualStart) {
      return actionInfo;
    }

    element = parentNode(element);
  }

  return {
    action: null,
    interactable: null,
    element: null
  };
}

function prepare(interaction, {
  action,
  interactable,
  element
}, scope) {
  action = action || {
    name: null
  };
  interaction.interactable = interactable;
  interaction.element = element;
  copyAction(interaction.prepared, action);
  interaction.rect = interactable && action.name ? interactable.getRect(element) : null;
  setInteractionCursor(interaction, scope);
  scope.fire('autoStart:prepared', {
    interaction
  });
}

function withinInteractionLimit(interactable, element, action, scope) {
  const options = interactable.options;
  const maxActions = options[action.name].max;
  const maxPerElement = options[action.name].maxPerElement;
  const autoStartMax = scope.autoStart.maxInteractions;
  let activeInteractions = 0;
  let interactableCount = 0;
  let elementCount = 0; // no actions if any of these values == 0

  if (!(maxActions && maxPerElement && autoStartMax)) {
    return false;
  }

  for (const interaction of scope.interactions.list) {
    const otherAction = interaction.prepared.name;

    if (!interaction.interacting()) {
      continue;
    }

    activeInteractions++;

    if (activeInteractions >= autoStartMax) {
      return false;
    }

    if (interaction.interactable !== interactable) {
      continue;
    }

    interactableCount += otherAction === action.name ? 1 : 0;

    if (interactableCount >= maxActions) {
      return false;
    }

    if (interaction.element === element) {
      elementCount++;

      if (otherAction === action.name && elementCount >= maxPerElement) {
        return false;
      }
    }
  }

  return autoStartMax > 0;
}

function maxInteractions(newValue, scope) {
  if (is.number(newValue)) {
    scope.autoStart.maxInteractions = newValue;
    return this;
  }

  return scope.autoStart.maxInteractions;
}

function setCursor(element, cursor, scope) {
  const {
    cursorElement: prevCursorElement
  } = scope.autoStart;

  if (prevCursorElement && prevCursorElement !== element) {
    prevCursorElement.style.cursor = '';
  }

  element.ownerDocument.documentElement.style.cursor = cursor;
  element.style.cursor = cursor;
  scope.autoStart.cursorElement = cursor ? element : null;
}

function setInteractionCursor(interaction, scope) {
  const {
    interactable,
    element,
    prepared
  } = interaction;

  if (!(interaction.pointerType === 'mouse' && interactable && interactable.options.styleCursor)) {
    // clear previous target element cursor
    if (scope.autoStart.cursorElement) {
      setCursor(scope.autoStart.cursorElement, '', scope);
    }

    return;
  }

  let cursor = '';

  if (prepared.name) {
    const cursorChecker = interactable.options[prepared.name].cursorChecker;

    if (is.func(cursorChecker)) {
      cursor = cursorChecker(prepared, interactable, element, interaction._interacting);
    } else {
      cursor = scope.actions.map[prepared.name].getCursor(prepared);
    }
  }

  setCursor(interaction.element, cursor || '', scope);
}

const autoStart = {
  id: 'auto-start/base',
  before: ['actions'],
  install: base_install,
  listeners: {
    'interactions:down': prepareOnDown,
    'interactions:move': (arg, scope) => {
      prepareOnMove(arg, scope);
      startOnMove(arg, scope);
    },
    'interactions:stop': clearCursorOnStop
  },
  maxInteractions,
  withinInteractionLimit,
  validateAction
};
/* harmony default export */ var base = (autoStart);
//# sourceMappingURL=base.js.map
// CONCATENATED MODULE: ./node_modules/@interactjs/auto-start/dragAxis.js




function beforeStart({
  interaction,
  eventTarget,
  dx,
  dy
}, scope) {
  if (interaction.prepared.name !== 'drag') {
    return;
  } // check if a drag is in the correct axis


  const absX = Math.abs(dx);
  const absY = Math.abs(dy);
  const targetOptions = interaction.interactable.options.drag;
  const startAxis = targetOptions.startAxis;
  const currentAxis = absX > absY ? 'x' : absX < absY ? 'y' : 'xy';
  interaction.prepared.axis = targetOptions.lockAxis === 'start' ? currentAxis[0] // always lock to one axis even if currentAxis === 'xy'
  : targetOptions.lockAxis; // if the movement isn't in the startAxis of the interactable

  if (currentAxis !== 'xy' && startAxis !== 'xy' && startAxis !== currentAxis) {
    // cancel the prepared action
    interaction.prepared.name = null; // then try to get a drag from another ineractable

    let element = eventTarget;

    const getDraggable = function (interactable) {
      if (interactable === interaction.interactable) {
        return;
      }

      const options = interaction.interactable.options.drag;

      if (!options.manualStart && interactable.testIgnoreAllow(options, element, eventTarget)) {
        const action = interactable.getAction(interaction.downPointer, interaction.downEvent, interaction, element);

        if (action && action.name === 'drag' && checkStartAxis(currentAxis, interactable) && base.validateAction(action, interactable, element, eventTarget, scope)) {
          return interactable;
        }
      }
    }; // check all interactables


    while (is.element(element)) {
      const interactable = scope.interactables.forEachMatch(element, getDraggable);

      if (interactable) {
        interaction.prepared.name = 'drag';
        interaction.interactable = interactable;
        interaction.element = element;
        break;
      }

      element = parentNode(element);
    }
  }
}

function checkStartAxis(startAxis, interactable) {
  if (!interactable) {
    return false;
  }

  const thisAxis = interactable.options.drag.startAxis;
  return startAxis === 'xy' || thisAxis === 'xy' || thisAxis === startAxis;
}

/* harmony default export */ var dragAxis = ({
  id: 'auto-start/dragAxis',
  listeners: {
    'autoStart:before-start': beforeStart
  }
});
//# sourceMappingURL=dragAxis.js.map
// CONCATENATED MODULE: ./node_modules/@interactjs/auto-start/hold.js



function hold_install(scope) {
  const {
    defaults
  } = scope;
  scope.usePlugin(base);
  defaults.perAction.hold = 0;
  defaults.perAction.delay = 0;
}

function getHoldDuration(interaction) {
  const actionName = interaction.prepared && interaction.prepared.name;

  if (!actionName) {
    return null;
  }

  const options = interaction.interactable.options;
  return options[actionName].hold || options[actionName].delay;
}

const hold = {
  id: 'auto-start/hold',
  install: hold_install,
  listeners: {
    'interactions:new': ({
      interaction
    }) => {
      interaction.autoStartHoldTimer = null;
    },
    'autoStart:prepared': ({
      interaction
    }) => {
      const hold = getHoldDuration(interaction);

      if (hold > 0) {
        interaction.autoStartHoldTimer = setTimeout(() => {
          interaction.start(interaction.prepared, interaction.interactable, interaction.element);
        }, hold);
      }
    },
    'interactions:move': ({
      interaction,
      duplicate
    }) => {
      if (interaction.autoStartHoldTimer && interaction.pointerWasMoved && !duplicate) {
        clearTimeout(interaction.autoStartHoldTimer);
        interaction.autoStartHoldTimer = null;
      }
    },
    // prevent regular down->move autoStart
    'autoStart:before-start': ({
      interaction
    }) => {
      const holdDuration = getHoldDuration(interaction);

      if (holdDuration > 0) {
        interaction.prepared.name = null;
      }
    }
  },
  getHoldDuration
};
/* harmony default export */ var auto_start_hold = (hold);
//# sourceMappingURL=hold.js.map
// CONCATENATED MODULE: ./node_modules/@interactjs/auto-start/plugin.js



/* harmony default export */ var auto_start_plugin = ({
  id: 'auto-start',

  install(scope) {
    scope.usePlugin(base);
    scope.usePlugin(auto_start_hold);
    scope.usePlugin(dragAxis);
  }

});
//# sourceMappingURL=plugin.js.map
// CONCATENATED MODULE: ./node_modules/@interactjs/auto-start/index.js
/* eslint-disable import/order, no-console, eol-last */



if (typeof window === 'object' && !!window) {
  interact_init(window);
}

_interactjs_interact.use(auto_start_plugin);
//# sourceMappingURL=index.js.map
// CONCATENATED MODULE: ./node_modules/@interactjs/actions/drag/plugin.js



function plugin_install(scope) {
  const {
    actions,
    Interactable,
    defaults
  } = scope;
  Interactable.prototype.draggable = drag.draggable;
  actions.map.drag = drag;
  actions.methodDict.drag = 'draggable';
  defaults.actions.drag = drag.defaults;
}

function beforeMove({
  interaction
}) {
  if (interaction.prepared.name !== 'drag') {
    return;
  }

  const axis = interaction.prepared.axis;

  if (axis === 'x') {
    interaction.coords.cur.page.y = interaction.coords.start.page.y;
    interaction.coords.cur.client.y = interaction.coords.start.client.y;
    interaction.coords.velocity.client.y = 0;
    interaction.coords.velocity.page.y = 0;
  } else if (axis === 'y') {
    interaction.coords.cur.page.x = interaction.coords.start.page.x;
    interaction.coords.cur.client.x = interaction.coords.start.client.x;
    interaction.coords.velocity.client.x = 0;
    interaction.coords.velocity.page.x = 0;
  }
}

function move({
  iEvent,
  interaction
}) {
  if (interaction.prepared.name !== 'drag') {
    return;
  }

  const axis = interaction.prepared.axis;

  if (axis === 'x' || axis === 'y') {
    const opposite = axis === 'x' ? 'y' : 'x';
    iEvent.page[opposite] = interaction.coords.start.page[opposite];
    iEvent.client[opposite] = interaction.coords.start.client[opposite];
    iEvent.delta[opposite] = 0;
  }
}
/**
 * ```js
 * interact(element).draggable({
 *     onstart: function (event) {},
 *     onmove : function (event) {},
 *     onend  : function (event) {},
 *
 *     // the axis in which the first movement must be
 *     // for the drag sequence to start
 *     // 'xy' by default - any direction
 *     startAxis: 'x' || 'y' || 'xy',
 *
 *     // 'xy' by default - don't restrict to one axis (move in any direction)
 *     // 'x' or 'y' to restrict movement to either axis
 *     // 'start' to restrict movement to the axis the drag started in
 *     lockAxis: 'x' || 'y' || 'xy' || 'start',
 *
 *     // max number of drags that can happen concurrently
 *     // with elements of this Interactable. Infinity by default
 *     max: Infinity,
 *
 *     // max number of drags that can target the same element+Interactable
 *     // 1 by default
 *     maxPerElement: 2
 * })
 *
 * var isDraggable = interact('element').draggable(); // true
 * ```
 *
 * Get or set whether drag actions can be performed on the target
 *
 * @alias Interactable.prototype.draggable
 *
 * @param {boolean | object} [options] true/false or An object with event
 * listeners to be fired on drag events (object makes the Interactable
 * draggable)
 * @return {boolean | Interactable} boolean indicating if this can be the
 * target of drag events, or this Interctable
 */


const plugin_draggable = function draggable(options) {
  if (is.object(options)) {
    this.options.drag.enabled = options.enabled !== false;
    this.setPerAction('drag', options);
    this.setOnEvents('drag', options);

    if (/^(xy|x|y|start)$/.test(options.lockAxis)) {
      this.options.drag.lockAxis = options.lockAxis;
    }

    if (/^(xy|x|y)$/.test(options.startAxis)) {
      this.options.drag.startAxis = options.startAxis;
    }

    return this;
  }

  if (is.bool(options)) {
    this.options.drag.enabled = options;
    return this;
  }

  return this.options.drag;
};

const drag = {
  id: 'actions/drag',
  install: plugin_install,
  listeners: {
    'interactions:before-action-move': beforeMove,
    'interactions:action-resume': beforeMove,
    // dragmove
    'interactions:action-move': move,
    'auto-start:check': arg => {
      const {
        interaction,
        interactable,
        buttons
      } = arg;
      const dragOptions = interactable.options.drag;

      if (!(dragOptions && dragOptions.enabled) || // check mouseButton setting if the pointer is down
      interaction.pointerIsDown && /mouse|pointer/.test(interaction.pointerType) && (buttons & interactable.options.drag.mouseButtons) === 0) {
        return undefined;
      }

      arg.action = {
        name: 'drag',
        axis: dragOptions.lockAxis === 'start' ? dragOptions.startAxis : dragOptions.lockAxis
      };
      return false;
    }
  },
  draggable: plugin_draggable,
  beforeMove,
  move,
  defaults: {
    startAxis: 'xy',
    lockAxis: 'xy'
  },

  getCursor() {
    return 'move';
  }

};
/* harmony default export */ var drag_plugin = (drag);
//# sourceMappingURL=plugin.js.map
// CONCATENATED MODULE: ./node_modules/@interactjs/actions/drag/index.js
/* eslint-disable import/order, no-console, eol-last */



if (typeof window === 'object' && !!window) {
  interact_init(window);
}

_interactjs_interact.use(drag_plugin);
//# sourceMappingURL=index.js.map
// CONCATENATED MODULE: ./node_modules/@interactjs/actions/resize/plugin.js






function resize_plugin_install(scope) {
  const {
    actions,
    browser,

    /** @lends Interactable */
    Interactable,
    // tslint:disable-line no-shadowed-variable
    defaults
  } = scope; // Less Precision with touch input

  resize.cursors = initCursors(browser);
  resize.defaultMargin = browser.supportsTouch || browser.supportsPointerEvent ? 20 : 10;
  /**
   * ```js
   * interact(element).resizable({
   *   onstart: function (event) {},
   *   onmove : function (event) {},
   *   onend  : function (event) {},
   *
   *   edges: {
   *     top   : true,       // Use pointer coords to check for resize.
   *     left  : false,      // Disable resizing from left edge.
   *     bottom: '.resize-s',// Resize if pointer target matches selector
   *     right : handleEl    // Resize if pointer target is the given Element
   *   },
   *
   *     // Width and height can be adjusted independently. When `true`, width and
   *     // height are adjusted at a 1:1 ratio.
   *     square: false,
   *
   *     // Width and height can be adjusted independently. When `true`, width and
   *     // height maintain the aspect ratio they had when resizing started.
   *     preserveAspectRatio: false,
   *
   *   // a value of 'none' will limit the resize rect to a minimum of 0x0
   *   // 'negate' will allow the rect to have negative width/height
   *   // 'reposition' will keep the width/height positive by swapping
   *   // the top and bottom edges and/or swapping the left and right edges
   *   invert: 'none' || 'negate' || 'reposition'
   *
   *   // limit multiple resizes.
   *   // See the explanation in the {@link Interactable.draggable} example
   *   max: Infinity,
   *   maxPerElement: 1,
   * })
   *
   * var isResizeable = interact(element).resizable()
   * ```
   *
   * Gets or sets whether resize actions can be performed on the target
   *
   * @param {boolean | object} [options] true/false or An object with event
   * listeners to be fired on resize events (object makes the Interactable
   * resizable)
   * @return {boolean | Interactable} A boolean indicating if this can be the
   * target of resize elements, or this Interactable
   */

  Interactable.prototype.resizable = function (options) {
    return resizable(this, options, scope);
  };

  actions.map.resize = resize;
  actions.methodDict.resize = 'resizable';
  defaults.actions.resize = resize.defaults;
}

function resizeChecker(arg) {
  const {
    interaction,
    interactable,
    element,
    rect,
    buttons
  } = arg;

  if (!rect) {
    return undefined;
  }

  const page = extend({}, interaction.coords.cur.page);
  const resizeOptions = interactable.options.resize;

  if (!(resizeOptions && resizeOptions.enabled) || // check mouseButton setting if the pointer is down
  interaction.pointerIsDown && /mouse|pointer/.test(interaction.pointerType) && (buttons & resizeOptions.mouseButtons) === 0) {
    return undefined;
  } // if using resize.edges


  if (is.object(resizeOptions.edges)) {
    const resizeEdges = {
      left: false,
      right: false,
      top: false,
      bottom: false
    };

    for (const edge in resizeEdges) {
      resizeEdges[edge] = checkResizeEdge(edge, resizeOptions.edges[edge], page, interaction._latestPointer.eventTarget, element, rect, resizeOptions.margin || resize.defaultMargin);
    }

    resizeEdges.left = resizeEdges.left && !resizeEdges.right;
    resizeEdges.top = resizeEdges.top && !resizeEdges.bottom;

    if (resizeEdges.left || resizeEdges.right || resizeEdges.top || resizeEdges.bottom) {
      arg.action = {
        name: 'resize',
        edges: resizeEdges
      };
    }
  } else {
    const right = resizeOptions.axis !== 'y' && page.x > rect.right - resize.defaultMargin;
    const bottom = resizeOptions.axis !== 'x' && page.y > rect.bottom - resize.defaultMargin;

    if (right || bottom) {
      arg.action = {
        name: 'resize',
        axes: (right ? 'x' : '') + (bottom ? 'y' : '')
      };
    }
  }

  return arg.action ? false : undefined;
}

function resizable(interactable, options, scope) {
  if (is.object(options)) {
    interactable.options.resize.enabled = options.enabled !== false;
    interactable.setPerAction('resize', options);
    interactable.setOnEvents('resize', options);

    if (is.string(options.axis) && /^x$|^y$|^xy$/.test(options.axis)) {
      interactable.options.resize.axis = options.axis;
    } else if (options.axis === null) {
      interactable.options.resize.axis = scope.defaults.actions.resize.axis;
    }

    if (is.bool(options.preserveAspectRatio)) {
      interactable.options.resize.preserveAspectRatio = options.preserveAspectRatio;
    } else if (is.bool(options.square)) {
      interactable.options.resize.square = options.square;
    }

    return interactable;
  }

  if (is.bool(options)) {
    interactable.options.resize.enabled = options;
    return interactable;
  }

  return interactable.options.resize;
}

function checkResizeEdge(name, value, page, element, interactableElement, rect, margin) {
  // false, '', undefined, null
  if (!value) {
    return false;
  } // true value, use pointer coords and element rect


  if (value === true) {
    // if dimensions are negative, "switch" edges
    const width = is.number(rect.width) ? rect.width : rect.right - rect.left;
    const height = is.number(rect.height) ? rect.height : rect.bottom - rect.top; // don't use margin greater than half the relevent dimension

    margin = Math.min(margin, Math.abs((name === 'left' || name === 'right' ? width : height) / 2));

    if (width < 0) {
      if (name === 'left') {
        name = 'right';
      } else if (name === 'right') {
        name = 'left';
      }
    }

    if (height < 0) {
      if (name === 'top') {
        name = 'bottom';
      } else if (name === 'bottom') {
        name = 'top';
      }
    }

    if (name === 'left') {
      return page.x < (width >= 0 ? rect.left : rect.right) + margin;
    }

    if (name === 'top') {
      return page.y < (height >= 0 ? rect.top : rect.bottom) + margin;
    }

    if (name === 'right') {
      return page.x > (width >= 0 ? rect.right : rect.left) - margin;
    }

    if (name === 'bottom') {
      return page.y > (height >= 0 ? rect.bottom : rect.top) - margin;
    }
  } // the remaining checks require an element


  if (!is.element(element)) {
    return false;
  }

  return is.element(value) // the value is an element to use as a resize handle
  ? value === element // otherwise check if element matches value as selector
  : matchesUpTo(element, value, interactableElement);
}
/* eslint-disable multiline-ternary */


function initCursors(browser) {
  return browser.isIe9 ? {
    x: 'e-resize',
    y: 's-resize',
    xy: 'se-resize',
    top: 'n-resize',
    left: 'w-resize',
    bottom: 's-resize',
    right: 'e-resize',
    topleft: 'se-resize',
    bottomright: 'se-resize',
    topright: 'ne-resize',
    bottomleft: 'ne-resize'
  } : {
    x: 'ew-resize',
    y: 'ns-resize',
    xy: 'nwse-resize',
    top: 'ns-resize',
    left: 'ew-resize',
    bottom: 'ns-resize',
    right: 'ew-resize',
    topleft: 'nwse-resize',
    bottomright: 'nwse-resize',
    topright: 'nesw-resize',
    bottomleft: 'nesw-resize'
  };
}
/* eslint-enable multiline-ternary */


function start({
  iEvent,
  interaction
}) {
  if (interaction.prepared.name !== 'resize' || !interaction.prepared.edges) {
    return;
  }

  const resizeEvent = iEvent;
  const rect = interaction.rect;
  interaction._rects = {
    start: extend({}, rect),
    corrected: extend({}, rect),
    previous: extend({}, rect),
    delta: {
      left: 0,
      right: 0,
      width: 0,
      top: 0,
      bottom: 0,
      height: 0
    }
  };
  resizeEvent.edges = interaction.prepared.edges;
  resizeEvent.rect = interaction._rects.corrected;
  resizeEvent.deltaRect = interaction._rects.delta;
}

function plugin_move({
  iEvent,
  interaction
}) {
  if (interaction.prepared.name !== 'resize' || !interaction.prepared.edges) {
    return;
  }

  const resizeEvent = iEvent;
  const resizeOptions = interaction.interactable.options.resize;
  const invert = resizeOptions.invert;
  const invertible = invert === 'reposition' || invert === 'negate';
  const current = interaction.rect;
  const {
    start: startRect,
    corrected,
    delta: deltaRect,
    previous
  } = interaction._rects;
  extend(previous, corrected);

  if (invertible) {
    // if invertible, copy the current rect
    extend(corrected, current);

    if (invert === 'reposition') {
      // swap edge values if necessary to keep width/height positive
      if (corrected.top > corrected.bottom) {
        const swap = corrected.top;
        corrected.top = corrected.bottom;
        corrected.bottom = swap;
      }

      if (corrected.left > corrected.right) {
        const swap = corrected.left;
        corrected.left = corrected.right;
        corrected.right = swap;
      }
    }
  } else {
    // if not invertible, restrict to minimum of 0x0 rect
    corrected.top = Math.min(current.top, startRect.bottom);
    corrected.bottom = Math.max(current.bottom, startRect.top);
    corrected.left = Math.min(current.left, startRect.right);
    corrected.right = Math.max(current.right, startRect.left);
  }

  corrected.width = corrected.right - corrected.left;
  corrected.height = corrected.bottom - corrected.top;

  for (const edge in corrected) {
    deltaRect[edge] = corrected[edge] - previous[edge];
  }

  resizeEvent.edges = interaction.prepared.edges;
  resizeEvent.rect = corrected;
  resizeEvent.deltaRect = deltaRect;
}

function end({
  iEvent,
  interaction
}) {
  if (interaction.prepared.name !== 'resize' || !interaction.prepared.edges) {
    return;
  }

  const resizeEvent = iEvent;
  resizeEvent.edges = interaction.prepared.edges;
  resizeEvent.rect = interaction._rects.corrected;
  resizeEvent.deltaRect = interaction._rects.delta;
}

function updateEventAxes({
  iEvent,
  interaction
}) {
  if (interaction.prepared.name !== 'resize' || !interaction.resizeAxes) {
    return;
  }

  const options = interaction.interactable.options;
  const resizeEvent = iEvent;

  if (options.resize.square) {
    if (interaction.resizeAxes === 'y') {
      resizeEvent.delta.x = resizeEvent.delta.y;
    } else {
      resizeEvent.delta.y = resizeEvent.delta.x;
    }

    resizeEvent.axes = 'xy';
  } else {
    resizeEvent.axes = interaction.resizeAxes;

    if (interaction.resizeAxes === 'x') {
      resizeEvent.delta.y = 0;
    } else if (interaction.resizeAxes === 'y') {
      resizeEvent.delta.x = 0;
    }
  }
}

const resize = {
  id: 'actions/resize',
  before: ['actions/drag'],
  install: resize_plugin_install,
  listeners: {
    'interactions:new': ({
      interaction
    }) => {
      interaction.resizeAxes = 'xy';
    },
    'interactions:action-start': arg => {
      start(arg);
      updateEventAxes(arg);
    },
    'interactions:action-move': arg => {
      plugin_move(arg);
      updateEventAxes(arg);
    },
    'interactions:action-end': end,
    'auto-start:check': resizeChecker
  },
  defaults: {
    square: false,
    preserveAspectRatio: false,
    axis: 'xy',
    // use default margin
    margin: NaN,
    // object with props left, right, top, bottom which are
    // true/false values to resize when the pointer is over that edge,
    // CSS selectors to match the handles for each direction
    // or the Elements for each handle
    edges: null,
    // a value of 'none' will limit the resize rect to a minimum of 0x0
    // 'negate' will alow the rect to have negative width/height
    // 'reposition' will keep the width/height positive by swapping
    // the top and bottom edges and/or swapping the left and right edges
    invert: 'none'
  },
  cursors: null,

  getCursor({
    edges,
    axis,
    name
  }) {
    const cursors = resize.cursors;
    let result = null;

    if (axis) {
      result = cursors[name + axis];
    } else if (edges) {
      let cursorKey = '';

      for (const edge of ['top', 'bottom', 'left', 'right']) {
        if (edges[edge]) {
          cursorKey += edge;
        }
      }

      result = cursors[cursorKey];
    }

    return result;
  },

  defaultMargin: null
};
/* harmony default export */ var resize_plugin = (resize);
//# sourceMappingURL=plugin.js.map
// CONCATENATED MODULE: ./node_modules/@interactjs/actions/resize/index.js
/* eslint-disable import/order, no-console, eol-last */



if (typeof window === 'object' && !!window) {
  interact_init(window);
}

_interactjs_interact.use(resize_plugin);
//# sourceMappingURL=index.js.map
// CONCATENATED MODULE: ./node_modules/@interactjs/snappers/edgeTarget.js
/* harmony default export */ var edgeTarget = (() => {});
//# sourceMappingURL=edgeTarget.js.map
// CONCATENATED MODULE: ./node_modules/@interactjs/snappers/elements.js
/* harmony default export */ var snappers_elements = (() => {});
//# sourceMappingURL=elements.js.map
// CONCATENATED MODULE: ./node_modules/@interactjs/snappers/grid.js
/* harmony default export */ var grid = (grid => {
  const coordFields = [['x', 'y'], ['left', 'top'], ['right', 'bottom'], ['width', 'height']].filter(([xField, yField]) => xField in grid || yField in grid);

  const gridFunc = (x, y) => {
    const {
      range,
      limits = {
        left: -Infinity,
        right: Infinity,
        top: -Infinity,
        bottom: Infinity
      },
      offset = {
        x: 0,
        y: 0
      }
    } = grid;
    const result = {
      range,
      grid,
      x: null,
      y: null
    };

    for (const [xField, yField] of coordFields) {
      const gridx = Math.round((x - offset.x) / grid[xField]);
      const gridy = Math.round((y - offset.y) / grid[yField]);
      result[xField] = Math.max(limits.left, Math.min(limits.right, gridx * grid[xField] + offset.x));
      result[yField] = Math.max(limits.top, Math.min(limits.bottom, gridy * grid[yField] + offset.y));
    }

    return result;
  };

  gridFunc.grid = grid;
  gridFunc.coordFields = coordFields;
  return gridFunc;
});
//# sourceMappingURL=grid.js.map
// CONCATENATED MODULE: ./node_modules/@interactjs/snappers/all.js



//# sourceMappingURL=all.js.map
// CONCATENATED MODULE: ./node_modules/@interactjs/snappers/plugin.js


const snappersPlugin = {
  id: 'snappers',

  install(scope) {
    const {
      interactStatic: interact
    } = scope;
    interact.snappers = extend(interact.snappers || {}, all_namespaceObject);
    interact.createSnapGrid = interact.snappers.grid;
  }

};
/* harmony default export */ var snappers_plugin = (snappersPlugin);
//# sourceMappingURL=plugin.js.map
// CONCATENATED MODULE: ./node_modules/@interactjs/modifiers/Modification.js



class Modification_Modification {
  constructor(interaction) {
    this.states = [];
    this.startOffset = {
      left: 0,
      right: 0,
      top: 0,
      bottom: 0
    };
    this.startDelta = null;
    this.result = null;
    this.endResult = null;
    this.edges = void 0;
    this.interaction = void 0;
    this.interaction = interaction;
    this.result = createResult();
  }

  start({
    phase
  }, pageCoords) {
    const {
      interaction
    } = this;
    const modifierList = getModifierList(interaction);
    this.prepareStates(modifierList);
    this.edges = extend({}, interaction.edges);
    this.startOffset = getRectOffset(interaction.rect, pageCoords);
    this.startDelta = {
      x: 0,
      y: 0
    };
    const arg = {
      phase,
      pageCoords,
      preEnd: false
    };
    this.result = createResult();
    this.startAll(arg);
    const result = this.result = this.setAll(arg);
    return result;
  }

  fillArg(arg) {
    const {
      interaction
    } = this;
    arg.interaction = interaction;
    arg.interactable = interaction.interactable;
    arg.element = interaction.element;
    arg.rect = arg.rect || interaction.rect;
    arg.edges = this.edges;
    arg.startOffset = this.startOffset;
  }

  startAll(arg) {
    this.fillArg(arg);

    for (const state of this.states) {
      if (state.methods.start) {
        arg.state = state;
        state.methods.start(arg);
      }
    }
  }

  setAll(arg) {
    this.fillArg(arg);
    const {
      phase,
      preEnd,
      skipModifiers,
      rect: unmodifiedRect
    } = arg;
    arg.coords = extend({}, arg.pageCoords);
    arg.rect = extend({}, unmodifiedRect);
    const states = skipModifiers ? this.states.slice(skipModifiers) : this.states;
    const newResult = createResult(arg.coords, arg.rect);

    for (const state of states) {
      const {
        options
      } = state;
      const lastModifierCoords = extend({}, arg.coords);
      let returnValue = null;

      if (state.methods.set && this.shouldDo(options, preEnd, phase)) {
        arg.state = state;
        returnValue = state.methods.set(arg);
        addEdges(this.interaction.edges, arg.rect, {
          x: arg.coords.x - lastModifierCoords.x,
          y: arg.coords.y - lastModifierCoords.y
        });
      }

      newResult.eventProps.push(returnValue);
    }

    newResult.delta.x = arg.coords.x - arg.pageCoords.x;
    newResult.delta.y = arg.coords.y - arg.pageCoords.y;
    newResult.rectDelta.left = arg.rect.left - unmodifiedRect.left;
    newResult.rectDelta.right = arg.rect.right - unmodifiedRect.right;
    newResult.rectDelta.top = arg.rect.top - unmodifiedRect.top;
    newResult.rectDelta.bottom = arg.rect.bottom - unmodifiedRect.bottom;
    const prevCoords = this.result.coords;
    const prevRect = this.result.rect;

    if (prevCoords && prevRect) {
      const rectChanged = newResult.rect.left !== prevRect.left || newResult.rect.right !== prevRect.right || newResult.rect.top !== prevRect.top || newResult.rect.bottom !== prevRect.bottom;
      newResult.changed = rectChanged || prevCoords.x !== newResult.coords.x || prevCoords.y !== newResult.coords.y;
    }

    return newResult;
  }

  applyToInteraction(arg) {
    const {
      interaction
    } = this;
    const {
      phase
    } = arg;
    const curCoords = interaction.coords.cur;
    const startCoords = interaction.coords.start;
    const {
      result,
      startDelta
    } = this;
    const curDelta = result.delta;

    if (phase === 'start') {
      extend(this.startDelta, result.delta);
    }

    for (const [coordsSet, delta] of [[startCoords, startDelta], [curCoords, curDelta]]) {
      coordsSet.page.x += delta.x;
      coordsSet.page.y += delta.y;
      coordsSet.client.x += delta.x;
      coordsSet.client.y += delta.y;
    }

    const {
      rectDelta
    } = this.result;
    const rect = arg.rect || interaction.rect;
    rect.left += rectDelta.left;
    rect.right += rectDelta.right;
    rect.top += rectDelta.top;
    rect.bottom += rectDelta.bottom;
    rect.width = rect.right - rect.left;
    rect.height = rect.bottom - rect.top;
  }

  setAndApply(arg) {
    const {
      interaction
    } = this;
    const {
      phase,
      preEnd,
      skipModifiers
    } = arg;
    const result = this.setAll({
      preEnd,
      phase,
      pageCoords: arg.modifiedCoords || interaction.coords.cur.page
    });
    this.result = result; // don't fire an action move if a modifier would keep the event in the same
    // cordinates as before

    if (!result.changed && (!skipModifiers || skipModifiers < this.states.length) && interaction.interacting()) {
      return false;
    }

    if (arg.modifiedCoords) {
      const {
        page
      } = interaction.coords.cur;
      const adjustment = {
        x: arg.modifiedCoords.x - page.x,
        y: arg.modifiedCoords.y - page.y
      };
      result.coords.x += adjustment.x;
      result.coords.y += adjustment.y;
      result.delta.x += adjustment.x;
      result.delta.y += adjustment.y;
    }

    this.applyToInteraction(arg);
  }

  beforeEnd(arg) {
    const {
      interaction,
      event
    } = arg;
    const states = this.states;

    if (!states || !states.length) {
      return;
    }

    let doPreend = false;

    for (const state of states) {
      arg.state = state;
      const {
        options,
        methods
      } = state;
      const endPosition = methods.beforeEnd && methods.beforeEnd(arg);

      if (endPosition) {
        this.endResult = endPosition;
        return false;
      }

      doPreend = doPreend || !doPreend && this.shouldDo(options, true, arg.phase, true);
    }

    if (doPreend) {
      // trigger a final modified move before ending
      interaction.move({
        event,
        preEnd: true
      });
    }
  }

  stop(arg) {
    const {
      interaction
    } = arg;

    if (!this.states || !this.states.length) {
      return;
    }

    const modifierArg = extend({
      states: this.states,
      interactable: interaction.interactable,
      element: interaction.element,
      rect: null
    }, arg);
    this.fillArg(modifierArg);

    for (const state of this.states) {
      modifierArg.state = state;

      if (state.methods.stop) {
        state.methods.stop(modifierArg);
      }
    }

    this.states = null;
    this.endResult = null;
  }

  prepareStates(modifierList) {
    this.states = [];

    for (let index = 0; index < modifierList.length; index++) {
      const {
        options,
        methods,
        name
      } = modifierList[index];
      this.states.push({
        options,
        methods,
        index,
        name
      });
    }

    return this.states;
  }

  restoreInteractionCoords({
    interaction: {
      coords,
      rect,
      modification
    }
  }) {
    if (!modification.result) {
      return;
    }

    const {
      startDelta
    } = modification;
    const {
      delta: curDelta,
      rectDelta
    } = modification.result;
    const coordsAndDeltas = [[coords.start, startDelta], [coords.cur, curDelta]];

    for (const [coordsSet, delta] of coordsAndDeltas) {
      coordsSet.page.x -= delta.x;
      coordsSet.page.y -= delta.y;
      coordsSet.client.x -= delta.x;
      coordsSet.client.y -= delta.y;
    }

    rect.left -= rectDelta.left;
    rect.right -= rectDelta.right;
    rect.top -= rectDelta.top;
    rect.bottom -= rectDelta.bottom;
  }

  shouldDo(options, preEnd, phase, requireEndOnly) {
    if ( // ignore disabled modifiers
    !options || options.enabled === false || // check if we require endOnly option to fire move before end
    requireEndOnly && !options.endOnly || // don't apply endOnly modifiers when not ending
    options.endOnly && !preEnd || // check if modifier should run be applied on start
    phase === 'start' && !options.setStart) {
      return false;
    }

    return true;
  }

  copyFrom(other) {
    this.startOffset = other.startOffset;
    this.startDelta = other.startDelta;
    this.edges = other.edges;
    this.states = other.states.map(s => clone(s));
    this.result = createResult(extend({}, other.result.coords), extend({}, other.result.rect));
  }

  destroy() {
    for (const prop in this) {
      this[prop] = null;
    }
  }

}

function createResult(coords, rect) {
  return {
    rect,
    coords,
    delta: {
      x: 0,
      y: 0
    },
    rectDelta: {
      left: 0,
      right: 0,
      top: 0,
      bottom: 0
    },
    eventProps: [],
    changed: true
  };
}

function getModifierList(interaction) {
  const actionOptions = interaction.interactable.options[interaction.prepared.name];
  const actionModifiers = actionOptions.modifiers;

  if (actionModifiers && actionModifiers.length) {
    return actionModifiers;
  }

  return ['snap', 'snapSize', 'snapEdges', 'restrict', 'restrictEdges', 'restrictSize'].map(type => {
    const options = actionOptions[type];
    return options && options.enabled && {
      options,
      methods: options._methods
    };
  }).filter(m => !!m);
}

function getRectOffset(rect, coords) {
  return rect ? {
    left: coords.x - rect.left,
    top: coords.y - rect.top,
    right: rect.right - coords.x,
    bottom: rect.bottom - coords.y
  } : {
    left: 0,
    top: 0,
    right: 0,
    bottom: 0
  };
}
//# sourceMappingURL=Modification.js.map
// CONCATENATED MODULE: ./node_modules/@interactjs/modifiers/base.js



function makeModifier(module, name) {
  const {
    defaults
  } = module;
  const methods = {
    start: module.start,
    set: module.set,
    beforeEnd: module.beforeEnd,
    stop: module.stop
  };

  const modifier = _options => {
    const options = _options || {};
    options.enabled = options.enabled !== false; // add missing defaults to options

    for (const prop in defaults) {
      if (!(prop in options)) {
        options[prop] = defaults[prop];
      }
    }

    const m = {
      options,
      methods,
      name,
      enable: () => {
        options.enabled = true;
        return m;
      },
      disable: () => {
        options.enabled = false;
        return m;
      }
    };
    return m;
  };

  if (name && typeof name === 'string') {
    // for backwrads compatibility
    modifier._defaults = defaults;
    modifier._methods = methods;
  }

  return modifier;
}
function addEventModifiers({
  iEvent,
  interaction: {
    modification: {
      result
    }
  }
}) {
  if (result) {
    iEvent.modifiers = result.eventProps;
  }
}
const modifiersBase = {
  id: 'modifiers/base',
  before: ['actions'],
  install: scope => {
    scope.defaults.perAction.modifiers = [];
  },
  listeners: {
    'interactions:new': ({
      interaction
    }) => {
      interaction.modification = new Modification_Modification(interaction);
    },
    'interactions:before-action-start': arg => {
      const {
        modification
      } = arg.interaction;
      modification.start(arg, arg.interaction.coords.start.page);
      arg.interaction.edges = modification.edges;
      modification.applyToInteraction(arg);
    },
    'interactions:before-action-move': arg => arg.interaction.modification.setAndApply(arg),
    'interactions:before-action-end': arg => arg.interaction.modification.beforeEnd(arg),
    'interactions:action-start': addEventModifiers,
    'interactions:action-move': addEventModifiers,
    'interactions:action-end': addEventModifiers,
    'interactions:after-action-start': arg => arg.interaction.modification.restoreInteractionCoords(arg),
    'interactions:after-action-move': arg => arg.interaction.modification.restoreInteractionCoords(arg),
    'interactions:stop': arg => arg.interaction.modification.stop(arg)
  }
};
/* harmony default export */ var modifiers_base = (modifiersBase);
//# sourceMappingURL=base.js.map
// CONCATENATED MODULE: ./node_modules/@interactjs/modifiers/aspectRatio.js
/**
 * @module modifiers/aspectRatio
 *
 * @description
 * This module forces elements to be resized with a specified dx/dy ratio.
 *
 * ```js
 * interact(target).resizable({
 *   modifiers: [
 *     interact.modifiers.snapSize({
 *       targets: [ interact.snappers.grid({ x: 20, y: 20 }) ],
 *     }),
 *     interact.aspectRatio({ ratio: 'preserve' }),
 *   ],
 * });
 * ```
 */




const aspectRatio = {
  start(arg) {
    const {
      state,
      rect,
      edges: originalEdges,
      pageCoords: coords
    } = arg;
    let {
      ratio
    } = state.options;
    const {
      equalDelta,
      modifiers
    } = state.options;

    if (ratio === 'preserve') {
      ratio = rect.width / rect.height;
    }

    state.startCoords = extend({}, coords);
    state.startRect = extend({}, rect);
    state.ratio = ratio;
    state.equalDelta = equalDelta;
    const linkedEdges = state.linkedEdges = {
      top: originalEdges.top || originalEdges.left && !originalEdges.bottom,
      left: originalEdges.left || originalEdges.top && !originalEdges.right,
      bottom: originalEdges.bottom || originalEdges.right && !originalEdges.top,
      right: originalEdges.right || originalEdges.bottom && !originalEdges.left
    };
    state.xIsPrimaryAxis = !!(originalEdges.left || originalEdges.right);

    if (state.equalDelta) {
      state.edgeSign = (linkedEdges.left ? 1 : -1) * (linkedEdges.top ? 1 : -1);
    } else {
      const negativeSecondaryEdge = state.xIsPrimaryAxis ? linkedEdges.top : linkedEdges.left;
      state.edgeSign = negativeSecondaryEdge ? -1 : 1;
    }

    extend(arg.edges, linkedEdges);

    if (!modifiers || !modifiers.length) {
      return;
    }

    const subModification = new Modification_Modification(arg.interaction);
    subModification.copyFrom(arg.interaction.modification);
    subModification.prepareStates(modifiers);
    state.subModification = subModification;
    subModification.startAll({ ...arg
    });
  },

  set(arg) {
    const {
      state,
      rect,
      coords
    } = arg;
    const initialCoords = extend({}, coords);
    const aspectMethod = state.equalDelta ? setEqualDelta : setRatio;
    aspectMethod(state, state.xIsPrimaryAxis, coords, rect);

    if (!state.subModification) {
      return null;
    }

    const correctedRect = extend({}, rect);
    addEdges(state.linkedEdges, correctedRect, {
      x: coords.x - initialCoords.x,
      y: coords.y - initialCoords.y
    });
    const result = state.subModification.setAll({ ...arg,
      rect: correctedRect,
      edges: state.linkedEdges,
      pageCoords: coords,
      prevCoords: coords,
      prevRect: correctedRect
    });
    const {
      delta
    } = result;

    if (result.changed) {
      const xIsCriticalAxis = Math.abs(delta.x) > Math.abs(delta.y); // do aspect modification again with critical edge axis as primary

      aspectMethod(state, xIsCriticalAxis, result.coords, result.rect);
      extend(coords, result.coords);
    }

    return result.eventProps;
  },

  defaults: {
    ratio: 'preserve',
    equalDelta: false,
    modifiers: [],
    enabled: false
  }
};

function setEqualDelta({
  startCoords,
  edgeSign
}, xIsPrimaryAxis, coords) {
  if (xIsPrimaryAxis) {
    coords.y = startCoords.y + (coords.x - startCoords.x) * edgeSign;
  } else {
    coords.x = startCoords.x + (coords.y - startCoords.y) * edgeSign;
  }
}

function setRatio({
  startRect,
  startCoords,
  ratio,
  edgeSign
}, xIsPrimaryAxis, coords, rect) {
  if (xIsPrimaryAxis) {
    const newHeight = rect.width / ratio;
    coords.y = startCoords.y + (newHeight - startRect.height) * edgeSign;
  } else {
    const newWidth = rect.height * ratio;
    coords.x = startCoords.x + (newWidth - startRect.width) * edgeSign;
  }
}

/* harmony default export */ var modifiers_aspectRatio = (makeModifier(aspectRatio, 'aspectRatio'));

//# sourceMappingURL=aspectRatio.js.map
// CONCATENATED MODULE: ./node_modules/@interactjs/modifiers/noop.js
const noop = () => {};

noop._defaults = {};
/* harmony default export */ var modifiers_noop = (noop);
//# sourceMappingURL=noop.js.map
// CONCATENATED MODULE: ./node_modules/@interactjs/modifiers/restrict/pointer.js





function pointer_start({
  rect,
  startOffset,
  state,
  interaction,
  pageCoords
}) {
  const {
    options
  } = state;
  const {
    elementRect
  } = options;
  const offset = extend({
    left: 0,
    top: 0,
    right: 0,
    bottom: 0
  }, options.offset || {});

  if (rect && elementRect) {
    const restriction = getRestrictionRect(options.restriction, interaction, pageCoords);

    if (restriction) {
      const widthDiff = restriction.right - restriction.left - rect.width;
      const heightDiff = restriction.bottom - restriction.top - rect.height;

      if (widthDiff < 0) {
        offset.left += widthDiff;
        offset.right += widthDiff;
      }

      if (heightDiff < 0) {
        offset.top += heightDiff;
        offset.bottom += heightDiff;
      }
    }

    offset.left += startOffset.left - rect.width * elementRect.left;
    offset.top += startOffset.top - rect.height * elementRect.top;
    offset.right += startOffset.right - rect.width * (1 - elementRect.right);
    offset.bottom += startOffset.bottom - rect.height * (1 - elementRect.bottom);
  }

  state.offset = offset;
}

function set({
  coords,
  interaction,
  state
}) {
  const {
    options,
    offset
  } = state;
  const restriction = getRestrictionRect(options.restriction, interaction, coords);

  if (!restriction) {
    return;
  }

  const rect = xywhToTlbr(restriction);
  coords.x = Math.max(Math.min(rect.right - offset.right, coords.x), rect.left + offset.left);
  coords.y = Math.max(Math.min(rect.bottom - offset.bottom, coords.y), rect.top + offset.top);
}

function getRestrictionRect(value, interaction, coords) {
  if (is.func(value)) {
    return resolveRectLike(value, interaction.interactable, interaction.element, [coords.x, coords.y, interaction]);
  } else {
    return resolveRectLike(value, interaction.interactable, interaction.element);
  }
}
const pointer_defaults = {
  restriction: null,
  elementRect: null,
  offset: null,
  endOnly: false,
  enabled: false
};
const restrict = {
  start: pointer_start,
  set,
  defaults: pointer_defaults
};
/* harmony default export */ var restrict_pointer = (makeModifier(restrict, 'restrict'));

//# sourceMappingURL=pointer.js.map
// CONCATENATED MODULE: ./node_modules/@interactjs/modifiers/restrict/edges.js
// This module adds the options.resize.restrictEdges setting which sets min and
// max for the top, left, bottom and right edges of the target being resized.
//
// interact(target).resize({
//   edges: { top: true, left: true },
//   restrictEdges: {
//     inner: { top: 200, left: 200, right: 400, bottom: 400 },
//     outer: { top:   0, left:   0, right: 600, bottom: 600 },
//   },
// })




const noInner = {
  top: +Infinity,
  left: +Infinity,
  bottom: -Infinity,
  right: -Infinity
};
const noOuter = {
  top: -Infinity,
  left: -Infinity,
  bottom: +Infinity,
  right: +Infinity
};

function edges_start({
  interaction,
  startOffset,
  state
}) {
  const {
    options
  } = state;
  let offset;

  if (options) {
    const offsetRect = getRestrictionRect(options.offset, interaction, interaction.coords.start.page);
    offset = rectToXY(offsetRect);
  }

  offset = offset || {
    x: 0,
    y: 0
  };
  state.offset = {
    top: offset.y + startOffset.top,
    left: offset.x + startOffset.left,
    bottom: offset.y - startOffset.bottom,
    right: offset.x - startOffset.right
  };
}

function edges_set({
  coords,
  edges,
  interaction,
  state
}) {
  const {
    offset,
    options
  } = state;

  if (!edges) {
    return;
  }

  const page = extend({}, coords);
  const inner = getRestrictionRect(options.inner, interaction, page) || {};
  const outer = getRestrictionRect(options.outer, interaction, page) || {};
  fixRect(inner, noInner);
  fixRect(outer, noOuter);

  if (edges.top) {
    coords.y = Math.min(Math.max(outer.top + offset.top, page.y), inner.top + offset.top);
  } else if (edges.bottom) {
    coords.y = Math.max(Math.min(outer.bottom + offset.bottom, page.y), inner.bottom + offset.bottom);
  }

  if (edges.left) {
    coords.x = Math.min(Math.max(outer.left + offset.left, page.x), inner.left + offset.left);
  } else if (edges.right) {
    coords.x = Math.max(Math.min(outer.right + offset.right, page.x), inner.right + offset.right);
  }
}

function fixRect(rect, defaults) {
  for (const edge of ['top', 'left', 'bottom', 'right']) {
    if (!(edge in rect)) {
      rect[edge] = defaults[edge];
    }
  }

  return rect;
}

const edges_defaults = {
  inner: null,
  outer: null,
  offset: null,
  endOnly: false,
  enabled: false
};
const restrictEdges = {
  noInner,
  noOuter,
  start: edges_start,
  set: edges_set,
  defaults: edges_defaults
};
/* harmony default export */ var restrict_edges = (makeModifier(restrictEdges, 'restrictEdges'));

//# sourceMappingURL=edges.js.map
// CONCATENATED MODULE: ./node_modules/@interactjs/modifiers/restrict/rect.js



const rect_defaults = extend({
  get elementRect() {
    return {
      top: 0,
      left: 0,
      bottom: 1,
      right: 1
    };
  },

  set elementRect(_) {}

}, restrict.defaults);
const restrictRect = {
  start: restrict.start,
  set: restrict.set,
  defaults: rect_defaults
};
/* harmony default export */ var restrict_rect = (makeModifier(restrictRect, 'restrictRect'));

//# sourceMappingURL=rect.js.map
// CONCATENATED MODULE: ./node_modules/@interactjs/modifiers/restrict/size.js





const noMin = {
  width: -Infinity,
  height: -Infinity
};
const noMax = {
  width: +Infinity,
  height: +Infinity
};

function size_start(arg) {
  return restrictEdges.start(arg);
}

function size_set(arg) {
  const {
    interaction,
    state,
    rect,
    edges
  } = arg;
  const {
    options
  } = state;

  if (!edges) {
    return;
  }

  const minSize = tlbrToXywh(getRestrictionRect(options.min, interaction, arg.coords)) || noMin;
  const maxSize = tlbrToXywh(getRestrictionRect(options.max, interaction, arg.coords)) || noMax;
  state.options = {
    endOnly: options.endOnly,
    inner: extend({}, restrictEdges.noInner),
    outer: extend({}, restrictEdges.noOuter)
  };

  if (edges.top) {
    state.options.inner.top = rect.bottom - minSize.height;
    state.options.outer.top = rect.bottom - maxSize.height;
  } else if (edges.bottom) {
    state.options.inner.bottom = rect.top + minSize.height;
    state.options.outer.bottom = rect.top + maxSize.height;
  }

  if (edges.left) {
    state.options.inner.left = rect.right - minSize.width;
    state.options.outer.left = rect.right - maxSize.width;
  } else if (edges.right) {
    state.options.inner.right = rect.left + minSize.width;
    state.options.outer.right = rect.left + maxSize.width;
  }

  restrictEdges.set(arg);
  state.options = options;
}

const size_defaults = {
  min: null,
  max: null,
  endOnly: false,
  enabled: false
};
const restrictSize = {
  start: size_start,
  set: size_set,
  defaults: size_defaults
};
/* harmony default export */ var size = (makeModifier(restrictSize, 'restrictSize'));

//# sourceMappingURL=size.js.map
// CONCATENATED MODULE: ./node_modules/@interactjs/modifiers/snap/pointer.js







function snap_pointer_start(arg) {
  const {
    interaction,
    interactable,
    element,
    rect,
    state,
    startOffset
  } = arg;
  const {
    options
  } = state;
  const origin = options.offsetWithOrigin ? getOrigin(arg) : {
    x: 0,
    y: 0
  };
  let snapOffset;

  if (options.offset === 'startCoords') {
    snapOffset = {
      x: interaction.coords.start.page.x,
      y: interaction.coords.start.page.y
    };
  } else {
    const offsetRect = resolveRectLike(options.offset, interactable, element, [interaction]);
    snapOffset = rectToXY(offsetRect) || {
      x: 0,
      y: 0
    };
    snapOffset.x += origin.x;
    snapOffset.y += origin.y;
  }

  const {
    relativePoints
  } = options;
  state.offsets = rect && relativePoints && relativePoints.length ? relativePoints.map((relativePoint, index) => ({
    index,
    relativePoint,
    x: startOffset.left - rect.width * relativePoint.x + snapOffset.x,
    y: startOffset.top - rect.height * relativePoint.y + snapOffset.y
  })) : [extend({
    index: 0,
    relativePoint: null
  }, snapOffset)];
}

function pointer_set(arg) {
  const {
    interaction,
    coords,
    state
  } = arg;
  const {
    options,
    offsets
  } = state;
  const origin = getOriginXY(interaction.interactable, interaction.element, interaction.prepared.name);
  const page = extend({}, coords);
  const targets = [];

  if (!options.offsetWithOrigin) {
    page.x -= origin.x;
    page.y -= origin.y;
  }

  for (const offset of offsets) {
    const relativeX = page.x - offset.x;
    const relativeY = page.y - offset.y;

    for (let index = 0, len = options.targets.length; index < len; index++) {
      const snapTarget = options.targets[index];
      let target;

      if (is.func(snapTarget)) {
        target = snapTarget(relativeX, relativeY, interaction._proxy, offset, index);
      } else {
        target = snapTarget;
      }

      if (!target) {
        continue;
      }

      targets.push({
        x: (is.number(target.x) ? target.x : relativeX) + offset.x,
        y: (is.number(target.y) ? target.y : relativeY) + offset.y,
        range: is.number(target.range) ? target.range : options.range,
        source: snapTarget,
        index,
        offset
      });
    }
  }

  const closest = {
    target: null,
    inRange: false,
    distance: 0,
    range: 0,
    delta: {
      x: 0,
      y: 0
    }
  };

  for (const target of targets) {
    const range = target.range;
    const dx = target.x - page.x;
    const dy = target.y - page.y;
    const distance = hypot(dx, dy);
    let inRange = distance <= range; // Infinite targets count as being out of range
    // compared to non infinite ones that are in range

    if (range === Infinity && closest.inRange && closest.range !== Infinity) {
      inRange = false;
    }

    if (!closest.target || (inRange // is the closest target in range?
    ? closest.inRange && range !== Infinity // the pointer is relatively deeper in this target
    ? distance / range < closest.distance / closest.range // this target has Infinite range and the closest doesn't
    : range === Infinity && closest.range !== Infinity || // OR this target is closer that the previous closest
    distance < closest.distance : // The other is not in range and the pointer is closer to this target
    !closest.inRange && distance < closest.distance)) {
      closest.target = target;
      closest.distance = distance;
      closest.range = range;
      closest.inRange = inRange;
      closest.delta.x = dx;
      closest.delta.y = dy;
    }
  }

  if (closest.inRange) {
    coords.x = closest.target.x;
    coords.y = closest.target.y;
  }

  state.closest = closest;
  return closest;
}

function getOrigin(arg) {
  const {
    element
  } = arg.interaction;
  const optionsOrigin = rectToXY(resolveRectLike(arg.state.options.origin, null, null, [element]));
  const origin = optionsOrigin || getOriginXY(arg.interactable, element, arg.interaction.prepared.name);
  return origin;
}

const snap_pointer_defaults = {
  range: Infinity,
  targets: null,
  offset: null,
  offsetWithOrigin: true,
  origin: null,
  relativePoints: null,
  endOnly: false,
  enabled: false
};
const snap = {
  start: snap_pointer_start,
  set: pointer_set,
  defaults: snap_pointer_defaults
};
/* harmony default export */ var snap_pointer = (makeModifier(snap, 'snap'));

//# sourceMappingURL=pointer.js.map
// CONCATENATED MODULE: ./node_modules/@interactjs/modifiers/snap/size.js
// This module allows snapping of the size of targets during resize
// interactions.





function snap_size_start(arg) {
  const {
    state,
    edges
  } = arg;
  const {
    options
  } = state;

  if (!edges) {
    return null;
  }

  arg.state = {
    options: {
      targets: null,
      relativePoints: [{
        x: edges.left ? 0 : 1,
        y: edges.top ? 0 : 1
      }],
      offset: options.offset || 'self',
      origin: {
        x: 0,
        y: 0
      },
      range: options.range
    }
  };
  state.targetFields = state.targetFields || [['width', 'height'], ['x', 'y']];
  snap.start(arg);
  state.offsets = arg.state.offsets;
  arg.state = state;
}

function snap_size_set(arg) {
  const {
    interaction,
    state,
    coords
  } = arg;
  const {
    options,
    offsets
  } = state;
  const relative = {
    x: coords.x - offsets[0].x,
    y: coords.y - offsets[0].y
  };
  state.options = extend({}, options);
  state.options.targets = [];

  for (const snapTarget of options.targets || []) {
    let target;

    if (is.func(snapTarget)) {
      target = snapTarget(relative.x, relative.y, interaction);
    } else {
      target = snapTarget;
    }

    if (!target) {
      continue;
    }

    for (const [xField, yField] of state.targetFields) {
      if (xField in target || yField in target) {
        target.x = target[xField];
        target.y = target[yField];
        break;
      }
    }

    state.options.targets.push(target);
  }

  const returnValue = snap.set(arg);
  state.options = options;
  return returnValue;
}

const snap_size_defaults = {
  range: Infinity,
  targets: null,
  offset: null,
  endOnly: false,
  enabled: false
};
const snapSize = {
  start: snap_size_start,
  set: snap_size_set,
  defaults: snap_size_defaults
};
/* harmony default export */ var snap_size = (makeModifier(snapSize, 'snapSize'));

//# sourceMappingURL=size.js.map
// CONCATENATED MODULE: ./node_modules/@interactjs/modifiers/snap/edges.js
/**
 * @module modifiers/snapEdges
 *
 * @description
 * WOW> This module allows snapping of the edges of targets during resize
 * interactions.
 *
 * ```js
 * interact(target).resizable({
 *   snapEdges: {
 *     targets: [interact.snappers.grid({ x: 100, y: 50 })],
 *   },
 * })
 *
 * interact(target).resizable({
 *   snapEdges: {
 *     targets: [
 *       interact.snappers.grid({
 *        top: 50,
 *        left: 50,
 *        bottom: 100,
 *        right: 100,
 *       }),
 *     ],
 *   },
 * })
 * ```
 */





function snap_edges_start(arg) {
  const {
    edges
  } = arg;

  if (!edges) {
    return null;
  }

  arg.state.targetFields = arg.state.targetFields || [[edges.left ? 'left' : 'right', edges.top ? 'top' : 'bottom']];
  return snapSize.start(arg);
}

const snapEdges = {
  start: snap_edges_start,
  set: snapSize.set,
  defaults: extend(clone(snapSize.defaults), {
    targets: null,
    range: null,
    offset: {
      x: 0,
      y: 0
    }
  })
};
/* harmony default export */ var snap_edges = (makeModifier(snapEdges, 'snapEdges'));

//# sourceMappingURL=edges.js.map
// CONCATENATED MODULE: ./node_modules/@interactjs/modifiers/all.js
/* eslint-disable node/no-extraneous-import */












/* harmony default export */ var modifiers_all = ({
  aspectRatio: modifiers_aspectRatio,
  restrictEdges: restrict_edges,
  restrict: restrict_pointer,
  restrictRect: restrict_rect,
  restrictSize: size,
  snapEdges: snap_edges,
  snap: snap_pointer,
  snapSize: snap_size,
  spring: modifiers_noop,
  avoid: modifiers_noop,
  transform: modifiers_noop,
  rubberband: modifiers_noop
});
//# sourceMappingURL=all.js.map
// CONCATENATED MODULE: ./node_modules/@interactjs/modifiers/plugin.js



const plugin_modifiers = {
  id: 'modifiers',

  install(scope) {
    const {
      interactStatic: interact
    } = scope;
    scope.usePlugin(modifiers_base);
    scope.usePlugin(snappers_plugin);
    interact.modifiers = modifiers_all; // for backwrads compatibility

    for (const type in modifiers_all) {
      const {
        _defaults,
        _methods
      } = modifiers_all[type];
      _defaults._methods = _methods;
      scope.defaults.perAction[type] = _defaults;
    }
  }

};
/* harmony default export */ var modifiers_plugin = (plugin_modifiers);
//# sourceMappingURL=plugin.js.map
// CONCATENATED MODULE: ./node_modules/@interactjs/modifiers/index.js
/* eslint-disable import/order, no-console, eol-last */



if (typeof window === 'object' && !!window) {
  interact_init(window);
}

_interactjs_interact.use(modifiers_plugin);
//# sourceMappingURL=index.js.map
// CONCATENATED MODULE: ./node_modules/@interactjs/dev-tools/plugin.js
/* eslint-disable no-console */






var CheckName;

(function (CheckName) {
  CheckName["touchAction"] = "touchAction";
  CheckName["boxSizing"] = "boxSizing";
  CheckName["noListeners"] = "noListeners";
})(CheckName || (CheckName = {}));

const prefix = '[interact.js] ';
const links = {
  touchAction: 'https://developer.mozilla.org/en-US/docs/Web/CSS/touch-action',
  boxSizing: 'https://developer.mozilla.org/en-US/docs/Web/CSS/box-sizing'
}; // eslint-disable-next-line no-undef

const isProduction = "development" === 'production'; // eslint-disable-next-line no-restricted-syntax

function dev_tools_plugin_install(scope, {
  logger
} = {}) {
  const {
    Interactable,
    defaults
  } = scope;
  scope.logger = logger || console;
  defaults.base.devTools = {
    ignore: {}
  };

  Interactable.prototype.devTools = function (options) {
    if (options) {
      extend(this.options.devTools, options);
      return this;
    }

    return this.options.devTools;
  };
}

const checks = [{
  name: CheckName.touchAction,

  perform({
    element
  }) {
    return !parentHasStyle(element, 'touchAction', /pan-|pinch|none/);
  },

  getInfo({
    element
  }) {
    return [element, links.touchAction];
  },

  text: 'Consider adding CSS "touch-action: none" to this element\n'
}, {
  name: CheckName.boxSizing,

  perform(interaction) {
    const {
      element
    } = interaction;
    return interaction.prepared.name === 'resize' && element instanceof utils_domObjects.HTMLElement && !hasStyle(element, 'boxSizing', /border-box/);
  },

  text: 'Consider adding CSS "box-sizing: border-box" to this resizable element',

  getInfo({
    element
  }) {
    return [element, links.boxSizing];
  }

}, {
  name: CheckName.noListeners,

  perform(interaction) {
    const actionName = interaction.prepared.name;
    const moveListeners = interaction.interactable.events.types[`${actionName}move`] || [];
    return !moveListeners.length;
  },

  getInfo(interaction) {
    return [interaction.prepared.name, interaction.interactable];
  },

  text: 'There are no listeners set for this action'
}];

function hasStyle(element, prop, styleRe) {
  const value = element.style[prop] || win.getComputedStyle(element)[prop];
  return styleRe.test((value || '').toString());
}

function parentHasStyle(element, prop, styleRe) {
  let parent = element;

  while (is.element(parent)) {
    if (hasStyle(parent, prop, styleRe)) {
      return true;
    }

    parent = parentNode(parent);
  }

  return false;
}

const plugin_id = 'dev-tools';
const defaultExport = isProduction ? {
  id: plugin_id,
  install: () => {}
} : {
  id: plugin_id,
  install: dev_tools_plugin_install,
  listeners: {
    'interactions:action-start': ({
      interaction
    }, scope) => {
      for (const check of checks) {
        const options = interaction.interactable && interaction.interactable.options;

        if (!(options && options.devTools && options.devTools.ignore[check.name]) && check.perform(interaction)) {
          scope.logger.warn(prefix + check.text, ...check.getInfo(interaction));
        }
      }
    }
  },
  checks,
  CheckName,
  links,
  prefix
};
/* harmony default export */ var dev_tools_plugin = (defaultExport);
//# sourceMappingURL=plugin.js.map
// CONCATENATED MODULE: ./node_modules/@interactjs/dev-tools/index.js
/* eslint-disable import/order, no-console, eol-last */



if (typeof window === 'object' && !!window) {
  interact_init(window);
}

_interactjs_interact.use(dev_tools_plugin);
//# sourceMappingURL=index.js.map
// CONCATENATED MODULE: ./node_modules/cache-loader/dist/cjs.js??ref--12-0!./node_modules/thread-loader/dist/cjs.js!./node_modules/babel-loader/lib!./node_modules/cache-loader/dist/cjs.js??ref--0-0!./node_modules/vue-loader/lib??vue-loader-options!./src/components/GridItem.vue?vue&type=script&lang=js&



//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//



 //    var eventBus = require('./eventBus');







/* harmony default export */ var GridItemvue_type_script_lang_js_ = ({
  name: "GridItem",
  props: {
    /*cols: {
     type: Number,
     required: true
     },*/

    /*containerWidth: {
     type: Number,
     required: true
      },
     rowHeight: {
     type: Number,
     required: true
     },
     margin: {
     type: Array,
     required: true
     },
     maxRows: {
     type: Number,
     required: true
     },*/
    isDraggable: {
      type: Boolean,
      required: false,
      default: null
    },
    isResizable: {
      type: Boolean,
      required: false,
      default: null
    },

    /*useCssTransforms: {
     type: Boolean,
     required: true
     },
     */
    static: {
      type: Boolean,
      required: false,
      default: false
    },
    minH: {
      type: Number,
      required: false,
      default: 1
    },
    minW: {
      type: Number,
      required: false,
      default: 1
    },
    maxH: {
      type: Number,
      required: false,
      default: Infinity
    },
    maxW: {
      type: Number,
      required: false,
      default: Infinity
    },
    x: {
      type: Number,
      required: true
    },
    y: {
      type: Number,
      required: true
    },
    w: {
      type: Number,
      required: true
    },
    h: {
      type: Number,
      required: true
    },
    i: {
      required: true
    },
    dragIgnoreFrom: {
      type: String,
      required: false,
      default: 'a, button'
    },
    dragAllowFrom: {
      type: String,
      required: false,
      default: null
    },
    resizeIgnoreFrom: {
      type: String,
      required: false,
      default: 'a, button'
    },
    preserveAspectRatio: {
      type: Boolean,
      required: false,
      default: false
    }
  },
  inject: ["eventBus", "layout"],
  data: function data() {
    return {
      cols: 1,
      containerWidth: 100,
      rowHeight: 30,
      margin: [10, 10],
      maxRows: Infinity,
      draggable: null,
      resizable: null,
      useCssTransforms: true,
      useStyleCursor: true,
      isDragging: false,
      dragging: null,
      isResizing: false,
      resizing: null,
      lastX: NaN,
      lastY: NaN,
      lastW: NaN,
      lastH: NaN,
      style: {},
      rtl: false,
      dragEventSet: false,
      resizeEventSet: false,
      previousW: null,
      previousH: null,
      previousX: null,
      previousY: null,
      innerX: this.x,
      innerY: this.y,
      innerW: this.w,
      innerH: this.h
    };
  },
  created: function created() {
    var _this = this;

    var self = this; // Accessible refernces of functions for removing in beforeDestroy

    self.updateWidthHandler = function (width) {
      self.updateWidth(width);
    };

    self.compactHandler = function (layout) {
      self.compact(layout);
    };

    self.setDraggableHandler = function (isDraggable) {
      if (self.isDraggable === null) {
        self.draggable = isDraggable;
      }
    };

    self.setResizableHandler = function (isResizable) {
      if (self.isResizable === null) {
        self.resizable = isResizable;
      }
    };

    self.setRowHeightHandler = function (rowHeight) {
      self.rowHeight = rowHeight;
    };

    self.setMaxRowsHandler = function (maxRows) {
      self.maxRows = maxRows;
    };

    self.directionchangeHandler = function () {
      _this.rtl = Object(DOM["b" /* getDocumentDir */])() === 'rtl';

      _this.compact();
    };

    self.setColNum = function (colNum) {
      self.cols = parseInt(colNum);
    };

    this.eventBus.$on('updateWidth', self.updateWidthHandler);
    this.eventBus.$on('compact', self.compactHandler);
    this.eventBus.$on('setDraggable', self.setDraggableHandler);
    this.eventBus.$on('setResizable', self.setResizableHandler);
    this.eventBus.$on('setRowHeight', self.setRowHeightHandler);
    this.eventBus.$on('setMaxRows', self.setMaxRowsHandler);
    this.eventBus.$on('directionchange', self.directionchangeHandler);
    this.eventBus.$on('setColNum', self.setColNum);
    this.rtl = Object(DOM["b" /* getDocumentDir */])() === 'rtl';
  },
  beforeDestroy: function beforeDestroy() {
    var self = this; //Remove listeners

    this.eventBus.$off('updateWidth', self.updateWidthHandler);
    this.eventBus.$off('compact', self.compactHandler);
    this.eventBus.$off('setDraggable', self.setDraggableHandler);
    this.eventBus.$off('setResizable', self.setResizableHandler);
    this.eventBus.$off('setRowHeight', self.setRowHeightHandler);
    this.eventBus.$off('setMaxRows', self.setMaxRowsHandler);
    this.eventBus.$off('directionchange', self.directionchangeHandler);
    this.eventBus.$off('setColNum', self.setColNum);

    if (this.interactObj) {
      this.interactObj.unset(); // destroy interact intance
    }
  },
  mounted: function mounted() {
    if (this.layout.responsive && this.layout.lastBreakpoint) {
      this.cols = Object(responsiveUtils["c" /* getColsFromBreakpoint */])(this.layout.lastBreakpoint, this.layout.cols);
    } else {
      this.cols = this.layout.colNum;
    }

    this.rowHeight = this.layout.rowHeight;
    this.containerWidth = this.layout.width !== null ? this.layout.width : 100;
    this.margin = this.layout.margin !== undefined ? this.layout.margin : [10, 10];
    this.maxRows = this.layout.maxRows;

    if (this.isDraggable === null) {
      this.draggable = this.layout.isDraggable;
    } else {
      this.draggable = this.isDraggable;
    }

    if (this.isResizable === null) {
      this.resizable = this.layout.isResizable;
    } else {
      this.resizable = this.isResizable;
    }

    this.useCssTransforms = this.layout.useCssTransforms;
    this.useStyleCursor = this.layout.useStyleCursor;
    this.createStyle();
  },
  watch: {
    isDraggable: function isDraggable() {
      this.draggable = this.isDraggable;
    },
    static: function _static() {
      this.tryMakeDraggable();
      this.tryMakeResizable();
    },
    draggable: function draggable() {
      this.tryMakeDraggable();
    },
    isResizable: function isResizable() {
      this.resizable = this.isResizable;
    },
    resizable: function resizable() {
      this.tryMakeResizable();
    },
    rowHeight: function rowHeight() {
      this.createStyle();
      this.emitContainerResized();
    },
    cols: function cols() {
      this.tryMakeResizable();
      this.createStyle();
      this.emitContainerResized();
    },
    containerWidth: function containerWidth() {
      this.tryMakeResizable();
      this.createStyle();
      this.emitContainerResized();
    },
    x: function x(newVal) {
      this.innerX = newVal;
      this.createStyle();
    },
    y: function y(newVal) {
      this.innerY = newVal;
      this.createStyle();
    },
    h: function h(newVal) {
      this.innerH = newVal;
      this.createStyle(); // this.emitContainerResized();
    },
    w: function w(newVal) {
      this.innerW = newVal;
      this.createStyle(); // this.emitContainerResized();
    },
    renderRtl: function renderRtl() {
      // console.log("### renderRtl");
      this.tryMakeResizable();
      this.createStyle();
    },
    minH: function minH() {
      this.tryMakeResizable();
    },
    maxH: function maxH() {
      this.tryMakeResizable();
    },
    minW: function minW() {
      this.tryMakeResizable();
    },
    maxW: function maxW() {
      this.tryMakeResizable();
    },
    "$parent.margin": function $parentMargin(margin) {
      if (!margin || margin[0] == this.margin[0] && margin[1] == this.margin[1]) {
        return;
      }

      this.margin = margin.map(function (m) {
        return Number(m);
      });
      this.createStyle();
      this.emitContainerResized();
    }
  },
  computed: {
    classObj: function classObj() {
      return {
        'vue-resizable': this.resizableAndNotStatic,
        'static': this.static,
        'resizing': this.isResizing,
        'vue-draggable-dragging': this.isDragging,
        'cssTransforms': this.useCssTransforms,
        'render-rtl': this.renderRtl,
        'disable-userselect': this.isDragging,
        'no-touch': this.isAndroid && this.draggableOrResizableAndNotStatic
      };
    },
    resizableAndNotStatic: function resizableAndNotStatic() {
      return this.resizable && !this.static;
    },
    draggableOrResizableAndNotStatic: function draggableOrResizableAndNotStatic() {
      return (this.draggable || this.resizable) && !this.static;
    },
    isAndroid: function isAndroid() {
      return navigator.userAgent.toLowerCase().indexOf("android") !== -1;
    },
    renderRtl: function renderRtl() {
      return this.layout.isMirrored ? !this.rtl : this.rtl;
    },
    resizableHandleClass: function resizableHandleClass() {
      if (this.renderRtl) {
        return 'vue-resizable-handle vue-rtl-resizable-handle';
      } else {
        return 'vue-resizable-handle';
      }
    }
  },
  methods: {
    createStyle: function createStyle() {
      if (this.x + this.w > this.cols) {
        this.innerX = 0;
        this.innerW = this.w > this.cols ? this.cols : this.w;
      } else {
        this.innerX = this.x;
        this.innerW = this.w;
      }

      var pos = this.calcPosition(this.innerX, this.innerY, this.innerW, this.innerH);

      if (this.isDragging) {
        pos.top = this.dragging.top; //                    Add rtl support

        if (this.renderRtl) {
          pos.right = this.dragging.left;
        } else {
          pos.left = this.dragging.left;
        }
      }

      if (this.isResizing) {
        pos.width = this.resizing.width;
        pos.height = this.resizing.height;
      }

      var style; // CSS Transforms support (default)

      if (this.useCssTransforms) {
        //                    Add rtl support
        if (this.renderRtl) {
          style = Object(utils["k" /* setTransformRtl */])(pos.top, pos.right, pos.width, pos.height);
        } else {
          style = Object(utils["j" /* setTransform */])(pos.top, pos.left, pos.width, pos.height);
        }
      } else {
        // top,left (slow)
        //                    Add rtl support
        if (this.renderRtl) {
          style = Object(utils["i" /* setTopRight */])(pos.top, pos.right, pos.width, pos.height);
        } else {
          style = Object(utils["h" /* setTopLeft */])(pos.top, pos.left, pos.width, pos.height);
        }
      }

      this.style = style;
    },
    emitContainerResized: function emitContainerResized() {
      // this.style has width and height with trailing 'px'. The
      // resized event is without them
      var styleProps = {};

      for (var _i = 0, _arr = ['width', 'height']; _i < _arr.length; _i++) {
        var prop = _arr[_i];
        var val = this.style[prop];
        var matches = val.match(/^(\d+)px$/);
        if (!matches) return;
        styleProps[prop] = matches[1];
      }

      this.$emit("container-resized", this.i, this.h, this.w, styleProps.height, styleProps.width);
    },
    handleResize: function handleResize(event) {
      if (this.static) return;
      var position = getControlPosition(event); // Get the current drag point from the event. This is used as the offset.

      if (position == null) return; // not possible but satisfies flow

      var x = position.x,
          y = position.y;
      var newSize = {
        width: 0,
        height: 0
      };
      var pos;

      switch (event.type) {
        case "resizestart":
          {
            this.previousW = this.innerW;
            this.previousH = this.innerH;
            pos = this.calcPosition(this.innerX, this.innerY, this.innerW, this.innerH);
            newSize.width = pos.width;
            newSize.height = pos.height;
            this.resizing = newSize;
            this.isResizing = true;
            break;
          }

        case "resizemove":
          {
            //                        console.log("### resize => " + event.type + ", lastW=" + this.lastW + ", lastH=" + this.lastH);
            var coreEvent = createCoreData(this.lastW, this.lastH, x, y);

            if (this.renderRtl) {
              newSize.width = this.resizing.width - coreEvent.deltaX;
            } else {
              newSize.width = this.resizing.width + coreEvent.deltaX;
            }

            newSize.height = this.resizing.height + coreEvent.deltaY; ///console.log("### resize => " + event.type + ", deltaX=" + coreEvent.deltaX + ", deltaY=" + coreEvent.deltaY);

            this.resizing = newSize;
            break;
          }

        case "resizeend":
          {
            //console.log("### resize end => x=" +this.innerX + " y=" + this.innerY + " w=" + this.innerW + " h=" + this.innerH);
            pos = this.calcPosition(this.innerX, this.innerY, this.innerW, this.innerH);
            newSize.width = pos.width;
            newSize.height = pos.height; //                        console.log("### resize end => " + JSON.stringify(newSize));

            this.resizing = null;
            this.isResizing = false;
            break;
          }
      } // Get new WH


      pos = this.calcWH(newSize.height, newSize.width);

      if (pos.w < this.minW) {
        pos.w = this.minW;
      }

      if (pos.w > this.maxW) {
        pos.w = this.maxW;
      }

      if (pos.h < this.minH) {
        pos.h = this.minH;
      }

      if (pos.h > this.maxH) {
        pos.h = this.maxH;
      }

      if (pos.h < 1) {
        pos.h = 1;
      }

      if (pos.w < 1) {
        pos.w = 1;
      }

      this.lastW = x;
      this.lastH = y;

      if (this.innerW !== pos.w || this.innerH !== pos.h) {
        this.$emit("resize", this.i, pos.h, pos.w, newSize.height, newSize.width);
      }

      if (event.type === "resizeend" && (this.previousW !== this.innerW || this.previousH !== this.innerH)) {
        this.$emit("resized", this.i, pos.h, pos.w, newSize.height, newSize.width);
      }

      this.eventBus.$emit("resizeEvent", event.type, this.i, this.innerX, this.innerY, pos.h, pos.w);
    },
    handleDrag: function handleDrag(event) {
      if (this.static) return;
      if (this.isResizing) return;
      var position = getControlPosition(event); // Get the current drag point from the event. This is used as the offset.

      if (position === null) return; // not possible but satisfies flow

      var x = position.x,
          y = position.y; // let shouldUpdate = false;

      var newPosition = {
        top: 0,
        left: 0
      };

      switch (event.type) {
        case "dragstart":
          {
            this.previousX = this.innerX;
            this.previousY = this.innerY;
            var parentRect = event.target.offsetParent.getBoundingClientRect();
            var clientRect = event.target.getBoundingClientRect();

            if (this.renderRtl) {
              newPosition.left = (clientRect.right - parentRect.right) * -1;
            } else {
              newPosition.left = clientRect.left - parentRect.left;
            }

            newPosition.top = clientRect.top - parentRect.top;
            this.dragging = newPosition;
            this.isDragging = true;
            break;
          }

        case "dragend":
          {
            if (!this.isDragging) return;

            var _parentRect = event.target.offsetParent.getBoundingClientRect();

            var _clientRect = event.target.getBoundingClientRect(); //                        Add rtl support


            if (this.renderRtl) {
              newPosition.left = (_clientRect.right - _parentRect.right) * -1;
            } else {
              newPosition.left = _clientRect.left - _parentRect.left;
            }

            newPosition.top = _clientRect.top - _parentRect.top; //                        console.log("### drag end => " + JSON.stringify(newPosition));
            //                        console.log("### DROP: " + JSON.stringify(newPosition));

            this.dragging = null;
            this.isDragging = false; // shouldUpdate = true;

            break;
          }

        case "dragmove":
          {
            var coreEvent = createCoreData(this.lastX, this.lastY, x, y); //                        Add rtl support

            if (this.renderRtl) {
              newPosition.left = this.dragging.left - coreEvent.deltaX;
            } else {
              newPosition.left = this.dragging.left + coreEvent.deltaX;
            }

            newPosition.top = this.dragging.top + coreEvent.deltaY; //                        console.log("### drag => " + event.type + ", x=" + x + ", y=" + y);
            //                        console.log("### drag => " + event.type + ", deltaX=" + coreEvent.deltaX + ", deltaY=" + coreEvent.deltaY);
            //                        console.log("### drag end => " + JSON.stringify(newPosition));

            this.dragging = newPosition;
            break;
          }
      } // Get new XY


      var pos;

      if (this.renderRtl) {
        pos = this.calcXY(newPosition.top, newPosition.left);
      } else {
        pos = this.calcXY(newPosition.top, newPosition.left);
      }

      this.lastX = x;
      this.lastY = y;

      if (this.innerX !== pos.x || this.innerY !== pos.y) {
        this.$emit("move", this.i, pos.x, pos.y);
      }

      if (event.type === "dragend" && (this.previousX !== this.innerX || this.previousY !== this.innerY)) {
        this.$emit("moved", this.i, pos.x, pos.y);
      }

      this.eventBus.$emit("dragEvent", event.type, this.i, pos.x, pos.y, this.innerH, this.innerW);
    },
    calcPosition: function calcPosition(x, y, w, h) {
      var colWidth = this.calcColWidth(); // add rtl support

      var out;

      if (this.renderRtl) {
        out = {
          right: Math.round(colWidth * x + (x + 1) * this.margin[0]),
          top: Math.round(this.rowHeight * y + (y + 1) * this.margin[1]),
          // 0 * Infinity === NaN, which causes problems with resize constriants;
          // Fix this if it occurs.
          // Note we do it here rather than later because Math.round(Infinity) causes deopt
          width: w === Infinity ? w : Math.round(colWidth * w + Math.max(0, w - 1) * this.margin[0]),
          height: h === Infinity ? h : Math.round(this.rowHeight * h + Math.max(0, h - 1) * this.margin[1])
        };
      } else {
        out = {
          left: Math.round(colWidth * x + (x + 1) * this.margin[0]),
          top: Math.round(this.rowHeight * y + (y + 1) * this.margin[1]),
          // 0 * Infinity === NaN, which causes problems with resize constriants;
          // Fix this if it occurs.
          // Note we do it here rather than later because Math.round(Infinity) causes deopt
          width: w === Infinity ? w : Math.round(colWidth * w + Math.max(0, w - 1) * this.margin[0]),
          height: h === Infinity ? h : Math.round(this.rowHeight * h + Math.max(0, h - 1) * this.margin[1])
        };
      }

      return out;
    },

    /**
     * Translate x and y coordinates from pixels to grid units.
     * @param  {Number} top  Top position (relative to parent) in pixels.
     * @param  {Number} left Left position (relative to parent) in pixels.
     * @return {Object} x and y in grid units.
     */
    // TODO check if this function needs change in order to support rtl.
    calcXY: function calcXY(top, left) {
      var colWidth = this.calcColWidth(); // left = colWidth * x + margin * (x + 1)
      // l = cx + m(x+1)
      // l = cx + mx + m
      // l - m = cx + mx
      // l - m = x(c + m)
      // (l - m) / (c + m) = x
      // x = (left - margin) / (coldWidth + margin)

      var x = Math.round((left - this.margin[0]) / (colWidth + this.margin[0]));
      var y = Math.round((top - this.margin[1]) / (this.rowHeight + this.margin[1])); // Capping

      x = Math.max(Math.min(x, this.cols - this.innerW), 0);
      y = Math.max(Math.min(y, this.maxRows - this.innerH), 0);
      return {
        x: x,
        y: y
      };
    },
    // Helper for generating column width
    calcColWidth: function calcColWidth() {
      var colWidth = (this.containerWidth - this.margin[0] * (this.cols + 1)) / this.cols; // console.log("### COLS=" + this.cols + " COL WIDTH=" + colWidth + " MARGIN " + this.margin[0]);

      return colWidth;
    },

    /**
     * Given a height and width in pixel values, calculate grid units.
     * @param  {Number} height Height in pixels.
     * @param  {Number} width  Width in pixels.
     * @return {Object} w, h as grid units.
     */
    calcWH: function calcWH(height, width) {
      var colWidth = this.calcColWidth(); // width = colWidth * w - (margin * (w - 1))
      // ...
      // w = (width + margin) / (colWidth + margin)

      var w = Math.round((width + this.margin[0]) / (colWidth + this.margin[0]));
      var h = Math.round((height + this.margin[1]) / (this.rowHeight + this.margin[1])); // Capping

      w = Math.max(Math.min(w, this.cols - this.innerX), 0);
      h = Math.max(Math.min(h, this.maxRows - this.innerY), 0);
      return {
        w: w,
        h: h
      };
    },
    updateWidth: function updateWidth(width, colNum) {
      this.containerWidth = width;

      if (colNum !== undefined && colNum !== null) {
        this.cols = colNum;
      }
    },
    compact: function compact() {
      this.createStyle();
    },
    tryMakeDraggable: function tryMakeDraggable() {
      var self = this;

      if (this.interactObj === null || this.interactObj === undefined) {
        this.interactObj = _interactjs_interact(this.$refs.item);

        if (!this.useStyleCursor) {
          this.interactObj.styleCursor(false);
        }
      }

      if (this.draggable && !this.static) {
        var opts = {
          ignoreFrom: this.dragIgnoreFrom,
          allowFrom: this.dragAllowFrom
        };
        this.interactObj.draggable(opts);
        /*this.interactObj.draggable({allowFrom: '.vue-draggable-handle'});*/

        if (!this.dragEventSet) {
          this.dragEventSet = true;
          this.interactObj.on('dragstart dragmove dragend', function (event) {
            self.handleDrag(event);
          });
        }
      } else {
        this.interactObj.draggable({
          enabled: false
        });
      }
    },
    tryMakeResizable: function tryMakeResizable() {
      var self = this;

      if (this.interactObj === null || this.interactObj === undefined) {
        this.interactObj = _interactjs_interact(this.$refs.item);

        if (!this.useStyleCursor) {
          this.interactObj.styleCursor(false);
        }
      }

      if (this.resizable && !this.static) {
        var maximum = this.calcPosition(0, 0, this.maxW, this.maxH);
        var minimum = this.calcPosition(0, 0, this.minW, this.minH); // console.log("### MAX " + JSON.stringify(maximum));
        // console.log("### MIN " + JSON.stringify(minimum));

        var opts = {
          // allowFrom: "." + this.resizableHandleClass.trim().replace(" ", "."),
          edges: {
            left: false,
            right: "." + this.resizableHandleClass.trim().replace(" ", "."),
            bottom: "." + this.resizableHandleClass.trim().replace(" ", "."),
            top: false
          },
          ignoreFrom: this.resizeIgnoreFrom,
          restrictSize: {
            min: {
              height: minimum.height,
              width: minimum.width
            },
            max: {
              height: maximum.height,
              width: maximum.width
            }
          }
        };

        if (this.preserveAspectRatio) {
          opts.modifiers = [_interactjs_interact.modifiers.aspectRatio({
            ratio: 'preserve'
          })];
        }

        this.interactObj.resizable(opts);

        if (!this.resizeEventSet) {
          this.resizeEventSet = true;
          this.interactObj.on('resizestart resizemove resizeend', function (event) {
            self.handleResize(event);
          });
        }
      } else {
        this.interactObj.resizable({
          enabled: false
        });
      }
    },
    autoSize: function autoSize() {
      // ok here we want to calculate if a resize is needed
      this.previousW = this.innerW;
      this.previousH = this.innerH;
      var newSize = this.$slots.default[0].elm.getBoundingClientRect();
      var pos = this.calcWH(newSize.height, newSize.width);

      if (pos.w < this.minW) {
        pos.w = this.minW;
      }

      if (pos.w > this.maxW) {
        pos.w = this.maxW;
      }

      if (pos.h < this.minH) {
        pos.h = this.minH;
      }

      if (pos.h > this.maxH) {
        pos.h = this.maxH;
      }

      if (pos.h < 1) {
        pos.h = 1;
      }

      if (pos.w < 1) {
        pos.w = 1;
      } // this.lastW = x; // basically, this is copied from resizehandler, but shouldn't be needed
      // this.lastH = y;


      if (this.innerW !== pos.w || this.innerH !== pos.h) {
        this.$emit("resize", this.i, pos.h, pos.w, newSize.height, newSize.width);
      }

      if (this.previousW !== pos.w || this.previousH !== pos.h) {
        this.$emit("resized", this.i, pos.h, pos.w, newSize.height, newSize.width);
        this.eventBus.$emit("resizeEvent", "resizeend", this.i, this.innerX, this.innerY, pos.h, pos.w);
      }
    }
  }
});
// CONCATENATED MODULE: ./src/components/GridItem.vue?vue&type=script&lang=js&
 /* harmony default export */ var components_GridItemvue_type_script_lang_js_ = (GridItemvue_type_script_lang_js_); 
// EXTERNAL MODULE: ./src/components/GridItem.vue?vue&type=style&index=0&lang=css&
var GridItemvue_type_style_index_0_lang_css_ = __nested_webpack_require_138031__("5ed4");

// EXTERNAL MODULE: ./node_modules/vue-loader/lib/runtime/componentNormalizer.js
var componentNormalizer = __nested_webpack_require_138031__("2877");

// CONCATENATED MODULE: ./src/components/GridItem.vue






/* normalize component */

var component = Object(componentNormalizer["a" /* default */])(
  components_GridItemvue_type_script_lang_js_,
  render,
  staticRenderFns,
  false,
  null,
  null,
  null
  
)

/* harmony default export */ var GridItem = __webpack_exports__["a"] = (component.exports);

/***/ }),

/***/ "be13":
/***/ (function(module, exports) {

// 7.2.1 RequireObjectCoercible(argument)
module.exports = function (it) {
  if (it == undefined) throw TypeError("Can't call method on  " + it);
  return it;
};


/***/ }),

/***/ "c274":
/***/ (function(module, exports, __nested_webpack_require_338228__) {

"use strict";


var utils = __nested_webpack_require_338228__("50bf");

module.exports = function batchProcessorMaker(options) {
    options             = options || {};
    var reporter        = options.reporter;
    var asyncProcess    = utils.getOption(options, "async", true);
    var autoProcess     = utils.getOption(options, "auto", true);

    if(autoProcess && !asyncProcess) {
        reporter && reporter.warn("Invalid options combination. auto=true and async=false is invalid. Setting async=true.");
        asyncProcess = true;
    }

    var batch = Batch();
    var asyncFrameHandler;
    var isProcessing = false;

    function addFunction(level, fn) {
        if(!isProcessing && autoProcess && asyncProcess && batch.size() === 0) {
            // Since this is async, it is guaranteed to be executed after that the fn is added to the batch.
            // This needs to be done before, since we're checking the size of the batch to be 0.
            processBatchAsync();
        }

        batch.add(level, fn);
    }

    function processBatch() {
        // Save the current batch, and create a new batch so that incoming functions are not added into the currently processing batch.
        // Continue processing until the top-level batch is empty (functions may be added to the new batch while processing, and so on).
        isProcessing = true;
        while (batch.size()) {
            var processingBatch = batch;
            batch = Batch();
            processingBatch.process();
        }
        isProcessing = false;
    }

    function forceProcessBatch(localAsyncProcess) {
        if (isProcessing) {
            return;
        }

        if(localAsyncProcess === undefined) {
            localAsyncProcess = asyncProcess;
        }

        if(asyncFrameHandler) {
            cancelFrame(asyncFrameHandler);
            asyncFrameHandler = null;
        }

        if(localAsyncProcess) {
            processBatchAsync();
        } else {
            processBatch();
        }
    }

    function processBatchAsync() {
        asyncFrameHandler = requestFrame(processBatch);
    }

    function clearBatch() {
        batch           = {};
        batchSize       = 0;
        topLevel        = 0;
        bottomLevel     = 0;
    }

    function cancelFrame(listener) {
        // var cancel = window.cancelAnimationFrame || window.mozCancelAnimationFrame || window.webkitCancelAnimationFrame || window.clearTimeout;
        var cancel = clearTimeout;
        return cancel(listener);
    }

    function requestFrame(callback) {
        // var raf = window.requestAnimationFrame || window.mozRequestAnimationFrame || window.webkitRequestAnimationFrame || function(fn) { return window.setTimeout(fn, 20); };
        var raf = function(fn) { return setTimeout(fn, 0); };
        return raf(callback);
    }

    return {
        add: addFunction,
        force: forceProcessBatch
    };
};

function Batch() {
    var batch       = {};
    var size        = 0;
    var topLevel    = 0;
    var bottomLevel = 0;

    function add(level, fn) {
        if(!fn) {
            fn = level;
            level = 0;
        }

        if(level > topLevel) {
            topLevel = level;
        } else if(level < bottomLevel) {
            bottomLevel = level;
        }

        if(!batch[level]) {
            batch[level] = [];
        }

        batch[level].push(fn);
        size++;
    }

    function process() {
        for(var level = bottomLevel; level <= topLevel; level++) {
            var fns = batch[level];

            for(var i = 0; i < fns.length; i++) {
                var fn = fns[i];
                fn();
            }
        }
    }

    function getSize() {
        return size;
    }

    return {
        add: add,
        process: process,
        size: getSize
    };
}


/***/ }),

/***/ "c366":
/***/ (function(module, exports, __nested_webpack_require_342130__) {

// false -> Array#indexOf
// true  -> Array#includes
var toIObject = __nested_webpack_require_342130__("6821");
var toLength = __nested_webpack_require_342130__("9def");
var toAbsoluteIndex = __nested_webpack_require_342130__("77f1");
module.exports = function (IS_INCLUDES) {
  return function ($this, el, fromIndex) {
    var O = toIObject($this);
    var length = toLength(O.length);
    var index = toAbsoluteIndex(fromIndex, length);
    var value;
    // Array#includes uses SameValueZero equality algorithm
    // eslint-disable-next-line no-self-compare
    if (IS_INCLUDES && el != el) while (length > index) {
      value = O[index++];
      // eslint-disable-next-line no-self-compare
      if (value != value) return true;
    // Array#indexOf ignores holes, Array#includes - not
    } else for (;length > index; index++) if (IS_INCLUDES || index in O) {
      if (O[index] === el) return IS_INCLUDES || index || 0;
    } return !IS_INCLUDES && -1;
  };
};


/***/ }),

/***/ "c5f6":
/***/ (function(module, exports, __nested_webpack_require_343141__) {

"use strict";

var global = __nested_webpack_require_343141__("7726");
var has = __nested_webpack_require_343141__("69a8");
var cof = __nested_webpack_require_343141__("2d95");
var inheritIfRequired = __nested_webpack_require_343141__("5dbc");
var toPrimitive = __nested_webpack_require_343141__("6a99");
var fails = __nested_webpack_require_343141__("79e5");
var gOPN = __nested_webpack_require_343141__("9093").f;
var gOPD = __nested_webpack_require_343141__("11e9").f;
var dP = __nested_webpack_require_343141__("86cc").f;
var $trim = __nested_webpack_require_343141__("aa77").trim;
var NUMBER = 'Number';
var $Number = global[NUMBER];
var Base = $Number;
var proto = $Number.prototype;
// Opera ~12 has broken Object#toString
var BROKEN_COF = cof(__nested_webpack_require_343141__("2aeb")(proto)) == NUMBER;
var TRIM = 'trim' in String.prototype;

// 7.1.3 ToNumber(argument)
var toNumber = function (argument) {
  var it = toPrimitive(argument, false);
  if (typeof it == 'string' && it.length > 2) {
    it = TRIM ? it.trim() : $trim(it, 3);
    var first = it.charCodeAt(0);
    var third, radix, maxCode;
    if (first === 43 || first === 45) {
      third = it.charCodeAt(2);
      if (third === 88 || third === 120) return NaN; // Number('+0x1') should be NaN, old V8 fix
    } else if (first === 48) {
      switch (it.charCodeAt(1)) {
        case 66: case 98: radix = 2; maxCode = 49; break; // fast equal /^0b[01]+$/i
        case 79: case 111: radix = 8; maxCode = 55; break; // fast equal /^0o[0-7]+$/i
        default: return +it;
      }
      for (var digits = it.slice(2), i = 0, l = digits.length, code; i < l; i++) {
        code = digits.charCodeAt(i);
        // parseInt parses a string to a first unavailable symbol
        // but ToNumber should return NaN if a string contains unavailable symbols
        if (code < 48 || code > maxCode) return NaN;
      } return parseInt(digits, radix);
    }
  } return +it;
};

if (!$Number(' 0o1') || !$Number('0b1') || $Number('+0x1')) {
  $Number = function Number(value) {
    var it = arguments.length < 1 ? 0 : value;
    var that = this;
    return that instanceof $Number
      // check on 1..constructor(foo) case
      && (BROKEN_COF ? fails(function () { proto.valueOf.call(that); }) : cof(that) != NUMBER)
        ? inheritIfRequired(new Base(toNumber(it)), that, $Number) : toNumber(it);
  };
  for (var keys = __nested_webpack_require_343141__("9e1e") ? gOPN(Base) : (
    // ES3:
    'MAX_VALUE,MIN_VALUE,NaN,NEGATIVE_INFINITY,POSITIVE_INFINITY,' +
    // ES6 (in case, if modules with ES6 Number statics required before):
    'EPSILON,isFinite,isInteger,isNaN,isSafeInteger,MAX_SAFE_INTEGER,' +
    'MIN_SAFE_INTEGER,parseFloat,parseInt,isInteger'
  ).split(','), j = 0, key; keys.length > j; j++) {
    if (has(Base, key = keys[j]) && !has($Number, key)) {
      dP($Number, key, gOPD(Base, key));
    }
  }
  $Number.prototype = proto;
  proto.constructor = $Number;
  __nested_webpack_require_343141__("2aba")(global, NUMBER, $Number);
}


/***/ }),

/***/ "c69a":
/***/ (function(module, exports, __nested_webpack_require_346066__) {

module.exports = !__nested_webpack_require_346066__("9e1e") && !__nested_webpack_require_346066__("79e5")(function () {
  return Object.defineProperty(__nested_webpack_require_346066__("230e")('div'), 'a', { get: function () { return 7; } }).a != 7;
});


/***/ }),

/***/ "c8ba":
/***/ (function(module, exports) {

var g;

// This works in non-strict mode
g = (function() {
	return this;
})();

try {
	// This works if eval is allowed (see CSP)
	g = g || new Function("return this")();
} catch (e) {
	// This works if the window reference is available
	if (typeof window === "object") g = window;
}

// g can still be undefined, but nothing to do about it...
// We return undefined, instead of nothing here, so it's
// easier to handle this case. if(!global) { ...}

module.exports = g;


/***/ }),

/***/ "c946":
/***/ (function(module, exports, __nested_webpack_require_346897__) {

"use strict";
/**
 * Resize detection strategy that injects divs to elements in order to detect resize events on scroll events.
 * Heavily inspired by: https://github.com/marcj/css-element-queries/blob/master/src/ResizeSensor.js
 */



var forEach = __nested_webpack_require_346897__("b770").forEach;

module.exports = function(options) {
    options             = options || {};
    var reporter        = options.reporter;
    var batchProcessor  = options.batchProcessor;
    var getState        = options.stateHandler.getState;
    var hasState        = options.stateHandler.hasState;
    var idHandler       = options.idHandler;

    if (!batchProcessor) {
        throw new Error("Missing required dependency: batchProcessor");
    }

    if (!reporter) {
        throw new Error("Missing required dependency: reporter.");
    }

    //TODO: Could this perhaps be done at installation time?
    var scrollbarSizes = getScrollbarSizes();

    var styleId = "erd_scroll_detection_scrollbar_style";
    var detectionContainerClass = "erd_scroll_detection_container";

    function initDocument(targetDocument) {
        // Inject the scrollbar styling that prevents them from appearing sometimes in Chrome.
        // The injected container needs to have a class, so that it may be styled with CSS (pseudo elements).
        injectScrollStyle(targetDocument, styleId, detectionContainerClass);
    }

    initDocument(window.document);

    function buildCssTextString(rules) {
        var seperator = options.important ? " !important; " : "; ";

        return (rules.join(seperator) + seperator).trim();
    }

    function getScrollbarSizes() {
        var width = 500;
        var height = 500;

        var child = document.createElement("div");
        child.style.cssText = buildCssTextString(["position: absolute", "width: " + width*2 + "px", "height: " + height*2 + "px", "visibility: hidden", "margin: 0", "padding: 0"]);

        var container = document.createElement("div");
        container.style.cssText = buildCssTextString(["position: absolute", "width: " + width + "px", "height: " + height + "px", "overflow: scroll", "visibility: none", "top: " + -width*3 + "px", "left: " + -height*3 + "px", "visibility: hidden", "margin: 0", "padding: 0"]);

        container.appendChild(child);

        document.body.insertBefore(container, document.body.firstChild);

        var widthSize = width - container.clientWidth;
        var heightSize = height - container.clientHeight;

        document.body.removeChild(container);

        return {
            width: widthSize,
            height: heightSize
        };
    }

    function injectScrollStyle(targetDocument, styleId, containerClass) {
        function injectStyle(style, method) {
            method = method || function (element) {
                targetDocument.head.appendChild(element);
            };

            var styleElement = targetDocument.createElement("style");
            styleElement.innerHTML = style;
            styleElement.id = styleId;
            method(styleElement);
            return styleElement;
        }

        if (!targetDocument.getElementById(styleId)) {
            var containerAnimationClass = containerClass + "_animation";
            var containerAnimationActiveClass = containerClass + "_animation_active";
            var style = "/* Created by the element-resize-detector library. */\n";
            style += "." + containerClass + " > div::-webkit-scrollbar { " + buildCssTextString(["display: none"]) + " }\n\n";
            style += "." + containerAnimationActiveClass + " { " + buildCssTextString(["-webkit-animation-duration: 0.1s", "animation-duration: 0.1s", "-webkit-animation-name: " + containerAnimationClass, "animation-name: " + containerAnimationClass]) + " }\n";
            style += "@-webkit-keyframes " + containerAnimationClass +  " { 0% { opacity: 1; } 50% { opacity: 0; } 100% { opacity: 1; } }\n";
            style += "@keyframes " + containerAnimationClass +          " { 0% { opacity: 1; } 50% { opacity: 0; } 100% { opacity: 1; } }";
            injectStyle(style);
        }
    }

    function addAnimationClass(element) {
        element.className += " " + detectionContainerClass + "_animation_active";
    }

    function addEvent(el, name, cb) {
        if (el.addEventListener) {
            el.addEventListener(name, cb);
        } else if(el.attachEvent) {
            el.attachEvent("on" + name, cb);
        } else {
            return reporter.error("[scroll] Don't know how to add event listeners.");
        }
    }

    function removeEvent(el, name, cb) {
        if (el.removeEventListener) {
            el.removeEventListener(name, cb);
        } else if(el.detachEvent) {
            el.detachEvent("on" + name, cb);
        } else {
            return reporter.error("[scroll] Don't know how to remove event listeners.");
        }
    }

    function getExpandElement(element) {
        return getState(element).container.childNodes[0].childNodes[0].childNodes[0];
    }

    function getShrinkElement(element) {
        return getState(element).container.childNodes[0].childNodes[0].childNodes[1];
    }

    /**
     * Adds a resize event listener to the element.
     * @public
     * @param {element} element The element that should have the listener added.
     * @param {function} listener The listener callback to be called for each resize event of the element. The element will be given as a parameter to the listener callback.
     */
    function addListener(element, listener) {
        var listeners = getState(element).listeners;

        if (!listeners.push) {
            throw new Error("Cannot add listener to an element that is not detectable.");
        }

        getState(element).listeners.push(listener);
    }

    /**
     * Makes an element detectable and ready to be listened for resize events. Will call the callback when the element is ready to be listened for resize changes.
     * @private
     * @param {object} options Optional options object.
     * @param {element} element The element to make detectable
     * @param {function} callback The callback to be called when the element is ready to be listened for resize changes. Will be called with the element as first parameter.
     */
    function makeDetectable(options, element, callback) {
        if (!callback) {
            callback = element;
            element = options;
            options = null;
        }

        options = options || {};

        function debug() {
            if (options.debug) {
                var args = Array.prototype.slice.call(arguments);
                args.unshift(idHandler.get(element), "Scroll: ");
                if (reporter.log.apply) {
                    reporter.log.apply(null, args);
                } else {
                    for (var i = 0; i < args.length; i++) {
                        reporter.log(args[i]);
                    }
                }
            }
        }

        function isDetached(element) {
            function isInDocument(element) {
                return element === element.ownerDocument.body || element.ownerDocument.body.contains(element);
            }

            if (!isInDocument(element)) {
                return true;
            }

            // FireFox returns null style in hidden iframes. See https://github.com/wnr/element-resize-detector/issues/68 and https://bugzilla.mozilla.org/show_bug.cgi?id=795520
            if (window.getComputedStyle(element) === null) {
                return true;
            }

            return false;
        }

        function isUnrendered(element) {
            // Check the absolute positioned container since the top level container is display: inline.
            var container = getState(element).container.childNodes[0];
            var style = window.getComputedStyle(container);
            return !style.width || style.width.indexOf("px") === -1; //Can only compute pixel value when rendered.
        }

        function getStyle() {
            // Some browsers only force layouts when actually reading the style properties of the style object, so make sure that they are all read here,
            // so that the user of the function can be sure that it will perform the layout here, instead of later (important for batching).
            var elementStyle            = window.getComputedStyle(element);
            var style                   = {};
            style.position              = elementStyle.position;
            style.width                 = element.offsetWidth;
            style.height                = element.offsetHeight;
            style.top                   = elementStyle.top;
            style.right                 = elementStyle.right;
            style.bottom                = elementStyle.bottom;
            style.left                  = elementStyle.left;
            style.widthCSS              = elementStyle.width;
            style.heightCSS             = elementStyle.height;
            return style;
        }

        function storeStartSize() {
            var style = getStyle();
            getState(element).startSize = {
                width: style.width,
                height: style.height
            };
            debug("Element start size", getState(element).startSize);
        }

        function initListeners() {
            getState(element).listeners = [];
        }

        function storeStyle() {
            debug("storeStyle invoked.");
            if (!getState(element)) {
                debug("Aborting because element has been uninstalled");
                return;
            }

            var style = getStyle();
            getState(element).style = style;
        }

        function storeCurrentSize(element, width, height) {
            getState(element).lastWidth = width;
            getState(element).lastHeight  = height;
        }

        function getExpandChildElement(element) {
            return getExpandElement(element).childNodes[0];
        }

        function getWidthOffset() {
            return 2 * scrollbarSizes.width + 1;
        }

        function getHeightOffset() {
            return 2 * scrollbarSizes.height + 1;
        }

        function getExpandWidth(width) {
            return width + 10 + getWidthOffset();
        }

        function getExpandHeight(height) {
            return height + 10 + getHeightOffset();
        }

        function getShrinkWidth(width) {
            return width * 2 + getWidthOffset();
        }

        function getShrinkHeight(height) {
            return height * 2 + getHeightOffset();
        }

        function positionScrollbars(element, width, height) {
            var expand          = getExpandElement(element);
            var shrink          = getShrinkElement(element);
            var expandWidth     = getExpandWidth(width);
            var expandHeight    = getExpandHeight(height);
            var shrinkWidth     = getShrinkWidth(width);
            var shrinkHeight    = getShrinkHeight(height);
            expand.scrollLeft   = expandWidth;
            expand.scrollTop    = expandHeight;
            shrink.scrollLeft   = shrinkWidth;
            shrink.scrollTop    = shrinkHeight;
        }

        function injectContainerElement() {
            var container = getState(element).container;

            if (!container) {
                container                   = document.createElement("div");
                container.className         = detectionContainerClass;
                container.style.cssText     = buildCssTextString(["visibility: hidden", "display: inline", "width: 0px", "height: 0px", "z-index: -1", "overflow: hidden", "margin: 0", "padding: 0"]);
                getState(element).container = container;
                addAnimationClass(container);
                element.appendChild(container);

                var onAnimationStart = function () {
                    getState(element).onRendered && getState(element).onRendered();
                };

                addEvent(container, "animationstart", onAnimationStart);

                // Store the event handler here so that they may be removed when uninstall is called.
                // See uninstall function for an explanation why it is needed.
                getState(element).onAnimationStart = onAnimationStart;
            }

            return container;
        }

        function injectScrollElements() {
            function alterPositionStyles() {
                var style = getState(element).style;

                if(style.position === "static") {
                    element.style.setProperty("position", "relative",options.important ? "important" : "");

                    var removeRelativeStyles = function(reporter, element, style, property) {
                        function getNumericalValue(value) {
                            return value.replace(/[^-\d\.]/g, "");
                        }

                        var value = style[property];

                        if(value !== "auto" && getNumericalValue(value) !== "0") {
                            reporter.warn("An element that is positioned static has style." + property + "=" + value + " which is ignored due to the static positioning. The element will need to be positioned relative, so the style." + property + " will be set to 0. Element: ", element);
                            element.style[property] = 0;
                        }
                    };

                    //Check so that there are no accidental styles that will make the element styled differently now that is is relative.
                    //If there are any, set them to 0 (this should be okay with the user since the style properties did nothing before [since the element was positioned static] anyway).
                    removeRelativeStyles(reporter, element, style, "top");
                    removeRelativeStyles(reporter, element, style, "right");
                    removeRelativeStyles(reporter, element, style, "bottom");
                    removeRelativeStyles(reporter, element, style, "left");
                }
            }

            function getLeftTopBottomRightCssText(left, top, bottom, right) {
                left = (!left ? "0" : (left + "px"));
                top = (!top ? "0" : (top + "px"));
                bottom = (!bottom ? "0" : (bottom + "px"));
                right = (!right ? "0" : (right + "px"));

                return ["left: " + left, "top: " + top, "right: " + right, "bottom: " + bottom];
            }

            debug("Injecting elements");

            if (!getState(element)) {
                debug("Aborting because element has been uninstalled");
                return;
            }

            alterPositionStyles();

            var rootContainer = getState(element).container;

            if (!rootContainer) {
                rootContainer = injectContainerElement();
            }

            // Due to this WebKit bug https://bugs.webkit.org/show_bug.cgi?id=80808 (currently fixed in Blink, but still present in WebKit browsers such as Safari),
            // we need to inject two containers, one that is width/height 100% and another that is left/top -1px so that the final container always is 1x1 pixels bigger than
            // the targeted element.
            // When the bug is resolved, "containerContainer" may be removed.

            // The outer container can occasionally be less wide than the targeted when inside inline elements element in WebKit (see https://bugs.webkit.org/show_bug.cgi?id=152980).
            // This should be no problem since the inner container either way makes sure the injected scroll elements are at least 1x1 px.

            var scrollbarWidth          = scrollbarSizes.width;
            var scrollbarHeight         = scrollbarSizes.height;
            var containerContainerStyle = buildCssTextString(["position: absolute", "flex: none", "overflow: hidden", "z-index: -1", "visibility: hidden", "width: 100%", "height: 100%", "left: 0px", "top: 0px"]);
            var containerStyle          = buildCssTextString(["position: absolute", "flex: none", "overflow: hidden", "z-index: -1", "visibility: hidden"].concat(getLeftTopBottomRightCssText(-(1 + scrollbarWidth), -(1 + scrollbarHeight), -scrollbarHeight, -scrollbarWidth)));
            var expandStyle             = buildCssTextString(["position: absolute", "flex: none", "overflow: scroll", "z-index: -1", "visibility: hidden", "width: 100%", "height: 100%"]);
            var shrinkStyle             = buildCssTextString(["position: absolute", "flex: none", "overflow: scroll", "z-index: -1", "visibility: hidden", "width: 100%", "height: 100%"]);
            var expandChildStyle        = buildCssTextString(["position: absolute", "left: 0", "top: 0"]);
            var shrinkChildStyle        = buildCssTextString(["position: absolute", "width: 200%", "height: 200%"]);

            var containerContainer      = document.createElement("div");
            var container               = document.createElement("div");
            var expand                  = document.createElement("div");
            var expandChild             = document.createElement("div");
            var shrink                  = document.createElement("div");
            var shrinkChild             = document.createElement("div");

            // Some browsers choke on the resize system being rtl, so force it to ltr. https://github.com/wnr/element-resize-detector/issues/56
            // However, dir should not be set on the top level container as it alters the dimensions of the target element in some browsers.
            containerContainer.dir              = "ltr";

            containerContainer.style.cssText    = containerContainerStyle;
            containerContainer.className        = detectionContainerClass;
            container.className                 = detectionContainerClass;
            container.style.cssText             = containerStyle;
            expand.style.cssText                = expandStyle;
            expandChild.style.cssText           = expandChildStyle;
            shrink.style.cssText                = shrinkStyle;
            shrinkChild.style.cssText           = shrinkChildStyle;

            expand.appendChild(expandChild);
            shrink.appendChild(shrinkChild);
            container.appendChild(expand);
            container.appendChild(shrink);
            containerContainer.appendChild(container);
            rootContainer.appendChild(containerContainer);

            function onExpandScroll() {
                getState(element).onExpand && getState(element).onExpand();
            }

            function onShrinkScroll() {
                getState(element).onShrink && getState(element).onShrink();
            }

            addEvent(expand, "scroll", onExpandScroll);
            addEvent(shrink, "scroll", onShrinkScroll);

            // Store the event handlers here so that they may be removed when uninstall is called.
            // See uninstall function for an explanation why it is needed.
            getState(element).onExpandScroll = onExpandScroll;
            getState(element).onShrinkScroll = onShrinkScroll;
        }

        function registerListenersAndPositionElements() {
            function updateChildSizes(element, width, height) {
                var expandChild             = getExpandChildElement(element);
                var expandWidth             = getExpandWidth(width);
                var expandHeight            = getExpandHeight(height);
                expandChild.style.setProperty("width", expandWidth + "px", options.important ? "important" : "");
                expandChild.style.setProperty("height", expandHeight + "px", options.important ? "important" : "");
            }

            function updateDetectorElements(done) {
                var width           = element.offsetWidth;
                var height          = element.offsetHeight;

                // Check whether the size has actually changed since last time the algorithm ran. If not, some steps may be skipped.
                var sizeChanged = width !== getState(element).lastWidth || height !== getState(element).lastHeight;

                debug("Storing current size", width, height);

                // Store the size of the element sync here, so that multiple scroll events may be ignored in the event listeners.
                // Otherwise the if-check in handleScroll is useless.
                storeCurrentSize(element, width, height);

                // Since we delay the processing of the batch, there is a risk that uninstall has been called before the batch gets to execute.
                // Since there is no way to cancel the fn executions, we need to add an uninstall guard to all fns of the batch.

                batchProcessor.add(0, function performUpdateChildSizes() {
                    if (!sizeChanged) {
                        return;
                    }

                    if (!getState(element)) {
                        debug("Aborting because element has been uninstalled");
                        return;
                    }

                    if (!areElementsInjected()) {
                        debug("Aborting because element container has not been initialized");
                        return;
                    }

                    if (options.debug) {
                        var w = element.offsetWidth;
                        var h = element.offsetHeight;

                        if (w !== width || h !== height) {
                            reporter.warn(idHandler.get(element), "Scroll: Size changed before updating detector elements.");
                        }
                    }

                    updateChildSizes(element, width, height);
                });

                batchProcessor.add(1, function updateScrollbars() {
                    // This function needs to be invoked event though the size is unchanged. The element could have been resized very quickly and then
                    // been restored to the original size, which will have changed the scrollbar positions.

                    if (!getState(element)) {
                        debug("Aborting because element has been uninstalled");
                        return;
                    }

                    if (!areElementsInjected()) {
                        debug("Aborting because element container has not been initialized");
                        return;
                    }

                    positionScrollbars(element, width, height);
                });

                if (sizeChanged && done) {
                    batchProcessor.add(2, function () {
                        if (!getState(element)) {
                            debug("Aborting because element has been uninstalled");
                            return;
                        }

                        if (!areElementsInjected()) {
                          debug("Aborting because element container has not been initialized");
                          return;
                        }

                        done();
                    });
                }
            }

            function areElementsInjected() {
                return !!getState(element).container;
            }

            function notifyListenersIfNeeded() {
                function isFirstNotify() {
                    return getState(element).lastNotifiedWidth === undefined;
                }

                debug("notifyListenersIfNeeded invoked");

                var state = getState(element);

                // Don't notify if the current size is the start size, and this is the first notification.
                if (isFirstNotify() && state.lastWidth === state.startSize.width && state.lastHeight === state.startSize.height) {
                    return debug("Not notifying: Size is the same as the start size, and there has been no notification yet.");
                }

                // Don't notify if the size already has been notified.
                if (state.lastWidth === state.lastNotifiedWidth && state.lastHeight === state.lastNotifiedHeight) {
                    return debug("Not notifying: Size already notified");
                }


                debug("Current size not notified, notifying...");
                state.lastNotifiedWidth = state.lastWidth;
                state.lastNotifiedHeight = state.lastHeight;
                forEach(getState(element).listeners, function (listener) {
                    listener(element);
                });
            }

            function handleRender() {
                debug("startanimation triggered.");

                if (isUnrendered(element)) {
                    debug("Ignoring since element is still unrendered...");
                    return;
                }

                debug("Element rendered.");
                var expand = getExpandElement(element);
                var shrink = getShrinkElement(element);
                if (expand.scrollLeft === 0 || expand.scrollTop === 0 || shrink.scrollLeft === 0 || shrink.scrollTop === 0) {
                    debug("Scrollbars out of sync. Updating detector elements...");
                    updateDetectorElements(notifyListenersIfNeeded);
                }
            }

            function handleScroll() {
                debug("Scroll detected.");

                if (isUnrendered(element)) {
                    // Element is still unrendered. Skip this scroll event.
                    debug("Scroll event fired while unrendered. Ignoring...");
                    return;
                }

                updateDetectorElements(notifyListenersIfNeeded);
            }

            debug("registerListenersAndPositionElements invoked.");

            if (!getState(element)) {
                debug("Aborting because element has been uninstalled");
                return;
            }

            getState(element).onRendered = handleRender;
            getState(element).onExpand = handleScroll;
            getState(element).onShrink = handleScroll;

            var style = getState(element).style;
            updateChildSizes(element, style.width, style.height);
        }

        function finalizeDomMutation() {
            debug("finalizeDomMutation invoked.");

            if (!getState(element)) {
                debug("Aborting because element has been uninstalled");
                return;
            }

            var style = getState(element).style;
            storeCurrentSize(element, style.width, style.height);
            positionScrollbars(element, style.width, style.height);
        }

        function ready() {
            callback(element);
        }

        function install() {
            debug("Installing...");
            initListeners();
            storeStartSize();

            batchProcessor.add(0, storeStyle);
            batchProcessor.add(1, injectScrollElements);
            batchProcessor.add(2, registerListenersAndPositionElements);
            batchProcessor.add(3, finalizeDomMutation);
            batchProcessor.add(4, ready);
        }

        debug("Making detectable...");

        if (isDetached(element)) {
            debug("Element is detached");

            injectContainerElement();

            debug("Waiting until element is attached...");

            getState(element).onRendered = function () {
                debug("Element is now attached");
                install();
            };
        } else {
            install();
        }
    }

    function uninstall(element) {
        var state = getState(element);

        if (!state) {
            // Uninstall has been called on a non-erd element.
            return;
        }

        // Uninstall may have been called in the following scenarios:
        // (1) Right between the sync code and async batch (here state.busy = true, but nothing have been registered or injected).
        // (2) In the ready callback of the last level of the batch by another element (here, state.busy = true, but all the stuff has been injected).
        // (3) After the installation process (here, state.busy = false and all the stuff has been injected).
        // So to be on the safe side, let's check for each thing before removing.

        // We need to remove the event listeners, because otherwise the event might fire on an uninstall element which results in an error when trying to get the state of the element.
        state.onExpandScroll && removeEvent(getExpandElement(element), "scroll", state.onExpandScroll);
        state.onShrinkScroll && removeEvent(getShrinkElement(element), "scroll", state.onShrinkScroll);
        state.onAnimationStart && removeEvent(state.container, "animationstart", state.onAnimationStart);

        state.container && element.removeChild(state.container);
    }

    return {
        makeDetectable: makeDetectable,
        addListener: addListener,
        uninstall: uninstall,
        initDocument: initDocument
    };
};


/***/ }),

/***/ "ca5a":
/***/ (function(module, exports) {

var id = 0;
var px = Math.random();
module.exports = function (key) {
  return 'Symbol('.concat(key === undefined ? '' : key, ')_', (++id + px).toString(36));
};


/***/ }),

/***/ "cadf":
/***/ (function(module, exports, __nested_webpack_require_376370__) {

"use strict";

var addToUnscopables = __nested_webpack_require_376370__("9c6c");
var step = __nested_webpack_require_376370__("d53b");
var Iterators = __nested_webpack_require_376370__("84f2");
var toIObject = __nested_webpack_require_376370__("6821");

// 22.1.3.4 Array.prototype.entries()
// 22.1.3.13 Array.prototype.keys()
// 22.1.3.29 Array.prototype.values()
// 22.1.3.30 Array.prototype[@@iterator]()
module.exports = __nested_webpack_require_376370__("01f9")(Array, 'Array', function (iterated, kind) {
  this._t = toIObject(iterated); // target
  this._i = 0;                   // next index
  this._k = kind;                // kind
// 22.1.5.2.1 %ArrayIteratorPrototype%.next()
}, function () {
  var O = this._t;
  var kind = this._k;
  var index = this._i++;
  if (!O || index >= O.length) {
    this._t = undefined;
    return step(1);
  }
  if (kind == 'keys') return step(0, index);
  if (kind == 'values') return step(0, O[index]);
  return step(0, [index, O[index]]);
}, 'values');

// argumentsList[@@iterator] is %ArrayProto_values% (9.4.4.6, 9.4.4.7)
Iterators.Arguments = Iterators.Array;

addToUnscopables('keys');
addToUnscopables('values');
addToUnscopables('entries');


/***/ }),

/***/ "cb7c":
/***/ (function(module, exports, __nested_webpack_require_377579__) {

var isObject = __nested_webpack_require_377579__("d3f4");
module.exports = function (it) {
  if (!isObject(it)) throw TypeError(it + ' is not an object!');
  return it;
};


/***/ }),

/***/ "ce10":
/***/ (function(module, exports, __nested_webpack_require_377821__) {

var has = __nested_webpack_require_377821__("69a8");
var toIObject = __nested_webpack_require_377821__("6821");
var arrayIndexOf = __nested_webpack_require_377821__("c366")(false);
var IE_PROTO = __nested_webpack_require_377821__("613b")('IE_PROTO');

module.exports = function (object, names) {
  var O = toIObject(object);
  var i = 0;
  var result = [];
  var key;
  for (key in O) if (key != IE_PROTO) has(O, key) && result.push(key);
  // Don't enum bug & hidden keys
  while (names.length > i) if (has(O, key = names[i++])) {
    ~arrayIndexOf(result, key) || result.push(key);
  }
  return result;
};


/***/ }),

/***/ "d3f4":
/***/ (function(module, exports) {

module.exports = function (it) {
  return typeof it === 'object' ? it !== null : typeof it === 'function';
};


/***/ }),

/***/ "d53b":
/***/ (function(module, exports) {

module.exports = function (done, value) {
  return { value: value, done: !!done };
};


/***/ }),

/***/ "d6eb":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var prop = "_erd";

function initState(element) {
    element[prop] = {};
    return getState(element);
}

function getState(element) {
    return element[prop];
}

function cleanState(element) {
    delete element[prop];
}

module.exports = {
    initState: initState,
    getState: getState,
    cleanState: cleanState
};


/***/ }),

/***/ "d8e8":
/***/ (function(module, exports) {

module.exports = function (it) {
  if (typeof it != 'function') throw TypeError(it + ' is not a function!');
  return it;
};


/***/ }),

/***/ "e11e":
/***/ (function(module, exports) {

// IE 8- don't enum bug keys
module.exports = (
  'constructor,hasOwnProperty,isPrototypeOf,propertyIsEnumerable,toLocaleString,toString,valueOf'
).split(',');


/***/ }),

/***/ "e279":
/***/ (function(module, __webpack_exports__, __nested_webpack_require_379626__) {

"use strict";
/* harmony import */ var _node_modules_vue_style_loader_index_js_ref_6_oneOf_1_0_node_modules_css_loader_index_js_ref_6_oneOf_1_1_node_modules_vue_loader_lib_loaders_stylePostLoader_js_node_modules_postcss_loader_src_index_js_ref_6_oneOf_1_2_node_modules_postcss_loader_src_index_js_ref_6_oneOf_1_3_node_modules_cache_loader_dist_cjs_js_ref_0_0_node_modules_vue_loader_lib_index_js_vue_loader_options_GridLayout_vue_vue_type_style_index_0_lang_css___WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_379626__("1156");
/* harmony import */ var _node_modules_vue_style_loader_index_js_ref_6_oneOf_1_0_node_modules_css_loader_index_js_ref_6_oneOf_1_1_node_modules_vue_loader_lib_loaders_stylePostLoader_js_node_modules_postcss_loader_src_index_js_ref_6_oneOf_1_2_node_modules_postcss_loader_src_index_js_ref_6_oneOf_1_3_node_modules_cache_loader_dist_cjs_js_ref_0_0_node_modules_vue_loader_lib_index_js_vue_loader_options_GridLayout_vue_vue_type_style_index_0_lang_css___WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__nested_webpack_require_379626__.n(_node_modules_vue_style_loader_index_js_ref_6_oneOf_1_0_node_modules_css_loader_index_js_ref_6_oneOf_1_1_node_modules_vue_loader_lib_loaders_stylePostLoader_js_node_modules_postcss_loader_src_index_js_ref_6_oneOf_1_2_node_modules_postcss_loader_src_index_js_ref_6_oneOf_1_3_node_modules_cache_loader_dist_cjs_js_ref_0_0_node_modules_vue_loader_lib_index_js_vue_loader_options_GridLayout_vue_vue_type_style_index_0_lang_css___WEBPACK_IMPORTED_MODULE_0__);
/* unused harmony reexport * */


/***/ }),

/***/ "eec4":
/***/ (function(module, exports, __nested_webpack_require_381243__) {

"use strict";


var forEach                 = __nested_webpack_require_381243__("b770").forEach;
var elementUtilsMaker       = __nested_webpack_require_381243__("5be5");
var listenerHandlerMaker    = __nested_webpack_require_381243__("49ad");
var idGeneratorMaker        = __nested_webpack_require_381243__("2cef");
var idHandlerMaker          = __nested_webpack_require_381243__("5058");
var reporterMaker           = __nested_webpack_require_381243__("abb4");
var browserDetector         = __nested_webpack_require_381243__("18e9");
var batchProcessorMaker     = __nested_webpack_require_381243__("c274");
var stateHandler            = __nested_webpack_require_381243__("d6eb");

//Detection strategies.
var objectStrategyMaker     = __nested_webpack_require_381243__("18d2");
var scrollStrategyMaker     = __nested_webpack_require_381243__("c946");

function isCollection(obj) {
    return Array.isArray(obj) || obj.length !== undefined;
}

function toArray(collection) {
    if (!Array.isArray(collection)) {
        var array = [];
        forEach(collection, function (obj) {
            array.push(obj);
        });
        return array;
    } else {
        return collection;
    }
}

function isElement(obj) {
    return obj && obj.nodeType === 1;
}

/**
 * @typedef idHandler
 * @type {object}
 * @property {function} get Gets the resize detector id of the element.
 * @property {function} set Generate and sets the resize detector id of the element.
 */

/**
 * @typedef Options
 * @type {object}
 * @property {boolean} callOnAdd    Determines if listeners should be called when they are getting added.
                                    Default is true. If true, the listener is guaranteed to be called when it has been added.
                                    If false, the listener will not be guarenteed to be called when it has been added (does not prevent it from being called).
 * @property {idHandler} idHandler  A custom id handler that is responsible for generating, setting and retrieving id's for elements.
                                    If not provided, a default id handler will be used.
 * @property {reporter} reporter    A custom reporter that handles reporting logs, warnings and errors.
                                    If not provided, a default id handler will be used.
                                    If set to false, then nothing will be reported.
 * @property {boolean} debug        If set to true, the the system will report debug messages as default for the listenTo method.
 */

/**
 * Creates an element resize detector instance.
 * @public
 * @param {Options?} options Optional global options object that will decide how this instance will work.
 */
module.exports = function(options) {
    options = options || {};

    //idHandler is currently not an option to the listenTo function, so it should not be added to globalOptions.
    var idHandler;

    if (options.idHandler) {
        // To maintain compatability with idHandler.get(element, readonly), make sure to wrap the given idHandler
        // so that readonly flag always is true when it's used here. This may be removed next major version bump.
        idHandler = {
            get: function (element) { return options.idHandler.get(element, true); },
            set: options.idHandler.set
        };
    } else {
        var idGenerator = idGeneratorMaker();
        var defaultIdHandler = idHandlerMaker({
            idGenerator: idGenerator,
            stateHandler: stateHandler
        });
        idHandler = defaultIdHandler;
    }

    //reporter is currently not an option to the listenTo function, so it should not be added to globalOptions.
    var reporter = options.reporter;

    if(!reporter) {
        //If options.reporter is false, then the reporter should be quiet.
        var quiet = reporter === false;
        reporter = reporterMaker(quiet);
    }

    //batchProcessor is currently not an option to the listenTo function, so it should not be added to globalOptions.
    var batchProcessor = getOption(options, "batchProcessor", batchProcessorMaker({ reporter: reporter }));

    //Options to be used as default for the listenTo function.
    var globalOptions = {};
    globalOptions.callOnAdd     = !!getOption(options, "callOnAdd", true);
    globalOptions.debug         = !!getOption(options, "debug", false);

    var eventListenerHandler    = listenerHandlerMaker(idHandler);
    var elementUtils            = elementUtilsMaker({
        stateHandler: stateHandler
    });

    //The detection strategy to be used.
    var detectionStrategy;
    var desiredStrategy = getOption(options, "strategy", "object");
    var importantCssRules = getOption(options, "important", false);
    var strategyOptions = {
        reporter: reporter,
        batchProcessor: batchProcessor,
        stateHandler: stateHandler,
        idHandler: idHandler,
        important: importantCssRules
    };

    if(desiredStrategy === "scroll") {
        if (browserDetector.isLegacyOpera()) {
            reporter.warn("Scroll strategy is not supported on legacy Opera. Changing to object strategy.");
            desiredStrategy = "object";
        } else if (browserDetector.isIE(9)) {
            reporter.warn("Scroll strategy is not supported on IE9. Changing to object strategy.");
            desiredStrategy = "object";
        }
    }

    if(desiredStrategy === "scroll") {
        detectionStrategy = scrollStrategyMaker(strategyOptions);
    } else if(desiredStrategy === "object") {
        detectionStrategy = objectStrategyMaker(strategyOptions);
    } else {
        throw new Error("Invalid strategy name: " + desiredStrategy);
    }

    //Calls can be made to listenTo with elements that are still being installed.
    //Also, same elements can occur in the elements list in the listenTo function.
    //With this map, the ready callbacks can be synchronized between the calls
    //so that the ready callback can always be called when an element is ready - even if
    //it wasn't installed from the function itself.
    var onReadyCallbacks = {};

    /**
     * Makes the given elements resize-detectable and starts listening to resize events on the elements. Calls the event callback for each event for each element.
     * @public
     * @param {Options?} options Optional options object. These options will override the global options. Some options may not be overriden, such as idHandler.
     * @param {element[]|element} elements The given array of elements to detect resize events of. Single element is also valid.
     * @param {function} listener The callback to be executed for each resize event for each element.
     */
    function listenTo(options, elements, listener) {
        function onResizeCallback(element) {
            var listeners = eventListenerHandler.get(element);
            forEach(listeners, function callListenerProxy(listener) {
                listener(element);
            });
        }

        function addListener(callOnAdd, element, listener) {
            eventListenerHandler.add(element, listener);

            if(callOnAdd) {
                listener(element);
            }
        }

        //Options object may be omitted.
        if(!listener) {
            listener = elements;
            elements = options;
            options = {};
        }

        if(!elements) {
            throw new Error("At least one element required.");
        }

        if(!listener) {
            throw new Error("Listener required.");
        }

        if (isElement(elements)) {
            // A single element has been passed in.
            elements = [elements];
        } else if (isCollection(elements)) {
            // Convert collection to array for plugins.
            // TODO: May want to check so that all the elements in the collection are valid elements.
            elements = toArray(elements);
        } else {
            return reporter.error("Invalid arguments. Must be a DOM element or a collection of DOM elements.");
        }

        var elementsReady = 0;

        var callOnAdd = getOption(options, "callOnAdd", globalOptions.callOnAdd);
        var onReadyCallback = getOption(options, "onReady", function noop() {});
        var debug = getOption(options, "debug", globalOptions.debug);

        forEach(elements, function attachListenerToElement(element) {
            if (!stateHandler.getState(element)) {
                stateHandler.initState(element);
                idHandler.set(element);
            }

            var id = idHandler.get(element);

            debug && reporter.log("Attaching listener to element", id, element);

            if(!elementUtils.isDetectable(element)) {
                debug && reporter.log(id, "Not detectable.");
                if(elementUtils.isBusy(element)) {
                    debug && reporter.log(id, "System busy making it detectable");

                    //The element is being prepared to be detectable. Do not make it detectable.
                    //Just add the listener, because the element will soon be detectable.
                    addListener(callOnAdd, element, listener);
                    onReadyCallbacks[id] = onReadyCallbacks[id] || [];
                    onReadyCallbacks[id].push(function onReady() {
                        elementsReady++;

                        if(elementsReady === elements.length) {
                            onReadyCallback();
                        }
                    });
                    return;
                }

                debug && reporter.log(id, "Making detectable...");
                //The element is not prepared to be detectable, so do prepare it and add a listener to it.
                elementUtils.markBusy(element, true);
                return detectionStrategy.makeDetectable({ debug: debug, important: importantCssRules }, element, function onElementDetectable(element) {
                    debug && reporter.log(id, "onElementDetectable");

                    if (stateHandler.getState(element)) {
                        elementUtils.markAsDetectable(element);
                        elementUtils.markBusy(element, false);
                        detectionStrategy.addListener(element, onResizeCallback);
                        addListener(callOnAdd, element, listener);

                        // Since the element size might have changed since the call to "listenTo", we need to check for this change,
                        // so that a resize event may be emitted.
                        // Having the startSize object is optional (since it does not make sense in some cases such as unrendered elements), so check for its existance before.
                        // Also, check the state existance before since the element may have been uninstalled in the installation process.
                        var state = stateHandler.getState(element);
                        if (state && state.startSize) {
                            var width = element.offsetWidth;
                            var height = element.offsetHeight;
                            if (state.startSize.width !== width || state.startSize.height !== height) {
                                onResizeCallback(element);
                            }
                        }

                        if(onReadyCallbacks[id]) {
                            forEach(onReadyCallbacks[id], function(callback) {
                                callback();
                            });
                        }
                    } else {
                        // The element has been unisntalled before being detectable.
                        debug && reporter.log(id, "Element uninstalled before being detectable.");
                    }

                    delete onReadyCallbacks[id];

                    elementsReady++;
                    if(elementsReady === elements.length) {
                        onReadyCallback();
                    }
                });
            }

            debug && reporter.log(id, "Already detecable, adding listener.");

            //The element has been prepared to be detectable and is ready to be listened to.
            addListener(callOnAdd, element, listener);
            elementsReady++;
        });

        if(elementsReady === elements.length) {
            onReadyCallback();
        }
    }

    function uninstall(elements) {
        if(!elements) {
            return reporter.error("At least one element is required.");
        }

        if (isElement(elements)) {
            // A single element has been passed in.
            elements = [elements];
        } else if (isCollection(elements)) {
            // Convert collection to array for plugins.
            // TODO: May want to check so that all the elements in the collection are valid elements.
            elements = toArray(elements);
        } else {
            return reporter.error("Invalid arguments. Must be a DOM element or a collection of DOM elements.");
        }

        forEach(elements, function (element) {
            eventListenerHandler.removeAllListeners(element);
            detectionStrategy.uninstall(element);
            stateHandler.cleanState(element);
        });
    }

    function initDocument(targetDocument) {
        detectionStrategy.initDocument && detectionStrategy.initDocument(targetDocument);
    }

    return {
        listenTo: listenTo,
        removeListener: eventListenerHandler.removeListener,
        removeAllListeners: eventListenerHandler.removeAllListeners,
        uninstall: uninstall,
        initDocument: initDocument
    };
};

function getOption(options, name, defaultValue) {
    var value = options[name];

    if((value === undefined || value === null) && defaultValue !== undefined) {
        return defaultValue;
    }

    return value;
}


/***/ }),

/***/ "f1ae":
/***/ (function(module, exports, __nested_webpack_require_395051__) {

"use strict";

var $defineProperty = __nested_webpack_require_395051__("86cc");
var createDesc = __nested_webpack_require_395051__("4630");

module.exports = function (object, index, value) {
  if (index in object) $defineProperty.f(object, index, createDesc(0, value));
  else object[index] = value;
};


/***/ }),

/***/ "f6fd":
/***/ (function(module, exports) {

// document.currentScript polyfill by Adam Miller

// MIT license

(function(document){
  var currentScript = "currentScript",
      scripts = document.getElementsByTagName('script'); // Live NodeList collection

  // If browser needs currentScript polyfill, add get currentScript() to the document object
  if (!(currentScript in document)) {
    Object.defineProperty(document, currentScript, {
      get: function(){

        // IE 6-10 supports script readyState
        // IE 10+ support stack trace
        try { throw new Error(); }
        catch (err) {

          // Find the second match for the "at" string to get file src url from stack.
          // Specifically works with the format of stack traces in IE.
          var i, res = ((/.*at [^\(]*\((.*):.+:.+\)$/ig).exec(err.stack) || [false])[1];

          // For all scripts on the page, if src matches or if ready state is interactive, return the script tag
          for(i in scripts){
            if(scripts[i].src == res || scripts[i].readyState == "interactive"){
              return scripts[i];
            }
          }

          // If no match, return null
          return null;
        }
      }
    });
  }
})(document);


/***/ }),

/***/ "f751":
/***/ (function(module, exports, __nested_webpack_require_396673__) {

// 19.1.3.1 Object.assign(target, source)
var $export = __nested_webpack_require_396673__("5ca1");

$export($export.S + $export.F, 'Object', { assign: __nested_webpack_require_396673__("7333") });


/***/ }),

/***/ "fa5b":
/***/ (function(module, exports, __nested_webpack_require_396926__) {

module.exports = __nested_webpack_require_396926__("5537")('native-function-to-string', Function.toString);


/***/ }),

/***/ "fab2":
/***/ (function(module, exports, __nested_webpack_require_397104__) {

var document = __nested_webpack_require_397104__("7726").document;
module.exports = document && document.documentElement;


/***/ }),

/***/ "fb15":
/***/ (function(module, __webpack_exports__, __nested_webpack_require_397308__) {

"use strict";
// ESM COMPAT FLAG
__nested_webpack_require_397308__.r(__webpack_exports__);

// EXPORTS
__nested_webpack_require_397308__.d(__webpack_exports__, "install", function() { return /* reexport */ components["d" /* install */]; });
__nested_webpack_require_397308__.d(__webpack_exports__, "GridLayout", function() { return /* reexport */ components["b" /* GridLayout */]; });
__nested_webpack_require_397308__.d(__webpack_exports__, "GridItem", function() { return /* reexport */ components["a" /* GridItem */]; });

// CONCATENATED MODULE: ./node_modules/@vue/cli-service/lib/commands/build/setPublicPath.js
// This file is imported into lib/wc client bundles.

if (typeof window !== 'undefined') {
  if (true) {
    __nested_webpack_require_397308__("f6fd")
  }

  var i
  if ((i = window.document.currentScript) && (i = i.src.match(/(.+\/)[^/]+\.js(\?.*)?$/))) {
    __nested_webpack_require_397308__.p = i[1] // eslint-disable-line
  }
}

// Indicate to webpack that this file can be concatenated
/* harmony default export */ var setPublicPath = (null);

// EXTERNAL MODULE: ./src/components/index.js
var components = __nested_webpack_require_397308__("2af9");

// CONCATENATED MODULE: ./node_modules/@vue/cli-service/lib/commands/build/entry-lib.js


/* harmony default export */ var entry_lib = __webpack_exports__["default"] = (components["c" /* default */]);



/***/ }),

/***/ "fca0":
/***/ (function(module, exports, __nested_webpack_require_398671__) {

// 20.1.2.2 Number.isFinite(number)
var $export = __nested_webpack_require_398671__("5ca1");
var _isFinite = __nested_webpack_require_398671__("7726").isFinite;

$export($export.S, 'Number', {
  isFinite: function isFinite(it) {
    return typeof it == 'number' && _isFinite(it);
  }
});


/***/ }),

/***/ "fdef":
/***/ (function(module, exports) {

module.exports = '\x09\x0A\x0B\x0C\x0D\x20\xA0\u1680\u180E\u2000\u2001\u2002\u2003' +
  '\u2004\u2005\u2006\u2007\u2008\u2009\u200A\u202F\u205F\u3000\u2028\u2029\uFEFF';


/***/ })

/******/ })["default"];
//# sourceMappingURL=vue-grid-layout.common.js.map

/***/ }),

/***/ "./resources/src/Pages/bot/BotTradePage.vue":
/*!**************************************************!*\
  !*** ./resources/src/Pages/bot/BotTradePage.vue ***!
  \**************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _BotTradePage_vue_vue_type_template_id_22f98bc2___WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./BotTradePage.vue?vue&type=template&id=22f98bc2& */ "./resources/src/Pages/bot/BotTradePage.vue?vue&type=template&id=22f98bc2&");
/* harmony import */ var _BotTradePage_vue_vue_type_script_lang_js___WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./BotTradePage.vue?vue&type=script&lang=js& */ "./resources/src/Pages/bot/BotTradePage.vue?vue&type=script&lang=js&");
/* harmony import */ var _BotTradePage_vue_vue_type_style_index_0_lang_scss_scope_true___WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./BotTradePage.vue?vue&type=style&index=0&lang=scss&scope=true& */ "./resources/src/Pages/bot/BotTradePage.vue?vue&type=style&index=0&lang=scss&scope=true&");
/* harmony import */ var _node_modules_vue_loader_lib_runtime_componentNormalizer_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! !../../../../node_modules/vue-loader/lib/runtime/componentNormalizer.js */ "./node_modules/vue-loader/lib/runtime/componentNormalizer.js");



;


/* normalize component */

var component = (0,_node_modules_vue_loader_lib_runtime_componentNormalizer_js__WEBPACK_IMPORTED_MODULE_3__["default"])(
  _BotTradePage_vue_vue_type_script_lang_js___WEBPACK_IMPORTED_MODULE_1__["default"],
  _BotTradePage_vue_vue_type_template_id_22f98bc2___WEBPACK_IMPORTED_MODULE_0__.render,
  _BotTradePage_vue_vue_type_template_id_22f98bc2___WEBPACK_IMPORTED_MODULE_0__.staticRenderFns,
  false,
  null,
  null,
  null
  
)

/* hot reload */
if (false) { var api; }
component.options.__file = "resources/src/Pages/bot/BotTradePage.vue"
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (component.exports);

/***/ }),

/***/ "./resources/src/components/bot/Trades.vue":
/*!*************************************************!*\
  !*** ./resources/src/components/bot/Trades.vue ***!
  \*************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _Trades_vue_vue_type_template_id_0c77c49d___WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Trades.vue?vue&type=template&id=0c77c49d& */ "./resources/src/components/bot/Trades.vue?vue&type=template&id=0c77c49d&");
/* harmony import */ var _Trades_vue_vue_type_script_lang_js___WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Trades.vue?vue&type=script&lang=js& */ "./resources/src/components/bot/Trades.vue?vue&type=script&lang=js&");
/* harmony import */ var _node_modules_vue_loader_lib_runtime_componentNormalizer_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! !../../../../node_modules/vue-loader/lib/runtime/componentNormalizer.js */ "./node_modules/vue-loader/lib/runtime/componentNormalizer.js");





/* normalize component */
;
var component = (0,_node_modules_vue_loader_lib_runtime_componentNormalizer_js__WEBPACK_IMPORTED_MODULE_2__["default"])(
  _Trades_vue_vue_type_script_lang_js___WEBPACK_IMPORTED_MODULE_1__["default"],
  _Trades_vue_vue_type_template_id_0c77c49d___WEBPACK_IMPORTED_MODULE_0__.render,
  _Trades_vue_vue_type_template_id_0c77c49d___WEBPACK_IMPORTED_MODULE_0__.staticRenderFns,
  false,
  null,
  null,
  null
  
)

/* hot reload */
if (false) { var api; }
component.options.__file = "resources/src/components/bot/Trades.vue"
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (component.exports);

/***/ }),

/***/ "./resources/src/components/trading/Marketinfo.vue":
/*!*********************************************************!*\
  !*** ./resources/src/components/trading/Marketinfo.vue ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _Marketinfo_vue_vue_type_template_id_a7005444___WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Marketinfo.vue?vue&type=template&id=a7005444& */ "./resources/src/components/trading/Marketinfo.vue?vue&type=template&id=a7005444&");
/* harmony import */ var _Marketinfo_vue_vue_type_script_lang_js___WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Marketinfo.vue?vue&type=script&lang=js& */ "./resources/src/components/trading/Marketinfo.vue?vue&type=script&lang=js&");
/* harmony import */ var _node_modules_vue_loader_lib_runtime_componentNormalizer_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! !../../../../node_modules/vue-loader/lib/runtime/componentNormalizer.js */ "./node_modules/vue-loader/lib/runtime/componentNormalizer.js");





/* normalize component */
;
var component = (0,_node_modules_vue_loader_lib_runtime_componentNormalizer_js__WEBPACK_IMPORTED_MODULE_2__["default"])(
  _Marketinfo_vue_vue_type_script_lang_js___WEBPACK_IMPORTED_MODULE_1__["default"],
  _Marketinfo_vue_vue_type_template_id_a7005444___WEBPACK_IMPORTED_MODULE_0__.render,
  _Marketinfo_vue_vue_type_template_id_a7005444___WEBPACK_IMPORTED_MODULE_0__.staticRenderFns,
  false,
  null,
  null,
  null
  
)

/* hot reload */
if (false) { var api; }
component.options.__file = "resources/src/components/trading/Marketinfo.vue"
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (component.exports);

/***/ }),

/***/ "./resources/src/components/trading/Markets.vue":
/*!******************************************************!*\
  !*** ./resources/src/components/trading/Markets.vue ***!
  \******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _Markets_vue_vue_type_template_id_d965ba1a___WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Markets.vue?vue&type=template&id=d965ba1a& */ "./resources/src/components/trading/Markets.vue?vue&type=template&id=d965ba1a&");
/* harmony import */ var _Markets_vue_vue_type_script_lang_js___WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Markets.vue?vue&type=script&lang=js& */ "./resources/src/components/trading/Markets.vue?vue&type=script&lang=js&");
/* harmony import */ var _Markets_vue_vue_type_style_index_0_lang_css___WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Markets.vue?vue&type=style&index=0&lang=css& */ "./resources/src/components/trading/Markets.vue?vue&type=style&index=0&lang=css&");
/* harmony import */ var _node_modules_vue_loader_lib_runtime_componentNormalizer_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! !../../../../node_modules/vue-loader/lib/runtime/componentNormalizer.js */ "./node_modules/vue-loader/lib/runtime/componentNormalizer.js");



;


/* normalize component */

var component = (0,_node_modules_vue_loader_lib_runtime_componentNormalizer_js__WEBPACK_IMPORTED_MODULE_3__["default"])(
  _Markets_vue_vue_type_script_lang_js___WEBPACK_IMPORTED_MODULE_1__["default"],
  _Markets_vue_vue_type_template_id_d965ba1a___WEBPACK_IMPORTED_MODULE_0__.render,
  _Markets_vue_vue_type_template_id_d965ba1a___WEBPACK_IMPORTED_MODULE_0__.staticRenderFns,
  false,
  null,
  null,
  null
  
)

/* hot reload */
if (false) { var api; }
component.options.__file = "resources/src/components/trading/Markets.vue"
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (component.exports);

/***/ }),

/***/ "./resources/src/components/trading/Orderbook.vue":
/*!********************************************************!*\
  !*** ./resources/src/components/trading/Orderbook.vue ***!
  \********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _Orderbook_vue_vue_type_template_id_4a636173___WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Orderbook.vue?vue&type=template&id=4a636173& */ "./resources/src/components/trading/Orderbook.vue?vue&type=template&id=4a636173&");
/* harmony import */ var _Orderbook_vue_vue_type_script_lang_js___WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Orderbook.vue?vue&type=script&lang=js& */ "./resources/src/components/trading/Orderbook.vue?vue&type=script&lang=js&");
/* harmony import */ var _node_modules_vue_loader_lib_runtime_componentNormalizer_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! !../../../../node_modules/vue-loader/lib/runtime/componentNormalizer.js */ "./node_modules/vue-loader/lib/runtime/componentNormalizer.js");





/* normalize component */
;
var component = (0,_node_modules_vue_loader_lib_runtime_componentNormalizer_js__WEBPACK_IMPORTED_MODULE_2__["default"])(
  _Orderbook_vue_vue_type_script_lang_js___WEBPACK_IMPORTED_MODULE_1__["default"],
  _Orderbook_vue_vue_type_template_id_4a636173___WEBPACK_IMPORTED_MODULE_0__.render,
  _Orderbook_vue_vue_type_template_id_4a636173___WEBPACK_IMPORTED_MODULE_0__.staticRenderFns,
  false,
  null,
  null,
  null
  
)

/* hot reload */
if (false) { var api; }
component.options.__file = "resources/src/components/trading/Orderbook.vue"
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (component.exports);

/***/ }),

/***/ "./resources/src/components/trading/Tradingview.vue":
/*!**********************************************************!*\
  !*** ./resources/src/components/trading/Tradingview.vue ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _Tradingview_vue_vue_type_template_id_e4f1b5fc___WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Tradingview.vue?vue&type=template&id=e4f1b5fc& */ "./resources/src/components/trading/Tradingview.vue?vue&type=template&id=e4f1b5fc&");
/* harmony import */ var _Tradingview_vue_vue_type_script_lang_js___WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Tradingview.vue?vue&type=script&lang=js& */ "./resources/src/components/trading/Tradingview.vue?vue&type=script&lang=js&");
/* harmony import */ var _node_modules_vue_loader_lib_runtime_componentNormalizer_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! !../../../../node_modules/vue-loader/lib/runtime/componentNormalizer.js */ "./node_modules/vue-loader/lib/runtime/componentNormalizer.js");





/* normalize component */
;
var component = (0,_node_modules_vue_loader_lib_runtime_componentNormalizer_js__WEBPACK_IMPORTED_MODULE_2__["default"])(
  _Tradingview_vue_vue_type_script_lang_js___WEBPACK_IMPORTED_MODULE_1__["default"],
  _Tradingview_vue_vue_type_template_id_e4f1b5fc___WEBPACK_IMPORTED_MODULE_0__.render,
  _Tradingview_vue_vue_type_template_id_e4f1b5fc___WEBPACK_IMPORTED_MODULE_0__.staticRenderFns,
  false,
  null,
  null,
  null
  
)

/* hot reload */
if (false) { var api; }
component.options.__file = "resources/src/components/trading/Tradingview.vue"
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (component.exports);

/***/ }),

/***/ "./resources/src/Pages/bot/BotTradePage.vue?vue&type=script&lang=js&":
/*!***************************************************************************!*\
  !*** ./resources/src/Pages/bot/BotTradePage.vue?vue&type=script&lang=js& ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _node_modules_babel_loader_lib_index_js_clonedRuleSet_5_0_rules_0_use_0_node_modules_vue_loader_lib_index_js_vue_loader_options_BotTradePage_vue_vue_type_script_lang_js___WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! -!../../../../node_modules/babel-loader/lib/index.js??clonedRuleSet-5[0].rules[0].use[0]!../../../../node_modules/vue-loader/lib/index.js??vue-loader-options!./BotTradePage.vue?vue&type=script&lang=js& */ "./node_modules/babel-loader/lib/index.js??clonedRuleSet-5[0].rules[0].use[0]!./node_modules/vue-loader/lib/index.js??vue-loader-options!./resources/src/Pages/bot/BotTradePage.vue?vue&type=script&lang=js&");
 /* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (_node_modules_babel_loader_lib_index_js_clonedRuleSet_5_0_rules_0_use_0_node_modules_vue_loader_lib_index_js_vue_loader_options_BotTradePage_vue_vue_type_script_lang_js___WEBPACK_IMPORTED_MODULE_0__["default"]); 

/***/ }),

/***/ "./resources/src/components/bot/Trades.vue?vue&type=script&lang=js&":
/*!**************************************************************************!*\
  !*** ./resources/src/components/bot/Trades.vue?vue&type=script&lang=js& ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _node_modules_babel_loader_lib_index_js_clonedRuleSet_5_0_rules_0_use_0_node_modules_vue_loader_lib_index_js_vue_loader_options_Trades_vue_vue_type_script_lang_js___WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! -!../../../../node_modules/babel-loader/lib/index.js??clonedRuleSet-5[0].rules[0].use[0]!../../../../node_modules/vue-loader/lib/index.js??vue-loader-options!./Trades.vue?vue&type=script&lang=js& */ "./node_modules/babel-loader/lib/index.js??clonedRuleSet-5[0].rules[0].use[0]!./node_modules/vue-loader/lib/index.js??vue-loader-options!./resources/src/components/bot/Trades.vue?vue&type=script&lang=js&");
 /* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (_node_modules_babel_loader_lib_index_js_clonedRuleSet_5_0_rules_0_use_0_node_modules_vue_loader_lib_index_js_vue_loader_options_Trades_vue_vue_type_script_lang_js___WEBPACK_IMPORTED_MODULE_0__["default"]); 

/***/ }),

/***/ "./resources/src/components/trading/Marketinfo.vue?vue&type=script&lang=js&":
/*!**********************************************************************************!*\
  !*** ./resources/src/components/trading/Marketinfo.vue?vue&type=script&lang=js& ***!
  \**********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _node_modules_babel_loader_lib_index_js_clonedRuleSet_5_0_rules_0_use_0_node_modules_vue_loader_lib_index_js_vue_loader_options_Marketinfo_vue_vue_type_script_lang_js___WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! -!../../../../node_modules/babel-loader/lib/index.js??clonedRuleSet-5[0].rules[0].use[0]!../../../../node_modules/vue-loader/lib/index.js??vue-loader-options!./Marketinfo.vue?vue&type=script&lang=js& */ "./node_modules/babel-loader/lib/index.js??clonedRuleSet-5[0].rules[0].use[0]!./node_modules/vue-loader/lib/index.js??vue-loader-options!./resources/src/components/trading/Marketinfo.vue?vue&type=script&lang=js&");
 /* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (_node_modules_babel_loader_lib_index_js_clonedRuleSet_5_0_rules_0_use_0_node_modules_vue_loader_lib_index_js_vue_loader_options_Marketinfo_vue_vue_type_script_lang_js___WEBPACK_IMPORTED_MODULE_0__["default"]); 

/***/ }),

/***/ "./resources/src/components/trading/Markets.vue?vue&type=script&lang=js&":
/*!*******************************************************************************!*\
  !*** ./resources/src/components/trading/Markets.vue?vue&type=script&lang=js& ***!
  \*******************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _node_modules_babel_loader_lib_index_js_clonedRuleSet_5_0_rules_0_use_0_node_modules_vue_loader_lib_index_js_vue_loader_options_Markets_vue_vue_type_script_lang_js___WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! -!../../../../node_modules/babel-loader/lib/index.js??clonedRuleSet-5[0].rules[0].use[0]!../../../../node_modules/vue-loader/lib/index.js??vue-loader-options!./Markets.vue?vue&type=script&lang=js& */ "./node_modules/babel-loader/lib/index.js??clonedRuleSet-5[0].rules[0].use[0]!./node_modules/vue-loader/lib/index.js??vue-loader-options!./resources/src/components/trading/Markets.vue?vue&type=script&lang=js&");
 /* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (_node_modules_babel_loader_lib_index_js_clonedRuleSet_5_0_rules_0_use_0_node_modules_vue_loader_lib_index_js_vue_loader_options_Markets_vue_vue_type_script_lang_js___WEBPACK_IMPORTED_MODULE_0__["default"]); 

/***/ }),

/***/ "./resources/src/components/trading/Orderbook.vue?vue&type=script&lang=js&":
/*!*********************************************************************************!*\
  !*** ./resources/src/components/trading/Orderbook.vue?vue&type=script&lang=js& ***!
  \*********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _node_modules_babel_loader_lib_index_js_clonedRuleSet_5_0_rules_0_use_0_node_modules_vue_loader_lib_index_js_vue_loader_options_Orderbook_vue_vue_type_script_lang_js___WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! -!../../../../node_modules/babel-loader/lib/index.js??clonedRuleSet-5[0].rules[0].use[0]!../../../../node_modules/vue-loader/lib/index.js??vue-loader-options!./Orderbook.vue?vue&type=script&lang=js& */ "./node_modules/babel-loader/lib/index.js??clonedRuleSet-5[0].rules[0].use[0]!./node_modules/vue-loader/lib/index.js??vue-loader-options!./resources/src/components/trading/Orderbook.vue?vue&type=script&lang=js&");
 /* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (_node_modules_babel_loader_lib_index_js_clonedRuleSet_5_0_rules_0_use_0_node_modules_vue_loader_lib_index_js_vue_loader_options_Orderbook_vue_vue_type_script_lang_js___WEBPACK_IMPORTED_MODULE_0__["default"]); 

/***/ }),

/***/ "./resources/src/components/trading/Tradingview.vue?vue&type=script&lang=js&":
/*!***********************************************************************************!*\
  !*** ./resources/src/components/trading/Tradingview.vue?vue&type=script&lang=js& ***!
  \***********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _node_modules_babel_loader_lib_index_js_clonedRuleSet_5_0_rules_0_use_0_node_modules_vue_loader_lib_index_js_vue_loader_options_Tradingview_vue_vue_type_script_lang_js___WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! -!../../../../node_modules/babel-loader/lib/index.js??clonedRuleSet-5[0].rules[0].use[0]!../../../../node_modules/vue-loader/lib/index.js??vue-loader-options!./Tradingview.vue?vue&type=script&lang=js& */ "./node_modules/babel-loader/lib/index.js??clonedRuleSet-5[0].rules[0].use[0]!./node_modules/vue-loader/lib/index.js??vue-loader-options!./resources/src/components/trading/Tradingview.vue?vue&type=script&lang=js&");
 /* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (_node_modules_babel_loader_lib_index_js_clonedRuleSet_5_0_rules_0_use_0_node_modules_vue_loader_lib_index_js_vue_loader_options_Tradingview_vue_vue_type_script_lang_js___WEBPACK_IMPORTED_MODULE_0__["default"]); 

/***/ }),

/***/ "./resources/src/components/trading/Markets.vue?vue&type=style&index=0&lang=css&":
/*!***************************************************************************************!*\
  !*** ./resources/src/components/trading/Markets.vue?vue&type=style&index=0&lang=css& ***!
  \***************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _node_modules_style_loader_dist_cjs_js_node_modules_laravel_mix_node_modules_css_loader_dist_cjs_js_clonedRuleSet_69_0_rules_0_use_1_node_modules_vue_loader_lib_loaders_stylePostLoader_js_node_modules_laravel_mix_node_modules_postcss_loader_dist_cjs_js_clonedRuleSet_69_0_rules_0_use_2_node_modules_vue_loader_lib_index_js_vue_loader_options_Markets_vue_vue_type_style_index_0_lang_css___WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! -!../../../../node_modules/style-loader/dist/cjs.js!../../../../node_modules/laravel-mix/node_modules/css-loader/dist/cjs.js??clonedRuleSet-69[0].rules[0].use[1]!../../../../node_modules/vue-loader/lib/loaders/stylePostLoader.js!../../../../node_modules/laravel-mix/node_modules/postcss-loader/dist/cjs.js??clonedRuleSet-69[0].rules[0].use[2]!../../../../node_modules/vue-loader/lib/index.js??vue-loader-options!./Markets.vue?vue&type=style&index=0&lang=css& */ "./node_modules/style-loader/dist/cjs.js!./node_modules/laravel-mix/node_modules/css-loader/dist/cjs.js??clonedRuleSet-69[0].rules[0].use[1]!./node_modules/vue-loader/lib/loaders/stylePostLoader.js!./node_modules/laravel-mix/node_modules/postcss-loader/dist/cjs.js??clonedRuleSet-69[0].rules[0].use[2]!./node_modules/vue-loader/lib/index.js??vue-loader-options!./resources/src/components/trading/Markets.vue?vue&type=style&index=0&lang=css&");


/***/ }),

/***/ "./resources/src/Pages/bot/BotTradePage.vue?vue&type=style&index=0&lang=scss&scope=true&":
/*!***********************************************************************************************!*\
  !*** ./resources/src/Pages/bot/BotTradePage.vue?vue&type=style&index=0&lang=scss&scope=true& ***!
  \***********************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _node_modules_style_loader_dist_cjs_js_node_modules_laravel_mix_node_modules_css_loader_dist_cjs_js_clonedRuleSet_72_0_rules_0_use_1_node_modules_vue_loader_lib_loaders_stylePostLoader_js_node_modules_laravel_mix_node_modules_postcss_loader_dist_cjs_js_clonedRuleSet_72_0_rules_0_use_2_node_modules_sass_loader_dist_cjs_js_clonedRuleSet_72_0_rules_0_use_3_node_modules_sass_loader_dist_cjs_js_clonedRuleSet_82_0_rules_0_use_0_node_modules_vue_loader_lib_index_js_vue_loader_options_BotTradePage_vue_vue_type_style_index_0_lang_scss_scope_true___WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! -!../../../../node_modules/style-loader/dist/cjs.js!../../../../node_modules/laravel-mix/node_modules/css-loader/dist/cjs.js??clonedRuleSet-72[0].rules[0].use[1]!../../../../node_modules/vue-loader/lib/loaders/stylePostLoader.js!../../../../node_modules/laravel-mix/node_modules/postcss-loader/dist/cjs.js??clonedRuleSet-72[0].rules[0].use[2]!../../../../node_modules/sass-loader/dist/cjs.js??clonedRuleSet-72[0].rules[0].use[3]!../../../../node_modules/sass-loader/dist/cjs.js??clonedRuleSet-82[0].rules[0].use[0]!../../../../node_modules/vue-loader/lib/index.js??vue-loader-options!./BotTradePage.vue?vue&type=style&index=0&lang=scss&scope=true& */ "./node_modules/style-loader/dist/cjs.js!./node_modules/laravel-mix/node_modules/css-loader/dist/cjs.js??clonedRuleSet-72[0].rules[0].use[1]!./node_modules/vue-loader/lib/loaders/stylePostLoader.js!./node_modules/laravel-mix/node_modules/postcss-loader/dist/cjs.js??clonedRuleSet-72[0].rules[0].use[2]!./node_modules/sass-loader/dist/cjs.js??clonedRuleSet-72[0].rules[0].use[3]!./node_modules/sass-loader/dist/cjs.js??clonedRuleSet-82[0].rules[0].use[0]!./node_modules/vue-loader/lib/index.js??vue-loader-options!./resources/src/Pages/bot/BotTradePage.vue?vue&type=style&index=0&lang=scss&scope=true&");


/***/ }),

/***/ "./resources/src/Pages/bot/BotTradePage.vue?vue&type=template&id=22f98bc2&":
/*!*********************************************************************************!*\
  !*** ./resources/src/Pages/bot/BotTradePage.vue?vue&type=template&id=22f98bc2& ***!
  \*********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "render": () => (/* reexport safe */ _node_modules_vue_loader_lib_loaders_templateLoader_js_vue_loader_options_node_modules_vue_loader_lib_index_js_vue_loader_options_BotTradePage_vue_vue_type_template_id_22f98bc2___WEBPACK_IMPORTED_MODULE_0__.render),
/* harmony export */   "staticRenderFns": () => (/* reexport safe */ _node_modules_vue_loader_lib_loaders_templateLoader_js_vue_loader_options_node_modules_vue_loader_lib_index_js_vue_loader_options_BotTradePage_vue_vue_type_template_id_22f98bc2___WEBPACK_IMPORTED_MODULE_0__.staticRenderFns)
/* harmony export */ });
/* harmony import */ var _node_modules_vue_loader_lib_loaders_templateLoader_js_vue_loader_options_node_modules_vue_loader_lib_index_js_vue_loader_options_BotTradePage_vue_vue_type_template_id_22f98bc2___WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! -!../../../../node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!../../../../node_modules/vue-loader/lib/index.js??vue-loader-options!./BotTradePage.vue?vue&type=template&id=22f98bc2& */ "./node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!./node_modules/vue-loader/lib/index.js??vue-loader-options!./resources/src/Pages/bot/BotTradePage.vue?vue&type=template&id=22f98bc2&");


/***/ }),

/***/ "./resources/src/components/bot/Trades.vue?vue&type=template&id=0c77c49d&":
/*!********************************************************************************!*\
  !*** ./resources/src/components/bot/Trades.vue?vue&type=template&id=0c77c49d& ***!
  \********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "render": () => (/* reexport safe */ _node_modules_vue_loader_lib_loaders_templateLoader_js_vue_loader_options_node_modules_vue_loader_lib_index_js_vue_loader_options_Trades_vue_vue_type_template_id_0c77c49d___WEBPACK_IMPORTED_MODULE_0__.render),
/* harmony export */   "staticRenderFns": () => (/* reexport safe */ _node_modules_vue_loader_lib_loaders_templateLoader_js_vue_loader_options_node_modules_vue_loader_lib_index_js_vue_loader_options_Trades_vue_vue_type_template_id_0c77c49d___WEBPACK_IMPORTED_MODULE_0__.staticRenderFns)
/* harmony export */ });
/* harmony import */ var _node_modules_vue_loader_lib_loaders_templateLoader_js_vue_loader_options_node_modules_vue_loader_lib_index_js_vue_loader_options_Trades_vue_vue_type_template_id_0c77c49d___WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! -!../../../../node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!../../../../node_modules/vue-loader/lib/index.js??vue-loader-options!./Trades.vue?vue&type=template&id=0c77c49d& */ "./node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!./node_modules/vue-loader/lib/index.js??vue-loader-options!./resources/src/components/bot/Trades.vue?vue&type=template&id=0c77c49d&");


/***/ }),

/***/ "./resources/src/components/trading/Marketinfo.vue?vue&type=template&id=a7005444&":
/*!****************************************************************************************!*\
  !*** ./resources/src/components/trading/Marketinfo.vue?vue&type=template&id=a7005444& ***!
  \****************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "render": () => (/* reexport safe */ _node_modules_vue_loader_lib_loaders_templateLoader_js_vue_loader_options_node_modules_vue_loader_lib_index_js_vue_loader_options_Marketinfo_vue_vue_type_template_id_a7005444___WEBPACK_IMPORTED_MODULE_0__.render),
/* harmony export */   "staticRenderFns": () => (/* reexport safe */ _node_modules_vue_loader_lib_loaders_templateLoader_js_vue_loader_options_node_modules_vue_loader_lib_index_js_vue_loader_options_Marketinfo_vue_vue_type_template_id_a7005444___WEBPACK_IMPORTED_MODULE_0__.staticRenderFns)
/* harmony export */ });
/* harmony import */ var _node_modules_vue_loader_lib_loaders_templateLoader_js_vue_loader_options_node_modules_vue_loader_lib_index_js_vue_loader_options_Marketinfo_vue_vue_type_template_id_a7005444___WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! -!../../../../node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!../../../../node_modules/vue-loader/lib/index.js??vue-loader-options!./Marketinfo.vue?vue&type=template&id=a7005444& */ "./node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!./node_modules/vue-loader/lib/index.js??vue-loader-options!./resources/src/components/trading/Marketinfo.vue?vue&type=template&id=a7005444&");


/***/ }),

/***/ "./resources/src/components/trading/Markets.vue?vue&type=template&id=d965ba1a&":
/*!*************************************************************************************!*\
  !*** ./resources/src/components/trading/Markets.vue?vue&type=template&id=d965ba1a& ***!
  \*************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "render": () => (/* reexport safe */ _node_modules_vue_loader_lib_loaders_templateLoader_js_vue_loader_options_node_modules_vue_loader_lib_index_js_vue_loader_options_Markets_vue_vue_type_template_id_d965ba1a___WEBPACK_IMPORTED_MODULE_0__.render),
/* harmony export */   "staticRenderFns": () => (/* reexport safe */ _node_modules_vue_loader_lib_loaders_templateLoader_js_vue_loader_options_node_modules_vue_loader_lib_index_js_vue_loader_options_Markets_vue_vue_type_template_id_d965ba1a___WEBPACK_IMPORTED_MODULE_0__.staticRenderFns)
/* harmony export */ });
/* harmony import */ var _node_modules_vue_loader_lib_loaders_templateLoader_js_vue_loader_options_node_modules_vue_loader_lib_index_js_vue_loader_options_Markets_vue_vue_type_template_id_d965ba1a___WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! -!../../../../node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!../../../../node_modules/vue-loader/lib/index.js??vue-loader-options!./Markets.vue?vue&type=template&id=d965ba1a& */ "./node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!./node_modules/vue-loader/lib/index.js??vue-loader-options!./resources/src/components/trading/Markets.vue?vue&type=template&id=d965ba1a&");


/***/ }),

/***/ "./resources/src/components/trading/Orderbook.vue?vue&type=template&id=4a636173&":
/*!***************************************************************************************!*\
  !*** ./resources/src/components/trading/Orderbook.vue?vue&type=template&id=4a636173& ***!
  \***************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "render": () => (/* reexport safe */ _node_modules_vue_loader_lib_loaders_templateLoader_js_vue_loader_options_node_modules_vue_loader_lib_index_js_vue_loader_options_Orderbook_vue_vue_type_template_id_4a636173___WEBPACK_IMPORTED_MODULE_0__.render),
/* harmony export */   "staticRenderFns": () => (/* reexport safe */ _node_modules_vue_loader_lib_loaders_templateLoader_js_vue_loader_options_node_modules_vue_loader_lib_index_js_vue_loader_options_Orderbook_vue_vue_type_template_id_4a636173___WEBPACK_IMPORTED_MODULE_0__.staticRenderFns)
/* harmony export */ });
/* harmony import */ var _node_modules_vue_loader_lib_loaders_templateLoader_js_vue_loader_options_node_modules_vue_loader_lib_index_js_vue_loader_options_Orderbook_vue_vue_type_template_id_4a636173___WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! -!../../../../node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!../../../../node_modules/vue-loader/lib/index.js??vue-loader-options!./Orderbook.vue?vue&type=template&id=4a636173& */ "./node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!./node_modules/vue-loader/lib/index.js??vue-loader-options!./resources/src/components/trading/Orderbook.vue?vue&type=template&id=4a636173&");


/***/ }),

/***/ "./resources/src/components/trading/Tradingview.vue?vue&type=template&id=e4f1b5fc&":
/*!*****************************************************************************************!*\
  !*** ./resources/src/components/trading/Tradingview.vue?vue&type=template&id=e4f1b5fc& ***!
  \*****************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "render": () => (/* reexport safe */ _node_modules_vue_loader_lib_loaders_templateLoader_js_vue_loader_options_node_modules_vue_loader_lib_index_js_vue_loader_options_Tradingview_vue_vue_type_template_id_e4f1b5fc___WEBPACK_IMPORTED_MODULE_0__.render),
/* harmony export */   "staticRenderFns": () => (/* reexport safe */ _node_modules_vue_loader_lib_loaders_templateLoader_js_vue_loader_options_node_modules_vue_loader_lib_index_js_vue_loader_options_Tradingview_vue_vue_type_template_id_e4f1b5fc___WEBPACK_IMPORTED_MODULE_0__.staticRenderFns)
/* harmony export */ });
/* harmony import */ var _node_modules_vue_loader_lib_loaders_templateLoader_js_vue_loader_options_node_modules_vue_loader_lib_index_js_vue_loader_options_Tradingview_vue_vue_type_template_id_e4f1b5fc___WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! -!../../../../node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!../../../../node_modules/vue-loader/lib/index.js??vue-loader-options!./Tradingview.vue?vue&type=template&id=e4f1b5fc& */ "./node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!./node_modules/vue-loader/lib/index.js??vue-loader-options!./resources/src/components/trading/Tradingview.vue?vue&type=template&id=e4f1b5fc&");


/***/ }),

/***/ "./node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!./node_modules/vue-loader/lib/index.js??vue-loader-options!./resources/src/Pages/bot/BotTradePage.vue?vue&type=template&id=22f98bc2&":
/*!************************************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!./node_modules/vue-loader/lib/index.js??vue-loader-options!./resources/src/Pages/bot/BotTradePage.vue?vue&type=template&id=22f98bc2& ***!
  \************************************************************************************************************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "render": () => (/* binding */ render),
/* harmony export */   "staticRenderFns": () => (/* binding */ staticRenderFns)
/* harmony export */ });
var render = function () {
  var _vm = this
  var _h = _vm.$createElement
  var _c = _vm._self._c || _h
  return _c(
    "div",
    { staticStyle: { margin: "-27px -27px 0 -27px" } },
    [
      _c(
        "grid-layout",
        {
          attrs: {
            layout: _vm.layout,
            "responsive-layouts": _vm.layouts,
            "col-num": 12,
            "row-height": 50,
            "is-draggable": _vm.draggable,
            "is-resizable": _vm.resizable,
            "vertical-compact": true,
            "use-css-transforms": true,
            responsive: _vm.responsive,
          },
          on: {
            "update:layout": function ($event) {
              _vm.layout = $event
            },
          },
        },
        [
          _c(
            "grid-item",
            {
              staticClass: "darked tabbable rounded shadow",
              staticStyle: { "overflow-y": "auto", "overflow-x": "hidden" },
              attrs: {
                x: _vm.layout[0].x,
                y: _vm.layout[0].y,
                w: _vm.layout[0].w,
                h: _vm.layout[0].h,
                i: _vm.layout[0].i,
                "drag-allow-from": ".vue-draggable-handle",
                "drag-ignore-from": ".no-drag",
              },
            },
            [
              _vm.pairs != null ? _vm._m(0) : _vm._e(),
              _vm._v(" "),
              _c("span", { staticClass: "vue-draggable-handle" }),
            ],
            1
          ),
          _vm._v(" "),
          _c(
            "grid-item",
            {
              staticClass: "darked tabbable rounded shadow",
              staticStyle: { "overflow-y": "auto", "overflow-x": "hidden" },
              attrs: {
                x: _vm.layout[1].x,
                y: _vm.layout[1].y,
                w: _vm.layout[1].w,
                h: _vm.layout[1].h,
                i: _vm.layout[1].i,
                "drag-allow-from": ".vue-draggable-handle",
                "drag-ignore-from": ".no-drag",
              },
            },
            [
              _vm.symbol != null
                ? _c("Trades", {
                    key: _vm.runningBot,
                    attrs: {
                      symbol: _vm.symbol,
                      currency: _vm.currency,
                      runningBot: _vm.runningBot,
                    },
                  })
                : _vm._e(),
              _vm._v(" "),
              _c("span", { staticClass: "vue-draggable-handle" }),
            ],
            1
          ),
          _vm._v(" "),
          _c(
            "grid-item",
            {
              staticClass: "darked rounded shadow",
              attrs: {
                x: _vm.layout[2].x,
                y: _vm.layout[2].y,
                w: _vm.layout[2].w,
                h: _vm.layout[2].h,
                i: _vm.layout[2].i,
                "drag-allow-from": ".vue-draggable-handle",
                "drag-ignore-from": ".no-drag",
              },
            },
            [
              _vm.provider != null
                ? _c("Marketinfo", {
                    attrs: {
                      symbol: _vm.symbol,
                      currency: _vm.currency,
                      provider: _vm.provider,
                    },
                  })
                : _vm._e(),
              _vm._v(" "),
              _c("span", { staticClass: "vue-draggable-handle" }),
            ],
            1
          ),
          _vm._v(" "),
          _c(
            "grid-item",
            {
              staticClass: "darked rounded shadow",
              attrs: {
                x: _vm.layout[3].x,
                y: _vm.layout[3].y,
                w: _vm.layout[3].w,
                h: _vm.layout[3].h,
                i: _vm.layout[3].i,
                "drag-allow-from": ".vue-draggable-handle",
                "drag-ignore-from": ".no-drag",
              },
            },
            [
              _vm.provide != null
                ? _c("Tradingview", {
                    key: _vm.symbol + _vm.currency,
                    attrs: {
                      symbol: _vm.symbol,
                      currency: _vm.currency,
                      provide: _vm.provide,
                    },
                  })
                : _vm._e(),
              _vm._v(" "),
              _c("span", { staticClass: "vue-draggable-handle" }),
            ],
            1
          ),
          _vm._v(" "),
          _c(
            "grid-item",
            {
              staticClass: "darked rounded shadow",
              attrs: {
                x: _vm.layout[4].x,
                y: _vm.layout[4].y,
                w: _vm.layout[4].w,
                h: _vm.layout[4].h,
                i: _vm.layout[4].i,
                "drag-allow-from": ".vue-draggable-handle",
                "drag-ignore-from": ".no-drag",
              },
            },
            [
              _c("div", { staticClass: "px-0" }, [
                _c(
                  "ul",
                  {
                    staticClass: "nav nav-tabs",
                    attrs: { id: "pills-tab", role: "tablist" },
                  },
                  [
                    _c("li", { staticClass: "nav-item" }, [
                      _c(
                        "button",
                        {
                          staticClass: "nav-link",
                          class: { active: _vm.isActive("pills-market") },
                          attrs: { href: "#pills-market" },
                          on: {
                            click: function ($event) {
                              $event.preventDefault()
                              return _vm.setActive("pills-market")
                            },
                          },
                        },
                        [
                          _vm._v(
                            "\n                            Rise/Fall\n                        "
                          ),
                        ]
                      ),
                    ]),
                  ]
                ),
                _vm._v(" "),
                _c(
                  "div",
                  {
                    staticClass: "tab-content",
                    attrs: { id: "pills-tabContent" },
                  },
                  [
                    _c(
                      "div",
                      {
                        staticClass: "tab-pane fade",
                        class: { "active show": _vm.isActive("pills-market") },
                        attrs: {
                          id: "pills-market",
                          role: "tabpanel",
                          "aria-labelledby": "pills-market-tab",
                        },
                      },
                      [
                        _c(
                          "form",
                          {
                            attrs: { id: "Order" },
                            on: {
                              submit: function ($event) {
                                $event.preventDefault()
                                return _vm.Order()
                              },
                            },
                          },
                          [
                            _c("div", { staticClass: "row pb-1 px-1" }, [
                              _c("div", { staticClass: "col-6" }, [
                                _c(
                                  "label",
                                  {
                                    staticClass:
                                      "form-label d-flex justify-content-between text-1 text-dark",
                                    attrs: { for: "selectBot" },
                                  },
                                  [_c("span", [_vm._v("Bots")])]
                                ),
                                _vm._v(" "),
                                _c("div", { key: _vm.balance }, [
                                  _vm.balance == null
                                    ? _c(
                                        "form",
                                        {
                                          on: {
                                            submit: function ($event) {
                                              $event.preventDefault()
                                              return _vm.createWallet()
                                            },
                                          },
                                        },
                                        [
                                          _c(
                                            "button",
                                            {
                                              staticClass:
                                                "btn btn-success w-100",
                                              attrs: { type: "submit" },
                                            },
                                            [
                                              _vm._v(
                                                "\n                                                Create Wallet\n                                            "
                                              ),
                                            ]
                                          ),
                                        ]
                                      )
                                    : _c(
                                        "button",
                                        {
                                          ref: "selectBot",
                                          staticClass: "w-100 btn btn-primary",
                                          attrs: {
                                            type: "button",
                                            "data-bs-toggle": "modal",
                                            "data-bs-target": "#botTypeModal",
                                          },
                                        },
                                        [
                                          _vm._v(
                                            "\n                                            Select Bot\n                                        "
                                          ),
                                        ]
                                      ),
                                ]),
                                _vm._v(" "),
                                _c(
                                  "label",
                                  {
                                    staticClass:
                                      "form-label mt-1 d-flex justify-content-between text-1 text-dark",
                                    attrs: { for: "botTimed" },
                                  },
                                  [_c("span", [_vm._v("Duration")])]
                                ),
                                _vm._v(" "),
                                _vm.bot_times != null
                                  ? _c(
                                      "div",
                                      {
                                        key: _vm.bot_times,
                                        staticClass: "dropdown",
                                      },
                                      [
                                        _c(
                                          "button",
                                          {
                                            ref: "botTimed",
                                            staticClass:
                                              "w-100 btn btn-outline-warning dropdown-toggle",
                                            attrs: {
                                              type: "button",
                                              "data-bs-toggle": "dropdown",
                                              "aria-expanded": "false",
                                              name: "botTimed",
                                            },
                                          },
                                          [
                                            _vm._v(
                                              "\n                                            Duration\n                                        "
                                            ),
                                          ]
                                        ),
                                        _vm._v(" "),
                                        _c(
                                          "ul",
                                          {
                                            staticClass:
                                              "dropdown-menu dropdown-menu-end",
                                          },
                                          _vm._l(
                                            _vm.bot_times,
                                            function (timing, index) {
                                              return _c("li", { key: index }, [
                                                _c(
                                                  "a",
                                                  {
                                                    staticClass:
                                                      "dropdown-item",
                                                    on: {
                                                      click: function ($event) {
                                                        return _vm.setTiming(
                                                          timing.duration,
                                                          timing.type
                                                        )
                                                      },
                                                    },
                                                  },
                                                  [
                                                    _vm._v(
                                                      _vm._s(timing.duration) +
                                                        "\n                                                    " +
                                                        _vm._s(timing.type) +
                                                        "s"
                                                    ),
                                                  ]
                                                ),
                                              ])
                                            }
                                          ),
                                          0
                                        ),
                                      ]
                                    )
                                  : _vm._e(),
                                _vm._v(" "),
                                _c(
                                  "button",
                                  {
                                    staticClass:
                                      "w-100 mt-1 btn btn-success mt-1 d-flex align-items-center justify-content-between",
                                    attrs: {
                                      type: "submit",
                                      disabled: _vm.loading,
                                    },
                                  },
                                  [
                                    _c("i", {
                                      staticClass:
                                        "bi bi-battery-charging fs-3",
                                    }),
                                    _c("span", [_vm._v(" Start Bot")]),
                                  ]
                                ),
                              ]),
                              _vm._v(" "),
                              _c("div", { staticClass: "col-6" }, [
                                _c(
                                  "label",
                                  {
                                    staticClass:
                                      "form-label d-flex justify-content-between text-1 text-dark",
                                    attrs: { for: "Amount" },
                                  },
                                  [_c("span", [_vm._v("Amount")])]
                                ),
                                _vm._v(" "),
                                _c("div", { staticClass: "input-group mb-1" }, [
                                  _c("input", {
                                    directives: [
                                      {
                                        name: "model",
                                        rawName: "v-model",
                                        value: _vm.amount,
                                        expression: "amount",
                                      },
                                    ],
                                    staticClass:
                                      "form-control text-dark border-0",
                                    attrs: {
                                      type: "number",
                                      min: _vm.min_amount,
                                      max: _vm.max_amount,
                                      step: _vm.min_amount,
                                      required: "",
                                      placeholder: "Amount",
                                      "aria-label":
                                        "Amount (to the nearest dollar)",
                                    },
                                    domProps: { value: _vm.amount },
                                    on: {
                                      input: function ($event) {
                                        if ($event.target.composing) {
                                          return
                                        }
                                        _vm.amount = $event.target.value
                                      },
                                    },
                                  }),
                                  _vm._v(" "),
                                  _c(
                                    "span",
                                    {
                                      staticClass:
                                        "input-group-text text-dark border-0",
                                    },
                                    [_vm._v(_vm._s(_vm.currency))]
                                  ),
                                ]),
                              ]),
                            ]),
                          ]
                        ),
                      ]
                    ),
                  ]
                ),
              ]),
              _vm._v(" "),
              _c("span", { staticClass: "vue-draggable-handle" }),
            ]
          ),
          _vm._v(" "),
          _c(
            "grid-item",
            {
              staticClass: "darked rounded shadow",
              attrs: {
                x: _vm.layout[5].x,
                y: _vm.layout[5].y,
                w: _vm.layout[5].w,
                h: _vm.layout[5].h,
                i: _vm.layout[5].i,
                "drag-allow-from": ".vue-draggable-handle",
                "drag-ignore-from": ".no-drag",
              },
            },
            [
              _vm.symbol != null
                ? _c("Orderbook", {
                    attrs: { symbol: _vm.symbol, currency: _vm.currency },
                  })
                : _vm._e(),
              _vm._v(" "),
              _c("span", { staticClass: "vue-draggable-handle" }),
            ],
            1
          ),
        ],
        1
      ),
      _vm._v(" "),
      _c(
        "div",
        {
          staticClass: "modal fade",
          attrs: {
            id: "botTypeModal",
            tabindex: "-1",
            "aria-labelledby": "botType",
            "aria-hidden": "true",
          },
        },
        [
          _c(
            "div",
            { staticClass: "modal-dialog modal-dialog-centered modal-lg" },
            [
              _c("div", { staticClass: "modal-content" }, [
                _vm._m(1),
                _vm._v(" "),
                _c(
                  "div",
                  { staticClass: "modal-body pb-3 px-sm-3" },
                  _vm._l(_vm.bot_type, function (bot, index) {
                    return _c(
                      "div",
                      {
                        key: index,
                        staticStyle: {},
                        on: {
                          click: function ($event) {
                            return _vm.setBot(bot)
                          },
                        },
                      },
                      [
                        _c(
                          "div",
                          {
                            staticClass: "row bg-wallet p-1 rounded mb-1",
                            class: bot.id == 1 ? "bg-wallet-active" : "",
                          },
                          [
                            _c("div", { staticClass: "col-3" }, [
                              _c("img", {
                                attrs: {
                                  src: "assets/images/bot/" + bot.image,
                                },
                              }),
                            ]),
                            _vm._v(" "),
                            _c("div", { staticClass: "col-9" }, [
                              _c(
                                "div",
                                {
                                  staticClass: "d-flex justify-content-between",
                                },
                                [
                                  _c(
                                    "div",
                                    { staticClass: "fw-bold fs-4 text-white" },
                                    [
                                      _vm._v(
                                        "\n                                        " +
                                          _vm._s(bot.title) +
                                          "\n                                        "
                                      ),
                                      bot.is_new == 1
                                        ? _c(
                                            "span",
                                            {
                                              staticClass:
                                                "fs-6 badge bg-success text-white",
                                            },
                                            [_vm._v("New")]
                                          )
                                        : _vm._e(),
                                    ]
                                  ),
                                  _vm._v(" "),
                                  _c(
                                    "div",
                                    {
                                      staticClass:
                                        "fs-6 text-white d-none d-md-block",
                                    },
                                    [
                                      _c("i", {
                                        staticClass: "bi bi-app-indicator",
                                      }),
                                      _vm._v(
                                        "\n                                        " +
                                          _vm._s(bot.fake) +
                                          "\n                                    "
                                      ),
                                    ]
                                  ),
                                ]
                              ),
                              _vm._v(" "),
                              _c("div", { staticClass: "row" }, [
                                _c(
                                  "small",
                                  { staticClass: "fs-6 text-warning" },
                                  [_vm._v(_vm._s(bot.desc))]
                                ),
                                _vm._v(" "),
                                _c("div", [
                                  _vm._v(
                                    "\n                                        Highest APR Today:\n                                        "
                                  ),
                                  _c("span", { staticClass: "text-success" }, [
                                    _vm._v(_vm._s(bot.perc) + "%"),
                                  ]),
                                ]),
                              ]),
                            ]),
                          ]
                        ),
                      ]
                    )
                  }),
                  0
                ),
              ]),
            ]
          ),
        ]
      ),
    ],
    1
  )
}
var staticRenderFns = [
  function () {
    var _vm = this
    var _h = _vm.$createElement
    var _c = _vm._self._c || _h
    return _c("Markets", {
      attrs: { pairs: _vm.pairs, type: _vm.type, provider: _vm.provider },
    })
  },
  function () {
    var _vm = this
    var _h = _vm.$createElement
    var _c = _vm._self._c || _h
    return _c("div", { staticClass: "modal-header bg-transparent" }, [
      _c("button", {
        staticClass: "btn-close",
        attrs: {
          type: "button",
          "data-bs-dismiss": "modal",
          "aria-label": "Close",
        },
      }),
    ])
  },
]
render._withStripped = true



/***/ }),

/***/ "./node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!./node_modules/vue-loader/lib/index.js??vue-loader-options!./resources/src/components/bot/Trades.vue?vue&type=template&id=0c77c49d&":
/*!***********************************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!./node_modules/vue-loader/lib/index.js??vue-loader-options!./resources/src/components/bot/Trades.vue?vue&type=template&id=0c77c49d& ***!
  \***********************************************************************************************************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "render": () => (/* binding */ render),
/* harmony export */   "staticRenderFns": () => (/* binding */ staticRenderFns)
/* harmony export */ });
var render = function () {
  var _vm = this
  var _h = _vm.$createElement
  var _c = _vm._self._c || _h
  return _c(
    "div",
    [
      _vm.runningBot != null
        ? _c(
            "router-link",
            {
              attrs: {
                to: "/bot",
                "data-bs-toggle": "tooltip",
                "data-bs-placement": "top",
                title: "View Contract",
              },
            },
            [
              _c(
                "div",
                {
                  staticClass: "p-1",
                  staticStyle: { "max-width": "280px", margin: "auto" },
                  attrs: { id: "speedtest" },
                },
                [
                  _c(
                    "svg",
                    {
                      staticStyle: { "enable-background": "new 0 0 100 100" },
                      attrs: {
                        id: "gauge",
                        version: "1.1",
                        xmlns: "http://www.w3.org/2000/svg",
                        "xmlns:xlink": "http://www.w3.org/1999/xlink",
                        x: "0px",
                        y: "0px",
                        viewBox: "0 0 100 100",
                        "xml:space": "preserve",
                      },
                    },
                    [
                      _c("path", {
                        staticStyle: { fill: "#e31212" },
                        attrs: {
                          d: "M12.9,75.5c0.3,0.5,0.7,0.9,1,1.4l7.6-5.7c-0.3-0.4-0.5-0.7-0.8-1.1L12.9,75.5z",
                        },
                      }),
                      _vm._v(" "),
                      _c("path", {
                        staticStyle: { fill: "#ea1f39", display: "none" },
                        attrs: {
                          d: "M9.3,69.3c0.3,0.5,0.5,1,0.8,1.5l8.4-4.4c-0.2-0.4-0.4-0.8-0.6-1.2L9.3,69.3z",
                        },
                      }),
                      _vm._v(" "),
                      _c("path", {
                        staticStyle: { fill: "#f12d60", display: "none" },
                        attrs: {
                          d: "M6.7,62.4C6.9,62.9,7,63.5,7.2,64l9.1-3c-0.1-0.4-0.3-0.8-0.4-1.2L6.7,62.4z",
                        },
                      }),
                      _vm._v(" "),
                      _c("path", {
                        staticStyle: { fill: "#f83c85", display: "none" },
                        attrs: {
                          d: "M5.3,55.2c0,0.6,0.1,1.1,0.2,1.7l9.4-1.5c-0.1-0.4-0.1-0.9-0.2-1.3L5.3,55.2z",
                        },
                      }),
                      _vm._v(" "),
                      _c("path", {
                        staticStyle: { fill: "#ff4ba8", display: "none" },
                        attrs: {
                          d: "M5,47.9c0,0.6,0,1.1,0,1.7l9.5,0.1c0-0.5,0-0.9,0-1.4L5,47.9z",
                        },
                      }),
                      _vm._v(" "),
                      _c("path", {
                        staticStyle: { fill: "#fb3eb2", display: "none" },
                        attrs: {
                          d: "M5.9,40.7c-0.1,0.6-0.2,1.1-0.3,1.7L15,44c0.1-0.4,0.2-0.9,0.2-1.3L5.9,40.7z",
                        },
                      }),
                      _vm._v(" "),
                      _c("path", {
                        staticStyle: { fill: "#f732bf", display: "none" },
                        attrs: {
                          d: "M8,33.7c-0.2,0.5-0.4,1.1-0.6,1.6l9,3.1c0.1-0.4,0.3-0.9,0.5-1.3L8,33.7z",
                        },
                      }),
                      _vm._v(" "),
                      _c("path", {
                        staticStyle: { fill: "#f226cd", display: "none" },
                        attrs: {
                          d: "M11.2,27.1c-0.3,0.5-0.5,1-0.8,1.5l8.3,4.6c0.2-0.4,0.4-0.8,0.7-1.2L11.2,27.1z",
                        },
                      }),
                      _vm._v(" "),
                      _c("path", {
                        staticStyle: { fill: "#ee1adc", display: "none" },
                        attrs: {
                          d: "M15.5,21.2c-0.4,0.4-0.8,0.9-1.1,1.3l7.5,5.8c0.3-0.4,0.6-0.7,0.9-1.1L15.5,21.2z",
                        },
                      }),
                      _vm._v(" "),
                      _c("path", {
                        staticStyle: { fill: "#ae19de", display: "none" },
                        attrs: {
                          d: "M20.6,16c-0.5,0.3-0.9,0.7-1.3,1.1l6.5,7c0.3-0.3,0.6-0.6,1-0.9L20.6,16z",
                        },
                      }),
                      _vm._v(" "),
                      _c("path", {
                        staticStyle: { fill: "#6618cd", display: "none" },
                        attrs: {
                          d: "M26.4,11.7c-0.5,0.3-0.9,0.6-1.4,0.9l5.3,7.9c0.3-0.2,0.7-0.5,1-0.7L26.4,11.7z",
                        },
                      }),
                      _vm._v(" "),
                      _c("path", {
                        staticStyle: { fill: "#2716bd", display: "none" },
                        attrs: {
                          d: "M33,8.3c-0.6,0.2-1.1,0.5-1.6,0.7l3.9,8.7c0.4-0.2,0.9-0.4,1.3-0.6L33,8.3z",
                        },
                      }),
                      _vm._v(" "),
                      _c("path", {
                        staticStyle: { fill: "#1537ac", display: "none" },
                        attrs: {
                          d: "M39.9,6.1c-0.5,0.1-1.1,0.3-1.6,0.4l2.5,9.2c0.4-0.1,0.8-0.2,1.2-0.3L39.9,6.1z",
                        },
                      }),
                      _vm._v(" "),
                      _c("path", {
                        staticStyle: { fill: "#2061c1", display: "none" },
                        attrs: {
                          d: "M47.2,5.2c-0.6,0-1.1,0-1.7,0.1l0.9,9.4c0.4,0,0.9-0.1,1.3-0.1L47.2,5.2z",
                        },
                      }),
                      _vm._v(" "),
                      _c("path", {
                        staticStyle: { fill: "#2c90d5", display: "none" },
                        attrs: {
                          d: "M54.5,5.2c-0.6,0-1.1-0.1-1.7-0.1l-0.6,9.5c0.4,0,0.9,0.1,1.3,0.1L54.5,5.2z",
                        },
                      }),
                      _vm._v(" "),
                      _c("path", {
                        staticStyle: { fill: "#3bc2ea", display: "none" },
                        attrs: {
                          d: "M61.6,6.5c-0.5-0.1-1.1-0.3-1.6-0.4l-2.2,9.3c0.4,0.1,0.9,0.2,1.3,0.3L61.6,6.5z",
                        },
                      }),
                      _vm._v(" "),
                      _c("path", {
                        staticStyle: { fill: "#4bf7ff", display: "none" },
                        attrs: {
                          d: "M68.6,9C68,8.7,67.5,8.5,67,8.3l-3.6,8.8c0.4,0.2,0.8,0.3,1.2,0.5L68.6,9z",
                        },
                      }),
                      _vm._v(" "),
                      _c("path", {
                        staticStyle: { fill: "#39f6d2", display: "none" },
                        attrs: {
                          d: "M74.9,12.5c-0.4-0.3-0.9-0.6-1.4-0.9l-5,8.1c0.4,0.2,0.7,0.5,1.1,0.7L74.9,12.5z",
                        },
                      }),
                      _vm._v(" "),
                      _c("path", {
                        staticStyle: { fill: "#28ed99", display: "none" },
                        attrs: {
                          d: "M80.6,17c-0.5-0.4-0.9-0.7-1.3-1.1l-6.2,7.2c0.3,0.3,0.7,0.6,1,0.9L80.6,17z",
                        },
                      }),
                      _vm._v(" "),
                      _c("path", {
                        staticStyle: { fill: "#19e55d", display: "none" },
                        attrs: {
                          d: "M85.7,22.4c-0.4-0.4-0.7-0.9-1.1-1.3l-7.4,6.1c0.3,0.3,0.5,0.7,0.8,1L85.7,22.4z",
                        },
                      }),
                      _vm._v(" "),
                      _c("path", {
                        staticStyle: { fill: "#0adc1e", display: "none" },
                        attrs: {
                          d: "M89.6,28.6c-0.2-0.5-0.5-1-0.8-1.5L80.6,32c0.2,0.4,0.4,0.7,0.6,1.1L89.6,28.6z",
                        },
                      }),
                      _vm._v(" "),
                      _c("path", {
                        staticStyle: { fill: "#0adc1e", display: "none" },
                        attrs: {
                          d: "M92.5,35.3c-0.2-0.5-0.4-1.1-0.6-1.6l-8.8,3.4c0.2,0.4,0.3,0.8,0.5,1.2L92.5,35.3z",
                        },
                      }),
                      _vm._v(" "),
                      _c("path", {
                        staticStyle: { fill: "#0adc1e", display: "none" },
                        attrs: {
                          d: "M94.4,42.2c-0.1-0.5-0.2-1.1-0.3-1.6l-9.4,2c0.1,0.4,0.2,0.9,0.2,1.3L94.4,42.2z",
                        },
                      }),
                      _vm._v(" "),
                      _c("path", {
                        staticStyle: { fill: "#0adc1e", display: "none" },
                        attrs: {
                          d: "M95,47.8l-9.5,0.5c0,0.4,0,0.9,0,1.3l9.5-0.1C95,48.9,95,48.4,95,47.8z",
                        },
                      }),
                      _vm._v(" "),
                      _c("path", {
                        staticStyle: { fill: "#0adc1e", display: "none" },
                        attrs: {
                          d: "M94.5,56.8c0.1-0.5,0.1-1.1,0.2-1.7l-9.4-1c-0.1,0.4-0.1,0.9-0.2,1.3L94.5,56.8z",
                        },
                      }),
                      _vm._v(" "),
                      _c("path", {
                        staticStyle: { fill: "#0adc1e", display: "none" },
                        attrs: {
                          d: "M92.8,63.9c0.2-0.5,0.3-1,0.5-1.7l-9.1-2.6c-0.1,0.4-0.3,0.9-0.4,1.3L92.8,63.9z",
                        },
                      }),
                      _vm._v(" "),
                      _c("path", {
                        staticStyle: { fill: "#0adc1e", display: "none" },
                        attrs: {
                          d: "M90,70.7c0.2-0.5,0.5-1,0.8-1.5l-8.7-4.1c-0.2,0.4-0.4,0.8-0.6,1.2L90,70.7z",
                        },
                      }),
                      _vm._v(" "),
                      _c("path", {
                        staticStyle: { fill: "#0adc1e", display: "none" },
                        attrs: {
                          d: "M89.9,80.1c0.5-0.7,1-1.3,1.4-1.9l-12-8.2c-0.3,0.4-0.6,0.9-0.9,1.3L89.9,80.1z",
                        },
                      }),
                    ]
                  ),
                  _vm._v(" "),
                  _c("div", { attrs: { id: "gauge-label" } }, [_vm._v("0")]),
                ]
              ),
            ]
          )
        : _vm._e(),
      _vm._v(" "),
      _vm._m(0),
    ],
    1
  )
}
var staticRenderFns = [
  function () {
    var _vm = this
    var _h = _vm.$createElement
    var _c = _vm._self._c || _h
    return _c("div", { staticClass: "table-responsive" }, [
      _c(
        "table",
        { staticClass: "table text-dark table-sm table-borderless" },
        [
          _c("thead", { staticClass: "text-muted" }, [
            _c("tr", [
              _c("th", { staticClass: "text-start", attrs: { scope: "col" } }, [
                _vm._v("Price"),
              ]),
              _vm._v(" "),
              _c("th", { staticClass: "text-start", attrs: { scope: "col" } }, [
                _vm._v("Amount"),
              ]),
              _vm._v(" "),
              _c("th", { staticClass: "text-end", attrs: { scope: "col" } }, [
                _vm._v("Time"),
              ]),
            ]),
          ]),
          _vm._v(" "),
          _c("tbody", { staticClass: "trade", attrs: { id: "tradeTable" } }),
        ]
      ),
    ])
  },
]
render._withStripped = true



/***/ }),

/***/ "./node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!./node_modules/vue-loader/lib/index.js??vue-loader-options!./resources/src/components/trading/Marketinfo.vue?vue&type=template&id=a7005444&":
/*!*******************************************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!./node_modules/vue-loader/lib/index.js??vue-loader-options!./resources/src/components/trading/Marketinfo.vue?vue&type=template&id=a7005444& ***!
  \*******************************************************************************************************************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "render": () => (/* binding */ render),
/* harmony export */   "staticRenderFns": () => (/* binding */ staticRenderFns)
/* harmony export */ });
var render = function () {
  var _vm = this
  var _h = _vm.$createElement
  var _c = _vm._self._c || _h
  return _c("div", {}, [
    _c(
      "div",
      {
        staticClass:
          "d-flex d-sm-none justify-content-between align-items-center text-2",
      },
      [
        _vm._m(0),
        _vm._v(" "),
        _vm.provider != "coinbasepro"
          ? _c("div", { staticClass: "d-flex flex-column" }, [
              _c("div", { staticClass: "text-muted d-none d-md-block" }, [
                _vm._v(_vm._s(_vm.symbol) + " Volume: "),
                _c("span", { staticClass: "text-dark day_volume_pair" }, [
                  _vm._v("------"),
                ]),
              ]),
              _vm._v(" "),
              _c("div", { staticClass: "text-muted d-none d-md-block" }, [
                _vm._v(_vm._s(_vm.currency) + " Volume: "),
                _c("span", { staticClass: "text-dark day_volume_currency" }, [
                  _vm._v("------"),
                ]),
              ]),
            ])
          : _vm._e(),
        _vm._v(" "),
        _vm.provider != "coinbasepro"
          ? _c("div", { staticClass: "d-flex flex-column" }, [
              _vm._m(1),
              _vm._v(" "),
              _vm._m(2),
            ])
          : _vm._e(),
      ]
    ),
    _vm._v(" "),
    _c(
      "div",
      {
        staticClass:
          "d-none d-sm-flex justify-content-between align-items-center mx-1 text-2 mt-1",
      },
      [
        _c("div", { staticClass: "d-flex align-items-center" }, [
          _c("img", {
            staticClass: "avatar-content",
            attrs: {
              width: "36px",
              src:
                "../../../../../assets/images/cryptoCurrency/" +
                _vm.symbol.toLowerCase() +
                ".png",
              alt: _vm.symbol,
            },
          }),
          _vm._v(" "),
          _c("i", { staticClass: "bi bi-chevron-right" }),
          _vm._v(" "),
          _c("img", {
            staticClass: "avatar-content",
            attrs: {
              width: "36px",
              src:
                "../../../../../assets/images/cryptoCurrency/" +
                _vm.currency.toLowerCase() +
                ".png",
              alt: _vm.currency,
            },
          }),
        ]),
        _vm._v(" "),
        _vm.provider != "coinbasepro"
          ? _c("div", { staticClass: "d-flex flex-column" }, [
              _c("span", { staticClass: "text-muted" }, [_vm._v("24h change")]),
              _vm._v(" "),
              _c("span", { staticClass: "day_change fs-6" }, [
                _vm._v("-------"),
              ]),
            ])
          : _vm._e(),
        _vm._v(" "),
        _vm._m(3),
        _vm._v(" "),
        _c("div", { staticClass: "d-flex flex-column" }, [
          _c("span", { staticClass: "text-muted" }, [_vm._v("24h Volume")]),
          _vm._v(" "),
          _c("span", { staticClass: "text-muted" }, [
            _vm._v(_vm._s(_vm.symbol) + ": "),
            _c("span", { staticClass: "text-dark day_volume_pair" }, [
              _vm._v("-------"),
            ]),
          ]),
          _vm._v(" "),
          _vm.provider != "coinbasepro"
            ? _c("span", { staticClass: "text-muted" }, [
                _vm._v(_vm._s(_vm.currency) + ": "),
                _c("span", { staticClass: "text-dark day_volume_currency" }, [
                  _vm._v("-------"),
                ]),
              ])
            : _vm._e(),
        ]),
      ]
    ),
  ])
}
var staticRenderFns = [
  function () {
    var _vm = this
    var _h = _vm.$createElement
    var _c = _vm._self._c || _h
    return _c("div", { staticClass: "d-flex flex-column" }, [
      _c("div", { staticClass: "text-muted" }, [
        _vm._v("Last Price: "),
        _c("span", { staticClass: "last_price" }, [_vm._v("------")]),
        _c("i", { staticClass: "last_price_icon bi" }),
      ]),
      _vm._v(" "),
      _c("div", { staticClass: "text-muted" }, [
        _vm._v("24h Change: "),
        _c("span", { staticClass: "day_change" }, [_vm._v("------")]),
        _c("i", { staticClass: "day_change_icon bi" }),
      ]),
    ])
  },
  function () {
    var _vm = this
    var _h = _vm.$createElement
    var _c = _vm._self._c || _h
    return _c("div", { staticClass: "text-muted" }, [
      _vm._v("24h High: "),
      _c("span", { staticClass: "text-dark day_high" }, [_vm._v("------")]),
    ])
  },
  function () {
    var _vm = this
    var _h = _vm.$createElement
    var _c = _vm._self._c || _h
    return _c("div", { staticClass: "text-muted" }, [
      _vm._v("24h Low: "),
      _c("span", { staticClass: "text-dark day_low" }, [_vm._v("------")]),
    ])
  },
  function () {
    var _vm = this
    var _h = _vm.$createElement
    var _c = _vm._self._c || _h
    return _c("div", { staticClass: "d-flex flex-column" }, [
      _c("span", { staticClass: "text-muted" }, [_vm._v("24h Price Range")]),
      _vm._v(" "),
      _c("div", { staticClass: "text-muted" }, [
        _vm._v("High: "),
        _c("span", { staticClass: "text-dark day_high" }, [_vm._v("-------")]),
      ]),
      _vm._v(" "),
      _c("div", { staticClass: "text-muted" }, [
        _vm._v("Low: "),
        _c("span", { staticClass: "text-dark day_low" }, [_vm._v("-------")]),
      ]),
    ])
  },
]
render._withStripped = true



/***/ }),

/***/ "./node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!./node_modules/vue-loader/lib/index.js??vue-loader-options!./resources/src/components/trading/Markets.vue?vue&type=template&id=d965ba1a&":
/*!****************************************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!./node_modules/vue-loader/lib/index.js??vue-loader-options!./resources/src/components/trading/Markets.vue?vue&type=template&id=d965ba1a& ***!
  \****************************************************************************************************************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "render": () => (/* binding */ render),
/* harmony export */   "staticRenderFns": () => (/* binding */ staticRenderFns)
/* harmony export */ });
var render = function () {
  var _vm = this
  var _h = _vm.$createElement
  var _c = _vm._self._c || _h
  return _c("div", [
    _c(
      "div",
      { staticClass: "d-flex justify-content-between align-items-center" },
      [
        _c(
          "button",
          {
            staticClass: "btn btn-icon",
            staticStyle: { position: "relative", top: "-5px" },
          },
          [
            _c("i", {
              staticClass: "bi bi-chevron-left text-warning fs-4",
              on: {
                click: function ($event) {
                  $event.preventDefault()
                  return _vm.scrollLeft()
                },
              },
            }),
          ]
        ),
        _vm._v(" "),
        _c(
          "ul",
          {
            staticClass: "nav nav-tabs nf",
            staticStyle: { "overflow-x": "hidden" },
            attrs: { role: "tablist" },
          },
          [
            _c("li", { staticClass: "nav-item" }, [
              _c(
                "a",
                {
                  staticClass: "nav-link",
                  class: { active: _vm.isActive("fav") },
                  attrs: { href: "#fav" },
                  on: {
                    click: function ($event) {
                      $event.preventDefault()
                      return _vm.setActive("fav")
                    },
                  },
                },
                [_c("i", { staticClass: "bi bi-star" })]
              ),
            ]),
            _vm._v(" "),
            _vm._l(_vm.pairs, function (pair, index) {
              return _c("li", { key: index, staticClass: "nav-item" }, [
                _c(
                  "a",
                  {
                    staticClass: "nav-link",
                    class: { active: _vm.isActive(pair) },
                    attrs: { href: "#profile" },
                    on: {
                      click: function ($event) {
                        $event.preventDefault()
                        return _vm.setActive(pair)
                      },
                    },
                  },
                  [_vm._v(_vm._s(pair))]
                ),
              ])
            }),
          ],
          2
        ),
        _vm._v(" "),
        _c(
          "button",
          {
            staticClass: "btn btn-icon",
            staticStyle: { position: "relative", top: "-5px" },
          },
          [
            _c("i", {
              staticClass: "bi bi-chevron-right text-warning fs-4",
              on: {
                click: function ($event) {
                  $event.preventDefault()
                  return _vm.scrollRight()
                },
              },
            }),
          ]
        ),
      ]
    ),
    _vm._v(" "),
    _c(
      "div",
      { staticClass: "tab-content", attrs: { id: "myTabContent" } },
      [
        _c(
          "div",
          {
            staticClass: "tab-pane fade",
            class: { "active show": _vm.isActive("fav") },
            attrs: { id: "fav" },
          },
          [
            _vm._m(0),
            _vm._v(" "),
            _c(
              "table",
              {
                staticClass:
                  "table text-dark table-sm table-borderless tableFixHead custom-data-table-fav",
              },
              [
                _vm._m(1),
                _vm._v(" "),
                _c(
                  "tbody",
                  _vm._l(_vm.favs, function (fav, index) {
                    return _c("tr", { key: index }, [
                      _c("td", [
                        _c(
                          "div",
                          { staticClass: "d-flex justify-content-start" },
                          [
                            _c(
                              "form",
                              {
                                on: {
                                  submit: function ($event) {
                                    $event.preventDefault()
                                    return _vm.removeFromWatchlist(fav.id)
                                  },
                                },
                              },
                              [_vm._m(2, true)]
                            ),
                            _vm._v(" "),
                            _c(
                              "router-link",
                              {
                                attrs: {
                                  to: "../" + fav.currency + "/" + fav.pair,
                                },
                              },
                              [
                                _c(
                                  "span",
                                  { staticClass: "text-dark fw-bold" },
                                  [_vm._v(_vm._s(fav.currency))]
                                ),
                                _vm._v("/"),
                                _c(
                                  "span",
                                  { staticClass: "text-secondary fw-bold" },
                                  [_vm._v(_vm._s(fav.pair))]
                                ),
                              ]
                            ),
                          ],
                          1
                        ),
                      ]),
                      _vm._v(" "),
                      _c("td", { staticClass: "d-lg-none d-xl-block" }, [
                        _c("span", {
                          class: "change-" + fav.currency + fav.pair,
                        }),
                      ]),
                      _vm._v(" "),
                      _c("td", [
                        _c("span", { class: "tic-" + fav.currency + fav.pair }),
                        _c("i", {
                          class: "tic-" + fav.currency + fav.pair + "-icon bi",
                        }),
                      ]),
                    ])
                  }),
                  0
                ),
              ]
            ),
          ]
        ),
        _vm._v(" "),
        _vm._l(_vm.markets, function (mark, index) {
          return _c(
            "div",
            {
              key: index,
              staticClass: "tab-pane fade",
              class: { "active show": _vm.isActive(index) },
              attrs: { id: { index: index } },
            },
            [
              _vm._m(3, true),
              _vm._v(" "),
              _c(
                "table",
                {
                  staticClass:
                    "table text-dark table-sm table-borderless tableFixHead",
                  class: "custom-data-table-" + index,
                },
                [
                  _vm._m(4, true),
                  _vm._v(" "),
                  _c(
                    "tbody",
                    _vm._l(mark, function (market, index) {
                      return _c("tr", { key: index }, [
                        _c("td", [
                          _c(
                            "div",
                            { staticClass: "d-flex justify-content-start" },
                            [
                              _c(
                                "form",
                                {
                                  on: {
                                    submit: function ($event) {
                                      $event.preventDefault()
                                      return _vm.addToWatchlist(
                                        market.currency,
                                        market.pair
                                      )
                                    },
                                  },
                                },
                                [_vm._m(5, true)]
                              ),
                              _vm._v(" "),
                              _c(
                                "router-link",
                                {
                                  attrs: {
                                    to:
                                      "../" +
                                      market.currency +
                                      "/" +
                                      market.pair,
                                  },
                                },
                                [
                                  _c(
                                    "span",
                                    { staticClass: "text-dark fw-bold" },
                                    [_vm._v(_vm._s(market.currency))]
                                  ),
                                  _vm._v("/"),
                                  _c(
                                    "span",
                                    { staticClass: "text-secondary fw-bold" },
                                    [_vm._v(_vm._s(market.pair))]
                                  ),
                                ]
                              ),
                            ],
                            1
                          ),
                        ]),
                      ])
                    }),
                    0
                  ),
                ]
              ),
            ]
          )
        }),
      ],
      2
    ),
  ])
}
var staticRenderFns = [
  function () {
    var _vm = this
    var _h = _vm.$createElement
    var _c = _vm._self._c || _h
    return _c("div", { staticClass: "row" }, [
      _c("div", { staticClass: "col-12 card-search custom-data-search" }, [
        _c("div", { staticClass: "input-group input-group-sm px-1 mb-1" }, [
          _c(
            "span",
            {
              staticClass: "input-group-text text-dark border-0",
              attrs: { id: "basic-addon1" },
            },
            [_c("i", { staticClass: "bi bi-search" })]
          ),
          _vm._v(" "),
          _c("input", {
            staticClass: "form-control form-control-sm text-dark border-0",
            attrs: {
              type: "text",
              name: "search_table_fav",
              placeholder: "Search...",
            },
          }),
        ]),
      ]),
    ])
  },
  function () {
    var _vm = this
    var _h = _vm.$createElement
    var _c = _vm._self._c || _h
    return _c("thead", { staticClass: "text-muted" }, [
      _c("th", { attrs: { scope: "col" } }, [_vm._v("Pair")]),
      _vm._v(" "),
      _c(
        "th",
        { staticClass: "d-lg-none d-xl-block", attrs: { scope: "col" } },
        [_vm._v("Change")]
      ),
      _vm._v(" "),
      _c("th", { attrs: { scope: "col" } }, [_vm._v("Price")]),
    ])
  },
  function () {
    var _vm = this
    var _h = _vm.$createElement
    var _c = _vm._self._c || _h
    return _c(
      "button",
      {
        staticClass: "watchlisted",
        staticStyle: { background: "transparent", border: "transparent" },
        attrs: { type: "submit" },
      },
      [_c("i", { staticClass: "me-1 text-warning bi bi-star-fill" })]
    )
  },
  function () {
    var _vm = this
    var _h = _vm.$createElement
    var _c = _vm._self._c || _h
    return _c("div", { staticClass: "row" }, [
      _c("div", { staticClass: "col-12 card-search custom-data-search" }, [
        _c("div", { staticClass: "input-group input-group-sm px-1 mb-1" }, [
          _c(
            "span",
            {
              staticClass: "input-group-text text-dark border-0",
              attrs: { id: "basic-addon1" },
            },
            [_c("i", { staticClass: "bi bi-search" })]
          ),
          _vm._v(" "),
          _c("input", {
            staticClass: "form-control form-control-sm text-dark border-0",
            attrs: {
              type: "text",
              name: "search_table",
              placeholder: "Search...",
            },
          }),
        ]),
      ]),
    ])
  },
  function () {
    var _vm = this
    var _h = _vm.$createElement
    var _c = _vm._self._c || _h
    return _c("thead", { staticClass: "text-muted" }, [
      _c("th", { attrs: { scope: "col" } }, [_vm._v("Pair")]),
    ])
  },
  function () {
    var _vm = this
    var _h = _vm.$createElement
    var _c = _vm._self._c || _h
    return _c(
      "button",
      {
        staticClass: "not-watchlisted",
        staticStyle: { background: "transparent", border: "transparent" },
        attrs: { type: "submit" },
      },
      [_c("i", { staticClass: "me-1 text-secondary bi bi-star" })]
    )
  },
]
render._withStripped = true



/***/ }),

/***/ "./node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!./node_modules/vue-loader/lib/index.js??vue-loader-options!./resources/src/components/trading/Orderbook.vue?vue&type=template&id=4a636173&":
/*!******************************************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!./node_modules/vue-loader/lib/index.js??vue-loader-options!./resources/src/components/trading/Orderbook.vue?vue&type=template&id=4a636173& ***!
  \******************************************************************************************************************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "render": () => (/* binding */ render),
/* harmony export */   "staticRenderFns": () => (/* binding */ staticRenderFns)
/* harmony export */ });
var render = function () {
  var _vm = this
  var _h = _vm.$createElement
  var _c = _vm._self._c || _h
  return _c("div", { staticClass: " " }, [
    _c("input", { attrs: { type: "hidden", id: "bestAsk" } }),
    _vm._v(" "),
    _c("input", { attrs: { type: "hidden", id: "bestBid" } }),
    _vm._v(" "),
    _c(
      "ul",
      {
        staticClass: "nav nav-tabs",
        attrs: { id: "pills-tab", role: "tablist" },
      },
      [
        _c("li", { staticClass: "nav-item" }, [
          _c(
            "button",
            {
              staticClass: "nav-link",
              class: { active: _vm.isActive("pills-graph") },
              attrs: { href: "#pills-graph" },
              on: {
                click: function ($event) {
                  $event.preventDefault()
                  return _vm.setActive("pills-graph")
                },
              },
            },
            [_c("i", { staticClass: "bi bi-graph-up text-dark" })]
          ),
        ]),
        _vm._v(" "),
        _c("li", { staticClass: "nav-item" }, [
          _c(
            "button",
            {
              staticClass: "nav-link",
              class: { active: _vm.isActive("pills-graph-up") },
              attrs: { href: "#pills-graph-up" },
              on: {
                click: function ($event) {
                  $event.preventDefault()
                  return _vm.setActive("pills-graph-up")
                },
              },
            },
            [_c("i", { staticClass: "bi bi-graph-up-arrow text-success" })]
          ),
        ]),
        _vm._v(" "),
        _c("li", { staticClass: "nav-item" }, [
          _c(
            "button",
            {
              staticClass: "nav-link",
              class: { active: _vm.isActive("pills-graph-down") },
              attrs: { href: "#pills-graph-down" },
              on: {
                click: function ($event) {
                  $event.preventDefault()
                  return _vm.setActive("pills-graph-down")
                },
              },
            },
            [_c("i", { staticClass: "bi bi-graph-down-arrow text-danger" })]
          ),
        ]),
      ]
    ),
    _vm._v(" "),
    _c(
      "div",
      { staticClass: "tab-content", attrs: { id: "pills-graph-tabContent" } },
      [
        _c(
          "div",
          {
            staticClass: "tab-pane fade",
            class: { "active show": _vm.isActive("pills-graph") },
            attrs: {
              id: "pills-graph",
              role: "tabpanel",
              "aria-labelledby": "pills-graph-tab",
            },
          },
          [
            _vm._m(0),
            _vm._v(" "),
            _vm._m(1),
            _vm._v(" "),
            _c("div", { staticClass: "table-responsive" }, [
              _c(
                "table",
                { staticClass: "bids", staticStyle: { "min-height": "280px" } },
                [
                  _c(
                    "div",
                    {
                      key: _vm.symbol + _vm.currency,
                      staticClass: "order-loader",
                    },
                    [_vm._m(2)]
                  ),
                ]
              ),
            ]),
          ]
        ),
        _vm._v(" "),
        _c(
          "div",
          {
            staticClass: "tab-pane fade",
            class: { "active show": _vm.isActive("pills-graph-down") },
            attrs: {
              id: "pills-graph-down",
              role: "tabpanel",
              "aria-labelledby": "pills-graph-down-tab",
            },
          },
          [_vm._m(3)]
        ),
        _vm._v(" "),
        _c(
          "div",
          {
            staticClass: "tab-pane fade",
            class: { "active show": _vm.isActive("pills-graph-up") },
            attrs: {
              id: "pills-graph-up",
              role: "tabpanel",
              "aria-labelledby": "pills-graph-up-tab",
            },
          },
          [_vm._m(4)]
        ),
      ]
    ),
  ])
}
var staticRenderFns = [
  function () {
    var _vm = this
    var _h = _vm.$createElement
    var _c = _vm._self._c || _h
    return _c("div", { staticClass: "table-responsive" }, [
      _c(
        "table",
        {
          staticClass: "table text-dark table-sm table-borderless",
          staticStyle: { "overflow-x": "hidden" },
        },
        [
          _c("thead", { staticClass: "text-muted" }, [
            _c("th", { staticClass: "text-start", attrs: { scope: "col" } }, [
              _vm._v("Price"),
            ]),
            _vm._v(" "),
            _c("th", { staticClass: "text-start", attrs: { scope: "col" } }, [
              _vm._v("Amount"),
            ]),
            _vm._v(" "),
            _c("th", { staticClass: "text-end", attrs: { scope: "col" } }, [
              _vm._v("Total"),
            ]),
          ]),
        ]
      ),
      _vm._v(" "),
      _c(
        "table",
        { staticClass: "asks", staticStyle: { "min-height": "280px" } },
        [
          _c("div", { staticClass: "order-loader" }, [
            _c(
              "div",
              {
                staticClass: "se-pre-con2 spinner-border text-primary",
                attrs: { role: "status" },
              },
              [_c("span", { staticClass: "sr-only" })]
            ),
          ]),
        ]
      ),
    ])
  },
  function () {
    var _vm = this
    var _h = _vm.$createElement
    var _c = _vm._self._c || _h
    return _c("div", { staticClass: "table-responsive bordered-y" }, [
      _c(
        "table",
        { staticClass: "table text-dark table-sm table-borderless my-auto" },
        [
          _c("tbody", [
            _c("tr", [
              _c("td", { staticClass: "text-mute" }, [
                _c("span", { staticClass: "fs-6" }, [_vm._v("Last Price: ")]),
                _vm._v(" "),
                _c("span", { staticClass: "fs-6 best_ask" }),
                _c("i", { staticClass: "fs-5 best_ask_icon bi" }),
              ]),
            ]),
          ]),
        ]
      ),
    ])
  },
  function () {
    var _vm = this
    var _h = _vm.$createElement
    var _c = _vm._self._c || _h
    return _c(
      "div",
      {
        staticClass: "se-pre-con2 spinner-border text-primary",
        attrs: { role: "status" },
      },
      [_c("span", { staticClass: "sr-only" })]
    )
  },
  function () {
    var _vm = this
    var _h = _vm.$createElement
    var _c = _vm._self._c || _h
    return _c("div", { staticClass: "table-responsive" }, [
      _c(
        "table",
        { staticClass: "table text-dark table-sm table-borderless" },
        [
          _c("thead", { staticClass: "text-muted" }, [
            _c("th", { attrs: { scope: "col" } }, [_vm._v("Price")]),
            _vm._v(" "),
            _c("th", { attrs: { scope: "col" } }, [_vm._v("Amount")]),
            _vm._v(" "),
            _c("th", { attrs: { scope: "col" } }, [_vm._v("Total")]),
          ]),
        ]
      ),
      _vm._v(" "),
      _c("table", { staticClass: "asks_only" }),
    ])
  },
  function () {
    var _vm = this
    var _h = _vm.$createElement
    var _c = _vm._self._c || _h
    return _c("div", { staticClass: "table-responsive" }, [
      _c(
        "table",
        { staticClass: "table text-dark table-sm table-borderless" },
        [
          _c("thead", { staticClass: "text-muted" }, [
            _c("th", { attrs: { scope: "col" } }, [_vm._v("Price")]),
            _vm._v(" "),
            _c("th", { attrs: { scope: "col" } }, [_vm._v("Amount")]),
            _vm._v(" "),
            _c("th", { attrs: { scope: "col" } }, [_vm._v("Total")]),
          ]),
        ]
      ),
      _vm._v(" "),
      _c("table", { staticClass: "bids_only" }),
    ])
  },
]
render._withStripped = true



/***/ }),

/***/ "./node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!./node_modules/vue-loader/lib/index.js??vue-loader-options!./resources/src/components/trading/Tradingview.vue?vue&type=template&id=e4f1b5fc&":
/*!********************************************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!./node_modules/vue-loader/lib/index.js??vue-loader-options!./resources/src/components/trading/Tradingview.vue?vue&type=template&id=e4f1b5fc& ***!
  \********************************************************************************************************************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "render": () => (/* binding */ render),
/* harmony export */   "staticRenderFns": () => (/* binding */ staticRenderFns)
/* harmony export */ });
var render = function () {
  var _vm = this
  var _h = _vm.$createElement
  var _c = _vm._self._c || _h
  return _vm._m(0)
}
var staticRenderFns = [
  function () {
    var _vm = this
    var _h = _vm.$createElement
    var _c = _vm._self._c || _h
    return _c("div", { staticClass: " " }, [
      _c("div", { attrs: { id: "tradingview" } }),
    ])
  },
]
render._withStripped = true



/***/ })

}]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoianMvY2h1bmtzL3Jlc291cmNlc19zcmNfUGFnZXNfYm90X0JvdFRyYWRlUGFnZV92dWUuNmJlM2VmMjc4MTUwZWIyYy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQTJVdUQ7QUFDVTtBQUNFO0FBQ0o7QUFDSjtBQUNOO0FBRXJEO0VBQ0FBLEtBQ0E7SUFBQUM7SUFBQUM7SUFBQUM7SUFBQUM7SUFBQUM7RUFBQSxDQURBLEVBQ0E7RUFDQTtJQUFBSjtJQUFBQztJQUFBQztJQUFBQztJQUFBQztFQUFBLENBRkEsRUFFQTtFQUNBO0lBQUFKO0lBQUFDO0lBQUFDO0lBQUFDO0lBQUFDO0VBQUEsQ0FIQSxFQUdBO0VBQ0E7SUFBQUo7SUFBQUM7SUFBQUM7SUFBQUM7SUFBQUM7RUFBQSxDQUpBLEVBSUE7RUFDQTtJQUFBSjtJQUFBQztJQUFBQztJQUFBQztJQUFBQztFQUFBLENBTEEsRUFLQTtFQUNBO0lBQUFKO0lBQUFDO0lBQUFDO0lBQUFDO0lBQUFDO0VBQUEsQ0FOQSxDQU1BO0VBTkEsQ0FEQTtFQVNBQyxLQUNBO0lBQUFMO0lBQUFDO0lBQUFDO0lBQUFDO0lBQUFDO0VBQUEsQ0FEQSxFQUNBO0VBQ0E7SUFBQUo7SUFBQUM7SUFBQUM7SUFB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TDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHO0FBQ0g7QUFDQSxxQkFBcUI7O0FBRXJCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1Qzs7QUFFdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBLFdBQVc7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QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBLHlCQUF5Qjs7QUFFekI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOzs7QUFHSjtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FBSUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7QUFFQSxFQUFFO0FBQ0Y7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7O0FBRUEsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7QUFNQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTix5QkFBeUI7QUFDekIsMkJBQTJCO0FBQzNCLHlCQUF5QjtBQUN6Qjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsOENBQThDOztBQUU5Qyw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOztBQUVBLEVBQUU7QUFDRjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBOztBQUVBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTs7QUFFQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7O0FBRUEsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBOztBQUVBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTs7QUFFQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7O0FBRUEsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBOztBQUVBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7QUFZQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCOztBQUV0QjtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQSxLQUFLOztBQUVMOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOzs7Ozs7Ozs7QUFTQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7O0FBRUEsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsK0NBQStDLFFBQVE7QUFDdkQ7QUFDQTs7QUFFQTtBQUNBLFFBQVE7QUFDUix3QkFBd0IsMEJBQTBCO0FBQ2xEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxrQ0FBa0M7O0FBRWxDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTs7O0FBR04sdUNBQXVDLFlBQVk7QUFDbkQsb0NBQW9DOztBQUVwQztBQUNBO0FBQ0E7QUFDQSxVQUFVLE9BQU87O0FBRWpCLDJDQUEyQyxRQUFRO0FBQ25EO0FBQ0E7QUFDQTtBQUNBLFdBQVcsa0JBQWtCOztBQUU3QjtBQUNBO0FBQ0Esb0NBQW9DO0FBQ3BDOztBQUVBO0FBQ0EsMENBQTBDOztBQUUxQztBQUNBO0FBQ0EsY0FBYzs7O0FBR2Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQjs7QUFFL0I7QUFDQSxzQkFBc0Isc0JBQXNCO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTs7QUFFVjtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUk7OztBQUdKO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3Qzs7QUFFeEM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7O0FBT0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsa0JBQWtCO0FBQy9CO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7OztBQUdMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEI7O0FBRTlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDREQUE0RDtBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQixhQUFhLFFBQVE7QUFDckIsY0FBYyxTQUFTO0FBQ3ZCO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEseUJBQXlCO0FBQ3RDLGFBQWEsVUFBVTtBQUN2QixhQUFhLGtCQUFrQjtBQUMvQjtBQUNBLGNBQWMsUUFBUTtBQUN0Qjs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLE1BQU07OztBQUdOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEseUJBQXlCO0FBQ3RDO0FBQ0EsYUFBYSxVQUFVO0FBQ3ZCLGFBQWEsa0JBQWtCO0FBQy9CO0FBQ0EsY0FBYyxRQUFRO0FBQ3RCOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLFNBQVM7QUFDdkI7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsU0FBUztBQUN2Qjs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsUUFBUTtBQUN0Qjs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQixjQUFjO0FBQ2Q7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOzs7Ozs7Ozs7QUFTQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsb0NBQW9DOztBQUVyQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLHNDQUFzQzs7QUFFdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixjQUFjO0FBQzdDO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsb0JBQW9CO0FBQ2xFO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckIsYUFBYSxjQUFjO0FBQzNCLGFBQWEsU0FBUztBQUN0QixjQUFjLFNBQVM7QUFDdkI7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdEO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFlBQVk7O0FBRVo7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDLFFBQVEsY0FBYztBQUNoRTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSyxpQkFBaUI7QUFDdEI7O0FBRUE7QUFDQSxJQUFJOzs7QUFHSjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxvQ0FBb0MsS0FBSztBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsYUFBYSxjQUFjO0FBQzNCOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsNkNBQTZDOztBQUU3QztBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxNQUFNOztBQUVOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSx1RUFBdUUsTUFBTTs7QUFFN0U7QUFDQTtBQUNBOztBQUVBOztBQUVBLDJDQUEyQyxNQUFNOztBQUVqRDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsaURBQWlELE1BQU07O0FBRXZEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7Ozs7O0FBTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLG1DQUFtQyxZQUFZO0FBQy9DOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7O0FBR0o7QUFDQTtBQUNBLElBQUk7OztBQUdKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQixjQUFjLHVCQUF1QjtBQUNyQzs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSzs7O0FBR0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLFVBQVU7QUFDbEM7QUFDQSxHQUFHLElBQUk7QUFDUCxDQUFDO0FBQ0Q7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTs7O0FBR1Y7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjs7O0FBR0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxpREFBaUQ7QUFDakQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7Ozs7Ozs7OztBQVNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTCxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEdBQUcsR0FBRzs7QUFFTjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFROzs7QUFHUjtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3Qjs7QUFFeEI7QUFDQSx5Q0FBeUM7O0FBRXpDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjs7QUFFQTtBQUNBO0FBQ0Esd0JBQXdCLDRDQUE0QztBQUNwRTtBQUNBLFVBQVU7QUFDVjs7O0FBR0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTs7O0FBR047QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLElBQUk7QUFDSjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7OztBQUdKO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLHVEQUF1RCxRQUFRO0FBQy9EOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7O0FBZUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLGdDQUFnQztBQUNsRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1Asb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTyxJQUFJOztBQUVYLGFBQWEsYUFBYTtBQUMxQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxpQ0FBaUM7QUFDakM7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLHFDQUFxQztBQUNyQzs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQSxvQkFBb0IsMkJBQTJCO0FBQy9DO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUFLQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxJQUFJOztBQUVKO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxhQUFhLHlCQUF5QjtBQUN0QztBQUNBLGNBQWMsMkJBQTJCO0FBQ3pDO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQSxHQUFHLDZFQUE2RSxxQkFBcUI7QUFDckc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLGFBQWEseUJBQXlCO0FBQ3RDO0FBQ0EsY0FBYywyQkFBMkI7QUFDekM7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRyw0RUFBNEUsb0JBQW9CO0FBQ25HO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEI7QUFDNUI7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLGlCQUFpQjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMseUJBQXlCO0FBQ3ZDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFNBQVM7QUFDdEIsY0FBYyx3QkFBd0I7QUFDdEM7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7Ozs7Ozs7O0FBUUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQjs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0Esd0NBQXdDLFNBQVM7QUFDakQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3Qjs7QUFFeEI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxJQUFJOzs7QUFHSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEI7O0FBRTVCO0FBQ0E7QUFDQSxzQ0FBc0M7O0FBRXRDOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPOzs7QUFHUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBOzs7O0FBSUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxLQUFLO0FBQ0w7QUFDQTtB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QTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0EsSUFBSTtBQUNKOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQU07QUFDTjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQUlBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSx1REFBdUQ7QUFDdkQ7QUFDQTtBQUNBLDhEQUE4RDtBQUM5RDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTs7OztBQUlBO0FBQ0E7OztBQUdBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOLHNEQUFzRDtBQUN0RDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOzs7O0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ04sMEJBQTBCO0FBQzFCLHdCQUF3QjtBQUN4QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUiwwQ0FBMEM7QUFDMUM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLDBCQUEwQjtBQUMxQjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07O0FBRU47QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSx3QkFBd0IsNkJBQTZCO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDLGlDQUFpQztBQUN6RTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUFJQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxpREFBaUQ7O0FBRWpEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkMsY0FBYztBQUMzRCxRQUFRO0FBQ1IsOEJBQThCLG1CQUFtQjtBQUNqRDtBQUNBLElBQUk7QUFDSjtBQUNBOzs7OztBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsTUFBTTs7QUFFTjtBQUNBO0FBQ0E7O0FBRUEsaUNBQWlDO0FBQ2pDLCtCQUErQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCO0FBQy9CLEtBQUs7QUFDTCxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ04sbUNBQW1DO0FBQ25DO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLG1DQUFtQztBQUNuQztBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsa0RBQWtEO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLE1BQU07O0FBRU47QUFDQSxxRUFBcUU7O0FBRXJFO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7O0FBTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRyxzQkFBc0I7O0FBRXpCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsdUJBQXVCO0FBQ3JDO0FBQ0EsZ0JBQWdCLDhDQUE4QztBQUM5RCxnQkFBZ0IsOENBQThDO0FBQzlELE1BQU07QUFDTixJQUFJOzs7OztBQUtKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsSUFBSTtBQUNKOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTs7QUFFQSx3QkFBd0I7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOzs7O0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7O0FBRUEsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOzs7Ozs7QUFNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCLG9CQUFvQjtBQUNwQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOzs7Ozs7OztBQVFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLHdCQUF3QjtBQUN4Qjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsc0RBQXNELGFBQWE7QUFDbkU7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQztBQUNyQzs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7QUFNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkI7QUFDM0I7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDLGVBQWU7QUFDekQsTUFBTTtBQUNOLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQSxNQUFNO0FBQ04sSUFBSTtBQUNKO0FBQ0E7Ozs7OztBQU1BO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQWFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7Ozs7QUFJQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0Esd0NBQXdDOztBQUV4QztBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FBSUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7O0FBT0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLDhCQUE4Qjs7QUFFL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVILHFEQUFxRDs7QUFFckQ7QUFDQTtBQUNBLEVBQUUsSUFBSTtBQUNOO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHOztBQUVIO0FBQ0EsQ0FBQztBQUNEOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLEdBQUc7O0FBRUg7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBLENBQUM7QUFDRDs7QUFFQTtBQUNBO0FBQ0EsbUVBQW1FLFdBQVc7QUFDOUU7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUFJQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOzs7O0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FBSUE7Ozs7Ozs7O0FBUUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTs7QUFFTjtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQSxxQkFBcUI7O0FBRXJCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxxQkFBcUI7O0FBRXJCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxnQ0FBZ0M7QUFDaEM7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCLEtBQUs7QUFDTDtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7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O0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGlCQUFpQjs7QUFFakI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsaUJBQWlCOztBQUVqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxx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QjtBQUNyQjtBQUNBO0FBQ0EsdUNBQXVDLGlCQUFpQjtBQUN4RDtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0EsdUNBQXVDLGtDQUFrQztBQUN6RTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0EsdUNBQXVDLGtDQUFrQztBQUN6RTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0EsdUNBQXVDLGtDQUFrQztBQUN6RTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0EsdUNBQXVDLGtDQUFrQztBQUN6RTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0EsdUNBQXVDLGtDQUFrQztBQUN6RTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0EsdUNBQXVDLGtDQUFrQztBQUN6RTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0EsdUNBQXVDLGtDQUFrQztBQUN6RTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0EsdUNBQXVDLGtDQUFrQztBQUN6RTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0EsdUNBQXVDLGtDQUFrQztBQUN6RTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0EsdUNBQXVDLGtDQUFrQztBQUN6RTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0EsdUNBQXVDLGtDQUFrQztBQUN6RTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0EsdUNBQXVDLGtDQUFrQztBQUN6RTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0EsdUNBQXVDLGtDQUFrQztBQUN6RTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0EsdUNBQXVDLGtDQUFrQztBQUN6RTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0EsdUNBQXVDLGtDQUFrQztBQUN6RTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0EsdUNBQXVDLGtDQUFrQztBQUN6RTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0EsdUNBQXVDLGtDQUFrQztBQUN6RTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0EsdUNBQXVDLGtDQUFrQztBQUN6RTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0EsdUNBQXVDLGtDQUFrQztBQUN6RTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0EsdUNBQXVDLGtDQUFrQztBQUN6RTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0EsdUNBQXVDLGtDQUFrQztBQUN6RTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0EsdUNBQXVDLGtDQUFrQztBQUN6RTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0EsdUNBQXVDLGtDQUFrQztBQUN6RTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0EsdUNBQXVDLGtDQUFrQztBQUN6RTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0EsdUNBQXVDLGtDQUFrQztBQUN6RTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0EsdUNBQXVDLGtDQUFrQztBQUN6RTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0EsdUNBQXVDLGtDQUFrQztBQUN6RTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsU0FBUyxxQkFBcUI7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsaUNBQWlDO0FBQ3hEO0FBQ0E7QUFDQSxVQUFVLDBEQUEwRDtBQUNwRTtBQUNBLHdCQUF3QiwyQkFBMkI7QUFDbkQ7QUFDQSx5QkFBeUIsb0NBQW9DLGdCQUFnQjtBQUM3RTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsb0NBQW9DLGdCQUFnQjtBQUM3RTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsa0NBQWtDLGdCQUFnQjtBQUMzRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLCtCQUErQixvQkFBb0I7QUFDM0U7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQzdSQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLG1DQUFtQztBQUMzRCwwQkFBMEIsNkNBQTZDO0FBQ3ZFO0FBQ0EsNkJBQTZCLDBDQUEwQztBQUN2RTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQiw2Q0FBNkM7QUFDdkU7QUFDQSw2QkFBNkIsOENBQThDO0FBQzNFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLG1DQUFtQztBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLG9CQUFvQiwwQ0FBMEM7QUFDOUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFdBQVc7QUFDWDtBQUNBLG9CQUFvQixvQ0FBb0M7QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixtQ0FBbUM7QUFDM0QsMkJBQTJCLDJCQUEyQjtBQUN0RDtBQUNBLDJCQUEyQixnQ0FBZ0M7QUFDM0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsbUNBQW1DO0FBQ3ZELHVCQUF1QiwyQkFBMkI7QUFDbEQ7QUFDQSx1QkFBdUIsMkJBQTJCO0FBQ2xEO0FBQ0EseUJBQXlCLDBDQUEwQztBQUNuRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLDJCQUEyQjtBQUN0RDtBQUNBLDZCQUE2Qiw4Q0FBOEM7QUFDM0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixtQ0FBbUM7QUFDMUQsa0JBQWtCLDJCQUEyQjtBQUM3QztBQUNBLHFCQUFxQiwyQkFBMkI7QUFDaEQsa0JBQWtCLG1DQUFtQztBQUNyRDtBQUNBO0FBQ0Esa0JBQWtCLDJCQUEyQjtBQUM3QztBQUNBLHFCQUFxQiwyQkFBMkI7QUFDaEQsa0JBQWtCLG1DQUFtQztBQUNyRDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLDJCQUEyQjtBQUNsRDtBQUNBLG1CQUFtQixtQ0FBbUM7QUFDdEQ7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsMkJBQTJCO0FBQ2xEO0FBQ0EsbUJBQW1CLGtDQUFrQztBQUNyRDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixtQ0FBbUM7QUFDMUQsbUJBQW1CLDJCQUEyQjtBQUM5QztBQUNBLGtCQUFrQiwyQkFBMkI7QUFDN0M7QUFDQSxxQkFBcUIsbUNBQW1DO0FBQ3hEO0FBQ0E7QUFDQSxrQkFBa0IsMkJBQTJCO0FBQzdDO0FBQ0EscUJBQXFCLGtDQUFrQztBQUN2RDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ3hLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsa0VBQWtFO0FBQzFFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsbUNBQW1DO0FBQzlELFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQixlQUFlO0FBQ2YsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLHdCQUF3QjtBQUNuRCxxQkFBcUIsaUJBQWlCO0FBQ3RDLFdBQVc7QUFDWDtBQUNBLHVCQUF1Qix5QkFBeUI7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsNkJBQTZCO0FBQ3hELDJCQUEyQixjQUFjO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCLG1CQUFtQjtBQUNuQixpQkFBaUI7QUFDakIsMkJBQTJCLDJCQUEyQjtBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyxxQ0FBcUM7QUFDckU7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsNEJBQTRCO0FBQ3pELDZCQUE2QixrQkFBa0I7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkIscUJBQXFCO0FBQ3JCLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixtQ0FBbUM7QUFDOUQsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCLGVBQWU7QUFDZixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLHFDQUFxQyxzQkFBc0I7QUFDbkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixvQ0FBb0M7QUFDekQscUJBQXFCLFdBQVc7QUFDaEMsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDLFlBQVk7QUFDbEQ7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLDZDQUE2QztBQUN6RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DO0FBQ25DLGlDQUFpQztBQUNqQywrQkFBK0I7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQztBQUNqQywrQkFBK0I7QUFDL0I7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLGtDQUFrQztBQUN0RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLHVDQUF1QztBQUMzRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMscUNBQXFDO0FBQ3RFO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0EscUNBQXFDLHlDQUF5QztBQUM5RTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsb0NBQW9DO0FBQzNELHVCQUF1QixNQUFNLGdCQUFnQjtBQUM3QyxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QyxZQUFZO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBLDhCQUE4Qiw2Q0FBNkM7QUFDM0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQztBQUNyQyxtQ0FBbUM7QUFDbkMsaUNBQWlDO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQztBQUNuQyxpQ0FBaUM7QUFDakM7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDLGtDQUFrQztBQUN4RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDLHVDQUF1QztBQUM3RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLG9CQUFvQjtBQUMzQyxrQkFBa0Isc0RBQXNEO0FBQ3hFLG9CQUFvQixxREFBcUQ7QUFDekU7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsb0JBQW9CO0FBQzNDLGFBQWE7QUFDYix1QkFBdUIsNkJBQTZCO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QiwyQkFBMkI7QUFDcEQsaUJBQWlCLFNBQVMsZ0JBQWdCO0FBQzFDO0FBQ0E7QUFDQTtBQUNBLFVBQVUsOENBQThDLGdCQUFnQjtBQUN4RTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsU0FBUyxnQkFBZ0I7QUFDMUM7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixrREFBa0Q7QUFDekUsaUJBQWlCLGdCQUFnQjtBQUNqQyxPQUFPO0FBQ1AsaUJBQWlCLGtEQUFrRDtBQUNuRTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixvQkFBb0I7QUFDM0Msa0JBQWtCLHNEQUFzRDtBQUN4RSxvQkFBb0IscURBQXFEO0FBQ3pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLG9CQUFvQjtBQUMzQyxhQUFhO0FBQ2IsdUJBQXVCLDZCQUE2QjtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsMkJBQTJCO0FBQ3BELGlCQUFpQixTQUFTLGdCQUFnQjtBQUMxQztBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLGtEQUFrRDtBQUN6RSxpQkFBaUIsZ0JBQWdCO0FBQ2pDLE9BQU87QUFDUCxpQkFBaUIsK0NBQStDO0FBQ2hFO0FBQ0EsR0FBRztBQUNIO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ3RZQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixrQkFBa0I7QUFDdkMsa0JBQWtCLFNBQVMsaUNBQWlDO0FBQzVEO0FBQ0Esa0JBQWtCLFNBQVMsaUNBQWlDO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsa0NBQWtDO0FBQ25ELE9BQU87QUFDUDtBQUNBLG1CQUFtQix5QkFBeUI7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIscUNBQXFDO0FBQzVELHVCQUF1QixzQkFBc0I7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIsZUFBZTtBQUNmLGFBQWE7QUFDYix1QkFBdUIseUNBQXlDO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQix5QkFBeUI7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsd0NBQXdDO0FBQy9ELHVCQUF1Qix5QkFBeUI7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIsZUFBZTtBQUNmLGFBQWE7QUFDYix1QkFBdUIsa0RBQWtEO0FBQ3pFO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQix5QkFBeUI7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsMENBQTBDO0FBQ2pFLHVCQUF1QiwyQkFBMkI7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIsZUFBZTtBQUNmLGFBQWE7QUFDYix1QkFBdUIsbURBQW1EO0FBQzFFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSxxQ0FBcUMsZ0NBQWdDO0FBQzdFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsNENBQTRDO0FBQ2pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLGlDQUFpQztBQUN6RDtBQUNBO0FBQ0Esa0JBQWtCLG9DQUFvQyx5QkFBeUI7QUFDL0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixpREFBaUQ7QUFDdEU7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLCtDQUErQztBQUNwRTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixpQ0FBaUM7QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsd0JBQXdCO0FBQ2pELFNBQVM7QUFDVDtBQUNBLHdCQUF3QiwyQkFBMkI7QUFDbkQsdUJBQXVCLG9DQUFvQyxnQkFBZ0I7QUFDM0U7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLG9DQUFvQyxnQkFBZ0I7QUFDM0U7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLGtDQUFrQyxnQkFBZ0I7QUFDekU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsb0NBQW9DLHlCQUF5QjtBQUN2RTtBQUNBLHNCQUFzQiw2QkFBNkI7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsZ0JBQWdCO0FBQ3pDLGVBQWU7QUFDZiw0QkFBNEIsd0JBQXdCO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsNENBQTRDO0FBQ25FO0FBQ0E7QUFDQSxVQUFVLGtFQUFrRTtBQUM1RTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsMEJBQTBCO0FBQ25ELDZCQUE2QixxQkFBcUI7QUFDbEQ7QUFDQSw2QkFBNkIsOEJBQThCO0FBQzNELDBCQUEwQixzQ0FBc0M7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsZ0JBQWdCO0FBQ2pDLE9BQU87QUFDUCxvQkFBb0Isd0JBQXdCO0FBQzVDO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLGlDQUFpQztBQUN4RDtBQUNBO0FBQ0EsVUFBVSwwREFBMEQ7QUFDcEU7QUFDQSx3QkFBd0IsMkJBQTJCO0FBQ25ELHVCQUF1QixTQUFTLGdCQUFnQjtBQUNoRDtBQUNBLHVCQUF1QixTQUFTLGdCQUFnQjtBQUNoRDtBQUNBLHVCQUF1QixTQUFTLGdCQUFnQjtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQiwwQkFBMEI7QUFDOUM7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsaUNBQWlDO0FBQ3hEO0FBQ0E7QUFDQSxVQUFVLDBEQUEwRDtBQUNwRTtBQUNBLHdCQUF3QiwyQkFBMkI7QUFDbkQsdUJBQXVCLFNBQVMsZ0JBQWdCO0FBQ2hEO0FBQ0EsdUJBQXVCLFNBQVMsZ0JBQWdCO0FBQ2hEO0FBQ0EsdUJBQXVCLFNBQVMsZ0JBQWdCO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLDBCQUEwQjtBQUM5QztBQUNBLEdBQUc7QUFDSDtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7QUM5UUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixrQkFBa0I7QUFDekMsa0JBQWtCLFNBQVMscUJBQXFCO0FBQ2hEO0FBQ0EsR0FBRztBQUNIO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vcmVzb3VyY2VzL3NyYy9QYWdlcy9ib3QvQm90VHJhZGVQYWdlLnZ1ZSIsIndlYnBhY2s6Ly8vcmVzb3VyY2VzL3NyYy9jb21wb25lbnRzL2JvdC9UcmFkZXMudnVlIiwid2VicGFjazovLy9yZXNvdXJjZXMvc3JjL2NvbXBvbmVudHMvdHJhZGluZy9NYXJrZXRpbmZvLnZ1ZSIsIndlYnBhY2s6Ly8vcmVzb3VyY2VzL3NyYy9jb21wb25lbnRzL3RyYWRpbmcvTWFya2V0cy52dWUiLCJ3ZWJwYWNrOi8vL3Jlc291cmNlcy9zcmMvY29tcG9uZW50cy90cmFkaW5nL09yZGVyYm9vay52dWUiLCJ3ZWJwYWNrOi8vL3Jlc291cmNlcy9zcmMvY29tcG9uZW50cy90cmFkaW5nL1RyYWRpbmd2aWV3LnZ1ZSIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvb2JqZWN0LXRvLWFycmF5LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXMub2JqZWN0LmVudHJpZXMuanMiLCJ3ZWJwYWNrOi8vLy4vcmVzb3VyY2VzL3NyYy9jb21wb25lbnRzL3RyYWRpbmcvTWFya2V0cy52dWU/OWM0ZCIsIndlYnBhY2s6Ly8vLi9yZXNvdXJjZXMvc3JjL1BhZ2VzL2JvdC9Cb3RUcmFkZVBhZ2UudnVlP2Y0NmUiLCJ3ZWJwYWNrOi8vLy4vcmVzb3VyY2VzL3NyYy9jb21wb25lbnRzL3RyYWRpbmcvTWFya2V0cy52dWU/MjcyOSIsIndlYnBhY2s6Ly8vLi9yZXNvdXJjZXMvc3JjL1BhZ2VzL2JvdC9Cb3RUcmFkZVBhZ2UudnVlPzBkMDMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3Z1ZS1ncmlkLWxheW91dC9kaXN0L3Z1ZS1ncmlkLWxheW91dC5jb21tb24uanMiLCJ3ZWJwYWNrOi8vLy4vcmVzb3VyY2VzL3NyYy9QYWdlcy9ib3QvQm90VHJhZGVQYWdlLnZ1ZSIsIndlYnBhY2s6Ly8vLi9yZXNvdXJjZXMvc3JjL2NvbXBvbmVudHMvYm90L1RyYWRlcy52dWUiLCJ3ZWJwYWNrOi8vLy4vcmVzb3VyY2VzL3NyYy9jb21wb25lbnRzL3RyYWRpbmcvTWFya2V0aW5mby52dWUiLCJ3ZWJwYWNrOi8vLy4vcmVzb3VyY2VzL3NyYy9jb21wb25lbnRzL3RyYWRpbmcvTWFya2V0cy52dWUiLCJ3ZWJwYWNrOi8vLy4vcmVzb3VyY2VzL3NyYy9jb21wb25lbnRzL3RyYWRpbmcvT3JkZXJib29rLnZ1ZSIsIndlYnBhY2s6Ly8vLi9yZXNvdXJjZXMvc3JjL2NvbXBvbmVudHMvdHJhZGluZy9UcmFkaW5ndmlldy52dWUiLCJ3ZWJwYWNrOi8vLy4vcmVzb3VyY2VzL3NyYy9QYWdlcy9ib3QvQm90VHJhZGVQYWdlLnZ1ZT9lNWY3Iiwid2VicGFjazovLy8uL3Jlc291cmNlcy9zcmMvY29tcG9uZW50cy9ib3QvVHJhZGVzLnZ1ZT8wZDVmIiwid2VicGFjazovLy8uL3Jlc291cmNlcy9zcmMvY29tcG9uZW50cy90cmFkaW5nL01hcmtldGluZm8udnVlPzUxZjgiLCJ3ZWJwYWNrOi8vLy4vcmVzb3VyY2VzL3NyYy9jb21wb25lbnRzL3RyYWRpbmcvTWFya2V0cy52dWU/MjcyZCIsIndlYnBhY2s6Ly8vLi9yZXNvdXJjZXMvc3JjL2NvbXBvbmVudHMvdHJhZGluZy9PcmRlcmJvb2sudnVlPzYyZDAiLCJ3ZWJwYWNrOi8vLy4vcmVzb3VyY2VzL3NyYy9jb21wb25lbnRzL3RyYWRpbmcvVHJhZGluZ3ZpZXcudnVlPzYyYjQiLCJ3ZWJwYWNrOi8vLy4vcmVzb3VyY2VzL3NyYy9QYWdlcy9ib3QvQm90VHJhZGVQYWdlLnZ1ZT8yYWM0Iiwid2VicGFjazovLy8uL3Jlc291cmNlcy9zcmMvUGFnZXMvYm90L0JvdFRyYWRlUGFnZS52dWU/NjRmOSIsIndlYnBhY2s6Ly8vLi9yZXNvdXJjZXMvc3JjL2NvbXBvbmVudHMvYm90L1RyYWRlcy52dWU/YTk5YyIsIndlYnBhY2s6Ly8vLi9yZXNvdXJjZXMvc3JjL1BhZ2VzL2JvdC9Cb3RUcmFkZVBhZ2UudnVlPzA3ZmEiLCJ3ZWJwYWNrOi8vLy4vcmVzb3VyY2VzL3NyYy9jb21wb25lbnRzL2JvdC9UcmFkZXMudnVlP2YxMzciLCJ3ZWJwYWNrOi8vLy4vcmVzb3VyY2VzL3NyYy9jb21wb25lbnRzL3RyYWRpbmcvTWFya2V0aW5mby52dWU/Y2I3OSIsIndlYnBhY2s6Ly8vLi9yZXNvdXJjZXMvc3JjL2NvbXBvbmVudHMvdHJhZGluZy9NYXJrZXRzLnZ1ZT9kZDk4Iiwid2VicGFjazovLy8uL3Jlc291cmNlcy9zcmMvY29tcG9uZW50cy90cmFkaW5nL09yZGVyYm9vay52dWU/NmI4NCIsIndlYnBhY2s6Ly8vLi9yZXNvdXJjZXMvc3JjL2NvbXBvbmVudHMvdHJhZGluZy9UcmFkaW5ndmlldy52dWU/M2YyZiJdLCJzb3VyY2VzQ29udGVudCI6WyI8dGVtcGxhdGU+XG4gICAgPGRpdiBzdHlsZT1cIm1hcmdpbjogLTI3cHggLTI3cHggMCAtMjdweFwiPlxuICAgICAgICA8Z3JpZC1sYXlvdXRcbiAgICAgICAgICAgIDpsYXlvdXQuc3luYz1cImxheW91dFwiXG4gICAgICAgICAgICA6cmVzcG9uc2l2ZS1sYXlvdXRzPVwibGF5b3V0c1wiXG4gICAgICAgICAgICA6Y29sLW51bT1cIjEyXCJcbiAgICAgICAgICAgIDpyb3ctaGVpZ2h0PVwiNTBcIlxuICAgICAgICAgICAgOmlzLWRyYWdnYWJsZT1cImRyYWdnYWJsZVwiXG4gICAgICAgICAgICA6aXMtcmVzaXphYmxlPVwicmVzaXphYmxlXCJcbiAgICAgICAgICAgIDp2ZXJ0aWNhbC1jb21wYWN0PVwidHJ1ZVwiXG4gICAgICAgICAgICA6dXNlLWNzcy10cmFuc2Zvcm1zPVwidHJ1ZVwiXG4gICAgICAgICAgICA6cmVzcG9uc2l2ZT1cInJlc3BvbnNpdmVcIlxuICAgICAgICA+XG4gICAgICAgICAgICA8Z3JpZC1pdGVtXG4gICAgICAgICAgICAgICAgOng9XCJsYXlvdXRbMF0ueFwiXG4gICAgICAgICAgICAgICAgOnk9XCJsYXlvdXRbMF0ueVwiXG4gICAgICAgICAgICAgICAgOnc9XCJsYXlvdXRbMF0ud1wiXG4gICAgICAgICAgICAgICAgOmg9XCJsYXlvdXRbMF0uaFwiXG4gICAgICAgICAgICAgICAgOmk9XCJsYXlvdXRbMF0uaVwiXG4gICAgICAgICAgICAgICAgZHJhZy1hbGxvdy1mcm9tPVwiLnZ1ZS1kcmFnZ2FibGUtaGFuZGxlXCJcbiAgICAgICAgICAgICAgICBkcmFnLWlnbm9yZS1mcm9tPVwiLm5vLWRyYWdcIlxuICAgICAgICAgICAgICAgIGNsYXNzPVwiZGFya2VkIHRhYmJhYmxlIHJvdW5kZWQgc2hhZG93XCJcbiAgICAgICAgICAgICAgICBzdHlsZT1cIm92ZXJmbG93LXk6IGF1dG87IG92ZXJmbG93LXg6IGhpZGRlblwiXG4gICAgICAgICAgICA+XG4gICAgICAgICAgICAgICAgPE1hcmtldHNcbiAgICAgICAgICAgICAgICAgICAgdi1vbmNlXG4gICAgICAgICAgICAgICAgICAgIHYtaWY9XCJwYWlycyAhPSBudWxsXCJcbiAgICAgICAgICAgICAgICAgICAgOnBhaXJzPVwicGFpcnNcIlxuICAgICAgICAgICAgICAgICAgICA6dHlwZT1cInR5cGVcIlxuICAgICAgICAgICAgICAgICAgICA6cHJvdmlkZXI9XCJwcm92aWRlclwiXG4gICAgICAgICAgICAgICAgLz5cbiAgICAgICAgICAgICAgICA8c3BhbiBjbGFzcz1cInZ1ZS1kcmFnZ2FibGUtaGFuZGxlXCI+PC9zcGFuPlxuICAgICAgICAgICAgPC9ncmlkLWl0ZW0+XG4gICAgICAgICAgICA8Z3JpZC1pdGVtXG4gICAgICAgICAgICAgICAgOng9XCJsYXlvdXRbMV0ueFwiXG4gICAgICAgICAgICAgICAgOnk9XCJsYXlvdXRbMV0ueVwiXG4gICAgICAgICAgICAgICAgOnc9XCJsYXlvdXRbMV0ud1wiXG4gICAgICAgICAgICAgICAgOmg9XCJsYXlvdXRbMV0uaFwiXG4gICAgICAgICAgICAgICAgOmk9XCJsYXlvdXRbMV0uaVwiXG4gICAgICAgICAgICAgICAgZHJhZy1hbGxvdy1mcm9tPVwiLnZ1ZS1kcmFnZ2FibGUtaGFuZGxlXCJcbiAgICAgICAgICAgICAgICBkcmFnLWlnbm9yZS1mcm9tPVwiLm5vLWRyYWdcIlxuICAgICAgICAgICAgICAgIGNsYXNzPVwiZGFya2VkIHRhYmJhYmxlIHJvdW5kZWQgc2hhZG93XCJcbiAgICAgICAgICAgICAgICBzdHlsZT1cIm92ZXJmbG93LXk6IGF1dG87IG92ZXJmbG93LXg6IGhpZGRlblwiXG4gICAgICAgICAgICA+XG4gICAgICAgICAgICAgICAgPFRyYWRlc1xuICAgICAgICAgICAgICAgICAgICB2LWlmPVwic3ltYm9sICE9IG51bGxcIlxuICAgICAgICAgICAgICAgICAgICA6c3ltYm9sPVwic3ltYm9sXCJcbiAgICAgICAgICAgICAgICAgICAgOmN1cnJlbmN5PVwiY3VycmVuY3lcIlxuICAgICAgICAgICAgICAgICAgICA6cnVubmluZ0JvdD1cInJ1bm5pbmdCb3RcIlxuICAgICAgICAgICAgICAgICAgICA6a2V5PVwicnVubmluZ0JvdFwiXG4gICAgICAgICAgICAgICAgLz5cbiAgICAgICAgICAgICAgICA8c3BhbiBjbGFzcz1cInZ1ZS1kcmFnZ2FibGUtaGFuZGxlXCI+PC9zcGFuPlxuICAgICAgICAgICAgPC9ncmlkLWl0ZW0+XG4gICAgICAgICAgICA8Z3JpZC1pdGVtXG4gICAgICAgICAgICAgICAgOng9XCJsYXlvdXRbMl0ueFwiXG4gICAgICAgICAgICAgICAgOnk9XCJsYXlvdXRbMl0ueVwiXG4gICAgICAgICAgICAgICAgOnc9XCJsYXlvdXRbMl0ud1wiXG4gICAgICAgICAgICAgICAgOmg9XCJsYXlvdXRbMl0uaFwiXG4gICAgICAgICAgICAgICAgOmk9XCJsYXlvdXRbMl0uaVwiXG4gICAgICAgICAgICAgICAgZHJhZy1hbGxvdy1mcm9tPVwiLnZ1ZS1kcmFnZ2FibGUtaGFuZGxlXCJcbiAgICAgICAgICAgICAgICBkcmFnLWlnbm9yZS1mcm9tPVwiLm5vLWRyYWdcIlxuICAgICAgICAgICAgICAgIGNsYXNzPVwiZGFya2VkIHJvdW5kZWQgc2hhZG93XCJcbiAgICAgICAgICAgID5cbiAgICAgICAgICAgICAgICA8TWFya2V0aW5mb1xuICAgICAgICAgICAgICAgICAgICB2LWlmPVwicHJvdmlkZXIgIT0gbnVsbFwiXG4gICAgICAgICAgICAgICAgICAgIDpzeW1ib2w9XCJzeW1ib2xcIlxuICAgICAgICAgICAgICAgICAgICA6Y3VycmVuY3k9XCJjdXJyZW5jeVwiXG4gICAgICAgICAgICAgICAgICAgIDpwcm92aWRlcj1cInByb3ZpZGVyXCJcbiAgICAgICAgICAgICAgICAvPlxuICAgICAgICAgICAgICAgIDxzcGFuIGNsYXNzPVwidnVlLWRyYWdnYWJsZS1oYW5kbGVcIj48L3NwYW4+XG4gICAgICAgICAgICA8L2dyaWQtaXRlbT5cbiAgICAgICAgICAgIDxncmlkLWl0ZW1cbiAgICAgICAgICAgICAgICA6eD1cImxheW91dFszXS54XCJcbiAgICAgICAgICAgICAgICA6eT1cImxheW91dFszXS55XCJcbiAgICAgICAgICAgICAgICA6dz1cImxheW91dFszXS53XCJcbiAgICAgICAgICAgICAgICA6aD1cImxheW91dFszXS5oXCJcbiAgICAgICAgICAgICAgICA6aT1cImxheW91dFszXS5pXCJcbiAgICAgICAgICAgICAgICBkcmFnLWFsbG93LWZyb209XCIudnVlLWRyYWdnYWJsZS1oYW5kbGVcIlxuICAgICAgICAgICAgICAgIGRyYWctaWdub3JlLWZyb209XCIubm8tZHJhZ1wiXG4gICAgICAgICAgICAgICAgY2xhc3M9XCJkYXJrZWQgcm91bmRlZCBzaGFkb3dcIlxuICAgICAgICAgICAgPlxuICAgICAgICAgICAgICAgIDxUcmFkaW5ndmlld1xuICAgICAgICAgICAgICAgICAgICB2LWlmPVwicHJvdmlkZSAhPSBudWxsXCJcbiAgICAgICAgICAgICAgICAgICAgOmtleT1cInN5bWJvbCArIGN1cnJlbmN5XCJcbiAgICAgICAgICAgICAgICAgICAgOnN5bWJvbD1cInN5bWJvbFwiXG4gICAgICAgICAgICAgICAgICAgIDpjdXJyZW5jeT1cImN1cnJlbmN5XCJcbiAgICAgICAgICAgICAgICAgICAgOnByb3ZpZGU9XCJwcm92aWRlXCJcbiAgICAgICAgICAgICAgICAvPlxuICAgICAgICAgICAgICAgIDxzcGFuIGNsYXNzPVwidnVlLWRyYWdnYWJsZS1oYW5kbGVcIj48L3NwYW4+XG4gICAgICAgICAgICA8L2dyaWQtaXRlbT5cbiAgICAgICAgICAgIDxncmlkLWl0ZW1cbiAgICAgICAgICAgICAgICA6eD1cImxheW91dFs0XS54XCJcbiAgICAgICAgICAgICAgICA6eT1cImxheW91dFs0XS55XCJcbiAgICAgICAgICAgICAgICA6dz1cImxheW91dFs0XS53XCJcbiAgICAgICAgICAgICAgICA6aD1cImxheW91dFs0XS5oXCJcbiAgICAgICAgICAgICAgICA6aT1cImxheW91dFs0XS5pXCJcbiAgICAgICAgICAgICAgICBkcmFnLWFsbG93LWZyb209XCIudnVlLWRyYWdnYWJsZS1oYW5kbGVcIlxuICAgICAgICAgICAgICAgIGRyYWctaWdub3JlLWZyb209XCIubm8tZHJhZ1wiXG4gICAgICAgICAgICAgICAgY2xhc3M9XCJkYXJrZWQgcm91bmRlZCBzaGFkb3dcIlxuICAgICAgICAgICAgPlxuICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJweC0wXCI+XG4gICAgICAgICAgICAgICAgICAgIDx1bCBjbGFzcz1cIm5hdiBuYXYtdGFic1wiIGlkPVwicGlsbHMtdGFiXCIgcm9sZT1cInRhYmxpc3RcIj5cbiAgICAgICAgICAgICAgICAgICAgICAgIDxsaSBjbGFzcz1cIm5hdi1pdGVtXCI+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPGJ1dHRvblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjbGFzcz1cIm5hdi1saW5rXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgQGNsaWNrLnByZXZlbnQ9XCJzZXRBY3RpdmUoJ3BpbGxzLW1hcmtldCcpXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgOmNsYXNzPVwieyBhY3RpdmU6IGlzQWN0aXZlKCdwaWxscy1tYXJrZXQnKSB9XCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaHJlZj1cIiNwaWxscy1tYXJrZXRcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgID5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgUmlzZS9GYWxsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPC9idXR0b24+XG4gICAgICAgICAgICAgICAgICAgICAgICA8L2xpPlxuICAgICAgICAgICAgICAgICAgICA8L3VsPlxuICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVwidGFiLWNvbnRlbnRcIiBpZD1cInBpbGxzLXRhYkNvbnRlbnRcIj5cbiAgICAgICAgICAgICAgICAgICAgICAgIDxkaXZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjbGFzcz1cInRhYi1wYW5lIGZhZGVcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDpjbGFzcz1cInsgJ2FjdGl2ZSBzaG93JzogaXNBY3RpdmUoJ3BpbGxzLW1hcmtldCcpIH1cIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlkPVwicGlsbHMtbWFya2V0XCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByb2xlPVwidGFicGFuZWxcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFyaWEtbGFiZWxsZWRieT1cInBpbGxzLW1hcmtldC10YWJcIlxuICAgICAgICAgICAgICAgICAgICAgICAgPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxmb3JtIGlkPVwiT3JkZXJcIiBAc3VibWl0LnByZXZlbnQ9XCJPcmRlcigpXCI+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJyb3cgcGItMSBweC0xXCI+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVwiY29sLTZcIj5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8bGFiZWxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yPVwic2VsZWN0Qm90XCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2xhc3M9XCJmb3JtLWxhYmVsIGQtZmxleCBqdXN0aWZ5LWNvbnRlbnQtYmV0d2VlbiB0ZXh0LTEgdGV4dC1kYXJrXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxzcGFuPkJvdHM8L3NwYW4+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPC9sYWJlbD5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IDprZXk9XCJiYWxhbmNlXCI+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxmb3JtXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2LWlmPVwiYmFsYW5jZSA9PSBudWxsXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIEBzdWJtaXQucHJldmVudD1cImNyZWF0ZVdhbGxldCgpXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPGJ1dHRvblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU9XCJzdWJtaXRcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNsYXNzPVwiYnRuIGJ0bi1zdWNjZXNzIHctMTAwXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBDcmVhdGUgV2FsbGV0XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L2J1dHRvbj5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPC9mb3JtPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8YnV0dG9uXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2LWVsc2VcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU9XCJidXR0b25cIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2xhc3M9XCJ3LTEwMCBidG4gYnRuLXByaW1hcnlcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YS1icy10b2dnbGU9XCJtb2RhbFwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhLWJzLXRhcmdldD1cIiNib3RUeXBlTW9kYWxcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVmPVwic2VsZWN0Qm90XCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgU2VsZWN0IEJvdFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L2J1dHRvbj5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8bGFiZWxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yPVwiYm90VGltZWRcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjbGFzcz1cImZvcm0tbGFiZWwgbXQtMSBkLWZsZXgganVzdGlmeS1jb250ZW50LWJldHdlZW4gdGV4dC0xIHRleHQtZGFya1wiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8c3Bhbj5EdXJhdGlvbjwvc3Bhbj5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L2xhYmVsPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxkaXZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2xhc3M9XCJkcm9wZG93blwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHYtaWY9XCJib3RfdGltZXMgIT0gbnVsbFwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDprZXk9XCJib3RfdGltZXNcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPGJ1dHRvblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2xhc3M9XCJ3LTEwMCBidG4gYnRuLW91dGxpbmUtd2FybmluZyBkcm9wZG93bi10b2dnbGVcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZT1cImJ1dHRvblwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhLWJzLXRvZ2dsZT1cImRyb3Bkb3duXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFyaWEtZXhwYW5kZWQ9XCJmYWxzZVwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWY9XCJib3RUaW1lZFwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYW1lPVwiYm90VGltZWRcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBEdXJhdGlvblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L2J1dHRvbj5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPHVsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjbGFzcz1cImRyb3Bkb3duLW1lbnUgZHJvcGRvd24tbWVudS1lbmRcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8bGlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2LWZvcj1cIihcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGltaW5nLCBpbmRleFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICkgaW4gYm90X3RpbWVzXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA6a2V5PVwiaW5kZXhcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxhXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNsYXNzPVwiZHJvcGRvd24taXRlbVwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIEBjbGljaz1cIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2V0VGltaW5nKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRpbWluZy5kdXJhdGlvbixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aW1pbmcudHlwZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA+e3sgdGltaW5nLmR1cmF0aW9uIH19XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHt7IHRpbWluZy50eXBlIH19czwvYVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvbGk+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvdWw+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPGJ1dHRvblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjbGFzcz1cInctMTAwIG10LTEgYnRuIGJ0bi1zdWNjZXNzIG10LTEgZC1mbGV4IGFsaWduLWl0ZW1zLWNlbnRlciBqdXN0aWZ5LWNvbnRlbnQtYmV0d2VlblwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU9XCJzdWJtaXRcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA6ZGlzYWJsZWQ9XCJsb2FkaW5nXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjbGFzcz1cImJpIGJpLWJhdHRlcnktY2hhcmdpbmcgZnMtM1wiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID48L2lcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPjxzcGFuPiBTdGFydCBCb3Q8L3NwYW4+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPC9idXR0b24+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJjb2wtNlwiPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxsYWJlbFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3I9XCJBbW91bnRcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjbGFzcz1cImZvcm0tbGFiZWwgZC1mbGV4IGp1c3RpZnktY29udGVudC1iZXR3ZWVuIHRleHQtMSB0ZXh0LWRhcmtcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPHNwYW4+QW1vdW50PC9zcGFuPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvbGFiZWw+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cImlucHV0LWdyb3VwIG1iLTFcIj5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPGlucHV0XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlPVwibnVtYmVyXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNsYXNzPVwiZm9ybS1jb250cm9sIHRleHQtZGFyayBib3JkZXItMFwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA6bWluPVwibWluX2Ftb3VudFwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA6bWF4PVwibWF4X2Ftb3VudFwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA6c3RlcD1cIm1pbl9hbW91bnRcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVxdWlyZWQ9XCJcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdi1tb2RlbD1cImFtb3VudFwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwbGFjZWhvbGRlcj1cIkFtb3VudFwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhcmlhLWxhYmVsPVwiQW1vdW50ICh0byB0aGUgbmVhcmVzdCBkb2xsYXIpXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLz5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPHNwYW5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNsYXNzPVwiaW5wdXQtZ3JvdXAtdGV4dCB0ZXh0LWRhcmsgYm9yZGVyLTBcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPnt7IGN1cnJlbmN5IH19PC9zcGFuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L2Zvcm0+XG4gICAgICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICAgICAgPHNwYW4gY2xhc3M9XCJ2dWUtZHJhZ2dhYmxlLWhhbmRsZVwiPjwvc3Bhbj5cbiAgICAgICAgICAgIDwvZ3JpZC1pdGVtPlxuICAgICAgICAgICAgPGdyaWQtaXRlbVxuICAgICAgICAgICAgICAgIDp4PVwibGF5b3V0WzVdLnhcIlxuICAgICAgICAgICAgICAgIDp5PVwibGF5b3V0WzVdLnlcIlxuICAgICAgICAgICAgICAgIDp3PVwibGF5b3V0WzVdLndcIlxuICAgICAgICAgICAgICAgIDpoPVwibGF5b3V0WzVdLmhcIlxuICAgICAgICAgICAgICAgIDppPVwibGF5b3V0WzVdLmlcIlxuICAgICAgICAgICAgICAgIGRyYWctYWxsb3ctZnJvbT1cIi52dWUtZHJhZ2dhYmxlLWhhbmRsZVwiXG4gICAgICAgICAgICAgICAgZHJhZy1pZ25vcmUtZnJvbT1cIi5uby1kcmFnXCJcbiAgICAgICAgICAgICAgICBjbGFzcz1cImRhcmtlZCByb3VuZGVkIHNoYWRvd1wiXG4gICAgICAgICAgICA+XG4gICAgICAgICAgICAgICAgPE9yZGVyYm9va1xuICAgICAgICAgICAgICAgICAgICB2LWlmPVwic3ltYm9sICE9IG51bGxcIlxuICAgICAgICAgICAgICAgICAgICA6c3ltYm9sPVwic3ltYm9sXCJcbiAgICAgICAgICAgICAgICAgICAgOmN1cnJlbmN5PVwiY3VycmVuY3lcIlxuICAgICAgICAgICAgICAgIC8+XG4gICAgICAgICAgICAgICAgPHNwYW4gY2xhc3M9XCJ2dWUtZHJhZ2dhYmxlLWhhbmRsZVwiPjwvc3Bhbj5cbiAgICAgICAgICAgIDwvZ3JpZC1pdGVtPlxuICAgICAgICA8L2dyaWQtbGF5b3V0PlxuXG4gICAgICAgIDxkaXZcbiAgICAgICAgICAgIGNsYXNzPVwibW9kYWwgZmFkZVwiXG4gICAgICAgICAgICBpZD1cImJvdFR5cGVNb2RhbFwiXG4gICAgICAgICAgICB0YWJpbmRleD1cIi0xXCJcbiAgICAgICAgICAgIGFyaWEtbGFiZWxsZWRieT1cImJvdFR5cGVcIlxuICAgICAgICAgICAgYXJpYS1oaWRkZW49XCJ0cnVlXCJcbiAgICAgICAgPlxuICAgICAgICAgICAgPGRpdiBjbGFzcz1cIm1vZGFsLWRpYWxvZyBtb2RhbC1kaWFsb2ctY2VudGVyZWQgbW9kYWwtbGdcIj5cbiAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVwibW9kYWwtY29udGVudFwiPlxuICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVwibW9kYWwtaGVhZGVyIGJnLXRyYW5zcGFyZW50XCI+XG4gICAgICAgICAgICAgICAgICAgICAgICA8YnV0dG9uXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZT1cImJ1dHRvblwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2xhc3M9XCJidG4tY2xvc2VcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGEtYnMtZGlzbWlzcz1cIm1vZGFsXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhcmlhLWxhYmVsPVwiQ2xvc2VcIlxuICAgICAgICAgICAgICAgICAgICAgICAgPjwvYnV0dG9uPlxuICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cIm1vZGFsLWJvZHkgcGItMyBweC1zbS0zXCI+XG4gICAgICAgICAgICAgICAgICAgICAgICA8ZGl2XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgQGNsaWNrPVwic2V0Qm90KGJvdClcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHYtZm9yPVwiKGJvdCwgaW5kZXgpIGluIGJvdF90eXBlXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA6a2V5PVwiaW5kZXhcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0eWxlPVwic3RyZXRjaGVkLWxpbmtcIlxuICAgICAgICAgICAgICAgICAgICAgICAgPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxkaXZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2xhc3M9XCJyb3cgYmctd2FsbGV0IHAtMSByb3VuZGVkIG1iLTFcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA6Y2xhc3M9XCJib3QuaWQgPT0gMSA/ICdiZy13YWxsZXQtYWN0aXZlJyA6ICcnXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJjb2wtM1wiPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPGltZ1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDpzcmM9XCInYXNzZXRzL2ltYWdlcy9ib3QvJyArIGJvdC5pbWFnZVwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cImNvbC05XCI+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVwiZC1mbGV4IGp1c3RpZnktY29udGVudC1iZXR3ZWVuXCI+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cImZ3LWJvbGQgZnMtNCB0ZXh0LXdoaXRlXCI+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHt7IGJvdC50aXRsZSB9fVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8c3BhblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdi1pZj1cImJvdC5pc19uZXcgPT0gMVwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjbGFzcz1cImZzLTYgYmFkZ2UgYmctc3VjY2VzcyB0ZXh0LXdoaXRlXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID5OZXc8L3NwYW5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxkaXZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2xhc3M9XCJmcy02IHRleHQtd2hpdGUgZC1ub25lIGQtbWQtYmxvY2tcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPGkgY2xhc3M9XCJiaSBiaS1hcHAtaW5kaWNhdG9yXCI+PC9pPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7eyBib3QuZmFrZSB9fVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVwicm93XCI+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPHNtYWxsIGNsYXNzPVwiZnMtNiB0ZXh0LXdhcm5pbmdcIj57e1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBib3QuZGVzY1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH19PC9zbWFsbD5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8ZGl2PlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBIaWdoZXN0IEFQUiBUb2RheTpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPHNwYW4gY2xhc3M9XCJ0ZXh0LXN1Y2Nlc3NcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPnt7IGJvdC5wZXJjIH19JTwvc3BhblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgPC9kaXY+XG4gICAgPC9kaXY+XG48L3RlbXBsYXRlPlxuXG48c2NyaXB0PlxuaW1wb3J0IHsgR3JpZExheW91dCwgR3JpZEl0ZW0gfSBmcm9tIFwidnVlLWdyaWQtbGF5b3V0XCI7XG5pbXBvcnQgTWFya2V0aW5mbyBmcm9tIFwiLi4vLi4vY29tcG9uZW50cy90cmFkaW5nL01hcmtldGluZm8udnVlXCI7XG5pbXBvcnQgVHJhZGluZ3ZpZXcgZnJvbSBcIi4uLy4uL2NvbXBvbmVudHMvdHJhZGluZy9UcmFkaW5ndmlldy52dWVcIjtcbmltcG9ydCBPcmRlcmJvb2sgZnJvbSBcIi4uLy4uL2NvbXBvbmVudHMvdHJhZGluZy9PcmRlcmJvb2sudnVlXCI7XG5pbXBvcnQgTWFya2V0cyBmcm9tIFwiLi4vLi4vY29tcG9uZW50cy90cmFkaW5nL01hcmtldHMudnVlXCI7XG5pbXBvcnQgVHJhZGVzIGZyb20gXCIuLi8uLi9jb21wb25lbnRzL2JvdC9UcmFkZXMudnVlXCI7XG5cbmxldCB0ZXN0TGF5b3V0cyA9IHtcbiAgICB4czogW1xuICAgICAgICB7IHg6IDAsIHk6IDE3LCB3OiAyLCBoOiA3LCBpOiBcIjBcIiB9LCAvLyBNYXJrZXRzXG4gICAgICAgIHsgeDogMCwgeTogMTMsIHc6IDIsIGg6IDcsIGk6IFwiMVwiIH0sIC8vIFRyYWRlc1xuICAgICAgICB7IHg6IDAsIHk6IDAsIHc6IDYsIGg6IDEsIGk6IFwiMlwiIH0sIC8vIE1hcmtldGluZm9cbiAgICAgICAgeyB4OiAwLCB5OiAxLCB3OiA0LCBoOiA2LCBpOiBcIjNcIiB9LCAvLyBUcmFkaW5ndmlld1xuICAgICAgICB7IHg6IDAsIHk6IDcsIHc6IDQsIGg6IDYsIGk6IFwiNFwiIH0sIC8vIE9yZGVyXG4gICAgICAgIHsgeDogMiwgeTogMTMsIHc6IDIsIGg6IDE0LCBpOiBcIjVcIiB9LCAvLyBPcmRlcmJvb2tcbiAgICBdLFxuICAgIHNtOiBbXG4gICAgICAgIHsgeDogMCwgeTogMTYsIHc6IDMsIGg6IDgsIGk6IFwiMFwiIH0sIC8vIE1hcmtldHNcbiAgICAgICAgeyB4OiAzLCB5OiAxNiwgdzogMywgaDogOCwgaTogXCIxXCIgfSwgLy8gVHJhZGVzXG4gICAgICAgIHsgeDogMCwgeTogMCwgdzogNiwgaDogMiwgaTogXCIyXCIgfSwgLy8gTWFya2V0aW5mb1xuICAgICAgICB7IHg6IDAsIHk6IDIsIHc6IDQsIGg6IDgsIGk6IFwiM1wiIH0sIC8vIFRyYWRpbmd2aWV3XG4gICAgICAgIHsgeDogMCwgeTogMTAsIHc6IDQsIGg6IDYsIGk6IFwiNFwiIH0sIC8vIE9yZGVyXG4gICAgICAgIHsgeDogNCwgeTogMiwgdzogMiwgaDogMTQsIGk6IFwiNVwiIH0sIC8vIE9yZGVyYm9va1xuICAgIF0sXG4gICAgbWQ6IFtcbiAgICAgICAgeyB4OiAwLCB5OiAwLCB3OiAzLCBoOiA4LCBpOiBcIjBcIiB9LCAvLyBNYXJrZXRzXG4gICAgICAgIHsgeDogMCwgeTogMTAsIHc6IDMsIGg6IDgsIGk6IFwiMVwiIH0sIC8vIFRyYWRlc1xuICAgICAgICB7IHg6IDMsIHk6IDAsIHc6IDcsIGg6IDIsIGk6IFwiMlwiIH0sIC8vIE1hcmtldGluZm9cbiAgICAgICAgeyB4OiAzLCB5OiAyLCB3OiA1LCBoOiA4LCBpOiBcIjNcIiB9LCAvLyBUcmFkaW5ndmlld1xuICAgICAgICB7IHg6IDMsIHk6IDEwLCB3OiA1LCBoOiA2LCBpOiBcIjRcIiB9LCAvLyBPcmRlclxuICAgICAgICB7IHg6IDgsIHk6IDQsIHc6IDIsIGg6IDE0LCBpOiBcIjVcIiB9LCAvLyBPcmRlcmJvb2tcbiAgICBdLFxuICAgIGxnOiBbXG4gICAgICAgIHsgeDogMCwgeTogMCwgdzogMywgaDogOCwgaTogXCIwXCIgfSwgLy8gTWFya2V0c1xuICAgICAgICB7IHg6IDAsIHk6IDEwLCB3OiAzLCBoOiA4LCBpOiBcIjFcIiB9LCAvLyBUcmFkZXNcbiAgICAgICAgeyB4OiAzLCB5OiAwLCB3OiA2LCBoOiAyLCBpOiBcIjJcIiB9LCAvLyBNYXJrZXRpbmZvXG4gICAgICAgIHsgeDogMywgeTogMiwgdzogNiwgaDogOCwgaTogXCIzXCIgfSwgLy8gVHJhZGluZ3ZpZXdcbiAgICAgICAgeyB4OiAzLCB5OiAxMCwgdzogNiwgaDogNiwgaTogXCI0XCIgfSwgLy8gT3JkZXJcbiAgICAgICAgeyB4OiA5LCB5OiAwLCB3OiAzLCBoOiAxNiwgaTogXCI1XCIgfSwgLy8gT3JkZXJib29rXG4gICAgXSxcbn07XG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgICAvLyBjb21wb25lbnQgbGlzdFxuICAgIGNvbXBvbmVudHM6IHtcbiAgICAgICAgTWFya2V0aW5mbyxcbiAgICAgICAgVHJhZGluZ3ZpZXcsXG4gICAgICAgIE9yZGVyYm9vayxcbiAgICAgICAgTWFya2V0cyxcbiAgICAgICAgVHJhZGVzLFxuICAgICAgICBHcmlkTGF5b3V0LFxuICAgICAgICBHcmlkSXRlbSxcbiAgICB9LFxuXG4gICAgLy8gY29tcG9uZW50IGRhdGFcbiAgICBkYXRhKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgc3ltYm9sOiB0aGlzLiRyb3V0ZS5wYXJhbXMuc3ltYm9sLFxuICAgICAgICAgICAgY3VycmVuY3k6IHRoaXMuJHJvdXRlLnBhcmFtcy5jdXJyZW5jeSxcbiAgICAgICAgICAgIGFjdGl2ZUl0ZW06IFwicGlsbHMtbWFya2V0XCIsXG4gICAgICAgICAgICBwYWlyczogbnVsbCxcbiAgICAgICAgICAgIHByb3ZpZGVyOiBudWxsLFxuICAgICAgICAgICAgcHJvdmlkZTogbnVsbCxcbiAgICAgICAgICAgIGxpbWl0OiBudWxsLFxuICAgICAgICAgICAgdXNlcjogW10sXG4gICAgICAgICAgICBnbmw6IFtdLFxuICAgICAgICAgICAgbGF5b3V0czogdGVzdExheW91dHMsXG4gICAgICAgICAgICBsYXlvdXQ6IHRlc3RMYXlvdXRzW1wibGdcIl0sXG4gICAgICAgICAgICBkcmFnZ2FibGU6IHRydWUsXG4gICAgICAgICAgICByZXNpemFibGU6IHRydWUsXG4gICAgICAgICAgICByZXNwb25zaXZlOiB0cnVlLFxuICAgICAgICAgICAgYm90X3RpbWluZzogbnVsbCxcbiAgICAgICAgICAgIGJvdF90aW1lczogbnVsbCxcbiAgICAgICAgICAgIGJvdF90eXBlOiBudWxsLFxuICAgICAgICAgICAgcnVubmluZ0JvdDogbnVsbCxcbiAgICAgICAgICAgIGxvYWRpbmc6IGZhbHNlLFxuICAgICAgICAgICAgdGltaW5nOiBudWxsLFxuICAgICAgICAgICAgYW1vdW50OiBudWxsLFxuICAgICAgICAgICAgYmFsYW5jZTogbnVsbCxcbiAgICAgICAgICAgIGJvdF9pZDogbnVsbCxcbiAgICAgICAgICAgIHR5cGU6IG51bGwsXG4gICAgICAgICAgICBtaW5fYW1vdW50OiBudWxsLFxuICAgICAgICAgICAgbWF4X2Ftb3VudDogbnVsbCxcbiAgICAgICAgfTtcbiAgICB9LFxuICAgIHdhdGNoOiB7XG4gICAgICAgIGV2ZW50TG9nOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBjb25zdCBldmVudHNEaXYgPSB0aGlzLiRyZWZzLmV2ZW50c0RpdjtcbiAgICAgICAgICAgIGV2ZW50c0Rpdi5zY3JvbGxUb3AgPSBldmVudHNEaXYuc2Nyb2xsSGVpZ2h0O1xuICAgICAgICB9LFxuICAgICAgICAkcm91dGUodG8sIGZyb20pIHtcbiAgICAgICAgICAgIHRoaXMuc3ltYm9sID0gdGhpcy4kcm91dGUucGFyYW1zLnN5bWJvbDtcbiAgICAgICAgICAgIHRoaXMuY3VycmVuY3kgPSB0aGlzLiRyb3V0ZS5wYXJhbXMuY3VycmVuY3k7XG4gICAgICAgIH0sXG4gICAgfSxcblxuICAgIC8vIGN1c3RvbSBtZXRob2RzXG4gICAgbWV0aG9kczoge1xuICAgICAgICBPcmRlcigpIHtcbiAgICAgICAgICAgIHRoaXMuJGh0dHBcbiAgICAgICAgICAgICAgICAucG9zdChcIi91c2VyL3N0b3JlL2JvdFwiLCB7XG4gICAgICAgICAgICAgICAgICAgIGFtb3VudDogdGhpcy5hbW91bnQsXG4gICAgICAgICAgICAgICAgICAgIGJvdFRpbWU6IHRoaXMudGltaW5nLFxuICAgICAgICAgICAgICAgICAgICBib3RfaWQ6IHRoaXMuYm90X2lkLFxuICAgICAgICAgICAgICAgICAgICBjdXJyZW5jeTogdGhpcy5jdXJyZW5jeSxcbiAgICAgICAgICAgICAgICAgICAgc3ltYm9sOiB0aGlzLnN5bWJvbCxcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogdGhpcy50eXBlLFxuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgLnRoZW4oKHJlc3BvbnNlKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuJHRvYXN0W3Jlc3BvbnNlLmRhdGEudHlwZV0ocmVzcG9uc2UuZGF0YS5tZXNzYWdlKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5mZXRjaERhdGEoKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5mZXRjaFdhbGxldCgpO1xuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgLmNhdGNoKChlcnJvcikgPT4ge30pXG4gICAgICAgICAgICAgICAgLmZpbmFsbHkoKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmxvYWRpbmcgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgfSxcbiAgICAgICAgc2V0Qm90KGJvdCkge1xuICAgICAgICAgICAgdGhpcy4kcmVmcy5zZWxlY3RCb3QuaW5uZXJUZXh0ID0gYm90LnRpdGxlO1xuICAgICAgICAgICAgdGhpcy5ib3RfaWQgPSBib3QuaWQ7XG4gICAgICAgICAgICB2YXIgdGltZXMgPSBbXTtcbiAgICAgICAgICAgIHRoaXMuYm90X3RpbWluZy5mb3JFYWNoKCh0aW1pbmcpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAodGltaW5nLmJvdF9pZCA9PT0gYm90LmlkKSB7XG4gICAgICAgICAgICAgICAgICAgIHRpbWVzLnB1c2godGltaW5nKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHRoaXMuYm90X3RpbWVzID0gdGltZXM7XG4gICAgICAgICAgICB0aGlzLm1pbl9hbW91bnQgPSBib3QubGltaXRzLm1pbl9ib3RfYW1vdW50O1xuICAgICAgICAgICAgdGhpcy5tYXhfYW1vdW50ID0gYm90LmxpbWl0cy5tYXhfYm90X2Ftb3VudDtcbiAgICAgICAgICAgICQoXCIjYm90VHlwZU1vZGFsXCIpLm1vZGFsKFwiaGlkZVwiKTtcbiAgICAgICAgfSxcbiAgICAgICAgc2V0VGltaW5nKGR1cmF0aW9uLCB0eXBlKSB7XG4gICAgICAgICAgICBpZiAoZHVyYXRpb24gIT0gMSkge1xuICAgICAgICAgICAgICAgIHRoaXMuJHJlZnMuYm90VGltZWQuaW5uZXJUZXh0ID0gZHVyYXRpb24gKyBcIiBcIiArIHR5cGUgKyBcInNcIjtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy4kcmVmcy5ib3RUaW1lZC5pbm5lclRleHQgPSBkdXJhdGlvbiArIFwiIFwiICsgdHlwZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMudHlwZSA9IHR5cGU7XG4gICAgICAgICAgICB0aGlzLnRpbWluZyA9IGR1cmF0aW9uO1xuICAgICAgICB9LFxuICAgICAgICBmZXRjaFdhbGxldCgpIHtcbiAgICAgICAgICAgIHRoaXMuJGh0dHBcbiAgICAgICAgICAgICAgICAucG9zdChcIi91c2VyL2ZldGNoL3dhbGxldFwiLCB7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IFwidHJhZGluZ1wiLFxuICAgICAgICAgICAgICAgICAgICBzeW1ib2w6IHRoaXMuc3ltYm9sLFxuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgLnRoZW4oKHJlc3BvbnNlKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYmFsYW5jZSA9IHJlc3BvbnNlLmRhdGEuYmFsYW5jZTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgfSxcbiAgICAgICAgY3JlYXRlV2FsbGV0KCkge1xuICAgICAgICAgICAgKHRoaXMubG9hZGluZyA9IHRydWUpLFxuICAgICAgICAgICAgICAgIHRoaXMuJGh0dHBcbiAgICAgICAgICAgICAgICAgICAgLnBvc3QoXCIvdXNlci93YWxsZXQvai9jcmVhdGVcIiwge1xuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogXCJmdW5kaW5nXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBzeW1ib2w6IHRoaXMuc3ltYm9sLFxuICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICAgICAudGhlbigocmVzcG9uc2UpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZmV0Y2hXYWxsZXQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuJHRvYXN0W3Jlc3BvbnNlLmRhdGEudHlwZV0ocmVzcG9uc2UuZGF0YS5tZXNzYWdlKTtcbiAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgICAgLmNhdGNoKChlcnJvcikgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy4kdG9hc3QuZXJyb3IoZXJyb3IucmVzcG9uc2UuZGF0YSk7XG4gICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgICAgIC5maW5hbGx5KCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMubG9hZGluZyA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgfSxcbiAgICAgICAgaXNBY3RpdmUobWVudUl0ZW0pIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmFjdGl2ZUl0ZW0gPT09IG1lbnVJdGVtO1xuICAgICAgICB9LFxuICAgICAgICBzZXRBY3RpdmUobWVudUl0ZW0pIHtcbiAgICAgICAgICAgIHRoaXMuYWN0aXZlSXRlbSA9IG1lbnVJdGVtO1xuICAgICAgICB9LFxuICAgICAgICBmZXRjaERhdGEoKSB7XG4gICAgICAgICAgICB0aGlzLiRodHRwXG4gICAgICAgICAgICAgICAgLnBvc3QoXCIvdXNlci9mZXRjaC9ib3QvaW5mb1wiLCB7XG4gICAgICAgICAgICAgICAgICAgIHN5bWJvbDogdGhpcy4kcm91dGUucGFyYW1zLnN5bWJvbCxcbiAgICAgICAgICAgICAgICAgICAgY3VycmVuY3k6IHRoaXMuJHJvdXRlLnBhcmFtcy5jdXJyZW5jeSxcbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIC50aGVuKChyZXNwb25zZSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAodGhpcy51c2VyID0gcmVzcG9uc2UuZGF0YS51c2VyKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICh0aGlzLnByb3ZpZGVyID0gcmVzcG9uc2UuZGF0YS5wcm92aWRlciksXG4gICAgICAgICAgICAgICAgICAgICAgICAodGhpcy5ib3RfdGltaW5nID0gcmVzcG9uc2UuZGF0YS5ib3RfdGltaW5nKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICh0aGlzLmJvdF90eXBlID0gcmVzcG9uc2UuZGF0YS5ib3RfdHlwZSksXG4gICAgICAgICAgICAgICAgICAgICAgICAodGhpcy5ydW5uaW5nQm90ID0gcmVzcG9uc2UuZGF0YS5ydW5uaW5nQm90KSxcbiAgICAgICAgICAgICAgICAgICAgICAgICh0aGlzLnByb3ZpZGUgPSByZXNwb25zZS5kYXRhLnByb3ZpZGUpLFxuICAgICAgICAgICAgICAgICAgICAgICAgKHRoaXMucGFpcnMgPSByZXNwb25zZS5kYXRhLnBhaXJzKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICh0aGlzLmdubCA9IHJlc3BvbnNlLmRhdGEuZ25sKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICh0aGlzLmxpbWl0ID0gcmVzcG9uc2UuZGF0YS5saW1pdCk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgIH0sXG4gICAgICAgIGdvQmFjaygpIHtcbiAgICAgICAgICAgIHdpbmRvdy5oaXN0b3J5Lmxlbmd0aCA+IDFcbiAgICAgICAgICAgICAgICA/IHRoaXMuJHJvdXRlci5nbygtMSlcbiAgICAgICAgICAgICAgICA6IHRoaXMuJHJvdXRlci5wdXNoKFwiL1wiKTtcbiAgICAgICAgfSxcbiAgICB9LFxuXG4gICAgY3JlYXRlZCgpIHtcbiAgICAgICAgdGhpcy5mZXRjaERhdGEoKTtcbiAgICAgICAgdGhpcy5mZXRjaFdhbGxldCgpO1xuICAgIH0sXG4gICAgbW91bnRlZCgpIHtcbiAgICAgICAgLypjb25zdCBwbHVnaW4gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwic2NyaXB0XCIpO1xuICAgICAgICBwbHVnaW4uc2V0QXR0cmlidXRlKFxuICAgICAgICAgICAgXCJzcmNcIixcbiAgICAgICAgICAgIFwiL3ZlbmRvcnMvanMvY2N4dC5qc1wiXG4gICAgICAgICk7XG4gICAgICAgIHBsdWdpbi5hc3luYyA9IHRydWU7XG4gICAgICAgIGRvY3VtZW50LmhlYWQuYXBwZW5kQ2hpbGQocGx1Z2luKTsqL1xuICAgICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcImhhc2hjaGFuZ2VcIiwgKGUpID0+IHtcbiAgICAgICAgICAgIHRoaXMuZmV0Y2hEYXRhKCk7XG4gICAgICAgIH0pO1xuICAgICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcImxvYWRcIiwgKGUpID0+IHtcbiAgICAgICAgICAgIHRoaXMuZmV0Y2hEYXRhKCk7XG4gICAgICAgIH0pO1xuICAgIH0sXG4gICAgLy8gb24gY29tcG9uZW50IGRlc3Ryb3llZFxuICAgIGRlc3Ryb3llZCgpIHt9LFxufTtcbjwvc2NyaXB0PlxuPHN0eWxlIGxhbmc9XCJzY3NzXCIgc2NvcGU+XG4kZGFyazogIzE3MWIyOTtcbiRsaWdodDogI2Q1ZjBlOTtcbiRlYXNlLW91dC1leHBvOiBjdWJpYy1iZXppZXIoMC4wMDUsIDEsIDAuMjIsIDEpO1xuXG46cm9vdCB7XG4gICAgLS10aGVtZS1iYWNrZ3JvdW5kLWJhc2U6ICN7bGlnaHRlbigkZGFyaywgMCUpfTtcbiAgICAtLXRoZW1lLWJhY2tncm91bmQtMzAwOiAje2xpZ2h0ZW4oJGRhcmssIDc1JSl9O1xuICAgIC0tdGhlbWUtYmFja2dyb3VuZC1vNzU6ICN7cmdiYShsaWdodGVuKCRkYXJrLCAxMCUpLCAwLjc1KX07XG4gICAgLS10aGVtZS1iYWNrZ3JvdW5kLW8yMDogI3tyZ2JhKGxpZ2h0ZW4oJGRhcmssIDEwJSksIDAuMil9O1xuICAgIC0tdGhlbWUtY29sb3Itbzc1OiAje3JnYmEoJGxpZ2h0LCAwLjc1KX07XG59XG5cbnRhYmxlIHtcbiAgICBib3JkZXItY29sbGFwc2U6IGNvbGxhcHNlO1xuICAgIHdpZHRoOiAxMDAlO1xuICAgIGZvbnQtc2l6ZTogMTFweDtcbiAgICBmb250LXdlaWdodDogNTAwO1xuICAgIGNvbG9yOiAjYjdiZGM2O1xuICAgIG92ZXJmbG93OiBoaWRkZW47XG4gICAgd2lkdGg6IDEwMCU7XG59XG4udGRkIHtcbiAgICBwb3NpdGlvbjogcmVsYXRpdmU7XG4gICAgaGVpZ2h0OiAxOHB4O1xuICAgIGxpbmUtaGVpZ2h0OiAxOHB4O1xufVxudGQge1xuICAgIGhlaWdodDogMTJweDtcbiAgICBsaW5lLWhlaWdodDogMTJweDtcbiAgICBzcGFuIHtcbiAgICAgICAgcG9zaXRpb246IHJlbGF0aXZlO1xuICAgICAgICB6LWluZGV4OiAyO1xuICAgIH1cbiAgICAucGVyY2VudCB7XG4gICAgICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTtcbiAgICAgICAgdG9wOiAwO1xuICAgICAgICBib3R0b206IDA7XG4gICAgICAgIHJpZ2h0OiAwO1xuICAgIH1cbn1cbnRkLnByaWNlIHtcbiAgICB3aWR0aDogMzAlO1xuICAgIHNwYW4ge1xuICAgICAgICBwYWRkaW5nLWxlZnQ6IDVweDtcbiAgICB9XG59XG50ZC5xdWFudGl0eSB7XG4gICAgd2lkdGg6IDMwJTtcbiAgICB0ZXh0LWFsaWduOiByaWdodDtcbn1cbnRkLnRpbWUge1xuICAgIHdpZHRoOiA0MCU7XG4gICAgdGV4dC1hbGlnbjogcmlnaHQ7XG4gICAgY29sb3I6ICM5OTk7XG4gICAgcGFkZGluZy1yaWdodDogNXB4O1xufVxudGQuYnRjIHtcbiAgICB3aWR0aDogNDAlO1xuICAgIHRleHQtYWxpZ246IHJpZ2h0O1xuICAgIHBhZGRpbmctcmlnaHQ6IDVweDtcbn1cbnRhYmxlLmFza3Mge1xuICAgIC5wZXJjZW50IHtcbiAgICAgICAgYmFja2dyb3VuZC1jb2xvcjogcmdiYSgyNDYsIDcwLCA5NCwgMC4yKTtcbiAgICB9XG59XG50YWJsZS5iaWRzIHtcbiAgICAucGVyY2VudCB7XG4gICAgICAgIGJhY2tncm91bmQtY29sb3I6IHJnYmEoMTQsIDIwMywgMTI5LCAwLjIpO1xuICAgIH1cbn1cbnRhYmxlLmFza3Nfb25seSB7XG4gICAgLnBlcmNlbnQge1xuICAgICAgICBiYWNrZ3JvdW5kLWNvbG9yOiByZ2JhKDI0NiwgNzAsIDk0LCAwLjIpO1xuICAgIH1cbn1cbnRhYmxlLmJpZHNfb25seSB7XG4gICAgLnBlcmNlbnQge1xuICAgICAgICBiYWNrZ3JvdW5kLWNvbG9yOiByZ2JhKDE0LCAyMDMsIDEyOSwgMC4yKTtcbiAgICB9XG59XG4ub3JkZXItbG9hZGVyIHtcbiAgICBwb3NpdGlvbjogcmVsYXRpdmU7XG4gICAgcmlnaHQ6IDBweDtcbiAgICB0b3A6IDEyMHB4O1xuICAgIHdpZHRoOiAxMDAlO1xuICAgIGhlaWdodDogMTAwJTtcbiAgICB6LWluZGV4OiA5OTk5O1xuICAgIGJhY2tncm91bmQ6ICMwMDAwMDBiNTtcbn1cbi5zZS1wcmUtY29uMiB7XG4gICAgcG9zaXRpb246IGFic29sdXRlO1xuICAgIHRvcDogNTAlO1xuICAgIGxlZnQ6IDUwJTtcbn1cbi5oaWRkZW4ge1xuICAgIGRpc3BsYXk6IG5vbmU7XG59XG5AbWVkaWEgKG1heC13aWR0aDogNzY3Ljk4cHgpIHtcbiAgICBodG1sIHtcbiAgICAgICAgYm9keS5uYXZiYXItc3RpY2t5IHtcbiAgICAgICAgICAgIC5hcHAtY29udGVudCB7XG4gICAgICAgICAgICAgICAgcGFkZGluZzogY2FsYygxcmVtIC0gMC44cmVtICsgNC40NXJlbSkgMCAwIDAgIWltcG9ydGFudDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn1cbjwvc3R5bGU+XG4iLCI8dGVtcGxhdGU+XG4gICAgPGRpdj5cbiAgICAgICAgPHJvdXRlci1saW5rXG4gICAgICAgICAgICB0bz1cIi9ib3RcIlxuICAgICAgICAgICAgZGF0YS1icy10b2dnbGU9XCJ0b29sdGlwXCJcbiAgICAgICAgICAgIGRhdGEtYnMtcGxhY2VtZW50PVwidG9wXCJcbiAgICAgICAgICAgIHRpdGxlPVwiVmlldyBDb250cmFjdFwiXG4gICAgICAgICAgICB2LWlmPVwicnVubmluZ0JvdCAhPSBudWxsXCJcbiAgICAgICAgPlxuICAgICAgICAgICAgPGRpdlxuICAgICAgICAgICAgICAgIGlkPVwic3BlZWR0ZXN0XCJcbiAgICAgICAgICAgICAgICBzdHlsZT1cIm1heC13aWR0aDogMjgwcHg7IG1hcmdpbjogYXV0b1wiXG4gICAgICAgICAgICAgICAgY2xhc3M9XCJwLTFcIlxuICAgICAgICAgICAgPlxuICAgICAgICAgICAgICAgIDxzdmdcbiAgICAgICAgICAgICAgICAgICAgaWQ9XCJnYXVnZVwiXG4gICAgICAgICAgICAgICAgICAgIHZlcnNpb249XCIxLjFcIlxuICAgICAgICAgICAgICAgICAgICB4bWxucz1cImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCJcbiAgICAgICAgICAgICAgICAgICAgeG1sbnM6eGxpbms9XCJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rXCJcbiAgICAgICAgICAgICAgICAgICAgeD1cIjBweFwiXG4gICAgICAgICAgICAgICAgICAgIHk9XCIwcHhcIlxuICAgICAgICAgICAgICAgICAgICB2aWV3Qm94PVwiMCAwIDEwMCAxMDBcIlxuICAgICAgICAgICAgICAgICAgICBzdHlsZT1cImVuYWJsZS1iYWNrZ3JvdW5kOiBuZXcgMCAwIDEwMCAxMDBcIlxuICAgICAgICAgICAgICAgICAgICB4bWw6c3BhY2U9XCJwcmVzZXJ2ZVwiXG4gICAgICAgICAgICAgICAgPlxuICAgICAgICAgICAgICAgICAgICA8cGF0aFxuICAgICAgICAgICAgICAgICAgICAgICAgc3R5bGU9XCJmaWxsOiAjZTMxMjEyXCJcbiAgICAgICAgICAgICAgICAgICAgICAgIGQ9XCJNMTIuOSw3NS41YzAuMywwLjUsMC43LDAuOSwxLDEuNGw3LjYtNS43Yy0wLjMtMC40LTAuNS0wLjctMC44LTEuMUwxMi45LDc1LjV6XCJcbiAgICAgICAgICAgICAgICAgICAgLz5cbiAgICAgICAgICAgICAgICAgICAgPHBhdGhcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0eWxlPVwiZmlsbDogI2VhMWYzOTsgZGlzcGxheTogbm9uZVwiXG4gICAgICAgICAgICAgICAgICAgICAgICBkPVwiTTkuMyw2OS4zYzAuMywwLjUsMC41LDEsMC44LDEuNWw4LjQtNC40Yy0wLjItMC40LTAuNC0wLjgtMC42LTEuMkw5LjMsNjkuM3pcIlxuICAgICAgICAgICAgICAgICAgICAvPlxuICAgICAgICAgICAgICAgICAgICA8cGF0aFxuICAgICAgICAgICAgICAgICAgICAgICAgc3R5bGU9XCJmaWxsOiAjZjEyZDYwOyBkaXNwbGF5OiBub25lXCJcbiAgICAgICAgICAgICAgICAgICAgICAgIGQ9XCJNNi43LDYyLjRDNi45LDYyLjksNyw2My41LDcuMiw2NGw5LjEtM2MtMC4xLTAuNC0wLjMtMC44LTAuNC0xLjJMNi43LDYyLjR6XCJcbiAgICAgICAgICAgICAgICAgICAgLz5cbiAgICAgICAgICAgICAgICAgICAgPHBhdGhcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0eWxlPVwiZmlsbDogI2Y4M2M4NTsgZGlzcGxheTogbm9uZVwiXG4gICAgICAgICAgICAgICAgICAgICAgICBkPVwiTTUuMyw1NS4yYzAsMC42LDAuMSwxLjEsMC4yLDEuN2w5LjQtMS41Yy0wLjEtMC40LTAuMS0wLjktMC4yLTEuM0w1LjMsNTUuMnpcIlxuICAgICAgICAgICAgICAgICAgICAvPlxuICAgICAgICAgICAgICAgICAgICA8cGF0aFxuICAgICAgICAgICAgICAgICAgICAgICAgc3R5bGU9XCJmaWxsOiAjZmY0YmE4OyBkaXNwbGF5OiBub25lXCJcbiAgICAgICAgICAgICAgICAgICAgICAgIGQ9XCJNNSw0Ny45YzAsMC42LDAsMS4xLDAsMS43bDkuNSwwLjFjMC0wLjUsMC0wLjksMC0xLjRMNSw0Ny45elwiXG4gICAgICAgICAgICAgICAgICAgIC8+XG4gICAgICAgICAgICAgICAgICAgIDxwYXRoXG4gICAgICAgICAgICAgICAgICAgICAgICBzdHlsZT1cImZpbGw6ICNmYjNlYjI7IGRpc3BsYXk6IG5vbmVcIlxuICAgICAgICAgICAgICAgICAgICAgICAgZD1cIk01LjksNDAuN2MtMC4xLDAuNi0wLjIsMS4xLTAuMywxLjdMMTUsNDRjMC4xLTAuNCwwLjItMC45LDAuMi0xLjNMNS45LDQwLjd6XCJcbiAgICAgICAgICAgICAgICAgICAgLz5cbiAgICAgICAgICAgICAgICAgICAgPHBhdGhcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0eWxlPVwiZmlsbDogI2Y3MzJiZjsgZGlzcGxheTogbm9uZVwiXG4gICAgICAgICAgICAgICAgICAgICAgICBkPVwiTTgsMzMuN2MtMC4yLDAuNS0wLjQsMS4xLTAuNiwxLjZsOSwzLjFjMC4xLTAuNCwwLjMtMC45LDAuNS0xLjNMOCwzMy43elwiXG4gICAgICAgICAgICAgICAgICAgIC8+XG4gICAgICAgICAgICAgICAgICAgIDxwYXRoXG4gICAgICAgICAgICAgICAgICAgICAgICBzdHlsZT1cImZpbGw6ICNmMjI2Y2Q7IGRpc3BsYXk6IG5vbmVcIlxuICAgICAgICAgICAgICAgICAgICAgICAgZD1cIk0xMS4yLDI3LjFjLTAuMywwLjUtMC41LDEtMC44LDEuNWw4LjMsNC42YzAuMi0wLjQsMC40LTAuOCwwLjctMS4yTDExLjIsMjcuMXpcIlxuICAgICAgICAgICAgICAgICAgICAvPlxuICAgICAgICAgICAgICAgICAgICA8cGF0aFxuICAgICAgICAgICAgICAgICAgICAgICAgc3R5bGU9XCJmaWxsOiAjZWUxYWRjOyBkaXNwbGF5OiBub25lXCJcbiAgICAgICAgICAgICAgICAgICAgICAgIGQ9XCJNMTUuNSwyMS4yYy0wLjQsMC40LTAuOCwwLjktMS4xLDEuM2w3LjUsNS44YzAuMy0wLjQsMC42LTAuNywwLjktMS4xTDE1LjUsMjEuMnpcIlxuICAgICAgICAgICAgICAgICAgICAvPlxuICAgICAgICAgICAgICAgICAgICA8cGF0aFxuICAgICAgICAgICAgICAgICAgICAgICAgc3R5bGU9XCJmaWxsOiAjYWUxOWRlOyBkaXNwbGF5OiBub25lXCJcbiAgICAgICAgICAgICAgICAgICAgICAgIGQ9XCJNMjAuNiwxNmMtMC41LDAuMy0wLjksMC43LTEuMywxLjFsNi41LDdjMC4zLTAuMywwLjYtMC42LDEtMC45TDIwLjYsMTZ6XCJcbiAgICAgICAgICAgICAgICAgICAgLz5cbiAgICAgICAgICAgICAgICAgICAgPHBhdGhcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0eWxlPVwiZmlsbDogIzY2MThjZDsgZGlzcGxheTogbm9uZVwiXG4gICAgICAgICAgICAgICAgICAgICAgICBkPVwiTTI2LjQsMTEuN2MtMC41LDAuMy0wLjksMC42LTEuNCwwLjlsNS4zLDcuOWMwLjMtMC4yLDAuNy0wLjUsMS0wLjdMMjYuNCwxMS43elwiXG4gICAgICAgICAgICAgICAgICAgIC8+XG4gICAgICAgICAgICAgICAgICAgIDxwYXRoXG4gICAgICAgICAgICAgICAgICAgICAgICBzdHlsZT1cImZpbGw6ICMyNzE2YmQ7IGRpc3BsYXk6IG5vbmVcIlxuICAgICAgICAgICAgICAgICAgICAgICAgZD1cIk0zMyw4LjNjLTAuNiwwLjItMS4xLDAuNS0xLjYsMC43bDMuOSw4LjdjMC40LTAuMiwwLjktMC40LDEuMy0wLjZMMzMsOC4zelwiXG4gICAgICAgICAgICAgICAgICAgIC8+XG4gICAgICAgICAgICAgICAgICAgIDxwYXRoXG4gICAgICAgICAgICAgICAgICAgICAgICBzdHlsZT1cImZpbGw6ICMxNTM3YWM7IGRpc3BsYXk6IG5vbmVcIlxuICAgICAgICAgICAgICAgICAgICAgICAgZD1cIk0zOS45LDYuMWMtMC41LDAuMS0xLjEsMC4zLTEuNiwwLjRsMi41LDkuMmMwLjQtMC4xLDAuOC0wLjIsMS4yLTAuM0wzOS45LDYuMXpcIlxuICAgICAgICAgICAgICAgICAgICAvPlxuICAgICAgICAgICAgICAgICAgICA8cGF0aFxuICAgICAgICAgICAgICAgICAgICAgICAgc3R5bGU9XCJmaWxsOiAjMjA2MWMxOyBkaXNwbGF5OiBub25lXCJcbiAgICAgICAgICAgICAgICAgICAgICAgIGQ9XCJNNDcuMiw1LjJjLTAuNiwwLTEuMSwwLTEuNywwLjFsMC45LDkuNGMwLjQsMCwwLjktMC4xLDEuMy0wLjFMNDcuMiw1LjJ6XCJcbiAgICAgICAgICAgICAgICAgICAgLz5cbiAgICAgICAgICAgICAgICAgICAgPHBhdGhcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0eWxlPVwiZmlsbDogIzJjOTBkNTsgZGlzcGxheTogbm9uZVwiXG4gICAgICAgICAgICAgICAgICAgICAgICBkPVwiTTU0LjUsNS4yYy0wLjYsMC0xLjEtMC4xLTEuNy0wLjFsLTAuNiw5LjVjMC40LDAsMC45LDAuMSwxLjMsMC4xTDU0LjUsNS4yelwiXG4gICAgICAgICAgICAgICAgICAgIC8+XG4gICAgICAgICAgICAgICAgICAgIDxwYXRoXG4gICAgICAgICAgICAgICAgICAgICAgICBzdHlsZT1cImZpbGw6ICMzYmMyZWE7IGRpc3BsYXk6IG5vbmVcIlxuICAgICAgICAgICAgICAgICAgICAgICAgZD1cIk02MS42LDYuNWMtMC41LTAuMS0xLjEtMC4zLTEuNi0wLjRsLTIuMiw5LjNjMC40LDAuMSwwLjksMC4yLDEuMywwLjNMNjEuNiw2LjV6XCJcbiAgICAgICAgICAgICAgICAgICAgLz5cbiAgICAgICAgICAgICAgICAgICAgPHBhdGhcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0eWxlPVwiZmlsbDogIzRiZjdmZjsgZGlzcGxheTogbm9uZVwiXG4gICAgICAgICAgICAgICAgICAgICAgICBkPVwiTTY4LjYsOUM2OCw4LjcsNjcuNSw4LjUsNjcsOC4zbC0zLjYsOC44YzAuNCwwLjIsMC44LDAuMywxLjIsMC41TDY4LjYsOXpcIlxuICAgICAgICAgICAgICAgICAgICAvPlxuICAgICAgICAgICAgICAgICAgICA8cGF0aFxuICAgICAgICAgICAgICAgICAgICAgICAgc3R5bGU9XCJmaWxsOiAjMzlmNmQyOyBkaXNwbGF5OiBub25lXCJcbiAgICAgICAgICAgICAgICAgICAgICAgIGQ9XCJNNzQuOSwxMi41Yy0wLjQtMC4zLTAuOS0wLjYtMS40LTAuOWwtNSw4LjFjMC40LDAuMiwwLjcsMC41LDEuMSwwLjdMNzQuOSwxMi41elwiXG4gICAgICAgICAgICAgICAgICAgIC8+XG4gICAgICAgICAgICAgICAgICAgIDxwYXRoXG4gICAgICAgICAgICAgICAgICAgICAgICBzdHlsZT1cImZpbGw6ICMyOGVkOTk7IGRpc3BsYXk6IG5vbmVcIlxuICAgICAgICAgICAgICAgICAgICAgICAgZD1cIk04MC42LDE3Yy0wLjUtMC40LTAuOS0wLjctMS4zLTEuMWwtNi4yLDcuMmMwLjMsMC4zLDAuNywwLjYsMSwwLjlMODAuNiwxN3pcIlxuICAgICAgICAgICAgICAgICAgICAvPlxuICAgICAgICAgICAgICAgICAgICA8cGF0aFxuICAgICAgICAgICAgICAgICAgICAgICAgc3R5bGU9XCJmaWxsOiAjMTllNTVkOyBkaXNwbGF5OiBub25lXCJcbiAgICAgICAgICAgICAgICAgICAgICAgIGQ9XCJNODUuNywyMi40Yy0wLjQtMC40LTAuNy0wLjktMS4xLTEuM2wtNy40LDYuMWMwLjMsMC4zLDAuNSwwLjcsMC44LDFMODUuNywyMi40elwiXG4gICAgICAgICAgICAgICAgICAgIC8+XG4gICAgICAgICAgICAgICAgICAgIDxwYXRoXG4gICAgICAgICAgICAgICAgICAgICAgICBzdHlsZT1cImZpbGw6ICMwYWRjMWU7IGRpc3BsYXk6IG5vbmVcIlxuICAgICAgICAgICAgICAgICAgICAgICAgZD1cIk04OS42LDI4LjZjLTAuMi0wLjUtMC41LTEtMC44LTEuNUw4MC42LDMyYzAuMiwwLjQsMC40LDAuNywwLjYsMS4xTDg5LjYsMjguNnpcIlxuICAgICAgICAgICAgICAgICAgICAvPlxuICAgICAgICAgICAgICAgICAgICA8cGF0aFxuICAgICAgICAgICAgICAgICAgICAgICAgc3R5bGU9XCJmaWxsOiAjMGFkYzFlOyBkaXNwbGF5OiBub25lXCJcbiAgICAgICAgICAgICAgICAgICAgICAgIGQ9XCJNOTIuNSwzNS4zYy0wLjItMC41LTAuNC0xLjEtMC42LTEuNmwtOC44LDMuNGMwLjIsMC40LDAuMywwLjgsMC41LDEuMkw5Mi41LDM1LjN6XCJcbiAgICAgICAgICAgICAgICAgICAgLz5cbiAgICAgICAgICAgICAgICAgICAgPHBhdGhcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0eWxlPVwiZmlsbDogIzBhZGMxZTsgZGlzcGxheTogbm9uZVwiXG4gICAgICAgICAgICAgICAgICAgICAgICBkPVwiTTk0LjQsNDIuMmMtMC4xLTAuNS0wLjItMS4xLTAuMy0xLjZsLTkuNCwyYzAuMSwwLjQsMC4yLDAuOSwwLjIsMS4zTDk0LjQsNDIuMnpcIlxuICAgICAgICAgICAgICAgICAgICAvPlxuICAgICAgICAgICAgICAgICAgICA8cGF0aFxuICAgICAgICAgICAgICAgICAgICAgICAgc3R5bGU9XCJmaWxsOiAjMGFkYzFlOyBkaXNwbGF5OiBub25lXCJcbiAgICAgICAgICAgICAgICAgICAgICAgIGQ9XCJNOTUsNDcuOGwtOS41LDAuNWMwLDAuNCwwLDAuOSwwLDEuM2w5LjUtMC4xQzk1LDQ4LjksOTUsNDguNCw5NSw0Ny44elwiXG4gICAgICAgICAgICAgICAgICAgIC8+XG4gICAgICAgICAgICAgICAgICAgIDxwYXRoXG4gICAgICAgICAgICAgICAgICAgICAgICBzdHlsZT1cImZpbGw6ICMwYWRjMWU7IGRpc3BsYXk6IG5vbmVcIlxuICAgICAgICAgICAgICAgICAgICAgICAgZD1cIk05NC41LDU2LjhjMC4xLTAuNSwwLjEtMS4xLDAuMi0xLjdsLTkuNC0xYy0wLjEsMC40LTAuMSwwLjktMC4yLDEuM0w5NC41LDU2Ljh6XCJcbiAgICAgICAgICAgICAgICAgICAgLz5cbiAgICAgICAgICAgICAgICAgICAgPHBhdGhcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0eWxlPVwiZmlsbDogIzBhZGMxZTsgZGlzcGxheTogbm9uZVwiXG4gICAgICAgICAgICAgICAgICAgICAgICBkPVwiTTkyLjgsNjMuOWMwLjItMC41LDAuMy0xLDAuNS0xLjdsLTkuMS0yLjZjLTAuMSwwLjQtMC4zLDAuOS0wLjQsMS4zTDkyLjgsNjMuOXpcIlxuICAgICAgICAgICAgICAgICAgICAvPlxuICAgICAgICAgICAgICAgICAgICA8cGF0aFxuICAgICAgICAgICAgICAgICAgICAgICAgc3R5bGU9XCJmaWxsOiAjMGFkYzFlOyBkaXNwbGF5OiBub25lXCJcbiAgICAgICAgICAgICAgICAgICAgICAgIGQ9XCJNOTAsNzAuN2MwLjItMC41LDAuNS0xLDAuOC0xLjVsLTguNy00LjFjLTAuMiwwLjQtMC40LDAuOC0wLjYsMS4yTDkwLDcwLjd6XCJcbiAgICAgICAgICAgICAgICAgICAgLz5cbiAgICAgICAgICAgICAgICAgICAgPHBhdGhcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0eWxlPVwiZmlsbDogIzBhZGMxZTsgZGlzcGxheTogbm9uZVwiXG4gICAgICAgICAgICAgICAgICAgICAgICBkPVwiTTg5LjksODAuMWMwLjUtMC43LDEtMS4zLDEuNC0xLjlsLTEyLTguMmMtMC4zLDAuNC0wLjYsMC45LTAuOSwxLjNMODkuOSw4MC4xelwiXG4gICAgICAgICAgICAgICAgICAgIC8+XG4gICAgICAgICAgICAgICAgPC9zdmc+XG4gICAgICAgICAgICAgICAgPGRpdiBpZD1cImdhdWdlLWxhYmVsXCI+MDwvZGl2PlxuICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgIDwvcm91dGVyLWxpbms+XG5cbiAgICAgICAgPGRpdiBjbGFzcz1cInRhYmxlLXJlc3BvbnNpdmVcIj5cbiAgICAgICAgICAgIDx0YWJsZSBjbGFzcz1cInRhYmxlIHRleHQtZGFyayB0YWJsZS1zbSB0YWJsZS1ib3JkZXJsZXNzXCI+XG4gICAgICAgICAgICAgICAgPHRoZWFkIGNsYXNzPVwidGV4dC1tdXRlZFwiPlxuICAgICAgICAgICAgICAgICAgICA8dHI+XG4gICAgICAgICAgICAgICAgICAgICAgICA8dGggY2xhc3M9XCJ0ZXh0LXN0YXJ0XCIgc2NvcGU9XCJjb2xcIj5QcmljZTwvdGg+XG4gICAgICAgICAgICAgICAgICAgICAgICA8dGggY2xhc3M9XCJ0ZXh0LXN0YXJ0XCIgc2NvcGU9XCJjb2xcIj5BbW91bnQ8L3RoPlxuICAgICAgICAgICAgICAgICAgICAgICAgPHRoIGNsYXNzPVwidGV4dC1lbmRcIiBzY29wZT1cImNvbFwiPlRpbWU8L3RoPlxuICAgICAgICAgICAgICAgICAgICA8L3RyPlxuICAgICAgICAgICAgICAgIDwvdGhlYWQ+XG4gICAgICAgICAgICAgICAgPHRib2R5IGlkPVwidHJhZGVUYWJsZVwiIGNsYXNzPVwidHJhZGVcIj48L3Rib2R5PlxuICAgICAgICAgICAgPC90YWJsZT5cbiAgICAgICAgPC9kaXY+XG4gICAgPC9kaXY+XG48L3RlbXBsYXRlPlxuXG48c2NyaXB0PlxuLy8gY29tcG9uZW50XG5leHBvcnQgZGVmYXVsdCB7XG4gICAgcHJvcHM6IFtcInN5bWJvbFwiLCBcImN1cnJlbmN5XCIsIFwicnVubmluZ0JvdFwiXSxcblxuICAgIC8vIGNvbXBvbmVudCBsaXN0XG4gICAgY29tcG9uZW50czoge30sXG5cbiAgICAvLyBjb21wb25lbnQgZGF0YVxuICAgIGRhdGEoKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBzdGF0dXM6IHRydWUsXG4gICAgICAgIH07XG4gICAgfSxcblxuICAgIGNvbXB1dGVkOiB7fSxcblxuICAgIC8vIGN1c3RvbSBtZXRob2RzXG4gICAgbWV0aG9kczoge1xuICAgICAgICB1cGRhdGVUcmFkZXMocmVzKSB7XG4gICAgICAgICAgICBsZXQgbGFzdElkID0gXCJcIjtcbiAgICAgICAgICAgIGxldCBjb2xvciA9IFwiXCI7XG4gICAgICAgICAgICB2YXIgdGFibGVkID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJ0cmFkZVRhYmxlXCIpO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCByZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBpZiAocmVzW2ldW1wiaWRcIl0gPiBsYXN0SWQpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJlc1tpXVtcInNpZGVcIl0gPT0gXCJzZWxsXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbG9yID0gXCJyZ2IoMjQ2LDcwLDkzKVwiO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29sb3IgPSBcInJnYigxNCwyMDMsMTI5KVwiO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGxldCByb3cgPSAkKFwiPHRyPlwiKVxuICAgICAgICAgICAgICAgICAgICAgICAgLmFwcGVuZChcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAkKFwiPHRkPlwiKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAuY3NzKFwiY29sb3JcIiwgY29sb3IpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5hZGRDbGFzcyhcInByaWNlXCIpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5hcHBlbmQoJChcIjxzcGFuPlwiKS50ZXh0KHJlc1tpXVtcInByaWNlXCJdKSlcbiAgICAgICAgICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICAgICAgICAgIC5hcHBlbmQoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJChcIjx0ZD5cIilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLmFkZENsYXNzKFwiYW1vdW50XCIpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5hcHBlbmQoJChcIjxzcGFuPlwiKS50ZXh0KHJlc1tpXVtcImFtb3VudFwiXSkpXG4gICAgICAgICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgICAgICAgICAuYXBwZW5kKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICQoJzx0ZCBjbGFzcz1cInRleHQtZW5kXCI+JylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLmFkZENsYXNzKFwidGltZVwiKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAuYXBwZW5kKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJChcIjxzcGFuPlwiKS50ZXh0KFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZm9ybWF0VGltZShyZXNbaV1bXCJkYXRldGltZVwiXSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgICAgJChcIi50cmFkZVwiKS5wcmVwZW5kKHJvdyk7XG4gICAgICAgICAgICAgICAgICAgIGxhc3RJZCA9IHJlc1tpXVtcImlkXCJdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAodGFibGVkLnJvd3MubGVuZ3RoID4gNSkge1xuICAgICAgICAgICAgICAgICAgICB0YWJsZWQuZGVsZXRlUm93KHRhYmxlZC5yb3dzLmxlbmd0aCAtIDEpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgYXN5bmMgbG9vcFRyYWRlcygpIHtcbiAgICAgICAgICAgIHdoaWxlICh0aGlzLnN0YXR1cyA9PSB0cnVlKSB7XG4gICAgICAgICAgICAgICAgaWYgKGRvY3VtZW50LmhpZGRlbikge1xuICAgICAgICAgICAgICAgICAgICBhd2FpdCBjY3h0LnNsZWVwKDEwMDApO1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcmVzID0gYXdhaXQgZXhjaGFuZ2Uud2F0Y2hUcmFkZXMoXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnN5bWJvbCArIFwiL1wiICsgdGhpcy5jdXJyZW5jeVxuICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnVwZGF0ZVRyYWRlcyhyZXMpO1xuICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBmb3JtYXRUaW1lKHRpbWUpIHtcbiAgICAgICAgICAgIHJldHVybiB0aW1lLnNwbGl0KFwiVFwiKVsxXS5zcGxpdChcIi5cIilbMF07XG4gICAgICAgIH0sXG4gICAgfSxcblxuICAgIC8vIG9uIGNvbXBvbmVudCBjcmVhdGVkXG4gICAgY3JlYXRlZCgpIHtcbiAgICAgICAgdmFyIGkgPSAwLFxuICAgICAgICAgICAgZGVsYXkgPSA1MDAwLFxuICAgICAgICAgICAgdmFsdWUgPSAwLFxuICAgICAgICAgICAgdmFsdWVTdG9yZSA9IDAsXG4gICAgICAgICAgICB0aWNrID0gMSxcbiAgICAgICAgICAgIHRpY2tTdG9yZSA9IDEsXG4gICAgICAgICAgICB0aWNrRGlmZiA9IDAsXG4gICAgICAgICAgICB0aWNrRGlmZlZhbHVlID0gMDtcblxuICAgICAgICBmdW5jdGlvbiB2YWxCZXR3ZWVuKHYsIG1pbiwgbWF4KSB7XG4gICAgICAgICAgICByZXR1cm4gTWF0aC5taW4obWF4LCBNYXRoLm1heChtaW4sIHYpKTtcbiAgICAgICAgfVxuICAgICAgICAoZnVuY3Rpb24gbG9vcCgpIHtcbiAgICAgICAgICAgIHZhbHVlID0gTWF0aC5jZWlsKE1hdGgucmFuZG9tKCkgKiAxMCk7XG4gICAgICAgICAgICB0aWNrID0gdmFsQmV0d2VlbihNYXRoLmNlaWwoKHZhbHVlIC8gMTApICogMjgpLCAxLCAyOCk7XG4gICAgICAgICAgICB0aWNrRGlmZiA9IE1hdGguYWJzKHRpY2sgLSB0aWNrU3RvcmUpO1xuICAgICAgICAgICAgdGlja0RpZmZWYWx1ZSA9IE1hdGguYWJzKHZhbHVlIC0gdmFsdWVTdG9yZSkgLyB0aWNrRGlmZjtcbiAgICAgICAgICAgIHZhciBjb3VudGVyID0gMCxcbiAgICAgICAgICAgICAgICB2YWx1ZVN0b3JlVGVtcCA9IHZhbHVlU3RvcmUsXG4gICAgICAgICAgICAgICAgdGlja1N0b3JlVGVtcCA9IHRpY2tTdG9yZTtcbiAgICAgICAgICAgIGlmICh2YWx1ZSA+IHZhbHVlU3RvcmUpIHtcbiAgICAgICAgICAgICAgICBmb3IgKGkgPSB0aWNrU3RvcmVUZW1wOyBpIDw9IHRpY2s7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICAoZnVuY3Rpb24gKGkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICQoXCIjZ2F1Z2VcIikuY3NzKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcImJveC1zaGFkb3dcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCIwIDAgMzJweCByZ2JhKDIxLCA1NSwgMTcyLCAwLjI1KSwgaW5zZXQgMCAtMTkycHggMTkycHggLTI0MHB4IFwiICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICQoXCIjZ2F1Z2UgcGF0aDpudGgtY2hpbGQoXCIgKyBpICsgXCIpXCIpWzBdXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLnN0eWxlLmZpbGwgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCIsIGluc2V0IDAgMCAycHggLTFweCBcIiArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAkKFwiI2dhdWdlIHBhdGg6bnRoLWNoaWxkKFwiICsgaSArIFwiKVwiKVswXVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5zdHlsZS5maWxsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAkKFwiI2dhdWdlIHBhdGg6bnRoLWNoaWxkKFwiICsgaSArIFwiKVwiKS5zaG93KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJChcIiNnYXVnZS1sYWJlbFwiKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAuY3NzKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJjb2xvclwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJChcIiNnYXVnZSBwYXRoOm50aC1jaGlsZChcIiArIGkgKyBcIilcIilbMF1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAuc3R5bGUuZmlsbFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC50ZXh0KFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgTWF0aC5jZWlsKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlU3RvcmVUZW1wICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGlja0RpZmZWYWx1ZSAqXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBNYXRoLmFicyh0aWNrU3RvcmVUZW1wIC0gaSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaSA9PSB0aWNrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICQoXCIjZ2F1Z2UtbGFiZWxcIikudGV4dCh2YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfSwgNTAgKiBjb3VudGVyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvdW50ZXIrKztcbiAgICAgICAgICAgICAgICAgICAgfSkoaSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIGlmICh2YWx1ZSA8IHZhbHVlU3RvcmUpIHtcbiAgICAgICAgICAgICAgICBmb3IgKGkgPSB0aWNrU3RvcmVUZW1wOyBpID49IHRpY2s7IGktLSkge1xuICAgICAgICAgICAgICAgICAgICAoZnVuY3Rpb24gKGkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICQoXCIjZ2F1Z2VcIikuY3NzKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcImJveC1zaGFkb3dcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCIwIDAgMzJweCByZ2JhKDIxLCA1NSwgMTcyLCAwLjI1KSwgaW5zZXQgMCAtMTkycHggMTkycHggLTI0MHB4IFwiICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICQoXCIjZ2F1Z2UgcGF0aDpudGgtY2hpbGQoXCIgKyBpICsgXCIpXCIpWzBdXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLnN0eWxlLmZpbGwgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCIsIGluc2V0IDAgMCAycHggLTFweCBcIiArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAkKFwiI2dhdWdlIHBhdGg6bnRoLWNoaWxkKFwiICsgaSArIFwiKVwiKVswXVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5zdHlsZS5maWxsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAkKFwiI2dhdWdlIHBhdGg6bnRoLWNoaWxkKFwiICsgaSArIFwiKVwiKS5oaWRlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJChcIiNnYXVnZS1sYWJlbFwiKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAuY3NzKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJjb2xvclwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJChcIiNnYXVnZSBwYXRoOm50aC1jaGlsZChcIiArIGkgKyBcIilcIilbMF1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAuc3R5bGUuZmlsbFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC50ZXh0KFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgTWF0aC5mbG9vcihcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZVN0b3JlVGVtcCAtXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRpY2tEaWZmVmFsdWUgKlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgTWF0aC5hYnModGlja1N0b3JlVGVtcCAtIGkpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGkgPT0gdGljaykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAkKFwiI2dhdWdlLWxhYmVsXCIpLnRleHQodmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH0sIDUwICogY291bnRlcik7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb3VudGVyKys7XG4gICAgICAgICAgICAgICAgICAgIH0pKGkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhbHVlU3RvcmUgPSB2YWx1ZTtcbiAgICAgICAgICAgIHRpY2tTdG9yZSA9IHRpY2s7XG4gICAgICAgICAgICB3aW5kb3cuc2V0VGltZW91dChsb29wLCBkZWxheSk7XG4gICAgICAgIH0pKCk7XG4gICAgfSxcblxuICAgIC8vIG9uIGNvbXBvbmVudCBtb3VudGVkXG4gICAgbW91bnRlZCgpIHtcbiAgICAgICAgdGhpcy5sb29wVHJhZGVzKCk7XG4gICAgfSxcblxuICAgIC8vIG9uIGNvbXBvbmVudCBkZXN0cm95ZWRcbiAgICBkZXN0cm95ZWQoKSB7fSxcbn07XG48L3NjcmlwdD5cbiIsIjx0ZW1wbGF0ZT5cbiAgICA8ZGl2IGNsYXNzPVwiXCI+XG4gICAgICAgIDxkaXYgY2xhc3M9XCJkLWZsZXggZC1zbS1ub25lIGp1c3RpZnktY29udGVudC1iZXR3ZWVuIGFsaWduLWl0ZW1zLWNlbnRlciB0ZXh0LTJcIj5cbiAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJkLWZsZXggZmxleC1jb2x1bW5cIj5cbiAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVwidGV4dC1tdXRlZFwiPkxhc3QgUHJpY2U6IDxzcGFuIGNsYXNzPVwibGFzdF9wcmljZVwiPi0tLS0tLTwvc3Bhbj48aVxuICAgICAgICAgICAgICAgICAgICAgICAgY2xhc3M9XCJsYXN0X3ByaWNlX2ljb24gYmlcIj48L2k+PC9kaXY+XG4gICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cInRleHQtbXV0ZWRcIj4yNGggQ2hhbmdlOiA8c3BhbiBjbGFzcz1cImRheV9jaGFuZ2VcIj4tLS0tLS08L3NwYW4+PGlcbiAgICAgICAgICAgICAgICAgICAgICAgIGNsYXNzPVwiZGF5X2NoYW5nZV9pY29uIGJpXCI+PC9pPjwvZGl2PlxuICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICA8ZGl2IHYtaWY9XCJwcm92aWRlciAhPSAnY29pbmJhc2Vwcm8nXCIgY2xhc3M9XCJkLWZsZXggZmxleC1jb2x1bW5cIj5cbiAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVwidGV4dC1tdXRlZCBkLW5vbmUgZC1tZC1ibG9ja1wiPnt7IHN5bWJvbCB9fSBWb2x1bWU6IDxzcGFuXG4gICAgICAgICAgICAgICAgICAgICAgICBjbGFzcz1cInRleHQtZGFyayBkYXlfdm9sdW1lX3BhaXJcIj4tLS0tLS08L3NwYW4+PC9kaXY+XG4gICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cInRleHQtbXV0ZWQgZC1ub25lIGQtbWQtYmxvY2tcIj57eyBjdXJyZW5jeSB9fSBWb2x1bWU6IDxzcGFuXG4gICAgICAgICAgICAgICAgICAgICAgICBjbGFzcz1cInRleHQtZGFyayBkYXlfdm9sdW1lX2N1cnJlbmN5XCI+LS0tLS0tPC9zcGFuPjwvZGl2PlxuICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICA8ZGl2IHYtaWY9XCJwcm92aWRlciAhPSAnY29pbmJhc2Vwcm8nXCIgY2xhc3M9XCJkLWZsZXggZmxleC1jb2x1bW5cIj5cbiAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVwidGV4dC1tdXRlZFwiPjI0aCBIaWdoOiA8c3BhbiBjbGFzcz1cInRleHQtZGFyayBkYXlfaGlnaFwiPi0tLS0tLTwvc3Bhbj48L2Rpdj5cbiAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVwidGV4dC1tdXRlZFwiPjI0aCBMb3c6IDxzcGFuIGNsYXNzPVwidGV4dC1kYXJrIGRheV9sb3dcIj4tLS0tLS08L3NwYW4+PC9kaXY+XG4gICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgPC9kaXY+XG4gICAgICAgIDxkaXYgY2xhc3M9XCJkLW5vbmUgZC1zbS1mbGV4IGp1c3RpZnktY29udGVudC1iZXR3ZWVuIGFsaWduLWl0ZW1zLWNlbnRlciBteC0xIHRleHQtMiBtdC0xXCI+XG4gICAgICAgICAgICA8ZGl2IGNsYXNzPVwiZC1mbGV4IGFsaWduLWl0ZW1zLWNlbnRlclwiPlxuICAgICAgICAgICAgICAgIDxpbWcgY2xhc3M9XCJhdmF0YXItY29udGVudFwiIHdpZHRoPVwiMzZweFwiXG4gICAgICAgICAgICAgICAgICAgIDpzcmM9XCInLi4vLi4vLi4vLi4vLi4vYXNzZXRzL2ltYWdlcy9jcnlwdG9DdXJyZW5jeS8nKyhzeW1ib2wpLnRvTG93ZXJDYXNlKCkrJy5wbmcnXCIgOmFsdD1cInN5bWJvbFwiPlxuICAgICAgICAgICAgICAgIDxpIGNsYXNzPVwiYmkgYmktY2hldnJvbi1yaWdodFwiPjwvaT5cbiAgICAgICAgICAgICAgICA8aW1nIGNsYXNzPVwiYXZhdGFyLWNvbnRlbnRcIiB3aWR0aD1cIjM2cHhcIlxuICAgICAgICAgICAgICAgICAgICA6c3JjPVwiJy4uLy4uLy4uLy4uLy4uL2Fzc2V0cy9pbWFnZXMvY3J5cHRvQ3VycmVuY3kvJysoY3VycmVuY3kpLnRvTG93ZXJDYXNlKCkrJy5wbmcnXCIgOmFsdD1cImN1cnJlbmN5XCI+XG4gICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgIDxkaXYgdi1pZj1cInByb3ZpZGVyICE9ICdjb2luYmFzZXBybydcIiBjbGFzcz1cImQtZmxleCBmbGV4LWNvbHVtblwiPlxuICAgICAgICAgICAgICAgIDxzcGFuIGNsYXNzPVwidGV4dC1tdXRlZFwiPjI0aCBjaGFuZ2U8L3NwYW4+XG4gICAgICAgICAgICAgICAgPHNwYW4gY2xhc3M9XCJkYXlfY2hhbmdlIGZzLTZcIj4tLS0tLS0tPC9zcGFuPlxuICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICA8ZGl2IGNsYXNzPVwiZC1mbGV4IGZsZXgtY29sdW1uXCI+XG4gICAgICAgICAgICAgICAgPHNwYW4gY2xhc3M9XCJ0ZXh0LW11dGVkXCI+MjRoIFByaWNlIFJhbmdlPC9zcGFuPlxuICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJ0ZXh0LW11dGVkXCI+SGlnaDogPHNwYW4gY2xhc3M9XCJ0ZXh0LWRhcmsgZGF5X2hpZ2hcIj4tLS0tLS0tPC9zcGFuPjwvZGl2PlxuICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJ0ZXh0LW11dGVkXCI+TG93OiA8c3BhbiBjbGFzcz1cInRleHQtZGFyayBkYXlfbG93XCI+LS0tLS0tLTwvc3Bhbj48L2Rpdj5cbiAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgPGRpdiBjbGFzcz1cImQtZmxleCBmbGV4LWNvbHVtblwiPlxuICAgICAgICAgICAgICAgIDxzcGFuIGNsYXNzPVwidGV4dC1tdXRlZFwiPjI0aCBWb2x1bWU8L3NwYW4+XG4gICAgICAgICAgICAgICAgPHNwYW4gY2xhc3M9XCJ0ZXh0LW11dGVkXCI+e3sgc3ltYm9sIH19OiA8c3BhbiBjbGFzcz1cInRleHQtZGFyayBkYXlfdm9sdW1lX3BhaXJcIj4tLS0tLS0tPC9zcGFuPjwvc3Bhbj5cbiAgICAgICAgICAgICAgICA8c3BhbiB2LWlmPVwicHJvdmlkZXIgIT0gJ2NvaW5iYXNlcHJvJ1wiIGNsYXNzPVwidGV4dC1tdXRlZFwiPnt7IGN1cnJlbmN5IH19OiA8c3BhblxuICAgICAgICAgICAgICAgICAgICAgICAgY2xhc3M9XCJ0ZXh0LWRhcmsgZGF5X3ZvbHVtZV9jdXJyZW5jeVwiPi0tLS0tLS08L3NwYW4+PC9zcGFuPlxuICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgIDwvZGl2PlxuICAgIDwvZGl2PlxuPC90ZW1wbGF0ZT5cblxuPHNjcmlwdD5cblxuLy8gY29tcG9uZW50XG5leHBvcnQgZGVmYXVsdCB7XG5cbiAgICBwcm9wczogW1xuICAgICAgICAncHJvdmlkZXInLCdzeW1ib2wnLCdjdXJyZW5jeSdcbiAgICBdLFxuXG4gICAgLy8gY29tcG9uZW50IGxpc3RcbiAgICBjb21wb25lbnRzOiB7XG5cbiAgICB9LFxuXG4gICAgLy8gY29tcG9uZW50IGRhdGFcbiAgICBkYXRhKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgbGFzdF9wcmljZTonJyxcbiAgICAgICAgICAgIGRheV9jaGFuZ2U6JycsXG4gICAgICAgICAgICBzdGF0dXM6IHRydWUsXG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLy8gY3VzdG9tIG1ldGhvZHNcbiAgICBtZXRob2RzOiB7XG4gICAgICAgIGFzeW5jIHVwZGF0ZVRpY2tlcih0aWNrKSB7XG4gICAgICAgICAgICB0aGlzLnRpY2tFbGVtZW50cyA9ICQoJy5sYXN0X3ByaWNlJylcbiAgICAgICAgICAgIHRoaXMudGlja0ljb25zID0gJCgnLmxhc3RfcHJpY2UtaWNvbicpXG4gICAgICAgICAgICBjb25zdCB0aWNrRWxlbWVudCA9IHRoaXMudGlja0VsZW1lbnRzXG4gICAgICAgICAgICBjb25zdCB0aWNrSWNvbiA9IHRoaXMudGlja0ljb25zXG4gICAgICAgICAgICBpZiAoIXRoaXMubGFzdF9wcmljZSB8fCB0aWNrWydsYXN0J10gPiB0aGlzLmxhc3RfcHJpY2UpIHtcbiAgICAgICAgICAgICAgICB0aWNrRWxlbWVudC50ZXh0KHRpY2tbJ2xhc3QnXSlcbiAgICAgICAgICAgICAgICB0aWNrRWxlbWVudC50b2dnbGVDbGFzcygndGV4dC1zdWNjZXNzJylcbiAgICAgICAgICAgICAgICB0aWNrSWNvbi50b2dnbGVDbGFzcygnYmktYXJyb3ctdXAgdGV4dC1zdWNjZXNzJylcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodGlja1snbGFzdCddIDwgdGhpcy5sYXN0X3ByaWNlKSB7XG4gICAgICAgICAgICAgICAgdGlja0VsZW1lbnQudGV4dCh0aWNrWydsYXN0J10pXG4gICAgICAgICAgICAgICAgdGlja0VsZW1lbnQudG9nZ2xlQ2xhc3MoJ3RleHQtZGFuZ2VyJylcbiAgICAgICAgICAgICAgICB0aWNrSWNvbi50b2dnbGVDbGFzcygnYmktYXJyb3ctZG93biB0ZXh0LWRhbmdlcicpXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmxhc3RfcHJpY2UgPSB0aWNrWydsYXN0J107XG5cbiAgICAgICAgICAgIGlmKHRoaXMucHJvdmlkZSAhPSAnY29pbmJhc2Vwcm8nKXtcbiAgICAgICAgICAgICAgICB0aGlzLnBlcmNlbnRhZ2VFbGVtZW50cyA9ICQoJy5kYXlfY2hhbmdlJylcbiAgICAgICAgICAgICAgICB0aGlzLnBlcmNlbnRhZ2VJY29ucyA9ICQoJy5kYXlfY2hhbmdlLWljb24nKVxuICAgICAgICAgICAgICAgIGNvbnN0IHBlcmNlbnRhZ2VFbGVtZW50ID0gdGhpcy5wZXJjZW50YWdlRWxlbWVudHNcbiAgICAgICAgICAgICAgICBjb25zdCBwZXJjZW50YWdlSWNvbiA9IHRoaXMucGVyY2VudGFnZUljb25zXG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLmRheV9jaGFuZ2UgfHwgdGlja1sncGVyY2VudGFnZSddID4gdGhpcy5kYXlfY2hhbmdlKSB7XG4gICAgICAgICAgICAgICAgICAgIHBlcmNlbnRhZ2VFbGVtZW50LnRleHQodGlja1sncGVyY2VudGFnZSddKyclJylcbiAgICAgICAgICAgICAgICAgICAgcGVyY2VudGFnZUVsZW1lbnQudG9nZ2xlQ2xhc3MoJ3RleHQtc3VjY2VzcycpXG4gICAgICAgICAgICAgICAgICAgIHBlcmNlbnRhZ2VJY29uLnRvZ2dsZUNsYXNzKCdiaS1hcnJvdy11cCB0ZXh0LXN1Y2Nlc3MnKVxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAodGlja1sncGVyY2VudGFnZSddIDwgdGhpcy5kYXlfY2hhbmdlKSB7XG4gICAgICAgICAgICAgICAgICAgIHBlcmNlbnRhZ2VFbGVtZW50LnRleHQodGlja1sncGVyY2VudGFnZSddKyclJylcbiAgICAgICAgICAgICAgICAgICAgcGVyY2VudGFnZUVsZW1lbnQudG9nZ2xlQ2xhc3MoJ3RleHQtZGFuZ2VyJylcbiAgICAgICAgICAgICAgICAgICAgcGVyY2VudGFnZUljb24udG9nZ2xlQ2xhc3MoJ2JpLWFycm93LWRvd24gdGV4dC1kYW5nZXInKVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLmRheV9jaGFuZ2UgPSB0aWNrWydwZXJjZW50YWdlJ107XG4gICAgICAgICAgICAgICAgdGhpcy5kYXlfdm9sdW1lX2N1cnJlbmN5cyA9ICQoJy5kYXlfdm9sdW1lX2N1cnJlbmN5JylcbiAgICAgICAgICAgICAgICBjb25zdCBkYXlfdm9sdW1lX2N1cnJlbmN5ID0gdGhpcy5kYXlfdm9sdW1lX2N1cnJlbmN5c1xuICAgICAgICAgICAgICAgIGRheV92b2x1bWVfY3VycmVuY3kudGV4dChuZXcgSW50bC5OdW1iZXJGb3JtYXQoKS5mb3JtYXQodGlja1sncXVvdGVWb2x1bWUnXSkpXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRoaXMuZGF5X2hpZ2hzID0gJCgnLmRheV9oaWdoJylcbiAgICAgICAgICAgIGNvbnN0IGRheV9oaWdoID0gdGhpcy5kYXlfaGlnaHNcbiAgICAgICAgICAgIGRheV9oaWdoLnRleHQodGhpcy5mb3JtYXRQcmljZSh0aWNrWydoaWdoJ10pKVxuXG4gICAgICAgICAgICB0aGlzLmRheV9sb3dzID0gJCgnLmRheV9sb3cnKVxuICAgICAgICAgICAgY29uc3QgZGF5X2xvdyA9IHRoaXMuZGF5X2xvd3NcbiAgICAgICAgICAgIGRheV9sb3cudGV4dCh0aGlzLmZvcm1hdFByaWNlKHRpY2tbJ2xvdyddKSlcblxuICAgICAgICAgICAgdGhpcy5kYXlfdm9sdW1lX3BhaXJzID0gJCgnLmRheV92b2x1bWVfcGFpcicpXG4gICAgICAgICAgICBjb25zdCBkYXlfdm9sdW1lX3BhaXIgPSB0aGlzLmRheV92b2x1bWVfcGFpcnNcbiAgICAgICAgICAgIGRheV92b2x1bWVfcGFpci50ZXh0KG5ldyBJbnRsLk51bWJlckZvcm1hdCgpLmZvcm1hdCh0aWNrWydiYXNlVm9sdW1lJ10pKVxuICAgICAgICB9LFxuXG4gICAgICAgIGFzeW5jIGxvb3BUaWNrZXIoKSB7XG4gICAgICAgICAgICB3aGlsZSAodGhpcy5zdGF0dXMgPT0gdHJ1ZSkge1xuICAgICAgICAgICAgICAgIGlmIChkb2N1bWVudC5oaWRkZW4pIHtcbiAgICAgICAgICAgICAgICAgICAgYXdhaXQgY2N4dC5zbGVlcCgxMDAwKVxuICAgICAgICAgICAgICAgICAgICBjb250aW51ZVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB0aWNrZXIgPSBhd2FpdCBleGNoYW5nZS53YXRjaFRpY2tlcih0aGlzLnN5bWJvbCsnLycrdGhpcy5jdXJyZW5jeSlcbiAgICAgICAgICAgICAgICAgICAgdGhpcy51cGRhdGVUaWNrZXIodGlja2VyKVxuICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgZm9ybWF0UHJpY2UgKHByaWNlKSB7XG4gICAgICAgICAgICByZXR1cm4gY2N4dC5kZWNpbWFsVG9QcmVjaXNpb24gKHByaWNlLCBjY3h0LlJPVU5ELCA5LCBjY3h0LlNJR05JRklDQU5UX0RJR0lUUywgY2N4dC5QQURfV0lUSF9aRVJPKVxuICAgICAgICB9LFxuICAgICAgICBhc3luYyB3c0Nsb3NlKCl7XG4gICAgICAgICAgICB0aGlzLnN0YXR1cyA9IGZhbHNlXG4gICAgICAgICAgICBhd2FpdCBleGNoYW5nZS5jbG9zZSgpXG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLy8gb24gY29tcG9uZW50IGNyZWF0ZWRcbiAgICBjcmVhdGVkKCkge1xuICAgIH0sXG5cbiAgICAvLyBvbiBjb21wb25lbnQgbW91bnRlZFxuICAgIG1vdW50ZWQoKSB7XG4gICAgICAgIHRoaXMubG9vcFRpY2tlcigpXG4gICAgfSxcblxuICAgIC8vIG9uIGNvbXBvbmVudCBkZXN0cm95ZWRcbiAgICBkZXN0cm95ZWQoKSB7fSxcbn1cbjwvc2NyaXB0PlxuIiwiPHRlbXBsYXRlPlxuICAgIDxkaXY+XG4gICAgICAgIDxkaXYgY2xhc3M9XCJkLWZsZXgganVzdGlmeS1jb250ZW50LWJldHdlZW4gYWxpZ24taXRlbXMtY2VudGVyXCI+XG4gICAgICAgICAgICA8YnV0dG9uIGNsYXNzPVwiYnRuIGJ0bi1pY29uXCIgc3R5bGU9XCJwb3NpdGlvbjogcmVsYXRpdmU7IHRvcDogLTVweFwiPlxuICAgICAgICAgICAgICAgIDxpXG4gICAgICAgICAgICAgICAgICAgIGNsYXNzPVwiYmkgYmktY2hldnJvbi1sZWZ0IHRleHQtd2FybmluZyBmcy00XCJcbiAgICAgICAgICAgICAgICAgICAgQGNsaWNrLnByZXZlbnQ9XCJzY3JvbGxMZWZ0KClcIlxuICAgICAgICAgICAgICAgID48L2k+XG4gICAgICAgICAgICA8L2J1dHRvbj5cbiAgICAgICAgICAgIDx1bFxuICAgICAgICAgICAgICAgIGNsYXNzPVwibmF2IG5hdi10YWJzIG5mXCJcbiAgICAgICAgICAgICAgICByb2xlPVwidGFibGlzdFwiXG4gICAgICAgICAgICAgICAgc3R5bGU9XCJvdmVyZmxvdy14OiBoaWRkZW5cIlxuICAgICAgICAgICAgPlxuICAgICAgICAgICAgICAgIDxsaSBjbGFzcz1cIm5hdi1pdGVtXCI+XG4gICAgICAgICAgICAgICAgICAgIDxhXG4gICAgICAgICAgICAgICAgICAgICAgICBjbGFzcz1cIm5hdi1saW5rXCJcbiAgICAgICAgICAgICAgICAgICAgICAgIEBjbGljay5wcmV2ZW50PVwic2V0QWN0aXZlKCdmYXYnKVwiXG4gICAgICAgICAgICAgICAgICAgICAgICA6Y2xhc3M9XCJ7IGFjdGl2ZTogaXNBY3RpdmUoJ2ZhdicpIH1cIlxuICAgICAgICAgICAgICAgICAgICAgICAgaHJlZj1cIiNmYXZcIlxuICAgICAgICAgICAgICAgICAgICAgICAgPjxpIGNsYXNzPVwiYmkgYmktc3RhclwiPjwvaVxuICAgICAgICAgICAgICAgICAgICA+PC9hPlxuICAgICAgICAgICAgICAgIDwvbGk+XG4gICAgICAgICAgICAgICAgPGxpXG4gICAgICAgICAgICAgICAgICAgIGNsYXNzPVwibmF2LWl0ZW1cIlxuICAgICAgICAgICAgICAgICAgICB2LWZvcj1cIihwYWlyLCBpbmRleCkgaW4gcGFpcnNcIlxuICAgICAgICAgICAgICAgICAgICA6a2V5PVwiaW5kZXhcIlxuICAgICAgICAgICAgICAgID5cbiAgICAgICAgICAgICAgICAgICAgPGFcbiAgICAgICAgICAgICAgICAgICAgICAgIGNsYXNzPVwibmF2LWxpbmtcIlxuICAgICAgICAgICAgICAgICAgICAgICAgQGNsaWNrLnByZXZlbnQ9XCJzZXRBY3RpdmUocGFpcilcIlxuICAgICAgICAgICAgICAgICAgICAgICAgOmNsYXNzPVwieyBhY3RpdmU6IGlzQWN0aXZlKHBhaXIpIH1cIlxuICAgICAgICAgICAgICAgICAgICAgICAgaHJlZj1cIiNwcm9maWxlXCJcbiAgICAgICAgICAgICAgICAgICAgICAgID57eyBwYWlyIH19PC9hXG4gICAgICAgICAgICAgICAgICAgID5cbiAgICAgICAgICAgICAgICA8L2xpPlxuICAgICAgICAgICAgPC91bD5cbiAgICAgICAgICAgIDxidXR0b24gY2xhc3M9XCJidG4gYnRuLWljb25cIiBzdHlsZT1cInBvc2l0aW9uOiByZWxhdGl2ZTsgdG9wOiAtNXB4XCI+XG4gICAgICAgICAgICAgICAgPGlcbiAgICAgICAgICAgICAgICAgICAgY2xhc3M9XCJiaSBiaS1jaGV2cm9uLXJpZ2h0IHRleHQtd2FybmluZyBmcy00XCJcbiAgICAgICAgICAgICAgICAgICAgQGNsaWNrLnByZXZlbnQ9XCJzY3JvbGxSaWdodCgpXCJcbiAgICAgICAgICAgICAgICA+PC9pPlxuICAgICAgICAgICAgPC9idXR0b24+XG4gICAgICAgIDwvZGl2PlxuICAgICAgICA8ZGl2IGNsYXNzPVwidGFiLWNvbnRlbnRcIiBpZD1cIm15VGFiQ29udGVudFwiPlxuICAgICAgICAgICAgPGRpdlxuICAgICAgICAgICAgICAgIGNsYXNzPVwidGFiLXBhbmUgZmFkZVwiXG4gICAgICAgICAgICAgICAgOmNsYXNzPVwieyAnYWN0aXZlIHNob3cnOiBpc0FjdGl2ZSgnZmF2JykgfVwiXG4gICAgICAgICAgICAgICAgaWQ9XCJmYXZcIlxuICAgICAgICAgICAgPlxuICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJyb3dcIj5cbiAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cImNvbC0xMiBjYXJkLXNlYXJjaCBjdXN0b20tZGF0YS1zZWFyY2hcIj5cbiAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJpbnB1dC1ncm91cCBpbnB1dC1ncm91cC1zbSBweC0xIG1iLTFcIj5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8c3BhblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjbGFzcz1cImlucHV0LWdyb3VwLXRleHQgdGV4dC1kYXJrIGJvcmRlci0wXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWQ9XCJiYXNpYy1hZGRvbjFcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA+PGkgY2xhc3M9XCJiaSBiaS1zZWFyY2hcIj48L2lcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA+PC9zcGFuPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxpbnB1dFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlPVwidGV4dFwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU9XCJzZWFyY2hfdGFibGVfZmF2XCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2xhc3M9XCJmb3JtLWNvbnRyb2wgZm9ybS1jb250cm9sLXNtIHRleHQtZGFyayBib3JkZXItMFwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBsYWNlaG9sZGVyPVwiU2VhcmNoLi4uXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvPlxuICAgICAgICAgICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgICAgIDx0YWJsZVxuICAgICAgICAgICAgICAgICAgICBjbGFzcz1cInRhYmxlIHRleHQtZGFyayB0YWJsZS1zbSB0YWJsZS1ib3JkZXJsZXNzIHRhYmxlRml4SGVhZCBjdXN0b20tZGF0YS10YWJsZS1mYXZcIlxuICAgICAgICAgICAgICAgID5cbiAgICAgICAgICAgICAgICAgICAgPHRoZWFkIGNsYXNzPVwidGV4dC1tdXRlZFwiPlxuICAgICAgICAgICAgICAgICAgICAgICAgPHRoIHNjb3BlPVwiY29sXCI+UGFpcjwvdGg+XG4gICAgICAgICAgICAgICAgICAgICAgICA8dGggY2xhc3M9XCJkLWxnLW5vbmUgZC14bC1ibG9ja1wiIHNjb3BlPVwiY29sXCI+Q2hhbmdlPC90aD5cbiAgICAgICAgICAgICAgICAgICAgICAgIDx0aCBzY29wZT1cImNvbFwiPlByaWNlPC90aD5cbiAgICAgICAgICAgICAgICAgICAgPC90aGVhZD5cbiAgICAgICAgICAgICAgICAgICAgPHRib2R5PlxuICAgICAgICAgICAgICAgICAgICAgICAgPHRyIHYtZm9yPVwiKGZhdiwgaW5kZXgpIGluIGZhdnNcIiA6a2V5PVwiaW5kZXhcIj5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8dGQ+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJkLWZsZXgganVzdGlmeS1jb250ZW50LXN0YXJ0XCI+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8Zm9ybVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIEBzdWJtaXQucHJldmVudD1cIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZW1vdmVGcm9tV2F0Y2hsaXN0KGZhdi5pZClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxidXR0b25cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZT1cInN1Ym1pdFwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNsYXNzPVwid2F0Y2hsaXN0ZWRcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdHlsZT1cIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYmFja2dyb3VuZDogdHJhbnNwYXJlbnQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBib3JkZXI6IHRyYW5zcGFyZW50O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPGlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNsYXNzPVwibWUtMSB0ZXh0LXdhcm5pbmcgYmkgYmktc3Rhci1maWxsXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPjwvaT5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L2J1dHRvbj5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvZm9ybT5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxyb3V0ZXItbGlua1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDp0bz1cIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnLi4vJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZhdi5jdXJyZW5jeSArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICcvJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZhdi5wYWlyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8c3BhbiBjbGFzcz1cInRleHQtZGFyayBmdy1ib2xkXCI+e3tcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZmF2LmN1cnJlbmN5XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfX08L3NwYW5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA+LzxzcGFuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNsYXNzPVwidGV4dC1zZWNvbmRhcnkgZnctYm9sZFwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID57eyBmYXYucGFpciB9fTwvc3BhblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvcm91dGVyLWxpbms+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvdGQ+XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8dGQgY2xhc3M9XCJkLWxnLW5vbmUgZC14bC1ibG9ja1wiPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8c3BhblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgOmNsYXNzPVwiJ2NoYW5nZS0nICsgZmF2LmN1cnJlbmN5ICsgZmF2LnBhaXJcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA+PC9zcGFuPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvdGQ+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPHRkPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8c3BhblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgOmNsYXNzPVwiJ3RpYy0nICsgZmF2LmN1cnJlbmN5ICsgZmF2LnBhaXJcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA+PC9zcGFuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID48aVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgOmNsYXNzPVwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ3RpYy0nICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmYXYuY3VycmVuY3kgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZhdi5wYWlyICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnLWljb24gYmknXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA+PC9pPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvdGQ+XG4gICAgICAgICAgICAgICAgICAgICAgICA8L3RyPlxuICAgICAgICAgICAgICAgICAgICA8L3Rib2R5PlxuICAgICAgICAgICAgICAgIDwvdGFibGU+XG4gICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgIDxkaXZcbiAgICAgICAgICAgICAgICBjbGFzcz1cInRhYi1wYW5lIGZhZGVcIlxuICAgICAgICAgICAgICAgIHYtZm9yPVwiKG1hcmssIGluZGV4KSBpbiBtYXJrZXRzXCJcbiAgICAgICAgICAgICAgICA6a2V5PVwiaW5kZXhcIlxuICAgICAgICAgICAgICAgIDpjbGFzcz1cInsgJ2FjdGl2ZSBzaG93JzogaXNBY3RpdmUoaW5kZXgpIH1cIlxuICAgICAgICAgICAgICAgIDppZD1cInsgaW5kZXggfVwiXG4gICAgICAgICAgICA+XG4gICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cInJvd1wiPlxuICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVwiY29sLTEyIGNhcmQtc2VhcmNoIGN1c3RvbS1kYXRhLXNlYXJjaFwiPlxuICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cImlucHV0LWdyb3VwIGlucHV0LWdyb3VwLXNtIHB4LTEgbWItMVwiPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxzcGFuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNsYXNzPVwiaW5wdXQtZ3JvdXAtdGV4dCB0ZXh0LWRhcmsgYm9yZGVyLTBcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZD1cImJhc2ljLWFkZG9uMVwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID48aSBjbGFzcz1cImJpIGJpLXNlYXJjaFwiPjwvaVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgID48L3NwYW4+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPGlucHV0XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU9XCJ0ZXh0XCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmFtZT1cInNlYXJjaF90YWJsZVwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNsYXNzPVwiZm9ybS1jb250cm9sIGZvcm0tY29udHJvbC1zbSB0ZXh0LWRhcmsgYm9yZGVyLTBcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwbGFjZWhvbGRlcj1cIlNlYXJjaC4uLlwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLz5cbiAgICAgICAgICAgICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgICAgICA8dGFibGVcbiAgICAgICAgICAgICAgICAgICAgY2xhc3M9XCJ0YWJsZSB0ZXh0LWRhcmsgdGFibGUtc20gdGFibGUtYm9yZGVybGVzcyB0YWJsZUZpeEhlYWRcIlxuICAgICAgICAgICAgICAgICAgICA6Y2xhc3M9XCInY3VzdG9tLWRhdGEtdGFibGUtJyArIGluZGV4XCJcbiAgICAgICAgICAgICAgICA+XG4gICAgICAgICAgICAgICAgICAgIDx0aGVhZCBjbGFzcz1cInRleHQtbXV0ZWRcIj5cbiAgICAgICAgICAgICAgICAgICAgICAgIDx0aCBzY29wZT1cImNvbFwiPlBhaXI8L3RoPlxuICAgICAgICAgICAgICAgICAgICA8L3RoZWFkPlxuICAgICAgICAgICAgICAgICAgICA8dGJvZHk+XG4gICAgICAgICAgICAgICAgICAgICAgICA8dHIgdi1mb3I9XCIobWFya2V0LCBpbmRleCkgaW4gbWFya1wiIDprZXk9XCJpbmRleFwiPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDx0ZD5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cImQtZmxleCBqdXN0aWZ5LWNvbnRlbnQtc3RhcnRcIj5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxmb3JtXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgQHN1Ym1pdC5wcmV2ZW50PVwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFkZFRvV2F0Y2hsaXN0KFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWFya2V0LmN1cnJlbmN5LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWFya2V0LnBhaXJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPGJ1dHRvblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlPVwic3VibWl0XCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2xhc3M9XCJub3Qtd2F0Y2hsaXN0ZWRcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdHlsZT1cIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYmFja2dyb3VuZDogdHJhbnNwYXJlbnQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBib3JkZXI6IHRyYW5zcGFyZW50O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPGlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNsYXNzPVwibWUtMSB0ZXh0LXNlY29uZGFyeSBiaSBiaS1zdGFyXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPjwvaT5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L2J1dHRvbj5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvZm9ybT5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxyb3V0ZXItbGlua1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDp0bz1cIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnLi4vJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1hcmtldC5jdXJyZW5jeSArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICcvJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1hcmtldC5wYWlyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8c3BhbiBjbGFzcz1cInRleHQtZGFyayBmdy1ib2xkXCI+e3tcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWFya2V0LmN1cnJlbmN5XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfX08L3NwYW5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA+LzxzcGFuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNsYXNzPVwidGV4dC1zZWNvbmRhcnkgZnctYm9sZFwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID57eyBtYXJrZXQucGFpciB9fTwvc3BhblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvcm91dGVyLWxpbms+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvdGQ+XG4gICAgICAgICAgICAgICAgICAgICAgICA8L3RyPlxuICAgICAgICAgICAgICAgICAgICA8L3Rib2R5PlxuICAgICAgICAgICAgICAgIDwvdGFibGU+XG4gICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgPC9kaXY+XG4gICAgPC9kaXY+XG48L3RlbXBsYXRlPlxuXG48c2NyaXB0PlxuLy8gY29tcG9uZW50XG5leHBvcnQgZGVmYXVsdCB7XG4gICAgcHJvcHM6IFtcInBhaXJzXCIsIFwicHJvdmlkZXJcIl0sXG4gICAgLy8gY29tcG9uZW50IGxpc3RcbiAgICBjb21wb25lbnRzOiB7fSxcblxuICAgIC8vIGNvbXBvbmVudCBkYXRhXG4gICAgZGF0YSgpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGZhdnM6IFtdLFxuICAgICAgICAgICAgb2xkOiBbXSxcbiAgICAgICAgICAgIG1hcmtldHM6IFtdLFxuICAgICAgICAgICAgYWN0aXZlSXRlbTogXCJmYXZcIixcbiAgICAgICAgICAgIHN0YXR1czogdHJ1ZSxcbiAgICAgICAgfTtcbiAgICB9LFxuICAgIGNvbXB1dGVkOiB7fSxcblxuICAgIC8vIGN1c3RvbSBtZXRob2RzXG4gICAgbWV0aG9kczoge1xuICAgICAgICBmZXRjaE1hcmtldHMoKSB7XG4gICAgICAgICAgICB0aGlzLiRodHRwLnBvc3QoXCIvZGF0YS9tYXJrZXRzL21hcmtldHMuanNvblwiKS50aGVuKChyZXNwb25zZSkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMubWFya2V0cyA9IHJlc3BvbnNlLmRhdGFbdGhpcy5wcm92aWRlcl07XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSxcbiAgICAgICAgZmV0Y2hGYXZzKCkge1xuICAgICAgICAgICAgdGhpcy4kaHR0cC5wb3N0KFwiL3VzZXIvd2F0Y2hsaXN0L2RhdGFcIikudGhlbigocmVzcG9uc2UpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLmZhdnMgPSByZXNwb25zZS5kYXRhLmZhdnM7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSxcbiAgICAgICAgaXNBY3RpdmUobWVudUl0ZW0pIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmFjdGl2ZUl0ZW0gPT09IG1lbnVJdGVtO1xuICAgICAgICB9LFxuICAgICAgICBzZXRBY3RpdmUobWVudUl0ZW0pIHtcbiAgICAgICAgICAgIHRoaXMuYWN0aXZlSXRlbSA9IG1lbnVJdGVtO1xuICAgICAgICB9LFxuICAgICAgICBzY3JvbGxMZWZ0KCkge1xuICAgICAgICAgICAgdmFyIGxlZnRQb3MgPSAkKFwiLm5mXCIpLnNjcm9sbExlZnQoKTtcbiAgICAgICAgICAgICQoXCIubmZcIikuYW5pbWF0ZSh7IHNjcm9sbExlZnQ6IGxlZnRQb3MgLSAyMDAgfSwgODAwKTtcbiAgICAgICAgfSxcbiAgICAgICAgc2Nyb2xsUmlnaHQoKSB7XG4gICAgICAgICAgICB2YXIgbGVmdFBvcyA9ICQoXCIubmZcIikuc2Nyb2xsTGVmdCgpO1xuICAgICAgICAgICAgJChcIi5uZlwiKS5hbmltYXRlKHsgc2Nyb2xsTGVmdDogbGVmdFBvcyArIDIwMCB9LCA4MDApO1xuICAgICAgICB9LFxuICAgICAgICBhZGRUb1dhdGNobGlzdChjdXJyZW5jeSwgcGFpcikge1xuICAgICAgICAgICAgdGhpcy4kaHR0cFxuICAgICAgICAgICAgICAgIC5wb3N0KFwiL3VzZXIvd2F0Y2hsaXN0L3N0b3JlXCIsIHtcbiAgICAgICAgICAgICAgICAgICAgY3VycmVuY3k6IGN1cnJlbmN5LFxuICAgICAgICAgICAgICAgICAgICBwYWlyOiBwYWlyLFxuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgLnRoZW4oKHJlc3BvbnNlKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuJHRvYXN0W3Jlc3BvbnNlLmRhdGEudHlwZV0ocmVzcG9uc2UuZGF0YS5tZXNzYWdlKTtcbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIC5jYXRjaCgoZXJyb3IpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy4kdG9hc3QuZXJyb3IoZXJyb3IucmVzcG9uc2UuZGF0YSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgIH0sXG4gICAgICAgIHJlbW92ZUZyb21XYXRjaGxpc3QoaWQpIHtcbiAgICAgICAgICAgIHRoaXMuJGh0dHBcbiAgICAgICAgICAgICAgICAucG9zdChcIi91c2VyL3dhdGNobGlzdC9kZWxldGVcIiwge1xuICAgICAgICAgICAgICAgICAgICBpZDogaWQsXG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAudGhlbigocmVzcG9uc2UpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy4kdG9hc3Quc3VjY2VzcyhyZXNwb25zZS5kYXRhLm1lc3NhZ2UpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmZldGNoRmF2cygpO1xuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgLmNhdGNoKChlcnJvcikgPT4ge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLiR0b2FzdC5lcnJvcihcIk1hcmtldCBBbHJlYWR5IFJlbW92ZWQgRnJvbSBXYXRjaGxpc3RcIik7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgIH0sXG4gICAgICAgIGhhbmRsZSh0aWNrZXJzKSB7XG4gICAgICAgICAgICB0aGlzLnRpY2tlckVsZW1lbnRzID0gdGhpcy50aWNrZXJFbGVtZW50cyB8fCB7fTtcbiAgICAgICAgICAgIHRoaXMudGlja2VySWNvbnMgPSB0aGlzLnRpY2tlckljb25zIHx8IHt9O1xuICAgICAgICAgICAgdGhpcy5jaGFuZ2VFbGVtZW50cyA9IHRoaXMuY2hhbmdlRWxlbWVudHMgfHwge307XG4gICAgICAgICAgICBmb3IgKGNvbnN0IFtzeW1ib2wsIHRpY2tlcl0gb2YgT2JqZWN0LmVudHJpZXModGlja2VycykpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBzeW1ib2xXaXRob3V0U2xhc2ggPSBzeW1ib2wucmVwbGFjZShcIi9cIiwgXCJcIik7XG4gICAgICAgICAgICAgICAgaWYgKCEoc3ltYm9sIGluIHRoaXMudGlja2VyRWxlbWVudHMpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMudGlja2VyRWxlbWVudHNbc3ltYm9sXSA9ICQoXG4gICAgICAgICAgICAgICAgICAgICAgICBcIi50aWMtXCIgKyBzeW1ib2xXaXRob3V0U2xhc2hcbiAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKCEoc3ltYm9sIGluIHRoaXMudGlja2VySWNvbnMpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMudGlja2VySWNvbnNbc3ltYm9sXSA9ICQoXG4gICAgICAgICAgICAgICAgICAgICAgICBcIi50aWMtXCIgKyBzeW1ib2xXaXRob3V0U2xhc2ggKyBcIi1pY29uXCJcbiAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3QgdGlja2VyRWxlbWVudCA9IHRoaXMudGlja2VyRWxlbWVudHNbc3ltYm9sXTtcbiAgICAgICAgICAgICAgICBjb25zdCB0aWNrZXJJY29uID0gdGhpcy50aWNrZXJJY29uc1tzeW1ib2xdO1xuICAgICAgICAgICAgICAgIGlmICghdGhpcy5vbGRbc3ltYm9sXSB8fCB0aWNrZXJbXCJsYXN0XCJdID4gdGhpcy5vbGRbc3ltYm9sXSkge1xuICAgICAgICAgICAgICAgICAgICB0aWNrZXJFbGVtZW50LnRleHQodGlja2VyW1wibGFzdFwiXSk7XG4gICAgICAgICAgICAgICAgICAgIHRpY2tlckVsZW1lbnQudG9nZ2xlQ2xhc3MoXCJ0ZXh0LXN1Y2Nlc3NcIik7XG4gICAgICAgICAgICAgICAgICAgIHRpY2tlckljb24udG9nZ2xlQ2xhc3MoXCJiaS1hcnJvdy11cCB0ZXh0LXN1Y2Nlc3NcIik7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmICh0aWNrZXJbXCJsYXN0XCJdIDwgdGhpcy5vbGRbc3ltYm9sXSkge1xuICAgICAgICAgICAgICAgICAgICB0aWNrZXJFbGVtZW50LnRleHQodGlja2VyW1wibGFzdFwiXSk7XG4gICAgICAgICAgICAgICAgICAgIHRpY2tlckVsZW1lbnQudG9nZ2xlQ2xhc3MoXCJ0ZXh0LWRhbmdlclwiKTtcbiAgICAgICAgICAgICAgICAgICAgdGlja2VySWNvbi50b2dnbGVDbGFzcyhcImJpLWFycm93LWRvd24gdGV4dC1kYW5nZXJcIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMub2xkW3N5bWJvbF0gPSB0aWNrZXJbXCJsYXN0XCJdO1xuICAgICAgICAgICAgICAgIGlmICghKHN5bWJvbCBpbiB0aGlzLmNoYW5nZUVsZW1lbnRzKSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmNoYW5nZUVsZW1lbnRzW3N5bWJvbF0gPSAkKFxuICAgICAgICAgICAgICAgICAgICAgICAgXCIuY2hhbmdlLVwiICsgc3ltYm9sV2l0aG91dFNsYXNoXG4gICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IGNoYW5nZUVsZW1lbnQgPSB0aGlzLmNoYW5nZUVsZW1lbnRzW3N5bWJvbF07XG4gICAgICAgICAgICAgICAgaWYgKHRpY2tlcltcImNoYW5nZVwiXSA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgY2hhbmdlRWxlbWVudC50ZXh0KFxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5mb3JtYXRUb3RhbCh0aWNrZXJbXCJjaGFuZ2VcIl0pICsgXCIlXCJcbiAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgICAgY2hhbmdlRWxlbWVudFxuICAgICAgICAgICAgICAgICAgICAgICAgLmFkZENsYXNzKFwidGV4dC1zdWNjZXNzXCIpXG4gICAgICAgICAgICAgICAgICAgICAgICAucmVtb3ZlQ2xhc3MoXCJ0ZXh0LWRhbmdlclwiKTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHRpY2tlcltcImNoYW5nZVwiXSA8IDApIHtcbiAgICAgICAgICAgICAgICAgICAgY2hhbmdlRWxlbWVudC50ZXh0KFxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5mb3JtYXRUb3RhbCh0aWNrZXJbXCJjaGFuZ2VcIl0pICsgXCIlXCJcbiAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgICAgY2hhbmdlRWxlbWVudFxuICAgICAgICAgICAgICAgICAgICAgICAgLmFkZENsYXNzKFwidGV4dC1kYW5nZXJcIilcbiAgICAgICAgICAgICAgICAgICAgICAgIC5yZW1vdmVDbGFzcyhcInRleHQtc3VjY2Vzc1wiKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBjaGFuZ2VFbGVtZW50LnRleHQoXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmZvcm1hdFRvdGFsKHRpY2tlcltcImNoYW5nZVwiXSkgKyBcIiVcIlxuICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICBhc3luYyBsb29wKCkge1xuICAgICAgICAgICAgd2hpbGUgKHRoaXMuc3RhdHVzID09IHRydWUpIHtcbiAgICAgICAgICAgICAgICBpZiAoZG9jdW1lbnQuaGlkZGVuKSB7XG4gICAgICAgICAgICAgICAgICAgIGF3YWl0IGNjeHQuc2xlZXAoMTAwMCk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB0aWNrZXJzID0gYXdhaXQgZXhjaGFuZ2UuZmV0Y2hUaWNrZXJzKCk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuaGFuZGxlKHRpY2tlcnMpO1xuICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBmb3JtYXRUb3RhbCh0b3RhbCkge1xuICAgICAgICAgICAgcmV0dXJuIGNjeHQuZGVjaW1hbFRvUHJlY2lzaW9uKFxuICAgICAgICAgICAgICAgIHRvdGFsLFxuICAgICAgICAgICAgICAgIGNjeHQuUk9VTkQsXG4gICAgICAgICAgICAgICAgMyxcbiAgICAgICAgICAgICAgICBjY3h0LkRFQ0lNQUxfUExBQ0VTLFxuICAgICAgICAgICAgICAgIGNjeHQuUEFEX1dJVEhfWkVST1xuICAgICAgICAgICAgKTtcbiAgICAgICAgfSxcbiAgICAgICAgYXN5bmMgd3NDbG9zZSgpIHtcbiAgICAgICAgICAgIHRoaXMuc3RhdHVzID0gZmFsc2U7XG4gICAgICAgICAgICBhd2FpdCBleGNoYW5nZS5jbG9zZSgpO1xuICAgICAgICB9LFxuICAgIH0sXG5cbiAgICAvLyBvbiBjb21wb25lbnQgY3JlYXRlZFxuICAgIGNyZWF0ZWQoKSB7XG4gICAgICAgIHRoaXMuZmV0Y2hGYXZzKCk7XG4gICAgICAgIHRoaXMuZmV0Y2hNYXJrZXRzKCk7XG4gICAgfSxcblxuICAgIC8vIG9uIGNvbXBvbmVudCBtb3VudGVkXG4gICAgbW91bnRlZCgpIHtcbiAgICAgICAgdGhpcy5sb29wKCk7XG4gICAgfSxcbiAgICAvLyBvbiBjb21wb25lbnQgbW91bnRlZFxuICAgIGJlZm9yZVVwZGF0ZSgpIHtcbiAgICAgICAgdGhpcy5wYWlycy5mb3JFYWNoKChwYWlyKSA9PiB7XG4gICAgICAgICAgICB2YXIgdHJfZWxlbWVudHMgPSAkKFwiLmN1c3RvbS1kYXRhLXRhYmxlLVwiICsgcGFpciArIFwiIHRib2R5IHRyXCIpO1xuICAgICAgICAgICAgJChkb2N1bWVudCkub24oXCJpbnB1dFwiLCBcImlucHV0W25hbWU9c2VhcmNoX3RhYmxlXVwiLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgdmFyIHNlYXJjaCA9ICQodGhpcykudmFsKCkudG9VcHBlckNhc2UoKTtcbiAgICAgICAgICAgICAgICB2YXIgbWF0Y2ggPSB0cl9lbGVtZW50c1xuICAgICAgICAgICAgICAgICAgICAuZmlsdGVyKGZ1bmN0aW9uIChpZHgsIGVsZW0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAkKGVsZW0pXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLnRleHQoKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC50cmltKClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAudG9VcHBlckNhc2UoKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5pbmRleE9mKHNlYXJjaCkgPj0gMFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgID8gZWxlbVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgICAgLnNvcnQoKTtcbiAgICAgICAgICAgICAgICB2YXIgdGFibGVfY29udGVudCA9ICQoXCIuY3VzdG9tLWRhdGEtdGFibGUtXCIgKyBwYWlyICsgXCIgdGJvZHlcIik7XG4gICAgICAgICAgICAgICAgaWYgKG1hdGNoLmxlbmd0aCA9PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHRhYmxlX2NvbnRlbnQuaHRtbChcbiAgICAgICAgICAgICAgICAgICAgICAgICc8dHI+PHRkIGNvbHNwYW49XCIxMDAlXCIgY2xhc3M9XCJ0ZXh0LWNlbnRlclwiPkRhdGEgTm90IEZvdW5kPC90ZD48L3RyPidcbiAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0YWJsZV9jb250ZW50Lmh0bWwobWF0Y2gpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgICAgdmFyIHRyX2VsZW1lbnRzID0gJChcIi5jdXN0b20tZGF0YS10YWJsZS1mYXYgdGJvZHkgdHJcIik7XG4gICAgICAgICQoZG9jdW1lbnQpLm9uKFwiaW5wdXRcIiwgXCJpbnB1dFtuYW1lPXNlYXJjaF90YWJsZV9mYXZdXCIsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBzZWFyY2ggPSAkKHRoaXMpLnZhbCgpLnRvVXBwZXJDYXNlKCk7XG4gICAgICAgICAgICB2YXIgbWF0Y2ggPSB0cl9lbGVtZW50c1xuICAgICAgICAgICAgICAgIC5maWx0ZXIoZnVuY3Rpb24gKGlkeCwgZWxlbSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gJChlbGVtKVxuICAgICAgICAgICAgICAgICAgICAgICAgLnRleHQoKVxuICAgICAgICAgICAgICAgICAgICAgICAgLnRyaW0oKVxuICAgICAgICAgICAgICAgICAgICAgICAgLnRvVXBwZXJDYXNlKClcbiAgICAgICAgICAgICAgICAgICAgICAgIC5pbmRleE9mKHNlYXJjaCkgPj0gMFxuICAgICAgICAgICAgICAgICAgICAgICAgPyBlbGVtXG4gICAgICAgICAgICAgICAgICAgICAgICA6IG51bGw7XG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAuc29ydCgpO1xuICAgICAgICAgICAgdmFyIHRhYmxlX2NvbnRlbnQgPSAkKFwiLmN1c3RvbS1kYXRhLXRhYmxlLWZhdiB0Ym9keVwiKTtcbiAgICAgICAgICAgIGlmIChtYXRjaC5sZW5ndGggPT0gMCkge1xuICAgICAgICAgICAgICAgIHRhYmxlX2NvbnRlbnQuaHRtbChcbiAgICAgICAgICAgICAgICAgICAgJzx0cj48dGQgY29sc3Bhbj1cIjEwMCVcIiBjbGFzcz1cInRleHQtY2VudGVyXCI+RGF0YSBOb3QgRm91bmQ8L3RkPjwvdHI+J1xuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRhYmxlX2NvbnRlbnQuaHRtbChtYXRjaCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH0sXG4gICAgdW5tb3VudGVkKCkge1xuICAgICAgICB0aGlzLndzQ2xvc2UoKTtcbiAgICB9LFxuICAgIC8vIG9uIGNvbXBvbmVudCBkZXN0cm95ZWRcbiAgICBkZXN0cm95ZWQoKSB7XG4gICAgICAgIHRoaXMud3NDbG9zZSgpO1xuICAgIH0sXG59O1xuPC9zY3JpcHQ+XG48c3R5bGU+XG4ubm90LXdhdGNobGlzdGVkOmhvdmVyIC5iaS1zdGFyIHtcbiAgICBjb2xvcjogcmdiKDI1NSwgMTU5LCA2NykgIWltcG9ydGFudDtcbn1cbi53YXRjaGxpc3RlZDpob3ZlciAuYmktc3Rhci1maWxsIHtcbiAgICBjb2xvcjogcmdiKDEzMCwgMTM0LCAxMzkpICFpbXBvcnRhbnQ7XG59XG48L3N0eWxlPlxuIiwiPHRlbXBsYXRlPlxuICAgIDxkaXYgY2xhc3M9XCIgXCI+XG4gICAgICAgIDxpbnB1dCB0eXBlPVwiaGlkZGVuXCIgaWQ9XCJiZXN0QXNrXCIgLz5cbiAgICAgICAgPGlucHV0IHR5cGU9XCJoaWRkZW5cIiBpZD1cImJlc3RCaWRcIiAvPlxuICAgICAgICA8dWwgY2xhc3M9XCJuYXYgbmF2LXRhYnNcIiBpZD1cInBpbGxzLXRhYlwiIHJvbGU9XCJ0YWJsaXN0XCI+XG4gICAgICAgICAgICA8bGkgY2xhc3M9XCJuYXYtaXRlbVwiPlxuICAgICAgICAgICAgICAgIDxidXR0b25cbiAgICAgICAgICAgICAgICAgICAgY2xhc3M9XCJuYXYtbGlua1wiXG4gICAgICAgICAgICAgICAgICAgIEBjbGljay5wcmV2ZW50PVwic2V0QWN0aXZlKCdwaWxscy1ncmFwaCcpXCJcbiAgICAgICAgICAgICAgICAgICAgOmNsYXNzPVwieyBhY3RpdmU6IGlzQWN0aXZlKCdwaWxscy1ncmFwaCcpIH1cIlxuICAgICAgICAgICAgICAgICAgICBocmVmPVwiI3BpbGxzLWdyYXBoXCJcbiAgICAgICAgICAgICAgICA+XG4gICAgICAgICAgICAgICAgICAgIDxpIGNsYXNzPVwiYmkgYmktZ3JhcGgtdXAgdGV4dC1kYXJrXCI+PC9pPlxuICAgICAgICAgICAgICAgIDwvYnV0dG9uPlxuICAgICAgICAgICAgPC9saT5cbiAgICAgICAgICAgIDxsaSBjbGFzcz1cIm5hdi1pdGVtXCI+XG4gICAgICAgICAgICAgICAgPGJ1dHRvblxuICAgICAgICAgICAgICAgICAgICBjbGFzcz1cIm5hdi1saW5rXCJcbiAgICAgICAgICAgICAgICAgICAgQGNsaWNrLnByZXZlbnQ9XCJzZXRBY3RpdmUoJ3BpbGxzLWdyYXBoLXVwJylcIlxuICAgICAgICAgICAgICAgICAgICA6Y2xhc3M9XCJ7IGFjdGl2ZTogaXNBY3RpdmUoJ3BpbGxzLWdyYXBoLXVwJykgfVwiXG4gICAgICAgICAgICAgICAgICAgIGhyZWY9XCIjcGlsbHMtZ3JhcGgtdXBcIlxuICAgICAgICAgICAgICAgID5cbiAgICAgICAgICAgICAgICAgICAgPGkgY2xhc3M9XCJiaSBiaS1ncmFwaC11cC1hcnJvdyB0ZXh0LXN1Y2Nlc3NcIj48L2k+XG4gICAgICAgICAgICAgICAgPC9idXR0b24+XG4gICAgICAgICAgICA8L2xpPlxuICAgICAgICAgICAgPGxpIGNsYXNzPVwibmF2LWl0ZW1cIj5cbiAgICAgICAgICAgICAgICA8YnV0dG9uXG4gICAgICAgICAgICAgICAgICAgIGNsYXNzPVwibmF2LWxpbmtcIlxuICAgICAgICAgICAgICAgICAgICBAY2xpY2sucHJldmVudD1cInNldEFjdGl2ZSgncGlsbHMtZ3JhcGgtZG93bicpXCJcbiAgICAgICAgICAgICAgICAgICAgOmNsYXNzPVwieyBhY3RpdmU6IGlzQWN0aXZlKCdwaWxscy1ncmFwaC1kb3duJykgfVwiXG4gICAgICAgICAgICAgICAgICAgIGhyZWY9XCIjcGlsbHMtZ3JhcGgtZG93blwiXG4gICAgICAgICAgICAgICAgPlxuICAgICAgICAgICAgICAgICAgICA8aSBjbGFzcz1cImJpIGJpLWdyYXBoLWRvd24tYXJyb3cgdGV4dC1kYW5nZXJcIj48L2k+XG4gICAgICAgICAgICAgICAgPC9idXR0b24+XG4gICAgICAgICAgICA8L2xpPlxuICAgICAgICA8L3VsPlxuICAgICAgICA8ZGl2IGNsYXNzPVwidGFiLWNvbnRlbnRcIiBpZD1cInBpbGxzLWdyYXBoLXRhYkNvbnRlbnRcIj5cbiAgICAgICAgICAgIDxkaXZcbiAgICAgICAgICAgICAgICBjbGFzcz1cInRhYi1wYW5lIGZhZGVcIlxuICAgICAgICAgICAgICAgIDpjbGFzcz1cInsgJ2FjdGl2ZSBzaG93JzogaXNBY3RpdmUoJ3BpbGxzLWdyYXBoJykgfVwiXG4gICAgICAgICAgICAgICAgaWQ9XCJwaWxscy1ncmFwaFwiXG4gICAgICAgICAgICAgICAgcm9sZT1cInRhYnBhbmVsXCJcbiAgICAgICAgICAgICAgICBhcmlhLWxhYmVsbGVkYnk9XCJwaWxscy1ncmFwaC10YWJcIlxuICAgICAgICAgICAgPlxuICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJ0YWJsZS1yZXNwb25zaXZlXCI+XG4gICAgICAgICAgICAgICAgICAgIDx0YWJsZVxuICAgICAgICAgICAgICAgICAgICAgICAgY2xhc3M9XCJ0YWJsZSB0ZXh0LWRhcmsgdGFibGUtc20gdGFibGUtYm9yZGVybGVzc1wiXG4gICAgICAgICAgICAgICAgICAgICAgICBzdHlsZT1cIm92ZXJmbG93LXg6IGhpZGRlblwiXG4gICAgICAgICAgICAgICAgICAgID5cbiAgICAgICAgICAgICAgICAgICAgICAgIDx0aGVhZCBjbGFzcz1cInRleHQtbXV0ZWRcIj5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8dGggY2xhc3M9XCJ0ZXh0LXN0YXJ0XCIgc2NvcGU9XCJjb2xcIj5QcmljZTwvdGg+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPHRoIGNsYXNzPVwidGV4dC1zdGFydFwiIHNjb3BlPVwiY29sXCI+QW1vdW50PC90aD5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8dGggY2xhc3M9XCJ0ZXh0LWVuZFwiIHNjb3BlPVwiY29sXCI+VG90YWw8L3RoPlxuICAgICAgICAgICAgICAgICAgICAgICAgPC90aGVhZD5cbiAgICAgICAgICAgICAgICAgICAgPC90YWJsZT5cbiAgICAgICAgICAgICAgICAgICAgPHRhYmxlIGNsYXNzPVwiYXNrc1wiIHN0eWxlPVwibWluLWhlaWdodDogMjgwcHhcIj5cbiAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJvcmRlci1sb2FkZXJcIj5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8ZGl2XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNsYXNzPVwic2UtcHJlLWNvbjIgc3Bpbm5lci1ib3JkZXIgdGV4dC1wcmltYXJ5XCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcm9sZT1cInN0YXR1c1wiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8c3BhbiBjbGFzcz1cInNyLW9ubHlcIj48L3NwYW4+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgICAgICAgICAgPC90YWJsZT5cbiAgICAgICAgICAgICAgICA8L2Rpdj5cblxuICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJ0YWJsZS1yZXNwb25zaXZlIGJvcmRlcmVkLXlcIj5cbiAgICAgICAgICAgICAgICAgICAgPHRhYmxlXG4gICAgICAgICAgICAgICAgICAgICAgICBjbGFzcz1cInRhYmxlIHRleHQtZGFyayB0YWJsZS1zbSB0YWJsZS1ib3JkZXJsZXNzIG15LWF1dG9cIlxuICAgICAgICAgICAgICAgICAgICA+XG4gICAgICAgICAgICAgICAgICAgICAgICA8dGJvZHk+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPHRyPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8dGQgY2xhc3M9XCJ0ZXh0LW11dGVcIj5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxzcGFuIGNsYXNzPVwiZnMtNlwiPkxhc3QgUHJpY2U6IDwvc3Bhbj5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxzcGFuIGNsYXNzPVwiZnMtNiBiZXN0X2Fza1wiPjwvc3BhblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPjxpIGNsYXNzPVwiZnMtNSBiZXN0X2Fza19pY29uIGJpXCI+PC9pPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L3RkPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvdHI+XG4gICAgICAgICAgICAgICAgICAgICAgICA8L3Rib2R5PlxuICAgICAgICAgICAgICAgICAgICA8L3RhYmxlPlxuICAgICAgICAgICAgICAgIDwvZGl2PlxuXG4gICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cInRhYmxlLXJlc3BvbnNpdmVcIj5cbiAgICAgICAgICAgICAgICAgICAgPHRhYmxlIGNsYXNzPVwiYmlkc1wiIHN0eWxlPVwibWluLWhlaWdodDogMjgwcHhcIj5cbiAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJvcmRlci1sb2FkZXJcIiA6a2V5PVwic3ltYm9sICsgY3VycmVuY3lcIj5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8ZGl2XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNsYXNzPVwic2UtcHJlLWNvbjIgc3Bpbm5lci1ib3JkZXIgdGV4dC1wcmltYXJ5XCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcm9sZT1cInN0YXR1c1wiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8c3BhbiBjbGFzcz1cInNyLW9ubHlcIj48L3NwYW4+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgICAgICAgICAgPC90YWJsZT5cbiAgICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgPGRpdlxuICAgICAgICAgICAgICAgIGNsYXNzPVwidGFiLXBhbmUgZmFkZVwiXG4gICAgICAgICAgICAgICAgOmNsYXNzPVwieyAnYWN0aXZlIHNob3cnOiBpc0FjdGl2ZSgncGlsbHMtZ3JhcGgtZG93bicpIH1cIlxuICAgICAgICAgICAgICAgIGlkPVwicGlsbHMtZ3JhcGgtZG93blwiXG4gICAgICAgICAgICAgICAgcm9sZT1cInRhYnBhbmVsXCJcbiAgICAgICAgICAgICAgICBhcmlhLWxhYmVsbGVkYnk9XCJwaWxscy1ncmFwaC1kb3duLXRhYlwiXG4gICAgICAgICAgICA+XG4gICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cInRhYmxlLXJlc3BvbnNpdmVcIj5cbiAgICAgICAgICAgICAgICAgICAgPHRhYmxlIGNsYXNzPVwidGFibGUgdGV4dC1kYXJrIHRhYmxlLXNtIHRhYmxlLWJvcmRlcmxlc3NcIj5cbiAgICAgICAgICAgICAgICAgICAgICAgIDx0aGVhZCBjbGFzcz1cInRleHQtbXV0ZWRcIj5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8dGggc2NvcGU9XCJjb2xcIj5QcmljZTwvdGg+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPHRoIHNjb3BlPVwiY29sXCI+QW1vdW50PC90aD5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8dGggc2NvcGU9XCJjb2xcIj5Ub3RhbDwvdGg+XG4gICAgICAgICAgICAgICAgICAgICAgICA8L3RoZWFkPlxuICAgICAgICAgICAgICAgICAgICA8L3RhYmxlPlxuICAgICAgICAgICAgICAgICAgICA8dGFibGUgY2xhc3M9XCJhc2tzX29ubHlcIj48L3RhYmxlPlxuICAgICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICA8ZGl2XG4gICAgICAgICAgICAgICAgY2xhc3M9XCJ0YWItcGFuZSBmYWRlXCJcbiAgICAgICAgICAgICAgICA6Y2xhc3M9XCJ7ICdhY3RpdmUgc2hvdyc6IGlzQWN0aXZlKCdwaWxscy1ncmFwaC11cCcpIH1cIlxuICAgICAgICAgICAgICAgIGlkPVwicGlsbHMtZ3JhcGgtdXBcIlxuICAgICAgICAgICAgICAgIHJvbGU9XCJ0YWJwYW5lbFwiXG4gICAgICAgICAgICAgICAgYXJpYS1sYWJlbGxlZGJ5PVwicGlsbHMtZ3JhcGgtdXAtdGFiXCJcbiAgICAgICAgICAgID5cbiAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVwidGFibGUtcmVzcG9uc2l2ZVwiPlxuICAgICAgICAgICAgICAgICAgICA8dGFibGUgY2xhc3M9XCJ0YWJsZSB0ZXh0LWRhcmsgdGFibGUtc20gdGFibGUtYm9yZGVybGVzc1wiPlxuICAgICAgICAgICAgICAgICAgICAgICAgPHRoZWFkIGNsYXNzPVwidGV4dC1tdXRlZFwiPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDx0aCBzY29wZT1cImNvbFwiPlByaWNlPC90aD5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8dGggc2NvcGU9XCJjb2xcIj5BbW91bnQ8L3RoPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDx0aCBzY29wZT1cImNvbFwiPlRvdGFsPC90aD5cbiAgICAgICAgICAgICAgICAgICAgICAgIDwvdGhlYWQ+XG4gICAgICAgICAgICAgICAgICAgIDwvdGFibGU+XG4gICAgICAgICAgICAgICAgICAgIDx0YWJsZSBjbGFzcz1cImJpZHNfb25seVwiPjwvdGFibGU+XG4gICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgPC9kaXY+XG4gICAgPC9kaXY+XG48L3RlbXBsYXRlPlxuXG48c2NyaXB0PlxuLy8gY29tcG9uZW50XG52YXIgY29tcHV0QmFyV2lkdGggPSB7XG4gICAgd2lkdGg6IDI1MCxcbiAgICBzb3J0RGVwdGg6IHtcbiAgICAgICAgc29ydDogZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICAgICAgZS5zb3J0KGZ1bmN0aW9uIChlLCB0KSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBlWzFdIC0gdFsxXTtcbiAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgICBlXG4gICAgICAgICAgICApO1xuICAgICAgICB9LFxuICAgICAgICBtZWRpYW46IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICB2YXIgdCA9IE1hdGguZmxvb3IoKGUubGVuZ3RoIC8gMykgKiAyKTtcbiAgICAgICAgICAgIHJldHVybiBlW3RdWzFdIDwgMSA/IDEgOiBlW3RdWzFdO1xuICAgICAgICB9LFxuICAgICAgICBtZWRpYW5Vbml0OiBmdW5jdGlvbiAoZSwgdCwgbikge1xuICAgICAgICAgICAgdmFyIHIgPSBuZXcgQXJyYXkoZSk7XG4gICAgICAgICAgICByID0gclswXTtcbiAgICAgICAgICAgIHZhciBvID0gbmV3IEFycmF5KHQpO1xuICAgICAgICAgICAgKG8gPSBvWzBdKSwgKHIgPSByLmNvbmNhdChvKSk7XG4gICAgICAgICAgICB2YXIgaSA9IHRoaXMubWVkaWFuKHRoaXMuc29ydChyKSkgLyBuO1xuICAgICAgICAgICAgcmV0dXJuIChvID0gciA9IG51bGwpLCBpO1xuICAgICAgICB9LFxuICAgICAgICB3aWR0aDogZnVuY3Rpb24gKGUsIHQpIHtcbiAgICAgICAgICAgIGlmICgwID09IHQpIHJldHVybiAxO1xuICAgICAgICAgICAgdmFyIG4gPSBNYXRoLnJvdW5kKE51bWJlcihlKSAvIHQpO1xuICAgICAgICAgICAgcmV0dXJuIG4gPD0gMCA/IDEgOiAxNjAgPCBuID8gMTYwIDogbjtcbiAgICAgICAgfSxcbiAgICB9LFxuICAgIGluaXQ6IGZ1bmN0aW9uIChlLCB0KSB7XG4gICAgICAgIHZhciBuID0gW10sXG4gICAgICAgICAgICByID0gW107XG4gICAgICAgIGUuZm9yRWFjaChmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgbi5wdXNoKGUpO1xuICAgICAgICB9KSxcbiAgICAgICAgICAgIHQuZm9yRWFjaChmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgICAgIHIucHVzaChlKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB2YXIgbyA9IHRoaXMuc29ydERlcHRoLm1lZGlhblVuaXQobiwgciwgNDgpO1xuICAgICAgICBlLmZvckVhY2goZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgIGUucHVzaCh7XG4gICAgICAgICAgICAgICAgd2lkdGg6XG4gICAgICAgICAgICAgICAgICAgIChjb21wdXRCYXJXaWR0aC5zb3J0RGVwdGgud2lkdGgoZVsxXSwgbykgKlxuICAgICAgICAgICAgICAgICAgICAgICAgY29tcHV0QmFyV2lkdGgud2lkdGgpIC9cbiAgICAgICAgICAgICAgICAgICAgMTAwLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pLFxuICAgICAgICAgICAgdC5mb3JFYWNoKGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICAgICAgZS5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgd2lkdGg6XG4gICAgICAgICAgICAgICAgICAgICAgICAoY29tcHV0QmFyV2lkdGguc29ydERlcHRoLndpZHRoKGVbMV0sIG8pICpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb21wdXRCYXJXaWR0aC53aWR0aCkgL1xuICAgICAgICAgICAgICAgICAgICAgICAgMTAwLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgfSxcbn07XG5mdW5jdGlvbiBudW1iZXJfZm9ybWF0KG51bWJlciwgZGVjaW1hbHMsIGRlY1BvaW50LCB0aG91c2FuZHNTZXApIHtcbiAgICBudW1iZXIgPSAobnVtYmVyICsgXCJcIikucmVwbGFjZSgvW14wLTkrXFwtRWUuXS9nLCBcIlwiKTtcbiAgICB2YXIgbiA9ICFpc0Zpbml0ZSgrbnVtYmVyKSA/IDAgOiArbnVtYmVyO1xuICAgIHZhciBwcmVjID0gIWlzRmluaXRlKCtkZWNpbWFscykgPyAwIDogTWF0aC5hYnMoZGVjaW1hbHMpO1xuICAgIHZhciBzZXAgPSB0eXBlb2YgdGhvdXNhbmRzU2VwID09PSBcInVuZGVmaW5lZFwiID8gXCIsXCIgOiB0aG91c2FuZHNTZXA7XG4gICAgdmFyIGRlYyA9IHR5cGVvZiBkZWNQb2ludCA9PT0gXCJ1bmRlZmluZWRcIiA/IFwiLlwiIDogZGVjUG9pbnQ7XG4gICAgdmFyIHMgPSBcIlwiO1xuXG4gICAgdmFyIHRvRml4ZWRGaXggPSBmdW5jdGlvbiAobiwgcHJlYykge1xuICAgICAgICB2YXIgayA9IE1hdGgucG93KDEwLCBwcmVjKTtcbiAgICAgICAgcmV0dXJuIFwiXCIgKyAoTWF0aC5yb3VuZChuICogaykgLyBrKS50b0ZpeGVkKHByZWMpO1xuICAgIH07XG5cbiAgICAvLyBAdG9kbzogZm9yIElFIHBhcnNlRmxvYXQoMC41NSkudG9GaXhlZCgwKSA9IDA7XG4gICAgcyA9IChwcmVjID8gdG9GaXhlZEZpeChuLCBwcmVjKSA6IFwiXCIgKyBNYXRoLnJvdW5kKG4pKS5zcGxpdChcIi5cIik7XG4gICAgaWYgKHNbMF0ubGVuZ3RoID4gMykge1xuICAgICAgICBzWzBdID0gc1swXS5yZXBsYWNlKC9cXEIoPz0oPzpcXGR7M30pKyg/IVxcZCkpL2csIHNlcCk7XG4gICAgfVxuICAgIGlmICgoc1sxXSB8fCBcIlwiKS5sZW5ndGggPCBwcmVjKSB7XG4gICAgICAgIHNbMV0gPSBzWzFdIHx8IFwiXCI7XG4gICAgICAgIHNbMV0gKz0gbmV3IEFycmF5KHByZWMgLSBzWzFdLmxlbmd0aCArIDEpLmpvaW4oXCIwXCIpO1xuICAgIH1cblxuICAgIHJldHVybiBzLmpvaW4oZGVjKTtcbn1cbmV4cG9ydCBkZWZhdWx0IHtcbiAgICBwcm9wczogW1wic3ltYm9sXCIsIFwiY3VycmVuY3lcIl0sXG5cbiAgICAvLyBjb21wb25lbnQgbGlzdFxuICAgIGNvbXBvbmVudHM6IHt9LFxuXG4gICAgLy8gY29tcG9uZW50IGRhdGFcbiAgICBkYXRhKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgc2lkZUxlbmd0aDogMjAsXG4gICAgICAgICAgICByZWZyZXNoUmF0ZTogNTAwLFxuICAgICAgICAgICAgYmVzdEFza2VyOiBcIlwiLFxuICAgICAgICAgICAgbGFzdFVwZGF0ZWQ6IFwiXCIsXG4gICAgICAgICAgICBhY3RpdmVJdGVtOiBcInBpbGxzLWdyYXBoXCIsXG4gICAgICAgICAgICBzdGF0dXM6IHRydWUsXG4gICAgICAgICAgICBkYXRhOiB7fSxcbiAgICAgICAgfTtcbiAgICB9LFxuICAgIC8vIGN1c3RvbSBtZXRob2RzXG4gICAgbWV0aG9kczoge1xuICAgICAgICBpc0FjdGl2ZShtZW51SXRlbSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuYWN0aXZlSXRlbSA9PT0gbWVudUl0ZW07XG4gICAgICAgIH0sXG4gICAgICAgIHNldEFjdGl2ZShtZW51SXRlbSkge1xuICAgICAgICAgICAgdGhpcy5hY3RpdmVJdGVtID0gbWVudUl0ZW07XG4gICAgICAgIH0sXG4gICAgICAgIGFzeW5jIHVwZGF0ZU9yZGVyYm9vayhkYXRhKSB7XG4gICAgICAgICAgICBjb25zdCBub3cgPSBEYXRlLm5vdygpO1xuICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgICF0aGlzLmxhc3RVcGRhdGVkIHx8XG4gICAgICAgICAgICAgICAgbm93IC0gdGhpcy5sYXN0VXBkYXRlZCA+IHRoaXMucmVmcmVzaFJhdGVcbiAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgIGNvbXB1dEJhcldpZHRoLmluaXQoZGF0YS5iaWRzLCBkYXRhLmFza3MpO1xuICAgICAgICAgICAgICAgICQoXCIuYXNrcywuYmlkcywuYXNrc19vbmx5LC5iaWRzX29ubHlcIikuZW1wdHkoKTtcblxuICAgICAgICAgICAgICAgICQuZWFjaChkYXRhLmFza3MsIGZ1bmN0aW9uIChpbmRleCwgaXRlbSkge1xuICAgICAgICAgICAgICAgICAgICBsZXQgcm93ID0gJChcIjx0cj5cIilcbiAgICAgICAgICAgICAgICAgICAgICAgIC5hcHBlbmQoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJCgnPHRkIGNsYXNzPVwidGRkXCI+JylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLmNzcyhcImNvbG9yXCIsIFwicmdiKDI0Niw3MCw5MylcIilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLmFkZENsYXNzKFwicHJpY2VcIilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLmFwcGVuZCgkKFwiPHNwYW4+XCIpLnRleHQoaXRlbVswXSkpXG4gICAgICAgICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgICAgICAgICAuYXBwZW5kKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICQoJzx0ZCBjbGFzcz1cInRkZFwiPicpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5hZGRDbGFzcyhcInF1YW50aXR5XCIpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5hcHBlbmQoJChcIjxzcGFuPlwiKS50ZXh0KGl0ZW1bMV0pKVxuICAgICAgICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgICAgICAgICAgLmFwcGVuZChcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAkKCc8dGQgY2xhc3M9XCJ0ZGRcIj4nKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAuYWRkQ2xhc3MoXCJidGNcIilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLmFwcGVuZChcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICQoXCI8c3Bhbj5cIikudGV4dChcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBudW1iZXJfZm9ybWF0KGl0ZW1bMF0gKiBpdGVtWzFdLCAyLCBcIixcIilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAuYXBwZW5kKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJChcIjxkaXY+XCIpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLmFkZENsYXNzKFwicGVyY2VudFwiKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5jc3MoXCJ3aWR0aFwiLCBpdGVtWzJdLndpZHRoICsgXCJweFwiKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgICBpZiAoaW5kZXggPiAxNikgcm93LmhpZGUoKTtcblxuICAgICAgICAgICAgICAgICAgICAkKFwiLmFza3NcIikucHJlcGVuZChyb3cpO1xuXG4gICAgICAgICAgICAgICAgICAgIGxldCByb3d5ID0gJChcIjx0cj5cIilcbiAgICAgICAgICAgICAgICAgICAgICAgIC5hcHBlbmQoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJCgnPHRkIGNsYXNzPVwidGRkXCI+JylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLmNzcyhcImNvbG9yXCIsIFwicmdiKDI0Niw3MCw5MylcIilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLmFkZENsYXNzKFwicHJpY2VcIilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLmFwcGVuZCgkKFwiPHNwYW4+XCIpLnRleHQoaXRlbVswXSkpXG4gICAgICAgICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgICAgICAgICAuYXBwZW5kKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICQoJzx0ZCBjbGFzcz1cInRkZFwiPicpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5hZGRDbGFzcyhcInF1YW50aXR5XCIpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5hcHBlbmQoJChcIjxzcGFuPlwiKS50ZXh0KGl0ZW1bMV0udG9GaXhlZCgyKSkpXG4gICAgICAgICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgICAgICAgICAuYXBwZW5kKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICQoJzx0ZCBjbGFzcz1cInRkZFwiPicpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5hZGRDbGFzcyhcImJ0Y1wiKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAuYXBwZW5kKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJChcIjxzcGFuPlwiKS50ZXh0KFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG51bWJlcl9mb3JtYXQoaXRlbVswXSAqIGl0ZW1bMV0sIDIsIFwiLFwiKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5hcHBlbmQoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAkKFwiPGRpdj5cIilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAuYWRkQ2xhc3MoXCJwZXJjZW50XCIpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLmNzcyhcIndpZHRoXCIsIGl0ZW1bMl0ud2lkdGggKyBcInB4XCIpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICAgICAgICAgICk7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKGluZGV4ID4gMjApIHJvd3kuaGlkZSgpO1xuXG4gICAgICAgICAgICAgICAgICAgICQoXCIuYXNrc19vbmx5XCIpLnByZXBlbmQocm93eSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgJC5lYWNoKGRhdGEuYmlkcywgZnVuY3Rpb24gKGluZGV4LCBpdGVtKSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCByb3cgPSAkKFwiPHRyPlwiKVxuICAgICAgICAgICAgICAgICAgICAgICAgLmFwcGVuZChcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAkKCc8dGQgY2xhc3M9XCJ0ZGRcIj4nKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAuY3NzKFwiY29sb3JcIiwgXCJyZ2IoMTQsMjAzLDEyOSlcIilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLmFkZENsYXNzKFwicHJpY2VcIilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLmFwcGVuZCgkKFwiPHNwYW4+XCIpLnRleHQoaXRlbVswXSkpXG4gICAgICAgICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgICAgICAgICAuYXBwZW5kKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICQoJzx0ZCBjbGFzcz1cInRkZFwiPicpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5hZGRDbGFzcyhcInF1YW50aXR5XCIpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5hcHBlbmQoJChcIjxzcGFuPlwiKS50ZXh0KGl0ZW1bMV0pKVxuICAgICAgICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgICAgICAgICAgLmFwcGVuZChcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAkKCc8dGQgY2xhc3M9XCJ0ZGRcIj4nKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAuYWRkQ2xhc3MoXCJidGNcIilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLmFwcGVuZChcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICQoXCI8c3Bhbj5cIikudGV4dChcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBudW1iZXJfZm9ybWF0KGl0ZW1bMF0gKiBpdGVtWzFdLCAyLCBcIixcIilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAuYXBwZW5kKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJChcIjxkaXY+XCIpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLmFkZENsYXNzKFwicGVyY2VudFwiKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5jc3MoXCJ3aWR0aFwiLCBpdGVtWzJdLndpZHRoICsgXCJweFwiKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgICAgICAgICApO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmIChpbmRleCA+IDE2KSByb3cuaGlkZSgpO1xuXG4gICAgICAgICAgICAgICAgICAgICQoXCIuYmlkc1wiKS5wcmVwZW5kKHJvdyk7XG5cbiAgICAgICAgICAgICAgICAgICAgbGV0IHJvd3kgPSAkKFwiPHRyPlwiKVxuICAgICAgICAgICAgICAgICAgICAgICAgLmFwcGVuZChcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAkKCc8dGQgY2xhc3M9XCJ0ZGRcIj4nKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAuY3NzKFwiY29sb3JcIiwgXCJyZ2IoMTQsMjAzLDEyOSlcIilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLmFkZENsYXNzKFwicHJpY2VcIilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLmFwcGVuZCgkKFwiPHNwYW4+XCIpLnRleHQoaXRlbVswXSkpXG4gICAgICAgICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgICAgICAgICAuYXBwZW5kKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICQoJzx0ZCBjbGFzcz1cInRkZFwiPicpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5hZGRDbGFzcyhcInF1YW50aXR5XCIpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5hcHBlbmQoJChcIjxzcGFuPlwiKS50ZXh0KGl0ZW1bMV0pKVxuICAgICAgICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgICAgICAgICAgLmFwcGVuZChcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAkKCc8dGQgY2xhc3M9XCJ0ZGRcIj4nKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAuYWRkQ2xhc3MoXCJidGNcIilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLmFwcGVuZChcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICQoXCI8c3Bhbj5cIikudGV4dChcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBudW1iZXJfZm9ybWF0KGl0ZW1bMF0gKiBpdGVtWzFdLCAyLCBcIixcIilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAuYXBwZW5kKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJChcIjxkaXY+XCIpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLmFkZENsYXNzKFwicGVyY2VudFwiKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5jc3MoXCJ3aWR0aFwiLCBpdGVtWzJdLndpZHRoICsgXCJweFwiKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgICAgICAgICApO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmIChpbmRleCA+IDIwKSByb3d5LmhpZGUoKTtcblxuICAgICAgICAgICAgICAgICAgICAkKFwiLmJpZHNfb25seVwiKS5wcmVwZW5kKHJvd3kpO1xuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgdGhpcy5iZXN0X2Fza3MgPSAkKFwiLmJlc3RfYXNrXCIpO1xuICAgICAgICAgICAgICAgIHRoaXMuYmVzdF9hc2tfSWNvbnMgPSAkKFwiLmJlc3RfYXNrX2ljb25cIik7XG4gICAgICAgICAgICAgICAgY29uc3QgYmVzdF9hc2sgPSB0aGlzLmJlc3RfYXNrcztcbiAgICAgICAgICAgICAgICBjb25zdCBiZXN0X2Fza19JY29uID0gdGhpcy5iZXN0X2Fza19JY29ucztcbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMuYmVzdEFza2VyIHx8IGRhdGEuYXNrc1swXVswXSA+IHRoaXMuYmVzdEFza2VyKSB7XG4gICAgICAgICAgICAgICAgICAgIGJlc3RfYXNrLnRleHQoZGF0YS5hc2tzWzBdWzBdKTtcbiAgICAgICAgICAgICAgICAgICAgYmVzdF9hc2sudG9nZ2xlQ2xhc3MoXCJ0ZXh0LXN1Y2Nlc3NcIik7XG4gICAgICAgICAgICAgICAgICAgIGJlc3RfYXNrX0ljb25cbiAgICAgICAgICAgICAgICAgICAgICAgIC5hZGRDbGFzcyhcImJpLWFycm93LXVwIHRleHQtc3VjY2Vzc1wiKVxuICAgICAgICAgICAgICAgICAgICAgICAgLnJlbW92ZUNsYXNzKFwiYmktYXJyb3ctZG93biB0ZXh0LWRhbmdlclwiKTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGRhdGEuYXNrc1swXVswXSA8IHRoaXMuYmVzdEFza2VyKSB7XG4gICAgICAgICAgICAgICAgICAgIGJlc3RfYXNrLnRleHQoZGF0YS5hc2tzWzBdWzBdKTtcbiAgICAgICAgICAgICAgICAgICAgYmVzdF9hc2sudG9nZ2xlQ2xhc3MoXCJ0ZXh0LWRhbmdlclwiKTtcbiAgICAgICAgICAgICAgICAgICAgYmVzdF9hc2tfSWNvblxuICAgICAgICAgICAgICAgICAgICAgICAgLmFkZENsYXNzKFwiYmktYXJyb3ctZG93biB0ZXh0LWRhbmdlclwiKVxuICAgICAgICAgICAgICAgICAgICAgICAgLnJlbW92ZUNsYXNzKFwiYmktYXJyb3ctdXAgdGV4dC1zdWNjZXNzXCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLmJlc3RBc2tlciA9IGRhdGEuYXNrc1swXVswXTtcblxuICAgICAgICAgICAgICAgIHRoaXMuYmVzdEFza1RleHQgPSAkKFwiI2Jlc3RBc2tcIik7XG4gICAgICAgICAgICAgICAgY29uc3QgYmVzdEFzayA9IHRoaXMuYmVzdEFza1RleHQ7XG4gICAgICAgICAgICAgICAgYmVzdEFzay52YWwoZGF0YS5hc2tzWzBdWzBdKTtcblxuICAgICAgICAgICAgICAgIHRoaXMuYmVzdEJpZFRleHQgPSAkKFwiI2Jlc3RCaWRcIik7XG4gICAgICAgICAgICAgICAgY29uc3QgYmVzdEJpZCA9IHRoaXMuYmVzdEJpZFRleHQ7XG4gICAgICAgICAgICAgICAgYmVzdEJpZC52YWwoZGF0YS5iaWRzWzBdWzBdKTtcblxuICAgICAgICAgICAgICAgIHRoaXMubGFzdFVwZGF0ZWQgPSBub3c7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGF3YWl0IGNjeHQuc2xlZXAocGFyc2VJbnQodGhpcy5yZWZyZXNoUmF0ZSAvIDIpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICBhc3luYyBsb29wT3JkZXJib29rKCkge1xuICAgICAgICAgICAgd2hpbGUgKHRoaXMuc3RhdHVzID09IHRydWUpIHtcbiAgICAgICAgICAgICAgICBpZiAoZG9jdW1lbnQuaGlkZGVuKSB7XG4gICAgICAgICAgICAgICAgICAgIGF3YWl0IGNjeHQuc2xlZXAoMTAwMCk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBkYXRhID0gYXdhaXQgZXhjaGFuZ2Uud2F0Y2hPcmRlckJvb2soXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnN5bWJvbCArIFwiL1wiICsgdGhpcy5jdXJyZW5jeSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc2lkZUxlbmd0aFxuICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnVwZGF0ZU9yZGVyYm9vayhkYXRhKTtcbiAgICAgICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICB9LFxuICAgIC8vIG9uIGNvbXBvbmVudCBjcmVhdGVkXG4gICAgY3JlYXRlZCgpIHtcbiAgICAgICAgdGhpcy5sb29wT3JkZXJib29rKCk7XG4gICAgfSxcbiAgICAvLyBvbiBjb21wb25lbnQgbW91bnRlZFxuICAgIG1vdW50ZWQoKSB7fSxcbn07XG48L3NjcmlwdD5cbiIsIjx0ZW1wbGF0ZT5cbiAgICA8ZGl2IGNsYXNzPVwiIFwiPlxuICAgICAgICA8ZGl2IGlkPVwidHJhZGluZ3ZpZXdcIj48L2Rpdj5cbiAgICA8L2Rpdj5cbjwvdGVtcGxhdGU+XG5cbjxzY3JpcHQ+XG4vLyBjb21wb25lbnRcbmV4cG9ydCBkZWZhdWx0IHtcbiAgICBwcm9wczogW1wicHJvdmlkZVwiLCBcInN5bWJvbFwiLCBcImN1cnJlbmN5XCJdLFxuXG4gICAgLy8gY29tcG9uZW50IGxpc3RcbiAgICBjb21wb25lbnRzOiB7fSxcblxuICAgIC8vIGNvbXBvbmVudCBkYXRhXG4gICAgZGF0YSgpIHtcbiAgICAgICAgcmV0dXJuIHt9O1xuICAgIH0sXG5cbiAgICAvLyBjdXN0b20gbWV0aG9kc1xuICAgIG1ldGhvZHM6IHt9LFxuXG4gICAgLy8gb24gY29tcG9uZW50IGNyZWF0ZWRcbiAgICBjcmVhdGVkKCkge30sXG5cbiAgICAvLyBvbiBjb21wb25lbnQgbW91bnRlZFxuICAgIG1vdW50ZWQoKSB7XG4gICAgICAgIG5ldyBUcmFkaW5nVmlldy53aWRnZXQoe1xuICAgICAgICAgICAgd2lkdGg6IFwiMTAwJVwiLFxuICAgICAgICAgICAgaGVpZ2h0OiBcIjEwMCVcIixcbiAgICAgICAgICAgIHN5bWJvbDogdGhpcy5wcm92aWRlICsgXCI6XCIgKyB0aGlzLnN5bWJvbCArIHRoaXMuY3VycmVuY3ksXG4gICAgICAgICAgICBpbnRlcnZhbDogXCJIXCIsXG4gICAgICAgICAgICB0aW1lem9uZTogXCJFdGMvVVRDXCIsXG4gICAgICAgICAgICB0aGVtZTogXCJkYXJrXCIsXG4gICAgICAgICAgICBzdHlsZTogXCIxXCIsXG4gICAgICAgICAgICBsb2NhbGU6IFwiZW5cIixcbiAgICAgICAgICAgIHRvb2xiYXJfYmc6IFwiI2YxZjNmNlwiLFxuICAgICAgICAgICAgZW5hYmxlX3B1Ymxpc2hpbmc6IGZhbHNlLFxuICAgICAgICAgICAgaGlkZV9sZWdlbmQ6IHRydWUsXG4gICAgICAgICAgICBzYXZlX2ltYWdlOiBmYWxzZSxcbiAgICAgICAgICAgIGNvbnRhaW5lcl9pZDogXCJ0cmFkaW5ndmlld1wiLFxuICAgICAgICB9KTtcbiAgICB9LFxuXG4gICAgLy8gb24gY29tcG9uZW50IGRlc3Ryb3llZFxuICAgIGRlc3Ryb3llZCgpIHt9LFxufTtcbjwvc2NyaXB0PlxuIiwidmFyIERFU0NSSVBUT1JTID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2Rlc2NyaXB0b3JzJyk7XG52YXIgdW5jdXJyeVRoaXMgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZnVuY3Rpb24tdW5jdXJyeS10aGlzJyk7XG52YXIgb2JqZWN0S2V5cyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9vYmplY3Qta2V5cycpO1xudmFyIHRvSW5kZXhlZE9iamVjdCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy90by1pbmRleGVkLW9iamVjdCcpO1xudmFyICRwcm9wZXJ0eUlzRW51bWVyYWJsZSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9vYmplY3QtcHJvcGVydHktaXMtZW51bWVyYWJsZScpLmY7XG5cbnZhciBwcm9wZXJ0eUlzRW51bWVyYWJsZSA9IHVuY3VycnlUaGlzKCRwcm9wZXJ0eUlzRW51bWVyYWJsZSk7XG52YXIgcHVzaCA9IHVuY3VycnlUaGlzKFtdLnB1c2gpO1xuXG4vLyBgT2JqZWN0LnsgZW50cmllcywgdmFsdWVzIH1gIG1ldGhvZHMgaW1wbGVtZW50YXRpb25cbnZhciBjcmVhdGVNZXRob2QgPSBmdW5jdGlvbiAoVE9fRU5UUklFUykge1xuICByZXR1cm4gZnVuY3Rpb24gKGl0KSB7XG4gICAgdmFyIE8gPSB0b0luZGV4ZWRPYmplY3QoaXQpO1xuICAgIHZhciBrZXlzID0gb2JqZWN0S2V5cyhPKTtcbiAgICB2YXIgbGVuZ3RoID0ga2V5cy5sZW5ndGg7XG4gICAgdmFyIGkgPSAwO1xuICAgIHZhciByZXN1bHQgPSBbXTtcbiAgICB2YXIga2V5O1xuICAgIHdoaWxlIChsZW5ndGggPiBpKSB7XG4gICAgICBrZXkgPSBrZXlzW2krK107XG4gICAgICBpZiAoIURFU0NSSVBUT1JTIHx8IHByb3BlcnR5SXNFbnVtZXJhYmxlKE8sIGtleSkpIHtcbiAgICAgICAgcHVzaChyZXN1bHQsIFRPX0VOVFJJRVMgPyBba2V5LCBPW2tleV1dIDogT1trZXldKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICAvLyBgT2JqZWN0LmVudHJpZXNgIG1ldGhvZFxuICAvLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLW9iamVjdC5lbnRyaWVzXG4gIGVudHJpZXM6IGNyZWF0ZU1ldGhvZCh0cnVlKSxcbiAgLy8gYE9iamVjdC52YWx1ZXNgIG1ldGhvZFxuICAvLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLW9iamVjdC52YWx1ZXNcbiAgdmFsdWVzOiBjcmVhdGVNZXRob2QoZmFsc2UpXG59O1xuIiwidmFyICQgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZXhwb3J0Jyk7XG52YXIgJGVudHJpZXMgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvb2JqZWN0LXRvLWFycmF5JykuZW50cmllcztcblxuLy8gYE9iamVjdC5lbnRyaWVzYCBtZXRob2Rcbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtb2JqZWN0LmVudHJpZXNcbiQoeyB0YXJnZXQ6ICdPYmplY3QnLCBzdGF0OiB0cnVlIH0sIHtcbiAgZW50cmllczogZnVuY3Rpb24gZW50cmllcyhPKSB7XG4gICAgcmV0dXJuICRlbnRyaWVzKE8pO1xuICB9XG59KTtcbiIsIi8vIEltcG9ydHNcbmltcG9ydCBfX19DU1NfTE9BREVSX0FQSV9TT1VSQ0VNQVBfSU1QT1JUX19fIGZyb20gXCIuLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvbGFyYXZlbC1taXgvbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvZGlzdC9ydW50aW1lL2Nzc1dpdGhNYXBwaW5nVG9TdHJpbmcuanNcIjtcbmltcG9ydCBfX19DU1NfTE9BREVSX0FQSV9JTVBPUlRfX18gZnJvbSBcIi4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9sYXJhdmVsLW1peC9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9kaXN0L3J1bnRpbWUvYXBpLmpzXCI7XG52YXIgX19fQ1NTX0xPQURFUl9FWFBPUlRfX18gPSBfX19DU1NfTE9BREVSX0FQSV9JTVBPUlRfX18oX19fQ1NTX0xPQURFUl9BUElfU09VUkNFTUFQX0lNUE9SVF9fXyk7XG4vLyBNb2R1bGVcbl9fX0NTU19MT0FERVJfRVhQT1JUX19fLnB1c2goW21vZHVsZS5pZCwgXCJcXG4ubm90LXdhdGNobGlzdGVkOmhvdmVyIC5iaS1zdGFyIHtcXG4gICAgY29sb3I6IHJnYigyNTUsIDE1OSwgNjcpICFpbXBvcnRhbnQ7XFxufVxcbi53YXRjaGxpc3RlZDpob3ZlciAuYmktc3Rhci1maWxsIHtcXG4gICAgY29sb3I6IHJnYigxMzAsIDEzNCwgMTM5KSAhaW1wb3J0YW50O1xcbn1cXG5cIiwgXCJcIix7XCJ2ZXJzaW9uXCI6MyxcInNvdXJjZXNcIjpbXCJ3ZWJwYWNrOi8vLi9yZXNvdXJjZXMvc3JjL2NvbXBvbmVudHMvdHJhZGluZy9NYXJrZXRzLnZ1ZVwiXSxcIm5hbWVzXCI6W10sXCJtYXBwaW5nc1wiOlwiO0FBK2JBO0lBQ0EsbUNBQUE7QUFDQTtBQUNBO0lBQ0Esb0NBQUE7QUFDQVwiLFwic291cmNlc0NvbnRlbnRcIjpbXCI8dGVtcGxhdGU+XFxuICAgIDxkaXY+XFxuICAgICAgICA8ZGl2IGNsYXNzPVxcXCJkLWZsZXgganVzdGlmeS1jb250ZW50LWJldHdlZW4gYWxpZ24taXRlbXMtY2VudGVyXFxcIj5cXG4gICAgICAgICAgICA8YnV0dG9uIGNsYXNzPVxcXCJidG4gYnRuLWljb25cXFwiIHN0eWxlPVxcXCJwb3NpdGlvbjogcmVsYXRpdmU7IHRvcDogLTVweFxcXCI+XFxuICAgICAgICAgICAgICAgIDxpXFxuICAgICAgICAgICAgICAgICAgICBjbGFzcz1cXFwiYmkgYmktY2hldnJvbi1sZWZ0IHRleHQtd2FybmluZyBmcy00XFxcIlxcbiAgICAgICAgICAgICAgICAgICAgQGNsaWNrLnByZXZlbnQ9XFxcInNjcm9sbExlZnQoKVxcXCJcXG4gICAgICAgICAgICAgICAgPjwvaT5cXG4gICAgICAgICAgICA8L2J1dHRvbj5cXG4gICAgICAgICAgICA8dWxcXG4gICAgICAgICAgICAgICAgY2xhc3M9XFxcIm5hdiBuYXYtdGFicyBuZlxcXCJcXG4gICAgICAgICAgICAgICAgcm9sZT1cXFwidGFibGlzdFxcXCJcXG4gICAgICAgICAgICAgICAgc3R5bGU9XFxcIm92ZXJmbG93LXg6IGhpZGRlblxcXCJcXG4gICAgICAgICAgICA+XFxuICAgICAgICAgICAgICAgIDxsaSBjbGFzcz1cXFwibmF2LWl0ZW1cXFwiPlxcbiAgICAgICAgICAgICAgICAgICAgPGFcXG4gICAgICAgICAgICAgICAgICAgICAgICBjbGFzcz1cXFwibmF2LWxpbmtcXFwiXFxuICAgICAgICAgICAgICAgICAgICAgICAgQGNsaWNrLnByZXZlbnQ9XFxcInNldEFjdGl2ZSgnZmF2JylcXFwiXFxuICAgICAgICAgICAgICAgICAgICAgICAgOmNsYXNzPVxcXCJ7IGFjdGl2ZTogaXNBY3RpdmUoJ2ZhdicpIH1cXFwiXFxuICAgICAgICAgICAgICAgICAgICAgICAgaHJlZj1cXFwiI2ZhdlxcXCJcXG4gICAgICAgICAgICAgICAgICAgICAgICA+PGkgY2xhc3M9XFxcImJpIGJpLXN0YXJcXFwiPjwvaVxcbiAgICAgICAgICAgICAgICAgICAgPjwvYT5cXG4gICAgICAgICAgICAgICAgPC9saT5cXG4gICAgICAgICAgICAgICAgPGxpXFxuICAgICAgICAgICAgICAgICAgICBjbGFzcz1cXFwibmF2LWl0ZW1cXFwiXFxuICAgICAgICAgICAgICAgICAgICB2LWZvcj1cXFwiKHBhaXIsIGluZGV4KSBpbiBwYWlyc1xcXCJcXG4gICAgICAgICAgICAgICAgICAgIDprZXk9XFxcImluZGV4XFxcIlxcbiAgICAgICAgICAgICAgICA+XFxuICAgICAgICAgICAgICAgICAgICA8YVxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNsYXNzPVxcXCJuYXYtbGlua1xcXCJcXG4gICAgICAgICAgICAgICAgICAgICAgICBAY2xpY2sucHJldmVudD1cXFwic2V0QWN0aXZlKHBhaXIpXFxcIlxcbiAgICAgICAgICAgICAgICAgICAgICAgIDpjbGFzcz1cXFwieyBhY3RpdmU6IGlzQWN0aXZlKHBhaXIpIH1cXFwiXFxuICAgICAgICAgICAgICAgICAgICAgICAgaHJlZj1cXFwiI3Byb2ZpbGVcXFwiXFxuICAgICAgICAgICAgICAgICAgICAgICAgPnt7IHBhaXIgfX08L2FcXG4gICAgICAgICAgICAgICAgICAgID5cXG4gICAgICAgICAgICAgICAgPC9saT5cXG4gICAgICAgICAgICA8L3VsPlxcbiAgICAgICAgICAgIDxidXR0b24gY2xhc3M9XFxcImJ0biBidG4taWNvblxcXCIgc3R5bGU9XFxcInBvc2l0aW9uOiByZWxhdGl2ZTsgdG9wOiAtNXB4XFxcIj5cXG4gICAgICAgICAgICAgICAgPGlcXG4gICAgICAgICAgICAgICAgICAgIGNsYXNzPVxcXCJiaSBiaS1jaGV2cm9uLXJpZ2h0IHRleHQtd2FybmluZyBmcy00XFxcIlxcbiAgICAgICAgICAgICAgICAgICAgQGNsaWNrLnByZXZlbnQ9XFxcInNjcm9sbFJpZ2h0KClcXFwiXFxuICAgICAgICAgICAgICAgID48L2k+XFxuICAgICAgICAgICAgPC9idXR0b24+XFxuICAgICAgICA8L2Rpdj5cXG4gICAgICAgIDxkaXYgY2xhc3M9XFxcInRhYi1jb250ZW50XFxcIiBpZD1cXFwibXlUYWJDb250ZW50XFxcIj5cXG4gICAgICAgICAgICA8ZGl2XFxuICAgICAgICAgICAgICAgIGNsYXNzPVxcXCJ0YWItcGFuZSBmYWRlXFxcIlxcbiAgICAgICAgICAgICAgICA6Y2xhc3M9XFxcInsgJ2FjdGl2ZSBzaG93JzogaXNBY3RpdmUoJ2ZhdicpIH1cXFwiXFxuICAgICAgICAgICAgICAgIGlkPVxcXCJmYXZcXFwiXFxuICAgICAgICAgICAgPlxcbiAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVxcXCJyb3dcXFwiPlxcbiAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cXFwiY29sLTEyIGNhcmQtc2VhcmNoIGN1c3RvbS1kYXRhLXNlYXJjaFxcXCI+XFxuICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cXFwiaW5wdXQtZ3JvdXAgaW5wdXQtZ3JvdXAtc20gcHgtMSBtYi0xXFxcIj5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPHNwYW5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNsYXNzPVxcXCJpbnB1dC1ncm91cC10ZXh0IHRleHQtZGFyayBib3JkZXItMFxcXCJcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlkPVxcXCJiYXNpYy1hZGRvbjFcXFwiXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA+PGkgY2xhc3M9XFxcImJpIGJpLXNlYXJjaFxcXCI+PC9pXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgID48L3NwYW4+XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxpbnB1dFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZT1cXFwidGV4dFxcXCJcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU9XFxcInNlYXJjaF90YWJsZV9mYXZcXFwiXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjbGFzcz1cXFwiZm9ybS1jb250cm9sIGZvcm0tY29udHJvbC1zbSB0ZXh0LWRhcmsgYm9yZGVyLTBcXFwiXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwbGFjZWhvbGRlcj1cXFwiU2VhcmNoLi4uXFxcIlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvPlxcbiAgICAgICAgICAgICAgICAgICAgICAgIDwvZGl2PlxcbiAgICAgICAgICAgICAgICAgICAgPC9kaXY+XFxuICAgICAgICAgICAgICAgIDwvZGl2PlxcbiAgICAgICAgICAgICAgICA8dGFibGVcXG4gICAgICAgICAgICAgICAgICAgIGNsYXNzPVxcXCJ0YWJsZSB0ZXh0LWRhcmsgdGFibGUtc20gdGFibGUtYm9yZGVybGVzcyB0YWJsZUZpeEhlYWQgY3VzdG9tLWRhdGEtdGFibGUtZmF2XFxcIlxcbiAgICAgICAgICAgICAgICA+XFxuICAgICAgICAgICAgICAgICAgICA8dGhlYWQgY2xhc3M9XFxcInRleHQtbXV0ZWRcXFwiPlxcbiAgICAgICAgICAgICAgICAgICAgICAgIDx0aCBzY29wZT1cXFwiY29sXFxcIj5QYWlyPC90aD5cXG4gICAgICAgICAgICAgICAgICAgICAgICA8dGggY2xhc3M9XFxcImQtbGctbm9uZSBkLXhsLWJsb2NrXFxcIiBzY29wZT1cXFwiY29sXFxcIj5DaGFuZ2U8L3RoPlxcbiAgICAgICAgICAgICAgICAgICAgICAgIDx0aCBzY29wZT1cXFwiY29sXFxcIj5QcmljZTwvdGg+XFxuICAgICAgICAgICAgICAgICAgICA8L3RoZWFkPlxcbiAgICAgICAgICAgICAgICAgICAgPHRib2R5PlxcbiAgICAgICAgICAgICAgICAgICAgICAgIDx0ciB2LWZvcj1cXFwiKGZhdiwgaW5kZXgpIGluIGZhdnNcXFwiIDprZXk9XFxcImluZGV4XFxcIj5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPHRkPlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cXFwiZC1mbGV4IGp1c3RpZnktY29udGVudC1zdGFydFxcXCI+XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPGZvcm1cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgQHN1Ym1pdC5wcmV2ZW50PVxcXCJcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlbW92ZUZyb21XYXRjaGxpc3QoZmF2LmlkKVxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcXFwiXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8YnV0dG9uXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlPVxcXCJzdWJtaXRcXFwiXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjbGFzcz1cXFwid2F0Y2hsaXN0ZWRcXFwiXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdHlsZT1cXFwiXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYmFja2dyb3VuZDogdHJhbnNwYXJlbnQ7XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYm9yZGVyOiB0cmFuc3BhcmVudDtcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxcXCJcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPGlcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjbGFzcz1cXFwibWUtMSB0ZXh0LXdhcm5pbmcgYmkgYmktc3Rhci1maWxsXFxcIlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPjwvaT5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPC9idXR0b24+XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPC9mb3JtPlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxyb3V0ZXItbGlua1xcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA6dG89XFxcIlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJy4uLycgK1xcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZmF2LmN1cnJlbmN5ICtcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICcvJyArXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmYXYucGFpclxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcXFwiXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8c3BhbiBjbGFzcz1cXFwidGV4dC1kYXJrIGZ3LWJvbGRcXFwiPnt7XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmYXYuY3VycmVuY3lcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfX08L3NwYW5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPi88c3BhblxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2xhc3M9XFxcInRleHQtc2Vjb25kYXJ5IGZ3LWJvbGRcXFwiXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA+e3sgZmF2LnBhaXIgfX08L3NwYW5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvcm91dGVyLWxpbms+XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPC90ZD5cXG5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPHRkIGNsYXNzPVxcXCJkLWxnLW5vbmUgZC14bC1ibG9ja1xcXCI+XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8c3BhblxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDpjbGFzcz1cXFwiJ2NoYW5nZS0nICsgZmF2LmN1cnJlbmN5ICsgZmF2LnBhaXJcXFwiXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA+PC9zcGFuPlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L3RkPlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8dGQ+XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8c3BhblxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDpjbGFzcz1cXFwiJ3RpYy0nICsgZmF2LmN1cnJlbmN5ICsgZmF2LnBhaXJcXFwiXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA+PC9zcGFuXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA+PGlcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA6Y2xhc3M9XFxcIlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAndGljLScgK1xcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmYXYuY3VycmVuY3kgK1xcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmYXYucGFpciArXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICctaWNvbiBiaSdcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcXFwiXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA+PC9pPlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L3RkPlxcbiAgICAgICAgICAgICAgICAgICAgICAgIDwvdHI+XFxuICAgICAgICAgICAgICAgICAgICA8L3Rib2R5PlxcbiAgICAgICAgICAgICAgICA8L3RhYmxlPlxcbiAgICAgICAgICAgIDwvZGl2PlxcbiAgICAgICAgICAgIDxkaXZcXG4gICAgICAgICAgICAgICAgY2xhc3M9XFxcInRhYi1wYW5lIGZhZGVcXFwiXFxuICAgICAgICAgICAgICAgIHYtZm9yPVxcXCIobWFyaywgaW5kZXgpIGluIG1hcmtldHNcXFwiXFxuICAgICAgICAgICAgICAgIDprZXk9XFxcImluZGV4XFxcIlxcbiAgICAgICAgICAgICAgICA6Y2xhc3M9XFxcInsgJ2FjdGl2ZSBzaG93JzogaXNBY3RpdmUoaW5kZXgpIH1cXFwiXFxuICAgICAgICAgICAgICAgIDppZD1cXFwieyBpbmRleCB9XFxcIlxcbiAgICAgICAgICAgID5cXG4gICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cXFwicm93XFxcIj5cXG4gICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XFxcImNvbC0xMiBjYXJkLXNlYXJjaCBjdXN0b20tZGF0YS1zZWFyY2hcXFwiPlxcbiAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XFxcImlucHV0LWdyb3VwIGlucHV0LWdyb3VwLXNtIHB4LTEgbWItMVxcXCI+XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxzcGFuXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjbGFzcz1cXFwiaW5wdXQtZ3JvdXAtdGV4dCB0ZXh0LWRhcmsgYm9yZGVyLTBcXFwiXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZD1cXFwiYmFzaWMtYWRkb24xXFxcIlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPjxpIGNsYXNzPVxcXCJiaSBiaS1zZWFyY2hcXFwiPjwvaVxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA+PC9zcGFuPlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8aW5wdXRcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU9XFxcInRleHRcXFwiXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYW1lPVxcXCJzZWFyY2hfdGFibGVcXFwiXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjbGFzcz1cXFwiZm9ybS1jb250cm9sIGZvcm0tY29udHJvbC1zbSB0ZXh0LWRhcmsgYm9yZGVyLTBcXFwiXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwbGFjZWhvbGRlcj1cXFwiU2VhcmNoLi4uXFxcIlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvPlxcbiAgICAgICAgICAgICAgICAgICAgICAgIDwvZGl2PlxcbiAgICAgICAgICAgICAgICAgICAgPC9kaXY+XFxuICAgICAgICAgICAgICAgIDwvZGl2PlxcbiAgICAgICAgICAgICAgICA8dGFibGVcXG4gICAgICAgICAgICAgICAgICAgIGNsYXNzPVxcXCJ0YWJsZSB0ZXh0LWRhcmsgdGFibGUtc20gdGFibGUtYm9yZGVybGVzcyB0YWJsZUZpeEhlYWRcXFwiXFxuICAgICAgICAgICAgICAgICAgICA6Y2xhc3M9XFxcIidjdXN0b20tZGF0YS10YWJsZS0nICsgaW5kZXhcXFwiXFxuICAgICAgICAgICAgICAgID5cXG4gICAgICAgICAgICAgICAgICAgIDx0aGVhZCBjbGFzcz1cXFwidGV4dC1tdXRlZFxcXCI+XFxuICAgICAgICAgICAgICAgICAgICAgICAgPHRoIHNjb3BlPVxcXCJjb2xcXFwiPlBhaXI8L3RoPlxcbiAgICAgICAgICAgICAgICAgICAgPC90aGVhZD5cXG4gICAgICAgICAgICAgICAgICAgIDx0Ym9keT5cXG4gICAgICAgICAgICAgICAgICAgICAgICA8dHIgdi1mb3I9XFxcIihtYXJrZXQsIGluZGV4KSBpbiBtYXJrXFxcIiA6a2V5PVxcXCJpbmRleFxcXCI+XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDx0ZD5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XFxcImQtZmxleCBqdXN0aWZ5LWNvbnRlbnQtc3RhcnRcXFwiPlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxmb3JtXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIEBzdWJtaXQucHJldmVudD1cXFwiXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhZGRUb1dhdGNobGlzdChcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYXJrZXQuY3VycmVuY3ksXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWFya2V0LnBhaXJcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIClcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXFxcIlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPGJ1dHRvblxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZT1cXFwic3VibWl0XFxcIlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2xhc3M9XFxcIm5vdC13YXRjaGxpc3RlZFxcXCJcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0eWxlPVxcXCJcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBiYWNrZ3JvdW5kOiB0cmFuc3BhcmVudDtcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBib3JkZXI6IHRyYW5zcGFyZW50O1xcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXFxcIlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA+XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8aVxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNsYXNzPVxcXCJtZS0xIHRleHQtc2Vjb25kYXJ5IGJpIGJpLXN0YXJcXFwiXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA+PC9pPlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L2J1dHRvbj5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L2Zvcm0+XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPHJvdXRlci1saW5rXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDp0bz1cXFwiXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnLi4vJyArXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYXJrZXQuY3VycmVuY3kgK1xcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJy8nICtcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1hcmtldC5wYWlyXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxcXCJcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA+XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxzcGFuIGNsYXNzPVxcXCJ0ZXh0LWRhcmsgZnctYm9sZFxcXCI+e3tcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1hcmtldC5jdXJyZW5jeVxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9fTwvc3BhblxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA+LzxzcGFuXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjbGFzcz1cXFwidGV4dC1zZWNvbmRhcnkgZnctYm9sZFxcXCJcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID57eyBtYXJrZXQucGFpciB9fTwvc3BhblxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA+XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPC9yb3V0ZXItbGluaz5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvZGl2PlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L3RkPlxcbiAgICAgICAgICAgICAgICAgICAgICAgIDwvdHI+XFxuICAgICAgICAgICAgICAgICAgICA8L3Rib2R5PlxcbiAgICAgICAgICAgICAgICA8L3RhYmxlPlxcbiAgICAgICAgICAgIDwvZGl2PlxcbiAgICAgICAgPC9kaXY+XFxuICAgIDwvZGl2PlxcbjwvdGVtcGxhdGU+XFxuXFxuPHNjcmlwdD5cXG4vLyBjb21wb25lbnRcXG5leHBvcnQgZGVmYXVsdCB7XFxuICAgIHByb3BzOiBbXFxcInBhaXJzXFxcIiwgXFxcInByb3ZpZGVyXFxcIl0sXFxuICAgIC8vIGNvbXBvbmVudCBsaXN0XFxuICAgIGNvbXBvbmVudHM6IHt9LFxcblxcbiAgICAvLyBjb21wb25lbnQgZGF0YVxcbiAgICBkYXRhKCkge1xcbiAgICAgICAgcmV0dXJuIHtcXG4gICAgICAgICAgICBmYXZzOiBbXSxcXG4gICAgICAgICAgICBvbGQ6IFtdLFxcbiAgICAgICAgICAgIG1hcmtldHM6IFtdLFxcbiAgICAgICAgICAgIGFjdGl2ZUl0ZW06IFxcXCJmYXZcXFwiLFxcbiAgICAgICAgICAgIHN0YXR1czogdHJ1ZSxcXG4gICAgICAgIH07XFxuICAgIH0sXFxuICAgIGNvbXB1dGVkOiB7fSxcXG5cXG4gICAgLy8gY3VzdG9tIG1ldGhvZHNcXG4gICAgbWV0aG9kczoge1xcbiAgICAgICAgZmV0Y2hNYXJrZXRzKCkge1xcbiAgICAgICAgICAgIHRoaXMuJGh0dHAucG9zdChcXFwiL2RhdGEvbWFya2V0cy9tYXJrZXRzLmpzb25cXFwiKS50aGVuKChyZXNwb25zZSkgPT4ge1xcbiAgICAgICAgICAgICAgICB0aGlzLm1hcmtldHMgPSByZXNwb25zZS5kYXRhW3RoaXMucHJvdmlkZXJdO1xcbiAgICAgICAgICAgIH0pO1xcbiAgICAgICAgfSxcXG4gICAgICAgIGZldGNoRmF2cygpIHtcXG4gICAgICAgICAgICB0aGlzLiRodHRwLnBvc3QoXFxcIi91c2VyL3dhdGNobGlzdC9kYXRhXFxcIikudGhlbigocmVzcG9uc2UpID0+IHtcXG4gICAgICAgICAgICAgICAgdGhpcy5mYXZzID0gcmVzcG9uc2UuZGF0YS5mYXZzO1xcbiAgICAgICAgICAgIH0pO1xcbiAgICAgICAgfSxcXG4gICAgICAgIGlzQWN0aXZlKG1lbnVJdGVtKSB7XFxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuYWN0aXZlSXRlbSA9PT0gbWVudUl0ZW07XFxuICAgICAgICB9LFxcbiAgICAgICAgc2V0QWN0aXZlKG1lbnVJdGVtKSB7XFxuICAgICAgICAgICAgdGhpcy5hY3RpdmVJdGVtID0gbWVudUl0ZW07XFxuICAgICAgICB9LFxcbiAgICAgICAgc2Nyb2xsTGVmdCgpIHtcXG4gICAgICAgICAgICB2YXIgbGVmdFBvcyA9ICQoXFxcIi5uZlxcXCIpLnNjcm9sbExlZnQoKTtcXG4gICAgICAgICAgICAkKFxcXCIubmZcXFwiKS5hbmltYXRlKHsgc2Nyb2xsTGVmdDogbGVmdFBvcyAtIDIwMCB9LCA4MDApO1xcbiAgICAgICAgfSxcXG4gICAgICAgIHNjcm9sbFJpZ2h0KCkge1xcbiAgICAgICAgICAgIHZhciBsZWZ0UG9zID0gJChcXFwiLm5mXFxcIikuc2Nyb2xsTGVmdCgpO1xcbiAgICAgICAgICAgICQoXFxcIi5uZlxcXCIpLmFuaW1hdGUoeyBzY3JvbGxMZWZ0OiBsZWZ0UG9zICsgMjAwIH0sIDgwMCk7XFxuICAgICAgICB9LFxcbiAgICAgICAgYWRkVG9XYXRjaGxpc3QoY3VycmVuY3ksIHBhaXIpIHtcXG4gICAgICAgICAgICB0aGlzLiRodHRwXFxuICAgICAgICAgICAgICAgIC5wb3N0KFxcXCIvdXNlci93YXRjaGxpc3Qvc3RvcmVcXFwiLCB7XFxuICAgICAgICAgICAgICAgICAgICBjdXJyZW5jeTogY3VycmVuY3ksXFxuICAgICAgICAgICAgICAgICAgICBwYWlyOiBwYWlyLFxcbiAgICAgICAgICAgICAgICB9KVxcbiAgICAgICAgICAgICAgICAudGhlbigocmVzcG9uc2UpID0+IHtcXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuJHRvYXN0W3Jlc3BvbnNlLmRhdGEudHlwZV0ocmVzcG9uc2UuZGF0YS5tZXNzYWdlKTtcXG4gICAgICAgICAgICAgICAgfSlcXG4gICAgICAgICAgICAgICAgLmNhdGNoKChlcnJvcikgPT4ge1xcbiAgICAgICAgICAgICAgICAgICAgdGhpcy4kdG9hc3QuZXJyb3IoZXJyb3IucmVzcG9uc2UuZGF0YSk7XFxuICAgICAgICAgICAgICAgIH0pO1xcbiAgICAgICAgfSxcXG4gICAgICAgIHJlbW92ZUZyb21XYXRjaGxpc3QoaWQpIHtcXG4gICAgICAgICAgICB0aGlzLiRodHRwXFxuICAgICAgICAgICAgICAgIC5wb3N0KFxcXCIvdXNlci93YXRjaGxpc3QvZGVsZXRlXFxcIiwge1xcbiAgICAgICAgICAgICAgICAgICAgaWQ6IGlkLFxcbiAgICAgICAgICAgICAgICB9KVxcbiAgICAgICAgICAgICAgICAudGhlbigocmVzcG9uc2UpID0+IHtcXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuJHRvYXN0LnN1Y2Nlc3MocmVzcG9uc2UuZGF0YS5tZXNzYWdlKTtcXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZmV0Y2hGYXZzKCk7XFxuICAgICAgICAgICAgICAgIH0pXFxuICAgICAgICAgICAgICAgIC5jYXRjaCgoZXJyb3IpID0+IHtcXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuJHRvYXN0LmVycm9yKFxcXCJNYXJrZXQgQWxyZWFkeSBSZW1vdmVkIEZyb20gV2F0Y2hsaXN0XFxcIik7XFxuICAgICAgICAgICAgICAgIH0pO1xcbiAgICAgICAgfSxcXG4gICAgICAgIGhhbmRsZSh0aWNrZXJzKSB7XFxuICAgICAgICAgICAgdGhpcy50aWNrZXJFbGVtZW50cyA9IHRoaXMudGlja2VyRWxlbWVudHMgfHwge307XFxuICAgICAgICAgICAgdGhpcy50aWNrZXJJY29ucyA9IHRoaXMudGlja2VySWNvbnMgfHwge307XFxuICAgICAgICAgICAgdGhpcy5jaGFuZ2VFbGVtZW50cyA9IHRoaXMuY2hhbmdlRWxlbWVudHMgfHwge307XFxuICAgICAgICAgICAgZm9yIChjb25zdCBbc3ltYm9sLCB0aWNrZXJdIG9mIE9iamVjdC5lbnRyaWVzKHRpY2tlcnMpKSB7XFxuICAgICAgICAgICAgICAgIGNvbnN0IHN5bWJvbFdpdGhvdXRTbGFzaCA9IHN5bWJvbC5yZXBsYWNlKFxcXCIvXFxcIiwgXFxcIlxcXCIpO1xcbiAgICAgICAgICAgICAgICBpZiAoIShzeW1ib2wgaW4gdGhpcy50aWNrZXJFbGVtZW50cykpIHtcXG4gICAgICAgICAgICAgICAgICAgIHRoaXMudGlja2VyRWxlbWVudHNbc3ltYm9sXSA9ICQoXFxuICAgICAgICAgICAgICAgICAgICAgICAgXFxcIi50aWMtXFxcIiArIHN5bWJvbFdpdGhvdXRTbGFzaFxcbiAgICAgICAgICAgICAgICAgICAgKTtcXG4gICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgICAgICBpZiAoIShzeW1ib2wgaW4gdGhpcy50aWNrZXJJY29ucykpIHtcXG4gICAgICAgICAgICAgICAgICAgIHRoaXMudGlja2VySWNvbnNbc3ltYm9sXSA9ICQoXFxuICAgICAgICAgICAgICAgICAgICAgICAgXFxcIi50aWMtXFxcIiArIHN5bWJvbFdpdGhvdXRTbGFzaCArIFxcXCItaWNvblxcXCJcXG4gICAgICAgICAgICAgICAgICAgICk7XFxuICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICAgICAgY29uc3QgdGlja2VyRWxlbWVudCA9IHRoaXMudGlja2VyRWxlbWVudHNbc3ltYm9sXTtcXG4gICAgICAgICAgICAgICAgY29uc3QgdGlja2VySWNvbiA9IHRoaXMudGlja2VySWNvbnNbc3ltYm9sXTtcXG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLm9sZFtzeW1ib2xdIHx8IHRpY2tlcltcXFwibGFzdFxcXCJdID4gdGhpcy5vbGRbc3ltYm9sXSkge1xcbiAgICAgICAgICAgICAgICAgICAgdGlja2VyRWxlbWVudC50ZXh0KHRpY2tlcltcXFwibGFzdFxcXCJdKTtcXG4gICAgICAgICAgICAgICAgICAgIHRpY2tlckVsZW1lbnQudG9nZ2xlQ2xhc3MoXFxcInRleHQtc3VjY2Vzc1xcXCIpO1xcbiAgICAgICAgICAgICAgICAgICAgdGlja2VySWNvbi50b2dnbGVDbGFzcyhcXFwiYmktYXJyb3ctdXAgdGV4dC1zdWNjZXNzXFxcIik7XFxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAodGlja2VyW1xcXCJsYXN0XFxcIl0gPCB0aGlzLm9sZFtzeW1ib2xdKSB7XFxuICAgICAgICAgICAgICAgICAgICB0aWNrZXJFbGVtZW50LnRleHQodGlja2VyW1xcXCJsYXN0XFxcIl0pO1xcbiAgICAgICAgICAgICAgICAgICAgdGlja2VyRWxlbWVudC50b2dnbGVDbGFzcyhcXFwidGV4dC1kYW5nZXJcXFwiKTtcXG4gICAgICAgICAgICAgICAgICAgIHRpY2tlckljb24udG9nZ2xlQ2xhc3MoXFxcImJpLWFycm93LWRvd24gdGV4dC1kYW5nZXJcXFwiKTtcXG4gICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgICAgICB0aGlzLm9sZFtzeW1ib2xdID0gdGlja2VyW1xcXCJsYXN0XFxcIl07XFxuICAgICAgICAgICAgICAgIGlmICghKHN5bWJvbCBpbiB0aGlzLmNoYW5nZUVsZW1lbnRzKSkge1xcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jaGFuZ2VFbGVtZW50c1tzeW1ib2xdID0gJChcXG4gICAgICAgICAgICAgICAgICAgICAgICBcXFwiLmNoYW5nZS1cXFwiICsgc3ltYm9sV2l0aG91dFNsYXNoXFxuICAgICAgICAgICAgICAgICAgICApO1xcbiAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgICAgIGNvbnN0IGNoYW5nZUVsZW1lbnQgPSB0aGlzLmNoYW5nZUVsZW1lbnRzW3N5bWJvbF07XFxuICAgICAgICAgICAgICAgIGlmICh0aWNrZXJbXFxcImNoYW5nZVxcXCJdID4gMCkge1xcbiAgICAgICAgICAgICAgICAgICAgY2hhbmdlRWxlbWVudC50ZXh0KFxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZm9ybWF0VG90YWwodGlja2VyW1xcXCJjaGFuZ2VcXFwiXSkgKyBcXFwiJVxcXCJcXG4gICAgICAgICAgICAgICAgICAgICk7XFxuICAgICAgICAgICAgICAgICAgICBjaGFuZ2VFbGVtZW50XFxuICAgICAgICAgICAgICAgICAgICAgICAgLmFkZENsYXNzKFxcXCJ0ZXh0LXN1Y2Nlc3NcXFwiKVxcbiAgICAgICAgICAgICAgICAgICAgICAgIC5yZW1vdmVDbGFzcyhcXFwidGV4dC1kYW5nZXJcXFwiKTtcXG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmICh0aWNrZXJbXFxcImNoYW5nZVxcXCJdIDwgMCkge1xcbiAgICAgICAgICAgICAgICAgICAgY2hhbmdlRWxlbWVudC50ZXh0KFxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZm9ybWF0VG90YWwodGlja2VyW1xcXCJjaGFuZ2VcXFwiXSkgKyBcXFwiJVxcXCJcXG4gICAgICAgICAgICAgICAgICAgICk7XFxuICAgICAgICAgICAgICAgICAgICBjaGFuZ2VFbGVtZW50XFxuICAgICAgICAgICAgICAgICAgICAgICAgLmFkZENsYXNzKFxcXCJ0ZXh0LWRhbmdlclxcXCIpXFxuICAgICAgICAgICAgICAgICAgICAgICAgLnJlbW92ZUNsYXNzKFxcXCJ0ZXh0LXN1Y2Nlc3NcXFwiKTtcXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgICAgICAgICAgIGNoYW5nZUVsZW1lbnQudGV4dChcXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmZvcm1hdFRvdGFsKHRpY2tlcltcXFwiY2hhbmdlXFxcIl0pICsgXFxcIiVcXFwiXFxuICAgICAgICAgICAgICAgICAgICApO1xcbiAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgfSxcXG5cXG4gICAgICAgIGFzeW5jIGxvb3AoKSB7XFxuICAgICAgICAgICAgd2hpbGUgKHRoaXMuc3RhdHVzID09IHRydWUpIHtcXG4gICAgICAgICAgICAgICAgaWYgKGRvY3VtZW50LmhpZGRlbikge1xcbiAgICAgICAgICAgICAgICAgICAgYXdhaXQgY2N4dC5zbGVlcCgxMDAwKTtcXG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xcbiAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgICAgIHRyeSB7XFxuICAgICAgICAgICAgICAgICAgICBjb25zdCB0aWNrZXJzID0gYXdhaXQgZXhjaGFuZ2UuZmV0Y2hUaWNrZXJzKCk7XFxuICAgICAgICAgICAgICAgICAgICB0aGlzLmhhbmRsZSh0aWNrZXJzKTtcXG4gICAgICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XFxuICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICB9XFxuICAgICAgICB9LFxcbiAgICAgICAgZm9ybWF0VG90YWwodG90YWwpIHtcXG4gICAgICAgICAgICByZXR1cm4gY2N4dC5kZWNpbWFsVG9QcmVjaXNpb24oXFxuICAgICAgICAgICAgICAgIHRvdGFsLFxcbiAgICAgICAgICAgICAgICBjY3h0LlJPVU5ELFxcbiAgICAgICAgICAgICAgICAzLFxcbiAgICAgICAgICAgICAgICBjY3h0LkRFQ0lNQUxfUExBQ0VTLFxcbiAgICAgICAgICAgICAgICBjY3h0LlBBRF9XSVRIX1pFUk9cXG4gICAgICAgICAgICApO1xcbiAgICAgICAgfSxcXG4gICAgICAgIGFzeW5jIHdzQ2xvc2UoKSB7XFxuICAgICAgICAgICAgdGhpcy5zdGF0dXMgPSBmYWxzZTtcXG4gICAgICAgICAgICBhd2FpdCBleGNoYW5nZS5jbG9zZSgpO1xcbiAgICAgICAgfSxcXG4gICAgfSxcXG5cXG4gICAgLy8gb24gY29tcG9uZW50IGNyZWF0ZWRcXG4gICAgY3JlYXRlZCgpIHtcXG4gICAgICAgIHRoaXMuZmV0Y2hGYXZzKCk7XFxuICAgICAgICB0aGlzLmZldGNoTWFya2V0cygpO1xcbiAgICB9LFxcblxcbiAgICAvLyBvbiBjb21wb25lbnQgbW91bnRlZFxcbiAgICBtb3VudGVkKCkge1xcbiAgICAgICAgdGhpcy5sb29wKCk7XFxuICAgIH0sXFxuICAgIC8vIG9uIGNvbXBvbmVudCBtb3VudGVkXFxuICAgIGJlZm9yZVVwZGF0ZSgpIHtcXG4gICAgICAgIHRoaXMucGFpcnMuZm9yRWFjaCgocGFpcikgPT4ge1xcbiAgICAgICAgICAgIHZhciB0cl9lbGVtZW50cyA9ICQoXFxcIi5jdXN0b20tZGF0YS10YWJsZS1cXFwiICsgcGFpciArIFxcXCIgdGJvZHkgdHJcXFwiKTtcXG4gICAgICAgICAgICAkKGRvY3VtZW50KS5vbihcXFwiaW5wdXRcXFwiLCBcXFwiaW5wdXRbbmFtZT1zZWFyY2hfdGFibGVdXFxcIiwgZnVuY3Rpb24gKCkge1xcbiAgICAgICAgICAgICAgICB2YXIgc2VhcmNoID0gJCh0aGlzKS52YWwoKS50b1VwcGVyQ2FzZSgpO1xcbiAgICAgICAgICAgICAgICB2YXIgbWF0Y2ggPSB0cl9lbGVtZW50c1xcbiAgICAgICAgICAgICAgICAgICAgLmZpbHRlcihmdW5jdGlvbiAoaWR4LCBlbGVtKSB7XFxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuICQoZWxlbSlcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLnRleHQoKVxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAudHJpbSgpXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC50b1VwcGVyQ2FzZSgpXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5pbmRleE9mKHNlYXJjaCkgPj0gMFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA/IGVsZW1cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgOiBudWxsO1xcbiAgICAgICAgICAgICAgICAgICAgfSlcXG4gICAgICAgICAgICAgICAgICAgIC5zb3J0KCk7XFxuICAgICAgICAgICAgICAgIHZhciB0YWJsZV9jb250ZW50ID0gJChcXFwiLmN1c3RvbS1kYXRhLXRhYmxlLVxcXCIgKyBwYWlyICsgXFxcIiB0Ym9keVxcXCIpO1xcbiAgICAgICAgICAgICAgICBpZiAobWF0Y2gubGVuZ3RoID09IDApIHtcXG4gICAgICAgICAgICAgICAgICAgIHRhYmxlX2NvbnRlbnQuaHRtbChcXG4gICAgICAgICAgICAgICAgICAgICAgICAnPHRyPjx0ZCBjb2xzcGFuPVxcXCIxMDAlXFxcIiBjbGFzcz1cXFwidGV4dC1jZW50ZXJcXFwiPkRhdGEgTm90IEZvdW5kPC90ZD48L3RyPidcXG4gICAgICAgICAgICAgICAgICAgICk7XFxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgICAgICAgICAgICB0YWJsZV9jb250ZW50Lmh0bWwobWF0Y2gpO1xcbiAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgfSk7XFxuICAgICAgICB9KTtcXG4gICAgICAgIHZhciB0cl9lbGVtZW50cyA9ICQoXFxcIi5jdXN0b20tZGF0YS10YWJsZS1mYXYgdGJvZHkgdHJcXFwiKTtcXG4gICAgICAgICQoZG9jdW1lbnQpLm9uKFxcXCJpbnB1dFxcXCIsIFxcXCJpbnB1dFtuYW1lPXNlYXJjaF90YWJsZV9mYXZdXFxcIiwgZnVuY3Rpb24gKCkge1xcbiAgICAgICAgICAgIHZhciBzZWFyY2ggPSAkKHRoaXMpLnZhbCgpLnRvVXBwZXJDYXNlKCk7XFxuICAgICAgICAgICAgdmFyIG1hdGNoID0gdHJfZWxlbWVudHNcXG4gICAgICAgICAgICAgICAgLmZpbHRlcihmdW5jdGlvbiAoaWR4LCBlbGVtKSB7XFxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gJChlbGVtKVxcbiAgICAgICAgICAgICAgICAgICAgICAgIC50ZXh0KClcXG4gICAgICAgICAgICAgICAgICAgICAgICAudHJpbSgpXFxuICAgICAgICAgICAgICAgICAgICAgICAgLnRvVXBwZXJDYXNlKClcXG4gICAgICAgICAgICAgICAgICAgICAgICAuaW5kZXhPZihzZWFyY2gpID49IDBcXG4gICAgICAgICAgICAgICAgICAgICAgICA/IGVsZW1cXG4gICAgICAgICAgICAgICAgICAgICAgICA6IG51bGw7XFxuICAgICAgICAgICAgICAgIH0pXFxuICAgICAgICAgICAgICAgIC5zb3J0KCk7XFxuICAgICAgICAgICAgdmFyIHRhYmxlX2NvbnRlbnQgPSAkKFxcXCIuY3VzdG9tLWRhdGEtdGFibGUtZmF2IHRib2R5XFxcIik7XFxuICAgICAgICAgICAgaWYgKG1hdGNoLmxlbmd0aCA9PSAwKSB7XFxuICAgICAgICAgICAgICAgIHRhYmxlX2NvbnRlbnQuaHRtbChcXG4gICAgICAgICAgICAgICAgICAgICc8dHI+PHRkIGNvbHNwYW49XFxcIjEwMCVcXFwiIGNsYXNzPVxcXCJ0ZXh0LWNlbnRlclxcXCI+RGF0YSBOb3QgRm91bmQ8L3RkPjwvdHI+J1xcbiAgICAgICAgICAgICAgICApO1xcbiAgICAgICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgICAgICAgIHRhYmxlX2NvbnRlbnQuaHRtbChtYXRjaCk7XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgfSk7XFxuICAgIH0sXFxuICAgIHVubW91bnRlZCgpIHtcXG4gICAgICAgIHRoaXMud3NDbG9zZSgpO1xcbiAgICB9LFxcbiAgICAvLyBvbiBjb21wb25lbnQgZGVzdHJveWVkXFxuICAgIGRlc3Ryb3llZCgpIHtcXG4gICAgICAgIHRoaXMud3NDbG9zZSgpO1xcbiAgICB9LFxcbn07XFxuPC9zY3JpcHQ+XFxuPHN0eWxlPlxcbi5ub3Qtd2F0Y2hsaXN0ZWQ6aG92ZXIgLmJpLXN0YXIge1xcbiAgICBjb2xvcjogcmdiKDI1NSwgMTU5LCA2NykgIWltcG9ydGFudDtcXG59XFxuLndhdGNobGlzdGVkOmhvdmVyIC5iaS1zdGFyLWZpbGwge1xcbiAgICBjb2xvcjogcmdiKDEzMCwgMTM0LCAxMzkpICFpbXBvcnRhbnQ7XFxufVxcbjwvc3R5bGU+XFxuXCJdLFwic291cmNlUm9vdFwiOlwiXCJ9XSk7XG4vLyBFeHBvcnRzXG5leHBvcnQgZGVmYXVsdCBfX19DU1NfTE9BREVSX0VYUE9SVF9fXztcbiIsIi8vIEltcG9ydHNcbmltcG9ydCBfX19DU1NfTE9BREVSX0FQSV9TT1VSQ0VNQVBfSU1QT1JUX19fIGZyb20gXCIuLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvbGFyYXZlbC1taXgvbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvZGlzdC9ydW50aW1lL2Nzc1dpdGhNYXBwaW5nVG9TdHJpbmcuanNcIjtcbmltcG9ydCBfX19DU1NfTE9BREVSX0FQSV9JTVBPUlRfX18gZnJvbSBcIi4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9sYXJhdmVsLW1peC9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9kaXN0L3J1bnRpbWUvYXBpLmpzXCI7XG52YXIgX19fQ1NTX0xPQURFUl9FWFBPUlRfX18gPSBfX19DU1NfTE9BREVSX0FQSV9JTVBPUlRfX18oX19fQ1NTX0xPQURFUl9BUElfU09VUkNFTUFQX0lNUE9SVF9fXyk7XG4vLyBNb2R1bGVcbl9fX0NTU19MT0FERVJfRVhQT1JUX19fLnB1c2goW21vZHVsZS5pZCwgXCI6cm9vdCB7XFxuICAtLXRoZW1lLWJhY2tncm91bmQtYmFzZTogIzE3MWIyOTtcXG4gIC0tdGhlbWUtYmFja2dyb3VuZC0zMDA6ICNkNmRhZTg7XFxuICAtLXRoZW1lLWJhY2tncm91bmQtbzc1OiByZ2JhKDQxLCA0OSwgNzQsIDAuNzUpO1xcbiAgLS10aGVtZS1iYWNrZ3JvdW5kLW8yMDogcmdiYSg0MSwgNDksIDc0LCAwLjIpO1xcbiAgLS10aGVtZS1jb2xvci1vNzU6IHJnYmEoMjEzLCAyNDAsIDIzMywgMC43NSk7XFxufVxcbnRhYmxlIHtcXG4gIGJvcmRlci1jb2xsYXBzZTogY29sbGFwc2U7XFxuICB3aWR0aDogMTAwJTtcXG4gIGZvbnQtc2l6ZTogMTFweDtcXG4gIGZvbnQtd2VpZ2h0OiA1MDA7XFxuICBjb2xvcjogI2I3YmRjNjtcXG4gIG92ZXJmbG93OiBoaWRkZW47XFxuICB3aWR0aDogMTAwJTtcXG59XFxuLnRkZCB7XFxuICBwb3NpdGlvbjogcmVsYXRpdmU7XFxuICBoZWlnaHQ6IDE4cHg7XFxuICBsaW5lLWhlaWdodDogMThweDtcXG59XFxudGQge1xcbiAgaGVpZ2h0OiAxMnB4O1xcbiAgbGluZS1oZWlnaHQ6IDEycHg7XFxufVxcbnRkIHNwYW4ge1xcbiAgcG9zaXRpb246IHJlbGF0aXZlO1xcbiAgei1pbmRleDogMjtcXG59XFxudGQgLnBlcmNlbnQge1xcbiAgcG9zaXRpb246IGFic29sdXRlO1xcbiAgdG9wOiAwO1xcbiAgYm90dG9tOiAwO1xcbn1cXG5bZGlyPWx0cl0gdGQgLnBlcmNlbnQge1xcbiAgcmlnaHQ6IDA7XFxufVxcbltkaXI9cnRsXSB0ZCAucGVyY2VudCB7XFxuICBsZWZ0OiAwO1xcbn1cXG50ZC5wcmljZSB7XFxuICB3aWR0aDogMzAlO1xcbn1cXG5bZGlyPWx0cl0gdGQucHJpY2Ugc3BhbiB7XFxuICBwYWRkaW5nLWxlZnQ6IDVweDtcXG59XFxuW2Rpcj1ydGxdIHRkLnByaWNlIHNwYW4ge1xcbiAgcGFkZGluZy1yaWdodDogNXB4O1xcbn1cXG50ZC5xdWFudGl0eSB7XFxuICB3aWR0aDogMzAlO1xcbn1cXG5bZGlyPWx0cl0gdGQucXVhbnRpdHkge1xcbiAgdGV4dC1hbGlnbjogcmlnaHQ7XFxufVxcbltkaXI9cnRsXSB0ZC5xdWFudGl0eSB7XFxuICB0ZXh0LWFsaWduOiBsZWZ0O1xcbn1cXG50ZC50aW1lIHtcXG4gIHdpZHRoOiA0MCU7XFxuICBjb2xvcjogIzk5OTtcXG59XFxuW2Rpcj1sdHJdIHRkLnRpbWUge1xcbiAgdGV4dC1hbGlnbjogcmlnaHQ7XFxuICBwYWRkaW5nLXJpZ2h0OiA1cHg7XFxufVxcbltkaXI9cnRsXSB0ZC50aW1lIHtcXG4gIHRleHQtYWxpZ246IGxlZnQ7XFxuICBwYWRkaW5nLWxlZnQ6IDVweDtcXG59XFxudGQuYnRjIHtcXG4gIHdpZHRoOiA0MCU7XFxufVxcbltkaXI9bHRyXSB0ZC5idGMge1xcbiAgdGV4dC1hbGlnbjogcmlnaHQ7XFxuICBwYWRkaW5nLXJpZ2h0OiA1cHg7XFxufVxcbltkaXI9cnRsXSB0ZC5idGMge1xcbiAgdGV4dC1hbGlnbjogbGVmdDtcXG4gIHBhZGRpbmctbGVmdDogNXB4O1xcbn1cXG5bZGlyXSB0YWJsZS5hc2tzIC5wZXJjZW50IHtcXG4gIGJhY2tncm91bmQtY29sb3I6IHJnYmEoMjQ2LCA3MCwgOTQsIDAuMik7XFxufVxcbltkaXJdIHRhYmxlLmJpZHMgLnBlcmNlbnQge1xcbiAgYmFja2dyb3VuZC1jb2xvcjogcmdiYSgxNCwgMjAzLCAxMjksIDAuMik7XFxufVxcbltkaXJdIHRhYmxlLmFza3Nfb25seSAucGVyY2VudCB7XFxuICBiYWNrZ3JvdW5kLWNvbG9yOiByZ2JhKDI0NiwgNzAsIDk0LCAwLjIpO1xcbn1cXG5bZGlyXSB0YWJsZS5iaWRzX29ubHkgLnBlcmNlbnQge1xcbiAgYmFja2dyb3VuZC1jb2xvcjogcmdiYSgxNCwgMjAzLCAxMjksIDAuMik7XFxufVxcbi5vcmRlci1sb2FkZXIge1xcbiAgcG9zaXRpb246IHJlbGF0aXZlO1xcbiAgdG9wOiAxMjBweDtcXG4gIHdpZHRoOiAxMDAlO1xcbiAgaGVpZ2h0OiAxMDAlO1xcbiAgei1pbmRleDogOTk5OTtcXG59XFxuW2Rpcl0gLm9yZGVyLWxvYWRlciB7XFxuICBiYWNrZ3JvdW5kOiByZ2JhKDAsIDAsIDAsIDAuNzA5ODAzOTIxNik7XFxufVxcbltkaXI9bHRyXSAub3JkZXItbG9hZGVyIHtcXG4gIHJpZ2h0OiAwcHg7XFxufVxcbltkaXI9cnRsXSAub3JkZXItbG9hZGVyIHtcXG4gIGxlZnQ6IDBweDtcXG59XFxuLnNlLXByZS1jb24yIHtcXG4gIHBvc2l0aW9uOiBhYnNvbHV0ZTtcXG4gIHRvcDogNTAlO1xcbn1cXG5bZGlyPWx0cl0gLnNlLXByZS1jb24yIHtcXG4gIGxlZnQ6IDUwJTtcXG59XFxuW2Rpcj1ydGxdIC5zZS1wcmUtY29uMiB7XFxuICByaWdodDogNTAlO1xcbn1cXG4uaGlkZGVuIHtcXG4gIGRpc3BsYXk6IG5vbmU7XFxufVxcbkBtZWRpYSAobWF4LXdpZHRoOiA3NjcuOThweCkge1xcbmh0bWxbZGlyXSBib2R5Lm5hdmJhci1zdGlja3kgLmFwcC1jb250ZW50IHtcXG4gICAgcGFkZGluZzogNC42NXJlbSAwIDAgMCAhaW1wb3J0YW50O1xcbn1cXG59XCIsIFwiXCIse1widmVyc2lvblwiOjMsXCJzb3VyY2VzXCI6W1wid2VicGFjazovLy4vcmVzb3VyY2VzL3NyYy9QYWdlcy9ib3QvQm90VHJhZGVQYWdlLnZ1ZVwiXSxcIm5hbWVzXCI6W10sXCJtYXBwaW5nc1wiOlwiQUFBQTtFQUNFLGdDQUFBO0VBQ0EsK0JBQUE7RUFDQSw4Q0FBQTtFQUNBLDZDQUFBO0VBQ0EsNENBQUE7QUFDRjtBQUVBO0VBQ0UseUJBQUE7RUFDQSxXQUFBO0VBQ0EsZUFBQTtFQUNBLGdCQUFBO0VBQ0EsY0FBQTtFQUNBLGdCQUFBO0VBQ0EsV0FBQTtBQUNGO0FBRUE7RUFDRSxrQkFBQTtFQUNBLFlBQUE7RUFDQSxpQkFBQTtBQUNGO0FBRUE7RUFDRSxZQUFBO0VBQ0EsaUJBQUE7QUFDRjtBQUNBO0VBQ0Usa0JBQUE7RUFDQSxVQUFBO0FBRUY7QUFBQTtFQUNFLGtCQUFBO0VBQ0EsTUFBQTtFQUNBLFNBQUE7QUFJRjtBQVBBO0VBSUUsUUFBQTtBQUdGO0FBUEE7RUFJRSxPQUFBO0FBR0Y7QUFBQTtFQUNFLFVBQUE7QUFHRjtBQURBO0VBQ0UsaUJBQUE7QUFJRjtBQUxBO0VBQ0Usa0JBQUE7QUFJRjtBQURBO0VBQ0UsVUFBQTtBQUtGO0FBTkE7RUFFRSxpQkFBQTtBQUlGO0FBTkE7RUFFRSxnQkFBQTtBQUlGO0FBREE7RUFDRSxVQUFBO0VBRUEsV0FBQTtBQUtGO0FBUkE7RUFFRSxpQkFBQTtFQUVBLGtCQUFBO0FBSUY7QUFSQTtFQUVFLGdCQUFBO0VBRUEsaUJBQUE7QUFJRjtBQURBO0VBQ0UsVUFBQTtBQU1GO0FBUEE7RUFFRSxpQkFBQTtFQUNBLGtCQUFBO0FBSUY7QUFQQTtFQUVFLGdCQUFBO0VBQ0EsaUJBQUE7QUFJRjtBQURBO0VBQ0Usd0NBQUE7QUFJRjtBQURBO0VBQ0UseUNBQUE7QUFJRjtBQURBO0VBQ0Usd0NBQUE7QUFJRjtBQURBO0VBQ0UseUNBQUE7QUFJRjtBQURBO0VBQ0Usa0JBQUE7RUFFQSxVQUFBO0VBQ0EsV0FBQTtFQUNBLFlBQUE7RUFDQSxhQUFBO0FBS0Y7QUFYQTtFQU9FLHVDQUFBO0FBSUY7QUFYQTtFQUVFLFVBQUE7QUFTRjtBQVhBO0VBRUUsU0FBQTtBQVNGO0FBREE7RUFDRSxrQkFBQTtFQUNBLFFBQUE7QUFLRjtBQVBBO0VBR0UsU0FBQTtBQUlGO0FBUEE7RUFHRSxVQUFBO0FBSUY7QUFEQTtFQUNFLGFBQUE7QUFJRjtBQURBO0FBQ0U7SUFDRSxpQ0FBQTtBQUlGO0FBQ0ZcIixcInNvdXJjZXNDb250ZW50XCI6W1wiOnJvb3Qge1xcbiAgLS10aGVtZS1iYWNrZ3JvdW5kLWJhc2U6ICMxNzFiMjk7XFxuICAtLXRoZW1lLWJhY2tncm91bmQtMzAwOiAjZDZkYWU4O1xcbiAgLS10aGVtZS1iYWNrZ3JvdW5kLW83NTogcmdiYSg0MSwgNDksIDc0LCAwLjc1KTtcXG4gIC0tdGhlbWUtYmFja2dyb3VuZC1vMjA6IHJnYmEoNDEsIDQ5LCA3NCwgMC4yKTtcXG4gIC0tdGhlbWUtY29sb3Itbzc1OiByZ2JhKDIxMywgMjQwLCAyMzMsIDAuNzUpO1xcbn1cXG5cXG50YWJsZSB7XFxuICBib3JkZXItY29sbGFwc2U6IGNvbGxhcHNlO1xcbiAgd2lkdGg6IDEwMCU7XFxuICBmb250LXNpemU6IDExcHg7XFxuICBmb250LXdlaWdodDogNTAwO1xcbiAgY29sb3I6ICNiN2JkYzY7XFxuICBvdmVyZmxvdzogaGlkZGVuO1xcbiAgd2lkdGg6IDEwMCU7XFxufVxcblxcbi50ZGQge1xcbiAgcG9zaXRpb246IHJlbGF0aXZlO1xcbiAgaGVpZ2h0OiAxOHB4O1xcbiAgbGluZS1oZWlnaHQ6IDE4cHg7XFxufVxcblxcbnRkIHtcXG4gIGhlaWdodDogMTJweDtcXG4gIGxpbmUtaGVpZ2h0OiAxMnB4O1xcbn1cXG50ZCBzcGFuIHtcXG4gIHBvc2l0aW9uOiByZWxhdGl2ZTtcXG4gIHotaW5kZXg6IDI7XFxufVxcbnRkIC5wZXJjZW50IHtcXG4gIHBvc2l0aW9uOiBhYnNvbHV0ZTtcXG4gIHRvcDogMDtcXG4gIGJvdHRvbTogMDtcXG4gIHJpZ2h0OiAwO1xcbn1cXG5cXG50ZC5wcmljZSB7XFxuICB3aWR0aDogMzAlO1xcbn1cXG50ZC5wcmljZSBzcGFuIHtcXG4gIHBhZGRpbmctbGVmdDogNXB4O1xcbn1cXG5cXG50ZC5xdWFudGl0eSB7XFxuICB3aWR0aDogMzAlO1xcbiAgdGV4dC1hbGlnbjogcmlnaHQ7XFxufVxcblxcbnRkLnRpbWUge1xcbiAgd2lkdGg6IDQwJTtcXG4gIHRleHQtYWxpZ246IHJpZ2h0O1xcbiAgY29sb3I6ICM5OTk7XFxuICBwYWRkaW5nLXJpZ2h0OiA1cHg7XFxufVxcblxcbnRkLmJ0YyB7XFxuICB3aWR0aDogNDAlO1xcbiAgdGV4dC1hbGlnbjogcmlnaHQ7XFxuICBwYWRkaW5nLXJpZ2h0OiA1cHg7XFxufVxcblxcbnRhYmxlLmFza3MgLnBlcmNlbnQge1xcbiAgYmFja2dyb3VuZC1jb2xvcjogcmdiYSgyNDYsIDcwLCA5NCwgMC4yKTtcXG59XFxuXFxudGFibGUuYmlkcyAucGVyY2VudCB7XFxuICBiYWNrZ3JvdW5kLWNvbG9yOiByZ2JhKDE0LCAyMDMsIDEyOSwgMC4yKTtcXG59XFxuXFxudGFibGUuYXNrc19vbmx5IC5wZXJjZW50IHtcXG4gIGJhY2tncm91bmQtY29sb3I6IHJnYmEoMjQ2LCA3MCwgOTQsIDAuMik7XFxufVxcblxcbnRhYmxlLmJpZHNfb25seSAucGVyY2VudCB7XFxuICBiYWNrZ3JvdW5kLWNvbG9yOiByZ2JhKDE0LCAyMDMsIDEyOSwgMC4yKTtcXG59XFxuXFxuLm9yZGVyLWxvYWRlciB7XFxuICBwb3NpdGlvbjogcmVsYXRpdmU7XFxuICByaWdodDogMHB4O1xcbiAgdG9wOiAxMjBweDtcXG4gIHdpZHRoOiAxMDAlO1xcbiAgaGVpZ2h0OiAxMDAlO1xcbiAgei1pbmRleDogOTk5OTtcXG4gIGJhY2tncm91bmQ6IHJnYmEoMCwgMCwgMCwgMC43MDk4MDM5MjE2KTtcXG59XFxuXFxuLnNlLXByZS1jb24yIHtcXG4gIHBvc2l0aW9uOiBhYnNvbHV0ZTtcXG4gIHRvcDogNTAlO1xcbiAgbGVmdDogNTAlO1xcbn1cXG5cXG4uaGlkZGVuIHtcXG4gIGRpc3BsYXk6IG5vbmU7XFxufVxcblxcbkBtZWRpYSAobWF4LXdpZHRoOiA3NjcuOThweCkge1xcbiAgaHRtbCBib2R5Lm5hdmJhci1zdGlja3kgLmFwcC1jb250ZW50IHtcXG4gICAgcGFkZGluZzogNC42NXJlbSAwIDAgMCAhaW1wb3J0YW50O1xcbiAgfVxcbn1cIl0sXCJzb3VyY2VSb290XCI6XCJcIn1dKTtcbi8vIEV4cG9ydHNcbmV4cG9ydCBkZWZhdWx0IF9fX0NTU19MT0FERVJfRVhQT1JUX19fO1xuIiwiaW1wb3J0IGFwaSBmcm9tIFwiIS4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9zdHlsZS1sb2FkZXIvZGlzdC9ydW50aW1lL2luamVjdFN0eWxlc0ludG9TdHlsZVRhZy5qc1wiO1xuICAgICAgICAgICAgaW1wb3J0IGNvbnRlbnQgZnJvbSBcIiEhLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2xhcmF2ZWwtbWl4L25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2Rpc3QvY2pzLmpzPz9jbG9uZWRSdWxlU2V0LTY5WzBdLnJ1bGVzWzBdLnVzZVsxXSEuLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvbG9hZGVycy9zdHlsZVBvc3RMb2FkZXIuanMhLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2xhcmF2ZWwtbWl4L25vZGVfbW9kdWxlcy9wb3N0Y3NzLWxvYWRlci9kaXN0L2Nqcy5qcz8/Y2xvbmVkUnVsZVNldC02OVswXS5ydWxlc1swXS51c2VbMl0hLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL2luZGV4LmpzPz92dWUtbG9hZGVyLW9wdGlvbnMhLi9NYXJrZXRzLnZ1ZT92dWUmdHlwZT1zdHlsZSZpbmRleD0wJmxhbmc9Y3NzJlwiO1xuXG52YXIgb3B0aW9ucyA9IHt9O1xuXG5vcHRpb25zLmluc2VydCA9IFwiaGVhZFwiO1xub3B0aW9ucy5zaW5nbGV0b24gPSBmYWxzZTtcblxudmFyIHVwZGF0ZSA9IGFwaShjb250ZW50LCBvcHRpb25zKTtcblxuXG5cbmV4cG9ydCBkZWZhdWx0IGNvbnRlbnQubG9jYWxzIHx8IHt9OyIsImltcG9ydCBhcGkgZnJvbSBcIiEuLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvc3R5bGUtbG9hZGVyL2Rpc3QvcnVudGltZS9pbmplY3RTdHlsZXNJbnRvU3R5bGVUYWcuanNcIjtcbiAgICAgICAgICAgIGltcG9ydCBjb250ZW50IGZyb20gXCIhIS4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9sYXJhdmVsLW1peC9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9kaXN0L2Nqcy5qcz8/Y2xvbmVkUnVsZVNldC03MlswXS5ydWxlc1swXS51c2VbMV0hLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL2xvYWRlcnMvc3R5bGVQb3N0TG9hZGVyLmpzIS4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9sYXJhdmVsLW1peC9ub2RlX21vZHVsZXMvcG9zdGNzcy1sb2FkZXIvZGlzdC9janMuanM/P2Nsb25lZFJ1bGVTZXQtNzJbMF0ucnVsZXNbMF0udXNlWzJdIS4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9zYXNzLWxvYWRlci9kaXN0L2Nqcy5qcz8/Y2xvbmVkUnVsZVNldC03MlswXS5ydWxlc1swXS51c2VbM10hLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3Nhc3MtbG9hZGVyL2Rpc3QvY2pzLmpzPz9jbG9uZWRSdWxlU2V0LTgyWzBdLnJ1bGVzWzBdLnVzZVswXSEuLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvaW5kZXguanM/P3Z1ZS1sb2FkZXItb3B0aW9ucyEuL0JvdFRyYWRlUGFnZS52dWU/dnVlJnR5cGU9c3R5bGUmaW5kZXg9MCZsYW5nPXNjc3Mmc2NvcGU9dHJ1ZSZcIjtcblxudmFyIG9wdGlvbnMgPSB7fTtcblxub3B0aW9ucy5pbnNlcnQgPSBcImhlYWRcIjtcbm9wdGlvbnMuc2luZ2xldG9uID0gZmFsc2U7XG5cbnZhciB1cGRhdGUgPSBhcGkoY29udGVudCwgb3B0aW9ucyk7XG5cblxuXG5leHBvcnQgZGVmYXVsdCBjb250ZW50LmxvY2FscyB8fCB7fTsiLCIvKiEgdnVlLWdyaWQtbGF5b3V0IC0gMi4zLjEyIHwgKGMpIDIwMTUsIDIwMjEgIEd1c3Rhdm8gU2FudG9zIChKQmF5IFNvbHV0aW9ucykgPGd1c3Rhdm8uc2FudG9zQGpiYXlzb2x1dGlvbnMuY29tPiAoaHR0cDovL3d3dy5qYmF5c29sdXRpb25zLmNvbSkgfCBodHRwczovL2dpdGh1Yi5jb20vamJheXNvbHV0aW9ucy92dWUtZ3JpZC1sYXlvdXQgKi9cbm1vZHVsZS5leHBvcnRzID1cbi8qKioqKiovIChmdW5jdGlvbihtb2R1bGVzKSB7IC8vIHdlYnBhY2tCb290c3RyYXBcbi8qKioqKiovIFx0Ly8gVGhlIG1vZHVsZSBjYWNoZVxuLyoqKioqKi8gXHR2YXIgaW5zdGFsbGVkTW9kdWxlcyA9IHt9O1xuLyoqKioqKi9cbi8qKioqKiovIFx0Ly8gVGhlIHJlcXVpcmUgZnVuY3Rpb25cbi8qKioqKiovIFx0ZnVuY3Rpb24gX193ZWJwYWNrX3JlcXVpcmVfXyhtb2R1bGVJZCkge1xuLyoqKioqKi9cbi8qKioqKiovIFx0XHQvLyBDaGVjayBpZiBtb2R1bGUgaXMgaW4gY2FjaGVcbi8qKioqKiovIFx0XHRpZihpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSkge1xuLyoqKioqKi8gXHRcdFx0cmV0dXJuIGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdLmV4cG9ydHM7XG4vKioqKioqLyBcdFx0fVxuLyoqKioqKi8gXHRcdC8vIENyZWF0ZSBhIG5ldyBtb2R1bGUgKGFuZCBwdXQgaXQgaW50byB0aGUgY2FjaGUpXG4vKioqKioqLyBcdFx0dmFyIG1vZHVsZSA9IGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdID0ge1xuLyoqKioqKi8gXHRcdFx0aTogbW9kdWxlSWQsXG4vKioqKioqLyBcdFx0XHRsOiBmYWxzZSxcbi8qKioqKiovIFx0XHRcdGV4cG9ydHM6IHt9XG4vKioqKioqLyBcdFx0fTtcbi8qKioqKiovXG4vKioqKioqLyBcdFx0Ly8gRXhlY3V0ZSB0aGUgbW9kdWxlIGZ1bmN0aW9uXG4vKioqKioqLyBcdFx0bW9kdWxlc1ttb2R1bGVJZF0uY2FsbChtb2R1bGUuZXhwb3J0cywgbW9kdWxlLCBtb2R1bGUuZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXyk7XG4vKioqKioqL1xuLyoqKioqKi8gXHRcdC8vIEZsYWcgdGhlIG1vZHVsZSBhcyBsb2FkZWRcbi8qKioqKiovIFx0XHRtb2R1bGUubCA9IHRydWU7XG4vKioqKioqL1xuLyoqKioqKi8gXHRcdC8vIFJldHVybiB0aGUgZXhwb3J0cyBvZiB0aGUgbW9kdWxlXG4vKioqKioqLyBcdFx0cmV0dXJuIG1vZHVsZS5leHBvcnRzO1xuLyoqKioqKi8gXHR9XG4vKioqKioqL1xuLyoqKioqKi9cbi8qKioqKiovIFx0Ly8gZXhwb3NlIHRoZSBtb2R1bGVzIG9iamVjdCAoX193ZWJwYWNrX21vZHVsZXNfXylcbi8qKioqKiovIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5tID0gbW9kdWxlcztcbi8qKioqKiovXG4vKioqKioqLyBcdC8vIGV4cG9zZSB0aGUgbW9kdWxlIGNhY2hlXG4vKioqKioqLyBcdF9fd2VicGFja19yZXF1aXJlX18uYyA9IGluc3RhbGxlZE1vZHVsZXM7XG4vKioqKioqL1xuLyoqKioqKi8gXHQvLyBkZWZpbmUgZ2V0dGVyIGZ1bmN0aW9uIGZvciBoYXJtb255IGV4cG9ydHNcbi8qKioqKiovIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5kID0gZnVuY3Rpb24oZXhwb3J0cywgbmFtZSwgZ2V0dGVyKSB7XG4vKioqKioqLyBcdFx0aWYoIV9fd2VicGFja19yZXF1aXJlX18ubyhleHBvcnRzLCBuYW1lKSkge1xuLyoqKioqKi8gXHRcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIG5hbWUsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBnZXR0ZXIgfSk7XG4vKioqKioqLyBcdFx0fVxuLyoqKioqKi8gXHR9O1xuLyoqKioqKi9cbi8qKioqKiovIFx0Ly8gZGVmaW5lIF9fZXNNb2R1bGUgb24gZXhwb3J0c1xuLyoqKioqKi8gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLnIgPSBmdW5jdGlvbihleHBvcnRzKSB7XG4vKioqKioqLyBcdFx0aWYodHlwZW9mIFN5bWJvbCAhPT0gJ3VuZGVmaW5lZCcgJiYgU3ltYm9sLnRvU3RyaW5nVGFnKSB7XG4vKioqKioqLyBcdFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgU3ltYm9sLnRvU3RyaW5nVGFnLCB7IHZhbHVlOiAnTW9kdWxlJyB9KTtcbi8qKioqKiovIFx0XHR9XG4vKioqKioqLyBcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcbi8qKioqKiovIFx0fTtcbi8qKioqKiovXG4vKioqKioqLyBcdC8vIGNyZWF0ZSBhIGZha2UgbmFtZXNwYWNlIG9iamVjdFxuLyoqKioqKi8gXHQvLyBtb2RlICYgMTogdmFsdWUgaXMgYSBtb2R1bGUgaWQsIHJlcXVpcmUgaXRcbi8qKioqKiovIFx0Ly8gbW9kZSAmIDI6IG1lcmdlIGFsbCBwcm9wZXJ0aWVzIG9mIHZhbHVlIGludG8gdGhlIG5zXG4vKioqKioqLyBcdC8vIG1vZGUgJiA0OiByZXR1cm4gdmFsdWUgd2hlbiBhbHJlYWR5IG5zIG9iamVjdFxuLyoqKioqKi8gXHQvLyBtb2RlICYgOHwxOiBiZWhhdmUgbGlrZSByZXF1aXJlXG4vKioqKioqLyBcdF9fd2VicGFja19yZXF1aXJlX18udCA9IGZ1bmN0aW9uKHZhbHVlLCBtb2RlKSB7XG4vKioqKioqLyBcdFx0aWYobW9kZSAmIDEpIHZhbHVlID0gX193ZWJwYWNrX3JlcXVpcmVfXyh2YWx1ZSk7XG4vKioqKioqLyBcdFx0aWYobW9kZSAmIDgpIHJldHVybiB2YWx1ZTtcbi8qKioqKiovIFx0XHRpZigobW9kZSAmIDQpICYmIHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcgJiYgdmFsdWUgJiYgdmFsdWUuX19lc01vZHVsZSkgcmV0dXJuIHZhbHVlO1xuLyoqKioqKi8gXHRcdHZhciBucyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4vKioqKioqLyBcdFx0X193ZWJwYWNrX3JlcXVpcmVfXy5yKG5zKTtcbi8qKioqKiovIFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkobnMsICdkZWZhdWx0JywgeyBlbnVtZXJhYmxlOiB0cnVlLCB2YWx1ZTogdmFsdWUgfSk7XG4vKioqKioqLyBcdFx0aWYobW9kZSAmIDIgJiYgdHlwZW9mIHZhbHVlICE9ICdzdHJpbmcnKSBmb3IodmFyIGtleSBpbiB2YWx1ZSkgX193ZWJwYWNrX3JlcXVpcmVfXy5kKG5zLCBrZXksIGZ1bmN0aW9uKGtleSkgeyByZXR1cm4gdmFsdWVba2V5XTsgfS5iaW5kKG51bGwsIGtleSkpO1xuLyoqKioqKi8gXHRcdHJldHVybiBucztcbi8qKioqKiovIFx0fTtcbi8qKioqKiovXG4vKioqKioqLyBcdC8vIGdldERlZmF1bHRFeHBvcnQgZnVuY3Rpb24gZm9yIGNvbXBhdGliaWxpdHkgd2l0aCBub24taGFybW9ueSBtb2R1bGVzXG4vKioqKioqLyBcdF9fd2VicGFja19yZXF1aXJlX18ubiA9IGZ1bmN0aW9uKG1vZHVsZSkge1xuLyoqKioqKi8gXHRcdHZhciBnZXR0ZXIgPSBtb2R1bGUgJiYgbW9kdWxlLl9fZXNNb2R1bGUgP1xuLyoqKioqKi8gXHRcdFx0ZnVuY3Rpb24gZ2V0RGVmYXVsdCgpIHsgcmV0dXJuIG1vZHVsZVsnZGVmYXVsdCddOyB9IDpcbi8qKioqKiovIFx0XHRcdGZ1bmN0aW9uIGdldE1vZHVsZUV4cG9ydHMoKSB7IHJldHVybiBtb2R1bGU7IH07XG4vKioqKioqLyBcdFx0X193ZWJwYWNrX3JlcXVpcmVfXy5kKGdldHRlciwgJ2EnLCBnZXR0ZXIpO1xuLyoqKioqKi8gXHRcdHJldHVybiBnZXR0ZXI7XG4vKioqKioqLyBcdH07XG4vKioqKioqL1xuLyoqKioqKi8gXHQvLyBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGxcbi8qKioqKiovIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5vID0gZnVuY3Rpb24ob2JqZWN0LCBwcm9wZXJ0eSkgeyByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwgcHJvcGVydHkpOyB9O1xuLyoqKioqKi9cbi8qKioqKiovIFx0Ly8gX193ZWJwYWNrX3B1YmxpY19wYXRoX19cbi8qKioqKiovIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5wID0gXCJcIjtcbi8qKioqKiovXG4vKioqKioqL1xuLyoqKioqKi8gXHQvLyBMb2FkIGVudHJ5IG1vZHVsZSBhbmQgcmV0dXJuIGV4cG9ydHNcbi8qKioqKiovIFx0cmV0dXJuIF9fd2VicGFja19yZXF1aXJlX18oX193ZWJwYWNrX3JlcXVpcmVfXy5zID0gXCJmYjE1XCIpO1xuLyoqKioqKi8gfSlcbi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKioqKioqLyAoe1xuXG4vKioqLyBcIjAxZjlcIjpcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBMSUJSQVJZID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIjJkMDBcIik7XG52YXIgJGV4cG9ydCA9IF9fd2VicGFja19yZXF1aXJlX18oXCI1Y2ExXCIpO1xudmFyIHJlZGVmaW5lID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIjJhYmFcIik7XG52YXIgaGlkZSA9IF9fd2VicGFja19yZXF1aXJlX18oXCIzMmU5XCIpO1xudmFyIEl0ZXJhdG9ycyA9IF9fd2VicGFja19yZXF1aXJlX18oXCI4NGYyXCIpO1xudmFyICRpdGVyQ3JlYXRlID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIjQxYTBcIik7XG52YXIgc2V0VG9TdHJpbmdUYWcgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiN2YyMFwiKTtcbnZhciBnZXRQcm90b3R5cGVPZiA9IF9fd2VicGFja19yZXF1aXJlX18oXCIzOGZkXCIpO1xudmFyIElURVJBVE9SID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIjJiNGNcIikoJ2l0ZXJhdG9yJyk7XG52YXIgQlVHR1kgPSAhKFtdLmtleXMgJiYgJ25leHQnIGluIFtdLmtleXMoKSk7IC8vIFNhZmFyaSBoYXMgYnVnZ3kgaXRlcmF0b3JzIHcvbyBgbmV4dGBcbnZhciBGRl9JVEVSQVRPUiA9ICdAQGl0ZXJhdG9yJztcbnZhciBLRVlTID0gJ2tleXMnO1xudmFyIFZBTFVFUyA9ICd2YWx1ZXMnO1xuXG52YXIgcmV0dXJuVGhpcyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXM7IH07XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKEJhc2UsIE5BTUUsIENvbnN0cnVjdG9yLCBuZXh0LCBERUZBVUxULCBJU19TRVQsIEZPUkNFRCkge1xuICAkaXRlckNyZWF0ZShDb25zdHJ1Y3RvciwgTkFNRSwgbmV4dCk7XG4gIHZhciBnZXRNZXRob2QgPSBmdW5jdGlvbiAoa2luZCkge1xuICAgIGlmICghQlVHR1kgJiYga2luZCBpbiBwcm90bykgcmV0dXJuIHByb3RvW2tpbmRdO1xuICAgIHN3aXRjaCAoa2luZCkge1xuICAgICAgY2FzZSBLRVlTOiByZXR1cm4gZnVuY3Rpb24ga2V5cygpIHsgcmV0dXJuIG5ldyBDb25zdHJ1Y3Rvcih0aGlzLCBraW5kKTsgfTtcbiAgICAgIGNhc2UgVkFMVUVTOiByZXR1cm4gZnVuY3Rpb24gdmFsdWVzKCkgeyByZXR1cm4gbmV3IENvbnN0cnVjdG9yKHRoaXMsIGtpbmQpOyB9O1xuICAgIH0gcmV0dXJuIGZ1bmN0aW9uIGVudHJpZXMoKSB7IHJldHVybiBuZXcgQ29uc3RydWN0b3IodGhpcywga2luZCk7IH07XG4gIH07XG4gIHZhciBUQUcgPSBOQU1FICsgJyBJdGVyYXRvcic7XG4gIHZhciBERUZfVkFMVUVTID0gREVGQVVMVCA9PSBWQUxVRVM7XG4gIHZhciBWQUxVRVNfQlVHID0gZmFsc2U7XG4gIHZhciBwcm90byA9IEJhc2UucHJvdG90eXBlO1xuICB2YXIgJG5hdGl2ZSA9IHByb3RvW0lURVJBVE9SXSB8fCBwcm90b1tGRl9JVEVSQVRPUl0gfHwgREVGQVVMVCAmJiBwcm90b1tERUZBVUxUXTtcbiAgdmFyICRkZWZhdWx0ID0gJG5hdGl2ZSB8fCBnZXRNZXRob2QoREVGQVVMVCk7XG4gIHZhciAkZW50cmllcyA9IERFRkFVTFQgPyAhREVGX1ZBTFVFUyA/ICRkZWZhdWx0IDogZ2V0TWV0aG9kKCdlbnRyaWVzJykgOiB1bmRlZmluZWQ7XG4gIHZhciAkYW55TmF0aXZlID0gTkFNRSA9PSAnQXJyYXknID8gcHJvdG8uZW50cmllcyB8fCAkbmF0aXZlIDogJG5hdGl2ZTtcbiAgdmFyIG1ldGhvZHMsIGtleSwgSXRlcmF0b3JQcm90b3R5cGU7XG4gIC8vIEZpeCBuYXRpdmVcbiAgaWYgKCRhbnlOYXRpdmUpIHtcbiAgICBJdGVyYXRvclByb3RvdHlwZSA9IGdldFByb3RvdHlwZU9mKCRhbnlOYXRpdmUuY2FsbChuZXcgQmFzZSgpKSk7XG4gICAgaWYgKEl0ZXJhdG9yUHJvdG90eXBlICE9PSBPYmplY3QucHJvdG90eXBlICYmIEl0ZXJhdG9yUHJvdG90eXBlLm5leHQpIHtcbiAgICAgIC8vIFNldCBAQHRvU3RyaW5nVGFnIHRvIG5hdGl2ZSBpdGVyYXRvcnNcbiAgICAgIHNldFRvU3RyaW5nVGFnKEl0ZXJhdG9yUHJvdG90eXBlLCBUQUcsIHRydWUpO1xuICAgICAgLy8gZml4IGZvciBzb21lIG9sZCBlbmdpbmVzXG4gICAgICBpZiAoIUxJQlJBUlkgJiYgdHlwZW9mIEl0ZXJhdG9yUHJvdG90eXBlW0lURVJBVE9SXSAhPSAnZnVuY3Rpb24nKSBoaWRlKEl0ZXJhdG9yUHJvdG90eXBlLCBJVEVSQVRPUiwgcmV0dXJuVGhpcyk7XG4gICAgfVxuICB9XG4gIC8vIGZpeCBBcnJheSN7dmFsdWVzLCBAQGl0ZXJhdG9yfS5uYW1lIGluIFY4IC8gRkZcbiAgaWYgKERFRl9WQUxVRVMgJiYgJG5hdGl2ZSAmJiAkbmF0aXZlLm5hbWUgIT09IFZBTFVFUykge1xuICAgIFZBTFVFU19CVUcgPSB0cnVlO1xuICAgICRkZWZhdWx0ID0gZnVuY3Rpb24gdmFsdWVzKCkgeyByZXR1cm4gJG5hdGl2ZS5jYWxsKHRoaXMpOyB9O1xuICB9XG4gIC8vIERlZmluZSBpdGVyYXRvclxuICBpZiAoKCFMSUJSQVJZIHx8IEZPUkNFRCkgJiYgKEJVR0dZIHx8IFZBTFVFU19CVUcgfHwgIXByb3RvW0lURVJBVE9SXSkpIHtcbiAgICBoaWRlKHByb3RvLCBJVEVSQVRPUiwgJGRlZmF1bHQpO1xuICB9XG4gIC8vIFBsdWcgZm9yIGxpYnJhcnlcbiAgSXRlcmF0b3JzW05BTUVdID0gJGRlZmF1bHQ7XG4gIEl0ZXJhdG9yc1tUQUddID0gcmV0dXJuVGhpcztcbiAgaWYgKERFRkFVTFQpIHtcbiAgICBtZXRob2RzID0ge1xuICAgICAgdmFsdWVzOiBERUZfVkFMVUVTID8gJGRlZmF1bHQgOiBnZXRNZXRob2QoVkFMVUVTKSxcbiAgICAgIGtleXM6IElTX1NFVCA/ICRkZWZhdWx0IDogZ2V0TWV0aG9kKEtFWVMpLFxuICAgICAgZW50cmllczogJGVudHJpZXNcbiAgICB9O1xuICAgIGlmIChGT1JDRUQpIGZvciAoa2V5IGluIG1ldGhvZHMpIHtcbiAgICAgIGlmICghKGtleSBpbiBwcm90bykpIHJlZGVmaW5lKHByb3RvLCBrZXksIG1ldGhvZHNba2V5XSk7XG4gICAgfSBlbHNlICRleHBvcnQoJGV4cG9ydC5QICsgJGV4cG9ydC5GICogKEJVR0dZIHx8IFZBTFVFU19CVUcpLCBOQU1FLCBtZXRob2RzKTtcbiAgfVxuICByZXR1cm4gbWV0aG9kcztcbn07XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiMDJmNFwiOlxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG52YXIgdG9JbnRlZ2VyID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIjQ1ODhcIik7XG52YXIgZGVmaW5lZCA9IF9fd2VicGFja19yZXF1aXJlX18oXCJiZTEzXCIpO1xuLy8gdHJ1ZSAgLT4gU3RyaW5nI2F0XG4vLyBmYWxzZSAtPiBTdHJpbmcjY29kZVBvaW50QXRcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKFRPX1NUUklORykge1xuICByZXR1cm4gZnVuY3Rpb24gKHRoYXQsIHBvcykge1xuICAgIHZhciBzID0gU3RyaW5nKGRlZmluZWQodGhhdCkpO1xuICAgIHZhciBpID0gdG9JbnRlZ2VyKHBvcyk7XG4gICAgdmFyIGwgPSBzLmxlbmd0aDtcbiAgICB2YXIgYSwgYjtcbiAgICBpZiAoaSA8IDAgfHwgaSA+PSBsKSByZXR1cm4gVE9fU1RSSU5HID8gJycgOiB1bmRlZmluZWQ7XG4gICAgYSA9IHMuY2hhckNvZGVBdChpKTtcbiAgICByZXR1cm4gYSA8IDB4ZDgwMCB8fCBhID4gMHhkYmZmIHx8IGkgKyAxID09PSBsIHx8IChiID0gcy5jaGFyQ29kZUF0KGkgKyAxKSkgPCAweGRjMDAgfHwgYiA+IDB4ZGZmZlxuICAgICAgPyBUT19TVFJJTkcgPyBzLmNoYXJBdChpKSA6IGFcbiAgICAgIDogVE9fU1RSSU5HID8gcy5zbGljZShpLCBpICsgMikgOiAoYSAtIDB4ZDgwMCA8PCAxMCkgKyAoYiAtIDB4ZGMwMCkgKyAweDEwMDAwO1xuICB9O1xufTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIwMzkwXCI6XG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG52YXIgYXQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiMDJmNFwiKSh0cnVlKTtcblxuIC8vIGBBZHZhbmNlU3RyaW5nSW5kZXhgIGFic3RyYWN0IG9wZXJhdGlvblxuLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtYWR2YW5jZXN0cmluZ2luZGV4XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChTLCBpbmRleCwgdW5pY29kZSkge1xuICByZXR1cm4gaW5kZXggKyAodW5pY29kZSA/IGF0KFMsIGluZGV4KS5sZW5ndGggOiAxKTtcbn07XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiMGJmYlwiOlxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuLy8gMjEuMi41LjMgZ2V0IFJlZ0V4cC5wcm90b3R5cGUuZmxhZ3NcbnZhciBhbk9iamVjdCA9IF9fd2VicGFja19yZXF1aXJlX18oXCJjYjdjXCIpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciB0aGF0ID0gYW5PYmplY3QodGhpcyk7XG4gIHZhciByZXN1bHQgPSAnJztcbiAgaWYgKHRoYXQuZ2xvYmFsKSByZXN1bHQgKz0gJ2cnO1xuICBpZiAodGhhdC5pZ25vcmVDYXNlKSByZXN1bHQgKz0gJ2knO1xuICBpZiAodGhhdC5tdWx0aWxpbmUpIHJlc3VsdCArPSAnbSc7XG4gIGlmICh0aGF0LnVuaWNvZGUpIHJlc3VsdCArPSAndSc7XG4gIGlmICh0aGF0LnN0aWNreSkgcmVzdWx0ICs9ICd5JztcbiAgcmV0dXJuIHJlc3VsdDtcbn07XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiMGQ1OFwiOlxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG4vLyAxOS4xLjIuMTQgLyAxNS4yLjMuMTQgT2JqZWN0LmtleXMoTylcbnZhciAka2V5cyA9IF9fd2VicGFja19yZXF1aXJlX18oXCJjZTEwXCIpO1xudmFyIGVudW1CdWdLZXlzID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcImUxMWVcIik7XG5cbm1vZHVsZS5leHBvcnRzID0gT2JqZWN0LmtleXMgfHwgZnVuY3Rpb24ga2V5cyhPKSB7XG4gIHJldHVybiAka2V5cyhPLCBlbnVtQnVnS2V5cyk7XG59O1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIjExNTZcIjpcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuLy8gc3R5bGUtbG9hZGVyOiBBZGRzIHNvbWUgY3NzIHRvIHRoZSBET00gYnkgYWRkaW5nIGEgPHN0eWxlPiB0YWdcblxuLy8gbG9hZCB0aGUgc3R5bGVzXG52YXIgY29udGVudCA9IF9fd2VicGFja19yZXF1aXJlX18oXCJhZDIwXCIpO1xuaWYodHlwZW9mIGNvbnRlbnQgPT09ICdzdHJpbmcnKSBjb250ZW50ID0gW1ttb2R1bGUuaSwgY29udGVudCwgJyddXTtcbmlmKGNvbnRlbnQubG9jYWxzKSBtb2R1bGUuZXhwb3J0cyA9IGNvbnRlbnQubG9jYWxzO1xuLy8gYWRkIHRoZSBzdHlsZXMgdG8gdGhlIERPTVxudmFyIGFkZCA9IF9fd2VicGFja19yZXF1aXJlX18oXCI0OTllXCIpLmRlZmF1bHRcbnZhciB1cGRhdGUgPSBhZGQoXCJjMWVjNTk3ZVwiLCBjb250ZW50LCB0cnVlLCB7XCJzb3VyY2VNYXBcIjpmYWxzZSxcInNoYWRvd01vZGVcIjpmYWxzZX0pO1xuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIxMWU5XCI6XG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbnZhciBwSUUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiNTJhN1wiKTtcbnZhciBjcmVhdGVEZXNjID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIjQ2MzBcIik7XG52YXIgdG9JT2JqZWN0ID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIjY4MjFcIik7XG52YXIgdG9QcmltaXRpdmUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiNmE5OVwiKTtcbnZhciBoYXMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiNjlhOFwiKTtcbnZhciBJRThfRE9NX0RFRklORSA9IF9fd2VicGFja19yZXF1aXJlX18oXCJjNjlhXCIpO1xudmFyIGdPUEQgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yO1xuXG5leHBvcnRzLmYgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiOWUxZVwiKSA/IGdPUEQgOiBmdW5jdGlvbiBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoTywgUCkge1xuICBPID0gdG9JT2JqZWN0KE8pO1xuICBQID0gdG9QcmltaXRpdmUoUCwgdHJ1ZSk7XG4gIGlmIChJRThfRE9NX0RFRklORSkgdHJ5IHtcbiAgICByZXR1cm4gZ09QRChPLCBQKTtcbiAgfSBjYXRjaCAoZSkgeyAvKiBlbXB0eSAqLyB9XG4gIGlmIChoYXMoTywgUCkpIHJldHVybiBjcmVhdGVEZXNjKCFwSUUuZi5jYWxsKE8sIFApLCBPW1BdKTtcbn07XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiMTQ5NVwiOlxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG52YXIgZFAgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiODZjY1wiKTtcbnZhciBhbk9iamVjdCA9IF9fd2VicGFja19yZXF1aXJlX18oXCJjYjdjXCIpO1xudmFyIGdldEtleXMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiMGQ1OFwiKTtcblxubW9kdWxlLmV4cG9ydHMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiOWUxZVwiKSA/IE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzIDogZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyhPLCBQcm9wZXJ0aWVzKSB7XG4gIGFuT2JqZWN0KE8pO1xuICB2YXIga2V5cyA9IGdldEtleXMoUHJvcGVydGllcyk7XG4gIHZhciBsZW5ndGggPSBrZXlzLmxlbmd0aDtcbiAgdmFyIGkgPSAwO1xuICB2YXIgUDtcbiAgd2hpbGUgKGxlbmd0aCA+IGkpIGRQLmYoTywgUCA9IGtleXNbaSsrXSwgUHJvcGVydGllc1tQXSk7XG4gIHJldHVybiBPO1xufTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIxOGQyXCI6XG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuLyoqXG4gKiBSZXNpemUgZGV0ZWN0aW9uIHN0cmF0ZWd5IHRoYXQgaW5qZWN0cyBvYmplY3RzIHRvIGVsZW1lbnRzIGluIG9yZGVyIHRvIGRldGVjdCByZXNpemUgZXZlbnRzLlxuICogSGVhdmlseSBpbnNwaXJlZCBieTogaHR0cDovL3d3dy5iYWNrYWxsZXljb2Rlci5jb20vMjAxMy8wMy8xOC9jcm9zcy1icm93c2VyLWV2ZW50LWJhc2VkLWVsZW1lbnQtcmVzaXplLWRldGVjdGlvbi9cbiAqL1xuXG5cblxudmFyIGJyb3dzZXJEZXRlY3RvciA9IF9fd2VicGFja19yZXF1aXJlX18oXCIxOGU5XCIpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICBvcHRpb25zICAgICAgICAgICAgID0gb3B0aW9ucyB8fCB7fTtcbiAgICB2YXIgcmVwb3J0ZXIgICAgICAgID0gb3B0aW9ucy5yZXBvcnRlcjtcbiAgICB2YXIgYmF0Y2hQcm9jZXNzb3IgID0gb3B0aW9ucy5iYXRjaFByb2Nlc3NvcjtcbiAgICB2YXIgZ2V0U3RhdGUgICAgICAgID0gb3B0aW9ucy5zdGF0ZUhhbmRsZXIuZ2V0U3RhdGU7XG5cbiAgICBpZighcmVwb3J0ZXIpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTWlzc2luZyByZXF1aXJlZCBkZXBlbmRlbmN5OiByZXBvcnRlci5cIik7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQWRkcyBhIHJlc2l6ZSBldmVudCBsaXN0ZW5lciB0byB0aGUgZWxlbWVudC5cbiAgICAgKiBAcHVibGljXG4gICAgICogQHBhcmFtIHtlbGVtZW50fSBlbGVtZW50IFRoZSBlbGVtZW50IHRoYXQgc2hvdWxkIGhhdmUgdGhlIGxpc3RlbmVyIGFkZGVkLlxuICAgICAqIEBwYXJhbSB7ZnVuY3Rpb259IGxpc3RlbmVyIFRoZSBsaXN0ZW5lciBjYWxsYmFjayB0byBiZSBjYWxsZWQgZm9yIGVhY2ggcmVzaXplIGV2ZW50IG9mIHRoZSBlbGVtZW50LiBUaGUgZWxlbWVudCB3aWxsIGJlIGdpdmVuIGFzIGEgcGFyYW1ldGVyIHRvIHRoZSBsaXN0ZW5lciBjYWxsYmFjay5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBhZGRMaXN0ZW5lcihlbGVtZW50LCBsaXN0ZW5lcikge1xuICAgICAgICBmdW5jdGlvbiBsaXN0ZW5lclByb3h5KCkge1xuICAgICAgICAgICAgbGlzdGVuZXIoZWxlbWVudCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZihicm93c2VyRGV0ZWN0b3IuaXNJRSg4KSkge1xuICAgICAgICAgICAgLy9JRSA4IGRvZXMgbm90IHN1cHBvcnQgb2JqZWN0LCBidXQgc3VwcG9ydHMgdGhlIHJlc2l6ZSBldmVudCBkaXJlY3RseSBvbiBlbGVtZW50cy5cbiAgICAgICAgICAgIGdldFN0YXRlKGVsZW1lbnQpLm9iamVjdCA9IHtcbiAgICAgICAgICAgICAgICBwcm94eTogbGlzdGVuZXJQcm94eVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGVsZW1lbnQuYXR0YWNoRXZlbnQoXCJvbnJlc2l6ZVwiLCBsaXN0ZW5lclByb3h5KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZhciBvYmplY3QgPSBnZXRPYmplY3QoZWxlbWVudCk7XG5cbiAgICAgICAgICAgIGlmKCFvYmplY3QpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJFbGVtZW50IGlzIG5vdCBkZXRlY3RhYmxlIGJ5IHRoaXMgc3RyYXRlZ3kuXCIpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBvYmplY3QuY29udGVudERvY3VtZW50LmRlZmF1bHRWaWV3LmFkZEV2ZW50TGlzdGVuZXIoXCJyZXNpemVcIiwgbGlzdGVuZXJQcm94eSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBidWlsZENzc1RleHRTdHJpbmcocnVsZXMpIHtcbiAgICAgICAgdmFyIHNlcGVyYXRvciA9IG9wdGlvbnMuaW1wb3J0YW50ID8gXCIgIWltcG9ydGFudDsgXCIgOiBcIjsgXCI7XG5cbiAgICAgICAgcmV0dXJuIChydWxlcy5qb2luKHNlcGVyYXRvcikgKyBzZXBlcmF0b3IpLnRyaW0oKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBNYWtlcyBhbiBlbGVtZW50IGRldGVjdGFibGUgYW5kIHJlYWR5IHRvIGJlIGxpc3RlbmVkIGZvciByZXNpemUgZXZlbnRzLiBXaWxsIGNhbGwgdGhlIGNhbGxiYWNrIHdoZW4gdGhlIGVsZW1lbnQgaXMgcmVhZHkgdG8gYmUgbGlzdGVuZWQgZm9yIHJlc2l6ZSBjaGFuZ2VzLlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtvYmplY3R9IG9wdGlvbnMgT3B0aW9uYWwgb3B0aW9ucyBvYmplY3QuXG4gICAgICogQHBhcmFtIHtlbGVtZW50fSBlbGVtZW50IFRoZSBlbGVtZW50IHRvIG1ha2UgZGV0ZWN0YWJsZVxuICAgICAqIEBwYXJhbSB7ZnVuY3Rpb259IGNhbGxiYWNrIFRoZSBjYWxsYmFjayB0byBiZSBjYWxsZWQgd2hlbiB0aGUgZWxlbWVudCBpcyByZWFkeSB0byBiZSBsaXN0ZW5lZCBmb3IgcmVzaXplIGNoYW5nZXMuIFdpbGwgYmUgY2FsbGVkIHdpdGggdGhlIGVsZW1lbnQgYXMgZmlyc3QgcGFyYW1ldGVyLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIG1ha2VEZXRlY3RhYmxlKG9wdGlvbnMsIGVsZW1lbnQsIGNhbGxiYWNrKSB7XG4gICAgICAgIGlmICghY2FsbGJhY2spIHtcbiAgICAgICAgICAgIGNhbGxiYWNrID0gZWxlbWVudDtcbiAgICAgICAgICAgIGVsZW1lbnQgPSBvcHRpb25zO1xuICAgICAgICAgICAgb3B0aW9ucyA9IG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgICAgICAgdmFyIGRlYnVnID0gb3B0aW9ucy5kZWJ1ZztcblxuICAgICAgICBmdW5jdGlvbiBpbmplY3RPYmplY3QoZWxlbWVudCwgY2FsbGJhY2spIHtcbiAgICAgICAgICAgIHZhciBPQkpFQ1RfU1RZTEUgPSBidWlsZENzc1RleHRTdHJpbmcoW1wiZGlzcGxheTogYmxvY2tcIiwgXCJwb3NpdGlvbjogYWJzb2x1dGVcIiwgXCJ0b3A6IDBcIiwgXCJsZWZ0OiAwXCIsIFwid2lkdGg6IDEwMCVcIiwgXCJoZWlnaHQ6IDEwMCVcIiwgXCJib3JkZXI6IG5vbmVcIiwgXCJwYWRkaW5nOiAwXCIsIFwibWFyZ2luOiAwXCIsIFwib3BhY2l0eTogMFwiLCBcInotaW5kZXg6IC0xMDAwXCIsIFwicG9pbnRlci1ldmVudHM6IG5vbmVcIl0pO1xuXG4gICAgICAgICAgICAvL1RoZSB0YXJnZXQgZWxlbWVudCBuZWVkcyB0byBiZSBwb3NpdGlvbmVkIChldmVyeXRoaW5nIGV4Y2VwdCBzdGF0aWMpIHNvIHRoZSBhYnNvbHV0ZSBwb3NpdGlvbmVkIG9iamVjdCB3aWxsIGJlIHBvc2l0aW9uZWQgcmVsYXRpdmUgdG8gdGhlIHRhcmdldCBlbGVtZW50LlxuXG4gICAgICAgICAgICAvLyBQb3NpdGlvbiBhbHRlcmluZyBtYXkgYmUgcGVyZm9ybWVkIGRpcmVjdGx5IG9yIG9uIG9iamVjdCBsb2FkLCBkZXBlbmRpbmcgb24gaWYgc3R5bGUgcmVzb2x1dGlvbiBpcyBwb3NzaWJsZSBkaXJlY3RseSBvciBub3QuXG4gICAgICAgICAgICB2YXIgcG9zaXRpb25DaGVja1BlcmZvcm1lZCA9IGZhbHNlO1xuXG4gICAgICAgICAgICAvLyBUaGUgZWxlbWVudCBtYXkgbm90IHlldCBiZSBhdHRhY2hlZCB0byB0aGUgRE9NLCBhbmQgdGhlcmVmb3JlIHRoZSBzdHlsZSBvYmplY3QgbWF5IGJlIGVtcHR5IGluIHNvbWUgYnJvd3NlcnMuXG4gICAgICAgICAgICAvLyBTaW5jZSB0aGUgc3R5bGUgb2JqZWN0IGlzIGEgcmVmZXJlbmNlLCBpdCB3aWxsIGJlIHVwZGF0ZWQgYXMgc29vbiBhcyB0aGUgZWxlbWVudCBpcyBhdHRhY2hlZCB0byB0aGUgRE9NLlxuICAgICAgICAgICAgdmFyIHN0eWxlID0gd2luZG93LmdldENvbXB1dGVkU3R5bGUoZWxlbWVudCk7XG4gICAgICAgICAgICB2YXIgd2lkdGggPSBlbGVtZW50Lm9mZnNldFdpZHRoO1xuICAgICAgICAgICAgdmFyIGhlaWdodCA9IGVsZW1lbnQub2Zmc2V0SGVpZ2h0O1xuXG4gICAgICAgICAgICBnZXRTdGF0ZShlbGVtZW50KS5zdGFydFNpemUgPSB7XG4gICAgICAgICAgICAgICAgd2lkdGg6IHdpZHRoLFxuICAgICAgICAgICAgICAgIGhlaWdodDogaGVpZ2h0XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICBmdW5jdGlvbiBtdXRhdGVEb20oKSB7XG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gYWx0ZXJQb3NpdGlvblN0eWxlcygpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYoc3R5bGUucG9zaXRpb24gPT09IFwic3RhdGljXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsZW1lbnQuc3R5bGUuc2V0UHJvcGVydHkoXCJwb3NpdGlvblwiLCBcInJlbGF0aXZlXCIsIG9wdGlvbnMuaW1wb3J0YW50ID8gXCJpbXBvcnRhbnRcIiA6IFwiXCIpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgcmVtb3ZlUmVsYXRpdmVTdHlsZXMgPSBmdW5jdGlvbihyZXBvcnRlciwgZWxlbWVudCwgc3R5bGUsIHByb3BlcnR5KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24gZ2V0TnVtZXJpY2FsVmFsdWUodmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlLnJlcGxhY2UoL1teLVxcZFxcLl0vZywgXCJcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHZhbHVlID0gc3R5bGVbcHJvcGVydHldO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYodmFsdWUgIT09IFwiYXV0b1wiICYmIGdldE51bWVyaWNhbFZhbHVlKHZhbHVlKSAhPT0gXCIwXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVwb3J0ZXIud2FybihcIkFuIGVsZW1lbnQgdGhhdCBpcyBwb3NpdGlvbmVkIHN0YXRpYyBoYXMgc3R5bGUuXCIgKyBwcm9wZXJ0eSArIFwiPVwiICsgdmFsdWUgKyBcIiB3aGljaCBpcyBpZ25vcmVkIGR1ZSB0byB0aGUgc3RhdGljIHBvc2l0aW9uaW5nLiBUaGUgZWxlbWVudCB3aWxsIG5lZWQgdG8gYmUgcG9zaXRpb25lZCByZWxhdGl2ZSwgc28gdGhlIHN0eWxlLlwiICsgcHJvcGVydHkgKyBcIiB3aWxsIGJlIHNldCB0byAwLiBFbGVtZW50OiBcIiwgZWxlbWVudCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsZW1lbnQuc3R5bGUuc2V0UHJvcGVydHkocHJvcGVydHksIFwiMFwiLCBvcHRpb25zLmltcG9ydGFudCA/IFwiaW1wb3J0YW50XCIgOiBcIlwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAvL0NoZWNrIHNvIHRoYXQgdGhlcmUgYXJlIG5vIGFjY2lkZW50YWwgc3R5bGVzIHRoYXQgd2lsbCBtYWtlIHRoZSBlbGVtZW50IHN0eWxlZCBkaWZmZXJlbnRseSBub3cgdGhhdCBpcyBpcyByZWxhdGl2ZS5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vSWYgdGhlcmUgYXJlIGFueSwgc2V0IHRoZW0gdG8gMCAodGhpcyBzaG91bGQgYmUgb2theSB3aXRoIHRoZSB1c2VyIHNpbmNlIHRoZSBzdHlsZSBwcm9wZXJ0aWVzIGRpZCBub3RoaW5nIGJlZm9yZSBbc2luY2UgdGhlIGVsZW1lbnQgd2FzIHBvc2l0aW9uZWQgc3RhdGljXSBhbnl3YXkpLlxuICAgICAgICAgICAgICAgICAgICAgICAgcmVtb3ZlUmVsYXRpdmVTdHlsZXMocmVwb3J0ZXIsIGVsZW1lbnQsIHN0eWxlLCBcInRvcFwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlbW92ZVJlbGF0aXZlU3R5bGVzKHJlcG9ydGVyLCBlbGVtZW50LCBzdHlsZSwgXCJyaWdodFwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlbW92ZVJlbGF0aXZlU3R5bGVzKHJlcG9ydGVyLCBlbGVtZW50LCBzdHlsZSwgXCJib3R0b21cIik7XG4gICAgICAgICAgICAgICAgICAgICAgICByZW1vdmVSZWxhdGl2ZVN0eWxlcyhyZXBvcnRlciwgZWxlbWVudCwgc3R5bGUsIFwibGVmdFwiKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIG9uT2JqZWN0TG9hZCgpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gVGhlIG9iamVjdCBoYXMgYmVlbiBsb2FkZWQsIHdoaWNoIG1lYW5zIHRoYXQgdGhlIGVsZW1lbnQgbm93IGlzIGd1YXJhbnRlZWQgdG8gYmUgYXR0YWNoZWQgdG8gdGhlIERPTS5cbiAgICAgICAgICAgICAgICAgICAgaWYgKCFwb3NpdGlvbkNoZWNrUGVyZm9ybWVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhbHRlclBvc2l0aW9uU3R5bGVzKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAvKmpzaGludCB2YWxpZHRoaXM6IHRydWUgKi9cblxuICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbiBnZXREb2N1bWVudChlbGVtZW50LCBjYWxsYmFjaykge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy9PcGVyYSAxMiBzZWVtIHRvIGNhbGwgdGhlIG9iamVjdC5vbmxvYWQgYmVmb3JlIHRoZSBhY3R1YWwgZG9jdW1lbnQgaGFzIGJlZW4gY3JlYXRlZC5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vU28gaWYgaXQgaXMgbm90IHByZXNlbnQsIHBvbGwgaXQgd2l0aCBhbiB0aW1lb3V0IHVudGlsIGl0IGlzIHByZXNlbnQuXG4gICAgICAgICAgICAgICAgICAgICAgICAvL1RPRE86IENvdWxkIG1heWJlIGJlIGhhbmRsZWQgYmV0dGVyIHdpdGggb2JqZWN0Lm9ucmVhZHlzdGF0ZWNoYW5nZSBvciBzaW1pbGFyLlxuICAgICAgICAgICAgICAgICAgICAgICAgaWYoIWVsZW1lbnQuY29udGVudERvY3VtZW50KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHN0YXRlID0gZ2V0U3RhdGUoZWxlbWVudCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHN0YXRlLmNoZWNrRm9yT2JqZWN0RG9jdW1lbnRUaW1lb3V0SWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgd2luZG93LmNsZWFyVGltZW91dChzdGF0ZS5jaGVja0Zvck9iamVjdERvY3VtZW50VGltZW91dElkKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhdGUuY2hlY2tGb3JPYmplY3REb2N1bWVudFRpbWVvdXRJZCA9IHNldFRpbWVvdXQoZnVuY3Rpb24gY2hlY2tGb3JPYmplY3REb2N1bWVudCgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhdGUuY2hlY2tGb3JPYmplY3REb2N1bWVudFRpbWVvdXRJZCA9IDA7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGdldERvY3VtZW50KGVsZW1lbnQsIGNhbGxiYWNrKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LCAxMDApO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICBjYWxsYmFjayhlbGVtZW50LmNvbnRlbnREb2N1bWVudCk7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAvL011dGF0aW5nIHRoZSBvYmplY3QgZWxlbWVudCBoZXJlIHNlZW1zIHRvIGZpcmUgYW5vdGhlciBsb2FkIGV2ZW50LlxuICAgICAgICAgICAgICAgICAgICAvL011dGF0aW5nIHRoZSBpbm5lciBkb2N1bWVudCBvZiB0aGUgb2JqZWN0IGVsZW1lbnQgaXMgZmluZSB0aG91Z2guXG4gICAgICAgICAgICAgICAgICAgIHZhciBvYmplY3RFbGVtZW50ID0gdGhpcztcblxuICAgICAgICAgICAgICAgICAgICAvL0NyZWF0ZSB0aGUgc3R5bGUgZWxlbWVudCB0byBiZSBhZGRlZCB0byB0aGUgb2JqZWN0LlxuICAgICAgICAgICAgICAgICAgICBnZXREb2N1bWVudChvYmplY3RFbGVtZW50LCBmdW5jdGlvbiBvbk9iamVjdERvY3VtZW50UmVhZHkob2JqZWN0RG9jdW1lbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vTm90aWZ5IHRoYXQgdGhlIGVsZW1lbnQgaXMgcmVhZHkgdG8gYmUgbGlzdGVuZWQgdG8uXG4gICAgICAgICAgICAgICAgICAgICAgICBjYWxsYmFjayhlbGVtZW50KTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gVGhlIGVsZW1lbnQgbWF5IGJlIGRldGFjaGVkIGZyb20gdGhlIERPTSwgYW5kIHNvbWUgYnJvd3NlcnMgZG9lcyBub3Qgc3VwcG9ydCBzdHlsZSByZXNvbHZpbmcgb2YgZGV0YWNoZWQgZWxlbWVudHMuXG4gICAgICAgICAgICAgICAgLy8gVGhlIGFsdGVyUG9zaXRpb25TdHlsZXMgbmVlZHMgdG8gYmUgZGVsYXllZCB1bnRpbCB3ZSBrbm93IHRoZSBlbGVtZW50IGhhcyBiZWVuIGF0dGFjaGVkIHRvIHRoZSBET00gKHdoaWNoIHdlIGFyZSBzdXJlIG9mIHdoZW4gdGhlIG9uT2JqZWN0TG9hZCBoYXMgYmVlbiBmaXJlZCksIGlmIHN0eWxlIHJlc29sdXRpb24gaXMgbm90IHBvc3NpYmxlLlxuICAgICAgICAgICAgICAgIGlmIChzdHlsZS5wb3NpdGlvbiAhPT0gXCJcIikge1xuICAgICAgICAgICAgICAgICAgICBhbHRlclBvc2l0aW9uU3R5bGVzKHN0eWxlKTtcbiAgICAgICAgICAgICAgICAgICAgcG9zaXRpb25DaGVja1BlcmZvcm1lZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy9BZGQgYW4gb2JqZWN0IGVsZW1lbnQgYXMgYSBjaGlsZCB0byB0aGUgdGFyZ2V0IGVsZW1lbnQgdGhhdCB3aWxsIGJlIGxpc3RlbmVkIHRvIGZvciByZXNpemUgZXZlbnRzLlxuICAgICAgICAgICAgICAgIHZhciBvYmplY3QgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwib2JqZWN0XCIpO1xuICAgICAgICAgICAgICAgIG9iamVjdC5zdHlsZS5jc3NUZXh0ID0gT0JKRUNUX1NUWUxFO1xuICAgICAgICAgICAgICAgIG9iamVjdC50YWJJbmRleCA9IC0xO1xuICAgICAgICAgICAgICAgIG9iamVjdC50eXBlID0gXCJ0ZXh0L2h0bWxcIjtcbiAgICAgICAgICAgICAgICBvYmplY3Quc2V0QXR0cmlidXRlKFwiYXJpYS1oaWRkZW5cIiwgXCJ0cnVlXCIpO1xuICAgICAgICAgICAgICAgIG9iamVjdC5vbmxvYWQgPSBvbk9iamVjdExvYWQ7XG5cbiAgICAgICAgICAgICAgICAvL1NhZmFyaTogVGhpcyBtdXN0IG9jY3VyIGJlZm9yZSBhZGRpbmcgdGhlIG9iamVjdCB0byB0aGUgRE9NLlxuICAgICAgICAgICAgICAgIC8vSUU6IERvZXMgbm90IGxpa2UgdGhhdCB0aGlzIGhhcHBlbnMgYmVmb3JlLCBldmVuIGlmIGl0IGlzIGFsc28gYWRkZWQgYWZ0ZXIuXG4gICAgICAgICAgICAgICAgaWYoIWJyb3dzZXJEZXRlY3Rvci5pc0lFKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgb2JqZWN0LmRhdGEgPSBcImFib3V0OmJsYW5rXCI7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKCFnZXRTdGF0ZShlbGVtZW50KSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBUaGUgZWxlbWVudCBoYXMgYmVlbiB1bmluc3RhbGxlZCBiZWZvcmUgdGhlIGFjdHVhbCBsb2FkaW5nIGhhcHBlbmVkLlxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgZWxlbWVudC5hcHBlbmRDaGlsZChvYmplY3QpO1xuICAgICAgICAgICAgICAgIGdldFN0YXRlKGVsZW1lbnQpLm9iamVjdCA9IG9iamVjdDtcblxuICAgICAgICAgICAgICAgIC8vSUU6IFRoaXMgbXVzdCBvY2N1ciBhZnRlciBhZGRpbmcgdGhlIG9iamVjdCB0byB0aGUgRE9NLlxuICAgICAgICAgICAgICAgIGlmKGJyb3dzZXJEZXRlY3Rvci5pc0lFKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgb2JqZWN0LmRhdGEgPSBcImFib3V0OmJsYW5rXCI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZihiYXRjaFByb2Nlc3Nvcikge1xuICAgICAgICAgICAgICAgIGJhdGNoUHJvY2Vzc29yLmFkZChtdXRhdGVEb20pO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBtdXRhdGVEb20oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmKGJyb3dzZXJEZXRlY3Rvci5pc0lFKDgpKSB7XG4gICAgICAgICAgICAvL0lFIDggZG9lcyBub3Qgc3VwcG9ydCBvYmplY3RzIHByb3Blcmx5LiBMdWNraWx5IHRoZXkgZG8gc3VwcG9ydCB0aGUgcmVzaXplIGV2ZW50LlxuICAgICAgICAgICAgLy9TbyBkbyBub3QgaW5qZWN0IHRoZSBvYmplY3QgYW5kIG5vdGlmeSB0aGF0IHRoZSBlbGVtZW50IGlzIGFscmVhZHkgcmVhZHkgdG8gYmUgbGlzdGVuZWQgdG8uXG4gICAgICAgICAgICAvL1RoZSBldmVudCBoYW5kbGVyIGZvciB0aGUgcmVzaXplIGV2ZW50IGlzIGF0dGFjaGVkIGluIHRoZSB1dGlscy5hZGRMaXN0ZW5lciBpbnN0ZWFkLlxuICAgICAgICAgICAgY2FsbGJhY2soZWxlbWVudCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpbmplY3RPYmplY3QoZWxlbWVudCwgY2FsbGJhY2spO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgY2hpbGQgb2JqZWN0IG9mIHRoZSB0YXJnZXQgZWxlbWVudC5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7ZWxlbWVudH0gZWxlbWVudCBUaGUgdGFyZ2V0IGVsZW1lbnQuXG4gICAgICogQHJldHVybnMgVGhlIG9iamVjdCBlbGVtZW50IG9mIHRoZSB0YXJnZXQuXG4gICAgICovXG4gICAgZnVuY3Rpb24gZ2V0T2JqZWN0KGVsZW1lbnQpIHtcbiAgICAgICAgcmV0dXJuIGdldFN0YXRlKGVsZW1lbnQpLm9iamVjdDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiB1bmluc3RhbGwoZWxlbWVudCkge1xuICAgICAgICBpZiAoIWdldFN0YXRlKGVsZW1lbnQpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgb2JqZWN0ID0gZ2V0T2JqZWN0KGVsZW1lbnQpO1xuXG4gICAgICAgIGlmICghb2JqZWN0KSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoYnJvd3NlckRldGVjdG9yLmlzSUUoOCkpIHtcbiAgICAgICAgICAgIGVsZW1lbnQuZGV0YWNoRXZlbnQoXCJvbnJlc2l6ZVwiLCBvYmplY3QucHJveHkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZWxlbWVudC5yZW1vdmVDaGlsZChvYmplY3QpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGdldFN0YXRlKGVsZW1lbnQpLmNoZWNrRm9yT2JqZWN0RG9jdW1lbnRUaW1lb3V0SWQpIHtcbiAgICAgICAgICAgIHdpbmRvdy5jbGVhclRpbWVvdXQoZ2V0U3RhdGUoZWxlbWVudCkuY2hlY2tGb3JPYmplY3REb2N1bWVudFRpbWVvdXRJZCk7XG4gICAgICAgIH1cblxuICAgICAgICBkZWxldGUgZ2V0U3RhdGUoZWxlbWVudCkub2JqZWN0O1xuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICAgIG1ha2VEZXRlY3RhYmxlOiBtYWtlRGV0ZWN0YWJsZSxcbiAgICAgICAgYWRkTGlzdGVuZXI6IGFkZExpc3RlbmVyLFxuICAgICAgICB1bmluc3RhbGw6IHVuaW5zdGFsbFxuICAgIH07XG59O1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIjE4ZTlcIjpcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxudmFyIGRldGVjdG9yID0gbW9kdWxlLmV4cG9ydHMgPSB7fTtcblxuZGV0ZWN0b3IuaXNJRSA9IGZ1bmN0aW9uKHZlcnNpb24pIHtcbiAgICBmdW5jdGlvbiBpc0FueUllVmVyc2lvbigpIHtcbiAgICAgICAgdmFyIGFnZW50ID0gbmF2aWdhdG9yLnVzZXJBZ2VudC50b0xvd2VyQ2FzZSgpO1xuICAgICAgICByZXR1cm4gYWdlbnQuaW5kZXhPZihcIm1zaWVcIikgIT09IC0xIHx8IGFnZW50LmluZGV4T2YoXCJ0cmlkZW50XCIpICE9PSAtMSB8fCBhZ2VudC5pbmRleE9mKFwiIGVkZ2UvXCIpICE9PSAtMTtcbiAgICB9XG5cbiAgICBpZighaXNBbnlJZVZlcnNpb24oKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgaWYoIXZlcnNpb24pIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgLy9TaGFtZWxlc3NseSBzdG9sZW4gZnJvbSBodHRwczovL2dpc3QuZ2l0aHViLmNvbS9wYWRvbHNleS81Mjc2ODNcbiAgICB2YXIgaWVWZXJzaW9uID0gKGZ1bmN0aW9uKCl7XG4gICAgICAgIHZhciB1bmRlZixcbiAgICAgICAgICAgIHYgPSAzLFxuICAgICAgICAgICAgZGl2ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKSxcbiAgICAgICAgICAgIGFsbCA9IGRpdi5nZXRFbGVtZW50c0J5VGFnTmFtZShcImlcIik7XG5cbiAgICAgICAgZG8ge1xuICAgICAgICAgICAgZGl2LmlubmVySFRNTCA9IFwiPCEtLVtpZiBndCBJRSBcIiArICgrK3YpICsgXCJdPjxpPjwvaT48IVtlbmRpZl0tLT5cIjtcbiAgICAgICAgfVxuICAgICAgICB3aGlsZSAoYWxsWzBdKTtcblxuICAgICAgICByZXR1cm4gdiA+IDQgPyB2IDogdW5kZWY7XG4gICAgfSgpKTtcblxuICAgIHJldHVybiB2ZXJzaW9uID09PSBpZVZlcnNpb247XG59O1xuXG5kZXRlY3Rvci5pc0xlZ2FjeU9wZXJhID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuICEhd2luZG93Lm9wZXJhO1xufTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIxY2E3XCI6XG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuLyogaGFybW9ueSBleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcImJcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBnZXREb2N1bWVudERpcjsgfSk7XG4vKiB1bnVzZWQgaGFybW9ueSBleHBvcnQgc2V0RG9jdW1lbnREaXIgKi9cbi8qIGhhcm1vbnkgZXhwb3J0IChiaW5kaW5nKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXCJhXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gYWRkV2luZG93RXZlbnRMaXN0ZW5lcjsgfSk7XG4vKiBoYXJtb255IGV4cG9ydCAoYmluZGluZykgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwiY1wiLCBmdW5jdGlvbigpIHsgcmV0dXJuIHJlbW92ZVdpbmRvd0V2ZW50TGlzdGVuZXI7IH0pO1xudmFyIGN1cnJlbnREaXJcbi8qOiBcImx0clwiIHwgXCJydGxcIiB8IFwiYXV0b1wiKi9cbj0gXCJhdXRvXCI7IC8vIGxldCBjdXJyZW50RGlyID0gXCJhdXRvXCI7XG5cbmZ1bmN0aW9uIGhhc0RvY3VtZW50KCkge1xuICByZXR1cm4gdHlwZW9mIGRvY3VtZW50ICE9PSBcInVuZGVmaW5lZFwiO1xufVxuXG5mdW5jdGlvbiBoYXNXaW5kb3coKSB7XG4gIHJldHVybiB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiO1xufVxuXG5mdW5jdGlvbiBnZXREb2N1bWVudERpcigpIHtcbiAgaWYgKCFoYXNEb2N1bWVudCgpKSB7XG4gICAgcmV0dXJuIGN1cnJlbnREaXI7XG4gIH1cblxuICB2YXIgZGlyZWN0aW9uID0gdHlwZW9mIGRvY3VtZW50LmRpciAhPT0gXCJ1bmRlZmluZWRcIiA/IGRvY3VtZW50LmRpciA6IGRvY3VtZW50LmdldEVsZW1lbnRzQnlUYWdOYW1lKFwiaHRtbFwiKVswXS5nZXRBdHRyaWJ1dGUoXCJkaXJcIik7XG4gIHJldHVybiBkaXJlY3Rpb247XG59XG5mdW5jdGlvbiBzZXREb2N1bWVudERpcihkaXJcbi8qOiBcImx0clwiIHwgXCJydGxcIiB8IFwiYXV0b1wiKi9cbikge1xuICAvLyBleHBvcnQgZnVuY3Rpb24gc2V0RG9jdW1lbnREaXIoZGlyKXtcbiAgaWYgKCFoYXNEb2N1bWVudCkge1xuICAgIGN1cnJlbnREaXIgPSBkaXI7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdmFyIGh0bWwgPSBkb2N1bWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZShcImh0bWxcIilbMF07XG4gIGh0bWwuc2V0QXR0cmlidXRlKFwiZGlyXCIsIGRpcik7XG59XG5mdW5jdGlvbiBhZGRXaW5kb3dFdmVudExpc3RlbmVyKGV2ZW50XG4vKjpzdHJpbmcqL1xuLCBjYWxsYmFja1xuLyo6ICgpID0+IG1peGVkKi9cbikge1xuICBpZiAoIWhhc1dpbmRvdykge1xuICAgIGNhbGxiYWNrKCk7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoZXZlbnQsIGNhbGxiYWNrKTtcbn1cbmZ1bmN0aW9uIHJlbW92ZVdpbmRvd0V2ZW50TGlzdGVuZXIoZXZlbnRcbi8qOnN0cmluZyovXG4sIGNhbGxiYWNrXG4vKjogKCkgPT4gbWl4ZWQqL1xuKSB7XG4gIGlmICghaGFzV2luZG93KSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoZXZlbnQsIGNhbGxiYWNrKTtcbn1cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiMjE0ZlwiOlxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuX193ZWJwYWNrX3JlcXVpcmVfXyhcImIwYzVcIik7XG52YXIgcmVkZWZpbmUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiMmFiYVwiKTtcbnZhciBoaWRlID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIjMyZTlcIik7XG52YXIgZmFpbHMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiNzllNVwiKTtcbnZhciBkZWZpbmVkID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcImJlMTNcIik7XG52YXIgd2tzID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIjJiNGNcIik7XG52YXIgcmVnZXhwRXhlYyA9IF9fd2VicGFja19yZXF1aXJlX18oXCI1MjBhXCIpO1xuXG52YXIgU1BFQ0lFUyA9IHdrcygnc3BlY2llcycpO1xuXG52YXIgUkVQTEFDRV9TVVBQT1JUU19OQU1FRF9HUk9VUFMgPSAhZmFpbHMoZnVuY3Rpb24gKCkge1xuICAvLyAjcmVwbGFjZSBuZWVkcyBidWlsdC1pbiBzdXBwb3J0IGZvciBuYW1lZCBncm91cHMuXG4gIC8vICNtYXRjaCB3b3JrcyBmaW5lIGJlY2F1c2UgaXQganVzdCByZXR1cm4gdGhlIGV4ZWMgcmVzdWx0cywgZXZlbiBpZiBpdCBoYXNcbiAgLy8gYSBcImdyb3BzXCIgcHJvcGVydHkuXG4gIHZhciByZSA9IC8uLztcbiAgcmUuZXhlYyA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgcmVzdWx0ID0gW107XG4gICAgcmVzdWx0Lmdyb3VwcyA9IHsgYTogJzcnIH07XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfTtcbiAgcmV0dXJuICcnLnJlcGxhY2UocmUsICckPGE+JykgIT09ICc3Jztcbn0pO1xuXG52YXIgU1BMSVRfV09SS1NfV0lUSF9PVkVSV1JJVFRFTl9FWEVDID0gKGZ1bmN0aW9uICgpIHtcbiAgLy8gQ2hyb21lIDUxIGhhcyBhIGJ1Z2d5IFwic3BsaXRcIiBpbXBsZW1lbnRhdGlvbiB3aGVuIFJlZ0V4cCNleGVjICE9PSBuYXRpdmVFeGVjXG4gIHZhciByZSA9IC8oPzopLztcbiAgdmFyIG9yaWdpbmFsRXhlYyA9IHJlLmV4ZWM7XG4gIHJlLmV4ZWMgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBvcmlnaW5hbEV4ZWMuYXBwbHkodGhpcywgYXJndW1lbnRzKTsgfTtcbiAgdmFyIHJlc3VsdCA9ICdhYicuc3BsaXQocmUpO1xuICByZXR1cm4gcmVzdWx0Lmxlbmd0aCA9PT0gMiAmJiByZXN1bHRbMF0gPT09ICdhJyAmJiByZXN1bHRbMV0gPT09ICdiJztcbn0pKCk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKEtFWSwgbGVuZ3RoLCBleGVjKSB7XG4gIHZhciBTWU1CT0wgPSB3a3MoS0VZKTtcblxuICB2YXIgREVMRUdBVEVTX1RPX1NZTUJPTCA9ICFmYWlscyhmdW5jdGlvbiAoKSB7XG4gICAgLy8gU3RyaW5nIG1ldGhvZHMgY2FsbCBzeW1ib2wtbmFtZWQgUmVnRXAgbWV0aG9kc1xuICAgIHZhciBPID0ge307XG4gICAgT1tTWU1CT0xdID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gNzsgfTtcbiAgICByZXR1cm4gJydbS0VZXShPKSAhPSA3O1xuICB9KTtcblxuICB2YXIgREVMRUdBVEVTX1RPX0VYRUMgPSBERUxFR0FURVNfVE9fU1lNQk9MID8gIWZhaWxzKGZ1bmN0aW9uICgpIHtcbiAgICAvLyBTeW1ib2wtbmFtZWQgUmVnRXhwIG1ldGhvZHMgY2FsbCAuZXhlY1xuICAgIHZhciBleGVjQ2FsbGVkID0gZmFsc2U7XG4gICAgdmFyIHJlID0gL2EvO1xuICAgIHJlLmV4ZWMgPSBmdW5jdGlvbiAoKSB7IGV4ZWNDYWxsZWQgPSB0cnVlOyByZXR1cm4gbnVsbDsgfTtcbiAgICBpZiAoS0VZID09PSAnc3BsaXQnKSB7XG4gICAgICAvLyBSZWdFeHBbQEBzcGxpdF0gZG9lc24ndCBjYWxsIHRoZSByZWdleCdzIGV4ZWMgbWV0aG9kLCBidXQgZmlyc3QgY3JlYXRlc1xuICAgICAgLy8gYSBuZXcgb25lLiBXZSBuZWVkIHRvIHJldHVybiB0aGUgcGF0Y2hlZCByZWdleCB3aGVuIGNyZWF0aW5nIHRoZSBuZXcgb25lLlxuICAgICAgcmUuY29uc3RydWN0b3IgPSB7fTtcbiAgICAgIHJlLmNvbnN0cnVjdG9yW1NQRUNJRVNdID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gcmU7IH07XG4gICAgfVxuICAgIHJlW1NZTUJPTF0oJycpO1xuICAgIHJldHVybiAhZXhlY0NhbGxlZDtcbiAgfSkgOiB1bmRlZmluZWQ7XG5cbiAgaWYgKFxuICAgICFERUxFR0FURVNfVE9fU1lNQk9MIHx8XG4gICAgIURFTEVHQVRFU19UT19FWEVDIHx8XG4gICAgKEtFWSA9PT0gJ3JlcGxhY2UnICYmICFSRVBMQUNFX1NVUFBPUlRTX05BTUVEX0dST1VQUykgfHxcbiAgICAoS0VZID09PSAnc3BsaXQnICYmICFTUExJVF9XT1JLU19XSVRIX09WRVJXUklUVEVOX0VYRUMpXG4gICkge1xuICAgIHZhciBuYXRpdmVSZWdFeHBNZXRob2QgPSAvLi9bU1lNQk9MXTtcbiAgICB2YXIgZm5zID0gZXhlYyhcbiAgICAgIGRlZmluZWQsXG4gICAgICBTWU1CT0wsXG4gICAgICAnJ1tLRVldLFxuICAgICAgZnVuY3Rpb24gbWF5YmVDYWxsTmF0aXZlKG5hdGl2ZU1ldGhvZCwgcmVnZXhwLCBzdHIsIGFyZzIsIGZvcmNlU3RyaW5nTWV0aG9kKSB7XG4gICAgICAgIGlmIChyZWdleHAuZXhlYyA9PT0gcmVnZXhwRXhlYykge1xuICAgICAgICAgIGlmIChERUxFR0FURVNfVE9fU1lNQk9MICYmICFmb3JjZVN0cmluZ01ldGhvZCkge1xuICAgICAgICAgICAgLy8gVGhlIG5hdGl2ZSBTdHJpbmcgbWV0aG9kIGFscmVhZHkgZGVsZWdhdGVzIHRvIEBAbWV0aG9kICh0aGlzXG4gICAgICAgICAgICAvLyBwb2x5ZmlsbGVkIGZ1bmN0aW9uKSwgbGVhc2luZyB0byBpbmZpbml0ZSByZWN1cnNpb24uXG4gICAgICAgICAgICAvLyBXZSBhdm9pZCBpdCBieSBkaXJlY3RseSBjYWxsaW5nIHRoZSBuYXRpdmUgQEBtZXRob2QgbWV0aG9kLlxuICAgICAgICAgICAgcmV0dXJuIHsgZG9uZTogdHJ1ZSwgdmFsdWU6IG5hdGl2ZVJlZ0V4cE1ldGhvZC5jYWxsKHJlZ2V4cCwgc3RyLCBhcmcyKSB9O1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4geyBkb25lOiB0cnVlLCB2YWx1ZTogbmF0aXZlTWV0aG9kLmNhbGwoc3RyLCByZWdleHAsIGFyZzIpIH07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHsgZG9uZTogZmFsc2UgfTtcbiAgICAgIH1cbiAgICApO1xuICAgIHZhciBzdHJmbiA9IGZuc1swXTtcbiAgICB2YXIgcnhmbiA9IGZuc1sxXTtcblxuICAgIHJlZGVmaW5lKFN0cmluZy5wcm90b3R5cGUsIEtFWSwgc3RyZm4pO1xuICAgIGhpZGUoUmVnRXhwLnByb3RvdHlwZSwgU1lNQk9MLCBsZW5ndGggPT0gMlxuICAgICAgLy8gMjEuMi41LjggUmVnRXhwLnByb3RvdHlwZVtAQHJlcGxhY2VdKHN0cmluZywgcmVwbGFjZVZhbHVlKVxuICAgICAgLy8gMjEuMi41LjExIFJlZ0V4cC5wcm90b3R5cGVbQEBzcGxpdF0oc3RyaW5nLCBsaW1pdClcbiAgICAgID8gZnVuY3Rpb24gKHN0cmluZywgYXJnKSB7IHJldHVybiByeGZuLmNhbGwoc3RyaW5nLCB0aGlzLCBhcmcpOyB9XG4gICAgICAvLyAyMS4yLjUuNiBSZWdFeHAucHJvdG90eXBlW0BAbWF0Y2hdKHN0cmluZylcbiAgICAgIC8vIDIxLjIuNS45IFJlZ0V4cC5wcm90b3R5cGVbQEBzZWFyY2hdKHN0cmluZylcbiAgICAgIDogZnVuY3Rpb24gKHN0cmluZykgeyByZXR1cm4gcnhmbi5jYWxsKHN0cmluZywgdGhpcyk7IH1cbiAgICApO1xuICB9XG59O1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIjIzMGVcIjpcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxudmFyIGlzT2JqZWN0ID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcImQzZjRcIik7XG52YXIgZG9jdW1lbnQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiNzcyNlwiKS5kb2N1bWVudDtcbi8vIHR5cGVvZiBkb2N1bWVudC5jcmVhdGVFbGVtZW50IGlzICdvYmplY3QnIGluIG9sZCBJRVxudmFyIGlzID0gaXNPYmplY3QoZG9jdW1lbnQpICYmIGlzT2JqZWN0KGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXQpIHtcbiAgcmV0dXJuIGlzID8gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChpdCkgOiB7fTtcbn07XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiMjM1MFwiOlxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG4vKlxuXHRNSVQgTGljZW5zZSBodHRwOi8vd3d3Lm9wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL21pdC1saWNlbnNlLnBocFxuXHRBdXRob3IgVG9iaWFzIEtvcHBlcnMgQHNva3JhXG4qL1xuLy8gY3NzIGJhc2UgY29kZSwgaW5qZWN0ZWQgYnkgdGhlIGNzcy1sb2FkZXJcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24odXNlU291cmNlTWFwKSB7XG5cdHZhciBsaXN0ID0gW107XG5cblx0Ly8gcmV0dXJuIHRoZSBsaXN0IG9mIG1vZHVsZXMgYXMgY3NzIHN0cmluZ1xuXHRsaXN0LnRvU3RyaW5nID0gZnVuY3Rpb24gdG9TdHJpbmcoKSB7XG5cdFx0cmV0dXJuIHRoaXMubWFwKGZ1bmN0aW9uIChpdGVtKSB7XG5cdFx0XHR2YXIgY29udGVudCA9IGNzc1dpdGhNYXBwaW5nVG9TdHJpbmcoaXRlbSwgdXNlU291cmNlTWFwKTtcblx0XHRcdGlmKGl0ZW1bMl0pIHtcblx0XHRcdFx0cmV0dXJuIFwiQG1lZGlhIFwiICsgaXRlbVsyXSArIFwie1wiICsgY29udGVudCArIFwifVwiO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0cmV0dXJuIGNvbnRlbnQ7XG5cdFx0XHR9XG5cdFx0fSkuam9pbihcIlwiKTtcblx0fTtcblxuXHQvLyBpbXBvcnQgYSBsaXN0IG9mIG1vZHVsZXMgaW50byB0aGUgbGlzdFxuXHRsaXN0LmkgPSBmdW5jdGlvbihtb2R1bGVzLCBtZWRpYVF1ZXJ5KSB7XG5cdFx0aWYodHlwZW9mIG1vZHVsZXMgPT09IFwic3RyaW5nXCIpXG5cdFx0XHRtb2R1bGVzID0gW1tudWxsLCBtb2R1bGVzLCBcIlwiXV07XG5cdFx0dmFyIGFscmVhZHlJbXBvcnRlZE1vZHVsZXMgPSB7fTtcblx0XHRmb3IodmFyIGkgPSAwOyBpIDwgdGhpcy5sZW5ndGg7IGkrKykge1xuXHRcdFx0dmFyIGlkID0gdGhpc1tpXVswXTtcblx0XHRcdGlmKHR5cGVvZiBpZCA9PT0gXCJudW1iZXJcIilcblx0XHRcdFx0YWxyZWFkeUltcG9ydGVkTW9kdWxlc1tpZF0gPSB0cnVlO1xuXHRcdH1cblx0XHRmb3IoaSA9IDA7IGkgPCBtb2R1bGVzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHR2YXIgaXRlbSA9IG1vZHVsZXNbaV07XG5cdFx0XHQvLyBza2lwIGFscmVhZHkgaW1wb3J0ZWQgbW9kdWxlXG5cdFx0XHQvLyB0aGlzIGltcGxlbWVudGF0aW9uIGlzIG5vdCAxMDAlIHBlcmZlY3QgZm9yIHdlaXJkIG1lZGlhIHF1ZXJ5IGNvbWJpbmF0aW9uc1xuXHRcdFx0Ly8gIHdoZW4gYSBtb2R1bGUgaXMgaW1wb3J0ZWQgbXVsdGlwbGUgdGltZXMgd2l0aCBkaWZmZXJlbnQgbWVkaWEgcXVlcmllcy5cblx0XHRcdC8vICBJIGhvcGUgdGhpcyB3aWxsIG5ldmVyIG9jY3VyIChIZXkgdGhpcyB3YXkgd2UgaGF2ZSBzbWFsbGVyIGJ1bmRsZXMpXG5cdFx0XHRpZih0eXBlb2YgaXRlbVswXSAhPT0gXCJudW1iZXJcIiB8fCAhYWxyZWFkeUltcG9ydGVkTW9kdWxlc1tpdGVtWzBdXSkge1xuXHRcdFx0XHRpZihtZWRpYVF1ZXJ5ICYmICFpdGVtWzJdKSB7XG5cdFx0XHRcdFx0aXRlbVsyXSA9IG1lZGlhUXVlcnk7XG5cdFx0XHRcdH0gZWxzZSBpZihtZWRpYVF1ZXJ5KSB7XG5cdFx0XHRcdFx0aXRlbVsyXSA9IFwiKFwiICsgaXRlbVsyXSArIFwiKSBhbmQgKFwiICsgbWVkaWFRdWVyeSArIFwiKVwiO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGxpc3QucHVzaChpdGVtKTtcblx0XHRcdH1cblx0XHR9XG5cdH07XG5cdHJldHVybiBsaXN0O1xufTtcblxuZnVuY3Rpb24gY3NzV2l0aE1hcHBpbmdUb1N0cmluZyhpdGVtLCB1c2VTb3VyY2VNYXApIHtcblx0dmFyIGNvbnRlbnQgPSBpdGVtWzFdIHx8ICcnO1xuXHR2YXIgY3NzTWFwcGluZyA9IGl0ZW1bM107XG5cdGlmICghY3NzTWFwcGluZykge1xuXHRcdHJldHVybiBjb250ZW50O1xuXHR9XG5cblx0aWYgKHVzZVNvdXJjZU1hcCAmJiB0eXBlb2YgYnRvYSA9PT0gJ2Z1bmN0aW9uJykge1xuXHRcdHZhciBzb3VyY2VNYXBwaW5nID0gdG9Db21tZW50KGNzc01hcHBpbmcpO1xuXHRcdHZhciBzb3VyY2VVUkxzID0gY3NzTWFwcGluZy5zb3VyY2VzLm1hcChmdW5jdGlvbiAoc291cmNlKSB7XG5cdFx0XHRyZXR1cm4gJy8qIyBzb3VyY2VVUkw9JyArIGNzc01hcHBpbmcuc291cmNlUm9vdCArIHNvdXJjZSArICcgKi8nXG5cdFx0fSk7XG5cblx0XHRyZXR1cm4gW2NvbnRlbnRdLmNvbmNhdChzb3VyY2VVUkxzKS5jb25jYXQoW3NvdXJjZU1hcHBpbmddKS5qb2luKCdcXG4nKTtcblx0fVxuXG5cdHJldHVybiBbY29udGVudF0uam9pbignXFxuJyk7XG59XG5cbi8vIEFkYXB0ZWQgZnJvbSBjb252ZXJ0LXNvdXJjZS1tYXAgKE1JVClcbmZ1bmN0aW9uIHRvQ29tbWVudChzb3VyY2VNYXApIHtcblx0Ly8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVuZGVmXG5cdHZhciBiYXNlNjQgPSBidG9hKHVuZXNjYXBlKGVuY29kZVVSSUNvbXBvbmVudChKU09OLnN0cmluZ2lmeShzb3VyY2VNYXApKSkpO1xuXHR2YXIgZGF0YSA9ICdzb3VyY2VNYXBwaW5nVVJMPWRhdGE6YXBwbGljYXRpb24vanNvbjtjaGFyc2V0PXV0Zi04O2Jhc2U2NCwnICsgYmFzZTY0O1xuXG5cdHJldHVybiAnLyojICcgKyBkYXRhICsgJyAqLyc7XG59XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiMjNjNlwiOlxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG4vLyBnZXR0aW5nIHRhZyBmcm9tIDE5LjEuMy42IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcoKVxudmFyIGNvZiA9IF9fd2VicGFja19yZXF1aXJlX18oXCIyZDk1XCIpO1xudmFyIFRBRyA9IF9fd2VicGFja19yZXF1aXJlX18oXCIyYjRjXCIpKCd0b1N0cmluZ1RhZycpO1xuLy8gRVMzIHdyb25nIGhlcmVcbnZhciBBUkcgPSBjb2YoZnVuY3Rpb24gKCkgeyByZXR1cm4gYXJndW1lbnRzOyB9KCkpID09ICdBcmd1bWVudHMnO1xuXG4vLyBmYWxsYmFjayBmb3IgSUUxMSBTY3JpcHQgQWNjZXNzIERlbmllZCBlcnJvclxudmFyIHRyeUdldCA9IGZ1bmN0aW9uIChpdCwga2V5KSB7XG4gIHRyeSB7XG4gICAgcmV0dXJuIGl0W2tleV07XG4gIH0gY2F0Y2ggKGUpIHsgLyogZW1wdHkgKi8gfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXQpIHtcbiAgdmFyIE8sIFQsIEI7XG4gIHJldHVybiBpdCA9PT0gdW5kZWZpbmVkID8gJ1VuZGVmaW5lZCcgOiBpdCA9PT0gbnVsbCA/ICdOdWxsJ1xuICAgIC8vIEBAdG9TdHJpbmdUYWcgY2FzZVxuICAgIDogdHlwZW9mIChUID0gdHJ5R2V0KE8gPSBPYmplY3QoaXQpLCBUQUcpKSA9PSAnc3RyaW5nJyA/IFRcbiAgICAvLyBidWlsdGluVGFnIGNhc2VcbiAgICA6IEFSRyA/IGNvZihPKVxuICAgIC8vIEVTMyBhcmd1bWVudHMgZmFsbGJhY2tcbiAgICA6IChCID0gY29mKE8pKSA9PSAnT2JqZWN0JyAmJiB0eXBlb2YgTy5jYWxsZWUgPT0gJ2Z1bmN0aW9uJyA/ICdBcmd1bWVudHMnIDogQjtcbn07XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiMjYyMVwiOlxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG5leHBvcnRzLmYgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzO1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIjI4NzdcIjpcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG4vKiBoYXJtb255IGV4cG9ydCAoYmluZGluZykgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwiYVwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIG5vcm1hbGl6ZUNvbXBvbmVudDsgfSk7XG4vKiBnbG9iYWxzIF9fVlVFX1NTUl9DT05URVhUX18gKi9cblxuLy8gSU1QT1JUQU5UOiBEbyBOT1QgdXNlIEVTMjAxNSBmZWF0dXJlcyBpbiB0aGlzIGZpbGUgKGV4Y2VwdCBmb3IgbW9kdWxlcykuXG4vLyBUaGlzIG1vZHVsZSBpcyBhIHJ1bnRpbWUgdXRpbGl0eSBmb3IgY2xlYW5lciBjb21wb25lbnQgbW9kdWxlIG91dHB1dCBhbmQgd2lsbFxuLy8gYmUgaW5jbHVkZWQgaW4gdGhlIGZpbmFsIHdlYnBhY2sgdXNlciBidW5kbGUuXG5cbmZ1bmN0aW9uIG5vcm1hbGl6ZUNvbXBvbmVudCAoXG4gIHNjcmlwdEV4cG9ydHMsXG4gIHJlbmRlcixcbiAgc3RhdGljUmVuZGVyRm5zLFxuICBmdW5jdGlvbmFsVGVtcGxhdGUsXG4gIGluamVjdFN0eWxlcyxcbiAgc2NvcGVJZCxcbiAgbW9kdWxlSWRlbnRpZmllciwgLyogc2VydmVyIG9ubHkgKi9cbiAgc2hhZG93TW9kZSAvKiB2dWUtY2xpIG9ubHkgKi9cbikge1xuICAvLyBWdWUuZXh0ZW5kIGNvbnN0cnVjdG9yIGV4cG9ydCBpbnRlcm9wXG4gIHZhciBvcHRpb25zID0gdHlwZW9mIHNjcmlwdEV4cG9ydHMgPT09ICdmdW5jdGlvbidcbiAgICA/IHNjcmlwdEV4cG9ydHMub3B0aW9uc1xuICAgIDogc2NyaXB0RXhwb3J0c1xuXG4gIC8vIHJlbmRlciBmdW5jdGlvbnNcbiAgaWYgKHJlbmRlcikge1xuICAgIG9wdGlvbnMucmVuZGVyID0gcmVuZGVyXG4gICAgb3B0aW9ucy5zdGF0aWNSZW5kZXJGbnMgPSBzdGF0aWNSZW5kZXJGbnNcbiAgICBvcHRpb25zLl9jb21waWxlZCA9IHRydWVcbiAgfVxuXG4gIC8vIGZ1bmN0aW9uYWwgdGVtcGxhdGVcbiAgaWYgKGZ1bmN0aW9uYWxUZW1wbGF0ZSkge1xuICAgIG9wdGlvbnMuZnVuY3Rpb25hbCA9IHRydWVcbiAgfVxuXG4gIC8vIHNjb3BlZElkXG4gIGlmIChzY29wZUlkKSB7XG4gICAgb3B0aW9ucy5fc2NvcGVJZCA9ICdkYXRhLXYtJyArIHNjb3BlSWRcbiAgfVxuXG4gIHZhciBob29rXG4gIGlmIChtb2R1bGVJZGVudGlmaWVyKSB7IC8vIHNlcnZlciBidWlsZFxuICAgIGhvb2sgPSBmdW5jdGlvbiAoY29udGV4dCkge1xuICAgICAgLy8gMi4zIGluamVjdGlvblxuICAgICAgY29udGV4dCA9XG4gICAgICAgIGNvbnRleHQgfHwgLy8gY2FjaGVkIGNhbGxcbiAgICAgICAgKHRoaXMuJHZub2RlICYmIHRoaXMuJHZub2RlLnNzckNvbnRleHQpIHx8IC8vIHN0YXRlZnVsXG4gICAgICAgICh0aGlzLnBhcmVudCAmJiB0aGlzLnBhcmVudC4kdm5vZGUgJiYgdGhpcy5wYXJlbnQuJHZub2RlLnNzckNvbnRleHQpIC8vIGZ1bmN0aW9uYWxcbiAgICAgIC8vIDIuMiB3aXRoIHJ1bkluTmV3Q29udGV4dDogdHJ1ZVxuICAgICAgaWYgKCFjb250ZXh0ICYmIHR5cGVvZiBfX1ZVRV9TU1JfQ09OVEVYVF9fICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICBjb250ZXh0ID0gX19WVUVfU1NSX0NPTlRFWFRfX1xuICAgICAgfVxuICAgICAgLy8gaW5qZWN0IGNvbXBvbmVudCBzdHlsZXNcbiAgICAgIGlmIChpbmplY3RTdHlsZXMpIHtcbiAgICAgICAgaW5qZWN0U3R5bGVzLmNhbGwodGhpcywgY29udGV4dClcbiAgICAgIH1cbiAgICAgIC8vIHJlZ2lzdGVyIGNvbXBvbmVudCBtb2R1bGUgaWRlbnRpZmllciBmb3IgYXN5bmMgY2h1bmsgaW5mZXJyZW5jZVxuICAgICAgaWYgKGNvbnRleHQgJiYgY29udGV4dC5fcmVnaXN0ZXJlZENvbXBvbmVudHMpIHtcbiAgICAgICAgY29udGV4dC5fcmVnaXN0ZXJlZENvbXBvbmVudHMuYWRkKG1vZHVsZUlkZW50aWZpZXIpXG4gICAgICB9XG4gICAgfVxuICAgIC8vIHVzZWQgYnkgc3NyIGluIGNhc2UgY29tcG9uZW50IGlzIGNhY2hlZCBhbmQgYmVmb3JlQ3JlYXRlXG4gICAgLy8gbmV2ZXIgZ2V0cyBjYWxsZWRcbiAgICBvcHRpb25zLl9zc3JSZWdpc3RlciA9IGhvb2tcbiAgfSBlbHNlIGlmIChpbmplY3RTdHlsZXMpIHtcbiAgICBob29rID0gc2hhZG93TW9kZVxuICAgICAgPyBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGluamVjdFN0eWxlcy5jYWxsKFxuICAgICAgICAgIHRoaXMsXG4gICAgICAgICAgKG9wdGlvbnMuZnVuY3Rpb25hbCA/IHRoaXMucGFyZW50IDogdGhpcykuJHJvb3QuJG9wdGlvbnMuc2hhZG93Um9vdFxuICAgICAgICApXG4gICAgICB9XG4gICAgICA6IGluamVjdFN0eWxlc1xuICB9XG5cbiAgaWYgKGhvb2spIHtcbiAgICBpZiAob3B0aW9ucy5mdW5jdGlvbmFsKSB7XG4gICAgICAvLyBmb3IgdGVtcGxhdGUtb25seSBob3QtcmVsb2FkIGJlY2F1c2UgaW4gdGhhdCBjYXNlIHRoZSByZW5kZXIgZm4gZG9lc24ndFxuICAgICAgLy8gZ28gdGhyb3VnaCB0aGUgbm9ybWFsaXplclxuICAgICAgb3B0aW9ucy5faW5qZWN0U3R5bGVzID0gaG9va1xuICAgICAgLy8gcmVnaXN0ZXIgZm9yIGZ1bmN0aW9uYWwgY29tcG9uZW50IGluIHZ1ZSBmaWxlXG4gICAgICB2YXIgb3JpZ2luYWxSZW5kZXIgPSBvcHRpb25zLnJlbmRlclxuICAgICAgb3B0aW9ucy5yZW5kZXIgPSBmdW5jdGlvbiByZW5kZXJXaXRoU3R5bGVJbmplY3Rpb24gKGgsIGNvbnRleHQpIHtcbiAgICAgICAgaG9vay5jYWxsKGNvbnRleHQpXG4gICAgICAgIHJldHVybiBvcmlnaW5hbFJlbmRlcihoLCBjb250ZXh0KVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBpbmplY3QgY29tcG9uZW50IHJlZ2lzdHJhdGlvbiBhcyBiZWZvcmVDcmVhdGUgaG9va1xuICAgICAgdmFyIGV4aXN0aW5nID0gb3B0aW9ucy5iZWZvcmVDcmVhdGVcbiAgICAgIG9wdGlvbnMuYmVmb3JlQ3JlYXRlID0gZXhpc3RpbmdcbiAgICAgICAgPyBbXS5jb25jYXQoZXhpc3RpbmcsIGhvb2spXG4gICAgICAgIDogW2hvb2tdXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBleHBvcnRzOiBzY3JpcHRFeHBvcnRzLFxuICAgIG9wdGlvbnM6IG9wdGlvbnNcbiAgfVxufVxuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIjJhYmFcIjpcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxudmFyIGdsb2JhbCA9IF9fd2VicGFja19yZXF1aXJlX18oXCI3NzI2XCIpO1xudmFyIGhpZGUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiMzJlOVwiKTtcbnZhciBoYXMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiNjlhOFwiKTtcbnZhciBTUkMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiY2E1YVwiKSgnc3JjJyk7XG52YXIgJHRvU3RyaW5nID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcImZhNWJcIik7XG52YXIgVE9fU1RSSU5HID0gJ3RvU3RyaW5nJztcbnZhciBUUEwgPSAoJycgKyAkdG9TdHJpbmcpLnNwbGl0KFRPX1NUUklORyk7XG5cbl9fd2VicGFja19yZXF1aXJlX18oXCI4Mzc4XCIpLmluc3BlY3RTb3VyY2UgPSBmdW5jdGlvbiAoaXQpIHtcbiAgcmV0dXJuICR0b1N0cmluZy5jYWxsKGl0KTtcbn07XG5cbihtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChPLCBrZXksIHZhbCwgc2FmZSkge1xuICB2YXIgaXNGdW5jdGlvbiA9IHR5cGVvZiB2YWwgPT0gJ2Z1bmN0aW9uJztcbiAgaWYgKGlzRnVuY3Rpb24pIGhhcyh2YWwsICduYW1lJykgfHwgaGlkZSh2YWwsICduYW1lJywga2V5KTtcbiAgaWYgKE9ba2V5XSA9PT0gdmFsKSByZXR1cm47XG4gIGlmIChpc0Z1bmN0aW9uKSBoYXModmFsLCBTUkMpIHx8IGhpZGUodmFsLCBTUkMsIE9ba2V5XSA/ICcnICsgT1trZXldIDogVFBMLmpvaW4oU3RyaW5nKGtleSkpKTtcbiAgaWYgKE8gPT09IGdsb2JhbCkge1xuICAgIE9ba2V5XSA9IHZhbDtcbiAgfSBlbHNlIGlmICghc2FmZSkge1xuICAgIGRlbGV0ZSBPW2tleV07XG4gICAgaGlkZShPLCBrZXksIHZhbCk7XG4gIH0gZWxzZSBpZiAoT1trZXldKSB7XG4gICAgT1trZXldID0gdmFsO1xuICB9IGVsc2Uge1xuICAgIGhpZGUoTywga2V5LCB2YWwpO1xuICB9XG4vLyBhZGQgZmFrZSBGdW5jdGlvbiN0b1N0cmluZyBmb3IgY29ycmVjdCB3b3JrIHdyYXBwZWQgbWV0aG9kcyAvIGNvbnN0cnVjdG9ycyB3aXRoIG1ldGhvZHMgbGlrZSBMb0Rhc2ggaXNOYXRpdmVcbn0pKEZ1bmN0aW9uLnByb3RvdHlwZSwgVE9fU1RSSU5HLCBmdW5jdGlvbiB0b1N0cmluZygpIHtcbiAgcmV0dXJuIHR5cGVvZiB0aGlzID09ICdmdW5jdGlvbicgJiYgdGhpc1tTUkNdIHx8ICR0b1N0cmluZy5jYWxsKHRoaXMpO1xufSk7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiMmFlYlwiOlxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG4vLyAxOS4xLjIuMiAvIDE1LjIuMy41IE9iamVjdC5jcmVhdGUoTyBbLCBQcm9wZXJ0aWVzXSlcbnZhciBhbk9iamVjdCA9IF9fd2VicGFja19yZXF1aXJlX18oXCJjYjdjXCIpO1xudmFyIGRQcyA9IF9fd2VicGFja19yZXF1aXJlX18oXCIxNDk1XCIpO1xudmFyIGVudW1CdWdLZXlzID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcImUxMWVcIik7XG52YXIgSUVfUFJPVE8gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiNjEzYlwiKSgnSUVfUFJPVE8nKTtcbnZhciBFbXB0eSA9IGZ1bmN0aW9uICgpIHsgLyogZW1wdHkgKi8gfTtcbnZhciBQUk9UT1RZUEUgPSAncHJvdG90eXBlJztcblxuLy8gQ3JlYXRlIG9iamVjdCB3aXRoIGZha2UgYG51bGxgIHByb3RvdHlwZTogdXNlIGlmcmFtZSBPYmplY3Qgd2l0aCBjbGVhcmVkIHByb3RvdHlwZVxudmFyIGNyZWF0ZURpY3QgPSBmdW5jdGlvbiAoKSB7XG4gIC8vIFRocmFzaCwgd2FzdGUgYW5kIHNvZG9teTogSUUgR0MgYnVnXG4gIHZhciBpZnJhbWUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiMjMwZVwiKSgnaWZyYW1lJyk7XG4gIHZhciBpID0gZW51bUJ1Z0tleXMubGVuZ3RoO1xuICB2YXIgbHQgPSAnPCc7XG4gIHZhciBndCA9ICc+JztcbiAgdmFyIGlmcmFtZURvY3VtZW50O1xuICBpZnJhbWUuc3R5bGUuZGlzcGxheSA9ICdub25lJztcbiAgX193ZWJwYWNrX3JlcXVpcmVfXyhcImZhYjJcIikuYXBwZW5kQ2hpbGQoaWZyYW1lKTtcbiAgaWZyYW1lLnNyYyA9ICdqYXZhc2NyaXB0Oic7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tc2NyaXB0LXVybFxuICAvLyBjcmVhdGVEaWN0ID0gaWZyYW1lLmNvbnRlbnRXaW5kb3cuT2JqZWN0O1xuICAvLyBodG1sLnJlbW92ZUNoaWxkKGlmcmFtZSk7XG4gIGlmcmFtZURvY3VtZW50ID0gaWZyYW1lLmNvbnRlbnRXaW5kb3cuZG9jdW1lbnQ7XG4gIGlmcmFtZURvY3VtZW50Lm9wZW4oKTtcbiAgaWZyYW1lRG9jdW1lbnQud3JpdGUobHQgKyAnc2NyaXB0JyArIGd0ICsgJ2RvY3VtZW50LkY9T2JqZWN0JyArIGx0ICsgJy9zY3JpcHQnICsgZ3QpO1xuICBpZnJhbWVEb2N1bWVudC5jbG9zZSgpO1xuICBjcmVhdGVEaWN0ID0gaWZyYW1lRG9jdW1lbnQuRjtcbiAgd2hpbGUgKGktLSkgZGVsZXRlIGNyZWF0ZURpY3RbUFJPVE9UWVBFXVtlbnVtQnVnS2V5c1tpXV07XG4gIHJldHVybiBjcmVhdGVEaWN0KCk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IE9iamVjdC5jcmVhdGUgfHwgZnVuY3Rpb24gY3JlYXRlKE8sIFByb3BlcnRpZXMpIHtcbiAgdmFyIHJlc3VsdDtcbiAgaWYgKE8gIT09IG51bGwpIHtcbiAgICBFbXB0eVtQUk9UT1RZUEVdID0gYW5PYmplY3QoTyk7XG4gICAgcmVzdWx0ID0gbmV3IEVtcHR5KCk7XG4gICAgRW1wdHlbUFJPVE9UWVBFXSA9IG51bGw7XG4gICAgLy8gYWRkIFwiX19wcm90b19fXCIgZm9yIE9iamVjdC5nZXRQcm90b3R5cGVPZiBwb2x5ZmlsbFxuICAgIHJlc3VsdFtJRV9QUk9UT10gPSBPO1xuICB9IGVsc2UgcmVzdWx0ID0gY3JlYXRlRGljdCgpO1xuICByZXR1cm4gUHJvcGVydGllcyA9PT0gdW5kZWZpbmVkID8gcmVzdWx0IDogZFBzKHJlc3VsdCwgUHJvcGVydGllcyk7XG59O1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIjJhZjlcIjpcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG4vKiBXRUJQQUNLIFZBUiBJTkpFQ1RJT04gKi8oZnVuY3Rpb24oZ2xvYmFsKSB7LyogaGFybW9ueSBleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcImRcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBpbnN0YWxsOyB9KTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBjb3JlX2pzX21vZHVsZXNfZXM2X2Z1bmN0aW9uX25hbWVfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXyA9IF9fd2VicGFja19yZXF1aXJlX18oXCI3ZjdmXCIpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIGNvcmVfanNfbW9kdWxlc19lczZfZnVuY3Rpb25fbmFtZV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fX2RlZmF1bHQgPSAvKiNfX1BVUkVfXyovX193ZWJwYWNrX3JlcXVpcmVfXy5uKGNvcmVfanNfbW9kdWxlc19lczZfZnVuY3Rpb25fbmFtZV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBjb3JlX2pzX21vZHVsZXNfZXM2X2FycmF5X2l0ZXJhdG9yX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiY2FkZlwiKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBjb3JlX2pzX21vZHVsZXNfZXM2X2FycmF5X2l0ZXJhdG9yX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19fZGVmYXVsdCA9IC8qI19fUFVSRV9fKi9fX3dlYnBhY2tfcmVxdWlyZV9fLm4oY29yZV9qc19tb2R1bGVzX2VzNl9hcnJheV9pdGVyYXRvcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBjb3JlX2pzX21vZHVsZXNfZXM2X29iamVjdF9rZXlzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiNDU2ZFwiKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBjb3JlX2pzX21vZHVsZXNfZXM2X29iamVjdF9rZXlzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX19fZGVmYXVsdCA9IC8qI19fUFVSRV9fKi9fX3dlYnBhY2tfcmVxdWlyZV9fLm4oY29yZV9qc19tb2R1bGVzX2VzNl9vYmplY3Rfa2V5c19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBjb3JlX2pzX21vZHVsZXNfd2ViX2RvbV9pdGVyYWJsZV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcImFjNmFcIik7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgY29yZV9qc19tb2R1bGVzX3dlYl9kb21faXRlcmFibGVfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfX19kZWZhdWx0ID0gLyojX19QVVJFX18qL19fd2VicGFja19yZXF1aXJlX18ubihjb3JlX2pzX21vZHVsZXNfd2ViX2RvbV9pdGVyYWJsZV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfR3JpZEl0ZW1fdnVlX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV80X18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiYmMyMVwiKTtcbi8qIGhhcm1vbnkgcmVleHBvcnQgKHNhZmUpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcImFcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBfR3JpZEl0ZW1fdnVlX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV80X19bXCJhXCJdOyB9KTtcblxuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9HcmlkTGF5b3V0X3Z1ZV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNV9fID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIjM3YzhcIik7XG4vKiBoYXJtb255IHJlZXhwb3J0IChzYWZlKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXCJiXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gX0dyaWRMYXlvdXRfdnVlX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV81X19bXCJhXCJdOyB9KTtcblxuXG5cblxuXG5cbiAvLyBpbXBvcnQgUmVzcG9uc2l2ZUdyaWRMYXlvdXQgZnJvbSAnLi9SZXNwb25zaXZlR3JpZExheW91dC52dWUnO1xuXG52YXIgVnVlR3JpZExheW91dCA9IHtcbiAgLy8gUmVzcG9uc2l2ZUdyaWRMYXlvdXQsXG4gIEdyaWRMYXlvdXQ6IF9HcmlkTGF5b3V0X3Z1ZV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNV9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLFxuICBHcmlkSXRlbTogX0dyaWRJdGVtX3Z1ZV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNF9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdXG59O1xuZnVuY3Rpb24gaW5zdGFsbChWdWUpIHtcbiAgaWYgKGluc3RhbGwuaW5zdGFsbGVkKSByZXR1cm47XG4gIGluc3RhbGwuaW5zdGFsbGVkID0gdHJ1ZTtcbiAgT2JqZWN0LmtleXMoVnVlR3JpZExheW91dCkuZm9yRWFjaChmdW5jdGlvbiAobmFtZSkge1xuICAgIFZ1ZS5jb21wb25lbnQobmFtZSwgVnVlR3JpZExheW91dFtuYW1lXSk7XG4gIH0pO1xufVxudmFyIHBsdWdpbiA9IHtcbiAgaW5zdGFsbDogaW5zdGFsbFxufTtcbnZhciBHbG9iYWxWdWUgPSBudWxsO1xuXG5pZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgR2xvYmFsVnVlID0gd2luZG93LlZ1ZTtcbn0gZWxzZSBpZiAodHlwZW9mIGdsb2JhbCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgR2xvYmFsVnVlID0gZ2xvYmFsLlZ1ZTtcbn1cblxuaWYgKEdsb2JhbFZ1ZSkge1xuICBHbG9iYWxWdWUudXNlKHBsdWdpbik7XG59XG5cbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gX193ZWJwYWNrX2V4cG9ydHNfX1tcImNcIl0gPSAoVnVlR3JpZExheW91dCk7XG5cbi8qIFdFQlBBQ0sgVkFSIElOSkVDVElPTiAqL30uY2FsbCh0aGlzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiYzhiYVwiKSkpXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIjJiNGNcIjpcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxudmFyIHN0b3JlID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIjU1MzdcIikoJ3drcycpO1xudmFyIHVpZCA9IF9fd2VicGFja19yZXF1aXJlX18oXCJjYTVhXCIpO1xudmFyIFN5bWJvbCA9IF9fd2VicGFja19yZXF1aXJlX18oXCI3NzI2XCIpLlN5bWJvbDtcbnZhciBVU0VfU1lNQk9MID0gdHlwZW9mIFN5bWJvbCA9PSAnZnVuY3Rpb24nO1xuXG52YXIgJGV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gIHJldHVybiBzdG9yZVtuYW1lXSB8fCAoc3RvcmVbbmFtZV0gPVxuICAgIFVTRV9TWU1CT0wgJiYgU3ltYm9sW25hbWVdIHx8IChVU0VfU1lNQk9MID8gU3ltYm9sIDogdWlkKSgnU3ltYm9sLicgKyBuYW1lKSk7XG59O1xuXG4kZXhwb3J0cy5zdG9yZSA9IHN0b3JlO1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIjJjZWZcIjpcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgaWRDb3VudCA9IDE7XG5cbiAgICAvKipcbiAgICAgKiBHZW5lcmF0ZXMgYSBuZXcgdW5pcXVlIGlkIGluIHRoZSBjb250ZXh0LlxuICAgICAqIEBwdWJsaWNcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBBIHVuaXF1ZSBpZCBpbiB0aGUgY29udGV4dC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBnZW5lcmF0ZSgpIHtcbiAgICAgICAgcmV0dXJuIGlkQ291bnQrKztcbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgICBnZW5lcmF0ZTogZ2VuZXJhdGVcbiAgICB9O1xufTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIyZDAwXCI6XG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cbm1vZHVsZS5leHBvcnRzID0gZmFsc2U7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiMmQ5NVwiOlxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG52YXIgdG9TdHJpbmcgPSB7fS50b1N0cmluZztcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXQpIHtcbiAgcmV0dXJuIHRvU3RyaW5nLmNhbGwoaXQpLnNsaWNlKDgsIC0xKTtcbn07XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiMmYyMVwiOlxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxudmFyIGZhaWxzID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIjc5ZTVcIik7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKG1ldGhvZCwgYXJnKSB7XG4gIHJldHVybiAhIW1ldGhvZCAmJiBmYWlscyhmdW5jdGlvbiAoKSB7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVzZWxlc3MtY2FsbFxuICAgIGFyZyA/IG1ldGhvZC5jYWxsKG51bGwsIGZ1bmN0aW9uICgpIHsgLyogZW1wdHkgKi8gfSwgMSkgOiBtZXRob2QuY2FsbChudWxsKTtcbiAgfSk7XG59O1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIjMyZTlcIjpcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxudmFyIGRQID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIjg2Y2NcIik7XG52YXIgY3JlYXRlRGVzYyA9IF9fd2VicGFja19yZXF1aXJlX18oXCI0NjMwXCIpO1xubW9kdWxlLmV4cG9ydHMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiOWUxZVwiKSA/IGZ1bmN0aW9uIChvYmplY3QsIGtleSwgdmFsdWUpIHtcbiAgcmV0dXJuIGRQLmYob2JqZWN0LCBrZXksIGNyZWF0ZURlc2MoMSwgdmFsdWUpKTtcbn0gOiBmdW5jdGlvbiAob2JqZWN0LCBrZXksIHZhbHVlKSB7XG4gIG9iamVjdFtrZXldID0gdmFsdWU7XG4gIHJldHVybiBvYmplY3Q7XG59O1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIjM3YzhcIjpcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vbm9kZV9tb2R1bGVzL2NhY2hlLWxvYWRlci9kaXN0L2Nqcy5qcz97XCJjYWNoZURpcmVjdG9yeVwiOlwibm9kZV9tb2R1bGVzLy5jYWNoZS92dWUtbG9hZGVyXCIsXCJjYWNoZUlkZW50aWZpZXJcIjpcIjA0OGUyNmMwLXZ1ZS1sb2FkZXItdGVtcGxhdGVcIn0hLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvbG9hZGVycy90ZW1wbGF0ZUxvYWRlci5qcz8/dnVlLWxvYWRlci1vcHRpb25zIS4vbm9kZV9tb2R1bGVzL2NhY2hlLWxvYWRlci9kaXN0L2Nqcy5qcz8/cmVmLS0wLTAhLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWI/P3Z1ZS1sb2FkZXItb3B0aW9ucyEuL3NyYy9jb21wb25lbnRzL0dyaWRMYXlvdXQudnVlP3Z1ZSZ0eXBlPXRlbXBsYXRlJmlkPWRiM2I1YTFjJlxudmFyIHJlbmRlciA9IGZ1bmN0aW9uICgpIHt2YXIgX3ZtPXRoaXM7dmFyIF9oPV92bS4kY3JlYXRlRWxlbWVudDt2YXIgX2M9X3ZtLl9zZWxmLl9jfHxfaDtyZXR1cm4gX2MoJ2Rpdicse3JlZjpcIml0ZW1cIixzdGF0aWNDbGFzczpcInZ1ZS1ncmlkLWxheW91dFwiLHN0eWxlOihfdm0ubWVyZ2VkU3R5bGUpfSxbX3ZtLl90KFwiZGVmYXVsdFwiKSxfYygnZ3JpZC1pdGVtJyx7ZGlyZWN0aXZlczpbe25hbWU6XCJzaG93XCIscmF3TmFtZTpcInYtc2hvd1wiLHZhbHVlOihfdm0uaXNEcmFnZ2luZyksZXhwcmVzc2lvbjpcImlzRHJhZ2dpbmdcIn1dLHN0YXRpY0NsYXNzOlwidnVlLWdyaWQtcGxhY2Vob2xkZXJcIixhdHRyczp7XCJ4XCI6X3ZtLnBsYWNlaG9sZGVyLngsXCJ5XCI6X3ZtLnBsYWNlaG9sZGVyLnksXCJ3XCI6X3ZtLnBsYWNlaG9sZGVyLncsXCJoXCI6X3ZtLnBsYWNlaG9sZGVyLmgsXCJpXCI6X3ZtLnBsYWNlaG9sZGVyLml9fSldLDIpfVxudmFyIHN0YXRpY1JlbmRlckZucyA9IFtdXG5cblxuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvY29tcG9uZW50cy9HcmlkTGF5b3V0LnZ1ZT92dWUmdHlwZT10ZW1wbGF0ZSZpZD1kYjNiNWExYyZcblxuLy8gRVhURVJOQUwgTU9EVUxFOiAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM3Lm9iamVjdC5nZXQtb3duLXByb3BlcnR5LWRlc2NyaXB0b3JzLmpzXG52YXIgZXM3X29iamVjdF9nZXRfb3duX3Byb3BlcnR5X2Rlc2NyaXB0b3JzID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIjhlNmVcIik7XG5cbi8vIEVYVEVSTkFMIE1PRFVMRTogLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5hcnJheS5pdGVyYXRvci5qc1xudmFyIGVzNl9hcnJheV9pdGVyYXRvciA9IF9fd2VicGFja19yZXF1aXJlX18oXCJjYWRmXCIpO1xuXG4vLyBFWFRFUk5BTCBNT0RVTEU6IC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYub2JqZWN0LmtleXMuanNcbnZhciBlczZfb2JqZWN0X2tleXMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiNDU2ZFwiKTtcblxuLy8gRVhURVJOQUwgTU9EVUxFOiAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2Lm9iamVjdC5hc3NpZ24uanNcbnZhciBlczZfb2JqZWN0X2Fzc2lnbiA9IF9fd2VicGFja19yZXF1aXJlX18oXCJmNzUxXCIpO1xuXG4vLyBFWFRFUk5BTCBNT0RVTEU6IC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYubnVtYmVyLmlzLWZpbml0ZS5qc1xudmFyIGVzNl9udW1iZXJfaXNfZmluaXRlID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcImZjYTBcIik7XG5cbi8vIEVYVEVSTkFMIE1PRFVMRTogLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL3dlYi5kb20uaXRlcmFibGUuanNcbnZhciB3ZWJfZG9tX2l0ZXJhYmxlID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcImFjNmFcIik7XG5cbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL2RlZmluZVByb3BlcnR5LmpzXG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHZhbHVlKSB7XG4gIGlmIChrZXkgaW4gb2JqKSB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwga2V5LCB7XG4gICAgICB2YWx1ZTogdmFsdWUsXG4gICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgd3JpdGFibGU6IHRydWVcbiAgICB9KTtcbiAgfSBlbHNlIHtcbiAgICBvYmpba2V5XSA9IHZhbHVlO1xuICB9XG5cbiAgcmV0dXJuIG9iajtcbn1cbi8vIEVYVEVSTkFMIE1PRFVMRTogLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5udW1iZXIuY29uc3RydWN0b3IuanNcbnZhciBlczZfbnVtYmVyX2NvbnN0cnVjdG9yID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcImM1ZjZcIik7XG5cbi8vIEVYVEVSTkFMIE1PRFVMRTogZXh0ZXJuYWwge1wiY29tbW9uanNcIjpcInZ1ZVwiLFwiY29tbW9uanMyXCI6XCJ2dWVcIixcInJvb3RcIjpcIlZ1ZVwifVxudmFyIGV4dGVybmFsX2NvbW1vbmpzX3Z1ZV9jb21tb25qczJfdnVlX3Jvb3RfVnVlXyA9IF9fd2VicGFja19yZXF1aXJlX18oXCI4YmJmXCIpO1xudmFyIGV4dGVybmFsX2NvbW1vbmpzX3Z1ZV9jb21tb25qczJfdnVlX3Jvb3RfVnVlX2RlZmF1bHQgPSAvKiNfX1BVUkVfXyovX193ZWJwYWNrX3JlcXVpcmVfXy5uKGV4dGVybmFsX2NvbW1vbmpzX3Z1ZV9jb21tb25qczJfdnVlX3Jvb3RfVnVlXyk7XG5cbi8vIEVYVEVSTkFMIE1PRFVMRTogLi9zcmMvaGVscGVycy91dGlscy5qc1xudmFyIHV0aWxzID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcImEyYjZcIik7XG5cbi8vIEVYVEVSTkFMIE1PRFVMRTogLi9zcmMvaGVscGVycy9yZXNwb25zaXZlVXRpbHMuanNcbnZhciByZXNwb25zaXZlVXRpbHMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiOTdhN1wiKTtcblxuLy8gRVhURVJOQUwgTU9EVUxFOiAuL3NyYy9jb21wb25lbnRzL0dyaWRJdGVtLnZ1ZSArIDY5IG1vZHVsZXNcbnZhciBHcmlkSXRlbSA9IF9fd2VicGFja19yZXF1aXJlX18oXCJiYzIxXCIpO1xuXG4vLyBFWFRFUk5BTCBNT0RVTEU6IC4vc3JjL2hlbHBlcnMvRE9NLmpzXG52YXIgRE9NID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIjFjYTdcIik7XG5cbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vbm9kZV9tb2R1bGVzL2NhY2hlLWxvYWRlci9kaXN0L2Nqcy5qcz8/cmVmLS0xMi0wIS4vbm9kZV9tb2R1bGVzL3RocmVhZC1sb2FkZXIvZGlzdC9janMuanMhLi9ub2RlX21vZHVsZXMvYmFiZWwtbG9hZGVyL2xpYiEuL25vZGVfbW9kdWxlcy9jYWNoZS1sb2FkZXIvZGlzdC9janMuanM/P3JlZi0tMC0wIS4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliPz92dWUtbG9hZGVyLW9wdGlvbnMhLi9zcmMvY29tcG9uZW50cy9HcmlkTGF5b3V0LnZ1ZT92dWUmdHlwZT1zY3JpcHQmbGFuZz1qcyZcblxuXG5cblxuXG5cblxuXG5cbmZ1bmN0aW9uIG93bktleXMob2JqZWN0LCBlbnVtZXJhYmxlT25seSkgeyB2YXIga2V5cyA9IE9iamVjdC5rZXlzKG9iamVjdCk7IGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7IHZhciBzeW1ib2xzID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhvYmplY3QpOyBpZiAoZW51bWVyYWJsZU9ubHkpIHN5bWJvbHMgPSBzeW1ib2xzLmZpbHRlcihmdW5jdGlvbiAoc3ltKSB7IHJldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iamVjdCwgc3ltKS5lbnVtZXJhYmxlOyB9KTsga2V5cy5wdXNoLmFwcGx5KGtleXMsIHN5bWJvbHMpOyB9IHJldHVybiBrZXlzOyB9XG5cbmZ1bmN0aW9uIF9vYmplY3RTcHJlYWQodGFyZ2V0KSB7IGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7IHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV0gIT0gbnVsbCA/IGFyZ3VtZW50c1tpXSA6IHt9OyBpZiAoaSAlIDIpIHsgb3duS2V5cyhPYmplY3Qoc291cmNlKSwgdHJ1ZSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7IF9kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgc291cmNlW2tleV0pOyB9KTsgfSBlbHNlIGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycykgeyBPYmplY3QuZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKHNvdXJjZSkpOyB9IGVsc2UgeyBvd25LZXlzKE9iamVjdChzb3VyY2UpKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHNvdXJjZSwga2V5KSk7IH0pOyB9IH0gcmV0dXJuIHRhcmdldDsgfVxuXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG5cblxudmFyIGVsZW1lbnRSZXNpemVEZXRlY3Rvck1ha2VyID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcImVlYzRcIik7XG5cblxuIC8vdmFyIGV2ZW50QnVzID0gcmVxdWlyZSgnLi9ldmVudEJ1cycpO1xuXG5cblxuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyB2YXIgR3JpZExheW91dHZ1ZV90eXBlX3NjcmlwdF9sYW5nX2pzXyA9ICh7XG4gIG5hbWU6IFwiR3JpZExheW91dFwiLFxuICBwcm92aWRlOiBmdW5jdGlvbiBwcm92aWRlKCkge1xuICAgIHJldHVybiB7XG4gICAgICBldmVudEJ1czogbnVsbCxcbiAgICAgIGxheW91dDogdGhpc1xuICAgIH07XG4gIH0sXG4gIGNvbXBvbmVudHM6IHtcbiAgICBHcmlkSXRlbTogR3JpZEl0ZW1bXCJhXCIgLyogZGVmYXVsdCAqL11cbiAgfSxcbiAgcHJvcHM6IHtcbiAgICAvLyBJZiB0cnVlLCB0aGUgY29udGFpbmVyIGhlaWdodCBzd2VsbHMgYW5kIGNvbnRyYWN0cyB0byBmaXQgY29udGVudHNcbiAgICBhdXRvU2l6ZToge1xuICAgICAgdHlwZTogQm9vbGVhbixcbiAgICAgIGRlZmF1bHQ6IHRydWVcbiAgICB9LFxuICAgIGNvbE51bToge1xuICAgICAgdHlwZTogTnVtYmVyLFxuICAgICAgZGVmYXVsdDogMTJcbiAgICB9LFxuICAgIHJvd0hlaWdodDoge1xuICAgICAgdHlwZTogTnVtYmVyLFxuICAgICAgZGVmYXVsdDogMTUwXG4gICAgfSxcbiAgICBtYXhSb3dzOiB7XG4gICAgICB0eXBlOiBOdW1iZXIsXG4gICAgICBkZWZhdWx0OiBJbmZpbml0eVxuICAgIH0sXG4gICAgbWFyZ2luOiB7XG4gICAgICB0eXBlOiBBcnJheSxcbiAgICAgIGRlZmF1bHQ6IGZ1bmN0aW9uIF9kZWZhdWx0KCkge1xuICAgICAgICByZXR1cm4gWzEwLCAxMF07XG4gICAgICB9XG4gICAgfSxcbiAgICBpc0RyYWdnYWJsZToge1xuICAgICAgdHlwZTogQm9vbGVhbixcbiAgICAgIGRlZmF1bHQ6IHRydWVcbiAgICB9LFxuICAgIGlzUmVzaXphYmxlOiB7XG4gICAgICB0eXBlOiBCb29sZWFuLFxuICAgICAgZGVmYXVsdDogdHJ1ZVxuICAgIH0sXG4gICAgaXNNaXJyb3JlZDoge1xuICAgICAgdHlwZTogQm9vbGVhbixcbiAgICAgIGRlZmF1bHQ6IGZhbHNlXG4gICAgfSxcbiAgICB1c2VDc3NUcmFuc2Zvcm1zOiB7XG4gICAgICB0eXBlOiBCb29sZWFuLFxuICAgICAgZGVmYXVsdDogdHJ1ZVxuICAgIH0sXG4gICAgdmVydGljYWxDb21wYWN0OiB7XG4gICAgICB0eXBlOiBCb29sZWFuLFxuICAgICAgZGVmYXVsdDogdHJ1ZVxuICAgIH0sXG4gICAgbGF5b3V0OiB7XG4gICAgICB0eXBlOiBBcnJheSxcbiAgICAgIHJlcXVpcmVkOiB0cnVlXG4gICAgfSxcbiAgICByZXNwb25zaXZlOiB7XG4gICAgICB0eXBlOiBCb29sZWFuLFxuICAgICAgZGVmYXVsdDogZmFsc2VcbiAgICB9LFxuICAgIHJlc3BvbnNpdmVMYXlvdXRzOiB7XG4gICAgICB0eXBlOiBPYmplY3QsXG4gICAgICBkZWZhdWx0OiBmdW5jdGlvbiBfZGVmYXVsdCgpIHtcbiAgICAgICAgcmV0dXJuIHt9O1xuICAgICAgfVxuICAgIH0sXG4gICAgYnJlYWtwb2ludHM6IHtcbiAgICAgIHR5cGU6IE9iamVjdCxcbiAgICAgIGRlZmF1bHQ6IGZ1bmN0aW9uIF9kZWZhdWx0KCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGxnOiAxMjAwLFxuICAgICAgICAgIG1kOiA5OTYsXG4gICAgICAgICAgc206IDc2OCxcbiAgICAgICAgICB4czogNDgwLFxuICAgICAgICAgIHh4czogMFxuICAgICAgICB9O1xuICAgICAgfVxuICAgIH0sXG4gICAgY29sczoge1xuICAgICAgdHlwZTogT2JqZWN0LFxuICAgICAgZGVmYXVsdDogZnVuY3Rpb24gX2RlZmF1bHQoKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgbGc6IDEyLFxuICAgICAgICAgIG1kOiAxMCxcbiAgICAgICAgICBzbTogNixcbiAgICAgICAgICB4czogNCxcbiAgICAgICAgICB4eHM6IDJcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9LFxuICAgIHByZXZlbnRDb2xsaXNpb246IHtcbiAgICAgIHR5cGU6IEJvb2xlYW4sXG4gICAgICBkZWZhdWx0OiBmYWxzZVxuICAgIH0sXG4gICAgdXNlU3R5bGVDdXJzb3I6IHtcbiAgICAgIHR5cGU6IEJvb2xlYW4sXG4gICAgICBkZWZhdWx0OiB0cnVlXG4gICAgfVxuICB9LFxuICBkYXRhOiBmdW5jdGlvbiBkYXRhKCkge1xuICAgIHJldHVybiB7XG4gICAgICB3aWR0aDogbnVsbCxcbiAgICAgIG1lcmdlZFN0eWxlOiB7fSxcbiAgICAgIGxhc3RMYXlvdXRMZW5ndGg6IDAsXG4gICAgICBpc0RyYWdnaW5nOiBmYWxzZSxcbiAgICAgIHBsYWNlaG9sZGVyOiB7XG4gICAgICAgIHg6IDAsXG4gICAgICAgIHk6IDAsXG4gICAgICAgIHc6IDAsXG4gICAgICAgIGg6IDAsXG4gICAgICAgIGk6IC0xXG4gICAgICB9LFxuICAgICAgbGF5b3V0czoge30sXG4gICAgICAvLyBhcnJheSB0byBzdG9yZSBhbGwgbGF5b3V0cyBmcm9tIGRpZmZlcmVudCBicmVha3BvaW50c1xuICAgICAgbGFzdEJyZWFrcG9pbnQ6IG51bGwsXG4gICAgICAvLyBzdG9yZSBsYXN0IGFjdGl2ZSBicmVha3BvaW50XG4gICAgICBvcmlnaW5hbExheW91dDogbnVsbCAvLyBzdG9yZSBvcmlnaW5hbCBMYXlvdXRcblxuICAgIH07XG4gIH0sXG4gIGNyZWF0ZWQ6IGZ1bmN0aW9uIGNyZWF0ZWQoKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzOyAvLyBBY2Nlc3NpYmxlIHJlZmVybmNlcyBvZiBmdW5jdGlvbnMgZm9yIHJlbW92aW5nIGluIGJlZm9yZURlc3Ryb3lcblxuICAgIHNlbGYucmVzaXplRXZlbnRIYW5kbGVyID0gZnVuY3Rpb24gKGV2ZW50VHlwZSwgaSwgeCwgeSwgaCwgdykge1xuICAgICAgc2VsZi5yZXNpemVFdmVudChldmVudFR5cGUsIGksIHgsIHksIGgsIHcpO1xuICAgIH07XG5cbiAgICBzZWxmLmRyYWdFdmVudEhhbmRsZXIgPSBmdW5jdGlvbiAoZXZlbnRUeXBlLCBpLCB4LCB5LCBoLCB3KSB7XG4gICAgICBzZWxmLmRyYWdFdmVudChldmVudFR5cGUsIGksIHgsIHksIGgsIHcpO1xuICAgIH07XG5cbiAgICBzZWxmLl9wcm92aWRlZC5ldmVudEJ1cyA9IG5ldyBleHRlcm5hbF9jb21tb25qc192dWVfY29tbW9uanMyX3Z1ZV9yb290X1Z1ZV9kZWZhdWx0LmEoKTtcbiAgICBzZWxmLmV2ZW50QnVzID0gc2VsZi5fcHJvdmlkZWQuZXZlbnRCdXM7XG4gICAgc2VsZi5ldmVudEJ1cy4kb24oJ3Jlc2l6ZUV2ZW50Jywgc2VsZi5yZXNpemVFdmVudEhhbmRsZXIpO1xuICAgIHNlbGYuZXZlbnRCdXMuJG9uKCdkcmFnRXZlbnQnLCBzZWxmLmRyYWdFdmVudEhhbmRsZXIpO1xuICAgIHNlbGYuJGVtaXQoJ2xheW91dC1jcmVhdGVkJywgc2VsZi5sYXlvdXQpO1xuICB9LFxuICBiZWZvcmVEZXN0cm95OiBmdW5jdGlvbiBiZWZvcmVEZXN0cm95KCkge1xuICAgIC8vUmVtb3ZlIGxpc3RlbmVyc1xuICAgIHRoaXMuZXZlbnRCdXMuJG9mZigncmVzaXplRXZlbnQnLCB0aGlzLnJlc2l6ZUV2ZW50SGFuZGxlcik7XG4gICAgdGhpcy5ldmVudEJ1cy4kb2ZmKCdkcmFnRXZlbnQnLCB0aGlzLmRyYWdFdmVudEhhbmRsZXIpO1xuICAgIHRoaXMuZXZlbnRCdXMuJGRlc3Ryb3koKTtcbiAgICBPYmplY3QoRE9NW1wiY1wiIC8qIHJlbW92ZVdpbmRvd0V2ZW50TGlzdGVuZXIgKi9dKShcInJlc2l6ZVwiLCB0aGlzLm9uV2luZG93UmVzaXplKTtcblxuICAgIGlmICh0aGlzLmVyZCkge1xuICAgICAgdGhpcy5lcmQudW5pbnN0YWxsKHRoaXMuJHJlZnMuaXRlbSk7XG4gICAgfVxuICB9LFxuICBiZWZvcmVNb3VudDogZnVuY3Rpb24gYmVmb3JlTW91bnQoKSB7XG4gICAgdGhpcy4kZW1pdCgnbGF5b3V0LWJlZm9yZS1tb3VudCcsIHRoaXMubGF5b3V0KTtcbiAgfSxcbiAgbW91bnRlZDogZnVuY3Rpb24gbW91bnRlZCgpIHtcbiAgICB0aGlzLiRlbWl0KCdsYXlvdXQtbW91bnRlZCcsIHRoaXMubGF5b3V0KTtcbiAgICB0aGlzLiRuZXh0VGljayhmdW5jdGlvbiAoKSB7XG4gICAgICBPYmplY3QodXRpbHNbXCJsXCIgLyogdmFsaWRhdGVMYXlvdXQgKi9dKSh0aGlzLmxheW91dCk7XG4gICAgICB0aGlzLm9yaWdpbmFsTGF5b3V0ID0gdGhpcy5sYXlvdXQ7XG4gICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICB0aGlzLiRuZXh0VGljayhmdW5jdGlvbiAoKSB7XG4gICAgICAgIHNlbGYub25XaW5kb3dSZXNpemUoKTtcbiAgICAgICAgc2VsZi5pbml0UmVzcG9uc2l2ZUZlYXR1cmVzKCk7IC8vc2VsZi53aWR0aCA9IHNlbGYuJGVsLm9mZnNldFdpZHRoO1xuXG4gICAgICAgIE9iamVjdChET01bXCJhXCIgLyogYWRkV2luZG93RXZlbnRMaXN0ZW5lciAqL10pKCdyZXNpemUnLCBzZWxmLm9uV2luZG93UmVzaXplKTtcbiAgICAgICAgT2JqZWN0KHV0aWxzW1wiY1wiIC8qIGNvbXBhY3QgKi9dKShzZWxmLmxheW91dCwgc2VsZi52ZXJ0aWNhbENvbXBhY3QpO1xuICAgICAgICBzZWxmLiRlbWl0KCdsYXlvdXQtdXBkYXRlZCcsIHNlbGYubGF5b3V0KTtcbiAgICAgICAgc2VsZi51cGRhdGVIZWlnaHQoKTtcbiAgICAgICAgc2VsZi4kbmV4dFRpY2soZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHRoaXMuZXJkID0gZWxlbWVudFJlc2l6ZURldGVjdG9yTWFrZXIoe1xuICAgICAgICAgICAgc3RyYXRlZ3k6IFwic2Nyb2xsXCIsXG4gICAgICAgICAgICAvLzwtIEZvciB1bHRyYSBwZXJmb3JtYW5jZS5cbiAgICAgICAgICAgIC8vIFNlZSBodHRwczovL2dpdGh1Yi5jb20vd25yL2VsZW1lbnQtcmVzaXplLWRldGVjdG9yL2lzc3Vlcy8xMTAgYWJvdXQgY2FsbE9uQWRkLlxuICAgICAgICAgICAgY2FsbE9uQWRkOiBmYWxzZVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIHRoaXMuZXJkLmxpc3RlblRvKHNlbGYuJHJlZnMuaXRlbSwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgc2VsZi5vbldpbmRvd1Jlc2l6ZSgpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9LFxuICB3YXRjaDoge1xuICAgIHdpZHRoOiBmdW5jdGlvbiB3aWR0aChuZXd2YWwsIG9sZHZhbCkge1xuICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgdGhpcy4kbmV4dFRpY2soZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgICAgIC8vdGhpcy4kYnJvYWRjYXN0KFwidXBkYXRlV2lkdGhcIiwgdGhpcy53aWR0aCk7XG4gICAgICAgIHRoaXMuZXZlbnRCdXMuJGVtaXQoXCJ1cGRhdGVXaWR0aFwiLCB0aGlzLndpZHRoKTtcblxuICAgICAgICBpZiAob2xkdmFsID09PSBudWxsKSB7XG4gICAgICAgICAgLypcbiAgICAgICAgICAgICAgSWYgb2xkdmFsID09IG51bGwgaXMgd2hlbiB0aGUgd2lkdGggaGFzIG5ldmVyIGJlZW5cbiAgICAgICAgICAgICAgc2V0IGJlZm9yZS4gVGhhdCBvbmx5IG9jY3VycyB3aGVuIG1vdXRpbmcgaXNcbiAgICAgICAgICAgICAgZmluaXNoZWQsIGFuZCBvbldpbmRvd1Jlc2l6ZSBoYXMgYmVlbiBjYWxsZWQgYW5kXG4gICAgICAgICAgICAgIHRoaXMud2lkdGggaGFzIGJlZW4gY2hhbmdlZCB0aGUgZmlyc3QgdGltZSBhZnRlciBpdFxuICAgICAgICAgICAgICBnb3Qgc2V0IHRvIG51bGwgaW4gdGhlIGNvbnN0cnVjdG9yLiBJdCBpcyBub3cgdGltZVxuICAgICAgICAgICAgICB0byBpc3N1ZSBsYXlvdXQtcmVhZHkgZXZlbnRzIGFzIHRoZSBHcmlkSXRlbXMgaGF2ZVxuICAgICAgICAgICAgICB0aGVpciBzaXplcyBjb25maWd1cmVkIHByb3Blcmx5LlxuICAgICAgICAgICAgICAgVGhlIHJlYXNvbiBmb3IgZW1pdHRpbmcgdGhlIGxheW91dC1yZWFkeSBldmVudHMgb25cbiAgICAgICAgICAgICAgdGhlIG5leHQgdGljayBpcyB0byBhbGxvdyBmb3IgdGhlIG5ld2x5LWVtaXR0ZWRcbiAgICAgICAgICAgICAgdXBkYXRlV2lkdGggZXZlbnQgKGFib3ZlKSB0byBoYXZlIHJlYWNoZWQgdGhlXG4gICAgICAgICAgICAgIGNoaWxkcmVuIEdyaWRJdGVtLXMgYW5kIGhhZCB0aGVpciBlZmZlY3QsIHNvIHdlJ3JlXG4gICAgICAgICAgICAgIHN1cmUgdGhhdCB0aGV5IGhhdmUgdGhlIGZpbmFsIHNpemUgYmVmb3JlIHdlIGVtaXRcbiAgICAgICAgICAgICAgbGF5b3V0LXJlYWR5IChmb3IgdGhpcyBHcmlkTGF5b3V0KSBhbmRcbiAgICAgICAgICAgICAgaXRlbS1sYXlvdXQtcmVhZHkgKGZvciB0aGUgR3JpZEl0ZW0tcykuXG4gICAgICAgICAgICAgICBUaGlzIHdheSBhbnkgY2xpZW50IGV2ZW50IGhhbmRsZXJzIGNhbiByZWxpYWJseVxuICAgICAgICAgICAgICBpbnZpc3RpZ2F0ZSBzdGFibGUgc2l6ZXMgb2YgR3JpZEl0ZW0tcy5cbiAgICAgICAgICAqL1xuICAgICAgICAgIHRoaXMuJG5leHRUaWNrKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIF90aGlzLiRlbWl0KCdsYXlvdXQtcmVhZHknLCBzZWxmLmxheW91dCk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnVwZGF0ZUhlaWdodCgpO1xuICAgICAgfSk7XG4gICAgfSxcbiAgICBsYXlvdXQ6IGZ1bmN0aW9uIGxheW91dCgpIHtcbiAgICAgIHRoaXMubGF5b3V0VXBkYXRlKCk7XG4gICAgfSxcbiAgICBjb2xOdW06IGZ1bmN0aW9uIGNvbE51bSh2YWwpIHtcbiAgICAgIHRoaXMuZXZlbnRCdXMuJGVtaXQoXCJzZXRDb2xOdW1cIiwgdmFsKTtcbiAgICB9LFxuICAgIHJvd0hlaWdodDogZnVuY3Rpb24gcm93SGVpZ2h0KCkge1xuICAgICAgdGhpcy5ldmVudEJ1cy4kZW1pdChcInNldFJvd0hlaWdodFwiLCB0aGlzLnJvd0hlaWdodCk7XG4gICAgfSxcbiAgICBpc0RyYWdnYWJsZTogZnVuY3Rpb24gaXNEcmFnZ2FibGUoKSB7XG4gICAgICB0aGlzLmV2ZW50QnVzLiRlbWl0KFwic2V0RHJhZ2dhYmxlXCIsIHRoaXMuaXNEcmFnZ2FibGUpO1xuICAgIH0sXG4gICAgaXNSZXNpemFibGU6IGZ1bmN0aW9uIGlzUmVzaXphYmxlKCkge1xuICAgICAgdGhpcy5ldmVudEJ1cy4kZW1pdChcInNldFJlc2l6YWJsZVwiLCB0aGlzLmlzUmVzaXphYmxlKTtcbiAgICB9LFxuICAgIHJlc3BvbnNpdmU6IGZ1bmN0aW9uIHJlc3BvbnNpdmUoKSB7XG4gICAgICBpZiAoIXRoaXMucmVzcG9uc2l2ZSkge1xuICAgICAgICB0aGlzLiRlbWl0KCd1cGRhdGU6bGF5b3V0JywgdGhpcy5vcmlnaW5hbExheW91dCk7XG4gICAgICAgIHRoaXMuZXZlbnRCdXMuJGVtaXQoXCJzZXRDb2xOdW1cIiwgdGhpcy5jb2xOdW0pO1xuICAgICAgfVxuXG4gICAgICB0aGlzLm9uV2luZG93UmVzaXplKCk7XG4gICAgfSxcbiAgICBtYXhSb3dzOiBmdW5jdGlvbiBtYXhSb3dzKCkge1xuICAgICAgdGhpcy5ldmVudEJ1cy4kZW1pdChcInNldE1heFJvd3NcIiwgdGhpcy5tYXhSb3dzKTtcbiAgICB9LFxuICAgIG1hcmdpbjogZnVuY3Rpb24gbWFyZ2luKCkge1xuICAgICAgdGhpcy51cGRhdGVIZWlnaHQoKTtcbiAgICB9XG4gIH0sXG4gIG1ldGhvZHM6IHtcbiAgICBsYXlvdXRVcGRhdGU6IGZ1bmN0aW9uIGxheW91dFVwZGF0ZSgpIHtcbiAgICAgIGlmICh0aGlzLmxheW91dCAhPT0gdW5kZWZpbmVkICYmIHRoaXMub3JpZ2luYWxMYXlvdXQgIT09IG51bGwpIHtcbiAgICAgICAgaWYgKHRoaXMubGF5b3V0Lmxlbmd0aCAhPT0gdGhpcy5vcmlnaW5hbExheW91dC5sZW5ndGgpIHtcbiAgICAgICAgICAvLyBjb25zb2xlLmxvZyhcIiMjIyBMQVlPVVQgVVBEQVRFIVwiLCB0aGlzLmxheW91dC5sZW5ndGgsIHRoaXMub3JpZ2luYWxMYXlvdXQubGVuZ3RoKTtcbiAgICAgICAgICB2YXIgZGlmZiA9IHRoaXMuZmluZERpZmZlcmVuY2UodGhpcy5sYXlvdXQsIHRoaXMub3JpZ2luYWxMYXlvdXQpO1xuXG4gICAgICAgICAgaWYgKGRpZmYubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgLy8gY29uc29sZS5sb2coZGlmZik7XG4gICAgICAgICAgICBpZiAodGhpcy5sYXlvdXQubGVuZ3RoID4gdGhpcy5vcmlnaW5hbExheW91dC5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgdGhpcy5vcmlnaW5hbExheW91dCA9IHRoaXMub3JpZ2luYWxMYXlvdXQuY29uY2F0KGRpZmYpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgdGhpcy5vcmlnaW5hbExheW91dCA9IHRoaXMub3JpZ2luYWxMYXlvdXQuZmlsdGVyKGZ1bmN0aW9uIChvYmopIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gIWRpZmYuc29tZShmdW5jdGlvbiAob2JqMikge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIG9iai5pID09PSBvYmoyLmk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIHRoaXMubGFzdExheW91dExlbmd0aCA9IHRoaXMubGF5b3V0Lmxlbmd0aDtcbiAgICAgICAgICB0aGlzLmluaXRSZXNwb25zaXZlRmVhdHVyZXMoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIE9iamVjdCh1dGlsc1tcImNcIiAvKiBjb21wYWN0ICovXSkodGhpcy5sYXlvdXQsIHRoaXMudmVydGljYWxDb21wYWN0KTtcbiAgICAgICAgdGhpcy5ldmVudEJ1cy4kZW1pdChcInVwZGF0ZVdpZHRoXCIsIHRoaXMud2lkdGgpO1xuICAgICAgICB0aGlzLnVwZGF0ZUhlaWdodCgpO1xuICAgICAgICB0aGlzLiRlbWl0KCdsYXlvdXQtdXBkYXRlZCcsIHRoaXMubGF5b3V0KTtcbiAgICAgIH1cbiAgICB9LFxuICAgIHVwZGF0ZUhlaWdodDogZnVuY3Rpb24gdXBkYXRlSGVpZ2h0KCkge1xuICAgICAgdGhpcy5tZXJnZWRTdHlsZSA9IHtcbiAgICAgICAgaGVpZ2h0OiB0aGlzLmNvbnRhaW5lckhlaWdodCgpXG4gICAgICB9O1xuICAgIH0sXG4gICAgb25XaW5kb3dSZXNpemU6IGZ1bmN0aW9uIG9uV2luZG93UmVzaXplKCkge1xuICAgICAgaWYgKHRoaXMuJHJlZnMgIT09IG51bGwgJiYgdGhpcy4kcmVmcy5pdGVtICE9PSBudWxsICYmIHRoaXMuJHJlZnMuaXRlbSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRoaXMud2lkdGggPSB0aGlzLiRyZWZzLml0ZW0ub2Zmc2V0V2lkdGg7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuZXZlbnRCdXMuJGVtaXQoXCJyZXNpemVFdmVudFwiKTtcbiAgICB9LFxuICAgIGNvbnRhaW5lckhlaWdodDogZnVuY3Rpb24gY29udGFpbmVySGVpZ2h0KCkge1xuICAgICAgaWYgKCF0aGlzLmF1dG9TaXplKSByZXR1cm47IC8vIGNvbnNvbGUubG9nKFwiYm90dG9tOiBcIiArIGJvdHRvbSh0aGlzLmxheW91dCkpXG4gICAgICAvLyBjb25zb2xlLmxvZyhcInJvd0hlaWdodCArIG1hcmdpbnM6IFwiICsgKHRoaXMucm93SGVpZ2h0ICsgdGhpcy5tYXJnaW5bMV0pICsgdGhpcy5tYXJnaW5bMV0pXG5cbiAgICAgIHZhciBjb250YWluZXJIZWlnaHQgPSBPYmplY3QodXRpbHNbXCJhXCIgLyogYm90dG9tICovXSkodGhpcy5sYXlvdXQpICogKHRoaXMucm93SGVpZ2h0ICsgdGhpcy5tYXJnaW5bMV0pICsgdGhpcy5tYXJnaW5bMV0gKyAncHgnO1xuICAgICAgcmV0dXJuIGNvbnRhaW5lckhlaWdodDtcbiAgICB9LFxuICAgIGRyYWdFdmVudDogZnVuY3Rpb24gZHJhZ0V2ZW50KGV2ZW50TmFtZSwgaWQsIHgsIHksIGgsIHcpIHtcbiAgICAgIC8vY29uc29sZS5sb2coZXZlbnROYW1lICsgXCIgaWQ9XCIgKyBpZCArIFwiLCB4PVwiICsgeCArIFwiLCB5PVwiICsgeSk7XG4gICAgICB2YXIgbCA9IE9iamVjdCh1dGlsc1tcImZcIiAvKiBnZXRMYXlvdXRJdGVtICovXSkodGhpcy5sYXlvdXQsIGlkKTsgLy9HZXRMYXlvdXRJdGVtIHNvbWV0aW1lcyByZXR1cm5zIG51bGwgb2JqZWN0XG5cbiAgICAgIGlmIChsID09PSB1bmRlZmluZWQgfHwgbCA9PT0gbnVsbCkge1xuICAgICAgICBsID0ge1xuICAgICAgICAgIHg6IDAsXG4gICAgICAgICAgeTogMFxuICAgICAgICB9O1xuICAgICAgfVxuXG4gICAgICBpZiAoZXZlbnROYW1lID09PSBcImRyYWdtb3ZlXCIgfHwgZXZlbnROYW1lID09PSBcImRyYWdzdGFydFwiKSB7XG4gICAgICAgIHRoaXMucGxhY2Vob2xkZXIuaSA9IGlkO1xuICAgICAgICB0aGlzLnBsYWNlaG9sZGVyLnggPSBsLng7XG4gICAgICAgIHRoaXMucGxhY2Vob2xkZXIueSA9IGwueTtcbiAgICAgICAgdGhpcy5wbGFjZWhvbGRlci53ID0gdztcbiAgICAgICAgdGhpcy5wbGFjZWhvbGRlci5oID0gaDtcbiAgICAgICAgdGhpcy4kbmV4dFRpY2soZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHRoaXMuaXNEcmFnZ2luZyA9IHRydWU7XG4gICAgICAgIH0pOyAvL3RoaXMuJGJyb2FkY2FzdChcInVwZGF0ZVdpZHRoXCIsIHRoaXMud2lkdGgpO1xuXG4gICAgICAgIHRoaXMuZXZlbnRCdXMuJGVtaXQoXCJ1cGRhdGVXaWR0aFwiLCB0aGlzLndpZHRoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuJG5leHRUaWNrKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICB0aGlzLmlzRHJhZ2dpbmcgPSBmYWxzZTtcbiAgICAgICAgfSk7XG4gICAgICB9IC8vIE1vdmUgdGhlIGVsZW1lbnQgdG8gdGhlIGRyYWdnZWQgbG9jYXRpb24uXG5cblxuICAgICAgdGhpcy5sYXlvdXQgPSBPYmplY3QodXRpbHNbXCJnXCIgLyogbW92ZUVsZW1lbnQgKi9dKSh0aGlzLmxheW91dCwgbCwgeCwgeSwgdHJ1ZSwgdGhpcy5wcmV2ZW50Q29sbGlzaW9uKTtcbiAgICAgIE9iamVjdCh1dGlsc1tcImNcIiAvKiBjb21wYWN0ICovXSkodGhpcy5sYXlvdXQsIHRoaXMudmVydGljYWxDb21wYWN0KTsgLy8gbmVlZGVkIGJlY2F1c2UgdnVlIGNhbid0IGRldGVjdCBjaGFuZ2VzIG9uIGFycmF5IGVsZW1lbnQgcHJvcGVydGllc1xuXG4gICAgICB0aGlzLmV2ZW50QnVzLiRlbWl0KFwiY29tcGFjdFwiKTtcbiAgICAgIHRoaXMudXBkYXRlSGVpZ2h0KCk7XG4gICAgICBpZiAoZXZlbnROYW1lID09PSAnZHJhZ2VuZCcpIHRoaXMuJGVtaXQoJ2xheW91dC11cGRhdGVkJywgdGhpcy5sYXlvdXQpO1xuICAgIH0sXG4gICAgcmVzaXplRXZlbnQ6IGZ1bmN0aW9uIHJlc2l6ZUV2ZW50KGV2ZW50TmFtZSwgaWQsIHgsIHksIGgsIHcpIHtcbiAgICAgIHZhciBsID0gT2JqZWN0KHV0aWxzW1wiZlwiIC8qIGdldExheW91dEl0ZW0gKi9dKSh0aGlzLmxheW91dCwgaWQpOyAvL0dldExheW91dEl0ZW0gc29tZXRpbWVzIHJldHVybiBudWxsIG9iamVjdFxuXG4gICAgICBpZiAobCA9PT0gdW5kZWZpbmVkIHx8IGwgPT09IG51bGwpIHtcbiAgICAgICAgbCA9IHtcbiAgICAgICAgICBoOiAwLFxuICAgICAgICAgIHc6IDBcbiAgICAgICAgfTtcbiAgICAgIH1cblxuICAgICAgdmFyIGhhc0NvbGxpc2lvbnM7XG5cbiAgICAgIGlmICh0aGlzLnByZXZlbnRDb2xsaXNpb24pIHtcbiAgICAgICAgdmFyIGNvbGxpc2lvbnMgPSBPYmplY3QodXRpbHNbXCJlXCIgLyogZ2V0QWxsQ29sbGlzaW9ucyAqL10pKHRoaXMubGF5b3V0LCBfb2JqZWN0U3ByZWFkKF9vYmplY3RTcHJlYWQoe30sIGwpLCB7fSwge1xuICAgICAgICAgIHc6IHcsXG4gICAgICAgICAgaDogaFxuICAgICAgICB9KSkuZmlsdGVyKGZ1bmN0aW9uIChsYXlvdXRJdGVtKSB7XG4gICAgICAgICAgcmV0dXJuIGxheW91dEl0ZW0uaSAhPT0gbC5pO1xuICAgICAgICB9KTtcbiAgICAgICAgaGFzQ29sbGlzaW9ucyA9IGNvbGxpc2lvbnMubGVuZ3RoID4gMDsgLy8gSWYgd2UncmUgY29sbGlkaW5nLCB3ZSBuZWVkIGFkanVzdCB0aGUgcGxhY2Vob2xkZXIuXG5cbiAgICAgICAgaWYgKGhhc0NvbGxpc2lvbnMpIHtcbiAgICAgICAgICAvLyBhZGp1c3QgdyAmJiBoIHRvIG1heGltdW0gYWxsb3dlZCBzcGFjZVxuICAgICAgICAgIHZhciBsZWFzdFggPSBJbmZpbml0eSxcbiAgICAgICAgICAgICAgbGVhc3RZID0gSW5maW5pdHk7XG4gICAgICAgICAgY29sbGlzaW9ucy5mb3JFYWNoKGZ1bmN0aW9uIChsYXlvdXRJdGVtKSB7XG4gICAgICAgICAgICBpZiAobGF5b3V0SXRlbS54ID4gbC54KSBsZWFzdFggPSBNYXRoLm1pbihsZWFzdFgsIGxheW91dEl0ZW0ueCk7XG4gICAgICAgICAgICBpZiAobGF5b3V0SXRlbS55ID4gbC55KSBsZWFzdFkgPSBNYXRoLm1pbihsZWFzdFksIGxheW91dEl0ZW0ueSk7XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgaWYgKE51bWJlci5pc0Zpbml0ZShsZWFzdFgpKSBsLncgPSBsZWFzdFggLSBsLng7XG4gICAgICAgICAgaWYgKE51bWJlci5pc0Zpbml0ZShsZWFzdFkpKSBsLmggPSBsZWFzdFkgLSBsLnk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKCFoYXNDb2xsaXNpb25zKSB7XG4gICAgICAgIC8vIFNldCBuZXcgd2lkdGggYW5kIGhlaWdodC5cbiAgICAgICAgbC53ID0gdztcbiAgICAgICAgbC5oID0gaDtcbiAgICAgIH1cblxuICAgICAgaWYgKGV2ZW50TmFtZSA9PT0gXCJyZXNpemVzdGFydFwiIHx8IGV2ZW50TmFtZSA9PT0gXCJyZXNpemVtb3ZlXCIpIHtcbiAgICAgICAgdGhpcy5wbGFjZWhvbGRlci5pID0gaWQ7XG4gICAgICAgIHRoaXMucGxhY2Vob2xkZXIueCA9IHg7XG4gICAgICAgIHRoaXMucGxhY2Vob2xkZXIueSA9IHk7XG4gICAgICAgIHRoaXMucGxhY2Vob2xkZXIudyA9IGwudztcbiAgICAgICAgdGhpcy5wbGFjZWhvbGRlci5oID0gbC5oO1xuICAgICAgICB0aGlzLiRuZXh0VGljayhmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgdGhpcy5pc0RyYWdnaW5nID0gdHJ1ZTtcbiAgICAgICAgfSk7IC8vdGhpcy4kYnJvYWRjYXN0KFwidXBkYXRlV2lkdGhcIiwgdGhpcy53aWR0aCk7XG5cbiAgICAgICAgdGhpcy5ldmVudEJ1cy4kZW1pdChcInVwZGF0ZVdpZHRoXCIsIHRoaXMud2lkdGgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy4kbmV4dFRpY2soZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHRoaXMuaXNEcmFnZ2luZyA9IGZhbHNlO1xuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMucmVzcG9uc2l2ZSkgdGhpcy5yZXNwb25zaXZlR3JpZExheW91dCgpO1xuICAgICAgT2JqZWN0KHV0aWxzW1wiY1wiIC8qIGNvbXBhY3QgKi9dKSh0aGlzLmxheW91dCwgdGhpcy52ZXJ0aWNhbENvbXBhY3QpO1xuICAgICAgdGhpcy5ldmVudEJ1cy4kZW1pdChcImNvbXBhY3RcIik7XG4gICAgICB0aGlzLnVwZGF0ZUhlaWdodCgpO1xuICAgICAgaWYgKGV2ZW50TmFtZSA9PT0gJ3Jlc2l6ZWVuZCcpIHRoaXMuJGVtaXQoJ2xheW91dC11cGRhdGVkJywgdGhpcy5sYXlvdXQpO1xuICAgIH0sXG4gICAgLy8gZmluZHMgb3IgZ2VuZXJhdGVzIG5ldyBsYXlvdXRzIGZvciBzZXQgYnJlYWtwb2ludHNcbiAgICByZXNwb25zaXZlR3JpZExheW91dDogZnVuY3Rpb24gcmVzcG9uc2l2ZUdyaWRMYXlvdXQoKSB7XG4gICAgICB2YXIgbmV3QnJlYWtwb2ludCA9IE9iamVjdChyZXNwb25zaXZlVXRpbHNbXCJiXCIgLyogZ2V0QnJlYWtwb2ludEZyb21XaWR0aCAqL10pKHRoaXMuYnJlYWtwb2ludHMsIHRoaXMud2lkdGgpO1xuICAgICAgdmFyIG5ld0NvbHMgPSBPYmplY3QocmVzcG9uc2l2ZVV0aWxzW1wiY1wiIC8qIGdldENvbHNGcm9tQnJlYWtwb2ludCAqL10pKG5ld0JyZWFrcG9pbnQsIHRoaXMuY29scyk7IC8vIHNhdmUgYWN0dWFsIGxheW91dCBpbiBsYXlvdXRzXG5cbiAgICAgIGlmICh0aGlzLmxhc3RCcmVha3BvaW50ICE9IG51bGwgJiYgIXRoaXMubGF5b3V0c1t0aGlzLmxhc3RCcmVha3BvaW50XSkgdGhpcy5sYXlvdXRzW3RoaXMubGFzdEJyZWFrcG9pbnRdID0gT2JqZWN0KHV0aWxzW1wiYlwiIC8qIGNsb25lTGF5b3V0ICovXSkodGhpcy5sYXlvdXQpOyAvLyBGaW5kIG9yIGdlbmVyYXRlIGEgbmV3IGxheW91dC5cblxuICAgICAgdmFyIGxheW91dCA9IE9iamVjdChyZXNwb25zaXZlVXRpbHNbXCJhXCIgLyogZmluZE9yR2VuZXJhdGVSZXNwb25zaXZlTGF5b3V0ICovXSkodGhpcy5vcmlnaW5hbExheW91dCwgdGhpcy5sYXlvdXRzLCB0aGlzLmJyZWFrcG9pbnRzLCBuZXdCcmVha3BvaW50LCB0aGlzLmxhc3RCcmVha3BvaW50LCBuZXdDb2xzLCB0aGlzLnZlcnRpY2FsQ29tcGFjdCk7IC8vIFN0b3JlIHRoZSBuZXcgbGF5b3V0LlxuXG4gICAgICB0aGlzLmxheW91dHNbbmV3QnJlYWtwb2ludF0gPSBsYXlvdXQ7XG5cbiAgICAgIGlmICh0aGlzLmxhc3RCcmVha3BvaW50ICE9PSBuZXdCcmVha3BvaW50KSB7XG4gICAgICAgIHRoaXMuJGVtaXQoJ2JyZWFrcG9pbnQtY2hhbmdlZCcsIG5ld0JyZWFrcG9pbnQsIGxheW91dCk7XG4gICAgICB9IC8vIG5ldyBwcm9wIHN5bmNcblxuXG4gICAgICB0aGlzLiRlbWl0KCd1cGRhdGU6bGF5b3V0JywgbGF5b3V0KTtcbiAgICAgIHRoaXMubGFzdEJyZWFrcG9pbnQgPSBuZXdCcmVha3BvaW50O1xuICAgICAgdGhpcy5ldmVudEJ1cy4kZW1pdChcInNldENvbE51bVwiLCBPYmplY3QocmVzcG9uc2l2ZVV0aWxzW1wiY1wiIC8qIGdldENvbHNGcm9tQnJlYWtwb2ludCAqL10pKG5ld0JyZWFrcG9pbnQsIHRoaXMuY29scykpO1xuICAgIH0sXG4gICAgLy8gY2xlYXIgYWxsIHJlc3BvbnNpdmUgbGF5b3V0c1xuICAgIGluaXRSZXNwb25zaXZlRmVhdHVyZXM6IGZ1bmN0aW9uIGluaXRSZXNwb25zaXZlRmVhdHVyZXMoKSB7XG4gICAgICAvLyBjbGVhciBsYXlvdXRzXG4gICAgICB0aGlzLmxheW91dHMgPSBPYmplY3QuYXNzaWduKHt9LCB0aGlzLnJlc3BvbnNpdmVMYXlvdXRzKTtcbiAgICB9LFxuICAgIC8vIGZpbmQgZGlmZmVyZW5jZSBpbiBsYXlvdXRzXG4gICAgZmluZERpZmZlcmVuY2U6IGZ1bmN0aW9uIGZpbmREaWZmZXJlbmNlKGxheW91dCwgb3JpZ2luYWxMYXlvdXQpIHtcbiAgICAgIC8vRmluZCB2YWx1ZXMgdGhhdCBhcmUgaW4gcmVzdWx0MSBidXQgbm90IGluIHJlc3VsdDJcbiAgICAgIHZhciB1bmlxdWVSZXN1bHRPbmUgPSBsYXlvdXQuZmlsdGVyKGZ1bmN0aW9uIChvYmopIHtcbiAgICAgICAgcmV0dXJuICFvcmlnaW5hbExheW91dC5zb21lKGZ1bmN0aW9uIChvYmoyKSB7XG4gICAgICAgICAgcmV0dXJuIG9iai5pID09PSBvYmoyLmk7XG4gICAgICAgIH0pO1xuICAgICAgfSk7IC8vRmluZCB2YWx1ZXMgdGhhdCBhcmUgaW4gcmVzdWx0MiBidXQgbm90IGluIHJlc3VsdDFcblxuICAgICAgdmFyIHVuaXF1ZVJlc3VsdFR3byA9IG9yaWdpbmFsTGF5b3V0LmZpbHRlcihmdW5jdGlvbiAob2JqKSB7XG4gICAgICAgIHJldHVybiAhbGF5b3V0LnNvbWUoZnVuY3Rpb24gKG9iajIpIHtcbiAgICAgICAgICByZXR1cm4gb2JqLmkgPT09IG9iajIuaTtcbiAgICAgICAgfSk7XG4gICAgICB9KTsgLy9Db21iaW5lIHRoZSB0d28gYXJyYXlzIG9mIHVuaXF1ZSBlbnRyaWVzI1xuXG4gICAgICByZXR1cm4gdW5pcXVlUmVzdWx0T25lLmNvbmNhdCh1bmlxdWVSZXN1bHRUd28pO1xuICAgIH1cbiAgfVxufSk7XG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9jb21wb25lbnRzL0dyaWRMYXlvdXQudnVlP3Z1ZSZ0eXBlPXNjcmlwdCZsYW5nPWpzJlxuIC8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gdmFyIGNvbXBvbmVudHNfR3JpZExheW91dHZ1ZV90eXBlX3NjcmlwdF9sYW5nX2pzXyA9IChHcmlkTGF5b3V0dnVlX3R5cGVfc2NyaXB0X2xhbmdfanNfKTsgXG4vLyBFWFRFUk5BTCBNT0RVTEU6IC4vc3JjL2NvbXBvbmVudHMvR3JpZExheW91dC52dWU/dnVlJnR5cGU9c3R5bGUmaW5kZXg9MCZsYW5nPWNzcyZcbnZhciBHcmlkTGF5b3V0dnVlX3R5cGVfc3R5bGVfaW5kZXhfMF9sYW5nX2Nzc18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiZTI3OVwiKTtcblxuLy8gRVhURVJOQUwgTU9EVUxFOiAuL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9ydW50aW1lL2NvbXBvbmVudE5vcm1hbGl6ZXIuanNcbnZhciBjb21wb25lbnROb3JtYWxpemVyID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIjI4NzdcIik7XG5cbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL2NvbXBvbmVudHMvR3JpZExheW91dC52dWVcblxuXG5cblxuXG5cbi8qIG5vcm1hbGl6ZSBjb21wb25lbnQgKi9cblxudmFyIGNvbXBvbmVudCA9IE9iamVjdChjb21wb25lbnROb3JtYWxpemVyW1wiYVwiIC8qIGRlZmF1bHQgKi9dKShcbiAgY29tcG9uZW50c19HcmlkTGF5b3V0dnVlX3R5cGVfc2NyaXB0X2xhbmdfanNfLFxuICByZW5kZXIsXG4gIHN0YXRpY1JlbmRlckZucyxcbiAgZmFsc2UsXG4gIG51bGwsXG4gIG51bGwsXG4gIG51bGxcbiAgXG4pXG5cbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gdmFyIEdyaWRMYXlvdXQgPSBfX3dlYnBhY2tfZXhwb3J0c19fW1wiYVwiXSA9IChjb21wb25lbnQuZXhwb3J0cyk7XG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIjM4ZmRcIjpcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuLy8gMTkuMS4yLjkgLyAxNS4yLjMuMiBPYmplY3QuZ2V0UHJvdG90eXBlT2YoTylcbnZhciBoYXMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiNjlhOFwiKTtcbnZhciB0b09iamVjdCA9IF9fd2VicGFja19yZXF1aXJlX18oXCI0YmY4XCIpO1xudmFyIElFX1BST1RPID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIjYxM2JcIikoJ0lFX1BST1RPJyk7XG52YXIgT2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuXG5tb2R1bGUuZXhwb3J0cyA9IE9iamVjdC5nZXRQcm90b3R5cGVPZiB8fCBmdW5jdGlvbiAoTykge1xuICBPID0gdG9PYmplY3QoTyk7XG4gIGlmIChoYXMoTywgSUVfUFJPVE8pKSByZXR1cm4gT1tJRV9QUk9UT107XG4gIGlmICh0eXBlb2YgTy5jb25zdHJ1Y3RvciA9PSAnZnVuY3Rpb24nICYmIE8gaW5zdGFuY2VvZiBPLmNvbnN0cnVjdG9yKSB7XG4gICAgcmV0dXJuIE8uY29uc3RydWN0b3IucHJvdG90eXBlO1xuICB9IHJldHVybiBPIGluc3RhbmNlb2YgT2JqZWN0ID8gT2JqZWN0UHJvdG8gOiBudWxsO1xufTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCI0MWEwXCI6XG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG52YXIgY3JlYXRlID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIjJhZWJcIik7XG52YXIgZGVzY3JpcHRvciA9IF9fd2VicGFja19yZXF1aXJlX18oXCI0NjMwXCIpO1xudmFyIHNldFRvU3RyaW5nVGFnID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIjdmMjBcIik7XG52YXIgSXRlcmF0b3JQcm90b3R5cGUgPSB7fTtcblxuLy8gMjUuMS4yLjEuMSAlSXRlcmF0b3JQcm90b3R5cGUlW0BAaXRlcmF0b3JdKClcbl9fd2VicGFja19yZXF1aXJlX18oXCIzMmU5XCIpKEl0ZXJhdG9yUHJvdG90eXBlLCBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiMmI0Y1wiKSgnaXRlcmF0b3InKSwgZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpczsgfSk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKENvbnN0cnVjdG9yLCBOQU1FLCBuZXh0KSB7XG4gIENvbnN0cnVjdG9yLnByb3RvdHlwZSA9IGNyZWF0ZShJdGVyYXRvclByb3RvdHlwZSwgeyBuZXh0OiBkZXNjcmlwdG9yKDEsIG5leHQpIH0pO1xuICBzZXRUb1N0cmluZ1RhZyhDb25zdHJ1Y3RvciwgTkFNRSArICcgSXRlcmF0b3InKTtcbn07XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiNDU2ZFwiOlxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG4vLyAxOS4xLjIuMTQgT2JqZWN0LmtleXMoTylcbnZhciB0b09iamVjdCA9IF9fd2VicGFja19yZXF1aXJlX18oXCI0YmY4XCIpO1xudmFyICRrZXlzID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIjBkNThcIik7XG5cbl9fd2VicGFja19yZXF1aXJlX18oXCI1ZWRhXCIpKCdrZXlzJywgZnVuY3Rpb24gKCkge1xuICByZXR1cm4gZnVuY3Rpb24ga2V5cyhpdCkge1xuICAgIHJldHVybiAka2V5cyh0b09iamVjdChpdCkpO1xuICB9O1xufSk7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiNDU4OFwiOlxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG4vLyA3LjEuNCBUb0ludGVnZXJcbnZhciBjZWlsID0gTWF0aC5jZWlsO1xudmFyIGZsb29yID0gTWF0aC5mbG9vcjtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0KSB7XG4gIHJldHVybiBpc05hTihpdCA9ICtpdCkgPyAwIDogKGl0ID4gMCA/IGZsb29yIDogY2VpbCkoaXQpO1xufTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCI0NjMwXCI6XG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGJpdG1hcCwgdmFsdWUpIHtcbiAgcmV0dXJuIHtcbiAgICBlbnVtZXJhYmxlOiAhKGJpdG1hcCAmIDEpLFxuICAgIGNvbmZpZ3VyYWJsZTogIShiaXRtYXAgJiAyKSxcbiAgICB3cml0YWJsZTogIShiaXRtYXAgJiA0KSxcbiAgICB2YWx1ZTogdmFsdWVcbiAgfTtcbn07XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiNDkxN1wiOlxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG52YXIgYW5PYmplY3QgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiY2I3Y1wiKTtcbnZhciB0b0xlbmd0aCA9IF9fd2VicGFja19yZXF1aXJlX18oXCI5ZGVmXCIpO1xudmFyIGFkdmFuY2VTdHJpbmdJbmRleCA9IF9fd2VicGFja19yZXF1aXJlX18oXCIwMzkwXCIpO1xudmFyIHJlZ0V4cEV4ZWMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiNWYxYlwiKTtcblxuLy8gQEBtYXRjaCBsb2dpY1xuX193ZWJwYWNrX3JlcXVpcmVfXyhcIjIxNGZcIikoJ21hdGNoJywgMSwgZnVuY3Rpb24gKGRlZmluZWQsIE1BVENILCAkbWF0Y2gsIG1heWJlQ2FsbE5hdGl2ZSkge1xuICByZXR1cm4gW1xuICAgIC8vIGBTdHJpbmcucHJvdG90eXBlLm1hdGNoYCBtZXRob2RcbiAgICAvLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1zdHJpbmcucHJvdG90eXBlLm1hdGNoXG4gICAgZnVuY3Rpb24gbWF0Y2gocmVnZXhwKSB7XG4gICAgICB2YXIgTyA9IGRlZmluZWQodGhpcyk7XG4gICAgICB2YXIgZm4gPSByZWdleHAgPT0gdW5kZWZpbmVkID8gdW5kZWZpbmVkIDogcmVnZXhwW01BVENIXTtcbiAgICAgIHJldHVybiBmbiAhPT0gdW5kZWZpbmVkID8gZm4uY2FsbChyZWdleHAsIE8pIDogbmV3IFJlZ0V4cChyZWdleHApW01BVENIXShTdHJpbmcoTykpO1xuICAgIH0sXG4gICAgLy8gYFJlZ0V4cC5wcm90b3R5cGVbQEBtYXRjaF1gIG1ldGhvZFxuICAgIC8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLXJlZ2V4cC5wcm90b3R5cGUtQEBtYXRjaFxuICAgIGZ1bmN0aW9uIChyZWdleHApIHtcbiAgICAgIHZhciByZXMgPSBtYXliZUNhbGxOYXRpdmUoJG1hdGNoLCByZWdleHAsIHRoaXMpO1xuICAgICAgaWYgKHJlcy5kb25lKSByZXR1cm4gcmVzLnZhbHVlO1xuICAgICAgdmFyIHJ4ID0gYW5PYmplY3QocmVnZXhwKTtcbiAgICAgIHZhciBTID0gU3RyaW5nKHRoaXMpO1xuICAgICAgaWYgKCFyeC5nbG9iYWwpIHJldHVybiByZWdFeHBFeGVjKHJ4LCBTKTtcbiAgICAgIHZhciBmdWxsVW5pY29kZSA9IHJ4LnVuaWNvZGU7XG4gICAgICByeC5sYXN0SW5kZXggPSAwO1xuICAgICAgdmFyIEEgPSBbXTtcbiAgICAgIHZhciBuID0gMDtcbiAgICAgIHZhciByZXN1bHQ7XG4gICAgICB3aGlsZSAoKHJlc3VsdCA9IHJlZ0V4cEV4ZWMocngsIFMpKSAhPT0gbnVsbCkge1xuICAgICAgICB2YXIgbWF0Y2hTdHIgPSBTdHJpbmcocmVzdWx0WzBdKTtcbiAgICAgICAgQVtuXSA9IG1hdGNoU3RyO1xuICAgICAgICBpZiAobWF0Y2hTdHIgPT09ICcnKSByeC5sYXN0SW5kZXggPSBhZHZhbmNlU3RyaW5nSW5kZXgoUywgdG9MZW5ndGgocngubGFzdEluZGV4KSwgZnVsbFVuaWNvZGUpO1xuICAgICAgICBuKys7XG4gICAgICB9XG4gICAgICByZXR1cm4gbiA9PT0gMCA/IG51bGwgOiBBO1xuICAgIH1cbiAgXTtcbn0pO1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIjQ5OWVcIjpcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG4vLyBFU00gQ09NUEFUIEZMQUdcbl9fd2VicGFja19yZXF1aXJlX18ucihfX3dlYnBhY2tfZXhwb3J0c19fKTtcblxuLy8gRVhQT1JUU1xuX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwiZGVmYXVsdFwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIC8qIGJpbmRpbmcgKi8gYWRkU3R5bGVzQ2xpZW50OyB9KTtcblxuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9ub2RlX21vZHVsZXMvdnVlLXN0eWxlLWxvYWRlci9saWIvbGlzdFRvU3R5bGVzLmpzXG4vKipcbiAqIFRyYW5zbGF0ZXMgdGhlIGxpc3QgZm9ybWF0IHByb2R1Y2VkIGJ5IGNzcy1sb2FkZXIgaW50byBzb21ldGhpbmdcbiAqIGVhc2llciB0byBtYW5pcHVsYXRlLlxuICovXG5mdW5jdGlvbiBsaXN0VG9TdHlsZXMgKHBhcmVudElkLCBsaXN0KSB7XG4gIHZhciBzdHlsZXMgPSBbXVxuICB2YXIgbmV3U3R5bGVzID0ge31cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGl0ZW0gPSBsaXN0W2ldXG4gICAgdmFyIGlkID0gaXRlbVswXVxuICAgIHZhciBjc3MgPSBpdGVtWzFdXG4gICAgdmFyIG1lZGlhID0gaXRlbVsyXVxuICAgIHZhciBzb3VyY2VNYXAgPSBpdGVtWzNdXG4gICAgdmFyIHBhcnQgPSB7XG4gICAgICBpZDogcGFyZW50SWQgKyAnOicgKyBpLFxuICAgICAgY3NzOiBjc3MsXG4gICAgICBtZWRpYTogbWVkaWEsXG4gICAgICBzb3VyY2VNYXA6IHNvdXJjZU1hcFxuICAgIH1cbiAgICBpZiAoIW5ld1N0eWxlc1tpZF0pIHtcbiAgICAgIHN0eWxlcy5wdXNoKG5ld1N0eWxlc1tpZF0gPSB7IGlkOiBpZCwgcGFydHM6IFtwYXJ0XSB9KVxuICAgIH0gZWxzZSB7XG4gICAgICBuZXdTdHlsZXNbaWRdLnBhcnRzLnB1c2gocGFydClcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHN0eWxlc1xufVxuXG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL25vZGVfbW9kdWxlcy92dWUtc3R5bGUtbG9hZGVyL2xpYi9hZGRTdHlsZXNDbGllbnQuanNcbi8qXG4gIE1JVCBMaWNlbnNlIGh0dHA6Ly93d3cub3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvbWl0LWxpY2Vuc2UucGhwXG4gIEF1dGhvciBUb2JpYXMgS29wcGVycyBAc29rcmFcbiAgTW9kaWZpZWQgYnkgRXZhbiBZb3UgQHl5eDk5MDgwM1xuKi9cblxuXG5cbnZhciBoYXNEb2N1bWVudCA9IHR5cGVvZiBkb2N1bWVudCAhPT0gJ3VuZGVmaW5lZCdcblxuaWYgKHR5cGVvZiBERUJVRyAhPT0gJ3VuZGVmaW5lZCcgJiYgREVCVUcpIHtcbiAgaWYgKCFoYXNEb2N1bWVudCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAndnVlLXN0eWxlLWxvYWRlciBjYW5ub3QgYmUgdXNlZCBpbiBhIG5vbi1icm93c2VyIGVudmlyb25tZW50LiAnICtcbiAgICBcIlVzZSB7IHRhcmdldDogJ25vZGUnIH0gaW4geW91ciBXZWJwYWNrIGNvbmZpZyB0byBpbmRpY2F0ZSBhIHNlcnZlci1yZW5kZXJpbmcgZW52aXJvbm1lbnQuXCJcbiAgKSB9XG59XG5cbi8qXG50eXBlIFN0eWxlT2JqZWN0ID0ge1xuICBpZDogbnVtYmVyO1xuICBwYXJ0czogQXJyYXk8U3R5bGVPYmplY3RQYXJ0PlxufVxuXG50eXBlIFN0eWxlT2JqZWN0UGFydCA9IHtcbiAgY3NzOiBzdHJpbmc7XG4gIG1lZGlhOiBzdHJpbmc7XG4gIHNvdXJjZU1hcDogP3N0cmluZ1xufVxuKi9cblxudmFyIHN0eWxlc0luRG9tID0gey8qXG4gIFtpZDogbnVtYmVyXToge1xuICAgIGlkOiBudW1iZXIsXG4gICAgcmVmczogbnVtYmVyLFxuICAgIHBhcnRzOiBBcnJheTwob2JqPzogU3R5bGVPYmplY3RQYXJ0KSA9PiB2b2lkPlxuICB9XG4qL31cblxudmFyIGhlYWQgPSBoYXNEb2N1bWVudCAmJiAoZG9jdW1lbnQuaGVhZCB8fCBkb2N1bWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZSgnaGVhZCcpWzBdKVxudmFyIHNpbmdsZXRvbkVsZW1lbnQgPSBudWxsXG52YXIgc2luZ2xldG9uQ291bnRlciA9IDBcbnZhciBpc1Byb2R1Y3Rpb24gPSBmYWxzZVxudmFyIG5vb3AgPSBmdW5jdGlvbiAoKSB7fVxudmFyIG9wdGlvbnMgPSBudWxsXG52YXIgc3NySWRLZXkgPSAnZGF0YS12dWUtc3NyLWlkJ1xuXG4vLyBGb3JjZSBzaW5nbGUtdGFnIHNvbHV0aW9uIG9uIElFNi05LCB3aGljaCBoYXMgYSBoYXJkIGxpbWl0IG9uIHRoZSAjIG9mIDxzdHlsZT5cbi8vIHRhZ3MgaXQgd2lsbCBhbGxvdyBvbiBhIHBhZ2VcbnZhciBpc09sZElFID0gdHlwZW9mIG5hdmlnYXRvciAhPT0gJ3VuZGVmaW5lZCcgJiYgL21zaWUgWzYtOV1cXGIvLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudC50b0xvd2VyQ2FzZSgpKVxuXG5mdW5jdGlvbiBhZGRTdHlsZXNDbGllbnQgKHBhcmVudElkLCBsaXN0LCBfaXNQcm9kdWN0aW9uLCBfb3B0aW9ucykge1xuICBpc1Byb2R1Y3Rpb24gPSBfaXNQcm9kdWN0aW9uXG5cbiAgb3B0aW9ucyA9IF9vcHRpb25zIHx8IHt9XG5cbiAgdmFyIHN0eWxlcyA9IGxpc3RUb1N0eWxlcyhwYXJlbnRJZCwgbGlzdClcbiAgYWRkU3R5bGVzVG9Eb20oc3R5bGVzKVxuXG4gIHJldHVybiBmdW5jdGlvbiB1cGRhdGUgKG5ld0xpc3QpIHtcbiAgICB2YXIgbWF5UmVtb3ZlID0gW11cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHN0eWxlcy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGl0ZW0gPSBzdHlsZXNbaV1cbiAgICAgIHZhciBkb21TdHlsZSA9IHN0eWxlc0luRG9tW2l0ZW0uaWRdXG4gICAgICBkb21TdHlsZS5yZWZzLS1cbiAgICAgIG1heVJlbW92ZS5wdXNoKGRvbVN0eWxlKVxuICAgIH1cbiAgICBpZiAobmV3TGlzdCkge1xuICAgICAgc3R5bGVzID0gbGlzdFRvU3R5bGVzKHBhcmVudElkLCBuZXdMaXN0KVxuICAgICAgYWRkU3R5bGVzVG9Eb20oc3R5bGVzKVxuICAgIH0gZWxzZSB7XG4gICAgICBzdHlsZXMgPSBbXVxuICAgIH1cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG1heVJlbW92ZS5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGRvbVN0eWxlID0gbWF5UmVtb3ZlW2ldXG4gICAgICBpZiAoZG9tU3R5bGUucmVmcyA9PT0gMCkge1xuICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGRvbVN0eWxlLnBhcnRzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgZG9tU3R5bGUucGFydHNbal0oKVxuICAgICAgICB9XG4gICAgICAgIGRlbGV0ZSBzdHlsZXNJbkRvbVtkb21TdHlsZS5pZF1cbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gYWRkU3R5bGVzVG9Eb20gKHN0eWxlcyAvKiBBcnJheTxTdHlsZU9iamVjdD4gKi8pIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdHlsZXMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgaXRlbSA9IHN0eWxlc1tpXVxuICAgIHZhciBkb21TdHlsZSA9IHN0eWxlc0luRG9tW2l0ZW0uaWRdXG4gICAgaWYgKGRvbVN0eWxlKSB7XG4gICAgICBkb21TdHlsZS5yZWZzKytcbiAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgZG9tU3R5bGUucGFydHMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgZG9tU3R5bGUucGFydHNbal0oaXRlbS5wYXJ0c1tqXSlcbiAgICAgIH1cbiAgICAgIGZvciAoOyBqIDwgaXRlbS5wYXJ0cy5sZW5ndGg7IGorKykge1xuICAgICAgICBkb21TdHlsZS5wYXJ0cy5wdXNoKGFkZFN0eWxlKGl0ZW0ucGFydHNbal0pKVxuICAgICAgfVxuICAgICAgaWYgKGRvbVN0eWxlLnBhcnRzLmxlbmd0aCA+IGl0ZW0ucGFydHMubGVuZ3RoKSB7XG4gICAgICAgIGRvbVN0eWxlLnBhcnRzLmxlbmd0aCA9IGl0ZW0ucGFydHMubGVuZ3RoXG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBwYXJ0cyA9IFtdXG4gICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGl0ZW0ucGFydHMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgcGFydHMucHVzaChhZGRTdHlsZShpdGVtLnBhcnRzW2pdKSlcbiAgICAgIH1cbiAgICAgIHN0eWxlc0luRG9tW2l0ZW0uaWRdID0geyBpZDogaXRlbS5pZCwgcmVmczogMSwgcGFydHM6IHBhcnRzIH1cbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gY3JlYXRlU3R5bGVFbGVtZW50ICgpIHtcbiAgdmFyIHN0eWxlRWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3N0eWxlJylcbiAgc3R5bGVFbGVtZW50LnR5cGUgPSAndGV4dC9jc3MnXG4gIGhlYWQuYXBwZW5kQ2hpbGQoc3R5bGVFbGVtZW50KVxuICByZXR1cm4gc3R5bGVFbGVtZW50XG59XG5cbmZ1bmN0aW9uIGFkZFN0eWxlIChvYmogLyogU3R5bGVPYmplY3RQYXJ0ICovKSB7XG4gIHZhciB1cGRhdGUsIHJlbW92ZVxuICB2YXIgc3R5bGVFbGVtZW50ID0gZG9jdW1lbnQucXVlcnlTZWxlY3Rvcignc3R5bGVbJyArIHNzcklkS2V5ICsgJ349XCInICsgb2JqLmlkICsgJ1wiXScpXG5cbiAgaWYgKHN0eWxlRWxlbWVudCkge1xuICAgIGlmIChpc1Byb2R1Y3Rpb24pIHtcbiAgICAgIC8vIGhhcyBTU1Igc3R5bGVzIGFuZCBpbiBwcm9kdWN0aW9uIG1vZGUuXG4gICAgICAvLyBzaW1wbHkgZG8gbm90aGluZy5cbiAgICAgIHJldHVybiBub29wXG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGhhcyBTU1Igc3R5bGVzIGJ1dCBpbiBkZXYgbW9kZS5cbiAgICAgIC8vIGZvciBzb21lIHJlYXNvbiBDaHJvbWUgY2FuJ3QgaGFuZGxlIHNvdXJjZSBtYXAgaW4gc2VydmVyLXJlbmRlcmVkXG4gICAgICAvLyBzdHlsZSB0YWdzIC0gc291cmNlIG1hcHMgaW4gPHN0eWxlPiBvbmx5IHdvcmtzIGlmIHRoZSBzdHlsZSB0YWcgaXNcbiAgICAgIC8vIGNyZWF0ZWQgYW5kIGluc2VydGVkIGR5bmFtaWNhbGx5LiBTbyB3ZSByZW1vdmUgdGhlIHNlcnZlciByZW5kZXJlZFxuICAgICAgLy8gc3R5bGVzIGFuZCBpbmplY3QgbmV3IG9uZXMuXG4gICAgICBzdHlsZUVsZW1lbnQucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChzdHlsZUVsZW1lbnQpXG4gICAgfVxuICB9XG5cbiAgaWYgKGlzT2xkSUUpIHtcbiAgICAvLyB1c2Ugc2luZ2xldG9uIG1vZGUgZm9yIElFOS5cbiAgICB2YXIgc3R5bGVJbmRleCA9IHNpbmdsZXRvbkNvdW50ZXIrK1xuICAgIHN0eWxlRWxlbWVudCA9IHNpbmdsZXRvbkVsZW1lbnQgfHwgKHNpbmdsZXRvbkVsZW1lbnQgPSBjcmVhdGVTdHlsZUVsZW1lbnQoKSlcbiAgICB1cGRhdGUgPSBhcHBseVRvU2luZ2xldG9uVGFnLmJpbmQobnVsbCwgc3R5bGVFbGVtZW50LCBzdHlsZUluZGV4LCBmYWxzZSlcbiAgICByZW1vdmUgPSBhcHBseVRvU2luZ2xldG9uVGFnLmJpbmQobnVsbCwgc3R5bGVFbGVtZW50LCBzdHlsZUluZGV4LCB0cnVlKVxuICB9IGVsc2Uge1xuICAgIC8vIHVzZSBtdWx0aS1zdHlsZS10YWcgbW9kZSBpbiBhbGwgb3RoZXIgY2FzZXNcbiAgICBzdHlsZUVsZW1lbnQgPSBjcmVhdGVTdHlsZUVsZW1lbnQoKVxuICAgIHVwZGF0ZSA9IGFwcGx5VG9UYWcuYmluZChudWxsLCBzdHlsZUVsZW1lbnQpXG4gICAgcmVtb3ZlID0gZnVuY3Rpb24gKCkge1xuICAgICAgc3R5bGVFbGVtZW50LnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoc3R5bGVFbGVtZW50KVxuICAgIH1cbiAgfVxuXG4gIHVwZGF0ZShvYmopXG5cbiAgcmV0dXJuIGZ1bmN0aW9uIHVwZGF0ZVN0eWxlIChuZXdPYmogLyogU3R5bGVPYmplY3RQYXJ0ICovKSB7XG4gICAgaWYgKG5ld09iaikge1xuICAgICAgaWYgKG5ld09iai5jc3MgPT09IG9iai5jc3MgJiZcbiAgICAgICAgICBuZXdPYmoubWVkaWEgPT09IG9iai5tZWRpYSAmJlxuICAgICAgICAgIG5ld09iai5zb3VyY2VNYXAgPT09IG9iai5zb3VyY2VNYXApIHtcbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG4gICAgICB1cGRhdGUob2JqID0gbmV3T2JqKVxuICAgIH0gZWxzZSB7XG4gICAgICByZW1vdmUoKVxuICAgIH1cbiAgfVxufVxuXG52YXIgcmVwbGFjZVRleHQgPSAoZnVuY3Rpb24gKCkge1xuICB2YXIgdGV4dFN0b3JlID0gW11cblxuICByZXR1cm4gZnVuY3Rpb24gKGluZGV4LCByZXBsYWNlbWVudCkge1xuICAgIHRleHRTdG9yZVtpbmRleF0gPSByZXBsYWNlbWVudFxuICAgIHJldHVybiB0ZXh0U3RvcmUuZmlsdGVyKEJvb2xlYW4pLmpvaW4oJ1xcbicpXG4gIH1cbn0pKClcblxuZnVuY3Rpb24gYXBwbHlUb1NpbmdsZXRvblRhZyAoc3R5bGVFbGVtZW50LCBpbmRleCwgcmVtb3ZlLCBvYmopIHtcbiAgdmFyIGNzcyA9IHJlbW92ZSA/ICcnIDogb2JqLmNzc1xuXG4gIGlmIChzdHlsZUVsZW1lbnQuc3R5bGVTaGVldCkge1xuICAgIHN0eWxlRWxlbWVudC5zdHlsZVNoZWV0LmNzc1RleHQgPSByZXBsYWNlVGV4dChpbmRleCwgY3NzKVxuICB9IGVsc2Uge1xuICAgIHZhciBjc3NOb2RlID0gZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoY3NzKVxuICAgIHZhciBjaGlsZE5vZGVzID0gc3R5bGVFbGVtZW50LmNoaWxkTm9kZXNcbiAgICBpZiAoY2hpbGROb2Rlc1tpbmRleF0pIHN0eWxlRWxlbWVudC5yZW1vdmVDaGlsZChjaGlsZE5vZGVzW2luZGV4XSlcbiAgICBpZiAoY2hpbGROb2Rlcy5sZW5ndGgpIHtcbiAgICAgIHN0eWxlRWxlbWVudC5pbnNlcnRCZWZvcmUoY3NzTm9kZSwgY2hpbGROb2Rlc1tpbmRleF0pXG4gICAgfSBlbHNlIHtcbiAgICAgIHN0eWxlRWxlbWVudC5hcHBlbmRDaGlsZChjc3NOb2RlKVxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBhcHBseVRvVGFnIChzdHlsZUVsZW1lbnQsIG9iaikge1xuICB2YXIgY3NzID0gb2JqLmNzc1xuICB2YXIgbWVkaWEgPSBvYmoubWVkaWFcbiAgdmFyIHNvdXJjZU1hcCA9IG9iai5zb3VyY2VNYXBcblxuICBpZiAobWVkaWEpIHtcbiAgICBzdHlsZUVsZW1lbnQuc2V0QXR0cmlidXRlKCdtZWRpYScsIG1lZGlhKVxuICB9XG4gIGlmIChvcHRpb25zLnNzcklkKSB7XG4gICAgc3R5bGVFbGVtZW50LnNldEF0dHJpYnV0ZShzc3JJZEtleSwgb2JqLmlkKVxuICB9XG5cbiAgaWYgKHNvdXJjZU1hcCkge1xuICAgIC8vIGh0dHBzOi8vZGV2ZWxvcGVyLmNocm9tZS5jb20vZGV2dG9vbHMvZG9jcy9qYXZhc2NyaXB0LWRlYnVnZ2luZ1xuICAgIC8vIHRoaXMgbWFrZXMgc291cmNlIG1hcHMgaW5zaWRlIHN0eWxlIHRhZ3Mgd29yayBwcm9wZXJseSBpbiBDaHJvbWVcbiAgICBjc3MgKz0gJ1xcbi8qIyBzb3VyY2VVUkw9JyArIHNvdXJjZU1hcC5zb3VyY2VzWzBdICsgJyAqLydcbiAgICAvLyBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vYS8yNjYwMzg3NVxuICAgIGNzcyArPSAnXFxuLyojIHNvdXJjZU1hcHBpbmdVUkw9ZGF0YTphcHBsaWNhdGlvbi9qc29uO2Jhc2U2NCwnICsgYnRvYSh1bmVzY2FwZShlbmNvZGVVUklDb21wb25lbnQoSlNPTi5zdHJpbmdpZnkoc291cmNlTWFwKSkpKSArICcgKi8nXG4gIH1cblxuICBpZiAoc3R5bGVFbGVtZW50LnN0eWxlU2hlZXQpIHtcbiAgICBzdHlsZUVsZW1lbnQuc3R5bGVTaGVldC5jc3NUZXh0ID0gY3NzXG4gIH0gZWxzZSB7XG4gICAgd2hpbGUgKHN0eWxlRWxlbWVudC5maXJzdENoaWxkKSB7XG4gICAgICBzdHlsZUVsZW1lbnQucmVtb3ZlQ2hpbGQoc3R5bGVFbGVtZW50LmZpcnN0Q2hpbGQpXG4gICAgfVxuICAgIHN0eWxlRWxlbWVudC5hcHBlbmRDaGlsZChkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShjc3MpKVxuICB9XG59XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiNDlhZFwiOlxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGlkSGFuZGxlcikge1xuICAgIHZhciBldmVudExpc3RlbmVycyA9IHt9O1xuXG4gICAgLyoqXG4gICAgICogR2V0cyBhbGwgbGlzdGVuZXJzIGZvciB0aGUgZ2l2ZW4gZWxlbWVudC5cbiAgICAgKiBAcHVibGljXG4gICAgICogQHBhcmFtIHtlbGVtZW50fSBlbGVtZW50IFRoZSBlbGVtZW50IHRvIGdldCBhbGwgbGlzdGVuZXJzIGZvci5cbiAgICAgKiBAcmV0dXJucyBBbGwgbGlzdGVuZXJzIGZvciB0aGUgZ2l2ZW4gZWxlbWVudC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBnZXRMaXN0ZW5lcnMoZWxlbWVudCkge1xuICAgICAgICB2YXIgaWQgPSBpZEhhbmRsZXIuZ2V0KGVsZW1lbnQpO1xuXG4gICAgICAgIGlmIChpZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZXZlbnRMaXN0ZW5lcnNbaWRdIHx8IFtdO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFN0b3JlcyB0aGUgZ2l2ZW4gbGlzdGVuZXIgZm9yIHRoZSBnaXZlbiBlbGVtZW50LiBXaWxsIG5vdCBhY3R1YWxseSBhZGQgdGhlIGxpc3RlbmVyIHRvIHRoZSBlbGVtZW50LlxuICAgICAqIEBwdWJsaWNcbiAgICAgKiBAcGFyYW0ge2VsZW1lbnR9IGVsZW1lbnQgVGhlIGVsZW1lbnQgdGhhdCBzaG91bGQgaGF2ZSB0aGUgbGlzdGVuZXIgYWRkZWQuXG4gICAgICogQHBhcmFtIHtmdW5jdGlvbn0gbGlzdGVuZXIgVGhlIGNhbGxiYWNrIHRoYXQgdGhlIGVsZW1lbnQgaGFzIGFkZGVkLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGFkZExpc3RlbmVyKGVsZW1lbnQsIGxpc3RlbmVyKSB7XG4gICAgICAgIHZhciBpZCA9IGlkSGFuZGxlci5nZXQoZWxlbWVudCk7XG5cbiAgICAgICAgaWYoIWV2ZW50TGlzdGVuZXJzW2lkXSkge1xuICAgICAgICAgICAgZXZlbnRMaXN0ZW5lcnNbaWRdID0gW107XG4gICAgICAgIH1cblxuICAgICAgICBldmVudExpc3RlbmVyc1tpZF0ucHVzaChsaXN0ZW5lcik7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcmVtb3ZlTGlzdGVuZXIoZWxlbWVudCwgbGlzdGVuZXIpIHtcbiAgICAgICAgdmFyIGxpc3RlbmVycyA9IGdldExpc3RlbmVycyhlbGVtZW50KTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IGxpc3RlbmVycy5sZW5ndGg7IGkgPCBsZW47ICsraSkge1xuICAgICAgICAgICAgaWYgKGxpc3RlbmVyc1tpXSA9PT0gbGlzdGVuZXIpIHtcbiAgICAgICAgICAgICAgbGlzdGVuZXJzLnNwbGljZShpLCAxKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiByZW1vdmVBbGxMaXN0ZW5lcnMoZWxlbWVudCkge1xuICAgICAgdmFyIGxpc3RlbmVycyA9IGdldExpc3RlbmVycyhlbGVtZW50KTtcbiAgICAgIGlmICghbGlzdGVuZXJzKSB7IHJldHVybjsgfVxuICAgICAgbGlzdGVuZXJzLmxlbmd0aCA9IDA7XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgICAgZ2V0OiBnZXRMaXN0ZW5lcnMsXG4gICAgICAgIGFkZDogYWRkTGlzdGVuZXIsXG4gICAgICAgIHJlbW92ZUxpc3RlbmVyOiByZW1vdmVMaXN0ZW5lcixcbiAgICAgICAgcmVtb3ZlQWxsTGlzdGVuZXJzOiByZW1vdmVBbGxMaXN0ZW5lcnNcbiAgICB9O1xufTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCI0YmY4XCI6XG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbi8vIDcuMS4xMyBUb09iamVjdChhcmd1bWVudClcbnZhciBkZWZpbmVkID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcImJlMTNcIik7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdCkge1xuICByZXR1cm4gT2JqZWN0KGRlZmluZWQoaXQpKTtcbn07XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiNTA1OFwiOlxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICB2YXIgaWRHZW5lcmF0b3IgICAgID0gb3B0aW9ucy5pZEdlbmVyYXRvcjtcbiAgICB2YXIgZ2V0U3RhdGUgICAgICAgID0gb3B0aW9ucy5zdGF0ZUhhbmRsZXIuZ2V0U3RhdGU7XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSByZXNpemUgZGV0ZWN0b3IgaWQgb2YgdGhlIGVsZW1lbnQuXG4gICAgICogQHB1YmxpY1xuICAgICAqIEBwYXJhbSB7ZWxlbWVudH0gZWxlbWVudCBUaGUgdGFyZ2V0IGVsZW1lbnQgdG8gZ2V0IHRoZSBpZCBvZi5cbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfG51bWJlcnxudWxsfSBUaGUgaWQgb2YgdGhlIGVsZW1lbnQuIE51bGwgaWYgaXQgaGFzIG5vIGlkLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGdldElkKGVsZW1lbnQpIHtcbiAgICAgICAgdmFyIHN0YXRlID0gZ2V0U3RhdGUoZWxlbWVudCk7XG5cbiAgICAgICAgaWYgKHN0YXRlICYmIHN0YXRlLmlkICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybiBzdGF0ZS5pZDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIHJlc2l6ZSBkZXRlY3RvciBpZCBvZiB0aGUgZWxlbWVudC4gUmVxdWlyZXMgdGhlIGVsZW1lbnQgdG8gaGF2ZSBhIHJlc2l6ZSBkZXRlY3RvciBzdGF0ZSBpbml0aWFsaXplZC5cbiAgICAgKiBAcHVibGljXG4gICAgICogQHBhcmFtIHtlbGVtZW50fSBlbGVtZW50IFRoZSB0YXJnZXQgZWxlbWVudCB0byBzZXQgdGhlIGlkIG9mLlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd8bnVtYmVyfG51bGx9IFRoZSBpZCBvZiB0aGUgZWxlbWVudC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBzZXRJZChlbGVtZW50KSB7XG4gICAgICAgIHZhciBzdGF0ZSA9IGdldFN0YXRlKGVsZW1lbnQpO1xuXG4gICAgICAgIGlmICghc3RhdGUpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcInNldElkIHJlcXVpcmVkIHRoZSBlbGVtZW50IHRvIGhhdmUgYSByZXNpemUgZGV0ZWN0aW9uIHN0YXRlLlwiKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBpZCA9IGlkR2VuZXJhdG9yLmdlbmVyYXRlKCk7XG5cbiAgICAgICAgc3RhdGUuaWQgPSBpZDtcblxuICAgICAgICByZXR1cm4gaWQ7XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgICAgZ2V0OiBnZXRJZCxcbiAgICAgICAgc2V0OiBzZXRJZFxuICAgIH07XG59O1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIjUwYmZcIjpcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxudmFyIHV0aWxzID0gbW9kdWxlLmV4cG9ydHMgPSB7fTtcblxudXRpbHMuZ2V0T3B0aW9uID0gZ2V0T3B0aW9uO1xuXG5mdW5jdGlvbiBnZXRPcHRpb24ob3B0aW9ucywgbmFtZSwgZGVmYXVsdFZhbHVlKSB7XG4gICAgdmFyIHZhbHVlID0gb3B0aW9uc1tuYW1lXTtcblxuICAgIGlmKCh2YWx1ZSA9PT0gdW5kZWZpbmVkIHx8IHZhbHVlID09PSBudWxsKSAmJiBkZWZhdWx0VmFsdWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gZGVmYXVsdFZhbHVlO1xuICAgIH1cblxuICAgIHJldHVybiB2YWx1ZTtcbn1cblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCI1MjBhXCI6XG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbnZhciByZWdleHBGbGFncyA9IF9fd2VicGFja19yZXF1aXJlX18oXCIwYmZiXCIpO1xuXG52YXIgbmF0aXZlRXhlYyA9IFJlZ0V4cC5wcm90b3R5cGUuZXhlYztcbi8vIFRoaXMgYWx3YXlzIHJlZmVycyB0byB0aGUgbmF0aXZlIGltcGxlbWVudGF0aW9uLCBiZWNhdXNlIHRoZVxuLy8gU3RyaW5nI3JlcGxhY2UgcG9seWZpbGwgdXNlcyAuL2ZpeC1yZWdleHAtd2VsbC1rbm93bi1zeW1ib2wtbG9naWMuanMsXG4vLyB3aGljaCBsb2FkcyB0aGlzIGZpbGUgYmVmb3JlIHBhdGNoaW5nIHRoZSBtZXRob2QuXG52YXIgbmF0aXZlUmVwbGFjZSA9IFN0cmluZy5wcm90b3R5cGUucmVwbGFjZTtcblxudmFyIHBhdGNoZWRFeGVjID0gbmF0aXZlRXhlYztcblxudmFyIExBU1RfSU5ERVggPSAnbGFzdEluZGV4JztcblxudmFyIFVQREFURVNfTEFTVF9JTkRFWF9XUk9ORyA9IChmdW5jdGlvbiAoKSB7XG4gIHZhciByZTEgPSAvYS8sXG4gICAgICByZTIgPSAvYiovZztcbiAgbmF0aXZlRXhlYy5jYWxsKHJlMSwgJ2EnKTtcbiAgbmF0aXZlRXhlYy5jYWxsKHJlMiwgJ2EnKTtcbiAgcmV0dXJuIHJlMVtMQVNUX0lOREVYXSAhPT0gMCB8fCByZTJbTEFTVF9JTkRFWF0gIT09IDA7XG59KSgpO1xuXG4vLyBub25wYXJ0aWNpcGF0aW5nIGNhcHR1cmluZyBncm91cCwgY29waWVkIGZyb20gZXM1LXNoaW0ncyBTdHJpbmcjc3BsaXQgcGF0Y2guXG52YXIgTlBDR19JTkNMVURFRCA9IC8oKT8/Ly5leGVjKCcnKVsxXSAhPT0gdW5kZWZpbmVkO1xuXG52YXIgUEFUQ0ggPSBVUERBVEVTX0xBU1RfSU5ERVhfV1JPTkcgfHwgTlBDR19JTkNMVURFRDtcblxuaWYgKFBBVENIKSB7XG4gIHBhdGNoZWRFeGVjID0gZnVuY3Rpb24gZXhlYyhzdHIpIHtcbiAgICB2YXIgcmUgPSB0aGlzO1xuICAgIHZhciBsYXN0SW5kZXgsIHJlQ29weSwgbWF0Y2gsIGk7XG5cbiAgICBpZiAoTlBDR19JTkNMVURFRCkge1xuICAgICAgcmVDb3B5ID0gbmV3IFJlZ0V4cCgnXicgKyByZS5zb3VyY2UgKyAnJCg/IVxcXFxzKScsIHJlZ2V4cEZsYWdzLmNhbGwocmUpKTtcbiAgICB9XG4gICAgaWYgKFVQREFURVNfTEFTVF9JTkRFWF9XUk9ORykgbGFzdEluZGV4ID0gcmVbTEFTVF9JTkRFWF07XG5cbiAgICBtYXRjaCA9IG5hdGl2ZUV4ZWMuY2FsbChyZSwgc3RyKTtcblxuICAgIGlmIChVUERBVEVTX0xBU1RfSU5ERVhfV1JPTkcgJiYgbWF0Y2gpIHtcbiAgICAgIHJlW0xBU1RfSU5ERVhdID0gcmUuZ2xvYmFsID8gbWF0Y2guaW5kZXggKyBtYXRjaFswXS5sZW5ndGggOiBsYXN0SW5kZXg7XG4gICAgfVxuICAgIGlmIChOUENHX0lOQ0xVREVEICYmIG1hdGNoICYmIG1hdGNoLmxlbmd0aCA+IDEpIHtcbiAgICAgIC8vIEZpeCBicm93c2VycyB3aG9zZSBgZXhlY2AgbWV0aG9kcyBkb24ndCBjb25zaXN0ZW50bHkgcmV0dXJuIGB1bmRlZmluZWRgXG4gICAgICAvLyBmb3IgTlBDRywgbGlrZSBJRTguIE5PVEU6IFRoaXMgZG9lc24nIHdvcmsgZm9yIC8oLj8pPy9cbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1sb29wLWZ1bmNcbiAgICAgIG5hdGl2ZVJlcGxhY2UuY2FsbChtYXRjaFswXSwgcmVDb3B5LCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGZvciAoaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoIC0gMjsgaSsrKSB7XG4gICAgICAgICAgaWYgKGFyZ3VtZW50c1tpXSA9PT0gdW5kZWZpbmVkKSBtYXRjaFtpXSA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG1hdGNoO1xuICB9O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHBhdGNoZWRFeGVjO1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIjUyYTdcIjpcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxuZXhwb3J0cy5mID0ge30ucHJvcGVydHlJc0VudW1lcmFibGU7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiNTUzN1wiOlxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG52YXIgY29yZSA9IF9fd2VicGFja19yZXF1aXJlX18oXCI4Mzc4XCIpO1xudmFyIGdsb2JhbCA9IF9fd2VicGFja19yZXF1aXJlX18oXCI3NzI2XCIpO1xudmFyIFNIQVJFRCA9ICdfX2NvcmUtanNfc2hhcmVkX18nO1xudmFyIHN0b3JlID0gZ2xvYmFsW1NIQVJFRF0gfHwgKGdsb2JhbFtTSEFSRURdID0ge30pO1xuXG4obW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoa2V5LCB2YWx1ZSkge1xuICByZXR1cm4gc3RvcmVba2V5XSB8fCAoc3RvcmVba2V5XSA9IHZhbHVlICE9PSB1bmRlZmluZWQgPyB2YWx1ZSA6IHt9KTtcbn0pKCd2ZXJzaW9ucycsIFtdKS5wdXNoKHtcbiAgdmVyc2lvbjogY29yZS52ZXJzaW9uLFxuICBtb2RlOiBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiMmQwMFwiKSA/ICdwdXJlJyA6ICdnbG9iYWwnLFxuICBjb3B5cmlnaHQ6ICfCqSAyMDIwIERlbmlzIFB1c2hrYXJldiAoemxvaXJvY2sucnUpJ1xufSk7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiNTVkZFwiOlxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxudmFyICRleHBvcnQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiNWNhMVwiKTtcbnZhciBhRnVuY3Rpb24gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiZDhlOFwiKTtcbnZhciB0b09iamVjdCA9IF9fd2VicGFja19yZXF1aXJlX18oXCI0YmY4XCIpO1xudmFyIGZhaWxzID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIjc5ZTVcIik7XG52YXIgJHNvcnQgPSBbXS5zb3J0O1xudmFyIHRlc3QgPSBbMSwgMiwgM107XG5cbiRleHBvcnQoJGV4cG9ydC5QICsgJGV4cG9ydC5GICogKGZhaWxzKGZ1bmN0aW9uICgpIHtcbiAgLy8gSUU4LVxuICB0ZXN0LnNvcnQodW5kZWZpbmVkKTtcbn0pIHx8ICFmYWlscyhmdW5jdGlvbiAoKSB7XG4gIC8vIFY4IGJ1Z1xuICB0ZXN0LnNvcnQobnVsbCk7XG4gIC8vIE9sZCBXZWJLaXRcbn0pIHx8ICFfX3dlYnBhY2tfcmVxdWlyZV9fKFwiMmYyMVwiKSgkc29ydCkpLCAnQXJyYXknLCB7XG4gIC8vIDIyLjEuMy4yNSBBcnJheS5wcm90b3R5cGUuc29ydChjb21wYXJlZm4pXG4gIHNvcnQ6IGZ1bmN0aW9uIHNvcnQoY29tcGFyZWZuKSB7XG4gICAgcmV0dXJuIGNvbXBhcmVmbiA9PT0gdW5kZWZpbmVkXG4gICAgICA/ICRzb3J0LmNhbGwodG9PYmplY3QodGhpcykpXG4gICAgICA6ICRzb3J0LmNhbGwodG9PYmplY3QodGhpcyksIGFGdW5jdGlvbihjb21wYXJlZm4pKTtcbiAgfVxufSk7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiNWJlNVwiOlxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICB2YXIgZ2V0U3RhdGUgPSBvcHRpb25zLnN0YXRlSGFuZGxlci5nZXRTdGF0ZTtcblxuICAgIC8qKlxuICAgICAqIFRlbGxzIGlmIHRoZSBlbGVtZW50IGhhcyBiZWVuIG1hZGUgZGV0ZWN0YWJsZSBhbmQgcmVhZHkgdG8gYmUgbGlzdGVuZWQgZm9yIHJlc2l6ZSBldmVudHMuXG4gICAgICogQHB1YmxpY1xuICAgICAqIEBwYXJhbSB7ZWxlbWVudH0gVGhlIGVsZW1lbnQgdG8gY2hlY2suXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgb3IgZmFsc2UgZGVwZW5kaW5nIG9uIGlmIHRoZSBlbGVtZW50IGlzIGRldGVjdGFibGUgb3Igbm90LlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzRGV0ZWN0YWJsZShlbGVtZW50KSB7XG4gICAgICAgIHZhciBzdGF0ZSA9IGdldFN0YXRlKGVsZW1lbnQpO1xuICAgICAgICByZXR1cm4gc3RhdGUgJiYgISFzdGF0ZS5pc0RldGVjdGFibGU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogTWFya3MgdGhlIGVsZW1lbnQgdGhhdCBpdCBoYXMgYmVlbiBtYWRlIGRldGVjdGFibGUgYW5kIHJlYWR5IHRvIGJlIGxpc3RlbmVkIGZvciByZXNpemUgZXZlbnRzLlxuICAgICAqIEBwdWJsaWNcbiAgICAgKiBAcGFyYW0ge2VsZW1lbnR9IFRoZSBlbGVtZW50IHRvIG1hcmsuXG4gICAgICovXG4gICAgZnVuY3Rpb24gbWFya0FzRGV0ZWN0YWJsZShlbGVtZW50KSB7XG4gICAgICAgIGdldFN0YXRlKGVsZW1lbnQpLmlzRGV0ZWN0YWJsZSA9IHRydWU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGVsbHMgaWYgdGhlIGVsZW1lbnQgaXMgYnVzeSBvciBub3QuXG4gICAgICogQHB1YmxpY1xuICAgICAqIEBwYXJhbSB7ZWxlbWVudH0gVGhlIGVsZW1lbnQgdG8gY2hlY2suXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgb3IgZmFsc2UgZGVwZW5kaW5nIG9uIGlmIHRoZSBlbGVtZW50IGlzIGJ1c3kgb3Igbm90LlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzQnVzeShlbGVtZW50KSB7XG4gICAgICAgIHJldHVybiAhIWdldFN0YXRlKGVsZW1lbnQpLmJ1c3k7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogTWFya3MgdGhlIG9iamVjdCBpcyBidXN5IGFuZCBzaG91bGQgbm90IGJlIG1hZGUgZGV0ZWN0YWJsZS5cbiAgICAgKiBAcHVibGljXG4gICAgICogQHBhcmFtIHtlbGVtZW50fSBlbGVtZW50IFRoZSBlbGVtZW50IHRvIG1hcmsuXG4gICAgICogQHBhcmFtIHtib29sZWFufSBidXN5IElmIHRoZSBlbGVtZW50IGlzIGJ1c3kgb3Igbm90LlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIG1hcmtCdXN5KGVsZW1lbnQsIGJ1c3kpIHtcbiAgICAgICAgZ2V0U3RhdGUoZWxlbWVudCkuYnVzeSA9ICEhYnVzeTtcbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgICBpc0RldGVjdGFibGU6IGlzRGV0ZWN0YWJsZSxcbiAgICAgICAgbWFya0FzRGV0ZWN0YWJsZTogbWFya0FzRGV0ZWN0YWJsZSxcbiAgICAgICAgaXNCdXN5OiBpc0J1c3ksXG4gICAgICAgIG1hcmtCdXN5OiBtYXJrQnVzeVxuICAgIH07XG59O1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIjVjYTFcIjpcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxudmFyIGdsb2JhbCA9IF9fd2VicGFja19yZXF1aXJlX18oXCI3NzI2XCIpO1xudmFyIGNvcmUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiODM3OFwiKTtcbnZhciBoaWRlID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIjMyZTlcIik7XG52YXIgcmVkZWZpbmUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiMmFiYVwiKTtcbnZhciBjdHggPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiOWI0M1wiKTtcbnZhciBQUk9UT1RZUEUgPSAncHJvdG90eXBlJztcblxudmFyICRleHBvcnQgPSBmdW5jdGlvbiAodHlwZSwgbmFtZSwgc291cmNlKSB7XG4gIHZhciBJU19GT1JDRUQgPSB0eXBlICYgJGV4cG9ydC5GO1xuICB2YXIgSVNfR0xPQkFMID0gdHlwZSAmICRleHBvcnQuRztcbiAgdmFyIElTX1NUQVRJQyA9IHR5cGUgJiAkZXhwb3J0LlM7XG4gIHZhciBJU19QUk9UTyA9IHR5cGUgJiAkZXhwb3J0LlA7XG4gIHZhciBJU19CSU5EID0gdHlwZSAmICRleHBvcnQuQjtcbiAgdmFyIHRhcmdldCA9IElTX0dMT0JBTCA/IGdsb2JhbCA6IElTX1NUQVRJQyA/IGdsb2JhbFtuYW1lXSB8fCAoZ2xvYmFsW25hbWVdID0ge30pIDogKGdsb2JhbFtuYW1lXSB8fCB7fSlbUFJPVE9UWVBFXTtcbiAgdmFyIGV4cG9ydHMgPSBJU19HTE9CQUwgPyBjb3JlIDogY29yZVtuYW1lXSB8fCAoY29yZVtuYW1lXSA9IHt9KTtcbiAgdmFyIGV4cFByb3RvID0gZXhwb3J0c1tQUk9UT1RZUEVdIHx8IChleHBvcnRzW1BST1RPVFlQRV0gPSB7fSk7XG4gIHZhciBrZXksIG93biwgb3V0LCBleHA7XG4gIGlmIChJU19HTE9CQUwpIHNvdXJjZSA9IG5hbWU7XG4gIGZvciAoa2V5IGluIHNvdXJjZSkge1xuICAgIC8vIGNvbnRhaW5zIGluIG5hdGl2ZVxuICAgIG93biA9ICFJU19GT1JDRUQgJiYgdGFyZ2V0ICYmIHRhcmdldFtrZXldICE9PSB1bmRlZmluZWQ7XG4gICAgLy8gZXhwb3J0IG5hdGl2ZSBvciBwYXNzZWRcbiAgICBvdXQgPSAob3duID8gdGFyZ2V0IDogc291cmNlKVtrZXldO1xuICAgIC8vIGJpbmQgdGltZXJzIHRvIGdsb2JhbCBmb3IgY2FsbCBmcm9tIGV4cG9ydCBjb250ZXh0XG4gICAgZXhwID0gSVNfQklORCAmJiBvd24gPyBjdHgob3V0LCBnbG9iYWwpIDogSVNfUFJPVE8gJiYgdHlwZW9mIG91dCA9PSAnZnVuY3Rpb24nID8gY3R4KEZ1bmN0aW9uLmNhbGwsIG91dCkgOiBvdXQ7XG4gICAgLy8gZXh0ZW5kIGdsb2JhbFxuICAgIGlmICh0YXJnZXQpIHJlZGVmaW5lKHRhcmdldCwga2V5LCBvdXQsIHR5cGUgJiAkZXhwb3J0LlUpO1xuICAgIC8vIGV4cG9ydFxuICAgIGlmIChleHBvcnRzW2tleV0gIT0gb3V0KSBoaWRlKGV4cG9ydHMsIGtleSwgZXhwKTtcbiAgICBpZiAoSVNfUFJPVE8gJiYgZXhwUHJvdG9ba2V5XSAhPSBvdXQpIGV4cFByb3RvW2tleV0gPSBvdXQ7XG4gIH1cbn07XG5nbG9iYWwuY29yZSA9IGNvcmU7XG4vLyB0eXBlIGJpdG1hcFxuJGV4cG9ydC5GID0gMTsgICAvLyBmb3JjZWRcbiRleHBvcnQuRyA9IDI7ICAgLy8gZ2xvYmFsXG4kZXhwb3J0LlMgPSA0OyAgIC8vIHN0YXRpY1xuJGV4cG9ydC5QID0gODsgICAvLyBwcm90b1xuJGV4cG9ydC5CID0gMTY7ICAvLyBiaW5kXG4kZXhwb3J0LlcgPSAzMjsgIC8vIHdyYXBcbiRleHBvcnQuVSA9IDY0OyAgLy8gc2FmZVxuJGV4cG9ydC5SID0gMTI4OyAvLyByZWFsIHByb3RvIG1ldGhvZCBmb3IgYGxpYnJhcnlgXG5tb2R1bGUuZXhwb3J0cyA9ICRleHBvcnQ7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiNWRiY1wiOlxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG52YXIgaXNPYmplY3QgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiZDNmNFwiKTtcbnZhciBzZXRQcm90b3R5cGVPZiA9IF9fd2VicGFja19yZXF1aXJlX18oXCI4Yjk3XCIpLnNldDtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKHRoYXQsIHRhcmdldCwgQykge1xuICB2YXIgUyA9IHRhcmdldC5jb25zdHJ1Y3RvcjtcbiAgdmFyIFA7XG4gIGlmIChTICE9PSBDICYmIHR5cGVvZiBTID09ICdmdW5jdGlvbicgJiYgKFAgPSBTLnByb3RvdHlwZSkgIT09IEMucHJvdG90eXBlICYmIGlzT2JqZWN0KFApICYmIHNldFByb3RvdHlwZU9mKSB7XG4gICAgc2V0UHJvdG90eXBlT2YodGhhdCwgUCk7XG4gIH0gcmV0dXJuIHRoYXQ7XG59O1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIjVlZDRcIjpcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX25vZGVfbW9kdWxlc192dWVfc3R5bGVfbG9hZGVyX2luZGV4X2pzX3JlZl82X29uZU9mXzFfMF9ub2RlX21vZHVsZXNfY3NzX2xvYWRlcl9pbmRleF9qc19yZWZfNl9vbmVPZl8xXzFfbm9kZV9tb2R1bGVzX3Z1ZV9sb2FkZXJfbGliX2xvYWRlcnNfc3R5bGVQb3N0TG9hZGVyX2pzX25vZGVfbW9kdWxlc19wb3N0Y3NzX2xvYWRlcl9zcmNfaW5kZXhfanNfcmVmXzZfb25lT2ZfMV8yX25vZGVfbW9kdWxlc19wb3N0Y3NzX2xvYWRlcl9zcmNfaW5kZXhfanNfcmVmXzZfb25lT2ZfMV8zX25vZGVfbW9kdWxlc19jYWNoZV9sb2FkZXJfZGlzdF9janNfanNfcmVmXzBfMF9ub2RlX21vZHVsZXNfdnVlX2xvYWRlcl9saWJfaW5kZXhfanNfdnVlX2xvYWRlcl9vcHRpb25zX0dyaWRJdGVtX3Z1ZV92dWVfdHlwZV9zdHlsZV9pbmRleF8wX2xhbmdfY3NzX19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIjZlMjFcIik7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX25vZGVfbW9kdWxlc192dWVfc3R5bGVfbG9hZGVyX2luZGV4X2pzX3JlZl82X29uZU9mXzFfMF9ub2RlX21vZHVsZXNfY3NzX2xvYWRlcl9pbmRleF9qc19yZWZfNl9vbmVPZl8xXzFfbm9kZV9tb2R1bGVzX3Z1ZV9sb2FkZXJfbGliX2xvYWRlcnNfc3R5bGVQb3N0TG9hZGVyX2pzX25vZGVfbW9kdWxlc19wb3N0Y3NzX2xvYWRlcl9zcmNfaW5kZXhfanNfcmVmXzZfb25lT2ZfMV8yX25vZGVfbW9kdWxlc19wb3N0Y3NzX2xvYWRlcl9zcmNfaW5kZXhfanNfcmVmXzZfb25lT2ZfMV8zX25vZGVfbW9kdWxlc19jYWNoZV9sb2FkZXJfZGlzdF9janNfanNfcmVmXzBfMF9ub2RlX21vZHVsZXNfdnVlX2xvYWRlcl9saWJfaW5kZXhfanNfdnVlX2xvYWRlcl9vcHRpb25zX0dyaWRJdGVtX3Z1ZV92dWVfdHlwZV9zdHlsZV9pbmRleF8wX2xhbmdfY3NzX19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fX2RlZmF1bHQgPSAvKiNfX1BVUkVfXyovX193ZWJwYWNrX3JlcXVpcmVfXy5uKF9ub2RlX21vZHVsZXNfdnVlX3N0eWxlX2xvYWRlcl9pbmRleF9qc19yZWZfNl9vbmVPZl8xXzBfbm9kZV9tb2R1bGVzX2Nzc19sb2FkZXJfaW5kZXhfanNfcmVmXzZfb25lT2ZfMV8xX25vZGVfbW9kdWxlc192dWVfbG9hZGVyX2xpYl9sb2FkZXJzX3N0eWxlUG9zdExvYWRlcl9qc19ub2RlX21vZHVsZXNfcG9zdGNzc19sb2FkZXJfc3JjX2luZGV4X2pzX3JlZl82X29uZU9mXzFfMl9ub2RlX21vZHVsZXNfcG9zdGNzc19sb2FkZXJfc3JjX2luZGV4X2pzX3JlZl82X29uZU9mXzFfM19ub2RlX21vZHVsZXNfY2FjaGVfbG9hZGVyX2Rpc3RfY2pzX2pzX3JlZl8wXzBfbm9kZV9tb2R1bGVzX3Z1ZV9sb2FkZXJfbGliX2luZGV4X2pzX3Z1ZV9sb2FkZXJfb3B0aW9uc19HcmlkSXRlbV92dWVfdnVlX3R5cGVfc3R5bGVfaW5kZXhfMF9sYW5nX2Nzc19fX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXyk7XG4vKiB1bnVzZWQgaGFybW9ueSByZWV4cG9ydCAqICovXG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiNWVkYVwiOlxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG4vLyBtb3N0IE9iamVjdCBtZXRob2RzIGJ5IEVTNiBzaG91bGQgYWNjZXB0IHByaW1pdGl2ZXNcbnZhciAkZXhwb3J0ID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIjVjYTFcIik7XG52YXIgY29yZSA9IF9fd2VicGFja19yZXF1aXJlX18oXCI4Mzc4XCIpO1xudmFyIGZhaWxzID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIjc5ZTVcIik7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChLRVksIGV4ZWMpIHtcbiAgdmFyIGZuID0gKGNvcmUuT2JqZWN0IHx8IHt9KVtLRVldIHx8IE9iamVjdFtLRVldO1xuICB2YXIgZXhwID0ge307XG4gIGV4cFtLRVldID0gZXhlYyhmbik7XG4gICRleHBvcnQoJGV4cG9ydC5TICsgJGV4cG9ydC5GICogZmFpbHMoZnVuY3Rpb24gKCkgeyBmbigxKTsgfSksICdPYmplY3QnLCBleHApO1xufTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCI1ZjFiXCI6XG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbnZhciBjbGFzc29mID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIjIzYzZcIik7XG52YXIgYnVpbHRpbkV4ZWMgPSBSZWdFeHAucHJvdG90eXBlLmV4ZWM7XG5cbiAvLyBgUmVnRXhwRXhlY2AgYWJzdHJhY3Qgb3BlcmF0aW9uXG4vLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1yZWdleHBleGVjXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChSLCBTKSB7XG4gIHZhciBleGVjID0gUi5leGVjO1xuICBpZiAodHlwZW9mIGV4ZWMgPT09ICdmdW5jdGlvbicpIHtcbiAgICB2YXIgcmVzdWx0ID0gZXhlYy5jYWxsKFIsIFMpO1xuICAgIGlmICh0eXBlb2YgcmVzdWx0ICE9PSAnb2JqZWN0Jykge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignUmVnRXhwIGV4ZWMgbWV0aG9kIHJldHVybmVkIHNvbWV0aGluZyBvdGhlciB0aGFuIGFuIE9iamVjdCBvciBudWxsJyk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbiAgaWYgKGNsYXNzb2YoUikgIT09ICdSZWdFeHAnKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignUmVnRXhwI2V4ZWMgY2FsbGVkIG9uIGluY29tcGF0aWJsZSByZWNlaXZlcicpO1xuICB9XG4gIHJldHVybiBidWlsdGluRXhlYy5jYWxsKFIsIFMpO1xufTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCI2MTNiXCI6XG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbnZhciBzaGFyZWQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiNTUzN1wiKSgna2V5cycpO1xudmFyIHVpZCA9IF9fd2VicGFja19yZXF1aXJlX18oXCJjYTVhXCIpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoa2V5KSB7XG4gIHJldHVybiBzaGFyZWRba2V5XSB8fCAoc2hhcmVkW2tleV0gPSB1aWQoa2V5KSk7XG59O1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIjYyNmFcIjpcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuLy8gZmFsbGJhY2sgZm9yIG5vbi1hcnJheS1saWtlIEVTMyBhbmQgbm9uLWVudW1lcmFibGUgb2xkIFY4IHN0cmluZ3NcbnZhciBjb2YgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiMmQ5NVwiKTtcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1wcm90b3R5cGUtYnVpbHRpbnNcbm1vZHVsZS5leHBvcnRzID0gT2JqZWN0KCd6JykucHJvcGVydHlJc0VudW1lcmFibGUoMCkgPyBPYmplY3QgOiBmdW5jdGlvbiAoaXQpIHtcbiAgcmV0dXJuIGNvZihpdCkgPT0gJ1N0cmluZycgPyBpdC5zcGxpdCgnJykgOiBPYmplY3QoaXQpO1xufTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCI2ODIxXCI6XG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbi8vIHRvIGluZGV4ZWQgb2JqZWN0LCB0b09iamVjdCB3aXRoIGZhbGxiYWNrIGZvciBub24tYXJyYXktbGlrZSBFUzMgc3RyaW5nc1xudmFyIElPYmplY3QgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiNjI2YVwiKTtcbnZhciBkZWZpbmVkID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcImJlMTNcIik7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdCkge1xuICByZXR1cm4gSU9iamVjdChkZWZpbmVkKGl0KSk7XG59O1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIjY5YThcIjpcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxudmFyIGhhc093blByb3BlcnR5ID0ge30uaGFzT3duUHJvcGVydHk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdCwga2V5KSB7XG4gIHJldHVybiBoYXNPd25Qcm9wZXJ0eS5jYWxsKGl0LCBrZXkpO1xufTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCI2YTk5XCI6XG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbi8vIDcuMS4xIFRvUHJpbWl0aXZlKGlucHV0IFssIFByZWZlcnJlZFR5cGVdKVxudmFyIGlzT2JqZWN0ID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcImQzZjRcIik7XG4vLyBpbnN0ZWFkIG9mIHRoZSBFUzYgc3BlYyB2ZXJzaW9uLCB3ZSBkaWRuJ3QgaW1wbGVtZW50IEBAdG9QcmltaXRpdmUgY2FzZVxuLy8gYW5kIHRoZSBzZWNvbmQgYXJndW1lbnQgLSBmbGFnIC0gcHJlZmVycmVkIHR5cGUgaXMgYSBzdHJpbmdcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0LCBTKSB7XG4gIGlmICghaXNPYmplY3QoaXQpKSByZXR1cm4gaXQ7XG4gIHZhciBmbiwgdmFsO1xuICBpZiAoUyAmJiB0eXBlb2YgKGZuID0gaXQudG9TdHJpbmcpID09ICdmdW5jdGlvbicgJiYgIWlzT2JqZWN0KHZhbCA9IGZuLmNhbGwoaXQpKSkgcmV0dXJuIHZhbDtcbiAgaWYgKHR5cGVvZiAoZm4gPSBpdC52YWx1ZU9mKSA9PSAnZnVuY3Rpb24nICYmICFpc09iamVjdCh2YWwgPSBmbi5jYWxsKGl0KSkpIHJldHVybiB2YWw7XG4gIGlmICghUyAmJiB0eXBlb2YgKGZuID0gaXQudG9TdHJpbmcpID09ICdmdW5jdGlvbicgJiYgIWlzT2JqZWN0KHZhbCA9IGZuLmNhbGwoaXQpKSkgcmV0dXJuIHZhbDtcbiAgdGhyb3cgVHlwZUVycm9yKFwiQ2FuJ3QgY29udmVydCBvYmplY3QgdG8gcHJpbWl0aXZlIHZhbHVlXCIpO1xufTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCI2ZTIxXCI6XG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbi8vIHN0eWxlLWxvYWRlcjogQWRkcyBzb21lIGNzcyB0byB0aGUgRE9NIGJ5IGFkZGluZyBhIDxzdHlsZT4gdGFnXG5cbi8vIGxvYWQgdGhlIHN0eWxlc1xudmFyIGNvbnRlbnQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiOWNiZVwiKTtcbmlmKHR5cGVvZiBjb250ZW50ID09PSAnc3RyaW5nJykgY29udGVudCA9IFtbbW9kdWxlLmksIGNvbnRlbnQsICcnXV07XG5pZihjb250ZW50LmxvY2FscykgbW9kdWxlLmV4cG9ydHMgPSBjb250ZW50LmxvY2Fscztcbi8vIGFkZCB0aGUgc3R5bGVzIHRvIHRoZSBET01cbnZhciBhZGQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiNDk5ZVwiKS5kZWZhdWx0XG52YXIgdXBkYXRlID0gYWRkKFwiM2NiZDBjMjFcIiwgY29udGVudCwgdHJ1ZSwge1wic291cmNlTWFwXCI6ZmFsc2UsXCJzaGFkb3dNb2RlXCI6ZmFsc2V9KTtcblxuLyoqKi8gfSksXG5cbi8qKiovIFwiNzMzM1wiOlxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuLy8gMTkuMS4yLjEgT2JqZWN0LmFzc2lnbih0YXJnZXQsIHNvdXJjZSwgLi4uKVxudmFyIERFU0NSSVBUT1JTID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIjllMWVcIik7XG52YXIgZ2V0S2V5cyA9IF9fd2VicGFja19yZXF1aXJlX18oXCIwZDU4XCIpO1xudmFyIGdPUFMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiMjYyMVwiKTtcbnZhciBwSUUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiNTJhN1wiKTtcbnZhciB0b09iamVjdCA9IF9fd2VicGFja19yZXF1aXJlX18oXCI0YmY4XCIpO1xudmFyIElPYmplY3QgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiNjI2YVwiKTtcbnZhciAkYXNzaWduID0gT2JqZWN0LmFzc2lnbjtcblxuLy8gc2hvdWxkIHdvcmsgd2l0aCBzeW1ib2xzIGFuZCBzaG91bGQgaGF2ZSBkZXRlcm1pbmlzdGljIHByb3BlcnR5IG9yZGVyIChWOCBidWcpXG5tb2R1bGUuZXhwb3J0cyA9ICEkYXNzaWduIHx8IF9fd2VicGFja19yZXF1aXJlX18oXCI3OWU1XCIpKGZ1bmN0aW9uICgpIHtcbiAgdmFyIEEgPSB7fTtcbiAgdmFyIEIgPSB7fTtcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVuZGVmXG4gIHZhciBTID0gU3ltYm9sKCk7XG4gIHZhciBLID0gJ2FiY2RlZmdoaWprbG1ub3BxcnN0JztcbiAgQVtTXSA9IDc7XG4gIEsuc3BsaXQoJycpLmZvckVhY2goZnVuY3Rpb24gKGspIHsgQltrXSA9IGs7IH0pO1xuICByZXR1cm4gJGFzc2lnbih7fSwgQSlbU10gIT0gNyB8fCBPYmplY3Qua2V5cygkYXNzaWduKHt9LCBCKSkuam9pbignJykgIT0gSztcbn0pID8gZnVuY3Rpb24gYXNzaWduKHRhcmdldCwgc291cmNlKSB7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW51c2VkLXZhcnNcbiAgdmFyIFQgPSB0b09iamVjdCh0YXJnZXQpO1xuICB2YXIgYUxlbiA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gIHZhciBpbmRleCA9IDE7XG4gIHZhciBnZXRTeW1ib2xzID0gZ09QUy5mO1xuICB2YXIgaXNFbnVtID0gcElFLmY7XG4gIHdoaWxlIChhTGVuID4gaW5kZXgpIHtcbiAgICB2YXIgUyA9IElPYmplY3QoYXJndW1lbnRzW2luZGV4KytdKTtcbiAgICB2YXIga2V5cyA9IGdldFN5bWJvbHMgPyBnZXRLZXlzKFMpLmNvbmNhdChnZXRTeW1ib2xzKFMpKSA6IGdldEtleXMoUyk7XG4gICAgdmFyIGxlbmd0aCA9IGtleXMubGVuZ3RoO1xuICAgIHZhciBqID0gMDtcbiAgICB2YXIga2V5O1xuICAgIHdoaWxlIChsZW5ndGggPiBqKSB7XG4gICAgICBrZXkgPSBrZXlzW2orK107XG4gICAgICBpZiAoIURFU0NSSVBUT1JTIHx8IGlzRW51bS5jYWxsKFMsIGtleSkpIFRba2V5XSA9IFNba2V5XTtcbiAgICB9XG4gIH0gcmV0dXJuIFQ7XG59IDogJGFzc2lnbjtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCI3NzI2XCI6XG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS96bG9pcm9jay9jb3JlLWpzL2lzc3Vlcy84NiNpc3N1ZWNvbW1lbnQtMTE1NzU5MDI4XG52YXIgZ2xvYmFsID0gbW9kdWxlLmV4cG9ydHMgPSB0eXBlb2Ygd2luZG93ICE9ICd1bmRlZmluZWQnICYmIHdpbmRvdy5NYXRoID09IE1hdGhcbiAgPyB3aW5kb3cgOiB0eXBlb2Ygc2VsZiAhPSAndW5kZWZpbmVkJyAmJiBzZWxmLk1hdGggPT0gTWF0aCA/IHNlbGZcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLW5ldy1mdW5jXG4gIDogRnVuY3Rpb24oJ3JldHVybiB0aGlzJykoKTtcbmlmICh0eXBlb2YgX19nID09ICdudW1iZXInKSBfX2cgPSBnbG9iYWw7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW5kZWZcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCI3N2YxXCI6XG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbnZhciB0b0ludGVnZXIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiNDU4OFwiKTtcbnZhciBtYXggPSBNYXRoLm1heDtcbnZhciBtaW4gPSBNYXRoLm1pbjtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGluZGV4LCBsZW5ndGgpIHtcbiAgaW5kZXggPSB0b0ludGVnZXIoaW5kZXgpO1xuICByZXR1cm4gaW5kZXggPCAwID8gbWF4KGluZGV4ICsgbGVuZ3RoLCAwKSA6IG1pbihpbmRleCwgbGVuZ3RoKTtcbn07XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiNzllNVwiOlxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChleGVjKSB7XG4gIHRyeSB7XG4gICAgcmV0dXJuICEhZXhlYygpO1xuICB9IGNhdGNoIChlKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbn07XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiN2YyMFwiOlxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG52YXIgZGVmID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIjg2Y2NcIikuZjtcbnZhciBoYXMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiNjlhOFwiKTtcbnZhciBUQUcgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiMmI0Y1wiKSgndG9TdHJpbmdUYWcnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXQsIHRhZywgc3RhdCkge1xuICBpZiAoaXQgJiYgIWhhcyhpdCA9IHN0YXQgPyBpdCA6IGl0LnByb3RvdHlwZSwgVEFHKSkgZGVmKGl0LCBUQUcsIHsgY29uZmlndXJhYmxlOiB0cnVlLCB2YWx1ZTogdGFnIH0pO1xufTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCI3ZjdmXCI6XG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbnZhciBkUCA9IF9fd2VicGFja19yZXF1aXJlX18oXCI4NmNjXCIpLmY7XG52YXIgRlByb3RvID0gRnVuY3Rpb24ucHJvdG90eXBlO1xudmFyIG5hbWVSRSA9IC9eXFxzKmZ1bmN0aW9uIChbXiAoXSopLztcbnZhciBOQU1FID0gJ25hbWUnO1xuXG4vLyAxOS4yLjQuMiBuYW1lXG5OQU1FIGluIEZQcm90byB8fCBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiOWUxZVwiKSAmJiBkUChGUHJvdG8sIE5BTUUsIHtcbiAgY29uZmlndXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuICgnJyArIHRoaXMpLm1hdGNoKG5hbWVSRSlbMV07XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgcmV0dXJuICcnO1xuICAgIH1cbiAgfVxufSk7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiODM3OFwiOlxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG52YXIgY29yZSA9IG1vZHVsZS5leHBvcnRzID0geyB2ZXJzaW9uOiAnMi42LjEyJyB9O1xuaWYgKHR5cGVvZiBfX2UgPT0gJ251bWJlcicpIF9fZSA9IGNvcmU7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW5kZWZcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCI4NGYyXCI6XG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cbm1vZHVsZS5leHBvcnRzID0ge307XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiODZjY1wiOlxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG52YXIgYW5PYmplY3QgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiY2I3Y1wiKTtcbnZhciBJRThfRE9NX0RFRklORSA9IF9fd2VicGFja19yZXF1aXJlX18oXCJjNjlhXCIpO1xudmFyIHRvUHJpbWl0aXZlID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIjZhOTlcIik7XG52YXIgZFAgPSBPYmplY3QuZGVmaW5lUHJvcGVydHk7XG5cbmV4cG9ydHMuZiA9IF9fd2VicGFja19yZXF1aXJlX18oXCI5ZTFlXCIpID8gT2JqZWN0LmRlZmluZVByb3BlcnR5IDogZnVuY3Rpb24gZGVmaW5lUHJvcGVydHkoTywgUCwgQXR0cmlidXRlcykge1xuICBhbk9iamVjdChPKTtcbiAgUCA9IHRvUHJpbWl0aXZlKFAsIHRydWUpO1xuICBhbk9iamVjdChBdHRyaWJ1dGVzKTtcbiAgaWYgKElFOF9ET01fREVGSU5FKSB0cnkge1xuICAgIHJldHVybiBkUChPLCBQLCBBdHRyaWJ1dGVzKTtcbiAgfSBjYXRjaCAoZSkgeyAvKiBlbXB0eSAqLyB9XG4gIGlmICgnZ2V0JyBpbiBBdHRyaWJ1dGVzIHx8ICdzZXQnIGluIEF0dHJpYnV0ZXMpIHRocm93IFR5cGVFcnJvcignQWNjZXNzb3JzIG5vdCBzdXBwb3J0ZWQhJyk7XG4gIGlmICgndmFsdWUnIGluIEF0dHJpYnV0ZXMpIE9bUF0gPSBBdHRyaWJ1dGVzLnZhbHVlO1xuICByZXR1cm4gTztcbn07XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiOGI5N1wiOlxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG4vLyBXb3JrcyB3aXRoIF9fcHJvdG9fXyBvbmx5LiBPbGQgdjggY2FuJ3Qgd29yayB3aXRoIG51bGwgcHJvdG8gb2JqZWN0cy5cbi8qIGVzbGludC1kaXNhYmxlIG5vLXByb3RvICovXG52YXIgaXNPYmplY3QgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiZDNmNFwiKTtcbnZhciBhbk9iamVjdCA9IF9fd2VicGFja19yZXF1aXJlX18oXCJjYjdjXCIpO1xudmFyIGNoZWNrID0gZnVuY3Rpb24gKE8sIHByb3RvKSB7XG4gIGFuT2JqZWN0KE8pO1xuICBpZiAoIWlzT2JqZWN0KHByb3RvKSAmJiBwcm90byAhPT0gbnVsbCkgdGhyb3cgVHlwZUVycm9yKHByb3RvICsgXCI6IGNhbid0IHNldCBhcyBwcm90b3R5cGUhXCIpO1xufTtcbm1vZHVsZS5leHBvcnRzID0ge1xuICBzZXQ6IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fCAoJ19fcHJvdG9fXycgaW4ge30gPyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lXG4gICAgZnVuY3Rpb24gKHRlc3QsIGJ1Z2d5LCBzZXQpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHNldCA9IF9fd2VicGFja19yZXF1aXJlX18oXCI5YjQzXCIpKEZ1bmN0aW9uLmNhbGwsIF9fd2VicGFja19yZXF1aXJlX18oXCIxMWU5XCIpLmYoT2JqZWN0LnByb3RvdHlwZSwgJ19fcHJvdG9fXycpLnNldCwgMik7XG4gICAgICAgIHNldCh0ZXN0LCBbXSk7XG4gICAgICAgIGJ1Z2d5ID0gISh0ZXN0IGluc3RhbmNlb2YgQXJyYXkpO1xuICAgICAgfSBjYXRjaCAoZSkgeyBidWdneSA9IHRydWU7IH1cbiAgICAgIHJldHVybiBmdW5jdGlvbiBzZXRQcm90b3R5cGVPZihPLCBwcm90bykge1xuICAgICAgICBjaGVjayhPLCBwcm90byk7XG4gICAgICAgIGlmIChidWdneSkgTy5fX3Byb3RvX18gPSBwcm90bztcbiAgICAgICAgZWxzZSBzZXQoTywgcHJvdG8pO1xuICAgICAgICByZXR1cm4gTztcbiAgICAgIH07XG4gICAgfSh7fSwgZmFsc2UpIDogdW5kZWZpbmVkKSxcbiAgY2hlY2s6IGNoZWNrXG59O1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIjhiYmZcIjpcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwidnVlXCIpO1xuXG4vKioqLyB9KSxcblxuLyoqKi8gXCI4ZTZlXCI6XG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS90YzM5L3Byb3Bvc2FsLW9iamVjdC1nZXRvd25wcm9wZXJ0eWRlc2NyaXB0b3JzXG52YXIgJGV4cG9ydCA9IF9fd2VicGFja19yZXF1aXJlX18oXCI1Y2ExXCIpO1xudmFyIG93bktleXMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiOTkwYlwiKTtcbnZhciB0b0lPYmplY3QgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiNjgyMVwiKTtcbnZhciBnT1BEID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIjExZTlcIik7XG52YXIgY3JlYXRlUHJvcGVydHkgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiZjFhZVwiKTtcblxuJGV4cG9ydCgkZXhwb3J0LlMsICdPYmplY3QnLCB7XG4gIGdldE93blByb3BlcnR5RGVzY3JpcHRvcnM6IGZ1bmN0aW9uIGdldE93blByb3BlcnR5RGVzY3JpcHRvcnMob2JqZWN0KSB7XG4gICAgdmFyIE8gPSB0b0lPYmplY3Qob2JqZWN0KTtcbiAgICB2YXIgZ2V0RGVzYyA9IGdPUEQuZjtcbiAgICB2YXIga2V5cyA9IG93bktleXMoTyk7XG4gICAgdmFyIHJlc3VsdCA9IHt9O1xuICAgIHZhciBpID0gMDtcbiAgICB2YXIga2V5LCBkZXNjO1xuICAgIHdoaWxlIChrZXlzLmxlbmd0aCA+IGkpIHtcbiAgICAgIGRlc2MgPSBnZXREZXNjKE8sIGtleSA9IGtleXNbaSsrXSk7XG4gICAgICBpZiAoZGVzYyAhPT0gdW5kZWZpbmVkKSBjcmVhdGVQcm9wZXJ0eShyZXN1bHQsIGtleSwgZGVzYyk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbn0pO1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIjkwOTNcIjpcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuLy8gMTkuMS4yLjcgLyAxNS4yLjMuNCBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhPKVxudmFyICRrZXlzID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcImNlMTBcIik7XG52YXIgaGlkZGVuS2V5cyA9IF9fd2VicGFja19yZXF1aXJlX18oXCJlMTFlXCIpLmNvbmNhdCgnbGVuZ3RoJywgJ3Byb3RvdHlwZScpO1xuXG5leHBvcnRzLmYgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyB8fCBmdW5jdGlvbiBnZXRPd25Qcm9wZXJ0eU5hbWVzKE8pIHtcbiAgcmV0dXJuICRrZXlzKE8sIGhpZGRlbktleXMpO1xufTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCI5N2E3XCI6XG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuLyogaGFybW9ueSBleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcImJcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBnZXRCcmVha3BvaW50RnJvbVdpZHRoOyB9KTtcbi8qIGhhcm1vbnkgZXhwb3J0IChiaW5kaW5nKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXCJjXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gZ2V0Q29sc0Zyb21CcmVha3BvaW50OyB9KTtcbi8qIGhhcm1vbnkgZXhwb3J0IChiaW5kaW5nKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXCJhXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gZmluZE9yR2VuZXJhdGVSZXNwb25zaXZlTGF5b3V0OyB9KTtcbi8qIHVudXNlZCBoYXJtb255IGV4cG9ydCBnZW5lcmF0ZVJlc3BvbnNpdmVMYXlvdXQgKi9cbi8qIHVudXNlZCBoYXJtb255IGV4cG9ydCBzb3J0QnJlYWtwb2ludHMgKi9cbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBjb3JlX2pzX21vZHVsZXNfZXM2X2FycmF5X3NvcnRfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXyA9IF9fd2VicGFja19yZXF1aXJlX18oXCI1NWRkXCIpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIGNvcmVfanNfbW9kdWxlc19lczZfYXJyYXlfc29ydF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fX2RlZmF1bHQgPSAvKiNfX1BVUkVfXyovX193ZWJwYWNrX3JlcXVpcmVfXy5uKGNvcmVfanNfbW9kdWxlc19lczZfYXJyYXlfc29ydF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBjb3JlX2pzX21vZHVsZXNfd2ViX2RvbV9pdGVyYWJsZV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcImFjNmFcIik7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgY29yZV9qc19tb2R1bGVzX3dlYl9kb21faXRlcmFibGVfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX19kZWZhdWx0ID0gLyojX19QVVJFX18qL19fd2VicGFja19yZXF1aXJlX18ubihjb3JlX2pzX21vZHVsZXNfd2ViX2RvbV9pdGVyYWJsZV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBjb3JlX2pzX21vZHVsZXNfZXM2X2FycmF5X2l0ZXJhdG9yX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiY2FkZlwiKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBjb3JlX2pzX21vZHVsZXNfZXM2X2FycmF5X2l0ZXJhdG9yX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX19fZGVmYXVsdCA9IC8qI19fUFVSRV9fKi9fX3dlYnBhY2tfcmVxdWlyZV9fLm4oY29yZV9qc19tb2R1bGVzX2VzNl9hcnJheV9pdGVyYXRvcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBjb3JlX2pzX21vZHVsZXNfZXM2X29iamVjdF9rZXlzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiNDU2ZFwiKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBjb3JlX2pzX21vZHVsZXNfZXM2X29iamVjdF9rZXlzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX19fZGVmYXVsdCA9IC8qI19fUFVSRV9fKi9fX3dlYnBhY2tfcmVxdWlyZV9fLm4oY29yZV9qc19tb2R1bGVzX2VzNl9vYmplY3Rfa2V5c19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfdXRpbHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzRfXyA9IF9fd2VicGFja19yZXF1aXJlX18oXCJhMmI2XCIpO1xuXG5cblxuXG4vLyBAZmxvd1xuXG5cbi8qOjogaW1wb3J0IHR5cGUge0xheW91dH0gZnJvbSAnLi91dGlscyc7Ki9cblxuLyo6OiBleHBvcnQgdHlwZSBSZXNwb25zaXZlTGF5b3V0ID0ge2xnPzogTGF5b3V0LCBtZD86IExheW91dCwgc20/OiBMYXlvdXQsIHhzPzogTGF5b3V0LCB4eHM/OiBMYXlvdXR9OyovXG5cbi8qOjogdHlwZSBCcmVha3BvaW50ID0gc3RyaW5nOyovXG5cbi8qKlxyXG4gKiBHaXZlbiBhIHdpZHRoLCBmaW5kIHRoZSBoaWdoZXN0IGJyZWFrcG9pbnQgdGhhdCBtYXRjaGVzIGlzIHZhbGlkIGZvciBpdCAod2lkdGggPiBicmVha3BvaW50KS5cclxuICpcclxuICogQHBhcmFtICB7T2JqZWN0fSBicmVha3BvaW50cyBCcmVha3BvaW50cyBvYmplY3QgKGUuZy4ge2xnOiAxMjAwLCBtZDogOTYwLCAuLi59KVxyXG4gKiBAcGFyYW0gIHtOdW1iZXJ9IHdpZHRoIFNjcmVlbiB3aWR0aC5cclxuICogQHJldHVybiB7U3RyaW5nfSAgICAgICBIaWdoZXN0IGJyZWFrcG9pbnQgdGhhdCBpcyBsZXNzIHRoYW4gd2lkdGguXHJcbiAqL1xuXG4vKjo6IHR5cGUgQnJlYWtwb2ludHMgPSB7bGc/OiBudW1iZXIsIG1kPzogbnVtYmVyLCBzbT86IG51bWJlciwgeHM/OiBudW1iZXIsIHh4cz86IG51bWJlcn07Ki9cblxuZnVuY3Rpb24gZ2V0QnJlYWtwb2ludEZyb21XaWR0aChicmVha3BvaW50c1xuLyo6IEJyZWFrcG9pbnRzKi9cbiwgd2lkdGhcbi8qOiBudW1iZXIqL1xuKVxuLyo6IEJyZWFrcG9pbnQqL1xue1xuICB2YXIgc29ydGVkID0gc29ydEJyZWFrcG9pbnRzKGJyZWFrcG9pbnRzKTtcbiAgdmFyIG1hdGNoaW5nID0gc29ydGVkWzBdO1xuXG4gIGZvciAodmFyIGkgPSAxLCBsZW4gPSBzb3J0ZWQubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICB2YXIgYnJlYWtwb2ludE5hbWUgPSBzb3J0ZWRbaV07XG4gICAgaWYgKHdpZHRoID4gYnJlYWtwb2ludHNbYnJlYWtwb2ludE5hbWVdKSBtYXRjaGluZyA9IGJyZWFrcG9pbnROYW1lO1xuICB9XG5cbiAgcmV0dXJuIG1hdGNoaW5nO1xufVxuLyoqXHJcbiAqIEdpdmVuIGEgYnJlYWtwb2ludCwgZ2V0IHRoZSAjIG9mIGNvbHMgc2V0IGZvciBpdC5cclxuICogQHBhcmFtICB7U3RyaW5nfSBicmVha3BvaW50IEJyZWFrcG9pbnQgbmFtZS5cclxuICogQHBhcmFtICB7T2JqZWN0fSBjb2xzICAgICAgIE1hcCBvZiBicmVha3BvaW50cyB0byBjb2xzLlxyXG4gKiBAcmV0dXJuIHtOdW1iZXJ9ICAgICAgICAgICAgTnVtYmVyIG9mIGNvbHMuXHJcbiAqL1xuXG5mdW5jdGlvbiBnZXRDb2xzRnJvbUJyZWFrcG9pbnQoYnJlYWtwb2ludFxuLyo6IEJyZWFrcG9pbnQqL1xuLCBjb2xzXG4vKjogQnJlYWtwb2ludHMqL1xuKVxuLyo6IG51bWJlciovXG57XG4gIGlmICghY29sc1ticmVha3BvaW50XSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIlJlc3BvbnNpdmVHcmlkTGF5b3V0OiBgY29sc2AgZW50cnkgZm9yIGJyZWFrcG9pbnQgXCIgKyBicmVha3BvaW50ICsgXCIgaXMgbWlzc2luZyFcIik7XG4gIH1cblxuICByZXR1cm4gY29sc1ticmVha3BvaW50XTtcbn1cbi8qKlxyXG4gKiBHaXZlbiBleGlzdGluZyBsYXlvdXRzIGFuZCBhIG5ldyBicmVha3BvaW50LCBmaW5kIG9yIGdlbmVyYXRlIGEgbmV3IGxheW91dC5cclxuICpcclxuICogVGhpcyBmaW5kcyB0aGUgbGF5b3V0IGFib3ZlIHRoZSBuZXcgb25lIGFuZCBnZW5lcmF0ZXMgZnJvbSBpdCwgaWYgaXQgZXhpc3RzLlxyXG4gKlxyXG4gKiBAcGFyYW0gIHtBcnJheX0gb3JnTGF5b3V0ICAgICBPcmlnaW5hbCBsYXlvdXQuXHJcbiAqIEBwYXJhbSAge09iamVjdH0gbGF5b3V0cyAgICAgRXhpc3RpbmcgbGF5b3V0cy5cclxuICogQHBhcmFtICB7QXJyYXl9IGJyZWFrcG9pbnRzIEFsbCBicmVha3BvaW50cy5cclxuICogQHBhcmFtICB7U3RyaW5nfSBicmVha3BvaW50IE5ldyBicmVha3BvaW50LlxyXG4gKiBAcGFyYW0gIHtTdHJpbmd9IGJyZWFrcG9pbnQgTGFzdCBicmVha3BvaW50IChmb3IgZmFsbGJhY2spLlxyXG4gKiBAcGFyYW0gIHtOdW1iZXJ9IGNvbHMgICAgICAgQ29sdW1uIGNvdW50IGF0IG5ldyBicmVha3BvaW50LlxyXG4gKiBAcGFyYW0gIHtCb29sZWFufSB2ZXJ0aWNhbENvbXBhY3QgV2hldGhlciBvciBub3QgdG8gY29tcGFjdCB0aGUgbGF5b3V0XHJcbiAqICAgdmVydGljYWxseS5cclxuICogQHJldHVybiB7QXJyYXl9ICAgICAgICAgICAgIE5ldyBsYXlvdXQuXHJcbiAqL1xuXG5mdW5jdGlvbiBmaW5kT3JHZW5lcmF0ZVJlc3BvbnNpdmVMYXlvdXQob3JnTGF5b3V0XG4vKjogTGF5b3V0Ki9cbiwgbGF5b3V0c1xuLyo6IFJlc3BvbnNpdmVMYXlvdXQqL1xuLCBicmVha3BvaW50c1xuLyo6IEJyZWFrcG9pbnRzKi9cbiwgYnJlYWtwb2ludFxuLyo6IEJyZWFrcG9pbnQqL1xuLCBsYXN0QnJlYWtwb2ludFxuLyo6IEJyZWFrcG9pbnQqL1xuLCBjb2xzXG4vKjogbnVtYmVyKi9cbiwgdmVydGljYWxDb21wYWN0XG4vKjogYm9vbGVhbiovXG4pXG4vKjogTGF5b3V0Ki9cbntcbiAgLy8gSWYgaXQgYWxyZWFkeSBleGlzdHMsIGp1c3QgcmV0dXJuIGl0LlxuICBpZiAobGF5b3V0c1ticmVha3BvaW50XSkgcmV0dXJuIE9iamVjdChfdXRpbHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzRfX1svKiBjbG9uZUxheW91dCAqLyBcImJcIl0pKGxheW91dHNbYnJlYWtwb2ludF0pOyAvLyBGaW5kIG9yIGdlbmVyYXRlIHRoZSBuZXh0IGxheW91dFxuXG4gIHZhciBsYXlvdXQgPSBvcmdMYXlvdXQ7XG4gIHZhciBicmVha3BvaW50c1NvcnRlZCA9IHNvcnRCcmVha3BvaW50cyhicmVha3BvaW50cyk7XG4gIHZhciBicmVha3BvaW50c0Fib3ZlID0gYnJlYWtwb2ludHNTb3J0ZWQuc2xpY2UoYnJlYWtwb2ludHNTb3J0ZWQuaW5kZXhPZihicmVha3BvaW50KSk7XG5cbiAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IGJyZWFrcG9pbnRzQWJvdmUubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICB2YXIgYiA9IGJyZWFrcG9pbnRzQWJvdmVbaV07XG5cbiAgICBpZiAobGF5b3V0c1tiXSkge1xuICAgICAgbGF5b3V0ID0gbGF5b3V0c1tiXTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuXG4gIGxheW91dCA9IE9iamVjdChfdXRpbHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzRfX1svKiBjbG9uZUxheW91dCAqLyBcImJcIl0pKGxheW91dCB8fCBbXSk7IC8vIGNsb25lIGxheW91dCBzbyB3ZSBkb24ndCBtb2RpZnkgZXhpc3RpbmcgaXRlbXNcblxuICByZXR1cm4gT2JqZWN0KF91dGlsc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNF9fWy8qIGNvbXBhY3QgKi8gXCJjXCJdKShPYmplY3QoX3V0aWxzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV80X19bLyogY29ycmVjdEJvdW5kcyAqLyBcImRcIl0pKGxheW91dCwge1xuICAgIGNvbHM6IGNvbHNcbiAgfSksIHZlcnRpY2FsQ29tcGFjdCk7XG59XG5mdW5jdGlvbiBnZW5lcmF0ZVJlc3BvbnNpdmVMYXlvdXQobGF5b3V0XG4vKjogTGF5b3V0Ki9cbiwgYnJlYWtwb2ludHNcbi8qOiBCcmVha3BvaW50cyovXG4sIGJyZWFrcG9pbnRcbi8qOiBCcmVha3BvaW50Ki9cbiwgbGFzdEJyZWFrcG9pbnRcbi8qOiBCcmVha3BvaW50Ki9cbiwgY29sc1xuLyo6IG51bWJlciovXG4sIHZlcnRpY2FsQ29tcGFjdFxuLyo6IGJvb2xlYW4qL1xuKVxuLyo6IExheW91dCovXG57XG4gIC8vIElmIGl0IGFscmVhZHkgZXhpc3RzLCBqdXN0IHJldHVybiBpdC5cblxuICAvKmlmIChsYXlvdXRzW2JyZWFrcG9pbnRdKSByZXR1cm4gY2xvbmVMYXlvdXQobGF5b3V0c1ticmVha3BvaW50XSk7XHJcbiAgLy8gRmluZCBvciBnZW5lcmF0ZSB0aGUgbmV4dCBsYXlvdXRcclxuICBsZXQgbGF5b3V0ID0gbGF5b3V0c1tsYXN0QnJlYWtwb2ludF07Ki9cblxuICAvKmNvbnN0IGJyZWFrcG9pbnRzU29ydGVkID0gc29ydEJyZWFrcG9pbnRzKGJyZWFrcG9pbnRzKTtcclxuICBjb25zdCBicmVha3BvaW50c0Fib3ZlID0gYnJlYWtwb2ludHNTb3J0ZWQuc2xpY2UoYnJlYWtwb2ludHNTb3J0ZWQuaW5kZXhPZihicmVha3BvaW50KSk7XHJcbiAgZm9yIChsZXQgaSA9IDAsIGxlbiA9IGJyZWFrcG9pbnRzQWJvdmUubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcclxuICBjb25zdCBiID0gYnJlYWtwb2ludHNBYm92ZVtpXTtcclxuICBpZiAobGF5b3V0c1tiXSkge1xyXG4gICAgbGF5b3V0ID0gbGF5b3V0c1tiXTtcclxuICAgIGJyZWFrO1xyXG4gIH1cclxuICB9Ki9cbiAgbGF5b3V0ID0gT2JqZWN0KF91dGlsc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNF9fWy8qIGNsb25lTGF5b3V0ICovIFwiYlwiXSkobGF5b3V0IHx8IFtdKTsgLy8gY2xvbmUgbGF5b3V0IHNvIHdlIGRvbid0IG1vZGlmeSBleGlzdGluZyBpdGVtc1xuXG4gIHJldHVybiBPYmplY3QoX3V0aWxzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV80X19bLyogY29tcGFjdCAqLyBcImNcIl0pKE9iamVjdChfdXRpbHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzRfX1svKiBjb3JyZWN0Qm91bmRzICovIFwiZFwiXSkobGF5b3V0LCB7XG4gICAgY29sczogY29sc1xuICB9KSwgdmVydGljYWxDb21wYWN0KTtcbn1cbi8qKlxyXG4gKiBHaXZlbiBicmVha3BvaW50cywgcmV0dXJuIGFuIGFycmF5IG9mIGJyZWFrcG9pbnRzIHNvcnRlZCBieSB3aWR0aC4gVGhpcyBpcyB1c3VhbGx5XHJcbiAqIGUuZy4gWyd4eHMnLCAneHMnLCAnc20nLCAuLi5dXHJcbiAqXHJcbiAqIEBwYXJhbSAge09iamVjdH0gYnJlYWtwb2ludHMgS2V5L3ZhbHVlIHBhaXIgb2YgYnJlYWtwb2ludCBuYW1lcyB0byB3aWR0aHMuXHJcbiAqIEByZXR1cm4ge0FycmF5fSAgICAgICAgICAgICAgU29ydGVkIGJyZWFrcG9pbnRzLlxyXG4gKi9cblxuZnVuY3Rpb24gc29ydEJyZWFrcG9pbnRzKGJyZWFrcG9pbnRzXG4vKjogQnJlYWtwb2ludHMqL1xuKVxuLyo6IEFycmF5PEJyZWFrcG9pbnQ+Ki9cbntcbiAgdmFyIGtleXNcbiAgLyo6IEFycmF5PHN0cmluZz4qL1xuICA9IE9iamVjdC5rZXlzKGJyZWFrcG9pbnRzKTtcbiAgcmV0dXJuIGtleXMuc29ydChmdW5jdGlvbiAoYSwgYikge1xuICAgIHJldHVybiBicmVha3BvaW50c1thXSAtIGJyZWFrcG9pbnRzW2JdO1xuICB9KTtcbn1cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiOTkwYlwiOlxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG4vLyBhbGwgb2JqZWN0IGtleXMsIGluY2x1ZGVzIG5vbi1lbnVtZXJhYmxlIGFuZCBzeW1ib2xzXG52YXIgZ09QTiA9IF9fd2VicGFja19yZXF1aXJlX18oXCI5MDkzXCIpO1xudmFyIGdPUFMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiMjYyMVwiKTtcbnZhciBhbk9iamVjdCA9IF9fd2VicGFja19yZXF1aXJlX18oXCJjYjdjXCIpO1xudmFyIFJlZmxlY3QgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiNzcyNlwiKS5SZWZsZWN0O1xubW9kdWxlLmV4cG9ydHMgPSBSZWZsZWN0ICYmIFJlZmxlY3Qub3duS2V5cyB8fCBmdW5jdGlvbiBvd25LZXlzKGl0KSB7XG4gIHZhciBrZXlzID0gZ09QTi5mKGFuT2JqZWN0KGl0KSk7XG4gIHZhciBnZXRTeW1ib2xzID0gZ09QUy5mO1xuICByZXR1cm4gZ2V0U3ltYm9scyA/IGtleXMuY29uY2F0KGdldFN5bWJvbHMoaXQpKSA6IGtleXM7XG59O1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIjliNDNcIjpcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuLy8gb3B0aW9uYWwgLyBzaW1wbGUgY29udGV4dCBiaW5kaW5nXG52YXIgYUZ1bmN0aW9uID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcImQ4ZThcIik7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChmbiwgdGhhdCwgbGVuZ3RoKSB7XG4gIGFGdW5jdGlvbihmbik7XG4gIGlmICh0aGF0ID09PSB1bmRlZmluZWQpIHJldHVybiBmbjtcbiAgc3dpdGNoIChsZW5ndGgpIHtcbiAgICBjYXNlIDE6IHJldHVybiBmdW5jdGlvbiAoYSkge1xuICAgICAgcmV0dXJuIGZuLmNhbGwodGhhdCwgYSk7XG4gICAgfTtcbiAgICBjYXNlIDI6IHJldHVybiBmdW5jdGlvbiAoYSwgYikge1xuICAgICAgcmV0dXJuIGZuLmNhbGwodGhhdCwgYSwgYik7XG4gICAgfTtcbiAgICBjYXNlIDM6IHJldHVybiBmdW5jdGlvbiAoYSwgYiwgYykge1xuICAgICAgcmV0dXJuIGZuLmNhbGwodGhhdCwgYSwgYiwgYyk7XG4gICAgfTtcbiAgfVxuICByZXR1cm4gZnVuY3Rpb24gKC8qIC4uLmFyZ3MgKi8pIHtcbiAgICByZXR1cm4gZm4uYXBwbHkodGhhdCwgYXJndW1lbnRzKTtcbiAgfTtcbn07XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiOWM2Y1wiOlxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG4vLyAyMi4xLjMuMzEgQXJyYXkucHJvdG90eXBlW0BAdW5zY29wYWJsZXNdXG52YXIgVU5TQ09QQUJMRVMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiMmI0Y1wiKSgndW5zY29wYWJsZXMnKTtcbnZhciBBcnJheVByb3RvID0gQXJyYXkucHJvdG90eXBlO1xuaWYgKEFycmF5UHJvdG9bVU5TQ09QQUJMRVNdID09IHVuZGVmaW5lZCkgX193ZWJwYWNrX3JlcXVpcmVfXyhcIjMyZTlcIikoQXJyYXlQcm90bywgVU5TQ09QQUJMRVMsIHt9KTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGtleSkge1xuICBBcnJheVByb3RvW1VOU0NPUEFCTEVTXVtrZXldID0gdHJ1ZTtcbn07XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiOWNiZVwiOlxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5leHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiMjM1MFwiKShmYWxzZSk7XG4vLyBpbXBvcnRzXG5cblxuLy8gbW9kdWxlXG5leHBvcnRzLnB1c2goW21vZHVsZS5pLCBcIi52dWUtZ3JpZC1pdGVtey13ZWJraXQtdHJhbnNpdGlvbjphbGwgLjJzIGVhc2U7dHJhbnNpdGlvbjphbGwgLjJzIGVhc2U7LXdlYmtpdC10cmFuc2l0aW9uLXByb3BlcnR5OmxlZnQsdG9wLHJpZ2h0O3RyYW5zaXRpb24tcHJvcGVydHk6bGVmdCx0b3AscmlnaHR9LnZ1ZS1ncmlkLWl0ZW0ubm8tdG91Y2h7LW1zLXRvdWNoLWFjdGlvbjpub25lO3RvdWNoLWFjdGlvbjpub25lfS52dWUtZ3JpZC1pdGVtLmNzc1RyYW5zZm9ybXN7LXdlYmtpdC10cmFuc2l0aW9uLXByb3BlcnR5Oi13ZWJraXQtdHJhbnNmb3JtO3RyYW5zaXRpb24tcHJvcGVydHk6LXdlYmtpdC10cmFuc2Zvcm07dHJhbnNpdGlvbi1wcm9wZXJ0eTp0cmFuc2Zvcm07dHJhbnNpdGlvbi1wcm9wZXJ0eTp0cmFuc2Zvcm0sLXdlYmtpdC10cmFuc2Zvcm07bGVmdDowO3JpZ2h0OmF1dG99LnZ1ZS1ncmlkLWl0ZW0uY3NzVHJhbnNmb3Jtcy5yZW5kZXItcnRse2xlZnQ6YXV0bztyaWdodDowfS52dWUtZ3JpZC1pdGVtLnJlc2l6aW5ne29wYWNpdHk6LjY7ei1pbmRleDozfS52dWUtZ3JpZC1pdGVtLnZ1ZS1kcmFnZ2FibGUtZHJhZ2dpbmd7LXdlYmtpdC10cmFuc2l0aW9uOm5vbmU7dHJhbnNpdGlvbjpub25lO3otaW5kZXg6M30udnVlLWdyaWQtaXRlbS52dWUtZ3JpZC1wbGFjZWhvbGRlcntiYWNrZ3JvdW5kOnJlZDtvcGFjaXR5Oi4yOy13ZWJraXQtdHJhbnNpdGlvbi1kdXJhdGlvbjouMXM7dHJhbnNpdGlvbi1kdXJhdGlvbjouMXM7ei1pbmRleDoyOy13ZWJraXQtdXNlci1zZWxlY3Q6bm9uZTstbW96LXVzZXItc2VsZWN0Om5vbmU7LW1zLXVzZXItc2VsZWN0Om5vbmU7LW8tdXNlci1zZWxlY3Q6bm9uZTt1c2VyLXNlbGVjdDpub25lfS52dWUtZ3JpZC1pdGVtPi52dWUtcmVzaXphYmxlLWhhbmRsZXtwb3NpdGlvbjphYnNvbHV0ZTt3aWR0aDoyMHB4O2hlaWdodDoyMHB4O2JvdHRvbTowO3JpZ2h0OjA7YmFja2dyb3VuZDp1cmwoXFxcImRhdGE6aW1hZ2Uvc3ZnK3htbDtiYXNlNjQsUEhOMlp5QnpkSGxzWlQwaVltRmphMmR5YjNWdVpDMWpiMnh2Y2pvalptWm1abVptTURBaUlIaHRiRzV6UFNKb2RIUndPaTh2ZDNkM0xuY3pMbTl5Wnk4eU1EQXdMM04yWnlJZ2QybGtkR2c5SWpZaUlHaGxhV2RvZEQwaU5pSStQSEJoZEdnZ1pEMGlUVFlnTmtnd1ZqUXVNbWcwTGpKV01FZzJkalo2SWlCdmNHRmphWFI1UFNJdU16QXlJaTgrUEM5emRtYytcXFwiKTtiYWNrZ3JvdW5kLXBvc2l0aW9uOjEwMCUgMTAwJTtwYWRkaW5nOjAgM3B4IDNweCAwO2JhY2tncm91bmQtcmVwZWF0Om5vLXJlcGVhdDtiYWNrZ3JvdW5kLW9yaWdpbjpjb250ZW50LWJveDstd2Via2l0LWJveC1zaXppbmc6Ym9yZGVyLWJveDtib3gtc2l6aW5nOmJvcmRlci1ib3g7Y3Vyc29yOnNlLXJlc2l6ZX0udnVlLWdyaWQtaXRlbT4udnVlLXJ0bC1yZXNpemFibGUtaGFuZGxle2JvdHRvbTowO2xlZnQ6MDtiYWNrZ3JvdW5kOnVybChkYXRhOmltYWdlL3N2Zyt4bWw7YmFzZTY0LFBITjJaeUIzYVdSMGFEMGlNVEFpSUdobGFXZG9kRDBpTVRBaUlIaHRiRzV6UFNKb2RIUndPaTh2ZDNkM0xuY3pMbTl5Wnk4eU1EQXdMM04yWnlJK1BIQmhkR2dnWm1sc2JEMGlibTl1WlNJZ1pEMGlUUzB4TFRGb01USjJNVEpJTFRGNklpOCtQR2MrUEhCaGRHZ2djM1J5YjJ0bExXeHBibVZqWVhBOUluVnVaR1ZtYVc1bFpDSWdjM1J5YjJ0bExXeHBibVZxYjJsdVBTSjFibVJsWm1sdVpXUWlJSE4wY205clpTMTNhV1IwYUQwaU1TNDFJaUJ6ZEhKdmEyVTlJaU13TURBaUlHWnBiR3c5SW01dmJtVWlJR1E5SWsweE5EUXVPREl4TFRNNExqTTVNMnd0TWpBdU16VTNMVE14TGpjNE5TSXZQanh3WVhSb0lITjBjbTlyWlQwaUl6WTJOaUlnYzNSeWIydGxMV3hwYm1WallYQTlJblZ1WkdWbWFXNWxaQ0lnYzNSeWIydGxMV3hwYm1WcWIybHVQU0oxYm1SbFptbHVaV1FpSUhOMGNtOXJaUzEzYVdSMGFEMGlNaUlnWm1sc2JEMGlibTl1WlNJZ1pEMGlUUzQ1TkRjdExqQXhPSFk1TGpFeU5VMHRMalkxTmlBNWFERXdMamN6SWk4K1BDOW5Qand2YzNablBnPT0pO2JhY2tncm91bmQtcG9zaXRpb246MCAxMDAlO3BhZGRpbmctbGVmdDozcHg7YmFja2dyb3VuZC1yZXBlYXQ6bm8tcmVwZWF0O2JhY2tncm91bmQtb3JpZ2luOmNvbnRlbnQtYm94O2N1cnNvcjpzdy1yZXNpemU7cmlnaHQ6YXV0b30udnVlLWdyaWQtaXRlbS5kaXNhYmxlLXVzZXJzZWxlY3R7LXdlYmtpdC11c2VyLXNlbGVjdDpub25lOy1tb3otdXNlci1zZWxlY3Q6bm9uZTstbXMtdXNlci1zZWxlY3Q6bm9uZTt1c2VyLXNlbGVjdDpub25lfVwiLCBcIlwiXSk7XG5cbi8vIGV4cG9ydHNcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCI5ZGVmXCI6XG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbi8vIDcuMS4xNSBUb0xlbmd0aFxudmFyIHRvSW50ZWdlciA9IF9fd2VicGFja19yZXF1aXJlX18oXCI0NTg4XCIpO1xudmFyIG1pbiA9IE1hdGgubWluO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXQpIHtcbiAgcmV0dXJuIGl0ID4gMCA/IG1pbih0b0ludGVnZXIoaXQpLCAweDFmZmZmZmZmZmZmZmZmKSA6IDA7IC8vIHBvdygyLCA1MykgLSAxID09IDkwMDcxOTkyNTQ3NDA5OTFcbn07XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiOWUxZVwiOlxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG4vLyBUaGFuaydzIElFOCBmb3IgaGlzIGZ1bm55IGRlZmluZVByb3BlcnR5XG5tb2R1bGUuZXhwb3J0cyA9ICFfX3dlYnBhY2tfcmVxdWlyZV9fKFwiNzllNVwiKShmdW5jdGlvbiAoKSB7XG4gIHJldHVybiBPYmplY3QuZGVmaW5lUHJvcGVydHkoe30sICdhJywgeyBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIDc7IH0gfSkuYSAhPSA3O1xufSk7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiYTJiNlwiOlxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX193ZWJwYWNrX2V4cG9ydHNfXywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcbi8qIGhhcm1vbnkgZXhwb3J0IChiaW5kaW5nKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXCJhXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gYm90dG9tOyB9KTtcbi8qIGhhcm1vbnkgZXhwb3J0IChiaW5kaW5nKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXCJiXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gY2xvbmVMYXlvdXQ7IH0pO1xuLyogdW51c2VkIGhhcm1vbnkgZXhwb3J0IGNsb25lTGF5b3V0SXRlbSAqL1xuLyogdW51c2VkIGhhcm1vbnkgZXhwb3J0IGNvbGxpZGVzICovXG4vKiBoYXJtb255IGV4cG9ydCAoYmluZGluZykgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwiY1wiLCBmdW5jdGlvbigpIHsgcmV0dXJuIGNvbXBhY3Q7IH0pO1xuLyogdW51c2VkIGhhcm1vbnkgZXhwb3J0IGNvbXBhY3RJdGVtICovXG4vKiBoYXJtb255IGV4cG9ydCAoYmluZGluZykgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwiZFwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIGNvcnJlY3RCb3VuZHM7IH0pO1xuLyogaGFybW9ueSBleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcImZcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBnZXRMYXlvdXRJdGVtOyB9KTtcbi8qIHVudXNlZCBoYXJtb255IGV4cG9ydCBnZXRGaXJzdENvbGxpc2lvbiAqL1xuLyogaGFybW9ueSBleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcImVcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBnZXRBbGxDb2xsaXNpb25zOyB9KTtcbi8qIHVudXNlZCBoYXJtb255IGV4cG9ydCBnZXRTdGF0aWNzICovXG4vKiBoYXJtb255IGV4cG9ydCAoYmluZGluZykgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwiZ1wiLCBmdW5jdGlvbigpIHsgcmV0dXJuIG1vdmVFbGVtZW50OyB9KTtcbi8qIHVudXNlZCBoYXJtb255IGV4cG9ydCBtb3ZlRWxlbWVudEF3YXlGcm9tQ29sbGlzaW9uICovXG4vKiB1bnVzZWQgaGFybW9ueSBleHBvcnQgcGVyYyAqL1xuLyogaGFybW9ueSBleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcImpcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBzZXRUcmFuc2Zvcm07IH0pO1xuLyogaGFybW9ueSBleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcImtcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBzZXRUcmFuc2Zvcm1SdGw7IH0pO1xuLyogaGFybW9ueSBleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcImhcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBzZXRUb3BMZWZ0OyB9KTtcbi8qIGhhcm1vbnkgZXhwb3J0IChiaW5kaW5nKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXCJpXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gc2V0VG9wUmlnaHQ7IH0pO1xuLyogdW51c2VkIGhhcm1vbnkgZXhwb3J0IHNvcnRMYXlvdXRJdGVtc0J5Um93Q29sICovXG4vKiBoYXJtb255IGV4cG9ydCAoYmluZGluZykgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwibFwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIHZhbGlkYXRlTGF5b3V0OyB9KTtcbi8qIHVudXNlZCBoYXJtb255IGV4cG9ydCBhdXRvQmluZEhhbmRsZXJzICovXG4vKiB1bnVzZWQgaGFybW9ueSBleHBvcnQgY3JlYXRlTWFya3VwICovXG4vKiB1bnVzZWQgaGFybW9ueSBleHBvcnQgSVNfVU5JVExFU1MgKi9cbi8qIHVudXNlZCBoYXJtb255IGV4cG9ydCBhZGRQeCAqL1xuLyogdW51c2VkIGhhcm1vbnkgZXhwb3J0IGh5cGhlbmF0ZVJFICovXG4vKiB1bnVzZWQgaGFybW9ueSBleHBvcnQgaHlwaGVuYXRlICovXG4vKiB1bnVzZWQgaGFybW9ueSBleHBvcnQgZmluZEl0ZW1JbkFycmF5ICovXG4vKiB1bnVzZWQgaGFybW9ueSBleHBvcnQgZmluZEFuZFJlbW92ZSAqL1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIGNvcmVfanNfbW9kdWxlc19lczZfcmVnZXhwX3JlcGxhY2VfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXyA9IF9fd2VicGFja19yZXF1aXJlX18oXCJhNDgxXCIpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIGNvcmVfanNfbW9kdWxlc19lczZfcmVnZXhwX3JlcGxhY2VfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX19kZWZhdWx0ID0gLyojX19QVVJFX18qL19fd2VicGFja19yZXF1aXJlX18ubihjb3JlX2pzX21vZHVsZXNfZXM2X3JlZ2V4cF9yZXBsYWNlX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18pO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIGNvcmVfanNfbW9kdWxlc19lczZfYXJyYXlfaXRlcmF0b3JfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfXyA9IF9fd2VicGFja19yZXF1aXJlX18oXCJjYWRmXCIpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIGNvcmVfanNfbW9kdWxlc19lczZfYXJyYXlfaXRlcmF0b3JfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX19kZWZhdWx0ID0gLyojX19QVVJFX18qL19fd2VicGFja19yZXF1aXJlX18ubihjb3JlX2pzX21vZHVsZXNfZXM2X2FycmF5X2l0ZXJhdG9yX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX18pO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIGNvcmVfanNfbW9kdWxlc19lczZfb2JqZWN0X2tleXNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfXyA9IF9fd2VicGFja19yZXF1aXJlX18oXCI0NTZkXCIpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIGNvcmVfanNfbW9kdWxlc19lczZfb2JqZWN0X2tleXNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfX19kZWZhdWx0ID0gLyojX19QVVJFX18qL19fd2VicGFja19yZXF1aXJlX18ubihjb3JlX2pzX21vZHVsZXNfZXM2X29iamVjdF9rZXlzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX18pO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIGNvcmVfanNfbW9kdWxlc193ZWJfZG9tX2l0ZXJhYmxlX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiYWM2YVwiKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBjb3JlX2pzX21vZHVsZXNfd2ViX2RvbV9pdGVyYWJsZV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fX2RlZmF1bHQgPSAvKiNfX1BVUkVfXyovX193ZWJwYWNrX3JlcXVpcmVfXy5uKGNvcmVfanNfbW9kdWxlc193ZWJfZG9tX2l0ZXJhYmxlX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX18pO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIGNvcmVfanNfbW9kdWxlc19lczZfYXJyYXlfc29ydF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIjU1ZGRcIik7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgY29yZV9qc19tb2R1bGVzX2VzNl9hcnJheV9zb3J0X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV80X19fZGVmYXVsdCA9IC8qI19fUFVSRV9fKi9fX3dlYnBhY2tfcmVxdWlyZV9fLm4oY29yZV9qc19tb2R1bGVzX2VzNl9hcnJheV9zb3J0X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV80X18pO1xuXG5cblxuXG5cbi8vIEBmbG93XG5cbi8qOjogZXhwb3J0IHR5cGUgTGF5b3V0SXRlbVJlcXVpcmVkID0ge3c6IG51bWJlciwgaDogbnVtYmVyLCB4OiBudW1iZXIsIHk6IG51bWJlciwgaTogc3RyaW5nfTsqL1xuXG4vKjo6IGV4cG9ydCB0eXBlIExheW91dEl0ZW0gPSBMYXlvdXRJdGVtUmVxdWlyZWQgJlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAge21pblc/OiBudW1iZXIsIG1pbkg/OiBudW1iZXIsIG1heFc/OiBudW1iZXIsIG1heEg/OiBudW1iZXIsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgbW92ZWQ/OiBib29sZWFuLCBzdGF0aWM/OiBib29sZWFuLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgIGlzRHJhZ2dhYmxlPzogP2Jvb2xlYW4sIGlzUmVzaXphYmxlPzogP2Jvb2xlYW59OyovXG5cbi8vIGV4cG9ydCB0eXBlIFBvc2l0aW9uID0ge2xlZnQ6IG51bWJlciwgdG9wOiBudW1iZXIsIHdpZHRoOiBudW1iZXIsIGhlaWdodDogbnVtYmVyfTtcblxuLypcclxuZXhwb3J0IHR5cGUgRHJhZ0NhbGxiYWNrRGF0YSA9IHtcclxuICBub2RlOiBIVE1MRWxlbWVudCxcclxuICB4OiBudW1iZXIsIHk6IG51bWJlcixcclxuICBkZWx0YVg6IG51bWJlciwgZGVsdGFZOiBudW1iZXIsXHJcbiAgbGFzdFg6IG51bWJlciwgbGFzdFk6IG51bWJlclxyXG59O1xyXG4qL1xuLy8gZXhwb3J0IHR5cGUgRHJhZ0V2ZW50ID0ge2U6IEV2ZW50fSAmIERyYWdDYWxsYmFja0RhdGE7XG5cbi8qOjogZXhwb3J0IHR5cGUgTGF5b3V0ID0gQXJyYXk8TGF5b3V0SXRlbT47Ki9cblxuLy8gZXhwb3J0IHR5cGUgUmVzaXplRXZlbnQgPSB7ZTogRXZlbnQsIG5vZGU6IEhUTUxFbGVtZW50LCBzaXplOiBTaXplfTtcbi8vIGNvbnN0IGlzUHJvZHVjdGlvbiA9IHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAncHJvZHVjdGlvbic7XG5cbi8qKlxyXG4gKiBSZXR1cm4gdGhlIGJvdHRvbSBjb29yZGluYXRlIG9mIHRoZSBsYXlvdXQuXHJcbiAqXHJcbiAqIEBwYXJhbSAge0FycmF5fSBsYXlvdXQgTGF5b3V0IGFycmF5LlxyXG4gKiBAcmV0dXJuIHtOdW1iZXJ9ICAgICAgIEJvdHRvbSBjb29yZGluYXRlLlxyXG4gKi9cblxuLyo6OiBleHBvcnQgdHlwZSBTaXplID0ge3dpZHRoOiBudW1iZXIsIGhlaWdodDogbnVtYmVyfTsqL1xuXG5mdW5jdGlvbiBib3R0b20obGF5b3V0XG4vKjogTGF5b3V0Ki9cbilcbi8qOiBudW1iZXIqL1xue1xuICB2YXIgbWF4ID0gMCxcbiAgICAgIGJvdHRvbVk7XG5cbiAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IGxheW91dC5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgIGJvdHRvbVkgPSBsYXlvdXRbaV0ueSArIGxheW91dFtpXS5oO1xuICAgIGlmIChib3R0b21ZID4gbWF4KSBtYXggPSBib3R0b21ZO1xuICB9XG5cbiAgcmV0dXJuIG1heDtcbn1cbmZ1bmN0aW9uIGNsb25lTGF5b3V0KGxheW91dFxuLyo6IExheW91dCovXG4pXG4vKjogTGF5b3V0Ki9cbntcbiAgdmFyIG5ld0xheW91dCA9IEFycmF5KGxheW91dC5sZW5ndGgpO1xuXG4gIGZvciAodmFyIGkgPSAwLCBsZW4gPSBsYXlvdXQubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICBuZXdMYXlvdXRbaV0gPSBjbG9uZUxheW91dEl0ZW0obGF5b3V0W2ldKTtcbiAgfVxuXG4gIHJldHVybiBuZXdMYXlvdXQ7XG59IC8vIEZhc3QgcGF0aCB0byBjbG9uaW5nLCBzaW5jZSB0aGlzIGlzIG1vbm9tb3JwaGljXG5cbmZ1bmN0aW9uIGNsb25lTGF5b3V0SXRlbShsYXlvdXRJdGVtXG4vKjogTGF5b3V0SXRlbSovXG4pXG4vKjogTGF5b3V0SXRlbSovXG57XG4gIC8qcmV0dXJuIHtcclxuICAgIHc6IGxheW91dEl0ZW0udywgaDogbGF5b3V0SXRlbS5oLCB4OiBsYXlvdXRJdGVtLngsIHk6IGxheW91dEl0ZW0ueSwgaTogbGF5b3V0SXRlbS5pLFxyXG4gICAgbWluVzogbGF5b3V0SXRlbS5taW5XLCBtYXhXOiBsYXlvdXRJdGVtLm1heFcsIG1pbkg6IGxheW91dEl0ZW0ubWluSCwgbWF4SDogbGF5b3V0SXRlbS5tYXhILFxyXG4gICAgbW92ZWQ6IEJvb2xlYW4obGF5b3V0SXRlbS5tb3ZlZCksIHN0YXRpYzogQm9vbGVhbihsYXlvdXRJdGVtLnN0YXRpYyksXHJcbiAgICAvLyBUaGVzZSBjYW4gYmUgbnVsbFxyXG4gICAgaXNEcmFnZ2FibGU6IGxheW91dEl0ZW0uaXNEcmFnZ2FibGUsIGlzUmVzaXphYmxlOiBsYXlvdXRJdGVtLmlzUmVzaXphYmxlXHJcbiAgfTsqL1xuICByZXR1cm4gSlNPTi5wYXJzZShKU09OLnN0cmluZ2lmeShsYXlvdXRJdGVtKSk7XG59XG4vKipcclxuICogR2l2ZW4gdHdvIGxheW91dGl0ZW1zLCBjaGVjayBpZiB0aGV5IGNvbGxpZGUuXHJcbiAqXHJcbiAqIEByZXR1cm4ge0Jvb2xlYW59ICAgVHJ1ZSBpZiBjb2xsaWRpbmcuXHJcbiAqL1xuXG5mdW5jdGlvbiBjb2xsaWRlcyhsMVxuLyo6IExheW91dEl0ZW0qL1xuLCBsMlxuLyo6IExheW91dEl0ZW0qL1xuKVxuLyo6IGJvb2xlYW4qL1xue1xuICBpZiAobDEgPT09IGwyKSByZXR1cm4gZmFsc2U7IC8vIHNhbWUgZWxlbWVudFxuXG4gIGlmIChsMS54ICsgbDEudyA8PSBsMi54KSByZXR1cm4gZmFsc2U7IC8vIGwxIGlzIGxlZnQgb2YgbDJcblxuICBpZiAobDEueCA+PSBsMi54ICsgbDIudykgcmV0dXJuIGZhbHNlOyAvLyBsMSBpcyByaWdodCBvZiBsMlxuXG4gIGlmIChsMS55ICsgbDEuaCA8PSBsMi55KSByZXR1cm4gZmFsc2U7IC8vIGwxIGlzIGFib3ZlIGwyXG5cbiAgaWYgKGwxLnkgPj0gbDIueSArIGwyLmgpIHJldHVybiBmYWxzZTsgLy8gbDEgaXMgYmVsb3cgbDJcblxuICByZXR1cm4gdHJ1ZTsgLy8gYm94ZXMgb3ZlcmxhcFxufVxuLyoqXHJcbiAqIEdpdmVuIGEgbGF5b3V0LCBjb21wYWN0IGl0LiBUaGlzIGludm9sdmVzIGdvaW5nIGRvd24gZWFjaCB5IGNvb3JkaW5hdGUgYW5kIHJlbW92aW5nIGdhcHNcclxuICogYmV0d2VlbiBpdGVtcy5cclxuICpcclxuICogQHBhcmFtICB7QXJyYXl9IGxheW91dCBMYXlvdXQuXHJcbiAqIEBwYXJhbSAge0Jvb2xlYW59IHZlcnRpY2FsQ29tcGFjdCBXaGV0aGVyIG9yIG5vdCB0byBjb21wYWN0IHRoZSBsYXlvdXRcclxuICogICB2ZXJ0aWNhbGx5LlxyXG4gKiBAcmV0dXJuIHtBcnJheX0gICAgICAgQ29tcGFjdGVkIExheW91dC5cclxuICovXG5cbmZ1bmN0aW9uIGNvbXBhY3QobGF5b3V0XG4vKjogTGF5b3V0Ki9cbiwgdmVydGljYWxDb21wYWN0XG4vKjogQm9vbGVhbiovXG4pXG4vKjogTGF5b3V0Ki9cbntcbiAgLy8gU3RhdGljcyBnbyBpbiB0aGUgY29tcGFyZVdpdGggYXJyYXkgcmlnaHQgYXdheSBzbyBpdGVtcyBmbG93IGFyb3VuZCB0aGVtLlxuICB2YXIgY29tcGFyZVdpdGggPSBnZXRTdGF0aWNzKGxheW91dCk7IC8vIFdlIGdvIHRocm91Z2ggdGhlIGl0ZW1zIGJ5IHJvdyBhbmQgY29sdW1uLlxuXG4gIHZhciBzb3J0ZWQgPSBzb3J0TGF5b3V0SXRlbXNCeVJvd0NvbChsYXlvdXQpOyAvLyBIb2xkaW5nIGZvciBuZXcgaXRlbXMuXG5cbiAgdmFyIG91dCA9IEFycmF5KGxheW91dC5sZW5ndGgpO1xuXG4gIGZvciAodmFyIGkgPSAwLCBsZW4gPSBzb3J0ZWQubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICB2YXIgbCA9IHNvcnRlZFtpXTsgLy8gRG9uJ3QgbW92ZSBzdGF0aWMgZWxlbWVudHNcblxuICAgIGlmICghbC5zdGF0aWMpIHtcbiAgICAgIGwgPSBjb21wYWN0SXRlbShjb21wYXJlV2l0aCwgbCwgdmVydGljYWxDb21wYWN0KTsgLy8gQWRkIHRvIGNvbXBhcmlzb24gYXJyYXkuIFdlIG9ubHkgY29sbGlkZSB3aXRoIGl0ZW1zIGJlZm9yZSB0aGlzIG9uZS5cbiAgICAgIC8vIFN0YXRpY3MgYXJlIGFscmVhZHkgaW4gdGhpcyBhcnJheS5cblxuICAgICAgY29tcGFyZVdpdGgucHVzaChsKTtcbiAgICB9IC8vIEFkZCB0byBvdXRwdXQgYXJyYXkgdG8gbWFrZSBzdXJlIHRoZXkgc3RpbGwgY29tZSBvdXQgaW4gdGhlIHJpZ2h0IG9yZGVyLlxuXG5cbiAgICBvdXRbbGF5b3V0LmluZGV4T2YobCldID0gbDsgLy8gQ2xlYXIgbW92ZWQgZmxhZywgaWYgaXQgZXhpc3RzLlxuXG4gICAgbC5tb3ZlZCA9IGZhbHNlO1xuICB9XG5cbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBDb21wYWN0IGFuIGl0ZW0gaW4gdGhlIGxheW91dC5cclxuICovXG5cbmZ1bmN0aW9uIGNvbXBhY3RJdGVtKGNvbXBhcmVXaXRoXG4vKjogTGF5b3V0Ki9cbiwgbFxuLyo6IExheW91dEl0ZW0qL1xuLCB2ZXJ0aWNhbENvbXBhY3Rcbi8qOiBib29sZWFuKi9cbilcbi8qOiBMYXlvdXRJdGVtKi9cbntcbiAgaWYgKHZlcnRpY2FsQ29tcGFjdCkge1xuICAgIC8vIE1vdmUgdGhlIGVsZW1lbnQgdXAgYXMgZmFyIGFzIGl0IGNhbiBnbyB3aXRob3V0IGNvbGxpZGluZy5cbiAgICB3aGlsZSAobC55ID4gMCAmJiAhZ2V0Rmlyc3RDb2xsaXNpb24oY29tcGFyZVdpdGgsIGwpKSB7XG4gICAgICBsLnktLTtcbiAgICB9XG4gIH0gLy8gTW92ZSBpdCBkb3duLCBhbmQga2VlcCBtb3ZpbmcgaXQgZG93biBpZiBpdCdzIGNvbGxpZGluZy5cblxuXG4gIHZhciBjb2xsaWRlcztcblxuICB3aGlsZSAoY29sbGlkZXMgPSBnZXRGaXJzdENvbGxpc2lvbihjb21wYXJlV2l0aCwgbCkpIHtcbiAgICBsLnkgPSBjb2xsaWRlcy55ICsgY29sbGlkZXMuaDtcbiAgfVxuXG4gIHJldHVybiBsO1xufVxuLyoqXHJcbiAqIEdpdmVuIGEgbGF5b3V0LCBtYWtlIHN1cmUgYWxsIGVsZW1lbnRzIGZpdCB3aXRoaW4gaXRzIGJvdW5kcy5cclxuICpcclxuICogQHBhcmFtICB7QXJyYXl9IGxheW91dCBMYXlvdXQgYXJyYXkuXHJcbiAqIEBwYXJhbSAge051bWJlcn0gYm91bmRzIE51bWJlciBvZiBjb2x1bW5zLlxyXG4gKi9cblxuZnVuY3Rpb24gY29ycmVjdEJvdW5kcyhsYXlvdXRcbi8qOiBMYXlvdXQqL1xuLCBib3VuZHNcbi8qOiB7Y29sczogbnVtYmVyfSovXG4pXG4vKjogTGF5b3V0Ki9cbntcbiAgdmFyIGNvbGxpZGVzV2l0aCA9IGdldFN0YXRpY3MobGF5b3V0KTtcblxuICBmb3IgKHZhciBpID0gMCwgbGVuID0gbGF5b3V0Lmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgdmFyIGwgPSBsYXlvdXRbaV07IC8vIE92ZXJmbG93cyByaWdodFxuXG4gICAgaWYgKGwueCArIGwudyA+IGJvdW5kcy5jb2xzKSBsLnggPSBib3VuZHMuY29scyAtIGwudzsgLy8gT3ZlcmZsb3dzIGxlZnRcblxuICAgIGlmIChsLnggPCAwKSB7XG4gICAgICBsLnggPSAwO1xuICAgICAgbC53ID0gYm91bmRzLmNvbHM7XG4gICAgfVxuXG4gICAgaWYgKCFsLnN0YXRpYykgY29sbGlkZXNXaXRoLnB1c2gobCk7ZWxzZSB7XG4gICAgICAvLyBJZiB0aGlzIGlzIHN0YXRpYyBhbmQgY29sbGlkZXMgd2l0aCBvdGhlciBzdGF0aWNzLCB3ZSBtdXN0IG1vdmUgaXQgZG93bi5cbiAgICAgIC8vIFdlIGhhdmUgdG8gZG8gc29tZXRoaW5nIG5pY2VyIHRoYW4ganVzdCBsZXR0aW5nIHRoZW0gb3ZlcmxhcC5cbiAgICAgIHdoaWxlIChnZXRGaXJzdENvbGxpc2lvbihjb2xsaWRlc1dpdGgsIGwpKSB7XG4gICAgICAgIGwueSsrO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBsYXlvdXQ7XG59XG4vKipcclxuICogR2V0IGEgbGF5b3V0IGl0ZW0gYnkgSUQuIFVzZWQgc28gd2UgY2FuIG92ZXJyaWRlIGxhdGVyIG9uIGlmIG5lY2Vzc2FyeS5cclxuICpcclxuICogQHBhcmFtICB7QXJyYXl9ICBsYXlvdXQgTGF5b3V0IGFycmF5LlxyXG4gKiBAcGFyYW0gIHtTdHJpbmd9IGlkICAgICBJRFxyXG4gKiBAcmV0dXJuIHtMYXlvdXRJdGVtfSAgICBJdGVtIGF0IElELlxyXG4gKi9cblxuZnVuY3Rpb24gZ2V0TGF5b3V0SXRlbShsYXlvdXRcbi8qOiBMYXlvdXQqL1xuLCBpZFxuLyo6IHN0cmluZyovXG4pXG4vKjogP0xheW91dEl0ZW0qL1xue1xuICBmb3IgKHZhciBpID0gMCwgbGVuID0gbGF5b3V0Lmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgaWYgKGxheW91dFtpXS5pID09PSBpZCkgcmV0dXJuIGxheW91dFtpXTtcbiAgfVxufVxuLyoqXHJcbiAqIFJldHVybnMgdGhlIGZpcnN0IGl0ZW0gdGhpcyBsYXlvdXQgY29sbGlkZXMgd2l0aC5cclxuICogSXQgZG9lc24ndCBhcHBlYXIgdG8gbWF0dGVyIHdoaWNoIG9yZGVyIHdlIGFwcHJvYWNoIHRoaXMgZnJvbSwgYWx0aG91Z2hcclxuICogcGVyaGFwcyB0aGF0IGlzIHRoZSB3cm9uZyB0aGluZyB0byBkby5cclxuICpcclxuICogQHBhcmFtICB7T2JqZWN0fSBsYXlvdXRJdGVtIExheW91dCBpdGVtLlxyXG4gKiBAcmV0dXJuIHtPYmplY3R8dW5kZWZpbmVkfSAgQSBjb2xsaWRpbmcgbGF5b3V0IGl0ZW0sIG9yIHVuZGVmaW5lZC5cclxuICovXG5cbmZ1bmN0aW9uIGdldEZpcnN0Q29sbGlzaW9uKGxheW91dFxuLyo6IExheW91dCovXG4sIGxheW91dEl0ZW1cbi8qOiBMYXlvdXRJdGVtKi9cbilcbi8qOiA/TGF5b3V0SXRlbSovXG57XG4gIGZvciAodmFyIGkgPSAwLCBsZW4gPSBsYXlvdXQubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICBpZiAoY29sbGlkZXMobGF5b3V0W2ldLCBsYXlvdXRJdGVtKSkgcmV0dXJuIGxheW91dFtpXTtcbiAgfVxufVxuZnVuY3Rpb24gZ2V0QWxsQ29sbGlzaW9ucyhsYXlvdXRcbi8qOiBMYXlvdXQqL1xuLCBsYXlvdXRJdGVtXG4vKjogTGF5b3V0SXRlbSovXG4pXG4vKjogQXJyYXk8TGF5b3V0SXRlbT4qL1xue1xuICByZXR1cm4gbGF5b3V0LmZpbHRlcihmdW5jdGlvbiAobCkge1xuICAgIHJldHVybiBjb2xsaWRlcyhsLCBsYXlvdXRJdGVtKTtcbiAgfSk7XG59XG4vKipcclxuICogR2V0IGFsbCBzdGF0aWMgZWxlbWVudHMuXHJcbiAqIEBwYXJhbSAge0FycmF5fSBsYXlvdXQgQXJyYXkgb2YgbGF5b3V0IG9iamVjdHMuXHJcbiAqIEByZXR1cm4ge0FycmF5fSAgICAgICAgQXJyYXkgb2Ygc3RhdGljIGxheW91dCBpdGVtcy4uXHJcbiAqL1xuXG5mdW5jdGlvbiBnZXRTdGF0aWNzKGxheW91dFxuLyo6IExheW91dCovXG4pXG4vKjogQXJyYXk8TGF5b3V0SXRlbT4qL1xue1xuICAvL3JldHVybiBbXTtcbiAgcmV0dXJuIGxheW91dC5maWx0ZXIoZnVuY3Rpb24gKGwpIHtcbiAgICByZXR1cm4gbC5zdGF0aWM7XG4gIH0pO1xufVxuLyoqXHJcbiAqIE1vdmUgYW4gZWxlbWVudC4gUmVzcG9uc2libGUgZm9yIGRvaW5nIGNhc2NhZGluZyBtb3ZlbWVudHMgb2Ygb3RoZXIgZWxlbWVudHMuXHJcbiAqXHJcbiAqIEBwYXJhbSAge0FycmF5fSAgICAgIGxheW91dCBGdWxsIGxheW91dCB0byBtb2RpZnkuXHJcbiAqIEBwYXJhbSAge0xheW91dEl0ZW19IGwgICAgICBlbGVtZW50IHRvIG1vdmUuXHJcbiAqIEBwYXJhbSAge051bWJlcn0gICAgIFt4XSAgICBYIHBvc2l0aW9uIGluIGdyaWQgdW5pdHMuXHJcbiAqIEBwYXJhbSAge051bWJlcn0gICAgIFt5XSAgICBZIHBvc2l0aW9uIGluIGdyaWQgdW5pdHMuXHJcbiAqIEBwYXJhbSAge0Jvb2xlYW59ICAgIFtpc1VzZXJBY3Rpb25dIElmIHRydWUsIGRlc2lnbmF0ZXMgdGhhdCB0aGUgaXRlbSB3ZSdyZSBtb3ZpbmcgaXNcclxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYmVpbmcgZHJhZ2dlZC9yZXNpemVkIGJ5IHRoIGV1c2VyLlxyXG4gKi9cblxuZnVuY3Rpb24gbW92ZUVsZW1lbnQobGF5b3V0XG4vKjogTGF5b3V0Ki9cbiwgbFxuLyo6IExheW91dEl0ZW0qL1xuLCB4XG4vKjogTnVtYmVyKi9cbiwgeVxuLyo6IE51bWJlciovXG4sIGlzVXNlckFjdGlvblxuLyo6IEJvb2xlYW4qL1xuLCBwcmV2ZW50Q29sbGlzaW9uXG4vKjogQm9vbGVhbiovXG4pXG4vKjogTGF5b3V0Ki9cbntcbiAgaWYgKGwuc3RhdGljKSByZXR1cm4gbGF5b3V0OyAvLyBTaG9ydC1jaXJjdWl0IGlmIG5vdGhpbmcgdG8gZG8uXG4gIC8vaWYgKGwueSA9PT0geSAmJiBsLnggPT09IHgpIHJldHVybiBsYXlvdXQ7XG5cbiAgdmFyIG9sZFggPSBsLng7XG4gIHZhciBvbGRZID0gbC55O1xuICB2YXIgbW92aW5nVXAgPSB5ICYmIGwueSA+IHk7IC8vIFRoaXMgaXMgcXVpdGUgYSBiaXQgZmFzdGVyIHRoYW4gZXh0ZW5kaW5nIHRoZSBvYmplY3RcblxuICBpZiAodHlwZW9mIHggPT09ICdudW1iZXInKSBsLnggPSB4O1xuICBpZiAodHlwZW9mIHkgPT09ICdudW1iZXInKSBsLnkgPSB5O1xuICBsLm1vdmVkID0gdHJ1ZTsgLy8gSWYgdGhpcyBjb2xsaWRlcyB3aXRoIGFueXRoaW5nLCBtb3ZlIGl0LlxuICAvLyBXaGVuIGRvaW5nIHRoaXMgY29tcGFyaXNvbiwgd2UgaGF2ZSB0byBzb3J0IHRoZSBpdGVtcyB3ZSBjb21wYXJlIHdpdGhcbiAgLy8gdG8gZW5zdXJlLCBpbiB0aGUgY2FzZSBvZiBtdWx0aXBsZSBjb2xsaXNpb25zLCB0aGF0IHdlJ3JlIGdldHRpbmcgdGhlXG4gIC8vIG5lYXJlc3QgY29sbGlzaW9uLlxuXG4gIHZhciBzb3J0ZWQgPSBzb3J0TGF5b3V0SXRlbXNCeVJvd0NvbChsYXlvdXQpO1xuICBpZiAobW92aW5nVXApIHNvcnRlZCA9IHNvcnRlZC5yZXZlcnNlKCk7XG4gIHZhciBjb2xsaXNpb25zID0gZ2V0QWxsQ29sbGlzaW9ucyhzb3J0ZWQsIGwpO1xuXG4gIGlmIChwcmV2ZW50Q29sbGlzaW9uICYmIGNvbGxpc2lvbnMubGVuZ3RoKSB7XG4gICAgbC54ID0gb2xkWDtcbiAgICBsLnkgPSBvbGRZO1xuICAgIGwubW92ZWQgPSBmYWxzZTtcbiAgICByZXR1cm4gbGF5b3V0O1xuICB9IC8vIE1vdmUgZWFjaCBpdGVtIHRoYXQgY29sbGlkZXMgYXdheSBmcm9tIHRoaXMgZWxlbWVudC5cblxuXG4gIGZvciAodmFyIGkgPSAwLCBsZW4gPSBjb2xsaXNpb25zLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgdmFyIGNvbGxpc2lvbiA9IGNvbGxpc2lvbnNbaV07IC8vIGNvbnNvbGUubG9nKCdyZXNvbHZpbmcgY29sbGlzaW9uIGJldHdlZW4nLCBsLmksICdhdCcsIGwueSwgJ2FuZCcsIGNvbGxpc2lvbi5pLCAnYXQnLCBjb2xsaXNpb24ueSk7XG4gICAgLy8gU2hvcnQgY2lyY3VpdCBzbyB3ZSBjYW4ndCBpbmZpbml0ZSBsb29wXG5cbiAgICBpZiAoY29sbGlzaW9uLm1vdmVkKSBjb250aW51ZTsgLy8gVGhpcyBtYWtlcyBpdCBmZWVsIGEgYml0IG1vcmUgcHJlY2lzZSBieSB3YWl0aW5nIHRvIHN3YXAgZm9yIGp1c3QgYSBiaXQgd2hlbiBtb3ZpbmcgdXAuXG5cbiAgICBpZiAobC55ID4gY29sbGlzaW9uLnkgJiYgbC55IC0gY29sbGlzaW9uLnkgPiBjb2xsaXNpb24uaCAvIDQpIGNvbnRpbnVlOyAvLyBEb24ndCBtb3ZlIHN0YXRpYyBpdGVtcyAtIHdlIGhhdmUgdG8gbW92ZSAqdGhpcyogZWxlbWVudCBhd2F5XG5cbiAgICBpZiAoY29sbGlzaW9uLnN0YXRpYykge1xuICAgICAgbGF5b3V0ID0gbW92ZUVsZW1lbnRBd2F5RnJvbUNvbGxpc2lvbihsYXlvdXQsIGNvbGxpc2lvbiwgbCwgaXNVc2VyQWN0aW9uKTtcbiAgICB9IGVsc2Uge1xuICAgICAgbGF5b3V0ID0gbW92ZUVsZW1lbnRBd2F5RnJvbUNvbGxpc2lvbihsYXlvdXQsIGwsIGNvbGxpc2lvbiwgaXNVc2VyQWN0aW9uKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gbGF5b3V0O1xufVxuLyoqXHJcbiAqIFRoaXMgaXMgd2hlcmUgdGhlIG1hZ2ljIG5lZWRzIHRvIGhhcHBlbiAtIGdpdmVuIGEgY29sbGlzaW9uLCBtb3ZlIGFuIGVsZW1lbnQgYXdheSBmcm9tIHRoZSBjb2xsaXNpb24uXHJcbiAqIFdlIGF0dGVtcHQgdG8gbW92ZSBpdCB1cCBpZiB0aGVyZSdzIHJvb20sIG90aGVyd2lzZSBpdCBnb2VzIGJlbG93LlxyXG4gKlxyXG4gKiBAcGFyYW0gIHtBcnJheX0gbGF5b3V0ICAgICAgICAgICAgRnVsbCBsYXlvdXQgdG8gbW9kaWZ5LlxyXG4gKiBAcGFyYW0gIHtMYXlvdXRJdGVtfSBjb2xsaWRlc1dpdGggTGF5b3V0IGl0ZW0gd2UncmUgY29sbGlkaW5nIHdpdGguXHJcbiAqIEBwYXJhbSAge0xheW91dEl0ZW19IGl0ZW1Ub01vdmUgICBMYXlvdXQgaXRlbSB3ZSdyZSBtb3ZpbmcuXHJcbiAqIEBwYXJhbSAge0Jvb2xlYW59IFtpc1VzZXJBY3Rpb25dICBJZiB0cnVlLCBkZXNpZ25hdGVzIHRoYXQgdGhlIGl0ZW0gd2UncmUgbW92aW5nIGlzIGJlaW5nIGRyYWdnZWQvcmVzaXplZFxyXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnkgdGhlIHVzZXIuXHJcbiAqL1xuXG5mdW5jdGlvbiBtb3ZlRWxlbWVudEF3YXlGcm9tQ29sbGlzaW9uKGxheW91dFxuLyo6IExheW91dCovXG4sIGNvbGxpZGVzV2l0aFxuLyo6IExheW91dEl0ZW0qL1xuLCBpdGVtVG9Nb3ZlXG4vKjogTGF5b3V0SXRlbSovXG4sIGlzVXNlckFjdGlvblxuLyo6ID9ib29sZWFuKi9cbilcbi8qOiBMYXlvdXQqL1xue1xuICB2YXIgcHJldmVudENvbGxpc2lvbiA9IGZhbHNlOyAvLyB3ZSdyZSBhbHJlYWR5IGNvbGxpZGluZ1xuICAvLyBJZiB0aGVyZSBpcyBlbm91Z2ggc3BhY2UgYWJvdmUgdGhlIGNvbGxpc2lvbiB0byBwdXQgdGhpcyBlbGVtZW50LCBtb3ZlIGl0IHRoZXJlLlxuICAvLyBXZSBvbmx5IGRvIHRoaXMgb24gdGhlIG1haW4gY29sbGlzaW9uIGFzIHRoaXMgY2FuIGdldCBmdW5reSBpbiBjYXNjYWRlcyBhbmQgY2F1c2VcbiAgLy8gdW53YW50ZWQgc3dhcHBpbmcgYmVoYXZpb3IuXG5cbiAgaWYgKGlzVXNlckFjdGlvbikge1xuICAgIC8vIE1ha2UgYSBtb2NrIGl0ZW0gc28gd2UgZG9uJ3QgbW9kaWZ5IHRoZSBpdGVtIGhlcmUsIG9ubHkgbW9kaWZ5IGluIG1vdmVFbGVtZW50LlxuICAgIHZhciBmYWtlSXRlbVxuICAgIC8qOiBMYXlvdXRJdGVtKi9cbiAgICA9IHtcbiAgICAgIHg6IGl0ZW1Ub01vdmUueCxcbiAgICAgIHk6IGl0ZW1Ub01vdmUueSxcbiAgICAgIHc6IGl0ZW1Ub01vdmUudyxcbiAgICAgIGg6IGl0ZW1Ub01vdmUuaCxcbiAgICAgIGk6ICctMSdcbiAgICB9O1xuICAgIGZha2VJdGVtLnkgPSBNYXRoLm1heChjb2xsaWRlc1dpdGgueSAtIGl0ZW1Ub01vdmUuaCwgMCk7XG5cbiAgICBpZiAoIWdldEZpcnN0Q29sbGlzaW9uKGxheW91dCwgZmFrZUl0ZW0pKSB7XG4gICAgICByZXR1cm4gbW92ZUVsZW1lbnQobGF5b3V0LCBpdGVtVG9Nb3ZlLCB1bmRlZmluZWQsIGZha2VJdGVtLnksIHByZXZlbnRDb2xsaXNpb24pO1xuICAgIH1cbiAgfSAvLyBQcmV2aW91c2x5IHRoaXMgd2FzIG9wdGltaXplZCB0byBtb3ZlIGJlbG93IHRoZSBjb2xsaXNpb24gZGlyZWN0bHksIGJ1dCB0aGlzIGNhbiBjYXVzZSBwcm9ibGVtc1xuICAvLyB3aXRoIGNhc2NhZGluZyBtb3ZlcywgYXMgYW4gaXRlbSBtYXkgYWN0dWFsbHkgbGVhcGZsb2cgYSBjb2xsaXNpb24gYW5kIGNhdXNlIGEgcmV2ZXJzYWwgaW4gb3JkZXIuXG5cblxuICByZXR1cm4gbW92ZUVsZW1lbnQobGF5b3V0LCBpdGVtVG9Nb3ZlLCB1bmRlZmluZWQsIGl0ZW1Ub01vdmUueSArIDEsIHByZXZlbnRDb2xsaXNpb24pO1xufVxuLyoqXHJcbiAqIEhlbHBlciB0byBjb252ZXJ0IGEgbnVtYmVyIHRvIGEgcGVyY2VudGFnZSBzdHJpbmcuXHJcbiAqXHJcbiAqIEBwYXJhbSAge051bWJlcn0gbnVtIEFueSBudW1iZXJcclxuICogQHJldHVybiB7U3RyaW5nfSAgICAgVGhhdCBudW1iZXIgYXMgYSBwZXJjZW50YWdlLlxyXG4gKi9cblxuZnVuY3Rpb24gcGVyYyhudW1cbi8qOiBudW1iZXIqL1xuKVxuLyo6IHN0cmluZyovXG57XG4gIHJldHVybiBudW0gKiAxMDAgKyAnJSc7XG59XG5mdW5jdGlvbiBzZXRUcmFuc2Zvcm0odG9wLCBsZWZ0LCB3aWR0aCwgaGVpZ2h0KVxuLyo6IE9iamVjdCovXG57XG4gIC8vIFJlcGxhY2UgdW5pdGxlc3MgaXRlbXMgd2l0aCBweFxuICB2YXIgdHJhbnNsYXRlID0gXCJ0cmFuc2xhdGUzZChcIiArIGxlZnQgKyBcInB4LFwiICsgdG9wICsgXCJweCwgMClcIjtcbiAgcmV0dXJuIHtcbiAgICB0cmFuc2Zvcm06IHRyYW5zbGF0ZSxcbiAgICBXZWJraXRUcmFuc2Zvcm06IHRyYW5zbGF0ZSxcbiAgICBNb3pUcmFuc2Zvcm06IHRyYW5zbGF0ZSxcbiAgICBtc1RyYW5zZm9ybTogdHJhbnNsYXRlLFxuICAgIE9UcmFuc2Zvcm06IHRyYW5zbGF0ZSxcbiAgICB3aWR0aDogd2lkdGggKyBcInB4XCIsXG4gICAgaGVpZ2h0OiBoZWlnaHQgKyBcInB4XCIsXG4gICAgcG9zaXRpb246ICdhYnNvbHV0ZSdcbiAgfTtcbn1cbi8qKlxyXG4gKiBKdXN0IGxpa2UgdGhlIHNldFRyYW5zZm9ybSBtZXRob2QsIGJ1dCBpbnN0ZWFkIGl0IHdpbGwgcmV0dXJuIGEgbmVnYXRpdmUgdmFsdWUgb2YgcmlnaHQuXHJcbiAqXHJcbiAqIEBwYXJhbSB0b3BcclxuICogQHBhcmFtIHJpZ2h0XHJcbiAqIEBwYXJhbSB3aWR0aFxyXG4gKiBAcGFyYW0gaGVpZ2h0XHJcbiAqIEByZXR1cm5zIHt7dHJhbnNmb3JtOiBzdHJpbmcsIFdlYmtpdFRyYW5zZm9ybTogc3RyaW5nLCBNb3pUcmFuc2Zvcm06IHN0cmluZywgbXNUcmFuc2Zvcm06IHN0cmluZywgT1RyYW5zZm9ybTogc3RyaW5nLCB3aWR0aDogc3RyaW5nLCBoZWlnaHQ6IHN0cmluZywgcG9zaXRpb246IHN0cmluZ319XHJcbiAqL1xuXG5mdW5jdGlvbiBzZXRUcmFuc2Zvcm1SdGwodG9wLCByaWdodCwgd2lkdGgsIGhlaWdodClcbi8qOiBPYmplY3QqL1xue1xuICAvLyBSZXBsYWNlIHVuaXRsZXNzIGl0ZW1zIHdpdGggcHhcbiAgdmFyIHRyYW5zbGF0ZSA9IFwidHJhbnNsYXRlM2QoXCIgKyByaWdodCAqIC0xICsgXCJweCxcIiArIHRvcCArIFwicHgsIDApXCI7XG4gIHJldHVybiB7XG4gICAgdHJhbnNmb3JtOiB0cmFuc2xhdGUsXG4gICAgV2Via2l0VHJhbnNmb3JtOiB0cmFuc2xhdGUsXG4gICAgTW96VHJhbnNmb3JtOiB0cmFuc2xhdGUsXG4gICAgbXNUcmFuc2Zvcm06IHRyYW5zbGF0ZSxcbiAgICBPVHJhbnNmb3JtOiB0cmFuc2xhdGUsXG4gICAgd2lkdGg6IHdpZHRoICsgXCJweFwiLFxuICAgIGhlaWdodDogaGVpZ2h0ICsgXCJweFwiLFxuICAgIHBvc2l0aW9uOiAnYWJzb2x1dGUnXG4gIH07XG59XG5mdW5jdGlvbiBzZXRUb3BMZWZ0KHRvcCwgbGVmdCwgd2lkdGgsIGhlaWdodClcbi8qOiBPYmplY3QqL1xue1xuICByZXR1cm4ge1xuICAgIHRvcDogdG9wICsgXCJweFwiLFxuICAgIGxlZnQ6IGxlZnQgKyBcInB4XCIsXG4gICAgd2lkdGg6IHdpZHRoICsgXCJweFwiLFxuICAgIGhlaWdodDogaGVpZ2h0ICsgXCJweFwiLFxuICAgIHBvc2l0aW9uOiAnYWJzb2x1dGUnXG4gIH07XG59XG4vKipcclxuICogSnVzdCBsaWtlIHRoZSBzZXRUb3BMZWZ0IG1ldGhvZCwgYnV0IGluc3RlYWQsIGl0IHdpbGwgcmV0dXJuIGEgcmlnaHQgcHJvcGVydHkgaW5zdGVhZCBvZiBsZWZ0LlxyXG4gKlxyXG4gKiBAcGFyYW0gdG9wXHJcbiAqIEBwYXJhbSByaWdodFxyXG4gKiBAcGFyYW0gd2lkdGhcclxuICogQHBhcmFtIGhlaWdodFxyXG4gKiBAcmV0dXJucyB7e3RvcDogc3RyaW5nLCByaWdodDogc3RyaW5nLCB3aWR0aDogc3RyaW5nLCBoZWlnaHQ6IHN0cmluZywgcG9zaXRpb246IHN0cmluZ319XHJcbiAqL1xuXG5mdW5jdGlvbiBzZXRUb3BSaWdodCh0b3AsIHJpZ2h0LCB3aWR0aCwgaGVpZ2h0KVxuLyo6IE9iamVjdCovXG57XG4gIHJldHVybiB7XG4gICAgdG9wOiB0b3AgKyBcInB4XCIsXG4gICAgcmlnaHQ6IHJpZ2h0ICsgXCJweFwiLFxuICAgIHdpZHRoOiB3aWR0aCArIFwicHhcIixcbiAgICBoZWlnaHQ6IGhlaWdodCArIFwicHhcIixcbiAgICBwb3NpdGlvbjogJ2Fic29sdXRlJ1xuICB9O1xufVxuLyoqXHJcbiAqIEdldCBsYXlvdXQgaXRlbXMgc29ydGVkIGZyb20gdG9wIGxlZnQgdG8gcmlnaHQgYW5kIGRvd24uXHJcbiAqXHJcbiAqIEByZXR1cm4ge0FycmF5fSBBcnJheSBvZiBsYXlvdXQgb2JqZWN0cy5cclxuICogQHJldHVybiB7QXJyYXl9ICAgICAgICBMYXlvdXQsIHNvcnRlZCBzdGF0aWMgaXRlbXMgZmlyc3QuXHJcbiAqL1xuXG5mdW5jdGlvbiBzb3J0TGF5b3V0SXRlbXNCeVJvd0NvbChsYXlvdXRcbi8qOiBMYXlvdXQqL1xuKVxuLyo6IExheW91dCovXG57XG4gIHJldHVybiBbXS5jb25jYXQobGF5b3V0KS5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgaWYgKGEueSA9PT0gYi55ICYmIGEueCA9PT0gYi54KSB7XG4gICAgICByZXR1cm4gMDtcbiAgICB9XG5cbiAgICBpZiAoYS55ID4gYi55IHx8IGEueSA9PT0gYi55ICYmIGEueCA+IGIueCkge1xuICAgICAgcmV0dXJuIDE7XG4gICAgfVxuXG4gICAgcmV0dXJuIC0xO1xuICB9KTtcbn1cbi8qKlxyXG4gKiBHZW5lcmF0ZSBhIGxheW91dCB1c2luZyB0aGUgaW5pdGlhbExheW91dCBhbmQgY2hpbGRyZW4gYXMgYSB0ZW1wbGF0ZS5cclxuICogTWlzc2luZyBlbnRyaWVzIHdpbGwgYmUgYWRkZWQsIGV4dHJhbmVvdXMgb25lcyB3aWxsIGJlIHRydW5jYXRlZC5cclxuICpcclxuICogQHBhcmFtICB7QXJyYXl9ICBpbml0aWFsTGF5b3V0IExheW91dCBwYXNzZWQgaW4gdGhyb3VnaCBwcm9wcy5cclxuICogQHBhcmFtICB7U3RyaW5nfSBicmVha3BvaW50ICAgIEN1cnJlbnQgcmVzcG9uc2l2ZSBicmVha3BvaW50LlxyXG4gKiBAcGFyYW0gIHtCb29sZWFufSB2ZXJ0aWNhbENvbXBhY3QgV2hldGhlciBvciBub3QgdG8gY29tcGFjdCB0aGUgbGF5b3V0IHZlcnRpY2FsbHkuXHJcbiAqIEByZXR1cm4ge0FycmF5fSAgICAgICAgICAgICAgICBXb3JraW5nIGxheW91dC5cclxuICovXG5cbi8qXHJcbmV4cG9ydCBmdW5jdGlvbiBzeW5jaHJvbml6ZUxheW91dFdpdGhDaGlsZHJlbihpbml0aWFsTGF5b3V0OiBMYXlvdXQsIGNoaWxkcmVuOiBBcnJheTxSZWFjdC5FbGVtZW50PnxSZWFjdC5FbGVtZW50LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29sczogbnVtYmVyLCB2ZXJ0aWNhbENvbXBhY3Q6IGJvb2xlYW4pOiBMYXlvdXQge1xyXG4gIC8vIGVuc3VyZSAnY2hpbGRyZW4nIGlzIGFsd2F5cyBhbiBhcnJheVxyXG4gIGlmICghQXJyYXkuaXNBcnJheShjaGlsZHJlbikpIHtcclxuICAgIGNoaWxkcmVuID0gW2NoaWxkcmVuXTtcclxuICB9XHJcbiAgaW5pdGlhbExheW91dCA9IGluaXRpYWxMYXlvdXQgfHwgW107XHJcblxyXG4gIC8vIEdlbmVyYXRlIG9uZSBsYXlvdXQgaXRlbSBwZXIgY2hpbGQuXHJcbiAgbGV0IGxheW91dDogTGF5b3V0ID0gW107XHJcbiAgZm9yIChsZXQgaSA9IDAsIGxlbiA9IGNoaWxkcmVuLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XHJcbiAgICBsZXQgbmV3SXRlbTtcclxuICAgIGNvbnN0IGNoaWxkID0gY2hpbGRyZW5baV07XHJcblxyXG4gICAgLy8gRG9uJ3Qgb3ZlcndyaXRlIGlmIGl0IGFscmVhZHkgZXhpc3RzLlxyXG4gICAgY29uc3QgZXhpc3RzID0gZ2V0TGF5b3V0SXRlbShpbml0aWFsTGF5b3V0LCBjaGlsZC5rZXkgfHwgXCIxXCIgLyEqIEZJWE1FIHNhdGlzZmllcyBGbG93ICohLyk7XHJcbiAgICBpZiAoZXhpc3RzKSB7XHJcbiAgICAgIG5ld0l0ZW0gPSBleGlzdHM7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBjb25zdCBnID0gY2hpbGQucHJvcHMuX2dyaWQ7XHJcblxyXG4gICAgICAvLyBIZXksIHRoaXMgaXRlbSBoYXMgYSBfZ3JpZCBwcm9wZXJ0eSwgdXNlIGl0LlxyXG4gICAgICBpZiAoZykge1xyXG4gICAgICAgIGlmICghaXNQcm9kdWN0aW9uKSB7XHJcbiAgICAgICAgICB2YWxpZGF0ZUxheW91dChbZ10sICdSZWFjdEdyaWRMYXlvdXQuY2hpbGRyZW4nKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gVmFsaWRhdGVkOyBhZGQgaXQgdG8gdGhlIGxheW91dC4gQm90dG9tICd5JyBwb3NzaWJsZSBpcyB0aGUgYm90dG9tIG9mIHRoZSBsYXlvdXQuXHJcbiAgICAgICAgLy8gVGhpcyBhbGxvd3MgeW91IHRvIGRvIG5pY2Ugc3R1ZmYgbGlrZSBzcGVjaWZ5IHt5OiBJbmZpbml0eX1cclxuICAgICAgICBpZiAodmVydGljYWxDb21wYWN0KSB7XHJcbiAgICAgICAgICBuZXdJdGVtID0gY2xvbmVMYXlvdXRJdGVtKHsuLi5nLCB5OiBNYXRoLm1pbihib3R0b20obGF5b3V0KSwgZy55KSwgaTogY2hpbGQua2V5fSk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIG5ld0l0ZW0gPSBjbG9uZUxheW91dEl0ZW0oey4uLmcsIHk6IGcueSwgaTogY2hpbGQua2V5fSk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICAgIC8vIE5vdGhpbmcgcHJvdmlkZWQ6IGVuc3VyZSB0aGlzIGlzIGFkZGVkIHRvIHRoZSBib3R0b21cclxuICAgICAgZWxzZSB7XHJcbiAgICAgICAgbmV3SXRlbSA9IGNsb25lTGF5b3V0SXRlbSh7dzogMSwgaDogMSwgeDogMCwgeTogYm90dG9tKGxheW91dCksIGk6IGNoaWxkLmtleSB8fCBcIjFcIn0pO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgICBsYXlvdXRbaV0gPSBuZXdJdGVtO1xyXG4gIH1cclxuXHJcbiAgLy8gQ29ycmVjdCB0aGUgbGF5b3V0LlxyXG4gIGxheW91dCA9IGNvcnJlY3RCb3VuZHMobGF5b3V0LCB7Y29sczogY29sc30pO1xyXG4gIGxheW91dCA9IGNvbXBhY3QobGF5b3V0LCB2ZXJ0aWNhbENvbXBhY3QpO1xyXG5cclxuICByZXR1cm4gbGF5b3V0O1xyXG59XHJcbiovXG5cbi8qKlxyXG4gKiBWYWxpZGF0ZSBhIGxheW91dC4gVGhyb3dzIGVycm9ycy5cclxuICpcclxuICogQHBhcmFtICB7QXJyYXl9ICBsYXlvdXQgICAgICAgIEFycmF5IG9mIGxheW91dCBpdGVtcy5cclxuICogQHBhcmFtICB7U3RyaW5nfSBbY29udGV4dE5hbWVdIENvbnRleHQgbmFtZSBmb3IgZXJyb3JzLlxyXG4gKiBAdGhyb3cgIHtFcnJvcn0gICAgICAgICAgICAgICAgVmFsaWRhdGlvbiBlcnJvci5cclxuICovXG5cbmZ1bmN0aW9uIHZhbGlkYXRlTGF5b3V0KGxheW91dFxuLyo6IExheW91dCovXG4sIGNvbnRleHROYW1lXG4vKjogc3RyaW5nKi9cbilcbi8qOiB2b2lkKi9cbntcbiAgY29udGV4dE5hbWUgPSBjb250ZXh0TmFtZSB8fCBcIkxheW91dFwiO1xuICB2YXIgc3ViUHJvcHMgPSBbJ3gnLCAneScsICd3JywgJ2gnXTtcbiAgaWYgKCFBcnJheS5pc0FycmF5KGxheW91dCkpIHRocm93IG5ldyBFcnJvcihjb250ZXh0TmFtZSArIFwiIG11c3QgYmUgYW4gYXJyYXkhXCIpO1xuXG4gIGZvciAodmFyIGkgPSAwLCBsZW4gPSBsYXlvdXQubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICB2YXIgaXRlbSA9IGxheW91dFtpXTtcblxuICAgIGZvciAodmFyIGogPSAwOyBqIDwgc3ViUHJvcHMubGVuZ3RoOyBqKyspIHtcbiAgICAgIGlmICh0eXBlb2YgaXRlbVtzdWJQcm9wc1tqXV0gIT09ICdudW1iZXInKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignVnVlR3JpZExheW91dDogJyArIGNvbnRleHROYW1lICsgJ1snICsgaSArICddLicgKyBzdWJQcm9wc1tqXSArICcgbXVzdCBiZSBhIG51bWJlciEnKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoaXRlbS5pICYmIHR5cGVvZiBpdGVtLmkgIT09ICdzdHJpbmcnKSB7Ly8gbnVtYmVyIGlzIGFsc28gb2ssIHNvIGNvbW1lbnQgdGhlIGVycm9yXG4gICAgICAvLyBUT0RPIGNvbmZpcm0gaWYgY29tbWVudGluZyB0aGUgbGluZSBiZWxvdyBkb2Vzbid0IGNhdXNlIHVuZXhwZWN0ZWQgcHJvYmxlbXNcbiAgICAgIC8vIHRocm93IG5ldyBFcnJvcignVnVlR3JpZExheW91dDogJyArIGNvbnRleHROYW1lICsgJ1snICsgaSArICddLmkgbXVzdCBiZSBhIHN0cmluZyEnKTtcbiAgICB9XG5cbiAgICBpZiAoaXRlbS5zdGF0aWMgIT09IHVuZGVmaW5lZCAmJiB0eXBlb2YgaXRlbS5zdGF0aWMgIT09ICdib29sZWFuJykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdWdWVHcmlkTGF5b3V0OiAnICsgY29udGV4dE5hbWUgKyAnWycgKyBpICsgJ10uc3RhdGljIG11c3QgYmUgYSBib29sZWFuIScpO1xuICAgIH1cbiAgfVxufSAvLyBGbG93IGNhbid0IHJlYWxseSBmaWd1cmUgdGhpcyBvdXQsIHNvIHdlIGp1c3QgdXNlIE9iamVjdFxuXG5mdW5jdGlvbiBhdXRvQmluZEhhbmRsZXJzKGVsXG4vKjogT2JqZWN0Ki9cbiwgZm5zXG4vKjogQXJyYXk8c3RyaW5nPiovXG4pXG4vKjogdm9pZCovXG57XG4gIGZucy5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICByZXR1cm4gZWxba2V5XSA9IGVsW2tleV0uYmluZChlbCk7XG4gIH0pO1xufVxuLyoqXHJcbiAqIENvbnZlcnQgYSBKUyBvYmplY3QgdG8gQ1NTIHN0cmluZy4gU2ltaWxhciB0byBSZWFjdCdzIG91dHB1dCBvZiBDU1MuXHJcbiAqIEBwYXJhbSBvYmpcclxuICogQHJldHVybnMge3N0cmluZ31cclxuICovXG5cbmZ1bmN0aW9uIGNyZWF0ZU1hcmt1cChvYmopIHtcbiAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhvYmopO1xuICBpZiAoIWtleXMubGVuZ3RoKSByZXR1cm4gJyc7XG4gIHZhciBpLFxuICAgICAgbGVuID0ga2V5cy5sZW5ndGg7XG4gIHZhciByZXN1bHQgPSAnJztcblxuICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICB2YXIga2V5ID0ga2V5c1tpXTtcbiAgICB2YXIgdmFsID0gb2JqW2tleV07XG4gICAgcmVzdWx0ICs9IGh5cGhlbmF0ZShrZXkpICsgJzonICsgYWRkUHgoa2V5LCB2YWwpICsgJzsnO1xuICB9XG5cbiAgcmV0dXJuIHJlc3VsdDtcbn1cbi8qIFRoZSBmb2xsb3dpbmcgbGlzdCBpcyBkZWZpbmVkIGluIFJlYWN0J3MgY29yZSAqL1xuXG52YXIgSVNfVU5JVExFU1MgPSB7XG4gIGFuaW1hdGlvbkl0ZXJhdGlvbkNvdW50OiB0cnVlLFxuICBib3hGbGV4OiB0cnVlLFxuICBib3hGbGV4R3JvdXA6IHRydWUsXG4gIGJveE9yZGluYWxHcm91cDogdHJ1ZSxcbiAgY29sdW1uQ291bnQ6IHRydWUsXG4gIGZsZXg6IHRydWUsXG4gIGZsZXhHcm93OiB0cnVlLFxuICBmbGV4UG9zaXRpdmU6IHRydWUsXG4gIGZsZXhTaHJpbms6IHRydWUsXG4gIGZsZXhOZWdhdGl2ZTogdHJ1ZSxcbiAgZmxleE9yZGVyOiB0cnVlLFxuICBncmlkUm93OiB0cnVlLFxuICBncmlkQ29sdW1uOiB0cnVlLFxuICBmb250V2VpZ2h0OiB0cnVlLFxuICBsaW5lQ2xhbXA6IHRydWUsXG4gIGxpbmVIZWlnaHQ6IHRydWUsXG4gIG9wYWNpdHk6IHRydWUsXG4gIG9yZGVyOiB0cnVlLFxuICBvcnBoYW5zOiB0cnVlLFxuICB0YWJTaXplOiB0cnVlLFxuICB3aWRvd3M6IHRydWUsXG4gIHpJbmRleDogdHJ1ZSxcbiAgem9vbTogdHJ1ZSxcbiAgLy8gU1ZHLXJlbGF0ZWQgcHJvcGVydGllc1xuICBmaWxsT3BhY2l0eTogdHJ1ZSxcbiAgc3RvcE9wYWNpdHk6IHRydWUsXG4gIHN0cm9rZURhc2hvZmZzZXQ6IHRydWUsXG4gIHN0cm9rZU9wYWNpdHk6IHRydWUsXG4gIHN0cm9rZVdpZHRoOiB0cnVlXG59O1xuLyoqXHJcbiAqIFdpbGwgYWRkIHB4IHRvIHRoZSBlbmQgb2Ygc3R5bGUgdmFsdWVzIHdoaWNoIGFyZSBOdW1iZXJzLlxyXG4gKiBAcGFyYW0gbmFtZVxyXG4gKiBAcGFyYW0gdmFsdWVcclxuICogQHJldHVybnMgeyp9XHJcbiAqL1xuXG5mdW5jdGlvbiBhZGRQeChuYW1lLCB2YWx1ZSkge1xuICBpZiAodHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJyAmJiAhSVNfVU5JVExFU1NbbmFtZV0pIHtcbiAgICByZXR1cm4gdmFsdWUgKyAncHgnO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxufVxuLyoqXHJcbiAqIEh5cGhlbmF0ZSBhIGNhbWVsQ2FzZSBzdHJpbmcuXHJcbiAqXHJcbiAqIEBwYXJhbSB7U3RyaW5nfSBzdHJcclxuICogQHJldHVybiB7U3RyaW5nfVxyXG4gKi9cblxudmFyIGh5cGhlbmF0ZVJFID0gLyhbYS16XFxkXSkoW0EtWl0pL2c7XG5mdW5jdGlvbiBoeXBoZW5hdGUoc3RyKSB7XG4gIHJldHVybiBzdHIucmVwbGFjZShoeXBoZW5hdGVSRSwgJyQxLSQyJykudG9Mb3dlckNhc2UoKTtcbn1cbmZ1bmN0aW9uIGZpbmRJdGVtSW5BcnJheShhcnJheSwgcHJvcGVydHksIHZhbHVlKSB7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgYXJyYXkubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAoYXJyYXlbaV1bcHJvcGVydHldID09IHZhbHVlKSByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cbmZ1bmN0aW9uIGZpbmRBbmRSZW1vdmUoYXJyYXksIHByb3BlcnR5LCB2YWx1ZSkge1xuICBhcnJheS5mb3JFYWNoKGZ1bmN0aW9uIChyZXN1bHQsIGluZGV4KSB7XG4gICAgaWYgKHJlc3VsdFtwcm9wZXJ0eV0gPT09IHZhbHVlKSB7XG4gICAgICAvL1JlbW92ZSBmcm9tIGFycmF5XG4gICAgICBhcnJheS5zcGxpY2UoaW5kZXgsIDEpO1xuICAgIH1cbiAgfSk7XG59XG5cbi8qKiovIH0pLFxuXG4vKioqLyBcImE0ODFcIjpcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxudmFyIGFuT2JqZWN0ID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcImNiN2NcIik7XG52YXIgdG9PYmplY3QgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiNGJmOFwiKTtcbnZhciB0b0xlbmd0aCA9IF9fd2VicGFja19yZXF1aXJlX18oXCI5ZGVmXCIpO1xudmFyIHRvSW50ZWdlciA9IF9fd2VicGFja19yZXF1aXJlX18oXCI0NTg4XCIpO1xudmFyIGFkdmFuY2VTdHJpbmdJbmRleCA9IF9fd2VicGFja19yZXF1aXJlX18oXCIwMzkwXCIpO1xudmFyIHJlZ0V4cEV4ZWMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiNWYxYlwiKTtcbnZhciBtYXggPSBNYXRoLm1heDtcbnZhciBtaW4gPSBNYXRoLm1pbjtcbnZhciBmbG9vciA9IE1hdGguZmxvb3I7XG52YXIgU1VCU1RJVFVUSU9OX1NZTUJPTFMgPSAvXFwkKFskJmAnXXxcXGRcXGQ/fDxbXj5dKj4pL2c7XG52YXIgU1VCU1RJVFVUSU9OX1NZTUJPTFNfTk9fTkFNRUQgPSAvXFwkKFskJmAnXXxcXGRcXGQ/KS9nO1xuXG52YXIgbWF5YmVUb1N0cmluZyA9IGZ1bmN0aW9uIChpdCkge1xuICByZXR1cm4gaXQgPT09IHVuZGVmaW5lZCA/IGl0IDogU3RyaW5nKGl0KTtcbn07XG5cbi8vIEBAcmVwbGFjZSBsb2dpY1xuX193ZWJwYWNrX3JlcXVpcmVfXyhcIjIxNGZcIikoJ3JlcGxhY2UnLCAyLCBmdW5jdGlvbiAoZGVmaW5lZCwgUkVQTEFDRSwgJHJlcGxhY2UsIG1heWJlQ2FsbE5hdGl2ZSkge1xuICByZXR1cm4gW1xuICAgIC8vIGBTdHJpbmcucHJvdG90eXBlLnJlcGxhY2VgIG1ldGhvZFxuICAgIC8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLXN0cmluZy5wcm90b3R5cGUucmVwbGFjZVxuICAgIGZ1bmN0aW9uIHJlcGxhY2Uoc2VhcmNoVmFsdWUsIHJlcGxhY2VWYWx1ZSkge1xuICAgICAgdmFyIE8gPSBkZWZpbmVkKHRoaXMpO1xuICAgICAgdmFyIGZuID0gc2VhcmNoVmFsdWUgPT0gdW5kZWZpbmVkID8gdW5kZWZpbmVkIDogc2VhcmNoVmFsdWVbUkVQTEFDRV07XG4gICAgICByZXR1cm4gZm4gIT09IHVuZGVmaW5lZFxuICAgICAgICA/IGZuLmNhbGwoc2VhcmNoVmFsdWUsIE8sIHJlcGxhY2VWYWx1ZSlcbiAgICAgICAgOiAkcmVwbGFjZS5jYWxsKFN0cmluZyhPKSwgc2VhcmNoVmFsdWUsIHJlcGxhY2VWYWx1ZSk7XG4gICAgfSxcbiAgICAvLyBgUmVnRXhwLnByb3RvdHlwZVtAQHJlcGxhY2VdYCBtZXRob2RcbiAgICAvLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1yZWdleHAucHJvdG90eXBlLUBAcmVwbGFjZVxuICAgIGZ1bmN0aW9uIChyZWdleHAsIHJlcGxhY2VWYWx1ZSkge1xuICAgICAgdmFyIHJlcyA9IG1heWJlQ2FsbE5hdGl2ZSgkcmVwbGFjZSwgcmVnZXhwLCB0aGlzLCByZXBsYWNlVmFsdWUpO1xuICAgICAgaWYgKHJlcy5kb25lKSByZXR1cm4gcmVzLnZhbHVlO1xuXG4gICAgICB2YXIgcnggPSBhbk9iamVjdChyZWdleHApO1xuICAgICAgdmFyIFMgPSBTdHJpbmcodGhpcyk7XG4gICAgICB2YXIgZnVuY3Rpb25hbFJlcGxhY2UgPSB0eXBlb2YgcmVwbGFjZVZhbHVlID09PSAnZnVuY3Rpb24nO1xuICAgICAgaWYgKCFmdW5jdGlvbmFsUmVwbGFjZSkgcmVwbGFjZVZhbHVlID0gU3RyaW5nKHJlcGxhY2VWYWx1ZSk7XG4gICAgICB2YXIgZ2xvYmFsID0gcnguZ2xvYmFsO1xuICAgICAgaWYgKGdsb2JhbCkge1xuICAgICAgICB2YXIgZnVsbFVuaWNvZGUgPSByeC51bmljb2RlO1xuICAgICAgICByeC5sYXN0SW5kZXggPSAwO1xuICAgICAgfVxuICAgICAgdmFyIHJlc3VsdHMgPSBbXTtcbiAgICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgIHZhciByZXN1bHQgPSByZWdFeHBFeGVjKHJ4LCBTKTtcbiAgICAgICAgaWYgKHJlc3VsdCA9PT0gbnVsbCkgYnJlYWs7XG4gICAgICAgIHJlc3VsdHMucHVzaChyZXN1bHQpO1xuICAgICAgICBpZiAoIWdsb2JhbCkgYnJlYWs7XG4gICAgICAgIHZhciBtYXRjaFN0ciA9IFN0cmluZyhyZXN1bHRbMF0pO1xuICAgICAgICBpZiAobWF0Y2hTdHIgPT09ICcnKSByeC5sYXN0SW5kZXggPSBhZHZhbmNlU3RyaW5nSW5kZXgoUywgdG9MZW5ndGgocngubGFzdEluZGV4KSwgZnVsbFVuaWNvZGUpO1xuICAgICAgfVxuICAgICAgdmFyIGFjY3VtdWxhdGVkUmVzdWx0ID0gJyc7XG4gICAgICB2YXIgbmV4dFNvdXJjZVBvc2l0aW9uID0gMDtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcmVzdWx0cy5sZW5ndGg7IGkrKykge1xuICAgICAgICByZXN1bHQgPSByZXN1bHRzW2ldO1xuICAgICAgICB2YXIgbWF0Y2hlZCA9IFN0cmluZyhyZXN1bHRbMF0pO1xuICAgICAgICB2YXIgcG9zaXRpb24gPSBtYXgobWluKHRvSW50ZWdlcihyZXN1bHQuaW5kZXgpLCBTLmxlbmd0aCksIDApO1xuICAgICAgICB2YXIgY2FwdHVyZXMgPSBbXTtcbiAgICAgICAgLy8gTk9URTogVGhpcyBpcyBlcXVpdmFsZW50IHRvXG4gICAgICAgIC8vICAgY2FwdHVyZXMgPSByZXN1bHQuc2xpY2UoMSkubWFwKG1heWJlVG9TdHJpbmcpXG4gICAgICAgIC8vIGJ1dCBmb3Igc29tZSByZWFzb24gYG5hdGl2ZVNsaWNlLmNhbGwocmVzdWx0LCAxLCByZXN1bHQubGVuZ3RoKWAgKGNhbGxlZCBpblxuICAgICAgICAvLyB0aGUgc2xpY2UgcG9seWZpbGwgd2hlbiBzbGljaW5nIG5hdGl2ZSBhcnJheXMpIFwiZG9lc24ndCB3b3JrXCIgaW4gc2FmYXJpIDkgYW5kXG4gICAgICAgIC8vIGNhdXNlcyBhIGNyYXNoIChodHRwczovL3Bhc3RlYmluLmNvbS9OMjFRemVRQSkgd2hlbiB0cnlpbmcgdG8gZGVidWcgaXQuXG4gICAgICAgIGZvciAodmFyIGogPSAxOyBqIDwgcmVzdWx0Lmxlbmd0aDsgaisrKSBjYXB0dXJlcy5wdXNoKG1heWJlVG9TdHJpbmcocmVzdWx0W2pdKSk7XG4gICAgICAgIHZhciBuYW1lZENhcHR1cmVzID0gcmVzdWx0Lmdyb3VwcztcbiAgICAgICAgaWYgKGZ1bmN0aW9uYWxSZXBsYWNlKSB7XG4gICAgICAgICAgdmFyIHJlcGxhY2VyQXJncyA9IFttYXRjaGVkXS5jb25jYXQoY2FwdHVyZXMsIHBvc2l0aW9uLCBTKTtcbiAgICAgICAgICBpZiAobmFtZWRDYXB0dXJlcyAhPT0gdW5kZWZpbmVkKSByZXBsYWNlckFyZ3MucHVzaChuYW1lZENhcHR1cmVzKTtcbiAgICAgICAgICB2YXIgcmVwbGFjZW1lbnQgPSBTdHJpbmcocmVwbGFjZVZhbHVlLmFwcGx5KHVuZGVmaW5lZCwgcmVwbGFjZXJBcmdzKSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmVwbGFjZW1lbnQgPSBnZXRTdWJzdGl0dXRpb24obWF0Y2hlZCwgUywgcG9zaXRpb24sIGNhcHR1cmVzLCBuYW1lZENhcHR1cmVzLCByZXBsYWNlVmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwb3NpdGlvbiA+PSBuZXh0U291cmNlUG9zaXRpb24pIHtcbiAgICAgICAgICBhY2N1bXVsYXRlZFJlc3VsdCArPSBTLnNsaWNlKG5leHRTb3VyY2VQb3NpdGlvbiwgcG9zaXRpb24pICsgcmVwbGFjZW1lbnQ7XG4gICAgICAgICAgbmV4dFNvdXJjZVBvc2l0aW9uID0gcG9zaXRpb24gKyBtYXRjaGVkLmxlbmd0aDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGFjY3VtdWxhdGVkUmVzdWx0ICsgUy5zbGljZShuZXh0U291cmNlUG9zaXRpb24pO1xuICAgIH1cbiAgXTtcblxuICAgIC8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLWdldHN1YnN0aXR1dGlvblxuICBmdW5jdGlvbiBnZXRTdWJzdGl0dXRpb24obWF0Y2hlZCwgc3RyLCBwb3NpdGlvbiwgY2FwdHVyZXMsIG5hbWVkQ2FwdHVyZXMsIHJlcGxhY2VtZW50KSB7XG4gICAgdmFyIHRhaWxQb3MgPSBwb3NpdGlvbiArIG1hdGNoZWQubGVuZ3RoO1xuICAgIHZhciBtID0gY2FwdHVyZXMubGVuZ3RoO1xuICAgIHZhciBzeW1ib2xzID0gU1VCU1RJVFVUSU9OX1NZTUJPTFNfTk9fTkFNRUQ7XG4gICAgaWYgKG5hbWVkQ2FwdHVyZXMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgbmFtZWRDYXB0dXJlcyA9IHRvT2JqZWN0KG5hbWVkQ2FwdHVyZXMpO1xuICAgICAgc3ltYm9scyA9IFNVQlNUSVRVVElPTl9TWU1CT0xTO1xuICAgIH1cbiAgICByZXR1cm4gJHJlcGxhY2UuY2FsbChyZXBsYWNlbWVudCwgc3ltYm9scywgZnVuY3Rpb24gKG1hdGNoLCBjaCkge1xuICAgICAgdmFyIGNhcHR1cmU7XG4gICAgICBzd2l0Y2ggKGNoLmNoYXJBdCgwKSkge1xuICAgICAgICBjYXNlICckJzogcmV0dXJuICckJztcbiAgICAgICAgY2FzZSAnJic6IHJldHVybiBtYXRjaGVkO1xuICAgICAgICBjYXNlICdgJzogcmV0dXJuIHN0ci5zbGljZSgwLCBwb3NpdGlvbik7XG4gICAgICAgIGNhc2UgXCInXCI6IHJldHVybiBzdHIuc2xpY2UodGFpbFBvcyk7XG4gICAgICAgIGNhc2UgJzwnOlxuICAgICAgICAgIGNhcHR1cmUgPSBuYW1lZENhcHR1cmVzW2NoLnNsaWNlKDEsIC0xKV07XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6IC8vIFxcZFxcZD9cbiAgICAgICAgICB2YXIgbiA9ICtjaDtcbiAgICAgICAgICBpZiAobiA9PT0gMCkgcmV0dXJuIG1hdGNoO1xuICAgICAgICAgIGlmIChuID4gbSkge1xuICAgICAgICAgICAgdmFyIGYgPSBmbG9vcihuIC8gMTApO1xuICAgICAgICAgICAgaWYgKGYgPT09IDApIHJldHVybiBtYXRjaDtcbiAgICAgICAgICAgIGlmIChmIDw9IG0pIHJldHVybiBjYXB0dXJlc1tmIC0gMV0gPT09IHVuZGVmaW5lZCA/IGNoLmNoYXJBdCgxKSA6IGNhcHR1cmVzW2YgLSAxXSArIGNoLmNoYXJBdCgxKTtcbiAgICAgICAgICAgIHJldHVybiBtYXRjaDtcbiAgICAgICAgICB9XG4gICAgICAgICAgY2FwdHVyZSA9IGNhcHR1cmVzW24gLSAxXTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBjYXB0dXJlID09PSB1bmRlZmluZWQgPyAnJyA6IGNhcHR1cmU7XG4gICAgfSk7XG4gIH1cbn0pO1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcImFhNzdcIjpcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxudmFyICRleHBvcnQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiNWNhMVwiKTtcbnZhciBkZWZpbmVkID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcImJlMTNcIik7XG52YXIgZmFpbHMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiNzllNVwiKTtcbnZhciBzcGFjZXMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiZmRlZlwiKTtcbnZhciBzcGFjZSA9ICdbJyArIHNwYWNlcyArICddJztcbnZhciBub24gPSAnXFx1MjAwYlxcdTAwODUnO1xudmFyIGx0cmltID0gUmVnRXhwKCdeJyArIHNwYWNlICsgc3BhY2UgKyAnKicpO1xudmFyIHJ0cmltID0gUmVnRXhwKHNwYWNlICsgc3BhY2UgKyAnKiQnKTtcblxudmFyIGV4cG9ydGVyID0gZnVuY3Rpb24gKEtFWSwgZXhlYywgQUxJQVMpIHtcbiAgdmFyIGV4cCA9IHt9O1xuICB2YXIgRk9SQ0UgPSBmYWlscyhmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuICEhc3BhY2VzW0tFWV0oKSB8fCBub25bS0VZXSgpICE9IG5vbjtcbiAgfSk7XG4gIHZhciBmbiA9IGV4cFtLRVldID0gRk9SQ0UgPyBleGVjKHRyaW0pIDogc3BhY2VzW0tFWV07XG4gIGlmIChBTElBUykgZXhwW0FMSUFTXSA9IGZuO1xuICAkZXhwb3J0KCRleHBvcnQuUCArICRleHBvcnQuRiAqIEZPUkNFLCAnU3RyaW5nJywgZXhwKTtcbn07XG5cbi8vIDEgLT4gU3RyaW5nI3RyaW1MZWZ0XG4vLyAyIC0+IFN0cmluZyN0cmltUmlnaHRcbi8vIDMgLT4gU3RyaW5nI3RyaW1cbnZhciB0cmltID0gZXhwb3J0ZXIudHJpbSA9IGZ1bmN0aW9uIChzdHJpbmcsIFRZUEUpIHtcbiAgc3RyaW5nID0gU3RyaW5nKGRlZmluZWQoc3RyaW5nKSk7XG4gIGlmIChUWVBFICYgMSkgc3RyaW5nID0gc3RyaW5nLnJlcGxhY2UobHRyaW0sICcnKTtcbiAgaWYgKFRZUEUgJiAyKSBzdHJpbmcgPSBzdHJpbmcucmVwbGFjZShydHJpbSwgJycpO1xuICByZXR1cm4gc3RyaW5nO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRlcjtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCJhYmI0XCI6XG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbi8qIGdsb2JhbCBjb25zb2xlOiBmYWxzZSAqL1xuXG4vKipcbiAqIFJlcG9ydGVyIHRoYXQgaGFuZGxlcyB0aGUgcmVwb3J0aW5nIG9mIGxvZ3MsIHdhcm5pbmdzIGFuZCBlcnJvcnMuXG4gKiBAcHVibGljXG4gKiBAcGFyYW0ge2Jvb2xlYW59IHF1aWV0IFRlbGxzIGlmIHRoZSByZXBvcnRlciBzaG91bGQgYmUgcXVpZXQgb3Igbm90LlxuICovXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKHF1aWV0KSB7XG4gICAgZnVuY3Rpb24gbm9vcCgpIHtcbiAgICAgICAgLy9Eb2VzIG5vdGhpbmcuXG4gICAgfVxuXG4gICAgdmFyIHJlcG9ydGVyID0ge1xuICAgICAgICBsb2c6IG5vb3AsXG4gICAgICAgIHdhcm46IG5vb3AsXG4gICAgICAgIGVycm9yOiBub29wXG4gICAgfTtcblxuICAgIGlmKCFxdWlldCAmJiB3aW5kb3cuY29uc29sZSkge1xuICAgICAgICB2YXIgYXR0YWNoRnVuY3Rpb24gPSBmdW5jdGlvbihyZXBvcnRlciwgbmFtZSkge1xuICAgICAgICAgICAgLy9UaGUgcHJveHkgaXMgbmVlZGVkIHRvIGJlIGFibGUgdG8gY2FsbCB0aGUgbWV0aG9kIHdpdGggdGhlIGNvbnNvbGUgY29udGV4dCxcbiAgICAgICAgICAgIC8vc2luY2Ugd2UgY2Fubm90IHVzZSBiaW5kLlxuICAgICAgICAgICAgcmVwb3J0ZXJbbmFtZV0gPSBmdW5jdGlvbiByZXBvcnRlclByb3h5KCkge1xuICAgICAgICAgICAgICAgIHZhciBmID0gY29uc29sZVtuYW1lXTtcbiAgICAgICAgICAgICAgICBpZiAoZi5hcHBseSkgeyAvL0lFOSBkb2VzIG5vdCBzdXBwb3J0IGNvbnNvbGUubG9nLmFwcGx5IDopXG4gICAgICAgICAgICAgICAgICAgIGYuYXBwbHkoY29uc29sZSwgYXJndW1lbnRzKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgZihhcmd1bWVudHNbaV0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfTtcblxuICAgICAgICBhdHRhY2hGdW5jdGlvbihyZXBvcnRlciwgXCJsb2dcIik7XG4gICAgICAgIGF0dGFjaEZ1bmN0aW9uKHJlcG9ydGVyLCBcIndhcm5cIik7XG4gICAgICAgIGF0dGFjaEZ1bmN0aW9uKHJlcG9ydGVyLCBcImVycm9yXCIpO1xuICAgIH1cblxuICAgIHJldHVybiByZXBvcnRlcjtcbn07XG5cbi8qKiovIH0pLFxuXG4vKioqLyBcImFjNmFcIjpcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxudmFyICRpdGVyYXRvcnMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiY2FkZlwiKTtcbnZhciBnZXRLZXlzID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIjBkNThcIik7XG52YXIgcmVkZWZpbmUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiMmFiYVwiKTtcbnZhciBnbG9iYWwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiNzcyNlwiKTtcbnZhciBoaWRlID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIjMyZTlcIik7XG52YXIgSXRlcmF0b3JzID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIjg0ZjJcIik7XG52YXIgd2tzID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIjJiNGNcIik7XG52YXIgSVRFUkFUT1IgPSB3a3MoJ2l0ZXJhdG9yJyk7XG52YXIgVE9fU1RSSU5HX1RBRyA9IHdrcygndG9TdHJpbmdUYWcnKTtcbnZhciBBcnJheVZhbHVlcyA9IEl0ZXJhdG9ycy5BcnJheTtcblxudmFyIERPTUl0ZXJhYmxlcyA9IHtcbiAgQ1NTUnVsZUxpc3Q6IHRydWUsIC8vIFRPRE86IE5vdCBzcGVjIGNvbXBsaWFudCwgc2hvdWxkIGJlIGZhbHNlLlxuICBDU1NTdHlsZURlY2xhcmF0aW9uOiBmYWxzZSxcbiAgQ1NTVmFsdWVMaXN0OiBmYWxzZSxcbiAgQ2xpZW50UmVjdExpc3Q6IGZhbHNlLFxuICBET01SZWN0TGlzdDogZmFsc2UsXG4gIERPTVN0cmluZ0xpc3Q6IGZhbHNlLFxuICBET01Ub2tlbkxpc3Q6IHRydWUsXG4gIERhdGFUcmFuc2Zlckl0ZW1MaXN0OiBmYWxzZSxcbiAgRmlsZUxpc3Q6IGZhbHNlLFxuICBIVE1MQWxsQ29sbGVjdGlvbjogZmFsc2UsXG4gIEhUTUxDb2xsZWN0aW9uOiBmYWxzZSxcbiAgSFRNTEZvcm1FbGVtZW50OiBmYWxzZSxcbiAgSFRNTFNlbGVjdEVsZW1lbnQ6IGZhbHNlLFxuICBNZWRpYUxpc3Q6IHRydWUsIC8vIFRPRE86IE5vdCBzcGVjIGNvbXBsaWFudCwgc2hvdWxkIGJlIGZhbHNlLlxuICBNaW1lVHlwZUFycmF5OiBmYWxzZSxcbiAgTmFtZWROb2RlTWFwOiBmYWxzZSxcbiAgTm9kZUxpc3Q6IHRydWUsXG4gIFBhaW50UmVxdWVzdExpc3Q6IGZhbHNlLFxuICBQbHVnaW46IGZhbHNlLFxuICBQbHVnaW5BcnJheTogZmFsc2UsXG4gIFNWR0xlbmd0aExpc3Q6IGZhbHNlLFxuICBTVkdOdW1iZXJMaXN0OiBmYWxzZSxcbiAgU1ZHUGF0aFNlZ0xpc3Q6IGZhbHNlLFxuICBTVkdQb2ludExpc3Q6IGZhbHNlLFxuICBTVkdTdHJpbmdMaXN0OiBmYWxzZSxcbiAgU1ZHVHJhbnNmb3JtTGlzdDogZmFsc2UsXG4gIFNvdXJjZUJ1ZmZlckxpc3Q6IGZhbHNlLFxuICBTdHlsZVNoZWV0TGlzdDogdHJ1ZSwgLy8gVE9ETzogTm90IHNwZWMgY29tcGxpYW50LCBzaG91bGQgYmUgZmFsc2UuXG4gIFRleHRUcmFja0N1ZUxpc3Q6IGZhbHNlLFxuICBUZXh0VHJhY2tMaXN0OiBmYWxzZSxcbiAgVG91Y2hMaXN0OiBmYWxzZVxufTtcblxuZm9yICh2YXIgY29sbGVjdGlvbnMgPSBnZXRLZXlzKERPTUl0ZXJhYmxlcyksIGkgPSAwOyBpIDwgY29sbGVjdGlvbnMubGVuZ3RoOyBpKyspIHtcbiAgdmFyIE5BTUUgPSBjb2xsZWN0aW9uc1tpXTtcbiAgdmFyIGV4cGxpY2l0ID0gRE9NSXRlcmFibGVzW05BTUVdO1xuICB2YXIgQ29sbGVjdGlvbiA9IGdsb2JhbFtOQU1FXTtcbiAgdmFyIHByb3RvID0gQ29sbGVjdGlvbiAmJiBDb2xsZWN0aW9uLnByb3RvdHlwZTtcbiAgdmFyIGtleTtcbiAgaWYgKHByb3RvKSB7XG4gICAgaWYgKCFwcm90b1tJVEVSQVRPUl0pIGhpZGUocHJvdG8sIElURVJBVE9SLCBBcnJheVZhbHVlcyk7XG4gICAgaWYgKCFwcm90b1tUT19TVFJJTkdfVEFHXSkgaGlkZShwcm90bywgVE9fU1RSSU5HX1RBRywgTkFNRSk7XG4gICAgSXRlcmF0b3JzW05BTUVdID0gQXJyYXlWYWx1ZXM7XG4gICAgaWYgKGV4cGxpY2l0KSBmb3IgKGtleSBpbiAkaXRlcmF0b3JzKSBpZiAoIXByb3RvW2tleV0pIHJlZGVmaW5lKHByb3RvLCBrZXksICRpdGVyYXRvcnNba2V5XSwgdHJ1ZSk7XG4gIH1cbn1cblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCJhZDIwXCI6XG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbmV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IF9fd2VicGFja19yZXF1aXJlX18oXCIyMzUwXCIpKGZhbHNlKTtcbi8vIGltcG9ydHNcblxuXG4vLyBtb2R1bGVcbmV4cG9ydHMucHVzaChbbW9kdWxlLmksIFwiLnZ1ZS1ncmlkLWxheW91dHtwb3NpdGlvbjpyZWxhdGl2ZTstd2Via2l0LXRyYW5zaXRpb246aGVpZ2h0IC4ycyBlYXNlO3RyYW5zaXRpb246aGVpZ2h0IC4ycyBlYXNlfVwiLCBcIlwiXSk7XG5cbi8vIGV4cG9ydHNcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCJiMGM1XCI6XG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG52YXIgcmVnZXhwRXhlYyA9IF9fd2VicGFja19yZXF1aXJlX18oXCI1MjBhXCIpO1xuX193ZWJwYWNrX3JlcXVpcmVfXyhcIjVjYTFcIikoe1xuICB0YXJnZXQ6ICdSZWdFeHAnLFxuICBwcm90bzogdHJ1ZSxcbiAgZm9yY2VkOiByZWdleHBFeGVjICE9PSAvLi8uZXhlY1xufSwge1xuICBleGVjOiByZWdleHBFeGVjXG59KTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCJiNzcwXCI6XG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbnZhciB1dGlscyA9IG1vZHVsZS5leHBvcnRzID0ge307XG5cbi8qKlxuICogTG9vcHMgdGhyb3VnaCB0aGUgY29sbGVjdGlvbiBhbmQgY2FsbHMgdGhlIGNhbGxiYWNrIGZvciBlYWNoIGVsZW1lbnQuIGlmIHRoZSBjYWxsYmFjayByZXR1cm5zIHRydXRoeSwgdGhlIGxvb3AgaXMgYnJva2VuIGFuZCByZXR1cm5zIHRoZSBzYW1lIHZhbHVlLlxuICogQHB1YmxpY1xuICogQHBhcmFtIHsqfSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGxvb3AgdGhyb3VnaC4gTmVlZHMgdG8gaGF2ZSBhIGxlbmd0aCBwcm9wZXJ0eSBzZXQgYW5kIGhhdmUgaW5kaWNlcyBzZXQgZnJvbSAwIHRvIGxlbmd0aCAtIDEuXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBjYWxsYmFjayBUaGUgY2FsbGJhY2sgdG8gYmUgY2FsbGVkIGZvciBlYWNoIGVsZW1lbnQuIFRoZSBlbGVtZW50IHdpbGwgYmUgZ2l2ZW4gYXMgYSBwYXJhbWV0ZXIgdG8gdGhlIGNhbGxiYWNrLiBJZiB0aGlzIGNhbGxiYWNrIHJldHVybnMgdHJ1dGh5LCB0aGUgbG9vcCBpcyBicm9rZW4gYW5kIHRoZSBzYW1lIHZhbHVlIGlzIHJldHVybmVkLlxuICogQHJldHVybnMgeyp9IFRoZSB2YWx1ZSB0aGF0IGEgY2FsbGJhY2sgaGFzIHJldHVybmVkIChpZiB0cnV0aHkpLiBPdGhlcndpc2Ugbm90aGluZy5cbiAqL1xudXRpbHMuZm9yRWFjaCA9IGZ1bmN0aW9uKGNvbGxlY3Rpb24sIGNhbGxiYWNrKSB7XG4gICAgZm9yKHZhciBpID0gMDsgaSA8IGNvbGxlY3Rpb24ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIHJlc3VsdCA9IGNhbGxiYWNrKGNvbGxlY3Rpb25baV0pO1xuICAgICAgICBpZihyZXN1bHQpIHtcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH1cbiAgICB9XG59O1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcImJjMjFcIjpcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbi8vIE5BTUVTUEFDRSBPQkpFQ1Q6IC4vbm9kZV9tb2R1bGVzL0BpbnRlcmFjdGpzL3NuYXBwZXJzL2FsbC5qc1xudmFyIGFsbF9uYW1lc3BhY2VPYmplY3QgPSB7fTtcbl9fd2VicGFja19yZXF1aXJlX18ucihhbGxfbmFtZXNwYWNlT2JqZWN0KTtcbl9fd2VicGFja19yZXF1aXJlX18uZChhbGxfbmFtZXNwYWNlT2JqZWN0LCBcImVkZ2VUYXJnZXRcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBlZGdlVGFyZ2V0OyB9KTtcbl9fd2VicGFja19yZXF1aXJlX18uZChhbGxfbmFtZXNwYWNlT2JqZWN0LCBcImVsZW1lbnRzXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gc25hcHBlcnNfZWxlbWVudHM7IH0pO1xuX193ZWJwYWNrX3JlcXVpcmVfXy5kKGFsbF9uYW1lc3BhY2VPYmplY3QsIFwiZ3JpZFwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIGdyaWQ7IH0pO1xuXG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL25vZGVfbW9kdWxlcy9jYWNoZS1sb2FkZXIvZGlzdC9janMuanM/e1wiY2FjaGVEaXJlY3RvcnlcIjpcIm5vZGVfbW9kdWxlcy8uY2FjaGUvdnVlLWxvYWRlclwiLFwiY2FjaGVJZGVudGlmaWVyXCI6XCIwNDhlMjZjMC12dWUtbG9hZGVyLXRlbXBsYXRlXCJ9IS4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL2xvYWRlcnMvdGVtcGxhdGVMb2FkZXIuanM/P3Z1ZS1sb2FkZXItb3B0aW9ucyEuL25vZGVfbW9kdWxlcy9jYWNoZS1sb2FkZXIvZGlzdC9janMuanM/P3JlZi0tMC0wIS4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliPz92dWUtbG9hZGVyLW9wdGlvbnMhLi9zcmMvY29tcG9uZW50cy9HcmlkSXRlbS52dWU/dnVlJnR5cGU9dGVtcGxhdGUmaWQ9N2VlZDczYTQmXG52YXIgcmVuZGVyID0gZnVuY3Rpb24gKCkge3ZhciBfdm09dGhpczt2YXIgX2g9X3ZtLiRjcmVhdGVFbGVtZW50O3ZhciBfYz1fdm0uX3NlbGYuX2N8fF9oO3JldHVybiBfYygnZGl2Jyx7cmVmOlwiaXRlbVwiLHN0YXRpY0NsYXNzOlwidnVlLWdyaWQtaXRlbVwiLGNsYXNzOl92bS5jbGFzc09iaixzdHlsZTooX3ZtLnN0eWxlKX0sW192bS5fdChcImRlZmF1bHRcIiksKF92bS5yZXNpemFibGVBbmROb3RTdGF0aWMpP19jKCdzcGFuJyx7cmVmOlwiaGFuZGxlXCIsY2xhc3M6X3ZtLnJlc2l6YWJsZUhhbmRsZUNsYXNzfSk6X3ZtLl9lKCldLDIpfVxudmFyIHN0YXRpY1JlbmRlckZucyA9IFtdXG5cblxuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvY29tcG9uZW50cy9HcmlkSXRlbS52dWU/dnVlJnR5cGU9dGVtcGxhdGUmaWQ9N2VlZDczYTQmXG5cbi8vIEVYVEVSTkFMIE1PRFVMRTogLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5yZWdleHAucmVwbGFjZS5qc1xudmFyIGVzNl9yZWdleHBfcmVwbGFjZSA9IF9fd2VicGFja19yZXF1aXJlX18oXCJhNDgxXCIpO1xuXG4vLyBFWFRFUk5BTCBNT0RVTEU6IC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYucmVnZXhwLm1hdGNoLmpzXG52YXIgZXM2X3JlZ2V4cF9tYXRjaCA9IF9fd2VicGFja19yZXF1aXJlX18oXCI0OTE3XCIpO1xuXG4vLyBFWFRFUk5BTCBNT0RVTEU6IC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYubnVtYmVyLmNvbnN0cnVjdG9yLmpzXG52YXIgZXM2X251bWJlcl9jb25zdHJ1Y3RvciA9IF9fd2VicGFja19yZXF1aXJlX18oXCJjNWY2XCIpO1xuXG4vLyBFWFRFUk5BTCBNT0RVTEU6IC4vc3JjL2hlbHBlcnMvdXRpbHMuanNcbnZhciB1dGlscyA9IF9fd2VicGFja19yZXF1aXJlX18oXCJhMmI2XCIpO1xuXG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9oZWxwZXJzL2RyYWdnYWJsZVV0aWxzLmpzXG4vLyBHZXQge3gsIHl9IHBvc2l0aW9ucyBmcm9tIGV2ZW50LlxuZnVuY3Rpb24gZ2V0Q29udHJvbFBvc2l0aW9uKGUpIHtcbiAgcmV0dXJuIG9mZnNldFhZRnJvbVBhcmVudE9mKGUpO1xufSAvLyBHZXQgZnJvbSBvZmZzZXRQYXJlbnRcblxuZnVuY3Rpb24gb2Zmc2V0WFlGcm9tUGFyZW50T2YoZXZ0KSB7XG4gIHZhciBvZmZzZXRQYXJlbnQgPSBldnQudGFyZ2V0Lm9mZnNldFBhcmVudCB8fCBkb2N1bWVudC5ib2R5O1xuICB2YXIgb2Zmc2V0UGFyZW50UmVjdCA9IGV2dC5vZmZzZXRQYXJlbnQgPT09IGRvY3VtZW50LmJvZHkgPyB7XG4gICAgbGVmdDogMCxcbiAgICB0b3A6IDBcbiAgfSA6IG9mZnNldFBhcmVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgdmFyIHggPSBldnQuY2xpZW50WCArIG9mZnNldFBhcmVudC5zY3JvbGxMZWZ0IC0gb2Zmc2V0UGFyZW50UmVjdC5sZWZ0O1xuICB2YXIgeSA9IGV2dC5jbGllbnRZICsgb2Zmc2V0UGFyZW50LnNjcm9sbFRvcCAtIG9mZnNldFBhcmVudFJlY3QudG9wO1xuICAvKmNvbnN0IHggPSBNYXRoLnJvdW5kKGV2dC5jbGllbnRYICsgb2Zmc2V0UGFyZW50LnNjcm9sbExlZnQgLSBvZmZzZXRQYXJlbnRSZWN0LmxlZnQpO1xyXG4gIGNvbnN0IHkgPSBNYXRoLnJvdW5kKGV2dC5jbGllbnRZICsgb2Zmc2V0UGFyZW50LnNjcm9sbFRvcCAtIG9mZnNldFBhcmVudFJlY3QudG9wKTsqL1xuXG4gIHJldHVybiB7XG4gICAgeDogeCxcbiAgICB5OiB5XG4gIH07XG59IC8vIENyZWF0ZSBhbiBkYXRhIG9iamVjdCBleHBvc2VkIGJ5IDxEcmFnZ2FibGVDb3JlPidzIGV2ZW50c1xuXG5mdW5jdGlvbiBjcmVhdGVDb3JlRGF0YShsYXN0WCwgbGFzdFksIHgsIHkpIHtcbiAgLy8gU3RhdGUgY2hhbmdlcyBhcmUgb2Z0ZW4gKGJ1dCBub3QgYWx3YXlzISkgYXN5bmMuIFdlIHdhbnQgdGhlIGxhdGVzdCB2YWx1ZS5cbiAgdmFyIGlzU3RhcnQgPSAhaXNOdW0obGFzdFgpO1xuXG4gIGlmIChpc1N0YXJ0KSB7XG4gICAgLy8gSWYgdGhpcyBpcyBvdXIgZmlyc3QgbW92ZSwgdXNlIHRoZSB4IGFuZCB5IGFzIGxhc3QgY29vcmRzLlxuICAgIHJldHVybiB7XG4gICAgICBkZWx0YVg6IDAsXG4gICAgICBkZWx0YVk6IDAsXG4gICAgICBsYXN0WDogeCxcbiAgICAgIGxhc3RZOiB5LFxuICAgICAgeDogeCxcbiAgICAgIHk6IHlcbiAgICB9O1xuICB9IGVsc2Uge1xuICAgIC8vIE90aGVyd2lzZSBjYWxjdWxhdGUgcHJvcGVyIHZhbHVlcy5cbiAgICByZXR1cm4ge1xuICAgICAgZGVsdGFYOiB4IC0gbGFzdFgsXG4gICAgICBkZWx0YVk6IHkgLSBsYXN0WSxcbiAgICAgIGxhc3RYOiBsYXN0WCxcbiAgICAgIGxhc3RZOiBsYXN0WSxcbiAgICAgIHg6IHgsXG4gICAgICB5OiB5XG4gICAgfTtcbiAgfVxufVxuXG5mdW5jdGlvbiBpc051bShudW0pIHtcbiAgcmV0dXJuIHR5cGVvZiBudW0gPT09ICdudW1iZXInICYmICFpc05hTihudW0pO1xufVxuLy8gRVhURVJOQUwgTU9EVUxFOiAuL3NyYy9oZWxwZXJzL3Jlc3BvbnNpdmVVdGlscy5qc1xudmFyIHJlc3BvbnNpdmVVdGlscyA9IF9fd2VicGFja19yZXF1aXJlX18oXCI5N2E3XCIpO1xuXG4vLyBFWFRFUk5BTCBNT0RVTEU6IC4vc3JjL2hlbHBlcnMvRE9NLmpzXG52YXIgRE9NID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIjFjYTdcIik7XG5cbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vbm9kZV9tb2R1bGVzL0BpbnRlcmFjdGpzL3V0aWxzL2RvbU9iamVjdHMuanNcbmNvbnN0IGRvbU9iamVjdHMgPSB7XG4gIGluaXQsXG4gIGRvY3VtZW50OiBudWxsLFxuICBEb2N1bWVudEZyYWdtZW50OiBudWxsLFxuICBTVkdFbGVtZW50OiBudWxsLFxuICBTVkdTVkdFbGVtZW50OiBudWxsLFxuICBTVkdFbGVtZW50SW5zdGFuY2U6IG51bGwsXG4gIEVsZW1lbnQ6IG51bGwsXG4gIEhUTUxFbGVtZW50OiBudWxsLFxuICBFdmVudDogbnVsbCxcbiAgVG91Y2g6IG51bGwsXG4gIFBvaW50ZXJFdmVudDogbnVsbFxufTtcblxuZnVuY3Rpb24gYmxhbmsoKSB7fVxuXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIHZhciB1dGlsc19kb21PYmplY3RzID0gKGRvbU9iamVjdHMpO1xuXG5mdW5jdGlvbiBpbml0KHdpbmRvdykge1xuICBjb25zdCB3aW4gPSB3aW5kb3c7XG4gIGRvbU9iamVjdHMuZG9jdW1lbnQgPSB3aW4uZG9jdW1lbnQ7XG4gIGRvbU9iamVjdHMuRG9jdW1lbnRGcmFnbWVudCA9IHdpbi5Eb2N1bWVudEZyYWdtZW50IHx8IGJsYW5rO1xuICBkb21PYmplY3RzLlNWR0VsZW1lbnQgPSB3aW4uU1ZHRWxlbWVudCB8fCBibGFuaztcbiAgZG9tT2JqZWN0cy5TVkdTVkdFbGVtZW50ID0gd2luLlNWR1NWR0VsZW1lbnQgfHwgYmxhbms7XG4gIGRvbU9iamVjdHMuU1ZHRWxlbWVudEluc3RhbmNlID0gd2luLlNWR0VsZW1lbnRJbnN0YW5jZSB8fCBibGFuaztcbiAgZG9tT2JqZWN0cy5FbGVtZW50ID0gd2luLkVsZW1lbnQgfHwgYmxhbms7XG4gIGRvbU9iamVjdHMuSFRNTEVsZW1lbnQgPSB3aW4uSFRNTEVsZW1lbnQgfHwgZG9tT2JqZWN0cy5FbGVtZW50O1xuICBkb21PYmplY3RzLkV2ZW50ID0gd2luLkV2ZW50O1xuICBkb21PYmplY3RzLlRvdWNoID0gd2luLlRvdWNoIHx8IGJsYW5rO1xuICBkb21PYmplY3RzLlBvaW50ZXJFdmVudCA9IHdpbi5Qb2ludGVyRXZlbnQgfHwgd2luLk1TUG9pbnRlckV2ZW50O1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZG9tT2JqZWN0cy5qcy5tYXBcbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vbm9kZV9tb2R1bGVzL0BpbnRlcmFjdGpzL3V0aWxzL2lzV2luZG93LmpzXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIHZhciBpc1dpbmRvdyA9ICh0aGluZyA9PiAhISh0aGluZyAmJiB0aGluZy5XaW5kb3cpICYmIHRoaW5nIGluc3RhbmNlb2YgdGhpbmcuV2luZG93KTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWlzV2luZG93LmpzLm1hcFxuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9ub2RlX21vZHVsZXMvQGludGVyYWN0anMvdXRpbHMvd2luZG93LmpzXG5cbmxldCByZWFsV2luZG93ID0gdW5kZWZpbmVkO1xubGV0IHdpbiA9IHVuZGVmaW5lZDtcblxuZnVuY3Rpb24gd2luZG93X2luaXQod2luZG93KSB7XG4gIC8vIGdldCB3cmFwcGVkIHdpbmRvdyBpZiB1c2luZyBTaGFkb3cgRE9NIHBvbHlmaWxsXG4gIHJlYWxXaW5kb3cgPSB3aW5kb3c7IC8vIGNyZWF0ZSBhIFRleHROb2RlXG5cbiAgY29uc3QgZWwgPSB3aW5kb3cuZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoJycpOyAvLyBjaGVjayBpZiBpdCdzIHdyYXBwZWQgYnkgYSBwb2x5ZmlsbFxuXG4gIGlmIChlbC5vd25lckRvY3VtZW50ICE9PSB3aW5kb3cuZG9jdW1lbnQgJiYgdHlwZW9mIHdpbmRvdy53cmFwID09PSAnZnVuY3Rpb24nICYmIHdpbmRvdy53cmFwKGVsKSA9PT0gZWwpIHtcbiAgICAvLyB1c2Ugd3JhcHBlZCB3aW5kb3dcbiAgICB3aW5kb3cgPSB3aW5kb3cud3JhcCh3aW5kb3cpO1xuICB9XG5cbiAgd2luID0gd2luZG93O1xufVxuXG5pZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgISF3aW5kb3cpIHtcbiAgd2luZG93X2luaXQod2luZG93KTtcbn1cblxuZnVuY3Rpb24gZ2V0V2luZG93KG5vZGUpIHtcbiAgaWYgKGlzV2luZG93KG5vZGUpKSB7XG4gICAgcmV0dXJuIG5vZGU7XG4gIH1cblxuICBjb25zdCByb290Tm9kZSA9IG5vZGUub3duZXJEb2N1bWVudCB8fCBub2RlO1xuICByZXR1cm4gcm9vdE5vZGUuZGVmYXVsdFZpZXcgfHwgd2luLndpbmRvdztcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXdpbmRvdy5qcy5tYXBcbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vbm9kZV9tb2R1bGVzL0BpbnRlcmFjdGpzL3V0aWxzL2lzLmpzXG5cblxuXG5jb25zdCBpc193aW5kb3cgPSB0aGluZyA9PiB0aGluZyA9PT0gd2luIHx8IGlzV2luZG93KHRoaW5nKTtcblxuY29uc3QgZG9jRnJhZyA9IHRoaW5nID0+IG9iamVjdCh0aGluZykgJiYgdGhpbmcubm9kZVR5cGUgPT09IDExO1xuXG5jb25zdCBvYmplY3QgPSB0aGluZyA9PiAhIXRoaW5nICYmIHR5cGVvZiB0aGluZyA9PT0gJ29iamVjdCc7XG5cbmNvbnN0IGZ1bmMgPSB0aGluZyA9PiB0eXBlb2YgdGhpbmcgPT09ICdmdW5jdGlvbic7XG5cbmNvbnN0IG51bWJlciA9IHRoaW5nID0+IHR5cGVvZiB0aGluZyA9PT0gJ251bWJlcic7XG5cbmNvbnN0IGJvb2wgPSB0aGluZyA9PiB0eXBlb2YgdGhpbmcgPT09ICdib29sZWFuJztcblxuY29uc3Qgc3RyaW5nID0gdGhpbmcgPT4gdHlwZW9mIHRoaW5nID09PSAnc3RyaW5nJztcblxuY29uc3QgaXNfZWxlbWVudCA9IHRoaW5nID0+IHtcbiAgaWYgKCF0aGluZyB8fCB0eXBlb2YgdGhpbmcgIT09ICdvYmplY3QnKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBpbXBvcnQvbm8tbmFtZWQtYXMtZGVmYXVsdC1tZW1iZXJcblxuXG4gIGNvbnN0IF93aW5kb3cgPSBnZXRXaW5kb3codGhpbmcpIHx8IHdpbjtcblxuICByZXR1cm4gL29iamVjdHxmdW5jdGlvbi8udGVzdCh0eXBlb2YgX3dpbmRvdy5FbGVtZW50KSA/IHRoaW5nIGluc3RhbmNlb2YgX3dpbmRvdy5FbGVtZW50IC8vIERPTTJcbiAgOiB0aGluZy5ub2RlVHlwZSA9PT0gMSAmJiB0eXBlb2YgdGhpbmcubm9kZU5hbWUgPT09ICdzdHJpbmcnO1xufTtcblxuY29uc3QgcGxhaW5PYmplY3QgPSB0aGluZyA9PiBvYmplY3QodGhpbmcpICYmICEhdGhpbmcuY29uc3RydWN0b3IgJiYgL2Z1bmN0aW9uIE9iamVjdFxcYi8udGVzdCh0aGluZy5jb25zdHJ1Y3Rvci50b1N0cmluZygpKTtcblxuY29uc3QgYXJyYXkgPSB0aGluZyA9PiBvYmplY3QodGhpbmcpICYmIHR5cGVvZiB0aGluZy5sZW5ndGggIT09ICd1bmRlZmluZWQnICYmIGZ1bmModGhpbmcuc3BsaWNlKTtcblxuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyB2YXIgaXMgPSAoe1xuICB3aW5kb3c6IGlzX3dpbmRvdyxcbiAgZG9jRnJhZyxcbiAgb2JqZWN0LFxuICBmdW5jLFxuICBudW1iZXIsXG4gIGJvb2wsXG4gIHN0cmluZyxcbiAgZWxlbWVudDogaXNfZWxlbWVudCxcbiAgcGxhaW5PYmplY3QsXG4gIGFycmF5XG59KTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWlzLmpzLm1hcFxuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9ub2RlX21vZHVsZXMvQGludGVyYWN0anMvdXRpbHMvYnJvd3Nlci5qc1xuXG5cblxuY29uc3QgYnJvd3NlciA9IHtcbiAgaW5pdDogYnJvd3Nlcl9pbml0LFxuICBzdXBwb3J0c1RvdWNoOiBudWxsLFxuICBzdXBwb3J0c1BvaW50ZXJFdmVudDogbnVsbCxcbiAgaXNJT1M3OiBudWxsLFxuICBpc0lPUzogbnVsbCxcbiAgaXNJZTk6IG51bGwsXG4gIGlzT3BlcmFNb2JpbGU6IG51bGwsXG4gIHByZWZpeGVkTWF0Y2hlc1NlbGVjdG9yOiBudWxsLFxuICBwRXZlbnRUeXBlczogbnVsbCxcbiAgd2hlZWxFdmVudDogbnVsbFxufTtcblxuZnVuY3Rpb24gYnJvd3Nlcl9pbml0KHdpbmRvdykge1xuICBjb25zdCBFbGVtZW50ID0gdXRpbHNfZG9tT2JqZWN0cy5FbGVtZW50O1xuICBjb25zdCBuYXZpZ2F0b3IgPSB3aW4ubmF2aWdhdG9yOyAvLyBEb2VzIHRoZSBicm93c2VyIHN1cHBvcnQgdG91Y2ggaW5wdXQ/XG5cbiAgYnJvd3Nlci5zdXBwb3J0c1RvdWNoID0gJ29udG91Y2hzdGFydCcgaW4gd2luZG93IHx8IGlzLmZ1bmMod2luZG93LkRvY3VtZW50VG91Y2gpICYmIHV0aWxzX2RvbU9iamVjdHMuZG9jdW1lbnQgaW5zdGFuY2VvZiB3aW5kb3cuRG9jdW1lbnRUb3VjaDsgLy8gRG9lcyB0aGUgYnJvd3NlciBzdXBwb3J0IFBvaW50ZXJFdmVudHNcblxuICBicm93c2VyLnN1cHBvcnRzUG9pbnRlckV2ZW50ID0gbmF2aWdhdG9yLnBvaW50ZXJFbmFibGVkICE9PSBmYWxzZSAmJiAhIXV0aWxzX2RvbU9iamVjdHMuUG9pbnRlckV2ZW50O1xuICBicm93c2VyLmlzSU9TID0gL2lQKGhvbmV8b2R8YWQpLy50ZXN0KG5hdmlnYXRvci5wbGF0Zm9ybSk7IC8vIHNjcm9sbGluZyBkb2Vzbid0IGNoYW5nZSB0aGUgcmVzdWx0IG9mIGdldENsaWVudFJlY3RzIG9uIGlPUyA3XG5cbiAgYnJvd3Nlci5pc0lPUzcgPSAvaVAoaG9uZXxvZHxhZCkvLnRlc3QobmF2aWdhdG9yLnBsYXRmb3JtKSAmJiAvT1MgN1teXFxkXS8udGVzdChuYXZpZ2F0b3IuYXBwVmVyc2lvbik7XG4gIGJyb3dzZXIuaXNJZTkgPSAvTVNJRSA5Ly50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQpOyAvLyBPcGVyYSBNb2JpbGUgbXVzdCBiZSBoYW5kbGVkIGRpZmZlcmVudGx5XG5cbiAgYnJvd3Nlci5pc09wZXJhTW9iaWxlID0gbmF2aWdhdG9yLmFwcE5hbWUgPT09ICdPcGVyYScgJiYgYnJvd3Nlci5zdXBwb3J0c1RvdWNoICYmIC9QcmVzdG8vLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCk7IC8vIHByZWZpeCBtYXRjaGVzU2VsZWN0b3JcblxuICBicm93c2VyLnByZWZpeGVkTWF0Y2hlc1NlbGVjdG9yID0gJ21hdGNoZXMnIGluIEVsZW1lbnQucHJvdG90eXBlID8gJ21hdGNoZXMnIDogJ3dlYmtpdE1hdGNoZXNTZWxlY3RvcicgaW4gRWxlbWVudC5wcm90b3R5cGUgPyAnd2Via2l0TWF0Y2hlc1NlbGVjdG9yJyA6ICdtb3pNYXRjaGVzU2VsZWN0b3InIGluIEVsZW1lbnQucHJvdG90eXBlID8gJ21vek1hdGNoZXNTZWxlY3RvcicgOiAnb01hdGNoZXNTZWxlY3RvcicgaW4gRWxlbWVudC5wcm90b3R5cGUgPyAnb01hdGNoZXNTZWxlY3RvcicgOiAnbXNNYXRjaGVzU2VsZWN0b3InO1xuICBicm93c2VyLnBFdmVudFR5cGVzID0gYnJvd3Nlci5zdXBwb3J0c1BvaW50ZXJFdmVudCA/IHV0aWxzX2RvbU9iamVjdHMuUG9pbnRlckV2ZW50ID09PSB3aW5kb3cuTVNQb2ludGVyRXZlbnQgPyB7XG4gICAgdXA6ICdNU1BvaW50ZXJVcCcsXG4gICAgZG93bjogJ01TUG9pbnRlckRvd24nLFxuICAgIG92ZXI6ICdtb3VzZW92ZXInLFxuICAgIG91dDogJ21vdXNlb3V0JyxcbiAgICBtb3ZlOiAnTVNQb2ludGVyTW92ZScsXG4gICAgY2FuY2VsOiAnTVNQb2ludGVyQ2FuY2VsJ1xuICB9IDoge1xuICAgIHVwOiAncG9pbnRlcnVwJyxcbiAgICBkb3duOiAncG9pbnRlcmRvd24nLFxuICAgIG92ZXI6ICdwb2ludGVyb3ZlcicsXG4gICAgb3V0OiAncG9pbnRlcm91dCcsXG4gICAgbW92ZTogJ3BvaW50ZXJtb3ZlJyxcbiAgICBjYW5jZWw6ICdwb2ludGVyY2FuY2VsJ1xuICB9IDogbnVsbDsgLy8gYmVjYXVzZSBXZWJraXQgYW5kIE9wZXJhIHN0aWxsIHVzZSAnbW91c2V3aGVlbCcgZXZlbnQgdHlwZVxuXG4gIGJyb3dzZXIud2hlZWxFdmVudCA9ICdvbm1vdXNld2hlZWwnIGluIHV0aWxzX2RvbU9iamVjdHMuZG9jdW1lbnQgPyAnbW91c2V3aGVlbCcgOiAnd2hlZWwnO1xufVxuXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIHZhciB1dGlsc19icm93c2VyID0gKGJyb3dzZXIpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YnJvd3Nlci5qcy5tYXBcbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vbm9kZV9tb2R1bGVzL0BpbnRlcmFjdGpzL3V0aWxzL2Fyci5qc1xuY29uc3QgY29udGFpbnMgPSAoYXJyYXksIHRhcmdldCkgPT4gYXJyYXkuaW5kZXhPZih0YXJnZXQpICE9PSAtMTtcbmNvbnN0IGFycl9yZW1vdmUgPSAoYXJyYXksIHRhcmdldCkgPT4gYXJyYXkuc3BsaWNlKGFycmF5LmluZGV4T2YodGFyZ2V0KSwgMSk7XG5jb25zdCBtZXJnZSA9ICh0YXJnZXQsIHNvdXJjZSkgPT4ge1xuICBmb3IgKGNvbnN0IGl0ZW0gb2Ygc291cmNlKSB7XG4gICAgdGFyZ2V0LnB1c2goaXRlbSk7XG4gIH1cblxuICByZXR1cm4gdGFyZ2V0O1xufTtcbmNvbnN0IGZyb20gPSBzb3VyY2UgPT4gbWVyZ2UoW10sIHNvdXJjZSk7XG5jb25zdCBmaW5kSW5kZXggPSAoYXJyYXksIGZ1bmMpID0+IHtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBhcnJheS5sZW5ndGg7IGkrKykge1xuICAgIGlmIChmdW5jKGFycmF5W2ldLCBpLCBhcnJheSkpIHtcbiAgICAgIHJldHVybiBpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiAtMTtcbn07XG5jb25zdCBmaW5kID0gKGFycmF5LCBmdW5jKSA9PiBhcnJheVtmaW5kSW5kZXgoYXJyYXksIGZ1bmMpXTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWFyci5qcy5tYXBcbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vbm9kZV9tb2R1bGVzL0BpbnRlcmFjdGpzL3V0aWxzL2Nsb25lLmpzXG5cbiAvLyB0c2xpbnQ6ZGlzYWJsZS1uZXh0LWxpbmUgYmFuLXR5cGVzXG5cbmZ1bmN0aW9uIGNsb25lKHNvdXJjZSkge1xuICBjb25zdCBkZXN0ID0ge307XG5cbiAgZm9yIChjb25zdCBwcm9wIGluIHNvdXJjZSkge1xuICAgIGNvbnN0IHZhbHVlID0gc291cmNlW3Byb3BdO1xuXG4gICAgaWYgKGlzLnBsYWluT2JqZWN0KHZhbHVlKSkge1xuICAgICAgZGVzdFtwcm9wXSA9IGNsb25lKHZhbHVlKTtcbiAgICB9IGVsc2UgaWYgKGlzLmFycmF5KHZhbHVlKSkge1xuICAgICAgZGVzdFtwcm9wXSA9IGZyb20odmFsdWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICBkZXN0W3Byb3BdID0gdmFsdWU7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGRlc3Q7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jbG9uZS5qcy5tYXBcbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vbm9kZV9tb2R1bGVzL0BpbnRlcmFjdGpzL3V0aWxzL2V4dGVuZC5qc1xuZnVuY3Rpb24gZXh0ZW5kKGRlc3QsIHNvdXJjZSkge1xuICBmb3IgKGNvbnN0IHByb3AgaW4gc291cmNlKSB7XG4gICAgZGVzdFtwcm9wXSA9IHNvdXJjZVtwcm9wXTtcbiAgfVxuXG4gIGNvbnN0IHJldCA9IGRlc3Q7XG4gIHJldHVybiByZXQ7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1leHRlbmQuanMubWFwXG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL25vZGVfbW9kdWxlcy9AaW50ZXJhY3Rqcy91dGlscy9yYWYuanNcbmxldCBsYXN0VGltZSA9IDA7XG5sZXQgcmVxdWVzdDtcbmxldCBjYW5jZWw7XG5cbmZ1bmN0aW9uIHJhZl9pbml0KHdpbmRvdykge1xuICByZXF1ZXN0ID0gd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZTtcbiAgY2FuY2VsID0gd2luZG93LmNhbmNlbEFuaW1hdGlvbkZyYW1lO1xuXG4gIGlmICghcmVxdWVzdCkge1xuICAgIGNvbnN0IHZlbmRvcnMgPSBbJ21zJywgJ21veicsICd3ZWJraXQnLCAnbyddO1xuXG4gICAgZm9yIChjb25zdCB2ZW5kb3Igb2YgdmVuZG9ycykge1xuICAgICAgcmVxdWVzdCA9IHdpbmRvd1tgJHt2ZW5kb3J9UmVxdWVzdEFuaW1hdGlvbkZyYW1lYF07XG4gICAgICBjYW5jZWwgPSB3aW5kb3dbYCR7dmVuZG9yfUNhbmNlbEFuaW1hdGlvbkZyYW1lYF0gfHwgd2luZG93W2Ake3ZlbmRvcn1DYW5jZWxSZXF1ZXN0QW5pbWF0aW9uRnJhbWVgXTtcbiAgICB9XG4gIH1cblxuICByZXF1ZXN0ID0gcmVxdWVzdCAmJiByZXF1ZXN0LmJpbmQod2luZG93KTtcbiAgY2FuY2VsID0gY2FuY2VsICYmIGNhbmNlbC5iaW5kKHdpbmRvdyk7XG5cbiAgaWYgKCFyZXF1ZXN0KSB7XG4gICAgcmVxdWVzdCA9IGNhbGxiYWNrID0+IHtcbiAgICAgIGNvbnN0IGN1cnJUaW1lID0gRGF0ZS5ub3coKTtcbiAgICAgIGNvbnN0IHRpbWVUb0NhbGwgPSBNYXRoLm1heCgwLCAxNiAtIChjdXJyVGltZSAtIGxhc3RUaW1lKSk7IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBub2RlL25vLWNhbGxiYWNrLWxpdGVyYWxcblxuICAgICAgY29uc3QgdG9rZW4gPSB3aW5kb3cuc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgIGNhbGxiYWNrKGN1cnJUaW1lICsgdGltZVRvQ2FsbCk7XG4gICAgICB9LCB0aW1lVG9DYWxsKTtcbiAgICAgIGxhc3RUaW1lID0gY3VyclRpbWUgKyB0aW1lVG9DYWxsO1xuICAgICAgcmV0dXJuIHRva2VuO1xuICAgIH07XG5cbiAgICBjYW5jZWwgPSB0b2tlbiA9PiBjbGVhclRpbWVvdXQodG9rZW4pO1xuICB9XG59XG5cbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gdmFyIHJhZiA9ICh7XG4gIHJlcXVlc3Q6IGNhbGxiYWNrID0+IHJlcXVlc3QoY2FsbGJhY2spLFxuICBjYW5jZWw6IHRva2VuID0+IGNhbmNlbCh0b2tlbiksXG4gIGluaXQ6IHJhZl9pbml0XG59KTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXJhZi5qcy5tYXBcbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vbm9kZV9tb2R1bGVzL0BpbnRlcmFjdGpzL3V0aWxzL25vcm1hbGl6ZUxpc3RlbmVycy5qc1xuXG5cbmZ1bmN0aW9uIG5vcm1hbGl6ZSh0eXBlLCBsaXN0ZW5lcnMsIHJlc3VsdCkge1xuICByZXN1bHQgPSByZXN1bHQgfHwge307XG5cbiAgaWYgKGlzLnN0cmluZyh0eXBlKSAmJiB0eXBlLnNlYXJjaCgnICcpICE9PSAtMSkge1xuICAgIHR5cGUgPSBzcGxpdCh0eXBlKTtcbiAgfVxuXG4gIGlmIChpcy5hcnJheSh0eXBlKSkge1xuICAgIHJldHVybiB0eXBlLnJlZHVjZSgoYWNjLCB0KSA9PiBleHRlbmQoYWNjLCBub3JtYWxpemUodCwgbGlzdGVuZXJzLCByZXN1bHQpKSwgcmVzdWx0KTtcbiAgfSAvLyAoeyB0eXBlOiBmbiB9KSAtPiAoJycsIHsgdHlwZTogZm4gfSlcblxuXG4gIGlmIChpcy5vYmplY3QodHlwZSkpIHtcbiAgICBsaXN0ZW5lcnMgPSB0eXBlO1xuICAgIHR5cGUgPSAnJztcbiAgfVxuXG4gIGlmIChpcy5mdW5jKGxpc3RlbmVycykpIHtcbiAgICByZXN1bHRbdHlwZV0gPSByZXN1bHRbdHlwZV0gfHwgW107XG4gICAgcmVzdWx0W3R5cGVdLnB1c2gobGlzdGVuZXJzKTtcbiAgfSBlbHNlIGlmIChpcy5hcnJheShsaXN0ZW5lcnMpKSB7XG4gICAgZm9yIChjb25zdCBsIG9mIGxpc3RlbmVycykge1xuICAgICAgbm9ybWFsaXplKHR5cGUsIGwsIHJlc3VsdCk7XG4gICAgfVxuICB9IGVsc2UgaWYgKGlzLm9iamVjdChsaXN0ZW5lcnMpKSB7XG4gICAgZm9yIChjb25zdCBwcmVmaXggaW4gbGlzdGVuZXJzKSB7XG4gICAgICBjb25zdCBjb21iaW5lZFR5cGVzID0gc3BsaXQocHJlZml4KS5tYXAocCA9PiBgJHt0eXBlfSR7cH1gKTtcbiAgICAgIG5vcm1hbGl6ZShjb21iaW5lZFR5cGVzLCBsaXN0ZW5lcnNbcHJlZml4XSwgcmVzdWx0KTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5mdW5jdGlvbiBzcGxpdCh0eXBlKSB7XG4gIHJldHVybiB0eXBlLnRyaW0oKS5zcGxpdCgvICsvKTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW5vcm1hbGl6ZUxpc3RlbmVycy5qcy5tYXBcbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vbm9kZV9tb2R1bGVzL0BpbnRlcmFjdGpzL2NvcmUvRXZlbnRhYmxlLmpzXG5cblxuXG5cbmZ1bmN0aW9uIGZpcmVVbnRpbEltbWVkaWF0ZVN0b3BwZWQoZXZlbnQsIGxpc3RlbmVycykge1xuICBmb3IgKGNvbnN0IGxpc3RlbmVyIG9mIGxpc3RlbmVycykge1xuICAgIGlmIChldmVudC5pbW1lZGlhdGVQcm9wYWdhdGlvblN0b3BwZWQpIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIGxpc3RlbmVyKGV2ZW50KTtcbiAgfVxufVxuXG5jbGFzcyBFdmVudGFibGVfRXZlbnRhYmxlIHtcbiAgY29uc3RydWN0b3Iob3B0aW9ucykge1xuICAgIHRoaXMub3B0aW9ucyA9IHZvaWQgMDtcbiAgICB0aGlzLnR5cGVzID0ge307XG4gICAgdGhpcy5wcm9wYWdhdGlvblN0b3BwZWQgPSBmYWxzZTtcbiAgICB0aGlzLmltbWVkaWF0ZVByb3BhZ2F0aW9uU3RvcHBlZCA9IGZhbHNlO1xuICAgIHRoaXMuZ2xvYmFsID0gdm9pZCAwO1xuICAgIHRoaXMub3B0aW9ucyA9IGV4dGVuZCh7fSwgb3B0aW9ucyB8fCB7fSk7XG4gIH1cblxuICBmaXJlKGV2ZW50KSB7XG4gICAgbGV0IGxpc3RlbmVycztcbiAgICBjb25zdCBnbG9iYWwgPSB0aGlzLmdsb2JhbDsgLy8gSW50ZXJhY3RhYmxlI29uKCkgbGlzdGVuZXJzXG4gICAgLy8gdHNsaW50OmRpc2FibGUgbm8tY29uZGl0aW9uYWwtYXNzaWdubWVudFxuXG4gICAgaWYgKGxpc3RlbmVycyA9IHRoaXMudHlwZXNbZXZlbnQudHlwZV0pIHtcbiAgICAgIGZpcmVVbnRpbEltbWVkaWF0ZVN0b3BwZWQoZXZlbnQsIGxpc3RlbmVycyk7XG4gICAgfSAvLyBpbnRlcmFjdC5vbigpIGxpc3RlbmVyc1xuXG5cbiAgICBpZiAoIWV2ZW50LnByb3BhZ2F0aW9uU3RvcHBlZCAmJiBnbG9iYWwgJiYgKGxpc3RlbmVycyA9IGdsb2JhbFtldmVudC50eXBlXSkpIHtcbiAgICAgIGZpcmVVbnRpbEltbWVkaWF0ZVN0b3BwZWQoZXZlbnQsIGxpc3RlbmVycyk7XG4gICAgfVxuICB9XG5cbiAgb24odHlwZSwgbGlzdGVuZXIpIHtcbiAgICBjb25zdCBsaXN0ZW5lcnMgPSBub3JtYWxpemUodHlwZSwgbGlzdGVuZXIpO1xuXG4gICAgZm9yICh0eXBlIGluIGxpc3RlbmVycykge1xuICAgICAgdGhpcy50eXBlc1t0eXBlXSA9IG1lcmdlKHRoaXMudHlwZXNbdHlwZV0gfHwgW10sIGxpc3RlbmVyc1t0eXBlXSk7XG4gICAgfVxuICB9XG5cbiAgb2ZmKHR5cGUsIGxpc3RlbmVyKSB7XG4gICAgY29uc3QgbGlzdGVuZXJzID0gbm9ybWFsaXplKHR5cGUsIGxpc3RlbmVyKTtcblxuICAgIGZvciAodHlwZSBpbiBsaXN0ZW5lcnMpIHtcbiAgICAgIGNvbnN0IGV2ZW50TGlzdCA9IHRoaXMudHlwZXNbdHlwZV07XG5cbiAgICAgIGlmICghZXZlbnRMaXN0IHx8ICFldmVudExpc3QubGVuZ3RoKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICBmb3IgKGNvbnN0IHN1Ykxpc3RlbmVyIG9mIGxpc3RlbmVyc1t0eXBlXSkge1xuICAgICAgICBjb25zdCBpbmRleCA9IGV2ZW50TGlzdC5pbmRleE9mKHN1Ykxpc3RlbmVyKTtcblxuICAgICAgICBpZiAoaW5kZXggIT09IC0xKSB7XG4gICAgICAgICAgZXZlbnRMaXN0LnNwbGljZShpbmRleCwgMSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBnZXRSZWN0KF9lbGVtZW50KSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9RXZlbnRhYmxlLmpzLm1hcFxuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9ub2RlX21vZHVsZXMvQGludGVyYWN0anMvdXRpbHMvZG9tVXRpbHMuanNcblxuXG5cblxuZnVuY3Rpb24gbm9kZUNvbnRhaW5zKHBhcmVudCwgY2hpbGQpIHtcbiAgaWYgKHBhcmVudC5jb250YWlucykge1xuICAgIHJldHVybiBwYXJlbnQuY29udGFpbnMoY2hpbGQpO1xuICB9XG5cbiAgd2hpbGUgKGNoaWxkKSB7XG4gICAgaWYgKGNoaWxkID09PSBwYXJlbnQpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIGNoaWxkID0gY2hpbGQucGFyZW50Tm9kZTtcbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cbmZ1bmN0aW9uIGRvbVV0aWxzX2Nsb3Nlc3QoZWxlbWVudCwgc2VsZWN0b3IpIHtcbiAgd2hpbGUgKGlzLmVsZW1lbnQoZWxlbWVudCkpIHtcbiAgICBpZiAobWF0Y2hlc1NlbGVjdG9yKGVsZW1lbnQsIHNlbGVjdG9yKSkge1xuICAgICAgcmV0dXJuIGVsZW1lbnQ7XG4gICAgfVxuXG4gICAgZWxlbWVudCA9IHBhcmVudE5vZGUoZWxlbWVudCk7XG4gIH1cblxuICByZXR1cm4gbnVsbDtcbn1cbmZ1bmN0aW9uIHBhcmVudE5vZGUobm9kZSkge1xuICBsZXQgcGFyZW50ID0gbm9kZS5wYXJlbnROb2RlO1xuXG4gIGlmIChpcy5kb2NGcmFnKHBhcmVudCkpIHtcbiAgICAvLyBza2lwIHBhc3QgI3NoYWRvLXJvb3QgZnJhZ21lbnRzXG4gICAgLy8gdHNsaW50OmRpc2FibGUtbmV4dC1saW5lXG4gICAgd2hpbGUgKChwYXJlbnQgPSBwYXJlbnQuaG9zdCkgJiYgaXMuZG9jRnJhZyhwYXJlbnQpKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICByZXR1cm4gcGFyZW50O1xuICB9XG5cbiAgcmV0dXJuIHBhcmVudDtcbn1cbmZ1bmN0aW9uIG1hdGNoZXNTZWxlY3RvcihlbGVtZW50LCBzZWxlY3Rvcikge1xuICAvLyByZW1vdmUgL2RlZXAvIGZyb20gc2VsZWN0b3JzIGlmIHNoYWRvd0RPTSBwb2x5ZmlsbCBpcyB1c2VkXG4gIGlmICh3aW4gIT09IHJlYWxXaW5kb3cpIHtcbiAgICBzZWxlY3RvciA9IHNlbGVjdG9yLnJlcGxhY2UoL1xcL2RlZXBcXC8vZywgJyAnKTtcbiAgfVxuXG4gIHJldHVybiBlbGVtZW50W3V0aWxzX2Jyb3dzZXIucHJlZml4ZWRNYXRjaGVzU2VsZWN0b3JdKHNlbGVjdG9yKTtcbn1cblxuY29uc3QgZ2V0UGFyZW50ID0gZWwgPT4gZWwucGFyZW50Tm9kZSB8fCBlbC5ob3N0OyAvLyBUZXN0IGZvciB0aGUgZWxlbWVudCB0aGF0J3MgXCJhYm92ZVwiIGFsbCBvdGhlciBxdWFsaWZpZXJzXG5cblxuZnVuY3Rpb24gaW5kZXhPZkRlZXBlc3RFbGVtZW50KGVsZW1lbnRzKSB7XG4gIGxldCBkZWVwZXN0Tm9kZVBhcmVudHMgPSBbXTtcbiAgbGV0IGRlZXBlc3ROb2RlSW5kZXg7XG5cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBlbGVtZW50cy5sZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IGN1cnJlbnROb2RlID0gZWxlbWVudHNbaV07XG4gICAgY29uc3QgZGVlcGVzdE5vZGUgPSBlbGVtZW50c1tkZWVwZXN0Tm9kZUluZGV4XTsgLy8gbm9kZSBtYXkgYXBwZWFyIGluIGVsZW1lbnRzIGFycmF5IG11bHRpcGxlIHRpbWVzXG5cbiAgICBpZiAoIWN1cnJlbnROb2RlIHx8IGkgPT09IGRlZXBlc3ROb2RlSW5kZXgpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIGlmICghZGVlcGVzdE5vZGUpIHtcbiAgICAgIGRlZXBlc3ROb2RlSW5kZXggPSBpO1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgY29uc3QgY3VycmVudE5vZGVQYXJlbnQgPSBnZXRQYXJlbnQoY3VycmVudE5vZGUpO1xuICAgIGNvbnN0IGRlZXBlc3ROb2RlUGFyZW50ID0gZ2V0UGFyZW50KGRlZXBlc3ROb2RlKTsgLy8gY2hlY2sgaWYgdGhlIGRlZXBlc3Qgb3IgY3VycmVudCBhcmUgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50L3Jvb3RFbGVtZW50XG4gICAgLy8gLSBpZiB0aGUgY3VycmVudCBub2RlIGlzLCBkbyBub3RoaW5nIGFuZCBjb250aW51ZVxuXG4gICAgaWYgKGN1cnJlbnROb2RlUGFyZW50ID09PSBjdXJyZW50Tm9kZS5vd25lckRvY3VtZW50KSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9IC8vIC0gaWYgZGVlcGVzdCBpcywgdXBkYXRlIHdpdGggdGhlIGN1cnJlbnQgbm9kZSBhbmQgY29udGludWUgdG8gbmV4dFxuICAgIGVsc2UgaWYgKGRlZXBlc3ROb2RlUGFyZW50ID09PSBjdXJyZW50Tm9kZS5vd25lckRvY3VtZW50KSB7XG4gICAgICAgIGRlZXBlc3ROb2RlSW5kZXggPSBpO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH0gLy8gY29tcGFyZSB6SW5kZXggb2Ygc2libGluZ3NcblxuXG4gICAgaWYgKGN1cnJlbnROb2RlUGFyZW50ID09PSBkZWVwZXN0Tm9kZVBhcmVudCkge1xuICAgICAgaWYgKHpJbmRleElzSGlnaGVyVGhhbihjdXJyZW50Tm9kZSwgZGVlcGVzdE5vZGUpKSB7XG4gICAgICAgIGRlZXBlc3ROb2RlSW5kZXggPSBpO1xuICAgICAgfVxuXG4gICAgICBjb250aW51ZTtcbiAgICB9IC8vIHBvcHVsYXRlIHRoZSBhbmNlc3RyeSBhcnJheSBmb3IgdGhlIGxhdGVzdCBkZWVwZXN0IG5vZGVcblxuXG4gICAgZGVlcGVzdE5vZGVQYXJlbnRzID0gZGVlcGVzdE5vZGVQYXJlbnRzLmxlbmd0aCA/IGRlZXBlc3ROb2RlUGFyZW50cyA6IGdldE5vZGVQYXJlbnRzKGRlZXBlc3ROb2RlKTtcbiAgICBsZXQgYW5jZXN0cnlTdGFydDsgLy8gaWYgdGhlIGRlZXBlc3Qgbm9kZSBpcyBhbiBIVE1MRWxlbWVudCBhbmQgdGhlIGN1cnJlbnQgbm9kZSBpcyBhIG5vbiByb290IHN2ZyBlbGVtZW50XG5cbiAgICBpZiAoZGVlcGVzdE5vZGUgaW5zdGFuY2VvZiB1dGlsc19kb21PYmplY3RzLkhUTUxFbGVtZW50ICYmIGN1cnJlbnROb2RlIGluc3RhbmNlb2YgdXRpbHNfZG9tT2JqZWN0cy5TVkdFbGVtZW50ICYmICEoY3VycmVudE5vZGUgaW5zdGFuY2VvZiB1dGlsc19kb21PYmplY3RzLlNWR1NWR0VsZW1lbnQpKSB7XG4gICAgICAvLyBUT0RPOiBpcyB0aGlzIGNoZWNrIG5lY2Vzc2FyeT8gV2FzIHRoaXMgZm9yIEhUTUwgZWxlbWVudHMgZW1iZWRkZWQgaW4gU1ZHP1xuICAgICAgaWYgKGN1cnJlbnROb2RlID09PSBkZWVwZXN0Tm9kZVBhcmVudCkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgYW5jZXN0cnlTdGFydCA9IGN1cnJlbnROb2RlLm93bmVyU1ZHRWxlbWVudDtcbiAgICB9IGVsc2Uge1xuICAgICAgYW5jZXN0cnlTdGFydCA9IGN1cnJlbnROb2RlO1xuICAgIH1cblxuICAgIGNvbnN0IGN1cnJlbnROb2RlUGFyZW50cyA9IGdldE5vZGVQYXJlbnRzKGFuY2VzdHJ5U3RhcnQsIGRlZXBlc3ROb2RlLm93bmVyRG9jdW1lbnQpO1xuICAgIGxldCBjb21tb25JbmRleCA9IDA7IC8vIGdldCAocG9zaXRpb24gb2YgY2xvc2VzdCBjb21tb24gYW5jZXN0b3IpICsgMVxuXG4gICAgd2hpbGUgKGN1cnJlbnROb2RlUGFyZW50c1tjb21tb25JbmRleF0gJiYgY3VycmVudE5vZGVQYXJlbnRzW2NvbW1vbkluZGV4XSA9PT0gZGVlcGVzdE5vZGVQYXJlbnRzW2NvbW1vbkluZGV4XSkge1xuICAgICAgY29tbW9uSW5kZXgrKztcbiAgICB9XG5cbiAgICBjb25zdCBwYXJlbnRzID0gW2N1cnJlbnROb2RlUGFyZW50c1tjb21tb25JbmRleCAtIDFdLCBjdXJyZW50Tm9kZVBhcmVudHNbY29tbW9uSW5kZXhdLCBkZWVwZXN0Tm9kZVBhcmVudHNbY29tbW9uSW5kZXhdXTtcbiAgICBsZXQgY2hpbGQgPSBwYXJlbnRzWzBdLmxhc3RDaGlsZDtcblxuICAgIHdoaWxlIChjaGlsZCkge1xuICAgICAgaWYgKGNoaWxkID09PSBwYXJlbnRzWzFdKSB7XG4gICAgICAgIGRlZXBlc3ROb2RlSW5kZXggPSBpO1xuICAgICAgICBkZWVwZXN0Tm9kZVBhcmVudHMgPSBjdXJyZW50Tm9kZVBhcmVudHM7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfSBlbHNlIGlmIChjaGlsZCA9PT0gcGFyZW50c1syXSkge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgICAgY2hpbGQgPSBjaGlsZC5wcmV2aW91c1NpYmxpbmc7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGRlZXBlc3ROb2RlSW5kZXg7XG59XG5cbmZ1bmN0aW9uIGdldE5vZGVQYXJlbnRzKG5vZGUsIGxpbWl0KSB7XG4gIGNvbnN0IHBhcmVudHMgPSBbXTtcbiAgbGV0IHBhcmVudCA9IG5vZGU7XG4gIGxldCBwYXJlbnRQYXJlbnQ7XG5cbiAgd2hpbGUgKChwYXJlbnRQYXJlbnQgPSBnZXRQYXJlbnQocGFyZW50KSkgJiYgcGFyZW50ICE9PSBsaW1pdCAmJiBwYXJlbnRQYXJlbnQgIT09IHBhcmVudC5vd25lckRvY3VtZW50KSB7XG4gICAgcGFyZW50cy51bnNoaWZ0KHBhcmVudCk7XG4gICAgcGFyZW50ID0gcGFyZW50UGFyZW50O1xuICB9XG5cbiAgcmV0dXJuIHBhcmVudHM7XG59XG5cbmZ1bmN0aW9uIHpJbmRleElzSGlnaGVyVGhhbihoaWdoZXJOb2RlLCBsb3dlck5vZGUpIHtcbiAgY29uc3QgaGlnaGVySW5kZXggPSBwYXJzZUludChnZXRXaW5kb3coaGlnaGVyTm9kZSkuZ2V0Q29tcHV0ZWRTdHlsZShoaWdoZXJOb2RlKS56SW5kZXgsIDEwKSB8fCAwO1xuICBjb25zdCBsb3dlckluZGV4ID0gcGFyc2VJbnQoZ2V0V2luZG93KGxvd2VyTm9kZSkuZ2V0Q29tcHV0ZWRTdHlsZShsb3dlck5vZGUpLnpJbmRleCwgMTApIHx8IDA7XG4gIHJldHVybiBoaWdoZXJJbmRleCA+PSBsb3dlckluZGV4O1xufVxuXG5mdW5jdGlvbiBtYXRjaGVzVXBUbyhlbGVtZW50LCBzZWxlY3RvciwgbGltaXQpIHtcbiAgd2hpbGUgKGlzLmVsZW1lbnQoZWxlbWVudCkpIHtcbiAgICBpZiAobWF0Y2hlc1NlbGVjdG9yKGVsZW1lbnQsIHNlbGVjdG9yKSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgZWxlbWVudCA9IHBhcmVudE5vZGUoZWxlbWVudCk7XG5cbiAgICBpZiAoZWxlbWVudCA9PT0gbGltaXQpIHtcbiAgICAgIHJldHVybiBtYXRjaGVzU2VsZWN0b3IoZWxlbWVudCwgc2VsZWN0b3IpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cbmZ1bmN0aW9uIGdldEFjdHVhbEVsZW1lbnQoZWxlbWVudCkge1xuICByZXR1cm4gZWxlbWVudC5jb3JyZXNwb25kaW5nVXNlRWxlbWVudCB8fCBlbGVtZW50O1xufVxuZnVuY3Rpb24gZ2V0U2Nyb2xsWFkocmVsZXZhbnRXaW5kb3cpIHtcbiAgcmVsZXZhbnRXaW5kb3cgPSByZWxldmFudFdpbmRvdyB8fCB3aW47XG4gIHJldHVybiB7XG4gICAgeDogcmVsZXZhbnRXaW5kb3cuc2Nyb2xsWCB8fCByZWxldmFudFdpbmRvdy5kb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc2Nyb2xsTGVmdCxcbiAgICB5OiByZWxldmFudFdpbmRvdy5zY3JvbGxZIHx8IHJlbGV2YW50V2luZG93LmRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zY3JvbGxUb3BcbiAgfTtcbn1cbmZ1bmN0aW9uIGdldEVsZW1lbnRDbGllbnRSZWN0KGVsZW1lbnQpIHtcbiAgY29uc3QgY2xpZW50UmVjdCA9IGVsZW1lbnQgaW5zdGFuY2VvZiB1dGlsc19kb21PYmplY3RzLlNWR0VsZW1lbnQgPyBlbGVtZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpIDogZWxlbWVudC5nZXRDbGllbnRSZWN0cygpWzBdO1xuICByZXR1cm4gY2xpZW50UmVjdCAmJiB7XG4gICAgbGVmdDogY2xpZW50UmVjdC5sZWZ0LFxuICAgIHJpZ2h0OiBjbGllbnRSZWN0LnJpZ2h0LFxuICAgIHRvcDogY2xpZW50UmVjdC50b3AsXG4gICAgYm90dG9tOiBjbGllbnRSZWN0LmJvdHRvbSxcbiAgICB3aWR0aDogY2xpZW50UmVjdC53aWR0aCB8fCBjbGllbnRSZWN0LnJpZ2h0IC0gY2xpZW50UmVjdC5sZWZ0LFxuICAgIGhlaWdodDogY2xpZW50UmVjdC5oZWlnaHQgfHwgY2xpZW50UmVjdC5ib3R0b20gLSBjbGllbnRSZWN0LnRvcFxuICB9O1xufVxuZnVuY3Rpb24gZ2V0RWxlbWVudFJlY3QoZWxlbWVudCkge1xuICBjb25zdCBjbGllbnRSZWN0ID0gZ2V0RWxlbWVudENsaWVudFJlY3QoZWxlbWVudCk7XG5cbiAgaWYgKCF1dGlsc19icm93c2VyLmlzSU9TNyAmJiBjbGllbnRSZWN0KSB7XG4gICAgY29uc3Qgc2Nyb2xsID0gZ2V0U2Nyb2xsWFkoZ2V0V2luZG93KGVsZW1lbnQpKTtcbiAgICBjbGllbnRSZWN0LmxlZnQgKz0gc2Nyb2xsLng7XG4gICAgY2xpZW50UmVjdC5yaWdodCArPSBzY3JvbGwueDtcbiAgICBjbGllbnRSZWN0LnRvcCArPSBzY3JvbGwueTtcbiAgICBjbGllbnRSZWN0LmJvdHRvbSArPSBzY3JvbGwueTtcbiAgfVxuXG4gIHJldHVybiBjbGllbnRSZWN0O1xufVxuZnVuY3Rpb24gZ2V0UGF0aChub2RlKSB7XG4gIGNvbnN0IHBhdGggPSBbXTtcblxuICB3aGlsZSAobm9kZSkge1xuICAgIHBhdGgucHVzaChub2RlKTtcbiAgICBub2RlID0gcGFyZW50Tm9kZShub2RlKTtcbiAgfVxuXG4gIHJldHVybiBwYXRoO1xufVxuZnVuY3Rpb24gdHJ5U2VsZWN0b3IodmFsdWUpIHtcbiAgaWYgKCFpcy5zdHJpbmcodmFsdWUpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9IC8vIGFuIGV4Y2VwdGlvbiB3aWxsIGJlIHJhaXNlZCBpZiBpdCBpcyBpbnZhbGlkXG5cblxuICB1dGlsc19kb21PYmplY3RzLmRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IodmFsdWUpO1xuICByZXR1cm4gdHJ1ZTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRvbVV0aWxzLmpzLm1hcFxuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9ub2RlX21vZHVsZXMvQGludGVyYWN0anMvdXRpbHMvcmVjdC5qc1xuXG5cblxuZnVuY3Rpb24gZ2V0U3RyaW5nT3B0aW9uUmVzdWx0KHZhbHVlLCB0YXJnZXQsIGVsZW1lbnQpIHtcbiAgaWYgKHZhbHVlID09PSAncGFyZW50Jykge1xuICAgIHJldHVybiBwYXJlbnROb2RlKGVsZW1lbnQpO1xuICB9XG5cbiAgaWYgKHZhbHVlID09PSAnc2VsZicpIHtcbiAgICByZXR1cm4gdGFyZ2V0LmdldFJlY3QoZWxlbWVudCk7XG4gIH1cblxuICByZXR1cm4gZG9tVXRpbHNfY2xvc2VzdChlbGVtZW50LCB2YWx1ZSk7XG59XG5mdW5jdGlvbiByZXNvbHZlUmVjdExpa2UodmFsdWUsIHRhcmdldCwgZWxlbWVudCwgZnVuY3Rpb25BcmdzKSB7XG4gIGxldCByZXR1cm5WYWx1ZSA9IHZhbHVlO1xuXG4gIGlmIChpcy5zdHJpbmcocmV0dXJuVmFsdWUpKSB7XG4gICAgcmV0dXJuVmFsdWUgPSBnZXRTdHJpbmdPcHRpb25SZXN1bHQocmV0dXJuVmFsdWUsIHRhcmdldCwgZWxlbWVudCk7XG4gIH0gZWxzZSBpZiAoaXMuZnVuYyhyZXR1cm5WYWx1ZSkpIHtcbiAgICByZXR1cm5WYWx1ZSA9IHJldHVyblZhbHVlKC4uLmZ1bmN0aW9uQXJncyk7XG4gIH1cblxuICBpZiAoaXMuZWxlbWVudChyZXR1cm5WYWx1ZSkpIHtcbiAgICByZXR1cm5WYWx1ZSA9IGdldEVsZW1lbnRSZWN0KHJldHVyblZhbHVlKTtcbiAgfVxuXG4gIHJldHVybiByZXR1cm5WYWx1ZTtcbn1cbmZ1bmN0aW9uIHJlY3RUb1hZKHJlY3QpIHtcbiAgcmV0dXJuIHJlY3QgJiYge1xuICAgIHg6ICd4JyBpbiByZWN0ID8gcmVjdC54IDogcmVjdC5sZWZ0LFxuICAgIHk6ICd5JyBpbiByZWN0ID8gcmVjdC55IDogcmVjdC50b3BcbiAgfTtcbn1cbmZ1bmN0aW9uIHh5d2hUb1RsYnIocmVjdCkge1xuICBpZiAocmVjdCAmJiAhKCdsZWZ0JyBpbiByZWN0ICYmICd0b3AnIGluIHJlY3QpKSB7XG4gICAgcmVjdCA9IGV4dGVuZCh7fSwgcmVjdCk7XG4gICAgcmVjdC5sZWZ0ID0gcmVjdC54IHx8IDA7XG4gICAgcmVjdC50b3AgPSByZWN0LnkgfHwgMDtcbiAgICByZWN0LnJpZ2h0ID0gcmVjdC5yaWdodCB8fCByZWN0LmxlZnQgKyByZWN0LndpZHRoO1xuICAgIHJlY3QuYm90dG9tID0gcmVjdC5ib3R0b20gfHwgcmVjdC50b3AgKyByZWN0LmhlaWdodDtcbiAgfVxuXG4gIHJldHVybiByZWN0O1xufVxuZnVuY3Rpb24gdGxiclRvWHl3aChyZWN0KSB7XG4gIGlmIChyZWN0ICYmICEoJ3gnIGluIHJlY3QgJiYgJ3knIGluIHJlY3QpKSB7XG4gICAgcmVjdCA9IGV4dGVuZCh7fSwgcmVjdCk7XG4gICAgcmVjdC54ID0gcmVjdC5sZWZ0IHx8IDA7XG4gICAgcmVjdC55ID0gcmVjdC50b3AgfHwgMDtcbiAgICByZWN0LndpZHRoID0gcmVjdC53aWR0aCB8fCAocmVjdC5yaWdodCB8fCAwKSAtIHJlY3QueDtcbiAgICByZWN0LmhlaWdodCA9IHJlY3QuaGVpZ2h0IHx8IChyZWN0LmJvdHRvbSB8fCAwKSAtIHJlY3QueTtcbiAgfVxuXG4gIHJldHVybiByZWN0O1xufVxuZnVuY3Rpb24gYWRkRWRnZXMoZWRnZXMsIHJlY3QsIGRlbHRhKSB7XG4gIGlmIChlZGdlcy5sZWZ0KSB7XG4gICAgcmVjdC5sZWZ0ICs9IGRlbHRhLng7XG4gIH1cblxuICBpZiAoZWRnZXMucmlnaHQpIHtcbiAgICByZWN0LnJpZ2h0ICs9IGRlbHRhLng7XG4gIH1cblxuICBpZiAoZWRnZXMudG9wKSB7XG4gICAgcmVjdC50b3AgKz0gZGVsdGEueTtcbiAgfVxuXG4gIGlmIChlZGdlcy5ib3R0b20pIHtcbiAgICByZWN0LmJvdHRvbSArPSBkZWx0YS55O1xuICB9XG5cbiAgcmVjdC53aWR0aCA9IHJlY3QucmlnaHQgLSByZWN0LmxlZnQ7XG4gIHJlY3QuaGVpZ2h0ID0gcmVjdC5ib3R0b20gLSByZWN0LnRvcDtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXJlY3QuanMubWFwXG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL25vZGVfbW9kdWxlcy9AaW50ZXJhY3Rqcy91dGlscy9nZXRPcmlnaW5YWS5qc1xuXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIHZhciBnZXRPcmlnaW5YWSA9IChmdW5jdGlvbiAodGFyZ2V0LCBlbGVtZW50LCBhY3Rpb25OYW1lKSB7XG4gIGNvbnN0IGFjdGlvbk9wdGlvbnMgPSB0YXJnZXQub3B0aW9uc1thY3Rpb25OYW1lXTtcbiAgY29uc3QgYWN0aW9uT3JpZ2luID0gYWN0aW9uT3B0aW9ucyAmJiBhY3Rpb25PcHRpb25zLm9yaWdpbjtcbiAgY29uc3Qgb3JpZ2luID0gYWN0aW9uT3JpZ2luIHx8IHRhcmdldC5vcHRpb25zLm9yaWdpbjtcbiAgY29uc3Qgb3JpZ2luUmVjdCA9IHJlc29sdmVSZWN0TGlrZShvcmlnaW4sIHRhcmdldCwgZWxlbWVudCwgW3RhcmdldCAmJiBlbGVtZW50XSk7XG4gIHJldHVybiByZWN0VG9YWShvcmlnaW5SZWN0KSB8fCB7XG4gICAgeDogMCxcbiAgICB5OiAwXG4gIH07XG59KTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWdldE9yaWdpblhZLmpzLm1hcFxuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9ub2RlX21vZHVsZXMvQGludGVyYWN0anMvdXRpbHMvaHlwb3QuanNcbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gdmFyIGh5cG90ID0gKCh4LCB5KSA9PiBNYXRoLnNxcnQoeCAqIHggKyB5ICogeSkpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aHlwb3QuanMubWFwXG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL25vZGVfbW9kdWxlcy9AaW50ZXJhY3Rqcy9jb3JlL0Jhc2VFdmVudC5qc1xuY2xhc3MgQmFzZUV2ZW50IHtcbiAgY29uc3RydWN0b3IoaW50ZXJhY3Rpb24pIHtcbiAgICB0aGlzLnR5cGUgPSB2b2lkIDA7XG4gICAgdGhpcy50YXJnZXQgPSB2b2lkIDA7XG4gICAgdGhpcy5jdXJyZW50VGFyZ2V0ID0gdm9pZCAwO1xuICAgIHRoaXMuaW50ZXJhY3RhYmxlID0gdm9pZCAwO1xuICAgIHRoaXMuX2ludGVyYWN0aW9uID0gdm9pZCAwO1xuICAgIHRoaXMudGltZVN0YW1wID0gdm9pZCAwO1xuICAgIHRoaXMuaW1tZWRpYXRlUHJvcGFnYXRpb25TdG9wcGVkID0gZmFsc2U7XG4gICAgdGhpcy5wcm9wYWdhdGlvblN0b3BwZWQgPSBmYWxzZTtcbiAgICB0aGlzLl9pbnRlcmFjdGlvbiA9IGludGVyYWN0aW9uO1xuICB9XG5cbiAgcHJldmVudERlZmF1bHQoKSB7fVxuICAvKipcbiAgICogRG9uJ3QgY2FsbCBhbnkgb3RoZXIgbGlzdGVuZXJzIChldmVuIG9uIHRoZSBjdXJyZW50IHRhcmdldClcbiAgICovXG5cblxuICBzdG9wUHJvcGFnYXRpb24oKSB7XG4gICAgdGhpcy5wcm9wYWdhdGlvblN0b3BwZWQgPSB0cnVlO1xuICB9XG4gIC8qKlxuICAgKiBEb24ndCBjYWxsIGxpc3RlbmVycyBvbiB0aGUgcmVtYWluaW5nIHRhcmdldHNcbiAgICovXG5cblxuICBzdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24oKSB7XG4gICAgdGhpcy5pbW1lZGlhdGVQcm9wYWdhdGlvblN0b3BwZWQgPSB0aGlzLnByb3BhZ2F0aW9uU3RvcHBlZCA9IHRydWU7XG4gIH1cblxufSAvLyBkZWZpbmVkIG91dHNpZGUgb2YgY2xhc3MgZGVmaW5pdGlvbiB0byBhdm9pZCBhc3NpZ25tZW50IG9mIHVuZGVmaW5lZCBkdXJpbmdcbi8vIGNvbnN0cnVjdGlvblxuXG4vLyBnZXR0ZXJzIGFuZCBzZXR0ZXJzIGRlZmluZWQgaGVyZSB0byBzdXBwb3J0IHR5cGVzY3JpcHQgMy42IGFuZCBiZWxvdyB3aGljaFxuLy8gZG9uJ3Qgc3VwcG9ydCBnZXR0ZXIgYW5kIHNldHRlcnMgaW4gLmQudHMgZmlsZXNcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShCYXNlRXZlbnQucHJvdG90eXBlLCAnaW50ZXJhY3Rpb24nLCB7XG4gIGdldCgpIHtcbiAgICByZXR1cm4gdGhpcy5faW50ZXJhY3Rpb24uX3Byb3h5O1xuICB9LFxuXG4gIHNldCgpIHt9XG5cbn0pO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9QmFzZUV2ZW50LmpzLm1hcFxuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9ub2RlX21vZHVsZXMvQGludGVyYWN0anMvY29yZS9kZWZhdWx0T3B0aW9ucy5qc1xuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1lbXB0eS1pbnRlcmZhY2Vcbi8vIGV4cG9ydCBpbnRlcmZhY2UgT3B0aW9ucyBleHRlbmRzIEJhc2VEZWZhdWx0cywgUGVyQWN0aW9uRGVmYXVsdHMge31cbmNvbnN0IGRlZmF1bHRPcHRpb25zX2RlZmF1bHRzID0ge1xuICBiYXNlOiB7XG4gICAgcHJldmVudERlZmF1bHQ6ICdhdXRvJyxcbiAgICBkZWx0YVNvdXJjZTogJ3BhZ2UnXG4gIH0sXG4gIHBlckFjdGlvbjoge1xuICAgIGVuYWJsZWQ6IGZhbHNlLFxuICAgIG9yaWdpbjoge1xuICAgICAgeDogMCxcbiAgICAgIHk6IDBcbiAgICB9XG4gIH0sXG4gIGFjdGlvbnM6IHt9XG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZGVmYXVsdE9wdGlvbnMuanMubWFwXG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL25vZGVfbW9kdWxlcy9AaW50ZXJhY3Rqcy9jb3JlL0ludGVyYWN0RXZlbnQuanNcblxuXG5cblxuXG5jbGFzcyBJbnRlcmFjdEV2ZW50X0ludGVyYWN0RXZlbnQgZXh0ZW5kcyBCYXNlRXZlbnQge1xuICAvLyByZXNpemVcblxuICAvKiogKi9cbiAgY29uc3RydWN0b3IoaW50ZXJhY3Rpb24sIGV2ZW50LCBhY3Rpb25OYW1lLCBwaGFzZSwgZWxlbWVudCwgcHJlRW5kLCB0eXBlKSB7XG4gICAgc3VwZXIoaW50ZXJhY3Rpb24pO1xuICAgIHRoaXMudGFyZ2V0ID0gdm9pZCAwO1xuICAgIHRoaXMuY3VycmVudFRhcmdldCA9IHZvaWQgMDtcbiAgICB0aGlzLnJlbGF0ZWRUYXJnZXQgPSBudWxsO1xuICAgIHRoaXMuc2NyZWVuWCA9IHZvaWQgMDtcbiAgICB0aGlzLnNjcmVlblkgPSB2b2lkIDA7XG4gICAgdGhpcy5idXR0b24gPSB2b2lkIDA7XG4gICAgdGhpcy5idXR0b25zID0gdm9pZCAwO1xuICAgIHRoaXMuY3RybEtleSA9IHZvaWQgMDtcbiAgICB0aGlzLnNoaWZ0S2V5ID0gdm9pZCAwO1xuICAgIHRoaXMuYWx0S2V5ID0gdm9pZCAwO1xuICAgIHRoaXMubWV0YUtleSA9IHZvaWQgMDtcbiAgICB0aGlzLnBhZ2UgPSB2b2lkIDA7XG4gICAgdGhpcy5jbGllbnQgPSB2b2lkIDA7XG4gICAgdGhpcy5kZWx0YSA9IHZvaWQgMDtcbiAgICB0aGlzLnJlY3QgPSB2b2lkIDA7XG4gICAgdGhpcy54MCA9IHZvaWQgMDtcbiAgICB0aGlzLnkwID0gdm9pZCAwO1xuICAgIHRoaXMudDAgPSB2b2lkIDA7XG4gICAgdGhpcy5kdCA9IHZvaWQgMDtcbiAgICB0aGlzLmR1cmF0aW9uID0gdm9pZCAwO1xuICAgIHRoaXMuY2xpZW50WDAgPSB2b2lkIDA7XG4gICAgdGhpcy5jbGllbnRZMCA9IHZvaWQgMDtcbiAgICB0aGlzLnZlbG9jaXR5ID0gdm9pZCAwO1xuICAgIHRoaXMuc3BlZWQgPSB2b2lkIDA7XG4gICAgdGhpcy5zd2lwZSA9IHZvaWQgMDtcbiAgICB0aGlzLnRpbWVTdGFtcCA9IHZvaWQgMDtcbiAgICB0aGlzLmF4ZXMgPSB2b2lkIDA7XG4gICAgdGhpcy5wcmVFbmQgPSB2b2lkIDA7XG4gICAgZWxlbWVudCA9IGVsZW1lbnQgfHwgaW50ZXJhY3Rpb24uZWxlbWVudDtcbiAgICBjb25zdCB0YXJnZXQgPSBpbnRlcmFjdGlvbi5pbnRlcmFjdGFibGU7XG4gICAgY29uc3QgZGVsdGFTb3VyY2UgPSAodGFyZ2V0ICYmIHRhcmdldC5vcHRpb25zIHx8IGRlZmF1bHRPcHRpb25zX2RlZmF1bHRzKS5kZWx0YVNvdXJjZTtcbiAgICBjb25zdCBvcmlnaW4gPSBnZXRPcmlnaW5YWSh0YXJnZXQsIGVsZW1lbnQsIGFjdGlvbk5hbWUpO1xuICAgIGNvbnN0IHN0YXJ0aW5nID0gcGhhc2UgPT09ICdzdGFydCc7XG4gICAgY29uc3QgZW5kaW5nID0gcGhhc2UgPT09ICdlbmQnO1xuICAgIGNvbnN0IHByZXZFdmVudCA9IHN0YXJ0aW5nID8gdGhpcyA6IGludGVyYWN0aW9uLnByZXZFdmVudDtcbiAgICBjb25zdCBjb29yZHMgPSBzdGFydGluZyA/IGludGVyYWN0aW9uLmNvb3Jkcy5zdGFydCA6IGVuZGluZyA/IHtcbiAgICAgIHBhZ2U6IHByZXZFdmVudC5wYWdlLFxuICAgICAgY2xpZW50OiBwcmV2RXZlbnQuY2xpZW50LFxuICAgICAgdGltZVN0YW1wOiBpbnRlcmFjdGlvbi5jb29yZHMuY3VyLnRpbWVTdGFtcFxuICAgIH0gOiBpbnRlcmFjdGlvbi5jb29yZHMuY3VyO1xuICAgIHRoaXMucGFnZSA9IGV4dGVuZCh7fSwgY29vcmRzLnBhZ2UpO1xuICAgIHRoaXMuY2xpZW50ID0gZXh0ZW5kKHt9LCBjb29yZHMuY2xpZW50KTtcbiAgICB0aGlzLnJlY3QgPSBleHRlbmQoe30sIGludGVyYWN0aW9uLnJlY3QpO1xuICAgIHRoaXMudGltZVN0YW1wID0gY29vcmRzLnRpbWVTdGFtcDtcblxuICAgIGlmICghZW5kaW5nKSB7XG4gICAgICB0aGlzLnBhZ2UueCAtPSBvcmlnaW4ueDtcbiAgICAgIHRoaXMucGFnZS55IC09IG9yaWdpbi55O1xuICAgICAgdGhpcy5jbGllbnQueCAtPSBvcmlnaW4ueDtcbiAgICAgIHRoaXMuY2xpZW50LnkgLT0gb3JpZ2luLnk7XG4gICAgfVxuXG4gICAgdGhpcy5jdHJsS2V5ID0gZXZlbnQuY3RybEtleTtcbiAgICB0aGlzLmFsdEtleSA9IGV2ZW50LmFsdEtleTtcbiAgICB0aGlzLnNoaWZ0S2V5ID0gZXZlbnQuc2hpZnRLZXk7XG4gICAgdGhpcy5tZXRhS2V5ID0gZXZlbnQubWV0YUtleTtcbiAgICB0aGlzLmJ1dHRvbiA9IGV2ZW50LmJ1dHRvbjtcbiAgICB0aGlzLmJ1dHRvbnMgPSBldmVudC5idXR0b25zO1xuICAgIHRoaXMudGFyZ2V0ID0gZWxlbWVudDtcbiAgICB0aGlzLmN1cnJlbnRUYXJnZXQgPSBlbGVtZW50O1xuICAgIHRoaXMucHJlRW5kID0gcHJlRW5kO1xuICAgIHRoaXMudHlwZSA9IHR5cGUgfHwgYWN0aW9uTmFtZSArIChwaGFzZSB8fCAnJyk7XG4gICAgdGhpcy5pbnRlcmFjdGFibGUgPSB0YXJnZXQ7XG4gICAgdGhpcy50MCA9IHN0YXJ0aW5nID8gaW50ZXJhY3Rpb24ucG9pbnRlcnNbaW50ZXJhY3Rpb24ucG9pbnRlcnMubGVuZ3RoIC0gMV0uZG93blRpbWUgOiBwcmV2RXZlbnQudDA7XG4gICAgdGhpcy54MCA9IGludGVyYWN0aW9uLmNvb3Jkcy5zdGFydC5wYWdlLnggLSBvcmlnaW4ueDtcbiAgICB0aGlzLnkwID0gaW50ZXJhY3Rpb24uY29vcmRzLnN0YXJ0LnBhZ2UueSAtIG9yaWdpbi55O1xuICAgIHRoaXMuY2xpZW50WDAgPSBpbnRlcmFjdGlvbi5jb29yZHMuc3RhcnQuY2xpZW50LnggLSBvcmlnaW4ueDtcbiAgICB0aGlzLmNsaWVudFkwID0gaW50ZXJhY3Rpb24uY29vcmRzLnN0YXJ0LmNsaWVudC55IC0gb3JpZ2luLnk7XG5cbiAgICBpZiAoc3RhcnRpbmcgfHwgZW5kaW5nKSB7XG4gICAgICB0aGlzLmRlbHRhID0ge1xuICAgICAgICB4OiAwLFxuICAgICAgICB5OiAwXG4gICAgICB9O1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmRlbHRhID0ge1xuICAgICAgICB4OiB0aGlzW2RlbHRhU291cmNlXS54IC0gcHJldkV2ZW50W2RlbHRhU291cmNlXS54LFxuICAgICAgICB5OiB0aGlzW2RlbHRhU291cmNlXS55IC0gcHJldkV2ZW50W2RlbHRhU291cmNlXS55XG4gICAgICB9O1xuICAgIH1cblxuICAgIHRoaXMuZHQgPSBpbnRlcmFjdGlvbi5jb29yZHMuZGVsdGEudGltZVN0YW1wO1xuICAgIHRoaXMuZHVyYXRpb24gPSB0aGlzLnRpbWVTdGFtcCAtIHRoaXMudDA7IC8vIHZlbG9jaXR5IGFuZCBzcGVlZCBpbiBwaXhlbHMgcGVyIHNlY29uZFxuXG4gICAgdGhpcy52ZWxvY2l0eSA9IGV4dGVuZCh7fSwgaW50ZXJhY3Rpb24uY29vcmRzLnZlbG9jaXR5W2RlbHRhU291cmNlXSk7XG4gICAgdGhpcy5zcGVlZCA9IGh5cG90KHRoaXMudmVsb2NpdHkueCwgdGhpcy52ZWxvY2l0eS55KTtcbiAgICB0aGlzLnN3aXBlID0gZW5kaW5nIHx8IHBoYXNlID09PSAnaW5lcnRpYXN0YXJ0JyA/IHRoaXMuZ2V0U3dpcGUoKSA6IG51bGw7XG4gIH1cblxuICBnZXRTd2lwZSgpIHtcbiAgICBjb25zdCBpbnRlcmFjdGlvbiA9IHRoaXMuX2ludGVyYWN0aW9uO1xuXG4gICAgaWYgKGludGVyYWN0aW9uLnByZXZFdmVudC5zcGVlZCA8IDYwMCB8fCB0aGlzLnRpbWVTdGFtcCAtIGludGVyYWN0aW9uLnByZXZFdmVudC50aW1lU3RhbXAgPiAxNTApIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIGxldCBhbmdsZSA9IDE4MCAqIE1hdGguYXRhbjIoaW50ZXJhY3Rpb24ucHJldkV2ZW50LnZlbG9jaXR5WSwgaW50ZXJhY3Rpb24ucHJldkV2ZW50LnZlbG9jaXR5WCkgLyBNYXRoLlBJO1xuICAgIGNvbnN0IG92ZXJsYXAgPSAyMi41O1xuXG4gICAgaWYgKGFuZ2xlIDwgMCkge1xuICAgICAgYW5nbGUgKz0gMzYwO1xuICAgIH1cblxuICAgIGNvbnN0IGxlZnQgPSAxMzUgLSBvdmVybGFwIDw9IGFuZ2xlICYmIGFuZ2xlIDwgMjI1ICsgb3ZlcmxhcDtcbiAgICBjb25zdCB1cCA9IDIyNSAtIG92ZXJsYXAgPD0gYW5nbGUgJiYgYW5nbGUgPCAzMTUgKyBvdmVybGFwO1xuICAgIGNvbnN0IHJpZ2h0ID0gIWxlZnQgJiYgKDMxNSAtIG92ZXJsYXAgPD0gYW5nbGUgfHwgYW5nbGUgPCA0NSArIG92ZXJsYXApO1xuICAgIGNvbnN0IGRvd24gPSAhdXAgJiYgNDUgLSBvdmVybGFwIDw9IGFuZ2xlICYmIGFuZ2xlIDwgMTM1ICsgb3ZlcmxhcDtcbiAgICByZXR1cm4ge1xuICAgICAgdXAsXG4gICAgICBkb3duLFxuICAgICAgbGVmdCxcbiAgICAgIHJpZ2h0LFxuICAgICAgYW5nbGUsXG4gICAgICBzcGVlZDogaW50ZXJhY3Rpb24ucHJldkV2ZW50LnNwZWVkLFxuICAgICAgdmVsb2NpdHk6IHtcbiAgICAgICAgeDogaW50ZXJhY3Rpb24ucHJldkV2ZW50LnZlbG9jaXR5WCxcbiAgICAgICAgeTogaW50ZXJhY3Rpb24ucHJldkV2ZW50LnZlbG9jaXR5WVxuICAgICAgfVxuICAgIH07XG4gIH1cblxuICBwcmV2ZW50RGVmYXVsdCgpIHt9XG4gIC8qKlxuICAgKiBEb24ndCBjYWxsIGxpc3RlbmVycyBvbiB0aGUgcmVtYWluaW5nIHRhcmdldHNcbiAgICovXG5cblxuICBzdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24oKSB7XG4gICAgdGhpcy5pbW1lZGlhdGVQcm9wYWdhdGlvblN0b3BwZWQgPSB0aGlzLnByb3BhZ2F0aW9uU3RvcHBlZCA9IHRydWU7XG4gIH1cbiAgLyoqXG4gICAqIERvbid0IGNhbGwgYW55IG90aGVyIGxpc3RlbmVycyAoZXZlbiBvbiB0aGUgY3VycmVudCB0YXJnZXQpXG4gICAqL1xuXG5cbiAgc3RvcFByb3BhZ2F0aW9uKCkge1xuICAgIHRoaXMucHJvcGFnYXRpb25TdG9wcGVkID0gdHJ1ZTtcbiAgfVxuXG59IC8vIGdldHRlcnMgYW5kIHNldHRlcnMgZGVmaW5lZCBoZXJlIHRvIHN1cHBvcnQgdHlwZXNjcmlwdCAzLjYgYW5kIGJlbG93IHdoaWNoXG4vLyBkb24ndCBzdXBwb3J0IGdldHRlciBhbmQgc2V0dGVycyBpbiAuZC50cyBmaWxlc1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydGllcyhJbnRlcmFjdEV2ZW50X0ludGVyYWN0RXZlbnQucHJvdG90eXBlLCB7XG4gIHBhZ2VYOiB7XG4gICAgZ2V0KCkge1xuICAgICAgcmV0dXJuIHRoaXMucGFnZS54O1xuICAgIH0sXG5cbiAgICBzZXQodmFsdWUpIHtcbiAgICAgIHRoaXMucGFnZS54ID0gdmFsdWU7XG4gICAgfVxuXG4gIH0sXG4gIHBhZ2VZOiB7XG4gICAgZ2V0KCkge1xuICAgICAgcmV0dXJuIHRoaXMucGFnZS55O1xuICAgIH0sXG5cbiAgICBzZXQodmFsdWUpIHtcbiAgICAgIHRoaXMucGFnZS55ID0gdmFsdWU7XG4gICAgfVxuXG4gIH0sXG4gIGNsaWVudFg6IHtcbiAgICBnZXQoKSB7XG4gICAgICByZXR1cm4gdGhpcy5jbGllbnQueDtcbiAgICB9LFxuXG4gICAgc2V0KHZhbHVlKSB7XG4gICAgICB0aGlzLmNsaWVudC54ID0gdmFsdWU7XG4gICAgfVxuXG4gIH0sXG4gIGNsaWVudFk6IHtcbiAgICBnZXQoKSB7XG4gICAgICByZXR1cm4gdGhpcy5jbGllbnQueTtcbiAgICB9LFxuXG4gICAgc2V0KHZhbHVlKSB7XG4gICAgICB0aGlzLmNsaWVudC55ID0gdmFsdWU7XG4gICAgfVxuXG4gIH0sXG4gIGR4OiB7XG4gICAgZ2V0KCkge1xuICAgICAgcmV0dXJuIHRoaXMuZGVsdGEueDtcbiAgICB9LFxuXG4gICAgc2V0KHZhbHVlKSB7XG4gICAgICB0aGlzLmRlbHRhLnggPSB2YWx1ZTtcbiAgICB9XG5cbiAgfSxcbiAgZHk6IHtcbiAgICBnZXQoKSB7XG4gICAgICByZXR1cm4gdGhpcy5kZWx0YS55O1xuICAgIH0sXG5cbiAgICBzZXQodmFsdWUpIHtcbiAgICAgIHRoaXMuZGVsdGEueSA9IHZhbHVlO1xuICAgIH1cblxuICB9LFxuICB2ZWxvY2l0eVg6IHtcbiAgICBnZXQoKSB7XG4gICAgICByZXR1cm4gdGhpcy52ZWxvY2l0eS54O1xuICAgIH0sXG5cbiAgICBzZXQodmFsdWUpIHtcbiAgICAgIHRoaXMudmVsb2NpdHkueCA9IHZhbHVlO1xuICAgIH1cblxuICB9LFxuICB2ZWxvY2l0eVk6IHtcbiAgICBnZXQoKSB7XG4gICAgICByZXR1cm4gdGhpcy52ZWxvY2l0eS55O1xuICAgIH0sXG5cbiAgICBzZXQodmFsdWUpIHtcbiAgICAgIHRoaXMudmVsb2NpdHkueSA9IHZhbHVlO1xuICAgIH1cblxuICB9XG59KTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUludGVyYWN0RXZlbnQuanMubWFwXG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL25vZGVfbW9kdWxlcy9AaW50ZXJhY3Rqcy9jb3JlL2lzTm9uTmF0aXZlRXZlbnQuanNcbmZ1bmN0aW9uIGlzTm9uTmF0aXZlRXZlbnQodHlwZSwgYWN0aW9ucykge1xuICBpZiAoYWN0aW9ucy5waGFzZWxlc3NUeXBlc1t0eXBlXSkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgZm9yIChjb25zdCBuYW1lIGluIGFjdGlvbnMubWFwKSB7XG4gICAgaWYgKHR5cGUuaW5kZXhPZihuYW1lKSA9PT0gMCAmJiB0eXBlLnN1YnN0cihuYW1lLmxlbmd0aCkgaW4gYWN0aW9ucy5waGFzZXMpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWlzTm9uTmF0aXZlRXZlbnQuanMubWFwXG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL25vZGVfbW9kdWxlcy9AaW50ZXJhY3Rqcy9jb3JlL0ludGVyYWN0YWJsZS5qc1xuLyogZXNsaW50LWRpc2FibGUgbm8tZHVwZS1jbGFzcy1tZW1iZXJzICovXG5cblxuXG5cblxuXG5cblxuXG5cblxuLyoqICovXG5jbGFzcyBJbnRlcmFjdGFibGVfSW50ZXJhY3RhYmxlIHtcbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBnZXQgX2RlZmF1bHRzKCkge1xuICAgIHJldHVybiB7XG4gICAgICBiYXNlOiB7fSxcbiAgICAgIHBlckFjdGlvbjoge30sXG4gICAgICBhY3Rpb25zOiB7fVxuICAgIH07XG4gIH1cblxuICAvKiogKi9cbiAgY29uc3RydWN0b3IodGFyZ2V0LCBvcHRpb25zLCBkZWZhdWx0Q29udGV4dCwgc2NvcGVFdmVudHMpIHtcbiAgICB0aGlzLm9wdGlvbnMgPSB2b2lkIDA7XG4gICAgdGhpcy5fYWN0aW9ucyA9IHZvaWQgMDtcbiAgICB0aGlzLnRhcmdldCA9IHZvaWQgMDtcbiAgICB0aGlzLmV2ZW50cyA9IG5ldyBFdmVudGFibGVfRXZlbnRhYmxlKCk7XG4gICAgdGhpcy5fY29udGV4dCA9IHZvaWQgMDtcbiAgICB0aGlzLl93aW4gPSB2b2lkIDA7XG4gICAgdGhpcy5fZG9jID0gdm9pZCAwO1xuICAgIHRoaXMuX3Njb3BlRXZlbnRzID0gdm9pZCAwO1xuICAgIHRoaXMuX3JlY3RDaGVja2VyID0gdm9pZCAwO1xuICAgIHRoaXMuX2FjdGlvbnMgPSBvcHRpb25zLmFjdGlvbnM7XG4gICAgdGhpcy50YXJnZXQgPSB0YXJnZXQ7XG4gICAgdGhpcy5fY29udGV4dCA9IG9wdGlvbnMuY29udGV4dCB8fCBkZWZhdWx0Q29udGV4dDtcbiAgICB0aGlzLl93aW4gPSBnZXRXaW5kb3codHJ5U2VsZWN0b3IodGFyZ2V0KSA/IHRoaXMuX2NvbnRleHQgOiB0YXJnZXQpO1xuICAgIHRoaXMuX2RvYyA9IHRoaXMuX3dpbi5kb2N1bWVudDtcbiAgICB0aGlzLl9zY29wZUV2ZW50cyA9IHNjb3BlRXZlbnRzO1xuICAgIHRoaXMuc2V0KG9wdGlvbnMpO1xuICB9XG5cbiAgc2V0T25FdmVudHMoYWN0aW9uTmFtZSwgcGhhc2VzKSB7XG4gICAgaWYgKGlzLmZ1bmMocGhhc2VzLm9uc3RhcnQpKSB7XG4gICAgICB0aGlzLm9uKGAke2FjdGlvbk5hbWV9c3RhcnRgLCBwaGFzZXMub25zdGFydCk7XG4gICAgfVxuXG4gICAgaWYgKGlzLmZ1bmMocGhhc2VzLm9ubW92ZSkpIHtcbiAgICAgIHRoaXMub24oYCR7YWN0aW9uTmFtZX1tb3ZlYCwgcGhhc2VzLm9ubW92ZSk7XG4gICAgfVxuXG4gICAgaWYgKGlzLmZ1bmMocGhhc2VzLm9uZW5kKSkge1xuICAgICAgdGhpcy5vbihgJHthY3Rpb25OYW1lfWVuZGAsIHBoYXNlcy5vbmVuZCk7XG4gICAgfVxuXG4gICAgaWYgKGlzLmZ1bmMocGhhc2VzLm9uaW5lcnRpYXN0YXJ0KSkge1xuICAgICAgdGhpcy5vbihgJHthY3Rpb25OYW1lfWluZXJ0aWFzdGFydGAsIHBoYXNlcy5vbmluZXJ0aWFzdGFydCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICB1cGRhdGVQZXJBY3Rpb25MaXN0ZW5lcnMoYWN0aW9uTmFtZSwgcHJldiwgY3VyKSB7XG4gICAgaWYgKGlzLmFycmF5KHByZXYpIHx8IGlzLm9iamVjdChwcmV2KSkge1xuICAgICAgdGhpcy5vZmYoYWN0aW9uTmFtZSwgcHJldik7XG4gICAgfVxuXG4gICAgaWYgKGlzLmFycmF5KGN1cikgfHwgaXMub2JqZWN0KGN1cikpIHtcbiAgICAgIHRoaXMub24oYWN0aW9uTmFtZSwgY3VyKTtcbiAgICB9XG4gIH1cblxuICBzZXRQZXJBY3Rpb24oYWN0aW9uTmFtZSwgb3B0aW9ucykge1xuICAgIGNvbnN0IGRlZmF1bHRzID0gdGhpcy5fZGVmYXVsdHM7IC8vIGZvciBhbGwgdGhlIGRlZmF1bHQgcGVyLWFjdGlvbiBvcHRpb25zXG5cbiAgICBmb3IgKGNvbnN0IG9wdGlvbk5hbWVfIGluIG9wdGlvbnMpIHtcbiAgICAgIGNvbnN0IG9wdGlvbk5hbWUgPSBvcHRpb25OYW1lXztcbiAgICAgIGNvbnN0IGFjdGlvbk9wdGlvbnMgPSB0aGlzLm9wdGlvbnNbYWN0aW9uTmFtZV07XG4gICAgICBjb25zdCBvcHRpb25WYWx1ZSA9IG9wdGlvbnNbb3B0aW9uTmFtZV07IC8vIHJlbW92ZSBvbGQgZXZlbnQgbGlzdGVuZXJzIGFuZCBhZGQgbmV3IG9uZXNcblxuICAgICAgaWYgKG9wdGlvbk5hbWUgPT09ICdsaXN0ZW5lcnMnKSB7XG4gICAgICAgIHRoaXMudXBkYXRlUGVyQWN0aW9uTGlzdGVuZXJzKGFjdGlvbk5hbWUsIGFjdGlvbk9wdGlvbnMubGlzdGVuZXJzLCBvcHRpb25WYWx1ZSk7XG4gICAgICB9IC8vIGlmIHRoZSBvcHRpb24gdmFsdWUgaXMgYW4gYXJyYXlcblxuXG4gICAgICBpZiAoaXMuYXJyYXkob3B0aW9uVmFsdWUpKSB7XG4gICAgICAgIGFjdGlvbk9wdGlvbnNbb3B0aW9uTmFtZV0gPSBmcm9tKG9wdGlvblZhbHVlKTtcbiAgICAgIH0gLy8gaWYgdGhlIG9wdGlvbiB2YWx1ZSBpcyBhbiBvYmplY3RcbiAgICAgIGVsc2UgaWYgKGlzLnBsYWluT2JqZWN0KG9wdGlvblZhbHVlKSkge1xuICAgICAgICAgIC8vIGNvcHkgdGhlIG9iamVjdFxuICAgICAgICAgIGFjdGlvbk9wdGlvbnNbb3B0aW9uTmFtZV0gPSBleHRlbmQoYWN0aW9uT3B0aW9uc1tvcHRpb25OYW1lXSB8fCB7fSwgY2xvbmUob3B0aW9uVmFsdWUpKTsgLy8gc2V0IGFuYWJsZWQgZmllbGQgdG8gdHJ1ZSBpZiBpdCBleGlzdHMgaW4gdGhlIGRlZmF1bHRzXG5cbiAgICAgICAgICBpZiAoaXMub2JqZWN0KGRlZmF1bHRzLnBlckFjdGlvbltvcHRpb25OYW1lXSkgJiYgJ2VuYWJsZWQnIGluIGRlZmF1bHRzLnBlckFjdGlvbltvcHRpb25OYW1lXSkge1xuICAgICAgICAgICAgYWN0aW9uT3B0aW9uc1tvcHRpb25OYW1lXS5lbmFibGVkID0gb3B0aW9uVmFsdWUuZW5hYmxlZCAhPT0gZmFsc2U7XG4gICAgICAgICAgfVxuICAgICAgICB9IC8vIGlmIHRoZSBvcHRpb24gdmFsdWUgaXMgYSBib29sZWFuIGFuZCB0aGUgZGVmYXVsdCBpcyBhbiBvYmplY3RcbiAgICAgICAgZWxzZSBpZiAoaXMuYm9vbChvcHRpb25WYWx1ZSkgJiYgaXMub2JqZWN0KGRlZmF1bHRzLnBlckFjdGlvbltvcHRpb25OYW1lXSkpIHtcbiAgICAgICAgICAgIGFjdGlvbk9wdGlvbnNbb3B0aW9uTmFtZV0uZW5hYmxlZCA9IG9wdGlvblZhbHVlO1xuICAgICAgICAgIH0gLy8gaWYgaXQncyBhbnl0aGluZyBlbHNlLCBkbyBhIHBsYWluIGFzc2lnbm1lbnRcbiAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgYWN0aW9uT3B0aW9uc1tvcHRpb25OYW1lXSA9IG9wdGlvblZhbHVlO1xuICAgICAgICAgICAgfVxuICAgIH1cbiAgfVxuICAvKipcbiAgICogVGhlIGRlZmF1bHQgZnVuY3Rpb24gdG8gZ2V0IGFuIEludGVyYWN0YWJsZXMgYm91bmRpbmcgcmVjdC4gQ2FuIGJlXG4gICAqIG92ZXJyaWRkZW4gdXNpbmcge0BsaW5rIEludGVyYWN0YWJsZS5yZWN0Q2hlY2tlcn0uXG4gICAqXG4gICAqIEBwYXJhbSB7RWxlbWVudH0gW2VsZW1lbnRdIFRoZSBlbGVtZW50IHRvIG1lYXN1cmUuXG4gICAqIEByZXR1cm4ge1JlY3R9IFRoZSBvYmplY3QncyBib3VuZGluZyByZWN0YW5nbGUuXG4gICAqL1xuXG5cbiAgZ2V0UmVjdChlbGVtZW50KSB7XG4gICAgZWxlbWVudCA9IGVsZW1lbnQgfHwgKGlzLmVsZW1lbnQodGhpcy50YXJnZXQpID8gdGhpcy50YXJnZXQgOiBudWxsKTtcblxuICAgIGlmIChpcy5zdHJpbmcodGhpcy50YXJnZXQpKSB7XG4gICAgICBlbGVtZW50ID0gZWxlbWVudCB8fCB0aGlzLl9jb250ZXh0LnF1ZXJ5U2VsZWN0b3IodGhpcy50YXJnZXQpO1xuICAgIH1cblxuICAgIHJldHVybiBnZXRFbGVtZW50UmVjdChlbGVtZW50KTtcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyBvciBzZXRzIHRoZSBmdW5jdGlvbiB1c2VkIHRvIGNhbGN1bGF0ZSB0aGUgaW50ZXJhY3RhYmxlJ3NcbiAgICogZWxlbWVudCdzIHJlY3RhbmdsZVxuICAgKlxuICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBbY2hlY2tlcl0gQSBmdW5jdGlvbiB3aGljaCByZXR1cm5zIHRoaXMgSW50ZXJhY3RhYmxlJ3NcbiAgICogYm91bmRpbmcgcmVjdGFuZ2xlLiBTZWUge0BsaW5rIEludGVyYWN0YWJsZS5nZXRSZWN0fVxuICAgKiBAcmV0dXJuIHtmdW5jdGlvbiB8IG9iamVjdH0gVGhlIGNoZWNrZXIgZnVuY3Rpb24gb3IgdGhpcyBJbnRlcmFjdGFibGVcbiAgICovXG5cblxuICByZWN0Q2hlY2tlcihjaGVja2VyKSB7XG4gICAgaWYgKGlzLmZ1bmMoY2hlY2tlcikpIHtcbiAgICAgIHRoaXMuX3JlY3RDaGVja2VyID0gY2hlY2tlcjtcblxuICAgICAgdGhpcy5nZXRSZWN0ID0gZWxlbWVudCA9PiB7XG4gICAgICAgIGNvbnN0IHJlY3QgPSBleHRlbmQoe30sIHRoaXMuX3JlY3RDaGVja2VyKGVsZW1lbnQpKTtcblxuICAgICAgICBpZiAoISgnd2lkdGgnIGluIHJlY3QpKSB7XG4gICAgICAgICAgcmVjdC53aWR0aCA9IHJlY3QucmlnaHQgLSByZWN0LmxlZnQ7XG4gICAgICAgICAgcmVjdC5oZWlnaHQgPSByZWN0LmJvdHRvbSAtIHJlY3QudG9wO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHJlY3Q7XG4gICAgICB9O1xuXG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICBpZiAoY2hlY2tlciA9PT0gbnVsbCkge1xuICAgICAgZGVsZXRlIHRoaXMuZ2V0UmVjdDtcbiAgICAgIGRlbGV0ZSB0aGlzLl9yZWN0Q2hlY2tlcjtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLmdldFJlY3Q7XG4gIH1cblxuICBfYmFja0NvbXBhdE9wdGlvbihvcHRpb25OYW1lLCBuZXdWYWx1ZSkge1xuICAgIGlmICh0cnlTZWxlY3RvcihuZXdWYWx1ZSkgfHwgaXMub2JqZWN0KG5ld1ZhbHVlKSkge1xuICAgICAgdGhpcy5vcHRpb25zW29wdGlvbk5hbWVdID0gbmV3VmFsdWU7XG5cbiAgICAgIGZvciAoY29uc3QgYWN0aW9uIGluIHRoaXMuX2FjdGlvbnMubWFwKSB7XG4gICAgICAgIHRoaXMub3B0aW9uc1thY3Rpb25dW29wdGlvbk5hbWVdID0gbmV3VmFsdWU7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLm9wdGlvbnNbb3B0aW9uTmFtZV07XG4gIH1cbiAgLyoqXG4gICAqIEdldHMgb3Igc2V0cyB0aGUgb3JpZ2luIG9mIHRoZSBJbnRlcmFjdGFibGUncyBlbGVtZW50LiAgVGhlIHggYW5kIHlcbiAgICogb2YgdGhlIG9yaWdpbiB3aWxsIGJlIHN1YnRyYWN0ZWQgZnJvbSBhY3Rpb24gZXZlbnQgY29vcmRpbmF0ZXMuXG4gICAqXG4gICAqIEBwYXJhbSB7RWxlbWVudCB8IG9iamVjdCB8IHN0cmluZ30gW29yaWdpbl0gQW4gSFRNTCBvciBTVkcgRWxlbWVudCB3aG9zZVxuICAgKiByZWN0IHdpbGwgYmUgdXNlZCwgYW4gb2JqZWN0IGVnLiB7IHg6IDAsIHk6IDAgfSBvciBzdHJpbmcgJ3BhcmVudCcsICdzZWxmJ1xuICAgKiBvciBhbnkgQ1NTIHNlbGVjdG9yXG4gICAqXG4gICAqIEByZXR1cm4ge29iamVjdH0gVGhlIGN1cnJlbnQgb3JpZ2luIG9yIHRoaXMgSW50ZXJhY3RhYmxlXG4gICAqL1xuXG5cbiAgb3JpZ2luKG5ld1ZhbHVlKSB7XG4gICAgcmV0dXJuIHRoaXMuX2JhY2tDb21wYXRPcHRpb24oJ29yaWdpbicsIG5ld1ZhbHVlKTtcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyBvciBzZXRzIHRoZSBtb3VzZSBjb29yZGluYXRlIHR5cGVzIHVzZWQgdG8gY2FsY3VsYXRlIHRoZVxuICAgKiBtb3ZlbWVudCBvZiB0aGUgcG9pbnRlci5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IFtuZXdWYWx1ZV0gVXNlICdjbGllbnQnIGlmIHlvdSB3aWxsIGJlIHNjcm9sbGluZyB3aGlsZVxuICAgKiBpbnRlcmFjdGluZzsgVXNlICdwYWdlJyBpZiB5b3Ugd2FudCBhdXRvU2Nyb2xsIHRvIHdvcmtcbiAgICogQHJldHVybiB7c3RyaW5nIHwgb2JqZWN0fSBUaGUgY3VycmVudCBkZWx0YVNvdXJjZSBvciB0aGlzIEludGVyYWN0YWJsZVxuICAgKi9cblxuXG4gIGRlbHRhU291cmNlKG5ld1ZhbHVlKSB7XG4gICAgaWYgKG5ld1ZhbHVlID09PSAncGFnZScgfHwgbmV3VmFsdWUgPT09ICdjbGllbnQnKSB7XG4gICAgICB0aGlzLm9wdGlvbnMuZGVsdGFTb3VyY2UgPSBuZXdWYWx1ZTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLm9wdGlvbnMuZGVsdGFTb3VyY2U7XG4gIH1cbiAgLyoqXG4gICAqIEdldHMgdGhlIHNlbGVjdG9yIGNvbnRleHQgTm9kZSBvZiB0aGUgSW50ZXJhY3RhYmxlLiBUaGUgZGVmYXVsdCBpc1xuICAgKiBgd2luZG93LmRvY3VtZW50YC5cbiAgICpcbiAgICogQHJldHVybiB7Tm9kZX0gVGhlIGNvbnRleHQgTm9kZSBvZiB0aGlzIEludGVyYWN0YWJsZVxuICAgKi9cblxuXG4gIGNvbnRleHQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2NvbnRleHQ7XG4gIH1cblxuICBpbkNvbnRleHQoZWxlbWVudCkge1xuICAgIHJldHVybiB0aGlzLl9jb250ZXh0ID09PSBlbGVtZW50Lm93bmVyRG9jdW1lbnQgfHwgbm9kZUNvbnRhaW5zKHRoaXMuX2NvbnRleHQsIGVsZW1lbnQpO1xuICB9XG5cbiAgdGVzdElnbm9yZUFsbG93KG9wdGlvbnMsIHRhcmdldE5vZGUsIGV2ZW50VGFyZ2V0KSB7XG4gICAgcmV0dXJuICF0aGlzLnRlc3RJZ25vcmUob3B0aW9ucy5pZ25vcmVGcm9tLCB0YXJnZXROb2RlLCBldmVudFRhcmdldCkgJiYgdGhpcy50ZXN0QWxsb3cob3B0aW9ucy5hbGxvd0Zyb20sIHRhcmdldE5vZGUsIGV2ZW50VGFyZ2V0KTtcbiAgfVxuXG4gIHRlc3RBbGxvdyhhbGxvd0Zyb20sIHRhcmdldE5vZGUsIGVsZW1lbnQpIHtcbiAgICBpZiAoIWFsbG93RnJvbSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgaWYgKCFpcy5lbGVtZW50KGVsZW1lbnQpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgaWYgKGlzLnN0cmluZyhhbGxvd0Zyb20pKSB7XG4gICAgICByZXR1cm4gbWF0Y2hlc1VwVG8oZWxlbWVudCwgYWxsb3dGcm9tLCB0YXJnZXROb2RlKTtcbiAgICB9IGVsc2UgaWYgKGlzLmVsZW1lbnQoYWxsb3dGcm9tKSkge1xuICAgICAgcmV0dXJuIG5vZGVDb250YWlucyhhbGxvd0Zyb20sIGVsZW1lbnQpO1xuICAgIH1cblxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHRlc3RJZ25vcmUoaWdub3JlRnJvbSwgdGFyZ2V0Tm9kZSwgZWxlbWVudCkge1xuICAgIGlmICghaWdub3JlRnJvbSB8fCAhaXMuZWxlbWVudChlbGVtZW50KSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGlmIChpcy5zdHJpbmcoaWdub3JlRnJvbSkpIHtcbiAgICAgIHJldHVybiBtYXRjaGVzVXBUbyhlbGVtZW50LCBpZ25vcmVGcm9tLCB0YXJnZXROb2RlKTtcbiAgICB9IGVsc2UgaWYgKGlzLmVsZW1lbnQoaWdub3JlRnJvbSkpIHtcbiAgICAgIHJldHVybiBub2RlQ29udGFpbnMoaWdub3JlRnJvbSwgZWxlbWVudCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIC8qKlxuICAgKiBDYWxscyBsaXN0ZW5lcnMgZm9yIHRoZSBnaXZlbiBJbnRlcmFjdEV2ZW50IHR5cGUgYm91bmQgZ2xvYmFsbHlcbiAgICogYW5kIGRpcmVjdGx5IHRvIHRoaXMgSW50ZXJhY3RhYmxlXG4gICAqXG4gICAqIEBwYXJhbSB7SW50ZXJhY3RFdmVudH0gaUV2ZW50IFRoZSBJbnRlcmFjdEV2ZW50IG9iamVjdCB0byBiZSBmaXJlZCBvbiB0aGlzXG4gICAqIEludGVyYWN0YWJsZVxuICAgKiBAcmV0dXJuIHtJbnRlcmFjdGFibGV9IHRoaXMgSW50ZXJhY3RhYmxlXG4gICAqL1xuXG5cbiAgZmlyZShpRXZlbnQpIHtcbiAgICB0aGlzLmV2ZW50cy5maXJlKGlFdmVudCk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICBfb25PZmYobWV0aG9kLCB0eXBlQXJnLCBsaXN0ZW5lckFyZywgb3B0aW9ucykge1xuICAgIGlmIChpcy5vYmplY3QodHlwZUFyZykgJiYgIWlzLmFycmF5KHR5cGVBcmcpKSB7XG4gICAgICBvcHRpb25zID0gbGlzdGVuZXJBcmc7XG4gICAgICBsaXN0ZW5lckFyZyA9IG51bGw7XG4gICAgfVxuXG4gICAgY29uc3QgYWRkUmVtb3ZlID0gbWV0aG9kID09PSAnb24nID8gJ2FkZCcgOiAncmVtb3ZlJztcbiAgICBjb25zdCBsaXN0ZW5lcnMgPSBub3JtYWxpemUodHlwZUFyZywgbGlzdGVuZXJBcmcpO1xuXG4gICAgZm9yIChsZXQgdHlwZSBpbiBsaXN0ZW5lcnMpIHtcbiAgICAgIGlmICh0eXBlID09PSAnd2hlZWwnKSB7XG4gICAgICAgIHR5cGUgPSB1dGlsc19icm93c2VyLndoZWVsRXZlbnQ7XG4gICAgICB9XG5cbiAgICAgIGZvciAoY29uc3QgbGlzdGVuZXIgb2YgbGlzdGVuZXJzW3R5cGVdKSB7XG4gICAgICAgIC8vIGlmIGl0IGlzIGFuIGFjdGlvbiBldmVudCB0eXBlXG4gICAgICAgIGlmIChpc05vbk5hdGl2ZUV2ZW50KHR5cGUsIHRoaXMuX2FjdGlvbnMpKSB7XG4gICAgICAgICAgdGhpcy5ldmVudHNbbWV0aG9kXSh0eXBlLCBsaXN0ZW5lcik7XG4gICAgICAgIH0gLy8gZGVsZWdhdGVkIGV2ZW50XG4gICAgICAgIGVsc2UgaWYgKGlzLnN0cmluZyh0aGlzLnRhcmdldCkpIHtcbiAgICAgICAgICAgIHRoaXMuX3Njb3BlRXZlbnRzW2Ake2FkZFJlbW92ZX1EZWxlZ2F0ZWBdKHRoaXMudGFyZ2V0LCB0aGlzLl9jb250ZXh0LCB0eXBlLCBsaXN0ZW5lciwgb3B0aW9ucyk7XG4gICAgICAgICAgfSAvLyByZW1vdmUgbGlzdGVuZXIgZnJvbSB0aGlzIEludGVyYWN0YWJsZSdzIGVsZW1lbnRcbiAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgdGhpcy5fc2NvcGVFdmVudHNbYWRkUmVtb3ZlXSh0aGlzLnRhcmdldCwgdHlwZSwgbGlzdGVuZXIsIG9wdGlvbnMpO1xuICAgICAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIC8qKlxuICAgKiBCaW5kcyBhIGxpc3RlbmVyIGZvciBhbiBJbnRlcmFjdEV2ZW50LCBwb2ludGVyRXZlbnQgb3IgRE9NIGV2ZW50LlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZyB8IGFycmF5IHwgb2JqZWN0fSB0eXBlcyBUaGUgdHlwZXMgb2YgZXZlbnRzIHRvIGxpc3RlblxuICAgKiBmb3JcbiAgICogQHBhcmFtIHtmdW5jdGlvbiB8IGFycmF5IHwgb2JqZWN0fSBbbGlzdGVuZXJdIFRoZSBldmVudCBsaXN0ZW5lciBmdW5jdGlvbihzKVxuICAgKiBAcGFyYW0ge29iamVjdCB8IGJvb2xlYW59IFtvcHRpb25zXSBvcHRpb25zIG9iamVjdCBvciB1c2VDYXB0dXJlIGZsYWcgZm9yXG4gICAqIGFkZEV2ZW50TGlzdGVuZXJcbiAgICogQHJldHVybiB7SW50ZXJhY3RhYmxlfSBUaGlzIEludGVyYWN0YWJsZVxuICAgKi9cblxuXG4gIG9uKHR5cGVzLCBsaXN0ZW5lciwgb3B0aW9ucykge1xuICAgIHJldHVybiB0aGlzLl9vbk9mZignb24nLCB0eXBlcywgbGlzdGVuZXIsIG9wdGlvbnMpO1xuICB9XG4gIC8qKlxuICAgKiBSZW1vdmVzIGFuIEludGVyYWN0RXZlbnQsIHBvaW50ZXJFdmVudCBvciBET00gZXZlbnQgbGlzdGVuZXIuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nIHwgYXJyYXkgfCBvYmplY3R9IHR5cGVzIFRoZSB0eXBlcyBvZiBldmVudHMgdGhhdCB3ZXJlXG4gICAqIGxpc3RlbmVkIGZvclxuICAgKiBAcGFyYW0ge2Z1bmN0aW9uIHwgYXJyYXkgfCBvYmplY3R9IFtsaXN0ZW5lcl0gVGhlIGV2ZW50IGxpc3RlbmVyIGZ1bmN0aW9uKHMpXG4gICAqIEBwYXJhbSB7b2JqZWN0IHwgYm9vbGVhbn0gW29wdGlvbnNdIG9wdGlvbnMgb2JqZWN0IG9yIHVzZUNhcHR1cmUgZmxhZyBmb3JcbiAgICogcmVtb3ZlRXZlbnRMaXN0ZW5lclxuICAgKiBAcmV0dXJuIHtJbnRlcmFjdGFibGV9IFRoaXMgSW50ZXJhY3RhYmxlXG4gICAqL1xuXG5cbiAgb2ZmKHR5cGVzLCBsaXN0ZW5lciwgb3B0aW9ucykge1xuICAgIHJldHVybiB0aGlzLl9vbk9mZignb2ZmJywgdHlwZXMsIGxpc3RlbmVyLCBvcHRpb25zKTtcbiAgfVxuICAvKipcbiAgICogUmVzZXQgdGhlIG9wdGlvbnMgb2YgdGhpcyBJbnRlcmFjdGFibGVcbiAgICpcbiAgICogQHBhcmFtIHtvYmplY3R9IG9wdGlvbnMgVGhlIG5ldyBzZXR0aW5ncyB0byBhcHBseVxuICAgKiBAcmV0dXJuIHtvYmplY3R9IFRoaXMgSW50ZXJhY3RhYmxlXG4gICAqL1xuXG5cbiAgc2V0KG9wdGlvbnMpIHtcbiAgICBjb25zdCBkZWZhdWx0cyA9IHRoaXMuX2RlZmF1bHRzO1xuXG4gICAgaWYgKCFpcy5vYmplY3Qob3B0aW9ucykpIHtcbiAgICAgIG9wdGlvbnMgPSB7fTtcbiAgICB9XG5cbiAgICB0aGlzLm9wdGlvbnMgPSBjbG9uZShkZWZhdWx0cy5iYXNlKTtcblxuICAgIGZvciAoY29uc3QgYWN0aW9uTmFtZV8gaW4gdGhpcy5fYWN0aW9ucy5tZXRob2REaWN0KSB7XG4gICAgICBjb25zdCBhY3Rpb25OYW1lID0gYWN0aW9uTmFtZV87XG4gICAgICBjb25zdCBtZXRob2ROYW1lID0gdGhpcy5fYWN0aW9ucy5tZXRob2REaWN0W2FjdGlvbk5hbWVdO1xuICAgICAgdGhpcy5vcHRpb25zW2FjdGlvbk5hbWVdID0ge307XG4gICAgICB0aGlzLnNldFBlckFjdGlvbihhY3Rpb25OYW1lLCBleHRlbmQoZXh0ZW5kKHt9LCBkZWZhdWx0cy5wZXJBY3Rpb24pLCBkZWZhdWx0cy5hY3Rpb25zW2FjdGlvbk5hbWVdKSk7XG4gICAgICB0aGlzW21ldGhvZE5hbWVdKG9wdGlvbnNbYWN0aW9uTmFtZV0pO1xuICAgIH1cblxuICAgIGZvciAoY29uc3Qgc2V0dGluZyBpbiBvcHRpb25zKSB7XG4gICAgICBpZiAoaXMuZnVuYyh0aGlzW3NldHRpbmddKSkge1xuICAgICAgICB0aGlzW3NldHRpbmddKG9wdGlvbnNbc2V0dGluZ10pO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIC8qKlxuICAgKiBSZW1vdmUgdGhpcyBpbnRlcmFjdGFibGUgZnJvbSB0aGUgbGlzdCBvZiBpbnRlcmFjdGFibGVzIGFuZCByZW1vdmUgaXQnc1xuICAgKiBhY3Rpb24gY2FwYWJpbGl0aWVzIGFuZCBldmVudCBsaXN0ZW5lcnNcbiAgICovXG5cblxuICB1bnNldCgpIHtcbiAgICBpZiAoaXMuc3RyaW5nKHRoaXMudGFyZ2V0KSkge1xuICAgICAgLy8gcmVtb3ZlIGRlbGVnYXRlZCBldmVudHNcbiAgICAgIGZvciAoY29uc3QgdHlwZSBpbiB0aGlzLl9zY29wZUV2ZW50cy5kZWxlZ2F0ZWRFdmVudHMpIHtcbiAgICAgICAgY29uc3QgZGVsZWdhdGVkID0gdGhpcy5fc2NvcGVFdmVudHMuZGVsZWdhdGVkRXZlbnRzW3R5cGVdO1xuXG4gICAgICAgIGZvciAobGV0IGkgPSBkZWxlZ2F0ZWQubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICBjb25zdCB7XG4gICAgICAgICAgICBzZWxlY3RvcixcbiAgICAgICAgICAgIGNvbnRleHQsXG4gICAgICAgICAgICBsaXN0ZW5lcnNcbiAgICAgICAgICB9ID0gZGVsZWdhdGVkW2ldO1xuXG4gICAgICAgICAgaWYgKHNlbGVjdG9yID09PSB0aGlzLnRhcmdldCAmJiBjb250ZXh0ID09PSB0aGlzLl9jb250ZXh0KSB7XG4gICAgICAgICAgICBkZWxlZ2F0ZWQuc3BsaWNlKGksIDEpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGZvciAobGV0IGwgPSBsaXN0ZW5lcnMubGVuZ3RoIC0gMTsgbCA+PSAwOyBsLS0pIHtcbiAgICAgICAgICAgIHRoaXMuX3Njb3BlRXZlbnRzLnJlbW92ZURlbGVnYXRlKHRoaXMudGFyZ2V0LCB0aGlzLl9jb250ZXh0LCB0eXBlLCBsaXN0ZW5lcnNbbF1bMF0sIGxpc3RlbmVyc1tsXVsxXSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX3Njb3BlRXZlbnRzLnJlbW92ZSh0aGlzLnRhcmdldCwgJ2FsbCcpO1xuICAgIH1cbiAgfVxuXG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1JbnRlcmFjdGFibGUuanMubWFwXG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL25vZGVfbW9kdWxlcy9AaW50ZXJhY3Rqcy9jb3JlL0ludGVyYWN0YWJsZVNldC5qc1xuXG5cblxuXG5jbGFzcyBJbnRlcmFjdGFibGVTZXRfSW50ZXJhY3RhYmxlU2V0IHtcbiAgLy8gYWxsIHNldCBpbnRlcmFjdGFibGVzXG4gIGNvbnN0cnVjdG9yKHNjb3BlKSB7XG4gICAgdGhpcy5saXN0ID0gW107XG4gICAgdGhpcy5zZWxlY3Rvck1hcCA9IHt9O1xuICAgIHRoaXMuc2NvcGUgPSB2b2lkIDA7XG4gICAgdGhpcy5zY29wZSA9IHNjb3BlO1xuICAgIHNjb3BlLmFkZExpc3RlbmVycyh7XG4gICAgICAnaW50ZXJhY3RhYmxlOnVuc2V0JzogKHtcbiAgICAgICAgaW50ZXJhY3RhYmxlXG4gICAgICB9KSA9PiB7XG4gICAgICAgIGNvbnN0IHtcbiAgICAgICAgICB0YXJnZXQsXG4gICAgICAgICAgX2NvbnRleHQ6IGNvbnRleHRcbiAgICAgICAgfSA9IGludGVyYWN0YWJsZTtcbiAgICAgICAgY29uc3QgdGFyZ2V0TWFwcGluZ3MgPSBpcy5zdHJpbmcodGFyZ2V0KSA/IHRoaXMuc2VsZWN0b3JNYXBbdGFyZ2V0XSA6IHRhcmdldFt0aGlzLnNjb3BlLmlkXTtcbiAgICAgICAgY29uc3QgdGFyZ2V0SW5kZXggPSBmaW5kSW5kZXgodGFyZ2V0TWFwcGluZ3MsIG0gPT4gbS5jb250ZXh0ID09PSBjb250ZXh0KTtcblxuICAgICAgICBpZiAodGFyZ2V0TWFwcGluZ3NbdGFyZ2V0SW5kZXhdKSB7XG4gICAgICAgICAgLy8gRGVzdHJveWluZyBtYXBwaW5nSW5mbydzIGNvbnRleHQgYW5kIGludGVyYWN0YWJsZVxuICAgICAgICAgIHRhcmdldE1hcHBpbmdzW3RhcmdldEluZGV4XS5jb250ZXh0ID0gbnVsbDtcbiAgICAgICAgICB0YXJnZXRNYXBwaW5nc1t0YXJnZXRJbmRleF0uaW50ZXJhY3RhYmxlID0gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIHRhcmdldE1hcHBpbmdzLnNwbGljZSh0YXJnZXRJbmRleCwgMSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICBuZXcodGFyZ2V0LCBvcHRpb25zKSB7XG4gICAgb3B0aW9ucyA9IGV4dGVuZChvcHRpb25zIHx8IHt9LCB7XG4gICAgICBhY3Rpb25zOiB0aGlzLnNjb3BlLmFjdGlvbnNcbiAgICB9KTtcbiAgICBjb25zdCBpbnRlcmFjdGFibGUgPSBuZXcgdGhpcy5zY29wZS5JbnRlcmFjdGFibGUodGFyZ2V0LCBvcHRpb25zLCB0aGlzLnNjb3BlLmRvY3VtZW50LCB0aGlzLnNjb3BlLmV2ZW50cyk7XG4gICAgY29uc3QgbWFwcGluZ0luZm8gPSB7XG4gICAgICBjb250ZXh0OiBpbnRlcmFjdGFibGUuX2NvbnRleHQsXG4gICAgICBpbnRlcmFjdGFibGVcbiAgICB9O1xuICAgIHRoaXMuc2NvcGUuYWRkRG9jdW1lbnQoaW50ZXJhY3RhYmxlLl9kb2MpO1xuICAgIHRoaXMubGlzdC5wdXNoKGludGVyYWN0YWJsZSk7XG5cbiAgICBpZiAoaXMuc3RyaW5nKHRhcmdldCkpIHtcbiAgICAgIGlmICghdGhpcy5zZWxlY3Rvck1hcFt0YXJnZXRdKSB7XG4gICAgICAgIHRoaXMuc2VsZWN0b3JNYXBbdGFyZ2V0XSA9IFtdO1xuICAgICAgfVxuXG4gICAgICB0aGlzLnNlbGVjdG9yTWFwW3RhcmdldF0ucHVzaChtYXBwaW5nSW5mbyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmICghaW50ZXJhY3RhYmxlLnRhcmdldFt0aGlzLnNjb3BlLmlkXSkge1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCB0aGlzLnNjb3BlLmlkLCB7XG4gICAgICAgICAgdmFsdWU6IFtdLFxuICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgdGFyZ2V0W3RoaXMuc2NvcGUuaWRdLnB1c2gobWFwcGluZ0luZm8pO1xuICAgIH1cblxuICAgIHRoaXMuc2NvcGUuZmlyZSgnaW50ZXJhY3RhYmxlOm5ldycsIHtcbiAgICAgIHRhcmdldCxcbiAgICAgIG9wdGlvbnMsXG4gICAgICBpbnRlcmFjdGFibGUsXG4gICAgICB3aW46IHRoaXMuc2NvcGUuX3dpblxuICAgIH0pO1xuICAgIHJldHVybiBpbnRlcmFjdGFibGU7XG4gIH1cblxuICBnZXQodGFyZ2V0LCBvcHRpb25zKSB7XG4gICAgY29uc3QgY29udGV4dCA9IG9wdGlvbnMgJiYgb3B0aW9ucy5jb250ZXh0IHx8IHRoaXMuc2NvcGUuZG9jdW1lbnQ7XG4gICAgY29uc3QgaXNTZWxlY3RvciA9IGlzLnN0cmluZyh0YXJnZXQpO1xuICAgIGNvbnN0IHRhcmdldE1hcHBpbmdzID0gaXNTZWxlY3RvciA/IHRoaXMuc2VsZWN0b3JNYXBbdGFyZ2V0XSA6IHRhcmdldFt0aGlzLnNjb3BlLmlkXTtcblxuICAgIGlmICghdGFyZ2V0TWFwcGluZ3MpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIGNvbnN0IGZvdW5kID0gZmluZCh0YXJnZXRNYXBwaW5ncywgbSA9PiBtLmNvbnRleHQgPT09IGNvbnRleHQgJiYgKGlzU2VsZWN0b3IgfHwgbS5pbnRlcmFjdGFibGUuaW5Db250ZXh0KHRhcmdldCkpKTtcbiAgICByZXR1cm4gZm91bmQgJiYgZm91bmQuaW50ZXJhY3RhYmxlO1xuICB9XG5cbiAgZm9yRWFjaE1hdGNoKG5vZGUsIGNhbGxiYWNrKSB7XG4gICAgZm9yIChjb25zdCBpbnRlcmFjdGFibGUgb2YgdGhpcy5saXN0KSB7XG4gICAgICBsZXQgcmV0O1xuXG4gICAgICBpZiAoKGlzLnN0cmluZyhpbnRlcmFjdGFibGUudGFyZ2V0KSAvLyB0YXJnZXQgaXMgYSBzZWxlY3RvciBhbmQgdGhlIGVsZW1lbnQgbWF0Y2hlc1xuICAgICAgPyBpcy5lbGVtZW50KG5vZGUpICYmIG1hdGNoZXNTZWxlY3Rvcihub2RlLCBpbnRlcmFjdGFibGUudGFyZ2V0KSA6IC8vIHRhcmdldCBpcyB0aGUgZWxlbWVudFxuICAgICAgbm9kZSA9PT0gaW50ZXJhY3RhYmxlLnRhcmdldCkgJiYgLy8gdGhlIGVsZW1lbnQgaXMgaW4gY29udGV4dFxuICAgICAgaW50ZXJhY3RhYmxlLmluQ29udGV4dChub2RlKSkge1xuICAgICAgICByZXQgPSBjYWxsYmFjayhpbnRlcmFjdGFibGUpO1xuICAgICAgfVxuXG4gICAgICBpZiAocmV0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIHJldDtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9SW50ZXJhY3RhYmxlU2V0LmpzLm1hcFxuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9ub2RlX21vZHVsZXMvQGludGVyYWN0anMvdXRpbHMvcG9pbnRlckV4dGVuZC5qc1xuZnVuY3Rpb24gcG9pbnRlckV4dGVuZChkZXN0LCBzb3VyY2UpIHtcbiAgZm9yIChjb25zdCBwcm9wIGluIHNvdXJjZSkge1xuICAgIGNvbnN0IHByZWZpeGVkUHJvcFJFcyA9IHBvaW50ZXJFeHRlbmQucHJlZml4ZWRQcm9wUkVzO1xuICAgIGxldCBkZXByZWNhdGVkID0gZmFsc2U7IC8vIHNraXAgZGVwcmVjYXRlZCBwcmVmaXhlZCBwcm9wZXJ0aWVzXG5cbiAgICBmb3IgKGNvbnN0IHZlbmRvciBpbiBwcmVmaXhlZFByb3BSRXMpIHtcbiAgICAgIGlmIChwcm9wLmluZGV4T2YodmVuZG9yKSA9PT0gMCAmJiBwcmVmaXhlZFByb3BSRXNbdmVuZG9yXS50ZXN0KHByb3ApKSB7XG4gICAgICAgIGRlcHJlY2F0ZWQgPSB0cnVlO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoIWRlcHJlY2F0ZWQgJiYgdHlwZW9mIHNvdXJjZVtwcm9wXSAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgZGVzdFtwcm9wXSA9IHNvdXJjZVtwcm9wXTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZGVzdDtcbn1cblxucG9pbnRlckV4dGVuZC5wcmVmaXhlZFByb3BSRXMgPSB7XG4gIHdlYmtpdDogLyhNb3ZlbWVudFtYWV18UmFkaXVzW1hZXXxSb3RhdGlvbkFuZ2xlfEZvcmNlKSQvLFxuICBtb3o6IC8oUHJlc3N1cmUpJC9cbn07XG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIHZhciB1dGlsc19wb2ludGVyRXh0ZW5kID0gKHBvaW50ZXJFeHRlbmQpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cG9pbnRlckV4dGVuZC5qcy5tYXBcbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vbm9kZV9tb2R1bGVzL0BpbnRlcmFjdGpzL3V0aWxzL3BvaW50ZXJVdGlscy5qc1xuXG5cblxuXG5cblxuZnVuY3Rpb24gY29weUNvb3JkcyhkZXN0LCBzcmMpIHtcbiAgZGVzdC5wYWdlID0gZGVzdC5wYWdlIHx8IHt9O1xuICBkZXN0LnBhZ2UueCA9IHNyYy5wYWdlLng7XG4gIGRlc3QucGFnZS55ID0gc3JjLnBhZ2UueTtcbiAgZGVzdC5jbGllbnQgPSBkZXN0LmNsaWVudCB8fCB7fTtcbiAgZGVzdC5jbGllbnQueCA9IHNyYy5jbGllbnQueDtcbiAgZGVzdC5jbGllbnQueSA9IHNyYy5jbGllbnQueTtcbiAgZGVzdC50aW1lU3RhbXAgPSBzcmMudGltZVN0YW1wO1xufVxuZnVuY3Rpb24gc2V0Q29vcmREZWx0YXModGFyZ2V0T2JqLCBwcmV2LCBjdXIpIHtcbiAgdGFyZ2V0T2JqLnBhZ2UueCA9IGN1ci5wYWdlLnggLSBwcmV2LnBhZ2UueDtcbiAgdGFyZ2V0T2JqLnBhZ2UueSA9IGN1ci5wYWdlLnkgLSBwcmV2LnBhZ2UueTtcbiAgdGFyZ2V0T2JqLmNsaWVudC54ID0gY3VyLmNsaWVudC54IC0gcHJldi5jbGllbnQueDtcbiAgdGFyZ2V0T2JqLmNsaWVudC55ID0gY3VyLmNsaWVudC55IC0gcHJldi5jbGllbnQueTtcbiAgdGFyZ2V0T2JqLnRpbWVTdGFtcCA9IGN1ci50aW1lU3RhbXAgLSBwcmV2LnRpbWVTdGFtcDtcbn1cbmZ1bmN0aW9uIHNldENvb3JkVmVsb2NpdHkodGFyZ2V0T2JqLCBkZWx0YSkge1xuICBjb25zdCBkdCA9IE1hdGgubWF4KGRlbHRhLnRpbWVTdGFtcCAvIDEwMDAsIDAuMDAxKTtcbiAgdGFyZ2V0T2JqLnBhZ2UueCA9IGRlbHRhLnBhZ2UueCAvIGR0O1xuICB0YXJnZXRPYmoucGFnZS55ID0gZGVsdGEucGFnZS55IC8gZHQ7XG4gIHRhcmdldE9iai5jbGllbnQueCA9IGRlbHRhLmNsaWVudC54IC8gZHQ7XG4gIHRhcmdldE9iai5jbGllbnQueSA9IGRlbHRhLmNsaWVudC55IC8gZHQ7XG4gIHRhcmdldE9iai50aW1lU3RhbXAgPSBkdDtcbn1cbmZ1bmN0aW9uIHNldFplcm9Db29yZHModGFyZ2V0T2JqKSB7XG4gIHRhcmdldE9iai5wYWdlLnggPSAwO1xuICB0YXJnZXRPYmoucGFnZS55ID0gMDtcbiAgdGFyZ2V0T2JqLmNsaWVudC54ID0gMDtcbiAgdGFyZ2V0T2JqLmNsaWVudC55ID0gMDtcbn1cbmZ1bmN0aW9uIGlzTmF0aXZlUG9pbnRlcihwb2ludGVyKSB7XG4gIHJldHVybiBwb2ludGVyIGluc3RhbmNlb2YgdXRpbHNfZG9tT2JqZWN0cy5FdmVudCB8fCBwb2ludGVyIGluc3RhbmNlb2YgdXRpbHNfZG9tT2JqZWN0cy5Ub3VjaDtcbn0gLy8gR2V0IHNwZWNpZmllZCBYL1kgY29vcmRzIGZvciBtb3VzZSBvciBldmVudC50b3VjaGVzWzBdXG5cbmZ1bmN0aW9uIGdldFhZKHR5cGUsIHBvaW50ZXIsIHh5KSB7XG4gIHh5ID0geHkgfHwge307XG4gIHR5cGUgPSB0eXBlIHx8ICdwYWdlJztcbiAgeHkueCA9IHBvaW50ZXJbdHlwZSArICdYJ107XG4gIHh5LnkgPSBwb2ludGVyW3R5cGUgKyAnWSddO1xuICByZXR1cm4geHk7XG59XG5mdW5jdGlvbiBnZXRQYWdlWFkocG9pbnRlciwgcGFnZSkge1xuICBwYWdlID0gcGFnZSB8fCB7XG4gICAgeDogMCxcbiAgICB5OiAwXG4gIH07IC8vIE9wZXJhIE1vYmlsZSBoYW5kbGVzIHRoZSB2aWV3cG9ydCBhbmQgc2Nyb2xsaW5nIG9kZGx5XG5cbiAgaWYgKHV0aWxzX2Jyb3dzZXIuaXNPcGVyYU1vYmlsZSAmJiBpc05hdGl2ZVBvaW50ZXIocG9pbnRlcikpIHtcbiAgICBnZXRYWSgnc2NyZWVuJywgcG9pbnRlciwgcGFnZSk7XG4gICAgcGFnZS54ICs9IHdpbmRvdy5zY3JvbGxYO1xuICAgIHBhZ2UueSArPSB3aW5kb3cuc2Nyb2xsWTtcbiAgfSBlbHNlIHtcbiAgICBnZXRYWSgncGFnZScsIHBvaW50ZXIsIHBhZ2UpO1xuICB9XG5cbiAgcmV0dXJuIHBhZ2U7XG59XG5mdW5jdGlvbiBnZXRDbGllbnRYWShwb2ludGVyLCBjbGllbnQpIHtcbiAgY2xpZW50ID0gY2xpZW50IHx8IHt9O1xuXG4gIGlmICh1dGlsc19icm93c2VyLmlzT3BlcmFNb2JpbGUgJiYgaXNOYXRpdmVQb2ludGVyKHBvaW50ZXIpKSB7XG4gICAgLy8gT3BlcmEgTW9iaWxlIGhhbmRsZXMgdGhlIHZpZXdwb3J0IGFuZCBzY3JvbGxpbmcgb2RkbHlcbiAgICBnZXRYWSgnc2NyZWVuJywgcG9pbnRlciwgY2xpZW50KTtcbiAgfSBlbHNlIHtcbiAgICBnZXRYWSgnY2xpZW50JywgcG9pbnRlciwgY2xpZW50KTtcbiAgfVxuXG4gIHJldHVybiBjbGllbnQ7XG59XG5mdW5jdGlvbiBnZXRQb2ludGVySWQocG9pbnRlcikge1xuICByZXR1cm4gaXMubnVtYmVyKHBvaW50ZXIucG9pbnRlcklkKSA/IHBvaW50ZXIucG9pbnRlcklkIDogcG9pbnRlci5pZGVudGlmaWVyO1xufVxuZnVuY3Rpb24gc2V0Q29vcmRzKGRlc3QsIHBvaW50ZXJzLCB0aW1lU3RhbXApIHtcbiAgY29uc3QgcG9pbnRlciA9IHBvaW50ZXJzLmxlbmd0aCA+IDEgPyBwb2ludGVyQXZlcmFnZShwb2ludGVycykgOiBwb2ludGVyc1swXTtcbiAgZ2V0UGFnZVhZKHBvaW50ZXIsIGRlc3QucGFnZSk7XG4gIGdldENsaWVudFhZKHBvaW50ZXIsIGRlc3QuY2xpZW50KTtcbiAgZGVzdC50aW1lU3RhbXAgPSB0aW1lU3RhbXA7XG59XG5mdW5jdGlvbiBnZXRUb3VjaFBhaXIoZXZlbnQpIHtcbiAgY29uc3QgdG91Y2hlcyA9IFtdOyAvLyBhcnJheSBvZiB0b3VjaGVzIGlzIHN1cHBsaWVkXG5cbiAgaWYgKGlzLmFycmF5KGV2ZW50KSkge1xuICAgIHRvdWNoZXNbMF0gPSBldmVudFswXTtcbiAgICB0b3VjaGVzWzFdID0gZXZlbnRbMV07XG4gIH0gLy8gYW4gZXZlbnRcbiAgZWxzZSB7XG4gICAgICBpZiAoZXZlbnQudHlwZSA9PT0gJ3RvdWNoZW5kJykge1xuICAgICAgICBpZiAoZXZlbnQudG91Y2hlcy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICB0b3VjaGVzWzBdID0gZXZlbnQudG91Y2hlc1swXTtcbiAgICAgICAgICB0b3VjaGVzWzFdID0gZXZlbnQuY2hhbmdlZFRvdWNoZXNbMF07XG4gICAgICAgIH0gZWxzZSBpZiAoZXZlbnQudG91Y2hlcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICB0b3VjaGVzWzBdID0gZXZlbnQuY2hhbmdlZFRvdWNoZXNbMF07XG4gICAgICAgICAgdG91Y2hlc1sxXSA9IGV2ZW50LmNoYW5nZWRUb3VjaGVzWzFdO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0b3VjaGVzWzBdID0gZXZlbnQudG91Y2hlc1swXTtcbiAgICAgICAgdG91Y2hlc1sxXSA9IGV2ZW50LnRvdWNoZXNbMV07XG4gICAgICB9XG4gICAgfVxuXG4gIHJldHVybiB0b3VjaGVzO1xufVxuZnVuY3Rpb24gcG9pbnRlckF2ZXJhZ2UocG9pbnRlcnMpIHtcbiAgY29uc3QgYXZlcmFnZSA9IHtcbiAgICBwYWdlWDogMCxcbiAgICBwYWdlWTogMCxcbiAgICBjbGllbnRYOiAwLFxuICAgIGNsaWVudFk6IDAsXG4gICAgc2NyZWVuWDogMCxcbiAgICBzY3JlZW5ZOiAwXG4gIH07XG5cbiAgZm9yIChjb25zdCBwb2ludGVyIG9mIHBvaW50ZXJzKSB7XG4gICAgZm9yIChjb25zdCBwcm9wIGluIGF2ZXJhZ2UpIHtcbiAgICAgIGF2ZXJhZ2VbcHJvcF0gKz0gcG9pbnRlcltwcm9wXTtcbiAgICB9XG4gIH1cblxuICBmb3IgKGNvbnN0IHByb3AgaW4gYXZlcmFnZSkge1xuICAgIGF2ZXJhZ2VbcHJvcF0gLz0gcG9pbnRlcnMubGVuZ3RoO1xuICB9XG5cbiAgcmV0dXJuIGF2ZXJhZ2U7XG59XG5mdW5jdGlvbiB0b3VjaEJCb3goZXZlbnQpIHtcbiAgaWYgKCFldmVudC5sZW5ndGgpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIGNvbnN0IHRvdWNoZXMgPSBnZXRUb3VjaFBhaXIoZXZlbnQpO1xuICBjb25zdCBtaW5YID0gTWF0aC5taW4odG91Y2hlc1swXS5wYWdlWCwgdG91Y2hlc1sxXS5wYWdlWCk7XG4gIGNvbnN0IG1pblkgPSBNYXRoLm1pbih0b3VjaGVzWzBdLnBhZ2VZLCB0b3VjaGVzWzFdLnBhZ2VZKTtcbiAgY29uc3QgbWF4WCA9IE1hdGgubWF4KHRvdWNoZXNbMF0ucGFnZVgsIHRvdWNoZXNbMV0ucGFnZVgpO1xuICBjb25zdCBtYXhZID0gTWF0aC5tYXgodG91Y2hlc1swXS5wYWdlWSwgdG91Y2hlc1sxXS5wYWdlWSk7XG4gIHJldHVybiB7XG4gICAgeDogbWluWCxcbiAgICB5OiBtaW5ZLFxuICAgIGxlZnQ6IG1pblgsXG4gICAgdG9wOiBtaW5ZLFxuICAgIHJpZ2h0OiBtYXhYLFxuICAgIGJvdHRvbTogbWF4WSxcbiAgICB3aWR0aDogbWF4WCAtIG1pblgsXG4gICAgaGVpZ2h0OiBtYXhZIC0gbWluWVxuICB9O1xufVxuZnVuY3Rpb24gdG91Y2hEaXN0YW5jZShldmVudCwgZGVsdGFTb3VyY2UpIHtcbiAgY29uc3Qgc291cmNlWCA9IGRlbHRhU291cmNlICsgJ1gnO1xuICBjb25zdCBzb3VyY2VZID0gZGVsdGFTb3VyY2UgKyAnWSc7XG4gIGNvbnN0IHRvdWNoZXMgPSBnZXRUb3VjaFBhaXIoZXZlbnQpO1xuICBjb25zdCBkeCA9IHRvdWNoZXNbMF1bc291cmNlWF0gLSB0b3VjaGVzWzFdW3NvdXJjZVhdO1xuICBjb25zdCBkeSA9IHRvdWNoZXNbMF1bc291cmNlWV0gLSB0b3VjaGVzWzFdW3NvdXJjZVldO1xuICByZXR1cm4gaHlwb3QoZHgsIGR5KTtcbn1cbmZ1bmN0aW9uIHRvdWNoQW5nbGUoZXZlbnQsIGRlbHRhU291cmNlKSB7XG4gIGNvbnN0IHNvdXJjZVggPSBkZWx0YVNvdXJjZSArICdYJztcbiAgY29uc3Qgc291cmNlWSA9IGRlbHRhU291cmNlICsgJ1knO1xuICBjb25zdCB0b3VjaGVzID0gZ2V0VG91Y2hQYWlyKGV2ZW50KTtcbiAgY29uc3QgZHggPSB0b3VjaGVzWzFdW3NvdXJjZVhdIC0gdG91Y2hlc1swXVtzb3VyY2VYXTtcbiAgY29uc3QgZHkgPSB0b3VjaGVzWzFdW3NvdXJjZVldIC0gdG91Y2hlc1swXVtzb3VyY2VZXTtcbiAgY29uc3QgYW5nbGUgPSAxODAgKiBNYXRoLmF0YW4yKGR5LCBkeCkgLyBNYXRoLlBJO1xuICByZXR1cm4gYW5nbGU7XG59XG5mdW5jdGlvbiBnZXRQb2ludGVyVHlwZShwb2ludGVyKSB7XG4gIHJldHVybiBpcy5zdHJpbmcocG9pbnRlci5wb2ludGVyVHlwZSkgPyBwb2ludGVyLnBvaW50ZXJUeXBlIDogaXMubnVtYmVyKHBvaW50ZXIucG9pbnRlclR5cGUpID8gW3VuZGVmaW5lZCwgdW5kZWZpbmVkLCAndG91Y2gnLCAncGVuJywgJ21vdXNlJ11bcG9pbnRlci5wb2ludGVyVHlwZV0gLy8gaWYgdGhlIFBvaW50ZXJFdmVudCBBUEkgaXNuJ3QgYXZhaWxhYmxlLCB0aGVuIHRoZSBcInBvaW50ZXJcIiBtdXN0XG4gIC8vIGJlIGVpdGhlciBhIE1vdXNlRXZlbnQsIFRvdWNoRXZlbnQsIG9yIFRvdWNoIG9iamVjdFxuICA6IC90b3VjaC8udGVzdChwb2ludGVyLnR5cGUpIHx8IHBvaW50ZXIgaW5zdGFuY2VvZiB1dGlsc19kb21PYmplY3RzLlRvdWNoID8gJ3RvdWNoJyA6ICdtb3VzZSc7XG59IC8vIFsgZXZlbnQudGFyZ2V0LCBldmVudC5jdXJyZW50VGFyZ2V0IF1cblxuZnVuY3Rpb24gZ2V0RXZlbnRUYXJnZXRzKGV2ZW50KSB7XG4gIGNvbnN0IHBhdGggPSBpcy5mdW5jKGV2ZW50LmNvbXBvc2VkUGF0aCkgPyBldmVudC5jb21wb3NlZFBhdGgoKSA6IGV2ZW50LnBhdGg7XG4gIHJldHVybiBbZ2V0QWN0dWFsRWxlbWVudChwYXRoID8gcGF0aFswXSA6IGV2ZW50LnRhcmdldCksIGdldEFjdHVhbEVsZW1lbnQoZXZlbnQuY3VycmVudFRhcmdldCldO1xufVxuZnVuY3Rpb24gbmV3Q29vcmRzKCkge1xuICByZXR1cm4ge1xuICAgIHBhZ2U6IHtcbiAgICAgIHg6IDAsXG4gICAgICB5OiAwXG4gICAgfSxcbiAgICBjbGllbnQ6IHtcbiAgICAgIHg6IDAsXG4gICAgICB5OiAwXG4gICAgfSxcbiAgICB0aW1lU3RhbXA6IDBcbiAgfTtcbn1cbmZ1bmN0aW9uIGNvb3Jkc1RvRXZlbnQoY29vcmRzKSB7XG4gIGNvbnN0IGV2ZW50ID0ge1xuICAgIGNvb3JkcyxcblxuICAgIGdldCBwYWdlKCkge1xuICAgICAgcmV0dXJuIHRoaXMuY29vcmRzLnBhZ2U7XG4gICAgfSxcblxuICAgIGdldCBjbGllbnQoKSB7XG4gICAgICByZXR1cm4gdGhpcy5jb29yZHMuY2xpZW50O1xuICAgIH0sXG5cbiAgICBnZXQgdGltZVN0YW1wKCkge1xuICAgICAgcmV0dXJuIHRoaXMuY29vcmRzLnRpbWVTdGFtcDtcbiAgICB9LFxuXG4gICAgZ2V0IHBhZ2VYKCkge1xuICAgICAgcmV0dXJuIHRoaXMuY29vcmRzLnBhZ2UueDtcbiAgICB9LFxuXG4gICAgZ2V0IHBhZ2VZKCkge1xuICAgICAgcmV0dXJuIHRoaXMuY29vcmRzLnBhZ2UueTtcbiAgICB9LFxuXG4gICAgZ2V0IGNsaWVudFgoKSB7XG4gICAgICByZXR1cm4gdGhpcy5jb29yZHMuY2xpZW50Lng7XG4gICAgfSxcblxuICAgIGdldCBjbGllbnRZKCkge1xuICAgICAgcmV0dXJuIHRoaXMuY29vcmRzLmNsaWVudC55O1xuICAgIH0sXG5cbiAgICBnZXQgcG9pbnRlcklkKCkge1xuICAgICAgcmV0dXJuIHRoaXMuY29vcmRzLnBvaW50ZXJJZDtcbiAgICB9LFxuXG4gICAgZ2V0IHRhcmdldCgpIHtcbiAgICAgIHJldHVybiB0aGlzLmNvb3Jkcy50YXJnZXQ7XG4gICAgfSxcblxuICAgIGdldCB0eXBlKCkge1xuICAgICAgcmV0dXJuIHRoaXMuY29vcmRzLnR5cGU7XG4gICAgfSxcblxuICAgIGdldCBwb2ludGVyVHlwZSgpIHtcbiAgICAgIHJldHVybiB0aGlzLmNvb3Jkcy5wb2ludGVyVHlwZTtcbiAgICB9LFxuXG4gICAgZ2V0IGJ1dHRvbnMoKSB7XG4gICAgICByZXR1cm4gdGhpcy5jb29yZHMuYnV0dG9ucztcbiAgICB9LFxuXG4gICAgcHJldmVudERlZmF1bHQoKSB7fVxuXG4gIH07XG4gIHJldHVybiBldmVudDtcbn1cblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cG9pbnRlclV0aWxzLmpzLm1hcFxuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9ub2RlX21vZHVsZXMvQGludGVyYWN0anMvY29yZS9ldmVudHMuanNcblxuXG5cblxuXG5cblxuXG5mdW5jdGlvbiBpbnN0YWxsKHNjb3BlKSB7XG4gIGNvbnN0IHRhcmdldHMgPSBbXTtcbiAgY29uc3QgZGVsZWdhdGVkRXZlbnRzID0ge307XG4gIGNvbnN0IGRvY3VtZW50cyA9IFtdO1xuICBjb25zdCBldmVudHNNZXRob2RzID0ge1xuICAgIGFkZCxcbiAgICByZW1vdmUsXG4gICAgYWRkRGVsZWdhdGUsXG4gICAgcmVtb3ZlRGVsZWdhdGUsXG4gICAgZGVsZWdhdGVMaXN0ZW5lcixcbiAgICBkZWxlZ2F0ZVVzZUNhcHR1cmUsXG4gICAgZGVsZWdhdGVkRXZlbnRzLFxuICAgIGRvY3VtZW50cyxcbiAgICB0YXJnZXRzLFxuICAgIHN1cHBvcnRzT3B0aW9uczogZmFsc2UsXG4gICAgc3VwcG9ydHNQYXNzaXZlOiBmYWxzZVxuICB9OyAvLyBjaGVjayBpZiBicm93c2VyIHN1cHBvcnRzIHBhc3NpdmUgZXZlbnRzIGFuZCBvcHRpb25zIGFyZ1xuXG4gIHNjb3BlLmRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpLmFkZEV2ZW50TGlzdGVuZXIoJ3Rlc3QnLCBudWxsLCB7XG4gICAgZ2V0IGNhcHR1cmUoKSB7XG4gICAgICByZXR1cm4gZXZlbnRzTWV0aG9kcy5zdXBwb3J0c09wdGlvbnMgPSB0cnVlO1xuICAgIH0sXG5cbiAgICBnZXQgcGFzc2l2ZSgpIHtcbiAgICAgIHJldHVybiBldmVudHNNZXRob2RzLnN1cHBvcnRzUGFzc2l2ZSA9IHRydWU7XG4gICAgfVxuXG4gIH0pO1xuICBzY29wZS5ldmVudHMgPSBldmVudHNNZXRob2RzO1xuXG4gIGZ1bmN0aW9uIGFkZChldmVudFRhcmdldCwgdHlwZSwgbGlzdGVuZXIsIG9wdGlvbmFsQXJnKSB7XG4gICAgY29uc3Qgb3B0aW9ucyA9IGdldE9wdGlvbnMob3B0aW9uYWxBcmcpO1xuICAgIGxldCB0YXJnZXQgPSBmaW5kKHRhcmdldHMsIHQgPT4gdC5ldmVudFRhcmdldCA9PT0gZXZlbnRUYXJnZXQpO1xuXG4gICAgaWYgKCF0YXJnZXQpIHtcbiAgICAgIHRhcmdldCA9IHtcbiAgICAgICAgZXZlbnRUYXJnZXQsXG4gICAgICAgIGV2ZW50czoge31cbiAgICAgIH07XG4gICAgICB0YXJnZXRzLnB1c2godGFyZ2V0KTtcbiAgICB9XG5cbiAgICBpZiAoIXRhcmdldC5ldmVudHNbdHlwZV0pIHtcbiAgICAgIHRhcmdldC5ldmVudHNbdHlwZV0gPSBbXTtcbiAgICB9XG5cbiAgICBpZiAoZXZlbnRUYXJnZXQuYWRkRXZlbnRMaXN0ZW5lciAmJiAhY29udGFpbnModGFyZ2V0LmV2ZW50c1t0eXBlXSwgbGlzdGVuZXIpKSB7XG4gICAgICBldmVudFRhcmdldC5hZGRFdmVudExpc3RlbmVyKHR5cGUsIGxpc3RlbmVyLCBldmVudHNNZXRob2RzLnN1cHBvcnRzT3B0aW9ucyA/IG9wdGlvbnMgOiBvcHRpb25zLmNhcHR1cmUpO1xuICAgICAgdGFyZ2V0LmV2ZW50c1t0eXBlXS5wdXNoKGxpc3RlbmVyKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiByZW1vdmUoZXZlbnRUYXJnZXQsIHR5cGUsIGxpc3RlbmVyLCBvcHRpb25hbEFyZykge1xuICAgIGNvbnN0IG9wdGlvbnMgPSBnZXRPcHRpb25zKG9wdGlvbmFsQXJnKTtcbiAgICBjb25zdCB0YXJnZXRJbmRleCA9IGZpbmRJbmRleCh0YXJnZXRzLCB0ID0+IHQuZXZlbnRUYXJnZXQgPT09IGV2ZW50VGFyZ2V0KTtcbiAgICBjb25zdCB0YXJnZXQgPSB0YXJnZXRzW3RhcmdldEluZGV4XTtcblxuICAgIGlmICghdGFyZ2V0IHx8ICF0YXJnZXQuZXZlbnRzKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKHR5cGUgPT09ICdhbGwnKSB7XG4gICAgICBmb3IgKHR5cGUgaW4gdGFyZ2V0LmV2ZW50cykge1xuICAgICAgICBpZiAodGFyZ2V0LmV2ZW50cy5oYXNPd25Qcm9wZXJ0eSh0eXBlKSkge1xuICAgICAgICAgIHJlbW92ZShldmVudFRhcmdldCwgdHlwZSwgJ2FsbCcpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBsZXQgdHlwZUlzRW1wdHkgPSBmYWxzZTtcbiAgICBjb25zdCB0eXBlTGlzdGVuZXJzID0gdGFyZ2V0LmV2ZW50c1t0eXBlXTtcblxuICAgIGlmICh0eXBlTGlzdGVuZXJzKSB7XG4gICAgICBpZiAobGlzdGVuZXIgPT09ICdhbGwnKSB7XG4gICAgICAgIGZvciAobGV0IGkgPSB0eXBlTGlzdGVuZXJzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgICAgcmVtb3ZlKGV2ZW50VGFyZ2V0LCB0eXBlLCB0eXBlTGlzdGVuZXJzW2ldLCBvcHRpb25zKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdHlwZUxpc3RlbmVycy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIGlmICh0eXBlTGlzdGVuZXJzW2ldID09PSBsaXN0ZW5lcikge1xuICAgICAgICAgICAgZXZlbnRUYXJnZXQucmVtb3ZlRXZlbnRMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lciwgZXZlbnRzTWV0aG9kcy5zdXBwb3J0c09wdGlvbnMgPyBvcHRpb25zIDogb3B0aW9ucy5jYXB0dXJlKTtcbiAgICAgICAgICAgIHR5cGVMaXN0ZW5lcnMuc3BsaWNlKGksIDEpO1xuXG4gICAgICAgICAgICBpZiAodHlwZUxpc3RlbmVycy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgZGVsZXRlIHRhcmdldC5ldmVudHNbdHlwZV07XG4gICAgICAgICAgICAgIHR5cGVJc0VtcHR5ID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHR5cGVJc0VtcHR5ICYmICFPYmplY3Qua2V5cyh0YXJnZXQuZXZlbnRzKS5sZW5ndGgpIHtcbiAgICAgIHRhcmdldHMuc3BsaWNlKHRhcmdldEluZGV4LCAxKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBhZGREZWxlZ2F0ZShzZWxlY3RvciwgY29udGV4dCwgdHlwZSwgbGlzdGVuZXIsIG9wdGlvbmFsQXJnKSB7XG4gICAgY29uc3Qgb3B0aW9ucyA9IGdldE9wdGlvbnMob3B0aW9uYWxBcmcpO1xuXG4gICAgaWYgKCFkZWxlZ2F0ZWRFdmVudHNbdHlwZV0pIHtcbiAgICAgIGRlbGVnYXRlZEV2ZW50c1t0eXBlXSA9IFtdOyAvLyBhZGQgZGVsZWdhdGUgbGlzdGVuZXIgZnVuY3Rpb25zXG5cbiAgICAgIGZvciAoY29uc3QgZG9jIG9mIGRvY3VtZW50cykge1xuICAgICAgICBhZGQoZG9jLCB0eXBlLCBkZWxlZ2F0ZUxpc3RlbmVyKTtcbiAgICAgICAgYWRkKGRvYywgdHlwZSwgZGVsZWdhdGVVc2VDYXB0dXJlLCB0cnVlKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBjb25zdCBkZWxlZ2F0ZXMgPSBkZWxlZ2F0ZWRFdmVudHNbdHlwZV07XG4gICAgbGV0IGRlbGVnYXRlID0gZmluZChkZWxlZ2F0ZXMsIGQgPT4gZC5zZWxlY3RvciA9PT0gc2VsZWN0b3IgJiYgZC5jb250ZXh0ID09PSBjb250ZXh0KTtcblxuICAgIGlmICghZGVsZWdhdGUpIHtcbiAgICAgIGRlbGVnYXRlID0ge1xuICAgICAgICBzZWxlY3RvcixcbiAgICAgICAgY29udGV4dCxcbiAgICAgICAgbGlzdGVuZXJzOiBbXVxuICAgICAgfTtcbiAgICAgIGRlbGVnYXRlcy5wdXNoKGRlbGVnYXRlKTtcbiAgICB9XG5cbiAgICBkZWxlZ2F0ZS5saXN0ZW5lcnMucHVzaChbbGlzdGVuZXIsIG9wdGlvbnNdKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHJlbW92ZURlbGVnYXRlKHNlbGVjdG9yLCBjb250ZXh0LCB0eXBlLCBsaXN0ZW5lciwgb3B0aW9uYWxBcmcpIHtcbiAgICBjb25zdCBvcHRpb25zID0gZ2V0T3B0aW9ucyhvcHRpb25hbEFyZyk7XG4gICAgY29uc3QgZGVsZWdhdGVzID0gZGVsZWdhdGVkRXZlbnRzW3R5cGVdO1xuICAgIGxldCBtYXRjaEZvdW5kID0gZmFsc2U7XG4gICAgbGV0IGluZGV4O1xuXG4gICAgaWYgKCFkZWxlZ2F0ZXMpIHtcbiAgICAgIHJldHVybjtcbiAgICB9IC8vIGNvdW50IGZyb20gbGFzdCBpbmRleCBvZiBkZWxlZ2F0ZWQgdG8gMFxuXG5cbiAgICBmb3IgKGluZGV4ID0gZGVsZWdhdGVzLmxlbmd0aCAtIDE7IGluZGV4ID49IDA7IGluZGV4LS0pIHtcbiAgICAgIGNvbnN0IGN1ciA9IGRlbGVnYXRlc1tpbmRleF07IC8vIGxvb2sgZm9yIG1hdGNoaW5nIHNlbGVjdG9yIGFuZCBjb250ZXh0IE5vZGVcblxuICAgICAgaWYgKGN1ci5zZWxlY3RvciA9PT0gc2VsZWN0b3IgJiYgY3VyLmNvbnRleHQgPT09IGNvbnRleHQpIHtcbiAgICAgICAgY29uc3Qge1xuICAgICAgICAgIGxpc3RlbmVyc1xuICAgICAgICB9ID0gY3VyOyAvLyBlYWNoIGl0ZW0gb2YgdGhlIGxpc3RlbmVycyBhcnJheSBpcyBhbiBhcnJheTogW2Z1bmN0aW9uLCBjYXB0dXJlLCBwYXNzaXZlXVxuXG4gICAgICAgIGZvciAobGV0IGkgPSBsaXN0ZW5lcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICBjb25zdCBbZm4sIHtcbiAgICAgICAgICAgIGNhcHR1cmUsXG4gICAgICAgICAgICBwYXNzaXZlXG4gICAgICAgICAgfV0gPSBsaXN0ZW5lcnNbaV07IC8vIGNoZWNrIGlmIHRoZSBsaXN0ZW5lciBmdW5jdGlvbnMgYW5kIGNhcHR1cmUgYW5kIHBhc3NpdmUgZmxhZ3MgbWF0Y2hcblxuICAgICAgICAgIGlmIChmbiA9PT0gbGlzdGVuZXIgJiYgY2FwdHVyZSA9PT0gb3B0aW9ucy5jYXB0dXJlICYmIHBhc3NpdmUgPT09IG9wdGlvbnMucGFzc2l2ZSkge1xuICAgICAgICAgICAgLy8gcmVtb3ZlIHRoZSBsaXN0ZW5lciBmcm9tIHRoZSBhcnJheSBvZiBsaXN0ZW5lcnNcbiAgICAgICAgICAgIGxpc3RlbmVycy5zcGxpY2UoaSwgMSk7IC8vIGlmIGFsbCBsaXN0ZW5lcnMgZm9yIHRoaXMgdGFyZ2V0IGhhdmUgYmVlbiByZW1vdmVkXG4gICAgICAgICAgICAvLyByZW1vdmUgdGhlIHRhcmdldCBmcm9tIHRoZSBkZWxlZ2F0ZXMgYXJyYXlcblxuICAgICAgICAgICAgaWYgKCFsaXN0ZW5lcnMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgIGRlbGVnYXRlcy5zcGxpY2UoaW5kZXgsIDEpOyAvLyByZW1vdmUgZGVsZWdhdGUgZnVuY3Rpb24gZnJvbSBjb250ZXh0XG5cbiAgICAgICAgICAgICAgcmVtb3ZlKGNvbnRleHQsIHR5cGUsIGRlbGVnYXRlTGlzdGVuZXIpO1xuICAgICAgICAgICAgICByZW1vdmUoY29udGV4dCwgdHlwZSwgZGVsZWdhdGVVc2VDYXB0dXJlLCB0cnVlKTtcbiAgICAgICAgICAgIH0gLy8gb25seSByZW1vdmUgb25lIGxpc3RlbmVyXG5cblxuICAgICAgICAgICAgbWF0Y2hGb3VuZCA9IHRydWU7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAobWF0Y2hGb3VuZCkge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9IC8vIGJvdW5kIHRvIHRoZSBpbnRlcmFjdGFibGUgY29udGV4dCB3aGVuIGEgRE9NIGV2ZW50XG4gIC8vIGxpc3RlbmVyIGlzIGFkZGVkIHRvIGEgc2VsZWN0b3IgaW50ZXJhY3RhYmxlXG5cblxuICBmdW5jdGlvbiBkZWxlZ2F0ZUxpc3RlbmVyKGV2ZW50LCBvcHRpb25hbEFyZykge1xuICAgIGNvbnN0IG9wdGlvbnMgPSBnZXRPcHRpb25zKG9wdGlvbmFsQXJnKTtcbiAgICBjb25zdCBmYWtlRXZlbnQgPSBuZXcgZXZlbnRzX0Zha2VFdmVudChldmVudCk7XG4gICAgY29uc3QgZGVsZWdhdGVzID0gZGVsZWdhdGVkRXZlbnRzW2V2ZW50LnR5cGVdO1xuICAgIGNvbnN0IFtldmVudFRhcmdldF0gPSBnZXRFdmVudFRhcmdldHMoZXZlbnQpO1xuICAgIGxldCBlbGVtZW50ID0gZXZlbnRUYXJnZXQ7IC8vIGNsaW1iIHVwIGRvY3VtZW50IHRyZWUgbG9va2luZyBmb3Igc2VsZWN0b3IgbWF0Y2hlc1xuXG4gICAgd2hpbGUgKGlzLmVsZW1lbnQoZWxlbWVudCkpIHtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZGVsZWdhdGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IGN1ciA9IGRlbGVnYXRlc1tpXTtcbiAgICAgICAgY29uc3Qge1xuICAgICAgICAgIHNlbGVjdG9yLFxuICAgICAgICAgIGNvbnRleHRcbiAgICAgICAgfSA9IGN1cjtcblxuICAgICAgICBpZiAobWF0Y2hlc1NlbGVjdG9yKGVsZW1lbnQsIHNlbGVjdG9yKSAmJiBub2RlQ29udGFpbnMoY29udGV4dCwgZXZlbnRUYXJnZXQpICYmIG5vZGVDb250YWlucyhjb250ZXh0LCBlbGVtZW50KSkge1xuICAgICAgICAgIGNvbnN0IHtcbiAgICAgICAgICAgIGxpc3RlbmVyc1xuICAgICAgICAgIH0gPSBjdXI7XG4gICAgICAgICAgZmFrZUV2ZW50LmN1cnJlbnRUYXJnZXQgPSBlbGVtZW50O1xuXG4gICAgICAgICAgZm9yIChjb25zdCBbZm4sIHtcbiAgICAgICAgICAgIGNhcHR1cmUsXG4gICAgICAgICAgICBwYXNzaXZlXG4gICAgICAgICAgfV0gb2YgbGlzdGVuZXJzKSB7XG4gICAgICAgICAgICBpZiAoY2FwdHVyZSA9PT0gb3B0aW9ucy5jYXB0dXJlICYmIHBhc3NpdmUgPT09IG9wdGlvbnMucGFzc2l2ZSkge1xuICAgICAgICAgICAgICBmbihmYWtlRXZlbnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBlbGVtZW50ID0gcGFyZW50Tm9kZShlbGVtZW50KTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBkZWxlZ2F0ZVVzZUNhcHR1cmUoZXZlbnQpIHtcbiAgICByZXR1cm4gZGVsZWdhdGVMaXN0ZW5lci5jYWxsKHRoaXMsIGV2ZW50LCB0cnVlKTtcbiAgfSAvLyBmb3IgdHlwZSBpbmZlcnJlbmNlXG5cblxuICByZXR1cm4gZXZlbnRzTWV0aG9kcztcbn1cblxuY2xhc3MgZXZlbnRzX0Zha2VFdmVudCB7XG4gIGNvbnN0cnVjdG9yKG9yaWdpbmFsRXZlbnQpIHtcbiAgICB0aGlzLmN1cnJlbnRUYXJnZXQgPSB2b2lkIDA7XG4gICAgdGhpcy5vcmlnaW5hbEV2ZW50ID0gdm9pZCAwO1xuICAgIHRoaXMudHlwZSA9IHZvaWQgMDtcbiAgICB0aGlzLm9yaWdpbmFsRXZlbnQgPSBvcmlnaW5hbEV2ZW50OyAvLyBkdXBsaWNhdGUgdGhlIGV2ZW50IHNvIHRoYXQgY3VycmVudFRhcmdldCBjYW4gYmUgY2hhbmdlZFxuXG4gICAgdXRpbHNfcG9pbnRlckV4dGVuZCh0aGlzLCBvcmlnaW5hbEV2ZW50KTtcbiAgfVxuXG4gIHByZXZlbnRPcmlnaW5hbERlZmF1bHQoKSB7XG4gICAgdGhpcy5vcmlnaW5hbEV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gIH1cblxuICBzdG9wUHJvcGFnYXRpb24oKSB7XG4gICAgdGhpcy5vcmlnaW5hbEV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuICB9XG5cbiAgc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uKCkge1xuICAgIHRoaXMub3JpZ2luYWxFdmVudC5zdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24oKTtcbiAgfVxuXG59XG5cbmZ1bmN0aW9uIGdldE9wdGlvbnMocGFyYW0pIHtcbiAgaWYgKCFpcy5vYmplY3QocGFyYW0pKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGNhcHR1cmU6ICEhcGFyYW0sXG4gICAgICBwYXNzaXZlOiBmYWxzZVxuICAgIH07XG4gIH1cblxuICBjb25zdCBvcHRpb25zID0gZXh0ZW5kKHt9LCBwYXJhbSk7XG4gIG9wdGlvbnMuY2FwdHVyZSA9ICEhcGFyYW0uY2FwdHVyZTtcbiAgb3B0aW9ucy5wYXNzaXZlID0gISFwYXJhbS5wYXNzaXZlO1xuICByZXR1cm4gb3B0aW9ucztcbn1cblxuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyB2YXIgZXZlbnRzID0gKHtcbiAgaWQ6ICdldmVudHMnLFxuICBpbnN0YWxsXG59KTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWV2ZW50cy5qcy5tYXBcbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vbm9kZV9tb2R1bGVzL0BpbnRlcmFjdGpzL3V0aWxzL21pc2MuanNcblxuZnVuY3Rpb24gd2Fybk9uY2UobWV0aG9kLCBtZXNzYWdlKSB7XG4gIGxldCB3YXJuZWQgPSBmYWxzZTtcbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoIXdhcm5lZCkge1xuICAgICAgd2luLmNvbnNvbGUud2FybihtZXNzYWdlKTtcbiAgICAgIHdhcm5lZCA9IHRydWU7XG4gICAgfVxuXG4gICAgcmV0dXJuIG1ldGhvZC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICB9O1xufVxuZnVuY3Rpb24gY29weUFjdGlvbihkZXN0LCBzcmMpIHtcbiAgZGVzdC5uYW1lID0gc3JjLm5hbWU7XG4gIGRlc3QuYXhpcyA9IHNyYy5heGlzO1xuICBkZXN0LmVkZ2VzID0gc3JjLmVkZ2VzO1xuICByZXR1cm4gZGVzdDtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW1pc2MuanMubWFwXG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL25vZGVfbW9kdWxlcy9AaW50ZXJhY3Rqcy9jb3JlL2ludGVyYWN0U3RhdGljLmpzXG4vKiogQG1vZHVsZSBpbnRlcmFjdCAqL1xuXG5cblxuXG5cblxuZnVuY3Rpb24gY3JlYXRlSW50ZXJhY3RTdGF0aWMoc2NvcGUpIHtcbiAgLyoqXG4gICAqIGBgYGpzXG4gICAqIGludGVyYWN0KCcjZHJhZ2dhYmxlJykuZHJhZ2dhYmxlKHRydWUpXG4gICAqXG4gICAqIHZhciByZWN0YWJsZXMgPSBpbnRlcmFjdCgncmVjdCcpXG4gICAqIHJlY3RhYmxlc1xuICAgKiAgIC5nZXN0dXJhYmxlKHRydWUpXG4gICAqICAgLm9uKCdnZXN0dXJlbW92ZScsIGZ1bmN0aW9uIChldmVudCkge1xuICAgKiAgICAgICAvLyAuLi5cbiAgICogICB9KVxuICAgKiBgYGBcbiAgICpcbiAgICogVGhlIG1ldGhvZHMgb2YgdGhpcyB2YXJpYWJsZSBjYW4gYmUgdXNlZCB0byBzZXQgZWxlbWVudHMgYXMgaW50ZXJhY3RhYmxlc1xuICAgKiBhbmQgYWxzbyB0byBjaGFuZ2UgdmFyaW91cyBkZWZhdWx0IHNldHRpbmdzLlxuICAgKlxuICAgKiBDYWxsaW5nIGl0IGFzIGEgZnVuY3Rpb24gYW5kIHBhc3NpbmcgYW4gZWxlbWVudCBvciBhIHZhbGlkIENTUyBzZWxlY3RvclxuICAgKiBzdHJpbmcgcmV0dXJucyBhbiBJbnRlcmFjdGFibGUgb2JqZWN0IHdoaWNoIGhhcyB2YXJpb3VzIG1ldGhvZHMgdG8gY29uZmlndXJlXG4gICAqIGl0LlxuICAgKlxuICAgKiBAZ2xvYmFsXG4gICAqXG4gICAqIEBwYXJhbSB7RWxlbWVudCB8IHN0cmluZ30gdGFyZ2V0IFRoZSBIVE1MIG9yIFNWRyBFbGVtZW50IHRvIGludGVyYWN0IHdpdGhcbiAgICogb3IgQ1NTIHNlbGVjdG9yXG4gICAqIEByZXR1cm4ge0ludGVyYWN0YWJsZX1cbiAgICovXG4gIGNvbnN0IGludGVyYWN0ID0gKHRhcmdldCwgb3B0aW9ucykgPT4ge1xuICAgIGxldCBpbnRlcmFjdGFibGUgPSBzY29wZS5pbnRlcmFjdGFibGVzLmdldCh0YXJnZXQsIG9wdGlvbnMpO1xuXG4gICAgaWYgKCFpbnRlcmFjdGFibGUpIHtcbiAgICAgIGludGVyYWN0YWJsZSA9IHNjb3BlLmludGVyYWN0YWJsZXMubmV3KHRhcmdldCwgb3B0aW9ucyk7XG4gICAgICBpbnRlcmFjdGFibGUuZXZlbnRzLmdsb2JhbCA9IGludGVyYWN0Lmdsb2JhbEV2ZW50cztcbiAgICB9XG5cbiAgICByZXR1cm4gaW50ZXJhY3RhYmxlO1xuICB9OyAvLyBleHBvc2UgdGhlIGZ1bmN0aW9ucyB1c2VkIHRvIGNhbGN1bGF0ZSBtdWx0aS10b3VjaCBwcm9wZXJ0aWVzXG5cblxuICBpbnRlcmFjdC5nZXRQb2ludGVyQXZlcmFnZSA9IHBvaW50ZXJBdmVyYWdlO1xuICBpbnRlcmFjdC5nZXRUb3VjaEJCb3ggPSB0b3VjaEJCb3g7XG4gIGludGVyYWN0LmdldFRvdWNoRGlzdGFuY2UgPSB0b3VjaERpc3RhbmNlO1xuICBpbnRlcmFjdC5nZXRUb3VjaEFuZ2xlID0gdG91Y2hBbmdsZTtcbiAgaW50ZXJhY3QuZ2V0RWxlbWVudFJlY3QgPSBnZXRFbGVtZW50UmVjdDtcbiAgaW50ZXJhY3QuZ2V0RWxlbWVudENsaWVudFJlY3QgPSBnZXRFbGVtZW50Q2xpZW50UmVjdDtcbiAgaW50ZXJhY3QubWF0Y2hlc1NlbGVjdG9yID0gbWF0Y2hlc1NlbGVjdG9yO1xuICBpbnRlcmFjdC5jbG9zZXN0ID0gZG9tVXRpbHNfY2xvc2VzdDtcbiAgaW50ZXJhY3QuZ2xvYmFsRXZlbnRzID0ge307IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11bmRlZlxuXG4gIGludGVyYWN0LnZlcnNpb24gPSBcIjEuMTAuMlwiO1xuICBpbnRlcmFjdC5zY29wZSA9IHNjb3BlO1xuICAvKipcbiAgKiBVc2UgYSBwbHVnaW5cbiAgKlxuICAqIEBhbGlhcyBtb2R1bGU6aW50ZXJhY3QudXNlXG4gICpcbiAgICovXG5cbiAgaW50ZXJhY3QudXNlID0gZnVuY3Rpb24gKHBsdWdpbiwgb3B0aW9ucykge1xuICAgIHRoaXMuc2NvcGUudXNlUGx1Z2luKHBsdWdpbiwgb3B0aW9ucyk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG4gIC8qKlxuICAgKiBDaGVjayBpZiBhbiBlbGVtZW50IG9yIHNlbGVjdG9yIGhhcyBiZWVuIHNldCB3aXRoIHRoZSB7QGxpbmsgaW50ZXJhY3R9XG4gICAqIGZ1bmN0aW9uXG4gICAqXG4gICAqIEBhbGlhcyBtb2R1bGU6aW50ZXJhY3QuaXNTZXRcbiAgICpcbiAgICogQHBhcmFtIHtUYXJnZXR9IHRhcmdldCBUaGUgRWxlbWVudCBvciBzdHJpbmcgYmVpbmcgc2VhcmNoZWQgZm9yXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBvcHRpb25zXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59IEluZGljYXRlcyBpZiB0aGUgZWxlbWVudCBvciBDU1Mgc2VsZWN0b3Igd2FzIHByZXZpb3VzbHlcbiAgICogcGFzc2VkIHRvIGludGVyYWN0XG4gICAqL1xuXG5cbiAgaW50ZXJhY3QuaXNTZXQgPSBmdW5jdGlvbiAodGFyZ2V0LCBvcHRpb25zKSB7XG4gICAgcmV0dXJuICEhdGhpcy5zY29wZS5pbnRlcmFjdGFibGVzLmdldCh0YXJnZXQsIG9wdGlvbnMgJiYgb3B0aW9ucy5jb250ZXh0KTtcbiAgfTtcbiAgLyoqXG4gICAqIEBkZXByZWNhdGVkXG4gICAqIEFkZCBhIGdsb2JhbCBsaXN0ZW5lciBmb3IgYW4gSW50ZXJhY3RFdmVudCBvciBhZGRzIGEgRE9NIGV2ZW50IHRvIGBkb2N1bWVudGBcbiAgICpcbiAgICogQGFsaWFzIG1vZHVsZTppbnRlcmFjdC5vblxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZyB8IGFycmF5IHwgb2JqZWN0fSB0eXBlIFRoZSB0eXBlcyBvZiBldmVudHMgdG8gbGlzdGVuIGZvclxuICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBsaXN0ZW5lciBUaGUgZnVuY3Rpb24gZXZlbnQgKHMpXG4gICAqIEBwYXJhbSB7b2JqZWN0IHwgYm9vbGVhbn0gW29wdGlvbnNdIG9iamVjdCBvciB1c2VDYXB0dXJlIGZsYWcgZm9yXG4gICAqIGFkZEV2ZW50TGlzdGVuZXJcbiAgICogQHJldHVybiB7b2JqZWN0fSBpbnRlcmFjdFxuICAgKi9cblxuXG4gIGludGVyYWN0Lm9uID0gd2Fybk9uY2UoZnVuY3Rpb24gb24odHlwZSwgbGlzdGVuZXIsIG9wdGlvbnMpIHtcbiAgICBpZiAoaXMuc3RyaW5nKHR5cGUpICYmIHR5cGUuc2VhcmNoKCcgJykgIT09IC0xKSB7XG4gICAgICB0eXBlID0gdHlwZS50cmltKCkuc3BsaXQoLyArLyk7XG4gICAgfVxuXG4gICAgaWYgKGlzLmFycmF5KHR5cGUpKSB7XG4gICAgICBmb3IgKGNvbnN0IGV2ZW50VHlwZSBvZiB0eXBlKSB7XG4gICAgICAgIHRoaXMub24oZXZlbnRUeXBlLCBsaXN0ZW5lciwgb3B0aW9ucyk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIGlmIChpcy5vYmplY3QodHlwZSkpIHtcbiAgICAgIGZvciAoY29uc3QgcHJvcCBpbiB0eXBlKSB7XG4gICAgICAgIHRoaXMub24ocHJvcCwgdHlwZVtwcm9wXSwgbGlzdGVuZXIpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9IC8vIGlmIGl0IGlzIGFuIEludGVyYWN0RXZlbnQgdHlwZSwgYWRkIGxpc3RlbmVyIHRvIGdsb2JhbEV2ZW50c1xuXG5cbiAgICBpZiAoaXNOb25OYXRpdmVFdmVudCh0eXBlLCB0aGlzLnNjb3BlLmFjdGlvbnMpKSB7XG4gICAgICAvLyBpZiB0aGlzIHR5cGUgb2YgZXZlbnQgd2FzIG5ldmVyIGJvdW5kXG4gICAgICBpZiAoIXRoaXMuZ2xvYmFsRXZlbnRzW3R5cGVdKSB7XG4gICAgICAgIHRoaXMuZ2xvYmFsRXZlbnRzW3R5cGVdID0gW2xpc3RlbmVyXTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuZ2xvYmFsRXZlbnRzW3R5cGVdLnB1c2gobGlzdGVuZXIpO1xuICAgICAgfVxuICAgIH0gLy8gSWYgbm9uIEludGVyYWN0RXZlbnQgdHlwZSwgYWRkRXZlbnRMaXN0ZW5lciB0byBkb2N1bWVudFxuICAgIGVsc2Uge1xuICAgICAgICB0aGlzLnNjb3BlLmV2ZW50cy5hZGQodGhpcy5zY29wZS5kb2N1bWVudCwgdHlwZSwgbGlzdGVuZXIsIHtcbiAgICAgICAgICBvcHRpb25zXG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sICdUaGUgaW50ZXJhY3Qub24oKSBtZXRob2QgaXMgYmVpbmcgZGVwcmVjYXRlZCcpO1xuICAvKipcbiAgICogQGRlcHJlY2F0ZWRcbiAgICogUmVtb3ZlcyBhIGdsb2JhbCBJbnRlcmFjdEV2ZW50IGxpc3RlbmVyIG9yIERPTSBldmVudCBmcm9tIGBkb2N1bWVudGBcbiAgICpcbiAgICogQGFsaWFzIG1vZHVsZTppbnRlcmFjdC5vZmZcbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmcgfCBhcnJheSB8IG9iamVjdH0gdHlwZSBUaGUgdHlwZXMgb2YgZXZlbnRzIHRoYXQgd2VyZSBsaXN0ZW5lZFxuICAgKiBmb3JcbiAgICogQHBhcmFtIHtmdW5jdGlvbn0gbGlzdGVuZXIgVGhlIGxpc3RlbmVyIGZ1bmN0aW9uIHRvIGJlIHJlbW92ZWRcbiAgICogQHBhcmFtIHtvYmplY3QgfCBib29sZWFufSBvcHRpb25zIFtvcHRpb25zXSBvYmplY3Qgb3IgdXNlQ2FwdHVyZSBmbGFnIGZvclxuICAgKiByZW1vdmVFdmVudExpc3RlbmVyXG4gICAqIEByZXR1cm4ge29iamVjdH0gaW50ZXJhY3RcbiAgICovXG5cbiAgaW50ZXJhY3Qub2ZmID0gd2Fybk9uY2UoZnVuY3Rpb24gb2ZmKHR5cGUsIGxpc3RlbmVyLCBvcHRpb25zKSB7XG4gICAgaWYgKGlzLnN0cmluZyh0eXBlKSAmJiB0eXBlLnNlYXJjaCgnICcpICE9PSAtMSkge1xuICAgICAgdHlwZSA9IHR5cGUudHJpbSgpLnNwbGl0KC8gKy8pO1xuICAgIH1cblxuICAgIGlmIChpcy5hcnJheSh0eXBlKSkge1xuICAgICAgZm9yIChjb25zdCBldmVudFR5cGUgb2YgdHlwZSkge1xuICAgICAgICB0aGlzLm9mZihldmVudFR5cGUsIGxpc3RlbmVyLCBvcHRpb25zKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgaWYgKGlzLm9iamVjdCh0eXBlKSkge1xuICAgICAgZm9yIChjb25zdCBwcm9wIGluIHR5cGUpIHtcbiAgICAgICAgdGhpcy5vZmYocHJvcCwgdHlwZVtwcm9wXSwgbGlzdGVuZXIpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICBpZiAoaXNOb25OYXRpdmVFdmVudCh0eXBlLCB0aGlzLnNjb3BlLmFjdGlvbnMpKSB7XG4gICAgICBsZXQgaW5kZXg7XG5cbiAgICAgIGlmICh0eXBlIGluIHRoaXMuZ2xvYmFsRXZlbnRzICYmIChpbmRleCA9IHRoaXMuZ2xvYmFsRXZlbnRzW3R5cGVdLmluZGV4T2YobGlzdGVuZXIpKSAhPT0gLTEpIHtcbiAgICAgICAgdGhpcy5nbG9iYWxFdmVudHNbdHlwZV0uc3BsaWNlKGluZGV4LCAxKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5zY29wZS5ldmVudHMucmVtb3ZlKHRoaXMuc2NvcGUuZG9jdW1lbnQsIHR5cGUsIGxpc3RlbmVyLCBvcHRpb25zKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfSwgJ1RoZSBpbnRlcmFjdC5vZmYoKSBtZXRob2QgaXMgYmVpbmcgZGVwcmVjYXRlZCcpO1xuXG4gIGludGVyYWN0LmRlYnVnID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLnNjb3BlO1xuICB9O1xuICAvKipcbiAgICogQGFsaWFzIG1vZHVsZTppbnRlcmFjdC5zdXBwb3J0c1RvdWNoXG4gICAqXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59IFdoZXRoZXIgb3Igbm90IHRoZSBicm93c2VyIHN1cHBvcnRzIHRvdWNoIGlucHV0XG4gICAqL1xuXG5cbiAgaW50ZXJhY3Quc3VwcG9ydHNUb3VjaCA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdXRpbHNfYnJvd3Nlci5zdXBwb3J0c1RvdWNoO1xuICB9O1xuICAvKipcbiAgICogQGFsaWFzIG1vZHVsZTppbnRlcmFjdC5zdXBwb3J0c1BvaW50ZXJFdmVudFxuICAgKlxuICAgKiBAcmV0dXJuIHtib29sZWFufSBXaGV0aGVyIG9yIG5vdCB0aGUgYnJvd3NlciBzdXBwb3J0cyBQb2ludGVyRXZlbnRzXG4gICAqL1xuXG5cbiAgaW50ZXJhY3Quc3VwcG9ydHNQb2ludGVyRXZlbnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHV0aWxzX2Jyb3dzZXIuc3VwcG9ydHNQb2ludGVyRXZlbnQ7XG4gIH07XG4gIC8qKlxuICAgKiBDYW5jZWxzIGFsbCBpbnRlcmFjdGlvbnMgKGVuZCBldmVudHMgYXJlIG5vdCBmaXJlZClcbiAgICpcbiAgICogQGFsaWFzIG1vZHVsZTppbnRlcmFjdC5zdG9wXG4gICAqXG4gICAqIEByZXR1cm4ge29iamVjdH0gaW50ZXJhY3RcbiAgICovXG5cblxuICBpbnRlcmFjdC5zdG9wID0gZnVuY3Rpb24gKCkge1xuICAgIGZvciAoY29uc3QgaW50ZXJhY3Rpb24gb2YgdGhpcy5zY29wZS5pbnRlcmFjdGlvbnMubGlzdCkge1xuICAgICAgaW50ZXJhY3Rpb24uc3RvcCgpO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xuICB9O1xuICAvKipcbiAgICogUmV0dXJucyBvciBzZXRzIHRoZSBkaXN0YW5jZSB0aGUgcG9pbnRlciBtdXN0IGJlIG1vdmVkIGJlZm9yZSBhbiBhY3Rpb25cbiAgICogc2VxdWVuY2Ugb2NjdXJzLiBUaGlzIGFsc28gYWZmZWN0cyB0b2xlcmFuY2UgZm9yIHRhcCBldmVudHMuXG4gICAqXG4gICAqIEBhbGlhcyBtb2R1bGU6aW50ZXJhY3QucG9pbnRlck1vdmVUb2xlcmFuY2VcbiAgICpcbiAgICogQHBhcmFtIHtudW1iZXJ9IFtuZXdWYWx1ZV0gVGhlIG1vdmVtZW50IGZyb20gdGhlIHN0YXJ0IHBvc2l0aW9uIG11c3QgYmUgZ3JlYXRlciB0aGFuIHRoaXMgdmFsdWVcbiAgICogQHJldHVybiB7aW50ZXJhY3QgfCBudW1iZXJ9XG4gICAqL1xuXG5cbiAgaW50ZXJhY3QucG9pbnRlck1vdmVUb2xlcmFuY2UgPSBmdW5jdGlvbiAobmV3VmFsdWUpIHtcbiAgICBpZiAoaXMubnVtYmVyKG5ld1ZhbHVlKSkge1xuICAgICAgdGhpcy5zY29wZS5pbnRlcmFjdGlvbnMucG9pbnRlck1vdmVUb2xlcmFuY2UgPSBuZXdWYWx1ZTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLnNjb3BlLmludGVyYWN0aW9ucy5wb2ludGVyTW92ZVRvbGVyYW5jZTtcbiAgfTtcblxuICBpbnRlcmFjdC5hZGREb2N1bWVudCA9IGZ1bmN0aW9uIChkb2MsIG9wdGlvbnMpIHtcbiAgICB0aGlzLnNjb3BlLmFkZERvY3VtZW50KGRvYywgb3B0aW9ucyk7XG4gIH07XG5cbiAgaW50ZXJhY3QucmVtb3ZlRG9jdW1lbnQgPSBmdW5jdGlvbiAoZG9jKSB7XG4gICAgdGhpcy5zY29wZS5yZW1vdmVEb2N1bWVudChkb2MpO1xuICB9O1xuXG4gIHJldHVybiBpbnRlcmFjdDtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWludGVyYWN0U3RhdGljLmpzLm1hcFxuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9ub2RlX21vZHVsZXMvQGludGVyYWN0anMvY29yZS9Qb2ludGVySW5mby5qc1xuY2xhc3MgUG9pbnRlckluZm8ge1xuICBjb25zdHJ1Y3RvcihpZCwgcG9pbnRlciwgZXZlbnQsIGRvd25UaW1lLCBkb3duVGFyZ2V0KSB7XG4gICAgdGhpcy5pZCA9IHZvaWQgMDtcbiAgICB0aGlzLnBvaW50ZXIgPSB2b2lkIDA7XG4gICAgdGhpcy5ldmVudCA9IHZvaWQgMDtcbiAgICB0aGlzLmRvd25UaW1lID0gdm9pZCAwO1xuICAgIHRoaXMuZG93blRhcmdldCA9IHZvaWQgMDtcbiAgICB0aGlzLmlkID0gaWQ7XG4gICAgdGhpcy5wb2ludGVyID0gcG9pbnRlcjtcbiAgICB0aGlzLmV2ZW50ID0gZXZlbnQ7XG4gICAgdGhpcy5kb3duVGltZSA9IGRvd25UaW1lO1xuICAgIHRoaXMuZG93blRhcmdldCA9IGRvd25UYXJnZXQ7XG4gIH1cblxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9UG9pbnRlckluZm8uanMubWFwXG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL25vZGVfbW9kdWxlcy9AaW50ZXJhY3Rqcy9jb3JlL0ludGVyYWN0aW9uLmpzXG5cblxuXG5cblxuXG5cblxubGV0IF9Qcm94eVZhbHVlcztcblxuKGZ1bmN0aW9uIChfUHJveHlWYWx1ZXMpIHtcbiAgX1Byb3h5VmFsdWVzW1wiaW50ZXJhY3RhYmxlXCJdID0gXCJcIjtcbiAgX1Byb3h5VmFsdWVzW1wiZWxlbWVudFwiXSA9IFwiXCI7XG4gIF9Qcm94eVZhbHVlc1tcInByZXBhcmVkXCJdID0gXCJcIjtcbiAgX1Byb3h5VmFsdWVzW1wicG9pbnRlcklzRG93blwiXSA9IFwiXCI7XG4gIF9Qcm94eVZhbHVlc1tcInBvaW50ZXJXYXNNb3ZlZFwiXSA9IFwiXCI7XG4gIF9Qcm94eVZhbHVlc1tcIl9wcm94eVwiXSA9IFwiXCI7XG59KShfUHJveHlWYWx1ZXMgfHwgKF9Qcm94eVZhbHVlcyA9IHt9KSk7XG5cbmxldCBfUHJveHlNZXRob2RzO1xuXG4oZnVuY3Rpb24gKF9Qcm94eU1ldGhvZHMpIHtcbiAgX1Byb3h5TWV0aG9kc1tcInN0YXJ0XCJdID0gXCJcIjtcbiAgX1Byb3h5TWV0aG9kc1tcIm1vdmVcIl0gPSBcIlwiO1xuICBfUHJveHlNZXRob2RzW1wiZW5kXCJdID0gXCJcIjtcbiAgX1Byb3h5TWV0aG9kc1tcInN0b3BcIl0gPSBcIlwiO1xuICBfUHJveHlNZXRob2RzW1wiaW50ZXJhY3RpbmdcIl0gPSBcIlwiO1xufSkoX1Byb3h5TWV0aG9kcyB8fCAoX1Byb3h5TWV0aG9kcyA9IHt9KSk7XG5cbmxldCBpZENvdW50ZXIgPSAwO1xuY2xhc3MgSW50ZXJhY3Rpb25fSW50ZXJhY3Rpb24ge1xuICAvLyBjdXJyZW50IGludGVyYWN0YWJsZSBiZWluZyBpbnRlcmFjdGVkIHdpdGhcbiAgLy8gdGhlIHRhcmdldCBlbGVtZW50IG9mIHRoZSBpbnRlcmFjdGFibGVcbiAgLy8gYWN0aW9uIHRoYXQncyByZWFkeSB0byBiZSBmaXJlZCBvbiBuZXh0IG1vdmUgZXZlbnRcbiAgLy8ga2VlcCB0cmFjayBvZiBhZGRlZCBwb2ludGVyc1xuICAvLyBwb2ludGVyZG93bi9tb3VzZWRvd24vdG91Y2hzdGFydCBldmVudFxuICAvLyBwcmV2aW91cyBhY3Rpb24gZXZlbnRcblxuICAvKiogQGludGVybmFsICovXG4gIGdldCBwb2ludGVyTW92ZVRvbGVyYW5jZSgpIHtcbiAgICByZXR1cm4gMTtcbiAgfVxuICAvKipcbiAgICogQGFsaWFzIEludGVyYWN0aW9uLnByb3RvdHlwZS5tb3ZlXG4gICAqL1xuXG5cbiAgLyoqICovXG4gIGNvbnN0cnVjdG9yKHtcbiAgICBwb2ludGVyVHlwZSxcbiAgICBzY29wZUZpcmVcbiAgfSkge1xuICAgIHRoaXMuaW50ZXJhY3RhYmxlID0gbnVsbDtcbiAgICB0aGlzLmVsZW1lbnQgPSBudWxsO1xuICAgIHRoaXMucmVjdCA9IHZvaWQgMDtcbiAgICB0aGlzLl9yZWN0cyA9IHZvaWQgMDtcbiAgICB0aGlzLmVkZ2VzID0gdm9pZCAwO1xuICAgIHRoaXMuX3Njb3BlRmlyZSA9IHZvaWQgMDtcbiAgICB0aGlzLnByZXBhcmVkID0ge1xuICAgICAgbmFtZTogbnVsbCxcbiAgICAgIGF4aXM6IG51bGwsXG4gICAgICBlZGdlczogbnVsbFxuICAgIH07XG4gICAgdGhpcy5wb2ludGVyVHlwZSA9IHZvaWQgMDtcbiAgICB0aGlzLnBvaW50ZXJzID0gW107XG4gICAgdGhpcy5kb3duRXZlbnQgPSBudWxsO1xuICAgIHRoaXMuZG93blBvaW50ZXIgPSB7fTtcbiAgICB0aGlzLl9sYXRlc3RQb2ludGVyID0ge1xuICAgICAgcG9pbnRlcjogbnVsbCxcbiAgICAgIGV2ZW50OiBudWxsLFxuICAgICAgZXZlbnRUYXJnZXQ6IG51bGxcbiAgICB9O1xuICAgIHRoaXMucHJldkV2ZW50ID0gbnVsbDtcbiAgICB0aGlzLnBvaW50ZXJJc0Rvd24gPSBmYWxzZTtcbiAgICB0aGlzLnBvaW50ZXJXYXNNb3ZlZCA9IGZhbHNlO1xuICAgIHRoaXMuX2ludGVyYWN0aW5nID0gZmFsc2U7XG4gICAgdGhpcy5fZW5kaW5nID0gZmFsc2U7XG4gICAgdGhpcy5fc3RvcHBlZCA9IHRydWU7XG4gICAgdGhpcy5fcHJveHkgPSBudWxsO1xuICAgIHRoaXMuc2ltdWxhdGlvbiA9IG51bGw7XG4gICAgdGhpcy5kb01vdmUgPSB3YXJuT25jZShmdW5jdGlvbiAoc2lnbmFsQXJnKSB7XG4gICAgICB0aGlzLm1vdmUoc2lnbmFsQXJnKTtcbiAgICB9LCAnVGhlIGludGVyYWN0aW9uLmRvTW92ZSgpIG1ldGhvZCBoYXMgYmVlbiByZW5hbWVkIHRvIGludGVyYWN0aW9uLm1vdmUoKScpO1xuICAgIHRoaXMuY29vcmRzID0ge1xuICAgICAgLy8gU3RhcnRpbmcgSW50ZXJhY3RFdmVudCBwb2ludGVyIGNvb3JkaW5hdGVzXG4gICAgICBzdGFydDogbmV3Q29vcmRzKCksXG4gICAgICAvLyBQcmV2aW91cyBuYXRpdmUgcG9pbnRlciBtb3ZlIGV2ZW50IGNvb3JkaW5hdGVzXG4gICAgICBwcmV2OiBuZXdDb29yZHMoKSxcbiAgICAgIC8vIGN1cnJlbnQgbmF0aXZlIHBvaW50ZXIgbW92ZSBldmVudCBjb29yZGluYXRlc1xuICAgICAgY3VyOiBuZXdDb29yZHMoKSxcbiAgICAgIC8vIENoYW5nZSBpbiBjb29yZGluYXRlcyBhbmQgdGltZSBvZiB0aGUgcG9pbnRlclxuICAgICAgZGVsdGE6IG5ld0Nvb3JkcygpLFxuICAgICAgLy8gcG9pbnRlciB2ZWxvY2l0eVxuICAgICAgdmVsb2NpdHk6IG5ld0Nvb3JkcygpXG4gICAgfTtcbiAgICB0aGlzLl9pZCA9IGlkQ291bnRlcisrO1xuICAgIHRoaXMuX3Njb3BlRmlyZSA9IHNjb3BlRmlyZTtcbiAgICB0aGlzLnBvaW50ZXJUeXBlID0gcG9pbnRlclR5cGU7XG4gICAgY29uc3QgdGhhdCA9IHRoaXM7XG4gICAgdGhpcy5fcHJveHkgPSB7fTtcblxuICAgIGZvciAoY29uc3Qga2V5IGluIF9Qcm94eVZhbHVlcykge1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMuX3Byb3h5LCBrZXksIHtcbiAgICAgICAgZ2V0KCkge1xuICAgICAgICAgIHJldHVybiB0aGF0W2tleV07XG4gICAgICAgIH1cblxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgZm9yIChjb25zdCBrZXkgaW4gX1Byb3h5TWV0aG9kcykge1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMuX3Byb3h5LCBrZXksIHtcbiAgICAgICAgdmFsdWU6ICguLi5hcmdzKSA9PiB0aGF0W2tleV0oLi4uYXJncylcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIHRoaXMuX3Njb3BlRmlyZSgnaW50ZXJhY3Rpb25zOm5ldycsIHtcbiAgICAgIGludGVyYWN0aW9uOiB0aGlzXG4gICAgfSk7XG4gIH1cblxuICBwb2ludGVyRG93bihwb2ludGVyLCBldmVudCwgZXZlbnRUYXJnZXQpIHtcbiAgICBjb25zdCBwb2ludGVySW5kZXggPSB0aGlzLnVwZGF0ZVBvaW50ZXIocG9pbnRlciwgZXZlbnQsIGV2ZW50VGFyZ2V0LCB0cnVlKTtcbiAgICBjb25zdCBwb2ludGVySW5mbyA9IHRoaXMucG9pbnRlcnNbcG9pbnRlckluZGV4XTtcblxuICAgIHRoaXMuX3Njb3BlRmlyZSgnaW50ZXJhY3Rpb25zOmRvd24nLCB7XG4gICAgICBwb2ludGVyLFxuICAgICAgZXZlbnQsXG4gICAgICBldmVudFRhcmdldCxcbiAgICAgIHBvaW50ZXJJbmRleCxcbiAgICAgIHBvaW50ZXJJbmZvLFxuICAgICAgdHlwZTogJ2Rvd24nLFxuICAgICAgaW50ZXJhY3Rpb246IHRoaXNcbiAgICB9KTtcbiAgfVxuICAvKipcbiAgICogYGBganNcbiAgICogaW50ZXJhY3QodGFyZ2V0KVxuICAgKiAgIC5kcmFnZ2FibGUoe1xuICAgKiAgICAgLy8gZGlzYWJsZSB0aGUgZGVmYXVsdCBkcmFnIHN0YXJ0IGJ5IGRvd24tPm1vdmVcbiAgICogICAgIG1hbnVhbFN0YXJ0OiB0cnVlXG4gICAqICAgfSlcbiAgICogICAvLyBzdGFydCBkcmFnZ2luZyBhZnRlciB0aGUgdXNlciBob2xkcyB0aGUgcG9pbnRlciBkb3duXG4gICAqICAgLm9uKCdob2xkJywgZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAqICAgICB2YXIgaW50ZXJhY3Rpb24gPSBldmVudC5pbnRlcmFjdGlvblxuICAgKlxuICAgKiAgICAgaWYgKCFpbnRlcmFjdGlvbi5pbnRlcmFjdGluZygpKSB7XG4gICAqICAgICAgIGludGVyYWN0aW9uLnN0YXJ0KHsgbmFtZTogJ2RyYWcnIH0sXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgIGV2ZW50LmludGVyYWN0YWJsZSxcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgZXZlbnQuY3VycmVudFRhcmdldClcbiAgICogICAgIH1cbiAgICogfSlcbiAgICogYGBgXG4gICAqXG4gICAqIFN0YXJ0IGFuIGFjdGlvbiB3aXRoIHRoZSBnaXZlbiBJbnRlcmFjdGFibGUgYW5kIEVsZW1lbnQgYXMgdGFydGdldHMuIFRoZVxuICAgKiBhY3Rpb24gbXVzdCBiZSBlbmFibGVkIGZvciB0aGUgdGFyZ2V0IEludGVyYWN0YWJsZSBhbmQgYW4gYXBwcm9wcmlhdGVcbiAgICogbnVtYmVyIG9mIHBvaW50ZXJzIG11c3QgYmUgaGVsZCBkb3duIC0gMSBmb3IgZHJhZy9yZXNpemUsIDIgZm9yIGdlc3R1cmUuXG4gICAqXG4gICAqIFVzZSBpdCB3aXRoIGBpbnRlcmFjdGFibGUuPGFjdGlvbj5hYmxlKHsgbWFudWFsU3RhcnQ6IGZhbHNlIH0pYCB0byBhbHdheXNcbiAgICogW3N0YXJ0IGFjdGlvbnMgbWFudWFsbHldKGh0dHBzOi8vZ2l0aHViLmNvbS90YXllL2ludGVyYWN0LmpzL2lzc3Vlcy8xMTQpXG4gICAqXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBhY3Rpb24gICBUaGUgYWN0aW9uIHRvIGJlIHBlcmZvcm1lZCAtIGRyYWcsIHJlc2l6ZSwgZXRjLlxuICAgKiBAcGFyYW0ge0ludGVyYWN0YWJsZX0gdGFyZ2V0ICBUaGUgSW50ZXJhY3RhYmxlIHRvIHRhcmdldFxuICAgKiBAcGFyYW0ge0VsZW1lbnR9IGVsZW1lbnQgVGhlIERPTSBFbGVtZW50IHRvIHRhcmdldFxuICAgKiBAcmV0dXJuIHtCb29sZWFufSBXaGV0aGVyIHRoZSBpbnRlcmFjdGlvbiB3YXMgc3VjY2Vzc2Z1bGx5IHN0YXJ0ZWRcbiAgICovXG5cblxuICBzdGFydChhY3Rpb24sIGludGVyYWN0YWJsZSwgZWxlbWVudCkge1xuICAgIGlmICh0aGlzLmludGVyYWN0aW5nKCkgfHwgIXRoaXMucG9pbnRlcklzRG93biB8fCB0aGlzLnBvaW50ZXJzLmxlbmd0aCA8IChhY3Rpb24ubmFtZSA9PT0gJ2dlc3R1cmUnID8gMiA6IDEpIHx8ICFpbnRlcmFjdGFibGUub3B0aW9uc1thY3Rpb24ubmFtZV0uZW5hYmxlZCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGNvcHlBY3Rpb24odGhpcy5wcmVwYXJlZCwgYWN0aW9uKTtcbiAgICB0aGlzLmludGVyYWN0YWJsZSA9IGludGVyYWN0YWJsZTtcbiAgICB0aGlzLmVsZW1lbnQgPSBlbGVtZW50O1xuICAgIHRoaXMucmVjdCA9IGludGVyYWN0YWJsZS5nZXRSZWN0KGVsZW1lbnQpO1xuICAgIHRoaXMuZWRnZXMgPSB0aGlzLnByZXBhcmVkLmVkZ2VzID8gZXh0ZW5kKHt9LCB0aGlzLnByZXBhcmVkLmVkZ2VzKSA6IHtcbiAgICAgIGxlZnQ6IHRydWUsXG4gICAgICByaWdodDogdHJ1ZSxcbiAgICAgIHRvcDogdHJ1ZSxcbiAgICAgIGJvdHRvbTogdHJ1ZVxuICAgIH07XG4gICAgdGhpcy5fc3RvcHBlZCA9IGZhbHNlO1xuICAgIHRoaXMuX2ludGVyYWN0aW5nID0gdGhpcy5fZG9QaGFzZSh7XG4gICAgICBpbnRlcmFjdGlvbjogdGhpcyxcbiAgICAgIGV2ZW50OiB0aGlzLmRvd25FdmVudCxcbiAgICAgIHBoYXNlOiAnc3RhcnQnXG4gICAgfSkgJiYgIXRoaXMuX3N0b3BwZWQ7XG4gICAgcmV0dXJuIHRoaXMuX2ludGVyYWN0aW5nO1xuICB9XG5cbiAgcG9pbnRlck1vdmUocG9pbnRlciwgZXZlbnQsIGV2ZW50VGFyZ2V0KSB7XG4gICAgaWYgKCF0aGlzLnNpbXVsYXRpb24gJiYgISh0aGlzLm1vZGlmaWNhdGlvbiAmJiB0aGlzLm1vZGlmaWNhdGlvbi5lbmRSZXN1bHQpKSB7XG4gICAgICB0aGlzLnVwZGF0ZVBvaW50ZXIocG9pbnRlciwgZXZlbnQsIGV2ZW50VGFyZ2V0LCBmYWxzZSk7XG4gICAgfVxuXG4gICAgY29uc3QgZHVwbGljYXRlTW92ZSA9IHRoaXMuY29vcmRzLmN1ci5wYWdlLnggPT09IHRoaXMuY29vcmRzLnByZXYucGFnZS54ICYmIHRoaXMuY29vcmRzLmN1ci5wYWdlLnkgPT09IHRoaXMuY29vcmRzLnByZXYucGFnZS55ICYmIHRoaXMuY29vcmRzLmN1ci5jbGllbnQueCA9PT0gdGhpcy5jb29yZHMucHJldi5jbGllbnQueCAmJiB0aGlzLmNvb3Jkcy5jdXIuY2xpZW50LnkgPT09IHRoaXMuY29vcmRzLnByZXYuY2xpZW50Lnk7XG4gICAgbGV0IGR4O1xuICAgIGxldCBkeTsgLy8gcmVnaXN0ZXIgbW92ZW1lbnQgZ3JlYXRlciB0aGFuIHBvaW50ZXJNb3ZlVG9sZXJhbmNlXG5cbiAgICBpZiAodGhpcy5wb2ludGVySXNEb3duICYmICF0aGlzLnBvaW50ZXJXYXNNb3ZlZCkge1xuICAgICAgZHggPSB0aGlzLmNvb3Jkcy5jdXIuY2xpZW50LnggLSB0aGlzLmNvb3Jkcy5zdGFydC5jbGllbnQueDtcbiAgICAgIGR5ID0gdGhpcy5jb29yZHMuY3VyLmNsaWVudC55IC0gdGhpcy5jb29yZHMuc3RhcnQuY2xpZW50Lnk7XG4gICAgICB0aGlzLnBvaW50ZXJXYXNNb3ZlZCA9IGh5cG90KGR4LCBkeSkgPiB0aGlzLnBvaW50ZXJNb3ZlVG9sZXJhbmNlO1xuICAgIH1cblxuICAgIGNvbnN0IHBvaW50ZXJJbmRleCA9IHRoaXMuZ2V0UG9pbnRlckluZGV4KHBvaW50ZXIpO1xuICAgIGNvbnN0IHNpZ25hbEFyZyA9IHtcbiAgICAgIHBvaW50ZXIsXG4gICAgICBwb2ludGVySW5kZXgsXG4gICAgICBwb2ludGVySW5mbzogdGhpcy5wb2ludGVyc1twb2ludGVySW5kZXhdLFxuICAgICAgZXZlbnQsXG4gICAgICB0eXBlOiAnbW92ZScsXG4gICAgICBldmVudFRhcmdldCxcbiAgICAgIGR4LFxuICAgICAgZHksXG4gICAgICBkdXBsaWNhdGU6IGR1cGxpY2F0ZU1vdmUsXG4gICAgICBpbnRlcmFjdGlvbjogdGhpc1xuICAgIH07XG5cbiAgICBpZiAoIWR1cGxpY2F0ZU1vdmUpIHtcbiAgICAgIC8vIHNldCBwb2ludGVyIGNvb3JkaW5hdGUsIHRpbWUgY2hhbmdlcyBhbmQgdmVsb2NpdHlcbiAgICAgIHNldENvb3JkVmVsb2NpdHkodGhpcy5jb29yZHMudmVsb2NpdHksIHRoaXMuY29vcmRzLmRlbHRhKTtcbiAgICB9XG5cbiAgICB0aGlzLl9zY29wZUZpcmUoJ2ludGVyYWN0aW9uczptb3ZlJywgc2lnbmFsQXJnKTtcblxuICAgIGlmICghZHVwbGljYXRlTW92ZSAmJiAhdGhpcy5zaW11bGF0aW9uKSB7XG4gICAgICAvLyBpZiBpbnRlcmFjdGluZywgZmlyZSBhbiAnYWN0aW9uLW1vdmUnIHNpZ25hbCBldGNcbiAgICAgIGlmICh0aGlzLmludGVyYWN0aW5nKCkpIHtcbiAgICAgICAgc2lnbmFsQXJnLnR5cGUgPSBudWxsO1xuICAgICAgICB0aGlzLm1vdmUoc2lnbmFsQXJnKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMucG9pbnRlcldhc01vdmVkKSB7XG4gICAgICAgIGNvcHlDb29yZHModGhpcy5jb29yZHMucHJldiwgdGhpcy5jb29yZHMuY3VyKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIGBgYGpzXG4gICAqIGludGVyYWN0KHRhcmdldClcbiAgICogICAuZHJhZ2dhYmxlKHRydWUpXG4gICAqICAgLm9uKCdkcmFnbW92ZScsIGZ1bmN0aW9uIChldmVudCkge1xuICAgKiAgICAgaWYgKHNvbWVDb25kaXRpb24pIHtcbiAgICogICAgICAgLy8gY2hhbmdlIHRoZSBzbmFwIHNldHRpbmdzXG4gICAqICAgICAgIGV2ZW50LmludGVyYWN0YWJsZS5kcmFnZ2FibGUoeyBzbmFwOiB7IHRhcmdldHM6IFtdIH19KVxuICAgKiAgICAgICAvLyBmaXJlIGFub3RoZXIgbW92ZSBldmVudCB3aXRoIHJlLWNhbGN1bGF0ZWQgc25hcFxuICAgKiAgICAgICBldmVudC5pbnRlcmFjdGlvbi5tb3ZlKClcbiAgICogICAgIH1cbiAgICogICB9KVxuICAgKiBgYGBcbiAgICpcbiAgICogRm9yY2UgYSBtb3ZlIG9mIHRoZSBjdXJyZW50IGFjdGlvbiBhdCB0aGUgc2FtZSBjb29yZGluYXRlcy4gVXNlZnVsIGlmXG4gICAqIHNuYXAvcmVzdHJpY3QgaGFzIGJlZW4gY2hhbmdlZCBhbmQgeW91IHdhbnQgYSBtb3ZlbWVudCB3aXRoIHRoZSBuZXdcbiAgICogc2V0dGluZ3MuXG4gICAqL1xuXG5cbiAgbW92ZShzaWduYWxBcmcpIHtcbiAgICBpZiAoIXNpZ25hbEFyZyB8fCAhc2lnbmFsQXJnLmV2ZW50KSB7XG4gICAgICBzZXRaZXJvQ29vcmRzKHRoaXMuY29vcmRzLmRlbHRhKTtcbiAgICB9XG5cbiAgICBzaWduYWxBcmcgPSBleHRlbmQoe1xuICAgICAgcG9pbnRlcjogdGhpcy5fbGF0ZXN0UG9pbnRlci5wb2ludGVyLFxuICAgICAgZXZlbnQ6IHRoaXMuX2xhdGVzdFBvaW50ZXIuZXZlbnQsXG4gICAgICBldmVudFRhcmdldDogdGhpcy5fbGF0ZXN0UG9pbnRlci5ldmVudFRhcmdldCxcbiAgICAgIGludGVyYWN0aW9uOiB0aGlzXG4gICAgfSwgc2lnbmFsQXJnIHx8IHt9KTtcbiAgICBzaWduYWxBcmcucGhhc2UgPSAnbW92ZSc7XG5cbiAgICB0aGlzLl9kb1BoYXNlKHNpZ25hbEFyZyk7XG4gIH0gLy8gRW5kIGludGVyYWN0IG1vdmUgZXZlbnRzIGFuZCBzdG9wIGF1dG8tc2Nyb2xsIHVubGVzcyBzaW11bGF0aW9uIGlzIHJ1bm5pbmdcblxuXG4gIHBvaW50ZXJVcChwb2ludGVyLCBldmVudCwgZXZlbnRUYXJnZXQsIGN1ckV2ZW50VGFyZ2V0KSB7XG4gICAgbGV0IHBvaW50ZXJJbmRleCA9IHRoaXMuZ2V0UG9pbnRlckluZGV4KHBvaW50ZXIpO1xuXG4gICAgaWYgKHBvaW50ZXJJbmRleCA9PT0gLTEpIHtcbiAgICAgIHBvaW50ZXJJbmRleCA9IHRoaXMudXBkYXRlUG9pbnRlcihwb2ludGVyLCBldmVudCwgZXZlbnRUYXJnZXQsIGZhbHNlKTtcbiAgICB9XG5cbiAgICBjb25zdCB0eXBlID0gL2NhbmNlbCQvaS50ZXN0KGV2ZW50LnR5cGUpID8gJ2NhbmNlbCcgOiAndXAnO1xuXG4gICAgdGhpcy5fc2NvcGVGaXJlKGBpbnRlcmFjdGlvbnM6JHt0eXBlfWAsIHtcbiAgICAgIHBvaW50ZXIsXG4gICAgICBwb2ludGVySW5kZXgsXG4gICAgICBwb2ludGVySW5mbzogdGhpcy5wb2ludGVyc1twb2ludGVySW5kZXhdLFxuICAgICAgZXZlbnQsXG4gICAgICBldmVudFRhcmdldCxcbiAgICAgIHR5cGU6IHR5cGUsXG4gICAgICBjdXJFdmVudFRhcmdldCxcbiAgICAgIGludGVyYWN0aW9uOiB0aGlzXG4gICAgfSk7XG5cbiAgICBpZiAoIXRoaXMuc2ltdWxhdGlvbikge1xuICAgICAgdGhpcy5lbmQoZXZlbnQpO1xuICAgIH1cblxuICAgIHRoaXMucmVtb3ZlUG9pbnRlcihwb2ludGVyLCBldmVudCk7XG4gIH1cblxuICBkb2N1bWVudEJsdXIoZXZlbnQpIHtcbiAgICB0aGlzLmVuZChldmVudCk7XG5cbiAgICB0aGlzLl9zY29wZUZpcmUoJ2ludGVyYWN0aW9uczpibHVyJywge1xuICAgICAgZXZlbnQsXG4gICAgICB0eXBlOiAnYmx1cicsXG4gICAgICBpbnRlcmFjdGlvbjogdGhpc1xuICAgIH0pO1xuICB9XG4gIC8qKlxuICAgKiBgYGBqc1xuICAgKiBpbnRlcmFjdCh0YXJnZXQpXG4gICAqICAgLmRyYWdnYWJsZSh0cnVlKVxuICAgKiAgIC5vbignbW92ZScsIGZ1bmN0aW9uIChldmVudCkge1xuICAgKiAgICAgaWYgKGV2ZW50LnBhZ2VYID4gMTAwMCkge1xuICAgKiAgICAgICAvLyBlbmQgdGhlIGN1cnJlbnQgYWN0aW9uXG4gICAqICAgICAgIGV2ZW50LmludGVyYWN0aW9uLmVuZCgpXG4gICAqICAgICAgIC8vIHN0b3AgYWxsIGZ1cnRoZXIgbGlzdGVuZXJzIGZyb20gYmVpbmcgY2FsbGVkXG4gICAqICAgICAgIGV2ZW50LnN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbigpXG4gICAqICAgICB9XG4gICAqICAgfSlcbiAgICogYGBgXG4gICAqXG4gICAqIEBwYXJhbSB7UG9pbnRlckV2ZW50fSBbZXZlbnRdXG4gICAqL1xuXG5cbiAgZW5kKGV2ZW50KSB7XG4gICAgdGhpcy5fZW5kaW5nID0gdHJ1ZTtcbiAgICBldmVudCA9IGV2ZW50IHx8IHRoaXMuX2xhdGVzdFBvaW50ZXIuZXZlbnQ7XG4gICAgbGV0IGVuZFBoYXNlUmVzdWx0O1xuXG4gICAgaWYgKHRoaXMuaW50ZXJhY3RpbmcoKSkge1xuICAgICAgZW5kUGhhc2VSZXN1bHQgPSB0aGlzLl9kb1BoYXNlKHtcbiAgICAgICAgZXZlbnQsXG4gICAgICAgIGludGVyYWN0aW9uOiB0aGlzLFxuICAgICAgICBwaGFzZTogJ2VuZCdcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIHRoaXMuX2VuZGluZyA9IGZhbHNlO1xuXG4gICAgaWYgKGVuZFBoYXNlUmVzdWx0ID09PSB0cnVlKSB7XG4gICAgICB0aGlzLnN0b3AoKTtcbiAgICB9XG4gIH1cblxuICBjdXJyZW50QWN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLl9pbnRlcmFjdGluZyA/IHRoaXMucHJlcGFyZWQubmFtZSA6IG51bGw7XG4gIH1cblxuICBpbnRlcmFjdGluZygpIHtcbiAgICByZXR1cm4gdGhpcy5faW50ZXJhY3Rpbmc7XG4gIH1cbiAgLyoqICovXG5cblxuICBzdG9wKCkge1xuICAgIHRoaXMuX3Njb3BlRmlyZSgnaW50ZXJhY3Rpb25zOnN0b3AnLCB7XG4gICAgICBpbnRlcmFjdGlvbjogdGhpc1xuICAgIH0pO1xuXG4gICAgdGhpcy5pbnRlcmFjdGFibGUgPSB0aGlzLmVsZW1lbnQgPSBudWxsO1xuICAgIHRoaXMuX2ludGVyYWN0aW5nID0gZmFsc2U7XG4gICAgdGhpcy5fc3RvcHBlZCA9IHRydWU7XG4gICAgdGhpcy5wcmVwYXJlZC5uYW1lID0gdGhpcy5wcmV2RXZlbnQgPSBudWxsO1xuICB9XG5cbiAgZ2V0UG9pbnRlckluZGV4KHBvaW50ZXIpIHtcbiAgICBjb25zdCBwb2ludGVySWQgPSBnZXRQb2ludGVySWQocG9pbnRlcik7IC8vIG1vdXNlIGFuZCBwZW4gaW50ZXJhY3Rpb25zIG1heSBoYXZlIG9ubHkgb25lIHBvaW50ZXJcblxuICAgIHJldHVybiB0aGlzLnBvaW50ZXJUeXBlID09PSAnbW91c2UnIHx8IHRoaXMucG9pbnRlclR5cGUgPT09ICdwZW4nID8gdGhpcy5wb2ludGVycy5sZW5ndGggLSAxIDogZmluZEluZGV4KHRoaXMucG9pbnRlcnMsIGN1clBvaW50ZXIgPT4gY3VyUG9pbnRlci5pZCA9PT0gcG9pbnRlcklkKTtcbiAgfVxuXG4gIGdldFBvaW50ZXJJbmZvKHBvaW50ZXIpIHtcbiAgICByZXR1cm4gdGhpcy5wb2ludGVyc1t0aGlzLmdldFBvaW50ZXJJbmRleChwb2ludGVyKV07XG4gIH1cblxuICB1cGRhdGVQb2ludGVyKHBvaW50ZXIsIGV2ZW50LCBldmVudFRhcmdldCwgZG93bikge1xuICAgIGNvbnN0IGlkID0gZ2V0UG9pbnRlcklkKHBvaW50ZXIpO1xuICAgIGxldCBwb2ludGVySW5kZXggPSB0aGlzLmdldFBvaW50ZXJJbmRleChwb2ludGVyKTtcbiAgICBsZXQgcG9pbnRlckluZm8gPSB0aGlzLnBvaW50ZXJzW3BvaW50ZXJJbmRleF07XG4gICAgZG93biA9IGRvd24gPT09IGZhbHNlID8gZmFsc2UgOiBkb3duIHx8IC8oZG93bnxzdGFydCkkL2kudGVzdChldmVudC50eXBlKTtcblxuICAgIGlmICghcG9pbnRlckluZm8pIHtcbiAgICAgIHBvaW50ZXJJbmZvID0gbmV3IFBvaW50ZXJJbmZvKGlkLCBwb2ludGVyLCBldmVudCwgbnVsbCwgbnVsbCk7XG4gICAgICBwb2ludGVySW5kZXggPSB0aGlzLnBvaW50ZXJzLmxlbmd0aDtcbiAgICAgIHRoaXMucG9pbnRlcnMucHVzaChwb2ludGVySW5mbyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHBvaW50ZXJJbmZvLnBvaW50ZXIgPSBwb2ludGVyO1xuICAgIH1cblxuICAgIHNldENvb3Jkcyh0aGlzLmNvb3Jkcy5jdXIsIHRoaXMucG9pbnRlcnMubWFwKHAgPT4gcC5wb2ludGVyKSwgdGhpcy5fbm93KCkpO1xuICAgIHNldENvb3JkRGVsdGFzKHRoaXMuY29vcmRzLmRlbHRhLCB0aGlzLmNvb3Jkcy5wcmV2LCB0aGlzLmNvb3Jkcy5jdXIpO1xuXG4gICAgaWYgKGRvd24pIHtcbiAgICAgIHRoaXMucG9pbnRlcklzRG93biA9IHRydWU7XG4gICAgICBwb2ludGVySW5mby5kb3duVGltZSA9IHRoaXMuY29vcmRzLmN1ci50aW1lU3RhbXA7XG4gICAgICBwb2ludGVySW5mby5kb3duVGFyZ2V0ID0gZXZlbnRUYXJnZXQ7XG4gICAgICB1dGlsc19wb2ludGVyRXh0ZW5kKHRoaXMuZG93blBvaW50ZXIsIHBvaW50ZXIpO1xuXG4gICAgICBpZiAoIXRoaXMuaW50ZXJhY3RpbmcoKSkge1xuICAgICAgICBjb3B5Q29vcmRzKHRoaXMuY29vcmRzLnN0YXJ0LCB0aGlzLmNvb3Jkcy5jdXIpO1xuICAgICAgICBjb3B5Q29vcmRzKHRoaXMuY29vcmRzLnByZXYsIHRoaXMuY29vcmRzLmN1cik7XG4gICAgICAgIHRoaXMuZG93bkV2ZW50ID0gZXZlbnQ7XG4gICAgICAgIHRoaXMucG9pbnRlcldhc01vdmVkID0gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdGhpcy5fdXBkYXRlTGF0ZXN0UG9pbnRlcihwb2ludGVyLCBldmVudCwgZXZlbnRUYXJnZXQpO1xuXG4gICAgdGhpcy5fc2NvcGVGaXJlKCdpbnRlcmFjdGlvbnM6dXBkYXRlLXBvaW50ZXInLCB7XG4gICAgICBwb2ludGVyLFxuICAgICAgZXZlbnQsXG4gICAgICBldmVudFRhcmdldCxcbiAgICAgIGRvd24sXG4gICAgICBwb2ludGVySW5mbyxcbiAgICAgIHBvaW50ZXJJbmRleCxcbiAgICAgIGludGVyYWN0aW9uOiB0aGlzXG4gICAgfSk7XG5cbiAgICByZXR1cm4gcG9pbnRlckluZGV4O1xuICB9XG5cbiAgcmVtb3ZlUG9pbnRlcihwb2ludGVyLCBldmVudCkge1xuICAgIGNvbnN0IHBvaW50ZXJJbmRleCA9IHRoaXMuZ2V0UG9pbnRlckluZGV4KHBvaW50ZXIpO1xuXG4gICAgaWYgKHBvaW50ZXJJbmRleCA9PT0gLTEpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjb25zdCBwb2ludGVySW5mbyA9IHRoaXMucG9pbnRlcnNbcG9pbnRlckluZGV4XTtcblxuICAgIHRoaXMuX3Njb3BlRmlyZSgnaW50ZXJhY3Rpb25zOnJlbW92ZS1wb2ludGVyJywge1xuICAgICAgcG9pbnRlcixcbiAgICAgIGV2ZW50LFxuICAgICAgZXZlbnRUYXJnZXQ6IG51bGwsXG4gICAgICBwb2ludGVySW5kZXgsXG4gICAgICBwb2ludGVySW5mbyxcbiAgICAgIGludGVyYWN0aW9uOiB0aGlzXG4gICAgfSk7XG5cbiAgICB0aGlzLnBvaW50ZXJzLnNwbGljZShwb2ludGVySW5kZXgsIDEpO1xuICAgIHRoaXMucG9pbnRlcklzRG93biA9IGZhbHNlO1xuICB9XG5cbiAgX3VwZGF0ZUxhdGVzdFBvaW50ZXIocG9pbnRlciwgZXZlbnQsIGV2ZW50VGFyZ2V0KSB7XG4gICAgdGhpcy5fbGF0ZXN0UG9pbnRlci5wb2ludGVyID0gcG9pbnRlcjtcbiAgICB0aGlzLl9sYXRlc3RQb2ludGVyLmV2ZW50ID0gZXZlbnQ7XG4gICAgdGhpcy5fbGF0ZXN0UG9pbnRlci5ldmVudFRhcmdldCA9IGV2ZW50VGFyZ2V0O1xuICB9XG5cbiAgZGVzdHJveSgpIHtcbiAgICB0aGlzLl9sYXRlc3RQb2ludGVyLnBvaW50ZXIgPSBudWxsO1xuICAgIHRoaXMuX2xhdGVzdFBvaW50ZXIuZXZlbnQgPSBudWxsO1xuICAgIHRoaXMuX2xhdGVzdFBvaW50ZXIuZXZlbnRUYXJnZXQgPSBudWxsO1xuICB9XG5cbiAgX2NyZWF0ZVByZXBhcmVkRXZlbnQoZXZlbnQsIHBoYXNlLCBwcmVFbmQsIHR5cGUpIHtcbiAgICByZXR1cm4gbmV3IEludGVyYWN0RXZlbnRfSW50ZXJhY3RFdmVudCh0aGlzLCBldmVudCwgdGhpcy5wcmVwYXJlZC5uYW1lLCBwaGFzZSwgdGhpcy5lbGVtZW50LCBwcmVFbmQsIHR5cGUpO1xuICB9XG5cbiAgX2ZpcmVFdmVudChpRXZlbnQpIHtcbiAgICB0aGlzLmludGVyYWN0YWJsZS5maXJlKGlFdmVudCk7XG5cbiAgICBpZiAoIXRoaXMucHJldkV2ZW50IHx8IGlFdmVudC50aW1lU3RhbXAgPj0gdGhpcy5wcmV2RXZlbnQudGltZVN0YW1wKSB7XG4gICAgICB0aGlzLnByZXZFdmVudCA9IGlFdmVudDtcbiAgICB9XG4gIH1cblxuICBfZG9QaGFzZShzaWduYWxBcmcpIHtcbiAgICBjb25zdCB7XG4gICAgICBldmVudCxcbiAgICAgIHBoYXNlLFxuICAgICAgcHJlRW5kLFxuICAgICAgdHlwZVxuICAgIH0gPSBzaWduYWxBcmc7XG4gICAgY29uc3Qge1xuICAgICAgcmVjdFxuICAgIH0gPSB0aGlzO1xuXG4gICAgaWYgKHJlY3QgJiYgcGhhc2UgPT09ICdtb3ZlJykge1xuICAgICAgLy8gdXBkYXRlIHRoZSByZWN0IGNoYW5nZXMgZHVlIHRvIHBvaW50ZXIgbW92ZVxuICAgICAgYWRkRWRnZXModGhpcy5lZGdlcywgcmVjdCwgdGhpcy5jb29yZHMuZGVsdGFbdGhpcy5pbnRlcmFjdGFibGUub3B0aW9ucy5kZWx0YVNvdXJjZV0pO1xuICAgICAgcmVjdC53aWR0aCA9IHJlY3QucmlnaHQgLSByZWN0LmxlZnQ7XG4gICAgICByZWN0LmhlaWdodCA9IHJlY3QuYm90dG9tIC0gcmVjdC50b3A7XG4gICAgfVxuXG4gICAgY29uc3QgYmVmb3JlUmVzdWx0ID0gdGhpcy5fc2NvcGVGaXJlKGBpbnRlcmFjdGlvbnM6YmVmb3JlLWFjdGlvbi0ke3BoYXNlfWAsIHNpZ25hbEFyZyk7XG5cbiAgICBpZiAoYmVmb3JlUmVzdWx0ID09PSBmYWxzZSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGNvbnN0IGlFdmVudCA9IHNpZ25hbEFyZy5pRXZlbnQgPSB0aGlzLl9jcmVhdGVQcmVwYXJlZEV2ZW50KGV2ZW50LCBwaGFzZSwgcHJlRW5kLCB0eXBlKTtcblxuICAgIHRoaXMuX3Njb3BlRmlyZShgaW50ZXJhY3Rpb25zOmFjdGlvbi0ke3BoYXNlfWAsIHNpZ25hbEFyZyk7XG5cbiAgICBpZiAocGhhc2UgPT09ICdzdGFydCcpIHtcbiAgICAgIHRoaXMucHJldkV2ZW50ID0gaUV2ZW50O1xuICAgIH1cblxuICAgIHRoaXMuX2ZpcmVFdmVudChpRXZlbnQpO1xuXG4gICAgdGhpcy5fc2NvcGVGaXJlKGBpbnRlcmFjdGlvbnM6YWZ0ZXItYWN0aW9uLSR7cGhhc2V9YCwgc2lnbmFsQXJnKTtcblxuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgX25vdygpIHtcbiAgICByZXR1cm4gRGF0ZS5ub3coKTtcbiAgfVxuXG59XG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIHZhciBjb3JlX0ludGVyYWN0aW9uID0gKEludGVyYWN0aW9uX0ludGVyYWN0aW9uKTtcblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9SW50ZXJhY3Rpb24uanMubWFwXG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL25vZGVfbW9kdWxlcy9AaW50ZXJhY3Rqcy9jb3JlL2ludGVyYWN0YWJsZVByZXZlbnREZWZhdWx0LmpzXG5cblxuXG5cblxuZnVuY3Rpb24gcHJldmVudERlZmF1bHQobmV3VmFsdWUpIHtcbiAgaWYgKC9eKGFsd2F5c3xuZXZlcnxhdXRvKSQvLnRlc3QobmV3VmFsdWUpKSB7XG4gICAgdGhpcy5vcHRpb25zLnByZXZlbnREZWZhdWx0ID0gbmV3VmFsdWU7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICBpZiAoaXMuYm9vbChuZXdWYWx1ZSkpIHtcbiAgICB0aGlzLm9wdGlvbnMucHJldmVudERlZmF1bHQgPSBuZXdWYWx1ZSA/ICdhbHdheXMnIDogJ25ldmVyJztcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIHJldHVybiB0aGlzLm9wdGlvbnMucHJldmVudERlZmF1bHQ7XG59XG5cbmZ1bmN0aW9uIGNoZWNrQW5kUHJldmVudERlZmF1bHQoaW50ZXJhY3RhYmxlLCBzY29wZSwgZXZlbnQpIHtcbiAgY29uc3Qgc2V0dGluZyA9IGludGVyYWN0YWJsZS5vcHRpb25zLnByZXZlbnREZWZhdWx0O1xuXG4gIGlmIChzZXR0aW5nID09PSAnbmV2ZXInKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgaWYgKHNldHRpbmcgPT09ICdhbHdheXMnKSB7XG4gICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICByZXR1cm47XG4gIH0gLy8gc2V0dGluZyA9PT0gJ2F1dG8nXG4gIC8vIGlmIHRoZSBicm93c2VyIHN1cHBvcnRzIHBhc3NpdmUgZXZlbnQgbGlzdGVuZXJzIGFuZCBpc24ndCBydW5uaW5nIG9uIGlPUyxcbiAgLy8gZG9uJ3QgcHJldmVudERlZmF1bHQgb2YgdG91Y2h7c3RhcnQsbW92ZX0gZXZlbnRzLiBDU1MgdG91Y2gtYWN0aW9uIGFuZFxuICAvLyB1c2VyLXNlbGVjdCBzaG91bGQgYmUgdXNlZCBpbnN0ZWFkIG9mIGNhbGxpbmcgZXZlbnQucHJldmVudERlZmF1bHQoKS5cblxuXG4gIGlmIChzY29wZS5ldmVudHMuc3VwcG9ydHNQYXNzaXZlICYmIC9edG91Y2goc3RhcnR8bW92ZSkkLy50ZXN0KGV2ZW50LnR5cGUpKSB7XG4gICAgY29uc3QgZG9jID0gZ2V0V2luZG93KGV2ZW50LnRhcmdldCkuZG9jdW1lbnQ7XG4gICAgY29uc3QgZG9jT3B0aW9ucyA9IHNjb3BlLmdldERvY09wdGlvbnMoZG9jKTtcblxuICAgIGlmICghKGRvY09wdGlvbnMgJiYgZG9jT3B0aW9ucy5ldmVudHMpIHx8IGRvY09wdGlvbnMuZXZlbnRzLnBhc3NpdmUgIT09IGZhbHNlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICB9IC8vIGRvbid0IHByZXZlbnREZWZhdWx0IG9mIHBvaW50ZXJkb3duIGV2ZW50c1xuXG5cbiAgaWYgKC9eKG1vdXNlfHBvaW50ZXJ8dG91Y2gpKihkb3dufHN0YXJ0KS9pLnRlc3QoZXZlbnQudHlwZSkpIHtcbiAgICByZXR1cm47XG4gIH0gLy8gZG9uJ3QgcHJldmVudERlZmF1bHQgb24gZWRpdGFibGUgZWxlbWVudHNcblxuXG4gIGlmIChpcy5lbGVtZW50KGV2ZW50LnRhcmdldCkgJiYgbWF0Y2hlc1NlbGVjdG9yKGV2ZW50LnRhcmdldCwgJ2lucHV0LHNlbGVjdCx0ZXh0YXJlYSxbY29udGVudGVkaXRhYmxlPXRydWVdLFtjb250ZW50ZWRpdGFibGU9dHJ1ZV0gKicpKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbn1cblxuZnVuY3Rpb24gb25JbnRlcmFjdGlvbkV2ZW50KHtcbiAgaW50ZXJhY3Rpb24sXG4gIGV2ZW50XG59KSB7XG4gIGlmIChpbnRlcmFjdGlvbi5pbnRlcmFjdGFibGUpIHtcbiAgICBpbnRlcmFjdGlvbi5pbnRlcmFjdGFibGUuY2hlY2tBbmRQcmV2ZW50RGVmYXVsdChldmVudCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gaW50ZXJhY3RhYmxlUHJldmVudERlZmF1bHRfaW5zdGFsbChzY29wZSkge1xuICAvKiogQGxlbmRzIEludGVyYWN0YWJsZSAqL1xuICBjb25zdCB7XG4gICAgSW50ZXJhY3RhYmxlXG4gIH0gPSBzY29wZTtcbiAgLyoqXG4gICAqIFJldHVybnMgb3Igc2V0cyB3aGV0aGVyIHRvIHByZXZlbnQgdGhlIGJyb3dzZXIncyBkZWZhdWx0IGJlaGF2aW91ciBpblxuICAgKiByZXNwb25zZSB0byBwb2ludGVyIGV2ZW50cy4gQ2FuIGJlIHNldCB0bzpcbiAgICogIC0gYCdhbHdheXMnYCB0byBhbHdheXMgcHJldmVudFxuICAgKiAgLSBgJ25ldmVyJ2AgdG8gbmV2ZXIgcHJldmVudFxuICAgKiAgLSBgJ2F1dG8nYCB0byBsZXQgaW50ZXJhY3QuanMgdHJ5IHRvIGRldGVybWluZSB3aGF0IHdvdWxkIGJlIGJlc3RcbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IFtuZXdWYWx1ZV0gYCdhbHdheXMnYCwgYCduZXZlcidgIG9yIGAnYXV0bydgXG4gICAqIEByZXR1cm4ge3N0cmluZyB8IEludGVyYWN0YWJsZX0gVGhlIGN1cnJlbnQgc2V0dGluZyBvciB0aGlzIEludGVyYWN0YWJsZVxuICAgKi9cblxuICBJbnRlcmFjdGFibGUucHJvdG90eXBlLnByZXZlbnREZWZhdWx0ID0gcHJldmVudERlZmF1bHQ7XG5cbiAgSW50ZXJhY3RhYmxlLnByb3RvdHlwZS5jaGVja0FuZFByZXZlbnREZWZhdWx0ID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgcmV0dXJuIGNoZWNrQW5kUHJldmVudERlZmF1bHQodGhpcywgc2NvcGUsIGV2ZW50KTtcbiAgfTsgLy8gcHJldmVudCBuYXRpdmUgSFRNTDUgZHJhZyBvbiBpbnRlcmFjdC5qcyB0YXJnZXQgZWxlbWVudHNcblxuXG4gIHNjb3BlLmludGVyYWN0aW9ucy5kb2NFdmVudHMucHVzaCh7XG4gICAgdHlwZTogJ2RyYWdzdGFydCcsXG5cbiAgICBsaXN0ZW5lcihldmVudCkge1xuICAgICAgZm9yIChjb25zdCBpbnRlcmFjdGlvbiBvZiBzY29wZS5pbnRlcmFjdGlvbnMubGlzdCkge1xuICAgICAgICBpZiAoaW50ZXJhY3Rpb24uZWxlbWVudCAmJiAoaW50ZXJhY3Rpb24uZWxlbWVudCA9PT0gZXZlbnQudGFyZ2V0IHx8IG5vZGVDb250YWlucyhpbnRlcmFjdGlvbi5lbGVtZW50LCBldmVudC50YXJnZXQpKSkge1xuICAgICAgICAgIGludGVyYWN0aW9uLmludGVyYWN0YWJsZS5jaGVja0FuZFByZXZlbnREZWZhdWx0KGV2ZW50KTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgfSk7XG59XG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIHZhciBpbnRlcmFjdGFibGVQcmV2ZW50RGVmYXVsdCA9ICh7XG4gIGlkOiAnY29yZS9pbnRlcmFjdGFibGVQcmV2ZW50RGVmYXVsdCcsXG4gIGluc3RhbGw6IGludGVyYWN0YWJsZVByZXZlbnREZWZhdWx0X2luc3RhbGwsXG4gIGxpc3RlbmVyczogWydkb3duJywgJ21vdmUnLCAndXAnLCAnY2FuY2VsJ10ucmVkdWNlKChhY2MsIGV2ZW50VHlwZSkgPT4ge1xuICAgIGFjY1tgaW50ZXJhY3Rpb25zOiR7ZXZlbnRUeXBlfWBdID0gb25JbnRlcmFjdGlvbkV2ZW50O1xuICAgIHJldHVybiBhY2M7XG4gIH0sIHt9KVxufSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbnRlcmFjdGFibGVQcmV2ZW50RGVmYXVsdC5qcy5tYXBcbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vbm9kZV9tb2R1bGVzL0BpbnRlcmFjdGpzL2NvcmUvaW50ZXJhY3Rpb25GaW5kZXIuanNcblxuY29uc3QgZmluZGVyID0ge1xuICBtZXRob2RPcmRlcjogWydzaW11bGF0aW9uUmVzdW1lJywgJ21vdXNlT3JQZW4nLCAnaGFzUG9pbnRlcicsICdpZGxlJ10sXG5cbiAgc2VhcmNoKGRldGFpbHMpIHtcbiAgICBmb3IgKGNvbnN0IG1ldGhvZCBvZiBmaW5kZXIubWV0aG9kT3JkZXIpIHtcbiAgICAgIGNvbnN0IGludGVyYWN0aW9uID0gZmluZGVyW21ldGhvZF0oZGV0YWlscyk7XG5cbiAgICAgIGlmIChpbnRlcmFjdGlvbikge1xuICAgICAgICByZXR1cm4gaW50ZXJhY3Rpb247XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIG51bGw7XG4gIH0sXG5cbiAgLy8gdHJ5IHRvIHJlc3VtZSBzaW11bGF0aW9uIHdpdGggYSBuZXcgcG9pbnRlclxuICBzaW11bGF0aW9uUmVzdW1lKHtcbiAgICBwb2ludGVyVHlwZSxcbiAgICBldmVudFR5cGUsXG4gICAgZXZlbnRUYXJnZXQsXG4gICAgc2NvcGVcbiAgfSkge1xuICAgIGlmICghL2Rvd258c3RhcnQvaS50ZXN0KGV2ZW50VHlwZSkpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIGZvciAoY29uc3QgaW50ZXJhY3Rpb24gb2Ygc2NvcGUuaW50ZXJhY3Rpb25zLmxpc3QpIHtcbiAgICAgIGxldCBlbGVtZW50ID0gZXZlbnRUYXJnZXQ7XG5cbiAgICAgIGlmIChpbnRlcmFjdGlvbi5zaW11bGF0aW9uICYmIGludGVyYWN0aW9uLnNpbXVsYXRpb24uYWxsb3dSZXN1bWUgJiYgaW50ZXJhY3Rpb24ucG9pbnRlclR5cGUgPT09IHBvaW50ZXJUeXBlKSB7XG4gICAgICAgIHdoaWxlIChlbGVtZW50KSB7XG4gICAgICAgICAgLy8gaWYgdGhlIGVsZW1lbnQgaXMgdGhlIGludGVyYWN0aW9uIGVsZW1lbnRcbiAgICAgICAgICBpZiAoZWxlbWVudCA9PT0gaW50ZXJhY3Rpb24uZWxlbWVudCkge1xuICAgICAgICAgICAgcmV0dXJuIGludGVyYWN0aW9uO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGVsZW1lbnQgPSBwYXJlbnROb2RlKGVsZW1lbnQpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIG51bGw7XG4gIH0sXG5cbiAgLy8gaWYgaXQncyBhIG1vdXNlIG9yIHBlbiBpbnRlcmFjdGlvblxuICBtb3VzZU9yUGVuKHtcbiAgICBwb2ludGVySWQsXG4gICAgcG9pbnRlclR5cGUsXG4gICAgZXZlbnRUeXBlLFxuICAgIHNjb3BlXG4gIH0pIHtcbiAgICBpZiAocG9pbnRlclR5cGUgIT09ICdtb3VzZScgJiYgcG9pbnRlclR5cGUgIT09ICdwZW4nKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICBsZXQgZmlyc3ROb25BY3RpdmU7XG5cbiAgICBmb3IgKGNvbnN0IGludGVyYWN0aW9uIG9mIHNjb3BlLmludGVyYWN0aW9ucy5saXN0KSB7XG4gICAgICBpZiAoaW50ZXJhY3Rpb24ucG9pbnRlclR5cGUgPT09IHBvaW50ZXJUeXBlKSB7XG4gICAgICAgIC8vIGlmIGl0J3MgYSBkb3duIGV2ZW50LCBza2lwIGludGVyYWN0aW9ucyB3aXRoIHJ1bm5pbmcgc2ltdWxhdGlvbnNcbiAgICAgICAgaWYgKGludGVyYWN0aW9uLnNpbXVsYXRpb24gJiYgIWhhc1BvaW50ZXJJZChpbnRlcmFjdGlvbiwgcG9pbnRlcklkKSkge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9IC8vIGlmIHRoZSBpbnRlcmFjdGlvbiBpcyBhY3RpdmUsIHJldHVybiBpdCBpbW1lZGlhdGVseVxuXG5cbiAgICAgICAgaWYgKGludGVyYWN0aW9uLmludGVyYWN0aW5nKCkpIHtcbiAgICAgICAgICByZXR1cm4gaW50ZXJhY3Rpb247XG4gICAgICAgIH0gLy8gb3RoZXJ3aXNlIHNhdmUgaXQgYW5kIGxvb2sgZm9yIGFub3RoZXIgYWN0aXZlIGludGVyYWN0aW9uXG4gICAgICAgIGVsc2UgaWYgKCFmaXJzdE5vbkFjdGl2ZSkge1xuICAgICAgICAgICAgZmlyc3ROb25BY3RpdmUgPSBpbnRlcmFjdGlvbjtcbiAgICAgICAgICB9XG4gICAgICB9XG4gICAgfSAvLyBpZiBubyBhY3RpdmUgbW91c2UgaW50ZXJhY3Rpb24gd2FzIGZvdW5kIHVzZSB0aGUgZmlyc3QgaW5hY3RpdmUgbW91c2VcbiAgICAvLyBpbnRlcmFjdGlvblxuXG5cbiAgICBpZiAoZmlyc3ROb25BY3RpdmUpIHtcbiAgICAgIHJldHVybiBmaXJzdE5vbkFjdGl2ZTtcbiAgICB9IC8vIGZpbmQgYW55IG1vdXNlIG9yIHBlbiBpbnRlcmFjdGlvbi5cbiAgICAvLyBpZ25vcmUgdGhlIGludGVyYWN0aW9uIGlmIHRoZSBldmVudFR5cGUgaXMgYSAqZG93biwgYW5kIGEgc2ltdWxhdGlvblxuICAgIC8vIGlzIGFjdGl2ZVxuXG5cbiAgICBmb3IgKGNvbnN0IGludGVyYWN0aW9uIG9mIHNjb3BlLmludGVyYWN0aW9ucy5saXN0KSB7XG4gICAgICBpZiAoaW50ZXJhY3Rpb24ucG9pbnRlclR5cGUgPT09IHBvaW50ZXJUeXBlICYmICEoL2Rvd24vaS50ZXN0KGV2ZW50VHlwZSkgJiYgaW50ZXJhY3Rpb24uc2ltdWxhdGlvbikpIHtcbiAgICAgICAgcmV0dXJuIGludGVyYWN0aW9uO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBudWxsO1xuICB9LFxuXG4gIC8vIGdldCBpbnRlcmFjdGlvbiB0aGF0IGhhcyB0aGlzIHBvaW50ZXJcbiAgaGFzUG9pbnRlcih7XG4gICAgcG9pbnRlcklkLFxuICAgIHNjb3BlXG4gIH0pIHtcbiAgICBmb3IgKGNvbnN0IGludGVyYWN0aW9uIG9mIHNjb3BlLmludGVyYWN0aW9ucy5saXN0KSB7XG4gICAgICBpZiAoaGFzUG9pbnRlcklkKGludGVyYWN0aW9uLCBwb2ludGVySWQpKSB7XG4gICAgICAgIHJldHVybiBpbnRlcmFjdGlvbjtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gbnVsbDtcbiAgfSxcblxuICAvLyBnZXQgZmlyc3QgaWRsZSBpbnRlcmFjdGlvbiB3aXRoIGEgbWF0Y2hpbmcgcG9pbnRlclR5cGVcbiAgaWRsZSh7XG4gICAgcG9pbnRlclR5cGUsXG4gICAgc2NvcGVcbiAgfSkge1xuICAgIGZvciAoY29uc3QgaW50ZXJhY3Rpb24gb2Ygc2NvcGUuaW50ZXJhY3Rpb25zLmxpc3QpIHtcbiAgICAgIC8vIGlmIHRoZXJlJ3MgYWxyZWFkeSBhIHBvaW50ZXIgaGVsZCBkb3duXG4gICAgICBpZiAoaW50ZXJhY3Rpb24ucG9pbnRlcnMubGVuZ3RoID09PSAxKSB7XG4gICAgICAgIGNvbnN0IHRhcmdldCA9IGludGVyYWN0aW9uLmludGVyYWN0YWJsZTsgLy8gZG9uJ3QgYWRkIHRoaXMgcG9pbnRlciBpZiB0aGVyZSBpcyBhIHRhcmdldCBpbnRlcmFjdGFibGUgYW5kIGl0XG4gICAgICAgIC8vIGlzbid0IGdlc3R1cmFibGVcblxuICAgICAgICBpZiAodGFyZ2V0ICYmICEodGFyZ2V0Lm9wdGlvbnMuZ2VzdHVyZSAmJiB0YXJnZXQub3B0aW9ucy5nZXN0dXJlLmVuYWJsZWQpKSB7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgIH0gLy8gbWF4aW11bSBvZiAyIHBvaW50ZXJzIHBlciBpbnRlcmFjdGlvblxuICAgICAgZWxzZSBpZiAoaW50ZXJhY3Rpb24ucG9pbnRlcnMubGVuZ3RoID49IDIpIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuXG4gICAgICBpZiAoIWludGVyYWN0aW9uLmludGVyYWN0aW5nKCkgJiYgcG9pbnRlclR5cGUgPT09IGludGVyYWN0aW9uLnBvaW50ZXJUeXBlKSB7XG4gICAgICAgIHJldHVybiBpbnRlcmFjdGlvbjtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG59O1xuXG5mdW5jdGlvbiBoYXNQb2ludGVySWQoaW50ZXJhY3Rpb24sIHBvaW50ZXJJZCkge1xuICByZXR1cm4gaW50ZXJhY3Rpb24ucG9pbnRlcnMuc29tZSgoe1xuICAgIGlkXG4gIH0pID0+IGlkID09PSBwb2ludGVySWQpO1xufVxuXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIHZhciBpbnRlcmFjdGlvbkZpbmRlciA9IChmaW5kZXIpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW50ZXJhY3Rpb25GaW5kZXIuanMubWFwXG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL25vZGVfbW9kdWxlcy9AaW50ZXJhY3Rqcy9jb3JlL2ludGVyYWN0aW9ucy5qc1xuXG5cblxuXG5cblxuXG5cbmNvbnN0IG1ldGhvZE5hbWVzID0gWydwb2ludGVyRG93bicsICdwb2ludGVyTW92ZScsICdwb2ludGVyVXAnLCAndXBkYXRlUG9pbnRlcicsICdyZW1vdmVQb2ludGVyJywgJ3dpbmRvd0JsdXInXTtcblxuZnVuY3Rpb24gaW50ZXJhY3Rpb25zX2luc3RhbGwoc2NvcGUpIHtcbiAgY29uc3QgbGlzdGVuZXJzID0ge307XG5cbiAgZm9yIChjb25zdCBtZXRob2Qgb2YgbWV0aG9kTmFtZXMpIHtcbiAgICBsaXN0ZW5lcnNbbWV0aG9kXSA9IGRvT25JbnRlcmFjdGlvbnMobWV0aG9kLCBzY29wZSk7XG4gIH1cblxuICBjb25zdCBwRXZlbnRUeXBlcyA9IHV0aWxzX2Jyb3dzZXIucEV2ZW50VHlwZXM7XG4gIGxldCBkb2NFdmVudHM7XG5cbiAgaWYgKHV0aWxzX2RvbU9iamVjdHMuUG9pbnRlckV2ZW50KSB7XG4gICAgZG9jRXZlbnRzID0gW3tcbiAgICAgIHR5cGU6IHBFdmVudFR5cGVzLmRvd24sXG4gICAgICBsaXN0ZW5lcjogcmVsZWFzZVBvaW50ZXJzT25SZW1vdmVkRWxzXG4gICAgfSwge1xuICAgICAgdHlwZTogcEV2ZW50VHlwZXMuZG93bixcbiAgICAgIGxpc3RlbmVyOiBsaXN0ZW5lcnMucG9pbnRlckRvd25cbiAgICB9LCB7XG4gICAgICB0eXBlOiBwRXZlbnRUeXBlcy5tb3ZlLFxuICAgICAgbGlzdGVuZXI6IGxpc3RlbmVycy5wb2ludGVyTW92ZVxuICAgIH0sIHtcbiAgICAgIHR5cGU6IHBFdmVudFR5cGVzLnVwLFxuICAgICAgbGlzdGVuZXI6IGxpc3RlbmVycy5wb2ludGVyVXBcbiAgICB9LCB7XG4gICAgICB0eXBlOiBwRXZlbnRUeXBlcy5jYW5jZWwsXG4gICAgICBsaXN0ZW5lcjogbGlzdGVuZXJzLnBvaW50ZXJVcFxuICAgIH1dO1xuICB9IGVsc2Uge1xuICAgIGRvY0V2ZW50cyA9IFt7XG4gICAgICB0eXBlOiAnbW91c2Vkb3duJyxcbiAgICAgIGxpc3RlbmVyOiBsaXN0ZW5lcnMucG9pbnRlckRvd25cbiAgICB9LCB7XG4gICAgICB0eXBlOiAnbW91c2Vtb3ZlJyxcbiAgICAgIGxpc3RlbmVyOiBsaXN0ZW5lcnMucG9pbnRlck1vdmVcbiAgICB9LCB7XG4gICAgICB0eXBlOiAnbW91c2V1cCcsXG4gICAgICBsaXN0ZW5lcjogbGlzdGVuZXJzLnBvaW50ZXJVcFxuICAgIH0sIHtcbiAgICAgIHR5cGU6ICd0b3VjaHN0YXJ0JyxcbiAgICAgIGxpc3RlbmVyOiByZWxlYXNlUG9pbnRlcnNPblJlbW92ZWRFbHNcbiAgICB9LCB7XG4gICAgICB0eXBlOiAndG91Y2hzdGFydCcsXG4gICAgICBsaXN0ZW5lcjogbGlzdGVuZXJzLnBvaW50ZXJEb3duXG4gICAgfSwge1xuICAgICAgdHlwZTogJ3RvdWNobW92ZScsXG4gICAgICBsaXN0ZW5lcjogbGlzdGVuZXJzLnBvaW50ZXJNb3ZlXG4gICAgfSwge1xuICAgICAgdHlwZTogJ3RvdWNoZW5kJyxcbiAgICAgIGxpc3RlbmVyOiBsaXN0ZW5lcnMucG9pbnRlclVwXG4gICAgfSwge1xuICAgICAgdHlwZTogJ3RvdWNoY2FuY2VsJyxcbiAgICAgIGxpc3RlbmVyOiBsaXN0ZW5lcnMucG9pbnRlclVwXG4gICAgfV07XG4gIH1cblxuICBkb2NFdmVudHMucHVzaCh7XG4gICAgdHlwZTogJ2JsdXInLFxuXG4gICAgbGlzdGVuZXIoZXZlbnQpIHtcbiAgICAgIGZvciAoY29uc3QgaW50ZXJhY3Rpb24gb2Ygc2NvcGUuaW50ZXJhY3Rpb25zLmxpc3QpIHtcbiAgICAgICAgaW50ZXJhY3Rpb24uZG9jdW1lbnRCbHVyKGV2ZW50KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgfSk7IC8vIGZvciBpZ25vcmluZyBicm93c2VyJ3Mgc2ltdWxhdGVkIG1vdXNlIGV2ZW50c1xuXG4gIHNjb3BlLnByZXZUb3VjaFRpbWUgPSAwO1xuICBzY29wZS5JbnRlcmFjdGlvbiA9IGNsYXNzIGV4dGVuZHMgY29yZV9JbnRlcmFjdGlvbiB7XG4gICAgZ2V0IHBvaW50ZXJNb3ZlVG9sZXJhbmNlKCkge1xuICAgICAgcmV0dXJuIHNjb3BlLmludGVyYWN0aW9ucy5wb2ludGVyTW92ZVRvbGVyYW5jZTtcbiAgICB9XG5cbiAgICBzZXQgcG9pbnRlck1vdmVUb2xlcmFuY2UodmFsdWUpIHtcbiAgICAgIHNjb3BlLmludGVyYWN0aW9ucy5wb2ludGVyTW92ZVRvbGVyYW5jZSA9IHZhbHVlO1xuICAgIH1cblxuICAgIF9ub3coKSB7XG4gICAgICByZXR1cm4gc2NvcGUubm93KCk7XG4gICAgfVxuXG4gIH07XG4gIHNjb3BlLmludGVyYWN0aW9ucyA9IHtcbiAgICAvLyBhbGwgYWN0aXZlIGFuZCBpZGxlIGludGVyYWN0aW9uc1xuICAgIGxpc3Q6IFtdLFxuXG4gICAgbmV3KG9wdGlvbnMpIHtcbiAgICAgIG9wdGlvbnMuc2NvcGVGaXJlID0gKG5hbWUsIGFyZykgPT4gc2NvcGUuZmlyZShuYW1lLCBhcmcpO1xuXG4gICAgICBjb25zdCBpbnRlcmFjdGlvbiA9IG5ldyBzY29wZS5JbnRlcmFjdGlvbihvcHRpb25zKTtcbiAgICAgIHNjb3BlLmludGVyYWN0aW9ucy5saXN0LnB1c2goaW50ZXJhY3Rpb24pO1xuICAgICAgcmV0dXJuIGludGVyYWN0aW9uO1xuICAgIH0sXG5cbiAgICBsaXN0ZW5lcnMsXG4gICAgZG9jRXZlbnRzLFxuICAgIHBvaW50ZXJNb3ZlVG9sZXJhbmNlOiAxXG4gIH07XG5cbiAgZnVuY3Rpb24gcmVsZWFzZVBvaW50ZXJzT25SZW1vdmVkRWxzKCkge1xuICAgIC8vIGZvciBhbGwgaW5hY3RpdmUgdG91Y2ggaW50ZXJhY3Rpb25zIHdpdGggcG9pbnRlcnMgZG93blxuICAgIGZvciAoY29uc3QgaW50ZXJhY3Rpb24gb2Ygc2NvcGUuaW50ZXJhY3Rpb25zLmxpc3QpIHtcbiAgICAgIGlmICghaW50ZXJhY3Rpb24ucG9pbnRlcklzRG93biB8fCBpbnRlcmFjdGlvbi5wb2ludGVyVHlwZSAhPT0gJ3RvdWNoJyB8fCBpbnRlcmFjdGlvbi5faW50ZXJhY3RpbmcpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9IC8vIGlmIGEgcG9pbnRlciBpcyBkb3duIG9uIGFuIGVsZW1lbnQgdGhhdCBpcyBubyBsb25nZXIgaW4gdGhlIERPTSB0cmVlXG5cblxuICAgICAgZm9yIChjb25zdCBwb2ludGVyIG9mIGludGVyYWN0aW9uLnBvaW50ZXJzKSB7XG4gICAgICAgIGlmICghc2NvcGUuZG9jdW1lbnRzLnNvbWUoKHtcbiAgICAgICAgICBkb2NcbiAgICAgICAgfSkgPT4gbm9kZUNvbnRhaW5zKGRvYywgcG9pbnRlci5kb3duVGFyZ2V0KSkpIHtcbiAgICAgICAgICAvLyByZW1vdmUgdGhlIHBvaW50ZXIgZnJvbSB0aGUgaW50ZXJhY3Rpb25cbiAgICAgICAgICBpbnRlcmFjdGlvbi5yZW1vdmVQb2ludGVyKHBvaW50ZXIucG9pbnRlciwgcG9pbnRlci5ldmVudCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBzY29wZS51c2VQbHVnaW4oaW50ZXJhY3RhYmxlUHJldmVudERlZmF1bHQpO1xufVxuXG5mdW5jdGlvbiBkb09uSW50ZXJhY3Rpb25zKG1ldGhvZCwgc2NvcGUpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIChldmVudCkge1xuICAgIGNvbnN0IGludGVyYWN0aW9ucyA9IHNjb3BlLmludGVyYWN0aW9ucy5saXN0O1xuICAgIGNvbnN0IHBvaW50ZXJUeXBlID0gZ2V0UG9pbnRlclR5cGUoZXZlbnQpO1xuICAgIGNvbnN0IFtldmVudFRhcmdldCwgY3VyRXZlbnRUYXJnZXRdID0gZ2V0RXZlbnRUYXJnZXRzKGV2ZW50KTtcbiAgICBjb25zdCBtYXRjaGVzID0gW107IC8vIFsgW3BvaW50ZXIsIGludGVyYWN0aW9uXSwgLi4uXVxuXG4gICAgaWYgKC9edG91Y2gvLnRlc3QoZXZlbnQudHlwZSkpIHtcbiAgICAgIHNjb3BlLnByZXZUb3VjaFRpbWUgPSBzY29wZS5ub3coKTsgLy8gQHRzLWV4cGVjdC1lcnJvclxuXG4gICAgICBmb3IgKGNvbnN0IGNoYW5nZWRUb3VjaCBvZiBldmVudC5jaGFuZ2VkVG91Y2hlcykge1xuICAgICAgICBjb25zdCBwb2ludGVyID0gY2hhbmdlZFRvdWNoO1xuICAgICAgICBjb25zdCBwb2ludGVySWQgPSBnZXRQb2ludGVySWQocG9pbnRlcik7XG4gICAgICAgIGNvbnN0IHNlYXJjaERldGFpbHMgPSB7XG4gICAgICAgICAgcG9pbnRlcixcbiAgICAgICAgICBwb2ludGVySWQsXG4gICAgICAgICAgcG9pbnRlclR5cGUsXG4gICAgICAgICAgZXZlbnRUeXBlOiBldmVudC50eXBlLFxuICAgICAgICAgIGV2ZW50VGFyZ2V0LFxuICAgICAgICAgIGN1ckV2ZW50VGFyZ2V0LFxuICAgICAgICAgIHNjb3BlXG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IGludGVyYWN0aW9uID0gZ2V0SW50ZXJhY3Rpb24oc2VhcmNoRGV0YWlscyk7XG4gICAgICAgIG1hdGNoZXMucHVzaChbc2VhcmNoRGV0YWlscy5wb2ludGVyLCBzZWFyY2hEZXRhaWxzLmV2ZW50VGFyZ2V0LCBzZWFyY2hEZXRhaWxzLmN1ckV2ZW50VGFyZ2V0LCBpbnRlcmFjdGlvbl0pO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBsZXQgaW52YWxpZFBvaW50ZXIgPSBmYWxzZTtcblxuICAgICAgaWYgKCF1dGlsc19icm93c2VyLnN1cHBvcnRzUG9pbnRlckV2ZW50ICYmIC9tb3VzZS8udGVzdChldmVudC50eXBlKSkge1xuICAgICAgICAvLyBpZ25vcmUgbW91c2UgZXZlbnRzIHdoaWxlIHRvdWNoIGludGVyYWN0aW9ucyBhcmUgYWN0aXZlXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgaW50ZXJhY3Rpb25zLmxlbmd0aCAmJiAhaW52YWxpZFBvaW50ZXI7IGkrKykge1xuICAgICAgICAgIGludmFsaWRQb2ludGVyID0gaW50ZXJhY3Rpb25zW2ldLnBvaW50ZXJUeXBlICE9PSAnbW91c2UnICYmIGludGVyYWN0aW9uc1tpXS5wb2ludGVySXNEb3duO1xuICAgICAgICB9IC8vIHRyeSB0byBpZ25vcmUgbW91c2UgZXZlbnRzIHRoYXQgYXJlIHNpbXVsYXRlZCBieSB0aGUgYnJvd3NlclxuICAgICAgICAvLyBhZnRlciBhIHRvdWNoIGV2ZW50XG5cblxuICAgICAgICBpbnZhbGlkUG9pbnRlciA9IGludmFsaWRQb2ludGVyIHx8IHNjb3BlLm5vdygpIC0gc2NvcGUucHJldlRvdWNoVGltZSA8IDUwMCB8fCAvLyBvbiBpT1MgYW5kIEZpcmVmb3ggTW9iaWxlLCBNb3VzZUV2ZW50LnRpbWVTdGFtcCBpcyB6ZXJvIGlmIHNpbXVsYXRlZFxuICAgICAgICBldmVudC50aW1lU3RhbXAgPT09IDA7XG4gICAgICB9XG5cbiAgICAgIGlmICghaW52YWxpZFBvaW50ZXIpIHtcbiAgICAgICAgY29uc3Qgc2VhcmNoRGV0YWlscyA9IHtcbiAgICAgICAgICBwb2ludGVyOiBldmVudCxcbiAgICAgICAgICBwb2ludGVySWQ6IGdldFBvaW50ZXJJZChldmVudCksXG4gICAgICAgICAgcG9pbnRlclR5cGUsXG4gICAgICAgICAgZXZlbnRUeXBlOiBldmVudC50eXBlLFxuICAgICAgICAgIGN1ckV2ZW50VGFyZ2V0LFxuICAgICAgICAgIGV2ZW50VGFyZ2V0LFxuICAgICAgICAgIHNjb3BlXG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IGludGVyYWN0aW9uID0gZ2V0SW50ZXJhY3Rpb24oc2VhcmNoRGV0YWlscyk7XG4gICAgICAgIG1hdGNoZXMucHVzaChbc2VhcmNoRGV0YWlscy5wb2ludGVyLCBzZWFyY2hEZXRhaWxzLmV2ZW50VGFyZ2V0LCBzZWFyY2hEZXRhaWxzLmN1ckV2ZW50VGFyZ2V0LCBpbnRlcmFjdGlvbl0pO1xuICAgICAgfVxuICAgIH0gLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXNoYWRvd1xuXG5cbiAgICBmb3IgKGNvbnN0IFtwb2ludGVyLCBldmVudFRhcmdldCwgY3VyRXZlbnRUYXJnZXQsIGludGVyYWN0aW9uXSBvZiBtYXRjaGVzKSB7XG4gICAgICBpbnRlcmFjdGlvblttZXRob2RdKHBvaW50ZXIsIGV2ZW50LCBldmVudFRhcmdldCwgY3VyRXZlbnRUYXJnZXQpO1xuICAgIH1cbiAgfTtcbn1cblxuZnVuY3Rpb24gZ2V0SW50ZXJhY3Rpb24oc2VhcmNoRGV0YWlscykge1xuICBjb25zdCB7XG4gICAgcG9pbnRlclR5cGUsXG4gICAgc2NvcGVcbiAgfSA9IHNlYXJjaERldGFpbHM7XG4gIGNvbnN0IGZvdW5kSW50ZXJhY3Rpb24gPSBpbnRlcmFjdGlvbkZpbmRlci5zZWFyY2goc2VhcmNoRGV0YWlscyk7XG4gIGNvbnN0IHNpZ25hbEFyZyA9IHtcbiAgICBpbnRlcmFjdGlvbjogZm91bmRJbnRlcmFjdGlvbixcbiAgICBzZWFyY2hEZXRhaWxzXG4gIH07XG4gIHNjb3BlLmZpcmUoJ2ludGVyYWN0aW9uczpmaW5kJywgc2lnbmFsQXJnKTtcbiAgcmV0dXJuIHNpZ25hbEFyZy5pbnRlcmFjdGlvbiB8fCBzY29wZS5pbnRlcmFjdGlvbnMubmV3KHtcbiAgICBwb2ludGVyVHlwZVxuICB9KTtcbn1cblxuZnVuY3Rpb24gb25Eb2NTaWduYWwoe1xuICBkb2MsXG4gIHNjb3BlLFxuICBvcHRpb25zXG59LCBldmVudE1ldGhvZE5hbWUpIHtcbiAgY29uc3Qge1xuICAgIGludGVyYWN0aW9uczoge1xuICAgICAgZG9jRXZlbnRzXG4gICAgfSxcbiAgICBldmVudHNcbiAgfSA9IHNjb3BlO1xuICBjb25zdCBldmVudE1ldGhvZCA9IGV2ZW50c1tldmVudE1ldGhvZE5hbWVdO1xuXG4gIGlmIChzY29wZS5icm93c2VyLmlzSU9TICYmICFvcHRpb25zLmV2ZW50cykge1xuICAgIG9wdGlvbnMuZXZlbnRzID0ge1xuICAgICAgcGFzc2l2ZTogZmFsc2VcbiAgICB9O1xuICB9IC8vIGRlbGVnYXRlIGV2ZW50IGxpc3RlbmVyXG5cblxuICBmb3IgKGNvbnN0IGV2ZW50VHlwZSBpbiBldmVudHMuZGVsZWdhdGVkRXZlbnRzKSB7XG4gICAgZXZlbnRNZXRob2QoZG9jLCBldmVudFR5cGUsIGV2ZW50cy5kZWxlZ2F0ZUxpc3RlbmVyKTtcbiAgICBldmVudE1ldGhvZChkb2MsIGV2ZW50VHlwZSwgZXZlbnRzLmRlbGVnYXRlVXNlQ2FwdHVyZSwgdHJ1ZSk7XG4gIH1cblxuICBjb25zdCBldmVudE9wdGlvbnMgPSBvcHRpb25zICYmIG9wdGlvbnMuZXZlbnRzO1xuXG4gIGZvciAoY29uc3Qge1xuICAgIHR5cGUsXG4gICAgbGlzdGVuZXJcbiAgfSBvZiBkb2NFdmVudHMpIHtcbiAgICBldmVudE1ldGhvZChkb2MsIHR5cGUsIGxpc3RlbmVyLCBldmVudE9wdGlvbnMpO1xuICB9XG59XG5cbmNvbnN0IGludGVyYWN0aW9uc19pbnRlcmFjdGlvbnMgPSB7XG4gIGlkOiAnY29yZS9pbnRlcmFjdGlvbnMnLFxuICBpbnN0YWxsOiBpbnRlcmFjdGlvbnNfaW5zdGFsbCxcbiAgbGlzdGVuZXJzOiB7XG4gICAgJ3Njb3BlOmFkZC1kb2N1bWVudCc6IGFyZyA9PiBvbkRvY1NpZ25hbChhcmcsICdhZGQnKSxcbiAgICAnc2NvcGU6cmVtb3ZlLWRvY3VtZW50JzogYXJnID0+IG9uRG9jU2lnbmFsKGFyZywgJ3JlbW92ZScpLFxuICAgICdpbnRlcmFjdGFibGU6dW5zZXQnOiAoe1xuICAgICAgaW50ZXJhY3RhYmxlXG4gICAgfSwgc2NvcGUpID0+IHtcbiAgICAgIC8vIFN0b3AgYW5kIGRlc3Ryb3kgcmVsYXRlZCBpbnRlcmFjdGlvbnMgd2hlbiBhbiBJbnRlcmFjdGFibGUgaXMgdW5zZXRcbiAgICAgIGZvciAobGV0IGkgPSBzY29wZS5pbnRlcmFjdGlvbnMubGlzdC5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICBjb25zdCBpbnRlcmFjdGlvbiA9IHNjb3BlLmludGVyYWN0aW9ucy5saXN0W2ldO1xuXG4gICAgICAgIGlmIChpbnRlcmFjdGlvbi5pbnRlcmFjdGFibGUgIT09IGludGVyYWN0YWJsZSkge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgaW50ZXJhY3Rpb24uc3RvcCgpO1xuICAgICAgICBzY29wZS5maXJlKCdpbnRlcmFjdGlvbnM6ZGVzdHJveScsIHtcbiAgICAgICAgICBpbnRlcmFjdGlvblxuICAgICAgICB9KTtcbiAgICAgICAgaW50ZXJhY3Rpb24uZGVzdHJveSgpO1xuXG4gICAgICAgIGlmIChzY29wZS5pbnRlcmFjdGlvbnMubGlzdC5sZW5ndGggPiAyKSB7XG4gICAgICAgICAgc2NvcGUuaW50ZXJhY3Rpb25zLmxpc3Quc3BsaWNlKGksIDEpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9LFxuICBvbkRvY1NpZ25hbCxcbiAgZG9PbkludGVyYWN0aW9ucyxcbiAgbWV0aG9kTmFtZXNcbn07XG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIHZhciBjb3JlX2ludGVyYWN0aW9ucyA9IChpbnRlcmFjdGlvbnNfaW50ZXJhY3Rpb25zKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWludGVyYWN0aW9ucy5qcy5tYXBcbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vbm9kZV9tb2R1bGVzL0BpbnRlcmFjdGpzL2NvcmUvc2NvcGUuanNcblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5jbGFzcyBzY29wZV9TY29wZSB7XG4gIC8vIG1haW4gd2luZG93XG4gIC8vIG1haW4gZG9jdW1lbnRcbiAgLy8gbWFpbiB3aW5kb3dcbiAgLy8gYWxsIGRvY3VtZW50cyBiZWluZyBsaXN0ZW5lZCB0b1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICB0aGlzLmlkID0gYF9faW50ZXJhY3Rfc2NvcGVfJHtNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiAxMDApfWA7XG4gICAgdGhpcy5pc0luaXRpYWxpemVkID0gZmFsc2U7XG4gICAgdGhpcy5saXN0ZW5lck1hcHMgPSBbXTtcbiAgICB0aGlzLmJyb3dzZXIgPSB1dGlsc19icm93c2VyO1xuICAgIHRoaXMuZGVmYXVsdHMgPSBjbG9uZShkZWZhdWx0T3B0aW9uc19kZWZhdWx0cyk7XG4gICAgdGhpcy5FdmVudGFibGUgPSBFdmVudGFibGVfRXZlbnRhYmxlO1xuICAgIHRoaXMuYWN0aW9ucyA9IHtcbiAgICAgIG1hcDoge30sXG4gICAgICBwaGFzZXM6IHtcbiAgICAgICAgc3RhcnQ6IHRydWUsXG4gICAgICAgIG1vdmU6IHRydWUsXG4gICAgICAgIGVuZDogdHJ1ZVxuICAgICAgfSxcbiAgICAgIG1ldGhvZERpY3Q6IHt9LFxuICAgICAgcGhhc2VsZXNzVHlwZXM6IHt9XG4gICAgfTtcbiAgICB0aGlzLmludGVyYWN0U3RhdGljID0gY3JlYXRlSW50ZXJhY3RTdGF0aWModGhpcyk7XG4gICAgdGhpcy5JbnRlcmFjdEV2ZW50ID0gSW50ZXJhY3RFdmVudF9JbnRlcmFjdEV2ZW50O1xuICAgIHRoaXMuSW50ZXJhY3RhYmxlID0gdm9pZCAwO1xuICAgIHRoaXMuaW50ZXJhY3RhYmxlcyA9IG5ldyBJbnRlcmFjdGFibGVTZXRfSW50ZXJhY3RhYmxlU2V0KHRoaXMpO1xuICAgIHRoaXMuX3dpbiA9IHZvaWQgMDtcbiAgICB0aGlzLmRvY3VtZW50ID0gdm9pZCAwO1xuICAgIHRoaXMud2luZG93ID0gdm9pZCAwO1xuICAgIHRoaXMuZG9jdW1lbnRzID0gW107XG4gICAgdGhpcy5fcGx1Z2lucyA9IHtcbiAgICAgIGxpc3Q6IFtdLFxuICAgICAgbWFwOiB7fVxuICAgIH07XG5cbiAgICB0aGlzLm9uV2luZG93VW5sb2FkID0gZXZlbnQgPT4gdGhpcy5yZW1vdmVEb2N1bWVudChldmVudC50YXJnZXQpO1xuXG4gICAgY29uc3Qgc2NvcGUgPSB0aGlzO1xuICAgIHRoaXMuSW50ZXJhY3RhYmxlID0gY2xhc3MgZXh0ZW5kcyBJbnRlcmFjdGFibGVfSW50ZXJhY3RhYmxlIHtcbiAgICAgIGdldCBfZGVmYXVsdHMoKSB7XG4gICAgICAgIHJldHVybiBzY29wZS5kZWZhdWx0cztcbiAgICAgIH1cblxuICAgICAgc2V0KG9wdGlvbnMpIHtcbiAgICAgICAgc3VwZXIuc2V0KG9wdGlvbnMpO1xuICAgICAgICBzY29wZS5maXJlKCdpbnRlcmFjdGFibGU6c2V0Jywge1xuICAgICAgICAgIG9wdGlvbnMsXG4gICAgICAgICAgaW50ZXJhY3RhYmxlOiB0aGlzXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH1cblxuICAgICAgdW5zZXQoKSB7XG4gICAgICAgIHN1cGVyLnVuc2V0KCk7XG4gICAgICAgIHNjb3BlLmludGVyYWN0YWJsZXMubGlzdC5zcGxpY2Uoc2NvcGUuaW50ZXJhY3RhYmxlcy5saXN0LmluZGV4T2YodGhpcyksIDEpO1xuICAgICAgICBzY29wZS5maXJlKCdpbnRlcmFjdGFibGU6dW5zZXQnLCB7XG4gICAgICAgICAgaW50ZXJhY3RhYmxlOiB0aGlzXG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgfTtcbiAgfVxuXG4gIGFkZExpc3RlbmVycyhtYXAsIGlkKSB7XG4gICAgdGhpcy5saXN0ZW5lck1hcHMucHVzaCh7XG4gICAgICBpZCxcbiAgICAgIG1hcFxuICAgIH0pO1xuICB9XG5cbiAgZmlyZShuYW1lLCBhcmcpIHtcbiAgICBmb3IgKGNvbnN0IHtcbiAgICAgIG1hcDoge1xuICAgICAgICBbbmFtZV06IGxpc3RlbmVyXG4gICAgICB9XG4gICAgfSBvZiB0aGlzLmxpc3RlbmVyTWFwcykge1xuICAgICAgaWYgKCEhbGlzdGVuZXIgJiYgbGlzdGVuZXIoYXJnLCB0aGlzLCBuYW1lKSA9PT0gZmFsc2UpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGluaXQod2luZG93KSB7XG4gICAgcmV0dXJuIHRoaXMuaXNJbml0aWFsaXplZCA/IHRoaXMgOiBpbml0U2NvcGUodGhpcywgd2luZG93KTtcbiAgfVxuXG4gIHBsdWdpbklzSW5zdGFsbGVkKHBsdWdpbikge1xuICAgIHJldHVybiB0aGlzLl9wbHVnaW5zLm1hcFtwbHVnaW4uaWRdIHx8IHRoaXMuX3BsdWdpbnMubGlzdC5pbmRleE9mKHBsdWdpbikgIT09IC0xO1xuICB9XG5cbiAgdXNlUGx1Z2luKHBsdWdpbiwgb3B0aW9ucykge1xuICAgIGlmICghdGhpcy5pc0luaXRpYWxpemVkKSB7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICBpZiAodGhpcy5wbHVnaW5Jc0luc3RhbGxlZChwbHVnaW4pKSB7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICBpZiAocGx1Z2luLmlkKSB7XG4gICAgICB0aGlzLl9wbHVnaW5zLm1hcFtwbHVnaW4uaWRdID0gcGx1Z2luO1xuICAgIH1cblxuICAgIHRoaXMuX3BsdWdpbnMubGlzdC5wdXNoKHBsdWdpbik7XG5cbiAgICBpZiAocGx1Z2luLmluc3RhbGwpIHtcbiAgICAgIHBsdWdpbi5pbnN0YWxsKHRoaXMsIG9wdGlvbnMpO1xuICAgIH1cblxuICAgIGlmIChwbHVnaW4ubGlzdGVuZXJzICYmIHBsdWdpbi5iZWZvcmUpIHtcbiAgICAgIGxldCBpbmRleCA9IDA7XG4gICAgICBjb25zdCBsZW4gPSB0aGlzLmxpc3RlbmVyTWFwcy5sZW5ndGg7XG4gICAgICBjb25zdCBiZWZvcmUgPSBwbHVnaW4uYmVmb3JlLnJlZHVjZSgoYWNjLCBpZCkgPT4ge1xuICAgICAgICBhY2NbaWRdID0gdHJ1ZTtcbiAgICAgICAgYWNjW3BsdWdpbklkUm9vdChpZCldID0gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIGFjYztcbiAgICAgIH0sIHt9KTtcblxuICAgICAgZm9yICg7IGluZGV4IDwgbGVuOyBpbmRleCsrKSB7XG4gICAgICAgIGNvbnN0IG90aGVySWQgPSB0aGlzLmxpc3RlbmVyTWFwc1tpbmRleF0uaWQ7XG5cbiAgICAgICAgaWYgKGJlZm9yZVtvdGhlcklkXSB8fCBiZWZvcmVbcGx1Z2luSWRSb290KG90aGVySWQpXSkge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHRoaXMubGlzdGVuZXJNYXBzLnNwbGljZShpbmRleCwgMCwge1xuICAgICAgICBpZDogcGx1Z2luLmlkLFxuICAgICAgICBtYXA6IHBsdWdpbi5saXN0ZW5lcnNcbiAgICAgIH0pO1xuICAgIH0gZWxzZSBpZiAocGx1Z2luLmxpc3RlbmVycykge1xuICAgICAgdGhpcy5saXN0ZW5lck1hcHMucHVzaCh7XG4gICAgICAgIGlkOiBwbHVnaW4uaWQsXG4gICAgICAgIG1hcDogcGx1Z2luLmxpc3RlbmVyc1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICBhZGREb2N1bWVudChkb2MsIG9wdGlvbnMpIHtcbiAgICAvLyBkbyBub3RoaW5nIGlmIGRvY3VtZW50IGlzIGFscmVhZHkga25vd25cbiAgICBpZiAodGhpcy5nZXREb2NJbmRleChkb2MpICE9PSAtMSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGNvbnN0IHdpbmRvdyA9IGdldFdpbmRvdyhkb2MpO1xuICAgIG9wdGlvbnMgPSBvcHRpb25zID8gZXh0ZW5kKHt9LCBvcHRpb25zKSA6IHt9O1xuICAgIHRoaXMuZG9jdW1lbnRzLnB1c2goe1xuICAgICAgZG9jLFxuICAgICAgb3B0aW9uc1xuICAgIH0pO1xuICAgIHRoaXMuZXZlbnRzLmRvY3VtZW50cy5wdXNoKGRvYyk7IC8vIGRvbid0IGFkZCBhbiB1bmxvYWQgZXZlbnQgZm9yIHRoZSBtYWluIGRvY3VtZW50XG4gICAgLy8gc28gdGhhdCB0aGUgcGFnZSBtYXkgYmUgY2FjaGVkIGluIGJyb3dzZXIgaGlzdG9yeVxuXG4gICAgaWYgKGRvYyAhPT0gdGhpcy5kb2N1bWVudCkge1xuICAgICAgdGhpcy5ldmVudHMuYWRkKHdpbmRvdywgJ3VubG9hZCcsIHRoaXMub25XaW5kb3dVbmxvYWQpO1xuICAgIH1cblxuICAgIHRoaXMuZmlyZSgnc2NvcGU6YWRkLWRvY3VtZW50Jywge1xuICAgICAgZG9jLFxuICAgICAgd2luZG93LFxuICAgICAgc2NvcGU6IHRoaXMsXG4gICAgICBvcHRpb25zXG4gICAgfSk7XG4gIH1cblxuICByZW1vdmVEb2N1bWVudChkb2MpIHtcbiAgICBjb25zdCBpbmRleCA9IHRoaXMuZ2V0RG9jSW5kZXgoZG9jKTtcbiAgICBjb25zdCB3aW5kb3cgPSBnZXRXaW5kb3coZG9jKTtcbiAgICBjb25zdCBvcHRpb25zID0gdGhpcy5kb2N1bWVudHNbaW5kZXhdLm9wdGlvbnM7XG4gICAgdGhpcy5ldmVudHMucmVtb3ZlKHdpbmRvdywgJ3VubG9hZCcsIHRoaXMub25XaW5kb3dVbmxvYWQpO1xuICAgIHRoaXMuZG9jdW1lbnRzLnNwbGljZShpbmRleCwgMSk7XG4gICAgdGhpcy5ldmVudHMuZG9jdW1lbnRzLnNwbGljZShpbmRleCwgMSk7XG4gICAgdGhpcy5maXJlKCdzY29wZTpyZW1vdmUtZG9jdW1lbnQnLCB7XG4gICAgICBkb2MsXG4gICAgICB3aW5kb3csXG4gICAgICBzY29wZTogdGhpcyxcbiAgICAgIG9wdGlvbnNcbiAgICB9KTtcbiAgfVxuXG4gIGdldERvY0luZGV4KGRvYykge1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5kb2N1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmICh0aGlzLmRvY3VtZW50c1tpXS5kb2MgPT09IGRvYykge1xuICAgICAgICByZXR1cm4gaTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gLTE7XG4gIH1cblxuICBnZXREb2NPcHRpb25zKGRvYykge1xuICAgIGNvbnN0IGRvY0luZGV4ID0gdGhpcy5nZXREb2NJbmRleChkb2MpO1xuICAgIHJldHVybiBkb2NJbmRleCA9PT0gLTEgPyBudWxsIDogdGhpcy5kb2N1bWVudHNbZG9jSW5kZXhdLm9wdGlvbnM7XG4gIH1cblxuICBub3coKSB7XG4gICAgcmV0dXJuICh0aGlzLndpbmRvdy5EYXRlIHx8IERhdGUpLm5vdygpO1xuICB9XG5cbn1cbmZ1bmN0aW9uIGluaXRTY29wZShzY29wZSwgd2luZG93KSB7XG4gIHNjb3BlLmlzSW5pdGlhbGl6ZWQgPSB0cnVlO1xuICB3aW5kb3dfaW5pdCh3aW5kb3cpO1xuICB1dGlsc19kb21PYmplY3RzLmluaXQod2luZG93KTtcbiAgdXRpbHNfYnJvd3Nlci5pbml0KHdpbmRvdyk7XG4gIHJhZi5pbml0KHdpbmRvdyk7XG4gIHNjb3BlLndpbmRvdyA9IHdpbmRvdztcbiAgc2NvcGUuZG9jdW1lbnQgPSB3aW5kb3cuZG9jdW1lbnQ7XG4gIHNjb3BlLnVzZVBsdWdpbihjb3JlX2ludGVyYWN0aW9ucyk7XG4gIHNjb3BlLnVzZVBsdWdpbihldmVudHMpO1xuICByZXR1cm4gc2NvcGU7XG59XG5cbmZ1bmN0aW9uIHBsdWdpbklkUm9vdChpZCkge1xuICByZXR1cm4gaWQgJiYgaWQucmVwbGFjZSgvXFwvLiokLywgJycpO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c2NvcGUuanMubWFwXG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL25vZGVfbW9kdWxlcy9AaW50ZXJhY3Rqcy9pbnRlcmFjdC9pbmRleC5qc1xuXG5jb25zdCBpbnRlcmFjdF9zY29wZSA9IG5ldyBzY29wZV9TY29wZSgpO1xuY29uc3QgaW50ZXJhY3RfaW50ZXJhY3QgPSBpbnRlcmFjdF9zY29wZS5pbnRlcmFjdFN0YXRpYztcbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gdmFyIF9pbnRlcmFjdGpzX2ludGVyYWN0ID0gKGludGVyYWN0X2ludGVyYWN0KTtcbmNvbnN0IGludGVyYWN0X2luaXQgPSB3aW4gPT4gaW50ZXJhY3Rfc2NvcGUuaW5pdCh3aW4pO1xuXG5pZiAodHlwZW9mIHdpbmRvdyA9PT0gJ29iamVjdCcgJiYgISF3aW5kb3cpIHtcbiAgaW50ZXJhY3RfaW5pdCh3aW5kb3cpO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwXG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL25vZGVfbW9kdWxlcy9AaW50ZXJhY3Rqcy9hdXRvLXN0YXJ0L0ludGVyYWN0YWJsZU1ldGhvZHMuanNcblxuXG5cblxuZnVuY3Rpb24gSW50ZXJhY3RhYmxlTWV0aG9kc19pbnN0YWxsKHNjb3BlKSB7XG4gIGNvbnN0IHtcbiAgICAvKiogQGxlbmRzIEludGVyYWN0YWJsZSAqL1xuICAgIEludGVyYWN0YWJsZSAvLyB0c2xpbnQ6ZGlzYWJsZS1saW5lIG5vLXNoYWRvd2VkLXZhcmlhYmxlXG5cbiAgfSA9IHNjb3BlO1xuXG4gIEludGVyYWN0YWJsZS5wcm90b3R5cGUuZ2V0QWN0aW9uID0gZnVuY3Rpb24gZ2V0QWN0aW9uKHBvaW50ZXIsIGV2ZW50LCBpbnRlcmFjdGlvbiwgZWxlbWVudCkge1xuICAgIGNvbnN0IGFjdGlvbiA9IGRlZmF1bHRBY3Rpb25DaGVja2VyKHRoaXMsIGV2ZW50LCBpbnRlcmFjdGlvbiwgZWxlbWVudCwgc2NvcGUpO1xuXG4gICAgaWYgKHRoaXMub3B0aW9ucy5hY3Rpb25DaGVja2VyKSB7XG4gICAgICByZXR1cm4gdGhpcy5vcHRpb25zLmFjdGlvbkNoZWNrZXIocG9pbnRlciwgZXZlbnQsIGFjdGlvbiwgdGhpcywgZWxlbWVudCwgaW50ZXJhY3Rpb24pO1xuICAgIH1cblxuICAgIHJldHVybiBhY3Rpb247XG4gIH07XG4gIC8qKlxuICAgKiBJZiB0aGUgdGFyZ2V0IG9mIHRoZSBgbW91c2Vkb3duYCwgYHBvaW50ZXJkb3duYCBvciBgdG91Y2hzdGFydGAgZXZlbnQgb3IgYW55XG4gICAqIG9mIGl0J3MgcGFyZW50cyBtYXRjaCB0aGUgZ2l2ZW4gQ1NTIHNlbGVjdG9yIG9yIEVsZW1lbnQsIG5vXG4gICAqIGRyYWcvcmVzaXplL2dlc3R1cmUgaXMgc3RhcnRlZC5cbiAgICpcbiAgICogQGRlcHJlY2F0ZWRcbiAgICogRG9uJ3QgdXNlIHRoaXMgbWV0aG9kLiBJbnN0ZWFkIHNldCB0aGUgYGlnbm9yZUZyb21gIG9wdGlvbiBmb3IgZWFjaCBhY3Rpb25cbiAgICogb3IgZm9yIGBwb2ludGVyRXZlbnRzYFxuICAgKlxuICAgKiBgYGBqc1xuICAgKiBpbnRlcmFjdCh0YXJnZXR0KVxuICAgKiAgIC5kcmFnZ2FibGUoe1xuICAgKiAgICAgaWdub3JlRnJvbTogJ2lucHV0LCB0ZXh0YXJlYSwgYVtocmVmXScnLFxuICAgKiAgIH0pXG4gICAqICAgLnBvaW50ZXJFdmVudHMoe1xuICAgKiAgICAgaWdub3JlRnJvbTogJ1tuby1wb2ludGVyXScsXG4gICAqICAgfSlcbiAgICogYGBgXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nIHwgRWxlbWVudCB8IG51bGx9IFtuZXdWYWx1ZV0gYSBDU1Mgc2VsZWN0b3Igc3RyaW5nLCBhblxuICAgKiBFbGVtZW50IG9yIGBudWxsYCB0byBub3QgaWdub3JlIGFueSBlbGVtZW50c1xuICAgKiBAcmV0dXJuIHtzdHJpbmcgfCBFbGVtZW50IHwgb2JqZWN0fSBUaGUgY3VycmVudCBpZ25vcmVGcm9tIHZhbHVlIG9yIHRoaXNcbiAgICogSW50ZXJhY3RhYmxlXG4gICAqL1xuXG5cbiAgSW50ZXJhY3RhYmxlLnByb3RvdHlwZS5pZ25vcmVGcm9tID0gd2Fybk9uY2UoZnVuY3Rpb24gKG5ld1ZhbHVlKSB7XG4gICAgcmV0dXJuIHRoaXMuX2JhY2tDb21wYXRPcHRpb24oJ2lnbm9yZUZyb20nLCBuZXdWYWx1ZSk7XG4gIH0sICdJbnRlcmFjdGFibGUuaWdub3JlRnJvbSgpIGhhcyBiZWVuIGRlcHJlY2F0ZWQuIFVzZSBJbnRlcmFjdGJsZS5kcmFnZ2FibGUoe2lnbm9yZUZyb206IG5ld1ZhbHVlfSkuJyk7XG4gIC8qKlxuICAgKlxuICAgKiBBIGRyYWcvcmVzaXplL2dlc3R1cmUgaXMgc3RhcnRlZCBvbmx5IElmIHRoZSB0YXJnZXQgb2YgdGhlIGBtb3VzZWRvd25gLFxuICAgKiBgcG9pbnRlcmRvd25gIG9yIGB0b3VjaHN0YXJ0YCBldmVudCBvciBhbnkgb2YgaXQncyBwYXJlbnRzIG1hdGNoIHRoZSBnaXZlblxuICAgKiBDU1Mgc2VsZWN0b3Igb3IgRWxlbWVudC5cbiAgICpcbiAgICogQGRlcHJlY2F0ZWRcbiAgICogRG9uJ3QgdXNlIHRoaXMgbWV0aG9kLiBJbnN0ZWFkIHNldCB0aGUgYGFsbG93RnJvbWAgb3B0aW9uIGZvciBlYWNoIGFjdGlvblxuICAgKiBvciBmb3IgYHBvaW50ZXJFdmVudHNgXG4gICAqXG4gICAqIGBgYGpzXG4gICAqIGludGVyYWN0KHRhcmdldHQpXG4gICAqICAgLnJlc2l6YWJsZSh7XG4gICAqICAgICBhbGxvd0Zyb206ICcucmVzaXplLWhhbmRsZScsXG4gICAqICAgLnBvaW50ZXJFdmVudHMoe1xuICAgKiAgICAgYWxsb3dGcm9tOiAnLmhhbmRsZScsLFxuICAgKiAgIH0pXG4gICAqIGBgYFxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZyB8IEVsZW1lbnQgfCBudWxsfSBbbmV3VmFsdWVdIGEgQ1NTIHNlbGVjdG9yIHN0cmluZywgYW5cbiAgICogRWxlbWVudCBvciBgbnVsbGAgdG8gYWxsb3cgZnJvbSBhbnkgZWxlbWVudFxuICAgKiBAcmV0dXJuIHtzdHJpbmcgfCBFbGVtZW50IHwgb2JqZWN0fSBUaGUgY3VycmVudCBhbGxvd0Zyb20gdmFsdWUgb3IgdGhpc1xuICAgKiBJbnRlcmFjdGFibGVcbiAgICovXG5cbiAgSW50ZXJhY3RhYmxlLnByb3RvdHlwZS5hbGxvd0Zyb20gPSB3YXJuT25jZShmdW5jdGlvbiAobmV3VmFsdWUpIHtcbiAgICByZXR1cm4gdGhpcy5fYmFja0NvbXBhdE9wdGlvbignYWxsb3dGcm9tJywgbmV3VmFsdWUpO1xuICB9LCAnSW50ZXJhY3RhYmxlLmFsbG93RnJvbSgpIGhhcyBiZWVuIGRlcHJlY2F0ZWQuIFVzZSBJbnRlcmFjdGJsZS5kcmFnZ2FibGUoe2FsbG93RnJvbTogbmV3VmFsdWV9KS4nKTtcbiAgLyoqXG4gICAqIGBgYGpzXG4gICAqIGludGVyYWN0KCcucmVzaXplLWRyYWcnKVxuICAgKiAgIC5yZXNpemFibGUodHJ1ZSlcbiAgICogICAuZHJhZ2dhYmxlKHRydWUpXG4gICAqICAgLmFjdGlvbkNoZWNrZXIoZnVuY3Rpb24gKHBvaW50ZXIsIGV2ZW50LCBhY3Rpb24sIGludGVyYWN0YWJsZSwgZWxlbWVudCwgaW50ZXJhY3Rpb24pIHtcbiAgICpcbiAgICogICAgIGlmIChpbnRlcmFjdC5tYXRjaGVzU2VsZWN0b3IoZXZlbnQudGFyZ2V0LCAnLmRyYWctaGFuZGxlJykpIHtcbiAgICogICAgICAgLy8gZm9yY2UgZHJhZyB3aXRoIGhhbmRsZSB0YXJnZXRcbiAgICogICAgICAgYWN0aW9uLm5hbWUgPSBkcmFnXG4gICAqICAgICB9XG4gICAqICAgICBlbHNlIHtcbiAgICogICAgICAgLy8gcmVzaXplIGZyb20gdGhlIHRvcCBhbmQgcmlnaHQgZWRnZXNcbiAgICogICAgICAgYWN0aW9uLm5hbWUgID0gJ3Jlc2l6ZSdcbiAgICogICAgICAgYWN0aW9uLmVkZ2VzID0geyB0b3A6IHRydWUsIHJpZ2h0OiB0cnVlIH1cbiAgICogICAgIH1cbiAgICpcbiAgICogICAgIHJldHVybiBhY3Rpb25cbiAgICogfSlcbiAgICogYGBgXG4gICAqXG4gICAqIFJldHVybnMgb3Igc2V0cyB0aGUgZnVuY3Rpb24gdXNlZCB0byBjaGVjayBhY3Rpb24gdG8gYmUgcGVyZm9ybWVkIG9uXG4gICAqIHBvaW50ZXJEb3duXG4gICAqXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb24gfCBudWxsfSBbY2hlY2tlcl0gQSBmdW5jdGlvbiB3aGljaCB0YWtlcyBhIHBvaW50ZXIgZXZlbnQsXG4gICAqIGRlZmF1bHRBY3Rpb24gc3RyaW5nLCBpbnRlcmFjdGFibGUsIGVsZW1lbnQgYW5kIGludGVyYWN0aW9uIGFzIHBhcmFtZXRlcnNcbiAgICogYW5kIHJldHVybnMgYW4gb2JqZWN0IHdpdGggbmFtZSBwcm9wZXJ0eSAnZHJhZycgJ3Jlc2l6ZScgb3IgJ2dlc3R1cmUnIGFuZFxuICAgKiBvcHRpb25hbGx5IGFuIGBlZGdlc2Agb2JqZWN0IHdpdGggYm9vbGVhbiAndG9wJywgJ2xlZnQnLCAnYm90dG9tJyBhbmQgcmlnaHRcbiAgICogcHJvcHMuXG4gICAqIEByZXR1cm4ge0Z1bmN0aW9uIHwgSW50ZXJhY3RhYmxlfSBUaGUgY2hlY2tlciBmdW5jdGlvbiBvciB0aGlzIEludGVyYWN0YWJsZVxuICAgKi9cblxuICBJbnRlcmFjdGFibGUucHJvdG90eXBlLmFjdGlvbkNoZWNrZXIgPSBhY3Rpb25DaGVja2VyO1xuICAvKipcbiAgICogUmV0dXJucyBvciBzZXRzIHdoZXRoZXIgdGhlIHRoZSBjdXJzb3Igc2hvdWxkIGJlIGNoYW5nZWQgZGVwZW5kaW5nIG9uIHRoZVxuICAgKiBhY3Rpb24gdGhhdCB3b3VsZCBiZSBwZXJmb3JtZWQgaWYgdGhlIG1vdXNlIHdlcmUgcHJlc3NlZCBhbmQgZHJhZ2dlZC5cbiAgICpcbiAgICogQHBhcmFtIHtib29sZWFufSBbbmV3VmFsdWVdXG4gICAqIEByZXR1cm4ge2Jvb2xlYW4gfCBJbnRlcmFjdGFibGV9IFRoZSBjdXJyZW50IHNldHRpbmcgb3IgdGhpcyBJbnRlcmFjdGFibGVcbiAgICovXG5cbiAgSW50ZXJhY3RhYmxlLnByb3RvdHlwZS5zdHlsZUN1cnNvciA9IHN0eWxlQ3Vyc29yO1xufVxuXG5mdW5jdGlvbiBkZWZhdWx0QWN0aW9uQ2hlY2tlcihpbnRlcmFjdGFibGUsIGV2ZW50LCBpbnRlcmFjdGlvbiwgZWxlbWVudCwgc2NvcGUpIHtcbiAgY29uc3QgcmVjdCA9IGludGVyYWN0YWJsZS5nZXRSZWN0KGVsZW1lbnQpO1xuICBjb25zdCBidXR0b25zID0gZXZlbnQuYnV0dG9ucyB8fCB7XG4gICAgMDogMSxcbiAgICAxOiA0LFxuICAgIDM6IDgsXG4gICAgNDogMTZcbiAgfVtldmVudC5idXR0b25dO1xuICBjb25zdCBhcmcgPSB7XG4gICAgYWN0aW9uOiBudWxsLFxuICAgIGludGVyYWN0YWJsZSxcbiAgICBpbnRlcmFjdGlvbixcbiAgICBlbGVtZW50LFxuICAgIHJlY3QsXG4gICAgYnV0dG9uc1xuICB9O1xuICBzY29wZS5maXJlKCdhdXRvLXN0YXJ0OmNoZWNrJywgYXJnKTtcbiAgcmV0dXJuIGFyZy5hY3Rpb247XG59XG5cbmZ1bmN0aW9uIHN0eWxlQ3Vyc29yKG5ld1ZhbHVlKSB7XG4gIGlmIChpcy5ib29sKG5ld1ZhbHVlKSkge1xuICAgIHRoaXMub3B0aW9ucy5zdHlsZUN1cnNvciA9IG5ld1ZhbHVlO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgaWYgKG5ld1ZhbHVlID09PSBudWxsKSB7XG4gICAgZGVsZXRlIHRoaXMub3B0aW9ucy5zdHlsZUN1cnNvcjtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIHJldHVybiB0aGlzLm9wdGlvbnMuc3R5bGVDdXJzb3I7XG59XG5cbmZ1bmN0aW9uIGFjdGlvbkNoZWNrZXIoY2hlY2tlcikge1xuICBpZiAoaXMuZnVuYyhjaGVja2VyKSkge1xuICAgIHRoaXMub3B0aW9ucy5hY3Rpb25DaGVja2VyID0gY2hlY2tlcjtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIGlmIChjaGVja2VyID09PSBudWxsKSB7XG4gICAgZGVsZXRlIHRoaXMub3B0aW9ucy5hY3Rpb25DaGVja2VyO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgcmV0dXJuIHRoaXMub3B0aW9ucy5hY3Rpb25DaGVja2VyO1xufVxuXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIHZhciBJbnRlcmFjdGFibGVNZXRob2RzID0gKHtcbiAgaWQ6ICdhdXRvLXN0YXJ0L2ludGVyYWN0YWJsZU1ldGhvZHMnLFxuICBpbnN0YWxsOiBJbnRlcmFjdGFibGVNZXRob2RzX2luc3RhbGxcbn0pO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9SW50ZXJhY3RhYmxlTWV0aG9kcy5qcy5tYXBcbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vbm9kZV9tb2R1bGVzL0BpbnRlcmFjdGpzL2F1dG8tc3RhcnQvYmFzZS5qc1xuXG5cblxuXG5cblxuXG5mdW5jdGlvbiBiYXNlX2luc3RhbGwoc2NvcGUpIHtcbiAgY29uc3Qge1xuICAgIGludGVyYWN0U3RhdGljOiBpbnRlcmFjdCxcbiAgICBkZWZhdWx0c1xuICB9ID0gc2NvcGU7XG4gIHNjb3BlLnVzZVBsdWdpbihJbnRlcmFjdGFibGVNZXRob2RzKTtcbiAgZGVmYXVsdHMuYmFzZS5hY3Rpb25DaGVja2VyID0gbnVsbDtcbiAgZGVmYXVsdHMuYmFzZS5zdHlsZUN1cnNvciA9IHRydWU7XG4gIGV4dGVuZChkZWZhdWx0cy5wZXJBY3Rpb24sIHtcbiAgICBtYW51YWxTdGFydDogZmFsc2UsXG4gICAgbWF4OiBJbmZpbml0eSxcbiAgICBtYXhQZXJFbGVtZW50OiAxLFxuICAgIGFsbG93RnJvbTogbnVsbCxcbiAgICBpZ25vcmVGcm9tOiBudWxsLFxuICAgIC8vIG9ubHkgYWxsb3cgbGVmdCBidXR0b24gYnkgZGVmYXVsdFxuICAgIC8vIHNlZSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvTW91c2VFdmVudC9idXR0b25zI1JldHVybl92YWx1ZVxuICAgIG1vdXNlQnV0dG9uczogMVxuICB9KTtcbiAgLyoqXG4gICAqIFJldHVybnMgb3Igc2V0cyB0aGUgbWF4aW11bSBudW1iZXIgb2YgY29uY3VycmVudCBpbnRlcmFjdGlvbnMgYWxsb3dlZC4gIEJ5XG4gICAqIGRlZmF1bHQgb25seSAxIGludGVyYWN0aW9uIGlzIGFsbG93ZWQgYXQgYSB0aW1lIChmb3IgYmFja3dhcmRzXG4gICAqIGNvbXBhdGliaWxpdHkpLiBUbyBhbGxvdyBtdWx0aXBsZSBpbnRlcmFjdGlvbnMgb24gdGhlIHNhbWUgSW50ZXJhY3RhYmxlcyBhbmRcbiAgICogZWxlbWVudHMsIHlvdSBuZWVkIHRvIGVuYWJsZSBpdCBpbiB0aGUgZHJhZ2dhYmxlLCByZXNpemFibGUgYW5kIGdlc3R1cmFibGVcbiAgICogYCdtYXgnYCBhbmQgYCdtYXhQZXJFbGVtZW50J2Agb3B0aW9ucy5cbiAgICpcbiAgICogQGFsaWFzIG1vZHVsZTppbnRlcmFjdC5tYXhJbnRlcmFjdGlvbnNcbiAgICpcbiAgICogQHBhcmFtIHtudW1iZXJ9IFtuZXdWYWx1ZV0gQW55IG51bWJlci4gbmV3VmFsdWUgPD0gMCBtZWFucyBubyBpbnRlcmFjdGlvbnMuXG4gICAqL1xuXG4gIGludGVyYWN0Lm1heEludGVyYWN0aW9ucyA9IG5ld1ZhbHVlID0+IG1heEludGVyYWN0aW9ucyhuZXdWYWx1ZSwgc2NvcGUpO1xuXG4gIHNjb3BlLmF1dG9TdGFydCA9IHtcbiAgICAvLyBBbGxvdyB0aGlzIG1hbnkgaW50ZXJhY3Rpb25zIHRvIGhhcHBlbiBzaW11bHRhbmVvdXNseVxuICAgIG1heEludGVyYWN0aW9uczogSW5maW5pdHksXG4gICAgd2l0aGluSW50ZXJhY3Rpb25MaW1pdCxcbiAgICBjdXJzb3JFbGVtZW50OiBudWxsXG4gIH07XG59XG5cbmZ1bmN0aW9uIHByZXBhcmVPbkRvd24oe1xuICBpbnRlcmFjdGlvbixcbiAgcG9pbnRlcixcbiAgZXZlbnQsXG4gIGV2ZW50VGFyZ2V0XG59LCBzY29wZSkge1xuICBpZiAoaW50ZXJhY3Rpb24uaW50ZXJhY3RpbmcoKSkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGNvbnN0IGFjdGlvbkluZm8gPSBnZXRBY3Rpb25JbmZvKGludGVyYWN0aW9uLCBwb2ludGVyLCBldmVudCwgZXZlbnRUYXJnZXQsIHNjb3BlKTtcbiAgcHJlcGFyZShpbnRlcmFjdGlvbiwgYWN0aW9uSW5mbywgc2NvcGUpO1xufVxuXG5mdW5jdGlvbiBwcmVwYXJlT25Nb3ZlKHtcbiAgaW50ZXJhY3Rpb24sXG4gIHBvaW50ZXIsXG4gIGV2ZW50LFxuICBldmVudFRhcmdldFxufSwgc2NvcGUpIHtcbiAgaWYgKGludGVyYWN0aW9uLnBvaW50ZXJUeXBlICE9PSAnbW91c2UnIHx8IGludGVyYWN0aW9uLnBvaW50ZXJJc0Rvd24gfHwgaW50ZXJhY3Rpb24uaW50ZXJhY3RpbmcoKSkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGNvbnN0IGFjdGlvbkluZm8gPSBnZXRBY3Rpb25JbmZvKGludGVyYWN0aW9uLCBwb2ludGVyLCBldmVudCwgZXZlbnRUYXJnZXQsIHNjb3BlKTtcbiAgcHJlcGFyZShpbnRlcmFjdGlvbiwgYWN0aW9uSW5mbywgc2NvcGUpO1xufVxuXG5mdW5jdGlvbiBzdGFydE9uTW92ZShhcmcsIHNjb3BlKSB7XG4gIGNvbnN0IHtcbiAgICBpbnRlcmFjdGlvblxuICB9ID0gYXJnO1xuXG4gIGlmICghaW50ZXJhY3Rpb24ucG9pbnRlcklzRG93biB8fCBpbnRlcmFjdGlvbi5pbnRlcmFjdGluZygpIHx8ICFpbnRlcmFjdGlvbi5wb2ludGVyV2FzTW92ZWQgfHwgIWludGVyYWN0aW9uLnByZXBhcmVkLm5hbWUpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBzY29wZS5maXJlKCdhdXRvU3RhcnQ6YmVmb3JlLXN0YXJ0JywgYXJnKTtcbiAgY29uc3Qge1xuICAgIGludGVyYWN0YWJsZVxuICB9ID0gaW50ZXJhY3Rpb247XG4gIGNvbnN0IGFjdGlvbk5hbWUgPSBpbnRlcmFjdGlvbi5wcmVwYXJlZC5uYW1lO1xuXG4gIGlmIChhY3Rpb25OYW1lICYmIGludGVyYWN0YWJsZSkge1xuICAgIC8vIGNoZWNrIG1hbnVhbFN0YXJ0IGFuZCBpbnRlcmFjdGlvbiBsaW1pdFxuICAgIGlmIChpbnRlcmFjdGFibGUub3B0aW9uc1thY3Rpb25OYW1lXS5tYW51YWxTdGFydCB8fCAhd2l0aGluSW50ZXJhY3Rpb25MaW1pdChpbnRlcmFjdGFibGUsIGludGVyYWN0aW9uLmVsZW1lbnQsIGludGVyYWN0aW9uLnByZXBhcmVkLCBzY29wZSkpIHtcbiAgICAgIGludGVyYWN0aW9uLnN0b3AoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgaW50ZXJhY3Rpb24uc3RhcnQoaW50ZXJhY3Rpb24ucHJlcGFyZWQsIGludGVyYWN0YWJsZSwgaW50ZXJhY3Rpb24uZWxlbWVudCk7XG4gICAgICBzZXRJbnRlcmFjdGlvbkN1cnNvcihpbnRlcmFjdGlvbiwgc2NvcGUpO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBjbGVhckN1cnNvck9uU3RvcCh7XG4gIGludGVyYWN0aW9uXG59LCBzY29wZSkge1xuICBjb25zdCB7XG4gICAgaW50ZXJhY3RhYmxlXG4gIH0gPSBpbnRlcmFjdGlvbjtcblxuICBpZiAoaW50ZXJhY3RhYmxlICYmIGludGVyYWN0YWJsZS5vcHRpb25zLnN0eWxlQ3Vyc29yKSB7XG4gICAgc2V0Q3Vyc29yKGludGVyYWN0aW9uLmVsZW1lbnQsICcnLCBzY29wZSk7XG4gIH1cbn0gLy8gQ2hlY2sgaWYgdGhlIGN1cnJlbnQgaW50ZXJhY3RhYmxlIHN1cHBvcnRzIHRoZSBhY3Rpb24uXG4vLyBJZiBzbywgcmV0dXJuIHRoZSB2YWxpZGF0ZWQgYWN0aW9uLiBPdGhlcndpc2UsIHJldHVybiBudWxsXG5cblxuZnVuY3Rpb24gdmFsaWRhdGVBY3Rpb24oYWN0aW9uLCBpbnRlcmFjdGFibGUsIGVsZW1lbnQsIGV2ZW50VGFyZ2V0LCBzY29wZSkge1xuICBpZiAoaW50ZXJhY3RhYmxlLnRlc3RJZ25vcmVBbGxvdyhpbnRlcmFjdGFibGUub3B0aW9uc1thY3Rpb24ubmFtZV0sIGVsZW1lbnQsIGV2ZW50VGFyZ2V0KSAmJiBpbnRlcmFjdGFibGUub3B0aW9uc1thY3Rpb24ubmFtZV0uZW5hYmxlZCAmJiB3aXRoaW5JbnRlcmFjdGlvbkxpbWl0KGludGVyYWN0YWJsZSwgZWxlbWVudCwgYWN0aW9uLCBzY29wZSkpIHtcbiAgICByZXR1cm4gYWN0aW9uO1xuICB9XG5cbiAgcmV0dXJuIG51bGw7XG59XG5cbmZ1bmN0aW9uIHZhbGlkYXRlTWF0Y2hlcyhpbnRlcmFjdGlvbiwgcG9pbnRlciwgZXZlbnQsIG1hdGNoZXMsIG1hdGNoRWxlbWVudHMsIGV2ZW50VGFyZ2V0LCBzY29wZSkge1xuICBmb3IgKGxldCBpID0gMCwgbGVuID0gbWF0Y2hlcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgIGNvbnN0IG1hdGNoID0gbWF0Y2hlc1tpXTtcbiAgICBjb25zdCBtYXRjaEVsZW1lbnQgPSBtYXRjaEVsZW1lbnRzW2ldO1xuICAgIGNvbnN0IG1hdGNoQWN0aW9uID0gbWF0Y2guZ2V0QWN0aW9uKHBvaW50ZXIsIGV2ZW50LCBpbnRlcmFjdGlvbiwgbWF0Y2hFbGVtZW50KTtcblxuICAgIGlmICghbWF0Y2hBY3Rpb24pIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIGNvbnN0IGFjdGlvbiA9IHZhbGlkYXRlQWN0aW9uKG1hdGNoQWN0aW9uLCBtYXRjaCwgbWF0Y2hFbGVtZW50LCBldmVudFRhcmdldCwgc2NvcGUpO1xuXG4gICAgaWYgKGFjdGlvbikge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgYWN0aW9uLFxuICAgICAgICBpbnRlcmFjdGFibGU6IG1hdGNoLFxuICAgICAgICBlbGVtZW50OiBtYXRjaEVsZW1lbnRcbiAgICAgIH07XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBhY3Rpb246IG51bGwsXG4gICAgaW50ZXJhY3RhYmxlOiBudWxsLFxuICAgIGVsZW1lbnQ6IG51bGxcbiAgfTtcbn1cblxuZnVuY3Rpb24gZ2V0QWN0aW9uSW5mbyhpbnRlcmFjdGlvbiwgcG9pbnRlciwgZXZlbnQsIGV2ZW50VGFyZ2V0LCBzY29wZSkge1xuICBsZXQgbWF0Y2hlcyA9IFtdO1xuICBsZXQgbWF0Y2hFbGVtZW50cyA9IFtdO1xuICBsZXQgZWxlbWVudCA9IGV2ZW50VGFyZ2V0O1xuXG4gIGZ1bmN0aW9uIHB1c2hNYXRjaGVzKGludGVyYWN0YWJsZSkge1xuICAgIG1hdGNoZXMucHVzaChpbnRlcmFjdGFibGUpO1xuICAgIG1hdGNoRWxlbWVudHMucHVzaChlbGVtZW50KTtcbiAgfVxuXG4gIHdoaWxlIChpcy5lbGVtZW50KGVsZW1lbnQpKSB7XG4gICAgbWF0Y2hlcyA9IFtdO1xuICAgIG1hdGNoRWxlbWVudHMgPSBbXTtcbiAgICBzY29wZS5pbnRlcmFjdGFibGVzLmZvckVhY2hNYXRjaChlbGVtZW50LCBwdXNoTWF0Y2hlcyk7XG4gICAgY29uc3QgYWN0aW9uSW5mbyA9IHZhbGlkYXRlTWF0Y2hlcyhpbnRlcmFjdGlvbiwgcG9pbnRlciwgZXZlbnQsIG1hdGNoZXMsIG1hdGNoRWxlbWVudHMsIGV2ZW50VGFyZ2V0LCBzY29wZSk7XG5cbiAgICBpZiAoYWN0aW9uSW5mby5hY3Rpb24gJiYgIWFjdGlvbkluZm8uaW50ZXJhY3RhYmxlLm9wdGlvbnNbYWN0aW9uSW5mby5hY3Rpb24ubmFtZV0ubWFudWFsU3RhcnQpIHtcbiAgICAgIHJldHVybiBhY3Rpb25JbmZvO1xuICAgIH1cblxuICAgIGVsZW1lbnQgPSBwYXJlbnROb2RlKGVsZW1lbnQpO1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBhY3Rpb246IG51bGwsXG4gICAgaW50ZXJhY3RhYmxlOiBudWxsLFxuICAgIGVsZW1lbnQ6IG51bGxcbiAgfTtcbn1cblxuZnVuY3Rpb24gcHJlcGFyZShpbnRlcmFjdGlvbiwge1xuICBhY3Rpb24sXG4gIGludGVyYWN0YWJsZSxcbiAgZWxlbWVudFxufSwgc2NvcGUpIHtcbiAgYWN0aW9uID0gYWN0aW9uIHx8IHtcbiAgICBuYW1lOiBudWxsXG4gIH07XG4gIGludGVyYWN0aW9uLmludGVyYWN0YWJsZSA9IGludGVyYWN0YWJsZTtcbiAgaW50ZXJhY3Rpb24uZWxlbWVudCA9IGVsZW1lbnQ7XG4gIGNvcHlBY3Rpb24oaW50ZXJhY3Rpb24ucHJlcGFyZWQsIGFjdGlvbik7XG4gIGludGVyYWN0aW9uLnJlY3QgPSBpbnRlcmFjdGFibGUgJiYgYWN0aW9uLm5hbWUgPyBpbnRlcmFjdGFibGUuZ2V0UmVjdChlbGVtZW50KSA6IG51bGw7XG4gIHNldEludGVyYWN0aW9uQ3Vyc29yKGludGVyYWN0aW9uLCBzY29wZSk7XG4gIHNjb3BlLmZpcmUoJ2F1dG9TdGFydDpwcmVwYXJlZCcsIHtcbiAgICBpbnRlcmFjdGlvblxuICB9KTtcbn1cblxuZnVuY3Rpb24gd2l0aGluSW50ZXJhY3Rpb25MaW1pdChpbnRlcmFjdGFibGUsIGVsZW1lbnQsIGFjdGlvbiwgc2NvcGUpIHtcbiAgY29uc3Qgb3B0aW9ucyA9IGludGVyYWN0YWJsZS5vcHRpb25zO1xuICBjb25zdCBtYXhBY3Rpb25zID0gb3B0aW9uc1thY3Rpb24ubmFtZV0ubWF4O1xuICBjb25zdCBtYXhQZXJFbGVtZW50ID0gb3B0aW9uc1thY3Rpb24ubmFtZV0ubWF4UGVyRWxlbWVudDtcbiAgY29uc3QgYXV0b1N0YXJ0TWF4ID0gc2NvcGUuYXV0b1N0YXJ0Lm1heEludGVyYWN0aW9ucztcbiAgbGV0IGFjdGl2ZUludGVyYWN0aW9ucyA9IDA7XG4gIGxldCBpbnRlcmFjdGFibGVDb3VudCA9IDA7XG4gIGxldCBlbGVtZW50Q291bnQgPSAwOyAvLyBubyBhY3Rpb25zIGlmIGFueSBvZiB0aGVzZSB2YWx1ZXMgPT0gMFxuXG4gIGlmICghKG1heEFjdGlvbnMgJiYgbWF4UGVyRWxlbWVudCAmJiBhdXRvU3RhcnRNYXgpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgZm9yIChjb25zdCBpbnRlcmFjdGlvbiBvZiBzY29wZS5pbnRlcmFjdGlvbnMubGlzdCkge1xuICAgIGNvbnN0IG90aGVyQWN0aW9uID0gaW50ZXJhY3Rpb24ucHJlcGFyZWQubmFtZTtcblxuICAgIGlmICghaW50ZXJhY3Rpb24uaW50ZXJhY3RpbmcoKSkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgYWN0aXZlSW50ZXJhY3Rpb25zKys7XG5cbiAgICBpZiAoYWN0aXZlSW50ZXJhY3Rpb25zID49IGF1dG9TdGFydE1heCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGlmIChpbnRlcmFjdGlvbi5pbnRlcmFjdGFibGUgIT09IGludGVyYWN0YWJsZSkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgaW50ZXJhY3RhYmxlQ291bnQgKz0gb3RoZXJBY3Rpb24gPT09IGFjdGlvbi5uYW1lID8gMSA6IDA7XG5cbiAgICBpZiAoaW50ZXJhY3RhYmxlQ291bnQgPj0gbWF4QWN0aW9ucykge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGlmIChpbnRlcmFjdGlvbi5lbGVtZW50ID09PSBlbGVtZW50KSB7XG4gICAgICBlbGVtZW50Q291bnQrKztcblxuICAgICAgaWYgKG90aGVyQWN0aW9uID09PSBhY3Rpb24ubmFtZSAmJiBlbGVtZW50Q291bnQgPj0gbWF4UGVyRWxlbWVudCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGF1dG9TdGFydE1heCA+IDA7XG59XG5cbmZ1bmN0aW9uIG1heEludGVyYWN0aW9ucyhuZXdWYWx1ZSwgc2NvcGUpIHtcbiAgaWYgKGlzLm51bWJlcihuZXdWYWx1ZSkpIHtcbiAgICBzY29wZS5hdXRvU3RhcnQubWF4SW50ZXJhY3Rpb25zID0gbmV3VmFsdWU7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICByZXR1cm4gc2NvcGUuYXV0b1N0YXJ0Lm1heEludGVyYWN0aW9ucztcbn1cblxuZnVuY3Rpb24gc2V0Q3Vyc29yKGVsZW1lbnQsIGN1cnNvciwgc2NvcGUpIHtcbiAgY29uc3Qge1xuICAgIGN1cnNvckVsZW1lbnQ6IHByZXZDdXJzb3JFbGVtZW50XG4gIH0gPSBzY29wZS5hdXRvU3RhcnQ7XG5cbiAgaWYgKHByZXZDdXJzb3JFbGVtZW50ICYmIHByZXZDdXJzb3JFbGVtZW50ICE9PSBlbGVtZW50KSB7XG4gICAgcHJldkN1cnNvckVsZW1lbnQuc3R5bGUuY3Vyc29yID0gJyc7XG4gIH1cblxuICBlbGVtZW50Lm93bmVyRG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnN0eWxlLmN1cnNvciA9IGN1cnNvcjtcbiAgZWxlbWVudC5zdHlsZS5jdXJzb3IgPSBjdXJzb3I7XG4gIHNjb3BlLmF1dG9TdGFydC5jdXJzb3JFbGVtZW50ID0gY3Vyc29yID8gZWxlbWVudCA6IG51bGw7XG59XG5cbmZ1bmN0aW9uIHNldEludGVyYWN0aW9uQ3Vyc29yKGludGVyYWN0aW9uLCBzY29wZSkge1xuICBjb25zdCB7XG4gICAgaW50ZXJhY3RhYmxlLFxuICAgIGVsZW1lbnQsXG4gICAgcHJlcGFyZWRcbiAgfSA9IGludGVyYWN0aW9uO1xuXG4gIGlmICghKGludGVyYWN0aW9uLnBvaW50ZXJUeXBlID09PSAnbW91c2UnICYmIGludGVyYWN0YWJsZSAmJiBpbnRlcmFjdGFibGUub3B0aW9ucy5zdHlsZUN1cnNvcikpIHtcbiAgICAvLyBjbGVhciBwcmV2aW91cyB0YXJnZXQgZWxlbWVudCBjdXJzb3JcbiAgICBpZiAoc2NvcGUuYXV0b1N0YXJ0LmN1cnNvckVsZW1lbnQpIHtcbiAgICAgIHNldEN1cnNvcihzY29wZS5hdXRvU3RhcnQuY3Vyc29yRWxlbWVudCwgJycsIHNjb3BlKTtcbiAgICB9XG5cbiAgICByZXR1cm47XG4gIH1cblxuICBsZXQgY3Vyc29yID0gJyc7XG5cbiAgaWYgKHByZXBhcmVkLm5hbWUpIHtcbiAgICBjb25zdCBjdXJzb3JDaGVja2VyID0gaW50ZXJhY3RhYmxlLm9wdGlvbnNbcHJlcGFyZWQubmFtZV0uY3Vyc29yQ2hlY2tlcjtcblxuICAgIGlmIChpcy5mdW5jKGN1cnNvckNoZWNrZXIpKSB7XG4gICAgICBjdXJzb3IgPSBjdXJzb3JDaGVja2VyKHByZXBhcmVkLCBpbnRlcmFjdGFibGUsIGVsZW1lbnQsIGludGVyYWN0aW9uLl9pbnRlcmFjdGluZyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGN1cnNvciA9IHNjb3BlLmFjdGlvbnMubWFwW3ByZXBhcmVkLm5hbWVdLmdldEN1cnNvcihwcmVwYXJlZCk7XG4gICAgfVxuICB9XG5cbiAgc2V0Q3Vyc29yKGludGVyYWN0aW9uLmVsZW1lbnQsIGN1cnNvciB8fCAnJywgc2NvcGUpO1xufVxuXG5jb25zdCBhdXRvU3RhcnQgPSB7XG4gIGlkOiAnYXV0by1zdGFydC9iYXNlJyxcbiAgYmVmb3JlOiBbJ2FjdGlvbnMnXSxcbiAgaW5zdGFsbDogYmFzZV9pbnN0YWxsLFxuICBsaXN0ZW5lcnM6IHtcbiAgICAnaW50ZXJhY3Rpb25zOmRvd24nOiBwcmVwYXJlT25Eb3duLFxuICAgICdpbnRlcmFjdGlvbnM6bW92ZSc6IChhcmcsIHNjb3BlKSA9PiB7XG4gICAgICBwcmVwYXJlT25Nb3ZlKGFyZywgc2NvcGUpO1xuICAgICAgc3RhcnRPbk1vdmUoYXJnLCBzY29wZSk7XG4gICAgfSxcbiAgICAnaW50ZXJhY3Rpb25zOnN0b3AnOiBjbGVhckN1cnNvck9uU3RvcFxuICB9LFxuICBtYXhJbnRlcmFjdGlvbnMsXG4gIHdpdGhpbkludGVyYWN0aW9uTGltaXQsXG4gIHZhbGlkYXRlQWN0aW9uXG59O1xuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyB2YXIgYmFzZSA9IChhdXRvU3RhcnQpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YmFzZS5qcy5tYXBcbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vbm9kZV9tb2R1bGVzL0BpbnRlcmFjdGpzL2F1dG8tc3RhcnQvZHJhZ0F4aXMuanNcblxuXG5cblxuZnVuY3Rpb24gYmVmb3JlU3RhcnQoe1xuICBpbnRlcmFjdGlvbixcbiAgZXZlbnRUYXJnZXQsXG4gIGR4LFxuICBkeVxufSwgc2NvcGUpIHtcbiAgaWYgKGludGVyYWN0aW9uLnByZXBhcmVkLm5hbWUgIT09ICdkcmFnJykge1xuICAgIHJldHVybjtcbiAgfSAvLyBjaGVjayBpZiBhIGRyYWcgaXMgaW4gdGhlIGNvcnJlY3QgYXhpc1xuXG5cbiAgY29uc3QgYWJzWCA9IE1hdGguYWJzKGR4KTtcbiAgY29uc3QgYWJzWSA9IE1hdGguYWJzKGR5KTtcbiAgY29uc3QgdGFyZ2V0T3B0aW9ucyA9IGludGVyYWN0aW9uLmludGVyYWN0YWJsZS5vcHRpb25zLmRyYWc7XG4gIGNvbnN0IHN0YXJ0QXhpcyA9IHRhcmdldE9wdGlvbnMuc3RhcnRBeGlzO1xuICBjb25zdCBjdXJyZW50QXhpcyA9IGFic1ggPiBhYnNZID8gJ3gnIDogYWJzWCA8IGFic1kgPyAneScgOiAneHknO1xuICBpbnRlcmFjdGlvbi5wcmVwYXJlZC5heGlzID0gdGFyZ2V0T3B0aW9ucy5sb2NrQXhpcyA9PT0gJ3N0YXJ0JyA/IGN1cnJlbnRBeGlzWzBdIC8vIGFsd2F5cyBsb2NrIHRvIG9uZSBheGlzIGV2ZW4gaWYgY3VycmVudEF4aXMgPT09ICd4eSdcbiAgOiB0YXJnZXRPcHRpb25zLmxvY2tBeGlzOyAvLyBpZiB0aGUgbW92ZW1lbnQgaXNuJ3QgaW4gdGhlIHN0YXJ0QXhpcyBvZiB0aGUgaW50ZXJhY3RhYmxlXG5cbiAgaWYgKGN1cnJlbnRBeGlzICE9PSAneHknICYmIHN0YXJ0QXhpcyAhPT0gJ3h5JyAmJiBzdGFydEF4aXMgIT09IGN1cnJlbnRBeGlzKSB7XG4gICAgLy8gY2FuY2VsIHRoZSBwcmVwYXJlZCBhY3Rpb25cbiAgICBpbnRlcmFjdGlvbi5wcmVwYXJlZC5uYW1lID0gbnVsbDsgLy8gdGhlbiB0cnkgdG8gZ2V0IGEgZHJhZyBmcm9tIGFub3RoZXIgaW5lcmFjdGFibGVcblxuICAgIGxldCBlbGVtZW50ID0gZXZlbnRUYXJnZXQ7XG5cbiAgICBjb25zdCBnZXREcmFnZ2FibGUgPSBmdW5jdGlvbiAoaW50ZXJhY3RhYmxlKSB7XG4gICAgICBpZiAoaW50ZXJhY3RhYmxlID09PSBpbnRlcmFjdGlvbi5pbnRlcmFjdGFibGUpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBvcHRpb25zID0gaW50ZXJhY3Rpb24uaW50ZXJhY3RhYmxlLm9wdGlvbnMuZHJhZztcblxuICAgICAgaWYgKCFvcHRpb25zLm1hbnVhbFN0YXJ0ICYmIGludGVyYWN0YWJsZS50ZXN0SWdub3JlQWxsb3cob3B0aW9ucywgZWxlbWVudCwgZXZlbnRUYXJnZXQpKSB7XG4gICAgICAgIGNvbnN0IGFjdGlvbiA9IGludGVyYWN0YWJsZS5nZXRBY3Rpb24oaW50ZXJhY3Rpb24uZG93blBvaW50ZXIsIGludGVyYWN0aW9uLmRvd25FdmVudCwgaW50ZXJhY3Rpb24sIGVsZW1lbnQpO1xuXG4gICAgICAgIGlmIChhY3Rpb24gJiYgYWN0aW9uLm5hbWUgPT09ICdkcmFnJyAmJiBjaGVja1N0YXJ0QXhpcyhjdXJyZW50QXhpcywgaW50ZXJhY3RhYmxlKSAmJiBiYXNlLnZhbGlkYXRlQWN0aW9uKGFjdGlvbiwgaW50ZXJhY3RhYmxlLCBlbGVtZW50LCBldmVudFRhcmdldCwgc2NvcGUpKSB7XG4gICAgICAgICAgcmV0dXJuIGludGVyYWN0YWJsZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07IC8vIGNoZWNrIGFsbCBpbnRlcmFjdGFibGVzXG5cblxuICAgIHdoaWxlIChpcy5lbGVtZW50KGVsZW1lbnQpKSB7XG4gICAgICBjb25zdCBpbnRlcmFjdGFibGUgPSBzY29wZS5pbnRlcmFjdGFibGVzLmZvckVhY2hNYXRjaChlbGVtZW50LCBnZXREcmFnZ2FibGUpO1xuXG4gICAgICBpZiAoaW50ZXJhY3RhYmxlKSB7XG4gICAgICAgIGludGVyYWN0aW9uLnByZXBhcmVkLm5hbWUgPSAnZHJhZyc7XG4gICAgICAgIGludGVyYWN0aW9uLmludGVyYWN0YWJsZSA9IGludGVyYWN0YWJsZTtcbiAgICAgICAgaW50ZXJhY3Rpb24uZWxlbWVudCA9IGVsZW1lbnQ7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgICBlbGVtZW50ID0gcGFyZW50Tm9kZShlbGVtZW50KTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gY2hlY2tTdGFydEF4aXMoc3RhcnRBeGlzLCBpbnRlcmFjdGFibGUpIHtcbiAgaWYgKCFpbnRlcmFjdGFibGUpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBjb25zdCB0aGlzQXhpcyA9IGludGVyYWN0YWJsZS5vcHRpb25zLmRyYWcuc3RhcnRBeGlzO1xuICByZXR1cm4gc3RhcnRBeGlzID09PSAneHknIHx8IHRoaXNBeGlzID09PSAneHknIHx8IHRoaXNBeGlzID09PSBzdGFydEF4aXM7XG59XG5cbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gdmFyIGRyYWdBeGlzID0gKHtcbiAgaWQ6ICdhdXRvLXN0YXJ0L2RyYWdBeGlzJyxcbiAgbGlzdGVuZXJzOiB7XG4gICAgJ2F1dG9TdGFydDpiZWZvcmUtc3RhcnQnOiBiZWZvcmVTdGFydFxuICB9XG59KTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRyYWdBeGlzLmpzLm1hcFxuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9ub2RlX21vZHVsZXMvQGludGVyYWN0anMvYXV0by1zdGFydC9ob2xkLmpzXG5cblxuXG5mdW5jdGlvbiBob2xkX2luc3RhbGwoc2NvcGUpIHtcbiAgY29uc3Qge1xuICAgIGRlZmF1bHRzXG4gIH0gPSBzY29wZTtcbiAgc2NvcGUudXNlUGx1Z2luKGJhc2UpO1xuICBkZWZhdWx0cy5wZXJBY3Rpb24uaG9sZCA9IDA7XG4gIGRlZmF1bHRzLnBlckFjdGlvbi5kZWxheSA9IDA7XG59XG5cbmZ1bmN0aW9uIGdldEhvbGREdXJhdGlvbihpbnRlcmFjdGlvbikge1xuICBjb25zdCBhY3Rpb25OYW1lID0gaW50ZXJhY3Rpb24ucHJlcGFyZWQgJiYgaW50ZXJhY3Rpb24ucHJlcGFyZWQubmFtZTtcblxuICBpZiAoIWFjdGlvbk5hbWUpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIGNvbnN0IG9wdGlvbnMgPSBpbnRlcmFjdGlvbi5pbnRlcmFjdGFibGUub3B0aW9ucztcbiAgcmV0dXJuIG9wdGlvbnNbYWN0aW9uTmFtZV0uaG9sZCB8fCBvcHRpb25zW2FjdGlvbk5hbWVdLmRlbGF5O1xufVxuXG5jb25zdCBob2xkID0ge1xuICBpZDogJ2F1dG8tc3RhcnQvaG9sZCcsXG4gIGluc3RhbGw6IGhvbGRfaW5zdGFsbCxcbiAgbGlzdGVuZXJzOiB7XG4gICAgJ2ludGVyYWN0aW9uczpuZXcnOiAoe1xuICAgICAgaW50ZXJhY3Rpb25cbiAgICB9KSA9PiB7XG4gICAgICBpbnRlcmFjdGlvbi5hdXRvU3RhcnRIb2xkVGltZXIgPSBudWxsO1xuICAgIH0sXG4gICAgJ2F1dG9TdGFydDpwcmVwYXJlZCc6ICh7XG4gICAgICBpbnRlcmFjdGlvblxuICAgIH0pID0+IHtcbiAgICAgIGNvbnN0IGhvbGQgPSBnZXRIb2xkRHVyYXRpb24oaW50ZXJhY3Rpb24pO1xuXG4gICAgICBpZiAoaG9sZCA+IDApIHtcbiAgICAgICAgaW50ZXJhY3Rpb24uYXV0b1N0YXJ0SG9sZFRpbWVyID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgaW50ZXJhY3Rpb24uc3RhcnQoaW50ZXJhY3Rpb24ucHJlcGFyZWQsIGludGVyYWN0aW9uLmludGVyYWN0YWJsZSwgaW50ZXJhY3Rpb24uZWxlbWVudCk7XG4gICAgICAgIH0sIGhvbGQpO1xuICAgICAgfVxuICAgIH0sXG4gICAgJ2ludGVyYWN0aW9uczptb3ZlJzogKHtcbiAgICAgIGludGVyYWN0aW9uLFxuICAgICAgZHVwbGljYXRlXG4gICAgfSkgPT4ge1xuICAgICAgaWYgKGludGVyYWN0aW9uLmF1dG9TdGFydEhvbGRUaW1lciAmJiBpbnRlcmFjdGlvbi5wb2ludGVyV2FzTW92ZWQgJiYgIWR1cGxpY2F0ZSkge1xuICAgICAgICBjbGVhclRpbWVvdXQoaW50ZXJhY3Rpb24uYXV0b1N0YXJ0SG9sZFRpbWVyKTtcbiAgICAgICAgaW50ZXJhY3Rpb24uYXV0b1N0YXJ0SG9sZFRpbWVyID0gbnVsbDtcbiAgICAgIH1cbiAgICB9LFxuICAgIC8vIHByZXZlbnQgcmVndWxhciBkb3duLT5tb3ZlIGF1dG9TdGFydFxuICAgICdhdXRvU3RhcnQ6YmVmb3JlLXN0YXJ0JzogKHtcbiAgICAgIGludGVyYWN0aW9uXG4gICAgfSkgPT4ge1xuICAgICAgY29uc3QgaG9sZER1cmF0aW9uID0gZ2V0SG9sZER1cmF0aW9uKGludGVyYWN0aW9uKTtcblxuICAgICAgaWYgKGhvbGREdXJhdGlvbiA+IDApIHtcbiAgICAgICAgaW50ZXJhY3Rpb24ucHJlcGFyZWQubmFtZSA9IG51bGw7XG4gICAgICB9XG4gICAgfVxuICB9LFxuICBnZXRIb2xkRHVyYXRpb25cbn07XG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIHZhciBhdXRvX3N0YXJ0X2hvbGQgPSAoaG9sZCk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1ob2xkLmpzLm1hcFxuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9ub2RlX21vZHVsZXMvQGludGVyYWN0anMvYXV0by1zdGFydC9wbHVnaW4uanNcblxuXG5cbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gdmFyIGF1dG9fc3RhcnRfcGx1Z2luID0gKHtcbiAgaWQ6ICdhdXRvLXN0YXJ0JyxcblxuICBpbnN0YWxsKHNjb3BlKSB7XG4gICAgc2NvcGUudXNlUGx1Z2luKGJhc2UpO1xuICAgIHNjb3BlLnVzZVBsdWdpbihhdXRvX3N0YXJ0X2hvbGQpO1xuICAgIHNjb3BlLnVzZVBsdWdpbihkcmFnQXhpcyk7XG4gIH1cblxufSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1wbHVnaW4uanMubWFwXG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL25vZGVfbW9kdWxlcy9AaW50ZXJhY3Rqcy9hdXRvLXN0YXJ0L2luZGV4LmpzXG4vKiBlc2xpbnQtZGlzYWJsZSBpbXBvcnQvb3JkZXIsIG5vLWNvbnNvbGUsIGVvbC1sYXN0ICovXG5cblxuXG5pZiAodHlwZW9mIHdpbmRvdyA9PT0gJ29iamVjdCcgJiYgISF3aW5kb3cpIHtcbiAgaW50ZXJhY3RfaW5pdCh3aW5kb3cpO1xufVxuXG5faW50ZXJhY3Rqc19pbnRlcmFjdC51c2UoYXV0b19zdGFydF9wbHVnaW4pO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwXG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL25vZGVfbW9kdWxlcy9AaW50ZXJhY3Rqcy9hY3Rpb25zL2RyYWcvcGx1Z2luLmpzXG5cblxuXG5mdW5jdGlvbiBwbHVnaW5faW5zdGFsbChzY29wZSkge1xuICBjb25zdCB7XG4gICAgYWN0aW9ucyxcbiAgICBJbnRlcmFjdGFibGUsXG4gICAgZGVmYXVsdHNcbiAgfSA9IHNjb3BlO1xuICBJbnRlcmFjdGFibGUucHJvdG90eXBlLmRyYWdnYWJsZSA9IGRyYWcuZHJhZ2dhYmxlO1xuICBhY3Rpb25zLm1hcC5kcmFnID0gZHJhZztcbiAgYWN0aW9ucy5tZXRob2REaWN0LmRyYWcgPSAnZHJhZ2dhYmxlJztcbiAgZGVmYXVsdHMuYWN0aW9ucy5kcmFnID0gZHJhZy5kZWZhdWx0cztcbn1cblxuZnVuY3Rpb24gYmVmb3JlTW92ZSh7XG4gIGludGVyYWN0aW9uXG59KSB7XG4gIGlmIChpbnRlcmFjdGlvbi5wcmVwYXJlZC5uYW1lICE9PSAnZHJhZycpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBjb25zdCBheGlzID0gaW50ZXJhY3Rpb24ucHJlcGFyZWQuYXhpcztcblxuICBpZiAoYXhpcyA9PT0gJ3gnKSB7XG4gICAgaW50ZXJhY3Rpb24uY29vcmRzLmN1ci5wYWdlLnkgPSBpbnRlcmFjdGlvbi5jb29yZHMuc3RhcnQucGFnZS55O1xuICAgIGludGVyYWN0aW9uLmNvb3Jkcy5jdXIuY2xpZW50LnkgPSBpbnRlcmFjdGlvbi5jb29yZHMuc3RhcnQuY2xpZW50Lnk7XG4gICAgaW50ZXJhY3Rpb24uY29vcmRzLnZlbG9jaXR5LmNsaWVudC55ID0gMDtcbiAgICBpbnRlcmFjdGlvbi5jb29yZHMudmVsb2NpdHkucGFnZS55ID0gMDtcbiAgfSBlbHNlIGlmIChheGlzID09PSAneScpIHtcbiAgICBpbnRlcmFjdGlvbi5jb29yZHMuY3VyLnBhZ2UueCA9IGludGVyYWN0aW9uLmNvb3Jkcy5zdGFydC5wYWdlLng7XG4gICAgaW50ZXJhY3Rpb24uY29vcmRzLmN1ci5jbGllbnQueCA9IGludGVyYWN0aW9uLmNvb3Jkcy5zdGFydC5jbGllbnQueDtcbiAgICBpbnRlcmFjdGlvbi5jb29yZHMudmVsb2NpdHkuY2xpZW50LnggPSAwO1xuICAgIGludGVyYWN0aW9uLmNvb3Jkcy52ZWxvY2l0eS5wYWdlLnggPSAwO1xuICB9XG59XG5cbmZ1bmN0aW9uIG1vdmUoe1xuICBpRXZlbnQsXG4gIGludGVyYWN0aW9uXG59KSB7XG4gIGlmIChpbnRlcmFjdGlvbi5wcmVwYXJlZC5uYW1lICE9PSAnZHJhZycpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBjb25zdCBheGlzID0gaW50ZXJhY3Rpb24ucHJlcGFyZWQuYXhpcztcblxuICBpZiAoYXhpcyA9PT0gJ3gnIHx8IGF4aXMgPT09ICd5Jykge1xuICAgIGNvbnN0IG9wcG9zaXRlID0gYXhpcyA9PT0gJ3gnID8gJ3knIDogJ3gnO1xuICAgIGlFdmVudC5wYWdlW29wcG9zaXRlXSA9IGludGVyYWN0aW9uLmNvb3Jkcy5zdGFydC5wYWdlW29wcG9zaXRlXTtcbiAgICBpRXZlbnQuY2xpZW50W29wcG9zaXRlXSA9IGludGVyYWN0aW9uLmNvb3Jkcy5zdGFydC5jbGllbnRbb3Bwb3NpdGVdO1xuICAgIGlFdmVudC5kZWx0YVtvcHBvc2l0ZV0gPSAwO1xuICB9XG59XG4vKipcbiAqIGBgYGpzXG4gKiBpbnRlcmFjdChlbGVtZW50KS5kcmFnZ2FibGUoe1xuICogICAgIG9uc3RhcnQ6IGZ1bmN0aW9uIChldmVudCkge30sXG4gKiAgICAgb25tb3ZlIDogZnVuY3Rpb24gKGV2ZW50KSB7fSxcbiAqICAgICBvbmVuZCAgOiBmdW5jdGlvbiAoZXZlbnQpIHt9LFxuICpcbiAqICAgICAvLyB0aGUgYXhpcyBpbiB3aGljaCB0aGUgZmlyc3QgbW92ZW1lbnQgbXVzdCBiZVxuICogICAgIC8vIGZvciB0aGUgZHJhZyBzZXF1ZW5jZSB0byBzdGFydFxuICogICAgIC8vICd4eScgYnkgZGVmYXVsdCAtIGFueSBkaXJlY3Rpb25cbiAqICAgICBzdGFydEF4aXM6ICd4JyB8fCAneScgfHwgJ3h5JyxcbiAqXG4gKiAgICAgLy8gJ3h5JyBieSBkZWZhdWx0IC0gZG9uJ3QgcmVzdHJpY3QgdG8gb25lIGF4aXMgKG1vdmUgaW4gYW55IGRpcmVjdGlvbilcbiAqICAgICAvLyAneCcgb3IgJ3knIHRvIHJlc3RyaWN0IG1vdmVtZW50IHRvIGVpdGhlciBheGlzXG4gKiAgICAgLy8gJ3N0YXJ0JyB0byByZXN0cmljdCBtb3ZlbWVudCB0byB0aGUgYXhpcyB0aGUgZHJhZyBzdGFydGVkIGluXG4gKiAgICAgbG9ja0F4aXM6ICd4JyB8fCAneScgfHwgJ3h5JyB8fCAnc3RhcnQnLFxuICpcbiAqICAgICAvLyBtYXggbnVtYmVyIG9mIGRyYWdzIHRoYXQgY2FuIGhhcHBlbiBjb25jdXJyZW50bHlcbiAqICAgICAvLyB3aXRoIGVsZW1lbnRzIG9mIHRoaXMgSW50ZXJhY3RhYmxlLiBJbmZpbml0eSBieSBkZWZhdWx0XG4gKiAgICAgbWF4OiBJbmZpbml0eSxcbiAqXG4gKiAgICAgLy8gbWF4IG51bWJlciBvZiBkcmFncyB0aGF0IGNhbiB0YXJnZXQgdGhlIHNhbWUgZWxlbWVudCtJbnRlcmFjdGFibGVcbiAqICAgICAvLyAxIGJ5IGRlZmF1bHRcbiAqICAgICBtYXhQZXJFbGVtZW50OiAyXG4gKiB9KVxuICpcbiAqIHZhciBpc0RyYWdnYWJsZSA9IGludGVyYWN0KCdlbGVtZW50JykuZHJhZ2dhYmxlKCk7IC8vIHRydWVcbiAqIGBgYFxuICpcbiAqIEdldCBvciBzZXQgd2hldGhlciBkcmFnIGFjdGlvbnMgY2FuIGJlIHBlcmZvcm1lZCBvbiB0aGUgdGFyZ2V0XG4gKlxuICogQGFsaWFzIEludGVyYWN0YWJsZS5wcm90b3R5cGUuZHJhZ2dhYmxlXG4gKlxuICogQHBhcmFtIHtib29sZWFuIHwgb2JqZWN0fSBbb3B0aW9uc10gdHJ1ZS9mYWxzZSBvciBBbiBvYmplY3Qgd2l0aCBldmVudFxuICogbGlzdGVuZXJzIHRvIGJlIGZpcmVkIG9uIGRyYWcgZXZlbnRzIChvYmplY3QgbWFrZXMgdGhlIEludGVyYWN0YWJsZVxuICogZHJhZ2dhYmxlKVxuICogQHJldHVybiB7Ym9vbGVhbiB8IEludGVyYWN0YWJsZX0gYm9vbGVhbiBpbmRpY2F0aW5nIGlmIHRoaXMgY2FuIGJlIHRoZVxuICogdGFyZ2V0IG9mIGRyYWcgZXZlbnRzLCBvciB0aGlzIEludGVyY3RhYmxlXG4gKi9cblxuXG5jb25zdCBwbHVnaW5fZHJhZ2dhYmxlID0gZnVuY3Rpb24gZHJhZ2dhYmxlKG9wdGlvbnMpIHtcbiAgaWYgKGlzLm9iamVjdChvcHRpb25zKSkge1xuICAgIHRoaXMub3B0aW9ucy5kcmFnLmVuYWJsZWQgPSBvcHRpb25zLmVuYWJsZWQgIT09IGZhbHNlO1xuICAgIHRoaXMuc2V0UGVyQWN0aW9uKCdkcmFnJywgb3B0aW9ucyk7XG4gICAgdGhpcy5zZXRPbkV2ZW50cygnZHJhZycsIG9wdGlvbnMpO1xuXG4gICAgaWYgKC9eKHh5fHh8eXxzdGFydCkkLy50ZXN0KG9wdGlvbnMubG9ja0F4aXMpKSB7XG4gICAgICB0aGlzLm9wdGlvbnMuZHJhZy5sb2NrQXhpcyA9IG9wdGlvbnMubG9ja0F4aXM7XG4gICAgfVxuXG4gICAgaWYgKC9eKHh5fHh8eSkkLy50ZXN0KG9wdGlvbnMuc3RhcnRBeGlzKSkge1xuICAgICAgdGhpcy5vcHRpb25zLmRyYWcuc3RhcnRBeGlzID0gb3B0aW9ucy5zdGFydEF4aXM7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICBpZiAoaXMuYm9vbChvcHRpb25zKSkge1xuICAgIHRoaXMub3B0aW9ucy5kcmFnLmVuYWJsZWQgPSBvcHRpb25zO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgcmV0dXJuIHRoaXMub3B0aW9ucy5kcmFnO1xufTtcblxuY29uc3QgZHJhZyA9IHtcbiAgaWQ6ICdhY3Rpb25zL2RyYWcnLFxuICBpbnN0YWxsOiBwbHVnaW5faW5zdGFsbCxcbiAgbGlzdGVuZXJzOiB7XG4gICAgJ2ludGVyYWN0aW9uczpiZWZvcmUtYWN0aW9uLW1vdmUnOiBiZWZvcmVNb3ZlLFxuICAgICdpbnRlcmFjdGlvbnM6YWN0aW9uLXJlc3VtZSc6IGJlZm9yZU1vdmUsXG4gICAgLy8gZHJhZ21vdmVcbiAgICAnaW50ZXJhY3Rpb25zOmFjdGlvbi1tb3ZlJzogbW92ZSxcbiAgICAnYXV0by1zdGFydDpjaGVjayc6IGFyZyA9PiB7XG4gICAgICBjb25zdCB7XG4gICAgICAgIGludGVyYWN0aW9uLFxuICAgICAgICBpbnRlcmFjdGFibGUsXG4gICAgICAgIGJ1dHRvbnNcbiAgICAgIH0gPSBhcmc7XG4gICAgICBjb25zdCBkcmFnT3B0aW9ucyA9IGludGVyYWN0YWJsZS5vcHRpb25zLmRyYWc7XG5cbiAgICAgIGlmICghKGRyYWdPcHRpb25zICYmIGRyYWdPcHRpb25zLmVuYWJsZWQpIHx8IC8vIGNoZWNrIG1vdXNlQnV0dG9uIHNldHRpbmcgaWYgdGhlIHBvaW50ZXIgaXMgZG93blxuICAgICAgaW50ZXJhY3Rpb24ucG9pbnRlcklzRG93biAmJiAvbW91c2V8cG9pbnRlci8udGVzdChpbnRlcmFjdGlvbi5wb2ludGVyVHlwZSkgJiYgKGJ1dHRvbnMgJiBpbnRlcmFjdGFibGUub3B0aW9ucy5kcmFnLm1vdXNlQnV0dG9ucykgPT09IDApIHtcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgIH1cblxuICAgICAgYXJnLmFjdGlvbiA9IHtcbiAgICAgICAgbmFtZTogJ2RyYWcnLFxuICAgICAgICBheGlzOiBkcmFnT3B0aW9ucy5sb2NrQXhpcyA9PT0gJ3N0YXJ0JyA/IGRyYWdPcHRpb25zLnN0YXJ0QXhpcyA6IGRyYWdPcHRpb25zLmxvY2tBeGlzXG4gICAgICB9O1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfSxcbiAgZHJhZ2dhYmxlOiBwbHVnaW5fZHJhZ2dhYmxlLFxuICBiZWZvcmVNb3ZlLFxuICBtb3ZlLFxuICBkZWZhdWx0czoge1xuICAgIHN0YXJ0QXhpczogJ3h5JyxcbiAgICBsb2NrQXhpczogJ3h5J1xuICB9LFxuXG4gIGdldEN1cnNvcigpIHtcbiAgICByZXR1cm4gJ21vdmUnO1xuICB9XG5cbn07XG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIHZhciBkcmFnX3BsdWdpbiA9IChkcmFnKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXBsdWdpbi5qcy5tYXBcbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vbm9kZV9tb2R1bGVzL0BpbnRlcmFjdGpzL2FjdGlvbnMvZHJhZy9pbmRleC5qc1xuLyogZXNsaW50LWRpc2FibGUgaW1wb3J0L29yZGVyLCBuby1jb25zb2xlLCBlb2wtbGFzdCAqL1xuXG5cblxuaWYgKHR5cGVvZiB3aW5kb3cgPT09ICdvYmplY3QnICYmICEhd2luZG93KSB7XG4gIGludGVyYWN0X2luaXQod2luZG93KTtcbn1cblxuX2ludGVyYWN0anNfaW50ZXJhY3QudXNlKGRyYWdfcGx1Z2luKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcFxuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9ub2RlX21vZHVsZXMvQGludGVyYWN0anMvYWN0aW9ucy9yZXNpemUvcGx1Z2luLmpzXG5cblxuXG5cblxuXG5mdW5jdGlvbiByZXNpemVfcGx1Z2luX2luc3RhbGwoc2NvcGUpIHtcbiAgY29uc3Qge1xuICAgIGFjdGlvbnMsXG4gICAgYnJvd3NlcixcblxuICAgIC8qKiBAbGVuZHMgSW50ZXJhY3RhYmxlICovXG4gICAgSW50ZXJhY3RhYmxlLFxuICAgIC8vIHRzbGludDpkaXNhYmxlLWxpbmUgbm8tc2hhZG93ZWQtdmFyaWFibGVcbiAgICBkZWZhdWx0c1xuICB9ID0gc2NvcGU7IC8vIExlc3MgUHJlY2lzaW9uIHdpdGggdG91Y2ggaW5wdXRcblxuICByZXNpemUuY3Vyc29ycyA9IGluaXRDdXJzb3JzKGJyb3dzZXIpO1xuICByZXNpemUuZGVmYXVsdE1hcmdpbiA9IGJyb3dzZXIuc3VwcG9ydHNUb3VjaCB8fCBicm93c2VyLnN1cHBvcnRzUG9pbnRlckV2ZW50ID8gMjAgOiAxMDtcbiAgLyoqXG4gICAqIGBgYGpzXG4gICAqIGludGVyYWN0KGVsZW1lbnQpLnJlc2l6YWJsZSh7XG4gICAqICAgb25zdGFydDogZnVuY3Rpb24gKGV2ZW50KSB7fSxcbiAgICogICBvbm1vdmUgOiBmdW5jdGlvbiAoZXZlbnQpIHt9LFxuICAgKiAgIG9uZW5kICA6IGZ1bmN0aW9uIChldmVudCkge30sXG4gICAqXG4gICAqICAgZWRnZXM6IHtcbiAgICogICAgIHRvcCAgIDogdHJ1ZSwgICAgICAgLy8gVXNlIHBvaW50ZXIgY29vcmRzIHRvIGNoZWNrIGZvciByZXNpemUuXG4gICAqICAgICBsZWZ0ICA6IGZhbHNlLCAgICAgIC8vIERpc2FibGUgcmVzaXppbmcgZnJvbSBsZWZ0IGVkZ2UuXG4gICAqICAgICBib3R0b206ICcucmVzaXplLXMnLC8vIFJlc2l6ZSBpZiBwb2ludGVyIHRhcmdldCBtYXRjaGVzIHNlbGVjdG9yXG4gICAqICAgICByaWdodCA6IGhhbmRsZUVsICAgIC8vIFJlc2l6ZSBpZiBwb2ludGVyIHRhcmdldCBpcyB0aGUgZ2l2ZW4gRWxlbWVudFxuICAgKiAgIH0sXG4gICAqXG4gICAqICAgICAvLyBXaWR0aCBhbmQgaGVpZ2h0IGNhbiBiZSBhZGp1c3RlZCBpbmRlcGVuZGVudGx5LiBXaGVuIGB0cnVlYCwgd2lkdGggYW5kXG4gICAqICAgICAvLyBoZWlnaHQgYXJlIGFkanVzdGVkIGF0IGEgMToxIHJhdGlvLlxuICAgKiAgICAgc3F1YXJlOiBmYWxzZSxcbiAgICpcbiAgICogICAgIC8vIFdpZHRoIGFuZCBoZWlnaHQgY2FuIGJlIGFkanVzdGVkIGluZGVwZW5kZW50bHkuIFdoZW4gYHRydWVgLCB3aWR0aCBhbmRcbiAgICogICAgIC8vIGhlaWdodCBtYWludGFpbiB0aGUgYXNwZWN0IHJhdGlvIHRoZXkgaGFkIHdoZW4gcmVzaXppbmcgc3RhcnRlZC5cbiAgICogICAgIHByZXNlcnZlQXNwZWN0UmF0aW86IGZhbHNlLFxuICAgKlxuICAgKiAgIC8vIGEgdmFsdWUgb2YgJ25vbmUnIHdpbGwgbGltaXQgdGhlIHJlc2l6ZSByZWN0IHRvIGEgbWluaW11bSBvZiAweDBcbiAgICogICAvLyAnbmVnYXRlJyB3aWxsIGFsbG93IHRoZSByZWN0IHRvIGhhdmUgbmVnYXRpdmUgd2lkdGgvaGVpZ2h0XG4gICAqICAgLy8gJ3JlcG9zaXRpb24nIHdpbGwga2VlcCB0aGUgd2lkdGgvaGVpZ2h0IHBvc2l0aXZlIGJ5IHN3YXBwaW5nXG4gICAqICAgLy8gdGhlIHRvcCBhbmQgYm90dG9tIGVkZ2VzIGFuZC9vciBzd2FwcGluZyB0aGUgbGVmdCBhbmQgcmlnaHQgZWRnZXNcbiAgICogICBpbnZlcnQ6ICdub25lJyB8fCAnbmVnYXRlJyB8fCAncmVwb3NpdGlvbidcbiAgICpcbiAgICogICAvLyBsaW1pdCBtdWx0aXBsZSByZXNpemVzLlxuICAgKiAgIC8vIFNlZSB0aGUgZXhwbGFuYXRpb24gaW4gdGhlIHtAbGluayBJbnRlcmFjdGFibGUuZHJhZ2dhYmxlfSBleGFtcGxlXG4gICAqICAgbWF4OiBJbmZpbml0eSxcbiAgICogICBtYXhQZXJFbGVtZW50OiAxLFxuICAgKiB9KVxuICAgKlxuICAgKiB2YXIgaXNSZXNpemVhYmxlID0gaW50ZXJhY3QoZWxlbWVudCkucmVzaXphYmxlKClcbiAgICogYGBgXG4gICAqXG4gICAqIEdldHMgb3Igc2V0cyB3aGV0aGVyIHJlc2l6ZSBhY3Rpb25zIGNhbiBiZSBwZXJmb3JtZWQgb24gdGhlIHRhcmdldFxuICAgKlxuICAgKiBAcGFyYW0ge2Jvb2xlYW4gfCBvYmplY3R9IFtvcHRpb25zXSB0cnVlL2ZhbHNlIG9yIEFuIG9iamVjdCB3aXRoIGV2ZW50XG4gICAqIGxpc3RlbmVycyB0byBiZSBmaXJlZCBvbiByZXNpemUgZXZlbnRzIChvYmplY3QgbWFrZXMgdGhlIEludGVyYWN0YWJsZVxuICAgKiByZXNpemFibGUpXG4gICAqIEByZXR1cm4ge2Jvb2xlYW4gfCBJbnRlcmFjdGFibGV9IEEgYm9vbGVhbiBpbmRpY2F0aW5nIGlmIHRoaXMgY2FuIGJlIHRoZVxuICAgKiB0YXJnZXQgb2YgcmVzaXplIGVsZW1lbnRzLCBvciB0aGlzIEludGVyYWN0YWJsZVxuICAgKi9cblxuICBJbnRlcmFjdGFibGUucHJvdG90eXBlLnJlc2l6YWJsZSA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgcmV0dXJuIHJlc2l6YWJsZSh0aGlzLCBvcHRpb25zLCBzY29wZSk7XG4gIH07XG5cbiAgYWN0aW9ucy5tYXAucmVzaXplID0gcmVzaXplO1xuICBhY3Rpb25zLm1ldGhvZERpY3QucmVzaXplID0gJ3Jlc2l6YWJsZSc7XG4gIGRlZmF1bHRzLmFjdGlvbnMucmVzaXplID0gcmVzaXplLmRlZmF1bHRzO1xufVxuXG5mdW5jdGlvbiByZXNpemVDaGVja2VyKGFyZykge1xuICBjb25zdCB7XG4gICAgaW50ZXJhY3Rpb24sXG4gICAgaW50ZXJhY3RhYmxlLFxuICAgIGVsZW1lbnQsXG4gICAgcmVjdCxcbiAgICBidXR0b25zXG4gIH0gPSBhcmc7XG5cbiAgaWYgKCFyZWN0KSB7XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfVxuXG4gIGNvbnN0IHBhZ2UgPSBleHRlbmQoe30sIGludGVyYWN0aW9uLmNvb3Jkcy5jdXIucGFnZSk7XG4gIGNvbnN0IHJlc2l6ZU9wdGlvbnMgPSBpbnRlcmFjdGFibGUub3B0aW9ucy5yZXNpemU7XG5cbiAgaWYgKCEocmVzaXplT3B0aW9ucyAmJiByZXNpemVPcHRpb25zLmVuYWJsZWQpIHx8IC8vIGNoZWNrIG1vdXNlQnV0dG9uIHNldHRpbmcgaWYgdGhlIHBvaW50ZXIgaXMgZG93blxuICBpbnRlcmFjdGlvbi5wb2ludGVySXNEb3duICYmIC9tb3VzZXxwb2ludGVyLy50ZXN0KGludGVyYWN0aW9uLnBvaW50ZXJUeXBlKSAmJiAoYnV0dG9ucyAmIHJlc2l6ZU9wdGlvbnMubW91c2VCdXR0b25zKSA9PT0gMCkge1xuICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH0gLy8gaWYgdXNpbmcgcmVzaXplLmVkZ2VzXG5cblxuICBpZiAoaXMub2JqZWN0KHJlc2l6ZU9wdGlvbnMuZWRnZXMpKSB7XG4gICAgY29uc3QgcmVzaXplRWRnZXMgPSB7XG4gICAgICBsZWZ0OiBmYWxzZSxcbiAgICAgIHJpZ2h0OiBmYWxzZSxcbiAgICAgIHRvcDogZmFsc2UsXG4gICAgICBib3R0b206IGZhbHNlXG4gICAgfTtcblxuICAgIGZvciAoY29uc3QgZWRnZSBpbiByZXNpemVFZGdlcykge1xuICAgICAgcmVzaXplRWRnZXNbZWRnZV0gPSBjaGVja1Jlc2l6ZUVkZ2UoZWRnZSwgcmVzaXplT3B0aW9ucy5lZGdlc1tlZGdlXSwgcGFnZSwgaW50ZXJhY3Rpb24uX2xhdGVzdFBvaW50ZXIuZXZlbnRUYXJnZXQsIGVsZW1lbnQsIHJlY3QsIHJlc2l6ZU9wdGlvbnMubWFyZ2luIHx8IHJlc2l6ZS5kZWZhdWx0TWFyZ2luKTtcbiAgICB9XG5cbiAgICByZXNpemVFZGdlcy5sZWZ0ID0gcmVzaXplRWRnZXMubGVmdCAmJiAhcmVzaXplRWRnZXMucmlnaHQ7XG4gICAgcmVzaXplRWRnZXMudG9wID0gcmVzaXplRWRnZXMudG9wICYmICFyZXNpemVFZGdlcy5ib3R0b207XG5cbiAgICBpZiAocmVzaXplRWRnZXMubGVmdCB8fCByZXNpemVFZGdlcy5yaWdodCB8fCByZXNpemVFZGdlcy50b3AgfHwgcmVzaXplRWRnZXMuYm90dG9tKSB7XG4gICAgICBhcmcuYWN0aW9uID0ge1xuICAgICAgICBuYW1lOiAncmVzaXplJyxcbiAgICAgICAgZWRnZXM6IHJlc2l6ZUVkZ2VzXG4gICAgICB9O1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBjb25zdCByaWdodCA9IHJlc2l6ZU9wdGlvbnMuYXhpcyAhPT0gJ3knICYmIHBhZ2UueCA+IHJlY3QucmlnaHQgLSByZXNpemUuZGVmYXVsdE1hcmdpbjtcbiAgICBjb25zdCBib3R0b20gPSByZXNpemVPcHRpb25zLmF4aXMgIT09ICd4JyAmJiBwYWdlLnkgPiByZWN0LmJvdHRvbSAtIHJlc2l6ZS5kZWZhdWx0TWFyZ2luO1xuXG4gICAgaWYgKHJpZ2h0IHx8IGJvdHRvbSkge1xuICAgICAgYXJnLmFjdGlvbiA9IHtcbiAgICAgICAgbmFtZTogJ3Jlc2l6ZScsXG4gICAgICAgIGF4ZXM6IChyaWdodCA/ICd4JyA6ICcnKSArIChib3R0b20gPyAneScgOiAnJylcbiAgICAgIH07XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGFyZy5hY3Rpb24gPyBmYWxzZSA6IHVuZGVmaW5lZDtcbn1cblxuZnVuY3Rpb24gcmVzaXphYmxlKGludGVyYWN0YWJsZSwgb3B0aW9ucywgc2NvcGUpIHtcbiAgaWYgKGlzLm9iamVjdChvcHRpb25zKSkge1xuICAgIGludGVyYWN0YWJsZS5vcHRpb25zLnJlc2l6ZS5lbmFibGVkID0gb3B0aW9ucy5lbmFibGVkICE9PSBmYWxzZTtcbiAgICBpbnRlcmFjdGFibGUuc2V0UGVyQWN0aW9uKCdyZXNpemUnLCBvcHRpb25zKTtcbiAgICBpbnRlcmFjdGFibGUuc2V0T25FdmVudHMoJ3Jlc2l6ZScsIG9wdGlvbnMpO1xuXG4gICAgaWYgKGlzLnN0cmluZyhvcHRpb25zLmF4aXMpICYmIC9eeCR8XnkkfF54eSQvLnRlc3Qob3B0aW9ucy5heGlzKSkge1xuICAgICAgaW50ZXJhY3RhYmxlLm9wdGlvbnMucmVzaXplLmF4aXMgPSBvcHRpb25zLmF4aXM7XG4gICAgfSBlbHNlIGlmIChvcHRpb25zLmF4aXMgPT09IG51bGwpIHtcbiAgICAgIGludGVyYWN0YWJsZS5vcHRpb25zLnJlc2l6ZS5heGlzID0gc2NvcGUuZGVmYXVsdHMuYWN0aW9ucy5yZXNpemUuYXhpcztcbiAgICB9XG5cbiAgICBpZiAoaXMuYm9vbChvcHRpb25zLnByZXNlcnZlQXNwZWN0UmF0aW8pKSB7XG4gICAgICBpbnRlcmFjdGFibGUub3B0aW9ucy5yZXNpemUucHJlc2VydmVBc3BlY3RSYXRpbyA9IG9wdGlvbnMucHJlc2VydmVBc3BlY3RSYXRpbztcbiAgICB9IGVsc2UgaWYgKGlzLmJvb2wob3B0aW9ucy5zcXVhcmUpKSB7XG4gICAgICBpbnRlcmFjdGFibGUub3B0aW9ucy5yZXNpemUuc3F1YXJlID0gb3B0aW9ucy5zcXVhcmU7XG4gICAgfVxuXG4gICAgcmV0dXJuIGludGVyYWN0YWJsZTtcbiAgfVxuXG4gIGlmIChpcy5ib29sKG9wdGlvbnMpKSB7XG4gICAgaW50ZXJhY3RhYmxlLm9wdGlvbnMucmVzaXplLmVuYWJsZWQgPSBvcHRpb25zO1xuICAgIHJldHVybiBpbnRlcmFjdGFibGU7XG4gIH1cblxuICByZXR1cm4gaW50ZXJhY3RhYmxlLm9wdGlvbnMucmVzaXplO1xufVxuXG5mdW5jdGlvbiBjaGVja1Jlc2l6ZUVkZ2UobmFtZSwgdmFsdWUsIHBhZ2UsIGVsZW1lbnQsIGludGVyYWN0YWJsZUVsZW1lbnQsIHJlY3QsIG1hcmdpbikge1xuICAvLyBmYWxzZSwgJycsIHVuZGVmaW5lZCwgbnVsbFxuICBpZiAoIXZhbHVlKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9IC8vIHRydWUgdmFsdWUsIHVzZSBwb2ludGVyIGNvb3JkcyBhbmQgZWxlbWVudCByZWN0XG5cblxuICBpZiAodmFsdWUgPT09IHRydWUpIHtcbiAgICAvLyBpZiBkaW1lbnNpb25zIGFyZSBuZWdhdGl2ZSwgXCJzd2l0Y2hcIiBlZGdlc1xuICAgIGNvbnN0IHdpZHRoID0gaXMubnVtYmVyKHJlY3Qud2lkdGgpID8gcmVjdC53aWR0aCA6IHJlY3QucmlnaHQgLSByZWN0LmxlZnQ7XG4gICAgY29uc3QgaGVpZ2h0ID0gaXMubnVtYmVyKHJlY3QuaGVpZ2h0KSA/IHJlY3QuaGVpZ2h0IDogcmVjdC5ib3R0b20gLSByZWN0LnRvcDsgLy8gZG9uJ3QgdXNlIG1hcmdpbiBncmVhdGVyIHRoYW4gaGFsZiB0aGUgcmVsZXZlbnQgZGltZW5zaW9uXG5cbiAgICBtYXJnaW4gPSBNYXRoLm1pbihtYXJnaW4sIE1hdGguYWJzKChuYW1lID09PSAnbGVmdCcgfHwgbmFtZSA9PT0gJ3JpZ2h0JyA/IHdpZHRoIDogaGVpZ2h0KSAvIDIpKTtcblxuICAgIGlmICh3aWR0aCA8IDApIHtcbiAgICAgIGlmIChuYW1lID09PSAnbGVmdCcpIHtcbiAgICAgICAgbmFtZSA9ICdyaWdodCc7XG4gICAgICB9IGVsc2UgaWYgKG5hbWUgPT09ICdyaWdodCcpIHtcbiAgICAgICAgbmFtZSA9ICdsZWZ0JztcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoaGVpZ2h0IDwgMCkge1xuICAgICAgaWYgKG5hbWUgPT09ICd0b3AnKSB7XG4gICAgICAgIG5hbWUgPSAnYm90dG9tJztcbiAgICAgIH0gZWxzZSBpZiAobmFtZSA9PT0gJ2JvdHRvbScpIHtcbiAgICAgICAgbmFtZSA9ICd0b3AnO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChuYW1lID09PSAnbGVmdCcpIHtcbiAgICAgIHJldHVybiBwYWdlLnggPCAod2lkdGggPj0gMCA/IHJlY3QubGVmdCA6IHJlY3QucmlnaHQpICsgbWFyZ2luO1xuICAgIH1cblxuICAgIGlmIChuYW1lID09PSAndG9wJykge1xuICAgICAgcmV0dXJuIHBhZ2UueSA8IChoZWlnaHQgPj0gMCA/IHJlY3QudG9wIDogcmVjdC5ib3R0b20pICsgbWFyZ2luO1xuICAgIH1cblxuICAgIGlmIChuYW1lID09PSAncmlnaHQnKSB7XG4gICAgICByZXR1cm4gcGFnZS54ID4gKHdpZHRoID49IDAgPyByZWN0LnJpZ2h0IDogcmVjdC5sZWZ0KSAtIG1hcmdpbjtcbiAgICB9XG5cbiAgICBpZiAobmFtZSA9PT0gJ2JvdHRvbScpIHtcbiAgICAgIHJldHVybiBwYWdlLnkgPiAoaGVpZ2h0ID49IDAgPyByZWN0LmJvdHRvbSA6IHJlY3QudG9wKSAtIG1hcmdpbjtcbiAgICB9XG4gIH0gLy8gdGhlIHJlbWFpbmluZyBjaGVja3MgcmVxdWlyZSBhbiBlbGVtZW50XG5cblxuICBpZiAoIWlzLmVsZW1lbnQoZWxlbWVudCkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICByZXR1cm4gaXMuZWxlbWVudCh2YWx1ZSkgLy8gdGhlIHZhbHVlIGlzIGFuIGVsZW1lbnQgdG8gdXNlIGFzIGEgcmVzaXplIGhhbmRsZVxuICA/IHZhbHVlID09PSBlbGVtZW50IC8vIG90aGVyd2lzZSBjaGVjayBpZiBlbGVtZW50IG1hdGNoZXMgdmFsdWUgYXMgc2VsZWN0b3JcbiAgOiBtYXRjaGVzVXBUbyhlbGVtZW50LCB2YWx1ZSwgaW50ZXJhY3RhYmxlRWxlbWVudCk7XG59XG4vKiBlc2xpbnQtZGlzYWJsZSBtdWx0aWxpbmUtdGVybmFyeSAqL1xuXG5cbmZ1bmN0aW9uIGluaXRDdXJzb3JzKGJyb3dzZXIpIHtcbiAgcmV0dXJuIGJyb3dzZXIuaXNJZTkgPyB7XG4gICAgeDogJ2UtcmVzaXplJyxcbiAgICB5OiAncy1yZXNpemUnLFxuICAgIHh5OiAnc2UtcmVzaXplJyxcbiAgICB0b3A6ICduLXJlc2l6ZScsXG4gICAgbGVmdDogJ3ctcmVzaXplJyxcbiAgICBib3R0b206ICdzLXJlc2l6ZScsXG4gICAgcmlnaHQ6ICdlLXJlc2l6ZScsXG4gICAgdG9wbGVmdDogJ3NlLXJlc2l6ZScsXG4gICAgYm90dG9tcmlnaHQ6ICdzZS1yZXNpemUnLFxuICAgIHRvcHJpZ2h0OiAnbmUtcmVzaXplJyxcbiAgICBib3R0b21sZWZ0OiAnbmUtcmVzaXplJ1xuICB9IDoge1xuICAgIHg6ICdldy1yZXNpemUnLFxuICAgIHk6ICducy1yZXNpemUnLFxuICAgIHh5OiAnbndzZS1yZXNpemUnLFxuICAgIHRvcDogJ25zLXJlc2l6ZScsXG4gICAgbGVmdDogJ2V3LXJlc2l6ZScsXG4gICAgYm90dG9tOiAnbnMtcmVzaXplJyxcbiAgICByaWdodDogJ2V3LXJlc2l6ZScsXG4gICAgdG9wbGVmdDogJ253c2UtcmVzaXplJyxcbiAgICBib3R0b21yaWdodDogJ253c2UtcmVzaXplJyxcbiAgICB0b3ByaWdodDogJ25lc3ctcmVzaXplJyxcbiAgICBib3R0b21sZWZ0OiAnbmVzdy1yZXNpemUnXG4gIH07XG59XG4vKiBlc2xpbnQtZW5hYmxlIG11bHRpbGluZS10ZXJuYXJ5ICovXG5cblxuZnVuY3Rpb24gc3RhcnQoe1xuICBpRXZlbnQsXG4gIGludGVyYWN0aW9uXG59KSB7XG4gIGlmIChpbnRlcmFjdGlvbi5wcmVwYXJlZC5uYW1lICE9PSAncmVzaXplJyB8fCAhaW50ZXJhY3Rpb24ucHJlcGFyZWQuZWRnZXMpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBjb25zdCByZXNpemVFdmVudCA9IGlFdmVudDtcbiAgY29uc3QgcmVjdCA9IGludGVyYWN0aW9uLnJlY3Q7XG4gIGludGVyYWN0aW9uLl9yZWN0cyA9IHtcbiAgICBzdGFydDogZXh0ZW5kKHt9LCByZWN0KSxcbiAgICBjb3JyZWN0ZWQ6IGV4dGVuZCh7fSwgcmVjdCksXG4gICAgcHJldmlvdXM6IGV4dGVuZCh7fSwgcmVjdCksXG4gICAgZGVsdGE6IHtcbiAgICAgIGxlZnQ6IDAsXG4gICAgICByaWdodDogMCxcbiAgICAgIHdpZHRoOiAwLFxuICAgICAgdG9wOiAwLFxuICAgICAgYm90dG9tOiAwLFxuICAgICAgaGVpZ2h0OiAwXG4gICAgfVxuICB9O1xuICByZXNpemVFdmVudC5lZGdlcyA9IGludGVyYWN0aW9uLnByZXBhcmVkLmVkZ2VzO1xuICByZXNpemVFdmVudC5yZWN0ID0gaW50ZXJhY3Rpb24uX3JlY3RzLmNvcnJlY3RlZDtcbiAgcmVzaXplRXZlbnQuZGVsdGFSZWN0ID0gaW50ZXJhY3Rpb24uX3JlY3RzLmRlbHRhO1xufVxuXG5mdW5jdGlvbiBwbHVnaW5fbW92ZSh7XG4gIGlFdmVudCxcbiAgaW50ZXJhY3Rpb25cbn0pIHtcbiAgaWYgKGludGVyYWN0aW9uLnByZXBhcmVkLm5hbWUgIT09ICdyZXNpemUnIHx8ICFpbnRlcmFjdGlvbi5wcmVwYXJlZC5lZGdlcykge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGNvbnN0IHJlc2l6ZUV2ZW50ID0gaUV2ZW50O1xuICBjb25zdCByZXNpemVPcHRpb25zID0gaW50ZXJhY3Rpb24uaW50ZXJhY3RhYmxlLm9wdGlvbnMucmVzaXplO1xuICBjb25zdCBpbnZlcnQgPSByZXNpemVPcHRpb25zLmludmVydDtcbiAgY29uc3QgaW52ZXJ0aWJsZSA9IGludmVydCA9PT0gJ3JlcG9zaXRpb24nIHx8IGludmVydCA9PT0gJ25lZ2F0ZSc7XG4gIGNvbnN0IGN1cnJlbnQgPSBpbnRlcmFjdGlvbi5yZWN0O1xuICBjb25zdCB7XG4gICAgc3RhcnQ6IHN0YXJ0UmVjdCxcbiAgICBjb3JyZWN0ZWQsXG4gICAgZGVsdGE6IGRlbHRhUmVjdCxcbiAgICBwcmV2aW91c1xuICB9ID0gaW50ZXJhY3Rpb24uX3JlY3RzO1xuICBleHRlbmQocHJldmlvdXMsIGNvcnJlY3RlZCk7XG5cbiAgaWYgKGludmVydGlibGUpIHtcbiAgICAvLyBpZiBpbnZlcnRpYmxlLCBjb3B5IHRoZSBjdXJyZW50IHJlY3RcbiAgICBleHRlbmQoY29ycmVjdGVkLCBjdXJyZW50KTtcblxuICAgIGlmIChpbnZlcnQgPT09ICdyZXBvc2l0aW9uJykge1xuICAgICAgLy8gc3dhcCBlZGdlIHZhbHVlcyBpZiBuZWNlc3NhcnkgdG8ga2VlcCB3aWR0aC9oZWlnaHQgcG9zaXRpdmVcbiAgICAgIGlmIChjb3JyZWN0ZWQudG9wID4gY29ycmVjdGVkLmJvdHRvbSkge1xuICAgICAgICBjb25zdCBzd2FwID0gY29ycmVjdGVkLnRvcDtcbiAgICAgICAgY29ycmVjdGVkLnRvcCA9IGNvcnJlY3RlZC5ib3R0b207XG4gICAgICAgIGNvcnJlY3RlZC5ib3R0b20gPSBzd2FwO1xuICAgICAgfVxuXG4gICAgICBpZiAoY29ycmVjdGVkLmxlZnQgPiBjb3JyZWN0ZWQucmlnaHQpIHtcbiAgICAgICAgY29uc3Qgc3dhcCA9IGNvcnJlY3RlZC5sZWZ0O1xuICAgICAgICBjb3JyZWN0ZWQubGVmdCA9IGNvcnJlY3RlZC5yaWdodDtcbiAgICAgICAgY29ycmVjdGVkLnJpZ2h0ID0gc3dhcDtcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgLy8gaWYgbm90IGludmVydGlibGUsIHJlc3RyaWN0IHRvIG1pbmltdW0gb2YgMHgwIHJlY3RcbiAgICBjb3JyZWN0ZWQudG9wID0gTWF0aC5taW4oY3VycmVudC50b3AsIHN0YXJ0UmVjdC5ib3R0b20pO1xuICAgIGNvcnJlY3RlZC5ib3R0b20gPSBNYXRoLm1heChjdXJyZW50LmJvdHRvbSwgc3RhcnRSZWN0LnRvcCk7XG4gICAgY29ycmVjdGVkLmxlZnQgPSBNYXRoLm1pbihjdXJyZW50LmxlZnQsIHN0YXJ0UmVjdC5yaWdodCk7XG4gICAgY29ycmVjdGVkLnJpZ2h0ID0gTWF0aC5tYXgoY3VycmVudC5yaWdodCwgc3RhcnRSZWN0LmxlZnQpO1xuICB9XG5cbiAgY29ycmVjdGVkLndpZHRoID0gY29ycmVjdGVkLnJpZ2h0IC0gY29ycmVjdGVkLmxlZnQ7XG4gIGNvcnJlY3RlZC5oZWlnaHQgPSBjb3JyZWN0ZWQuYm90dG9tIC0gY29ycmVjdGVkLnRvcDtcblxuICBmb3IgKGNvbnN0IGVkZ2UgaW4gY29ycmVjdGVkKSB7XG4gICAgZGVsdGFSZWN0W2VkZ2VdID0gY29ycmVjdGVkW2VkZ2VdIC0gcHJldmlvdXNbZWRnZV07XG4gIH1cblxuICByZXNpemVFdmVudC5lZGdlcyA9IGludGVyYWN0aW9uLnByZXBhcmVkLmVkZ2VzO1xuICByZXNpemVFdmVudC5yZWN0ID0gY29ycmVjdGVkO1xuICByZXNpemVFdmVudC5kZWx0YVJlY3QgPSBkZWx0YVJlY3Q7XG59XG5cbmZ1bmN0aW9uIGVuZCh7XG4gIGlFdmVudCxcbiAgaW50ZXJhY3Rpb25cbn0pIHtcbiAgaWYgKGludGVyYWN0aW9uLnByZXBhcmVkLm5hbWUgIT09ICdyZXNpemUnIHx8ICFpbnRlcmFjdGlvbi5wcmVwYXJlZC5lZGdlcykge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGNvbnN0IHJlc2l6ZUV2ZW50ID0gaUV2ZW50O1xuICByZXNpemVFdmVudC5lZGdlcyA9IGludGVyYWN0aW9uLnByZXBhcmVkLmVkZ2VzO1xuICByZXNpemVFdmVudC5yZWN0ID0gaW50ZXJhY3Rpb24uX3JlY3RzLmNvcnJlY3RlZDtcbiAgcmVzaXplRXZlbnQuZGVsdGFSZWN0ID0gaW50ZXJhY3Rpb24uX3JlY3RzLmRlbHRhO1xufVxuXG5mdW5jdGlvbiB1cGRhdGVFdmVudEF4ZXMoe1xuICBpRXZlbnQsXG4gIGludGVyYWN0aW9uXG59KSB7XG4gIGlmIChpbnRlcmFjdGlvbi5wcmVwYXJlZC5uYW1lICE9PSAncmVzaXplJyB8fCAhaW50ZXJhY3Rpb24ucmVzaXplQXhlcykge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGNvbnN0IG9wdGlvbnMgPSBpbnRlcmFjdGlvbi5pbnRlcmFjdGFibGUub3B0aW9ucztcbiAgY29uc3QgcmVzaXplRXZlbnQgPSBpRXZlbnQ7XG5cbiAgaWYgKG9wdGlvbnMucmVzaXplLnNxdWFyZSkge1xuICAgIGlmIChpbnRlcmFjdGlvbi5yZXNpemVBeGVzID09PSAneScpIHtcbiAgICAgIHJlc2l6ZUV2ZW50LmRlbHRhLnggPSByZXNpemVFdmVudC5kZWx0YS55O1xuICAgIH0gZWxzZSB7XG4gICAgICByZXNpemVFdmVudC5kZWx0YS55ID0gcmVzaXplRXZlbnQuZGVsdGEueDtcbiAgICB9XG5cbiAgICByZXNpemVFdmVudC5heGVzID0gJ3h5JztcbiAgfSBlbHNlIHtcbiAgICByZXNpemVFdmVudC5heGVzID0gaW50ZXJhY3Rpb24ucmVzaXplQXhlcztcblxuICAgIGlmIChpbnRlcmFjdGlvbi5yZXNpemVBeGVzID09PSAneCcpIHtcbiAgICAgIHJlc2l6ZUV2ZW50LmRlbHRhLnkgPSAwO1xuICAgIH0gZWxzZSBpZiAoaW50ZXJhY3Rpb24ucmVzaXplQXhlcyA9PT0gJ3knKSB7XG4gICAgICByZXNpemVFdmVudC5kZWx0YS54ID0gMDtcbiAgICB9XG4gIH1cbn1cblxuY29uc3QgcmVzaXplID0ge1xuICBpZDogJ2FjdGlvbnMvcmVzaXplJyxcbiAgYmVmb3JlOiBbJ2FjdGlvbnMvZHJhZyddLFxuICBpbnN0YWxsOiByZXNpemVfcGx1Z2luX2luc3RhbGwsXG4gIGxpc3RlbmVyczoge1xuICAgICdpbnRlcmFjdGlvbnM6bmV3JzogKHtcbiAgICAgIGludGVyYWN0aW9uXG4gICAgfSkgPT4ge1xuICAgICAgaW50ZXJhY3Rpb24ucmVzaXplQXhlcyA9ICd4eSc7XG4gICAgfSxcbiAgICAnaW50ZXJhY3Rpb25zOmFjdGlvbi1zdGFydCc6IGFyZyA9PiB7XG4gICAgICBzdGFydChhcmcpO1xuICAgICAgdXBkYXRlRXZlbnRBeGVzKGFyZyk7XG4gICAgfSxcbiAgICAnaW50ZXJhY3Rpb25zOmFjdGlvbi1tb3ZlJzogYXJnID0+IHtcbiAgICAgIHBsdWdpbl9tb3ZlKGFyZyk7XG4gICAgICB1cGRhdGVFdmVudEF4ZXMoYXJnKTtcbiAgICB9LFxuICAgICdpbnRlcmFjdGlvbnM6YWN0aW9uLWVuZCc6IGVuZCxcbiAgICAnYXV0by1zdGFydDpjaGVjayc6IHJlc2l6ZUNoZWNrZXJcbiAgfSxcbiAgZGVmYXVsdHM6IHtcbiAgICBzcXVhcmU6IGZhbHNlLFxuICAgIHByZXNlcnZlQXNwZWN0UmF0aW86IGZhbHNlLFxuICAgIGF4aXM6ICd4eScsXG4gICAgLy8gdXNlIGRlZmF1bHQgbWFyZ2luXG4gICAgbWFyZ2luOiBOYU4sXG4gICAgLy8gb2JqZWN0IHdpdGggcHJvcHMgbGVmdCwgcmlnaHQsIHRvcCwgYm90dG9tIHdoaWNoIGFyZVxuICAgIC8vIHRydWUvZmFsc2UgdmFsdWVzIHRvIHJlc2l6ZSB3aGVuIHRoZSBwb2ludGVyIGlzIG92ZXIgdGhhdCBlZGdlLFxuICAgIC8vIENTUyBzZWxlY3RvcnMgdG8gbWF0Y2ggdGhlIGhhbmRsZXMgZm9yIGVhY2ggZGlyZWN0aW9uXG4gICAgLy8gb3IgdGhlIEVsZW1lbnRzIGZvciBlYWNoIGhhbmRsZVxuICAgIGVkZ2VzOiBudWxsLFxuICAgIC8vIGEgdmFsdWUgb2YgJ25vbmUnIHdpbGwgbGltaXQgdGhlIHJlc2l6ZSByZWN0IHRvIGEgbWluaW11bSBvZiAweDBcbiAgICAvLyAnbmVnYXRlJyB3aWxsIGFsb3cgdGhlIHJlY3QgdG8gaGF2ZSBuZWdhdGl2ZSB3aWR0aC9oZWlnaHRcbiAgICAvLyAncmVwb3NpdGlvbicgd2lsbCBrZWVwIHRoZSB3aWR0aC9oZWlnaHQgcG9zaXRpdmUgYnkgc3dhcHBpbmdcbiAgICAvLyB0aGUgdG9wIGFuZCBib3R0b20gZWRnZXMgYW5kL29yIHN3YXBwaW5nIHRoZSBsZWZ0IGFuZCByaWdodCBlZGdlc1xuICAgIGludmVydDogJ25vbmUnXG4gIH0sXG4gIGN1cnNvcnM6IG51bGwsXG5cbiAgZ2V0Q3Vyc29yKHtcbiAgICBlZGdlcyxcbiAgICBheGlzLFxuICAgIG5hbWVcbiAgfSkge1xuICAgIGNvbnN0IGN1cnNvcnMgPSByZXNpemUuY3Vyc29ycztcbiAgICBsZXQgcmVzdWx0ID0gbnVsbDtcblxuICAgIGlmIChheGlzKSB7XG4gICAgICByZXN1bHQgPSBjdXJzb3JzW25hbWUgKyBheGlzXTtcbiAgICB9IGVsc2UgaWYgKGVkZ2VzKSB7XG4gICAgICBsZXQgY3Vyc29yS2V5ID0gJyc7XG5cbiAgICAgIGZvciAoY29uc3QgZWRnZSBvZiBbJ3RvcCcsICdib3R0b20nLCAnbGVmdCcsICdyaWdodCddKSB7XG4gICAgICAgIGlmIChlZGdlc1tlZGdlXSkge1xuICAgICAgICAgIGN1cnNvcktleSArPSBlZGdlO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJlc3VsdCA9IGN1cnNvcnNbY3Vyc29yS2V5XTtcbiAgICB9XG5cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9LFxuXG4gIGRlZmF1bHRNYXJnaW46IG51bGxcbn07XG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIHZhciByZXNpemVfcGx1Z2luID0gKHJlc2l6ZSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1wbHVnaW4uanMubWFwXG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL25vZGVfbW9kdWxlcy9AaW50ZXJhY3Rqcy9hY3Rpb25zL3Jlc2l6ZS9pbmRleC5qc1xuLyogZXNsaW50LWRpc2FibGUgaW1wb3J0L29yZGVyLCBuby1jb25zb2xlLCBlb2wtbGFzdCAqL1xuXG5cblxuaWYgKHR5cGVvZiB3aW5kb3cgPT09ICdvYmplY3QnICYmICEhd2luZG93KSB7XG4gIGludGVyYWN0X2luaXQod2luZG93KTtcbn1cblxuX2ludGVyYWN0anNfaW50ZXJhY3QudXNlKHJlc2l6ZV9wbHVnaW4pO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwXG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL25vZGVfbW9kdWxlcy9AaW50ZXJhY3Rqcy9zbmFwcGVycy9lZGdlVGFyZ2V0LmpzXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIHZhciBlZGdlVGFyZ2V0ID0gKCgpID0+IHt9KTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWVkZ2VUYXJnZXQuanMubWFwXG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL25vZGVfbW9kdWxlcy9AaW50ZXJhY3Rqcy9zbmFwcGVycy9lbGVtZW50cy5qc1xuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyB2YXIgc25hcHBlcnNfZWxlbWVudHMgPSAoKCkgPT4ge30pO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZWxlbWVudHMuanMubWFwXG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL25vZGVfbW9kdWxlcy9AaW50ZXJhY3Rqcy9zbmFwcGVycy9ncmlkLmpzXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIHZhciBncmlkID0gKGdyaWQgPT4ge1xuICBjb25zdCBjb29yZEZpZWxkcyA9IFtbJ3gnLCAneSddLCBbJ2xlZnQnLCAndG9wJ10sIFsncmlnaHQnLCAnYm90dG9tJ10sIFsnd2lkdGgnLCAnaGVpZ2h0J11dLmZpbHRlcigoW3hGaWVsZCwgeUZpZWxkXSkgPT4geEZpZWxkIGluIGdyaWQgfHwgeUZpZWxkIGluIGdyaWQpO1xuXG4gIGNvbnN0IGdyaWRGdW5jID0gKHgsIHkpID0+IHtcbiAgICBjb25zdCB7XG4gICAgICByYW5nZSxcbiAgICAgIGxpbWl0cyA9IHtcbiAgICAgICAgbGVmdDogLUluZmluaXR5LFxuICAgICAgICByaWdodDogSW5maW5pdHksXG4gICAgICAgIHRvcDogLUluZmluaXR5LFxuICAgICAgICBib3R0b206IEluZmluaXR5XG4gICAgICB9LFxuICAgICAgb2Zmc2V0ID0ge1xuICAgICAgICB4OiAwLFxuICAgICAgICB5OiAwXG4gICAgICB9XG4gICAgfSA9IGdyaWQ7XG4gICAgY29uc3QgcmVzdWx0ID0ge1xuICAgICAgcmFuZ2UsXG4gICAgICBncmlkLFxuICAgICAgeDogbnVsbCxcbiAgICAgIHk6IG51bGxcbiAgICB9O1xuXG4gICAgZm9yIChjb25zdCBbeEZpZWxkLCB5RmllbGRdIG9mIGNvb3JkRmllbGRzKSB7XG4gICAgICBjb25zdCBncmlkeCA9IE1hdGgucm91bmQoKHggLSBvZmZzZXQueCkgLyBncmlkW3hGaWVsZF0pO1xuICAgICAgY29uc3QgZ3JpZHkgPSBNYXRoLnJvdW5kKCh5IC0gb2Zmc2V0LnkpIC8gZ3JpZFt5RmllbGRdKTtcbiAgICAgIHJlc3VsdFt4RmllbGRdID0gTWF0aC5tYXgobGltaXRzLmxlZnQsIE1hdGgubWluKGxpbWl0cy5yaWdodCwgZ3JpZHggKiBncmlkW3hGaWVsZF0gKyBvZmZzZXQueCkpO1xuICAgICAgcmVzdWx0W3lGaWVsZF0gPSBNYXRoLm1heChsaW1pdHMudG9wLCBNYXRoLm1pbihsaW1pdHMuYm90dG9tLCBncmlkeSAqIGdyaWRbeUZpZWxkXSArIG9mZnNldC55KSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfTtcblxuICBncmlkRnVuYy5ncmlkID0gZ3JpZDtcbiAgZ3JpZEZ1bmMuY29vcmRGaWVsZHMgPSBjb29yZEZpZWxkcztcbiAgcmV0dXJuIGdyaWRGdW5jO1xufSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1ncmlkLmpzLm1hcFxuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9ub2RlX21vZHVsZXMvQGludGVyYWN0anMvc25hcHBlcnMvYWxsLmpzXG5cblxuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1hbGwuanMubWFwXG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL25vZGVfbW9kdWxlcy9AaW50ZXJhY3Rqcy9zbmFwcGVycy9wbHVnaW4uanNcblxuXG5jb25zdCBzbmFwcGVyc1BsdWdpbiA9IHtcbiAgaWQ6ICdzbmFwcGVycycsXG5cbiAgaW5zdGFsbChzY29wZSkge1xuICAgIGNvbnN0IHtcbiAgICAgIGludGVyYWN0U3RhdGljOiBpbnRlcmFjdFxuICAgIH0gPSBzY29wZTtcbiAgICBpbnRlcmFjdC5zbmFwcGVycyA9IGV4dGVuZChpbnRlcmFjdC5zbmFwcGVycyB8fCB7fSwgYWxsX25hbWVzcGFjZU9iamVjdCk7XG4gICAgaW50ZXJhY3QuY3JlYXRlU25hcEdyaWQgPSBpbnRlcmFjdC5zbmFwcGVycy5ncmlkO1xuICB9XG5cbn07XG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIHZhciBzbmFwcGVyc19wbHVnaW4gPSAoc25hcHBlcnNQbHVnaW4pO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cGx1Z2luLmpzLm1hcFxuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9ub2RlX21vZHVsZXMvQGludGVyYWN0anMvbW9kaWZpZXJzL01vZGlmaWNhdGlvbi5qc1xuXG5cblxuY2xhc3MgTW9kaWZpY2F0aW9uX01vZGlmaWNhdGlvbiB7XG4gIGNvbnN0cnVjdG9yKGludGVyYWN0aW9uKSB7XG4gICAgdGhpcy5zdGF0ZXMgPSBbXTtcbiAgICB0aGlzLnN0YXJ0T2Zmc2V0ID0ge1xuICAgICAgbGVmdDogMCxcbiAgICAgIHJpZ2h0OiAwLFxuICAgICAgdG9wOiAwLFxuICAgICAgYm90dG9tOiAwXG4gICAgfTtcbiAgICB0aGlzLnN0YXJ0RGVsdGEgPSBudWxsO1xuICAgIHRoaXMucmVzdWx0ID0gbnVsbDtcbiAgICB0aGlzLmVuZFJlc3VsdCA9IG51bGw7XG4gICAgdGhpcy5lZGdlcyA9IHZvaWQgMDtcbiAgICB0aGlzLmludGVyYWN0aW9uID0gdm9pZCAwO1xuICAgIHRoaXMuaW50ZXJhY3Rpb24gPSBpbnRlcmFjdGlvbjtcbiAgICB0aGlzLnJlc3VsdCA9IGNyZWF0ZVJlc3VsdCgpO1xuICB9XG5cbiAgc3RhcnQoe1xuICAgIHBoYXNlXG4gIH0sIHBhZ2VDb29yZHMpIHtcbiAgICBjb25zdCB7XG4gICAgICBpbnRlcmFjdGlvblxuICAgIH0gPSB0aGlzO1xuICAgIGNvbnN0IG1vZGlmaWVyTGlzdCA9IGdldE1vZGlmaWVyTGlzdChpbnRlcmFjdGlvbik7XG4gICAgdGhpcy5wcmVwYXJlU3RhdGVzKG1vZGlmaWVyTGlzdCk7XG4gICAgdGhpcy5lZGdlcyA9IGV4dGVuZCh7fSwgaW50ZXJhY3Rpb24uZWRnZXMpO1xuICAgIHRoaXMuc3RhcnRPZmZzZXQgPSBnZXRSZWN0T2Zmc2V0KGludGVyYWN0aW9uLnJlY3QsIHBhZ2VDb29yZHMpO1xuICAgIHRoaXMuc3RhcnREZWx0YSA9IHtcbiAgICAgIHg6IDAsXG4gICAgICB5OiAwXG4gICAgfTtcbiAgICBjb25zdCBhcmcgPSB7XG4gICAgICBwaGFzZSxcbiAgICAgIHBhZ2VDb29yZHMsXG4gICAgICBwcmVFbmQ6IGZhbHNlXG4gICAgfTtcbiAgICB0aGlzLnJlc3VsdCA9IGNyZWF0ZVJlc3VsdCgpO1xuICAgIHRoaXMuc3RhcnRBbGwoYXJnKTtcbiAgICBjb25zdCByZXN1bHQgPSB0aGlzLnJlc3VsdCA9IHRoaXMuc2V0QWxsKGFyZyk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIGZpbGxBcmcoYXJnKSB7XG4gICAgY29uc3Qge1xuICAgICAgaW50ZXJhY3Rpb25cbiAgICB9ID0gdGhpcztcbiAgICBhcmcuaW50ZXJhY3Rpb24gPSBpbnRlcmFjdGlvbjtcbiAgICBhcmcuaW50ZXJhY3RhYmxlID0gaW50ZXJhY3Rpb24uaW50ZXJhY3RhYmxlO1xuICAgIGFyZy5lbGVtZW50ID0gaW50ZXJhY3Rpb24uZWxlbWVudDtcbiAgICBhcmcucmVjdCA9IGFyZy5yZWN0IHx8IGludGVyYWN0aW9uLnJlY3Q7XG4gICAgYXJnLmVkZ2VzID0gdGhpcy5lZGdlcztcbiAgICBhcmcuc3RhcnRPZmZzZXQgPSB0aGlzLnN0YXJ0T2Zmc2V0O1xuICB9XG5cbiAgc3RhcnRBbGwoYXJnKSB7XG4gICAgdGhpcy5maWxsQXJnKGFyZyk7XG5cbiAgICBmb3IgKGNvbnN0IHN0YXRlIG9mIHRoaXMuc3RhdGVzKSB7XG4gICAgICBpZiAoc3RhdGUubWV0aG9kcy5zdGFydCkge1xuICAgICAgICBhcmcuc3RhdGUgPSBzdGF0ZTtcbiAgICAgICAgc3RhdGUubWV0aG9kcy5zdGFydChhcmcpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHNldEFsbChhcmcpIHtcbiAgICB0aGlzLmZpbGxBcmcoYXJnKTtcbiAgICBjb25zdCB7XG4gICAgICBwaGFzZSxcbiAgICAgIHByZUVuZCxcbiAgICAgIHNraXBNb2RpZmllcnMsXG4gICAgICByZWN0OiB1bm1vZGlmaWVkUmVjdFxuICAgIH0gPSBhcmc7XG4gICAgYXJnLmNvb3JkcyA9IGV4dGVuZCh7fSwgYXJnLnBhZ2VDb29yZHMpO1xuICAgIGFyZy5yZWN0ID0gZXh0ZW5kKHt9LCB1bm1vZGlmaWVkUmVjdCk7XG4gICAgY29uc3Qgc3RhdGVzID0gc2tpcE1vZGlmaWVycyA/IHRoaXMuc3RhdGVzLnNsaWNlKHNraXBNb2RpZmllcnMpIDogdGhpcy5zdGF0ZXM7XG4gICAgY29uc3QgbmV3UmVzdWx0ID0gY3JlYXRlUmVzdWx0KGFyZy5jb29yZHMsIGFyZy5yZWN0KTtcblxuICAgIGZvciAoY29uc3Qgc3RhdGUgb2Ygc3RhdGVzKSB7XG4gICAgICBjb25zdCB7XG4gICAgICAgIG9wdGlvbnNcbiAgICAgIH0gPSBzdGF0ZTtcbiAgICAgIGNvbnN0IGxhc3RNb2RpZmllckNvb3JkcyA9IGV4dGVuZCh7fSwgYXJnLmNvb3Jkcyk7XG4gICAgICBsZXQgcmV0dXJuVmFsdWUgPSBudWxsO1xuXG4gICAgICBpZiAoc3RhdGUubWV0aG9kcy5zZXQgJiYgdGhpcy5zaG91bGREbyhvcHRpb25zLCBwcmVFbmQsIHBoYXNlKSkge1xuICAgICAgICBhcmcuc3RhdGUgPSBzdGF0ZTtcbiAgICAgICAgcmV0dXJuVmFsdWUgPSBzdGF0ZS5tZXRob2RzLnNldChhcmcpO1xuICAgICAgICBhZGRFZGdlcyh0aGlzLmludGVyYWN0aW9uLmVkZ2VzLCBhcmcucmVjdCwge1xuICAgICAgICAgIHg6IGFyZy5jb29yZHMueCAtIGxhc3RNb2RpZmllckNvb3Jkcy54LFxuICAgICAgICAgIHk6IGFyZy5jb29yZHMueSAtIGxhc3RNb2RpZmllckNvb3Jkcy55XG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICBuZXdSZXN1bHQuZXZlbnRQcm9wcy5wdXNoKHJldHVyblZhbHVlKTtcbiAgICB9XG5cbiAgICBuZXdSZXN1bHQuZGVsdGEueCA9IGFyZy5jb29yZHMueCAtIGFyZy5wYWdlQ29vcmRzLng7XG4gICAgbmV3UmVzdWx0LmRlbHRhLnkgPSBhcmcuY29vcmRzLnkgLSBhcmcucGFnZUNvb3Jkcy55O1xuICAgIG5ld1Jlc3VsdC5yZWN0RGVsdGEubGVmdCA9IGFyZy5yZWN0LmxlZnQgLSB1bm1vZGlmaWVkUmVjdC5sZWZ0O1xuICAgIG5ld1Jlc3VsdC5yZWN0RGVsdGEucmlnaHQgPSBhcmcucmVjdC5yaWdodCAtIHVubW9kaWZpZWRSZWN0LnJpZ2h0O1xuICAgIG5ld1Jlc3VsdC5yZWN0RGVsdGEudG9wID0gYXJnLnJlY3QudG9wIC0gdW5tb2RpZmllZFJlY3QudG9wO1xuICAgIG5ld1Jlc3VsdC5yZWN0RGVsdGEuYm90dG9tID0gYXJnLnJlY3QuYm90dG9tIC0gdW5tb2RpZmllZFJlY3QuYm90dG9tO1xuICAgIGNvbnN0IHByZXZDb29yZHMgPSB0aGlzLnJlc3VsdC5jb29yZHM7XG4gICAgY29uc3QgcHJldlJlY3QgPSB0aGlzLnJlc3VsdC5yZWN0O1xuXG4gICAgaWYgKHByZXZDb29yZHMgJiYgcHJldlJlY3QpIHtcbiAgICAgIGNvbnN0IHJlY3RDaGFuZ2VkID0gbmV3UmVzdWx0LnJlY3QubGVmdCAhPT0gcHJldlJlY3QubGVmdCB8fCBuZXdSZXN1bHQucmVjdC5yaWdodCAhPT0gcHJldlJlY3QucmlnaHQgfHwgbmV3UmVzdWx0LnJlY3QudG9wICE9PSBwcmV2UmVjdC50b3AgfHwgbmV3UmVzdWx0LnJlY3QuYm90dG9tICE9PSBwcmV2UmVjdC5ib3R0b207XG4gICAgICBuZXdSZXN1bHQuY2hhbmdlZCA9IHJlY3RDaGFuZ2VkIHx8IHByZXZDb29yZHMueCAhPT0gbmV3UmVzdWx0LmNvb3Jkcy54IHx8IHByZXZDb29yZHMueSAhPT0gbmV3UmVzdWx0LmNvb3Jkcy55O1xuICAgIH1cblxuICAgIHJldHVybiBuZXdSZXN1bHQ7XG4gIH1cblxuICBhcHBseVRvSW50ZXJhY3Rpb24oYXJnKSB7XG4gICAgY29uc3Qge1xuICAgICAgaW50ZXJhY3Rpb25cbiAgICB9ID0gdGhpcztcbiAgICBjb25zdCB7XG4gICAgICBwaGFzZVxuICAgIH0gPSBhcmc7XG4gICAgY29uc3QgY3VyQ29vcmRzID0gaW50ZXJhY3Rpb24uY29vcmRzLmN1cjtcbiAgICBjb25zdCBzdGFydENvb3JkcyA9IGludGVyYWN0aW9uLmNvb3Jkcy5zdGFydDtcbiAgICBjb25zdCB7XG4gICAgICByZXN1bHQsXG4gICAgICBzdGFydERlbHRhXG4gICAgfSA9IHRoaXM7XG4gICAgY29uc3QgY3VyRGVsdGEgPSByZXN1bHQuZGVsdGE7XG5cbiAgICBpZiAocGhhc2UgPT09ICdzdGFydCcpIHtcbiAgICAgIGV4dGVuZCh0aGlzLnN0YXJ0RGVsdGEsIHJlc3VsdC5kZWx0YSk7XG4gICAgfVxuXG4gICAgZm9yIChjb25zdCBbY29vcmRzU2V0LCBkZWx0YV0gb2YgW1tzdGFydENvb3Jkcywgc3RhcnREZWx0YV0sIFtjdXJDb29yZHMsIGN1ckRlbHRhXV0pIHtcbiAgICAgIGNvb3Jkc1NldC5wYWdlLnggKz0gZGVsdGEueDtcbiAgICAgIGNvb3Jkc1NldC5wYWdlLnkgKz0gZGVsdGEueTtcbiAgICAgIGNvb3Jkc1NldC5jbGllbnQueCArPSBkZWx0YS54O1xuICAgICAgY29vcmRzU2V0LmNsaWVudC55ICs9IGRlbHRhLnk7XG4gICAgfVxuXG4gICAgY29uc3Qge1xuICAgICAgcmVjdERlbHRhXG4gICAgfSA9IHRoaXMucmVzdWx0O1xuICAgIGNvbnN0IHJlY3QgPSBhcmcucmVjdCB8fCBpbnRlcmFjdGlvbi5yZWN0O1xuICAgIHJlY3QubGVmdCArPSByZWN0RGVsdGEubGVmdDtcbiAgICByZWN0LnJpZ2h0ICs9IHJlY3REZWx0YS5yaWdodDtcbiAgICByZWN0LnRvcCArPSByZWN0RGVsdGEudG9wO1xuICAgIHJlY3QuYm90dG9tICs9IHJlY3REZWx0YS5ib3R0b207XG4gICAgcmVjdC53aWR0aCA9IHJlY3QucmlnaHQgLSByZWN0LmxlZnQ7XG4gICAgcmVjdC5oZWlnaHQgPSByZWN0LmJvdHRvbSAtIHJlY3QudG9wO1xuICB9XG5cbiAgc2V0QW5kQXBwbHkoYXJnKSB7XG4gICAgY29uc3Qge1xuICAgICAgaW50ZXJhY3Rpb25cbiAgICB9ID0gdGhpcztcbiAgICBjb25zdCB7XG4gICAgICBwaGFzZSxcbiAgICAgIHByZUVuZCxcbiAgICAgIHNraXBNb2RpZmllcnNcbiAgICB9ID0gYXJnO1xuICAgIGNvbnN0IHJlc3VsdCA9IHRoaXMuc2V0QWxsKHtcbiAgICAgIHByZUVuZCxcbiAgICAgIHBoYXNlLFxuICAgICAgcGFnZUNvb3JkczogYXJnLm1vZGlmaWVkQ29vcmRzIHx8IGludGVyYWN0aW9uLmNvb3Jkcy5jdXIucGFnZVxuICAgIH0pO1xuICAgIHRoaXMucmVzdWx0ID0gcmVzdWx0OyAvLyBkb24ndCBmaXJlIGFuIGFjdGlvbiBtb3ZlIGlmIGEgbW9kaWZpZXIgd291bGQga2VlcCB0aGUgZXZlbnQgaW4gdGhlIHNhbWVcbiAgICAvLyBjb3JkaW5hdGVzIGFzIGJlZm9yZVxuXG4gICAgaWYgKCFyZXN1bHQuY2hhbmdlZCAmJiAoIXNraXBNb2RpZmllcnMgfHwgc2tpcE1vZGlmaWVycyA8IHRoaXMuc3RhdGVzLmxlbmd0aCkgJiYgaW50ZXJhY3Rpb24uaW50ZXJhY3RpbmcoKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGlmIChhcmcubW9kaWZpZWRDb29yZHMpIHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgcGFnZVxuICAgICAgfSA9IGludGVyYWN0aW9uLmNvb3Jkcy5jdXI7XG4gICAgICBjb25zdCBhZGp1c3RtZW50ID0ge1xuICAgICAgICB4OiBhcmcubW9kaWZpZWRDb29yZHMueCAtIHBhZ2UueCxcbiAgICAgICAgeTogYXJnLm1vZGlmaWVkQ29vcmRzLnkgLSBwYWdlLnlcbiAgICAgIH07XG4gICAgICByZXN1bHQuY29vcmRzLnggKz0gYWRqdXN0bWVudC54O1xuICAgICAgcmVzdWx0LmNvb3Jkcy55ICs9IGFkanVzdG1lbnQueTtcbiAgICAgIHJlc3VsdC5kZWx0YS54ICs9IGFkanVzdG1lbnQueDtcbiAgICAgIHJlc3VsdC5kZWx0YS55ICs9IGFkanVzdG1lbnQueTtcbiAgICB9XG5cbiAgICB0aGlzLmFwcGx5VG9JbnRlcmFjdGlvbihhcmcpO1xuICB9XG5cbiAgYmVmb3JlRW5kKGFyZykge1xuICAgIGNvbnN0IHtcbiAgICAgIGludGVyYWN0aW9uLFxuICAgICAgZXZlbnRcbiAgICB9ID0gYXJnO1xuICAgIGNvbnN0IHN0YXRlcyA9IHRoaXMuc3RhdGVzO1xuXG4gICAgaWYgKCFzdGF0ZXMgfHwgIXN0YXRlcy5sZW5ndGgpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBsZXQgZG9QcmVlbmQgPSBmYWxzZTtcblxuICAgIGZvciAoY29uc3Qgc3RhdGUgb2Ygc3RhdGVzKSB7XG4gICAgICBhcmcuc3RhdGUgPSBzdGF0ZTtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgb3B0aW9ucyxcbiAgICAgICAgbWV0aG9kc1xuICAgICAgfSA9IHN0YXRlO1xuICAgICAgY29uc3QgZW5kUG9zaXRpb24gPSBtZXRob2RzLmJlZm9yZUVuZCAmJiBtZXRob2RzLmJlZm9yZUVuZChhcmcpO1xuXG4gICAgICBpZiAoZW5kUG9zaXRpb24pIHtcbiAgICAgICAgdGhpcy5lbmRSZXN1bHQgPSBlbmRQb3NpdGlvbjtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuXG4gICAgICBkb1ByZWVuZCA9IGRvUHJlZW5kIHx8ICFkb1ByZWVuZCAmJiB0aGlzLnNob3VsZERvKG9wdGlvbnMsIHRydWUsIGFyZy5waGFzZSwgdHJ1ZSk7XG4gICAgfVxuXG4gICAgaWYgKGRvUHJlZW5kKSB7XG4gICAgICAvLyB0cmlnZ2VyIGEgZmluYWwgbW9kaWZpZWQgbW92ZSBiZWZvcmUgZW5kaW5nXG4gICAgICBpbnRlcmFjdGlvbi5tb3ZlKHtcbiAgICAgICAgZXZlbnQsXG4gICAgICAgIHByZUVuZDogdHJ1ZVxuICAgICAgfSk7XG4gICAgfVxuICB9XG5cbiAgc3RvcChhcmcpIHtcbiAgICBjb25zdCB7XG4gICAgICBpbnRlcmFjdGlvblxuICAgIH0gPSBhcmc7XG5cbiAgICBpZiAoIXRoaXMuc3RhdGVzIHx8ICF0aGlzLnN0YXRlcy5sZW5ndGgpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjb25zdCBtb2RpZmllckFyZyA9IGV4dGVuZCh7XG4gICAgICBzdGF0ZXM6IHRoaXMuc3RhdGVzLFxuICAgICAgaW50ZXJhY3RhYmxlOiBpbnRlcmFjdGlvbi5pbnRlcmFjdGFibGUsXG4gICAgICBlbGVtZW50OiBpbnRlcmFjdGlvbi5lbGVtZW50LFxuICAgICAgcmVjdDogbnVsbFxuICAgIH0sIGFyZyk7XG4gICAgdGhpcy5maWxsQXJnKG1vZGlmaWVyQXJnKTtcblxuICAgIGZvciAoY29uc3Qgc3RhdGUgb2YgdGhpcy5zdGF0ZXMpIHtcbiAgICAgIG1vZGlmaWVyQXJnLnN0YXRlID0gc3RhdGU7XG5cbiAgICAgIGlmIChzdGF0ZS5tZXRob2RzLnN0b3ApIHtcbiAgICAgICAgc3RhdGUubWV0aG9kcy5zdG9wKG1vZGlmaWVyQXJnKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB0aGlzLnN0YXRlcyA9IG51bGw7XG4gICAgdGhpcy5lbmRSZXN1bHQgPSBudWxsO1xuICB9XG5cbiAgcHJlcGFyZVN0YXRlcyhtb2RpZmllckxpc3QpIHtcbiAgICB0aGlzLnN0YXRlcyA9IFtdO1xuXG4gICAgZm9yIChsZXQgaW5kZXggPSAwOyBpbmRleCA8IG1vZGlmaWVyTGlzdC5sZW5ndGg7IGluZGV4KyspIHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgb3B0aW9ucyxcbiAgICAgICAgbWV0aG9kcyxcbiAgICAgICAgbmFtZVxuICAgICAgfSA9IG1vZGlmaWVyTGlzdFtpbmRleF07XG4gICAgICB0aGlzLnN0YXRlcy5wdXNoKHtcbiAgICAgICAgb3B0aW9ucyxcbiAgICAgICAgbWV0aG9kcyxcbiAgICAgICAgaW5kZXgsXG4gICAgICAgIG5hbWVcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLnN0YXRlcztcbiAgfVxuXG4gIHJlc3RvcmVJbnRlcmFjdGlvbkNvb3Jkcyh7XG4gICAgaW50ZXJhY3Rpb246IHtcbiAgICAgIGNvb3JkcyxcbiAgICAgIHJlY3QsXG4gICAgICBtb2RpZmljYXRpb25cbiAgICB9XG4gIH0pIHtcbiAgICBpZiAoIW1vZGlmaWNhdGlvbi5yZXN1bHQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjb25zdCB7XG4gICAgICBzdGFydERlbHRhXG4gICAgfSA9IG1vZGlmaWNhdGlvbjtcbiAgICBjb25zdCB7XG4gICAgICBkZWx0YTogY3VyRGVsdGEsXG4gICAgICByZWN0RGVsdGFcbiAgICB9ID0gbW9kaWZpY2F0aW9uLnJlc3VsdDtcbiAgICBjb25zdCBjb29yZHNBbmREZWx0YXMgPSBbW2Nvb3Jkcy5zdGFydCwgc3RhcnREZWx0YV0sIFtjb29yZHMuY3VyLCBjdXJEZWx0YV1dO1xuXG4gICAgZm9yIChjb25zdCBbY29vcmRzU2V0LCBkZWx0YV0gb2YgY29vcmRzQW5kRGVsdGFzKSB7XG4gICAgICBjb29yZHNTZXQucGFnZS54IC09IGRlbHRhLng7XG4gICAgICBjb29yZHNTZXQucGFnZS55IC09IGRlbHRhLnk7XG4gICAgICBjb29yZHNTZXQuY2xpZW50LnggLT0gZGVsdGEueDtcbiAgICAgIGNvb3Jkc1NldC5jbGllbnQueSAtPSBkZWx0YS55O1xuICAgIH1cblxuICAgIHJlY3QubGVmdCAtPSByZWN0RGVsdGEubGVmdDtcbiAgICByZWN0LnJpZ2h0IC09IHJlY3REZWx0YS5yaWdodDtcbiAgICByZWN0LnRvcCAtPSByZWN0RGVsdGEudG9wO1xuICAgIHJlY3QuYm90dG9tIC09IHJlY3REZWx0YS5ib3R0b207XG4gIH1cblxuICBzaG91bGREbyhvcHRpb25zLCBwcmVFbmQsIHBoYXNlLCByZXF1aXJlRW5kT25seSkge1xuICAgIGlmICggLy8gaWdub3JlIGRpc2FibGVkIG1vZGlmaWVyc1xuICAgICFvcHRpb25zIHx8IG9wdGlvbnMuZW5hYmxlZCA9PT0gZmFsc2UgfHwgLy8gY2hlY2sgaWYgd2UgcmVxdWlyZSBlbmRPbmx5IG9wdGlvbiB0byBmaXJlIG1vdmUgYmVmb3JlIGVuZFxuICAgIHJlcXVpcmVFbmRPbmx5ICYmICFvcHRpb25zLmVuZE9ubHkgfHwgLy8gZG9uJ3QgYXBwbHkgZW5kT25seSBtb2RpZmllcnMgd2hlbiBub3QgZW5kaW5nXG4gICAgb3B0aW9ucy5lbmRPbmx5ICYmICFwcmVFbmQgfHwgLy8gY2hlY2sgaWYgbW9kaWZpZXIgc2hvdWxkIHJ1biBiZSBhcHBsaWVkIG9uIHN0YXJ0XG4gICAgcGhhc2UgPT09ICdzdGFydCcgJiYgIW9wdGlvbnMuc2V0U3RhcnQpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIGNvcHlGcm9tKG90aGVyKSB7XG4gICAgdGhpcy5zdGFydE9mZnNldCA9IG90aGVyLnN0YXJ0T2Zmc2V0O1xuICAgIHRoaXMuc3RhcnREZWx0YSA9IG90aGVyLnN0YXJ0RGVsdGE7XG4gICAgdGhpcy5lZGdlcyA9IG90aGVyLmVkZ2VzO1xuICAgIHRoaXMuc3RhdGVzID0gb3RoZXIuc3RhdGVzLm1hcChzID0+IGNsb25lKHMpKTtcbiAgICB0aGlzLnJlc3VsdCA9IGNyZWF0ZVJlc3VsdChleHRlbmQoe30sIG90aGVyLnJlc3VsdC5jb29yZHMpLCBleHRlbmQoe30sIG90aGVyLnJlc3VsdC5yZWN0KSk7XG4gIH1cblxuICBkZXN0cm95KCkge1xuICAgIGZvciAoY29uc3QgcHJvcCBpbiB0aGlzKSB7XG4gICAgICB0aGlzW3Byb3BdID0gbnVsbDtcbiAgICB9XG4gIH1cblxufVxuXG5mdW5jdGlvbiBjcmVhdGVSZXN1bHQoY29vcmRzLCByZWN0KSB7XG4gIHJldHVybiB7XG4gICAgcmVjdCxcbiAgICBjb29yZHMsXG4gICAgZGVsdGE6IHtcbiAgICAgIHg6IDAsXG4gICAgICB5OiAwXG4gICAgfSxcbiAgICByZWN0RGVsdGE6IHtcbiAgICAgIGxlZnQ6IDAsXG4gICAgICByaWdodDogMCxcbiAgICAgIHRvcDogMCxcbiAgICAgIGJvdHRvbTogMFxuICAgIH0sXG4gICAgZXZlbnRQcm9wczogW10sXG4gICAgY2hhbmdlZDogdHJ1ZVxuICB9O1xufVxuXG5mdW5jdGlvbiBnZXRNb2RpZmllckxpc3QoaW50ZXJhY3Rpb24pIHtcbiAgY29uc3QgYWN0aW9uT3B0aW9ucyA9IGludGVyYWN0aW9uLmludGVyYWN0YWJsZS5vcHRpb25zW2ludGVyYWN0aW9uLnByZXBhcmVkLm5hbWVdO1xuICBjb25zdCBhY3Rpb25Nb2RpZmllcnMgPSBhY3Rpb25PcHRpb25zLm1vZGlmaWVycztcblxuICBpZiAoYWN0aW9uTW9kaWZpZXJzICYmIGFjdGlvbk1vZGlmaWVycy5sZW5ndGgpIHtcbiAgICByZXR1cm4gYWN0aW9uTW9kaWZpZXJzO1xuICB9XG5cbiAgcmV0dXJuIFsnc25hcCcsICdzbmFwU2l6ZScsICdzbmFwRWRnZXMnLCAncmVzdHJpY3QnLCAncmVzdHJpY3RFZGdlcycsICdyZXN0cmljdFNpemUnXS5tYXAodHlwZSA9PiB7XG4gICAgY29uc3Qgb3B0aW9ucyA9IGFjdGlvbk9wdGlvbnNbdHlwZV07XG4gICAgcmV0dXJuIG9wdGlvbnMgJiYgb3B0aW9ucy5lbmFibGVkICYmIHtcbiAgICAgIG9wdGlvbnMsXG4gICAgICBtZXRob2RzOiBvcHRpb25zLl9tZXRob2RzXG4gICAgfTtcbiAgfSkuZmlsdGVyKG0gPT4gISFtKTtcbn1cblxuZnVuY3Rpb24gZ2V0UmVjdE9mZnNldChyZWN0LCBjb29yZHMpIHtcbiAgcmV0dXJuIHJlY3QgPyB7XG4gICAgbGVmdDogY29vcmRzLnggLSByZWN0LmxlZnQsXG4gICAgdG9wOiBjb29yZHMueSAtIHJlY3QudG9wLFxuICAgIHJpZ2h0OiByZWN0LnJpZ2h0IC0gY29vcmRzLngsXG4gICAgYm90dG9tOiByZWN0LmJvdHRvbSAtIGNvb3Jkcy55XG4gIH0gOiB7XG4gICAgbGVmdDogMCxcbiAgICB0b3A6IDAsXG4gICAgcmlnaHQ6IDAsXG4gICAgYm90dG9tOiAwXG4gIH07XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1Nb2RpZmljYXRpb24uanMubWFwXG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL25vZGVfbW9kdWxlcy9AaW50ZXJhY3Rqcy9tb2RpZmllcnMvYmFzZS5qc1xuXG5cblxuZnVuY3Rpb24gbWFrZU1vZGlmaWVyKG1vZHVsZSwgbmFtZSkge1xuICBjb25zdCB7XG4gICAgZGVmYXVsdHNcbiAgfSA9IG1vZHVsZTtcbiAgY29uc3QgbWV0aG9kcyA9IHtcbiAgICBzdGFydDogbW9kdWxlLnN0YXJ0LFxuICAgIHNldDogbW9kdWxlLnNldCxcbiAgICBiZWZvcmVFbmQ6IG1vZHVsZS5iZWZvcmVFbmQsXG4gICAgc3RvcDogbW9kdWxlLnN0b3BcbiAgfTtcblxuICBjb25zdCBtb2RpZmllciA9IF9vcHRpb25zID0+IHtcbiAgICBjb25zdCBvcHRpb25zID0gX29wdGlvbnMgfHwge307XG4gICAgb3B0aW9ucy5lbmFibGVkID0gb3B0aW9ucy5lbmFibGVkICE9PSBmYWxzZTsgLy8gYWRkIG1pc3NpbmcgZGVmYXVsdHMgdG8gb3B0aW9uc1xuXG4gICAgZm9yIChjb25zdCBwcm9wIGluIGRlZmF1bHRzKSB7XG4gICAgICBpZiAoIShwcm9wIGluIG9wdGlvbnMpKSB7XG4gICAgICAgIG9wdGlvbnNbcHJvcF0gPSBkZWZhdWx0c1twcm9wXTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBjb25zdCBtID0ge1xuICAgICAgb3B0aW9ucyxcbiAgICAgIG1ldGhvZHMsXG4gICAgICBuYW1lLFxuICAgICAgZW5hYmxlOiAoKSA9PiB7XG4gICAgICAgIG9wdGlvbnMuZW5hYmxlZCA9IHRydWU7XG4gICAgICAgIHJldHVybiBtO1xuICAgICAgfSxcbiAgICAgIGRpc2FibGU6ICgpID0+IHtcbiAgICAgICAgb3B0aW9ucy5lbmFibGVkID0gZmFsc2U7XG4gICAgICAgIHJldHVybiBtO1xuICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIG07XG4gIH07XG5cbiAgaWYgKG5hbWUgJiYgdHlwZW9mIG5hbWUgPT09ICdzdHJpbmcnKSB7XG4gICAgLy8gZm9yIGJhY2t3cmFkcyBjb21wYXRpYmlsaXR5XG4gICAgbW9kaWZpZXIuX2RlZmF1bHRzID0gZGVmYXVsdHM7XG4gICAgbW9kaWZpZXIuX21ldGhvZHMgPSBtZXRob2RzO1xuICB9XG5cbiAgcmV0dXJuIG1vZGlmaWVyO1xufVxuZnVuY3Rpb24gYWRkRXZlbnRNb2RpZmllcnMoe1xuICBpRXZlbnQsXG4gIGludGVyYWN0aW9uOiB7XG4gICAgbW9kaWZpY2F0aW9uOiB7XG4gICAgICByZXN1bHRcbiAgICB9XG4gIH1cbn0pIHtcbiAgaWYgKHJlc3VsdCkge1xuICAgIGlFdmVudC5tb2RpZmllcnMgPSByZXN1bHQuZXZlbnRQcm9wcztcbiAgfVxufVxuY29uc3QgbW9kaWZpZXJzQmFzZSA9IHtcbiAgaWQ6ICdtb2RpZmllcnMvYmFzZScsXG4gIGJlZm9yZTogWydhY3Rpb25zJ10sXG4gIGluc3RhbGw6IHNjb3BlID0+IHtcbiAgICBzY29wZS5kZWZhdWx0cy5wZXJBY3Rpb24ubW9kaWZpZXJzID0gW107XG4gIH0sXG4gIGxpc3RlbmVyczoge1xuICAgICdpbnRlcmFjdGlvbnM6bmV3JzogKHtcbiAgICAgIGludGVyYWN0aW9uXG4gICAgfSkgPT4ge1xuICAgICAgaW50ZXJhY3Rpb24ubW9kaWZpY2F0aW9uID0gbmV3IE1vZGlmaWNhdGlvbl9Nb2RpZmljYXRpb24oaW50ZXJhY3Rpb24pO1xuICAgIH0sXG4gICAgJ2ludGVyYWN0aW9uczpiZWZvcmUtYWN0aW9uLXN0YXJ0JzogYXJnID0+IHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgbW9kaWZpY2F0aW9uXG4gICAgICB9ID0gYXJnLmludGVyYWN0aW9uO1xuICAgICAgbW9kaWZpY2F0aW9uLnN0YXJ0KGFyZywgYXJnLmludGVyYWN0aW9uLmNvb3Jkcy5zdGFydC5wYWdlKTtcbiAgICAgIGFyZy5pbnRlcmFjdGlvbi5lZGdlcyA9IG1vZGlmaWNhdGlvbi5lZGdlcztcbiAgICAgIG1vZGlmaWNhdGlvbi5hcHBseVRvSW50ZXJhY3Rpb24oYXJnKTtcbiAgICB9LFxuICAgICdpbnRlcmFjdGlvbnM6YmVmb3JlLWFjdGlvbi1tb3ZlJzogYXJnID0+IGFyZy5pbnRlcmFjdGlvbi5tb2RpZmljYXRpb24uc2V0QW5kQXBwbHkoYXJnKSxcbiAgICAnaW50ZXJhY3Rpb25zOmJlZm9yZS1hY3Rpb24tZW5kJzogYXJnID0+IGFyZy5pbnRlcmFjdGlvbi5tb2RpZmljYXRpb24uYmVmb3JlRW5kKGFyZyksXG4gICAgJ2ludGVyYWN0aW9uczphY3Rpb24tc3RhcnQnOiBhZGRFdmVudE1vZGlmaWVycyxcbiAgICAnaW50ZXJhY3Rpb25zOmFjdGlvbi1tb3ZlJzogYWRkRXZlbnRNb2RpZmllcnMsXG4gICAgJ2ludGVyYWN0aW9uczphY3Rpb24tZW5kJzogYWRkRXZlbnRNb2RpZmllcnMsXG4gICAgJ2ludGVyYWN0aW9uczphZnRlci1hY3Rpb24tc3RhcnQnOiBhcmcgPT4gYXJnLmludGVyYWN0aW9uLm1vZGlmaWNhdGlvbi5yZXN0b3JlSW50ZXJhY3Rpb25Db29yZHMoYXJnKSxcbiAgICAnaW50ZXJhY3Rpb25zOmFmdGVyLWFjdGlvbi1tb3ZlJzogYXJnID0+IGFyZy5pbnRlcmFjdGlvbi5tb2RpZmljYXRpb24ucmVzdG9yZUludGVyYWN0aW9uQ29vcmRzKGFyZyksXG4gICAgJ2ludGVyYWN0aW9uczpzdG9wJzogYXJnID0+IGFyZy5pbnRlcmFjdGlvbi5tb2RpZmljYXRpb24uc3RvcChhcmcpXG4gIH1cbn07XG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIHZhciBtb2RpZmllcnNfYmFzZSA9IChtb2RpZmllcnNCYXNlKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWJhc2UuanMubWFwXG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL25vZGVfbW9kdWxlcy9AaW50ZXJhY3Rqcy9tb2RpZmllcnMvYXNwZWN0UmF0aW8uanNcbi8qKlxuICogQG1vZHVsZSBtb2RpZmllcnMvYXNwZWN0UmF0aW9cbiAqXG4gKiBAZGVzY3JpcHRpb25cbiAqIFRoaXMgbW9kdWxlIGZvcmNlcyBlbGVtZW50cyB0byBiZSByZXNpemVkIHdpdGggYSBzcGVjaWZpZWQgZHgvZHkgcmF0aW8uXG4gKlxuICogYGBganNcbiAqIGludGVyYWN0KHRhcmdldCkucmVzaXphYmxlKHtcbiAqICAgbW9kaWZpZXJzOiBbXG4gKiAgICAgaW50ZXJhY3QubW9kaWZpZXJzLnNuYXBTaXplKHtcbiAqICAgICAgIHRhcmdldHM6IFsgaW50ZXJhY3Quc25hcHBlcnMuZ3JpZCh7IHg6IDIwLCB5OiAyMCB9KSBdLFxuICogICAgIH0pLFxuICogICAgIGludGVyYWN0LmFzcGVjdFJhdGlvKHsgcmF0aW86ICdwcmVzZXJ2ZScgfSksXG4gKiAgIF0sXG4gKiB9KTtcbiAqIGBgYFxuICovXG5cblxuXG5cbmNvbnN0IGFzcGVjdFJhdGlvID0ge1xuICBzdGFydChhcmcpIHtcbiAgICBjb25zdCB7XG4gICAgICBzdGF0ZSxcbiAgICAgIHJlY3QsXG4gICAgICBlZGdlczogb3JpZ2luYWxFZGdlcyxcbiAgICAgIHBhZ2VDb29yZHM6IGNvb3Jkc1xuICAgIH0gPSBhcmc7XG4gICAgbGV0IHtcbiAgICAgIHJhdGlvXG4gICAgfSA9IHN0YXRlLm9wdGlvbnM7XG4gICAgY29uc3Qge1xuICAgICAgZXF1YWxEZWx0YSxcbiAgICAgIG1vZGlmaWVyc1xuICAgIH0gPSBzdGF0ZS5vcHRpb25zO1xuXG4gICAgaWYgKHJhdGlvID09PSAncHJlc2VydmUnKSB7XG4gICAgICByYXRpbyA9IHJlY3Qud2lkdGggLyByZWN0LmhlaWdodDtcbiAgICB9XG5cbiAgICBzdGF0ZS5zdGFydENvb3JkcyA9IGV4dGVuZCh7fSwgY29vcmRzKTtcbiAgICBzdGF0ZS5zdGFydFJlY3QgPSBleHRlbmQoe30sIHJlY3QpO1xuICAgIHN0YXRlLnJhdGlvID0gcmF0aW87XG4gICAgc3RhdGUuZXF1YWxEZWx0YSA9IGVxdWFsRGVsdGE7XG4gICAgY29uc3QgbGlua2VkRWRnZXMgPSBzdGF0ZS5saW5rZWRFZGdlcyA9IHtcbiAgICAgIHRvcDogb3JpZ2luYWxFZGdlcy50b3AgfHwgb3JpZ2luYWxFZGdlcy5sZWZ0ICYmICFvcmlnaW5hbEVkZ2VzLmJvdHRvbSxcbiAgICAgIGxlZnQ6IG9yaWdpbmFsRWRnZXMubGVmdCB8fCBvcmlnaW5hbEVkZ2VzLnRvcCAmJiAhb3JpZ2luYWxFZGdlcy5yaWdodCxcbiAgICAgIGJvdHRvbTogb3JpZ2luYWxFZGdlcy5ib3R0b20gfHwgb3JpZ2luYWxFZGdlcy5yaWdodCAmJiAhb3JpZ2luYWxFZGdlcy50b3AsXG4gICAgICByaWdodDogb3JpZ2luYWxFZGdlcy5yaWdodCB8fCBvcmlnaW5hbEVkZ2VzLmJvdHRvbSAmJiAhb3JpZ2luYWxFZGdlcy5sZWZ0XG4gICAgfTtcbiAgICBzdGF0ZS54SXNQcmltYXJ5QXhpcyA9ICEhKG9yaWdpbmFsRWRnZXMubGVmdCB8fCBvcmlnaW5hbEVkZ2VzLnJpZ2h0KTtcblxuICAgIGlmIChzdGF0ZS5lcXVhbERlbHRhKSB7XG4gICAgICBzdGF0ZS5lZGdlU2lnbiA9IChsaW5rZWRFZGdlcy5sZWZ0ID8gMSA6IC0xKSAqIChsaW5rZWRFZGdlcy50b3AgPyAxIDogLTEpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBuZWdhdGl2ZVNlY29uZGFyeUVkZ2UgPSBzdGF0ZS54SXNQcmltYXJ5QXhpcyA/IGxpbmtlZEVkZ2VzLnRvcCA6IGxpbmtlZEVkZ2VzLmxlZnQ7XG4gICAgICBzdGF0ZS5lZGdlU2lnbiA9IG5lZ2F0aXZlU2Vjb25kYXJ5RWRnZSA/IC0xIDogMTtcbiAgICB9XG5cbiAgICBleHRlbmQoYXJnLmVkZ2VzLCBsaW5rZWRFZGdlcyk7XG5cbiAgICBpZiAoIW1vZGlmaWVycyB8fCAhbW9kaWZpZXJzLmxlbmd0aCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0IHN1Yk1vZGlmaWNhdGlvbiA9IG5ldyBNb2RpZmljYXRpb25fTW9kaWZpY2F0aW9uKGFyZy5pbnRlcmFjdGlvbik7XG4gICAgc3ViTW9kaWZpY2F0aW9uLmNvcHlGcm9tKGFyZy5pbnRlcmFjdGlvbi5tb2RpZmljYXRpb24pO1xuICAgIHN1Yk1vZGlmaWNhdGlvbi5wcmVwYXJlU3RhdGVzKG1vZGlmaWVycyk7XG4gICAgc3RhdGUuc3ViTW9kaWZpY2F0aW9uID0gc3ViTW9kaWZpY2F0aW9uO1xuICAgIHN1Yk1vZGlmaWNhdGlvbi5zdGFydEFsbCh7IC4uLmFyZ1xuICAgIH0pO1xuICB9LFxuXG4gIHNldChhcmcpIHtcbiAgICBjb25zdCB7XG4gICAgICBzdGF0ZSxcbiAgICAgIHJlY3QsXG4gICAgICBjb29yZHNcbiAgICB9ID0gYXJnO1xuICAgIGNvbnN0IGluaXRpYWxDb29yZHMgPSBleHRlbmQoe30sIGNvb3Jkcyk7XG4gICAgY29uc3QgYXNwZWN0TWV0aG9kID0gc3RhdGUuZXF1YWxEZWx0YSA/IHNldEVxdWFsRGVsdGEgOiBzZXRSYXRpbztcbiAgICBhc3BlY3RNZXRob2Qoc3RhdGUsIHN0YXRlLnhJc1ByaW1hcnlBeGlzLCBjb29yZHMsIHJlY3QpO1xuXG4gICAgaWYgKCFzdGF0ZS5zdWJNb2RpZmljYXRpb24pIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIGNvbnN0IGNvcnJlY3RlZFJlY3QgPSBleHRlbmQoe30sIHJlY3QpO1xuICAgIGFkZEVkZ2VzKHN0YXRlLmxpbmtlZEVkZ2VzLCBjb3JyZWN0ZWRSZWN0LCB7XG4gICAgICB4OiBjb29yZHMueCAtIGluaXRpYWxDb29yZHMueCxcbiAgICAgIHk6IGNvb3Jkcy55IC0gaW5pdGlhbENvb3Jkcy55XG4gICAgfSk7XG4gICAgY29uc3QgcmVzdWx0ID0gc3RhdGUuc3ViTW9kaWZpY2F0aW9uLnNldEFsbCh7IC4uLmFyZyxcbiAgICAgIHJlY3Q6IGNvcnJlY3RlZFJlY3QsXG4gICAgICBlZGdlczogc3RhdGUubGlua2VkRWRnZXMsXG4gICAgICBwYWdlQ29vcmRzOiBjb29yZHMsXG4gICAgICBwcmV2Q29vcmRzOiBjb29yZHMsXG4gICAgICBwcmV2UmVjdDogY29ycmVjdGVkUmVjdFxuICAgIH0pO1xuICAgIGNvbnN0IHtcbiAgICAgIGRlbHRhXG4gICAgfSA9IHJlc3VsdDtcblxuICAgIGlmIChyZXN1bHQuY2hhbmdlZCkge1xuICAgICAgY29uc3QgeElzQ3JpdGljYWxBeGlzID0gTWF0aC5hYnMoZGVsdGEueCkgPiBNYXRoLmFicyhkZWx0YS55KTsgLy8gZG8gYXNwZWN0IG1vZGlmaWNhdGlvbiBhZ2FpbiB3aXRoIGNyaXRpY2FsIGVkZ2UgYXhpcyBhcyBwcmltYXJ5XG5cbiAgICAgIGFzcGVjdE1ldGhvZChzdGF0ZSwgeElzQ3JpdGljYWxBeGlzLCByZXN1bHQuY29vcmRzLCByZXN1bHQucmVjdCk7XG4gICAgICBleHRlbmQoY29vcmRzLCByZXN1bHQuY29vcmRzKTtcbiAgICB9XG5cbiAgICByZXR1cm4gcmVzdWx0LmV2ZW50UHJvcHM7XG4gIH0sXG5cbiAgZGVmYXVsdHM6IHtcbiAgICByYXRpbzogJ3ByZXNlcnZlJyxcbiAgICBlcXVhbERlbHRhOiBmYWxzZSxcbiAgICBtb2RpZmllcnM6IFtdLFxuICAgIGVuYWJsZWQ6IGZhbHNlXG4gIH1cbn07XG5cbmZ1bmN0aW9uIHNldEVxdWFsRGVsdGEoe1xuICBzdGFydENvb3JkcyxcbiAgZWRnZVNpZ25cbn0sIHhJc1ByaW1hcnlBeGlzLCBjb29yZHMpIHtcbiAgaWYgKHhJc1ByaW1hcnlBeGlzKSB7XG4gICAgY29vcmRzLnkgPSBzdGFydENvb3Jkcy55ICsgKGNvb3Jkcy54IC0gc3RhcnRDb29yZHMueCkgKiBlZGdlU2lnbjtcbiAgfSBlbHNlIHtcbiAgICBjb29yZHMueCA9IHN0YXJ0Q29vcmRzLnggKyAoY29vcmRzLnkgLSBzdGFydENvb3Jkcy55KSAqIGVkZ2VTaWduO1xuICB9XG59XG5cbmZ1bmN0aW9uIHNldFJhdGlvKHtcbiAgc3RhcnRSZWN0LFxuICBzdGFydENvb3JkcyxcbiAgcmF0aW8sXG4gIGVkZ2VTaWduXG59LCB4SXNQcmltYXJ5QXhpcywgY29vcmRzLCByZWN0KSB7XG4gIGlmICh4SXNQcmltYXJ5QXhpcykge1xuICAgIGNvbnN0IG5ld0hlaWdodCA9IHJlY3Qud2lkdGggLyByYXRpbztcbiAgICBjb29yZHMueSA9IHN0YXJ0Q29vcmRzLnkgKyAobmV3SGVpZ2h0IC0gc3RhcnRSZWN0LmhlaWdodCkgKiBlZGdlU2lnbjtcbiAgfSBlbHNlIHtcbiAgICBjb25zdCBuZXdXaWR0aCA9IHJlY3QuaGVpZ2h0ICogcmF0aW87XG4gICAgY29vcmRzLnggPSBzdGFydENvb3Jkcy54ICsgKG5ld1dpZHRoIC0gc3RhcnRSZWN0LndpZHRoKSAqIGVkZ2VTaWduO1xuICB9XG59XG5cbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gdmFyIG1vZGlmaWVyc19hc3BlY3RSYXRpbyA9IChtYWtlTW9kaWZpZXIoYXNwZWN0UmF0aW8sICdhc3BlY3RSYXRpbycpKTtcblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YXNwZWN0UmF0aW8uanMubWFwXG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL25vZGVfbW9kdWxlcy9AaW50ZXJhY3Rqcy9tb2RpZmllcnMvbm9vcC5qc1xuY29uc3Qgbm9vcCA9ICgpID0+IHt9O1xuXG5ub29wLl9kZWZhdWx0cyA9IHt9O1xuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyB2YXIgbW9kaWZpZXJzX25vb3AgPSAobm9vcCk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1ub29wLmpzLm1hcFxuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9ub2RlX21vZHVsZXMvQGludGVyYWN0anMvbW9kaWZpZXJzL3Jlc3RyaWN0L3BvaW50ZXIuanNcblxuXG5cblxuXG5mdW5jdGlvbiBwb2ludGVyX3N0YXJ0KHtcbiAgcmVjdCxcbiAgc3RhcnRPZmZzZXQsXG4gIHN0YXRlLFxuICBpbnRlcmFjdGlvbixcbiAgcGFnZUNvb3Jkc1xufSkge1xuICBjb25zdCB7XG4gICAgb3B0aW9uc1xuICB9ID0gc3RhdGU7XG4gIGNvbnN0IHtcbiAgICBlbGVtZW50UmVjdFxuICB9ID0gb3B0aW9ucztcbiAgY29uc3Qgb2Zmc2V0ID0gZXh0ZW5kKHtcbiAgICBsZWZ0OiAwLFxuICAgIHRvcDogMCxcbiAgICByaWdodDogMCxcbiAgICBib3R0b206IDBcbiAgfSwgb3B0aW9ucy5vZmZzZXQgfHwge30pO1xuXG4gIGlmIChyZWN0ICYmIGVsZW1lbnRSZWN0KSB7XG4gICAgY29uc3QgcmVzdHJpY3Rpb24gPSBnZXRSZXN0cmljdGlvblJlY3Qob3B0aW9ucy5yZXN0cmljdGlvbiwgaW50ZXJhY3Rpb24sIHBhZ2VDb29yZHMpO1xuXG4gICAgaWYgKHJlc3RyaWN0aW9uKSB7XG4gICAgICBjb25zdCB3aWR0aERpZmYgPSByZXN0cmljdGlvbi5yaWdodCAtIHJlc3RyaWN0aW9uLmxlZnQgLSByZWN0LndpZHRoO1xuICAgICAgY29uc3QgaGVpZ2h0RGlmZiA9IHJlc3RyaWN0aW9uLmJvdHRvbSAtIHJlc3RyaWN0aW9uLnRvcCAtIHJlY3QuaGVpZ2h0O1xuXG4gICAgICBpZiAod2lkdGhEaWZmIDwgMCkge1xuICAgICAgICBvZmZzZXQubGVmdCArPSB3aWR0aERpZmY7XG4gICAgICAgIG9mZnNldC5yaWdodCArPSB3aWR0aERpZmY7XG4gICAgICB9XG5cbiAgICAgIGlmIChoZWlnaHREaWZmIDwgMCkge1xuICAgICAgICBvZmZzZXQudG9wICs9IGhlaWdodERpZmY7XG4gICAgICAgIG9mZnNldC5ib3R0b20gKz0gaGVpZ2h0RGlmZjtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBvZmZzZXQubGVmdCArPSBzdGFydE9mZnNldC5sZWZ0IC0gcmVjdC53aWR0aCAqIGVsZW1lbnRSZWN0LmxlZnQ7XG4gICAgb2Zmc2V0LnRvcCArPSBzdGFydE9mZnNldC50b3AgLSByZWN0LmhlaWdodCAqIGVsZW1lbnRSZWN0LnRvcDtcbiAgICBvZmZzZXQucmlnaHQgKz0gc3RhcnRPZmZzZXQucmlnaHQgLSByZWN0LndpZHRoICogKDEgLSBlbGVtZW50UmVjdC5yaWdodCk7XG4gICAgb2Zmc2V0LmJvdHRvbSArPSBzdGFydE9mZnNldC5ib3R0b20gLSByZWN0LmhlaWdodCAqICgxIC0gZWxlbWVudFJlY3QuYm90dG9tKTtcbiAgfVxuXG4gIHN0YXRlLm9mZnNldCA9IG9mZnNldDtcbn1cblxuZnVuY3Rpb24gc2V0KHtcbiAgY29vcmRzLFxuICBpbnRlcmFjdGlvbixcbiAgc3RhdGVcbn0pIHtcbiAgY29uc3Qge1xuICAgIG9wdGlvbnMsXG4gICAgb2Zmc2V0XG4gIH0gPSBzdGF0ZTtcbiAgY29uc3QgcmVzdHJpY3Rpb24gPSBnZXRSZXN0cmljdGlvblJlY3Qob3B0aW9ucy5yZXN0cmljdGlvbiwgaW50ZXJhY3Rpb24sIGNvb3Jkcyk7XG5cbiAgaWYgKCFyZXN0cmljdGlvbikge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGNvbnN0IHJlY3QgPSB4eXdoVG9UbGJyKHJlc3RyaWN0aW9uKTtcbiAgY29vcmRzLnggPSBNYXRoLm1heChNYXRoLm1pbihyZWN0LnJpZ2h0IC0gb2Zmc2V0LnJpZ2h0LCBjb29yZHMueCksIHJlY3QubGVmdCArIG9mZnNldC5sZWZ0KTtcbiAgY29vcmRzLnkgPSBNYXRoLm1heChNYXRoLm1pbihyZWN0LmJvdHRvbSAtIG9mZnNldC5ib3R0b20sIGNvb3Jkcy55KSwgcmVjdC50b3AgKyBvZmZzZXQudG9wKTtcbn1cblxuZnVuY3Rpb24gZ2V0UmVzdHJpY3Rpb25SZWN0KHZhbHVlLCBpbnRlcmFjdGlvbiwgY29vcmRzKSB7XG4gIGlmIChpcy5mdW5jKHZhbHVlKSkge1xuICAgIHJldHVybiByZXNvbHZlUmVjdExpa2UodmFsdWUsIGludGVyYWN0aW9uLmludGVyYWN0YWJsZSwgaW50ZXJhY3Rpb24uZWxlbWVudCwgW2Nvb3Jkcy54LCBjb29yZHMueSwgaW50ZXJhY3Rpb25dKTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gcmVzb2x2ZVJlY3RMaWtlKHZhbHVlLCBpbnRlcmFjdGlvbi5pbnRlcmFjdGFibGUsIGludGVyYWN0aW9uLmVsZW1lbnQpO1xuICB9XG59XG5jb25zdCBwb2ludGVyX2RlZmF1bHRzID0ge1xuICByZXN0cmljdGlvbjogbnVsbCxcbiAgZWxlbWVudFJlY3Q6IG51bGwsXG4gIG9mZnNldDogbnVsbCxcbiAgZW5kT25seTogZmFsc2UsXG4gIGVuYWJsZWQ6IGZhbHNlXG59O1xuY29uc3QgcmVzdHJpY3QgPSB7XG4gIHN0YXJ0OiBwb2ludGVyX3N0YXJ0LFxuICBzZXQsXG4gIGRlZmF1bHRzOiBwb2ludGVyX2RlZmF1bHRzXG59O1xuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyB2YXIgcmVzdHJpY3RfcG9pbnRlciA9IChtYWtlTW9kaWZpZXIocmVzdHJpY3QsICdyZXN0cmljdCcpKTtcblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cG9pbnRlci5qcy5tYXBcbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vbm9kZV9tb2R1bGVzL0BpbnRlcmFjdGpzL21vZGlmaWVycy9yZXN0cmljdC9lZGdlcy5qc1xuLy8gVGhpcyBtb2R1bGUgYWRkcyB0aGUgb3B0aW9ucy5yZXNpemUucmVzdHJpY3RFZGdlcyBzZXR0aW5nIHdoaWNoIHNldHMgbWluIGFuZFxuLy8gbWF4IGZvciB0aGUgdG9wLCBsZWZ0LCBib3R0b20gYW5kIHJpZ2h0IGVkZ2VzIG9mIHRoZSB0YXJnZXQgYmVpbmcgcmVzaXplZC5cbi8vXG4vLyBpbnRlcmFjdCh0YXJnZXQpLnJlc2l6ZSh7XG4vLyAgIGVkZ2VzOiB7IHRvcDogdHJ1ZSwgbGVmdDogdHJ1ZSB9LFxuLy8gICByZXN0cmljdEVkZ2VzOiB7XG4vLyAgICAgaW5uZXI6IHsgdG9wOiAyMDAsIGxlZnQ6IDIwMCwgcmlnaHQ6IDQwMCwgYm90dG9tOiA0MDAgfSxcbi8vICAgICBvdXRlcjogeyB0b3A6ICAgMCwgbGVmdDogICAwLCByaWdodDogNjAwLCBib3R0b206IDYwMCB9LFxuLy8gICB9LFxuLy8gfSlcblxuXG5cblxuY29uc3Qgbm9Jbm5lciA9IHtcbiAgdG9wOiArSW5maW5pdHksXG4gIGxlZnQ6ICtJbmZpbml0eSxcbiAgYm90dG9tOiAtSW5maW5pdHksXG4gIHJpZ2h0OiAtSW5maW5pdHlcbn07XG5jb25zdCBub091dGVyID0ge1xuICB0b3A6IC1JbmZpbml0eSxcbiAgbGVmdDogLUluZmluaXR5LFxuICBib3R0b206ICtJbmZpbml0eSxcbiAgcmlnaHQ6ICtJbmZpbml0eVxufTtcblxuZnVuY3Rpb24gZWRnZXNfc3RhcnQoe1xuICBpbnRlcmFjdGlvbixcbiAgc3RhcnRPZmZzZXQsXG4gIHN0YXRlXG59KSB7XG4gIGNvbnN0IHtcbiAgICBvcHRpb25zXG4gIH0gPSBzdGF0ZTtcbiAgbGV0IG9mZnNldDtcblxuICBpZiAob3B0aW9ucykge1xuICAgIGNvbnN0IG9mZnNldFJlY3QgPSBnZXRSZXN0cmljdGlvblJlY3Qob3B0aW9ucy5vZmZzZXQsIGludGVyYWN0aW9uLCBpbnRlcmFjdGlvbi5jb29yZHMuc3RhcnQucGFnZSk7XG4gICAgb2Zmc2V0ID0gcmVjdFRvWFkob2Zmc2V0UmVjdCk7XG4gIH1cblxuICBvZmZzZXQgPSBvZmZzZXQgfHwge1xuICAgIHg6IDAsXG4gICAgeTogMFxuICB9O1xuICBzdGF0ZS5vZmZzZXQgPSB7XG4gICAgdG9wOiBvZmZzZXQueSArIHN0YXJ0T2Zmc2V0LnRvcCxcbiAgICBsZWZ0OiBvZmZzZXQueCArIHN0YXJ0T2Zmc2V0LmxlZnQsXG4gICAgYm90dG9tOiBvZmZzZXQueSAtIHN0YXJ0T2Zmc2V0LmJvdHRvbSxcbiAgICByaWdodDogb2Zmc2V0LnggLSBzdGFydE9mZnNldC5yaWdodFxuICB9O1xufVxuXG5mdW5jdGlvbiBlZGdlc19zZXQoe1xuICBjb29yZHMsXG4gIGVkZ2VzLFxuICBpbnRlcmFjdGlvbixcbiAgc3RhdGVcbn0pIHtcbiAgY29uc3Qge1xuICAgIG9mZnNldCxcbiAgICBvcHRpb25zXG4gIH0gPSBzdGF0ZTtcblxuICBpZiAoIWVkZ2VzKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgY29uc3QgcGFnZSA9IGV4dGVuZCh7fSwgY29vcmRzKTtcbiAgY29uc3QgaW5uZXIgPSBnZXRSZXN0cmljdGlvblJlY3Qob3B0aW9ucy5pbm5lciwgaW50ZXJhY3Rpb24sIHBhZ2UpIHx8IHt9O1xuICBjb25zdCBvdXRlciA9IGdldFJlc3RyaWN0aW9uUmVjdChvcHRpb25zLm91dGVyLCBpbnRlcmFjdGlvbiwgcGFnZSkgfHwge307XG4gIGZpeFJlY3QoaW5uZXIsIG5vSW5uZXIpO1xuICBmaXhSZWN0KG91dGVyLCBub091dGVyKTtcblxuICBpZiAoZWRnZXMudG9wKSB7XG4gICAgY29vcmRzLnkgPSBNYXRoLm1pbihNYXRoLm1heChvdXRlci50b3AgKyBvZmZzZXQudG9wLCBwYWdlLnkpLCBpbm5lci50b3AgKyBvZmZzZXQudG9wKTtcbiAgfSBlbHNlIGlmIChlZGdlcy5ib3R0b20pIHtcbiAgICBjb29yZHMueSA9IE1hdGgubWF4KE1hdGgubWluKG91dGVyLmJvdHRvbSArIG9mZnNldC5ib3R0b20sIHBhZ2UueSksIGlubmVyLmJvdHRvbSArIG9mZnNldC5ib3R0b20pO1xuICB9XG5cbiAgaWYgKGVkZ2VzLmxlZnQpIHtcbiAgICBjb29yZHMueCA9IE1hdGgubWluKE1hdGgubWF4KG91dGVyLmxlZnQgKyBvZmZzZXQubGVmdCwgcGFnZS54KSwgaW5uZXIubGVmdCArIG9mZnNldC5sZWZ0KTtcbiAgfSBlbHNlIGlmIChlZGdlcy5yaWdodCkge1xuICAgIGNvb3Jkcy54ID0gTWF0aC5tYXgoTWF0aC5taW4ob3V0ZXIucmlnaHQgKyBvZmZzZXQucmlnaHQsIHBhZ2UueCksIGlubmVyLnJpZ2h0ICsgb2Zmc2V0LnJpZ2h0KTtcbiAgfVxufVxuXG5mdW5jdGlvbiBmaXhSZWN0KHJlY3QsIGRlZmF1bHRzKSB7XG4gIGZvciAoY29uc3QgZWRnZSBvZiBbJ3RvcCcsICdsZWZ0JywgJ2JvdHRvbScsICdyaWdodCddKSB7XG4gICAgaWYgKCEoZWRnZSBpbiByZWN0KSkge1xuICAgICAgcmVjdFtlZGdlXSA9IGRlZmF1bHRzW2VkZ2VdO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiByZWN0O1xufVxuXG5jb25zdCBlZGdlc19kZWZhdWx0cyA9IHtcbiAgaW5uZXI6IG51bGwsXG4gIG91dGVyOiBudWxsLFxuICBvZmZzZXQ6IG51bGwsXG4gIGVuZE9ubHk6IGZhbHNlLFxuICBlbmFibGVkOiBmYWxzZVxufTtcbmNvbnN0IHJlc3RyaWN0RWRnZXMgPSB7XG4gIG5vSW5uZXIsXG4gIG5vT3V0ZXIsXG4gIHN0YXJ0OiBlZGdlc19zdGFydCxcbiAgc2V0OiBlZGdlc19zZXQsXG4gIGRlZmF1bHRzOiBlZGdlc19kZWZhdWx0c1xufTtcbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gdmFyIHJlc3RyaWN0X2VkZ2VzID0gKG1ha2VNb2RpZmllcihyZXN0cmljdEVkZ2VzLCAncmVzdHJpY3RFZGdlcycpKTtcblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZWRnZXMuanMubWFwXG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL25vZGVfbW9kdWxlcy9AaW50ZXJhY3Rqcy9tb2RpZmllcnMvcmVzdHJpY3QvcmVjdC5qc1xuXG5cblxuY29uc3QgcmVjdF9kZWZhdWx0cyA9IGV4dGVuZCh7XG4gIGdldCBlbGVtZW50UmVjdCgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgdG9wOiAwLFxuICAgICAgbGVmdDogMCxcbiAgICAgIGJvdHRvbTogMSxcbiAgICAgIHJpZ2h0OiAxXG4gICAgfTtcbiAgfSxcblxuICBzZXQgZWxlbWVudFJlY3QoXykge31cblxufSwgcmVzdHJpY3QuZGVmYXVsdHMpO1xuY29uc3QgcmVzdHJpY3RSZWN0ID0ge1xuICBzdGFydDogcmVzdHJpY3Quc3RhcnQsXG4gIHNldDogcmVzdHJpY3Quc2V0LFxuICBkZWZhdWx0czogcmVjdF9kZWZhdWx0c1xufTtcbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gdmFyIHJlc3RyaWN0X3JlY3QgPSAobWFrZU1vZGlmaWVyKHJlc3RyaWN0UmVjdCwgJ3Jlc3RyaWN0UmVjdCcpKTtcblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cmVjdC5qcy5tYXBcbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vbm9kZV9tb2R1bGVzL0BpbnRlcmFjdGpzL21vZGlmaWVycy9yZXN0cmljdC9zaXplLmpzXG5cblxuXG5cblxuY29uc3Qgbm9NaW4gPSB7XG4gIHdpZHRoOiAtSW5maW5pdHksXG4gIGhlaWdodDogLUluZmluaXR5XG59O1xuY29uc3Qgbm9NYXggPSB7XG4gIHdpZHRoOiArSW5maW5pdHksXG4gIGhlaWdodDogK0luZmluaXR5XG59O1xuXG5mdW5jdGlvbiBzaXplX3N0YXJ0KGFyZykge1xuICByZXR1cm4gcmVzdHJpY3RFZGdlcy5zdGFydChhcmcpO1xufVxuXG5mdW5jdGlvbiBzaXplX3NldChhcmcpIHtcbiAgY29uc3Qge1xuICAgIGludGVyYWN0aW9uLFxuICAgIHN0YXRlLFxuICAgIHJlY3QsXG4gICAgZWRnZXNcbiAgfSA9IGFyZztcbiAgY29uc3Qge1xuICAgIG9wdGlvbnNcbiAgfSA9IHN0YXRlO1xuXG4gIGlmICghZWRnZXMpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBjb25zdCBtaW5TaXplID0gdGxiclRvWHl3aChnZXRSZXN0cmljdGlvblJlY3Qob3B0aW9ucy5taW4sIGludGVyYWN0aW9uLCBhcmcuY29vcmRzKSkgfHwgbm9NaW47XG4gIGNvbnN0IG1heFNpemUgPSB0bGJyVG9YeXdoKGdldFJlc3RyaWN0aW9uUmVjdChvcHRpb25zLm1heCwgaW50ZXJhY3Rpb24sIGFyZy5jb29yZHMpKSB8fCBub01heDtcbiAgc3RhdGUub3B0aW9ucyA9IHtcbiAgICBlbmRPbmx5OiBvcHRpb25zLmVuZE9ubHksXG4gICAgaW5uZXI6IGV4dGVuZCh7fSwgcmVzdHJpY3RFZGdlcy5ub0lubmVyKSxcbiAgICBvdXRlcjogZXh0ZW5kKHt9LCByZXN0cmljdEVkZ2VzLm5vT3V0ZXIpXG4gIH07XG5cbiAgaWYgKGVkZ2VzLnRvcCkge1xuICAgIHN0YXRlLm9wdGlvbnMuaW5uZXIudG9wID0gcmVjdC5ib3R0b20gLSBtaW5TaXplLmhlaWdodDtcbiAgICBzdGF0ZS5vcHRpb25zLm91dGVyLnRvcCA9IHJlY3QuYm90dG9tIC0gbWF4U2l6ZS5oZWlnaHQ7XG4gIH0gZWxzZSBpZiAoZWRnZXMuYm90dG9tKSB7XG4gICAgc3RhdGUub3B0aW9ucy5pbm5lci5ib3R0b20gPSByZWN0LnRvcCArIG1pblNpemUuaGVpZ2h0O1xuICAgIHN0YXRlLm9wdGlvbnMub3V0ZXIuYm90dG9tID0gcmVjdC50b3AgKyBtYXhTaXplLmhlaWdodDtcbiAgfVxuXG4gIGlmIChlZGdlcy5sZWZ0KSB7XG4gICAgc3RhdGUub3B0aW9ucy5pbm5lci5sZWZ0ID0gcmVjdC5yaWdodCAtIG1pblNpemUud2lkdGg7XG4gICAgc3RhdGUub3B0aW9ucy5vdXRlci5sZWZ0ID0gcmVjdC5yaWdodCAtIG1heFNpemUud2lkdGg7XG4gIH0gZWxzZSBpZiAoZWRnZXMucmlnaHQpIHtcbiAgICBzdGF0ZS5vcHRpb25zLmlubmVyLnJpZ2h0ID0gcmVjdC5sZWZ0ICsgbWluU2l6ZS53aWR0aDtcbiAgICBzdGF0ZS5vcHRpb25zLm91dGVyLnJpZ2h0ID0gcmVjdC5sZWZ0ICsgbWF4U2l6ZS53aWR0aDtcbiAgfVxuXG4gIHJlc3RyaWN0RWRnZXMuc2V0KGFyZyk7XG4gIHN0YXRlLm9wdGlvbnMgPSBvcHRpb25zO1xufVxuXG5jb25zdCBzaXplX2RlZmF1bHRzID0ge1xuICBtaW46IG51bGwsXG4gIG1heDogbnVsbCxcbiAgZW5kT25seTogZmFsc2UsXG4gIGVuYWJsZWQ6IGZhbHNlXG59O1xuY29uc3QgcmVzdHJpY3RTaXplID0ge1xuICBzdGFydDogc2l6ZV9zdGFydCxcbiAgc2V0OiBzaXplX3NldCxcbiAgZGVmYXVsdHM6IHNpemVfZGVmYXVsdHNcbn07XG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIHZhciBzaXplID0gKG1ha2VNb2RpZmllcihyZXN0cmljdFNpemUsICdyZXN0cmljdFNpemUnKSk7XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXNpemUuanMubWFwXG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL25vZGVfbW9kdWxlcy9AaW50ZXJhY3Rqcy9tb2RpZmllcnMvc25hcC9wb2ludGVyLmpzXG5cblxuXG5cblxuXG5cbmZ1bmN0aW9uIHNuYXBfcG9pbnRlcl9zdGFydChhcmcpIHtcbiAgY29uc3Qge1xuICAgIGludGVyYWN0aW9uLFxuICAgIGludGVyYWN0YWJsZSxcbiAgICBlbGVtZW50LFxuICAgIHJlY3QsXG4gICAgc3RhdGUsXG4gICAgc3RhcnRPZmZzZXRcbiAgfSA9IGFyZztcbiAgY29uc3Qge1xuICAgIG9wdGlvbnNcbiAgfSA9IHN0YXRlO1xuICBjb25zdCBvcmlnaW4gPSBvcHRpb25zLm9mZnNldFdpdGhPcmlnaW4gPyBnZXRPcmlnaW4oYXJnKSA6IHtcbiAgICB4OiAwLFxuICAgIHk6IDBcbiAgfTtcbiAgbGV0IHNuYXBPZmZzZXQ7XG5cbiAgaWYgKG9wdGlvbnMub2Zmc2V0ID09PSAnc3RhcnRDb29yZHMnKSB7XG4gICAgc25hcE9mZnNldCA9IHtcbiAgICAgIHg6IGludGVyYWN0aW9uLmNvb3Jkcy5zdGFydC5wYWdlLngsXG4gICAgICB5OiBpbnRlcmFjdGlvbi5jb29yZHMuc3RhcnQucGFnZS55XG4gICAgfTtcbiAgfSBlbHNlIHtcbiAgICBjb25zdCBvZmZzZXRSZWN0ID0gcmVzb2x2ZVJlY3RMaWtlKG9wdGlvbnMub2Zmc2V0LCBpbnRlcmFjdGFibGUsIGVsZW1lbnQsIFtpbnRlcmFjdGlvbl0pO1xuICAgIHNuYXBPZmZzZXQgPSByZWN0VG9YWShvZmZzZXRSZWN0KSB8fCB7XG4gICAgICB4OiAwLFxuICAgICAgeTogMFxuICAgIH07XG4gICAgc25hcE9mZnNldC54ICs9IG9yaWdpbi54O1xuICAgIHNuYXBPZmZzZXQueSArPSBvcmlnaW4ueTtcbiAgfVxuXG4gIGNvbnN0IHtcbiAgICByZWxhdGl2ZVBvaW50c1xuICB9ID0gb3B0aW9ucztcbiAgc3RhdGUub2Zmc2V0cyA9IHJlY3QgJiYgcmVsYXRpdmVQb2ludHMgJiYgcmVsYXRpdmVQb2ludHMubGVuZ3RoID8gcmVsYXRpdmVQb2ludHMubWFwKChyZWxhdGl2ZVBvaW50LCBpbmRleCkgPT4gKHtcbiAgICBpbmRleCxcbiAgICByZWxhdGl2ZVBvaW50LFxuICAgIHg6IHN0YXJ0T2Zmc2V0LmxlZnQgLSByZWN0LndpZHRoICogcmVsYXRpdmVQb2ludC54ICsgc25hcE9mZnNldC54LFxuICAgIHk6IHN0YXJ0T2Zmc2V0LnRvcCAtIHJlY3QuaGVpZ2h0ICogcmVsYXRpdmVQb2ludC55ICsgc25hcE9mZnNldC55XG4gIH0pKSA6IFtleHRlbmQoe1xuICAgIGluZGV4OiAwLFxuICAgIHJlbGF0aXZlUG9pbnQ6IG51bGxcbiAgfSwgc25hcE9mZnNldCldO1xufVxuXG5mdW5jdGlvbiBwb2ludGVyX3NldChhcmcpIHtcbiAgY29uc3Qge1xuICAgIGludGVyYWN0aW9uLFxuICAgIGNvb3JkcyxcbiAgICBzdGF0ZVxuICB9ID0gYXJnO1xuICBjb25zdCB7XG4gICAgb3B0aW9ucyxcbiAgICBvZmZzZXRzXG4gIH0gPSBzdGF0ZTtcbiAgY29uc3Qgb3JpZ2luID0gZ2V0T3JpZ2luWFkoaW50ZXJhY3Rpb24uaW50ZXJhY3RhYmxlLCBpbnRlcmFjdGlvbi5lbGVtZW50LCBpbnRlcmFjdGlvbi5wcmVwYXJlZC5uYW1lKTtcbiAgY29uc3QgcGFnZSA9IGV4dGVuZCh7fSwgY29vcmRzKTtcbiAgY29uc3QgdGFyZ2V0cyA9IFtdO1xuXG4gIGlmICghb3B0aW9ucy5vZmZzZXRXaXRoT3JpZ2luKSB7XG4gICAgcGFnZS54IC09IG9yaWdpbi54O1xuICAgIHBhZ2UueSAtPSBvcmlnaW4ueTtcbiAgfVxuXG4gIGZvciAoY29uc3Qgb2Zmc2V0IG9mIG9mZnNldHMpIHtcbiAgICBjb25zdCByZWxhdGl2ZVggPSBwYWdlLnggLSBvZmZzZXQueDtcbiAgICBjb25zdCByZWxhdGl2ZVkgPSBwYWdlLnkgLSBvZmZzZXQueTtcblxuICAgIGZvciAobGV0IGluZGV4ID0gMCwgbGVuID0gb3B0aW9ucy50YXJnZXRzLmxlbmd0aDsgaW5kZXggPCBsZW47IGluZGV4KyspIHtcbiAgICAgIGNvbnN0IHNuYXBUYXJnZXQgPSBvcHRpb25zLnRhcmdldHNbaW5kZXhdO1xuICAgICAgbGV0IHRhcmdldDtcblxuICAgICAgaWYgKGlzLmZ1bmMoc25hcFRhcmdldCkpIHtcbiAgICAgICAgdGFyZ2V0ID0gc25hcFRhcmdldChyZWxhdGl2ZVgsIHJlbGF0aXZlWSwgaW50ZXJhY3Rpb24uX3Byb3h5LCBvZmZzZXQsIGluZGV4KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRhcmdldCA9IHNuYXBUYXJnZXQ7XG4gICAgICB9XG5cbiAgICAgIGlmICghdGFyZ2V0KSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICB0YXJnZXRzLnB1c2goe1xuICAgICAgICB4OiAoaXMubnVtYmVyKHRhcmdldC54KSA/IHRhcmdldC54IDogcmVsYXRpdmVYKSArIG9mZnNldC54LFxuICAgICAgICB5OiAoaXMubnVtYmVyKHRhcmdldC55KSA/IHRhcmdldC55IDogcmVsYXRpdmVZKSArIG9mZnNldC55LFxuICAgICAgICByYW5nZTogaXMubnVtYmVyKHRhcmdldC5yYW5nZSkgPyB0YXJnZXQucmFuZ2UgOiBvcHRpb25zLnJhbmdlLFxuICAgICAgICBzb3VyY2U6IHNuYXBUYXJnZXQsXG4gICAgICAgIGluZGV4LFxuICAgICAgICBvZmZzZXRcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuXG4gIGNvbnN0IGNsb3Nlc3QgPSB7XG4gICAgdGFyZ2V0OiBudWxsLFxuICAgIGluUmFuZ2U6IGZhbHNlLFxuICAgIGRpc3RhbmNlOiAwLFxuICAgIHJhbmdlOiAwLFxuICAgIGRlbHRhOiB7XG4gICAgICB4OiAwLFxuICAgICAgeTogMFxuICAgIH1cbiAgfTtcblxuICBmb3IgKGNvbnN0IHRhcmdldCBvZiB0YXJnZXRzKSB7XG4gICAgY29uc3QgcmFuZ2UgPSB0YXJnZXQucmFuZ2U7XG4gICAgY29uc3QgZHggPSB0YXJnZXQueCAtIHBhZ2UueDtcbiAgICBjb25zdCBkeSA9IHRhcmdldC55IC0gcGFnZS55O1xuICAgIGNvbnN0IGRpc3RhbmNlID0gaHlwb3QoZHgsIGR5KTtcbiAgICBsZXQgaW5SYW5nZSA9IGRpc3RhbmNlIDw9IHJhbmdlOyAvLyBJbmZpbml0ZSB0YXJnZXRzIGNvdW50IGFzIGJlaW5nIG91dCBvZiByYW5nZVxuICAgIC8vIGNvbXBhcmVkIHRvIG5vbiBpbmZpbml0ZSBvbmVzIHRoYXQgYXJlIGluIHJhbmdlXG5cbiAgICBpZiAocmFuZ2UgPT09IEluZmluaXR5ICYmIGNsb3Nlc3QuaW5SYW5nZSAmJiBjbG9zZXN0LnJhbmdlICE9PSBJbmZpbml0eSkge1xuICAgICAgaW5SYW5nZSA9IGZhbHNlO1xuICAgIH1cblxuICAgIGlmICghY2xvc2VzdC50YXJnZXQgfHwgKGluUmFuZ2UgLy8gaXMgdGhlIGNsb3Nlc3QgdGFyZ2V0IGluIHJhbmdlP1xuICAgID8gY2xvc2VzdC5pblJhbmdlICYmIHJhbmdlICE9PSBJbmZpbml0eSAvLyB0aGUgcG9pbnRlciBpcyByZWxhdGl2ZWx5IGRlZXBlciBpbiB0aGlzIHRhcmdldFxuICAgID8gZGlzdGFuY2UgLyByYW5nZSA8IGNsb3Nlc3QuZGlzdGFuY2UgLyBjbG9zZXN0LnJhbmdlIC8vIHRoaXMgdGFyZ2V0IGhhcyBJbmZpbml0ZSByYW5nZSBhbmQgdGhlIGNsb3Nlc3QgZG9lc24ndFxuICAgIDogcmFuZ2UgPT09IEluZmluaXR5ICYmIGNsb3Nlc3QucmFuZ2UgIT09IEluZmluaXR5IHx8IC8vIE9SIHRoaXMgdGFyZ2V0IGlzIGNsb3NlciB0aGF0IHRoZSBwcmV2aW91cyBjbG9zZXN0XG4gICAgZGlzdGFuY2UgPCBjbG9zZXN0LmRpc3RhbmNlIDogLy8gVGhlIG90aGVyIGlzIG5vdCBpbiByYW5nZSBhbmQgdGhlIHBvaW50ZXIgaXMgY2xvc2VyIHRvIHRoaXMgdGFyZ2V0XG4gICAgIWNsb3Nlc3QuaW5SYW5nZSAmJiBkaXN0YW5jZSA8IGNsb3Nlc3QuZGlzdGFuY2UpKSB7XG4gICAgICBjbG9zZXN0LnRhcmdldCA9IHRhcmdldDtcbiAgICAgIGNsb3Nlc3QuZGlzdGFuY2UgPSBkaXN0YW5jZTtcbiAgICAgIGNsb3Nlc3QucmFuZ2UgPSByYW5nZTtcbiAgICAgIGNsb3Nlc3QuaW5SYW5nZSA9IGluUmFuZ2U7XG4gICAgICBjbG9zZXN0LmRlbHRhLnggPSBkeDtcbiAgICAgIGNsb3Nlc3QuZGVsdGEueSA9IGR5O1xuICAgIH1cbiAgfVxuXG4gIGlmIChjbG9zZXN0LmluUmFuZ2UpIHtcbiAgICBjb29yZHMueCA9IGNsb3Nlc3QudGFyZ2V0Lng7XG4gICAgY29vcmRzLnkgPSBjbG9zZXN0LnRhcmdldC55O1xuICB9XG5cbiAgc3RhdGUuY2xvc2VzdCA9IGNsb3Nlc3Q7XG4gIHJldHVybiBjbG9zZXN0O1xufVxuXG5mdW5jdGlvbiBnZXRPcmlnaW4oYXJnKSB7XG4gIGNvbnN0IHtcbiAgICBlbGVtZW50XG4gIH0gPSBhcmcuaW50ZXJhY3Rpb247XG4gIGNvbnN0IG9wdGlvbnNPcmlnaW4gPSByZWN0VG9YWShyZXNvbHZlUmVjdExpa2UoYXJnLnN0YXRlLm9wdGlvbnMub3JpZ2luLCBudWxsLCBudWxsLCBbZWxlbWVudF0pKTtcbiAgY29uc3Qgb3JpZ2luID0gb3B0aW9uc09yaWdpbiB8fCBnZXRPcmlnaW5YWShhcmcuaW50ZXJhY3RhYmxlLCBlbGVtZW50LCBhcmcuaW50ZXJhY3Rpb24ucHJlcGFyZWQubmFtZSk7XG4gIHJldHVybiBvcmlnaW47XG59XG5cbmNvbnN0IHNuYXBfcG9pbnRlcl9kZWZhdWx0cyA9IHtcbiAgcmFuZ2U6IEluZmluaXR5LFxuICB0YXJnZXRzOiBudWxsLFxuICBvZmZzZXQ6IG51bGwsXG4gIG9mZnNldFdpdGhPcmlnaW46IHRydWUsXG4gIG9yaWdpbjogbnVsbCxcbiAgcmVsYXRpdmVQb2ludHM6IG51bGwsXG4gIGVuZE9ubHk6IGZhbHNlLFxuICBlbmFibGVkOiBmYWxzZVxufTtcbmNvbnN0IHNuYXAgPSB7XG4gIHN0YXJ0OiBzbmFwX3BvaW50ZXJfc3RhcnQsXG4gIHNldDogcG9pbnRlcl9zZXQsXG4gIGRlZmF1bHRzOiBzbmFwX3BvaW50ZXJfZGVmYXVsdHNcbn07XG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIHZhciBzbmFwX3BvaW50ZXIgPSAobWFrZU1vZGlmaWVyKHNuYXAsICdzbmFwJykpO1xuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1wb2ludGVyLmpzLm1hcFxuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9ub2RlX21vZHVsZXMvQGludGVyYWN0anMvbW9kaWZpZXJzL3NuYXAvc2l6ZS5qc1xuLy8gVGhpcyBtb2R1bGUgYWxsb3dzIHNuYXBwaW5nIG9mIHRoZSBzaXplIG9mIHRhcmdldHMgZHVyaW5nIHJlc2l6ZVxuLy8gaW50ZXJhY3Rpb25zLlxuXG5cblxuXG5cbmZ1bmN0aW9uIHNuYXBfc2l6ZV9zdGFydChhcmcpIHtcbiAgY29uc3Qge1xuICAgIHN0YXRlLFxuICAgIGVkZ2VzXG4gIH0gPSBhcmc7XG4gIGNvbnN0IHtcbiAgICBvcHRpb25zXG4gIH0gPSBzdGF0ZTtcblxuICBpZiAoIWVkZ2VzKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICBhcmcuc3RhdGUgPSB7XG4gICAgb3B0aW9uczoge1xuICAgICAgdGFyZ2V0czogbnVsbCxcbiAgICAgIHJlbGF0aXZlUG9pbnRzOiBbe1xuICAgICAgICB4OiBlZGdlcy5sZWZ0ID8gMCA6IDEsXG4gICAgICAgIHk6IGVkZ2VzLnRvcCA/IDAgOiAxXG4gICAgICB9XSxcbiAgICAgIG9mZnNldDogb3B0aW9ucy5vZmZzZXQgfHwgJ3NlbGYnLFxuICAgICAgb3JpZ2luOiB7XG4gICAgICAgIHg6IDAsXG4gICAgICAgIHk6IDBcbiAgICAgIH0sXG4gICAgICByYW5nZTogb3B0aW9ucy5yYW5nZVxuICAgIH1cbiAgfTtcbiAgc3RhdGUudGFyZ2V0RmllbGRzID0gc3RhdGUudGFyZ2V0RmllbGRzIHx8IFtbJ3dpZHRoJywgJ2hlaWdodCddLCBbJ3gnLCAneSddXTtcbiAgc25hcC5zdGFydChhcmcpO1xuICBzdGF0ZS5vZmZzZXRzID0gYXJnLnN0YXRlLm9mZnNldHM7XG4gIGFyZy5zdGF0ZSA9IHN0YXRlO1xufVxuXG5mdW5jdGlvbiBzbmFwX3NpemVfc2V0KGFyZykge1xuICBjb25zdCB7XG4gICAgaW50ZXJhY3Rpb24sXG4gICAgc3RhdGUsXG4gICAgY29vcmRzXG4gIH0gPSBhcmc7XG4gIGNvbnN0IHtcbiAgICBvcHRpb25zLFxuICAgIG9mZnNldHNcbiAgfSA9IHN0YXRlO1xuICBjb25zdCByZWxhdGl2ZSA9IHtcbiAgICB4OiBjb29yZHMueCAtIG9mZnNldHNbMF0ueCxcbiAgICB5OiBjb29yZHMueSAtIG9mZnNldHNbMF0ueVxuICB9O1xuICBzdGF0ZS5vcHRpb25zID0gZXh0ZW5kKHt9LCBvcHRpb25zKTtcbiAgc3RhdGUub3B0aW9ucy50YXJnZXRzID0gW107XG5cbiAgZm9yIChjb25zdCBzbmFwVGFyZ2V0IG9mIG9wdGlvbnMudGFyZ2V0cyB8fCBbXSkge1xuICAgIGxldCB0YXJnZXQ7XG5cbiAgICBpZiAoaXMuZnVuYyhzbmFwVGFyZ2V0KSkge1xuICAgICAgdGFyZ2V0ID0gc25hcFRhcmdldChyZWxhdGl2ZS54LCByZWxhdGl2ZS55LCBpbnRlcmFjdGlvbik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRhcmdldCA9IHNuYXBUYXJnZXQ7XG4gICAgfVxuXG4gICAgaWYgKCF0YXJnZXQpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIGZvciAoY29uc3QgW3hGaWVsZCwgeUZpZWxkXSBvZiBzdGF0ZS50YXJnZXRGaWVsZHMpIHtcbiAgICAgIGlmICh4RmllbGQgaW4gdGFyZ2V0IHx8IHlGaWVsZCBpbiB0YXJnZXQpIHtcbiAgICAgICAgdGFyZ2V0LnggPSB0YXJnZXRbeEZpZWxkXTtcbiAgICAgICAgdGFyZ2V0LnkgPSB0YXJnZXRbeUZpZWxkXTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuXG4gICAgc3RhdGUub3B0aW9ucy50YXJnZXRzLnB1c2godGFyZ2V0KTtcbiAgfVxuXG4gIGNvbnN0IHJldHVyblZhbHVlID0gc25hcC5zZXQoYXJnKTtcbiAgc3RhdGUub3B0aW9ucyA9IG9wdGlvbnM7XG4gIHJldHVybiByZXR1cm5WYWx1ZTtcbn1cblxuY29uc3Qgc25hcF9zaXplX2RlZmF1bHRzID0ge1xuICByYW5nZTogSW5maW5pdHksXG4gIHRhcmdldHM6IG51bGwsXG4gIG9mZnNldDogbnVsbCxcbiAgZW5kT25seTogZmFsc2UsXG4gIGVuYWJsZWQ6IGZhbHNlXG59O1xuY29uc3Qgc25hcFNpemUgPSB7XG4gIHN0YXJ0OiBzbmFwX3NpemVfc3RhcnQsXG4gIHNldDogc25hcF9zaXplX3NldCxcbiAgZGVmYXVsdHM6IHNuYXBfc2l6ZV9kZWZhdWx0c1xufTtcbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gdmFyIHNuYXBfc2l6ZSA9IChtYWtlTW9kaWZpZXIoc25hcFNpemUsICdzbmFwU2l6ZScpKTtcblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c2l6ZS5qcy5tYXBcbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vbm9kZV9tb2R1bGVzL0BpbnRlcmFjdGpzL21vZGlmaWVycy9zbmFwL2VkZ2VzLmpzXG4vKipcbiAqIEBtb2R1bGUgbW9kaWZpZXJzL3NuYXBFZGdlc1xuICpcbiAqIEBkZXNjcmlwdGlvblxuICogV09XPiBUaGlzIG1vZHVsZSBhbGxvd3Mgc25hcHBpbmcgb2YgdGhlIGVkZ2VzIG9mIHRhcmdldHMgZHVyaW5nIHJlc2l6ZVxuICogaW50ZXJhY3Rpb25zLlxuICpcbiAqIGBgYGpzXG4gKiBpbnRlcmFjdCh0YXJnZXQpLnJlc2l6YWJsZSh7XG4gKiAgIHNuYXBFZGdlczoge1xuICogICAgIHRhcmdldHM6IFtpbnRlcmFjdC5zbmFwcGVycy5ncmlkKHsgeDogMTAwLCB5OiA1MCB9KV0sXG4gKiAgIH0sXG4gKiB9KVxuICpcbiAqIGludGVyYWN0KHRhcmdldCkucmVzaXphYmxlKHtcbiAqICAgc25hcEVkZ2VzOiB7XG4gKiAgICAgdGFyZ2V0czogW1xuICogICAgICAgaW50ZXJhY3Quc25hcHBlcnMuZ3JpZCh7XG4gKiAgICAgICAgdG9wOiA1MCxcbiAqICAgICAgICBsZWZ0OiA1MCxcbiAqICAgICAgICBib3R0b206IDEwMCxcbiAqICAgICAgICByaWdodDogMTAwLFxuICogICAgICAgfSksXG4gKiAgICAgXSxcbiAqICAgfSxcbiAqIH0pXG4gKiBgYGBcbiAqL1xuXG5cblxuXG5cbmZ1bmN0aW9uIHNuYXBfZWRnZXNfc3RhcnQoYXJnKSB7XG4gIGNvbnN0IHtcbiAgICBlZGdlc1xuICB9ID0gYXJnO1xuXG4gIGlmICghZWRnZXMpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIGFyZy5zdGF0ZS50YXJnZXRGaWVsZHMgPSBhcmcuc3RhdGUudGFyZ2V0RmllbGRzIHx8IFtbZWRnZXMubGVmdCA/ICdsZWZ0JyA6ICdyaWdodCcsIGVkZ2VzLnRvcCA/ICd0b3AnIDogJ2JvdHRvbSddXTtcbiAgcmV0dXJuIHNuYXBTaXplLnN0YXJ0KGFyZyk7XG59XG5cbmNvbnN0IHNuYXBFZGdlcyA9IHtcbiAgc3RhcnQ6IHNuYXBfZWRnZXNfc3RhcnQsXG4gIHNldDogc25hcFNpemUuc2V0LFxuICBkZWZhdWx0czogZXh0ZW5kKGNsb25lKHNuYXBTaXplLmRlZmF1bHRzKSwge1xuICAgIHRhcmdldHM6IG51bGwsXG4gICAgcmFuZ2U6IG51bGwsXG4gICAgb2Zmc2V0OiB7XG4gICAgICB4OiAwLFxuICAgICAgeTogMFxuICAgIH1cbiAgfSlcbn07XG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIHZhciBzbmFwX2VkZ2VzID0gKG1ha2VNb2RpZmllcihzbmFwRWRnZXMsICdzbmFwRWRnZXMnKSk7XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWVkZ2VzLmpzLm1hcFxuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9ub2RlX21vZHVsZXMvQGludGVyYWN0anMvbW9kaWZpZXJzL2FsbC5qc1xuLyogZXNsaW50LWRpc2FibGUgbm9kZS9uby1leHRyYW5lb3VzLWltcG9ydCAqL1xuXG5cblxuXG5cblxuXG5cblxuXG5cblxuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyB2YXIgbW9kaWZpZXJzX2FsbCA9ICh7XG4gIGFzcGVjdFJhdGlvOiBtb2RpZmllcnNfYXNwZWN0UmF0aW8sXG4gIHJlc3RyaWN0RWRnZXM6IHJlc3RyaWN0X2VkZ2VzLFxuICByZXN0cmljdDogcmVzdHJpY3RfcG9pbnRlcixcbiAgcmVzdHJpY3RSZWN0OiByZXN0cmljdF9yZWN0LFxuICByZXN0cmljdFNpemU6IHNpemUsXG4gIHNuYXBFZGdlczogc25hcF9lZGdlcyxcbiAgc25hcDogc25hcF9wb2ludGVyLFxuICBzbmFwU2l6ZTogc25hcF9zaXplLFxuICBzcHJpbmc6IG1vZGlmaWVyc19ub29wLFxuICBhdm9pZDogbW9kaWZpZXJzX25vb3AsXG4gIHRyYW5zZm9ybTogbW9kaWZpZXJzX25vb3AsXG4gIHJ1YmJlcmJhbmQ6IG1vZGlmaWVyc19ub29wXG59KTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWFsbC5qcy5tYXBcbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vbm9kZV9tb2R1bGVzL0BpbnRlcmFjdGpzL21vZGlmaWVycy9wbHVnaW4uanNcblxuXG5cbmNvbnN0IHBsdWdpbl9tb2RpZmllcnMgPSB7XG4gIGlkOiAnbW9kaWZpZXJzJyxcblxuICBpbnN0YWxsKHNjb3BlKSB7XG4gICAgY29uc3Qge1xuICAgICAgaW50ZXJhY3RTdGF0aWM6IGludGVyYWN0XG4gICAgfSA9IHNjb3BlO1xuICAgIHNjb3BlLnVzZVBsdWdpbihtb2RpZmllcnNfYmFzZSk7XG4gICAgc2NvcGUudXNlUGx1Z2luKHNuYXBwZXJzX3BsdWdpbik7XG4gICAgaW50ZXJhY3QubW9kaWZpZXJzID0gbW9kaWZpZXJzX2FsbDsgLy8gZm9yIGJhY2t3cmFkcyBjb21wYXRpYmlsaXR5XG5cbiAgICBmb3IgKGNvbnN0IHR5cGUgaW4gbW9kaWZpZXJzX2FsbCkge1xuICAgICAgY29uc3Qge1xuICAgICAgICBfZGVmYXVsdHMsXG4gICAgICAgIF9tZXRob2RzXG4gICAgICB9ID0gbW9kaWZpZXJzX2FsbFt0eXBlXTtcbiAgICAgIF9kZWZhdWx0cy5fbWV0aG9kcyA9IF9tZXRob2RzO1xuICAgICAgc2NvcGUuZGVmYXVsdHMucGVyQWN0aW9uW3R5cGVdID0gX2RlZmF1bHRzO1xuICAgIH1cbiAgfVxuXG59O1xuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyB2YXIgbW9kaWZpZXJzX3BsdWdpbiA9IChwbHVnaW5fbW9kaWZpZXJzKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXBsdWdpbi5qcy5tYXBcbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vbm9kZV9tb2R1bGVzL0BpbnRlcmFjdGpzL21vZGlmaWVycy9pbmRleC5qc1xuLyogZXNsaW50LWRpc2FibGUgaW1wb3J0L29yZGVyLCBuby1jb25zb2xlLCBlb2wtbGFzdCAqL1xuXG5cblxuaWYgKHR5cGVvZiB3aW5kb3cgPT09ICdvYmplY3QnICYmICEhd2luZG93KSB7XG4gIGludGVyYWN0X2luaXQod2luZG93KTtcbn1cblxuX2ludGVyYWN0anNfaW50ZXJhY3QudXNlKG1vZGlmaWVyc19wbHVnaW4pO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwXG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL25vZGVfbW9kdWxlcy9AaW50ZXJhY3Rqcy9kZXYtdG9vbHMvcGx1Z2luLmpzXG4vKiBlc2xpbnQtZGlzYWJsZSBuby1jb25zb2xlICovXG5cblxuXG5cblxuXG52YXIgQ2hlY2tOYW1lO1xuXG4oZnVuY3Rpb24gKENoZWNrTmFtZSkge1xuICBDaGVja05hbWVbXCJ0b3VjaEFjdGlvblwiXSA9IFwidG91Y2hBY3Rpb25cIjtcbiAgQ2hlY2tOYW1lW1wiYm94U2l6aW5nXCJdID0gXCJib3hTaXppbmdcIjtcbiAgQ2hlY2tOYW1lW1wibm9MaXN0ZW5lcnNcIl0gPSBcIm5vTGlzdGVuZXJzXCI7XG59KShDaGVja05hbWUgfHwgKENoZWNrTmFtZSA9IHt9KSk7XG5cbmNvbnN0IHByZWZpeCA9ICdbaW50ZXJhY3QuanNdICc7XG5jb25zdCBsaW5rcyA9IHtcbiAgdG91Y2hBY3Rpb246ICdodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9DU1MvdG91Y2gtYWN0aW9uJyxcbiAgYm94U2l6aW5nOiAnaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQ1NTL2JveC1zaXppbmcnXG59OyAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdW5kZWZcblxuY29uc3QgaXNQcm9kdWN0aW9uID0gXCJkZXZlbG9wbWVudFwiID09PSAncHJvZHVjdGlvbic7IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1yZXN0cmljdGVkLXN5bnRheFxuXG5mdW5jdGlvbiBkZXZfdG9vbHNfcGx1Z2luX2luc3RhbGwoc2NvcGUsIHtcbiAgbG9nZ2VyXG59ID0ge30pIHtcbiAgY29uc3Qge1xuICAgIEludGVyYWN0YWJsZSxcbiAgICBkZWZhdWx0c1xuICB9ID0gc2NvcGU7XG4gIHNjb3BlLmxvZ2dlciA9IGxvZ2dlciB8fCBjb25zb2xlO1xuICBkZWZhdWx0cy5iYXNlLmRldlRvb2xzID0ge1xuICAgIGlnbm9yZToge31cbiAgfTtcblxuICBJbnRlcmFjdGFibGUucHJvdG90eXBlLmRldlRvb2xzID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICBpZiAob3B0aW9ucykge1xuICAgICAgZXh0ZW5kKHRoaXMub3B0aW9ucy5kZXZUb29scywgb3B0aW9ucyk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5vcHRpb25zLmRldlRvb2xzO1xuICB9O1xufVxuXG5jb25zdCBjaGVja3MgPSBbe1xuICBuYW1lOiBDaGVja05hbWUudG91Y2hBY3Rpb24sXG5cbiAgcGVyZm9ybSh7XG4gICAgZWxlbWVudFxuICB9KSB7XG4gICAgcmV0dXJuICFwYXJlbnRIYXNTdHlsZShlbGVtZW50LCAndG91Y2hBY3Rpb24nLCAvcGFuLXxwaW5jaHxub25lLyk7XG4gIH0sXG5cbiAgZ2V0SW5mbyh7XG4gICAgZWxlbWVudFxuICB9KSB7XG4gICAgcmV0dXJuIFtlbGVtZW50LCBsaW5rcy50b3VjaEFjdGlvbl07XG4gIH0sXG5cbiAgdGV4dDogJ0NvbnNpZGVyIGFkZGluZyBDU1MgXCJ0b3VjaC1hY3Rpb246IG5vbmVcIiB0byB0aGlzIGVsZW1lbnRcXG4nXG59LCB7XG4gIG5hbWU6IENoZWNrTmFtZS5ib3hTaXppbmcsXG5cbiAgcGVyZm9ybShpbnRlcmFjdGlvbikge1xuICAgIGNvbnN0IHtcbiAgICAgIGVsZW1lbnRcbiAgICB9ID0gaW50ZXJhY3Rpb247XG4gICAgcmV0dXJuIGludGVyYWN0aW9uLnByZXBhcmVkLm5hbWUgPT09ICdyZXNpemUnICYmIGVsZW1lbnQgaW5zdGFuY2VvZiB1dGlsc19kb21PYmplY3RzLkhUTUxFbGVtZW50ICYmICFoYXNTdHlsZShlbGVtZW50LCAnYm94U2l6aW5nJywgL2JvcmRlci1ib3gvKTtcbiAgfSxcblxuICB0ZXh0OiAnQ29uc2lkZXIgYWRkaW5nIENTUyBcImJveC1zaXppbmc6IGJvcmRlci1ib3hcIiB0byB0aGlzIHJlc2l6YWJsZSBlbGVtZW50JyxcblxuICBnZXRJbmZvKHtcbiAgICBlbGVtZW50XG4gIH0pIHtcbiAgICByZXR1cm4gW2VsZW1lbnQsIGxpbmtzLmJveFNpemluZ107XG4gIH1cblxufSwge1xuICBuYW1lOiBDaGVja05hbWUubm9MaXN0ZW5lcnMsXG5cbiAgcGVyZm9ybShpbnRlcmFjdGlvbikge1xuICAgIGNvbnN0IGFjdGlvbk5hbWUgPSBpbnRlcmFjdGlvbi5wcmVwYXJlZC5uYW1lO1xuICAgIGNvbnN0IG1vdmVMaXN0ZW5lcnMgPSBpbnRlcmFjdGlvbi5pbnRlcmFjdGFibGUuZXZlbnRzLnR5cGVzW2Ake2FjdGlvbk5hbWV9bW92ZWBdIHx8IFtdO1xuICAgIHJldHVybiAhbW92ZUxpc3RlbmVycy5sZW5ndGg7XG4gIH0sXG5cbiAgZ2V0SW5mbyhpbnRlcmFjdGlvbikge1xuICAgIHJldHVybiBbaW50ZXJhY3Rpb24ucHJlcGFyZWQubmFtZSwgaW50ZXJhY3Rpb24uaW50ZXJhY3RhYmxlXTtcbiAgfSxcblxuICB0ZXh0OiAnVGhlcmUgYXJlIG5vIGxpc3RlbmVycyBzZXQgZm9yIHRoaXMgYWN0aW9uJ1xufV07XG5cbmZ1bmN0aW9uIGhhc1N0eWxlKGVsZW1lbnQsIHByb3AsIHN0eWxlUmUpIHtcbiAgY29uc3QgdmFsdWUgPSBlbGVtZW50LnN0eWxlW3Byb3BdIHx8IHdpbi5nZXRDb21wdXRlZFN0eWxlKGVsZW1lbnQpW3Byb3BdO1xuICByZXR1cm4gc3R5bGVSZS50ZXN0KCh2YWx1ZSB8fCAnJykudG9TdHJpbmcoKSk7XG59XG5cbmZ1bmN0aW9uIHBhcmVudEhhc1N0eWxlKGVsZW1lbnQsIHByb3AsIHN0eWxlUmUpIHtcbiAgbGV0IHBhcmVudCA9IGVsZW1lbnQ7XG5cbiAgd2hpbGUgKGlzLmVsZW1lbnQocGFyZW50KSkge1xuICAgIGlmIChoYXNTdHlsZShwYXJlbnQsIHByb3AsIHN0eWxlUmUpKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICBwYXJlbnQgPSBwYXJlbnROb2RlKHBhcmVudCk7XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59XG5cbmNvbnN0IHBsdWdpbl9pZCA9ICdkZXYtdG9vbHMnO1xuY29uc3QgZGVmYXVsdEV4cG9ydCA9IGlzUHJvZHVjdGlvbiA/IHtcbiAgaWQ6IHBsdWdpbl9pZCxcbiAgaW5zdGFsbDogKCkgPT4ge31cbn0gOiB7XG4gIGlkOiBwbHVnaW5faWQsXG4gIGluc3RhbGw6IGRldl90b29sc19wbHVnaW5faW5zdGFsbCxcbiAgbGlzdGVuZXJzOiB7XG4gICAgJ2ludGVyYWN0aW9uczphY3Rpb24tc3RhcnQnOiAoe1xuICAgICAgaW50ZXJhY3Rpb25cbiAgICB9LCBzY29wZSkgPT4ge1xuICAgICAgZm9yIChjb25zdCBjaGVjayBvZiBjaGVja3MpIHtcbiAgICAgICAgY29uc3Qgb3B0aW9ucyA9IGludGVyYWN0aW9uLmludGVyYWN0YWJsZSAmJiBpbnRlcmFjdGlvbi5pbnRlcmFjdGFibGUub3B0aW9ucztcblxuICAgICAgICBpZiAoIShvcHRpb25zICYmIG9wdGlvbnMuZGV2VG9vbHMgJiYgb3B0aW9ucy5kZXZUb29scy5pZ25vcmVbY2hlY2submFtZV0pICYmIGNoZWNrLnBlcmZvcm0oaW50ZXJhY3Rpb24pKSB7XG4gICAgICAgICAgc2NvcGUubG9nZ2VyLndhcm4ocHJlZml4ICsgY2hlY2sudGV4dCwgLi4uY2hlY2suZ2V0SW5mbyhpbnRlcmFjdGlvbikpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9LFxuICBjaGVja3MsXG4gIENoZWNrTmFtZSxcbiAgbGlua3MsXG4gIHByZWZpeFxufTtcbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gdmFyIGRldl90b29sc19wbHVnaW4gPSAoZGVmYXVsdEV4cG9ydCk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1wbHVnaW4uanMubWFwXG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL25vZGVfbW9kdWxlcy9AaW50ZXJhY3Rqcy9kZXYtdG9vbHMvaW5kZXguanNcbi8qIGVzbGludC1kaXNhYmxlIGltcG9ydC9vcmRlciwgbm8tY29uc29sZSwgZW9sLWxhc3QgKi9cblxuXG5cbmlmICh0eXBlb2Ygd2luZG93ID09PSAnb2JqZWN0JyAmJiAhIXdpbmRvdykge1xuICBpbnRlcmFjdF9pbml0KHdpbmRvdyk7XG59XG5cbl9pbnRlcmFjdGpzX2ludGVyYWN0LnVzZShkZXZfdG9vbHNfcGx1Z2luKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcFxuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9ub2RlX21vZHVsZXMvY2FjaGUtbG9hZGVyL2Rpc3QvY2pzLmpzPz9yZWYtLTEyLTAhLi9ub2RlX21vZHVsZXMvdGhyZWFkLWxvYWRlci9kaXN0L2Nqcy5qcyEuL25vZGVfbW9kdWxlcy9iYWJlbC1sb2FkZXIvbGliIS4vbm9kZV9tb2R1bGVzL2NhY2hlLWxvYWRlci9kaXN0L2Nqcy5qcz8/cmVmLS0wLTAhLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWI/P3Z1ZS1sb2FkZXItb3B0aW9ucyEuL3NyYy9jb21wb25lbnRzL0dyaWRJdGVtLnZ1ZT92dWUmdHlwZT1zY3JpcHQmbGFuZz1qcyZcblxuXG5cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cblxuXG5cbiAvLyAgICB2YXIgZXZlbnRCdXMgPSByZXF1aXJlKCcuL2V2ZW50QnVzJyk7XG5cblxuXG5cblxuXG5cbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gdmFyIEdyaWRJdGVtdnVlX3R5cGVfc2NyaXB0X2xhbmdfanNfID0gKHtcbiAgbmFtZTogXCJHcmlkSXRlbVwiLFxuICBwcm9wczoge1xuICAgIC8qY29sczoge1xuICAgICB0eXBlOiBOdW1iZXIsXG4gICAgIHJlcXVpcmVkOiB0cnVlXG4gICAgIH0sKi9cblxuICAgIC8qY29udGFpbmVyV2lkdGg6IHtcbiAgICAgdHlwZTogTnVtYmVyLFxuICAgICByZXF1aXJlZDogdHJ1ZVxuICAgICAgfSxcbiAgICAgcm93SGVpZ2h0OiB7XG4gICAgIHR5cGU6IE51bWJlcixcbiAgICAgcmVxdWlyZWQ6IHRydWVcbiAgICAgfSxcbiAgICAgbWFyZ2luOiB7XG4gICAgIHR5cGU6IEFycmF5LFxuICAgICByZXF1aXJlZDogdHJ1ZVxuICAgICB9LFxuICAgICBtYXhSb3dzOiB7XG4gICAgIHR5cGU6IE51bWJlcixcbiAgICAgcmVxdWlyZWQ6IHRydWVcbiAgICAgfSwqL1xuICAgIGlzRHJhZ2dhYmxlOiB7XG4gICAgICB0eXBlOiBCb29sZWFuLFxuICAgICAgcmVxdWlyZWQ6IGZhbHNlLFxuICAgICAgZGVmYXVsdDogbnVsbFxuICAgIH0sXG4gICAgaXNSZXNpemFibGU6IHtcbiAgICAgIHR5cGU6IEJvb2xlYW4sXG4gICAgICByZXF1aXJlZDogZmFsc2UsXG4gICAgICBkZWZhdWx0OiBudWxsXG4gICAgfSxcblxuICAgIC8qdXNlQ3NzVHJhbnNmb3Jtczoge1xuICAgICB0eXBlOiBCb29sZWFuLFxuICAgICByZXF1aXJlZDogdHJ1ZVxuICAgICB9LFxuICAgICAqL1xuICAgIHN0YXRpYzoge1xuICAgICAgdHlwZTogQm9vbGVhbixcbiAgICAgIHJlcXVpcmVkOiBmYWxzZSxcbiAgICAgIGRlZmF1bHQ6IGZhbHNlXG4gICAgfSxcbiAgICBtaW5IOiB7XG4gICAgICB0eXBlOiBOdW1iZXIsXG4gICAgICByZXF1aXJlZDogZmFsc2UsXG4gICAgICBkZWZhdWx0OiAxXG4gICAgfSxcbiAgICBtaW5XOiB7XG4gICAgICB0eXBlOiBOdW1iZXIsXG4gICAgICByZXF1aXJlZDogZmFsc2UsXG4gICAgICBkZWZhdWx0OiAxXG4gICAgfSxcbiAgICBtYXhIOiB7XG4gICAgICB0eXBlOiBOdW1iZXIsXG4gICAgICByZXF1aXJlZDogZmFsc2UsXG4gICAgICBkZWZhdWx0OiBJbmZpbml0eVxuICAgIH0sXG4gICAgbWF4Vzoge1xuICAgICAgdHlwZTogTnVtYmVyLFxuICAgICAgcmVxdWlyZWQ6IGZhbHNlLFxuICAgICAgZGVmYXVsdDogSW5maW5pdHlcbiAgICB9LFxuICAgIHg6IHtcbiAgICAgIHR5cGU6IE51bWJlcixcbiAgICAgIHJlcXVpcmVkOiB0cnVlXG4gICAgfSxcbiAgICB5OiB7XG4gICAgICB0eXBlOiBOdW1iZXIsXG4gICAgICByZXF1aXJlZDogdHJ1ZVxuICAgIH0sXG4gICAgdzoge1xuICAgICAgdHlwZTogTnVtYmVyLFxuICAgICAgcmVxdWlyZWQ6IHRydWVcbiAgICB9LFxuICAgIGg6IHtcbiAgICAgIHR5cGU6IE51bWJlcixcbiAgICAgIHJlcXVpcmVkOiB0cnVlXG4gICAgfSxcbiAgICBpOiB7XG4gICAgICByZXF1aXJlZDogdHJ1ZVxuICAgIH0sXG4gICAgZHJhZ0lnbm9yZUZyb206IHtcbiAgICAgIHR5cGU6IFN0cmluZyxcbiAgICAgIHJlcXVpcmVkOiBmYWxzZSxcbiAgICAgIGRlZmF1bHQ6ICdhLCBidXR0b24nXG4gICAgfSxcbiAgICBkcmFnQWxsb3dGcm9tOiB7XG4gICAgICB0eXBlOiBTdHJpbmcsXG4gICAgICByZXF1aXJlZDogZmFsc2UsXG4gICAgICBkZWZhdWx0OiBudWxsXG4gICAgfSxcbiAgICByZXNpemVJZ25vcmVGcm9tOiB7XG4gICAgICB0eXBlOiBTdHJpbmcsXG4gICAgICByZXF1aXJlZDogZmFsc2UsXG4gICAgICBkZWZhdWx0OiAnYSwgYnV0dG9uJ1xuICAgIH0sXG4gICAgcHJlc2VydmVBc3BlY3RSYXRpbzoge1xuICAgICAgdHlwZTogQm9vbGVhbixcbiAgICAgIHJlcXVpcmVkOiBmYWxzZSxcbiAgICAgIGRlZmF1bHQ6IGZhbHNlXG4gICAgfVxuICB9LFxuICBpbmplY3Q6IFtcImV2ZW50QnVzXCIsIFwibGF5b3V0XCJdLFxuICBkYXRhOiBmdW5jdGlvbiBkYXRhKCkge1xuICAgIHJldHVybiB7XG4gICAgICBjb2xzOiAxLFxuICAgICAgY29udGFpbmVyV2lkdGg6IDEwMCxcbiAgICAgIHJvd0hlaWdodDogMzAsXG4gICAgICBtYXJnaW46IFsxMCwgMTBdLFxuICAgICAgbWF4Um93czogSW5maW5pdHksXG4gICAgICBkcmFnZ2FibGU6IG51bGwsXG4gICAgICByZXNpemFibGU6IG51bGwsXG4gICAgICB1c2VDc3NUcmFuc2Zvcm1zOiB0cnVlLFxuICAgICAgdXNlU3R5bGVDdXJzb3I6IHRydWUsXG4gICAgICBpc0RyYWdnaW5nOiBmYWxzZSxcbiAgICAgIGRyYWdnaW5nOiBudWxsLFxuICAgICAgaXNSZXNpemluZzogZmFsc2UsXG4gICAgICByZXNpemluZzogbnVsbCxcbiAgICAgIGxhc3RYOiBOYU4sXG4gICAgICBsYXN0WTogTmFOLFxuICAgICAgbGFzdFc6IE5hTixcbiAgICAgIGxhc3RIOiBOYU4sXG4gICAgICBzdHlsZToge30sXG4gICAgICBydGw6IGZhbHNlLFxuICAgICAgZHJhZ0V2ZW50U2V0OiBmYWxzZSxcbiAgICAgIHJlc2l6ZUV2ZW50U2V0OiBmYWxzZSxcbiAgICAgIHByZXZpb3VzVzogbnVsbCxcbiAgICAgIHByZXZpb3VzSDogbnVsbCxcbiAgICAgIHByZXZpb3VzWDogbnVsbCxcbiAgICAgIHByZXZpb3VzWTogbnVsbCxcbiAgICAgIGlubmVyWDogdGhpcy54LFxuICAgICAgaW5uZXJZOiB0aGlzLnksXG4gICAgICBpbm5lclc6IHRoaXMudyxcbiAgICAgIGlubmVySDogdGhpcy5oXG4gICAgfTtcbiAgfSxcbiAgY3JlYXRlZDogZnVuY3Rpb24gY3JlYXRlZCgpIHtcbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgdmFyIHNlbGYgPSB0aGlzOyAvLyBBY2Nlc3NpYmxlIHJlZmVybmNlcyBvZiBmdW5jdGlvbnMgZm9yIHJlbW92aW5nIGluIGJlZm9yZURlc3Ryb3lcblxuICAgIHNlbGYudXBkYXRlV2lkdGhIYW5kbGVyID0gZnVuY3Rpb24gKHdpZHRoKSB7XG4gICAgICBzZWxmLnVwZGF0ZVdpZHRoKHdpZHRoKTtcbiAgICB9O1xuXG4gICAgc2VsZi5jb21wYWN0SGFuZGxlciA9IGZ1bmN0aW9uIChsYXlvdXQpIHtcbiAgICAgIHNlbGYuY29tcGFjdChsYXlvdXQpO1xuICAgIH07XG5cbiAgICBzZWxmLnNldERyYWdnYWJsZUhhbmRsZXIgPSBmdW5jdGlvbiAoaXNEcmFnZ2FibGUpIHtcbiAgICAgIGlmIChzZWxmLmlzRHJhZ2dhYmxlID09PSBudWxsKSB7XG4gICAgICAgIHNlbGYuZHJhZ2dhYmxlID0gaXNEcmFnZ2FibGU7XG4gICAgICB9XG4gICAgfTtcblxuICAgIHNlbGYuc2V0UmVzaXphYmxlSGFuZGxlciA9IGZ1bmN0aW9uIChpc1Jlc2l6YWJsZSkge1xuICAgICAgaWYgKHNlbGYuaXNSZXNpemFibGUgPT09IG51bGwpIHtcbiAgICAgICAgc2VsZi5yZXNpemFibGUgPSBpc1Jlc2l6YWJsZTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgc2VsZi5zZXRSb3dIZWlnaHRIYW5kbGVyID0gZnVuY3Rpb24gKHJvd0hlaWdodCkge1xuICAgICAgc2VsZi5yb3dIZWlnaHQgPSByb3dIZWlnaHQ7XG4gICAgfTtcblxuICAgIHNlbGYuc2V0TWF4Um93c0hhbmRsZXIgPSBmdW5jdGlvbiAobWF4Um93cykge1xuICAgICAgc2VsZi5tYXhSb3dzID0gbWF4Um93cztcbiAgICB9O1xuXG4gICAgc2VsZi5kaXJlY3Rpb25jaGFuZ2VIYW5kbGVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgX3RoaXMucnRsID0gT2JqZWN0KERPTVtcImJcIiAvKiBnZXREb2N1bWVudERpciAqL10pKCkgPT09ICdydGwnO1xuXG4gICAgICBfdGhpcy5jb21wYWN0KCk7XG4gICAgfTtcblxuICAgIHNlbGYuc2V0Q29sTnVtID0gZnVuY3Rpb24gKGNvbE51bSkge1xuICAgICAgc2VsZi5jb2xzID0gcGFyc2VJbnQoY29sTnVtKTtcbiAgICB9O1xuXG4gICAgdGhpcy5ldmVudEJ1cy4kb24oJ3VwZGF0ZVdpZHRoJywgc2VsZi51cGRhdGVXaWR0aEhhbmRsZXIpO1xuICAgIHRoaXMuZXZlbnRCdXMuJG9uKCdjb21wYWN0Jywgc2VsZi5jb21wYWN0SGFuZGxlcik7XG4gICAgdGhpcy5ldmVudEJ1cy4kb24oJ3NldERyYWdnYWJsZScsIHNlbGYuc2V0RHJhZ2dhYmxlSGFuZGxlcik7XG4gICAgdGhpcy5ldmVudEJ1cy4kb24oJ3NldFJlc2l6YWJsZScsIHNlbGYuc2V0UmVzaXphYmxlSGFuZGxlcik7XG4gICAgdGhpcy5ldmVudEJ1cy4kb24oJ3NldFJvd0hlaWdodCcsIHNlbGYuc2V0Um93SGVpZ2h0SGFuZGxlcik7XG4gICAgdGhpcy5ldmVudEJ1cy4kb24oJ3NldE1heFJvd3MnLCBzZWxmLnNldE1heFJvd3NIYW5kbGVyKTtcbiAgICB0aGlzLmV2ZW50QnVzLiRvbignZGlyZWN0aW9uY2hhbmdlJywgc2VsZi5kaXJlY3Rpb25jaGFuZ2VIYW5kbGVyKTtcbiAgICB0aGlzLmV2ZW50QnVzLiRvbignc2V0Q29sTnVtJywgc2VsZi5zZXRDb2xOdW0pO1xuICAgIHRoaXMucnRsID0gT2JqZWN0KERPTVtcImJcIiAvKiBnZXREb2N1bWVudERpciAqL10pKCkgPT09ICdydGwnO1xuICB9LFxuICBiZWZvcmVEZXN0cm95OiBmdW5jdGlvbiBiZWZvcmVEZXN0cm95KCkge1xuICAgIHZhciBzZWxmID0gdGhpczsgLy9SZW1vdmUgbGlzdGVuZXJzXG5cbiAgICB0aGlzLmV2ZW50QnVzLiRvZmYoJ3VwZGF0ZVdpZHRoJywgc2VsZi51cGRhdGVXaWR0aEhhbmRsZXIpO1xuICAgIHRoaXMuZXZlbnRCdXMuJG9mZignY29tcGFjdCcsIHNlbGYuY29tcGFjdEhhbmRsZXIpO1xuICAgIHRoaXMuZXZlbnRCdXMuJG9mZignc2V0RHJhZ2dhYmxlJywgc2VsZi5zZXREcmFnZ2FibGVIYW5kbGVyKTtcbiAgICB0aGlzLmV2ZW50QnVzLiRvZmYoJ3NldFJlc2l6YWJsZScsIHNlbGYuc2V0UmVzaXphYmxlSGFuZGxlcik7XG4gICAgdGhpcy5ldmVudEJ1cy4kb2ZmKCdzZXRSb3dIZWlnaHQnLCBzZWxmLnNldFJvd0hlaWdodEhhbmRsZXIpO1xuICAgIHRoaXMuZXZlbnRCdXMuJG9mZignc2V0TWF4Um93cycsIHNlbGYuc2V0TWF4Um93c0hhbmRsZXIpO1xuICAgIHRoaXMuZXZlbnRCdXMuJG9mZignZGlyZWN0aW9uY2hhbmdlJywgc2VsZi5kaXJlY3Rpb25jaGFuZ2VIYW5kbGVyKTtcbiAgICB0aGlzLmV2ZW50QnVzLiRvZmYoJ3NldENvbE51bScsIHNlbGYuc2V0Q29sTnVtKTtcblxuICAgIGlmICh0aGlzLmludGVyYWN0T2JqKSB7XG4gICAgICB0aGlzLmludGVyYWN0T2JqLnVuc2V0KCk7IC8vIGRlc3Ryb3kgaW50ZXJhY3QgaW50YW5jZVxuICAgIH1cbiAgfSxcbiAgbW91bnRlZDogZnVuY3Rpb24gbW91bnRlZCgpIHtcbiAgICBpZiAodGhpcy5sYXlvdXQucmVzcG9uc2l2ZSAmJiB0aGlzLmxheW91dC5sYXN0QnJlYWtwb2ludCkge1xuICAgICAgdGhpcy5jb2xzID0gT2JqZWN0KHJlc3BvbnNpdmVVdGlsc1tcImNcIiAvKiBnZXRDb2xzRnJvbUJyZWFrcG9pbnQgKi9dKSh0aGlzLmxheW91dC5sYXN0QnJlYWtwb2ludCwgdGhpcy5sYXlvdXQuY29scyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuY29scyA9IHRoaXMubGF5b3V0LmNvbE51bTtcbiAgICB9XG5cbiAgICB0aGlzLnJvd0hlaWdodCA9IHRoaXMubGF5b3V0LnJvd0hlaWdodDtcbiAgICB0aGlzLmNvbnRhaW5lcldpZHRoID0gdGhpcy5sYXlvdXQud2lkdGggIT09IG51bGwgPyB0aGlzLmxheW91dC53aWR0aCA6IDEwMDtcbiAgICB0aGlzLm1hcmdpbiA9IHRoaXMubGF5b3V0Lm1hcmdpbiAhPT0gdW5kZWZpbmVkID8gdGhpcy5sYXlvdXQubWFyZ2luIDogWzEwLCAxMF07XG4gICAgdGhpcy5tYXhSb3dzID0gdGhpcy5sYXlvdXQubWF4Um93cztcblxuICAgIGlmICh0aGlzLmlzRHJhZ2dhYmxlID09PSBudWxsKSB7XG4gICAgICB0aGlzLmRyYWdnYWJsZSA9IHRoaXMubGF5b3V0LmlzRHJhZ2dhYmxlO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmRyYWdnYWJsZSA9IHRoaXMuaXNEcmFnZ2FibGU7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuaXNSZXNpemFibGUgPT09IG51bGwpIHtcbiAgICAgIHRoaXMucmVzaXphYmxlID0gdGhpcy5sYXlvdXQuaXNSZXNpemFibGU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMucmVzaXphYmxlID0gdGhpcy5pc1Jlc2l6YWJsZTtcbiAgICB9XG5cbiAgICB0aGlzLnVzZUNzc1RyYW5zZm9ybXMgPSB0aGlzLmxheW91dC51c2VDc3NUcmFuc2Zvcm1zO1xuICAgIHRoaXMudXNlU3R5bGVDdXJzb3IgPSB0aGlzLmxheW91dC51c2VTdHlsZUN1cnNvcjtcbiAgICB0aGlzLmNyZWF0ZVN0eWxlKCk7XG4gIH0sXG4gIHdhdGNoOiB7XG4gICAgaXNEcmFnZ2FibGU6IGZ1bmN0aW9uIGlzRHJhZ2dhYmxlKCkge1xuICAgICAgdGhpcy5kcmFnZ2FibGUgPSB0aGlzLmlzRHJhZ2dhYmxlO1xuICAgIH0sXG4gICAgc3RhdGljOiBmdW5jdGlvbiBfc3RhdGljKCkge1xuICAgICAgdGhpcy50cnlNYWtlRHJhZ2dhYmxlKCk7XG4gICAgICB0aGlzLnRyeU1ha2VSZXNpemFibGUoKTtcbiAgICB9LFxuICAgIGRyYWdnYWJsZTogZnVuY3Rpb24gZHJhZ2dhYmxlKCkge1xuICAgICAgdGhpcy50cnlNYWtlRHJhZ2dhYmxlKCk7XG4gICAgfSxcbiAgICBpc1Jlc2l6YWJsZTogZnVuY3Rpb24gaXNSZXNpemFibGUoKSB7XG4gICAgICB0aGlzLnJlc2l6YWJsZSA9IHRoaXMuaXNSZXNpemFibGU7XG4gICAgfSxcbiAgICByZXNpemFibGU6IGZ1bmN0aW9uIHJlc2l6YWJsZSgpIHtcbiAgICAgIHRoaXMudHJ5TWFrZVJlc2l6YWJsZSgpO1xuICAgIH0sXG4gICAgcm93SGVpZ2h0OiBmdW5jdGlvbiByb3dIZWlnaHQoKSB7XG4gICAgICB0aGlzLmNyZWF0ZVN0eWxlKCk7XG4gICAgICB0aGlzLmVtaXRDb250YWluZXJSZXNpemVkKCk7XG4gICAgfSxcbiAgICBjb2xzOiBmdW5jdGlvbiBjb2xzKCkge1xuICAgICAgdGhpcy50cnlNYWtlUmVzaXphYmxlKCk7XG4gICAgICB0aGlzLmNyZWF0ZVN0eWxlKCk7XG4gICAgICB0aGlzLmVtaXRDb250YWluZXJSZXNpemVkKCk7XG4gICAgfSxcbiAgICBjb250YWluZXJXaWR0aDogZnVuY3Rpb24gY29udGFpbmVyV2lkdGgoKSB7XG4gICAgICB0aGlzLnRyeU1ha2VSZXNpemFibGUoKTtcbiAgICAgIHRoaXMuY3JlYXRlU3R5bGUoKTtcbiAgICAgIHRoaXMuZW1pdENvbnRhaW5lclJlc2l6ZWQoKTtcbiAgICB9LFxuICAgIHg6IGZ1bmN0aW9uIHgobmV3VmFsKSB7XG4gICAgICB0aGlzLmlubmVyWCA9IG5ld1ZhbDtcbiAgICAgIHRoaXMuY3JlYXRlU3R5bGUoKTtcbiAgICB9LFxuICAgIHk6IGZ1bmN0aW9uIHkobmV3VmFsKSB7XG4gICAgICB0aGlzLmlubmVyWSA9IG5ld1ZhbDtcbiAgICAgIHRoaXMuY3JlYXRlU3R5bGUoKTtcbiAgICB9LFxuICAgIGg6IGZ1bmN0aW9uIGgobmV3VmFsKSB7XG4gICAgICB0aGlzLmlubmVySCA9IG5ld1ZhbDtcbiAgICAgIHRoaXMuY3JlYXRlU3R5bGUoKTsgLy8gdGhpcy5lbWl0Q29udGFpbmVyUmVzaXplZCgpO1xuICAgIH0sXG4gICAgdzogZnVuY3Rpb24gdyhuZXdWYWwpIHtcbiAgICAgIHRoaXMuaW5uZXJXID0gbmV3VmFsO1xuICAgICAgdGhpcy5jcmVhdGVTdHlsZSgpOyAvLyB0aGlzLmVtaXRDb250YWluZXJSZXNpemVkKCk7XG4gICAgfSxcbiAgICByZW5kZXJSdGw6IGZ1bmN0aW9uIHJlbmRlclJ0bCgpIHtcbiAgICAgIC8vIGNvbnNvbGUubG9nKFwiIyMjIHJlbmRlclJ0bFwiKTtcbiAgICAgIHRoaXMudHJ5TWFrZVJlc2l6YWJsZSgpO1xuICAgICAgdGhpcy5jcmVhdGVTdHlsZSgpO1xuICAgIH0sXG4gICAgbWluSDogZnVuY3Rpb24gbWluSCgpIHtcbiAgICAgIHRoaXMudHJ5TWFrZVJlc2l6YWJsZSgpO1xuICAgIH0sXG4gICAgbWF4SDogZnVuY3Rpb24gbWF4SCgpIHtcbiAgICAgIHRoaXMudHJ5TWFrZVJlc2l6YWJsZSgpO1xuICAgIH0sXG4gICAgbWluVzogZnVuY3Rpb24gbWluVygpIHtcbiAgICAgIHRoaXMudHJ5TWFrZVJlc2l6YWJsZSgpO1xuICAgIH0sXG4gICAgbWF4VzogZnVuY3Rpb24gbWF4VygpIHtcbiAgICAgIHRoaXMudHJ5TWFrZVJlc2l6YWJsZSgpO1xuICAgIH0sXG4gICAgXCIkcGFyZW50Lm1hcmdpblwiOiBmdW5jdGlvbiAkcGFyZW50TWFyZ2luKG1hcmdpbikge1xuICAgICAgaWYgKCFtYXJnaW4gfHwgbWFyZ2luWzBdID09IHRoaXMubWFyZ2luWzBdICYmIG1hcmdpblsxXSA9PSB0aGlzLm1hcmdpblsxXSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHRoaXMubWFyZ2luID0gbWFyZ2luLm1hcChmdW5jdGlvbiAobSkge1xuICAgICAgICByZXR1cm4gTnVtYmVyKG0pO1xuICAgICAgfSk7XG4gICAgICB0aGlzLmNyZWF0ZVN0eWxlKCk7XG4gICAgICB0aGlzLmVtaXRDb250YWluZXJSZXNpemVkKCk7XG4gICAgfVxuICB9LFxuICBjb21wdXRlZDoge1xuICAgIGNsYXNzT2JqOiBmdW5jdGlvbiBjbGFzc09iaigpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgICd2dWUtcmVzaXphYmxlJzogdGhpcy5yZXNpemFibGVBbmROb3RTdGF0aWMsXG4gICAgICAgICdzdGF0aWMnOiB0aGlzLnN0YXRpYyxcbiAgICAgICAgJ3Jlc2l6aW5nJzogdGhpcy5pc1Jlc2l6aW5nLFxuICAgICAgICAndnVlLWRyYWdnYWJsZS1kcmFnZ2luZyc6IHRoaXMuaXNEcmFnZ2luZyxcbiAgICAgICAgJ2Nzc1RyYW5zZm9ybXMnOiB0aGlzLnVzZUNzc1RyYW5zZm9ybXMsXG4gICAgICAgICdyZW5kZXItcnRsJzogdGhpcy5yZW5kZXJSdGwsXG4gICAgICAgICdkaXNhYmxlLXVzZXJzZWxlY3QnOiB0aGlzLmlzRHJhZ2dpbmcsXG4gICAgICAgICduby10b3VjaCc6IHRoaXMuaXNBbmRyb2lkICYmIHRoaXMuZHJhZ2dhYmxlT3JSZXNpemFibGVBbmROb3RTdGF0aWNcbiAgICAgIH07XG4gICAgfSxcbiAgICByZXNpemFibGVBbmROb3RTdGF0aWM6IGZ1bmN0aW9uIHJlc2l6YWJsZUFuZE5vdFN0YXRpYygpIHtcbiAgICAgIHJldHVybiB0aGlzLnJlc2l6YWJsZSAmJiAhdGhpcy5zdGF0aWM7XG4gICAgfSxcbiAgICBkcmFnZ2FibGVPclJlc2l6YWJsZUFuZE5vdFN0YXRpYzogZnVuY3Rpb24gZHJhZ2dhYmxlT3JSZXNpemFibGVBbmROb3RTdGF0aWMoKSB7XG4gICAgICByZXR1cm4gKHRoaXMuZHJhZ2dhYmxlIHx8IHRoaXMucmVzaXphYmxlKSAmJiAhdGhpcy5zdGF0aWM7XG4gICAgfSxcbiAgICBpc0FuZHJvaWQ6IGZ1bmN0aW9uIGlzQW5kcm9pZCgpIHtcbiAgICAgIHJldHVybiBuYXZpZ2F0b3IudXNlckFnZW50LnRvTG93ZXJDYXNlKCkuaW5kZXhPZihcImFuZHJvaWRcIikgIT09IC0xO1xuICAgIH0sXG4gICAgcmVuZGVyUnRsOiBmdW5jdGlvbiByZW5kZXJSdGwoKSB7XG4gICAgICByZXR1cm4gdGhpcy5sYXlvdXQuaXNNaXJyb3JlZCA/ICF0aGlzLnJ0bCA6IHRoaXMucnRsO1xuICAgIH0sXG4gICAgcmVzaXphYmxlSGFuZGxlQ2xhc3M6IGZ1bmN0aW9uIHJlc2l6YWJsZUhhbmRsZUNsYXNzKCkge1xuICAgICAgaWYgKHRoaXMucmVuZGVyUnRsKSB7XG4gICAgICAgIHJldHVybiAndnVlLXJlc2l6YWJsZS1oYW5kbGUgdnVlLXJ0bC1yZXNpemFibGUtaGFuZGxlJztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiAndnVlLXJlc2l6YWJsZS1oYW5kbGUnO1xuICAgICAgfVxuICAgIH1cbiAgfSxcbiAgbWV0aG9kczoge1xuICAgIGNyZWF0ZVN0eWxlOiBmdW5jdGlvbiBjcmVhdGVTdHlsZSgpIHtcbiAgICAgIGlmICh0aGlzLnggKyB0aGlzLncgPiB0aGlzLmNvbHMpIHtcbiAgICAgICAgdGhpcy5pbm5lclggPSAwO1xuICAgICAgICB0aGlzLmlubmVyVyA9IHRoaXMudyA+IHRoaXMuY29scyA/IHRoaXMuY29scyA6IHRoaXMudztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuaW5uZXJYID0gdGhpcy54O1xuICAgICAgICB0aGlzLmlubmVyVyA9IHRoaXMudztcbiAgICAgIH1cblxuICAgICAgdmFyIHBvcyA9IHRoaXMuY2FsY1Bvc2l0aW9uKHRoaXMuaW5uZXJYLCB0aGlzLmlubmVyWSwgdGhpcy5pbm5lclcsIHRoaXMuaW5uZXJIKTtcblxuICAgICAgaWYgKHRoaXMuaXNEcmFnZ2luZykge1xuICAgICAgICBwb3MudG9wID0gdGhpcy5kcmFnZ2luZy50b3A7IC8vICAgICAgICAgICAgICAgICAgICBBZGQgcnRsIHN1cHBvcnRcblxuICAgICAgICBpZiAodGhpcy5yZW5kZXJSdGwpIHtcbiAgICAgICAgICBwb3MucmlnaHQgPSB0aGlzLmRyYWdnaW5nLmxlZnQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcG9zLmxlZnQgPSB0aGlzLmRyYWdnaW5nLmxlZnQ7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMuaXNSZXNpemluZykge1xuICAgICAgICBwb3Mud2lkdGggPSB0aGlzLnJlc2l6aW5nLndpZHRoO1xuICAgICAgICBwb3MuaGVpZ2h0ID0gdGhpcy5yZXNpemluZy5oZWlnaHQ7XG4gICAgICB9XG5cbiAgICAgIHZhciBzdHlsZTsgLy8gQ1NTIFRyYW5zZm9ybXMgc3VwcG9ydCAoZGVmYXVsdClcblxuICAgICAgaWYgKHRoaXMudXNlQ3NzVHJhbnNmb3Jtcykge1xuICAgICAgICAvLyAgICAgICAgICAgICAgICAgICAgQWRkIHJ0bCBzdXBwb3J0XG4gICAgICAgIGlmICh0aGlzLnJlbmRlclJ0bCkge1xuICAgICAgICAgIHN0eWxlID0gT2JqZWN0KHV0aWxzW1wia1wiIC8qIHNldFRyYW5zZm9ybVJ0bCAqL10pKHBvcy50b3AsIHBvcy5yaWdodCwgcG9zLndpZHRoLCBwb3MuaGVpZ2h0KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzdHlsZSA9IE9iamVjdCh1dGlsc1tcImpcIiAvKiBzZXRUcmFuc2Zvcm0gKi9dKShwb3MudG9wLCBwb3MubGVmdCwgcG9zLndpZHRoLCBwb3MuaGVpZ2h0KTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gdG9wLGxlZnQgKHNsb3cpXG4gICAgICAgIC8vICAgICAgICAgICAgICAgICAgICBBZGQgcnRsIHN1cHBvcnRcbiAgICAgICAgaWYgKHRoaXMucmVuZGVyUnRsKSB7XG4gICAgICAgICAgc3R5bGUgPSBPYmplY3QodXRpbHNbXCJpXCIgLyogc2V0VG9wUmlnaHQgKi9dKShwb3MudG9wLCBwb3MucmlnaHQsIHBvcy53aWR0aCwgcG9zLmhlaWdodCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgc3R5bGUgPSBPYmplY3QodXRpbHNbXCJoXCIgLyogc2V0VG9wTGVmdCAqL10pKHBvcy50b3AsIHBvcy5sZWZ0LCBwb3Mud2lkdGgsIHBvcy5oZWlnaHQpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHRoaXMuc3R5bGUgPSBzdHlsZTtcbiAgICB9LFxuICAgIGVtaXRDb250YWluZXJSZXNpemVkOiBmdW5jdGlvbiBlbWl0Q29udGFpbmVyUmVzaXplZCgpIHtcbiAgICAgIC8vIHRoaXMuc3R5bGUgaGFzIHdpZHRoIGFuZCBoZWlnaHQgd2l0aCB0cmFpbGluZyAncHgnLiBUaGVcbiAgICAgIC8vIHJlc2l6ZWQgZXZlbnQgaXMgd2l0aG91dCB0aGVtXG4gICAgICB2YXIgc3R5bGVQcm9wcyA9IHt9O1xuXG4gICAgICBmb3IgKHZhciBfaSA9IDAsIF9hcnIgPSBbJ3dpZHRoJywgJ2hlaWdodCddOyBfaSA8IF9hcnIubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgIHZhciBwcm9wID0gX2FycltfaV07XG4gICAgICAgIHZhciB2YWwgPSB0aGlzLnN0eWxlW3Byb3BdO1xuICAgICAgICB2YXIgbWF0Y2hlcyA9IHZhbC5tYXRjaCgvXihcXGQrKXB4JC8pO1xuICAgICAgICBpZiAoIW1hdGNoZXMpIHJldHVybjtcbiAgICAgICAgc3R5bGVQcm9wc1twcm9wXSA9IG1hdGNoZXNbMV07XG4gICAgICB9XG5cbiAgICAgIHRoaXMuJGVtaXQoXCJjb250YWluZXItcmVzaXplZFwiLCB0aGlzLmksIHRoaXMuaCwgdGhpcy53LCBzdHlsZVByb3BzLmhlaWdodCwgc3R5bGVQcm9wcy53aWR0aCk7XG4gICAgfSxcbiAgICBoYW5kbGVSZXNpemU6IGZ1bmN0aW9uIGhhbmRsZVJlc2l6ZShldmVudCkge1xuICAgICAgaWYgKHRoaXMuc3RhdGljKSByZXR1cm47XG4gICAgICB2YXIgcG9zaXRpb24gPSBnZXRDb250cm9sUG9zaXRpb24oZXZlbnQpOyAvLyBHZXQgdGhlIGN1cnJlbnQgZHJhZyBwb2ludCBmcm9tIHRoZSBldmVudC4gVGhpcyBpcyB1c2VkIGFzIHRoZSBvZmZzZXQuXG5cbiAgICAgIGlmIChwb3NpdGlvbiA9PSBudWxsKSByZXR1cm47IC8vIG5vdCBwb3NzaWJsZSBidXQgc2F0aXNmaWVzIGZsb3dcblxuICAgICAgdmFyIHggPSBwb3NpdGlvbi54LFxuICAgICAgICAgIHkgPSBwb3NpdGlvbi55O1xuICAgICAgdmFyIG5ld1NpemUgPSB7XG4gICAgICAgIHdpZHRoOiAwLFxuICAgICAgICBoZWlnaHQ6IDBcbiAgICAgIH07XG4gICAgICB2YXIgcG9zO1xuXG4gICAgICBzd2l0Y2ggKGV2ZW50LnR5cGUpIHtcbiAgICAgICAgY2FzZSBcInJlc2l6ZXN0YXJ0XCI6XG4gICAgICAgICAge1xuICAgICAgICAgICAgdGhpcy5wcmV2aW91c1cgPSB0aGlzLmlubmVyVztcbiAgICAgICAgICAgIHRoaXMucHJldmlvdXNIID0gdGhpcy5pbm5lckg7XG4gICAgICAgICAgICBwb3MgPSB0aGlzLmNhbGNQb3NpdGlvbih0aGlzLmlubmVyWCwgdGhpcy5pbm5lclksIHRoaXMuaW5uZXJXLCB0aGlzLmlubmVySCk7XG4gICAgICAgICAgICBuZXdTaXplLndpZHRoID0gcG9zLndpZHRoO1xuICAgICAgICAgICAgbmV3U2l6ZS5oZWlnaHQgPSBwb3MuaGVpZ2h0O1xuICAgICAgICAgICAgdGhpcy5yZXNpemluZyA9IG5ld1NpemU7XG4gICAgICAgICAgICB0aGlzLmlzUmVzaXppbmcgPSB0cnVlO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuXG4gICAgICAgIGNhc2UgXCJyZXNpemVtb3ZlXCI6XG4gICAgICAgICAge1xuICAgICAgICAgICAgLy8gICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcIiMjIyByZXNpemUgPT4gXCIgKyBldmVudC50eXBlICsgXCIsIGxhc3RXPVwiICsgdGhpcy5sYXN0VyArIFwiLCBsYXN0SD1cIiArIHRoaXMubGFzdEgpO1xuICAgICAgICAgICAgdmFyIGNvcmVFdmVudCA9IGNyZWF0ZUNvcmVEYXRhKHRoaXMubGFzdFcsIHRoaXMubGFzdEgsIHgsIHkpO1xuXG4gICAgICAgICAgICBpZiAodGhpcy5yZW5kZXJSdGwpIHtcbiAgICAgICAgICAgICAgbmV3U2l6ZS53aWR0aCA9IHRoaXMucmVzaXppbmcud2lkdGggLSBjb3JlRXZlbnQuZGVsdGFYO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgbmV3U2l6ZS53aWR0aCA9IHRoaXMucmVzaXppbmcud2lkdGggKyBjb3JlRXZlbnQuZGVsdGFYO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBuZXdTaXplLmhlaWdodCA9IHRoaXMucmVzaXppbmcuaGVpZ2h0ICsgY29yZUV2ZW50LmRlbHRhWTsgLy8vY29uc29sZS5sb2coXCIjIyMgcmVzaXplID0+IFwiICsgZXZlbnQudHlwZSArIFwiLCBkZWx0YVg9XCIgKyBjb3JlRXZlbnQuZGVsdGFYICsgXCIsIGRlbHRhWT1cIiArIGNvcmVFdmVudC5kZWx0YVkpO1xuXG4gICAgICAgICAgICB0aGlzLnJlc2l6aW5nID0gbmV3U2l6ZTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cblxuICAgICAgICBjYXNlIFwicmVzaXplZW5kXCI6XG4gICAgICAgICAge1xuICAgICAgICAgICAgLy9jb25zb2xlLmxvZyhcIiMjIyByZXNpemUgZW5kID0+IHg9XCIgK3RoaXMuaW5uZXJYICsgXCIgeT1cIiArIHRoaXMuaW5uZXJZICsgXCIgdz1cIiArIHRoaXMuaW5uZXJXICsgXCIgaD1cIiArIHRoaXMuaW5uZXJIKTtcbiAgICAgICAgICAgIHBvcyA9IHRoaXMuY2FsY1Bvc2l0aW9uKHRoaXMuaW5uZXJYLCB0aGlzLmlubmVyWSwgdGhpcy5pbm5lclcsIHRoaXMuaW5uZXJIKTtcbiAgICAgICAgICAgIG5ld1NpemUud2lkdGggPSBwb3Mud2lkdGg7XG4gICAgICAgICAgICBuZXdTaXplLmhlaWdodCA9IHBvcy5oZWlnaHQ7IC8vICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coXCIjIyMgcmVzaXplIGVuZCA9PiBcIiArIEpTT04uc3RyaW5naWZ5KG5ld1NpemUpKTtcblxuICAgICAgICAgICAgdGhpcy5yZXNpemluZyA9IG51bGw7XG4gICAgICAgICAgICB0aGlzLmlzUmVzaXppbmcgPSBmYWxzZTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgIH0gLy8gR2V0IG5ldyBXSFxuXG5cbiAgICAgIHBvcyA9IHRoaXMuY2FsY1dIKG5ld1NpemUuaGVpZ2h0LCBuZXdTaXplLndpZHRoKTtcblxuICAgICAgaWYgKHBvcy53IDwgdGhpcy5taW5XKSB7XG4gICAgICAgIHBvcy53ID0gdGhpcy5taW5XO1xuICAgICAgfVxuXG4gICAgICBpZiAocG9zLncgPiB0aGlzLm1heFcpIHtcbiAgICAgICAgcG9zLncgPSB0aGlzLm1heFc7XG4gICAgICB9XG5cbiAgICAgIGlmIChwb3MuaCA8IHRoaXMubWluSCkge1xuICAgICAgICBwb3MuaCA9IHRoaXMubWluSDtcbiAgICAgIH1cblxuICAgICAgaWYgKHBvcy5oID4gdGhpcy5tYXhIKSB7XG4gICAgICAgIHBvcy5oID0gdGhpcy5tYXhIO1xuICAgICAgfVxuXG4gICAgICBpZiAocG9zLmggPCAxKSB7XG4gICAgICAgIHBvcy5oID0gMTtcbiAgICAgIH1cblxuICAgICAgaWYgKHBvcy53IDwgMSkge1xuICAgICAgICBwb3MudyA9IDE7XG4gICAgICB9XG5cbiAgICAgIHRoaXMubGFzdFcgPSB4O1xuICAgICAgdGhpcy5sYXN0SCA9IHk7XG5cbiAgICAgIGlmICh0aGlzLmlubmVyVyAhPT0gcG9zLncgfHwgdGhpcy5pbm5lckggIT09IHBvcy5oKSB7XG4gICAgICAgIHRoaXMuJGVtaXQoXCJyZXNpemVcIiwgdGhpcy5pLCBwb3MuaCwgcG9zLncsIG5ld1NpemUuaGVpZ2h0LCBuZXdTaXplLndpZHRoKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGV2ZW50LnR5cGUgPT09IFwicmVzaXplZW5kXCIgJiYgKHRoaXMucHJldmlvdXNXICE9PSB0aGlzLmlubmVyVyB8fCB0aGlzLnByZXZpb3VzSCAhPT0gdGhpcy5pbm5lckgpKSB7XG4gICAgICAgIHRoaXMuJGVtaXQoXCJyZXNpemVkXCIsIHRoaXMuaSwgcG9zLmgsIHBvcy53LCBuZXdTaXplLmhlaWdodCwgbmV3U2l6ZS53aWR0aCk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuZXZlbnRCdXMuJGVtaXQoXCJyZXNpemVFdmVudFwiLCBldmVudC50eXBlLCB0aGlzLmksIHRoaXMuaW5uZXJYLCB0aGlzLmlubmVyWSwgcG9zLmgsIHBvcy53KTtcbiAgICB9LFxuICAgIGhhbmRsZURyYWc6IGZ1bmN0aW9uIGhhbmRsZURyYWcoZXZlbnQpIHtcbiAgICAgIGlmICh0aGlzLnN0YXRpYykgcmV0dXJuO1xuICAgICAgaWYgKHRoaXMuaXNSZXNpemluZykgcmV0dXJuO1xuICAgICAgdmFyIHBvc2l0aW9uID0gZ2V0Q29udHJvbFBvc2l0aW9uKGV2ZW50KTsgLy8gR2V0IHRoZSBjdXJyZW50IGRyYWcgcG9pbnQgZnJvbSB0aGUgZXZlbnQuIFRoaXMgaXMgdXNlZCBhcyB0aGUgb2Zmc2V0LlxuXG4gICAgICBpZiAocG9zaXRpb24gPT09IG51bGwpIHJldHVybjsgLy8gbm90IHBvc3NpYmxlIGJ1dCBzYXRpc2ZpZXMgZmxvd1xuXG4gICAgICB2YXIgeCA9IHBvc2l0aW9uLngsXG4gICAgICAgICAgeSA9IHBvc2l0aW9uLnk7IC8vIGxldCBzaG91bGRVcGRhdGUgPSBmYWxzZTtcblxuICAgICAgdmFyIG5ld1Bvc2l0aW9uID0ge1xuICAgICAgICB0b3A6IDAsXG4gICAgICAgIGxlZnQ6IDBcbiAgICAgIH07XG5cbiAgICAgIHN3aXRjaCAoZXZlbnQudHlwZSkge1xuICAgICAgICBjYXNlIFwiZHJhZ3N0YXJ0XCI6XG4gICAgICAgICAge1xuICAgICAgICAgICAgdGhpcy5wcmV2aW91c1ggPSB0aGlzLmlubmVyWDtcbiAgICAgICAgICAgIHRoaXMucHJldmlvdXNZID0gdGhpcy5pbm5lclk7XG4gICAgICAgICAgICB2YXIgcGFyZW50UmVjdCA9IGV2ZW50LnRhcmdldC5vZmZzZXRQYXJlbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICAgICAgICB2YXIgY2xpZW50UmVjdCA9IGV2ZW50LnRhcmdldC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcblxuICAgICAgICAgICAgaWYgKHRoaXMucmVuZGVyUnRsKSB7XG4gICAgICAgICAgICAgIG5ld1Bvc2l0aW9uLmxlZnQgPSAoY2xpZW50UmVjdC5yaWdodCAtIHBhcmVudFJlY3QucmlnaHQpICogLTE7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBuZXdQb3NpdGlvbi5sZWZ0ID0gY2xpZW50UmVjdC5sZWZ0IC0gcGFyZW50UmVjdC5sZWZ0O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBuZXdQb3NpdGlvbi50b3AgPSBjbGllbnRSZWN0LnRvcCAtIHBhcmVudFJlY3QudG9wO1xuICAgICAgICAgICAgdGhpcy5kcmFnZ2luZyA9IG5ld1Bvc2l0aW9uO1xuICAgICAgICAgICAgdGhpcy5pc0RyYWdnaW5nID0gdHJ1ZTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cblxuICAgICAgICBjYXNlIFwiZHJhZ2VuZFwiOlxuICAgICAgICAgIHtcbiAgICAgICAgICAgIGlmICghdGhpcy5pc0RyYWdnaW5nKSByZXR1cm47XG5cbiAgICAgICAgICAgIHZhciBfcGFyZW50UmVjdCA9IGV2ZW50LnRhcmdldC5vZmZzZXRQYXJlbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG5cbiAgICAgICAgICAgIHZhciBfY2xpZW50UmVjdCA9IGV2ZW50LnRhcmdldC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTsgLy8gICAgICAgICAgICAgICAgICAgICAgICBBZGQgcnRsIHN1cHBvcnRcblxuXG4gICAgICAgICAgICBpZiAodGhpcy5yZW5kZXJSdGwpIHtcbiAgICAgICAgICAgICAgbmV3UG9zaXRpb24ubGVmdCA9IChfY2xpZW50UmVjdC5yaWdodCAtIF9wYXJlbnRSZWN0LnJpZ2h0KSAqIC0xO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgbmV3UG9zaXRpb24ubGVmdCA9IF9jbGllbnRSZWN0LmxlZnQgLSBfcGFyZW50UmVjdC5sZWZ0O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBuZXdQb3NpdGlvbi50b3AgPSBfY2xpZW50UmVjdC50b3AgLSBfcGFyZW50UmVjdC50b3A7IC8vICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coXCIjIyMgZHJhZyBlbmQgPT4gXCIgKyBKU09OLnN0cmluZ2lmeShuZXdQb3NpdGlvbikpO1xuICAgICAgICAgICAgLy8gICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcIiMjIyBEUk9QOiBcIiArIEpTT04uc3RyaW5naWZ5KG5ld1Bvc2l0aW9uKSk7XG5cbiAgICAgICAgICAgIHRoaXMuZHJhZ2dpbmcgPSBudWxsO1xuICAgICAgICAgICAgdGhpcy5pc0RyYWdnaW5nID0gZmFsc2U7IC8vIHNob3VsZFVwZGF0ZSA9IHRydWU7XG5cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cblxuICAgICAgICBjYXNlIFwiZHJhZ21vdmVcIjpcbiAgICAgICAgICB7XG4gICAgICAgICAgICB2YXIgY29yZUV2ZW50ID0gY3JlYXRlQ29yZURhdGEodGhpcy5sYXN0WCwgdGhpcy5sYXN0WSwgeCwgeSk7IC8vICAgICAgICAgICAgICAgICAgICAgICAgQWRkIHJ0bCBzdXBwb3J0XG5cbiAgICAgICAgICAgIGlmICh0aGlzLnJlbmRlclJ0bCkge1xuICAgICAgICAgICAgICBuZXdQb3NpdGlvbi5sZWZ0ID0gdGhpcy5kcmFnZ2luZy5sZWZ0IC0gY29yZUV2ZW50LmRlbHRhWDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIG5ld1Bvc2l0aW9uLmxlZnQgPSB0aGlzLmRyYWdnaW5nLmxlZnQgKyBjb3JlRXZlbnQuZGVsdGFYO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBuZXdQb3NpdGlvbi50b3AgPSB0aGlzLmRyYWdnaW5nLnRvcCArIGNvcmVFdmVudC5kZWx0YVk7IC8vICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coXCIjIyMgZHJhZyA9PiBcIiArIGV2ZW50LnR5cGUgKyBcIiwgeD1cIiArIHggKyBcIiwgeT1cIiArIHkpO1xuICAgICAgICAgICAgLy8gICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcIiMjIyBkcmFnID0+IFwiICsgZXZlbnQudHlwZSArIFwiLCBkZWx0YVg9XCIgKyBjb3JlRXZlbnQuZGVsdGFYICsgXCIsIGRlbHRhWT1cIiArIGNvcmVFdmVudC5kZWx0YVkpO1xuICAgICAgICAgICAgLy8gICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcIiMjIyBkcmFnIGVuZCA9PiBcIiArIEpTT04uc3RyaW5naWZ5KG5ld1Bvc2l0aW9uKSk7XG5cbiAgICAgICAgICAgIHRoaXMuZHJhZ2dpbmcgPSBuZXdQb3NpdGlvbjtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgIH0gLy8gR2V0IG5ldyBYWVxuXG5cbiAgICAgIHZhciBwb3M7XG5cbiAgICAgIGlmICh0aGlzLnJlbmRlclJ0bCkge1xuICAgICAgICBwb3MgPSB0aGlzLmNhbGNYWShuZXdQb3NpdGlvbi50b3AsIG5ld1Bvc2l0aW9uLmxlZnQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcG9zID0gdGhpcy5jYWxjWFkobmV3UG9zaXRpb24udG9wLCBuZXdQb3NpdGlvbi5sZWZ0KTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5sYXN0WCA9IHg7XG4gICAgICB0aGlzLmxhc3RZID0geTtcblxuICAgICAgaWYgKHRoaXMuaW5uZXJYICE9PSBwb3MueCB8fCB0aGlzLmlubmVyWSAhPT0gcG9zLnkpIHtcbiAgICAgICAgdGhpcy4kZW1pdChcIm1vdmVcIiwgdGhpcy5pLCBwb3MueCwgcG9zLnkpO1xuICAgICAgfVxuXG4gICAgICBpZiAoZXZlbnQudHlwZSA9PT0gXCJkcmFnZW5kXCIgJiYgKHRoaXMucHJldmlvdXNYICE9PSB0aGlzLmlubmVyWCB8fCB0aGlzLnByZXZpb3VzWSAhPT0gdGhpcy5pbm5lclkpKSB7XG4gICAgICAgIHRoaXMuJGVtaXQoXCJtb3ZlZFwiLCB0aGlzLmksIHBvcy54LCBwb3MueSk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuZXZlbnRCdXMuJGVtaXQoXCJkcmFnRXZlbnRcIiwgZXZlbnQudHlwZSwgdGhpcy5pLCBwb3MueCwgcG9zLnksIHRoaXMuaW5uZXJILCB0aGlzLmlubmVyVyk7XG4gICAgfSxcbiAgICBjYWxjUG9zaXRpb246IGZ1bmN0aW9uIGNhbGNQb3NpdGlvbih4LCB5LCB3LCBoKSB7XG4gICAgICB2YXIgY29sV2lkdGggPSB0aGlzLmNhbGNDb2xXaWR0aCgpOyAvLyBhZGQgcnRsIHN1cHBvcnRcblxuICAgICAgdmFyIG91dDtcblxuICAgICAgaWYgKHRoaXMucmVuZGVyUnRsKSB7XG4gICAgICAgIG91dCA9IHtcbiAgICAgICAgICByaWdodDogTWF0aC5yb3VuZChjb2xXaWR0aCAqIHggKyAoeCArIDEpICogdGhpcy5tYXJnaW5bMF0pLFxuICAgICAgICAgIHRvcDogTWF0aC5yb3VuZCh0aGlzLnJvd0hlaWdodCAqIHkgKyAoeSArIDEpICogdGhpcy5tYXJnaW5bMV0pLFxuICAgICAgICAgIC8vIDAgKiBJbmZpbml0eSA9PT0gTmFOLCB3aGljaCBjYXVzZXMgcHJvYmxlbXMgd2l0aCByZXNpemUgY29uc3RyaWFudHM7XG4gICAgICAgICAgLy8gRml4IHRoaXMgaWYgaXQgb2NjdXJzLlxuICAgICAgICAgIC8vIE5vdGUgd2UgZG8gaXQgaGVyZSByYXRoZXIgdGhhbiBsYXRlciBiZWNhdXNlIE1hdGgucm91bmQoSW5maW5pdHkpIGNhdXNlcyBkZW9wdFxuICAgICAgICAgIHdpZHRoOiB3ID09PSBJbmZpbml0eSA/IHcgOiBNYXRoLnJvdW5kKGNvbFdpZHRoICogdyArIE1hdGgubWF4KDAsIHcgLSAxKSAqIHRoaXMubWFyZ2luWzBdKSxcbiAgICAgICAgICBoZWlnaHQ6IGggPT09IEluZmluaXR5ID8gaCA6IE1hdGgucm91bmQodGhpcy5yb3dIZWlnaHQgKiBoICsgTWF0aC5tYXgoMCwgaCAtIDEpICogdGhpcy5tYXJnaW5bMV0pXG4gICAgICAgIH07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBvdXQgPSB7XG4gICAgICAgICAgbGVmdDogTWF0aC5yb3VuZChjb2xXaWR0aCAqIHggKyAoeCArIDEpICogdGhpcy5tYXJnaW5bMF0pLFxuICAgICAgICAgIHRvcDogTWF0aC5yb3VuZCh0aGlzLnJvd0hlaWdodCAqIHkgKyAoeSArIDEpICogdGhpcy5tYXJnaW5bMV0pLFxuICAgICAgICAgIC8vIDAgKiBJbmZpbml0eSA9PT0gTmFOLCB3aGljaCBjYXVzZXMgcHJvYmxlbXMgd2l0aCByZXNpemUgY29uc3RyaWFudHM7XG4gICAgICAgICAgLy8gRml4IHRoaXMgaWYgaXQgb2NjdXJzLlxuICAgICAgICAgIC8vIE5vdGUgd2UgZG8gaXQgaGVyZSByYXRoZXIgdGhhbiBsYXRlciBiZWNhdXNlIE1hdGgucm91bmQoSW5maW5pdHkpIGNhdXNlcyBkZW9wdFxuICAgICAgICAgIHdpZHRoOiB3ID09PSBJbmZpbml0eSA/IHcgOiBNYXRoLnJvdW5kKGNvbFdpZHRoICogdyArIE1hdGgubWF4KDAsIHcgLSAxKSAqIHRoaXMubWFyZ2luWzBdKSxcbiAgICAgICAgICBoZWlnaHQ6IGggPT09IEluZmluaXR5ID8gaCA6IE1hdGgucm91bmQodGhpcy5yb3dIZWlnaHQgKiBoICsgTWF0aC5tYXgoMCwgaCAtIDEpICogdGhpcy5tYXJnaW5bMV0pXG4gICAgICAgIH07XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBvdXQ7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFRyYW5zbGF0ZSB4IGFuZCB5IGNvb3JkaW5hdGVzIGZyb20gcGl4ZWxzIHRvIGdyaWQgdW5pdHMuXG4gICAgICogQHBhcmFtICB7TnVtYmVyfSB0b3AgIFRvcCBwb3NpdGlvbiAocmVsYXRpdmUgdG8gcGFyZW50KSBpbiBwaXhlbHMuXG4gICAgICogQHBhcmFtICB7TnVtYmVyfSBsZWZ0IExlZnQgcG9zaXRpb24gKHJlbGF0aXZlIHRvIHBhcmVudCkgaW4gcGl4ZWxzLlxuICAgICAqIEByZXR1cm4ge09iamVjdH0geCBhbmQgeSBpbiBncmlkIHVuaXRzLlxuICAgICAqL1xuICAgIC8vIFRPRE8gY2hlY2sgaWYgdGhpcyBmdW5jdGlvbiBuZWVkcyBjaGFuZ2UgaW4gb3JkZXIgdG8gc3VwcG9ydCBydGwuXG4gICAgY2FsY1hZOiBmdW5jdGlvbiBjYWxjWFkodG9wLCBsZWZ0KSB7XG4gICAgICB2YXIgY29sV2lkdGggPSB0aGlzLmNhbGNDb2xXaWR0aCgpOyAvLyBsZWZ0ID0gY29sV2lkdGggKiB4ICsgbWFyZ2luICogKHggKyAxKVxuICAgICAgLy8gbCA9IGN4ICsgbSh4KzEpXG4gICAgICAvLyBsID0gY3ggKyBteCArIG1cbiAgICAgIC8vIGwgLSBtID0gY3ggKyBteFxuICAgICAgLy8gbCAtIG0gPSB4KGMgKyBtKVxuICAgICAgLy8gKGwgLSBtKSAvIChjICsgbSkgPSB4XG4gICAgICAvLyB4ID0gKGxlZnQgLSBtYXJnaW4pIC8gKGNvbGRXaWR0aCArIG1hcmdpbilcblxuICAgICAgdmFyIHggPSBNYXRoLnJvdW5kKChsZWZ0IC0gdGhpcy5tYXJnaW5bMF0pIC8gKGNvbFdpZHRoICsgdGhpcy5tYXJnaW5bMF0pKTtcbiAgICAgIHZhciB5ID0gTWF0aC5yb3VuZCgodG9wIC0gdGhpcy5tYXJnaW5bMV0pIC8gKHRoaXMucm93SGVpZ2h0ICsgdGhpcy5tYXJnaW5bMV0pKTsgLy8gQ2FwcGluZ1xuXG4gICAgICB4ID0gTWF0aC5tYXgoTWF0aC5taW4oeCwgdGhpcy5jb2xzIC0gdGhpcy5pbm5lclcpLCAwKTtcbiAgICAgIHkgPSBNYXRoLm1heChNYXRoLm1pbih5LCB0aGlzLm1heFJvd3MgLSB0aGlzLmlubmVySCksIDApO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgeDogeCxcbiAgICAgICAgeTogeVxuICAgICAgfTtcbiAgICB9LFxuICAgIC8vIEhlbHBlciBmb3IgZ2VuZXJhdGluZyBjb2x1bW4gd2lkdGhcbiAgICBjYWxjQ29sV2lkdGg6IGZ1bmN0aW9uIGNhbGNDb2xXaWR0aCgpIHtcbiAgICAgIHZhciBjb2xXaWR0aCA9ICh0aGlzLmNvbnRhaW5lcldpZHRoIC0gdGhpcy5tYXJnaW5bMF0gKiAodGhpcy5jb2xzICsgMSkpIC8gdGhpcy5jb2xzOyAvLyBjb25zb2xlLmxvZyhcIiMjIyBDT0xTPVwiICsgdGhpcy5jb2xzICsgXCIgQ09MIFdJRFRIPVwiICsgY29sV2lkdGggKyBcIiBNQVJHSU4gXCIgKyB0aGlzLm1hcmdpblswXSk7XG5cbiAgICAgIHJldHVybiBjb2xXaWR0aDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogR2l2ZW4gYSBoZWlnaHQgYW5kIHdpZHRoIGluIHBpeGVsIHZhbHVlcywgY2FsY3VsYXRlIGdyaWQgdW5pdHMuXG4gICAgICogQHBhcmFtICB7TnVtYmVyfSBoZWlnaHQgSGVpZ2h0IGluIHBpeGVscy5cbiAgICAgKiBAcGFyYW0gIHtOdW1iZXJ9IHdpZHRoICBXaWR0aCBpbiBwaXhlbHMuXG4gICAgICogQHJldHVybiB7T2JqZWN0fSB3LCBoIGFzIGdyaWQgdW5pdHMuXG4gICAgICovXG4gICAgY2FsY1dIOiBmdW5jdGlvbiBjYWxjV0goaGVpZ2h0LCB3aWR0aCkge1xuICAgICAgdmFyIGNvbFdpZHRoID0gdGhpcy5jYWxjQ29sV2lkdGgoKTsgLy8gd2lkdGggPSBjb2xXaWR0aCAqIHcgLSAobWFyZ2luICogKHcgLSAxKSlcbiAgICAgIC8vIC4uLlxuICAgICAgLy8gdyA9ICh3aWR0aCArIG1hcmdpbikgLyAoY29sV2lkdGggKyBtYXJnaW4pXG5cbiAgICAgIHZhciB3ID0gTWF0aC5yb3VuZCgod2lkdGggKyB0aGlzLm1hcmdpblswXSkgLyAoY29sV2lkdGggKyB0aGlzLm1hcmdpblswXSkpO1xuICAgICAgdmFyIGggPSBNYXRoLnJvdW5kKChoZWlnaHQgKyB0aGlzLm1hcmdpblsxXSkgLyAodGhpcy5yb3dIZWlnaHQgKyB0aGlzLm1hcmdpblsxXSkpOyAvLyBDYXBwaW5nXG5cbiAgICAgIHcgPSBNYXRoLm1heChNYXRoLm1pbih3LCB0aGlzLmNvbHMgLSB0aGlzLmlubmVyWCksIDApO1xuICAgICAgaCA9IE1hdGgubWF4KE1hdGgubWluKGgsIHRoaXMubWF4Um93cyAtIHRoaXMuaW5uZXJZKSwgMCk7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB3OiB3LFxuICAgICAgICBoOiBoXG4gICAgICB9O1xuICAgIH0sXG4gICAgdXBkYXRlV2lkdGg6IGZ1bmN0aW9uIHVwZGF0ZVdpZHRoKHdpZHRoLCBjb2xOdW0pIHtcbiAgICAgIHRoaXMuY29udGFpbmVyV2lkdGggPSB3aWR0aDtcblxuICAgICAgaWYgKGNvbE51bSAhPT0gdW5kZWZpbmVkICYmIGNvbE51bSAhPT0gbnVsbCkge1xuICAgICAgICB0aGlzLmNvbHMgPSBjb2xOdW07XG4gICAgICB9XG4gICAgfSxcbiAgICBjb21wYWN0OiBmdW5jdGlvbiBjb21wYWN0KCkge1xuICAgICAgdGhpcy5jcmVhdGVTdHlsZSgpO1xuICAgIH0sXG4gICAgdHJ5TWFrZURyYWdnYWJsZTogZnVuY3Rpb24gdHJ5TWFrZURyYWdnYWJsZSgpIHtcbiAgICAgIHZhciBzZWxmID0gdGhpcztcblxuICAgICAgaWYgKHRoaXMuaW50ZXJhY3RPYmogPT09IG51bGwgfHwgdGhpcy5pbnRlcmFjdE9iaiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRoaXMuaW50ZXJhY3RPYmogPSBfaW50ZXJhY3Rqc19pbnRlcmFjdCh0aGlzLiRyZWZzLml0ZW0pO1xuXG4gICAgICAgIGlmICghdGhpcy51c2VTdHlsZUN1cnNvcikge1xuICAgICAgICAgIHRoaXMuaW50ZXJhY3RPYmouc3R5bGVDdXJzb3IoZmFsc2UpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLmRyYWdnYWJsZSAmJiAhdGhpcy5zdGF0aWMpIHtcbiAgICAgICAgdmFyIG9wdHMgPSB7XG4gICAgICAgICAgaWdub3JlRnJvbTogdGhpcy5kcmFnSWdub3JlRnJvbSxcbiAgICAgICAgICBhbGxvd0Zyb206IHRoaXMuZHJhZ0FsbG93RnJvbVxuICAgICAgICB9O1xuICAgICAgICB0aGlzLmludGVyYWN0T2JqLmRyYWdnYWJsZShvcHRzKTtcbiAgICAgICAgLyp0aGlzLmludGVyYWN0T2JqLmRyYWdnYWJsZSh7YWxsb3dGcm9tOiAnLnZ1ZS1kcmFnZ2FibGUtaGFuZGxlJ30pOyovXG5cbiAgICAgICAgaWYgKCF0aGlzLmRyYWdFdmVudFNldCkge1xuICAgICAgICAgIHRoaXMuZHJhZ0V2ZW50U2V0ID0gdHJ1ZTtcbiAgICAgICAgICB0aGlzLmludGVyYWN0T2JqLm9uKCdkcmFnc3RhcnQgZHJhZ21vdmUgZHJhZ2VuZCcsIGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICAgICAgc2VsZi5oYW5kbGVEcmFnKGV2ZW50KTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5pbnRlcmFjdE9iai5kcmFnZ2FibGUoe1xuICAgICAgICAgIGVuYWJsZWQ6IGZhbHNlXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0sXG4gICAgdHJ5TWFrZVJlc2l6YWJsZTogZnVuY3Rpb24gdHJ5TWFrZVJlc2l6YWJsZSgpIHtcbiAgICAgIHZhciBzZWxmID0gdGhpcztcblxuICAgICAgaWYgKHRoaXMuaW50ZXJhY3RPYmogPT09IG51bGwgfHwgdGhpcy5pbnRlcmFjdE9iaiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRoaXMuaW50ZXJhY3RPYmogPSBfaW50ZXJhY3Rqc19pbnRlcmFjdCh0aGlzLiRyZWZzLml0ZW0pO1xuXG4gICAgICAgIGlmICghdGhpcy51c2VTdHlsZUN1cnNvcikge1xuICAgICAgICAgIHRoaXMuaW50ZXJhY3RPYmouc3R5bGVDdXJzb3IoZmFsc2UpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLnJlc2l6YWJsZSAmJiAhdGhpcy5zdGF0aWMpIHtcbiAgICAgICAgdmFyIG1heGltdW0gPSB0aGlzLmNhbGNQb3NpdGlvbigwLCAwLCB0aGlzLm1heFcsIHRoaXMubWF4SCk7XG4gICAgICAgIHZhciBtaW5pbXVtID0gdGhpcy5jYWxjUG9zaXRpb24oMCwgMCwgdGhpcy5taW5XLCB0aGlzLm1pbkgpOyAvLyBjb25zb2xlLmxvZyhcIiMjIyBNQVggXCIgKyBKU09OLnN0cmluZ2lmeShtYXhpbXVtKSk7XG4gICAgICAgIC8vIGNvbnNvbGUubG9nKFwiIyMjIE1JTiBcIiArIEpTT04uc3RyaW5naWZ5KG1pbmltdW0pKTtcblxuICAgICAgICB2YXIgb3B0cyA9IHtcbiAgICAgICAgICAvLyBhbGxvd0Zyb206IFwiLlwiICsgdGhpcy5yZXNpemFibGVIYW5kbGVDbGFzcy50cmltKCkucmVwbGFjZShcIiBcIiwgXCIuXCIpLFxuICAgICAgICAgIGVkZ2VzOiB7XG4gICAgICAgICAgICBsZWZ0OiBmYWxzZSxcbiAgICAgICAgICAgIHJpZ2h0OiBcIi5cIiArIHRoaXMucmVzaXphYmxlSGFuZGxlQ2xhc3MudHJpbSgpLnJlcGxhY2UoXCIgXCIsIFwiLlwiKSxcbiAgICAgICAgICAgIGJvdHRvbTogXCIuXCIgKyB0aGlzLnJlc2l6YWJsZUhhbmRsZUNsYXNzLnRyaW0oKS5yZXBsYWNlKFwiIFwiLCBcIi5cIiksXG4gICAgICAgICAgICB0b3A6IGZhbHNlXG4gICAgICAgICAgfSxcbiAgICAgICAgICBpZ25vcmVGcm9tOiB0aGlzLnJlc2l6ZUlnbm9yZUZyb20sXG4gICAgICAgICAgcmVzdHJpY3RTaXplOiB7XG4gICAgICAgICAgICBtaW46IHtcbiAgICAgICAgICAgICAgaGVpZ2h0OiBtaW5pbXVtLmhlaWdodCxcbiAgICAgICAgICAgICAgd2lkdGg6IG1pbmltdW0ud2lkdGhcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBtYXg6IHtcbiAgICAgICAgICAgICAgaGVpZ2h0OiBtYXhpbXVtLmhlaWdodCxcbiAgICAgICAgICAgICAgd2lkdGg6IG1heGltdW0ud2lkdGhcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgaWYgKHRoaXMucHJlc2VydmVBc3BlY3RSYXRpbykge1xuICAgICAgICAgIG9wdHMubW9kaWZpZXJzID0gW19pbnRlcmFjdGpzX2ludGVyYWN0Lm1vZGlmaWVycy5hc3BlY3RSYXRpbyh7XG4gICAgICAgICAgICByYXRpbzogJ3ByZXNlcnZlJ1xuICAgICAgICAgIH0pXTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuaW50ZXJhY3RPYmoucmVzaXphYmxlKG9wdHMpO1xuXG4gICAgICAgIGlmICghdGhpcy5yZXNpemVFdmVudFNldCkge1xuICAgICAgICAgIHRoaXMucmVzaXplRXZlbnRTZXQgPSB0cnVlO1xuICAgICAgICAgIHRoaXMuaW50ZXJhY3RPYmoub24oJ3Jlc2l6ZXN0YXJ0IHJlc2l6ZW1vdmUgcmVzaXplZW5kJywgZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgICAgICBzZWxmLmhhbmRsZVJlc2l6ZShldmVudCk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuaW50ZXJhY3RPYmoucmVzaXphYmxlKHtcbiAgICAgICAgICBlbmFibGVkOiBmYWxzZVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9LFxuICAgIGF1dG9TaXplOiBmdW5jdGlvbiBhdXRvU2l6ZSgpIHtcbiAgICAgIC8vIG9rIGhlcmUgd2Ugd2FudCB0byBjYWxjdWxhdGUgaWYgYSByZXNpemUgaXMgbmVlZGVkXG4gICAgICB0aGlzLnByZXZpb3VzVyA9IHRoaXMuaW5uZXJXO1xuICAgICAgdGhpcy5wcmV2aW91c0ggPSB0aGlzLmlubmVySDtcbiAgICAgIHZhciBuZXdTaXplID0gdGhpcy4kc2xvdHMuZGVmYXVsdFswXS5lbG0uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICB2YXIgcG9zID0gdGhpcy5jYWxjV0gobmV3U2l6ZS5oZWlnaHQsIG5ld1NpemUud2lkdGgpO1xuXG4gICAgICBpZiAocG9zLncgPCB0aGlzLm1pblcpIHtcbiAgICAgICAgcG9zLncgPSB0aGlzLm1pblc7XG4gICAgICB9XG5cbiAgICAgIGlmIChwb3MudyA+IHRoaXMubWF4Vykge1xuICAgICAgICBwb3MudyA9IHRoaXMubWF4VztcbiAgICAgIH1cblxuICAgICAgaWYgKHBvcy5oIDwgdGhpcy5taW5IKSB7XG4gICAgICAgIHBvcy5oID0gdGhpcy5taW5IO1xuICAgICAgfVxuXG4gICAgICBpZiAocG9zLmggPiB0aGlzLm1heEgpIHtcbiAgICAgICAgcG9zLmggPSB0aGlzLm1heEg7XG4gICAgICB9XG5cbiAgICAgIGlmIChwb3MuaCA8IDEpIHtcbiAgICAgICAgcG9zLmggPSAxO1xuICAgICAgfVxuXG4gICAgICBpZiAocG9zLncgPCAxKSB7XG4gICAgICAgIHBvcy53ID0gMTtcbiAgICAgIH0gLy8gdGhpcy5sYXN0VyA9IHg7IC8vIGJhc2ljYWxseSwgdGhpcyBpcyBjb3BpZWQgZnJvbSByZXNpemVoYW5kbGVyLCBidXQgc2hvdWxkbid0IGJlIG5lZWRlZFxuICAgICAgLy8gdGhpcy5sYXN0SCA9IHk7XG5cblxuICAgICAgaWYgKHRoaXMuaW5uZXJXICE9PSBwb3MudyB8fCB0aGlzLmlubmVySCAhPT0gcG9zLmgpIHtcbiAgICAgICAgdGhpcy4kZW1pdChcInJlc2l6ZVwiLCB0aGlzLmksIHBvcy5oLCBwb3MudywgbmV3U2l6ZS5oZWlnaHQsIG5ld1NpemUud2lkdGgpO1xuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5wcmV2aW91c1cgIT09IHBvcy53IHx8IHRoaXMucHJldmlvdXNIICE9PSBwb3MuaCkge1xuICAgICAgICB0aGlzLiRlbWl0KFwicmVzaXplZFwiLCB0aGlzLmksIHBvcy5oLCBwb3MudywgbmV3U2l6ZS5oZWlnaHQsIG5ld1NpemUud2lkdGgpO1xuICAgICAgICB0aGlzLmV2ZW50QnVzLiRlbWl0KFwicmVzaXplRXZlbnRcIiwgXCJyZXNpemVlbmRcIiwgdGhpcy5pLCB0aGlzLmlubmVyWCwgdGhpcy5pbm5lclksIHBvcy5oLCBwb3Mudyk7XG4gICAgICB9XG4gICAgfVxuICB9XG59KTtcbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL2NvbXBvbmVudHMvR3JpZEl0ZW0udnVlP3Z1ZSZ0eXBlPXNjcmlwdCZsYW5nPWpzJlxuIC8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gdmFyIGNvbXBvbmVudHNfR3JpZEl0ZW12dWVfdHlwZV9zY3JpcHRfbGFuZ19qc18gPSAoR3JpZEl0ZW12dWVfdHlwZV9zY3JpcHRfbGFuZ19qc18pOyBcbi8vIEVYVEVSTkFMIE1PRFVMRTogLi9zcmMvY29tcG9uZW50cy9HcmlkSXRlbS52dWU/dnVlJnR5cGU9c3R5bGUmaW5kZXg9MCZsYW5nPWNzcyZcbnZhciBHcmlkSXRlbXZ1ZV90eXBlX3N0eWxlX2luZGV4XzBfbGFuZ19jc3NfID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIjVlZDRcIik7XG5cbi8vIEVYVEVSTkFMIE1PRFVMRTogLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvcnVudGltZS9jb21wb25lbnROb3JtYWxpemVyLmpzXG52YXIgY29tcG9uZW50Tm9ybWFsaXplciA9IF9fd2VicGFja19yZXF1aXJlX18oXCIyODc3XCIpO1xuXG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9jb21wb25lbnRzL0dyaWRJdGVtLnZ1ZVxuXG5cblxuXG5cblxuLyogbm9ybWFsaXplIGNvbXBvbmVudCAqL1xuXG52YXIgY29tcG9uZW50ID0gT2JqZWN0KGNvbXBvbmVudE5vcm1hbGl6ZXJbXCJhXCIgLyogZGVmYXVsdCAqL10pKFxuICBjb21wb25lbnRzX0dyaWRJdGVtdnVlX3R5cGVfc2NyaXB0X2xhbmdfanNfLFxuICByZW5kZXIsXG4gIHN0YXRpY1JlbmRlckZucyxcbiAgZmFsc2UsXG4gIG51bGwsXG4gIG51bGwsXG4gIG51bGxcbiAgXG4pXG5cbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gdmFyIEdyaWRJdGVtID0gX193ZWJwYWNrX2V4cG9ydHNfX1tcImFcIl0gPSAoY29tcG9uZW50LmV4cG9ydHMpO1xuXG4vKioqLyB9KSxcblxuLyoqKi8gXCJiZTEzXCI6XG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cbi8vIDcuMi4xIFJlcXVpcmVPYmplY3RDb2VyY2libGUoYXJndW1lbnQpXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdCkge1xuICBpZiAoaXQgPT0gdW5kZWZpbmVkKSB0aHJvdyBUeXBlRXJyb3IoXCJDYW4ndCBjYWxsIG1ldGhvZCBvbiAgXCIgKyBpdCk7XG4gIHJldHVybiBpdDtcbn07XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiYzI3NFwiOlxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG52YXIgdXRpbHMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiNTBiZlwiKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBiYXRjaFByb2Nlc3Nvck1ha2VyKG9wdGlvbnMpIHtcbiAgICBvcHRpb25zICAgICAgICAgICAgID0gb3B0aW9ucyB8fCB7fTtcbiAgICB2YXIgcmVwb3J0ZXIgICAgICAgID0gb3B0aW9ucy5yZXBvcnRlcjtcbiAgICB2YXIgYXN5bmNQcm9jZXNzICAgID0gdXRpbHMuZ2V0T3B0aW9uKG9wdGlvbnMsIFwiYXN5bmNcIiwgdHJ1ZSk7XG4gICAgdmFyIGF1dG9Qcm9jZXNzICAgICA9IHV0aWxzLmdldE9wdGlvbihvcHRpb25zLCBcImF1dG9cIiwgdHJ1ZSk7XG5cbiAgICBpZihhdXRvUHJvY2VzcyAmJiAhYXN5bmNQcm9jZXNzKSB7XG4gICAgICAgIHJlcG9ydGVyICYmIHJlcG9ydGVyLndhcm4oXCJJbnZhbGlkIG9wdGlvbnMgY29tYmluYXRpb24uIGF1dG89dHJ1ZSBhbmQgYXN5bmM9ZmFsc2UgaXMgaW52YWxpZC4gU2V0dGluZyBhc3luYz10cnVlLlwiKTtcbiAgICAgICAgYXN5bmNQcm9jZXNzID0gdHJ1ZTtcbiAgICB9XG5cbiAgICB2YXIgYmF0Y2ggPSBCYXRjaCgpO1xuICAgIHZhciBhc3luY0ZyYW1lSGFuZGxlcjtcbiAgICB2YXIgaXNQcm9jZXNzaW5nID0gZmFsc2U7XG5cbiAgICBmdW5jdGlvbiBhZGRGdW5jdGlvbihsZXZlbCwgZm4pIHtcbiAgICAgICAgaWYoIWlzUHJvY2Vzc2luZyAmJiBhdXRvUHJvY2VzcyAmJiBhc3luY1Byb2Nlc3MgJiYgYmF0Y2guc2l6ZSgpID09PSAwKSB7XG4gICAgICAgICAgICAvLyBTaW5jZSB0aGlzIGlzIGFzeW5jLCBpdCBpcyBndWFyYW50ZWVkIHRvIGJlIGV4ZWN1dGVkIGFmdGVyIHRoYXQgdGhlIGZuIGlzIGFkZGVkIHRvIHRoZSBiYXRjaC5cbiAgICAgICAgICAgIC8vIFRoaXMgbmVlZHMgdG8gYmUgZG9uZSBiZWZvcmUsIHNpbmNlIHdlJ3JlIGNoZWNraW5nIHRoZSBzaXplIG9mIHRoZSBiYXRjaCB0byBiZSAwLlxuICAgICAgICAgICAgcHJvY2Vzc0JhdGNoQXN5bmMoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGJhdGNoLmFkZChsZXZlbCwgZm4pO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHByb2Nlc3NCYXRjaCgpIHtcbiAgICAgICAgLy8gU2F2ZSB0aGUgY3VycmVudCBiYXRjaCwgYW5kIGNyZWF0ZSBhIG5ldyBiYXRjaCBzbyB0aGF0IGluY29taW5nIGZ1bmN0aW9ucyBhcmUgbm90IGFkZGVkIGludG8gdGhlIGN1cnJlbnRseSBwcm9jZXNzaW5nIGJhdGNoLlxuICAgICAgICAvLyBDb250aW51ZSBwcm9jZXNzaW5nIHVudGlsIHRoZSB0b3AtbGV2ZWwgYmF0Y2ggaXMgZW1wdHkgKGZ1bmN0aW9ucyBtYXkgYmUgYWRkZWQgdG8gdGhlIG5ldyBiYXRjaCB3aGlsZSBwcm9jZXNzaW5nLCBhbmQgc28gb24pLlxuICAgICAgICBpc1Byb2Nlc3NpbmcgPSB0cnVlO1xuICAgICAgICB3aGlsZSAoYmF0Y2guc2l6ZSgpKSB7XG4gICAgICAgICAgICB2YXIgcHJvY2Vzc2luZ0JhdGNoID0gYmF0Y2g7XG4gICAgICAgICAgICBiYXRjaCA9IEJhdGNoKCk7XG4gICAgICAgICAgICBwcm9jZXNzaW5nQmF0Y2gucHJvY2VzcygpO1xuICAgICAgICB9XG4gICAgICAgIGlzUHJvY2Vzc2luZyA9IGZhbHNlO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGZvcmNlUHJvY2Vzc0JhdGNoKGxvY2FsQXN5bmNQcm9jZXNzKSB7XG4gICAgICAgIGlmIChpc1Byb2Nlc3NpbmcpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmKGxvY2FsQXN5bmNQcm9jZXNzID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGxvY2FsQXN5bmNQcm9jZXNzID0gYXN5bmNQcm9jZXNzO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYoYXN5bmNGcmFtZUhhbmRsZXIpIHtcbiAgICAgICAgICAgIGNhbmNlbEZyYW1lKGFzeW5jRnJhbWVIYW5kbGVyKTtcbiAgICAgICAgICAgIGFzeW5jRnJhbWVIYW5kbGVyID0gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmKGxvY2FsQXN5bmNQcm9jZXNzKSB7XG4gICAgICAgICAgICBwcm9jZXNzQmF0Y2hBc3luYygpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcHJvY2Vzc0JhdGNoKCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwcm9jZXNzQmF0Y2hBc3luYygpIHtcbiAgICAgICAgYXN5bmNGcmFtZUhhbmRsZXIgPSByZXF1ZXN0RnJhbWUocHJvY2Vzc0JhdGNoKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjbGVhckJhdGNoKCkge1xuICAgICAgICBiYXRjaCAgICAgICAgICAgPSB7fTtcbiAgICAgICAgYmF0Y2hTaXplICAgICAgID0gMDtcbiAgICAgICAgdG9wTGV2ZWwgICAgICAgID0gMDtcbiAgICAgICAgYm90dG9tTGV2ZWwgICAgID0gMDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjYW5jZWxGcmFtZShsaXN0ZW5lcikge1xuICAgICAgICAvLyB2YXIgY2FuY2VsID0gd2luZG93LmNhbmNlbEFuaW1hdGlvbkZyYW1lIHx8IHdpbmRvdy5tb3pDYW5jZWxBbmltYXRpb25GcmFtZSB8fCB3aW5kb3cud2Via2l0Q2FuY2VsQW5pbWF0aW9uRnJhbWUgfHwgd2luZG93LmNsZWFyVGltZW91dDtcbiAgICAgICAgdmFyIGNhbmNlbCA9IGNsZWFyVGltZW91dDtcbiAgICAgICAgcmV0dXJuIGNhbmNlbChsaXN0ZW5lcik7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcmVxdWVzdEZyYW1lKGNhbGxiYWNrKSB7XG4gICAgICAgIC8vIHZhciByYWYgPSB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lIHx8IHdpbmRvdy5tb3pSZXF1ZXN0QW5pbWF0aW9uRnJhbWUgfHwgd2luZG93LndlYmtpdFJlcXVlc3RBbmltYXRpb25GcmFtZSB8fCBmdW5jdGlvbihmbikgeyByZXR1cm4gd2luZG93LnNldFRpbWVvdXQoZm4sIDIwKTsgfTtcbiAgICAgICAgdmFyIHJhZiA9IGZ1bmN0aW9uKGZuKSB7IHJldHVybiBzZXRUaW1lb3V0KGZuLCAwKTsgfTtcbiAgICAgICAgcmV0dXJuIHJhZihjYWxsYmFjayk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgICAgYWRkOiBhZGRGdW5jdGlvbixcbiAgICAgICAgZm9yY2U6IGZvcmNlUHJvY2Vzc0JhdGNoXG4gICAgfTtcbn07XG5cbmZ1bmN0aW9uIEJhdGNoKCkge1xuICAgIHZhciBiYXRjaCAgICAgICA9IHt9O1xuICAgIHZhciBzaXplICAgICAgICA9IDA7XG4gICAgdmFyIHRvcExldmVsICAgID0gMDtcbiAgICB2YXIgYm90dG9tTGV2ZWwgPSAwO1xuXG4gICAgZnVuY3Rpb24gYWRkKGxldmVsLCBmbikge1xuICAgICAgICBpZighZm4pIHtcbiAgICAgICAgICAgIGZuID0gbGV2ZWw7XG4gICAgICAgICAgICBsZXZlbCA9IDA7XG4gICAgICAgIH1cblxuICAgICAgICBpZihsZXZlbCA+IHRvcExldmVsKSB7XG4gICAgICAgICAgICB0b3BMZXZlbCA9IGxldmVsO1xuICAgICAgICB9IGVsc2UgaWYobGV2ZWwgPCBib3R0b21MZXZlbCkge1xuICAgICAgICAgICAgYm90dG9tTGV2ZWwgPSBsZXZlbDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmKCFiYXRjaFtsZXZlbF0pIHtcbiAgICAgICAgICAgIGJhdGNoW2xldmVsXSA9IFtdO1xuICAgICAgICB9XG5cbiAgICAgICAgYmF0Y2hbbGV2ZWxdLnB1c2goZm4pO1xuICAgICAgICBzaXplKys7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcHJvY2VzcygpIHtcbiAgICAgICAgZm9yKHZhciBsZXZlbCA9IGJvdHRvbUxldmVsOyBsZXZlbCA8PSB0b3BMZXZlbDsgbGV2ZWwrKykge1xuICAgICAgICAgICAgdmFyIGZucyA9IGJhdGNoW2xldmVsXTtcblxuICAgICAgICAgICAgZm9yKHZhciBpID0gMDsgaSA8IGZucy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIHZhciBmbiA9IGZuc1tpXTtcbiAgICAgICAgICAgICAgICBmbigpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2V0U2l6ZSgpIHtcbiAgICAgICAgcmV0dXJuIHNpemU7XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgICAgYWRkOiBhZGQsXG4gICAgICAgIHByb2Nlc3M6IHByb2Nlc3MsXG4gICAgICAgIHNpemU6IGdldFNpemVcbiAgICB9O1xufVxuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcImMzNjZcIjpcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuLy8gZmFsc2UgLT4gQXJyYXkjaW5kZXhPZlxuLy8gdHJ1ZSAgLT4gQXJyYXkjaW5jbHVkZXNcbnZhciB0b0lPYmplY3QgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiNjgyMVwiKTtcbnZhciB0b0xlbmd0aCA9IF9fd2VicGFja19yZXF1aXJlX18oXCI5ZGVmXCIpO1xudmFyIHRvQWJzb2x1dGVJbmRleCA9IF9fd2VicGFja19yZXF1aXJlX18oXCI3N2YxXCIpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoSVNfSU5DTFVERVMpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uICgkdGhpcywgZWwsIGZyb21JbmRleCkge1xuICAgIHZhciBPID0gdG9JT2JqZWN0KCR0aGlzKTtcbiAgICB2YXIgbGVuZ3RoID0gdG9MZW5ndGgoTy5sZW5ndGgpO1xuICAgIHZhciBpbmRleCA9IHRvQWJzb2x1dGVJbmRleChmcm9tSW5kZXgsIGxlbmd0aCk7XG4gICAgdmFyIHZhbHVlO1xuICAgIC8vIEFycmF5I2luY2x1ZGVzIHVzZXMgU2FtZVZhbHVlWmVybyBlcXVhbGl0eSBhbGdvcml0aG1cbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tc2VsZi1jb21wYXJlXG4gICAgaWYgKElTX0lOQ0xVREVTICYmIGVsICE9IGVsKSB3aGlsZSAobGVuZ3RoID4gaW5kZXgpIHtcbiAgICAgIHZhbHVlID0gT1tpbmRleCsrXTtcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1zZWxmLWNvbXBhcmVcbiAgICAgIGlmICh2YWx1ZSAhPSB2YWx1ZSkgcmV0dXJuIHRydWU7XG4gICAgLy8gQXJyYXkjaW5kZXhPZiBpZ25vcmVzIGhvbGVzLCBBcnJheSNpbmNsdWRlcyAtIG5vdFxuICAgIH0gZWxzZSBmb3IgKDtsZW5ndGggPiBpbmRleDsgaW5kZXgrKykgaWYgKElTX0lOQ0xVREVTIHx8IGluZGV4IGluIE8pIHtcbiAgICAgIGlmIChPW2luZGV4XSA9PT0gZWwpIHJldHVybiBJU19JTkNMVURFUyB8fCBpbmRleCB8fCAwO1xuICAgIH0gcmV0dXJuICFJU19JTkNMVURFUyAmJiAtMTtcbiAgfTtcbn07XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiYzVmNlwiOlxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxudmFyIGdsb2JhbCA9IF9fd2VicGFja19yZXF1aXJlX18oXCI3NzI2XCIpO1xudmFyIGhhcyA9IF9fd2VicGFja19yZXF1aXJlX18oXCI2OWE4XCIpO1xudmFyIGNvZiA9IF9fd2VicGFja19yZXF1aXJlX18oXCIyZDk1XCIpO1xudmFyIGluaGVyaXRJZlJlcXVpcmVkID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIjVkYmNcIik7XG52YXIgdG9QcmltaXRpdmUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiNmE5OVwiKTtcbnZhciBmYWlscyA9IF9fd2VicGFja19yZXF1aXJlX18oXCI3OWU1XCIpO1xudmFyIGdPUE4gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiOTA5M1wiKS5mO1xudmFyIGdPUEQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiMTFlOVwiKS5mO1xudmFyIGRQID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIjg2Y2NcIikuZjtcbnZhciAkdHJpbSA9IF9fd2VicGFja19yZXF1aXJlX18oXCJhYTc3XCIpLnRyaW07XG52YXIgTlVNQkVSID0gJ051bWJlcic7XG52YXIgJE51bWJlciA9IGdsb2JhbFtOVU1CRVJdO1xudmFyIEJhc2UgPSAkTnVtYmVyO1xudmFyIHByb3RvID0gJE51bWJlci5wcm90b3R5cGU7XG4vLyBPcGVyYSB+MTIgaGFzIGJyb2tlbiBPYmplY3QjdG9TdHJpbmdcbnZhciBCUk9LRU5fQ09GID0gY29mKF9fd2VicGFja19yZXF1aXJlX18oXCIyYWViXCIpKHByb3RvKSkgPT0gTlVNQkVSO1xudmFyIFRSSU0gPSAndHJpbScgaW4gU3RyaW5nLnByb3RvdHlwZTtcblxuLy8gNy4xLjMgVG9OdW1iZXIoYXJndW1lbnQpXG52YXIgdG9OdW1iZXIgPSBmdW5jdGlvbiAoYXJndW1lbnQpIHtcbiAgdmFyIGl0ID0gdG9QcmltaXRpdmUoYXJndW1lbnQsIGZhbHNlKTtcbiAgaWYgKHR5cGVvZiBpdCA9PSAnc3RyaW5nJyAmJiBpdC5sZW5ndGggPiAyKSB7XG4gICAgaXQgPSBUUklNID8gaXQudHJpbSgpIDogJHRyaW0oaXQsIDMpO1xuICAgIHZhciBmaXJzdCA9IGl0LmNoYXJDb2RlQXQoMCk7XG4gICAgdmFyIHRoaXJkLCByYWRpeCwgbWF4Q29kZTtcbiAgICBpZiAoZmlyc3QgPT09IDQzIHx8IGZpcnN0ID09PSA0NSkge1xuICAgICAgdGhpcmQgPSBpdC5jaGFyQ29kZUF0KDIpO1xuICAgICAgaWYgKHRoaXJkID09PSA4OCB8fCB0aGlyZCA9PT0gMTIwKSByZXR1cm4gTmFOOyAvLyBOdW1iZXIoJysweDEnKSBzaG91bGQgYmUgTmFOLCBvbGQgVjggZml4XG4gICAgfSBlbHNlIGlmIChmaXJzdCA9PT0gNDgpIHtcbiAgICAgIHN3aXRjaCAoaXQuY2hhckNvZGVBdCgxKSkge1xuICAgICAgICBjYXNlIDY2OiBjYXNlIDk4OiByYWRpeCA9IDI7IG1heENvZGUgPSA0OTsgYnJlYWs7IC8vIGZhc3QgZXF1YWwgL14wYlswMV0rJC9pXG4gICAgICAgIGNhc2UgNzk6IGNhc2UgMTExOiByYWRpeCA9IDg7IG1heENvZGUgPSA1NTsgYnJlYWs7IC8vIGZhc3QgZXF1YWwgL14wb1swLTddKyQvaVxuICAgICAgICBkZWZhdWx0OiByZXR1cm4gK2l0O1xuICAgICAgfVxuICAgICAgZm9yICh2YXIgZGlnaXRzID0gaXQuc2xpY2UoMiksIGkgPSAwLCBsID0gZGlnaXRzLmxlbmd0aCwgY29kZTsgaSA8IGw7IGkrKykge1xuICAgICAgICBjb2RlID0gZGlnaXRzLmNoYXJDb2RlQXQoaSk7XG4gICAgICAgIC8vIHBhcnNlSW50IHBhcnNlcyBhIHN0cmluZyB0byBhIGZpcnN0IHVuYXZhaWxhYmxlIHN5bWJvbFxuICAgICAgICAvLyBidXQgVG9OdW1iZXIgc2hvdWxkIHJldHVybiBOYU4gaWYgYSBzdHJpbmcgY29udGFpbnMgdW5hdmFpbGFibGUgc3ltYm9sc1xuICAgICAgICBpZiAoY29kZSA8IDQ4IHx8IGNvZGUgPiBtYXhDb2RlKSByZXR1cm4gTmFOO1xuICAgICAgfSByZXR1cm4gcGFyc2VJbnQoZGlnaXRzLCByYWRpeCk7XG4gICAgfVxuICB9IHJldHVybiAraXQ7XG59O1xuXG5pZiAoISROdW1iZXIoJyAwbzEnKSB8fCAhJE51bWJlcignMGIxJykgfHwgJE51bWJlcignKzB4MScpKSB7XG4gICROdW1iZXIgPSBmdW5jdGlvbiBOdW1iZXIodmFsdWUpIHtcbiAgICB2YXIgaXQgPSBhcmd1bWVudHMubGVuZ3RoIDwgMSA/IDAgOiB2YWx1ZTtcbiAgICB2YXIgdGhhdCA9IHRoaXM7XG4gICAgcmV0dXJuIHRoYXQgaW5zdGFuY2VvZiAkTnVtYmVyXG4gICAgICAvLyBjaGVjayBvbiAxLi5jb25zdHJ1Y3Rvcihmb28pIGNhc2VcbiAgICAgICYmIChCUk9LRU5fQ09GID8gZmFpbHMoZnVuY3Rpb24gKCkgeyBwcm90by52YWx1ZU9mLmNhbGwodGhhdCk7IH0pIDogY29mKHRoYXQpICE9IE5VTUJFUilcbiAgICAgICAgPyBpbmhlcml0SWZSZXF1aXJlZChuZXcgQmFzZSh0b051bWJlcihpdCkpLCB0aGF0LCAkTnVtYmVyKSA6IHRvTnVtYmVyKGl0KTtcbiAgfTtcbiAgZm9yICh2YXIga2V5cyA9IF9fd2VicGFja19yZXF1aXJlX18oXCI5ZTFlXCIpID8gZ09QTihCYXNlKSA6IChcbiAgICAvLyBFUzM6XG4gICAgJ01BWF9WQUxVRSxNSU5fVkFMVUUsTmFOLE5FR0FUSVZFX0lORklOSVRZLFBPU0lUSVZFX0lORklOSVRZLCcgK1xuICAgIC8vIEVTNiAoaW4gY2FzZSwgaWYgbW9kdWxlcyB3aXRoIEVTNiBOdW1iZXIgc3RhdGljcyByZXF1aXJlZCBiZWZvcmUpOlxuICAgICdFUFNJTE9OLGlzRmluaXRlLGlzSW50ZWdlcixpc05hTixpc1NhZmVJbnRlZ2VyLE1BWF9TQUZFX0lOVEVHRVIsJyArXG4gICAgJ01JTl9TQUZFX0lOVEVHRVIscGFyc2VGbG9hdCxwYXJzZUludCxpc0ludGVnZXInXG4gICkuc3BsaXQoJywnKSwgaiA9IDAsIGtleTsga2V5cy5sZW5ndGggPiBqOyBqKyspIHtcbiAgICBpZiAoaGFzKEJhc2UsIGtleSA9IGtleXNbal0pICYmICFoYXMoJE51bWJlciwga2V5KSkge1xuICAgICAgZFAoJE51bWJlciwga2V5LCBnT1BEKEJhc2UsIGtleSkpO1xuICAgIH1cbiAgfVxuICAkTnVtYmVyLnByb3RvdHlwZSA9IHByb3RvO1xuICBwcm90by5jb25zdHJ1Y3RvciA9ICROdW1iZXI7XG4gIF9fd2VicGFja19yZXF1aXJlX18oXCIyYWJhXCIpKGdsb2JhbCwgTlVNQkVSLCAkTnVtYmVyKTtcbn1cblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCJjNjlhXCI6XG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbm1vZHVsZS5leHBvcnRzID0gIV9fd2VicGFja19yZXF1aXJlX18oXCI5ZTFlXCIpICYmICFfX3dlYnBhY2tfcmVxdWlyZV9fKFwiNzllNVwiKShmdW5jdGlvbiAoKSB7XG4gIHJldHVybiBPYmplY3QuZGVmaW5lUHJvcGVydHkoX193ZWJwYWNrX3JlcXVpcmVfXyhcIjIzMGVcIikoJ2RpdicpLCAnYScsIHsgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiA3OyB9IH0pLmEgIT0gNztcbn0pO1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcImM4YmFcIjpcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxudmFyIGc7XG5cbi8vIFRoaXMgd29ya3MgaW4gbm9uLXN0cmljdCBtb2RlXG5nID0gKGZ1bmN0aW9uKCkge1xuXHRyZXR1cm4gdGhpcztcbn0pKCk7XG5cbnRyeSB7XG5cdC8vIFRoaXMgd29ya3MgaWYgZXZhbCBpcyBhbGxvd2VkIChzZWUgQ1NQKVxuXHRnID0gZyB8fCBuZXcgRnVuY3Rpb24oXCJyZXR1cm4gdGhpc1wiKSgpO1xufSBjYXRjaCAoZSkge1xuXHQvLyBUaGlzIHdvcmtzIGlmIHRoZSB3aW5kb3cgcmVmZXJlbmNlIGlzIGF2YWlsYWJsZVxuXHRpZiAodHlwZW9mIHdpbmRvdyA9PT0gXCJvYmplY3RcIikgZyA9IHdpbmRvdztcbn1cblxuLy8gZyBjYW4gc3RpbGwgYmUgdW5kZWZpbmVkLCBidXQgbm90aGluZyB0byBkbyBhYm91dCBpdC4uLlxuLy8gV2UgcmV0dXJuIHVuZGVmaW5lZCwgaW5zdGVhZCBvZiBub3RoaW5nIGhlcmUsIHNvIGl0J3Ncbi8vIGVhc2llciB0byBoYW5kbGUgdGhpcyBjYXNlLiBpZighZ2xvYmFsKSB7IC4uLn1cblxubW9kdWxlLmV4cG9ydHMgPSBnO1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcImM5NDZcIjpcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG4vKipcbiAqIFJlc2l6ZSBkZXRlY3Rpb24gc3RyYXRlZ3kgdGhhdCBpbmplY3RzIGRpdnMgdG8gZWxlbWVudHMgaW4gb3JkZXIgdG8gZGV0ZWN0IHJlc2l6ZSBldmVudHMgb24gc2Nyb2xsIGV2ZW50cy5cbiAqIEhlYXZpbHkgaW5zcGlyZWQgYnk6IGh0dHBzOi8vZ2l0aHViLmNvbS9tYXJjai9jc3MtZWxlbWVudC1xdWVyaWVzL2Jsb2IvbWFzdGVyL3NyYy9SZXNpemVTZW5zb3IuanNcbiAqL1xuXG5cblxudmFyIGZvckVhY2ggPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiYjc3MFwiKS5mb3JFYWNoO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICBvcHRpb25zICAgICAgICAgICAgID0gb3B0aW9ucyB8fCB7fTtcbiAgICB2YXIgcmVwb3J0ZXIgICAgICAgID0gb3B0aW9ucy5yZXBvcnRlcjtcbiAgICB2YXIgYmF0Y2hQcm9jZXNzb3IgID0gb3B0aW9ucy5iYXRjaFByb2Nlc3NvcjtcbiAgICB2YXIgZ2V0U3RhdGUgICAgICAgID0gb3B0aW9ucy5zdGF0ZUhhbmRsZXIuZ2V0U3RhdGU7XG4gICAgdmFyIGhhc1N0YXRlICAgICAgICA9IG9wdGlvbnMuc3RhdGVIYW5kbGVyLmhhc1N0YXRlO1xuICAgIHZhciBpZEhhbmRsZXIgICAgICAgPSBvcHRpb25zLmlkSGFuZGxlcjtcblxuICAgIGlmICghYmF0Y2hQcm9jZXNzb3IpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTWlzc2luZyByZXF1aXJlZCBkZXBlbmRlbmN5OiBiYXRjaFByb2Nlc3NvclwiKTtcbiAgICB9XG5cbiAgICBpZiAoIXJlcG9ydGVyKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIk1pc3NpbmcgcmVxdWlyZWQgZGVwZW5kZW5jeTogcmVwb3J0ZXIuXCIpO1xuICAgIH1cblxuICAgIC8vVE9ETzogQ291bGQgdGhpcyBwZXJoYXBzIGJlIGRvbmUgYXQgaW5zdGFsbGF0aW9uIHRpbWU/XG4gICAgdmFyIHNjcm9sbGJhclNpemVzID0gZ2V0U2Nyb2xsYmFyU2l6ZXMoKTtcblxuICAgIHZhciBzdHlsZUlkID0gXCJlcmRfc2Nyb2xsX2RldGVjdGlvbl9zY3JvbGxiYXJfc3R5bGVcIjtcbiAgICB2YXIgZGV0ZWN0aW9uQ29udGFpbmVyQ2xhc3MgPSBcImVyZF9zY3JvbGxfZGV0ZWN0aW9uX2NvbnRhaW5lclwiO1xuXG4gICAgZnVuY3Rpb24gaW5pdERvY3VtZW50KHRhcmdldERvY3VtZW50KSB7XG4gICAgICAgIC8vIEluamVjdCB0aGUgc2Nyb2xsYmFyIHN0eWxpbmcgdGhhdCBwcmV2ZW50cyB0aGVtIGZyb20gYXBwZWFyaW5nIHNvbWV0aW1lcyBpbiBDaHJvbWUuXG4gICAgICAgIC8vIFRoZSBpbmplY3RlZCBjb250YWluZXIgbmVlZHMgdG8gaGF2ZSBhIGNsYXNzLCBzbyB0aGF0IGl0IG1heSBiZSBzdHlsZWQgd2l0aCBDU1MgKHBzZXVkbyBlbGVtZW50cykuXG4gICAgICAgIGluamVjdFNjcm9sbFN0eWxlKHRhcmdldERvY3VtZW50LCBzdHlsZUlkLCBkZXRlY3Rpb25Db250YWluZXJDbGFzcyk7XG4gICAgfVxuXG4gICAgaW5pdERvY3VtZW50KHdpbmRvdy5kb2N1bWVudCk7XG5cbiAgICBmdW5jdGlvbiBidWlsZENzc1RleHRTdHJpbmcocnVsZXMpIHtcbiAgICAgICAgdmFyIHNlcGVyYXRvciA9IG9wdGlvbnMuaW1wb3J0YW50ID8gXCIgIWltcG9ydGFudDsgXCIgOiBcIjsgXCI7XG5cbiAgICAgICAgcmV0dXJuIChydWxlcy5qb2luKHNlcGVyYXRvcikgKyBzZXBlcmF0b3IpLnRyaW0oKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXRTY3JvbGxiYXJTaXplcygpIHtcbiAgICAgICAgdmFyIHdpZHRoID0gNTAwO1xuICAgICAgICB2YXIgaGVpZ2h0ID0gNTAwO1xuXG4gICAgICAgIHZhciBjaGlsZCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgICAgIGNoaWxkLnN0eWxlLmNzc1RleHQgPSBidWlsZENzc1RleHRTdHJpbmcoW1wicG9zaXRpb246IGFic29sdXRlXCIsIFwid2lkdGg6IFwiICsgd2lkdGgqMiArIFwicHhcIiwgXCJoZWlnaHQ6IFwiICsgaGVpZ2h0KjIgKyBcInB4XCIsIFwidmlzaWJpbGl0eTogaGlkZGVuXCIsIFwibWFyZ2luOiAwXCIsIFwicGFkZGluZzogMFwiXSk7XG5cbiAgICAgICAgdmFyIGNvbnRhaW5lciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgICAgIGNvbnRhaW5lci5zdHlsZS5jc3NUZXh0ID0gYnVpbGRDc3NUZXh0U3RyaW5nKFtcInBvc2l0aW9uOiBhYnNvbHV0ZVwiLCBcIndpZHRoOiBcIiArIHdpZHRoICsgXCJweFwiLCBcImhlaWdodDogXCIgKyBoZWlnaHQgKyBcInB4XCIsIFwib3ZlcmZsb3c6IHNjcm9sbFwiLCBcInZpc2liaWxpdHk6IG5vbmVcIiwgXCJ0b3A6IFwiICsgLXdpZHRoKjMgKyBcInB4XCIsIFwibGVmdDogXCIgKyAtaGVpZ2h0KjMgKyBcInB4XCIsIFwidmlzaWJpbGl0eTogaGlkZGVuXCIsIFwibWFyZ2luOiAwXCIsIFwicGFkZGluZzogMFwiXSk7XG5cbiAgICAgICAgY29udGFpbmVyLmFwcGVuZENoaWxkKGNoaWxkKTtcblxuICAgICAgICBkb2N1bWVudC5ib2R5Lmluc2VydEJlZm9yZShjb250YWluZXIsIGRvY3VtZW50LmJvZHkuZmlyc3RDaGlsZCk7XG5cbiAgICAgICAgdmFyIHdpZHRoU2l6ZSA9IHdpZHRoIC0gY29udGFpbmVyLmNsaWVudFdpZHRoO1xuICAgICAgICB2YXIgaGVpZ2h0U2l6ZSA9IGhlaWdodCAtIGNvbnRhaW5lci5jbGllbnRIZWlnaHQ7XG5cbiAgICAgICAgZG9jdW1lbnQuYm9keS5yZW1vdmVDaGlsZChjb250YWluZXIpO1xuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB3aWR0aDogd2lkdGhTaXplLFxuICAgICAgICAgICAgaGVpZ2h0OiBoZWlnaHRTaXplXG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaW5qZWN0U2Nyb2xsU3R5bGUodGFyZ2V0RG9jdW1lbnQsIHN0eWxlSWQsIGNvbnRhaW5lckNsYXNzKSB7XG4gICAgICAgIGZ1bmN0aW9uIGluamVjdFN0eWxlKHN0eWxlLCBtZXRob2QpIHtcbiAgICAgICAgICAgIG1ldGhvZCA9IG1ldGhvZCB8fCBmdW5jdGlvbiAoZWxlbWVudCkge1xuICAgICAgICAgICAgICAgIHRhcmdldERvY3VtZW50LmhlYWQuYXBwZW5kQ2hpbGQoZWxlbWVudCk7XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICB2YXIgc3R5bGVFbGVtZW50ID0gdGFyZ2V0RG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInN0eWxlXCIpO1xuICAgICAgICAgICAgc3R5bGVFbGVtZW50LmlubmVySFRNTCA9IHN0eWxlO1xuICAgICAgICAgICAgc3R5bGVFbGVtZW50LmlkID0gc3R5bGVJZDtcbiAgICAgICAgICAgIG1ldGhvZChzdHlsZUVsZW1lbnQpO1xuICAgICAgICAgICAgcmV0dXJuIHN0eWxlRWxlbWVudDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghdGFyZ2V0RG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoc3R5bGVJZCkpIHtcbiAgICAgICAgICAgIHZhciBjb250YWluZXJBbmltYXRpb25DbGFzcyA9IGNvbnRhaW5lckNsYXNzICsgXCJfYW5pbWF0aW9uXCI7XG4gICAgICAgICAgICB2YXIgY29udGFpbmVyQW5pbWF0aW9uQWN0aXZlQ2xhc3MgPSBjb250YWluZXJDbGFzcyArIFwiX2FuaW1hdGlvbl9hY3RpdmVcIjtcbiAgICAgICAgICAgIHZhciBzdHlsZSA9IFwiLyogQ3JlYXRlZCBieSB0aGUgZWxlbWVudC1yZXNpemUtZGV0ZWN0b3IgbGlicmFyeS4gKi9cXG5cIjtcbiAgICAgICAgICAgIHN0eWxlICs9IFwiLlwiICsgY29udGFpbmVyQ2xhc3MgKyBcIiA+IGRpdjo6LXdlYmtpdC1zY3JvbGxiYXIgeyBcIiArIGJ1aWxkQ3NzVGV4dFN0cmluZyhbXCJkaXNwbGF5OiBub25lXCJdKSArIFwiIH1cXG5cXG5cIjtcbiAgICAgICAgICAgIHN0eWxlICs9IFwiLlwiICsgY29udGFpbmVyQW5pbWF0aW9uQWN0aXZlQ2xhc3MgKyBcIiB7IFwiICsgYnVpbGRDc3NUZXh0U3RyaW5nKFtcIi13ZWJraXQtYW5pbWF0aW9uLWR1cmF0aW9uOiAwLjFzXCIsIFwiYW5pbWF0aW9uLWR1cmF0aW9uOiAwLjFzXCIsIFwiLXdlYmtpdC1hbmltYXRpb24tbmFtZTogXCIgKyBjb250YWluZXJBbmltYXRpb25DbGFzcywgXCJhbmltYXRpb24tbmFtZTogXCIgKyBjb250YWluZXJBbmltYXRpb25DbGFzc10pICsgXCIgfVxcblwiO1xuICAgICAgICAgICAgc3R5bGUgKz0gXCJALXdlYmtpdC1rZXlmcmFtZXMgXCIgKyBjb250YWluZXJBbmltYXRpb25DbGFzcyArICBcIiB7IDAlIHsgb3BhY2l0eTogMTsgfSA1MCUgeyBvcGFjaXR5OiAwOyB9IDEwMCUgeyBvcGFjaXR5OiAxOyB9IH1cXG5cIjtcbiAgICAgICAgICAgIHN0eWxlICs9IFwiQGtleWZyYW1lcyBcIiArIGNvbnRhaW5lckFuaW1hdGlvbkNsYXNzICsgICAgICAgICAgXCIgeyAwJSB7IG9wYWNpdHk6IDE7IH0gNTAlIHsgb3BhY2l0eTogMDsgfSAxMDAlIHsgb3BhY2l0eTogMTsgfSB9XCI7XG4gICAgICAgICAgICBpbmplY3RTdHlsZShzdHlsZSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBhZGRBbmltYXRpb25DbGFzcyhlbGVtZW50KSB7XG4gICAgICAgIGVsZW1lbnQuY2xhc3NOYW1lICs9IFwiIFwiICsgZGV0ZWN0aW9uQ29udGFpbmVyQ2xhc3MgKyBcIl9hbmltYXRpb25fYWN0aXZlXCI7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gYWRkRXZlbnQoZWwsIG5hbWUsIGNiKSB7XG4gICAgICAgIGlmIChlbC5hZGRFdmVudExpc3RlbmVyKSB7XG4gICAgICAgICAgICBlbC5hZGRFdmVudExpc3RlbmVyKG5hbWUsIGNiKTtcbiAgICAgICAgfSBlbHNlIGlmKGVsLmF0dGFjaEV2ZW50KSB7XG4gICAgICAgICAgICBlbC5hdHRhY2hFdmVudChcIm9uXCIgKyBuYW1lLCBjYik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gcmVwb3J0ZXIuZXJyb3IoXCJbc2Nyb2xsXSBEb24ndCBrbm93IGhvdyB0byBhZGQgZXZlbnQgbGlzdGVuZXJzLlwiKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHJlbW92ZUV2ZW50KGVsLCBuYW1lLCBjYikge1xuICAgICAgICBpZiAoZWwucmVtb3ZlRXZlbnRMaXN0ZW5lcikge1xuICAgICAgICAgICAgZWwucmVtb3ZlRXZlbnRMaXN0ZW5lcihuYW1lLCBjYik7XG4gICAgICAgIH0gZWxzZSBpZihlbC5kZXRhY2hFdmVudCkge1xuICAgICAgICAgICAgZWwuZGV0YWNoRXZlbnQoXCJvblwiICsgbmFtZSwgY2IpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHJlcG9ydGVyLmVycm9yKFwiW3Njcm9sbF0gRG9uJ3Qga25vdyBob3cgdG8gcmVtb3ZlIGV2ZW50IGxpc3RlbmVycy5cIik7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXRFeHBhbmRFbGVtZW50KGVsZW1lbnQpIHtcbiAgICAgICAgcmV0dXJuIGdldFN0YXRlKGVsZW1lbnQpLmNvbnRhaW5lci5jaGlsZE5vZGVzWzBdLmNoaWxkTm9kZXNbMF0uY2hpbGROb2Rlc1swXTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXRTaHJpbmtFbGVtZW50KGVsZW1lbnQpIHtcbiAgICAgICAgcmV0dXJuIGdldFN0YXRlKGVsZW1lbnQpLmNvbnRhaW5lci5jaGlsZE5vZGVzWzBdLmNoaWxkTm9kZXNbMF0uY2hpbGROb2Rlc1sxXTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBZGRzIGEgcmVzaXplIGV2ZW50IGxpc3RlbmVyIHRvIHRoZSBlbGVtZW50LlxuICAgICAqIEBwdWJsaWNcbiAgICAgKiBAcGFyYW0ge2VsZW1lbnR9IGVsZW1lbnQgVGhlIGVsZW1lbnQgdGhhdCBzaG91bGQgaGF2ZSB0aGUgbGlzdGVuZXIgYWRkZWQuXG4gICAgICogQHBhcmFtIHtmdW5jdGlvbn0gbGlzdGVuZXIgVGhlIGxpc3RlbmVyIGNhbGxiYWNrIHRvIGJlIGNhbGxlZCBmb3IgZWFjaCByZXNpemUgZXZlbnQgb2YgdGhlIGVsZW1lbnQuIFRoZSBlbGVtZW50IHdpbGwgYmUgZ2l2ZW4gYXMgYSBwYXJhbWV0ZXIgdG8gdGhlIGxpc3RlbmVyIGNhbGxiYWNrLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGFkZExpc3RlbmVyKGVsZW1lbnQsIGxpc3RlbmVyKSB7XG4gICAgICAgIHZhciBsaXN0ZW5lcnMgPSBnZXRTdGF0ZShlbGVtZW50KS5saXN0ZW5lcnM7XG5cbiAgICAgICAgaWYgKCFsaXN0ZW5lcnMucHVzaCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IGFkZCBsaXN0ZW5lciB0byBhbiBlbGVtZW50IHRoYXQgaXMgbm90IGRldGVjdGFibGUuXCIpO1xuICAgICAgICB9XG5cbiAgICAgICAgZ2V0U3RhdGUoZWxlbWVudCkubGlzdGVuZXJzLnB1c2gobGlzdGVuZXIpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIE1ha2VzIGFuIGVsZW1lbnQgZGV0ZWN0YWJsZSBhbmQgcmVhZHkgdG8gYmUgbGlzdGVuZWQgZm9yIHJlc2l6ZSBldmVudHMuIFdpbGwgY2FsbCB0aGUgY2FsbGJhY2sgd2hlbiB0aGUgZWxlbWVudCBpcyByZWFkeSB0byBiZSBsaXN0ZW5lZCBmb3IgcmVzaXplIGNoYW5nZXMuXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gb3B0aW9ucyBPcHRpb25hbCBvcHRpb25zIG9iamVjdC5cbiAgICAgKiBAcGFyYW0ge2VsZW1lbnR9IGVsZW1lbnQgVGhlIGVsZW1lbnQgdG8gbWFrZSBkZXRlY3RhYmxlXG4gICAgICogQHBhcmFtIHtmdW5jdGlvbn0gY2FsbGJhY2sgVGhlIGNhbGxiYWNrIHRvIGJlIGNhbGxlZCB3aGVuIHRoZSBlbGVtZW50IGlzIHJlYWR5IHRvIGJlIGxpc3RlbmVkIGZvciByZXNpemUgY2hhbmdlcy4gV2lsbCBiZSBjYWxsZWQgd2l0aCB0aGUgZWxlbWVudCBhcyBmaXJzdCBwYXJhbWV0ZXIuXG4gICAgICovXG4gICAgZnVuY3Rpb24gbWFrZURldGVjdGFibGUob3B0aW9ucywgZWxlbWVudCwgY2FsbGJhY2spIHtcbiAgICAgICAgaWYgKCFjYWxsYmFjaykge1xuICAgICAgICAgICAgY2FsbGJhY2sgPSBlbGVtZW50O1xuICAgICAgICAgICAgZWxlbWVudCA9IG9wdGlvbnM7XG4gICAgICAgICAgICBvcHRpb25zID0gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG4gICAgICAgIGZ1bmN0aW9uIGRlYnVnKCkge1xuICAgICAgICAgICAgaWYgKG9wdGlvbnMuZGVidWcpIHtcbiAgICAgICAgICAgICAgICB2YXIgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cyk7XG4gICAgICAgICAgICAgICAgYXJncy51bnNoaWZ0KGlkSGFuZGxlci5nZXQoZWxlbWVudCksIFwiU2Nyb2xsOiBcIik7XG4gICAgICAgICAgICAgICAgaWYgKHJlcG9ydGVyLmxvZy5hcHBseSkge1xuICAgICAgICAgICAgICAgICAgICByZXBvcnRlci5sb2cuYXBwbHkobnVsbCwgYXJncyk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcmdzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXBvcnRlci5sb2coYXJnc1tpXSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBpc0RldGFjaGVkKGVsZW1lbnQpIHtcbiAgICAgICAgICAgIGZ1bmN0aW9uIGlzSW5Eb2N1bWVudChlbGVtZW50KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGVsZW1lbnQgPT09IGVsZW1lbnQub3duZXJEb2N1bWVudC5ib2R5IHx8IGVsZW1lbnQub3duZXJEb2N1bWVudC5ib2R5LmNvbnRhaW5zKGVsZW1lbnQpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoIWlzSW5Eb2N1bWVudChlbGVtZW50KSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBGaXJlRm94IHJldHVybnMgbnVsbCBzdHlsZSBpbiBoaWRkZW4gaWZyYW1lcy4gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS93bnIvZWxlbWVudC1yZXNpemUtZGV0ZWN0b3IvaXNzdWVzLzY4IGFuZCBodHRwczovL2J1Z3ppbGxhLm1vemlsbGEub3JnL3Nob3dfYnVnLmNnaT9pZD03OTU1MjBcbiAgICAgICAgICAgIGlmICh3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShlbGVtZW50KSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBpc1VucmVuZGVyZWQoZWxlbWVudCkge1xuICAgICAgICAgICAgLy8gQ2hlY2sgdGhlIGFic29sdXRlIHBvc2l0aW9uZWQgY29udGFpbmVyIHNpbmNlIHRoZSB0b3AgbGV2ZWwgY29udGFpbmVyIGlzIGRpc3BsYXk6IGlubGluZS5cbiAgICAgICAgICAgIHZhciBjb250YWluZXIgPSBnZXRTdGF0ZShlbGVtZW50KS5jb250YWluZXIuY2hpbGROb2Rlc1swXTtcbiAgICAgICAgICAgIHZhciBzdHlsZSA9IHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKGNvbnRhaW5lcik7XG4gICAgICAgICAgICByZXR1cm4gIXN0eWxlLndpZHRoIHx8IHN0eWxlLndpZHRoLmluZGV4T2YoXCJweFwiKSA9PT0gLTE7IC8vQ2FuIG9ubHkgY29tcHV0ZSBwaXhlbCB2YWx1ZSB3aGVuIHJlbmRlcmVkLlxuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gZ2V0U3R5bGUoKSB7XG4gICAgICAgICAgICAvLyBTb21lIGJyb3dzZXJzIG9ubHkgZm9yY2UgbGF5b3V0cyB3aGVuIGFjdHVhbGx5IHJlYWRpbmcgdGhlIHN0eWxlIHByb3BlcnRpZXMgb2YgdGhlIHN0eWxlIG9iamVjdCwgc28gbWFrZSBzdXJlIHRoYXQgdGhleSBhcmUgYWxsIHJlYWQgaGVyZSxcbiAgICAgICAgICAgIC8vIHNvIHRoYXQgdGhlIHVzZXIgb2YgdGhlIGZ1bmN0aW9uIGNhbiBiZSBzdXJlIHRoYXQgaXQgd2lsbCBwZXJmb3JtIHRoZSBsYXlvdXQgaGVyZSwgaW5zdGVhZCBvZiBsYXRlciAoaW1wb3J0YW50IGZvciBiYXRjaGluZykuXG4gICAgICAgICAgICB2YXIgZWxlbWVudFN0eWxlICAgICAgICAgICAgPSB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShlbGVtZW50KTtcbiAgICAgICAgICAgIHZhciBzdHlsZSAgICAgICAgICAgICAgICAgICA9IHt9O1xuICAgICAgICAgICAgc3R5bGUucG9zaXRpb24gICAgICAgICAgICAgID0gZWxlbWVudFN0eWxlLnBvc2l0aW9uO1xuICAgICAgICAgICAgc3R5bGUud2lkdGggICAgICAgICAgICAgICAgID0gZWxlbWVudC5vZmZzZXRXaWR0aDtcbiAgICAgICAgICAgIHN0eWxlLmhlaWdodCAgICAgICAgICAgICAgICA9IGVsZW1lbnQub2Zmc2V0SGVpZ2h0O1xuICAgICAgICAgICAgc3R5bGUudG9wICAgICAgICAgICAgICAgICAgID0gZWxlbWVudFN0eWxlLnRvcDtcbiAgICAgICAgICAgIHN0eWxlLnJpZ2h0ICAgICAgICAgICAgICAgICA9IGVsZW1lbnRTdHlsZS5yaWdodDtcbiAgICAgICAgICAgIHN0eWxlLmJvdHRvbSAgICAgICAgICAgICAgICA9IGVsZW1lbnRTdHlsZS5ib3R0b207XG4gICAgICAgICAgICBzdHlsZS5sZWZ0ICAgICAgICAgICAgICAgICAgPSBlbGVtZW50U3R5bGUubGVmdDtcbiAgICAgICAgICAgIHN0eWxlLndpZHRoQ1NTICAgICAgICAgICAgICA9IGVsZW1lbnRTdHlsZS53aWR0aDtcbiAgICAgICAgICAgIHN0eWxlLmhlaWdodENTUyAgICAgICAgICAgICA9IGVsZW1lbnRTdHlsZS5oZWlnaHQ7XG4gICAgICAgICAgICByZXR1cm4gc3R5bGU7XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBzdG9yZVN0YXJ0U2l6ZSgpIHtcbiAgICAgICAgICAgIHZhciBzdHlsZSA9IGdldFN0eWxlKCk7XG4gICAgICAgICAgICBnZXRTdGF0ZShlbGVtZW50KS5zdGFydFNpemUgPSB7XG4gICAgICAgICAgICAgICAgd2lkdGg6IHN0eWxlLndpZHRoLFxuICAgICAgICAgICAgICAgIGhlaWdodDogc3R5bGUuaGVpZ2h0XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgZGVidWcoXCJFbGVtZW50IHN0YXJ0IHNpemVcIiwgZ2V0U3RhdGUoZWxlbWVudCkuc3RhcnRTaXplKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIGluaXRMaXN0ZW5lcnMoKSB7XG4gICAgICAgICAgICBnZXRTdGF0ZShlbGVtZW50KS5saXN0ZW5lcnMgPSBbXTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIHN0b3JlU3R5bGUoKSB7XG4gICAgICAgICAgICBkZWJ1ZyhcInN0b3JlU3R5bGUgaW52b2tlZC5cIik7XG4gICAgICAgICAgICBpZiAoIWdldFN0YXRlKGVsZW1lbnQpKSB7XG4gICAgICAgICAgICAgICAgZGVidWcoXCJBYm9ydGluZyBiZWNhdXNlIGVsZW1lbnQgaGFzIGJlZW4gdW5pbnN0YWxsZWRcIik7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgc3R5bGUgPSBnZXRTdHlsZSgpO1xuICAgICAgICAgICAgZ2V0U3RhdGUoZWxlbWVudCkuc3R5bGUgPSBzdHlsZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIHN0b3JlQ3VycmVudFNpemUoZWxlbWVudCwgd2lkdGgsIGhlaWdodCkge1xuICAgICAgICAgICAgZ2V0U3RhdGUoZWxlbWVudCkubGFzdFdpZHRoID0gd2lkdGg7XG4gICAgICAgICAgICBnZXRTdGF0ZShlbGVtZW50KS5sYXN0SGVpZ2h0ICA9IGhlaWdodDtcbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIGdldEV4cGFuZENoaWxkRWxlbWVudChlbGVtZW50KSB7XG4gICAgICAgICAgICByZXR1cm4gZ2V0RXhwYW5kRWxlbWVudChlbGVtZW50KS5jaGlsZE5vZGVzWzBdO1xuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gZ2V0V2lkdGhPZmZzZXQoKSB7XG4gICAgICAgICAgICByZXR1cm4gMiAqIHNjcm9sbGJhclNpemVzLndpZHRoICsgMTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIGdldEhlaWdodE9mZnNldCgpIHtcbiAgICAgICAgICAgIHJldHVybiAyICogc2Nyb2xsYmFyU2l6ZXMuaGVpZ2h0ICsgMTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIGdldEV4cGFuZFdpZHRoKHdpZHRoKSB7XG4gICAgICAgICAgICByZXR1cm4gd2lkdGggKyAxMCArIGdldFdpZHRoT2Zmc2V0KCk7XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBnZXRFeHBhbmRIZWlnaHQoaGVpZ2h0KSB7XG4gICAgICAgICAgICByZXR1cm4gaGVpZ2h0ICsgMTAgKyBnZXRIZWlnaHRPZmZzZXQoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIGdldFNocmlua1dpZHRoKHdpZHRoKSB7XG4gICAgICAgICAgICByZXR1cm4gd2lkdGggKiAyICsgZ2V0V2lkdGhPZmZzZXQoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIGdldFNocmlua0hlaWdodChoZWlnaHQpIHtcbiAgICAgICAgICAgIHJldHVybiBoZWlnaHQgKiAyICsgZ2V0SGVpZ2h0T2Zmc2V0KCk7XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBwb3NpdGlvblNjcm9sbGJhcnMoZWxlbWVudCwgd2lkdGgsIGhlaWdodCkge1xuICAgICAgICAgICAgdmFyIGV4cGFuZCAgICAgICAgICA9IGdldEV4cGFuZEVsZW1lbnQoZWxlbWVudCk7XG4gICAgICAgICAgICB2YXIgc2hyaW5rICAgICAgICAgID0gZ2V0U2hyaW5rRWxlbWVudChlbGVtZW50KTtcbiAgICAgICAgICAgIHZhciBleHBhbmRXaWR0aCAgICAgPSBnZXRFeHBhbmRXaWR0aCh3aWR0aCk7XG4gICAgICAgICAgICB2YXIgZXhwYW5kSGVpZ2h0ICAgID0gZ2V0RXhwYW5kSGVpZ2h0KGhlaWdodCk7XG4gICAgICAgICAgICB2YXIgc2hyaW5rV2lkdGggICAgID0gZ2V0U2hyaW5rV2lkdGgod2lkdGgpO1xuICAgICAgICAgICAgdmFyIHNocmlua0hlaWdodCAgICA9IGdldFNocmlua0hlaWdodChoZWlnaHQpO1xuICAgICAgICAgICAgZXhwYW5kLnNjcm9sbExlZnQgICA9IGV4cGFuZFdpZHRoO1xuICAgICAgICAgICAgZXhwYW5kLnNjcm9sbFRvcCAgICA9IGV4cGFuZEhlaWdodDtcbiAgICAgICAgICAgIHNocmluay5zY3JvbGxMZWZ0ICAgPSBzaHJpbmtXaWR0aDtcbiAgICAgICAgICAgIHNocmluay5zY3JvbGxUb3AgICAgPSBzaHJpbmtIZWlnaHQ7XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBpbmplY3RDb250YWluZXJFbGVtZW50KCkge1xuICAgICAgICAgICAgdmFyIGNvbnRhaW5lciA9IGdldFN0YXRlKGVsZW1lbnQpLmNvbnRhaW5lcjtcblxuICAgICAgICAgICAgaWYgKCFjb250YWluZXIpIHtcbiAgICAgICAgICAgICAgICBjb250YWluZXIgICAgICAgICAgICAgICAgICAgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgICAgICAgICAgICAgIGNvbnRhaW5lci5jbGFzc05hbWUgICAgICAgICA9IGRldGVjdGlvbkNvbnRhaW5lckNsYXNzO1xuICAgICAgICAgICAgICAgIGNvbnRhaW5lci5zdHlsZS5jc3NUZXh0ICAgICA9IGJ1aWxkQ3NzVGV4dFN0cmluZyhbXCJ2aXNpYmlsaXR5OiBoaWRkZW5cIiwgXCJkaXNwbGF5OiBpbmxpbmVcIiwgXCJ3aWR0aDogMHB4XCIsIFwiaGVpZ2h0OiAwcHhcIiwgXCJ6LWluZGV4OiAtMVwiLCBcIm92ZXJmbG93OiBoaWRkZW5cIiwgXCJtYXJnaW46IDBcIiwgXCJwYWRkaW5nOiAwXCJdKTtcbiAgICAgICAgICAgICAgICBnZXRTdGF0ZShlbGVtZW50KS5jb250YWluZXIgPSBjb250YWluZXI7XG4gICAgICAgICAgICAgICAgYWRkQW5pbWF0aW9uQ2xhc3MoY29udGFpbmVyKTtcbiAgICAgICAgICAgICAgICBlbGVtZW50LmFwcGVuZENoaWxkKGNvbnRhaW5lcik7XG5cbiAgICAgICAgICAgICAgICB2YXIgb25BbmltYXRpb25TdGFydCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgZ2V0U3RhdGUoZWxlbWVudCkub25SZW5kZXJlZCAmJiBnZXRTdGF0ZShlbGVtZW50KS5vblJlbmRlcmVkKCk7XG4gICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgIGFkZEV2ZW50KGNvbnRhaW5lciwgXCJhbmltYXRpb25zdGFydFwiLCBvbkFuaW1hdGlvblN0YXJ0KTtcblxuICAgICAgICAgICAgICAgIC8vIFN0b3JlIHRoZSBldmVudCBoYW5kbGVyIGhlcmUgc28gdGhhdCB0aGV5IG1heSBiZSByZW1vdmVkIHdoZW4gdW5pbnN0YWxsIGlzIGNhbGxlZC5cbiAgICAgICAgICAgICAgICAvLyBTZWUgdW5pbnN0YWxsIGZ1bmN0aW9uIGZvciBhbiBleHBsYW5hdGlvbiB3aHkgaXQgaXMgbmVlZGVkLlxuICAgICAgICAgICAgICAgIGdldFN0YXRlKGVsZW1lbnQpLm9uQW5pbWF0aW9uU3RhcnQgPSBvbkFuaW1hdGlvblN0YXJ0O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gY29udGFpbmVyO1xuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gaW5qZWN0U2Nyb2xsRWxlbWVudHMoKSB7XG4gICAgICAgICAgICBmdW5jdGlvbiBhbHRlclBvc2l0aW9uU3R5bGVzKCkge1xuICAgICAgICAgICAgICAgIHZhciBzdHlsZSA9IGdldFN0YXRlKGVsZW1lbnQpLnN0eWxlO1xuXG4gICAgICAgICAgICAgICAgaWYoc3R5bGUucG9zaXRpb24gPT09IFwic3RhdGljXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgZWxlbWVudC5zdHlsZS5zZXRQcm9wZXJ0eShcInBvc2l0aW9uXCIsIFwicmVsYXRpdmVcIixvcHRpb25zLmltcG9ydGFudCA/IFwiaW1wb3J0YW50XCIgOiBcIlwiKTtcblxuICAgICAgICAgICAgICAgICAgICB2YXIgcmVtb3ZlUmVsYXRpdmVTdHlsZXMgPSBmdW5jdGlvbihyZXBvcnRlciwgZWxlbWVudCwgc3R5bGUsIHByb3BlcnR5KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbiBnZXROdW1lcmljYWxWYWx1ZSh2YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZS5yZXBsYWNlKC9bXi1cXGRcXC5dL2csIFwiXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgdmFsdWUgPSBzdHlsZVtwcm9wZXJ0eV07XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmKHZhbHVlICE9PSBcImF1dG9cIiAmJiBnZXROdW1lcmljYWxWYWx1ZSh2YWx1ZSkgIT09IFwiMFwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVwb3J0ZXIud2FybihcIkFuIGVsZW1lbnQgdGhhdCBpcyBwb3NpdGlvbmVkIHN0YXRpYyBoYXMgc3R5bGUuXCIgKyBwcm9wZXJ0eSArIFwiPVwiICsgdmFsdWUgKyBcIiB3aGljaCBpcyBpZ25vcmVkIGR1ZSB0byB0aGUgc3RhdGljIHBvc2l0aW9uaW5nLiBUaGUgZWxlbWVudCB3aWxsIG5lZWQgdG8gYmUgcG9zaXRpb25lZCByZWxhdGl2ZSwgc28gdGhlIHN0eWxlLlwiICsgcHJvcGVydHkgKyBcIiB3aWxsIGJlIHNldCB0byAwLiBFbGVtZW50OiBcIiwgZWxlbWVudCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxlbWVudC5zdHlsZVtwcm9wZXJ0eV0gPSAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgICAgIC8vQ2hlY2sgc28gdGhhdCB0aGVyZSBhcmUgbm8gYWNjaWRlbnRhbCBzdHlsZXMgdGhhdCB3aWxsIG1ha2UgdGhlIGVsZW1lbnQgc3R5bGVkIGRpZmZlcmVudGx5IG5vdyB0aGF0IGlzIGlzIHJlbGF0aXZlLlxuICAgICAgICAgICAgICAgICAgICAvL0lmIHRoZXJlIGFyZSBhbnksIHNldCB0aGVtIHRvIDAgKHRoaXMgc2hvdWxkIGJlIG9rYXkgd2l0aCB0aGUgdXNlciBzaW5jZSB0aGUgc3R5bGUgcHJvcGVydGllcyBkaWQgbm90aGluZyBiZWZvcmUgW3NpbmNlIHRoZSBlbGVtZW50IHdhcyBwb3NpdGlvbmVkIHN0YXRpY10gYW55d2F5KS5cbiAgICAgICAgICAgICAgICAgICAgcmVtb3ZlUmVsYXRpdmVTdHlsZXMocmVwb3J0ZXIsIGVsZW1lbnQsIHN0eWxlLCBcInRvcFwiKTtcbiAgICAgICAgICAgICAgICAgICAgcmVtb3ZlUmVsYXRpdmVTdHlsZXMocmVwb3J0ZXIsIGVsZW1lbnQsIHN0eWxlLCBcInJpZ2h0XCIpO1xuICAgICAgICAgICAgICAgICAgICByZW1vdmVSZWxhdGl2ZVN0eWxlcyhyZXBvcnRlciwgZWxlbWVudCwgc3R5bGUsIFwiYm90dG9tXCIpO1xuICAgICAgICAgICAgICAgICAgICByZW1vdmVSZWxhdGl2ZVN0eWxlcyhyZXBvcnRlciwgZWxlbWVudCwgc3R5bGUsIFwibGVmdFwiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGZ1bmN0aW9uIGdldExlZnRUb3BCb3R0b21SaWdodENzc1RleHQobGVmdCwgdG9wLCBib3R0b20sIHJpZ2h0KSB7XG4gICAgICAgICAgICAgICAgbGVmdCA9ICghbGVmdCA/IFwiMFwiIDogKGxlZnQgKyBcInB4XCIpKTtcbiAgICAgICAgICAgICAgICB0b3AgPSAoIXRvcCA/IFwiMFwiIDogKHRvcCArIFwicHhcIikpO1xuICAgICAgICAgICAgICAgIGJvdHRvbSA9ICghYm90dG9tID8gXCIwXCIgOiAoYm90dG9tICsgXCJweFwiKSk7XG4gICAgICAgICAgICAgICAgcmlnaHQgPSAoIXJpZ2h0ID8gXCIwXCIgOiAocmlnaHQgKyBcInB4XCIpKTtcblxuICAgICAgICAgICAgICAgIHJldHVybiBbXCJsZWZ0OiBcIiArIGxlZnQsIFwidG9wOiBcIiArIHRvcCwgXCJyaWdodDogXCIgKyByaWdodCwgXCJib3R0b206IFwiICsgYm90dG9tXTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZGVidWcoXCJJbmplY3RpbmcgZWxlbWVudHNcIik7XG5cbiAgICAgICAgICAgIGlmICghZ2V0U3RhdGUoZWxlbWVudCkpIHtcbiAgICAgICAgICAgICAgICBkZWJ1ZyhcIkFib3J0aW5nIGJlY2F1c2UgZWxlbWVudCBoYXMgYmVlbiB1bmluc3RhbGxlZFwiKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGFsdGVyUG9zaXRpb25TdHlsZXMoKTtcblxuICAgICAgICAgICAgdmFyIHJvb3RDb250YWluZXIgPSBnZXRTdGF0ZShlbGVtZW50KS5jb250YWluZXI7XG5cbiAgICAgICAgICAgIGlmICghcm9vdENvbnRhaW5lcikge1xuICAgICAgICAgICAgICAgIHJvb3RDb250YWluZXIgPSBpbmplY3RDb250YWluZXJFbGVtZW50KCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIER1ZSB0byB0aGlzIFdlYktpdCBidWcgaHR0cHM6Ly9idWdzLndlYmtpdC5vcmcvc2hvd19idWcuY2dpP2lkPTgwODA4IChjdXJyZW50bHkgZml4ZWQgaW4gQmxpbmssIGJ1dCBzdGlsbCBwcmVzZW50IGluIFdlYktpdCBicm93c2VycyBzdWNoIGFzIFNhZmFyaSksXG4gICAgICAgICAgICAvLyB3ZSBuZWVkIHRvIGluamVjdCB0d28gY29udGFpbmVycywgb25lIHRoYXQgaXMgd2lkdGgvaGVpZ2h0IDEwMCUgYW5kIGFub3RoZXIgdGhhdCBpcyBsZWZ0L3RvcCAtMXB4IHNvIHRoYXQgdGhlIGZpbmFsIGNvbnRhaW5lciBhbHdheXMgaXMgMXgxIHBpeGVscyBiaWdnZXIgdGhhblxuICAgICAgICAgICAgLy8gdGhlIHRhcmdldGVkIGVsZW1lbnQuXG4gICAgICAgICAgICAvLyBXaGVuIHRoZSBidWcgaXMgcmVzb2x2ZWQsIFwiY29udGFpbmVyQ29udGFpbmVyXCIgbWF5IGJlIHJlbW92ZWQuXG5cbiAgICAgICAgICAgIC8vIFRoZSBvdXRlciBjb250YWluZXIgY2FuIG9jY2FzaW9uYWxseSBiZSBsZXNzIHdpZGUgdGhhbiB0aGUgdGFyZ2V0ZWQgd2hlbiBpbnNpZGUgaW5saW5lIGVsZW1lbnRzIGVsZW1lbnQgaW4gV2ViS2l0IChzZWUgaHR0cHM6Ly9idWdzLndlYmtpdC5vcmcvc2hvd19idWcuY2dpP2lkPTE1Mjk4MCkuXG4gICAgICAgICAgICAvLyBUaGlzIHNob3VsZCBiZSBubyBwcm9ibGVtIHNpbmNlIHRoZSBpbm5lciBjb250YWluZXIgZWl0aGVyIHdheSBtYWtlcyBzdXJlIHRoZSBpbmplY3RlZCBzY3JvbGwgZWxlbWVudHMgYXJlIGF0IGxlYXN0IDF4MSBweC5cblxuICAgICAgICAgICAgdmFyIHNjcm9sbGJhcldpZHRoICAgICAgICAgID0gc2Nyb2xsYmFyU2l6ZXMud2lkdGg7XG4gICAgICAgICAgICB2YXIgc2Nyb2xsYmFySGVpZ2h0ICAgICAgICAgPSBzY3JvbGxiYXJTaXplcy5oZWlnaHQ7XG4gICAgICAgICAgICB2YXIgY29udGFpbmVyQ29udGFpbmVyU3R5bGUgPSBidWlsZENzc1RleHRTdHJpbmcoW1wicG9zaXRpb246IGFic29sdXRlXCIsIFwiZmxleDogbm9uZVwiLCBcIm92ZXJmbG93OiBoaWRkZW5cIiwgXCJ6LWluZGV4OiAtMVwiLCBcInZpc2liaWxpdHk6IGhpZGRlblwiLCBcIndpZHRoOiAxMDAlXCIsIFwiaGVpZ2h0OiAxMDAlXCIsIFwibGVmdDogMHB4XCIsIFwidG9wOiAwcHhcIl0pO1xuICAgICAgICAgICAgdmFyIGNvbnRhaW5lclN0eWxlICAgICAgICAgID0gYnVpbGRDc3NUZXh0U3RyaW5nKFtcInBvc2l0aW9uOiBhYnNvbHV0ZVwiLCBcImZsZXg6IG5vbmVcIiwgXCJvdmVyZmxvdzogaGlkZGVuXCIsIFwiei1pbmRleDogLTFcIiwgXCJ2aXNpYmlsaXR5OiBoaWRkZW5cIl0uY29uY2F0KGdldExlZnRUb3BCb3R0b21SaWdodENzc1RleHQoLSgxICsgc2Nyb2xsYmFyV2lkdGgpLCAtKDEgKyBzY3JvbGxiYXJIZWlnaHQpLCAtc2Nyb2xsYmFySGVpZ2h0LCAtc2Nyb2xsYmFyV2lkdGgpKSk7XG4gICAgICAgICAgICB2YXIgZXhwYW5kU3R5bGUgICAgICAgICAgICAgPSBidWlsZENzc1RleHRTdHJpbmcoW1wicG9zaXRpb246IGFic29sdXRlXCIsIFwiZmxleDogbm9uZVwiLCBcIm92ZXJmbG93OiBzY3JvbGxcIiwgXCJ6LWluZGV4OiAtMVwiLCBcInZpc2liaWxpdHk6IGhpZGRlblwiLCBcIndpZHRoOiAxMDAlXCIsIFwiaGVpZ2h0OiAxMDAlXCJdKTtcbiAgICAgICAgICAgIHZhciBzaHJpbmtTdHlsZSAgICAgICAgICAgICA9IGJ1aWxkQ3NzVGV4dFN0cmluZyhbXCJwb3NpdGlvbjogYWJzb2x1dGVcIiwgXCJmbGV4OiBub25lXCIsIFwib3ZlcmZsb3c6IHNjcm9sbFwiLCBcInotaW5kZXg6IC0xXCIsIFwidmlzaWJpbGl0eTogaGlkZGVuXCIsIFwid2lkdGg6IDEwMCVcIiwgXCJoZWlnaHQ6IDEwMCVcIl0pO1xuICAgICAgICAgICAgdmFyIGV4cGFuZENoaWxkU3R5bGUgICAgICAgID0gYnVpbGRDc3NUZXh0U3RyaW5nKFtcInBvc2l0aW9uOiBhYnNvbHV0ZVwiLCBcImxlZnQ6IDBcIiwgXCJ0b3A6IDBcIl0pO1xuICAgICAgICAgICAgdmFyIHNocmlua0NoaWxkU3R5bGUgICAgICAgID0gYnVpbGRDc3NUZXh0U3RyaW5nKFtcInBvc2l0aW9uOiBhYnNvbHV0ZVwiLCBcIndpZHRoOiAyMDAlXCIsIFwiaGVpZ2h0OiAyMDAlXCJdKTtcblxuICAgICAgICAgICAgdmFyIGNvbnRhaW5lckNvbnRhaW5lciAgICAgID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICAgICAgICAgIHZhciBjb250YWluZXIgICAgICAgICAgICAgICA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgICAgICAgICB2YXIgZXhwYW5kICAgICAgICAgICAgICAgICAgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgICAgICAgICAgdmFyIGV4cGFuZENoaWxkICAgICAgICAgICAgID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICAgICAgICAgIHZhciBzaHJpbmsgICAgICAgICAgICAgICAgICA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgICAgICAgICB2YXIgc2hyaW5rQ2hpbGQgICAgICAgICAgICAgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuXG4gICAgICAgICAgICAvLyBTb21lIGJyb3dzZXJzIGNob2tlIG9uIHRoZSByZXNpemUgc3lzdGVtIGJlaW5nIHJ0bCwgc28gZm9yY2UgaXQgdG8gbHRyLiBodHRwczovL2dpdGh1Yi5jb20vd25yL2VsZW1lbnQtcmVzaXplLWRldGVjdG9yL2lzc3Vlcy81NlxuICAgICAgICAgICAgLy8gSG93ZXZlciwgZGlyIHNob3VsZCBub3QgYmUgc2V0IG9uIHRoZSB0b3AgbGV2ZWwgY29udGFpbmVyIGFzIGl0IGFsdGVycyB0aGUgZGltZW5zaW9ucyBvZiB0aGUgdGFyZ2V0IGVsZW1lbnQgaW4gc29tZSBicm93c2Vycy5cbiAgICAgICAgICAgIGNvbnRhaW5lckNvbnRhaW5lci5kaXIgICAgICAgICAgICAgID0gXCJsdHJcIjtcblxuICAgICAgICAgICAgY29udGFpbmVyQ29udGFpbmVyLnN0eWxlLmNzc1RleHQgICAgPSBjb250YWluZXJDb250YWluZXJTdHlsZTtcbiAgICAgICAgICAgIGNvbnRhaW5lckNvbnRhaW5lci5jbGFzc05hbWUgICAgICAgID0gZGV0ZWN0aW9uQ29udGFpbmVyQ2xhc3M7XG4gICAgICAgICAgICBjb250YWluZXIuY2xhc3NOYW1lICAgICAgICAgICAgICAgICA9IGRldGVjdGlvbkNvbnRhaW5lckNsYXNzO1xuICAgICAgICAgICAgY29udGFpbmVyLnN0eWxlLmNzc1RleHQgICAgICAgICAgICAgPSBjb250YWluZXJTdHlsZTtcbiAgICAgICAgICAgIGV4cGFuZC5zdHlsZS5jc3NUZXh0ICAgICAgICAgICAgICAgID0gZXhwYW5kU3R5bGU7XG4gICAgICAgICAgICBleHBhbmRDaGlsZC5zdHlsZS5jc3NUZXh0ICAgICAgICAgICA9IGV4cGFuZENoaWxkU3R5bGU7XG4gICAgICAgICAgICBzaHJpbmsuc3R5bGUuY3NzVGV4dCAgICAgICAgICAgICAgICA9IHNocmlua1N0eWxlO1xuICAgICAgICAgICAgc2hyaW5rQ2hpbGQuc3R5bGUuY3NzVGV4dCAgICAgICAgICAgPSBzaHJpbmtDaGlsZFN0eWxlO1xuXG4gICAgICAgICAgICBleHBhbmQuYXBwZW5kQ2hpbGQoZXhwYW5kQ2hpbGQpO1xuICAgICAgICAgICAgc2hyaW5rLmFwcGVuZENoaWxkKHNocmlua0NoaWxkKTtcbiAgICAgICAgICAgIGNvbnRhaW5lci5hcHBlbmRDaGlsZChleHBhbmQpO1xuICAgICAgICAgICAgY29udGFpbmVyLmFwcGVuZENoaWxkKHNocmluayk7XG4gICAgICAgICAgICBjb250YWluZXJDb250YWluZXIuYXBwZW5kQ2hpbGQoY29udGFpbmVyKTtcbiAgICAgICAgICAgIHJvb3RDb250YWluZXIuYXBwZW5kQ2hpbGQoY29udGFpbmVyQ29udGFpbmVyKTtcblxuICAgICAgICAgICAgZnVuY3Rpb24gb25FeHBhbmRTY3JvbGwoKSB7XG4gICAgICAgICAgICAgICAgZ2V0U3RhdGUoZWxlbWVudCkub25FeHBhbmQgJiYgZ2V0U3RhdGUoZWxlbWVudCkub25FeHBhbmQoKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZnVuY3Rpb24gb25TaHJpbmtTY3JvbGwoKSB7XG4gICAgICAgICAgICAgICAgZ2V0U3RhdGUoZWxlbWVudCkub25TaHJpbmsgJiYgZ2V0U3RhdGUoZWxlbWVudCkub25TaHJpbmsoKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgYWRkRXZlbnQoZXhwYW5kLCBcInNjcm9sbFwiLCBvbkV4cGFuZFNjcm9sbCk7XG4gICAgICAgICAgICBhZGRFdmVudChzaHJpbmssIFwic2Nyb2xsXCIsIG9uU2hyaW5rU2Nyb2xsKTtcblxuICAgICAgICAgICAgLy8gU3RvcmUgdGhlIGV2ZW50IGhhbmRsZXJzIGhlcmUgc28gdGhhdCB0aGV5IG1heSBiZSByZW1vdmVkIHdoZW4gdW5pbnN0YWxsIGlzIGNhbGxlZC5cbiAgICAgICAgICAgIC8vIFNlZSB1bmluc3RhbGwgZnVuY3Rpb24gZm9yIGFuIGV4cGxhbmF0aW9uIHdoeSBpdCBpcyBuZWVkZWQuXG4gICAgICAgICAgICBnZXRTdGF0ZShlbGVtZW50KS5vbkV4cGFuZFNjcm9sbCA9IG9uRXhwYW5kU2Nyb2xsO1xuICAgICAgICAgICAgZ2V0U3RhdGUoZWxlbWVudCkub25TaHJpbmtTY3JvbGwgPSBvblNocmlua1Njcm9sbDtcbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIHJlZ2lzdGVyTGlzdGVuZXJzQW5kUG9zaXRpb25FbGVtZW50cygpIHtcbiAgICAgICAgICAgIGZ1bmN0aW9uIHVwZGF0ZUNoaWxkU2l6ZXMoZWxlbWVudCwgd2lkdGgsIGhlaWdodCkge1xuICAgICAgICAgICAgICAgIHZhciBleHBhbmRDaGlsZCAgICAgICAgICAgICA9IGdldEV4cGFuZENoaWxkRWxlbWVudChlbGVtZW50KTtcbiAgICAgICAgICAgICAgICB2YXIgZXhwYW5kV2lkdGggICAgICAgICAgICAgPSBnZXRFeHBhbmRXaWR0aCh3aWR0aCk7XG4gICAgICAgICAgICAgICAgdmFyIGV4cGFuZEhlaWdodCAgICAgICAgICAgID0gZ2V0RXhwYW5kSGVpZ2h0KGhlaWdodCk7XG4gICAgICAgICAgICAgICAgZXhwYW5kQ2hpbGQuc3R5bGUuc2V0UHJvcGVydHkoXCJ3aWR0aFwiLCBleHBhbmRXaWR0aCArIFwicHhcIiwgb3B0aW9ucy5pbXBvcnRhbnQgPyBcImltcG9ydGFudFwiIDogXCJcIik7XG4gICAgICAgICAgICAgICAgZXhwYW5kQ2hpbGQuc3R5bGUuc2V0UHJvcGVydHkoXCJoZWlnaHRcIiwgZXhwYW5kSGVpZ2h0ICsgXCJweFwiLCBvcHRpb25zLmltcG9ydGFudCA/IFwiaW1wb3J0YW50XCIgOiBcIlwiKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZnVuY3Rpb24gdXBkYXRlRGV0ZWN0b3JFbGVtZW50cyhkb25lKSB7XG4gICAgICAgICAgICAgICAgdmFyIHdpZHRoICAgICAgICAgICA9IGVsZW1lbnQub2Zmc2V0V2lkdGg7XG4gICAgICAgICAgICAgICAgdmFyIGhlaWdodCAgICAgICAgICA9IGVsZW1lbnQub2Zmc2V0SGVpZ2h0O1xuXG4gICAgICAgICAgICAgICAgLy8gQ2hlY2sgd2hldGhlciB0aGUgc2l6ZSBoYXMgYWN0dWFsbHkgY2hhbmdlZCBzaW5jZSBsYXN0IHRpbWUgdGhlIGFsZ29yaXRobSByYW4uIElmIG5vdCwgc29tZSBzdGVwcyBtYXkgYmUgc2tpcHBlZC5cbiAgICAgICAgICAgICAgICB2YXIgc2l6ZUNoYW5nZWQgPSB3aWR0aCAhPT0gZ2V0U3RhdGUoZWxlbWVudCkubGFzdFdpZHRoIHx8IGhlaWdodCAhPT0gZ2V0U3RhdGUoZWxlbWVudCkubGFzdEhlaWdodDtcblxuICAgICAgICAgICAgICAgIGRlYnVnKFwiU3RvcmluZyBjdXJyZW50IHNpemVcIiwgd2lkdGgsIGhlaWdodCk7XG5cbiAgICAgICAgICAgICAgICAvLyBTdG9yZSB0aGUgc2l6ZSBvZiB0aGUgZWxlbWVudCBzeW5jIGhlcmUsIHNvIHRoYXQgbXVsdGlwbGUgc2Nyb2xsIGV2ZW50cyBtYXkgYmUgaWdub3JlZCBpbiB0aGUgZXZlbnQgbGlzdGVuZXJzLlxuICAgICAgICAgICAgICAgIC8vIE90aGVyd2lzZSB0aGUgaWYtY2hlY2sgaW4gaGFuZGxlU2Nyb2xsIGlzIHVzZWxlc3MuXG4gICAgICAgICAgICAgICAgc3RvcmVDdXJyZW50U2l6ZShlbGVtZW50LCB3aWR0aCwgaGVpZ2h0KTtcblxuICAgICAgICAgICAgICAgIC8vIFNpbmNlIHdlIGRlbGF5IHRoZSBwcm9jZXNzaW5nIG9mIHRoZSBiYXRjaCwgdGhlcmUgaXMgYSByaXNrIHRoYXQgdW5pbnN0YWxsIGhhcyBiZWVuIGNhbGxlZCBiZWZvcmUgdGhlIGJhdGNoIGdldHMgdG8gZXhlY3V0ZS5cbiAgICAgICAgICAgICAgICAvLyBTaW5jZSB0aGVyZSBpcyBubyB3YXkgdG8gY2FuY2VsIHRoZSBmbiBleGVjdXRpb25zLCB3ZSBuZWVkIHRvIGFkZCBhbiB1bmluc3RhbGwgZ3VhcmQgdG8gYWxsIGZucyBvZiB0aGUgYmF0Y2guXG5cbiAgICAgICAgICAgICAgICBiYXRjaFByb2Nlc3Nvci5hZGQoMCwgZnVuY3Rpb24gcGVyZm9ybVVwZGF0ZUNoaWxkU2l6ZXMoKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghc2l6ZUNoYW5nZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGlmICghZ2V0U3RhdGUoZWxlbWVudCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlYnVnKFwiQWJvcnRpbmcgYmVjYXVzZSBlbGVtZW50IGhhcyBiZWVuIHVuaW5zdGFsbGVkXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKCFhcmVFbGVtZW50c0luamVjdGVkKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlYnVnKFwiQWJvcnRpbmcgYmVjYXVzZSBlbGVtZW50IGNvbnRhaW5lciBoYXMgbm90IGJlZW4gaW5pdGlhbGl6ZWRcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBpZiAob3B0aW9ucy5kZWJ1Zykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHcgPSBlbGVtZW50Lm9mZnNldFdpZHRoO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGggPSBlbGVtZW50Lm9mZnNldEhlaWdodDtcblxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHcgIT09IHdpZHRoIHx8IGggIT09IGhlaWdodCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlcG9ydGVyLndhcm4oaWRIYW5kbGVyLmdldChlbGVtZW50KSwgXCJTY3JvbGw6IFNpemUgY2hhbmdlZCBiZWZvcmUgdXBkYXRpbmcgZGV0ZWN0b3IgZWxlbWVudHMuXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgdXBkYXRlQ2hpbGRTaXplcyhlbGVtZW50LCB3aWR0aCwgaGVpZ2h0KTtcbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgIGJhdGNoUHJvY2Vzc29yLmFkZCgxLCBmdW5jdGlvbiB1cGRhdGVTY3JvbGxiYXJzKCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBUaGlzIGZ1bmN0aW9uIG5lZWRzIHRvIGJlIGludm9rZWQgZXZlbnQgdGhvdWdoIHRoZSBzaXplIGlzIHVuY2hhbmdlZC4gVGhlIGVsZW1lbnQgY291bGQgaGF2ZSBiZWVuIHJlc2l6ZWQgdmVyeSBxdWlja2x5IGFuZCB0aGVuXG4gICAgICAgICAgICAgICAgICAgIC8vIGJlZW4gcmVzdG9yZWQgdG8gdGhlIG9yaWdpbmFsIHNpemUsIHdoaWNoIHdpbGwgaGF2ZSBjaGFuZ2VkIHRoZSBzY3JvbGxiYXIgcG9zaXRpb25zLlxuXG4gICAgICAgICAgICAgICAgICAgIGlmICghZ2V0U3RhdGUoZWxlbWVudCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlYnVnKFwiQWJvcnRpbmcgYmVjYXVzZSBlbGVtZW50IGhhcyBiZWVuIHVuaW5zdGFsbGVkXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKCFhcmVFbGVtZW50c0luamVjdGVkKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlYnVnKFwiQWJvcnRpbmcgYmVjYXVzZSBlbGVtZW50IGNvbnRhaW5lciBoYXMgbm90IGJlZW4gaW5pdGlhbGl6ZWRcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBwb3NpdGlvblNjcm9sbGJhcnMoZWxlbWVudCwgd2lkdGgsIGhlaWdodCk7XG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICBpZiAoc2l6ZUNoYW5nZWQgJiYgZG9uZSkge1xuICAgICAgICAgICAgICAgICAgICBiYXRjaFByb2Nlc3Nvci5hZGQoMiwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFnZXRTdGF0ZShlbGVtZW50KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlYnVnKFwiQWJvcnRpbmcgYmVjYXVzZSBlbGVtZW50IGhhcyBiZWVuIHVuaW5zdGFsbGVkXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFhcmVFbGVtZW50c0luamVjdGVkKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgZGVidWcoXCJBYm9ydGluZyBiZWNhdXNlIGVsZW1lbnQgY29udGFpbmVyIGhhcyBub3QgYmVlbiBpbml0aWFsaXplZFwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICBkb25lKCk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZnVuY3Rpb24gYXJlRWxlbWVudHNJbmplY3RlZCgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gISFnZXRTdGF0ZShlbGVtZW50KS5jb250YWluZXI7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGZ1bmN0aW9uIG5vdGlmeUxpc3RlbmVyc0lmTmVlZGVkKCkge1xuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIGlzRmlyc3ROb3RpZnkoKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBnZXRTdGF0ZShlbGVtZW50KS5sYXN0Tm90aWZpZWRXaWR0aCA9PT0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGRlYnVnKFwibm90aWZ5TGlzdGVuZXJzSWZOZWVkZWQgaW52b2tlZFwiKTtcblxuICAgICAgICAgICAgICAgIHZhciBzdGF0ZSA9IGdldFN0YXRlKGVsZW1lbnQpO1xuXG4gICAgICAgICAgICAgICAgLy8gRG9uJ3Qgbm90aWZ5IGlmIHRoZSBjdXJyZW50IHNpemUgaXMgdGhlIHN0YXJ0IHNpemUsIGFuZCB0aGlzIGlzIHRoZSBmaXJzdCBub3RpZmljYXRpb24uXG4gICAgICAgICAgICAgICAgaWYgKGlzRmlyc3ROb3RpZnkoKSAmJiBzdGF0ZS5sYXN0V2lkdGggPT09IHN0YXRlLnN0YXJ0U2l6ZS53aWR0aCAmJiBzdGF0ZS5sYXN0SGVpZ2h0ID09PSBzdGF0ZS5zdGFydFNpemUuaGVpZ2h0KSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBkZWJ1ZyhcIk5vdCBub3RpZnlpbmc6IFNpemUgaXMgdGhlIHNhbWUgYXMgdGhlIHN0YXJ0IHNpemUsIGFuZCB0aGVyZSBoYXMgYmVlbiBubyBub3RpZmljYXRpb24geWV0LlwiKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBEb24ndCBub3RpZnkgaWYgdGhlIHNpemUgYWxyZWFkeSBoYXMgYmVlbiBub3RpZmllZC5cbiAgICAgICAgICAgICAgICBpZiAoc3RhdGUubGFzdFdpZHRoID09PSBzdGF0ZS5sYXN0Tm90aWZpZWRXaWR0aCAmJiBzdGF0ZS5sYXN0SGVpZ2h0ID09PSBzdGF0ZS5sYXN0Tm90aWZpZWRIZWlnaHQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGRlYnVnKFwiTm90IG5vdGlmeWluZzogU2l6ZSBhbHJlYWR5IG5vdGlmaWVkXCIpO1xuICAgICAgICAgICAgICAgIH1cblxuXG4gICAgICAgICAgICAgICAgZGVidWcoXCJDdXJyZW50IHNpemUgbm90IG5vdGlmaWVkLCBub3RpZnlpbmcuLi5cIik7XG4gICAgICAgICAgICAgICAgc3RhdGUubGFzdE5vdGlmaWVkV2lkdGggPSBzdGF0ZS5sYXN0V2lkdGg7XG4gICAgICAgICAgICAgICAgc3RhdGUubGFzdE5vdGlmaWVkSGVpZ2h0ID0gc3RhdGUubGFzdEhlaWdodDtcbiAgICAgICAgICAgICAgICBmb3JFYWNoKGdldFN0YXRlKGVsZW1lbnQpLmxpc3RlbmVycywgZnVuY3Rpb24gKGxpc3RlbmVyKSB7XG4gICAgICAgICAgICAgICAgICAgIGxpc3RlbmVyKGVsZW1lbnQpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBmdW5jdGlvbiBoYW5kbGVSZW5kZXIoKSB7XG4gICAgICAgICAgICAgICAgZGVidWcoXCJzdGFydGFuaW1hdGlvbiB0cmlnZ2VyZWQuXCIpO1xuXG4gICAgICAgICAgICAgICAgaWYgKGlzVW5yZW5kZXJlZChlbGVtZW50KSkge1xuICAgICAgICAgICAgICAgICAgICBkZWJ1ZyhcIklnbm9yaW5nIHNpbmNlIGVsZW1lbnQgaXMgc3RpbGwgdW5yZW5kZXJlZC4uLlwiKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGRlYnVnKFwiRWxlbWVudCByZW5kZXJlZC5cIik7XG4gICAgICAgICAgICAgICAgdmFyIGV4cGFuZCA9IGdldEV4cGFuZEVsZW1lbnQoZWxlbWVudCk7XG4gICAgICAgICAgICAgICAgdmFyIHNocmluayA9IGdldFNocmlua0VsZW1lbnQoZWxlbWVudCk7XG4gICAgICAgICAgICAgICAgaWYgKGV4cGFuZC5zY3JvbGxMZWZ0ID09PSAwIHx8IGV4cGFuZC5zY3JvbGxUb3AgPT09IDAgfHwgc2hyaW5rLnNjcm9sbExlZnQgPT09IDAgfHwgc2hyaW5rLnNjcm9sbFRvcCA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICBkZWJ1ZyhcIlNjcm9sbGJhcnMgb3V0IG9mIHN5bmMuIFVwZGF0aW5nIGRldGVjdG9yIGVsZW1lbnRzLi4uXCIpO1xuICAgICAgICAgICAgICAgICAgICB1cGRhdGVEZXRlY3RvckVsZW1lbnRzKG5vdGlmeUxpc3RlbmVyc0lmTmVlZGVkKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGZ1bmN0aW9uIGhhbmRsZVNjcm9sbCgpIHtcbiAgICAgICAgICAgICAgICBkZWJ1ZyhcIlNjcm9sbCBkZXRlY3RlZC5cIik7XG5cbiAgICAgICAgICAgICAgICBpZiAoaXNVbnJlbmRlcmVkKGVsZW1lbnQpKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIEVsZW1lbnQgaXMgc3RpbGwgdW5yZW5kZXJlZC4gU2tpcCB0aGlzIHNjcm9sbCBldmVudC5cbiAgICAgICAgICAgICAgICAgICAgZGVidWcoXCJTY3JvbGwgZXZlbnQgZmlyZWQgd2hpbGUgdW5yZW5kZXJlZC4gSWdub3JpbmcuLi5cIik7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB1cGRhdGVEZXRlY3RvckVsZW1lbnRzKG5vdGlmeUxpc3RlbmVyc0lmTmVlZGVkKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZGVidWcoXCJyZWdpc3Rlckxpc3RlbmVyc0FuZFBvc2l0aW9uRWxlbWVudHMgaW52b2tlZC5cIik7XG5cbiAgICAgICAgICAgIGlmICghZ2V0U3RhdGUoZWxlbWVudCkpIHtcbiAgICAgICAgICAgICAgICBkZWJ1ZyhcIkFib3J0aW5nIGJlY2F1c2UgZWxlbWVudCBoYXMgYmVlbiB1bmluc3RhbGxlZFwiKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGdldFN0YXRlKGVsZW1lbnQpLm9uUmVuZGVyZWQgPSBoYW5kbGVSZW5kZXI7XG4gICAgICAgICAgICBnZXRTdGF0ZShlbGVtZW50KS5vbkV4cGFuZCA9IGhhbmRsZVNjcm9sbDtcbiAgICAgICAgICAgIGdldFN0YXRlKGVsZW1lbnQpLm9uU2hyaW5rID0gaGFuZGxlU2Nyb2xsO1xuXG4gICAgICAgICAgICB2YXIgc3R5bGUgPSBnZXRTdGF0ZShlbGVtZW50KS5zdHlsZTtcbiAgICAgICAgICAgIHVwZGF0ZUNoaWxkU2l6ZXMoZWxlbWVudCwgc3R5bGUud2lkdGgsIHN0eWxlLmhlaWdodCk7XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBmaW5hbGl6ZURvbU11dGF0aW9uKCkge1xuICAgICAgICAgICAgZGVidWcoXCJmaW5hbGl6ZURvbU11dGF0aW9uIGludm9rZWQuXCIpO1xuXG4gICAgICAgICAgICBpZiAoIWdldFN0YXRlKGVsZW1lbnQpKSB7XG4gICAgICAgICAgICAgICAgZGVidWcoXCJBYm9ydGluZyBiZWNhdXNlIGVsZW1lbnQgaGFzIGJlZW4gdW5pbnN0YWxsZWRcIik7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgc3R5bGUgPSBnZXRTdGF0ZShlbGVtZW50KS5zdHlsZTtcbiAgICAgICAgICAgIHN0b3JlQ3VycmVudFNpemUoZWxlbWVudCwgc3R5bGUud2lkdGgsIHN0eWxlLmhlaWdodCk7XG4gICAgICAgICAgICBwb3NpdGlvblNjcm9sbGJhcnMoZWxlbWVudCwgc3R5bGUud2lkdGgsIHN0eWxlLmhlaWdodCk7XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiByZWFkeSgpIHtcbiAgICAgICAgICAgIGNhbGxiYWNrKGVsZW1lbnQpO1xuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gaW5zdGFsbCgpIHtcbiAgICAgICAgICAgIGRlYnVnKFwiSW5zdGFsbGluZy4uLlwiKTtcbiAgICAgICAgICAgIGluaXRMaXN0ZW5lcnMoKTtcbiAgICAgICAgICAgIHN0b3JlU3RhcnRTaXplKCk7XG5cbiAgICAgICAgICAgIGJhdGNoUHJvY2Vzc29yLmFkZCgwLCBzdG9yZVN0eWxlKTtcbiAgICAgICAgICAgIGJhdGNoUHJvY2Vzc29yLmFkZCgxLCBpbmplY3RTY3JvbGxFbGVtZW50cyk7XG4gICAgICAgICAgICBiYXRjaFByb2Nlc3Nvci5hZGQoMiwgcmVnaXN0ZXJMaXN0ZW5lcnNBbmRQb3NpdGlvbkVsZW1lbnRzKTtcbiAgICAgICAgICAgIGJhdGNoUHJvY2Vzc29yLmFkZCgzLCBmaW5hbGl6ZURvbU11dGF0aW9uKTtcbiAgICAgICAgICAgIGJhdGNoUHJvY2Vzc29yLmFkZCg0LCByZWFkeSk7XG4gICAgICAgIH1cblxuICAgICAgICBkZWJ1ZyhcIk1ha2luZyBkZXRlY3RhYmxlLi4uXCIpO1xuXG4gICAgICAgIGlmIChpc0RldGFjaGVkKGVsZW1lbnQpKSB7XG4gICAgICAgICAgICBkZWJ1ZyhcIkVsZW1lbnQgaXMgZGV0YWNoZWRcIik7XG5cbiAgICAgICAgICAgIGluamVjdENvbnRhaW5lckVsZW1lbnQoKTtcblxuICAgICAgICAgICAgZGVidWcoXCJXYWl0aW5nIHVudGlsIGVsZW1lbnQgaXMgYXR0YWNoZWQuLi5cIik7XG5cbiAgICAgICAgICAgIGdldFN0YXRlKGVsZW1lbnQpLm9uUmVuZGVyZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgZGVidWcoXCJFbGVtZW50IGlzIG5vdyBhdHRhY2hlZFwiKTtcbiAgICAgICAgICAgICAgICBpbnN0YWxsKCk7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaW5zdGFsbCgpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gdW5pbnN0YWxsKGVsZW1lbnQpIHtcbiAgICAgICAgdmFyIHN0YXRlID0gZ2V0U3RhdGUoZWxlbWVudCk7XG5cbiAgICAgICAgaWYgKCFzdGF0ZSkge1xuICAgICAgICAgICAgLy8gVW5pbnN0YWxsIGhhcyBiZWVuIGNhbGxlZCBvbiBhIG5vbi1lcmQgZWxlbWVudC5cbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFVuaW5zdGFsbCBtYXkgaGF2ZSBiZWVuIGNhbGxlZCBpbiB0aGUgZm9sbG93aW5nIHNjZW5hcmlvczpcbiAgICAgICAgLy8gKDEpIFJpZ2h0IGJldHdlZW4gdGhlIHN5bmMgY29kZSBhbmQgYXN5bmMgYmF0Y2ggKGhlcmUgc3RhdGUuYnVzeSA9IHRydWUsIGJ1dCBub3RoaW5nIGhhdmUgYmVlbiByZWdpc3RlcmVkIG9yIGluamVjdGVkKS5cbiAgICAgICAgLy8gKDIpIEluIHRoZSByZWFkeSBjYWxsYmFjayBvZiB0aGUgbGFzdCBsZXZlbCBvZiB0aGUgYmF0Y2ggYnkgYW5vdGhlciBlbGVtZW50IChoZXJlLCBzdGF0ZS5idXN5ID0gdHJ1ZSwgYnV0IGFsbCB0aGUgc3R1ZmYgaGFzIGJlZW4gaW5qZWN0ZWQpLlxuICAgICAgICAvLyAoMykgQWZ0ZXIgdGhlIGluc3RhbGxhdGlvbiBwcm9jZXNzIChoZXJlLCBzdGF0ZS5idXN5ID0gZmFsc2UgYW5kIGFsbCB0aGUgc3R1ZmYgaGFzIGJlZW4gaW5qZWN0ZWQpLlxuICAgICAgICAvLyBTbyB0byBiZSBvbiB0aGUgc2FmZSBzaWRlLCBsZXQncyBjaGVjayBmb3IgZWFjaCB0aGluZyBiZWZvcmUgcmVtb3ZpbmcuXG5cbiAgICAgICAgLy8gV2UgbmVlZCB0byByZW1vdmUgdGhlIGV2ZW50IGxpc3RlbmVycywgYmVjYXVzZSBvdGhlcndpc2UgdGhlIGV2ZW50IG1pZ2h0IGZpcmUgb24gYW4gdW5pbnN0YWxsIGVsZW1lbnQgd2hpY2ggcmVzdWx0cyBpbiBhbiBlcnJvciB3aGVuIHRyeWluZyB0byBnZXQgdGhlIHN0YXRlIG9mIHRoZSBlbGVtZW50LlxuICAgICAgICBzdGF0ZS5vbkV4cGFuZFNjcm9sbCAmJiByZW1vdmVFdmVudChnZXRFeHBhbmRFbGVtZW50KGVsZW1lbnQpLCBcInNjcm9sbFwiLCBzdGF0ZS5vbkV4cGFuZFNjcm9sbCk7XG4gICAgICAgIHN0YXRlLm9uU2hyaW5rU2Nyb2xsICYmIHJlbW92ZUV2ZW50KGdldFNocmlua0VsZW1lbnQoZWxlbWVudCksIFwic2Nyb2xsXCIsIHN0YXRlLm9uU2hyaW5rU2Nyb2xsKTtcbiAgICAgICAgc3RhdGUub25BbmltYXRpb25TdGFydCAmJiByZW1vdmVFdmVudChzdGF0ZS5jb250YWluZXIsIFwiYW5pbWF0aW9uc3RhcnRcIiwgc3RhdGUub25BbmltYXRpb25TdGFydCk7XG5cbiAgICAgICAgc3RhdGUuY29udGFpbmVyICYmIGVsZW1lbnQucmVtb3ZlQ2hpbGQoc3RhdGUuY29udGFpbmVyKTtcbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgICBtYWtlRGV0ZWN0YWJsZTogbWFrZURldGVjdGFibGUsXG4gICAgICAgIGFkZExpc3RlbmVyOiBhZGRMaXN0ZW5lcixcbiAgICAgICAgdW5pbnN0YWxsOiB1bmluc3RhbGwsXG4gICAgICAgIGluaXREb2N1bWVudDogaW5pdERvY3VtZW50XG4gICAgfTtcbn07XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiY2E1YVwiOlxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG52YXIgaWQgPSAwO1xudmFyIHB4ID0gTWF0aC5yYW5kb20oKTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGtleSkge1xuICByZXR1cm4gJ1N5bWJvbCgnLmNvbmNhdChrZXkgPT09IHVuZGVmaW5lZCA/ICcnIDoga2V5LCAnKV8nLCAoKytpZCArIHB4KS50b1N0cmluZygzNikpO1xufTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCJjYWRmXCI6XG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG52YXIgYWRkVG9VbnNjb3BhYmxlcyA9IF9fd2VicGFja19yZXF1aXJlX18oXCI5YzZjXCIpO1xudmFyIHN0ZXAgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiZDUzYlwiKTtcbnZhciBJdGVyYXRvcnMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiODRmMlwiKTtcbnZhciB0b0lPYmplY3QgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiNjgyMVwiKTtcblxuLy8gMjIuMS4zLjQgQXJyYXkucHJvdG90eXBlLmVudHJpZXMoKVxuLy8gMjIuMS4zLjEzIEFycmF5LnByb3RvdHlwZS5rZXlzKClcbi8vIDIyLjEuMy4yOSBBcnJheS5wcm90b3R5cGUudmFsdWVzKClcbi8vIDIyLjEuMy4zMCBBcnJheS5wcm90b3R5cGVbQEBpdGVyYXRvcl0oKVxubW9kdWxlLmV4cG9ydHMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiMDFmOVwiKShBcnJheSwgJ0FycmF5JywgZnVuY3Rpb24gKGl0ZXJhdGVkLCBraW5kKSB7XG4gIHRoaXMuX3QgPSB0b0lPYmplY3QoaXRlcmF0ZWQpOyAvLyB0YXJnZXRcbiAgdGhpcy5faSA9IDA7ICAgICAgICAgICAgICAgICAgIC8vIG5leHQgaW5kZXhcbiAgdGhpcy5fayA9IGtpbmQ7ICAgICAgICAgICAgICAgIC8vIGtpbmRcbi8vIDIyLjEuNS4yLjEgJUFycmF5SXRlcmF0b3JQcm90b3R5cGUlLm5leHQoKVxufSwgZnVuY3Rpb24gKCkge1xuICB2YXIgTyA9IHRoaXMuX3Q7XG4gIHZhciBraW5kID0gdGhpcy5faztcbiAgdmFyIGluZGV4ID0gdGhpcy5faSsrO1xuICBpZiAoIU8gfHwgaW5kZXggPj0gTy5sZW5ndGgpIHtcbiAgICB0aGlzLl90ID0gdW5kZWZpbmVkO1xuICAgIHJldHVybiBzdGVwKDEpO1xuICB9XG4gIGlmIChraW5kID09ICdrZXlzJykgcmV0dXJuIHN0ZXAoMCwgaW5kZXgpO1xuICBpZiAoa2luZCA9PSAndmFsdWVzJykgcmV0dXJuIHN0ZXAoMCwgT1tpbmRleF0pO1xuICByZXR1cm4gc3RlcCgwLCBbaW5kZXgsIE9baW5kZXhdXSk7XG59LCAndmFsdWVzJyk7XG5cbi8vIGFyZ3VtZW50c0xpc3RbQEBpdGVyYXRvcl0gaXMgJUFycmF5UHJvdG9fdmFsdWVzJSAoOS40LjQuNiwgOS40LjQuNylcbkl0ZXJhdG9ycy5Bcmd1bWVudHMgPSBJdGVyYXRvcnMuQXJyYXk7XG5cbmFkZFRvVW5zY29wYWJsZXMoJ2tleXMnKTtcbmFkZFRvVW5zY29wYWJsZXMoJ3ZhbHVlcycpO1xuYWRkVG9VbnNjb3BhYmxlcygnZW50cmllcycpO1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcImNiN2NcIjpcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxudmFyIGlzT2JqZWN0ID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcImQzZjRcIik7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdCkge1xuICBpZiAoIWlzT2JqZWN0KGl0KSkgdGhyb3cgVHlwZUVycm9yKGl0ICsgJyBpcyBub3QgYW4gb2JqZWN0IScpO1xuICByZXR1cm4gaXQ7XG59O1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcImNlMTBcIjpcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxudmFyIGhhcyA9IF9fd2VicGFja19yZXF1aXJlX18oXCI2OWE4XCIpO1xudmFyIHRvSU9iamVjdCA9IF9fd2VicGFja19yZXF1aXJlX18oXCI2ODIxXCIpO1xudmFyIGFycmF5SW5kZXhPZiA9IF9fd2VicGFja19yZXF1aXJlX18oXCJjMzY2XCIpKGZhbHNlKTtcbnZhciBJRV9QUk9UTyA9IF9fd2VicGFja19yZXF1aXJlX18oXCI2MTNiXCIpKCdJRV9QUk9UTycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChvYmplY3QsIG5hbWVzKSB7XG4gIHZhciBPID0gdG9JT2JqZWN0KG9iamVjdCk7XG4gIHZhciBpID0gMDtcbiAgdmFyIHJlc3VsdCA9IFtdO1xuICB2YXIga2V5O1xuICBmb3IgKGtleSBpbiBPKSBpZiAoa2V5ICE9IElFX1BST1RPKSBoYXMoTywga2V5KSAmJiByZXN1bHQucHVzaChrZXkpO1xuICAvLyBEb24ndCBlbnVtIGJ1ZyAmIGhpZGRlbiBrZXlzXG4gIHdoaWxlIChuYW1lcy5sZW5ndGggPiBpKSBpZiAoaGFzKE8sIGtleSA9IG5hbWVzW2krK10pKSB7XG4gICAgfmFycmF5SW5kZXhPZihyZXN1bHQsIGtleSkgfHwgcmVzdWx0LnB1c2goa2V5KTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCJkM2Y0XCI6XG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0KSB7XG4gIHJldHVybiB0eXBlb2YgaXQgPT09ICdvYmplY3QnID8gaXQgIT09IG51bGwgOiB0eXBlb2YgaXQgPT09ICdmdW5jdGlvbic7XG59O1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcImQ1M2JcIjpcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoZG9uZSwgdmFsdWUpIHtcbiAgcmV0dXJuIHsgdmFsdWU6IHZhbHVlLCBkb25lOiAhIWRvbmUgfTtcbn07XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiZDZlYlwiOlxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG52YXIgcHJvcCA9IFwiX2VyZFwiO1xuXG5mdW5jdGlvbiBpbml0U3RhdGUoZWxlbWVudCkge1xuICAgIGVsZW1lbnRbcHJvcF0gPSB7fTtcbiAgICByZXR1cm4gZ2V0U3RhdGUoZWxlbWVudCk7XG59XG5cbmZ1bmN0aW9uIGdldFN0YXRlKGVsZW1lbnQpIHtcbiAgICByZXR1cm4gZWxlbWVudFtwcm9wXTtcbn1cblxuZnVuY3Rpb24gY2xlYW5TdGF0ZShlbGVtZW50KSB7XG4gICAgZGVsZXRlIGVsZW1lbnRbcHJvcF07XG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICAgIGluaXRTdGF0ZTogaW5pdFN0YXRlLFxuICAgIGdldFN0YXRlOiBnZXRTdGF0ZSxcbiAgICBjbGVhblN0YXRlOiBjbGVhblN0YXRlXG59O1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcImQ4ZThcIjpcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXQpIHtcbiAgaWYgKHR5cGVvZiBpdCAhPSAnZnVuY3Rpb24nKSB0aHJvdyBUeXBlRXJyb3IoaXQgKyAnIGlzIG5vdCBhIGZ1bmN0aW9uIScpO1xuICByZXR1cm4gaXQ7XG59O1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcImUxMWVcIjpcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxuLy8gSUUgOC0gZG9uJ3QgZW51bSBidWcga2V5c1xubW9kdWxlLmV4cG9ydHMgPSAoXG4gICdjb25zdHJ1Y3RvcixoYXNPd25Qcm9wZXJ0eSxpc1Byb3RvdHlwZU9mLHByb3BlcnR5SXNFbnVtZXJhYmxlLHRvTG9jYWxlU3RyaW5nLHRvU3RyaW5nLHZhbHVlT2YnXG4pLnNwbGl0KCcsJyk7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiZTI3OVwiOlxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX193ZWJwYWNrX2V4cG9ydHNfXywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfbm9kZV9tb2R1bGVzX3Z1ZV9zdHlsZV9sb2FkZXJfaW5kZXhfanNfcmVmXzZfb25lT2ZfMV8wX25vZGVfbW9kdWxlc19jc3NfbG9hZGVyX2luZGV4X2pzX3JlZl82X29uZU9mXzFfMV9ub2RlX21vZHVsZXNfdnVlX2xvYWRlcl9saWJfbG9hZGVyc19zdHlsZVBvc3RMb2FkZXJfanNfbm9kZV9tb2R1bGVzX3Bvc3Rjc3NfbG9hZGVyX3NyY19pbmRleF9qc19yZWZfNl9vbmVPZl8xXzJfbm9kZV9tb2R1bGVzX3Bvc3Rjc3NfbG9hZGVyX3NyY19pbmRleF9qc19yZWZfNl9vbmVPZl8xXzNfbm9kZV9tb2R1bGVzX2NhY2hlX2xvYWRlcl9kaXN0X2Nqc19qc19yZWZfMF8wX25vZGVfbW9kdWxlc192dWVfbG9hZGVyX2xpYl9pbmRleF9qc192dWVfbG9hZGVyX29wdGlvbnNfR3JpZExheW91dF92dWVfdnVlX3R5cGVfc3R5bGVfaW5kZXhfMF9sYW5nX2Nzc19fX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXyA9IF9fd2VicGFja19yZXF1aXJlX18oXCIxMTU2XCIpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9ub2RlX21vZHVsZXNfdnVlX3N0eWxlX2xvYWRlcl9pbmRleF9qc19yZWZfNl9vbmVPZl8xXzBfbm9kZV9tb2R1bGVzX2Nzc19sb2FkZXJfaW5kZXhfanNfcmVmXzZfb25lT2ZfMV8xX25vZGVfbW9kdWxlc192dWVfbG9hZGVyX2xpYl9sb2FkZXJzX3N0eWxlUG9zdExvYWRlcl9qc19ub2RlX21vZHVsZXNfcG9zdGNzc19sb2FkZXJfc3JjX2luZGV4X2pzX3JlZl82X29uZU9mXzFfMl9ub2RlX21vZHVsZXNfcG9zdGNzc19sb2FkZXJfc3JjX2luZGV4X2pzX3JlZl82X29uZU9mXzFfM19ub2RlX21vZHVsZXNfY2FjaGVfbG9hZGVyX2Rpc3RfY2pzX2pzX3JlZl8wXzBfbm9kZV9tb2R1bGVzX3Z1ZV9sb2FkZXJfbGliX2luZGV4X2pzX3Z1ZV9sb2FkZXJfb3B0aW9uc19HcmlkTGF5b3V0X3Z1ZV92dWVfdHlwZV9zdHlsZV9pbmRleF8wX2xhbmdfY3NzX19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fX2RlZmF1bHQgPSAvKiNfX1BVUkVfXyovX193ZWJwYWNrX3JlcXVpcmVfXy5uKF9ub2RlX21vZHVsZXNfdnVlX3N0eWxlX2xvYWRlcl9pbmRleF9qc19yZWZfNl9vbmVPZl8xXzBfbm9kZV9tb2R1bGVzX2Nzc19sb2FkZXJfaW5kZXhfanNfcmVmXzZfb25lT2ZfMV8xX25vZGVfbW9kdWxlc192dWVfbG9hZGVyX2xpYl9sb2FkZXJzX3N0eWxlUG9zdExvYWRlcl9qc19ub2RlX21vZHVsZXNfcG9zdGNzc19sb2FkZXJfc3JjX2luZGV4X2pzX3JlZl82X29uZU9mXzFfMl9ub2RlX21vZHVsZXNfcG9zdGNzc19sb2FkZXJfc3JjX2luZGV4X2pzX3JlZl82X29uZU9mXzFfM19ub2RlX21vZHVsZXNfY2FjaGVfbG9hZGVyX2Rpc3RfY2pzX2pzX3JlZl8wXzBfbm9kZV9tb2R1bGVzX3Z1ZV9sb2FkZXJfbGliX2luZGV4X2pzX3Z1ZV9sb2FkZXJfb3B0aW9uc19HcmlkTGF5b3V0X3Z1ZV92dWVfdHlwZV9zdHlsZV9pbmRleF8wX2xhbmdfY3NzX19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fKTtcbi8qIHVudXNlZCBoYXJtb255IHJlZXhwb3J0ICogKi9cblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCJlZWM0XCI6XG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbnZhciBmb3JFYWNoICAgICAgICAgICAgICAgICA9IF9fd2VicGFja19yZXF1aXJlX18oXCJiNzcwXCIpLmZvckVhY2g7XG52YXIgZWxlbWVudFV0aWxzTWFrZXIgICAgICAgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiNWJlNVwiKTtcbnZhciBsaXN0ZW5lckhhbmRsZXJNYWtlciAgICA9IF9fd2VicGFja19yZXF1aXJlX18oXCI0OWFkXCIpO1xudmFyIGlkR2VuZXJhdG9yTWFrZXIgICAgICAgID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIjJjZWZcIik7XG52YXIgaWRIYW5kbGVyTWFrZXIgICAgICAgICAgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiNTA1OFwiKTtcbnZhciByZXBvcnRlck1ha2VyICAgICAgICAgICA9IF9fd2VicGFja19yZXF1aXJlX18oXCJhYmI0XCIpO1xudmFyIGJyb3dzZXJEZXRlY3RvciAgICAgICAgID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIjE4ZTlcIik7XG52YXIgYmF0Y2hQcm9jZXNzb3JNYWtlciAgICAgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiYzI3NFwiKTtcbnZhciBzdGF0ZUhhbmRsZXIgICAgICAgICAgICA9IF9fd2VicGFja19yZXF1aXJlX18oXCJkNmViXCIpO1xuXG4vL0RldGVjdGlvbiBzdHJhdGVnaWVzLlxudmFyIG9iamVjdFN0cmF0ZWd5TWFrZXIgICAgID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIjE4ZDJcIik7XG52YXIgc2Nyb2xsU3RyYXRlZ3lNYWtlciAgICAgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiYzk0NlwiKTtcblxuZnVuY3Rpb24gaXNDb2xsZWN0aW9uKG9iaikge1xuICAgIHJldHVybiBBcnJheS5pc0FycmF5KG9iaikgfHwgb2JqLmxlbmd0aCAhPT0gdW5kZWZpbmVkO1xufVxuXG5mdW5jdGlvbiB0b0FycmF5KGNvbGxlY3Rpb24pIHtcbiAgICBpZiAoIUFycmF5LmlzQXJyYXkoY29sbGVjdGlvbikpIHtcbiAgICAgICAgdmFyIGFycmF5ID0gW107XG4gICAgICAgIGZvckVhY2goY29sbGVjdGlvbiwgZnVuY3Rpb24gKG9iaikge1xuICAgICAgICAgICAgYXJyYXkucHVzaChvYmopO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIGFycmF5O1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBjb2xsZWN0aW9uO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gaXNFbGVtZW50KG9iaikge1xuICAgIHJldHVybiBvYmogJiYgb2JqLm5vZGVUeXBlID09PSAxO1xufVxuXG4vKipcbiAqIEB0eXBlZGVmIGlkSGFuZGxlclxuICogQHR5cGUge29iamVjdH1cbiAqIEBwcm9wZXJ0eSB7ZnVuY3Rpb259IGdldCBHZXRzIHRoZSByZXNpemUgZGV0ZWN0b3IgaWQgb2YgdGhlIGVsZW1lbnQuXG4gKiBAcHJvcGVydHkge2Z1bmN0aW9ufSBzZXQgR2VuZXJhdGUgYW5kIHNldHMgdGhlIHJlc2l6ZSBkZXRlY3RvciBpZCBvZiB0aGUgZWxlbWVudC5cbiAqL1xuXG4vKipcbiAqIEB0eXBlZGVmIE9wdGlvbnNcbiAqIEB0eXBlIHtvYmplY3R9XG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IGNhbGxPbkFkZCAgICBEZXRlcm1pbmVzIGlmIGxpc3RlbmVycyBzaG91bGQgYmUgY2FsbGVkIHdoZW4gdGhleSBhcmUgZ2V0dGluZyBhZGRlZC5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIERlZmF1bHQgaXMgdHJ1ZS4gSWYgdHJ1ZSwgdGhlIGxpc3RlbmVyIGlzIGd1YXJhbnRlZWQgdG8gYmUgY2FsbGVkIHdoZW4gaXQgaGFzIGJlZW4gYWRkZWQuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBJZiBmYWxzZSwgdGhlIGxpc3RlbmVyIHdpbGwgbm90IGJlIGd1YXJlbnRlZWQgdG8gYmUgY2FsbGVkIHdoZW4gaXQgaGFzIGJlZW4gYWRkZWQgKGRvZXMgbm90IHByZXZlbnQgaXQgZnJvbSBiZWluZyBjYWxsZWQpLlxuICogQHByb3BlcnR5IHtpZEhhbmRsZXJ9IGlkSGFuZGxlciAgQSBjdXN0b20gaWQgaGFuZGxlciB0aGF0IGlzIHJlc3BvbnNpYmxlIGZvciBnZW5lcmF0aW5nLCBzZXR0aW5nIGFuZCByZXRyaWV2aW5nIGlkJ3MgZm9yIGVsZW1lbnRzLlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgSWYgbm90IHByb3ZpZGVkLCBhIGRlZmF1bHQgaWQgaGFuZGxlciB3aWxsIGJlIHVzZWQuXG4gKiBAcHJvcGVydHkge3JlcG9ydGVyfSByZXBvcnRlciAgICBBIGN1c3RvbSByZXBvcnRlciB0aGF0IGhhbmRsZXMgcmVwb3J0aW5nIGxvZ3MsIHdhcm5pbmdzIGFuZCBlcnJvcnMuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBJZiBub3QgcHJvdmlkZWQsIGEgZGVmYXVsdCBpZCBoYW5kbGVyIHdpbGwgYmUgdXNlZC5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIElmIHNldCB0byBmYWxzZSwgdGhlbiBub3RoaW5nIHdpbGwgYmUgcmVwb3J0ZWQuXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IGRlYnVnICAgICAgICBJZiBzZXQgdG8gdHJ1ZSwgdGhlIHRoZSBzeXN0ZW0gd2lsbCByZXBvcnQgZGVidWcgbWVzc2FnZXMgYXMgZGVmYXVsdCBmb3IgdGhlIGxpc3RlblRvIG1ldGhvZC5cbiAqL1xuXG4vKipcbiAqIENyZWF0ZXMgYW4gZWxlbWVudCByZXNpemUgZGV0ZWN0b3IgaW5zdGFuY2UuXG4gKiBAcHVibGljXG4gKiBAcGFyYW0ge09wdGlvbnM/fSBvcHRpb25zIE9wdGlvbmFsIGdsb2JhbCBvcHRpb25zIG9iamVjdCB0aGF0IHdpbGwgZGVjaWRlIGhvdyB0aGlzIGluc3RhbmNlIHdpbGwgd29yay5cbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cbiAgICAvL2lkSGFuZGxlciBpcyBjdXJyZW50bHkgbm90IGFuIG9wdGlvbiB0byB0aGUgbGlzdGVuVG8gZnVuY3Rpb24sIHNvIGl0IHNob3VsZCBub3QgYmUgYWRkZWQgdG8gZ2xvYmFsT3B0aW9ucy5cbiAgICB2YXIgaWRIYW5kbGVyO1xuXG4gICAgaWYgKG9wdGlvbnMuaWRIYW5kbGVyKSB7XG4gICAgICAgIC8vIFRvIG1haW50YWluIGNvbXBhdGFiaWxpdHkgd2l0aCBpZEhhbmRsZXIuZ2V0KGVsZW1lbnQsIHJlYWRvbmx5KSwgbWFrZSBzdXJlIHRvIHdyYXAgdGhlIGdpdmVuIGlkSGFuZGxlclxuICAgICAgICAvLyBzbyB0aGF0IHJlYWRvbmx5IGZsYWcgYWx3YXlzIGlzIHRydWUgd2hlbiBpdCdzIHVzZWQgaGVyZS4gVGhpcyBtYXkgYmUgcmVtb3ZlZCBuZXh0IG1ham9yIHZlcnNpb24gYnVtcC5cbiAgICAgICAgaWRIYW5kbGVyID0ge1xuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoZWxlbWVudCkgeyByZXR1cm4gb3B0aW9ucy5pZEhhbmRsZXIuZ2V0KGVsZW1lbnQsIHRydWUpOyB9LFxuICAgICAgICAgICAgc2V0OiBvcHRpb25zLmlkSGFuZGxlci5zZXRcbiAgICAgICAgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgaWRHZW5lcmF0b3IgPSBpZEdlbmVyYXRvck1ha2VyKCk7XG4gICAgICAgIHZhciBkZWZhdWx0SWRIYW5kbGVyID0gaWRIYW5kbGVyTWFrZXIoe1xuICAgICAgICAgICAgaWRHZW5lcmF0b3I6IGlkR2VuZXJhdG9yLFxuICAgICAgICAgICAgc3RhdGVIYW5kbGVyOiBzdGF0ZUhhbmRsZXJcbiAgICAgICAgfSk7XG4gICAgICAgIGlkSGFuZGxlciA9IGRlZmF1bHRJZEhhbmRsZXI7XG4gICAgfVxuXG4gICAgLy9yZXBvcnRlciBpcyBjdXJyZW50bHkgbm90IGFuIG9wdGlvbiB0byB0aGUgbGlzdGVuVG8gZnVuY3Rpb24sIHNvIGl0IHNob3VsZCBub3QgYmUgYWRkZWQgdG8gZ2xvYmFsT3B0aW9ucy5cbiAgICB2YXIgcmVwb3J0ZXIgPSBvcHRpb25zLnJlcG9ydGVyO1xuXG4gICAgaWYoIXJlcG9ydGVyKSB7XG4gICAgICAgIC8vSWYgb3B0aW9ucy5yZXBvcnRlciBpcyBmYWxzZSwgdGhlbiB0aGUgcmVwb3J0ZXIgc2hvdWxkIGJlIHF1aWV0LlxuICAgICAgICB2YXIgcXVpZXQgPSByZXBvcnRlciA9PT0gZmFsc2U7XG4gICAgICAgIHJlcG9ydGVyID0gcmVwb3J0ZXJNYWtlcihxdWlldCk7XG4gICAgfVxuXG4gICAgLy9iYXRjaFByb2Nlc3NvciBpcyBjdXJyZW50bHkgbm90IGFuIG9wdGlvbiB0byB0aGUgbGlzdGVuVG8gZnVuY3Rpb24sIHNvIGl0IHNob3VsZCBub3QgYmUgYWRkZWQgdG8gZ2xvYmFsT3B0aW9ucy5cbiAgICB2YXIgYmF0Y2hQcm9jZXNzb3IgPSBnZXRPcHRpb24ob3B0aW9ucywgXCJiYXRjaFByb2Nlc3NvclwiLCBiYXRjaFByb2Nlc3Nvck1ha2VyKHsgcmVwb3J0ZXI6IHJlcG9ydGVyIH0pKTtcblxuICAgIC8vT3B0aW9ucyB0byBiZSB1c2VkIGFzIGRlZmF1bHQgZm9yIHRoZSBsaXN0ZW5UbyBmdW5jdGlvbi5cbiAgICB2YXIgZ2xvYmFsT3B0aW9ucyA9IHt9O1xuICAgIGdsb2JhbE9wdGlvbnMuY2FsbE9uQWRkICAgICA9ICEhZ2V0T3B0aW9uKG9wdGlvbnMsIFwiY2FsbE9uQWRkXCIsIHRydWUpO1xuICAgIGdsb2JhbE9wdGlvbnMuZGVidWcgICAgICAgICA9ICEhZ2V0T3B0aW9uKG9wdGlvbnMsIFwiZGVidWdcIiwgZmFsc2UpO1xuXG4gICAgdmFyIGV2ZW50TGlzdGVuZXJIYW5kbGVyICAgID0gbGlzdGVuZXJIYW5kbGVyTWFrZXIoaWRIYW5kbGVyKTtcbiAgICB2YXIgZWxlbWVudFV0aWxzICAgICAgICAgICAgPSBlbGVtZW50VXRpbHNNYWtlcih7XG4gICAgICAgIHN0YXRlSGFuZGxlcjogc3RhdGVIYW5kbGVyXG4gICAgfSk7XG5cbiAgICAvL1RoZSBkZXRlY3Rpb24gc3RyYXRlZ3kgdG8gYmUgdXNlZC5cbiAgICB2YXIgZGV0ZWN0aW9uU3RyYXRlZ3k7XG4gICAgdmFyIGRlc2lyZWRTdHJhdGVneSA9IGdldE9wdGlvbihvcHRpb25zLCBcInN0cmF0ZWd5XCIsIFwib2JqZWN0XCIpO1xuICAgIHZhciBpbXBvcnRhbnRDc3NSdWxlcyA9IGdldE9wdGlvbihvcHRpb25zLCBcImltcG9ydGFudFwiLCBmYWxzZSk7XG4gICAgdmFyIHN0cmF0ZWd5T3B0aW9ucyA9IHtcbiAgICAgICAgcmVwb3J0ZXI6IHJlcG9ydGVyLFxuICAgICAgICBiYXRjaFByb2Nlc3NvcjogYmF0Y2hQcm9jZXNzb3IsXG4gICAgICAgIHN0YXRlSGFuZGxlcjogc3RhdGVIYW5kbGVyLFxuICAgICAgICBpZEhhbmRsZXI6IGlkSGFuZGxlcixcbiAgICAgICAgaW1wb3J0YW50OiBpbXBvcnRhbnRDc3NSdWxlc1xuICAgIH07XG5cbiAgICBpZihkZXNpcmVkU3RyYXRlZ3kgPT09IFwic2Nyb2xsXCIpIHtcbiAgICAgICAgaWYgKGJyb3dzZXJEZXRlY3Rvci5pc0xlZ2FjeU9wZXJhKCkpIHtcbiAgICAgICAgICAgIHJlcG9ydGVyLndhcm4oXCJTY3JvbGwgc3RyYXRlZ3kgaXMgbm90IHN1cHBvcnRlZCBvbiBsZWdhY3kgT3BlcmEuIENoYW5naW5nIHRvIG9iamVjdCBzdHJhdGVneS5cIik7XG4gICAgICAgICAgICBkZXNpcmVkU3RyYXRlZ3kgPSBcIm9iamVjdFwiO1xuICAgICAgICB9IGVsc2UgaWYgKGJyb3dzZXJEZXRlY3Rvci5pc0lFKDkpKSB7XG4gICAgICAgICAgICByZXBvcnRlci53YXJuKFwiU2Nyb2xsIHN0cmF0ZWd5IGlzIG5vdCBzdXBwb3J0ZWQgb24gSUU5LiBDaGFuZ2luZyB0byBvYmplY3Qgc3RyYXRlZ3kuXCIpO1xuICAgICAgICAgICAgZGVzaXJlZFN0cmF0ZWd5ID0gXCJvYmplY3RcIjtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGlmKGRlc2lyZWRTdHJhdGVneSA9PT0gXCJzY3JvbGxcIikge1xuICAgICAgICBkZXRlY3Rpb25TdHJhdGVneSA9IHNjcm9sbFN0cmF0ZWd5TWFrZXIoc3RyYXRlZ3lPcHRpb25zKTtcbiAgICB9IGVsc2UgaWYoZGVzaXJlZFN0cmF0ZWd5ID09PSBcIm9iamVjdFwiKSB7XG4gICAgICAgIGRldGVjdGlvblN0cmF0ZWd5ID0gb2JqZWN0U3RyYXRlZ3lNYWtlcihzdHJhdGVneU9wdGlvbnMpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgc3RyYXRlZ3kgbmFtZTogXCIgKyBkZXNpcmVkU3RyYXRlZ3kpO1xuICAgIH1cblxuICAgIC8vQ2FsbHMgY2FuIGJlIG1hZGUgdG8gbGlzdGVuVG8gd2l0aCBlbGVtZW50cyB0aGF0IGFyZSBzdGlsbCBiZWluZyBpbnN0YWxsZWQuXG4gICAgLy9BbHNvLCBzYW1lIGVsZW1lbnRzIGNhbiBvY2N1ciBpbiB0aGUgZWxlbWVudHMgbGlzdCBpbiB0aGUgbGlzdGVuVG8gZnVuY3Rpb24uXG4gICAgLy9XaXRoIHRoaXMgbWFwLCB0aGUgcmVhZHkgY2FsbGJhY2tzIGNhbiBiZSBzeW5jaHJvbml6ZWQgYmV0d2VlbiB0aGUgY2FsbHNcbiAgICAvL3NvIHRoYXQgdGhlIHJlYWR5IGNhbGxiYWNrIGNhbiBhbHdheXMgYmUgY2FsbGVkIHdoZW4gYW4gZWxlbWVudCBpcyByZWFkeSAtIGV2ZW4gaWZcbiAgICAvL2l0IHdhc24ndCBpbnN0YWxsZWQgZnJvbSB0aGUgZnVuY3Rpb24gaXRzZWxmLlxuICAgIHZhciBvblJlYWR5Q2FsbGJhY2tzID0ge307XG5cbiAgICAvKipcbiAgICAgKiBNYWtlcyB0aGUgZ2l2ZW4gZWxlbWVudHMgcmVzaXplLWRldGVjdGFibGUgYW5kIHN0YXJ0cyBsaXN0ZW5pbmcgdG8gcmVzaXplIGV2ZW50cyBvbiB0aGUgZWxlbWVudHMuIENhbGxzIHRoZSBldmVudCBjYWxsYmFjayBmb3IgZWFjaCBldmVudCBmb3IgZWFjaCBlbGVtZW50LlxuICAgICAqIEBwdWJsaWNcbiAgICAgKiBAcGFyYW0ge09wdGlvbnM/fSBvcHRpb25zIE9wdGlvbmFsIG9wdGlvbnMgb2JqZWN0LiBUaGVzZSBvcHRpb25zIHdpbGwgb3ZlcnJpZGUgdGhlIGdsb2JhbCBvcHRpb25zLiBTb21lIG9wdGlvbnMgbWF5IG5vdCBiZSBvdmVycmlkZW4sIHN1Y2ggYXMgaWRIYW5kbGVyLlxuICAgICAqIEBwYXJhbSB7ZWxlbWVudFtdfGVsZW1lbnR9IGVsZW1lbnRzIFRoZSBnaXZlbiBhcnJheSBvZiBlbGVtZW50cyB0byBkZXRlY3QgcmVzaXplIGV2ZW50cyBvZi4gU2luZ2xlIGVsZW1lbnQgaXMgYWxzbyB2YWxpZC5cbiAgICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBsaXN0ZW5lciBUaGUgY2FsbGJhY2sgdG8gYmUgZXhlY3V0ZWQgZm9yIGVhY2ggcmVzaXplIGV2ZW50IGZvciBlYWNoIGVsZW1lbnQuXG4gICAgICovXG4gICAgZnVuY3Rpb24gbGlzdGVuVG8ob3B0aW9ucywgZWxlbWVudHMsIGxpc3RlbmVyKSB7XG4gICAgICAgIGZ1bmN0aW9uIG9uUmVzaXplQ2FsbGJhY2soZWxlbWVudCkge1xuICAgICAgICAgICAgdmFyIGxpc3RlbmVycyA9IGV2ZW50TGlzdGVuZXJIYW5kbGVyLmdldChlbGVtZW50KTtcbiAgICAgICAgICAgIGZvckVhY2gobGlzdGVuZXJzLCBmdW5jdGlvbiBjYWxsTGlzdGVuZXJQcm94eShsaXN0ZW5lcikge1xuICAgICAgICAgICAgICAgIGxpc3RlbmVyKGVsZW1lbnQpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBhZGRMaXN0ZW5lcihjYWxsT25BZGQsIGVsZW1lbnQsIGxpc3RlbmVyKSB7XG4gICAgICAgICAgICBldmVudExpc3RlbmVySGFuZGxlci5hZGQoZWxlbWVudCwgbGlzdGVuZXIpO1xuXG4gICAgICAgICAgICBpZihjYWxsT25BZGQpIHtcbiAgICAgICAgICAgICAgICBsaXN0ZW5lcihlbGVtZW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vT3B0aW9ucyBvYmplY3QgbWF5IGJlIG9taXR0ZWQuXG4gICAgICAgIGlmKCFsaXN0ZW5lcikge1xuICAgICAgICAgICAgbGlzdGVuZXIgPSBlbGVtZW50cztcbiAgICAgICAgICAgIGVsZW1lbnRzID0gb3B0aW9ucztcbiAgICAgICAgICAgIG9wdGlvbnMgPSB7fTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmKCFlbGVtZW50cykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQXQgbGVhc3Qgb25lIGVsZW1lbnQgcmVxdWlyZWQuXCIpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYoIWxpc3RlbmVyKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJMaXN0ZW5lciByZXF1aXJlZC5cIik7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaXNFbGVtZW50KGVsZW1lbnRzKSkge1xuICAgICAgICAgICAgLy8gQSBzaW5nbGUgZWxlbWVudCBoYXMgYmVlbiBwYXNzZWQgaW4uXG4gICAgICAgICAgICBlbGVtZW50cyA9IFtlbGVtZW50c107XG4gICAgICAgIH0gZWxzZSBpZiAoaXNDb2xsZWN0aW9uKGVsZW1lbnRzKSkge1xuICAgICAgICAgICAgLy8gQ29udmVydCBjb2xsZWN0aW9uIHRvIGFycmF5IGZvciBwbHVnaW5zLlxuICAgICAgICAgICAgLy8gVE9ETzogTWF5IHdhbnQgdG8gY2hlY2sgc28gdGhhdCBhbGwgdGhlIGVsZW1lbnRzIGluIHRoZSBjb2xsZWN0aW9uIGFyZSB2YWxpZCBlbGVtZW50cy5cbiAgICAgICAgICAgIGVsZW1lbnRzID0gdG9BcnJheShlbGVtZW50cyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gcmVwb3J0ZXIuZXJyb3IoXCJJbnZhbGlkIGFyZ3VtZW50cy4gTXVzdCBiZSBhIERPTSBlbGVtZW50IG9yIGEgY29sbGVjdGlvbiBvZiBET00gZWxlbWVudHMuXCIpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGVsZW1lbnRzUmVhZHkgPSAwO1xuXG4gICAgICAgIHZhciBjYWxsT25BZGQgPSBnZXRPcHRpb24ob3B0aW9ucywgXCJjYWxsT25BZGRcIiwgZ2xvYmFsT3B0aW9ucy5jYWxsT25BZGQpO1xuICAgICAgICB2YXIgb25SZWFkeUNhbGxiYWNrID0gZ2V0T3B0aW9uKG9wdGlvbnMsIFwib25SZWFkeVwiLCBmdW5jdGlvbiBub29wKCkge30pO1xuICAgICAgICB2YXIgZGVidWcgPSBnZXRPcHRpb24ob3B0aW9ucywgXCJkZWJ1Z1wiLCBnbG9iYWxPcHRpb25zLmRlYnVnKTtcblxuICAgICAgICBmb3JFYWNoKGVsZW1lbnRzLCBmdW5jdGlvbiBhdHRhY2hMaXN0ZW5lclRvRWxlbWVudChlbGVtZW50KSB7XG4gICAgICAgICAgICBpZiAoIXN0YXRlSGFuZGxlci5nZXRTdGF0ZShlbGVtZW50KSkge1xuICAgICAgICAgICAgICAgIHN0YXRlSGFuZGxlci5pbml0U3RhdGUoZWxlbWVudCk7XG4gICAgICAgICAgICAgICAgaWRIYW5kbGVyLnNldChlbGVtZW50KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIGlkID0gaWRIYW5kbGVyLmdldChlbGVtZW50KTtcblxuICAgICAgICAgICAgZGVidWcgJiYgcmVwb3J0ZXIubG9nKFwiQXR0YWNoaW5nIGxpc3RlbmVyIHRvIGVsZW1lbnRcIiwgaWQsIGVsZW1lbnQpO1xuXG4gICAgICAgICAgICBpZighZWxlbWVudFV0aWxzLmlzRGV0ZWN0YWJsZShlbGVtZW50KSkge1xuICAgICAgICAgICAgICAgIGRlYnVnICYmIHJlcG9ydGVyLmxvZyhpZCwgXCJOb3QgZGV0ZWN0YWJsZS5cIik7XG4gICAgICAgICAgICAgICAgaWYoZWxlbWVudFV0aWxzLmlzQnVzeShlbGVtZW50KSkge1xuICAgICAgICAgICAgICAgICAgICBkZWJ1ZyAmJiByZXBvcnRlci5sb2coaWQsIFwiU3lzdGVtIGJ1c3kgbWFraW5nIGl0IGRldGVjdGFibGVcIik7XG5cbiAgICAgICAgICAgICAgICAgICAgLy9UaGUgZWxlbWVudCBpcyBiZWluZyBwcmVwYXJlZCB0byBiZSBkZXRlY3RhYmxlLiBEbyBub3QgbWFrZSBpdCBkZXRlY3RhYmxlLlxuICAgICAgICAgICAgICAgICAgICAvL0p1c3QgYWRkIHRoZSBsaXN0ZW5lciwgYmVjYXVzZSB0aGUgZWxlbWVudCB3aWxsIHNvb24gYmUgZGV0ZWN0YWJsZS5cbiAgICAgICAgICAgICAgICAgICAgYWRkTGlzdGVuZXIoY2FsbE9uQWRkLCBlbGVtZW50LCBsaXN0ZW5lcik7XG4gICAgICAgICAgICAgICAgICAgIG9uUmVhZHlDYWxsYmFja3NbaWRdID0gb25SZWFkeUNhbGxiYWNrc1tpZF0gfHwgW107XG4gICAgICAgICAgICAgICAgICAgIG9uUmVhZHlDYWxsYmFja3NbaWRdLnB1c2goZnVuY3Rpb24gb25SZWFkeSgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsZW1lbnRzUmVhZHkrKztcblxuICAgICAgICAgICAgICAgICAgICAgICAgaWYoZWxlbWVudHNSZWFkeSA9PT0gZWxlbWVudHMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb25SZWFkeUNhbGxiYWNrKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgZGVidWcgJiYgcmVwb3J0ZXIubG9nKGlkLCBcIk1ha2luZyBkZXRlY3RhYmxlLi4uXCIpO1xuICAgICAgICAgICAgICAgIC8vVGhlIGVsZW1lbnQgaXMgbm90IHByZXBhcmVkIHRvIGJlIGRldGVjdGFibGUsIHNvIGRvIHByZXBhcmUgaXQgYW5kIGFkZCBhIGxpc3RlbmVyIHRvIGl0LlxuICAgICAgICAgICAgICAgIGVsZW1lbnRVdGlscy5tYXJrQnVzeShlbGVtZW50LCB0cnVlKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gZGV0ZWN0aW9uU3RyYXRlZ3kubWFrZURldGVjdGFibGUoeyBkZWJ1ZzogZGVidWcsIGltcG9ydGFudDogaW1wb3J0YW50Q3NzUnVsZXMgfSwgZWxlbWVudCwgZnVuY3Rpb24gb25FbGVtZW50RGV0ZWN0YWJsZShlbGVtZW50KSB7XG4gICAgICAgICAgICAgICAgICAgIGRlYnVnICYmIHJlcG9ydGVyLmxvZyhpZCwgXCJvbkVsZW1lbnREZXRlY3RhYmxlXCIpO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmIChzdGF0ZUhhbmRsZXIuZ2V0U3RhdGUoZWxlbWVudCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsZW1lbnRVdGlscy5tYXJrQXNEZXRlY3RhYmxlKGVsZW1lbnQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgZWxlbWVudFV0aWxzLm1hcmtCdXN5KGVsZW1lbnQsIGZhbHNlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRldGVjdGlvblN0cmF0ZWd5LmFkZExpc3RlbmVyKGVsZW1lbnQsIG9uUmVzaXplQ2FsbGJhY2spO1xuICAgICAgICAgICAgICAgICAgICAgICAgYWRkTGlzdGVuZXIoY2FsbE9uQWRkLCBlbGVtZW50LCBsaXN0ZW5lcik7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFNpbmNlIHRoZSBlbGVtZW50IHNpemUgbWlnaHQgaGF2ZSBjaGFuZ2VkIHNpbmNlIHRoZSBjYWxsIHRvIFwibGlzdGVuVG9cIiwgd2UgbmVlZCB0byBjaGVjayBmb3IgdGhpcyBjaGFuZ2UsXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBzbyB0aGF0IGEgcmVzaXplIGV2ZW50IG1heSBiZSBlbWl0dGVkLlxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gSGF2aW5nIHRoZSBzdGFydFNpemUgb2JqZWN0IGlzIG9wdGlvbmFsIChzaW5jZSBpdCBkb2VzIG5vdCBtYWtlIHNlbnNlIGluIHNvbWUgY2FzZXMgc3VjaCBhcyB1bnJlbmRlcmVkIGVsZW1lbnRzKSwgc28gY2hlY2sgZm9yIGl0cyBleGlzdGFuY2UgYmVmb3JlLlxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gQWxzbywgY2hlY2sgdGhlIHN0YXRlIGV4aXN0YW5jZSBiZWZvcmUgc2luY2UgdGhlIGVsZW1lbnQgbWF5IGhhdmUgYmVlbiB1bmluc3RhbGxlZCBpbiB0aGUgaW5zdGFsbGF0aW9uIHByb2Nlc3MuXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgc3RhdGUgPSBzdGF0ZUhhbmRsZXIuZ2V0U3RhdGUoZWxlbWVudCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoc3RhdGUgJiYgc3RhdGUuc3RhcnRTaXplKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHdpZHRoID0gZWxlbWVudC5vZmZzZXRXaWR0aDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgaGVpZ2h0ID0gZWxlbWVudC5vZmZzZXRIZWlnaHQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHN0YXRlLnN0YXJ0U2l6ZS53aWR0aCAhPT0gd2lkdGggfHwgc3RhdGUuc3RhcnRTaXplLmhlaWdodCAhPT0gaGVpZ2h0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9uUmVzaXplQ2FsbGJhY2soZWxlbWVudCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICBpZihvblJlYWR5Q2FsbGJhY2tzW2lkXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvckVhY2gob25SZWFkeUNhbGxiYWNrc1tpZF0sIGZ1bmN0aW9uKGNhbGxiYWNrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBUaGUgZWxlbWVudCBoYXMgYmVlbiB1bmlzbnRhbGxlZCBiZWZvcmUgYmVpbmcgZGV0ZWN0YWJsZS5cbiAgICAgICAgICAgICAgICAgICAgICAgIGRlYnVnICYmIHJlcG9ydGVyLmxvZyhpZCwgXCJFbGVtZW50IHVuaW5zdGFsbGVkIGJlZm9yZSBiZWluZyBkZXRlY3RhYmxlLlwiKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBvblJlYWR5Q2FsbGJhY2tzW2lkXTtcblxuICAgICAgICAgICAgICAgICAgICBlbGVtZW50c1JlYWR5Kys7XG4gICAgICAgICAgICAgICAgICAgIGlmKGVsZW1lbnRzUmVhZHkgPT09IGVsZW1lbnRzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgb25SZWFkeUNhbGxiYWNrKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZGVidWcgJiYgcmVwb3J0ZXIubG9nKGlkLCBcIkFscmVhZHkgZGV0ZWNhYmxlLCBhZGRpbmcgbGlzdGVuZXIuXCIpO1xuXG4gICAgICAgICAgICAvL1RoZSBlbGVtZW50IGhhcyBiZWVuIHByZXBhcmVkIHRvIGJlIGRldGVjdGFibGUgYW5kIGlzIHJlYWR5IHRvIGJlIGxpc3RlbmVkIHRvLlxuICAgICAgICAgICAgYWRkTGlzdGVuZXIoY2FsbE9uQWRkLCBlbGVtZW50LCBsaXN0ZW5lcik7XG4gICAgICAgICAgICBlbGVtZW50c1JlYWR5Kys7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGlmKGVsZW1lbnRzUmVhZHkgPT09IGVsZW1lbnRzLmxlbmd0aCkge1xuICAgICAgICAgICAgb25SZWFkeUNhbGxiYWNrKCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiB1bmluc3RhbGwoZWxlbWVudHMpIHtcbiAgICAgICAgaWYoIWVsZW1lbnRzKSB7XG4gICAgICAgICAgICByZXR1cm4gcmVwb3J0ZXIuZXJyb3IoXCJBdCBsZWFzdCBvbmUgZWxlbWVudCBpcyByZXF1aXJlZC5cIik7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaXNFbGVtZW50KGVsZW1lbnRzKSkge1xuICAgICAgICAgICAgLy8gQSBzaW5nbGUgZWxlbWVudCBoYXMgYmVlbiBwYXNzZWQgaW4uXG4gICAgICAgICAgICBlbGVtZW50cyA9IFtlbGVtZW50c107XG4gICAgICAgIH0gZWxzZSBpZiAoaXNDb2xsZWN0aW9uKGVsZW1lbnRzKSkge1xuICAgICAgICAgICAgLy8gQ29udmVydCBjb2xsZWN0aW9uIHRvIGFycmF5IGZvciBwbHVnaW5zLlxuICAgICAgICAgICAgLy8gVE9ETzogTWF5IHdhbnQgdG8gY2hlY2sgc28gdGhhdCBhbGwgdGhlIGVsZW1lbnRzIGluIHRoZSBjb2xsZWN0aW9uIGFyZSB2YWxpZCBlbGVtZW50cy5cbiAgICAgICAgICAgIGVsZW1lbnRzID0gdG9BcnJheShlbGVtZW50cyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gcmVwb3J0ZXIuZXJyb3IoXCJJbnZhbGlkIGFyZ3VtZW50cy4gTXVzdCBiZSBhIERPTSBlbGVtZW50IG9yIGEgY29sbGVjdGlvbiBvZiBET00gZWxlbWVudHMuXCIpO1xuICAgICAgICB9XG5cbiAgICAgICAgZm9yRWFjaChlbGVtZW50cywgZnVuY3Rpb24gKGVsZW1lbnQpIHtcbiAgICAgICAgICAgIGV2ZW50TGlzdGVuZXJIYW5kbGVyLnJlbW92ZUFsbExpc3RlbmVycyhlbGVtZW50KTtcbiAgICAgICAgICAgIGRldGVjdGlvblN0cmF0ZWd5LnVuaW5zdGFsbChlbGVtZW50KTtcbiAgICAgICAgICAgIHN0YXRlSGFuZGxlci5jbGVhblN0YXRlKGVsZW1lbnQpO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpbml0RG9jdW1lbnQodGFyZ2V0RG9jdW1lbnQpIHtcbiAgICAgICAgZGV0ZWN0aW9uU3RyYXRlZ3kuaW5pdERvY3VtZW50ICYmIGRldGVjdGlvblN0cmF0ZWd5LmluaXREb2N1bWVudCh0YXJnZXREb2N1bWVudCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgICAgbGlzdGVuVG86IGxpc3RlblRvLFxuICAgICAgICByZW1vdmVMaXN0ZW5lcjogZXZlbnRMaXN0ZW5lckhhbmRsZXIucmVtb3ZlTGlzdGVuZXIsXG4gICAgICAgIHJlbW92ZUFsbExpc3RlbmVyczogZXZlbnRMaXN0ZW5lckhhbmRsZXIucmVtb3ZlQWxsTGlzdGVuZXJzLFxuICAgICAgICB1bmluc3RhbGw6IHVuaW5zdGFsbCxcbiAgICAgICAgaW5pdERvY3VtZW50OiBpbml0RG9jdW1lbnRcbiAgICB9O1xufTtcblxuZnVuY3Rpb24gZ2V0T3B0aW9uKG9wdGlvbnMsIG5hbWUsIGRlZmF1bHRWYWx1ZSkge1xuICAgIHZhciB2YWx1ZSA9IG9wdGlvbnNbbmFtZV07XG5cbiAgICBpZigodmFsdWUgPT09IHVuZGVmaW5lZCB8fCB2YWx1ZSA9PT0gbnVsbCkgJiYgZGVmYXVsdFZhbHVlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIGRlZmF1bHRWYWx1ZTtcbiAgICB9XG5cbiAgICByZXR1cm4gdmFsdWU7XG59XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiZjFhZVwiOlxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxudmFyICRkZWZpbmVQcm9wZXJ0eSA9IF9fd2VicGFja19yZXF1aXJlX18oXCI4NmNjXCIpO1xudmFyIGNyZWF0ZURlc2MgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiNDYzMFwiKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAob2JqZWN0LCBpbmRleCwgdmFsdWUpIHtcbiAgaWYgKGluZGV4IGluIG9iamVjdCkgJGRlZmluZVByb3BlcnR5LmYob2JqZWN0LCBpbmRleCwgY3JlYXRlRGVzYygwLCB2YWx1ZSkpO1xuICBlbHNlIG9iamVjdFtpbmRleF0gPSB2YWx1ZTtcbn07XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiZjZmZFwiOlxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG4vLyBkb2N1bWVudC5jdXJyZW50U2NyaXB0IHBvbHlmaWxsIGJ5IEFkYW0gTWlsbGVyXG5cbi8vIE1JVCBsaWNlbnNlXG5cbihmdW5jdGlvbihkb2N1bWVudCl7XG4gIHZhciBjdXJyZW50U2NyaXB0ID0gXCJjdXJyZW50U2NyaXB0XCIsXG4gICAgICBzY3JpcHRzID0gZG9jdW1lbnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ3NjcmlwdCcpOyAvLyBMaXZlIE5vZGVMaXN0IGNvbGxlY3Rpb25cblxuICAvLyBJZiBicm93c2VyIG5lZWRzIGN1cnJlbnRTY3JpcHQgcG9seWZpbGwsIGFkZCBnZXQgY3VycmVudFNjcmlwdCgpIHRvIHRoZSBkb2N1bWVudCBvYmplY3RcbiAgaWYgKCEoY3VycmVudFNjcmlwdCBpbiBkb2N1bWVudCkpIHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZG9jdW1lbnQsIGN1cnJlbnRTY3JpcHQsIHtcbiAgICAgIGdldDogZnVuY3Rpb24oKXtcblxuICAgICAgICAvLyBJRSA2LTEwIHN1cHBvcnRzIHNjcmlwdCByZWFkeVN0YXRlXG4gICAgICAgIC8vIElFIDEwKyBzdXBwb3J0IHN0YWNrIHRyYWNlXG4gICAgICAgIHRyeSB7IHRocm93IG5ldyBFcnJvcigpOyB9XG4gICAgICAgIGNhdGNoIChlcnIpIHtcblxuICAgICAgICAgIC8vIEZpbmQgdGhlIHNlY29uZCBtYXRjaCBmb3IgdGhlIFwiYXRcIiBzdHJpbmcgdG8gZ2V0IGZpbGUgc3JjIHVybCBmcm9tIHN0YWNrLlxuICAgICAgICAgIC8vIFNwZWNpZmljYWxseSB3b3JrcyB3aXRoIHRoZSBmb3JtYXQgb2Ygc3RhY2sgdHJhY2VzIGluIElFLlxuICAgICAgICAgIHZhciBpLCByZXMgPSAoKC8uKmF0IFteXFwoXSpcXCgoLiopOi4rOi4rXFwpJC9pZykuZXhlYyhlcnIuc3RhY2spIHx8IFtmYWxzZV0pWzFdO1xuXG4gICAgICAgICAgLy8gRm9yIGFsbCBzY3JpcHRzIG9uIHRoZSBwYWdlLCBpZiBzcmMgbWF0Y2hlcyBvciBpZiByZWFkeSBzdGF0ZSBpcyBpbnRlcmFjdGl2ZSwgcmV0dXJuIHRoZSBzY3JpcHQgdGFnXG4gICAgICAgICAgZm9yKGkgaW4gc2NyaXB0cyl7XG4gICAgICAgICAgICBpZihzY3JpcHRzW2ldLnNyYyA9PSByZXMgfHwgc2NyaXB0c1tpXS5yZWFkeVN0YXRlID09IFwiaW50ZXJhY3RpdmVcIil7XG4gICAgICAgICAgICAgIHJldHVybiBzY3JpcHRzW2ldO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIElmIG5vIG1hdGNoLCByZXR1cm4gbnVsbFxuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbn0pKGRvY3VtZW50KTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCJmNzUxXCI6XG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbi8vIDE5LjEuMy4xIE9iamVjdC5hc3NpZ24odGFyZ2V0LCBzb3VyY2UpXG52YXIgJGV4cG9ydCA9IF9fd2VicGFja19yZXF1aXJlX18oXCI1Y2ExXCIpO1xuXG4kZXhwb3J0KCRleHBvcnQuUyArICRleHBvcnQuRiwgJ09iamVjdCcsIHsgYXNzaWduOiBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiNzMzM1wiKSB9KTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCJmYTViXCI6XG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbm1vZHVsZS5leHBvcnRzID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIjU1MzdcIikoJ25hdGl2ZS1mdW5jdGlvbi10by1zdHJpbmcnLCBGdW5jdGlvbi50b1N0cmluZyk7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiZmFiMlwiOlxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG52YXIgZG9jdW1lbnQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiNzcyNlwiKS5kb2N1bWVudDtcbm1vZHVsZS5leHBvcnRzID0gZG9jdW1lbnQgJiYgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50O1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcImZiMTVcIjpcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG4vLyBFU00gQ09NUEFUIEZMQUdcbl9fd2VicGFja19yZXF1aXJlX18ucihfX3dlYnBhY2tfZXhwb3J0c19fKTtcblxuLy8gRVhQT1JUU1xuX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwiaW5zdGFsbFwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIC8qIHJlZXhwb3J0ICovIGNvbXBvbmVudHNbXCJkXCIgLyogaW5zdGFsbCAqL107IH0pO1xuX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwiR3JpZExheW91dFwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIC8qIHJlZXhwb3J0ICovIGNvbXBvbmVudHNbXCJiXCIgLyogR3JpZExheW91dCAqL107IH0pO1xuX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwiR3JpZEl0ZW1cIiwgZnVuY3Rpb24oKSB7IHJldHVybiAvKiByZWV4cG9ydCAqLyBjb21wb25lbnRzW1wiYVwiIC8qIEdyaWRJdGVtICovXTsgfSk7XG5cbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vbm9kZV9tb2R1bGVzL0B2dWUvY2xpLXNlcnZpY2UvbGliL2NvbW1hbmRzL2J1aWxkL3NldFB1YmxpY1BhdGguanNcbi8vIFRoaXMgZmlsZSBpcyBpbXBvcnRlZCBpbnRvIGxpYi93YyBjbGllbnQgYnVuZGxlcy5cblxuaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnKSB7XG4gIGlmICh0cnVlKSB7XG4gICAgX193ZWJwYWNrX3JlcXVpcmVfXyhcImY2ZmRcIilcbiAgfVxuXG4gIHZhciBpXG4gIGlmICgoaSA9IHdpbmRvdy5kb2N1bWVudC5jdXJyZW50U2NyaXB0KSAmJiAoaSA9IGkuc3JjLm1hdGNoKC8oLitcXC8pW14vXStcXC5qcyhcXD8uKik/JC8pKSkge1xuICAgIF9fd2VicGFja19yZXF1aXJlX18ucCA9IGlbMV0gLy8gZXNsaW50LWRpc2FibGUtbGluZVxuICB9XG59XG5cbi8vIEluZGljYXRlIHRvIHdlYnBhY2sgdGhhdCB0aGlzIGZpbGUgY2FuIGJlIGNvbmNhdGVuYXRlZFxuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyB2YXIgc2V0UHVibGljUGF0aCA9IChudWxsKTtcblxuLy8gRVhURVJOQUwgTU9EVUxFOiAuL3NyYy9jb21wb25lbnRzL2luZGV4LmpzXG52YXIgY29tcG9uZW50cyA9IF9fd2VicGFja19yZXF1aXJlX18oXCIyYWY5XCIpO1xuXG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL25vZGVfbW9kdWxlcy9AdnVlL2NsaS1zZXJ2aWNlL2xpYi9jb21tYW5kcy9idWlsZC9lbnRyeS1saWIuanNcblxuXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIHZhciBlbnRyeV9saWIgPSBfX3dlYnBhY2tfZXhwb3J0c19fW1wiZGVmYXVsdFwiXSA9IChjb21wb25lbnRzW1wiY1wiIC8qIGRlZmF1bHQgKi9dKTtcblxuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcImZjYTBcIjpcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuLy8gMjAuMS4yLjIgTnVtYmVyLmlzRmluaXRlKG51bWJlcilcbnZhciAkZXhwb3J0ID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIjVjYTFcIik7XG52YXIgX2lzRmluaXRlID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIjc3MjZcIikuaXNGaW5pdGU7XG5cbiRleHBvcnQoJGV4cG9ydC5TLCAnTnVtYmVyJywge1xuICBpc0Zpbml0ZTogZnVuY3Rpb24gaXNGaW5pdGUoaXQpIHtcbiAgICByZXR1cm4gdHlwZW9mIGl0ID09ICdudW1iZXInICYmIF9pc0Zpbml0ZShpdCk7XG4gIH1cbn0pO1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcImZkZWZcIjpcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxubW9kdWxlLmV4cG9ydHMgPSAnXFx4MDlcXHgwQVxceDBCXFx4MENcXHgwRFxceDIwXFx4QTBcXHUxNjgwXFx1MTgwRVxcdTIwMDBcXHUyMDAxXFx1MjAwMlxcdTIwMDMnICtcbiAgJ1xcdTIwMDRcXHUyMDA1XFx1MjAwNlxcdTIwMDdcXHUyMDA4XFx1MjAwOVxcdTIwMEFcXHUyMDJGXFx1MjA1RlxcdTMwMDBcXHUyMDI4XFx1MjAyOVxcdUZFRkYnO1xuXG5cbi8qKiovIH0pXG5cbi8qKioqKiovIH0pW1wiZGVmYXVsdFwiXTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXZ1ZS1ncmlkLWxheW91dC5jb21tb24uanMubWFwIiwiaW1wb3J0IHsgcmVuZGVyLCBzdGF0aWNSZW5kZXJGbnMgfSBmcm9tIFwiLi9Cb3RUcmFkZVBhZ2UudnVlP3Z1ZSZ0eXBlPXRlbXBsYXRlJmlkPTIyZjk4YmMyJlwiXG5pbXBvcnQgc2NyaXB0IGZyb20gXCIuL0JvdFRyYWRlUGFnZS52dWU/dnVlJnR5cGU9c2NyaXB0Jmxhbmc9anMmXCJcbmV4cG9ydCAqIGZyb20gXCIuL0JvdFRyYWRlUGFnZS52dWU/dnVlJnR5cGU9c2NyaXB0Jmxhbmc9anMmXCJcbmltcG9ydCBzdHlsZTAgZnJvbSBcIi4vQm90VHJhZGVQYWdlLnZ1ZT92dWUmdHlwZT1zdHlsZSZpbmRleD0wJmxhbmc9c2NzcyZzY29wZT10cnVlJlwiXG5cblxuLyogbm9ybWFsaXplIGNvbXBvbmVudCAqL1xuaW1wb3J0IG5vcm1hbGl6ZXIgZnJvbSBcIiEuLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvcnVudGltZS9jb21wb25lbnROb3JtYWxpemVyLmpzXCJcbnZhciBjb21wb25lbnQgPSBub3JtYWxpemVyKFxuICBzY3JpcHQsXG4gIHJlbmRlcixcbiAgc3RhdGljUmVuZGVyRm5zLFxuICBmYWxzZSxcbiAgbnVsbCxcbiAgbnVsbCxcbiAgbnVsbFxuICBcbilcblxuLyogaG90IHJlbG9hZCAqL1xuaWYgKG1vZHVsZS5ob3QpIHtcbiAgdmFyIGFwaSA9IHJlcXVpcmUoXCJDOlxcXFx4YW1wcFxcXFxodGRvY3NcXFxcbm9kZV9tb2R1bGVzXFxcXHZ1ZS1ob3QtcmVsb2FkLWFwaVxcXFxkaXN0XFxcXGluZGV4LmpzXCIpXG4gIGFwaS5pbnN0YWxsKHJlcXVpcmUoJ3Z1ZScpKVxuICBpZiAoYXBpLmNvbXBhdGlibGUpIHtcbiAgICBtb2R1bGUuaG90LmFjY2VwdCgpXG4gICAgaWYgKCFhcGkuaXNSZWNvcmRlZCgnMjJmOThiYzInKSkge1xuICAgICAgYXBpLmNyZWF0ZVJlY29yZCgnMjJmOThiYzInLCBjb21wb25lbnQub3B0aW9ucylcbiAgICB9IGVsc2Uge1xuICAgICAgYXBpLnJlbG9hZCgnMjJmOThiYzInLCBjb21wb25lbnQub3B0aW9ucylcbiAgICB9XG4gICAgbW9kdWxlLmhvdC5hY2NlcHQoXCIuL0JvdFRyYWRlUGFnZS52dWU/dnVlJnR5cGU9dGVtcGxhdGUmaWQ9MjJmOThiYzImXCIsIGZ1bmN0aW9uICgpIHtcbiAgICAgIGFwaS5yZXJlbmRlcignMjJmOThiYzInLCB7XG4gICAgICAgIHJlbmRlcjogcmVuZGVyLFxuICAgICAgICBzdGF0aWNSZW5kZXJGbnM6IHN0YXRpY1JlbmRlckZuc1xuICAgICAgfSlcbiAgICB9KVxuICB9XG59XG5jb21wb25lbnQub3B0aW9ucy5fX2ZpbGUgPSBcInJlc291cmNlcy9zcmMvUGFnZXMvYm90L0JvdFRyYWRlUGFnZS52dWVcIlxuZXhwb3J0IGRlZmF1bHQgY29tcG9uZW50LmV4cG9ydHMiLCJpbXBvcnQgeyByZW5kZXIsIHN0YXRpY1JlbmRlckZucyB9IGZyb20gXCIuL1RyYWRlcy52dWU/dnVlJnR5cGU9dGVtcGxhdGUmaWQ9MGM3N2M0OWQmXCJcbmltcG9ydCBzY3JpcHQgZnJvbSBcIi4vVHJhZGVzLnZ1ZT92dWUmdHlwZT1zY3JpcHQmbGFuZz1qcyZcIlxuZXhwb3J0ICogZnJvbSBcIi4vVHJhZGVzLnZ1ZT92dWUmdHlwZT1zY3JpcHQmbGFuZz1qcyZcIlxuXG5cbi8qIG5vcm1hbGl6ZSBjb21wb25lbnQgKi9cbmltcG9ydCBub3JtYWxpemVyIGZyb20gXCIhLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3J1bnRpbWUvY29tcG9uZW50Tm9ybWFsaXplci5qc1wiXG52YXIgY29tcG9uZW50ID0gbm9ybWFsaXplcihcbiAgc2NyaXB0LFxuICByZW5kZXIsXG4gIHN0YXRpY1JlbmRlckZucyxcbiAgZmFsc2UsXG4gIG51bGwsXG4gIG51bGwsXG4gIG51bGxcbiAgXG4pXG5cbi8qIGhvdCByZWxvYWQgKi9cbmlmIChtb2R1bGUuaG90KSB7XG4gIHZhciBhcGkgPSByZXF1aXJlKFwiQzpcXFxceGFtcHBcXFxcaHRkb2NzXFxcXG5vZGVfbW9kdWxlc1xcXFx2dWUtaG90LXJlbG9hZC1hcGlcXFxcZGlzdFxcXFxpbmRleC5qc1wiKVxuICBhcGkuaW5zdGFsbChyZXF1aXJlKCd2dWUnKSlcbiAgaWYgKGFwaS5jb21wYXRpYmxlKSB7XG4gICAgbW9kdWxlLmhvdC5hY2NlcHQoKVxuICAgIGlmICghYXBpLmlzUmVjb3JkZWQoJzBjNzdjNDlkJykpIHtcbiAgICAgIGFwaS5jcmVhdGVSZWNvcmQoJzBjNzdjNDlkJywgY29tcG9uZW50Lm9wdGlvbnMpXG4gICAgfSBlbHNlIHtcbiAgICAgIGFwaS5yZWxvYWQoJzBjNzdjNDlkJywgY29tcG9uZW50Lm9wdGlvbnMpXG4gICAgfVxuICAgIG1vZHVsZS5ob3QuYWNjZXB0KFwiLi9UcmFkZXMudnVlP3Z1ZSZ0eXBlPXRlbXBsYXRlJmlkPTBjNzdjNDlkJlwiLCBmdW5jdGlvbiAoKSB7XG4gICAgICBhcGkucmVyZW5kZXIoJzBjNzdjNDlkJywge1xuICAgICAgICByZW5kZXI6IHJlbmRlcixcbiAgICAgICAgc3RhdGljUmVuZGVyRm5zOiBzdGF0aWNSZW5kZXJGbnNcbiAgICAgIH0pXG4gICAgfSlcbiAgfVxufVxuY29tcG9uZW50Lm9wdGlvbnMuX19maWxlID0gXCJyZXNvdXJjZXMvc3JjL2NvbXBvbmVudHMvYm90L1RyYWRlcy52dWVcIlxuZXhwb3J0IGRlZmF1bHQgY29tcG9uZW50LmV4cG9ydHMiLCJpbXBvcnQgeyByZW5kZXIsIHN0YXRpY1JlbmRlckZucyB9IGZyb20gXCIuL01hcmtldGluZm8udnVlP3Z1ZSZ0eXBlPXRlbXBsYXRlJmlkPWE3MDA1NDQ0JlwiXG5pbXBvcnQgc2NyaXB0IGZyb20gXCIuL01hcmtldGluZm8udnVlP3Z1ZSZ0eXBlPXNjcmlwdCZsYW5nPWpzJlwiXG5leHBvcnQgKiBmcm9tIFwiLi9NYXJrZXRpbmZvLnZ1ZT92dWUmdHlwZT1zY3JpcHQmbGFuZz1qcyZcIlxuXG5cbi8qIG5vcm1hbGl6ZSBjb21wb25lbnQgKi9cbmltcG9ydCBub3JtYWxpemVyIGZyb20gXCIhLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3J1bnRpbWUvY29tcG9uZW50Tm9ybWFsaXplci5qc1wiXG52YXIgY29tcG9uZW50ID0gbm9ybWFsaXplcihcbiAgc2NyaXB0LFxuICByZW5kZXIsXG4gIHN0YXRpY1JlbmRlckZucyxcbiAgZmFsc2UsXG4gIG51bGwsXG4gIG51bGwsXG4gIG51bGxcbiAgXG4pXG5cbi8qIGhvdCByZWxvYWQgKi9cbmlmIChtb2R1bGUuaG90KSB7XG4gIHZhciBhcGkgPSByZXF1aXJlKFwiQzpcXFxceGFtcHBcXFxcaHRkb2NzXFxcXG5vZGVfbW9kdWxlc1xcXFx2dWUtaG90LXJlbG9hZC1hcGlcXFxcZGlzdFxcXFxpbmRleC5qc1wiKVxuICBhcGkuaW5zdGFsbChyZXF1aXJlKCd2dWUnKSlcbiAgaWYgKGFwaS5jb21wYXRpYmxlKSB7XG4gICAgbW9kdWxlLmhvdC5hY2NlcHQoKVxuICAgIGlmICghYXBpLmlzUmVjb3JkZWQoJ2E3MDA1NDQ0JykpIHtcbiAgICAgIGFwaS5jcmVhdGVSZWNvcmQoJ2E3MDA1NDQ0JywgY29tcG9uZW50Lm9wdGlvbnMpXG4gICAgfSBlbHNlIHtcbiAgICAgIGFwaS5yZWxvYWQoJ2E3MDA1NDQ0JywgY29tcG9uZW50Lm9wdGlvbnMpXG4gICAgfVxuICAgIG1vZHVsZS5ob3QuYWNjZXB0KFwiLi9NYXJrZXRpbmZvLnZ1ZT92dWUmdHlwZT10ZW1wbGF0ZSZpZD1hNzAwNTQ0NCZcIiwgZnVuY3Rpb24gKCkge1xuICAgICAgYXBpLnJlcmVuZGVyKCdhNzAwNTQ0NCcsIHtcbiAgICAgICAgcmVuZGVyOiByZW5kZXIsXG4gICAgICAgIHN0YXRpY1JlbmRlckZuczogc3RhdGljUmVuZGVyRm5zXG4gICAgICB9KVxuICAgIH0pXG4gIH1cbn1cbmNvbXBvbmVudC5vcHRpb25zLl9fZmlsZSA9IFwicmVzb3VyY2VzL3NyYy9jb21wb25lbnRzL3RyYWRpbmcvTWFya2V0aW5mby52dWVcIlxuZXhwb3J0IGRlZmF1bHQgY29tcG9uZW50LmV4cG9ydHMiLCJpbXBvcnQgeyByZW5kZXIsIHN0YXRpY1JlbmRlckZucyB9IGZyb20gXCIuL01hcmtldHMudnVlP3Z1ZSZ0eXBlPXRlbXBsYXRlJmlkPWQ5NjViYTFhJlwiXG5pbXBvcnQgc2NyaXB0IGZyb20gXCIuL01hcmtldHMudnVlP3Z1ZSZ0eXBlPXNjcmlwdCZsYW5nPWpzJlwiXG5leHBvcnQgKiBmcm9tIFwiLi9NYXJrZXRzLnZ1ZT92dWUmdHlwZT1zY3JpcHQmbGFuZz1qcyZcIlxuaW1wb3J0IHN0eWxlMCBmcm9tIFwiLi9NYXJrZXRzLnZ1ZT92dWUmdHlwZT1zdHlsZSZpbmRleD0wJmxhbmc9Y3NzJlwiXG5cblxuLyogbm9ybWFsaXplIGNvbXBvbmVudCAqL1xuaW1wb3J0IG5vcm1hbGl6ZXIgZnJvbSBcIiEuLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvcnVudGltZS9jb21wb25lbnROb3JtYWxpemVyLmpzXCJcbnZhciBjb21wb25lbnQgPSBub3JtYWxpemVyKFxuICBzY3JpcHQsXG4gIHJlbmRlcixcbiAgc3RhdGljUmVuZGVyRm5zLFxuICBmYWxzZSxcbiAgbnVsbCxcbiAgbnVsbCxcbiAgbnVsbFxuICBcbilcblxuLyogaG90IHJlbG9hZCAqL1xuaWYgKG1vZHVsZS5ob3QpIHtcbiAgdmFyIGFwaSA9IHJlcXVpcmUoXCJDOlxcXFx4YW1wcFxcXFxodGRvY3NcXFxcbm9kZV9tb2R1bGVzXFxcXHZ1ZS1ob3QtcmVsb2FkLWFwaVxcXFxkaXN0XFxcXGluZGV4LmpzXCIpXG4gIGFwaS5pbnN0YWxsKHJlcXVpcmUoJ3Z1ZScpKVxuICBpZiAoYXBpLmNvbXBhdGlibGUpIHtcbiAgICBtb2R1bGUuaG90LmFjY2VwdCgpXG4gICAgaWYgKCFhcGkuaXNSZWNvcmRlZCgnZDk2NWJhMWEnKSkge1xuICAgICAgYXBpLmNyZWF0ZVJlY29yZCgnZDk2NWJhMWEnLCBjb21wb25lbnQub3B0aW9ucylcbiAgICB9IGVsc2Uge1xuICAgICAgYXBpLnJlbG9hZCgnZDk2NWJhMWEnLCBjb21wb25lbnQub3B0aW9ucylcbiAgICB9XG4gICAgbW9kdWxlLmhvdC5hY2NlcHQoXCIuL01hcmtldHMudnVlP3Z1ZSZ0eXBlPXRlbXBsYXRlJmlkPWQ5NjViYTFhJlwiLCBmdW5jdGlvbiAoKSB7XG4gICAgICBhcGkucmVyZW5kZXIoJ2Q5NjViYTFhJywge1xuICAgICAgICByZW5kZXI6IHJlbmRlcixcbiAgICAgICAgc3RhdGljUmVuZGVyRm5zOiBzdGF0aWNSZW5kZXJGbnNcbiAgICAgIH0pXG4gICAgfSlcbiAgfVxufVxuY29tcG9uZW50Lm9wdGlvbnMuX19maWxlID0gXCJyZXNvdXJjZXMvc3JjL2NvbXBvbmVudHMvdHJhZGluZy9NYXJrZXRzLnZ1ZVwiXG5leHBvcnQgZGVmYXVsdCBjb21wb25lbnQuZXhwb3J0cyIsImltcG9ydCB7IHJlbmRlciwgc3RhdGljUmVuZGVyRm5zIH0gZnJvbSBcIi4vT3JkZXJib29rLnZ1ZT92dWUmdHlwZT10ZW1wbGF0ZSZpZD00YTYzNjE3MyZcIlxuaW1wb3J0IHNjcmlwdCBmcm9tIFwiLi9PcmRlcmJvb2sudnVlP3Z1ZSZ0eXBlPXNjcmlwdCZsYW5nPWpzJlwiXG5leHBvcnQgKiBmcm9tIFwiLi9PcmRlcmJvb2sudnVlP3Z1ZSZ0eXBlPXNjcmlwdCZsYW5nPWpzJlwiXG5cblxuLyogbm9ybWFsaXplIGNvbXBvbmVudCAqL1xuaW1wb3J0IG5vcm1hbGl6ZXIgZnJvbSBcIiEuLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvcnVudGltZS9jb21wb25lbnROb3JtYWxpemVyLmpzXCJcbnZhciBjb21wb25lbnQgPSBub3JtYWxpemVyKFxuICBzY3JpcHQsXG4gIHJlbmRlcixcbiAgc3RhdGljUmVuZGVyRm5zLFxuICBmYWxzZSxcbiAgbnVsbCxcbiAgbnVsbCxcbiAgbnVsbFxuICBcbilcblxuLyogaG90IHJlbG9hZCAqL1xuaWYgKG1vZHVsZS5ob3QpIHtcbiAgdmFyIGFwaSA9IHJlcXVpcmUoXCJDOlxcXFx4YW1wcFxcXFxodGRvY3NcXFxcbm9kZV9tb2R1bGVzXFxcXHZ1ZS1ob3QtcmVsb2FkLWFwaVxcXFxkaXN0XFxcXGluZGV4LmpzXCIpXG4gIGFwaS5pbnN0YWxsKHJlcXVpcmUoJ3Z1ZScpKVxuICBpZiAoYXBpLmNvbXBhdGlibGUpIHtcbiAgICBtb2R1bGUuaG90LmFjY2VwdCgpXG4gICAgaWYgKCFhcGkuaXNSZWNvcmRlZCgnNGE2MzYxNzMnKSkge1xuICAgICAgYXBpLmNyZWF0ZVJlY29yZCgnNGE2MzYxNzMnLCBjb21wb25lbnQub3B0aW9ucylcbiAgICB9IGVsc2Uge1xuICAgICAgYXBpLnJlbG9hZCgnNGE2MzYxNzMnLCBjb21wb25lbnQub3B0aW9ucylcbiAgICB9XG4gICAgbW9kdWxlLmhvdC5hY2NlcHQoXCIuL09yZGVyYm9vay52dWU/dnVlJnR5cGU9dGVtcGxhdGUmaWQ9NGE2MzYxNzMmXCIsIGZ1bmN0aW9uICgpIHtcbiAgICAgIGFwaS5yZXJlbmRlcignNGE2MzYxNzMnLCB7XG4gICAgICAgIHJlbmRlcjogcmVuZGVyLFxuICAgICAgICBzdGF0aWNSZW5kZXJGbnM6IHN0YXRpY1JlbmRlckZuc1xuICAgICAgfSlcbiAgICB9KVxuICB9XG59XG5jb21wb25lbnQub3B0aW9ucy5fX2ZpbGUgPSBcInJlc291cmNlcy9zcmMvY29tcG9uZW50cy90cmFkaW5nL09yZGVyYm9vay52dWVcIlxuZXhwb3J0IGRlZmF1bHQgY29tcG9uZW50LmV4cG9ydHMiLCJpbXBvcnQgeyByZW5kZXIsIHN0YXRpY1JlbmRlckZucyB9IGZyb20gXCIuL1RyYWRpbmd2aWV3LnZ1ZT92dWUmdHlwZT10ZW1wbGF0ZSZpZD1lNGYxYjVmYyZcIlxuaW1wb3J0IHNjcmlwdCBmcm9tIFwiLi9UcmFkaW5ndmlldy52dWU/dnVlJnR5cGU9c2NyaXB0Jmxhbmc9anMmXCJcbmV4cG9ydCAqIGZyb20gXCIuL1RyYWRpbmd2aWV3LnZ1ZT92dWUmdHlwZT1zY3JpcHQmbGFuZz1qcyZcIlxuXG5cbi8qIG5vcm1hbGl6ZSBjb21wb25lbnQgKi9cbmltcG9ydCBub3JtYWxpemVyIGZyb20gXCIhLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3J1bnRpbWUvY29tcG9uZW50Tm9ybWFsaXplci5qc1wiXG52YXIgY29tcG9uZW50ID0gbm9ybWFsaXplcihcbiAgc2NyaXB0LFxuICByZW5kZXIsXG4gIHN0YXRpY1JlbmRlckZucyxcbiAgZmFsc2UsXG4gIG51bGwsXG4gIG51bGwsXG4gIG51bGxcbiAgXG4pXG5cbi8qIGhvdCByZWxvYWQgKi9cbmlmIChtb2R1bGUuaG90KSB7XG4gIHZhciBhcGkgPSByZXF1aXJlKFwiQzpcXFxceGFtcHBcXFxcaHRkb2NzXFxcXG5vZGVfbW9kdWxlc1xcXFx2dWUtaG90LXJlbG9hZC1hcGlcXFxcZGlzdFxcXFxpbmRleC5qc1wiKVxuICBhcGkuaW5zdGFsbChyZXF1aXJlKCd2dWUnKSlcbiAgaWYgKGFwaS5jb21wYXRpYmxlKSB7XG4gICAgbW9kdWxlLmhvdC5hY2NlcHQoKVxuICAgIGlmICghYXBpLmlzUmVjb3JkZWQoJ2U0ZjFiNWZjJykpIHtcbiAgICAgIGFwaS5jcmVhdGVSZWNvcmQoJ2U0ZjFiNWZjJywgY29tcG9uZW50Lm9wdGlvbnMpXG4gICAgfSBlbHNlIHtcbiAgICAgIGFwaS5yZWxvYWQoJ2U0ZjFiNWZjJywgY29tcG9uZW50Lm9wdGlvbnMpXG4gICAgfVxuICAgIG1vZHVsZS5ob3QuYWNjZXB0KFwiLi9UcmFkaW5ndmlldy52dWU/dnVlJnR5cGU9dGVtcGxhdGUmaWQ9ZTRmMWI1ZmMmXCIsIGZ1bmN0aW9uICgpIHtcbiAgICAgIGFwaS5yZXJlbmRlcignZTRmMWI1ZmMnLCB7XG4gICAgICAgIHJlbmRlcjogcmVuZGVyLFxuICAgICAgICBzdGF0aWNSZW5kZXJGbnM6IHN0YXRpY1JlbmRlckZuc1xuICAgICAgfSlcbiAgICB9KVxuICB9XG59XG5jb21wb25lbnQub3B0aW9ucy5fX2ZpbGUgPSBcInJlc291cmNlcy9zcmMvY29tcG9uZW50cy90cmFkaW5nL1RyYWRpbmd2aWV3LnZ1ZVwiXG5leHBvcnQgZGVmYXVsdCBjb21wb25lbnQuZXhwb3J0cyIsImltcG9ydCBtb2QgZnJvbSBcIi0hLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2JhYmVsLWxvYWRlci9saWIvaW5kZXguanM/P2Nsb25lZFJ1bGVTZXQtNVswXS5ydWxlc1swXS51c2VbMF0hLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL2luZGV4LmpzPz92dWUtbG9hZGVyLW9wdGlvbnMhLi9Cb3RUcmFkZVBhZ2UudnVlP3Z1ZSZ0eXBlPXNjcmlwdCZsYW5nPWpzJlwiOyBleHBvcnQgZGVmYXVsdCBtb2Q7IGV4cG9ydCAqIGZyb20gXCItIS4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9iYWJlbC1sb2FkZXIvbGliL2luZGV4LmpzPz9jbG9uZWRSdWxlU2V0LTVbMF0ucnVsZXNbMF0udXNlWzBdIS4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9pbmRleC5qcz8/dnVlLWxvYWRlci1vcHRpb25zIS4vQm90VHJhZGVQYWdlLnZ1ZT92dWUmdHlwZT1zY3JpcHQmbGFuZz1qcyZcIiIsImltcG9ydCBtb2QgZnJvbSBcIi0hLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2JhYmVsLWxvYWRlci9saWIvaW5kZXguanM/P2Nsb25lZFJ1bGVTZXQtNVswXS5ydWxlc1swXS51c2VbMF0hLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL2luZGV4LmpzPz92dWUtbG9hZGVyLW9wdGlvbnMhLi9UcmFkZXMudnVlP3Z1ZSZ0eXBlPXNjcmlwdCZsYW5nPWpzJlwiOyBleHBvcnQgZGVmYXVsdCBtb2Q7IGV4cG9ydCAqIGZyb20gXCItIS4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9iYWJlbC1sb2FkZXIvbGliL2luZGV4LmpzPz9jbG9uZWRSdWxlU2V0LTVbMF0ucnVsZXNbMF0udXNlWzBdIS4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9pbmRleC5qcz8/dnVlLWxvYWRlci1vcHRpb25zIS4vVHJhZGVzLnZ1ZT92dWUmdHlwZT1zY3JpcHQmbGFuZz1qcyZcIiIsImltcG9ydCBtb2QgZnJvbSBcIi0hLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2JhYmVsLWxvYWRlci9saWIvaW5kZXguanM/P2Nsb25lZFJ1bGVTZXQtNVswXS5ydWxlc1swXS51c2VbMF0hLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL2luZGV4LmpzPz92dWUtbG9hZGVyLW9wdGlvbnMhLi9NYXJrZXRpbmZvLnZ1ZT92dWUmdHlwZT1zY3JpcHQmbGFuZz1qcyZcIjsgZXhwb3J0IGRlZmF1bHQgbW9kOyBleHBvcnQgKiBmcm9tIFwiLSEuLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvYmFiZWwtbG9hZGVyL2xpYi9pbmRleC5qcz8/Y2xvbmVkUnVsZVNldC01WzBdLnJ1bGVzWzBdLnVzZVswXSEuLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvaW5kZXguanM/P3Z1ZS1sb2FkZXItb3B0aW9ucyEuL01hcmtldGluZm8udnVlP3Z1ZSZ0eXBlPXNjcmlwdCZsYW5nPWpzJlwiIiwiaW1wb3J0IG1vZCBmcm9tIFwiLSEuLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvYmFiZWwtbG9hZGVyL2xpYi9pbmRleC5qcz8/Y2xvbmVkUnVsZVNldC01WzBdLnJ1bGVzWzBdLnVzZVswXSEuLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvaW5kZXguanM/P3Z1ZS1sb2FkZXItb3B0aW9ucyEuL01hcmtldHMudnVlP3Z1ZSZ0eXBlPXNjcmlwdCZsYW5nPWpzJlwiOyBleHBvcnQgZGVmYXVsdCBtb2Q7IGV4cG9ydCAqIGZyb20gXCItIS4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9iYWJlbC1sb2FkZXIvbGliL2luZGV4LmpzPz9jbG9uZWRSdWxlU2V0LTVbMF0ucnVsZXNbMF0udXNlWzBdIS4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9pbmRleC5qcz8/dnVlLWxvYWRlci1vcHRpb25zIS4vTWFya2V0cy52dWU/dnVlJnR5cGU9c2NyaXB0Jmxhbmc9anMmXCIiLCJpbXBvcnQgbW9kIGZyb20gXCItIS4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9iYWJlbC1sb2FkZXIvbGliL2luZGV4LmpzPz9jbG9uZWRSdWxlU2V0LTVbMF0ucnVsZXNbMF0udXNlWzBdIS4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9pbmRleC5qcz8/dnVlLWxvYWRlci1vcHRpb25zIS4vT3JkZXJib29rLnZ1ZT92dWUmdHlwZT1zY3JpcHQmbGFuZz1qcyZcIjsgZXhwb3J0IGRlZmF1bHQgbW9kOyBleHBvcnQgKiBmcm9tIFwiLSEuLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvYmFiZWwtbG9hZGVyL2xpYi9pbmRleC5qcz8/Y2xvbmVkUnVsZVNldC01WzBdLnJ1bGVzWzBdLnVzZVswXSEuLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvaW5kZXguanM/P3Z1ZS1sb2FkZXItb3B0aW9ucyEuL09yZGVyYm9vay52dWU/dnVlJnR5cGU9c2NyaXB0Jmxhbmc9anMmXCIiLCJpbXBvcnQgbW9kIGZyb20gXCItIS4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9iYWJlbC1sb2FkZXIvbGliL2luZGV4LmpzPz9jbG9uZWRSdWxlU2V0LTVbMF0ucnVsZXNbMF0udXNlWzBdIS4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9pbmRleC5qcz8/dnVlLWxvYWRlci1vcHRpb25zIS4vVHJhZGluZ3ZpZXcudnVlP3Z1ZSZ0eXBlPXNjcmlwdCZsYW5nPWpzJlwiOyBleHBvcnQgZGVmYXVsdCBtb2Q7IGV4cG9ydCAqIGZyb20gXCItIS4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9iYWJlbC1sb2FkZXIvbGliL2luZGV4LmpzPz9jbG9uZWRSdWxlU2V0LTVbMF0ucnVsZXNbMF0udXNlWzBdIS4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9pbmRleC5qcz8/dnVlLWxvYWRlci1vcHRpb25zIS4vVHJhZGluZ3ZpZXcudnVlP3Z1ZSZ0eXBlPXNjcmlwdCZsYW5nPWpzJlwiIiwiZXhwb3J0ICogZnJvbSBcIi0hLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3N0eWxlLWxvYWRlci9kaXN0L2Nqcy5qcyEuLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvbGFyYXZlbC1taXgvbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvZGlzdC9janMuanM/P2Nsb25lZFJ1bGVTZXQtNzJbMF0ucnVsZXNbMF0udXNlWzFdIS4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9sb2FkZXJzL3N0eWxlUG9zdExvYWRlci5qcyEuLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvbGFyYXZlbC1taXgvbm9kZV9tb2R1bGVzL3Bvc3Rjc3MtbG9hZGVyL2Rpc3QvY2pzLmpzPz9jbG9uZWRSdWxlU2V0LTcyWzBdLnJ1bGVzWzBdLnVzZVsyXSEuLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvc2Fzcy1sb2FkZXIvZGlzdC9janMuanM/P2Nsb25lZFJ1bGVTZXQtNzJbMF0ucnVsZXNbMF0udXNlWzNdIS4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9zYXNzLWxvYWRlci9kaXN0L2Nqcy5qcz8/Y2xvbmVkUnVsZVNldC04MlswXS5ydWxlc1swXS51c2VbMF0hLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL2luZGV4LmpzPz92dWUtbG9hZGVyLW9wdGlvbnMhLi9Cb3RUcmFkZVBhZ2UudnVlP3Z1ZSZ0eXBlPXN0eWxlJmluZGV4PTAmbGFuZz1zY3NzJnNjb3BlPXRydWUmXCIiLCJleHBvcnQgKiBmcm9tIFwiLSEuLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvbG9hZGVycy90ZW1wbGF0ZUxvYWRlci5qcz8/dnVlLWxvYWRlci1vcHRpb25zIS4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9pbmRleC5qcz8/dnVlLWxvYWRlci1vcHRpb25zIS4vQm90VHJhZGVQYWdlLnZ1ZT92dWUmdHlwZT10ZW1wbGF0ZSZpZD0yMmY5OGJjMiZcIiIsImV4cG9ydCAqIGZyb20gXCItIS4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9sb2FkZXJzL3RlbXBsYXRlTG9hZGVyLmpzPz92dWUtbG9hZGVyLW9wdGlvbnMhLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL2luZGV4LmpzPz92dWUtbG9hZGVyLW9wdGlvbnMhLi9UcmFkZXMudnVlP3Z1ZSZ0eXBlPXRlbXBsYXRlJmlkPTBjNzdjNDlkJlwiIiwidmFyIHJlbmRlciA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIF92bSA9IHRoaXNcbiAgdmFyIF9oID0gX3ZtLiRjcmVhdGVFbGVtZW50XG4gIHZhciBfYyA9IF92bS5fc2VsZi5fYyB8fCBfaFxuICByZXR1cm4gX2MoXG4gICAgXCJkaXZcIixcbiAgICB7IHN0YXRpY1N0eWxlOiB7IG1hcmdpbjogXCItMjdweCAtMjdweCAwIC0yN3B4XCIgfSB9LFxuICAgIFtcbiAgICAgIF9jKFxuICAgICAgICBcImdyaWQtbGF5b3V0XCIsXG4gICAgICAgIHtcbiAgICAgICAgICBhdHRyczoge1xuICAgICAgICAgICAgbGF5b3V0OiBfdm0ubGF5b3V0LFxuICAgICAgICAgICAgXCJyZXNwb25zaXZlLWxheW91dHNcIjogX3ZtLmxheW91dHMsXG4gICAgICAgICAgICBcImNvbC1udW1cIjogMTIsXG4gICAgICAgICAgICBcInJvdy1oZWlnaHRcIjogNTAsXG4gICAgICAgICAgICBcImlzLWRyYWdnYWJsZVwiOiBfdm0uZHJhZ2dhYmxlLFxuICAgICAgICAgICAgXCJpcy1yZXNpemFibGVcIjogX3ZtLnJlc2l6YWJsZSxcbiAgICAgICAgICAgIFwidmVydGljYWwtY29tcGFjdFwiOiB0cnVlLFxuICAgICAgICAgICAgXCJ1c2UtY3NzLXRyYW5zZm9ybXNcIjogdHJ1ZSxcbiAgICAgICAgICAgIHJlc3BvbnNpdmU6IF92bS5yZXNwb25zaXZlLFxuICAgICAgICAgIH0sXG4gICAgICAgICAgb246IHtcbiAgICAgICAgICAgIFwidXBkYXRlOmxheW91dFwiOiBmdW5jdGlvbiAoJGV2ZW50KSB7XG4gICAgICAgICAgICAgIF92bS5sYXlvdXQgPSAkZXZlbnRcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgfSxcbiAgICAgICAgfSxcbiAgICAgICAgW1xuICAgICAgICAgIF9jKFxuICAgICAgICAgICAgXCJncmlkLWl0ZW1cIixcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgc3RhdGljQ2xhc3M6IFwiZGFya2VkIHRhYmJhYmxlIHJvdW5kZWQgc2hhZG93XCIsXG4gICAgICAgICAgICAgIHN0YXRpY1N0eWxlOiB7IFwib3ZlcmZsb3cteVwiOiBcImF1dG9cIiwgXCJvdmVyZmxvdy14XCI6IFwiaGlkZGVuXCIgfSxcbiAgICAgICAgICAgICAgYXR0cnM6IHtcbiAgICAgICAgICAgICAgICB4OiBfdm0ubGF5b3V0WzBdLngsXG4gICAgICAgICAgICAgICAgeTogX3ZtLmxheW91dFswXS55LFxuICAgICAgICAgICAgICAgIHc6IF92bS5sYXlvdXRbMF0udyxcbiAgICAgICAgICAgICAgICBoOiBfdm0ubGF5b3V0WzBdLmgsXG4gICAgICAgICAgICAgICAgaTogX3ZtLmxheW91dFswXS5pLFxuICAgICAgICAgICAgICAgIFwiZHJhZy1hbGxvdy1mcm9tXCI6IFwiLnZ1ZS1kcmFnZ2FibGUtaGFuZGxlXCIsXG4gICAgICAgICAgICAgICAgXCJkcmFnLWlnbm9yZS1mcm9tXCI6IFwiLm5vLWRyYWdcIixcbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBbXG4gICAgICAgICAgICAgIF92bS5wYWlycyAhPSBudWxsID8gX3ZtLl9tKDApIDogX3ZtLl9lKCksXG4gICAgICAgICAgICAgIF92bS5fdihcIiBcIiksXG4gICAgICAgICAgICAgIF9jKFwic3BhblwiLCB7IHN0YXRpY0NsYXNzOiBcInZ1ZS1kcmFnZ2FibGUtaGFuZGxlXCIgfSksXG4gICAgICAgICAgICBdLFxuICAgICAgICAgICAgMVxuICAgICAgICAgICksXG4gICAgICAgICAgX3ZtLl92KFwiIFwiKSxcbiAgICAgICAgICBfYyhcbiAgICAgICAgICAgIFwiZ3JpZC1pdGVtXCIsXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIHN0YXRpY0NsYXNzOiBcImRhcmtlZCB0YWJiYWJsZSByb3VuZGVkIHNoYWRvd1wiLFxuICAgICAgICAgICAgICBzdGF0aWNTdHlsZTogeyBcIm92ZXJmbG93LXlcIjogXCJhdXRvXCIsIFwib3ZlcmZsb3cteFwiOiBcImhpZGRlblwiIH0sXG4gICAgICAgICAgICAgIGF0dHJzOiB7XG4gICAgICAgICAgICAgICAgeDogX3ZtLmxheW91dFsxXS54LFxuICAgICAgICAgICAgICAgIHk6IF92bS5sYXlvdXRbMV0ueSxcbiAgICAgICAgICAgICAgICB3OiBfdm0ubGF5b3V0WzFdLncsXG4gICAgICAgICAgICAgICAgaDogX3ZtLmxheW91dFsxXS5oLFxuICAgICAgICAgICAgICAgIGk6IF92bS5sYXlvdXRbMV0uaSxcbiAgICAgICAgICAgICAgICBcImRyYWctYWxsb3ctZnJvbVwiOiBcIi52dWUtZHJhZ2dhYmxlLWhhbmRsZVwiLFxuICAgICAgICAgICAgICAgIFwiZHJhZy1pZ25vcmUtZnJvbVwiOiBcIi5uby1kcmFnXCIsXG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgW1xuICAgICAgICAgICAgICBfdm0uc3ltYm9sICE9IG51bGxcbiAgICAgICAgICAgICAgICA/IF9jKFwiVHJhZGVzXCIsIHtcbiAgICAgICAgICAgICAgICAgICAga2V5OiBfdm0ucnVubmluZ0JvdCxcbiAgICAgICAgICAgICAgICAgICAgYXR0cnM6IHtcbiAgICAgICAgICAgICAgICAgICAgICBzeW1ib2w6IF92bS5zeW1ib2wsXG4gICAgICAgICAgICAgICAgICAgICAgY3VycmVuY3k6IF92bS5jdXJyZW5jeSxcbiAgICAgICAgICAgICAgICAgICAgICBydW5uaW5nQm90OiBfdm0ucnVubmluZ0JvdCxcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgOiBfdm0uX2UoKSxcbiAgICAgICAgICAgICAgX3ZtLl92KFwiIFwiKSxcbiAgICAgICAgICAgICAgX2MoXCJzcGFuXCIsIHsgc3RhdGljQ2xhc3M6IFwidnVlLWRyYWdnYWJsZS1oYW5kbGVcIiB9KSxcbiAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAxXG4gICAgICAgICAgKSxcbiAgICAgICAgICBfdm0uX3YoXCIgXCIpLFxuICAgICAgICAgIF9jKFxuICAgICAgICAgICAgXCJncmlkLWl0ZW1cIixcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgc3RhdGljQ2xhc3M6IFwiZGFya2VkIHJvdW5kZWQgc2hhZG93XCIsXG4gICAgICAgICAgICAgIGF0dHJzOiB7XG4gICAgICAgICAgICAgICAgeDogX3ZtLmxheW91dFsyXS54LFxuICAgICAgICAgICAgICAgIHk6IF92bS5sYXlvdXRbMl0ueSxcbiAgICAgICAgICAgICAgICB3OiBfdm0ubGF5b3V0WzJdLncsXG4gICAgICAgICAgICAgICAgaDogX3ZtLmxheW91dFsyXS5oLFxuICAgICAgICAgICAgICAgIGk6IF92bS5sYXlvdXRbMl0uaSxcbiAgICAgICAgICAgICAgICBcImRyYWctYWxsb3ctZnJvbVwiOiBcIi52dWUtZHJhZ2dhYmxlLWhhbmRsZVwiLFxuICAgICAgICAgICAgICAgIFwiZHJhZy1pZ25vcmUtZnJvbVwiOiBcIi5uby1kcmFnXCIsXG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgW1xuICAgICAgICAgICAgICBfdm0ucHJvdmlkZXIgIT0gbnVsbFxuICAgICAgICAgICAgICAgID8gX2MoXCJNYXJrZXRpbmZvXCIsIHtcbiAgICAgICAgICAgICAgICAgICAgYXR0cnM6IHtcbiAgICAgICAgICAgICAgICAgICAgICBzeW1ib2w6IF92bS5zeW1ib2wsXG4gICAgICAgICAgICAgICAgICAgICAgY3VycmVuY3k6IF92bS5jdXJyZW5jeSxcbiAgICAgICAgICAgICAgICAgICAgICBwcm92aWRlcjogX3ZtLnByb3ZpZGVyLFxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICA6IF92bS5fZSgpLFxuICAgICAgICAgICAgICBfdm0uX3YoXCIgXCIpLFxuICAgICAgICAgICAgICBfYyhcInNwYW5cIiwgeyBzdGF0aWNDbGFzczogXCJ2dWUtZHJhZ2dhYmxlLWhhbmRsZVwiIH0pLFxuICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIDFcbiAgICAgICAgICApLFxuICAgICAgICAgIF92bS5fdihcIiBcIiksXG4gICAgICAgICAgX2MoXG4gICAgICAgICAgICBcImdyaWQtaXRlbVwiLFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICBzdGF0aWNDbGFzczogXCJkYXJrZWQgcm91bmRlZCBzaGFkb3dcIixcbiAgICAgICAgICAgICAgYXR0cnM6IHtcbiAgICAgICAgICAgICAgICB4OiBfdm0ubGF5b3V0WzNdLngsXG4gICAgICAgICAgICAgICAgeTogX3ZtLmxheW91dFszXS55LFxuICAgICAgICAgICAgICAgIHc6IF92bS5sYXlvdXRbM10udyxcbiAgICAgICAgICAgICAgICBoOiBfdm0ubGF5b3V0WzNdLmgsXG4gICAgICAgICAgICAgICAgaTogX3ZtLmxheW91dFszXS5pLFxuICAgICAgICAgICAgICAgIFwiZHJhZy1hbGxvdy1mcm9tXCI6IFwiLnZ1ZS1kcmFnZ2FibGUtaGFuZGxlXCIsXG4gICAgICAgICAgICAgICAgXCJkcmFnLWlnbm9yZS1mcm9tXCI6IFwiLm5vLWRyYWdcIixcbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBbXG4gICAgICAgICAgICAgIF92bS5wcm92aWRlICE9IG51bGxcbiAgICAgICAgICAgICAgICA/IF9jKFwiVHJhZGluZ3ZpZXdcIiwge1xuICAgICAgICAgICAgICAgICAgICBrZXk6IF92bS5zeW1ib2wgKyBfdm0uY3VycmVuY3ksXG4gICAgICAgICAgICAgICAgICAgIGF0dHJzOiB7XG4gICAgICAgICAgICAgICAgICAgICAgc3ltYm9sOiBfdm0uc3ltYm9sLFxuICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbmN5OiBfdm0uY3VycmVuY3ksXG4gICAgICAgICAgICAgICAgICAgICAgcHJvdmlkZTogX3ZtLnByb3ZpZGUsXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIDogX3ZtLl9lKCksXG4gICAgICAgICAgICAgIF92bS5fdihcIiBcIiksXG4gICAgICAgICAgICAgIF9jKFwic3BhblwiLCB7IHN0YXRpY0NsYXNzOiBcInZ1ZS1kcmFnZ2FibGUtaGFuZGxlXCIgfSksXG4gICAgICAgICAgICBdLFxuICAgICAgICAgICAgMVxuICAgICAgICAgICksXG4gICAgICAgICAgX3ZtLl92KFwiIFwiKSxcbiAgICAgICAgICBfYyhcbiAgICAgICAgICAgIFwiZ3JpZC1pdGVtXCIsXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIHN0YXRpY0NsYXNzOiBcImRhcmtlZCByb3VuZGVkIHNoYWRvd1wiLFxuICAgICAgICAgICAgICBhdHRyczoge1xuICAgICAgICAgICAgICAgIHg6IF92bS5sYXlvdXRbNF0ueCxcbiAgICAgICAgICAgICAgICB5OiBfdm0ubGF5b3V0WzRdLnksXG4gICAgICAgICAgICAgICAgdzogX3ZtLmxheW91dFs0XS53LFxuICAgICAgICAgICAgICAgIGg6IF92bS5sYXlvdXRbNF0uaCxcbiAgICAgICAgICAgICAgICBpOiBfdm0ubGF5b3V0WzRdLmksXG4gICAgICAgICAgICAgICAgXCJkcmFnLWFsbG93LWZyb21cIjogXCIudnVlLWRyYWdnYWJsZS1oYW5kbGVcIixcbiAgICAgICAgICAgICAgICBcImRyYWctaWdub3JlLWZyb21cIjogXCIubm8tZHJhZ1wiLFxuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIFtcbiAgICAgICAgICAgICAgX2MoXCJkaXZcIiwgeyBzdGF0aWNDbGFzczogXCJweC0wXCIgfSwgW1xuICAgICAgICAgICAgICAgIF9jKFxuICAgICAgICAgICAgICAgICAgXCJ1bFwiLFxuICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBzdGF0aWNDbGFzczogXCJuYXYgbmF2LXRhYnNcIixcbiAgICAgICAgICAgICAgICAgICAgYXR0cnM6IHsgaWQ6IFwicGlsbHMtdGFiXCIsIHJvbGU6IFwidGFibGlzdFwiIH0sXG4gICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgW1xuICAgICAgICAgICAgICAgICAgICBfYyhcImxpXCIsIHsgc3RhdGljQ2xhc3M6IFwibmF2LWl0ZW1cIiB9LCBbXG4gICAgICAgICAgICAgICAgICAgICAgX2MoXG4gICAgICAgICAgICAgICAgICAgICAgICBcImJ1dHRvblwiLFxuICAgICAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgICBzdGF0aWNDbGFzczogXCJuYXYtbGlua1wiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICBjbGFzczogeyBhY3RpdmU6IF92bS5pc0FjdGl2ZShcInBpbGxzLW1hcmtldFwiKSB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICBhdHRyczogeyBocmVmOiBcIiNwaWxscy1tYXJrZXRcIiB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICBvbjoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNsaWNrOiBmdW5jdGlvbiAoJGV2ZW50KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAkZXZlbnQucHJldmVudERlZmF1bHQoKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF92bS5zZXRBY3RpdmUoXCJwaWxscy1tYXJrZXRcIilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIFtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgX3ZtLl92KFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFJpc2UvRmFsbFxcbiAgICAgICAgICAgICAgICAgICAgICAgIFwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICksXG4gICAgICAgICAgICAgICAgICAgICAgICBdXG4gICAgICAgICAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICAgICAgICAgXSksXG4gICAgICAgICAgICAgICAgICBdXG4gICAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICAgICBfdm0uX3YoXCIgXCIpLFxuICAgICAgICAgICAgICAgIF9jKFxuICAgICAgICAgICAgICAgICAgXCJkaXZcIixcbiAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgc3RhdGljQ2xhc3M6IFwidGFiLWNvbnRlbnRcIixcbiAgICAgICAgICAgICAgICAgICAgYXR0cnM6IHsgaWQ6IFwicGlsbHMtdGFiQ29udGVudFwiIH0sXG4gICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgW1xuICAgICAgICAgICAgICAgICAgICBfYyhcbiAgICAgICAgICAgICAgICAgICAgICBcImRpdlwiLFxuICAgICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXRpY0NsYXNzOiBcInRhYi1wYW5lIGZhZGVcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIGNsYXNzOiB7IFwiYWN0aXZlIHNob3dcIjogX3ZtLmlzQWN0aXZlKFwicGlsbHMtbWFya2V0XCIpIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICBhdHRyczoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICBpZDogXCJwaWxscy1tYXJrZXRcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgcm9sZTogXCJ0YWJwYW5lbFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICBcImFyaWEtbGFiZWxsZWRieVwiOiBcInBpbGxzLW1hcmtldC10YWJcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICBbXG4gICAgICAgICAgICAgICAgICAgICAgICBfYyhcbiAgICAgICAgICAgICAgICAgICAgICAgICAgXCJmb3JtXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhdHRyczogeyBpZDogXCJPcmRlclwiIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb246IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN1Ym1pdDogZnVuY3Rpb24gKCRldmVudCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAkZXZlbnQucHJldmVudERlZmF1bHQoKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gX3ZtLk9yZGVyKClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9jKFwiZGl2XCIsIHsgc3RhdGljQ2xhc3M6IFwicm93IHBiLTEgcHgtMVwiIH0sIFtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9jKFwiZGl2XCIsIHsgc3RhdGljQ2xhc3M6IFwiY29sLTZcIiB9LCBbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9jKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwibGFiZWxcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGF0aWNDbGFzczpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJmb3JtLWxhYmVsIGQtZmxleCBqdXN0aWZ5LWNvbnRlbnQtYmV0d2VlbiB0ZXh0LTEgdGV4dC1kYXJrXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhdHRyczogeyBmb3I6IFwic2VsZWN0Qm90XCIgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFtfYyhcInNwYW5cIiwgW192bS5fdihcIkJvdHNcIildKV1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX3ZtLl92KFwiIFwiKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX2MoXCJkaXZcIiwgeyBrZXk6IF92bS5iYWxhbmNlIH0sIFtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfdm0uYmFsYW5jZSA9PSBudWxsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA/IF9jKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiZm9ybVwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9uOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN1Ym1pdDogZnVuY3Rpb24gKCRldmVudCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICRldmVudC5wcmV2ZW50RGVmYXVsdCgpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF92bS5jcmVhdGVXYWxsZXQoKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9jKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcImJ1dHRvblwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhdGljQ2xhc3M6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcImJ0biBidG4tc3VjY2VzcyB3LTEwMFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGF0dHJzOiB7IHR5cGU6IFwic3VibWl0XCIgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF92bS5fdihcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgQ3JlYXRlIFdhbGxldFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBdXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgOiBfYyhcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcImJ1dHRvblwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlZjogXCJzZWxlY3RCb3RcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXRpY0NsYXNzOiBcInctMTAwIGJ0biBidG4tcHJpbWFyeVwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXR0cnM6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogXCJidXR0b25cIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJkYXRhLWJzLXRvZ2dsZVwiOiBcIm1vZGFsXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiZGF0YS1icy10YXJnZXRcIjogXCIjYm90VHlwZU1vZGFsXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX3ZtLl92KFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgU2VsZWN0IEJvdFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBdXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF0pLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfdm0uX3YoXCIgXCIpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfYyhcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcImxhYmVsXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhdGljQ2xhc3M6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiZm9ybS1sYWJlbCBtdC0xIGQtZmxleCBqdXN0aWZ5LWNvbnRlbnQtYmV0d2VlbiB0ZXh0LTEgdGV4dC1kYXJrXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhdHRyczogeyBmb3I6IFwiYm90VGltZWRcIiB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgW19jKFwic3BhblwiLCBbX3ZtLl92KFwiRHVyYXRpb25cIildKV1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX3ZtLl92KFwiIFwiKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX3ZtLmJvdF90aW1lcyAhPSBudWxsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPyBfYyhcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJkaXZcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGtleTogX3ZtLmJvdF90aW1lcyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGF0aWNDbGFzczogXCJkcm9wZG93blwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX2MoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcImJ1dHRvblwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWY6IFwiYm90VGltZWRcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhdGljQ2xhc3M6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJ3LTEwMCBidG4gYnRuLW91dGxpbmUtd2FybmluZyBkcm9wZG93bi10b2dnbGVcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXR0cnM6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBcImJ1dHRvblwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiZGF0YS1icy10b2dnbGVcIjogXCJkcm9wZG93blwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiYXJpYS1leHBhbmRlZFwiOiBcImZhbHNlXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmFtZTogXCJib3RUaW1lZFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX3ZtLl92KFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBEdXJhdGlvblxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX3ZtLl92KFwiIFwiKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfYyhcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwidWxcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhdGljQ2xhc3M6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJkcm9wZG93bi1tZW51IGRyb3Bkb3duLW1lbnUtZW5kXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX3ZtLl9sKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfdm0uYm90X3RpbWVzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbiAodGltaW5nLCBpbmRleCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBfYyhcImxpXCIsIHsga2V5OiBpbmRleCB9LCBbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfYyhcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJhXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGF0aWNDbGFzczpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiZHJvcGRvd24taXRlbVwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9uOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjbGljazogZnVuY3Rpb24gKCRldmVudCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gX3ZtLnNldFRpbWluZyhcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aW1pbmcuZHVyYXRpb24sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGltaW5nLnR5cGVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX3ZtLl92KFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX3ZtLl9zKHRpbWluZy5kdXJhdGlvbikgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIiArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF92bS5fcyh0aW1pbmcudHlwZSkgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcInNcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBdXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgOiBfdm0uX2UoKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX3ZtLl92KFwiIFwiKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX2MoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJidXR0b25cIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGF0aWNDbGFzczpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJ3LTEwMCBtdC0xIGJ0biBidG4tc3VjY2VzcyBtdC0xIGQtZmxleCBhbGlnbi1pdGVtcy1jZW50ZXIganVzdGlmeS1jb250ZW50LWJldHdlZW5cIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGF0dHJzOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IFwic3VibWl0XCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRpc2FibGVkOiBfdm0ubG9hZGluZyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfYyhcImlcIiwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGF0aWNDbGFzczpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcImJpIGJpLWJhdHRlcnktY2hhcmdpbmcgZnMtM1wiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfYyhcInNwYW5cIiwgW192bS5fdihcIiBTdGFydCBCb3RcIildKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBdXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBdKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF92bS5fdihcIiBcIiksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfYyhcImRpdlwiLCB7IHN0YXRpY0NsYXNzOiBcImNvbC02XCIgfSwgW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfYyhcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcImxhYmVsXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhdGljQ2xhc3M6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiZm9ybS1sYWJlbCBkLWZsZXgganVzdGlmeS1jb250ZW50LWJldHdlZW4gdGV4dC0xIHRleHQtZGFya1wiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXR0cnM6IHsgZm9yOiBcIkFtb3VudFwiIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBbX2MoXCJzcGFuXCIsIFtfdm0uX3YoXCJBbW91bnRcIildKV1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX3ZtLl92KFwiIFwiKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX2MoXCJkaXZcIiwgeyBzdGF0aWNDbGFzczogXCJpbnB1dC1ncm91cCBtYi0xXCIgfSwgW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9jKFwiaW5wdXRcIiwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGlyZWN0aXZlczogW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmFtZTogXCJtb2RlbFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJhd05hbWU6IFwidi1tb2RlbFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiBfdm0uYW1vdW50LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV4cHJlc3Npb246IFwiYW1vdW50XCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhdGljQ2xhc3M6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiZm9ybS1jb250cm9sIHRleHQtZGFyayBib3JkZXItMFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXR0cnM6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogXCJudW1iZXJcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWluOiBfdm0ubWluX2Ftb3VudCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWF4OiBfdm0ubWF4X2Ftb3VudCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RlcDogX3ZtLm1pbl9hbW91bnQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlcXVpcmVkOiBcIlwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwbGFjZWhvbGRlcjogXCJBbW91bnRcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJhcmlhLWxhYmVsXCI6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJBbW91bnQgKHRvIHRoZSBuZWFyZXN0IGRvbGxhcilcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkb21Qcm9wczogeyB2YWx1ZTogX3ZtLmFtb3VudCB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb246IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5wdXQ6IGZ1bmN0aW9uICgkZXZlbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoJGV2ZW50LnRhcmdldC5jb21wb3NpbmcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVyblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfdm0uYW1vdW50ID0gJGV2ZW50LnRhcmdldC52YWx1ZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfdm0uX3YoXCIgXCIpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9jKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJzcGFuXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXRpY0NsYXNzOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiaW5wdXQtZ3JvdXAtdGV4dCB0ZXh0LWRhcmsgYm9yZGVyLTBcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBbX3ZtLl92KF92bS5fcyhfdm0uY3VycmVuY3kpKV1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBdKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF0pLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF0pLFxuICAgICAgICAgICAgICAgICAgICAgICAgICBdXG4gICAgICAgICAgICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgICAgICAgICAgIF1cbiAgICAgICAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICAgICAgIF1cbiAgICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgICBdKSxcbiAgICAgICAgICAgICAgX3ZtLl92KFwiIFwiKSxcbiAgICAgICAgICAgICAgX2MoXCJzcGFuXCIsIHsgc3RhdGljQ2xhc3M6IFwidnVlLWRyYWdnYWJsZS1oYW5kbGVcIiB9KSxcbiAgICAgICAgICAgIF1cbiAgICAgICAgICApLFxuICAgICAgICAgIF92bS5fdihcIiBcIiksXG4gICAgICAgICAgX2MoXG4gICAgICAgICAgICBcImdyaWQtaXRlbVwiLFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICBzdGF0aWNDbGFzczogXCJkYXJrZWQgcm91bmRlZCBzaGFkb3dcIixcbiAgICAgICAgICAgICAgYXR0cnM6IHtcbiAgICAgICAgICAgICAgICB4OiBfdm0ubGF5b3V0WzVdLngsXG4gICAgICAgICAgICAgICAgeTogX3ZtLmxheW91dFs1XS55LFxuICAgICAgICAgICAgICAgIHc6IF92bS5sYXlvdXRbNV0udyxcbiAgICAgICAgICAgICAgICBoOiBfdm0ubGF5b3V0WzVdLmgsXG4gICAgICAgICAgICAgICAgaTogX3ZtLmxheW91dFs1XS5pLFxuICAgICAgICAgICAgICAgIFwiZHJhZy1hbGxvdy1mcm9tXCI6IFwiLnZ1ZS1kcmFnZ2FibGUtaGFuZGxlXCIsXG4gICAgICAgICAgICAgICAgXCJkcmFnLWlnbm9yZS1mcm9tXCI6IFwiLm5vLWRyYWdcIixcbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBbXG4gICAgICAgICAgICAgIF92bS5zeW1ib2wgIT0gbnVsbFxuICAgICAgICAgICAgICAgID8gX2MoXCJPcmRlcmJvb2tcIiwge1xuICAgICAgICAgICAgICAgICAgICBhdHRyczogeyBzeW1ib2w6IF92bS5zeW1ib2wsIGN1cnJlbmN5OiBfdm0uY3VycmVuY3kgfSxcbiAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgOiBfdm0uX2UoKSxcbiAgICAgICAgICAgICAgX3ZtLl92KFwiIFwiKSxcbiAgICAgICAgICAgICAgX2MoXCJzcGFuXCIsIHsgc3RhdGljQ2xhc3M6IFwidnVlLWRyYWdnYWJsZS1oYW5kbGVcIiB9KSxcbiAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAxXG4gICAgICAgICAgKSxcbiAgICAgICAgXSxcbiAgICAgICAgMVxuICAgICAgKSxcbiAgICAgIF92bS5fdihcIiBcIiksXG4gICAgICBfYyhcbiAgICAgICAgXCJkaXZcIixcbiAgICAgICAge1xuICAgICAgICAgIHN0YXRpY0NsYXNzOiBcIm1vZGFsIGZhZGVcIixcbiAgICAgICAgICBhdHRyczoge1xuICAgICAgICAgICAgaWQ6IFwiYm90VHlwZU1vZGFsXCIsXG4gICAgICAgICAgICB0YWJpbmRleDogXCItMVwiLFxuICAgICAgICAgICAgXCJhcmlhLWxhYmVsbGVkYnlcIjogXCJib3RUeXBlXCIsXG4gICAgICAgICAgICBcImFyaWEtaGlkZGVuXCI6IFwidHJ1ZVwiLFxuICAgICAgICAgIH0sXG4gICAgICAgIH0sXG4gICAgICAgIFtcbiAgICAgICAgICBfYyhcbiAgICAgICAgICAgIFwiZGl2XCIsXG4gICAgICAgICAgICB7IHN0YXRpY0NsYXNzOiBcIm1vZGFsLWRpYWxvZyBtb2RhbC1kaWFsb2ctY2VudGVyZWQgbW9kYWwtbGdcIiB9LFxuICAgICAgICAgICAgW1xuICAgICAgICAgICAgICBfYyhcImRpdlwiLCB7IHN0YXRpY0NsYXNzOiBcIm1vZGFsLWNvbnRlbnRcIiB9LCBbXG4gICAgICAgICAgICAgICAgX3ZtLl9tKDEpLFxuICAgICAgICAgICAgICAgIF92bS5fdihcIiBcIiksXG4gICAgICAgICAgICAgICAgX2MoXG4gICAgICAgICAgICAgICAgICBcImRpdlwiLFxuICAgICAgICAgICAgICAgICAgeyBzdGF0aWNDbGFzczogXCJtb2RhbC1ib2R5IHBiLTMgcHgtc20tM1wiIH0sXG4gICAgICAgICAgICAgICAgICBfdm0uX2woX3ZtLmJvdF90eXBlLCBmdW5jdGlvbiAoYm90LCBpbmRleCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gX2MoXG4gICAgICAgICAgICAgICAgICAgICAgXCJkaXZcIixcbiAgICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICBrZXk6IGluZGV4LFxuICAgICAgICAgICAgICAgICAgICAgICAgc3RhdGljU3R5bGU6IHt9LFxuICAgICAgICAgICAgICAgICAgICAgICAgb246IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgY2xpY2s6IGZ1bmN0aW9uICgkZXZlbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gX3ZtLnNldEJvdChib3QpXG4gICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgW1xuICAgICAgICAgICAgICAgICAgICAgICAgX2MoXG4gICAgICAgICAgICAgICAgICAgICAgICAgIFwiZGl2XCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGF0aWNDbGFzczogXCJyb3cgYmctd2FsbGV0IHAtMSByb3VuZGVkIG1iLTFcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjbGFzczogYm90LmlkID09IDEgPyBcImJnLXdhbGxldC1hY3RpdmVcIiA6IFwiXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgIFtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfYyhcImRpdlwiLCB7IHN0YXRpY0NsYXNzOiBcImNvbC0zXCIgfSwgW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX2MoXCJpbWdcIiwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhdHRyczoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNyYzogXCJhc3NldHMvaW1hZ2VzL2JvdC9cIiArIGJvdC5pbWFnZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF0pLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF92bS5fdihcIiBcIiksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX2MoXCJkaXZcIiwgeyBzdGF0aWNDbGFzczogXCJjb2wtOVwiIH0sIFtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9jKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcImRpdlwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhdGljQ2xhc3M6IFwiZC1mbGV4IGp1c3RpZnktY29udGVudC1iZXR3ZWVuXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfYyhcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiZGl2XCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7IHN0YXRpY0NsYXNzOiBcImZ3LWJvbGQgZnMtNCB0ZXh0LXdoaXRlXCIgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX3ZtLl92KFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF92bS5fcyhib3QudGl0bGUpICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJvdC5pc19uZXcgPT0gMVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID8gX2MoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwic3BhblwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhdGljQ2xhc3M6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcImZzLTYgYmFkZ2UgYmctc3VjY2VzcyB0ZXh0LXdoaXRlXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFtfdm0uX3YoXCJOZXdcIildXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgOiBfdm0uX2UoKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF92bS5fdihcIiBcIiksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX2MoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcImRpdlwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGF0aWNDbGFzczpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcImZzLTYgdGV4dC13aGl0ZSBkLW5vbmUgZC1tZC1ibG9ja1wiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX2MoXCJpXCIsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGF0aWNDbGFzczogXCJiaSBiaS1hcHAtaW5kaWNhdG9yXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfdm0uX3YoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCIgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX3ZtLl9zKGJvdC5mYWtlKSArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBdXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF92bS5fdihcIiBcIiksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfYyhcImRpdlwiLCB7IHN0YXRpY0NsYXNzOiBcInJvd1wiIH0sIFtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX2MoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJzbWFsbFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHsgc3RhdGljQ2xhc3M6IFwiZnMtNiB0ZXh0LXdhcm5pbmdcIiB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFtfdm0uX3YoX3ZtLl9zKGJvdC5kZXNjKSldXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF92bS5fdihcIiBcIiksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9jKFwiZGl2XCIsIFtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfdm0uX3YoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBIaWdoZXN0IEFQUiBUb2RheTpcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9jKFwic3BhblwiLCB7IHN0YXRpY0NsYXNzOiBcInRleHQtc3VjY2Vzc1wiIH0sIFtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF92bS5fdihfdm0uX3MoYm90LnBlcmMpICsgXCIlXCIpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF0pLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBdKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF0pLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF0pLFxuICAgICAgICAgICAgICAgICAgICAgICAgICBdXG4gICAgICAgICAgICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgICAgICAgICAgIF1cbiAgICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgICAgICAwXG4gICAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICAgXSksXG4gICAgICAgICAgICBdXG4gICAgICAgICAgKSxcbiAgICAgICAgXVxuICAgICAgKSxcbiAgICBdLFxuICAgIDFcbiAgKVxufVxudmFyIHN0YXRpY1JlbmRlckZucyA9IFtcbiAgZnVuY3Rpb24gKCkge1xuICAgIHZhciBfdm0gPSB0aGlzXG4gICAgdmFyIF9oID0gX3ZtLiRjcmVhdGVFbGVtZW50XG4gICAgdmFyIF9jID0gX3ZtLl9zZWxmLl9jIHx8IF9oXG4gICAgcmV0dXJuIF9jKFwiTWFya2V0c1wiLCB7XG4gICAgICBhdHRyczogeyBwYWlyczogX3ZtLnBhaXJzLCB0eXBlOiBfdm0udHlwZSwgcHJvdmlkZXI6IF92bS5wcm92aWRlciB9LFxuICAgIH0pXG4gIH0sXG4gIGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgX3ZtID0gdGhpc1xuICAgIHZhciBfaCA9IF92bS4kY3JlYXRlRWxlbWVudFxuICAgIHZhciBfYyA9IF92bS5fc2VsZi5fYyB8fCBfaFxuICAgIHJldHVybiBfYyhcImRpdlwiLCB7IHN0YXRpY0NsYXNzOiBcIm1vZGFsLWhlYWRlciBiZy10cmFuc3BhcmVudFwiIH0sIFtcbiAgICAgIF9jKFwiYnV0dG9uXCIsIHtcbiAgICAgICAgc3RhdGljQ2xhc3M6IFwiYnRuLWNsb3NlXCIsXG4gICAgICAgIGF0dHJzOiB7XG4gICAgICAgICAgdHlwZTogXCJidXR0b25cIixcbiAgICAgICAgICBcImRhdGEtYnMtZGlzbWlzc1wiOiBcIm1vZGFsXCIsXG4gICAgICAgICAgXCJhcmlhLWxhYmVsXCI6IFwiQ2xvc2VcIixcbiAgICAgICAgfSxcbiAgICAgIH0pLFxuICAgIF0pXG4gIH0sXG5dXG5yZW5kZXIuX3dpdGhTdHJpcHBlZCA9IHRydWVcblxuZXhwb3J0IHsgcmVuZGVyLCBzdGF0aWNSZW5kZXJGbnMgfSIsInZhciByZW5kZXIgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBfdm0gPSB0aGlzXG4gIHZhciBfaCA9IF92bS4kY3JlYXRlRWxlbWVudFxuICB2YXIgX2MgPSBfdm0uX3NlbGYuX2MgfHwgX2hcbiAgcmV0dXJuIF9jKFxuICAgIFwiZGl2XCIsXG4gICAgW1xuICAgICAgX3ZtLnJ1bm5pbmdCb3QgIT0gbnVsbFxuICAgICAgICA/IF9jKFxuICAgICAgICAgICAgXCJyb3V0ZXItbGlua1wiLFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICBhdHRyczoge1xuICAgICAgICAgICAgICAgIHRvOiBcIi9ib3RcIixcbiAgICAgICAgICAgICAgICBcImRhdGEtYnMtdG9nZ2xlXCI6IFwidG9vbHRpcFwiLFxuICAgICAgICAgICAgICAgIFwiZGF0YS1icy1wbGFjZW1lbnRcIjogXCJ0b3BcIixcbiAgICAgICAgICAgICAgICB0aXRsZTogXCJWaWV3IENvbnRyYWN0XCIsXG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgW1xuICAgICAgICAgICAgICBfYyhcbiAgICAgICAgICAgICAgICBcImRpdlwiLFxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgIHN0YXRpY0NsYXNzOiBcInAtMVwiLFxuICAgICAgICAgICAgICAgICAgc3RhdGljU3R5bGU6IHsgXCJtYXgtd2lkdGhcIjogXCIyODBweFwiLCBtYXJnaW46IFwiYXV0b1wiIH0sXG4gICAgICAgICAgICAgICAgICBhdHRyczogeyBpZDogXCJzcGVlZHRlc3RcIiB9LFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgW1xuICAgICAgICAgICAgICAgICAgX2MoXG4gICAgICAgICAgICAgICAgICAgIFwic3ZnXCIsXG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICBzdGF0aWNTdHlsZTogeyBcImVuYWJsZS1iYWNrZ3JvdW5kXCI6IFwibmV3IDAgMCAxMDAgMTAwXCIgfSxcbiAgICAgICAgICAgICAgICAgICAgICBhdHRyczoge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWQ6IFwiZ2F1Z2VcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIHZlcnNpb246IFwiMS4xXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICB4bWxuczogXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiLFxuICAgICAgICAgICAgICAgICAgICAgICAgXCJ4bWxuczp4bGlua1wiOiBcImh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmtcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIHg6IFwiMHB4XCIsXG4gICAgICAgICAgICAgICAgICAgICAgICB5OiBcIjBweFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgdmlld0JveDogXCIwIDAgMTAwIDEwMFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgXCJ4bWw6c3BhY2VcIjogXCJwcmVzZXJ2ZVwiLFxuICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIFtcbiAgICAgICAgICAgICAgICAgICAgICBfYyhcInBhdGhcIiwge1xuICAgICAgICAgICAgICAgICAgICAgICAgc3RhdGljU3R5bGU6IHsgZmlsbDogXCIjZTMxMjEyXCIgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGF0dHJzOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIGQ6IFwiTTEyLjksNzUuNWMwLjMsMC41LDAuNywwLjksMSwxLjRsNy42LTUuN2MtMC4zLTAuNC0wLjUtMC43LTAuOC0xLjFMMTIuOSw3NS41elwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgICAgICAgICBfdm0uX3YoXCIgXCIpLFxuICAgICAgICAgICAgICAgICAgICAgIF9jKFwicGF0aFwiLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdGF0aWNTdHlsZTogeyBmaWxsOiBcIiNlYTFmMzlcIiwgZGlzcGxheTogXCJub25lXCIgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGF0dHJzOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIGQ6IFwiTTkuMyw2OS4zYzAuMywwLjUsMC41LDEsMC44LDEuNWw4LjQtNC40Yy0wLjItMC40LTAuNC0wLjgtMC42LTEuMkw5LjMsNjkuM3pcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgICAgICAgICAgX3ZtLl92KFwiIFwiKSxcbiAgICAgICAgICAgICAgICAgICAgICBfYyhcInBhdGhcIiwge1xuICAgICAgICAgICAgICAgICAgICAgICAgc3RhdGljU3R5bGU6IHsgZmlsbDogXCIjZjEyZDYwXCIsIGRpc3BsYXk6IFwibm9uZVwiIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICBhdHRyczoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICBkOiBcIk02LjcsNjIuNEM2LjksNjIuOSw3LDYzLjUsNy4yLDY0bDkuMS0zYy0wLjEtMC40LTAuMy0wLjgtMC40LTEuMkw2LjcsNjIuNHpcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgICAgICAgICAgX3ZtLl92KFwiIFwiKSxcbiAgICAgICAgICAgICAgICAgICAgICBfYyhcInBhdGhcIiwge1xuICAgICAgICAgICAgICAgICAgICAgICAgc3RhdGljU3R5bGU6IHsgZmlsbDogXCIjZjgzYzg1XCIsIGRpc3BsYXk6IFwibm9uZVwiIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICBhdHRyczoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICBkOiBcIk01LjMsNTUuMmMwLDAuNiwwLjEsMS4xLDAuMiwxLjdsOS40LTEuNWMtMC4xLTAuNC0wLjEtMC45LTAuMi0xLjNMNS4zLDU1LjJ6XCIsXG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAgICAgICAgIF92bS5fdihcIiBcIiksXG4gICAgICAgICAgICAgICAgICAgICAgX2MoXCJwYXRoXCIsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXRpY1N0eWxlOiB7IGZpbGw6IFwiI2ZmNGJhOFwiLCBkaXNwbGF5OiBcIm5vbmVcIiB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgYXR0cnM6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgZDogXCJNNSw0Ny45YzAsMC42LDAsMS4xLDAsMS43bDkuNSwwLjFjMC0wLjUsMC0wLjksMC0xLjRMNSw0Ny45elwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgICAgICAgICBfdm0uX3YoXCIgXCIpLFxuICAgICAgICAgICAgICAgICAgICAgIF9jKFwicGF0aFwiLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdGF0aWNTdHlsZTogeyBmaWxsOiBcIiNmYjNlYjJcIiwgZGlzcGxheTogXCJub25lXCIgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGF0dHJzOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIGQ6IFwiTTUuOSw0MC43Yy0wLjEsMC42LTAuMiwxLjEtMC4zLDEuN0wxNSw0NGMwLjEtMC40LDAuMi0wLjksMC4yLTEuM0w1LjksNDAuN3pcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgICAgICAgICAgX3ZtLl92KFwiIFwiKSxcbiAgICAgICAgICAgICAgICAgICAgICBfYyhcInBhdGhcIiwge1xuICAgICAgICAgICAgICAgICAgICAgICAgc3RhdGljU3R5bGU6IHsgZmlsbDogXCIjZjczMmJmXCIsIGRpc3BsYXk6IFwibm9uZVwiIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICBhdHRyczoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICBkOiBcIk04LDMzLjdjLTAuMiwwLjUtMC40LDEuMS0wLjYsMS42bDksMy4xYzAuMS0wLjQsMC4zLTAuOSwwLjUtMS4zTDgsMzMuN3pcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgICAgICAgICAgX3ZtLl92KFwiIFwiKSxcbiAgICAgICAgICAgICAgICAgICAgICBfYyhcInBhdGhcIiwge1xuICAgICAgICAgICAgICAgICAgICAgICAgc3RhdGljU3R5bGU6IHsgZmlsbDogXCIjZjIyNmNkXCIsIGRpc3BsYXk6IFwibm9uZVwiIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICBhdHRyczoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICBkOiBcIk0xMS4yLDI3LjFjLTAuMywwLjUtMC41LDEtMC44LDEuNWw4LjMsNC42YzAuMi0wLjQsMC40LTAuOCwwLjctMS4yTDExLjIsMjcuMXpcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgICAgICAgICAgX3ZtLl92KFwiIFwiKSxcbiAgICAgICAgICAgICAgICAgICAgICBfYyhcInBhdGhcIiwge1xuICAgICAgICAgICAgICAgICAgICAgICAgc3RhdGljU3R5bGU6IHsgZmlsbDogXCIjZWUxYWRjXCIsIGRpc3BsYXk6IFwibm9uZVwiIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICBhdHRyczoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICBkOiBcIk0xNS41LDIxLjJjLTAuNCwwLjQtMC44LDAuOS0xLjEsMS4zbDcuNSw1LjhjMC4zLTAuNCwwLjYtMC43LDAuOS0xLjFMMTUuNSwyMS4yelwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgICAgICAgICBfdm0uX3YoXCIgXCIpLFxuICAgICAgICAgICAgICAgICAgICAgIF9jKFwicGF0aFwiLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdGF0aWNTdHlsZTogeyBmaWxsOiBcIiNhZTE5ZGVcIiwgZGlzcGxheTogXCJub25lXCIgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGF0dHJzOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIGQ6IFwiTTIwLjYsMTZjLTAuNSwwLjMtMC45LDAuNy0xLjMsMS4xbDYuNSw3YzAuMy0wLjMsMC42LTAuNiwxLTAuOUwyMC42LDE2elwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgICAgICAgICBfdm0uX3YoXCIgXCIpLFxuICAgICAgICAgICAgICAgICAgICAgIF9jKFwicGF0aFwiLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdGF0aWNTdHlsZTogeyBmaWxsOiBcIiM2NjE4Y2RcIiwgZGlzcGxheTogXCJub25lXCIgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGF0dHJzOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIGQ6IFwiTTI2LjQsMTEuN2MtMC41LDAuMy0wLjksMC42LTEuNCwwLjlsNS4zLDcuOWMwLjMtMC4yLDAuNy0wLjUsMS0wLjdMMjYuNCwxMS43elwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgICAgICAgICBfdm0uX3YoXCIgXCIpLFxuICAgICAgICAgICAgICAgICAgICAgIF9jKFwicGF0aFwiLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdGF0aWNTdHlsZTogeyBmaWxsOiBcIiMyNzE2YmRcIiwgZGlzcGxheTogXCJub25lXCIgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGF0dHJzOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIGQ6IFwiTTMzLDguM2MtMC42LDAuMi0xLjEsMC41LTEuNiwwLjdsMy45LDguN2MwLjQtMC4yLDAuOS0wLjQsMS4zLTAuNkwzMyw4LjN6XCIsXG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAgICAgICAgIF92bS5fdihcIiBcIiksXG4gICAgICAgICAgICAgICAgICAgICAgX2MoXCJwYXRoXCIsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXRpY1N0eWxlOiB7IGZpbGw6IFwiIzE1MzdhY1wiLCBkaXNwbGF5OiBcIm5vbmVcIiB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgYXR0cnM6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgZDogXCJNMzkuOSw2LjFjLTAuNSwwLjEtMS4xLDAuMy0xLjYsMC40bDIuNSw5LjJjMC40LTAuMSwwLjgtMC4yLDEuMi0wLjNMMzkuOSw2LjF6XCIsXG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAgICAgICAgIF92bS5fdihcIiBcIiksXG4gICAgICAgICAgICAgICAgICAgICAgX2MoXCJwYXRoXCIsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXRpY1N0eWxlOiB7IGZpbGw6IFwiIzIwNjFjMVwiLCBkaXNwbGF5OiBcIm5vbmVcIiB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgYXR0cnM6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgZDogXCJNNDcuMiw1LjJjLTAuNiwwLTEuMSwwLTEuNywwLjFsMC45LDkuNGMwLjQsMCwwLjktMC4xLDEuMy0wLjFMNDcuMiw1LjJ6XCIsXG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAgICAgICAgIF92bS5fdihcIiBcIiksXG4gICAgICAgICAgICAgICAgICAgICAgX2MoXCJwYXRoXCIsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXRpY1N0eWxlOiB7IGZpbGw6IFwiIzJjOTBkNVwiLCBkaXNwbGF5OiBcIm5vbmVcIiB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgYXR0cnM6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgZDogXCJNNTQuNSw1LjJjLTAuNiwwLTEuMS0wLjEtMS43LTAuMWwtMC42LDkuNWMwLjQsMCwwLjksMC4xLDEuMywwLjFMNTQuNSw1LjJ6XCIsXG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAgICAgICAgIF92bS5fdihcIiBcIiksXG4gICAgICAgICAgICAgICAgICAgICAgX2MoXCJwYXRoXCIsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXRpY1N0eWxlOiB7IGZpbGw6IFwiIzNiYzJlYVwiLCBkaXNwbGF5OiBcIm5vbmVcIiB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgYXR0cnM6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgZDogXCJNNjEuNiw2LjVjLTAuNS0wLjEtMS4xLTAuMy0xLjYtMC40bC0yLjIsOS4zYzAuNCwwLjEsMC45LDAuMiwxLjMsMC4zTDYxLjYsNi41elwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgICAgICAgICBfdm0uX3YoXCIgXCIpLFxuICAgICAgICAgICAgICAgICAgICAgIF9jKFwicGF0aFwiLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdGF0aWNTdHlsZTogeyBmaWxsOiBcIiM0YmY3ZmZcIiwgZGlzcGxheTogXCJub25lXCIgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGF0dHJzOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIGQ6IFwiTTY4LjYsOUM2OCw4LjcsNjcuNSw4LjUsNjcsOC4zbC0zLjYsOC44YzAuNCwwLjIsMC44LDAuMywxLjIsMC41TDY4LjYsOXpcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgICAgICAgICAgX3ZtLl92KFwiIFwiKSxcbiAgICAgICAgICAgICAgICAgICAgICBfYyhcInBhdGhcIiwge1xuICAgICAgICAgICAgICAgICAgICAgICAgc3RhdGljU3R5bGU6IHsgZmlsbDogXCIjMzlmNmQyXCIsIGRpc3BsYXk6IFwibm9uZVwiIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICBhdHRyczoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICBkOiBcIk03NC45LDEyLjVjLTAuNC0wLjMtMC45LTAuNi0xLjQtMC45bC01LDguMWMwLjQsMC4yLDAuNywwLjUsMS4xLDAuN0w3NC45LDEyLjV6XCIsXG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAgICAgICAgIF92bS5fdihcIiBcIiksXG4gICAgICAgICAgICAgICAgICAgICAgX2MoXCJwYXRoXCIsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXRpY1N0eWxlOiB7IGZpbGw6IFwiIzI4ZWQ5OVwiLCBkaXNwbGF5OiBcIm5vbmVcIiB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgYXR0cnM6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgZDogXCJNODAuNiwxN2MtMC41LTAuNC0wLjktMC43LTEuMy0xLjFsLTYuMiw3LjJjMC4zLDAuMywwLjcsMC42LDEsMC45TDgwLjYsMTd6XCIsXG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAgICAgICAgIF92bS5fdihcIiBcIiksXG4gICAgICAgICAgICAgICAgICAgICAgX2MoXCJwYXRoXCIsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXRpY1N0eWxlOiB7IGZpbGw6IFwiIzE5ZTU1ZFwiLCBkaXNwbGF5OiBcIm5vbmVcIiB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgYXR0cnM6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgZDogXCJNODUuNywyMi40Yy0wLjQtMC40LTAuNy0wLjktMS4xLTEuM2wtNy40LDYuMWMwLjMsMC4zLDAuNSwwLjcsMC44LDFMODUuNywyMi40elwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgICAgICAgICBfdm0uX3YoXCIgXCIpLFxuICAgICAgICAgICAgICAgICAgICAgIF9jKFwicGF0aFwiLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdGF0aWNTdHlsZTogeyBmaWxsOiBcIiMwYWRjMWVcIiwgZGlzcGxheTogXCJub25lXCIgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGF0dHJzOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIGQ6IFwiTTg5LjYsMjguNmMtMC4yLTAuNS0wLjUtMS0wLjgtMS41TDgwLjYsMzJjMC4yLDAuNCwwLjQsMC43LDAuNiwxLjFMODkuNiwyOC42elwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgICAgICAgICBfdm0uX3YoXCIgXCIpLFxuICAgICAgICAgICAgICAgICAgICAgIF9jKFwicGF0aFwiLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdGF0aWNTdHlsZTogeyBmaWxsOiBcIiMwYWRjMWVcIiwgZGlzcGxheTogXCJub25lXCIgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGF0dHJzOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIGQ6IFwiTTkyLjUsMzUuM2MtMC4yLTAuNS0wLjQtMS4xLTAuNi0xLjZsLTguOCwzLjRjMC4yLDAuNCwwLjMsMC44LDAuNSwxLjJMOTIuNSwzNS4zelwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgICAgICAgICBfdm0uX3YoXCIgXCIpLFxuICAgICAgICAgICAgICAgICAgICAgIF9jKFwicGF0aFwiLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdGF0aWNTdHlsZTogeyBmaWxsOiBcIiMwYWRjMWVcIiwgZGlzcGxheTogXCJub25lXCIgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGF0dHJzOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIGQ6IFwiTTk0LjQsNDIuMmMtMC4xLTAuNS0wLjItMS4xLTAuMy0xLjZsLTkuNCwyYzAuMSwwLjQsMC4yLDAuOSwwLjIsMS4zTDk0LjQsNDIuMnpcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgICAgICAgICAgX3ZtLl92KFwiIFwiKSxcbiAgICAgICAgICAgICAgICAgICAgICBfYyhcInBhdGhcIiwge1xuICAgICAgICAgICAgICAgICAgICAgICAgc3RhdGljU3R5bGU6IHsgZmlsbDogXCIjMGFkYzFlXCIsIGRpc3BsYXk6IFwibm9uZVwiIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICBhdHRyczoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICBkOiBcIk05NSw0Ny44bC05LjUsMC41YzAsMC40LDAsMC45LDAsMS4zbDkuNS0wLjFDOTUsNDguOSw5NSw0OC40LDk1LDQ3Ljh6XCIsXG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAgICAgICAgIF92bS5fdihcIiBcIiksXG4gICAgICAgICAgICAgICAgICAgICAgX2MoXCJwYXRoXCIsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXRpY1N0eWxlOiB7IGZpbGw6IFwiIzBhZGMxZVwiLCBkaXNwbGF5OiBcIm5vbmVcIiB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgYXR0cnM6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgZDogXCJNOTQuNSw1Ni44YzAuMS0wLjUsMC4xLTEuMSwwLjItMS43bC05LjQtMWMtMC4xLDAuNC0wLjEsMC45LTAuMiwxLjNMOTQuNSw1Ni44elwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgICAgICAgICBfdm0uX3YoXCIgXCIpLFxuICAgICAgICAgICAgICAgICAgICAgIF9jKFwicGF0aFwiLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdGF0aWNTdHlsZTogeyBmaWxsOiBcIiMwYWRjMWVcIiwgZGlzcGxheTogXCJub25lXCIgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGF0dHJzOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIGQ6IFwiTTkyLjgsNjMuOWMwLjItMC41LDAuMy0xLDAuNS0xLjdsLTkuMS0yLjZjLTAuMSwwLjQtMC4zLDAuOS0wLjQsMS4zTDkyLjgsNjMuOXpcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgICAgICAgICAgX3ZtLl92KFwiIFwiKSxcbiAgICAgICAgICAgICAgICAgICAgICBfYyhcInBhdGhcIiwge1xuICAgICAgICAgICAgICAgICAgICAgICAgc3RhdGljU3R5bGU6IHsgZmlsbDogXCIjMGFkYzFlXCIsIGRpc3BsYXk6IFwibm9uZVwiIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICBhdHRyczoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICBkOiBcIk05MCw3MC43YzAuMi0wLjUsMC41LTEsMC44LTEuNWwtOC43LTQuMWMtMC4yLDAuNC0wLjQsMC44LTAuNiwxLjJMOTAsNzAuN3pcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgICAgICAgICAgX3ZtLl92KFwiIFwiKSxcbiAgICAgICAgICAgICAgICAgICAgICBfYyhcInBhdGhcIiwge1xuICAgICAgICAgICAgICAgICAgICAgICAgc3RhdGljU3R5bGU6IHsgZmlsbDogXCIjMGFkYzFlXCIsIGRpc3BsYXk6IFwibm9uZVwiIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICBhdHRyczoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICBkOiBcIk04OS45LDgwLjFjMC41LTAuNywxLTEuMywxLjQtMS45bC0xMi04LjJjLTAuMywwLjQtMC42LDAuOS0wLjksMS4zTDg5LjksODAuMXpcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgICAgICAgIF1cbiAgICAgICAgICAgICAgICAgICksXG4gICAgICAgICAgICAgICAgICBfdm0uX3YoXCIgXCIpLFxuICAgICAgICAgICAgICAgICAgX2MoXCJkaXZcIiwgeyBhdHRyczogeyBpZDogXCJnYXVnZS1sYWJlbFwiIH0gfSwgW192bS5fdihcIjBcIildKSxcbiAgICAgICAgICAgICAgICBdXG4gICAgICAgICAgICAgICksXG4gICAgICAgICAgICBdXG4gICAgICAgICAgKVxuICAgICAgICA6IF92bS5fZSgpLFxuICAgICAgX3ZtLl92KFwiIFwiKSxcbiAgICAgIF92bS5fbSgwKSxcbiAgICBdLFxuICAgIDFcbiAgKVxufVxudmFyIHN0YXRpY1JlbmRlckZucyA9IFtcbiAgZnVuY3Rpb24gKCkge1xuICAgIHZhciBfdm0gPSB0aGlzXG4gICAgdmFyIF9oID0gX3ZtLiRjcmVhdGVFbGVtZW50XG4gICAgdmFyIF9jID0gX3ZtLl9zZWxmLl9jIHx8IF9oXG4gICAgcmV0dXJuIF9jKFwiZGl2XCIsIHsgc3RhdGljQ2xhc3M6IFwidGFibGUtcmVzcG9uc2l2ZVwiIH0sIFtcbiAgICAgIF9jKFxuICAgICAgICBcInRhYmxlXCIsXG4gICAgICAgIHsgc3RhdGljQ2xhc3M6IFwidGFibGUgdGV4dC1kYXJrIHRhYmxlLXNtIHRhYmxlLWJvcmRlcmxlc3NcIiB9LFxuICAgICAgICBbXG4gICAgICAgICAgX2MoXCJ0aGVhZFwiLCB7IHN0YXRpY0NsYXNzOiBcInRleHQtbXV0ZWRcIiB9LCBbXG4gICAgICAgICAgICBfYyhcInRyXCIsIFtcbiAgICAgICAgICAgICAgX2MoXCJ0aFwiLCB7IHN0YXRpY0NsYXNzOiBcInRleHQtc3RhcnRcIiwgYXR0cnM6IHsgc2NvcGU6IFwiY29sXCIgfSB9LCBbXG4gICAgICAgICAgICAgICAgX3ZtLl92KFwiUHJpY2VcIiksXG4gICAgICAgICAgICAgIF0pLFxuICAgICAgICAgICAgICBfdm0uX3YoXCIgXCIpLFxuICAgICAgICAgICAgICBfYyhcInRoXCIsIHsgc3RhdGljQ2xhc3M6IFwidGV4dC1zdGFydFwiLCBhdHRyczogeyBzY29wZTogXCJjb2xcIiB9IH0sIFtcbiAgICAgICAgICAgICAgICBfdm0uX3YoXCJBbW91bnRcIiksXG4gICAgICAgICAgICAgIF0pLFxuICAgICAgICAgICAgICBfdm0uX3YoXCIgXCIpLFxuICAgICAgICAgICAgICBfYyhcInRoXCIsIHsgc3RhdGljQ2xhc3M6IFwidGV4dC1lbmRcIiwgYXR0cnM6IHsgc2NvcGU6IFwiY29sXCIgfSB9LCBbXG4gICAgICAgICAgICAgICAgX3ZtLl92KFwiVGltZVwiKSxcbiAgICAgICAgICAgICAgXSksXG4gICAgICAgICAgICBdKSxcbiAgICAgICAgICBdKSxcbiAgICAgICAgICBfdm0uX3YoXCIgXCIpLFxuICAgICAgICAgIF9jKFwidGJvZHlcIiwgeyBzdGF0aWNDbGFzczogXCJ0cmFkZVwiLCBhdHRyczogeyBpZDogXCJ0cmFkZVRhYmxlXCIgfSB9KSxcbiAgICAgICAgXVxuICAgICAgKSxcbiAgICBdKVxuICB9LFxuXVxucmVuZGVyLl93aXRoU3RyaXBwZWQgPSB0cnVlXG5cbmV4cG9ydCB7IHJlbmRlciwgc3RhdGljUmVuZGVyRm5zIH0iLCJ2YXIgcmVuZGVyID0gZnVuY3Rpb24gKCkge1xuICB2YXIgX3ZtID0gdGhpc1xuICB2YXIgX2ggPSBfdm0uJGNyZWF0ZUVsZW1lbnRcbiAgdmFyIF9jID0gX3ZtLl9zZWxmLl9jIHx8IF9oXG4gIHJldHVybiBfYyhcImRpdlwiLCB7fSwgW1xuICAgIF9jKFxuICAgICAgXCJkaXZcIixcbiAgICAgIHtcbiAgICAgICAgc3RhdGljQ2xhc3M6XG4gICAgICAgICAgXCJkLWZsZXggZC1zbS1ub25lIGp1c3RpZnktY29udGVudC1iZXR3ZWVuIGFsaWduLWl0ZW1zLWNlbnRlciB0ZXh0LTJcIixcbiAgICAgIH0sXG4gICAgICBbXG4gICAgICAgIF92bS5fbSgwKSxcbiAgICAgICAgX3ZtLl92KFwiIFwiKSxcbiAgICAgICAgX3ZtLnByb3ZpZGVyICE9IFwiY29pbmJhc2Vwcm9cIlxuICAgICAgICAgID8gX2MoXCJkaXZcIiwgeyBzdGF0aWNDbGFzczogXCJkLWZsZXggZmxleC1jb2x1bW5cIiB9LCBbXG4gICAgICAgICAgICAgIF9jKFwiZGl2XCIsIHsgc3RhdGljQ2xhc3M6IFwidGV4dC1tdXRlZCBkLW5vbmUgZC1tZC1ibG9ja1wiIH0sIFtcbiAgICAgICAgICAgICAgICBfdm0uX3YoX3ZtLl9zKF92bS5zeW1ib2wpICsgXCIgVm9sdW1lOiBcIiksXG4gICAgICAgICAgICAgICAgX2MoXCJzcGFuXCIsIHsgc3RhdGljQ2xhc3M6IFwidGV4dC1kYXJrIGRheV92b2x1bWVfcGFpclwiIH0sIFtcbiAgICAgICAgICAgICAgICAgIF92bS5fdihcIi0tLS0tLVwiKSxcbiAgICAgICAgICAgICAgICBdKSxcbiAgICAgICAgICAgICAgXSksXG4gICAgICAgICAgICAgIF92bS5fdihcIiBcIiksXG4gICAgICAgICAgICAgIF9jKFwiZGl2XCIsIHsgc3RhdGljQ2xhc3M6IFwidGV4dC1tdXRlZCBkLW5vbmUgZC1tZC1ibG9ja1wiIH0sIFtcbiAgICAgICAgICAgICAgICBfdm0uX3YoX3ZtLl9zKF92bS5jdXJyZW5jeSkgKyBcIiBWb2x1bWU6IFwiKSxcbiAgICAgICAgICAgICAgICBfYyhcInNwYW5cIiwgeyBzdGF0aWNDbGFzczogXCJ0ZXh0LWRhcmsgZGF5X3ZvbHVtZV9jdXJyZW5jeVwiIH0sIFtcbiAgICAgICAgICAgICAgICAgIF92bS5fdihcIi0tLS0tLVwiKSxcbiAgICAgICAgICAgICAgICBdKSxcbiAgICAgICAgICAgICAgXSksXG4gICAgICAgICAgICBdKVxuICAgICAgICAgIDogX3ZtLl9lKCksXG4gICAgICAgIF92bS5fdihcIiBcIiksXG4gICAgICAgIF92bS5wcm92aWRlciAhPSBcImNvaW5iYXNlcHJvXCJcbiAgICAgICAgICA/IF9jKFwiZGl2XCIsIHsgc3RhdGljQ2xhc3M6IFwiZC1mbGV4IGZsZXgtY29sdW1uXCIgfSwgW1xuICAgICAgICAgICAgICBfdm0uX20oMSksXG4gICAgICAgICAgICAgIF92bS5fdihcIiBcIiksXG4gICAgICAgICAgICAgIF92bS5fbSgyKSxcbiAgICAgICAgICAgIF0pXG4gICAgICAgICAgOiBfdm0uX2UoKSxcbiAgICAgIF1cbiAgICApLFxuICAgIF92bS5fdihcIiBcIiksXG4gICAgX2MoXG4gICAgICBcImRpdlwiLFxuICAgICAge1xuICAgICAgICBzdGF0aWNDbGFzczpcbiAgICAgICAgICBcImQtbm9uZSBkLXNtLWZsZXgganVzdGlmeS1jb250ZW50LWJldHdlZW4gYWxpZ24taXRlbXMtY2VudGVyIG14LTEgdGV4dC0yIG10LTFcIixcbiAgICAgIH0sXG4gICAgICBbXG4gICAgICAgIF9jKFwiZGl2XCIsIHsgc3RhdGljQ2xhc3M6IFwiZC1mbGV4IGFsaWduLWl0ZW1zLWNlbnRlclwiIH0sIFtcbiAgICAgICAgICBfYyhcImltZ1wiLCB7XG4gICAgICAgICAgICBzdGF0aWNDbGFzczogXCJhdmF0YXItY29udGVudFwiLFxuICAgICAgICAgICAgYXR0cnM6IHtcbiAgICAgICAgICAgICAgd2lkdGg6IFwiMzZweFwiLFxuICAgICAgICAgICAgICBzcmM6XG4gICAgICAgICAgICAgICAgXCIuLi8uLi8uLi8uLi8uLi9hc3NldHMvaW1hZ2VzL2NyeXB0b0N1cnJlbmN5L1wiICtcbiAgICAgICAgICAgICAgICBfdm0uc3ltYm9sLnRvTG93ZXJDYXNlKCkgK1xuICAgICAgICAgICAgICAgIFwiLnBuZ1wiLFxuICAgICAgICAgICAgICBhbHQ6IF92bS5zeW1ib2wsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgIH0pLFxuICAgICAgICAgIF92bS5fdihcIiBcIiksXG4gICAgICAgICAgX2MoXCJpXCIsIHsgc3RhdGljQ2xhc3M6IFwiYmkgYmktY2hldnJvbi1yaWdodFwiIH0pLFxuICAgICAgICAgIF92bS5fdihcIiBcIiksXG4gICAgICAgICAgX2MoXCJpbWdcIiwge1xuICAgICAgICAgICAgc3RhdGljQ2xhc3M6IFwiYXZhdGFyLWNvbnRlbnRcIixcbiAgICAgICAgICAgIGF0dHJzOiB7XG4gICAgICAgICAgICAgIHdpZHRoOiBcIjM2cHhcIixcbiAgICAgICAgICAgICAgc3JjOlxuICAgICAgICAgICAgICAgIFwiLi4vLi4vLi4vLi4vLi4vYXNzZXRzL2ltYWdlcy9jcnlwdG9DdXJyZW5jeS9cIiArXG4gICAgICAgICAgICAgICAgX3ZtLmN1cnJlbmN5LnRvTG93ZXJDYXNlKCkgK1xuICAgICAgICAgICAgICAgIFwiLnBuZ1wiLFxuICAgICAgICAgICAgICBhbHQ6IF92bS5jdXJyZW5jeSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgfSksXG4gICAgICAgIF0pLFxuICAgICAgICBfdm0uX3YoXCIgXCIpLFxuICAgICAgICBfdm0ucHJvdmlkZXIgIT0gXCJjb2luYmFzZXByb1wiXG4gICAgICAgICAgPyBfYyhcImRpdlwiLCB7IHN0YXRpY0NsYXNzOiBcImQtZmxleCBmbGV4LWNvbHVtblwiIH0sIFtcbiAgICAgICAgICAgICAgX2MoXCJzcGFuXCIsIHsgc3RhdGljQ2xhc3M6IFwidGV4dC1tdXRlZFwiIH0sIFtfdm0uX3YoXCIyNGggY2hhbmdlXCIpXSksXG4gICAgICAgICAgICAgIF92bS5fdihcIiBcIiksXG4gICAgICAgICAgICAgIF9jKFwic3BhblwiLCB7IHN0YXRpY0NsYXNzOiBcImRheV9jaGFuZ2UgZnMtNlwiIH0sIFtcbiAgICAgICAgICAgICAgICBfdm0uX3YoXCItLS0tLS0tXCIpLFxuICAgICAgICAgICAgICBdKSxcbiAgICAgICAgICAgIF0pXG4gICAgICAgICAgOiBfdm0uX2UoKSxcbiAgICAgICAgX3ZtLl92KFwiIFwiKSxcbiAgICAgICAgX3ZtLl9tKDMpLFxuICAgICAgICBfdm0uX3YoXCIgXCIpLFxuICAgICAgICBfYyhcImRpdlwiLCB7IHN0YXRpY0NsYXNzOiBcImQtZmxleCBmbGV4LWNvbHVtblwiIH0sIFtcbiAgICAgICAgICBfYyhcInNwYW5cIiwgeyBzdGF0aWNDbGFzczogXCJ0ZXh0LW11dGVkXCIgfSwgW192bS5fdihcIjI0aCBWb2x1bWVcIildKSxcbiAgICAgICAgICBfdm0uX3YoXCIgXCIpLFxuICAgICAgICAgIF9jKFwic3BhblwiLCB7IHN0YXRpY0NsYXNzOiBcInRleHQtbXV0ZWRcIiB9LCBbXG4gICAgICAgICAgICBfdm0uX3YoX3ZtLl9zKF92bS5zeW1ib2wpICsgXCI6IFwiKSxcbiAgICAgICAgICAgIF9jKFwic3BhblwiLCB7IHN0YXRpY0NsYXNzOiBcInRleHQtZGFyayBkYXlfdm9sdW1lX3BhaXJcIiB9LCBbXG4gICAgICAgICAgICAgIF92bS5fdihcIi0tLS0tLS1cIiksXG4gICAgICAgICAgICBdKSxcbiAgICAgICAgICBdKSxcbiAgICAgICAgICBfdm0uX3YoXCIgXCIpLFxuICAgICAgICAgIF92bS5wcm92aWRlciAhPSBcImNvaW5iYXNlcHJvXCJcbiAgICAgICAgICAgID8gX2MoXCJzcGFuXCIsIHsgc3RhdGljQ2xhc3M6IFwidGV4dC1tdXRlZFwiIH0sIFtcbiAgICAgICAgICAgICAgICBfdm0uX3YoX3ZtLl9zKF92bS5jdXJyZW5jeSkgKyBcIjogXCIpLFxuICAgICAgICAgICAgICAgIF9jKFwic3BhblwiLCB7IHN0YXRpY0NsYXNzOiBcInRleHQtZGFyayBkYXlfdm9sdW1lX2N1cnJlbmN5XCIgfSwgW1xuICAgICAgICAgICAgICAgICAgX3ZtLl92KFwiLS0tLS0tLVwiKSxcbiAgICAgICAgICAgICAgICBdKSxcbiAgICAgICAgICAgICAgXSlcbiAgICAgICAgICAgIDogX3ZtLl9lKCksXG4gICAgICAgIF0pLFxuICAgICAgXVxuICAgICksXG4gIF0pXG59XG52YXIgc3RhdGljUmVuZGVyRm5zID0gW1xuICBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIF92bSA9IHRoaXNcbiAgICB2YXIgX2ggPSBfdm0uJGNyZWF0ZUVsZW1lbnRcbiAgICB2YXIgX2MgPSBfdm0uX3NlbGYuX2MgfHwgX2hcbiAgICByZXR1cm4gX2MoXCJkaXZcIiwgeyBzdGF0aWNDbGFzczogXCJkLWZsZXggZmxleC1jb2x1bW5cIiB9LCBbXG4gICAgICBfYyhcImRpdlwiLCB7IHN0YXRpY0NsYXNzOiBcInRleHQtbXV0ZWRcIiB9LCBbXG4gICAgICAgIF92bS5fdihcIkxhc3QgUHJpY2U6IFwiKSxcbiAgICAgICAgX2MoXCJzcGFuXCIsIHsgc3RhdGljQ2xhc3M6IFwibGFzdF9wcmljZVwiIH0sIFtfdm0uX3YoXCItLS0tLS1cIildKSxcbiAgICAgICAgX2MoXCJpXCIsIHsgc3RhdGljQ2xhc3M6IFwibGFzdF9wcmljZV9pY29uIGJpXCIgfSksXG4gICAgICBdKSxcbiAgICAgIF92bS5fdihcIiBcIiksXG4gICAgICBfYyhcImRpdlwiLCB7IHN0YXRpY0NsYXNzOiBcInRleHQtbXV0ZWRcIiB9LCBbXG4gICAgICAgIF92bS5fdihcIjI0aCBDaGFuZ2U6IFwiKSxcbiAgICAgICAgX2MoXCJzcGFuXCIsIHsgc3RhdGljQ2xhc3M6IFwiZGF5X2NoYW5nZVwiIH0sIFtfdm0uX3YoXCItLS0tLS1cIildKSxcbiAgICAgICAgX2MoXCJpXCIsIHsgc3RhdGljQ2xhc3M6IFwiZGF5X2NoYW5nZV9pY29uIGJpXCIgfSksXG4gICAgICBdKSxcbiAgICBdKVxuICB9LFxuICBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIF92bSA9IHRoaXNcbiAgICB2YXIgX2ggPSBfdm0uJGNyZWF0ZUVsZW1lbnRcbiAgICB2YXIgX2MgPSBfdm0uX3NlbGYuX2MgfHwgX2hcbiAgICByZXR1cm4gX2MoXCJkaXZcIiwgeyBzdGF0aWNDbGFzczogXCJ0ZXh0LW11dGVkXCIgfSwgW1xuICAgICAgX3ZtLl92KFwiMjRoIEhpZ2g6IFwiKSxcbiAgICAgIF9jKFwic3BhblwiLCB7IHN0YXRpY0NsYXNzOiBcInRleHQtZGFyayBkYXlfaGlnaFwiIH0sIFtfdm0uX3YoXCItLS0tLS1cIildKSxcbiAgICBdKVxuICB9LFxuICBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIF92bSA9IHRoaXNcbiAgICB2YXIgX2ggPSBfdm0uJGNyZWF0ZUVsZW1lbnRcbiAgICB2YXIgX2MgPSBfdm0uX3NlbGYuX2MgfHwgX2hcbiAgICByZXR1cm4gX2MoXCJkaXZcIiwgeyBzdGF0aWNDbGFzczogXCJ0ZXh0LW11dGVkXCIgfSwgW1xuICAgICAgX3ZtLl92KFwiMjRoIExvdzogXCIpLFxuICAgICAgX2MoXCJzcGFuXCIsIHsgc3RhdGljQ2xhc3M6IFwidGV4dC1kYXJrIGRheV9sb3dcIiB9LCBbX3ZtLl92KFwiLS0tLS0tXCIpXSksXG4gICAgXSlcbiAgfSxcbiAgZnVuY3Rpb24gKCkge1xuICAgIHZhciBfdm0gPSB0aGlzXG4gICAgdmFyIF9oID0gX3ZtLiRjcmVhdGVFbGVtZW50XG4gICAgdmFyIF9jID0gX3ZtLl9zZWxmLl9jIHx8IF9oXG4gICAgcmV0dXJuIF9jKFwiZGl2XCIsIHsgc3RhdGljQ2xhc3M6IFwiZC1mbGV4IGZsZXgtY29sdW1uXCIgfSwgW1xuICAgICAgX2MoXCJzcGFuXCIsIHsgc3RhdGljQ2xhc3M6IFwidGV4dC1tdXRlZFwiIH0sIFtfdm0uX3YoXCIyNGggUHJpY2UgUmFuZ2VcIildKSxcbiAgICAgIF92bS5fdihcIiBcIiksXG4gICAgICBfYyhcImRpdlwiLCB7IHN0YXRpY0NsYXNzOiBcInRleHQtbXV0ZWRcIiB9LCBbXG4gICAgICAgIF92bS5fdihcIkhpZ2g6IFwiKSxcbiAgICAgICAgX2MoXCJzcGFuXCIsIHsgc3RhdGljQ2xhc3M6IFwidGV4dC1kYXJrIGRheV9oaWdoXCIgfSwgW192bS5fdihcIi0tLS0tLS1cIildKSxcbiAgICAgIF0pLFxuICAgICAgX3ZtLl92KFwiIFwiKSxcbiAgICAgIF9jKFwiZGl2XCIsIHsgc3RhdGljQ2xhc3M6IFwidGV4dC1tdXRlZFwiIH0sIFtcbiAgICAgICAgX3ZtLl92KFwiTG93OiBcIiksXG4gICAgICAgIF9jKFwic3BhblwiLCB7IHN0YXRpY0NsYXNzOiBcInRleHQtZGFyayBkYXlfbG93XCIgfSwgW192bS5fdihcIi0tLS0tLS1cIildKSxcbiAgICAgIF0pLFxuICAgIF0pXG4gIH0sXG5dXG5yZW5kZXIuX3dpdGhTdHJpcHBlZCA9IHRydWVcblxuZXhwb3J0IHsgcmVuZGVyLCBzdGF0aWNSZW5kZXJGbnMgfSIsInZhciByZW5kZXIgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBfdm0gPSB0aGlzXG4gIHZhciBfaCA9IF92bS4kY3JlYXRlRWxlbWVudFxuICB2YXIgX2MgPSBfdm0uX3NlbGYuX2MgfHwgX2hcbiAgcmV0dXJuIF9jKFwiZGl2XCIsIFtcbiAgICBfYyhcbiAgICAgIFwiZGl2XCIsXG4gICAgICB7IHN0YXRpY0NsYXNzOiBcImQtZmxleCBqdXN0aWZ5LWNvbnRlbnQtYmV0d2VlbiBhbGlnbi1pdGVtcy1jZW50ZXJcIiB9LFxuICAgICAgW1xuICAgICAgICBfYyhcbiAgICAgICAgICBcImJ1dHRvblwiLFxuICAgICAgICAgIHtcbiAgICAgICAgICAgIHN0YXRpY0NsYXNzOiBcImJ0biBidG4taWNvblwiLFxuICAgICAgICAgICAgc3RhdGljU3R5bGU6IHsgcG9zaXRpb246IFwicmVsYXRpdmVcIiwgdG9wOiBcIi01cHhcIiB9LFxuICAgICAgICAgIH0sXG4gICAgICAgICAgW1xuICAgICAgICAgICAgX2MoXCJpXCIsIHtcbiAgICAgICAgICAgICAgc3RhdGljQ2xhc3M6IFwiYmkgYmktY2hldnJvbi1sZWZ0IHRleHQtd2FybmluZyBmcy00XCIsXG4gICAgICAgICAgICAgIG9uOiB7XG4gICAgICAgICAgICAgICAgY2xpY2s6IGZ1bmN0aW9uICgkZXZlbnQpIHtcbiAgICAgICAgICAgICAgICAgICRldmVudC5wcmV2ZW50RGVmYXVsdCgpXG4gICAgICAgICAgICAgICAgICByZXR1cm4gX3ZtLnNjcm9sbExlZnQoKVxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9KSxcbiAgICAgICAgICBdXG4gICAgICAgICksXG4gICAgICAgIF92bS5fdihcIiBcIiksXG4gICAgICAgIF9jKFxuICAgICAgICAgIFwidWxcIixcbiAgICAgICAgICB7XG4gICAgICAgICAgICBzdGF0aWNDbGFzczogXCJuYXYgbmF2LXRhYnMgbmZcIixcbiAgICAgICAgICAgIHN0YXRpY1N0eWxlOiB7IFwib3ZlcmZsb3cteFwiOiBcImhpZGRlblwiIH0sXG4gICAgICAgICAgICBhdHRyczogeyByb2xlOiBcInRhYmxpc3RcIiB9LFxuICAgICAgICAgIH0sXG4gICAgICAgICAgW1xuICAgICAgICAgICAgX2MoXCJsaVwiLCB7IHN0YXRpY0NsYXNzOiBcIm5hdi1pdGVtXCIgfSwgW1xuICAgICAgICAgICAgICBfYyhcbiAgICAgICAgICAgICAgICBcImFcIixcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICBzdGF0aWNDbGFzczogXCJuYXYtbGlua1wiLFxuICAgICAgICAgICAgICAgICAgY2xhc3M6IHsgYWN0aXZlOiBfdm0uaXNBY3RpdmUoXCJmYXZcIikgfSxcbiAgICAgICAgICAgICAgICAgIGF0dHJzOiB7IGhyZWY6IFwiI2ZhdlwiIH0sXG4gICAgICAgICAgICAgICAgICBvbjoge1xuICAgICAgICAgICAgICAgICAgICBjbGljazogZnVuY3Rpb24gKCRldmVudCkge1xuICAgICAgICAgICAgICAgICAgICAgICRldmVudC5wcmV2ZW50RGVmYXVsdCgpXG4gICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF92bS5zZXRBY3RpdmUoXCJmYXZcIilcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBbX2MoXCJpXCIsIHsgc3RhdGljQ2xhc3M6IFwiYmkgYmktc3RhclwiIH0pXVxuICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgXSksXG4gICAgICAgICAgICBfdm0uX3YoXCIgXCIpLFxuICAgICAgICAgICAgX3ZtLl9sKF92bS5wYWlycywgZnVuY3Rpb24gKHBhaXIsIGluZGV4KSB7XG4gICAgICAgICAgICAgIHJldHVybiBfYyhcImxpXCIsIHsga2V5OiBpbmRleCwgc3RhdGljQ2xhc3M6IFwibmF2LWl0ZW1cIiB9LCBbXG4gICAgICAgICAgICAgICAgX2MoXG4gICAgICAgICAgICAgICAgICBcImFcIixcbiAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgc3RhdGljQ2xhc3M6IFwibmF2LWxpbmtcIixcbiAgICAgICAgICAgICAgICAgICAgY2xhc3M6IHsgYWN0aXZlOiBfdm0uaXNBY3RpdmUocGFpcikgfSxcbiAgICAgICAgICAgICAgICAgICAgYXR0cnM6IHsgaHJlZjogXCIjcHJvZmlsZVwiIH0sXG4gICAgICAgICAgICAgICAgICAgIG9uOiB7XG4gICAgICAgICAgICAgICAgICAgICAgY2xpY2s6IGZ1bmN0aW9uICgkZXZlbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICRldmVudC5wcmV2ZW50RGVmYXVsdCgpXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gX3ZtLnNldEFjdGl2ZShwYWlyKVxuICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgW192bS5fdihfdm0uX3MocGFpcikpXVxuICAgICAgICAgICAgICAgICksXG4gICAgICAgICAgICAgIF0pXG4gICAgICAgICAgICB9KSxcbiAgICAgICAgICBdLFxuICAgICAgICAgIDJcbiAgICAgICAgKSxcbiAgICAgICAgX3ZtLl92KFwiIFwiKSxcbiAgICAgICAgX2MoXG4gICAgICAgICAgXCJidXR0b25cIixcbiAgICAgICAgICB7XG4gICAgICAgICAgICBzdGF0aWNDbGFzczogXCJidG4gYnRuLWljb25cIixcbiAgICAgICAgICAgIHN0YXRpY1N0eWxlOiB7IHBvc2l0aW9uOiBcInJlbGF0aXZlXCIsIHRvcDogXCItNXB4XCIgfSxcbiAgICAgICAgICB9LFxuICAgICAgICAgIFtcbiAgICAgICAgICAgIF9jKFwiaVwiLCB7XG4gICAgICAgICAgICAgIHN0YXRpY0NsYXNzOiBcImJpIGJpLWNoZXZyb24tcmlnaHQgdGV4dC13YXJuaW5nIGZzLTRcIixcbiAgICAgICAgICAgICAgb246IHtcbiAgICAgICAgICAgICAgICBjbGljazogZnVuY3Rpb24gKCRldmVudCkge1xuICAgICAgICAgICAgICAgICAgJGV2ZW50LnByZXZlbnREZWZhdWx0KClcbiAgICAgICAgICAgICAgICAgIHJldHVybiBfdm0uc2Nyb2xsUmlnaHQoKVxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9KSxcbiAgICAgICAgICBdXG4gICAgICAgICksXG4gICAgICBdXG4gICAgKSxcbiAgICBfdm0uX3YoXCIgXCIpLFxuICAgIF9jKFxuICAgICAgXCJkaXZcIixcbiAgICAgIHsgc3RhdGljQ2xhc3M6IFwidGFiLWNvbnRlbnRcIiwgYXR0cnM6IHsgaWQ6IFwibXlUYWJDb250ZW50XCIgfSB9LFxuICAgICAgW1xuICAgICAgICBfYyhcbiAgICAgICAgICBcImRpdlwiLFxuICAgICAgICAgIHtcbiAgICAgICAgICAgIHN0YXRpY0NsYXNzOiBcInRhYi1wYW5lIGZhZGVcIixcbiAgICAgICAgICAgIGNsYXNzOiB7IFwiYWN0aXZlIHNob3dcIjogX3ZtLmlzQWN0aXZlKFwiZmF2XCIpIH0sXG4gICAgICAgICAgICBhdHRyczogeyBpZDogXCJmYXZcIiB9LFxuICAgICAgICAgIH0sXG4gICAgICAgICAgW1xuICAgICAgICAgICAgX3ZtLl9tKDApLFxuICAgICAgICAgICAgX3ZtLl92KFwiIFwiKSxcbiAgICAgICAgICAgIF9jKFxuICAgICAgICAgICAgICBcInRhYmxlXCIsXG4gICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBzdGF0aWNDbGFzczpcbiAgICAgICAgICAgICAgICAgIFwidGFibGUgdGV4dC1kYXJrIHRhYmxlLXNtIHRhYmxlLWJvcmRlcmxlc3MgdGFibGVGaXhIZWFkIGN1c3RvbS1kYXRhLXRhYmxlLWZhdlwiLFxuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICBbXG4gICAgICAgICAgICAgICAgX3ZtLl9tKDEpLFxuICAgICAgICAgICAgICAgIF92bS5fdihcIiBcIiksXG4gICAgICAgICAgICAgICAgX2MoXG4gICAgICAgICAgICAgICAgICBcInRib2R5XCIsXG4gICAgICAgICAgICAgICAgICBfdm0uX2woX3ZtLmZhdnMsIGZ1bmN0aW9uIChmYXYsIGluZGV4KSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBfYyhcInRyXCIsIHsga2V5OiBpbmRleCB9LCBbXG4gICAgICAgICAgICAgICAgICAgICAgX2MoXCJ0ZFwiLCBbXG4gICAgICAgICAgICAgICAgICAgICAgICBfYyhcbiAgICAgICAgICAgICAgICAgICAgICAgICAgXCJkaXZcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgeyBzdGF0aWNDbGFzczogXCJkLWZsZXgganVzdGlmeS1jb250ZW50LXN0YXJ0XCIgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9jKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJmb3JtXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9uOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3VibWl0OiBmdW5jdGlvbiAoJGV2ZW50KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAkZXZlbnQucHJldmVudERlZmF1bHQoKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF92bS5yZW1vdmVGcm9tV2F0Y2hsaXN0KGZhdi5pZClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFtfdm0uX20oMiwgdHJ1ZSldXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfdm0uX3YoXCIgXCIpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9jKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJyb3V0ZXItbGlua1wiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhdHRyczoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRvOiBcIi4uL1wiICsgZmF2LmN1cnJlbmN5ICsgXCIvXCIgKyBmYXYucGFpcixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9jKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwic3BhblwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHsgc3RhdGljQ2xhc3M6IFwidGV4dC1kYXJrIGZ3LWJvbGRcIiB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFtfdm0uX3YoX3ZtLl9zKGZhdi5jdXJyZW5jeSkpXVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfdm0uX3YoXCIvXCIpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfYyhcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcInNwYW5cIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7IHN0YXRpY0NsYXNzOiBcInRleHQtc2Vjb25kYXJ5IGZ3LWJvbGRcIiB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFtfdm0uX3YoX3ZtLl9zKGZhdi5wYWlyKSldXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBdXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgMVxuICAgICAgICAgICAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICAgICAgICAgICBdKSxcbiAgICAgICAgICAgICAgICAgICAgICBfdm0uX3YoXCIgXCIpLFxuICAgICAgICAgICAgICAgICAgICAgIF9jKFwidGRcIiwgeyBzdGF0aWNDbGFzczogXCJkLWxnLW5vbmUgZC14bC1ibG9ja1wiIH0sIFtcbiAgICAgICAgICAgICAgICAgICAgICAgIF9jKFwic3BhblwiLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIGNsYXNzOiBcImNoYW5nZS1cIiArIGZhdi5jdXJyZW5jeSArIGZhdi5wYWlyLFxuICAgICAgICAgICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgICAgICAgICAgXSksXG4gICAgICAgICAgICAgICAgICAgICAgX3ZtLl92KFwiIFwiKSxcbiAgICAgICAgICAgICAgICAgICAgICBfYyhcInRkXCIsIFtcbiAgICAgICAgICAgICAgICAgICAgICAgIF9jKFwic3BhblwiLCB7IGNsYXNzOiBcInRpYy1cIiArIGZhdi5jdXJyZW5jeSArIGZhdi5wYWlyIH0pLFxuICAgICAgICAgICAgICAgICAgICAgICAgX2MoXCJpXCIsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgY2xhc3M6IFwidGljLVwiICsgZmF2LmN1cnJlbmN5ICsgZmF2LnBhaXIgKyBcIi1pY29uIGJpXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgICAgICAgICBdKSxcbiAgICAgICAgICAgICAgICAgICAgXSlcbiAgICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAgICAgMFxuICAgICAgICAgICAgICAgICksXG4gICAgICAgICAgICAgIF1cbiAgICAgICAgICAgICksXG4gICAgICAgICAgXVxuICAgICAgICApLFxuICAgICAgICBfdm0uX3YoXCIgXCIpLFxuICAgICAgICBfdm0uX2woX3ZtLm1hcmtldHMsIGZ1bmN0aW9uIChtYXJrLCBpbmRleCkge1xuICAgICAgICAgIHJldHVybiBfYyhcbiAgICAgICAgICAgIFwiZGl2XCIsXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIGtleTogaW5kZXgsXG4gICAgICAgICAgICAgIHN0YXRpY0NsYXNzOiBcInRhYi1wYW5lIGZhZGVcIixcbiAgICAgICAgICAgICAgY2xhc3M6IHsgXCJhY3RpdmUgc2hvd1wiOiBfdm0uaXNBY3RpdmUoaW5kZXgpIH0sXG4gICAgICAgICAgICAgIGF0dHJzOiB7IGlkOiB7IGluZGV4OiBpbmRleCB9IH0sXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgW1xuICAgICAgICAgICAgICBfdm0uX20oMywgdHJ1ZSksXG4gICAgICAgICAgICAgIF92bS5fdihcIiBcIiksXG4gICAgICAgICAgICAgIF9jKFxuICAgICAgICAgICAgICAgIFwidGFibGVcIixcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICBzdGF0aWNDbGFzczpcbiAgICAgICAgICAgICAgICAgICAgXCJ0YWJsZSB0ZXh0LWRhcmsgdGFibGUtc20gdGFibGUtYm9yZGVybGVzcyB0YWJsZUZpeEhlYWRcIixcbiAgICAgICAgICAgICAgICAgIGNsYXNzOiBcImN1c3RvbS1kYXRhLXRhYmxlLVwiICsgaW5kZXgsXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBbXG4gICAgICAgICAgICAgICAgICBfdm0uX20oNCwgdHJ1ZSksXG4gICAgICAgICAgICAgICAgICBfdm0uX3YoXCIgXCIpLFxuICAgICAgICAgICAgICAgICAgX2MoXG4gICAgICAgICAgICAgICAgICAgIFwidGJvZHlcIixcbiAgICAgICAgICAgICAgICAgICAgX3ZtLl9sKG1hcmssIGZ1bmN0aW9uIChtYXJrZXQsIGluZGV4KSB7XG4gICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9jKFwidHJcIiwgeyBrZXk6IGluZGV4IH0sIFtcbiAgICAgICAgICAgICAgICAgICAgICAgIF9jKFwidGRcIiwgW1xuICAgICAgICAgICAgICAgICAgICAgICAgICBfYyhcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBcImRpdlwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHsgc3RhdGljQ2xhc3M6IFwiZC1mbGV4IGp1c3RpZnktY29udGVudC1zdGFydFwiIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX2MoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiZm9ybVwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb246IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN1Ym1pdDogZnVuY3Rpb24gKCRldmVudCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAkZXZlbnQucHJldmVudERlZmF1bHQoKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gX3ZtLmFkZFRvV2F0Y2hsaXN0KFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1hcmtldC5jdXJyZW5jeSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYXJrZXQucGFpclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFtfdm0uX20oNSwgdHJ1ZSldXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX3ZtLl92KFwiIFwiKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9jKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcInJvdXRlci1saW5rXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhdHRyczoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdG86XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiLi4vXCIgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYXJrZXQuY3VycmVuY3kgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIi9cIiArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1hcmtldC5wYWlyLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfYyhcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwic3BhblwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeyBzdGF0aWNDbGFzczogXCJ0ZXh0LWRhcmsgZnctYm9sZFwiIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBbX3ZtLl92KF92bS5fcyhtYXJrZXQuY3VycmVuY3kpKV1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF92bS5fdihcIi9cIiksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX2MoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcInNwYW5cIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHsgc3RhdGljQ2xhc3M6IFwidGV4dC1zZWNvbmRhcnkgZnctYm9sZFwiIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBbX3ZtLl92KF92bS5fcyhtYXJrZXQucGFpcikpXVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAxXG4gICAgICAgICAgICAgICAgICAgICAgICAgICksXG4gICAgICAgICAgICAgICAgICAgICAgICBdKSxcbiAgICAgICAgICAgICAgICAgICAgICBdKVxuICAgICAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgICAgICAgMFxuICAgICAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICAgICBdXG4gICAgICAgICAgICAgICksXG4gICAgICAgICAgICBdXG4gICAgICAgICAgKVxuICAgICAgICB9KSxcbiAgICAgIF0sXG4gICAgICAyXG4gICAgKSxcbiAgXSlcbn1cbnZhciBzdGF0aWNSZW5kZXJGbnMgPSBbXG4gIGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgX3ZtID0gdGhpc1xuICAgIHZhciBfaCA9IF92bS4kY3JlYXRlRWxlbWVudFxuICAgIHZhciBfYyA9IF92bS5fc2VsZi5fYyB8fCBfaFxuICAgIHJldHVybiBfYyhcImRpdlwiLCB7IHN0YXRpY0NsYXNzOiBcInJvd1wiIH0sIFtcbiAgICAgIF9jKFwiZGl2XCIsIHsgc3RhdGljQ2xhc3M6IFwiY29sLTEyIGNhcmQtc2VhcmNoIGN1c3RvbS1kYXRhLXNlYXJjaFwiIH0sIFtcbiAgICAgICAgX2MoXCJkaXZcIiwgeyBzdGF0aWNDbGFzczogXCJpbnB1dC1ncm91cCBpbnB1dC1ncm91cC1zbSBweC0xIG1iLTFcIiB9LCBbXG4gICAgICAgICAgX2MoXG4gICAgICAgICAgICBcInNwYW5cIixcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgc3RhdGljQ2xhc3M6IFwiaW5wdXQtZ3JvdXAtdGV4dCB0ZXh0LWRhcmsgYm9yZGVyLTBcIixcbiAgICAgICAgICAgICAgYXR0cnM6IHsgaWQ6IFwiYmFzaWMtYWRkb24xXCIgfSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBbX2MoXCJpXCIsIHsgc3RhdGljQ2xhc3M6IFwiYmkgYmktc2VhcmNoXCIgfSldXG4gICAgICAgICAgKSxcbiAgICAgICAgICBfdm0uX3YoXCIgXCIpLFxuICAgICAgICAgIF9jKFwiaW5wdXRcIiwge1xuICAgICAgICAgICAgc3RhdGljQ2xhc3M6IFwiZm9ybS1jb250cm9sIGZvcm0tY29udHJvbC1zbSB0ZXh0LWRhcmsgYm9yZGVyLTBcIixcbiAgICAgICAgICAgIGF0dHJzOiB7XG4gICAgICAgICAgICAgIHR5cGU6IFwidGV4dFwiLFxuICAgICAgICAgICAgICBuYW1lOiBcInNlYXJjaF90YWJsZV9mYXZcIixcbiAgICAgICAgICAgICAgcGxhY2Vob2xkZXI6IFwiU2VhcmNoLi4uXCIsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgIH0pLFxuICAgICAgICBdKSxcbiAgICAgIF0pLFxuICAgIF0pXG4gIH0sXG4gIGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgX3ZtID0gdGhpc1xuICAgIHZhciBfaCA9IF92bS4kY3JlYXRlRWxlbWVudFxuICAgIHZhciBfYyA9IF92bS5fc2VsZi5fYyB8fCBfaFxuICAgIHJldHVybiBfYyhcInRoZWFkXCIsIHsgc3RhdGljQ2xhc3M6IFwidGV4dC1tdXRlZFwiIH0sIFtcbiAgICAgIF9jKFwidGhcIiwgeyBhdHRyczogeyBzY29wZTogXCJjb2xcIiB9IH0sIFtfdm0uX3YoXCJQYWlyXCIpXSksXG4gICAgICBfdm0uX3YoXCIgXCIpLFxuICAgICAgX2MoXG4gICAgICAgIFwidGhcIixcbiAgICAgICAgeyBzdGF0aWNDbGFzczogXCJkLWxnLW5vbmUgZC14bC1ibG9ja1wiLCBhdHRyczogeyBzY29wZTogXCJjb2xcIiB9IH0sXG4gICAgICAgIFtfdm0uX3YoXCJDaGFuZ2VcIildXG4gICAgICApLFxuICAgICAgX3ZtLl92KFwiIFwiKSxcbiAgICAgIF9jKFwidGhcIiwgeyBhdHRyczogeyBzY29wZTogXCJjb2xcIiB9IH0sIFtfdm0uX3YoXCJQcmljZVwiKV0pLFxuICAgIF0pXG4gIH0sXG4gIGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgX3ZtID0gdGhpc1xuICAgIHZhciBfaCA9IF92bS4kY3JlYXRlRWxlbWVudFxuICAgIHZhciBfYyA9IF92bS5fc2VsZi5fYyB8fCBfaFxuICAgIHJldHVybiBfYyhcbiAgICAgIFwiYnV0dG9uXCIsXG4gICAgICB7XG4gICAgICAgIHN0YXRpY0NsYXNzOiBcIndhdGNobGlzdGVkXCIsXG4gICAgICAgIHN0YXRpY1N0eWxlOiB7IGJhY2tncm91bmQ6IFwidHJhbnNwYXJlbnRcIiwgYm9yZGVyOiBcInRyYW5zcGFyZW50XCIgfSxcbiAgICAgICAgYXR0cnM6IHsgdHlwZTogXCJzdWJtaXRcIiB9LFxuICAgICAgfSxcbiAgICAgIFtfYyhcImlcIiwgeyBzdGF0aWNDbGFzczogXCJtZS0xIHRleHQtd2FybmluZyBiaSBiaS1zdGFyLWZpbGxcIiB9KV1cbiAgICApXG4gIH0sXG4gIGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgX3ZtID0gdGhpc1xuICAgIHZhciBfaCA9IF92bS4kY3JlYXRlRWxlbWVudFxuICAgIHZhciBfYyA9IF92bS5fc2VsZi5fYyB8fCBfaFxuICAgIHJldHVybiBfYyhcImRpdlwiLCB7IHN0YXRpY0NsYXNzOiBcInJvd1wiIH0sIFtcbiAgICAgIF9jKFwiZGl2XCIsIHsgc3RhdGljQ2xhc3M6IFwiY29sLTEyIGNhcmQtc2VhcmNoIGN1c3RvbS1kYXRhLXNlYXJjaFwiIH0sIFtcbiAgICAgICAgX2MoXCJkaXZcIiwgeyBzdGF0aWNDbGFzczogXCJpbnB1dC1ncm91cCBpbnB1dC1ncm91cC1zbSBweC0xIG1iLTFcIiB9LCBbXG4gICAgICAgICAgX2MoXG4gICAgICAgICAgICBcInNwYW5cIixcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgc3RhdGljQ2xhc3M6IFwiaW5wdXQtZ3JvdXAtdGV4dCB0ZXh0LWRhcmsgYm9yZGVyLTBcIixcbiAgICAgICAgICAgICAgYXR0cnM6IHsgaWQ6IFwiYmFzaWMtYWRkb24xXCIgfSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBbX2MoXCJpXCIsIHsgc3RhdGljQ2xhc3M6IFwiYmkgYmktc2VhcmNoXCIgfSldXG4gICAgICAgICAgKSxcbiAgICAgICAgICBfdm0uX3YoXCIgXCIpLFxuICAgICAgICAgIF9jKFwiaW5wdXRcIiwge1xuICAgICAgICAgICAgc3RhdGljQ2xhc3M6IFwiZm9ybS1jb250cm9sIGZvcm0tY29udHJvbC1zbSB0ZXh0LWRhcmsgYm9yZGVyLTBcIixcbiAgICAgICAgICAgIGF0dHJzOiB7XG4gICAgICAgICAgICAgIHR5cGU6IFwidGV4dFwiLFxuICAgICAgICAgICAgICBuYW1lOiBcInNlYXJjaF90YWJsZVwiLFxuICAgICAgICAgICAgICBwbGFjZWhvbGRlcjogXCJTZWFyY2guLi5cIixcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgfSksXG4gICAgICAgIF0pLFxuICAgICAgXSksXG4gICAgXSlcbiAgfSxcbiAgZnVuY3Rpb24gKCkge1xuICAgIHZhciBfdm0gPSB0aGlzXG4gICAgdmFyIF9oID0gX3ZtLiRjcmVhdGVFbGVtZW50XG4gICAgdmFyIF9jID0gX3ZtLl9zZWxmLl9jIHx8IF9oXG4gICAgcmV0dXJuIF9jKFwidGhlYWRcIiwgeyBzdGF0aWNDbGFzczogXCJ0ZXh0LW11dGVkXCIgfSwgW1xuICAgICAgX2MoXCJ0aFwiLCB7IGF0dHJzOiB7IHNjb3BlOiBcImNvbFwiIH0gfSwgW192bS5fdihcIlBhaXJcIildKSxcbiAgICBdKVxuICB9LFxuICBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIF92bSA9IHRoaXNcbiAgICB2YXIgX2ggPSBfdm0uJGNyZWF0ZUVsZW1lbnRcbiAgICB2YXIgX2MgPSBfdm0uX3NlbGYuX2MgfHwgX2hcbiAgICByZXR1cm4gX2MoXG4gICAgICBcImJ1dHRvblwiLFxuICAgICAge1xuICAgICAgICBzdGF0aWNDbGFzczogXCJub3Qtd2F0Y2hsaXN0ZWRcIixcbiAgICAgICAgc3RhdGljU3R5bGU6IHsgYmFja2dyb3VuZDogXCJ0cmFuc3BhcmVudFwiLCBib3JkZXI6IFwidHJhbnNwYXJlbnRcIiB9LFxuICAgICAgICBhdHRyczogeyB0eXBlOiBcInN1Ym1pdFwiIH0sXG4gICAgICB9LFxuICAgICAgW19jKFwiaVwiLCB7IHN0YXRpY0NsYXNzOiBcIm1lLTEgdGV4dC1zZWNvbmRhcnkgYmkgYmktc3RhclwiIH0pXVxuICAgIClcbiAgfSxcbl1cbnJlbmRlci5fd2l0aFN0cmlwcGVkID0gdHJ1ZVxuXG5leHBvcnQgeyByZW5kZXIsIHN0YXRpY1JlbmRlckZucyB9IiwidmFyIHJlbmRlciA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIF92bSA9IHRoaXNcbiAgdmFyIF9oID0gX3ZtLiRjcmVhdGVFbGVtZW50XG4gIHZhciBfYyA9IF92bS5fc2VsZi5fYyB8fCBfaFxuICByZXR1cm4gX2MoXCJkaXZcIiwgeyBzdGF0aWNDbGFzczogXCIgXCIgfSwgW1xuICAgIF9jKFwiaW5wdXRcIiwgeyBhdHRyczogeyB0eXBlOiBcImhpZGRlblwiLCBpZDogXCJiZXN0QXNrXCIgfSB9KSxcbiAgICBfdm0uX3YoXCIgXCIpLFxuICAgIF9jKFwiaW5wdXRcIiwgeyBhdHRyczogeyB0eXBlOiBcImhpZGRlblwiLCBpZDogXCJiZXN0QmlkXCIgfSB9KSxcbiAgICBfdm0uX3YoXCIgXCIpLFxuICAgIF9jKFxuICAgICAgXCJ1bFwiLFxuICAgICAge1xuICAgICAgICBzdGF0aWNDbGFzczogXCJuYXYgbmF2LXRhYnNcIixcbiAgICAgICAgYXR0cnM6IHsgaWQ6IFwicGlsbHMtdGFiXCIsIHJvbGU6IFwidGFibGlzdFwiIH0sXG4gICAgICB9LFxuICAgICAgW1xuICAgICAgICBfYyhcImxpXCIsIHsgc3RhdGljQ2xhc3M6IFwibmF2LWl0ZW1cIiB9LCBbXG4gICAgICAgICAgX2MoXG4gICAgICAgICAgICBcImJ1dHRvblwiLFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICBzdGF0aWNDbGFzczogXCJuYXYtbGlua1wiLFxuICAgICAgICAgICAgICBjbGFzczogeyBhY3RpdmU6IF92bS5pc0FjdGl2ZShcInBpbGxzLWdyYXBoXCIpIH0sXG4gICAgICAgICAgICAgIGF0dHJzOiB7IGhyZWY6IFwiI3BpbGxzLWdyYXBoXCIgfSxcbiAgICAgICAgICAgICAgb246IHtcbiAgICAgICAgICAgICAgICBjbGljazogZnVuY3Rpb24gKCRldmVudCkge1xuICAgICAgICAgICAgICAgICAgJGV2ZW50LnByZXZlbnREZWZhdWx0KClcbiAgICAgICAgICAgICAgICAgIHJldHVybiBfdm0uc2V0QWN0aXZlKFwicGlsbHMtZ3JhcGhcIilcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIFtfYyhcImlcIiwgeyBzdGF0aWNDbGFzczogXCJiaSBiaS1ncmFwaC11cCB0ZXh0LWRhcmtcIiB9KV1cbiAgICAgICAgICApLFxuICAgICAgICBdKSxcbiAgICAgICAgX3ZtLl92KFwiIFwiKSxcbiAgICAgICAgX2MoXCJsaVwiLCB7IHN0YXRpY0NsYXNzOiBcIm5hdi1pdGVtXCIgfSwgW1xuICAgICAgICAgIF9jKFxuICAgICAgICAgICAgXCJidXR0b25cIixcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgc3RhdGljQ2xhc3M6IFwibmF2LWxpbmtcIixcbiAgICAgICAgICAgICAgY2xhc3M6IHsgYWN0aXZlOiBfdm0uaXNBY3RpdmUoXCJwaWxscy1ncmFwaC11cFwiKSB9LFxuICAgICAgICAgICAgICBhdHRyczogeyBocmVmOiBcIiNwaWxscy1ncmFwaC11cFwiIH0sXG4gICAgICAgICAgICAgIG9uOiB7XG4gICAgICAgICAgICAgICAgY2xpY2s6IGZ1bmN0aW9uICgkZXZlbnQpIHtcbiAgICAgICAgICAgICAgICAgICRldmVudC5wcmV2ZW50RGVmYXVsdCgpXG4gICAgICAgICAgICAgICAgICByZXR1cm4gX3ZtLnNldEFjdGl2ZShcInBpbGxzLWdyYXBoLXVwXCIpXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBbX2MoXCJpXCIsIHsgc3RhdGljQ2xhc3M6IFwiYmkgYmktZ3JhcGgtdXAtYXJyb3cgdGV4dC1zdWNjZXNzXCIgfSldXG4gICAgICAgICAgKSxcbiAgICAgICAgXSksXG4gICAgICAgIF92bS5fdihcIiBcIiksXG4gICAgICAgIF9jKFwibGlcIiwgeyBzdGF0aWNDbGFzczogXCJuYXYtaXRlbVwiIH0sIFtcbiAgICAgICAgICBfYyhcbiAgICAgICAgICAgIFwiYnV0dG9uXCIsXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIHN0YXRpY0NsYXNzOiBcIm5hdi1saW5rXCIsXG4gICAgICAgICAgICAgIGNsYXNzOiB7IGFjdGl2ZTogX3ZtLmlzQWN0aXZlKFwicGlsbHMtZ3JhcGgtZG93blwiKSB9LFxuICAgICAgICAgICAgICBhdHRyczogeyBocmVmOiBcIiNwaWxscy1ncmFwaC1kb3duXCIgfSxcbiAgICAgICAgICAgICAgb246IHtcbiAgICAgICAgICAgICAgICBjbGljazogZnVuY3Rpb24gKCRldmVudCkge1xuICAgICAgICAgICAgICAgICAgJGV2ZW50LnByZXZlbnREZWZhdWx0KClcbiAgICAgICAgICAgICAgICAgIHJldHVybiBfdm0uc2V0QWN0aXZlKFwicGlsbHMtZ3JhcGgtZG93blwiKVxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgW19jKFwiaVwiLCB7IHN0YXRpY0NsYXNzOiBcImJpIGJpLWdyYXBoLWRvd24tYXJyb3cgdGV4dC1kYW5nZXJcIiB9KV1cbiAgICAgICAgICApLFxuICAgICAgICBdKSxcbiAgICAgIF1cbiAgICApLFxuICAgIF92bS5fdihcIiBcIiksXG4gICAgX2MoXG4gICAgICBcImRpdlwiLFxuICAgICAgeyBzdGF0aWNDbGFzczogXCJ0YWItY29udGVudFwiLCBhdHRyczogeyBpZDogXCJwaWxscy1ncmFwaC10YWJDb250ZW50XCIgfSB9LFxuICAgICAgW1xuICAgICAgICBfYyhcbiAgICAgICAgICBcImRpdlwiLFxuICAgICAgICAgIHtcbiAgICAgICAgICAgIHN0YXRpY0NsYXNzOiBcInRhYi1wYW5lIGZhZGVcIixcbiAgICAgICAgICAgIGNsYXNzOiB7IFwiYWN0aXZlIHNob3dcIjogX3ZtLmlzQWN0aXZlKFwicGlsbHMtZ3JhcGhcIikgfSxcbiAgICAgICAgICAgIGF0dHJzOiB7XG4gICAgICAgICAgICAgIGlkOiBcInBpbGxzLWdyYXBoXCIsXG4gICAgICAgICAgICAgIHJvbGU6IFwidGFicGFuZWxcIixcbiAgICAgICAgICAgICAgXCJhcmlhLWxhYmVsbGVkYnlcIjogXCJwaWxscy1ncmFwaC10YWJcIixcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgfSxcbiAgICAgICAgICBbXG4gICAgICAgICAgICBfdm0uX20oMCksXG4gICAgICAgICAgICBfdm0uX3YoXCIgXCIpLFxuICAgICAgICAgICAgX3ZtLl9tKDEpLFxuICAgICAgICAgICAgX3ZtLl92KFwiIFwiKSxcbiAgICAgICAgICAgIF9jKFwiZGl2XCIsIHsgc3RhdGljQ2xhc3M6IFwidGFibGUtcmVzcG9uc2l2ZVwiIH0sIFtcbiAgICAgICAgICAgICAgX2MoXG4gICAgICAgICAgICAgICAgXCJ0YWJsZVwiLFxuICAgICAgICAgICAgICAgIHsgc3RhdGljQ2xhc3M6IFwiYmlkc1wiLCBzdGF0aWNTdHlsZTogeyBcIm1pbi1oZWlnaHRcIjogXCIyODBweFwiIH0gfSxcbiAgICAgICAgICAgICAgICBbXG4gICAgICAgICAgICAgICAgICBfYyhcbiAgICAgICAgICAgICAgICAgICAgXCJkaXZcIixcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgIGtleTogX3ZtLnN5bWJvbCArIF92bS5jdXJyZW5jeSxcbiAgICAgICAgICAgICAgICAgICAgICBzdGF0aWNDbGFzczogXCJvcmRlci1sb2FkZXJcIixcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgW192bS5fbSgyKV1cbiAgICAgICAgICAgICAgICAgICksXG4gICAgICAgICAgICAgICAgXVxuICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgXSksXG4gICAgICAgICAgXVxuICAgICAgICApLFxuICAgICAgICBfdm0uX3YoXCIgXCIpLFxuICAgICAgICBfYyhcbiAgICAgICAgICBcImRpdlwiLFxuICAgICAgICAgIHtcbiAgICAgICAgICAgIHN0YXRpY0NsYXNzOiBcInRhYi1wYW5lIGZhZGVcIixcbiAgICAgICAgICAgIGNsYXNzOiB7IFwiYWN0aXZlIHNob3dcIjogX3ZtLmlzQWN0aXZlKFwicGlsbHMtZ3JhcGgtZG93blwiKSB9LFxuICAgICAgICAgICAgYXR0cnM6IHtcbiAgICAgICAgICAgICAgaWQ6IFwicGlsbHMtZ3JhcGgtZG93blwiLFxuICAgICAgICAgICAgICByb2xlOiBcInRhYnBhbmVsXCIsXG4gICAgICAgICAgICAgIFwiYXJpYS1sYWJlbGxlZGJ5XCI6IFwicGlsbHMtZ3JhcGgtZG93bi10YWJcIixcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgfSxcbiAgICAgICAgICBbX3ZtLl9tKDMpXVxuICAgICAgICApLFxuICAgICAgICBfdm0uX3YoXCIgXCIpLFxuICAgICAgICBfYyhcbiAgICAgICAgICBcImRpdlwiLFxuICAgICAgICAgIHtcbiAgICAgICAgICAgIHN0YXRpY0NsYXNzOiBcInRhYi1wYW5lIGZhZGVcIixcbiAgICAgICAgICAgIGNsYXNzOiB7IFwiYWN0aXZlIHNob3dcIjogX3ZtLmlzQWN0aXZlKFwicGlsbHMtZ3JhcGgtdXBcIikgfSxcbiAgICAgICAgICAgIGF0dHJzOiB7XG4gICAgICAgICAgICAgIGlkOiBcInBpbGxzLWdyYXBoLXVwXCIsXG4gICAgICAgICAgICAgIHJvbGU6IFwidGFicGFuZWxcIixcbiAgICAgICAgICAgICAgXCJhcmlhLWxhYmVsbGVkYnlcIjogXCJwaWxscy1ncmFwaC11cC10YWJcIixcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgfSxcbiAgICAgICAgICBbX3ZtLl9tKDQpXVxuICAgICAgICApLFxuICAgICAgXVxuICAgICksXG4gIF0pXG59XG52YXIgc3RhdGljUmVuZGVyRm5zID0gW1xuICBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIF92bSA9IHRoaXNcbiAgICB2YXIgX2ggPSBfdm0uJGNyZWF0ZUVsZW1lbnRcbiAgICB2YXIgX2MgPSBfdm0uX3NlbGYuX2MgfHwgX2hcbiAgICByZXR1cm4gX2MoXCJkaXZcIiwgeyBzdGF0aWNDbGFzczogXCJ0YWJsZS1yZXNwb25zaXZlXCIgfSwgW1xuICAgICAgX2MoXG4gICAgICAgIFwidGFibGVcIixcbiAgICAgICAge1xuICAgICAgICAgIHN0YXRpY0NsYXNzOiBcInRhYmxlIHRleHQtZGFyayB0YWJsZS1zbSB0YWJsZS1ib3JkZXJsZXNzXCIsXG4gICAgICAgICAgc3RhdGljU3R5bGU6IHsgXCJvdmVyZmxvdy14XCI6IFwiaGlkZGVuXCIgfSxcbiAgICAgICAgfSxcbiAgICAgICAgW1xuICAgICAgICAgIF9jKFwidGhlYWRcIiwgeyBzdGF0aWNDbGFzczogXCJ0ZXh0LW11dGVkXCIgfSwgW1xuICAgICAgICAgICAgX2MoXCJ0aFwiLCB7IHN0YXRpY0NsYXNzOiBcInRleHQtc3RhcnRcIiwgYXR0cnM6IHsgc2NvcGU6IFwiY29sXCIgfSB9LCBbXG4gICAgICAgICAgICAgIF92bS5fdihcIlByaWNlXCIpLFxuICAgICAgICAgICAgXSksXG4gICAgICAgICAgICBfdm0uX3YoXCIgXCIpLFxuICAgICAgICAgICAgX2MoXCJ0aFwiLCB7IHN0YXRpY0NsYXNzOiBcInRleHQtc3RhcnRcIiwgYXR0cnM6IHsgc2NvcGU6IFwiY29sXCIgfSB9LCBbXG4gICAgICAgICAgICAgIF92bS5fdihcIkFtb3VudFwiKSxcbiAgICAgICAgICAgIF0pLFxuICAgICAgICAgICAgX3ZtLl92KFwiIFwiKSxcbiAgICAgICAgICAgIF9jKFwidGhcIiwgeyBzdGF0aWNDbGFzczogXCJ0ZXh0LWVuZFwiLCBhdHRyczogeyBzY29wZTogXCJjb2xcIiB9IH0sIFtcbiAgICAgICAgICAgICAgX3ZtLl92KFwiVG90YWxcIiksXG4gICAgICAgICAgICBdKSxcbiAgICAgICAgICBdKSxcbiAgICAgICAgXVxuICAgICAgKSxcbiAgICAgIF92bS5fdihcIiBcIiksXG4gICAgICBfYyhcbiAgICAgICAgXCJ0YWJsZVwiLFxuICAgICAgICB7IHN0YXRpY0NsYXNzOiBcImFza3NcIiwgc3RhdGljU3R5bGU6IHsgXCJtaW4taGVpZ2h0XCI6IFwiMjgwcHhcIiB9IH0sXG4gICAgICAgIFtcbiAgICAgICAgICBfYyhcImRpdlwiLCB7IHN0YXRpY0NsYXNzOiBcIm9yZGVyLWxvYWRlclwiIH0sIFtcbiAgICAgICAgICAgIF9jKFxuICAgICAgICAgICAgICBcImRpdlwiLFxuICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgc3RhdGljQ2xhc3M6IFwic2UtcHJlLWNvbjIgc3Bpbm5lci1ib3JkZXIgdGV4dC1wcmltYXJ5XCIsXG4gICAgICAgICAgICAgICAgYXR0cnM6IHsgcm9sZTogXCJzdGF0dXNcIiB9LFxuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICBbX2MoXCJzcGFuXCIsIHsgc3RhdGljQ2xhc3M6IFwic3Itb25seVwiIH0pXVxuICAgICAgICAgICAgKSxcbiAgICAgICAgICBdKSxcbiAgICAgICAgXVxuICAgICAgKSxcbiAgICBdKVxuICB9LFxuICBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIF92bSA9IHRoaXNcbiAgICB2YXIgX2ggPSBfdm0uJGNyZWF0ZUVsZW1lbnRcbiAgICB2YXIgX2MgPSBfdm0uX3NlbGYuX2MgfHwgX2hcbiAgICByZXR1cm4gX2MoXCJkaXZcIiwgeyBzdGF0aWNDbGFzczogXCJ0YWJsZS1yZXNwb25zaXZlIGJvcmRlcmVkLXlcIiB9LCBbXG4gICAgICBfYyhcbiAgICAgICAgXCJ0YWJsZVwiLFxuICAgICAgICB7IHN0YXRpY0NsYXNzOiBcInRhYmxlIHRleHQtZGFyayB0YWJsZS1zbSB0YWJsZS1ib3JkZXJsZXNzIG15LWF1dG9cIiB9LFxuICAgICAgICBbXG4gICAgICAgICAgX2MoXCJ0Ym9keVwiLCBbXG4gICAgICAgICAgICBfYyhcInRyXCIsIFtcbiAgICAgICAgICAgICAgX2MoXCJ0ZFwiLCB7IHN0YXRpY0NsYXNzOiBcInRleHQtbXV0ZVwiIH0sIFtcbiAgICAgICAgICAgICAgICBfYyhcInNwYW5cIiwgeyBzdGF0aWNDbGFzczogXCJmcy02XCIgfSwgW192bS5fdihcIkxhc3QgUHJpY2U6IFwiKV0pLFxuICAgICAgICAgICAgICAgIF92bS5fdihcIiBcIiksXG4gICAgICAgICAgICAgICAgX2MoXCJzcGFuXCIsIHsgc3RhdGljQ2xhc3M6IFwiZnMtNiBiZXN0X2Fza1wiIH0pLFxuICAgICAgICAgICAgICAgIF9jKFwiaVwiLCB7IHN0YXRpY0NsYXNzOiBcImZzLTUgYmVzdF9hc2tfaWNvbiBiaVwiIH0pLFxuICAgICAgICAgICAgICBdKSxcbiAgICAgICAgICAgIF0pLFxuICAgICAgICAgIF0pLFxuICAgICAgICBdXG4gICAgICApLFxuICAgIF0pXG4gIH0sXG4gIGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgX3ZtID0gdGhpc1xuICAgIHZhciBfaCA9IF92bS4kY3JlYXRlRWxlbWVudFxuICAgIHZhciBfYyA9IF92bS5fc2VsZi5fYyB8fCBfaFxuICAgIHJldHVybiBfYyhcbiAgICAgIFwiZGl2XCIsXG4gICAgICB7XG4gICAgICAgIHN0YXRpY0NsYXNzOiBcInNlLXByZS1jb24yIHNwaW5uZXItYm9yZGVyIHRleHQtcHJpbWFyeVwiLFxuICAgICAgICBhdHRyczogeyByb2xlOiBcInN0YXR1c1wiIH0sXG4gICAgICB9LFxuICAgICAgW19jKFwic3BhblwiLCB7IHN0YXRpY0NsYXNzOiBcInNyLW9ubHlcIiB9KV1cbiAgICApXG4gIH0sXG4gIGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgX3ZtID0gdGhpc1xuICAgIHZhciBfaCA9IF92bS4kY3JlYXRlRWxlbWVudFxuICAgIHZhciBfYyA9IF92bS5fc2VsZi5fYyB8fCBfaFxuICAgIHJldHVybiBfYyhcImRpdlwiLCB7IHN0YXRpY0NsYXNzOiBcInRhYmxlLXJlc3BvbnNpdmVcIiB9LCBbXG4gICAgICBfYyhcbiAgICAgICAgXCJ0YWJsZVwiLFxuICAgICAgICB7IHN0YXRpY0NsYXNzOiBcInRhYmxlIHRleHQtZGFyayB0YWJsZS1zbSB0YWJsZS1ib3JkZXJsZXNzXCIgfSxcbiAgICAgICAgW1xuICAgICAgICAgIF9jKFwidGhlYWRcIiwgeyBzdGF0aWNDbGFzczogXCJ0ZXh0LW11dGVkXCIgfSwgW1xuICAgICAgICAgICAgX2MoXCJ0aFwiLCB7IGF0dHJzOiB7IHNjb3BlOiBcImNvbFwiIH0gfSwgW192bS5fdihcIlByaWNlXCIpXSksXG4gICAgICAgICAgICBfdm0uX3YoXCIgXCIpLFxuICAgICAgICAgICAgX2MoXCJ0aFwiLCB7IGF0dHJzOiB7IHNjb3BlOiBcImNvbFwiIH0gfSwgW192bS5fdihcIkFtb3VudFwiKV0pLFxuICAgICAgICAgICAgX3ZtLl92KFwiIFwiKSxcbiAgICAgICAgICAgIF9jKFwidGhcIiwgeyBhdHRyczogeyBzY29wZTogXCJjb2xcIiB9IH0sIFtfdm0uX3YoXCJUb3RhbFwiKV0pLFxuICAgICAgICAgIF0pLFxuICAgICAgICBdXG4gICAgICApLFxuICAgICAgX3ZtLl92KFwiIFwiKSxcbiAgICAgIF9jKFwidGFibGVcIiwgeyBzdGF0aWNDbGFzczogXCJhc2tzX29ubHlcIiB9KSxcbiAgICBdKVxuICB9LFxuICBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIF92bSA9IHRoaXNcbiAgICB2YXIgX2ggPSBfdm0uJGNyZWF0ZUVsZW1lbnRcbiAgICB2YXIgX2MgPSBfdm0uX3NlbGYuX2MgfHwgX2hcbiAgICByZXR1cm4gX2MoXCJkaXZcIiwgeyBzdGF0aWNDbGFzczogXCJ0YWJsZS1yZXNwb25zaXZlXCIgfSwgW1xuICAgICAgX2MoXG4gICAgICAgIFwidGFibGVcIixcbiAgICAgICAgeyBzdGF0aWNDbGFzczogXCJ0YWJsZSB0ZXh0LWRhcmsgdGFibGUtc20gdGFibGUtYm9yZGVybGVzc1wiIH0sXG4gICAgICAgIFtcbiAgICAgICAgICBfYyhcInRoZWFkXCIsIHsgc3RhdGljQ2xhc3M6IFwidGV4dC1tdXRlZFwiIH0sIFtcbiAgICAgICAgICAgIF9jKFwidGhcIiwgeyBhdHRyczogeyBzY29wZTogXCJjb2xcIiB9IH0sIFtfdm0uX3YoXCJQcmljZVwiKV0pLFxuICAgICAgICAgICAgX3ZtLl92KFwiIFwiKSxcbiAgICAgICAgICAgIF9jKFwidGhcIiwgeyBhdHRyczogeyBzY29wZTogXCJjb2xcIiB9IH0sIFtfdm0uX3YoXCJBbW91bnRcIildKSxcbiAgICAgICAgICAgIF92bS5fdihcIiBcIiksXG4gICAgICAgICAgICBfYyhcInRoXCIsIHsgYXR0cnM6IHsgc2NvcGU6IFwiY29sXCIgfSB9LCBbX3ZtLl92KFwiVG90YWxcIildKSxcbiAgICAgICAgICBdKSxcbiAgICAgICAgXVxuICAgICAgKSxcbiAgICAgIF92bS5fdihcIiBcIiksXG4gICAgICBfYyhcInRhYmxlXCIsIHsgc3RhdGljQ2xhc3M6IFwiYmlkc19vbmx5XCIgfSksXG4gICAgXSlcbiAgfSxcbl1cbnJlbmRlci5fd2l0aFN0cmlwcGVkID0gdHJ1ZVxuXG5leHBvcnQgeyByZW5kZXIsIHN0YXRpY1JlbmRlckZucyB9IiwidmFyIHJlbmRlciA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIF92bSA9IHRoaXNcbiAgdmFyIF9oID0gX3ZtLiRjcmVhdGVFbGVtZW50XG4gIHZhciBfYyA9IF92bS5fc2VsZi5fYyB8fCBfaFxuICByZXR1cm4gX3ZtLl9tKDApXG59XG52YXIgc3RhdGljUmVuZGVyRm5zID0gW1xuICBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIF92bSA9IHRoaXNcbiAgICB2YXIgX2ggPSBfdm0uJGNyZWF0ZUVsZW1lbnRcbiAgICB2YXIgX2MgPSBfdm0uX3NlbGYuX2MgfHwgX2hcbiAgICByZXR1cm4gX2MoXCJkaXZcIiwgeyBzdGF0aWNDbGFzczogXCIgXCIgfSwgW1xuICAgICAgX2MoXCJkaXZcIiwgeyBhdHRyczogeyBpZDogXCJ0cmFkaW5ndmlld1wiIH0gfSksXG4gICAgXSlcbiAgfSxcbl1cbnJlbmRlci5fd2l0aFN0cmlwcGVkID0gdHJ1ZVxuXG5leHBvcnQgeyByZW5kZXIsIHN0YXRpY1JlbmRlckZucyB9Il0sIm5hbWVzIjpbInhzIiwieCIsInkiLCJ3IiwiaCIsImkiLCJzbSIsIm1kIiwibGciLCJjb21wb25lbnRzIiwiTWFya2V0aW5mbyIsIlRyYWRpbmd2aWV3IiwiT3JkZXJib29rIiwiTWFya2V0cyIsIlRyYWRlcyIsIkdyaWRMYXlvdXQiLCJHcmlkSXRlbSIsImRhdGEiLCJzeW1ib2wiLCJjdXJyZW5jeSIsImFjdGl2ZUl0ZW0iLCJwYWlycyIsInByb3ZpZGVyIiwicHJvdmlkZSIsImxpbWl0IiwidXNlciIsImdubCIsImxheW91dHMiLCJsYXlvdXQiLCJkcmFnZ2FibGUiLCJyZXNpemFibGUiLCJyZXNwb25zaXZlIiwiYm90X3RpbWluZyIsImJvdF90aW1lcyIsImJvdF90eXBlIiwicnVubmluZ0JvdCIsImxvYWRpbmciLCJ0aW1pbmciLCJhbW91bnQiLCJiYWxhbmNlIiwiYm90X2lkIiwidHlwZSIsIm1pbl9hbW91bnQiLCJtYXhfYW1vdW50Iiwid2F0Y2giLCJldmVudExvZyIsImV2ZW50c0RpdiIsIiRyb3V0ZSIsInRvIiwiZnJvbSIsIm1ldGhvZHMiLCJPcmRlciIsInBvc3QiLCJib3RUaW1lIiwidGhlbiIsInNldEJvdCIsImJvdCIsInRpbWVzIiwiJCIsInNldFRpbWluZyIsImR1cmF0aW9uIiwiZmV0Y2hXYWxsZXQiLCJjcmVhdGVXYWxsZXQiLCJpc0FjdGl2ZSIsIm1lbnVJdGVtIiwic2V0QWN0aXZlIiwiZmV0Y2hEYXRhIiwiZ29CYWNrIiwid2luZG93IiwiY3JlYXRlZCIsIm1vdW50ZWQiLCJkZXN0cm95ZWQiLCJwcm9wcyIsInN0YXR1cyIsImNvbXB1dGVkIiwidXBkYXRlVHJhZGVzIiwicmVzIiwiY29sb3IiLCJhcHBlbmQiLCJjc3MiLCJhZGRDbGFzcyIsImxhc3RJZCIsInRhYmxlZCIsImxvb3BUcmFkZXMiLCJkb2N1bWVudCIsImNjeHQiLCJleGNoYW5nZSIsImZvcm1hdFRpbWUiLCJ0aW1lIiwiZGVsYXkiLCJ2YWx1ZSIsInZhbHVlU3RvcmUiLCJ0aWNrIiwidGlja1N0b3JlIiwidGlja0RpZmYiLCJ0aWNrRGlmZlZhbHVlIiwidmFsdWVTdG9yZVRlbXAiLCJ0aWNrU3RvcmVUZW1wIiwic2V0VGltZW91dCIsInN0eWxlIiwiZmlsbCIsInRleHQiLCJNYXRoIiwiY291bnRlciIsImxhc3RfcHJpY2UiLCJkYXlfY2hhbmdlIiwidXBkYXRlVGlja2VyIiwidGlja0VsZW1lbnQiLCJ0aWNrSWNvbiIsInBlcmNlbnRhZ2VFbGVtZW50IiwicGVyY2VudGFnZUljb24iLCJkYXlfdm9sdW1lX2N1cnJlbmN5IiwiZGF5X2hpZ2giLCJkYXlfbG93IiwiZGF5X3ZvbHVtZV9wYWlyIiwibG9vcFRpY2tlciIsInRpY2tlciIsImZvcm1hdFByaWNlIiwicHJpY2UiLCJ3c0Nsb3NlIiwiZmF2cyIsIm9sZCIsIm1hcmtldHMiLCJmZXRjaE1hcmtldHMiLCJmZXRjaEZhdnMiLCJzY3JvbGxMZWZ0Iiwic2Nyb2xsUmlnaHQiLCJhZGRUb1dhdGNobGlzdCIsInBhaXIiLCJyZW1vdmVGcm9tV2F0Y2hsaXN0IiwiaWQiLCJoYW5kbGUiLCJ0aWNrZXJzIiwidGlja2VyRWxlbWVudCIsInRpY2tlckljb24iLCJjaGFuZ2VFbGVtZW50IiwicmVtb3ZlQ2xhc3MiLCJsb29wIiwiZm9ybWF0VG90YWwiLCJ0b3RhbCIsImJlZm9yZVVwZGF0ZSIsImZpbHRlciIsInRyaW0iLCJ0b1VwcGVyQ2FzZSIsImluZGV4T2YiLCJzZWFyY2giLCJlbGVtIiwic29ydCIsInRhYmxlX2NvbnRlbnQiLCJ1bm1vdW50ZWQiLCJ3aWR0aCIsInNvcnREZXB0aCIsImUiLCJtZWRpYW4iLCJtZWRpYW5Vbml0IiwiciIsIm8iLCJpbml0IiwibiIsInQiLCJjb21wdXRCYXJXaWR0aCIsIm51bWJlciIsInMiLCJzaWRlTGVuZ3RoIiwicmVmcmVzaFJhdGUiLCJiZXN0QXNrZXIiLCJsYXN0VXBkYXRlZCIsInVwZGF0ZU9yZGVyYm9vayIsIm5vdyIsIkRhdGUiLCJudW1iZXJfZm9ybWF0IiwiaXRlbSIsImJlc3RfYXNrIiwiYmVzdF9hc2tfSWNvbiIsImJlc3RBc2siLCJiZXN0QmlkIiwibG9vcE9yZGVyYm9vayIsImhlaWdodCIsImludGVydmFsIiwidGltZXpvbmUiLCJ0aGVtZSIsImxvY2FsZSIsInRvb2xiYXJfYmciLCJlbmFibGVfcHVibGlzaGluZyIsImhpZGVfbGVnZW5kIiwic2F2ZV9pbWFnZSIsImNvbnRhaW5lcl9pZCJdLCJzb3VyY2VSb290IjoiIn0=