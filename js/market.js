/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./src/market/configs/defaultOptions.js":
/*!**********************************************!*\
  !*** ./src/market/configs/defaultOptions.js ***!
  \**********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var raw_loader_resources_assets_cors_txt__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! raw-loader!../../../resources/assets/cors.txt */ "./node_modules/raw-loader/dist/cjs.js!./resources/assets/cors.txt");
/**
 * Application options object
 */

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  // cors proxy for outgoing http requests
  proxy: raw_loader_resources_assets_cors_txt__WEBPACK_IMPORTED_MODULE_0__["default"],
  // custom proxy list
  proxylist: [raw_loader_resources_assets_cors_txt__WEBPACK_IMPORTED_MODULE_0__["default"]],
  // notification options
  notify: {
    enabled: true,
    duration: 10
  },
  // notification audio
  audio: {
    enabled: true,
    volume: 0.5,
    file: '../../../../market/audio/audio_2.mp3'
  },
  // search options
  search: {
    fullword: false,
    // must type full search words
    fullcase: false // must type correct word upper/lower case letters

  },
  // live price options
  prices: {
    header: true,
    // show top coins in header
    chart: true,
    // show live price chart in list
    market: 'USDT',
    // default selected market token
    sort: 'marketVolume',
    // price data to sort by
    order: 'desc',
    // price sort direction
    limit: 20 // how many entries to show

  },
  // news related options
  news: {
    enabled: true,
    // enable fetching on a timer
    notify: false,
    // show push notifications for news
    send: false,
    // include news in outgoing notifications (email/telegram)
    interval: 5,
    // how often to try fetching from each source (secs)
    delay: 500,
    // how long to wait before fetching again from each source (secs)
    tweets: 1,
    // how many tweets to fetch at once from each source
    total: 100,
    // how many total tweets to store
    max: 30,
    // max number of news entries to show
    days: 1 // only show entries posted within this number of days

  },
  // binance api config
  binance: {
    enabled: false,
    // status
    apikey: '',
    // api key
    apisecret: '' // api secret

  },
  // mailgun api config
  mailgun: {
    enabled: false,
    // status
    domain: '',
    // account domain
    apikey: '',
    // api key
    email: '' // recipient email

  },
  // telegram bot api config
  telegram: {
    enabled: false,
    // status
    botkey: '',
    // telegram bot id
    userid: '' // recipient chat id

  }
});

/***/ }),

/***/ "./src/market/modules/ajax.js":
/*!************************************!*\
  !*** ./src/market/modules/ajax.js ***!
  \************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ Ajax)
/* harmony export */ });
/* harmony import */ var _store__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./store */ "./src/market/modules/store.js");
/* harmony import */ var _logger__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./logger */ "./src/market/modules/logger.js");
/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./utils */ "./src/market/modules/utils.js");
/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_utils__WEBPACK_IMPORTED_MODULE_2__);
function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }

/**
 * Basic XHR ajax request module
 */


 // ajax class

var Ajax = /*#__PURE__*/function () {
  /**
   * Constructor
   * @param {object}  options  Initial options
   */
  function Ajax(options) {
    _classCallCheck(this, Ajax);

    this._url = null;
    this._options = {
      // save response data to local store cache
      cache: false,
      // key prefix for local store cache
      prefix: 'ajax_data_',
      // proxy url to preppend to outgoing requests
      proxy: ''
    };
    this.setOptions(options);
  }
  /**
   * Merge options
   * @param {object}  options  Options object
   */


  _createClass(Ajax, [{
    key: "setOptions",
    value: function setOptions(options) {
      Object.assign(this._options, options);
    }
    /**
     * Convert object into a query string
     * @param {object}  data  Key/Val data pairs
     */

  }, {
    key: "serializeData",
    value: function serializeData(data) {
      var q = [];

      if (_typeof(data) === 'object') {
        Object.keys(data).forEach(function (k) {
          q.push(encodeURIComponent(k) + '=' + encodeURIComponent(data[k]));
        });
      }

      return q.join('&');
    }
    /**
     * GET request alias
     */

  }, {
    key: "get",
    value: function get(address, options) {
      this.request('GET', address, options);
    }
    /**
     * POST request alias
     */

  }, {
    key: "post",
    value: function post(address, options) {
      this.request('POST', address, options);
    }
    /**
     * PUT request alias
     */

  }, {
    key: "put",
    value: function put(address, options) {
      this.request('PUT', address, options);
    }
    /**
     * DELETE request alias
     */

  }, {
    key: "delete",
    value: function _delete(address, options) {
      this.request('DELETE', address, options);
    }
    /**
     * AJAX request method
     * @param {string}  method   Request method verb
     * @param {string}  address  Endpoint URL
     * @param {object}  options  Request options
     */

  }, {
    key: "request",
    value: function request(method, address, options) {
      var _this = this;

      method = String(method || '').toUpperCase();
      address = String(address || '').trim();
      options = Object.assign({}, this._options, options); // setup options

      var isDone = false;
      var type = String(options.type || 'text');
      var proxy = String(options.proxy || '').trim();
      var timeout = parseInt(options.timeout) || 0;
      var headers = Object.assign({}, options.headers);
      var cacheTime = parseInt(options.cache) || 0; // seconds to be cached

      var cacheKey = options.prefix + _utils__WEBPACK_IMPORTED_MODULE_2___default().unique(method + '|' + address);
      var xhr = new XMLHttpRequest(); // setup callbacks

      var onError = typeof options.error === 'function' ? options.error : function () {};
      var onSuccess = typeof options.success === 'function' ? options.success : function () {};
      var onDone = typeof options.done === 'function' ? options.done : function () {}; // check params

      if (!method) return onError(xhr, 0, 'Must specify a request method to make a new request.');
      if (!address) return onError(xhr, 0, 'Must specify a request url address to make a new request.'); // check cache

      if (cacheTime) {
        var cacheData = _store__WEBPACK_IMPORTED_MODULE_0__["default"].getData(cacheKey);

        if (cacheData) {
          onSuccess(xhr, 200, cacheData);
          onDone(xhr, 200, cacheData);
          isDone = true;
          return;
        }
      } // resolve full request url


      var fullUrl = _utils__WEBPACK_IMPORTED_MODULE_2___default().fullUrl(address);

      try {
        this._url = new URL(fullUrl);
      } catch (err) {} // encode data for get requests


      if (method === 'GET' && _typeof(options.data) === 'object') {
        headers['Content-type'] = 'application/x-www-form-urlencoded';
        fullUrl += '?' + this.serializeData(options.data);
        options.data = null;
      } // init request handler


      xhr.open(method, proxy + fullUrl, true);
      xhr.responseType = type; // set timeout

      if (timeout) {
        xhr.timeout = timeout < 1000 ? 1000 * timeout : timeout;
      } // default headers


      xhr.setRequestHeader('Accept', 'application/json, text/plain, text/html, */*'); // send ajax header unless stated not to

      if (!options.notAjax) {
        xhr.setRequestHeader('X-Requested-With', 'XMLHttpRequest');
      } // check for basic auth data and set header


      if (options.auth && _typeof(options.auth) === 'object') {
        var username = String(options.auth.username || '').trim();
        var password = String(options.auth.password || '').trim();
        xhr.setRequestHeader('Authorization', 'Basic ' + btoa(username + ':' + password));
      } // custom headers


      Object.keys(headers).forEach(function (name) {
        xhr.setRequestHeader(name, headers[name]);
      }); // data load handler

      xhr.addEventListener('load', function (e) {
        var _this$_responseParams = _this._responseParams('load', xhr, type),
            status = _this$_responseParams.status,
            response = _this$_responseParams.response,
            error = _this$_responseParams.error;

        (0,_logger__WEBPACK_IMPORTED_MODULE_1__["default"])(status, method, fullUrl);
        (0,_logger__WEBPACK_IMPORTED_MODULE_1__["default"])(response);

        if (status && status < 400) {
          if (cacheTime) _store__WEBPACK_IMPORTED_MODULE_0__["default"].setData(cacheKey, response, cacheTime);
          onSuccess(xhr, status, response);
        } else {
          onError(xhr, status, error);
        }

        if (!isDone) onDone(xhr, status, response);
        isDone = true;
      }); // request error handler

      xhr.addEventListener('error', function (e) {
        var _this$_responseParams2 = _this._responseParams('error', xhr, type),
            status = _this$_responseParams2.status,
            response = _this$_responseParams2.response,
            error = _this$_responseParams2.error;

        onError(xhr, status, error);
        if (!isDone) onDone(xhr, status, response);
        isDone = true;
      }); // request abort handler

      xhr.addEventListener('abort', function (e) {
        var _this$_responseParams3 = _this._responseParams('abort', xhr, type),
            status = _this$_responseParams3.status,
            response = _this$_responseParams3.response,
            error = _this$_responseParams3.error;

        onError(xhr, status, error);
        if (!isDone) onDone(xhr, status, response);
        isDone = true;
      }); // request timeout handler

      xhr.addEventListener('timeout', function (e) {
        var _this$_responseParams4 = _this._responseParams('timeout', xhr, type),
            status = _this$_responseParams4.status,
            response = _this$_responseParams4.response,
            error = _this$_responseParams4.error;

        onError(xhr, status, error);
        if (!isDone) onDone(xhr, status, response);
        isDone = true;
      }); // send the request

      xhr.send(options.data || null);
    }
    /**
     * Parse information about the response
     * @param {string}  evt   Event type
     * @param {object}  xhr   XMLHttpRequest object
     * @param {string}  type  Expected response type
     */

  }, {
    key: "_responseParams",
    value: function _responseParams(evt, xhr, type) {
      var hostname = this._url.hostname || 'nohost';
      var status = xhr.status | 0;
      var response = type === 'text' ? xhr.responseText : xhr.response;
      var error = '';

      if (evt === 'load' && status >= 400 && response) {
        error = "".concat(hostname, "(").concat(status, "): ") + this._dataReduce(response);
      }

      if (evt === 'error') {
        error = "".concat(hostname, "(").concat(status, "): The request has been aborted due to a network related problem.");
      }

      if (evt === 'abort') {
        error = "".concat(hostname, "(").concat(status, "): The request has been aborted by the client before completing.");
      }

      if (evt === 'timeout') {
        error = "".concat(hostname, "(").concat(status, "): The request has been aborted due to the server not responding.");
      }

      if ((status <= 0 || status >= 400) && !error) {
        error = "".concat(hostname, "(").concat(status, "): The request was rejected by the server and no error message was given.");
      }

      return {
        status: status,
        response: response,
        error: error
      };
    }
    /**
     * Reduce data object into a single string line.
     * @param {object}  data     Object or string to be scanned
     * @param {array}   output   Output array
     */

  }, {
    key: "_dataReduce",
    value: function _dataReduce(data, output) {
      var _this2 = this;

      output = output || [];

      if (data && typeof data === 'string') {
        output.push(data);
      } else if (data && _typeof(data) === 'object') {
        Object.keys(data).forEach(function (key) {
          _this2._dataReduce(data[key], output);
        });
      }

      return output.join(' | ').replace(/[\t\r\n\s]+/g, ' ').trim();
    }
  }]);

  return Ajax;
}();



/***/ }),

/***/ "./src/market/modules/alarms.js":
/*!**************************************!*\
  !*** ./src/market/modules/alarms.js ***!
  \**************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ Alarms)
/* harmony export */ });
/* harmony import */ var _bus__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./bus */ "./src/market/modules/bus.js");
/* harmony import */ var _store__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./store */ "./src/market/modules/store.js");
/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./utils */ "./src/market/modules/utils.js");
/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_utils__WEBPACK_IMPORTED_MODULE_2__);
function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

/**
 * Price alarms helper class
 */




var Alarms = /*#__PURE__*/function (_Bus) {
  _inherits(Alarms, _Bus);

  var _super = _createSuper(Alarms);

  /**
   * Constructor
   */
  function Alarms(options) {
    var _this;

    _classCallCheck(this, Alarms);

    _this = _super.call(this);
    _this._alarms = [];
    _this._options = Object.assign({
      // key used for storage
      key: 'alarms_data' // ...

    }, options);
    return _this;
  }
  /**
   * Save current alarms data to store and emit list
   */


  _createClass(Alarms, [{
    key: "saveData",
    value: function saveData() {
      this.emit('update', this._alarms);
      _store__WEBPACK_IMPORTED_MODULE_1__["default"].setData(this._options.key, this._alarms);
    }
    /**
     * Load saved history data from store
     */

  }, {
    key: "loadData",
    value: function loadData() {
      var data = _store__WEBPACK_IMPORTED_MODULE_1__["default"].getData(this._options.key);
      if (!data || !Array.isArray(data)) return;
      this._alarms = data;
      this.emit('update', this._alarms);
    }
    /**
     * Get count of active alarms for a symbol
     * @param {string}  symbol  Pair symbol string
     */

  }, {
    key: "getCount",
    value: function getCount(symbol) {
      return this._alarms.filter(function (a) {
        return a.symbol === symbol && a.active;
      }).length;
    }
    /**
     * Adds an alarm for a pair
     * @param {object}  pairData  Pair data object from binance socket class
     * @param {number}  price     Alarm price
     */

  }, {
    key: "add",
    value: function add(pairData, price) {
      if (!pairData || !pairData.symbol || !pairData.close) return false;
      var symbol = pairData.symbol,
          token = pairData.token,
          asset = pairData.asset,
          pair = pairData.pair,
          image = pairData.image,
          close = pairData.close;
      close = parseFloat(close) || 0; // current price

      price = parseFloat(price) || 0; // alarm price

      if (!close || !price || close === price) return false;
      if (this.find(symbol, price).length) return false;
      var id = _utils__WEBPACK_IMPORTED_MODULE_2___default().randString(20);
      var time = Date.now();
      var active = true;
      var arrow = price > close ? '▲' : '▼';
      var sign = price > close ? '≥' : '≤';
      var check = price > close ? 'gain' : 'loss';
      var alarm = {
        id: id,
        time: time,
        active: active,
        arrow: arrow,
        sign: sign,
        check: check,
        symbol: symbol,
        token: token,
        asset: asset,
        pair: pair,
        image: image,
        close: close,
        price: price
      };

      this._alarms.push(alarm);

      this.saveData();
      return true;
    }
    /**
     * Find existing alarms for a symbol and price
     * @param {string}  symbol  Pair symbol string
     * @param {number}  price   Alarm price
     */

  }, {
    key: "find",
    value: function find(symbol, price) {
      price = parseFloat(price) || 0;
      return this._alarms.filter(function (a) {
        return a.symbol === symbol && a.price === price;
      });
    }
    /**
     * Remove an alarm from the list by ID
     * @param {string}  id  Unique alarm ID
     */

  }, {
    key: "remove",
    value: function remove(id) {
      if (!id || typeof id !== 'string') return;
      this._alarms = this._alarms.filter(function (a) {
        return a.id !== id;
      });
      this.saveData();
    }
    /**
     * Toggle status for an alarm by ID
     * @param {string}   id      Unique alarm ID
     * @param {boolean}  active  Alarm active status
     */

  }, {
    key: "toggle",
    value: function toggle(id, active) {
      if (!id || typeof id !== 'string') return;
      if (typeof active !== 'boolean') return;

      this._alarms.forEach(function (a) {
        if (a.id !== id) return;
        a.active = active;
      });

      this.saveData();
    }
    /**
     * Flush all alarms
     */

  }, {
    key: "flush",
    value: function flush() {
      this._alarms = [];
      this.saveData();
    }
    /**
     * Check price of a symbol against all saved alarms
     * @param {string}   symbol    Pair symbol string
     * @param {number}   close     Current pair close price
     * @param {function} callback  Callback handler
     */

  }, {
    key: "check",
    value: function check(symbol, close, callback) {
      var count = 0;

      for (var i = 0; i < this._alarms.length; ++i) {
        var a = this._alarms[i];
        var price = Number(a.price || 0);
        if (a.symbol !== symbol || !a.active) continue;
        if (a.check === 'loss' && close > price) continue;
        if (a.check === 'gain' && close < price) continue;
        var diff = 'equal to';
        if (close > price) diff = 'more than';
        if (close < price) diff = 'less than';
        var closeFixed = Number(close).toFixed(8);
        var priceFixed = Number(price).toFixed(8);
        var title = "".concat(a.symbol, " price ").concat(a.arrow, " ").concat(closeFixed, " ").concat(a.asset);
        var info = "".concat(a.symbol, " is now ").concat(diff, " your alarm price of ").concat(priceFixed, " ").concat(a.asset, ".");
        callback(title, info, a);
        a.active = false;
        count++;
      } // save alarms data if alarms were triggered


      if (count) this.saveData();
    }
  }]);

  return Alarms;
}(_bus__WEBPACK_IMPORTED_MODULE_0__["default"]);



/***/ }),

/***/ "./src/market/modules/binance.js":
/*!***************************************!*\
  !*** ./src/market/modules/binance.js ***!
  \***************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ Binance)
/* harmony export */ });
/* harmony import */ var _bus__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./bus */ "./src/market/modules/bus.js");
/* harmony import */ var _symbol__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./symbol */ "./src/market/modules/symbol.js");
/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./utils */ "./src/market/modules/utils.js");
/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_utils__WEBPACK_IMPORTED_MODULE_2__);
function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }

function _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it["return"] != null) it["return"](); } finally { if (didErr) throw err; } } }; }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

/**
 * Binance socket api wrapper class
 */




var Binance = /*#__PURE__*/function (_Bus) {
  _inherits(Binance, _Bus);

  var _super = _createSuper(Binance);

  /**
   * Constructor
   */
  function Binance() {
    var _this;

    _classCallCheck(this, Binance);

    _this = _super.call(this);
    _this._ajax = null;
    _this._apiurl = 'https://api.binance.com/api';
    _this._wssurl = 'wss://stream.binance.com:9443';
    _this._apikey = ''; // binance API key

    _this._apisecret = ''; // binance API secret

    _this._listenkey = ''; // user stream listen key

    _this._wait = 10000; // reconnect wait (mils)

    _this._coindata = {}; // data about each token

    _this._symbols = {}; // unique symbols data cache

    _this._markets = {}; // available markets and total assets

    _this._reconnect = {};
    _this._timers = {};
    _this._socks = {};
    return _this;
  }
  /**
   * Set ajax module reference to use for requests
   */


  _createClass(Binance, [{
    key: "useAjax",
    value: function useAjax(ajax) {
      this._ajax = ajax;
    }
    /**
     * Set API key
     */

  }, {
    key: "setApiKey",
    value: function setApiKey() {
      var key = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';
      this._apikey = String(key || '').trim();
    }
    /**
     * Set API secret
     */

  }, {
    key: "setApiSecret",
    value: function setApiSecret() {
      var secret = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';
      this._apisecret = String(secret || '').trim();
    }
    /**
     * Set coins data fetched from somewhere else
     */

  }, {
    key: "setCoinData",
    value: function setCoinData() {
      var data = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      this._coindata = Object.assign(this._coindata, data);
    }
    /**
     * Set socket reconnect boolean for an id
     */

  }, {
    key: "setReconnect",
    value: function setReconnect(id, toggle) {
      this._reconnect[id] = toggle ? true : false;
    }
    /**
     * Check reconnect toggle for an id and call a handler function
     */

  }, {
    key: "checkReconnect",
    value: function checkReconnect(id, callback) {
      if (!this._reconnect[id]) return;
      setTimeout(callback, this._wait);
    }
    /**
     * Get public api endpoint url
     */

  }, {
    key: "getPublicUrl",
    value: function getPublicUrl(endpoint, params) {
      var qstr = this._ajax.serializeData(Object.assign({}, params));

      return this._apiurl + endpoint + '?' + qstr;
    }
    /**
     * Get user signed api endpoint url
     */

  }, {
    key: "getSignedUrl",
    value: function getSignedUrl(endpoint, params) {
      var crypto = window.CryptoJS || null;
      var recvWindow = 100000;
      var timestamp = Date.now() - recvWindow / 2;

      var qstr = this._ajax.serializeData(Object.assign({
        recvWindow: recvWindow,
        timestamp: timestamp
      }, params));

      var signature = crypto ? crypto.HmacSHA256(qstr, this._apisecret).toString(crypto.enc.Hex) : '';
      return this._apiurl + endpoint + '?' + qstr + '&signature=' + signature;
    }
    /**
     * Fetch data about available markets form exchange
     */

  }, {
    key: "fetchMarketsData",
    value: function fetchMarketsData() {
      var _this2 = this;

      if (!this._ajax) return;
      var remote = "".concat(this._apiurl, "/v3/exchangeInfo");
      var local = "../../../../public/market/json/exchangeInfo.json"; // build markets data and emit it out

      var handleResponse = function handleResponse(res) {
        if (res && Array.isArray(res.symbols)) {
          var _iterator = _createForOfIteratorHelper(res.symbols),
              _step;

          try {
            var _loop = function _loop() {
              var symb = _step.value;
              var token = symb.quoteAsset; // market

              var count = res.symbols.filter(function (s) {
                return s.quoteAsset === token && s.baseAsset !== token && s.status === 'TRADING';
              }).length;
              _this2._markets[token] = {
                token: token,
                count: count
              };
            };

            for (_iterator.s(); !(_step = _iterator.n()).done;) {
              _loop();
            }
          } catch (err) {
            _iterator.e(err);
          } finally {
            _iterator.f();
          }

          _this2.emit('markets_data', _this2._markets);
        }
      }; // try remote, then local if it fails


      this._ajax.get(remote, {
        type: 'json',
        success: function success(xhr, status, res) {
          return handleResponse(res);
        },
        error: function error(xhr, status, err) {
          _this2._ajax.get(local, {
            type: 'json',
            proxy: false,
            success: function success(xhr, status, res) {
              return handleResponse(res);
            }
          });
        }
      });
    }
    /**
     * Fetch last 24h candle data
     */

  }, {
    key: "fetchChartData",
    value: function fetchChartData(symbol, cb) {
      var _this3 = this;

      if (!this._ajax || !symbol) return;
      var endpoint = "".concat(this._apiurl, "/v3/klines?symbol=").concat(symbol, "&interval=1h&limit=168");
      var prices = [];

      this._ajax.get(endpoint, {
        type: 'json',
        // cache: 600,
        success: function success(xhr, status, res) {
          if (res && Array.isArray(res)) {
            for (var i = 0; i < res.length; ++i) {
              prices.push(parseFloat(res[i][4])); // close price
            }
          }

          if (typeof cb === 'function') cb(prices);

          _this3.emit('chart_data', {
            symbol: symbol,
            prices: prices
          });
        },
        error: function error(xhr, status, err) {
          if (typeof cb === 'function') cb(prices);
          console.warn(err);
        }
      });
    }
    /**
     * Parse user balances data
     */

  }, {
    key: "parseUserBalances",
    value: function parseUserBalances(data) {
      var _this4 = this;

      var balances = [];
      if (Array.isArray(data)) balances = data; // as-is

      if (Array.isArray(data.balances)) balances = data.balances; // http

      if (Array.isArray(data.B)) balances = data.B; // websocket

      balances = balances.map(function (t) {
        var asset = String(t.a || t.asset || '');
        var pair = asset === 'BTC' ? 'USDT' : 'BTC';
        var route = '/symbol/' + asset + pair;
        var name = _this4._names[asset] || asset;
        var free = parseFloat(t.f || t.free) || 0;
        var locked = parseFloat(t.l || t.locked) || 0;
        var total = free + locked;
        return {
          asset: asset,
          name: name,
          route: route,
          free: free,
          locked: locked,
          total: total
        };
      });
      return balances.filter(function (t) {
        return t.total > 0;
      });
    }
    /**
     * Parse order data from an API/Socket response and combine it with symbol data
     * @param {object}  data  Order data response
     */

  }, {
    key: "parseOrderData",
    value: function parseOrderData(data) {
      var now = Date.now();
      var time = Number(data.T || data.transactTime || now); // transaction time

      var id = String(data.i || data.orderId || ''); // order id

      var symbol = String(data.s || data.symbol || ''); // trade pair symbol

      var side = String(data.S || data.side || ''); // book side (BUY, SELL)

      var type = String(data.o || data.type || ''); // order type (LIMIT, MARKET, etc)

      var status = String(data.X || data.status || ''); // order status (NEW, CANCELED, FILLED, etc)

      var price = Number(data.p || data.price || 0); // order book price

      var quantity = Number(data.q || data.origQty || 0); // original trade quantity

      var filled = Number(data.z || data.executedQty || 0); // filled trade quantity

      var total = Number(data.Z || data.cummulativeQuoteQty || 0); // total trade asset cost

      var feeAsset = String(data.N || ''); // fee asset used for commission (BNB, etc)

      var feeAmount = Number(data.n || 0); // fee commission amount

      var percent = Number(filled / quantity * 100); // filled percent
      // resolve available amount after token fee has been deducted

      var smb = this._symbols[symbol] || new _symbol__WEBPACK_IMPORTED_MODULE_1__["default"](symbol);
      var amount = feeAsset === smb.token ? quantity - feeAmount : quantity;
      var unique = _utils__WEBPACK_IMPORTED_MODULE_2___default().unique(symbol + '|' + Math.floor(amount));
      status = status === 'NEW' ? 'OPEN' : status;

      if (!price && total) {
        price = total / quantity;
      }

      if (!total && price) {
        total = price * quantity;
      }

      return smb.getData({
        id: id,
        unique: unique,
        side: side,
        time: time,
        type: type,
        status: status,
        price: price,
        quantity: quantity,
        filled: filled,
        amount: amount,
        total: total,
        feeAsset: feeAsset,
        feeAmount: feeAmount,
        percent: percent
      });
    }
    /**
     * Build fake order data
     * @param {string}  symbol    Full trading symbol
     * @param {string}  type      Order type (LIMIT, MARKET)
     * @param {string}  side      Book side (BUY, SELL)
     * @param {number}  price     Book price
     * @param {number}  quantity  Order quantity
     */

  }, {
    key: "fakeOrderData",
    value: function fakeOrderData(symbol, type, side, price, quantity, status) {
      var time = Date.now();
      var id = _utils__WEBPACK_IMPORTED_MODULE_2___default().randString(20);
      var priceStr = Number(price).toFixed(8);
      var quantityStr = Number(quantity).toFixed(0);
      var totalStr = Number(price * quantity).toFixed(8);
      return this.parseOrderData({
        symbol: symbol,
        orderId: id,
        transactTime: time,
        price: priceStr,
        origQty: quantityStr,
        executedQty: quantityStr,
        cummulativeQuoteQty: totalStr,
        status: status,
        type: type,
        side: side
      });
    }
    /**
     * Simulate an order with fake API request
     * @param {string}  symbol    Full trading symbol
     * @param {string}  type      Order type (LIMIT, MARKET)
     * @param {string}  side      Book side (BUY, SELL)
     * @param {number}  price     Book price
     * @param {number}  quantity  Order quantity
     */

  }, {
    key: "placeFakeOrder",
    value: function placeFakeOrder(symbol, type, side, price, quantity) {
      var _this5 = this;

      var secs = Math.floor(1000 + Math.random() * 4000); // 1-5 secs

      var orderOpen = this.fakeOrderData(symbol, type, side, price, quantity, 'OPEN');
      var orderFilled = this.fakeOrderData(symbol, type, side, price, quantity, 'FILLED');
      var orderCanceled = this.fakeOrderData(symbol, type, side, price, quantity, 'CANCELED');
      var orderResult = secs < 4900 ? orderFilled : orderCanceled;
      setTimeout(function () {
        _this5.emit('book_create', orderOpen);
      }, 300); // added to book

      setTimeout(function () {
        _this5.emit('user_order', orderResult);
      }, secs); // filled or canceled
    }
    /**
     * Place new order in book
     * @param {string}  symbol    Full trading symbol
     * @param {string}  type      Order type (LIMIT, MARKET)
     * @param {string}  side      Book side (BUY, SELL)
     * @param {number}  price     Book price
     * @param {number}  quantity  Order quantity
     * @param {string}  inforce   Time inforce type (GTC, IOC, FOK)
     */

  }, {
    key: "placeOrder",
    value: function placeOrder(symbol, type, side, price, quantity, inforce) {
      var _this6 = this;

      if (!this._apikey || !this._ajax) return;
      if (!symbol || !type || !side || !quantity || quantity <= 0) return;
      price = Number(price).toFixed(8);
      quantity = Number(quantity).toFixed(0);
      inforce = String(inforce || 'FOK');
      var params = {
        symbol: symbol,
        side: side,
        type: type,
        quantity: quantity
      };
      if (type === 'LIMIT') Object.assign(params, {
        price: price,
        timeInForce: inforce
      });
      Object.assign(params, {
        newOrderRespType: 'RESULT'
      });

      this._ajax.post(this.getSignedUrl('/v3/order', params), {
        type: 'json',
        headers: {
          'X-MBX-APIKEY': this._apikey
        },
        success: function success(xhr, status, response) {
          var order = _this6.parseOrderData(response);

          _this6.emit('book_create', order);
        },
        error: function error(xhr, status, _error) {
          var order = _this6.fakeOrderData(symbol, type, side, price, quantity, 'REJECTED');

          _this6.emit('book_fail', order, _error);
        }
      });
    }
    /**
     * Cancel order from book
     * @param {string}  symbol    Full trading symbol
     * @param {number}  orderId   Order ID number
     * @param {number}  quantity  Order quantity
     */

  }, {
    key: "cancelOrder",
    value: function cancelOrder(symbol, orderId, quantity) {
      var _this7 = this;

      if (!this._apikey || !this._ajax) return;
      if (!symbol || !orderId) return;

      this._ajax["delete"](this.getSignedUrl('/v3/order', {
        symbol: symbol,
        orderId: orderId
      }), {
        type: 'json',
        headers: {
          'X-MBX-APIKEY': this._apikey
        },
        success: function success(xhr, status, response) {
          var order = _this7.fakeOrderData(symbol, 'MARKET', 'CANCEL', 1, quantity, 'COMPLETE');

          _this7.emit('book_cancel', order);
        },
        error: function error(xhr, status, _error2) {
          var order = _this7.fakeOrderData(symbol, 'MARKET', 'CANCEL', 1, quantity, 'FAILED');

          _this7.emit('book_fail', order, _error2);
        }
      });
    }
    /**
     * Get user account data over ajax
     */

  }, {
    key: "fetchUserAccount",
    value: function fetchUserAccount() {
      var _this8 = this;

      if (!this._apikey || !this._ajax) return;

      this._ajax.get(this.getSignedUrl('/v3/account'), {
        type: 'json',
        headers: {
          'X-MBX-APIKEY': this._apikey
        },
        success: function success(xhr, status, response) {
          var balances = _this8.parseUserBalances(response);

          _this8.emit('user_balances', balances);

          _this8.emit('user_data', true);
        },
        error: function error(xhr, status, _error3) {
          _this8.emit('user_fail', _error3);

          _this8.stopUserStream();
        }
      });
    }
    /**
     * Fetch current open orders
     */

  }, {
    key: "fetchOpenOrders",
    value: function fetchOpenOrders() {
      var _this9 = this;

      if (!this._apikey || !this._ajax) return;

      this._ajax.get(this.getSignedUrl('/v3/openOrders'), {
        type: 'json',
        headers: {
          'X-MBX-APIKEY': this._apikey
        },
        success: function success(xhr, status, response) {
          response.forEach(function (o) {
            return _this9.emit('user_order', _this9.parseOrderData(o));
          });

          _this9.emit('user_data', true);
        },
        error: function error(xhr, status, _error4) {
          _this9.emit('user_fail', _error4);
        }
      });
    }
    /**
     * Attempt to start a new user stream
     */

  }, {
    key: "initUserStream",
    value: function initUserStream(reconnect) {
      var _this10 = this;

      if (!this._apikey || !this._ajax) return;
      this.emit('user_init', Date.now());
      this.stopUserStream();

      this._ajax.post(this.getPublicUrl('/v1/userDataStream'), {
        type: 'json',
        headers: {
          'X-MBX-APIKEY': this._apikey
        },
        success: function success(xhr, status, response) {
          var time = 1000 * 60 * 20; // 20 mins

          var func = _this10.extendStreamKey.bind(_this10);

          _this10._listenkey = String(response.listenKey || '').trim();

          _this10.emit('user_listenkey', _this10._listenkey);

          _this10.startUserStream(_this10._listenkey, reconnect);

          _this10.startTimer('user', time, func, false);
        },
        error: function error(xhr, status, _error5) {
          _this10.emit('user_fail', _error5);
        }
      });
    }
    /**
     * Extend user stream listen key
     */

  }, {
    key: "extendStreamKey",
    value: function extendStreamKey() {
      var _this11 = this;

      if (!this._apikey || !this._ajax) return;
      if (!this._listenkey) return;

      this._ajax.put(this.getPublicUrl('/v1/userDataStream', {
        listenKey: this._listenkey
      }), {
        type: 'json',
        headers: {
          'X-MBX-APIKEY': this._apikey
        },
        success: function success(xhr, status, response) {
          _this11.emit('user_listenkey', _this11._listenkey);
        }
      });
    }
    /**
     * Connect to a live user account data stream
     */

  }, {
    key: "startUserStream",
    value: function startUserStream(listenKey, reconnect) {
      var _this12 = this;

      this.setReconnect('user', reconnect || false);
      this.emit('user_init', Date.now());
      var ws = this.sockConnect('user', this._wssurl + '/ws/' + listenKey);
      if (!ws) return this.emit('user_fail', 'Could not connect to user stream API endpoint.');
      ws.addEventListener('open', function (e) {
        _this12.emit('user_open', e);

        _this12.fetchUserAccount();

        _this12.fetchOpenOrders();
      });
      ws.addEventListener('error', function (e) {
        _this12.emit('user_error', e);

        _this12.stopTimer('user');
      });
      ws.addEventListener('close', function (e) {
        _this12.emit('user_close', e);

        _this12.stopTimer('user');

        _this12.checkReconnect('user', function () {
          return _this12.startUserStream(listenKey, reconnect);
        });
      });
      ws.addEventListener('message', function (e) {
        _this12.emit('user_data', true);

        var data = JSON.parse(e.data || '{}') || {};

        if (data.e === 'outboundAccountInfo') {
          var balances = _this12.parseUserBalances(data);

          return _this12.emit('user_balances', balances);
        }

        if (data.e === 'executionReport') {
          var order = _this12.parseOrderData(data);

          return _this12.emit('user_order', order);
        }
      });
    }
    /**
     * Stop user stream
     */

  }, {
    key: "stopUserStream",
    value: function stopUserStream() {
      this.setReconnect('user', false);
      this.stopTimer('user');
      this.sockClose('user');
    }
    /**
     * Connect to live ticker prices socket endpoint
     */

  }, {
    key: "startTickerStream",
    value: function startTickerStream(reconnect) {
      var _this13 = this;

      this.setReconnect('ticker', reconnect || false);
      this.emit('ticker_init', Date.now());
      var ws = this.sockConnect('ticker', this._wssurl + '/ws/!ticker@arr');
      if (!ws) return this.emit('ticker_fail', 'Could not connect to live ticker stream API endpoint.');
      ws.addEventListener('open', function (e) {
        _this13.emit('ticker_open', e);

        _this13.startTickerTimer();
      });
      ws.addEventListener('error', function (e) {
        _this13.emit('ticker_error', e);

        _this13.stopTimer('ticker');
      });
      ws.addEventListener('close', function (e) {
        _this13.emit('ticker_close', e);

        _this13.stopTimer('ticker');

        _this13.checkReconnect('ticker', function () {
          return _this13.startTickerStream(reconnect);
        });
      });
      ws.addEventListener('message', function (e) {
        _this13.emit('ticker_data', true);

        var list = JSON.parse(e.data || '[]') || [];
        var markets = Object.keys(_this13._markets);
        var count = list.length; // wait for markets data to be available before creating symbols

        if (!markets.length || !count) return;

        while (count--) {
          var ticker = list[count];
          var pair = ticker.s; // trading pair symbol str

          var symbol = _this13._symbols[pair] || new _symbol__WEBPACK_IMPORTED_MODULE_1__["default"](pair); // cached

          symbol.splitSymbol(markets); // split pair symbol into token / market

          symbol.setCoinData(_this13._coindata[symbol.token]); // data from coincap.io

          symbol.setTickerData(ticker); // update symbol ticker data

          symbol.resolveImage(); // find an icon for this token

          _this13._symbols[pair] = symbol; // update cache
        }
      });
    }
    /**
     * Start ticker data timer
     */

  }, {
    key: "startTickerTimer",
    value: function startTickerTimer() {
      var _this14 = this;

      this.stopTimer('ticker');
      this.startTimer('ticker', 1000, function () {
        var keys = Object.keys(_this14._symbols);
        var count = keys.length;
        var prices = [];

        while (count--) {
          prices.push(_this14._symbols[keys[count]]);
        }

        _this14.emit('ticker_prices', prices);
      }, true);
    }
    /**
     * Stop price ticker
     */

  }, {
    key: "stopTickerStream",
    value: function stopTickerStream() {
      this.setReconnect('ticker', false);
      this.stopTimer('ticker');
      this.sockClose('ticker');
    }
    /**
     * Start custom timer
     * @param {string}    id        Timer id name
     * @param {number}    time      Interval mils
     * @param {function}  callback  Callback function
     * @param {boolean}   init      Init callback
     */

  }, {
    key: "startTimer",
    value: function startTimer(id, time, callback, init) {
      this.stopTimer(id);
      this._timers[id] = setInterval(callback, time);
      if (init) callback();
    }
    /**
     * Stop custom timer
     * @param {string}  id  Timer id name
     */

  }, {
    key: "stopTimer",
    value: function stopTimer(id) {
      if (!id || !this._timers.hasOwnProperty(id)) return;
      clearInterval(this._timers[id]);
      delete this._timers[id];
    }
    /**
     * Create a WebSocket connection
     * @param {string}  id      Ref id name
     * @param {string}  endpoint  Socket endpoint url
     */

  }, {
    key: "sockConnect",
    value: function sockConnect(id, endpoint) {
      if (!id || !endpoint) return;
      this.emit('sock_init', endpoint);
      this.sockClose(id);

      if (!('WebSocket' in window)) {
        this.emit('sock_fail', 'This web browser does not have WebSocket support.');
        return false;
      }

      try {
        var ws = new WebSocket(endpoint);
        this._socks[id] = ws;
        return ws;
      } catch (err) {
        var message = String(err.message || 'WebSocket endpoint connection failed for (' + endpoint + ').');
        this.emit('sock_fail', message);
        return false;
      }
    }
    /**
     * Close socket connection and remove it from the list
     * @param {string}  id  Socket id name
     */

  }, {
    key: "sockClose",
    value: function sockClose(id) {
      if (!id || !this._socks.hasOwnProperty(id)) return;
      this.emit('sock_close', id);

      this._socks[id].close();

      delete this._socks[id];
    }
    /**
     * Close all active socket connections
     */

  }, {
    key: "sockCloseAll",
    value: function sockCloseAll() {
      var _this15 = this;

      Object.keys(this._socks).forEach(function (id) {
        return _this15.sockClose(id);
      });
    }
  }]);

  return Binance;
}(_bus__WEBPACK_IMPORTED_MODULE_0__["default"]);



/***/ }),

/***/ "./src/market/modules/bus.js":
/*!***********************************!*\
  !*** ./src/market/modules/bus.js ***!
  \***********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ Bus)
/* harmony export */ });
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }

/**
 * Basic event bus class
 */
var Bus = /*#__PURE__*/function () {
  /**
   * Constructor
   */
  function Bus() {
    _classCallCheck(this, Bus);

    this._events = {};
  }
  /**
   * Register an event handler
   * @param {string}    name      Event name
   * @param {function}  callback  Event callback function
   */


  _createClass(Bus, [{
    key: "on",
    value: function on(name, callback) {
      if (!name || typeof name !== 'string') return;
      if (typeof callback !== 'function') return;
      if (!this._events.hasOwnProperty(name)) this._events[name] = [];

      this._events[name].push(callback);
    }
    /**
     * Emit an event by name (first arg) with rest of args passed to it
     */

  }, {
    key: "emit",
    value: function emit() {
      var args = Array.from(arguments);
      var name = args.length ? args.shift() : '';

      if (this._events.hasOwnProperty(name)) {
        for (var i = 0; i < this._events[name].length; ++i) {
          var cb = this._events[name][i];
          cb.apply(cb, args);
        }
      }

      args = undefined; // gc
    }
  }]);

  return Bus;
}();



/***/ }),

/***/ "./src/market/modules/coinbasepro.js":
/*!*******************************************!*\
  !*** ./src/market/modules/coinbasepro.js ***!
  \*******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ Coinbasepro)
/* harmony export */ });
/* harmony import */ var _bus__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./bus */ "./src/market/modules/bus.js");
/* harmony import */ var _symbol__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./symbol */ "./src/market/modules/symbol.js");
/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./utils */ "./src/market/modules/utils.js");
/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_utils__WEBPACK_IMPORTED_MODULE_2__);
function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }

function _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it["return"] != null) it["return"](); } finally { if (didErr) throw err; } } }; }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

/**
 * Coinbasepro socket api wrapper class
 */




var Coinbasepro = /*#__PURE__*/function (_Bus) {
  _inherits(Coinbasepro, _Bus);

  var _super = _createSuper(Coinbasepro);

  /**
   * Constructor
   */
  function Coinbasepro() {
    var _this;

    _classCallCheck(this, Coinbasepro);

    _this = _super.call(this);
    _this._ajax = null;
    _this._apiurl = 'https://api.exchange.coinbase.com/';
    _this._wssurl = 'wss://ws-feed.exchange.coinbase.com';
    _this._apikey = ''; // API key

    _this._apisecret = ''; // API secret

    _this._listenkey = ''; // user stream listen key

    _this._wait = 10000; // reconnect wait (mils)

    _this._coindata = {}; // data about each token

    _this._symbols = {}; // unique symbols data cache

    _this._markets = {}; // available markets and total assets

    _this._reconnect = {};
    _this._timers = {};
    _this._socks = {};
    return _this;
  }
  /**
   * Set ajax module reference to use for requests
   */


  _createClass(Coinbasepro, [{
    key: "useAjax",
    value: function useAjax(ajax) {
      this._ajax = ajax;
    }
    /**
     * Set API key
     */

  }, {
    key: "setApiKey",
    value: function setApiKey() {
      var key = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';
      this._apikey = String(key || '').trim();
    }
    /**
     * Set API secret
     */

  }, {
    key: "setApiSecret",
    value: function setApiSecret() {
      var secret = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';
      this._apisecret = String(secret || '').trim();
    }
    /**
     * Set coins data fetched from somewhere else
     */

  }, {
    key: "setCoinData",
    value: function setCoinData() {
      var data = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      this._coindata = Object.assign(this._coindata, data);
    }
    /**
     * Set socket reconnect boolean for an id
     */

  }, {
    key: "setReconnect",
    value: function setReconnect(id, toggle) {
      this._reconnect[id] = toggle ? true : false;
    }
    /**
     * Check reconnect toggle for an id and call a handler function
     */

  }, {
    key: "checkReconnect",
    value: function checkReconnect(id, callback) {
      if (!this._reconnect[id]) return;
      setTimeout(callback, this._wait);
    }
    /**
     * Get public api endpoint url
     */

  }, {
    key: "getPublicUrl",
    value: function getPublicUrl(endpoint, params) {
      var qstr = this._ajax.serializeData(Object.assign({}, params));

      return this._apiurl + endpoint + '?' + qstr;
    }
    /**
     * Get user signed api endpoint url
     */

  }, {
    key: "getSignedUrl",
    value: function getSignedUrl(endpoint, params) {
      var crypto = window.CryptoJS || null;
      var recvWindow = 100000;
      var timestamp = Date.now() - recvWindow / 2;

      var qstr = this._ajax.serializeData(Object.assign({
        recvWindow: recvWindow,
        timestamp: timestamp
      }, params));

      var signature = crypto ? crypto.HmacSHA256(qstr, this._apisecret).toString(crypto.enc.Hex) : '';
      return this._apiurl + endpoint + '?' + qstr + '&signature=' + signature;
    }
    /**
     * Fetch data about available markets form exchange
     */

  }, {
    key: "fetchMarketsData",
    value: function fetchMarketsData() {
      var _this2 = this;

      if (!this._ajax) return;
      var remote = "".concat(this._apiurl, "/products");
      var local = "../../../../public/market/json/exchangeInfo.json"; // build markets data and emit it out

      var handleResponse = function handleResponse(res) {
        if (res && Array.isArray(res.symbols)) {
          var _iterator = _createForOfIteratorHelper(res.symbols),
              _step;

          try {
            var _loop = function _loop() {
              var symb = _step.value;
              var token = symb.quoteAsset; // market

              var count = res.symbols.filter(function (s) {
                return s.quoteAsset === token && s.baseAsset !== token && s.status === 'TRADING';
              }).length;
              _this2._markets[token] = {
                token: token,
                count: count
              };
            };

            for (_iterator.s(); !(_step = _iterator.n()).done;) {
              _loop();
            }
          } catch (err) {
            _iterator.e(err);
          } finally {
            _iterator.f();
          }

          _this2.emit('markets_data', _this2._markets);
        }
      }; // try remote, then local if it fails


      this._ajax.get(remote, {
        type: 'json',
        success: function success(xhr, status, res) {
          return handleResponse(res);
        },
        error: function error(xhr, status, err) {
          _this2._ajax.get(local, {
            type: 'json',
            proxy: false,
            success: function success(xhr, status, res) {
              return handleResponse(res);
            }
          });
        }
      });
    }
    /**
     * Fetch last 24h candle data
     */

  }, {
    key: "fetchChartData",
    value: function fetchChartData(symbol, cb) {
      var _this3 = this;

      if (!this._ajax || !symbol) return;
      var endpoint = "".concat(this._apiurl, "/v3/klines?symbol=").concat(symbol, "&interval=1h&limit=168");
      var prices = [];

      this._ajax.get(endpoint, {
        type: 'json',
        // cache: 600,
        success: function success(xhr, status, res) {
          if (res && Array.isArray(res)) {
            for (var i = 0; i < res.length; ++i) {
              prices.push(parseFloat(res[i][4])); // close price
            }
          }

          if (typeof cb === 'function') cb(prices);

          _this3.emit('chart_data', {
            symbol: symbol,
            prices: prices
          });
        },
        error: function error(xhr, status, err) {
          if (typeof cb === 'function') cb(prices);
          console.warn(err);
        }
      });
    }
    /**
     * Parse user balances data
     */

  }, {
    key: "parseUserBalances",
    value: function parseUserBalances(data) {
      var _this4 = this;

      var balances = [];
      if (Array.isArray(data)) balances = data; // as-is

      if (Array.isArray(data.balances)) balances = data.balances; // http

      if (Array.isArray(data.B)) balances = data.B; // websocket

      balances = balances.map(function (t) {
        var asset = String(t.a || t.asset || '');
        var pair = asset === 'BTC' ? 'USDT' : 'BTC';
        var route = '/symbol/' + asset + pair;
        var name = _this4._names[asset] || asset;
        var free = parseFloat(t.f || t.free) || 0;
        var locked = parseFloat(t.l || t.locked) || 0;
        var total = free + locked;
        return {
          asset: asset,
          name: name,
          route: route,
          free: free,
          locked: locked,
          total: total
        };
      });
      return balances.filter(function (t) {
        return t.total > 0;
      });
    }
    /**
     * Parse order data from an API/Socket response and combine it with symbol data
     * @param {object}  data  Order data response
     */

  }, {
    key: "parseOrderData",
    value: function parseOrderData(data) {
      var now = Date.now();
      var time = Number(data.T || data.transactTime || now); // transaction time

      var id = String(data.i || data.orderId || ''); // order id

      var symbol = String(data.s || data.symbol || ''); // trade pair symbol

      var side = String(data.S || data.side || ''); // book side (BUY, SELL)

      var type = String(data.o || data.type || ''); // order type (LIMIT, MARKET, etc)

      var status = String(data.X || data.status || ''); // order status (NEW, CANCELED, FILLED, etc)

      var price = Number(data.p || data.price || 0); // order book price

      var quantity = Number(data.q || data.origQty || 0); // original trade quantity

      var filled = Number(data.z || data.executedQty || 0); // filled trade quantity

      var total = Number(data.Z || data.cummulativeQuoteQty || 0); // total trade asset cost

      var feeAsset = String(data.N || ''); // fee asset used for commission (BNB, etc)

      var feeAmount = Number(data.n || 0); // fee commission amount

      var percent = Number(filled / quantity * 100); // filled percent
      // resolve available amount after token fee has been deducted

      var smb = this._symbols[symbol] || new _symbol__WEBPACK_IMPORTED_MODULE_1__["default"](symbol);
      var amount = feeAsset === smb.token ? quantity - feeAmount : quantity;
      var unique = _utils__WEBPACK_IMPORTED_MODULE_2___default().unique(symbol + '|' + Math.floor(amount));
      status = status === 'NEW' ? 'OPEN' : status;

      if (!price && total) {
        price = total / quantity;
      }

      if (!total && price) {
        total = price * quantity;
      }

      return smb.getData({
        id: id,
        unique: unique,
        side: side,
        time: time,
        type: type,
        status: status,
        price: price,
        quantity: quantity,
        filled: filled,
        amount: amount,
        total: total,
        feeAsset: feeAsset,
        feeAmount: feeAmount,
        percent: percent
      });
    }
    /**
     * Build fake order data
     * @param {string}  symbol    Full trading symbol
     * @param {string}  type      Order type (LIMIT, MARKET)
     * @param {string}  side      Book side (BUY, SELL)
     * @param {number}  price     Book price
     * @param {number}  quantity  Order quantity
     */

  }, {
    key: "fakeOrderData",
    value: function fakeOrderData(symbol, type, side, price, quantity, status) {
      var time = Date.now();
      var id = _utils__WEBPACK_IMPORTED_MODULE_2___default().randString(20);
      var priceStr = Number(price).toFixed(8);
      var quantityStr = Number(quantity).toFixed(0);
      var totalStr = Number(price * quantity).toFixed(8);
      return this.parseOrderData({
        symbol: symbol,
        orderId: id,
        transactTime: time,
        price: priceStr,
        origQty: quantityStr,
        executedQty: quantityStr,
        cummulativeQuoteQty: totalStr,
        status: status,
        type: type,
        side: side
      });
    }
    /**
     * Simulate an order with fake API request
     * @param {string}  symbol    Full trading symbol
     * @param {string}  type      Order type (LIMIT, MARKET)
     * @param {string}  side      Book side (BUY, SELL)
     * @param {number}  price     Book price
     * @param {number}  quantity  Order quantity
     */

  }, {
    key: "placeFakeOrder",
    value: function placeFakeOrder(symbol, type, side, price, quantity) {
      var _this5 = this;

      var secs = Math.floor(1000 + Math.random() * 4000); // 1-5 secs

      var orderOpen = this.fakeOrderData(symbol, type, side, price, quantity, 'OPEN');
      var orderFilled = this.fakeOrderData(symbol, type, side, price, quantity, 'FILLED');
      var orderCanceled = this.fakeOrderData(symbol, type, side, price, quantity, 'CANCELED');
      var orderResult = secs < 4900 ? orderFilled : orderCanceled;
      setTimeout(function () {
        _this5.emit('book_create', orderOpen);
      }, 300); // added to book

      setTimeout(function () {
        _this5.emit('user_order', orderResult);
      }, secs); // filled or canceled
    }
    /**
     * Place new order in book
     * @param {string}  symbol    Full trading symbol
     * @param {string}  type      Order type (LIMIT, MARKET)
     * @param {string}  side      Book side (BUY, SELL)
     * @param {number}  price     Book price
     * @param {number}  quantity  Order quantity
     * @param {string}  inforce   Time inforce type (GTC, IOC, FOK)
     */

  }, {
    key: "placeOrder",
    value: function placeOrder(symbol, type, side, price, quantity, inforce) {
      var _this6 = this;

      if (!this._apikey || !this._ajax) return;
      if (!symbol || !type || !side || !quantity || quantity <= 0) return;
      price = Number(price).toFixed(8);
      quantity = Number(quantity).toFixed(0);
      inforce = String(inforce || 'FOK');
      var params = {
        symbol: symbol,
        side: side,
        type: type,
        quantity: quantity
      };
      if (type === 'LIMIT') Object.assign(params, {
        price: price,
        timeInForce: inforce
      });
      Object.assign(params, {
        newOrderRespType: 'RESULT'
      });

      this._ajax.post(this.getSignedUrl('/v3/order', params), {
        type: 'json',
        headers: {
          'X-MBX-APIKEY': this._apikey
        },
        success: function success(xhr, status, response) {
          var order = _this6.parseOrderData(response);

          _this6.emit('book_create', order);
        },
        error: function error(xhr, status, _error) {
          var order = _this6.fakeOrderData(symbol, type, side, price, quantity, 'REJECTED');

          _this6.emit('book_fail', order, _error);
        }
      });
    }
    /**
     * Cancel order from book
     * @param {string}  symbol    Full trading symbol
     * @param {number}  orderId   Order ID number
     * @param {number}  quantity  Order quantity
     */

  }, {
    key: "cancelOrder",
    value: function cancelOrder(symbol, orderId, quantity) {
      var _this7 = this;

      if (!this._apikey || !this._ajax) return;
      if (!symbol || !orderId) return;

      this._ajax["delete"](this.getSignedUrl('/v3/order', {
        symbol: symbol,
        orderId: orderId
      }), {
        type: 'json',
        headers: {
          'X-MBX-APIKEY': this._apikey
        },
        success: function success(xhr, status, response) {
          var order = _this7.fakeOrderData(symbol, 'MARKET', 'CANCEL', 1, quantity, 'COMPLETE');

          _this7.emit('book_cancel', order);
        },
        error: function error(xhr, status, _error2) {
          var order = _this7.fakeOrderData(symbol, 'MARKET', 'CANCEL', 1, quantity, 'FAILED');

          _this7.emit('book_fail', order, _error2);
        }
      });
    }
    /**
     * Get user account data over ajax
     */

  }, {
    key: "fetchUserAccount",
    value: function fetchUserAccount() {
      var _this8 = this;

      if (!this._apikey || !this._ajax) return;

      this._ajax.get(this.getSignedUrl('/v3/account'), {
        type: 'json',
        headers: {
          'X-MBX-APIKEY': this._apikey
        },
        success: function success(xhr, status, response) {
          var balances = _this8.parseUserBalances(response);

          _this8.emit('user_balances', balances);

          _this8.emit('user_data', true);
        },
        error: function error(xhr, status, _error3) {
          _this8.emit('user_fail', _error3);

          _this8.stopUserStream();
        }
      });
    }
    /**
     * Fetch current open orders
     */

  }, {
    key: "fetchOpenOrders",
    value: function fetchOpenOrders() {
      var _this9 = this;

      if (!this._apikey || !this._ajax) return;

      this._ajax.get(this.getSignedUrl('/v3/openOrders'), {
        type: 'json',
        headers: {
          'X-MBX-APIKEY': this._apikey
        },
        success: function success(xhr, status, response) {
          response.forEach(function (o) {
            return _this9.emit('user_order', _this9.parseOrderData(o));
          });

          _this9.emit('user_data', true);
        },
        error: function error(xhr, status, _error4) {
          _this9.emit('user_fail', _error4);
        }
      });
    }
    /**
     * Attempt to start a new user stream
     */

  }, {
    key: "initUserStream",
    value: function initUserStream(reconnect) {
      var _this10 = this;

      if (!this._apikey || !this._ajax) return;
      this.emit('user_init', Date.now());
      this.stopUserStream();

      this._ajax.post(this.getPublicUrl('/v1/userDataStream'), {
        type: 'json',
        headers: {
          'X-MBX-APIKEY': this._apikey
        },
        success: function success(xhr, status, response) {
          var time = 1000 * 60 * 20; // 20 mins

          var func = _this10.extendStreamKey.bind(_this10);

          _this10._listenkey = String(response.listenKey || '').trim();

          _this10.emit('user_listenkey', _this10._listenkey);

          _this10.startUserStream(_this10._listenkey, reconnect);

          _this10.startTimer('user', time, func, false);
        },
        error: function error(xhr, status, _error5) {
          _this10.emit('user_fail', _error5);
        }
      });
    }
    /**
     * Extend user stream listen key
     */

  }, {
    key: "extendStreamKey",
    value: function extendStreamKey() {
      var _this11 = this;

      if (!this._apikey || !this._ajax) return;
      if (!this._listenkey) return;

      this._ajax.put(this.getPublicUrl('/v1/userDataStream', {
        listenKey: this._listenkey
      }), {
        type: 'json',
        headers: {
          'X-MBX-APIKEY': this._apikey
        },
        success: function success(xhr, status, response) {
          _this11.emit('user_listenkey', _this11._listenkey);
        }
      });
    }
    /**
     * Connect to a live user account data stream
     */

  }, {
    key: "startUserStream",
    value: function startUserStream(listenKey, reconnect) {
      var _this12 = this;

      this.setReconnect('user', reconnect || false);
      this.emit('user_init', Date.now());
      var ws = this.sockConnect('user', this._wssurl + '/ws/' + listenKey);
      if (!ws) return this.emit('user_fail', 'Could not connect to user stream API endpoint.');
      ws.addEventListener('open', function (e) {
        _this12.emit('user_open', e);

        _this12.fetchUserAccount();

        _this12.fetchOpenOrders();
      });
      ws.addEventListener('error', function (e) {
        _this12.emit('user_error', e);

        _this12.stopTimer('user');
      });
      ws.addEventListener('close', function (e) {
        _this12.emit('user_close', e);

        _this12.stopTimer('user');

        _this12.checkReconnect('user', function () {
          return _this12.startUserStream(listenKey, reconnect);
        });
      });
      ws.addEventListener('message', function (e) {
        _this12.emit('user_data', true);

        var data = JSON.parse(e.data || '{}') || {};

        if (data.e === 'outboundAccountInfo') {
          var balances = _this12.parseUserBalances(data);

          return _this12.emit('user_balances', balances);
        }

        if (data.e === 'executionReport') {
          var order = _this12.parseOrderData(data);

          return _this12.emit('user_order', order);
        }
      });
    }
    /**
     * Stop user stream
     */

  }, {
    key: "stopUserStream",
    value: function stopUserStream() {
      this.setReconnect('user', false);
      this.stopTimer('user');
      this.sockClose('user');
    }
    /**
     * Connect to live ticker prices socket endpoint
     */

  }, {
    key: "startTickerStream",
    value: function startTickerStream(reconnect) {
      var _this13 = this;

      this.setReconnect('ticker', reconnect || false);
      this.emit('ticker_init', Date.now());
      var ws = this.sockConnect('ticker', this._wssurl + '/ws/!ticker@arr');
      if (!ws) return this.emit('ticker_fail', 'Could not connect to live ticker stream API endpoint.');
      ws.addEventListener('open', function (e) {
        _this13.emit('ticker_open', e);

        _this13.startTickerTimer();
      });
      ws.addEventListener('error', function (e) {
        _this13.emit('ticker_error', e);

        _this13.stopTimer('ticker');
      });
      ws.addEventListener('close', function (e) {
        _this13.emit('ticker_close', e);

        _this13.stopTimer('ticker');

        _this13.checkReconnect('ticker', function () {
          return _this13.startTickerStream(reconnect);
        });
      });
      ws.addEventListener('message', function (e) {
        _this13.emit('ticker_data', true);

        var list = JSON.parse(e.data || '[]') || [];
        var markets = Object.keys(_this13._markets);
        var count = list.length; // wait for markets data to be available before creating symbols

        if (!markets.length || !count) return;

        while (count--) {
          var ticker = list[count];
          var pair = ticker.s; // trading pair symbol str

          var symbol = _this13._symbols[pair] || new _symbol__WEBPACK_IMPORTED_MODULE_1__["default"](pair); // cached

          symbol.splitSymbol(markets); // split pair symbol into token / market

          symbol.setCoinData(_this13._coindata[symbol.token]); // data from coincap.io

          symbol.setTickerData(ticker); // update symbol ticker data

          symbol.resolveImage(); // find an icon for this token

          _this13._symbols[pair] = symbol; // update cache
        }
      });
    }
    /**
     * Start ticker data timer
     */

  }, {
    key: "startTickerTimer",
    value: function startTickerTimer() {
      var _this14 = this;

      this.stopTimer('ticker');
      this.startTimer('ticker', 1000, function () {
        var keys = Object.keys(_this14._symbols);
        var count = keys.length;
        var prices = [];

        while (count--) {
          prices.push(_this14._symbols[keys[count]]);
        }

        _this14.emit('ticker_prices', prices);
      }, true);
    }
    /**
     * Stop price ticker
     */

  }, {
    key: "stopTickerStream",
    value: function stopTickerStream() {
      this.setReconnect('ticker', false);
      this.stopTimer('ticker');
      this.sockClose('ticker');
    }
    /**
     * Start custom timer
     * @param {string}    id        Timer id name
     * @param {number}    time      Interval mils
     * @param {function}  callback  Callback function
     * @param {boolean}   init      Init callback
     */

  }, {
    key: "startTimer",
    value: function startTimer(id, time, callback, init) {
      this.stopTimer(id);
      this._timers[id] = setInterval(callback, time);
      if (init) callback();
    }
    /**
     * Stop custom timer
     * @param {string}  id  Timer id name
     */

  }, {
    key: "stopTimer",
    value: function stopTimer(id) {
      if (!id || !this._timers.hasOwnProperty(id)) return;
      clearInterval(this._timers[id]);
      delete this._timers[id];
    }
    /**
     * Create a WebSocket connection
     * @param {string}  id      Ref id name
     * @param {string}  endpoint  Socket endpoint url
     */

  }, {
    key: "sockConnect",
    value: function sockConnect(id, endpoint) {
      if (!id || !endpoint) return;
      this.emit('sock_init', endpoint);
      this.sockClose(id);

      if (!('WebSocket' in window)) {
        this.emit('sock_fail', 'This web browser does not have WebSocket support.');
        return false;
      }

      try {
        var ws = new WebSocket(endpoint);
        this._socks[id] = ws;
        return ws;
      } catch (err) {
        var message = String(err.message || 'WebSocket endpoint connection failed for (' + endpoint + ').');
        this.emit('sock_fail', message);
        return false;
      }
    }
    /**
     * Close socket connection and remove it from the list
     * @param {string}  id  Socket id name
     */

  }, {
    key: "sockClose",
    value: function sockClose(id) {
      if (!id || !this._socks.hasOwnProperty(id)) return;
      this.emit('sock_close', id);

      this._socks[id].close();

      delete this._socks[id];
    }
    /**
     * Close all active socket connections
     */

  }, {
    key: "sockCloseAll",
    value: function sockCloseAll() {
      var _this15 = this;

      Object.keys(this._socks).forEach(function (id) {
        return _this15.sockClose(id);
      });
    }
  }]);

  return Coinbasepro;
}(_bus__WEBPACK_IMPORTED_MODULE_0__["default"]);



/***/ }),

/***/ "./src/market/modules/coincap.js":
/*!***************************************!*\
  !*** ./src/market/modules/coincap.js ***!
  \***************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ Coincap)
/* harmony export */ });
/* harmony import */ var _bus__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./bus */ "./src/market/modules/bus.js");
/* harmony import */ var raw_loader_resources_assets_cors_txt__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! raw-loader!../../../resources/assets/cors.txt */ "./node_modules/raw-loader/dist/cjs.js!./resources/assets/cors.txt");
function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }

function _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it["return"] != null) it["return"](); } finally { if (didErr) throw err; } } }; }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

/**
 * Handle talking to coincap.io to get coin related data
 * https://docs.coincap.io/
 */



var Coincap = /*#__PURE__*/function (_Bus) {
  _inherits(Coincap, _Bus);

  var _super = _createSuper(Coincap);

  /**
   * Constructor
   */
  function Coincap() {
    var _this;

    _classCallCheck(this, Coincap);

    _this = _super.call(this);
    _this._ajax = null;
    _this._coins = {};
    return _this;
  }
  /**
   * Set ajax module reference to use for requests
   */


  _createClass(Coincap, [{
    key: "useAjax",
    value: function useAjax(ajax) {
      this._ajax = ajax;
    }
    /**
     * Get tokens data object
     */

  }, {
    key: "getData",
    value: function getData() {
      return this._coins;
    }
    /**
     * fetch list of all tokens and their names from API
     */

  }, {
    key: "fetchAll",
    value: function fetchAll() {
      var _this2 = this;

      if (!this._ajax) return;

      this._ajax.get("".concat(raw_loader_resources_assets_cors_txt__WEBPACK_IMPORTED_MODULE_1__["default"], "https://api.coincap.io/v2/assets?limit=2000"), {
        type: 'json',
        beforeSend: function beforeSend(xhr) {
          xhr.setRequestHeader('Authorization', 'Bearer t-7618a141-3c2f-425d-af06-46690c5f5539');
        },
        cache: 600,
        proxy: false,
        success: function success(xhr, status, res) {
          if (!res || !Array.isArray(res.data)) return;

          var _iterator = _createForOfIteratorHelper(res.data),
              _step;

          try {
            for (_iterator.s(); !(_step = _iterator.n()).done;) {
              var c = _step.value;
              _this2._coins[c.symbol] = c;
            }
          } catch (err) {
            _iterator.e(err);
          } finally {
            _iterator.f();
          }

          _this2.emit('allcoins', _this2._coins);
        }
      });
    }
    /**
     * Fetch market cap data for a token
     */

  }, {
    key: "fetchCoin",
    value: function fetchCoin(id, cb) {
      var _this3 = this;

      if (!this._ajax || !id) return;

      this._ajax.get("".concat(raw_loader_resources_assets_cors_txt__WEBPACK_IMPORTED_MODULE_1__["default"], "https://api.coincap.io/v2/assets/").concat(id), {
        type: 'json',
        beforeSend: function beforeSend(xhr) {
          xhr.setRequestHeader('Authorization', 'Bearer t-7618a141-3c2f-425d-af06-46690c5f5539');
        },
        cache: 300,
        proxy: false,
        success: function success(xhr, status, res) {
          if (!res || !res.data) return;
          if (typeof cb === 'function') cb(res.data);

          _this3.emit('coindata', res.data);
        }
      });
    }
  }]);

  return Coincap;
}(_bus__WEBPACK_IMPORTED_MODULE_0__["default"]);



/***/ }),

/***/ "./src/market/modules/history.js":
/*!***************************************!*\
  !*** ./src/market/modules/history.js ***!
  \***************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ History)
/* harmony export */ });
/* harmony import */ var _bus__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./bus */ "./src/market/modules/bus.js");
/* harmony import */ var _store__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./store */ "./src/market/modules/store.js");
/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./utils */ "./src/market/modules/utils.js");
/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_utils__WEBPACK_IMPORTED_MODULE_2__);
function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

/**
 * Handles saving data to a history list
 */




var History = /*#__PURE__*/function (_Bus) {
  _inherits(History, _Bus);

  var _super = _createSuper(History);

  /**
   * Constructor
   */
  function History(options) {
    var _this;

    _classCallCheck(this, History);

    _this = _super.call(this);
    _this._alarms = [];
    _this._sto = null;
    _this._options = Object.assign({
      // key used for storage
      key: 'history_data',
      // auto remove entries past this value (secs)
      expire: 1800,
      // total number of entries to keep in list
      total: 20 // ...

    }, options);
    return _this;
  }
  /**
   * Save current history data to store and emit list
   */


  _createClass(History, [{
    key: "saveData",
    value: function saveData() {
      this._autoClean();

      this.emit('update', this._alarms);
      _store__WEBPACK_IMPORTED_MODULE_1__["default"].setData(this._options.key, this._alarms);
      if (this._sto) clearTimeout(this._sto);
      this._sto = setTimeout(this.saveData.bind(this), 30000);
    }
    /**
     * Load saved history data from store
     */

  }, {
    key: "loadData",
    value: function loadData() {
      var data = _store__WEBPACK_IMPORTED_MODULE_1__["default"].getData(this._options.key);
      if (!data || !Array.isArray(data)) return;
      this._alarms = data;
      this.saveData();
    }
    /**
     * Add data to history
     * @param {string}  title  Title string
     * @param {string}  info   Info string
     * @param {string}  icon   Icon image URL
     */

  }, {
    key: "add",
    value: function add(title, info, icon) {
      if (!title || !info) return;
      var id = _utils__WEBPACK_IMPORTED_MODULE_2___default().randString(20);
      var time = Date.now();
      var isNew = true;

      this._alarms.unshift({
        id: id,
        time: time,
        isNew: isNew,
        title: title,
        info: info,
        icon: icon
      });

      this.saveData();
    }
    /**
     * Remove an entry from the list by ID
     * @param {string}  id  Unique entry ID
     */

  }, {
    key: "remove",
    value: function remove(id) {
      if (!id || typeof id !== 'string') return;
      this._alarms = this._alarms.filter(function (e) {
        return e.id !== id;
      });
      this.saveData();
    }
    /**
     * Reset new entry indicators
     */

  }, {
    key: "reset",
    value: function reset() {
      this._alarms.forEach(function (e) {
        e.isNew = false;
      });

      this.saveData();
    }
    /**
     * Remove all entries from the list
     */

  }, {
    key: "flush",
    value: function flush() {
      this._alarms = [];
      this.saveData();
    }
    /**
     * Cleanup the list and emit changes
     */

  }, {
    key: "_autoClean",
    value: function _autoClean() {
      var time = Date.now();
      var expire = parseInt(this._options.expire) | 0;
      var total = parseInt(this._options.total) | 0;
      if (expire) this._alarms = this._alarms.filter(function (e) {
        return (time - e.time) / 1000 < expire;
      });
      if (total) this._alarms = this._alarms.slice(0, total);
    }
  }]);

  return History;
}(_bus__WEBPACK_IMPORTED_MODULE_0__["default"]);



/***/ }),

/***/ "./src/market/modules/logger.js":
/*!**************************************!*\
  !*** ./src/market/modules/logger.js ***!
  \**************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }

/**
 * Console log wrapper
 */
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__() {
  var w = __webpack_require__.g || window || null;
  if (!w || !w.DEBUG || !w.console) return;

  for (var i = 0; i < arguments.length; ++i) {
    if (_typeof(arguments[i]) === 'object') {
      arguments[i] = JSON.stringify(arguments[i], null, 2);
    }
  }

  console.log('-'.repeat(100));
  console.log.apply(console, arguments);
}

/***/ }),

/***/ "./src/market/modules/messenger.js":
/*!*****************************************!*\
  !*** ./src/market/modules/messenger.js ***!
  \*****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ Messenger)
/* harmony export */ });
/* harmony import */ var _bus__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./bus */ "./src/market/modules/bus.js");
function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

/**
 * Binance socket api wrapper class
 */


var Messenger = /*#__PURE__*/function (_Bus) {
  _inherits(Messenger, _Bus);

  var _super = _createSuper(Messenger);

  // constructor
  function Messenger(options) {
    var _this;

    _classCallCheck(this, Messenger);

    _this = _super.call(this);
    _this._ajax = null;
    _this._sto = null;
    _this._queue = [];
    _this._options = Object.assign({
      // how often to check the queue
      seconds: 60,
      // API options for mailgun
      mailgun: {
        enabled: false,
        apikey: '',
        email: '',
        domain: ''
      },
      // API options for telegram
      telegram: {
        enabled: false,
        botkey: '',
        userid: ''
      } // ...

    }, options);
    return _this;
  }
  /**
   * Merge options
   * @param {object}  options  Options object
   */


  _createClass(Messenger, [{
    key: "setOptions",
    value: function setOptions(options) {
      Object.assign(this._options, options);
    }
    /**
     * Set ajax module reference to use for requests
     * @param {object}  ajax  Ajax class instance
     */

  }, {
    key: "useAjax",
    value: function useAjax(ajax) {
      this._ajax = ajax;
    }
    /**
     * Push message data to queue
     * @param {string}  title     Message title
     * @param {string}  message   Message text
     * @param {string}  image     Message image/icon
     * @param {*}       data      Optional data
     */

  }, {
    key: "add",
    value: function add(title, message, image, data) {
      title = String(title || '');
      message = String(message || '');
      image = String(image || '');
      if (!title || !message) return;

      this._queue.push({
        title: title,
        message: message,
        image: image,
        data: data
      });
    }
    /**
     * Flush queue data
     */

  }, {
    key: "flush",
    value: function flush() {
      this._queue = [];
    }
    /**
     * Start the timer
     */

  }, {
    key: "start",
    value: function start() {
      this.stop();

      this._checkQueue();
    }
    /**
     * Stop the timer
     */

  }, {
    key: "stop",
    value: function stop() {
      if (this._sto) clearTimeout(this._sto);
    }
    /**
     * Queue checker
     */

  }, {
    key: "_checkQueue",
    value: function _checkQueue() {
      var secs = parseInt(this._options.seconds) || 0;
      this._sto = setTimeout(this._checkQueue.bind(this), 1000 * secs);
      if (!secs || !this._queue.length) return;
      this.emit('queue', this._queue);

      this._mailgunSend();

      this._telegramSend();

      this._queue = [];
    }
    /**
     * Send queue messages using Mailgun API
     */

  }, {
    key: "_mailgunSend",
    value: function _mailgunSend() {
      var _this2 = this;

      var _this$_options$mailgu = this._options.mailgun,
          enabled = _this$_options$mailgu.enabled,
          apikey = _this$_options$mailgu.apikey,
          email = _this$_options$mailgu.email,
          domain = _this$_options$mailgu.domain;
      if (!enabled || !apikey || !email || !domain || !this._ajax) return;
      var content = '';

      this._queue.forEach(function (q) {
        var title = q.title,
            message = q.message,
            image = q.image;
        message = String(message).replace(/\n+/g, ' <br />');
        content += "\n      <div style=\"border-top: 1px dashed rgba( 0,0,0,0.1 ); margin: 0 0 1em 0;\">\n        <table width=\"100%\" border=\"0\">\n          <tr>\n            <td><img src=\"".concat(image, "\" alt=\"image\" style=\"width: 42px; height: auto; margin: 0 .5em 0 0;\" /></td>\n            <td width=\"100%\"><b>").concat(title, "</b> <br /> ").concat(message, "</td>\n          </tr>\n        </table>\n      </div>");
      });

      var html = "\n    <!DOCTYPE html>\n    <html lang=\"en-US\">\n      <body style=\"margin: 0; padding: 0;\">\n        <div style=\"font-family: monospace; font-size: 10px; padding: 1em;\">\n          ".concat(content, "\n        </div>\n      </body>\n    </html>");
      var fdata = new FormData();
      fdata.append('from', 'Binance Watch App <noreply@' + domain + '>');
      fdata.append('to', 'E-mail Recipient <' + email + '>');
      fdata.append('subject', 'Binance Watch E-mail Notifications (' + this._queue.length + ')');
      fdata.append('html', String(html).trim());

      this._ajax.post('https://api.mailgun.net/v3/' + domain + '/messages', {
        type: 'json',
        data: fdata,
        auth: {
          username: 'api',
          password: apikey
        },
        done: function done(xhr, status, response) {
          if (!response || !response.id) return console.warn('Mailgun-API', status, response);

          _this2.emit('sent', 'E-mail notifications sent to (' + email + ').');
        }
      });
    }
    /**
     * Send queue messages using Telegram API
     */

  }, {
    key: "_telegramSend",
    value: function _telegramSend() {
      var _this3 = this;

      var _this$_options$telegr = this._options.telegram,
          enabled = _this$_options$telegr.enabled,
          botkey = _this$_options$telegr.botkey,
          userid = _this$_options$telegr.userid;
      if (!enabled || !botkey || !userid || !this._ajax) return;
      var content = '';

      this._queue.forEach(function (q) {
        var title = q.title,
            message = q.message;
        content += "<b>".concat(title, "</b> \n");
        content += "".concat(message, " \n");
        content += "\n";
      });

      var fdata = new FormData();
      fdata.append('chat_id', userid);
      fdata.append('text', String(content).trim());
      fdata.append('parse_mode', 'html');

      this._ajax.post('https://api.telegram.org/bot' + botkey + '/sendMessage', {
        type: 'json',
        data: fdata,
        done: function done(xhr, status, response) {
          if (!response || !response.ok) return console.warn('Telegram-API', status, response);

          _this3.emit('sent', 'Telegram notifications sent to (' + userid + ').');
        }
      });
    }
  }]);

  return Messenger;
}(_bus__WEBPACK_IMPORTED_MODULE_0__["default"]);



/***/ }),

/***/ "./src/market/modules/news.js":
/*!************************************!*\
  !*** ./src/market/modules/news.js ***!
  \************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ News)
/* harmony export */ });
/* harmony import */ var _bus__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./bus */ "./src/market/modules/bus.js");
/* harmony import */ var _twitter__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./twitter */ "./src/market/modules/twitter.js");
/* harmony import */ var _store__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./store */ "./src/market/modules/store.js");
function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }

function _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it["return"] != null) it["return"](); } finally { if (didErr) throw err; } } }; }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

/**
 * Twitter news handler class
 */




var News = /*#__PURE__*/function (_Bus) {
  _inherits(News, _Bus);

  var _super = _createSuper(News);

  /**
   * Constructor
   */
  function News() {
    var _this;

    _classCallCheck(this, News);

    _this = _super.call(this);
    _this._ajax = null;
    _this._accountsKey = 'news_accounts_data';
    _this._tweetsKey = 'news_tweets_data';
    _this._handlers = [];
    _this._tweets = [];
    _this._blacklist = [];
    _this._counter = 0;
    _this._interval = null;
    _this._options = {
      enabled: true,
      // aut re-fetch news on a timer
      interval: 5,
      // how often to try fetching from each source (secs)
      delay: 300,
      // how long to wait before fetching again from each source (secs)
      days: 1,
      // only show entries posted within this number of days
      tweets: 1,
      // how many tweets to fetch at once from each source
      total: 100 // max number of news entries to store in list

    };
    _this.tweetsHandler = _this.tweetsHandler.bind(_assertThisInitialized(_this));

    _this.setupTimer();

    return _this;
  }
  /**
   * Set ajax module reference to use for requests
   * @param {object}  ajax  Ajax class instance
   */


  _createClass(News, [{
    key: "useAjax",
    value: function useAjax(ajax) {
      this._ajax = ajax;
    }
    /**
     * Update options
     * @param {object}  options  Options object
     */

  }, {
    key: "setOptions",
    value: function setOptions(options) {
      Object.assign(this._options, options);
      this.setupTimer();
      this.updateHandlers();
      this.filterTweets();
    }
    /**
     * Load saved accounts list from store
     */

  }, {
    key: "loadAccounts",
    value: function loadAccounts() {
      var accounts = _store__WEBPACK_IMPORTED_MODULE_2__["default"].getData(this._accountsKey);
      if (!Array.isArray(accounts) || !accounts.length) return;
      this.importAccounts(accounts, true);
    }
    /**
     * Save accounts list to store
     */

  }, {
    key: "saveAccounts",
    value: function saveAccounts() {
      var accounts = this._handlers.map(function (tw) {
        return tw.handle;
      });

      _store__WEBPACK_IMPORTED_MODULE_2__["default"].setData(this._accountsKey, accounts);
      this.emit('handlers', this._handlers);
    }
    /**
     * Load list of twitter handles
     * @param {array}    accounts  List of twitter handle string names
     * @param {boolean}  reset     Reset current list of loaded handlers
     * @param {boolean}  save      Save list of account after importing
     */

  }, {
    key: "importAccounts",
    value: function importAccounts(accounts, reset, save) {
      accounts = Array.isArray(accounts) ? accounts : [];
      var count = 0; // reset current list, if a new list is available

      if (reset && accounts.length) this._handlers = []; // import new accounts list

      var _iterator = _createForOfIteratorHelper(accounts),
          _step;

      try {
        for (_iterator.s(); !(_step = _iterator.n()).done;) {
          var handle = _step.value;
          this.trackAccount(handle) && count++;
        } // save accounts back to store, or just emit loaded list

      } catch (err) {
        _iterator.e(err);
      } finally {
        _iterator.f();
      }

      if (save) {
        this.saveAccounts();
      } else {
        this.emit('handlers', this._handlers);
      }

      return count;
    }
    /**
     * Checks if a handle is already being tracked
     * @param {string}  handle  Twitter handle
     */

  }, {
    key: "tracking",
    value: function tracking(handle) {
      if (!handle || typeof handle !== 'string') return false;
      return this._handlers.filter(function (tw) {
        return tw.handle === handle;
      }).length ? true : false;
    }
    /**
     * Start tracking a new twitter account
     * @param {string}   handle  Twitter handle
     * @param {boolean}  fetch   Fetch tweets after adding
     * @param {boolean}  save    Save accounts after adding
     */

  }, {
    key: "trackAccount",
    value: function trackAccount(handle, fetch, save) {
      if (!handle || typeof handle !== 'string') return false;
      if (this.tracking(handle)) return false; // create new handler, add to list and update options

      var tw = new _twitter__WEBPACK_IMPORTED_MODULE_1__["default"](handle);
      this.updateHandlers(tw);

      this._handlers.push(tw); // fetch tweets now if needed and emit event


      if (fetch) tw.fetchTweets(this._ajax, this.tweetsHandler);
      if (save) this.saveAccounts();
      return true;
    }
    /**
     * Stop tracking a twitter account
     * @param {string}  handle  Twitter handle
     */

  }, {
    key: "untrackAccount",
    value: function untrackAccount(handle) {
      if (!handle || typeof handle !== 'string') return false; // get handler that is being removed from the list, if it exists

      var tw = this._handlers.filter(function (tw) {
        return tw.handle === handle;
      }).shift();

      if (!tw) return true; // remove handler from the list and emit events

      this._handlers = this._handlers.filter(function (tw) {
        return tw.handle !== handle;
      });
      this._tweets = this._tweets.filter(function (t) {
        return t.handle !== handle;
      });
      this.saveAccounts();
      this.saveTweets();
      return true;
    }
    /**
     * Update options for each Twitter handler
     */

  }, {
    key: "updateHandlers",
    value: function updateHandlers(tw) {
      var fetchDelay = parseInt(this._options.delay) || 300;
      var limitCount = parseInt(this._options.tweets) || 1;
      if (tw instanceof _twitter__WEBPACK_IMPORTED_MODULE_1__["default"]) return tw.setOptions({
        fetchDelay: fetchDelay,
        limitCount: limitCount
      });

      this._handlers.forEach(function (tw) {
        return tw.setOptions({
          fetchDelay: fetchDelay,
          limitCount: limitCount
        });
      });
    }
    /**
     * Load cached tweets from store
     */

  }, {
    key: "loadTweets",
    value: function loadTweets() {
      var tweets = _store__WEBPACK_IMPORTED_MODULE_2__["default"].getData(this._tweetsKey);
      if (!Array.isArray(tweets) || !tweets.length) return;
      this._tweets = tweets;
      this.resetTweets();
      this.filterTweets();
      this.saveTweets();
    }
    /**
     * Save current tweets to store
     */

  }, {
    key: "saveTweets",
    value: function saveTweets() {
      _store__WEBPACK_IMPORTED_MODULE_2__["default"].setData(this._tweetsKey, this._tweets);
      this.emit('tweets', this._tweets);
    }
    /**
     * Reset new entries indicator
     */

  }, {
    key: "resetTweets",
    value: function resetTweets() {
      this._tweets.forEach(function (t) {
        t.isNew = false;
      });

      this.saveTweets();
    }
    /**
     * Flush tweets list
     */

  }, {
    key: "flushTweets",
    value: function flushTweets() {
      this._tweets = [];
      this._blacklist = [];
      this.saveTweets();
    }
    /**
     * Remove tweet from list and add ID to blacklist
     * @param {string}  id  Tweet ID
     */

  }, {
    key: "blockTweet",
    value: function blockTweet(id) {
      if (!id) return false;
      this._tweets = this._tweets.filter(function (t) {
        return t.id !== id;
      });
      this._blacklist = this._blacklist.filter(function (tid) {
        return tid !== id;
      });

      this._blacklist.push(id);

      this.saveTweets();
      return true;
    }
    /**
     * Add new tweet object to the list
     * @param {object}  tweet  Tweet object
     */

  }, {
    key: "addTweet",
    value: function addTweet(tweet) {
      if (!tweet || !('id' in tweet)) return false;
      if (this.tweetExists(tweet)) return false;
      if (this.tweetBlocked(tweet)) return false;
      if (this.tweetExpired(tweet)) return false;
      tweet.isNew = true; // for indicator

      this._tweets.push(tweet);

      return true;
    }
    /**
     * Checks if a tweet is in the list of news
     * @param {object}  tweet  Tweet object
     */

  }, {
    key: "tweetExists",
    value: function tweetExists(tweet) {
      if (!tweet || !('id' in tweet)) return false;
      return this._tweets.filter(function (t) {
        return t.id === tweet.id;
      }).length ? true : false;
    }
    /**
     * Checks if a tweet is in the blocklist
     * @param {object}  tweet  Tweet object
     */

  }, {
    key: "tweetBlocked",
    value: function tweetBlocked(tweet) {
      if (!tweet || !('id' in tweet)) return false;
      return this._blacklist.filter(function (id) {
        return id === tweet.id;
      }).length ? true : false;
    }
    /**
     * Checks if a tweet is too old, based on option
     * @param {object}  tweet  Tweet object
     */

  }, {
    key: "tweetExpired",
    value: function tweetExpired(tweet) {
      if (!tweet || !('id' in tweet)) return false;
      var days = parseInt(this._options.days) | 0;
      var secs = (Date.now() - tweet.time) / 1000;
      var age = Math.ceil(secs / 86400);
      return age > days ? true : false;
    }
    /**
     * Handles new tweets that are fetched from the Twitter class
     * @param {string}  err    Error string (empty on success)
     * @param {array}  tweets  Tweets array (empty on error)
     */

  }, {
    key: "tweetsHandler",
    value: function tweetsHandler(err, tweets) {
      if (err) return this.emit('error', err);
      if (!tweets.length) return;

      var _iterator2 = _createForOfIteratorHelper(tweets),
          _step2;

      try {
        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
          var tweet = _step2.value;
          // it's possible added tweets can get removed due to filtering...
          var added = this.addTweet(tweet);
          this.filterTweets(); // double check if the tweet survived and emit it

          if (added && this.tweetExists(tweet)) {
            this.emit('tweet', tweet);
          }
        }
      } catch (err) {
        _iterator2.e(err);
      } finally {
        _iterator2.f();
      }

      this.saveAccounts();
      this.saveTweets();
    }
    /**
     * Cleanup tweets list
     */

  }, {
    key: "filterTweets",
    value: function filterTweets() {
      var _this2 = this;

      var total = parseInt(this._options.total); // filter out old tweets

      this._tweets = this._tweets.filter(function (tweet) {
        return !_this2.tweetExpired(tweet);
      }); // sort tweets from new to old

      this._tweets = this._tweets.sort(function (a, b) {
        if (a.time > b.time) return -1;
        if (a.time < b.time) return 1;
        return 0;
      }); // trim tweets list

      if (total) {
        this._tweets = this._tweets.slice(0, total);
      }
    }
    /**
     * Fetch tweets for an account by handle
     * @param {string}  handle  Twitter handle
     */

  }, {
    key: "fetchByHandle",
    value: function fetchByHandle(handle) {
      if (!handle || typeof handle !== 'string') return false;

      var tw = this._handlers.filter(function (tw) {
        return tw.handle === handle;
      }).shift();

      if (tw) tw.fetchTweets(this._ajax, this.tweetsHandler);
      return true;
    }
    /**
     * Fetch tweets from next handler down the list
     */

  }, {
    key: "fetchNextHandler",
    value: function fetchNextHandler() {
      if (!this._handlers.length) return;
      var last = this._handlers.length - 1;
      var tw = this._handlers[this._counter];
      if (tw) tw.fetchTweets(this._ajax, this.tweetsHandler);
      this._counter = this._counter < last ? this._counter + 1 : 0;
    }
    /**
     * Start the tweets interval handler
     */

  }, {
    key: "setupTimer",
    value: function setupTimer() {
      var _this3 = this;

      this.stopTimer();
      var secs = parseInt(this._options.interval);
      if (!secs) return;
      this._interval = setInterval(function () {
        if (!_this3._options.enabled) return;

        _this3.fetchNextHandler();
      }, 1000 * secs);
    }
    /**
     * Stop the tweets interval handler
     */

  }, {
    key: "stopTimer",
    value: function stopTimer() {
      if (this._interval) {
        clearInterval(this._interval);
        this._interval = null;
      }
    }
  }]);

  return News;
}(_bus__WEBPACK_IMPORTED_MODULE_0__["default"]);



/***/ }),

/***/ "./src/market/modules/notify.js":
/*!**************************************!*\
  !*** ./src/market/modules/notify.js ***!
  \**************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ Notify)
/* harmony export */ });
/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils */ "./src/market/modules/utils.js");
/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_utils__WEBPACK_IMPORTED_MODULE_0__);
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }

/**
 * Push notifications and custom alarms handler class
 */


var Notify = /*#__PURE__*/function () {
  // constructor
  function Notify(options) {
    _classCallCheck(this, Notify);

    this._queue = [];
    this._notices = [];
    this._options = {
      // toggle notifications
      enabled: true,
      // notifications duration (secs)
      duration: 10,
      // toggle notification sound
      sound: true,
      // volume of notification sound ( 0 - 1 )
      volume: 1,
      // audio file to play on with notifications
      audio: '../../../market/audio/audio_3.mp3',
      // default notification image file
      image: '../../../market/notification.png'
    };
    this.setOptions(options);

    this._watchQueue();
  } // merge new options


  _createClass(Notify, [{
    key: "setOptions",
    value: function setOptions(options) {
      Object.assign(this._options, options);
    } // add a notification message to the queue

  }, {
    key: "add",
    value: function add(title, body, icon, link) {
      if (!title || !body) return;
      var id = _utils__WEBPACK_IMPORTED_MODULE_0___default().randString(20);
      var time = Date.now();
      icon = String(icon || this._options.image);
      this._queue = this._queue.filter(function (n) {
        return n.title !== title;
      });

      this._queue.push({
        id: id,
        time: time,
        title: title,
        body: body,
        icon: icon,
        link: link
      });
    } // flush the queue

  }, {
    key: "flush",
    value: function flush() {
      this._queue = [];
    } // check if notification is supported

  }, {
    key: "hasSupport",
    value: function hasSupport() {
      return window && 'Notification' in window;
    } // check if Notification is possible

  }, {
    key: "canNotify",
    value: function canNotify() {
      if (!this.hasSupport()) return false;
      if (Notification.permission !== 'granted') return false;
      return true;
    } // ask for browser notifications permission

  }, {
    key: "permission",
    value: function permission(callback) {
      if (!this.hasSupport()) return;
      Notification.requestPermission().then(function (response) {
        if (typeof callback === 'function') callback(response);
      });
    } // play notification sound if enabled

  }, {
    key: "playSound",
    value: function playSound() {
      if (this._options.sound) {
        _utils__WEBPACK_IMPORTED_MODULE_0___default().playAudio(this._options.audio, this._options.volume);
      }
    } // limit visible notifications to a fixed number

  }, {
    key: "_cleanupNotifications",
    value: function _cleanupNotifications() {
      var limit = 3;
      if (this._notices.length <= limit) return;

      for (var i = 0; i < this._notices.length - limit; ++i) {
        this._notices[i].close(); // trigger close event

      }
    } // create notifications from the queue on a timer

  }, {
    key: "_watchQueue",
    value: function _watchQueue() {
      var _this = this;

      this._cleanupNotifications();

      setTimeout(this._watchQueue.bind(this), 500);
      if (!this._options.enabled || !this._queue.length) return;
      if (!this.canNotify()) return; // create new notification

      var _this$_queue$shift = this._queue.shift(),
          id = _this$_queue$shift.id,
          time = _this$_queue$shift.time,
          title = _this$_queue$shift.title,
          body = _this$_queue$shift.body,
          icon = _this$_queue$shift.icon,
          link = _this$_queue$shift.link;

      var a = new Notification(title, {
        body: body,
        icon: icon,
        tag: id
      }); // auto-close on optional duration

      var ttl = parseInt(this._options.duration);
      if (ttl) setTimeout(function () {
        return a.close();
      }, 1000 * ttl); // keep track of visible notifications

      a.addEventListener('show', function (e) {
        if (!e || !e.target || !e.target.tag) return;

        _this.playSound();
      }); // remove notification from local array when it closes

      a.addEventListener('close', function (e) {
        if (!e || !e.target || !e.target.tag) return;
        _this._notices = _this._notices.filter(function (a) {
          return a.tag !== e.target.tag;
        });
      }); // convert url string to clickable link

      if (link && typeof link === 'string') {
        a.addEventListener('click', function (e) {
          e.preventDefault();
          window.open(link, '_blank');
        });
      } // custom click handler


      if (link && typeof link === 'function') {
        a.addEventListener('click', link);
      } // add to tracker


      this._notices.push(a);
    }
  }]);

  return Notify;
}();



/***/ }),

/***/ "./src/market/modules/options.js":
/*!***************************************!*\
  !*** ./src/market/modules/options.js ***!
  \***************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ Options)
/* harmony export */ });
/* harmony import */ var _bus__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./bus */ "./src/market/modules/bus.js");
/* harmony import */ var _store__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./store */ "./src/market/modules/store.js");
/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./utils */ "./src/market/modules/utils.js");
/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_utils__WEBPACK_IMPORTED_MODULE_2__);
function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

/**
 * App Options helper class
 */




var Options = /*#__PURE__*/function (_Bus) {
  _inherits(Options, _Bus);

  var _super = _createSuper(Options);

  /**
   * Constructor
   */
  function Options(options) {
    var _this;

    _classCallCheck(this, Options);

    _this = _super.call(this);
    _this._key = 'app_options_data';
    _this._options = {};

    _this.setOptions(options);

    return _this;
  }
  /**
   * Loads and sets saved data from store
   */


  _createClass(Options, [{
    key: "loadOptions",
    value: function loadOptions() {
      var options = _store__WEBPACK_IMPORTED_MODULE_1__["default"].getData(this._key);
      this.setOptions(options);
    }
    /**
     * Set new options data and save to store
     * @param {object}  options  Options object
     */

  }, {
    key: "saveOptions",
    value: function saveOptions(options) {
      this.setOptions(options);
      _store__WEBPACK_IMPORTED_MODULE_1__["default"].setData(this._key, this._options);
    }
    /**
     * Set new options data and emit changes
     * @param {object}  options  Options object
     */

  }, {
    key: "setOptions",
    value: function setOptions(options) {
      this._options = _utils__WEBPACK_IMPORTED_MODULE_2___default().deepMerge({}, this._options, options);
      this.emit('update', this._options);
    }
    /**
     * Get options by name, or all
     * @param {string}  key  Options object key
     * @param {*}       def  Optional default value
     */

  }, {
    key: "getOptions",
    value: function getOptions(key, def) {
      if (key && typeof key === 'string') {
        if (this._options.hasOwnProperty(key)) return this._options[key];
        return def;
      }

      return this._options;
    }
  }]);

  return Options;
}(_bus__WEBPACK_IMPORTED_MODULE_0__["default"]);



/***/ }),

/***/ "./src/market/modules/router.js":
/*!**************************************!*\
  !*** ./src/market/modules/router.js ***!
  \**************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ Router)
/* harmony export */ });
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }

/**
 * Basic URL hash router
 */
var Router = /*#__PURE__*/function () {
  // constructor
  function Router() {
    _classCallCheck(this, Router);

    this._routes = {};

    this._init();
  } // get routes data


  _createClass(Router, [{
    key: "getRoutes",
    value: function getRoutes() {
      return this._routes;
    } // set a url hash route

  }, {
    key: "setRoute",
    value: function setRoute(route) {
      route = this._path(route);
      window.location.hash = route;
    } // add custom route and callback to list

  }, {
    key: "on",
    value: function on(route, callback) {
      route = this._path(route);
      if (!route || typeof callback !== 'function') return;
      this._routes[route] = callback;
    } // delete route handler

  }, {
    key: "off",
    value: function off(route) {
      route = this._path(route);

      if (this._routes.hasOwnProperty(route)) {
        delete this._routes[route];
      }
    } // trigger saved handler for a path

  }, {
    key: "trigger",
    value: function trigger(path) {
      var _this = this;

      path = this._path(path);
      if (!path) return;
      Object.keys(this._routes).forEach(function (route) {
        var cb = _this._routes[route]; // path matches route, call handler as is

        if (path === route) return cb(); // use regexp to test route

        var reg = new RegExp('^' + route + '$');
        var matches = reg.exec(path); // found something, pass regexp matches as arguments to handler

        if (matches) {
          matches = Array.from(matches);
          matches.shift();
          cb.apply(cb, matches);
        }
      });
    } // clean path

  }, {
    key: "_path",
    value: function _path(path) {
      return '/' + String(path || '').replace(/^[\#\/]+|[\/]+$/g, '').trim();
    } // start watching for hash changes

  }, {
    key: "_init",
    value: function _init() {
      var _this2 = this;

      var _w = window;

      _w.addEventListener('hashchange', function (e) {
        _this2.trigger(_w.location.hash);
      });

      _w.addEventListener('load', function (e) {
        _this2.trigger(_w.location.hash);
      });
    }
  }]);

  return Router;
}();



/***/ }),

/***/ "./src/market/modules/scroller.js":
/*!****************************************!*\
  !*** ./src/market/modules/scroller.js ***!
  \****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ Scroller)
/* harmony export */ });
/* harmony import */ var _bus__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./bus */ "./src/market/modules/bus.js");
function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

/**
 * Scroller Class.
 * For calling custom function based on scroll position, or to auto-scroll.
 */


var Scroller = /*#__PURE__*/function (_Bus) {
  _inherits(Scroller, _Bus);

  var _super = _createSuper(Scroller);

  /**
   * Constructor
   */
  function Scroller(target) {
    var _this;

    _classCallCheck(this, Scroller);

    _this = _super.call(this);
    _this._tdef = document.scrollingElement || document.documentElement || window;
    _this._target = target instanceof Element ? target : _this._tdef;
    _this._scrolling = false;
    _this._pos = 0;
    _this._to = 0;
    _this._min = 0;
    _this._max = 0;
    _this._ease = 10;
    _this._triggers = [];
    _this._onScroll = _this._onScroll.bind(_assertThisInitialized(_this));

    _this.addTrigger('up');

    _this.addTrigger('down');

    window.addEventListener('scroll', _this._onScroll);
    window.addEventListener('resize', _this._onScroll);
    return _this;
  }
  /**
   * Add custom scroll trigger
   * @param {string}    name   Trigger name
   * @param {number}    pos    Trigger scroll position
   * @param {function}  cb     Optional callback handler
   * @param {object}    data
   */


  _createClass(Scroller, [{
    key: "addTrigger",
    value: function addTrigger(name, pos, cb, data) {
      var trigger = String(name || '').trim().toLowerCase();
      var position = parseFloat(pos) || 0;
      var callback = typeof cb === 'function' ? cb : function () {};
      var called = false;
      if (!trigger) return;

      this._triggers.push(Object.assign({
        trigger: trigger,
        position: position,
        called: called
      }, data));

      this.on(trigger, callback);
    }
    /**
     * Reset triggers called state to false
     */

  }, {
    key: "resetTriggers",
    value: function resetTriggers() {
      this._triggers.forEach(function (t) {
        called = false;
      });
    }
    /**
     * When elements enter and leave the viewport area
     * @param {*}         targets   CSS selector, or array list of target elements
     * @param {function}  callback  Callback function
     */

  }, {
    key: "onVisible",
    value: function onVisible(targets, callback) {
      var elms = this._getElmList(targets);

      var emap = new Array(elms.length).fill(false);
      this.addTrigger('reveal', 0, callback, {
        elms: elms,
        emap: emap
      });
    }
    /**
     * Auto scroll page to a target destination
     * @param {*}  dest      String selector, number or element
     * @param {*}  callback  Callback function
     */

  }, {
    key: "jumpTo",
    value: function jumpTo(dest, callback) {
      var scrollHeight = Math.max(0, Math.floor(this._target.scrollHeight || 0));
      var clientHeight = Math.max(0, Math.floor(this._target.clientHeight || 0));
      this._max = Math.floor(scrollHeight - clientHeight);
      this._pos = this._target.scrollTop || 0;
      this._to = this._pos;

      if (typeof dest === 'number') {
        this._to = dest;
      } else if (_typeof(dest) === 'object' && dest instanceof Element) {
        this._to = this._pos + dest.getBoundingClientRect().top || this._pos;
      } else if (typeof dest === 'string') {
        if (/^(up|top)$/i.test(dest)) {
          this._to = this._min;
        } else if (/^(middle|center)$/i.test(dest)) {
          this._to = this._max / 2;
        } else if (/^(down|bottom)$/i.test(dest)) {
          this._to = this._max;
        } else if (/^([0-9]+)$/.test(dest)) {
          this._to = parseInt(dest);
        } else {
          var node = document.querySelector(dest);
          this._to = node ? this._pos + node.getBoundingClientRect().top : this._pos;
        }
      }

      this._to = Math.max(this._min, Math.min(this._to, this._max));

      this._jumpLoop(callback);
    }
    /**
     * Autoscroll animation loop
     */

  }, {
    key: "_jumpLoop",
    value: function _jumpLoop(cb) {
      var _this2 = this;

      if (Math.abs(this._to - this._pos) < 1) {
        this._scrolling = false;
        this._target.scrollTop = this._to;

        this._onScrollTick();

        if (typeof cb === 'function') cb(this._to);
        return;
      }

      this._scrolling = true;
      this._pos += (this._to - this._pos) / this._ease;
      this._target.scrollTop = this._pos;
      window.requestAnimationFrame(function () {
        _this2._jumpLoop(cb);
      });
    } // check scroll behavior

  }, {
    key: "_onScrollTick",
    value: function _onScrollTick() {
      var sp = this._target.scrollTop | 0;
      this.emit('scroll', sp);

      for (var i = 0; i < this._triggers.length; ++i) {
        var t = this._triggers[i];

        if (t.trigger === 'up') {
          var check = sp < this._pos;
          if (!t.called && check) this.emit(t.trigger, sp);
          t.called = check;
        }

        if (t.trigger === 'down') {
          var _check = sp > this._pos;

          if (!t.called && _check) this.emit(t.trigger, sp);
          t.called = _check;
        }

        if (t.trigger === 'more') {
          var _check2 = sp > t.position;

          if (!t.called && _check2) this.emit(t.trigger, sp);
          t.called = _check2;
        }

        if (t.trigger === 'less') {
          var _check3 = sp < t.position;

          if (!t.called && _check3) this.emit(t.trigger, sp);
          t.called = _check3;
        }

        if (t.trigger === 'reveal' && t.elms) {
          for (var _i = 0; _i < t.elms.length; ++_i) {
            var e = t.elms[_i];
            var c = t.emap[_i];

            var v = this._checkVisible(e);

            if (!c && v) this.emit('show', e, sp); // entering

            if (c && !v) this.emit('hide', e, sp); // leaving

            t.emap[_i] = v;
          }
        }
      }

      this._pos = sp;
    }
    /**
     * Checks if an element is visible within the height of the scroll window
     * @param {element} elm  Element object
     */

  }, {
    key: "_checkVisible",
    value: function _checkVisible(elm) {
      var height = this._target.clientHeight | 0;
      var box = elm.getBoundingClientRect();
      var yPos = box.top + box.height / 2; // elm middle

      return yPos >= 0 && yPos <= height;
    }
    /**
     * Handler for native scroll event
     * @param {object}  e  Event object
     */

  }, {
    key: "_onScroll",
    value: function _onScroll(e) {
      var _this3 = this;

      if (this._scrolling) return;
      this._scrolling = true;
      window.requestAnimationFrame(function () {
        _this3._onScrollTick();

        _this3._scrolling = false;
      });
    }
    /**
     * Resolve list of elements from an arg
     * @param {*}  elms  String selector, nodelist or array
     */

  }, {
    key: "_getElmList",
    value: function _getElmList(elms) {
      if (typeof elms === 'string') return document.querySelectorAll(elms);
      if (Array.isArray(elms) || elms instanceof NodeList) return elms;
      if (elms instanceof Element) return [elms];
      return [];
    }
  }]);

  return Scroller;
}(_bus__WEBPACK_IMPORTED_MODULE_0__["default"]);



/***/ }),

/***/ "./src/market/modules/sentiment.js":
/*!*****************************************!*\
  !*** ./src/market/modules/sentiment.js ***!
  \*****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function _iterableToArrayLimit(arr, i) { var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"]; if (_i == null) return; var _arr = []; var _n = true; var _d = false; var _s, _e; try { for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

/**
 * Basic sentiment analysis module
 */
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  // score list data
  _afinn: {},
  // words that negate the score of a following word
  _negators: ["cant", "can't", "dont", "don't", "doesnt", "doesn't", "not", "non", "wont", "won't", "isnt", "isn't", "wouldnt", "wouldn't", "couldnt", "couldn't", "didnt", "didn't", "wasnt", "wasn't", "havent", "haven't", "ain't", "aint", "werent", "weren't"],
  // build afinn wordlist
  merge: function merge(list) {
    this._afinn = Object.assign(this._afinn, list);
  },
  // analyse sentiment for text
  analyze: function analyze(text) {
    var score = 0;
    var negative = 0;
    var positive = 0;
    var comparative = 0;

    var list = this._splitWords(text);

    var total = list.length;
    var i = total; // loop filtered input words

    while (i--) {
      if (!this._afinn.hasOwnProperty(list[i])) continue; // not found

      var w = list[i]; // current word

      var p = i > 0 ? list[i - 1] : ''; // previous word

      var s = parseFloat(this._afinn[w]) | 0; // word score

      if (!p || !s) continue; // no score

      if (this._negators.indexOf(p) >= 0) s *= -1; // flip score

      if (s > 0) positive += s;
      if (s < 0) negative += s;
      score += s;
    } // sentiment string params


    var params = ['', 'Neutral', 'icon-help iconLeft text-info']; // positive

    if (score === 1) params = ['+', 'Ok', 'icon-help iconLeft text-success'];
    if (score > 1) params = ['+', 'Positive', 'icon-like iconLeft text-success'];
    if (score > 10) params = ['+', 'Positive', 'icon-like iconLeft text-gain']; // negative

    if (score === -1) params = ['-', 'Ok', 'icon-help iconLeft text-danger'];
    if (score < -1) params = ['-', 'Negative', 'icon-dislike iconLeft text-danger'];
    if (score < -10) params = ['-', 'Negative', 'icon-dislike iconLeft text-loss']; // build sentiment info

    var _params = params,
        _params2 = _slicedToArray(_params, 3),
        sign = _params2[0],
        word = _params2[1],
        styles = _params2[2];

    var sentiment = [word, sign + Math.abs(score)].join(' '); // build final data

    comparative = total ? score / total : 0;
    return {
      score: score,
      positive: positive,
      negative: negative,
      comparative: comparative,
      sign: sign,
      word: word,
      styles: styles,
      sentiment: sentiment
    };
  },
  // filter input text into word list
  _splitWords: function _splitWords(input) {
    var div = document.createElement('div');
    div.innerHTML = String(input || ''); // strip html

    var output = String(div.textContent || div.innerText || '').toLowerCase().trim(); // clean string

    output = output.replace(/([\`\'\’]+)/g, "'") // normalize apostrophes
    .replace(/([\“\”\“\”\"]+)/g, '"') // normalize quotes
    .replace(/([\-]+)/g, '-') // normalize dashes
    .replace(/([^a-z\'\-]+)/g, ' ') // only allow these
    .replace(/[\t\r\n\s\uFEFF\xA0]+/g, ' ') // remove whitespace
    .trim(); // split

    return output.split(/\s+/g);
  }
});

/***/ }),

/***/ "./src/market/modules/sorter.js":
/*!**************************************!*\
  !*** ./src/market/modules/sorter.js ***!
  \**************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ Sorter)
/* harmony export */ });
/* harmony import */ var _bus__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./bus */ "./src/market/modules/bus.js");
/* harmony import */ var _store__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./store */ "./src/market/modules/store.js");
function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

/**
 * Helper module for sorting lists
 */



var Sorter = /*#__PURE__*/function (_Bus) {
  _inherits(Sorter, _Bus);

  var _super = _createSuper(Sorter);

  /**
   * Constructor
   */
  function Sorter(target) {
    var _this;

    _classCallCheck(this, Sorter);

    _this = _super.call(this);
    _this._key = 'list_sort_data';
    _this._lists = {};
    return _this;
  }
  /**
   * Save sort data to store
   */


  _createClass(Sorter, [{
    key: "saveData",
    value: function saveData() {
      _store__WEBPACK_IMPORTED_MODULE_1__["default"].setData(this._key, this._lists);
      this.emit('save', this._lists);
    }
    /**
     * Load sort data from store
     */

  }, {
    key: "loadData",
    value: function loadData() {
      var data = _store__WEBPACK_IMPORTED_MODULE_1__["default"].getData(this._key);
      this._lists = data || this._lists;
      this.emit('load', this._lists);
    }
    /**
     *  Get all sort data
     */

  }, {
    key: "getData",
    value: function getData() {
      return this._lists;
    }
    /**
     * Set sort data for a key
     */

  }, {
    key: "setKey",
    value: function setKey(key, column, order, search) {
      column = String(column || 'id');
      order = String(order || 'asc');
      search = String(search || '');
      this._lists[key] = {
        column: column,
        order: order,
        search: search
      };
      return this._lists[key];
    }
    /**
     * Get sort data for a key
     */

  }, {
    key: "getKey",
    value: function getKey(key) {
      return this._lists[key] || null;
    }
    /**
     * Set new sort order for a key
     */

  }, {
    key: "sortOrder",
    value: function sortOrder(key, column, order) {
      var d = this._lists[key] || null;

      if (d) {
        if (column !== d.column) {
          d.order = order || 'asc';
        } else {
          d.order = d.order === 'asc' ? 'desc' : 'asc';
        }

        d.column = column;
      }

      this.emit('change', this._lists);
      this.saveData();
      return d;
    }
    /**
     * Apply search text for a key
     */

  }, {
    key: "setSearch",
    value: function setSearch(key, text) {
      var d = this._lists[key] || null;
      if (d) d.search = String(text || '').trim();
      this.emit('change', this._lists);
      return d;
    }
    /**
     * Check if sort column is active for a key
     */

  }, {
    key: "checkActive",
    value: function checkActive(key, column) {
      var d = this._lists[key] || null;
      if (d) return d.column === column;
      return false;
    }
    /**
     * Get css icon style for a key
     */

  }, {
    key: "getStyles",
    value: function getStyles(key, column) {
      var d = this._lists[key] || null;
      var c = column || d.column;
      if (d && c === d.column && d.order === 'asc') return 'icon-up';
      if (d && c === d.column && d.order === 'desc') return 'icon-down';
      return 'hidden';
    }
  }]);

  return Sorter;
}(_bus__WEBPACK_IMPORTED_MODULE_0__["default"]);



/***/ }),

/***/ "./src/market/modules/store.js":
/*!*************************************!*\
  !*** ./src/market/modules/store.js ***!
  \*************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/**
 * Web cache handler
 */
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  // local props
  _api: 'localStorage',
  _prefix: 'webcache_',
  _ttl: 0,
  // save data to cache
  setData: function setData(key, data, time) {
    return this._save(key, data, time);
  },
  // get saved data for a key as is
  getData: function getData(key) {
    this._clean();

    return this._fetch(key);
  },
  // delete saved data for key
  deleteData: function deleteData(key) {
    return this._delete(key);
  },
  // santizer for keys
  _key: function _key(key) {
    return this._prefix + String(key || '').replace(/[^\w]+/g, '_');
  },
  // error handler
  _error: function _error(e) {
    var _code = e.code | 0;

    var _name = e.name || 'UnknownError';

    var _info = e.message || 'Problem with ' + this._api + ' browser API.';

    console.error('StorageError (' + _code + '):', _info, '(' + _name + ').');
    return false;
  },
  // try saving the data and handle any errors
  _save: function _save(key, data, ttl) {
    try {
      var _store = window[this._api];

      var _key = this._key(key);

      var _time = Date.now();

      var _ttl = parseInt(ttl) || this._ttl;

      var _string = JSON.stringify({
        _time: _time,
        _ttl: _ttl,
        data: data
      });

      _store.setItem(_key, _string);

      return true;
    } catch (e) {
      return this._error(e);
    }
  },
  // try fetching data for key
  _fetch: function _fetch(key) {
    try {
      var _store = window[this._api];

      var _key = this._key(key);

      var _parsed = JSON.parse(_store.getItem(_key) || '{}');

      return _parsed && _parsed.data ? _parsed.data : null;
    } catch (e) {
      return this._error(e);
    }
  },
  // try deleting data by key
  _delete: function _delete(key) {
    try {
      var _store = window[this._api];

      var _key = this._key(key);

      _store.removeItem(_key);

      return true;
    } catch (e) {
      return this._error(e);
    }
  },
  // clean all expired items from storage
  _clean: function _clean() {
    try {
      var _store = window[this._api];

      var _time = Date.now(); // loop keys


      for (var i = 0; i < _store.length; i++) {
        // make sure it's a key managed by this object
        var _key = _store.key(i);

        if (_key.indexOf(this._prefix) < 0) continue; // get data for key

        var _data = JSON.parse(_store.getItem(_key) || '{}');

        if (!_data._time || !_data._ttl) continue; // need these
        // check if enough time has passed and delete key

        var _secs = (_time - _data._time) / 1000;

        if (_secs < _data._ttl) continue; // still fresh

        _store.removeItem(_key);
      }

      return true;
    } catch (e) {
      return this._error(e);
    }
  }
});

/***/ }),

/***/ "./src/market/modules/symbol.js":
/*!**************************************!*\
  !*** ./src/market/modules/symbol.js ***!
  \**************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ _Symbol)
/* harmony export */ });
function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }

/**
 * Ticker symbol class
 */
var _Symbol = /*#__PURE__*/function () {
  // constructor
  function _Symbol() {
    var symbol = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';

    _classCallCheck(this, _Symbol);

    this.symbol = String(symbol || '').toUpperCase();
    this.id = ''; // custom unique token id

    this.token = ''; // base asset token

    this.market = ''; // quote asset token (market)

    this.name = ''; // name of token

    this.pair = ''; // token/market

    this.route = '/symbol/' + this.symbol;
    this.image = '../../../assets/images/cryptoCurrency/default_.png';
    this.imageLoaded = false;
    this.open = 0;
    this.high = 0;
    this.low = 0;
    this.close = 0;
    this.change = 0;
    this.percent = 0;
    this.trades = 0;
    this.tokenVolume = 0;
    this.marketVolume = 0;
    this.volatility = 0;
    this.danger = 0;
    this.time = 0;
    this.rank = 0;
    this.supply = 0;
    this.capusd = 0;
    this.history = [];
    this.candles = [];
    this.sign = '';
    this.arrow = '';
    this.style = '';
  }
  /**
   * Split full symbol (BTCUSD) into token and asset symbols (BTC, USD)
   */


  _createClass(_Symbol, [{
    key: "splitSymbol",
    value: function splitSymbol() {
      var markets = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
      if (this.token || this.market || !markets.length) return;
      var quotes = markets.join('|');
      var regexp = new RegExp("^([A-Z0-9]+)(".concat(quotes, ")$"));
      this.token = this.symbol.replace(regexp, '$1') || this.token;
      this.market = this.symbol.replace(regexp, '$2') || this.market;
      this.name = this.token;
      this.pair = this.token + '/' + this.market;
    }
    /**
     * Set coin data fetched from coincap API
     * https://docs.coincap.io/
     */

  }, {
    key: "setCoinData",
    value: function setCoinData(data) {
      if (_typeof(data) !== 'object') return;
      this.id = String(data.id || this.id).trim();
      this.name = String(data.name || this.token).trim();
      this.rank = Number(data.rank || 0);
      this.supply = Number(data.supply || 0);
      this.capusd = Number(data.marketCapUsd || 0);
    }
    /**
     * Set latest ticker values from binance socket API
     * https://binance-docs.github.io/apidocs/spot/en/#individual-symbol-mini-ticker-stream
     */

  }, {
    key: "setTickerData",
    value: function setTickerData(data) {
      this.open = Number(data.o || data.openPrice || 0);
      this.high = Number(data.h || data.highPrice || 0);
      this.low = Number(data.l || data.lowPrice || 0);
      this.close = Number(data.c || data.lastPrice || 0);
      this.change = Number(data.p || data.priceChange || 0);
      this.percent = Number(data.P || data.priceChangePercent || 0);
      this.trades = Number(data.n || data.count || 0);
      this.tokenVolume = Number(data.v || data.volume || 0);
      this.marketVolume = Number(data.q || data.quoteVolume || 0);
      this.sign = this.percent > 0 ? '+' : '';
      this.arrow = this.percent > 0 ? '▲' : '▼';
      this.calcVolatility();
      this.calcDanger();
      this.calcHistory();
      this.calcStyle();
    }
    /**
     * Resolve token icon image
     */

  }, {
    key: "resolveImage",
    value: function resolveImage() {
      //if ( !this.token || this.imageLoaded ) return;
      //let img = new Image();
      //img.addEventListener( 'load',  e => { this.imageLoaded = true; this.image = img.src; } );
      //img.addEventListener( 'error', e => { this.imageLoaded = true; } );
      //img.src = '../../../assets/images/cryptoCurrency/'+ String( this.token ).toLowerCase() +'_.png';
      this.imageLoaded = !0, this.image = "../../../assets/images/cryptoCurrency/" + String(this.token).toLowerCase() + ".png";
    }
    /**
     * Get symbol data with merged data
     * @param {object}  merge  Optional object
     */

  }, {
    key: "getData",
    value: function getData(merge) {
      var volume = this.marketVolume;
      var id = this.id,
          symbol = this.symbol,
          token = this.token,
          market = this.market,
          name = this.name,
          pair = this.pair,
          route = this.route,
          image = this.image,
          close = this.close,
          capusd = this.capusd,
          supply = this.supply;
      return Object.assign({
        id: id,
        symbol: symbol,
        token: token,
        market: market,
        name: name,
        pair: pair,
        route: route,
        image: image,
        close: close,
        capusd: capusd,
        supply: supply,
        volume: volume
      }, merge);
    }
    /**
     * Cleanup stored price data
     */

  }, {
    key: "flushData",
    value: function flushData() {
      this.history = [];
      this.candles = [];
    }
    /**
     * Calculate style class based on percent
     */

  }, {
    key: "calcStyle",
    value: function calcStyle() {
      this.style = '';
      if (this.percent > 0) this.style = 'gain';
      if (this.percent < 0) this.style = 'loss';
    }
    /**
     * Calculate 24h high/low volatility score
     */

  }, {
    key: "calcVolatility",
    value: function calcVolatility() {
      var change = this.high - this.low;
      this.volatility = this.high ? change / this.high * 100.0 : 0.0;
    }
    /**
     * Calculate possible pump/dump danger score based on cached price action from recent few hours
     */

  }, {
    key: "calcDanger",
    value: function calcDanger() {
      var now = Date.now();
      var wait = 300; // secs to wait

      var hrs = 3; // hours to store prices

      var secs = (now - this.time) / 1000;
      var total = 60 * 60 * hrs / wait;
      if (secs < wait) return;
      this.candles.push(this.close);
      this.candles.splice(0, this.candles.length - total);
      var idx = this.candles.length;
      var min = this.candles[0];
      var max = this.candles[0];

      while (idx--) {
        var price = this.candles[idx];
        min = price < min ? price : min;
        max = price > max ? price : max;
      }

      var change = max - min;
      this.danger = max ? change / max * 100.0 : 0.0;
      this.time = now;
    }
    /**
     * Manages a history list with the latest close price
     */

  }, {
    key: "calcHistory",
    value: function calcHistory() {
      if (!this.history.length) this.fakeHistory();
      this.history.push(this.close);
      this.history.splice(0, this.history.length - 30);
    }
    /**
     * Come up with some fake history prices to fill in the initial line chart
     */

  }, {
    key: "fakeHistory",
    value: function fakeHistory() {
      var num = this.close * 0.0002;
      var min = -Math.abs(num);
      var max = Math.abs(num);
      this.history = [];

      for (var i = 0; i < 30; ++i) {
        var rand = Math.random() * (max - min) + min;
        this.history.push(this.close + rand);
      }
    }
  }]);

  return _Symbol;
}();



/***/ }),

/***/ "./src/market/modules/tooltip.js":
/*!***************************************!*\
  !*** ./src/market/modules/tooltip.js ***!
  \***************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ Tooltip)
/* harmony export */ });
/* harmony import */ var _viewport__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./viewport */ "./src/market/modules/viewport.js");
function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }

/**
 * Tooltips Class.
 * Adds custom tooltips to elements on the page.
 */


var Tooltip = /*#__PURE__*/function () {
  // class constructor
  function Tooltip(options) {
    _classCallCheck(this, Tooltip);

    this._options = Object.assign({
      // class to apply to tooltip element
      tipClass: 'tooltip-wrap',
      // class to apply when tooltip is placed on the left
      leftClass: 'tooltip-left',
      // class to apply when tooltip is placed on the right
      rightClass: 'tooltip-right',
      // class to apply when tooltip is placed on the top
      topClass: 'tooltip-top',
      // class to apply when tooltip is placed on the bottom
      bottomClass: 'tooltip-bottom',
      // delay to show the tooltip
      showDelay: 100,
      // auto hide delay
      hideDelay: 3000 // ...

    }, options);
    this._tooltip = null;
    this._hovItem = null;
    this._timeout = null;
    this._autohide = null;
    this._visible = false;
    this._elements = [];
    this._onScroll = this._onScroll.bind(this);

    this._init();
  } // set target elements


  _createClass(Tooltip, [{
    key: "select",
    value: function select(selector) {
      if (typeof selector === 'string') {
        this._elements = document.querySelectorAll(selector) || [];
      } else if (_typeof(selector) === 'object' && selector instanceof Element) {
        this._elements.push(selector);
      }

      for (var i = 0; i < this._elements.length; ++i) {
        this._setupItem(this._elements[i]);
      }

      this._hideTooltip();
    } // remove element from the list

  }, {
    key: "unselect",
    value: function unselect(element) {
      if (_typeof(element) === 'object' && element instanceof Element) {
        for (var i = 0, t = this._elements.length; i < t; ++i) {
          if (this._elements[i] === element) {
            this._resetItem(this._elements[i]);

            this._elements.splice(i, 1);

            break;
          }
        }

        this._hideTooltip();
      }
    } // cleanup this instance

  }, {
    key: "destroy",
    value: function destroy() {
      for (var i = 0; i < this._elements.length; ++i) {
        this._resetItem(this._elements[i]);
      }

      if (document.body.contains(this._tooltip)) {
        document.body.removeChild(this._tooltip);
      }

      window.removeEventListener('scroll', this._onScroll);
      window.removeEventListener('touchmove', this._onScroll);
      this._elements = [];
      this._tooltip = null;
    } // initlaize elements

  }, {
    key: "_init",
    value: function _init() {
      this._tooltip = document.createElement('div');
      this._tooltip.className = this._options.tipClass;
      this._tooltip.style['display'] = 'block';
      this._tooltip.style['position'] = 'absolute';
      this._tooltip.style['pointer-events'] = 'none';

      this._hideTooltip();

      document.body.appendChild(this._tooltip);
      window.addEventListener('scroll', this._onScroll);
      window.addEventListener('touchmove', this._onScroll);
    } // set an element to have tooltip, if not alredy setup

  }, {
    key: "_setupItem",
    value: function _setupItem(item) {
      var _this = this;

      if (item && item instanceof Element) {
        if (item.hasAttribute('title')) {
          var _passive = {
            passive: true
          };
          item.setAttribute('data-tip', item.getAttribute('title') || '');
          item.removeAttribute('title');
          item.addEventListener('mouseenter', function (e) {
            _this._onEnter(e);
          }, _passive);
          item.addEventListener('touchstart', function (e) {
            _this._onEnter(e);
          }, _passive);
          item.addEventListener('mouseleave', function (e) {
            _this._onLeave(e);
          }, _passive);
          item.addEventListener('touchend', function (e) {
            _this._onLeave(e);
          }, _passive);
        }
      }
    } // remove tooltip events from element, if needed

  }, {
    key: "_resetItem",
    value: function _resetItem(item) {
      var _this2 = this;

      if (item && item instanceof Element) {
        if (item.hasAttribute('data-tip')) {
          item.setAttribute('title', item.getAttribute('data-tip') || '');
          item.removeAttribute('data-tip');
          item.removeEventListener('mouseenter', function (e) {
            _this2._onEnter(e);
          });
          item.removeEventListener('touchstart', function (e) {
            _this2._onEnter(e);
          });
          item.removeEventListener('mouseleave', function (e) {
            _this2._onLeave(e);
          });
          item.removeEventListener('touchend', function (e) {
            _this2._onLeave(e);
          });
        }
      }
    } // decides where to place the tooltip in relation to item and screen bounds

  }, {
    key: "_showTooltip",
    value: function _showTooltip() {
      if (this._tooltip && this._hovItem) {
        var box = this._hovItem.getBoundingClientRect();

        var centerX = box.left + (this._hovItem.offsetWidth - this._tooltip.offsetWidth) / 2;
        var centerY = box.top + (this._hovItem.offsetHeight - this._tooltip.offsetHeight) / 2;
        var leftPos = box.left - this._tooltip.offsetWidth;
        var rightPos = box.left + this._hovItem.offsetWidth;
        var topPos = box.top - this._tooltip.offsetHeight;
        var bottomPos = box.top + this._hovItem.offsetHeight;
        var tipHalf = this._tooltip.offsetWidth / 2;
        var boxCenter = box.top - this._hovItem.offsetHeight / 2;
        var halfScreen = window.innerHeight / 2;
        var isNearLeft = box.left < tipHalf;
        var isNearRight = _viewport__WEBPACK_IMPORTED_MODULE_0__["default"].clientWidth() - rightPos < tipHalf;
        var clss = this._options.topClass;
        var left = centerX;
        var top = topPos; // move to the bottom

        if (boxCenter < halfScreen) {
          clss = this._options.bottomClass;
          left = centerX;
          top = bottomPos;
        } // move to the right


        if (isNearLeft && !isNearRight) {
          clss = this._options.rightClass;
          left = rightPos;
          top = centerY;
        } // move to the left


        if (isNearRight && !isNearLeft) {
          clss = this._options.leftClass;
          left = leftPos;
          top = centerY;
        } // show tooltip


        if (left > 1 && top > 1 && this._tooltip.innerHTML) {
          this._tooltip.className = this._options.tipClass + ' ' + clss;
          this._tooltip.style['left'] = _viewport__WEBPACK_IMPORTED_MODULE_0__["default"].scrollLeft() + left + 'px';
          this._tooltip.style['top'] = _viewport__WEBPACK_IMPORTED_MODULE_0__["default"].scrollTop() + top + 'px';
          this._visible = true;
        }
      }
    } // move tooltip object off screen, reset content and class

  }, {
    key: "_hideTooltip",
    value: function _hideTooltip() {
      if (this._tooltip) {
        this._tooltip.innerHTML = '';
        this._tooltip.className = this._options.tipClass;
        this._tooltip.style['left'] = '-1000px';
        this._tooltip.style['top'] = '-1000px';
        this._visible = false;
      }
    } // when mouse enters target element

  }, {
    key: "_onEnter",
    value: function _onEnter(e) {
      var item = e.target;
      var title = item.getAttribute('data-tip');

      if (title) {
        this._hovItem = item;
        this._tooltip.innerHTML = title;
        if (this._timeout) clearTimeout(this._timeout);
        this._timeout = setTimeout(this._showTooltip.bind(this), this._options.showDelay);
        if (this._autohide) clearTimeout(this._autohide);
        this._autohide = setTimeout(this._hideTooltip.bind(this), this._options.hideDelay);
      }
    } // when mouse leaves target element

  }, {
    key: "_onLeave",
    value: function _onLeave(e) {
      if (this._timeout) {
        clearTimeout(this._timeout);
        this._timeout = null;
      }

      this._hovItem = null;

      this._hideTooltip();
    } // hide tooltip over fixed elements when scrolled

  }, {
    key: "_onScroll",
    value: function _onScroll(e) {
      if (this._visible) {
        this._hideTooltip();
      }
    }
  }]);

  return Tooltip;
}();



/***/ }),

/***/ "./src/market/modules/twitter.js":
/*!***************************************!*\
  !*** ./src/market/modules/twitter.js ***!
  \***************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ Twitter)
/* harmony export */ });
function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }

/**
 * Twitter scraper and tweets manager class.
 */
var Twitter = /*#__PURE__*/function () {
  /**
   * Constructor
   * @param {string}  handle   Twitter handle
   * @param {object}  options  Fetching options
   */
  function Twitter(handle, options) {
    _classCallCheck(this, Twitter);

    if (!handle || typeof handle !== 'string') {
      throw 'Must provide a valid twitter handle string.';
    }

    this.uid = '';
    this.handle = '';
    this.name = '';
    this.avatar = '';
    this.url = '';
    this.error = '';
    this.last = 0;
    this.fetching = false;
    this._options = {
      skipPinned: true,
      // ignore pinned tweets
      skipRetweet: true,
      // ignore re-tweets
      cleanTweets: true,
      // strip html and whitespace from tweets
      fetchDelay: 300,
      // prevent re-fetching for (secs)
      limitCount: 1 // limit number of tweets parsed

    };
    this.setOptions(options);
    this.setData({
      handle: handle,
      name: handle
    });
  }
  /**
    * Update options
    * @param {object}  options  Options object
    */


  _createClass(Twitter, [{
    key: "setOptions",
    value: function setOptions(options) {
      Object.assign(this._options, options);
    }
    /**
     * Set new acocunt data
     * @param {object} data  Twitter account data
     */

  }, {
    key: "setData",
    value: function setData(data) {
      if (_typeof(data) !== 'object') return;
      if (data.uid) this.uid = String(this.uid).replace(/[^\w\-]+/g, '');
      if (data.handle) this.handle = String(data.handle).replace(/[^\w\-]+/g, '');
      if (data.name) this.name = String(data.name).replace(/[\r\n\s\t]+/g, ' ').trim();
      if (data.avatar) this.avatar = String(data.avatar).trim();
      this.url = 'https://twitter.com/' + this.handle;
    }
    /**
     * Get account info
     */

  }, {
    key: "getData",
    value: function getData() {
      var uid = this.uid,
          handle = this.handle,
          name = this.name,
          avatar = this.avatar,
          url = this.url,
          last = this.last,
          fetching = this.fetching,
          error = this.error;
      return {
        uid: uid,
        handle: handle,
        name: name,
        avatar: avatar,
        url: url,
        last: last,
        fetching: fetching,
        error: error
      };
    }
    /**
     * Fetch remote tweets using ajax module
     * @param {object}    ajax      Ajax module instance to use for request
     * @param {function}  callback  Callback function
     */

  }, {
    key: "fetchTweets",
    value: function fetchTweets(ajax, callback) {
      var _this = this;

      if (!callback || typeof callback !== 'function') return;
      if (!ajax || _typeof(ajax) !== 'object') return callback('Must provide an ajax module reference.', []);
      if (!this._canFetch()) return callback('', []); // too soon, ignore

      this.fetching = true;
      this.error = '';
      ajax.get(this.url, {
        type: 'text',
        timeout: 30,
        notAjax: true,
        done: function done(xhr, status, response) {
          _this.fetching = false;
        },
        error: function error(xhr, status, _error) {
          _this.error = _error + ' | @' + _this.handle + '.';
          return callback(_this.error, []);
        },
        success: function success(xhr, status, response) {
          var parser = new DOMParser();

          var html = _this._cleanHtml(response);

          var doc = parser.parseFromString(html, 'text/html');

          if (doc && doc instanceof HTMLDocument) {
            _this.last = Date.now();
            callback('', _this.parseTweets(doc));
          } else {
            _this.error = 'DOMParserError: Could not parse response from ' + _this.url;
            callback(_this.error, []);
          }

          parser = null;
          html = null;
          doc = null;
        }
      });
    }
    /**
     * Parse account and tweets data from a fetched HTML response
     * @param {HTMLDocument}  doc  Twitter account page document
     */

  }, {
    key: "parseTweets",
    value: function parseTweets(doc) {
      var limit = this._options.limitCount | 0;
      var count = 0;
      var output = []; // look for profile avatar

      var avatar = doc.querySelector('img.ProfileAvatar-image');
      avatar = avatar ? avatar.src : ''; // look for items

      var items = doc.querySelectorAll('.stream-item') || []; // loop tweet list items

      for (var i = 0; i < items.length; ++i) {
        if (limit && count >= limit) break; // look for tweet data

        var item = items[i];
        var tweet = item ? item.querySelector('.js-stream-tweet') : null; // metadata tag

        var posted = item ? item.querySelector('.js-short-timestamp') : null; // date tag

        var content = item ? item.querySelector('.js-tweet-text') : null; // tweet wrapper

        var text = ''; // look for account info

        var id = tweet ? tweet.getAttribute('data-tweet-id') || '' : '';
        var uid = tweet ? tweet.getAttribute('data-user-id') || '' : '';
        var name = tweet ? tweet.getAttribute('data-name') || '' : '';
        var handle = tweet ? tweet.getAttribute('data-screen-name') || '' : '';
        var link = tweet ? 'https://twitter.com' + tweet.getAttribute('data-permalink-path') || 0 : '';
        var time = posted ? Number(posted.getAttribute('data-time-ms')) || 0 : 0; // update profile details

        this.setData({
          uid: uid,
          handle: handle,
          name: name,
          avatar: avatar
        }); // resolve tweet text

        if (content) {
          text = this._options.cleanTweets ? this._cleanTweet(content.textContent) : String(content.innerHTML || '').trim();
        } // check a few things, skip if needed


        if (!id || !uid || !name || !handle || !text || !time || time < 0) continue;
        if (this._options.skipPinned && item.classList.contains('js-pinned')) continue;
        if (this._options.skipRetweet && tweet.hasAttribute('data-retweet-id')) continue; // format time

        var d = new Date(time);
        var date = d.toDateString(); // add tweet to list and update account info

        output.push({
          id: id,
          uid: uid,
          time: time,
          date: date,
          name: name,
          handle: handle,
          avatar: avatar,
          text: text,
          link: link
        });
        count++;
      }

      items = null;
      return output;
    }
    /**
     * Check last fetch time to see if it's ok to fetch again
     */

  }, {
    key: "_canFetch",
    value: function _canFetch() {
      var now = Date.now();
      var elapsed = Math.floor((now - this.last) / 1000);
      var delay = this._options.fetchDelay | 0;
      if (this.fetching || this.last >= now) return false; // busy, wait

      if (delay && elapsed < delay) return false; // too soon, wait

      return true; // looks good
    }
    /**
     * Clean tweet text
     * @param {string}  text  Strign to clean
     */

  }, {
    key: "_cleanTweet",
    value: function _cleanTweet(text) {
      return String(text || '').replace(/([^\s]+)(https?\:|pic\.)/g, '$1 $2') // add space around links
      .replace('pic.twitter', 'https://pic.twitter') // fix some links without proto
      .replace(/([\`\'\’]+)/g, "'") // normalize apostrophes
      .replace(/([\“\”\“\”\"]+)/g, '"') // normalize quotes
      .replace(/[\…\#\$]+/g, ' ') // remove some junk chars
      .replace(/[\t\r\n\s\uFEFF\xA0]+/g, ' ').trim(); // collapse whitespace
    }
    /**
     * Clean html content
     * @param {string}  html  HTML text to clean
     */

  }, {
    key: "_cleanHtml",
    value: function _cleanHtml(html) {
      return String(html || '').replace(/<(style|script)[^>]*>(?:(?!<\/(style|script)>)[^])*<\/(style|script)>/gim, '').replace(/[\r\n\s\t]+/g, ' ').trim();
    }
  }]);

  return Twitter;
}();



/***/ }),

/***/ "./src/market/modules/utils.js":
/*!*************************************!*\
  !*** ./src/market/modules/utils.js ***!
  \*************************************/
/***/ ((module) => {

function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }

/**
 * Common utils
 */
module.exports = {
  // convert url string into an anchor element (parser)
  parseUrl: function parseUrl(url, prop) {
    var link = document.createElement('a');
    link.href = url;
    var data = link[prop] || '';
    link = null;
    return data;
  },
  // convert URLs into clickable links
  linkUrl: function linkUrl(text) {
    return String(text || '').replace(/(https?\:\/\/[\w\-\.\?\=\&\%\/\#]+)/gi, '<a href="$1" target="_blank">$1</a>');
  },
  // convert html tags to text content
  stripHtml: function stripHtml(text, removeUrls) {
    var div = document.createElement('div');
    div.innerHTML = String(text || '');
    var output = String(div.textContent || div.innerText || '');
    if (removeUrls) output = output.replace(/(https?\:\/\/[\w\-\.\?\=\&\%\/\#]+)/gi, '');
    return output;
  },
  // convert relative path to full url
  fullUrl: function fullUrl(relpath) {
    if (/^([\w\-]+\:)?\/\/.*$/.test(relpath)) return relpath;
    var loc = window.location;
    var path = String(loc.pathname || '').replace(/\/+$/g, '');
    var rel = String(relpath || '').replace(/^\/+/g, '');
    return loc.protocol + '//' + loc.host + path + '/' + rel;
  },
  // play audio file
  playAudio: function playAudio(file, vol) {
    if (!file || typeof file !== 'string') return; // normalize volume

    vol = parseFloat(vol) || 1;
    vol = vol > 1 ? vol / 100 : vol;
    vol = vol > 1 || vol < 0 ? 1 : vol; // load and play audio

    var audio = new Audio();
    audio.src = this.fullUrl(file);
    audio.volume = vol;
    audio.crossOrigin = 'anonymous';
    audio.addEventListener('canplaythrough', function (e) {
      try {
        audio.play();
      } catch (err) {}
    });
    audio.load();
  },
  // copy text to clipboard
  copyText: function copyText(text) {
    var elm = document.createElement('input');
    document.body.appendChild(elm);
    elm.value = String(text || '').trim();
    elm.select();
    setTimeout(function () {
      return elm.remove();
    }, 1000);
    return document.execCommand('Copy');
  },
  // clamp a number between min and max
  clamp: function clamp(num, min, max) {
    return Math.min(Math.max(num, min), max);
  },
  // cut part of a string
  limit: function limit(str, length, append) {
    str = String(str);
    length = parseInt(length) || 50;
    append = String(append || '');
    return str.length > length ? str.substring(0, length) + append : str;
  },
  // alway keep a string at a certain length
  fill: function fill(str, length, _char, append) {
    str = String(str);
    length = parseInt(length) || 20;
    _char = String(_char || ' ');
    append = String(append || '');
    if (str.length > length) return str.substring(0, length - 3) + '...';
    return str + _char.repeat(length - str.length) + append;
  },
  // get noun word for a number
  noun: function noun(num, singular, plutal, append) {
    append = String(append || '');
    return String(num + ' ' + (parseFloat(num) === 1 ? singular : plutal) + ' ' + append).trim();
  },
  // format number to money
  money: function money(num, fixed) {
    num = parseFloat(num) || 0;
    fixed = parseInt(fixed) || 0;
    var o = {
      style: 'decimal',
      minimumFractionDigits: fixed,
      maximumFractionDigits: fixed
    };
    return new Intl.NumberFormat('en-US', o).format(num);
  },
  // fixed numbers
  fixed: function fixed(num, decimals) {
    if (typeof decimals === 'number') return Number(num).toFixed(decimals);
    if (/(USD|PAX|DAI)/.test(decimals)) return this.money(num, 3);
    return Number(num).toFixed(8);
  },
  // get info about how long something has been
  elapsed: function elapsed(secs, suffix, _short) {
    secs = parseInt(secs) || 0;
    if (_short && secs < 60) return 'Just now';
    var list = [];
    var data = {
      'M': Math.floor(secs / 2419200),
      'w': Math.floor(secs / 604800 % 4),
      'd': Math.floor(secs / 86400 % 7),
      'h': Math.floor(secs / 3600 % 24),
      'm': Math.floor(secs / 60 % 60)
    };
    if (!_short) data.s = Math.floor(secs % 60);
    Object.keys(data).forEach(function (k) {
      if (data[k]) list.push(data[k] + k);
    });
    if (suffix) list.push(suffix);
    return list.join(' ');
  },
  // get data about current date and time
  dateData: function dateData(time) {
    var now = Date.now();

    if (time) {
      // timestamp or datestring, keep as is
      if (typeof time === 'number' || /^[\w\-\+\:]+$/.test(time)) {
        now = time;
      } // other string, assume timezone
      else if (typeof time === 'string') {
        now = new Date().toLocaleString('en-US', {
          time: time
        });
      }
    }

    var _p = function _p(n) {
      return n < 10 ? '0' + n : '' + n;
    };

    var date = new Date(now);
    var month = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'][date.getMonth()];
    var year = date.getFullYear();

    var day = _p(date.getDate());

    var minute = _p(date.getMinutes());

    var second = _p(date.getSeconds());

    var fullh = date.getHours();
    var ampm = fullh > 12 ? 'PM' : 'AM';
    var hour = fullh > 12 ? fullh - 12 : fullh;
    hour = _p(hour === 0 ? 12 : hour);
    return {
      month: month,
      day: day,
      year: year,
      hour: hour,
      minute: minute,
      second: second,
      ampm: ampm
    };
  },
  // get readable date
  date: function date(time, full) {
    var _this$dateData = this.dateData(time),
        month = _this$dateData.month,
        day = _this$dateData.day,
        year = _this$dateData.year,
        hour = _this$dateData.hour,
        minute = _this$dateData.minute,
        second = _this$dateData.second,
        ampm = _this$dateData.ampm;

    var out = [month + '/' + day + '/' + year];
    if (full) out.push(hour + ':' + minute + ':' + second, ampm);
    return out.join(' ');
  },
  // get current time
  time: function time(_time) {
    var _this$dateData2 = this.dateData(_time),
        hour = _this$dateData2.hour,
        minute = _this$dateData2.minute,
        second = _this$dateData2.second,
        ampm = _this$dateData2.ampm;

    return hour + ':' + minute + ':' + second + ' ' + ampm;
  },
  // calculate percent change
  percent: function percent(current, last, toNum) {
    var isnum = Boolean(last > 0);
    var isup = Boolean(current >= last);
    var change = isup ? current - last : last - current;
    var percent = isnum ? change / last * 100.0 : 0.0;
    var sign = isup ? '+' : '-';
    var arrow = isup ? '▲' : '▼';
    var color = isup ? 'green' : 'red';
    if (toNum === true) return +Number(sign + percent).toFixed(3);
    return {
      change: change,
      percent: percent,
      sign: sign,
      arrow: arrow,
      color: color
    };
  },
  // calc chart points for given dimensions and values
  points: function points(width, height, values) {
    width = parseFloat(width) || 0;
    height = parseFloat(height) || 0;
    values = Array.isArray(values) ? values : [];
    values = values.map(function (n) {
      return parseFloat(n) || 0;
    });
    var min = values.reduce(function (min, val) {
      return val < min ? val : min;
    }, values[0]);
    var max = values.reduce(function (max, val) {
      return val > max ? val : max;
    }, values[0]);
    var len = values.length;
    var half = height / 2;
    var range = max > min ? max - min : height;
    var gap = len > 1 ? width / (len - 1) : 1;
    var out = [];

    for (var i = 0; i < len; ++i) {
      var d = values[i];
      var val = 2 * ((d - min) / range - 0.5);
      var x = i * gap;
      var y = -val * half * 0.8 + half;
      out.push({
        x: x,
        y: y
      });
    }

    return out;
  },
  // compute placement for an absolute box on the screen
  boxPosition: function boxPosition(triggerElm) {
    var top = true,
        right = false,
        bottom = false,
        left = true;

    if (triggerElm instanceof HTMLElement) {
      var box = triggerElm.getBoundingClientRect();
      var posx = box.left + triggerElm.offsetWidth / 2;
      var posy = box.top + triggerElm.offsetHeight / 2;
      var centerx = window.innerWidth / 2;
      var centery = window.innerHeight / 2;
      top = posy < centery ? true : false;
      right = posx > centerx ? true : false;
      bottom = posy > centery ? true : false;
      left = posx < centerx ? true : false;
      return {
        top: top,
        right: right,
        bottom: bottom,
        left: left
      };
    }
  },
  // check a key-press event for some common keys being pressed
  keyboard: function keyboard(e) {
    var code = e.keyCode || e.key || 0;
    var up = code === 38;
    var down = code === 40;
    var left = code === 37;
    var right = code === 39;
    var back = code === 8;
    var escape = code === 27;
    var space = code === 32;
    var enter = code === 13;
    return {
      up: up,
      down: down,
      left: left,
      right: right,
      back: back,
      escape: escape,
      space: space,
      enter: enter
    };
  },
  // shuffle an array
  shuffle: function shuffle(o) {
    for (var j, x, i = o.length; i; j = parseInt(Math.random() * i), x = o[--i], o[i] = o[j], o[j] = x) {
      ;
    }

    return o;
  },
  // deep merge obj arguments
  deepMerge: function deepMerge() {
    for (var i = 1; i < arguments.length; i++) {
      for (var key in arguments[i]) {
        if (arguments[i].hasOwnProperty(key)) {
          if (_typeof(arguments[0][key]) === 'object' && _typeof(arguments[i][key]) === 'object') {
            this.deepMerge(arguments[0][key], arguments[i][key]);
          } else {
            arguments[0][key] = arguments[i][key];
          }
        }
      }
    }

    return arguments[0];
  },
  // search objects in a list by key and search text
  search: function search(list, key, text, fullword, fullcase) {
    text = String(text || '').replace(/[^\w\s\|]+/g, '');

    if (text.length > 1) {
      var search = fullword ? '\\b' + text.replace(/[\|]+/g, '\\b|\\b') + '\\b' : text;
      var options = fullcase ? 'g' : 'gi';
      var regex = new RegExp(search, options);
      var count = list.length;
      var output = [];

      while (count--) {
        if (String(list[count][key] || '').search(regex) < 0) continue;
        output.push(list[count]);
      }

      return output;
    }

    return list;
  },
  // sort objects in an array by a key
  sort: function sort(list, key, order, ignore) {
    return list.sort(function (a, b) {
      if (a.hasOwnProperty(key)) {
        var _a = a[key];
        var _b = b[key];

        if (ignore) {
          // sort strings using same case
          _a = typeof _a === 'string' ? _a.toUpperCase() : _a;
          _b = typeof _b === 'string' ? _b.toUpperCase() : _b;
        }

        if (order === 'asc') {
          if (_a < _b) return -1;
          if (_a > _b) return 1;
        }

        if (order === 'desc') {
          if (_a > _b) return -1;
          if (_a < _b) return 1;
        }
      }

      return 0;
    });
  },
  // remove items from the start of a list
  trimLeft: function trimLeft(list, max) {
    return list.length > max ? list.slice(list.length - max) : list;
  },
  // remove items from the end of a list
  trimRight: function trimRight(list, max) {
    return list.length > max ? list.slice(0, max) : list;
  },
  // create unique hash from a string
  unique: function unique(str) {
    str = String(str || '').replace(/[\r\n\t\s]+/g, ' ').trim();
    var hash = 5381,
        i = str.length;

    while (--i) {
      hash = hash * 33 ^ str.charCodeAt(i);
    }

    return 'unq_' + (hash >>> 0);
  },
  // random string for a given length
  randString: function randString(length) {
    var chars = 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789';
    var total = parseInt(length) || 10;
    var output = '';

    while (total) {
      output += chars.charAt(Math.floor(Math.random() * chars.length));
      total--;
    }

    return output;
  },
  // get a unique ID string that uses the current timestamp and a random value
  idString: function idString() {
    return (Date.now().toString(36) + Math.random().toString(36).substr(2, 5)).toUpperCase();
  }
};

/***/ }),

/***/ "./src/market/modules/viewport.js":
/*!****************************************!*\
  !*** ./src/market/modules/viewport.js ***!
  \****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/**
 * Viewport Object.
 * Helper for working with viewport data.
 */
var _w = window || {};

var _s = window.screen || {};

var _d = document.documentElement || {};

var _b = document.body || {};

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  screenWidth: function screenWidth() {
    return Math.max(0, _s.width || _s.availWidth || 0);
  },
  screenHeight: function screenHeight() {
    return Math.max(0, _s.height || _s.availHeight || 0);
  },
  clientWidth: function clientWidth() {
    return Math.max(0, _w.innerWidth || _d.clientWidth || _b.clientWidth || 0);
  },
  clientHeight: function clientHeight() {
    return Math.max(0, _w.innerHeight || _d.clientHeight || _b.clientHeight || 0);
  },
  pageWidth: function pageWidth() {
    return Math.max(0, _b.scrollWidth || 0, _b.offsetWidth || 0, _d.clientWidth || 0, _d.offsetWidth || 0, _d.scrollWidth || 0);
  },
  pageHeight: function pageHeight() {
    return Math.max(0, _b.scrollHeight || 0, _b.offsetHeight || 0, _d.clientHeight || 0, _d.offsetHeight || 0, _d.scrollHeight || 0);
  },
  pageLeft: function pageLeft() {
    return Math.max(0, _d.clientLeft || _b.clientLeft || 0);
  },
  pageTop: function pageTop() {
    return Math.max(0, _d.clientTop || _b.clientTop || 0);
  },
  scrollLeft: function scrollLeft() {
    return Math.max(0, _w.pageXOffset || _d.scrollLeft || _b.scrollLeft || 0) - this.pageLeft();
  },
  scrollTop: function scrollTop() {
    return Math.max(0, _w.pageYOffset || _d.scrollTop || _b.scrollTop || 0) - this.pageTop();
  },
  scrollRight: function scrollRight() {
    // max right
    return Math.max(0, Math.floor(this.pageWidth() - this.clientWidth()));
  },
  scrollBottom: function scrollBottom() {
    // max bottom
    return Math.max(0, Math.floor(this.pageHeight() - this.clientHeight()));
  },
  mouseLeft: function mouseLeft(e) {
    var t = e && e.changedTouches ? e.changedTouches[0] : {};
    return e ? Math.max(0, t.pageX || e.pageX || e.clientX || 0) : 0;
  },
  mouseTop: function mouseTop(e) {
    var t = e && e.changedTouches ? e.changedTouches[0] : {};
    return e ? Math.max(0, t.pageY || e.pageY || e.clientY || 0) : 0;
  },
  centerX: function centerX(e) {
    // pointer axis from center
    return this.mouseLeft(e) - this.clientWidth() / 2;
  },
  centerY: function centerY(e) {
    // pointer axis from center
    return this.mouseTop(e) - this.clientHeight() / 2;
  },
  elementWidth: function elementWidth(e) {
    // border-box
    return e ? Math.max(0, e.offsetWidth || 0) : 0;
  },
  elementHeight: function elementHeight(e) {
    // border-box
    return e ? Math.max(0, e.offsetHeight || 0) : 0;
  },
  elementLeft: function elementLeft(e) {
    // from window
    return e ? e.getBoundingClientRect().left : 0;
  },
  elementTop: function elementTop(e) {
    // from window
    return e ? e.getBoundingClientRect().top : 0;
  },
  clampValue: function clampValue(value, min, max) {
    return Math.max(min, Math.min(value, max));
  }
});

/***/ }),

/***/ "./node_modules/raw-loader/dist/cjs.js!./resources/assets/cors.txt":
/*!*************************************************************************!*\
  !*** ./node_modules/raw-loader/dist/cjs.js!./resources/assets/cors.txt ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ("https://fast-reaches-54358.herokuapp.com/");

/***/ }),

/***/ "./node_modules/vue/dist/vue.esm.js":
/*!******************************************!*\
  !*** ./node_modules/vue/dist/vue.esm.js ***!
  \******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/*!
 * Vue.js v2.6.14
 * (c) 2014-2021 Evan You
 * Released under the MIT License.
 */
/*  */

var emptyObject = Object.freeze({});

// These helpers produce better VM code in JS engines due to their
// explicitness and function inlining.
function isUndef (v) {
  return v === undefined || v === null
}

function isDef (v) {
  return v !== undefined && v !== null
}

function isTrue (v) {
  return v === true
}

function isFalse (v) {
  return v === false
}

/**
 * Check if value is primitive.
 */
function isPrimitive (value) {
  return (
    typeof value === 'string' ||
    typeof value === 'number' ||
    // $flow-disable-line
    typeof value === 'symbol' ||
    typeof value === 'boolean'
  )
}

/**
 * Quick object check - this is primarily used to tell
 * Objects from primitive values when we know the value
 * is a JSON-compliant type.
 */
function isObject (obj) {
  return obj !== null && typeof obj === 'object'
}

/**
 * Get the raw type string of a value, e.g., [object Object].
 */
var _toString = Object.prototype.toString;

function toRawType (value) {
  return _toString.call(value).slice(8, -1)
}

/**
 * Strict object type check. Only returns true
 * for plain JavaScript objects.
 */
function isPlainObject (obj) {
  return _toString.call(obj) === '[object Object]'
}

function isRegExp (v) {
  return _toString.call(v) === '[object RegExp]'
}

/**
 * Check if val is a valid array index.
 */
function isValidArrayIndex (val) {
  var n = parseFloat(String(val));
  return n >= 0 && Math.floor(n) === n && isFinite(val)
}

function isPromise (val) {
  return (
    isDef(val) &&
    typeof val.then === 'function' &&
    typeof val.catch === 'function'
  )
}

/**
 * Convert a value to a string that is actually rendered.
 */
function toString (val) {
  return val == null
    ? ''
    : Array.isArray(val) || (isPlainObject(val) && val.toString === _toString)
      ? JSON.stringify(val, null, 2)
      : String(val)
}

/**
 * Convert an input value to a number for persistence.
 * If the conversion fails, return original string.
 */
function toNumber (val) {
  var n = parseFloat(val);
  return isNaN(n) ? val : n
}

/**
 * Make a map and return a function for checking if a key
 * is in that map.
 */
function makeMap (
  str,
  expectsLowerCase
) {
  var map = Object.create(null);
  var list = str.split(',');
  for (var i = 0; i < list.length; i++) {
    map[list[i]] = true;
  }
  return expectsLowerCase
    ? function (val) { return map[val.toLowerCase()]; }
    : function (val) { return map[val]; }
}

/**
 * Check if a tag is a built-in tag.
 */
var isBuiltInTag = makeMap('slot,component', true);

/**
 * Check if an attribute is a reserved attribute.
 */
var isReservedAttribute = makeMap('key,ref,slot,slot-scope,is');

/**
 * Remove an item from an array.
 */
function remove (arr, item) {
  if (arr.length) {
    var index = arr.indexOf(item);
    if (index > -1) {
      return arr.splice(index, 1)
    }
  }
}

/**
 * Check whether an object has the property.
 */
var hasOwnProperty = Object.prototype.hasOwnProperty;
function hasOwn (obj, key) {
  return hasOwnProperty.call(obj, key)
}

/**
 * Create a cached version of a pure function.
 */
function cached (fn) {
  var cache = Object.create(null);
  return (function cachedFn (str) {
    var hit = cache[str];
    return hit || (cache[str] = fn(str))
  })
}

/**
 * Camelize a hyphen-delimited string.
 */
var camelizeRE = /-(\w)/g;
var camelize = cached(function (str) {
  return str.replace(camelizeRE, function (_, c) { return c ? c.toUpperCase() : ''; })
});

/**
 * Capitalize a string.
 */
var capitalize = cached(function (str) {
  return str.charAt(0).toUpperCase() + str.slice(1)
});

/**
 * Hyphenate a camelCase string.
 */
var hyphenateRE = /\B([A-Z])/g;
var hyphenate = cached(function (str) {
  return str.replace(hyphenateRE, '-$1').toLowerCase()
});

/**
 * Simple bind polyfill for environments that do not support it,
 * e.g., PhantomJS 1.x. Technically, we don't need this anymore
 * since native bind is now performant enough in most browsers.
 * But removing it would mean breaking code that was able to run in
 * PhantomJS 1.x, so this must be kept for backward compatibility.
 */

/* istanbul ignore next */
function polyfillBind (fn, ctx) {
  function boundFn (a) {
    var l = arguments.length;
    return l
      ? l > 1
        ? fn.apply(ctx, arguments)
        : fn.call(ctx, a)
      : fn.call(ctx)
  }

  boundFn._length = fn.length;
  return boundFn
}

function nativeBind (fn, ctx) {
  return fn.bind(ctx)
}

var bind = Function.prototype.bind
  ? nativeBind
  : polyfillBind;

/**
 * Convert an Array-like object to a real Array.
 */
function toArray (list, start) {
  start = start || 0;
  var i = list.length - start;
  var ret = new Array(i);
  while (i--) {
    ret[i] = list[i + start];
  }
  return ret
}

/**
 * Mix properties into target object.
 */
function extend (to, _from) {
  for (var key in _from) {
    to[key] = _from[key];
  }
  return to
}

/**
 * Merge an Array of Objects into a single Object.
 */
function toObject (arr) {
  var res = {};
  for (var i = 0; i < arr.length; i++) {
    if (arr[i]) {
      extend(res, arr[i]);
    }
  }
  return res
}

/* eslint-disable no-unused-vars */

/**
 * Perform no operation.
 * Stubbing args to make Flow happy without leaving useless transpiled code
 * with ...rest (https://flow.org/blog/2017/05/07/Strict-Function-Call-Arity/).
 */
function noop (a, b, c) {}

/**
 * Always return false.
 */
var no = function (a, b, c) { return false; };

/* eslint-enable no-unused-vars */

/**
 * Return the same value.
 */
var identity = function (_) { return _; };

/**
 * Generate a string containing static keys from compiler modules.
 */
function genStaticKeys (modules) {
  return modules.reduce(function (keys, m) {
    return keys.concat(m.staticKeys || [])
  }, []).join(',')
}

/**
 * Check if two values are loosely equal - that is,
 * if they are plain objects, do they have the same shape?
 */
function looseEqual (a, b) {
  if (a === b) { return true }
  var isObjectA = isObject(a);
  var isObjectB = isObject(b);
  if (isObjectA && isObjectB) {
    try {
      var isArrayA = Array.isArray(a);
      var isArrayB = Array.isArray(b);
      if (isArrayA && isArrayB) {
        return a.length === b.length && a.every(function (e, i) {
          return looseEqual(e, b[i])
        })
      } else if (a instanceof Date && b instanceof Date) {
        return a.getTime() === b.getTime()
      } else if (!isArrayA && !isArrayB) {
        var keysA = Object.keys(a);
        var keysB = Object.keys(b);
        return keysA.length === keysB.length && keysA.every(function (key) {
          return looseEqual(a[key], b[key])
        })
      } else {
        /* istanbul ignore next */
        return false
      }
    } catch (e) {
      /* istanbul ignore next */
      return false
    }
  } else if (!isObjectA && !isObjectB) {
    return String(a) === String(b)
  } else {
    return false
  }
}

/**
 * Return the first index at which a loosely equal value can be
 * found in the array (if value is a plain object, the array must
 * contain an object of the same shape), or -1 if it is not present.
 */
function looseIndexOf (arr, val) {
  for (var i = 0; i < arr.length; i++) {
    if (looseEqual(arr[i], val)) { return i }
  }
  return -1
}

/**
 * Ensure a function is called only once.
 */
function once (fn) {
  var called = false;
  return function () {
    if (!called) {
      called = true;
      fn.apply(this, arguments);
    }
  }
}

var SSR_ATTR = 'data-server-rendered';

var ASSET_TYPES = [
  'component',
  'directive',
  'filter'
];

var LIFECYCLE_HOOKS = [
  'beforeCreate',
  'created',
  'beforeMount',
  'mounted',
  'beforeUpdate',
  'updated',
  'beforeDestroy',
  'destroyed',
  'activated',
  'deactivated',
  'errorCaptured',
  'serverPrefetch'
];

/*  */



var config = ({
  /**
   * Option merge strategies (used in core/util/options)
   */
  // $flow-disable-line
  optionMergeStrategies: Object.create(null),

  /**
   * Whether to suppress warnings.
   */
  silent: false,

  /**
   * Show production mode tip message on boot?
   */
  productionTip: "development" !== 'production',

  /**
   * Whether to enable devtools
   */
  devtools: "development" !== 'production',

  /**
   * Whether to record perf
   */
  performance: false,

  /**
   * Error handler for watcher errors
   */
  errorHandler: null,

  /**
   * Warn handler for watcher warns
   */
  warnHandler: null,

  /**
   * Ignore certain custom elements
   */
  ignoredElements: [],

  /**
   * Custom user key aliases for v-on
   */
  // $flow-disable-line
  keyCodes: Object.create(null),

  /**
   * Check if a tag is reserved so that it cannot be registered as a
   * component. This is platform-dependent and may be overwritten.
   */
  isReservedTag: no,

  /**
   * Check if an attribute is reserved so that it cannot be used as a component
   * prop. This is platform-dependent and may be overwritten.
   */
  isReservedAttr: no,

  /**
   * Check if a tag is an unknown element.
   * Platform-dependent.
   */
  isUnknownElement: no,

  /**
   * Get the namespace of an element
   */
  getTagNamespace: noop,

  /**
   * Parse the real tag name for the specific platform.
   */
  parsePlatformTagName: identity,

  /**
   * Check if an attribute must be bound using property, e.g. value
   * Platform-dependent.
   */
  mustUseProp: no,

  /**
   * Perform updates asynchronously. Intended to be used by Vue Test Utils
   * This will significantly reduce performance if set to false.
   */
  async: true,

  /**
   * Exposed for legacy reasons
   */
  _lifecycleHooks: LIFECYCLE_HOOKS
});

/*  */

/**
 * unicode letters used for parsing html tags, component names and property paths.
 * using https://www.w3.org/TR/html53/semantics-scripting.html#potentialcustomelementname
 * skipping \u10000-\uEFFFF due to it freezing up PhantomJS
 */
var unicodeRegExp = /a-zA-Z\u00B7\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u037D\u037F-\u1FFF\u200C-\u200D\u203F-\u2040\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD/;

/**
 * Check if a string starts with $ or _
 */
function isReserved (str) {
  var c = (str + '').charCodeAt(0);
  return c === 0x24 || c === 0x5F
}

/**
 * Define a property.
 */
function def (obj, key, val, enumerable) {
  Object.defineProperty(obj, key, {
    value: val,
    enumerable: !!enumerable,
    writable: true,
    configurable: true
  });
}

/**
 * Parse simple path.
 */
var bailRE = new RegExp(("[^" + (unicodeRegExp.source) + ".$_\\d]"));
function parsePath (path) {
  if (bailRE.test(path)) {
    return
  }
  var segments = path.split('.');
  return function (obj) {
    for (var i = 0; i < segments.length; i++) {
      if (!obj) { return }
      obj = obj[segments[i]];
    }
    return obj
  }
}

/*  */

// can we use __proto__?
var hasProto = '__proto__' in {};

// Browser environment sniffing
var inBrowser = typeof window !== 'undefined';
var inWeex = typeof WXEnvironment !== 'undefined' && !!WXEnvironment.platform;
var weexPlatform = inWeex && WXEnvironment.platform.toLowerCase();
var UA = inBrowser && window.navigator.userAgent.toLowerCase();
var isIE = UA && /msie|trident/.test(UA);
var isIE9 = UA && UA.indexOf('msie 9.0') > 0;
var isEdge = UA && UA.indexOf('edge/') > 0;
var isAndroid = (UA && UA.indexOf('android') > 0) || (weexPlatform === 'android');
var isIOS = (UA && /iphone|ipad|ipod|ios/.test(UA)) || (weexPlatform === 'ios');
var isChrome = UA && /chrome\/\d+/.test(UA) && !isEdge;
var isPhantomJS = UA && /phantomjs/.test(UA);
var isFF = UA && UA.match(/firefox\/(\d+)/);

// Firefox has a "watch" function on Object.prototype...
var nativeWatch = ({}).watch;

var supportsPassive = false;
if (inBrowser) {
  try {
    var opts = {};
    Object.defineProperty(opts, 'passive', ({
      get: function get () {
        /* istanbul ignore next */
        supportsPassive = true;
      }
    })); // https://github.com/facebook/flow/issues/285
    window.addEventListener('test-passive', null, opts);
  } catch (e) {}
}

// this needs to be lazy-evaled because vue may be required before
// vue-server-renderer can set VUE_ENV
var _isServer;
var isServerRendering = function () {
  if (_isServer === undefined) {
    /* istanbul ignore if */
    if (!inBrowser && !inWeex && typeof __webpack_require__.g !== 'undefined') {
      // detect presence of vue-server-renderer and avoid
      // Webpack shimming the process
      _isServer = __webpack_require__.g['process'] && __webpack_require__.g['process'].env.VUE_ENV === 'server';
    } else {
      _isServer = false;
    }
  }
  return _isServer
};

// detect devtools
var devtools = inBrowser && window.__VUE_DEVTOOLS_GLOBAL_HOOK__;

/* istanbul ignore next */
function isNative (Ctor) {
  return typeof Ctor === 'function' && /native code/.test(Ctor.toString())
}

var hasSymbol =
  typeof Symbol !== 'undefined' && isNative(Symbol) &&
  typeof Reflect !== 'undefined' && isNative(Reflect.ownKeys);

var _Set;
/* istanbul ignore if */ // $flow-disable-line
if (typeof Set !== 'undefined' && isNative(Set)) {
  // use native Set when available.
  _Set = Set;
} else {
  // a non-standard Set polyfill that only works with primitive keys.
  _Set = /*@__PURE__*/(function () {
    function Set () {
      this.set = Object.create(null);
    }
    Set.prototype.has = function has (key) {
      return this.set[key] === true
    };
    Set.prototype.add = function add (key) {
      this.set[key] = true;
    };
    Set.prototype.clear = function clear () {
      this.set = Object.create(null);
    };

    return Set;
  }());
}

/*  */

var warn = noop;
var tip = noop;
var generateComponentTrace = (noop); // work around flow check
var formatComponentName = (noop);

if (true) {
  var hasConsole = typeof console !== 'undefined';
  var classifyRE = /(?:^|[-_])(\w)/g;
  var classify = function (str) { return str
    .replace(classifyRE, function (c) { return c.toUpperCase(); })
    .replace(/[-_]/g, ''); };

  warn = function (msg, vm) {
    var trace = vm ? generateComponentTrace(vm) : '';

    if (config.warnHandler) {
      config.warnHandler.call(null, msg, vm, trace);
    } else if (hasConsole && (!config.silent)) {
      console.error(("[Vue warn]: " + msg + trace));
    }
  };

  tip = function (msg, vm) {
    if (hasConsole && (!config.silent)) {
      console.warn("[Vue tip]: " + msg + (
        vm ? generateComponentTrace(vm) : ''
      ));
    }
  };

  formatComponentName = function (vm, includeFile) {
    if (vm.$root === vm) {
      return '<Root>'
    }
    var options = typeof vm === 'function' && vm.cid != null
      ? vm.options
      : vm._isVue
        ? vm.$options || vm.constructor.options
        : vm;
    var name = options.name || options._componentTag;
    var file = options.__file;
    if (!name && file) {
      var match = file.match(/([^/\\]+)\.vue$/);
      name = match && match[1];
    }

    return (
      (name ? ("<" + (classify(name)) + ">") : "<Anonymous>") +
      (file && includeFile !== false ? (" at " + file) : '')
    )
  };

  var repeat = function (str, n) {
    var res = '';
    while (n) {
      if (n % 2 === 1) { res += str; }
      if (n > 1) { str += str; }
      n >>= 1;
    }
    return res
  };

  generateComponentTrace = function (vm) {
    if (vm._isVue && vm.$parent) {
      var tree = [];
      var currentRecursiveSequence = 0;
      while (vm) {
        if (tree.length > 0) {
          var last = tree[tree.length - 1];
          if (last.constructor === vm.constructor) {
            currentRecursiveSequence++;
            vm = vm.$parent;
            continue
          } else if (currentRecursiveSequence > 0) {
            tree[tree.length - 1] = [last, currentRecursiveSequence];
            currentRecursiveSequence = 0;
          }
        }
        tree.push(vm);
        vm = vm.$parent;
      }
      return '\n\nfound in\n\n' + tree
        .map(function (vm, i) { return ("" + (i === 0 ? '---> ' : repeat(' ', 5 + i * 2)) + (Array.isArray(vm)
            ? ((formatComponentName(vm[0])) + "... (" + (vm[1]) + " recursive calls)")
            : formatComponentName(vm))); })
        .join('\n')
    } else {
      return ("\n\n(found in " + (formatComponentName(vm)) + ")")
    }
  };
}

/*  */

var uid = 0;

/**
 * A dep is an observable that can have multiple
 * directives subscribing to it.
 */
var Dep = function Dep () {
  this.id = uid++;
  this.subs = [];
};

Dep.prototype.addSub = function addSub (sub) {
  this.subs.push(sub);
};

Dep.prototype.removeSub = function removeSub (sub) {
  remove(this.subs, sub);
};

Dep.prototype.depend = function depend () {
  if (Dep.target) {
    Dep.target.addDep(this);
  }
};

Dep.prototype.notify = function notify () {
  // stabilize the subscriber list first
  var subs = this.subs.slice();
  if ( true && !config.async) {
    // subs aren't sorted in scheduler if not running async
    // we need to sort them now to make sure they fire in correct
    // order
    subs.sort(function (a, b) { return a.id - b.id; });
  }
  for (var i = 0, l = subs.length; i < l; i++) {
    subs[i].update();
  }
};

// The current target watcher being evaluated.
// This is globally unique because only one watcher
// can be evaluated at a time.
Dep.target = null;
var targetStack = [];

function pushTarget (target) {
  targetStack.push(target);
  Dep.target = target;
}

function popTarget () {
  targetStack.pop();
  Dep.target = targetStack[targetStack.length - 1];
}

/*  */

var VNode = function VNode (
  tag,
  data,
  children,
  text,
  elm,
  context,
  componentOptions,
  asyncFactory
) {
  this.tag = tag;
  this.data = data;
  this.children = children;
  this.text = text;
  this.elm = elm;
  this.ns = undefined;
  this.context = context;
  this.fnContext = undefined;
  this.fnOptions = undefined;
  this.fnScopeId = undefined;
  this.key = data && data.key;
  this.componentOptions = componentOptions;
  this.componentInstance = undefined;
  this.parent = undefined;
  this.raw = false;
  this.isStatic = false;
  this.isRootInsert = true;
  this.isComment = false;
  this.isCloned = false;
  this.isOnce = false;
  this.asyncFactory = asyncFactory;
  this.asyncMeta = undefined;
  this.isAsyncPlaceholder = false;
};

var prototypeAccessors = { child: { configurable: true } };

// DEPRECATED: alias for componentInstance for backwards compat.
/* istanbul ignore next */
prototypeAccessors.child.get = function () {
  return this.componentInstance
};

Object.defineProperties( VNode.prototype, prototypeAccessors );

var createEmptyVNode = function (text) {
  if ( text === void 0 ) text = '';

  var node = new VNode();
  node.text = text;
  node.isComment = true;
  return node
};

function createTextVNode (val) {
  return new VNode(undefined, undefined, undefined, String(val))
}

// optimized shallow clone
// used for static nodes and slot nodes because they may be reused across
// multiple renders, cloning them avoids errors when DOM manipulations rely
// on their elm reference.
function cloneVNode (vnode) {
  var cloned = new VNode(
    vnode.tag,
    vnode.data,
    // #7975
    // clone children array to avoid mutating original in case of cloning
    // a child.
    vnode.children && vnode.children.slice(),
    vnode.text,
    vnode.elm,
    vnode.context,
    vnode.componentOptions,
    vnode.asyncFactory
  );
  cloned.ns = vnode.ns;
  cloned.isStatic = vnode.isStatic;
  cloned.key = vnode.key;
  cloned.isComment = vnode.isComment;
  cloned.fnContext = vnode.fnContext;
  cloned.fnOptions = vnode.fnOptions;
  cloned.fnScopeId = vnode.fnScopeId;
  cloned.asyncMeta = vnode.asyncMeta;
  cloned.isCloned = true;
  return cloned
}

/*
 * not type checking this file because flow doesn't play well with
 * dynamically accessing methods on Array prototype
 */

var arrayProto = Array.prototype;
var arrayMethods = Object.create(arrayProto);

var methodsToPatch = [
  'push',
  'pop',
  'shift',
  'unshift',
  'splice',
  'sort',
  'reverse'
];

/**
 * Intercept mutating methods and emit events
 */
methodsToPatch.forEach(function (method) {
  // cache original method
  var original = arrayProto[method];
  def(arrayMethods, method, function mutator () {
    var args = [], len = arguments.length;
    while ( len-- ) args[ len ] = arguments[ len ];

    var result = original.apply(this, args);
    var ob = this.__ob__;
    var inserted;
    switch (method) {
      case 'push':
      case 'unshift':
        inserted = args;
        break
      case 'splice':
        inserted = args.slice(2);
        break
    }
    if (inserted) { ob.observeArray(inserted); }
    // notify change
    ob.dep.notify();
    return result
  });
});

/*  */

var arrayKeys = Object.getOwnPropertyNames(arrayMethods);

/**
 * In some cases we may want to disable observation inside a component's
 * update computation.
 */
var shouldObserve = true;

function toggleObserving (value) {
  shouldObserve = value;
}

/**
 * Observer class that is attached to each observed
 * object. Once attached, the observer converts the target
 * object's property keys into getter/setters that
 * collect dependencies and dispatch updates.
 */
var Observer = function Observer (value) {
  this.value = value;
  this.dep = new Dep();
  this.vmCount = 0;
  def(value, '__ob__', this);
  if (Array.isArray(value)) {
    if (hasProto) {
      protoAugment(value, arrayMethods);
    } else {
      copyAugment(value, arrayMethods, arrayKeys);
    }
    this.observeArray(value);
  } else {
    this.walk(value);
  }
};

/**
 * Walk through all properties and convert them into
 * getter/setters. This method should only be called when
 * value type is Object.
 */
Observer.prototype.walk = function walk (obj) {
  var keys = Object.keys(obj);
  for (var i = 0; i < keys.length; i++) {
    defineReactive$$1(obj, keys[i]);
  }
};

/**
 * Observe a list of Array items.
 */
Observer.prototype.observeArray = function observeArray (items) {
  for (var i = 0, l = items.length; i < l; i++) {
    observe(items[i]);
  }
};

// helpers

/**
 * Augment a target Object or Array by intercepting
 * the prototype chain using __proto__
 */
function protoAugment (target, src) {
  /* eslint-disable no-proto */
  target.__proto__ = src;
  /* eslint-enable no-proto */
}

/**
 * Augment a target Object or Array by defining
 * hidden properties.
 */
/* istanbul ignore next */
function copyAugment (target, src, keys) {
  for (var i = 0, l = keys.length; i < l; i++) {
    var key = keys[i];
    def(target, key, src[key]);
  }
}

/**
 * Attempt to create an observer instance for a value,
 * returns the new observer if successfully observed,
 * or the existing observer if the value already has one.
 */
function observe (value, asRootData) {
  if (!isObject(value) || value instanceof VNode) {
    return
  }
  var ob;
  if (hasOwn(value, '__ob__') && value.__ob__ instanceof Observer) {
    ob = value.__ob__;
  } else if (
    shouldObserve &&
    !isServerRendering() &&
    (Array.isArray(value) || isPlainObject(value)) &&
    Object.isExtensible(value) &&
    !value._isVue
  ) {
    ob = new Observer(value);
  }
  if (asRootData && ob) {
    ob.vmCount++;
  }
  return ob
}

/**
 * Define a reactive property on an Object.
 */
function defineReactive$$1 (
  obj,
  key,
  val,
  customSetter,
  shallow
) {
  var dep = new Dep();

  var property = Object.getOwnPropertyDescriptor(obj, key);
  if (property && property.configurable === false) {
    return
  }

  // cater for pre-defined getter/setters
  var getter = property && property.get;
  var setter = property && property.set;
  if ((!getter || setter) && arguments.length === 2) {
    val = obj[key];
  }

  var childOb = !shallow && observe(val);
  Object.defineProperty(obj, key, {
    enumerable: true,
    configurable: true,
    get: function reactiveGetter () {
      var value = getter ? getter.call(obj) : val;
      if (Dep.target) {
        dep.depend();
        if (childOb) {
          childOb.dep.depend();
          if (Array.isArray(value)) {
            dependArray(value);
          }
        }
      }
      return value
    },
    set: function reactiveSetter (newVal) {
      var value = getter ? getter.call(obj) : val;
      /* eslint-disable no-self-compare */
      if (newVal === value || (newVal !== newVal && value !== value)) {
        return
      }
      /* eslint-enable no-self-compare */
      if ( true && customSetter) {
        customSetter();
      }
      // #7981: for accessor properties without setter
      if (getter && !setter) { return }
      if (setter) {
        setter.call(obj, newVal);
      } else {
        val = newVal;
      }
      childOb = !shallow && observe(newVal);
      dep.notify();
    }
  });
}

/**
 * Set a property on an object. Adds the new property and
 * triggers change notification if the property doesn't
 * already exist.
 */
function set (target, key, val) {
  if ( true &&
    (isUndef(target) || isPrimitive(target))
  ) {
    warn(("Cannot set reactive property on undefined, null, or primitive value: " + ((target))));
  }
  if (Array.isArray(target) && isValidArrayIndex(key)) {
    target.length = Math.max(target.length, key);
    target.splice(key, 1, val);
    return val
  }
  if (key in target && !(key in Object.prototype)) {
    target[key] = val;
    return val
  }
  var ob = (target).__ob__;
  if (target._isVue || (ob && ob.vmCount)) {
     true && warn(
      'Avoid adding reactive properties to a Vue instance or its root $data ' +
      'at runtime - declare it upfront in the data option.'
    );
    return val
  }
  if (!ob) {
    target[key] = val;
    return val
  }
  defineReactive$$1(ob.value, key, val);
  ob.dep.notify();
  return val
}

/**
 * Delete a property and trigger change if necessary.
 */
function del (target, key) {
  if ( true &&
    (isUndef(target) || isPrimitive(target))
  ) {
    warn(("Cannot delete reactive property on undefined, null, or primitive value: " + ((target))));
  }
  if (Array.isArray(target) && isValidArrayIndex(key)) {
    target.splice(key, 1);
    return
  }
  var ob = (target).__ob__;
  if (target._isVue || (ob && ob.vmCount)) {
     true && warn(
      'Avoid deleting properties on a Vue instance or its root $data ' +
      '- just set it to null.'
    );
    return
  }
  if (!hasOwn(target, key)) {
    return
  }
  delete target[key];
  if (!ob) {
    return
  }
  ob.dep.notify();
}

/**
 * Collect dependencies on array elements when the array is touched, since
 * we cannot intercept array element access like property getters.
 */
function dependArray (value) {
  for (var e = (void 0), i = 0, l = value.length; i < l; i++) {
    e = value[i];
    e && e.__ob__ && e.__ob__.dep.depend();
    if (Array.isArray(e)) {
      dependArray(e);
    }
  }
}

/*  */

/**
 * Option overwriting strategies are functions that handle
 * how to merge a parent option value and a child option
 * value into the final value.
 */
var strats = config.optionMergeStrategies;

/**
 * Options with restrictions
 */
if (true) {
  strats.el = strats.propsData = function (parent, child, vm, key) {
    if (!vm) {
      warn(
        "option \"" + key + "\" can only be used during instance " +
        'creation with the `new` keyword.'
      );
    }
    return defaultStrat(parent, child)
  };
}

/**
 * Helper that recursively merges two data objects together.
 */
function mergeData (to, from) {
  if (!from) { return to }
  var key, toVal, fromVal;

  var keys = hasSymbol
    ? Reflect.ownKeys(from)
    : Object.keys(from);

  for (var i = 0; i < keys.length; i++) {
    key = keys[i];
    // in case the object is already observed...
    if (key === '__ob__') { continue }
    toVal = to[key];
    fromVal = from[key];
    if (!hasOwn(to, key)) {
      set(to, key, fromVal);
    } else if (
      toVal !== fromVal &&
      isPlainObject(toVal) &&
      isPlainObject(fromVal)
    ) {
      mergeData(toVal, fromVal);
    }
  }
  return to
}

/**
 * Data
 */
function mergeDataOrFn (
  parentVal,
  childVal,
  vm
) {
  if (!vm) {
    // in a Vue.extend merge, both should be functions
    if (!childVal) {
      return parentVal
    }
    if (!parentVal) {
      return childVal
    }
    // when parentVal & childVal are both present,
    // we need to return a function that returns the
    // merged result of both functions... no need to
    // check if parentVal is a function here because
    // it has to be a function to pass previous merges.
    return function mergedDataFn () {
      return mergeData(
        typeof childVal === 'function' ? childVal.call(this, this) : childVal,
        typeof parentVal === 'function' ? parentVal.call(this, this) : parentVal
      )
    }
  } else {
    return function mergedInstanceDataFn () {
      // instance merge
      var instanceData = typeof childVal === 'function'
        ? childVal.call(vm, vm)
        : childVal;
      var defaultData = typeof parentVal === 'function'
        ? parentVal.call(vm, vm)
        : parentVal;
      if (instanceData) {
        return mergeData(instanceData, defaultData)
      } else {
        return defaultData
      }
    }
  }
}

strats.data = function (
  parentVal,
  childVal,
  vm
) {
  if (!vm) {
    if (childVal && typeof childVal !== 'function') {
       true && warn(
        'The "data" option should be a function ' +
        'that returns a per-instance value in component ' +
        'definitions.',
        vm
      );

      return parentVal
    }
    return mergeDataOrFn(parentVal, childVal)
  }

  return mergeDataOrFn(parentVal, childVal, vm)
};

/**
 * Hooks and props are merged as arrays.
 */
function mergeHook (
  parentVal,
  childVal
) {
  var res = childVal
    ? parentVal
      ? parentVal.concat(childVal)
      : Array.isArray(childVal)
        ? childVal
        : [childVal]
    : parentVal;
  return res
    ? dedupeHooks(res)
    : res
}

function dedupeHooks (hooks) {
  var res = [];
  for (var i = 0; i < hooks.length; i++) {
    if (res.indexOf(hooks[i]) === -1) {
      res.push(hooks[i]);
    }
  }
  return res
}

LIFECYCLE_HOOKS.forEach(function (hook) {
  strats[hook] = mergeHook;
});

/**
 * Assets
 *
 * When a vm is present (instance creation), we need to do
 * a three-way merge between constructor options, instance
 * options and parent options.
 */
function mergeAssets (
  parentVal,
  childVal,
  vm,
  key
) {
  var res = Object.create(parentVal || null);
  if (childVal) {
     true && assertObjectType(key, childVal, vm);
    return extend(res, childVal)
  } else {
    return res
  }
}

ASSET_TYPES.forEach(function (type) {
  strats[type + 's'] = mergeAssets;
});

/**
 * Watchers.
 *
 * Watchers hashes should not overwrite one
 * another, so we merge them as arrays.
 */
strats.watch = function (
  parentVal,
  childVal,
  vm,
  key
) {
  // work around Firefox's Object.prototype.watch...
  if (parentVal === nativeWatch) { parentVal = undefined; }
  if (childVal === nativeWatch) { childVal = undefined; }
  /* istanbul ignore if */
  if (!childVal) { return Object.create(parentVal || null) }
  if (true) {
    assertObjectType(key, childVal, vm);
  }
  if (!parentVal) { return childVal }
  var ret = {};
  extend(ret, parentVal);
  for (var key$1 in childVal) {
    var parent = ret[key$1];
    var child = childVal[key$1];
    if (parent && !Array.isArray(parent)) {
      parent = [parent];
    }
    ret[key$1] = parent
      ? parent.concat(child)
      : Array.isArray(child) ? child : [child];
  }
  return ret
};

/**
 * Other object hashes.
 */
strats.props =
strats.methods =
strats.inject =
strats.computed = function (
  parentVal,
  childVal,
  vm,
  key
) {
  if (childVal && "development" !== 'production') {
    assertObjectType(key, childVal, vm);
  }
  if (!parentVal) { return childVal }
  var ret = Object.create(null);
  extend(ret, parentVal);
  if (childVal) { extend(ret, childVal); }
  return ret
};
strats.provide = mergeDataOrFn;

/**
 * Default strategy.
 */
var defaultStrat = function (parentVal, childVal) {
  return childVal === undefined
    ? parentVal
    : childVal
};

/**
 * Validate component names
 */
function checkComponents (options) {
  for (var key in options.components) {
    validateComponentName(key);
  }
}

function validateComponentName (name) {
  if (!new RegExp(("^[a-zA-Z][\\-\\.0-9_" + (unicodeRegExp.source) + "]*$")).test(name)) {
    warn(
      'Invalid component name: "' + name + '". Component names ' +
      'should conform to valid custom element name in html5 specification.'
    );
  }
  if (isBuiltInTag(name) || config.isReservedTag(name)) {
    warn(
      'Do not use built-in or reserved HTML elements as component ' +
      'id: ' + name
    );
  }
}

/**
 * Ensure all props option syntax are normalized into the
 * Object-based format.
 */
function normalizeProps (options, vm) {
  var props = options.props;
  if (!props) { return }
  var res = {};
  var i, val, name;
  if (Array.isArray(props)) {
    i = props.length;
    while (i--) {
      val = props[i];
      if (typeof val === 'string') {
        name = camelize(val);
        res[name] = { type: null };
      } else if (true) {
        warn('props must be strings when using array syntax.');
      }
    }
  } else if (isPlainObject(props)) {
    for (var key in props) {
      val = props[key];
      name = camelize(key);
      res[name] = isPlainObject(val)
        ? val
        : { type: val };
    }
  } else if (true) {
    warn(
      "Invalid value for option \"props\": expected an Array or an Object, " +
      "but got " + (toRawType(props)) + ".",
      vm
    );
  }
  options.props = res;
}

/**
 * Normalize all injections into Object-based format
 */
function normalizeInject (options, vm) {
  var inject = options.inject;
  if (!inject) { return }
  var normalized = options.inject = {};
  if (Array.isArray(inject)) {
    for (var i = 0; i < inject.length; i++) {
      normalized[inject[i]] = { from: inject[i] };
    }
  } else if (isPlainObject(inject)) {
    for (var key in inject) {
      var val = inject[key];
      normalized[key] = isPlainObject(val)
        ? extend({ from: key }, val)
        : { from: val };
    }
  } else if (true) {
    warn(
      "Invalid value for option \"inject\": expected an Array or an Object, " +
      "but got " + (toRawType(inject)) + ".",
      vm
    );
  }
}

/**
 * Normalize raw function directives into object format.
 */
function normalizeDirectives (options) {
  var dirs = options.directives;
  if (dirs) {
    for (var key in dirs) {
      var def$$1 = dirs[key];
      if (typeof def$$1 === 'function') {
        dirs[key] = { bind: def$$1, update: def$$1 };
      }
    }
  }
}

function assertObjectType (name, value, vm) {
  if (!isPlainObject(value)) {
    warn(
      "Invalid value for option \"" + name + "\": expected an Object, " +
      "but got " + (toRawType(value)) + ".",
      vm
    );
  }
}

/**
 * Merge two option objects into a new one.
 * Core utility used in both instantiation and inheritance.
 */
function mergeOptions (
  parent,
  child,
  vm
) {
  if (true) {
    checkComponents(child);
  }

  if (typeof child === 'function') {
    child = child.options;
  }

  normalizeProps(child, vm);
  normalizeInject(child, vm);
  normalizeDirectives(child);

  // Apply extends and mixins on the child options,
  // but only if it is a raw options object that isn't
  // the result of another mergeOptions call.
  // Only merged options has the _base property.
  if (!child._base) {
    if (child.extends) {
      parent = mergeOptions(parent, child.extends, vm);
    }
    if (child.mixins) {
      for (var i = 0, l = child.mixins.length; i < l; i++) {
        parent = mergeOptions(parent, child.mixins[i], vm);
      }
    }
  }

  var options = {};
  var key;
  for (key in parent) {
    mergeField(key);
  }
  for (key in child) {
    if (!hasOwn(parent, key)) {
      mergeField(key);
    }
  }
  function mergeField (key) {
    var strat = strats[key] || defaultStrat;
    options[key] = strat(parent[key], child[key], vm, key);
  }
  return options
}

/**
 * Resolve an asset.
 * This function is used because child instances need access
 * to assets defined in its ancestor chain.
 */
function resolveAsset (
  options,
  type,
  id,
  warnMissing
) {
  /* istanbul ignore if */
  if (typeof id !== 'string') {
    return
  }
  var assets = options[type];
  // check local registration variations first
  if (hasOwn(assets, id)) { return assets[id] }
  var camelizedId = camelize(id);
  if (hasOwn(assets, camelizedId)) { return assets[camelizedId] }
  var PascalCaseId = capitalize(camelizedId);
  if (hasOwn(assets, PascalCaseId)) { return assets[PascalCaseId] }
  // fallback to prototype chain
  var res = assets[id] || assets[camelizedId] || assets[PascalCaseId];
  if ( true && warnMissing && !res) {
    warn(
      'Failed to resolve ' + type.slice(0, -1) + ': ' + id,
      options
    );
  }
  return res
}

/*  */



function validateProp (
  key,
  propOptions,
  propsData,
  vm
) {
  var prop = propOptions[key];
  var absent = !hasOwn(propsData, key);
  var value = propsData[key];
  // boolean casting
  var booleanIndex = getTypeIndex(Boolean, prop.type);
  if (booleanIndex > -1) {
    if (absent && !hasOwn(prop, 'default')) {
      value = false;
    } else if (value === '' || value === hyphenate(key)) {
      // only cast empty string / same name to boolean if
      // boolean has higher priority
      var stringIndex = getTypeIndex(String, prop.type);
      if (stringIndex < 0 || booleanIndex < stringIndex) {
        value = true;
      }
    }
  }
  // check default value
  if (value === undefined) {
    value = getPropDefaultValue(vm, prop, key);
    // since the default value is a fresh copy,
    // make sure to observe it.
    var prevShouldObserve = shouldObserve;
    toggleObserving(true);
    observe(value);
    toggleObserving(prevShouldObserve);
  }
  if (
    true
  ) {
    assertProp(prop, key, value, vm, absent);
  }
  return value
}

/**
 * Get the default value of a prop.
 */
function getPropDefaultValue (vm, prop, key) {
  // no default, return undefined
  if (!hasOwn(prop, 'default')) {
    return undefined
  }
  var def = prop.default;
  // warn against non-factory defaults for Object & Array
  if ( true && isObject(def)) {
    warn(
      'Invalid default value for prop "' + key + '": ' +
      'Props with type Object/Array must use a factory function ' +
      'to return the default value.',
      vm
    );
  }
  // the raw prop value was also undefined from previous render,
  // return previous default value to avoid unnecessary watcher trigger
  if (vm && vm.$options.propsData &&
    vm.$options.propsData[key] === undefined &&
    vm._props[key] !== undefined
  ) {
    return vm._props[key]
  }
  // call factory function for non-Function types
  // a value is Function if its prototype is function even across different execution context
  return typeof def === 'function' && getType(prop.type) !== 'Function'
    ? def.call(vm)
    : def
}

/**
 * Assert whether a prop is valid.
 */
function assertProp (
  prop,
  name,
  value,
  vm,
  absent
) {
  if (prop.required && absent) {
    warn(
      'Missing required prop: "' + name + '"',
      vm
    );
    return
  }
  if (value == null && !prop.required) {
    return
  }
  var type = prop.type;
  var valid = !type || type === true;
  var expectedTypes = [];
  if (type) {
    if (!Array.isArray(type)) {
      type = [type];
    }
    for (var i = 0; i < type.length && !valid; i++) {
      var assertedType = assertType(value, type[i], vm);
      expectedTypes.push(assertedType.expectedType || '');
      valid = assertedType.valid;
    }
  }

  var haveExpectedTypes = expectedTypes.some(function (t) { return t; });
  if (!valid && haveExpectedTypes) {
    warn(
      getInvalidTypeMessage(name, value, expectedTypes),
      vm
    );
    return
  }
  var validator = prop.validator;
  if (validator) {
    if (!validator(value)) {
      warn(
        'Invalid prop: custom validator check failed for prop "' + name + '".',
        vm
      );
    }
  }
}

var simpleCheckRE = /^(String|Number|Boolean|Function|Symbol|BigInt)$/;

function assertType (value, type, vm) {
  var valid;
  var expectedType = getType(type);
  if (simpleCheckRE.test(expectedType)) {
    var t = typeof value;
    valid = t === expectedType.toLowerCase();
    // for primitive wrapper objects
    if (!valid && t === 'object') {
      valid = value instanceof type;
    }
  } else if (expectedType === 'Object') {
    valid = isPlainObject(value);
  } else if (expectedType === 'Array') {
    valid = Array.isArray(value);
  } else {
    try {
      valid = value instanceof type;
    } catch (e) {
      warn('Invalid prop type: "' + String(type) + '" is not a constructor', vm);
      valid = false;
    }
  }
  return {
    valid: valid,
    expectedType: expectedType
  }
}

var functionTypeCheckRE = /^\s*function (\w+)/;

/**
 * Use function string name to check built-in types,
 * because a simple equality check will fail when running
 * across different vms / iframes.
 */
function getType (fn) {
  var match = fn && fn.toString().match(functionTypeCheckRE);
  return match ? match[1] : ''
}

function isSameType (a, b) {
  return getType(a) === getType(b)
}

function getTypeIndex (type, expectedTypes) {
  if (!Array.isArray(expectedTypes)) {
    return isSameType(expectedTypes, type) ? 0 : -1
  }
  for (var i = 0, len = expectedTypes.length; i < len; i++) {
    if (isSameType(expectedTypes[i], type)) {
      return i
    }
  }
  return -1
}

function getInvalidTypeMessage (name, value, expectedTypes) {
  var message = "Invalid prop: type check failed for prop \"" + name + "\"." +
    " Expected " + (expectedTypes.map(capitalize).join(', '));
  var expectedType = expectedTypes[0];
  var receivedType = toRawType(value);
  // check if we need to specify expected value
  if (
    expectedTypes.length === 1 &&
    isExplicable(expectedType) &&
    isExplicable(typeof value) &&
    !isBoolean(expectedType, receivedType)
  ) {
    message += " with value " + (styleValue(value, expectedType));
  }
  message += ", got " + receivedType + " ";
  // check if we need to specify received value
  if (isExplicable(receivedType)) {
    message += "with value " + (styleValue(value, receivedType)) + ".";
  }
  return message
}

function styleValue (value, type) {
  if (type === 'String') {
    return ("\"" + value + "\"")
  } else if (type === 'Number') {
    return ("" + (Number(value)))
  } else {
    return ("" + value)
  }
}

var EXPLICABLE_TYPES = ['string', 'number', 'boolean'];
function isExplicable (value) {
  return EXPLICABLE_TYPES.some(function (elem) { return value.toLowerCase() === elem; })
}

function isBoolean () {
  var args = [], len = arguments.length;
  while ( len-- ) args[ len ] = arguments[ len ];

  return args.some(function (elem) { return elem.toLowerCase() === 'boolean'; })
}

/*  */

function handleError (err, vm, info) {
  // Deactivate deps tracking while processing error handler to avoid possible infinite rendering.
  // See: https://github.com/vuejs/vuex/issues/1505
  pushTarget();
  try {
    if (vm) {
      var cur = vm;
      while ((cur = cur.$parent)) {
        var hooks = cur.$options.errorCaptured;
        if (hooks) {
          for (var i = 0; i < hooks.length; i++) {
            try {
              var capture = hooks[i].call(cur, err, vm, info) === false;
              if (capture) { return }
            } catch (e) {
              globalHandleError(e, cur, 'errorCaptured hook');
            }
          }
        }
      }
    }
    globalHandleError(err, vm, info);
  } finally {
    popTarget();
  }
}

function invokeWithErrorHandling (
  handler,
  context,
  args,
  vm,
  info
) {
  var res;
  try {
    res = args ? handler.apply(context, args) : handler.call(context);
    if (res && !res._isVue && isPromise(res) && !res._handled) {
      res.catch(function (e) { return handleError(e, vm, info + " (Promise/async)"); });
      // issue #9511
      // avoid catch triggering multiple times when nested calls
      res._handled = true;
    }
  } catch (e) {
    handleError(e, vm, info);
  }
  return res
}

function globalHandleError (err, vm, info) {
  if (config.errorHandler) {
    try {
      return config.errorHandler.call(null, err, vm, info)
    } catch (e) {
      // if the user intentionally throws the original error in the handler,
      // do not log it twice
      if (e !== err) {
        logError(e, null, 'config.errorHandler');
      }
    }
  }
  logError(err, vm, info);
}

function logError (err, vm, info) {
  if (true) {
    warn(("Error in " + info + ": \"" + (err.toString()) + "\""), vm);
  }
  /* istanbul ignore else */
  if ((inBrowser || inWeex) && typeof console !== 'undefined') {
    console.error(err);
  } else {
    throw err
  }
}

/*  */

var isUsingMicroTask = false;

var callbacks = [];
var pending = false;

function flushCallbacks () {
  pending = false;
  var copies = callbacks.slice(0);
  callbacks.length = 0;
  for (var i = 0; i < copies.length; i++) {
    copies[i]();
  }
}

// Here we have async deferring wrappers using microtasks.
// In 2.5 we used (macro) tasks (in combination with microtasks).
// However, it has subtle problems when state is changed right before repaint
// (e.g. #6813, out-in transitions).
// Also, using (macro) tasks in event handler would cause some weird behaviors
// that cannot be circumvented (e.g. #7109, #7153, #7546, #7834, #8109).
// So we now use microtasks everywhere, again.
// A major drawback of this tradeoff is that there are some scenarios
// where microtasks have too high a priority and fire in between supposedly
// sequential events (e.g. #4521, #6690, which have workarounds)
// or even between bubbling of the same event (#6566).
var timerFunc;

// The nextTick behavior leverages the microtask queue, which can be accessed
// via either native Promise.then or MutationObserver.
// MutationObserver has wider support, however it is seriously bugged in
// UIWebView in iOS >= 9.3.3 when triggered in touch event handlers. It
// completely stops working after triggering a few times... so, if native
// Promise is available, we will use it:
/* istanbul ignore next, $flow-disable-line */
if (typeof Promise !== 'undefined' && isNative(Promise)) {
  var p = Promise.resolve();
  timerFunc = function () {
    p.then(flushCallbacks);
    // In problematic UIWebViews, Promise.then doesn't completely break, but
    // it can get stuck in a weird state where callbacks are pushed into the
    // microtask queue but the queue isn't being flushed, until the browser
    // needs to do some other work, e.g. handle a timer. Therefore we can
    // "force" the microtask queue to be flushed by adding an empty timer.
    if (isIOS) { setTimeout(noop); }
  };
  isUsingMicroTask = true;
} else if (!isIE && typeof MutationObserver !== 'undefined' && (
  isNative(MutationObserver) ||
  // PhantomJS and iOS 7.x
  MutationObserver.toString() === '[object MutationObserverConstructor]'
)) {
  // Use MutationObserver where native Promise is not available,
  // e.g. PhantomJS, iOS7, Android 4.4
  // (#6466 MutationObserver is unreliable in IE11)
  var counter = 1;
  var observer = new MutationObserver(flushCallbacks);
  var textNode = document.createTextNode(String(counter));
  observer.observe(textNode, {
    characterData: true
  });
  timerFunc = function () {
    counter = (counter + 1) % 2;
    textNode.data = String(counter);
  };
  isUsingMicroTask = true;
} else if (typeof setImmediate !== 'undefined' && isNative(setImmediate)) {
  // Fallback to setImmediate.
  // Technically it leverages the (macro) task queue,
  // but it is still a better choice than setTimeout.
  timerFunc = function () {
    setImmediate(flushCallbacks);
  };
} else {
  // Fallback to setTimeout.
  timerFunc = function () {
    setTimeout(flushCallbacks, 0);
  };
}

function nextTick (cb, ctx) {
  var _resolve;
  callbacks.push(function () {
    if (cb) {
      try {
        cb.call(ctx);
      } catch (e) {
        handleError(e, ctx, 'nextTick');
      }
    } else if (_resolve) {
      _resolve(ctx);
    }
  });
  if (!pending) {
    pending = true;
    timerFunc();
  }
  // $flow-disable-line
  if (!cb && typeof Promise !== 'undefined') {
    return new Promise(function (resolve) {
      _resolve = resolve;
    })
  }
}

/*  */

var mark;
var measure;

if (true) {
  var perf = inBrowser && window.performance;
  /* istanbul ignore if */
  if (
    perf &&
    perf.mark &&
    perf.measure &&
    perf.clearMarks &&
    perf.clearMeasures
  ) {
    mark = function (tag) { return perf.mark(tag); };
    measure = function (name, startTag, endTag) {
      perf.measure(name, startTag, endTag);
      perf.clearMarks(startTag);
      perf.clearMarks(endTag);
      // perf.clearMeasures(name)
    };
  }
}

/* not type checking this file because flow doesn't play well with Proxy */

var initProxy;

if (true) {
  var allowedGlobals = makeMap(
    'Infinity,undefined,NaN,isFinite,isNaN,' +
    'parseFloat,parseInt,decodeURI,decodeURIComponent,encodeURI,encodeURIComponent,' +
    'Math,Number,Date,Array,Object,Boolean,String,RegExp,Map,Set,JSON,Intl,BigInt,' +
    'require' // for Webpack/Browserify
  );

  var warnNonPresent = function (target, key) {
    warn(
      "Property or method \"" + key + "\" is not defined on the instance but " +
      'referenced during render. Make sure that this property is reactive, ' +
      'either in the data option, or for class-based components, by ' +
      'initializing the property. ' +
      'See: https://vuejs.org/v2/guide/reactivity.html#Declaring-Reactive-Properties.',
      target
    );
  };

  var warnReservedPrefix = function (target, key) {
    warn(
      "Property \"" + key + "\" must be accessed with \"$data." + key + "\" because " +
      'properties starting with "$" or "_" are not proxied in the Vue instance to ' +
      'prevent conflicts with Vue internals. ' +
      'See: https://vuejs.org/v2/api/#data',
      target
    );
  };

  var hasProxy =
    typeof Proxy !== 'undefined' && isNative(Proxy);

  if (hasProxy) {
    var isBuiltInModifier = makeMap('stop,prevent,self,ctrl,shift,alt,meta,exact');
    config.keyCodes = new Proxy(config.keyCodes, {
      set: function set (target, key, value) {
        if (isBuiltInModifier(key)) {
          warn(("Avoid overwriting built-in modifier in config.keyCodes: ." + key));
          return false
        } else {
          target[key] = value;
          return true
        }
      }
    });
  }

  var hasHandler = {
    has: function has (target, key) {
      var has = key in target;
      var isAllowed = allowedGlobals(key) ||
        (typeof key === 'string' && key.charAt(0) === '_' && !(key in target.$data));
      if (!has && !isAllowed) {
        if (key in target.$data) { warnReservedPrefix(target, key); }
        else { warnNonPresent(target, key); }
      }
      return has || !isAllowed
    }
  };

  var getHandler = {
    get: function get (target, key) {
      if (typeof key === 'string' && !(key in target)) {
        if (key in target.$data) { warnReservedPrefix(target, key); }
        else { warnNonPresent(target, key); }
      }
      return target[key]
    }
  };

  initProxy = function initProxy (vm) {
    if (hasProxy) {
      // determine which proxy handler to use
      var options = vm.$options;
      var handlers = options.render && options.render._withStripped
        ? getHandler
        : hasHandler;
      vm._renderProxy = new Proxy(vm, handlers);
    } else {
      vm._renderProxy = vm;
    }
  };
}

/*  */

var seenObjects = new _Set();

/**
 * Recursively traverse an object to evoke all converted
 * getters, so that every nested property inside the object
 * is collected as a "deep" dependency.
 */
function traverse (val) {
  _traverse(val, seenObjects);
  seenObjects.clear();
}

function _traverse (val, seen) {
  var i, keys;
  var isA = Array.isArray(val);
  if ((!isA && !isObject(val)) || Object.isFrozen(val) || val instanceof VNode) {
    return
  }
  if (val.__ob__) {
    var depId = val.__ob__.dep.id;
    if (seen.has(depId)) {
      return
    }
    seen.add(depId);
  }
  if (isA) {
    i = val.length;
    while (i--) { _traverse(val[i], seen); }
  } else {
    keys = Object.keys(val);
    i = keys.length;
    while (i--) { _traverse(val[keys[i]], seen); }
  }
}

/*  */

var normalizeEvent = cached(function (name) {
  var passive = name.charAt(0) === '&';
  name = passive ? name.slice(1) : name;
  var once$$1 = name.charAt(0) === '~'; // Prefixed last, checked first
  name = once$$1 ? name.slice(1) : name;
  var capture = name.charAt(0) === '!';
  name = capture ? name.slice(1) : name;
  return {
    name: name,
    once: once$$1,
    capture: capture,
    passive: passive
  }
});

function createFnInvoker (fns, vm) {
  function invoker () {
    var arguments$1 = arguments;

    var fns = invoker.fns;
    if (Array.isArray(fns)) {
      var cloned = fns.slice();
      for (var i = 0; i < cloned.length; i++) {
        invokeWithErrorHandling(cloned[i], null, arguments$1, vm, "v-on handler");
      }
    } else {
      // return handler return value for single handlers
      return invokeWithErrorHandling(fns, null, arguments, vm, "v-on handler")
    }
  }
  invoker.fns = fns;
  return invoker
}

function updateListeners (
  on,
  oldOn,
  add,
  remove$$1,
  createOnceHandler,
  vm
) {
  var name, def$$1, cur, old, event;
  for (name in on) {
    def$$1 = cur = on[name];
    old = oldOn[name];
    event = normalizeEvent(name);
    if (isUndef(cur)) {
       true && warn(
        "Invalid handler for event \"" + (event.name) + "\": got " + String(cur),
        vm
      );
    } else if (isUndef(old)) {
      if (isUndef(cur.fns)) {
        cur = on[name] = createFnInvoker(cur, vm);
      }
      if (isTrue(event.once)) {
        cur = on[name] = createOnceHandler(event.name, cur, event.capture);
      }
      add(event.name, cur, event.capture, event.passive, event.params);
    } else if (cur !== old) {
      old.fns = cur;
      on[name] = old;
    }
  }
  for (name in oldOn) {
    if (isUndef(on[name])) {
      event = normalizeEvent(name);
      remove$$1(event.name, oldOn[name], event.capture);
    }
  }
}

/*  */

function mergeVNodeHook (def, hookKey, hook) {
  if (def instanceof VNode) {
    def = def.data.hook || (def.data.hook = {});
  }
  var invoker;
  var oldHook = def[hookKey];

  function wrappedHook () {
    hook.apply(this, arguments);
    // important: remove merged hook to ensure it's called only once
    // and prevent memory leak
    remove(invoker.fns, wrappedHook);
  }

  if (isUndef(oldHook)) {
    // no existing hook
    invoker = createFnInvoker([wrappedHook]);
  } else {
    /* istanbul ignore if */
    if (isDef(oldHook.fns) && isTrue(oldHook.merged)) {
      // already a merged invoker
      invoker = oldHook;
      invoker.fns.push(wrappedHook);
    } else {
      // existing plain hook
      invoker = createFnInvoker([oldHook, wrappedHook]);
    }
  }

  invoker.merged = true;
  def[hookKey] = invoker;
}

/*  */

function extractPropsFromVNodeData (
  data,
  Ctor,
  tag
) {
  // we are only extracting raw values here.
  // validation and default values are handled in the child
  // component itself.
  var propOptions = Ctor.options.props;
  if (isUndef(propOptions)) {
    return
  }
  var res = {};
  var attrs = data.attrs;
  var props = data.props;
  if (isDef(attrs) || isDef(props)) {
    for (var key in propOptions) {
      var altKey = hyphenate(key);
      if (true) {
        var keyInLowerCase = key.toLowerCase();
        if (
          key !== keyInLowerCase &&
          attrs && hasOwn(attrs, keyInLowerCase)
        ) {
          tip(
            "Prop \"" + keyInLowerCase + "\" is passed to component " +
            (formatComponentName(tag || Ctor)) + ", but the declared prop name is" +
            " \"" + key + "\". " +
            "Note that HTML attributes are case-insensitive and camelCased " +
            "props need to use their kebab-case equivalents when using in-DOM " +
            "templates. You should probably use \"" + altKey + "\" instead of \"" + key + "\"."
          );
        }
      }
      checkProp(res, props, key, altKey, true) ||
      checkProp(res, attrs, key, altKey, false);
    }
  }
  return res
}

function checkProp (
  res,
  hash,
  key,
  altKey,
  preserve
) {
  if (isDef(hash)) {
    if (hasOwn(hash, key)) {
      res[key] = hash[key];
      if (!preserve) {
        delete hash[key];
      }
      return true
    } else if (hasOwn(hash, altKey)) {
      res[key] = hash[altKey];
      if (!preserve) {
        delete hash[altKey];
      }
      return true
    }
  }
  return false
}

/*  */

// The template compiler attempts to minimize the need for normalization by
// statically analyzing the template at compile time.
//
// For plain HTML markup, normalization can be completely skipped because the
// generated render function is guaranteed to return Array<VNode>. There are
// two cases where extra normalization is needed:

// 1. When the children contains components - because a functional component
// may return an Array instead of a single root. In this case, just a simple
// normalization is needed - if any child is an Array, we flatten the whole
// thing with Array.prototype.concat. It is guaranteed to be only 1-level deep
// because functional components already normalize their own children.
function simpleNormalizeChildren (children) {
  for (var i = 0; i < children.length; i++) {
    if (Array.isArray(children[i])) {
      return Array.prototype.concat.apply([], children)
    }
  }
  return children
}

// 2. When the children contains constructs that always generated nested Arrays,
// e.g. <template>, <slot>, v-for, or when the children is provided by user
// with hand-written render functions / JSX. In such cases a full normalization
// is needed to cater to all possible types of children values.
function normalizeChildren (children) {
  return isPrimitive(children)
    ? [createTextVNode(children)]
    : Array.isArray(children)
      ? normalizeArrayChildren(children)
      : undefined
}

function isTextNode (node) {
  return isDef(node) && isDef(node.text) && isFalse(node.isComment)
}

function normalizeArrayChildren (children, nestedIndex) {
  var res = [];
  var i, c, lastIndex, last;
  for (i = 0; i < children.length; i++) {
    c = children[i];
    if (isUndef(c) || typeof c === 'boolean') { continue }
    lastIndex = res.length - 1;
    last = res[lastIndex];
    //  nested
    if (Array.isArray(c)) {
      if (c.length > 0) {
        c = normalizeArrayChildren(c, ((nestedIndex || '') + "_" + i));
        // merge adjacent text nodes
        if (isTextNode(c[0]) && isTextNode(last)) {
          res[lastIndex] = createTextVNode(last.text + (c[0]).text);
          c.shift();
        }
        res.push.apply(res, c);
      }
    } else if (isPrimitive(c)) {
      if (isTextNode(last)) {
        // merge adjacent text nodes
        // this is necessary for SSR hydration because text nodes are
        // essentially merged when rendered to HTML strings
        res[lastIndex] = createTextVNode(last.text + c);
      } else if (c !== '') {
        // convert primitive to vnode
        res.push(createTextVNode(c));
      }
    } else {
      if (isTextNode(c) && isTextNode(last)) {
        // merge adjacent text nodes
        res[lastIndex] = createTextVNode(last.text + c.text);
      } else {
        // default key for nested array children (likely generated by v-for)
        if (isTrue(children._isVList) &&
          isDef(c.tag) &&
          isUndef(c.key) &&
          isDef(nestedIndex)) {
          c.key = "__vlist" + nestedIndex + "_" + i + "__";
        }
        res.push(c);
      }
    }
  }
  return res
}

/*  */

function initProvide (vm) {
  var provide = vm.$options.provide;
  if (provide) {
    vm._provided = typeof provide === 'function'
      ? provide.call(vm)
      : provide;
  }
}

function initInjections (vm) {
  var result = resolveInject(vm.$options.inject, vm);
  if (result) {
    toggleObserving(false);
    Object.keys(result).forEach(function (key) {
      /* istanbul ignore else */
      if (true) {
        defineReactive$$1(vm, key, result[key], function () {
          warn(
            "Avoid mutating an injected value directly since the changes will be " +
            "overwritten whenever the provided component re-renders. " +
            "injection being mutated: \"" + key + "\"",
            vm
          );
        });
      } else {}
    });
    toggleObserving(true);
  }
}

function resolveInject (inject, vm) {
  if (inject) {
    // inject is :any because flow is not smart enough to figure out cached
    var result = Object.create(null);
    var keys = hasSymbol
      ? Reflect.ownKeys(inject)
      : Object.keys(inject);

    for (var i = 0; i < keys.length; i++) {
      var key = keys[i];
      // #6574 in case the inject object is observed...
      if (key === '__ob__') { continue }
      var provideKey = inject[key].from;
      var source = vm;
      while (source) {
        if (source._provided && hasOwn(source._provided, provideKey)) {
          result[key] = source._provided[provideKey];
          break
        }
        source = source.$parent;
      }
      if (!source) {
        if ('default' in inject[key]) {
          var provideDefault = inject[key].default;
          result[key] = typeof provideDefault === 'function'
            ? provideDefault.call(vm)
            : provideDefault;
        } else if (true) {
          warn(("Injection \"" + key + "\" not found"), vm);
        }
      }
    }
    return result
  }
}

/*  */



/**
 * Runtime helper for resolving raw children VNodes into a slot object.
 */
function resolveSlots (
  children,
  context
) {
  if (!children || !children.length) {
    return {}
  }
  var slots = {};
  for (var i = 0, l = children.length; i < l; i++) {
    var child = children[i];
    var data = child.data;
    // remove slot attribute if the node is resolved as a Vue slot node
    if (data && data.attrs && data.attrs.slot) {
      delete data.attrs.slot;
    }
    // named slots should only be respected if the vnode was rendered in the
    // same context.
    if ((child.context === context || child.fnContext === context) &&
      data && data.slot != null
    ) {
      var name = data.slot;
      var slot = (slots[name] || (slots[name] = []));
      if (child.tag === 'template') {
        slot.push.apply(slot, child.children || []);
      } else {
        slot.push(child);
      }
    } else {
      (slots.default || (slots.default = [])).push(child);
    }
  }
  // ignore slots that contains only whitespace
  for (var name$1 in slots) {
    if (slots[name$1].every(isWhitespace)) {
      delete slots[name$1];
    }
  }
  return slots
}

function isWhitespace (node) {
  return (node.isComment && !node.asyncFactory) || node.text === ' '
}

/*  */

function isAsyncPlaceholder (node) {
  return node.isComment && node.asyncFactory
}

/*  */

function normalizeScopedSlots (
  slots,
  normalSlots,
  prevSlots
) {
  var res;
  var hasNormalSlots = Object.keys(normalSlots).length > 0;
  var isStable = slots ? !!slots.$stable : !hasNormalSlots;
  var key = slots && slots.$key;
  if (!slots) {
    res = {};
  } else if (slots._normalized) {
    // fast path 1: child component re-render only, parent did not change
    return slots._normalized
  } else if (
    isStable &&
    prevSlots &&
    prevSlots !== emptyObject &&
    key === prevSlots.$key &&
    !hasNormalSlots &&
    !prevSlots.$hasNormal
  ) {
    // fast path 2: stable scoped slots w/ no normal slots to proxy,
    // only need to normalize once
    return prevSlots
  } else {
    res = {};
    for (var key$1 in slots) {
      if (slots[key$1] && key$1[0] !== '$') {
        res[key$1] = normalizeScopedSlot(normalSlots, key$1, slots[key$1]);
      }
    }
  }
  // expose normal slots on scopedSlots
  for (var key$2 in normalSlots) {
    if (!(key$2 in res)) {
      res[key$2] = proxyNormalSlot(normalSlots, key$2);
    }
  }
  // avoriaz seems to mock a non-extensible $scopedSlots object
  // and when that is passed down this would cause an error
  if (slots && Object.isExtensible(slots)) {
    (slots)._normalized = res;
  }
  def(res, '$stable', isStable);
  def(res, '$key', key);
  def(res, '$hasNormal', hasNormalSlots);
  return res
}

function normalizeScopedSlot(normalSlots, key, fn) {
  var normalized = function () {
    var res = arguments.length ? fn.apply(null, arguments) : fn({});
    res = res && typeof res === 'object' && !Array.isArray(res)
      ? [res] // single vnode
      : normalizeChildren(res);
    var vnode = res && res[0];
    return res && (
      !vnode ||
      (res.length === 1 && vnode.isComment && !isAsyncPlaceholder(vnode)) // #9658, #10391
    ) ? undefined
      : res
  };
  // this is a slot using the new v-slot syntax without scope. although it is
  // compiled as a scoped slot, render fn users would expect it to be present
  // on this.$slots because the usage is semantically a normal slot.
  if (fn.proxy) {
    Object.defineProperty(normalSlots, key, {
      get: normalized,
      enumerable: true,
      configurable: true
    });
  }
  return normalized
}

function proxyNormalSlot(slots, key) {
  return function () { return slots[key]; }
}

/*  */

/**
 * Runtime helper for rendering v-for lists.
 */
function renderList (
  val,
  render
) {
  var ret, i, l, keys, key;
  if (Array.isArray(val) || typeof val === 'string') {
    ret = new Array(val.length);
    for (i = 0, l = val.length; i < l; i++) {
      ret[i] = render(val[i], i);
    }
  } else if (typeof val === 'number') {
    ret = new Array(val);
    for (i = 0; i < val; i++) {
      ret[i] = render(i + 1, i);
    }
  } else if (isObject(val)) {
    if (hasSymbol && val[Symbol.iterator]) {
      ret = [];
      var iterator = val[Symbol.iterator]();
      var result = iterator.next();
      while (!result.done) {
        ret.push(render(result.value, ret.length));
        result = iterator.next();
      }
    } else {
      keys = Object.keys(val);
      ret = new Array(keys.length);
      for (i = 0, l = keys.length; i < l; i++) {
        key = keys[i];
        ret[i] = render(val[key], key, i);
      }
    }
  }
  if (!isDef(ret)) {
    ret = [];
  }
  (ret)._isVList = true;
  return ret
}

/*  */

/**
 * Runtime helper for rendering <slot>
 */
function renderSlot (
  name,
  fallbackRender,
  props,
  bindObject
) {
  var scopedSlotFn = this.$scopedSlots[name];
  var nodes;
  if (scopedSlotFn) {
    // scoped slot
    props = props || {};
    if (bindObject) {
      if ( true && !isObject(bindObject)) {
        warn('slot v-bind without argument expects an Object', this);
      }
      props = extend(extend({}, bindObject), props);
    }
    nodes =
      scopedSlotFn(props) ||
      (typeof fallbackRender === 'function' ? fallbackRender() : fallbackRender);
  } else {
    nodes =
      this.$slots[name] ||
      (typeof fallbackRender === 'function' ? fallbackRender() : fallbackRender);
  }

  var target = props && props.slot;
  if (target) {
    return this.$createElement('template', { slot: target }, nodes)
  } else {
    return nodes
  }
}

/*  */

/**
 * Runtime helper for resolving filters
 */
function resolveFilter (id) {
  return resolveAsset(this.$options, 'filters', id, true) || identity
}

/*  */

function isKeyNotMatch (expect, actual) {
  if (Array.isArray(expect)) {
    return expect.indexOf(actual) === -1
  } else {
    return expect !== actual
  }
}

/**
 * Runtime helper for checking keyCodes from config.
 * exposed as Vue.prototype._k
 * passing in eventKeyName as last argument separately for backwards compat
 */
function checkKeyCodes (
  eventKeyCode,
  key,
  builtInKeyCode,
  eventKeyName,
  builtInKeyName
) {
  var mappedKeyCode = config.keyCodes[key] || builtInKeyCode;
  if (builtInKeyName && eventKeyName && !config.keyCodes[key]) {
    return isKeyNotMatch(builtInKeyName, eventKeyName)
  } else if (mappedKeyCode) {
    return isKeyNotMatch(mappedKeyCode, eventKeyCode)
  } else if (eventKeyName) {
    return hyphenate(eventKeyName) !== key
  }
  return eventKeyCode === undefined
}

/*  */

/**
 * Runtime helper for merging v-bind="object" into a VNode's data.
 */
function bindObjectProps (
  data,
  tag,
  value,
  asProp,
  isSync
) {
  if (value) {
    if (!isObject(value)) {
       true && warn(
        'v-bind without argument expects an Object or Array value',
        this
      );
    } else {
      if (Array.isArray(value)) {
        value = toObject(value);
      }
      var hash;
      var loop = function ( key ) {
        if (
          key === 'class' ||
          key === 'style' ||
          isReservedAttribute(key)
        ) {
          hash = data;
        } else {
          var type = data.attrs && data.attrs.type;
          hash = asProp || config.mustUseProp(tag, type, key)
            ? data.domProps || (data.domProps = {})
            : data.attrs || (data.attrs = {});
        }
        var camelizedKey = camelize(key);
        var hyphenatedKey = hyphenate(key);
        if (!(camelizedKey in hash) && !(hyphenatedKey in hash)) {
          hash[key] = value[key];

          if (isSync) {
            var on = data.on || (data.on = {});
            on[("update:" + key)] = function ($event) {
              value[key] = $event;
            };
          }
        }
      };

      for (var key in value) loop( key );
    }
  }
  return data
}

/*  */

/**
 * Runtime helper for rendering static trees.
 */
function renderStatic (
  index,
  isInFor
) {
  var cached = this._staticTrees || (this._staticTrees = []);
  var tree = cached[index];
  // if has already-rendered static tree and not inside v-for,
  // we can reuse the same tree.
  if (tree && !isInFor) {
    return tree
  }
  // otherwise, render a fresh tree.
  tree = cached[index] = this.$options.staticRenderFns[index].call(
    this._renderProxy,
    null,
    this // for render fns generated for functional component templates
  );
  markStatic(tree, ("__static__" + index), false);
  return tree
}

/**
 * Runtime helper for v-once.
 * Effectively it means marking the node as static with a unique key.
 */
function markOnce (
  tree,
  index,
  key
) {
  markStatic(tree, ("__once__" + index + (key ? ("_" + key) : "")), true);
  return tree
}

function markStatic (
  tree,
  key,
  isOnce
) {
  if (Array.isArray(tree)) {
    for (var i = 0; i < tree.length; i++) {
      if (tree[i] && typeof tree[i] !== 'string') {
        markStaticNode(tree[i], (key + "_" + i), isOnce);
      }
    }
  } else {
    markStaticNode(tree, key, isOnce);
  }
}

function markStaticNode (node, key, isOnce) {
  node.isStatic = true;
  node.key = key;
  node.isOnce = isOnce;
}

/*  */

function bindObjectListeners (data, value) {
  if (value) {
    if (!isPlainObject(value)) {
       true && warn(
        'v-on without argument expects an Object value',
        this
      );
    } else {
      var on = data.on = data.on ? extend({}, data.on) : {};
      for (var key in value) {
        var existing = on[key];
        var ours = value[key];
        on[key] = existing ? [].concat(existing, ours) : ours;
      }
    }
  }
  return data
}

/*  */

function resolveScopedSlots (
  fns, // see flow/vnode
  res,
  // the following are added in 2.6
  hasDynamicKeys,
  contentHashKey
) {
  res = res || { $stable: !hasDynamicKeys };
  for (var i = 0; i < fns.length; i++) {
    var slot = fns[i];
    if (Array.isArray(slot)) {
      resolveScopedSlots(slot, res, hasDynamicKeys);
    } else if (slot) {
      // marker for reverse proxying v-slot without scope on this.$slots
      if (slot.proxy) {
        slot.fn.proxy = true;
      }
      res[slot.key] = slot.fn;
    }
  }
  if (contentHashKey) {
    (res).$key = contentHashKey;
  }
  return res
}

/*  */

function bindDynamicKeys (baseObj, values) {
  for (var i = 0; i < values.length; i += 2) {
    var key = values[i];
    if (typeof key === 'string' && key) {
      baseObj[values[i]] = values[i + 1];
    } else if ( true && key !== '' && key !== null) {
      // null is a special value for explicitly removing a binding
      warn(
        ("Invalid value for dynamic directive argument (expected string or null): " + key),
        this
      );
    }
  }
  return baseObj
}

// helper to dynamically append modifier runtime markers to event names.
// ensure only append when value is already string, otherwise it will be cast
// to string and cause the type check to miss.
function prependModifier (value, symbol) {
  return typeof value === 'string' ? symbol + value : value
}

/*  */

function installRenderHelpers (target) {
  target._o = markOnce;
  target._n = toNumber;
  target._s = toString;
  target._l = renderList;
  target._t = renderSlot;
  target._q = looseEqual;
  target._i = looseIndexOf;
  target._m = renderStatic;
  target._f = resolveFilter;
  target._k = checkKeyCodes;
  target._b = bindObjectProps;
  target._v = createTextVNode;
  target._e = createEmptyVNode;
  target._u = resolveScopedSlots;
  target._g = bindObjectListeners;
  target._d = bindDynamicKeys;
  target._p = prependModifier;
}

/*  */

function FunctionalRenderContext (
  data,
  props,
  children,
  parent,
  Ctor
) {
  var this$1 = this;

  var options = Ctor.options;
  // ensure the createElement function in functional components
  // gets a unique context - this is necessary for correct named slot check
  var contextVm;
  if (hasOwn(parent, '_uid')) {
    contextVm = Object.create(parent);
    // $flow-disable-line
    contextVm._original = parent;
  } else {
    // the context vm passed in is a functional context as well.
    // in this case we want to make sure we are able to get a hold to the
    // real context instance.
    contextVm = parent;
    // $flow-disable-line
    parent = parent._original;
  }
  var isCompiled = isTrue(options._compiled);
  var needNormalization = !isCompiled;

  this.data = data;
  this.props = props;
  this.children = children;
  this.parent = parent;
  this.listeners = data.on || emptyObject;
  this.injections = resolveInject(options.inject, parent);
  this.slots = function () {
    if (!this$1.$slots) {
      normalizeScopedSlots(
        data.scopedSlots,
        this$1.$slots = resolveSlots(children, parent)
      );
    }
    return this$1.$slots
  };

  Object.defineProperty(this, 'scopedSlots', ({
    enumerable: true,
    get: function get () {
      return normalizeScopedSlots(data.scopedSlots, this.slots())
    }
  }));

  // support for compiled functional template
  if (isCompiled) {
    // exposing $options for renderStatic()
    this.$options = options;
    // pre-resolve slots for renderSlot()
    this.$slots = this.slots();
    this.$scopedSlots = normalizeScopedSlots(data.scopedSlots, this.$slots);
  }

  if (options._scopeId) {
    this._c = function (a, b, c, d) {
      var vnode = createElement(contextVm, a, b, c, d, needNormalization);
      if (vnode && !Array.isArray(vnode)) {
        vnode.fnScopeId = options._scopeId;
        vnode.fnContext = parent;
      }
      return vnode
    };
  } else {
    this._c = function (a, b, c, d) { return createElement(contextVm, a, b, c, d, needNormalization); };
  }
}

installRenderHelpers(FunctionalRenderContext.prototype);

function createFunctionalComponent (
  Ctor,
  propsData,
  data,
  contextVm,
  children
) {
  var options = Ctor.options;
  var props = {};
  var propOptions = options.props;
  if (isDef(propOptions)) {
    for (var key in propOptions) {
      props[key] = validateProp(key, propOptions, propsData || emptyObject);
    }
  } else {
    if (isDef(data.attrs)) { mergeProps(props, data.attrs); }
    if (isDef(data.props)) { mergeProps(props, data.props); }
  }

  var renderContext = new FunctionalRenderContext(
    data,
    props,
    children,
    contextVm,
    Ctor
  );

  var vnode = options.render.call(null, renderContext._c, renderContext);

  if (vnode instanceof VNode) {
    return cloneAndMarkFunctionalResult(vnode, data, renderContext.parent, options, renderContext)
  } else if (Array.isArray(vnode)) {
    var vnodes = normalizeChildren(vnode) || [];
    var res = new Array(vnodes.length);
    for (var i = 0; i < vnodes.length; i++) {
      res[i] = cloneAndMarkFunctionalResult(vnodes[i], data, renderContext.parent, options, renderContext);
    }
    return res
  }
}

function cloneAndMarkFunctionalResult (vnode, data, contextVm, options, renderContext) {
  // #7817 clone node before setting fnContext, otherwise if the node is reused
  // (e.g. it was from a cached normal slot) the fnContext causes named slots
  // that should not be matched to match.
  var clone = cloneVNode(vnode);
  clone.fnContext = contextVm;
  clone.fnOptions = options;
  if (true) {
    (clone.devtoolsMeta = clone.devtoolsMeta || {}).renderContext = renderContext;
  }
  if (data.slot) {
    (clone.data || (clone.data = {})).slot = data.slot;
  }
  return clone
}

function mergeProps (to, from) {
  for (var key in from) {
    to[camelize(key)] = from[key];
  }
}

/*  */

/*  */

/*  */

/*  */

// inline hooks to be invoked on component VNodes during patch
var componentVNodeHooks = {
  init: function init (vnode, hydrating) {
    if (
      vnode.componentInstance &&
      !vnode.componentInstance._isDestroyed &&
      vnode.data.keepAlive
    ) {
      // kept-alive components, treat as a patch
      var mountedNode = vnode; // work around flow
      componentVNodeHooks.prepatch(mountedNode, mountedNode);
    } else {
      var child = vnode.componentInstance = createComponentInstanceForVnode(
        vnode,
        activeInstance
      );
      child.$mount(hydrating ? vnode.elm : undefined, hydrating);
    }
  },

  prepatch: function prepatch (oldVnode, vnode) {
    var options = vnode.componentOptions;
    var child = vnode.componentInstance = oldVnode.componentInstance;
    updateChildComponent(
      child,
      options.propsData, // updated props
      options.listeners, // updated listeners
      vnode, // new parent vnode
      options.children // new children
    );
  },

  insert: function insert (vnode) {
    var context = vnode.context;
    var componentInstance = vnode.componentInstance;
    if (!componentInstance._isMounted) {
      componentInstance._isMounted = true;
      callHook(componentInstance, 'mounted');
    }
    if (vnode.data.keepAlive) {
      if (context._isMounted) {
        // vue-router#1212
        // During updates, a kept-alive component's child components may
        // change, so directly walking the tree here may call activated hooks
        // on incorrect children. Instead we push them into a queue which will
        // be processed after the whole patch process ended.
        queueActivatedComponent(componentInstance);
      } else {
        activateChildComponent(componentInstance, true /* direct */);
      }
    }
  },

  destroy: function destroy (vnode) {
    var componentInstance = vnode.componentInstance;
    if (!componentInstance._isDestroyed) {
      if (!vnode.data.keepAlive) {
        componentInstance.$destroy();
      } else {
        deactivateChildComponent(componentInstance, true /* direct */);
      }
    }
  }
};

var hooksToMerge = Object.keys(componentVNodeHooks);

function createComponent (
  Ctor,
  data,
  context,
  children,
  tag
) {
  if (isUndef(Ctor)) {
    return
  }

  var baseCtor = context.$options._base;

  // plain options object: turn it into a constructor
  if (isObject(Ctor)) {
    Ctor = baseCtor.extend(Ctor);
  }

  // if at this stage it's not a constructor or an async component factory,
  // reject.
  if (typeof Ctor !== 'function') {
    if (true) {
      warn(("Invalid Component definition: " + (String(Ctor))), context);
    }
    return
  }

  // async component
  var asyncFactory;
  if (isUndef(Ctor.cid)) {
    asyncFactory = Ctor;
    Ctor = resolveAsyncComponent(asyncFactory, baseCtor);
    if (Ctor === undefined) {
      // return a placeholder node for async component, which is rendered
      // as a comment node but preserves all the raw information for the node.
      // the information will be used for async server-rendering and hydration.
      return createAsyncPlaceholder(
        asyncFactory,
        data,
        context,
        children,
        tag
      )
    }
  }

  data = data || {};

  // resolve constructor options in case global mixins are applied after
  // component constructor creation
  resolveConstructorOptions(Ctor);

  // transform component v-model data into props & events
  if (isDef(data.model)) {
    transformModel(Ctor.options, data);
  }

  // extract props
  var propsData = extractPropsFromVNodeData(data, Ctor, tag);

  // functional component
  if (isTrue(Ctor.options.functional)) {
    return createFunctionalComponent(Ctor, propsData, data, context, children)
  }

  // extract listeners, since these needs to be treated as
  // child component listeners instead of DOM listeners
  var listeners = data.on;
  // replace with listeners with .native modifier
  // so it gets processed during parent component patch.
  data.on = data.nativeOn;

  if (isTrue(Ctor.options.abstract)) {
    // abstract components do not keep anything
    // other than props & listeners & slot

    // work around flow
    var slot = data.slot;
    data = {};
    if (slot) {
      data.slot = slot;
    }
  }

  // install component management hooks onto the placeholder node
  installComponentHooks(data);

  // return a placeholder vnode
  var name = Ctor.options.name || tag;
  var vnode = new VNode(
    ("vue-component-" + (Ctor.cid) + (name ? ("-" + name) : '')),
    data, undefined, undefined, undefined, context,
    { Ctor: Ctor, propsData: propsData, listeners: listeners, tag: tag, children: children },
    asyncFactory
  );

  return vnode
}

function createComponentInstanceForVnode (
  // we know it's MountedComponentVNode but flow doesn't
  vnode,
  // activeInstance in lifecycle state
  parent
) {
  var options = {
    _isComponent: true,
    _parentVnode: vnode,
    parent: parent
  };
  // check inline-template render functions
  var inlineTemplate = vnode.data.inlineTemplate;
  if (isDef(inlineTemplate)) {
    options.render = inlineTemplate.render;
    options.staticRenderFns = inlineTemplate.staticRenderFns;
  }
  return new vnode.componentOptions.Ctor(options)
}

function installComponentHooks (data) {
  var hooks = data.hook || (data.hook = {});
  for (var i = 0; i < hooksToMerge.length; i++) {
    var key = hooksToMerge[i];
    var existing = hooks[key];
    var toMerge = componentVNodeHooks[key];
    if (existing !== toMerge && !(existing && existing._merged)) {
      hooks[key] = existing ? mergeHook$1(toMerge, existing) : toMerge;
    }
  }
}

function mergeHook$1 (f1, f2) {
  var merged = function (a, b) {
    // flow complains about extra args which is why we use any
    f1(a, b);
    f2(a, b);
  };
  merged._merged = true;
  return merged
}

// transform component v-model info (value and callback) into
// prop and event handler respectively.
function transformModel (options, data) {
  var prop = (options.model && options.model.prop) || 'value';
  var event = (options.model && options.model.event) || 'input'
  ;(data.attrs || (data.attrs = {}))[prop] = data.model.value;
  var on = data.on || (data.on = {});
  var existing = on[event];
  var callback = data.model.callback;
  if (isDef(existing)) {
    if (
      Array.isArray(existing)
        ? existing.indexOf(callback) === -1
        : existing !== callback
    ) {
      on[event] = [callback].concat(existing);
    }
  } else {
    on[event] = callback;
  }
}

/*  */

var SIMPLE_NORMALIZE = 1;
var ALWAYS_NORMALIZE = 2;

// wrapper function for providing a more flexible interface
// without getting yelled at by flow
function createElement (
  context,
  tag,
  data,
  children,
  normalizationType,
  alwaysNormalize
) {
  if (Array.isArray(data) || isPrimitive(data)) {
    normalizationType = children;
    children = data;
    data = undefined;
  }
  if (isTrue(alwaysNormalize)) {
    normalizationType = ALWAYS_NORMALIZE;
  }
  return _createElement(context, tag, data, children, normalizationType)
}

function _createElement (
  context,
  tag,
  data,
  children,
  normalizationType
) {
  if (isDef(data) && isDef((data).__ob__)) {
     true && warn(
      "Avoid using observed data object as vnode data: " + (JSON.stringify(data)) + "\n" +
      'Always create fresh vnode data objects in each render!',
      context
    );
    return createEmptyVNode()
  }
  // object syntax in v-bind
  if (isDef(data) && isDef(data.is)) {
    tag = data.is;
  }
  if (!tag) {
    // in case of component :is set to falsy value
    return createEmptyVNode()
  }
  // warn against non-primitive key
  if ( true &&
    isDef(data) && isDef(data.key) && !isPrimitive(data.key)
  ) {
    {
      warn(
        'Avoid using non-primitive value as key, ' +
        'use string/number value instead.',
        context
      );
    }
  }
  // support single function children as default scoped slot
  if (Array.isArray(children) &&
    typeof children[0] === 'function'
  ) {
    data = data || {};
    data.scopedSlots = { default: children[0] };
    children.length = 0;
  }
  if (normalizationType === ALWAYS_NORMALIZE) {
    children = normalizeChildren(children);
  } else if (normalizationType === SIMPLE_NORMALIZE) {
    children = simpleNormalizeChildren(children);
  }
  var vnode, ns;
  if (typeof tag === 'string') {
    var Ctor;
    ns = (context.$vnode && context.$vnode.ns) || config.getTagNamespace(tag);
    if (config.isReservedTag(tag)) {
      // platform built-in elements
      if ( true && isDef(data) && isDef(data.nativeOn) && data.tag !== 'component') {
        warn(
          ("The .native modifier for v-on is only valid on components but it was used on <" + tag + ">."),
          context
        );
      }
      vnode = new VNode(
        config.parsePlatformTagName(tag), data, children,
        undefined, undefined, context
      );
    } else if ((!data || !data.pre) && isDef(Ctor = resolveAsset(context.$options, 'components', tag))) {
      // component
      vnode = createComponent(Ctor, data, context, children, tag);
    } else {
      // unknown or unlisted namespaced elements
      // check at runtime because it may get assigned a namespace when its
      // parent normalizes children
      vnode = new VNode(
        tag, data, children,
        undefined, undefined, context
      );
    }
  } else {
    // direct component options / constructor
    vnode = createComponent(tag, data, context, children);
  }
  if (Array.isArray(vnode)) {
    return vnode
  } else if (isDef(vnode)) {
    if (isDef(ns)) { applyNS(vnode, ns); }
    if (isDef(data)) { registerDeepBindings(data); }
    return vnode
  } else {
    return createEmptyVNode()
  }
}

function applyNS (vnode, ns, force) {
  vnode.ns = ns;
  if (vnode.tag === 'foreignObject') {
    // use default namespace inside foreignObject
    ns = undefined;
    force = true;
  }
  if (isDef(vnode.children)) {
    for (var i = 0, l = vnode.children.length; i < l; i++) {
      var child = vnode.children[i];
      if (isDef(child.tag) && (
        isUndef(child.ns) || (isTrue(force) && child.tag !== 'svg'))) {
        applyNS(child, ns, force);
      }
    }
  }
}

// ref #5318
// necessary to ensure parent re-render when deep bindings like :style and
// :class are used on slot nodes
function registerDeepBindings (data) {
  if (isObject(data.style)) {
    traverse(data.style);
  }
  if (isObject(data.class)) {
    traverse(data.class);
  }
}

/*  */

function initRender (vm) {
  vm._vnode = null; // the root of the child tree
  vm._staticTrees = null; // v-once cached trees
  var options = vm.$options;
  var parentVnode = vm.$vnode = options._parentVnode; // the placeholder node in parent tree
  var renderContext = parentVnode && parentVnode.context;
  vm.$slots = resolveSlots(options._renderChildren, renderContext);
  vm.$scopedSlots = emptyObject;
  // bind the createElement fn to this instance
  // so that we get proper render context inside it.
  // args order: tag, data, children, normalizationType, alwaysNormalize
  // internal version is used by render functions compiled from templates
  vm._c = function (a, b, c, d) { return createElement(vm, a, b, c, d, false); };
  // normalization is always applied for the public version, used in
  // user-written render functions.
  vm.$createElement = function (a, b, c, d) { return createElement(vm, a, b, c, d, true); };

  // $attrs & $listeners are exposed for easier HOC creation.
  // they need to be reactive so that HOCs using them are always updated
  var parentData = parentVnode && parentVnode.data;

  /* istanbul ignore else */
  if (true) {
    defineReactive$$1(vm, '$attrs', parentData && parentData.attrs || emptyObject, function () {
      !isUpdatingChildComponent && warn("$attrs is readonly.", vm);
    }, true);
    defineReactive$$1(vm, '$listeners', options._parentListeners || emptyObject, function () {
      !isUpdatingChildComponent && warn("$listeners is readonly.", vm);
    }, true);
  } else {}
}

var currentRenderingInstance = null;

function renderMixin (Vue) {
  // install runtime convenience helpers
  installRenderHelpers(Vue.prototype);

  Vue.prototype.$nextTick = function (fn) {
    return nextTick(fn, this)
  };

  Vue.prototype._render = function () {
    var vm = this;
    var ref = vm.$options;
    var render = ref.render;
    var _parentVnode = ref._parentVnode;

    if (_parentVnode) {
      vm.$scopedSlots = normalizeScopedSlots(
        _parentVnode.data.scopedSlots,
        vm.$slots,
        vm.$scopedSlots
      );
    }

    // set parent vnode. this allows render functions to have access
    // to the data on the placeholder node.
    vm.$vnode = _parentVnode;
    // render self
    var vnode;
    try {
      // There's no need to maintain a stack because all render fns are called
      // separately from one another. Nested component's render fns are called
      // when parent component is patched.
      currentRenderingInstance = vm;
      vnode = render.call(vm._renderProxy, vm.$createElement);
    } catch (e) {
      handleError(e, vm, "render");
      // return error render result,
      // or previous vnode to prevent render error causing blank component
      /* istanbul ignore else */
      if ( true && vm.$options.renderError) {
        try {
          vnode = vm.$options.renderError.call(vm._renderProxy, vm.$createElement, e);
        } catch (e) {
          handleError(e, vm, "renderError");
          vnode = vm._vnode;
        }
      } else {
        vnode = vm._vnode;
      }
    } finally {
      currentRenderingInstance = null;
    }
    // if the returned array contains only a single node, allow it
    if (Array.isArray(vnode) && vnode.length === 1) {
      vnode = vnode[0];
    }
    // return empty vnode in case the render function errored out
    if (!(vnode instanceof VNode)) {
      if ( true && Array.isArray(vnode)) {
        warn(
          'Multiple root nodes returned from render function. Render function ' +
          'should return a single root node.',
          vm
        );
      }
      vnode = createEmptyVNode();
    }
    // set parent
    vnode.parent = _parentVnode;
    return vnode
  };
}

/*  */

function ensureCtor (comp, base) {
  if (
    comp.__esModule ||
    (hasSymbol && comp[Symbol.toStringTag] === 'Module')
  ) {
    comp = comp.default;
  }
  return isObject(comp)
    ? base.extend(comp)
    : comp
}

function createAsyncPlaceholder (
  factory,
  data,
  context,
  children,
  tag
) {
  var node = createEmptyVNode();
  node.asyncFactory = factory;
  node.asyncMeta = { data: data, context: context, children: children, tag: tag };
  return node
}

function resolveAsyncComponent (
  factory,
  baseCtor
) {
  if (isTrue(factory.error) && isDef(factory.errorComp)) {
    return factory.errorComp
  }

  if (isDef(factory.resolved)) {
    return factory.resolved
  }

  var owner = currentRenderingInstance;
  if (owner && isDef(factory.owners) && factory.owners.indexOf(owner) === -1) {
    // already pending
    factory.owners.push(owner);
  }

  if (isTrue(factory.loading) && isDef(factory.loadingComp)) {
    return factory.loadingComp
  }

  if (owner && !isDef(factory.owners)) {
    var owners = factory.owners = [owner];
    var sync = true;
    var timerLoading = null;
    var timerTimeout = null

    ;(owner).$on('hook:destroyed', function () { return remove(owners, owner); });

    var forceRender = function (renderCompleted) {
      for (var i = 0, l = owners.length; i < l; i++) {
        (owners[i]).$forceUpdate();
      }

      if (renderCompleted) {
        owners.length = 0;
        if (timerLoading !== null) {
          clearTimeout(timerLoading);
          timerLoading = null;
        }
        if (timerTimeout !== null) {
          clearTimeout(timerTimeout);
          timerTimeout = null;
        }
      }
    };

    var resolve = once(function (res) {
      // cache resolved
      factory.resolved = ensureCtor(res, baseCtor);
      // invoke callbacks only if this is not a synchronous resolve
      // (async resolves are shimmed as synchronous during SSR)
      if (!sync) {
        forceRender(true);
      } else {
        owners.length = 0;
      }
    });

    var reject = once(function (reason) {
       true && warn(
        "Failed to resolve async component: " + (String(factory)) +
        (reason ? ("\nReason: " + reason) : '')
      );
      if (isDef(factory.errorComp)) {
        factory.error = true;
        forceRender(true);
      }
    });

    var res = factory(resolve, reject);

    if (isObject(res)) {
      if (isPromise(res)) {
        // () => Promise
        if (isUndef(factory.resolved)) {
          res.then(resolve, reject);
        }
      } else if (isPromise(res.component)) {
        res.component.then(resolve, reject);

        if (isDef(res.error)) {
          factory.errorComp = ensureCtor(res.error, baseCtor);
        }

        if (isDef(res.loading)) {
          factory.loadingComp = ensureCtor(res.loading, baseCtor);
          if (res.delay === 0) {
            factory.loading = true;
          } else {
            timerLoading = setTimeout(function () {
              timerLoading = null;
              if (isUndef(factory.resolved) && isUndef(factory.error)) {
                factory.loading = true;
                forceRender(false);
              }
            }, res.delay || 200);
          }
        }

        if (isDef(res.timeout)) {
          timerTimeout = setTimeout(function () {
            timerTimeout = null;
            if (isUndef(factory.resolved)) {
              reject(
                 true
                  ? ("timeout (" + (res.timeout) + "ms)")
                  : 0
              );
            }
          }, res.timeout);
        }
      }
    }

    sync = false;
    // return in case resolved synchronously
    return factory.loading
      ? factory.loadingComp
      : factory.resolved
  }
}

/*  */

function getFirstComponentChild (children) {
  if (Array.isArray(children)) {
    for (var i = 0; i < children.length; i++) {
      var c = children[i];
      if (isDef(c) && (isDef(c.componentOptions) || isAsyncPlaceholder(c))) {
        return c
      }
    }
  }
}

/*  */

/*  */

function initEvents (vm) {
  vm._events = Object.create(null);
  vm._hasHookEvent = false;
  // init parent attached events
  var listeners = vm.$options._parentListeners;
  if (listeners) {
    updateComponentListeners(vm, listeners);
  }
}

var target;

function add (event, fn) {
  target.$on(event, fn);
}

function remove$1 (event, fn) {
  target.$off(event, fn);
}

function createOnceHandler (event, fn) {
  var _target = target;
  return function onceHandler () {
    var res = fn.apply(null, arguments);
    if (res !== null) {
      _target.$off(event, onceHandler);
    }
  }
}

function updateComponentListeners (
  vm,
  listeners,
  oldListeners
) {
  target = vm;
  updateListeners(listeners, oldListeners || {}, add, remove$1, createOnceHandler, vm);
  target = undefined;
}

function eventsMixin (Vue) {
  var hookRE = /^hook:/;
  Vue.prototype.$on = function (event, fn) {
    var vm = this;
    if (Array.isArray(event)) {
      for (var i = 0, l = event.length; i < l; i++) {
        vm.$on(event[i], fn);
      }
    } else {
      (vm._events[event] || (vm._events[event] = [])).push(fn);
      // optimize hook:event cost by using a boolean flag marked at registration
      // instead of a hash lookup
      if (hookRE.test(event)) {
        vm._hasHookEvent = true;
      }
    }
    return vm
  };

  Vue.prototype.$once = function (event, fn) {
    var vm = this;
    function on () {
      vm.$off(event, on);
      fn.apply(vm, arguments);
    }
    on.fn = fn;
    vm.$on(event, on);
    return vm
  };

  Vue.prototype.$off = function (event, fn) {
    var vm = this;
    // all
    if (!arguments.length) {
      vm._events = Object.create(null);
      return vm
    }
    // array of events
    if (Array.isArray(event)) {
      for (var i$1 = 0, l = event.length; i$1 < l; i$1++) {
        vm.$off(event[i$1], fn);
      }
      return vm
    }
    // specific event
    var cbs = vm._events[event];
    if (!cbs) {
      return vm
    }
    if (!fn) {
      vm._events[event] = null;
      return vm
    }
    // specific handler
    var cb;
    var i = cbs.length;
    while (i--) {
      cb = cbs[i];
      if (cb === fn || cb.fn === fn) {
        cbs.splice(i, 1);
        break
      }
    }
    return vm
  };

  Vue.prototype.$emit = function (event) {
    var vm = this;
    if (true) {
      var lowerCaseEvent = event.toLowerCase();
      if (lowerCaseEvent !== event && vm._events[lowerCaseEvent]) {
        tip(
          "Event \"" + lowerCaseEvent + "\" is emitted in component " +
          (formatComponentName(vm)) + " but the handler is registered for \"" + event + "\". " +
          "Note that HTML attributes are case-insensitive and you cannot use " +
          "v-on to listen to camelCase events when using in-DOM templates. " +
          "You should probably use \"" + (hyphenate(event)) + "\" instead of \"" + event + "\"."
        );
      }
    }
    var cbs = vm._events[event];
    if (cbs) {
      cbs = cbs.length > 1 ? toArray(cbs) : cbs;
      var args = toArray(arguments, 1);
      var info = "event handler for \"" + event + "\"";
      for (var i = 0, l = cbs.length; i < l; i++) {
        invokeWithErrorHandling(cbs[i], vm, args, vm, info);
      }
    }
    return vm
  };
}

/*  */

var activeInstance = null;
var isUpdatingChildComponent = false;

function setActiveInstance(vm) {
  var prevActiveInstance = activeInstance;
  activeInstance = vm;
  return function () {
    activeInstance = prevActiveInstance;
  }
}

function initLifecycle (vm) {
  var options = vm.$options;

  // locate first non-abstract parent
  var parent = options.parent;
  if (parent && !options.abstract) {
    while (parent.$options.abstract && parent.$parent) {
      parent = parent.$parent;
    }
    parent.$children.push(vm);
  }

  vm.$parent = parent;
  vm.$root = parent ? parent.$root : vm;

  vm.$children = [];
  vm.$refs = {};

  vm._watcher = null;
  vm._inactive = null;
  vm._directInactive = false;
  vm._isMounted = false;
  vm._isDestroyed = false;
  vm._isBeingDestroyed = false;
}

function lifecycleMixin (Vue) {
  Vue.prototype._update = function (vnode, hydrating) {
    var vm = this;
    var prevEl = vm.$el;
    var prevVnode = vm._vnode;
    var restoreActiveInstance = setActiveInstance(vm);
    vm._vnode = vnode;
    // Vue.prototype.__patch__ is injected in entry points
    // based on the rendering backend used.
    if (!prevVnode) {
      // initial render
      vm.$el = vm.__patch__(vm.$el, vnode, hydrating, false /* removeOnly */);
    } else {
      // updates
      vm.$el = vm.__patch__(prevVnode, vnode);
    }
    restoreActiveInstance();
    // update __vue__ reference
    if (prevEl) {
      prevEl.__vue__ = null;
    }
    if (vm.$el) {
      vm.$el.__vue__ = vm;
    }
    // if parent is an HOC, update its $el as well
    if (vm.$vnode && vm.$parent && vm.$vnode === vm.$parent._vnode) {
      vm.$parent.$el = vm.$el;
    }
    // updated hook is called by the scheduler to ensure that children are
    // updated in a parent's updated hook.
  };

  Vue.prototype.$forceUpdate = function () {
    var vm = this;
    if (vm._watcher) {
      vm._watcher.update();
    }
  };

  Vue.prototype.$destroy = function () {
    var vm = this;
    if (vm._isBeingDestroyed) {
      return
    }
    callHook(vm, 'beforeDestroy');
    vm._isBeingDestroyed = true;
    // remove self from parent
    var parent = vm.$parent;
    if (parent && !parent._isBeingDestroyed && !vm.$options.abstract) {
      remove(parent.$children, vm);
    }
    // teardown watchers
    if (vm._watcher) {
      vm._watcher.teardown();
    }
    var i = vm._watchers.length;
    while (i--) {
      vm._watchers[i].teardown();
    }
    // remove reference from data ob
    // frozen object may not have observer.
    if (vm._data.__ob__) {
      vm._data.__ob__.vmCount--;
    }
    // call the last hook...
    vm._isDestroyed = true;
    // invoke destroy hooks on current rendered tree
    vm.__patch__(vm._vnode, null);
    // fire destroyed hook
    callHook(vm, 'destroyed');
    // turn off all instance listeners.
    vm.$off();
    // remove __vue__ reference
    if (vm.$el) {
      vm.$el.__vue__ = null;
    }
    // release circular reference (#6759)
    if (vm.$vnode) {
      vm.$vnode.parent = null;
    }
  };
}

function mountComponent (
  vm,
  el,
  hydrating
) {
  vm.$el = el;
  if (!vm.$options.render) {
    vm.$options.render = createEmptyVNode;
    if (true) {
      /* istanbul ignore if */
      if ((vm.$options.template && vm.$options.template.charAt(0) !== '#') ||
        vm.$options.el || el) {
        warn(
          'You are using the runtime-only build of Vue where the template ' +
          'compiler is not available. Either pre-compile the templates into ' +
          'render functions, or use the compiler-included build.',
          vm
        );
      } else {
        warn(
          'Failed to mount component: template or render function not defined.',
          vm
        );
      }
    }
  }
  callHook(vm, 'beforeMount');

  var updateComponent;
  /* istanbul ignore if */
  if ( true && config.performance && mark) {
    updateComponent = function () {
      var name = vm._name;
      var id = vm._uid;
      var startTag = "vue-perf-start:" + id;
      var endTag = "vue-perf-end:" + id;

      mark(startTag);
      var vnode = vm._render();
      mark(endTag);
      measure(("vue " + name + " render"), startTag, endTag);

      mark(startTag);
      vm._update(vnode, hydrating);
      mark(endTag);
      measure(("vue " + name + " patch"), startTag, endTag);
    };
  } else {
    updateComponent = function () {
      vm._update(vm._render(), hydrating);
    };
  }

  // we set this to vm._watcher inside the watcher's constructor
  // since the watcher's initial patch may call $forceUpdate (e.g. inside child
  // component's mounted hook), which relies on vm._watcher being already defined
  new Watcher(vm, updateComponent, noop, {
    before: function before () {
      if (vm._isMounted && !vm._isDestroyed) {
        callHook(vm, 'beforeUpdate');
      }
    }
  }, true /* isRenderWatcher */);
  hydrating = false;

  // manually mounted instance, call mounted on self
  // mounted is called for render-created child components in its inserted hook
  if (vm.$vnode == null) {
    vm._isMounted = true;
    callHook(vm, 'mounted');
  }
  return vm
}

function updateChildComponent (
  vm,
  propsData,
  listeners,
  parentVnode,
  renderChildren
) {
  if (true) {
    isUpdatingChildComponent = true;
  }

  // determine whether component has slot children
  // we need to do this before overwriting $options._renderChildren.

  // check if there are dynamic scopedSlots (hand-written or compiled but with
  // dynamic slot names). Static scoped slots compiled from template has the
  // "$stable" marker.
  var newScopedSlots = parentVnode.data.scopedSlots;
  var oldScopedSlots = vm.$scopedSlots;
  var hasDynamicScopedSlot = !!(
    (newScopedSlots && !newScopedSlots.$stable) ||
    (oldScopedSlots !== emptyObject && !oldScopedSlots.$stable) ||
    (newScopedSlots && vm.$scopedSlots.$key !== newScopedSlots.$key) ||
    (!newScopedSlots && vm.$scopedSlots.$key)
  );

  // Any static slot children from the parent may have changed during parent's
  // update. Dynamic scoped slots may also have changed. In such cases, a forced
  // update is necessary to ensure correctness.
  var needsForceUpdate = !!(
    renderChildren ||               // has new static slots
    vm.$options._renderChildren ||  // has old static slots
    hasDynamicScopedSlot
  );

  vm.$options._parentVnode = parentVnode;
  vm.$vnode = parentVnode; // update vm's placeholder node without re-render

  if (vm._vnode) { // update child tree's parent
    vm._vnode.parent = parentVnode;
  }
  vm.$options._renderChildren = renderChildren;

  // update $attrs and $listeners hash
  // these are also reactive so they may trigger child update if the child
  // used them during render
  vm.$attrs = parentVnode.data.attrs || emptyObject;
  vm.$listeners = listeners || emptyObject;

  // update props
  if (propsData && vm.$options.props) {
    toggleObserving(false);
    var props = vm._props;
    var propKeys = vm.$options._propKeys || [];
    for (var i = 0; i < propKeys.length; i++) {
      var key = propKeys[i];
      var propOptions = vm.$options.props; // wtf flow?
      props[key] = validateProp(key, propOptions, propsData, vm);
    }
    toggleObserving(true);
    // keep a copy of raw propsData
    vm.$options.propsData = propsData;
  }

  // update listeners
  listeners = listeners || emptyObject;
  var oldListeners = vm.$options._parentListeners;
  vm.$options._parentListeners = listeners;
  updateComponentListeners(vm, listeners, oldListeners);

  // resolve slots + force update if has children
  if (needsForceUpdate) {
    vm.$slots = resolveSlots(renderChildren, parentVnode.context);
    vm.$forceUpdate();
  }

  if (true) {
    isUpdatingChildComponent = false;
  }
}

function isInInactiveTree (vm) {
  while (vm && (vm = vm.$parent)) {
    if (vm._inactive) { return true }
  }
  return false
}

function activateChildComponent (vm, direct) {
  if (direct) {
    vm._directInactive = false;
    if (isInInactiveTree(vm)) {
      return
    }
  } else if (vm._directInactive) {
    return
  }
  if (vm._inactive || vm._inactive === null) {
    vm._inactive = false;
    for (var i = 0; i < vm.$children.length; i++) {
      activateChildComponent(vm.$children[i]);
    }
    callHook(vm, 'activated');
  }
}

function deactivateChildComponent (vm, direct) {
  if (direct) {
    vm._directInactive = true;
    if (isInInactiveTree(vm)) {
      return
    }
  }
  if (!vm._inactive) {
    vm._inactive = true;
    for (var i = 0; i < vm.$children.length; i++) {
      deactivateChildComponent(vm.$children[i]);
    }
    callHook(vm, 'deactivated');
  }
}

function callHook (vm, hook) {
  // #7573 disable dep collection when invoking lifecycle hooks
  pushTarget();
  var handlers = vm.$options[hook];
  var info = hook + " hook";
  if (handlers) {
    for (var i = 0, j = handlers.length; i < j; i++) {
      invokeWithErrorHandling(handlers[i], vm, null, vm, info);
    }
  }
  if (vm._hasHookEvent) {
    vm.$emit('hook:' + hook);
  }
  popTarget();
}

/*  */

var MAX_UPDATE_COUNT = 100;

var queue = [];
var activatedChildren = [];
var has = {};
var circular = {};
var waiting = false;
var flushing = false;
var index = 0;

/**
 * Reset the scheduler's state.
 */
function resetSchedulerState () {
  index = queue.length = activatedChildren.length = 0;
  has = {};
  if (true) {
    circular = {};
  }
  waiting = flushing = false;
}

// Async edge case #6566 requires saving the timestamp when event listeners are
// attached. However, calling performance.now() has a perf overhead especially
// if the page has thousands of event listeners. Instead, we take a timestamp
// every time the scheduler flushes and use that for all event listeners
// attached during that flush.
var currentFlushTimestamp = 0;

// Async edge case fix requires storing an event listener's attach timestamp.
var getNow = Date.now;

// Determine what event timestamp the browser is using. Annoyingly, the
// timestamp can either be hi-res (relative to page load) or low-res
// (relative to UNIX epoch), so in order to compare time we have to use the
// same timestamp type when saving the flush timestamp.
// All IE versions use low-res event timestamps, and have problematic clock
// implementations (#9632)
if (inBrowser && !isIE) {
  var performance = window.performance;
  if (
    performance &&
    typeof performance.now === 'function' &&
    getNow() > document.createEvent('Event').timeStamp
  ) {
    // if the event timestamp, although evaluated AFTER the Date.now(), is
    // smaller than it, it means the event is using a hi-res timestamp,
    // and we need to use the hi-res version for event listener timestamps as
    // well.
    getNow = function () { return performance.now(); };
  }
}

/**
 * Flush both queues and run the watchers.
 */
function flushSchedulerQueue () {
  currentFlushTimestamp = getNow();
  flushing = true;
  var watcher, id;

  // Sort queue before flush.
  // This ensures that:
  // 1. Components are updated from parent to child. (because parent is always
  //    created before the child)
  // 2. A component's user watchers are run before its render watcher (because
  //    user watchers are created before the render watcher)
  // 3. If a component is destroyed during a parent component's watcher run,
  //    its watchers can be skipped.
  queue.sort(function (a, b) { return a.id - b.id; });

  // do not cache length because more watchers might be pushed
  // as we run existing watchers
  for (index = 0; index < queue.length; index++) {
    watcher = queue[index];
    if (watcher.before) {
      watcher.before();
    }
    id = watcher.id;
    has[id] = null;
    watcher.run();
    // in dev build, check and stop circular updates.
    if ( true && has[id] != null) {
      circular[id] = (circular[id] || 0) + 1;
      if (circular[id] > MAX_UPDATE_COUNT) {
        warn(
          'You may have an infinite update loop ' + (
            watcher.user
              ? ("in watcher with expression \"" + (watcher.expression) + "\"")
              : "in a component render function."
          ),
          watcher.vm
        );
        break
      }
    }
  }

  // keep copies of post queues before resetting state
  var activatedQueue = activatedChildren.slice();
  var updatedQueue = queue.slice();

  resetSchedulerState();

  // call component updated and activated hooks
  callActivatedHooks(activatedQueue);
  callUpdatedHooks(updatedQueue);

  // devtool hook
  /* istanbul ignore if */
  if (devtools && config.devtools) {
    devtools.emit('flush');
  }
}

function callUpdatedHooks (queue) {
  var i = queue.length;
  while (i--) {
    var watcher = queue[i];
    var vm = watcher.vm;
    if (vm._watcher === watcher && vm._isMounted && !vm._isDestroyed) {
      callHook(vm, 'updated');
    }
  }
}

/**
 * Queue a kept-alive component that was activated during patch.
 * The queue will be processed after the entire tree has been patched.
 */
function queueActivatedComponent (vm) {
  // setting _inactive to false here so that a render function can
  // rely on checking whether it's in an inactive tree (e.g. router-view)
  vm._inactive = false;
  activatedChildren.push(vm);
}

function callActivatedHooks (queue) {
  for (var i = 0; i < queue.length; i++) {
    queue[i]._inactive = true;
    activateChildComponent(queue[i], true /* true */);
  }
}

/**
 * Push a watcher into the watcher queue.
 * Jobs with duplicate IDs will be skipped unless it's
 * pushed when the queue is being flushed.
 */
function queueWatcher (watcher) {
  var id = watcher.id;
  if (has[id] == null) {
    has[id] = true;
    if (!flushing) {
      queue.push(watcher);
    } else {
      // if already flushing, splice the watcher based on its id
      // if already past its id, it will be run next immediately.
      var i = queue.length - 1;
      while (i > index && queue[i].id > watcher.id) {
        i--;
      }
      queue.splice(i + 1, 0, watcher);
    }
    // queue the flush
    if (!waiting) {
      waiting = true;

      if ( true && !config.async) {
        flushSchedulerQueue();
        return
      }
      nextTick(flushSchedulerQueue);
    }
  }
}

/*  */



var uid$2 = 0;

/**
 * A watcher parses an expression, collects dependencies,
 * and fires callback when the expression value changes.
 * This is used for both the $watch() api and directives.
 */
var Watcher = function Watcher (
  vm,
  expOrFn,
  cb,
  options,
  isRenderWatcher
) {
  this.vm = vm;
  if (isRenderWatcher) {
    vm._watcher = this;
  }
  vm._watchers.push(this);
  // options
  if (options) {
    this.deep = !!options.deep;
    this.user = !!options.user;
    this.lazy = !!options.lazy;
    this.sync = !!options.sync;
    this.before = options.before;
  } else {
    this.deep = this.user = this.lazy = this.sync = false;
  }
  this.cb = cb;
  this.id = ++uid$2; // uid for batching
  this.active = true;
  this.dirty = this.lazy; // for lazy watchers
  this.deps = [];
  this.newDeps = [];
  this.depIds = new _Set();
  this.newDepIds = new _Set();
  this.expression =  true
    ? expOrFn.toString()
    : 0;
  // parse expression for getter
  if (typeof expOrFn === 'function') {
    this.getter = expOrFn;
  } else {
    this.getter = parsePath(expOrFn);
    if (!this.getter) {
      this.getter = noop;
       true && warn(
        "Failed watching path: \"" + expOrFn + "\" " +
        'Watcher only accepts simple dot-delimited paths. ' +
        'For full control, use a function instead.',
        vm
      );
    }
  }
  this.value = this.lazy
    ? undefined
    : this.get();
};

/**
 * Evaluate the getter, and re-collect dependencies.
 */
Watcher.prototype.get = function get () {
  pushTarget(this);
  var value;
  var vm = this.vm;
  try {
    value = this.getter.call(vm, vm);
  } catch (e) {
    if (this.user) {
      handleError(e, vm, ("getter for watcher \"" + (this.expression) + "\""));
    } else {
      throw e
    }
  } finally {
    // "touch" every property so they are all tracked as
    // dependencies for deep watching
    if (this.deep) {
      traverse(value);
    }
    popTarget();
    this.cleanupDeps();
  }
  return value
};

/**
 * Add a dependency to this directive.
 */
Watcher.prototype.addDep = function addDep (dep) {
  var id = dep.id;
  if (!this.newDepIds.has(id)) {
    this.newDepIds.add(id);
    this.newDeps.push(dep);
    if (!this.depIds.has(id)) {
      dep.addSub(this);
    }
  }
};

/**
 * Clean up for dependency collection.
 */
Watcher.prototype.cleanupDeps = function cleanupDeps () {
  var i = this.deps.length;
  while (i--) {
    var dep = this.deps[i];
    if (!this.newDepIds.has(dep.id)) {
      dep.removeSub(this);
    }
  }
  var tmp = this.depIds;
  this.depIds = this.newDepIds;
  this.newDepIds = tmp;
  this.newDepIds.clear();
  tmp = this.deps;
  this.deps = this.newDeps;
  this.newDeps = tmp;
  this.newDeps.length = 0;
};

/**
 * Subscriber interface.
 * Will be called when a dependency changes.
 */
Watcher.prototype.update = function update () {
  /* istanbul ignore else */
  if (this.lazy) {
    this.dirty = true;
  } else if (this.sync) {
    this.run();
  } else {
    queueWatcher(this);
  }
};

/**
 * Scheduler job interface.
 * Will be called by the scheduler.
 */
Watcher.prototype.run = function run () {
  if (this.active) {
    var value = this.get();
    if (
      value !== this.value ||
      // Deep watchers and watchers on Object/Arrays should fire even
      // when the value is the same, because the value may
      // have mutated.
      isObject(value) ||
      this.deep
    ) {
      // set new value
      var oldValue = this.value;
      this.value = value;
      if (this.user) {
        var info = "callback for watcher \"" + (this.expression) + "\"";
        invokeWithErrorHandling(this.cb, this.vm, [value, oldValue], this.vm, info);
      } else {
        this.cb.call(this.vm, value, oldValue);
      }
    }
  }
};

/**
 * Evaluate the value of the watcher.
 * This only gets called for lazy watchers.
 */
Watcher.prototype.evaluate = function evaluate () {
  this.value = this.get();
  this.dirty = false;
};

/**
 * Depend on all deps collected by this watcher.
 */
Watcher.prototype.depend = function depend () {
  var i = this.deps.length;
  while (i--) {
    this.deps[i].depend();
  }
};

/**
 * Remove self from all dependencies' subscriber list.
 */
Watcher.prototype.teardown = function teardown () {
  if (this.active) {
    // remove self from vm's watcher list
    // this is a somewhat expensive operation so we skip it
    // if the vm is being destroyed.
    if (!this.vm._isBeingDestroyed) {
      remove(this.vm._watchers, this);
    }
    var i = this.deps.length;
    while (i--) {
      this.deps[i].removeSub(this);
    }
    this.active = false;
  }
};

/*  */

var sharedPropertyDefinition = {
  enumerable: true,
  configurable: true,
  get: noop,
  set: noop
};

function proxy (target, sourceKey, key) {
  sharedPropertyDefinition.get = function proxyGetter () {
    return this[sourceKey][key]
  };
  sharedPropertyDefinition.set = function proxySetter (val) {
    this[sourceKey][key] = val;
  };
  Object.defineProperty(target, key, sharedPropertyDefinition);
}

function initState (vm) {
  vm._watchers = [];
  var opts = vm.$options;
  if (opts.props) { initProps(vm, opts.props); }
  if (opts.methods) { initMethods(vm, opts.methods); }
  if (opts.data) {
    initData(vm);
  } else {
    observe(vm._data = {}, true /* asRootData */);
  }
  if (opts.computed) { initComputed(vm, opts.computed); }
  if (opts.watch && opts.watch !== nativeWatch) {
    initWatch(vm, opts.watch);
  }
}

function initProps (vm, propsOptions) {
  var propsData = vm.$options.propsData || {};
  var props = vm._props = {};
  // cache prop keys so that future props updates can iterate using Array
  // instead of dynamic object key enumeration.
  var keys = vm.$options._propKeys = [];
  var isRoot = !vm.$parent;
  // root instance props should be converted
  if (!isRoot) {
    toggleObserving(false);
  }
  var loop = function ( key ) {
    keys.push(key);
    var value = validateProp(key, propsOptions, propsData, vm);
    /* istanbul ignore else */
    if (true) {
      var hyphenatedKey = hyphenate(key);
      if (isReservedAttribute(hyphenatedKey) ||
          config.isReservedAttr(hyphenatedKey)) {
        warn(
          ("\"" + hyphenatedKey + "\" is a reserved attribute and cannot be used as component prop."),
          vm
        );
      }
      defineReactive$$1(props, key, value, function () {
        if (!isRoot && !isUpdatingChildComponent) {
          warn(
            "Avoid mutating a prop directly since the value will be " +
            "overwritten whenever the parent component re-renders. " +
            "Instead, use a data or computed property based on the prop's " +
            "value. Prop being mutated: \"" + key + "\"",
            vm
          );
        }
      });
    } else {}
    // static props are already proxied on the component's prototype
    // during Vue.extend(). We only need to proxy props defined at
    // instantiation here.
    if (!(key in vm)) {
      proxy(vm, "_props", key);
    }
  };

  for (var key in propsOptions) loop( key );
  toggleObserving(true);
}

function initData (vm) {
  var data = vm.$options.data;
  data = vm._data = typeof data === 'function'
    ? getData(data, vm)
    : data || {};
  if (!isPlainObject(data)) {
    data = {};
     true && warn(
      'data functions should return an object:\n' +
      'https://vuejs.org/v2/guide/components.html#data-Must-Be-a-Function',
      vm
    );
  }
  // proxy data on instance
  var keys = Object.keys(data);
  var props = vm.$options.props;
  var methods = vm.$options.methods;
  var i = keys.length;
  while (i--) {
    var key = keys[i];
    if (true) {
      if (methods && hasOwn(methods, key)) {
        warn(
          ("Method \"" + key + "\" has already been defined as a data property."),
          vm
        );
      }
    }
    if (props && hasOwn(props, key)) {
       true && warn(
        "The data property \"" + key + "\" is already declared as a prop. " +
        "Use prop default value instead.",
        vm
      );
    } else if (!isReserved(key)) {
      proxy(vm, "_data", key);
    }
  }
  // observe data
  observe(data, true /* asRootData */);
}

function getData (data, vm) {
  // #7573 disable dep collection when invoking data getters
  pushTarget();
  try {
    return data.call(vm, vm)
  } catch (e) {
    handleError(e, vm, "data()");
    return {}
  } finally {
    popTarget();
  }
}

var computedWatcherOptions = { lazy: true };

function initComputed (vm, computed) {
  // $flow-disable-line
  var watchers = vm._computedWatchers = Object.create(null);
  // computed properties are just getters during SSR
  var isSSR = isServerRendering();

  for (var key in computed) {
    var userDef = computed[key];
    var getter = typeof userDef === 'function' ? userDef : userDef.get;
    if ( true && getter == null) {
      warn(
        ("Getter is missing for computed property \"" + key + "\"."),
        vm
      );
    }

    if (!isSSR) {
      // create internal watcher for the computed property.
      watchers[key] = new Watcher(
        vm,
        getter || noop,
        noop,
        computedWatcherOptions
      );
    }

    // component-defined computed properties are already defined on the
    // component prototype. We only need to define computed properties defined
    // at instantiation here.
    if (!(key in vm)) {
      defineComputed(vm, key, userDef);
    } else if (true) {
      if (key in vm.$data) {
        warn(("The computed property \"" + key + "\" is already defined in data."), vm);
      } else if (vm.$options.props && key in vm.$options.props) {
        warn(("The computed property \"" + key + "\" is already defined as a prop."), vm);
      } else if (vm.$options.methods && key in vm.$options.methods) {
        warn(("The computed property \"" + key + "\" is already defined as a method."), vm);
      }
    }
  }
}

function defineComputed (
  target,
  key,
  userDef
) {
  var shouldCache = !isServerRendering();
  if (typeof userDef === 'function') {
    sharedPropertyDefinition.get = shouldCache
      ? createComputedGetter(key)
      : createGetterInvoker(userDef);
    sharedPropertyDefinition.set = noop;
  } else {
    sharedPropertyDefinition.get = userDef.get
      ? shouldCache && userDef.cache !== false
        ? createComputedGetter(key)
        : createGetterInvoker(userDef.get)
      : noop;
    sharedPropertyDefinition.set = userDef.set || noop;
  }
  if ( true &&
      sharedPropertyDefinition.set === noop) {
    sharedPropertyDefinition.set = function () {
      warn(
        ("Computed property \"" + key + "\" was assigned to but it has no setter."),
        this
      );
    };
  }
  Object.defineProperty(target, key, sharedPropertyDefinition);
}

function createComputedGetter (key) {
  return function computedGetter () {
    var watcher = this._computedWatchers && this._computedWatchers[key];
    if (watcher) {
      if (watcher.dirty) {
        watcher.evaluate();
      }
      if (Dep.target) {
        watcher.depend();
      }
      return watcher.value
    }
  }
}

function createGetterInvoker(fn) {
  return function computedGetter () {
    return fn.call(this, this)
  }
}

function initMethods (vm, methods) {
  var props = vm.$options.props;
  for (var key in methods) {
    if (true) {
      if (typeof methods[key] !== 'function') {
        warn(
          "Method \"" + key + "\" has type \"" + (typeof methods[key]) + "\" in the component definition. " +
          "Did you reference the function correctly?",
          vm
        );
      }
      if (props && hasOwn(props, key)) {
        warn(
          ("Method \"" + key + "\" has already been defined as a prop."),
          vm
        );
      }
      if ((key in vm) && isReserved(key)) {
        warn(
          "Method \"" + key + "\" conflicts with an existing Vue instance method. " +
          "Avoid defining component methods that start with _ or $."
        );
      }
    }
    vm[key] = typeof methods[key] !== 'function' ? noop : bind(methods[key], vm);
  }
}

function initWatch (vm, watch) {
  for (var key in watch) {
    var handler = watch[key];
    if (Array.isArray(handler)) {
      for (var i = 0; i < handler.length; i++) {
        createWatcher(vm, key, handler[i]);
      }
    } else {
      createWatcher(vm, key, handler);
    }
  }
}

function createWatcher (
  vm,
  expOrFn,
  handler,
  options
) {
  if (isPlainObject(handler)) {
    options = handler;
    handler = handler.handler;
  }
  if (typeof handler === 'string') {
    handler = vm[handler];
  }
  return vm.$watch(expOrFn, handler, options)
}

function stateMixin (Vue) {
  // flow somehow has problems with directly declared definition object
  // when using Object.defineProperty, so we have to procedurally build up
  // the object here.
  var dataDef = {};
  dataDef.get = function () { return this._data };
  var propsDef = {};
  propsDef.get = function () { return this._props };
  if (true) {
    dataDef.set = function () {
      warn(
        'Avoid replacing instance root $data. ' +
        'Use nested data properties instead.',
        this
      );
    };
    propsDef.set = function () {
      warn("$props is readonly.", this);
    };
  }
  Object.defineProperty(Vue.prototype, '$data', dataDef);
  Object.defineProperty(Vue.prototype, '$props', propsDef);

  Vue.prototype.$set = set;
  Vue.prototype.$delete = del;

  Vue.prototype.$watch = function (
    expOrFn,
    cb,
    options
  ) {
    var vm = this;
    if (isPlainObject(cb)) {
      return createWatcher(vm, expOrFn, cb, options)
    }
    options = options || {};
    options.user = true;
    var watcher = new Watcher(vm, expOrFn, cb, options);
    if (options.immediate) {
      var info = "callback for immediate watcher \"" + (watcher.expression) + "\"";
      pushTarget();
      invokeWithErrorHandling(cb, vm, [watcher.value], vm, info);
      popTarget();
    }
    return function unwatchFn () {
      watcher.teardown();
    }
  };
}

/*  */

var uid$3 = 0;

function initMixin (Vue) {
  Vue.prototype._init = function (options) {
    var vm = this;
    // a uid
    vm._uid = uid$3++;

    var startTag, endTag;
    /* istanbul ignore if */
    if ( true && config.performance && mark) {
      startTag = "vue-perf-start:" + (vm._uid);
      endTag = "vue-perf-end:" + (vm._uid);
      mark(startTag);
    }

    // a flag to avoid this being observed
    vm._isVue = true;
    // merge options
    if (options && options._isComponent) {
      // optimize internal component instantiation
      // since dynamic options merging is pretty slow, and none of the
      // internal component options needs special treatment.
      initInternalComponent(vm, options);
    } else {
      vm.$options = mergeOptions(
        resolveConstructorOptions(vm.constructor),
        options || {},
        vm
      );
    }
    /* istanbul ignore else */
    if (true) {
      initProxy(vm);
    } else {}
    // expose real self
    vm._self = vm;
    initLifecycle(vm);
    initEvents(vm);
    initRender(vm);
    callHook(vm, 'beforeCreate');
    initInjections(vm); // resolve injections before data/props
    initState(vm);
    initProvide(vm); // resolve provide after data/props
    callHook(vm, 'created');

    /* istanbul ignore if */
    if ( true && config.performance && mark) {
      vm._name = formatComponentName(vm, false);
      mark(endTag);
      measure(("vue " + (vm._name) + " init"), startTag, endTag);
    }

    if (vm.$options.el) {
      vm.$mount(vm.$options.el);
    }
  };
}

function initInternalComponent (vm, options) {
  var opts = vm.$options = Object.create(vm.constructor.options);
  // doing this because it's faster than dynamic enumeration.
  var parentVnode = options._parentVnode;
  opts.parent = options.parent;
  opts._parentVnode = parentVnode;

  var vnodeComponentOptions = parentVnode.componentOptions;
  opts.propsData = vnodeComponentOptions.propsData;
  opts._parentListeners = vnodeComponentOptions.listeners;
  opts._renderChildren = vnodeComponentOptions.children;
  opts._componentTag = vnodeComponentOptions.tag;

  if (options.render) {
    opts.render = options.render;
    opts.staticRenderFns = options.staticRenderFns;
  }
}

function resolveConstructorOptions (Ctor) {
  var options = Ctor.options;
  if (Ctor.super) {
    var superOptions = resolveConstructorOptions(Ctor.super);
    var cachedSuperOptions = Ctor.superOptions;
    if (superOptions !== cachedSuperOptions) {
      // super option changed,
      // need to resolve new options.
      Ctor.superOptions = superOptions;
      // check if there are any late-modified/attached options (#4976)
      var modifiedOptions = resolveModifiedOptions(Ctor);
      // update base extend options
      if (modifiedOptions) {
        extend(Ctor.extendOptions, modifiedOptions);
      }
      options = Ctor.options = mergeOptions(superOptions, Ctor.extendOptions);
      if (options.name) {
        options.components[options.name] = Ctor;
      }
    }
  }
  return options
}

function resolveModifiedOptions (Ctor) {
  var modified;
  var latest = Ctor.options;
  var sealed = Ctor.sealedOptions;
  for (var key in latest) {
    if (latest[key] !== sealed[key]) {
      if (!modified) { modified = {}; }
      modified[key] = latest[key];
    }
  }
  return modified
}

function Vue (options) {
  if ( true &&
    !(this instanceof Vue)
  ) {
    warn('Vue is a constructor and should be called with the `new` keyword');
  }
  this._init(options);
}

initMixin(Vue);
stateMixin(Vue);
eventsMixin(Vue);
lifecycleMixin(Vue);
renderMixin(Vue);

/*  */

function initUse (Vue) {
  Vue.use = function (plugin) {
    var installedPlugins = (this._installedPlugins || (this._installedPlugins = []));
    if (installedPlugins.indexOf(plugin) > -1) {
      return this
    }

    // additional parameters
    var args = toArray(arguments, 1);
    args.unshift(this);
    if (typeof plugin.install === 'function') {
      plugin.install.apply(plugin, args);
    } else if (typeof plugin === 'function') {
      plugin.apply(null, args);
    }
    installedPlugins.push(plugin);
    return this
  };
}

/*  */

function initMixin$1 (Vue) {
  Vue.mixin = function (mixin) {
    this.options = mergeOptions(this.options, mixin);
    return this
  };
}

/*  */

function initExtend (Vue) {
  /**
   * Each instance constructor, including Vue, has a unique
   * cid. This enables us to create wrapped "child
   * constructors" for prototypal inheritance and cache them.
   */
  Vue.cid = 0;
  var cid = 1;

  /**
   * Class inheritance
   */
  Vue.extend = function (extendOptions) {
    extendOptions = extendOptions || {};
    var Super = this;
    var SuperId = Super.cid;
    var cachedCtors = extendOptions._Ctor || (extendOptions._Ctor = {});
    if (cachedCtors[SuperId]) {
      return cachedCtors[SuperId]
    }

    var name = extendOptions.name || Super.options.name;
    if ( true && name) {
      validateComponentName(name);
    }

    var Sub = function VueComponent (options) {
      this._init(options);
    };
    Sub.prototype = Object.create(Super.prototype);
    Sub.prototype.constructor = Sub;
    Sub.cid = cid++;
    Sub.options = mergeOptions(
      Super.options,
      extendOptions
    );
    Sub['super'] = Super;

    // For props and computed properties, we define the proxy getters on
    // the Vue instances at extension time, on the extended prototype. This
    // avoids Object.defineProperty calls for each instance created.
    if (Sub.options.props) {
      initProps$1(Sub);
    }
    if (Sub.options.computed) {
      initComputed$1(Sub);
    }

    // allow further extension/mixin/plugin usage
    Sub.extend = Super.extend;
    Sub.mixin = Super.mixin;
    Sub.use = Super.use;

    // create asset registers, so extended classes
    // can have their private assets too.
    ASSET_TYPES.forEach(function (type) {
      Sub[type] = Super[type];
    });
    // enable recursive self-lookup
    if (name) {
      Sub.options.components[name] = Sub;
    }

    // keep a reference to the super options at extension time.
    // later at instantiation we can check if Super's options have
    // been updated.
    Sub.superOptions = Super.options;
    Sub.extendOptions = extendOptions;
    Sub.sealedOptions = extend({}, Sub.options);

    // cache constructor
    cachedCtors[SuperId] = Sub;
    return Sub
  };
}

function initProps$1 (Comp) {
  var props = Comp.options.props;
  for (var key in props) {
    proxy(Comp.prototype, "_props", key);
  }
}

function initComputed$1 (Comp) {
  var computed = Comp.options.computed;
  for (var key in computed) {
    defineComputed(Comp.prototype, key, computed[key]);
  }
}

/*  */

function initAssetRegisters (Vue) {
  /**
   * Create asset registration methods.
   */
  ASSET_TYPES.forEach(function (type) {
    Vue[type] = function (
      id,
      definition
    ) {
      if (!definition) {
        return this.options[type + 's'][id]
      } else {
        /* istanbul ignore if */
        if ( true && type === 'component') {
          validateComponentName(id);
        }
        if (type === 'component' && isPlainObject(definition)) {
          definition.name = definition.name || id;
          definition = this.options._base.extend(definition);
        }
        if (type === 'directive' && typeof definition === 'function') {
          definition = { bind: definition, update: definition };
        }
        this.options[type + 's'][id] = definition;
        return definition
      }
    };
  });
}

/*  */





function getComponentName (opts) {
  return opts && (opts.Ctor.options.name || opts.tag)
}

function matches (pattern, name) {
  if (Array.isArray(pattern)) {
    return pattern.indexOf(name) > -1
  } else if (typeof pattern === 'string') {
    return pattern.split(',').indexOf(name) > -1
  } else if (isRegExp(pattern)) {
    return pattern.test(name)
  }
  /* istanbul ignore next */
  return false
}

function pruneCache (keepAliveInstance, filter) {
  var cache = keepAliveInstance.cache;
  var keys = keepAliveInstance.keys;
  var _vnode = keepAliveInstance._vnode;
  for (var key in cache) {
    var entry = cache[key];
    if (entry) {
      var name = entry.name;
      if (name && !filter(name)) {
        pruneCacheEntry(cache, key, keys, _vnode);
      }
    }
  }
}

function pruneCacheEntry (
  cache,
  key,
  keys,
  current
) {
  var entry = cache[key];
  if (entry && (!current || entry.tag !== current.tag)) {
    entry.componentInstance.$destroy();
  }
  cache[key] = null;
  remove(keys, key);
}

var patternTypes = [String, RegExp, Array];

var KeepAlive = {
  name: 'keep-alive',
  abstract: true,

  props: {
    include: patternTypes,
    exclude: patternTypes,
    max: [String, Number]
  },

  methods: {
    cacheVNode: function cacheVNode() {
      var ref = this;
      var cache = ref.cache;
      var keys = ref.keys;
      var vnodeToCache = ref.vnodeToCache;
      var keyToCache = ref.keyToCache;
      if (vnodeToCache) {
        var tag = vnodeToCache.tag;
        var componentInstance = vnodeToCache.componentInstance;
        var componentOptions = vnodeToCache.componentOptions;
        cache[keyToCache] = {
          name: getComponentName(componentOptions),
          tag: tag,
          componentInstance: componentInstance,
        };
        keys.push(keyToCache);
        // prune oldest entry
        if (this.max && keys.length > parseInt(this.max)) {
          pruneCacheEntry(cache, keys[0], keys, this._vnode);
        }
        this.vnodeToCache = null;
      }
    }
  },

  created: function created () {
    this.cache = Object.create(null);
    this.keys = [];
  },

  destroyed: function destroyed () {
    for (var key in this.cache) {
      pruneCacheEntry(this.cache, key, this.keys);
    }
  },

  mounted: function mounted () {
    var this$1 = this;

    this.cacheVNode();
    this.$watch('include', function (val) {
      pruneCache(this$1, function (name) { return matches(val, name); });
    });
    this.$watch('exclude', function (val) {
      pruneCache(this$1, function (name) { return !matches(val, name); });
    });
  },

  updated: function updated () {
    this.cacheVNode();
  },

  render: function render () {
    var slot = this.$slots.default;
    var vnode = getFirstComponentChild(slot);
    var componentOptions = vnode && vnode.componentOptions;
    if (componentOptions) {
      // check pattern
      var name = getComponentName(componentOptions);
      var ref = this;
      var include = ref.include;
      var exclude = ref.exclude;
      if (
        // not included
        (include && (!name || !matches(include, name))) ||
        // excluded
        (exclude && name && matches(exclude, name))
      ) {
        return vnode
      }

      var ref$1 = this;
      var cache = ref$1.cache;
      var keys = ref$1.keys;
      var key = vnode.key == null
        // same constructor may get registered as different local components
        // so cid alone is not enough (#3269)
        ? componentOptions.Ctor.cid + (componentOptions.tag ? ("::" + (componentOptions.tag)) : '')
        : vnode.key;
      if (cache[key]) {
        vnode.componentInstance = cache[key].componentInstance;
        // make current key freshest
        remove(keys, key);
        keys.push(key);
      } else {
        // delay setting the cache until update
        this.vnodeToCache = vnode;
        this.keyToCache = key;
      }

      vnode.data.keepAlive = true;
    }
    return vnode || (slot && slot[0])
  }
};

var builtInComponents = {
  KeepAlive: KeepAlive
};

/*  */

function initGlobalAPI (Vue) {
  // config
  var configDef = {};
  configDef.get = function () { return config; };
  if (true) {
    configDef.set = function () {
      warn(
        'Do not replace the Vue.config object, set individual fields instead.'
      );
    };
  }
  Object.defineProperty(Vue, 'config', configDef);

  // exposed util methods.
  // NOTE: these are not considered part of the public API - avoid relying on
  // them unless you are aware of the risk.
  Vue.util = {
    warn: warn,
    extend: extend,
    mergeOptions: mergeOptions,
    defineReactive: defineReactive$$1
  };

  Vue.set = set;
  Vue.delete = del;
  Vue.nextTick = nextTick;

  // 2.6 explicit observable API
  Vue.observable = function (obj) {
    observe(obj);
    return obj
  };

  Vue.options = Object.create(null);
  ASSET_TYPES.forEach(function (type) {
    Vue.options[type + 's'] = Object.create(null);
  });

  // this is used to identify the "base" constructor to extend all plain-object
  // components with in Weex's multi-instance scenarios.
  Vue.options._base = Vue;

  extend(Vue.options.components, builtInComponents);

  initUse(Vue);
  initMixin$1(Vue);
  initExtend(Vue);
  initAssetRegisters(Vue);
}

initGlobalAPI(Vue);

Object.defineProperty(Vue.prototype, '$isServer', {
  get: isServerRendering
});

Object.defineProperty(Vue.prototype, '$ssrContext', {
  get: function get () {
    /* istanbul ignore next */
    return this.$vnode && this.$vnode.ssrContext
  }
});

// expose FunctionalRenderContext for ssr runtime helper installation
Object.defineProperty(Vue, 'FunctionalRenderContext', {
  value: FunctionalRenderContext
});

Vue.version = '2.6.14';

/*  */

// these are reserved for web because they are directly compiled away
// during template compilation
var isReservedAttr = makeMap('style,class');

// attributes that should be using props for binding
var acceptValue = makeMap('input,textarea,option,select,progress');
var mustUseProp = function (tag, type, attr) {
  return (
    (attr === 'value' && acceptValue(tag)) && type !== 'button' ||
    (attr === 'selected' && tag === 'option') ||
    (attr === 'checked' && tag === 'input') ||
    (attr === 'muted' && tag === 'video')
  )
};

var isEnumeratedAttr = makeMap('contenteditable,draggable,spellcheck');

var isValidContentEditableValue = makeMap('events,caret,typing,plaintext-only');

var convertEnumeratedValue = function (key, value) {
  return isFalsyAttrValue(value) || value === 'false'
    ? 'false'
    // allow arbitrary string value for contenteditable
    : key === 'contenteditable' && isValidContentEditableValue(value)
      ? value
      : 'true'
};

var isBooleanAttr = makeMap(
  'allowfullscreen,async,autofocus,autoplay,checked,compact,controls,declare,' +
  'default,defaultchecked,defaultmuted,defaultselected,defer,disabled,' +
  'enabled,formnovalidate,hidden,indeterminate,inert,ismap,itemscope,loop,multiple,' +
  'muted,nohref,noresize,noshade,novalidate,nowrap,open,pauseonexit,readonly,' +
  'required,reversed,scoped,seamless,selected,sortable,' +
  'truespeed,typemustmatch,visible'
);

var xlinkNS = 'http://www.w3.org/1999/xlink';

var isXlink = function (name) {
  return name.charAt(5) === ':' && name.slice(0, 5) === 'xlink'
};

var getXlinkProp = function (name) {
  return isXlink(name) ? name.slice(6, name.length) : ''
};

var isFalsyAttrValue = function (val) {
  return val == null || val === false
};

/*  */

function genClassForVnode (vnode) {
  var data = vnode.data;
  var parentNode = vnode;
  var childNode = vnode;
  while (isDef(childNode.componentInstance)) {
    childNode = childNode.componentInstance._vnode;
    if (childNode && childNode.data) {
      data = mergeClassData(childNode.data, data);
    }
  }
  while (isDef(parentNode = parentNode.parent)) {
    if (parentNode && parentNode.data) {
      data = mergeClassData(data, parentNode.data);
    }
  }
  return renderClass(data.staticClass, data.class)
}

function mergeClassData (child, parent) {
  return {
    staticClass: concat(child.staticClass, parent.staticClass),
    class: isDef(child.class)
      ? [child.class, parent.class]
      : parent.class
  }
}

function renderClass (
  staticClass,
  dynamicClass
) {
  if (isDef(staticClass) || isDef(dynamicClass)) {
    return concat(staticClass, stringifyClass(dynamicClass))
  }
  /* istanbul ignore next */
  return ''
}

function concat (a, b) {
  return a ? b ? (a + ' ' + b) : a : (b || '')
}

function stringifyClass (value) {
  if (Array.isArray(value)) {
    return stringifyArray(value)
  }
  if (isObject(value)) {
    return stringifyObject(value)
  }
  if (typeof value === 'string') {
    return value
  }
  /* istanbul ignore next */
  return ''
}

function stringifyArray (value) {
  var res = '';
  var stringified;
  for (var i = 0, l = value.length; i < l; i++) {
    if (isDef(stringified = stringifyClass(value[i])) && stringified !== '') {
      if (res) { res += ' '; }
      res += stringified;
    }
  }
  return res
}

function stringifyObject (value) {
  var res = '';
  for (var key in value) {
    if (value[key]) {
      if (res) { res += ' '; }
      res += key;
    }
  }
  return res
}

/*  */

var namespaceMap = {
  svg: 'http://www.w3.org/2000/svg',
  math: 'http://www.w3.org/1998/Math/MathML'
};

var isHTMLTag = makeMap(
  'html,body,base,head,link,meta,style,title,' +
  'address,article,aside,footer,header,h1,h2,h3,h4,h5,h6,hgroup,nav,section,' +
  'div,dd,dl,dt,figcaption,figure,picture,hr,img,li,main,ol,p,pre,ul,' +
  'a,b,abbr,bdi,bdo,br,cite,code,data,dfn,em,i,kbd,mark,q,rp,rt,rtc,ruby,' +
  's,samp,small,span,strong,sub,sup,time,u,var,wbr,area,audio,map,track,video,' +
  'embed,object,param,source,canvas,script,noscript,del,ins,' +
  'caption,col,colgroup,table,thead,tbody,td,th,tr,' +
  'button,datalist,fieldset,form,input,label,legend,meter,optgroup,option,' +
  'output,progress,select,textarea,' +
  'details,dialog,menu,menuitem,summary,' +
  'content,element,shadow,template,blockquote,iframe,tfoot'
);

// this map is intentionally selective, only covering SVG elements that may
// contain child elements.
var isSVG = makeMap(
  'svg,animate,circle,clippath,cursor,defs,desc,ellipse,filter,font-face,' +
  'foreignobject,g,glyph,image,line,marker,mask,missing-glyph,path,pattern,' +
  'polygon,polyline,rect,switch,symbol,text,textpath,tspan,use,view',
  true
);

var isPreTag = function (tag) { return tag === 'pre'; };

var isReservedTag = function (tag) {
  return isHTMLTag(tag) || isSVG(tag)
};

function getTagNamespace (tag) {
  if (isSVG(tag)) {
    return 'svg'
  }
  // basic support for MathML
  // note it doesn't support other MathML elements being component roots
  if (tag === 'math') {
    return 'math'
  }
}

var unknownElementCache = Object.create(null);
function isUnknownElement (tag) {
  /* istanbul ignore if */
  if (!inBrowser) {
    return true
  }
  if (isReservedTag(tag)) {
    return false
  }
  tag = tag.toLowerCase();
  /* istanbul ignore if */
  if (unknownElementCache[tag] != null) {
    return unknownElementCache[tag]
  }
  var el = document.createElement(tag);
  if (tag.indexOf('-') > -1) {
    // http://stackoverflow.com/a/28210364/1070244
    return (unknownElementCache[tag] = (
      el.constructor === window.HTMLUnknownElement ||
      el.constructor === window.HTMLElement
    ))
  } else {
    return (unknownElementCache[tag] = /HTMLUnknownElement/.test(el.toString()))
  }
}

var isTextInputType = makeMap('text,number,password,search,email,tel,url');

/*  */

/**
 * Query an element selector if it's not an element already.
 */
function query (el) {
  if (typeof el === 'string') {
    var selected = document.querySelector(el);
    if (!selected) {
       true && warn(
        'Cannot find element: ' + el
      );
      return document.createElement('div')
    }
    return selected
  } else {
    return el
  }
}

/*  */

function createElement$1 (tagName, vnode) {
  var elm = document.createElement(tagName);
  if (tagName !== 'select') {
    return elm
  }
  // false or null will remove the attribute but undefined will not
  if (vnode.data && vnode.data.attrs && vnode.data.attrs.multiple !== undefined) {
    elm.setAttribute('multiple', 'multiple');
  }
  return elm
}

function createElementNS (namespace, tagName) {
  return document.createElementNS(namespaceMap[namespace], tagName)
}

function createTextNode (text) {
  return document.createTextNode(text)
}

function createComment (text) {
  return document.createComment(text)
}

function insertBefore (parentNode, newNode, referenceNode) {
  parentNode.insertBefore(newNode, referenceNode);
}

function removeChild (node, child) {
  node.removeChild(child);
}

function appendChild (node, child) {
  node.appendChild(child);
}

function parentNode (node) {
  return node.parentNode
}

function nextSibling (node) {
  return node.nextSibling
}

function tagName (node) {
  return node.tagName
}

function setTextContent (node, text) {
  node.textContent = text;
}

function setStyleScope (node, scopeId) {
  node.setAttribute(scopeId, '');
}

var nodeOps = /*#__PURE__*/Object.freeze({
  createElement: createElement$1,
  createElementNS: createElementNS,
  createTextNode: createTextNode,
  createComment: createComment,
  insertBefore: insertBefore,
  removeChild: removeChild,
  appendChild: appendChild,
  parentNode: parentNode,
  nextSibling: nextSibling,
  tagName: tagName,
  setTextContent: setTextContent,
  setStyleScope: setStyleScope
});

/*  */

var ref = {
  create: function create (_, vnode) {
    registerRef(vnode);
  },
  update: function update (oldVnode, vnode) {
    if (oldVnode.data.ref !== vnode.data.ref) {
      registerRef(oldVnode, true);
      registerRef(vnode);
    }
  },
  destroy: function destroy (vnode) {
    registerRef(vnode, true);
  }
};

function registerRef (vnode, isRemoval) {
  var key = vnode.data.ref;
  if (!isDef(key)) { return }

  var vm = vnode.context;
  var ref = vnode.componentInstance || vnode.elm;
  var refs = vm.$refs;
  if (isRemoval) {
    if (Array.isArray(refs[key])) {
      remove(refs[key], ref);
    } else if (refs[key] === ref) {
      refs[key] = undefined;
    }
  } else {
    if (vnode.data.refInFor) {
      if (!Array.isArray(refs[key])) {
        refs[key] = [ref];
      } else if (refs[key].indexOf(ref) < 0) {
        // $flow-disable-line
        refs[key].push(ref);
      }
    } else {
      refs[key] = ref;
    }
  }
}

/**
 * Virtual DOM patching algorithm based on Snabbdom by
 * Simon Friis Vindum (@paldepind)
 * Licensed under the MIT License
 * https://github.com/paldepind/snabbdom/blob/master/LICENSE
 *
 * modified by Evan You (@yyx990803)
 *
 * Not type-checking this because this file is perf-critical and the cost
 * of making flow understand it is not worth it.
 */

var emptyNode = new VNode('', {}, []);

var hooks = ['create', 'activate', 'update', 'remove', 'destroy'];

function sameVnode (a, b) {
  return (
    a.key === b.key &&
    a.asyncFactory === b.asyncFactory && (
      (
        a.tag === b.tag &&
        a.isComment === b.isComment &&
        isDef(a.data) === isDef(b.data) &&
        sameInputType(a, b)
      ) || (
        isTrue(a.isAsyncPlaceholder) &&
        isUndef(b.asyncFactory.error)
      )
    )
  )
}

function sameInputType (a, b) {
  if (a.tag !== 'input') { return true }
  var i;
  var typeA = isDef(i = a.data) && isDef(i = i.attrs) && i.type;
  var typeB = isDef(i = b.data) && isDef(i = i.attrs) && i.type;
  return typeA === typeB || isTextInputType(typeA) && isTextInputType(typeB)
}

function createKeyToOldIdx (children, beginIdx, endIdx) {
  var i, key;
  var map = {};
  for (i = beginIdx; i <= endIdx; ++i) {
    key = children[i].key;
    if (isDef(key)) { map[key] = i; }
  }
  return map
}

function createPatchFunction (backend) {
  var i, j;
  var cbs = {};

  var modules = backend.modules;
  var nodeOps = backend.nodeOps;

  for (i = 0; i < hooks.length; ++i) {
    cbs[hooks[i]] = [];
    for (j = 0; j < modules.length; ++j) {
      if (isDef(modules[j][hooks[i]])) {
        cbs[hooks[i]].push(modules[j][hooks[i]]);
      }
    }
  }

  function emptyNodeAt (elm) {
    return new VNode(nodeOps.tagName(elm).toLowerCase(), {}, [], undefined, elm)
  }

  function createRmCb (childElm, listeners) {
    function remove$$1 () {
      if (--remove$$1.listeners === 0) {
        removeNode(childElm);
      }
    }
    remove$$1.listeners = listeners;
    return remove$$1
  }

  function removeNode (el) {
    var parent = nodeOps.parentNode(el);
    // element may have already been removed due to v-html / v-text
    if (isDef(parent)) {
      nodeOps.removeChild(parent, el);
    }
  }

  function isUnknownElement$$1 (vnode, inVPre) {
    return (
      !inVPre &&
      !vnode.ns &&
      !(
        config.ignoredElements.length &&
        config.ignoredElements.some(function (ignore) {
          return isRegExp(ignore)
            ? ignore.test(vnode.tag)
            : ignore === vnode.tag
        })
      ) &&
      config.isUnknownElement(vnode.tag)
    )
  }

  var creatingElmInVPre = 0;

  function createElm (
    vnode,
    insertedVnodeQueue,
    parentElm,
    refElm,
    nested,
    ownerArray,
    index
  ) {
    if (isDef(vnode.elm) && isDef(ownerArray)) {
      // This vnode was used in a previous render!
      // now it's used as a new node, overwriting its elm would cause
      // potential patch errors down the road when it's used as an insertion
      // reference node. Instead, we clone the node on-demand before creating
      // associated DOM element for it.
      vnode = ownerArray[index] = cloneVNode(vnode);
    }

    vnode.isRootInsert = !nested; // for transition enter check
    if (createComponent(vnode, insertedVnodeQueue, parentElm, refElm)) {
      return
    }

    var data = vnode.data;
    var children = vnode.children;
    var tag = vnode.tag;
    if (isDef(tag)) {
      if (true) {
        if (data && data.pre) {
          creatingElmInVPre++;
        }
        if (isUnknownElement$$1(vnode, creatingElmInVPre)) {
          warn(
            'Unknown custom element: <' + tag + '> - did you ' +
            'register the component correctly? For recursive components, ' +
            'make sure to provide the "name" option.',
            vnode.context
          );
        }
      }

      vnode.elm = vnode.ns
        ? nodeOps.createElementNS(vnode.ns, tag)
        : nodeOps.createElement(tag, vnode);
      setScope(vnode);

      /* istanbul ignore if */
      {
        createChildren(vnode, children, insertedVnodeQueue);
        if (isDef(data)) {
          invokeCreateHooks(vnode, insertedVnodeQueue);
        }
        insert(parentElm, vnode.elm, refElm);
      }

      if ( true && data && data.pre) {
        creatingElmInVPre--;
      }
    } else if (isTrue(vnode.isComment)) {
      vnode.elm = nodeOps.createComment(vnode.text);
      insert(parentElm, vnode.elm, refElm);
    } else {
      vnode.elm = nodeOps.createTextNode(vnode.text);
      insert(parentElm, vnode.elm, refElm);
    }
  }

  function createComponent (vnode, insertedVnodeQueue, parentElm, refElm) {
    var i = vnode.data;
    if (isDef(i)) {
      var isReactivated = isDef(vnode.componentInstance) && i.keepAlive;
      if (isDef(i = i.hook) && isDef(i = i.init)) {
        i(vnode, false /* hydrating */);
      }
      // after calling the init hook, if the vnode is a child component
      // it should've created a child instance and mounted it. the child
      // component also has set the placeholder vnode's elm.
      // in that case we can just return the element and be done.
      if (isDef(vnode.componentInstance)) {
        initComponent(vnode, insertedVnodeQueue);
        insert(parentElm, vnode.elm, refElm);
        if (isTrue(isReactivated)) {
          reactivateComponent(vnode, insertedVnodeQueue, parentElm, refElm);
        }
        return true
      }
    }
  }

  function initComponent (vnode, insertedVnodeQueue) {
    if (isDef(vnode.data.pendingInsert)) {
      insertedVnodeQueue.push.apply(insertedVnodeQueue, vnode.data.pendingInsert);
      vnode.data.pendingInsert = null;
    }
    vnode.elm = vnode.componentInstance.$el;
    if (isPatchable(vnode)) {
      invokeCreateHooks(vnode, insertedVnodeQueue);
      setScope(vnode);
    } else {
      // empty component root.
      // skip all element-related modules except for ref (#3455)
      registerRef(vnode);
      // make sure to invoke the insert hook
      insertedVnodeQueue.push(vnode);
    }
  }

  function reactivateComponent (vnode, insertedVnodeQueue, parentElm, refElm) {
    var i;
    // hack for #4339: a reactivated component with inner transition
    // does not trigger because the inner node's created hooks are not called
    // again. It's not ideal to involve module-specific logic in here but
    // there doesn't seem to be a better way to do it.
    var innerNode = vnode;
    while (innerNode.componentInstance) {
      innerNode = innerNode.componentInstance._vnode;
      if (isDef(i = innerNode.data) && isDef(i = i.transition)) {
        for (i = 0; i < cbs.activate.length; ++i) {
          cbs.activate[i](emptyNode, innerNode);
        }
        insertedVnodeQueue.push(innerNode);
        break
      }
    }
    // unlike a newly created component,
    // a reactivated keep-alive component doesn't insert itself
    insert(parentElm, vnode.elm, refElm);
  }

  function insert (parent, elm, ref$$1) {
    if (isDef(parent)) {
      if (isDef(ref$$1)) {
        if (nodeOps.parentNode(ref$$1) === parent) {
          nodeOps.insertBefore(parent, elm, ref$$1);
        }
      } else {
        nodeOps.appendChild(parent, elm);
      }
    }
  }

  function createChildren (vnode, children, insertedVnodeQueue) {
    if (Array.isArray(children)) {
      if (true) {
        checkDuplicateKeys(children);
      }
      for (var i = 0; i < children.length; ++i) {
        createElm(children[i], insertedVnodeQueue, vnode.elm, null, true, children, i);
      }
    } else if (isPrimitive(vnode.text)) {
      nodeOps.appendChild(vnode.elm, nodeOps.createTextNode(String(vnode.text)));
    }
  }

  function isPatchable (vnode) {
    while (vnode.componentInstance) {
      vnode = vnode.componentInstance._vnode;
    }
    return isDef(vnode.tag)
  }

  function invokeCreateHooks (vnode, insertedVnodeQueue) {
    for (var i$1 = 0; i$1 < cbs.create.length; ++i$1) {
      cbs.create[i$1](emptyNode, vnode);
    }
    i = vnode.data.hook; // Reuse variable
    if (isDef(i)) {
      if (isDef(i.create)) { i.create(emptyNode, vnode); }
      if (isDef(i.insert)) { insertedVnodeQueue.push(vnode); }
    }
  }

  // set scope id attribute for scoped CSS.
  // this is implemented as a special case to avoid the overhead
  // of going through the normal attribute patching process.
  function setScope (vnode) {
    var i;
    if (isDef(i = vnode.fnScopeId)) {
      nodeOps.setStyleScope(vnode.elm, i);
    } else {
      var ancestor = vnode;
      while (ancestor) {
        if (isDef(i = ancestor.context) && isDef(i = i.$options._scopeId)) {
          nodeOps.setStyleScope(vnode.elm, i);
        }
        ancestor = ancestor.parent;
      }
    }
    // for slot content they should also get the scopeId from the host instance.
    if (isDef(i = activeInstance) &&
      i !== vnode.context &&
      i !== vnode.fnContext &&
      isDef(i = i.$options._scopeId)
    ) {
      nodeOps.setStyleScope(vnode.elm, i);
    }
  }

  function addVnodes (parentElm, refElm, vnodes, startIdx, endIdx, insertedVnodeQueue) {
    for (; startIdx <= endIdx; ++startIdx) {
      createElm(vnodes[startIdx], insertedVnodeQueue, parentElm, refElm, false, vnodes, startIdx);
    }
  }

  function invokeDestroyHook (vnode) {
    var i, j;
    var data = vnode.data;
    if (isDef(data)) {
      if (isDef(i = data.hook) && isDef(i = i.destroy)) { i(vnode); }
      for (i = 0; i < cbs.destroy.length; ++i) { cbs.destroy[i](vnode); }
    }
    if (isDef(i = vnode.children)) {
      for (j = 0; j < vnode.children.length; ++j) {
        invokeDestroyHook(vnode.children[j]);
      }
    }
  }

  function removeVnodes (vnodes, startIdx, endIdx) {
    for (; startIdx <= endIdx; ++startIdx) {
      var ch = vnodes[startIdx];
      if (isDef(ch)) {
        if (isDef(ch.tag)) {
          removeAndInvokeRemoveHook(ch);
          invokeDestroyHook(ch);
        } else { // Text node
          removeNode(ch.elm);
        }
      }
    }
  }

  function removeAndInvokeRemoveHook (vnode, rm) {
    if (isDef(rm) || isDef(vnode.data)) {
      var i;
      var listeners = cbs.remove.length + 1;
      if (isDef(rm)) {
        // we have a recursively passed down rm callback
        // increase the listeners count
        rm.listeners += listeners;
      } else {
        // directly removing
        rm = createRmCb(vnode.elm, listeners);
      }
      // recursively invoke hooks on child component root node
      if (isDef(i = vnode.componentInstance) && isDef(i = i._vnode) && isDef(i.data)) {
        removeAndInvokeRemoveHook(i, rm);
      }
      for (i = 0; i < cbs.remove.length; ++i) {
        cbs.remove[i](vnode, rm);
      }
      if (isDef(i = vnode.data.hook) && isDef(i = i.remove)) {
        i(vnode, rm);
      } else {
        rm();
      }
    } else {
      removeNode(vnode.elm);
    }
  }

  function updateChildren (parentElm, oldCh, newCh, insertedVnodeQueue, removeOnly) {
    var oldStartIdx = 0;
    var newStartIdx = 0;
    var oldEndIdx = oldCh.length - 1;
    var oldStartVnode = oldCh[0];
    var oldEndVnode = oldCh[oldEndIdx];
    var newEndIdx = newCh.length - 1;
    var newStartVnode = newCh[0];
    var newEndVnode = newCh[newEndIdx];
    var oldKeyToIdx, idxInOld, vnodeToMove, refElm;

    // removeOnly is a special flag used only by <transition-group>
    // to ensure removed elements stay in correct relative positions
    // during leaving transitions
    var canMove = !removeOnly;

    if (true) {
      checkDuplicateKeys(newCh);
    }

    while (oldStartIdx <= oldEndIdx && newStartIdx <= newEndIdx) {
      if (isUndef(oldStartVnode)) {
        oldStartVnode = oldCh[++oldStartIdx]; // Vnode has been moved left
      } else if (isUndef(oldEndVnode)) {
        oldEndVnode = oldCh[--oldEndIdx];
      } else if (sameVnode(oldStartVnode, newStartVnode)) {
        patchVnode(oldStartVnode, newStartVnode, insertedVnodeQueue, newCh, newStartIdx);
        oldStartVnode = oldCh[++oldStartIdx];
        newStartVnode = newCh[++newStartIdx];
      } else if (sameVnode(oldEndVnode, newEndVnode)) {
        patchVnode(oldEndVnode, newEndVnode, insertedVnodeQueue, newCh, newEndIdx);
        oldEndVnode = oldCh[--oldEndIdx];
        newEndVnode = newCh[--newEndIdx];
      } else if (sameVnode(oldStartVnode, newEndVnode)) { // Vnode moved right
        patchVnode(oldStartVnode, newEndVnode, insertedVnodeQueue, newCh, newEndIdx);
        canMove && nodeOps.insertBefore(parentElm, oldStartVnode.elm, nodeOps.nextSibling(oldEndVnode.elm));
        oldStartVnode = oldCh[++oldStartIdx];
        newEndVnode = newCh[--newEndIdx];
      } else if (sameVnode(oldEndVnode, newStartVnode)) { // Vnode moved left
        patchVnode(oldEndVnode, newStartVnode, insertedVnodeQueue, newCh, newStartIdx);
        canMove && nodeOps.insertBefore(parentElm, oldEndVnode.elm, oldStartVnode.elm);
        oldEndVnode = oldCh[--oldEndIdx];
        newStartVnode = newCh[++newStartIdx];
      } else {
        if (isUndef(oldKeyToIdx)) { oldKeyToIdx = createKeyToOldIdx(oldCh, oldStartIdx, oldEndIdx); }
        idxInOld = isDef(newStartVnode.key)
          ? oldKeyToIdx[newStartVnode.key]
          : findIdxInOld(newStartVnode, oldCh, oldStartIdx, oldEndIdx);
        if (isUndef(idxInOld)) { // New element
          createElm(newStartVnode, insertedVnodeQueue, parentElm, oldStartVnode.elm, false, newCh, newStartIdx);
        } else {
          vnodeToMove = oldCh[idxInOld];
          if (sameVnode(vnodeToMove, newStartVnode)) {
            patchVnode(vnodeToMove, newStartVnode, insertedVnodeQueue, newCh, newStartIdx);
            oldCh[idxInOld] = undefined;
            canMove && nodeOps.insertBefore(parentElm, vnodeToMove.elm, oldStartVnode.elm);
          } else {
            // same key but different element. treat as new element
            createElm(newStartVnode, insertedVnodeQueue, parentElm, oldStartVnode.elm, false, newCh, newStartIdx);
          }
        }
        newStartVnode = newCh[++newStartIdx];
      }
    }
    if (oldStartIdx > oldEndIdx) {
      refElm = isUndef(newCh[newEndIdx + 1]) ? null : newCh[newEndIdx + 1].elm;
      addVnodes(parentElm, refElm, newCh, newStartIdx, newEndIdx, insertedVnodeQueue);
    } else if (newStartIdx > newEndIdx) {
      removeVnodes(oldCh, oldStartIdx, oldEndIdx);
    }
  }

  function checkDuplicateKeys (children) {
    var seenKeys = {};
    for (var i = 0; i < children.length; i++) {
      var vnode = children[i];
      var key = vnode.key;
      if (isDef(key)) {
        if (seenKeys[key]) {
          warn(
            ("Duplicate keys detected: '" + key + "'. This may cause an update error."),
            vnode.context
          );
        } else {
          seenKeys[key] = true;
        }
      }
    }
  }

  function findIdxInOld (node, oldCh, start, end) {
    for (var i = start; i < end; i++) {
      var c = oldCh[i];
      if (isDef(c) && sameVnode(node, c)) { return i }
    }
  }

  function patchVnode (
    oldVnode,
    vnode,
    insertedVnodeQueue,
    ownerArray,
    index,
    removeOnly
  ) {
    if (oldVnode === vnode) {
      return
    }

    if (isDef(vnode.elm) && isDef(ownerArray)) {
      // clone reused vnode
      vnode = ownerArray[index] = cloneVNode(vnode);
    }

    var elm = vnode.elm = oldVnode.elm;

    if (isTrue(oldVnode.isAsyncPlaceholder)) {
      if (isDef(vnode.asyncFactory.resolved)) {
        hydrate(oldVnode.elm, vnode, insertedVnodeQueue);
      } else {
        vnode.isAsyncPlaceholder = true;
      }
      return
    }

    // reuse element for static trees.
    // note we only do this if the vnode is cloned -
    // if the new node is not cloned it means the render functions have been
    // reset by the hot-reload-api and we need to do a proper re-render.
    if (isTrue(vnode.isStatic) &&
      isTrue(oldVnode.isStatic) &&
      vnode.key === oldVnode.key &&
      (isTrue(vnode.isCloned) || isTrue(vnode.isOnce))
    ) {
      vnode.componentInstance = oldVnode.componentInstance;
      return
    }

    var i;
    var data = vnode.data;
    if (isDef(data) && isDef(i = data.hook) && isDef(i = i.prepatch)) {
      i(oldVnode, vnode);
    }

    var oldCh = oldVnode.children;
    var ch = vnode.children;
    if (isDef(data) && isPatchable(vnode)) {
      for (i = 0; i < cbs.update.length; ++i) { cbs.update[i](oldVnode, vnode); }
      if (isDef(i = data.hook) && isDef(i = i.update)) { i(oldVnode, vnode); }
    }
    if (isUndef(vnode.text)) {
      if (isDef(oldCh) && isDef(ch)) {
        if (oldCh !== ch) { updateChildren(elm, oldCh, ch, insertedVnodeQueue, removeOnly); }
      } else if (isDef(ch)) {
        if (true) {
          checkDuplicateKeys(ch);
        }
        if (isDef(oldVnode.text)) { nodeOps.setTextContent(elm, ''); }
        addVnodes(elm, null, ch, 0, ch.length - 1, insertedVnodeQueue);
      } else if (isDef(oldCh)) {
        removeVnodes(oldCh, 0, oldCh.length - 1);
      } else if (isDef(oldVnode.text)) {
        nodeOps.setTextContent(elm, '');
      }
    } else if (oldVnode.text !== vnode.text) {
      nodeOps.setTextContent(elm, vnode.text);
    }
    if (isDef(data)) {
      if (isDef(i = data.hook) && isDef(i = i.postpatch)) { i(oldVnode, vnode); }
    }
  }

  function invokeInsertHook (vnode, queue, initial) {
    // delay insert hooks for component root nodes, invoke them after the
    // element is really inserted
    if (isTrue(initial) && isDef(vnode.parent)) {
      vnode.parent.data.pendingInsert = queue;
    } else {
      for (var i = 0; i < queue.length; ++i) {
        queue[i].data.hook.insert(queue[i]);
      }
    }
  }

  var hydrationBailed = false;
  // list of modules that can skip create hook during hydration because they
  // are already rendered on the client or has no need for initialization
  // Note: style is excluded because it relies on initial clone for future
  // deep updates (#7063).
  var isRenderedModule = makeMap('attrs,class,staticClass,staticStyle,key');

  // Note: this is a browser-only function so we can assume elms are DOM nodes.
  function hydrate (elm, vnode, insertedVnodeQueue, inVPre) {
    var i;
    var tag = vnode.tag;
    var data = vnode.data;
    var children = vnode.children;
    inVPre = inVPre || (data && data.pre);
    vnode.elm = elm;

    if (isTrue(vnode.isComment) && isDef(vnode.asyncFactory)) {
      vnode.isAsyncPlaceholder = true;
      return true
    }
    // assert node match
    if (true) {
      if (!assertNodeMatch(elm, vnode, inVPre)) {
        return false
      }
    }
    if (isDef(data)) {
      if (isDef(i = data.hook) && isDef(i = i.init)) { i(vnode, true /* hydrating */); }
      if (isDef(i = vnode.componentInstance)) {
        // child component. it should have hydrated its own tree.
        initComponent(vnode, insertedVnodeQueue);
        return true
      }
    }
    if (isDef(tag)) {
      if (isDef(children)) {
        // empty element, allow client to pick up and populate children
        if (!elm.hasChildNodes()) {
          createChildren(vnode, children, insertedVnodeQueue);
        } else {
          // v-html and domProps: innerHTML
          if (isDef(i = data) && isDef(i = i.domProps) && isDef(i = i.innerHTML)) {
            if (i !== elm.innerHTML) {
              /* istanbul ignore if */
              if ( true &&
                typeof console !== 'undefined' &&
                !hydrationBailed
              ) {
                hydrationBailed = true;
                console.warn('Parent: ', elm);
                console.warn('server innerHTML: ', i);
                console.warn('client innerHTML: ', elm.innerHTML);
              }
              return false
            }
          } else {
            // iterate and compare children lists
            var childrenMatch = true;
            var childNode = elm.firstChild;
            for (var i$1 = 0; i$1 < children.length; i$1++) {
              if (!childNode || !hydrate(childNode, children[i$1], insertedVnodeQueue, inVPre)) {
                childrenMatch = false;
                break
              }
              childNode = childNode.nextSibling;
            }
            // if childNode is not null, it means the actual childNodes list is
            // longer than the virtual children list.
            if (!childrenMatch || childNode) {
              /* istanbul ignore if */
              if ( true &&
                typeof console !== 'undefined' &&
                !hydrationBailed
              ) {
                hydrationBailed = true;
                console.warn('Parent: ', elm);
                console.warn('Mismatching childNodes vs. VNodes: ', elm.childNodes, children);
              }
              return false
            }
          }
        }
      }
      if (isDef(data)) {
        var fullInvoke = false;
        for (var key in data) {
          if (!isRenderedModule(key)) {
            fullInvoke = true;
            invokeCreateHooks(vnode, insertedVnodeQueue);
            break
          }
        }
        if (!fullInvoke && data['class']) {
          // ensure collecting deps for deep class bindings for future updates
          traverse(data['class']);
        }
      }
    } else if (elm.data !== vnode.text) {
      elm.data = vnode.text;
    }
    return true
  }

  function assertNodeMatch (node, vnode, inVPre) {
    if (isDef(vnode.tag)) {
      return vnode.tag.indexOf('vue-component') === 0 || (
        !isUnknownElement$$1(vnode, inVPre) &&
        vnode.tag.toLowerCase() === (node.tagName && node.tagName.toLowerCase())
      )
    } else {
      return node.nodeType === (vnode.isComment ? 8 : 3)
    }
  }

  return function patch (oldVnode, vnode, hydrating, removeOnly) {
    if (isUndef(vnode)) {
      if (isDef(oldVnode)) { invokeDestroyHook(oldVnode); }
      return
    }

    var isInitialPatch = false;
    var insertedVnodeQueue = [];

    if (isUndef(oldVnode)) {
      // empty mount (likely as component), create new root element
      isInitialPatch = true;
      createElm(vnode, insertedVnodeQueue);
    } else {
      var isRealElement = isDef(oldVnode.nodeType);
      if (!isRealElement && sameVnode(oldVnode, vnode)) {
        // patch existing root node
        patchVnode(oldVnode, vnode, insertedVnodeQueue, null, null, removeOnly);
      } else {
        if (isRealElement) {
          // mounting to a real element
          // check if this is server-rendered content and if we can perform
          // a successful hydration.
          if (oldVnode.nodeType === 1 && oldVnode.hasAttribute(SSR_ATTR)) {
            oldVnode.removeAttribute(SSR_ATTR);
            hydrating = true;
          }
          if (isTrue(hydrating)) {
            if (hydrate(oldVnode, vnode, insertedVnodeQueue)) {
              invokeInsertHook(vnode, insertedVnodeQueue, true);
              return oldVnode
            } else if (true) {
              warn(
                'The client-side rendered virtual DOM tree is not matching ' +
                'server-rendered content. This is likely caused by incorrect ' +
                'HTML markup, for example nesting block-level elements inside ' +
                '<p>, or missing <tbody>. Bailing hydration and performing ' +
                'full client-side render.'
              );
            }
          }
          // either not server-rendered, or hydration failed.
          // create an empty node and replace it
          oldVnode = emptyNodeAt(oldVnode);
        }

        // replacing existing element
        var oldElm = oldVnode.elm;
        var parentElm = nodeOps.parentNode(oldElm);

        // create new node
        createElm(
          vnode,
          insertedVnodeQueue,
          // extremely rare edge case: do not insert if old element is in a
          // leaving transition. Only happens when combining transition +
          // keep-alive + HOCs. (#4590)
          oldElm._leaveCb ? null : parentElm,
          nodeOps.nextSibling(oldElm)
        );

        // update parent placeholder node element, recursively
        if (isDef(vnode.parent)) {
          var ancestor = vnode.parent;
          var patchable = isPatchable(vnode);
          while (ancestor) {
            for (var i = 0; i < cbs.destroy.length; ++i) {
              cbs.destroy[i](ancestor);
            }
            ancestor.elm = vnode.elm;
            if (patchable) {
              for (var i$1 = 0; i$1 < cbs.create.length; ++i$1) {
                cbs.create[i$1](emptyNode, ancestor);
              }
              // #6513
              // invoke insert hooks that may have been merged by create hooks.
              // e.g. for directives that uses the "inserted" hook.
              var insert = ancestor.data.hook.insert;
              if (insert.merged) {
                // start at index 1 to avoid re-invoking component mounted hook
                for (var i$2 = 1; i$2 < insert.fns.length; i$2++) {
                  insert.fns[i$2]();
                }
              }
            } else {
              registerRef(ancestor);
            }
            ancestor = ancestor.parent;
          }
        }

        // destroy old node
        if (isDef(parentElm)) {
          removeVnodes([oldVnode], 0, 0);
        } else if (isDef(oldVnode.tag)) {
          invokeDestroyHook(oldVnode);
        }
      }
    }

    invokeInsertHook(vnode, insertedVnodeQueue, isInitialPatch);
    return vnode.elm
  }
}

/*  */

var directives = {
  create: updateDirectives,
  update: updateDirectives,
  destroy: function unbindDirectives (vnode) {
    updateDirectives(vnode, emptyNode);
  }
};

function updateDirectives (oldVnode, vnode) {
  if (oldVnode.data.directives || vnode.data.directives) {
    _update(oldVnode, vnode);
  }
}

function _update (oldVnode, vnode) {
  var isCreate = oldVnode === emptyNode;
  var isDestroy = vnode === emptyNode;
  var oldDirs = normalizeDirectives$1(oldVnode.data.directives, oldVnode.context);
  var newDirs = normalizeDirectives$1(vnode.data.directives, vnode.context);

  var dirsWithInsert = [];
  var dirsWithPostpatch = [];

  var key, oldDir, dir;
  for (key in newDirs) {
    oldDir = oldDirs[key];
    dir = newDirs[key];
    if (!oldDir) {
      // new directive, bind
      callHook$1(dir, 'bind', vnode, oldVnode);
      if (dir.def && dir.def.inserted) {
        dirsWithInsert.push(dir);
      }
    } else {
      // existing directive, update
      dir.oldValue = oldDir.value;
      dir.oldArg = oldDir.arg;
      callHook$1(dir, 'update', vnode, oldVnode);
      if (dir.def && dir.def.componentUpdated) {
        dirsWithPostpatch.push(dir);
      }
    }
  }

  if (dirsWithInsert.length) {
    var callInsert = function () {
      for (var i = 0; i < dirsWithInsert.length; i++) {
        callHook$1(dirsWithInsert[i], 'inserted', vnode, oldVnode);
      }
    };
    if (isCreate) {
      mergeVNodeHook(vnode, 'insert', callInsert);
    } else {
      callInsert();
    }
  }

  if (dirsWithPostpatch.length) {
    mergeVNodeHook(vnode, 'postpatch', function () {
      for (var i = 0; i < dirsWithPostpatch.length; i++) {
        callHook$1(dirsWithPostpatch[i], 'componentUpdated', vnode, oldVnode);
      }
    });
  }

  if (!isCreate) {
    for (key in oldDirs) {
      if (!newDirs[key]) {
        // no longer present, unbind
        callHook$1(oldDirs[key], 'unbind', oldVnode, oldVnode, isDestroy);
      }
    }
  }
}

var emptyModifiers = Object.create(null);

function normalizeDirectives$1 (
  dirs,
  vm
) {
  var res = Object.create(null);
  if (!dirs) {
    // $flow-disable-line
    return res
  }
  var i, dir;
  for (i = 0; i < dirs.length; i++) {
    dir = dirs[i];
    if (!dir.modifiers) {
      // $flow-disable-line
      dir.modifiers = emptyModifiers;
    }
    res[getRawDirName(dir)] = dir;
    dir.def = resolveAsset(vm.$options, 'directives', dir.name, true);
  }
  // $flow-disable-line
  return res
}

function getRawDirName (dir) {
  return dir.rawName || ((dir.name) + "." + (Object.keys(dir.modifiers || {}).join('.')))
}

function callHook$1 (dir, hook, vnode, oldVnode, isDestroy) {
  var fn = dir.def && dir.def[hook];
  if (fn) {
    try {
      fn(vnode.elm, dir, vnode, oldVnode, isDestroy);
    } catch (e) {
      handleError(e, vnode.context, ("directive " + (dir.name) + " " + hook + " hook"));
    }
  }
}

var baseModules = [
  ref,
  directives
];

/*  */

function updateAttrs (oldVnode, vnode) {
  var opts = vnode.componentOptions;
  if (isDef(opts) && opts.Ctor.options.inheritAttrs === false) {
    return
  }
  if (isUndef(oldVnode.data.attrs) && isUndef(vnode.data.attrs)) {
    return
  }
  var key, cur, old;
  var elm = vnode.elm;
  var oldAttrs = oldVnode.data.attrs || {};
  var attrs = vnode.data.attrs || {};
  // clone observed objects, as the user probably wants to mutate it
  if (isDef(attrs.__ob__)) {
    attrs = vnode.data.attrs = extend({}, attrs);
  }

  for (key in attrs) {
    cur = attrs[key];
    old = oldAttrs[key];
    if (old !== cur) {
      setAttr(elm, key, cur, vnode.data.pre);
    }
  }
  // #4391: in IE9, setting type can reset value for input[type=radio]
  // #6666: IE/Edge forces progress value down to 1 before setting a max
  /* istanbul ignore if */
  if ((isIE || isEdge) && attrs.value !== oldAttrs.value) {
    setAttr(elm, 'value', attrs.value);
  }
  for (key in oldAttrs) {
    if (isUndef(attrs[key])) {
      if (isXlink(key)) {
        elm.removeAttributeNS(xlinkNS, getXlinkProp(key));
      } else if (!isEnumeratedAttr(key)) {
        elm.removeAttribute(key);
      }
    }
  }
}

function setAttr (el, key, value, isInPre) {
  if (isInPre || el.tagName.indexOf('-') > -1) {
    baseSetAttr(el, key, value);
  } else if (isBooleanAttr(key)) {
    // set attribute for blank value
    // e.g. <option disabled>Select one</option>
    if (isFalsyAttrValue(value)) {
      el.removeAttribute(key);
    } else {
      // technically allowfullscreen is a boolean attribute for <iframe>,
      // but Flash expects a value of "true" when used on <embed> tag
      value = key === 'allowfullscreen' && el.tagName === 'EMBED'
        ? 'true'
        : key;
      el.setAttribute(key, value);
    }
  } else if (isEnumeratedAttr(key)) {
    el.setAttribute(key, convertEnumeratedValue(key, value));
  } else if (isXlink(key)) {
    if (isFalsyAttrValue(value)) {
      el.removeAttributeNS(xlinkNS, getXlinkProp(key));
    } else {
      el.setAttributeNS(xlinkNS, key, value);
    }
  } else {
    baseSetAttr(el, key, value);
  }
}

function baseSetAttr (el, key, value) {
  if (isFalsyAttrValue(value)) {
    el.removeAttribute(key);
  } else {
    // #7138: IE10 & 11 fires input event when setting placeholder on
    // <textarea>... block the first input event and remove the blocker
    // immediately.
    /* istanbul ignore if */
    if (
      isIE && !isIE9 &&
      el.tagName === 'TEXTAREA' &&
      key === 'placeholder' && value !== '' && !el.__ieph
    ) {
      var blocker = function (e) {
        e.stopImmediatePropagation();
        el.removeEventListener('input', blocker);
      };
      el.addEventListener('input', blocker);
      // $flow-disable-line
      el.__ieph = true; /* IE placeholder patched */
    }
    el.setAttribute(key, value);
  }
}

var attrs = {
  create: updateAttrs,
  update: updateAttrs
};

/*  */

function updateClass (oldVnode, vnode) {
  var el = vnode.elm;
  var data = vnode.data;
  var oldData = oldVnode.data;
  if (
    isUndef(data.staticClass) &&
    isUndef(data.class) && (
      isUndef(oldData) || (
        isUndef(oldData.staticClass) &&
        isUndef(oldData.class)
      )
    )
  ) {
    return
  }

  var cls = genClassForVnode(vnode);

  // handle transition classes
  var transitionClass = el._transitionClasses;
  if (isDef(transitionClass)) {
    cls = concat(cls, stringifyClass(transitionClass));
  }

  // set the class
  if (cls !== el._prevClass) {
    el.setAttribute('class', cls);
    el._prevClass = cls;
  }
}

var klass = {
  create: updateClass,
  update: updateClass
};

/*  */

var validDivisionCharRE = /[\w).+\-_$\]]/;

function parseFilters (exp) {
  var inSingle = false;
  var inDouble = false;
  var inTemplateString = false;
  var inRegex = false;
  var curly = 0;
  var square = 0;
  var paren = 0;
  var lastFilterIndex = 0;
  var c, prev, i, expression, filters;

  for (i = 0; i < exp.length; i++) {
    prev = c;
    c = exp.charCodeAt(i);
    if (inSingle) {
      if (c === 0x27 && prev !== 0x5C) { inSingle = false; }
    } else if (inDouble) {
      if (c === 0x22 && prev !== 0x5C) { inDouble = false; }
    } else if (inTemplateString) {
      if (c === 0x60 && prev !== 0x5C) { inTemplateString = false; }
    } else if (inRegex) {
      if (c === 0x2f && prev !== 0x5C) { inRegex = false; }
    } else if (
      c === 0x7C && // pipe
      exp.charCodeAt(i + 1) !== 0x7C &&
      exp.charCodeAt(i - 1) !== 0x7C &&
      !curly && !square && !paren
    ) {
      if (expression === undefined) {
        // first filter, end of expression
        lastFilterIndex = i + 1;
        expression = exp.slice(0, i).trim();
      } else {
        pushFilter();
      }
    } else {
      switch (c) {
        case 0x22: inDouble = true; break         // "
        case 0x27: inSingle = true; break         // '
        case 0x60: inTemplateString = true; break // `
        case 0x28: paren++; break                 // (
        case 0x29: paren--; break                 // )
        case 0x5B: square++; break                // [
        case 0x5D: square--; break                // ]
        case 0x7B: curly++; break                 // {
        case 0x7D: curly--; break                 // }
      }
      if (c === 0x2f) { // /
        var j = i - 1;
        var p = (void 0);
        // find first non-whitespace prev char
        for (; j >= 0; j--) {
          p = exp.charAt(j);
          if (p !== ' ') { break }
        }
        if (!p || !validDivisionCharRE.test(p)) {
          inRegex = true;
        }
      }
    }
  }

  if (expression === undefined) {
    expression = exp.slice(0, i).trim();
  } else if (lastFilterIndex !== 0) {
    pushFilter();
  }

  function pushFilter () {
    (filters || (filters = [])).push(exp.slice(lastFilterIndex, i).trim());
    lastFilterIndex = i + 1;
  }

  if (filters) {
    for (i = 0; i < filters.length; i++) {
      expression = wrapFilter(expression, filters[i]);
    }
  }

  return expression
}

function wrapFilter (exp, filter) {
  var i = filter.indexOf('(');
  if (i < 0) {
    // _f: resolveFilter
    return ("_f(\"" + filter + "\")(" + exp + ")")
  } else {
    var name = filter.slice(0, i);
    var args = filter.slice(i + 1);
    return ("_f(\"" + name + "\")(" + exp + (args !== ')' ? ',' + args : args))
  }
}

/*  */



/* eslint-disable no-unused-vars */
function baseWarn (msg, range) {
  console.error(("[Vue compiler]: " + msg));
}
/* eslint-enable no-unused-vars */

function pluckModuleFunction (
  modules,
  key
) {
  return modules
    ? modules.map(function (m) { return m[key]; }).filter(function (_) { return _; })
    : []
}

function addProp (el, name, value, range, dynamic) {
  (el.props || (el.props = [])).push(rangeSetItem({ name: name, value: value, dynamic: dynamic }, range));
  el.plain = false;
}

function addAttr (el, name, value, range, dynamic) {
  var attrs = dynamic
    ? (el.dynamicAttrs || (el.dynamicAttrs = []))
    : (el.attrs || (el.attrs = []));
  attrs.push(rangeSetItem({ name: name, value: value, dynamic: dynamic }, range));
  el.plain = false;
}

// add a raw attr (use this in preTransforms)
function addRawAttr (el, name, value, range) {
  el.attrsMap[name] = value;
  el.attrsList.push(rangeSetItem({ name: name, value: value }, range));
}

function addDirective (
  el,
  name,
  rawName,
  value,
  arg,
  isDynamicArg,
  modifiers,
  range
) {
  (el.directives || (el.directives = [])).push(rangeSetItem({
    name: name,
    rawName: rawName,
    value: value,
    arg: arg,
    isDynamicArg: isDynamicArg,
    modifiers: modifiers
  }, range));
  el.plain = false;
}

function prependModifierMarker (symbol, name, dynamic) {
  return dynamic
    ? ("_p(" + name + ",\"" + symbol + "\")")
    : symbol + name // mark the event as captured
}

function addHandler (
  el,
  name,
  value,
  modifiers,
  important,
  warn,
  range,
  dynamic
) {
  modifiers = modifiers || emptyObject;
  // warn prevent and passive modifier
  /* istanbul ignore if */
  if (
     true && warn &&
    modifiers.prevent && modifiers.passive
  ) {
    warn(
      'passive and prevent can\'t be used together. ' +
      'Passive handler can\'t prevent default event.',
      range
    );
  }

  // normalize click.right and click.middle since they don't actually fire
  // this is technically browser-specific, but at least for now browsers are
  // the only target envs that have right/middle clicks.
  if (modifiers.right) {
    if (dynamic) {
      name = "(" + name + ")==='click'?'contextmenu':(" + name + ")";
    } else if (name === 'click') {
      name = 'contextmenu';
      delete modifiers.right;
    }
  } else if (modifiers.middle) {
    if (dynamic) {
      name = "(" + name + ")==='click'?'mouseup':(" + name + ")";
    } else if (name === 'click') {
      name = 'mouseup';
    }
  }

  // check capture modifier
  if (modifiers.capture) {
    delete modifiers.capture;
    name = prependModifierMarker('!', name, dynamic);
  }
  if (modifiers.once) {
    delete modifiers.once;
    name = prependModifierMarker('~', name, dynamic);
  }
  /* istanbul ignore if */
  if (modifiers.passive) {
    delete modifiers.passive;
    name = prependModifierMarker('&', name, dynamic);
  }

  var events;
  if (modifiers.native) {
    delete modifiers.native;
    events = el.nativeEvents || (el.nativeEvents = {});
  } else {
    events = el.events || (el.events = {});
  }

  var newHandler = rangeSetItem({ value: value.trim(), dynamic: dynamic }, range);
  if (modifiers !== emptyObject) {
    newHandler.modifiers = modifiers;
  }

  var handlers = events[name];
  /* istanbul ignore if */
  if (Array.isArray(handlers)) {
    important ? handlers.unshift(newHandler) : handlers.push(newHandler);
  } else if (handlers) {
    events[name] = important ? [newHandler, handlers] : [handlers, newHandler];
  } else {
    events[name] = newHandler;
  }

  el.plain = false;
}

function getRawBindingAttr (
  el,
  name
) {
  return el.rawAttrsMap[':' + name] ||
    el.rawAttrsMap['v-bind:' + name] ||
    el.rawAttrsMap[name]
}

function getBindingAttr (
  el,
  name,
  getStatic
) {
  var dynamicValue =
    getAndRemoveAttr(el, ':' + name) ||
    getAndRemoveAttr(el, 'v-bind:' + name);
  if (dynamicValue != null) {
    return parseFilters(dynamicValue)
  } else if (getStatic !== false) {
    var staticValue = getAndRemoveAttr(el, name);
    if (staticValue != null) {
      return JSON.stringify(staticValue)
    }
  }
}

// note: this only removes the attr from the Array (attrsList) so that it
// doesn't get processed by processAttrs.
// By default it does NOT remove it from the map (attrsMap) because the map is
// needed during codegen.
function getAndRemoveAttr (
  el,
  name,
  removeFromMap
) {
  var val;
  if ((val = el.attrsMap[name]) != null) {
    var list = el.attrsList;
    for (var i = 0, l = list.length; i < l; i++) {
      if (list[i].name === name) {
        list.splice(i, 1);
        break
      }
    }
  }
  if (removeFromMap) {
    delete el.attrsMap[name];
  }
  return val
}

function getAndRemoveAttrByRegex (
  el,
  name
) {
  var list = el.attrsList;
  for (var i = 0, l = list.length; i < l; i++) {
    var attr = list[i];
    if (name.test(attr.name)) {
      list.splice(i, 1);
      return attr
    }
  }
}

function rangeSetItem (
  item,
  range
) {
  if (range) {
    if (range.start != null) {
      item.start = range.start;
    }
    if (range.end != null) {
      item.end = range.end;
    }
  }
  return item
}

/*  */

/**
 * Cross-platform code generation for component v-model
 */
function genComponentModel (
  el,
  value,
  modifiers
) {
  var ref = modifiers || {};
  var number = ref.number;
  var trim = ref.trim;

  var baseValueExpression = '$$v';
  var valueExpression = baseValueExpression;
  if (trim) {
    valueExpression =
      "(typeof " + baseValueExpression + " === 'string'" +
      "? " + baseValueExpression + ".trim()" +
      ": " + baseValueExpression + ")";
  }
  if (number) {
    valueExpression = "_n(" + valueExpression + ")";
  }
  var assignment = genAssignmentCode(value, valueExpression);

  el.model = {
    value: ("(" + value + ")"),
    expression: JSON.stringify(value),
    callback: ("function (" + baseValueExpression + ") {" + assignment + "}")
  };
}

/**
 * Cross-platform codegen helper for generating v-model value assignment code.
 */
function genAssignmentCode (
  value,
  assignment
) {
  var res = parseModel(value);
  if (res.key === null) {
    return (value + "=" + assignment)
  } else {
    return ("$set(" + (res.exp) + ", " + (res.key) + ", " + assignment + ")")
  }
}

/**
 * Parse a v-model expression into a base path and a final key segment.
 * Handles both dot-path and possible square brackets.
 *
 * Possible cases:
 *
 * - test
 * - test[key]
 * - test[test1[key]]
 * - test["a"][key]
 * - xxx.test[a[a].test1[key]]
 * - test.xxx.a["asa"][test1[key]]
 *
 */

var len, str, chr, index$1, expressionPos, expressionEndPos;



function parseModel (val) {
  // Fix https://github.com/vuejs/vue/pull/7730
  // allow v-model="obj.val " (trailing whitespace)
  val = val.trim();
  len = val.length;

  if (val.indexOf('[') < 0 || val.lastIndexOf(']') < len - 1) {
    index$1 = val.lastIndexOf('.');
    if (index$1 > -1) {
      return {
        exp: val.slice(0, index$1),
        key: '"' + val.slice(index$1 + 1) + '"'
      }
    } else {
      return {
        exp: val,
        key: null
      }
    }
  }

  str = val;
  index$1 = expressionPos = expressionEndPos = 0;

  while (!eof()) {
    chr = next();
    /* istanbul ignore if */
    if (isStringStart(chr)) {
      parseString(chr);
    } else if (chr === 0x5B) {
      parseBracket(chr);
    }
  }

  return {
    exp: val.slice(0, expressionPos),
    key: val.slice(expressionPos + 1, expressionEndPos)
  }
}

function next () {
  return str.charCodeAt(++index$1)
}

function eof () {
  return index$1 >= len
}

function isStringStart (chr) {
  return chr === 0x22 || chr === 0x27
}

function parseBracket (chr) {
  var inBracket = 1;
  expressionPos = index$1;
  while (!eof()) {
    chr = next();
    if (isStringStart(chr)) {
      parseString(chr);
      continue
    }
    if (chr === 0x5B) { inBracket++; }
    if (chr === 0x5D) { inBracket--; }
    if (inBracket === 0) {
      expressionEndPos = index$1;
      break
    }
  }
}

function parseString (chr) {
  var stringQuote = chr;
  while (!eof()) {
    chr = next();
    if (chr === stringQuote) {
      break
    }
  }
}

/*  */

var warn$1;

// in some cases, the event used has to be determined at runtime
// so we used some reserved tokens during compile.
var RANGE_TOKEN = '__r';
var CHECKBOX_RADIO_TOKEN = '__c';

function model (
  el,
  dir,
  _warn
) {
  warn$1 = _warn;
  var value = dir.value;
  var modifiers = dir.modifiers;
  var tag = el.tag;
  var type = el.attrsMap.type;

  if (true) {
    // inputs with type="file" are read only and setting the input's
    // value will throw an error.
    if (tag === 'input' && type === 'file') {
      warn$1(
        "<" + (el.tag) + " v-model=\"" + value + "\" type=\"file\">:\n" +
        "File inputs are read only. Use a v-on:change listener instead.",
        el.rawAttrsMap['v-model']
      );
    }
  }

  if (el.component) {
    genComponentModel(el, value, modifiers);
    // component v-model doesn't need extra runtime
    return false
  } else if (tag === 'select') {
    genSelect(el, value, modifiers);
  } else if (tag === 'input' && type === 'checkbox') {
    genCheckboxModel(el, value, modifiers);
  } else if (tag === 'input' && type === 'radio') {
    genRadioModel(el, value, modifiers);
  } else if (tag === 'input' || tag === 'textarea') {
    genDefaultModel(el, value, modifiers);
  } else if (!config.isReservedTag(tag)) {
    genComponentModel(el, value, modifiers);
    // component v-model doesn't need extra runtime
    return false
  } else if (true) {
    warn$1(
      "<" + (el.tag) + " v-model=\"" + value + "\">: " +
      "v-model is not supported on this element type. " +
      'If you are working with contenteditable, it\'s recommended to ' +
      'wrap a library dedicated for that purpose inside a custom component.',
      el.rawAttrsMap['v-model']
    );
  }

  // ensure runtime directive metadata
  return true
}

function genCheckboxModel (
  el,
  value,
  modifiers
) {
  var number = modifiers && modifiers.number;
  var valueBinding = getBindingAttr(el, 'value') || 'null';
  var trueValueBinding = getBindingAttr(el, 'true-value') || 'true';
  var falseValueBinding = getBindingAttr(el, 'false-value') || 'false';
  addProp(el, 'checked',
    "Array.isArray(" + value + ")" +
    "?_i(" + value + "," + valueBinding + ")>-1" + (
      trueValueBinding === 'true'
        ? (":(" + value + ")")
        : (":_q(" + value + "," + trueValueBinding + ")")
    )
  );
  addHandler(el, 'change',
    "var $$a=" + value + "," +
        '$$el=$event.target,' +
        "$$c=$$el.checked?(" + trueValueBinding + "):(" + falseValueBinding + ");" +
    'if(Array.isArray($$a)){' +
      "var $$v=" + (number ? '_n(' + valueBinding + ')' : valueBinding) + "," +
          '$$i=_i($$a,$$v);' +
      "if($$el.checked){$$i<0&&(" + (genAssignmentCode(value, '$$a.concat([$$v])')) + ")}" +
      "else{$$i>-1&&(" + (genAssignmentCode(value, '$$a.slice(0,$$i).concat($$a.slice($$i+1))')) + ")}" +
    "}else{" + (genAssignmentCode(value, '$$c')) + "}",
    null, true
  );
}

function genRadioModel (
  el,
  value,
  modifiers
) {
  var number = modifiers && modifiers.number;
  var valueBinding = getBindingAttr(el, 'value') || 'null';
  valueBinding = number ? ("_n(" + valueBinding + ")") : valueBinding;
  addProp(el, 'checked', ("_q(" + value + "," + valueBinding + ")"));
  addHandler(el, 'change', genAssignmentCode(value, valueBinding), null, true);
}

function genSelect (
  el,
  value,
  modifiers
) {
  var number = modifiers && modifiers.number;
  var selectedVal = "Array.prototype.filter" +
    ".call($event.target.options,function(o){return o.selected})" +
    ".map(function(o){var val = \"_value\" in o ? o._value : o.value;" +
    "return " + (number ? '_n(val)' : 'val') + "})";

  var assignment = '$event.target.multiple ? $$selectedVal : $$selectedVal[0]';
  var code = "var $$selectedVal = " + selectedVal + ";";
  code = code + " " + (genAssignmentCode(value, assignment));
  addHandler(el, 'change', code, null, true);
}

function genDefaultModel (
  el,
  value,
  modifiers
) {
  var type = el.attrsMap.type;

  // warn if v-bind:value conflicts with v-model
  // except for inputs with v-bind:type
  if (true) {
    var value$1 = el.attrsMap['v-bind:value'] || el.attrsMap[':value'];
    var typeBinding = el.attrsMap['v-bind:type'] || el.attrsMap[':type'];
    if (value$1 && !typeBinding) {
      var binding = el.attrsMap['v-bind:value'] ? 'v-bind:value' : ':value';
      warn$1(
        binding + "=\"" + value$1 + "\" conflicts with v-model on the same element " +
        'because the latter already expands to a value binding internally',
        el.rawAttrsMap[binding]
      );
    }
  }

  var ref = modifiers || {};
  var lazy = ref.lazy;
  var number = ref.number;
  var trim = ref.trim;
  var needCompositionGuard = !lazy && type !== 'range';
  var event = lazy
    ? 'change'
    : type === 'range'
      ? RANGE_TOKEN
      : 'input';

  var valueExpression = '$event.target.value';
  if (trim) {
    valueExpression = "$event.target.value.trim()";
  }
  if (number) {
    valueExpression = "_n(" + valueExpression + ")";
  }

  var code = genAssignmentCode(value, valueExpression);
  if (needCompositionGuard) {
    code = "if($event.target.composing)return;" + code;
  }

  addProp(el, 'value', ("(" + value + ")"));
  addHandler(el, event, code, null, true);
  if (trim || number) {
    addHandler(el, 'blur', '$forceUpdate()');
  }
}

/*  */

// normalize v-model event tokens that can only be determined at runtime.
// it's important to place the event as the first in the array because
// the whole point is ensuring the v-model callback gets called before
// user-attached handlers.
function normalizeEvents (on) {
  /* istanbul ignore if */
  if (isDef(on[RANGE_TOKEN])) {
    // IE input[type=range] only supports `change` event
    var event = isIE ? 'change' : 'input';
    on[event] = [].concat(on[RANGE_TOKEN], on[event] || []);
    delete on[RANGE_TOKEN];
  }
  // This was originally intended to fix #4521 but no longer necessary
  // after 2.5. Keeping it for backwards compat with generated code from < 2.4
  /* istanbul ignore if */
  if (isDef(on[CHECKBOX_RADIO_TOKEN])) {
    on.change = [].concat(on[CHECKBOX_RADIO_TOKEN], on.change || []);
    delete on[CHECKBOX_RADIO_TOKEN];
  }
}

var target$1;

function createOnceHandler$1 (event, handler, capture) {
  var _target = target$1; // save current target element in closure
  return function onceHandler () {
    var res = handler.apply(null, arguments);
    if (res !== null) {
      remove$2(event, onceHandler, capture, _target);
    }
  }
}

// #9446: Firefox <= 53 (in particular, ESR 52) has incorrect Event.timeStamp
// implementation and does not fire microtasks in between event propagation, so
// safe to exclude.
var useMicrotaskFix = isUsingMicroTask && !(isFF && Number(isFF[1]) <= 53);

function add$1 (
  name,
  handler,
  capture,
  passive
) {
  // async edge case #6566: inner click event triggers patch, event handler
  // attached to outer element during patch, and triggered again. This
  // happens because browsers fire microtask ticks between event propagation.
  // the solution is simple: we save the timestamp when a handler is attached,
  // and the handler would only fire if the event passed to it was fired
  // AFTER it was attached.
  if (useMicrotaskFix) {
    var attachedTimestamp = currentFlushTimestamp;
    var original = handler;
    handler = original._wrapper = function (e) {
      if (
        // no bubbling, should always fire.
        // this is just a safety net in case event.timeStamp is unreliable in
        // certain weird environments...
        e.target === e.currentTarget ||
        // event is fired after handler attachment
        e.timeStamp >= attachedTimestamp ||
        // bail for environments that have buggy event.timeStamp implementations
        // #9462 iOS 9 bug: event.timeStamp is 0 after history.pushState
        // #9681 QtWebEngine event.timeStamp is negative value
        e.timeStamp <= 0 ||
        // #9448 bail if event is fired in another document in a multi-page
        // electron/nw.js app, since event.timeStamp will be using a different
        // starting reference
        e.target.ownerDocument !== document
      ) {
        return original.apply(this, arguments)
      }
    };
  }
  target$1.addEventListener(
    name,
    handler,
    supportsPassive
      ? { capture: capture, passive: passive }
      : capture
  );
}

function remove$2 (
  name,
  handler,
  capture,
  _target
) {
  (_target || target$1).removeEventListener(
    name,
    handler._wrapper || handler,
    capture
  );
}

function updateDOMListeners (oldVnode, vnode) {
  if (isUndef(oldVnode.data.on) && isUndef(vnode.data.on)) {
    return
  }
  var on = vnode.data.on || {};
  var oldOn = oldVnode.data.on || {};
  target$1 = vnode.elm;
  normalizeEvents(on);
  updateListeners(on, oldOn, add$1, remove$2, createOnceHandler$1, vnode.context);
  target$1 = undefined;
}

var events = {
  create: updateDOMListeners,
  update: updateDOMListeners
};

/*  */

var svgContainer;

function updateDOMProps (oldVnode, vnode) {
  if (isUndef(oldVnode.data.domProps) && isUndef(vnode.data.domProps)) {
    return
  }
  var key, cur;
  var elm = vnode.elm;
  var oldProps = oldVnode.data.domProps || {};
  var props = vnode.data.domProps || {};
  // clone observed objects, as the user probably wants to mutate it
  if (isDef(props.__ob__)) {
    props = vnode.data.domProps = extend({}, props);
  }

  for (key in oldProps) {
    if (!(key in props)) {
      elm[key] = '';
    }
  }

  for (key in props) {
    cur = props[key];
    // ignore children if the node has textContent or innerHTML,
    // as these will throw away existing DOM nodes and cause removal errors
    // on subsequent patches (#3360)
    if (key === 'textContent' || key === 'innerHTML') {
      if (vnode.children) { vnode.children.length = 0; }
      if (cur === oldProps[key]) { continue }
      // #6601 work around Chrome version <= 55 bug where single textNode
      // replaced by innerHTML/textContent retains its parentNode property
      if (elm.childNodes.length === 1) {
        elm.removeChild(elm.childNodes[0]);
      }
    }

    if (key === 'value' && elm.tagName !== 'PROGRESS') {
      // store value as _value as well since
      // non-string values will be stringified
      elm._value = cur;
      // avoid resetting cursor position when value is the same
      var strCur = isUndef(cur) ? '' : String(cur);
      if (shouldUpdateValue(elm, strCur)) {
        elm.value = strCur;
      }
    } else if (key === 'innerHTML' && isSVG(elm.tagName) && isUndef(elm.innerHTML)) {
      // IE doesn't support innerHTML for SVG elements
      svgContainer = svgContainer || document.createElement('div');
      svgContainer.innerHTML = "<svg>" + cur + "</svg>";
      var svg = svgContainer.firstChild;
      while (elm.firstChild) {
        elm.removeChild(elm.firstChild);
      }
      while (svg.firstChild) {
        elm.appendChild(svg.firstChild);
      }
    } else if (
      // skip the update if old and new VDOM state is the same.
      // `value` is handled separately because the DOM value may be temporarily
      // out of sync with VDOM state due to focus, composition and modifiers.
      // This  #4521 by skipping the unnecessary `checked` update.
      cur !== oldProps[key]
    ) {
      // some property updates can throw
      // e.g. `value` on <progress> w/ non-finite value
      try {
        elm[key] = cur;
      } catch (e) {}
    }
  }
}

// check platforms/web/util/attrs.js acceptValue


function shouldUpdateValue (elm, checkVal) {
  return (!elm.composing && (
    elm.tagName === 'OPTION' ||
    isNotInFocusAndDirty(elm, checkVal) ||
    isDirtyWithModifiers(elm, checkVal)
  ))
}

function isNotInFocusAndDirty (elm, checkVal) {
  // return true when textbox (.number and .trim) loses focus and its value is
  // not equal to the updated value
  var notInFocus = true;
  // #6157
  // work around IE bug when accessing document.activeElement in an iframe
  try { notInFocus = document.activeElement !== elm; } catch (e) {}
  return notInFocus && elm.value !== checkVal
}

function isDirtyWithModifiers (elm, newVal) {
  var value = elm.value;
  var modifiers = elm._vModifiers; // injected by v-model runtime
  if (isDef(modifiers)) {
    if (modifiers.number) {
      return toNumber(value) !== toNumber(newVal)
    }
    if (modifiers.trim) {
      return value.trim() !== newVal.trim()
    }
  }
  return value !== newVal
}

var domProps = {
  create: updateDOMProps,
  update: updateDOMProps
};

/*  */

var parseStyleText = cached(function (cssText) {
  var res = {};
  var listDelimiter = /;(?![^(]*\))/g;
  var propertyDelimiter = /:(.+)/;
  cssText.split(listDelimiter).forEach(function (item) {
    if (item) {
      var tmp = item.split(propertyDelimiter);
      tmp.length > 1 && (res[tmp[0].trim()] = tmp[1].trim());
    }
  });
  return res
});

// merge static and dynamic style data on the same vnode
function normalizeStyleData (data) {
  var style = normalizeStyleBinding(data.style);
  // static style is pre-processed into an object during compilation
  // and is always a fresh object, so it's safe to merge into it
  return data.staticStyle
    ? extend(data.staticStyle, style)
    : style
}

// normalize possible array / string values into Object
function normalizeStyleBinding (bindingStyle) {
  if (Array.isArray(bindingStyle)) {
    return toObject(bindingStyle)
  }
  if (typeof bindingStyle === 'string') {
    return parseStyleText(bindingStyle)
  }
  return bindingStyle
}

/**
 * parent component style should be after child's
 * so that parent component's style could override it
 */
function getStyle (vnode, checkChild) {
  var res = {};
  var styleData;

  if (checkChild) {
    var childNode = vnode;
    while (childNode.componentInstance) {
      childNode = childNode.componentInstance._vnode;
      if (
        childNode && childNode.data &&
        (styleData = normalizeStyleData(childNode.data))
      ) {
        extend(res, styleData);
      }
    }
  }

  if ((styleData = normalizeStyleData(vnode.data))) {
    extend(res, styleData);
  }

  var parentNode = vnode;
  while ((parentNode = parentNode.parent)) {
    if (parentNode.data && (styleData = normalizeStyleData(parentNode.data))) {
      extend(res, styleData);
    }
  }
  return res
}

/*  */

var cssVarRE = /^--/;
var importantRE = /\s*!important$/;
var setProp = function (el, name, val) {
  /* istanbul ignore if */
  if (cssVarRE.test(name)) {
    el.style.setProperty(name, val);
  } else if (importantRE.test(val)) {
    el.style.setProperty(hyphenate(name), val.replace(importantRE, ''), 'important');
  } else {
    var normalizedName = normalize(name);
    if (Array.isArray(val)) {
      // Support values array created by autoprefixer, e.g.
      // {display: ["-webkit-box", "-ms-flexbox", "flex"]}
      // Set them one by one, and the browser will only set those it can recognize
      for (var i = 0, len = val.length; i < len; i++) {
        el.style[normalizedName] = val[i];
      }
    } else {
      el.style[normalizedName] = val;
    }
  }
};

var vendorNames = ['Webkit', 'Moz', 'ms'];

var emptyStyle;
var normalize = cached(function (prop) {
  emptyStyle = emptyStyle || document.createElement('div').style;
  prop = camelize(prop);
  if (prop !== 'filter' && (prop in emptyStyle)) {
    return prop
  }
  var capName = prop.charAt(0).toUpperCase() + prop.slice(1);
  for (var i = 0; i < vendorNames.length; i++) {
    var name = vendorNames[i] + capName;
    if (name in emptyStyle) {
      return name
    }
  }
});

function updateStyle (oldVnode, vnode) {
  var data = vnode.data;
  var oldData = oldVnode.data;

  if (isUndef(data.staticStyle) && isUndef(data.style) &&
    isUndef(oldData.staticStyle) && isUndef(oldData.style)
  ) {
    return
  }

  var cur, name;
  var el = vnode.elm;
  var oldStaticStyle = oldData.staticStyle;
  var oldStyleBinding = oldData.normalizedStyle || oldData.style || {};

  // if static style exists, stylebinding already merged into it when doing normalizeStyleData
  var oldStyle = oldStaticStyle || oldStyleBinding;

  var style = normalizeStyleBinding(vnode.data.style) || {};

  // store normalized style under a different key for next diff
  // make sure to clone it if it's reactive, since the user likely wants
  // to mutate it.
  vnode.data.normalizedStyle = isDef(style.__ob__)
    ? extend({}, style)
    : style;

  var newStyle = getStyle(vnode, true);

  for (name in oldStyle) {
    if (isUndef(newStyle[name])) {
      setProp(el, name, '');
    }
  }
  for (name in newStyle) {
    cur = newStyle[name];
    if (cur !== oldStyle[name]) {
      // ie9 setting to null has no effect, must use empty string
      setProp(el, name, cur == null ? '' : cur);
    }
  }
}

var style = {
  create: updateStyle,
  update: updateStyle
};

/*  */

var whitespaceRE = /\s+/;

/**
 * Add class with compatibility for SVG since classList is not supported on
 * SVG elements in IE
 */
function addClass (el, cls) {
  /* istanbul ignore if */
  if (!cls || !(cls = cls.trim())) {
    return
  }

  /* istanbul ignore else */
  if (el.classList) {
    if (cls.indexOf(' ') > -1) {
      cls.split(whitespaceRE).forEach(function (c) { return el.classList.add(c); });
    } else {
      el.classList.add(cls);
    }
  } else {
    var cur = " " + (el.getAttribute('class') || '') + " ";
    if (cur.indexOf(' ' + cls + ' ') < 0) {
      el.setAttribute('class', (cur + cls).trim());
    }
  }
}

/**
 * Remove class with compatibility for SVG since classList is not supported on
 * SVG elements in IE
 */
function removeClass (el, cls) {
  /* istanbul ignore if */
  if (!cls || !(cls = cls.trim())) {
    return
  }

  /* istanbul ignore else */
  if (el.classList) {
    if (cls.indexOf(' ') > -1) {
      cls.split(whitespaceRE).forEach(function (c) { return el.classList.remove(c); });
    } else {
      el.classList.remove(cls);
    }
    if (!el.classList.length) {
      el.removeAttribute('class');
    }
  } else {
    var cur = " " + (el.getAttribute('class') || '') + " ";
    var tar = ' ' + cls + ' ';
    while (cur.indexOf(tar) >= 0) {
      cur = cur.replace(tar, ' ');
    }
    cur = cur.trim();
    if (cur) {
      el.setAttribute('class', cur);
    } else {
      el.removeAttribute('class');
    }
  }
}

/*  */

function resolveTransition (def$$1) {
  if (!def$$1) {
    return
  }
  /* istanbul ignore else */
  if (typeof def$$1 === 'object') {
    var res = {};
    if (def$$1.css !== false) {
      extend(res, autoCssTransition(def$$1.name || 'v'));
    }
    extend(res, def$$1);
    return res
  } else if (typeof def$$1 === 'string') {
    return autoCssTransition(def$$1)
  }
}

var autoCssTransition = cached(function (name) {
  return {
    enterClass: (name + "-enter"),
    enterToClass: (name + "-enter-to"),
    enterActiveClass: (name + "-enter-active"),
    leaveClass: (name + "-leave"),
    leaveToClass: (name + "-leave-to"),
    leaveActiveClass: (name + "-leave-active")
  }
});

var hasTransition = inBrowser && !isIE9;
var TRANSITION = 'transition';
var ANIMATION = 'animation';

// Transition property/event sniffing
var transitionProp = 'transition';
var transitionEndEvent = 'transitionend';
var animationProp = 'animation';
var animationEndEvent = 'animationend';
if (hasTransition) {
  /* istanbul ignore if */
  if (window.ontransitionend === undefined &&
    window.onwebkittransitionend !== undefined
  ) {
    transitionProp = 'WebkitTransition';
    transitionEndEvent = 'webkitTransitionEnd';
  }
  if (window.onanimationend === undefined &&
    window.onwebkitanimationend !== undefined
  ) {
    animationProp = 'WebkitAnimation';
    animationEndEvent = 'webkitAnimationEnd';
  }
}

// binding to window is necessary to make hot reload work in IE in strict mode
var raf = inBrowser
  ? window.requestAnimationFrame
    ? window.requestAnimationFrame.bind(window)
    : setTimeout
  : /* istanbul ignore next */ function (fn) { return fn(); };

function nextFrame (fn) {
  raf(function () {
    raf(fn);
  });
}

function addTransitionClass (el, cls) {
  var transitionClasses = el._transitionClasses || (el._transitionClasses = []);
  if (transitionClasses.indexOf(cls) < 0) {
    transitionClasses.push(cls);
    addClass(el, cls);
  }
}

function removeTransitionClass (el, cls) {
  if (el._transitionClasses) {
    remove(el._transitionClasses, cls);
  }
  removeClass(el, cls);
}

function whenTransitionEnds (
  el,
  expectedType,
  cb
) {
  var ref = getTransitionInfo(el, expectedType);
  var type = ref.type;
  var timeout = ref.timeout;
  var propCount = ref.propCount;
  if (!type) { return cb() }
  var event = type === TRANSITION ? transitionEndEvent : animationEndEvent;
  var ended = 0;
  var end = function () {
    el.removeEventListener(event, onEnd);
    cb();
  };
  var onEnd = function (e) {
    if (e.target === el) {
      if (++ended >= propCount) {
        end();
      }
    }
  };
  setTimeout(function () {
    if (ended < propCount) {
      end();
    }
  }, timeout + 1);
  el.addEventListener(event, onEnd);
}

var transformRE = /\b(transform|all)(,|$)/;

function getTransitionInfo (el, expectedType) {
  var styles = window.getComputedStyle(el);
  // JSDOM may return undefined for transition properties
  var transitionDelays = (styles[transitionProp + 'Delay'] || '').split(', ');
  var transitionDurations = (styles[transitionProp + 'Duration'] || '').split(', ');
  var transitionTimeout = getTimeout(transitionDelays, transitionDurations);
  var animationDelays = (styles[animationProp + 'Delay'] || '').split(', ');
  var animationDurations = (styles[animationProp + 'Duration'] || '').split(', ');
  var animationTimeout = getTimeout(animationDelays, animationDurations);

  var type;
  var timeout = 0;
  var propCount = 0;
  /* istanbul ignore if */
  if (expectedType === TRANSITION) {
    if (transitionTimeout > 0) {
      type = TRANSITION;
      timeout = transitionTimeout;
      propCount = transitionDurations.length;
    }
  } else if (expectedType === ANIMATION) {
    if (animationTimeout > 0) {
      type = ANIMATION;
      timeout = animationTimeout;
      propCount = animationDurations.length;
    }
  } else {
    timeout = Math.max(transitionTimeout, animationTimeout);
    type = timeout > 0
      ? transitionTimeout > animationTimeout
        ? TRANSITION
        : ANIMATION
      : null;
    propCount = type
      ? type === TRANSITION
        ? transitionDurations.length
        : animationDurations.length
      : 0;
  }
  var hasTransform =
    type === TRANSITION &&
    transformRE.test(styles[transitionProp + 'Property']);
  return {
    type: type,
    timeout: timeout,
    propCount: propCount,
    hasTransform: hasTransform
  }
}

function getTimeout (delays, durations) {
  /* istanbul ignore next */
  while (delays.length < durations.length) {
    delays = delays.concat(delays);
  }

  return Math.max.apply(null, durations.map(function (d, i) {
    return toMs(d) + toMs(delays[i])
  }))
}

// Old versions of Chromium (below 61.0.3163.100) formats floating pointer numbers
// in a locale-dependent way, using a comma instead of a dot.
// If comma is not replaced with a dot, the input will be rounded down (i.e. acting
// as a floor function) causing unexpected behaviors
function toMs (s) {
  return Number(s.slice(0, -1).replace(',', '.')) * 1000
}

/*  */

function enter (vnode, toggleDisplay) {
  var el = vnode.elm;

  // call leave callback now
  if (isDef(el._leaveCb)) {
    el._leaveCb.cancelled = true;
    el._leaveCb();
  }

  var data = resolveTransition(vnode.data.transition);
  if (isUndef(data)) {
    return
  }

  /* istanbul ignore if */
  if (isDef(el._enterCb) || el.nodeType !== 1) {
    return
  }

  var css = data.css;
  var type = data.type;
  var enterClass = data.enterClass;
  var enterToClass = data.enterToClass;
  var enterActiveClass = data.enterActiveClass;
  var appearClass = data.appearClass;
  var appearToClass = data.appearToClass;
  var appearActiveClass = data.appearActiveClass;
  var beforeEnter = data.beforeEnter;
  var enter = data.enter;
  var afterEnter = data.afterEnter;
  var enterCancelled = data.enterCancelled;
  var beforeAppear = data.beforeAppear;
  var appear = data.appear;
  var afterAppear = data.afterAppear;
  var appearCancelled = data.appearCancelled;
  var duration = data.duration;

  // activeInstance will always be the <transition> component managing this
  // transition. One edge case to check is when the <transition> is placed
  // as the root node of a child component. In that case we need to check
  // <transition>'s parent for appear check.
  var context = activeInstance;
  var transitionNode = activeInstance.$vnode;
  while (transitionNode && transitionNode.parent) {
    context = transitionNode.context;
    transitionNode = transitionNode.parent;
  }

  var isAppear = !context._isMounted || !vnode.isRootInsert;

  if (isAppear && !appear && appear !== '') {
    return
  }

  var startClass = isAppear && appearClass
    ? appearClass
    : enterClass;
  var activeClass = isAppear && appearActiveClass
    ? appearActiveClass
    : enterActiveClass;
  var toClass = isAppear && appearToClass
    ? appearToClass
    : enterToClass;

  var beforeEnterHook = isAppear
    ? (beforeAppear || beforeEnter)
    : beforeEnter;
  var enterHook = isAppear
    ? (typeof appear === 'function' ? appear : enter)
    : enter;
  var afterEnterHook = isAppear
    ? (afterAppear || afterEnter)
    : afterEnter;
  var enterCancelledHook = isAppear
    ? (appearCancelled || enterCancelled)
    : enterCancelled;

  var explicitEnterDuration = toNumber(
    isObject(duration)
      ? duration.enter
      : duration
  );

  if ( true && explicitEnterDuration != null) {
    checkDuration(explicitEnterDuration, 'enter', vnode);
  }

  var expectsCSS = css !== false && !isIE9;
  var userWantsControl = getHookArgumentsLength(enterHook);

  var cb = el._enterCb = once(function () {
    if (expectsCSS) {
      removeTransitionClass(el, toClass);
      removeTransitionClass(el, activeClass);
    }
    if (cb.cancelled) {
      if (expectsCSS) {
        removeTransitionClass(el, startClass);
      }
      enterCancelledHook && enterCancelledHook(el);
    } else {
      afterEnterHook && afterEnterHook(el);
    }
    el._enterCb = null;
  });

  if (!vnode.data.show) {
    // remove pending leave element on enter by injecting an insert hook
    mergeVNodeHook(vnode, 'insert', function () {
      var parent = el.parentNode;
      var pendingNode = parent && parent._pending && parent._pending[vnode.key];
      if (pendingNode &&
        pendingNode.tag === vnode.tag &&
        pendingNode.elm._leaveCb
      ) {
        pendingNode.elm._leaveCb();
      }
      enterHook && enterHook(el, cb);
    });
  }

  // start enter transition
  beforeEnterHook && beforeEnterHook(el);
  if (expectsCSS) {
    addTransitionClass(el, startClass);
    addTransitionClass(el, activeClass);
    nextFrame(function () {
      removeTransitionClass(el, startClass);
      if (!cb.cancelled) {
        addTransitionClass(el, toClass);
        if (!userWantsControl) {
          if (isValidDuration(explicitEnterDuration)) {
            setTimeout(cb, explicitEnterDuration);
          } else {
            whenTransitionEnds(el, type, cb);
          }
        }
      }
    });
  }

  if (vnode.data.show) {
    toggleDisplay && toggleDisplay();
    enterHook && enterHook(el, cb);
  }

  if (!expectsCSS && !userWantsControl) {
    cb();
  }
}

function leave (vnode, rm) {
  var el = vnode.elm;

  // call enter callback now
  if (isDef(el._enterCb)) {
    el._enterCb.cancelled = true;
    el._enterCb();
  }

  var data = resolveTransition(vnode.data.transition);
  if (isUndef(data) || el.nodeType !== 1) {
    return rm()
  }

  /* istanbul ignore if */
  if (isDef(el._leaveCb)) {
    return
  }

  var css = data.css;
  var type = data.type;
  var leaveClass = data.leaveClass;
  var leaveToClass = data.leaveToClass;
  var leaveActiveClass = data.leaveActiveClass;
  var beforeLeave = data.beforeLeave;
  var leave = data.leave;
  var afterLeave = data.afterLeave;
  var leaveCancelled = data.leaveCancelled;
  var delayLeave = data.delayLeave;
  var duration = data.duration;

  var expectsCSS = css !== false && !isIE9;
  var userWantsControl = getHookArgumentsLength(leave);

  var explicitLeaveDuration = toNumber(
    isObject(duration)
      ? duration.leave
      : duration
  );

  if ( true && isDef(explicitLeaveDuration)) {
    checkDuration(explicitLeaveDuration, 'leave', vnode);
  }

  var cb = el._leaveCb = once(function () {
    if (el.parentNode && el.parentNode._pending) {
      el.parentNode._pending[vnode.key] = null;
    }
    if (expectsCSS) {
      removeTransitionClass(el, leaveToClass);
      removeTransitionClass(el, leaveActiveClass);
    }
    if (cb.cancelled) {
      if (expectsCSS) {
        removeTransitionClass(el, leaveClass);
      }
      leaveCancelled && leaveCancelled(el);
    } else {
      rm();
      afterLeave && afterLeave(el);
    }
    el._leaveCb = null;
  });

  if (delayLeave) {
    delayLeave(performLeave);
  } else {
    performLeave();
  }

  function performLeave () {
    // the delayed leave may have already been cancelled
    if (cb.cancelled) {
      return
    }
    // record leaving element
    if (!vnode.data.show && el.parentNode) {
      (el.parentNode._pending || (el.parentNode._pending = {}))[(vnode.key)] = vnode;
    }
    beforeLeave && beforeLeave(el);
    if (expectsCSS) {
      addTransitionClass(el, leaveClass);
      addTransitionClass(el, leaveActiveClass);
      nextFrame(function () {
        removeTransitionClass(el, leaveClass);
        if (!cb.cancelled) {
          addTransitionClass(el, leaveToClass);
          if (!userWantsControl) {
            if (isValidDuration(explicitLeaveDuration)) {
              setTimeout(cb, explicitLeaveDuration);
            } else {
              whenTransitionEnds(el, type, cb);
            }
          }
        }
      });
    }
    leave && leave(el, cb);
    if (!expectsCSS && !userWantsControl) {
      cb();
    }
  }
}

// only used in dev mode
function checkDuration (val, name, vnode) {
  if (typeof val !== 'number') {
    warn(
      "<transition> explicit " + name + " duration is not a valid number - " +
      "got " + (JSON.stringify(val)) + ".",
      vnode.context
    );
  } else if (isNaN(val)) {
    warn(
      "<transition> explicit " + name + " duration is NaN - " +
      'the duration expression might be incorrect.',
      vnode.context
    );
  }
}

function isValidDuration (val) {
  return typeof val === 'number' && !isNaN(val)
}

/**
 * Normalize a transition hook's argument length. The hook may be:
 * - a merged hook (invoker) with the original in .fns
 * - a wrapped component method (check ._length)
 * - a plain function (.length)
 */
function getHookArgumentsLength (fn) {
  if (isUndef(fn)) {
    return false
  }
  var invokerFns = fn.fns;
  if (isDef(invokerFns)) {
    // invoker
    return getHookArgumentsLength(
      Array.isArray(invokerFns)
        ? invokerFns[0]
        : invokerFns
    )
  } else {
    return (fn._length || fn.length) > 1
  }
}

function _enter (_, vnode) {
  if (vnode.data.show !== true) {
    enter(vnode);
  }
}

var transition = inBrowser ? {
  create: _enter,
  activate: _enter,
  remove: function remove$$1 (vnode, rm) {
    /* istanbul ignore else */
    if (vnode.data.show !== true) {
      leave(vnode, rm);
    } else {
      rm();
    }
  }
} : {};

var platformModules = [
  attrs,
  klass,
  events,
  domProps,
  style,
  transition
];

/*  */

// the directive module should be applied last, after all
// built-in modules have been applied.
var modules = platformModules.concat(baseModules);

var patch = createPatchFunction({ nodeOps: nodeOps, modules: modules });

/**
 * Not type checking this file because flow doesn't like attaching
 * properties to Elements.
 */

/* istanbul ignore if */
if (isIE9) {
  // http://www.matts411.com/post/internet-explorer-9-oninput/
  document.addEventListener('selectionchange', function () {
    var el = document.activeElement;
    if (el && el.vmodel) {
      trigger(el, 'input');
    }
  });
}

var directive = {
  inserted: function inserted (el, binding, vnode, oldVnode) {
    if (vnode.tag === 'select') {
      // #6903
      if (oldVnode.elm && !oldVnode.elm._vOptions) {
        mergeVNodeHook(vnode, 'postpatch', function () {
          directive.componentUpdated(el, binding, vnode);
        });
      } else {
        setSelected(el, binding, vnode.context);
      }
      el._vOptions = [].map.call(el.options, getValue);
    } else if (vnode.tag === 'textarea' || isTextInputType(el.type)) {
      el._vModifiers = binding.modifiers;
      if (!binding.modifiers.lazy) {
        el.addEventListener('compositionstart', onCompositionStart);
        el.addEventListener('compositionend', onCompositionEnd);
        // Safari < 10.2 & UIWebView doesn't fire compositionend when
        // switching focus before confirming composition choice
        // this also fixes the issue where some browsers e.g. iOS Chrome
        // fires "change" instead of "input" on autocomplete.
        el.addEventListener('change', onCompositionEnd);
        /* istanbul ignore if */
        if (isIE9) {
          el.vmodel = true;
        }
      }
    }
  },

  componentUpdated: function componentUpdated (el, binding, vnode) {
    if (vnode.tag === 'select') {
      setSelected(el, binding, vnode.context);
      // in case the options rendered by v-for have changed,
      // it's possible that the value is out-of-sync with the rendered options.
      // detect such cases and filter out values that no longer has a matching
      // option in the DOM.
      var prevOptions = el._vOptions;
      var curOptions = el._vOptions = [].map.call(el.options, getValue);
      if (curOptions.some(function (o, i) { return !looseEqual(o, prevOptions[i]); })) {
        // trigger change event if
        // no matching option found for at least one value
        var needReset = el.multiple
          ? binding.value.some(function (v) { return hasNoMatchingOption(v, curOptions); })
          : binding.value !== binding.oldValue && hasNoMatchingOption(binding.value, curOptions);
        if (needReset) {
          trigger(el, 'change');
        }
      }
    }
  }
};

function setSelected (el, binding, vm) {
  actuallySetSelected(el, binding, vm);
  /* istanbul ignore if */
  if (isIE || isEdge) {
    setTimeout(function () {
      actuallySetSelected(el, binding, vm);
    }, 0);
  }
}

function actuallySetSelected (el, binding, vm) {
  var value = binding.value;
  var isMultiple = el.multiple;
  if (isMultiple && !Array.isArray(value)) {
     true && warn(
      "<select multiple v-model=\"" + (binding.expression) + "\"> " +
      "expects an Array value for its binding, but got " + (Object.prototype.toString.call(value).slice(8, -1)),
      vm
    );
    return
  }
  var selected, option;
  for (var i = 0, l = el.options.length; i < l; i++) {
    option = el.options[i];
    if (isMultiple) {
      selected = looseIndexOf(value, getValue(option)) > -1;
      if (option.selected !== selected) {
        option.selected = selected;
      }
    } else {
      if (looseEqual(getValue(option), value)) {
        if (el.selectedIndex !== i) {
          el.selectedIndex = i;
        }
        return
      }
    }
  }
  if (!isMultiple) {
    el.selectedIndex = -1;
  }
}

function hasNoMatchingOption (value, options) {
  return options.every(function (o) { return !looseEqual(o, value); })
}

function getValue (option) {
  return '_value' in option
    ? option._value
    : option.value
}

function onCompositionStart (e) {
  e.target.composing = true;
}

function onCompositionEnd (e) {
  // prevent triggering an input event for no reason
  if (!e.target.composing) { return }
  e.target.composing = false;
  trigger(e.target, 'input');
}

function trigger (el, type) {
  var e = document.createEvent('HTMLEvents');
  e.initEvent(type, true, true);
  el.dispatchEvent(e);
}

/*  */

// recursively search for possible transition defined inside the component root
function locateNode (vnode) {
  return vnode.componentInstance && (!vnode.data || !vnode.data.transition)
    ? locateNode(vnode.componentInstance._vnode)
    : vnode
}

var show = {
  bind: function bind (el, ref, vnode) {
    var value = ref.value;

    vnode = locateNode(vnode);
    var transition$$1 = vnode.data && vnode.data.transition;
    var originalDisplay = el.__vOriginalDisplay =
      el.style.display === 'none' ? '' : el.style.display;
    if (value && transition$$1) {
      vnode.data.show = true;
      enter(vnode, function () {
        el.style.display = originalDisplay;
      });
    } else {
      el.style.display = value ? originalDisplay : 'none';
    }
  },

  update: function update (el, ref, vnode) {
    var value = ref.value;
    var oldValue = ref.oldValue;

    /* istanbul ignore if */
    if (!value === !oldValue) { return }
    vnode = locateNode(vnode);
    var transition$$1 = vnode.data && vnode.data.transition;
    if (transition$$1) {
      vnode.data.show = true;
      if (value) {
        enter(vnode, function () {
          el.style.display = el.__vOriginalDisplay;
        });
      } else {
        leave(vnode, function () {
          el.style.display = 'none';
        });
      }
    } else {
      el.style.display = value ? el.__vOriginalDisplay : 'none';
    }
  },

  unbind: function unbind (
    el,
    binding,
    vnode,
    oldVnode,
    isDestroy
  ) {
    if (!isDestroy) {
      el.style.display = el.__vOriginalDisplay;
    }
  }
};

var platformDirectives = {
  model: directive,
  show: show
};

/*  */

var transitionProps = {
  name: String,
  appear: Boolean,
  css: Boolean,
  mode: String,
  type: String,
  enterClass: String,
  leaveClass: String,
  enterToClass: String,
  leaveToClass: String,
  enterActiveClass: String,
  leaveActiveClass: String,
  appearClass: String,
  appearActiveClass: String,
  appearToClass: String,
  duration: [Number, String, Object]
};

// in case the child is also an abstract component, e.g. <keep-alive>
// we want to recursively retrieve the real component to be rendered
function getRealChild (vnode) {
  var compOptions = vnode && vnode.componentOptions;
  if (compOptions && compOptions.Ctor.options.abstract) {
    return getRealChild(getFirstComponentChild(compOptions.children))
  } else {
    return vnode
  }
}

function extractTransitionData (comp) {
  var data = {};
  var options = comp.$options;
  // props
  for (var key in options.propsData) {
    data[key] = comp[key];
  }
  // events.
  // extract listeners and pass them directly to the transition methods
  var listeners = options._parentListeners;
  for (var key$1 in listeners) {
    data[camelize(key$1)] = listeners[key$1];
  }
  return data
}

function placeholder (h, rawChild) {
  if (/\d-keep-alive$/.test(rawChild.tag)) {
    return h('keep-alive', {
      props: rawChild.componentOptions.propsData
    })
  }
}

function hasParentTransition (vnode) {
  while ((vnode = vnode.parent)) {
    if (vnode.data.transition) {
      return true
    }
  }
}

function isSameChild (child, oldChild) {
  return oldChild.key === child.key && oldChild.tag === child.tag
}

var isNotTextNode = function (c) { return c.tag || isAsyncPlaceholder(c); };

var isVShowDirective = function (d) { return d.name === 'show'; };

var Transition = {
  name: 'transition',
  props: transitionProps,
  abstract: true,

  render: function render (h) {
    var this$1 = this;

    var children = this.$slots.default;
    if (!children) {
      return
    }

    // filter out text nodes (possible whitespaces)
    children = children.filter(isNotTextNode);
    /* istanbul ignore if */
    if (!children.length) {
      return
    }

    // warn multiple elements
    if ( true && children.length > 1) {
      warn(
        '<transition> can only be used on a single element. Use ' +
        '<transition-group> for lists.',
        this.$parent
      );
    }

    var mode = this.mode;

    // warn invalid mode
    if ( true &&
      mode && mode !== 'in-out' && mode !== 'out-in'
    ) {
      warn(
        'invalid <transition> mode: ' + mode,
        this.$parent
      );
    }

    var rawChild = children[0];

    // if this is a component root node and the component's
    // parent container node also has transition, skip.
    if (hasParentTransition(this.$vnode)) {
      return rawChild
    }

    // apply transition data to child
    // use getRealChild() to ignore abstract components e.g. keep-alive
    var child = getRealChild(rawChild);
    /* istanbul ignore if */
    if (!child) {
      return rawChild
    }

    if (this._leaving) {
      return placeholder(h, rawChild)
    }

    // ensure a key that is unique to the vnode type and to this transition
    // component instance. This key will be used to remove pending leaving nodes
    // during entering.
    var id = "__transition-" + (this._uid) + "-";
    child.key = child.key == null
      ? child.isComment
        ? id + 'comment'
        : id + child.tag
      : isPrimitive(child.key)
        ? (String(child.key).indexOf(id) === 0 ? child.key : id + child.key)
        : child.key;

    var data = (child.data || (child.data = {})).transition = extractTransitionData(this);
    var oldRawChild = this._vnode;
    var oldChild = getRealChild(oldRawChild);

    // mark v-show
    // so that the transition module can hand over the control to the directive
    if (child.data.directives && child.data.directives.some(isVShowDirective)) {
      child.data.show = true;
    }

    if (
      oldChild &&
      oldChild.data &&
      !isSameChild(child, oldChild) &&
      !isAsyncPlaceholder(oldChild) &&
      // #6687 component root is a comment node
      !(oldChild.componentInstance && oldChild.componentInstance._vnode.isComment)
    ) {
      // replace old child transition data with fresh one
      // important for dynamic transitions!
      var oldData = oldChild.data.transition = extend({}, data);
      // handle transition mode
      if (mode === 'out-in') {
        // return placeholder node and queue update when leave finishes
        this._leaving = true;
        mergeVNodeHook(oldData, 'afterLeave', function () {
          this$1._leaving = false;
          this$1.$forceUpdate();
        });
        return placeholder(h, rawChild)
      } else if (mode === 'in-out') {
        if (isAsyncPlaceholder(child)) {
          return oldRawChild
        }
        var delayedLeave;
        var performLeave = function () { delayedLeave(); };
        mergeVNodeHook(data, 'afterEnter', performLeave);
        mergeVNodeHook(data, 'enterCancelled', performLeave);
        mergeVNodeHook(oldData, 'delayLeave', function (leave) { delayedLeave = leave; });
      }
    }

    return rawChild
  }
};

/*  */

var props = extend({
  tag: String,
  moveClass: String
}, transitionProps);

delete props.mode;

var TransitionGroup = {
  props: props,

  beforeMount: function beforeMount () {
    var this$1 = this;

    var update = this._update;
    this._update = function (vnode, hydrating) {
      var restoreActiveInstance = setActiveInstance(this$1);
      // force removing pass
      this$1.__patch__(
        this$1._vnode,
        this$1.kept,
        false, // hydrating
        true // removeOnly (!important, avoids unnecessary moves)
      );
      this$1._vnode = this$1.kept;
      restoreActiveInstance();
      update.call(this$1, vnode, hydrating);
    };
  },

  render: function render (h) {
    var tag = this.tag || this.$vnode.data.tag || 'span';
    var map = Object.create(null);
    var prevChildren = this.prevChildren = this.children;
    var rawChildren = this.$slots.default || [];
    var children = this.children = [];
    var transitionData = extractTransitionData(this);

    for (var i = 0; i < rawChildren.length; i++) {
      var c = rawChildren[i];
      if (c.tag) {
        if (c.key != null && String(c.key).indexOf('__vlist') !== 0) {
          children.push(c);
          map[c.key] = c
          ;(c.data || (c.data = {})).transition = transitionData;
        } else if (true) {
          var opts = c.componentOptions;
          var name = opts ? (opts.Ctor.options.name || opts.tag || '') : c.tag;
          warn(("<transition-group> children must be keyed: <" + name + ">"));
        }
      }
    }

    if (prevChildren) {
      var kept = [];
      var removed = [];
      for (var i$1 = 0; i$1 < prevChildren.length; i$1++) {
        var c$1 = prevChildren[i$1];
        c$1.data.transition = transitionData;
        c$1.data.pos = c$1.elm.getBoundingClientRect();
        if (map[c$1.key]) {
          kept.push(c$1);
        } else {
          removed.push(c$1);
        }
      }
      this.kept = h(tag, null, kept);
      this.removed = removed;
    }

    return h(tag, null, children)
  },

  updated: function updated () {
    var children = this.prevChildren;
    var moveClass = this.moveClass || ((this.name || 'v') + '-move');
    if (!children.length || !this.hasMove(children[0].elm, moveClass)) {
      return
    }

    // we divide the work into three loops to avoid mixing DOM reads and writes
    // in each iteration - which helps prevent layout thrashing.
    children.forEach(callPendingCbs);
    children.forEach(recordPosition);
    children.forEach(applyTranslation);

    // force reflow to put everything in position
    // assign to this to avoid being removed in tree-shaking
    // $flow-disable-line
    this._reflow = document.body.offsetHeight;

    children.forEach(function (c) {
      if (c.data.moved) {
        var el = c.elm;
        var s = el.style;
        addTransitionClass(el, moveClass);
        s.transform = s.WebkitTransform = s.transitionDuration = '';
        el.addEventListener(transitionEndEvent, el._moveCb = function cb (e) {
          if (e && e.target !== el) {
            return
          }
          if (!e || /transform$/.test(e.propertyName)) {
            el.removeEventListener(transitionEndEvent, cb);
            el._moveCb = null;
            removeTransitionClass(el, moveClass);
          }
        });
      }
    });
  },

  methods: {
    hasMove: function hasMove (el, moveClass) {
      /* istanbul ignore if */
      if (!hasTransition) {
        return false
      }
      /* istanbul ignore if */
      if (this._hasMove) {
        return this._hasMove
      }
      // Detect whether an element with the move class applied has
      // CSS transitions. Since the element may be inside an entering
      // transition at this very moment, we make a clone of it and remove
      // all other transition classes applied to ensure only the move class
      // is applied.
      var clone = el.cloneNode();
      if (el._transitionClasses) {
        el._transitionClasses.forEach(function (cls) { removeClass(clone, cls); });
      }
      addClass(clone, moveClass);
      clone.style.display = 'none';
      this.$el.appendChild(clone);
      var info = getTransitionInfo(clone);
      this.$el.removeChild(clone);
      return (this._hasMove = info.hasTransform)
    }
  }
};

function callPendingCbs (c) {
  /* istanbul ignore if */
  if (c.elm._moveCb) {
    c.elm._moveCb();
  }
  /* istanbul ignore if */
  if (c.elm._enterCb) {
    c.elm._enterCb();
  }
}

function recordPosition (c) {
  c.data.newPos = c.elm.getBoundingClientRect();
}

function applyTranslation (c) {
  var oldPos = c.data.pos;
  var newPos = c.data.newPos;
  var dx = oldPos.left - newPos.left;
  var dy = oldPos.top - newPos.top;
  if (dx || dy) {
    c.data.moved = true;
    var s = c.elm.style;
    s.transform = s.WebkitTransform = "translate(" + dx + "px," + dy + "px)";
    s.transitionDuration = '0s';
  }
}

var platformComponents = {
  Transition: Transition,
  TransitionGroup: TransitionGroup
};

/*  */

// install platform specific utils
Vue.config.mustUseProp = mustUseProp;
Vue.config.isReservedTag = isReservedTag;
Vue.config.isReservedAttr = isReservedAttr;
Vue.config.getTagNamespace = getTagNamespace;
Vue.config.isUnknownElement = isUnknownElement;

// install platform runtime directives & components
extend(Vue.options.directives, platformDirectives);
extend(Vue.options.components, platformComponents);

// install platform patch function
Vue.prototype.__patch__ = inBrowser ? patch : noop;

// public mount method
Vue.prototype.$mount = function (
  el,
  hydrating
) {
  el = el && inBrowser ? query(el) : undefined;
  return mountComponent(this, el, hydrating)
};

// devtools global hook
/* istanbul ignore next */
if (inBrowser) {
  setTimeout(function () {
    if (config.devtools) {
      if (devtools) {
        devtools.emit('init', Vue);
      } else if (
        true
      ) {
        console[console.info ? 'info' : 'log'](
          'Download the Vue Devtools extension for a better development experience:\n' +
          'https://github.com/vuejs/vue-devtools'
        );
      }
    }
    if ( true &&
      config.productionTip !== false &&
      typeof console !== 'undefined'
    ) {
      console[console.info ? 'info' : 'log'](
        "You are running Vue in development mode.\n" +
        "Make sure to turn on production mode when deploying for production.\n" +
        "See more tips at https://vuejs.org/guide/deployment.html"
      );
    }
  }, 0);
}

/*  */

var defaultTagRE = /\{\{((?:.|\r?\n)+?)\}\}/g;
var regexEscapeRE = /[-.*+?^${}()|[\]\/\\]/g;

var buildRegex = cached(function (delimiters) {
  var open = delimiters[0].replace(regexEscapeRE, '\\$&');
  var close = delimiters[1].replace(regexEscapeRE, '\\$&');
  return new RegExp(open + '((?:.|\\n)+?)' + close, 'g')
});



function parseText (
  text,
  delimiters
) {
  var tagRE = delimiters ? buildRegex(delimiters) : defaultTagRE;
  if (!tagRE.test(text)) {
    return
  }
  var tokens = [];
  var rawTokens = [];
  var lastIndex = tagRE.lastIndex = 0;
  var match, index, tokenValue;
  while ((match = tagRE.exec(text))) {
    index = match.index;
    // push text token
    if (index > lastIndex) {
      rawTokens.push(tokenValue = text.slice(lastIndex, index));
      tokens.push(JSON.stringify(tokenValue));
    }
    // tag token
    var exp = parseFilters(match[1].trim());
    tokens.push(("_s(" + exp + ")"));
    rawTokens.push({ '@binding': exp });
    lastIndex = index + match[0].length;
  }
  if (lastIndex < text.length) {
    rawTokens.push(tokenValue = text.slice(lastIndex));
    tokens.push(JSON.stringify(tokenValue));
  }
  return {
    expression: tokens.join('+'),
    tokens: rawTokens
  }
}

/*  */

function transformNode (el, options) {
  var warn = options.warn || baseWarn;
  var staticClass = getAndRemoveAttr(el, 'class');
  if ( true && staticClass) {
    var res = parseText(staticClass, options.delimiters);
    if (res) {
      warn(
        "class=\"" + staticClass + "\": " +
        'Interpolation inside attributes has been removed. ' +
        'Use v-bind or the colon shorthand instead. For example, ' +
        'instead of <div class="{{ val }}">, use <div :class="val">.',
        el.rawAttrsMap['class']
      );
    }
  }
  if (staticClass) {
    el.staticClass = JSON.stringify(staticClass);
  }
  var classBinding = getBindingAttr(el, 'class', false /* getStatic */);
  if (classBinding) {
    el.classBinding = classBinding;
  }
}

function genData (el) {
  var data = '';
  if (el.staticClass) {
    data += "staticClass:" + (el.staticClass) + ",";
  }
  if (el.classBinding) {
    data += "class:" + (el.classBinding) + ",";
  }
  return data
}

var klass$1 = {
  staticKeys: ['staticClass'],
  transformNode: transformNode,
  genData: genData
};

/*  */

function transformNode$1 (el, options) {
  var warn = options.warn || baseWarn;
  var staticStyle = getAndRemoveAttr(el, 'style');
  if (staticStyle) {
    /* istanbul ignore if */
    if (true) {
      var res = parseText(staticStyle, options.delimiters);
      if (res) {
        warn(
          "style=\"" + staticStyle + "\": " +
          'Interpolation inside attributes has been removed. ' +
          'Use v-bind or the colon shorthand instead. For example, ' +
          'instead of <div style="{{ val }}">, use <div :style="val">.',
          el.rawAttrsMap['style']
        );
      }
    }
    el.staticStyle = JSON.stringify(parseStyleText(staticStyle));
  }

  var styleBinding = getBindingAttr(el, 'style', false /* getStatic */);
  if (styleBinding) {
    el.styleBinding = styleBinding;
  }
}

function genData$1 (el) {
  var data = '';
  if (el.staticStyle) {
    data += "staticStyle:" + (el.staticStyle) + ",";
  }
  if (el.styleBinding) {
    data += "style:(" + (el.styleBinding) + "),";
  }
  return data
}

var style$1 = {
  staticKeys: ['staticStyle'],
  transformNode: transformNode$1,
  genData: genData$1
};

/*  */

var decoder;

var he = {
  decode: function decode (html) {
    decoder = decoder || document.createElement('div');
    decoder.innerHTML = html;
    return decoder.textContent
  }
};

/*  */

var isUnaryTag = makeMap(
  'area,base,br,col,embed,frame,hr,img,input,isindex,keygen,' +
  'link,meta,param,source,track,wbr'
);

// Elements that you can, intentionally, leave open
// (and which close themselves)
var canBeLeftOpenTag = makeMap(
  'colgroup,dd,dt,li,options,p,td,tfoot,th,thead,tr,source'
);

// HTML5 tags https://html.spec.whatwg.org/multipage/indices.html#elements-3
// Phrasing Content https://html.spec.whatwg.org/multipage/dom.html#phrasing-content
var isNonPhrasingTag = makeMap(
  'address,article,aside,base,blockquote,body,caption,col,colgroup,dd,' +
  'details,dialog,div,dl,dt,fieldset,figcaption,figure,footer,form,' +
  'h1,h2,h3,h4,h5,h6,head,header,hgroup,hr,html,legend,li,menuitem,meta,' +
  'optgroup,option,param,rp,rt,source,style,summary,tbody,td,tfoot,th,thead,' +
  'title,tr,track'
);

/**
 * Not type-checking this file because it's mostly vendor code.
 */

// Regular Expressions for parsing tags and attributes
var attribute = /^\s*([^\s"'<>\/=]+)(?:\s*(=)\s*(?:"([^"]*)"+|'([^']*)'+|([^\s"'=<>`]+)))?/;
var dynamicArgAttribute = /^\s*((?:v-[\w-]+:|@|:|#)\[[^=]+?\][^\s"'<>\/=]*)(?:\s*(=)\s*(?:"([^"]*)"+|'([^']*)'+|([^\s"'=<>`]+)))?/;
var ncname = "[a-zA-Z_][\\-\\.0-9_a-zA-Z" + (unicodeRegExp.source) + "]*";
var qnameCapture = "((?:" + ncname + "\\:)?" + ncname + ")";
var startTagOpen = new RegExp(("^<" + qnameCapture));
var startTagClose = /^\s*(\/?)>/;
var endTag = new RegExp(("^<\\/" + qnameCapture + "[^>]*>"));
var doctype = /^<!DOCTYPE [^>]+>/i;
// #7298: escape - to avoid being passed as HTML comment when inlined in page
var comment = /^<!\--/;
var conditionalComment = /^<!\[/;

// Special Elements (can contain anything)
var isPlainTextElement = makeMap('script,style,textarea', true);
var reCache = {};

var decodingMap = {
  '&lt;': '<',
  '&gt;': '>',
  '&quot;': '"',
  '&amp;': '&',
  '&#10;': '\n',
  '&#9;': '\t',
  '&#39;': "'"
};
var encodedAttr = /&(?:lt|gt|quot|amp|#39);/g;
var encodedAttrWithNewLines = /&(?:lt|gt|quot|amp|#39|#10|#9);/g;

// #5992
var isIgnoreNewlineTag = makeMap('pre,textarea', true);
var shouldIgnoreFirstNewline = function (tag, html) { return tag && isIgnoreNewlineTag(tag) && html[0] === '\n'; };

function decodeAttr (value, shouldDecodeNewlines) {
  var re = shouldDecodeNewlines ? encodedAttrWithNewLines : encodedAttr;
  return value.replace(re, function (match) { return decodingMap[match]; })
}

function parseHTML (html, options) {
  var stack = [];
  var expectHTML = options.expectHTML;
  var isUnaryTag$$1 = options.isUnaryTag || no;
  var canBeLeftOpenTag$$1 = options.canBeLeftOpenTag || no;
  var index = 0;
  var last, lastTag;
  while (html) {
    last = html;
    // Make sure we're not in a plaintext content element like script/style
    if (!lastTag || !isPlainTextElement(lastTag)) {
      var textEnd = html.indexOf('<');
      if (textEnd === 0) {
        // Comment:
        if (comment.test(html)) {
          var commentEnd = html.indexOf('-->');

          if (commentEnd >= 0) {
            if (options.shouldKeepComment) {
              options.comment(html.substring(4, commentEnd), index, index + commentEnd + 3);
            }
            advance(commentEnd + 3);
            continue
          }
        }

        // http://en.wikipedia.org/wiki/Conditional_comment#Downlevel-revealed_conditional_comment
        if (conditionalComment.test(html)) {
          var conditionalEnd = html.indexOf(']>');

          if (conditionalEnd >= 0) {
            advance(conditionalEnd + 2);
            continue
          }
        }

        // Doctype:
        var doctypeMatch = html.match(doctype);
        if (doctypeMatch) {
          advance(doctypeMatch[0].length);
          continue
        }

        // End tag:
        var endTagMatch = html.match(endTag);
        if (endTagMatch) {
          var curIndex = index;
          advance(endTagMatch[0].length);
          parseEndTag(endTagMatch[1], curIndex, index);
          continue
        }

        // Start tag:
        var startTagMatch = parseStartTag();
        if (startTagMatch) {
          handleStartTag(startTagMatch);
          if (shouldIgnoreFirstNewline(startTagMatch.tagName, html)) {
            advance(1);
          }
          continue
        }
      }

      var text = (void 0), rest = (void 0), next = (void 0);
      if (textEnd >= 0) {
        rest = html.slice(textEnd);
        while (
          !endTag.test(rest) &&
          !startTagOpen.test(rest) &&
          !comment.test(rest) &&
          !conditionalComment.test(rest)
        ) {
          // < in plain text, be forgiving and treat it as text
          next = rest.indexOf('<', 1);
          if (next < 0) { break }
          textEnd += next;
          rest = html.slice(textEnd);
        }
        text = html.substring(0, textEnd);
      }

      if (textEnd < 0) {
        text = html;
      }

      if (text) {
        advance(text.length);
      }

      if (options.chars && text) {
        options.chars(text, index - text.length, index);
      }
    } else {
      var endTagLength = 0;
      var stackedTag = lastTag.toLowerCase();
      var reStackedTag = reCache[stackedTag] || (reCache[stackedTag] = new RegExp('([\\s\\S]*?)(</' + stackedTag + '[^>]*>)', 'i'));
      var rest$1 = html.replace(reStackedTag, function (all, text, endTag) {
        endTagLength = endTag.length;
        if (!isPlainTextElement(stackedTag) && stackedTag !== 'noscript') {
          text = text
            .replace(/<!\--([\s\S]*?)-->/g, '$1') // #7298
            .replace(/<!\[CDATA\[([\s\S]*?)]]>/g, '$1');
        }
        if (shouldIgnoreFirstNewline(stackedTag, text)) {
          text = text.slice(1);
        }
        if (options.chars) {
          options.chars(text);
        }
        return ''
      });
      index += html.length - rest$1.length;
      html = rest$1;
      parseEndTag(stackedTag, index - endTagLength, index);
    }

    if (html === last) {
      options.chars && options.chars(html);
      if ( true && !stack.length && options.warn) {
        options.warn(("Mal-formatted tag at end of template: \"" + html + "\""), { start: index + html.length });
      }
      break
    }
  }

  // Clean up any remaining tags
  parseEndTag();

  function advance (n) {
    index += n;
    html = html.substring(n);
  }

  function parseStartTag () {
    var start = html.match(startTagOpen);
    if (start) {
      var match = {
        tagName: start[1],
        attrs: [],
        start: index
      };
      advance(start[0].length);
      var end, attr;
      while (!(end = html.match(startTagClose)) && (attr = html.match(dynamicArgAttribute) || html.match(attribute))) {
        attr.start = index;
        advance(attr[0].length);
        attr.end = index;
        match.attrs.push(attr);
      }
      if (end) {
        match.unarySlash = end[1];
        advance(end[0].length);
        match.end = index;
        return match
      }
    }
  }

  function handleStartTag (match) {
    var tagName = match.tagName;
    var unarySlash = match.unarySlash;

    if (expectHTML) {
      if (lastTag === 'p' && isNonPhrasingTag(tagName)) {
        parseEndTag(lastTag);
      }
      if (canBeLeftOpenTag$$1(tagName) && lastTag === tagName) {
        parseEndTag(tagName);
      }
    }

    var unary = isUnaryTag$$1(tagName) || !!unarySlash;

    var l = match.attrs.length;
    var attrs = new Array(l);
    for (var i = 0; i < l; i++) {
      var args = match.attrs[i];
      var value = args[3] || args[4] || args[5] || '';
      var shouldDecodeNewlines = tagName === 'a' && args[1] === 'href'
        ? options.shouldDecodeNewlinesForHref
        : options.shouldDecodeNewlines;
      attrs[i] = {
        name: args[1],
        value: decodeAttr(value, shouldDecodeNewlines)
      };
      if ( true && options.outputSourceRange) {
        attrs[i].start = args.start + args[0].match(/^\s*/).length;
        attrs[i].end = args.end;
      }
    }

    if (!unary) {
      stack.push({ tag: tagName, lowerCasedTag: tagName.toLowerCase(), attrs: attrs, start: match.start, end: match.end });
      lastTag = tagName;
    }

    if (options.start) {
      options.start(tagName, attrs, unary, match.start, match.end);
    }
  }

  function parseEndTag (tagName, start, end) {
    var pos, lowerCasedTagName;
    if (start == null) { start = index; }
    if (end == null) { end = index; }

    // Find the closest opened tag of the same type
    if (tagName) {
      lowerCasedTagName = tagName.toLowerCase();
      for (pos = stack.length - 1; pos >= 0; pos--) {
        if (stack[pos].lowerCasedTag === lowerCasedTagName) {
          break
        }
      }
    } else {
      // If no tag name is provided, clean shop
      pos = 0;
    }

    if (pos >= 0) {
      // Close all the open elements, up the stack
      for (var i = stack.length - 1; i >= pos; i--) {
        if ( true &&
          (i > pos || !tagName) &&
          options.warn
        ) {
          options.warn(
            ("tag <" + (stack[i].tag) + "> has no matching end tag."),
            { start: stack[i].start, end: stack[i].end }
          );
        }
        if (options.end) {
          options.end(stack[i].tag, start, end);
        }
      }

      // Remove the open elements from the stack
      stack.length = pos;
      lastTag = pos && stack[pos - 1].tag;
    } else if (lowerCasedTagName === 'br') {
      if (options.start) {
        options.start(tagName, [], true, start, end);
      }
    } else if (lowerCasedTagName === 'p') {
      if (options.start) {
        options.start(tagName, [], false, start, end);
      }
      if (options.end) {
        options.end(tagName, start, end);
      }
    }
  }
}

/*  */

var onRE = /^@|^v-on:/;
var dirRE = /^v-|^@|^:|^#/;
var forAliasRE = /([\s\S]*?)\s+(?:in|of)\s+([\s\S]*)/;
var forIteratorRE = /,([^,\}\]]*)(?:,([^,\}\]]*))?$/;
var stripParensRE = /^\(|\)$/g;
var dynamicArgRE = /^\[.*\]$/;

var argRE = /:(.*)$/;
var bindRE = /^:|^\.|^v-bind:/;
var modifierRE = /\.[^.\]]+(?=[^\]]*$)/g;

var slotRE = /^v-slot(:|$)|^#/;

var lineBreakRE = /[\r\n]/;
var whitespaceRE$1 = /[ \f\t\r\n]+/g;

var invalidAttributeRE = /[\s"'<>\/=]/;

var decodeHTMLCached = cached(he.decode);

var emptySlotScopeToken = "_empty_";

// configurable state
var warn$2;
var delimiters;
var transforms;
var preTransforms;
var postTransforms;
var platformIsPreTag;
var platformMustUseProp;
var platformGetTagNamespace;
var maybeComponent;

function createASTElement (
  tag,
  attrs,
  parent
) {
  return {
    type: 1,
    tag: tag,
    attrsList: attrs,
    attrsMap: makeAttrsMap(attrs),
    rawAttrsMap: {},
    parent: parent,
    children: []
  }
}

/**
 * Convert HTML string to AST.
 */
function parse (
  template,
  options
) {
  warn$2 = options.warn || baseWarn;

  platformIsPreTag = options.isPreTag || no;
  platformMustUseProp = options.mustUseProp || no;
  platformGetTagNamespace = options.getTagNamespace || no;
  var isReservedTag = options.isReservedTag || no;
  maybeComponent = function (el) { return !!(
    el.component ||
    el.attrsMap[':is'] ||
    el.attrsMap['v-bind:is'] ||
    !(el.attrsMap.is ? isReservedTag(el.attrsMap.is) : isReservedTag(el.tag))
  ); };
  transforms = pluckModuleFunction(options.modules, 'transformNode');
  preTransforms = pluckModuleFunction(options.modules, 'preTransformNode');
  postTransforms = pluckModuleFunction(options.modules, 'postTransformNode');

  delimiters = options.delimiters;

  var stack = [];
  var preserveWhitespace = options.preserveWhitespace !== false;
  var whitespaceOption = options.whitespace;
  var root;
  var currentParent;
  var inVPre = false;
  var inPre = false;
  var warned = false;

  function warnOnce (msg, range) {
    if (!warned) {
      warned = true;
      warn$2(msg, range);
    }
  }

  function closeElement (element) {
    trimEndingWhitespace(element);
    if (!inVPre && !element.processed) {
      element = processElement(element, options);
    }
    // tree management
    if (!stack.length && element !== root) {
      // allow root elements with v-if, v-else-if and v-else
      if (root.if && (element.elseif || element.else)) {
        if (true) {
          checkRootConstraints(element);
        }
        addIfCondition(root, {
          exp: element.elseif,
          block: element
        });
      } else if (true) {
        warnOnce(
          "Component template should contain exactly one root element. " +
          "If you are using v-if on multiple elements, " +
          "use v-else-if to chain them instead.",
          { start: element.start }
        );
      }
    }
    if (currentParent && !element.forbidden) {
      if (element.elseif || element.else) {
        processIfConditions(element, currentParent);
      } else {
        if (element.slotScope) {
          // scoped slot
          // keep it in the children list so that v-else(-if) conditions can
          // find it as the prev node.
          var name = element.slotTarget || '"default"'
          ;(currentParent.scopedSlots || (currentParent.scopedSlots = {}))[name] = element;
        }
        currentParent.children.push(element);
        element.parent = currentParent;
      }
    }

    // final children cleanup
    // filter out scoped slots
    element.children = element.children.filter(function (c) { return !(c).slotScope; });
    // remove trailing whitespace node again
    trimEndingWhitespace(element);

    // check pre state
    if (element.pre) {
      inVPre = false;
    }
    if (platformIsPreTag(element.tag)) {
      inPre = false;
    }
    // apply post-transforms
    for (var i = 0; i < postTransforms.length; i++) {
      postTransforms[i](element, options);
    }
  }

  function trimEndingWhitespace (el) {
    // remove trailing whitespace node
    if (!inPre) {
      var lastNode;
      while (
        (lastNode = el.children[el.children.length - 1]) &&
        lastNode.type === 3 &&
        lastNode.text === ' '
      ) {
        el.children.pop();
      }
    }
  }

  function checkRootConstraints (el) {
    if (el.tag === 'slot' || el.tag === 'template') {
      warnOnce(
        "Cannot use <" + (el.tag) + "> as component root element because it may " +
        'contain multiple nodes.',
        { start: el.start }
      );
    }
    if (el.attrsMap.hasOwnProperty('v-for')) {
      warnOnce(
        'Cannot use v-for on stateful component root element because ' +
        'it renders multiple elements.',
        el.rawAttrsMap['v-for']
      );
    }
  }

  parseHTML(template, {
    warn: warn$2,
    expectHTML: options.expectHTML,
    isUnaryTag: options.isUnaryTag,
    canBeLeftOpenTag: options.canBeLeftOpenTag,
    shouldDecodeNewlines: options.shouldDecodeNewlines,
    shouldDecodeNewlinesForHref: options.shouldDecodeNewlinesForHref,
    shouldKeepComment: options.comments,
    outputSourceRange: options.outputSourceRange,
    start: function start (tag, attrs, unary, start$1, end) {
      // check namespace.
      // inherit parent ns if there is one
      var ns = (currentParent && currentParent.ns) || platformGetTagNamespace(tag);

      // handle IE svg bug
      /* istanbul ignore if */
      if (isIE && ns === 'svg') {
        attrs = guardIESVGBug(attrs);
      }

      var element = createASTElement(tag, attrs, currentParent);
      if (ns) {
        element.ns = ns;
      }

      if (true) {
        if (options.outputSourceRange) {
          element.start = start$1;
          element.end = end;
          element.rawAttrsMap = element.attrsList.reduce(function (cumulated, attr) {
            cumulated[attr.name] = attr;
            return cumulated
          }, {});
        }
        attrs.forEach(function (attr) {
          if (invalidAttributeRE.test(attr.name)) {
            warn$2(
              "Invalid dynamic argument expression: attribute names cannot contain " +
              "spaces, quotes, <, >, / or =.",
              {
                start: attr.start + attr.name.indexOf("["),
                end: attr.start + attr.name.length
              }
            );
          }
        });
      }

      if (isForbiddenTag(element) && !isServerRendering()) {
        element.forbidden = true;
         true && warn$2(
          'Templates should only be responsible for mapping the state to the ' +
          'UI. Avoid placing tags with side-effects in your templates, such as ' +
          "<" + tag + ">" + ', as they will not be parsed.',
          { start: element.start }
        );
      }

      // apply pre-transforms
      for (var i = 0; i < preTransforms.length; i++) {
        element = preTransforms[i](element, options) || element;
      }

      if (!inVPre) {
        processPre(element);
        if (element.pre) {
          inVPre = true;
        }
      }
      if (platformIsPreTag(element.tag)) {
        inPre = true;
      }
      if (inVPre) {
        processRawAttrs(element);
      } else if (!element.processed) {
        // structural directives
        processFor(element);
        processIf(element);
        processOnce(element);
      }

      if (!root) {
        root = element;
        if (true) {
          checkRootConstraints(root);
        }
      }

      if (!unary) {
        currentParent = element;
        stack.push(element);
      } else {
        closeElement(element);
      }
    },

    end: function end (tag, start, end$1) {
      var element = stack[stack.length - 1];
      // pop stack
      stack.length -= 1;
      currentParent = stack[stack.length - 1];
      if ( true && options.outputSourceRange) {
        element.end = end$1;
      }
      closeElement(element);
    },

    chars: function chars (text, start, end) {
      if (!currentParent) {
        if (true) {
          if (text === template) {
            warnOnce(
              'Component template requires a root element, rather than just text.',
              { start: start }
            );
          } else if ((text = text.trim())) {
            warnOnce(
              ("text \"" + text + "\" outside root element will be ignored."),
              { start: start }
            );
          }
        }
        return
      }
      // IE textarea placeholder bug
      /* istanbul ignore if */
      if (isIE &&
        currentParent.tag === 'textarea' &&
        currentParent.attrsMap.placeholder === text
      ) {
        return
      }
      var children = currentParent.children;
      if (inPre || text.trim()) {
        text = isTextTag(currentParent) ? text : decodeHTMLCached(text);
      } else if (!children.length) {
        // remove the whitespace-only node right after an opening tag
        text = '';
      } else if (whitespaceOption) {
        if (whitespaceOption === 'condense') {
          // in condense mode, remove the whitespace node if it contains
          // line break, otherwise condense to a single space
          text = lineBreakRE.test(text) ? '' : ' ';
        } else {
          text = ' ';
        }
      } else {
        text = preserveWhitespace ? ' ' : '';
      }
      if (text) {
        if (!inPre && whitespaceOption === 'condense') {
          // condense consecutive whitespaces into single space
          text = text.replace(whitespaceRE$1, ' ');
        }
        var res;
        var child;
        if (!inVPre && text !== ' ' && (res = parseText(text, delimiters))) {
          child = {
            type: 2,
            expression: res.expression,
            tokens: res.tokens,
            text: text
          };
        } else if (text !== ' ' || !children.length || children[children.length - 1].text !== ' ') {
          child = {
            type: 3,
            text: text
          };
        }
        if (child) {
          if ( true && options.outputSourceRange) {
            child.start = start;
            child.end = end;
          }
          children.push(child);
        }
      }
    },
    comment: function comment (text, start, end) {
      // adding anything as a sibling to the root node is forbidden
      // comments should still be allowed, but ignored
      if (currentParent) {
        var child = {
          type: 3,
          text: text,
          isComment: true
        };
        if ( true && options.outputSourceRange) {
          child.start = start;
          child.end = end;
        }
        currentParent.children.push(child);
      }
    }
  });
  return root
}

function processPre (el) {
  if (getAndRemoveAttr(el, 'v-pre') != null) {
    el.pre = true;
  }
}

function processRawAttrs (el) {
  var list = el.attrsList;
  var len = list.length;
  if (len) {
    var attrs = el.attrs = new Array(len);
    for (var i = 0; i < len; i++) {
      attrs[i] = {
        name: list[i].name,
        value: JSON.stringify(list[i].value)
      };
      if (list[i].start != null) {
        attrs[i].start = list[i].start;
        attrs[i].end = list[i].end;
      }
    }
  } else if (!el.pre) {
    // non root node in pre blocks with no attributes
    el.plain = true;
  }
}

function processElement (
  element,
  options
) {
  processKey(element);

  // determine whether this is a plain element after
  // removing structural attributes
  element.plain = (
    !element.key &&
    !element.scopedSlots &&
    !element.attrsList.length
  );

  processRef(element);
  processSlotContent(element);
  processSlotOutlet(element);
  processComponent(element);
  for (var i = 0; i < transforms.length; i++) {
    element = transforms[i](element, options) || element;
  }
  processAttrs(element);
  return element
}

function processKey (el) {
  var exp = getBindingAttr(el, 'key');
  if (exp) {
    if (true) {
      if (el.tag === 'template') {
        warn$2(
          "<template> cannot be keyed. Place the key on real elements instead.",
          getRawBindingAttr(el, 'key')
        );
      }
      if (el.for) {
        var iterator = el.iterator2 || el.iterator1;
        var parent = el.parent;
        if (iterator && iterator === exp && parent && parent.tag === 'transition-group') {
          warn$2(
            "Do not use v-for index as key on <transition-group> children, " +
            "this is the same as not using keys.",
            getRawBindingAttr(el, 'key'),
            true /* tip */
          );
        }
      }
    }
    el.key = exp;
  }
}

function processRef (el) {
  var ref = getBindingAttr(el, 'ref');
  if (ref) {
    el.ref = ref;
    el.refInFor = checkInFor(el);
  }
}

function processFor (el) {
  var exp;
  if ((exp = getAndRemoveAttr(el, 'v-for'))) {
    var res = parseFor(exp);
    if (res) {
      extend(el, res);
    } else if (true) {
      warn$2(
        ("Invalid v-for expression: " + exp),
        el.rawAttrsMap['v-for']
      );
    }
  }
}



function parseFor (exp) {
  var inMatch = exp.match(forAliasRE);
  if (!inMatch) { return }
  var res = {};
  res.for = inMatch[2].trim();
  var alias = inMatch[1].trim().replace(stripParensRE, '');
  var iteratorMatch = alias.match(forIteratorRE);
  if (iteratorMatch) {
    res.alias = alias.replace(forIteratorRE, '').trim();
    res.iterator1 = iteratorMatch[1].trim();
    if (iteratorMatch[2]) {
      res.iterator2 = iteratorMatch[2].trim();
    }
  } else {
    res.alias = alias;
  }
  return res
}

function processIf (el) {
  var exp = getAndRemoveAttr(el, 'v-if');
  if (exp) {
    el.if = exp;
    addIfCondition(el, {
      exp: exp,
      block: el
    });
  } else {
    if (getAndRemoveAttr(el, 'v-else') != null) {
      el.else = true;
    }
    var elseif = getAndRemoveAttr(el, 'v-else-if');
    if (elseif) {
      el.elseif = elseif;
    }
  }
}

function processIfConditions (el, parent) {
  var prev = findPrevElement(parent.children);
  if (prev && prev.if) {
    addIfCondition(prev, {
      exp: el.elseif,
      block: el
    });
  } else if (true) {
    warn$2(
      "v-" + (el.elseif ? ('else-if="' + el.elseif + '"') : 'else') + " " +
      "used on element <" + (el.tag) + "> without corresponding v-if.",
      el.rawAttrsMap[el.elseif ? 'v-else-if' : 'v-else']
    );
  }
}

function findPrevElement (children) {
  var i = children.length;
  while (i--) {
    if (children[i].type === 1) {
      return children[i]
    } else {
      if ( true && children[i].text !== ' ') {
        warn$2(
          "text \"" + (children[i].text.trim()) + "\" between v-if and v-else(-if) " +
          "will be ignored.",
          children[i]
        );
      }
      children.pop();
    }
  }
}

function addIfCondition (el, condition) {
  if (!el.ifConditions) {
    el.ifConditions = [];
  }
  el.ifConditions.push(condition);
}

function processOnce (el) {
  var once$$1 = getAndRemoveAttr(el, 'v-once');
  if (once$$1 != null) {
    el.once = true;
  }
}

// handle content being passed to a component as slot,
// e.g. <template slot="xxx">, <div slot-scope="xxx">
function processSlotContent (el) {
  var slotScope;
  if (el.tag === 'template') {
    slotScope = getAndRemoveAttr(el, 'scope');
    /* istanbul ignore if */
    if ( true && slotScope) {
      warn$2(
        "the \"scope\" attribute for scoped slots have been deprecated and " +
        "replaced by \"slot-scope\" since 2.5. The new \"slot-scope\" attribute " +
        "can also be used on plain elements in addition to <template> to " +
        "denote scoped slots.",
        el.rawAttrsMap['scope'],
        true
      );
    }
    el.slotScope = slotScope || getAndRemoveAttr(el, 'slot-scope');
  } else if ((slotScope = getAndRemoveAttr(el, 'slot-scope'))) {
    /* istanbul ignore if */
    if ( true && el.attrsMap['v-for']) {
      warn$2(
        "Ambiguous combined usage of slot-scope and v-for on <" + (el.tag) + "> " +
        "(v-for takes higher priority). Use a wrapper <template> for the " +
        "scoped slot to make it clearer.",
        el.rawAttrsMap['slot-scope'],
        true
      );
    }
    el.slotScope = slotScope;
  }

  // slot="xxx"
  var slotTarget = getBindingAttr(el, 'slot');
  if (slotTarget) {
    el.slotTarget = slotTarget === '""' ? '"default"' : slotTarget;
    el.slotTargetDynamic = !!(el.attrsMap[':slot'] || el.attrsMap['v-bind:slot']);
    // preserve slot as an attribute for native shadow DOM compat
    // only for non-scoped slots.
    if (el.tag !== 'template' && !el.slotScope) {
      addAttr(el, 'slot', slotTarget, getRawBindingAttr(el, 'slot'));
    }
  }

  // 2.6 v-slot syntax
  {
    if (el.tag === 'template') {
      // v-slot on <template>
      var slotBinding = getAndRemoveAttrByRegex(el, slotRE);
      if (slotBinding) {
        if (true) {
          if (el.slotTarget || el.slotScope) {
            warn$2(
              "Unexpected mixed usage of different slot syntaxes.",
              el
            );
          }
          if (el.parent && !maybeComponent(el.parent)) {
            warn$2(
              "<template v-slot> can only appear at the root level inside " +
              "the receiving component",
              el
            );
          }
        }
        var ref = getSlotName(slotBinding);
        var name = ref.name;
        var dynamic = ref.dynamic;
        el.slotTarget = name;
        el.slotTargetDynamic = dynamic;
        el.slotScope = slotBinding.value || emptySlotScopeToken; // force it into a scoped slot for perf
      }
    } else {
      // v-slot on component, denotes default slot
      var slotBinding$1 = getAndRemoveAttrByRegex(el, slotRE);
      if (slotBinding$1) {
        if (true) {
          if (!maybeComponent(el)) {
            warn$2(
              "v-slot can only be used on components or <template>.",
              slotBinding$1
            );
          }
          if (el.slotScope || el.slotTarget) {
            warn$2(
              "Unexpected mixed usage of different slot syntaxes.",
              el
            );
          }
          if (el.scopedSlots) {
            warn$2(
              "To avoid scope ambiguity, the default slot should also use " +
              "<template> syntax when there are other named slots.",
              slotBinding$1
            );
          }
        }
        // add the component's children to its default slot
        var slots = el.scopedSlots || (el.scopedSlots = {});
        var ref$1 = getSlotName(slotBinding$1);
        var name$1 = ref$1.name;
        var dynamic$1 = ref$1.dynamic;
        var slotContainer = slots[name$1] = createASTElement('template', [], el);
        slotContainer.slotTarget = name$1;
        slotContainer.slotTargetDynamic = dynamic$1;
        slotContainer.children = el.children.filter(function (c) {
          if (!c.slotScope) {
            c.parent = slotContainer;
            return true
          }
        });
        slotContainer.slotScope = slotBinding$1.value || emptySlotScopeToken;
        // remove children as they are returned from scopedSlots now
        el.children = [];
        // mark el non-plain so data gets generated
        el.plain = false;
      }
    }
  }
}

function getSlotName (binding) {
  var name = binding.name.replace(slotRE, '');
  if (!name) {
    if (binding.name[0] !== '#') {
      name = 'default';
    } else if (true) {
      warn$2(
        "v-slot shorthand syntax requires a slot name.",
        binding
      );
    }
  }
  return dynamicArgRE.test(name)
    // dynamic [name]
    ? { name: name.slice(1, -1), dynamic: true }
    // static name
    : { name: ("\"" + name + "\""), dynamic: false }
}

// handle <slot/> outlets
function processSlotOutlet (el) {
  if (el.tag === 'slot') {
    el.slotName = getBindingAttr(el, 'name');
    if ( true && el.key) {
      warn$2(
        "`key` does not work on <slot> because slots are abstract outlets " +
        "and can possibly expand into multiple elements. " +
        "Use the key on a wrapping element instead.",
        getRawBindingAttr(el, 'key')
      );
    }
  }
}

function processComponent (el) {
  var binding;
  if ((binding = getBindingAttr(el, 'is'))) {
    el.component = binding;
  }
  if (getAndRemoveAttr(el, 'inline-template') != null) {
    el.inlineTemplate = true;
  }
}

function processAttrs (el) {
  var list = el.attrsList;
  var i, l, name, rawName, value, modifiers, syncGen, isDynamic;
  for (i = 0, l = list.length; i < l; i++) {
    name = rawName = list[i].name;
    value = list[i].value;
    if (dirRE.test(name)) {
      // mark element as dynamic
      el.hasBindings = true;
      // modifiers
      modifiers = parseModifiers(name.replace(dirRE, ''));
      // support .foo shorthand syntax for the .prop modifier
      if (modifiers) {
        name = name.replace(modifierRE, '');
      }
      if (bindRE.test(name)) { // v-bind
        name = name.replace(bindRE, '');
        value = parseFilters(value);
        isDynamic = dynamicArgRE.test(name);
        if (isDynamic) {
          name = name.slice(1, -1);
        }
        if (
           true &&
          value.trim().length === 0
        ) {
          warn$2(
            ("The value for a v-bind expression cannot be empty. Found in \"v-bind:" + name + "\"")
          );
        }
        if (modifiers) {
          if (modifiers.prop && !isDynamic) {
            name = camelize(name);
            if (name === 'innerHtml') { name = 'innerHTML'; }
          }
          if (modifiers.camel && !isDynamic) {
            name = camelize(name);
          }
          if (modifiers.sync) {
            syncGen = genAssignmentCode(value, "$event");
            if (!isDynamic) {
              addHandler(
                el,
                ("update:" + (camelize(name))),
                syncGen,
                null,
                false,
                warn$2,
                list[i]
              );
              if (hyphenate(name) !== camelize(name)) {
                addHandler(
                  el,
                  ("update:" + (hyphenate(name))),
                  syncGen,
                  null,
                  false,
                  warn$2,
                  list[i]
                );
              }
            } else {
              // handler w/ dynamic event name
              addHandler(
                el,
                ("\"update:\"+(" + name + ")"),
                syncGen,
                null,
                false,
                warn$2,
                list[i],
                true // dynamic
              );
            }
          }
        }
        if ((modifiers && modifiers.prop) || (
          !el.component && platformMustUseProp(el.tag, el.attrsMap.type, name)
        )) {
          addProp(el, name, value, list[i], isDynamic);
        } else {
          addAttr(el, name, value, list[i], isDynamic);
        }
      } else if (onRE.test(name)) { // v-on
        name = name.replace(onRE, '');
        isDynamic = dynamicArgRE.test(name);
        if (isDynamic) {
          name = name.slice(1, -1);
        }
        addHandler(el, name, value, modifiers, false, warn$2, list[i], isDynamic);
      } else { // normal directives
        name = name.replace(dirRE, '');
        // parse arg
        var argMatch = name.match(argRE);
        var arg = argMatch && argMatch[1];
        isDynamic = false;
        if (arg) {
          name = name.slice(0, -(arg.length + 1));
          if (dynamicArgRE.test(arg)) {
            arg = arg.slice(1, -1);
            isDynamic = true;
          }
        }
        addDirective(el, name, rawName, value, arg, isDynamic, modifiers, list[i]);
        if ( true && name === 'model') {
          checkForAliasModel(el, value);
        }
      }
    } else {
      // literal attribute
      if (true) {
        var res = parseText(value, delimiters);
        if (res) {
          warn$2(
            name + "=\"" + value + "\": " +
            'Interpolation inside attributes has been removed. ' +
            'Use v-bind or the colon shorthand instead. For example, ' +
            'instead of <div id="{{ val }}">, use <div :id="val">.',
            list[i]
          );
        }
      }
      addAttr(el, name, JSON.stringify(value), list[i]);
      // #6887 firefox doesn't update muted state if set via attribute
      // even immediately after element creation
      if (!el.component &&
          name === 'muted' &&
          platformMustUseProp(el.tag, el.attrsMap.type, name)) {
        addProp(el, name, 'true', list[i]);
      }
    }
  }
}

function checkInFor (el) {
  var parent = el;
  while (parent) {
    if (parent.for !== undefined) {
      return true
    }
    parent = parent.parent;
  }
  return false
}

function parseModifiers (name) {
  var match = name.match(modifierRE);
  if (match) {
    var ret = {};
    match.forEach(function (m) { ret[m.slice(1)] = true; });
    return ret
  }
}

function makeAttrsMap (attrs) {
  var map = {};
  for (var i = 0, l = attrs.length; i < l; i++) {
    if (
       true &&
      map[attrs[i].name] && !isIE && !isEdge
    ) {
      warn$2('duplicate attribute: ' + attrs[i].name, attrs[i]);
    }
    map[attrs[i].name] = attrs[i].value;
  }
  return map
}

// for script (e.g. type="x/template") or style, do not decode content
function isTextTag (el) {
  return el.tag === 'script' || el.tag === 'style'
}

function isForbiddenTag (el) {
  return (
    el.tag === 'style' ||
    (el.tag === 'script' && (
      !el.attrsMap.type ||
      el.attrsMap.type === 'text/javascript'
    ))
  )
}

var ieNSBug = /^xmlns:NS\d+/;
var ieNSPrefix = /^NS\d+:/;

/* istanbul ignore next */
function guardIESVGBug (attrs) {
  var res = [];
  for (var i = 0; i < attrs.length; i++) {
    var attr = attrs[i];
    if (!ieNSBug.test(attr.name)) {
      attr.name = attr.name.replace(ieNSPrefix, '');
      res.push(attr);
    }
  }
  return res
}

function checkForAliasModel (el, value) {
  var _el = el;
  while (_el) {
    if (_el.for && _el.alias === value) {
      warn$2(
        "<" + (el.tag) + " v-model=\"" + value + "\">: " +
        "You are binding v-model directly to a v-for iteration alias. " +
        "This will not be able to modify the v-for source array because " +
        "writing to the alias is like modifying a function local variable. " +
        "Consider using an array of objects and use v-model on an object property instead.",
        el.rawAttrsMap['v-model']
      );
    }
    _el = _el.parent;
  }
}

/*  */

function preTransformNode (el, options) {
  if (el.tag === 'input') {
    var map = el.attrsMap;
    if (!map['v-model']) {
      return
    }

    var typeBinding;
    if (map[':type'] || map['v-bind:type']) {
      typeBinding = getBindingAttr(el, 'type');
    }
    if (!map.type && !typeBinding && map['v-bind']) {
      typeBinding = "(" + (map['v-bind']) + ").type";
    }

    if (typeBinding) {
      var ifCondition = getAndRemoveAttr(el, 'v-if', true);
      var ifConditionExtra = ifCondition ? ("&&(" + ifCondition + ")") : "";
      var hasElse = getAndRemoveAttr(el, 'v-else', true) != null;
      var elseIfCondition = getAndRemoveAttr(el, 'v-else-if', true);
      // 1. checkbox
      var branch0 = cloneASTElement(el);
      // process for on the main node
      processFor(branch0);
      addRawAttr(branch0, 'type', 'checkbox');
      processElement(branch0, options);
      branch0.processed = true; // prevent it from double-processed
      branch0.if = "(" + typeBinding + ")==='checkbox'" + ifConditionExtra;
      addIfCondition(branch0, {
        exp: branch0.if,
        block: branch0
      });
      // 2. add radio else-if condition
      var branch1 = cloneASTElement(el);
      getAndRemoveAttr(branch1, 'v-for', true);
      addRawAttr(branch1, 'type', 'radio');
      processElement(branch1, options);
      addIfCondition(branch0, {
        exp: "(" + typeBinding + ")==='radio'" + ifConditionExtra,
        block: branch1
      });
      // 3. other
      var branch2 = cloneASTElement(el);
      getAndRemoveAttr(branch2, 'v-for', true);
      addRawAttr(branch2, ':type', typeBinding);
      processElement(branch2, options);
      addIfCondition(branch0, {
        exp: ifCondition,
        block: branch2
      });

      if (hasElse) {
        branch0.else = true;
      } else if (elseIfCondition) {
        branch0.elseif = elseIfCondition;
      }

      return branch0
    }
  }
}

function cloneASTElement (el) {
  return createASTElement(el.tag, el.attrsList.slice(), el.parent)
}

var model$1 = {
  preTransformNode: preTransformNode
};

var modules$1 = [
  klass$1,
  style$1,
  model$1
];

/*  */

function text (el, dir) {
  if (dir.value) {
    addProp(el, 'textContent', ("_s(" + (dir.value) + ")"), dir);
  }
}

/*  */

function html (el, dir) {
  if (dir.value) {
    addProp(el, 'innerHTML', ("_s(" + (dir.value) + ")"), dir);
  }
}

var directives$1 = {
  model: model,
  text: text,
  html: html
};

/*  */

var baseOptions = {
  expectHTML: true,
  modules: modules$1,
  directives: directives$1,
  isPreTag: isPreTag,
  isUnaryTag: isUnaryTag,
  mustUseProp: mustUseProp,
  canBeLeftOpenTag: canBeLeftOpenTag,
  isReservedTag: isReservedTag,
  getTagNamespace: getTagNamespace,
  staticKeys: genStaticKeys(modules$1)
};

/*  */

var isStaticKey;
var isPlatformReservedTag;

var genStaticKeysCached = cached(genStaticKeys$1);

/**
 * Goal of the optimizer: walk the generated template AST tree
 * and detect sub-trees that are purely static, i.e. parts of
 * the DOM that never needs to change.
 *
 * Once we detect these sub-trees, we can:
 *
 * 1. Hoist them into constants, so that we no longer need to
 *    create fresh nodes for them on each re-render;
 * 2. Completely skip them in the patching process.
 */
function optimize (root, options) {
  if (!root) { return }
  isStaticKey = genStaticKeysCached(options.staticKeys || '');
  isPlatformReservedTag = options.isReservedTag || no;
  // first pass: mark all non-static nodes.
  markStatic$1(root);
  // second pass: mark static roots.
  markStaticRoots(root, false);
}

function genStaticKeys$1 (keys) {
  return makeMap(
    'type,tag,attrsList,attrsMap,plain,parent,children,attrs,start,end,rawAttrsMap' +
    (keys ? ',' + keys : '')
  )
}

function markStatic$1 (node) {
  node.static = isStatic(node);
  if (node.type === 1) {
    // do not make component slot content static. this avoids
    // 1. components not able to mutate slot nodes
    // 2. static slot content fails for hot-reloading
    if (
      !isPlatformReservedTag(node.tag) &&
      node.tag !== 'slot' &&
      node.attrsMap['inline-template'] == null
    ) {
      return
    }
    for (var i = 0, l = node.children.length; i < l; i++) {
      var child = node.children[i];
      markStatic$1(child);
      if (!child.static) {
        node.static = false;
      }
    }
    if (node.ifConditions) {
      for (var i$1 = 1, l$1 = node.ifConditions.length; i$1 < l$1; i$1++) {
        var block = node.ifConditions[i$1].block;
        markStatic$1(block);
        if (!block.static) {
          node.static = false;
        }
      }
    }
  }
}

function markStaticRoots (node, isInFor) {
  if (node.type === 1) {
    if (node.static || node.once) {
      node.staticInFor = isInFor;
    }
    // For a node to qualify as a static root, it should have children that
    // are not just static text. Otherwise the cost of hoisting out will
    // outweigh the benefits and it's better off to just always render it fresh.
    if (node.static && node.children.length && !(
      node.children.length === 1 &&
      node.children[0].type === 3
    )) {
      node.staticRoot = true;
      return
    } else {
      node.staticRoot = false;
    }
    if (node.children) {
      for (var i = 0, l = node.children.length; i < l; i++) {
        markStaticRoots(node.children[i], isInFor || !!node.for);
      }
    }
    if (node.ifConditions) {
      for (var i$1 = 1, l$1 = node.ifConditions.length; i$1 < l$1; i$1++) {
        markStaticRoots(node.ifConditions[i$1].block, isInFor);
      }
    }
  }
}

function isStatic (node) {
  if (node.type === 2) { // expression
    return false
  }
  if (node.type === 3) { // text
    return true
  }
  return !!(node.pre || (
    !node.hasBindings && // no dynamic bindings
    !node.if && !node.for && // not v-if or v-for or v-else
    !isBuiltInTag(node.tag) && // not a built-in
    isPlatformReservedTag(node.tag) && // not a component
    !isDirectChildOfTemplateFor(node) &&
    Object.keys(node).every(isStaticKey)
  ))
}

function isDirectChildOfTemplateFor (node) {
  while (node.parent) {
    node = node.parent;
    if (node.tag !== 'template') {
      return false
    }
    if (node.for) {
      return true
    }
  }
  return false
}

/*  */

var fnExpRE = /^([\w$_]+|\([^)]*?\))\s*=>|^function(?:\s+[\w$]+)?\s*\(/;
var fnInvokeRE = /\([^)]*?\);*$/;
var simplePathRE = /^[A-Za-z_$][\w$]*(?:\.[A-Za-z_$][\w$]*|\['[^']*?']|\["[^"]*?"]|\[\d+]|\[[A-Za-z_$][\w$]*])*$/;

// KeyboardEvent.keyCode aliases
var keyCodes = {
  esc: 27,
  tab: 9,
  enter: 13,
  space: 32,
  up: 38,
  left: 37,
  right: 39,
  down: 40,
  'delete': [8, 46]
};

// KeyboardEvent.key aliases
var keyNames = {
  // #7880: IE11 and Edge use `Esc` for Escape key name.
  esc: ['Esc', 'Escape'],
  tab: 'Tab',
  enter: 'Enter',
  // #9112: IE11 uses `Spacebar` for Space key name.
  space: [' ', 'Spacebar'],
  // #7806: IE11 uses key names without `Arrow` prefix for arrow keys.
  up: ['Up', 'ArrowUp'],
  left: ['Left', 'ArrowLeft'],
  right: ['Right', 'ArrowRight'],
  down: ['Down', 'ArrowDown'],
  // #9112: IE11 uses `Del` for Delete key name.
  'delete': ['Backspace', 'Delete', 'Del']
};

// #4868: modifiers that prevent the execution of the listener
// need to explicitly return null so that we can determine whether to remove
// the listener for .once
var genGuard = function (condition) { return ("if(" + condition + ")return null;"); };

var modifierCode = {
  stop: '$event.stopPropagation();',
  prevent: '$event.preventDefault();',
  self: genGuard("$event.target !== $event.currentTarget"),
  ctrl: genGuard("!$event.ctrlKey"),
  shift: genGuard("!$event.shiftKey"),
  alt: genGuard("!$event.altKey"),
  meta: genGuard("!$event.metaKey"),
  left: genGuard("'button' in $event && $event.button !== 0"),
  middle: genGuard("'button' in $event && $event.button !== 1"),
  right: genGuard("'button' in $event && $event.button !== 2")
};

function genHandlers (
  events,
  isNative
) {
  var prefix = isNative ? 'nativeOn:' : 'on:';
  var staticHandlers = "";
  var dynamicHandlers = "";
  for (var name in events) {
    var handlerCode = genHandler(events[name]);
    if (events[name] && events[name].dynamic) {
      dynamicHandlers += name + "," + handlerCode + ",";
    } else {
      staticHandlers += "\"" + name + "\":" + handlerCode + ",";
    }
  }
  staticHandlers = "{" + (staticHandlers.slice(0, -1)) + "}";
  if (dynamicHandlers) {
    return prefix + "_d(" + staticHandlers + ",[" + (dynamicHandlers.slice(0, -1)) + "])"
  } else {
    return prefix + staticHandlers
  }
}

function genHandler (handler) {
  if (!handler) {
    return 'function(){}'
  }

  if (Array.isArray(handler)) {
    return ("[" + (handler.map(function (handler) { return genHandler(handler); }).join(',')) + "]")
  }

  var isMethodPath = simplePathRE.test(handler.value);
  var isFunctionExpression = fnExpRE.test(handler.value);
  var isFunctionInvocation = simplePathRE.test(handler.value.replace(fnInvokeRE, ''));

  if (!handler.modifiers) {
    if (isMethodPath || isFunctionExpression) {
      return handler.value
    }
    return ("function($event){" + (isFunctionInvocation ? ("return " + (handler.value)) : handler.value) + "}") // inline statement
  } else {
    var code = '';
    var genModifierCode = '';
    var keys = [];
    for (var key in handler.modifiers) {
      if (modifierCode[key]) {
        genModifierCode += modifierCode[key];
        // left/right
        if (keyCodes[key]) {
          keys.push(key);
        }
      } else if (key === 'exact') {
        var modifiers = (handler.modifiers);
        genModifierCode += genGuard(
          ['ctrl', 'shift', 'alt', 'meta']
            .filter(function (keyModifier) { return !modifiers[keyModifier]; })
            .map(function (keyModifier) { return ("$event." + keyModifier + "Key"); })
            .join('||')
        );
      } else {
        keys.push(key);
      }
    }
    if (keys.length) {
      code += genKeyFilter(keys);
    }
    // Make sure modifiers like prevent and stop get executed after key filtering
    if (genModifierCode) {
      code += genModifierCode;
    }
    var handlerCode = isMethodPath
      ? ("return " + (handler.value) + ".apply(null, arguments)")
      : isFunctionExpression
        ? ("return (" + (handler.value) + ").apply(null, arguments)")
        : isFunctionInvocation
          ? ("return " + (handler.value))
          : handler.value;
    return ("function($event){" + code + handlerCode + "}")
  }
}

function genKeyFilter (keys) {
  return (
    // make sure the key filters only apply to KeyboardEvents
    // #9441: can't use 'keyCode' in $event because Chrome autofill fires fake
    // key events that do not have keyCode property...
    "if(!$event.type.indexOf('key')&&" +
    (keys.map(genFilterCode).join('&&')) + ")return null;"
  )
}

function genFilterCode (key) {
  var keyVal = parseInt(key, 10);
  if (keyVal) {
    return ("$event.keyCode!==" + keyVal)
  }
  var keyCode = keyCodes[key];
  var keyName = keyNames[key];
  return (
    "_k($event.keyCode," +
    (JSON.stringify(key)) + "," +
    (JSON.stringify(keyCode)) + "," +
    "$event.key," +
    "" + (JSON.stringify(keyName)) +
    ")"
  )
}

/*  */

function on (el, dir) {
  if ( true && dir.modifiers) {
    warn("v-on without argument does not support modifiers.");
  }
  el.wrapListeners = function (code) { return ("_g(" + code + "," + (dir.value) + ")"); };
}

/*  */

function bind$1 (el, dir) {
  el.wrapData = function (code) {
    return ("_b(" + code + ",'" + (el.tag) + "'," + (dir.value) + "," + (dir.modifiers && dir.modifiers.prop ? 'true' : 'false') + (dir.modifiers && dir.modifiers.sync ? ',true' : '') + ")")
  };
}

/*  */

var baseDirectives = {
  on: on,
  bind: bind$1,
  cloak: noop
};

/*  */





var CodegenState = function CodegenState (options) {
  this.options = options;
  this.warn = options.warn || baseWarn;
  this.transforms = pluckModuleFunction(options.modules, 'transformCode');
  this.dataGenFns = pluckModuleFunction(options.modules, 'genData');
  this.directives = extend(extend({}, baseDirectives), options.directives);
  var isReservedTag = options.isReservedTag || no;
  this.maybeComponent = function (el) { return !!el.component || !isReservedTag(el.tag); };
  this.onceId = 0;
  this.staticRenderFns = [];
  this.pre = false;
};



function generate (
  ast,
  options
) {
  var state = new CodegenState(options);
  // fix #11483, Root level <script> tags should not be rendered.
  var code = ast ? (ast.tag === 'script' ? 'null' : genElement(ast, state)) : '_c("div")';
  return {
    render: ("with(this){return " + code + "}"),
    staticRenderFns: state.staticRenderFns
  }
}

function genElement (el, state) {
  if (el.parent) {
    el.pre = el.pre || el.parent.pre;
  }

  if (el.staticRoot && !el.staticProcessed) {
    return genStatic(el, state)
  } else if (el.once && !el.onceProcessed) {
    return genOnce(el, state)
  } else if (el.for && !el.forProcessed) {
    return genFor(el, state)
  } else if (el.if && !el.ifProcessed) {
    return genIf(el, state)
  } else if (el.tag === 'template' && !el.slotTarget && !state.pre) {
    return genChildren(el, state) || 'void 0'
  } else if (el.tag === 'slot') {
    return genSlot(el, state)
  } else {
    // component or element
    var code;
    if (el.component) {
      code = genComponent(el.component, el, state);
    } else {
      var data;
      if (!el.plain || (el.pre && state.maybeComponent(el))) {
        data = genData$2(el, state);
      }

      var children = el.inlineTemplate ? null : genChildren(el, state, true);
      code = "_c('" + (el.tag) + "'" + (data ? ("," + data) : '') + (children ? ("," + children) : '') + ")";
    }
    // module transforms
    for (var i = 0; i < state.transforms.length; i++) {
      code = state.transforms[i](el, code);
    }
    return code
  }
}

// hoist static sub-trees out
function genStatic (el, state) {
  el.staticProcessed = true;
  // Some elements (templates) need to behave differently inside of a v-pre
  // node.  All pre nodes are static roots, so we can use this as a location to
  // wrap a state change and reset it upon exiting the pre node.
  var originalPreState = state.pre;
  if (el.pre) {
    state.pre = el.pre;
  }
  state.staticRenderFns.push(("with(this){return " + (genElement(el, state)) + "}"));
  state.pre = originalPreState;
  return ("_m(" + (state.staticRenderFns.length - 1) + (el.staticInFor ? ',true' : '') + ")")
}

// v-once
function genOnce (el, state) {
  el.onceProcessed = true;
  if (el.if && !el.ifProcessed) {
    return genIf(el, state)
  } else if (el.staticInFor) {
    var key = '';
    var parent = el.parent;
    while (parent) {
      if (parent.for) {
        key = parent.key;
        break
      }
      parent = parent.parent;
    }
    if (!key) {
       true && state.warn(
        "v-once can only be used inside v-for that is keyed. ",
        el.rawAttrsMap['v-once']
      );
      return genElement(el, state)
    }
    return ("_o(" + (genElement(el, state)) + "," + (state.onceId++) + "," + key + ")")
  } else {
    return genStatic(el, state)
  }
}

function genIf (
  el,
  state,
  altGen,
  altEmpty
) {
  el.ifProcessed = true; // avoid recursion
  return genIfConditions(el.ifConditions.slice(), state, altGen, altEmpty)
}

function genIfConditions (
  conditions,
  state,
  altGen,
  altEmpty
) {
  if (!conditions.length) {
    return altEmpty || '_e()'
  }

  var condition = conditions.shift();
  if (condition.exp) {
    return ("(" + (condition.exp) + ")?" + (genTernaryExp(condition.block)) + ":" + (genIfConditions(conditions, state, altGen, altEmpty)))
  } else {
    return ("" + (genTernaryExp(condition.block)))
  }

  // v-if with v-once should generate code like (a)?_m(0):_m(1)
  function genTernaryExp (el) {
    return altGen
      ? altGen(el, state)
      : el.once
        ? genOnce(el, state)
        : genElement(el, state)
  }
}

function genFor (
  el,
  state,
  altGen,
  altHelper
) {
  var exp = el.for;
  var alias = el.alias;
  var iterator1 = el.iterator1 ? ("," + (el.iterator1)) : '';
  var iterator2 = el.iterator2 ? ("," + (el.iterator2)) : '';

  if ( true &&
    state.maybeComponent(el) &&
    el.tag !== 'slot' &&
    el.tag !== 'template' &&
    !el.key
  ) {
    state.warn(
      "<" + (el.tag) + " v-for=\"" + alias + " in " + exp + "\">: component lists rendered with " +
      "v-for should have explicit keys. " +
      "See https://vuejs.org/guide/list.html#key for more info.",
      el.rawAttrsMap['v-for'],
      true /* tip */
    );
  }

  el.forProcessed = true; // avoid recursion
  return (altHelper || '_l') + "((" + exp + ")," +
    "function(" + alias + iterator1 + iterator2 + "){" +
      "return " + ((altGen || genElement)(el, state)) +
    '})'
}

function genData$2 (el, state) {
  var data = '{';

  // directives first.
  // directives may mutate the el's other properties before they are generated.
  var dirs = genDirectives(el, state);
  if (dirs) { data += dirs + ','; }

  // key
  if (el.key) {
    data += "key:" + (el.key) + ",";
  }
  // ref
  if (el.ref) {
    data += "ref:" + (el.ref) + ",";
  }
  if (el.refInFor) {
    data += "refInFor:true,";
  }
  // pre
  if (el.pre) {
    data += "pre:true,";
  }
  // record original tag name for components using "is" attribute
  if (el.component) {
    data += "tag:\"" + (el.tag) + "\",";
  }
  // module data generation functions
  for (var i = 0; i < state.dataGenFns.length; i++) {
    data += state.dataGenFns[i](el);
  }
  // attributes
  if (el.attrs) {
    data += "attrs:" + (genProps(el.attrs)) + ",";
  }
  // DOM props
  if (el.props) {
    data += "domProps:" + (genProps(el.props)) + ",";
  }
  // event handlers
  if (el.events) {
    data += (genHandlers(el.events, false)) + ",";
  }
  if (el.nativeEvents) {
    data += (genHandlers(el.nativeEvents, true)) + ",";
  }
  // slot target
  // only for non-scoped slots
  if (el.slotTarget && !el.slotScope) {
    data += "slot:" + (el.slotTarget) + ",";
  }
  // scoped slots
  if (el.scopedSlots) {
    data += (genScopedSlots(el, el.scopedSlots, state)) + ",";
  }
  // component v-model
  if (el.model) {
    data += "model:{value:" + (el.model.value) + ",callback:" + (el.model.callback) + ",expression:" + (el.model.expression) + "},";
  }
  // inline-template
  if (el.inlineTemplate) {
    var inlineTemplate = genInlineTemplate(el, state);
    if (inlineTemplate) {
      data += inlineTemplate + ",";
    }
  }
  data = data.replace(/,$/, '') + '}';
  // v-bind dynamic argument wrap
  // v-bind with dynamic arguments must be applied using the same v-bind object
  // merge helper so that class/style/mustUseProp attrs are handled correctly.
  if (el.dynamicAttrs) {
    data = "_b(" + data + ",\"" + (el.tag) + "\"," + (genProps(el.dynamicAttrs)) + ")";
  }
  // v-bind data wrap
  if (el.wrapData) {
    data = el.wrapData(data);
  }
  // v-on data wrap
  if (el.wrapListeners) {
    data = el.wrapListeners(data);
  }
  return data
}

function genDirectives (el, state) {
  var dirs = el.directives;
  if (!dirs) { return }
  var res = 'directives:[';
  var hasRuntime = false;
  var i, l, dir, needRuntime;
  for (i = 0, l = dirs.length; i < l; i++) {
    dir = dirs[i];
    needRuntime = true;
    var gen = state.directives[dir.name];
    if (gen) {
      // compile-time directive that manipulates AST.
      // returns true if it also needs a runtime counterpart.
      needRuntime = !!gen(el, dir, state.warn);
    }
    if (needRuntime) {
      hasRuntime = true;
      res += "{name:\"" + (dir.name) + "\",rawName:\"" + (dir.rawName) + "\"" + (dir.value ? (",value:(" + (dir.value) + "),expression:" + (JSON.stringify(dir.value))) : '') + (dir.arg ? (",arg:" + (dir.isDynamicArg ? dir.arg : ("\"" + (dir.arg) + "\""))) : '') + (dir.modifiers ? (",modifiers:" + (JSON.stringify(dir.modifiers))) : '') + "},";
    }
  }
  if (hasRuntime) {
    return res.slice(0, -1) + ']'
  }
}

function genInlineTemplate (el, state) {
  var ast = el.children[0];
  if ( true && (
    el.children.length !== 1 || ast.type !== 1
  )) {
    state.warn(
      'Inline-template components must have exactly one child element.',
      { start: el.start }
    );
  }
  if (ast && ast.type === 1) {
    var inlineRenderFns = generate(ast, state.options);
    return ("inlineTemplate:{render:function(){" + (inlineRenderFns.render) + "},staticRenderFns:[" + (inlineRenderFns.staticRenderFns.map(function (code) { return ("function(){" + code + "}"); }).join(',')) + "]}")
  }
}

function genScopedSlots (
  el,
  slots,
  state
) {
  // by default scoped slots are considered "stable", this allows child
  // components with only scoped slots to skip forced updates from parent.
  // but in some cases we have to bail-out of this optimization
  // for example if the slot contains dynamic names, has v-if or v-for on them...
  var needsForceUpdate = el.for || Object.keys(slots).some(function (key) {
    var slot = slots[key];
    return (
      slot.slotTargetDynamic ||
      slot.if ||
      slot.for ||
      containsSlotChild(slot) // is passing down slot from parent which may be dynamic
    )
  });

  // #9534: if a component with scoped slots is inside a conditional branch,
  // it's possible for the same component to be reused but with different
  // compiled slot content. To avoid that, we generate a unique key based on
  // the generated code of all the slot contents.
  var needsKey = !!el.if;

  // OR when it is inside another scoped slot or v-for (the reactivity may be
  // disconnected due to the intermediate scope variable)
  // #9438, #9506
  // TODO: this can be further optimized by properly analyzing in-scope bindings
  // and skip force updating ones that do not actually use scope variables.
  if (!needsForceUpdate) {
    var parent = el.parent;
    while (parent) {
      if (
        (parent.slotScope && parent.slotScope !== emptySlotScopeToken) ||
        parent.for
      ) {
        needsForceUpdate = true;
        break
      }
      if (parent.if) {
        needsKey = true;
      }
      parent = parent.parent;
    }
  }

  var generatedSlots = Object.keys(slots)
    .map(function (key) { return genScopedSlot(slots[key], state); })
    .join(',');

  return ("scopedSlots:_u([" + generatedSlots + "]" + (needsForceUpdate ? ",null,true" : "") + (!needsForceUpdate && needsKey ? (",null,false," + (hash(generatedSlots))) : "") + ")")
}

function hash(str) {
  var hash = 5381;
  var i = str.length;
  while(i) {
    hash = (hash * 33) ^ str.charCodeAt(--i);
  }
  return hash >>> 0
}

function containsSlotChild (el) {
  if (el.type === 1) {
    if (el.tag === 'slot') {
      return true
    }
    return el.children.some(containsSlotChild)
  }
  return false
}

function genScopedSlot (
  el,
  state
) {
  var isLegacySyntax = el.attrsMap['slot-scope'];
  if (el.if && !el.ifProcessed && !isLegacySyntax) {
    return genIf(el, state, genScopedSlot, "null")
  }
  if (el.for && !el.forProcessed) {
    return genFor(el, state, genScopedSlot)
  }
  var slotScope = el.slotScope === emptySlotScopeToken
    ? ""
    : String(el.slotScope);
  var fn = "function(" + slotScope + "){" +
    "return " + (el.tag === 'template'
      ? el.if && isLegacySyntax
        ? ("(" + (el.if) + ")?" + (genChildren(el, state) || 'undefined') + ":undefined")
        : genChildren(el, state) || 'undefined'
      : genElement(el, state)) + "}";
  // reverse proxy v-slot without scope on this.$slots
  var reverseProxy = slotScope ? "" : ",proxy:true";
  return ("{key:" + (el.slotTarget || "\"default\"") + ",fn:" + fn + reverseProxy + "}")
}

function genChildren (
  el,
  state,
  checkSkip,
  altGenElement,
  altGenNode
) {
  var children = el.children;
  if (children.length) {
    var el$1 = children[0];
    // optimize single v-for
    if (children.length === 1 &&
      el$1.for &&
      el$1.tag !== 'template' &&
      el$1.tag !== 'slot'
    ) {
      var normalizationType = checkSkip
        ? state.maybeComponent(el$1) ? ",1" : ",0"
        : "";
      return ("" + ((altGenElement || genElement)(el$1, state)) + normalizationType)
    }
    var normalizationType$1 = checkSkip
      ? getNormalizationType(children, state.maybeComponent)
      : 0;
    var gen = altGenNode || genNode;
    return ("[" + (children.map(function (c) { return gen(c, state); }).join(',')) + "]" + (normalizationType$1 ? ("," + normalizationType$1) : ''))
  }
}

// determine the normalization needed for the children array.
// 0: no normalization needed
// 1: simple normalization needed (possible 1-level deep nested array)
// 2: full normalization needed
function getNormalizationType (
  children,
  maybeComponent
) {
  var res = 0;
  for (var i = 0; i < children.length; i++) {
    var el = children[i];
    if (el.type !== 1) {
      continue
    }
    if (needsNormalization(el) ||
        (el.ifConditions && el.ifConditions.some(function (c) { return needsNormalization(c.block); }))) {
      res = 2;
      break
    }
    if (maybeComponent(el) ||
        (el.ifConditions && el.ifConditions.some(function (c) { return maybeComponent(c.block); }))) {
      res = 1;
    }
  }
  return res
}

function needsNormalization (el) {
  return el.for !== undefined || el.tag === 'template' || el.tag === 'slot'
}

function genNode (node, state) {
  if (node.type === 1) {
    return genElement(node, state)
  } else if (node.type === 3 && node.isComment) {
    return genComment(node)
  } else {
    return genText(node)
  }
}

function genText (text) {
  return ("_v(" + (text.type === 2
    ? text.expression // no need for () because already wrapped in _s()
    : transformSpecialNewlines(JSON.stringify(text.text))) + ")")
}

function genComment (comment) {
  return ("_e(" + (JSON.stringify(comment.text)) + ")")
}

function genSlot (el, state) {
  var slotName = el.slotName || '"default"';
  var children = genChildren(el, state);
  var res = "_t(" + slotName + (children ? (",function(){return " + children + "}") : '');
  var attrs = el.attrs || el.dynamicAttrs
    ? genProps((el.attrs || []).concat(el.dynamicAttrs || []).map(function (attr) { return ({
        // slot props are camelized
        name: camelize(attr.name),
        value: attr.value,
        dynamic: attr.dynamic
      }); }))
    : null;
  var bind$$1 = el.attrsMap['v-bind'];
  if ((attrs || bind$$1) && !children) {
    res += ",null";
  }
  if (attrs) {
    res += "," + attrs;
  }
  if (bind$$1) {
    res += (attrs ? '' : ',null') + "," + bind$$1;
  }
  return res + ')'
}

// componentName is el.component, take it as argument to shun flow's pessimistic refinement
function genComponent (
  componentName,
  el,
  state
) {
  var children = el.inlineTemplate ? null : genChildren(el, state, true);
  return ("_c(" + componentName + "," + (genData$2(el, state)) + (children ? ("," + children) : '') + ")")
}

function genProps (props) {
  var staticProps = "";
  var dynamicProps = "";
  for (var i = 0; i < props.length; i++) {
    var prop = props[i];
    var value = transformSpecialNewlines(prop.value);
    if (prop.dynamic) {
      dynamicProps += (prop.name) + "," + value + ",";
    } else {
      staticProps += "\"" + (prop.name) + "\":" + value + ",";
    }
  }
  staticProps = "{" + (staticProps.slice(0, -1)) + "}";
  if (dynamicProps) {
    return ("_d(" + staticProps + ",[" + (dynamicProps.slice(0, -1)) + "])")
  } else {
    return staticProps
  }
}

// #3895, #4268
function transformSpecialNewlines (text) {
  return text
    .replace(/\u2028/g, '\\u2028')
    .replace(/\u2029/g, '\\u2029')
}

/*  */



// these keywords should not appear inside expressions, but operators like
// typeof, instanceof and in are allowed
var prohibitedKeywordRE = new RegExp('\\b' + (
  'do,if,for,let,new,try,var,case,else,with,await,break,catch,class,const,' +
  'super,throw,while,yield,delete,export,import,return,switch,default,' +
  'extends,finally,continue,debugger,function,arguments'
).split(',').join('\\b|\\b') + '\\b');

// these unary operators should not be used as property/method names
var unaryOperatorsRE = new RegExp('\\b' + (
  'delete,typeof,void'
).split(',').join('\\s*\\([^\\)]*\\)|\\b') + '\\s*\\([^\\)]*\\)');

// strip strings in expressions
var stripStringRE = /'(?:[^'\\]|\\.)*'|"(?:[^"\\]|\\.)*"|`(?:[^`\\]|\\.)*\$\{|\}(?:[^`\\]|\\.)*`|`(?:[^`\\]|\\.)*`/g;

// detect problematic expressions in a template
function detectErrors (ast, warn) {
  if (ast) {
    checkNode(ast, warn);
  }
}

function checkNode (node, warn) {
  if (node.type === 1) {
    for (var name in node.attrsMap) {
      if (dirRE.test(name)) {
        var value = node.attrsMap[name];
        if (value) {
          var range = node.rawAttrsMap[name];
          if (name === 'v-for') {
            checkFor(node, ("v-for=\"" + value + "\""), warn, range);
          } else if (name === 'v-slot' || name[0] === '#') {
            checkFunctionParameterExpression(value, (name + "=\"" + value + "\""), warn, range);
          } else if (onRE.test(name)) {
            checkEvent(value, (name + "=\"" + value + "\""), warn, range);
          } else {
            checkExpression(value, (name + "=\"" + value + "\""), warn, range);
          }
        }
      }
    }
    if (node.children) {
      for (var i = 0; i < node.children.length; i++) {
        checkNode(node.children[i], warn);
      }
    }
  } else if (node.type === 2) {
    checkExpression(node.expression, node.text, warn, node);
  }
}

function checkEvent (exp, text, warn, range) {
  var stripped = exp.replace(stripStringRE, '');
  var keywordMatch = stripped.match(unaryOperatorsRE);
  if (keywordMatch && stripped.charAt(keywordMatch.index - 1) !== '$') {
    warn(
      "avoid using JavaScript unary operator as property name: " +
      "\"" + (keywordMatch[0]) + "\" in expression " + (text.trim()),
      range
    );
  }
  checkExpression(exp, text, warn, range);
}

function checkFor (node, text, warn, range) {
  checkExpression(node.for || '', text, warn, range);
  checkIdentifier(node.alias, 'v-for alias', text, warn, range);
  checkIdentifier(node.iterator1, 'v-for iterator', text, warn, range);
  checkIdentifier(node.iterator2, 'v-for iterator', text, warn, range);
}

function checkIdentifier (
  ident,
  type,
  text,
  warn,
  range
) {
  if (typeof ident === 'string') {
    try {
      new Function(("var " + ident + "=_"));
    } catch (e) {
      warn(("invalid " + type + " \"" + ident + "\" in expression: " + (text.trim())), range);
    }
  }
}

function checkExpression (exp, text, warn, range) {
  try {
    new Function(("return " + exp));
  } catch (e) {
    var keywordMatch = exp.replace(stripStringRE, '').match(prohibitedKeywordRE);
    if (keywordMatch) {
      warn(
        "avoid using JavaScript keyword as property name: " +
        "\"" + (keywordMatch[0]) + "\"\n  Raw expression: " + (text.trim()),
        range
      );
    } else {
      warn(
        "invalid expression: " + (e.message) + " in\n\n" +
        "    " + exp + "\n\n" +
        "  Raw expression: " + (text.trim()) + "\n",
        range
      );
    }
  }
}

function checkFunctionParameterExpression (exp, text, warn, range) {
  try {
    new Function(exp, '');
  } catch (e) {
    warn(
      "invalid function parameter expression: " + (e.message) + " in\n\n" +
      "    " + exp + "\n\n" +
      "  Raw expression: " + (text.trim()) + "\n",
      range
    );
  }
}

/*  */

var range = 2;

function generateCodeFrame (
  source,
  start,
  end
) {
  if ( start === void 0 ) start = 0;
  if ( end === void 0 ) end = source.length;

  var lines = source.split(/\r?\n/);
  var count = 0;
  var res = [];
  for (var i = 0; i < lines.length; i++) {
    count += lines[i].length + 1;
    if (count >= start) {
      for (var j = i - range; j <= i + range || end > count; j++) {
        if (j < 0 || j >= lines.length) { continue }
        res.push(("" + (j + 1) + (repeat$1(" ", 3 - String(j + 1).length)) + "|  " + (lines[j])));
        var lineLength = lines[j].length;
        if (j === i) {
          // push underline
          var pad = start - (count - lineLength) + 1;
          var length = end > count ? lineLength - pad : end - start;
          res.push("   |  " + repeat$1(" ", pad) + repeat$1("^", length));
        } else if (j > i) {
          if (end > count) {
            var length$1 = Math.min(end - count, lineLength);
            res.push("   |  " + repeat$1("^", length$1));
          }
          count += lineLength + 1;
        }
      }
      break
    }
  }
  return res.join('\n')
}

function repeat$1 (str, n) {
  var result = '';
  if (n > 0) {
    while (true) { // eslint-disable-line
      if (n & 1) { result += str; }
      n >>>= 1;
      if (n <= 0) { break }
      str += str;
    }
  }
  return result
}

/*  */



function createFunction (code, errors) {
  try {
    return new Function(code)
  } catch (err) {
    errors.push({ err: err, code: code });
    return noop
  }
}

function createCompileToFunctionFn (compile) {
  var cache = Object.create(null);

  return function compileToFunctions (
    template,
    options,
    vm
  ) {
    options = extend({}, options);
    var warn$$1 = options.warn || warn;
    delete options.warn;

    /* istanbul ignore if */
    if (true) {
      // detect possible CSP restriction
      try {
        new Function('return 1');
      } catch (e) {
        if (e.toString().match(/unsafe-eval|CSP/)) {
          warn$$1(
            'It seems you are using the standalone build of Vue.js in an ' +
            'environment with Content Security Policy that prohibits unsafe-eval. ' +
            'The template compiler cannot work in this environment. Consider ' +
            'relaxing the policy to allow unsafe-eval or pre-compiling your ' +
            'templates into render functions.'
          );
        }
      }
    }

    // check cache
    var key = options.delimiters
      ? String(options.delimiters) + template
      : template;
    if (cache[key]) {
      return cache[key]
    }

    // compile
    var compiled = compile(template, options);

    // check compilation errors/tips
    if (true) {
      if (compiled.errors && compiled.errors.length) {
        if (options.outputSourceRange) {
          compiled.errors.forEach(function (e) {
            warn$$1(
              "Error compiling template:\n\n" + (e.msg) + "\n\n" +
              generateCodeFrame(template, e.start, e.end),
              vm
            );
          });
        } else {
          warn$$1(
            "Error compiling template:\n\n" + template + "\n\n" +
            compiled.errors.map(function (e) { return ("- " + e); }).join('\n') + '\n',
            vm
          );
        }
      }
      if (compiled.tips && compiled.tips.length) {
        if (options.outputSourceRange) {
          compiled.tips.forEach(function (e) { return tip(e.msg, vm); });
        } else {
          compiled.tips.forEach(function (msg) { return tip(msg, vm); });
        }
      }
    }

    // turn code into functions
    var res = {};
    var fnGenErrors = [];
    res.render = createFunction(compiled.render, fnGenErrors);
    res.staticRenderFns = compiled.staticRenderFns.map(function (code) {
      return createFunction(code, fnGenErrors)
    });

    // check function generation errors.
    // this should only happen if there is a bug in the compiler itself.
    // mostly for codegen development use
    /* istanbul ignore if */
    if (true) {
      if ((!compiled.errors || !compiled.errors.length) && fnGenErrors.length) {
        warn$$1(
          "Failed to generate render function:\n\n" +
          fnGenErrors.map(function (ref) {
            var err = ref.err;
            var code = ref.code;

            return ((err.toString()) + " in\n\n" + code + "\n");
        }).join('\n'),
          vm
        );
      }
    }

    return (cache[key] = res)
  }
}

/*  */

function createCompilerCreator (baseCompile) {
  return function createCompiler (baseOptions) {
    function compile (
      template,
      options
    ) {
      var finalOptions = Object.create(baseOptions);
      var errors = [];
      var tips = [];

      var warn = function (msg, range, tip) {
        (tip ? tips : errors).push(msg);
      };

      if (options) {
        if ( true && options.outputSourceRange) {
          // $flow-disable-line
          var leadingSpaceLength = template.match(/^\s*/)[0].length;

          warn = function (msg, range, tip) {
            var data = { msg: msg };
            if (range) {
              if (range.start != null) {
                data.start = range.start + leadingSpaceLength;
              }
              if (range.end != null) {
                data.end = range.end + leadingSpaceLength;
              }
            }
            (tip ? tips : errors).push(data);
          };
        }
        // merge custom modules
        if (options.modules) {
          finalOptions.modules =
            (baseOptions.modules || []).concat(options.modules);
        }
        // merge custom directives
        if (options.directives) {
          finalOptions.directives = extend(
            Object.create(baseOptions.directives || null),
            options.directives
          );
        }
        // copy other options
        for (var key in options) {
          if (key !== 'modules' && key !== 'directives') {
            finalOptions[key] = options[key];
          }
        }
      }

      finalOptions.warn = warn;

      var compiled = baseCompile(template.trim(), finalOptions);
      if (true) {
        detectErrors(compiled.ast, warn);
      }
      compiled.errors = errors;
      compiled.tips = tips;
      return compiled
    }

    return {
      compile: compile,
      compileToFunctions: createCompileToFunctionFn(compile)
    }
  }
}

/*  */

// `createCompilerCreator` allows creating compilers that use alternative
// parser/optimizer/codegen, e.g the SSR optimizing compiler.
// Here we just export a default compiler using the default parts.
var createCompiler = createCompilerCreator(function baseCompile (
  template,
  options
) {
  var ast = parse(template.trim(), options);
  if (options.optimize !== false) {
    optimize(ast, options);
  }
  var code = generate(ast, options);
  return {
    ast: ast,
    render: code.render,
    staticRenderFns: code.staticRenderFns
  }
});

/*  */

var ref$1 = createCompiler(baseOptions);
var compile = ref$1.compile;
var compileToFunctions = ref$1.compileToFunctions;

/*  */

// check whether current browser encodes a char inside attribute values
var div;
function getShouldDecode (href) {
  div = div || document.createElement('div');
  div.innerHTML = href ? "<a href=\"\n\"/>" : "<div a=\"\n\"/>";
  return div.innerHTML.indexOf('&#10;') > 0
}

// #3663: IE encodes newlines inside attribute values while other browsers don't
var shouldDecodeNewlines = inBrowser ? getShouldDecode(false) : false;
// #6828: chrome encodes content in a[href]
var shouldDecodeNewlinesForHref = inBrowser ? getShouldDecode(true) : false;

/*  */

var idToTemplate = cached(function (id) {
  var el = query(id);
  return el && el.innerHTML
});

var mount = Vue.prototype.$mount;
Vue.prototype.$mount = function (
  el,
  hydrating
) {
  el = el && query(el);

  /* istanbul ignore if */
  if (el === document.body || el === document.documentElement) {
     true && warn(
      "Do not mount Vue to <html> or <body> - mount to normal elements instead."
    );
    return this
  }

  var options = this.$options;
  // resolve template/el and convert to render function
  if (!options.render) {
    var template = options.template;
    if (template) {
      if (typeof template === 'string') {
        if (template.charAt(0) === '#') {
          template = idToTemplate(template);
          /* istanbul ignore if */
          if ( true && !template) {
            warn(
              ("Template element not found or is empty: " + (options.template)),
              this
            );
          }
        }
      } else if (template.nodeType) {
        template = template.innerHTML;
      } else {
        if (true) {
          warn('invalid template option:' + template, this);
        }
        return this
      }
    } else if (el) {
      template = getOuterHTML(el);
    }
    if (template) {
      /* istanbul ignore if */
      if ( true && config.performance && mark) {
        mark('compile');
      }

      var ref = compileToFunctions(template, {
        outputSourceRange: "development" !== 'production',
        shouldDecodeNewlines: shouldDecodeNewlines,
        shouldDecodeNewlinesForHref: shouldDecodeNewlinesForHref,
        delimiters: options.delimiters,
        comments: options.comments
      }, this);
      var render = ref.render;
      var staticRenderFns = ref.staticRenderFns;
      options.render = render;
      options.staticRenderFns = staticRenderFns;

      /* istanbul ignore if */
      if ( true && config.performance && mark) {
        mark('compile end');
        measure(("vue " + (this._name) + " compile"), 'compile', 'compile end');
      }
    }
  }
  return mount.call(this, el, hydrating)
};

/**
 * Get outerHTML of elements, taking care
 * of SVG elements in IE as well.
 */
function getOuterHTML (el) {
  if (el.outerHTML) {
    return el.outerHTML
  } else {
    var container = document.createElement('div');
    container.appendChild(el.cloneNode(true));
    return container.innerHTML
  }
}

Vue.compile = compileToFunctions;

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Vue);


/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/compat get default export */
/******/ 	(() => {
/******/ 		// getDefaultExport function for compatibility with non-harmony modules
/******/ 		__webpack_require__.n = (module) => {
/******/ 			var getter = module && module.__esModule ?
/******/ 				() => (module['default']) :
/******/ 				() => (module);
/******/ 			__webpack_require__.d(getter, { a: getter });
/******/ 			return getter;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/global */
/******/ 	(() => {
/******/ 		__webpack_require__.g = (function() {
/******/ 			if (typeof globalThis === 'object') return globalThis;
/******/ 			try {
/******/ 				return this || new Function('return this')();
/******/ 			} catch (e) {
/******/ 				if (typeof window === 'object') return window;
/******/ 			}
/******/ 		})();
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
var __webpack_exports__ = {};
// This entry need to be wrapped in an IIFE because it need to be in strict mode.
(() => {
"use strict";
/*!******************************!*\
  !*** ./src/market/market.js ***!
  \******************************/
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _configs_defaultOptions__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./configs/defaultOptions */ "./src/market/configs/defaultOptions.js");
/* harmony import */ var _modules_options__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./modules/options */ "./src/market/modules/options.js");
/* harmony import */ var _modules_ajax__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./modules/ajax */ "./src/market/modules/ajax.js");
/* harmony import */ var _modules_binance__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./modules/binance */ "./src/market/modules/binance.js");
/* harmony import */ var _modules_coincap__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./modules/coincap */ "./src/market/modules/coincap.js");
/* harmony import */ var _modules_alarms__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./modules/alarms */ "./src/market/modules/alarms.js");
/* harmony import */ var _modules_history__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./modules/history */ "./src/market/modules/history.js");
/* harmony import */ var _modules_notify__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./modules/notify */ "./src/market/modules/notify.js");
/* harmony import */ var _modules_news__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./modules/news */ "./src/market/modules/news.js");
/* harmony import */ var _modules_messenger__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./modules/messenger */ "./src/market/modules/messenger.js");
/* harmony import */ var _modules_router__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./modules/router */ "./src/market/modules/router.js");
/* harmony import */ var _modules_bus__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./modules/bus */ "./src/market/modules/bus.js");
/* harmony import */ var _modules_sorter__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./modules/sorter */ "./src/market/modules/sorter.js");
/* harmony import */ var _modules_scroller__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./modules/scroller */ "./src/market/modules/scroller.js");
/* harmony import */ var _modules_tooltip__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./modules/tooltip */ "./src/market/modules/tooltip.js");
/* harmony import */ var _modules_store__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ./modules/store */ "./src/market/modules/store.js");
/* harmony import */ var _modules_sentiment__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ./modules/sentiment */ "./src/market/modules/sentiment.js");
/* harmony import */ var _modules_utils__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ./modules/utils */ "./src/market/modules/utils.js");
/* harmony import */ var _modules_utils__WEBPACK_IMPORTED_MODULE_17___default = /*#__PURE__*/__webpack_require__.n(_modules_utils__WEBPACK_IMPORTED_MODULE_17__);
Object(function webpackMissingModule() { var e = new Error("Cannot find module './components/App.vue'"); e.code = 'MODULE_NOT_FOUND'; throw e; }());
/* harmony import */ var vue__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(/*! vue */ "./node_modules/vue/dist/vue.esm.js");
/* harmony import */ var _modules_coinbasepro__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! ./modules/coinbasepro */ "./src/market/modules/coinbasepro.js");
/**
 * Main app entry file.
 */
window.DEBUG = false; // app dependencies





















 // setup common helper classes

var _options = new _modules_options__WEBPACK_IMPORTED_MODULE_1__["default"](_configs_defaultOptions__WEBPACK_IMPORTED_MODULE_0__["default"]);

var _ajax = new _modules_ajax__WEBPACK_IMPORTED_MODULE_2__["default"]();

var _binance = new _modules_binance__WEBPACK_IMPORTED_MODULE_3__["default"]();

var _coinbasepro = new _modules_coinbasepro__WEBPACK_IMPORTED_MODULE_19__["default"]();

var _coincap = new _modules_coincap__WEBPACK_IMPORTED_MODULE_4__["default"]();

var _alarms = new _modules_alarms__WEBPACK_IMPORTED_MODULE_5__["default"]();

var _history = new _modules_history__WEBPACK_IMPORTED_MODULE_6__["default"]();

var _notify = new _modules_notify__WEBPACK_IMPORTED_MODULE_7__["default"]();

var _news = new _modules_news__WEBPACK_IMPORTED_MODULE_8__["default"]();

var _messenger = new _modules_messenger__WEBPACK_IMPORTED_MODULE_9__["default"]();

var _router = new _modules_router__WEBPACK_IMPORTED_MODULE_10__["default"]();

var _bus = new _modules_bus__WEBPACK_IMPORTED_MODULE_11__["default"]();

var _sorter = new _modules_sorter__WEBPACK_IMPORTED_MODULE_12__["default"]();

var _scroller = new _modules_scroller__WEBPACK_IMPORTED_MODULE_13__["default"]();

var _tooltip = new _modules_tooltip__WEBPACK_IMPORTED_MODULE_14__["default"](); // create custom global vue properties


Object.defineProperties(vue__WEBPACK_IMPORTED_MODULE_20__["default"].prototype, {
  $opts: {
    get: function get() {
      return _options;
    }
  },
  $ajax: {
    get: function get() {
      return _ajax;
    }
  },
  $binance: {
    get: function get() {
      return _binance;
    }
  },
  $coinbasepro: {
    get: function get() {
      return _coinbasepro;
    }
  },
  $coincap: {
    get: function get() {
      return _coincap;
    }
  },
  $alarms: {
    get: function get() {
      return _alarms;
    }
  },
  $history: {
    get: function get() {
      return _history;
    }
  },
  $notify: {
    get: function get() {
      return _notify;
    }
  },
  $news: {
    get: function get() {
      return _news;
    }
  },
  $messenger: {
    get: function get() {
      return _messenger;
    }
  },
  $router: {
    get: function get() {
      return _router;
    }
  },
  $scroller: {
    get: function get() {
      return _scroller;
    }
  },
  $bus: {
    get: function get() {
      return _bus;
    }
  },
  $sorter: {
    get: function get() {
      return _sorter;
    }
  },
  $store: {
    get: function get() {
      return _modules_store__WEBPACK_IMPORTED_MODULE_15__["default"];
    }
  },
  $sentiment: {
    get: function get() {
      return _modules_sentiment__WEBPACK_IMPORTED_MODULE_16__["default"];
    }
  },
  $utils: {
    get: function get() {
      return (_modules_utils__WEBPACK_IMPORTED_MODULE_17___default());
    }
  }
}); // single tooltip instance for entire app

vue__WEBPACK_IMPORTED_MODULE_20__["default"].directive('tooltip', {
  bind: function bind(el) {
    _tooltip.select(el);
  },
  unbind: function unbind(el) {
    _tooltip.unselect(el);
  }
}); // global filters used to format currency and price change values

vue__WEBPACK_IMPORTED_MODULE_20__["default"].filter('toLinks', function (text) {
  return _modules_utils__WEBPACK_IMPORTED_MODULE_17___default().linkUrl(text);
});
vue__WEBPACK_IMPORTED_MODULE_20__["default"].filter('toNoun', function (num, s, p) {
  return _modules_utils__WEBPACK_IMPORTED_MODULE_17___default().noun(num, s, p);
});
vue__WEBPACK_IMPORTED_MODULE_20__["default"].filter('toElapsed', function (time, suffix, _short) {
  return _modules_utils__WEBPACK_IMPORTED_MODULE_17___default().elapsed((Date.now() - time) / 1000, suffix, _short);
});
vue__WEBPACK_IMPORTED_MODULE_20__["default"].filter('toDate', function (time, full) {
  return _modules_utils__WEBPACK_IMPORTED_MODULE_17___default().date(time, full);
});
vue__WEBPACK_IMPORTED_MODULE_20__["default"].filter('toMoney', function (num, decimals) {
  return _modules_utils__WEBPACK_IMPORTED_MODULE_17___default().money(num, decimals);
});
vue__WEBPACK_IMPORTED_MODULE_20__["default"].filter('toFixed', function (num, asset) {
  return _modules_utils__WEBPACK_IMPORTED_MODULE_17___default().fixed(num, asset);
}); // init and/or render

window.addEventListener('load', function (e) {
  if (window.top !== window) return;
  document.body.setAttribute('tabindex', '0');
  new vue__WEBPACK_IMPORTED_MODULE_20__["default"]({
    el: '#market',
    render: function render(h) {
      return h(Object(function webpackMissingModule() { var e = new Error("Cannot find module './components/App.vue'"); e.code = 'MODULE_NOT_FOUND'; throw e; }()));
    }
  });
});
})();

/******/ })()
;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,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OztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU0sS0FBcUM7QUFDM0M7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLHFCQUFxQjtBQUNyRDtBQUNBLG1DQUFtQyxPQUFPO0FBQzFDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDJCQUEyQixTQUFTOztBQUVwQztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JB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QUN0RDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCO0FBQzVCO0FBQ0EscUNBQXFDO0FBQ3JDO0FBQ0Esc0NBQXNDO0FBQ3RDO0FBQ0E7QUFDQSxNQUFNLEtBQXFDO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7O0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUksSUFFUTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNLEtBQXFDO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsMkJBQTJCO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsNERBQTRELFdBQVc7QUFDdkU7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QUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNLEtBQXFDO0FBQzNDO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxrREFBa0Q7QUFDbEQsNENBQTRDO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw2Q0FBNkM7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGlCQUFpQjtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNLEtBQXFDO0FBQzNDO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTiw0Q0FBNEM7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O0FBQ0E7QUFDQTtBQUNBLFVBQVUsS0FBcUM7QUFDL0M7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSxLQUFxQztBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEtBQUssNENBQTRDLCtCQUErQjs7QUFFaEY7QUFDQSx5Q0FBeUMsT0FBTztBQUNoRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBLE1BQU0sS0FBcUM7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixLQUFxQztBQUNyRDtBQUNBLG9CQUFvQixDQUFJO0FBQ3hCO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxvQkFBb0IscUJBQXFCO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0M7QUFDL0M7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDLE9BQU87QUFDL0M7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDLFNBQVM7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFFBQVEsSUFBcUM7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0MsT0FBTztBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLElBQXFDO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNLEtBQXFDO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU0sSUFBcUM7QUFDM0M7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDJCQUEyQjs7QUFFM0IsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IscUJBQXFCO0FBQ3pDO0FBQ0EsMkNBQTJDO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsTUFBTSxJQUFxQztBQUMzQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLHlCQUF5QjtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQix5QkFBeUI7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUMsT0FBTztBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU0sSUFBcUM7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IscUJBQXFCOztBQUVwRDtBQUNBO0FBQ0Esa0JBQWtCLHNCQUFzQjtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSxLQUFxQztBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esa0JBQWtCLGtCQUFrQjtBQUNwQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsVUFBVSxLQUFxQztBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7OztBQUlBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsS0FBcUM7QUFDekQ7QUFDQSxNQUFNLENBQUU7QUFDUjtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0EsTUFBTSxLQUFxQztBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEIsc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQSxJQUFJO0FBQ0oseUJBQXlCO0FBQ3pCO0FBQ0EsdUJBQXVCO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsSUFBcUM7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLE1BQU0sS0FBSyxFQUVOO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSSxLQUFxQztBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLElBQXFDO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNLEtBQXFDO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBLCtCQUErQjs7QUFFL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLEtBQXFDO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNLFNBQVMsSUFBcUM7QUFDcEQ7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNLEtBQXFDO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLElBQXFDO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0Isb0JBQW9CO0FBQzFDO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEI7QUFDOUI7QUFDQSwrQkFBK0I7QUFDL0IsTUFBTSxJQUFxQztBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsUUFBUSxLQUFxQztBQUM3QztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLElBQXFDO0FBQzdDO0FBQ0EsTUFBTSxLQUFLLEVBRU47QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQSxxQkFBcUI7QUFDckI7O0FBRUE7QUFDQSxRQUFRLEtBQXFDO0FBQzdDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsTUFBTSxLQUFxQztBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzRUFBc0U7QUFDdEU7QUFDQTtBQUNBOztBQUVBO0FBQ0EsUUFBUSxLQUFxQztBQUM3QztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUM7O0FBRWpDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsWUFBWSxLQUFxQztBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBOzs7Ozs7QUFNQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsMkNBQTJDLDRCQUE0QjtBQUN2RSxLQUFLO0FBQ0w7QUFDQSwyQ0FBMkMsNkJBQTZCO0FBQ3hFLEtBQUs7QUFDTCxHQUFHOztBQUVIO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0M7QUFDaEMsTUFBTSxJQUFxQztBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0MsT0FBTztBQUMzQztBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxnQ0FBZ0M7O0FBRWhDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTSxLQUFxQztBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxxQkFBcUI7O0FBRXJCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxnQ0FBZ0M7O0FBRWhDOztBQUVBO0FBQ0E7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SjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDLE9BQU87QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLE9BQU87QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSx3REFBd0QsbUJBQW1CO0FBQzNFO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7Ozs7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCLHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLE1BQU0sSUFBcUM7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0EsSUFBSSxTQUFTLElBQXFDO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpRkFBaUY7QUFDakYsNEJBQTRCO0FBQzVCO0FBQ0EsMkJBQTJCO0FBQzNCLHdCQUF3QixpRUFBaUU7QUFDekYsWUFBWSwwRkFBMEY7QUFDdEcsTUFBTSxLQUFLLDBDQUEwQztBQUNyRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QyxrQkFBa0I7QUFDL0Qsc0JBQXNCLCtDQUErQztBQUNyRSxpREFBaUQ7O0FBRWpEO0FBQ0Esc0RBQXNEO0FBQ3REO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQU0sSUFBcUM7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsOENBQThDO0FBQzlDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQztBQUMzQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QjtBQUM1QixtQ0FBbUM7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7O0FBRUE7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsK0NBQStDO0FBQ3ZEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLG1DQUFtQztBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0Esd0NBQXdDLFNBQVM7QUFDakQ7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLHdCQUF3QjtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxxREFBcUQsNkJBQTZCO0FBQ2xGLE1BQU07QUFDTjtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EscURBQXFELGdDQUFnQztBQUNyRixNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0NBQStDOztBQUUvQztBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsTUFBTSxLQUFxQztBQUMzQztBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxNQUFNLEtBQXFDO0FBQzNDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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Q0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxtQ0FBbUM7O0FBRW5DLHNDQUFzQzs7QUFFdEM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxRQUFRLEtBQXFDO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLFFBQVEsS0FBcUM7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSw4Q0FBOEM7QUFDOUM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0RBQXdEO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDO0FBQ3pDO0FBQ0E7QUFDQSxpRUFBaUUsdUJBQXVCO0FBQ3hGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7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QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxPQUFPO0FBQ1AsT0FBTztBQUNQLFNBQVM7QUFDVCxRQUFRO0FBQ1IsUUFBUTtBQUNSLE9BQU87QUFDUCxRQUFRO0FBQ1I7QUFDQSwyQ0FBMkM7QUFDM0MsOERBQThEOztBQUU5RDtBQUNBO0FBQ0Esc0RBQXNEOztBQUV0RDtBQUNBO0FBQ0EsOENBQThDLDRCQUE0QjtBQUMxRTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFD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QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsSUFBSSxTQUFTLElBQXFDO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ04sVUFBVSxLQUFxQztBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSxLQUFxQztBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLFFBQVEsS0FBcUM7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLElBQXFDO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUVBQWlFO0FBQ2pFO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLFlBQVksSUFBcUM7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMERBQTBEO0FBQzFEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNLFNBQVMsSUFBcUM7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBLFFBQVE7QUFDUjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsS0FBcUM7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IsT0FBTztBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSxLQUFxQztBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0M7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsUUFBUSw0QkFBNEI7QUFDcEM7QUFDQTtBQUNBO0FB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Oi8vLy4vc3JjL21hcmtldC9jb25maWdzL2RlZmF1bHRPcHRpb25zLmpzIiwid2VicGFjazovLy8uL3NyYy9tYXJrZXQvbW9kdWxlcy9hamF4LmpzIiwid2VicGFjazovLy8uL3NyYy9tYXJrZXQvbW9kdWxlcy9hbGFybXMuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL21hcmtldC9tb2R1bGVzL2JpbmFuY2UuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL21hcmtldC9tb2R1bGVzL2J1cy5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvbWFya2V0L21vZHVsZXMvY29pbmJhc2Vwcm8uanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL21hcmtldC9tb2R1bGVzL2NvaW5jYXAuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL21hcmtldC9tb2R1bGVzL2hpc3RvcnkuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL21hcmtldC9tb2R1bGVzL2xvZ2dlci5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvbWFya2V0L21vZHVsZXMvbWVzc2VuZ2VyLmpzIiwid2VicGFjazovLy8uL3NyYy9tYXJrZXQvbW9kdWxlcy9uZXdzLmpzIiwid2VicGFjazovLy8uL3NyYy9tYXJrZXQvbW9kdWxlcy9ub3RpZnkuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL21hcmtldC9tb2R1bGVzL29wdGlvbnMuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL21hcmtldC9tb2R1bGVzL3JvdXRlci5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvbWFya2V0L21vZHVsZXMvc2Nyb2xsZXIuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL21hcmtldC9tb2R1bGVzL3NlbnRpbWVudC5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvbWFya2V0L21vZHVsZXMvc29ydGVyLmpzIiwid2VicGFjazovLy8uL3NyYy9tYXJrZXQvbW9kdWxlcy9zdG9yZS5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvbWFya2V0L21vZHVsZXMvc3ltYm9sLmpzIiwid2VicGFjazovLy8uL3NyYy9tYXJrZXQvbW9kdWxlcy90b29sdGlwLmpzIiwid2VicGFjazovLy8uL3NyYy9tYXJrZXQvbW9kdWxlcy90d2l0dGVyLmpzIiwid2VicGFjazovLy8uL3NyYy9tYXJrZXQvbW9kdWxlcy91dGlscy5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvbWFya2V0L21vZHVsZXMvdmlld3BvcnQuanMiLCJ3ZWJwYWNrOi8vLy4vcmVzb3VyY2VzL2Fzc2V0cy9jb3JzLnR4dCIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvdnVlL2Rpc3QvdnVlLmVzbS5qcyIsIndlYnBhY2s6Ly8vd2VicGFjay9ib290c3RyYXAiLCJ3ZWJwYWNrOi8vL3dlYnBhY2svcnVudGltZS9jb21wYXQgZ2V0IGRlZmF1bHQgZXhwb3J0Iiwid2VicGFjazovLy93ZWJwYWNrL3J1bnRpbWUvZGVmaW5lIHByb3BlcnR5IGdldHRlcnMiLCJ3ZWJwYWNrOi8vL3dlYnBhY2svcnVudGltZS9nbG9iYWwiLCJ3ZWJwYWNrOi8vL3dlYnBhY2svcnVudGltZS9oYXNPd25Qcm9wZXJ0eSBzaG9ydGhhbmQiLCJ3ZWJwYWNrOi8vL3dlYnBhY2svcnVudGltZS9tYWtlIG5hbWVzcGFjZSBvYmplY3QiLCJ3ZWJwYWNrOi8vLy4vc3JjL21hcmtldC9tYXJrZXQuanMiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBBcHBsaWNhdGlvbiBvcHRpb25zIG9iamVjdFxuICovXG5pbXBvcnQgdHh0IGZyb20gJ3Jhdy1sb2FkZXIhLi4vLi4vLi4vcmVzb3VyY2VzL2Fzc2V0cy9jb3JzLnR4dCc7XG5leHBvcnQgZGVmYXVsdCB7XG5cbiAgLy8gY29ycyBwcm94eSBmb3Igb3V0Z29pbmcgaHR0cCByZXF1ZXN0c1xuICBwcm94eTogdHh0LFxuXG4gIC8vIGN1c3RvbSBwcm94eSBsaXN0XG4gIHByb3h5bGlzdDogW1xuICAgIHR4dFxuICBdLFxuXG4gIC8vIG5vdGlmaWNhdGlvbiBvcHRpb25zXG4gIG5vdGlmeToge1xuICAgIGVuYWJsZWQ6IHRydWUsXG4gICAgZHVyYXRpb246IDEwLFxuICB9LFxuXG4gIC8vIG5vdGlmaWNhdGlvbiBhdWRpb1xuICBhdWRpbzoge1xuICAgIGVuYWJsZWQ6IHRydWUsXG4gICAgdm9sdW1lOiAwLjUsXG4gICAgZmlsZTogJy4uLy4uLy4uLy4uL21hcmtldC9hdWRpby9hdWRpb18yLm1wMycsXG4gIH0sXG5cbiAgLy8gc2VhcmNoIG9wdGlvbnNcbiAgc2VhcmNoOiB7XG4gICAgZnVsbHdvcmQ6IGZhbHNlLCAgLy8gbXVzdCB0eXBlIGZ1bGwgc2VhcmNoIHdvcmRzXG4gICAgZnVsbGNhc2U6IGZhbHNlLCAgLy8gbXVzdCB0eXBlIGNvcnJlY3Qgd29yZCB1cHBlci9sb3dlciBjYXNlIGxldHRlcnNcbiAgfSxcblxuICAvLyBsaXZlIHByaWNlIG9wdGlvbnNcbiAgcHJpY2VzOiB7XG4gICAgaGVhZGVyOiB0cnVlLCAgICAgICAgIC8vIHNob3cgdG9wIGNvaW5zIGluIGhlYWRlclxuICAgIGNoYXJ0OiB0cnVlLCAgICAgICAgICAvLyBzaG93IGxpdmUgcHJpY2UgY2hhcnQgaW4gbGlzdFxuICAgIG1hcmtldDogJ1VTRFQnLCAgICAgICAvLyBkZWZhdWx0IHNlbGVjdGVkIG1hcmtldCB0b2tlblxuICAgIHNvcnQ6ICdtYXJrZXRWb2x1bWUnLCAvLyBwcmljZSBkYXRhIHRvIHNvcnQgYnlcbiAgICBvcmRlcjogJ2Rlc2MnLCAgICAgICAgLy8gcHJpY2Ugc29ydCBkaXJlY3Rpb25cbiAgICBsaW1pdDogMjAsICAgICAgICAgICAgLy8gaG93IG1hbnkgZW50cmllcyB0byBzaG93XG4gIH0sXG5cbiAgLy8gbmV3cyByZWxhdGVkIG9wdGlvbnNcbiAgbmV3czoge1xuICAgIGVuYWJsZWQ6IHRydWUsIC8vIGVuYWJsZSBmZXRjaGluZyBvbiBhIHRpbWVyXG4gICAgbm90aWZ5OiBmYWxzZSwgIC8vIHNob3cgcHVzaCBub3RpZmljYXRpb25zIGZvciBuZXdzXG4gICAgc2VuZDogZmFsc2UsICAgIC8vIGluY2x1ZGUgbmV3cyBpbiBvdXRnb2luZyBub3RpZmljYXRpb25zIChlbWFpbC90ZWxlZ3JhbSlcbiAgICBpbnRlcnZhbDogNSwgICAgLy8gaG93IG9mdGVuIHRvIHRyeSBmZXRjaGluZyBmcm9tIGVhY2ggc291cmNlIChzZWNzKVxuICAgIGRlbGF5OiA1MDAsICAgICAvLyBob3cgbG9uZyB0byB3YWl0IGJlZm9yZSBmZXRjaGluZyBhZ2FpbiBmcm9tIGVhY2ggc291cmNlIChzZWNzKVxuICAgIHR3ZWV0czogMSwgICAgICAvLyBob3cgbWFueSB0d2VldHMgdG8gZmV0Y2ggYXQgb25jZSBmcm9tIGVhY2ggc291cmNlXG4gICAgdG90YWw6IDEwMCwgICAgIC8vIGhvdyBtYW55IHRvdGFsIHR3ZWV0cyB0byBzdG9yZVxuICAgIG1heDogMzAsICAgICAgICAvLyBtYXggbnVtYmVyIG9mIG5ld3MgZW50cmllcyB0byBzaG93XG4gICAgZGF5czogMSwgICAgICAgIC8vIG9ubHkgc2hvdyBlbnRyaWVzIHBvc3RlZCB3aXRoaW4gdGhpcyBudW1iZXIgb2YgZGF5c1xuICB9LFxuXG4gIC8vIGJpbmFuY2UgYXBpIGNvbmZpZ1xuICBiaW5hbmNlOiB7XG4gICAgZW5hYmxlZDogZmFsc2UsIC8vIHN0YXR1c1xuICAgIGFwaWtleTogJycsICAgICAvLyBhcGkga2V5XG4gICAgYXBpc2VjcmV0OiAnJywgIC8vIGFwaSBzZWNyZXRcbiAgfSxcblxuICAvLyBtYWlsZ3VuIGFwaSBjb25maWdcbiAgbWFpbGd1bjoge1xuICAgIGVuYWJsZWQ6IGZhbHNlLCAvLyBzdGF0dXNcbiAgICBkb21haW46ICcnLCAgICAgLy8gYWNjb3VudCBkb21haW5cbiAgICBhcGlrZXk6ICcnLCAgICAgLy8gYXBpIGtleVxuICAgIGVtYWlsOiAnJywgICAgICAvLyByZWNpcGllbnQgZW1haWxcbiAgfSxcblxuICAvLyB0ZWxlZ3JhbSBib3QgYXBpIGNvbmZpZ1xuICB0ZWxlZ3JhbToge1xuICAgIGVuYWJsZWQ6IGZhbHNlLCAvLyBzdGF0dXNcbiAgICBib3RrZXk6ICcnLCAgICAgLy8gdGVsZWdyYW0gYm90IGlkXG4gICAgdXNlcmlkOiAnJywgICAgIC8vIHJlY2lwaWVudCBjaGF0IGlkXG4gIH0sXG59XG4iLCIvKipcclxuICogQmFzaWMgWEhSIGFqYXggcmVxdWVzdCBtb2R1bGVcclxuICovXHJcbmltcG9ydCBzdG9yZSBmcm9tICcuL3N0b3JlJztcclxuaW1wb3J0IGxvZ2dlciBmcm9tICcuL2xvZ2dlcic7XHJcbmltcG9ydCB1dGlscyBmcm9tICcuL3V0aWxzJztcclxuXHJcbi8vIGFqYXggY2xhc3NcclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgQWpheCB7XHJcblxyXG4gIC8qKlxyXG4gICAqIENvbnN0cnVjdG9yXHJcbiAgICogQHBhcmFtIHtvYmplY3R9ICBvcHRpb25zICBJbml0aWFsIG9wdGlvbnNcclxuICAgKi9cclxuICBjb25zdHJ1Y3Rvciggb3B0aW9ucyApIHtcclxuICAgIHRoaXMuX3VybCA9IG51bGw7XHJcbiAgICB0aGlzLl9vcHRpb25zID0ge1xyXG4gICAgICAvLyBzYXZlIHJlc3BvbnNlIGRhdGEgdG8gbG9jYWwgc3RvcmUgY2FjaGVcclxuICAgICAgY2FjaGU6IGZhbHNlLFxyXG4gICAgICAvLyBrZXkgcHJlZml4IGZvciBsb2NhbCBzdG9yZSBjYWNoZVxyXG4gICAgICBwcmVmaXg6ICdhamF4X2RhdGFfJyxcclxuICAgICAgLy8gcHJveHkgdXJsIHRvIHByZXBwZW5kIHRvIG91dGdvaW5nIHJlcXVlc3RzXHJcbiAgICAgIHByb3h5OiAnJyxcclxuICAgIH07XHJcbiAgICB0aGlzLnNldE9wdGlvbnMoIG9wdGlvbnMgKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIE1lcmdlIG9wdGlvbnNcclxuICAgKiBAcGFyYW0ge29iamVjdH0gIG9wdGlvbnMgIE9wdGlvbnMgb2JqZWN0XHJcbiAgICovXHJcbiAgc2V0T3B0aW9ucyggb3B0aW9ucyApIHtcclxuICAgIE9iamVjdC5hc3NpZ24oIHRoaXMuX29wdGlvbnMsIG9wdGlvbnMgKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIENvbnZlcnQgb2JqZWN0IGludG8gYSBxdWVyeSBzdHJpbmdcclxuICAgKiBAcGFyYW0ge29iamVjdH0gIGRhdGEgIEtleS9WYWwgZGF0YSBwYWlyc1xyXG4gICAqL1xyXG4gIHNlcmlhbGl6ZURhdGEoIGRhdGEgKSB7XHJcbiAgICBsZXQgcSA9IFtdO1xyXG4gICAgaWYgKCB0eXBlb2YgZGF0YSA9PT0gJ29iamVjdCcgKSB7XHJcbiAgICAgIE9iamVjdC5rZXlzKCBkYXRhICkuZm9yRWFjaCggayA9PiB7XHJcbiAgICAgICAgcS5wdXNoKCBlbmNvZGVVUklDb21wb25lbnQoIGsgKSArJz0nKyBlbmNvZGVVUklDb21wb25lbnQoIGRhdGFbIGsgXSApICk7XHJcbiAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHEuam9pbiggJyYnICk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBHRVQgcmVxdWVzdCBhbGlhc1xyXG4gICAqL1xyXG4gIGdldCggYWRkcmVzcywgb3B0aW9ucyApIHtcclxuICAgIHRoaXMucmVxdWVzdCggJ0dFVCcsIGFkZHJlc3MsIG9wdGlvbnMgKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFBPU1QgcmVxdWVzdCBhbGlhc1xyXG4gICAqL1xyXG4gIHBvc3QoIGFkZHJlc3MsIG9wdGlvbnMgKSB7XHJcbiAgICB0aGlzLnJlcXVlc3QoICdQT1NUJywgYWRkcmVzcywgb3B0aW9ucyApO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogUFVUIHJlcXVlc3QgYWxpYXNcclxuICAgKi9cclxuICBwdXQoIGFkZHJlc3MsIG9wdGlvbnMgKSB7XHJcbiAgICB0aGlzLnJlcXVlc3QoICdQVVQnLCBhZGRyZXNzLCBvcHRpb25zICk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBERUxFVEUgcmVxdWVzdCBhbGlhc1xyXG4gICAqL1xyXG4gIGRlbGV0ZSggYWRkcmVzcywgb3B0aW9ucyApIHtcclxuICAgIHRoaXMucmVxdWVzdCggJ0RFTEVURScsIGFkZHJlc3MsIG9wdGlvbnMgKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEFKQVggcmVxdWVzdCBtZXRob2RcclxuICAgKiBAcGFyYW0ge3N0cmluZ30gIG1ldGhvZCAgIFJlcXVlc3QgbWV0aG9kIHZlcmJcclxuICAgKiBAcGFyYW0ge3N0cmluZ30gIGFkZHJlc3MgIEVuZHBvaW50IFVSTFxyXG4gICAqIEBwYXJhbSB7b2JqZWN0fSAgb3B0aW9ucyAgUmVxdWVzdCBvcHRpb25zXHJcbiAgICovXHJcbiAgcmVxdWVzdCggbWV0aG9kLCBhZGRyZXNzLCBvcHRpb25zICkge1xyXG4gICAgbWV0aG9kICA9IFN0cmluZyggbWV0aG9kIHx8ICcnICkudG9VcHBlckNhc2UoKTtcclxuICAgIGFkZHJlc3MgPSBTdHJpbmcoIGFkZHJlc3MgfHwgJycgKS50cmltKCk7XHJcbiAgICBvcHRpb25zID0gT2JqZWN0LmFzc2lnbigge30sIHRoaXMuX29wdGlvbnMsIG9wdGlvbnMgKTtcclxuXHJcbiAgICAvLyBzZXR1cCBvcHRpb25zXHJcbiAgICBsZXQgaXNEb25lICAgID0gZmFsc2U7XHJcbiAgICBsZXQgdHlwZSAgICAgID0gU3RyaW5nKCBvcHRpb25zLnR5cGUgfHwgJ3RleHQnICk7XHJcbiAgICBsZXQgcHJveHkgICAgID0gU3RyaW5nKCBvcHRpb25zLnByb3h5IHx8ICcnICkudHJpbSgpO1xyXG4gICAgbGV0IHRpbWVvdXQgICA9IHBhcnNlSW50KCBvcHRpb25zLnRpbWVvdXQgKSB8fCAwO1xyXG4gICAgbGV0IGhlYWRlcnMgICA9IE9iamVjdC5hc3NpZ24oIHt9LCBvcHRpb25zLmhlYWRlcnMgKTtcclxuICAgIGxldCBjYWNoZVRpbWUgPSBwYXJzZUludCggb3B0aW9ucy5jYWNoZSApIHx8IDA7IC8vIHNlY29uZHMgdG8gYmUgY2FjaGVkXHJcbiAgICBsZXQgY2FjaGVLZXkgID0gb3B0aW9ucy5wcmVmaXggKyB1dGlscy51bmlxdWUoIG1ldGhvZCArJ3wnKyBhZGRyZXNzICk7XHJcbiAgICBsZXQgeGhyICAgICAgID0gbmV3IFhNTEh0dHBSZXF1ZXN0KCk7XHJcblxyXG4gICAgLy8gc2V0dXAgY2FsbGJhY2tzXHJcbiAgICBsZXQgb25FcnJvciAgID0gKCB0eXBlb2Ygb3B0aW9ucy5lcnJvciA9PT0gJ2Z1bmN0aW9uJyApICAgPyBvcHRpb25zLmVycm9yICAgOiBmdW5jdGlvbigpIHt9O1xyXG4gICAgbGV0IG9uU3VjY2VzcyA9ICggdHlwZW9mIG9wdGlvbnMuc3VjY2VzcyA9PT0gJ2Z1bmN0aW9uJyApID8gb3B0aW9ucy5zdWNjZXNzIDogZnVuY3Rpb24oKSB7fTtcclxuICAgIGxldCBvbkRvbmUgICAgPSAoIHR5cGVvZiBvcHRpb25zLmRvbmUgPT09ICdmdW5jdGlvbicgKSAgICA/IG9wdGlvbnMuZG9uZSAgICA6IGZ1bmN0aW9uKCkge307XHJcblxyXG4gICAgLy8gY2hlY2sgcGFyYW1zXHJcbiAgICBpZiAoICFtZXRob2QgKSByZXR1cm4gb25FcnJvciggeGhyLCAwLCAnTXVzdCBzcGVjaWZ5IGEgcmVxdWVzdCBtZXRob2QgdG8gbWFrZSBhIG5ldyByZXF1ZXN0LicgKTtcclxuICAgIGlmICggIWFkZHJlc3MgKSByZXR1cm4gb25FcnJvciggeGhyLCAwLCAnTXVzdCBzcGVjaWZ5IGEgcmVxdWVzdCB1cmwgYWRkcmVzcyB0byBtYWtlIGEgbmV3IHJlcXVlc3QuJyApO1xyXG5cclxuICAgIC8vIGNoZWNrIGNhY2hlXHJcbiAgICBpZiAoIGNhY2hlVGltZSApIHtcclxuICAgICAgY29uc3QgY2FjaGVEYXRhID0gc3RvcmUuZ2V0RGF0YSggY2FjaGVLZXkgKTtcclxuICAgICAgaWYgKCBjYWNoZURhdGEgKSB7XHJcbiAgICAgICAgb25TdWNjZXNzKCB4aHIsIDIwMCwgY2FjaGVEYXRhICk7XHJcbiAgICAgICAgb25Eb25lKCB4aHIsIDIwMCwgY2FjaGVEYXRhICk7XHJcbiAgICAgICAgaXNEb25lID0gdHJ1ZTtcclxuICAgICAgICByZXR1cm47XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvLyByZXNvbHZlIGZ1bGwgcmVxdWVzdCB1cmxcclxuICAgIGxldCBmdWxsVXJsID0gdXRpbHMuZnVsbFVybCggYWRkcmVzcyApO1xyXG4gICAgdHJ5IHsgdGhpcy5fdXJsID0gbmV3IFVSTCggZnVsbFVybCApOyB9XHJcbiAgICBjYXRjaCAoIGVyciApIHt9XHJcblxyXG4gICAgLy8gZW5jb2RlIGRhdGEgZm9yIGdldCByZXF1ZXN0c1xyXG4gICAgaWYgKCBtZXRob2QgPT09ICdHRVQnICYmIHR5cGVvZiBvcHRpb25zLmRhdGEgPT09ICdvYmplY3QnICkge1xyXG4gICAgICBoZWFkZXJzWyAnQ29udGVudC10eXBlJyBdID0gJ2FwcGxpY2F0aW9uL3gtd3d3LWZvcm0tdXJsZW5jb2RlZCc7XHJcbiAgICAgIGZ1bGxVcmwgKz0gJz8nICsgdGhpcy5zZXJpYWxpemVEYXRhKCBvcHRpb25zLmRhdGEgKTtcclxuICAgICAgb3B0aW9ucy5kYXRhID0gbnVsbDtcclxuICAgIH1cclxuXHJcbiAgICAvLyBpbml0IHJlcXVlc3QgaGFuZGxlclxyXG4gICAgeGhyLm9wZW4oIG1ldGhvZCwgcHJveHkgKyBmdWxsVXJsLCB0cnVlICk7XHJcbiAgICB4aHIucmVzcG9uc2VUeXBlID0gdHlwZTtcclxuXHJcbiAgICAvLyBzZXQgdGltZW91dFxyXG4gICAgaWYgKCB0aW1lb3V0ICkge1xyXG4gICAgICB4aHIudGltZW91dCA9ICggdGltZW91dCA8IDEwMDAgKSA/IDEwMDAgKiB0aW1lb3V0IDogdGltZW91dDtcclxuICAgIH1cclxuXHJcbiAgICAvLyBkZWZhdWx0IGhlYWRlcnNcclxuICAgIHhoci5zZXRSZXF1ZXN0SGVhZGVyKCAnQWNjZXB0JywgJ2FwcGxpY2F0aW9uL2pzb24sIHRleHQvcGxhaW4sIHRleHQvaHRtbCwgKi8qJyApO1xyXG5cclxuICAgIC8vIHNlbmQgYWpheCBoZWFkZXIgdW5sZXNzIHN0YXRlZCBub3QgdG9cclxuICAgIGlmICggIW9wdGlvbnMubm90QWpheCApIHtcclxuICAgICAgeGhyLnNldFJlcXVlc3RIZWFkZXIoICdYLVJlcXVlc3RlZC1XaXRoJywgJ1hNTEh0dHBSZXF1ZXN0JyApO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIGNoZWNrIGZvciBiYXNpYyBhdXRoIGRhdGEgYW5kIHNldCBoZWFkZXJcclxuICAgIGlmICggb3B0aW9ucy5hdXRoICYmIHR5cGVvZiBvcHRpb25zLmF1dGggPT09ICdvYmplY3QnICkge1xyXG4gICAgICBsZXQgdXNlcm5hbWUgPSBTdHJpbmcoIG9wdGlvbnMuYXV0aC51c2VybmFtZSB8fCAnJyApLnRyaW0oKTtcclxuICAgICAgbGV0IHBhc3N3b3JkID0gU3RyaW5nKCBvcHRpb25zLmF1dGgucGFzc3dvcmQgfHwgJycgKS50cmltKCk7XHJcbiAgICAgIHhoci5zZXRSZXF1ZXN0SGVhZGVyKCAnQXV0aG9yaXphdGlvbicsICdCYXNpYyAnKyBidG9hKCB1c2VybmFtZSArJzonKyBwYXNzd29yZCApICk7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gY3VzdG9tIGhlYWRlcnNcclxuICAgIE9iamVjdC5rZXlzKCBoZWFkZXJzICkuZm9yRWFjaCggbmFtZSA9PiB7XHJcbiAgICAgIHhoci5zZXRSZXF1ZXN0SGVhZGVyKCBuYW1lLCBoZWFkZXJzWyBuYW1lIF0gKTtcclxuICAgIH0pO1xyXG5cclxuICAgIC8vIGRhdGEgbG9hZCBoYW5kbGVyXHJcbiAgICB4aHIuYWRkRXZlbnRMaXN0ZW5lciggJ2xvYWQnLCBlID0+IHtcclxuICAgICAgbGV0IHsgc3RhdHVzLCByZXNwb25zZSwgZXJyb3IgfSA9IHRoaXMuX3Jlc3BvbnNlUGFyYW1zKCAnbG9hZCcsIHhociwgdHlwZSApO1xyXG5cclxuICAgICAgbG9nZ2VyKCBzdGF0dXMsIG1ldGhvZCwgZnVsbFVybCApO1xyXG4gICAgICBsb2dnZXIoIHJlc3BvbnNlICk7XHJcblxyXG4gICAgICBpZiAoIHN0YXR1cyAmJiBzdGF0dXMgPCA0MDAgKSB7XHJcbiAgICAgICAgaWYgKCBjYWNoZVRpbWUgKSBzdG9yZS5zZXREYXRhKCBjYWNoZUtleSwgcmVzcG9uc2UsIGNhY2hlVGltZSApO1xyXG4gICAgICAgIG9uU3VjY2VzcyggeGhyLCBzdGF0dXMsIHJlc3BvbnNlICk7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgb25FcnJvciggeGhyLCBzdGF0dXMsIGVycm9yICk7XHJcbiAgICAgIH1cclxuICAgICAgaWYgKCAhaXNEb25lICkgb25Eb25lKCB4aHIsIHN0YXR1cywgcmVzcG9uc2UgKTtcclxuICAgICAgaXNEb25lID0gdHJ1ZTtcclxuICAgIH0pO1xyXG5cclxuICAgIC8vIHJlcXVlc3QgZXJyb3IgaGFuZGxlclxyXG4gICAgeGhyLmFkZEV2ZW50TGlzdGVuZXIoICdlcnJvcicsIGUgPT4ge1xyXG4gICAgICBsZXQgeyBzdGF0dXMsIHJlc3BvbnNlLCBlcnJvciB9ID0gdGhpcy5fcmVzcG9uc2VQYXJhbXMoICdlcnJvcicsIHhociwgdHlwZSApO1xyXG4gICAgICBvbkVycm9yKCB4aHIsIHN0YXR1cywgZXJyb3IgKTtcclxuICAgICAgaWYgKCAhaXNEb25lICkgb25Eb25lKCB4aHIsIHN0YXR1cywgcmVzcG9uc2UgKTtcclxuICAgICAgaXNEb25lID0gdHJ1ZTtcclxuICAgIH0pO1xyXG5cclxuICAgIC8vIHJlcXVlc3QgYWJvcnQgaGFuZGxlclxyXG4gICAgeGhyLmFkZEV2ZW50TGlzdGVuZXIoICdhYm9ydCcsIGUgPT4ge1xyXG4gICAgICBsZXQgeyBzdGF0dXMsIHJlc3BvbnNlLCBlcnJvciB9ID0gdGhpcy5fcmVzcG9uc2VQYXJhbXMoICdhYm9ydCcsIHhociwgdHlwZSApO1xyXG4gICAgICBvbkVycm9yKCB4aHIsIHN0YXR1cywgZXJyb3IgKTtcclxuICAgICAgaWYgKCAhaXNEb25lICkgb25Eb25lKCB4aHIsIHN0YXR1cywgcmVzcG9uc2UgKTtcclxuICAgICAgaXNEb25lID0gdHJ1ZTtcclxuICAgIH0pO1xyXG5cclxuICAgIC8vIHJlcXVlc3QgdGltZW91dCBoYW5kbGVyXHJcbiAgICB4aHIuYWRkRXZlbnRMaXN0ZW5lciggJ3RpbWVvdXQnLCBlID0+IHtcclxuICAgICAgbGV0IHsgc3RhdHVzLCByZXNwb25zZSwgZXJyb3IgfSA9IHRoaXMuX3Jlc3BvbnNlUGFyYW1zKCAndGltZW91dCcsIHhociwgdHlwZSApO1xyXG4gICAgICBvbkVycm9yKCB4aHIsIHN0YXR1cywgZXJyb3IgKTtcclxuICAgICAgaWYgKCAhaXNEb25lICkgb25Eb25lKCB4aHIsIHN0YXR1cywgcmVzcG9uc2UgKTtcclxuICAgICAgaXNEb25lID0gdHJ1ZTtcclxuICAgIH0pO1xyXG5cclxuICAgIC8vIHNlbmQgdGhlIHJlcXVlc3RcclxuICAgIHhoci5zZW5kKCBvcHRpb25zLmRhdGEgfHwgbnVsbCApO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogUGFyc2UgaW5mb3JtYXRpb24gYWJvdXQgdGhlIHJlc3BvbnNlXHJcbiAgICogQHBhcmFtIHtzdHJpbmd9ICBldnQgICBFdmVudCB0eXBlXHJcbiAgICogQHBhcmFtIHtvYmplY3R9ICB4aHIgICBYTUxIdHRwUmVxdWVzdCBvYmplY3RcclxuICAgKiBAcGFyYW0ge3N0cmluZ30gIHR5cGUgIEV4cGVjdGVkIHJlc3BvbnNlIHR5cGVcclxuICAgKi9cclxuICBfcmVzcG9uc2VQYXJhbXMoIGV2dCwgeGhyLCB0eXBlICkge1xyXG4gICAgbGV0IGhvc3RuYW1lID0gdGhpcy5fdXJsLmhvc3RuYW1lIHx8ICdub2hvc3QnO1xyXG4gICAgbGV0IHN0YXR1cyAgID0geGhyLnN0YXR1cyB8IDA7XHJcbiAgICBsZXQgcmVzcG9uc2UgPSAoIHR5cGUgPT09ICd0ZXh0JyApID8geGhyLnJlc3BvbnNlVGV4dCA6IHhoci5yZXNwb25zZTtcclxuICAgIGxldCBlcnJvciAgICA9ICcnO1xyXG5cclxuICAgIGlmICggZXZ0ID09PSAnbG9hZCcgJiYgc3RhdHVzID49IDQwMCAmJiByZXNwb25zZSApIHtcclxuICAgICAgZXJyb3IgPSBgJHtob3N0bmFtZX0oJHtzdGF0dXN9KTogYCsgdGhpcy5fZGF0YVJlZHVjZSggcmVzcG9uc2UgKTtcclxuICAgIH1cclxuICAgIGlmICggZXZ0ID09PSAnZXJyb3InICkge1xyXG4gICAgICBlcnJvciA9IGAke2hvc3RuYW1lfSgke3N0YXR1c30pOiBUaGUgcmVxdWVzdCBoYXMgYmVlbiBhYm9ydGVkIGR1ZSB0byBhIG5ldHdvcmsgcmVsYXRlZCBwcm9ibGVtLmA7XHJcbiAgICB9XHJcbiAgICBpZiAoIGV2dCA9PT0gJ2Fib3J0JyApIHtcclxuICAgICAgZXJyb3IgPSBgJHtob3N0bmFtZX0oJHtzdGF0dXN9KTogVGhlIHJlcXVlc3QgaGFzIGJlZW4gYWJvcnRlZCBieSB0aGUgY2xpZW50IGJlZm9yZSBjb21wbGV0aW5nLmA7XHJcbiAgICB9XHJcbiAgICBpZiAoIGV2dCA9PT0gJ3RpbWVvdXQnICkge1xyXG4gICAgICBlcnJvciA9IGAke2hvc3RuYW1lfSgke3N0YXR1c30pOiBUaGUgcmVxdWVzdCBoYXMgYmVlbiBhYm9ydGVkIGR1ZSB0byB0aGUgc2VydmVyIG5vdCByZXNwb25kaW5nLmA7XHJcbiAgICB9XHJcbiAgICBpZiAoICggc3RhdHVzIDw9IDAgfHwgc3RhdHVzID49IDQwMCApICYmICFlcnJvciApIHtcclxuICAgICAgZXJyb3IgPSBgJHtob3N0bmFtZX0oJHtzdGF0dXN9KTogVGhlIHJlcXVlc3Qgd2FzIHJlamVjdGVkIGJ5IHRoZSBzZXJ2ZXIgYW5kIG5vIGVycm9yIG1lc3NhZ2Ugd2FzIGdpdmVuLmA7XHJcbiAgICB9XHJcbiAgICByZXR1cm4geyBzdGF0dXMsIHJlc3BvbnNlLCBlcnJvciB9O1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogUmVkdWNlIGRhdGEgb2JqZWN0IGludG8gYSBzaW5nbGUgc3RyaW5nIGxpbmUuXHJcbiAgICogQHBhcmFtIHtvYmplY3R9ICBkYXRhICAgICBPYmplY3Qgb3Igc3RyaW5nIHRvIGJlIHNjYW5uZWRcclxuICAgKiBAcGFyYW0ge2FycmF5fSAgIG91dHB1dCAgIE91dHB1dCBhcnJheVxyXG4gICAqL1xyXG4gIF9kYXRhUmVkdWNlKCBkYXRhLCBvdXRwdXQgKSB7XHJcbiAgICBvdXRwdXQgPSBvdXRwdXQgfHwgW107XHJcblxyXG4gICAgaWYgKCBkYXRhICYmIHR5cGVvZiBkYXRhID09PSAnc3RyaW5nJyApIHtcclxuICAgICAgb3V0cHV0LnB1c2goIGRhdGEgKTtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKCBkYXRhICYmIHR5cGVvZiBkYXRhID09PSAnb2JqZWN0JyApIHtcclxuICAgICAgT2JqZWN0LmtleXMoIGRhdGEgKS5mb3JFYWNoKCBrZXkgPT4ge1xyXG4gICAgICAgIHRoaXMuX2RhdGFSZWR1Y2UoIGRhdGFbIGtleSBdLCBvdXRwdXQgKTtcclxuICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gb3V0cHV0LmpvaW4oICcgfCAnICkucmVwbGFjZSggL1tcXHRcXHJcXG5cXHNdKy9nLCAnICcgKS50cmltKCk7XHJcbiAgfVxyXG5cclxufVxyXG5cclxuIiwiLyoqXHJcbiAqIFByaWNlIGFsYXJtcyBoZWxwZXIgY2xhc3NcclxuICovXHJcbmltcG9ydCBCdXMgZnJvbSAnLi9idXMnO1xyXG5pbXBvcnQgc3RvcmUgZnJvbSAnLi9zdG9yZSc7XHJcbmltcG9ydCB1dGlscyBmcm9tICcuL3V0aWxzJztcclxuXHJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEFsYXJtcyBleHRlbmRzIEJ1cyB7XHJcblxyXG4gIC8qKlxyXG4gICAqIENvbnN0cnVjdG9yXHJcbiAgICovXHJcbiAgY29uc3RydWN0b3IoIG9wdGlvbnMgKSB7XHJcbiAgICBzdXBlcigpO1xyXG4gICAgdGhpcy5fYWxhcm1zICA9IFtdO1xyXG4gICAgdGhpcy5fb3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oIHtcclxuICAgICAgLy8ga2V5IHVzZWQgZm9yIHN0b3JhZ2VcclxuICAgICAga2V5OiAnYWxhcm1zX2RhdGEnLFxyXG4gICAgICAvLyAuLi5cclxuICAgIH0sIG9wdGlvbnMgKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFNhdmUgY3VycmVudCBhbGFybXMgZGF0YSB0byBzdG9yZSBhbmQgZW1pdCBsaXN0XHJcbiAgICovXHJcbiAgc2F2ZURhdGEoKSB7XHJcbiAgICB0aGlzLmVtaXQoICd1cGRhdGUnLCB0aGlzLl9hbGFybXMgKTtcclxuICAgIHN0b3JlLnNldERhdGEoIHRoaXMuX29wdGlvbnMua2V5LCB0aGlzLl9hbGFybXMgKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIExvYWQgc2F2ZWQgaGlzdG9yeSBkYXRhIGZyb20gc3RvcmVcclxuICAgKi9cclxuICBsb2FkRGF0YSgpIHtcclxuICAgIGxldCBkYXRhID0gc3RvcmUuZ2V0RGF0YSggdGhpcy5fb3B0aW9ucy5rZXkgKTtcclxuICAgIGlmICggIWRhdGEgfHwgIUFycmF5LmlzQXJyYXkoIGRhdGEgKSApIHJldHVybjtcclxuICAgIHRoaXMuX2FsYXJtcyA9IGRhdGE7XHJcbiAgICB0aGlzLmVtaXQoICd1cGRhdGUnLCB0aGlzLl9hbGFybXMgKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEdldCBjb3VudCBvZiBhY3RpdmUgYWxhcm1zIGZvciBhIHN5bWJvbFxyXG4gICAqIEBwYXJhbSB7c3RyaW5nfSAgc3ltYm9sICBQYWlyIHN5bWJvbCBzdHJpbmdcclxuICAgKi9cclxuICBnZXRDb3VudCggc3ltYm9sICkge1xyXG4gICAgcmV0dXJuIHRoaXMuX2FsYXJtcy5maWx0ZXIoIGEgPT4gKCBhLnN5bWJvbCA9PT0gc3ltYm9sICYmIGEuYWN0aXZlICkgKS5sZW5ndGg7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBBZGRzIGFuIGFsYXJtIGZvciBhIHBhaXJcclxuICAgKiBAcGFyYW0ge29iamVjdH0gIHBhaXJEYXRhICBQYWlyIGRhdGEgb2JqZWN0IGZyb20gYmluYW5jZSBzb2NrZXQgY2xhc3NcclxuICAgKiBAcGFyYW0ge251bWJlcn0gIHByaWNlICAgICBBbGFybSBwcmljZVxyXG4gICAqL1xyXG4gIGFkZCggcGFpckRhdGEsIHByaWNlICkge1xyXG4gICAgaWYgKCAhcGFpckRhdGEgfHwgIXBhaXJEYXRhLnN5bWJvbCB8fCAhcGFpckRhdGEuY2xvc2UgKSByZXR1cm4gZmFsc2U7XHJcbiAgICBsZXQgeyBzeW1ib2wsIHRva2VuLCBhc3NldCwgcGFpciwgaW1hZ2UsIGNsb3NlIH0gPSBwYWlyRGF0YTtcclxuXHJcbiAgICBjbG9zZSA9IHBhcnNlRmxvYXQoIGNsb3NlICkgfHwgMDsgLy8gY3VycmVudCBwcmljZVxyXG4gICAgcHJpY2UgPSBwYXJzZUZsb2F0KCBwcmljZSApIHx8IDA7IC8vIGFsYXJtIHByaWNlXHJcblxyXG4gICAgaWYgKCAhY2xvc2UgfHwgIXByaWNlIHx8IGNsb3NlID09PSBwcmljZSApIHJldHVybiBmYWxzZTtcclxuICAgIGlmICggdGhpcy5maW5kKCBzeW1ib2wsIHByaWNlICkubGVuZ3RoICkgcmV0dXJuIGZhbHNlO1xyXG5cclxuICAgIGxldCBpZCAgICAgPSB1dGlscy5yYW5kU3RyaW5nKCAyMCApO1xyXG4gICAgbGV0IHRpbWUgICA9IERhdGUubm93KCk7XHJcbiAgICBsZXQgYWN0aXZlID0gdHJ1ZTtcclxuICAgIGxldCBhcnJvdyAgPSAoIHByaWNlID4gY2xvc2UgKSA/ICfilrInIDogJ+KWvCc7XHJcbiAgICBsZXQgc2lnbiAgID0gKCBwcmljZSA+IGNsb3NlICkgPyAn4omlJyA6ICfiiaQnO1xyXG4gICAgbGV0IGNoZWNrICA9ICggcHJpY2UgPiBjbG9zZSApID8gJ2dhaW4nIDogJ2xvc3MnO1xyXG4gICAgbGV0IGFsYXJtICA9IHsgaWQsIHRpbWUsIGFjdGl2ZSwgYXJyb3csIHNpZ24sIGNoZWNrLCBzeW1ib2wsIHRva2VuLCBhc3NldCwgcGFpciwgaW1hZ2UsIGNsb3NlLCBwcmljZSB9O1xyXG5cclxuICAgIHRoaXMuX2FsYXJtcy5wdXNoKCBhbGFybSApO1xyXG4gICAgdGhpcy5zYXZlRGF0YSgpO1xyXG4gICAgcmV0dXJuIHRydWU7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBGaW5kIGV4aXN0aW5nIGFsYXJtcyBmb3IgYSBzeW1ib2wgYW5kIHByaWNlXHJcbiAgICogQHBhcmFtIHtzdHJpbmd9ICBzeW1ib2wgIFBhaXIgc3ltYm9sIHN0cmluZ1xyXG4gICAqIEBwYXJhbSB7bnVtYmVyfSAgcHJpY2UgICBBbGFybSBwcmljZVxyXG4gICAqL1xyXG4gIGZpbmQoIHN5bWJvbCwgcHJpY2UgKSB7XHJcbiAgICBwcmljZSA9IHBhcnNlRmxvYXQoIHByaWNlICkgfHwgMDtcclxuICAgIHJldHVybiB0aGlzLl9hbGFybXMuZmlsdGVyKCBhID0+ICggYS5zeW1ib2wgPT09IHN5bWJvbCAmJiBhLnByaWNlID09PSBwcmljZSApICk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBSZW1vdmUgYW4gYWxhcm0gZnJvbSB0aGUgbGlzdCBieSBJRFxyXG4gICAqIEBwYXJhbSB7c3RyaW5nfSAgaWQgIFVuaXF1ZSBhbGFybSBJRFxyXG4gICAqL1xyXG4gIHJlbW92ZSggaWQgKSB7XHJcbiAgICBpZiAoICFpZCB8fCB0eXBlb2YgaWQgIT09ICdzdHJpbmcnICkgcmV0dXJuO1xyXG4gICAgdGhpcy5fYWxhcm1zID0gdGhpcy5fYWxhcm1zLmZpbHRlciggYSA9PiBhLmlkICE9PSBpZCApO1xyXG4gICAgdGhpcy5zYXZlRGF0YSgpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogVG9nZ2xlIHN0YXR1cyBmb3IgYW4gYWxhcm0gYnkgSURcclxuICAgKiBAcGFyYW0ge3N0cmluZ30gICBpZCAgICAgIFVuaXF1ZSBhbGFybSBJRFxyXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gIGFjdGl2ZSAgQWxhcm0gYWN0aXZlIHN0YXR1c1xyXG4gICAqL1xyXG4gIHRvZ2dsZSggaWQsIGFjdGl2ZSApIHtcclxuICAgIGlmICggIWlkIHx8IHR5cGVvZiBpZCAhPT0gJ3N0cmluZycgKSByZXR1cm47XHJcbiAgICBpZiAoIHR5cGVvZiBhY3RpdmUgIT09ICdib29sZWFuJyApIHJldHVybjtcclxuXHJcbiAgICB0aGlzLl9hbGFybXMuZm9yRWFjaCggYSA9PiB7XHJcbiAgICAgIGlmICggYS5pZCAhPT0gaWQgKSByZXR1cm47XHJcbiAgICAgIGEuYWN0aXZlID0gYWN0aXZlO1xyXG4gICAgfSk7XHJcbiAgICB0aGlzLnNhdmVEYXRhKCk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBGbHVzaCBhbGwgYWxhcm1zXHJcbiAgICovXHJcbiAgZmx1c2goKSB7XHJcbiAgICB0aGlzLl9hbGFybXMgPSBbXTtcclxuICAgIHRoaXMuc2F2ZURhdGEoKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIENoZWNrIHByaWNlIG9mIGEgc3ltYm9sIGFnYWluc3QgYWxsIHNhdmVkIGFsYXJtc1xyXG4gICAqIEBwYXJhbSB7c3RyaW5nfSAgIHN5bWJvbCAgICBQYWlyIHN5bWJvbCBzdHJpbmdcclxuICAgKiBAcGFyYW0ge251bWJlcn0gICBjbG9zZSAgICAgQ3VycmVudCBwYWlyIGNsb3NlIHByaWNlXHJcbiAgICogQHBhcmFtIHtmdW5jdGlvbn0gY2FsbGJhY2sgIENhbGxiYWNrIGhhbmRsZXJcclxuICAgKi9cclxuICBjaGVjayggc3ltYm9sLCBjbG9zZSwgY2FsbGJhY2sgKSB7XHJcbiAgICBsZXQgY291bnQgPSAwO1xyXG5cclxuICAgIGZvciAoIGxldCBpID0gMDsgaSA8IHRoaXMuX2FsYXJtcy5sZW5ndGg7ICsraSApIHtcclxuICAgICAgbGV0IGEgPSB0aGlzLl9hbGFybXNbIGkgXTtcclxuICAgICAgbGV0IHByaWNlID0gTnVtYmVyKCBhLnByaWNlIHx8IDAgKTtcclxuXHJcbiAgICAgIGlmICggYS5zeW1ib2wgIT09IHN5bWJvbCB8fCAhYS5hY3RpdmUgKSBjb250aW51ZTtcclxuICAgICAgaWYgKCBhLmNoZWNrID09PSAnbG9zcycgJiYgY2xvc2UgPiBwcmljZSApIGNvbnRpbnVlO1xyXG4gICAgICBpZiAoIGEuY2hlY2sgPT09ICdnYWluJyAmJiBjbG9zZSA8IHByaWNlICkgY29udGludWU7XHJcblxyXG4gICAgICBsZXQgZGlmZiA9ICdlcXVhbCB0byc7XHJcbiAgICAgIGlmICggY2xvc2UgPiBwcmljZSApIGRpZmYgPSAnbW9yZSB0aGFuJztcclxuICAgICAgaWYgKCBjbG9zZSA8IHByaWNlICkgZGlmZiA9ICdsZXNzIHRoYW4nO1xyXG5cclxuICAgICAgbGV0IGNsb3NlRml4ZWQgPSBOdW1iZXIoIGNsb3NlICkudG9GaXhlZCggOCApO1xyXG4gICAgICBsZXQgcHJpY2VGaXhlZCA9IE51bWJlciggcHJpY2UgKS50b0ZpeGVkKCA4ICk7XHJcblxyXG4gICAgICBsZXQgdGl0bGUgPSBgJHthLnN5bWJvbH0gcHJpY2UgJHthLmFycm93fSAke2Nsb3NlRml4ZWR9ICR7YS5hc3NldH1gO1xyXG4gICAgICBsZXQgaW5mbyAgPSBgJHthLnN5bWJvbH0gaXMgbm93ICR7ZGlmZn0geW91ciBhbGFybSBwcmljZSBvZiAke3ByaWNlRml4ZWR9ICR7YS5hc3NldH0uYDtcclxuXHJcbiAgICAgIGNhbGxiYWNrKCB0aXRsZSwgaW5mbywgYSApO1xyXG4gICAgICBhLmFjdGl2ZSA9IGZhbHNlO1xyXG4gICAgICBjb3VudCsrO1xyXG4gICAgfVxyXG4gICAgLy8gc2F2ZSBhbGFybXMgZGF0YSBpZiBhbGFybXMgd2VyZSB0cmlnZ2VyZWRcclxuICAgIGlmICggY291bnQgKSB0aGlzLnNhdmVEYXRhKCk7XHJcbiAgfVxyXG5cclxufVxyXG4iLCIvKipcbiAqIEJpbmFuY2Ugc29ja2V0IGFwaSB3cmFwcGVyIGNsYXNzXG4gKi9cbmltcG9ydCBCdXMgZnJvbSAnLi9idXMnO1xuaW1wb3J0IFN5bWJvbCBmcm9tICcuL3N5bWJvbCc7XG5pbXBvcnQgdXRpbHMgZnJvbSAnLi91dGlscyc7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEJpbmFuY2UgZXh0ZW5kcyBCdXMge1xuXG4gIC8qKlxuICAgKiBDb25zdHJ1Y3RvclxuICAgKi9cbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoKTtcbiAgICB0aGlzLl9hamF4ICAgICAgPSBudWxsO1xuICAgIHRoaXMuX2FwaXVybCAgICA9ICdodHRwczovL2FwaS5iaW5hbmNlLmNvbS9hcGknO1xuICAgIHRoaXMuX3dzc3VybCAgICA9ICd3c3M6Ly9zdHJlYW0uYmluYW5jZS5jb206OTQ0Myc7XG4gICAgdGhpcy5fYXBpa2V5ICAgID0gJyc7ICAgIC8vIGJpbmFuY2UgQVBJIGtleVxuICAgIHRoaXMuX2FwaXNlY3JldCA9ICcnOyAgICAvLyBiaW5hbmNlIEFQSSBzZWNyZXRcbiAgICB0aGlzLl9saXN0ZW5rZXkgPSAnJzsgICAgLy8gdXNlciBzdHJlYW0gbGlzdGVuIGtleVxuICAgIHRoaXMuX3dhaXQgICAgICA9IDEwMDAwOyAvLyByZWNvbm5lY3Qgd2FpdCAobWlscylcbiAgICB0aGlzLl9jb2luZGF0YSAgPSB7fTsgICAgLy8gZGF0YSBhYm91dCBlYWNoIHRva2VuXG4gICAgdGhpcy5fc3ltYm9scyAgID0ge307ICAgIC8vIHVuaXF1ZSBzeW1ib2xzIGRhdGEgY2FjaGVcbiAgICB0aGlzLl9tYXJrZXRzICAgPSB7fTsgICAgLy8gYXZhaWxhYmxlIG1hcmtldHMgYW5kIHRvdGFsIGFzc2V0c1xuICAgIHRoaXMuX3JlY29ubmVjdCA9IHt9O1xuICAgIHRoaXMuX3RpbWVycyAgICA9IHt9O1xuICAgIHRoaXMuX3NvY2tzICAgICA9IHt9O1xuICB9XG5cbiAgLyoqXG4gICAqIFNldCBhamF4IG1vZHVsZSByZWZlcmVuY2UgdG8gdXNlIGZvciByZXF1ZXN0c1xuICAgKi9cbiAgdXNlQWpheCggYWpheCApIHtcbiAgICB0aGlzLl9hamF4ID0gYWpheDtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXQgQVBJIGtleVxuICAgKi9cbiAgc2V0QXBpS2V5KCBrZXkgPSAnJyApIHtcbiAgICB0aGlzLl9hcGlrZXkgPSBTdHJpbmcoIGtleSB8fCAnJyApLnRyaW0oKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXQgQVBJIHNlY3JldFxuICAgKi9cbiAgc2V0QXBpU2VjcmV0KCBzZWNyZXQgPSAnJyApIHtcbiAgICB0aGlzLl9hcGlzZWNyZXQgPSBTdHJpbmcoIHNlY3JldCB8fCAnJyApLnRyaW0oKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXQgY29pbnMgZGF0YSBmZXRjaGVkIGZyb20gc29tZXdoZXJlIGVsc2VcbiAgICovXG4gIHNldENvaW5EYXRhKCBkYXRhID0ge30gKSB7XG4gICAgdGhpcy5fY29pbmRhdGEgPSBPYmplY3QuYXNzaWduKCB0aGlzLl9jb2luZGF0YSwgZGF0YSApO1xuICB9XG5cbiAgLyoqXG4gICAqIFNldCBzb2NrZXQgcmVjb25uZWN0IGJvb2xlYW4gZm9yIGFuIGlkXG4gICAqL1xuICBzZXRSZWNvbm5lY3QoIGlkLCB0b2dnbGUgKSB7XG4gICAgdGhpcy5fcmVjb25uZWN0WyBpZCBdID0gdG9nZ2xlID8gdHJ1ZSA6IGZhbHNlO1xuICB9XG5cbiAgLyoqXG4gICAqIENoZWNrIHJlY29ubmVjdCB0b2dnbGUgZm9yIGFuIGlkIGFuZCBjYWxsIGEgaGFuZGxlciBmdW5jdGlvblxuICAgKi9cbiAgY2hlY2tSZWNvbm5lY3QoIGlkLCBjYWxsYmFjayApIHtcbiAgICBpZiAoICF0aGlzLl9yZWNvbm5lY3RbIGlkIF0gKSByZXR1cm47XG4gICAgc2V0VGltZW91dCggY2FsbGJhY2ssIHRoaXMuX3dhaXQgKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgcHVibGljIGFwaSBlbmRwb2ludCB1cmxcbiAgICovXG4gIGdldFB1YmxpY1VybCggZW5kcG9pbnQsIHBhcmFtcyApIHtcbiAgICBsZXQgcXN0ciA9IHRoaXMuX2FqYXguc2VyaWFsaXplRGF0YSggT2JqZWN0LmFzc2lnbigge30sIHBhcmFtcyApICk7XG4gICAgcmV0dXJuIHRoaXMuX2FwaXVybCArIGVuZHBvaW50ICsgJz8nICsgcXN0cjtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdXNlciBzaWduZWQgYXBpIGVuZHBvaW50IHVybFxuICAgKi9cbiAgZ2V0U2lnbmVkVXJsKCBlbmRwb2ludCwgcGFyYW1zICkge1xuICAgIGxldCBjcnlwdG8gICAgID0gd2luZG93LkNyeXB0b0pTIHx8IG51bGw7XG4gICAgbGV0IHJlY3ZXaW5kb3cgPSAxMDAwMDA7XG4gICAgbGV0IHRpbWVzdGFtcCAgPSBEYXRlLm5vdygpIC0gKCByZWN2V2luZG93IC8gMiApO1xuICAgIGxldCBxc3RyICAgICAgID0gdGhpcy5fYWpheC5zZXJpYWxpemVEYXRhKCBPYmplY3QuYXNzaWduKCB7IHJlY3ZXaW5kb3csIHRpbWVzdGFtcCB9LCBwYXJhbXMgKSApO1xuICAgIGxldCBzaWduYXR1cmUgID0gY3J5cHRvID8gY3J5cHRvLkhtYWNTSEEyNTYoIHFzdHIsIHRoaXMuX2FwaXNlY3JldCApLnRvU3RyaW5nKCBjcnlwdG8uZW5jLkhleCApIDogJyc7XG4gICAgcmV0dXJuIHRoaXMuX2FwaXVybCArIGVuZHBvaW50ICsgJz8nICsgcXN0ciArICcmc2lnbmF0dXJlPScgKyBzaWduYXR1cmU7XG4gIH1cblxuICAvKipcbiAgICogRmV0Y2ggZGF0YSBhYm91dCBhdmFpbGFibGUgbWFya2V0cyBmb3JtIGV4Y2hhbmdlXG4gICAqL1xuICBmZXRjaE1hcmtldHNEYXRhKCkge1xuICAgIGlmICggIXRoaXMuX2FqYXggKSByZXR1cm47XG4gICAgY29uc3QgcmVtb3RlID0gYCR7dGhpcy5fYXBpdXJsfS92My9leGNoYW5nZUluZm9gO1xuICAgIGNvbnN0IGxvY2FsICA9IGAuLi8uLi8uLi8uLi9wdWJsaWMvbWFya2V0L2pzb24vZXhjaGFuZ2VJbmZvLmpzb25gO1xuXG4gICAgLy8gYnVpbGQgbWFya2V0cyBkYXRhIGFuZCBlbWl0IGl0IG91dFxuICAgIGNvbnN0IGhhbmRsZVJlc3BvbnNlID0gKCByZXMgKSA9PiB7XG4gICAgICBpZiAoIHJlcyAmJiBBcnJheS5pc0FycmF5KCByZXMuc3ltYm9scyApICkge1xuICAgICAgICBmb3IgKCBsZXQgc3ltYiBvZiByZXMuc3ltYm9scyApIHtcbiAgICAgICAgICBsZXQgdG9rZW4gPSBzeW1iLnF1b3RlQXNzZXQ7IC8vIG1hcmtldFxuICAgICAgICAgIGxldCBjb3VudCA9IHJlcy5zeW1ib2xzLmZpbHRlciggcyA9PiAoIHMucXVvdGVBc3NldCA9PT0gdG9rZW4gJiYgcy5iYXNlQXNzZXQgIT09IHRva2VuICYmIHMuc3RhdHVzID09PSAnVFJBRElORycgKSApLmxlbmd0aDtcbiAgICAgICAgICB0aGlzLl9tYXJrZXRzWyB0b2tlbiBdID0geyB0b2tlbiwgY291bnQgfTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmVtaXQoICdtYXJrZXRzX2RhdGEnLCB0aGlzLl9tYXJrZXRzICk7XG4gICAgICB9XG4gICAgfVxuICAgIC8vIHRyeSByZW1vdGUsIHRoZW4gbG9jYWwgaWYgaXQgZmFpbHNcbiAgICB0aGlzLl9hamF4LmdldCggcmVtb3RlLCB7XG4gICAgICB0eXBlOiAnanNvbicsXG4gICAgICBzdWNjZXNzOiAoIHhociwgc3RhdHVzLCByZXMgKSA9PiBoYW5kbGVSZXNwb25zZSggcmVzICksXG4gICAgICBlcnJvcjogKCB4aHIsIHN0YXR1cywgZXJyICkgPT4ge1xuICAgICAgICB0aGlzLl9hamF4LmdldCggbG9jYWwsIHtcbiAgICAgICAgICB0eXBlOiAnanNvbicsXG4gICAgICAgICAgcHJveHk6IGZhbHNlLFxuICAgICAgICAgIHN1Y2Nlc3M6ICggeGhyLCBzdGF0dXMsIHJlcyApID0+IGhhbmRsZVJlc3BvbnNlKCByZXMgKSxcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogRmV0Y2ggbGFzdCAyNGggY2FuZGxlIGRhdGFcbiAgICovXG4gIGZldGNoQ2hhcnREYXRhKCBzeW1ib2wsIGNiICkge1xuICAgICBpZiAoICF0aGlzLl9hamF4IHx8ICFzeW1ib2wgKSByZXR1cm47XG4gICAgIGNvbnN0IGVuZHBvaW50ID0gYCR7dGhpcy5fYXBpdXJsfS92My9rbGluZXM/c3ltYm9sPSR7c3ltYm9sfSZpbnRlcnZhbD0xaCZsaW1pdD0xNjhgO1xuICAgICBjb25zdCBwcmljZXMgICA9IFtdO1xuXG4gICAgdGhpcy5fYWpheC5nZXQoIGVuZHBvaW50LCB7XG4gICAgICB0eXBlOiAnanNvbicsXG4gICAgICAvLyBjYWNoZTogNjAwLFxuICAgICAgc3VjY2VzczogKCB4aHIsIHN0YXR1cywgcmVzICkgPT4ge1xuICAgICAgICBpZiAoIHJlcyAmJiBBcnJheS5pc0FycmF5KCByZXMgKSApIHtcbiAgICAgICAgICBmb3IgKCBsZXQgaSA9IDA7IGkgPCByZXMubGVuZ3RoOyArK2kgKSB7XG4gICAgICAgICAgICBwcmljZXMucHVzaCggcGFyc2VGbG9hdCggcmVzWyBpIF1bIDQgXSApICk7IC8vIGNsb3NlIHByaWNlXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICggdHlwZW9mIGNiID09PSAnZnVuY3Rpb24nICkgY2IoIHByaWNlcyApO1xuICAgICAgICB0aGlzLmVtaXQoICdjaGFydF9kYXRhJywgeyBzeW1ib2wsIHByaWNlcyB9ICk7XG4gICAgICB9LFxuICAgICAgZXJyb3I6ICggeGhyLCBzdGF0dXMsIGVyciApID0+IHtcbiAgICAgICAgaWYgKCB0eXBlb2YgY2IgPT09ICdmdW5jdGlvbicgKSBjYiggcHJpY2VzICk7XG4gICAgICAgIGNvbnNvbGUud2FybiggZXJyICk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogUGFyc2UgdXNlciBiYWxhbmNlcyBkYXRhXG4gICAqL1xuICBwYXJzZVVzZXJCYWxhbmNlcyggZGF0YSApIHtcbiAgICBsZXQgYmFsYW5jZXMgPSBbXTtcbiAgICBpZiAoIEFycmF5LmlzQXJyYXkoIGRhdGEgKSApIGJhbGFuY2VzID0gZGF0YTsgLy8gYXMtaXNcbiAgICBpZiAoIEFycmF5LmlzQXJyYXkoIGRhdGEuYmFsYW5jZXMgKSApIGJhbGFuY2VzID0gZGF0YS5iYWxhbmNlczsgLy8gaHR0cFxuICAgIGlmICggQXJyYXkuaXNBcnJheSggZGF0YS5CICkgKSBiYWxhbmNlcyA9IGRhdGEuQjsgLy8gd2Vic29ja2V0XG5cbiAgICBiYWxhbmNlcyA9IGJhbGFuY2VzLm1hcCggdCA9PiB7XG4gICAgICBsZXQgYXNzZXQgID0gU3RyaW5nKCB0LmEgfHwgdC5hc3NldCB8fCAnJyApO1xuICAgICAgbGV0IHBhaXIgICA9ICggYXNzZXQgPT09ICdCVEMnICkgPyAnVVNEVCcgOiAnQlRDJztcbiAgICAgIGxldCByb3V0ZSAgPSAnL3N5bWJvbC8nKyBhc3NldCArIHBhaXI7XG4gICAgICBsZXQgbmFtZSAgID0gdGhpcy5fbmFtZXNbIGFzc2V0IF0gfHwgYXNzZXQ7XG4gICAgICBsZXQgZnJlZSAgID0gcGFyc2VGbG9hdCggdC5mIHx8IHQuZnJlZSApIHx8IDA7XG4gICAgICBsZXQgbG9ja2VkID0gcGFyc2VGbG9hdCggdC5sIHx8IHQubG9ja2VkICkgfHwgMDtcbiAgICAgIGxldCB0b3RhbCAgPSAoIGZyZWUgKyBsb2NrZWQgKTtcbiAgICAgIHJldHVybiB7IGFzc2V0LCBuYW1lLCByb3V0ZSwgZnJlZSwgbG9ja2VkLCB0b3RhbCB9O1xuICAgIH0pO1xuICAgIHJldHVybiBiYWxhbmNlcy5maWx0ZXIoIHQgPT4gKCB0LnRvdGFsID4gMCApICk7XG4gIH1cblxuICAvKipcbiAgICogUGFyc2Ugb3JkZXIgZGF0YSBmcm9tIGFuIEFQSS9Tb2NrZXQgcmVzcG9uc2UgYW5kIGNvbWJpbmUgaXQgd2l0aCBzeW1ib2wgZGF0YVxuICAgKiBAcGFyYW0ge29iamVjdH0gIGRhdGEgIE9yZGVyIGRhdGEgcmVzcG9uc2VcbiAgICovXG4gIHBhcnNlT3JkZXJEYXRhKCBkYXRhICkge1xuICAgIGxldCBub3cgICAgICAgPSBEYXRlLm5vdygpO1xuICAgIGxldCB0aW1lICAgICAgPSBOdW1iZXIoIGRhdGEuVCB8fCBkYXRhLnRyYW5zYWN0VGltZSB8fCBub3cgKTsgICAgICAvLyB0cmFuc2FjdGlvbiB0aW1lXG4gICAgbGV0IGlkICAgICAgICA9IFN0cmluZyggZGF0YS5pIHx8IGRhdGEub3JkZXJJZCB8fCAnJyApOyAgICAgICAgICAgIC8vIG9yZGVyIGlkXG4gICAgbGV0IHN5bWJvbCAgICA9IFN0cmluZyggZGF0YS5zIHx8IGRhdGEuc3ltYm9sIHx8ICcnICk7ICAgICAgICAgICAgIC8vIHRyYWRlIHBhaXIgc3ltYm9sXG4gICAgbGV0IHNpZGUgICAgICA9IFN0cmluZyggZGF0YS5TIHx8IGRhdGEuc2lkZSB8fCAnJyApOyAgICAgICAgICAgICAgIC8vIGJvb2sgc2lkZSAoQlVZLCBTRUxMKVxuICAgIGxldCB0eXBlICAgICAgPSBTdHJpbmcoIGRhdGEubyB8fCBkYXRhLnR5cGUgfHwgJycgKTsgICAgICAgICAgICAgICAvLyBvcmRlciB0eXBlIChMSU1JVCwgTUFSS0VULCBldGMpXG4gICAgbGV0IHN0YXR1cyAgICA9IFN0cmluZyggZGF0YS5YIHx8IGRhdGEuc3RhdHVzIHx8ICcnICk7ICAgICAgICAgICAgIC8vIG9yZGVyIHN0YXR1cyAoTkVXLCBDQU5DRUxFRCwgRklMTEVELCBldGMpXG4gICAgbGV0IHByaWNlICAgICA9IE51bWJlciggZGF0YS5wIHx8IGRhdGEucHJpY2UgfHwgMCApOyAgICAgICAgICAgICAgIC8vIG9yZGVyIGJvb2sgcHJpY2VcbiAgICBsZXQgcXVhbnRpdHkgID0gTnVtYmVyKCBkYXRhLnEgfHwgZGF0YS5vcmlnUXR5IHx8IDAgKTsgICAgICAgICAgICAgLy8gb3JpZ2luYWwgdHJhZGUgcXVhbnRpdHlcbiAgICBsZXQgZmlsbGVkICAgID0gTnVtYmVyKCBkYXRhLnogfHwgZGF0YS5leGVjdXRlZFF0eSB8fCAwICk7ICAgICAgICAgLy8gZmlsbGVkIHRyYWRlIHF1YW50aXR5XG4gICAgbGV0IHRvdGFsICAgICA9IE51bWJlciggZGF0YS5aIHx8IGRhdGEuY3VtbXVsYXRpdmVRdW90ZVF0eSB8fCAwICk7IC8vIHRvdGFsIHRyYWRlIGFzc2V0IGNvc3RcbiAgICBsZXQgZmVlQXNzZXQgID0gU3RyaW5nKCBkYXRhLk4gfHwgJycgKTsgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gZmVlIGFzc2V0IHVzZWQgZm9yIGNvbW1pc3Npb24gKEJOQiwgZXRjKVxuICAgIGxldCBmZWVBbW91bnQgPSBOdW1iZXIoIGRhdGEubiB8fCAwICk7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBmZWUgY29tbWlzc2lvbiBhbW91bnRcbiAgICBsZXQgcGVyY2VudCAgID0gTnVtYmVyKCBmaWxsZWQgLyBxdWFudGl0eSAqIDEwMCApOyAgICAgICAgICAgICAgICAgLy8gZmlsbGVkIHBlcmNlbnRcblxuICAgIC8vIHJlc29sdmUgYXZhaWxhYmxlIGFtb3VudCBhZnRlciB0b2tlbiBmZWUgaGFzIGJlZW4gZGVkdWN0ZWRcbiAgICBsZXQgc21iICAgID0gdGhpcy5fc3ltYm9sc1sgc3ltYm9sIF0gfHwgbmV3IFN5bWJvbCggc3ltYm9sICk7XG4gICAgbGV0IGFtb3VudCA9ICggZmVlQXNzZXQgPT09IHNtYi50b2tlbiApID8gKCBxdWFudGl0eSAtIGZlZUFtb3VudCApIDogcXVhbnRpdHk7XG4gICAgbGV0IHVuaXF1ZSA9IHV0aWxzLnVuaXF1ZSggc3ltYm9sICsnfCcrIE1hdGguZmxvb3IoIGFtb3VudCApICk7XG5cbiAgICBzdGF0dXMgPSAoIHN0YXR1cyA9PT0gJ05FVycgKSA/ICdPUEVOJyA6IHN0YXR1cztcbiAgICBpZiAoICFwcmljZSAmJiB0b3RhbCApIHsgcHJpY2UgPSAoIHRvdGFsIC8gcXVhbnRpdHkgKTsgfVxuICAgIGlmICggIXRvdGFsICYmIHByaWNlICkgeyB0b3RhbCA9ICggcHJpY2UgKiBxdWFudGl0eSApOyB9XG5cbiAgICByZXR1cm4gc21iLmdldERhdGEoIHsgaWQsIHVuaXF1ZSwgc2lkZSwgdGltZSwgdHlwZSwgc3RhdHVzLCBwcmljZSwgcXVhbnRpdHksIGZpbGxlZCwgYW1vdW50LCB0b3RhbCwgZmVlQXNzZXQsIGZlZUFtb3VudCwgcGVyY2VudCB9ICk7XG4gIH1cblxuICAvKipcbiAgICogQnVpbGQgZmFrZSBvcmRlciBkYXRhXG4gICAqIEBwYXJhbSB7c3RyaW5nfSAgc3ltYm9sICAgIEZ1bGwgdHJhZGluZyBzeW1ib2xcbiAgICogQHBhcmFtIHtzdHJpbmd9ICB0eXBlICAgICAgT3JkZXIgdHlwZSAoTElNSVQsIE1BUktFVClcbiAgICogQHBhcmFtIHtzdHJpbmd9ICBzaWRlICAgICAgQm9vayBzaWRlIChCVVksIFNFTEwpXG4gICAqIEBwYXJhbSB7bnVtYmVyfSAgcHJpY2UgICAgIEJvb2sgcHJpY2VcbiAgICogQHBhcmFtIHtudW1iZXJ9ICBxdWFudGl0eSAgT3JkZXIgcXVhbnRpdHlcbiAgICovXG4gIGZha2VPcmRlckRhdGEoIHN5bWJvbCwgdHlwZSwgc2lkZSwgcHJpY2UsIHF1YW50aXR5LCBzdGF0dXMgKSB7XG4gICAgbGV0IHRpbWUgPSBEYXRlLm5vdygpO1xuICAgIGxldCBpZCA9IHV0aWxzLnJhbmRTdHJpbmcoIDIwICk7XG4gICAgbGV0IHByaWNlU3RyID0gTnVtYmVyKCBwcmljZSApLnRvRml4ZWQoIDggKTtcbiAgICBsZXQgcXVhbnRpdHlTdHIgPSBOdW1iZXIoIHF1YW50aXR5ICkudG9GaXhlZCggMCApO1xuICAgIGxldCB0b3RhbFN0ciA9IE51bWJlciggcHJpY2UgKiBxdWFudGl0eSApLnRvRml4ZWQoIDggKTtcbiAgICByZXR1cm4gdGhpcy5wYXJzZU9yZGVyRGF0YSgge1xuICAgICAgc3ltYm9sOiBzeW1ib2wsXG4gICAgICBvcmRlcklkOiBpZCxcbiAgICAgIHRyYW5zYWN0VGltZTogdGltZSxcbiAgICAgIHByaWNlOiBwcmljZVN0cixcbiAgICAgIG9yaWdRdHk6IHF1YW50aXR5U3RyLFxuICAgICAgZXhlY3V0ZWRRdHk6IHF1YW50aXR5U3RyLFxuICAgICAgY3VtbXVsYXRpdmVRdW90ZVF0eTogdG90YWxTdHIsXG4gICAgICBzdGF0dXM6IHN0YXR1cyxcbiAgICAgIHR5cGU6IHR5cGUsXG4gICAgICBzaWRlOiBzaWRlXG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogU2ltdWxhdGUgYW4gb3JkZXIgd2l0aCBmYWtlIEFQSSByZXF1ZXN0XG4gICAqIEBwYXJhbSB7c3RyaW5nfSAgc3ltYm9sICAgIEZ1bGwgdHJhZGluZyBzeW1ib2xcbiAgICogQHBhcmFtIHtzdHJpbmd9ICB0eXBlICAgICAgT3JkZXIgdHlwZSAoTElNSVQsIE1BUktFVClcbiAgICogQHBhcmFtIHtzdHJpbmd9ICBzaWRlICAgICAgQm9vayBzaWRlIChCVVksIFNFTEwpXG4gICAqIEBwYXJhbSB7bnVtYmVyfSAgcHJpY2UgICAgIEJvb2sgcHJpY2VcbiAgICogQHBhcmFtIHtudW1iZXJ9ICBxdWFudGl0eSAgT3JkZXIgcXVhbnRpdHlcbiAgICovXG4gIHBsYWNlRmFrZU9yZGVyKCBzeW1ib2wsIHR5cGUsIHNpZGUsIHByaWNlLCBxdWFudGl0eSApIHtcbiAgICBsZXQgc2VjcyA9IE1hdGguZmxvb3IoIDEwMDAgKyBNYXRoLnJhbmRvbSgpICogNDAwMCApOyAvLyAxLTUgc2Vjc1xuICAgIGxldCBvcmRlck9wZW4gPSB0aGlzLmZha2VPcmRlckRhdGEoIHN5bWJvbCwgdHlwZSwgc2lkZSwgcHJpY2UsIHF1YW50aXR5LCAnT1BFTicgKTtcbiAgICBsZXQgb3JkZXJGaWxsZWQgPSB0aGlzLmZha2VPcmRlckRhdGEoIHN5bWJvbCwgdHlwZSwgc2lkZSwgcHJpY2UsIHF1YW50aXR5LCAnRklMTEVEJyApO1xuICAgIGxldCBvcmRlckNhbmNlbGVkID0gdGhpcy5mYWtlT3JkZXJEYXRhKCBzeW1ib2wsIHR5cGUsIHNpZGUsIHByaWNlLCBxdWFudGl0eSwgJ0NBTkNFTEVEJyApO1xuICAgIGxldCBvcmRlclJlc3VsdCA9ICggc2VjcyA8IDQ5MDAgKSA/IG9yZGVyRmlsbGVkIDogb3JkZXJDYW5jZWxlZDtcbiAgICBzZXRUaW1lb3V0KCAoKSA9PiB7IHRoaXMuZW1pdCggJ2Jvb2tfY3JlYXRlJywgb3JkZXJPcGVuICkgfSwgMzAwICk7IC8vIGFkZGVkIHRvIGJvb2tcbiAgICBzZXRUaW1lb3V0KCAoKSA9PiB7IHRoaXMuZW1pdCggJ3VzZXJfb3JkZXInLCBvcmRlclJlc3VsdCApIH0sIHNlY3MgKTsgLy8gZmlsbGVkIG9yIGNhbmNlbGVkXG4gIH1cblxuICAvKipcbiAgICogUGxhY2UgbmV3IG9yZGVyIGluIGJvb2tcbiAgICogQHBhcmFtIHtzdHJpbmd9ICBzeW1ib2wgICAgRnVsbCB0cmFkaW5nIHN5bWJvbFxuICAgKiBAcGFyYW0ge3N0cmluZ30gIHR5cGUgICAgICBPcmRlciB0eXBlIChMSU1JVCwgTUFSS0VUKVxuICAgKiBAcGFyYW0ge3N0cmluZ30gIHNpZGUgICAgICBCb29rIHNpZGUgKEJVWSwgU0VMTClcbiAgICogQHBhcmFtIHtudW1iZXJ9ICBwcmljZSAgICAgQm9vayBwcmljZVxuICAgKiBAcGFyYW0ge251bWJlcn0gIHF1YW50aXR5ICBPcmRlciBxdWFudGl0eVxuICAgKiBAcGFyYW0ge3N0cmluZ30gIGluZm9yY2UgICBUaW1lIGluZm9yY2UgdHlwZSAoR1RDLCBJT0MsIEZPSylcbiAgICovXG4gIHBsYWNlT3JkZXIoIHN5bWJvbCwgdHlwZSwgc2lkZSwgcHJpY2UsIHF1YW50aXR5LCBpbmZvcmNlICkge1xuICAgIGlmICggIXRoaXMuX2FwaWtleSB8fCAhdGhpcy5fYWpheCApIHJldHVybjtcbiAgICBpZiAoICFzeW1ib2wgfHwgIXR5cGUgfHwgIXNpZGUgfHwgIXF1YW50aXR5IHx8IHF1YW50aXR5IDw9IDAgKSByZXR1cm47XG5cbiAgICBwcmljZSA9IE51bWJlciggcHJpY2UgKS50b0ZpeGVkKCA4ICk7XG4gICAgcXVhbnRpdHkgPSBOdW1iZXIoIHF1YW50aXR5ICkudG9GaXhlZCggMCApO1xuICAgIGluZm9yY2UgPSBTdHJpbmcoIGluZm9yY2UgfHwgJ0ZPSycgKTtcblxuICAgIGxldCBwYXJhbXMgPSB7IHN5bWJvbCwgc2lkZSwgdHlwZSwgcXVhbnRpdHkgfTtcbiAgICBpZiAoIHR5cGUgPT09ICdMSU1JVCcgKSBPYmplY3QuYXNzaWduKCBwYXJhbXMsIHsgcHJpY2UsIHRpbWVJbkZvcmNlOiBpbmZvcmNlIH0gKTtcbiAgICBPYmplY3QuYXNzaWduKCBwYXJhbXMsIHsgbmV3T3JkZXJSZXNwVHlwZTogJ1JFU1VMVCcgfSApO1xuXG4gICAgdGhpcy5fYWpheC5wb3N0KCB0aGlzLmdldFNpZ25lZFVybCggJy92My9vcmRlcicsIHBhcmFtcyApLCB7XG4gICAgICB0eXBlOiAnanNvbicsXG4gICAgICBoZWFkZXJzOiB7ICdYLU1CWC1BUElLRVknOiB0aGlzLl9hcGlrZXkgfSxcblxuICAgICAgc3VjY2VzczogKCB4aHIsIHN0YXR1cywgcmVzcG9uc2UgKSA9PiB7XG4gICAgICAgIGxldCBvcmRlciA9IHRoaXMucGFyc2VPcmRlckRhdGEoIHJlc3BvbnNlICk7XG4gICAgICAgIHRoaXMuZW1pdCggJ2Jvb2tfY3JlYXRlJywgb3JkZXIgKTtcbiAgICAgIH0sXG4gICAgICBlcnJvcjogKCB4aHIsIHN0YXR1cywgZXJyb3IgKSA9PiB7XG4gICAgICAgIGxldCBvcmRlciA9IHRoaXMuZmFrZU9yZGVyRGF0YSggc3ltYm9sLCB0eXBlLCBzaWRlLCBwcmljZSwgcXVhbnRpdHksICdSRUpFQ1RFRCcgKTtcbiAgICAgICAgdGhpcy5lbWl0KCAnYm9va19mYWlsJywgb3JkZXIsIGVycm9yICk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogQ2FuY2VsIG9yZGVyIGZyb20gYm9va1xuICAgKiBAcGFyYW0ge3N0cmluZ30gIHN5bWJvbCAgICBGdWxsIHRyYWRpbmcgc3ltYm9sXG4gICAqIEBwYXJhbSB7bnVtYmVyfSAgb3JkZXJJZCAgIE9yZGVyIElEIG51bWJlclxuICAgKiBAcGFyYW0ge251bWJlcn0gIHF1YW50aXR5ICBPcmRlciBxdWFudGl0eVxuICAgKi9cbiAgY2FuY2VsT3JkZXIoIHN5bWJvbCwgb3JkZXJJZCwgcXVhbnRpdHkgKSB7XG4gICAgaWYgKCAhdGhpcy5fYXBpa2V5IHx8ICF0aGlzLl9hamF4ICkgcmV0dXJuO1xuICAgIGlmICggIXN5bWJvbCB8fCAhb3JkZXJJZCApIHJldHVybjtcblxuICAgIHRoaXMuX2FqYXguZGVsZXRlKCB0aGlzLmdldFNpZ25lZFVybCggJy92My9vcmRlcicsIHsgc3ltYm9sLCBvcmRlcklkIH0gKSwge1xuICAgICAgdHlwZTogJ2pzb24nLFxuICAgICAgaGVhZGVyczogeyAnWC1NQlgtQVBJS0VZJzogdGhpcy5fYXBpa2V5IH0sXG5cbiAgICAgIHN1Y2Nlc3M6ICggeGhyLCBzdGF0dXMsIHJlc3BvbnNlICkgPT4ge1xuICAgICAgICBsZXQgb3JkZXIgPSB0aGlzLmZha2VPcmRlckRhdGEoIHN5bWJvbCwgJ01BUktFVCcsICdDQU5DRUwnLCAxLCBxdWFudGl0eSwgJ0NPTVBMRVRFJyApO1xuICAgICAgICB0aGlzLmVtaXQoICdib29rX2NhbmNlbCcsIG9yZGVyICk7XG4gICAgICB9LFxuICAgICAgZXJyb3I6ICggeGhyLCBzdGF0dXMsIGVycm9yICkgPT4ge1xuICAgICAgICBsZXQgb3JkZXIgPSB0aGlzLmZha2VPcmRlckRhdGEoIHN5bWJvbCwgJ01BUktFVCcsICdDQU5DRUwnLCAxLCBxdWFudGl0eSwgJ0ZBSUxFRCcgKTtcbiAgICAgICAgdGhpcy5lbWl0KCAnYm9va19mYWlsJywgb3JkZXIsIGVycm9yICk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogR2V0IHVzZXIgYWNjb3VudCBkYXRhIG92ZXIgYWpheFxuICAgKi9cbiAgZmV0Y2hVc2VyQWNjb3VudCgpIHtcbiAgICBpZiAoICF0aGlzLl9hcGlrZXkgfHwgIXRoaXMuX2FqYXggKSByZXR1cm47XG5cbiAgICB0aGlzLl9hamF4LmdldCggdGhpcy5nZXRTaWduZWRVcmwoICcvdjMvYWNjb3VudCcgKSwge1xuICAgICAgdHlwZTogJ2pzb24nLFxuICAgICAgaGVhZGVyczogeyAnWC1NQlgtQVBJS0VZJzogdGhpcy5fYXBpa2V5IH0sXG5cbiAgICAgIHN1Y2Nlc3M6ICggeGhyLCBzdGF0dXMsIHJlc3BvbnNlICkgPT4ge1xuICAgICAgICBsZXQgYmFsYW5jZXMgPSB0aGlzLnBhcnNlVXNlckJhbGFuY2VzKCByZXNwb25zZSApO1xuICAgICAgICB0aGlzLmVtaXQoICd1c2VyX2JhbGFuY2VzJywgYmFsYW5jZXMgKTtcbiAgICAgICAgdGhpcy5lbWl0KCAndXNlcl9kYXRhJywgdHJ1ZSApO1xuICAgICAgfSxcbiAgICAgIGVycm9yOiAoIHhociwgc3RhdHVzLCBlcnJvciApID0+IHtcbiAgICAgICAgdGhpcy5lbWl0KCAndXNlcl9mYWlsJywgZXJyb3IgKTtcbiAgICAgICAgdGhpcy5zdG9wVXNlclN0cmVhbSgpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIEZldGNoIGN1cnJlbnQgb3BlbiBvcmRlcnNcbiAgICovXG4gIGZldGNoT3Blbk9yZGVycygpIHtcbiAgICBpZiAoICF0aGlzLl9hcGlrZXkgfHwgIXRoaXMuX2FqYXggKSByZXR1cm47XG5cbiAgICB0aGlzLl9hamF4LmdldCggdGhpcy5nZXRTaWduZWRVcmwoICcvdjMvb3Blbk9yZGVycycgKSwge1xuICAgICAgdHlwZTogJ2pzb24nLFxuICAgICAgaGVhZGVyczogeyAnWC1NQlgtQVBJS0VZJzogdGhpcy5fYXBpa2V5IH0sXG5cbiAgICAgIHN1Y2Nlc3M6ICggeGhyLCBzdGF0dXMsIHJlc3BvbnNlICkgPT4ge1xuICAgICAgICByZXNwb25zZS5mb3JFYWNoKCBvID0+IHRoaXMuZW1pdCggJ3VzZXJfb3JkZXInLCB0aGlzLnBhcnNlT3JkZXJEYXRhKCBvICkgKSApO1xuICAgICAgICB0aGlzLmVtaXQoICd1c2VyX2RhdGEnLCB0cnVlICk7XG4gICAgICB9LFxuICAgICAgZXJyb3I6ICggeGhyLCBzdGF0dXMsIGVycm9yICkgPT4ge1xuICAgICAgICB0aGlzLmVtaXQoICd1c2VyX2ZhaWwnLCBlcnJvciApO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIEF0dGVtcHQgdG8gc3RhcnQgYSBuZXcgdXNlciBzdHJlYW1cbiAgICovXG4gIGluaXRVc2VyU3RyZWFtKCByZWNvbm5lY3QgKSB7XG4gICAgaWYgKCAhdGhpcy5fYXBpa2V5IHx8ICF0aGlzLl9hamF4ICkgcmV0dXJuO1xuXG4gICAgdGhpcy5lbWl0KCAndXNlcl9pbml0JywgRGF0ZS5ub3coKSApO1xuICAgIHRoaXMuc3RvcFVzZXJTdHJlYW0oKTtcblxuICAgIHRoaXMuX2FqYXgucG9zdCggdGhpcy5nZXRQdWJsaWNVcmwoICcvdjEvdXNlckRhdGFTdHJlYW0nICksIHtcbiAgICAgIHR5cGU6ICdqc29uJyxcbiAgICAgIGhlYWRlcnM6IHsgJ1gtTUJYLUFQSUtFWSc6IHRoaXMuX2FwaWtleSB9LFxuXG4gICAgICBzdWNjZXNzOiAoIHhociwgc3RhdHVzLCByZXNwb25zZSApID0+IHtcbiAgICAgICAgY29uc3QgdGltZSA9ICggMTAwMCAqIDYwICogMjAgKTsgLy8gMjAgbWluc1xuICAgICAgICBjb25zdCBmdW5jID0gdGhpcy5leHRlbmRTdHJlYW1LZXkuYmluZCggdGhpcyApO1xuICAgICAgICB0aGlzLl9saXN0ZW5rZXkgPSBTdHJpbmcoIHJlc3BvbnNlLmxpc3RlbktleSB8fCAnJyApLnRyaW0oKTtcbiAgICAgICAgdGhpcy5lbWl0KCAndXNlcl9saXN0ZW5rZXknLCB0aGlzLl9saXN0ZW5rZXkgKTtcbiAgICAgICAgdGhpcy5zdGFydFVzZXJTdHJlYW0oIHRoaXMuX2xpc3RlbmtleSwgcmVjb25uZWN0ICk7XG4gICAgICAgIHRoaXMuc3RhcnRUaW1lciggJ3VzZXInLCB0aW1lLCBmdW5jLCBmYWxzZSApO1xuICAgICAgfSxcbiAgICAgIGVycm9yOiAoIHhociwgc3RhdHVzLCBlcnJvciApID0+IHtcbiAgICAgICAgdGhpcy5lbWl0KCAndXNlcl9mYWlsJywgZXJyb3IgKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBFeHRlbmQgdXNlciBzdHJlYW0gbGlzdGVuIGtleVxuICAgKi9cbiAgZXh0ZW5kU3RyZWFtS2V5KCkge1xuICAgIGlmICggIXRoaXMuX2FwaWtleSB8fCAhdGhpcy5fYWpheCApIHJldHVybjtcbiAgICBpZiAoICF0aGlzLl9saXN0ZW5rZXkgKSByZXR1cm47XG5cbiAgICB0aGlzLl9hamF4LnB1dCggdGhpcy5nZXRQdWJsaWNVcmwoICcvdjEvdXNlckRhdGFTdHJlYW0nLCB7IGxpc3RlbktleTogdGhpcy5fbGlzdGVua2V5IH0gKSwge1xuICAgICAgdHlwZTogJ2pzb24nLFxuICAgICAgaGVhZGVyczogeyAnWC1NQlgtQVBJS0VZJzogdGhpcy5fYXBpa2V5IH0sXG5cbiAgICAgIHN1Y2Nlc3M6ICggeGhyLCBzdGF0dXMsIHJlc3BvbnNlICkgPT4ge1xuICAgICAgICB0aGlzLmVtaXQoICd1c2VyX2xpc3RlbmtleScsIHRoaXMuX2xpc3RlbmtleSApO1xuICAgICAgfSxcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDb25uZWN0IHRvIGEgbGl2ZSB1c2VyIGFjY291bnQgZGF0YSBzdHJlYW1cbiAgICovXG4gIHN0YXJ0VXNlclN0cmVhbSggbGlzdGVuS2V5LCByZWNvbm5lY3QgKSB7XG4gICAgdGhpcy5zZXRSZWNvbm5lY3QoICd1c2VyJywgcmVjb25uZWN0IHx8IGZhbHNlICk7XG4gICAgdGhpcy5lbWl0KCAndXNlcl9pbml0JywgRGF0ZS5ub3coKSApO1xuXG4gICAgY29uc3Qgd3MgPSB0aGlzLnNvY2tDb25uZWN0KCAndXNlcicsIHRoaXMuX3dzc3VybCArJy93cy8nKyBsaXN0ZW5LZXkgKTtcbiAgICBpZiAoICF3cyApIHJldHVybiB0aGlzLmVtaXQoICd1c2VyX2ZhaWwnLCAnQ291bGQgbm90IGNvbm5lY3QgdG8gdXNlciBzdHJlYW0gQVBJIGVuZHBvaW50LicgKTtcblxuICAgIHdzLmFkZEV2ZW50TGlzdGVuZXIoICdvcGVuJywgZSA9PiB7XG4gICAgICB0aGlzLmVtaXQoICd1c2VyX29wZW4nLCBlICk7XG4gICAgICB0aGlzLmZldGNoVXNlckFjY291bnQoKTtcbiAgICAgIHRoaXMuZmV0Y2hPcGVuT3JkZXJzKCk7XG4gICAgfSk7XG5cbiAgICB3cy5hZGRFdmVudExpc3RlbmVyKCAnZXJyb3InLCBlID0+IHtcbiAgICAgIHRoaXMuZW1pdCggJ3VzZXJfZXJyb3InLCBlICk7XG4gICAgICB0aGlzLnN0b3BUaW1lciggJ3VzZXInICk7XG4gICAgfSk7XG5cbiAgICB3cy5hZGRFdmVudExpc3RlbmVyKCAnY2xvc2UnLCBlID0+IHtcbiAgICAgIHRoaXMuZW1pdCggJ3VzZXJfY2xvc2UnLCBlICk7XG4gICAgICB0aGlzLnN0b3BUaW1lciggJ3VzZXInICk7XG4gICAgICB0aGlzLmNoZWNrUmVjb25uZWN0KCAndXNlcicsICgpID0+IHRoaXMuc3RhcnRVc2VyU3RyZWFtKCBsaXN0ZW5LZXksIHJlY29ubmVjdCApICk7XG4gICAgfSk7XG5cbiAgICB3cy5hZGRFdmVudExpc3RlbmVyKCAnbWVzc2FnZScsIGUgPT4ge1xuICAgICAgdGhpcy5lbWl0KCAndXNlcl9kYXRhJywgdHJ1ZSApO1xuICAgICAgbGV0IGRhdGEgPSBKU09OLnBhcnNlKCBlLmRhdGEgfHwgJ3t9JyApIHx8IHt9O1xuXG4gICAgICBpZiAoIGRhdGEuZSA9PT0gJ291dGJvdW5kQWNjb3VudEluZm8nICkge1xuICAgICAgICBsZXQgYmFsYW5jZXMgPSB0aGlzLnBhcnNlVXNlckJhbGFuY2VzKCBkYXRhICk7XG4gICAgICAgIHJldHVybiB0aGlzLmVtaXQoICd1c2VyX2JhbGFuY2VzJywgYmFsYW5jZXMgKTtcbiAgICAgIH1cbiAgICAgIGlmICggZGF0YS5lID09PSAnZXhlY3V0aW9uUmVwb3J0JyApIHtcbiAgICAgICAgbGV0IG9yZGVyID0gdGhpcy5wYXJzZU9yZGVyRGF0YSggZGF0YSApO1xuICAgICAgICByZXR1cm4gdGhpcy5lbWl0KCAndXNlcl9vcmRlcicsIG9yZGVyICk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogU3RvcCB1c2VyIHN0cmVhbVxuICAgKi9cbiAgc3RvcFVzZXJTdHJlYW0oKSB7XG4gICAgdGhpcy5zZXRSZWNvbm5lY3QoICd1c2VyJywgZmFsc2UgKTtcbiAgICB0aGlzLnN0b3BUaW1lciggJ3VzZXInICk7XG4gICAgdGhpcy5zb2NrQ2xvc2UoICd1c2VyJyApO1xuICB9XG5cbiAgLyoqXG4gICAqIENvbm5lY3QgdG8gbGl2ZSB0aWNrZXIgcHJpY2VzIHNvY2tldCBlbmRwb2ludFxuICAgKi9cbiAgc3RhcnRUaWNrZXJTdHJlYW0oIHJlY29ubmVjdCApIHtcbiAgICB0aGlzLnNldFJlY29ubmVjdCggJ3RpY2tlcicsIHJlY29ubmVjdCB8fCBmYWxzZSApO1xuICAgIHRoaXMuZW1pdCggJ3RpY2tlcl9pbml0JywgRGF0ZS5ub3coKSApO1xuXG4gICAgY29uc3Qgd3MgPSB0aGlzLnNvY2tDb25uZWN0KCAndGlja2VyJywgdGhpcy5fd3NzdXJsICsnL3dzLyF0aWNrZXJAYXJyJyApO1xuICAgIGlmICggIXdzICkgcmV0dXJuIHRoaXMuZW1pdCggJ3RpY2tlcl9mYWlsJywgJ0NvdWxkIG5vdCBjb25uZWN0IHRvIGxpdmUgdGlja2VyIHN0cmVhbSBBUEkgZW5kcG9pbnQuJyApO1xuXG4gICAgd3MuYWRkRXZlbnRMaXN0ZW5lciggJ29wZW4nLCBlID0+IHtcbiAgICAgIHRoaXMuZW1pdCggJ3RpY2tlcl9vcGVuJywgZSApO1xuICAgICAgdGhpcy5zdGFydFRpY2tlclRpbWVyKCk7XG4gICAgfSk7XG5cbiAgICB3cy5hZGRFdmVudExpc3RlbmVyKCAnZXJyb3InLCBlID0+IHtcbiAgICAgIHRoaXMuZW1pdCggJ3RpY2tlcl9lcnJvcicsIGUgKTtcbiAgICAgIHRoaXMuc3RvcFRpbWVyKCAndGlja2VyJyApO1xuICAgIH0pO1xuXG4gICAgd3MuYWRkRXZlbnRMaXN0ZW5lciggJ2Nsb3NlJywgZSA9PiB7XG4gICAgICB0aGlzLmVtaXQoICd0aWNrZXJfY2xvc2UnLCBlICk7XG4gICAgICB0aGlzLnN0b3BUaW1lciggJ3RpY2tlcicgKTtcbiAgICAgIHRoaXMuY2hlY2tSZWNvbm5lY3QoICd0aWNrZXInLCAoKSA9PiB0aGlzLnN0YXJ0VGlja2VyU3RyZWFtKCByZWNvbm5lY3QgKSApO1xuICAgIH0pO1xuXG4gICAgd3MuYWRkRXZlbnRMaXN0ZW5lciggJ21lc3NhZ2UnLCBlID0+IHtcbiAgICAgIHRoaXMuZW1pdCggJ3RpY2tlcl9kYXRhJywgdHJ1ZSApO1xuICAgICAgbGV0IGxpc3QgICAgPSBKU09OLnBhcnNlKCBlLmRhdGEgfHwgJ1tdJyApIHx8IFtdO1xuICAgICAgbGV0IG1hcmtldHMgPSBPYmplY3Qua2V5cyggdGhpcy5fbWFya2V0cyApO1xuICAgICAgbGV0IGNvdW50ICAgPSBsaXN0Lmxlbmd0aDtcblxuICAgICAgLy8gd2FpdCBmb3IgbWFya2V0cyBkYXRhIHRvIGJlIGF2YWlsYWJsZSBiZWZvcmUgY3JlYXRpbmcgc3ltYm9sc1xuICAgICAgaWYgKCAhbWFya2V0cy5sZW5ndGggfHwgIWNvdW50ICkgcmV0dXJuO1xuXG4gICAgICB3aGlsZSAoIGNvdW50LS0gKSB7XG4gICAgICAgIGxldCB0aWNrZXIgICA9IGxpc3RbIGNvdW50IF07XG4gICAgICAgIGxldCBwYWlyICAgICA9IHRpY2tlci5zOyAvLyB0cmFkaW5nIHBhaXIgc3ltYm9sIHN0clxuICAgICAgICBsZXQgc3ltYm9sICAgPSB0aGlzLl9zeW1ib2xzWyBwYWlyIF0gfHwgbmV3IFN5bWJvbCggcGFpciApOyAvLyBjYWNoZWRcblxuICAgICAgICBzeW1ib2wuc3BsaXRTeW1ib2woIG1hcmtldHMgKTsgLy8gc3BsaXQgcGFpciBzeW1ib2wgaW50byB0b2tlbiAvIG1hcmtldFxuICAgICAgICBzeW1ib2wuc2V0Q29pbkRhdGEoIHRoaXMuX2NvaW5kYXRhWyBzeW1ib2wudG9rZW4gXSApOyAvLyBkYXRhIGZyb20gY29pbmNhcC5pb1xuICAgICAgICBzeW1ib2wuc2V0VGlja2VyRGF0YSggdGlja2VyICk7IC8vIHVwZGF0ZSBzeW1ib2wgdGlja2VyIGRhdGFcbiAgICAgICAgc3ltYm9sLnJlc29sdmVJbWFnZSgpOyAvLyBmaW5kIGFuIGljb24gZm9yIHRoaXMgdG9rZW5cbiAgICAgICAgdGhpcy5fc3ltYm9sc1sgcGFpciBdID0gc3ltYm9sOyAvLyB1cGRhdGUgY2FjaGVcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTdGFydCB0aWNrZXIgZGF0YSB0aW1lclxuICAgKi9cbiAgc3RhcnRUaWNrZXJUaW1lcigpIHtcbiAgICB0aGlzLnN0b3BUaW1lciggJ3RpY2tlcicgKTtcbiAgICB0aGlzLnN0YXJ0VGltZXIoICd0aWNrZXInLCAxMDAwLCAoKSA9PiB7XG4gICAgICBsZXQga2V5cyAgID0gT2JqZWN0LmtleXMoIHRoaXMuX3N5bWJvbHMgKTtcbiAgICAgIGxldCBjb3VudCAgPSBrZXlzLmxlbmd0aDtcbiAgICAgIGxldCBwcmljZXMgPSBbXTtcblxuICAgICAgd2hpbGUgKCBjb3VudC0tICkgcHJpY2VzLnB1c2goIHRoaXMuX3N5bWJvbHNbIGtleXNbIGNvdW50IF0gXSApO1xuICAgICAgdGhpcy5lbWl0KCAndGlja2VyX3ByaWNlcycsIHByaWNlcyApO1xuICAgIH0sIHRydWUgKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTdG9wIHByaWNlIHRpY2tlclxuICAgKi9cbiAgc3RvcFRpY2tlclN0cmVhbSgpIHtcbiAgICB0aGlzLnNldFJlY29ubmVjdCggJ3RpY2tlcicsIGZhbHNlICk7XG4gICAgdGhpcy5zdG9wVGltZXIoICd0aWNrZXInICk7XG4gICAgdGhpcy5zb2NrQ2xvc2UoICd0aWNrZXInICk7XG4gIH1cblxuICAvKipcbiAgICogU3RhcnQgY3VzdG9tIHRpbWVyXG4gICAqIEBwYXJhbSB7c3RyaW5nfSAgICBpZCAgICAgICAgVGltZXIgaWQgbmFtZVxuICAgKiBAcGFyYW0ge251bWJlcn0gICAgdGltZSAgICAgIEludGVydmFsIG1pbHNcbiAgICogQHBhcmFtIHtmdW5jdGlvbn0gIGNhbGxiYWNrICBDYWxsYmFjayBmdW5jdGlvblxuICAgKiBAcGFyYW0ge2Jvb2xlYW59ICAgaW5pdCAgICAgIEluaXQgY2FsbGJhY2tcbiAgICovXG4gIHN0YXJ0VGltZXIoIGlkLCB0aW1lLCBjYWxsYmFjaywgaW5pdCApIHtcbiAgICB0aGlzLnN0b3BUaW1lciggaWQgKTtcbiAgICB0aGlzLl90aW1lcnNbIGlkIF0gPSBzZXRJbnRlcnZhbCggY2FsbGJhY2ssIHRpbWUgKTtcbiAgICBpZiAoIGluaXQgKSBjYWxsYmFjaygpO1xuICB9XG5cbiAgLyoqXG4gICAqIFN0b3AgY3VzdG9tIHRpbWVyXG4gICAqIEBwYXJhbSB7c3RyaW5nfSAgaWQgIFRpbWVyIGlkIG5hbWVcbiAgICovXG4gIHN0b3BUaW1lciggaWQgKSB7XG4gICAgaWYgKCAhaWQgfHwgIXRoaXMuX3RpbWVycy5oYXNPd25Qcm9wZXJ0eSggaWQgKSApIHJldHVybjtcbiAgICBjbGVhckludGVydmFsKCB0aGlzLl90aW1lcnNbIGlkIF0gKTtcbiAgICBkZWxldGUgdGhpcy5fdGltZXJzWyBpZCBdO1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhIFdlYlNvY2tldCBjb25uZWN0aW9uXG4gICAqIEBwYXJhbSB7c3RyaW5nfSAgaWQgICAgICBSZWYgaWQgbmFtZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gIGVuZHBvaW50ICBTb2NrZXQgZW5kcG9pbnQgdXJsXG4gICAqL1xuICBzb2NrQ29ubmVjdCggaWQsIGVuZHBvaW50ICkge1xuICAgIGlmICggIWlkIHx8ICFlbmRwb2ludCApIHJldHVybjtcbiAgICB0aGlzLmVtaXQoICdzb2NrX2luaXQnLCBlbmRwb2ludCApO1xuICAgIHRoaXMuc29ja0Nsb3NlKCBpZCApO1xuXG4gICAgaWYgKCAhKCAnV2ViU29ja2V0JyBpbiB3aW5kb3cgKSApIHtcbiAgICAgIHRoaXMuZW1pdCggJ3NvY2tfZmFpbCcsICdUaGlzIHdlYiBicm93c2VyIGRvZXMgbm90IGhhdmUgV2ViU29ja2V0IHN1cHBvcnQuJyApO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgbGV0IHdzID0gbmV3IFdlYlNvY2tldCggZW5kcG9pbnQgKTtcbiAgICAgIHRoaXMuX3NvY2tzWyBpZCBdID0gd3M7XG4gICAgICByZXR1cm4gd3M7XG4gICAgfVxuICAgIGNhdGNoICggZXJyICkge1xuICAgICAgbGV0IG1lc3NhZ2UgPSBTdHJpbmcoIGVyci5tZXNzYWdlIHx8ICdXZWJTb2NrZXQgZW5kcG9pbnQgY29ubmVjdGlvbiBmYWlsZWQgZm9yICgnKyBlbmRwb2ludCArJykuJyApO1xuICAgICAgdGhpcy5lbWl0KCAnc29ja19mYWlsJywgbWVzc2FnZSApO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBDbG9zZSBzb2NrZXQgY29ubmVjdGlvbiBhbmQgcmVtb3ZlIGl0IGZyb20gdGhlIGxpc3RcbiAgICogQHBhcmFtIHtzdHJpbmd9ICBpZCAgU29ja2V0IGlkIG5hbWVcbiAgICovXG4gIHNvY2tDbG9zZSggaWQgKSB7XG4gICAgaWYgKCAhaWQgfHwgIXRoaXMuX3NvY2tzLmhhc093blByb3BlcnR5KCBpZCApICkgcmV0dXJuO1xuICAgIHRoaXMuZW1pdCggJ3NvY2tfY2xvc2UnLCBpZCApO1xuICAgIHRoaXMuX3NvY2tzWyBpZCBdLmNsb3NlKCk7XG4gICAgZGVsZXRlIHRoaXMuX3NvY2tzWyBpZCBdO1xuICB9XG5cbiAgLyoqXG4gICAqIENsb3NlIGFsbCBhY3RpdmUgc29ja2V0IGNvbm5lY3Rpb25zXG4gICAqL1xuICBzb2NrQ2xvc2VBbGwoKSB7XG4gICAgT2JqZWN0LmtleXMoIHRoaXMuX3NvY2tzICkuZm9yRWFjaCggaWQgPT4gdGhpcy5zb2NrQ2xvc2UoIGlkICkgKTtcbiAgfVxuXG59XG4iLCIvKipcclxuICogQmFzaWMgZXZlbnQgYnVzIGNsYXNzXHJcbiAqL1xyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBCdXMge1xyXG5cclxuICAvKipcclxuICAgKiBDb25zdHJ1Y3RvclxyXG4gICAqL1xyXG4gIGNvbnN0cnVjdG9yKCkge1xyXG4gICAgdGhpcy5fZXZlbnRzID0ge307XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBSZWdpc3RlciBhbiBldmVudCBoYW5kbGVyXHJcbiAgICogQHBhcmFtIHtzdHJpbmd9ICAgIG5hbWUgICAgICBFdmVudCBuYW1lXHJcbiAgICogQHBhcmFtIHtmdW5jdGlvbn0gIGNhbGxiYWNrICBFdmVudCBjYWxsYmFjayBmdW5jdGlvblxyXG4gICAqL1xyXG4gIG9uKCBuYW1lLCBjYWxsYmFjayApIHtcclxuICAgIGlmICggIW5hbWUgfHwgdHlwZW9mIG5hbWUgIT09ICdzdHJpbmcnICkgcmV0dXJuO1xyXG4gICAgaWYgKCB0eXBlb2YgY2FsbGJhY2sgIT09ICdmdW5jdGlvbicgKSByZXR1cm47XHJcbiAgICBpZiAoICF0aGlzLl9ldmVudHMuaGFzT3duUHJvcGVydHkoIG5hbWUgKSApIHRoaXMuX2V2ZW50c1sgbmFtZSBdID0gW107XHJcbiAgICB0aGlzLl9ldmVudHNbIG5hbWUgXS5wdXNoKCBjYWxsYmFjayApO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogRW1pdCBhbiBldmVudCBieSBuYW1lIChmaXJzdCBhcmcpIHdpdGggcmVzdCBvZiBhcmdzIHBhc3NlZCB0byBpdFxyXG4gICAqL1xyXG4gIGVtaXQoKSB7XHJcbiAgICBsZXQgYXJncyA9IEFycmF5LmZyb20oIGFyZ3VtZW50cyApO1xyXG4gICAgbGV0IG5hbWUgPSBhcmdzLmxlbmd0aCA/IGFyZ3Muc2hpZnQoKSA6ICcnO1xyXG5cclxuICAgIGlmICggdGhpcy5fZXZlbnRzLmhhc093blByb3BlcnR5KCBuYW1lICkgKSB7XHJcbiAgICAgIGZvciAoIGxldCBpID0gMDsgaSA8IHRoaXMuX2V2ZW50c1sgbmFtZSBdLmxlbmd0aDsgKytpICkge1xyXG4gICAgICAgIGxldCBjYiA9IHRoaXMuX2V2ZW50c1sgbmFtZSBdWyBpIF07XHJcbiAgICAgICAgY2IuYXBwbHkoIGNiLCBhcmdzICk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICAgIGFyZ3MgPSB1bmRlZmluZWQ7IC8vIGdjXHJcbiAgfVxyXG59XHJcbiIsIi8qKlxuICogQ29pbmJhc2Vwcm8gc29ja2V0IGFwaSB3cmFwcGVyIGNsYXNzXG4gKi9cbmltcG9ydCBCdXMgZnJvbSAnLi9idXMnO1xuaW1wb3J0IFN5bWJvbCBmcm9tICcuL3N5bWJvbCc7XG5pbXBvcnQgdXRpbHMgZnJvbSAnLi91dGlscyc7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIENvaW5iYXNlcHJvIGV4dGVuZHMgQnVzIHtcblxuICAvKipcbiAgICogQ29uc3RydWN0b3JcbiAgICovXG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKCk7XG4gICAgdGhpcy5fYWpheCAgICAgID0gbnVsbDtcbiAgICB0aGlzLl9hcGl1cmwgICAgPSAnaHR0cHM6Ly9hcGkuZXhjaGFuZ2UuY29pbmJhc2UuY29tLyc7XG4gICAgdGhpcy5fd3NzdXJsICAgID0gJ3dzczovL3dzLWZlZWQuZXhjaGFuZ2UuY29pbmJhc2UuY29tJztcbiAgICB0aGlzLl9hcGlrZXkgICAgPSAnJzsgICAgLy8gQVBJIGtleVxuICAgIHRoaXMuX2FwaXNlY3JldCA9ICcnOyAgICAvLyBBUEkgc2VjcmV0XG4gICAgdGhpcy5fbGlzdGVua2V5ID0gJyc7ICAgIC8vIHVzZXIgc3RyZWFtIGxpc3RlbiBrZXlcbiAgICB0aGlzLl93YWl0ICAgICAgPSAxMDAwMDsgLy8gcmVjb25uZWN0IHdhaXQgKG1pbHMpXG4gICAgdGhpcy5fY29pbmRhdGEgID0ge307ICAgIC8vIGRhdGEgYWJvdXQgZWFjaCB0b2tlblxuICAgIHRoaXMuX3N5bWJvbHMgICA9IHt9OyAgICAvLyB1bmlxdWUgc3ltYm9scyBkYXRhIGNhY2hlXG4gICAgdGhpcy5fbWFya2V0cyAgID0ge307ICAgIC8vIGF2YWlsYWJsZSBtYXJrZXRzIGFuZCB0b3RhbCBhc3NldHNcbiAgICB0aGlzLl9yZWNvbm5lY3QgPSB7fTtcbiAgICB0aGlzLl90aW1lcnMgICAgPSB7fTtcbiAgICB0aGlzLl9zb2NrcyAgICAgPSB7fTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXQgYWpheCBtb2R1bGUgcmVmZXJlbmNlIHRvIHVzZSBmb3IgcmVxdWVzdHNcbiAgICovXG4gIHVzZUFqYXgoIGFqYXggKSB7XG4gICAgdGhpcy5fYWpheCA9IGFqYXg7XG4gIH1cblxuICAvKipcbiAgICogU2V0IEFQSSBrZXlcbiAgICovXG4gIHNldEFwaUtleSgga2V5ID0gJycgKSB7XG4gICAgdGhpcy5fYXBpa2V5ID0gU3RyaW5nKCBrZXkgfHwgJycgKS50cmltKCk7XG4gIH1cblxuICAvKipcbiAgICogU2V0IEFQSSBzZWNyZXRcbiAgICovXG4gIHNldEFwaVNlY3JldCggc2VjcmV0ID0gJycgKSB7XG4gICAgdGhpcy5fYXBpc2VjcmV0ID0gU3RyaW5nKCBzZWNyZXQgfHwgJycgKS50cmltKCk7XG4gIH1cblxuICAvKipcbiAgICogU2V0IGNvaW5zIGRhdGEgZmV0Y2hlZCBmcm9tIHNvbWV3aGVyZSBlbHNlXG4gICAqL1xuICBzZXRDb2luRGF0YSggZGF0YSA9IHt9ICkge1xuICAgIHRoaXMuX2NvaW5kYXRhID0gT2JqZWN0LmFzc2lnbiggdGhpcy5fY29pbmRhdGEsIGRhdGEgKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXQgc29ja2V0IHJlY29ubmVjdCBib29sZWFuIGZvciBhbiBpZFxuICAgKi9cbiAgc2V0UmVjb25uZWN0KCBpZCwgdG9nZ2xlICkge1xuICAgIHRoaXMuX3JlY29ubmVjdFsgaWQgXSA9IHRvZ2dsZSA/IHRydWUgOiBmYWxzZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDaGVjayByZWNvbm5lY3QgdG9nZ2xlIGZvciBhbiBpZCBhbmQgY2FsbCBhIGhhbmRsZXIgZnVuY3Rpb25cbiAgICovXG4gIGNoZWNrUmVjb25uZWN0KCBpZCwgY2FsbGJhY2sgKSB7XG4gICAgaWYgKCAhdGhpcy5fcmVjb25uZWN0WyBpZCBdICkgcmV0dXJuO1xuICAgIHNldFRpbWVvdXQoIGNhbGxiYWNrLCB0aGlzLl93YWl0ICk7XG4gIH1cblxuICAvKipcbiAgICogR2V0IHB1YmxpYyBhcGkgZW5kcG9pbnQgdXJsXG4gICAqL1xuICBnZXRQdWJsaWNVcmwoIGVuZHBvaW50LCBwYXJhbXMgKSB7XG4gICAgbGV0IHFzdHIgPSB0aGlzLl9hamF4LnNlcmlhbGl6ZURhdGEoIE9iamVjdC5hc3NpZ24oIHt9LCBwYXJhbXMgKSApO1xuICAgIHJldHVybiB0aGlzLl9hcGl1cmwgKyBlbmRwb2ludCArICc/JyArIHFzdHI7XG4gIH1cblxuICAvKipcbiAgICogR2V0IHVzZXIgc2lnbmVkIGFwaSBlbmRwb2ludCB1cmxcbiAgICovXG4gIGdldFNpZ25lZFVybCggZW5kcG9pbnQsIHBhcmFtcyApIHtcbiAgICBsZXQgY3J5cHRvICAgICA9IHdpbmRvdy5DcnlwdG9KUyB8fCBudWxsO1xuICAgIGxldCByZWN2V2luZG93ID0gMTAwMDAwO1xuICAgIGxldCB0aW1lc3RhbXAgID0gRGF0ZS5ub3coKSAtICggcmVjdldpbmRvdyAvIDIgKTtcbiAgICBsZXQgcXN0ciAgICAgICA9IHRoaXMuX2FqYXguc2VyaWFsaXplRGF0YSggT2JqZWN0LmFzc2lnbiggeyByZWN2V2luZG93LCB0aW1lc3RhbXAgfSwgcGFyYW1zICkgKTtcbiAgICBsZXQgc2lnbmF0dXJlICA9IGNyeXB0byA/IGNyeXB0by5IbWFjU0hBMjU2KCBxc3RyLCB0aGlzLl9hcGlzZWNyZXQgKS50b1N0cmluZyggY3J5cHRvLmVuYy5IZXggKSA6ICcnO1xuICAgIHJldHVybiB0aGlzLl9hcGl1cmwgKyBlbmRwb2ludCArICc/JyArIHFzdHIgKyAnJnNpZ25hdHVyZT0nICsgc2lnbmF0dXJlO1xuICB9XG5cbiAgLyoqXG4gICAqIEZldGNoIGRhdGEgYWJvdXQgYXZhaWxhYmxlIG1hcmtldHMgZm9ybSBleGNoYW5nZVxuICAgKi9cbiAgZmV0Y2hNYXJrZXRzRGF0YSgpIHtcbiAgICBpZiAoICF0aGlzLl9hamF4ICkgcmV0dXJuO1xuICAgIGNvbnN0IHJlbW90ZSA9IGAke3RoaXMuX2FwaXVybH0vcHJvZHVjdHNgO1xuICAgIGNvbnN0IGxvY2FsICA9IGAuLi8uLi8uLi8uLi9wdWJsaWMvbWFya2V0L2pzb24vZXhjaGFuZ2VJbmZvLmpzb25gO1xuXG4gICAgLy8gYnVpbGQgbWFya2V0cyBkYXRhIGFuZCBlbWl0IGl0IG91dFxuICAgIGNvbnN0IGhhbmRsZVJlc3BvbnNlID0gKCByZXMgKSA9PiB7XG4gICAgICBpZiAoIHJlcyAmJiBBcnJheS5pc0FycmF5KCByZXMuc3ltYm9scyApICkge1xuICAgICAgICBmb3IgKCBsZXQgc3ltYiBvZiByZXMuc3ltYm9scyApIHtcbiAgICAgICAgICBsZXQgdG9rZW4gPSBzeW1iLnF1b3RlQXNzZXQ7IC8vIG1hcmtldFxuICAgICAgICAgIGxldCBjb3VudCA9IHJlcy5zeW1ib2xzLmZpbHRlciggcyA9PiAoIHMucXVvdGVBc3NldCA9PT0gdG9rZW4gJiYgcy5iYXNlQXNzZXQgIT09IHRva2VuICYmIHMuc3RhdHVzID09PSAnVFJBRElORycgKSApLmxlbmd0aDtcbiAgICAgICAgICB0aGlzLl9tYXJrZXRzWyB0b2tlbiBdID0geyB0b2tlbiwgY291bnQgfTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmVtaXQoICdtYXJrZXRzX2RhdGEnLCB0aGlzLl9tYXJrZXRzICk7XG4gICAgICB9XG4gICAgfVxuICAgIC8vIHRyeSByZW1vdGUsIHRoZW4gbG9jYWwgaWYgaXQgZmFpbHNcbiAgICB0aGlzLl9hamF4LmdldCggcmVtb3RlLCB7XG4gICAgICB0eXBlOiAnanNvbicsXG4gICAgICBzdWNjZXNzOiAoIHhociwgc3RhdHVzLCByZXMgKSA9PiBoYW5kbGVSZXNwb25zZSggcmVzICksXG4gICAgICBlcnJvcjogKCB4aHIsIHN0YXR1cywgZXJyICkgPT4ge1xuICAgICAgICB0aGlzLl9hamF4LmdldCggbG9jYWwsIHtcbiAgICAgICAgICB0eXBlOiAnanNvbicsXG4gICAgICAgICAgcHJveHk6IGZhbHNlLFxuICAgICAgICAgIHN1Y2Nlc3M6ICggeGhyLCBzdGF0dXMsIHJlcyApID0+IGhhbmRsZVJlc3BvbnNlKCByZXMgKSxcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogRmV0Y2ggbGFzdCAyNGggY2FuZGxlIGRhdGFcbiAgICovXG4gIGZldGNoQ2hhcnREYXRhKCBzeW1ib2wsIGNiICkge1xuICAgICBpZiAoICF0aGlzLl9hamF4IHx8ICFzeW1ib2wgKSByZXR1cm47XG4gICAgIGNvbnN0IGVuZHBvaW50ID0gYCR7dGhpcy5fYXBpdXJsfS92My9rbGluZXM/c3ltYm9sPSR7c3ltYm9sfSZpbnRlcnZhbD0xaCZsaW1pdD0xNjhgO1xuICAgICBjb25zdCBwcmljZXMgICA9IFtdO1xuXG4gICAgdGhpcy5fYWpheC5nZXQoIGVuZHBvaW50LCB7XG4gICAgICB0eXBlOiAnanNvbicsXG4gICAgICAvLyBjYWNoZTogNjAwLFxuICAgICAgc3VjY2VzczogKCB4aHIsIHN0YXR1cywgcmVzICkgPT4ge1xuICAgICAgICBpZiAoIHJlcyAmJiBBcnJheS5pc0FycmF5KCByZXMgKSApIHtcbiAgICAgICAgICBmb3IgKCBsZXQgaSA9IDA7IGkgPCByZXMubGVuZ3RoOyArK2kgKSB7XG4gICAgICAgICAgICBwcmljZXMucHVzaCggcGFyc2VGbG9hdCggcmVzWyBpIF1bIDQgXSApICk7IC8vIGNsb3NlIHByaWNlXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICggdHlwZW9mIGNiID09PSAnZnVuY3Rpb24nICkgY2IoIHByaWNlcyApO1xuICAgICAgICB0aGlzLmVtaXQoICdjaGFydF9kYXRhJywgeyBzeW1ib2wsIHByaWNlcyB9ICk7XG4gICAgICB9LFxuICAgICAgZXJyb3I6ICggeGhyLCBzdGF0dXMsIGVyciApID0+IHtcbiAgICAgICAgaWYgKCB0eXBlb2YgY2IgPT09ICdmdW5jdGlvbicgKSBjYiggcHJpY2VzICk7XG4gICAgICAgIGNvbnNvbGUud2FybiggZXJyICk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogUGFyc2UgdXNlciBiYWxhbmNlcyBkYXRhXG4gICAqL1xuICBwYXJzZVVzZXJCYWxhbmNlcyggZGF0YSApIHtcbiAgICBsZXQgYmFsYW5jZXMgPSBbXTtcbiAgICBpZiAoIEFycmF5LmlzQXJyYXkoIGRhdGEgKSApIGJhbGFuY2VzID0gZGF0YTsgLy8gYXMtaXNcbiAgICBpZiAoIEFycmF5LmlzQXJyYXkoIGRhdGEuYmFsYW5jZXMgKSApIGJhbGFuY2VzID0gZGF0YS5iYWxhbmNlczsgLy8gaHR0cFxuICAgIGlmICggQXJyYXkuaXNBcnJheSggZGF0YS5CICkgKSBiYWxhbmNlcyA9IGRhdGEuQjsgLy8gd2Vic29ja2V0XG5cbiAgICBiYWxhbmNlcyA9IGJhbGFuY2VzLm1hcCggdCA9PiB7XG4gICAgICBsZXQgYXNzZXQgID0gU3RyaW5nKCB0LmEgfHwgdC5hc3NldCB8fCAnJyApO1xuICAgICAgbGV0IHBhaXIgICA9ICggYXNzZXQgPT09ICdCVEMnICkgPyAnVVNEVCcgOiAnQlRDJztcbiAgICAgIGxldCByb3V0ZSAgPSAnL3N5bWJvbC8nKyBhc3NldCArIHBhaXI7XG4gICAgICBsZXQgbmFtZSAgID0gdGhpcy5fbmFtZXNbIGFzc2V0IF0gfHwgYXNzZXQ7XG4gICAgICBsZXQgZnJlZSAgID0gcGFyc2VGbG9hdCggdC5mIHx8IHQuZnJlZSApIHx8IDA7XG4gICAgICBsZXQgbG9ja2VkID0gcGFyc2VGbG9hdCggdC5sIHx8IHQubG9ja2VkICkgfHwgMDtcbiAgICAgIGxldCB0b3RhbCAgPSAoIGZyZWUgKyBsb2NrZWQgKTtcbiAgICAgIHJldHVybiB7IGFzc2V0LCBuYW1lLCByb3V0ZSwgZnJlZSwgbG9ja2VkLCB0b3RhbCB9O1xuICAgIH0pO1xuICAgIHJldHVybiBiYWxhbmNlcy5maWx0ZXIoIHQgPT4gKCB0LnRvdGFsID4gMCApICk7XG4gIH1cblxuICAvKipcbiAgICogUGFyc2Ugb3JkZXIgZGF0YSBmcm9tIGFuIEFQSS9Tb2NrZXQgcmVzcG9uc2UgYW5kIGNvbWJpbmUgaXQgd2l0aCBzeW1ib2wgZGF0YVxuICAgKiBAcGFyYW0ge29iamVjdH0gIGRhdGEgIE9yZGVyIGRhdGEgcmVzcG9uc2VcbiAgICovXG4gIHBhcnNlT3JkZXJEYXRhKCBkYXRhICkge1xuICAgIGxldCBub3cgICAgICAgPSBEYXRlLm5vdygpO1xuICAgIGxldCB0aW1lICAgICAgPSBOdW1iZXIoIGRhdGEuVCB8fCBkYXRhLnRyYW5zYWN0VGltZSB8fCBub3cgKTsgICAgICAvLyB0cmFuc2FjdGlvbiB0aW1lXG4gICAgbGV0IGlkICAgICAgICA9IFN0cmluZyggZGF0YS5pIHx8IGRhdGEub3JkZXJJZCB8fCAnJyApOyAgICAgICAgICAgIC8vIG9yZGVyIGlkXG4gICAgbGV0IHN5bWJvbCAgICA9IFN0cmluZyggZGF0YS5zIHx8IGRhdGEuc3ltYm9sIHx8ICcnICk7ICAgICAgICAgICAgIC8vIHRyYWRlIHBhaXIgc3ltYm9sXG4gICAgbGV0IHNpZGUgICAgICA9IFN0cmluZyggZGF0YS5TIHx8IGRhdGEuc2lkZSB8fCAnJyApOyAgICAgICAgICAgICAgIC8vIGJvb2sgc2lkZSAoQlVZLCBTRUxMKVxuICAgIGxldCB0eXBlICAgICAgPSBTdHJpbmcoIGRhdGEubyB8fCBkYXRhLnR5cGUgfHwgJycgKTsgICAgICAgICAgICAgICAvLyBvcmRlciB0eXBlIChMSU1JVCwgTUFSS0VULCBldGMpXG4gICAgbGV0IHN0YXR1cyAgICA9IFN0cmluZyggZGF0YS5YIHx8IGRhdGEuc3RhdHVzIHx8ICcnICk7ICAgICAgICAgICAgIC8vIG9yZGVyIHN0YXR1cyAoTkVXLCBDQU5DRUxFRCwgRklMTEVELCBldGMpXG4gICAgbGV0IHByaWNlICAgICA9IE51bWJlciggZGF0YS5wIHx8IGRhdGEucHJpY2UgfHwgMCApOyAgICAgICAgICAgICAgIC8vIG9yZGVyIGJvb2sgcHJpY2VcbiAgICBsZXQgcXVhbnRpdHkgID0gTnVtYmVyKCBkYXRhLnEgfHwgZGF0YS5vcmlnUXR5IHx8IDAgKTsgICAgICAgICAgICAgLy8gb3JpZ2luYWwgdHJhZGUgcXVhbnRpdHlcbiAgICBsZXQgZmlsbGVkICAgID0gTnVtYmVyKCBkYXRhLnogfHwgZGF0YS5leGVjdXRlZFF0eSB8fCAwICk7ICAgICAgICAgLy8gZmlsbGVkIHRyYWRlIHF1YW50aXR5XG4gICAgbGV0IHRvdGFsICAgICA9IE51bWJlciggZGF0YS5aIHx8IGRhdGEuY3VtbXVsYXRpdmVRdW90ZVF0eSB8fCAwICk7IC8vIHRvdGFsIHRyYWRlIGFzc2V0IGNvc3RcbiAgICBsZXQgZmVlQXNzZXQgID0gU3RyaW5nKCBkYXRhLk4gfHwgJycgKTsgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gZmVlIGFzc2V0IHVzZWQgZm9yIGNvbW1pc3Npb24gKEJOQiwgZXRjKVxuICAgIGxldCBmZWVBbW91bnQgPSBOdW1iZXIoIGRhdGEubiB8fCAwICk7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBmZWUgY29tbWlzc2lvbiBhbW91bnRcbiAgICBsZXQgcGVyY2VudCAgID0gTnVtYmVyKCBmaWxsZWQgLyBxdWFudGl0eSAqIDEwMCApOyAgICAgICAgICAgICAgICAgLy8gZmlsbGVkIHBlcmNlbnRcblxuICAgIC8vIHJlc29sdmUgYXZhaWxhYmxlIGFtb3VudCBhZnRlciB0b2tlbiBmZWUgaGFzIGJlZW4gZGVkdWN0ZWRcbiAgICBsZXQgc21iICAgID0gdGhpcy5fc3ltYm9sc1sgc3ltYm9sIF0gfHwgbmV3IFN5bWJvbCggc3ltYm9sICk7XG4gICAgbGV0IGFtb3VudCA9ICggZmVlQXNzZXQgPT09IHNtYi50b2tlbiApID8gKCBxdWFudGl0eSAtIGZlZUFtb3VudCApIDogcXVhbnRpdHk7XG4gICAgbGV0IHVuaXF1ZSA9IHV0aWxzLnVuaXF1ZSggc3ltYm9sICsnfCcrIE1hdGguZmxvb3IoIGFtb3VudCApICk7XG5cbiAgICBzdGF0dXMgPSAoIHN0YXR1cyA9PT0gJ05FVycgKSA/ICdPUEVOJyA6IHN0YXR1cztcbiAgICBpZiAoICFwcmljZSAmJiB0b3RhbCApIHsgcHJpY2UgPSAoIHRvdGFsIC8gcXVhbnRpdHkgKTsgfVxuICAgIGlmICggIXRvdGFsICYmIHByaWNlICkgeyB0b3RhbCA9ICggcHJpY2UgKiBxdWFudGl0eSApOyB9XG5cbiAgICByZXR1cm4gc21iLmdldERhdGEoIHsgaWQsIHVuaXF1ZSwgc2lkZSwgdGltZSwgdHlwZSwgc3RhdHVzLCBwcmljZSwgcXVhbnRpdHksIGZpbGxlZCwgYW1vdW50LCB0b3RhbCwgZmVlQXNzZXQsIGZlZUFtb3VudCwgcGVyY2VudCB9ICk7XG4gIH1cblxuICAvKipcbiAgICogQnVpbGQgZmFrZSBvcmRlciBkYXRhXG4gICAqIEBwYXJhbSB7c3RyaW5nfSAgc3ltYm9sICAgIEZ1bGwgdHJhZGluZyBzeW1ib2xcbiAgICogQHBhcmFtIHtzdHJpbmd9ICB0eXBlICAgICAgT3JkZXIgdHlwZSAoTElNSVQsIE1BUktFVClcbiAgICogQHBhcmFtIHtzdHJpbmd9ICBzaWRlICAgICAgQm9vayBzaWRlIChCVVksIFNFTEwpXG4gICAqIEBwYXJhbSB7bnVtYmVyfSAgcHJpY2UgICAgIEJvb2sgcHJpY2VcbiAgICogQHBhcmFtIHtudW1iZXJ9ICBxdWFudGl0eSAgT3JkZXIgcXVhbnRpdHlcbiAgICovXG4gIGZha2VPcmRlckRhdGEoIHN5bWJvbCwgdHlwZSwgc2lkZSwgcHJpY2UsIHF1YW50aXR5LCBzdGF0dXMgKSB7XG4gICAgbGV0IHRpbWUgPSBEYXRlLm5vdygpO1xuICAgIGxldCBpZCA9IHV0aWxzLnJhbmRTdHJpbmcoIDIwICk7XG4gICAgbGV0IHByaWNlU3RyID0gTnVtYmVyKCBwcmljZSApLnRvRml4ZWQoIDggKTtcbiAgICBsZXQgcXVhbnRpdHlTdHIgPSBOdW1iZXIoIHF1YW50aXR5ICkudG9GaXhlZCggMCApO1xuICAgIGxldCB0b3RhbFN0ciA9IE51bWJlciggcHJpY2UgKiBxdWFudGl0eSApLnRvRml4ZWQoIDggKTtcbiAgICByZXR1cm4gdGhpcy5wYXJzZU9yZGVyRGF0YSgge1xuICAgICAgc3ltYm9sOiBzeW1ib2wsXG4gICAgICBvcmRlcklkOiBpZCxcbiAgICAgIHRyYW5zYWN0VGltZTogdGltZSxcbiAgICAgIHByaWNlOiBwcmljZVN0cixcbiAgICAgIG9yaWdRdHk6IHF1YW50aXR5U3RyLFxuICAgICAgZXhlY3V0ZWRRdHk6IHF1YW50aXR5U3RyLFxuICAgICAgY3VtbXVsYXRpdmVRdW90ZVF0eTogdG90YWxTdHIsXG4gICAgICBzdGF0dXM6IHN0YXR1cyxcbiAgICAgIHR5cGU6IHR5cGUsXG4gICAgICBzaWRlOiBzaWRlXG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogU2ltdWxhdGUgYW4gb3JkZXIgd2l0aCBmYWtlIEFQSSByZXF1ZXN0XG4gICAqIEBwYXJhbSB7c3RyaW5nfSAgc3ltYm9sICAgIEZ1bGwgdHJhZGluZyBzeW1ib2xcbiAgICogQHBhcmFtIHtzdHJpbmd9ICB0eXBlICAgICAgT3JkZXIgdHlwZSAoTElNSVQsIE1BUktFVClcbiAgICogQHBhcmFtIHtzdHJpbmd9ICBzaWRlICAgICAgQm9vayBzaWRlIChCVVksIFNFTEwpXG4gICAqIEBwYXJhbSB7bnVtYmVyfSAgcHJpY2UgICAgIEJvb2sgcHJpY2VcbiAgICogQHBhcmFtIHtudW1iZXJ9ICBxdWFudGl0eSAgT3JkZXIgcXVhbnRpdHlcbiAgICovXG4gIHBsYWNlRmFrZU9yZGVyKCBzeW1ib2wsIHR5cGUsIHNpZGUsIHByaWNlLCBxdWFudGl0eSApIHtcbiAgICBsZXQgc2VjcyA9IE1hdGguZmxvb3IoIDEwMDAgKyBNYXRoLnJhbmRvbSgpICogNDAwMCApOyAvLyAxLTUgc2Vjc1xuICAgIGxldCBvcmRlck9wZW4gPSB0aGlzLmZha2VPcmRlckRhdGEoIHN5bWJvbCwgdHlwZSwgc2lkZSwgcHJpY2UsIHF1YW50aXR5LCAnT1BFTicgKTtcbiAgICBsZXQgb3JkZXJGaWxsZWQgPSB0aGlzLmZha2VPcmRlckRhdGEoIHN5bWJvbCwgdHlwZSwgc2lkZSwgcHJpY2UsIHF1YW50aXR5LCAnRklMTEVEJyApO1xuICAgIGxldCBvcmRlckNhbmNlbGVkID0gdGhpcy5mYWtlT3JkZXJEYXRhKCBzeW1ib2wsIHR5cGUsIHNpZGUsIHByaWNlLCBxdWFudGl0eSwgJ0NBTkNFTEVEJyApO1xuICAgIGxldCBvcmRlclJlc3VsdCA9ICggc2VjcyA8IDQ5MDAgKSA/IG9yZGVyRmlsbGVkIDogb3JkZXJDYW5jZWxlZDtcbiAgICBzZXRUaW1lb3V0KCAoKSA9PiB7IHRoaXMuZW1pdCggJ2Jvb2tfY3JlYXRlJywgb3JkZXJPcGVuICkgfSwgMzAwICk7IC8vIGFkZGVkIHRvIGJvb2tcbiAgICBzZXRUaW1lb3V0KCAoKSA9PiB7IHRoaXMuZW1pdCggJ3VzZXJfb3JkZXInLCBvcmRlclJlc3VsdCApIH0sIHNlY3MgKTsgLy8gZmlsbGVkIG9yIGNhbmNlbGVkXG4gIH1cblxuICAvKipcbiAgICogUGxhY2UgbmV3IG9yZGVyIGluIGJvb2tcbiAgICogQHBhcmFtIHtzdHJpbmd9ICBzeW1ib2wgICAgRnVsbCB0cmFkaW5nIHN5bWJvbFxuICAgKiBAcGFyYW0ge3N0cmluZ30gIHR5cGUgICAgICBPcmRlciB0eXBlIChMSU1JVCwgTUFSS0VUKVxuICAgKiBAcGFyYW0ge3N0cmluZ30gIHNpZGUgICAgICBCb29rIHNpZGUgKEJVWSwgU0VMTClcbiAgICogQHBhcmFtIHtudW1iZXJ9ICBwcmljZSAgICAgQm9vayBwcmljZVxuICAgKiBAcGFyYW0ge251bWJlcn0gIHF1YW50aXR5ICBPcmRlciBxdWFudGl0eVxuICAgKiBAcGFyYW0ge3N0cmluZ30gIGluZm9yY2UgICBUaW1lIGluZm9yY2UgdHlwZSAoR1RDLCBJT0MsIEZPSylcbiAgICovXG4gIHBsYWNlT3JkZXIoIHN5bWJvbCwgdHlwZSwgc2lkZSwgcHJpY2UsIHF1YW50aXR5LCBpbmZvcmNlICkge1xuICAgIGlmICggIXRoaXMuX2FwaWtleSB8fCAhdGhpcy5fYWpheCApIHJldHVybjtcbiAgICBpZiAoICFzeW1ib2wgfHwgIXR5cGUgfHwgIXNpZGUgfHwgIXF1YW50aXR5IHx8IHF1YW50aXR5IDw9IDAgKSByZXR1cm47XG5cbiAgICBwcmljZSA9IE51bWJlciggcHJpY2UgKS50b0ZpeGVkKCA4ICk7XG4gICAgcXVhbnRpdHkgPSBOdW1iZXIoIHF1YW50aXR5ICkudG9GaXhlZCggMCApO1xuICAgIGluZm9yY2UgPSBTdHJpbmcoIGluZm9yY2UgfHwgJ0ZPSycgKTtcblxuICAgIGxldCBwYXJhbXMgPSB7IHN5bWJvbCwgc2lkZSwgdHlwZSwgcXVhbnRpdHkgfTtcbiAgICBpZiAoIHR5cGUgPT09ICdMSU1JVCcgKSBPYmplY3QuYXNzaWduKCBwYXJhbXMsIHsgcHJpY2UsIHRpbWVJbkZvcmNlOiBpbmZvcmNlIH0gKTtcbiAgICBPYmplY3QuYXNzaWduKCBwYXJhbXMsIHsgbmV3T3JkZXJSZXNwVHlwZTogJ1JFU1VMVCcgfSApO1xuXG4gICAgdGhpcy5fYWpheC5wb3N0KCB0aGlzLmdldFNpZ25lZFVybCggJy92My9vcmRlcicsIHBhcmFtcyApLCB7XG4gICAgICB0eXBlOiAnanNvbicsXG4gICAgICBoZWFkZXJzOiB7ICdYLU1CWC1BUElLRVknOiB0aGlzLl9hcGlrZXkgfSxcblxuICAgICAgc3VjY2VzczogKCB4aHIsIHN0YXR1cywgcmVzcG9uc2UgKSA9PiB7XG4gICAgICAgIGxldCBvcmRlciA9IHRoaXMucGFyc2VPcmRlckRhdGEoIHJlc3BvbnNlICk7XG4gICAgICAgIHRoaXMuZW1pdCggJ2Jvb2tfY3JlYXRlJywgb3JkZXIgKTtcbiAgICAgIH0sXG4gICAgICBlcnJvcjogKCB4aHIsIHN0YXR1cywgZXJyb3IgKSA9PiB7XG4gICAgICAgIGxldCBvcmRlciA9IHRoaXMuZmFrZU9yZGVyRGF0YSggc3ltYm9sLCB0eXBlLCBzaWRlLCBwcmljZSwgcXVhbnRpdHksICdSRUpFQ1RFRCcgKTtcbiAgICAgICAgdGhpcy5lbWl0KCAnYm9va19mYWlsJywgb3JkZXIsIGVycm9yICk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogQ2FuY2VsIG9yZGVyIGZyb20gYm9va1xuICAgKiBAcGFyYW0ge3N0cmluZ30gIHN5bWJvbCAgICBGdWxsIHRyYWRpbmcgc3ltYm9sXG4gICAqIEBwYXJhbSB7bnVtYmVyfSAgb3JkZXJJZCAgIE9yZGVyIElEIG51bWJlclxuICAgKiBAcGFyYW0ge251bWJlcn0gIHF1YW50aXR5ICBPcmRlciBxdWFudGl0eVxuICAgKi9cbiAgY2FuY2VsT3JkZXIoIHN5bWJvbCwgb3JkZXJJZCwgcXVhbnRpdHkgKSB7XG4gICAgaWYgKCAhdGhpcy5fYXBpa2V5IHx8ICF0aGlzLl9hamF4ICkgcmV0dXJuO1xuICAgIGlmICggIXN5bWJvbCB8fCAhb3JkZXJJZCApIHJldHVybjtcblxuICAgIHRoaXMuX2FqYXguZGVsZXRlKCB0aGlzLmdldFNpZ25lZFVybCggJy92My9vcmRlcicsIHsgc3ltYm9sLCBvcmRlcklkIH0gKSwge1xuICAgICAgdHlwZTogJ2pzb24nLFxuICAgICAgaGVhZGVyczogeyAnWC1NQlgtQVBJS0VZJzogdGhpcy5fYXBpa2V5IH0sXG5cbiAgICAgIHN1Y2Nlc3M6ICggeGhyLCBzdGF0dXMsIHJlc3BvbnNlICkgPT4ge1xuICAgICAgICBsZXQgb3JkZXIgPSB0aGlzLmZha2VPcmRlckRhdGEoIHN5bWJvbCwgJ01BUktFVCcsICdDQU5DRUwnLCAxLCBxdWFudGl0eSwgJ0NPTVBMRVRFJyApO1xuICAgICAgICB0aGlzLmVtaXQoICdib29rX2NhbmNlbCcsIG9yZGVyICk7XG4gICAgICB9LFxuICAgICAgZXJyb3I6ICggeGhyLCBzdGF0dXMsIGVycm9yICkgPT4ge1xuICAgICAgICBsZXQgb3JkZXIgPSB0aGlzLmZha2VPcmRlckRhdGEoIHN5bWJvbCwgJ01BUktFVCcsICdDQU5DRUwnLCAxLCBxdWFudGl0eSwgJ0ZBSUxFRCcgKTtcbiAgICAgICAgdGhpcy5lbWl0KCAnYm9va19mYWlsJywgb3JkZXIsIGVycm9yICk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogR2V0IHVzZXIgYWNjb3VudCBkYXRhIG92ZXIgYWpheFxuICAgKi9cbiAgZmV0Y2hVc2VyQWNjb3VudCgpIHtcbiAgICBpZiAoICF0aGlzLl9hcGlrZXkgfHwgIXRoaXMuX2FqYXggKSByZXR1cm47XG5cbiAgICB0aGlzLl9hamF4LmdldCggdGhpcy5nZXRTaWduZWRVcmwoICcvdjMvYWNjb3VudCcgKSwge1xuICAgICAgdHlwZTogJ2pzb24nLFxuICAgICAgaGVhZGVyczogeyAnWC1NQlgtQVBJS0VZJzogdGhpcy5fYXBpa2V5IH0sXG5cbiAgICAgIHN1Y2Nlc3M6ICggeGhyLCBzdGF0dXMsIHJlc3BvbnNlICkgPT4ge1xuICAgICAgICBsZXQgYmFsYW5jZXMgPSB0aGlzLnBhcnNlVXNlckJhbGFuY2VzKCByZXNwb25zZSApO1xuICAgICAgICB0aGlzLmVtaXQoICd1c2VyX2JhbGFuY2VzJywgYmFsYW5jZXMgKTtcbiAgICAgICAgdGhpcy5lbWl0KCAndXNlcl9kYXRhJywgdHJ1ZSApO1xuICAgICAgfSxcbiAgICAgIGVycm9yOiAoIHhociwgc3RhdHVzLCBlcnJvciApID0+IHtcbiAgICAgICAgdGhpcy5lbWl0KCAndXNlcl9mYWlsJywgZXJyb3IgKTtcbiAgICAgICAgdGhpcy5zdG9wVXNlclN0cmVhbSgpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIEZldGNoIGN1cnJlbnQgb3BlbiBvcmRlcnNcbiAgICovXG4gIGZldGNoT3Blbk9yZGVycygpIHtcbiAgICBpZiAoICF0aGlzLl9hcGlrZXkgfHwgIXRoaXMuX2FqYXggKSByZXR1cm47XG5cbiAgICB0aGlzLl9hamF4LmdldCggdGhpcy5nZXRTaWduZWRVcmwoICcvdjMvb3Blbk9yZGVycycgKSwge1xuICAgICAgdHlwZTogJ2pzb24nLFxuICAgICAgaGVhZGVyczogeyAnWC1NQlgtQVBJS0VZJzogdGhpcy5fYXBpa2V5IH0sXG5cbiAgICAgIHN1Y2Nlc3M6ICggeGhyLCBzdGF0dXMsIHJlc3BvbnNlICkgPT4ge1xuICAgICAgICByZXNwb25zZS5mb3JFYWNoKCBvID0+IHRoaXMuZW1pdCggJ3VzZXJfb3JkZXInLCB0aGlzLnBhcnNlT3JkZXJEYXRhKCBvICkgKSApO1xuICAgICAgICB0aGlzLmVtaXQoICd1c2VyX2RhdGEnLCB0cnVlICk7XG4gICAgICB9LFxuICAgICAgZXJyb3I6ICggeGhyLCBzdGF0dXMsIGVycm9yICkgPT4ge1xuICAgICAgICB0aGlzLmVtaXQoICd1c2VyX2ZhaWwnLCBlcnJvciApO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIEF0dGVtcHQgdG8gc3RhcnQgYSBuZXcgdXNlciBzdHJlYW1cbiAgICovXG4gIGluaXRVc2VyU3RyZWFtKCByZWNvbm5lY3QgKSB7XG4gICAgaWYgKCAhdGhpcy5fYXBpa2V5IHx8ICF0aGlzLl9hamF4ICkgcmV0dXJuO1xuXG4gICAgdGhpcy5lbWl0KCAndXNlcl9pbml0JywgRGF0ZS5ub3coKSApO1xuICAgIHRoaXMuc3RvcFVzZXJTdHJlYW0oKTtcblxuICAgIHRoaXMuX2FqYXgucG9zdCggdGhpcy5nZXRQdWJsaWNVcmwoICcvdjEvdXNlckRhdGFTdHJlYW0nICksIHtcbiAgICAgIHR5cGU6ICdqc29uJyxcbiAgICAgIGhlYWRlcnM6IHsgJ1gtTUJYLUFQSUtFWSc6IHRoaXMuX2FwaWtleSB9LFxuXG4gICAgICBzdWNjZXNzOiAoIHhociwgc3RhdHVzLCByZXNwb25zZSApID0+IHtcbiAgICAgICAgY29uc3QgdGltZSA9ICggMTAwMCAqIDYwICogMjAgKTsgLy8gMjAgbWluc1xuICAgICAgICBjb25zdCBmdW5jID0gdGhpcy5leHRlbmRTdHJlYW1LZXkuYmluZCggdGhpcyApO1xuICAgICAgICB0aGlzLl9saXN0ZW5rZXkgPSBTdHJpbmcoIHJlc3BvbnNlLmxpc3RlbktleSB8fCAnJyApLnRyaW0oKTtcbiAgICAgICAgdGhpcy5lbWl0KCAndXNlcl9saXN0ZW5rZXknLCB0aGlzLl9saXN0ZW5rZXkgKTtcbiAgICAgICAgdGhpcy5zdGFydFVzZXJTdHJlYW0oIHRoaXMuX2xpc3RlbmtleSwgcmVjb25uZWN0ICk7XG4gICAgICAgIHRoaXMuc3RhcnRUaW1lciggJ3VzZXInLCB0aW1lLCBmdW5jLCBmYWxzZSApO1xuICAgICAgfSxcbiAgICAgIGVycm9yOiAoIHhociwgc3RhdHVzLCBlcnJvciApID0+IHtcbiAgICAgICAgdGhpcy5lbWl0KCAndXNlcl9mYWlsJywgZXJyb3IgKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBFeHRlbmQgdXNlciBzdHJlYW0gbGlzdGVuIGtleVxuICAgKi9cbiAgZXh0ZW5kU3RyZWFtS2V5KCkge1xuICAgIGlmICggIXRoaXMuX2FwaWtleSB8fCAhdGhpcy5fYWpheCApIHJldHVybjtcbiAgICBpZiAoICF0aGlzLl9saXN0ZW5rZXkgKSByZXR1cm47XG5cbiAgICB0aGlzLl9hamF4LnB1dCggdGhpcy5nZXRQdWJsaWNVcmwoICcvdjEvdXNlckRhdGFTdHJlYW0nLCB7IGxpc3RlbktleTogdGhpcy5fbGlzdGVua2V5IH0gKSwge1xuICAgICAgdHlwZTogJ2pzb24nLFxuICAgICAgaGVhZGVyczogeyAnWC1NQlgtQVBJS0VZJzogdGhpcy5fYXBpa2V5IH0sXG5cbiAgICAgIHN1Y2Nlc3M6ICggeGhyLCBzdGF0dXMsIHJlc3BvbnNlICkgPT4ge1xuICAgICAgICB0aGlzLmVtaXQoICd1c2VyX2xpc3RlbmtleScsIHRoaXMuX2xpc3RlbmtleSApO1xuICAgICAgfSxcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDb25uZWN0IHRvIGEgbGl2ZSB1c2VyIGFjY291bnQgZGF0YSBzdHJlYW1cbiAgICovXG4gIHN0YXJ0VXNlclN0cmVhbSggbGlzdGVuS2V5LCByZWNvbm5lY3QgKSB7XG4gICAgdGhpcy5zZXRSZWNvbm5lY3QoICd1c2VyJywgcmVjb25uZWN0IHx8IGZhbHNlICk7XG4gICAgdGhpcy5lbWl0KCAndXNlcl9pbml0JywgRGF0ZS5ub3coKSApO1xuXG4gICAgY29uc3Qgd3MgPSB0aGlzLnNvY2tDb25uZWN0KCAndXNlcicsIHRoaXMuX3dzc3VybCArJy93cy8nKyBsaXN0ZW5LZXkgKTtcbiAgICBpZiAoICF3cyApIHJldHVybiB0aGlzLmVtaXQoICd1c2VyX2ZhaWwnLCAnQ291bGQgbm90IGNvbm5lY3QgdG8gdXNlciBzdHJlYW0gQVBJIGVuZHBvaW50LicgKTtcblxuICAgIHdzLmFkZEV2ZW50TGlzdGVuZXIoICdvcGVuJywgZSA9PiB7XG4gICAgICB0aGlzLmVtaXQoICd1c2VyX29wZW4nLCBlICk7XG4gICAgICB0aGlzLmZldGNoVXNlckFjY291bnQoKTtcbiAgICAgIHRoaXMuZmV0Y2hPcGVuT3JkZXJzKCk7XG4gICAgfSk7XG5cbiAgICB3cy5hZGRFdmVudExpc3RlbmVyKCAnZXJyb3InLCBlID0+IHtcbiAgICAgIHRoaXMuZW1pdCggJ3VzZXJfZXJyb3InLCBlICk7XG4gICAgICB0aGlzLnN0b3BUaW1lciggJ3VzZXInICk7XG4gICAgfSk7XG5cbiAgICB3cy5hZGRFdmVudExpc3RlbmVyKCAnY2xvc2UnLCBlID0+IHtcbiAgICAgIHRoaXMuZW1pdCggJ3VzZXJfY2xvc2UnLCBlICk7XG4gICAgICB0aGlzLnN0b3BUaW1lciggJ3VzZXInICk7XG4gICAgICB0aGlzLmNoZWNrUmVjb25uZWN0KCAndXNlcicsICgpID0+IHRoaXMuc3RhcnRVc2VyU3RyZWFtKCBsaXN0ZW5LZXksIHJlY29ubmVjdCApICk7XG4gICAgfSk7XG5cbiAgICB3cy5hZGRFdmVudExpc3RlbmVyKCAnbWVzc2FnZScsIGUgPT4ge1xuICAgICAgdGhpcy5lbWl0KCAndXNlcl9kYXRhJywgdHJ1ZSApO1xuICAgICAgbGV0IGRhdGEgPSBKU09OLnBhcnNlKCBlLmRhdGEgfHwgJ3t9JyApIHx8IHt9O1xuXG4gICAgICBpZiAoIGRhdGEuZSA9PT0gJ291dGJvdW5kQWNjb3VudEluZm8nICkge1xuICAgICAgICBsZXQgYmFsYW5jZXMgPSB0aGlzLnBhcnNlVXNlckJhbGFuY2VzKCBkYXRhICk7XG4gICAgICAgIHJldHVybiB0aGlzLmVtaXQoICd1c2VyX2JhbGFuY2VzJywgYmFsYW5jZXMgKTtcbiAgICAgIH1cbiAgICAgIGlmICggZGF0YS5lID09PSAnZXhlY3V0aW9uUmVwb3J0JyApIHtcbiAgICAgICAgbGV0IG9yZGVyID0gdGhpcy5wYXJzZU9yZGVyRGF0YSggZGF0YSApO1xuICAgICAgICByZXR1cm4gdGhpcy5lbWl0KCAndXNlcl9vcmRlcicsIG9yZGVyICk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogU3RvcCB1c2VyIHN0cmVhbVxuICAgKi9cbiAgc3RvcFVzZXJTdHJlYW0oKSB7XG4gICAgdGhpcy5zZXRSZWNvbm5lY3QoICd1c2VyJywgZmFsc2UgKTtcbiAgICB0aGlzLnN0b3BUaW1lciggJ3VzZXInICk7XG4gICAgdGhpcy5zb2NrQ2xvc2UoICd1c2VyJyApO1xuICB9XG5cbiAgLyoqXG4gICAqIENvbm5lY3QgdG8gbGl2ZSB0aWNrZXIgcHJpY2VzIHNvY2tldCBlbmRwb2ludFxuICAgKi9cbiAgc3RhcnRUaWNrZXJTdHJlYW0oIHJlY29ubmVjdCApIHtcbiAgICB0aGlzLnNldFJlY29ubmVjdCggJ3RpY2tlcicsIHJlY29ubmVjdCB8fCBmYWxzZSApO1xuICAgIHRoaXMuZW1pdCggJ3RpY2tlcl9pbml0JywgRGF0ZS5ub3coKSApO1xuXG4gICAgY29uc3Qgd3MgPSB0aGlzLnNvY2tDb25uZWN0KCAndGlja2VyJywgdGhpcy5fd3NzdXJsICsnL3dzLyF0aWNrZXJAYXJyJyApO1xuICAgIGlmICggIXdzICkgcmV0dXJuIHRoaXMuZW1pdCggJ3RpY2tlcl9mYWlsJywgJ0NvdWxkIG5vdCBjb25uZWN0IHRvIGxpdmUgdGlja2VyIHN0cmVhbSBBUEkgZW5kcG9pbnQuJyApO1xuXG4gICAgd3MuYWRkRXZlbnRMaXN0ZW5lciggJ29wZW4nLCBlID0+IHtcbiAgICAgIHRoaXMuZW1pdCggJ3RpY2tlcl9vcGVuJywgZSApO1xuICAgICAgdGhpcy5zdGFydFRpY2tlclRpbWVyKCk7XG4gICAgfSk7XG5cbiAgICB3cy5hZGRFdmVudExpc3RlbmVyKCAnZXJyb3InLCBlID0+IHtcbiAgICAgIHRoaXMuZW1pdCggJ3RpY2tlcl9lcnJvcicsIGUgKTtcbiAgICAgIHRoaXMuc3RvcFRpbWVyKCAndGlja2VyJyApO1xuICAgIH0pO1xuXG4gICAgd3MuYWRkRXZlbnRMaXN0ZW5lciggJ2Nsb3NlJywgZSA9PiB7XG4gICAgICB0aGlzLmVtaXQoICd0aWNrZXJfY2xvc2UnLCBlICk7XG4gICAgICB0aGlzLnN0b3BUaW1lciggJ3RpY2tlcicgKTtcbiAgICAgIHRoaXMuY2hlY2tSZWNvbm5lY3QoICd0aWNrZXInLCAoKSA9PiB0aGlzLnN0YXJ0VGlja2VyU3RyZWFtKCByZWNvbm5lY3QgKSApO1xuICAgIH0pO1xuXG4gICAgd3MuYWRkRXZlbnRMaXN0ZW5lciggJ21lc3NhZ2UnLCBlID0+IHtcbiAgICAgIHRoaXMuZW1pdCggJ3RpY2tlcl9kYXRhJywgdHJ1ZSApO1xuICAgICAgbGV0IGxpc3QgICAgPSBKU09OLnBhcnNlKCBlLmRhdGEgfHwgJ1tdJyApIHx8IFtdO1xuICAgICAgbGV0IG1hcmtldHMgPSBPYmplY3Qua2V5cyggdGhpcy5fbWFya2V0cyApO1xuICAgICAgbGV0IGNvdW50ICAgPSBsaXN0Lmxlbmd0aDtcblxuICAgICAgLy8gd2FpdCBmb3IgbWFya2V0cyBkYXRhIHRvIGJlIGF2YWlsYWJsZSBiZWZvcmUgY3JlYXRpbmcgc3ltYm9sc1xuICAgICAgaWYgKCAhbWFya2V0cy5sZW5ndGggfHwgIWNvdW50ICkgcmV0dXJuO1xuXG4gICAgICB3aGlsZSAoIGNvdW50LS0gKSB7XG4gICAgICAgIGxldCB0aWNrZXIgICA9IGxpc3RbIGNvdW50IF07XG4gICAgICAgIGxldCBwYWlyICAgICA9IHRpY2tlci5zOyAvLyB0cmFkaW5nIHBhaXIgc3ltYm9sIHN0clxuICAgICAgICBsZXQgc3ltYm9sICAgPSB0aGlzLl9zeW1ib2xzWyBwYWlyIF0gfHwgbmV3IFN5bWJvbCggcGFpciApOyAvLyBjYWNoZWRcblxuICAgICAgICBzeW1ib2wuc3BsaXRTeW1ib2woIG1hcmtldHMgKTsgLy8gc3BsaXQgcGFpciBzeW1ib2wgaW50byB0b2tlbiAvIG1hcmtldFxuICAgICAgICBzeW1ib2wuc2V0Q29pbkRhdGEoIHRoaXMuX2NvaW5kYXRhWyBzeW1ib2wudG9rZW4gXSApOyAvLyBkYXRhIGZyb20gY29pbmNhcC5pb1xuICAgICAgICBzeW1ib2wuc2V0VGlja2VyRGF0YSggdGlja2VyICk7IC8vIHVwZGF0ZSBzeW1ib2wgdGlja2VyIGRhdGFcbiAgICAgICAgc3ltYm9sLnJlc29sdmVJbWFnZSgpOyAvLyBmaW5kIGFuIGljb24gZm9yIHRoaXMgdG9rZW5cbiAgICAgICAgdGhpcy5fc3ltYm9sc1sgcGFpciBdID0gc3ltYm9sOyAvLyB1cGRhdGUgY2FjaGVcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTdGFydCB0aWNrZXIgZGF0YSB0aW1lclxuICAgKi9cbiAgc3RhcnRUaWNrZXJUaW1lcigpIHtcbiAgICB0aGlzLnN0b3BUaW1lciggJ3RpY2tlcicgKTtcbiAgICB0aGlzLnN0YXJ0VGltZXIoICd0aWNrZXInLCAxMDAwLCAoKSA9PiB7XG4gICAgICBsZXQga2V5cyAgID0gT2JqZWN0LmtleXMoIHRoaXMuX3N5bWJvbHMgKTtcbiAgICAgIGxldCBjb3VudCAgPSBrZXlzLmxlbmd0aDtcbiAgICAgIGxldCBwcmljZXMgPSBbXTtcblxuICAgICAgd2hpbGUgKCBjb3VudC0tICkgcHJpY2VzLnB1c2goIHRoaXMuX3N5bWJvbHNbIGtleXNbIGNvdW50IF0gXSApO1xuICAgICAgdGhpcy5lbWl0KCAndGlja2VyX3ByaWNlcycsIHByaWNlcyApO1xuICAgIH0sIHRydWUgKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTdG9wIHByaWNlIHRpY2tlclxuICAgKi9cbiAgc3RvcFRpY2tlclN0cmVhbSgpIHtcbiAgICB0aGlzLnNldFJlY29ubmVjdCggJ3RpY2tlcicsIGZhbHNlICk7XG4gICAgdGhpcy5zdG9wVGltZXIoICd0aWNrZXInICk7XG4gICAgdGhpcy5zb2NrQ2xvc2UoICd0aWNrZXInICk7XG4gIH1cblxuICAvKipcbiAgICogU3RhcnQgY3VzdG9tIHRpbWVyXG4gICAqIEBwYXJhbSB7c3RyaW5nfSAgICBpZCAgICAgICAgVGltZXIgaWQgbmFtZVxuICAgKiBAcGFyYW0ge251bWJlcn0gICAgdGltZSAgICAgIEludGVydmFsIG1pbHNcbiAgICogQHBhcmFtIHtmdW5jdGlvbn0gIGNhbGxiYWNrICBDYWxsYmFjayBmdW5jdGlvblxuICAgKiBAcGFyYW0ge2Jvb2xlYW59ICAgaW5pdCAgICAgIEluaXQgY2FsbGJhY2tcbiAgICovXG4gIHN0YXJ0VGltZXIoIGlkLCB0aW1lLCBjYWxsYmFjaywgaW5pdCApIHtcbiAgICB0aGlzLnN0b3BUaW1lciggaWQgKTtcbiAgICB0aGlzLl90aW1lcnNbIGlkIF0gPSBzZXRJbnRlcnZhbCggY2FsbGJhY2ssIHRpbWUgKTtcbiAgICBpZiAoIGluaXQgKSBjYWxsYmFjaygpO1xuICB9XG5cbiAgLyoqXG4gICAqIFN0b3AgY3VzdG9tIHRpbWVyXG4gICAqIEBwYXJhbSB7c3RyaW5nfSAgaWQgIFRpbWVyIGlkIG5hbWVcbiAgICovXG4gIHN0b3BUaW1lciggaWQgKSB7XG4gICAgaWYgKCAhaWQgfHwgIXRoaXMuX3RpbWVycy5oYXNPd25Qcm9wZXJ0eSggaWQgKSApIHJldHVybjtcbiAgICBjbGVhckludGVydmFsKCB0aGlzLl90aW1lcnNbIGlkIF0gKTtcbiAgICBkZWxldGUgdGhpcy5fdGltZXJzWyBpZCBdO1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhIFdlYlNvY2tldCBjb25uZWN0aW9uXG4gICAqIEBwYXJhbSB7c3RyaW5nfSAgaWQgICAgICBSZWYgaWQgbmFtZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gIGVuZHBvaW50ICBTb2NrZXQgZW5kcG9pbnQgdXJsXG4gICAqL1xuICBzb2NrQ29ubmVjdCggaWQsIGVuZHBvaW50ICkge1xuICAgIGlmICggIWlkIHx8ICFlbmRwb2ludCApIHJldHVybjtcbiAgICB0aGlzLmVtaXQoICdzb2NrX2luaXQnLCBlbmRwb2ludCApO1xuICAgIHRoaXMuc29ja0Nsb3NlKCBpZCApO1xuXG4gICAgaWYgKCAhKCAnV2ViU29ja2V0JyBpbiB3aW5kb3cgKSApIHtcbiAgICAgIHRoaXMuZW1pdCggJ3NvY2tfZmFpbCcsICdUaGlzIHdlYiBicm93c2VyIGRvZXMgbm90IGhhdmUgV2ViU29ja2V0IHN1cHBvcnQuJyApO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgbGV0IHdzID0gbmV3IFdlYlNvY2tldCggZW5kcG9pbnQgKTtcbiAgICAgIHRoaXMuX3NvY2tzWyBpZCBdID0gd3M7XG4gICAgICByZXR1cm4gd3M7XG4gICAgfVxuICAgIGNhdGNoICggZXJyICkge1xuICAgICAgbGV0IG1lc3NhZ2UgPSBTdHJpbmcoIGVyci5tZXNzYWdlIHx8ICdXZWJTb2NrZXQgZW5kcG9pbnQgY29ubmVjdGlvbiBmYWlsZWQgZm9yICgnKyBlbmRwb2ludCArJykuJyApO1xuICAgICAgdGhpcy5lbWl0KCAnc29ja19mYWlsJywgbWVzc2FnZSApO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBDbG9zZSBzb2NrZXQgY29ubmVjdGlvbiBhbmQgcmVtb3ZlIGl0IGZyb20gdGhlIGxpc3RcbiAgICogQHBhcmFtIHtzdHJpbmd9ICBpZCAgU29ja2V0IGlkIG5hbWVcbiAgICovXG4gIHNvY2tDbG9zZSggaWQgKSB7XG4gICAgaWYgKCAhaWQgfHwgIXRoaXMuX3NvY2tzLmhhc093blByb3BlcnR5KCBpZCApICkgcmV0dXJuO1xuICAgIHRoaXMuZW1pdCggJ3NvY2tfY2xvc2UnLCBpZCApO1xuICAgIHRoaXMuX3NvY2tzWyBpZCBdLmNsb3NlKCk7XG4gICAgZGVsZXRlIHRoaXMuX3NvY2tzWyBpZCBdO1xuICB9XG5cbiAgLyoqXG4gICAqIENsb3NlIGFsbCBhY3RpdmUgc29ja2V0IGNvbm5lY3Rpb25zXG4gICAqL1xuICBzb2NrQ2xvc2VBbGwoKSB7XG4gICAgT2JqZWN0LmtleXMoIHRoaXMuX3NvY2tzICkuZm9yRWFjaCggaWQgPT4gdGhpcy5zb2NrQ2xvc2UoIGlkICkgKTtcbiAgfVxuXG59XG4iLCIvKipcbiAqIEhhbmRsZSB0YWxraW5nIHRvIGNvaW5jYXAuaW8gdG8gZ2V0IGNvaW4gcmVsYXRlZCBkYXRhXG4gKiBodHRwczovL2RvY3MuY29pbmNhcC5pby9cbiAqL1xuaW1wb3J0IEJ1cyBmcm9tICcuL2J1cyc7XG5pbXBvcnQgdHh0IGZyb20gJ3Jhdy1sb2FkZXIhLi4vLi4vLi4vcmVzb3VyY2VzL2Fzc2V0cy9jb3JzLnR4dCc7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIENvaW5jYXAgZXh0ZW5kcyBCdXMge1xuXG4gIC8qKlxuICAgKiBDb25zdHJ1Y3RvclxuICAgKi9cbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoKTtcbiAgICB0aGlzLl9hamF4ICA9IG51bGw7XG4gICAgdGhpcy5fY29pbnMgPSB7fTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXQgYWpheCBtb2R1bGUgcmVmZXJlbmNlIHRvIHVzZSBmb3IgcmVxdWVzdHNcbiAgICovXG4gIHVzZUFqYXgoIGFqYXggKSB7XG4gICAgdGhpcy5fYWpheCA9IGFqYXg7XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRva2VucyBkYXRhIG9iamVjdFxuICAgKi9cbiAgZ2V0RGF0YSgpIHtcbiAgICByZXR1cm4gdGhpcy5fY29pbnM7XG4gIH1cblxuICAvKipcbiAgICogZmV0Y2ggbGlzdCBvZiBhbGwgdG9rZW5zIGFuZCB0aGVpciBuYW1lcyBmcm9tIEFQSVxuICAgKi9cbiAgZmV0Y2hBbGwoKSB7XG4gICAgaWYgKCAhdGhpcy5fYWpheCApIHJldHVybjtcbiAgICB0aGlzLl9hamF4LmdldCggYCR7dHh0fWh0dHBzOi8vYXBpLmNvaW5jYXAuaW8vdjIvYXNzZXRzP2xpbWl0PTIwMDBgLCB7XG4gICAgICB0eXBlOiAnanNvbicsXG4gICAgICBiZWZvcmVTZW5kOiBmdW5jdGlvbiAoeGhyKSB7XG4gICAgICAgICAgICB4aHIuc2V0UmVxdWVzdEhlYWRlcignQXV0aG9yaXphdGlvbicsICdCZWFyZXIgdC03NjE4YTE0MS0zYzJmLTQyNWQtYWYwNi00NjY5MGM1ZjU1MzknKTtcbiAgICAgICAgfSxcbiAgICAgIGNhY2hlOiA2MDAsXG4gICAgICBwcm94eTogZmFsc2UsXG4gICAgICBzdWNjZXNzOiAoIHhociwgc3RhdHVzLCByZXMgKSA9PiB7XG4gICAgICAgIGlmICggIXJlcyB8fCAhQXJyYXkuaXNBcnJheSggcmVzLmRhdGEgKSApIHJldHVybjtcbiAgICAgICAgZm9yICggbGV0IGMgb2YgcmVzLmRhdGEgKSB7IHRoaXMuX2NvaW5zWyBjLnN5bWJvbCBdID0gYzsgfVxuICAgICAgICB0aGlzLmVtaXQoICdhbGxjb2lucycsIHRoaXMuX2NvaW5zICk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogRmV0Y2ggbWFya2V0IGNhcCBkYXRhIGZvciBhIHRva2VuXG4gICAqL1xuICBmZXRjaENvaW4oIGlkLCBjYiApIHtcbiAgICBpZiAoICF0aGlzLl9hamF4IHx8ICFpZCApIHJldHVybjtcbiAgICB0aGlzLl9hamF4LmdldCggYCR7dHh0fWh0dHBzOi8vYXBpLmNvaW5jYXAuaW8vdjIvYXNzZXRzLyR7aWR9YCwge1xuICAgICAgdHlwZTogJ2pzb24nLFxuICAgICAgYmVmb3JlU2VuZDogZnVuY3Rpb24gKHhocikge1xuICAgICAgICAgICAgeGhyLnNldFJlcXVlc3RIZWFkZXIoJ0F1dGhvcml6YXRpb24nLCAnQmVhcmVyIHQtNzYxOGExNDEtM2MyZi00MjVkLWFmMDYtNDY2OTBjNWY1NTM5Jyk7XG4gICAgICAgIH0sXG4gICAgICBjYWNoZTogMzAwLFxuICAgICAgcHJveHk6IGZhbHNlLFxuICAgICAgc3VjY2VzczogKCB4aHIsIHN0YXR1cywgcmVzICkgPT4ge1xuICAgICAgICBpZiAoICFyZXMgfHwgIXJlcy5kYXRhICkgcmV0dXJuO1xuICAgICAgICBpZiAoIHR5cGVvZiBjYiA9PT0gJ2Z1bmN0aW9uJyApIGNiKCByZXMuZGF0YSApO1xuICAgICAgICB0aGlzLmVtaXQoICdjb2luZGF0YScsIHJlcy5kYXRhICk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxufVxuIiwiLyoqXHJcbiAqIEhhbmRsZXMgc2F2aW5nIGRhdGEgdG8gYSBoaXN0b3J5IGxpc3RcclxuICovXHJcbmltcG9ydCBCdXMgZnJvbSAnLi9idXMnO1xyXG5pbXBvcnQgc3RvcmUgZnJvbSAnLi9zdG9yZSc7XHJcbmltcG9ydCB1dGlscyBmcm9tICcuL3V0aWxzJztcclxuXHJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEhpc3RvcnkgZXh0ZW5kcyBCdXMge1xyXG5cclxuICAvKipcclxuICAgKiBDb25zdHJ1Y3RvclxyXG4gICAqL1xyXG4gIGNvbnN0cnVjdG9yKCBvcHRpb25zICkge1xyXG4gICAgc3VwZXIoKTtcclxuICAgIHRoaXMuX2FsYXJtcyA9IFtdO1xyXG4gICAgdGhpcy5fc3RvID0gbnVsbDtcclxuICAgIHRoaXMuX29wdGlvbnMgPSBPYmplY3QuYXNzaWduKCB7XHJcbiAgICAgIC8vIGtleSB1c2VkIGZvciBzdG9yYWdlXHJcbiAgICAgIGtleTogJ2hpc3RvcnlfZGF0YScsXHJcbiAgICAgIC8vIGF1dG8gcmVtb3ZlIGVudHJpZXMgcGFzdCB0aGlzIHZhbHVlIChzZWNzKVxyXG4gICAgICBleHBpcmU6IDE4MDAsXHJcbiAgICAgIC8vIHRvdGFsIG51bWJlciBvZiBlbnRyaWVzIHRvIGtlZXAgaW4gbGlzdFxyXG4gICAgICB0b3RhbDogMjAsXHJcbiAgICAgIC8vIC4uLlxyXG4gICAgfSwgb3B0aW9ucyApO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogU2F2ZSBjdXJyZW50IGhpc3RvcnkgZGF0YSB0byBzdG9yZSBhbmQgZW1pdCBsaXN0XHJcbiAgICovXHJcbiAgc2F2ZURhdGEoKSB7XHJcbiAgICB0aGlzLl9hdXRvQ2xlYW4oKTtcclxuICAgIHRoaXMuZW1pdCggJ3VwZGF0ZScsIHRoaXMuX2FsYXJtcyApO1xyXG4gICAgc3RvcmUuc2V0RGF0YSggdGhpcy5fb3B0aW9ucy5rZXksIHRoaXMuX2FsYXJtcyApO1xyXG4gICAgaWYgKCB0aGlzLl9zdG8gKSBjbGVhclRpbWVvdXQoIHRoaXMuX3N0byApO1xyXG4gICAgdGhpcy5fc3RvID0gc2V0VGltZW91dCggdGhpcy5zYXZlRGF0YS5iaW5kKCB0aGlzICksIDMwMDAwICk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBMb2FkIHNhdmVkIGhpc3RvcnkgZGF0YSBmcm9tIHN0b3JlXHJcbiAgICovXHJcbiAgbG9hZERhdGEoKSB7XHJcbiAgICBsZXQgZGF0YSA9IHN0b3JlLmdldERhdGEoIHRoaXMuX29wdGlvbnMua2V5ICk7XHJcbiAgICBpZiAoICFkYXRhIHx8ICFBcnJheS5pc0FycmF5KCBkYXRhICkgKSByZXR1cm47XHJcbiAgICB0aGlzLl9hbGFybXMgPSBkYXRhO1xyXG4gICAgdGhpcy5zYXZlRGF0YSgpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQWRkIGRhdGEgdG8gaGlzdG9yeVxyXG4gICAqIEBwYXJhbSB7c3RyaW5nfSAgdGl0bGUgIFRpdGxlIHN0cmluZ1xyXG4gICAqIEBwYXJhbSB7c3RyaW5nfSAgaW5mbyAgIEluZm8gc3RyaW5nXHJcbiAgICogQHBhcmFtIHtzdHJpbmd9ICBpY29uICAgSWNvbiBpbWFnZSBVUkxcclxuICAgKi9cclxuICBhZGQoIHRpdGxlLCBpbmZvLCBpY29uICkge1xyXG4gICAgaWYgKCAhdGl0bGUgfHwgIWluZm8gKSByZXR1cm47XHJcbiAgICBsZXQgaWQgICAgPSB1dGlscy5yYW5kU3RyaW5nKCAyMCApO1xyXG4gICAgbGV0IHRpbWUgID0gRGF0ZS5ub3coKTtcclxuICAgIGxldCBpc05ldyA9IHRydWU7XHJcbiAgICB0aGlzLl9hbGFybXMudW5zaGlmdCggeyBpZCwgdGltZSwgaXNOZXcsIHRpdGxlLCBpbmZvLCBpY29uIH0gKTtcclxuICAgIHRoaXMuc2F2ZURhdGEoKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFJlbW92ZSBhbiBlbnRyeSBmcm9tIHRoZSBsaXN0IGJ5IElEXHJcbiAgICogQHBhcmFtIHtzdHJpbmd9ICBpZCAgVW5pcXVlIGVudHJ5IElEXHJcbiAgICovXHJcbiAgcmVtb3ZlKCBpZCApIHtcclxuICAgIGlmICggIWlkIHx8IHR5cGVvZiBpZCAhPT0gJ3N0cmluZycgKSByZXR1cm47XHJcbiAgICB0aGlzLl9hbGFybXMgPSB0aGlzLl9hbGFybXMuZmlsdGVyKCBlID0+IGUuaWQgIT09IGlkICk7XHJcbiAgICB0aGlzLnNhdmVEYXRhKCk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBSZXNldCBuZXcgZW50cnkgaW5kaWNhdG9yc1xyXG4gICAqL1xyXG4gIHJlc2V0KCkge1xyXG4gICAgdGhpcy5fYWxhcm1zLmZvckVhY2goIGUgPT4geyBlLmlzTmV3ID0gZmFsc2U7IH0gKTtcclxuICAgIHRoaXMuc2F2ZURhdGEoKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFJlbW92ZSBhbGwgZW50cmllcyBmcm9tIHRoZSBsaXN0XHJcbiAgICovXHJcbiAgZmx1c2goKSB7XHJcbiAgICB0aGlzLl9hbGFybXMgPSBbXTtcclxuICAgIHRoaXMuc2F2ZURhdGEoKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIENsZWFudXAgdGhlIGxpc3QgYW5kIGVtaXQgY2hhbmdlc1xyXG4gICAqL1xyXG4gIF9hdXRvQ2xlYW4oKSB7XHJcbiAgICBsZXQgdGltZSA9IERhdGUubm93KCk7XHJcbiAgICBsZXQgZXhwaXJlID0gcGFyc2VJbnQoIHRoaXMuX29wdGlvbnMuZXhwaXJlICkgfCAwO1xyXG4gICAgbGV0IHRvdGFsID0gcGFyc2VJbnQoIHRoaXMuX29wdGlvbnMudG90YWwgKSB8IDA7XHJcbiAgICBpZiAoIGV4cGlyZSApIHRoaXMuX2FsYXJtcyA9IHRoaXMuX2FsYXJtcy5maWx0ZXIoIGUgPT4gKCAoIHRpbWUgLSBlLnRpbWUgKSAvIDEwMDAgKSA8IGV4cGlyZSApO1xyXG4gICAgaWYgKCB0b3RhbCApIHRoaXMuX2FsYXJtcyA9IHRoaXMuX2FsYXJtcy5zbGljZSggMCwgdG90YWwgKTtcclxuICB9XHJcbn1cclxuIiwiLyoqXHJcbiAqIENvbnNvbGUgbG9nIHdyYXBwZXJcclxuICovXHJcbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKCkge1xyXG4gIGNvbnN0IHcgPSBnbG9iYWwgfHwgd2luZG93IHx8IG51bGw7XHJcbiAgaWYgKCAhdyB8fCAhdy5ERUJVRyB8fCAhdy5jb25zb2xlICkgcmV0dXJuO1xyXG5cclxuICBmb3IgKCBsZXQgaSA9IDA7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyArK2kgKSB7XHJcbiAgICBpZiAoIHR5cGVvZiBhcmd1bWVudHNbIGkgXSA9PT0gJ29iamVjdCcgKSB7XHJcbiAgICAgIGFyZ3VtZW50c1sgaSBdID0gSlNPTi5zdHJpbmdpZnkoIGFyZ3VtZW50c1sgaSBdLCBudWxsLCAyICk7XHJcbiAgICB9XHJcbiAgfVxyXG4gIGNvbnNvbGUubG9nKCAnLScucmVwZWF0KCAxMDAgKSApO1xyXG4gIGNvbnNvbGUubG9nLmFwcGx5KCBjb25zb2xlLCBhcmd1bWVudHMgKTtcclxufVxyXG4iLCIvKipcclxuICogQmluYW5jZSBzb2NrZXQgYXBpIHdyYXBwZXIgY2xhc3NcclxuICovXHJcbmltcG9ydCBCdXMgZnJvbSAnLi9idXMnO1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgTWVzc2VuZ2VyIGV4dGVuZHMgQnVzIHtcclxuXHJcbiAgLy8gY29uc3RydWN0b3JcclxuICBjb25zdHJ1Y3Rvciggb3B0aW9ucyApIHtcclxuICAgIHN1cGVyKCk7XHJcbiAgICB0aGlzLl9hamF4ID0gbnVsbDtcclxuICAgIHRoaXMuX3N0byA9IG51bGw7XHJcbiAgICB0aGlzLl9xdWV1ZSA9IFtdO1xyXG4gICAgdGhpcy5fb3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oIHtcclxuICAgICAgLy8gaG93IG9mdGVuIHRvIGNoZWNrIHRoZSBxdWV1ZVxyXG4gICAgICBzZWNvbmRzOiA2MCxcclxuICAgICAgLy8gQVBJIG9wdGlvbnMgZm9yIG1haWxndW5cclxuICAgICAgbWFpbGd1bjogeyBlbmFibGVkOiBmYWxzZSwgYXBpa2V5OiAnJywgZW1haWw6ICcnLCBkb21haW46ICcnIH0sXHJcbiAgICAgIC8vIEFQSSBvcHRpb25zIGZvciB0ZWxlZ3JhbVxyXG4gICAgICB0ZWxlZ3JhbTogeyBlbmFibGVkOiBmYWxzZSwgYm90a2V5OiAnJywgdXNlcmlkOiAnJyB9LFxyXG4gICAgICAvLyAuLi5cclxuICAgIH0sIG9wdGlvbnMgKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIE1lcmdlIG9wdGlvbnNcclxuICAgKiBAcGFyYW0ge29iamVjdH0gIG9wdGlvbnMgIE9wdGlvbnMgb2JqZWN0XHJcbiAgICovXHJcbiAgc2V0T3B0aW9ucyggb3B0aW9ucyApIHtcclxuICAgIE9iamVjdC5hc3NpZ24oIHRoaXMuX29wdGlvbnMsIG9wdGlvbnMgKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFNldCBhamF4IG1vZHVsZSByZWZlcmVuY2UgdG8gdXNlIGZvciByZXF1ZXN0c1xyXG4gICAqIEBwYXJhbSB7b2JqZWN0fSAgYWpheCAgQWpheCBjbGFzcyBpbnN0YW5jZVxyXG4gICAqL1xyXG4gIHVzZUFqYXgoIGFqYXggKSB7XHJcbiAgICB0aGlzLl9hamF4ID0gYWpheDtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFB1c2ggbWVzc2FnZSBkYXRhIHRvIHF1ZXVlXHJcbiAgICogQHBhcmFtIHtzdHJpbmd9ICB0aXRsZSAgICAgTWVzc2FnZSB0aXRsZVxyXG4gICAqIEBwYXJhbSB7c3RyaW5nfSAgbWVzc2FnZSAgIE1lc3NhZ2UgdGV4dFxyXG4gICAqIEBwYXJhbSB7c3RyaW5nfSAgaW1hZ2UgICAgIE1lc3NhZ2UgaW1hZ2UvaWNvblxyXG4gICAqIEBwYXJhbSB7Kn0gICAgICAgZGF0YSAgICAgIE9wdGlvbmFsIGRhdGFcclxuICAgKi9cclxuICBhZGQoIHRpdGxlLCBtZXNzYWdlLCBpbWFnZSwgZGF0YSApIHtcclxuICAgIHRpdGxlICAgPSBTdHJpbmcoIHRpdGxlIHx8ICcnICk7XHJcbiAgICBtZXNzYWdlID0gU3RyaW5nKCBtZXNzYWdlIHx8ICcnICk7XHJcbiAgICBpbWFnZSAgID0gU3RyaW5nKCBpbWFnZSB8fCAnJyApO1xyXG4gICAgaWYgKCAhdGl0bGUgfHwgIW1lc3NhZ2UgKSByZXR1cm47XHJcbiAgICB0aGlzLl9xdWV1ZS5wdXNoKCB7IHRpdGxlLCBtZXNzYWdlLCBpbWFnZSwgZGF0YSB9ICk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBGbHVzaCBxdWV1ZSBkYXRhXHJcbiAgICovXHJcbiAgZmx1c2goKSB7XHJcbiAgICB0aGlzLl9xdWV1ZSA9IFtdO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogU3RhcnQgdGhlIHRpbWVyXHJcbiAgICovXHJcbiAgc3RhcnQoKSB7XHJcbiAgICB0aGlzLnN0b3AoKTtcclxuICAgIHRoaXMuX2NoZWNrUXVldWUoKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFN0b3AgdGhlIHRpbWVyXHJcbiAgICovXHJcbiAgc3RvcCgpIHtcclxuICAgIGlmICggdGhpcy5fc3RvICkgY2xlYXJUaW1lb3V0KCB0aGlzLl9zdG8gKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFF1ZXVlIGNoZWNrZXJcclxuICAgKi9cclxuICBfY2hlY2tRdWV1ZSgpIHtcclxuICAgIGNvbnN0IHNlY3MgPSBwYXJzZUludCggdGhpcy5fb3B0aW9ucy5zZWNvbmRzICkgfHwgMDtcclxuICAgIHRoaXMuX3N0byAgPSBzZXRUaW1lb3V0KCB0aGlzLl9jaGVja1F1ZXVlLmJpbmQoIHRoaXMgKSwgMTAwMCAqIHNlY3MgKTtcclxuICAgIGlmICggIXNlY3MgfHwgIXRoaXMuX3F1ZXVlLmxlbmd0aCApIHJldHVybjtcclxuICAgIHRoaXMuZW1pdCggJ3F1ZXVlJywgdGhpcy5fcXVldWUgKTtcclxuICAgIHRoaXMuX21haWxndW5TZW5kKCk7XHJcbiAgICB0aGlzLl90ZWxlZ3JhbVNlbmQoKTtcclxuICAgIHRoaXMuX3F1ZXVlID0gW107XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBTZW5kIHF1ZXVlIG1lc3NhZ2VzIHVzaW5nIE1haWxndW4gQVBJXHJcbiAgICovXHJcbiAgX21haWxndW5TZW5kKCkge1xyXG4gICAgbGV0IHsgZW5hYmxlZCwgYXBpa2V5LCBlbWFpbCwgZG9tYWluIH0gPSB0aGlzLl9vcHRpb25zLm1haWxndW47XHJcbiAgICBpZiAoICFlbmFibGVkIHx8ICFhcGlrZXkgfHwgIWVtYWlsIHx8ICFkb21haW4gfHwgIXRoaXMuX2FqYXggKSByZXR1cm47XHJcbiAgICBsZXQgY29udGVudCA9ICcnO1xyXG5cclxuICAgIHRoaXMuX3F1ZXVlLmZvckVhY2goIHEgPT4ge1xyXG4gICAgICBsZXQgeyB0aXRsZSwgbWVzc2FnZSwgaW1hZ2UgfSA9IHE7XHJcbiAgICAgIG1lc3NhZ2UgPSBTdHJpbmcoIG1lc3NhZ2UgKS5yZXBsYWNlKCAvXFxuKy9nLCAnIDxiciAvPicgKTtcclxuICAgICAgY29udGVudCArPSBgXHJcbiAgICAgIDxkaXYgc3R5bGU9XCJib3JkZXItdG9wOiAxcHggZGFzaGVkIHJnYmEoIDAsMCwwLDAuMSApOyBtYXJnaW46IDAgMCAxZW0gMDtcIj5cclxuICAgICAgICA8dGFibGUgd2lkdGg9XCIxMDAlXCIgYm9yZGVyPVwiMFwiPlxyXG4gICAgICAgICAgPHRyPlxyXG4gICAgICAgICAgICA8dGQ+PGltZyBzcmM9XCIkeyBpbWFnZSB9XCIgYWx0PVwiaW1hZ2VcIiBzdHlsZT1cIndpZHRoOiA0MnB4OyBoZWlnaHQ6IGF1dG87IG1hcmdpbjogMCAuNWVtIDAgMDtcIiAvPjwvdGQ+XHJcbiAgICAgICAgICAgIDx0ZCB3aWR0aD1cIjEwMCVcIj48Yj4keyB0aXRsZSB9PC9iPiA8YnIgLz4gJHsgbWVzc2FnZSB9PC90ZD5cclxuICAgICAgICAgIDwvdHI+XHJcbiAgICAgICAgPC90YWJsZT5cclxuICAgICAgPC9kaXY+YDtcclxuICAgIH0pO1xyXG5cclxuICAgIGNvbnN0IGh0bWwgPSBgXHJcbiAgICA8IURPQ1RZUEUgaHRtbD5cclxuICAgIDxodG1sIGxhbmc9XCJlbi1VU1wiPlxyXG4gICAgICA8Ym9keSBzdHlsZT1cIm1hcmdpbjogMDsgcGFkZGluZzogMDtcIj5cclxuICAgICAgICA8ZGl2IHN0eWxlPVwiZm9udC1mYW1pbHk6IG1vbm9zcGFjZTsgZm9udC1zaXplOiAxMHB4OyBwYWRkaW5nOiAxZW07XCI+XHJcbiAgICAgICAgICAkeyBjb250ZW50IH1cclxuICAgICAgICA8L2Rpdj5cclxuICAgICAgPC9ib2R5PlxyXG4gICAgPC9odG1sPmA7XHJcblxyXG4gICAgY29uc3QgZmRhdGEgPSBuZXcgRm9ybURhdGEoKTtcclxuICAgIGZkYXRhLmFwcGVuZCggJ2Zyb20nLCAnQmluYW5jZSBXYXRjaCBBcHAgPG5vcmVwbHlAJysgZG9tYWluICsnPicgKTtcclxuICAgIGZkYXRhLmFwcGVuZCggJ3RvJywgJ0UtbWFpbCBSZWNpcGllbnQgPCcrIGVtYWlsICsnPicgKTtcclxuICAgIGZkYXRhLmFwcGVuZCggJ3N1YmplY3QnLCAnQmluYW5jZSBXYXRjaCBFLW1haWwgTm90aWZpY2F0aW9ucyAoJysgdGhpcy5fcXVldWUubGVuZ3RoICsnKScgKTtcclxuICAgIGZkYXRhLmFwcGVuZCggJ2h0bWwnLCBTdHJpbmcoIGh0bWwgKS50cmltKCkgKTtcclxuXHJcbiAgICB0aGlzLl9hamF4LnBvc3QoICdodHRwczovL2FwaS5tYWlsZ3VuLm5ldC92My8nKyBkb21haW4gKycvbWVzc2FnZXMnLCB7XHJcbiAgICAgIHR5cGU6ICdqc29uJyxcclxuICAgICAgZGF0YTogZmRhdGEsXHJcbiAgICAgIGF1dGg6IHsgdXNlcm5hbWU6ICdhcGknLCBwYXNzd29yZDogYXBpa2V5IH0sXHJcbiAgICAgIGRvbmU6ICggeGhyLCBzdGF0dXMsIHJlc3BvbnNlICkgPT4ge1xyXG4gICAgICAgIGlmICggIXJlc3BvbnNlIHx8ICFyZXNwb25zZS5pZCApIHJldHVybiBjb25zb2xlLndhcm4oICdNYWlsZ3VuLUFQSScsIHN0YXR1cywgcmVzcG9uc2UgKTtcclxuICAgICAgICB0aGlzLmVtaXQoICdzZW50JywgJ0UtbWFpbCBub3RpZmljYXRpb25zIHNlbnQgdG8gKCcrIGVtYWlsICsnKS4nICk7XHJcbiAgICAgIH0sXHJcbiAgICB9KTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFNlbmQgcXVldWUgbWVzc2FnZXMgdXNpbmcgVGVsZWdyYW0gQVBJXHJcbiAgICovXHJcbiAgX3RlbGVncmFtU2VuZCgpIHtcclxuICAgIGxldCB7IGVuYWJsZWQsIGJvdGtleSwgdXNlcmlkIH0gPSB0aGlzLl9vcHRpb25zLnRlbGVncmFtO1xyXG4gICAgaWYgKCAhZW5hYmxlZCB8fCAhYm90a2V5IHx8ICF1c2VyaWQgfHwgIXRoaXMuX2FqYXggKSByZXR1cm47XHJcbiAgICBsZXQgY29udGVudCA9ICcnO1xyXG5cclxuICAgIHRoaXMuX3F1ZXVlLmZvckVhY2goIHEgPT4ge1xyXG4gICAgICBsZXQgeyB0aXRsZSwgbWVzc2FnZSB9ID0gcTtcclxuICAgICAgY29udGVudCArPSBgPGI+JHsgdGl0bGUgfTwvYj4gXFxuYDtcclxuICAgICAgY29udGVudCArPSBgJHsgbWVzc2FnZSB9IFxcbmA7XHJcbiAgICAgIGNvbnRlbnQgKz0gYFxcbmA7XHJcbiAgICB9KTtcclxuXHJcbiAgICBjb25zdCBmZGF0YSA9IG5ldyBGb3JtRGF0YSgpO1xyXG4gICAgZmRhdGEuYXBwZW5kKCAnY2hhdF9pZCcsIHVzZXJpZCApO1xyXG4gICAgZmRhdGEuYXBwZW5kKCAndGV4dCcsIFN0cmluZyggY29udGVudCApLnRyaW0oKSApO1xyXG4gICAgZmRhdGEuYXBwZW5kKCAncGFyc2VfbW9kZScsICdodG1sJyApO1xyXG5cclxuICAgIHRoaXMuX2FqYXgucG9zdCggJ2h0dHBzOi8vYXBpLnRlbGVncmFtLm9yZy9ib3QnKyBib3RrZXkgKycvc2VuZE1lc3NhZ2UnLCB7XHJcbiAgICAgIHR5cGU6ICdqc29uJyxcclxuICAgICAgZGF0YTogZmRhdGEsXHJcbiAgICAgIGRvbmU6ICggeGhyLCBzdGF0dXMsIHJlc3BvbnNlICkgPT4ge1xyXG4gICAgICAgIGlmICggIXJlc3BvbnNlIHx8ICFyZXNwb25zZS5vayApIHJldHVybiBjb25zb2xlLndhcm4oICdUZWxlZ3JhbS1BUEknLCBzdGF0dXMsIHJlc3BvbnNlICk7XHJcbiAgICAgICAgdGhpcy5lbWl0KCAnc2VudCcsICdUZWxlZ3JhbSBub3RpZmljYXRpb25zIHNlbnQgdG8gKCcrIHVzZXJpZCArJykuJyApO1xyXG4gICAgICB9LFxyXG4gICAgfSk7XHJcblxyXG4gIH1cclxuXHJcbn1cclxuIiwiLyoqXHJcbiAqIFR3aXR0ZXIgbmV3cyBoYW5kbGVyIGNsYXNzXHJcbiAqL1xyXG5pbXBvcnQgQnVzIGZyb20gJy4vYnVzJztcclxuaW1wb3J0IFR3aXR0ZXIgZnJvbSAnLi90d2l0dGVyJztcclxuaW1wb3J0IHN0b3JlIGZyb20gJy4vc3RvcmUnO1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgTmV3cyBleHRlbmRzIEJ1cyB7XHJcblxyXG4gIC8qKlxyXG4gICAqIENvbnN0cnVjdG9yXHJcbiAgICovXHJcbiAgY29uc3RydWN0b3IoKSB7XHJcbiAgICBzdXBlcigpO1xyXG4gICAgdGhpcy5fYWpheCAgICAgICAgPSBudWxsO1xyXG4gICAgdGhpcy5fYWNjb3VudHNLZXkgPSAnbmV3c19hY2NvdW50c19kYXRhJztcclxuICAgIHRoaXMuX3R3ZWV0c0tleSAgID0gJ25ld3NfdHdlZXRzX2RhdGEnO1xyXG4gICAgdGhpcy5faGFuZGxlcnMgICAgPSBbXTtcclxuICAgIHRoaXMuX3R3ZWV0cyAgICAgID0gW107XHJcbiAgICB0aGlzLl9ibGFja2xpc3QgICA9IFtdO1xyXG4gICAgdGhpcy5fY291bnRlciAgICAgPSAwO1xyXG4gICAgdGhpcy5faW50ZXJ2YWwgICAgPSBudWxsO1xyXG4gICAgdGhpcy5fb3B0aW9ucyAgICAgPSB7XHJcbiAgICAgIGVuYWJsZWQ6IHRydWUsICAvLyBhdXQgcmUtZmV0Y2ggbmV3cyBvbiBhIHRpbWVyXHJcbiAgICAgIGludGVydmFsOiA1LCAgICAvLyBob3cgb2Z0ZW4gdG8gdHJ5IGZldGNoaW5nIGZyb20gZWFjaCBzb3VyY2UgKHNlY3MpXHJcbiAgICAgIGRlbGF5OiAzMDAsICAgICAvLyBob3cgbG9uZyB0byB3YWl0IGJlZm9yZSBmZXRjaGluZyBhZ2FpbiBmcm9tIGVhY2ggc291cmNlIChzZWNzKVxyXG4gICAgICBkYXlzOiAxLCAgICAgICAgLy8gb25seSBzaG93IGVudHJpZXMgcG9zdGVkIHdpdGhpbiB0aGlzIG51bWJlciBvZiBkYXlzXHJcbiAgICAgIHR3ZWV0czogMSwgICAgICAvLyBob3cgbWFueSB0d2VldHMgdG8gZmV0Y2ggYXQgb25jZSBmcm9tIGVhY2ggc291cmNlXHJcbiAgICAgIHRvdGFsOiAxMDAsICAgICAvLyBtYXggbnVtYmVyIG9mIG5ld3MgZW50cmllcyB0byBzdG9yZSBpbiBsaXN0XHJcbiAgICB9O1xyXG4gICAgdGhpcy50d2VldHNIYW5kbGVyID0gdGhpcy50d2VldHNIYW5kbGVyLmJpbmQoIHRoaXMgKTtcclxuICAgIHRoaXMuc2V0dXBUaW1lcigpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogU2V0IGFqYXggbW9kdWxlIHJlZmVyZW5jZSB0byB1c2UgZm9yIHJlcXVlc3RzXHJcbiAgICogQHBhcmFtIHtvYmplY3R9ICBhamF4ICBBamF4IGNsYXNzIGluc3RhbmNlXHJcbiAgICovXHJcbiAgdXNlQWpheCggYWpheCApIHtcclxuICAgIHRoaXMuX2FqYXggPSBhamF4O1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogVXBkYXRlIG9wdGlvbnNcclxuICAgKiBAcGFyYW0ge29iamVjdH0gIG9wdGlvbnMgIE9wdGlvbnMgb2JqZWN0XHJcbiAgICovXHJcbiAgc2V0T3B0aW9ucyggb3B0aW9ucyApIHtcclxuICAgIE9iamVjdC5hc3NpZ24oIHRoaXMuX29wdGlvbnMsIG9wdGlvbnMgKTtcclxuICAgIHRoaXMuc2V0dXBUaW1lcigpO1xyXG4gICAgdGhpcy51cGRhdGVIYW5kbGVycygpO1xyXG4gICAgdGhpcy5maWx0ZXJUd2VldHMoKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIExvYWQgc2F2ZWQgYWNjb3VudHMgbGlzdCBmcm9tIHN0b3JlXHJcbiAgICovXHJcbiAgbG9hZEFjY291bnRzKCkge1xyXG4gICAgbGV0IGFjY291bnRzID0gc3RvcmUuZ2V0RGF0YSggdGhpcy5fYWNjb3VudHNLZXkgKTtcclxuICAgIGlmICggIUFycmF5LmlzQXJyYXkoIGFjY291bnRzICkgfHwgIWFjY291bnRzLmxlbmd0aCApIHJldHVybjtcclxuICAgIHRoaXMuaW1wb3J0QWNjb3VudHMoIGFjY291bnRzLCB0cnVlICk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBTYXZlIGFjY291bnRzIGxpc3QgdG8gc3RvcmVcclxuICAgKi9cclxuICBzYXZlQWNjb3VudHMoKSB7XHJcbiAgICBsZXQgYWNjb3VudHMgPSB0aGlzLl9oYW5kbGVycy5tYXAoIHR3ID0+IHR3LmhhbmRsZSApO1xyXG4gICAgc3RvcmUuc2V0RGF0YSggdGhpcy5fYWNjb3VudHNLZXksIGFjY291bnRzICk7XHJcbiAgICB0aGlzLmVtaXQoICdoYW5kbGVycycsIHRoaXMuX2hhbmRsZXJzICk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBMb2FkIGxpc3Qgb2YgdHdpdHRlciBoYW5kbGVzXHJcbiAgICogQHBhcmFtIHthcnJheX0gICAgYWNjb3VudHMgIExpc3Qgb2YgdHdpdHRlciBoYW5kbGUgc3RyaW5nIG5hbWVzXHJcbiAgICogQHBhcmFtIHtib29sZWFufSAgcmVzZXQgICAgIFJlc2V0IGN1cnJlbnQgbGlzdCBvZiBsb2FkZWQgaGFuZGxlcnNcclxuICAgKiBAcGFyYW0ge2Jvb2xlYW59ICBzYXZlICAgICAgU2F2ZSBsaXN0IG9mIGFjY291bnQgYWZ0ZXIgaW1wb3J0aW5nXHJcbiAgICovXHJcbiAgaW1wb3J0QWNjb3VudHMoIGFjY291bnRzLCByZXNldCwgc2F2ZSApIHtcclxuICAgIGFjY291bnRzID0gQXJyYXkuaXNBcnJheSggYWNjb3VudHMgKSA/IGFjY291bnRzIDogW107XHJcbiAgICBsZXQgY291bnQgPSAwO1xyXG5cclxuICAgIC8vIHJlc2V0IGN1cnJlbnQgbGlzdCwgaWYgYSBuZXcgbGlzdCBpcyBhdmFpbGFibGVcclxuICAgIGlmICggcmVzZXQgJiYgYWNjb3VudHMubGVuZ3RoICkgdGhpcy5faGFuZGxlcnMgPSBbXTtcclxuICAgIC8vIGltcG9ydCBuZXcgYWNjb3VudHMgbGlzdFxyXG4gICAgZm9yICggbGV0IGhhbmRsZSBvZiBhY2NvdW50cyApIHRoaXMudHJhY2tBY2NvdW50KCBoYW5kbGUgKSAmJiBjb3VudCsrO1xyXG4gICAgLy8gc2F2ZSBhY2NvdW50cyBiYWNrIHRvIHN0b3JlLCBvciBqdXN0IGVtaXQgbG9hZGVkIGxpc3RcclxuICAgIGlmICggc2F2ZSApIHsgdGhpcy5zYXZlQWNjb3VudHMoKTsgfVxyXG4gICAgZWxzZSB7IHRoaXMuZW1pdCggJ2hhbmRsZXJzJywgdGhpcy5faGFuZGxlcnMgKTsgfVxyXG5cclxuICAgIHJldHVybiBjb3VudDtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIENoZWNrcyBpZiBhIGhhbmRsZSBpcyBhbHJlYWR5IGJlaW5nIHRyYWNrZWRcclxuICAgKiBAcGFyYW0ge3N0cmluZ30gIGhhbmRsZSAgVHdpdHRlciBoYW5kbGVcclxuICAgKi9cclxuICB0cmFja2luZyggaGFuZGxlICkge1xyXG4gICAgaWYgKCAhaGFuZGxlIHx8IHR5cGVvZiBoYW5kbGUgIT09ICdzdHJpbmcnICkgcmV0dXJuIGZhbHNlO1xyXG4gICAgcmV0dXJuICggdGhpcy5faGFuZGxlcnMuZmlsdGVyKCB0dyA9PiB0dy5oYW5kbGUgPT09IGhhbmRsZSApLmxlbmd0aCApID8gdHJ1ZSA6IGZhbHNlO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogU3RhcnQgdHJhY2tpbmcgYSBuZXcgdHdpdHRlciBhY2NvdW50XHJcbiAgICogQHBhcmFtIHtzdHJpbmd9ICAgaGFuZGxlICBUd2l0dGVyIGhhbmRsZVxyXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gIGZldGNoICAgRmV0Y2ggdHdlZXRzIGFmdGVyIGFkZGluZ1xyXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gIHNhdmUgICAgU2F2ZSBhY2NvdW50cyBhZnRlciBhZGRpbmdcclxuICAgKi9cclxuICB0cmFja0FjY291bnQoIGhhbmRsZSwgZmV0Y2gsIHNhdmUgKSB7XHJcbiAgICBpZiAoICFoYW5kbGUgfHwgdHlwZW9mIGhhbmRsZSAhPT0gJ3N0cmluZycgKSByZXR1cm4gZmFsc2U7XHJcbiAgICBpZiAoIHRoaXMudHJhY2tpbmcoIGhhbmRsZSApICkgcmV0dXJuIGZhbHNlO1xyXG4gICAgLy8gY3JlYXRlIG5ldyBoYW5kbGVyLCBhZGQgdG8gbGlzdCBhbmQgdXBkYXRlIG9wdGlvbnNcclxuICAgIGNvbnN0IHR3ID0gbmV3IFR3aXR0ZXIoIGhhbmRsZSApO1xyXG4gICAgdGhpcy51cGRhdGVIYW5kbGVycyggdHcgKTtcclxuICAgIHRoaXMuX2hhbmRsZXJzLnB1c2goIHR3ICk7XHJcbiAgICAvLyBmZXRjaCB0d2VldHMgbm93IGlmIG5lZWRlZCBhbmQgZW1pdCBldmVudFxyXG4gICAgaWYgKCBmZXRjaCApIHR3LmZldGNoVHdlZXRzKCB0aGlzLl9hamF4LCB0aGlzLnR3ZWV0c0hhbmRsZXIgKTtcclxuICAgIGlmICggc2F2ZSApIHRoaXMuc2F2ZUFjY291bnRzKCk7XHJcbiAgICByZXR1cm4gdHJ1ZTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFN0b3AgdHJhY2tpbmcgYSB0d2l0dGVyIGFjY291bnRcclxuICAgKiBAcGFyYW0ge3N0cmluZ30gIGhhbmRsZSAgVHdpdHRlciBoYW5kbGVcclxuICAgKi9cclxuICB1bnRyYWNrQWNjb3VudCggaGFuZGxlICkge1xyXG4gICAgaWYgKCAhaGFuZGxlIHx8IHR5cGVvZiBoYW5kbGUgIT09ICdzdHJpbmcnICkgcmV0dXJuIGZhbHNlO1xyXG4gICAgLy8gZ2V0IGhhbmRsZXIgdGhhdCBpcyBiZWluZyByZW1vdmVkIGZyb20gdGhlIGxpc3QsIGlmIGl0IGV4aXN0c1xyXG4gICAgY29uc3QgdHcgPSB0aGlzLl9oYW5kbGVycy5maWx0ZXIoIHR3ID0+IHR3LmhhbmRsZSA9PT0gaGFuZGxlICkuc2hpZnQoKTtcclxuICAgIGlmICggIXR3ICkgcmV0dXJuIHRydWU7XHJcbiAgICAvLyByZW1vdmUgaGFuZGxlciBmcm9tIHRoZSBsaXN0IGFuZCBlbWl0IGV2ZW50c1xyXG4gICAgdGhpcy5faGFuZGxlcnMgPSB0aGlzLl9oYW5kbGVycy5maWx0ZXIoIHR3ID0+IHR3LmhhbmRsZSAhPT0gaGFuZGxlICk7XHJcbiAgICB0aGlzLl90d2VldHMgPSB0aGlzLl90d2VldHMuZmlsdGVyKCB0ID0+IHQuaGFuZGxlICE9PSBoYW5kbGUgKTtcclxuICAgIHRoaXMuc2F2ZUFjY291bnRzKCk7XHJcbiAgICB0aGlzLnNhdmVUd2VldHMoKTtcclxuICAgIHJldHVybiB0cnVlO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogVXBkYXRlIG9wdGlvbnMgZm9yIGVhY2ggVHdpdHRlciBoYW5kbGVyXHJcbiAgICovXHJcbiAgdXBkYXRlSGFuZGxlcnMoIHR3ICkge1xyXG4gICAgY29uc3QgZmV0Y2hEZWxheSA9IHBhcnNlSW50KCB0aGlzLl9vcHRpb25zLmRlbGF5ICkgfHwgMzAwO1xyXG4gICAgY29uc3QgbGltaXRDb3VudCA9IHBhcnNlSW50KCB0aGlzLl9vcHRpb25zLnR3ZWV0cyApIHx8IDE7XHJcbiAgICBpZiAoIHR3IGluc3RhbmNlb2YgVHdpdHRlciApIHJldHVybiB0dy5zZXRPcHRpb25zKCB7IGZldGNoRGVsYXksIGxpbWl0Q291bnQgfSApO1xyXG4gICAgdGhpcy5faGFuZGxlcnMuZm9yRWFjaCggdHcgPT4gdHcuc2V0T3B0aW9ucyggeyBmZXRjaERlbGF5LCBsaW1pdENvdW50IH0gKSApO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogTG9hZCBjYWNoZWQgdHdlZXRzIGZyb20gc3RvcmVcclxuICAgKi9cclxuICBsb2FkVHdlZXRzKCkge1xyXG4gICAgbGV0IHR3ZWV0cyA9IHN0b3JlLmdldERhdGEoIHRoaXMuX3R3ZWV0c0tleSApO1xyXG4gICAgaWYgKCAhQXJyYXkuaXNBcnJheSggdHdlZXRzICkgfHwgIXR3ZWV0cy5sZW5ndGggKSByZXR1cm47XHJcbiAgICB0aGlzLl90d2VldHMgPSB0d2VldHM7XHJcbiAgICB0aGlzLnJlc2V0VHdlZXRzKCk7XHJcbiAgICB0aGlzLmZpbHRlclR3ZWV0cygpO1xyXG4gICAgdGhpcy5zYXZlVHdlZXRzKCk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBTYXZlIGN1cnJlbnQgdHdlZXRzIHRvIHN0b3JlXHJcbiAgICovXHJcbiAgc2F2ZVR3ZWV0cygpIHtcclxuICAgIHN0b3JlLnNldERhdGEoIHRoaXMuX3R3ZWV0c0tleSwgdGhpcy5fdHdlZXRzICk7XHJcbiAgICB0aGlzLmVtaXQoICd0d2VldHMnLCB0aGlzLl90d2VldHMgKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFJlc2V0IG5ldyBlbnRyaWVzIGluZGljYXRvclxyXG4gICAqL1xyXG4gIHJlc2V0VHdlZXRzKCkge1xyXG4gICAgdGhpcy5fdHdlZXRzLmZvckVhY2goIHQgPT4geyB0LmlzTmV3ID0gZmFsc2U7IH0gKTtcclxuICAgIHRoaXMuc2F2ZVR3ZWV0cygpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogRmx1c2ggdHdlZXRzIGxpc3RcclxuICAgKi9cclxuICBmbHVzaFR3ZWV0cygpIHtcclxuICAgIHRoaXMuX3R3ZWV0cyA9IFtdO1xyXG4gICAgdGhpcy5fYmxhY2tsaXN0ID0gW107XHJcbiAgICB0aGlzLnNhdmVUd2VldHMoKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFJlbW92ZSB0d2VldCBmcm9tIGxpc3QgYW5kIGFkZCBJRCB0byBibGFja2xpc3RcclxuICAgKiBAcGFyYW0ge3N0cmluZ30gIGlkICBUd2VldCBJRFxyXG4gICAqL1xyXG4gIGJsb2NrVHdlZXQoIGlkICkge1xyXG4gICAgaWYgKCAhaWQgKSByZXR1cm4gZmFsc2U7XHJcbiAgICB0aGlzLl90d2VldHMgPSB0aGlzLl90d2VldHMuZmlsdGVyKCB0ID0+IHQuaWQgIT09IGlkICk7XHJcbiAgICB0aGlzLl9ibGFja2xpc3QgPSB0aGlzLl9ibGFja2xpc3QuZmlsdGVyKCB0aWQgPT4gdGlkICE9PSBpZCApO1xyXG4gICAgdGhpcy5fYmxhY2tsaXN0LnB1c2goIGlkICk7XHJcbiAgICB0aGlzLnNhdmVUd2VldHMoKTtcclxuICAgIHJldHVybiB0cnVlO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQWRkIG5ldyB0d2VldCBvYmplY3QgdG8gdGhlIGxpc3RcclxuICAgKiBAcGFyYW0ge29iamVjdH0gIHR3ZWV0ICBUd2VldCBvYmplY3RcclxuICAgKi9cclxuICBhZGRUd2VldCggdHdlZXQgKSB7XHJcbiAgICBpZiAoICF0d2VldCB8fCAhKCAnaWQnIGluIHR3ZWV0ICkgKSByZXR1cm4gZmFsc2U7XHJcbiAgICBpZiAoIHRoaXMudHdlZXRFeGlzdHMoIHR3ZWV0ICkgKSByZXR1cm4gZmFsc2U7XHJcbiAgICBpZiAoIHRoaXMudHdlZXRCbG9ja2VkKCB0d2VldCApICkgcmV0dXJuIGZhbHNlO1xyXG4gICAgaWYgKCB0aGlzLnR3ZWV0RXhwaXJlZCggdHdlZXQgKSApIHJldHVybiBmYWxzZTtcclxuICAgIHR3ZWV0LmlzTmV3ID0gdHJ1ZTsgLy8gZm9yIGluZGljYXRvclxyXG4gICAgdGhpcy5fdHdlZXRzLnB1c2goIHR3ZWV0ICk7XHJcbiAgICByZXR1cm4gdHJ1ZTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIENoZWNrcyBpZiBhIHR3ZWV0IGlzIGluIHRoZSBsaXN0IG9mIG5ld3NcclxuICAgKiBAcGFyYW0ge29iamVjdH0gIHR3ZWV0ICBUd2VldCBvYmplY3RcclxuICAgKi9cclxuICB0d2VldEV4aXN0cyggdHdlZXQgKSB7XHJcbiAgICBpZiAoICF0d2VldCB8fCAhKCAnaWQnIGluIHR3ZWV0ICkgKSByZXR1cm4gZmFsc2U7XHJcbiAgICByZXR1cm4gdGhpcy5fdHdlZXRzLmZpbHRlciggdCA9PiB0LmlkID09PSB0d2VldC5pZCApLmxlbmd0aCA/IHRydWUgOiBmYWxzZTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIENoZWNrcyBpZiBhIHR3ZWV0IGlzIGluIHRoZSBibG9ja2xpc3RcclxuICAgKiBAcGFyYW0ge29iamVjdH0gIHR3ZWV0ICBUd2VldCBvYmplY3RcclxuICAgKi9cclxuICB0d2VldEJsb2NrZWQoIHR3ZWV0ICkge1xyXG4gICAgaWYgKCAhdHdlZXQgfHwgISggJ2lkJyBpbiB0d2VldCApICkgcmV0dXJuIGZhbHNlO1xyXG4gICAgcmV0dXJuIHRoaXMuX2JsYWNrbGlzdC5maWx0ZXIoIGlkID0+IGlkID09PSB0d2VldC5pZCApLmxlbmd0aCA/IHRydWUgOiBmYWxzZTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIENoZWNrcyBpZiBhIHR3ZWV0IGlzIHRvbyBvbGQsIGJhc2VkIG9uIG9wdGlvblxyXG4gICAqIEBwYXJhbSB7b2JqZWN0fSAgdHdlZXQgIFR3ZWV0IG9iamVjdFxyXG4gICAqL1xyXG4gIHR3ZWV0RXhwaXJlZCggdHdlZXQgKSB7XHJcbiAgICBpZiAoICF0d2VldCB8fCAhKCAnaWQnIGluIHR3ZWV0ICkgKSByZXR1cm4gZmFsc2U7XHJcbiAgICBsZXQgZGF5cyA9IHBhcnNlSW50KCB0aGlzLl9vcHRpb25zLmRheXMgKSB8IDA7XHJcbiAgICBsZXQgc2VjcyA9ICggRGF0ZS5ub3coKSAtIHR3ZWV0LnRpbWUgKSAvIDEwMDA7XHJcbiAgICBsZXQgYWdlICA9IE1hdGguY2VpbCggc2VjcyAvIDg2NDAwICk7XHJcbiAgICByZXR1cm4gKCBhZ2UgPiBkYXlzICkgPyB0cnVlIDogZmFsc2U7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBIYW5kbGVzIG5ldyB0d2VldHMgdGhhdCBhcmUgZmV0Y2hlZCBmcm9tIHRoZSBUd2l0dGVyIGNsYXNzXHJcbiAgICogQHBhcmFtIHtzdHJpbmd9ICBlcnIgICAgRXJyb3Igc3RyaW5nIChlbXB0eSBvbiBzdWNjZXNzKVxyXG4gICAqIEBwYXJhbSB7YXJyYXl9ICB0d2VldHMgIFR3ZWV0cyBhcnJheSAoZW1wdHkgb24gZXJyb3IpXHJcbiAgICovXHJcbiAgdHdlZXRzSGFuZGxlciggZXJyLCB0d2VldHMgKSB7XHJcbiAgICBpZiAoIGVyciApIHJldHVybiB0aGlzLmVtaXQoICdlcnJvcicsIGVyciApO1xyXG4gICAgaWYgKCAhdHdlZXRzLmxlbmd0aCApIHJldHVybjtcclxuXHJcbiAgICBmb3IgKCBsZXQgdHdlZXQgb2YgdHdlZXRzICkge1xyXG4gICAgICAvLyBpdCdzIHBvc3NpYmxlIGFkZGVkIHR3ZWV0cyBjYW4gZ2V0IHJlbW92ZWQgZHVlIHRvIGZpbHRlcmluZy4uLlxyXG4gICAgICBsZXQgYWRkZWQgPSB0aGlzLmFkZFR3ZWV0KCB0d2VldCApO1xyXG4gICAgICB0aGlzLmZpbHRlclR3ZWV0cygpO1xyXG5cclxuICAgICAgLy8gZG91YmxlIGNoZWNrIGlmIHRoZSB0d2VldCBzdXJ2aXZlZCBhbmQgZW1pdCBpdFxyXG4gICAgICBpZiAoIGFkZGVkICYmIHRoaXMudHdlZXRFeGlzdHMoIHR3ZWV0ICkgKSB7XHJcbiAgICAgICAgdGhpcy5lbWl0KCAndHdlZXQnLCB0d2VldCApO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgICB0aGlzLnNhdmVBY2NvdW50cygpO1xyXG4gICAgdGhpcy5zYXZlVHdlZXRzKCk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBDbGVhbnVwIHR3ZWV0cyBsaXN0XHJcbiAgICovXHJcbiAgZmlsdGVyVHdlZXRzKCkge1xyXG4gICAgbGV0IHRvdGFsID0gcGFyc2VJbnQoIHRoaXMuX29wdGlvbnMudG90YWwgKTtcclxuXHJcbiAgICAvLyBmaWx0ZXIgb3V0IG9sZCB0d2VldHNcclxuICAgIHRoaXMuX3R3ZWV0cyA9IHRoaXMuX3R3ZWV0cy5maWx0ZXIoIHR3ZWV0ID0+IHtcclxuICAgICAgcmV0dXJuICF0aGlzLnR3ZWV0RXhwaXJlZCggdHdlZXQgKTtcclxuICAgIH0pO1xyXG4gICAgLy8gc29ydCB0d2VldHMgZnJvbSBuZXcgdG8gb2xkXHJcbiAgICB0aGlzLl90d2VldHMgPSB0aGlzLl90d2VldHMuc29ydCggKCBhLCBiICkgPT4ge1xyXG4gICAgICBpZiAoIGEudGltZSA+IGIudGltZSApIHJldHVybiAtMTtcclxuICAgICAgaWYgKCBhLnRpbWUgPCBiLnRpbWUgKSByZXR1cm4gMTtcclxuICAgICAgcmV0dXJuIDA7XHJcbiAgICB9KTtcclxuICAgIC8vIHRyaW0gdHdlZXRzIGxpc3RcclxuICAgIGlmICggdG90YWwgKSB7XHJcbiAgICAgIHRoaXMuX3R3ZWV0cyA9IHRoaXMuX3R3ZWV0cy5zbGljZSggMCwgdG90YWwgKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEZldGNoIHR3ZWV0cyBmb3IgYW4gYWNjb3VudCBieSBoYW5kbGVcclxuICAgKiBAcGFyYW0ge3N0cmluZ30gIGhhbmRsZSAgVHdpdHRlciBoYW5kbGVcclxuICAgKi9cclxuICBmZXRjaEJ5SGFuZGxlKCBoYW5kbGUgKSB7XHJcbiAgICBpZiAoICFoYW5kbGUgfHwgdHlwZW9mIGhhbmRsZSAhPT0gJ3N0cmluZycgKSByZXR1cm4gZmFsc2U7XHJcbiAgICBjb25zdCB0dyA9IHRoaXMuX2hhbmRsZXJzLmZpbHRlciggdHcgPT4gdHcuaGFuZGxlID09PSBoYW5kbGUgKS5zaGlmdCgpO1xyXG4gICAgaWYgKCB0dyApIHR3LmZldGNoVHdlZXRzKCB0aGlzLl9hamF4LCB0aGlzLnR3ZWV0c0hhbmRsZXIgKTtcclxuICAgIHJldHVybiB0cnVlO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogRmV0Y2ggdHdlZXRzIGZyb20gbmV4dCBoYW5kbGVyIGRvd24gdGhlIGxpc3RcclxuICAgKi9cclxuICBmZXRjaE5leHRIYW5kbGVyKCkge1xyXG4gICAgaWYgKCAhdGhpcy5faGFuZGxlcnMubGVuZ3RoICkgcmV0dXJuO1xyXG4gICAgY29uc3QgbGFzdCA9IHRoaXMuX2hhbmRsZXJzLmxlbmd0aCAtIDE7XHJcbiAgICBjb25zdCB0dyA9IHRoaXMuX2hhbmRsZXJzWyB0aGlzLl9jb3VudGVyIF07XHJcbiAgICBpZiAoIHR3ICkgdHcuZmV0Y2hUd2VldHMoIHRoaXMuX2FqYXgsIHRoaXMudHdlZXRzSGFuZGxlciApO1xyXG4gICAgdGhpcy5fY291bnRlciA9ICggdGhpcy5fY291bnRlciA8IGxhc3QgKSA/ICggdGhpcy5fY291bnRlciArIDEgKSA6IDA7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBTdGFydCB0aGUgdHdlZXRzIGludGVydmFsIGhhbmRsZXJcclxuICAgKi9cclxuICBzZXR1cFRpbWVyKCkge1xyXG4gICAgdGhpcy5zdG9wVGltZXIoKTtcclxuICAgIGNvbnN0IHNlY3MgPSBwYXJzZUludCggdGhpcy5fb3B0aW9ucy5pbnRlcnZhbCApO1xyXG4gICAgaWYgKCAhc2VjcyApIHJldHVybjtcclxuICAgIHRoaXMuX2ludGVydmFsID0gc2V0SW50ZXJ2YWwoICgpID0+IHtcclxuICAgICAgaWYgKCAhdGhpcy5fb3B0aW9ucy5lbmFibGVkICkgcmV0dXJuO1xyXG4gICAgICB0aGlzLmZldGNoTmV4dEhhbmRsZXIoKTtcclxuICAgIH0sIDEwMDAgKiBzZWNzICk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBTdG9wIHRoZSB0d2VldHMgaW50ZXJ2YWwgaGFuZGxlclxyXG4gICAqL1xyXG4gIHN0b3BUaW1lcigpIHtcclxuICAgIGlmICggdGhpcy5faW50ZXJ2YWwgKSB7XHJcbiAgICAgIGNsZWFySW50ZXJ2YWwoIHRoaXMuX2ludGVydmFsICk7XHJcbiAgICAgIHRoaXMuX2ludGVydmFsID0gbnVsbDtcclxuICAgIH1cclxuICB9XHJcblxyXG59XHJcbiIsIi8qKlxuICogUHVzaCBub3RpZmljYXRpb25zIGFuZCBjdXN0b20gYWxhcm1zIGhhbmRsZXIgY2xhc3NcbiAqL1xuaW1wb3J0IHV0aWxzIGZyb20gJy4vdXRpbHMnO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBOb3RpZnkge1xuXG4gIC8vIGNvbnN0cnVjdG9yXG4gIGNvbnN0cnVjdG9yKCBvcHRpb25zICkge1xuICAgIHRoaXMuX3F1ZXVlICAgPSBbXTtcbiAgICB0aGlzLl9ub3RpY2VzID0gW107XG4gICAgdGhpcy5fb3B0aW9ucyA9IHtcbiAgICAgIC8vIHRvZ2dsZSBub3RpZmljYXRpb25zXG4gICAgICBlbmFibGVkOiB0cnVlLFxuICAgICAgLy8gbm90aWZpY2F0aW9ucyBkdXJhdGlvbiAoc2VjcylcbiAgICAgIGR1cmF0aW9uOiAxMCxcbiAgICAgIC8vIHRvZ2dsZSBub3RpZmljYXRpb24gc291bmRcbiAgICAgIHNvdW5kOiB0cnVlLFxuICAgICAgLy8gdm9sdW1lIG9mIG5vdGlmaWNhdGlvbiBzb3VuZCAoIDAgLSAxIClcbiAgICAgIHZvbHVtZTogMSxcbiAgICAgIC8vIGF1ZGlvIGZpbGUgdG8gcGxheSBvbiB3aXRoIG5vdGlmaWNhdGlvbnNcbiAgICAgIGF1ZGlvOiAnLi4vLi4vLi4vbWFya2V0L2F1ZGlvL2F1ZGlvXzMubXAzJyxcbiAgICAgIC8vIGRlZmF1bHQgbm90aWZpY2F0aW9uIGltYWdlIGZpbGVcbiAgICAgIGltYWdlOiAnLi4vLi4vLi4vbWFya2V0L25vdGlmaWNhdGlvbi5wbmcnLFxuICAgIH07XG4gICAgdGhpcy5zZXRPcHRpb25zKCBvcHRpb25zICk7XG4gICAgdGhpcy5fd2F0Y2hRdWV1ZSgpO1xuICB9XG5cbiAgLy8gbWVyZ2UgbmV3IG9wdGlvbnNcbiAgc2V0T3B0aW9ucyggb3B0aW9ucyApIHtcbiAgICBPYmplY3QuYXNzaWduKCB0aGlzLl9vcHRpb25zLCBvcHRpb25zICk7XG4gIH1cblxuICAvLyBhZGQgYSBub3RpZmljYXRpb24gbWVzc2FnZSB0byB0aGUgcXVldWVcbiAgYWRkKCB0aXRsZSwgYm9keSwgaWNvbiwgbGluayApIHtcbiAgICBpZiAoICF0aXRsZSB8fCAhYm9keSApIHJldHVybjtcbiAgICBsZXQgaWQgPSB1dGlscy5yYW5kU3RyaW5nKCAyMCApO1xuICAgIGxldCB0aW1lID0gRGF0ZS5ub3coKTtcbiAgICBpY29uID0gU3RyaW5nKCBpY29uIHx8IHRoaXMuX29wdGlvbnMuaW1hZ2UgKTtcbiAgICB0aGlzLl9xdWV1ZSA9IHRoaXMuX3F1ZXVlLmZpbHRlciggbiA9PiBuLnRpdGxlICE9PSB0aXRsZSApO1xuICAgIHRoaXMuX3F1ZXVlLnB1c2goIHsgaWQsIHRpbWUsIHRpdGxlLCBib2R5LCBpY29uLCBsaW5rIH0gKTtcbiAgfVxuXG4gIC8vIGZsdXNoIHRoZSBxdWV1ZVxuICBmbHVzaCgpIHtcbiAgICB0aGlzLl9xdWV1ZSA9IFtdO1xuICB9XG5cbiAgLy8gY2hlY2sgaWYgbm90aWZpY2F0aW9uIGlzIHN1cHBvcnRlZFxuICBoYXNTdXBwb3J0KCkge1xuICAgIHJldHVybiAoIHdpbmRvdyAmJiAoICdOb3RpZmljYXRpb24nIGluIHdpbmRvdyApICk7XG4gIH1cblxuICAvLyBjaGVjayBpZiBOb3RpZmljYXRpb24gaXMgcG9zc2libGVcbiAgY2FuTm90aWZ5KCkge1xuICAgIGlmICggIXRoaXMuaGFzU3VwcG9ydCgpICkgcmV0dXJuIGZhbHNlO1xuICAgIGlmICggTm90aWZpY2F0aW9uLnBlcm1pc3Npb24gIT09ICdncmFudGVkJyApIHJldHVybiBmYWxzZTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIC8vIGFzayBmb3IgYnJvd3NlciBub3RpZmljYXRpb25zIHBlcm1pc3Npb25cbiAgcGVybWlzc2lvbiggY2FsbGJhY2sgKSB7XG4gICAgaWYgKCAhdGhpcy5oYXNTdXBwb3J0KCkgKSByZXR1cm47XG4gICAgTm90aWZpY2F0aW9uLnJlcXVlc3RQZXJtaXNzaW9uKCkudGhlbiggcmVzcG9uc2UgPT4ge1xuICAgICAgaWYgKCB0eXBlb2YgY2FsbGJhY2sgPT09ICdmdW5jdGlvbicgKSBjYWxsYmFjayggcmVzcG9uc2UgKTtcbiAgICB9KTtcbiAgfVxuXG4gIC8vIHBsYXkgbm90aWZpY2F0aW9uIHNvdW5kIGlmIGVuYWJsZWRcbiAgcGxheVNvdW5kKCkge1xuICAgIGlmICggdGhpcy5fb3B0aW9ucy5zb3VuZCApIHtcbiAgICAgIHV0aWxzLnBsYXlBdWRpbyggdGhpcy5fb3B0aW9ucy5hdWRpbywgdGhpcy5fb3B0aW9ucy52b2x1bWUgKTtcbiAgICB9XG4gIH1cblxuICAvLyBsaW1pdCB2aXNpYmxlIG5vdGlmaWNhdGlvbnMgdG8gYSBmaXhlZCBudW1iZXJcbiAgX2NsZWFudXBOb3RpZmljYXRpb25zKCkge1xuICAgIGxldCBsaW1pdCA9IDM7XG4gICAgaWYgKCB0aGlzLl9ub3RpY2VzLmxlbmd0aCA8PSBsaW1pdCApIHJldHVybjtcbiAgICBmb3IgKCBsZXQgaSA9IDA7IGkgPCAoIHRoaXMuX25vdGljZXMubGVuZ3RoIC0gbGltaXQgKTsgKytpICkge1xuICAgICAgdGhpcy5fbm90aWNlc1sgaSBdLmNsb3NlKCk7IC8vIHRyaWdnZXIgY2xvc2UgZXZlbnRcbiAgICB9XG4gIH1cblxuICAvLyBjcmVhdGUgbm90aWZpY2F0aW9ucyBmcm9tIHRoZSBxdWV1ZSBvbiBhIHRpbWVyXG4gIF93YXRjaFF1ZXVlKCkge1xuICAgIHRoaXMuX2NsZWFudXBOb3RpZmljYXRpb25zKCk7XG4gICAgc2V0VGltZW91dCggdGhpcy5fd2F0Y2hRdWV1ZS5iaW5kKCB0aGlzICksIDUwMCApO1xuICAgIGlmICggIXRoaXMuX29wdGlvbnMuZW5hYmxlZCB8fCAhdGhpcy5fcXVldWUubGVuZ3RoICkgcmV0dXJuO1xuICAgIGlmICggIXRoaXMuY2FuTm90aWZ5KCkgKSByZXR1cm47XG5cbiAgICAvLyBjcmVhdGUgbmV3IG5vdGlmaWNhdGlvblxuICAgIGxldCB7IGlkLCB0aW1lLCB0aXRsZSwgYm9keSwgaWNvbiwgbGluayB9ID0gdGhpcy5fcXVldWUuc2hpZnQoKTtcbiAgICBsZXQgYSA9IG5ldyBOb3RpZmljYXRpb24oIHRpdGxlLCB7IGJvZHksIGljb24sIHRhZzogaWQgfSApO1xuXG4gICAgLy8gYXV0by1jbG9zZSBvbiBvcHRpb25hbCBkdXJhdGlvblxuICAgIGxldCB0dGwgPSBwYXJzZUludCggdGhpcy5fb3B0aW9ucy5kdXJhdGlvbiApO1xuICAgIGlmICggdHRsICkgc2V0VGltZW91dCggKCkgPT4gYS5jbG9zZSgpLCAxMDAwICogdHRsICk7XG5cbiAgICAvLyBrZWVwIHRyYWNrIG9mIHZpc2libGUgbm90aWZpY2F0aW9uc1xuICAgIGEuYWRkRXZlbnRMaXN0ZW5lciggJ3Nob3cnLCBlID0+IHtcbiAgICAgIGlmICggIWUgfHwgIWUudGFyZ2V0IHx8ICFlLnRhcmdldC50YWcgKSByZXR1cm47XG4gICAgICB0aGlzLnBsYXlTb3VuZCgpO1xuICAgIH0pO1xuICAgIC8vIHJlbW92ZSBub3RpZmljYXRpb24gZnJvbSBsb2NhbCBhcnJheSB3aGVuIGl0IGNsb3Nlc1xuICAgIGEuYWRkRXZlbnRMaXN0ZW5lciggJ2Nsb3NlJywgZSA9PiB7XG4gICAgICBpZiAoICFlIHx8ICFlLnRhcmdldCB8fCAhZS50YXJnZXQudGFnICkgcmV0dXJuO1xuICAgICAgdGhpcy5fbm90aWNlcyA9IHRoaXMuX25vdGljZXMuZmlsdGVyKCBhID0+IGEudGFnICE9PSBlLnRhcmdldC50YWcgKTtcbiAgICB9KTtcbiAgICAvLyBjb252ZXJ0IHVybCBzdHJpbmcgdG8gY2xpY2thYmxlIGxpbmtcbiAgICBpZiAoIGxpbmsgJiYgdHlwZW9mIGxpbmsgPT09ICdzdHJpbmcnICkge1xuICAgICAgYS5hZGRFdmVudExpc3RlbmVyKCAnY2xpY2snLCBlID0+IHsgZS5wcmV2ZW50RGVmYXVsdCgpOyB3aW5kb3cub3BlbiggbGluaywgJ19ibGFuaycgKTsgfSApO1xuICAgIH1cbiAgICAvLyBjdXN0b20gY2xpY2sgaGFuZGxlclxuICAgIGlmICggbGluayAmJiB0eXBlb2YgbGluayA9PT0gJ2Z1bmN0aW9uJyApIHtcbiAgICAgIGEuYWRkRXZlbnRMaXN0ZW5lciggJ2NsaWNrJywgbGluayApO1xuICAgIH1cbiAgICAvLyBhZGQgdG8gdHJhY2tlclxuICAgIHRoaXMuX25vdGljZXMucHVzaCggYSApO1xuICB9XG5cbn1cbiIsIi8qKlxyXG4gKiBBcHAgT3B0aW9ucyBoZWxwZXIgY2xhc3NcclxuICovXHJcbmltcG9ydCBCdXMgZnJvbSAnLi9idXMnO1xyXG5pbXBvcnQgc3RvcmUgZnJvbSAnLi9zdG9yZSc7XHJcbmltcG9ydCB1dGlscyBmcm9tICcuL3V0aWxzJztcclxuXHJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIE9wdGlvbnMgZXh0ZW5kcyBCdXMge1xyXG5cclxuICAvKipcclxuICAgKiBDb25zdHJ1Y3RvclxyXG4gICAqL1xyXG4gIGNvbnN0cnVjdG9yKCBvcHRpb25zICkge1xyXG4gICAgc3VwZXIoKTtcclxuICAgIHRoaXMuX2tleSA9ICdhcHBfb3B0aW9uc19kYXRhJztcclxuICAgIHRoaXMuX29wdGlvbnMgPSB7fTtcclxuICAgIHRoaXMuc2V0T3B0aW9ucyggb3B0aW9ucyApO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogTG9hZHMgYW5kIHNldHMgc2F2ZWQgZGF0YSBmcm9tIHN0b3JlXHJcbiAgICovXHJcbiAgbG9hZE9wdGlvbnMoKSB7XHJcbiAgICBsZXQgb3B0aW9ucyA9IHN0b3JlLmdldERhdGEoIHRoaXMuX2tleSApO1xyXG4gICAgdGhpcy5zZXRPcHRpb25zKCBvcHRpb25zICk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBTZXQgbmV3IG9wdGlvbnMgZGF0YSBhbmQgc2F2ZSB0byBzdG9yZVxyXG4gICAqIEBwYXJhbSB7b2JqZWN0fSAgb3B0aW9ucyAgT3B0aW9ucyBvYmplY3RcclxuICAgKi9cclxuICBzYXZlT3B0aW9ucyggb3B0aW9ucyApIHtcclxuICAgIHRoaXMuc2V0T3B0aW9ucyggb3B0aW9ucyApO1xyXG4gICAgc3RvcmUuc2V0RGF0YSggdGhpcy5fa2V5LCB0aGlzLl9vcHRpb25zICk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBTZXQgbmV3IG9wdGlvbnMgZGF0YSBhbmQgZW1pdCBjaGFuZ2VzXHJcbiAgICogQHBhcmFtIHtvYmplY3R9ICBvcHRpb25zICBPcHRpb25zIG9iamVjdFxyXG4gICAqL1xyXG4gIHNldE9wdGlvbnMoIG9wdGlvbnMgKSB7XHJcbiAgICB0aGlzLl9vcHRpb25zID0gdXRpbHMuZGVlcE1lcmdlKCB7fSwgdGhpcy5fb3B0aW9ucywgb3B0aW9ucyApO1xyXG4gICAgdGhpcy5lbWl0KCAndXBkYXRlJywgdGhpcy5fb3B0aW9ucyApO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogR2V0IG9wdGlvbnMgYnkgbmFtZSwgb3IgYWxsXHJcbiAgICogQHBhcmFtIHtzdHJpbmd9ICBrZXkgIE9wdGlvbnMgb2JqZWN0IGtleVxyXG4gICAqIEBwYXJhbSB7Kn0gICAgICAgZGVmICBPcHRpb25hbCBkZWZhdWx0IHZhbHVlXHJcbiAgICovXHJcbiAgZ2V0T3B0aW9ucygga2V5LCBkZWYgKSB7XHJcbiAgICBpZiAoIGtleSAmJiB0eXBlb2Yga2V5ID09PSAnc3RyaW5nJyApIHtcclxuICAgICAgaWYgKCB0aGlzLl9vcHRpb25zLmhhc093blByb3BlcnR5KCBrZXkgKSApIHJldHVybiB0aGlzLl9vcHRpb25zWyBrZXkgXTtcclxuICAgICAgcmV0dXJuIGRlZjtcclxuICAgIH1cclxuICAgIHJldHVybiB0aGlzLl9vcHRpb25zO1xyXG4gIH1cclxuXHJcbn1cclxuIiwiLyoqXHJcbiAqIEJhc2ljIFVSTCBoYXNoIHJvdXRlclxyXG4gKi9cclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgUm91dGVyIHtcclxuXHJcbiAgLy8gY29uc3RydWN0b3JcclxuICBjb25zdHJ1Y3RvcigpIHtcclxuICAgIHRoaXMuX3JvdXRlcyA9IHt9O1xyXG4gICAgdGhpcy5faW5pdCgpO1xyXG4gIH1cclxuXHJcbiAgLy8gZ2V0IHJvdXRlcyBkYXRhXHJcbiAgZ2V0Um91dGVzKCkge1xyXG4gICAgcmV0dXJuIHRoaXMuX3JvdXRlcztcclxuICB9XHJcblxyXG4gIC8vIHNldCBhIHVybCBoYXNoIHJvdXRlXHJcbiAgc2V0Um91dGUoIHJvdXRlICkge1xyXG4gICAgcm91dGUgPSB0aGlzLl9wYXRoKCByb3V0ZSApO1xyXG4gICAgd2luZG93LmxvY2F0aW9uLmhhc2ggPSByb3V0ZTtcclxuICB9XHJcblxyXG4gIC8vIGFkZCBjdXN0b20gcm91dGUgYW5kIGNhbGxiYWNrIHRvIGxpc3RcclxuICBvbiggcm91dGUsIGNhbGxiYWNrICkge1xyXG4gICAgcm91dGUgPSB0aGlzLl9wYXRoKCByb3V0ZSApO1xyXG4gICAgaWYgKCAhcm91dGUgfHwgdHlwZW9mIGNhbGxiYWNrICE9PSAnZnVuY3Rpb24nICkgcmV0dXJuO1xyXG4gICAgdGhpcy5fcm91dGVzWyByb3V0ZSBdID0gY2FsbGJhY2s7XHJcbiAgfVxyXG5cclxuICAvLyBkZWxldGUgcm91dGUgaGFuZGxlclxyXG4gIG9mZiggcm91dGUgKSB7XHJcbiAgICByb3V0ZSA9IHRoaXMuX3BhdGgoIHJvdXRlICk7XHJcbiAgICBpZiAoIHRoaXMuX3JvdXRlcy5oYXNPd25Qcm9wZXJ0eSggcm91dGUgKSApIHtcclxuICAgICAgZGVsZXRlIHRoaXMuX3JvdXRlc1sgcm91dGUgXTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8vIHRyaWdnZXIgc2F2ZWQgaGFuZGxlciBmb3IgYSBwYXRoXHJcbiAgdHJpZ2dlciggcGF0aCApIHtcclxuICAgIHBhdGggPSB0aGlzLl9wYXRoKCBwYXRoICk7XHJcbiAgICBpZiAoICFwYXRoICkgcmV0dXJuO1xyXG5cclxuICAgIE9iamVjdC5rZXlzKCB0aGlzLl9yb3V0ZXMgKS5mb3JFYWNoKCByb3V0ZSA9PiB7XHJcbiAgICAgIGxldCBjYiA9IHRoaXMuX3JvdXRlc1sgcm91dGUgXTtcclxuXHJcbiAgICAgIC8vIHBhdGggbWF0Y2hlcyByb3V0ZSwgY2FsbCBoYW5kbGVyIGFzIGlzXHJcbiAgICAgIGlmICggcGF0aCA9PT0gcm91dGUgKSByZXR1cm4gY2IoKTtcclxuXHJcbiAgICAgIC8vIHVzZSByZWdleHAgdG8gdGVzdCByb3V0ZVxyXG4gICAgICBsZXQgcmVnID0gbmV3IFJlZ0V4cCggJ14nKyByb3V0ZSArJyQnICk7XHJcbiAgICAgIGxldCBtYXRjaGVzID0gcmVnLmV4ZWMoIHBhdGggKTtcclxuXHJcbiAgICAgIC8vIGZvdW5kIHNvbWV0aGluZywgcGFzcyByZWdleHAgbWF0Y2hlcyBhcyBhcmd1bWVudHMgdG8gaGFuZGxlclxyXG4gICAgICBpZiAoIG1hdGNoZXMgKSB7XHJcbiAgICAgICAgbWF0Y2hlcyA9IEFycmF5LmZyb20oIG1hdGNoZXMgKTtcclxuICAgICAgICBtYXRjaGVzLnNoaWZ0KCk7XHJcbiAgICAgICAgY2IuYXBwbHkoIGNiLCBtYXRjaGVzICk7XHJcbiAgICAgIH1cclxuICAgIH0pO1xyXG4gIH1cclxuXHJcbiAgLy8gY2xlYW4gcGF0aFxyXG4gIF9wYXRoKCBwYXRoICkge1xyXG4gICAgcmV0dXJuICcvJysgU3RyaW5nKCBwYXRoIHx8ICcnICkucmVwbGFjZSggL15bXFwjXFwvXSt8W1xcL10rJC9nLCAnJyApLnRyaW0oKTtcclxuICB9XHJcblxyXG4gIC8vIHN0YXJ0IHdhdGNoaW5nIGZvciBoYXNoIGNoYW5nZXNcclxuICBfaW5pdCgpIHtcclxuICAgIGNvbnN0IF93ID0gd2luZG93O1xyXG4gICAgX3cuYWRkRXZlbnRMaXN0ZW5lciggJ2hhc2hjaGFuZ2UnLCBlID0+IHsgdGhpcy50cmlnZ2VyKCBfdy5sb2NhdGlvbi5oYXNoICkgfSApO1xyXG4gICAgX3cuYWRkRXZlbnRMaXN0ZW5lciggJ2xvYWQnLCBlID0+IHsgdGhpcy50cmlnZ2VyKCBfdy5sb2NhdGlvbi5oYXNoICkgfSApO1xyXG4gIH1cclxufVxyXG4iLCIvKipcclxuICogU2Nyb2xsZXIgQ2xhc3MuXHJcbiAqIEZvciBjYWxsaW5nIGN1c3RvbSBmdW5jdGlvbiBiYXNlZCBvbiBzY3JvbGwgcG9zaXRpb24sIG9yIHRvIGF1dG8tc2Nyb2xsLlxyXG4gKi9cclxuaW1wb3J0IEJ1cyBmcm9tICcuL2J1cyc7XHJcblxyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBTY3JvbGxlciBleHRlbmRzIEJ1cyB7XHJcblxyXG4gIC8qKlxyXG4gICAqIENvbnN0cnVjdG9yXHJcbiAgICovXHJcbiAgY29uc3RydWN0b3IoIHRhcmdldCApIHtcclxuICAgIHN1cGVyKCk7XHJcbiAgICB0aGlzLl90ZGVmICAgICAgPSBkb2N1bWVudC5zY3JvbGxpbmdFbGVtZW50IHx8IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudCB8fCB3aW5kb3c7XHJcbiAgICB0aGlzLl90YXJnZXQgICAgPSAoIHRhcmdldCBpbnN0YW5jZW9mIEVsZW1lbnQgKSA/IHRhcmdldCA6IHRoaXMuX3RkZWY7XHJcbiAgICB0aGlzLl9zY3JvbGxpbmcgPSBmYWxzZTtcclxuICAgIHRoaXMuX3BvcyAgICAgICA9IDA7XHJcbiAgICB0aGlzLl90byAgICAgICAgPSAwO1xyXG4gICAgdGhpcy5fbWluICAgICAgID0gMDtcclxuICAgIHRoaXMuX21heCAgICAgICA9IDA7XHJcbiAgICB0aGlzLl9lYXNlICAgICAgPSAxMDtcclxuICAgIHRoaXMuX3RyaWdnZXJzICA9IFtdO1xyXG4gICAgdGhpcy5fb25TY3JvbGwgID0gdGhpcy5fb25TY3JvbGwuYmluZCggdGhpcyApO1xyXG4gICAgdGhpcy5hZGRUcmlnZ2VyKCAndXAnICk7XHJcbiAgICB0aGlzLmFkZFRyaWdnZXIoICdkb3duJyApO1xyXG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoICdzY3JvbGwnLCB0aGlzLl9vblNjcm9sbCApO1xyXG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoICdyZXNpemUnLCB0aGlzLl9vblNjcm9sbCApO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQWRkIGN1c3RvbSBzY3JvbGwgdHJpZ2dlclxyXG4gICAqIEBwYXJhbSB7c3RyaW5nfSAgICBuYW1lICAgVHJpZ2dlciBuYW1lXHJcbiAgICogQHBhcmFtIHtudW1iZXJ9ICAgIHBvcyAgICBUcmlnZ2VyIHNjcm9sbCBwb3NpdGlvblxyXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb259ICBjYiAgICAgT3B0aW9uYWwgY2FsbGJhY2sgaGFuZGxlclxyXG4gICAqIEBwYXJhbSB7b2JqZWN0fSAgICBkYXRhXHJcbiAgICovXHJcbiAgYWRkVHJpZ2dlciggbmFtZSwgcG9zLCBjYiwgZGF0YSApIHtcclxuICAgIGxldCB0cmlnZ2VyICA9IFN0cmluZyggbmFtZSB8fCAnJyApLnRyaW0oKS50b0xvd2VyQ2FzZSgpO1xyXG4gICAgbGV0IHBvc2l0aW9uID0gcGFyc2VGbG9hdCggcG9zICkgfHwgMDtcclxuICAgIGxldCBjYWxsYmFjayA9ICggdHlwZW9mIGNiID09PSAnZnVuY3Rpb24nICkgPyBjYiA6IGZ1bmN0aW9uKCkge307XHJcbiAgICBsZXQgY2FsbGVkICAgPSBmYWxzZTtcclxuICAgIGlmICggIXRyaWdnZXIgKSByZXR1cm47XHJcbiAgICB0aGlzLl90cmlnZ2Vycy5wdXNoKCBPYmplY3QuYXNzaWduKCB7IHRyaWdnZXIsIHBvc2l0aW9uLCBjYWxsZWQgfSwgZGF0YSApICk7XHJcbiAgICB0aGlzLm9uKCB0cmlnZ2VyLCBjYWxsYmFjayApO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogUmVzZXQgdHJpZ2dlcnMgY2FsbGVkIHN0YXRlIHRvIGZhbHNlXHJcbiAgICovXHJcbiAgcmVzZXRUcmlnZ2VycygpIHtcclxuICAgIHRoaXMuX3RyaWdnZXJzLmZvckVhY2goIHQgPT4geyBjYWxsZWQgPSBmYWxzZSB9ICk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBXaGVuIGVsZW1lbnRzIGVudGVyIGFuZCBsZWF2ZSB0aGUgdmlld3BvcnQgYXJlYVxyXG4gICAqIEBwYXJhbSB7Kn0gICAgICAgICB0YXJnZXRzICAgQ1NTIHNlbGVjdG9yLCBvciBhcnJheSBsaXN0IG9mIHRhcmdldCBlbGVtZW50c1xyXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb259ICBjYWxsYmFjayAgQ2FsbGJhY2sgZnVuY3Rpb25cclxuICAgKi9cclxuICBvblZpc2libGUoIHRhcmdldHMsIGNhbGxiYWNrICkge1xyXG4gICAgbGV0IGVsbXMgPSB0aGlzLl9nZXRFbG1MaXN0KCB0YXJnZXRzICk7XHJcbiAgICBsZXQgZW1hcCA9IG5ldyBBcnJheSggZWxtcy5sZW5ndGggKS5maWxsKCBmYWxzZSApO1xyXG4gICAgdGhpcy5hZGRUcmlnZ2VyKCAncmV2ZWFsJywgMCwgY2FsbGJhY2ssIHsgZWxtcywgZW1hcCB9ICk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBBdXRvIHNjcm9sbCBwYWdlIHRvIGEgdGFyZ2V0IGRlc3RpbmF0aW9uXHJcbiAgICogQHBhcmFtIHsqfSAgZGVzdCAgICAgIFN0cmluZyBzZWxlY3RvciwgbnVtYmVyIG9yIGVsZW1lbnRcclxuICAgKiBAcGFyYW0geyp9ICBjYWxsYmFjayAgQ2FsbGJhY2sgZnVuY3Rpb25cclxuICAgKi9cclxuICBqdW1wVG8oIGRlc3QsIGNhbGxiYWNrICkge1xyXG4gICAgY29uc3Qgc2Nyb2xsSGVpZ2h0ID0gTWF0aC5tYXgoIDAsIE1hdGguZmxvb3IoIHRoaXMuX3RhcmdldC5zY3JvbGxIZWlnaHQgfHwgMCApICk7XHJcbiAgICBjb25zdCBjbGllbnRIZWlnaHQgPSBNYXRoLm1heCggMCwgTWF0aC5mbG9vciggdGhpcy5fdGFyZ2V0LmNsaWVudEhlaWdodCB8fCAwICkgKTtcclxuXHJcbiAgICB0aGlzLl9tYXggPSBNYXRoLmZsb29yKCBzY3JvbGxIZWlnaHQgLSBjbGllbnRIZWlnaHQgKTtcclxuICAgIHRoaXMuX3BvcyA9IHRoaXMuX3RhcmdldC5zY3JvbGxUb3AgfHwgMDtcclxuICAgIHRoaXMuX3RvICA9IHRoaXMuX3BvcztcclxuXHJcbiAgICBpZiAoIHR5cGVvZiBkZXN0ID09PSAnbnVtYmVyJyApIHtcclxuICAgICAgdGhpcy5fdG8gPSBkZXN0O1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAoIHR5cGVvZiBkZXN0ID09PSAnb2JqZWN0JyAmJiBkZXN0IGluc3RhbmNlb2YgRWxlbWVudCApIHtcclxuICAgICAgdGhpcy5fdG8gPSAoIHRoaXMuX3BvcyArIGRlc3QuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkudG9wICkgfHwgdGhpcy5fcG9zO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAoIHR5cGVvZiBkZXN0ID09PSAnc3RyaW5nJyApIHtcclxuICAgICAgaWYgKCAvXih1cHx0b3ApJC9pLnRlc3QoIGRlc3QgKSApIHsgdGhpcy5fdG8gPSB0aGlzLl9taW47IH0gZWxzZVxyXG4gICAgICBpZiAoIC9eKG1pZGRsZXxjZW50ZXIpJC9pLnRlc3QoIGRlc3QgKSApIHsgdGhpcy5fdG8gPSB0aGlzLl9tYXggLyAyOyB9IGVsc2VcclxuICAgICAgaWYgKCAvXihkb3dufGJvdHRvbSkkL2kudGVzdCggZGVzdCApICkgeyB0aGlzLl90byA9IHRoaXMuX21heDsgfSBlbHNlXHJcbiAgICAgIGlmICggL14oWzAtOV0rKSQvLnRlc3QoIGRlc3QgKSApIHsgdGhpcy5fdG8gPSBwYXJzZUludCggZGVzdCApOyB9XHJcbiAgICAgIGVsc2Uge1xyXG4gICAgICAgIGxldCBub2RlID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvciggZGVzdCApO1xyXG4gICAgICAgIHRoaXMuX3RvID0gbm9kZSA/ICggdGhpcy5fcG9zICsgbm9kZS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS50b3AgKSA6IHRoaXMuX3BvcztcclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgdGhpcy5fdG8gPSBNYXRoLm1heCggdGhpcy5fbWluLCBNYXRoLm1pbiggdGhpcy5fdG8sIHRoaXMuX21heCApICk7XHJcbiAgICB0aGlzLl9qdW1wTG9vcCggY2FsbGJhY2sgKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEF1dG9zY3JvbGwgYW5pbWF0aW9uIGxvb3BcclxuICAgKi9cclxuICBfanVtcExvb3AoIGNiICkge1xyXG4gICAgaWYgKCBNYXRoLmFicyggdGhpcy5fdG8gLSB0aGlzLl9wb3MgKSA8IDEgKSB7XHJcbiAgICAgIHRoaXMuX3Njcm9sbGluZyA9IGZhbHNlO1xyXG4gICAgICB0aGlzLl90YXJnZXQuc2Nyb2xsVG9wID0gdGhpcy5fdG87XHJcbiAgICAgIHRoaXMuX29uU2Nyb2xsVGljaygpO1xyXG4gICAgICBpZiAoIHR5cGVvZiBjYiA9PT0gJ2Z1bmN0aW9uJyApIGNiKCB0aGlzLl90byApO1xyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcbiAgICB0aGlzLl9zY3JvbGxpbmcgPSB0cnVlO1xyXG4gICAgdGhpcy5fcG9zICs9ICggdGhpcy5fdG8gLSB0aGlzLl9wb3MgKSAvIHRoaXMuX2Vhc2U7XHJcbiAgICB0aGlzLl90YXJnZXQuc2Nyb2xsVG9wID0gdGhpcy5fcG9zO1xyXG4gICAgd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZSggKCkgPT4geyB0aGlzLl9qdW1wTG9vcCggY2IgKSB9ICk7XHJcbiAgfVxyXG5cclxuICAvLyBjaGVjayBzY3JvbGwgYmVoYXZpb3JcclxuICBfb25TY3JvbGxUaWNrKCkge1xyXG4gICAgbGV0IHNwID0gdGhpcy5fdGFyZ2V0LnNjcm9sbFRvcCB8IDA7XHJcbiAgICB0aGlzLmVtaXQoICdzY3JvbGwnLCBzcCApO1xyXG5cclxuICAgIGZvciAoIGxldCBpID0gMDsgaSA8IHRoaXMuX3RyaWdnZXJzLmxlbmd0aDsgKytpICkge1xyXG4gICAgICBsZXQgdCA9IHRoaXMuX3RyaWdnZXJzWyBpIF07XHJcblxyXG4gICAgICBpZiAoIHQudHJpZ2dlciA9PT0gJ3VwJyApIHtcclxuICAgICAgICBsZXQgY2hlY2sgPSAoIHNwIDwgdGhpcy5fcG9zICk7XHJcbiAgICAgICAgaWYgKCAhdC5jYWxsZWQgJiYgY2hlY2sgKSB0aGlzLmVtaXQoIHQudHJpZ2dlciwgc3AgKTtcclxuICAgICAgICB0LmNhbGxlZCA9IGNoZWNrO1xyXG4gICAgICB9XHJcbiAgICAgIGlmICggdC50cmlnZ2VyID09PSAnZG93bicgKSB7XHJcbiAgICAgICAgbGV0IGNoZWNrID0gKCBzcCA+IHRoaXMuX3BvcyApO1xyXG4gICAgICAgIGlmICggIXQuY2FsbGVkICYmIGNoZWNrICkgdGhpcy5lbWl0KCB0LnRyaWdnZXIsIHNwICk7XHJcbiAgICAgICAgdC5jYWxsZWQgPSBjaGVjaztcclxuICAgICAgfVxyXG4gICAgICBpZiAoIHQudHJpZ2dlciA9PT0gJ21vcmUnICkge1xyXG4gICAgICAgIGxldCBjaGVjayA9ICggc3AgPiB0LnBvc2l0aW9uICk7XHJcbiAgICAgICAgaWYgKCAhdC5jYWxsZWQgJiYgY2hlY2sgKSB0aGlzLmVtaXQoIHQudHJpZ2dlciwgc3AgKTtcclxuICAgICAgICB0LmNhbGxlZCA9IGNoZWNrO1xyXG4gICAgICB9XHJcbiAgICAgIGlmICggdC50cmlnZ2VyID09PSAnbGVzcycgKSB7XHJcbiAgICAgICAgbGV0IGNoZWNrID0gKCBzcCA8IHQucG9zaXRpb24gKTtcclxuICAgICAgICBpZiAoICF0LmNhbGxlZCAmJiBjaGVjayApIHRoaXMuZW1pdCggdC50cmlnZ2VyLCBzcCApO1xyXG4gICAgICAgIHQuY2FsbGVkID0gY2hlY2s7XHJcbiAgICAgIH1cclxuICAgICAgaWYgKCB0LnRyaWdnZXIgPT09ICdyZXZlYWwnICYmIHQuZWxtcyApIHtcclxuICAgICAgICBmb3IgKCBsZXQgaSA9IDA7IGkgPCB0LmVsbXMubGVuZ3RoOyArK2kgKSB7XHJcbiAgICAgICAgICBsZXQgZSA9IHQuZWxtc1sgaSBdO1xyXG4gICAgICAgICAgbGV0IGMgPSB0LmVtYXBbIGkgXTtcclxuICAgICAgICAgIGxldCB2ID0gdGhpcy5fY2hlY2tWaXNpYmxlKCBlICk7XHJcbiAgICAgICAgICBpZiAoICFjICYmIHYgKSB0aGlzLmVtaXQoICdzaG93JywgZSwgc3AgKTsgLy8gZW50ZXJpbmdcclxuICAgICAgICAgIGlmICggYyAmJiAhdiApIHRoaXMuZW1pdCggJ2hpZGUnLCBlLCBzcCApOyAvLyBsZWF2aW5nXHJcbiAgICAgICAgICB0LmVtYXBbIGkgXSA9IHY7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgICB0aGlzLl9wb3MgPSBzcDtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIENoZWNrcyBpZiBhbiBlbGVtZW50IGlzIHZpc2libGUgd2l0aGluIHRoZSBoZWlnaHQgb2YgdGhlIHNjcm9sbCB3aW5kb3dcclxuICAgKiBAcGFyYW0ge2VsZW1lbnR9IGVsbSAgRWxlbWVudCBvYmplY3RcclxuICAgKi9cclxuICBfY2hlY2tWaXNpYmxlKCBlbG0gKSB7XHJcbiAgICBsZXQgaGVpZ2h0ID0gdGhpcy5fdGFyZ2V0LmNsaWVudEhlaWdodCB8IDA7XHJcbiAgICBsZXQgYm94ICAgID0gZWxtLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xyXG4gICAgbGV0IHlQb3MgICA9IGJveC50b3AgKyAoIGJveC5oZWlnaHQgLyAyICk7IC8vIGVsbSBtaWRkbGVcclxuICAgIHJldHVybiAoIHlQb3MgPj0gMCAmJiB5UG9zIDw9IGhlaWdodCApO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogSGFuZGxlciBmb3IgbmF0aXZlIHNjcm9sbCBldmVudFxyXG4gICAqIEBwYXJhbSB7b2JqZWN0fSAgZSAgRXZlbnQgb2JqZWN0XHJcbiAgICovXHJcbiAgX29uU2Nyb2xsKCBlICkge1xyXG4gICAgaWYgKCB0aGlzLl9zY3JvbGxpbmcgKSByZXR1cm47XHJcbiAgICB0aGlzLl9zY3JvbGxpbmcgPSB0cnVlO1xyXG4gICAgd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZSggKCkgPT4ge1xyXG4gICAgICB0aGlzLl9vblNjcm9sbFRpY2soKTtcclxuICAgICAgdGhpcy5fc2Nyb2xsaW5nID0gZmFsc2U7XHJcbiAgICB9KTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFJlc29sdmUgbGlzdCBvZiBlbGVtZW50cyBmcm9tIGFuIGFyZ1xyXG4gICAqIEBwYXJhbSB7Kn0gIGVsbXMgIFN0cmluZyBzZWxlY3Rvciwgbm9kZWxpc3Qgb3IgYXJyYXlcclxuICAgKi9cclxuICBfZ2V0RWxtTGlzdCggZWxtcyApIHtcclxuICAgIGlmICggdHlwZW9mIGVsbXMgPT09ICdzdHJpbmcnICkgcmV0dXJuIGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoIGVsbXMgKTtcclxuICAgIGlmICggQXJyYXkuaXNBcnJheSggZWxtcyApIHx8IGVsbXMgaW5zdGFuY2VvZiBOb2RlTGlzdCApIHJldHVybiBlbG1zO1xyXG4gICAgaWYgKCBlbG1zIGluc3RhbmNlb2YgRWxlbWVudCApIHJldHVybiBbIGVsbXMgXTtcclxuICAgIHJldHVybiBbXTtcclxuICB9XHJcbn1cclxuIiwiLyoqXHJcbiAqIEJhc2ljIHNlbnRpbWVudCBhbmFseXNpcyBtb2R1bGVcclxuICovXHJcbmV4cG9ydCBkZWZhdWx0IHtcclxuXHJcbiAgLy8gc2NvcmUgbGlzdCBkYXRhXHJcbiAgX2FmaW5uOiB7fSxcclxuXHJcbiAgLy8gd29yZHMgdGhhdCBuZWdhdGUgdGhlIHNjb3JlIG9mIGEgZm9sbG93aW5nIHdvcmRcclxuICBfbmVnYXRvcnM6IFtcclxuICAgIFwiY2FudFwiLFxyXG4gICAgXCJjYW4ndFwiLFxyXG4gICAgXCJkb250XCIsXHJcbiAgICBcImRvbid0XCIsXHJcbiAgICBcImRvZXNudFwiLFxyXG4gICAgXCJkb2Vzbid0XCIsXHJcbiAgICBcIm5vdFwiLFxyXG4gICAgXCJub25cIixcclxuICAgIFwid29udFwiLFxyXG4gICAgXCJ3b24ndFwiLFxyXG4gICAgXCJpc250XCIsXHJcbiAgICBcImlzbid0XCIsXHJcbiAgICBcIndvdWxkbnRcIixcclxuICAgIFwid291bGRuJ3RcIixcclxuICAgIFwiY291bGRudFwiLFxyXG4gICAgXCJjb3VsZG4ndFwiLFxyXG4gICAgXCJkaWRudFwiLFxyXG4gICAgXCJkaWRuJ3RcIixcclxuICAgIFwid2FzbnRcIixcclxuICAgIFwid2Fzbid0XCIsXHJcbiAgICBcImhhdmVudFwiLFxyXG4gICAgXCJoYXZlbid0XCIsXHJcbiAgICBcImFpbid0XCIsXHJcbiAgICBcImFpbnRcIixcclxuICAgIFwid2VyZW50XCIsXHJcbiAgICBcIndlcmVuJ3RcIixcclxuICBdLFxyXG5cclxuICAvLyBidWlsZCBhZmlubiB3b3JkbGlzdFxyXG4gIG1lcmdlKCBsaXN0ICkge1xyXG4gICAgdGhpcy5fYWZpbm4gPSBPYmplY3QuYXNzaWduKCB0aGlzLl9hZmlubiwgbGlzdCApO1xyXG4gIH0sXHJcblxyXG4gIC8vIGFuYWx5c2Ugc2VudGltZW50IGZvciB0ZXh0XHJcbiAgYW5hbHl6ZSggdGV4dCApIHtcclxuICAgIGxldCBzY29yZSA9IDA7XHJcbiAgICBsZXQgbmVnYXRpdmUgPSAwO1xyXG4gICAgbGV0IHBvc2l0aXZlID0gMDtcclxuICAgIGxldCBjb21wYXJhdGl2ZSA9IDA7XHJcbiAgICBsZXQgbGlzdCA9IHRoaXMuX3NwbGl0V29yZHMoIHRleHQgKTtcclxuICAgIGxldCB0b3RhbCA9IGxpc3QubGVuZ3RoO1xyXG4gICAgbGV0IGkgPSB0b3RhbDtcclxuXHJcbiAgICAvLyBsb29wIGZpbHRlcmVkIGlucHV0IHdvcmRzXHJcbiAgICB3aGlsZSAoIGktLSApIHtcclxuICAgICAgaWYgKCAhdGhpcy5fYWZpbm4uaGFzT3duUHJvcGVydHkoIGxpc3RbIGkgXSApICkgY29udGludWU7IC8vIG5vdCBmb3VuZFxyXG5cclxuICAgICAgbGV0IHcgPSBsaXN0WyBpIF07IC8vIGN1cnJlbnQgd29yZFxyXG4gICAgICBsZXQgcCA9ICggaSA+IDAgKSA/IGxpc3RbIGkgLSAxIF0gOiAnJzsgLy8gcHJldmlvdXMgd29yZFxyXG4gICAgICBsZXQgcyA9IHBhcnNlRmxvYXQoIHRoaXMuX2FmaW5uWyB3IF0gKSB8IDA7IC8vIHdvcmQgc2NvcmVcclxuXHJcbiAgICAgIGlmICggIXAgfHwgIXMgKSBjb250aW51ZTsgLy8gbm8gc2NvcmVcclxuICAgICAgaWYgKCB0aGlzLl9uZWdhdG9ycy5pbmRleE9mKCBwICkgPj0gMCApIHMgKj0gLTE7IC8vIGZsaXAgc2NvcmVcclxuICAgICAgaWYgKCBzID4gMCApIHBvc2l0aXZlICs9IHM7XHJcbiAgICAgIGlmICggcyA8IDAgKSBuZWdhdGl2ZSArPSBzO1xyXG4gICAgICBzY29yZSArPSBzO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIHNlbnRpbWVudCBzdHJpbmcgcGFyYW1zXHJcbiAgICBsZXQgcGFyYW1zICAgICAgICAgICAgICAgICA9IFsgJycsICAnTmV1dHJhbCcsICAnaWNvbi1oZWxwIGljb25MZWZ0IHRleHQtaW5mbycgXTtcclxuICAgIC8vIHBvc2l0aXZlXHJcbiAgICBpZiAoIHNjb3JlID09PSAgMSApIHBhcmFtcyA9IFsgJysnLCAnT2snLCAgICAgICAnaWNvbi1oZWxwIGljb25MZWZ0IHRleHQtc3VjY2VzcycgXTtcclxuICAgIGlmICggc2NvcmUgPiAgICAxICkgcGFyYW1zID0gWyAnKycsICdQb3NpdGl2ZScsICdpY29uLWxpa2UgaWNvbkxlZnQgdGV4dC1zdWNjZXNzJyBdO1xyXG4gICAgaWYgKCBzY29yZSA+ICAgMTAgKSBwYXJhbXMgPSBbICcrJywgJ1Bvc2l0aXZlJywgJ2ljb24tbGlrZSBpY29uTGVmdCB0ZXh0LWdhaW4nIF07XHJcbiAgICAvLyBuZWdhdGl2ZVxyXG4gICAgaWYgKCBzY29yZSA9PT0gLTEgKSBwYXJhbXMgPSBbICctJywgJ09rJywgICAgICAgJ2ljb24taGVscCBpY29uTGVmdCB0ZXh0LWRhbmdlcicgXTtcclxuICAgIGlmICggc2NvcmUgPCAgIC0xICkgcGFyYW1zID0gWyAnLScsICdOZWdhdGl2ZScsICdpY29uLWRpc2xpa2UgaWNvbkxlZnQgdGV4dC1kYW5nZXInIF07XHJcbiAgICBpZiAoIHNjb3JlIDwgIC0xMCApIHBhcmFtcyA9IFsgJy0nLCAnTmVnYXRpdmUnLCAnaWNvbi1kaXNsaWtlIGljb25MZWZ0IHRleHQtbG9zcycgXTtcclxuXHJcbiAgICAvLyBidWlsZCBzZW50aW1lbnQgaW5mb1xyXG4gICAgbGV0IFsgc2lnbiwgd29yZCwgc3R5bGVzIF0gPSBwYXJhbXM7XHJcbiAgICBsZXQgc2VudGltZW50ID0gWyB3b3JkLCBzaWduICsgTWF0aC5hYnMoIHNjb3JlICkgXS5qb2luKCAnICcgKTtcclxuXHJcbiAgICAvLyBidWlsZCBmaW5hbCBkYXRhXHJcbiAgICBjb21wYXJhdGl2ZSA9IHRvdGFsID8gKCBzY29yZSAvIHRvdGFsICkgOiAwO1xyXG4gICAgcmV0dXJuIHsgc2NvcmUsIHBvc2l0aXZlLCBuZWdhdGl2ZSwgY29tcGFyYXRpdmUsIHNpZ24sIHdvcmQsIHN0eWxlcywgc2VudGltZW50IH07XHJcbiAgfSxcclxuXHJcbiAgLy8gZmlsdGVyIGlucHV0IHRleHQgaW50byB3b3JkIGxpc3RcclxuICBfc3BsaXRXb3JkcyggaW5wdXQgKSB7XHJcbiAgICBsZXQgZGl2ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCggJ2RpdicgKTtcclxuICAgIGRpdi5pbm5lckhUTUwgPSBTdHJpbmcoIGlucHV0IHx8ICcnICk7XHJcblxyXG4gICAgLy8gc3RyaXAgaHRtbFxyXG4gICAgbGV0IG91dHB1dCA9IFN0cmluZyggZGl2LnRleHRDb250ZW50IHx8IGRpdi5pbm5lclRleHQgfHwgJycgKVxyXG4gICAgLnRvTG93ZXJDYXNlKClcclxuICAgIC50cmltKCk7XHJcblxyXG4gICAgLy8gY2xlYW4gc3RyaW5nXHJcbiAgICBvdXRwdXQgPSBvdXRwdXRcclxuICAgIC5yZXBsYWNlKCAvKFtcXGBcXCdcXOKAmV0rKS9nLCBcIidcIiApIC8vIG5vcm1hbGl6ZSBhcG9zdHJvcGhlc1xyXG4gICAgLnJlcGxhY2UoIC8oW1xc4oCcXFzigJ1cXOKAnFxc4oCdXFxcIl0rKS9nLCAnXCInICkgLy8gbm9ybWFsaXplIHF1b3Rlc1xyXG4gICAgLnJlcGxhY2UoIC8oW1xcLV0rKS9nLCAnLScgKSAvLyBub3JtYWxpemUgZGFzaGVzXHJcbiAgICAucmVwbGFjZSggLyhbXmEtelxcJ1xcLV0rKS9nLCAnICcgKSAvLyBvbmx5IGFsbG93IHRoZXNlXHJcbiAgICAucmVwbGFjZSggL1tcXHRcXHJcXG5cXHNcXHVGRUZGXFx4QTBdKy9nLCAnICcgKSAvLyByZW1vdmUgd2hpdGVzcGFjZVxyXG4gICAgLnRyaW0oKTtcclxuXHJcbiAgICAvLyBzcGxpdFxyXG4gICAgcmV0dXJuIG91dHB1dC5zcGxpdCggL1xccysvZyApO1xyXG4gIH0sXHJcbn07XHJcbiIsIi8qKlxyXG4gKiBIZWxwZXIgbW9kdWxlIGZvciBzb3J0aW5nIGxpc3RzXHJcbiAqL1xyXG5pbXBvcnQgQnVzIGZyb20gJy4vYnVzJztcclxuaW1wb3J0IHN0b3JlIGZyb20gJy4vc3RvcmUnO1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgU29ydGVyIGV4dGVuZHMgQnVzIHtcclxuXHJcbiAgLyoqXHJcbiAgICogQ29uc3RydWN0b3JcclxuICAgKi9cclxuICBjb25zdHJ1Y3RvciggdGFyZ2V0ICkge1xyXG4gICAgc3VwZXIoKTtcclxuICAgIHRoaXMuX2tleSA9ICdsaXN0X3NvcnRfZGF0YSc7XHJcbiAgICB0aGlzLl9saXN0cyA9IHt9O1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogU2F2ZSBzb3J0IGRhdGEgdG8gc3RvcmVcclxuICAgKi9cclxuICBzYXZlRGF0YSgpIHtcclxuICAgIHN0b3JlLnNldERhdGEoIHRoaXMuX2tleSwgdGhpcy5fbGlzdHMgKTtcclxuICAgIHRoaXMuZW1pdCggJ3NhdmUnLCB0aGlzLl9saXN0cyApO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogTG9hZCBzb3J0IGRhdGEgZnJvbSBzdG9yZVxyXG4gICAqL1xyXG4gIGxvYWREYXRhKCkge1xyXG4gICAgbGV0IGRhdGEgPSBzdG9yZS5nZXREYXRhKCB0aGlzLl9rZXkgKTtcclxuICAgIHRoaXMuX2xpc3RzID0gZGF0YSB8fCB0aGlzLl9saXN0cztcclxuICAgIHRoaXMuZW1pdCggJ2xvYWQnLCB0aGlzLl9saXN0cyApO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogIEdldCBhbGwgc29ydCBkYXRhXHJcbiAgICovXHJcbiAgZ2V0RGF0YSgpIHtcclxuICAgIHJldHVybiB0aGlzLl9saXN0cztcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFNldCBzb3J0IGRhdGEgZm9yIGEga2V5XHJcbiAgICovXHJcbiAgc2V0S2V5KCBrZXksIGNvbHVtbiwgb3JkZXIsIHNlYXJjaCApIHtcclxuICAgIGNvbHVtbiA9IFN0cmluZyggY29sdW1uIHx8ICdpZCcgKTtcclxuICAgIG9yZGVyICA9IFN0cmluZyggb3JkZXIgfHwgJ2FzYycgKTtcclxuICAgIHNlYXJjaCA9IFN0cmluZyggc2VhcmNoIHx8ICcnICk7XHJcbiAgICB0aGlzLl9saXN0c1sga2V5IF0gPSB7IGNvbHVtbiwgb3JkZXIsIHNlYXJjaCB9O1xyXG4gICAgcmV0dXJuIHRoaXMuX2xpc3RzWyBrZXkgXTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEdldCBzb3J0IGRhdGEgZm9yIGEga2V5XHJcbiAgICovXHJcbiAgZ2V0S2V5KCBrZXkgKSB7XHJcbiAgICByZXR1cm4gdGhpcy5fbGlzdHNbIGtleSBdIHx8IG51bGw7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBTZXQgbmV3IHNvcnQgb3JkZXIgZm9yIGEga2V5XHJcbiAgICovXHJcbiAgc29ydE9yZGVyKCBrZXksIGNvbHVtbiwgb3JkZXIgKSB7XHJcbiAgICBsZXQgZCA9IHRoaXMuX2xpc3RzWyBrZXkgXSB8fCBudWxsO1xyXG4gICAgaWYgKCBkICkge1xyXG4gICAgICBpZiAoIGNvbHVtbiAhPT0gZC5jb2x1bW4gKSB7IGQub3JkZXIgPSBvcmRlciB8fCAnYXNjJzsgfVxyXG4gICAgICBlbHNlIHsgZC5vcmRlciA9ICggZC5vcmRlciA9PT0gJ2FzYycgKSA/ICdkZXNjJyA6ICdhc2MnOyB9XHJcbiAgICAgIGQuY29sdW1uID0gY29sdW1uO1xyXG4gICAgfVxyXG4gICAgdGhpcy5lbWl0KCAnY2hhbmdlJywgdGhpcy5fbGlzdHMgKTtcclxuICAgIHRoaXMuc2F2ZURhdGEoKTtcclxuICAgIHJldHVybiBkO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQXBwbHkgc2VhcmNoIHRleHQgZm9yIGEga2V5XHJcbiAgICovXHJcbiAgc2V0U2VhcmNoKCBrZXksIHRleHQgKSB7XHJcbiAgICBsZXQgZCA9IHRoaXMuX2xpc3RzWyBrZXkgXSB8fCBudWxsO1xyXG4gICAgaWYgKCBkICkgZC5zZWFyY2ggPSBTdHJpbmcoIHRleHQgfHwgJycgKS50cmltKCk7XHJcbiAgICB0aGlzLmVtaXQoICdjaGFuZ2UnLCB0aGlzLl9saXN0cyApO1xyXG4gICAgcmV0dXJuIGQ7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBDaGVjayBpZiBzb3J0IGNvbHVtbiBpcyBhY3RpdmUgZm9yIGEga2V5XHJcbiAgICovXHJcbiAgY2hlY2tBY3RpdmUoIGtleSwgY29sdW1uICkge1xyXG4gICAgbGV0IGQgPSB0aGlzLl9saXN0c1sga2V5IF0gfHwgbnVsbDtcclxuICAgIGlmICggZCApIHJldHVybiAoIGQuY29sdW1uID09PSBjb2x1bW4gKTtcclxuICAgIHJldHVybiBmYWxzZTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEdldCBjc3MgaWNvbiBzdHlsZSBmb3IgYSBrZXlcclxuICAgKi9cclxuICBnZXRTdHlsZXMoIGtleSwgY29sdW1uICkge1xyXG4gICAgbGV0IGQgPSB0aGlzLl9saXN0c1sga2V5IF0gfHwgbnVsbDtcclxuICAgIGxldCBjID0gY29sdW1uIHx8IGQuY29sdW1uO1xyXG4gICAgaWYgKCBkICYmIGMgPT09IGQuY29sdW1uICYmIGQub3JkZXIgPT09ICdhc2MnICkgcmV0dXJuICdpY29uLXVwJztcclxuICAgIGlmICggZCAmJiBjID09PSBkLmNvbHVtbiAmJiBkLm9yZGVyID09PSAnZGVzYycgKSByZXR1cm4gJ2ljb24tZG93bic7XHJcbiAgICByZXR1cm4gJ2hpZGRlbic7XHJcbiAgfVxyXG5cclxufVxyXG4iLCIvKipcclxuICogV2ViIGNhY2hlIGhhbmRsZXJcclxuICovXHJcblxyXG5leHBvcnQgZGVmYXVsdCB7XHJcblxyXG4gIC8vIGxvY2FsIHByb3BzXHJcbiAgX2FwaSAgICA6ICdsb2NhbFN0b3JhZ2UnLFxyXG4gIF9wcmVmaXggOiAnd2ViY2FjaGVfJyxcclxuICBfdHRsICAgIDogMCxcclxuXHJcbiAgLy8gc2F2ZSBkYXRhIHRvIGNhY2hlXHJcbiAgc2V0RGF0YSgga2V5LCBkYXRhLCB0aW1lICkge1xyXG4gICAgcmV0dXJuIHRoaXMuX3NhdmUoIGtleSwgZGF0YSwgdGltZSApO1xyXG4gIH0sXHJcblxyXG4gIC8vIGdldCBzYXZlZCBkYXRhIGZvciBhIGtleSBhcyBpc1xyXG4gIGdldERhdGEoIGtleSApIHtcclxuICAgIHRoaXMuX2NsZWFuKCk7XHJcbiAgICByZXR1cm4gdGhpcy5fZmV0Y2goIGtleSApO1xyXG4gIH0sXHJcblxyXG4gIC8vIGRlbGV0ZSBzYXZlZCBkYXRhIGZvciBrZXlcclxuICBkZWxldGVEYXRhKCBrZXkgKSB7XHJcbiAgICByZXR1cm4gdGhpcy5fZGVsZXRlKCBrZXkgKTtcclxuICB9LFxyXG5cclxuICAvLyBzYW50aXplciBmb3Iga2V5c1xyXG4gIF9rZXkoIGtleSApIHtcclxuICAgIHJldHVybiB0aGlzLl9wcmVmaXggKyBTdHJpbmcoIGtleSB8fCAnJyApLnJlcGxhY2UoIC9bXlxcd10rL2csICdfJyApO1xyXG4gIH0sXHJcblxyXG4gIC8vIGVycm9yIGhhbmRsZXJcclxuICBfZXJyb3IoIGUgKSB7XHJcbiAgICBsZXQgX2NvZGUgPSBlLmNvZGUgICAgfCAgMDtcclxuICAgIGxldCBfbmFtZSA9IGUubmFtZSAgICB8fCAnVW5rbm93bkVycm9yJztcclxuICAgIGxldCBfaW5mbyA9IGUubWVzc2FnZSB8fCAnUHJvYmxlbSB3aXRoICcgKyB0aGlzLl9hcGkgKycgYnJvd3NlciBBUEkuJyA7XHJcbiAgICBjb25zb2xlLmVycm9yKCAnU3RvcmFnZUVycm9yICgnKyBfY29kZSArJyk6JywgX2luZm8sICcoJysgX25hbWUgKycpLicgKTtcclxuICAgIHJldHVybiBmYWxzZTtcclxuICB9LFxyXG5cclxuICAvLyB0cnkgc2F2aW5nIHRoZSBkYXRhIGFuZCBoYW5kbGUgYW55IGVycm9yc1xyXG4gIF9zYXZlKCBrZXksIGRhdGEsIHR0bCApIHtcclxuICAgIHRyeSB7XHJcbiAgICAgIGNvbnN0IF9zdG9yZSAgPSB3aW5kb3dbIHRoaXMuX2FwaSBdO1xyXG4gICAgICBjb25zdCBfa2V5ICAgID0gdGhpcy5fa2V5KCBrZXkgKTtcclxuICAgICAgY29uc3QgX3RpbWUgICA9IERhdGUubm93KCk7XHJcbiAgICAgIGNvbnN0IF90dGwgICAgPSBwYXJzZUludCggdHRsICkgfHwgdGhpcy5fdHRsO1xyXG4gICAgICBjb25zdCBfc3RyaW5nID0gSlNPTi5zdHJpbmdpZnkoIHsgX3RpbWUsIF90dGwsIGRhdGEgfSApO1xyXG4gICAgICBfc3RvcmUuc2V0SXRlbSggX2tleSwgX3N0cmluZyApO1xyXG4gICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIH1cclxuICAgIGNhdGNoICggZSApIHtcclxuICAgICAgcmV0dXJuIHRoaXMuX2Vycm9yKCBlICk7XHJcbiAgICB9XHJcbiAgfSxcclxuXHJcbiAgLy8gdHJ5IGZldGNoaW5nIGRhdGEgZm9yIGtleVxyXG4gIF9mZXRjaCgga2V5ICkge1xyXG4gICAgdHJ5IHtcclxuICAgICAgY29uc3QgX3N0b3JlICA9IHdpbmRvd1sgdGhpcy5fYXBpIF07XHJcbiAgICAgIGNvbnN0IF9rZXkgICAgPSB0aGlzLl9rZXkoIGtleSApO1xyXG4gICAgICBjb25zdCBfcGFyc2VkID0gSlNPTi5wYXJzZSggX3N0b3JlLmdldEl0ZW0oIF9rZXkgKSB8fCAne30nICk7XHJcbiAgICAgIHJldHVybiAoIF9wYXJzZWQgJiYgX3BhcnNlZC5kYXRhICkgPyBfcGFyc2VkLmRhdGEgOiBudWxsO1xyXG4gICAgfVxyXG4gICAgY2F0Y2ggKCBlICkge1xyXG4gICAgICByZXR1cm4gdGhpcy5fZXJyb3IoIGUgKTtcclxuICAgIH1cclxuICB9LFxyXG5cclxuICAvLyB0cnkgZGVsZXRpbmcgZGF0YSBieSBrZXlcclxuICBfZGVsZXRlKCBrZXkgKSB7XHJcbiAgICB0cnkge1xyXG4gICAgICBjb25zdCBfc3RvcmUgPSB3aW5kb3dbIHRoaXMuX2FwaSBdO1xyXG4gICAgICBjb25zdCBfa2V5ICAgPSB0aGlzLl9rZXkoIGtleSApO1xyXG4gICAgICBfc3RvcmUucmVtb3ZlSXRlbSggX2tleSApO1xyXG4gICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIH1cclxuICAgIGNhdGNoICggZSApIHtcclxuICAgICAgcmV0dXJuIHRoaXMuX2Vycm9yKCBlICk7XHJcbiAgICB9XHJcbiAgfSxcclxuXHJcbiAgLy8gY2xlYW4gYWxsIGV4cGlyZWQgaXRlbXMgZnJvbSBzdG9yYWdlXHJcbiAgX2NsZWFuKCkge1xyXG4gICAgdHJ5IHtcclxuICAgICAgY29uc3QgX3N0b3JlID0gd2luZG93WyB0aGlzLl9hcGkgXTtcclxuICAgICAgY29uc3QgX3RpbWUgID0gRGF0ZS5ub3coKTtcclxuXHJcbiAgICAgIC8vIGxvb3Aga2V5c1xyXG4gICAgICBmb3IgKCBsZXQgaSA9IDA7IGkgPCBfc3RvcmUubGVuZ3RoOyBpKysgKSB7XHJcblxyXG4gICAgICAgIC8vIG1ha2Ugc3VyZSBpdCdzIGEga2V5IG1hbmFnZWQgYnkgdGhpcyBvYmplY3RcclxuICAgICAgICBjb25zdCBfa2V5ID0gX3N0b3JlLmtleSggaSApO1xyXG4gICAgICAgIGlmICggX2tleS5pbmRleE9mKCB0aGlzLl9wcmVmaXggKSA8IDAgKSBjb250aW51ZTtcclxuXHJcbiAgICAgICAgLy8gZ2V0IGRhdGEgZm9yIGtleVxyXG4gICAgICAgIGNvbnN0IF9kYXRhID0gSlNPTi5wYXJzZSggX3N0b3JlLmdldEl0ZW0oIF9rZXkgKSB8fCAne30nICk7XHJcbiAgICAgICAgaWYgKCAhX2RhdGEuX3RpbWUgfHwgIV9kYXRhLl90dGwgKSBjb250aW51ZTsgLy8gbmVlZCB0aGVzZVxyXG5cclxuICAgICAgICAvLyBjaGVjayBpZiBlbm91Z2ggdGltZSBoYXMgcGFzc2VkIGFuZCBkZWxldGUga2V5XHJcbiAgICAgICAgY29uc3QgX3NlY3MgPSAoIF90aW1lIC0gX2RhdGEuX3RpbWUgKSAvIDEwMDA7XHJcbiAgICAgICAgaWYgKCBfc2VjcyA8IF9kYXRhLl90dGwgKSBjb250aW51ZTsgLy8gc3RpbGwgZnJlc2hcclxuICAgICAgICBfc3RvcmUucmVtb3ZlSXRlbSggX2tleSApO1xyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgfVxyXG4gICAgY2F0Y2ggKCBlICkge1xyXG4gICAgICByZXR1cm4gdGhpcy5fZXJyb3IoIGUgKTtcclxuICAgIH1cclxuICB9LFxyXG5cclxufVxyXG4iLCIvKipcbiAqIFRpY2tlciBzeW1ib2wgY2xhc3NcbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgU3ltYm9sIHtcblxuICAvLyBjb25zdHJ1Y3RvclxuICBjb25zdHJ1Y3Rvciggc3ltYm9sID0gJycgKSB7XG4gICAgdGhpcy5zeW1ib2wgICAgICAgPSBTdHJpbmcoIHN5bWJvbCB8fCAnJyApLnRvVXBwZXJDYXNlKCk7XG4gICAgdGhpcy5pZCAgICAgICAgICAgPSAnJzsgLy8gY3VzdG9tIHVuaXF1ZSB0b2tlbiBpZFxuICAgIHRoaXMudG9rZW4gICAgICAgID0gJyc7IC8vIGJhc2UgYXNzZXQgdG9rZW5cbiAgICB0aGlzLm1hcmtldCAgICAgICA9ICcnOyAvLyBxdW90ZSBhc3NldCB0b2tlbiAobWFya2V0KVxuICAgIHRoaXMubmFtZSAgICAgICAgID0gJyc7IC8vIG5hbWUgb2YgdG9rZW5cbiAgICB0aGlzLnBhaXIgICAgICAgICA9ICcnOyAvLyB0b2tlbi9tYXJrZXRcbiAgICB0aGlzLnJvdXRlICAgICAgICA9ICcvc3ltYm9sLycrIHRoaXMuc3ltYm9sO1xuICAgIHRoaXMuaW1hZ2UgICAgICAgID0gJy4uLy4uLy4uL2Fzc2V0cy9pbWFnZXMvY3J5cHRvQ3VycmVuY3kvZGVmYXVsdF8ucG5nJztcbiAgICB0aGlzLmltYWdlTG9hZGVkICA9IGZhbHNlO1xuICAgIHRoaXMub3BlbiAgICAgICAgID0gMDtcbiAgICB0aGlzLmhpZ2ggICAgICAgICA9IDA7XG4gICAgdGhpcy5sb3cgICAgICAgICAgPSAwO1xuICAgIHRoaXMuY2xvc2UgICAgICAgID0gMDtcbiAgICB0aGlzLmNoYW5nZSAgICAgICA9IDA7XG4gICAgdGhpcy5wZXJjZW50ICAgICAgPSAwO1xuICAgIHRoaXMudHJhZGVzICAgICAgID0gMDtcbiAgICB0aGlzLnRva2VuVm9sdW1lICA9IDA7XG4gICAgdGhpcy5tYXJrZXRWb2x1bWUgPSAwO1xuICAgIHRoaXMudm9sYXRpbGl0eSAgID0gMDtcbiAgICB0aGlzLmRhbmdlciAgICAgICA9IDA7XG4gICAgdGhpcy50aW1lICAgICAgICAgPSAwO1xuICAgIHRoaXMucmFuayAgICAgICAgID0gMDtcbiAgICB0aGlzLnN1cHBseSAgICAgICA9IDA7XG4gICAgdGhpcy5jYXB1c2QgICAgICAgPSAwO1xuICAgIHRoaXMuaGlzdG9yeSAgICAgID0gW107XG4gICAgdGhpcy5jYW5kbGVzICAgICAgPSBbXTtcbiAgICB0aGlzLnNpZ24gICAgICAgICA9ICcnO1xuICAgIHRoaXMuYXJyb3cgICAgICAgID0gJyc7XG4gICAgdGhpcy5zdHlsZSAgICAgICAgPSAnJztcbiAgfVxuXG4gIC8qKlxuICAgKiBTcGxpdCBmdWxsIHN5bWJvbCAoQlRDVVNEKSBpbnRvIHRva2VuIGFuZCBhc3NldCBzeW1ib2xzIChCVEMsIFVTRClcbiAgICovXG4gIHNwbGl0U3ltYm9sKCBtYXJrZXRzID0gW10gKSB7XG4gICAgaWYgKCB0aGlzLnRva2VuIHx8IHRoaXMubWFya2V0IHx8ICFtYXJrZXRzLmxlbmd0aCApIHJldHVybjtcbiAgICBjb25zdCBxdW90ZXMgPSBtYXJrZXRzLmpvaW4oICd8JyApO1xuICAgIGNvbnN0IHJlZ2V4cCA9IG5ldyBSZWdFeHAoIGBeKFtBLVowLTldKykoJHtxdW90ZXN9KSRgICk7XG4gICAgdGhpcy50b2tlbiAgID0gdGhpcy5zeW1ib2wucmVwbGFjZSggcmVnZXhwLCAnJDEnICkgfHwgdGhpcy50b2tlbjtcbiAgICB0aGlzLm1hcmtldCAgPSB0aGlzLnN5bWJvbC5yZXBsYWNlKCByZWdleHAsICckMicgKSB8fCB0aGlzLm1hcmtldDtcbiAgICB0aGlzLm5hbWUgICAgPSB0aGlzLnRva2VuO1xuICAgIHRoaXMucGFpciAgICA9IHRoaXMudG9rZW4gKycvJysgdGhpcy5tYXJrZXQ7XG4gIH1cblxuICAvKipcbiAgICogU2V0IGNvaW4gZGF0YSBmZXRjaGVkIGZyb20gY29pbmNhcCBBUElcbiAgICogaHR0cHM6Ly9kb2NzLmNvaW5jYXAuaW8vXG4gICAqL1xuICBzZXRDb2luRGF0YSggZGF0YSApIHtcbiAgICBpZiAoIHR5cGVvZiBkYXRhICE9PSAnb2JqZWN0JyApIHJldHVybjtcbiAgICB0aGlzLmlkICAgICA9IFN0cmluZyggZGF0YS5pZCB8fCB0aGlzLmlkICkudHJpbSgpO1xuICAgIHRoaXMubmFtZSAgID0gU3RyaW5nKCBkYXRhLm5hbWUgfHwgdGhpcy50b2tlbiApLnRyaW0oKTtcbiAgICB0aGlzLnJhbmsgICA9IE51bWJlciggZGF0YS5yYW5rIHx8IDAgKTtcbiAgICB0aGlzLnN1cHBseSA9IE51bWJlciggZGF0YS5zdXBwbHkgfHwgMCApO1xuICAgIHRoaXMuY2FwdXNkID0gTnVtYmVyKCBkYXRhLm1hcmtldENhcFVzZCB8fCAwICk7XG4gIH1cblxuICAvKipcbiAgICogU2V0IGxhdGVzdCB0aWNrZXIgdmFsdWVzIGZyb20gYmluYW5jZSBzb2NrZXQgQVBJXG4gICAqIGh0dHBzOi8vYmluYW5jZS1kb2NzLmdpdGh1Yi5pby9hcGlkb2NzL3Nwb3QvZW4vI2luZGl2aWR1YWwtc3ltYm9sLW1pbmktdGlja2VyLXN0cmVhbVxuICAgKi9cbiAgc2V0VGlja2VyRGF0YSggZGF0YSApIHtcbiAgICB0aGlzLm9wZW4gICAgICAgICA9IE51bWJlciggZGF0YS5vIHx8IGRhdGEub3BlblByaWNlIHx8IDAgKTtcbiAgICB0aGlzLmhpZ2ggICAgICAgICA9IE51bWJlciggZGF0YS5oIHx8IGRhdGEuaGlnaFByaWNlIHx8IDAgKTtcbiAgICB0aGlzLmxvdyAgICAgICAgICA9IE51bWJlciggZGF0YS5sIHx8IGRhdGEubG93UHJpY2UgfHwgMCApO1xuICAgIHRoaXMuY2xvc2UgICAgICAgID0gTnVtYmVyKCBkYXRhLmMgfHwgZGF0YS5sYXN0UHJpY2UgfHwgMCApO1xuICAgIHRoaXMuY2hhbmdlICAgICAgID0gTnVtYmVyKCBkYXRhLnAgfHwgZGF0YS5wcmljZUNoYW5nZSB8fCAwICk7XG4gICAgdGhpcy5wZXJjZW50ICAgICAgPSBOdW1iZXIoIGRhdGEuUCB8fCBkYXRhLnByaWNlQ2hhbmdlUGVyY2VudCB8fCAwICk7XG4gICAgdGhpcy50cmFkZXMgICAgICAgPSBOdW1iZXIoIGRhdGEubiB8fCBkYXRhLmNvdW50IHx8IDAgKTtcbiAgICB0aGlzLnRva2VuVm9sdW1lICA9IE51bWJlciggZGF0YS52IHx8IGRhdGEudm9sdW1lIHx8IDAgKTtcbiAgICB0aGlzLm1hcmtldFZvbHVtZSA9IE51bWJlciggZGF0YS5xIHx8IGRhdGEucXVvdGVWb2x1bWUgfHwgMCApO1xuICAgIHRoaXMuc2lnbiAgICAgICAgID0gKCB0aGlzLnBlcmNlbnQgPiAwICkgPyAnKycgOiAnJztcbiAgICB0aGlzLmFycm93ICAgICAgICA9ICggdGhpcy5wZXJjZW50ID4gMCApID8gJ+KWsicgOiAn4pa8JztcbiAgICB0aGlzLmNhbGNWb2xhdGlsaXR5KCk7XG4gICAgdGhpcy5jYWxjRGFuZ2VyKCk7XG4gICAgdGhpcy5jYWxjSGlzdG9yeSgpO1xuICAgIHRoaXMuY2FsY1N0eWxlKCk7XG4gIH1cblxuICAvKipcbiAgICogUmVzb2x2ZSB0b2tlbiBpY29uIGltYWdlXG4gICAqL1xuICByZXNvbHZlSW1hZ2UoKSB7XG4gICAgLy9pZiAoICF0aGlzLnRva2VuIHx8IHRoaXMuaW1hZ2VMb2FkZWQgKSByZXR1cm47XG4gICAgLy9sZXQgaW1nID0gbmV3IEltYWdlKCk7XG4gICAgLy9pbWcuYWRkRXZlbnRMaXN0ZW5lciggJ2xvYWQnLCAgZSA9PiB7IHRoaXMuaW1hZ2VMb2FkZWQgPSB0cnVlOyB0aGlzLmltYWdlID0gaW1nLnNyYzsgfSApO1xuICAgIC8vaW1nLmFkZEV2ZW50TGlzdGVuZXIoICdlcnJvcicsIGUgPT4geyB0aGlzLmltYWdlTG9hZGVkID0gdHJ1ZTsgfSApO1xuICAgIC8vaW1nLnNyYyA9ICcuLi8uLi8uLi9hc3NldHMvaW1hZ2VzL2NyeXB0b0N1cnJlbmN5LycrIFN0cmluZyggdGhpcy50b2tlbiApLnRvTG93ZXJDYXNlKCkgKydfLnBuZyc7XG4gICAgdGhpcy5pbWFnZUxvYWRlZCA9ICEwLCB0aGlzLmltYWdlID0gXCIuLi8uLi8uLi9hc3NldHMvaW1hZ2VzL2NyeXB0b0N1cnJlbmN5L1wiICsgU3RyaW5nKHRoaXMudG9rZW4pLnRvTG93ZXJDYXNlKCkgKyBcIi5wbmdcIlxuICB9XG5cbiAgLyoqXG4gICAqIEdldCBzeW1ib2wgZGF0YSB3aXRoIG1lcmdlZCBkYXRhXG4gICAqIEBwYXJhbSB7b2JqZWN0fSAgbWVyZ2UgIE9wdGlvbmFsIG9iamVjdFxuICAgKi9cbiAgZ2V0RGF0YSggbWVyZ2UgKSB7XG4gICAgbGV0IHZvbHVtZSA9IHRoaXMubWFya2V0Vm9sdW1lO1xuICAgIGxldCB7IGlkLCBzeW1ib2wsIHRva2VuLCBtYXJrZXQsIG5hbWUsIHBhaXIsIHJvdXRlLCBpbWFnZSwgY2xvc2UsIGNhcHVzZCwgc3VwcGx5IH0gPSB0aGlzO1xuICAgIHJldHVybiBPYmplY3QuYXNzaWduKCB7IGlkLCBzeW1ib2wsIHRva2VuLCBtYXJrZXQsIG5hbWUsIHBhaXIsIHJvdXRlLCBpbWFnZSwgY2xvc2UsIGNhcHVzZCwgc3VwcGx5LCB2b2x1bWUgfSwgbWVyZ2UgKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDbGVhbnVwIHN0b3JlZCBwcmljZSBkYXRhXG4gICAqL1xuICBmbHVzaERhdGEoKSB7XG4gICAgdGhpcy5oaXN0b3J5ID0gW107XG4gICAgdGhpcy5jYW5kbGVzID0gW107XG4gIH1cblxuICAvKipcbiAgICogQ2FsY3VsYXRlIHN0eWxlIGNsYXNzIGJhc2VkIG9uIHBlcmNlbnRcbiAgICovXG4gIGNhbGNTdHlsZSgpIHtcbiAgICB0aGlzLnN0eWxlID0gJyc7XG4gICAgaWYgKCB0aGlzLnBlcmNlbnQgPiAwICkgdGhpcy5zdHlsZSA9ICdnYWluJztcbiAgICBpZiAoIHRoaXMucGVyY2VudCA8IDAgKSB0aGlzLnN0eWxlID0gJ2xvc3MnO1xuICB9XG5cbiAgLyoqXG4gICAqIENhbGN1bGF0ZSAyNGggaGlnaC9sb3cgdm9sYXRpbGl0eSBzY29yZVxuICAgKi9cbiAgY2FsY1ZvbGF0aWxpdHkoKSB7XG4gICAgbGV0IGNoYW5nZSA9ICggdGhpcy5oaWdoIC0gdGhpcy5sb3cgKTtcbiAgICB0aGlzLnZvbGF0aWxpdHkgPSB0aGlzLmhpZ2ggPyAoIGNoYW5nZSAvIHRoaXMuaGlnaCAqIDEwMC4wICkgOiAwLjA7XG4gIH1cblxuICAvKipcbiAgICogQ2FsY3VsYXRlIHBvc3NpYmxlIHB1bXAvZHVtcCBkYW5nZXIgc2NvcmUgYmFzZWQgb24gY2FjaGVkIHByaWNlIGFjdGlvbiBmcm9tIHJlY2VudCBmZXcgaG91cnNcbiAgICovXG4gIGNhbGNEYW5nZXIoKSB7XG4gICAgbGV0IG5vdyAgID0gRGF0ZS5ub3coKTtcbiAgICBsZXQgd2FpdCAgPSAzMDA7IC8vIHNlY3MgdG8gd2FpdFxuICAgIGxldCBocnMgICA9IDM7ICAgLy8gaG91cnMgdG8gc3RvcmUgcHJpY2VzXG4gICAgbGV0IHNlY3MgID0gKCBub3cgLSB0aGlzLnRpbWUgKSAvIDEwMDA7XG4gICAgbGV0IHRvdGFsID0gKCA2MCAqIDYwICogaHJzICkgLyB3YWl0O1xuXG4gICAgaWYgKCBzZWNzIDwgd2FpdCApIHJldHVybjtcbiAgICB0aGlzLmNhbmRsZXMucHVzaCggdGhpcy5jbG9zZSApO1xuICAgIHRoaXMuY2FuZGxlcy5zcGxpY2UoIDAsIHRoaXMuY2FuZGxlcy5sZW5ndGggLSB0b3RhbCApO1xuXG4gICAgbGV0IGlkeCA9IHRoaXMuY2FuZGxlcy5sZW5ndGg7XG4gICAgbGV0IG1pbiA9IHRoaXMuY2FuZGxlc1sgMCBdO1xuICAgIGxldCBtYXggPSB0aGlzLmNhbmRsZXNbIDAgXTtcblxuICAgIHdoaWxlICggaWR4LS0gKSB7XG4gICAgICBsZXQgcHJpY2UgPSB0aGlzLmNhbmRsZXNbIGlkeCBdO1xuICAgICAgbWluID0gKCBwcmljZSA8IG1pbiApID8gcHJpY2UgOiBtaW47XG4gICAgICBtYXggPSAoIHByaWNlID4gbWF4ICkgPyBwcmljZSA6IG1heDtcbiAgICB9XG4gICAgbGV0IGNoYW5nZSA9ICggbWF4IC0gbWluICk7XG4gICAgdGhpcy5kYW5nZXIgPSBtYXggPyAoIGNoYW5nZSAvIG1heCAqIDEwMC4wICkgOiAwLjA7XG4gICAgdGhpcy50aW1lID0gbm93O1xuICB9XG5cbiAgLyoqXG4gICAqIE1hbmFnZXMgYSBoaXN0b3J5IGxpc3Qgd2l0aCB0aGUgbGF0ZXN0IGNsb3NlIHByaWNlXG4gICAqL1xuICBjYWxjSGlzdG9yeSgpIHtcbiAgICBpZiAoICF0aGlzLmhpc3RvcnkubGVuZ3RoICkgdGhpcy5mYWtlSGlzdG9yeSgpO1xuICAgIHRoaXMuaGlzdG9yeS5wdXNoKCB0aGlzLmNsb3NlICk7XG4gICAgdGhpcy5oaXN0b3J5LnNwbGljZSggMCwgdGhpcy5oaXN0b3J5Lmxlbmd0aCAtIDMwICk7XG4gIH1cblxuICAvKipcbiAgICogQ29tZSB1cCB3aXRoIHNvbWUgZmFrZSBoaXN0b3J5IHByaWNlcyB0byBmaWxsIGluIHRoZSBpbml0aWFsIGxpbmUgY2hhcnRcbiAgICovXG4gIGZha2VIaXN0b3J5KCkge1xuICAgIGxldCBudW0gPSB0aGlzLmNsb3NlICogMC4wMDAyO1xuICAgIGxldCBtaW4gPSAtTWF0aC5hYnMoIG51bSApO1xuICAgIGxldCBtYXggPSBNYXRoLmFicyggbnVtICk7XG4gICAgdGhpcy5oaXN0b3J5ID0gW107XG5cbiAgICBmb3IgKCBsZXQgaSA9IDA7IGkgPCAzMDsgKytpICkge1xuICAgICAgbGV0IHJhbmQgPSBNYXRoLnJhbmRvbSgpICogKCBtYXggLSBtaW4gKSArIG1pbjtcbiAgICAgIHRoaXMuaGlzdG9yeS5wdXNoKCB0aGlzLmNsb3NlICsgcmFuZCApO1xuICAgIH1cbiAgfVxuXG59XG4iLCIvKipcclxuICogVG9vbHRpcHMgQ2xhc3MuXHJcbiAqIEFkZHMgY3VzdG9tIHRvb2x0aXBzIHRvIGVsZW1lbnRzIG9uIHRoZSBwYWdlLlxyXG4gKi9cclxuaW1wb3J0IFZpZXdwb3J0IGZyb20gJy4vdmlld3BvcnQnO1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgVG9vbHRpcCB7XHJcblxyXG4gIC8vIGNsYXNzIGNvbnN0cnVjdG9yXHJcbiAgY29uc3RydWN0b3IoIG9wdGlvbnMgKSB7XHJcbiAgICB0aGlzLl9vcHRpb25zID0gT2JqZWN0LmFzc2lnbih7XHJcbiAgICAgIC8vIGNsYXNzIHRvIGFwcGx5IHRvIHRvb2x0aXAgZWxlbWVudFxyXG4gICAgICB0aXBDbGFzcyA6ICd0b29sdGlwLXdyYXAnLFxyXG4gICAgICAvLyBjbGFzcyB0byBhcHBseSB3aGVuIHRvb2x0aXAgaXMgcGxhY2VkIG9uIHRoZSBsZWZ0XHJcbiAgICAgIGxlZnRDbGFzcyA6ICd0b29sdGlwLWxlZnQnLFxyXG4gICAgICAvLyBjbGFzcyB0byBhcHBseSB3aGVuIHRvb2x0aXAgaXMgcGxhY2VkIG9uIHRoZSByaWdodFxyXG4gICAgICByaWdodENsYXNzIDogJ3Rvb2x0aXAtcmlnaHQnLFxyXG4gICAgICAvLyBjbGFzcyB0byBhcHBseSB3aGVuIHRvb2x0aXAgaXMgcGxhY2VkIG9uIHRoZSB0b3BcclxuICAgICAgdG9wQ2xhc3MgOiAndG9vbHRpcC10b3AnLFxyXG4gICAgICAvLyBjbGFzcyB0byBhcHBseSB3aGVuIHRvb2x0aXAgaXMgcGxhY2VkIG9uIHRoZSBib3R0b21cclxuICAgICAgYm90dG9tQ2xhc3MgOiAndG9vbHRpcC1ib3R0b20nLFxyXG4gICAgICAvLyBkZWxheSB0byBzaG93IHRoZSB0b29sdGlwXHJcbiAgICAgIHNob3dEZWxheSA6IDEwMCxcclxuICAgICAgLy8gYXV0byBoaWRlIGRlbGF5XHJcbiAgICAgIGhpZGVEZWxheTogMzAwMCxcclxuICAgICAgLy8gLi4uXHJcbiAgICB9LCBvcHRpb25zICk7XHJcblxyXG4gICAgdGhpcy5fdG9vbHRpcCAgPSBudWxsO1xyXG4gICAgdGhpcy5faG92SXRlbSAgPSBudWxsO1xyXG4gICAgdGhpcy5fdGltZW91dCAgPSBudWxsO1xyXG4gICAgdGhpcy5fYXV0b2hpZGUgPSBudWxsO1xyXG4gICAgdGhpcy5fdmlzaWJsZSAgPSBmYWxzZTtcclxuICAgIHRoaXMuX2VsZW1lbnRzID0gW107XHJcbiAgICB0aGlzLl9vblNjcm9sbCA9IHRoaXMuX29uU2Nyb2xsLmJpbmQoIHRoaXMgKTtcclxuICAgIHRoaXMuX2luaXQoKTtcclxuICB9XHJcblxyXG4gIC8vIHNldCB0YXJnZXQgZWxlbWVudHNcclxuICBzZWxlY3QoIHNlbGVjdG9yICkge1xyXG4gICAgaWYgKCB0eXBlb2Ygc2VsZWN0b3IgPT09ICdzdHJpbmcnICkge1xyXG4gICAgICB0aGlzLl9lbGVtZW50cyA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoIHNlbGVjdG9yICkgfHwgW107XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmICggdHlwZW9mIHNlbGVjdG9yID09PSAnb2JqZWN0JyAmJiBzZWxlY3RvciBpbnN0YW5jZW9mIEVsZW1lbnQgKSB7XHJcbiAgICAgIHRoaXMuX2VsZW1lbnRzLnB1c2goIHNlbGVjdG9yICk7XHJcbiAgICB9XHJcbiAgICBmb3IgKCBsZXQgaSA9IDA7IGkgPCB0aGlzLl9lbGVtZW50cy5sZW5ndGg7ICsraSApIHtcclxuICAgICAgdGhpcy5fc2V0dXBJdGVtKCB0aGlzLl9lbGVtZW50c1sgaSBdICk7XHJcbiAgICB9XHJcbiAgICB0aGlzLl9oaWRlVG9vbHRpcCgpO1xyXG4gIH1cclxuXHJcbiAgLy8gcmVtb3ZlIGVsZW1lbnQgZnJvbSB0aGUgbGlzdFxyXG4gIHVuc2VsZWN0KCBlbGVtZW50ICkge1xyXG4gICAgaWYgKCB0eXBlb2YgZWxlbWVudCA9PT0gJ29iamVjdCcgJiYgZWxlbWVudCBpbnN0YW5jZW9mIEVsZW1lbnQgKSB7XHJcbiAgICAgIGZvciAoIGxldCBpID0gMCwgdCA9IHRoaXMuX2VsZW1lbnRzLmxlbmd0aDsgaSA8IHQ7ICsraSApIHtcclxuICAgICAgICBpZiAoIHRoaXMuX2VsZW1lbnRzWyBpIF0gPT09IGVsZW1lbnQgKSB7XHJcbiAgICAgICAgICB0aGlzLl9yZXNldEl0ZW0oIHRoaXMuX2VsZW1lbnRzWyBpIF0gKTtcclxuICAgICAgICAgIHRoaXMuX2VsZW1lbnRzLnNwbGljZSggaSwgMSApO1xyXG4gICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICAgIHRoaXMuX2hpZGVUb29sdGlwKCk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvLyBjbGVhbnVwIHRoaXMgaW5zdGFuY2VcclxuICBkZXN0cm95KCkge1xyXG4gICAgZm9yICggbGV0IGkgPSAwOyBpIDwgdGhpcy5fZWxlbWVudHMubGVuZ3RoOyArK2kgKSB7XHJcbiAgICAgIHRoaXMuX3Jlc2V0SXRlbSggdGhpcy5fZWxlbWVudHNbIGkgXSApO1xyXG4gICAgfVxyXG4gICAgaWYgKCBkb2N1bWVudC5ib2R5LmNvbnRhaW5zKCB0aGlzLl90b29sdGlwICkgKSB7XHJcbiAgICAgIGRvY3VtZW50LmJvZHkucmVtb3ZlQ2hpbGQoIHRoaXMuX3Rvb2x0aXAgKTtcclxuICAgIH1cclxuICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCAnc2Nyb2xsJywgdGhpcy5fb25TY3JvbGwgKTtcclxuICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCAndG91Y2htb3ZlJywgdGhpcy5fb25TY3JvbGwgKTtcclxuICAgIHRoaXMuX2VsZW1lbnRzID0gW107XHJcbiAgICB0aGlzLl90b29sdGlwID0gbnVsbDtcclxuICB9XHJcblxyXG4gIC8vIGluaXRsYWl6ZSBlbGVtZW50c1xyXG4gIF9pbml0KCkge1xyXG4gICAgdGhpcy5fdG9vbHRpcCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoICdkaXYnICk7XHJcbiAgICB0aGlzLl90b29sdGlwLmNsYXNzTmFtZSA9IHRoaXMuX29wdGlvbnMudGlwQ2xhc3M7XHJcbiAgICB0aGlzLl90b29sdGlwLnN0eWxlWydkaXNwbGF5J10gPSAnYmxvY2snO1xyXG4gICAgdGhpcy5fdG9vbHRpcC5zdHlsZVsncG9zaXRpb24nXSA9ICdhYnNvbHV0ZSc7XHJcbiAgICB0aGlzLl90b29sdGlwLnN0eWxlWydwb2ludGVyLWV2ZW50cyddID0gJ25vbmUnO1xyXG4gICAgdGhpcy5faGlkZVRvb2x0aXAoKTtcclxuICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQoIHRoaXMuX3Rvb2x0aXAgKTtcclxuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCAnc2Nyb2xsJywgdGhpcy5fb25TY3JvbGwgKTtcclxuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCAndG91Y2htb3ZlJywgdGhpcy5fb25TY3JvbGwgKTtcclxuICB9XHJcblxyXG4gIC8vIHNldCBhbiBlbGVtZW50IHRvIGhhdmUgdG9vbHRpcCwgaWYgbm90IGFscmVkeSBzZXR1cFxyXG4gIF9zZXR1cEl0ZW0oIGl0ZW0gKSB7XHJcbiAgICBpZiAoIGl0ZW0gJiYgaXRlbSBpbnN0YW5jZW9mIEVsZW1lbnQgKSB7XHJcbiAgICAgIGlmICggaXRlbS5oYXNBdHRyaWJ1dGUoICd0aXRsZScgKSApIHtcclxuICAgICAgICBjb25zdCBfcGFzc2l2ZSA9IHsgcGFzc2l2ZTogdHJ1ZSB9O1xyXG4gICAgICAgIGl0ZW0uc2V0QXR0cmlidXRlKCAnZGF0YS10aXAnLCBpdGVtLmdldEF0dHJpYnV0ZSggJ3RpdGxlJyApIHx8ICcnICk7XHJcbiAgICAgICAgaXRlbS5yZW1vdmVBdHRyaWJ1dGUoICd0aXRsZScgKTtcclxuICAgICAgICBpdGVtLmFkZEV2ZW50TGlzdGVuZXIoICdtb3VzZWVudGVyJywgZSA9PiB7IHRoaXMuX29uRW50ZXIoIGUgKTsgfSwgX3Bhc3NpdmUgKTtcclxuICAgICAgICBpdGVtLmFkZEV2ZW50TGlzdGVuZXIoICd0b3VjaHN0YXJ0JywgZSA9PiB7IHRoaXMuX29uRW50ZXIoIGUgKTsgfSwgX3Bhc3NpdmUgKTtcclxuICAgICAgICBpdGVtLmFkZEV2ZW50TGlzdGVuZXIoICdtb3VzZWxlYXZlJywgZSA9PiB7IHRoaXMuX29uTGVhdmUoIGUgKTsgfSwgX3Bhc3NpdmUgKTtcclxuICAgICAgICBpdGVtLmFkZEV2ZW50TGlzdGVuZXIoICd0b3VjaGVuZCcsIGUgPT4geyB0aGlzLl9vbkxlYXZlKCBlICk7IH0sIF9wYXNzaXZlICk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8vIHJlbW92ZSB0b29sdGlwIGV2ZW50cyBmcm9tIGVsZW1lbnQsIGlmIG5lZWRlZFxyXG4gIF9yZXNldEl0ZW0oIGl0ZW0gKSB7XHJcbiAgICBpZiAoIGl0ZW0gJiYgaXRlbSBpbnN0YW5jZW9mIEVsZW1lbnQgKSB7XHJcbiAgICAgIGlmICggaXRlbS5oYXNBdHRyaWJ1dGUoICdkYXRhLXRpcCcgKSApIHtcclxuICAgICAgICBpdGVtLnNldEF0dHJpYnV0ZSggJ3RpdGxlJywgaXRlbS5nZXRBdHRyaWJ1dGUoICdkYXRhLXRpcCcgKSB8fCAnJyApO1xyXG4gICAgICAgIGl0ZW0ucmVtb3ZlQXR0cmlidXRlKCAnZGF0YS10aXAnICk7XHJcbiAgICAgICAgaXRlbS5yZW1vdmVFdmVudExpc3RlbmVyKCAnbW91c2VlbnRlcicsIGUgPT4geyB0aGlzLl9vbkVudGVyKCBlICk7IH0gKTtcclxuICAgICAgICBpdGVtLnJlbW92ZUV2ZW50TGlzdGVuZXIoICd0b3VjaHN0YXJ0JywgZSA9PiB7IHRoaXMuX29uRW50ZXIoIGUgKTsgfSApO1xyXG4gICAgICAgIGl0ZW0ucmVtb3ZlRXZlbnRMaXN0ZW5lciggJ21vdXNlbGVhdmUnLCBlID0+IHsgdGhpcy5fb25MZWF2ZSggZSApOyB9ICk7XHJcbiAgICAgICAgaXRlbS5yZW1vdmVFdmVudExpc3RlbmVyKCAndG91Y2hlbmQnLCBlID0+IHsgdGhpcy5fb25MZWF2ZSggZSApOyB9ICk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8vIGRlY2lkZXMgd2hlcmUgdG8gcGxhY2UgdGhlIHRvb2x0aXAgaW4gcmVsYXRpb24gdG8gaXRlbSBhbmQgc2NyZWVuIGJvdW5kc1xyXG4gIF9zaG93VG9vbHRpcCgpIHtcclxuICAgIGlmICggdGhpcy5fdG9vbHRpcCAmJiB0aGlzLl9ob3ZJdGVtICkge1xyXG4gICAgICBsZXQgYm94ICAgICAgICAgPSB0aGlzLl9ob3ZJdGVtLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xyXG4gICAgICBsZXQgY2VudGVyWCAgICAgPSBib3gubGVmdCArICggdGhpcy5faG92SXRlbS5vZmZzZXRXaWR0aCAtIHRoaXMuX3Rvb2x0aXAub2Zmc2V0V2lkdGggKSAvIDI7XHJcbiAgICAgIGxldCBjZW50ZXJZICAgICA9IGJveC50b3AgKyAoIHRoaXMuX2hvdkl0ZW0ub2Zmc2V0SGVpZ2h0IC0gdGhpcy5fdG9vbHRpcC5vZmZzZXRIZWlnaHQgKSAvIDI7XHJcbiAgICAgIGxldCBsZWZ0UG9zICAgICA9IGJveC5sZWZ0IC0gdGhpcy5fdG9vbHRpcC5vZmZzZXRXaWR0aDtcclxuICAgICAgbGV0IHJpZ2h0UG9zICAgID0gYm94LmxlZnQgKyB0aGlzLl9ob3ZJdGVtLm9mZnNldFdpZHRoO1xyXG4gICAgICBsZXQgdG9wUG9zICAgICAgPSBib3gudG9wIC0gdGhpcy5fdG9vbHRpcC5vZmZzZXRIZWlnaHQ7XHJcbiAgICAgIGxldCBib3R0b21Qb3MgICA9IGJveC50b3AgKyB0aGlzLl9ob3ZJdGVtLm9mZnNldEhlaWdodDtcclxuICAgICAgbGV0IHRpcEhhbGYgICAgID0gdGhpcy5fdG9vbHRpcC5vZmZzZXRXaWR0aCAvIDI7XHJcbiAgICAgIGxldCBib3hDZW50ZXIgICA9IGJveC50b3AgLSAoIHRoaXMuX2hvdkl0ZW0ub2Zmc2V0SGVpZ2h0IC8gMiApO1xyXG4gICAgICBsZXQgaGFsZlNjcmVlbiAgPSB3aW5kb3cuaW5uZXJIZWlnaHQgLyAyO1xyXG4gICAgICBsZXQgaXNOZWFyTGVmdCAgPSAoIGJveC5sZWZ0IDwgdGlwSGFsZiApO1xyXG4gICAgICBsZXQgaXNOZWFyUmlnaHQgPSAoICggVmlld3BvcnQuY2xpZW50V2lkdGgoKSAtIHJpZ2h0UG9zICkgPCB0aXBIYWxmICk7XHJcblxyXG4gICAgICBsZXQgY2xzcyA9IHRoaXMuX29wdGlvbnMudG9wQ2xhc3M7XHJcbiAgICAgIGxldCBsZWZ0ID0gY2VudGVyWDtcclxuICAgICAgbGV0IHRvcCAgPSB0b3BQb3M7XHJcblxyXG4gICAgICAvLyBtb3ZlIHRvIHRoZSBib3R0b21cclxuICAgICAgaWYgKCBib3hDZW50ZXIgPCBoYWxmU2NyZWVuICkge1xyXG4gICAgICAgIGNsc3MgPSB0aGlzLl9vcHRpb25zLmJvdHRvbUNsYXNzO1xyXG4gICAgICAgIGxlZnQgPSBjZW50ZXJYO1xyXG4gICAgICAgIHRvcCAgPSBib3R0b21Qb3M7XHJcbiAgICAgIH1cclxuICAgICAgLy8gbW92ZSB0byB0aGUgcmlnaHRcclxuICAgICAgaWYgKCBpc05lYXJMZWZ0ICYmICFpc05lYXJSaWdodCApIHtcclxuICAgICAgICBjbHNzID0gdGhpcy5fb3B0aW9ucy5yaWdodENsYXNzO1xyXG4gICAgICAgIGxlZnQgPSByaWdodFBvcztcclxuICAgICAgICB0b3AgID0gY2VudGVyWTtcclxuICAgICAgfVxyXG4gICAgICAvLyBtb3ZlIHRvIHRoZSBsZWZ0XHJcbiAgICAgIGlmICggaXNOZWFyUmlnaHQgJiYgIWlzTmVhckxlZnQgKSB7XHJcbiAgICAgICAgY2xzcyA9IHRoaXMuX29wdGlvbnMubGVmdENsYXNzO1xyXG4gICAgICAgIGxlZnQgPSBsZWZ0UG9zO1xyXG4gICAgICAgIHRvcCAgPSBjZW50ZXJZO1xyXG4gICAgICB9XHJcbiAgICAgIC8vIHNob3cgdG9vbHRpcFxyXG4gICAgICBpZiAoIGxlZnQgPiAxICYmIHRvcCA+IDEgJiYgdGhpcy5fdG9vbHRpcC5pbm5lckhUTUwgKSB7XHJcbiAgICAgICAgdGhpcy5fdG9vbHRpcC5jbGFzc05hbWUgPSB0aGlzLl9vcHRpb25zLnRpcENsYXNzICsgJyAnICsgY2xzcztcclxuICAgICAgICB0aGlzLl90b29sdGlwLnN0eWxlWydsZWZ0J10gPSAoIFZpZXdwb3J0LnNjcm9sbExlZnQoKSArIGxlZnQgKSArJ3B4JztcclxuICAgICAgICB0aGlzLl90b29sdGlwLnN0eWxlWyd0b3AnXSA9ICggVmlld3BvcnQuc2Nyb2xsVG9wKCkgKyB0b3AgKSArJ3B4JztcclxuICAgICAgICB0aGlzLl92aXNpYmxlID0gdHJ1ZTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLy8gbW92ZSB0b29sdGlwIG9iamVjdCBvZmYgc2NyZWVuLCByZXNldCBjb250ZW50IGFuZCBjbGFzc1xyXG4gIF9oaWRlVG9vbHRpcCgpIHtcclxuICAgIGlmICggdGhpcy5fdG9vbHRpcCApIHtcclxuICAgICAgdGhpcy5fdG9vbHRpcC5pbm5lckhUTUwgPSAnJztcclxuICAgICAgdGhpcy5fdG9vbHRpcC5jbGFzc05hbWUgPSB0aGlzLl9vcHRpb25zLnRpcENsYXNzO1xyXG4gICAgICB0aGlzLl90b29sdGlwLnN0eWxlWydsZWZ0J10gPSAnLTEwMDBweCc7XHJcbiAgICAgIHRoaXMuX3Rvb2x0aXAuc3R5bGVbJ3RvcCddID0gJy0xMDAwcHgnO1xyXG4gICAgICB0aGlzLl92aXNpYmxlID0gZmFsc2U7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvLyB3aGVuIG1vdXNlIGVudGVycyB0YXJnZXQgZWxlbWVudFxyXG4gIF9vbkVudGVyKCBlICkge1xyXG4gICAgbGV0IGl0ZW0gID0gZS50YXJnZXQ7XHJcbiAgICBsZXQgdGl0bGUgPSBpdGVtLmdldEF0dHJpYnV0ZSggJ2RhdGEtdGlwJyApO1xyXG5cclxuICAgIGlmICggdGl0bGUgKSB7XHJcbiAgICAgIHRoaXMuX2hvdkl0ZW0gPSBpdGVtO1xyXG4gICAgICB0aGlzLl90b29sdGlwLmlubmVySFRNTCA9IHRpdGxlO1xyXG5cclxuICAgICAgaWYgKCB0aGlzLl90aW1lb3V0ICkgY2xlYXJUaW1lb3V0KCB0aGlzLl90aW1lb3V0ICk7XHJcbiAgICAgIHRoaXMuX3RpbWVvdXQgPSBzZXRUaW1lb3V0KCB0aGlzLl9zaG93VG9vbHRpcC5iaW5kKCB0aGlzICksIHRoaXMuX29wdGlvbnMuc2hvd0RlbGF5ICk7XHJcblxyXG4gICAgICBpZiAoIHRoaXMuX2F1dG9oaWRlICkgY2xlYXJUaW1lb3V0KCB0aGlzLl9hdXRvaGlkZSApO1xyXG4gICAgICB0aGlzLl9hdXRvaGlkZSA9IHNldFRpbWVvdXQoIHRoaXMuX2hpZGVUb29sdGlwLmJpbmQoIHRoaXMgKSwgdGhpcy5fb3B0aW9ucy5oaWRlRGVsYXkgKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8vIHdoZW4gbW91c2UgbGVhdmVzIHRhcmdldCBlbGVtZW50XHJcbiAgX29uTGVhdmUoIGUgKSB7XHJcbiAgICBpZiAoIHRoaXMuX3RpbWVvdXQgKSB7XHJcbiAgICAgIGNsZWFyVGltZW91dCggdGhpcy5fdGltZW91dCApO1xyXG4gICAgICB0aGlzLl90aW1lb3V0ID0gbnVsbDtcclxuICAgIH1cclxuICAgIHRoaXMuX2hvdkl0ZW0gPSBudWxsO1xyXG4gICAgdGhpcy5faGlkZVRvb2x0aXAoKTtcclxuICB9XHJcblxyXG4gIC8vIGhpZGUgdG9vbHRpcCBvdmVyIGZpeGVkIGVsZW1lbnRzIHdoZW4gc2Nyb2xsZWRcclxuICBfb25TY3JvbGwoIGUgKSB7XHJcbiAgICBpZiAoIHRoaXMuX3Zpc2libGUgKSB7XHJcbiAgICAgIHRoaXMuX2hpZGVUb29sdGlwKCk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxufVxyXG4iLCIvKipcbiAqIFR3aXR0ZXIgc2NyYXBlciBhbmQgdHdlZXRzIG1hbmFnZXIgY2xhc3MuXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFR3aXR0ZXIge1xuXG4gIC8qKlxuICAgKiBDb25zdHJ1Y3RvclxuICAgKiBAcGFyYW0ge3N0cmluZ30gIGhhbmRsZSAgIFR3aXR0ZXIgaGFuZGxlXG4gICAqIEBwYXJhbSB7b2JqZWN0fSAgb3B0aW9ucyAgRmV0Y2hpbmcgb3B0aW9uc1xuICAgKi9cbiAgY29uc3RydWN0b3IoIGhhbmRsZSwgb3B0aW9ucyApIHtcbiAgICBpZiAoICFoYW5kbGUgfHwgdHlwZW9mIGhhbmRsZSAhPT0gJ3N0cmluZycgKSB7XG4gICAgICB0aHJvdyAnTXVzdCBwcm92aWRlIGEgdmFsaWQgdHdpdHRlciBoYW5kbGUgc3RyaW5nLic7XG4gICAgfVxuICAgIHRoaXMudWlkICAgICAgID0gJyc7XG4gICAgdGhpcy5oYW5kbGUgICAgPSAnJztcbiAgICB0aGlzLm5hbWUgICAgICA9ICcnO1xuICAgIHRoaXMuYXZhdGFyICAgID0gJyc7XG4gICAgdGhpcy51cmwgICAgICAgPSAnJztcbiAgICB0aGlzLmVycm9yICAgICA9ICcnO1xuICAgIHRoaXMubGFzdCAgICAgID0gMDtcbiAgICB0aGlzLmZldGNoaW5nICA9IGZhbHNlO1xuICAgIHRoaXMuX29wdGlvbnMgID0ge1xuICAgICAgc2tpcFBpbm5lZCAgOiB0cnVlLCAgLy8gaWdub3JlIHBpbm5lZCB0d2VldHNcbiAgICAgIHNraXBSZXR3ZWV0IDogdHJ1ZSwgIC8vIGlnbm9yZSByZS10d2VldHNcbiAgICAgIGNsZWFuVHdlZXRzIDogdHJ1ZSwgIC8vIHN0cmlwIGh0bWwgYW5kIHdoaXRlc3BhY2UgZnJvbSB0d2VldHNcbiAgICAgIGZldGNoRGVsYXkgIDogMzAwLCAgIC8vIHByZXZlbnQgcmUtZmV0Y2hpbmcgZm9yIChzZWNzKVxuICAgICAgbGltaXRDb3VudCAgOiAxLCAgICAgLy8gbGltaXQgbnVtYmVyIG9mIHR3ZWV0cyBwYXJzZWRcbiAgICB9O1xuICAgIHRoaXMuc2V0T3B0aW9ucyggb3B0aW9ucyApO1xuICAgIHRoaXMuc2V0RGF0YSggeyBoYW5kbGU6IGhhbmRsZSwgbmFtZTogaGFuZGxlIH0gKTtcbiAgfVxuXG4gLyoqXG4gICAqIFVwZGF0ZSBvcHRpb25zXG4gICAqIEBwYXJhbSB7b2JqZWN0fSAgb3B0aW9ucyAgT3B0aW9ucyBvYmplY3RcbiAgICovXG4gIHNldE9wdGlvbnMoIG9wdGlvbnMgKSB7XG4gICAgT2JqZWN0LmFzc2lnbiggdGhpcy5fb3B0aW9ucywgb3B0aW9ucyApO1xuICB9XG5cbiAgLyoqXG4gICAqIFNldCBuZXcgYWNvY3VudCBkYXRhXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBkYXRhICBUd2l0dGVyIGFjY291bnQgZGF0YVxuICAgKi9cbiAgc2V0RGF0YSggZGF0YSApIHtcbiAgICBpZiAoIHR5cGVvZiBkYXRhICE9PSAnb2JqZWN0JyApIHJldHVybjtcbiAgICBpZiAoIGRhdGEudWlkICkgICAgdGhpcy51aWQgICAgPSBTdHJpbmcoIHRoaXMudWlkICkucmVwbGFjZSggL1teXFx3XFwtXSsvZywgJycgKTtcbiAgICBpZiAoIGRhdGEuaGFuZGxlICkgdGhpcy5oYW5kbGUgPSBTdHJpbmcoIGRhdGEuaGFuZGxlICkucmVwbGFjZSggL1teXFx3XFwtXSsvZywgJycgKTtcbiAgICBpZiAoIGRhdGEubmFtZSApICAgdGhpcy5uYW1lICAgPSBTdHJpbmcoIGRhdGEubmFtZSApLnJlcGxhY2UoIC9bXFxyXFxuXFxzXFx0XSsvZywgJyAnICkudHJpbSgpO1xuICAgIGlmICggZGF0YS5hdmF0YXIgKSB0aGlzLmF2YXRhciA9IFN0cmluZyggZGF0YS5hdmF0YXIgKS50cmltKCk7XG4gICAgdGhpcy51cmwgPSAnaHR0cHM6Ly90d2l0dGVyLmNvbS8nKyB0aGlzLmhhbmRsZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgYWNjb3VudCBpbmZvXG4gICAqL1xuICBnZXREYXRhKCkge1xuICAgIGxldCB7IHVpZCwgaGFuZGxlLCBuYW1lLCBhdmF0YXIsIHVybCwgbGFzdCwgZmV0Y2hpbmcsIGVycm9yIH0gPSB0aGlzO1xuICAgIHJldHVybiB7IHVpZCwgaGFuZGxlLCBuYW1lLCBhdmF0YXIsIHVybCwgbGFzdCwgZmV0Y2hpbmcsIGVycm9yIH07XG4gIH1cblxuICAvKipcbiAgICogRmV0Y2ggcmVtb3RlIHR3ZWV0cyB1c2luZyBhamF4IG1vZHVsZVxuICAgKiBAcGFyYW0ge29iamVjdH0gICAgYWpheCAgICAgIEFqYXggbW9kdWxlIGluc3RhbmNlIHRvIHVzZSBmb3IgcmVxdWVzdFxuICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSAgY2FsbGJhY2sgIENhbGxiYWNrIGZ1bmN0aW9uXG4gICAqL1xuICBmZXRjaFR3ZWV0cyggYWpheCwgY2FsbGJhY2sgKSB7XG4gICAgaWYgKCAhY2FsbGJhY2sgfHwgdHlwZW9mIGNhbGxiYWNrICE9PSAnZnVuY3Rpb24nICkgcmV0dXJuO1xuICAgIGlmICggIWFqYXggfHwgdHlwZW9mIGFqYXggIT09ICdvYmplY3QnICkgcmV0dXJuIGNhbGxiYWNrKCAnTXVzdCBwcm92aWRlIGFuIGFqYXggbW9kdWxlIHJlZmVyZW5jZS4nLCBbXSApO1xuICAgIGlmICggIXRoaXMuX2NhbkZldGNoKCkgKSByZXR1cm4gY2FsbGJhY2soICcnLCBbXSApOyAvLyB0b28gc29vbiwgaWdub3JlXG5cbiAgICB0aGlzLmZldGNoaW5nID0gdHJ1ZTtcbiAgICB0aGlzLmVycm9yID0gJyc7XG5cbiAgICBhamF4LmdldCggdGhpcy51cmwsIHtcbiAgICAgIHR5cGU6ICd0ZXh0JyxcbiAgICAgIHRpbWVvdXQ6IDMwLFxuICAgICAgbm90QWpheDogdHJ1ZSxcblxuICAgICAgZG9uZTogKCB4aHIsIHN0YXR1cywgcmVzcG9uc2UgKSA9PiB7XG4gICAgICAgIHRoaXMuZmV0Y2hpbmcgPSBmYWxzZTtcbiAgICAgIH0sXG4gICAgICBlcnJvcjogKCB4aHIsIHN0YXR1cywgZXJyb3IgKSA9PiB7XG4gICAgICAgIHRoaXMuZXJyb3IgPSBlcnJvciArJyB8IEAnKyB0aGlzLmhhbmRsZSArJy4nO1xuICAgICAgICByZXR1cm4gY2FsbGJhY2soIHRoaXMuZXJyb3IsIFtdICk7XG4gICAgICB9LFxuICAgICAgc3VjY2VzczogKCB4aHIsIHN0YXR1cywgcmVzcG9uc2UgKSA9PiB7XG4gICAgICAgIGxldCBwYXJzZXIgPSBuZXcgRE9NUGFyc2VyKCk7XG4gICAgICAgIGxldCBodG1sICAgPSB0aGlzLl9jbGVhbkh0bWwoIHJlc3BvbnNlICk7XG4gICAgICAgIGxldCBkb2MgICAgPSBwYXJzZXIucGFyc2VGcm9tU3RyaW5nKCBodG1sLCAndGV4dC9odG1sJyApO1xuXG4gICAgICAgIGlmICggZG9jICYmIGRvYyBpbnN0YW5jZW9mIEhUTUxEb2N1bWVudCApIHtcbiAgICAgICAgICB0aGlzLmxhc3QgPSBEYXRlLm5vdygpO1xuICAgICAgICAgIGNhbGxiYWNrKCAnJywgdGhpcy5wYXJzZVR3ZWV0cyggZG9jICkgKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLmVycm9yID0gJ0RPTVBhcnNlckVycm9yOiBDb3VsZCBub3QgcGFyc2UgcmVzcG9uc2UgZnJvbSAnKyB0aGlzLnVybDtcbiAgICAgICAgICBjYWxsYmFjayggdGhpcy5lcnJvciwgW10gKTtcbiAgICAgICAgfVxuICAgICAgICBwYXJzZXIgPSBudWxsO1xuICAgICAgICBodG1sID0gbnVsbDtcbiAgICAgICAgZG9jID0gbnVsbDtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBQYXJzZSBhY2NvdW50IGFuZCB0d2VldHMgZGF0YSBmcm9tIGEgZmV0Y2hlZCBIVE1MIHJlc3BvbnNlXG4gICAqIEBwYXJhbSB7SFRNTERvY3VtZW50fSAgZG9jICBUd2l0dGVyIGFjY291bnQgcGFnZSBkb2N1bWVudFxuICAgKi9cbiAgcGFyc2VUd2VldHMoIGRvYyApIHtcbiAgICBsZXQgbGltaXQgID0gdGhpcy5fb3B0aW9ucy5saW1pdENvdW50IHwgMDtcbiAgICBsZXQgY291bnQgID0gMDtcbiAgICBsZXQgb3V0cHV0ID0gW107XG5cbiAgICAvLyBsb29rIGZvciBwcm9maWxlIGF2YXRhclxuICAgIGxldCBhdmF0YXIgPSBkb2MucXVlcnlTZWxlY3RvciggJ2ltZy5Qcm9maWxlQXZhdGFyLWltYWdlJyApO1xuICAgIGF2YXRhciA9IGF2YXRhciA/IGF2YXRhci5zcmMgOiAnJztcblxuICAgIC8vIGxvb2sgZm9yIGl0ZW1zXG4gICAgbGV0IGl0ZW1zID0gZG9jLnF1ZXJ5U2VsZWN0b3JBbGwoICcuc3RyZWFtLWl0ZW0nICkgfHwgW107XG5cbiAgICAvLyBsb29wIHR3ZWV0IGxpc3QgaXRlbXNcbiAgICBmb3IgKCBsZXQgaSA9IDA7IGkgPCBpdGVtcy5sZW5ndGg7ICsraSApIHtcbiAgICAgIGlmICggbGltaXQgJiYgY291bnQgPj0gbGltaXQgKSBicmVhaztcblxuICAgICAgLy8gbG9vayBmb3IgdHdlZXQgZGF0YVxuICAgICAgbGV0IGl0ZW0gICAgPSBpdGVtc1sgaSBdO1xuICAgICAgbGV0IHR3ZWV0ICAgPSBpdGVtICAgPyBpdGVtLnF1ZXJ5U2VsZWN0b3IoICcuanMtc3RyZWFtLXR3ZWV0JyApIDogbnVsbDsgLy8gbWV0YWRhdGEgdGFnXG4gICAgICBsZXQgcG9zdGVkICA9IGl0ZW0gICA/IGl0ZW0ucXVlcnlTZWxlY3RvciggJy5qcy1zaG9ydC10aW1lc3RhbXAnICkgOiBudWxsOyAvLyBkYXRlIHRhZ1xuICAgICAgbGV0IGNvbnRlbnQgPSBpdGVtICAgPyBpdGVtLnF1ZXJ5U2VsZWN0b3IoICcuanMtdHdlZXQtdGV4dCcgKSA6IG51bGw7IC8vIHR3ZWV0IHdyYXBwZXJcbiAgICAgIGxldCB0ZXh0ICAgID0gJyc7XG5cbiAgICAgIC8vIGxvb2sgZm9yIGFjY291bnQgaW5mb1xuICAgICAgbGV0IGlkICAgICAgPSB0d2VldCAgPyB0d2VldC5nZXRBdHRyaWJ1dGUoICdkYXRhLXR3ZWV0LWlkJyApIHx8ICcnIDogJyc7XG4gICAgICBsZXQgdWlkICAgICA9IHR3ZWV0ICA/IHR3ZWV0LmdldEF0dHJpYnV0ZSggJ2RhdGEtdXNlci1pZCcgKSB8fCAnJyA6ICcnO1xuICAgICAgbGV0IG5hbWUgICAgPSB0d2VldCAgPyB0d2VldC5nZXRBdHRyaWJ1dGUoICdkYXRhLW5hbWUnICkgfHwgJycgOiAnJztcbiAgICAgIGxldCBoYW5kbGUgID0gdHdlZXQgID8gdHdlZXQuZ2V0QXR0cmlidXRlKCAnZGF0YS1zY3JlZW4tbmFtZScgKSB8fCAnJyA6ICcnO1xuICAgICAgbGV0IGxpbmsgICAgPSB0d2VldCAgPyAnaHR0cHM6Ly90d2l0dGVyLmNvbScrIHR3ZWV0LmdldEF0dHJpYnV0ZSggJ2RhdGEtcGVybWFsaW5rLXBhdGgnICkgfHwgJycgOiAnJztcbiAgICAgIGxldCB0aW1lICAgID0gcG9zdGVkID8gTnVtYmVyKCBwb3N0ZWQuZ2V0QXR0cmlidXRlKCAnZGF0YS10aW1lLW1zJyApICkgfHwgMCA6IDA7XG5cbiAgICAgIC8vIHVwZGF0ZSBwcm9maWxlIGRldGFpbHNcbiAgICAgIHRoaXMuc2V0RGF0YSggeyB1aWQsIGhhbmRsZSwgbmFtZSwgYXZhdGFyIH0gKTtcblxuICAgICAgLy8gcmVzb2x2ZSB0d2VldCB0ZXh0XG4gICAgICBpZiAoIGNvbnRlbnQgKSB7XG4gICAgICAgIHRleHQgPSB0aGlzLl9vcHRpb25zLmNsZWFuVHdlZXRzXG4gICAgICAgICAgPyB0aGlzLl9jbGVhblR3ZWV0KCBjb250ZW50LnRleHRDb250ZW50IClcbiAgICAgICAgICA6IFN0cmluZyggY29udGVudC5pbm5lckhUTUwgfHwgJycgKS50cmltKCk7XG4gICAgICB9XG4gICAgICAvLyBjaGVjayBhIGZldyB0aGluZ3MsIHNraXAgaWYgbmVlZGVkXG4gICAgICBpZiAoICFpZCB8fCAhdWlkIHx8ICFuYW1lIHx8ICFoYW5kbGUgfHwgIXRleHQgfHwgIXRpbWUgfHwgdGltZSA8IDAgKSBjb250aW51ZTtcbiAgICAgIGlmICggdGhpcy5fb3B0aW9ucy5za2lwUGlubmVkICYmIGl0ZW0uY2xhc3NMaXN0LmNvbnRhaW5zKCAnanMtcGlubmVkJyApICkgY29udGludWU7XG4gICAgICBpZiAoIHRoaXMuX29wdGlvbnMuc2tpcFJldHdlZXQgJiYgdHdlZXQuaGFzQXR0cmlidXRlKCAnZGF0YS1yZXR3ZWV0LWlkJyApICkgY29udGludWU7XG5cbiAgICAgIC8vIGZvcm1hdCB0aW1lXG4gICAgICBsZXQgZCA9IG5ldyBEYXRlKCB0aW1lICk7XG4gICAgICBsZXQgZGF0ZSA9IGQudG9EYXRlU3RyaW5nKCk7XG5cbiAgICAgIC8vIGFkZCB0d2VldCB0byBsaXN0IGFuZCB1cGRhdGUgYWNjb3VudCBpbmZvXG4gICAgICBvdXRwdXQucHVzaCggeyBpZCwgdWlkLCB0aW1lLCBkYXRlLCBuYW1lLCBoYW5kbGUsIGF2YXRhciwgdGV4dCwgbGluayB9ICk7XG4gICAgICBjb3VudCsrO1xuICAgIH1cbiAgICBpdGVtcyA9IG51bGw7XG4gICAgcmV0dXJuIG91dHB1dDtcbiAgfVxuXG4gIC8qKlxuICAgKiBDaGVjayBsYXN0IGZldGNoIHRpbWUgdG8gc2VlIGlmIGl0J3Mgb2sgdG8gZmV0Y2ggYWdhaW5cbiAgICovXG4gIF9jYW5GZXRjaCgpIHtcbiAgICBsZXQgbm93ICAgICAgPSBEYXRlLm5vdygpO1xuICAgIGxldCBlbGFwc2VkICA9IE1hdGguZmxvb3IoICggbm93IC0gdGhpcy5sYXN0ICkgLyAxMDAwICk7XG4gICAgbGV0IGRlbGF5ICAgID0gdGhpcy5fb3B0aW9ucy5mZXRjaERlbGF5IHwgMDtcblxuICAgIGlmICggdGhpcy5mZXRjaGluZyB8fCB0aGlzLmxhc3QgPj0gbm93ICkgcmV0dXJuIGZhbHNlOyAvLyBidXN5LCB3YWl0XG4gICAgaWYgKCBkZWxheSAmJiBlbGFwc2VkIDwgZGVsYXkgKSByZXR1cm4gZmFsc2U7IC8vIHRvbyBzb29uLCB3YWl0XG4gICAgcmV0dXJuIHRydWU7IC8vIGxvb2tzIGdvb2RcbiAgfVxuXG4gIC8qKlxuICAgKiBDbGVhbiB0d2VldCB0ZXh0XG4gICAqIEBwYXJhbSB7c3RyaW5nfSAgdGV4dCAgU3RyaWduIHRvIGNsZWFuXG4gICAqL1xuICBfY2xlYW5Ud2VldCggdGV4dCApIHtcbiAgICByZXR1cm4gU3RyaW5nKCB0ZXh0IHx8ICcnIClcbiAgICAucmVwbGFjZSggLyhbXlxcc10rKShodHRwcz9cXDp8cGljXFwuKS9nLCAnJDEgJDInICkgLy8gYWRkIHNwYWNlIGFyb3VuZCBsaW5rc1xuICAgIC5yZXBsYWNlKCAncGljLnR3aXR0ZXInLCAnaHR0cHM6Ly9waWMudHdpdHRlcicgKSAvLyBmaXggc29tZSBsaW5rcyB3aXRob3V0IHByb3RvXG4gICAgLnJlcGxhY2UoIC8oW1xcYFxcJ1xc4oCZXSspL2csIFwiJ1wiICkgLy8gbm9ybWFsaXplIGFwb3N0cm9waGVzXG4gICAgLnJlcGxhY2UoIC8oW1xc4oCcXFzigJ1cXOKAnFxc4oCdXFxcIl0rKS9nLCAnXCInICkgLy8gbm9ybWFsaXplIHF1b3Rlc1xuICAgIC5yZXBsYWNlKCAvW1xc4oCmXFwjXFwkXSsvZywgJyAnICkgLy8gcmVtb3ZlIHNvbWUganVuayBjaGFyc1xuICAgIC5yZXBsYWNlKCAvW1xcdFxcclxcblxcc1xcdUZFRkZcXHhBMF0rL2csICcgJyApLnRyaW0oKTsgLy8gY29sbGFwc2Ugd2hpdGVzcGFjZVxuICB9XG5cbiAgLyoqXG4gICAqIENsZWFuIGh0bWwgY29udGVudFxuICAgKiBAcGFyYW0ge3N0cmluZ30gIGh0bWwgIEhUTUwgdGV4dCB0byBjbGVhblxuICAgKi9cbiAgX2NsZWFuSHRtbCggaHRtbCApIHtcbiAgICByZXR1cm4gU3RyaW5nKCBodG1sIHx8ICcnIClcbiAgICAucmVwbGFjZSggLzwoc3R5bGV8c2NyaXB0KVtePl0qPig/Oig/ITxcXC8oc3R5bGV8c2NyaXB0KT4pW15dKSo8XFwvKHN0eWxlfHNjcmlwdCk+L2dpbSwgJycgKVxuICAgIC5yZXBsYWNlKCAvW1xcclxcblxcc1xcdF0rL2csICcgJyApXG4gICAgLnRyaW0oKTtcbiAgfVxuXG59XG4iLCIvKipcbiAqIENvbW1vbiB1dGlsc1xuICovXG5tb2R1bGUuZXhwb3J0cyA9IHtcblxuICAvLyBjb252ZXJ0IHVybCBzdHJpbmcgaW50byBhbiBhbmNob3IgZWxlbWVudCAocGFyc2VyKVxuICBwYXJzZVVybCggdXJsLCBwcm9wICkge1xuICAgIGxldCBsaW5rID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCggJ2EnICk7XG4gICAgbGluay5ocmVmID0gdXJsO1xuICAgIGxldCBkYXRhID0gbGlua1sgcHJvcCBdIHx8ICcnO1xuICAgIGxpbmsgPSBudWxsO1xuICAgIHJldHVybiBkYXRhO1xuICB9LFxuXG4gIC8vIGNvbnZlcnQgVVJMcyBpbnRvIGNsaWNrYWJsZSBsaW5rc1xuICBsaW5rVXJsKCB0ZXh0ICkge1xuICAgIHJldHVybiBTdHJpbmcoIHRleHQgfHwgJycgKS5yZXBsYWNlKCAvKGh0dHBzP1xcOlxcL1xcL1tcXHdcXC1cXC5cXD9cXD1cXCZcXCVcXC9cXCNdKykvZ2ksICc8YSBocmVmPVwiJDFcIiB0YXJnZXQ9XCJfYmxhbmtcIj4kMTwvYT4nICk7XG4gIH0sXG5cbiAgLy8gY29udmVydCBodG1sIHRhZ3MgdG8gdGV4dCBjb250ZW50XG4gIHN0cmlwSHRtbCggdGV4dCwgcmVtb3ZlVXJscyApIHtcbiAgICBsZXQgZGl2ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCggJ2RpdicgKTtcbiAgICBkaXYuaW5uZXJIVE1MID0gU3RyaW5nKCB0ZXh0IHx8ICcnICk7XG4gICAgbGV0IG91dHB1dCA9IFN0cmluZyggZGl2LnRleHRDb250ZW50IHx8IGRpdi5pbm5lclRleHQgfHwgJycgKTtcbiAgICBpZiAoIHJlbW92ZVVybHMgKSBvdXRwdXQgPSBvdXRwdXQucmVwbGFjZSggLyhodHRwcz9cXDpcXC9cXC9bXFx3XFwtXFwuXFw/XFw9XFwmXFwlXFwvXFwjXSspL2dpLCAnJyApO1xuICAgIHJldHVybiBvdXRwdXQ7XG4gIH0sXG5cbiAgLy8gY29udmVydCByZWxhdGl2ZSBwYXRoIHRvIGZ1bGwgdXJsXG4gIGZ1bGxVcmwoIHJlbHBhdGggKSB7XG4gICAgaWYgKCAvXihbXFx3XFwtXStcXDopP1xcL1xcLy4qJC8udGVzdCggcmVscGF0aCApICkgcmV0dXJuIHJlbHBhdGg7XG4gICAgbGV0IGxvYyAgPSB3aW5kb3cubG9jYXRpb247XG4gICAgbGV0IHBhdGggPSBTdHJpbmcoIGxvYy5wYXRobmFtZSB8fCAnJyApLnJlcGxhY2UoIC9cXC8rJC9nLCAnJyApO1xuICAgIGxldCByZWwgID0gU3RyaW5nKCByZWxwYXRoIHx8ICcnICkucmVwbGFjZSggL15cXC8rL2csICcnICk7XG4gICAgcmV0dXJuIGxvYy5wcm90b2NvbCArJy8vJysgbG9jLmhvc3QgKyBwYXRoICsnLycrIHJlbDtcbiAgfSxcblxuICAvLyBwbGF5IGF1ZGlvIGZpbGVcbiAgcGxheUF1ZGlvKCBmaWxlLCB2b2wgKSB7XG4gICAgaWYgKCAhZmlsZSB8fCB0eXBlb2YgZmlsZSAhPT0gJ3N0cmluZycgKSByZXR1cm47XG4gICAgLy8gbm9ybWFsaXplIHZvbHVtZVxuICAgIHZvbCA9IHBhcnNlRmxvYXQoIHZvbCApIHx8IDE7XG4gICAgdm9sID0gKCB2b2wgPiAxICkgPyB2b2wgLyAxMDAgOiB2b2w7XG4gICAgdm9sID0gKCB2b2wgPiAxIHx8IHZvbCA8IDAgKSA/IDEgOiB2b2w7XG4gICAgLy8gbG9hZCBhbmQgcGxheSBhdWRpb1xuICAgIGxldCBhdWRpbyA9IG5ldyBBdWRpbygpO1xuICAgIGF1ZGlvLnNyYyA9IHRoaXMuZnVsbFVybCggZmlsZSApO1xuICAgIGF1ZGlvLnZvbHVtZSA9IHZvbDtcbiAgICBhdWRpby5jcm9zc09yaWdpbiA9ICdhbm9ueW1vdXMnO1xuICAgIGF1ZGlvLmFkZEV2ZW50TGlzdGVuZXIoICdjYW5wbGF5dGhyb3VnaCcsIGUgPT4ge1xuICAgICAgdHJ5IHsgYXVkaW8ucGxheSgpOyB9IGNhdGNoKCBlcnIgKSB7fVxuICAgIH0pO1xuICAgIGF1ZGlvLmxvYWQoKTtcbiAgfSxcblxuICAvLyBjb3B5IHRleHQgdG8gY2xpcGJvYXJkXG4gIGNvcHlUZXh0KCB0ZXh0ICkge1xuICAgIGxldCBlbG0gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCAnaW5wdXQnICk7XG4gICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZCggZWxtICk7XG4gICAgZWxtLnZhbHVlID0gU3RyaW5nKCB0ZXh0IHx8ICcnICkudHJpbSgpO1xuICAgIGVsbS5zZWxlY3QoKTtcbiAgICBzZXRUaW1lb3V0KCAoKSA9PiBlbG0ucmVtb3ZlKCksIDEwMDAgKTtcbiAgICByZXR1cm4gZG9jdW1lbnQuZXhlY0NvbW1hbmQoICdDb3B5JyApO1xuICB9LFxuXG4gIC8vIGNsYW1wIGEgbnVtYmVyIGJldHdlZW4gbWluIGFuZCBtYXhcbiAgY2xhbXAoIG51bSwgbWluLCBtYXggKSB7XG4gICAgcmV0dXJuIE1hdGgubWluKCBNYXRoLm1heCggbnVtLCBtaW4gKSwgbWF4ICk7XG4gIH0sXG5cbiAgLy8gY3V0IHBhcnQgb2YgYSBzdHJpbmdcbiAgbGltaXQoIHN0ciwgbGVuZ3RoLCBhcHBlbmQgKSB7XG4gICAgc3RyICAgID0gU3RyaW5nKCBzdHIgKTtcbiAgICBsZW5ndGggPSBwYXJzZUludCggbGVuZ3RoICkgfHwgNTA7XG4gICAgYXBwZW5kID0gU3RyaW5nKCBhcHBlbmQgfHwgJycgKTtcbiAgICByZXR1cm4gKCBzdHIubGVuZ3RoID4gbGVuZ3RoICkgPyBzdHIuc3Vic3RyaW5nKCAwLCBsZW5ndGggKSArIGFwcGVuZCA6IHN0cjtcbiAgfSxcblxuICAvLyBhbHdheSBrZWVwIGEgc3RyaW5nIGF0IGEgY2VydGFpbiBsZW5ndGhcbiAgZmlsbCggc3RyLCBsZW5ndGgsIGNoYXIsIGFwcGVuZCApIHtcbiAgICBzdHIgICAgPSBTdHJpbmcoIHN0ciApO1xuICAgIGxlbmd0aCA9IHBhcnNlSW50KCBsZW5ndGggKSB8fCAyMDtcbiAgICBjaGFyICAgPSBTdHJpbmcoIGNoYXIgfHwgJyAnICk7XG4gICAgYXBwZW5kID0gU3RyaW5nKCBhcHBlbmQgfHwgJycgKTtcbiAgICBpZiAoIHN0ci5sZW5ndGggPiBsZW5ndGggKSByZXR1cm4gc3RyLnN1YnN0cmluZyggMCwgKCBsZW5ndGggLSAzICkgKSArICcuLi4nO1xuICAgIHJldHVybiBzdHIgKyBjaGFyLnJlcGVhdCggbGVuZ3RoIC0gc3RyLmxlbmd0aCApICsgYXBwZW5kO1xuICB9LFxuXG4gIC8vIGdldCBub3VuIHdvcmQgZm9yIGEgbnVtYmVyXG4gIG5vdW4oIG51bSwgc2luZ3VsYXIsIHBsdXRhbCwgYXBwZW5kICkge1xuICAgIGFwcGVuZCA9IFN0cmluZyggYXBwZW5kIHx8ICcnICk7XG4gICAgcmV0dXJuIFN0cmluZyggbnVtICsnICcrICggcGFyc2VGbG9hdCggbnVtICkgPT09IDEgPyBzaW5ndWxhciA6IHBsdXRhbCApICsnICcrIGFwcGVuZCApLnRyaW0oKTtcbiAgfSxcblxuICAvLyBmb3JtYXQgbnVtYmVyIHRvIG1vbmV5XG4gIG1vbmV5KCBudW0sIGZpeGVkICkge1xuICAgIG51bSAgID0gcGFyc2VGbG9hdCggbnVtICkgfHwgMDtcbiAgICBmaXhlZCA9IHBhcnNlSW50KCBmaXhlZCApIHx8IDA7XG4gICAgbGV0IG8gPSB7IHN0eWxlOiAnZGVjaW1hbCcsIG1pbmltdW1GcmFjdGlvbkRpZ2l0czogZml4ZWQsIG1heGltdW1GcmFjdGlvbkRpZ2l0czogZml4ZWQgfTtcbiAgICByZXR1cm4gbmV3IEludGwuTnVtYmVyRm9ybWF0KCAnZW4tVVMnLCBvICkuZm9ybWF0KCBudW0gKTtcbiAgfSxcblxuICAvLyBmaXhlZCBudW1iZXJzXG4gIGZpeGVkKCBudW0sIGRlY2ltYWxzICkge1xuICAgIGlmICggdHlwZW9mIGRlY2ltYWxzID09PSAnbnVtYmVyJyApIHJldHVybiBOdW1iZXIoIG51bSApLnRvRml4ZWQoIGRlY2ltYWxzICk7XG4gICAgaWYgKCAvKFVTRHxQQVh8REFJKS8udGVzdCggZGVjaW1hbHMgKSApIHJldHVybiB0aGlzLm1vbmV5KCBudW0sIDMgKTtcbiAgICByZXR1cm4gTnVtYmVyKCBudW0gKS50b0ZpeGVkKCA4ICk7XG4gIH0sXG5cbiAgLy8gZ2V0IGluZm8gYWJvdXQgaG93IGxvbmcgc29tZXRoaW5nIGhhcyBiZWVuXG4gIGVsYXBzZWQoIHNlY3MsIHN1ZmZpeCwgc2hvcnQgKSB7XG4gICAgc2VjcyA9IHBhcnNlSW50KCBzZWNzICkgfHwgMDtcbiAgICBpZiAoIHNob3J0ICYmIHNlY3MgPCA2MCApIHJldHVybiAnSnVzdCBub3cnO1xuICAgIGxldCBsaXN0ID0gW107XG4gICAgbGV0IGRhdGEgPSB7XG4gICAgICAnTSc6IE1hdGguZmxvb3IoIHNlY3MgLyAyNDE5MjAwICksXG4gICAgICAndyc6IE1hdGguZmxvb3IoIHNlY3MgLyA2MDQ4MDAgJSA0ICksXG4gICAgICAnZCc6IE1hdGguZmxvb3IoIHNlY3MgLyA4NjQwMCAlIDcgKSxcbiAgICAgICdoJzogTWF0aC5mbG9vciggc2VjcyAvIDM2MDAgJSAyNCApLFxuICAgICAgJ20nOiBNYXRoLmZsb29yKCBzZWNzIC8gNjAgJSA2MCApLFxuICAgIH07XG4gICAgaWYgKCAhc2hvcnQgKSBkYXRhLnMgPSBNYXRoLmZsb29yKCBzZWNzICUgNjAgKTtcbiAgICBPYmplY3Qua2V5cyggZGF0YSApLmZvckVhY2goIGsgPT4geyBpZiAoIGRhdGFbIGsgXSApIGxpc3QucHVzaCggZGF0YVsgayBdICsgayApOyB9ICk7XG4gICAgaWYgKCBzdWZmaXggKSBsaXN0LnB1c2goIHN1ZmZpeCApO1xuICAgIHJldHVybiBsaXN0LmpvaW4oICcgJyApO1xuICB9LFxuXG4gIC8vIGdldCBkYXRhIGFib3V0IGN1cnJlbnQgZGF0ZSBhbmQgdGltZVxuICBkYXRlRGF0YSggdGltZSApIHtcbiAgICBsZXQgbm93ID0gRGF0ZS5ub3coKTtcblxuICAgIGlmICggdGltZSApIHtcbiAgICAgIC8vIHRpbWVzdGFtcCBvciBkYXRlc3RyaW5nLCBrZWVwIGFzIGlzXG4gICAgICBpZiAoIHR5cGVvZiB0aW1lID09PSAnbnVtYmVyJyB8fCAvXltcXHdcXC1cXCtcXDpdKyQvLnRlc3QoIHRpbWUgKSApIHtcbiAgICAgICAgbm93ID0gdGltZTtcbiAgICAgIH1cbiAgICAgIC8vIG90aGVyIHN0cmluZywgYXNzdW1lIHRpbWV6b25lXG4gICAgICBlbHNlIGlmICggdHlwZW9mIHRpbWUgPT09ICdzdHJpbmcnICkge1xuICAgICAgICBub3cgPSBuZXcgRGF0ZSgpLnRvTG9jYWxlU3RyaW5nKCAnZW4tVVMnLCB7IHRpbWUgfSApO1xuICAgICAgfVxuICAgIH1cbiAgICBsZXQgX3AgICAgICA9ICggbiApID0+ICggbiA8IDEwICkgPyAnMCcrIG4gOiAnJysgbjtcbiAgICBsZXQgZGF0ZSAgICA9IG5ldyBEYXRlKCBub3cgKTtcbiAgICBsZXQgbW9udGggICA9IFsnSmFuJywgJ0ZlYicsICdNYXInLCAnQXByJywgJ01heScsICdKdW4nLCAnSnVsJywgJ0F1ZycsICdTZXAnLCAnT2N0JywgJ05vdicsICdEZWMnXVsgZGF0ZS5nZXRNb250aCgpIF07XG4gICAgbGV0IHllYXIgICAgPSBkYXRlLmdldEZ1bGxZZWFyKCk7XG4gICAgbGV0IGRheSAgICAgPSBfcCggZGF0ZS5nZXREYXRlKCkgKTtcbiAgICBsZXQgbWludXRlICA9IF9wKCBkYXRlLmdldE1pbnV0ZXMoKSApO1xuICAgIGxldCBzZWNvbmQgID0gX3AoIGRhdGUuZ2V0U2Vjb25kcygpICk7XG4gICAgbGV0IGZ1bGxoICAgPSBkYXRlLmdldEhvdXJzKCk7XG4gICAgbGV0IGFtcG0gICAgPSAoIGZ1bGxoID4gMTIgKSA/ICdQTScgOiAnQU0nO1xuICAgIGxldCBob3VyICAgID0gKCBmdWxsaCA+IDEyICkgPyAoIGZ1bGxoIC0gMTIgKSA6IGZ1bGxoO1xuICAgIGhvdXIgICAgICAgID0gX3AoIGhvdXIgPT09IDAgPyAxMiA6IGhvdXIgKTtcbiAgICByZXR1cm4geyBtb250aCwgZGF5LCB5ZWFyLCBob3VyLCBtaW51dGUsIHNlY29uZCwgYW1wbSB9O1xuICB9LFxuXG4gIC8vIGdldCByZWFkYWJsZSBkYXRlXG4gIGRhdGUoIHRpbWUsIGZ1bGwgKSB7XG4gICAgbGV0IHsgbW9udGgsIGRheSwgeWVhciwgaG91ciwgbWludXRlLCBzZWNvbmQsIGFtcG0gfSA9IHRoaXMuZGF0ZURhdGEoIHRpbWUgKTtcbiAgICBsZXQgb3V0ID0gWyBtb250aCArJy8nKyBkYXkgKycvJysgeWVhciBdO1xuICAgIGlmICggZnVsbCApIG91dC5wdXNoKCBob3VyICsnOicrIG1pbnV0ZSArJzonKyBzZWNvbmQsIGFtcG0gKTtcbiAgICByZXR1cm4gb3V0LmpvaW4oICcgJyApO1xuICB9LFxuXG4gIC8vIGdldCBjdXJyZW50IHRpbWVcbiAgdGltZSggdGltZSApIHtcbiAgICBsZXQgeyBob3VyLCBtaW51dGUsIHNlY29uZCwgYW1wbSB9ID0gdGhpcy5kYXRlRGF0YSggdGltZSApO1xuICAgIHJldHVybiBob3VyICsnOicrIG1pbnV0ZSArJzonKyBzZWNvbmQgKycgJysgYW1wbTtcbiAgfSxcblxuICAvLyBjYWxjdWxhdGUgcGVyY2VudCBjaGFuZ2VcbiAgcGVyY2VudCggY3VycmVudCwgbGFzdCwgdG9OdW0gKSB7XG4gICAgbGV0IGlzbnVtICAgPSBCb29sZWFuKCBsYXN0ID4gMCApO1xuICAgIGxldCBpc3VwICAgID0gQm9vbGVhbiggY3VycmVudCA+PSBsYXN0ICk7XG4gICAgbGV0IGNoYW5nZSAgPSBpc3VwICA/ICggY3VycmVudCAtIGxhc3QgKSA6ICggbGFzdCAtIGN1cnJlbnQgKTtcbiAgICBsZXQgcGVyY2VudCA9IGlzbnVtID8gKCBjaGFuZ2UgLyBsYXN0ICogMTAwLjAgKSA6IDAuMDtcbiAgICBsZXQgc2lnbiAgICA9IGlzdXAgID8gJysnIDogJy0nO1xuICAgIGxldCBhcnJvdyAgID0gaXN1cCAgPyAn4payJyA6ICfilrwnO1xuICAgIGxldCBjb2xvciAgID0gaXN1cCAgPyAnZ3JlZW4nIDogJ3JlZCc7XG4gICAgaWYgKCB0b051bSA9PT0gdHJ1ZSApIHJldHVybiArTnVtYmVyKCBzaWduICsgcGVyY2VudCApLnRvRml4ZWQoIDMgKTtcbiAgICByZXR1cm4geyBjaGFuZ2UsIHBlcmNlbnQsIHNpZ24sIGFycm93LCBjb2xvciB9O1xuICB9LFxuXG4gIC8vIGNhbGMgY2hhcnQgcG9pbnRzIGZvciBnaXZlbiBkaW1lbnNpb25zIGFuZCB2YWx1ZXNcbiAgcG9pbnRzKCB3aWR0aCwgaGVpZ2h0LCB2YWx1ZXMgKSB7XG4gICAgd2lkdGggID0gcGFyc2VGbG9hdCggd2lkdGggKSB8fCAwO1xuICAgIGhlaWdodCA9IHBhcnNlRmxvYXQoIGhlaWdodCApIHx8IDA7XG4gICAgdmFsdWVzID0gQXJyYXkuaXNBcnJheSggdmFsdWVzICkgPyB2YWx1ZXMgOiBbXTtcbiAgICB2YWx1ZXMgPSB2YWx1ZXMubWFwKCBuID0+IHBhcnNlRmxvYXQoIG4gKSB8fCAwICk7XG5cbiAgICBsZXQgbWluICAgPSB2YWx1ZXMucmVkdWNlKCAoIG1pbiwgdmFsICkgPT4gdmFsIDwgbWluID8gdmFsIDogbWluLCB2YWx1ZXNbIDAgXSApO1xuICAgIGxldCBtYXggICA9IHZhbHVlcy5yZWR1Y2UoICggbWF4LCB2YWwgKSA9PiB2YWwgPiBtYXggPyB2YWwgOiBtYXgsIHZhbHVlc1sgMCBdICk7XG4gICAgbGV0IGxlbiAgID0gdmFsdWVzLmxlbmd0aDtcbiAgICBsZXQgaGFsZiAgPSBoZWlnaHQgLyAyO1xuICAgIGxldCByYW5nZSA9ICggbWF4ID4gbWluICkgPyAoIG1heCAtIG1pbiApIDogaGVpZ2h0O1xuICAgIGxldCBnYXAgICA9ICggbGVuID4gMSApID8gKCB3aWR0aCAvICggbGVuIC0gMSApICkgOiAxO1xuICAgIGxldCBvdXQgICA9IFtdO1xuXG4gICAgZm9yICggbGV0IGkgPSAwOyBpIDwgbGVuOyArK2kgKSB7XG4gICAgICBsZXQgZCA9IHZhbHVlc1sgaSBdO1xuICAgICAgbGV0IHZhbCA9IDIgKiAoICggZCAtIG1pbiApIC8gcmFuZ2UgLSAwLjUgKTtcbiAgICAgIGxldCB4ID0gaSAqIGdhcDtcbiAgICAgIGxldCB5ID0gLXZhbCAqIGhhbGYgKiAwLjggKyBoYWxmO1xuICAgICAgb3V0LnB1c2goIHsgeCwgeSB9ICk7XG4gICAgfVxuICAgIHJldHVybiBvdXQ7XG4gIH0sXG5cbiAgLy8gY29tcHV0ZSBwbGFjZW1lbnQgZm9yIGFuIGFic29sdXRlIGJveCBvbiB0aGUgc2NyZWVuXG4gIGJveFBvc2l0aW9uKCB0cmlnZ2VyRWxtICkge1xuICAgIGxldCBbIHRvcCwgcmlnaHQsIGJvdHRvbSwgbGVmdCBdID0gWyB0cnVlLCBmYWxzZSwgZmFsc2UsIHRydWUgXTtcblxuICAgIGlmICggdHJpZ2dlckVsbSBpbnN0YW5jZW9mIEhUTUxFbGVtZW50ICkge1xuICAgICAgbGV0IGJveCAgICAgPSB0cmlnZ2VyRWxtLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgbGV0IHBvc3ggICAgPSBib3gubGVmdCArICggdHJpZ2dlckVsbS5vZmZzZXRXaWR0aCAvIDIgKTtcbiAgICAgIGxldCBwb3N5ICAgID0gYm94LnRvcCArICggdHJpZ2dlckVsbS5vZmZzZXRIZWlnaHQgLyAyICk7XG4gICAgICBsZXQgY2VudGVyeCA9ICggd2luZG93LmlubmVyV2lkdGggLyAyICk7XG4gICAgICBsZXQgY2VudGVyeSA9ICggd2luZG93LmlubmVySGVpZ2h0IC8gMiApO1xuXG4gICAgICB0b3AgICAgPSAoIHBvc3kgPCBjZW50ZXJ5ICkgPyB0cnVlIDogZmFsc2U7XG4gICAgICByaWdodCAgPSAoIHBvc3ggPiBjZW50ZXJ4ICkgPyB0cnVlIDogZmFsc2U7XG4gICAgICBib3R0b20gPSAoIHBvc3kgPiBjZW50ZXJ5ICkgPyB0cnVlIDogZmFsc2U7XG4gICAgICBsZWZ0ICAgPSAoIHBvc3ggPCBjZW50ZXJ4ICkgPyB0cnVlIDogZmFsc2U7XG4gICAgICByZXR1cm4geyB0b3AsIHJpZ2h0LCBib3R0b20sIGxlZnQgfTtcbiAgICB9XG4gIH0sXG5cbiAgLy8gY2hlY2sgYSBrZXktcHJlc3MgZXZlbnQgZm9yIHNvbWUgY29tbW9uIGtleXMgYmVpbmcgcHJlc3NlZFxuICBrZXlib2FyZCggZSApIHtcbiAgICBsZXQgY29kZSA9IGUua2V5Q29kZSB8fCBlLmtleSB8fCAwO1xuICAgIGxldCB1cCAgICAgPSAoIGNvZGUgPT09IDM4ICk7XG4gICAgbGV0IGRvd24gICA9ICggY29kZSA9PT0gNDAgKTtcbiAgICBsZXQgbGVmdCAgID0gKCBjb2RlID09PSAzNyApO1xuICAgIGxldCByaWdodCAgPSAoIGNvZGUgPT09IDM5ICk7XG4gICAgbGV0IGJhY2sgICA9ICggY29kZSA9PT0gOCApO1xuICAgIGxldCBlc2NhcGUgPSAoIGNvZGUgPT09IDI3ICk7XG4gICAgbGV0IHNwYWNlICA9ICggY29kZSA9PT0gMzIgKTtcbiAgICBsZXQgZW50ZXIgID0gKCBjb2RlID09PSAxMyApO1xuICAgIHJldHVybiB7IHVwLCBkb3duLCBsZWZ0LCByaWdodCwgYmFjaywgZXNjYXBlLCBzcGFjZSwgZW50ZXIgfTtcbiAgfSxcblxuICAvLyBzaHVmZmxlIGFuIGFycmF5XG4gIHNodWZmbGUoIG8gKSB7XG4gICAgZm9yICggbGV0IGosIHgsIGkgPSBvLmxlbmd0aDsgaTsgaiA9IHBhcnNlSW50KCBNYXRoLnJhbmRvbSgpICogaSApLCB4ID0gb1stLWldLCBvW2ldID0gb1tqXSwgb1tqXSA9IHggKTtcbiAgICByZXR1cm4gbztcbiAgfSxcblxuICAvLyBkZWVwIG1lcmdlIG9iaiBhcmd1bWVudHNcbiAgZGVlcE1lcmdlKCl7XG4gICAgZm9yICggbGV0IGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrICkge1xuICAgICAgZm9yICggbGV0IGtleSBpbiBhcmd1bWVudHNbIGkgXSApXG4gICAgICAgIGlmICggYXJndW1lbnRzWyBpIF0uaGFzT3duUHJvcGVydHkoIGtleSApICkge1xuICAgICAgICAgIGlmICggdHlwZW9mIGFyZ3VtZW50c1sgMCBdWyBrZXkgXSA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIGFyZ3VtZW50c1sgaSBdWyBrZXkgXSA9PT0gJ29iamVjdCcgKSB7XG4gICAgICAgICAgICB0aGlzLmRlZXBNZXJnZSggYXJndW1lbnRzWyAwIF1bIGtleSBdLCBhcmd1bWVudHNbIGkgXVsga2V5IF0gKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgYXJndW1lbnRzWyAwIF1bIGtleSBdID0gYXJndW1lbnRzWyBpIF1bIGtleSBdO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIHJldHVybiBhcmd1bWVudHNbIDAgXTtcbiAgfSxcblxuICAvLyBzZWFyY2ggb2JqZWN0cyBpbiBhIGxpc3QgYnkga2V5IGFuZCBzZWFyY2ggdGV4dFxuICBzZWFyY2goIGxpc3QsIGtleSwgdGV4dCwgZnVsbHdvcmQsIGZ1bGxjYXNlICkge1xuICAgIHRleHQgPSBTdHJpbmcoIHRleHQgfHwgJycgKS5yZXBsYWNlKCAvW15cXHdcXHNcXHxdKy9nLCAnJyApO1xuXG4gICAgaWYgKCB0ZXh0Lmxlbmd0aCA+IDEgKSB7XG4gICAgICBsZXQgc2VhcmNoICA9IGZ1bGx3b3JkID8gJ1xcXFxiJysgdGV4dC5yZXBsYWNlKCAvW1xcfF0rL2csICdcXFxcYnxcXFxcYicgKSArJ1xcXFxiJyA6IHRleHQ7XG4gICAgICBsZXQgb3B0aW9ucyA9IGZ1bGxjYXNlID8gJ2cnIDogJ2dpJztcbiAgICAgIGxldCByZWdleCAgID0gbmV3IFJlZ0V4cCggc2VhcmNoLCBvcHRpb25zICk7XG4gICAgICBsZXQgY291bnQgICA9IGxpc3QubGVuZ3RoO1xuICAgICAgbGV0IG91dHB1dCAgPSBbXTtcblxuICAgICAgd2hpbGUgKCBjb3VudC0tICkge1xuICAgICAgICBpZiAoIFN0cmluZyggbGlzdFsgY291bnQgXVsga2V5IF0gfHwgJycgKS5zZWFyY2goIHJlZ2V4ICkgPCAwICkgY29udGludWU7XG4gICAgICAgIG91dHB1dC5wdXNoKCBsaXN0WyBjb3VudCBdICk7XG4gICAgICB9XG4gICAgICByZXR1cm4gb3V0cHV0O1xuICAgIH1cbiAgICByZXR1cm4gbGlzdDtcbiAgfSxcblxuICAvLyBzb3J0IG9iamVjdHMgaW4gYW4gYXJyYXkgYnkgYSBrZXlcbiAgc29ydCggbGlzdCwga2V5LCBvcmRlciwgaWdub3JlICkge1xuICAgIHJldHVybiBsaXN0LnNvcnQoICggYSwgYiApID0+IHtcbiAgICAgIGlmICggYS5oYXNPd25Qcm9wZXJ0eSgga2V5ICkgKSB7XG5cbiAgICAgICAgbGV0IF9hID0gYVsga2V5IF07XG4gICAgICAgIGxldCBfYiA9IGJbIGtleSBdO1xuXG4gICAgICAgIGlmICggaWdub3JlICkgeyAvLyBzb3J0IHN0cmluZ3MgdXNpbmcgc2FtZSBjYXNlXG4gICAgICAgICAgX2EgPSAoIHR5cGVvZiBfYSA9PT0gJ3N0cmluZycgKSA/IF9hLnRvVXBwZXJDYXNlKCkgOiBfYTtcbiAgICAgICAgICBfYiA9ICggdHlwZW9mIF9iID09PSAnc3RyaW5nJyApID8gX2IudG9VcHBlckNhc2UoKSA6IF9iO1xuICAgICAgICB9XG4gICAgICAgIGlmICggb3JkZXIgPT09ICdhc2MnICkge1xuICAgICAgICAgIGlmICggX2EgPCBfYiApIHJldHVybiAtMTtcbiAgICAgICAgICBpZiAoIF9hID4gX2IgKSByZXR1cm4gMTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIG9yZGVyID09PSAnZGVzYycgKSB7XG4gICAgICAgICAgaWYgKCBfYSA+IF9iICkgcmV0dXJuIC0xO1xuICAgICAgICAgIGlmICggX2EgPCBfYiApIHJldHVybiAxO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gMDtcbiAgICB9KTtcbiAgfSxcblxuICAvLyByZW1vdmUgaXRlbXMgZnJvbSB0aGUgc3RhcnQgb2YgYSBsaXN0XG4gIHRyaW1MZWZ0KCBsaXN0LCBtYXggKSB7XG4gICAgcmV0dXJuICggbGlzdC5sZW5ndGggPiBtYXggKSA/IGxpc3Quc2xpY2UoIGxpc3QubGVuZ3RoIC0gbWF4ICkgOiBsaXN0O1xuICB9LFxuXG4gIC8vIHJlbW92ZSBpdGVtcyBmcm9tIHRoZSBlbmQgb2YgYSBsaXN0XG4gIHRyaW1SaWdodCggbGlzdCwgbWF4ICkge1xuICAgIHJldHVybiAoIGxpc3QubGVuZ3RoID4gbWF4ICkgPyBsaXN0LnNsaWNlKCAwLCBtYXggKSA6IGxpc3Q7XG4gIH0sXG5cbiAgLy8gY3JlYXRlIHVuaXF1ZSBoYXNoIGZyb20gYSBzdHJpbmdcbiAgdW5pcXVlKCBzdHIgKSB7XG4gICAgc3RyID0gU3RyaW5nKCBzdHIgfHwgJycgKS5yZXBsYWNlKCAvW1xcclxcblxcdFxcc10rL2csICcgJyApLnRyaW0oKTtcbiAgICBsZXQgaGFzaCA9IDUzODEsIGkgPSBzdHIubGVuZ3RoO1xuICAgIHdoaWxlICggLS1pICkgaGFzaCA9ICggaGFzaCAqIDMzICkgXiBzdHIuY2hhckNvZGVBdCggaSApO1xuICAgIHJldHVybiAndW5xXycgKyAoIGhhc2ggPj4+IDAgKTtcbiAgfSxcblxuICAvLyByYW5kb20gc3RyaW5nIGZvciBhIGdpdmVuIGxlbmd0aFxuICByYW5kU3RyaW5nKCBsZW5ndGggKSB7XG4gICAgbGV0IGNoYXJzICA9ICdhYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ekFCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaMDEyMzQ1Njc4OSc7XG4gICAgbGV0IHRvdGFsICA9IHBhcnNlSW50KCBsZW5ndGggKSB8fCAxMDtcbiAgICBsZXQgb3V0cHV0ID0gJyc7XG5cbiAgICB3aGlsZSAoIHRvdGFsICkge1xuICAgICAgb3V0cHV0ICs9IGNoYXJzLmNoYXJBdCggTWF0aC5mbG9vciggTWF0aC5yYW5kb20oKSAqIGNoYXJzLmxlbmd0aCApICk7XG4gICAgICB0b3RhbC0tO1xuICAgIH1cbiAgICByZXR1cm4gb3V0cHV0O1xuICB9LFxuXG4gIC8vIGdldCBhIHVuaXF1ZSBJRCBzdHJpbmcgdGhhdCB1c2VzIHRoZSBjdXJyZW50IHRpbWVzdGFtcCBhbmQgYSByYW5kb20gdmFsdWVcbiAgaWRTdHJpbmcoKSB7XG4gICAgcmV0dXJuICggRGF0ZS5ub3coKS50b1N0cmluZyggMzYgKSArIE1hdGgucmFuZG9tKCkudG9TdHJpbmcoIDM2ICkuc3Vic3RyKCAyLCA1ICkgKS50b1VwcGVyQ2FzZSgpO1xuICB9LFxuXG59XG4iLCIvKipcclxuICogVmlld3BvcnQgT2JqZWN0LlxyXG4gKiBIZWxwZXIgZm9yIHdvcmtpbmcgd2l0aCB2aWV3cG9ydCBkYXRhLlxyXG4gKi9cclxuY29uc3QgX3cgPSB3aW5kb3cgfHwge307XHJcbmNvbnN0IF9zID0gd2luZG93LnNjcmVlbiB8fCB7fTtcclxuY29uc3QgX2QgPSBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQgfHwge307XHJcbmNvbnN0IF9iID0gZG9jdW1lbnQuYm9keSB8fCB7fTtcclxuXHJcbmV4cG9ydCBkZWZhdWx0IHtcclxuICBzY3JlZW5XaWR0aDogZnVuY3Rpb24oKSB7XHJcbiAgICByZXR1cm4gTWF0aC5tYXgoIDAsIF9zLndpZHRoIHx8IF9zLmF2YWlsV2lkdGggfHwgMCApO1xyXG4gIH0sXHJcbiAgc2NyZWVuSGVpZ2h0OiBmdW5jdGlvbigpIHtcclxuICAgIHJldHVybiBNYXRoLm1heCggMCwgX3MuaGVpZ2h0IHx8IF9zLmF2YWlsSGVpZ2h0IHx8IDAgKTtcclxuICB9LFxyXG4gIGNsaWVudFdpZHRoOiBmdW5jdGlvbigpIHtcclxuICAgIHJldHVybiBNYXRoLm1heCggMCwgX3cuaW5uZXJXaWR0aCB8fCBfZC5jbGllbnRXaWR0aCB8fCBfYi5jbGllbnRXaWR0aCB8fCAwICk7XHJcbiAgfSxcclxuICBjbGllbnRIZWlnaHQ6IGZ1bmN0aW9uKCkge1xyXG4gICAgcmV0dXJuIE1hdGgubWF4KCAwLCBfdy5pbm5lckhlaWdodCB8fCBfZC5jbGllbnRIZWlnaHQgfHwgX2IuY2xpZW50SGVpZ2h0IHx8IDAgKTtcclxuICB9LFxyXG4gIHBhZ2VXaWR0aDogZnVuY3Rpb24oKSB7XHJcbiAgICByZXR1cm4gTWF0aC5tYXgoIDAsIF9iLnNjcm9sbFdpZHRoIHx8IDAsIF9iLm9mZnNldFdpZHRoIHx8IDAsIF9kLmNsaWVudFdpZHRoIHx8IDAsIF9kLm9mZnNldFdpZHRoIHx8IDAsIF9kLnNjcm9sbFdpZHRoIHx8IDAgKTtcclxuICB9LFxyXG4gIHBhZ2VIZWlnaHQ6IGZ1bmN0aW9uKCkge1xyXG4gICAgcmV0dXJuIE1hdGgubWF4KCAwLCBfYi5zY3JvbGxIZWlnaHQgfHwgMCwgX2Iub2Zmc2V0SGVpZ2h0IHx8IDAsIF9kLmNsaWVudEhlaWdodCB8fCAwLCBfZC5vZmZzZXRIZWlnaHQgfHwgMCwgX2Quc2Nyb2xsSGVpZ2h0IHx8IDAgKTtcclxuICB9LFxyXG4gIHBhZ2VMZWZ0OiBmdW5jdGlvbigpIHtcclxuICAgIHJldHVybiBNYXRoLm1heCggMCwgX2QuY2xpZW50TGVmdCB8fCBfYi5jbGllbnRMZWZ0IHx8IDAgKTtcclxuICB9LFxyXG4gIHBhZ2VUb3A6IGZ1bmN0aW9uKCkge1xyXG4gICAgcmV0dXJuIE1hdGgubWF4KCAwLCBfZC5jbGllbnRUb3AgfHwgX2IuY2xpZW50VG9wIHx8IDAgKTtcclxuICB9LFxyXG4gIHNjcm9sbExlZnQ6IGZ1bmN0aW9uKCkge1xyXG4gICAgcmV0dXJuIE1hdGgubWF4KCAwLCBfdy5wYWdlWE9mZnNldCB8fCBfZC5zY3JvbGxMZWZ0IHx8IF9iLnNjcm9sbExlZnQgfHwgMCApIC0gdGhpcy5wYWdlTGVmdCgpO1xyXG4gIH0sXHJcbiAgc2Nyb2xsVG9wOiBmdW5jdGlvbigpIHtcclxuICAgIHJldHVybiBNYXRoLm1heCggMCwgX3cucGFnZVlPZmZzZXQgfHwgX2Quc2Nyb2xsVG9wIHx8IF9iLnNjcm9sbFRvcCB8fCAwICkgLSB0aGlzLnBhZ2VUb3AoKTtcclxuICB9LFxyXG4gIHNjcm9sbFJpZ2h0OiBmdW5jdGlvbigpIHsgLy8gbWF4IHJpZ2h0XHJcbiAgICByZXR1cm4gTWF0aC5tYXgoIDAsIE1hdGguZmxvb3IoIHRoaXMucGFnZVdpZHRoKCkgLSB0aGlzLmNsaWVudFdpZHRoKCkgKSApO1xyXG4gIH0sXHJcbiAgc2Nyb2xsQm90dG9tOiBmdW5jdGlvbigpIHsgLy8gbWF4IGJvdHRvbVxyXG4gICAgcmV0dXJuIE1hdGgubWF4KCAwLCBNYXRoLmZsb29yKCB0aGlzLnBhZ2VIZWlnaHQoKSAtIHRoaXMuY2xpZW50SGVpZ2h0KCkgKSApO1xyXG4gIH0sXHJcbiAgbW91c2VMZWZ0OiBmdW5jdGlvbiggZSApIHtcclxuICAgIHZhciB0ID0gKCBlICYmIGUuY2hhbmdlZFRvdWNoZXMgKSA/IGUuY2hhbmdlZFRvdWNoZXNbIDAgXSA6IHt9O1xyXG4gICAgcmV0dXJuIGUgPyBNYXRoLm1heCggMCwgdC5wYWdlWCB8fCBlLnBhZ2VYIHx8IGUuY2xpZW50WCB8fCAwICkgOiAwO1xyXG4gIH0sXHJcbiAgbW91c2VUb3A6IGZ1bmN0aW9uKCBlICkge1xyXG4gICAgdmFyIHQgPSAoIGUgJiYgZS5jaGFuZ2VkVG91Y2hlcyApID8gZS5jaGFuZ2VkVG91Y2hlc1sgMCBdIDoge307XHJcbiAgICByZXR1cm4gZSA/IE1hdGgubWF4KCAwLCB0LnBhZ2VZIHx8IGUucGFnZVkgfHwgZS5jbGllbnRZIHx8IDAgKSA6IDA7XHJcbiAgfSxcclxuICBjZW50ZXJYOiBmdW5jdGlvbiggZSApIHsgLy8gcG9pbnRlciBheGlzIGZyb20gY2VudGVyXHJcbiAgICByZXR1cm4gKCB0aGlzLm1vdXNlTGVmdCggZSApIC0gKCB0aGlzLmNsaWVudFdpZHRoKCkgLyAyICkgKTtcclxuICB9LFxyXG4gIGNlbnRlclk6IGZ1bmN0aW9uKCBlICkgeyAvLyBwb2ludGVyIGF4aXMgZnJvbSBjZW50ZXJcclxuICAgIHJldHVybiAoIHRoaXMubW91c2VUb3AoIGUgKSAtICggdGhpcy5jbGllbnRIZWlnaHQoKSAvIDIgKSApO1xyXG4gIH0sXHJcbiAgZWxlbWVudFdpZHRoOiBmdW5jdGlvbiggZSApIHsgLy8gYm9yZGVyLWJveFxyXG4gICAgcmV0dXJuIGUgPyBNYXRoLm1heCggMCwgZS5vZmZzZXRXaWR0aCB8fCAwICkgOiAwO1xyXG4gIH0sXHJcbiAgZWxlbWVudEhlaWdodDogZnVuY3Rpb24oIGUgKSB7IC8vIGJvcmRlci1ib3hcclxuICAgIHJldHVybiBlID8gTWF0aC5tYXgoIDAsIGUub2Zmc2V0SGVpZ2h0IHx8IDAgKSA6IDA7XHJcbiAgfSxcclxuICBlbGVtZW50TGVmdDogZnVuY3Rpb24oIGUgKSB7IC8vIGZyb20gd2luZG93XHJcbiAgICByZXR1cm4gZSA/IGUuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkubGVmdCA6IDA7XHJcbiAgfSxcclxuICBlbGVtZW50VG9wOiBmdW5jdGlvbiggZSApIHsgLy8gZnJvbSB3aW5kb3dcclxuICAgIHJldHVybiBlID8gZS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS50b3AgOiAwO1xyXG4gIH0sXHJcbiAgY2xhbXBWYWx1ZTogZnVuY3Rpb24oIHZhbHVlLCBtaW4sIG1heCApIHtcclxuICAgIHJldHVybiBNYXRoLm1heCggbWluLCBNYXRoLm1pbiggdmFsdWUsIG1heCApICk7XHJcbiAgfVxyXG59XHJcbiIsImV4cG9ydCBkZWZhdWx0IFwiaHR0cHM6Ly9mYXN0LXJlYWNoZXMtNTQzNTguaGVyb2t1YXBwLmNvbS9cIjsiLCIvKiFcbiAqIFZ1ZS5qcyB2Mi42LjE0XG4gKiAoYykgMjAxNC0yMDIxIEV2YW4gWW91XG4gKiBSZWxlYXNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG4gKi9cbi8qICAqL1xuXG52YXIgZW1wdHlPYmplY3QgPSBPYmplY3QuZnJlZXplKHt9KTtcblxuLy8gVGhlc2UgaGVscGVycyBwcm9kdWNlIGJldHRlciBWTSBjb2RlIGluIEpTIGVuZ2luZXMgZHVlIHRvIHRoZWlyXG4vLyBleHBsaWNpdG5lc3MgYW5kIGZ1bmN0aW9uIGlubGluaW5nLlxuZnVuY3Rpb24gaXNVbmRlZiAodikge1xuICByZXR1cm4gdiA9PT0gdW5kZWZpbmVkIHx8IHYgPT09IG51bGxcbn1cblxuZnVuY3Rpb24gaXNEZWYgKHYpIHtcbiAgcmV0dXJuIHYgIT09IHVuZGVmaW5lZCAmJiB2ICE9PSBudWxsXG59XG5cbmZ1bmN0aW9uIGlzVHJ1ZSAodikge1xuICByZXR1cm4gdiA9PT0gdHJ1ZVxufVxuXG5mdW5jdGlvbiBpc0ZhbHNlICh2KSB7XG4gIHJldHVybiB2ID09PSBmYWxzZVxufVxuXG4vKipcbiAqIENoZWNrIGlmIHZhbHVlIGlzIHByaW1pdGl2ZS5cbiAqL1xuZnVuY3Rpb24gaXNQcmltaXRpdmUgKHZhbHVlKSB7XG4gIHJldHVybiAoXG4gICAgdHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJyB8fFxuICAgIHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicgfHxcbiAgICAvLyAkZmxvdy1kaXNhYmxlLWxpbmVcbiAgICB0eXBlb2YgdmFsdWUgPT09ICdzeW1ib2wnIHx8XG4gICAgdHlwZW9mIHZhbHVlID09PSAnYm9vbGVhbidcbiAgKVxufVxuXG4vKipcbiAqIFF1aWNrIG9iamVjdCBjaGVjayAtIHRoaXMgaXMgcHJpbWFyaWx5IHVzZWQgdG8gdGVsbFxuICogT2JqZWN0cyBmcm9tIHByaW1pdGl2ZSB2YWx1ZXMgd2hlbiB3ZSBrbm93IHRoZSB2YWx1ZVxuICogaXMgYSBKU09OLWNvbXBsaWFudCB0eXBlLlxuICovXG5mdW5jdGlvbiBpc09iamVjdCAob2JqKSB7XG4gIHJldHVybiBvYmogIT09IG51bGwgJiYgdHlwZW9mIG9iaiA9PT0gJ29iamVjdCdcbn1cblxuLyoqXG4gKiBHZXQgdGhlIHJhdyB0eXBlIHN0cmluZyBvZiBhIHZhbHVlLCBlLmcuLCBbb2JqZWN0IE9iamVjdF0uXG4gKi9cbnZhciBfdG9TdHJpbmcgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nO1xuXG5mdW5jdGlvbiB0b1Jhd1R5cGUgKHZhbHVlKSB7XG4gIHJldHVybiBfdG9TdHJpbmcuY2FsbCh2YWx1ZSkuc2xpY2UoOCwgLTEpXG59XG5cbi8qKlxuICogU3RyaWN0IG9iamVjdCB0eXBlIGNoZWNrLiBPbmx5IHJldHVybnMgdHJ1ZVxuICogZm9yIHBsYWluIEphdmFTY3JpcHQgb2JqZWN0cy5cbiAqL1xuZnVuY3Rpb24gaXNQbGFpbk9iamVjdCAob2JqKSB7XG4gIHJldHVybiBfdG9TdHJpbmcuY2FsbChvYmopID09PSAnW29iamVjdCBPYmplY3RdJ1xufVxuXG5mdW5jdGlvbiBpc1JlZ0V4cCAodikge1xuICByZXR1cm4gX3RvU3RyaW5nLmNhbGwodikgPT09ICdbb2JqZWN0IFJlZ0V4cF0nXG59XG5cbi8qKlxuICogQ2hlY2sgaWYgdmFsIGlzIGEgdmFsaWQgYXJyYXkgaW5kZXguXG4gKi9cbmZ1bmN0aW9uIGlzVmFsaWRBcnJheUluZGV4ICh2YWwpIHtcbiAgdmFyIG4gPSBwYXJzZUZsb2F0KFN0cmluZyh2YWwpKTtcbiAgcmV0dXJuIG4gPj0gMCAmJiBNYXRoLmZsb29yKG4pID09PSBuICYmIGlzRmluaXRlKHZhbClcbn1cblxuZnVuY3Rpb24gaXNQcm9taXNlICh2YWwpIHtcbiAgcmV0dXJuIChcbiAgICBpc0RlZih2YWwpICYmXG4gICAgdHlwZW9mIHZhbC50aGVuID09PSAnZnVuY3Rpb24nICYmXG4gICAgdHlwZW9mIHZhbC5jYXRjaCA9PT0gJ2Z1bmN0aW9uJ1xuICApXG59XG5cbi8qKlxuICogQ29udmVydCBhIHZhbHVlIHRvIGEgc3RyaW5nIHRoYXQgaXMgYWN0dWFsbHkgcmVuZGVyZWQuXG4gKi9cbmZ1bmN0aW9uIHRvU3RyaW5nICh2YWwpIHtcbiAgcmV0dXJuIHZhbCA9PSBudWxsXG4gICAgPyAnJ1xuICAgIDogQXJyYXkuaXNBcnJheSh2YWwpIHx8IChpc1BsYWluT2JqZWN0KHZhbCkgJiYgdmFsLnRvU3RyaW5nID09PSBfdG9TdHJpbmcpXG4gICAgICA/IEpTT04uc3RyaW5naWZ5KHZhbCwgbnVsbCwgMilcbiAgICAgIDogU3RyaW5nKHZhbClcbn1cblxuLyoqXG4gKiBDb252ZXJ0IGFuIGlucHV0IHZhbHVlIHRvIGEgbnVtYmVyIGZvciBwZXJzaXN0ZW5jZS5cbiAqIElmIHRoZSBjb252ZXJzaW9uIGZhaWxzLCByZXR1cm4gb3JpZ2luYWwgc3RyaW5nLlxuICovXG5mdW5jdGlvbiB0b051bWJlciAodmFsKSB7XG4gIHZhciBuID0gcGFyc2VGbG9hdCh2YWwpO1xuICByZXR1cm4gaXNOYU4obikgPyB2YWwgOiBuXG59XG5cbi8qKlxuICogTWFrZSBhIG1hcCBhbmQgcmV0dXJuIGEgZnVuY3Rpb24gZm9yIGNoZWNraW5nIGlmIGEga2V5XG4gKiBpcyBpbiB0aGF0IG1hcC5cbiAqL1xuZnVuY3Rpb24gbWFrZU1hcCAoXG4gIHN0cixcbiAgZXhwZWN0c0xvd2VyQ2FzZVxuKSB7XG4gIHZhciBtYXAgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICB2YXIgbGlzdCA9IHN0ci5zcGxpdCgnLCcpO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyBpKyspIHtcbiAgICBtYXBbbGlzdFtpXV0gPSB0cnVlO1xuICB9XG4gIHJldHVybiBleHBlY3RzTG93ZXJDYXNlXG4gICAgPyBmdW5jdGlvbiAodmFsKSB7IHJldHVybiBtYXBbdmFsLnRvTG93ZXJDYXNlKCldOyB9XG4gICAgOiBmdW5jdGlvbiAodmFsKSB7IHJldHVybiBtYXBbdmFsXTsgfVxufVxuXG4vKipcbiAqIENoZWNrIGlmIGEgdGFnIGlzIGEgYnVpbHQtaW4gdGFnLlxuICovXG52YXIgaXNCdWlsdEluVGFnID0gbWFrZU1hcCgnc2xvdCxjb21wb25lbnQnLCB0cnVlKTtcblxuLyoqXG4gKiBDaGVjayBpZiBhbiBhdHRyaWJ1dGUgaXMgYSByZXNlcnZlZCBhdHRyaWJ1dGUuXG4gKi9cbnZhciBpc1Jlc2VydmVkQXR0cmlidXRlID0gbWFrZU1hcCgna2V5LHJlZixzbG90LHNsb3Qtc2NvcGUsaXMnKTtcblxuLyoqXG4gKiBSZW1vdmUgYW4gaXRlbSBmcm9tIGFuIGFycmF5LlxuICovXG5mdW5jdGlvbiByZW1vdmUgKGFyciwgaXRlbSkge1xuICBpZiAoYXJyLmxlbmd0aCkge1xuICAgIHZhciBpbmRleCA9IGFyci5pbmRleE9mKGl0ZW0pO1xuICAgIGlmIChpbmRleCA+IC0xKSB7XG4gICAgICByZXR1cm4gYXJyLnNwbGljZShpbmRleCwgMSlcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBDaGVjayB3aGV0aGVyIGFuIG9iamVjdCBoYXMgdGhlIHByb3BlcnR5LlxuICovXG52YXIgaGFzT3duUHJvcGVydHkgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xuZnVuY3Rpb24gaGFzT3duIChvYmosIGtleSkge1xuICByZXR1cm4gaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGtleSlcbn1cblxuLyoqXG4gKiBDcmVhdGUgYSBjYWNoZWQgdmVyc2lvbiBvZiBhIHB1cmUgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIGNhY2hlZCAoZm4pIHtcbiAgdmFyIGNhY2hlID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgcmV0dXJuIChmdW5jdGlvbiBjYWNoZWRGbiAoc3RyKSB7XG4gICAgdmFyIGhpdCA9IGNhY2hlW3N0cl07XG4gICAgcmV0dXJuIGhpdCB8fCAoY2FjaGVbc3RyXSA9IGZuKHN0cikpXG4gIH0pXG59XG5cbi8qKlxuICogQ2FtZWxpemUgYSBoeXBoZW4tZGVsaW1pdGVkIHN0cmluZy5cbiAqL1xudmFyIGNhbWVsaXplUkUgPSAvLShcXHcpL2c7XG52YXIgY2FtZWxpemUgPSBjYWNoZWQoZnVuY3Rpb24gKHN0cikge1xuICByZXR1cm4gc3RyLnJlcGxhY2UoY2FtZWxpemVSRSwgZnVuY3Rpb24gKF8sIGMpIHsgcmV0dXJuIGMgPyBjLnRvVXBwZXJDYXNlKCkgOiAnJzsgfSlcbn0pO1xuXG4vKipcbiAqIENhcGl0YWxpemUgYSBzdHJpbmcuXG4gKi9cbnZhciBjYXBpdGFsaXplID0gY2FjaGVkKGZ1bmN0aW9uIChzdHIpIHtcbiAgcmV0dXJuIHN0ci5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSArIHN0ci5zbGljZSgxKVxufSk7XG5cbi8qKlxuICogSHlwaGVuYXRlIGEgY2FtZWxDYXNlIHN0cmluZy5cbiAqL1xudmFyIGh5cGhlbmF0ZVJFID0gL1xcQihbQS1aXSkvZztcbnZhciBoeXBoZW5hdGUgPSBjYWNoZWQoZnVuY3Rpb24gKHN0cikge1xuICByZXR1cm4gc3RyLnJlcGxhY2UoaHlwaGVuYXRlUkUsICctJDEnKS50b0xvd2VyQ2FzZSgpXG59KTtcblxuLyoqXG4gKiBTaW1wbGUgYmluZCBwb2x5ZmlsbCBmb3IgZW52aXJvbm1lbnRzIHRoYXQgZG8gbm90IHN1cHBvcnQgaXQsXG4gKiBlLmcuLCBQaGFudG9tSlMgMS54LiBUZWNobmljYWxseSwgd2UgZG9uJ3QgbmVlZCB0aGlzIGFueW1vcmVcbiAqIHNpbmNlIG5hdGl2ZSBiaW5kIGlzIG5vdyBwZXJmb3JtYW50IGVub3VnaCBpbiBtb3N0IGJyb3dzZXJzLlxuICogQnV0IHJlbW92aW5nIGl0IHdvdWxkIG1lYW4gYnJlYWtpbmcgY29kZSB0aGF0IHdhcyBhYmxlIHRvIHJ1biBpblxuICogUGhhbnRvbUpTIDEueCwgc28gdGhpcyBtdXN0IGJlIGtlcHQgZm9yIGJhY2t3YXJkIGNvbXBhdGliaWxpdHkuXG4gKi9cblxuLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbmZ1bmN0aW9uIHBvbHlmaWxsQmluZCAoZm4sIGN0eCkge1xuICBmdW5jdGlvbiBib3VuZEZuIChhKSB7XG4gICAgdmFyIGwgPSBhcmd1bWVudHMubGVuZ3RoO1xuICAgIHJldHVybiBsXG4gICAgICA/IGwgPiAxXG4gICAgICAgID8gZm4uYXBwbHkoY3R4LCBhcmd1bWVudHMpXG4gICAgICAgIDogZm4uY2FsbChjdHgsIGEpXG4gICAgICA6IGZuLmNhbGwoY3R4KVxuICB9XG5cbiAgYm91bmRGbi5fbGVuZ3RoID0gZm4ubGVuZ3RoO1xuICByZXR1cm4gYm91bmRGblxufVxuXG5mdW5jdGlvbiBuYXRpdmVCaW5kIChmbiwgY3R4KSB7XG4gIHJldHVybiBmbi5iaW5kKGN0eClcbn1cblxudmFyIGJpbmQgPSBGdW5jdGlvbi5wcm90b3R5cGUuYmluZFxuICA/IG5hdGl2ZUJpbmRcbiAgOiBwb2x5ZmlsbEJpbmQ7XG5cbi8qKlxuICogQ29udmVydCBhbiBBcnJheS1saWtlIG9iamVjdCB0byBhIHJlYWwgQXJyYXkuXG4gKi9cbmZ1bmN0aW9uIHRvQXJyYXkgKGxpc3QsIHN0YXJ0KSB7XG4gIHN0YXJ0ID0gc3RhcnQgfHwgMDtcbiAgdmFyIGkgPSBsaXN0Lmxlbmd0aCAtIHN0YXJ0O1xuICB2YXIgcmV0ID0gbmV3IEFycmF5KGkpO1xuICB3aGlsZSAoaS0tKSB7XG4gICAgcmV0W2ldID0gbGlzdFtpICsgc3RhcnRdO1xuICB9XG4gIHJldHVybiByZXRcbn1cblxuLyoqXG4gKiBNaXggcHJvcGVydGllcyBpbnRvIHRhcmdldCBvYmplY3QuXG4gKi9cbmZ1bmN0aW9uIGV4dGVuZCAodG8sIF9mcm9tKSB7XG4gIGZvciAodmFyIGtleSBpbiBfZnJvbSkge1xuICAgIHRvW2tleV0gPSBfZnJvbVtrZXldO1xuICB9XG4gIHJldHVybiB0b1xufVxuXG4vKipcbiAqIE1lcmdlIGFuIEFycmF5IG9mIE9iamVjdHMgaW50byBhIHNpbmdsZSBPYmplY3QuXG4gKi9cbmZ1bmN0aW9uIHRvT2JqZWN0IChhcnIpIHtcbiAgdmFyIHJlcyA9IHt9O1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGFyci5sZW5ndGg7IGkrKykge1xuICAgIGlmIChhcnJbaV0pIHtcbiAgICAgIGV4dGVuZChyZXMsIGFycltpXSk7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXNcbn1cblxuLyogZXNsaW50LWRpc2FibGUgbm8tdW51c2VkLXZhcnMgKi9cblxuLyoqXG4gKiBQZXJmb3JtIG5vIG9wZXJhdGlvbi5cbiAqIFN0dWJiaW5nIGFyZ3MgdG8gbWFrZSBGbG93IGhhcHB5IHdpdGhvdXQgbGVhdmluZyB1c2VsZXNzIHRyYW5zcGlsZWQgY29kZVxuICogd2l0aCAuLi5yZXN0IChodHRwczovL2Zsb3cub3JnL2Jsb2cvMjAxNy8wNS8wNy9TdHJpY3QtRnVuY3Rpb24tQ2FsbC1Bcml0eS8pLlxuICovXG5mdW5jdGlvbiBub29wIChhLCBiLCBjKSB7fVxuXG4vKipcbiAqIEFsd2F5cyByZXR1cm4gZmFsc2UuXG4gKi9cbnZhciBubyA9IGZ1bmN0aW9uIChhLCBiLCBjKSB7IHJldHVybiBmYWxzZTsgfTtcblxuLyogZXNsaW50LWVuYWJsZSBuby11bnVzZWQtdmFycyAqL1xuXG4vKipcbiAqIFJldHVybiB0aGUgc2FtZSB2YWx1ZS5cbiAqL1xudmFyIGlkZW50aXR5ID0gZnVuY3Rpb24gKF8pIHsgcmV0dXJuIF87IH07XG5cbi8qKlxuICogR2VuZXJhdGUgYSBzdHJpbmcgY29udGFpbmluZyBzdGF0aWMga2V5cyBmcm9tIGNvbXBpbGVyIG1vZHVsZXMuXG4gKi9cbmZ1bmN0aW9uIGdlblN0YXRpY0tleXMgKG1vZHVsZXMpIHtcbiAgcmV0dXJuIG1vZHVsZXMucmVkdWNlKGZ1bmN0aW9uIChrZXlzLCBtKSB7XG4gICAgcmV0dXJuIGtleXMuY29uY2F0KG0uc3RhdGljS2V5cyB8fCBbXSlcbiAgfSwgW10pLmpvaW4oJywnKVxufVxuXG4vKipcbiAqIENoZWNrIGlmIHR3byB2YWx1ZXMgYXJlIGxvb3NlbHkgZXF1YWwgLSB0aGF0IGlzLFxuICogaWYgdGhleSBhcmUgcGxhaW4gb2JqZWN0cywgZG8gdGhleSBoYXZlIHRoZSBzYW1lIHNoYXBlP1xuICovXG5mdW5jdGlvbiBsb29zZUVxdWFsIChhLCBiKSB7XG4gIGlmIChhID09PSBiKSB7IHJldHVybiB0cnVlIH1cbiAgdmFyIGlzT2JqZWN0QSA9IGlzT2JqZWN0KGEpO1xuICB2YXIgaXNPYmplY3RCID0gaXNPYmplY3QoYik7XG4gIGlmIChpc09iamVjdEEgJiYgaXNPYmplY3RCKSB7XG4gICAgdHJ5IHtcbiAgICAgIHZhciBpc0FycmF5QSA9IEFycmF5LmlzQXJyYXkoYSk7XG4gICAgICB2YXIgaXNBcnJheUIgPSBBcnJheS5pc0FycmF5KGIpO1xuICAgICAgaWYgKGlzQXJyYXlBICYmIGlzQXJyYXlCKSB7XG4gICAgICAgIHJldHVybiBhLmxlbmd0aCA9PT0gYi5sZW5ndGggJiYgYS5ldmVyeShmdW5jdGlvbiAoZSwgaSkge1xuICAgICAgICAgIHJldHVybiBsb29zZUVxdWFsKGUsIGJbaV0pXG4gICAgICAgIH0pXG4gICAgICB9IGVsc2UgaWYgKGEgaW5zdGFuY2VvZiBEYXRlICYmIGIgaW5zdGFuY2VvZiBEYXRlKSB7XG4gICAgICAgIHJldHVybiBhLmdldFRpbWUoKSA9PT0gYi5nZXRUaW1lKClcbiAgICAgIH0gZWxzZSBpZiAoIWlzQXJyYXlBICYmICFpc0FycmF5Qikge1xuICAgICAgICB2YXIga2V5c0EgPSBPYmplY3Qua2V5cyhhKTtcbiAgICAgICAgdmFyIGtleXNCID0gT2JqZWN0LmtleXMoYik7XG4gICAgICAgIHJldHVybiBrZXlzQS5sZW5ndGggPT09IGtleXNCLmxlbmd0aCAmJiBrZXlzQS5ldmVyeShmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgICAgcmV0dXJuIGxvb3NlRXF1YWwoYVtrZXldLCBiW2tleV0pXG4gICAgICAgIH0pXG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgIH1cbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfVxuICB9IGVsc2UgaWYgKCFpc09iamVjdEEgJiYgIWlzT2JqZWN0Qikge1xuICAgIHJldHVybiBTdHJpbmcoYSkgPT09IFN0cmluZyhiKVxuICB9IGVsc2Uge1xuICAgIHJldHVybiBmYWxzZVxuICB9XG59XG5cbi8qKlxuICogUmV0dXJuIHRoZSBmaXJzdCBpbmRleCBhdCB3aGljaCBhIGxvb3NlbHkgZXF1YWwgdmFsdWUgY2FuIGJlXG4gKiBmb3VuZCBpbiB0aGUgYXJyYXkgKGlmIHZhbHVlIGlzIGEgcGxhaW4gb2JqZWN0LCB0aGUgYXJyYXkgbXVzdFxuICogY29udGFpbiBhbiBvYmplY3Qgb2YgdGhlIHNhbWUgc2hhcGUpLCBvciAtMSBpZiBpdCBpcyBub3QgcHJlc2VudC5cbiAqL1xuZnVuY3Rpb24gbG9vc2VJbmRleE9mIChhcnIsIHZhbCkge1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGFyci5sZW5ndGg7IGkrKykge1xuICAgIGlmIChsb29zZUVxdWFsKGFycltpXSwgdmFsKSkgeyByZXR1cm4gaSB9XG4gIH1cbiAgcmV0dXJuIC0xXG59XG5cbi8qKlxuICogRW5zdXJlIGEgZnVuY3Rpb24gaXMgY2FsbGVkIG9ubHkgb25jZS5cbiAqL1xuZnVuY3Rpb24gb25jZSAoZm4pIHtcbiAgdmFyIGNhbGxlZCA9IGZhbHNlO1xuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIGlmICghY2FsbGVkKSB7XG4gICAgICBjYWxsZWQgPSB0cnVlO1xuICAgICAgZm4uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG4gIH1cbn1cblxudmFyIFNTUl9BVFRSID0gJ2RhdGEtc2VydmVyLXJlbmRlcmVkJztcblxudmFyIEFTU0VUX1RZUEVTID0gW1xuICAnY29tcG9uZW50JyxcbiAgJ2RpcmVjdGl2ZScsXG4gICdmaWx0ZXInXG5dO1xuXG52YXIgTElGRUNZQ0xFX0hPT0tTID0gW1xuICAnYmVmb3JlQ3JlYXRlJyxcbiAgJ2NyZWF0ZWQnLFxuICAnYmVmb3JlTW91bnQnLFxuICAnbW91bnRlZCcsXG4gICdiZWZvcmVVcGRhdGUnLFxuICAndXBkYXRlZCcsXG4gICdiZWZvcmVEZXN0cm95JyxcbiAgJ2Rlc3Ryb3llZCcsXG4gICdhY3RpdmF0ZWQnLFxuICAnZGVhY3RpdmF0ZWQnLFxuICAnZXJyb3JDYXB0dXJlZCcsXG4gICdzZXJ2ZXJQcmVmZXRjaCdcbl07XG5cbi8qICAqL1xuXG5cblxudmFyIGNvbmZpZyA9ICh7XG4gIC8qKlxuICAgKiBPcHRpb24gbWVyZ2Ugc3RyYXRlZ2llcyAodXNlZCBpbiBjb3JlL3V0aWwvb3B0aW9ucylcbiAgICovXG4gIC8vICRmbG93LWRpc2FibGUtbGluZVxuICBvcHRpb25NZXJnZVN0cmF0ZWdpZXM6IE9iamVjdC5jcmVhdGUobnVsbCksXG5cbiAgLyoqXG4gICAqIFdoZXRoZXIgdG8gc3VwcHJlc3Mgd2FybmluZ3MuXG4gICAqL1xuICBzaWxlbnQ6IGZhbHNlLFxuXG4gIC8qKlxuICAgKiBTaG93IHByb2R1Y3Rpb24gbW9kZSB0aXAgbWVzc2FnZSBvbiBib290P1xuICAgKi9cbiAgcHJvZHVjdGlvblRpcDogcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyxcblxuICAvKipcbiAgICogV2hldGhlciB0byBlbmFibGUgZGV2dG9vbHNcbiAgICovXG4gIGRldnRvb2xzOiBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nLFxuXG4gIC8qKlxuICAgKiBXaGV0aGVyIHRvIHJlY29yZCBwZXJmXG4gICAqL1xuICBwZXJmb3JtYW5jZTogZmFsc2UsXG5cbiAgLyoqXG4gICAqIEVycm9yIGhhbmRsZXIgZm9yIHdhdGNoZXIgZXJyb3JzXG4gICAqL1xuICBlcnJvckhhbmRsZXI6IG51bGwsXG5cbiAgLyoqXG4gICAqIFdhcm4gaGFuZGxlciBmb3Igd2F0Y2hlciB3YXJuc1xuICAgKi9cbiAgd2FybkhhbmRsZXI6IG51bGwsXG5cbiAgLyoqXG4gICAqIElnbm9yZSBjZXJ0YWluIGN1c3RvbSBlbGVtZW50c1xuICAgKi9cbiAgaWdub3JlZEVsZW1lbnRzOiBbXSxcblxuICAvKipcbiAgICogQ3VzdG9tIHVzZXIga2V5IGFsaWFzZXMgZm9yIHYtb25cbiAgICovXG4gIC8vICRmbG93LWRpc2FibGUtbGluZVxuICBrZXlDb2RlczogT2JqZWN0LmNyZWF0ZShudWxsKSxcblxuICAvKipcbiAgICogQ2hlY2sgaWYgYSB0YWcgaXMgcmVzZXJ2ZWQgc28gdGhhdCBpdCBjYW5ub3QgYmUgcmVnaXN0ZXJlZCBhcyBhXG4gICAqIGNvbXBvbmVudC4gVGhpcyBpcyBwbGF0Zm9ybS1kZXBlbmRlbnQgYW5kIG1heSBiZSBvdmVyd3JpdHRlbi5cbiAgICovXG4gIGlzUmVzZXJ2ZWRUYWc6IG5vLFxuXG4gIC8qKlxuICAgKiBDaGVjayBpZiBhbiBhdHRyaWJ1dGUgaXMgcmVzZXJ2ZWQgc28gdGhhdCBpdCBjYW5ub3QgYmUgdXNlZCBhcyBhIGNvbXBvbmVudFxuICAgKiBwcm9wLiBUaGlzIGlzIHBsYXRmb3JtLWRlcGVuZGVudCBhbmQgbWF5IGJlIG92ZXJ3cml0dGVuLlxuICAgKi9cbiAgaXNSZXNlcnZlZEF0dHI6IG5vLFxuXG4gIC8qKlxuICAgKiBDaGVjayBpZiBhIHRhZyBpcyBhbiB1bmtub3duIGVsZW1lbnQuXG4gICAqIFBsYXRmb3JtLWRlcGVuZGVudC5cbiAgICovXG4gIGlzVW5rbm93bkVsZW1lbnQ6IG5vLFxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIG5hbWVzcGFjZSBvZiBhbiBlbGVtZW50XG4gICAqL1xuICBnZXRUYWdOYW1lc3BhY2U6IG5vb3AsXG5cbiAgLyoqXG4gICAqIFBhcnNlIHRoZSByZWFsIHRhZyBuYW1lIGZvciB0aGUgc3BlY2lmaWMgcGxhdGZvcm0uXG4gICAqL1xuICBwYXJzZVBsYXRmb3JtVGFnTmFtZTogaWRlbnRpdHksXG5cbiAgLyoqXG4gICAqIENoZWNrIGlmIGFuIGF0dHJpYnV0ZSBtdXN0IGJlIGJvdW5kIHVzaW5nIHByb3BlcnR5LCBlLmcuIHZhbHVlXG4gICAqIFBsYXRmb3JtLWRlcGVuZGVudC5cbiAgICovXG4gIG11c3RVc2VQcm9wOiBubyxcblxuICAvKipcbiAgICogUGVyZm9ybSB1cGRhdGVzIGFzeW5jaHJvbm91c2x5LiBJbnRlbmRlZCB0byBiZSB1c2VkIGJ5IFZ1ZSBUZXN0IFV0aWxzXG4gICAqIFRoaXMgd2lsbCBzaWduaWZpY2FudGx5IHJlZHVjZSBwZXJmb3JtYW5jZSBpZiBzZXQgdG8gZmFsc2UuXG4gICAqL1xuICBhc3luYzogdHJ1ZSxcblxuICAvKipcbiAgICogRXhwb3NlZCBmb3IgbGVnYWN5IHJlYXNvbnNcbiAgICovXG4gIF9saWZlY3ljbGVIb29rczogTElGRUNZQ0xFX0hPT0tTXG59KTtcblxuLyogICovXG5cbi8qKlxuICogdW5pY29kZSBsZXR0ZXJzIHVzZWQgZm9yIHBhcnNpbmcgaHRtbCB0YWdzLCBjb21wb25lbnQgbmFtZXMgYW5kIHByb3BlcnR5IHBhdGhzLlxuICogdXNpbmcgaHR0cHM6Ly93d3cudzMub3JnL1RSL2h0bWw1My9zZW1hbnRpY3Mtc2NyaXB0aW5nLmh0bWwjcG90ZW50aWFsY3VzdG9tZWxlbWVudG5hbWVcbiAqIHNraXBwaW5nIFxcdTEwMDAwLVxcdUVGRkZGIGR1ZSB0byBpdCBmcmVlemluZyB1cCBQaGFudG9tSlNcbiAqL1xudmFyIHVuaWNvZGVSZWdFeHAgPSAvYS16QS1aXFx1MDBCN1xcdTAwQzAtXFx1MDBENlxcdTAwRDgtXFx1MDBGNlxcdTAwRjgtXFx1MDM3RFxcdTAzN0YtXFx1MUZGRlxcdTIwMEMtXFx1MjAwRFxcdTIwM0YtXFx1MjA0MFxcdTIwNzAtXFx1MjE4RlxcdTJDMDAtXFx1MkZFRlxcdTMwMDEtXFx1RDdGRlxcdUY5MDAtXFx1RkRDRlxcdUZERjAtXFx1RkZGRC87XG5cbi8qKlxuICogQ2hlY2sgaWYgYSBzdHJpbmcgc3RhcnRzIHdpdGggJCBvciBfXG4gKi9cbmZ1bmN0aW9uIGlzUmVzZXJ2ZWQgKHN0cikge1xuICB2YXIgYyA9IChzdHIgKyAnJykuY2hhckNvZGVBdCgwKTtcbiAgcmV0dXJuIGMgPT09IDB4MjQgfHwgYyA9PT0gMHg1RlxufVxuXG4vKipcbiAqIERlZmluZSBhIHByb3BlcnR5LlxuICovXG5mdW5jdGlvbiBkZWYgKG9iaiwga2V5LCB2YWwsIGVudW1lcmFibGUpIHtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwga2V5LCB7XG4gICAgdmFsdWU6IHZhbCxcbiAgICBlbnVtZXJhYmxlOiAhIWVudW1lcmFibGUsXG4gICAgd3JpdGFibGU6IHRydWUsXG4gICAgY29uZmlndXJhYmxlOiB0cnVlXG4gIH0pO1xufVxuXG4vKipcbiAqIFBhcnNlIHNpbXBsZSBwYXRoLlxuICovXG52YXIgYmFpbFJFID0gbmV3IFJlZ0V4cCgoXCJbXlwiICsgKHVuaWNvZGVSZWdFeHAuc291cmNlKSArIFwiLiRfXFxcXGRdXCIpKTtcbmZ1bmN0aW9uIHBhcnNlUGF0aCAocGF0aCkge1xuICBpZiAoYmFpbFJFLnRlc3QocGF0aCkpIHtcbiAgICByZXR1cm5cbiAgfVxuICB2YXIgc2VnbWVudHMgPSBwYXRoLnNwbGl0KCcuJyk7XG4gIHJldHVybiBmdW5jdGlvbiAob2JqKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzZWdtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKCFvYmopIHsgcmV0dXJuIH1cbiAgICAgIG9iaiA9IG9ialtzZWdtZW50c1tpXV07XG4gICAgfVxuICAgIHJldHVybiBvYmpcbiAgfVxufVxuXG4vKiAgKi9cblxuLy8gY2FuIHdlIHVzZSBfX3Byb3RvX18/XG52YXIgaGFzUHJvdG8gPSAnX19wcm90b19fJyBpbiB7fTtcblxuLy8gQnJvd3NlciBlbnZpcm9ubWVudCBzbmlmZmluZ1xudmFyIGluQnJvd3NlciA9IHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnO1xudmFyIGluV2VleCA9IHR5cGVvZiBXWEVudmlyb25tZW50ICE9PSAndW5kZWZpbmVkJyAmJiAhIVdYRW52aXJvbm1lbnQucGxhdGZvcm07XG52YXIgd2VleFBsYXRmb3JtID0gaW5XZWV4ICYmIFdYRW52aXJvbm1lbnQucGxhdGZvcm0udG9Mb3dlckNhc2UoKTtcbnZhciBVQSA9IGluQnJvd3NlciAmJiB3aW5kb3cubmF2aWdhdG9yLnVzZXJBZ2VudC50b0xvd2VyQ2FzZSgpO1xudmFyIGlzSUUgPSBVQSAmJiAvbXNpZXx0cmlkZW50Ly50ZXN0KFVBKTtcbnZhciBpc0lFOSA9IFVBICYmIFVBLmluZGV4T2YoJ21zaWUgOS4wJykgPiAwO1xudmFyIGlzRWRnZSA9IFVBICYmIFVBLmluZGV4T2YoJ2VkZ2UvJykgPiAwO1xudmFyIGlzQW5kcm9pZCA9IChVQSAmJiBVQS5pbmRleE9mKCdhbmRyb2lkJykgPiAwKSB8fCAod2VleFBsYXRmb3JtID09PSAnYW5kcm9pZCcpO1xudmFyIGlzSU9TID0gKFVBICYmIC9pcGhvbmV8aXBhZHxpcG9kfGlvcy8udGVzdChVQSkpIHx8ICh3ZWV4UGxhdGZvcm0gPT09ICdpb3MnKTtcbnZhciBpc0Nocm9tZSA9IFVBICYmIC9jaHJvbWVcXC9cXGQrLy50ZXN0KFVBKSAmJiAhaXNFZGdlO1xudmFyIGlzUGhhbnRvbUpTID0gVUEgJiYgL3BoYW50b21qcy8udGVzdChVQSk7XG52YXIgaXNGRiA9IFVBICYmIFVBLm1hdGNoKC9maXJlZm94XFwvKFxcZCspLyk7XG5cbi8vIEZpcmVmb3ggaGFzIGEgXCJ3YXRjaFwiIGZ1bmN0aW9uIG9uIE9iamVjdC5wcm90b3R5cGUuLi5cbnZhciBuYXRpdmVXYXRjaCA9ICh7fSkud2F0Y2g7XG5cbnZhciBzdXBwb3J0c1Bhc3NpdmUgPSBmYWxzZTtcbmlmIChpbkJyb3dzZXIpIHtcbiAgdHJ5IHtcbiAgICB2YXIgb3B0cyA9IHt9O1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvcHRzLCAncGFzc2l2ZScsICh7XG4gICAgICBnZXQ6IGZ1bmN0aW9uIGdldCAoKSB7XG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgICAgIHN1cHBvcnRzUGFzc2l2ZSA9IHRydWU7XG4gICAgICB9XG4gICAgfSkpOyAvLyBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svZmxvdy9pc3N1ZXMvMjg1XG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3Rlc3QtcGFzc2l2ZScsIG51bGwsIG9wdHMpO1xuICB9IGNhdGNoIChlKSB7fVxufVxuXG4vLyB0aGlzIG5lZWRzIHRvIGJlIGxhenktZXZhbGVkIGJlY2F1c2UgdnVlIG1heSBiZSByZXF1aXJlZCBiZWZvcmVcbi8vIHZ1ZS1zZXJ2ZXItcmVuZGVyZXIgY2FuIHNldCBWVUVfRU5WXG52YXIgX2lzU2VydmVyO1xudmFyIGlzU2VydmVyUmVuZGVyaW5nID0gZnVuY3Rpb24gKCkge1xuICBpZiAoX2lzU2VydmVyID09PSB1bmRlZmluZWQpIHtcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICBpZiAoIWluQnJvd3NlciAmJiAhaW5XZWV4ICYmIHR5cGVvZiBnbG9iYWwgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAvLyBkZXRlY3QgcHJlc2VuY2Ugb2YgdnVlLXNlcnZlci1yZW5kZXJlciBhbmQgYXZvaWRcbiAgICAgIC8vIFdlYnBhY2sgc2hpbW1pbmcgdGhlIHByb2Nlc3NcbiAgICAgIF9pc1NlcnZlciA9IGdsb2JhbFsncHJvY2VzcyddICYmIGdsb2JhbFsncHJvY2VzcyddLmVudi5WVUVfRU5WID09PSAnc2VydmVyJztcbiAgICB9IGVsc2Uge1xuICAgICAgX2lzU2VydmVyID0gZmFsc2U7XG4gICAgfVxuICB9XG4gIHJldHVybiBfaXNTZXJ2ZXJcbn07XG5cbi8vIGRldGVjdCBkZXZ0b29sc1xudmFyIGRldnRvb2xzID0gaW5Ccm93c2VyICYmIHdpbmRvdy5fX1ZVRV9ERVZUT09MU19HTE9CQUxfSE9PS19fO1xuXG4vKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuZnVuY3Rpb24gaXNOYXRpdmUgKEN0b3IpIHtcbiAgcmV0dXJuIHR5cGVvZiBDdG9yID09PSAnZnVuY3Rpb24nICYmIC9uYXRpdmUgY29kZS8udGVzdChDdG9yLnRvU3RyaW5nKCkpXG59XG5cbnZhciBoYXNTeW1ib2wgPVxuICB0eXBlb2YgU3ltYm9sICE9PSAndW5kZWZpbmVkJyAmJiBpc05hdGl2ZShTeW1ib2wpICYmXG4gIHR5cGVvZiBSZWZsZWN0ICE9PSAndW5kZWZpbmVkJyAmJiBpc05hdGl2ZShSZWZsZWN0Lm93bktleXMpO1xuXG52YXIgX1NldDtcbi8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqLyAvLyAkZmxvdy1kaXNhYmxlLWxpbmVcbmlmICh0eXBlb2YgU2V0ICE9PSAndW5kZWZpbmVkJyAmJiBpc05hdGl2ZShTZXQpKSB7XG4gIC8vIHVzZSBuYXRpdmUgU2V0IHdoZW4gYXZhaWxhYmxlLlxuICBfU2V0ID0gU2V0O1xufSBlbHNlIHtcbiAgLy8gYSBub24tc3RhbmRhcmQgU2V0IHBvbHlmaWxsIHRoYXQgb25seSB3b3JrcyB3aXRoIHByaW1pdGl2ZSBrZXlzLlxuICBfU2V0ID0gLypAX19QVVJFX18qLyhmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gU2V0ICgpIHtcbiAgICAgIHRoaXMuc2V0ID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICB9XG4gICAgU2V0LnByb3RvdHlwZS5oYXMgPSBmdW5jdGlvbiBoYXMgKGtleSkge1xuICAgICAgcmV0dXJuIHRoaXMuc2V0W2tleV0gPT09IHRydWVcbiAgICB9O1xuICAgIFNldC5wcm90b3R5cGUuYWRkID0gZnVuY3Rpb24gYWRkIChrZXkpIHtcbiAgICAgIHRoaXMuc2V0W2tleV0gPSB0cnVlO1xuICAgIH07XG4gICAgU2V0LnByb3RvdHlwZS5jbGVhciA9IGZ1bmN0aW9uIGNsZWFyICgpIHtcbiAgICAgIHRoaXMuc2V0ID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICB9O1xuXG4gICAgcmV0dXJuIFNldDtcbiAgfSgpKTtcbn1cblxuLyogICovXG5cbnZhciB3YXJuID0gbm9vcDtcbnZhciB0aXAgPSBub29wO1xudmFyIGdlbmVyYXRlQ29tcG9uZW50VHJhY2UgPSAobm9vcCk7IC8vIHdvcmsgYXJvdW5kIGZsb3cgY2hlY2tcbnZhciBmb3JtYXRDb21wb25lbnROYW1lID0gKG5vb3ApO1xuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICB2YXIgaGFzQ29uc29sZSA9IHR5cGVvZiBjb25zb2xlICE9PSAndW5kZWZpbmVkJztcbiAgdmFyIGNsYXNzaWZ5UkUgPSAvKD86XnxbLV9dKShcXHcpL2c7XG4gIHZhciBjbGFzc2lmeSA9IGZ1bmN0aW9uIChzdHIpIHsgcmV0dXJuIHN0clxuICAgIC5yZXBsYWNlKGNsYXNzaWZ5UkUsIGZ1bmN0aW9uIChjKSB7IHJldHVybiBjLnRvVXBwZXJDYXNlKCk7IH0pXG4gICAgLnJlcGxhY2UoL1stX10vZywgJycpOyB9O1xuXG4gIHdhcm4gPSBmdW5jdGlvbiAobXNnLCB2bSkge1xuICAgIHZhciB0cmFjZSA9IHZtID8gZ2VuZXJhdGVDb21wb25lbnRUcmFjZSh2bSkgOiAnJztcblxuICAgIGlmIChjb25maWcud2FybkhhbmRsZXIpIHtcbiAgICAgIGNvbmZpZy53YXJuSGFuZGxlci5jYWxsKG51bGwsIG1zZywgdm0sIHRyYWNlKTtcbiAgICB9IGVsc2UgaWYgKGhhc0NvbnNvbGUgJiYgKCFjb25maWcuc2lsZW50KSkge1xuICAgICAgY29uc29sZS5lcnJvcigoXCJbVnVlIHdhcm5dOiBcIiArIG1zZyArIHRyYWNlKSk7XG4gICAgfVxuICB9O1xuXG4gIHRpcCA9IGZ1bmN0aW9uIChtc2csIHZtKSB7XG4gICAgaWYgKGhhc0NvbnNvbGUgJiYgKCFjb25maWcuc2lsZW50KSkge1xuICAgICAgY29uc29sZS53YXJuKFwiW1Z1ZSB0aXBdOiBcIiArIG1zZyArIChcbiAgICAgICAgdm0gPyBnZW5lcmF0ZUNvbXBvbmVudFRyYWNlKHZtKSA6ICcnXG4gICAgICApKTtcbiAgICB9XG4gIH07XG5cbiAgZm9ybWF0Q29tcG9uZW50TmFtZSA9IGZ1bmN0aW9uICh2bSwgaW5jbHVkZUZpbGUpIHtcbiAgICBpZiAodm0uJHJvb3QgPT09IHZtKSB7XG4gICAgICByZXR1cm4gJzxSb290PidcbiAgICB9XG4gICAgdmFyIG9wdGlvbnMgPSB0eXBlb2Ygdm0gPT09ICdmdW5jdGlvbicgJiYgdm0uY2lkICE9IG51bGxcbiAgICAgID8gdm0ub3B0aW9uc1xuICAgICAgOiB2bS5faXNWdWVcbiAgICAgICAgPyB2bS4kb3B0aW9ucyB8fCB2bS5jb25zdHJ1Y3Rvci5vcHRpb25zXG4gICAgICAgIDogdm07XG4gICAgdmFyIG5hbWUgPSBvcHRpb25zLm5hbWUgfHwgb3B0aW9ucy5fY29tcG9uZW50VGFnO1xuICAgIHZhciBmaWxlID0gb3B0aW9ucy5fX2ZpbGU7XG4gICAgaWYgKCFuYW1lICYmIGZpbGUpIHtcbiAgICAgIHZhciBtYXRjaCA9IGZpbGUubWF0Y2goLyhbXi9cXFxcXSspXFwudnVlJC8pO1xuICAgICAgbmFtZSA9IG1hdGNoICYmIG1hdGNoWzFdO1xuICAgIH1cblxuICAgIHJldHVybiAoXG4gICAgICAobmFtZSA/IChcIjxcIiArIChjbGFzc2lmeShuYW1lKSkgKyBcIj5cIikgOiBcIjxBbm9ueW1vdXM+XCIpICtcbiAgICAgIChmaWxlICYmIGluY2x1ZGVGaWxlICE9PSBmYWxzZSA/IChcIiBhdCBcIiArIGZpbGUpIDogJycpXG4gICAgKVxuICB9O1xuXG4gIHZhciByZXBlYXQgPSBmdW5jdGlvbiAoc3RyLCBuKSB7XG4gICAgdmFyIHJlcyA9ICcnO1xuICAgIHdoaWxlIChuKSB7XG4gICAgICBpZiAobiAlIDIgPT09IDEpIHsgcmVzICs9IHN0cjsgfVxuICAgICAgaWYgKG4gPiAxKSB7IHN0ciArPSBzdHI7IH1cbiAgICAgIG4gPj49IDE7XG4gICAgfVxuICAgIHJldHVybiByZXNcbiAgfTtcblxuICBnZW5lcmF0ZUNvbXBvbmVudFRyYWNlID0gZnVuY3Rpb24gKHZtKSB7XG4gICAgaWYgKHZtLl9pc1Z1ZSAmJiB2bS4kcGFyZW50KSB7XG4gICAgICB2YXIgdHJlZSA9IFtdO1xuICAgICAgdmFyIGN1cnJlbnRSZWN1cnNpdmVTZXF1ZW5jZSA9IDA7XG4gICAgICB3aGlsZSAodm0pIHtcbiAgICAgICAgaWYgKHRyZWUubGVuZ3RoID4gMCkge1xuICAgICAgICAgIHZhciBsYXN0ID0gdHJlZVt0cmVlLmxlbmd0aCAtIDFdO1xuICAgICAgICAgIGlmIChsYXN0LmNvbnN0cnVjdG9yID09PSB2bS5jb25zdHJ1Y3Rvcikge1xuICAgICAgICAgICAgY3VycmVudFJlY3Vyc2l2ZVNlcXVlbmNlKys7XG4gICAgICAgICAgICB2bSA9IHZtLiRwYXJlbnQ7XG4gICAgICAgICAgICBjb250aW51ZVxuICAgICAgICAgIH0gZWxzZSBpZiAoY3VycmVudFJlY3Vyc2l2ZVNlcXVlbmNlID4gMCkge1xuICAgICAgICAgICAgdHJlZVt0cmVlLmxlbmd0aCAtIDFdID0gW2xhc3QsIGN1cnJlbnRSZWN1cnNpdmVTZXF1ZW5jZV07XG4gICAgICAgICAgICBjdXJyZW50UmVjdXJzaXZlU2VxdWVuY2UgPSAwO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0cmVlLnB1c2godm0pO1xuICAgICAgICB2bSA9IHZtLiRwYXJlbnQ7XG4gICAgICB9XG4gICAgICByZXR1cm4gJ1xcblxcbmZvdW5kIGluXFxuXFxuJyArIHRyZWVcbiAgICAgICAgLm1hcChmdW5jdGlvbiAodm0sIGkpIHsgcmV0dXJuIChcIlwiICsgKGkgPT09IDAgPyAnLS0tPiAnIDogcmVwZWF0KCcgJywgNSArIGkgKiAyKSkgKyAoQXJyYXkuaXNBcnJheSh2bSlcbiAgICAgICAgICAgID8gKChmb3JtYXRDb21wb25lbnROYW1lKHZtWzBdKSkgKyBcIi4uLiAoXCIgKyAodm1bMV0pICsgXCIgcmVjdXJzaXZlIGNhbGxzKVwiKVxuICAgICAgICAgICAgOiBmb3JtYXRDb21wb25lbnROYW1lKHZtKSkpOyB9KVxuICAgICAgICAuam9pbignXFxuJylcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIChcIlxcblxcbihmb3VuZCBpbiBcIiArIChmb3JtYXRDb21wb25lbnROYW1lKHZtKSkgKyBcIilcIilcbiAgICB9XG4gIH07XG59XG5cbi8qICAqL1xuXG52YXIgdWlkID0gMDtcblxuLyoqXG4gKiBBIGRlcCBpcyBhbiBvYnNlcnZhYmxlIHRoYXQgY2FuIGhhdmUgbXVsdGlwbGVcbiAqIGRpcmVjdGl2ZXMgc3Vic2NyaWJpbmcgdG8gaXQuXG4gKi9cbnZhciBEZXAgPSBmdW5jdGlvbiBEZXAgKCkge1xuICB0aGlzLmlkID0gdWlkKys7XG4gIHRoaXMuc3VicyA9IFtdO1xufTtcblxuRGVwLnByb3RvdHlwZS5hZGRTdWIgPSBmdW5jdGlvbiBhZGRTdWIgKHN1Yikge1xuICB0aGlzLnN1YnMucHVzaChzdWIpO1xufTtcblxuRGVwLnByb3RvdHlwZS5yZW1vdmVTdWIgPSBmdW5jdGlvbiByZW1vdmVTdWIgKHN1Yikge1xuICByZW1vdmUodGhpcy5zdWJzLCBzdWIpO1xufTtcblxuRGVwLnByb3RvdHlwZS5kZXBlbmQgPSBmdW5jdGlvbiBkZXBlbmQgKCkge1xuICBpZiAoRGVwLnRhcmdldCkge1xuICAgIERlcC50YXJnZXQuYWRkRGVwKHRoaXMpO1xuICB9XG59O1xuXG5EZXAucHJvdG90eXBlLm5vdGlmeSA9IGZ1bmN0aW9uIG5vdGlmeSAoKSB7XG4gIC8vIHN0YWJpbGl6ZSB0aGUgc3Vic2NyaWJlciBsaXN0IGZpcnN0XG4gIHZhciBzdWJzID0gdGhpcy5zdWJzLnNsaWNlKCk7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmICFjb25maWcuYXN5bmMpIHtcbiAgICAvLyBzdWJzIGFyZW4ndCBzb3J0ZWQgaW4gc2NoZWR1bGVyIGlmIG5vdCBydW5uaW5nIGFzeW5jXG4gICAgLy8gd2UgbmVlZCB0byBzb3J0IHRoZW0gbm93IHRvIG1ha2Ugc3VyZSB0aGV5IGZpcmUgaW4gY29ycmVjdFxuICAgIC8vIG9yZGVyXG4gICAgc3Vicy5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7IHJldHVybiBhLmlkIC0gYi5pZDsgfSk7XG4gIH1cbiAgZm9yICh2YXIgaSA9IDAsIGwgPSBzdWJzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgIHN1YnNbaV0udXBkYXRlKCk7XG4gIH1cbn07XG5cbi8vIFRoZSBjdXJyZW50IHRhcmdldCB3YXRjaGVyIGJlaW5nIGV2YWx1YXRlZC5cbi8vIFRoaXMgaXMgZ2xvYmFsbHkgdW5pcXVlIGJlY2F1c2Ugb25seSBvbmUgd2F0Y2hlclxuLy8gY2FuIGJlIGV2YWx1YXRlZCBhdCBhIHRpbWUuXG5EZXAudGFyZ2V0ID0gbnVsbDtcbnZhciB0YXJnZXRTdGFjayA9IFtdO1xuXG5mdW5jdGlvbiBwdXNoVGFyZ2V0ICh0YXJnZXQpIHtcbiAgdGFyZ2V0U3RhY2sucHVzaCh0YXJnZXQpO1xuICBEZXAudGFyZ2V0ID0gdGFyZ2V0O1xufVxuXG5mdW5jdGlvbiBwb3BUYXJnZXQgKCkge1xuICB0YXJnZXRTdGFjay5wb3AoKTtcbiAgRGVwLnRhcmdldCA9IHRhcmdldFN0YWNrW3RhcmdldFN0YWNrLmxlbmd0aCAtIDFdO1xufVxuXG4vKiAgKi9cblxudmFyIFZOb2RlID0gZnVuY3Rpb24gVk5vZGUgKFxuICB0YWcsXG4gIGRhdGEsXG4gIGNoaWxkcmVuLFxuICB0ZXh0LFxuICBlbG0sXG4gIGNvbnRleHQsXG4gIGNvbXBvbmVudE9wdGlvbnMsXG4gIGFzeW5jRmFjdG9yeVxuKSB7XG4gIHRoaXMudGFnID0gdGFnO1xuICB0aGlzLmRhdGEgPSBkYXRhO1xuICB0aGlzLmNoaWxkcmVuID0gY2hpbGRyZW47XG4gIHRoaXMudGV4dCA9IHRleHQ7XG4gIHRoaXMuZWxtID0gZWxtO1xuICB0aGlzLm5zID0gdW5kZWZpbmVkO1xuICB0aGlzLmNvbnRleHQgPSBjb250ZXh0O1xuICB0aGlzLmZuQ29udGV4dCA9IHVuZGVmaW5lZDtcbiAgdGhpcy5mbk9wdGlvbnMgPSB1bmRlZmluZWQ7XG4gIHRoaXMuZm5TY29wZUlkID0gdW5kZWZpbmVkO1xuICB0aGlzLmtleSA9IGRhdGEgJiYgZGF0YS5rZXk7XG4gIHRoaXMuY29tcG9uZW50T3B0aW9ucyA9IGNvbXBvbmVudE9wdGlvbnM7XG4gIHRoaXMuY29tcG9uZW50SW5zdGFuY2UgPSB1bmRlZmluZWQ7XG4gIHRoaXMucGFyZW50ID0gdW5kZWZpbmVkO1xuICB0aGlzLnJhdyA9IGZhbHNlO1xuICB0aGlzLmlzU3RhdGljID0gZmFsc2U7XG4gIHRoaXMuaXNSb290SW5zZXJ0ID0gdHJ1ZTtcbiAgdGhpcy5pc0NvbW1lbnQgPSBmYWxzZTtcbiAgdGhpcy5pc0Nsb25lZCA9IGZhbHNlO1xuICB0aGlzLmlzT25jZSA9IGZhbHNlO1xuICB0aGlzLmFzeW5jRmFjdG9yeSA9IGFzeW5jRmFjdG9yeTtcbiAgdGhpcy5hc3luY01ldGEgPSB1bmRlZmluZWQ7XG4gIHRoaXMuaXNBc3luY1BsYWNlaG9sZGVyID0gZmFsc2U7XG59O1xuXG52YXIgcHJvdG90eXBlQWNjZXNzb3JzID0geyBjaGlsZDogeyBjb25maWd1cmFibGU6IHRydWUgfSB9O1xuXG4vLyBERVBSRUNBVEVEOiBhbGlhcyBmb3IgY29tcG9uZW50SW5zdGFuY2UgZm9yIGJhY2t3YXJkcyBjb21wYXQuXG4vKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xucHJvdG90eXBlQWNjZXNzb3JzLmNoaWxkLmdldCA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMuY29tcG9uZW50SW5zdGFuY2Vcbn07XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKCBWTm9kZS5wcm90b3R5cGUsIHByb3RvdHlwZUFjY2Vzc29ycyApO1xuXG52YXIgY3JlYXRlRW1wdHlWTm9kZSA9IGZ1bmN0aW9uICh0ZXh0KSB7XG4gIGlmICggdGV4dCA9PT0gdm9pZCAwICkgdGV4dCA9ICcnO1xuXG4gIHZhciBub2RlID0gbmV3IFZOb2RlKCk7XG4gIG5vZGUudGV4dCA9IHRleHQ7XG4gIG5vZGUuaXNDb21tZW50ID0gdHJ1ZTtcbiAgcmV0dXJuIG5vZGVcbn07XG5cbmZ1bmN0aW9uIGNyZWF0ZVRleHRWTm9kZSAodmFsKSB7XG4gIHJldHVybiBuZXcgVk5vZGUodW5kZWZpbmVkLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgU3RyaW5nKHZhbCkpXG59XG5cbi8vIG9wdGltaXplZCBzaGFsbG93IGNsb25lXG4vLyB1c2VkIGZvciBzdGF0aWMgbm9kZXMgYW5kIHNsb3Qgbm9kZXMgYmVjYXVzZSB0aGV5IG1heSBiZSByZXVzZWQgYWNyb3NzXG4vLyBtdWx0aXBsZSByZW5kZXJzLCBjbG9uaW5nIHRoZW0gYXZvaWRzIGVycm9ycyB3aGVuIERPTSBtYW5pcHVsYXRpb25zIHJlbHlcbi8vIG9uIHRoZWlyIGVsbSByZWZlcmVuY2UuXG5mdW5jdGlvbiBjbG9uZVZOb2RlICh2bm9kZSkge1xuICB2YXIgY2xvbmVkID0gbmV3IFZOb2RlKFxuICAgIHZub2RlLnRhZyxcbiAgICB2bm9kZS5kYXRhLFxuICAgIC8vICM3OTc1XG4gICAgLy8gY2xvbmUgY2hpbGRyZW4gYXJyYXkgdG8gYXZvaWQgbXV0YXRpbmcgb3JpZ2luYWwgaW4gY2FzZSBvZiBjbG9uaW5nXG4gICAgLy8gYSBjaGlsZC5cbiAgICB2bm9kZS5jaGlsZHJlbiAmJiB2bm9kZS5jaGlsZHJlbi5zbGljZSgpLFxuICAgIHZub2RlLnRleHQsXG4gICAgdm5vZGUuZWxtLFxuICAgIHZub2RlLmNvbnRleHQsXG4gICAgdm5vZGUuY29tcG9uZW50T3B0aW9ucyxcbiAgICB2bm9kZS5hc3luY0ZhY3RvcnlcbiAgKTtcbiAgY2xvbmVkLm5zID0gdm5vZGUubnM7XG4gIGNsb25lZC5pc1N0YXRpYyA9IHZub2RlLmlzU3RhdGljO1xuICBjbG9uZWQua2V5ID0gdm5vZGUua2V5O1xuICBjbG9uZWQuaXNDb21tZW50ID0gdm5vZGUuaXNDb21tZW50O1xuICBjbG9uZWQuZm5Db250ZXh0ID0gdm5vZGUuZm5Db250ZXh0O1xuICBjbG9uZWQuZm5PcHRpb25zID0gdm5vZGUuZm5PcHRpb25zO1xuICBjbG9uZWQuZm5TY29wZUlkID0gdm5vZGUuZm5TY29wZUlkO1xuICBjbG9uZWQuYXN5bmNNZXRhID0gdm5vZGUuYXN5bmNNZXRhO1xuICBjbG9uZWQuaXNDbG9uZWQgPSB0cnVlO1xuICByZXR1cm4gY2xvbmVkXG59XG5cbi8qXG4gKiBub3QgdHlwZSBjaGVja2luZyB0aGlzIGZpbGUgYmVjYXVzZSBmbG93IGRvZXNuJ3QgcGxheSB3ZWxsIHdpdGhcbiAqIGR5bmFtaWNhbGx5IGFjY2Vzc2luZyBtZXRob2RzIG9uIEFycmF5IHByb3RvdHlwZVxuICovXG5cbnZhciBhcnJheVByb3RvID0gQXJyYXkucHJvdG90eXBlO1xudmFyIGFycmF5TWV0aG9kcyA9IE9iamVjdC5jcmVhdGUoYXJyYXlQcm90byk7XG5cbnZhciBtZXRob2RzVG9QYXRjaCA9IFtcbiAgJ3B1c2gnLFxuICAncG9wJyxcbiAgJ3NoaWZ0JyxcbiAgJ3Vuc2hpZnQnLFxuICAnc3BsaWNlJyxcbiAgJ3NvcnQnLFxuICAncmV2ZXJzZSdcbl07XG5cbi8qKlxuICogSW50ZXJjZXB0IG11dGF0aW5nIG1ldGhvZHMgYW5kIGVtaXQgZXZlbnRzXG4gKi9cbm1ldGhvZHNUb1BhdGNoLmZvckVhY2goZnVuY3Rpb24gKG1ldGhvZCkge1xuICAvLyBjYWNoZSBvcmlnaW5hbCBtZXRob2RcbiAgdmFyIG9yaWdpbmFsID0gYXJyYXlQcm90b1ttZXRob2RdO1xuICBkZWYoYXJyYXlNZXRob2RzLCBtZXRob2QsIGZ1bmN0aW9uIG11dGF0b3IgKCkge1xuICAgIHZhciBhcmdzID0gW10sIGxlbiA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gICAgd2hpbGUgKCBsZW4tLSApIGFyZ3NbIGxlbiBdID0gYXJndW1lbnRzWyBsZW4gXTtcblxuICAgIHZhciByZXN1bHQgPSBvcmlnaW5hbC5hcHBseSh0aGlzLCBhcmdzKTtcbiAgICB2YXIgb2IgPSB0aGlzLl9fb2JfXztcbiAgICB2YXIgaW5zZXJ0ZWQ7XG4gICAgc3dpdGNoIChtZXRob2QpIHtcbiAgICAgIGNhc2UgJ3B1c2gnOlxuICAgICAgY2FzZSAndW5zaGlmdCc6XG4gICAgICAgIGluc2VydGVkID0gYXJncztcbiAgICAgICAgYnJlYWtcbiAgICAgIGNhc2UgJ3NwbGljZSc6XG4gICAgICAgIGluc2VydGVkID0gYXJncy5zbGljZSgyKTtcbiAgICAgICAgYnJlYWtcbiAgICB9XG4gICAgaWYgKGluc2VydGVkKSB7IG9iLm9ic2VydmVBcnJheShpbnNlcnRlZCk7IH1cbiAgICAvLyBub3RpZnkgY2hhbmdlXG4gICAgb2IuZGVwLm5vdGlmeSgpO1xuICAgIHJldHVybiByZXN1bHRcbiAgfSk7XG59KTtcblxuLyogICovXG5cbnZhciBhcnJheUtleXMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhhcnJheU1ldGhvZHMpO1xuXG4vKipcbiAqIEluIHNvbWUgY2FzZXMgd2UgbWF5IHdhbnQgdG8gZGlzYWJsZSBvYnNlcnZhdGlvbiBpbnNpZGUgYSBjb21wb25lbnQnc1xuICogdXBkYXRlIGNvbXB1dGF0aW9uLlxuICovXG52YXIgc2hvdWxkT2JzZXJ2ZSA9IHRydWU7XG5cbmZ1bmN0aW9uIHRvZ2dsZU9ic2VydmluZyAodmFsdWUpIHtcbiAgc2hvdWxkT2JzZXJ2ZSA9IHZhbHVlO1xufVxuXG4vKipcbiAqIE9ic2VydmVyIGNsYXNzIHRoYXQgaXMgYXR0YWNoZWQgdG8gZWFjaCBvYnNlcnZlZFxuICogb2JqZWN0LiBPbmNlIGF0dGFjaGVkLCB0aGUgb2JzZXJ2ZXIgY29udmVydHMgdGhlIHRhcmdldFxuICogb2JqZWN0J3MgcHJvcGVydHkga2V5cyBpbnRvIGdldHRlci9zZXR0ZXJzIHRoYXRcbiAqIGNvbGxlY3QgZGVwZW5kZW5jaWVzIGFuZCBkaXNwYXRjaCB1cGRhdGVzLlxuICovXG52YXIgT2JzZXJ2ZXIgPSBmdW5jdGlvbiBPYnNlcnZlciAodmFsdWUpIHtcbiAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICB0aGlzLmRlcCA9IG5ldyBEZXAoKTtcbiAgdGhpcy52bUNvdW50ID0gMDtcbiAgZGVmKHZhbHVlLCAnX19vYl9fJywgdGhpcyk7XG4gIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgIGlmIChoYXNQcm90bykge1xuICAgICAgcHJvdG9BdWdtZW50KHZhbHVlLCBhcnJheU1ldGhvZHMpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb3B5QXVnbWVudCh2YWx1ZSwgYXJyYXlNZXRob2RzLCBhcnJheUtleXMpO1xuICAgIH1cbiAgICB0aGlzLm9ic2VydmVBcnJheSh2YWx1ZSk7XG4gIH0gZWxzZSB7XG4gICAgdGhpcy53YWxrKHZhbHVlKTtcbiAgfVxufTtcblxuLyoqXG4gKiBXYWxrIHRocm91Z2ggYWxsIHByb3BlcnRpZXMgYW5kIGNvbnZlcnQgdGhlbSBpbnRvXG4gKiBnZXR0ZXIvc2V0dGVycy4gVGhpcyBtZXRob2Qgc2hvdWxkIG9ubHkgYmUgY2FsbGVkIHdoZW5cbiAqIHZhbHVlIHR5cGUgaXMgT2JqZWN0LlxuICovXG5PYnNlcnZlci5wcm90b3R5cGUud2FsayA9IGZ1bmN0aW9uIHdhbGsgKG9iaikge1xuICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKG9iaik7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7IGkrKykge1xuICAgIGRlZmluZVJlYWN0aXZlJCQxKG9iaiwga2V5c1tpXSk7XG4gIH1cbn07XG5cbi8qKlxuICogT2JzZXJ2ZSBhIGxpc3Qgb2YgQXJyYXkgaXRlbXMuXG4gKi9cbk9ic2VydmVyLnByb3RvdHlwZS5vYnNlcnZlQXJyYXkgPSBmdW5jdGlvbiBvYnNlcnZlQXJyYXkgKGl0ZW1zKSB7XG4gIGZvciAodmFyIGkgPSAwLCBsID0gaXRlbXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgb2JzZXJ2ZShpdGVtc1tpXSk7XG4gIH1cbn07XG5cbi8vIGhlbHBlcnNcblxuLyoqXG4gKiBBdWdtZW50IGEgdGFyZ2V0IE9iamVjdCBvciBBcnJheSBieSBpbnRlcmNlcHRpbmdcbiAqIHRoZSBwcm90b3R5cGUgY2hhaW4gdXNpbmcgX19wcm90b19fXG4gKi9cbmZ1bmN0aW9uIHByb3RvQXVnbWVudCAodGFyZ2V0LCBzcmMpIHtcbiAgLyogZXNsaW50LWRpc2FibGUgbm8tcHJvdG8gKi9cbiAgdGFyZ2V0Ll9fcHJvdG9fXyA9IHNyYztcbiAgLyogZXNsaW50LWVuYWJsZSBuby1wcm90byAqL1xufVxuXG4vKipcbiAqIEF1Z21lbnQgYSB0YXJnZXQgT2JqZWN0IG9yIEFycmF5IGJ5IGRlZmluaW5nXG4gKiBoaWRkZW4gcHJvcGVydGllcy5cbiAqL1xuLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbmZ1bmN0aW9uIGNvcHlBdWdtZW50ICh0YXJnZXQsIHNyYywga2V5cykge1xuICBmb3IgKHZhciBpID0gMCwgbCA9IGtleXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgdmFyIGtleSA9IGtleXNbaV07XG4gICAgZGVmKHRhcmdldCwga2V5LCBzcmNba2V5XSk7XG4gIH1cbn1cblxuLyoqXG4gKiBBdHRlbXB0IHRvIGNyZWF0ZSBhbiBvYnNlcnZlciBpbnN0YW5jZSBmb3IgYSB2YWx1ZSxcbiAqIHJldHVybnMgdGhlIG5ldyBvYnNlcnZlciBpZiBzdWNjZXNzZnVsbHkgb2JzZXJ2ZWQsXG4gKiBvciB0aGUgZXhpc3Rpbmcgb2JzZXJ2ZXIgaWYgdGhlIHZhbHVlIGFscmVhZHkgaGFzIG9uZS5cbiAqL1xuZnVuY3Rpb24gb2JzZXJ2ZSAodmFsdWUsIGFzUm9vdERhdGEpIHtcbiAgaWYgKCFpc09iamVjdCh2YWx1ZSkgfHwgdmFsdWUgaW5zdGFuY2VvZiBWTm9kZSkge1xuICAgIHJldHVyblxuICB9XG4gIHZhciBvYjtcbiAgaWYgKGhhc093bih2YWx1ZSwgJ19fb2JfXycpICYmIHZhbHVlLl9fb2JfXyBpbnN0YW5jZW9mIE9ic2VydmVyKSB7XG4gICAgb2IgPSB2YWx1ZS5fX29iX187XG4gIH0gZWxzZSBpZiAoXG4gICAgc2hvdWxkT2JzZXJ2ZSAmJlxuICAgICFpc1NlcnZlclJlbmRlcmluZygpICYmXG4gICAgKEFycmF5LmlzQXJyYXkodmFsdWUpIHx8IGlzUGxhaW5PYmplY3QodmFsdWUpKSAmJlxuICAgIE9iamVjdC5pc0V4dGVuc2libGUodmFsdWUpICYmXG4gICAgIXZhbHVlLl9pc1Z1ZVxuICApIHtcbiAgICBvYiA9IG5ldyBPYnNlcnZlcih2YWx1ZSk7XG4gIH1cbiAgaWYgKGFzUm9vdERhdGEgJiYgb2IpIHtcbiAgICBvYi52bUNvdW50Kys7XG4gIH1cbiAgcmV0dXJuIG9iXG59XG5cbi8qKlxuICogRGVmaW5lIGEgcmVhY3RpdmUgcHJvcGVydHkgb24gYW4gT2JqZWN0LlxuICovXG5mdW5jdGlvbiBkZWZpbmVSZWFjdGl2ZSQkMSAoXG4gIG9iaixcbiAga2V5LFxuICB2YWwsXG4gIGN1c3RvbVNldHRlcixcbiAgc2hhbGxvd1xuKSB7XG4gIHZhciBkZXAgPSBuZXcgRGVwKCk7XG5cbiAgdmFyIHByb3BlcnR5ID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmosIGtleSk7XG4gIGlmIChwcm9wZXJ0eSAmJiBwcm9wZXJ0eS5jb25maWd1cmFibGUgPT09IGZhbHNlKSB7XG4gICAgcmV0dXJuXG4gIH1cblxuICAvLyBjYXRlciBmb3IgcHJlLWRlZmluZWQgZ2V0dGVyL3NldHRlcnNcbiAgdmFyIGdldHRlciA9IHByb3BlcnR5ICYmIHByb3BlcnR5LmdldDtcbiAgdmFyIHNldHRlciA9IHByb3BlcnR5ICYmIHByb3BlcnR5LnNldDtcbiAgaWYgKCghZ2V0dGVyIHx8IHNldHRlcikgJiYgYXJndW1lbnRzLmxlbmd0aCA9PT0gMikge1xuICAgIHZhbCA9IG9ialtrZXldO1xuICB9XG5cbiAgdmFyIGNoaWxkT2IgPSAhc2hhbGxvdyAmJiBvYnNlcnZlKHZhbCk7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwge1xuICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgIGdldDogZnVuY3Rpb24gcmVhY3RpdmVHZXR0ZXIgKCkge1xuICAgICAgdmFyIHZhbHVlID0gZ2V0dGVyID8gZ2V0dGVyLmNhbGwob2JqKSA6IHZhbDtcbiAgICAgIGlmIChEZXAudGFyZ2V0KSB7XG4gICAgICAgIGRlcC5kZXBlbmQoKTtcbiAgICAgICAgaWYgKGNoaWxkT2IpIHtcbiAgICAgICAgICBjaGlsZE9iLmRlcC5kZXBlbmQoKTtcbiAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgICAgIGRlcGVuZEFycmF5KHZhbHVlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiB2YWx1ZVxuICAgIH0sXG4gICAgc2V0OiBmdW5jdGlvbiByZWFjdGl2ZVNldHRlciAobmV3VmFsKSB7XG4gICAgICB2YXIgdmFsdWUgPSBnZXR0ZXIgPyBnZXR0ZXIuY2FsbChvYmopIDogdmFsO1xuICAgICAgLyogZXNsaW50LWRpc2FibGUgbm8tc2VsZi1jb21wYXJlICovXG4gICAgICBpZiAobmV3VmFsID09PSB2YWx1ZSB8fCAobmV3VmFsICE9PSBuZXdWYWwgJiYgdmFsdWUgIT09IHZhbHVlKSkge1xuICAgICAgICByZXR1cm5cbiAgICAgIH1cbiAgICAgIC8qIGVzbGludC1lbmFibGUgbm8tc2VsZi1jb21wYXJlICovXG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiBjdXN0b21TZXR0ZXIpIHtcbiAgICAgICAgY3VzdG9tU2V0dGVyKCk7XG4gICAgICB9XG4gICAgICAvLyAjNzk4MTogZm9yIGFjY2Vzc29yIHByb3BlcnRpZXMgd2l0aG91dCBzZXR0ZXJcbiAgICAgIGlmIChnZXR0ZXIgJiYgIXNldHRlcikgeyByZXR1cm4gfVxuICAgICAgaWYgKHNldHRlcikge1xuICAgICAgICBzZXR0ZXIuY2FsbChvYmosIG5ld1ZhbCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YWwgPSBuZXdWYWw7XG4gICAgICB9XG4gICAgICBjaGlsZE9iID0gIXNoYWxsb3cgJiYgb2JzZXJ2ZShuZXdWYWwpO1xuICAgICAgZGVwLm5vdGlmeSgpO1xuICAgIH1cbiAgfSk7XG59XG5cbi8qKlxuICogU2V0IGEgcHJvcGVydHkgb24gYW4gb2JqZWN0LiBBZGRzIHRoZSBuZXcgcHJvcGVydHkgYW5kXG4gKiB0cmlnZ2VycyBjaGFuZ2Ugbm90aWZpY2F0aW9uIGlmIHRoZSBwcm9wZXJ0eSBkb2Vzbid0XG4gKiBhbHJlYWR5IGV4aXN0LlxuICovXG5mdW5jdGlvbiBzZXQgKHRhcmdldCwga2V5LCB2YWwpIHtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiZcbiAgICAoaXNVbmRlZih0YXJnZXQpIHx8IGlzUHJpbWl0aXZlKHRhcmdldCkpXG4gICkge1xuICAgIHdhcm4oKFwiQ2Fubm90IHNldCByZWFjdGl2ZSBwcm9wZXJ0eSBvbiB1bmRlZmluZWQsIG51bGwsIG9yIHByaW1pdGl2ZSB2YWx1ZTogXCIgKyAoKHRhcmdldCkpKSk7XG4gIH1cbiAgaWYgKEFycmF5LmlzQXJyYXkodGFyZ2V0KSAmJiBpc1ZhbGlkQXJyYXlJbmRleChrZXkpKSB7XG4gICAgdGFyZ2V0Lmxlbmd0aCA9IE1hdGgubWF4KHRhcmdldC5sZW5ndGgsIGtleSk7XG4gICAgdGFyZ2V0LnNwbGljZShrZXksIDEsIHZhbCk7XG4gICAgcmV0dXJuIHZhbFxuICB9XG4gIGlmIChrZXkgaW4gdGFyZ2V0ICYmICEoa2V5IGluIE9iamVjdC5wcm90b3R5cGUpKSB7XG4gICAgdGFyZ2V0W2tleV0gPSB2YWw7XG4gICAgcmV0dXJuIHZhbFxuICB9XG4gIHZhciBvYiA9ICh0YXJnZXQpLl9fb2JfXztcbiAgaWYgKHRhcmdldC5faXNWdWUgfHwgKG9iICYmIG9iLnZtQ291bnQpKSB7XG4gICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiB3YXJuKFxuICAgICAgJ0F2b2lkIGFkZGluZyByZWFjdGl2ZSBwcm9wZXJ0aWVzIHRvIGEgVnVlIGluc3RhbmNlIG9yIGl0cyByb290ICRkYXRhICcgK1xuICAgICAgJ2F0IHJ1bnRpbWUgLSBkZWNsYXJlIGl0IHVwZnJvbnQgaW4gdGhlIGRhdGEgb3B0aW9uLidcbiAgICApO1xuICAgIHJldHVybiB2YWxcbiAgfVxuICBpZiAoIW9iKSB7XG4gICAgdGFyZ2V0W2tleV0gPSB2YWw7XG4gICAgcmV0dXJuIHZhbFxuICB9XG4gIGRlZmluZVJlYWN0aXZlJCQxKG9iLnZhbHVlLCBrZXksIHZhbCk7XG4gIG9iLmRlcC5ub3RpZnkoKTtcbiAgcmV0dXJuIHZhbFxufVxuXG4vKipcbiAqIERlbGV0ZSBhIHByb3BlcnR5IGFuZCB0cmlnZ2VyIGNoYW5nZSBpZiBuZWNlc3NhcnkuXG4gKi9cbmZ1bmN0aW9uIGRlbCAodGFyZ2V0LCBrZXkpIHtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiZcbiAgICAoaXNVbmRlZih0YXJnZXQpIHx8IGlzUHJpbWl0aXZlKHRhcmdldCkpXG4gICkge1xuICAgIHdhcm4oKFwiQ2Fubm90IGRlbGV0ZSByZWFjdGl2ZSBwcm9wZXJ0eSBvbiB1bmRlZmluZWQsIG51bGwsIG9yIHByaW1pdGl2ZSB2YWx1ZTogXCIgKyAoKHRhcmdldCkpKSk7XG4gIH1cbiAgaWYgKEFycmF5LmlzQXJyYXkodGFyZ2V0KSAmJiBpc1ZhbGlkQXJyYXlJbmRleChrZXkpKSB7XG4gICAgdGFyZ2V0LnNwbGljZShrZXksIDEpO1xuICAgIHJldHVyblxuICB9XG4gIHZhciBvYiA9ICh0YXJnZXQpLl9fb2JfXztcbiAgaWYgKHRhcmdldC5faXNWdWUgfHwgKG9iICYmIG9iLnZtQ291bnQpKSB7XG4gICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiB3YXJuKFxuICAgICAgJ0F2b2lkIGRlbGV0aW5nIHByb3BlcnRpZXMgb24gYSBWdWUgaW5zdGFuY2Ugb3IgaXRzIHJvb3QgJGRhdGEgJyArXG4gICAgICAnLSBqdXN0IHNldCBpdCB0byBudWxsLidcbiAgICApO1xuICAgIHJldHVyblxuICB9XG4gIGlmICghaGFzT3duKHRhcmdldCwga2V5KSkge1xuICAgIHJldHVyblxuICB9XG4gIGRlbGV0ZSB0YXJnZXRba2V5XTtcbiAgaWYgKCFvYikge1xuICAgIHJldHVyblxuICB9XG4gIG9iLmRlcC5ub3RpZnkoKTtcbn1cblxuLyoqXG4gKiBDb2xsZWN0IGRlcGVuZGVuY2llcyBvbiBhcnJheSBlbGVtZW50cyB3aGVuIHRoZSBhcnJheSBpcyB0b3VjaGVkLCBzaW5jZVxuICogd2UgY2Fubm90IGludGVyY2VwdCBhcnJheSBlbGVtZW50IGFjY2VzcyBsaWtlIHByb3BlcnR5IGdldHRlcnMuXG4gKi9cbmZ1bmN0aW9uIGRlcGVuZEFycmF5ICh2YWx1ZSkge1xuICBmb3IgKHZhciBlID0gKHZvaWQgMCksIGkgPSAwLCBsID0gdmFsdWUubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgZSA9IHZhbHVlW2ldO1xuICAgIGUgJiYgZS5fX29iX18gJiYgZS5fX29iX18uZGVwLmRlcGVuZCgpO1xuICAgIGlmIChBcnJheS5pc0FycmF5KGUpKSB7XG4gICAgICBkZXBlbmRBcnJheShlKTtcbiAgICB9XG4gIH1cbn1cblxuLyogICovXG5cbi8qKlxuICogT3B0aW9uIG92ZXJ3cml0aW5nIHN0cmF0ZWdpZXMgYXJlIGZ1bmN0aW9ucyB0aGF0IGhhbmRsZVxuICogaG93IHRvIG1lcmdlIGEgcGFyZW50IG9wdGlvbiB2YWx1ZSBhbmQgYSBjaGlsZCBvcHRpb25cbiAqIHZhbHVlIGludG8gdGhlIGZpbmFsIHZhbHVlLlxuICovXG52YXIgc3RyYXRzID0gY29uZmlnLm9wdGlvbk1lcmdlU3RyYXRlZ2llcztcblxuLyoqXG4gKiBPcHRpb25zIHdpdGggcmVzdHJpY3Rpb25zXG4gKi9cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIHN0cmF0cy5lbCA9IHN0cmF0cy5wcm9wc0RhdGEgPSBmdW5jdGlvbiAocGFyZW50LCBjaGlsZCwgdm0sIGtleSkge1xuICAgIGlmICghdm0pIHtcbiAgICAgIHdhcm4oXG4gICAgICAgIFwib3B0aW9uIFxcXCJcIiArIGtleSArIFwiXFxcIiBjYW4gb25seSBiZSB1c2VkIGR1cmluZyBpbnN0YW5jZSBcIiArXG4gICAgICAgICdjcmVhdGlvbiB3aXRoIHRoZSBgbmV3YCBrZXl3b3JkLidcbiAgICAgICk7XG4gICAgfVxuICAgIHJldHVybiBkZWZhdWx0U3RyYXQocGFyZW50LCBjaGlsZClcbiAgfTtcbn1cblxuLyoqXG4gKiBIZWxwZXIgdGhhdCByZWN1cnNpdmVseSBtZXJnZXMgdHdvIGRhdGEgb2JqZWN0cyB0b2dldGhlci5cbiAqL1xuZnVuY3Rpb24gbWVyZ2VEYXRhICh0bywgZnJvbSkge1xuICBpZiAoIWZyb20pIHsgcmV0dXJuIHRvIH1cbiAgdmFyIGtleSwgdG9WYWwsIGZyb21WYWw7XG5cbiAgdmFyIGtleXMgPSBoYXNTeW1ib2xcbiAgICA/IFJlZmxlY3Qub3duS2V5cyhmcm9tKVxuICAgIDogT2JqZWN0LmtleXMoZnJvbSk7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAga2V5ID0ga2V5c1tpXTtcbiAgICAvLyBpbiBjYXNlIHRoZSBvYmplY3QgaXMgYWxyZWFkeSBvYnNlcnZlZC4uLlxuICAgIGlmIChrZXkgPT09ICdfX29iX18nKSB7IGNvbnRpbnVlIH1cbiAgICB0b1ZhbCA9IHRvW2tleV07XG4gICAgZnJvbVZhbCA9IGZyb21ba2V5XTtcbiAgICBpZiAoIWhhc093bih0bywga2V5KSkge1xuICAgICAgc2V0KHRvLCBrZXksIGZyb21WYWwpO1xuICAgIH0gZWxzZSBpZiAoXG4gICAgICB0b1ZhbCAhPT0gZnJvbVZhbCAmJlxuICAgICAgaXNQbGFpbk9iamVjdCh0b1ZhbCkgJiZcbiAgICAgIGlzUGxhaW5PYmplY3QoZnJvbVZhbClcbiAgICApIHtcbiAgICAgIG1lcmdlRGF0YSh0b1ZhbCwgZnJvbVZhbCk7XG4gICAgfVxuICB9XG4gIHJldHVybiB0b1xufVxuXG4vKipcbiAqIERhdGFcbiAqL1xuZnVuY3Rpb24gbWVyZ2VEYXRhT3JGbiAoXG4gIHBhcmVudFZhbCxcbiAgY2hpbGRWYWwsXG4gIHZtXG4pIHtcbiAgaWYgKCF2bSkge1xuICAgIC8vIGluIGEgVnVlLmV4dGVuZCBtZXJnZSwgYm90aCBzaG91bGQgYmUgZnVuY3Rpb25zXG4gICAgaWYgKCFjaGlsZFZhbCkge1xuICAgICAgcmV0dXJuIHBhcmVudFZhbFxuICAgIH1cbiAgICBpZiAoIXBhcmVudFZhbCkge1xuICAgICAgcmV0dXJuIGNoaWxkVmFsXG4gICAgfVxuICAgIC8vIHdoZW4gcGFyZW50VmFsICYgY2hpbGRWYWwgYXJlIGJvdGggcHJlc2VudCxcbiAgICAvLyB3ZSBuZWVkIHRvIHJldHVybiBhIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyB0aGVcbiAgICAvLyBtZXJnZWQgcmVzdWx0IG9mIGJvdGggZnVuY3Rpb25zLi4uIG5vIG5lZWQgdG9cbiAgICAvLyBjaGVjayBpZiBwYXJlbnRWYWwgaXMgYSBmdW5jdGlvbiBoZXJlIGJlY2F1c2VcbiAgICAvLyBpdCBoYXMgdG8gYmUgYSBmdW5jdGlvbiB0byBwYXNzIHByZXZpb3VzIG1lcmdlcy5cbiAgICByZXR1cm4gZnVuY3Rpb24gbWVyZ2VkRGF0YUZuICgpIHtcbiAgICAgIHJldHVybiBtZXJnZURhdGEoXG4gICAgICAgIHR5cGVvZiBjaGlsZFZhbCA9PT0gJ2Z1bmN0aW9uJyA/IGNoaWxkVmFsLmNhbGwodGhpcywgdGhpcykgOiBjaGlsZFZhbCxcbiAgICAgICAgdHlwZW9mIHBhcmVudFZhbCA9PT0gJ2Z1bmN0aW9uJyA/IHBhcmVudFZhbC5jYWxsKHRoaXMsIHRoaXMpIDogcGFyZW50VmFsXG4gICAgICApXG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHJldHVybiBmdW5jdGlvbiBtZXJnZWRJbnN0YW5jZURhdGFGbiAoKSB7XG4gICAgICAvLyBpbnN0YW5jZSBtZXJnZVxuICAgICAgdmFyIGluc3RhbmNlRGF0YSA9IHR5cGVvZiBjaGlsZFZhbCA9PT0gJ2Z1bmN0aW9uJ1xuICAgICAgICA/IGNoaWxkVmFsLmNhbGwodm0sIHZtKVxuICAgICAgICA6IGNoaWxkVmFsO1xuICAgICAgdmFyIGRlZmF1bHREYXRhID0gdHlwZW9mIHBhcmVudFZhbCA9PT0gJ2Z1bmN0aW9uJ1xuICAgICAgICA/IHBhcmVudFZhbC5jYWxsKHZtLCB2bSlcbiAgICAgICAgOiBwYXJlbnRWYWw7XG4gICAgICBpZiAoaW5zdGFuY2VEYXRhKSB7XG4gICAgICAgIHJldHVybiBtZXJnZURhdGEoaW5zdGFuY2VEYXRhLCBkZWZhdWx0RGF0YSlcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBkZWZhdWx0RGF0YVxuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5zdHJhdHMuZGF0YSA9IGZ1bmN0aW9uIChcbiAgcGFyZW50VmFsLFxuICBjaGlsZFZhbCxcbiAgdm1cbikge1xuICBpZiAoIXZtKSB7XG4gICAgaWYgKGNoaWxkVmFsICYmIHR5cGVvZiBjaGlsZFZhbCAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiB3YXJuKFxuICAgICAgICAnVGhlIFwiZGF0YVwiIG9wdGlvbiBzaG91bGQgYmUgYSBmdW5jdGlvbiAnICtcbiAgICAgICAgJ3RoYXQgcmV0dXJucyBhIHBlci1pbnN0YW5jZSB2YWx1ZSBpbiBjb21wb25lbnQgJyArXG4gICAgICAgICdkZWZpbml0aW9ucy4nLFxuICAgICAgICB2bVxuICAgICAgKTtcblxuICAgICAgcmV0dXJuIHBhcmVudFZhbFxuICAgIH1cbiAgICByZXR1cm4gbWVyZ2VEYXRhT3JGbihwYXJlbnRWYWwsIGNoaWxkVmFsKVxuICB9XG5cbiAgcmV0dXJuIG1lcmdlRGF0YU9yRm4ocGFyZW50VmFsLCBjaGlsZFZhbCwgdm0pXG59O1xuXG4vKipcbiAqIEhvb2tzIGFuZCBwcm9wcyBhcmUgbWVyZ2VkIGFzIGFycmF5cy5cbiAqL1xuZnVuY3Rpb24gbWVyZ2VIb29rIChcbiAgcGFyZW50VmFsLFxuICBjaGlsZFZhbFxuKSB7XG4gIHZhciByZXMgPSBjaGlsZFZhbFxuICAgID8gcGFyZW50VmFsXG4gICAgICA/IHBhcmVudFZhbC5jb25jYXQoY2hpbGRWYWwpXG4gICAgICA6IEFycmF5LmlzQXJyYXkoY2hpbGRWYWwpXG4gICAgICAgID8gY2hpbGRWYWxcbiAgICAgICAgOiBbY2hpbGRWYWxdXG4gICAgOiBwYXJlbnRWYWw7XG4gIHJldHVybiByZXNcbiAgICA/IGRlZHVwZUhvb2tzKHJlcylcbiAgICA6IHJlc1xufVxuXG5mdW5jdGlvbiBkZWR1cGVIb29rcyAoaG9va3MpIHtcbiAgdmFyIHJlcyA9IFtdO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGhvb2tzLmxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKHJlcy5pbmRleE9mKGhvb2tzW2ldKSA9PT0gLTEpIHtcbiAgICAgIHJlcy5wdXNoKGhvb2tzW2ldKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc1xufVxuXG5MSUZFQ1lDTEVfSE9PS1MuZm9yRWFjaChmdW5jdGlvbiAoaG9vaykge1xuICBzdHJhdHNbaG9va10gPSBtZXJnZUhvb2s7XG59KTtcblxuLyoqXG4gKiBBc3NldHNcbiAqXG4gKiBXaGVuIGEgdm0gaXMgcHJlc2VudCAoaW5zdGFuY2UgY3JlYXRpb24pLCB3ZSBuZWVkIHRvIGRvXG4gKiBhIHRocmVlLXdheSBtZXJnZSBiZXR3ZWVuIGNvbnN0cnVjdG9yIG9wdGlvbnMsIGluc3RhbmNlXG4gKiBvcHRpb25zIGFuZCBwYXJlbnQgb3B0aW9ucy5cbiAqL1xuZnVuY3Rpb24gbWVyZ2VBc3NldHMgKFxuICBwYXJlbnRWYWwsXG4gIGNoaWxkVmFsLFxuICB2bSxcbiAga2V5XG4pIHtcbiAgdmFyIHJlcyA9IE9iamVjdC5jcmVhdGUocGFyZW50VmFsIHx8IG51bGwpO1xuICBpZiAoY2hpbGRWYWwpIHtcbiAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIGFzc2VydE9iamVjdFR5cGUoa2V5LCBjaGlsZFZhbCwgdm0pO1xuICAgIHJldHVybiBleHRlbmQocmVzLCBjaGlsZFZhbClcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gcmVzXG4gIH1cbn1cblxuQVNTRVRfVFlQRVMuZm9yRWFjaChmdW5jdGlvbiAodHlwZSkge1xuICBzdHJhdHNbdHlwZSArICdzJ10gPSBtZXJnZUFzc2V0cztcbn0pO1xuXG4vKipcbiAqIFdhdGNoZXJzLlxuICpcbiAqIFdhdGNoZXJzIGhhc2hlcyBzaG91bGQgbm90IG92ZXJ3cml0ZSBvbmVcbiAqIGFub3RoZXIsIHNvIHdlIG1lcmdlIHRoZW0gYXMgYXJyYXlzLlxuICovXG5zdHJhdHMud2F0Y2ggPSBmdW5jdGlvbiAoXG4gIHBhcmVudFZhbCxcbiAgY2hpbGRWYWwsXG4gIHZtLFxuICBrZXlcbikge1xuICAvLyB3b3JrIGFyb3VuZCBGaXJlZm94J3MgT2JqZWN0LnByb3RvdHlwZS53YXRjaC4uLlxuICBpZiAocGFyZW50VmFsID09PSBuYXRpdmVXYXRjaCkgeyBwYXJlbnRWYWwgPSB1bmRlZmluZWQ7IH1cbiAgaWYgKGNoaWxkVmFsID09PSBuYXRpdmVXYXRjaCkgeyBjaGlsZFZhbCA9IHVuZGVmaW5lZDsgfVxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgaWYgKCFjaGlsZFZhbCkgeyByZXR1cm4gT2JqZWN0LmNyZWF0ZShwYXJlbnRWYWwgfHwgbnVsbCkgfVxuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIGFzc2VydE9iamVjdFR5cGUoa2V5LCBjaGlsZFZhbCwgdm0pO1xuICB9XG4gIGlmICghcGFyZW50VmFsKSB7IHJldHVybiBjaGlsZFZhbCB9XG4gIHZhciByZXQgPSB7fTtcbiAgZXh0ZW5kKHJldCwgcGFyZW50VmFsKTtcbiAgZm9yICh2YXIga2V5JDEgaW4gY2hpbGRWYWwpIHtcbiAgICB2YXIgcGFyZW50ID0gcmV0W2tleSQxXTtcbiAgICB2YXIgY2hpbGQgPSBjaGlsZFZhbFtrZXkkMV07XG4gICAgaWYgKHBhcmVudCAmJiAhQXJyYXkuaXNBcnJheShwYXJlbnQpKSB7XG4gICAgICBwYXJlbnQgPSBbcGFyZW50XTtcbiAgICB9XG4gICAgcmV0W2tleSQxXSA9IHBhcmVudFxuICAgICAgPyBwYXJlbnQuY29uY2F0KGNoaWxkKVxuICAgICAgOiBBcnJheS5pc0FycmF5KGNoaWxkKSA/IGNoaWxkIDogW2NoaWxkXTtcbiAgfVxuICByZXR1cm4gcmV0XG59O1xuXG4vKipcbiAqIE90aGVyIG9iamVjdCBoYXNoZXMuXG4gKi9cbnN0cmF0cy5wcm9wcyA9XG5zdHJhdHMubWV0aG9kcyA9XG5zdHJhdHMuaW5qZWN0ID1cbnN0cmF0cy5jb21wdXRlZCA9IGZ1bmN0aW9uIChcbiAgcGFyZW50VmFsLFxuICBjaGlsZFZhbCxcbiAgdm0sXG4gIGtleVxuKSB7XG4gIGlmIChjaGlsZFZhbCAmJiBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgYXNzZXJ0T2JqZWN0VHlwZShrZXksIGNoaWxkVmFsLCB2bSk7XG4gIH1cbiAgaWYgKCFwYXJlbnRWYWwpIHsgcmV0dXJuIGNoaWxkVmFsIH1cbiAgdmFyIHJldCA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gIGV4dGVuZChyZXQsIHBhcmVudFZhbCk7XG4gIGlmIChjaGlsZFZhbCkgeyBleHRlbmQocmV0LCBjaGlsZFZhbCk7IH1cbiAgcmV0dXJuIHJldFxufTtcbnN0cmF0cy5wcm92aWRlID0gbWVyZ2VEYXRhT3JGbjtcblxuLyoqXG4gKiBEZWZhdWx0IHN0cmF0ZWd5LlxuICovXG52YXIgZGVmYXVsdFN0cmF0ID0gZnVuY3Rpb24gKHBhcmVudFZhbCwgY2hpbGRWYWwpIHtcbiAgcmV0dXJuIGNoaWxkVmFsID09PSB1bmRlZmluZWRcbiAgICA/IHBhcmVudFZhbFxuICAgIDogY2hpbGRWYWxcbn07XG5cbi8qKlxuICogVmFsaWRhdGUgY29tcG9uZW50IG5hbWVzXG4gKi9cbmZ1bmN0aW9uIGNoZWNrQ29tcG9uZW50cyAob3B0aW9ucykge1xuICBmb3IgKHZhciBrZXkgaW4gb3B0aW9ucy5jb21wb25lbnRzKSB7XG4gICAgdmFsaWRhdGVDb21wb25lbnROYW1lKGtleSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gdmFsaWRhdGVDb21wb25lbnROYW1lIChuYW1lKSB7XG4gIGlmICghbmV3IFJlZ0V4cCgoXCJeW2EtekEtWl1bXFxcXC1cXFxcLjAtOV9cIiArICh1bmljb2RlUmVnRXhwLnNvdXJjZSkgKyBcIl0qJFwiKSkudGVzdChuYW1lKSkge1xuICAgIHdhcm4oXG4gICAgICAnSW52YWxpZCBjb21wb25lbnQgbmFtZTogXCInICsgbmFtZSArICdcIi4gQ29tcG9uZW50IG5hbWVzICcgK1xuICAgICAgJ3Nob3VsZCBjb25mb3JtIHRvIHZhbGlkIGN1c3RvbSBlbGVtZW50IG5hbWUgaW4gaHRtbDUgc3BlY2lmaWNhdGlvbi4nXG4gICAgKTtcbiAgfVxuICBpZiAoaXNCdWlsdEluVGFnKG5hbWUpIHx8IGNvbmZpZy5pc1Jlc2VydmVkVGFnKG5hbWUpKSB7XG4gICAgd2FybihcbiAgICAgICdEbyBub3QgdXNlIGJ1aWx0LWluIG9yIHJlc2VydmVkIEhUTUwgZWxlbWVudHMgYXMgY29tcG9uZW50ICcgK1xuICAgICAgJ2lkOiAnICsgbmFtZVxuICAgICk7XG4gIH1cbn1cblxuLyoqXG4gKiBFbnN1cmUgYWxsIHByb3BzIG9wdGlvbiBzeW50YXggYXJlIG5vcm1hbGl6ZWQgaW50byB0aGVcbiAqIE9iamVjdC1iYXNlZCBmb3JtYXQuXG4gKi9cbmZ1bmN0aW9uIG5vcm1hbGl6ZVByb3BzIChvcHRpb25zLCB2bSkge1xuICB2YXIgcHJvcHMgPSBvcHRpb25zLnByb3BzO1xuICBpZiAoIXByb3BzKSB7IHJldHVybiB9XG4gIHZhciByZXMgPSB7fTtcbiAgdmFyIGksIHZhbCwgbmFtZTtcbiAgaWYgKEFycmF5LmlzQXJyYXkocHJvcHMpKSB7XG4gICAgaSA9IHByb3BzLmxlbmd0aDtcbiAgICB3aGlsZSAoaS0tKSB7XG4gICAgICB2YWwgPSBwcm9wc1tpXTtcbiAgICAgIGlmICh0eXBlb2YgdmFsID09PSAnc3RyaW5nJykge1xuICAgICAgICBuYW1lID0gY2FtZWxpemUodmFsKTtcbiAgICAgICAgcmVzW25hbWVdID0geyB0eXBlOiBudWxsIH07XG4gICAgICB9IGVsc2UgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgd2FybigncHJvcHMgbXVzdCBiZSBzdHJpbmdzIHdoZW4gdXNpbmcgYXJyYXkgc3ludGF4LicpO1xuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIGlmIChpc1BsYWluT2JqZWN0KHByb3BzKSkge1xuICAgIGZvciAodmFyIGtleSBpbiBwcm9wcykge1xuICAgICAgdmFsID0gcHJvcHNba2V5XTtcbiAgICAgIG5hbWUgPSBjYW1lbGl6ZShrZXkpO1xuICAgICAgcmVzW25hbWVdID0gaXNQbGFpbk9iamVjdCh2YWwpXG4gICAgICAgID8gdmFsXG4gICAgICAgIDogeyB0eXBlOiB2YWwgfTtcbiAgICB9XG4gIH0gZWxzZSBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIHdhcm4oXG4gICAgICBcIkludmFsaWQgdmFsdWUgZm9yIG9wdGlvbiBcXFwicHJvcHNcXFwiOiBleHBlY3RlZCBhbiBBcnJheSBvciBhbiBPYmplY3QsIFwiICtcbiAgICAgIFwiYnV0IGdvdCBcIiArICh0b1Jhd1R5cGUocHJvcHMpKSArIFwiLlwiLFxuICAgICAgdm1cbiAgICApO1xuICB9XG4gIG9wdGlvbnMucHJvcHMgPSByZXM7XG59XG5cbi8qKlxuICogTm9ybWFsaXplIGFsbCBpbmplY3Rpb25zIGludG8gT2JqZWN0LWJhc2VkIGZvcm1hdFxuICovXG5mdW5jdGlvbiBub3JtYWxpemVJbmplY3QgKG9wdGlvbnMsIHZtKSB7XG4gIHZhciBpbmplY3QgPSBvcHRpb25zLmluamVjdDtcbiAgaWYgKCFpbmplY3QpIHsgcmV0dXJuIH1cbiAgdmFyIG5vcm1hbGl6ZWQgPSBvcHRpb25zLmluamVjdCA9IHt9O1xuICBpZiAoQXJyYXkuaXNBcnJheShpbmplY3QpKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBpbmplY3QubGVuZ3RoOyBpKyspIHtcbiAgICAgIG5vcm1hbGl6ZWRbaW5qZWN0W2ldXSA9IHsgZnJvbTogaW5qZWN0W2ldIH07XG4gICAgfVxuICB9IGVsc2UgaWYgKGlzUGxhaW5PYmplY3QoaW5qZWN0KSkge1xuICAgIGZvciAodmFyIGtleSBpbiBpbmplY3QpIHtcbiAgICAgIHZhciB2YWwgPSBpbmplY3Rba2V5XTtcbiAgICAgIG5vcm1hbGl6ZWRba2V5XSA9IGlzUGxhaW5PYmplY3QodmFsKVxuICAgICAgICA/IGV4dGVuZCh7IGZyb206IGtleSB9LCB2YWwpXG4gICAgICAgIDogeyBmcm9tOiB2YWwgfTtcbiAgICB9XG4gIH0gZWxzZSBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIHdhcm4oXG4gICAgICBcIkludmFsaWQgdmFsdWUgZm9yIG9wdGlvbiBcXFwiaW5qZWN0XFxcIjogZXhwZWN0ZWQgYW4gQXJyYXkgb3IgYW4gT2JqZWN0LCBcIiArXG4gICAgICBcImJ1dCBnb3QgXCIgKyAodG9SYXdUeXBlKGluamVjdCkpICsgXCIuXCIsXG4gICAgICB2bVxuICAgICk7XG4gIH1cbn1cblxuLyoqXG4gKiBOb3JtYWxpemUgcmF3IGZ1bmN0aW9uIGRpcmVjdGl2ZXMgaW50byBvYmplY3QgZm9ybWF0LlxuICovXG5mdW5jdGlvbiBub3JtYWxpemVEaXJlY3RpdmVzIChvcHRpb25zKSB7XG4gIHZhciBkaXJzID0gb3B0aW9ucy5kaXJlY3RpdmVzO1xuICBpZiAoZGlycykge1xuICAgIGZvciAodmFyIGtleSBpbiBkaXJzKSB7XG4gICAgICB2YXIgZGVmJCQxID0gZGlyc1trZXldO1xuICAgICAgaWYgKHR5cGVvZiBkZWYkJDEgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgZGlyc1trZXldID0geyBiaW5kOiBkZWYkJDEsIHVwZGF0ZTogZGVmJCQxIH07XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGFzc2VydE9iamVjdFR5cGUgKG5hbWUsIHZhbHVlLCB2bSkge1xuICBpZiAoIWlzUGxhaW5PYmplY3QodmFsdWUpKSB7XG4gICAgd2FybihcbiAgICAgIFwiSW52YWxpZCB2YWx1ZSBmb3Igb3B0aW9uIFxcXCJcIiArIG5hbWUgKyBcIlxcXCI6IGV4cGVjdGVkIGFuIE9iamVjdCwgXCIgK1xuICAgICAgXCJidXQgZ290IFwiICsgKHRvUmF3VHlwZSh2YWx1ZSkpICsgXCIuXCIsXG4gICAgICB2bVxuICAgICk7XG4gIH1cbn1cblxuLyoqXG4gKiBNZXJnZSB0d28gb3B0aW9uIG9iamVjdHMgaW50byBhIG5ldyBvbmUuXG4gKiBDb3JlIHV0aWxpdHkgdXNlZCBpbiBib3RoIGluc3RhbnRpYXRpb24gYW5kIGluaGVyaXRhbmNlLlxuICovXG5mdW5jdGlvbiBtZXJnZU9wdGlvbnMgKFxuICBwYXJlbnQsXG4gIGNoaWxkLFxuICB2bVxuKSB7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgY2hlY2tDb21wb25lbnRzKGNoaWxkKTtcbiAgfVxuXG4gIGlmICh0eXBlb2YgY2hpbGQgPT09ICdmdW5jdGlvbicpIHtcbiAgICBjaGlsZCA9IGNoaWxkLm9wdGlvbnM7XG4gIH1cblxuICBub3JtYWxpemVQcm9wcyhjaGlsZCwgdm0pO1xuICBub3JtYWxpemVJbmplY3QoY2hpbGQsIHZtKTtcbiAgbm9ybWFsaXplRGlyZWN0aXZlcyhjaGlsZCk7XG5cbiAgLy8gQXBwbHkgZXh0ZW5kcyBhbmQgbWl4aW5zIG9uIHRoZSBjaGlsZCBvcHRpb25zLFxuICAvLyBidXQgb25seSBpZiBpdCBpcyBhIHJhdyBvcHRpb25zIG9iamVjdCB0aGF0IGlzbid0XG4gIC8vIHRoZSByZXN1bHQgb2YgYW5vdGhlciBtZXJnZU9wdGlvbnMgY2FsbC5cbiAgLy8gT25seSBtZXJnZWQgb3B0aW9ucyBoYXMgdGhlIF9iYXNlIHByb3BlcnR5LlxuICBpZiAoIWNoaWxkLl9iYXNlKSB7XG4gICAgaWYgKGNoaWxkLmV4dGVuZHMpIHtcbiAgICAgIHBhcmVudCA9IG1lcmdlT3B0aW9ucyhwYXJlbnQsIGNoaWxkLmV4dGVuZHMsIHZtKTtcbiAgICB9XG4gICAgaWYgKGNoaWxkLm1peGlucykge1xuICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSBjaGlsZC5taXhpbnMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgIHBhcmVudCA9IG1lcmdlT3B0aW9ucyhwYXJlbnQsIGNoaWxkLm1peGluc1tpXSwgdm0pO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHZhciBvcHRpb25zID0ge307XG4gIHZhciBrZXk7XG4gIGZvciAoa2V5IGluIHBhcmVudCkge1xuICAgIG1lcmdlRmllbGQoa2V5KTtcbiAgfVxuICBmb3IgKGtleSBpbiBjaGlsZCkge1xuICAgIGlmICghaGFzT3duKHBhcmVudCwga2V5KSkge1xuICAgICAgbWVyZ2VGaWVsZChrZXkpO1xuICAgIH1cbiAgfVxuICBmdW5jdGlvbiBtZXJnZUZpZWxkIChrZXkpIHtcbiAgICB2YXIgc3RyYXQgPSBzdHJhdHNba2V5XSB8fCBkZWZhdWx0U3RyYXQ7XG4gICAgb3B0aW9uc1trZXldID0gc3RyYXQocGFyZW50W2tleV0sIGNoaWxkW2tleV0sIHZtLCBrZXkpO1xuICB9XG4gIHJldHVybiBvcHRpb25zXG59XG5cbi8qKlxuICogUmVzb2x2ZSBhbiBhc3NldC5cbiAqIFRoaXMgZnVuY3Rpb24gaXMgdXNlZCBiZWNhdXNlIGNoaWxkIGluc3RhbmNlcyBuZWVkIGFjY2Vzc1xuICogdG8gYXNzZXRzIGRlZmluZWQgaW4gaXRzIGFuY2VzdG9yIGNoYWluLlxuICovXG5mdW5jdGlvbiByZXNvbHZlQXNzZXQgKFxuICBvcHRpb25zLFxuICB0eXBlLFxuICBpZCxcbiAgd2Fybk1pc3Npbmdcbikge1xuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgaWYgKHR5cGVvZiBpZCAhPT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm5cbiAgfVxuICB2YXIgYXNzZXRzID0gb3B0aW9uc1t0eXBlXTtcbiAgLy8gY2hlY2sgbG9jYWwgcmVnaXN0cmF0aW9uIHZhcmlhdGlvbnMgZmlyc3RcbiAgaWYgKGhhc093bihhc3NldHMsIGlkKSkgeyByZXR1cm4gYXNzZXRzW2lkXSB9XG4gIHZhciBjYW1lbGl6ZWRJZCA9IGNhbWVsaXplKGlkKTtcbiAgaWYgKGhhc093bihhc3NldHMsIGNhbWVsaXplZElkKSkgeyByZXR1cm4gYXNzZXRzW2NhbWVsaXplZElkXSB9XG4gIHZhciBQYXNjYWxDYXNlSWQgPSBjYXBpdGFsaXplKGNhbWVsaXplZElkKTtcbiAgaWYgKGhhc093bihhc3NldHMsIFBhc2NhbENhc2VJZCkpIHsgcmV0dXJuIGFzc2V0c1tQYXNjYWxDYXNlSWRdIH1cbiAgLy8gZmFsbGJhY2sgdG8gcHJvdG90eXBlIGNoYWluXG4gIHZhciByZXMgPSBhc3NldHNbaWRdIHx8IGFzc2V0c1tjYW1lbGl6ZWRJZF0gfHwgYXNzZXRzW1Bhc2NhbENhc2VJZF07XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIHdhcm5NaXNzaW5nICYmICFyZXMpIHtcbiAgICB3YXJuKFxuICAgICAgJ0ZhaWxlZCB0byByZXNvbHZlICcgKyB0eXBlLnNsaWNlKDAsIC0xKSArICc6ICcgKyBpZCxcbiAgICAgIG9wdGlvbnNcbiAgICApO1xuICB9XG4gIHJldHVybiByZXNcbn1cblxuLyogICovXG5cblxuXG5mdW5jdGlvbiB2YWxpZGF0ZVByb3AgKFxuICBrZXksXG4gIHByb3BPcHRpb25zLFxuICBwcm9wc0RhdGEsXG4gIHZtXG4pIHtcbiAgdmFyIHByb3AgPSBwcm9wT3B0aW9uc1trZXldO1xuICB2YXIgYWJzZW50ID0gIWhhc093bihwcm9wc0RhdGEsIGtleSk7XG4gIHZhciB2YWx1ZSA9IHByb3BzRGF0YVtrZXldO1xuICAvLyBib29sZWFuIGNhc3RpbmdcbiAgdmFyIGJvb2xlYW5JbmRleCA9IGdldFR5cGVJbmRleChCb29sZWFuLCBwcm9wLnR5cGUpO1xuICBpZiAoYm9vbGVhbkluZGV4ID4gLTEpIHtcbiAgICBpZiAoYWJzZW50ICYmICFoYXNPd24ocHJvcCwgJ2RlZmF1bHQnKSkge1xuICAgICAgdmFsdWUgPSBmYWxzZTtcbiAgICB9IGVsc2UgaWYgKHZhbHVlID09PSAnJyB8fCB2YWx1ZSA9PT0gaHlwaGVuYXRlKGtleSkpIHtcbiAgICAgIC8vIG9ubHkgY2FzdCBlbXB0eSBzdHJpbmcgLyBzYW1lIG5hbWUgdG8gYm9vbGVhbiBpZlxuICAgICAgLy8gYm9vbGVhbiBoYXMgaGlnaGVyIHByaW9yaXR5XG4gICAgICB2YXIgc3RyaW5nSW5kZXggPSBnZXRUeXBlSW5kZXgoU3RyaW5nLCBwcm9wLnR5cGUpO1xuICAgICAgaWYgKHN0cmluZ0luZGV4IDwgMCB8fCBib29sZWFuSW5kZXggPCBzdHJpbmdJbmRleCkge1xuICAgICAgICB2YWx1ZSA9IHRydWU7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIC8vIGNoZWNrIGRlZmF1bHQgdmFsdWVcbiAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICB2YWx1ZSA9IGdldFByb3BEZWZhdWx0VmFsdWUodm0sIHByb3AsIGtleSk7XG4gICAgLy8gc2luY2UgdGhlIGRlZmF1bHQgdmFsdWUgaXMgYSBmcmVzaCBjb3B5LFxuICAgIC8vIG1ha2Ugc3VyZSB0byBvYnNlcnZlIGl0LlxuICAgIHZhciBwcmV2U2hvdWxkT2JzZXJ2ZSA9IHNob3VsZE9ic2VydmU7XG4gICAgdG9nZ2xlT2JzZXJ2aW5nKHRydWUpO1xuICAgIG9ic2VydmUodmFsdWUpO1xuICAgIHRvZ2dsZU9ic2VydmluZyhwcmV2U2hvdWxkT2JzZXJ2ZSk7XG4gIH1cbiAgaWYgKFxuICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiZcbiAgICAvLyBza2lwIHZhbGlkYXRpb24gZm9yIHdlZXggcmVjeWNsZS1saXN0IGNoaWxkIGNvbXBvbmVudCBwcm9wc1xuICAgICEoZmFsc2UpXG4gICkge1xuICAgIGFzc2VydFByb3AocHJvcCwga2V5LCB2YWx1ZSwgdm0sIGFic2VudCk7XG4gIH1cbiAgcmV0dXJuIHZhbHVlXG59XG5cbi8qKlxuICogR2V0IHRoZSBkZWZhdWx0IHZhbHVlIG9mIGEgcHJvcC5cbiAqL1xuZnVuY3Rpb24gZ2V0UHJvcERlZmF1bHRWYWx1ZSAodm0sIHByb3AsIGtleSkge1xuICAvLyBubyBkZWZhdWx0LCByZXR1cm4gdW5kZWZpbmVkXG4gIGlmICghaGFzT3duKHByb3AsICdkZWZhdWx0JykpIHtcbiAgICByZXR1cm4gdW5kZWZpbmVkXG4gIH1cbiAgdmFyIGRlZiA9IHByb3AuZGVmYXVsdDtcbiAgLy8gd2FybiBhZ2FpbnN0IG5vbi1mYWN0b3J5IGRlZmF1bHRzIGZvciBPYmplY3QgJiBBcnJheVxuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiBpc09iamVjdChkZWYpKSB7XG4gICAgd2FybihcbiAgICAgICdJbnZhbGlkIGRlZmF1bHQgdmFsdWUgZm9yIHByb3AgXCInICsga2V5ICsgJ1wiOiAnICtcbiAgICAgICdQcm9wcyB3aXRoIHR5cGUgT2JqZWN0L0FycmF5IG11c3QgdXNlIGEgZmFjdG9yeSBmdW5jdGlvbiAnICtcbiAgICAgICd0byByZXR1cm4gdGhlIGRlZmF1bHQgdmFsdWUuJyxcbiAgICAgIHZtXG4gICAgKTtcbiAgfVxuICAvLyB0aGUgcmF3IHByb3AgdmFsdWUgd2FzIGFsc28gdW5kZWZpbmVkIGZyb20gcHJldmlvdXMgcmVuZGVyLFxuICAvLyByZXR1cm4gcHJldmlvdXMgZGVmYXVsdCB2YWx1ZSB0byBhdm9pZCB1bm5lY2Vzc2FyeSB3YXRjaGVyIHRyaWdnZXJcbiAgaWYgKHZtICYmIHZtLiRvcHRpb25zLnByb3BzRGF0YSAmJlxuICAgIHZtLiRvcHRpb25zLnByb3BzRGF0YVtrZXldID09PSB1bmRlZmluZWQgJiZcbiAgICB2bS5fcHJvcHNba2V5XSAhPT0gdW5kZWZpbmVkXG4gICkge1xuICAgIHJldHVybiB2bS5fcHJvcHNba2V5XVxuICB9XG4gIC8vIGNhbGwgZmFjdG9yeSBmdW5jdGlvbiBmb3Igbm9uLUZ1bmN0aW9uIHR5cGVzXG4gIC8vIGEgdmFsdWUgaXMgRnVuY3Rpb24gaWYgaXRzIHByb3RvdHlwZSBpcyBmdW5jdGlvbiBldmVuIGFjcm9zcyBkaWZmZXJlbnQgZXhlY3V0aW9uIGNvbnRleHRcbiAgcmV0dXJuIHR5cGVvZiBkZWYgPT09ICdmdW5jdGlvbicgJiYgZ2V0VHlwZShwcm9wLnR5cGUpICE9PSAnRnVuY3Rpb24nXG4gICAgPyBkZWYuY2FsbCh2bSlcbiAgICA6IGRlZlxufVxuXG4vKipcbiAqIEFzc2VydCB3aGV0aGVyIGEgcHJvcCBpcyB2YWxpZC5cbiAqL1xuZnVuY3Rpb24gYXNzZXJ0UHJvcCAoXG4gIHByb3AsXG4gIG5hbWUsXG4gIHZhbHVlLFxuICB2bSxcbiAgYWJzZW50XG4pIHtcbiAgaWYgKHByb3AucmVxdWlyZWQgJiYgYWJzZW50KSB7XG4gICAgd2FybihcbiAgICAgICdNaXNzaW5nIHJlcXVpcmVkIHByb3A6IFwiJyArIG5hbWUgKyAnXCInLFxuICAgICAgdm1cbiAgICApO1xuICAgIHJldHVyblxuICB9XG4gIGlmICh2YWx1ZSA9PSBudWxsICYmICFwcm9wLnJlcXVpcmVkKSB7XG4gICAgcmV0dXJuXG4gIH1cbiAgdmFyIHR5cGUgPSBwcm9wLnR5cGU7XG4gIHZhciB2YWxpZCA9ICF0eXBlIHx8IHR5cGUgPT09IHRydWU7XG4gIHZhciBleHBlY3RlZFR5cGVzID0gW107XG4gIGlmICh0eXBlKSB7XG4gICAgaWYgKCFBcnJheS5pc0FycmF5KHR5cGUpKSB7XG4gICAgICB0eXBlID0gW3R5cGVdO1xuICAgIH1cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHR5cGUubGVuZ3RoICYmICF2YWxpZDsgaSsrKSB7XG4gICAgICB2YXIgYXNzZXJ0ZWRUeXBlID0gYXNzZXJ0VHlwZSh2YWx1ZSwgdHlwZVtpXSwgdm0pO1xuICAgICAgZXhwZWN0ZWRUeXBlcy5wdXNoKGFzc2VydGVkVHlwZS5leHBlY3RlZFR5cGUgfHwgJycpO1xuICAgICAgdmFsaWQgPSBhc3NlcnRlZFR5cGUudmFsaWQ7XG4gICAgfVxuICB9XG5cbiAgdmFyIGhhdmVFeHBlY3RlZFR5cGVzID0gZXhwZWN0ZWRUeXBlcy5zb21lKGZ1bmN0aW9uICh0KSB7IHJldHVybiB0OyB9KTtcbiAgaWYgKCF2YWxpZCAmJiBoYXZlRXhwZWN0ZWRUeXBlcykge1xuICAgIHdhcm4oXG4gICAgICBnZXRJbnZhbGlkVHlwZU1lc3NhZ2UobmFtZSwgdmFsdWUsIGV4cGVjdGVkVHlwZXMpLFxuICAgICAgdm1cbiAgICApO1xuICAgIHJldHVyblxuICB9XG4gIHZhciB2YWxpZGF0b3IgPSBwcm9wLnZhbGlkYXRvcjtcbiAgaWYgKHZhbGlkYXRvcikge1xuICAgIGlmICghdmFsaWRhdG9yKHZhbHVlKSkge1xuICAgICAgd2FybihcbiAgICAgICAgJ0ludmFsaWQgcHJvcDogY3VzdG9tIHZhbGlkYXRvciBjaGVjayBmYWlsZWQgZm9yIHByb3AgXCInICsgbmFtZSArICdcIi4nLFxuICAgICAgICB2bVxuICAgICAgKTtcbiAgICB9XG4gIH1cbn1cblxudmFyIHNpbXBsZUNoZWNrUkUgPSAvXihTdHJpbmd8TnVtYmVyfEJvb2xlYW58RnVuY3Rpb258U3ltYm9sfEJpZ0ludCkkLztcblxuZnVuY3Rpb24gYXNzZXJ0VHlwZSAodmFsdWUsIHR5cGUsIHZtKSB7XG4gIHZhciB2YWxpZDtcbiAgdmFyIGV4cGVjdGVkVHlwZSA9IGdldFR5cGUodHlwZSk7XG4gIGlmIChzaW1wbGVDaGVja1JFLnRlc3QoZXhwZWN0ZWRUeXBlKSkge1xuICAgIHZhciB0ID0gdHlwZW9mIHZhbHVlO1xuICAgIHZhbGlkID0gdCA9PT0gZXhwZWN0ZWRUeXBlLnRvTG93ZXJDYXNlKCk7XG4gICAgLy8gZm9yIHByaW1pdGl2ZSB3cmFwcGVyIG9iamVjdHNcbiAgICBpZiAoIXZhbGlkICYmIHQgPT09ICdvYmplY3QnKSB7XG4gICAgICB2YWxpZCA9IHZhbHVlIGluc3RhbmNlb2YgdHlwZTtcbiAgICB9XG4gIH0gZWxzZSBpZiAoZXhwZWN0ZWRUeXBlID09PSAnT2JqZWN0Jykge1xuICAgIHZhbGlkID0gaXNQbGFpbk9iamVjdCh2YWx1ZSk7XG4gIH0gZWxzZSBpZiAoZXhwZWN0ZWRUeXBlID09PSAnQXJyYXknKSB7XG4gICAgdmFsaWQgPSBBcnJheS5pc0FycmF5KHZhbHVlKTtcbiAgfSBlbHNlIHtcbiAgICB0cnkge1xuICAgICAgdmFsaWQgPSB2YWx1ZSBpbnN0YW5jZW9mIHR5cGU7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgd2FybignSW52YWxpZCBwcm9wIHR5cGU6IFwiJyArIFN0cmluZyh0eXBlKSArICdcIiBpcyBub3QgYSBjb25zdHJ1Y3RvcicsIHZtKTtcbiAgICAgIHZhbGlkID0gZmFsc2U7XG4gICAgfVxuICB9XG4gIHJldHVybiB7XG4gICAgdmFsaWQ6IHZhbGlkLFxuICAgIGV4cGVjdGVkVHlwZTogZXhwZWN0ZWRUeXBlXG4gIH1cbn1cblxudmFyIGZ1bmN0aW9uVHlwZUNoZWNrUkUgPSAvXlxccypmdW5jdGlvbiAoXFx3KykvO1xuXG4vKipcbiAqIFVzZSBmdW5jdGlvbiBzdHJpbmcgbmFtZSB0byBjaGVjayBidWlsdC1pbiB0eXBlcyxcbiAqIGJlY2F1c2UgYSBzaW1wbGUgZXF1YWxpdHkgY2hlY2sgd2lsbCBmYWlsIHdoZW4gcnVubmluZ1xuICogYWNyb3NzIGRpZmZlcmVudCB2bXMgLyBpZnJhbWVzLlxuICovXG5mdW5jdGlvbiBnZXRUeXBlIChmbikge1xuICB2YXIgbWF0Y2ggPSBmbiAmJiBmbi50b1N0cmluZygpLm1hdGNoKGZ1bmN0aW9uVHlwZUNoZWNrUkUpO1xuICByZXR1cm4gbWF0Y2ggPyBtYXRjaFsxXSA6ICcnXG59XG5cbmZ1bmN0aW9uIGlzU2FtZVR5cGUgKGEsIGIpIHtcbiAgcmV0dXJuIGdldFR5cGUoYSkgPT09IGdldFR5cGUoYilcbn1cblxuZnVuY3Rpb24gZ2V0VHlwZUluZGV4ICh0eXBlLCBleHBlY3RlZFR5cGVzKSB7XG4gIGlmICghQXJyYXkuaXNBcnJheShleHBlY3RlZFR5cGVzKSkge1xuICAgIHJldHVybiBpc1NhbWVUeXBlKGV4cGVjdGVkVHlwZXMsIHR5cGUpID8gMCA6IC0xXG4gIH1cbiAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IGV4cGVjdGVkVHlwZXMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICBpZiAoaXNTYW1lVHlwZShleHBlY3RlZFR5cGVzW2ldLCB0eXBlKSkge1xuICAgICAgcmV0dXJuIGlcbiAgICB9XG4gIH1cbiAgcmV0dXJuIC0xXG59XG5cbmZ1bmN0aW9uIGdldEludmFsaWRUeXBlTWVzc2FnZSAobmFtZSwgdmFsdWUsIGV4cGVjdGVkVHlwZXMpIHtcbiAgdmFyIG1lc3NhZ2UgPSBcIkludmFsaWQgcHJvcDogdHlwZSBjaGVjayBmYWlsZWQgZm9yIHByb3AgXFxcIlwiICsgbmFtZSArIFwiXFxcIi5cIiArXG4gICAgXCIgRXhwZWN0ZWQgXCIgKyAoZXhwZWN0ZWRUeXBlcy5tYXAoY2FwaXRhbGl6ZSkuam9pbignLCAnKSk7XG4gIHZhciBleHBlY3RlZFR5cGUgPSBleHBlY3RlZFR5cGVzWzBdO1xuICB2YXIgcmVjZWl2ZWRUeXBlID0gdG9SYXdUeXBlKHZhbHVlKTtcbiAgLy8gY2hlY2sgaWYgd2UgbmVlZCB0byBzcGVjaWZ5IGV4cGVjdGVkIHZhbHVlXG4gIGlmIChcbiAgICBleHBlY3RlZFR5cGVzLmxlbmd0aCA9PT0gMSAmJlxuICAgIGlzRXhwbGljYWJsZShleHBlY3RlZFR5cGUpICYmXG4gICAgaXNFeHBsaWNhYmxlKHR5cGVvZiB2YWx1ZSkgJiZcbiAgICAhaXNCb29sZWFuKGV4cGVjdGVkVHlwZSwgcmVjZWl2ZWRUeXBlKVxuICApIHtcbiAgICBtZXNzYWdlICs9IFwiIHdpdGggdmFsdWUgXCIgKyAoc3R5bGVWYWx1ZSh2YWx1ZSwgZXhwZWN0ZWRUeXBlKSk7XG4gIH1cbiAgbWVzc2FnZSArPSBcIiwgZ290IFwiICsgcmVjZWl2ZWRUeXBlICsgXCIgXCI7XG4gIC8vIGNoZWNrIGlmIHdlIG5lZWQgdG8gc3BlY2lmeSByZWNlaXZlZCB2YWx1ZVxuICBpZiAoaXNFeHBsaWNhYmxlKHJlY2VpdmVkVHlwZSkpIHtcbiAgICBtZXNzYWdlICs9IFwid2l0aCB2YWx1ZSBcIiArIChzdHlsZVZhbHVlKHZhbHVlLCByZWNlaXZlZFR5cGUpKSArIFwiLlwiO1xuICB9XG4gIHJldHVybiBtZXNzYWdlXG59XG5cbmZ1bmN0aW9uIHN0eWxlVmFsdWUgKHZhbHVlLCB0eXBlKSB7XG4gIGlmICh0eXBlID09PSAnU3RyaW5nJykge1xuICAgIHJldHVybiAoXCJcXFwiXCIgKyB2YWx1ZSArIFwiXFxcIlwiKVxuICB9IGVsc2UgaWYgKHR5cGUgPT09ICdOdW1iZXInKSB7XG4gICAgcmV0dXJuIChcIlwiICsgKE51bWJlcih2YWx1ZSkpKVxuICB9IGVsc2Uge1xuICAgIHJldHVybiAoXCJcIiArIHZhbHVlKVxuICB9XG59XG5cbnZhciBFWFBMSUNBQkxFX1RZUEVTID0gWydzdHJpbmcnLCAnbnVtYmVyJywgJ2Jvb2xlYW4nXTtcbmZ1bmN0aW9uIGlzRXhwbGljYWJsZSAodmFsdWUpIHtcbiAgcmV0dXJuIEVYUExJQ0FCTEVfVFlQRVMuc29tZShmdW5jdGlvbiAoZWxlbSkgeyByZXR1cm4gdmFsdWUudG9Mb3dlckNhc2UoKSA9PT0gZWxlbTsgfSlcbn1cblxuZnVuY3Rpb24gaXNCb29sZWFuICgpIHtcbiAgdmFyIGFyZ3MgPSBbXSwgbGVuID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgd2hpbGUgKCBsZW4tLSApIGFyZ3NbIGxlbiBdID0gYXJndW1lbnRzWyBsZW4gXTtcblxuICByZXR1cm4gYXJncy5zb21lKGZ1bmN0aW9uIChlbGVtKSB7IHJldHVybiBlbGVtLnRvTG93ZXJDYXNlKCkgPT09ICdib29sZWFuJzsgfSlcbn1cblxuLyogICovXG5cbmZ1bmN0aW9uIGhhbmRsZUVycm9yIChlcnIsIHZtLCBpbmZvKSB7XG4gIC8vIERlYWN0aXZhdGUgZGVwcyB0cmFja2luZyB3aGlsZSBwcm9jZXNzaW5nIGVycm9yIGhhbmRsZXIgdG8gYXZvaWQgcG9zc2libGUgaW5maW5pdGUgcmVuZGVyaW5nLlxuICAvLyBTZWU6IGh0dHBzOi8vZ2l0aHViLmNvbS92dWVqcy92dWV4L2lzc3Vlcy8xNTA1XG4gIHB1c2hUYXJnZXQoKTtcbiAgdHJ5IHtcbiAgICBpZiAodm0pIHtcbiAgICAgIHZhciBjdXIgPSB2bTtcbiAgICAgIHdoaWxlICgoY3VyID0gY3VyLiRwYXJlbnQpKSB7XG4gICAgICAgIHZhciBob29rcyA9IGN1ci4kb3B0aW9ucy5lcnJvckNhcHR1cmVkO1xuICAgICAgICBpZiAoaG9va3MpIHtcbiAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGhvb2tzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICB2YXIgY2FwdHVyZSA9IGhvb2tzW2ldLmNhbGwoY3VyLCBlcnIsIHZtLCBpbmZvKSA9PT0gZmFsc2U7XG4gICAgICAgICAgICAgIGlmIChjYXB0dXJlKSB7IHJldHVybiB9XG4gICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgIGdsb2JhbEhhbmRsZUVycm9yKGUsIGN1ciwgJ2Vycm9yQ2FwdHVyZWQgaG9vaycpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBnbG9iYWxIYW5kbGVFcnJvcihlcnIsIHZtLCBpbmZvKTtcbiAgfSBmaW5hbGx5IHtcbiAgICBwb3BUYXJnZXQoKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBpbnZva2VXaXRoRXJyb3JIYW5kbGluZyAoXG4gIGhhbmRsZXIsXG4gIGNvbnRleHQsXG4gIGFyZ3MsXG4gIHZtLFxuICBpbmZvXG4pIHtcbiAgdmFyIHJlcztcbiAgdHJ5IHtcbiAgICByZXMgPSBhcmdzID8gaGFuZGxlci5hcHBseShjb250ZXh0LCBhcmdzKSA6IGhhbmRsZXIuY2FsbChjb250ZXh0KTtcbiAgICBpZiAocmVzICYmICFyZXMuX2lzVnVlICYmIGlzUHJvbWlzZShyZXMpICYmICFyZXMuX2hhbmRsZWQpIHtcbiAgICAgIHJlcy5jYXRjaChmdW5jdGlvbiAoZSkgeyByZXR1cm4gaGFuZGxlRXJyb3IoZSwgdm0sIGluZm8gKyBcIiAoUHJvbWlzZS9hc3luYylcIik7IH0pO1xuICAgICAgLy8gaXNzdWUgIzk1MTFcbiAgICAgIC8vIGF2b2lkIGNhdGNoIHRyaWdnZXJpbmcgbXVsdGlwbGUgdGltZXMgd2hlbiBuZXN0ZWQgY2FsbHNcbiAgICAgIHJlcy5faGFuZGxlZCA9IHRydWU7XG4gICAgfVxuICB9IGNhdGNoIChlKSB7XG4gICAgaGFuZGxlRXJyb3IoZSwgdm0sIGluZm8pO1xuICB9XG4gIHJldHVybiByZXNcbn1cblxuZnVuY3Rpb24gZ2xvYmFsSGFuZGxlRXJyb3IgKGVyciwgdm0sIGluZm8pIHtcbiAgaWYgKGNvbmZpZy5lcnJvckhhbmRsZXIpIHtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIGNvbmZpZy5lcnJvckhhbmRsZXIuY2FsbChudWxsLCBlcnIsIHZtLCBpbmZvKVxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIC8vIGlmIHRoZSB1c2VyIGludGVudGlvbmFsbHkgdGhyb3dzIHRoZSBvcmlnaW5hbCBlcnJvciBpbiB0aGUgaGFuZGxlcixcbiAgICAgIC8vIGRvIG5vdCBsb2cgaXQgdHdpY2VcbiAgICAgIGlmIChlICE9PSBlcnIpIHtcbiAgICAgICAgbG9nRXJyb3IoZSwgbnVsbCwgJ2NvbmZpZy5lcnJvckhhbmRsZXInKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgbG9nRXJyb3IoZXJyLCB2bSwgaW5mbyk7XG59XG5cbmZ1bmN0aW9uIGxvZ0Vycm9yIChlcnIsIHZtLCBpbmZvKSB7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgd2FybigoXCJFcnJvciBpbiBcIiArIGluZm8gKyBcIjogXFxcIlwiICsgKGVyci50b1N0cmluZygpKSArIFwiXFxcIlwiKSwgdm0pO1xuICB9XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG4gIGlmICgoaW5Ccm93c2VyIHx8IGluV2VleCkgJiYgdHlwZW9mIGNvbnNvbGUgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgY29uc29sZS5lcnJvcihlcnIpO1xuICB9IGVsc2Uge1xuICAgIHRocm93IGVyclxuICB9XG59XG5cbi8qICAqL1xuXG52YXIgaXNVc2luZ01pY3JvVGFzayA9IGZhbHNlO1xuXG52YXIgY2FsbGJhY2tzID0gW107XG52YXIgcGVuZGluZyA9IGZhbHNlO1xuXG5mdW5jdGlvbiBmbHVzaENhbGxiYWNrcyAoKSB7XG4gIHBlbmRpbmcgPSBmYWxzZTtcbiAgdmFyIGNvcGllcyA9IGNhbGxiYWNrcy5zbGljZSgwKTtcbiAgY2FsbGJhY2tzLmxlbmd0aCA9IDA7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgY29waWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgY29waWVzW2ldKCk7XG4gIH1cbn1cblxuLy8gSGVyZSB3ZSBoYXZlIGFzeW5jIGRlZmVycmluZyB3cmFwcGVycyB1c2luZyBtaWNyb3Rhc2tzLlxuLy8gSW4gMi41IHdlIHVzZWQgKG1hY3JvKSB0YXNrcyAoaW4gY29tYmluYXRpb24gd2l0aCBtaWNyb3Rhc2tzKS5cbi8vIEhvd2V2ZXIsIGl0IGhhcyBzdWJ0bGUgcHJvYmxlbXMgd2hlbiBzdGF0ZSBpcyBjaGFuZ2VkIHJpZ2h0IGJlZm9yZSByZXBhaW50XG4vLyAoZS5nLiAjNjgxMywgb3V0LWluIHRyYW5zaXRpb25zKS5cbi8vIEFsc28sIHVzaW5nIChtYWNybykgdGFza3MgaW4gZXZlbnQgaGFuZGxlciB3b3VsZCBjYXVzZSBzb21lIHdlaXJkIGJlaGF2aW9yc1xuLy8gdGhhdCBjYW5ub3QgYmUgY2lyY3VtdmVudGVkIChlLmcuICM3MTA5LCAjNzE1MywgIzc1NDYsICM3ODM0LCAjODEwOSkuXG4vLyBTbyB3ZSBub3cgdXNlIG1pY3JvdGFza3MgZXZlcnl3aGVyZSwgYWdhaW4uXG4vLyBBIG1ham9yIGRyYXdiYWNrIG9mIHRoaXMgdHJhZGVvZmYgaXMgdGhhdCB0aGVyZSBhcmUgc29tZSBzY2VuYXJpb3Ncbi8vIHdoZXJlIG1pY3JvdGFza3MgaGF2ZSB0b28gaGlnaCBhIHByaW9yaXR5IGFuZCBmaXJlIGluIGJldHdlZW4gc3VwcG9zZWRseVxuLy8gc2VxdWVudGlhbCBldmVudHMgKGUuZy4gIzQ1MjEsICM2NjkwLCB3aGljaCBoYXZlIHdvcmthcm91bmRzKVxuLy8gb3IgZXZlbiBiZXR3ZWVuIGJ1YmJsaW5nIG9mIHRoZSBzYW1lIGV2ZW50ICgjNjU2NikuXG52YXIgdGltZXJGdW5jO1xuXG4vLyBUaGUgbmV4dFRpY2sgYmVoYXZpb3IgbGV2ZXJhZ2VzIHRoZSBtaWNyb3Rhc2sgcXVldWUsIHdoaWNoIGNhbiBiZSBhY2Nlc3NlZFxuLy8gdmlhIGVpdGhlciBuYXRpdmUgUHJvbWlzZS50aGVuIG9yIE11dGF0aW9uT2JzZXJ2ZXIuXG4vLyBNdXRhdGlvbk9ic2VydmVyIGhhcyB3aWRlciBzdXBwb3J0LCBob3dldmVyIGl0IGlzIHNlcmlvdXNseSBidWdnZWQgaW5cbi8vIFVJV2ViVmlldyBpbiBpT1MgPj0gOS4zLjMgd2hlbiB0cmlnZ2VyZWQgaW4gdG91Y2ggZXZlbnQgaGFuZGxlcnMuIEl0XG4vLyBjb21wbGV0ZWx5IHN0b3BzIHdvcmtpbmcgYWZ0ZXIgdHJpZ2dlcmluZyBhIGZldyB0aW1lcy4uLiBzbywgaWYgbmF0aXZlXG4vLyBQcm9taXNlIGlzIGF2YWlsYWJsZSwgd2Ugd2lsbCB1c2UgaXQ6XG4vKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCwgJGZsb3ctZGlzYWJsZS1saW5lICovXG5pZiAodHlwZW9mIFByb21pc2UgIT09ICd1bmRlZmluZWQnICYmIGlzTmF0aXZlKFByb21pc2UpKSB7XG4gIHZhciBwID0gUHJvbWlzZS5yZXNvbHZlKCk7XG4gIHRpbWVyRnVuYyA9IGZ1bmN0aW9uICgpIHtcbiAgICBwLnRoZW4oZmx1c2hDYWxsYmFja3MpO1xuICAgIC8vIEluIHByb2JsZW1hdGljIFVJV2ViVmlld3MsIFByb21pc2UudGhlbiBkb2Vzbid0IGNvbXBsZXRlbHkgYnJlYWssIGJ1dFxuICAgIC8vIGl0IGNhbiBnZXQgc3R1Y2sgaW4gYSB3ZWlyZCBzdGF0ZSB3aGVyZSBjYWxsYmFja3MgYXJlIHB1c2hlZCBpbnRvIHRoZVxuICAgIC8vIG1pY3JvdGFzayBxdWV1ZSBidXQgdGhlIHF1ZXVlIGlzbid0IGJlaW5nIGZsdXNoZWQsIHVudGlsIHRoZSBicm93c2VyXG4gICAgLy8gbmVlZHMgdG8gZG8gc29tZSBvdGhlciB3b3JrLCBlLmcuIGhhbmRsZSBhIHRpbWVyLiBUaGVyZWZvcmUgd2UgY2FuXG4gICAgLy8gXCJmb3JjZVwiIHRoZSBtaWNyb3Rhc2sgcXVldWUgdG8gYmUgZmx1c2hlZCBieSBhZGRpbmcgYW4gZW1wdHkgdGltZXIuXG4gICAgaWYgKGlzSU9TKSB7IHNldFRpbWVvdXQobm9vcCk7IH1cbiAgfTtcbiAgaXNVc2luZ01pY3JvVGFzayA9IHRydWU7XG59IGVsc2UgaWYgKCFpc0lFICYmIHR5cGVvZiBNdXRhdGlvbk9ic2VydmVyICE9PSAndW5kZWZpbmVkJyAmJiAoXG4gIGlzTmF0aXZlKE11dGF0aW9uT2JzZXJ2ZXIpIHx8XG4gIC8vIFBoYW50b21KUyBhbmQgaU9TIDcueFxuICBNdXRhdGlvbk9ic2VydmVyLnRvU3RyaW5nKCkgPT09ICdbb2JqZWN0IE11dGF0aW9uT2JzZXJ2ZXJDb25zdHJ1Y3Rvcl0nXG4pKSB7XG4gIC8vIFVzZSBNdXRhdGlvbk9ic2VydmVyIHdoZXJlIG5hdGl2ZSBQcm9taXNlIGlzIG5vdCBhdmFpbGFibGUsXG4gIC8vIGUuZy4gUGhhbnRvbUpTLCBpT1M3LCBBbmRyb2lkIDQuNFxuICAvLyAoIzY0NjYgTXV0YXRpb25PYnNlcnZlciBpcyB1bnJlbGlhYmxlIGluIElFMTEpXG4gIHZhciBjb3VudGVyID0gMTtcbiAgdmFyIG9ic2VydmVyID0gbmV3IE11dGF0aW9uT2JzZXJ2ZXIoZmx1c2hDYWxsYmFja3MpO1xuICB2YXIgdGV4dE5vZGUgPSBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShTdHJpbmcoY291bnRlcikpO1xuICBvYnNlcnZlci5vYnNlcnZlKHRleHROb2RlLCB7XG4gICAgY2hhcmFjdGVyRGF0YTogdHJ1ZVxuICB9KTtcbiAgdGltZXJGdW5jID0gZnVuY3Rpb24gKCkge1xuICAgIGNvdW50ZXIgPSAoY291bnRlciArIDEpICUgMjtcbiAgICB0ZXh0Tm9kZS5kYXRhID0gU3RyaW5nKGNvdW50ZXIpO1xuICB9O1xuICBpc1VzaW5nTWljcm9UYXNrID0gdHJ1ZTtcbn0gZWxzZSBpZiAodHlwZW9mIHNldEltbWVkaWF0ZSAhPT0gJ3VuZGVmaW5lZCcgJiYgaXNOYXRpdmUoc2V0SW1tZWRpYXRlKSkge1xuICAvLyBGYWxsYmFjayB0byBzZXRJbW1lZGlhdGUuXG4gIC8vIFRlY2huaWNhbGx5IGl0IGxldmVyYWdlcyB0aGUgKG1hY3JvKSB0YXNrIHF1ZXVlLFxuICAvLyBidXQgaXQgaXMgc3RpbGwgYSBiZXR0ZXIgY2hvaWNlIHRoYW4gc2V0VGltZW91dC5cbiAgdGltZXJGdW5jID0gZnVuY3Rpb24gKCkge1xuICAgIHNldEltbWVkaWF0ZShmbHVzaENhbGxiYWNrcyk7XG4gIH07XG59IGVsc2Uge1xuICAvLyBGYWxsYmFjayB0byBzZXRUaW1lb3V0LlxuICB0aW1lckZ1bmMgPSBmdW5jdGlvbiAoKSB7XG4gICAgc2V0VGltZW91dChmbHVzaENhbGxiYWNrcywgMCk7XG4gIH07XG59XG5cbmZ1bmN0aW9uIG5leHRUaWNrIChjYiwgY3R4KSB7XG4gIHZhciBfcmVzb2x2ZTtcbiAgY2FsbGJhY2tzLnB1c2goZnVuY3Rpb24gKCkge1xuICAgIGlmIChjYikge1xuICAgICAgdHJ5IHtcbiAgICAgICAgY2IuY2FsbChjdHgpO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBoYW5kbGVFcnJvcihlLCBjdHgsICduZXh0VGljaycpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoX3Jlc29sdmUpIHtcbiAgICAgIF9yZXNvbHZlKGN0eCk7XG4gICAgfVxuICB9KTtcbiAgaWYgKCFwZW5kaW5nKSB7XG4gICAgcGVuZGluZyA9IHRydWU7XG4gICAgdGltZXJGdW5jKCk7XG4gIH1cbiAgLy8gJGZsb3ctZGlzYWJsZS1saW5lXG4gIGlmICghY2IgJiYgdHlwZW9mIFByb21pc2UgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlKSB7XG4gICAgICBfcmVzb2x2ZSA9IHJlc29sdmU7XG4gICAgfSlcbiAgfVxufVxuXG4vKiAgKi9cblxudmFyIG1hcms7XG52YXIgbWVhc3VyZTtcblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgdmFyIHBlcmYgPSBpbkJyb3dzZXIgJiYgd2luZG93LnBlcmZvcm1hbmNlO1xuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgaWYgKFxuICAgIHBlcmYgJiZcbiAgICBwZXJmLm1hcmsgJiZcbiAgICBwZXJmLm1lYXN1cmUgJiZcbiAgICBwZXJmLmNsZWFyTWFya3MgJiZcbiAgICBwZXJmLmNsZWFyTWVhc3VyZXNcbiAgKSB7XG4gICAgbWFyayA9IGZ1bmN0aW9uICh0YWcpIHsgcmV0dXJuIHBlcmYubWFyayh0YWcpOyB9O1xuICAgIG1lYXN1cmUgPSBmdW5jdGlvbiAobmFtZSwgc3RhcnRUYWcsIGVuZFRhZykge1xuICAgICAgcGVyZi5tZWFzdXJlKG5hbWUsIHN0YXJ0VGFnLCBlbmRUYWcpO1xuICAgICAgcGVyZi5jbGVhck1hcmtzKHN0YXJ0VGFnKTtcbiAgICAgIHBlcmYuY2xlYXJNYXJrcyhlbmRUYWcpO1xuICAgICAgLy8gcGVyZi5jbGVhck1lYXN1cmVzKG5hbWUpXG4gICAgfTtcbiAgfVxufVxuXG4vKiBub3QgdHlwZSBjaGVja2luZyB0aGlzIGZpbGUgYmVjYXVzZSBmbG93IGRvZXNuJ3QgcGxheSB3ZWxsIHdpdGggUHJveHkgKi9cblxudmFyIGluaXRQcm94eTtcblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgdmFyIGFsbG93ZWRHbG9iYWxzID0gbWFrZU1hcChcbiAgICAnSW5maW5pdHksdW5kZWZpbmVkLE5hTixpc0Zpbml0ZSxpc05hTiwnICtcbiAgICAncGFyc2VGbG9hdCxwYXJzZUludCxkZWNvZGVVUkksZGVjb2RlVVJJQ29tcG9uZW50LGVuY29kZVVSSSxlbmNvZGVVUklDb21wb25lbnQsJyArXG4gICAgJ01hdGgsTnVtYmVyLERhdGUsQXJyYXksT2JqZWN0LEJvb2xlYW4sU3RyaW5nLFJlZ0V4cCxNYXAsU2V0LEpTT04sSW50bCxCaWdJbnQsJyArXG4gICAgJ3JlcXVpcmUnIC8vIGZvciBXZWJwYWNrL0Jyb3dzZXJpZnlcbiAgKTtcblxuICB2YXIgd2Fybk5vblByZXNlbnQgPSBmdW5jdGlvbiAodGFyZ2V0LCBrZXkpIHtcbiAgICB3YXJuKFxuICAgICAgXCJQcm9wZXJ0eSBvciBtZXRob2QgXFxcIlwiICsga2V5ICsgXCJcXFwiIGlzIG5vdCBkZWZpbmVkIG9uIHRoZSBpbnN0YW5jZSBidXQgXCIgK1xuICAgICAgJ3JlZmVyZW5jZWQgZHVyaW5nIHJlbmRlci4gTWFrZSBzdXJlIHRoYXQgdGhpcyBwcm9wZXJ0eSBpcyByZWFjdGl2ZSwgJyArXG4gICAgICAnZWl0aGVyIGluIHRoZSBkYXRhIG9wdGlvbiwgb3IgZm9yIGNsYXNzLWJhc2VkIGNvbXBvbmVudHMsIGJ5ICcgK1xuICAgICAgJ2luaXRpYWxpemluZyB0aGUgcHJvcGVydHkuICcgK1xuICAgICAgJ1NlZTogaHR0cHM6Ly92dWVqcy5vcmcvdjIvZ3VpZGUvcmVhY3Rpdml0eS5odG1sI0RlY2xhcmluZy1SZWFjdGl2ZS1Qcm9wZXJ0aWVzLicsXG4gICAgICB0YXJnZXRcbiAgICApO1xuICB9O1xuXG4gIHZhciB3YXJuUmVzZXJ2ZWRQcmVmaXggPSBmdW5jdGlvbiAodGFyZ2V0LCBrZXkpIHtcbiAgICB3YXJuKFxuICAgICAgXCJQcm9wZXJ0eSBcXFwiXCIgKyBrZXkgKyBcIlxcXCIgbXVzdCBiZSBhY2Nlc3NlZCB3aXRoIFxcXCIkZGF0YS5cIiArIGtleSArIFwiXFxcIiBiZWNhdXNlIFwiICtcbiAgICAgICdwcm9wZXJ0aWVzIHN0YXJ0aW5nIHdpdGggXCIkXCIgb3IgXCJfXCIgYXJlIG5vdCBwcm94aWVkIGluIHRoZSBWdWUgaW5zdGFuY2UgdG8gJyArXG4gICAgICAncHJldmVudCBjb25mbGljdHMgd2l0aCBWdWUgaW50ZXJuYWxzLiAnICtcbiAgICAgICdTZWU6IGh0dHBzOi8vdnVlanMub3JnL3YyL2FwaS8jZGF0YScsXG4gICAgICB0YXJnZXRcbiAgICApO1xuICB9O1xuXG4gIHZhciBoYXNQcm94eSA9XG4gICAgdHlwZW9mIFByb3h5ICE9PSAndW5kZWZpbmVkJyAmJiBpc05hdGl2ZShQcm94eSk7XG5cbiAgaWYgKGhhc1Byb3h5KSB7XG4gICAgdmFyIGlzQnVpbHRJbk1vZGlmaWVyID0gbWFrZU1hcCgnc3RvcCxwcmV2ZW50LHNlbGYsY3RybCxzaGlmdCxhbHQsbWV0YSxleGFjdCcpO1xuICAgIGNvbmZpZy5rZXlDb2RlcyA9IG5ldyBQcm94eShjb25maWcua2V5Q29kZXMsIHtcbiAgICAgIHNldDogZnVuY3Rpb24gc2V0ICh0YXJnZXQsIGtleSwgdmFsdWUpIHtcbiAgICAgICAgaWYgKGlzQnVpbHRJbk1vZGlmaWVyKGtleSkpIHtcbiAgICAgICAgICB3YXJuKChcIkF2b2lkIG92ZXJ3cml0aW5nIGJ1aWx0LWluIG1vZGlmaWVyIGluIGNvbmZpZy5rZXlDb2RlczogLlwiICsga2V5KSk7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGFyZ2V0W2tleV0gPSB2YWx1ZTtcbiAgICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICB2YXIgaGFzSGFuZGxlciA9IHtcbiAgICBoYXM6IGZ1bmN0aW9uIGhhcyAodGFyZ2V0LCBrZXkpIHtcbiAgICAgIHZhciBoYXMgPSBrZXkgaW4gdGFyZ2V0O1xuICAgICAgdmFyIGlzQWxsb3dlZCA9IGFsbG93ZWRHbG9iYWxzKGtleSkgfHxcbiAgICAgICAgKHR5cGVvZiBrZXkgPT09ICdzdHJpbmcnICYmIGtleS5jaGFyQXQoMCkgPT09ICdfJyAmJiAhKGtleSBpbiB0YXJnZXQuJGRhdGEpKTtcbiAgICAgIGlmICghaGFzICYmICFpc0FsbG93ZWQpIHtcbiAgICAgICAgaWYgKGtleSBpbiB0YXJnZXQuJGRhdGEpIHsgd2FyblJlc2VydmVkUHJlZml4KHRhcmdldCwga2V5KTsgfVxuICAgICAgICBlbHNlIHsgd2Fybk5vblByZXNlbnQodGFyZ2V0LCBrZXkpOyB9XG4gICAgICB9XG4gICAgICByZXR1cm4gaGFzIHx8ICFpc0FsbG93ZWRcbiAgICB9XG4gIH07XG5cbiAgdmFyIGdldEhhbmRsZXIgPSB7XG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQgKHRhcmdldCwga2V5KSB7XG4gICAgICBpZiAodHlwZW9mIGtleSA9PT0gJ3N0cmluZycgJiYgIShrZXkgaW4gdGFyZ2V0KSkge1xuICAgICAgICBpZiAoa2V5IGluIHRhcmdldC4kZGF0YSkgeyB3YXJuUmVzZXJ2ZWRQcmVmaXgodGFyZ2V0LCBrZXkpOyB9XG4gICAgICAgIGVsc2UgeyB3YXJuTm9uUHJlc2VudCh0YXJnZXQsIGtleSk7IH1cbiAgICAgIH1cbiAgICAgIHJldHVybiB0YXJnZXRba2V5XVxuICAgIH1cbiAgfTtcblxuICBpbml0UHJveHkgPSBmdW5jdGlvbiBpbml0UHJveHkgKHZtKSB7XG4gICAgaWYgKGhhc1Byb3h5KSB7XG4gICAgICAvLyBkZXRlcm1pbmUgd2hpY2ggcHJveHkgaGFuZGxlciB0byB1c2VcbiAgICAgIHZhciBvcHRpb25zID0gdm0uJG9wdGlvbnM7XG4gICAgICB2YXIgaGFuZGxlcnMgPSBvcHRpb25zLnJlbmRlciAmJiBvcHRpb25zLnJlbmRlci5fd2l0aFN0cmlwcGVkXG4gICAgICAgID8gZ2V0SGFuZGxlclxuICAgICAgICA6IGhhc0hhbmRsZXI7XG4gICAgICB2bS5fcmVuZGVyUHJveHkgPSBuZXcgUHJveHkodm0sIGhhbmRsZXJzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdm0uX3JlbmRlclByb3h5ID0gdm07XG4gICAgfVxuICB9O1xufVxuXG4vKiAgKi9cblxudmFyIHNlZW5PYmplY3RzID0gbmV3IF9TZXQoKTtcblxuLyoqXG4gKiBSZWN1cnNpdmVseSB0cmF2ZXJzZSBhbiBvYmplY3QgdG8gZXZva2UgYWxsIGNvbnZlcnRlZFxuICogZ2V0dGVycywgc28gdGhhdCBldmVyeSBuZXN0ZWQgcHJvcGVydHkgaW5zaWRlIHRoZSBvYmplY3RcbiAqIGlzIGNvbGxlY3RlZCBhcyBhIFwiZGVlcFwiIGRlcGVuZGVuY3kuXG4gKi9cbmZ1bmN0aW9uIHRyYXZlcnNlICh2YWwpIHtcbiAgX3RyYXZlcnNlKHZhbCwgc2Vlbk9iamVjdHMpO1xuICBzZWVuT2JqZWN0cy5jbGVhcigpO1xufVxuXG5mdW5jdGlvbiBfdHJhdmVyc2UgKHZhbCwgc2Vlbikge1xuICB2YXIgaSwga2V5cztcbiAgdmFyIGlzQSA9IEFycmF5LmlzQXJyYXkodmFsKTtcbiAgaWYgKCghaXNBICYmICFpc09iamVjdCh2YWwpKSB8fCBPYmplY3QuaXNGcm96ZW4odmFsKSB8fCB2YWwgaW5zdGFuY2VvZiBWTm9kZSkge1xuICAgIHJldHVyblxuICB9XG4gIGlmICh2YWwuX19vYl9fKSB7XG4gICAgdmFyIGRlcElkID0gdmFsLl9fb2JfXy5kZXAuaWQ7XG4gICAgaWYgKHNlZW4uaGFzKGRlcElkKSkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuICAgIHNlZW4uYWRkKGRlcElkKTtcbiAgfVxuICBpZiAoaXNBKSB7XG4gICAgaSA9IHZhbC5sZW5ndGg7XG4gICAgd2hpbGUgKGktLSkgeyBfdHJhdmVyc2UodmFsW2ldLCBzZWVuKTsgfVxuICB9IGVsc2Uge1xuICAgIGtleXMgPSBPYmplY3Qua2V5cyh2YWwpO1xuICAgIGkgPSBrZXlzLmxlbmd0aDtcbiAgICB3aGlsZSAoaS0tKSB7IF90cmF2ZXJzZSh2YWxba2V5c1tpXV0sIHNlZW4pOyB9XG4gIH1cbn1cblxuLyogICovXG5cbnZhciBub3JtYWxpemVFdmVudCA9IGNhY2hlZChmdW5jdGlvbiAobmFtZSkge1xuICB2YXIgcGFzc2l2ZSA9IG5hbWUuY2hhckF0KDApID09PSAnJic7XG4gIG5hbWUgPSBwYXNzaXZlID8gbmFtZS5zbGljZSgxKSA6IG5hbWU7XG4gIHZhciBvbmNlJCQxID0gbmFtZS5jaGFyQXQoMCkgPT09ICd+JzsgLy8gUHJlZml4ZWQgbGFzdCwgY2hlY2tlZCBmaXJzdFxuICBuYW1lID0gb25jZSQkMSA/IG5hbWUuc2xpY2UoMSkgOiBuYW1lO1xuICB2YXIgY2FwdHVyZSA9IG5hbWUuY2hhckF0KDApID09PSAnISc7XG4gIG5hbWUgPSBjYXB0dXJlID8gbmFtZS5zbGljZSgxKSA6IG5hbWU7XG4gIHJldHVybiB7XG4gICAgbmFtZTogbmFtZSxcbiAgICBvbmNlOiBvbmNlJCQxLFxuICAgIGNhcHR1cmU6IGNhcHR1cmUsXG4gICAgcGFzc2l2ZTogcGFzc2l2ZVxuICB9XG59KTtcblxuZnVuY3Rpb24gY3JlYXRlRm5JbnZva2VyIChmbnMsIHZtKSB7XG4gIGZ1bmN0aW9uIGludm9rZXIgKCkge1xuICAgIHZhciBhcmd1bWVudHMkMSA9IGFyZ3VtZW50cztcblxuICAgIHZhciBmbnMgPSBpbnZva2VyLmZucztcbiAgICBpZiAoQXJyYXkuaXNBcnJheShmbnMpKSB7XG4gICAgICB2YXIgY2xvbmVkID0gZm5zLnNsaWNlKCk7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNsb25lZC5sZW5ndGg7IGkrKykge1xuICAgICAgICBpbnZva2VXaXRoRXJyb3JIYW5kbGluZyhjbG9uZWRbaV0sIG51bGwsIGFyZ3VtZW50cyQxLCB2bSwgXCJ2LW9uIGhhbmRsZXJcIik7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIHJldHVybiBoYW5kbGVyIHJldHVybiB2YWx1ZSBmb3Igc2luZ2xlIGhhbmRsZXJzXG4gICAgICByZXR1cm4gaW52b2tlV2l0aEVycm9ySGFuZGxpbmcoZm5zLCBudWxsLCBhcmd1bWVudHMsIHZtLCBcInYtb24gaGFuZGxlclwiKVxuICAgIH1cbiAgfVxuICBpbnZva2VyLmZucyA9IGZucztcbiAgcmV0dXJuIGludm9rZXJcbn1cblxuZnVuY3Rpb24gdXBkYXRlTGlzdGVuZXJzIChcbiAgb24sXG4gIG9sZE9uLFxuICBhZGQsXG4gIHJlbW92ZSQkMSxcbiAgY3JlYXRlT25jZUhhbmRsZXIsXG4gIHZtXG4pIHtcbiAgdmFyIG5hbWUsIGRlZiQkMSwgY3VyLCBvbGQsIGV2ZW50O1xuICBmb3IgKG5hbWUgaW4gb24pIHtcbiAgICBkZWYkJDEgPSBjdXIgPSBvbltuYW1lXTtcbiAgICBvbGQgPSBvbGRPbltuYW1lXTtcbiAgICBldmVudCA9IG5vcm1hbGl6ZUV2ZW50KG5hbWUpO1xuICAgIGlmIChpc1VuZGVmKGN1cikpIHtcbiAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgd2FybihcbiAgICAgICAgXCJJbnZhbGlkIGhhbmRsZXIgZm9yIGV2ZW50IFxcXCJcIiArIChldmVudC5uYW1lKSArIFwiXFxcIjogZ290IFwiICsgU3RyaW5nKGN1ciksXG4gICAgICAgIHZtXG4gICAgICApO1xuICAgIH0gZWxzZSBpZiAoaXNVbmRlZihvbGQpKSB7XG4gICAgICBpZiAoaXNVbmRlZihjdXIuZm5zKSkge1xuICAgICAgICBjdXIgPSBvbltuYW1lXSA9IGNyZWF0ZUZuSW52b2tlcihjdXIsIHZtKTtcbiAgICAgIH1cbiAgICAgIGlmIChpc1RydWUoZXZlbnQub25jZSkpIHtcbiAgICAgICAgY3VyID0gb25bbmFtZV0gPSBjcmVhdGVPbmNlSGFuZGxlcihldmVudC5uYW1lLCBjdXIsIGV2ZW50LmNhcHR1cmUpO1xuICAgICAgfVxuICAgICAgYWRkKGV2ZW50Lm5hbWUsIGN1ciwgZXZlbnQuY2FwdHVyZSwgZXZlbnQucGFzc2l2ZSwgZXZlbnQucGFyYW1zKTtcbiAgICB9IGVsc2UgaWYgKGN1ciAhPT0gb2xkKSB7XG4gICAgICBvbGQuZm5zID0gY3VyO1xuICAgICAgb25bbmFtZV0gPSBvbGQ7XG4gICAgfVxuICB9XG4gIGZvciAobmFtZSBpbiBvbGRPbikge1xuICAgIGlmIChpc1VuZGVmKG9uW25hbWVdKSkge1xuICAgICAgZXZlbnQgPSBub3JtYWxpemVFdmVudChuYW1lKTtcbiAgICAgIHJlbW92ZSQkMShldmVudC5uYW1lLCBvbGRPbltuYW1lXSwgZXZlbnQuY2FwdHVyZSk7XG4gICAgfVxuICB9XG59XG5cbi8qICAqL1xuXG5mdW5jdGlvbiBtZXJnZVZOb2RlSG9vayAoZGVmLCBob29rS2V5LCBob29rKSB7XG4gIGlmIChkZWYgaW5zdGFuY2VvZiBWTm9kZSkge1xuICAgIGRlZiA9IGRlZi5kYXRhLmhvb2sgfHwgKGRlZi5kYXRhLmhvb2sgPSB7fSk7XG4gIH1cbiAgdmFyIGludm9rZXI7XG4gIHZhciBvbGRIb29rID0gZGVmW2hvb2tLZXldO1xuXG4gIGZ1bmN0aW9uIHdyYXBwZWRIb29rICgpIHtcbiAgICBob29rLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgLy8gaW1wb3J0YW50OiByZW1vdmUgbWVyZ2VkIGhvb2sgdG8gZW5zdXJlIGl0J3MgY2FsbGVkIG9ubHkgb25jZVxuICAgIC8vIGFuZCBwcmV2ZW50IG1lbW9yeSBsZWFrXG4gICAgcmVtb3ZlKGludm9rZXIuZm5zLCB3cmFwcGVkSG9vayk7XG4gIH1cblxuICBpZiAoaXNVbmRlZihvbGRIb29rKSkge1xuICAgIC8vIG5vIGV4aXN0aW5nIGhvb2tcbiAgICBpbnZva2VyID0gY3JlYXRlRm5JbnZva2VyKFt3cmFwcGVkSG9va10pO1xuICB9IGVsc2Uge1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgIGlmIChpc0RlZihvbGRIb29rLmZucykgJiYgaXNUcnVlKG9sZEhvb2subWVyZ2VkKSkge1xuICAgICAgLy8gYWxyZWFkeSBhIG1lcmdlZCBpbnZva2VyXG4gICAgICBpbnZva2VyID0gb2xkSG9vaztcbiAgICAgIGludm9rZXIuZm5zLnB1c2god3JhcHBlZEhvb2spO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBleGlzdGluZyBwbGFpbiBob29rXG4gICAgICBpbnZva2VyID0gY3JlYXRlRm5JbnZva2VyKFtvbGRIb29rLCB3cmFwcGVkSG9va10pO1xuICAgIH1cbiAgfVxuXG4gIGludm9rZXIubWVyZ2VkID0gdHJ1ZTtcbiAgZGVmW2hvb2tLZXldID0gaW52b2tlcjtcbn1cblxuLyogICovXG5cbmZ1bmN0aW9uIGV4dHJhY3RQcm9wc0Zyb21WTm9kZURhdGEgKFxuICBkYXRhLFxuICBDdG9yLFxuICB0YWdcbikge1xuICAvLyB3ZSBhcmUgb25seSBleHRyYWN0aW5nIHJhdyB2YWx1ZXMgaGVyZS5cbiAgLy8gdmFsaWRhdGlvbiBhbmQgZGVmYXVsdCB2YWx1ZXMgYXJlIGhhbmRsZWQgaW4gdGhlIGNoaWxkXG4gIC8vIGNvbXBvbmVudCBpdHNlbGYuXG4gIHZhciBwcm9wT3B0aW9ucyA9IEN0b3Iub3B0aW9ucy5wcm9wcztcbiAgaWYgKGlzVW5kZWYocHJvcE9wdGlvbnMpKSB7XG4gICAgcmV0dXJuXG4gIH1cbiAgdmFyIHJlcyA9IHt9O1xuICB2YXIgYXR0cnMgPSBkYXRhLmF0dHJzO1xuICB2YXIgcHJvcHMgPSBkYXRhLnByb3BzO1xuICBpZiAoaXNEZWYoYXR0cnMpIHx8IGlzRGVmKHByb3BzKSkge1xuICAgIGZvciAodmFyIGtleSBpbiBwcm9wT3B0aW9ucykge1xuICAgICAgdmFyIGFsdEtleSA9IGh5cGhlbmF0ZShrZXkpO1xuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgdmFyIGtleUluTG93ZXJDYXNlID0ga2V5LnRvTG93ZXJDYXNlKCk7XG4gICAgICAgIGlmIChcbiAgICAgICAgICBrZXkgIT09IGtleUluTG93ZXJDYXNlICYmXG4gICAgICAgICAgYXR0cnMgJiYgaGFzT3duKGF0dHJzLCBrZXlJbkxvd2VyQ2FzZSlcbiAgICAgICAgKSB7XG4gICAgICAgICAgdGlwKFxuICAgICAgICAgICAgXCJQcm9wIFxcXCJcIiArIGtleUluTG93ZXJDYXNlICsgXCJcXFwiIGlzIHBhc3NlZCB0byBjb21wb25lbnQgXCIgK1xuICAgICAgICAgICAgKGZvcm1hdENvbXBvbmVudE5hbWUodGFnIHx8IEN0b3IpKSArIFwiLCBidXQgdGhlIGRlY2xhcmVkIHByb3AgbmFtZSBpc1wiICtcbiAgICAgICAgICAgIFwiIFxcXCJcIiArIGtleSArIFwiXFxcIi4gXCIgK1xuICAgICAgICAgICAgXCJOb3RlIHRoYXQgSFRNTCBhdHRyaWJ1dGVzIGFyZSBjYXNlLWluc2Vuc2l0aXZlIGFuZCBjYW1lbENhc2VkIFwiICtcbiAgICAgICAgICAgIFwicHJvcHMgbmVlZCB0byB1c2UgdGhlaXIga2ViYWItY2FzZSBlcXVpdmFsZW50cyB3aGVuIHVzaW5nIGluLURPTSBcIiArXG4gICAgICAgICAgICBcInRlbXBsYXRlcy4gWW91IHNob3VsZCBwcm9iYWJseSB1c2UgXFxcIlwiICsgYWx0S2V5ICsgXCJcXFwiIGluc3RlYWQgb2YgXFxcIlwiICsga2V5ICsgXCJcXFwiLlwiXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgY2hlY2tQcm9wKHJlcywgcHJvcHMsIGtleSwgYWx0S2V5LCB0cnVlKSB8fFxuICAgICAgY2hlY2tQcm9wKHJlcywgYXR0cnMsIGtleSwgYWx0S2V5LCBmYWxzZSk7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXNcbn1cblxuZnVuY3Rpb24gY2hlY2tQcm9wIChcbiAgcmVzLFxuICBoYXNoLFxuICBrZXksXG4gIGFsdEtleSxcbiAgcHJlc2VydmVcbikge1xuICBpZiAoaXNEZWYoaGFzaCkpIHtcbiAgICBpZiAoaGFzT3duKGhhc2gsIGtleSkpIHtcbiAgICAgIHJlc1trZXldID0gaGFzaFtrZXldO1xuICAgICAgaWYgKCFwcmVzZXJ2ZSkge1xuICAgICAgICBkZWxldGUgaGFzaFtrZXldO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRydWVcbiAgICB9IGVsc2UgaWYgKGhhc093bihoYXNoLCBhbHRLZXkpKSB7XG4gICAgICByZXNba2V5XSA9IGhhc2hbYWx0S2V5XTtcbiAgICAgIGlmICghcHJlc2VydmUpIHtcbiAgICAgICAgZGVsZXRlIGhhc2hbYWx0S2V5XTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0cnVlXG4gICAgfVxuICB9XG4gIHJldHVybiBmYWxzZVxufVxuXG4vKiAgKi9cblxuLy8gVGhlIHRlbXBsYXRlIGNvbXBpbGVyIGF0dGVtcHRzIHRvIG1pbmltaXplIHRoZSBuZWVkIGZvciBub3JtYWxpemF0aW9uIGJ5XG4vLyBzdGF0aWNhbGx5IGFuYWx5emluZyB0aGUgdGVtcGxhdGUgYXQgY29tcGlsZSB0aW1lLlxuLy9cbi8vIEZvciBwbGFpbiBIVE1MIG1hcmt1cCwgbm9ybWFsaXphdGlvbiBjYW4gYmUgY29tcGxldGVseSBza2lwcGVkIGJlY2F1c2UgdGhlXG4vLyBnZW5lcmF0ZWQgcmVuZGVyIGZ1bmN0aW9uIGlzIGd1YXJhbnRlZWQgdG8gcmV0dXJuIEFycmF5PFZOb2RlPi4gVGhlcmUgYXJlXG4vLyB0d28gY2FzZXMgd2hlcmUgZXh0cmEgbm9ybWFsaXphdGlvbiBpcyBuZWVkZWQ6XG5cbi8vIDEuIFdoZW4gdGhlIGNoaWxkcmVuIGNvbnRhaW5zIGNvbXBvbmVudHMgLSBiZWNhdXNlIGEgZnVuY3Rpb25hbCBjb21wb25lbnRcbi8vIG1heSByZXR1cm4gYW4gQXJyYXkgaW5zdGVhZCBvZiBhIHNpbmdsZSByb290LiBJbiB0aGlzIGNhc2UsIGp1c3QgYSBzaW1wbGVcbi8vIG5vcm1hbGl6YXRpb24gaXMgbmVlZGVkIC0gaWYgYW55IGNoaWxkIGlzIGFuIEFycmF5LCB3ZSBmbGF0dGVuIHRoZSB3aG9sZVxuLy8gdGhpbmcgd2l0aCBBcnJheS5wcm90b3R5cGUuY29uY2F0LiBJdCBpcyBndWFyYW50ZWVkIHRvIGJlIG9ubHkgMS1sZXZlbCBkZWVwXG4vLyBiZWNhdXNlIGZ1bmN0aW9uYWwgY29tcG9uZW50cyBhbHJlYWR5IG5vcm1hbGl6ZSB0aGVpciBvd24gY2hpbGRyZW4uXG5mdW5jdGlvbiBzaW1wbGVOb3JtYWxpemVDaGlsZHJlbiAoY2hpbGRyZW4pIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgIGlmIChBcnJheS5pc0FycmF5KGNoaWxkcmVuW2ldKSkge1xuICAgICAgcmV0dXJuIEFycmF5LnByb3RvdHlwZS5jb25jYXQuYXBwbHkoW10sIGNoaWxkcmVuKVxuICAgIH1cbiAgfVxuICByZXR1cm4gY2hpbGRyZW5cbn1cblxuLy8gMi4gV2hlbiB0aGUgY2hpbGRyZW4gY29udGFpbnMgY29uc3RydWN0cyB0aGF0IGFsd2F5cyBnZW5lcmF0ZWQgbmVzdGVkIEFycmF5cyxcbi8vIGUuZy4gPHRlbXBsYXRlPiwgPHNsb3Q+LCB2LWZvciwgb3Igd2hlbiB0aGUgY2hpbGRyZW4gaXMgcHJvdmlkZWQgYnkgdXNlclxuLy8gd2l0aCBoYW5kLXdyaXR0ZW4gcmVuZGVyIGZ1bmN0aW9ucyAvIEpTWC4gSW4gc3VjaCBjYXNlcyBhIGZ1bGwgbm9ybWFsaXphdGlvblxuLy8gaXMgbmVlZGVkIHRvIGNhdGVyIHRvIGFsbCBwb3NzaWJsZSB0eXBlcyBvZiBjaGlsZHJlbiB2YWx1ZXMuXG5mdW5jdGlvbiBub3JtYWxpemVDaGlsZHJlbiAoY2hpbGRyZW4pIHtcbiAgcmV0dXJuIGlzUHJpbWl0aXZlKGNoaWxkcmVuKVxuICAgID8gW2NyZWF0ZVRleHRWTm9kZShjaGlsZHJlbildXG4gICAgOiBBcnJheS5pc0FycmF5KGNoaWxkcmVuKVxuICAgICAgPyBub3JtYWxpemVBcnJheUNoaWxkcmVuKGNoaWxkcmVuKVxuICAgICAgOiB1bmRlZmluZWRcbn1cblxuZnVuY3Rpb24gaXNUZXh0Tm9kZSAobm9kZSkge1xuICByZXR1cm4gaXNEZWYobm9kZSkgJiYgaXNEZWYobm9kZS50ZXh0KSAmJiBpc0ZhbHNlKG5vZGUuaXNDb21tZW50KVxufVxuXG5mdW5jdGlvbiBub3JtYWxpemVBcnJheUNoaWxkcmVuIChjaGlsZHJlbiwgbmVzdGVkSW5kZXgpIHtcbiAgdmFyIHJlcyA9IFtdO1xuICB2YXIgaSwgYywgbGFzdEluZGV4LCBsYXN0O1xuICBmb3IgKGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICBjID0gY2hpbGRyZW5baV07XG4gICAgaWYgKGlzVW5kZWYoYykgfHwgdHlwZW9mIGMgPT09ICdib29sZWFuJykgeyBjb250aW51ZSB9XG4gICAgbGFzdEluZGV4ID0gcmVzLmxlbmd0aCAtIDE7XG4gICAgbGFzdCA9IHJlc1tsYXN0SW5kZXhdO1xuICAgIC8vICBuZXN0ZWRcbiAgICBpZiAoQXJyYXkuaXNBcnJheShjKSkge1xuICAgICAgaWYgKGMubGVuZ3RoID4gMCkge1xuICAgICAgICBjID0gbm9ybWFsaXplQXJyYXlDaGlsZHJlbihjLCAoKG5lc3RlZEluZGV4IHx8ICcnKSArIFwiX1wiICsgaSkpO1xuICAgICAgICAvLyBtZXJnZSBhZGphY2VudCB0ZXh0IG5vZGVzXG4gICAgICAgIGlmIChpc1RleHROb2RlKGNbMF0pICYmIGlzVGV4dE5vZGUobGFzdCkpIHtcbiAgICAgICAgICByZXNbbGFzdEluZGV4XSA9IGNyZWF0ZVRleHRWTm9kZShsYXN0LnRleHQgKyAoY1swXSkudGV4dCk7XG4gICAgICAgICAgYy5zaGlmdCgpO1xuICAgICAgICB9XG4gICAgICAgIHJlcy5wdXNoLmFwcGx5KHJlcywgYyk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChpc1ByaW1pdGl2ZShjKSkge1xuICAgICAgaWYgKGlzVGV4dE5vZGUobGFzdCkpIHtcbiAgICAgICAgLy8gbWVyZ2UgYWRqYWNlbnQgdGV4dCBub2Rlc1xuICAgICAgICAvLyB0aGlzIGlzIG5lY2Vzc2FyeSBmb3IgU1NSIGh5ZHJhdGlvbiBiZWNhdXNlIHRleHQgbm9kZXMgYXJlXG4gICAgICAgIC8vIGVzc2VudGlhbGx5IG1lcmdlZCB3aGVuIHJlbmRlcmVkIHRvIEhUTUwgc3RyaW5nc1xuICAgICAgICByZXNbbGFzdEluZGV4XSA9IGNyZWF0ZVRleHRWTm9kZShsYXN0LnRleHQgKyBjKTtcbiAgICAgIH0gZWxzZSBpZiAoYyAhPT0gJycpIHtcbiAgICAgICAgLy8gY29udmVydCBwcmltaXRpdmUgdG8gdm5vZGVcbiAgICAgICAgcmVzLnB1c2goY3JlYXRlVGV4dFZOb2RlKGMpKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKGlzVGV4dE5vZGUoYykgJiYgaXNUZXh0Tm9kZShsYXN0KSkge1xuICAgICAgICAvLyBtZXJnZSBhZGphY2VudCB0ZXh0IG5vZGVzXG4gICAgICAgIHJlc1tsYXN0SW5kZXhdID0gY3JlYXRlVGV4dFZOb2RlKGxhc3QudGV4dCArIGMudGV4dCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBkZWZhdWx0IGtleSBmb3IgbmVzdGVkIGFycmF5IGNoaWxkcmVuIChsaWtlbHkgZ2VuZXJhdGVkIGJ5IHYtZm9yKVxuICAgICAgICBpZiAoaXNUcnVlKGNoaWxkcmVuLl9pc1ZMaXN0KSAmJlxuICAgICAgICAgIGlzRGVmKGMudGFnKSAmJlxuICAgICAgICAgIGlzVW5kZWYoYy5rZXkpICYmXG4gICAgICAgICAgaXNEZWYobmVzdGVkSW5kZXgpKSB7XG4gICAgICAgICAgYy5rZXkgPSBcIl9fdmxpc3RcIiArIG5lc3RlZEluZGV4ICsgXCJfXCIgKyBpICsgXCJfX1wiO1xuICAgICAgICB9XG4gICAgICAgIHJlcy5wdXNoKGMpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzXG59XG5cbi8qICAqL1xuXG5mdW5jdGlvbiBpbml0UHJvdmlkZSAodm0pIHtcbiAgdmFyIHByb3ZpZGUgPSB2bS4kb3B0aW9ucy5wcm92aWRlO1xuICBpZiAocHJvdmlkZSkge1xuICAgIHZtLl9wcm92aWRlZCA9IHR5cGVvZiBwcm92aWRlID09PSAnZnVuY3Rpb24nXG4gICAgICA/IHByb3ZpZGUuY2FsbCh2bSlcbiAgICAgIDogcHJvdmlkZTtcbiAgfVxufVxuXG5mdW5jdGlvbiBpbml0SW5qZWN0aW9ucyAodm0pIHtcbiAgdmFyIHJlc3VsdCA9IHJlc29sdmVJbmplY3Qodm0uJG9wdGlvbnMuaW5qZWN0LCB2bSk7XG4gIGlmIChyZXN1bHQpIHtcbiAgICB0b2dnbGVPYnNlcnZpbmcoZmFsc2UpO1xuICAgIE9iamVjdC5rZXlzKHJlc3VsdCkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgZGVmaW5lUmVhY3RpdmUkJDEodm0sIGtleSwgcmVzdWx0W2tleV0sIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICB3YXJuKFxuICAgICAgICAgICAgXCJBdm9pZCBtdXRhdGluZyBhbiBpbmplY3RlZCB2YWx1ZSBkaXJlY3RseSBzaW5jZSB0aGUgY2hhbmdlcyB3aWxsIGJlIFwiICtcbiAgICAgICAgICAgIFwib3ZlcndyaXR0ZW4gd2hlbmV2ZXIgdGhlIHByb3ZpZGVkIGNvbXBvbmVudCByZS1yZW5kZXJzLiBcIiArXG4gICAgICAgICAgICBcImluamVjdGlvbiBiZWluZyBtdXRhdGVkOiBcXFwiXCIgKyBrZXkgKyBcIlxcXCJcIixcbiAgICAgICAgICAgIHZtXG4gICAgICAgICAgKTtcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBkZWZpbmVSZWFjdGl2ZSQkMSh2bSwga2V5LCByZXN1bHRba2V5XSk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgdG9nZ2xlT2JzZXJ2aW5nKHRydWUpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHJlc29sdmVJbmplY3QgKGluamVjdCwgdm0pIHtcbiAgaWYgKGluamVjdCkge1xuICAgIC8vIGluamVjdCBpcyA6YW55IGJlY2F1c2UgZmxvdyBpcyBub3Qgc21hcnQgZW5vdWdoIHRvIGZpZ3VyZSBvdXQgY2FjaGVkXG4gICAgdmFyIHJlc3VsdCA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgdmFyIGtleXMgPSBoYXNTeW1ib2xcbiAgICAgID8gUmVmbGVjdC5vd25LZXlzKGluamVjdClcbiAgICAgIDogT2JqZWN0LmtleXMoaW5qZWN0KTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGtleSA9IGtleXNbaV07XG4gICAgICAvLyAjNjU3NCBpbiBjYXNlIHRoZSBpbmplY3Qgb2JqZWN0IGlzIG9ic2VydmVkLi4uXG4gICAgICBpZiAoa2V5ID09PSAnX19vYl9fJykgeyBjb250aW51ZSB9XG4gICAgICB2YXIgcHJvdmlkZUtleSA9IGluamVjdFtrZXldLmZyb207XG4gICAgICB2YXIgc291cmNlID0gdm07XG4gICAgICB3aGlsZSAoc291cmNlKSB7XG4gICAgICAgIGlmIChzb3VyY2UuX3Byb3ZpZGVkICYmIGhhc093bihzb3VyY2UuX3Byb3ZpZGVkLCBwcm92aWRlS2V5KSkge1xuICAgICAgICAgIHJlc3VsdFtrZXldID0gc291cmNlLl9wcm92aWRlZFtwcm92aWRlS2V5XTtcbiAgICAgICAgICBicmVha1xuICAgICAgICB9XG4gICAgICAgIHNvdXJjZSA9IHNvdXJjZS4kcGFyZW50O1xuICAgICAgfVxuICAgICAgaWYgKCFzb3VyY2UpIHtcbiAgICAgICAgaWYgKCdkZWZhdWx0JyBpbiBpbmplY3Rba2V5XSkge1xuICAgICAgICAgIHZhciBwcm92aWRlRGVmYXVsdCA9IGluamVjdFtrZXldLmRlZmF1bHQ7XG4gICAgICAgICAgcmVzdWx0W2tleV0gPSB0eXBlb2YgcHJvdmlkZURlZmF1bHQgPT09ICdmdW5jdGlvbidcbiAgICAgICAgICAgID8gcHJvdmlkZURlZmF1bHQuY2FsbCh2bSlcbiAgICAgICAgICAgIDogcHJvdmlkZURlZmF1bHQ7XG4gICAgICAgIH0gZWxzZSBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICAgIHdhcm4oKFwiSW5qZWN0aW9uIFxcXCJcIiArIGtleSArIFwiXFxcIiBub3QgZm91bmRcIiksIHZtKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0XG4gIH1cbn1cblxuLyogICovXG5cblxuXG4vKipcbiAqIFJ1bnRpbWUgaGVscGVyIGZvciByZXNvbHZpbmcgcmF3IGNoaWxkcmVuIFZOb2RlcyBpbnRvIGEgc2xvdCBvYmplY3QuXG4gKi9cbmZ1bmN0aW9uIHJlc29sdmVTbG90cyAoXG4gIGNoaWxkcmVuLFxuICBjb250ZXh0XG4pIHtcbiAgaWYgKCFjaGlsZHJlbiB8fCAhY2hpbGRyZW4ubGVuZ3RoKSB7XG4gICAgcmV0dXJuIHt9XG4gIH1cbiAgdmFyIHNsb3RzID0ge307XG4gIGZvciAodmFyIGkgPSAwLCBsID0gY2hpbGRyZW4ubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgdmFyIGNoaWxkID0gY2hpbGRyZW5baV07XG4gICAgdmFyIGRhdGEgPSBjaGlsZC5kYXRhO1xuICAgIC8vIHJlbW92ZSBzbG90IGF0dHJpYnV0ZSBpZiB0aGUgbm9kZSBpcyByZXNvbHZlZCBhcyBhIFZ1ZSBzbG90IG5vZGVcbiAgICBpZiAoZGF0YSAmJiBkYXRhLmF0dHJzICYmIGRhdGEuYXR0cnMuc2xvdCkge1xuICAgICAgZGVsZXRlIGRhdGEuYXR0cnMuc2xvdDtcbiAgICB9XG4gICAgLy8gbmFtZWQgc2xvdHMgc2hvdWxkIG9ubHkgYmUgcmVzcGVjdGVkIGlmIHRoZSB2bm9kZSB3YXMgcmVuZGVyZWQgaW4gdGhlXG4gICAgLy8gc2FtZSBjb250ZXh0LlxuICAgIGlmICgoY2hpbGQuY29udGV4dCA9PT0gY29udGV4dCB8fCBjaGlsZC5mbkNvbnRleHQgPT09IGNvbnRleHQpICYmXG4gICAgICBkYXRhICYmIGRhdGEuc2xvdCAhPSBudWxsXG4gICAgKSB7XG4gICAgICB2YXIgbmFtZSA9IGRhdGEuc2xvdDtcbiAgICAgIHZhciBzbG90ID0gKHNsb3RzW25hbWVdIHx8IChzbG90c1tuYW1lXSA9IFtdKSk7XG4gICAgICBpZiAoY2hpbGQudGFnID09PSAndGVtcGxhdGUnKSB7XG4gICAgICAgIHNsb3QucHVzaC5hcHBseShzbG90LCBjaGlsZC5jaGlsZHJlbiB8fCBbXSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzbG90LnB1c2goY2hpbGQpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAoc2xvdHMuZGVmYXVsdCB8fCAoc2xvdHMuZGVmYXVsdCA9IFtdKSkucHVzaChjaGlsZCk7XG4gICAgfVxuICB9XG4gIC8vIGlnbm9yZSBzbG90cyB0aGF0IGNvbnRhaW5zIG9ubHkgd2hpdGVzcGFjZVxuICBmb3IgKHZhciBuYW1lJDEgaW4gc2xvdHMpIHtcbiAgICBpZiAoc2xvdHNbbmFtZSQxXS5ldmVyeShpc1doaXRlc3BhY2UpKSB7XG4gICAgICBkZWxldGUgc2xvdHNbbmFtZSQxXTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHNsb3RzXG59XG5cbmZ1bmN0aW9uIGlzV2hpdGVzcGFjZSAobm9kZSkge1xuICByZXR1cm4gKG5vZGUuaXNDb21tZW50ICYmICFub2RlLmFzeW5jRmFjdG9yeSkgfHwgbm9kZS50ZXh0ID09PSAnICdcbn1cblxuLyogICovXG5cbmZ1bmN0aW9uIGlzQXN5bmNQbGFjZWhvbGRlciAobm9kZSkge1xuICByZXR1cm4gbm9kZS5pc0NvbW1lbnQgJiYgbm9kZS5hc3luY0ZhY3Rvcnlcbn1cblxuLyogICovXG5cbmZ1bmN0aW9uIG5vcm1hbGl6ZVNjb3BlZFNsb3RzIChcbiAgc2xvdHMsXG4gIG5vcm1hbFNsb3RzLFxuICBwcmV2U2xvdHNcbikge1xuICB2YXIgcmVzO1xuICB2YXIgaGFzTm9ybWFsU2xvdHMgPSBPYmplY3Qua2V5cyhub3JtYWxTbG90cykubGVuZ3RoID4gMDtcbiAgdmFyIGlzU3RhYmxlID0gc2xvdHMgPyAhIXNsb3RzLiRzdGFibGUgOiAhaGFzTm9ybWFsU2xvdHM7XG4gIHZhciBrZXkgPSBzbG90cyAmJiBzbG90cy4ka2V5O1xuICBpZiAoIXNsb3RzKSB7XG4gICAgcmVzID0ge307XG4gIH0gZWxzZSBpZiAoc2xvdHMuX25vcm1hbGl6ZWQpIHtcbiAgICAvLyBmYXN0IHBhdGggMTogY2hpbGQgY29tcG9uZW50IHJlLXJlbmRlciBvbmx5LCBwYXJlbnQgZGlkIG5vdCBjaGFuZ2VcbiAgICByZXR1cm4gc2xvdHMuX25vcm1hbGl6ZWRcbiAgfSBlbHNlIGlmIChcbiAgICBpc1N0YWJsZSAmJlxuICAgIHByZXZTbG90cyAmJlxuICAgIHByZXZTbG90cyAhPT0gZW1wdHlPYmplY3QgJiZcbiAgICBrZXkgPT09IHByZXZTbG90cy4ka2V5ICYmXG4gICAgIWhhc05vcm1hbFNsb3RzICYmXG4gICAgIXByZXZTbG90cy4kaGFzTm9ybWFsXG4gICkge1xuICAgIC8vIGZhc3QgcGF0aCAyOiBzdGFibGUgc2NvcGVkIHNsb3RzIHcvIG5vIG5vcm1hbCBzbG90cyB0byBwcm94eSxcbiAgICAvLyBvbmx5IG5lZWQgdG8gbm9ybWFsaXplIG9uY2VcbiAgICByZXR1cm4gcHJldlNsb3RzXG4gIH0gZWxzZSB7XG4gICAgcmVzID0ge307XG4gICAgZm9yICh2YXIga2V5JDEgaW4gc2xvdHMpIHtcbiAgICAgIGlmIChzbG90c1trZXkkMV0gJiYga2V5JDFbMF0gIT09ICckJykge1xuICAgICAgICByZXNba2V5JDFdID0gbm9ybWFsaXplU2NvcGVkU2xvdChub3JtYWxTbG90cywga2V5JDEsIHNsb3RzW2tleSQxXSk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIC8vIGV4cG9zZSBub3JtYWwgc2xvdHMgb24gc2NvcGVkU2xvdHNcbiAgZm9yICh2YXIga2V5JDIgaW4gbm9ybWFsU2xvdHMpIHtcbiAgICBpZiAoIShrZXkkMiBpbiByZXMpKSB7XG4gICAgICByZXNba2V5JDJdID0gcHJveHlOb3JtYWxTbG90KG5vcm1hbFNsb3RzLCBrZXkkMik7XG4gICAgfVxuICB9XG4gIC8vIGF2b3JpYXogc2VlbXMgdG8gbW9jayBhIG5vbi1leHRlbnNpYmxlICRzY29wZWRTbG90cyBvYmplY3RcbiAgLy8gYW5kIHdoZW4gdGhhdCBpcyBwYXNzZWQgZG93biB0aGlzIHdvdWxkIGNhdXNlIGFuIGVycm9yXG4gIGlmIChzbG90cyAmJiBPYmplY3QuaXNFeHRlbnNpYmxlKHNsb3RzKSkge1xuICAgIChzbG90cykuX25vcm1hbGl6ZWQgPSByZXM7XG4gIH1cbiAgZGVmKHJlcywgJyRzdGFibGUnLCBpc1N0YWJsZSk7XG4gIGRlZihyZXMsICcka2V5Jywga2V5KTtcbiAgZGVmKHJlcywgJyRoYXNOb3JtYWwnLCBoYXNOb3JtYWxTbG90cyk7XG4gIHJldHVybiByZXNcbn1cblxuZnVuY3Rpb24gbm9ybWFsaXplU2NvcGVkU2xvdChub3JtYWxTbG90cywga2V5LCBmbikge1xuICB2YXIgbm9ybWFsaXplZCA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgcmVzID0gYXJndW1lbnRzLmxlbmd0aCA/IGZuLmFwcGx5KG51bGwsIGFyZ3VtZW50cykgOiBmbih7fSk7XG4gICAgcmVzID0gcmVzICYmIHR5cGVvZiByZXMgPT09ICdvYmplY3QnICYmICFBcnJheS5pc0FycmF5KHJlcylcbiAgICAgID8gW3Jlc10gLy8gc2luZ2xlIHZub2RlXG4gICAgICA6IG5vcm1hbGl6ZUNoaWxkcmVuKHJlcyk7XG4gICAgdmFyIHZub2RlID0gcmVzICYmIHJlc1swXTtcbiAgICByZXR1cm4gcmVzICYmIChcbiAgICAgICF2bm9kZSB8fFxuICAgICAgKHJlcy5sZW5ndGggPT09IDEgJiYgdm5vZGUuaXNDb21tZW50ICYmICFpc0FzeW5jUGxhY2Vob2xkZXIodm5vZGUpKSAvLyAjOTY1OCwgIzEwMzkxXG4gICAgKSA/IHVuZGVmaW5lZFxuICAgICAgOiByZXNcbiAgfTtcbiAgLy8gdGhpcyBpcyBhIHNsb3QgdXNpbmcgdGhlIG5ldyB2LXNsb3Qgc3ludGF4IHdpdGhvdXQgc2NvcGUuIGFsdGhvdWdoIGl0IGlzXG4gIC8vIGNvbXBpbGVkIGFzIGEgc2NvcGVkIHNsb3QsIHJlbmRlciBmbiB1c2VycyB3b3VsZCBleHBlY3QgaXQgdG8gYmUgcHJlc2VudFxuICAvLyBvbiB0aGlzLiRzbG90cyBiZWNhdXNlIHRoZSB1c2FnZSBpcyBzZW1hbnRpY2FsbHkgYSBub3JtYWwgc2xvdC5cbiAgaWYgKGZuLnByb3h5KSB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG5vcm1hbFNsb3RzLCBrZXksIHtcbiAgICAgIGdldDogbm9ybWFsaXplZCxcbiAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgfVxuICByZXR1cm4gbm9ybWFsaXplZFxufVxuXG5mdW5jdGlvbiBwcm94eU5vcm1hbFNsb3Qoc2xvdHMsIGtleSkge1xuICByZXR1cm4gZnVuY3Rpb24gKCkgeyByZXR1cm4gc2xvdHNba2V5XTsgfVxufVxuXG4vKiAgKi9cblxuLyoqXG4gKiBSdW50aW1lIGhlbHBlciBmb3IgcmVuZGVyaW5nIHYtZm9yIGxpc3RzLlxuICovXG5mdW5jdGlvbiByZW5kZXJMaXN0IChcbiAgdmFsLFxuICByZW5kZXJcbikge1xuICB2YXIgcmV0LCBpLCBsLCBrZXlzLCBrZXk7XG4gIGlmIChBcnJheS5pc0FycmF5KHZhbCkgfHwgdHlwZW9mIHZhbCA9PT0gJ3N0cmluZycpIHtcbiAgICByZXQgPSBuZXcgQXJyYXkodmFsLmxlbmd0aCk7XG4gICAgZm9yIChpID0gMCwgbCA9IHZhbC5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgIHJldFtpXSA9IHJlbmRlcih2YWxbaV0sIGkpO1xuICAgIH1cbiAgfSBlbHNlIGlmICh0eXBlb2YgdmFsID09PSAnbnVtYmVyJykge1xuICAgIHJldCA9IG5ldyBBcnJheSh2YWwpO1xuICAgIGZvciAoaSA9IDA7IGkgPCB2YWw7IGkrKykge1xuICAgICAgcmV0W2ldID0gcmVuZGVyKGkgKyAxLCBpKTtcbiAgICB9XG4gIH0gZWxzZSBpZiAoaXNPYmplY3QodmFsKSkge1xuICAgIGlmIChoYXNTeW1ib2wgJiYgdmFsW1N5bWJvbC5pdGVyYXRvcl0pIHtcbiAgICAgIHJldCA9IFtdO1xuICAgICAgdmFyIGl0ZXJhdG9yID0gdmFsW1N5bWJvbC5pdGVyYXRvcl0oKTtcbiAgICAgIHZhciByZXN1bHQgPSBpdGVyYXRvci5uZXh0KCk7XG4gICAgICB3aGlsZSAoIXJlc3VsdC5kb25lKSB7XG4gICAgICAgIHJldC5wdXNoKHJlbmRlcihyZXN1bHQudmFsdWUsIHJldC5sZW5ndGgpKTtcbiAgICAgICAgcmVzdWx0ID0gaXRlcmF0b3IubmV4dCgpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBrZXlzID0gT2JqZWN0LmtleXModmFsKTtcbiAgICAgIHJldCA9IG5ldyBBcnJheShrZXlzLmxlbmd0aCk7XG4gICAgICBmb3IgKGkgPSAwLCBsID0ga2V5cy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAga2V5ID0ga2V5c1tpXTtcbiAgICAgICAgcmV0W2ldID0gcmVuZGVyKHZhbFtrZXldLCBrZXksIGkpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBpZiAoIWlzRGVmKHJldCkpIHtcbiAgICByZXQgPSBbXTtcbiAgfVxuICAocmV0KS5faXNWTGlzdCA9IHRydWU7XG4gIHJldHVybiByZXRcbn1cblxuLyogICovXG5cbi8qKlxuICogUnVudGltZSBoZWxwZXIgZm9yIHJlbmRlcmluZyA8c2xvdD5cbiAqL1xuZnVuY3Rpb24gcmVuZGVyU2xvdCAoXG4gIG5hbWUsXG4gIGZhbGxiYWNrUmVuZGVyLFxuICBwcm9wcyxcbiAgYmluZE9iamVjdFxuKSB7XG4gIHZhciBzY29wZWRTbG90Rm4gPSB0aGlzLiRzY29wZWRTbG90c1tuYW1lXTtcbiAgdmFyIG5vZGVzO1xuICBpZiAoc2NvcGVkU2xvdEZuKSB7XG4gICAgLy8gc2NvcGVkIHNsb3RcbiAgICBwcm9wcyA9IHByb3BzIHx8IHt9O1xuICAgIGlmIChiaW5kT2JqZWN0KSB7XG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiAhaXNPYmplY3QoYmluZE9iamVjdCkpIHtcbiAgICAgICAgd2Fybignc2xvdCB2LWJpbmQgd2l0aG91dCBhcmd1bWVudCBleHBlY3RzIGFuIE9iamVjdCcsIHRoaXMpO1xuICAgICAgfVxuICAgICAgcHJvcHMgPSBleHRlbmQoZXh0ZW5kKHt9LCBiaW5kT2JqZWN0KSwgcHJvcHMpO1xuICAgIH1cbiAgICBub2RlcyA9XG4gICAgICBzY29wZWRTbG90Rm4ocHJvcHMpIHx8XG4gICAgICAodHlwZW9mIGZhbGxiYWNrUmVuZGVyID09PSAnZnVuY3Rpb24nID8gZmFsbGJhY2tSZW5kZXIoKSA6IGZhbGxiYWNrUmVuZGVyKTtcbiAgfSBlbHNlIHtcbiAgICBub2RlcyA9XG4gICAgICB0aGlzLiRzbG90c1tuYW1lXSB8fFxuICAgICAgKHR5cGVvZiBmYWxsYmFja1JlbmRlciA9PT0gJ2Z1bmN0aW9uJyA/IGZhbGxiYWNrUmVuZGVyKCkgOiBmYWxsYmFja1JlbmRlcik7XG4gIH1cblxuICB2YXIgdGFyZ2V0ID0gcHJvcHMgJiYgcHJvcHMuc2xvdDtcbiAgaWYgKHRhcmdldCkge1xuICAgIHJldHVybiB0aGlzLiRjcmVhdGVFbGVtZW50KCd0ZW1wbGF0ZScsIHsgc2xvdDogdGFyZ2V0IH0sIG5vZGVzKVxuICB9IGVsc2Uge1xuICAgIHJldHVybiBub2Rlc1xuICB9XG59XG5cbi8qICAqL1xuXG4vKipcbiAqIFJ1bnRpbWUgaGVscGVyIGZvciByZXNvbHZpbmcgZmlsdGVyc1xuICovXG5mdW5jdGlvbiByZXNvbHZlRmlsdGVyIChpZCkge1xuICByZXR1cm4gcmVzb2x2ZUFzc2V0KHRoaXMuJG9wdGlvbnMsICdmaWx0ZXJzJywgaWQsIHRydWUpIHx8IGlkZW50aXR5XG59XG5cbi8qICAqL1xuXG5mdW5jdGlvbiBpc0tleU5vdE1hdGNoIChleHBlY3QsIGFjdHVhbCkge1xuICBpZiAoQXJyYXkuaXNBcnJheShleHBlY3QpKSB7XG4gICAgcmV0dXJuIGV4cGVjdC5pbmRleE9mKGFjdHVhbCkgPT09IC0xXG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGV4cGVjdCAhPT0gYWN0dWFsXG4gIH1cbn1cblxuLyoqXG4gKiBSdW50aW1lIGhlbHBlciBmb3IgY2hlY2tpbmcga2V5Q29kZXMgZnJvbSBjb25maWcuXG4gKiBleHBvc2VkIGFzIFZ1ZS5wcm90b3R5cGUuX2tcbiAqIHBhc3NpbmcgaW4gZXZlbnRLZXlOYW1lIGFzIGxhc3QgYXJndW1lbnQgc2VwYXJhdGVseSBmb3IgYmFja3dhcmRzIGNvbXBhdFxuICovXG5mdW5jdGlvbiBjaGVja0tleUNvZGVzIChcbiAgZXZlbnRLZXlDb2RlLFxuICBrZXksXG4gIGJ1aWx0SW5LZXlDb2RlLFxuICBldmVudEtleU5hbWUsXG4gIGJ1aWx0SW5LZXlOYW1lXG4pIHtcbiAgdmFyIG1hcHBlZEtleUNvZGUgPSBjb25maWcua2V5Q29kZXNba2V5XSB8fCBidWlsdEluS2V5Q29kZTtcbiAgaWYgKGJ1aWx0SW5LZXlOYW1lICYmIGV2ZW50S2V5TmFtZSAmJiAhY29uZmlnLmtleUNvZGVzW2tleV0pIHtcbiAgICByZXR1cm4gaXNLZXlOb3RNYXRjaChidWlsdEluS2V5TmFtZSwgZXZlbnRLZXlOYW1lKVxuICB9IGVsc2UgaWYgKG1hcHBlZEtleUNvZGUpIHtcbiAgICByZXR1cm4gaXNLZXlOb3RNYXRjaChtYXBwZWRLZXlDb2RlLCBldmVudEtleUNvZGUpXG4gIH0gZWxzZSBpZiAoZXZlbnRLZXlOYW1lKSB7XG4gICAgcmV0dXJuIGh5cGhlbmF0ZShldmVudEtleU5hbWUpICE9PSBrZXlcbiAgfVxuICByZXR1cm4gZXZlbnRLZXlDb2RlID09PSB1bmRlZmluZWRcbn1cblxuLyogICovXG5cbi8qKlxuICogUnVudGltZSBoZWxwZXIgZm9yIG1lcmdpbmcgdi1iaW5kPVwib2JqZWN0XCIgaW50byBhIFZOb2RlJ3MgZGF0YS5cbiAqL1xuZnVuY3Rpb24gYmluZE9iamVjdFByb3BzIChcbiAgZGF0YSxcbiAgdGFnLFxuICB2YWx1ZSxcbiAgYXNQcm9wLFxuICBpc1N5bmNcbikge1xuICBpZiAodmFsdWUpIHtcbiAgICBpZiAoIWlzT2JqZWN0KHZhbHVlKSkge1xuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiB3YXJuKFxuICAgICAgICAndi1iaW5kIHdpdGhvdXQgYXJndW1lbnQgZXhwZWN0cyBhbiBPYmplY3Qgb3IgQXJyYXkgdmFsdWUnLFxuICAgICAgICB0aGlzXG4gICAgICApO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgdmFsdWUgPSB0b09iamVjdCh2YWx1ZSk7XG4gICAgICB9XG4gICAgICB2YXIgaGFzaDtcbiAgICAgIHZhciBsb29wID0gZnVuY3Rpb24gKCBrZXkgKSB7XG4gICAgICAgIGlmIChcbiAgICAgICAgICBrZXkgPT09ICdjbGFzcycgfHxcbiAgICAgICAgICBrZXkgPT09ICdzdHlsZScgfHxcbiAgICAgICAgICBpc1Jlc2VydmVkQXR0cmlidXRlKGtleSlcbiAgICAgICAgKSB7XG4gICAgICAgICAgaGFzaCA9IGRhdGE7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFyIHR5cGUgPSBkYXRhLmF0dHJzICYmIGRhdGEuYXR0cnMudHlwZTtcbiAgICAgICAgICBoYXNoID0gYXNQcm9wIHx8IGNvbmZpZy5tdXN0VXNlUHJvcCh0YWcsIHR5cGUsIGtleSlcbiAgICAgICAgICAgID8gZGF0YS5kb21Qcm9wcyB8fCAoZGF0YS5kb21Qcm9wcyA9IHt9KVxuICAgICAgICAgICAgOiBkYXRhLmF0dHJzIHx8IChkYXRhLmF0dHJzID0ge30pO1xuICAgICAgICB9XG4gICAgICAgIHZhciBjYW1lbGl6ZWRLZXkgPSBjYW1lbGl6ZShrZXkpO1xuICAgICAgICB2YXIgaHlwaGVuYXRlZEtleSA9IGh5cGhlbmF0ZShrZXkpO1xuICAgICAgICBpZiAoIShjYW1lbGl6ZWRLZXkgaW4gaGFzaCkgJiYgIShoeXBoZW5hdGVkS2V5IGluIGhhc2gpKSB7XG4gICAgICAgICAgaGFzaFtrZXldID0gdmFsdWVba2V5XTtcblxuICAgICAgICAgIGlmIChpc1N5bmMpIHtcbiAgICAgICAgICAgIHZhciBvbiA9IGRhdGEub24gfHwgKGRhdGEub24gPSB7fSk7XG4gICAgICAgICAgICBvblsoXCJ1cGRhdGU6XCIgKyBrZXkpXSA9IGZ1bmN0aW9uICgkZXZlbnQpIHtcbiAgICAgICAgICAgICAgdmFsdWVba2V5XSA9ICRldmVudDtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICBmb3IgKHZhciBrZXkgaW4gdmFsdWUpIGxvb3AoIGtleSApO1xuICAgIH1cbiAgfVxuICByZXR1cm4gZGF0YVxufVxuXG4vKiAgKi9cblxuLyoqXG4gKiBSdW50aW1lIGhlbHBlciBmb3IgcmVuZGVyaW5nIHN0YXRpYyB0cmVlcy5cbiAqL1xuZnVuY3Rpb24gcmVuZGVyU3RhdGljIChcbiAgaW5kZXgsXG4gIGlzSW5Gb3Jcbikge1xuICB2YXIgY2FjaGVkID0gdGhpcy5fc3RhdGljVHJlZXMgfHwgKHRoaXMuX3N0YXRpY1RyZWVzID0gW10pO1xuICB2YXIgdHJlZSA9IGNhY2hlZFtpbmRleF07XG4gIC8vIGlmIGhhcyBhbHJlYWR5LXJlbmRlcmVkIHN0YXRpYyB0cmVlIGFuZCBub3QgaW5zaWRlIHYtZm9yLFxuICAvLyB3ZSBjYW4gcmV1c2UgdGhlIHNhbWUgdHJlZS5cbiAgaWYgKHRyZWUgJiYgIWlzSW5Gb3IpIHtcbiAgICByZXR1cm4gdHJlZVxuICB9XG4gIC8vIG90aGVyd2lzZSwgcmVuZGVyIGEgZnJlc2ggdHJlZS5cbiAgdHJlZSA9IGNhY2hlZFtpbmRleF0gPSB0aGlzLiRvcHRpb25zLnN0YXRpY1JlbmRlckZuc1tpbmRleF0uY2FsbChcbiAgICB0aGlzLl9yZW5kZXJQcm94eSxcbiAgICBudWxsLFxuICAgIHRoaXMgLy8gZm9yIHJlbmRlciBmbnMgZ2VuZXJhdGVkIGZvciBmdW5jdGlvbmFsIGNvbXBvbmVudCB0ZW1wbGF0ZXNcbiAgKTtcbiAgbWFya1N0YXRpYyh0cmVlLCAoXCJfX3N0YXRpY19fXCIgKyBpbmRleCksIGZhbHNlKTtcbiAgcmV0dXJuIHRyZWVcbn1cblxuLyoqXG4gKiBSdW50aW1lIGhlbHBlciBmb3Igdi1vbmNlLlxuICogRWZmZWN0aXZlbHkgaXQgbWVhbnMgbWFya2luZyB0aGUgbm9kZSBhcyBzdGF0aWMgd2l0aCBhIHVuaXF1ZSBrZXkuXG4gKi9cbmZ1bmN0aW9uIG1hcmtPbmNlIChcbiAgdHJlZSxcbiAgaW5kZXgsXG4gIGtleVxuKSB7XG4gIG1hcmtTdGF0aWModHJlZSwgKFwiX19vbmNlX19cIiArIGluZGV4ICsgKGtleSA/IChcIl9cIiArIGtleSkgOiBcIlwiKSksIHRydWUpO1xuICByZXR1cm4gdHJlZVxufVxuXG5mdW5jdGlvbiBtYXJrU3RhdGljIChcbiAgdHJlZSxcbiAga2V5LFxuICBpc09uY2Vcbikge1xuICBpZiAoQXJyYXkuaXNBcnJheSh0cmVlKSkge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdHJlZS5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKHRyZWVbaV0gJiYgdHlwZW9mIHRyZWVbaV0gIT09ICdzdHJpbmcnKSB7XG4gICAgICAgIG1hcmtTdGF0aWNOb2RlKHRyZWVbaV0sIChrZXkgKyBcIl9cIiArIGkpLCBpc09uY2UpO1xuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBtYXJrU3RhdGljTm9kZSh0cmVlLCBrZXksIGlzT25jZSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gbWFya1N0YXRpY05vZGUgKG5vZGUsIGtleSwgaXNPbmNlKSB7XG4gIG5vZGUuaXNTdGF0aWMgPSB0cnVlO1xuICBub2RlLmtleSA9IGtleTtcbiAgbm9kZS5pc09uY2UgPSBpc09uY2U7XG59XG5cbi8qICAqL1xuXG5mdW5jdGlvbiBiaW5kT2JqZWN0TGlzdGVuZXJzIChkYXRhLCB2YWx1ZSkge1xuICBpZiAodmFsdWUpIHtcbiAgICBpZiAoIWlzUGxhaW5PYmplY3QodmFsdWUpKSB7XG4gICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIHdhcm4oXG4gICAgICAgICd2LW9uIHdpdGhvdXQgYXJndW1lbnQgZXhwZWN0cyBhbiBPYmplY3QgdmFsdWUnLFxuICAgICAgICB0aGlzXG4gICAgICApO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgb24gPSBkYXRhLm9uID0gZGF0YS5vbiA/IGV4dGVuZCh7fSwgZGF0YS5vbikgOiB7fTtcbiAgICAgIGZvciAodmFyIGtleSBpbiB2YWx1ZSkge1xuICAgICAgICB2YXIgZXhpc3RpbmcgPSBvbltrZXldO1xuICAgICAgICB2YXIgb3VycyA9IHZhbHVlW2tleV07XG4gICAgICAgIG9uW2tleV0gPSBleGlzdGluZyA/IFtdLmNvbmNhdChleGlzdGluZywgb3VycykgOiBvdXJzO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gZGF0YVxufVxuXG4vKiAgKi9cblxuZnVuY3Rpb24gcmVzb2x2ZVNjb3BlZFNsb3RzIChcbiAgZm5zLCAvLyBzZWUgZmxvdy92bm9kZVxuICByZXMsXG4gIC8vIHRoZSBmb2xsb3dpbmcgYXJlIGFkZGVkIGluIDIuNlxuICBoYXNEeW5hbWljS2V5cyxcbiAgY29udGVudEhhc2hLZXlcbikge1xuICByZXMgPSByZXMgfHwgeyAkc3RhYmxlOiAhaGFzRHluYW1pY0tleXMgfTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBmbnMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgc2xvdCA9IGZuc1tpXTtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShzbG90KSkge1xuICAgICAgcmVzb2x2ZVNjb3BlZFNsb3RzKHNsb3QsIHJlcywgaGFzRHluYW1pY0tleXMpO1xuICAgIH0gZWxzZSBpZiAoc2xvdCkge1xuICAgICAgLy8gbWFya2VyIGZvciByZXZlcnNlIHByb3h5aW5nIHYtc2xvdCB3aXRob3V0IHNjb3BlIG9uIHRoaXMuJHNsb3RzXG4gICAgICBpZiAoc2xvdC5wcm94eSkge1xuICAgICAgICBzbG90LmZuLnByb3h5ID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIHJlc1tzbG90LmtleV0gPSBzbG90LmZuO1xuICAgIH1cbiAgfVxuICBpZiAoY29udGVudEhhc2hLZXkpIHtcbiAgICAocmVzKS4ka2V5ID0gY29udGVudEhhc2hLZXk7XG4gIH1cbiAgcmV0dXJuIHJlc1xufVxuXG4vKiAgKi9cblxuZnVuY3Rpb24gYmluZER5bmFtaWNLZXlzIChiYXNlT2JqLCB2YWx1ZXMpIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCB2YWx1ZXMubGVuZ3RoOyBpICs9IDIpIHtcbiAgICB2YXIga2V5ID0gdmFsdWVzW2ldO1xuICAgIGlmICh0eXBlb2Yga2V5ID09PSAnc3RyaW5nJyAmJiBrZXkpIHtcbiAgICAgIGJhc2VPYmpbdmFsdWVzW2ldXSA9IHZhbHVlc1tpICsgMV07XG4gICAgfSBlbHNlIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIGtleSAhPT0gJycgJiYga2V5ICE9PSBudWxsKSB7XG4gICAgICAvLyBudWxsIGlzIGEgc3BlY2lhbCB2YWx1ZSBmb3IgZXhwbGljaXRseSByZW1vdmluZyBhIGJpbmRpbmdcbiAgICAgIHdhcm4oXG4gICAgICAgIChcIkludmFsaWQgdmFsdWUgZm9yIGR5bmFtaWMgZGlyZWN0aXZlIGFyZ3VtZW50IChleHBlY3RlZCBzdHJpbmcgb3IgbnVsbCk6IFwiICsga2V5KSxcbiAgICAgICAgdGhpc1xuICAgICAgKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGJhc2VPYmpcbn1cblxuLy8gaGVscGVyIHRvIGR5bmFtaWNhbGx5IGFwcGVuZCBtb2RpZmllciBydW50aW1lIG1hcmtlcnMgdG8gZXZlbnQgbmFtZXMuXG4vLyBlbnN1cmUgb25seSBhcHBlbmQgd2hlbiB2YWx1ZSBpcyBhbHJlYWR5IHN0cmluZywgb3RoZXJ3aXNlIGl0IHdpbGwgYmUgY2FzdFxuLy8gdG8gc3RyaW5nIGFuZCBjYXVzZSB0aGUgdHlwZSBjaGVjayB0byBtaXNzLlxuZnVuY3Rpb24gcHJlcGVuZE1vZGlmaWVyICh2YWx1ZSwgc3ltYm9sKSB7XG4gIHJldHVybiB0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnID8gc3ltYm9sICsgdmFsdWUgOiB2YWx1ZVxufVxuXG4vKiAgKi9cblxuZnVuY3Rpb24gaW5zdGFsbFJlbmRlckhlbHBlcnMgKHRhcmdldCkge1xuICB0YXJnZXQuX28gPSBtYXJrT25jZTtcbiAgdGFyZ2V0Ll9uID0gdG9OdW1iZXI7XG4gIHRhcmdldC5fcyA9IHRvU3RyaW5nO1xuICB0YXJnZXQuX2wgPSByZW5kZXJMaXN0O1xuICB0YXJnZXQuX3QgPSByZW5kZXJTbG90O1xuICB0YXJnZXQuX3EgPSBsb29zZUVxdWFsO1xuICB0YXJnZXQuX2kgPSBsb29zZUluZGV4T2Y7XG4gIHRhcmdldC5fbSA9IHJlbmRlclN0YXRpYztcbiAgdGFyZ2V0Ll9mID0gcmVzb2x2ZUZpbHRlcjtcbiAgdGFyZ2V0Ll9rID0gY2hlY2tLZXlDb2RlcztcbiAgdGFyZ2V0Ll9iID0gYmluZE9iamVjdFByb3BzO1xuICB0YXJnZXQuX3YgPSBjcmVhdGVUZXh0Vk5vZGU7XG4gIHRhcmdldC5fZSA9IGNyZWF0ZUVtcHR5Vk5vZGU7XG4gIHRhcmdldC5fdSA9IHJlc29sdmVTY29wZWRTbG90cztcbiAgdGFyZ2V0Ll9nID0gYmluZE9iamVjdExpc3RlbmVycztcbiAgdGFyZ2V0Ll9kID0gYmluZER5bmFtaWNLZXlzO1xuICB0YXJnZXQuX3AgPSBwcmVwZW5kTW9kaWZpZXI7XG59XG5cbi8qICAqL1xuXG5mdW5jdGlvbiBGdW5jdGlvbmFsUmVuZGVyQ29udGV4dCAoXG4gIGRhdGEsXG4gIHByb3BzLFxuICBjaGlsZHJlbixcbiAgcGFyZW50LFxuICBDdG9yXG4pIHtcbiAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgdmFyIG9wdGlvbnMgPSBDdG9yLm9wdGlvbnM7XG4gIC8vIGVuc3VyZSB0aGUgY3JlYXRlRWxlbWVudCBmdW5jdGlvbiBpbiBmdW5jdGlvbmFsIGNvbXBvbmVudHNcbiAgLy8gZ2V0cyBhIHVuaXF1ZSBjb250ZXh0IC0gdGhpcyBpcyBuZWNlc3NhcnkgZm9yIGNvcnJlY3QgbmFtZWQgc2xvdCBjaGVja1xuICB2YXIgY29udGV4dFZtO1xuICBpZiAoaGFzT3duKHBhcmVudCwgJ191aWQnKSkge1xuICAgIGNvbnRleHRWbSA9IE9iamVjdC5jcmVhdGUocGFyZW50KTtcbiAgICAvLyAkZmxvdy1kaXNhYmxlLWxpbmVcbiAgICBjb250ZXh0Vm0uX29yaWdpbmFsID0gcGFyZW50O1xuICB9IGVsc2Uge1xuICAgIC8vIHRoZSBjb250ZXh0IHZtIHBhc3NlZCBpbiBpcyBhIGZ1bmN0aW9uYWwgY29udGV4dCBhcyB3ZWxsLlxuICAgIC8vIGluIHRoaXMgY2FzZSB3ZSB3YW50IHRvIG1ha2Ugc3VyZSB3ZSBhcmUgYWJsZSB0byBnZXQgYSBob2xkIHRvIHRoZVxuICAgIC8vIHJlYWwgY29udGV4dCBpbnN0YW5jZS5cbiAgICBjb250ZXh0Vm0gPSBwYXJlbnQ7XG4gICAgLy8gJGZsb3ctZGlzYWJsZS1saW5lXG4gICAgcGFyZW50ID0gcGFyZW50Ll9vcmlnaW5hbDtcbiAgfVxuICB2YXIgaXNDb21waWxlZCA9IGlzVHJ1ZShvcHRpb25zLl9jb21waWxlZCk7XG4gIHZhciBuZWVkTm9ybWFsaXphdGlvbiA9ICFpc0NvbXBpbGVkO1xuXG4gIHRoaXMuZGF0YSA9IGRhdGE7XG4gIHRoaXMucHJvcHMgPSBwcm9wcztcbiAgdGhpcy5jaGlsZHJlbiA9IGNoaWxkcmVuO1xuICB0aGlzLnBhcmVudCA9IHBhcmVudDtcbiAgdGhpcy5saXN0ZW5lcnMgPSBkYXRhLm9uIHx8IGVtcHR5T2JqZWN0O1xuICB0aGlzLmluamVjdGlvbnMgPSByZXNvbHZlSW5qZWN0KG9wdGlvbnMuaW5qZWN0LCBwYXJlbnQpO1xuICB0aGlzLnNsb3RzID0gZnVuY3Rpb24gKCkge1xuICAgIGlmICghdGhpcyQxLiRzbG90cykge1xuICAgICAgbm9ybWFsaXplU2NvcGVkU2xvdHMoXG4gICAgICAgIGRhdGEuc2NvcGVkU2xvdHMsXG4gICAgICAgIHRoaXMkMS4kc2xvdHMgPSByZXNvbHZlU2xvdHMoY2hpbGRyZW4sIHBhcmVudClcbiAgICAgICk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzJDEuJHNsb3RzXG4gIH07XG5cbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsICdzY29wZWRTbG90cycsICh7XG4gICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCAoKSB7XG4gICAgICByZXR1cm4gbm9ybWFsaXplU2NvcGVkU2xvdHMoZGF0YS5zY29wZWRTbG90cywgdGhpcy5zbG90cygpKVxuICAgIH1cbiAgfSkpO1xuXG4gIC8vIHN1cHBvcnQgZm9yIGNvbXBpbGVkIGZ1bmN0aW9uYWwgdGVtcGxhdGVcbiAgaWYgKGlzQ29tcGlsZWQpIHtcbiAgICAvLyBleHBvc2luZyAkb3B0aW9ucyBmb3IgcmVuZGVyU3RhdGljKClcbiAgICB0aGlzLiRvcHRpb25zID0gb3B0aW9ucztcbiAgICAvLyBwcmUtcmVzb2x2ZSBzbG90cyBmb3IgcmVuZGVyU2xvdCgpXG4gICAgdGhpcy4kc2xvdHMgPSB0aGlzLnNsb3RzKCk7XG4gICAgdGhpcy4kc2NvcGVkU2xvdHMgPSBub3JtYWxpemVTY29wZWRTbG90cyhkYXRhLnNjb3BlZFNsb3RzLCB0aGlzLiRzbG90cyk7XG4gIH1cblxuICBpZiAob3B0aW9ucy5fc2NvcGVJZCkge1xuICAgIHRoaXMuX2MgPSBmdW5jdGlvbiAoYSwgYiwgYywgZCkge1xuICAgICAgdmFyIHZub2RlID0gY3JlYXRlRWxlbWVudChjb250ZXh0Vm0sIGEsIGIsIGMsIGQsIG5lZWROb3JtYWxpemF0aW9uKTtcbiAgICAgIGlmICh2bm9kZSAmJiAhQXJyYXkuaXNBcnJheSh2bm9kZSkpIHtcbiAgICAgICAgdm5vZGUuZm5TY29wZUlkID0gb3B0aW9ucy5fc2NvcGVJZDtcbiAgICAgICAgdm5vZGUuZm5Db250ZXh0ID0gcGFyZW50O1xuICAgICAgfVxuICAgICAgcmV0dXJuIHZub2RlXG4gICAgfTtcbiAgfSBlbHNlIHtcbiAgICB0aGlzLl9jID0gZnVuY3Rpb24gKGEsIGIsIGMsIGQpIHsgcmV0dXJuIGNyZWF0ZUVsZW1lbnQoY29udGV4dFZtLCBhLCBiLCBjLCBkLCBuZWVkTm9ybWFsaXphdGlvbik7IH07XG4gIH1cbn1cblxuaW5zdGFsbFJlbmRlckhlbHBlcnMoRnVuY3Rpb25hbFJlbmRlckNvbnRleHQucHJvdG90eXBlKTtcblxuZnVuY3Rpb24gY3JlYXRlRnVuY3Rpb25hbENvbXBvbmVudCAoXG4gIEN0b3IsXG4gIHByb3BzRGF0YSxcbiAgZGF0YSxcbiAgY29udGV4dFZtLFxuICBjaGlsZHJlblxuKSB7XG4gIHZhciBvcHRpb25zID0gQ3Rvci5vcHRpb25zO1xuICB2YXIgcHJvcHMgPSB7fTtcbiAgdmFyIHByb3BPcHRpb25zID0gb3B0aW9ucy5wcm9wcztcbiAgaWYgKGlzRGVmKHByb3BPcHRpb25zKSkge1xuICAgIGZvciAodmFyIGtleSBpbiBwcm9wT3B0aW9ucykge1xuICAgICAgcHJvcHNba2V5XSA9IHZhbGlkYXRlUHJvcChrZXksIHByb3BPcHRpb25zLCBwcm9wc0RhdGEgfHwgZW1wdHlPYmplY3QpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBpZiAoaXNEZWYoZGF0YS5hdHRycykpIHsgbWVyZ2VQcm9wcyhwcm9wcywgZGF0YS5hdHRycyk7IH1cbiAgICBpZiAoaXNEZWYoZGF0YS5wcm9wcykpIHsgbWVyZ2VQcm9wcyhwcm9wcywgZGF0YS5wcm9wcyk7IH1cbiAgfVxuXG4gIHZhciByZW5kZXJDb250ZXh0ID0gbmV3IEZ1bmN0aW9uYWxSZW5kZXJDb250ZXh0KFxuICAgIGRhdGEsXG4gICAgcHJvcHMsXG4gICAgY2hpbGRyZW4sXG4gICAgY29udGV4dFZtLFxuICAgIEN0b3JcbiAgKTtcblxuICB2YXIgdm5vZGUgPSBvcHRpb25zLnJlbmRlci5jYWxsKG51bGwsIHJlbmRlckNvbnRleHQuX2MsIHJlbmRlckNvbnRleHQpO1xuXG4gIGlmICh2bm9kZSBpbnN0YW5jZW9mIFZOb2RlKSB7XG4gICAgcmV0dXJuIGNsb25lQW5kTWFya0Z1bmN0aW9uYWxSZXN1bHQodm5vZGUsIGRhdGEsIHJlbmRlckNvbnRleHQucGFyZW50LCBvcHRpb25zLCByZW5kZXJDb250ZXh0KVxuICB9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkodm5vZGUpKSB7XG4gICAgdmFyIHZub2RlcyA9IG5vcm1hbGl6ZUNoaWxkcmVuKHZub2RlKSB8fCBbXTtcbiAgICB2YXIgcmVzID0gbmV3IEFycmF5KHZub2Rlcy5sZW5ndGgpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdm5vZGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICByZXNbaV0gPSBjbG9uZUFuZE1hcmtGdW5jdGlvbmFsUmVzdWx0KHZub2Rlc1tpXSwgZGF0YSwgcmVuZGVyQ29udGV4dC5wYXJlbnQsIG9wdGlvbnMsIHJlbmRlckNvbnRleHQpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzXG4gIH1cbn1cblxuZnVuY3Rpb24gY2xvbmVBbmRNYXJrRnVuY3Rpb25hbFJlc3VsdCAodm5vZGUsIGRhdGEsIGNvbnRleHRWbSwgb3B0aW9ucywgcmVuZGVyQ29udGV4dCkge1xuICAvLyAjNzgxNyBjbG9uZSBub2RlIGJlZm9yZSBzZXR0aW5nIGZuQ29udGV4dCwgb3RoZXJ3aXNlIGlmIHRoZSBub2RlIGlzIHJldXNlZFxuICAvLyAoZS5nLiBpdCB3YXMgZnJvbSBhIGNhY2hlZCBub3JtYWwgc2xvdCkgdGhlIGZuQ29udGV4dCBjYXVzZXMgbmFtZWQgc2xvdHNcbiAgLy8gdGhhdCBzaG91bGQgbm90IGJlIG1hdGNoZWQgdG8gbWF0Y2guXG4gIHZhciBjbG9uZSA9IGNsb25lVk5vZGUodm5vZGUpO1xuICBjbG9uZS5mbkNvbnRleHQgPSBjb250ZXh0Vm07XG4gIGNsb25lLmZuT3B0aW9ucyA9IG9wdGlvbnM7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgKGNsb25lLmRldnRvb2xzTWV0YSA9IGNsb25lLmRldnRvb2xzTWV0YSB8fCB7fSkucmVuZGVyQ29udGV4dCA9IHJlbmRlckNvbnRleHQ7XG4gIH1cbiAgaWYgKGRhdGEuc2xvdCkge1xuICAgIChjbG9uZS5kYXRhIHx8IChjbG9uZS5kYXRhID0ge30pKS5zbG90ID0gZGF0YS5zbG90O1xuICB9XG4gIHJldHVybiBjbG9uZVxufVxuXG5mdW5jdGlvbiBtZXJnZVByb3BzICh0bywgZnJvbSkge1xuICBmb3IgKHZhciBrZXkgaW4gZnJvbSkge1xuICAgIHRvW2NhbWVsaXplKGtleSldID0gZnJvbVtrZXldO1xuICB9XG59XG5cbi8qICAqL1xuXG4vKiAgKi9cblxuLyogICovXG5cbi8qICAqL1xuXG4vLyBpbmxpbmUgaG9va3MgdG8gYmUgaW52b2tlZCBvbiBjb21wb25lbnQgVk5vZGVzIGR1cmluZyBwYXRjaFxudmFyIGNvbXBvbmVudFZOb2RlSG9va3MgPSB7XG4gIGluaXQ6IGZ1bmN0aW9uIGluaXQgKHZub2RlLCBoeWRyYXRpbmcpIHtcbiAgICBpZiAoXG4gICAgICB2bm9kZS5jb21wb25lbnRJbnN0YW5jZSAmJlxuICAgICAgIXZub2RlLmNvbXBvbmVudEluc3RhbmNlLl9pc0Rlc3Ryb3llZCAmJlxuICAgICAgdm5vZGUuZGF0YS5rZWVwQWxpdmVcbiAgICApIHtcbiAgICAgIC8vIGtlcHQtYWxpdmUgY29tcG9uZW50cywgdHJlYXQgYXMgYSBwYXRjaFxuICAgICAgdmFyIG1vdW50ZWROb2RlID0gdm5vZGU7IC8vIHdvcmsgYXJvdW5kIGZsb3dcbiAgICAgIGNvbXBvbmVudFZOb2RlSG9va3MucHJlcGF0Y2gobW91bnRlZE5vZGUsIG1vdW50ZWROb2RlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIGNoaWxkID0gdm5vZGUuY29tcG9uZW50SW5zdGFuY2UgPSBjcmVhdGVDb21wb25lbnRJbnN0YW5jZUZvclZub2RlKFxuICAgICAgICB2bm9kZSxcbiAgICAgICAgYWN0aXZlSW5zdGFuY2VcbiAgICAgICk7XG4gICAgICBjaGlsZC4kbW91bnQoaHlkcmF0aW5nID8gdm5vZGUuZWxtIDogdW5kZWZpbmVkLCBoeWRyYXRpbmcpO1xuICAgIH1cbiAgfSxcblxuICBwcmVwYXRjaDogZnVuY3Rpb24gcHJlcGF0Y2ggKG9sZFZub2RlLCB2bm9kZSkge1xuICAgIHZhciBvcHRpb25zID0gdm5vZGUuY29tcG9uZW50T3B0aW9ucztcbiAgICB2YXIgY2hpbGQgPSB2bm9kZS5jb21wb25lbnRJbnN0YW5jZSA9IG9sZFZub2RlLmNvbXBvbmVudEluc3RhbmNlO1xuICAgIHVwZGF0ZUNoaWxkQ29tcG9uZW50KFxuICAgICAgY2hpbGQsXG4gICAgICBvcHRpb25zLnByb3BzRGF0YSwgLy8gdXBkYXRlZCBwcm9wc1xuICAgICAgb3B0aW9ucy5saXN0ZW5lcnMsIC8vIHVwZGF0ZWQgbGlzdGVuZXJzXG4gICAgICB2bm9kZSwgLy8gbmV3IHBhcmVudCB2bm9kZVxuICAgICAgb3B0aW9ucy5jaGlsZHJlbiAvLyBuZXcgY2hpbGRyZW5cbiAgICApO1xuICB9LFxuXG4gIGluc2VydDogZnVuY3Rpb24gaW5zZXJ0ICh2bm9kZSkge1xuICAgIHZhciBjb250ZXh0ID0gdm5vZGUuY29udGV4dDtcbiAgICB2YXIgY29tcG9uZW50SW5zdGFuY2UgPSB2bm9kZS5jb21wb25lbnRJbnN0YW5jZTtcbiAgICBpZiAoIWNvbXBvbmVudEluc3RhbmNlLl9pc01vdW50ZWQpIHtcbiAgICAgIGNvbXBvbmVudEluc3RhbmNlLl9pc01vdW50ZWQgPSB0cnVlO1xuICAgICAgY2FsbEhvb2soY29tcG9uZW50SW5zdGFuY2UsICdtb3VudGVkJyk7XG4gICAgfVxuICAgIGlmICh2bm9kZS5kYXRhLmtlZXBBbGl2ZSkge1xuICAgICAgaWYgKGNvbnRleHQuX2lzTW91bnRlZCkge1xuICAgICAgICAvLyB2dWUtcm91dGVyIzEyMTJcbiAgICAgICAgLy8gRHVyaW5nIHVwZGF0ZXMsIGEga2VwdC1hbGl2ZSBjb21wb25lbnQncyBjaGlsZCBjb21wb25lbnRzIG1heVxuICAgICAgICAvLyBjaGFuZ2UsIHNvIGRpcmVjdGx5IHdhbGtpbmcgdGhlIHRyZWUgaGVyZSBtYXkgY2FsbCBhY3RpdmF0ZWQgaG9va3NcbiAgICAgICAgLy8gb24gaW5jb3JyZWN0IGNoaWxkcmVuLiBJbnN0ZWFkIHdlIHB1c2ggdGhlbSBpbnRvIGEgcXVldWUgd2hpY2ggd2lsbFxuICAgICAgICAvLyBiZSBwcm9jZXNzZWQgYWZ0ZXIgdGhlIHdob2xlIHBhdGNoIHByb2Nlc3MgZW5kZWQuXG4gICAgICAgIHF1ZXVlQWN0aXZhdGVkQ29tcG9uZW50KGNvbXBvbmVudEluc3RhbmNlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGFjdGl2YXRlQ2hpbGRDb21wb25lbnQoY29tcG9uZW50SW5zdGFuY2UsIHRydWUgLyogZGlyZWN0ICovKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sXG5cbiAgZGVzdHJveTogZnVuY3Rpb24gZGVzdHJveSAodm5vZGUpIHtcbiAgICB2YXIgY29tcG9uZW50SW5zdGFuY2UgPSB2bm9kZS5jb21wb25lbnRJbnN0YW5jZTtcbiAgICBpZiAoIWNvbXBvbmVudEluc3RhbmNlLl9pc0Rlc3Ryb3llZCkge1xuICAgICAgaWYgKCF2bm9kZS5kYXRhLmtlZXBBbGl2ZSkge1xuICAgICAgICBjb21wb25lbnRJbnN0YW5jZS4kZGVzdHJveSgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZGVhY3RpdmF0ZUNoaWxkQ29tcG9uZW50KGNvbXBvbmVudEluc3RhbmNlLCB0cnVlIC8qIGRpcmVjdCAqLyk7XG4gICAgICB9XG4gICAgfVxuICB9XG59O1xuXG52YXIgaG9va3NUb01lcmdlID0gT2JqZWN0LmtleXMoY29tcG9uZW50Vk5vZGVIb29rcyk7XG5cbmZ1bmN0aW9uIGNyZWF0ZUNvbXBvbmVudCAoXG4gIEN0b3IsXG4gIGRhdGEsXG4gIGNvbnRleHQsXG4gIGNoaWxkcmVuLFxuICB0YWdcbikge1xuICBpZiAoaXNVbmRlZihDdG9yKSkge1xuICAgIHJldHVyblxuICB9XG5cbiAgdmFyIGJhc2VDdG9yID0gY29udGV4dC4kb3B0aW9ucy5fYmFzZTtcblxuICAvLyBwbGFpbiBvcHRpb25zIG9iamVjdDogdHVybiBpdCBpbnRvIGEgY29uc3RydWN0b3JcbiAgaWYgKGlzT2JqZWN0KEN0b3IpKSB7XG4gICAgQ3RvciA9IGJhc2VDdG9yLmV4dGVuZChDdG9yKTtcbiAgfVxuXG4gIC8vIGlmIGF0IHRoaXMgc3RhZ2UgaXQncyBub3QgYSBjb25zdHJ1Y3RvciBvciBhbiBhc3luYyBjb21wb25lbnQgZmFjdG9yeSxcbiAgLy8gcmVqZWN0LlxuICBpZiAodHlwZW9mIEN0b3IgIT09ICdmdW5jdGlvbicpIHtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgd2FybigoXCJJbnZhbGlkIENvbXBvbmVudCBkZWZpbml0aW9uOiBcIiArIChTdHJpbmcoQ3RvcikpKSwgY29udGV4dCk7XG4gICAgfVxuICAgIHJldHVyblxuICB9XG5cbiAgLy8gYXN5bmMgY29tcG9uZW50XG4gIHZhciBhc3luY0ZhY3Rvcnk7XG4gIGlmIChpc1VuZGVmKEN0b3IuY2lkKSkge1xuICAgIGFzeW5jRmFjdG9yeSA9IEN0b3I7XG4gICAgQ3RvciA9IHJlc29sdmVBc3luY0NvbXBvbmVudChhc3luY0ZhY3RvcnksIGJhc2VDdG9yKTtcbiAgICBpZiAoQ3RvciA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAvLyByZXR1cm4gYSBwbGFjZWhvbGRlciBub2RlIGZvciBhc3luYyBjb21wb25lbnQsIHdoaWNoIGlzIHJlbmRlcmVkXG4gICAgICAvLyBhcyBhIGNvbW1lbnQgbm9kZSBidXQgcHJlc2VydmVzIGFsbCB0aGUgcmF3IGluZm9ybWF0aW9uIGZvciB0aGUgbm9kZS5cbiAgICAgIC8vIHRoZSBpbmZvcm1hdGlvbiB3aWxsIGJlIHVzZWQgZm9yIGFzeW5jIHNlcnZlci1yZW5kZXJpbmcgYW5kIGh5ZHJhdGlvbi5cbiAgICAgIHJldHVybiBjcmVhdGVBc3luY1BsYWNlaG9sZGVyKFxuICAgICAgICBhc3luY0ZhY3RvcnksXG4gICAgICAgIGRhdGEsXG4gICAgICAgIGNvbnRleHQsXG4gICAgICAgIGNoaWxkcmVuLFxuICAgICAgICB0YWdcbiAgICAgIClcbiAgICB9XG4gIH1cblxuICBkYXRhID0gZGF0YSB8fCB7fTtcblxuICAvLyByZXNvbHZlIGNvbnN0cnVjdG9yIG9wdGlvbnMgaW4gY2FzZSBnbG9iYWwgbWl4aW5zIGFyZSBhcHBsaWVkIGFmdGVyXG4gIC8vIGNvbXBvbmVudCBjb25zdHJ1Y3RvciBjcmVhdGlvblxuICByZXNvbHZlQ29uc3RydWN0b3JPcHRpb25zKEN0b3IpO1xuXG4gIC8vIHRyYW5zZm9ybSBjb21wb25lbnQgdi1tb2RlbCBkYXRhIGludG8gcHJvcHMgJiBldmVudHNcbiAgaWYgKGlzRGVmKGRhdGEubW9kZWwpKSB7XG4gICAgdHJhbnNmb3JtTW9kZWwoQ3Rvci5vcHRpb25zLCBkYXRhKTtcbiAgfVxuXG4gIC8vIGV4dHJhY3QgcHJvcHNcbiAgdmFyIHByb3BzRGF0YSA9IGV4dHJhY3RQcm9wc0Zyb21WTm9kZURhdGEoZGF0YSwgQ3RvciwgdGFnKTtcblxuICAvLyBmdW5jdGlvbmFsIGNvbXBvbmVudFxuICBpZiAoaXNUcnVlKEN0b3Iub3B0aW9ucy5mdW5jdGlvbmFsKSkge1xuICAgIHJldHVybiBjcmVhdGVGdW5jdGlvbmFsQ29tcG9uZW50KEN0b3IsIHByb3BzRGF0YSwgZGF0YSwgY29udGV4dCwgY2hpbGRyZW4pXG4gIH1cblxuICAvLyBleHRyYWN0IGxpc3RlbmVycywgc2luY2UgdGhlc2UgbmVlZHMgdG8gYmUgdHJlYXRlZCBhc1xuICAvLyBjaGlsZCBjb21wb25lbnQgbGlzdGVuZXJzIGluc3RlYWQgb2YgRE9NIGxpc3RlbmVyc1xuICB2YXIgbGlzdGVuZXJzID0gZGF0YS5vbjtcbiAgLy8gcmVwbGFjZSB3aXRoIGxpc3RlbmVycyB3aXRoIC5uYXRpdmUgbW9kaWZpZXJcbiAgLy8gc28gaXQgZ2V0cyBwcm9jZXNzZWQgZHVyaW5nIHBhcmVudCBjb21wb25lbnQgcGF0Y2guXG4gIGRhdGEub24gPSBkYXRhLm5hdGl2ZU9uO1xuXG4gIGlmIChpc1RydWUoQ3Rvci5vcHRpb25zLmFic3RyYWN0KSkge1xuICAgIC8vIGFic3RyYWN0IGNvbXBvbmVudHMgZG8gbm90IGtlZXAgYW55dGhpbmdcbiAgICAvLyBvdGhlciB0aGFuIHByb3BzICYgbGlzdGVuZXJzICYgc2xvdFxuXG4gICAgLy8gd29yayBhcm91bmQgZmxvd1xuICAgIHZhciBzbG90ID0gZGF0YS5zbG90O1xuICAgIGRhdGEgPSB7fTtcbiAgICBpZiAoc2xvdCkge1xuICAgICAgZGF0YS5zbG90ID0gc2xvdDtcbiAgICB9XG4gIH1cblxuICAvLyBpbnN0YWxsIGNvbXBvbmVudCBtYW5hZ2VtZW50IGhvb2tzIG9udG8gdGhlIHBsYWNlaG9sZGVyIG5vZGVcbiAgaW5zdGFsbENvbXBvbmVudEhvb2tzKGRhdGEpO1xuXG4gIC8vIHJldHVybiBhIHBsYWNlaG9sZGVyIHZub2RlXG4gIHZhciBuYW1lID0gQ3Rvci5vcHRpb25zLm5hbWUgfHwgdGFnO1xuICB2YXIgdm5vZGUgPSBuZXcgVk5vZGUoXG4gICAgKFwidnVlLWNvbXBvbmVudC1cIiArIChDdG9yLmNpZCkgKyAobmFtZSA/IChcIi1cIiArIG5hbWUpIDogJycpKSxcbiAgICBkYXRhLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCBjb250ZXh0LFxuICAgIHsgQ3RvcjogQ3RvciwgcHJvcHNEYXRhOiBwcm9wc0RhdGEsIGxpc3RlbmVyczogbGlzdGVuZXJzLCB0YWc6IHRhZywgY2hpbGRyZW46IGNoaWxkcmVuIH0sXG4gICAgYXN5bmNGYWN0b3J5XG4gICk7XG5cbiAgcmV0dXJuIHZub2RlXG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUNvbXBvbmVudEluc3RhbmNlRm9yVm5vZGUgKFxuICAvLyB3ZSBrbm93IGl0J3MgTW91bnRlZENvbXBvbmVudFZOb2RlIGJ1dCBmbG93IGRvZXNuJ3RcbiAgdm5vZGUsXG4gIC8vIGFjdGl2ZUluc3RhbmNlIGluIGxpZmVjeWNsZSBzdGF0ZVxuICBwYXJlbnRcbikge1xuICB2YXIgb3B0aW9ucyA9IHtcbiAgICBfaXNDb21wb25lbnQ6IHRydWUsXG4gICAgX3BhcmVudFZub2RlOiB2bm9kZSxcbiAgICBwYXJlbnQ6IHBhcmVudFxuICB9O1xuICAvLyBjaGVjayBpbmxpbmUtdGVtcGxhdGUgcmVuZGVyIGZ1bmN0aW9uc1xuICB2YXIgaW5saW5lVGVtcGxhdGUgPSB2bm9kZS5kYXRhLmlubGluZVRlbXBsYXRlO1xuICBpZiAoaXNEZWYoaW5saW5lVGVtcGxhdGUpKSB7XG4gICAgb3B0aW9ucy5yZW5kZXIgPSBpbmxpbmVUZW1wbGF0ZS5yZW5kZXI7XG4gICAgb3B0aW9ucy5zdGF0aWNSZW5kZXJGbnMgPSBpbmxpbmVUZW1wbGF0ZS5zdGF0aWNSZW5kZXJGbnM7XG4gIH1cbiAgcmV0dXJuIG5ldyB2bm9kZS5jb21wb25lbnRPcHRpb25zLkN0b3Iob3B0aW9ucylcbn1cblxuZnVuY3Rpb24gaW5zdGFsbENvbXBvbmVudEhvb2tzIChkYXRhKSB7XG4gIHZhciBob29rcyA9IGRhdGEuaG9vayB8fCAoZGF0YS5ob29rID0ge30pO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGhvb2tzVG9NZXJnZS5sZW5ndGg7IGkrKykge1xuICAgIHZhciBrZXkgPSBob29rc1RvTWVyZ2VbaV07XG4gICAgdmFyIGV4aXN0aW5nID0gaG9va3Nba2V5XTtcbiAgICB2YXIgdG9NZXJnZSA9IGNvbXBvbmVudFZOb2RlSG9va3Nba2V5XTtcbiAgICBpZiAoZXhpc3RpbmcgIT09IHRvTWVyZ2UgJiYgIShleGlzdGluZyAmJiBleGlzdGluZy5fbWVyZ2VkKSkge1xuICAgICAgaG9va3Nba2V5XSA9IGV4aXN0aW5nID8gbWVyZ2VIb29rJDEodG9NZXJnZSwgZXhpc3RpbmcpIDogdG9NZXJnZTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gbWVyZ2VIb29rJDEgKGYxLCBmMikge1xuICB2YXIgbWVyZ2VkID0gZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAvLyBmbG93IGNvbXBsYWlucyBhYm91dCBleHRyYSBhcmdzIHdoaWNoIGlzIHdoeSB3ZSB1c2UgYW55XG4gICAgZjEoYSwgYik7XG4gICAgZjIoYSwgYik7XG4gIH07XG4gIG1lcmdlZC5fbWVyZ2VkID0gdHJ1ZTtcbiAgcmV0dXJuIG1lcmdlZFxufVxuXG4vLyB0cmFuc2Zvcm0gY29tcG9uZW50IHYtbW9kZWwgaW5mbyAodmFsdWUgYW5kIGNhbGxiYWNrKSBpbnRvXG4vLyBwcm9wIGFuZCBldmVudCBoYW5kbGVyIHJlc3BlY3RpdmVseS5cbmZ1bmN0aW9uIHRyYW5zZm9ybU1vZGVsIChvcHRpb25zLCBkYXRhKSB7XG4gIHZhciBwcm9wID0gKG9wdGlvbnMubW9kZWwgJiYgb3B0aW9ucy5tb2RlbC5wcm9wKSB8fCAndmFsdWUnO1xuICB2YXIgZXZlbnQgPSAob3B0aW9ucy5tb2RlbCAmJiBvcHRpb25zLm1vZGVsLmV2ZW50KSB8fCAnaW5wdXQnXG4gIDsoZGF0YS5hdHRycyB8fCAoZGF0YS5hdHRycyA9IHt9KSlbcHJvcF0gPSBkYXRhLm1vZGVsLnZhbHVlO1xuICB2YXIgb24gPSBkYXRhLm9uIHx8IChkYXRhLm9uID0ge30pO1xuICB2YXIgZXhpc3RpbmcgPSBvbltldmVudF07XG4gIHZhciBjYWxsYmFjayA9IGRhdGEubW9kZWwuY2FsbGJhY2s7XG4gIGlmIChpc0RlZihleGlzdGluZykpIHtcbiAgICBpZiAoXG4gICAgICBBcnJheS5pc0FycmF5KGV4aXN0aW5nKVxuICAgICAgICA/IGV4aXN0aW5nLmluZGV4T2YoY2FsbGJhY2spID09PSAtMVxuICAgICAgICA6IGV4aXN0aW5nICE9PSBjYWxsYmFja1xuICAgICkge1xuICAgICAgb25bZXZlbnRdID0gW2NhbGxiYWNrXS5jb25jYXQoZXhpc3RpbmcpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBvbltldmVudF0gPSBjYWxsYmFjaztcbiAgfVxufVxuXG4vKiAgKi9cblxudmFyIFNJTVBMRV9OT1JNQUxJWkUgPSAxO1xudmFyIEFMV0FZU19OT1JNQUxJWkUgPSAyO1xuXG4vLyB3cmFwcGVyIGZ1bmN0aW9uIGZvciBwcm92aWRpbmcgYSBtb3JlIGZsZXhpYmxlIGludGVyZmFjZVxuLy8gd2l0aG91dCBnZXR0aW5nIHllbGxlZCBhdCBieSBmbG93XG5mdW5jdGlvbiBjcmVhdGVFbGVtZW50IChcbiAgY29udGV4dCxcbiAgdGFnLFxuICBkYXRhLFxuICBjaGlsZHJlbixcbiAgbm9ybWFsaXphdGlvblR5cGUsXG4gIGFsd2F5c05vcm1hbGl6ZVxuKSB7XG4gIGlmIChBcnJheS5pc0FycmF5KGRhdGEpIHx8IGlzUHJpbWl0aXZlKGRhdGEpKSB7XG4gICAgbm9ybWFsaXphdGlvblR5cGUgPSBjaGlsZHJlbjtcbiAgICBjaGlsZHJlbiA9IGRhdGE7XG4gICAgZGF0YSA9IHVuZGVmaW5lZDtcbiAgfVxuICBpZiAoaXNUcnVlKGFsd2F5c05vcm1hbGl6ZSkpIHtcbiAgICBub3JtYWxpemF0aW9uVHlwZSA9IEFMV0FZU19OT1JNQUxJWkU7XG4gIH1cbiAgcmV0dXJuIF9jcmVhdGVFbGVtZW50KGNvbnRleHQsIHRhZywgZGF0YSwgY2hpbGRyZW4sIG5vcm1hbGl6YXRpb25UeXBlKVxufVxuXG5mdW5jdGlvbiBfY3JlYXRlRWxlbWVudCAoXG4gIGNvbnRleHQsXG4gIHRhZyxcbiAgZGF0YSxcbiAgY2hpbGRyZW4sXG4gIG5vcm1hbGl6YXRpb25UeXBlXG4pIHtcbiAgaWYgKGlzRGVmKGRhdGEpICYmIGlzRGVmKChkYXRhKS5fX29iX18pKSB7XG4gICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiB3YXJuKFxuICAgICAgXCJBdm9pZCB1c2luZyBvYnNlcnZlZCBkYXRhIG9iamVjdCBhcyB2bm9kZSBkYXRhOiBcIiArIChKU09OLnN0cmluZ2lmeShkYXRhKSkgKyBcIlxcblwiICtcbiAgICAgICdBbHdheXMgY3JlYXRlIGZyZXNoIHZub2RlIGRhdGEgb2JqZWN0cyBpbiBlYWNoIHJlbmRlciEnLFxuICAgICAgY29udGV4dFxuICAgICk7XG4gICAgcmV0dXJuIGNyZWF0ZUVtcHR5Vk5vZGUoKVxuICB9XG4gIC8vIG9iamVjdCBzeW50YXggaW4gdi1iaW5kXG4gIGlmIChpc0RlZihkYXRhKSAmJiBpc0RlZihkYXRhLmlzKSkge1xuICAgIHRhZyA9IGRhdGEuaXM7XG4gIH1cbiAgaWYgKCF0YWcpIHtcbiAgICAvLyBpbiBjYXNlIG9mIGNvbXBvbmVudCA6aXMgc2V0IHRvIGZhbHN5IHZhbHVlXG4gICAgcmV0dXJuIGNyZWF0ZUVtcHR5Vk5vZGUoKVxuICB9XG4gIC8vIHdhcm4gYWdhaW5zdCBub24tcHJpbWl0aXZlIGtleVxuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJlxuICAgIGlzRGVmKGRhdGEpICYmIGlzRGVmKGRhdGEua2V5KSAmJiAhaXNQcmltaXRpdmUoZGF0YS5rZXkpXG4gICkge1xuICAgIHtcbiAgICAgIHdhcm4oXG4gICAgICAgICdBdm9pZCB1c2luZyBub24tcHJpbWl0aXZlIHZhbHVlIGFzIGtleSwgJyArXG4gICAgICAgICd1c2Ugc3RyaW5nL251bWJlciB2YWx1ZSBpbnN0ZWFkLicsXG4gICAgICAgIGNvbnRleHRcbiAgICAgICk7XG4gICAgfVxuICB9XG4gIC8vIHN1cHBvcnQgc2luZ2xlIGZ1bmN0aW9uIGNoaWxkcmVuIGFzIGRlZmF1bHQgc2NvcGVkIHNsb3RcbiAgaWYgKEFycmF5LmlzQXJyYXkoY2hpbGRyZW4pICYmXG4gICAgdHlwZW9mIGNoaWxkcmVuWzBdID09PSAnZnVuY3Rpb24nXG4gICkge1xuICAgIGRhdGEgPSBkYXRhIHx8IHt9O1xuICAgIGRhdGEuc2NvcGVkU2xvdHMgPSB7IGRlZmF1bHQ6IGNoaWxkcmVuWzBdIH07XG4gICAgY2hpbGRyZW4ubGVuZ3RoID0gMDtcbiAgfVxuICBpZiAobm9ybWFsaXphdGlvblR5cGUgPT09IEFMV0FZU19OT1JNQUxJWkUpIHtcbiAgICBjaGlsZHJlbiA9IG5vcm1hbGl6ZUNoaWxkcmVuKGNoaWxkcmVuKTtcbiAgfSBlbHNlIGlmIChub3JtYWxpemF0aW9uVHlwZSA9PT0gU0lNUExFX05PUk1BTElaRSkge1xuICAgIGNoaWxkcmVuID0gc2ltcGxlTm9ybWFsaXplQ2hpbGRyZW4oY2hpbGRyZW4pO1xuICB9XG4gIHZhciB2bm9kZSwgbnM7XG4gIGlmICh0eXBlb2YgdGFnID09PSAnc3RyaW5nJykge1xuICAgIHZhciBDdG9yO1xuICAgIG5zID0gKGNvbnRleHQuJHZub2RlICYmIGNvbnRleHQuJHZub2RlLm5zKSB8fCBjb25maWcuZ2V0VGFnTmFtZXNwYWNlKHRhZyk7XG4gICAgaWYgKGNvbmZpZy5pc1Jlc2VydmVkVGFnKHRhZykpIHtcbiAgICAgIC8vIHBsYXRmb3JtIGJ1aWx0LWluIGVsZW1lbnRzXG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiBpc0RlZihkYXRhKSAmJiBpc0RlZihkYXRhLm5hdGl2ZU9uKSAmJiBkYXRhLnRhZyAhPT0gJ2NvbXBvbmVudCcpIHtcbiAgICAgICAgd2FybihcbiAgICAgICAgICAoXCJUaGUgLm5hdGl2ZSBtb2RpZmllciBmb3Igdi1vbiBpcyBvbmx5IHZhbGlkIG9uIGNvbXBvbmVudHMgYnV0IGl0IHdhcyB1c2VkIG9uIDxcIiArIHRhZyArIFwiPi5cIiksXG4gICAgICAgICAgY29udGV4dFxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgdm5vZGUgPSBuZXcgVk5vZGUoXG4gICAgICAgIGNvbmZpZy5wYXJzZVBsYXRmb3JtVGFnTmFtZSh0YWcpLCBkYXRhLCBjaGlsZHJlbixcbiAgICAgICAgdW5kZWZpbmVkLCB1bmRlZmluZWQsIGNvbnRleHRcbiAgICAgICk7XG4gICAgfSBlbHNlIGlmICgoIWRhdGEgfHwgIWRhdGEucHJlKSAmJiBpc0RlZihDdG9yID0gcmVzb2x2ZUFzc2V0KGNvbnRleHQuJG9wdGlvbnMsICdjb21wb25lbnRzJywgdGFnKSkpIHtcbiAgICAgIC8vIGNvbXBvbmVudFxuICAgICAgdm5vZGUgPSBjcmVhdGVDb21wb25lbnQoQ3RvciwgZGF0YSwgY29udGV4dCwgY2hpbGRyZW4sIHRhZyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIHVua25vd24gb3IgdW5saXN0ZWQgbmFtZXNwYWNlZCBlbGVtZW50c1xuICAgICAgLy8gY2hlY2sgYXQgcnVudGltZSBiZWNhdXNlIGl0IG1heSBnZXQgYXNzaWduZWQgYSBuYW1lc3BhY2Ugd2hlbiBpdHNcbiAgICAgIC8vIHBhcmVudCBub3JtYWxpemVzIGNoaWxkcmVuXG4gICAgICB2bm9kZSA9IG5ldyBWTm9kZShcbiAgICAgICAgdGFnLCBkYXRhLCBjaGlsZHJlbixcbiAgICAgICAgdW5kZWZpbmVkLCB1bmRlZmluZWQsIGNvbnRleHRcbiAgICAgICk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIC8vIGRpcmVjdCBjb21wb25lbnQgb3B0aW9ucyAvIGNvbnN0cnVjdG9yXG4gICAgdm5vZGUgPSBjcmVhdGVDb21wb25lbnQodGFnLCBkYXRhLCBjb250ZXh0LCBjaGlsZHJlbik7XG4gIH1cbiAgaWYgKEFycmF5LmlzQXJyYXkodm5vZGUpKSB7XG4gICAgcmV0dXJuIHZub2RlXG4gIH0gZWxzZSBpZiAoaXNEZWYodm5vZGUpKSB7XG4gICAgaWYgKGlzRGVmKG5zKSkgeyBhcHBseU5TKHZub2RlLCBucyk7IH1cbiAgICBpZiAoaXNEZWYoZGF0YSkpIHsgcmVnaXN0ZXJEZWVwQmluZGluZ3MoZGF0YSk7IH1cbiAgICByZXR1cm4gdm5vZGVcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gY3JlYXRlRW1wdHlWTm9kZSgpXG4gIH1cbn1cblxuZnVuY3Rpb24gYXBwbHlOUyAodm5vZGUsIG5zLCBmb3JjZSkge1xuICB2bm9kZS5ucyA9IG5zO1xuICBpZiAodm5vZGUudGFnID09PSAnZm9yZWlnbk9iamVjdCcpIHtcbiAgICAvLyB1c2UgZGVmYXVsdCBuYW1lc3BhY2UgaW5zaWRlIGZvcmVpZ25PYmplY3RcbiAgICBucyA9IHVuZGVmaW5lZDtcbiAgICBmb3JjZSA9IHRydWU7XG4gIH1cbiAgaWYgKGlzRGVmKHZub2RlLmNoaWxkcmVuKSkge1xuICAgIGZvciAodmFyIGkgPSAwLCBsID0gdm5vZGUuY2hpbGRyZW4ubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICB2YXIgY2hpbGQgPSB2bm9kZS5jaGlsZHJlbltpXTtcbiAgICAgIGlmIChpc0RlZihjaGlsZC50YWcpICYmIChcbiAgICAgICAgaXNVbmRlZihjaGlsZC5ucykgfHwgKGlzVHJ1ZShmb3JjZSkgJiYgY2hpbGQudGFnICE9PSAnc3ZnJykpKSB7XG4gICAgICAgIGFwcGx5TlMoY2hpbGQsIG5zLCBmb3JjZSk7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbi8vIHJlZiAjNTMxOFxuLy8gbmVjZXNzYXJ5IHRvIGVuc3VyZSBwYXJlbnQgcmUtcmVuZGVyIHdoZW4gZGVlcCBiaW5kaW5ncyBsaWtlIDpzdHlsZSBhbmRcbi8vIDpjbGFzcyBhcmUgdXNlZCBvbiBzbG90IG5vZGVzXG5mdW5jdGlvbiByZWdpc3RlckRlZXBCaW5kaW5ncyAoZGF0YSkge1xuICBpZiAoaXNPYmplY3QoZGF0YS5zdHlsZSkpIHtcbiAgICB0cmF2ZXJzZShkYXRhLnN0eWxlKTtcbiAgfVxuICBpZiAoaXNPYmplY3QoZGF0YS5jbGFzcykpIHtcbiAgICB0cmF2ZXJzZShkYXRhLmNsYXNzKTtcbiAgfVxufVxuXG4vKiAgKi9cblxuZnVuY3Rpb24gaW5pdFJlbmRlciAodm0pIHtcbiAgdm0uX3Zub2RlID0gbnVsbDsgLy8gdGhlIHJvb3Qgb2YgdGhlIGNoaWxkIHRyZWVcbiAgdm0uX3N0YXRpY1RyZWVzID0gbnVsbDsgLy8gdi1vbmNlIGNhY2hlZCB0cmVlc1xuICB2YXIgb3B0aW9ucyA9IHZtLiRvcHRpb25zO1xuICB2YXIgcGFyZW50Vm5vZGUgPSB2bS4kdm5vZGUgPSBvcHRpb25zLl9wYXJlbnRWbm9kZTsgLy8gdGhlIHBsYWNlaG9sZGVyIG5vZGUgaW4gcGFyZW50IHRyZWVcbiAgdmFyIHJlbmRlckNvbnRleHQgPSBwYXJlbnRWbm9kZSAmJiBwYXJlbnRWbm9kZS5jb250ZXh0O1xuICB2bS4kc2xvdHMgPSByZXNvbHZlU2xvdHMob3B0aW9ucy5fcmVuZGVyQ2hpbGRyZW4sIHJlbmRlckNvbnRleHQpO1xuICB2bS4kc2NvcGVkU2xvdHMgPSBlbXB0eU9iamVjdDtcbiAgLy8gYmluZCB0aGUgY3JlYXRlRWxlbWVudCBmbiB0byB0aGlzIGluc3RhbmNlXG4gIC8vIHNvIHRoYXQgd2UgZ2V0IHByb3BlciByZW5kZXIgY29udGV4dCBpbnNpZGUgaXQuXG4gIC8vIGFyZ3Mgb3JkZXI6IHRhZywgZGF0YSwgY2hpbGRyZW4sIG5vcm1hbGl6YXRpb25UeXBlLCBhbHdheXNOb3JtYWxpemVcbiAgLy8gaW50ZXJuYWwgdmVyc2lvbiBpcyB1c2VkIGJ5IHJlbmRlciBmdW5jdGlvbnMgY29tcGlsZWQgZnJvbSB0ZW1wbGF0ZXNcbiAgdm0uX2MgPSBmdW5jdGlvbiAoYSwgYiwgYywgZCkgeyByZXR1cm4gY3JlYXRlRWxlbWVudCh2bSwgYSwgYiwgYywgZCwgZmFsc2UpOyB9O1xuICAvLyBub3JtYWxpemF0aW9uIGlzIGFsd2F5cyBhcHBsaWVkIGZvciB0aGUgcHVibGljIHZlcnNpb24sIHVzZWQgaW5cbiAgLy8gdXNlci13cml0dGVuIHJlbmRlciBmdW5jdGlvbnMuXG4gIHZtLiRjcmVhdGVFbGVtZW50ID0gZnVuY3Rpb24gKGEsIGIsIGMsIGQpIHsgcmV0dXJuIGNyZWF0ZUVsZW1lbnQodm0sIGEsIGIsIGMsIGQsIHRydWUpOyB9O1xuXG4gIC8vICRhdHRycyAmICRsaXN0ZW5lcnMgYXJlIGV4cG9zZWQgZm9yIGVhc2llciBIT0MgY3JlYXRpb24uXG4gIC8vIHRoZXkgbmVlZCB0byBiZSByZWFjdGl2ZSBzbyB0aGF0IEhPQ3MgdXNpbmcgdGhlbSBhcmUgYWx3YXlzIHVwZGF0ZWRcbiAgdmFyIHBhcmVudERhdGEgPSBwYXJlbnRWbm9kZSAmJiBwYXJlbnRWbm9kZS5kYXRhO1xuXG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgZGVmaW5lUmVhY3RpdmUkJDEodm0sICckYXR0cnMnLCBwYXJlbnREYXRhICYmIHBhcmVudERhdGEuYXR0cnMgfHwgZW1wdHlPYmplY3QsIGZ1bmN0aW9uICgpIHtcbiAgICAgICFpc1VwZGF0aW5nQ2hpbGRDb21wb25lbnQgJiYgd2FybihcIiRhdHRycyBpcyByZWFkb25seS5cIiwgdm0pO1xuICAgIH0sIHRydWUpO1xuICAgIGRlZmluZVJlYWN0aXZlJCQxKHZtLCAnJGxpc3RlbmVycycsIG9wdGlvbnMuX3BhcmVudExpc3RlbmVycyB8fCBlbXB0eU9iamVjdCwgZnVuY3Rpb24gKCkge1xuICAgICAgIWlzVXBkYXRpbmdDaGlsZENvbXBvbmVudCAmJiB3YXJuKFwiJGxpc3RlbmVycyBpcyByZWFkb25seS5cIiwgdm0pO1xuICAgIH0sIHRydWUpO1xuICB9IGVsc2Uge1xuICAgIGRlZmluZVJlYWN0aXZlJCQxKHZtLCAnJGF0dHJzJywgcGFyZW50RGF0YSAmJiBwYXJlbnREYXRhLmF0dHJzIHx8IGVtcHR5T2JqZWN0LCBudWxsLCB0cnVlKTtcbiAgICBkZWZpbmVSZWFjdGl2ZSQkMSh2bSwgJyRsaXN0ZW5lcnMnLCBvcHRpb25zLl9wYXJlbnRMaXN0ZW5lcnMgfHwgZW1wdHlPYmplY3QsIG51bGwsIHRydWUpO1xuICB9XG59XG5cbnZhciBjdXJyZW50UmVuZGVyaW5nSW5zdGFuY2UgPSBudWxsO1xuXG5mdW5jdGlvbiByZW5kZXJNaXhpbiAoVnVlKSB7XG4gIC8vIGluc3RhbGwgcnVudGltZSBjb252ZW5pZW5jZSBoZWxwZXJzXG4gIGluc3RhbGxSZW5kZXJIZWxwZXJzKFZ1ZS5wcm90b3R5cGUpO1xuXG4gIFZ1ZS5wcm90b3R5cGUuJG5leHRUaWNrID0gZnVuY3Rpb24gKGZuKSB7XG4gICAgcmV0dXJuIG5leHRUaWNrKGZuLCB0aGlzKVxuICB9O1xuXG4gIFZ1ZS5wcm90b3R5cGUuX3JlbmRlciA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgdm0gPSB0aGlzO1xuICAgIHZhciByZWYgPSB2bS4kb3B0aW9ucztcbiAgICB2YXIgcmVuZGVyID0gcmVmLnJlbmRlcjtcbiAgICB2YXIgX3BhcmVudFZub2RlID0gcmVmLl9wYXJlbnRWbm9kZTtcblxuICAgIGlmIChfcGFyZW50Vm5vZGUpIHtcbiAgICAgIHZtLiRzY29wZWRTbG90cyA9IG5vcm1hbGl6ZVNjb3BlZFNsb3RzKFxuICAgICAgICBfcGFyZW50Vm5vZGUuZGF0YS5zY29wZWRTbG90cyxcbiAgICAgICAgdm0uJHNsb3RzLFxuICAgICAgICB2bS4kc2NvcGVkU2xvdHNcbiAgICAgICk7XG4gICAgfVxuXG4gICAgLy8gc2V0IHBhcmVudCB2bm9kZS4gdGhpcyBhbGxvd3MgcmVuZGVyIGZ1bmN0aW9ucyB0byBoYXZlIGFjY2Vzc1xuICAgIC8vIHRvIHRoZSBkYXRhIG9uIHRoZSBwbGFjZWhvbGRlciBub2RlLlxuICAgIHZtLiR2bm9kZSA9IF9wYXJlbnRWbm9kZTtcbiAgICAvLyByZW5kZXIgc2VsZlxuICAgIHZhciB2bm9kZTtcbiAgICB0cnkge1xuICAgICAgLy8gVGhlcmUncyBubyBuZWVkIHRvIG1haW50YWluIGEgc3RhY2sgYmVjYXVzZSBhbGwgcmVuZGVyIGZucyBhcmUgY2FsbGVkXG4gICAgICAvLyBzZXBhcmF0ZWx5IGZyb20gb25lIGFub3RoZXIuIE5lc3RlZCBjb21wb25lbnQncyByZW5kZXIgZm5zIGFyZSBjYWxsZWRcbiAgICAgIC8vIHdoZW4gcGFyZW50IGNvbXBvbmVudCBpcyBwYXRjaGVkLlxuICAgICAgY3VycmVudFJlbmRlcmluZ0luc3RhbmNlID0gdm07XG4gICAgICB2bm9kZSA9IHJlbmRlci5jYWxsKHZtLl9yZW5kZXJQcm94eSwgdm0uJGNyZWF0ZUVsZW1lbnQpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGhhbmRsZUVycm9yKGUsIHZtLCBcInJlbmRlclwiKTtcbiAgICAgIC8vIHJldHVybiBlcnJvciByZW5kZXIgcmVzdWx0LFxuICAgICAgLy8gb3IgcHJldmlvdXMgdm5vZGUgdG8gcHJldmVudCByZW5kZXIgZXJyb3IgY2F1c2luZyBibGFuayBjb21wb25lbnRcbiAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiB2bS4kb3B0aW9ucy5yZW5kZXJFcnJvcikge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIHZub2RlID0gdm0uJG9wdGlvbnMucmVuZGVyRXJyb3IuY2FsbCh2bS5fcmVuZGVyUHJveHksIHZtLiRjcmVhdGVFbGVtZW50LCBlKTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgIGhhbmRsZUVycm9yKGUsIHZtLCBcInJlbmRlckVycm9yXCIpO1xuICAgICAgICAgIHZub2RlID0gdm0uX3Zub2RlO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2bm9kZSA9IHZtLl92bm9kZTtcbiAgICAgIH1cbiAgICB9IGZpbmFsbHkge1xuICAgICAgY3VycmVudFJlbmRlcmluZ0luc3RhbmNlID0gbnVsbDtcbiAgICB9XG4gICAgLy8gaWYgdGhlIHJldHVybmVkIGFycmF5IGNvbnRhaW5zIG9ubHkgYSBzaW5nbGUgbm9kZSwgYWxsb3cgaXRcbiAgICBpZiAoQXJyYXkuaXNBcnJheSh2bm9kZSkgJiYgdm5vZGUubGVuZ3RoID09PSAxKSB7XG4gICAgICB2bm9kZSA9IHZub2RlWzBdO1xuICAgIH1cbiAgICAvLyByZXR1cm4gZW1wdHkgdm5vZGUgaW4gY2FzZSB0aGUgcmVuZGVyIGZ1bmN0aW9uIGVycm9yZWQgb3V0XG4gICAgaWYgKCEodm5vZGUgaW5zdGFuY2VvZiBWTm9kZSkpIHtcbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIEFycmF5LmlzQXJyYXkodm5vZGUpKSB7XG4gICAgICAgIHdhcm4oXG4gICAgICAgICAgJ011bHRpcGxlIHJvb3Qgbm9kZXMgcmV0dXJuZWQgZnJvbSByZW5kZXIgZnVuY3Rpb24uIFJlbmRlciBmdW5jdGlvbiAnICtcbiAgICAgICAgICAnc2hvdWxkIHJldHVybiBhIHNpbmdsZSByb290IG5vZGUuJyxcbiAgICAgICAgICB2bVxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgdm5vZGUgPSBjcmVhdGVFbXB0eVZOb2RlKCk7XG4gICAgfVxuICAgIC8vIHNldCBwYXJlbnRcbiAgICB2bm9kZS5wYXJlbnQgPSBfcGFyZW50Vm5vZGU7XG4gICAgcmV0dXJuIHZub2RlXG4gIH07XG59XG5cbi8qICAqL1xuXG5mdW5jdGlvbiBlbnN1cmVDdG9yIChjb21wLCBiYXNlKSB7XG4gIGlmIChcbiAgICBjb21wLl9fZXNNb2R1bGUgfHxcbiAgICAoaGFzU3ltYm9sICYmIGNvbXBbU3ltYm9sLnRvU3RyaW5nVGFnXSA9PT0gJ01vZHVsZScpXG4gICkge1xuICAgIGNvbXAgPSBjb21wLmRlZmF1bHQ7XG4gIH1cbiAgcmV0dXJuIGlzT2JqZWN0KGNvbXApXG4gICAgPyBiYXNlLmV4dGVuZChjb21wKVxuICAgIDogY29tcFxufVxuXG5mdW5jdGlvbiBjcmVhdGVBc3luY1BsYWNlaG9sZGVyIChcbiAgZmFjdG9yeSxcbiAgZGF0YSxcbiAgY29udGV4dCxcbiAgY2hpbGRyZW4sXG4gIHRhZ1xuKSB7XG4gIHZhciBub2RlID0gY3JlYXRlRW1wdHlWTm9kZSgpO1xuICBub2RlLmFzeW5jRmFjdG9yeSA9IGZhY3Rvcnk7XG4gIG5vZGUuYXN5bmNNZXRhID0geyBkYXRhOiBkYXRhLCBjb250ZXh0OiBjb250ZXh0LCBjaGlsZHJlbjogY2hpbGRyZW4sIHRhZzogdGFnIH07XG4gIHJldHVybiBub2RlXG59XG5cbmZ1bmN0aW9uIHJlc29sdmVBc3luY0NvbXBvbmVudCAoXG4gIGZhY3RvcnksXG4gIGJhc2VDdG9yXG4pIHtcbiAgaWYgKGlzVHJ1ZShmYWN0b3J5LmVycm9yKSAmJiBpc0RlZihmYWN0b3J5LmVycm9yQ29tcCkpIHtcbiAgICByZXR1cm4gZmFjdG9yeS5lcnJvckNvbXBcbiAgfVxuXG4gIGlmIChpc0RlZihmYWN0b3J5LnJlc29sdmVkKSkge1xuICAgIHJldHVybiBmYWN0b3J5LnJlc29sdmVkXG4gIH1cblxuICB2YXIgb3duZXIgPSBjdXJyZW50UmVuZGVyaW5nSW5zdGFuY2U7XG4gIGlmIChvd25lciAmJiBpc0RlZihmYWN0b3J5Lm93bmVycykgJiYgZmFjdG9yeS5vd25lcnMuaW5kZXhPZihvd25lcikgPT09IC0xKSB7XG4gICAgLy8gYWxyZWFkeSBwZW5kaW5nXG4gICAgZmFjdG9yeS5vd25lcnMucHVzaChvd25lcik7XG4gIH1cblxuICBpZiAoaXNUcnVlKGZhY3RvcnkubG9hZGluZykgJiYgaXNEZWYoZmFjdG9yeS5sb2FkaW5nQ29tcCkpIHtcbiAgICByZXR1cm4gZmFjdG9yeS5sb2FkaW5nQ29tcFxuICB9XG5cbiAgaWYgKG93bmVyICYmICFpc0RlZihmYWN0b3J5Lm93bmVycykpIHtcbiAgICB2YXIgb3duZXJzID0gZmFjdG9yeS5vd25lcnMgPSBbb3duZXJdO1xuICAgIHZhciBzeW5jID0gdHJ1ZTtcbiAgICB2YXIgdGltZXJMb2FkaW5nID0gbnVsbDtcbiAgICB2YXIgdGltZXJUaW1lb3V0ID0gbnVsbFxuXG4gICAgOyhvd25lcikuJG9uKCdob29rOmRlc3Ryb3llZCcsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIHJlbW92ZShvd25lcnMsIG93bmVyKTsgfSk7XG5cbiAgICB2YXIgZm9yY2VSZW5kZXIgPSBmdW5jdGlvbiAocmVuZGVyQ29tcGxldGVkKSB7XG4gICAgICBmb3IgKHZhciBpID0gMCwgbCA9IG93bmVycy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgKG93bmVyc1tpXSkuJGZvcmNlVXBkYXRlKCk7XG4gICAgICB9XG5cbiAgICAgIGlmIChyZW5kZXJDb21wbGV0ZWQpIHtcbiAgICAgICAgb3duZXJzLmxlbmd0aCA9IDA7XG4gICAgICAgIGlmICh0aW1lckxvYWRpbmcgIT09IG51bGwpIHtcbiAgICAgICAgICBjbGVhclRpbWVvdXQodGltZXJMb2FkaW5nKTtcbiAgICAgICAgICB0aW1lckxvYWRpbmcgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aW1lclRpbWVvdXQgIT09IG51bGwpIHtcbiAgICAgICAgICBjbGVhclRpbWVvdXQodGltZXJUaW1lb3V0KTtcbiAgICAgICAgICB0aW1lclRpbWVvdXQgPSBudWxsO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcblxuICAgIHZhciByZXNvbHZlID0gb25jZShmdW5jdGlvbiAocmVzKSB7XG4gICAgICAvLyBjYWNoZSByZXNvbHZlZFxuICAgICAgZmFjdG9yeS5yZXNvbHZlZCA9IGVuc3VyZUN0b3IocmVzLCBiYXNlQ3Rvcik7XG4gICAgICAvLyBpbnZva2UgY2FsbGJhY2tzIG9ubHkgaWYgdGhpcyBpcyBub3QgYSBzeW5jaHJvbm91cyByZXNvbHZlXG4gICAgICAvLyAoYXN5bmMgcmVzb2x2ZXMgYXJlIHNoaW1tZWQgYXMgc3luY2hyb25vdXMgZHVyaW5nIFNTUilcbiAgICAgIGlmICghc3luYykge1xuICAgICAgICBmb3JjZVJlbmRlcih0cnVlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG93bmVycy5sZW5ndGggPSAwO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgdmFyIHJlamVjdCA9IG9uY2UoZnVuY3Rpb24gKHJlYXNvbikge1xuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiB3YXJuKFxuICAgICAgICBcIkZhaWxlZCB0byByZXNvbHZlIGFzeW5jIGNvbXBvbmVudDogXCIgKyAoU3RyaW5nKGZhY3RvcnkpKSArXG4gICAgICAgIChyZWFzb24gPyAoXCJcXG5SZWFzb246IFwiICsgcmVhc29uKSA6ICcnKVxuICAgICAgKTtcbiAgICAgIGlmIChpc0RlZihmYWN0b3J5LmVycm9yQ29tcCkpIHtcbiAgICAgICAgZmFjdG9yeS5lcnJvciA9IHRydWU7XG4gICAgICAgIGZvcmNlUmVuZGVyKHRydWUpO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgdmFyIHJlcyA9IGZhY3RvcnkocmVzb2x2ZSwgcmVqZWN0KTtcblxuICAgIGlmIChpc09iamVjdChyZXMpKSB7XG4gICAgICBpZiAoaXNQcm9taXNlKHJlcykpIHtcbiAgICAgICAgLy8gKCkgPT4gUHJvbWlzZVxuICAgICAgICBpZiAoaXNVbmRlZihmYWN0b3J5LnJlc29sdmVkKSkge1xuICAgICAgICAgIHJlcy50aGVuKHJlc29sdmUsIHJlamVjdCk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoaXNQcm9taXNlKHJlcy5jb21wb25lbnQpKSB7XG4gICAgICAgIHJlcy5jb21wb25lbnQudGhlbihyZXNvbHZlLCByZWplY3QpO1xuXG4gICAgICAgIGlmIChpc0RlZihyZXMuZXJyb3IpKSB7XG4gICAgICAgICAgZmFjdG9yeS5lcnJvckNvbXAgPSBlbnN1cmVDdG9yKHJlcy5lcnJvciwgYmFzZUN0b3IpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGlzRGVmKHJlcy5sb2FkaW5nKSkge1xuICAgICAgICAgIGZhY3RvcnkubG9hZGluZ0NvbXAgPSBlbnN1cmVDdG9yKHJlcy5sb2FkaW5nLCBiYXNlQ3Rvcik7XG4gICAgICAgICAgaWYgKHJlcy5kZWxheSA9PT0gMCkge1xuICAgICAgICAgICAgZmFjdG9yeS5sb2FkaW5nID0gdHJ1ZTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGltZXJMb2FkaW5nID0gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgIHRpbWVyTG9hZGluZyA9IG51bGw7XG4gICAgICAgICAgICAgIGlmIChpc1VuZGVmKGZhY3RvcnkucmVzb2x2ZWQpICYmIGlzVW5kZWYoZmFjdG9yeS5lcnJvcikpIHtcbiAgICAgICAgICAgICAgICBmYWN0b3J5LmxvYWRpbmcgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGZvcmNlUmVuZGVyKGZhbHNlKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwgcmVzLmRlbGF5IHx8IDIwMCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGlzRGVmKHJlcy50aW1lb3V0KSkge1xuICAgICAgICAgIHRpbWVyVGltZW91dCA9IHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdGltZXJUaW1lb3V0ID0gbnVsbDtcbiAgICAgICAgICAgIGlmIChpc1VuZGVmKGZhY3RvcnkucmVzb2x2ZWQpKSB7XG4gICAgICAgICAgICAgIHJlamVjdChcbiAgICAgICAgICAgICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nXG4gICAgICAgICAgICAgICAgICA/IChcInRpbWVvdXQgKFwiICsgKHJlcy50aW1lb3V0KSArIFwibXMpXCIpXG4gICAgICAgICAgICAgICAgICA6IG51bGxcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9LCByZXMudGltZW91dCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBzeW5jID0gZmFsc2U7XG4gICAgLy8gcmV0dXJuIGluIGNhc2UgcmVzb2x2ZWQgc3luY2hyb25vdXNseVxuICAgIHJldHVybiBmYWN0b3J5LmxvYWRpbmdcbiAgICAgID8gZmFjdG9yeS5sb2FkaW5nQ29tcFxuICAgICAgOiBmYWN0b3J5LnJlc29sdmVkXG4gIH1cbn1cblxuLyogICovXG5cbmZ1bmN0aW9uIGdldEZpcnN0Q29tcG9uZW50Q2hpbGQgKGNoaWxkcmVuKSB7XG4gIGlmIChBcnJheS5pc0FycmF5KGNoaWxkcmVuKSkge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBjID0gY2hpbGRyZW5baV07XG4gICAgICBpZiAoaXNEZWYoYykgJiYgKGlzRGVmKGMuY29tcG9uZW50T3B0aW9ucykgfHwgaXNBc3luY1BsYWNlaG9sZGVyKGMpKSkge1xuICAgICAgICByZXR1cm4gY1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG4vKiAgKi9cblxuLyogICovXG5cbmZ1bmN0aW9uIGluaXRFdmVudHMgKHZtKSB7XG4gIHZtLl9ldmVudHMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICB2bS5faGFzSG9va0V2ZW50ID0gZmFsc2U7XG4gIC8vIGluaXQgcGFyZW50IGF0dGFjaGVkIGV2ZW50c1xuICB2YXIgbGlzdGVuZXJzID0gdm0uJG9wdGlvbnMuX3BhcmVudExpc3RlbmVycztcbiAgaWYgKGxpc3RlbmVycykge1xuICAgIHVwZGF0ZUNvbXBvbmVudExpc3RlbmVycyh2bSwgbGlzdGVuZXJzKTtcbiAgfVxufVxuXG52YXIgdGFyZ2V0O1xuXG5mdW5jdGlvbiBhZGQgKGV2ZW50LCBmbikge1xuICB0YXJnZXQuJG9uKGV2ZW50LCBmbik7XG59XG5cbmZ1bmN0aW9uIHJlbW92ZSQxIChldmVudCwgZm4pIHtcbiAgdGFyZ2V0LiRvZmYoZXZlbnQsIGZuKTtcbn1cblxuZnVuY3Rpb24gY3JlYXRlT25jZUhhbmRsZXIgKGV2ZW50LCBmbikge1xuICB2YXIgX3RhcmdldCA9IHRhcmdldDtcbiAgcmV0dXJuIGZ1bmN0aW9uIG9uY2VIYW5kbGVyICgpIHtcbiAgICB2YXIgcmVzID0gZm4uYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbiAgICBpZiAocmVzICE9PSBudWxsKSB7XG4gICAgICBfdGFyZ2V0LiRvZmYoZXZlbnQsIG9uY2VIYW5kbGVyKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gdXBkYXRlQ29tcG9uZW50TGlzdGVuZXJzIChcbiAgdm0sXG4gIGxpc3RlbmVycyxcbiAgb2xkTGlzdGVuZXJzXG4pIHtcbiAgdGFyZ2V0ID0gdm07XG4gIHVwZGF0ZUxpc3RlbmVycyhsaXN0ZW5lcnMsIG9sZExpc3RlbmVycyB8fCB7fSwgYWRkLCByZW1vdmUkMSwgY3JlYXRlT25jZUhhbmRsZXIsIHZtKTtcbiAgdGFyZ2V0ID0gdW5kZWZpbmVkO1xufVxuXG5mdW5jdGlvbiBldmVudHNNaXhpbiAoVnVlKSB7XG4gIHZhciBob29rUkUgPSAvXmhvb2s6LztcbiAgVnVlLnByb3RvdHlwZS4kb24gPSBmdW5jdGlvbiAoZXZlbnQsIGZuKSB7XG4gICAgdmFyIHZtID0gdGhpcztcbiAgICBpZiAoQXJyYXkuaXNBcnJheShldmVudCkpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gZXZlbnQubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgIHZtLiRvbihldmVudFtpXSwgZm4pO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAodm0uX2V2ZW50c1tldmVudF0gfHwgKHZtLl9ldmVudHNbZXZlbnRdID0gW10pKS5wdXNoKGZuKTtcbiAgICAgIC8vIG9wdGltaXplIGhvb2s6ZXZlbnQgY29zdCBieSB1c2luZyBhIGJvb2xlYW4gZmxhZyBtYXJrZWQgYXQgcmVnaXN0cmF0aW9uXG4gICAgICAvLyBpbnN0ZWFkIG9mIGEgaGFzaCBsb29rdXBcbiAgICAgIGlmIChob29rUkUudGVzdChldmVudCkpIHtcbiAgICAgICAgdm0uX2hhc0hvb2tFdmVudCA9IHRydWU7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB2bVxuICB9O1xuXG4gIFZ1ZS5wcm90b3R5cGUuJG9uY2UgPSBmdW5jdGlvbiAoZXZlbnQsIGZuKSB7XG4gICAgdmFyIHZtID0gdGhpcztcbiAgICBmdW5jdGlvbiBvbiAoKSB7XG4gICAgICB2bS4kb2ZmKGV2ZW50LCBvbik7XG4gICAgICBmbi5hcHBseSh2bSwgYXJndW1lbnRzKTtcbiAgICB9XG4gICAgb24uZm4gPSBmbjtcbiAgICB2bS4kb24oZXZlbnQsIG9uKTtcbiAgICByZXR1cm4gdm1cbiAgfTtcblxuICBWdWUucHJvdG90eXBlLiRvZmYgPSBmdW5jdGlvbiAoZXZlbnQsIGZuKSB7XG4gICAgdmFyIHZtID0gdGhpcztcbiAgICAvLyBhbGxcbiAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICAgIHZtLl9ldmVudHMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgICAgcmV0dXJuIHZtXG4gICAgfVxuICAgIC8vIGFycmF5IG9mIGV2ZW50c1xuICAgIGlmIChBcnJheS5pc0FycmF5KGV2ZW50KSkge1xuICAgICAgZm9yICh2YXIgaSQxID0gMCwgbCA9IGV2ZW50Lmxlbmd0aDsgaSQxIDwgbDsgaSQxKyspIHtcbiAgICAgICAgdm0uJG9mZihldmVudFtpJDFdLCBmbik7XG4gICAgICB9XG4gICAgICByZXR1cm4gdm1cbiAgICB9XG4gICAgLy8gc3BlY2lmaWMgZXZlbnRcbiAgICB2YXIgY2JzID0gdm0uX2V2ZW50c1tldmVudF07XG4gICAgaWYgKCFjYnMpIHtcbiAgICAgIHJldHVybiB2bVxuICAgIH1cbiAgICBpZiAoIWZuKSB7XG4gICAgICB2bS5fZXZlbnRzW2V2ZW50XSA9IG51bGw7XG4gICAgICByZXR1cm4gdm1cbiAgICB9XG4gICAgLy8gc3BlY2lmaWMgaGFuZGxlclxuICAgIHZhciBjYjtcbiAgICB2YXIgaSA9IGNicy5sZW5ndGg7XG4gICAgd2hpbGUgKGktLSkge1xuICAgICAgY2IgPSBjYnNbaV07XG4gICAgICBpZiAoY2IgPT09IGZuIHx8IGNiLmZuID09PSBmbikge1xuICAgICAgICBjYnMuc3BsaWNlKGksIDEpO1xuICAgICAgICBicmVha1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdm1cbiAgfTtcblxuICBWdWUucHJvdG90eXBlLiRlbWl0ID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgdmFyIHZtID0gdGhpcztcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgdmFyIGxvd2VyQ2FzZUV2ZW50ID0gZXZlbnQudG9Mb3dlckNhc2UoKTtcbiAgICAgIGlmIChsb3dlckNhc2VFdmVudCAhPT0gZXZlbnQgJiYgdm0uX2V2ZW50c1tsb3dlckNhc2VFdmVudF0pIHtcbiAgICAgICAgdGlwKFxuICAgICAgICAgIFwiRXZlbnQgXFxcIlwiICsgbG93ZXJDYXNlRXZlbnQgKyBcIlxcXCIgaXMgZW1pdHRlZCBpbiBjb21wb25lbnQgXCIgK1xuICAgICAgICAgIChmb3JtYXRDb21wb25lbnROYW1lKHZtKSkgKyBcIiBidXQgdGhlIGhhbmRsZXIgaXMgcmVnaXN0ZXJlZCBmb3IgXFxcIlwiICsgZXZlbnQgKyBcIlxcXCIuIFwiICtcbiAgICAgICAgICBcIk5vdGUgdGhhdCBIVE1MIGF0dHJpYnV0ZXMgYXJlIGNhc2UtaW5zZW5zaXRpdmUgYW5kIHlvdSBjYW5ub3QgdXNlIFwiICtcbiAgICAgICAgICBcInYtb24gdG8gbGlzdGVuIHRvIGNhbWVsQ2FzZSBldmVudHMgd2hlbiB1c2luZyBpbi1ET00gdGVtcGxhdGVzLiBcIiArXG4gICAgICAgICAgXCJZb3Ugc2hvdWxkIHByb2JhYmx5IHVzZSBcXFwiXCIgKyAoaHlwaGVuYXRlKGV2ZW50KSkgKyBcIlxcXCIgaW5zdGVhZCBvZiBcXFwiXCIgKyBldmVudCArIFwiXFxcIi5cIlxuICAgICAgICApO1xuICAgICAgfVxuICAgIH1cbiAgICB2YXIgY2JzID0gdm0uX2V2ZW50c1tldmVudF07XG4gICAgaWYgKGNicykge1xuICAgICAgY2JzID0gY2JzLmxlbmd0aCA+IDEgPyB0b0FycmF5KGNicykgOiBjYnM7XG4gICAgICB2YXIgYXJncyA9IHRvQXJyYXkoYXJndW1lbnRzLCAxKTtcbiAgICAgIHZhciBpbmZvID0gXCJldmVudCBoYW5kbGVyIGZvciBcXFwiXCIgKyBldmVudCArIFwiXFxcIlwiO1xuICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSBjYnMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgIGludm9rZVdpdGhFcnJvckhhbmRsaW5nKGNic1tpXSwgdm0sIGFyZ3MsIHZtLCBpbmZvKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHZtXG4gIH07XG59XG5cbi8qICAqL1xuXG52YXIgYWN0aXZlSW5zdGFuY2UgPSBudWxsO1xudmFyIGlzVXBkYXRpbmdDaGlsZENvbXBvbmVudCA9IGZhbHNlO1xuXG5mdW5jdGlvbiBzZXRBY3RpdmVJbnN0YW5jZSh2bSkge1xuICB2YXIgcHJldkFjdGl2ZUluc3RhbmNlID0gYWN0aXZlSW5zdGFuY2U7XG4gIGFjdGl2ZUluc3RhbmNlID0gdm07XG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgYWN0aXZlSW5zdGFuY2UgPSBwcmV2QWN0aXZlSW5zdGFuY2U7XG4gIH1cbn1cblxuZnVuY3Rpb24gaW5pdExpZmVjeWNsZSAodm0pIHtcbiAgdmFyIG9wdGlvbnMgPSB2bS4kb3B0aW9ucztcblxuICAvLyBsb2NhdGUgZmlyc3Qgbm9uLWFic3RyYWN0IHBhcmVudFxuICB2YXIgcGFyZW50ID0gb3B0aW9ucy5wYXJlbnQ7XG4gIGlmIChwYXJlbnQgJiYgIW9wdGlvbnMuYWJzdHJhY3QpIHtcbiAgICB3aGlsZSAocGFyZW50LiRvcHRpb25zLmFic3RyYWN0ICYmIHBhcmVudC4kcGFyZW50KSB7XG4gICAgICBwYXJlbnQgPSBwYXJlbnQuJHBhcmVudDtcbiAgICB9XG4gICAgcGFyZW50LiRjaGlsZHJlbi5wdXNoKHZtKTtcbiAgfVxuXG4gIHZtLiRwYXJlbnQgPSBwYXJlbnQ7XG4gIHZtLiRyb290ID0gcGFyZW50ID8gcGFyZW50LiRyb290IDogdm07XG5cbiAgdm0uJGNoaWxkcmVuID0gW107XG4gIHZtLiRyZWZzID0ge307XG5cbiAgdm0uX3dhdGNoZXIgPSBudWxsO1xuICB2bS5faW5hY3RpdmUgPSBudWxsO1xuICB2bS5fZGlyZWN0SW5hY3RpdmUgPSBmYWxzZTtcbiAgdm0uX2lzTW91bnRlZCA9IGZhbHNlO1xuICB2bS5faXNEZXN0cm95ZWQgPSBmYWxzZTtcbiAgdm0uX2lzQmVpbmdEZXN0cm95ZWQgPSBmYWxzZTtcbn1cblxuZnVuY3Rpb24gbGlmZWN5Y2xlTWl4aW4gKFZ1ZSkge1xuICBWdWUucHJvdG90eXBlLl91cGRhdGUgPSBmdW5jdGlvbiAodm5vZGUsIGh5ZHJhdGluZykge1xuICAgIHZhciB2bSA9IHRoaXM7XG4gICAgdmFyIHByZXZFbCA9IHZtLiRlbDtcbiAgICB2YXIgcHJldlZub2RlID0gdm0uX3Zub2RlO1xuICAgIHZhciByZXN0b3JlQWN0aXZlSW5zdGFuY2UgPSBzZXRBY3RpdmVJbnN0YW5jZSh2bSk7XG4gICAgdm0uX3Zub2RlID0gdm5vZGU7XG4gICAgLy8gVnVlLnByb3RvdHlwZS5fX3BhdGNoX18gaXMgaW5qZWN0ZWQgaW4gZW50cnkgcG9pbnRzXG4gICAgLy8gYmFzZWQgb24gdGhlIHJlbmRlcmluZyBiYWNrZW5kIHVzZWQuXG4gICAgaWYgKCFwcmV2Vm5vZGUpIHtcbiAgICAgIC8vIGluaXRpYWwgcmVuZGVyXG4gICAgICB2bS4kZWwgPSB2bS5fX3BhdGNoX18odm0uJGVsLCB2bm9kZSwgaHlkcmF0aW5nLCBmYWxzZSAvKiByZW1vdmVPbmx5ICovKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gdXBkYXRlc1xuICAgICAgdm0uJGVsID0gdm0uX19wYXRjaF9fKHByZXZWbm9kZSwgdm5vZGUpO1xuICAgIH1cbiAgICByZXN0b3JlQWN0aXZlSW5zdGFuY2UoKTtcbiAgICAvLyB1cGRhdGUgX192dWVfXyByZWZlcmVuY2VcbiAgICBpZiAocHJldkVsKSB7XG4gICAgICBwcmV2RWwuX192dWVfXyA9IG51bGw7XG4gICAgfVxuICAgIGlmICh2bS4kZWwpIHtcbiAgICAgIHZtLiRlbC5fX3Z1ZV9fID0gdm07XG4gICAgfVxuICAgIC8vIGlmIHBhcmVudCBpcyBhbiBIT0MsIHVwZGF0ZSBpdHMgJGVsIGFzIHdlbGxcbiAgICBpZiAodm0uJHZub2RlICYmIHZtLiRwYXJlbnQgJiYgdm0uJHZub2RlID09PSB2bS4kcGFyZW50Ll92bm9kZSkge1xuICAgICAgdm0uJHBhcmVudC4kZWwgPSB2bS4kZWw7XG4gICAgfVxuICAgIC8vIHVwZGF0ZWQgaG9vayBpcyBjYWxsZWQgYnkgdGhlIHNjaGVkdWxlciB0byBlbnN1cmUgdGhhdCBjaGlsZHJlbiBhcmVcbiAgICAvLyB1cGRhdGVkIGluIGEgcGFyZW50J3MgdXBkYXRlZCBob29rLlxuICB9O1xuXG4gIFZ1ZS5wcm90b3R5cGUuJGZvcmNlVXBkYXRlID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciB2bSA9IHRoaXM7XG4gICAgaWYgKHZtLl93YXRjaGVyKSB7XG4gICAgICB2bS5fd2F0Y2hlci51cGRhdGUoKTtcbiAgICB9XG4gIH07XG5cbiAgVnVlLnByb3RvdHlwZS4kZGVzdHJveSA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgdm0gPSB0aGlzO1xuICAgIGlmICh2bS5faXNCZWluZ0Rlc3Ryb3llZCkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuICAgIGNhbGxIb29rKHZtLCAnYmVmb3JlRGVzdHJveScpO1xuICAgIHZtLl9pc0JlaW5nRGVzdHJveWVkID0gdHJ1ZTtcbiAgICAvLyByZW1vdmUgc2VsZiBmcm9tIHBhcmVudFxuICAgIHZhciBwYXJlbnQgPSB2bS4kcGFyZW50O1xuICAgIGlmIChwYXJlbnQgJiYgIXBhcmVudC5faXNCZWluZ0Rlc3Ryb3llZCAmJiAhdm0uJG9wdGlvbnMuYWJzdHJhY3QpIHtcbiAgICAgIHJlbW92ZShwYXJlbnQuJGNoaWxkcmVuLCB2bSk7XG4gICAgfVxuICAgIC8vIHRlYXJkb3duIHdhdGNoZXJzXG4gICAgaWYgKHZtLl93YXRjaGVyKSB7XG4gICAgICB2bS5fd2F0Y2hlci50ZWFyZG93bigpO1xuICAgIH1cbiAgICB2YXIgaSA9IHZtLl93YXRjaGVycy5sZW5ndGg7XG4gICAgd2hpbGUgKGktLSkge1xuICAgICAgdm0uX3dhdGNoZXJzW2ldLnRlYXJkb3duKCk7XG4gICAgfVxuICAgIC8vIHJlbW92ZSByZWZlcmVuY2UgZnJvbSBkYXRhIG9iXG4gICAgLy8gZnJvemVuIG9iamVjdCBtYXkgbm90IGhhdmUgb2JzZXJ2ZXIuXG4gICAgaWYgKHZtLl9kYXRhLl9fb2JfXykge1xuICAgICAgdm0uX2RhdGEuX19vYl9fLnZtQ291bnQtLTtcbiAgICB9XG4gICAgLy8gY2FsbCB0aGUgbGFzdCBob29rLi4uXG4gICAgdm0uX2lzRGVzdHJveWVkID0gdHJ1ZTtcbiAgICAvLyBpbnZva2UgZGVzdHJveSBob29rcyBvbiBjdXJyZW50IHJlbmRlcmVkIHRyZWVcbiAgICB2bS5fX3BhdGNoX18odm0uX3Zub2RlLCBudWxsKTtcbiAgICAvLyBmaXJlIGRlc3Ryb3llZCBob29rXG4gICAgY2FsbEhvb2sodm0sICdkZXN0cm95ZWQnKTtcbiAgICAvLyB0dXJuIG9mZiBhbGwgaW5zdGFuY2UgbGlzdGVuZXJzLlxuICAgIHZtLiRvZmYoKTtcbiAgICAvLyByZW1vdmUgX192dWVfXyByZWZlcmVuY2VcbiAgICBpZiAodm0uJGVsKSB7XG4gICAgICB2bS4kZWwuX192dWVfXyA9IG51bGw7XG4gICAgfVxuICAgIC8vIHJlbGVhc2UgY2lyY3VsYXIgcmVmZXJlbmNlICgjNjc1OSlcbiAgICBpZiAodm0uJHZub2RlKSB7XG4gICAgICB2bS4kdm5vZGUucGFyZW50ID0gbnVsbDtcbiAgICB9XG4gIH07XG59XG5cbmZ1bmN0aW9uIG1vdW50Q29tcG9uZW50IChcbiAgdm0sXG4gIGVsLFxuICBoeWRyYXRpbmdcbikge1xuICB2bS4kZWwgPSBlbDtcbiAgaWYgKCF2bS4kb3B0aW9ucy5yZW5kZXIpIHtcbiAgICB2bS4kb3B0aW9ucy5yZW5kZXIgPSBjcmVhdGVFbXB0eVZOb2RlO1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgIGlmICgodm0uJG9wdGlvbnMudGVtcGxhdGUgJiYgdm0uJG9wdGlvbnMudGVtcGxhdGUuY2hhckF0KDApICE9PSAnIycpIHx8XG4gICAgICAgIHZtLiRvcHRpb25zLmVsIHx8IGVsKSB7XG4gICAgICAgIHdhcm4oXG4gICAgICAgICAgJ1lvdSBhcmUgdXNpbmcgdGhlIHJ1bnRpbWUtb25seSBidWlsZCBvZiBWdWUgd2hlcmUgdGhlIHRlbXBsYXRlICcgK1xuICAgICAgICAgICdjb21waWxlciBpcyBub3QgYXZhaWxhYmxlLiBFaXRoZXIgcHJlLWNvbXBpbGUgdGhlIHRlbXBsYXRlcyBpbnRvICcgK1xuICAgICAgICAgICdyZW5kZXIgZnVuY3Rpb25zLCBvciB1c2UgdGhlIGNvbXBpbGVyLWluY2x1ZGVkIGJ1aWxkLicsXG4gICAgICAgICAgdm1cbiAgICAgICAgKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHdhcm4oXG4gICAgICAgICAgJ0ZhaWxlZCB0byBtb3VudCBjb21wb25lbnQ6IHRlbXBsYXRlIG9yIHJlbmRlciBmdW5jdGlvbiBub3QgZGVmaW5lZC4nLFxuICAgICAgICAgIHZtXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGNhbGxIb29rKHZtLCAnYmVmb3JlTW91bnQnKTtcblxuICB2YXIgdXBkYXRlQ29tcG9uZW50O1xuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgY29uZmlnLnBlcmZvcm1hbmNlICYmIG1hcmspIHtcbiAgICB1cGRhdGVDb21wb25lbnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgbmFtZSA9IHZtLl9uYW1lO1xuICAgICAgdmFyIGlkID0gdm0uX3VpZDtcbiAgICAgIHZhciBzdGFydFRhZyA9IFwidnVlLXBlcmYtc3RhcnQ6XCIgKyBpZDtcbiAgICAgIHZhciBlbmRUYWcgPSBcInZ1ZS1wZXJmLWVuZDpcIiArIGlkO1xuXG4gICAgICBtYXJrKHN0YXJ0VGFnKTtcbiAgICAgIHZhciB2bm9kZSA9IHZtLl9yZW5kZXIoKTtcbiAgICAgIG1hcmsoZW5kVGFnKTtcbiAgICAgIG1lYXN1cmUoKFwidnVlIFwiICsgbmFtZSArIFwiIHJlbmRlclwiKSwgc3RhcnRUYWcsIGVuZFRhZyk7XG5cbiAgICAgIG1hcmsoc3RhcnRUYWcpO1xuICAgICAgdm0uX3VwZGF0ZSh2bm9kZSwgaHlkcmF0aW5nKTtcbiAgICAgIG1hcmsoZW5kVGFnKTtcbiAgICAgIG1lYXN1cmUoKFwidnVlIFwiICsgbmFtZSArIFwiIHBhdGNoXCIpLCBzdGFydFRhZywgZW5kVGFnKTtcbiAgICB9O1xuICB9IGVsc2Uge1xuICAgIHVwZGF0ZUNvbXBvbmVudCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZtLl91cGRhdGUodm0uX3JlbmRlcigpLCBoeWRyYXRpbmcpO1xuICAgIH07XG4gIH1cblxuICAvLyB3ZSBzZXQgdGhpcyB0byB2bS5fd2F0Y2hlciBpbnNpZGUgdGhlIHdhdGNoZXIncyBjb25zdHJ1Y3RvclxuICAvLyBzaW5jZSB0aGUgd2F0Y2hlcidzIGluaXRpYWwgcGF0Y2ggbWF5IGNhbGwgJGZvcmNlVXBkYXRlIChlLmcuIGluc2lkZSBjaGlsZFxuICAvLyBjb21wb25lbnQncyBtb3VudGVkIGhvb2spLCB3aGljaCByZWxpZXMgb24gdm0uX3dhdGNoZXIgYmVpbmcgYWxyZWFkeSBkZWZpbmVkXG4gIG5ldyBXYXRjaGVyKHZtLCB1cGRhdGVDb21wb25lbnQsIG5vb3AsIHtcbiAgICBiZWZvcmU6IGZ1bmN0aW9uIGJlZm9yZSAoKSB7XG4gICAgICBpZiAodm0uX2lzTW91bnRlZCAmJiAhdm0uX2lzRGVzdHJveWVkKSB7XG4gICAgICAgIGNhbGxIb29rKHZtLCAnYmVmb3JlVXBkYXRlJyk7XG4gICAgICB9XG4gICAgfVxuICB9LCB0cnVlIC8qIGlzUmVuZGVyV2F0Y2hlciAqLyk7XG4gIGh5ZHJhdGluZyA9IGZhbHNlO1xuXG4gIC8vIG1hbnVhbGx5IG1vdW50ZWQgaW5zdGFuY2UsIGNhbGwgbW91bnRlZCBvbiBzZWxmXG4gIC8vIG1vdW50ZWQgaXMgY2FsbGVkIGZvciByZW5kZXItY3JlYXRlZCBjaGlsZCBjb21wb25lbnRzIGluIGl0cyBpbnNlcnRlZCBob29rXG4gIGlmICh2bS4kdm5vZGUgPT0gbnVsbCkge1xuICAgIHZtLl9pc01vdW50ZWQgPSB0cnVlO1xuICAgIGNhbGxIb29rKHZtLCAnbW91bnRlZCcpO1xuICB9XG4gIHJldHVybiB2bVxufVxuXG5mdW5jdGlvbiB1cGRhdGVDaGlsZENvbXBvbmVudCAoXG4gIHZtLFxuICBwcm9wc0RhdGEsXG4gIGxpc3RlbmVycyxcbiAgcGFyZW50Vm5vZGUsXG4gIHJlbmRlckNoaWxkcmVuXG4pIHtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICBpc1VwZGF0aW5nQ2hpbGRDb21wb25lbnQgPSB0cnVlO1xuICB9XG5cbiAgLy8gZGV0ZXJtaW5lIHdoZXRoZXIgY29tcG9uZW50IGhhcyBzbG90IGNoaWxkcmVuXG4gIC8vIHdlIG5lZWQgdG8gZG8gdGhpcyBiZWZvcmUgb3ZlcndyaXRpbmcgJG9wdGlvbnMuX3JlbmRlckNoaWxkcmVuLlxuXG4gIC8vIGNoZWNrIGlmIHRoZXJlIGFyZSBkeW5hbWljIHNjb3BlZFNsb3RzIChoYW5kLXdyaXR0ZW4gb3IgY29tcGlsZWQgYnV0IHdpdGhcbiAgLy8gZHluYW1pYyBzbG90IG5hbWVzKS4gU3RhdGljIHNjb3BlZCBzbG90cyBjb21waWxlZCBmcm9tIHRlbXBsYXRlIGhhcyB0aGVcbiAgLy8gXCIkc3RhYmxlXCIgbWFya2VyLlxuICB2YXIgbmV3U2NvcGVkU2xvdHMgPSBwYXJlbnRWbm9kZS5kYXRhLnNjb3BlZFNsb3RzO1xuICB2YXIgb2xkU2NvcGVkU2xvdHMgPSB2bS4kc2NvcGVkU2xvdHM7XG4gIHZhciBoYXNEeW5hbWljU2NvcGVkU2xvdCA9ICEhKFxuICAgIChuZXdTY29wZWRTbG90cyAmJiAhbmV3U2NvcGVkU2xvdHMuJHN0YWJsZSkgfHxcbiAgICAob2xkU2NvcGVkU2xvdHMgIT09IGVtcHR5T2JqZWN0ICYmICFvbGRTY29wZWRTbG90cy4kc3RhYmxlKSB8fFxuICAgIChuZXdTY29wZWRTbG90cyAmJiB2bS4kc2NvcGVkU2xvdHMuJGtleSAhPT0gbmV3U2NvcGVkU2xvdHMuJGtleSkgfHxcbiAgICAoIW5ld1Njb3BlZFNsb3RzICYmIHZtLiRzY29wZWRTbG90cy4ka2V5KVxuICApO1xuXG4gIC8vIEFueSBzdGF0aWMgc2xvdCBjaGlsZHJlbiBmcm9tIHRoZSBwYXJlbnQgbWF5IGhhdmUgY2hhbmdlZCBkdXJpbmcgcGFyZW50J3NcbiAgLy8gdXBkYXRlLiBEeW5hbWljIHNjb3BlZCBzbG90cyBtYXkgYWxzbyBoYXZlIGNoYW5nZWQuIEluIHN1Y2ggY2FzZXMsIGEgZm9yY2VkXG4gIC8vIHVwZGF0ZSBpcyBuZWNlc3NhcnkgdG8gZW5zdXJlIGNvcnJlY3RuZXNzLlxuICB2YXIgbmVlZHNGb3JjZVVwZGF0ZSA9ICEhKFxuICAgIHJlbmRlckNoaWxkcmVuIHx8ICAgICAgICAgICAgICAgLy8gaGFzIG5ldyBzdGF0aWMgc2xvdHNcbiAgICB2bS4kb3B0aW9ucy5fcmVuZGVyQ2hpbGRyZW4gfHwgIC8vIGhhcyBvbGQgc3RhdGljIHNsb3RzXG4gICAgaGFzRHluYW1pY1Njb3BlZFNsb3RcbiAgKTtcblxuICB2bS4kb3B0aW9ucy5fcGFyZW50Vm5vZGUgPSBwYXJlbnRWbm9kZTtcbiAgdm0uJHZub2RlID0gcGFyZW50Vm5vZGU7IC8vIHVwZGF0ZSB2bSdzIHBsYWNlaG9sZGVyIG5vZGUgd2l0aG91dCByZS1yZW5kZXJcblxuICBpZiAodm0uX3Zub2RlKSB7IC8vIHVwZGF0ZSBjaGlsZCB0cmVlJ3MgcGFyZW50XG4gICAgdm0uX3Zub2RlLnBhcmVudCA9IHBhcmVudFZub2RlO1xuICB9XG4gIHZtLiRvcHRpb25zLl9yZW5kZXJDaGlsZHJlbiA9IHJlbmRlckNoaWxkcmVuO1xuXG4gIC8vIHVwZGF0ZSAkYXR0cnMgYW5kICRsaXN0ZW5lcnMgaGFzaFxuICAvLyB0aGVzZSBhcmUgYWxzbyByZWFjdGl2ZSBzbyB0aGV5IG1heSB0cmlnZ2VyIGNoaWxkIHVwZGF0ZSBpZiB0aGUgY2hpbGRcbiAgLy8gdXNlZCB0aGVtIGR1cmluZyByZW5kZXJcbiAgdm0uJGF0dHJzID0gcGFyZW50Vm5vZGUuZGF0YS5hdHRycyB8fCBlbXB0eU9iamVjdDtcbiAgdm0uJGxpc3RlbmVycyA9IGxpc3RlbmVycyB8fCBlbXB0eU9iamVjdDtcblxuICAvLyB1cGRhdGUgcHJvcHNcbiAgaWYgKHByb3BzRGF0YSAmJiB2bS4kb3B0aW9ucy5wcm9wcykge1xuICAgIHRvZ2dsZU9ic2VydmluZyhmYWxzZSk7XG4gICAgdmFyIHByb3BzID0gdm0uX3Byb3BzO1xuICAgIHZhciBwcm9wS2V5cyA9IHZtLiRvcHRpb25zLl9wcm9wS2V5cyB8fCBbXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BLZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIga2V5ID0gcHJvcEtleXNbaV07XG4gICAgICB2YXIgcHJvcE9wdGlvbnMgPSB2bS4kb3B0aW9ucy5wcm9wczsgLy8gd3RmIGZsb3c/XG4gICAgICBwcm9wc1trZXldID0gdmFsaWRhdGVQcm9wKGtleSwgcHJvcE9wdGlvbnMsIHByb3BzRGF0YSwgdm0pO1xuICAgIH1cbiAgICB0b2dnbGVPYnNlcnZpbmcodHJ1ZSk7XG4gICAgLy8ga2VlcCBhIGNvcHkgb2YgcmF3IHByb3BzRGF0YVxuICAgIHZtLiRvcHRpb25zLnByb3BzRGF0YSA9IHByb3BzRGF0YTtcbiAgfVxuXG4gIC8vIHVwZGF0ZSBsaXN0ZW5lcnNcbiAgbGlzdGVuZXJzID0gbGlzdGVuZXJzIHx8IGVtcHR5T2JqZWN0O1xuICB2YXIgb2xkTGlzdGVuZXJzID0gdm0uJG9wdGlvbnMuX3BhcmVudExpc3RlbmVycztcbiAgdm0uJG9wdGlvbnMuX3BhcmVudExpc3RlbmVycyA9IGxpc3RlbmVycztcbiAgdXBkYXRlQ29tcG9uZW50TGlzdGVuZXJzKHZtLCBsaXN0ZW5lcnMsIG9sZExpc3RlbmVycyk7XG5cbiAgLy8gcmVzb2x2ZSBzbG90cyArIGZvcmNlIHVwZGF0ZSBpZiBoYXMgY2hpbGRyZW5cbiAgaWYgKG5lZWRzRm9yY2VVcGRhdGUpIHtcbiAgICB2bS4kc2xvdHMgPSByZXNvbHZlU2xvdHMocmVuZGVyQ2hpbGRyZW4sIHBhcmVudFZub2RlLmNvbnRleHQpO1xuICAgIHZtLiRmb3JjZVVwZGF0ZSgpO1xuICB9XG5cbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICBpc1VwZGF0aW5nQ2hpbGRDb21wb25lbnQgPSBmYWxzZTtcbiAgfVxufVxuXG5mdW5jdGlvbiBpc0luSW5hY3RpdmVUcmVlICh2bSkge1xuICB3aGlsZSAodm0gJiYgKHZtID0gdm0uJHBhcmVudCkpIHtcbiAgICBpZiAodm0uX2luYWN0aXZlKSB7IHJldHVybiB0cnVlIH1cbiAgfVxuICByZXR1cm4gZmFsc2Vcbn1cblxuZnVuY3Rpb24gYWN0aXZhdGVDaGlsZENvbXBvbmVudCAodm0sIGRpcmVjdCkge1xuICBpZiAoZGlyZWN0KSB7XG4gICAgdm0uX2RpcmVjdEluYWN0aXZlID0gZmFsc2U7XG4gICAgaWYgKGlzSW5JbmFjdGl2ZVRyZWUodm0pKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG4gIH0gZWxzZSBpZiAodm0uX2RpcmVjdEluYWN0aXZlKSB7XG4gICAgcmV0dXJuXG4gIH1cbiAgaWYgKHZtLl9pbmFjdGl2ZSB8fCB2bS5faW5hY3RpdmUgPT09IG51bGwpIHtcbiAgICB2bS5faW5hY3RpdmUgPSBmYWxzZTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHZtLiRjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgYWN0aXZhdGVDaGlsZENvbXBvbmVudCh2bS4kY2hpbGRyZW5baV0pO1xuICAgIH1cbiAgICBjYWxsSG9vayh2bSwgJ2FjdGl2YXRlZCcpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGRlYWN0aXZhdGVDaGlsZENvbXBvbmVudCAodm0sIGRpcmVjdCkge1xuICBpZiAoZGlyZWN0KSB7XG4gICAgdm0uX2RpcmVjdEluYWN0aXZlID0gdHJ1ZTtcbiAgICBpZiAoaXNJbkluYWN0aXZlVHJlZSh2bSkpIHtcbiAgICAgIHJldHVyblxuICAgIH1cbiAgfVxuICBpZiAoIXZtLl9pbmFjdGl2ZSkge1xuICAgIHZtLl9pbmFjdGl2ZSA9IHRydWU7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB2bS4kY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgIGRlYWN0aXZhdGVDaGlsZENvbXBvbmVudCh2bS4kY2hpbGRyZW5baV0pO1xuICAgIH1cbiAgICBjYWxsSG9vayh2bSwgJ2RlYWN0aXZhdGVkJyk7XG4gIH1cbn1cblxuZnVuY3Rpb24gY2FsbEhvb2sgKHZtLCBob29rKSB7XG4gIC8vICM3NTczIGRpc2FibGUgZGVwIGNvbGxlY3Rpb24gd2hlbiBpbnZva2luZyBsaWZlY3ljbGUgaG9va3NcbiAgcHVzaFRhcmdldCgpO1xuICB2YXIgaGFuZGxlcnMgPSB2bS4kb3B0aW9uc1tob29rXTtcbiAgdmFyIGluZm8gPSBob29rICsgXCIgaG9va1wiO1xuICBpZiAoaGFuZGxlcnMpIHtcbiAgICBmb3IgKHZhciBpID0gMCwgaiA9IGhhbmRsZXJzLmxlbmd0aDsgaSA8IGo7IGkrKykge1xuICAgICAgaW52b2tlV2l0aEVycm9ySGFuZGxpbmcoaGFuZGxlcnNbaV0sIHZtLCBudWxsLCB2bSwgaW5mbyk7XG4gICAgfVxuICB9XG4gIGlmICh2bS5faGFzSG9va0V2ZW50KSB7XG4gICAgdm0uJGVtaXQoJ2hvb2s6JyArIGhvb2spO1xuICB9XG4gIHBvcFRhcmdldCgpO1xufVxuXG4vKiAgKi9cblxudmFyIE1BWF9VUERBVEVfQ09VTlQgPSAxMDA7XG5cbnZhciBxdWV1ZSA9IFtdO1xudmFyIGFjdGl2YXRlZENoaWxkcmVuID0gW107XG52YXIgaGFzID0ge307XG52YXIgY2lyY3VsYXIgPSB7fTtcbnZhciB3YWl0aW5nID0gZmFsc2U7XG52YXIgZmx1c2hpbmcgPSBmYWxzZTtcbnZhciBpbmRleCA9IDA7XG5cbi8qKlxuICogUmVzZXQgdGhlIHNjaGVkdWxlcidzIHN0YXRlLlxuICovXG5mdW5jdGlvbiByZXNldFNjaGVkdWxlclN0YXRlICgpIHtcbiAgaW5kZXggPSBxdWV1ZS5sZW5ndGggPSBhY3RpdmF0ZWRDaGlsZHJlbi5sZW5ndGggPSAwO1xuICBoYXMgPSB7fTtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICBjaXJjdWxhciA9IHt9O1xuICB9XG4gIHdhaXRpbmcgPSBmbHVzaGluZyA9IGZhbHNlO1xufVxuXG4vLyBBc3luYyBlZGdlIGNhc2UgIzY1NjYgcmVxdWlyZXMgc2F2aW5nIHRoZSB0aW1lc3RhbXAgd2hlbiBldmVudCBsaXN0ZW5lcnMgYXJlXG4vLyBhdHRhY2hlZC4gSG93ZXZlciwgY2FsbGluZyBwZXJmb3JtYW5jZS5ub3coKSBoYXMgYSBwZXJmIG92ZXJoZWFkIGVzcGVjaWFsbHlcbi8vIGlmIHRoZSBwYWdlIGhhcyB0aG91c2FuZHMgb2YgZXZlbnQgbGlzdGVuZXJzLiBJbnN0ZWFkLCB3ZSB0YWtlIGEgdGltZXN0YW1wXG4vLyBldmVyeSB0aW1lIHRoZSBzY2hlZHVsZXIgZmx1c2hlcyBhbmQgdXNlIHRoYXQgZm9yIGFsbCBldmVudCBsaXN0ZW5lcnNcbi8vIGF0dGFjaGVkIGR1cmluZyB0aGF0IGZsdXNoLlxudmFyIGN1cnJlbnRGbHVzaFRpbWVzdGFtcCA9IDA7XG5cbi8vIEFzeW5jIGVkZ2UgY2FzZSBmaXggcmVxdWlyZXMgc3RvcmluZyBhbiBldmVudCBsaXN0ZW5lcidzIGF0dGFjaCB0aW1lc3RhbXAuXG52YXIgZ2V0Tm93ID0gRGF0ZS5ub3c7XG5cbi8vIERldGVybWluZSB3aGF0IGV2ZW50IHRpbWVzdGFtcCB0aGUgYnJvd3NlciBpcyB1c2luZy4gQW5ub3lpbmdseSwgdGhlXG4vLyB0aW1lc3RhbXAgY2FuIGVpdGhlciBiZSBoaS1yZXMgKHJlbGF0aXZlIHRvIHBhZ2UgbG9hZCkgb3IgbG93LXJlc1xuLy8gKHJlbGF0aXZlIHRvIFVOSVggZXBvY2gpLCBzbyBpbiBvcmRlciB0byBjb21wYXJlIHRpbWUgd2UgaGF2ZSB0byB1c2UgdGhlXG4vLyBzYW1lIHRpbWVzdGFtcCB0eXBlIHdoZW4gc2F2aW5nIHRoZSBmbHVzaCB0aW1lc3RhbXAuXG4vLyBBbGwgSUUgdmVyc2lvbnMgdXNlIGxvdy1yZXMgZXZlbnQgdGltZXN0YW1wcywgYW5kIGhhdmUgcHJvYmxlbWF0aWMgY2xvY2tcbi8vIGltcGxlbWVudGF0aW9ucyAoIzk2MzIpXG5pZiAoaW5Ccm93c2VyICYmICFpc0lFKSB7XG4gIHZhciBwZXJmb3JtYW5jZSA9IHdpbmRvdy5wZXJmb3JtYW5jZTtcbiAgaWYgKFxuICAgIHBlcmZvcm1hbmNlICYmXG4gICAgdHlwZW9mIHBlcmZvcm1hbmNlLm5vdyA9PT0gJ2Z1bmN0aW9uJyAmJlxuICAgIGdldE5vdygpID4gZG9jdW1lbnQuY3JlYXRlRXZlbnQoJ0V2ZW50JykudGltZVN0YW1wXG4gICkge1xuICAgIC8vIGlmIHRoZSBldmVudCB0aW1lc3RhbXAsIGFsdGhvdWdoIGV2YWx1YXRlZCBBRlRFUiB0aGUgRGF0ZS5ub3coKSwgaXNcbiAgICAvLyBzbWFsbGVyIHRoYW4gaXQsIGl0IG1lYW5zIHRoZSBldmVudCBpcyB1c2luZyBhIGhpLXJlcyB0aW1lc3RhbXAsXG4gICAgLy8gYW5kIHdlIG5lZWQgdG8gdXNlIHRoZSBoaS1yZXMgdmVyc2lvbiBmb3IgZXZlbnQgbGlzdGVuZXIgdGltZXN0YW1wcyBhc1xuICAgIC8vIHdlbGwuXG4gICAgZ2V0Tm93ID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gcGVyZm9ybWFuY2Uubm93KCk7IH07XG4gIH1cbn1cblxuLyoqXG4gKiBGbHVzaCBib3RoIHF1ZXVlcyBhbmQgcnVuIHRoZSB3YXRjaGVycy5cbiAqL1xuZnVuY3Rpb24gZmx1c2hTY2hlZHVsZXJRdWV1ZSAoKSB7XG4gIGN1cnJlbnRGbHVzaFRpbWVzdGFtcCA9IGdldE5vdygpO1xuICBmbHVzaGluZyA9IHRydWU7XG4gIHZhciB3YXRjaGVyLCBpZDtcblxuICAvLyBTb3J0IHF1ZXVlIGJlZm9yZSBmbHVzaC5cbiAgLy8gVGhpcyBlbnN1cmVzIHRoYXQ6XG4gIC8vIDEuIENvbXBvbmVudHMgYXJlIHVwZGF0ZWQgZnJvbSBwYXJlbnQgdG8gY2hpbGQuIChiZWNhdXNlIHBhcmVudCBpcyBhbHdheXNcbiAgLy8gICAgY3JlYXRlZCBiZWZvcmUgdGhlIGNoaWxkKVxuICAvLyAyLiBBIGNvbXBvbmVudCdzIHVzZXIgd2F0Y2hlcnMgYXJlIHJ1biBiZWZvcmUgaXRzIHJlbmRlciB3YXRjaGVyIChiZWNhdXNlXG4gIC8vICAgIHVzZXIgd2F0Y2hlcnMgYXJlIGNyZWF0ZWQgYmVmb3JlIHRoZSByZW5kZXIgd2F0Y2hlcilcbiAgLy8gMy4gSWYgYSBjb21wb25lbnQgaXMgZGVzdHJveWVkIGR1cmluZyBhIHBhcmVudCBjb21wb25lbnQncyB3YXRjaGVyIHJ1bixcbiAgLy8gICAgaXRzIHdhdGNoZXJzIGNhbiBiZSBza2lwcGVkLlxuICBxdWV1ZS5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7IHJldHVybiBhLmlkIC0gYi5pZDsgfSk7XG5cbiAgLy8gZG8gbm90IGNhY2hlIGxlbmd0aCBiZWNhdXNlIG1vcmUgd2F0Y2hlcnMgbWlnaHQgYmUgcHVzaGVkXG4gIC8vIGFzIHdlIHJ1biBleGlzdGluZyB3YXRjaGVyc1xuICBmb3IgKGluZGV4ID0gMDsgaW5kZXggPCBxdWV1ZS5sZW5ndGg7IGluZGV4KyspIHtcbiAgICB3YXRjaGVyID0gcXVldWVbaW5kZXhdO1xuICAgIGlmICh3YXRjaGVyLmJlZm9yZSkge1xuICAgICAgd2F0Y2hlci5iZWZvcmUoKTtcbiAgICB9XG4gICAgaWQgPSB3YXRjaGVyLmlkO1xuICAgIGhhc1tpZF0gPSBudWxsO1xuICAgIHdhdGNoZXIucnVuKCk7XG4gICAgLy8gaW4gZGV2IGJ1aWxkLCBjaGVjayBhbmQgc3RvcCBjaXJjdWxhciB1cGRhdGVzLlxuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIGhhc1tpZF0gIT0gbnVsbCkge1xuICAgICAgY2lyY3VsYXJbaWRdID0gKGNpcmN1bGFyW2lkXSB8fCAwKSArIDE7XG4gICAgICBpZiAoY2lyY3VsYXJbaWRdID4gTUFYX1VQREFURV9DT1VOVCkge1xuICAgICAgICB3YXJuKFxuICAgICAgICAgICdZb3UgbWF5IGhhdmUgYW4gaW5maW5pdGUgdXBkYXRlIGxvb3AgJyArIChcbiAgICAgICAgICAgIHdhdGNoZXIudXNlclxuICAgICAgICAgICAgICA/IChcImluIHdhdGNoZXIgd2l0aCBleHByZXNzaW9uIFxcXCJcIiArICh3YXRjaGVyLmV4cHJlc3Npb24pICsgXCJcXFwiXCIpXG4gICAgICAgICAgICAgIDogXCJpbiBhIGNvbXBvbmVudCByZW5kZXIgZnVuY3Rpb24uXCJcbiAgICAgICAgICApLFxuICAgICAgICAgIHdhdGNoZXIudm1cbiAgICAgICAgKTtcbiAgICAgICAgYnJlYWtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvLyBrZWVwIGNvcGllcyBvZiBwb3N0IHF1ZXVlcyBiZWZvcmUgcmVzZXR0aW5nIHN0YXRlXG4gIHZhciBhY3RpdmF0ZWRRdWV1ZSA9IGFjdGl2YXRlZENoaWxkcmVuLnNsaWNlKCk7XG4gIHZhciB1cGRhdGVkUXVldWUgPSBxdWV1ZS5zbGljZSgpO1xuXG4gIHJlc2V0U2NoZWR1bGVyU3RhdGUoKTtcblxuICAvLyBjYWxsIGNvbXBvbmVudCB1cGRhdGVkIGFuZCBhY3RpdmF0ZWQgaG9va3NcbiAgY2FsbEFjdGl2YXRlZEhvb2tzKGFjdGl2YXRlZFF1ZXVlKTtcbiAgY2FsbFVwZGF0ZWRIb29rcyh1cGRhdGVkUXVldWUpO1xuXG4gIC8vIGRldnRvb2wgaG9va1xuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgaWYgKGRldnRvb2xzICYmIGNvbmZpZy5kZXZ0b29scykge1xuICAgIGRldnRvb2xzLmVtaXQoJ2ZsdXNoJyk7XG4gIH1cbn1cblxuZnVuY3Rpb24gY2FsbFVwZGF0ZWRIb29rcyAocXVldWUpIHtcbiAgdmFyIGkgPSBxdWV1ZS5sZW5ndGg7XG4gIHdoaWxlIChpLS0pIHtcbiAgICB2YXIgd2F0Y2hlciA9IHF1ZXVlW2ldO1xuICAgIHZhciB2bSA9IHdhdGNoZXIudm07XG4gICAgaWYgKHZtLl93YXRjaGVyID09PSB3YXRjaGVyICYmIHZtLl9pc01vdW50ZWQgJiYgIXZtLl9pc0Rlc3Ryb3llZCkge1xuICAgICAgY2FsbEhvb2sodm0sICd1cGRhdGVkJyk7XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogUXVldWUgYSBrZXB0LWFsaXZlIGNvbXBvbmVudCB0aGF0IHdhcyBhY3RpdmF0ZWQgZHVyaW5nIHBhdGNoLlxuICogVGhlIHF1ZXVlIHdpbGwgYmUgcHJvY2Vzc2VkIGFmdGVyIHRoZSBlbnRpcmUgdHJlZSBoYXMgYmVlbiBwYXRjaGVkLlxuICovXG5mdW5jdGlvbiBxdWV1ZUFjdGl2YXRlZENvbXBvbmVudCAodm0pIHtcbiAgLy8gc2V0dGluZyBfaW5hY3RpdmUgdG8gZmFsc2UgaGVyZSBzbyB0aGF0IGEgcmVuZGVyIGZ1bmN0aW9uIGNhblxuICAvLyByZWx5IG9uIGNoZWNraW5nIHdoZXRoZXIgaXQncyBpbiBhbiBpbmFjdGl2ZSB0cmVlIChlLmcuIHJvdXRlci12aWV3KVxuICB2bS5faW5hY3RpdmUgPSBmYWxzZTtcbiAgYWN0aXZhdGVkQ2hpbGRyZW4ucHVzaCh2bSk7XG59XG5cbmZ1bmN0aW9uIGNhbGxBY3RpdmF0ZWRIb29rcyAocXVldWUpIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBxdWV1ZS5sZW5ndGg7IGkrKykge1xuICAgIHF1ZXVlW2ldLl9pbmFjdGl2ZSA9IHRydWU7XG4gICAgYWN0aXZhdGVDaGlsZENvbXBvbmVudChxdWV1ZVtpXSwgdHJ1ZSAvKiB0cnVlICovKTtcbiAgfVxufVxuXG4vKipcbiAqIFB1c2ggYSB3YXRjaGVyIGludG8gdGhlIHdhdGNoZXIgcXVldWUuXG4gKiBKb2JzIHdpdGggZHVwbGljYXRlIElEcyB3aWxsIGJlIHNraXBwZWQgdW5sZXNzIGl0J3NcbiAqIHB1c2hlZCB3aGVuIHRoZSBxdWV1ZSBpcyBiZWluZyBmbHVzaGVkLlxuICovXG5mdW5jdGlvbiBxdWV1ZVdhdGNoZXIgKHdhdGNoZXIpIHtcbiAgdmFyIGlkID0gd2F0Y2hlci5pZDtcbiAgaWYgKGhhc1tpZF0gPT0gbnVsbCkge1xuICAgIGhhc1tpZF0gPSB0cnVlO1xuICAgIGlmICghZmx1c2hpbmcpIHtcbiAgICAgIHF1ZXVlLnB1c2god2F0Y2hlcik7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGlmIGFscmVhZHkgZmx1c2hpbmcsIHNwbGljZSB0aGUgd2F0Y2hlciBiYXNlZCBvbiBpdHMgaWRcbiAgICAgIC8vIGlmIGFscmVhZHkgcGFzdCBpdHMgaWQsIGl0IHdpbGwgYmUgcnVuIG5leHQgaW1tZWRpYXRlbHkuXG4gICAgICB2YXIgaSA9IHF1ZXVlLmxlbmd0aCAtIDE7XG4gICAgICB3aGlsZSAoaSA+IGluZGV4ICYmIHF1ZXVlW2ldLmlkID4gd2F0Y2hlci5pZCkge1xuICAgICAgICBpLS07XG4gICAgICB9XG4gICAgICBxdWV1ZS5zcGxpY2UoaSArIDEsIDAsIHdhdGNoZXIpO1xuICAgIH1cbiAgICAvLyBxdWV1ZSB0aGUgZmx1c2hcbiAgICBpZiAoIXdhaXRpbmcpIHtcbiAgICAgIHdhaXRpbmcgPSB0cnVlO1xuXG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiAhY29uZmlnLmFzeW5jKSB7XG4gICAgICAgIGZsdXNoU2NoZWR1bGVyUXVldWUoKTtcbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG4gICAgICBuZXh0VGljayhmbHVzaFNjaGVkdWxlclF1ZXVlKTtcbiAgICB9XG4gIH1cbn1cblxuLyogICovXG5cblxuXG52YXIgdWlkJDIgPSAwO1xuXG4vKipcbiAqIEEgd2F0Y2hlciBwYXJzZXMgYW4gZXhwcmVzc2lvbiwgY29sbGVjdHMgZGVwZW5kZW5jaWVzLFxuICogYW5kIGZpcmVzIGNhbGxiYWNrIHdoZW4gdGhlIGV4cHJlc3Npb24gdmFsdWUgY2hhbmdlcy5cbiAqIFRoaXMgaXMgdXNlZCBmb3IgYm90aCB0aGUgJHdhdGNoKCkgYXBpIGFuZCBkaXJlY3RpdmVzLlxuICovXG52YXIgV2F0Y2hlciA9IGZ1bmN0aW9uIFdhdGNoZXIgKFxuICB2bSxcbiAgZXhwT3JGbixcbiAgY2IsXG4gIG9wdGlvbnMsXG4gIGlzUmVuZGVyV2F0Y2hlclxuKSB7XG4gIHRoaXMudm0gPSB2bTtcbiAgaWYgKGlzUmVuZGVyV2F0Y2hlcikge1xuICAgIHZtLl93YXRjaGVyID0gdGhpcztcbiAgfVxuICB2bS5fd2F0Y2hlcnMucHVzaCh0aGlzKTtcbiAgLy8gb3B0aW9uc1xuICBpZiAob3B0aW9ucykge1xuICAgIHRoaXMuZGVlcCA9ICEhb3B0aW9ucy5kZWVwO1xuICAgIHRoaXMudXNlciA9ICEhb3B0aW9ucy51c2VyO1xuICAgIHRoaXMubGF6eSA9ICEhb3B0aW9ucy5sYXp5O1xuICAgIHRoaXMuc3luYyA9ICEhb3B0aW9ucy5zeW5jO1xuICAgIHRoaXMuYmVmb3JlID0gb3B0aW9ucy5iZWZvcmU7XG4gIH0gZWxzZSB7XG4gICAgdGhpcy5kZWVwID0gdGhpcy51c2VyID0gdGhpcy5sYXp5ID0gdGhpcy5zeW5jID0gZmFsc2U7XG4gIH1cbiAgdGhpcy5jYiA9IGNiO1xuICB0aGlzLmlkID0gKyt1aWQkMjsgLy8gdWlkIGZvciBiYXRjaGluZ1xuICB0aGlzLmFjdGl2ZSA9IHRydWU7XG4gIHRoaXMuZGlydHkgPSB0aGlzLmxhenk7IC8vIGZvciBsYXp5IHdhdGNoZXJzXG4gIHRoaXMuZGVwcyA9IFtdO1xuICB0aGlzLm5ld0RlcHMgPSBbXTtcbiAgdGhpcy5kZXBJZHMgPSBuZXcgX1NldCgpO1xuICB0aGlzLm5ld0RlcElkcyA9IG5ldyBfU2V0KCk7XG4gIHRoaXMuZXhwcmVzc2lvbiA9IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbidcbiAgICA/IGV4cE9yRm4udG9TdHJpbmcoKVxuICAgIDogJyc7XG4gIC8vIHBhcnNlIGV4cHJlc3Npb24gZm9yIGdldHRlclxuICBpZiAodHlwZW9mIGV4cE9yRm4gPT09ICdmdW5jdGlvbicpIHtcbiAgICB0aGlzLmdldHRlciA9IGV4cE9yRm47XG4gIH0gZWxzZSB7XG4gICAgdGhpcy5nZXR0ZXIgPSBwYXJzZVBhdGgoZXhwT3JGbik7XG4gICAgaWYgKCF0aGlzLmdldHRlcikge1xuICAgICAgdGhpcy5nZXR0ZXIgPSBub29wO1xuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiB3YXJuKFxuICAgICAgICBcIkZhaWxlZCB3YXRjaGluZyBwYXRoOiBcXFwiXCIgKyBleHBPckZuICsgXCJcXFwiIFwiICtcbiAgICAgICAgJ1dhdGNoZXIgb25seSBhY2NlcHRzIHNpbXBsZSBkb3QtZGVsaW1pdGVkIHBhdGhzLiAnICtcbiAgICAgICAgJ0ZvciBmdWxsIGNvbnRyb2wsIHVzZSBhIGZ1bmN0aW9uIGluc3RlYWQuJyxcbiAgICAgICAgdm1cbiAgICAgICk7XG4gICAgfVxuICB9XG4gIHRoaXMudmFsdWUgPSB0aGlzLmxhenlcbiAgICA/IHVuZGVmaW5lZFxuICAgIDogdGhpcy5nZXQoKTtcbn07XG5cbi8qKlxuICogRXZhbHVhdGUgdGhlIGdldHRlciwgYW5kIHJlLWNvbGxlY3QgZGVwZW5kZW5jaWVzLlxuICovXG5XYXRjaGVyLnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbiBnZXQgKCkge1xuICBwdXNoVGFyZ2V0KHRoaXMpO1xuICB2YXIgdmFsdWU7XG4gIHZhciB2bSA9IHRoaXMudm07XG4gIHRyeSB7XG4gICAgdmFsdWUgPSB0aGlzLmdldHRlci5jYWxsKHZtLCB2bSk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICBpZiAodGhpcy51c2VyKSB7XG4gICAgICBoYW5kbGVFcnJvcihlLCB2bSwgKFwiZ2V0dGVyIGZvciB3YXRjaGVyIFxcXCJcIiArICh0aGlzLmV4cHJlc3Npb24pICsgXCJcXFwiXCIpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgZVxuICAgIH1cbiAgfSBmaW5hbGx5IHtcbiAgICAvLyBcInRvdWNoXCIgZXZlcnkgcHJvcGVydHkgc28gdGhleSBhcmUgYWxsIHRyYWNrZWQgYXNcbiAgICAvLyBkZXBlbmRlbmNpZXMgZm9yIGRlZXAgd2F0Y2hpbmdcbiAgICBpZiAodGhpcy5kZWVwKSB7XG4gICAgICB0cmF2ZXJzZSh2YWx1ZSk7XG4gICAgfVxuICAgIHBvcFRhcmdldCgpO1xuICAgIHRoaXMuY2xlYW51cERlcHMoKTtcbiAgfVxuICByZXR1cm4gdmFsdWVcbn07XG5cbi8qKlxuICogQWRkIGEgZGVwZW5kZW5jeSB0byB0aGlzIGRpcmVjdGl2ZS5cbiAqL1xuV2F0Y2hlci5wcm90b3R5cGUuYWRkRGVwID0gZnVuY3Rpb24gYWRkRGVwIChkZXApIHtcbiAgdmFyIGlkID0gZGVwLmlkO1xuICBpZiAoIXRoaXMubmV3RGVwSWRzLmhhcyhpZCkpIHtcbiAgICB0aGlzLm5ld0RlcElkcy5hZGQoaWQpO1xuICAgIHRoaXMubmV3RGVwcy5wdXNoKGRlcCk7XG4gICAgaWYgKCF0aGlzLmRlcElkcy5oYXMoaWQpKSB7XG4gICAgICBkZXAuYWRkU3ViKHRoaXMpO1xuICAgIH1cbiAgfVxufTtcblxuLyoqXG4gKiBDbGVhbiB1cCBmb3IgZGVwZW5kZW5jeSBjb2xsZWN0aW9uLlxuICovXG5XYXRjaGVyLnByb3RvdHlwZS5jbGVhbnVwRGVwcyA9IGZ1bmN0aW9uIGNsZWFudXBEZXBzICgpIHtcbiAgdmFyIGkgPSB0aGlzLmRlcHMubGVuZ3RoO1xuICB3aGlsZSAoaS0tKSB7XG4gICAgdmFyIGRlcCA9IHRoaXMuZGVwc1tpXTtcbiAgICBpZiAoIXRoaXMubmV3RGVwSWRzLmhhcyhkZXAuaWQpKSB7XG4gICAgICBkZXAucmVtb3ZlU3ViKHRoaXMpO1xuICAgIH1cbiAgfVxuICB2YXIgdG1wID0gdGhpcy5kZXBJZHM7XG4gIHRoaXMuZGVwSWRzID0gdGhpcy5uZXdEZXBJZHM7XG4gIHRoaXMubmV3RGVwSWRzID0gdG1wO1xuICB0aGlzLm5ld0RlcElkcy5jbGVhcigpO1xuICB0bXAgPSB0aGlzLmRlcHM7XG4gIHRoaXMuZGVwcyA9IHRoaXMubmV3RGVwcztcbiAgdGhpcy5uZXdEZXBzID0gdG1wO1xuICB0aGlzLm5ld0RlcHMubGVuZ3RoID0gMDtcbn07XG5cbi8qKlxuICogU3Vic2NyaWJlciBpbnRlcmZhY2UuXG4gKiBXaWxsIGJlIGNhbGxlZCB3aGVuIGEgZGVwZW5kZW5jeSBjaGFuZ2VzLlxuICovXG5XYXRjaGVyLnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbiB1cGRhdGUgKCkge1xuICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICBpZiAodGhpcy5sYXp5KSB7XG4gICAgdGhpcy5kaXJ0eSA9IHRydWU7XG4gIH0gZWxzZSBpZiAodGhpcy5zeW5jKSB7XG4gICAgdGhpcy5ydW4oKTtcbiAgfSBlbHNlIHtcbiAgICBxdWV1ZVdhdGNoZXIodGhpcyk7XG4gIH1cbn07XG5cbi8qKlxuICogU2NoZWR1bGVyIGpvYiBpbnRlcmZhY2UuXG4gKiBXaWxsIGJlIGNhbGxlZCBieSB0aGUgc2NoZWR1bGVyLlxuICovXG5XYXRjaGVyLnByb3RvdHlwZS5ydW4gPSBmdW5jdGlvbiBydW4gKCkge1xuICBpZiAodGhpcy5hY3RpdmUpIHtcbiAgICB2YXIgdmFsdWUgPSB0aGlzLmdldCgpO1xuICAgIGlmIChcbiAgICAgIHZhbHVlICE9PSB0aGlzLnZhbHVlIHx8XG4gICAgICAvLyBEZWVwIHdhdGNoZXJzIGFuZCB3YXRjaGVycyBvbiBPYmplY3QvQXJyYXlzIHNob3VsZCBmaXJlIGV2ZW5cbiAgICAgIC8vIHdoZW4gdGhlIHZhbHVlIGlzIHRoZSBzYW1lLCBiZWNhdXNlIHRoZSB2YWx1ZSBtYXlcbiAgICAgIC8vIGhhdmUgbXV0YXRlZC5cbiAgICAgIGlzT2JqZWN0KHZhbHVlKSB8fFxuICAgICAgdGhpcy5kZWVwXG4gICAgKSB7XG4gICAgICAvLyBzZXQgbmV3IHZhbHVlXG4gICAgICB2YXIgb2xkVmFsdWUgPSB0aGlzLnZhbHVlO1xuICAgICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICAgICAgaWYgKHRoaXMudXNlcikge1xuICAgICAgICB2YXIgaW5mbyA9IFwiY2FsbGJhY2sgZm9yIHdhdGNoZXIgXFxcIlwiICsgKHRoaXMuZXhwcmVzc2lvbikgKyBcIlxcXCJcIjtcbiAgICAgICAgaW52b2tlV2l0aEVycm9ySGFuZGxpbmcodGhpcy5jYiwgdGhpcy52bSwgW3ZhbHVlLCBvbGRWYWx1ZV0sIHRoaXMudm0sIGluZm8pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5jYi5jYWxsKHRoaXMudm0sIHZhbHVlLCBvbGRWYWx1ZSk7XG4gICAgICB9XG4gICAgfVxuICB9XG59O1xuXG4vKipcbiAqIEV2YWx1YXRlIHRoZSB2YWx1ZSBvZiB0aGUgd2F0Y2hlci5cbiAqIFRoaXMgb25seSBnZXRzIGNhbGxlZCBmb3IgbGF6eSB3YXRjaGVycy5cbiAqL1xuV2F0Y2hlci5wcm90b3R5cGUuZXZhbHVhdGUgPSBmdW5jdGlvbiBldmFsdWF0ZSAoKSB7XG4gIHRoaXMudmFsdWUgPSB0aGlzLmdldCgpO1xuICB0aGlzLmRpcnR5ID0gZmFsc2U7XG59O1xuXG4vKipcbiAqIERlcGVuZCBvbiBhbGwgZGVwcyBjb2xsZWN0ZWQgYnkgdGhpcyB3YXRjaGVyLlxuICovXG5XYXRjaGVyLnByb3RvdHlwZS5kZXBlbmQgPSBmdW5jdGlvbiBkZXBlbmQgKCkge1xuICB2YXIgaSA9IHRoaXMuZGVwcy5sZW5ndGg7XG4gIHdoaWxlIChpLS0pIHtcbiAgICB0aGlzLmRlcHNbaV0uZGVwZW5kKCk7XG4gIH1cbn07XG5cbi8qKlxuICogUmVtb3ZlIHNlbGYgZnJvbSBhbGwgZGVwZW5kZW5jaWVzJyBzdWJzY3JpYmVyIGxpc3QuXG4gKi9cbldhdGNoZXIucHJvdG90eXBlLnRlYXJkb3duID0gZnVuY3Rpb24gdGVhcmRvd24gKCkge1xuICBpZiAodGhpcy5hY3RpdmUpIHtcbiAgICAvLyByZW1vdmUgc2VsZiBmcm9tIHZtJ3Mgd2F0Y2hlciBsaXN0XG4gICAgLy8gdGhpcyBpcyBhIHNvbWV3aGF0IGV4cGVuc2l2ZSBvcGVyYXRpb24gc28gd2Ugc2tpcCBpdFxuICAgIC8vIGlmIHRoZSB2bSBpcyBiZWluZyBkZXN0cm95ZWQuXG4gICAgaWYgKCF0aGlzLnZtLl9pc0JlaW5nRGVzdHJveWVkKSB7XG4gICAgICByZW1vdmUodGhpcy52bS5fd2F0Y2hlcnMsIHRoaXMpO1xuICAgIH1cbiAgICB2YXIgaSA9IHRoaXMuZGVwcy5sZW5ndGg7XG4gICAgd2hpbGUgKGktLSkge1xuICAgICAgdGhpcy5kZXBzW2ldLnJlbW92ZVN1Yih0aGlzKTtcbiAgICB9XG4gICAgdGhpcy5hY3RpdmUgPSBmYWxzZTtcbiAgfVxufTtcblxuLyogICovXG5cbnZhciBzaGFyZWRQcm9wZXJ0eURlZmluaXRpb24gPSB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBub29wLFxuICBzZXQ6IG5vb3Bcbn07XG5cbmZ1bmN0aW9uIHByb3h5ICh0YXJnZXQsIHNvdXJjZUtleSwga2V5KSB7XG4gIHNoYXJlZFByb3BlcnR5RGVmaW5pdGlvbi5nZXQgPSBmdW5jdGlvbiBwcm94eUdldHRlciAoKSB7XG4gICAgcmV0dXJuIHRoaXNbc291cmNlS2V5XVtrZXldXG4gIH07XG4gIHNoYXJlZFByb3BlcnR5RGVmaW5pdGlvbi5zZXQgPSBmdW5jdGlvbiBwcm94eVNldHRlciAodmFsKSB7XG4gICAgdGhpc1tzb3VyY2VLZXldW2tleV0gPSB2YWw7XG4gIH07XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgc2hhcmVkUHJvcGVydHlEZWZpbml0aW9uKTtcbn1cblxuZnVuY3Rpb24gaW5pdFN0YXRlICh2bSkge1xuICB2bS5fd2F0Y2hlcnMgPSBbXTtcbiAgdmFyIG9wdHMgPSB2bS4kb3B0aW9ucztcbiAgaWYgKG9wdHMucHJvcHMpIHsgaW5pdFByb3BzKHZtLCBvcHRzLnByb3BzKTsgfVxuICBpZiAob3B0cy5tZXRob2RzKSB7IGluaXRNZXRob2RzKHZtLCBvcHRzLm1ldGhvZHMpOyB9XG4gIGlmIChvcHRzLmRhdGEpIHtcbiAgICBpbml0RGF0YSh2bSk7XG4gIH0gZWxzZSB7XG4gICAgb2JzZXJ2ZSh2bS5fZGF0YSA9IHt9LCB0cnVlIC8qIGFzUm9vdERhdGEgKi8pO1xuICB9XG4gIGlmIChvcHRzLmNvbXB1dGVkKSB7IGluaXRDb21wdXRlZCh2bSwgb3B0cy5jb21wdXRlZCk7IH1cbiAgaWYgKG9wdHMud2F0Y2ggJiYgb3B0cy53YXRjaCAhPT0gbmF0aXZlV2F0Y2gpIHtcbiAgICBpbml0V2F0Y2godm0sIG9wdHMud2F0Y2gpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGluaXRQcm9wcyAodm0sIHByb3BzT3B0aW9ucykge1xuICB2YXIgcHJvcHNEYXRhID0gdm0uJG9wdGlvbnMucHJvcHNEYXRhIHx8IHt9O1xuICB2YXIgcHJvcHMgPSB2bS5fcHJvcHMgPSB7fTtcbiAgLy8gY2FjaGUgcHJvcCBrZXlzIHNvIHRoYXQgZnV0dXJlIHByb3BzIHVwZGF0ZXMgY2FuIGl0ZXJhdGUgdXNpbmcgQXJyYXlcbiAgLy8gaW5zdGVhZCBvZiBkeW5hbWljIG9iamVjdCBrZXkgZW51bWVyYXRpb24uXG4gIHZhciBrZXlzID0gdm0uJG9wdGlvbnMuX3Byb3BLZXlzID0gW107XG4gIHZhciBpc1Jvb3QgPSAhdm0uJHBhcmVudDtcbiAgLy8gcm9vdCBpbnN0YW5jZSBwcm9wcyBzaG91bGQgYmUgY29udmVydGVkXG4gIGlmICghaXNSb290KSB7XG4gICAgdG9nZ2xlT2JzZXJ2aW5nKGZhbHNlKTtcbiAgfVxuICB2YXIgbG9vcCA9IGZ1bmN0aW9uICgga2V5ICkge1xuICAgIGtleXMucHVzaChrZXkpO1xuICAgIHZhciB2YWx1ZSA9IHZhbGlkYXRlUHJvcChrZXksIHByb3BzT3B0aW9ucywgcHJvcHNEYXRhLCB2bSk7XG4gICAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgdmFyIGh5cGhlbmF0ZWRLZXkgPSBoeXBoZW5hdGUoa2V5KTtcbiAgICAgIGlmIChpc1Jlc2VydmVkQXR0cmlidXRlKGh5cGhlbmF0ZWRLZXkpIHx8XG4gICAgICAgICAgY29uZmlnLmlzUmVzZXJ2ZWRBdHRyKGh5cGhlbmF0ZWRLZXkpKSB7XG4gICAgICAgIHdhcm4oXG4gICAgICAgICAgKFwiXFxcIlwiICsgaHlwaGVuYXRlZEtleSArIFwiXFxcIiBpcyBhIHJlc2VydmVkIGF0dHJpYnV0ZSBhbmQgY2Fubm90IGJlIHVzZWQgYXMgY29tcG9uZW50IHByb3AuXCIpLFxuICAgICAgICAgIHZtXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICBkZWZpbmVSZWFjdGl2ZSQkMShwcm9wcywga2V5LCB2YWx1ZSwgZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoIWlzUm9vdCAmJiAhaXNVcGRhdGluZ0NoaWxkQ29tcG9uZW50KSB7XG4gICAgICAgICAgd2FybihcbiAgICAgICAgICAgIFwiQXZvaWQgbXV0YXRpbmcgYSBwcm9wIGRpcmVjdGx5IHNpbmNlIHRoZSB2YWx1ZSB3aWxsIGJlIFwiICtcbiAgICAgICAgICAgIFwib3ZlcndyaXR0ZW4gd2hlbmV2ZXIgdGhlIHBhcmVudCBjb21wb25lbnQgcmUtcmVuZGVycy4gXCIgK1xuICAgICAgICAgICAgXCJJbnN0ZWFkLCB1c2UgYSBkYXRhIG9yIGNvbXB1dGVkIHByb3BlcnR5IGJhc2VkIG9uIHRoZSBwcm9wJ3MgXCIgK1xuICAgICAgICAgICAgXCJ2YWx1ZS4gUHJvcCBiZWluZyBtdXRhdGVkOiBcXFwiXCIgKyBrZXkgKyBcIlxcXCJcIixcbiAgICAgICAgICAgIHZtXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGRlZmluZVJlYWN0aXZlJCQxKHByb3BzLCBrZXksIHZhbHVlKTtcbiAgICB9XG4gICAgLy8gc3RhdGljIHByb3BzIGFyZSBhbHJlYWR5IHByb3hpZWQgb24gdGhlIGNvbXBvbmVudCdzIHByb3RvdHlwZVxuICAgIC8vIGR1cmluZyBWdWUuZXh0ZW5kKCkuIFdlIG9ubHkgbmVlZCB0byBwcm94eSBwcm9wcyBkZWZpbmVkIGF0XG4gICAgLy8gaW5zdGFudGlhdGlvbiBoZXJlLlxuICAgIGlmICghKGtleSBpbiB2bSkpIHtcbiAgICAgIHByb3h5KHZtLCBcIl9wcm9wc1wiLCBrZXkpO1xuICAgIH1cbiAgfTtcblxuICBmb3IgKHZhciBrZXkgaW4gcHJvcHNPcHRpb25zKSBsb29wKCBrZXkgKTtcbiAgdG9nZ2xlT2JzZXJ2aW5nKHRydWUpO1xufVxuXG5mdW5jdGlvbiBpbml0RGF0YSAodm0pIHtcbiAgdmFyIGRhdGEgPSB2bS4kb3B0aW9ucy5kYXRhO1xuICBkYXRhID0gdm0uX2RhdGEgPSB0eXBlb2YgZGF0YSA9PT0gJ2Z1bmN0aW9uJ1xuICAgID8gZ2V0RGF0YShkYXRhLCB2bSlcbiAgICA6IGRhdGEgfHwge307XG4gIGlmICghaXNQbGFpbk9iamVjdChkYXRhKSkge1xuICAgIGRhdGEgPSB7fTtcbiAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIHdhcm4oXG4gICAgICAnZGF0YSBmdW5jdGlvbnMgc2hvdWxkIHJldHVybiBhbiBvYmplY3Q6XFxuJyArXG4gICAgICAnaHR0cHM6Ly92dWVqcy5vcmcvdjIvZ3VpZGUvY29tcG9uZW50cy5odG1sI2RhdGEtTXVzdC1CZS1hLUZ1bmN0aW9uJyxcbiAgICAgIHZtXG4gICAgKTtcbiAgfVxuICAvLyBwcm94eSBkYXRhIG9uIGluc3RhbmNlXG4gIHZhciBrZXlzID0gT2JqZWN0LmtleXMoZGF0YSk7XG4gIHZhciBwcm9wcyA9IHZtLiRvcHRpb25zLnByb3BzO1xuICB2YXIgbWV0aG9kcyA9IHZtLiRvcHRpb25zLm1ldGhvZHM7XG4gIHZhciBpID0ga2V5cy5sZW5ndGg7XG4gIHdoaWxlIChpLS0pIHtcbiAgICB2YXIga2V5ID0ga2V5c1tpXTtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgaWYgKG1ldGhvZHMgJiYgaGFzT3duKG1ldGhvZHMsIGtleSkpIHtcbiAgICAgICAgd2FybihcbiAgICAgICAgICAoXCJNZXRob2QgXFxcIlwiICsga2V5ICsgXCJcXFwiIGhhcyBhbHJlYWR5IGJlZW4gZGVmaW5lZCBhcyBhIGRhdGEgcHJvcGVydHkuXCIpLFxuICAgICAgICAgIHZtXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChwcm9wcyAmJiBoYXNPd24ocHJvcHMsIGtleSkpIHtcbiAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgd2FybihcbiAgICAgICAgXCJUaGUgZGF0YSBwcm9wZXJ0eSBcXFwiXCIgKyBrZXkgKyBcIlxcXCIgaXMgYWxyZWFkeSBkZWNsYXJlZCBhcyBhIHByb3AuIFwiICtcbiAgICAgICAgXCJVc2UgcHJvcCBkZWZhdWx0IHZhbHVlIGluc3RlYWQuXCIsXG4gICAgICAgIHZtXG4gICAgICApO1xuICAgIH0gZWxzZSBpZiAoIWlzUmVzZXJ2ZWQoa2V5KSkge1xuICAgICAgcHJveHkodm0sIFwiX2RhdGFcIiwga2V5KTtcbiAgICB9XG4gIH1cbiAgLy8gb2JzZXJ2ZSBkYXRhXG4gIG9ic2VydmUoZGF0YSwgdHJ1ZSAvKiBhc1Jvb3REYXRhICovKTtcbn1cblxuZnVuY3Rpb24gZ2V0RGF0YSAoZGF0YSwgdm0pIHtcbiAgLy8gIzc1NzMgZGlzYWJsZSBkZXAgY29sbGVjdGlvbiB3aGVuIGludm9raW5nIGRhdGEgZ2V0dGVyc1xuICBwdXNoVGFyZ2V0KCk7XG4gIHRyeSB7XG4gICAgcmV0dXJuIGRhdGEuY2FsbCh2bSwgdm0pXG4gIH0gY2F0Y2ggKGUpIHtcbiAgICBoYW5kbGVFcnJvcihlLCB2bSwgXCJkYXRhKClcIik7XG4gICAgcmV0dXJuIHt9XG4gIH0gZmluYWxseSB7XG4gICAgcG9wVGFyZ2V0KCk7XG4gIH1cbn1cblxudmFyIGNvbXB1dGVkV2F0Y2hlck9wdGlvbnMgPSB7IGxhenk6IHRydWUgfTtcblxuZnVuY3Rpb24gaW5pdENvbXB1dGVkICh2bSwgY29tcHV0ZWQpIHtcbiAgLy8gJGZsb3ctZGlzYWJsZS1saW5lXG4gIHZhciB3YXRjaGVycyA9IHZtLl9jb21wdXRlZFdhdGNoZXJzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgLy8gY29tcHV0ZWQgcHJvcGVydGllcyBhcmUganVzdCBnZXR0ZXJzIGR1cmluZyBTU1JcbiAgdmFyIGlzU1NSID0gaXNTZXJ2ZXJSZW5kZXJpbmcoKTtcblxuICBmb3IgKHZhciBrZXkgaW4gY29tcHV0ZWQpIHtcbiAgICB2YXIgdXNlckRlZiA9IGNvbXB1dGVkW2tleV07XG4gICAgdmFyIGdldHRlciA9IHR5cGVvZiB1c2VyRGVmID09PSAnZnVuY3Rpb24nID8gdXNlckRlZiA6IHVzZXJEZWYuZ2V0O1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIGdldHRlciA9PSBudWxsKSB7XG4gICAgICB3YXJuKFxuICAgICAgICAoXCJHZXR0ZXIgaXMgbWlzc2luZyBmb3IgY29tcHV0ZWQgcHJvcGVydHkgXFxcIlwiICsga2V5ICsgXCJcXFwiLlwiKSxcbiAgICAgICAgdm1cbiAgICAgICk7XG4gICAgfVxuXG4gICAgaWYgKCFpc1NTUikge1xuICAgICAgLy8gY3JlYXRlIGludGVybmFsIHdhdGNoZXIgZm9yIHRoZSBjb21wdXRlZCBwcm9wZXJ0eS5cbiAgICAgIHdhdGNoZXJzW2tleV0gPSBuZXcgV2F0Y2hlcihcbiAgICAgICAgdm0sXG4gICAgICAgIGdldHRlciB8fCBub29wLFxuICAgICAgICBub29wLFxuICAgICAgICBjb21wdXRlZFdhdGNoZXJPcHRpb25zXG4gICAgICApO1xuICAgIH1cblxuICAgIC8vIGNvbXBvbmVudC1kZWZpbmVkIGNvbXB1dGVkIHByb3BlcnRpZXMgYXJlIGFscmVhZHkgZGVmaW5lZCBvbiB0aGVcbiAgICAvLyBjb21wb25lbnQgcHJvdG90eXBlLiBXZSBvbmx5IG5lZWQgdG8gZGVmaW5lIGNvbXB1dGVkIHByb3BlcnRpZXMgZGVmaW5lZFxuICAgIC8vIGF0IGluc3RhbnRpYXRpb24gaGVyZS5cbiAgICBpZiAoIShrZXkgaW4gdm0pKSB7XG4gICAgICBkZWZpbmVDb21wdXRlZCh2bSwga2V5LCB1c2VyRGVmKTtcbiAgICB9IGVsc2UgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIGlmIChrZXkgaW4gdm0uJGRhdGEpIHtcbiAgICAgICAgd2FybigoXCJUaGUgY29tcHV0ZWQgcHJvcGVydHkgXFxcIlwiICsga2V5ICsgXCJcXFwiIGlzIGFscmVhZHkgZGVmaW5lZCBpbiBkYXRhLlwiKSwgdm0pO1xuICAgICAgfSBlbHNlIGlmICh2bS4kb3B0aW9ucy5wcm9wcyAmJiBrZXkgaW4gdm0uJG9wdGlvbnMucHJvcHMpIHtcbiAgICAgICAgd2FybigoXCJUaGUgY29tcHV0ZWQgcHJvcGVydHkgXFxcIlwiICsga2V5ICsgXCJcXFwiIGlzIGFscmVhZHkgZGVmaW5lZCBhcyBhIHByb3AuXCIpLCB2bSk7XG4gICAgICB9IGVsc2UgaWYgKHZtLiRvcHRpb25zLm1ldGhvZHMgJiYga2V5IGluIHZtLiRvcHRpb25zLm1ldGhvZHMpIHtcbiAgICAgICAgd2FybigoXCJUaGUgY29tcHV0ZWQgcHJvcGVydHkgXFxcIlwiICsga2V5ICsgXCJcXFwiIGlzIGFscmVhZHkgZGVmaW5lZCBhcyBhIG1ldGhvZC5cIiksIHZtKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gZGVmaW5lQ29tcHV0ZWQgKFxuICB0YXJnZXQsXG4gIGtleSxcbiAgdXNlckRlZlxuKSB7XG4gIHZhciBzaG91bGRDYWNoZSA9ICFpc1NlcnZlclJlbmRlcmluZygpO1xuICBpZiAodHlwZW9mIHVzZXJEZWYgPT09ICdmdW5jdGlvbicpIHtcbiAgICBzaGFyZWRQcm9wZXJ0eURlZmluaXRpb24uZ2V0ID0gc2hvdWxkQ2FjaGVcbiAgICAgID8gY3JlYXRlQ29tcHV0ZWRHZXR0ZXIoa2V5KVxuICAgICAgOiBjcmVhdGVHZXR0ZXJJbnZva2VyKHVzZXJEZWYpO1xuICAgIHNoYXJlZFByb3BlcnR5RGVmaW5pdGlvbi5zZXQgPSBub29wO1xuICB9IGVsc2Uge1xuICAgIHNoYXJlZFByb3BlcnR5RGVmaW5pdGlvbi5nZXQgPSB1c2VyRGVmLmdldFxuICAgICAgPyBzaG91bGRDYWNoZSAmJiB1c2VyRGVmLmNhY2hlICE9PSBmYWxzZVxuICAgICAgICA/IGNyZWF0ZUNvbXB1dGVkR2V0dGVyKGtleSlcbiAgICAgICAgOiBjcmVhdGVHZXR0ZXJJbnZva2VyKHVzZXJEZWYuZ2V0KVxuICAgICAgOiBub29wO1xuICAgIHNoYXJlZFByb3BlcnR5RGVmaW5pdGlvbi5zZXQgPSB1c2VyRGVmLnNldCB8fCBub29wO1xuICB9XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmXG4gICAgICBzaGFyZWRQcm9wZXJ0eURlZmluaXRpb24uc2V0ID09PSBub29wKSB7XG4gICAgc2hhcmVkUHJvcGVydHlEZWZpbml0aW9uLnNldCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHdhcm4oXG4gICAgICAgIChcIkNvbXB1dGVkIHByb3BlcnR5IFxcXCJcIiArIGtleSArIFwiXFxcIiB3YXMgYXNzaWduZWQgdG8gYnV0IGl0IGhhcyBubyBzZXR0ZXIuXCIpLFxuICAgICAgICB0aGlzXG4gICAgICApO1xuICAgIH07XG4gIH1cbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCBzaGFyZWRQcm9wZXJ0eURlZmluaXRpb24pO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVDb21wdXRlZEdldHRlciAoa2V5KSB7XG4gIHJldHVybiBmdW5jdGlvbiBjb21wdXRlZEdldHRlciAoKSB7XG4gICAgdmFyIHdhdGNoZXIgPSB0aGlzLl9jb21wdXRlZFdhdGNoZXJzICYmIHRoaXMuX2NvbXB1dGVkV2F0Y2hlcnNba2V5XTtcbiAgICBpZiAod2F0Y2hlcikge1xuICAgICAgaWYgKHdhdGNoZXIuZGlydHkpIHtcbiAgICAgICAgd2F0Y2hlci5ldmFsdWF0ZSgpO1xuICAgICAgfVxuICAgICAgaWYgKERlcC50YXJnZXQpIHtcbiAgICAgICAgd2F0Y2hlci5kZXBlbmQoKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB3YXRjaGVyLnZhbHVlXG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUdldHRlckludm9rZXIoZm4pIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIGNvbXB1dGVkR2V0dGVyICgpIHtcbiAgICByZXR1cm4gZm4uY2FsbCh0aGlzLCB0aGlzKVxuICB9XG59XG5cbmZ1bmN0aW9uIGluaXRNZXRob2RzICh2bSwgbWV0aG9kcykge1xuICB2YXIgcHJvcHMgPSB2bS4kb3B0aW9ucy5wcm9wcztcbiAgZm9yICh2YXIga2V5IGluIG1ldGhvZHMpIHtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgaWYgKHR5cGVvZiBtZXRob2RzW2tleV0gIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgd2FybihcbiAgICAgICAgICBcIk1ldGhvZCBcXFwiXCIgKyBrZXkgKyBcIlxcXCIgaGFzIHR5cGUgXFxcIlwiICsgKHR5cGVvZiBtZXRob2RzW2tleV0pICsgXCJcXFwiIGluIHRoZSBjb21wb25lbnQgZGVmaW5pdGlvbi4gXCIgK1xuICAgICAgICAgIFwiRGlkIHlvdSByZWZlcmVuY2UgdGhlIGZ1bmN0aW9uIGNvcnJlY3RseT9cIixcbiAgICAgICAgICB2bVxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgaWYgKHByb3BzICYmIGhhc093bihwcm9wcywga2V5KSkge1xuICAgICAgICB3YXJuKFxuICAgICAgICAgIChcIk1ldGhvZCBcXFwiXCIgKyBrZXkgKyBcIlxcXCIgaGFzIGFscmVhZHkgYmVlbiBkZWZpbmVkIGFzIGEgcHJvcC5cIiksXG4gICAgICAgICAgdm1cbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIGlmICgoa2V5IGluIHZtKSAmJiBpc1Jlc2VydmVkKGtleSkpIHtcbiAgICAgICAgd2FybihcbiAgICAgICAgICBcIk1ldGhvZCBcXFwiXCIgKyBrZXkgKyBcIlxcXCIgY29uZmxpY3RzIHdpdGggYW4gZXhpc3RpbmcgVnVlIGluc3RhbmNlIG1ldGhvZC4gXCIgK1xuICAgICAgICAgIFwiQXZvaWQgZGVmaW5pbmcgY29tcG9uZW50IG1ldGhvZHMgdGhhdCBzdGFydCB3aXRoIF8gb3IgJC5cIlxuICAgICAgICApO1xuICAgICAgfVxuICAgIH1cbiAgICB2bVtrZXldID0gdHlwZW9mIG1ldGhvZHNba2V5XSAhPT0gJ2Z1bmN0aW9uJyA/IG5vb3AgOiBiaW5kKG1ldGhvZHNba2V5XSwgdm0pO1xuICB9XG59XG5cbmZ1bmN0aW9uIGluaXRXYXRjaCAodm0sIHdhdGNoKSB7XG4gIGZvciAodmFyIGtleSBpbiB3YXRjaCkge1xuICAgIHZhciBoYW5kbGVyID0gd2F0Y2hba2V5XTtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShoYW5kbGVyKSkge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBoYW5kbGVyLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNyZWF0ZVdhdGNoZXIodm0sIGtleSwgaGFuZGxlcltpXSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGNyZWF0ZVdhdGNoZXIodm0sIGtleSwgaGFuZGxlcik7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZVdhdGNoZXIgKFxuICB2bSxcbiAgZXhwT3JGbixcbiAgaGFuZGxlcixcbiAgb3B0aW9uc1xuKSB7XG4gIGlmIChpc1BsYWluT2JqZWN0KGhhbmRsZXIpKSB7XG4gICAgb3B0aW9ucyA9IGhhbmRsZXI7XG4gICAgaGFuZGxlciA9IGhhbmRsZXIuaGFuZGxlcjtcbiAgfVxuICBpZiAodHlwZW9mIGhhbmRsZXIgPT09ICdzdHJpbmcnKSB7XG4gICAgaGFuZGxlciA9IHZtW2hhbmRsZXJdO1xuICB9XG4gIHJldHVybiB2bS4kd2F0Y2goZXhwT3JGbiwgaGFuZGxlciwgb3B0aW9ucylcbn1cblxuZnVuY3Rpb24gc3RhdGVNaXhpbiAoVnVlKSB7XG4gIC8vIGZsb3cgc29tZWhvdyBoYXMgcHJvYmxlbXMgd2l0aCBkaXJlY3RseSBkZWNsYXJlZCBkZWZpbml0aW9uIG9iamVjdFxuICAvLyB3aGVuIHVzaW5nIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSwgc28gd2UgaGF2ZSB0byBwcm9jZWR1cmFsbHkgYnVpbGQgdXBcbiAgLy8gdGhlIG9iamVjdCBoZXJlLlxuICB2YXIgZGF0YURlZiA9IHt9O1xuICBkYXRhRGVmLmdldCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX2RhdGEgfTtcbiAgdmFyIHByb3BzRGVmID0ge307XG4gIHByb3BzRGVmLmdldCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX3Byb3BzIH07XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgZGF0YURlZi5zZXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICB3YXJuKFxuICAgICAgICAnQXZvaWQgcmVwbGFjaW5nIGluc3RhbmNlIHJvb3QgJGRhdGEuICcgK1xuICAgICAgICAnVXNlIG5lc3RlZCBkYXRhIHByb3BlcnRpZXMgaW5zdGVhZC4nLFxuICAgICAgICB0aGlzXG4gICAgICApO1xuICAgIH07XG4gICAgcHJvcHNEZWYuc2V0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgd2FybihcIiRwcm9wcyBpcyByZWFkb25seS5cIiwgdGhpcyk7XG4gICAgfTtcbiAgfVxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVnVlLnByb3RvdHlwZSwgJyRkYXRhJywgZGF0YURlZik7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShWdWUucHJvdG90eXBlLCAnJHByb3BzJywgcHJvcHNEZWYpO1xuXG4gIFZ1ZS5wcm90b3R5cGUuJHNldCA9IHNldDtcbiAgVnVlLnByb3RvdHlwZS4kZGVsZXRlID0gZGVsO1xuXG4gIFZ1ZS5wcm90b3R5cGUuJHdhdGNoID0gZnVuY3Rpb24gKFxuICAgIGV4cE9yRm4sXG4gICAgY2IsXG4gICAgb3B0aW9uc1xuICApIHtcbiAgICB2YXIgdm0gPSB0aGlzO1xuICAgIGlmIChpc1BsYWluT2JqZWN0KGNiKSkge1xuICAgICAgcmV0dXJuIGNyZWF0ZVdhdGNoZXIodm0sIGV4cE9yRm4sIGNiLCBvcHRpb25zKVxuICAgIH1cbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgICBvcHRpb25zLnVzZXIgPSB0cnVlO1xuICAgIHZhciB3YXRjaGVyID0gbmV3IFdhdGNoZXIodm0sIGV4cE9yRm4sIGNiLCBvcHRpb25zKTtcbiAgICBpZiAob3B0aW9ucy5pbW1lZGlhdGUpIHtcbiAgICAgIHZhciBpbmZvID0gXCJjYWxsYmFjayBmb3IgaW1tZWRpYXRlIHdhdGNoZXIgXFxcIlwiICsgKHdhdGNoZXIuZXhwcmVzc2lvbikgKyBcIlxcXCJcIjtcbiAgICAgIHB1c2hUYXJnZXQoKTtcbiAgICAgIGludm9rZVdpdGhFcnJvckhhbmRsaW5nKGNiLCB2bSwgW3dhdGNoZXIudmFsdWVdLCB2bSwgaW5mbyk7XG4gICAgICBwb3BUYXJnZXQoKTtcbiAgICB9XG4gICAgcmV0dXJuIGZ1bmN0aW9uIHVud2F0Y2hGbiAoKSB7XG4gICAgICB3YXRjaGVyLnRlYXJkb3duKCk7XG4gICAgfVxuICB9O1xufVxuXG4vKiAgKi9cblxudmFyIHVpZCQzID0gMDtcblxuZnVuY3Rpb24gaW5pdE1peGluIChWdWUpIHtcbiAgVnVlLnByb3RvdHlwZS5faW5pdCA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgdmFyIHZtID0gdGhpcztcbiAgICAvLyBhIHVpZFxuICAgIHZtLl91aWQgPSB1aWQkMysrO1xuXG4gICAgdmFyIHN0YXJ0VGFnLCBlbmRUYWc7XG4gICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgY29uZmlnLnBlcmZvcm1hbmNlICYmIG1hcmspIHtcbiAgICAgIHN0YXJ0VGFnID0gXCJ2dWUtcGVyZi1zdGFydDpcIiArICh2bS5fdWlkKTtcbiAgICAgIGVuZFRhZyA9IFwidnVlLXBlcmYtZW5kOlwiICsgKHZtLl91aWQpO1xuICAgICAgbWFyayhzdGFydFRhZyk7XG4gICAgfVxuXG4gICAgLy8gYSBmbGFnIHRvIGF2b2lkIHRoaXMgYmVpbmcgb2JzZXJ2ZWRcbiAgICB2bS5faXNWdWUgPSB0cnVlO1xuICAgIC8vIG1lcmdlIG9wdGlvbnNcbiAgICBpZiAob3B0aW9ucyAmJiBvcHRpb25zLl9pc0NvbXBvbmVudCkge1xuICAgICAgLy8gb3B0aW1pemUgaW50ZXJuYWwgY29tcG9uZW50IGluc3RhbnRpYXRpb25cbiAgICAgIC8vIHNpbmNlIGR5bmFtaWMgb3B0aW9ucyBtZXJnaW5nIGlzIHByZXR0eSBzbG93LCBhbmQgbm9uZSBvZiB0aGVcbiAgICAgIC8vIGludGVybmFsIGNvbXBvbmVudCBvcHRpb25zIG5lZWRzIHNwZWNpYWwgdHJlYXRtZW50LlxuICAgICAgaW5pdEludGVybmFsQ29tcG9uZW50KHZtLCBvcHRpb25zKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdm0uJG9wdGlvbnMgPSBtZXJnZU9wdGlvbnMoXG4gICAgICAgIHJlc29sdmVDb25zdHJ1Y3Rvck9wdGlvbnModm0uY29uc3RydWN0b3IpLFxuICAgICAgICBvcHRpb25zIHx8IHt9LFxuICAgICAgICB2bVxuICAgICAgKTtcbiAgICB9XG4gICAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgaW5pdFByb3h5KHZtKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdm0uX3JlbmRlclByb3h5ID0gdm07XG4gICAgfVxuICAgIC8vIGV4cG9zZSByZWFsIHNlbGZcbiAgICB2bS5fc2VsZiA9IHZtO1xuICAgIGluaXRMaWZlY3ljbGUodm0pO1xuICAgIGluaXRFdmVudHModm0pO1xuICAgIGluaXRSZW5kZXIodm0pO1xuICAgIGNhbGxIb29rKHZtLCAnYmVmb3JlQ3JlYXRlJyk7XG4gICAgaW5pdEluamVjdGlvbnModm0pOyAvLyByZXNvbHZlIGluamVjdGlvbnMgYmVmb3JlIGRhdGEvcHJvcHNcbiAgICBpbml0U3RhdGUodm0pO1xuICAgIGluaXRQcm92aWRlKHZtKTsgLy8gcmVzb2x2ZSBwcm92aWRlIGFmdGVyIGRhdGEvcHJvcHNcbiAgICBjYWxsSG9vayh2bSwgJ2NyZWF0ZWQnKTtcblxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIGNvbmZpZy5wZXJmb3JtYW5jZSAmJiBtYXJrKSB7XG4gICAgICB2bS5fbmFtZSA9IGZvcm1hdENvbXBvbmVudE5hbWUodm0sIGZhbHNlKTtcbiAgICAgIG1hcmsoZW5kVGFnKTtcbiAgICAgIG1lYXN1cmUoKFwidnVlIFwiICsgKHZtLl9uYW1lKSArIFwiIGluaXRcIiksIHN0YXJ0VGFnLCBlbmRUYWcpO1xuICAgIH1cblxuICAgIGlmICh2bS4kb3B0aW9ucy5lbCkge1xuICAgICAgdm0uJG1vdW50KHZtLiRvcHRpb25zLmVsKTtcbiAgICB9XG4gIH07XG59XG5cbmZ1bmN0aW9uIGluaXRJbnRlcm5hbENvbXBvbmVudCAodm0sIG9wdGlvbnMpIHtcbiAgdmFyIG9wdHMgPSB2bS4kb3B0aW9ucyA9IE9iamVjdC5jcmVhdGUodm0uY29uc3RydWN0b3Iub3B0aW9ucyk7XG4gIC8vIGRvaW5nIHRoaXMgYmVjYXVzZSBpdCdzIGZhc3RlciB0aGFuIGR5bmFtaWMgZW51bWVyYXRpb24uXG4gIHZhciBwYXJlbnRWbm9kZSA9IG9wdGlvbnMuX3BhcmVudFZub2RlO1xuICBvcHRzLnBhcmVudCA9IG9wdGlvbnMucGFyZW50O1xuICBvcHRzLl9wYXJlbnRWbm9kZSA9IHBhcmVudFZub2RlO1xuXG4gIHZhciB2bm9kZUNvbXBvbmVudE9wdGlvbnMgPSBwYXJlbnRWbm9kZS5jb21wb25lbnRPcHRpb25zO1xuICBvcHRzLnByb3BzRGF0YSA9IHZub2RlQ29tcG9uZW50T3B0aW9ucy5wcm9wc0RhdGE7XG4gIG9wdHMuX3BhcmVudExpc3RlbmVycyA9IHZub2RlQ29tcG9uZW50T3B0aW9ucy5saXN0ZW5lcnM7XG4gIG9wdHMuX3JlbmRlckNoaWxkcmVuID0gdm5vZGVDb21wb25lbnRPcHRpb25zLmNoaWxkcmVuO1xuICBvcHRzLl9jb21wb25lbnRUYWcgPSB2bm9kZUNvbXBvbmVudE9wdGlvbnMudGFnO1xuXG4gIGlmIChvcHRpb25zLnJlbmRlcikge1xuICAgIG9wdHMucmVuZGVyID0gb3B0aW9ucy5yZW5kZXI7XG4gICAgb3B0cy5zdGF0aWNSZW5kZXJGbnMgPSBvcHRpb25zLnN0YXRpY1JlbmRlckZucztcbiAgfVxufVxuXG5mdW5jdGlvbiByZXNvbHZlQ29uc3RydWN0b3JPcHRpb25zIChDdG9yKSB7XG4gIHZhciBvcHRpb25zID0gQ3Rvci5vcHRpb25zO1xuICBpZiAoQ3Rvci5zdXBlcikge1xuICAgIHZhciBzdXBlck9wdGlvbnMgPSByZXNvbHZlQ29uc3RydWN0b3JPcHRpb25zKEN0b3Iuc3VwZXIpO1xuICAgIHZhciBjYWNoZWRTdXBlck9wdGlvbnMgPSBDdG9yLnN1cGVyT3B0aW9ucztcbiAgICBpZiAoc3VwZXJPcHRpb25zICE9PSBjYWNoZWRTdXBlck9wdGlvbnMpIHtcbiAgICAgIC8vIHN1cGVyIG9wdGlvbiBjaGFuZ2VkLFxuICAgICAgLy8gbmVlZCB0byByZXNvbHZlIG5ldyBvcHRpb25zLlxuICAgICAgQ3Rvci5zdXBlck9wdGlvbnMgPSBzdXBlck9wdGlvbnM7XG4gICAgICAvLyBjaGVjayBpZiB0aGVyZSBhcmUgYW55IGxhdGUtbW9kaWZpZWQvYXR0YWNoZWQgb3B0aW9ucyAoIzQ5NzYpXG4gICAgICB2YXIgbW9kaWZpZWRPcHRpb25zID0gcmVzb2x2ZU1vZGlmaWVkT3B0aW9ucyhDdG9yKTtcbiAgICAgIC8vIHVwZGF0ZSBiYXNlIGV4dGVuZCBvcHRpb25zXG4gICAgICBpZiAobW9kaWZpZWRPcHRpb25zKSB7XG4gICAgICAgIGV4dGVuZChDdG9yLmV4dGVuZE9wdGlvbnMsIG1vZGlmaWVkT3B0aW9ucyk7XG4gICAgICB9XG4gICAgICBvcHRpb25zID0gQ3Rvci5vcHRpb25zID0gbWVyZ2VPcHRpb25zKHN1cGVyT3B0aW9ucywgQ3Rvci5leHRlbmRPcHRpb25zKTtcbiAgICAgIGlmIChvcHRpb25zLm5hbWUpIHtcbiAgICAgICAgb3B0aW9ucy5jb21wb25lbnRzW29wdGlvbnMubmFtZV0gPSBDdG9yO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gb3B0aW9uc1xufVxuXG5mdW5jdGlvbiByZXNvbHZlTW9kaWZpZWRPcHRpb25zIChDdG9yKSB7XG4gIHZhciBtb2RpZmllZDtcbiAgdmFyIGxhdGVzdCA9IEN0b3Iub3B0aW9ucztcbiAgdmFyIHNlYWxlZCA9IEN0b3Iuc2VhbGVkT3B0aW9ucztcbiAgZm9yICh2YXIga2V5IGluIGxhdGVzdCkge1xuICAgIGlmIChsYXRlc3Rba2V5XSAhPT0gc2VhbGVkW2tleV0pIHtcbiAgICAgIGlmICghbW9kaWZpZWQpIHsgbW9kaWZpZWQgPSB7fTsgfVxuICAgICAgbW9kaWZpZWRba2V5XSA9IGxhdGVzdFtrZXldO1xuICAgIH1cbiAgfVxuICByZXR1cm4gbW9kaWZpZWRcbn1cblxuZnVuY3Rpb24gVnVlIChvcHRpb25zKSB7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmXG4gICAgISh0aGlzIGluc3RhbmNlb2YgVnVlKVxuICApIHtcbiAgICB3YXJuKCdWdWUgaXMgYSBjb25zdHJ1Y3RvciBhbmQgc2hvdWxkIGJlIGNhbGxlZCB3aXRoIHRoZSBgbmV3YCBrZXl3b3JkJyk7XG4gIH1cbiAgdGhpcy5faW5pdChvcHRpb25zKTtcbn1cblxuaW5pdE1peGluKFZ1ZSk7XG5zdGF0ZU1peGluKFZ1ZSk7XG5ldmVudHNNaXhpbihWdWUpO1xubGlmZWN5Y2xlTWl4aW4oVnVlKTtcbnJlbmRlck1peGluKFZ1ZSk7XG5cbi8qICAqL1xuXG5mdW5jdGlvbiBpbml0VXNlIChWdWUpIHtcbiAgVnVlLnVzZSA9IGZ1bmN0aW9uIChwbHVnaW4pIHtcbiAgICB2YXIgaW5zdGFsbGVkUGx1Z2lucyA9ICh0aGlzLl9pbnN0YWxsZWRQbHVnaW5zIHx8ICh0aGlzLl9pbnN0YWxsZWRQbHVnaW5zID0gW10pKTtcbiAgICBpZiAoaW5zdGFsbGVkUGx1Z2lucy5pbmRleE9mKHBsdWdpbikgPiAtMSkge1xuICAgICAgcmV0dXJuIHRoaXNcbiAgICB9XG5cbiAgICAvLyBhZGRpdGlvbmFsIHBhcmFtZXRlcnNcbiAgICB2YXIgYXJncyA9IHRvQXJyYXkoYXJndW1lbnRzLCAxKTtcbiAgICBhcmdzLnVuc2hpZnQodGhpcyk7XG4gICAgaWYgKHR5cGVvZiBwbHVnaW4uaW5zdGFsbCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgcGx1Z2luLmluc3RhbGwuYXBwbHkocGx1Z2luLCBhcmdzKTtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBwbHVnaW4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHBsdWdpbi5hcHBseShudWxsLCBhcmdzKTtcbiAgICB9XG4gICAgaW5zdGFsbGVkUGx1Z2lucy5wdXNoKHBsdWdpbik7XG4gICAgcmV0dXJuIHRoaXNcbiAgfTtcbn1cblxuLyogICovXG5cbmZ1bmN0aW9uIGluaXRNaXhpbiQxIChWdWUpIHtcbiAgVnVlLm1peGluID0gZnVuY3Rpb24gKG1peGluKSB7XG4gICAgdGhpcy5vcHRpb25zID0gbWVyZ2VPcHRpb25zKHRoaXMub3B0aW9ucywgbWl4aW4pO1xuICAgIHJldHVybiB0aGlzXG4gIH07XG59XG5cbi8qICAqL1xuXG5mdW5jdGlvbiBpbml0RXh0ZW5kIChWdWUpIHtcbiAgLyoqXG4gICAqIEVhY2ggaW5zdGFuY2UgY29uc3RydWN0b3IsIGluY2x1ZGluZyBWdWUsIGhhcyBhIHVuaXF1ZVxuICAgKiBjaWQuIFRoaXMgZW5hYmxlcyB1cyB0byBjcmVhdGUgd3JhcHBlZCBcImNoaWxkXG4gICAqIGNvbnN0cnVjdG9yc1wiIGZvciBwcm90b3R5cGFsIGluaGVyaXRhbmNlIGFuZCBjYWNoZSB0aGVtLlxuICAgKi9cbiAgVnVlLmNpZCA9IDA7XG4gIHZhciBjaWQgPSAxO1xuXG4gIC8qKlxuICAgKiBDbGFzcyBpbmhlcml0YW5jZVxuICAgKi9cbiAgVnVlLmV4dGVuZCA9IGZ1bmN0aW9uIChleHRlbmRPcHRpb25zKSB7XG4gICAgZXh0ZW5kT3B0aW9ucyA9IGV4dGVuZE9wdGlvbnMgfHwge307XG4gICAgdmFyIFN1cGVyID0gdGhpcztcbiAgICB2YXIgU3VwZXJJZCA9IFN1cGVyLmNpZDtcbiAgICB2YXIgY2FjaGVkQ3RvcnMgPSBleHRlbmRPcHRpb25zLl9DdG9yIHx8IChleHRlbmRPcHRpb25zLl9DdG9yID0ge30pO1xuICAgIGlmIChjYWNoZWRDdG9yc1tTdXBlcklkXSkge1xuICAgICAgcmV0dXJuIGNhY2hlZEN0b3JzW1N1cGVySWRdXG4gICAgfVxuXG4gICAgdmFyIG5hbWUgPSBleHRlbmRPcHRpb25zLm5hbWUgfHwgU3VwZXIub3B0aW9ucy5uYW1lO1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIG5hbWUpIHtcbiAgICAgIHZhbGlkYXRlQ29tcG9uZW50TmFtZShuYW1lKTtcbiAgICB9XG5cbiAgICB2YXIgU3ViID0gZnVuY3Rpb24gVnVlQ29tcG9uZW50IChvcHRpb25zKSB7XG4gICAgICB0aGlzLl9pbml0KG9wdGlvbnMpO1xuICAgIH07XG4gICAgU3ViLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoU3VwZXIucHJvdG90eXBlKTtcbiAgICBTdWIucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gU3ViO1xuICAgIFN1Yi5jaWQgPSBjaWQrKztcbiAgICBTdWIub3B0aW9ucyA9IG1lcmdlT3B0aW9ucyhcbiAgICAgIFN1cGVyLm9wdGlvbnMsXG4gICAgICBleHRlbmRPcHRpb25zXG4gICAgKTtcbiAgICBTdWJbJ3N1cGVyJ10gPSBTdXBlcjtcblxuICAgIC8vIEZvciBwcm9wcyBhbmQgY29tcHV0ZWQgcHJvcGVydGllcywgd2UgZGVmaW5lIHRoZSBwcm94eSBnZXR0ZXJzIG9uXG4gICAgLy8gdGhlIFZ1ZSBpbnN0YW5jZXMgYXQgZXh0ZW5zaW9uIHRpbWUsIG9uIHRoZSBleHRlbmRlZCBwcm90b3R5cGUuIFRoaXNcbiAgICAvLyBhdm9pZHMgT2JqZWN0LmRlZmluZVByb3BlcnR5IGNhbGxzIGZvciBlYWNoIGluc3RhbmNlIGNyZWF0ZWQuXG4gICAgaWYgKFN1Yi5vcHRpb25zLnByb3BzKSB7XG4gICAgICBpbml0UHJvcHMkMShTdWIpO1xuICAgIH1cbiAgICBpZiAoU3ViLm9wdGlvbnMuY29tcHV0ZWQpIHtcbiAgICAgIGluaXRDb21wdXRlZCQxKFN1Yik7XG4gICAgfVxuXG4gICAgLy8gYWxsb3cgZnVydGhlciBleHRlbnNpb24vbWl4aW4vcGx1Z2luIHVzYWdlXG4gICAgU3ViLmV4dGVuZCA9IFN1cGVyLmV4dGVuZDtcbiAgICBTdWIubWl4aW4gPSBTdXBlci5taXhpbjtcbiAgICBTdWIudXNlID0gU3VwZXIudXNlO1xuXG4gICAgLy8gY3JlYXRlIGFzc2V0IHJlZ2lzdGVycywgc28gZXh0ZW5kZWQgY2xhc3Nlc1xuICAgIC8vIGNhbiBoYXZlIHRoZWlyIHByaXZhdGUgYXNzZXRzIHRvby5cbiAgICBBU1NFVF9UWVBFUy5mb3JFYWNoKGZ1bmN0aW9uICh0eXBlKSB7XG4gICAgICBTdWJbdHlwZV0gPSBTdXBlclt0eXBlXTtcbiAgICB9KTtcbiAgICAvLyBlbmFibGUgcmVjdXJzaXZlIHNlbGYtbG9va3VwXG4gICAgaWYgKG5hbWUpIHtcbiAgICAgIFN1Yi5vcHRpb25zLmNvbXBvbmVudHNbbmFtZV0gPSBTdWI7XG4gICAgfVxuXG4gICAgLy8ga2VlcCBhIHJlZmVyZW5jZSB0byB0aGUgc3VwZXIgb3B0aW9ucyBhdCBleHRlbnNpb24gdGltZS5cbiAgICAvLyBsYXRlciBhdCBpbnN0YW50aWF0aW9uIHdlIGNhbiBjaGVjayBpZiBTdXBlcidzIG9wdGlvbnMgaGF2ZVxuICAgIC8vIGJlZW4gdXBkYXRlZC5cbiAgICBTdWIuc3VwZXJPcHRpb25zID0gU3VwZXIub3B0aW9ucztcbiAgICBTdWIuZXh0ZW5kT3B0aW9ucyA9IGV4dGVuZE9wdGlvbnM7XG4gICAgU3ViLnNlYWxlZE9wdGlvbnMgPSBleHRlbmQoe30sIFN1Yi5vcHRpb25zKTtcblxuICAgIC8vIGNhY2hlIGNvbnN0cnVjdG9yXG4gICAgY2FjaGVkQ3RvcnNbU3VwZXJJZF0gPSBTdWI7XG4gICAgcmV0dXJuIFN1YlxuICB9O1xufVxuXG5mdW5jdGlvbiBpbml0UHJvcHMkMSAoQ29tcCkge1xuICB2YXIgcHJvcHMgPSBDb21wLm9wdGlvbnMucHJvcHM7XG4gIGZvciAodmFyIGtleSBpbiBwcm9wcykge1xuICAgIHByb3h5KENvbXAucHJvdG90eXBlLCBcIl9wcm9wc1wiLCBrZXkpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGluaXRDb21wdXRlZCQxIChDb21wKSB7XG4gIHZhciBjb21wdXRlZCA9IENvbXAub3B0aW9ucy5jb21wdXRlZDtcbiAgZm9yICh2YXIga2V5IGluIGNvbXB1dGVkKSB7XG4gICAgZGVmaW5lQ29tcHV0ZWQoQ29tcC5wcm90b3R5cGUsIGtleSwgY29tcHV0ZWRba2V5XSk7XG4gIH1cbn1cblxuLyogICovXG5cbmZ1bmN0aW9uIGluaXRBc3NldFJlZ2lzdGVycyAoVnVlKSB7XG4gIC8qKlxuICAgKiBDcmVhdGUgYXNzZXQgcmVnaXN0cmF0aW9uIG1ldGhvZHMuXG4gICAqL1xuICBBU1NFVF9UWVBFUy5mb3JFYWNoKGZ1bmN0aW9uICh0eXBlKSB7XG4gICAgVnVlW3R5cGVdID0gZnVuY3Rpb24gKFxuICAgICAgaWQsXG4gICAgICBkZWZpbml0aW9uXG4gICAgKSB7XG4gICAgICBpZiAoIWRlZmluaXRpb24pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMub3B0aW9uc1t0eXBlICsgJ3MnXVtpZF1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiB0eXBlID09PSAnY29tcG9uZW50Jykge1xuICAgICAgICAgIHZhbGlkYXRlQ29tcG9uZW50TmFtZShpZCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGUgPT09ICdjb21wb25lbnQnICYmIGlzUGxhaW5PYmplY3QoZGVmaW5pdGlvbikpIHtcbiAgICAgICAgICBkZWZpbml0aW9uLm5hbWUgPSBkZWZpbml0aW9uLm5hbWUgfHwgaWQ7XG4gICAgICAgICAgZGVmaW5pdGlvbiA9IHRoaXMub3B0aW9ucy5fYmFzZS5leHRlbmQoZGVmaW5pdGlvbik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGUgPT09ICdkaXJlY3RpdmUnICYmIHR5cGVvZiBkZWZpbml0aW9uID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgZGVmaW5pdGlvbiA9IHsgYmluZDogZGVmaW5pdGlvbiwgdXBkYXRlOiBkZWZpbml0aW9uIH07XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5vcHRpb25zW3R5cGUgKyAncyddW2lkXSA9IGRlZmluaXRpb247XG4gICAgICAgIHJldHVybiBkZWZpbml0aW9uXG4gICAgICB9XG4gICAgfTtcbiAgfSk7XG59XG5cbi8qICAqL1xuXG5cblxuXG5cbmZ1bmN0aW9uIGdldENvbXBvbmVudE5hbWUgKG9wdHMpIHtcbiAgcmV0dXJuIG9wdHMgJiYgKG9wdHMuQ3Rvci5vcHRpb25zLm5hbWUgfHwgb3B0cy50YWcpXG59XG5cbmZ1bmN0aW9uIG1hdGNoZXMgKHBhdHRlcm4sIG5hbWUpIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkocGF0dGVybikpIHtcbiAgICByZXR1cm4gcGF0dGVybi5pbmRleE9mKG5hbWUpID4gLTFcbiAgfSBlbHNlIGlmICh0eXBlb2YgcGF0dGVybiA9PT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gcGF0dGVybi5zcGxpdCgnLCcpLmluZGV4T2YobmFtZSkgPiAtMVxuICB9IGVsc2UgaWYgKGlzUmVnRXhwKHBhdHRlcm4pKSB7XG4gICAgcmV0dXJuIHBhdHRlcm4udGVzdChuYW1lKVxuICB9XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gIHJldHVybiBmYWxzZVxufVxuXG5mdW5jdGlvbiBwcnVuZUNhY2hlIChrZWVwQWxpdmVJbnN0YW5jZSwgZmlsdGVyKSB7XG4gIHZhciBjYWNoZSA9IGtlZXBBbGl2ZUluc3RhbmNlLmNhY2hlO1xuICB2YXIga2V5cyA9IGtlZXBBbGl2ZUluc3RhbmNlLmtleXM7XG4gIHZhciBfdm5vZGUgPSBrZWVwQWxpdmVJbnN0YW5jZS5fdm5vZGU7XG4gIGZvciAodmFyIGtleSBpbiBjYWNoZSkge1xuICAgIHZhciBlbnRyeSA9IGNhY2hlW2tleV07XG4gICAgaWYgKGVudHJ5KSB7XG4gICAgICB2YXIgbmFtZSA9IGVudHJ5Lm5hbWU7XG4gICAgICBpZiAobmFtZSAmJiAhZmlsdGVyKG5hbWUpKSB7XG4gICAgICAgIHBydW5lQ2FjaGVFbnRyeShjYWNoZSwga2V5LCBrZXlzLCBfdm5vZGUpO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBwcnVuZUNhY2hlRW50cnkgKFxuICBjYWNoZSxcbiAga2V5LFxuICBrZXlzLFxuICBjdXJyZW50XG4pIHtcbiAgdmFyIGVudHJ5ID0gY2FjaGVba2V5XTtcbiAgaWYgKGVudHJ5ICYmICghY3VycmVudCB8fCBlbnRyeS50YWcgIT09IGN1cnJlbnQudGFnKSkge1xuICAgIGVudHJ5LmNvbXBvbmVudEluc3RhbmNlLiRkZXN0cm95KCk7XG4gIH1cbiAgY2FjaGVba2V5XSA9IG51bGw7XG4gIHJlbW92ZShrZXlzLCBrZXkpO1xufVxuXG52YXIgcGF0dGVyblR5cGVzID0gW1N0cmluZywgUmVnRXhwLCBBcnJheV07XG5cbnZhciBLZWVwQWxpdmUgPSB7XG4gIG5hbWU6ICdrZWVwLWFsaXZlJyxcbiAgYWJzdHJhY3Q6IHRydWUsXG5cbiAgcHJvcHM6IHtcbiAgICBpbmNsdWRlOiBwYXR0ZXJuVHlwZXMsXG4gICAgZXhjbHVkZTogcGF0dGVyblR5cGVzLFxuICAgIG1heDogW1N0cmluZywgTnVtYmVyXVxuICB9LFxuXG4gIG1ldGhvZHM6IHtcbiAgICBjYWNoZVZOb2RlOiBmdW5jdGlvbiBjYWNoZVZOb2RlKCkge1xuICAgICAgdmFyIHJlZiA9IHRoaXM7XG4gICAgICB2YXIgY2FjaGUgPSByZWYuY2FjaGU7XG4gICAgICB2YXIga2V5cyA9IHJlZi5rZXlzO1xuICAgICAgdmFyIHZub2RlVG9DYWNoZSA9IHJlZi52bm9kZVRvQ2FjaGU7XG4gICAgICB2YXIga2V5VG9DYWNoZSA9IHJlZi5rZXlUb0NhY2hlO1xuICAgICAgaWYgKHZub2RlVG9DYWNoZSkge1xuICAgICAgICB2YXIgdGFnID0gdm5vZGVUb0NhY2hlLnRhZztcbiAgICAgICAgdmFyIGNvbXBvbmVudEluc3RhbmNlID0gdm5vZGVUb0NhY2hlLmNvbXBvbmVudEluc3RhbmNlO1xuICAgICAgICB2YXIgY29tcG9uZW50T3B0aW9ucyA9IHZub2RlVG9DYWNoZS5jb21wb25lbnRPcHRpb25zO1xuICAgICAgICBjYWNoZVtrZXlUb0NhY2hlXSA9IHtcbiAgICAgICAgICBuYW1lOiBnZXRDb21wb25lbnROYW1lKGNvbXBvbmVudE9wdGlvbnMpLFxuICAgICAgICAgIHRhZzogdGFnLFxuICAgICAgICAgIGNvbXBvbmVudEluc3RhbmNlOiBjb21wb25lbnRJbnN0YW5jZSxcbiAgICAgICAgfTtcbiAgICAgICAga2V5cy5wdXNoKGtleVRvQ2FjaGUpO1xuICAgICAgICAvLyBwcnVuZSBvbGRlc3QgZW50cnlcbiAgICAgICAgaWYgKHRoaXMubWF4ICYmIGtleXMubGVuZ3RoID4gcGFyc2VJbnQodGhpcy5tYXgpKSB7XG4gICAgICAgICAgcHJ1bmVDYWNoZUVudHJ5KGNhY2hlLCBrZXlzWzBdLCBrZXlzLCB0aGlzLl92bm9kZSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy52bm9kZVRvQ2FjaGUgPSBudWxsO1xuICAgICAgfVxuICAgIH1cbiAgfSxcblxuICBjcmVhdGVkOiBmdW5jdGlvbiBjcmVhdGVkICgpIHtcbiAgICB0aGlzLmNhY2hlID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICB0aGlzLmtleXMgPSBbXTtcbiAgfSxcblxuICBkZXN0cm95ZWQ6IGZ1bmN0aW9uIGRlc3Ryb3llZCAoKSB7XG4gICAgZm9yICh2YXIga2V5IGluIHRoaXMuY2FjaGUpIHtcbiAgICAgIHBydW5lQ2FjaGVFbnRyeSh0aGlzLmNhY2hlLCBrZXksIHRoaXMua2V5cyk7XG4gICAgfVxuICB9LFxuXG4gIG1vdW50ZWQ6IGZ1bmN0aW9uIG1vdW50ZWQgKCkge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gICAgdGhpcy5jYWNoZVZOb2RlKCk7XG4gICAgdGhpcy4kd2F0Y2goJ2luY2x1ZGUnLCBmdW5jdGlvbiAodmFsKSB7XG4gICAgICBwcnVuZUNhY2hlKHRoaXMkMSwgZnVuY3Rpb24gKG5hbWUpIHsgcmV0dXJuIG1hdGNoZXModmFsLCBuYW1lKTsgfSk7XG4gICAgfSk7XG4gICAgdGhpcy4kd2F0Y2goJ2V4Y2x1ZGUnLCBmdW5jdGlvbiAodmFsKSB7XG4gICAgICBwcnVuZUNhY2hlKHRoaXMkMSwgZnVuY3Rpb24gKG5hbWUpIHsgcmV0dXJuICFtYXRjaGVzKHZhbCwgbmFtZSk7IH0pO1xuICAgIH0pO1xuICB9LFxuXG4gIHVwZGF0ZWQ6IGZ1bmN0aW9uIHVwZGF0ZWQgKCkge1xuICAgIHRoaXMuY2FjaGVWTm9kZSgpO1xuICB9LFxuXG4gIHJlbmRlcjogZnVuY3Rpb24gcmVuZGVyICgpIHtcbiAgICB2YXIgc2xvdCA9IHRoaXMuJHNsb3RzLmRlZmF1bHQ7XG4gICAgdmFyIHZub2RlID0gZ2V0Rmlyc3RDb21wb25lbnRDaGlsZChzbG90KTtcbiAgICB2YXIgY29tcG9uZW50T3B0aW9ucyA9IHZub2RlICYmIHZub2RlLmNvbXBvbmVudE9wdGlvbnM7XG4gICAgaWYgKGNvbXBvbmVudE9wdGlvbnMpIHtcbiAgICAgIC8vIGNoZWNrIHBhdHRlcm5cbiAgICAgIHZhciBuYW1lID0gZ2V0Q29tcG9uZW50TmFtZShjb21wb25lbnRPcHRpb25zKTtcbiAgICAgIHZhciByZWYgPSB0aGlzO1xuICAgICAgdmFyIGluY2x1ZGUgPSByZWYuaW5jbHVkZTtcbiAgICAgIHZhciBleGNsdWRlID0gcmVmLmV4Y2x1ZGU7XG4gICAgICBpZiAoXG4gICAgICAgIC8vIG5vdCBpbmNsdWRlZFxuICAgICAgICAoaW5jbHVkZSAmJiAoIW5hbWUgfHwgIW1hdGNoZXMoaW5jbHVkZSwgbmFtZSkpKSB8fFxuICAgICAgICAvLyBleGNsdWRlZFxuICAgICAgICAoZXhjbHVkZSAmJiBuYW1lICYmIG1hdGNoZXMoZXhjbHVkZSwgbmFtZSkpXG4gICAgICApIHtcbiAgICAgICAgcmV0dXJuIHZub2RlXG4gICAgICB9XG5cbiAgICAgIHZhciByZWYkMSA9IHRoaXM7XG4gICAgICB2YXIgY2FjaGUgPSByZWYkMS5jYWNoZTtcbiAgICAgIHZhciBrZXlzID0gcmVmJDEua2V5cztcbiAgICAgIHZhciBrZXkgPSB2bm9kZS5rZXkgPT0gbnVsbFxuICAgICAgICAvLyBzYW1lIGNvbnN0cnVjdG9yIG1heSBnZXQgcmVnaXN0ZXJlZCBhcyBkaWZmZXJlbnQgbG9jYWwgY29tcG9uZW50c1xuICAgICAgICAvLyBzbyBjaWQgYWxvbmUgaXMgbm90IGVub3VnaCAoIzMyNjkpXG4gICAgICAgID8gY29tcG9uZW50T3B0aW9ucy5DdG9yLmNpZCArIChjb21wb25lbnRPcHRpb25zLnRhZyA/IChcIjo6XCIgKyAoY29tcG9uZW50T3B0aW9ucy50YWcpKSA6ICcnKVxuICAgICAgICA6IHZub2RlLmtleTtcbiAgICAgIGlmIChjYWNoZVtrZXldKSB7XG4gICAgICAgIHZub2RlLmNvbXBvbmVudEluc3RhbmNlID0gY2FjaGVba2V5XS5jb21wb25lbnRJbnN0YW5jZTtcbiAgICAgICAgLy8gbWFrZSBjdXJyZW50IGtleSBmcmVzaGVzdFxuICAgICAgICByZW1vdmUoa2V5cywga2V5KTtcbiAgICAgICAga2V5cy5wdXNoKGtleSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBkZWxheSBzZXR0aW5nIHRoZSBjYWNoZSB1bnRpbCB1cGRhdGVcbiAgICAgICAgdGhpcy52bm9kZVRvQ2FjaGUgPSB2bm9kZTtcbiAgICAgICAgdGhpcy5rZXlUb0NhY2hlID0ga2V5O1xuICAgICAgfVxuXG4gICAgICB2bm9kZS5kYXRhLmtlZXBBbGl2ZSA9IHRydWU7XG4gICAgfVxuICAgIHJldHVybiB2bm9kZSB8fCAoc2xvdCAmJiBzbG90WzBdKVxuICB9XG59O1xuXG52YXIgYnVpbHRJbkNvbXBvbmVudHMgPSB7XG4gIEtlZXBBbGl2ZTogS2VlcEFsaXZlXG59O1xuXG4vKiAgKi9cblxuZnVuY3Rpb24gaW5pdEdsb2JhbEFQSSAoVnVlKSB7XG4gIC8vIGNvbmZpZ1xuICB2YXIgY29uZmlnRGVmID0ge307XG4gIGNvbmZpZ0RlZi5nZXQgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBjb25maWc7IH07XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgY29uZmlnRGVmLnNldCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHdhcm4oXG4gICAgICAgICdEbyBub3QgcmVwbGFjZSB0aGUgVnVlLmNvbmZpZyBvYmplY3QsIHNldCBpbmRpdmlkdWFsIGZpZWxkcyBpbnN0ZWFkLidcbiAgICAgICk7XG4gICAgfTtcbiAgfVxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVnVlLCAnY29uZmlnJywgY29uZmlnRGVmKTtcblxuICAvLyBleHBvc2VkIHV0aWwgbWV0aG9kcy5cbiAgLy8gTk9URTogdGhlc2UgYXJlIG5vdCBjb25zaWRlcmVkIHBhcnQgb2YgdGhlIHB1YmxpYyBBUEkgLSBhdm9pZCByZWx5aW5nIG9uXG4gIC8vIHRoZW0gdW5sZXNzIHlvdSBhcmUgYXdhcmUgb2YgdGhlIHJpc2suXG4gIFZ1ZS51dGlsID0ge1xuICAgIHdhcm46IHdhcm4sXG4gICAgZXh0ZW5kOiBleHRlbmQsXG4gICAgbWVyZ2VPcHRpb25zOiBtZXJnZU9wdGlvbnMsXG4gICAgZGVmaW5lUmVhY3RpdmU6IGRlZmluZVJlYWN0aXZlJCQxXG4gIH07XG5cbiAgVnVlLnNldCA9IHNldDtcbiAgVnVlLmRlbGV0ZSA9IGRlbDtcbiAgVnVlLm5leHRUaWNrID0gbmV4dFRpY2s7XG5cbiAgLy8gMi42IGV4cGxpY2l0IG9ic2VydmFibGUgQVBJXG4gIFZ1ZS5vYnNlcnZhYmxlID0gZnVuY3Rpb24gKG9iaikge1xuICAgIG9ic2VydmUob2JqKTtcbiAgICByZXR1cm4gb2JqXG4gIH07XG5cbiAgVnVlLm9wdGlvbnMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICBBU1NFVF9UWVBFUy5mb3JFYWNoKGZ1bmN0aW9uICh0eXBlKSB7XG4gICAgVnVlLm9wdGlvbnNbdHlwZSArICdzJ10gPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICB9KTtcblxuICAvLyB0aGlzIGlzIHVzZWQgdG8gaWRlbnRpZnkgdGhlIFwiYmFzZVwiIGNvbnN0cnVjdG9yIHRvIGV4dGVuZCBhbGwgcGxhaW4tb2JqZWN0XG4gIC8vIGNvbXBvbmVudHMgd2l0aCBpbiBXZWV4J3MgbXVsdGktaW5zdGFuY2Ugc2NlbmFyaW9zLlxuICBWdWUub3B0aW9ucy5fYmFzZSA9IFZ1ZTtcblxuICBleHRlbmQoVnVlLm9wdGlvbnMuY29tcG9uZW50cywgYnVpbHRJbkNvbXBvbmVudHMpO1xuXG4gIGluaXRVc2UoVnVlKTtcbiAgaW5pdE1peGluJDEoVnVlKTtcbiAgaW5pdEV4dGVuZChWdWUpO1xuICBpbml0QXNzZXRSZWdpc3RlcnMoVnVlKTtcbn1cblxuaW5pdEdsb2JhbEFQSShWdWUpO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoVnVlLnByb3RvdHlwZSwgJyRpc1NlcnZlcicsIHtcbiAgZ2V0OiBpc1NlcnZlclJlbmRlcmluZ1xufSk7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShWdWUucHJvdG90eXBlLCAnJHNzckNvbnRleHQnLCB7XG4gIGdldDogZnVuY3Rpb24gZ2V0ICgpIHtcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgIHJldHVybiB0aGlzLiR2bm9kZSAmJiB0aGlzLiR2bm9kZS5zc3JDb250ZXh0XG4gIH1cbn0pO1xuXG4vLyBleHBvc2UgRnVuY3Rpb25hbFJlbmRlckNvbnRleHQgZm9yIHNzciBydW50aW1lIGhlbHBlciBpbnN0YWxsYXRpb25cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShWdWUsICdGdW5jdGlvbmFsUmVuZGVyQ29udGV4dCcsIHtcbiAgdmFsdWU6IEZ1bmN0aW9uYWxSZW5kZXJDb250ZXh0XG59KTtcblxuVnVlLnZlcnNpb24gPSAnMi42LjE0JztcblxuLyogICovXG5cbi8vIHRoZXNlIGFyZSByZXNlcnZlZCBmb3Igd2ViIGJlY2F1c2UgdGhleSBhcmUgZGlyZWN0bHkgY29tcGlsZWQgYXdheVxuLy8gZHVyaW5nIHRlbXBsYXRlIGNvbXBpbGF0aW9uXG52YXIgaXNSZXNlcnZlZEF0dHIgPSBtYWtlTWFwKCdzdHlsZSxjbGFzcycpO1xuXG4vLyBhdHRyaWJ1dGVzIHRoYXQgc2hvdWxkIGJlIHVzaW5nIHByb3BzIGZvciBiaW5kaW5nXG52YXIgYWNjZXB0VmFsdWUgPSBtYWtlTWFwKCdpbnB1dCx0ZXh0YXJlYSxvcHRpb24sc2VsZWN0LHByb2dyZXNzJyk7XG52YXIgbXVzdFVzZVByb3AgPSBmdW5jdGlvbiAodGFnLCB0eXBlLCBhdHRyKSB7XG4gIHJldHVybiAoXG4gICAgKGF0dHIgPT09ICd2YWx1ZScgJiYgYWNjZXB0VmFsdWUodGFnKSkgJiYgdHlwZSAhPT0gJ2J1dHRvbicgfHxcbiAgICAoYXR0ciA9PT0gJ3NlbGVjdGVkJyAmJiB0YWcgPT09ICdvcHRpb24nKSB8fFxuICAgIChhdHRyID09PSAnY2hlY2tlZCcgJiYgdGFnID09PSAnaW5wdXQnKSB8fFxuICAgIChhdHRyID09PSAnbXV0ZWQnICYmIHRhZyA9PT0gJ3ZpZGVvJylcbiAgKVxufTtcblxudmFyIGlzRW51bWVyYXRlZEF0dHIgPSBtYWtlTWFwKCdjb250ZW50ZWRpdGFibGUsZHJhZ2dhYmxlLHNwZWxsY2hlY2snKTtcblxudmFyIGlzVmFsaWRDb250ZW50RWRpdGFibGVWYWx1ZSA9IG1ha2VNYXAoJ2V2ZW50cyxjYXJldCx0eXBpbmcscGxhaW50ZXh0LW9ubHknKTtcblxudmFyIGNvbnZlcnRFbnVtZXJhdGVkVmFsdWUgPSBmdW5jdGlvbiAoa2V5LCB2YWx1ZSkge1xuICByZXR1cm4gaXNGYWxzeUF0dHJWYWx1ZSh2YWx1ZSkgfHwgdmFsdWUgPT09ICdmYWxzZSdcbiAgICA/ICdmYWxzZSdcbiAgICAvLyBhbGxvdyBhcmJpdHJhcnkgc3RyaW5nIHZhbHVlIGZvciBjb250ZW50ZWRpdGFibGVcbiAgICA6IGtleSA9PT0gJ2NvbnRlbnRlZGl0YWJsZScgJiYgaXNWYWxpZENvbnRlbnRFZGl0YWJsZVZhbHVlKHZhbHVlKVxuICAgICAgPyB2YWx1ZVxuICAgICAgOiAndHJ1ZSdcbn07XG5cbnZhciBpc0Jvb2xlYW5BdHRyID0gbWFrZU1hcChcbiAgJ2FsbG93ZnVsbHNjcmVlbixhc3luYyxhdXRvZm9jdXMsYXV0b3BsYXksY2hlY2tlZCxjb21wYWN0LGNvbnRyb2xzLGRlY2xhcmUsJyArXG4gICdkZWZhdWx0LGRlZmF1bHRjaGVja2VkLGRlZmF1bHRtdXRlZCxkZWZhdWx0c2VsZWN0ZWQsZGVmZXIsZGlzYWJsZWQsJyArXG4gICdlbmFibGVkLGZvcm1ub3ZhbGlkYXRlLGhpZGRlbixpbmRldGVybWluYXRlLGluZXJ0LGlzbWFwLGl0ZW1zY29wZSxsb29wLG11bHRpcGxlLCcgK1xuICAnbXV0ZWQsbm9ocmVmLG5vcmVzaXplLG5vc2hhZGUsbm92YWxpZGF0ZSxub3dyYXAsb3BlbixwYXVzZW9uZXhpdCxyZWFkb25seSwnICtcbiAgJ3JlcXVpcmVkLHJldmVyc2VkLHNjb3BlZCxzZWFtbGVzcyxzZWxlY3RlZCxzb3J0YWJsZSwnICtcbiAgJ3RydWVzcGVlZCx0eXBlbXVzdG1hdGNoLHZpc2libGUnXG4pO1xuXG52YXIgeGxpbmtOUyA9ICdodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rJztcblxudmFyIGlzWGxpbmsgPSBmdW5jdGlvbiAobmFtZSkge1xuICByZXR1cm4gbmFtZS5jaGFyQXQoNSkgPT09ICc6JyAmJiBuYW1lLnNsaWNlKDAsIDUpID09PSAneGxpbmsnXG59O1xuXG52YXIgZ2V0WGxpbmtQcm9wID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgcmV0dXJuIGlzWGxpbmsobmFtZSkgPyBuYW1lLnNsaWNlKDYsIG5hbWUubGVuZ3RoKSA6ICcnXG59O1xuXG52YXIgaXNGYWxzeUF0dHJWYWx1ZSA9IGZ1bmN0aW9uICh2YWwpIHtcbiAgcmV0dXJuIHZhbCA9PSBudWxsIHx8IHZhbCA9PT0gZmFsc2Vcbn07XG5cbi8qICAqL1xuXG5mdW5jdGlvbiBnZW5DbGFzc0ZvclZub2RlICh2bm9kZSkge1xuICB2YXIgZGF0YSA9IHZub2RlLmRhdGE7XG4gIHZhciBwYXJlbnROb2RlID0gdm5vZGU7XG4gIHZhciBjaGlsZE5vZGUgPSB2bm9kZTtcbiAgd2hpbGUgKGlzRGVmKGNoaWxkTm9kZS5jb21wb25lbnRJbnN0YW5jZSkpIHtcbiAgICBjaGlsZE5vZGUgPSBjaGlsZE5vZGUuY29tcG9uZW50SW5zdGFuY2UuX3Zub2RlO1xuICAgIGlmIChjaGlsZE5vZGUgJiYgY2hpbGROb2RlLmRhdGEpIHtcbiAgICAgIGRhdGEgPSBtZXJnZUNsYXNzRGF0YShjaGlsZE5vZGUuZGF0YSwgZGF0YSk7XG4gICAgfVxuICB9XG4gIHdoaWxlIChpc0RlZihwYXJlbnROb2RlID0gcGFyZW50Tm9kZS5wYXJlbnQpKSB7XG4gICAgaWYgKHBhcmVudE5vZGUgJiYgcGFyZW50Tm9kZS5kYXRhKSB7XG4gICAgICBkYXRhID0gbWVyZ2VDbGFzc0RhdGEoZGF0YSwgcGFyZW50Tm9kZS5kYXRhKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlbmRlckNsYXNzKGRhdGEuc3RhdGljQ2xhc3MsIGRhdGEuY2xhc3MpXG59XG5cbmZ1bmN0aW9uIG1lcmdlQ2xhc3NEYXRhIChjaGlsZCwgcGFyZW50KSB7XG4gIHJldHVybiB7XG4gICAgc3RhdGljQ2xhc3M6IGNvbmNhdChjaGlsZC5zdGF0aWNDbGFzcywgcGFyZW50LnN0YXRpY0NsYXNzKSxcbiAgICBjbGFzczogaXNEZWYoY2hpbGQuY2xhc3MpXG4gICAgICA/IFtjaGlsZC5jbGFzcywgcGFyZW50LmNsYXNzXVxuICAgICAgOiBwYXJlbnQuY2xhc3NcbiAgfVxufVxuXG5mdW5jdGlvbiByZW5kZXJDbGFzcyAoXG4gIHN0YXRpY0NsYXNzLFxuICBkeW5hbWljQ2xhc3Ncbikge1xuICBpZiAoaXNEZWYoc3RhdGljQ2xhc3MpIHx8IGlzRGVmKGR5bmFtaWNDbGFzcykpIHtcbiAgICByZXR1cm4gY29uY2F0KHN0YXRpY0NsYXNzLCBzdHJpbmdpZnlDbGFzcyhkeW5hbWljQ2xhc3MpKVxuICB9XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gIHJldHVybiAnJ1xufVxuXG5mdW5jdGlvbiBjb25jYXQgKGEsIGIpIHtcbiAgcmV0dXJuIGEgPyBiID8gKGEgKyAnICcgKyBiKSA6IGEgOiAoYiB8fCAnJylcbn1cblxuZnVuY3Rpb24gc3RyaW5naWZ5Q2xhc3MgKHZhbHVlKSB7XG4gIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgIHJldHVybiBzdHJpbmdpZnlBcnJheSh2YWx1ZSlcbiAgfVxuICBpZiAoaXNPYmplY3QodmFsdWUpKSB7XG4gICAgcmV0dXJuIHN0cmluZ2lmeU9iamVjdCh2YWx1ZSlcbiAgfVxuICBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xuICAgIHJldHVybiB2YWx1ZVxuICB9XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gIHJldHVybiAnJ1xufVxuXG5mdW5jdGlvbiBzdHJpbmdpZnlBcnJheSAodmFsdWUpIHtcbiAgdmFyIHJlcyA9ICcnO1xuICB2YXIgc3RyaW5naWZpZWQ7XG4gIGZvciAodmFyIGkgPSAwLCBsID0gdmFsdWUubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgaWYgKGlzRGVmKHN0cmluZ2lmaWVkID0gc3RyaW5naWZ5Q2xhc3ModmFsdWVbaV0pKSAmJiBzdHJpbmdpZmllZCAhPT0gJycpIHtcbiAgICAgIGlmIChyZXMpIHsgcmVzICs9ICcgJzsgfVxuICAgICAgcmVzICs9IHN0cmluZ2lmaWVkO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzXG59XG5cbmZ1bmN0aW9uIHN0cmluZ2lmeU9iamVjdCAodmFsdWUpIHtcbiAgdmFyIHJlcyA9ICcnO1xuICBmb3IgKHZhciBrZXkgaW4gdmFsdWUpIHtcbiAgICBpZiAodmFsdWVba2V5XSkge1xuICAgICAgaWYgKHJlcykgeyByZXMgKz0gJyAnOyB9XG4gICAgICByZXMgKz0ga2V5O1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzXG59XG5cbi8qICAqL1xuXG52YXIgbmFtZXNwYWNlTWFwID0ge1xuICBzdmc6ICdodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZycsXG4gIG1hdGg6ICdodHRwOi8vd3d3LnczLm9yZy8xOTk4L01hdGgvTWF0aE1MJ1xufTtcblxudmFyIGlzSFRNTFRhZyA9IG1ha2VNYXAoXG4gICdodG1sLGJvZHksYmFzZSxoZWFkLGxpbmssbWV0YSxzdHlsZSx0aXRsZSwnICtcbiAgJ2FkZHJlc3MsYXJ0aWNsZSxhc2lkZSxmb290ZXIsaGVhZGVyLGgxLGgyLGgzLGg0LGg1LGg2LGhncm91cCxuYXYsc2VjdGlvbiwnICtcbiAgJ2RpdixkZCxkbCxkdCxmaWdjYXB0aW9uLGZpZ3VyZSxwaWN0dXJlLGhyLGltZyxsaSxtYWluLG9sLHAscHJlLHVsLCcgK1xuICAnYSxiLGFiYnIsYmRpLGJkbyxicixjaXRlLGNvZGUsZGF0YSxkZm4sZW0saSxrYmQsbWFyayxxLHJwLHJ0LHJ0YyxydWJ5LCcgK1xuICAncyxzYW1wLHNtYWxsLHNwYW4sc3Ryb25nLHN1YixzdXAsdGltZSx1LHZhcix3YnIsYXJlYSxhdWRpbyxtYXAsdHJhY2ssdmlkZW8sJyArXG4gICdlbWJlZCxvYmplY3QscGFyYW0sc291cmNlLGNhbnZhcyxzY3JpcHQsbm9zY3JpcHQsZGVsLGlucywnICtcbiAgJ2NhcHRpb24sY29sLGNvbGdyb3VwLHRhYmxlLHRoZWFkLHRib2R5LHRkLHRoLHRyLCcgK1xuICAnYnV0dG9uLGRhdGFsaXN0LGZpZWxkc2V0LGZvcm0saW5wdXQsbGFiZWwsbGVnZW5kLG1ldGVyLG9wdGdyb3VwLG9wdGlvbiwnICtcbiAgJ291dHB1dCxwcm9ncmVzcyxzZWxlY3QsdGV4dGFyZWEsJyArXG4gICdkZXRhaWxzLGRpYWxvZyxtZW51LG1lbnVpdGVtLHN1bW1hcnksJyArXG4gICdjb250ZW50LGVsZW1lbnQsc2hhZG93LHRlbXBsYXRlLGJsb2NrcXVvdGUsaWZyYW1lLHRmb290J1xuKTtcblxuLy8gdGhpcyBtYXAgaXMgaW50ZW50aW9uYWxseSBzZWxlY3RpdmUsIG9ubHkgY292ZXJpbmcgU1ZHIGVsZW1lbnRzIHRoYXQgbWF5XG4vLyBjb250YWluIGNoaWxkIGVsZW1lbnRzLlxudmFyIGlzU1ZHID0gbWFrZU1hcChcbiAgJ3N2ZyxhbmltYXRlLGNpcmNsZSxjbGlwcGF0aCxjdXJzb3IsZGVmcyxkZXNjLGVsbGlwc2UsZmlsdGVyLGZvbnQtZmFjZSwnICtcbiAgJ2ZvcmVpZ25vYmplY3QsZyxnbHlwaCxpbWFnZSxsaW5lLG1hcmtlcixtYXNrLG1pc3NpbmctZ2x5cGgscGF0aCxwYXR0ZXJuLCcgK1xuICAncG9seWdvbixwb2x5bGluZSxyZWN0LHN3aXRjaCxzeW1ib2wsdGV4dCx0ZXh0cGF0aCx0c3Bhbix1c2UsdmlldycsXG4gIHRydWVcbik7XG5cbnZhciBpc1ByZVRhZyA9IGZ1bmN0aW9uICh0YWcpIHsgcmV0dXJuIHRhZyA9PT0gJ3ByZSc7IH07XG5cbnZhciBpc1Jlc2VydmVkVGFnID0gZnVuY3Rpb24gKHRhZykge1xuICByZXR1cm4gaXNIVE1MVGFnKHRhZykgfHwgaXNTVkcodGFnKVxufTtcblxuZnVuY3Rpb24gZ2V0VGFnTmFtZXNwYWNlICh0YWcpIHtcbiAgaWYgKGlzU1ZHKHRhZykpIHtcbiAgICByZXR1cm4gJ3N2ZydcbiAgfVxuICAvLyBiYXNpYyBzdXBwb3J0IGZvciBNYXRoTUxcbiAgLy8gbm90ZSBpdCBkb2Vzbid0IHN1cHBvcnQgb3RoZXIgTWF0aE1MIGVsZW1lbnRzIGJlaW5nIGNvbXBvbmVudCByb290c1xuICBpZiAodGFnID09PSAnbWF0aCcpIHtcbiAgICByZXR1cm4gJ21hdGgnXG4gIH1cbn1cblxudmFyIHVua25vd25FbGVtZW50Q2FjaGUgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuZnVuY3Rpb24gaXNVbmtub3duRWxlbWVudCAodGFnKSB7XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICBpZiAoIWluQnJvd3Nlcikge1xuICAgIHJldHVybiB0cnVlXG4gIH1cbiAgaWYgKGlzUmVzZXJ2ZWRUYWcodGFnKSkge1xuICAgIHJldHVybiBmYWxzZVxuICB9XG4gIHRhZyA9IHRhZy50b0xvd2VyQ2FzZSgpO1xuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgaWYgKHVua25vd25FbGVtZW50Q2FjaGVbdGFnXSAhPSBudWxsKSB7XG4gICAgcmV0dXJuIHVua25vd25FbGVtZW50Q2FjaGVbdGFnXVxuICB9XG4gIHZhciBlbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQodGFnKTtcbiAgaWYgKHRhZy5pbmRleE9mKCctJykgPiAtMSkge1xuICAgIC8vIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9hLzI4MjEwMzY0LzEwNzAyNDRcbiAgICByZXR1cm4gKHVua25vd25FbGVtZW50Q2FjaGVbdGFnXSA9IChcbiAgICAgIGVsLmNvbnN0cnVjdG9yID09PSB3aW5kb3cuSFRNTFVua25vd25FbGVtZW50IHx8XG4gICAgICBlbC5jb25zdHJ1Y3RvciA9PT0gd2luZG93LkhUTUxFbGVtZW50XG4gICAgKSlcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gKHVua25vd25FbGVtZW50Q2FjaGVbdGFnXSA9IC9IVE1MVW5rbm93bkVsZW1lbnQvLnRlc3QoZWwudG9TdHJpbmcoKSkpXG4gIH1cbn1cblxudmFyIGlzVGV4dElucHV0VHlwZSA9IG1ha2VNYXAoJ3RleHQsbnVtYmVyLHBhc3N3b3JkLHNlYXJjaCxlbWFpbCx0ZWwsdXJsJyk7XG5cbi8qICAqL1xuXG4vKipcbiAqIFF1ZXJ5IGFuIGVsZW1lbnQgc2VsZWN0b3IgaWYgaXQncyBub3QgYW4gZWxlbWVudCBhbHJlYWR5LlxuICovXG5mdW5jdGlvbiBxdWVyeSAoZWwpIHtcbiAgaWYgKHR5cGVvZiBlbCA9PT0gJ3N0cmluZycpIHtcbiAgICB2YXIgc2VsZWN0ZWQgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKGVsKTtcbiAgICBpZiAoIXNlbGVjdGVkKSB7XG4gICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIHdhcm4oXG4gICAgICAgICdDYW5ub3QgZmluZCBlbGVtZW50OiAnICsgZWxcbiAgICAgICk7XG4gICAgICByZXR1cm4gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2JylcbiAgICB9XG4gICAgcmV0dXJuIHNlbGVjdGVkXG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGVsXG4gIH1cbn1cblxuLyogICovXG5cbmZ1bmN0aW9uIGNyZWF0ZUVsZW1lbnQkMSAodGFnTmFtZSwgdm5vZGUpIHtcbiAgdmFyIGVsbSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQodGFnTmFtZSk7XG4gIGlmICh0YWdOYW1lICE9PSAnc2VsZWN0Jykge1xuICAgIHJldHVybiBlbG1cbiAgfVxuICAvLyBmYWxzZSBvciBudWxsIHdpbGwgcmVtb3ZlIHRoZSBhdHRyaWJ1dGUgYnV0IHVuZGVmaW5lZCB3aWxsIG5vdFxuICBpZiAodm5vZGUuZGF0YSAmJiB2bm9kZS5kYXRhLmF0dHJzICYmIHZub2RlLmRhdGEuYXR0cnMubXVsdGlwbGUgIT09IHVuZGVmaW5lZCkge1xuICAgIGVsbS5zZXRBdHRyaWJ1dGUoJ211bHRpcGxlJywgJ211bHRpcGxlJyk7XG4gIH1cbiAgcmV0dXJuIGVsbVxufVxuXG5mdW5jdGlvbiBjcmVhdGVFbGVtZW50TlMgKG5hbWVzcGFjZSwgdGFnTmFtZSkge1xuICByZXR1cm4gZG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TKG5hbWVzcGFjZU1hcFtuYW1lc3BhY2VdLCB0YWdOYW1lKVxufVxuXG5mdW5jdGlvbiBjcmVhdGVUZXh0Tm9kZSAodGV4dCkge1xuICByZXR1cm4gZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUodGV4dClcbn1cblxuZnVuY3Rpb24gY3JlYXRlQ29tbWVudCAodGV4dCkge1xuICByZXR1cm4gZG9jdW1lbnQuY3JlYXRlQ29tbWVudCh0ZXh0KVxufVxuXG5mdW5jdGlvbiBpbnNlcnRCZWZvcmUgKHBhcmVudE5vZGUsIG5ld05vZGUsIHJlZmVyZW5jZU5vZGUpIHtcbiAgcGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUobmV3Tm9kZSwgcmVmZXJlbmNlTm9kZSk7XG59XG5cbmZ1bmN0aW9uIHJlbW92ZUNoaWxkIChub2RlLCBjaGlsZCkge1xuICBub2RlLnJlbW92ZUNoaWxkKGNoaWxkKTtcbn1cblxuZnVuY3Rpb24gYXBwZW5kQ2hpbGQgKG5vZGUsIGNoaWxkKSB7XG4gIG5vZGUuYXBwZW5kQ2hpbGQoY2hpbGQpO1xufVxuXG5mdW5jdGlvbiBwYXJlbnROb2RlIChub2RlKSB7XG4gIHJldHVybiBub2RlLnBhcmVudE5vZGVcbn1cblxuZnVuY3Rpb24gbmV4dFNpYmxpbmcgKG5vZGUpIHtcbiAgcmV0dXJuIG5vZGUubmV4dFNpYmxpbmdcbn1cblxuZnVuY3Rpb24gdGFnTmFtZSAobm9kZSkge1xuICByZXR1cm4gbm9kZS50YWdOYW1lXG59XG5cbmZ1bmN0aW9uIHNldFRleHRDb250ZW50IChub2RlLCB0ZXh0KSB7XG4gIG5vZGUudGV4dENvbnRlbnQgPSB0ZXh0O1xufVxuXG5mdW5jdGlvbiBzZXRTdHlsZVNjb3BlIChub2RlLCBzY29wZUlkKSB7XG4gIG5vZGUuc2V0QXR0cmlidXRlKHNjb3BlSWQsICcnKTtcbn1cblxudmFyIG5vZGVPcHMgPSAvKiNfX1BVUkVfXyovT2JqZWN0LmZyZWV6ZSh7XG4gIGNyZWF0ZUVsZW1lbnQ6IGNyZWF0ZUVsZW1lbnQkMSxcbiAgY3JlYXRlRWxlbWVudE5TOiBjcmVhdGVFbGVtZW50TlMsXG4gIGNyZWF0ZVRleHROb2RlOiBjcmVhdGVUZXh0Tm9kZSxcbiAgY3JlYXRlQ29tbWVudDogY3JlYXRlQ29tbWVudCxcbiAgaW5zZXJ0QmVmb3JlOiBpbnNlcnRCZWZvcmUsXG4gIHJlbW92ZUNoaWxkOiByZW1vdmVDaGlsZCxcbiAgYXBwZW5kQ2hpbGQ6IGFwcGVuZENoaWxkLFxuICBwYXJlbnROb2RlOiBwYXJlbnROb2RlLFxuICBuZXh0U2libGluZzogbmV4dFNpYmxpbmcsXG4gIHRhZ05hbWU6IHRhZ05hbWUsXG4gIHNldFRleHRDb250ZW50OiBzZXRUZXh0Q29udGVudCxcbiAgc2V0U3R5bGVTY29wZTogc2V0U3R5bGVTY29wZVxufSk7XG5cbi8qICAqL1xuXG52YXIgcmVmID0ge1xuICBjcmVhdGU6IGZ1bmN0aW9uIGNyZWF0ZSAoXywgdm5vZGUpIHtcbiAgICByZWdpc3RlclJlZih2bm9kZSk7XG4gIH0sXG4gIHVwZGF0ZTogZnVuY3Rpb24gdXBkYXRlIChvbGRWbm9kZSwgdm5vZGUpIHtcbiAgICBpZiAob2xkVm5vZGUuZGF0YS5yZWYgIT09IHZub2RlLmRhdGEucmVmKSB7XG4gICAgICByZWdpc3RlclJlZihvbGRWbm9kZSwgdHJ1ZSk7XG4gICAgICByZWdpc3RlclJlZih2bm9kZSk7XG4gICAgfVxuICB9LFxuICBkZXN0cm95OiBmdW5jdGlvbiBkZXN0cm95ICh2bm9kZSkge1xuICAgIHJlZ2lzdGVyUmVmKHZub2RlLCB0cnVlKTtcbiAgfVxufTtcblxuZnVuY3Rpb24gcmVnaXN0ZXJSZWYgKHZub2RlLCBpc1JlbW92YWwpIHtcbiAgdmFyIGtleSA9IHZub2RlLmRhdGEucmVmO1xuICBpZiAoIWlzRGVmKGtleSkpIHsgcmV0dXJuIH1cblxuICB2YXIgdm0gPSB2bm9kZS5jb250ZXh0O1xuICB2YXIgcmVmID0gdm5vZGUuY29tcG9uZW50SW5zdGFuY2UgfHwgdm5vZGUuZWxtO1xuICB2YXIgcmVmcyA9IHZtLiRyZWZzO1xuICBpZiAoaXNSZW1vdmFsKSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkocmVmc1trZXldKSkge1xuICAgICAgcmVtb3ZlKHJlZnNba2V5XSwgcmVmKTtcbiAgICB9IGVsc2UgaWYgKHJlZnNba2V5XSA9PT0gcmVmKSB7XG4gICAgICByZWZzW2tleV0gPSB1bmRlZmluZWQ7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGlmICh2bm9kZS5kYXRhLnJlZkluRm9yKSB7XG4gICAgICBpZiAoIUFycmF5LmlzQXJyYXkocmVmc1trZXldKSkge1xuICAgICAgICByZWZzW2tleV0gPSBbcmVmXTtcbiAgICAgIH0gZWxzZSBpZiAocmVmc1trZXldLmluZGV4T2YocmVmKSA8IDApIHtcbiAgICAgICAgLy8gJGZsb3ctZGlzYWJsZS1saW5lXG4gICAgICAgIHJlZnNba2V5XS5wdXNoKHJlZik7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlZnNba2V5XSA9IHJlZjtcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBWaXJ0dWFsIERPTSBwYXRjaGluZyBhbGdvcml0aG0gYmFzZWQgb24gU25hYmJkb20gYnlcbiAqIFNpbW9uIEZyaWlzIFZpbmR1bSAoQHBhbGRlcGluZClcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZVxuICogaHR0cHM6Ly9naXRodWIuY29tL3BhbGRlcGluZC9zbmFiYmRvbS9ibG9iL21hc3Rlci9MSUNFTlNFXG4gKlxuICogbW9kaWZpZWQgYnkgRXZhbiBZb3UgKEB5eXg5OTA4MDMpXG4gKlxuICogTm90IHR5cGUtY2hlY2tpbmcgdGhpcyBiZWNhdXNlIHRoaXMgZmlsZSBpcyBwZXJmLWNyaXRpY2FsIGFuZCB0aGUgY29zdFxuICogb2YgbWFraW5nIGZsb3cgdW5kZXJzdGFuZCBpdCBpcyBub3Qgd29ydGggaXQuXG4gKi9cblxudmFyIGVtcHR5Tm9kZSA9IG5ldyBWTm9kZSgnJywge30sIFtdKTtcblxudmFyIGhvb2tzID0gWydjcmVhdGUnLCAnYWN0aXZhdGUnLCAndXBkYXRlJywgJ3JlbW92ZScsICdkZXN0cm95J107XG5cbmZ1bmN0aW9uIHNhbWVWbm9kZSAoYSwgYikge1xuICByZXR1cm4gKFxuICAgIGEua2V5ID09PSBiLmtleSAmJlxuICAgIGEuYXN5bmNGYWN0b3J5ID09PSBiLmFzeW5jRmFjdG9yeSAmJiAoXG4gICAgICAoXG4gICAgICAgIGEudGFnID09PSBiLnRhZyAmJlxuICAgICAgICBhLmlzQ29tbWVudCA9PT0gYi5pc0NvbW1lbnQgJiZcbiAgICAgICAgaXNEZWYoYS5kYXRhKSA9PT0gaXNEZWYoYi5kYXRhKSAmJlxuICAgICAgICBzYW1lSW5wdXRUeXBlKGEsIGIpXG4gICAgICApIHx8IChcbiAgICAgICAgaXNUcnVlKGEuaXNBc3luY1BsYWNlaG9sZGVyKSAmJlxuICAgICAgICBpc1VuZGVmKGIuYXN5bmNGYWN0b3J5LmVycm9yKVxuICAgICAgKVxuICAgIClcbiAgKVxufVxuXG5mdW5jdGlvbiBzYW1lSW5wdXRUeXBlIChhLCBiKSB7XG4gIGlmIChhLnRhZyAhPT0gJ2lucHV0JykgeyByZXR1cm4gdHJ1ZSB9XG4gIHZhciBpO1xuICB2YXIgdHlwZUEgPSBpc0RlZihpID0gYS5kYXRhKSAmJiBpc0RlZihpID0gaS5hdHRycykgJiYgaS50eXBlO1xuICB2YXIgdHlwZUIgPSBpc0RlZihpID0gYi5kYXRhKSAmJiBpc0RlZihpID0gaS5hdHRycykgJiYgaS50eXBlO1xuICByZXR1cm4gdHlwZUEgPT09IHR5cGVCIHx8IGlzVGV4dElucHV0VHlwZSh0eXBlQSkgJiYgaXNUZXh0SW5wdXRUeXBlKHR5cGVCKVxufVxuXG5mdW5jdGlvbiBjcmVhdGVLZXlUb09sZElkeCAoY2hpbGRyZW4sIGJlZ2luSWR4LCBlbmRJZHgpIHtcbiAgdmFyIGksIGtleTtcbiAgdmFyIG1hcCA9IHt9O1xuICBmb3IgKGkgPSBiZWdpbklkeDsgaSA8PSBlbmRJZHg7ICsraSkge1xuICAgIGtleSA9IGNoaWxkcmVuW2ldLmtleTtcbiAgICBpZiAoaXNEZWYoa2V5KSkgeyBtYXBba2V5XSA9IGk7IH1cbiAgfVxuICByZXR1cm4gbWFwXG59XG5cbmZ1bmN0aW9uIGNyZWF0ZVBhdGNoRnVuY3Rpb24gKGJhY2tlbmQpIHtcbiAgdmFyIGksIGo7XG4gIHZhciBjYnMgPSB7fTtcblxuICB2YXIgbW9kdWxlcyA9IGJhY2tlbmQubW9kdWxlcztcbiAgdmFyIG5vZGVPcHMgPSBiYWNrZW5kLm5vZGVPcHM7XG5cbiAgZm9yIChpID0gMDsgaSA8IGhvb2tzLmxlbmd0aDsgKytpKSB7XG4gICAgY2JzW2hvb2tzW2ldXSA9IFtdO1xuICAgIGZvciAoaiA9IDA7IGogPCBtb2R1bGVzLmxlbmd0aDsgKytqKSB7XG4gICAgICBpZiAoaXNEZWYobW9kdWxlc1tqXVtob29rc1tpXV0pKSB7XG4gICAgICAgIGNic1tob29rc1tpXV0ucHVzaChtb2R1bGVzW2pdW2hvb2tzW2ldXSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gZW1wdHlOb2RlQXQgKGVsbSkge1xuICAgIHJldHVybiBuZXcgVk5vZGUobm9kZU9wcy50YWdOYW1lKGVsbSkudG9Mb3dlckNhc2UoKSwge30sIFtdLCB1bmRlZmluZWQsIGVsbSlcbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZVJtQ2IgKGNoaWxkRWxtLCBsaXN0ZW5lcnMpIHtcbiAgICBmdW5jdGlvbiByZW1vdmUkJDEgKCkge1xuICAgICAgaWYgKC0tcmVtb3ZlJCQxLmxpc3RlbmVycyA9PT0gMCkge1xuICAgICAgICByZW1vdmVOb2RlKGNoaWxkRWxtKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmVtb3ZlJCQxLmxpc3RlbmVycyA9IGxpc3RlbmVycztcbiAgICByZXR1cm4gcmVtb3ZlJCQxXG4gIH1cblxuICBmdW5jdGlvbiByZW1vdmVOb2RlIChlbCkge1xuICAgIHZhciBwYXJlbnQgPSBub2RlT3BzLnBhcmVudE5vZGUoZWwpO1xuICAgIC8vIGVsZW1lbnQgbWF5IGhhdmUgYWxyZWFkeSBiZWVuIHJlbW92ZWQgZHVlIHRvIHYtaHRtbCAvIHYtdGV4dFxuICAgIGlmIChpc0RlZihwYXJlbnQpKSB7XG4gICAgICBub2RlT3BzLnJlbW92ZUNoaWxkKHBhcmVudCwgZWwpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGlzVW5rbm93bkVsZW1lbnQkJDEgKHZub2RlLCBpblZQcmUpIHtcbiAgICByZXR1cm4gKFxuICAgICAgIWluVlByZSAmJlxuICAgICAgIXZub2RlLm5zICYmXG4gICAgICAhKFxuICAgICAgICBjb25maWcuaWdub3JlZEVsZW1lbnRzLmxlbmd0aCAmJlxuICAgICAgICBjb25maWcuaWdub3JlZEVsZW1lbnRzLnNvbWUoZnVuY3Rpb24gKGlnbm9yZSkge1xuICAgICAgICAgIHJldHVybiBpc1JlZ0V4cChpZ25vcmUpXG4gICAgICAgICAgICA/IGlnbm9yZS50ZXN0KHZub2RlLnRhZylcbiAgICAgICAgICAgIDogaWdub3JlID09PSB2bm9kZS50YWdcbiAgICAgICAgfSlcbiAgICAgICkgJiZcbiAgICAgIGNvbmZpZy5pc1Vua25vd25FbGVtZW50KHZub2RlLnRhZylcbiAgICApXG4gIH1cblxuICB2YXIgY3JlYXRpbmdFbG1JblZQcmUgPSAwO1xuXG4gIGZ1bmN0aW9uIGNyZWF0ZUVsbSAoXG4gICAgdm5vZGUsXG4gICAgaW5zZXJ0ZWRWbm9kZVF1ZXVlLFxuICAgIHBhcmVudEVsbSxcbiAgICByZWZFbG0sXG4gICAgbmVzdGVkLFxuICAgIG93bmVyQXJyYXksXG4gICAgaW5kZXhcbiAgKSB7XG4gICAgaWYgKGlzRGVmKHZub2RlLmVsbSkgJiYgaXNEZWYob3duZXJBcnJheSkpIHtcbiAgICAgIC8vIFRoaXMgdm5vZGUgd2FzIHVzZWQgaW4gYSBwcmV2aW91cyByZW5kZXIhXG4gICAgICAvLyBub3cgaXQncyB1c2VkIGFzIGEgbmV3IG5vZGUsIG92ZXJ3cml0aW5nIGl0cyBlbG0gd291bGQgY2F1c2VcbiAgICAgIC8vIHBvdGVudGlhbCBwYXRjaCBlcnJvcnMgZG93biB0aGUgcm9hZCB3aGVuIGl0J3MgdXNlZCBhcyBhbiBpbnNlcnRpb25cbiAgICAgIC8vIHJlZmVyZW5jZSBub2RlLiBJbnN0ZWFkLCB3ZSBjbG9uZSB0aGUgbm9kZSBvbi1kZW1hbmQgYmVmb3JlIGNyZWF0aW5nXG4gICAgICAvLyBhc3NvY2lhdGVkIERPTSBlbGVtZW50IGZvciBpdC5cbiAgICAgIHZub2RlID0gb3duZXJBcnJheVtpbmRleF0gPSBjbG9uZVZOb2RlKHZub2RlKTtcbiAgICB9XG5cbiAgICB2bm9kZS5pc1Jvb3RJbnNlcnQgPSAhbmVzdGVkOyAvLyBmb3IgdHJhbnNpdGlvbiBlbnRlciBjaGVja1xuICAgIGlmIChjcmVhdGVDb21wb25lbnQodm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSwgcGFyZW50RWxtLCByZWZFbG0pKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICB2YXIgZGF0YSA9IHZub2RlLmRhdGE7XG4gICAgdmFyIGNoaWxkcmVuID0gdm5vZGUuY2hpbGRyZW47XG4gICAgdmFyIHRhZyA9IHZub2RlLnRhZztcbiAgICBpZiAoaXNEZWYodGFnKSkge1xuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgaWYgKGRhdGEgJiYgZGF0YS5wcmUpIHtcbiAgICAgICAgICBjcmVhdGluZ0VsbUluVlByZSsrO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpc1Vua25vd25FbGVtZW50JCQxKHZub2RlLCBjcmVhdGluZ0VsbUluVlByZSkpIHtcbiAgICAgICAgICB3YXJuKFxuICAgICAgICAgICAgJ1Vua25vd24gY3VzdG9tIGVsZW1lbnQ6IDwnICsgdGFnICsgJz4gLSBkaWQgeW91ICcgK1xuICAgICAgICAgICAgJ3JlZ2lzdGVyIHRoZSBjb21wb25lbnQgY29ycmVjdGx5PyBGb3IgcmVjdXJzaXZlIGNvbXBvbmVudHMsICcgK1xuICAgICAgICAgICAgJ21ha2Ugc3VyZSB0byBwcm92aWRlIHRoZSBcIm5hbWVcIiBvcHRpb24uJyxcbiAgICAgICAgICAgIHZub2RlLmNvbnRleHRcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHZub2RlLmVsbSA9IHZub2RlLm5zXG4gICAgICAgID8gbm9kZU9wcy5jcmVhdGVFbGVtZW50TlModm5vZGUubnMsIHRhZylcbiAgICAgICAgOiBub2RlT3BzLmNyZWF0ZUVsZW1lbnQodGFnLCB2bm9kZSk7XG4gICAgICBzZXRTY29wZSh2bm9kZSk7XG5cbiAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAge1xuICAgICAgICBjcmVhdGVDaGlsZHJlbih2bm9kZSwgY2hpbGRyZW4sIGluc2VydGVkVm5vZGVRdWV1ZSk7XG4gICAgICAgIGlmIChpc0RlZihkYXRhKSkge1xuICAgICAgICAgIGludm9rZUNyZWF0ZUhvb2tzKHZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUpO1xuICAgICAgICB9XG4gICAgICAgIGluc2VydChwYXJlbnRFbG0sIHZub2RlLmVsbSwgcmVmRWxtKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgZGF0YSAmJiBkYXRhLnByZSkge1xuICAgICAgICBjcmVhdGluZ0VsbUluVlByZS0tO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoaXNUcnVlKHZub2RlLmlzQ29tbWVudCkpIHtcbiAgICAgIHZub2RlLmVsbSA9IG5vZGVPcHMuY3JlYXRlQ29tbWVudCh2bm9kZS50ZXh0KTtcbiAgICAgIGluc2VydChwYXJlbnRFbG0sIHZub2RlLmVsbSwgcmVmRWxtKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdm5vZGUuZWxtID0gbm9kZU9wcy5jcmVhdGVUZXh0Tm9kZSh2bm9kZS50ZXh0KTtcbiAgICAgIGluc2VydChwYXJlbnRFbG0sIHZub2RlLmVsbSwgcmVmRWxtKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBjcmVhdGVDb21wb25lbnQgKHZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUsIHBhcmVudEVsbSwgcmVmRWxtKSB7XG4gICAgdmFyIGkgPSB2bm9kZS5kYXRhO1xuICAgIGlmIChpc0RlZihpKSkge1xuICAgICAgdmFyIGlzUmVhY3RpdmF0ZWQgPSBpc0RlZih2bm9kZS5jb21wb25lbnRJbnN0YW5jZSkgJiYgaS5rZWVwQWxpdmU7XG4gICAgICBpZiAoaXNEZWYoaSA9IGkuaG9vaykgJiYgaXNEZWYoaSA9IGkuaW5pdCkpIHtcbiAgICAgICAgaSh2bm9kZSwgZmFsc2UgLyogaHlkcmF0aW5nICovKTtcbiAgICAgIH1cbiAgICAgIC8vIGFmdGVyIGNhbGxpbmcgdGhlIGluaXQgaG9vaywgaWYgdGhlIHZub2RlIGlzIGEgY2hpbGQgY29tcG9uZW50XG4gICAgICAvLyBpdCBzaG91bGQndmUgY3JlYXRlZCBhIGNoaWxkIGluc3RhbmNlIGFuZCBtb3VudGVkIGl0LiB0aGUgY2hpbGRcbiAgICAgIC8vIGNvbXBvbmVudCBhbHNvIGhhcyBzZXQgdGhlIHBsYWNlaG9sZGVyIHZub2RlJ3MgZWxtLlxuICAgICAgLy8gaW4gdGhhdCBjYXNlIHdlIGNhbiBqdXN0IHJldHVybiB0aGUgZWxlbWVudCBhbmQgYmUgZG9uZS5cbiAgICAgIGlmIChpc0RlZih2bm9kZS5jb21wb25lbnRJbnN0YW5jZSkpIHtcbiAgICAgICAgaW5pdENvbXBvbmVudCh2bm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlKTtcbiAgICAgICAgaW5zZXJ0KHBhcmVudEVsbSwgdm5vZGUuZWxtLCByZWZFbG0pO1xuICAgICAgICBpZiAoaXNUcnVlKGlzUmVhY3RpdmF0ZWQpKSB7XG4gICAgICAgICAgcmVhY3RpdmF0ZUNvbXBvbmVudCh2bm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlLCBwYXJlbnRFbG0sIHJlZkVsbSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWVcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBpbml0Q29tcG9uZW50ICh2bm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlKSB7XG4gICAgaWYgKGlzRGVmKHZub2RlLmRhdGEucGVuZGluZ0luc2VydCkpIHtcbiAgICAgIGluc2VydGVkVm5vZGVRdWV1ZS5wdXNoLmFwcGx5KGluc2VydGVkVm5vZGVRdWV1ZSwgdm5vZGUuZGF0YS5wZW5kaW5nSW5zZXJ0KTtcbiAgICAgIHZub2RlLmRhdGEucGVuZGluZ0luc2VydCA9IG51bGw7XG4gICAgfVxuICAgIHZub2RlLmVsbSA9IHZub2RlLmNvbXBvbmVudEluc3RhbmNlLiRlbDtcbiAgICBpZiAoaXNQYXRjaGFibGUodm5vZGUpKSB7XG4gICAgICBpbnZva2VDcmVhdGVIb29rcyh2bm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlKTtcbiAgICAgIHNldFNjb3BlKHZub2RlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gZW1wdHkgY29tcG9uZW50IHJvb3QuXG4gICAgICAvLyBza2lwIGFsbCBlbGVtZW50LXJlbGF0ZWQgbW9kdWxlcyBleGNlcHQgZm9yIHJlZiAoIzM0NTUpXG4gICAgICByZWdpc3RlclJlZih2bm9kZSk7XG4gICAgICAvLyBtYWtlIHN1cmUgdG8gaW52b2tlIHRoZSBpbnNlcnQgaG9va1xuICAgICAgaW5zZXJ0ZWRWbm9kZVF1ZXVlLnB1c2godm5vZGUpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHJlYWN0aXZhdGVDb21wb25lbnQgKHZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUsIHBhcmVudEVsbSwgcmVmRWxtKSB7XG4gICAgdmFyIGk7XG4gICAgLy8gaGFjayBmb3IgIzQzMzk6IGEgcmVhY3RpdmF0ZWQgY29tcG9uZW50IHdpdGggaW5uZXIgdHJhbnNpdGlvblxuICAgIC8vIGRvZXMgbm90IHRyaWdnZXIgYmVjYXVzZSB0aGUgaW5uZXIgbm9kZSdzIGNyZWF0ZWQgaG9va3MgYXJlIG5vdCBjYWxsZWRcbiAgICAvLyBhZ2Fpbi4gSXQncyBub3QgaWRlYWwgdG8gaW52b2x2ZSBtb2R1bGUtc3BlY2lmaWMgbG9naWMgaW4gaGVyZSBidXRcbiAgICAvLyB0aGVyZSBkb2Vzbid0IHNlZW0gdG8gYmUgYSBiZXR0ZXIgd2F5IHRvIGRvIGl0LlxuICAgIHZhciBpbm5lck5vZGUgPSB2bm9kZTtcbiAgICB3aGlsZSAoaW5uZXJOb2RlLmNvbXBvbmVudEluc3RhbmNlKSB7XG4gICAgICBpbm5lck5vZGUgPSBpbm5lck5vZGUuY29tcG9uZW50SW5zdGFuY2UuX3Zub2RlO1xuICAgICAgaWYgKGlzRGVmKGkgPSBpbm5lck5vZGUuZGF0YSkgJiYgaXNEZWYoaSA9IGkudHJhbnNpdGlvbikpIHtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGNicy5hY3RpdmF0ZS5sZW5ndGg7ICsraSkge1xuICAgICAgICAgIGNicy5hY3RpdmF0ZVtpXShlbXB0eU5vZGUsIGlubmVyTm9kZSk7XG4gICAgICAgIH1cbiAgICAgICAgaW5zZXJ0ZWRWbm9kZVF1ZXVlLnB1c2goaW5uZXJOb2RlKTtcbiAgICAgICAgYnJlYWtcbiAgICAgIH1cbiAgICB9XG4gICAgLy8gdW5saWtlIGEgbmV3bHkgY3JlYXRlZCBjb21wb25lbnQsXG4gICAgLy8gYSByZWFjdGl2YXRlZCBrZWVwLWFsaXZlIGNvbXBvbmVudCBkb2Vzbid0IGluc2VydCBpdHNlbGZcbiAgICBpbnNlcnQocGFyZW50RWxtLCB2bm9kZS5lbG0sIHJlZkVsbSk7XG4gIH1cblxuICBmdW5jdGlvbiBpbnNlcnQgKHBhcmVudCwgZWxtLCByZWYkJDEpIHtcbiAgICBpZiAoaXNEZWYocGFyZW50KSkge1xuICAgICAgaWYgKGlzRGVmKHJlZiQkMSkpIHtcbiAgICAgICAgaWYgKG5vZGVPcHMucGFyZW50Tm9kZShyZWYkJDEpID09PSBwYXJlbnQpIHtcbiAgICAgICAgICBub2RlT3BzLmluc2VydEJlZm9yZShwYXJlbnQsIGVsbSwgcmVmJCQxKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbm9kZU9wcy5hcHBlbmRDaGlsZChwYXJlbnQsIGVsbSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gY3JlYXRlQ2hpbGRyZW4gKHZub2RlLCBjaGlsZHJlbiwgaW5zZXJ0ZWRWbm9kZVF1ZXVlKSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoY2hpbGRyZW4pKSB7XG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICBjaGVja0R1cGxpY2F0ZUtleXMoY2hpbGRyZW4pO1xuICAgICAgfVxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7ICsraSkge1xuICAgICAgICBjcmVhdGVFbG0oY2hpbGRyZW5baV0sIGluc2VydGVkVm5vZGVRdWV1ZSwgdm5vZGUuZWxtLCBudWxsLCB0cnVlLCBjaGlsZHJlbiwgaSk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChpc1ByaW1pdGl2ZSh2bm9kZS50ZXh0KSkge1xuICAgICAgbm9kZU9wcy5hcHBlbmRDaGlsZCh2bm9kZS5lbG0sIG5vZGVPcHMuY3JlYXRlVGV4dE5vZGUoU3RyaW5nKHZub2RlLnRleHQpKSk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gaXNQYXRjaGFibGUgKHZub2RlKSB7XG4gICAgd2hpbGUgKHZub2RlLmNvbXBvbmVudEluc3RhbmNlKSB7XG4gICAgICB2bm9kZSA9IHZub2RlLmNvbXBvbmVudEluc3RhbmNlLl92bm9kZTtcbiAgICB9XG4gICAgcmV0dXJuIGlzRGVmKHZub2RlLnRhZylcbiAgfVxuXG4gIGZ1bmN0aW9uIGludm9rZUNyZWF0ZUhvb2tzICh2bm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlKSB7XG4gICAgZm9yICh2YXIgaSQxID0gMDsgaSQxIDwgY2JzLmNyZWF0ZS5sZW5ndGg7ICsraSQxKSB7XG4gICAgICBjYnMuY3JlYXRlW2kkMV0oZW1wdHlOb2RlLCB2bm9kZSk7XG4gICAgfVxuICAgIGkgPSB2bm9kZS5kYXRhLmhvb2s7IC8vIFJldXNlIHZhcmlhYmxlXG4gICAgaWYgKGlzRGVmKGkpKSB7XG4gICAgICBpZiAoaXNEZWYoaS5jcmVhdGUpKSB7IGkuY3JlYXRlKGVtcHR5Tm9kZSwgdm5vZGUpOyB9XG4gICAgICBpZiAoaXNEZWYoaS5pbnNlcnQpKSB7IGluc2VydGVkVm5vZGVRdWV1ZS5wdXNoKHZub2RlKTsgfVxuICAgIH1cbiAgfVxuXG4gIC8vIHNldCBzY29wZSBpZCBhdHRyaWJ1dGUgZm9yIHNjb3BlZCBDU1MuXG4gIC8vIHRoaXMgaXMgaW1wbGVtZW50ZWQgYXMgYSBzcGVjaWFsIGNhc2UgdG8gYXZvaWQgdGhlIG92ZXJoZWFkXG4gIC8vIG9mIGdvaW5nIHRocm91Z2ggdGhlIG5vcm1hbCBhdHRyaWJ1dGUgcGF0Y2hpbmcgcHJvY2Vzcy5cbiAgZnVuY3Rpb24gc2V0U2NvcGUgKHZub2RlKSB7XG4gICAgdmFyIGk7XG4gICAgaWYgKGlzRGVmKGkgPSB2bm9kZS5mblNjb3BlSWQpKSB7XG4gICAgICBub2RlT3BzLnNldFN0eWxlU2NvcGUodm5vZGUuZWxtLCBpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIGFuY2VzdG9yID0gdm5vZGU7XG4gICAgICB3aGlsZSAoYW5jZXN0b3IpIHtcbiAgICAgICAgaWYgKGlzRGVmKGkgPSBhbmNlc3Rvci5jb250ZXh0KSAmJiBpc0RlZihpID0gaS4kb3B0aW9ucy5fc2NvcGVJZCkpIHtcbiAgICAgICAgICBub2RlT3BzLnNldFN0eWxlU2NvcGUodm5vZGUuZWxtLCBpKTtcbiAgICAgICAgfVxuICAgICAgICBhbmNlc3RvciA9IGFuY2VzdG9yLnBhcmVudDtcbiAgICAgIH1cbiAgICB9XG4gICAgLy8gZm9yIHNsb3QgY29udGVudCB0aGV5IHNob3VsZCBhbHNvIGdldCB0aGUgc2NvcGVJZCBmcm9tIHRoZSBob3N0IGluc3RhbmNlLlxuICAgIGlmIChpc0RlZihpID0gYWN0aXZlSW5zdGFuY2UpICYmXG4gICAgICBpICE9PSB2bm9kZS5jb250ZXh0ICYmXG4gICAgICBpICE9PSB2bm9kZS5mbkNvbnRleHQgJiZcbiAgICAgIGlzRGVmKGkgPSBpLiRvcHRpb25zLl9zY29wZUlkKVxuICAgICkge1xuICAgICAgbm9kZU9wcy5zZXRTdHlsZVNjb3BlKHZub2RlLmVsbSwgaSk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gYWRkVm5vZGVzIChwYXJlbnRFbG0sIHJlZkVsbSwgdm5vZGVzLCBzdGFydElkeCwgZW5kSWR4LCBpbnNlcnRlZFZub2RlUXVldWUpIHtcbiAgICBmb3IgKDsgc3RhcnRJZHggPD0gZW5kSWR4OyArK3N0YXJ0SWR4KSB7XG4gICAgICBjcmVhdGVFbG0odm5vZGVzW3N0YXJ0SWR4XSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlLCBwYXJlbnRFbG0sIHJlZkVsbSwgZmFsc2UsIHZub2Rlcywgc3RhcnRJZHgpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGludm9rZURlc3Ryb3lIb29rICh2bm9kZSkge1xuICAgIHZhciBpLCBqO1xuICAgIHZhciBkYXRhID0gdm5vZGUuZGF0YTtcbiAgICBpZiAoaXNEZWYoZGF0YSkpIHtcbiAgICAgIGlmIChpc0RlZihpID0gZGF0YS5ob29rKSAmJiBpc0RlZihpID0gaS5kZXN0cm95KSkgeyBpKHZub2RlKTsgfVxuICAgICAgZm9yIChpID0gMDsgaSA8IGNicy5kZXN0cm95Lmxlbmd0aDsgKytpKSB7IGNicy5kZXN0cm95W2ldKHZub2RlKTsgfVxuICAgIH1cbiAgICBpZiAoaXNEZWYoaSA9IHZub2RlLmNoaWxkcmVuKSkge1xuICAgICAgZm9yIChqID0gMDsgaiA8IHZub2RlLmNoaWxkcmVuLmxlbmd0aDsgKytqKSB7XG4gICAgICAgIGludm9rZURlc3Ryb3lIb29rKHZub2RlLmNoaWxkcmVuW2pdKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiByZW1vdmVWbm9kZXMgKHZub2Rlcywgc3RhcnRJZHgsIGVuZElkeCkge1xuICAgIGZvciAoOyBzdGFydElkeCA8PSBlbmRJZHg7ICsrc3RhcnRJZHgpIHtcbiAgICAgIHZhciBjaCA9IHZub2Rlc1tzdGFydElkeF07XG4gICAgICBpZiAoaXNEZWYoY2gpKSB7XG4gICAgICAgIGlmIChpc0RlZihjaC50YWcpKSB7XG4gICAgICAgICAgcmVtb3ZlQW5kSW52b2tlUmVtb3ZlSG9vayhjaCk7XG4gICAgICAgICAgaW52b2tlRGVzdHJveUhvb2soY2gpO1xuICAgICAgICB9IGVsc2UgeyAvLyBUZXh0IG5vZGVcbiAgICAgICAgICByZW1vdmVOb2RlKGNoLmVsbSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiByZW1vdmVBbmRJbnZva2VSZW1vdmVIb29rICh2bm9kZSwgcm0pIHtcbiAgICBpZiAoaXNEZWYocm0pIHx8IGlzRGVmKHZub2RlLmRhdGEpKSB7XG4gICAgICB2YXIgaTtcbiAgICAgIHZhciBsaXN0ZW5lcnMgPSBjYnMucmVtb3ZlLmxlbmd0aCArIDE7XG4gICAgICBpZiAoaXNEZWYocm0pKSB7XG4gICAgICAgIC8vIHdlIGhhdmUgYSByZWN1cnNpdmVseSBwYXNzZWQgZG93biBybSBjYWxsYmFja1xuICAgICAgICAvLyBpbmNyZWFzZSB0aGUgbGlzdGVuZXJzIGNvdW50XG4gICAgICAgIHJtLmxpc3RlbmVycyArPSBsaXN0ZW5lcnM7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBkaXJlY3RseSByZW1vdmluZ1xuICAgICAgICBybSA9IGNyZWF0ZVJtQ2Iodm5vZGUuZWxtLCBsaXN0ZW5lcnMpO1xuICAgICAgfVxuICAgICAgLy8gcmVjdXJzaXZlbHkgaW52b2tlIGhvb2tzIG9uIGNoaWxkIGNvbXBvbmVudCByb290IG5vZGVcbiAgICAgIGlmIChpc0RlZihpID0gdm5vZGUuY29tcG9uZW50SW5zdGFuY2UpICYmIGlzRGVmKGkgPSBpLl92bm9kZSkgJiYgaXNEZWYoaS5kYXRhKSkge1xuICAgICAgICByZW1vdmVBbmRJbnZva2VSZW1vdmVIb29rKGksIHJtKTtcbiAgICAgIH1cbiAgICAgIGZvciAoaSA9IDA7IGkgPCBjYnMucmVtb3ZlLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIGNicy5yZW1vdmVbaV0odm5vZGUsIHJtKTtcbiAgICAgIH1cbiAgICAgIGlmIChpc0RlZihpID0gdm5vZGUuZGF0YS5ob29rKSAmJiBpc0RlZihpID0gaS5yZW1vdmUpKSB7XG4gICAgICAgIGkodm5vZGUsIHJtKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJtKCk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlbW92ZU5vZGUodm5vZGUuZWxtKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiB1cGRhdGVDaGlsZHJlbiAocGFyZW50RWxtLCBvbGRDaCwgbmV3Q2gsIGluc2VydGVkVm5vZGVRdWV1ZSwgcmVtb3ZlT25seSkge1xuICAgIHZhciBvbGRTdGFydElkeCA9IDA7XG4gICAgdmFyIG5ld1N0YXJ0SWR4ID0gMDtcbiAgICB2YXIgb2xkRW5kSWR4ID0gb2xkQ2gubGVuZ3RoIC0gMTtcbiAgICB2YXIgb2xkU3RhcnRWbm9kZSA9IG9sZENoWzBdO1xuICAgIHZhciBvbGRFbmRWbm9kZSA9IG9sZENoW29sZEVuZElkeF07XG4gICAgdmFyIG5ld0VuZElkeCA9IG5ld0NoLmxlbmd0aCAtIDE7XG4gICAgdmFyIG5ld1N0YXJ0Vm5vZGUgPSBuZXdDaFswXTtcbiAgICB2YXIgbmV3RW5kVm5vZGUgPSBuZXdDaFtuZXdFbmRJZHhdO1xuICAgIHZhciBvbGRLZXlUb0lkeCwgaWR4SW5PbGQsIHZub2RlVG9Nb3ZlLCByZWZFbG07XG5cbiAgICAvLyByZW1vdmVPbmx5IGlzIGEgc3BlY2lhbCBmbGFnIHVzZWQgb25seSBieSA8dHJhbnNpdGlvbi1ncm91cD5cbiAgICAvLyB0byBlbnN1cmUgcmVtb3ZlZCBlbGVtZW50cyBzdGF5IGluIGNvcnJlY3QgcmVsYXRpdmUgcG9zaXRpb25zXG4gICAgLy8gZHVyaW5nIGxlYXZpbmcgdHJhbnNpdGlvbnNcbiAgICB2YXIgY2FuTW92ZSA9ICFyZW1vdmVPbmx5O1xuXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIGNoZWNrRHVwbGljYXRlS2V5cyhuZXdDaCk7XG4gICAgfVxuXG4gICAgd2hpbGUgKG9sZFN0YXJ0SWR4IDw9IG9sZEVuZElkeCAmJiBuZXdTdGFydElkeCA8PSBuZXdFbmRJZHgpIHtcbiAgICAgIGlmIChpc1VuZGVmKG9sZFN0YXJ0Vm5vZGUpKSB7XG4gICAgICAgIG9sZFN0YXJ0Vm5vZGUgPSBvbGRDaFsrK29sZFN0YXJ0SWR4XTsgLy8gVm5vZGUgaGFzIGJlZW4gbW92ZWQgbGVmdFxuICAgICAgfSBlbHNlIGlmIChpc1VuZGVmKG9sZEVuZFZub2RlKSkge1xuICAgICAgICBvbGRFbmRWbm9kZSA9IG9sZENoWy0tb2xkRW5kSWR4XTtcbiAgICAgIH0gZWxzZSBpZiAoc2FtZVZub2RlKG9sZFN0YXJ0Vm5vZGUsIG5ld1N0YXJ0Vm5vZGUpKSB7XG4gICAgICAgIHBhdGNoVm5vZGUob2xkU3RhcnRWbm9kZSwgbmV3U3RhcnRWbm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlLCBuZXdDaCwgbmV3U3RhcnRJZHgpO1xuICAgICAgICBvbGRTdGFydFZub2RlID0gb2xkQ2hbKytvbGRTdGFydElkeF07XG4gICAgICAgIG5ld1N0YXJ0Vm5vZGUgPSBuZXdDaFsrK25ld1N0YXJ0SWR4XTtcbiAgICAgIH0gZWxzZSBpZiAoc2FtZVZub2RlKG9sZEVuZFZub2RlLCBuZXdFbmRWbm9kZSkpIHtcbiAgICAgICAgcGF0Y2hWbm9kZShvbGRFbmRWbm9kZSwgbmV3RW5kVm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSwgbmV3Q2gsIG5ld0VuZElkeCk7XG4gICAgICAgIG9sZEVuZFZub2RlID0gb2xkQ2hbLS1vbGRFbmRJZHhdO1xuICAgICAgICBuZXdFbmRWbm9kZSA9IG5ld0NoWy0tbmV3RW5kSWR4XTtcbiAgICAgIH0gZWxzZSBpZiAoc2FtZVZub2RlKG9sZFN0YXJ0Vm5vZGUsIG5ld0VuZFZub2RlKSkgeyAvLyBWbm9kZSBtb3ZlZCByaWdodFxuICAgICAgICBwYXRjaFZub2RlKG9sZFN0YXJ0Vm5vZGUsIG5ld0VuZFZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUsIG5ld0NoLCBuZXdFbmRJZHgpO1xuICAgICAgICBjYW5Nb3ZlICYmIG5vZGVPcHMuaW5zZXJ0QmVmb3JlKHBhcmVudEVsbSwgb2xkU3RhcnRWbm9kZS5lbG0sIG5vZGVPcHMubmV4dFNpYmxpbmcob2xkRW5kVm5vZGUuZWxtKSk7XG4gICAgICAgIG9sZFN0YXJ0Vm5vZGUgPSBvbGRDaFsrK29sZFN0YXJ0SWR4XTtcbiAgICAgICAgbmV3RW5kVm5vZGUgPSBuZXdDaFstLW5ld0VuZElkeF07XG4gICAgICB9IGVsc2UgaWYgKHNhbWVWbm9kZShvbGRFbmRWbm9kZSwgbmV3U3RhcnRWbm9kZSkpIHsgLy8gVm5vZGUgbW92ZWQgbGVmdFxuICAgICAgICBwYXRjaFZub2RlKG9sZEVuZFZub2RlLCBuZXdTdGFydFZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUsIG5ld0NoLCBuZXdTdGFydElkeCk7XG4gICAgICAgIGNhbk1vdmUgJiYgbm9kZU9wcy5pbnNlcnRCZWZvcmUocGFyZW50RWxtLCBvbGRFbmRWbm9kZS5lbG0sIG9sZFN0YXJ0Vm5vZGUuZWxtKTtcbiAgICAgICAgb2xkRW5kVm5vZGUgPSBvbGRDaFstLW9sZEVuZElkeF07XG4gICAgICAgIG5ld1N0YXJ0Vm5vZGUgPSBuZXdDaFsrK25ld1N0YXJ0SWR4XTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChpc1VuZGVmKG9sZEtleVRvSWR4KSkgeyBvbGRLZXlUb0lkeCA9IGNyZWF0ZUtleVRvT2xkSWR4KG9sZENoLCBvbGRTdGFydElkeCwgb2xkRW5kSWR4KTsgfVxuICAgICAgICBpZHhJbk9sZCA9IGlzRGVmKG5ld1N0YXJ0Vm5vZGUua2V5KVxuICAgICAgICAgID8gb2xkS2V5VG9JZHhbbmV3U3RhcnRWbm9kZS5rZXldXG4gICAgICAgICAgOiBmaW5kSWR4SW5PbGQobmV3U3RhcnRWbm9kZSwgb2xkQ2gsIG9sZFN0YXJ0SWR4LCBvbGRFbmRJZHgpO1xuICAgICAgICBpZiAoaXNVbmRlZihpZHhJbk9sZCkpIHsgLy8gTmV3IGVsZW1lbnRcbiAgICAgICAgICBjcmVhdGVFbG0obmV3U3RhcnRWbm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlLCBwYXJlbnRFbG0sIG9sZFN0YXJ0Vm5vZGUuZWxtLCBmYWxzZSwgbmV3Q2gsIG5ld1N0YXJ0SWR4KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2bm9kZVRvTW92ZSA9IG9sZENoW2lkeEluT2xkXTtcbiAgICAgICAgICBpZiAoc2FtZVZub2RlKHZub2RlVG9Nb3ZlLCBuZXdTdGFydFZub2RlKSkge1xuICAgICAgICAgICAgcGF0Y2hWbm9kZSh2bm9kZVRvTW92ZSwgbmV3U3RhcnRWbm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlLCBuZXdDaCwgbmV3U3RhcnRJZHgpO1xuICAgICAgICAgICAgb2xkQ2hbaWR4SW5PbGRdID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgY2FuTW92ZSAmJiBub2RlT3BzLmluc2VydEJlZm9yZShwYXJlbnRFbG0sIHZub2RlVG9Nb3ZlLmVsbSwgb2xkU3RhcnRWbm9kZS5lbG0pO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBzYW1lIGtleSBidXQgZGlmZmVyZW50IGVsZW1lbnQuIHRyZWF0IGFzIG5ldyBlbGVtZW50XG4gICAgICAgICAgICBjcmVhdGVFbG0obmV3U3RhcnRWbm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlLCBwYXJlbnRFbG0sIG9sZFN0YXJ0Vm5vZGUuZWxtLCBmYWxzZSwgbmV3Q2gsIG5ld1N0YXJ0SWR4KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgbmV3U3RhcnRWbm9kZSA9IG5ld0NoWysrbmV3U3RhcnRJZHhdO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAob2xkU3RhcnRJZHggPiBvbGRFbmRJZHgpIHtcbiAgICAgIHJlZkVsbSA9IGlzVW5kZWYobmV3Q2hbbmV3RW5kSWR4ICsgMV0pID8gbnVsbCA6IG5ld0NoW25ld0VuZElkeCArIDFdLmVsbTtcbiAgICAgIGFkZFZub2RlcyhwYXJlbnRFbG0sIHJlZkVsbSwgbmV3Q2gsIG5ld1N0YXJ0SWR4LCBuZXdFbmRJZHgsIGluc2VydGVkVm5vZGVRdWV1ZSk7XG4gICAgfSBlbHNlIGlmIChuZXdTdGFydElkeCA+IG5ld0VuZElkeCkge1xuICAgICAgcmVtb3ZlVm5vZGVzKG9sZENoLCBvbGRTdGFydElkeCwgb2xkRW5kSWR4KTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBjaGVja0R1cGxpY2F0ZUtleXMgKGNoaWxkcmVuKSB7XG4gICAgdmFyIHNlZW5LZXlzID0ge307XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIHZub2RlID0gY2hpbGRyZW5baV07XG4gICAgICB2YXIga2V5ID0gdm5vZGUua2V5O1xuICAgICAgaWYgKGlzRGVmKGtleSkpIHtcbiAgICAgICAgaWYgKHNlZW5LZXlzW2tleV0pIHtcbiAgICAgICAgICB3YXJuKFxuICAgICAgICAgICAgKFwiRHVwbGljYXRlIGtleXMgZGV0ZWN0ZWQ6ICdcIiArIGtleSArIFwiJy4gVGhpcyBtYXkgY2F1c2UgYW4gdXBkYXRlIGVycm9yLlwiKSxcbiAgICAgICAgICAgIHZub2RlLmNvbnRleHRcbiAgICAgICAgICApO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHNlZW5LZXlzW2tleV0gPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gZmluZElkeEluT2xkIChub2RlLCBvbGRDaCwgc3RhcnQsIGVuZCkge1xuICAgIGZvciAodmFyIGkgPSBzdGFydDsgaSA8IGVuZDsgaSsrKSB7XG4gICAgICB2YXIgYyA9IG9sZENoW2ldO1xuICAgICAgaWYgKGlzRGVmKGMpICYmIHNhbWVWbm9kZShub2RlLCBjKSkgeyByZXR1cm4gaSB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gcGF0Y2hWbm9kZSAoXG4gICAgb2xkVm5vZGUsXG4gICAgdm5vZGUsXG4gICAgaW5zZXJ0ZWRWbm9kZVF1ZXVlLFxuICAgIG93bmVyQXJyYXksXG4gICAgaW5kZXgsXG4gICAgcmVtb3ZlT25seVxuICApIHtcbiAgICBpZiAob2xkVm5vZGUgPT09IHZub2RlKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICBpZiAoaXNEZWYodm5vZGUuZWxtKSAmJiBpc0RlZihvd25lckFycmF5KSkge1xuICAgICAgLy8gY2xvbmUgcmV1c2VkIHZub2RlXG4gICAgICB2bm9kZSA9IG93bmVyQXJyYXlbaW5kZXhdID0gY2xvbmVWTm9kZSh2bm9kZSk7XG4gICAgfVxuXG4gICAgdmFyIGVsbSA9IHZub2RlLmVsbSA9IG9sZFZub2RlLmVsbTtcblxuICAgIGlmIChpc1RydWUob2xkVm5vZGUuaXNBc3luY1BsYWNlaG9sZGVyKSkge1xuICAgICAgaWYgKGlzRGVmKHZub2RlLmFzeW5jRmFjdG9yeS5yZXNvbHZlZCkpIHtcbiAgICAgICAgaHlkcmF0ZShvbGRWbm9kZS5lbG0sIHZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdm5vZGUuaXNBc3luY1BsYWNlaG9sZGVyID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIC8vIHJldXNlIGVsZW1lbnQgZm9yIHN0YXRpYyB0cmVlcy5cbiAgICAvLyBub3RlIHdlIG9ubHkgZG8gdGhpcyBpZiB0aGUgdm5vZGUgaXMgY2xvbmVkIC1cbiAgICAvLyBpZiB0aGUgbmV3IG5vZGUgaXMgbm90IGNsb25lZCBpdCBtZWFucyB0aGUgcmVuZGVyIGZ1bmN0aW9ucyBoYXZlIGJlZW5cbiAgICAvLyByZXNldCBieSB0aGUgaG90LXJlbG9hZC1hcGkgYW5kIHdlIG5lZWQgdG8gZG8gYSBwcm9wZXIgcmUtcmVuZGVyLlxuICAgIGlmIChpc1RydWUodm5vZGUuaXNTdGF0aWMpICYmXG4gICAgICBpc1RydWUob2xkVm5vZGUuaXNTdGF0aWMpICYmXG4gICAgICB2bm9kZS5rZXkgPT09IG9sZFZub2RlLmtleSAmJlxuICAgICAgKGlzVHJ1ZSh2bm9kZS5pc0Nsb25lZCkgfHwgaXNUcnVlKHZub2RlLmlzT25jZSkpXG4gICAgKSB7XG4gICAgICB2bm9kZS5jb21wb25lbnRJbnN0YW5jZSA9IG9sZFZub2RlLmNvbXBvbmVudEluc3RhbmNlO1xuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgdmFyIGk7XG4gICAgdmFyIGRhdGEgPSB2bm9kZS5kYXRhO1xuICAgIGlmIChpc0RlZihkYXRhKSAmJiBpc0RlZihpID0gZGF0YS5ob29rKSAmJiBpc0RlZihpID0gaS5wcmVwYXRjaCkpIHtcbiAgICAgIGkob2xkVm5vZGUsIHZub2RlKTtcbiAgICB9XG5cbiAgICB2YXIgb2xkQ2ggPSBvbGRWbm9kZS5jaGlsZHJlbjtcbiAgICB2YXIgY2ggPSB2bm9kZS5jaGlsZHJlbjtcbiAgICBpZiAoaXNEZWYoZGF0YSkgJiYgaXNQYXRjaGFibGUodm5vZGUpKSB7XG4gICAgICBmb3IgKGkgPSAwOyBpIDwgY2JzLnVwZGF0ZS5sZW5ndGg7ICsraSkgeyBjYnMudXBkYXRlW2ldKG9sZFZub2RlLCB2bm9kZSk7IH1cbiAgICAgIGlmIChpc0RlZihpID0gZGF0YS5ob29rKSAmJiBpc0RlZihpID0gaS51cGRhdGUpKSB7IGkob2xkVm5vZGUsIHZub2RlKTsgfVxuICAgIH1cbiAgICBpZiAoaXNVbmRlZih2bm9kZS50ZXh0KSkge1xuICAgICAgaWYgKGlzRGVmKG9sZENoKSAmJiBpc0RlZihjaCkpIHtcbiAgICAgICAgaWYgKG9sZENoICE9PSBjaCkgeyB1cGRhdGVDaGlsZHJlbihlbG0sIG9sZENoLCBjaCwgaW5zZXJ0ZWRWbm9kZVF1ZXVlLCByZW1vdmVPbmx5KTsgfVxuICAgICAgfSBlbHNlIGlmIChpc0RlZihjaCkpIHtcbiAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgICBjaGVja0R1cGxpY2F0ZUtleXMoY2gpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpc0RlZihvbGRWbm9kZS50ZXh0KSkgeyBub2RlT3BzLnNldFRleHRDb250ZW50KGVsbSwgJycpOyB9XG4gICAgICAgIGFkZFZub2RlcyhlbG0sIG51bGwsIGNoLCAwLCBjaC5sZW5ndGggLSAxLCBpbnNlcnRlZFZub2RlUXVldWUpO1xuICAgICAgfSBlbHNlIGlmIChpc0RlZihvbGRDaCkpIHtcbiAgICAgICAgcmVtb3ZlVm5vZGVzKG9sZENoLCAwLCBvbGRDaC5sZW5ndGggLSAxKTtcbiAgICAgIH0gZWxzZSBpZiAoaXNEZWYob2xkVm5vZGUudGV4dCkpIHtcbiAgICAgICAgbm9kZU9wcy5zZXRUZXh0Q29udGVudChlbG0sICcnKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKG9sZFZub2RlLnRleHQgIT09IHZub2RlLnRleHQpIHtcbiAgICAgIG5vZGVPcHMuc2V0VGV4dENvbnRlbnQoZWxtLCB2bm9kZS50ZXh0KTtcbiAgICB9XG4gICAgaWYgKGlzRGVmKGRhdGEpKSB7XG4gICAgICBpZiAoaXNEZWYoaSA9IGRhdGEuaG9vaykgJiYgaXNEZWYoaSA9IGkucG9zdHBhdGNoKSkgeyBpKG9sZFZub2RlLCB2bm9kZSk7IH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBpbnZva2VJbnNlcnRIb29rICh2bm9kZSwgcXVldWUsIGluaXRpYWwpIHtcbiAgICAvLyBkZWxheSBpbnNlcnQgaG9va3MgZm9yIGNvbXBvbmVudCByb290IG5vZGVzLCBpbnZva2UgdGhlbSBhZnRlciB0aGVcbiAgICAvLyBlbGVtZW50IGlzIHJlYWxseSBpbnNlcnRlZFxuICAgIGlmIChpc1RydWUoaW5pdGlhbCkgJiYgaXNEZWYodm5vZGUucGFyZW50KSkge1xuICAgICAgdm5vZGUucGFyZW50LmRhdGEucGVuZGluZ0luc2VydCA9IHF1ZXVlO1xuICAgIH0gZWxzZSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHF1ZXVlLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIHF1ZXVlW2ldLmRhdGEuaG9vay5pbnNlcnQocXVldWVbaV0pO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHZhciBoeWRyYXRpb25CYWlsZWQgPSBmYWxzZTtcbiAgLy8gbGlzdCBvZiBtb2R1bGVzIHRoYXQgY2FuIHNraXAgY3JlYXRlIGhvb2sgZHVyaW5nIGh5ZHJhdGlvbiBiZWNhdXNlIHRoZXlcbiAgLy8gYXJlIGFscmVhZHkgcmVuZGVyZWQgb24gdGhlIGNsaWVudCBvciBoYXMgbm8gbmVlZCBmb3IgaW5pdGlhbGl6YXRpb25cbiAgLy8gTm90ZTogc3R5bGUgaXMgZXhjbHVkZWQgYmVjYXVzZSBpdCByZWxpZXMgb24gaW5pdGlhbCBjbG9uZSBmb3IgZnV0dXJlXG4gIC8vIGRlZXAgdXBkYXRlcyAoIzcwNjMpLlxuICB2YXIgaXNSZW5kZXJlZE1vZHVsZSA9IG1ha2VNYXAoJ2F0dHJzLGNsYXNzLHN0YXRpY0NsYXNzLHN0YXRpY1N0eWxlLGtleScpO1xuXG4gIC8vIE5vdGU6IHRoaXMgaXMgYSBicm93c2VyLW9ubHkgZnVuY3Rpb24gc28gd2UgY2FuIGFzc3VtZSBlbG1zIGFyZSBET00gbm9kZXMuXG4gIGZ1bmN0aW9uIGh5ZHJhdGUgKGVsbSwgdm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSwgaW5WUHJlKSB7XG4gICAgdmFyIGk7XG4gICAgdmFyIHRhZyA9IHZub2RlLnRhZztcbiAgICB2YXIgZGF0YSA9IHZub2RlLmRhdGE7XG4gICAgdmFyIGNoaWxkcmVuID0gdm5vZGUuY2hpbGRyZW47XG4gICAgaW5WUHJlID0gaW5WUHJlIHx8IChkYXRhICYmIGRhdGEucHJlKTtcbiAgICB2bm9kZS5lbG0gPSBlbG07XG5cbiAgICBpZiAoaXNUcnVlKHZub2RlLmlzQ29tbWVudCkgJiYgaXNEZWYodm5vZGUuYXN5bmNGYWN0b3J5KSkge1xuICAgICAgdm5vZGUuaXNBc3luY1BsYWNlaG9sZGVyID0gdHJ1ZTtcbiAgICAgIHJldHVybiB0cnVlXG4gICAgfVxuICAgIC8vIGFzc2VydCBub2RlIG1hdGNoXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIGlmICghYXNzZXJ0Tm9kZU1hdGNoKGVsbSwgdm5vZGUsIGluVlByZSkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICB9XG4gICAgfVxuICAgIGlmIChpc0RlZihkYXRhKSkge1xuICAgICAgaWYgKGlzRGVmKGkgPSBkYXRhLmhvb2spICYmIGlzRGVmKGkgPSBpLmluaXQpKSB7IGkodm5vZGUsIHRydWUgLyogaHlkcmF0aW5nICovKTsgfVxuICAgICAgaWYgKGlzRGVmKGkgPSB2bm9kZS5jb21wb25lbnRJbnN0YW5jZSkpIHtcbiAgICAgICAgLy8gY2hpbGQgY29tcG9uZW50LiBpdCBzaG91bGQgaGF2ZSBoeWRyYXRlZCBpdHMgb3duIHRyZWUuXG4gICAgICAgIGluaXRDb21wb25lbnQodm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSk7XG4gICAgICAgIHJldHVybiB0cnVlXG4gICAgICB9XG4gICAgfVxuICAgIGlmIChpc0RlZih0YWcpKSB7XG4gICAgICBpZiAoaXNEZWYoY2hpbGRyZW4pKSB7XG4gICAgICAgIC8vIGVtcHR5IGVsZW1lbnQsIGFsbG93IGNsaWVudCB0byBwaWNrIHVwIGFuZCBwb3B1bGF0ZSBjaGlsZHJlblxuICAgICAgICBpZiAoIWVsbS5oYXNDaGlsZE5vZGVzKCkpIHtcbiAgICAgICAgICBjcmVhdGVDaGlsZHJlbih2bm9kZSwgY2hpbGRyZW4sIGluc2VydGVkVm5vZGVRdWV1ZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gdi1odG1sIGFuZCBkb21Qcm9wczogaW5uZXJIVE1MXG4gICAgICAgICAgaWYgKGlzRGVmKGkgPSBkYXRhKSAmJiBpc0RlZihpID0gaS5kb21Qcm9wcykgJiYgaXNEZWYoaSA9IGkuaW5uZXJIVE1MKSkge1xuICAgICAgICAgICAgaWYgKGkgIT09IGVsbS5pbm5lckhUTUwpIHtcbiAgICAgICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICAgICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmXG4gICAgICAgICAgICAgICAgdHlwZW9mIGNvbnNvbGUgIT09ICd1bmRlZmluZWQnICYmXG4gICAgICAgICAgICAgICAgIWh5ZHJhdGlvbkJhaWxlZFxuICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICBoeWRyYXRpb25CYWlsZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybignUGFyZW50OiAnLCBlbG0pO1xuICAgICAgICAgICAgICAgIGNvbnNvbGUud2Fybignc2VydmVyIGlubmVySFRNTDogJywgaSk7XG4gICAgICAgICAgICAgICAgY29uc29sZS53YXJuKCdjbGllbnQgaW5uZXJIVE1MOiAnLCBlbG0uaW5uZXJIVE1MKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gaXRlcmF0ZSBhbmQgY29tcGFyZSBjaGlsZHJlbiBsaXN0c1xuICAgICAgICAgICAgdmFyIGNoaWxkcmVuTWF0Y2ggPSB0cnVlO1xuICAgICAgICAgICAgdmFyIGNoaWxkTm9kZSA9IGVsbS5maXJzdENoaWxkO1xuICAgICAgICAgICAgZm9yICh2YXIgaSQxID0gMDsgaSQxIDwgY2hpbGRyZW4ubGVuZ3RoOyBpJDErKykge1xuICAgICAgICAgICAgICBpZiAoIWNoaWxkTm9kZSB8fCAhaHlkcmF0ZShjaGlsZE5vZGUsIGNoaWxkcmVuW2kkMV0sIGluc2VydGVkVm5vZGVRdWV1ZSwgaW5WUHJlKSkge1xuICAgICAgICAgICAgICAgIGNoaWxkcmVuTWF0Y2ggPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBicmVha1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGNoaWxkTm9kZSA9IGNoaWxkTm9kZS5uZXh0U2libGluZztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGlmIGNoaWxkTm9kZSBpcyBub3QgbnVsbCwgaXQgbWVhbnMgdGhlIGFjdHVhbCBjaGlsZE5vZGVzIGxpc3QgaXNcbiAgICAgICAgICAgIC8vIGxvbmdlciB0aGFuIHRoZSB2aXJ0dWFsIGNoaWxkcmVuIGxpc3QuXG4gICAgICAgICAgICBpZiAoIWNoaWxkcmVuTWF0Y2ggfHwgY2hpbGROb2RlKSB7XG4gICAgICAgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJlxuICAgICAgICAgICAgICAgIHR5cGVvZiBjb25zb2xlICE9PSAndW5kZWZpbmVkJyAmJlxuICAgICAgICAgICAgICAgICFoeWRyYXRpb25CYWlsZWRcbiAgICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgaHlkcmF0aW9uQmFpbGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oJ1BhcmVudDogJywgZWxtKTtcbiAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oJ01pc21hdGNoaW5nIGNoaWxkTm9kZXMgdnMuIFZOb2RlczogJywgZWxtLmNoaWxkTm9kZXMsIGNoaWxkcmVuKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChpc0RlZihkYXRhKSkge1xuICAgICAgICB2YXIgZnVsbEludm9rZSA9IGZhbHNlO1xuICAgICAgICBmb3IgKHZhciBrZXkgaW4gZGF0YSkge1xuICAgICAgICAgIGlmICghaXNSZW5kZXJlZE1vZHVsZShrZXkpKSB7XG4gICAgICAgICAgICBmdWxsSW52b2tlID0gdHJ1ZTtcbiAgICAgICAgICAgIGludm9rZUNyZWF0ZUhvb2tzKHZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUpO1xuICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFmdWxsSW52b2tlICYmIGRhdGFbJ2NsYXNzJ10pIHtcbiAgICAgICAgICAvLyBlbnN1cmUgY29sbGVjdGluZyBkZXBzIGZvciBkZWVwIGNsYXNzIGJpbmRpbmdzIGZvciBmdXR1cmUgdXBkYXRlc1xuICAgICAgICAgIHRyYXZlcnNlKGRhdGFbJ2NsYXNzJ10pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChlbG0uZGF0YSAhPT0gdm5vZGUudGV4dCkge1xuICAgICAgZWxtLmRhdGEgPSB2bm9kZS50ZXh0O1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZVxuICB9XG5cbiAgZnVuY3Rpb24gYXNzZXJ0Tm9kZU1hdGNoIChub2RlLCB2bm9kZSwgaW5WUHJlKSB7XG4gICAgaWYgKGlzRGVmKHZub2RlLnRhZykpIHtcbiAgICAgIHJldHVybiB2bm9kZS50YWcuaW5kZXhPZigndnVlLWNvbXBvbmVudCcpID09PSAwIHx8IChcbiAgICAgICAgIWlzVW5rbm93bkVsZW1lbnQkJDEodm5vZGUsIGluVlByZSkgJiZcbiAgICAgICAgdm5vZGUudGFnLnRvTG93ZXJDYXNlKCkgPT09IChub2RlLnRhZ05hbWUgJiYgbm9kZS50YWdOYW1lLnRvTG93ZXJDYXNlKCkpXG4gICAgICApXG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBub2RlLm5vZGVUeXBlID09PSAodm5vZGUuaXNDb21tZW50ID8gOCA6IDMpXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZ1bmN0aW9uIHBhdGNoIChvbGRWbm9kZSwgdm5vZGUsIGh5ZHJhdGluZywgcmVtb3ZlT25seSkge1xuICAgIGlmIChpc1VuZGVmKHZub2RlKSkge1xuICAgICAgaWYgKGlzRGVmKG9sZFZub2RlKSkgeyBpbnZva2VEZXN0cm95SG9vayhvbGRWbm9kZSk7IH1cbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIHZhciBpc0luaXRpYWxQYXRjaCA9IGZhbHNlO1xuICAgIHZhciBpbnNlcnRlZFZub2RlUXVldWUgPSBbXTtcblxuICAgIGlmIChpc1VuZGVmKG9sZFZub2RlKSkge1xuICAgICAgLy8gZW1wdHkgbW91bnQgKGxpa2VseSBhcyBjb21wb25lbnQpLCBjcmVhdGUgbmV3IHJvb3QgZWxlbWVudFxuICAgICAgaXNJbml0aWFsUGF0Y2ggPSB0cnVlO1xuICAgICAgY3JlYXRlRWxtKHZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgaXNSZWFsRWxlbWVudCA9IGlzRGVmKG9sZFZub2RlLm5vZGVUeXBlKTtcbiAgICAgIGlmICghaXNSZWFsRWxlbWVudCAmJiBzYW1lVm5vZGUob2xkVm5vZGUsIHZub2RlKSkge1xuICAgICAgICAvLyBwYXRjaCBleGlzdGluZyByb290IG5vZGVcbiAgICAgICAgcGF0Y2hWbm9kZShvbGRWbm9kZSwgdm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSwgbnVsbCwgbnVsbCwgcmVtb3ZlT25seSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoaXNSZWFsRWxlbWVudCkge1xuICAgICAgICAgIC8vIG1vdW50aW5nIHRvIGEgcmVhbCBlbGVtZW50XG4gICAgICAgICAgLy8gY2hlY2sgaWYgdGhpcyBpcyBzZXJ2ZXItcmVuZGVyZWQgY29udGVudCBhbmQgaWYgd2UgY2FuIHBlcmZvcm1cbiAgICAgICAgICAvLyBhIHN1Y2Nlc3NmdWwgaHlkcmF0aW9uLlxuICAgICAgICAgIGlmIChvbGRWbm9kZS5ub2RlVHlwZSA9PT0gMSAmJiBvbGRWbm9kZS5oYXNBdHRyaWJ1dGUoU1NSX0FUVFIpKSB7XG4gICAgICAgICAgICBvbGRWbm9kZS5yZW1vdmVBdHRyaWJ1dGUoU1NSX0FUVFIpO1xuICAgICAgICAgICAgaHlkcmF0aW5nID0gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGlzVHJ1ZShoeWRyYXRpbmcpKSB7XG4gICAgICAgICAgICBpZiAoaHlkcmF0ZShvbGRWbm9kZSwgdm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSkpIHtcbiAgICAgICAgICAgICAgaW52b2tlSW5zZXJ0SG9vayh2bm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlLCB0cnVlKTtcbiAgICAgICAgICAgICAgcmV0dXJuIG9sZFZub2RlXG4gICAgICAgICAgICB9IGVsc2UgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgICAgICAgd2FybihcbiAgICAgICAgICAgICAgICAnVGhlIGNsaWVudC1zaWRlIHJlbmRlcmVkIHZpcnR1YWwgRE9NIHRyZWUgaXMgbm90IG1hdGNoaW5nICcgK1xuICAgICAgICAgICAgICAgICdzZXJ2ZXItcmVuZGVyZWQgY29udGVudC4gVGhpcyBpcyBsaWtlbHkgY2F1c2VkIGJ5IGluY29ycmVjdCAnICtcbiAgICAgICAgICAgICAgICAnSFRNTCBtYXJrdXAsIGZvciBleGFtcGxlIG5lc3RpbmcgYmxvY2stbGV2ZWwgZWxlbWVudHMgaW5zaWRlICcgK1xuICAgICAgICAgICAgICAgICc8cD4sIG9yIG1pc3NpbmcgPHRib2R5Pi4gQmFpbGluZyBoeWRyYXRpb24gYW5kIHBlcmZvcm1pbmcgJyArXG4gICAgICAgICAgICAgICAgJ2Z1bGwgY2xpZW50LXNpZGUgcmVuZGVyLidcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgLy8gZWl0aGVyIG5vdCBzZXJ2ZXItcmVuZGVyZWQsIG9yIGh5ZHJhdGlvbiBmYWlsZWQuXG4gICAgICAgICAgLy8gY3JlYXRlIGFuIGVtcHR5IG5vZGUgYW5kIHJlcGxhY2UgaXRcbiAgICAgICAgICBvbGRWbm9kZSA9IGVtcHR5Tm9kZUF0KG9sZFZub2RlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHJlcGxhY2luZyBleGlzdGluZyBlbGVtZW50XG4gICAgICAgIHZhciBvbGRFbG0gPSBvbGRWbm9kZS5lbG07XG4gICAgICAgIHZhciBwYXJlbnRFbG0gPSBub2RlT3BzLnBhcmVudE5vZGUob2xkRWxtKTtcblxuICAgICAgICAvLyBjcmVhdGUgbmV3IG5vZGVcbiAgICAgICAgY3JlYXRlRWxtKFxuICAgICAgICAgIHZub2RlLFxuICAgICAgICAgIGluc2VydGVkVm5vZGVRdWV1ZSxcbiAgICAgICAgICAvLyBleHRyZW1lbHkgcmFyZSBlZGdlIGNhc2U6IGRvIG5vdCBpbnNlcnQgaWYgb2xkIGVsZW1lbnQgaXMgaW4gYVxuICAgICAgICAgIC8vIGxlYXZpbmcgdHJhbnNpdGlvbi4gT25seSBoYXBwZW5zIHdoZW4gY29tYmluaW5nIHRyYW5zaXRpb24gK1xuICAgICAgICAgIC8vIGtlZXAtYWxpdmUgKyBIT0NzLiAoIzQ1OTApXG4gICAgICAgICAgb2xkRWxtLl9sZWF2ZUNiID8gbnVsbCA6IHBhcmVudEVsbSxcbiAgICAgICAgICBub2RlT3BzLm5leHRTaWJsaW5nKG9sZEVsbSlcbiAgICAgICAgKTtcblxuICAgICAgICAvLyB1cGRhdGUgcGFyZW50IHBsYWNlaG9sZGVyIG5vZGUgZWxlbWVudCwgcmVjdXJzaXZlbHlcbiAgICAgICAgaWYgKGlzRGVmKHZub2RlLnBhcmVudCkpIHtcbiAgICAgICAgICB2YXIgYW5jZXN0b3IgPSB2bm9kZS5wYXJlbnQ7XG4gICAgICAgICAgdmFyIHBhdGNoYWJsZSA9IGlzUGF0Y2hhYmxlKHZub2RlKTtcbiAgICAgICAgICB3aGlsZSAoYW5jZXN0b3IpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2JzLmRlc3Ryb3kubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgICAgY2JzLmRlc3Ryb3lbaV0oYW5jZXN0b3IpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYW5jZXN0b3IuZWxtID0gdm5vZGUuZWxtO1xuICAgICAgICAgICAgaWYgKHBhdGNoYWJsZSkge1xuICAgICAgICAgICAgICBmb3IgKHZhciBpJDEgPSAwOyBpJDEgPCBjYnMuY3JlYXRlLmxlbmd0aDsgKytpJDEpIHtcbiAgICAgICAgICAgICAgICBjYnMuY3JlYXRlW2kkMV0oZW1wdHlOb2RlLCBhbmNlc3Rvcik7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgLy8gIzY1MTNcbiAgICAgICAgICAgICAgLy8gaW52b2tlIGluc2VydCBob29rcyB0aGF0IG1heSBoYXZlIGJlZW4gbWVyZ2VkIGJ5IGNyZWF0ZSBob29rcy5cbiAgICAgICAgICAgICAgLy8gZS5nLiBmb3IgZGlyZWN0aXZlcyB0aGF0IHVzZXMgdGhlIFwiaW5zZXJ0ZWRcIiBob29rLlxuICAgICAgICAgICAgICB2YXIgaW5zZXJ0ID0gYW5jZXN0b3IuZGF0YS5ob29rLmluc2VydDtcbiAgICAgICAgICAgICAgaWYgKGluc2VydC5tZXJnZWQpIHtcbiAgICAgICAgICAgICAgICAvLyBzdGFydCBhdCBpbmRleCAxIHRvIGF2b2lkIHJlLWludm9raW5nIGNvbXBvbmVudCBtb3VudGVkIGhvb2tcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpJDIgPSAxOyBpJDIgPCBpbnNlcnQuZm5zLmxlbmd0aDsgaSQyKyspIHtcbiAgICAgICAgICAgICAgICAgIGluc2VydC5mbnNbaSQyXSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgcmVnaXN0ZXJSZWYoYW5jZXN0b3IpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYW5jZXN0b3IgPSBhbmNlc3Rvci5wYXJlbnQ7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gZGVzdHJveSBvbGQgbm9kZVxuICAgICAgICBpZiAoaXNEZWYocGFyZW50RWxtKSkge1xuICAgICAgICAgIHJlbW92ZVZub2Rlcyhbb2xkVm5vZGVdLCAwLCAwKTtcbiAgICAgICAgfSBlbHNlIGlmIChpc0RlZihvbGRWbm9kZS50YWcpKSB7XG4gICAgICAgICAgaW52b2tlRGVzdHJveUhvb2sob2xkVm5vZGUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgaW52b2tlSW5zZXJ0SG9vayh2bm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlLCBpc0luaXRpYWxQYXRjaCk7XG4gICAgcmV0dXJuIHZub2RlLmVsbVxuICB9XG59XG5cbi8qICAqL1xuXG52YXIgZGlyZWN0aXZlcyA9IHtcbiAgY3JlYXRlOiB1cGRhdGVEaXJlY3RpdmVzLFxuICB1cGRhdGU6IHVwZGF0ZURpcmVjdGl2ZXMsXG4gIGRlc3Ryb3k6IGZ1bmN0aW9uIHVuYmluZERpcmVjdGl2ZXMgKHZub2RlKSB7XG4gICAgdXBkYXRlRGlyZWN0aXZlcyh2bm9kZSwgZW1wdHlOb2RlKTtcbiAgfVxufTtcblxuZnVuY3Rpb24gdXBkYXRlRGlyZWN0aXZlcyAob2xkVm5vZGUsIHZub2RlKSB7XG4gIGlmIChvbGRWbm9kZS5kYXRhLmRpcmVjdGl2ZXMgfHwgdm5vZGUuZGF0YS5kaXJlY3RpdmVzKSB7XG4gICAgX3VwZGF0ZShvbGRWbm9kZSwgdm5vZGUpO1xuICB9XG59XG5cbmZ1bmN0aW9uIF91cGRhdGUgKG9sZFZub2RlLCB2bm9kZSkge1xuICB2YXIgaXNDcmVhdGUgPSBvbGRWbm9kZSA9PT0gZW1wdHlOb2RlO1xuICB2YXIgaXNEZXN0cm95ID0gdm5vZGUgPT09IGVtcHR5Tm9kZTtcbiAgdmFyIG9sZERpcnMgPSBub3JtYWxpemVEaXJlY3RpdmVzJDEob2xkVm5vZGUuZGF0YS5kaXJlY3RpdmVzLCBvbGRWbm9kZS5jb250ZXh0KTtcbiAgdmFyIG5ld0RpcnMgPSBub3JtYWxpemVEaXJlY3RpdmVzJDEodm5vZGUuZGF0YS5kaXJlY3RpdmVzLCB2bm9kZS5jb250ZXh0KTtcblxuICB2YXIgZGlyc1dpdGhJbnNlcnQgPSBbXTtcbiAgdmFyIGRpcnNXaXRoUG9zdHBhdGNoID0gW107XG5cbiAgdmFyIGtleSwgb2xkRGlyLCBkaXI7XG4gIGZvciAoa2V5IGluIG5ld0RpcnMpIHtcbiAgICBvbGREaXIgPSBvbGREaXJzW2tleV07XG4gICAgZGlyID0gbmV3RGlyc1trZXldO1xuICAgIGlmICghb2xkRGlyKSB7XG4gICAgICAvLyBuZXcgZGlyZWN0aXZlLCBiaW5kXG4gICAgICBjYWxsSG9vayQxKGRpciwgJ2JpbmQnLCB2bm9kZSwgb2xkVm5vZGUpO1xuICAgICAgaWYgKGRpci5kZWYgJiYgZGlyLmRlZi5pbnNlcnRlZCkge1xuICAgICAgICBkaXJzV2l0aEluc2VydC5wdXNoKGRpcik7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGV4aXN0aW5nIGRpcmVjdGl2ZSwgdXBkYXRlXG4gICAgICBkaXIub2xkVmFsdWUgPSBvbGREaXIudmFsdWU7XG4gICAgICBkaXIub2xkQXJnID0gb2xkRGlyLmFyZztcbiAgICAgIGNhbGxIb29rJDEoZGlyLCAndXBkYXRlJywgdm5vZGUsIG9sZFZub2RlKTtcbiAgICAgIGlmIChkaXIuZGVmICYmIGRpci5kZWYuY29tcG9uZW50VXBkYXRlZCkge1xuICAgICAgICBkaXJzV2l0aFBvc3RwYXRjaC5wdXNoKGRpcik7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgaWYgKGRpcnNXaXRoSW5zZXJ0Lmxlbmd0aCkge1xuICAgIHZhciBjYWxsSW5zZXJ0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBkaXJzV2l0aEluc2VydC5sZW5ndGg7IGkrKykge1xuICAgICAgICBjYWxsSG9vayQxKGRpcnNXaXRoSW5zZXJ0W2ldLCAnaW5zZXJ0ZWQnLCB2bm9kZSwgb2xkVm5vZGUpO1xuICAgICAgfVxuICAgIH07XG4gICAgaWYgKGlzQ3JlYXRlKSB7XG4gICAgICBtZXJnZVZOb2RlSG9vayh2bm9kZSwgJ2luc2VydCcsIGNhbGxJbnNlcnQpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjYWxsSW5zZXJ0KCk7XG4gICAgfVxuICB9XG5cbiAgaWYgKGRpcnNXaXRoUG9zdHBhdGNoLmxlbmd0aCkge1xuICAgIG1lcmdlVk5vZGVIb29rKHZub2RlLCAncG9zdHBhdGNoJywgZnVuY3Rpb24gKCkge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBkaXJzV2l0aFBvc3RwYXRjaC5sZW5ndGg7IGkrKykge1xuICAgICAgICBjYWxsSG9vayQxKGRpcnNXaXRoUG9zdHBhdGNoW2ldLCAnY29tcG9uZW50VXBkYXRlZCcsIHZub2RlLCBvbGRWbm9kZSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICBpZiAoIWlzQ3JlYXRlKSB7XG4gICAgZm9yIChrZXkgaW4gb2xkRGlycykge1xuICAgICAgaWYgKCFuZXdEaXJzW2tleV0pIHtcbiAgICAgICAgLy8gbm8gbG9uZ2VyIHByZXNlbnQsIHVuYmluZFxuICAgICAgICBjYWxsSG9vayQxKG9sZERpcnNba2V5XSwgJ3VuYmluZCcsIG9sZFZub2RlLCBvbGRWbm9kZSwgaXNEZXN0cm95KTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxudmFyIGVtcHR5TW9kaWZpZXJzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcblxuZnVuY3Rpb24gbm9ybWFsaXplRGlyZWN0aXZlcyQxIChcbiAgZGlycyxcbiAgdm1cbikge1xuICB2YXIgcmVzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgaWYgKCFkaXJzKSB7XG4gICAgLy8gJGZsb3ctZGlzYWJsZS1saW5lXG4gICAgcmV0dXJuIHJlc1xuICB9XG4gIHZhciBpLCBkaXI7XG4gIGZvciAoaSA9IDA7IGkgPCBkaXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgZGlyID0gZGlyc1tpXTtcbiAgICBpZiAoIWRpci5tb2RpZmllcnMpIHtcbiAgICAgIC8vICRmbG93LWRpc2FibGUtbGluZVxuICAgICAgZGlyLm1vZGlmaWVycyA9IGVtcHR5TW9kaWZpZXJzO1xuICAgIH1cbiAgICByZXNbZ2V0UmF3RGlyTmFtZShkaXIpXSA9IGRpcjtcbiAgICBkaXIuZGVmID0gcmVzb2x2ZUFzc2V0KHZtLiRvcHRpb25zLCAnZGlyZWN0aXZlcycsIGRpci5uYW1lLCB0cnVlKTtcbiAgfVxuICAvLyAkZmxvdy1kaXNhYmxlLWxpbmVcbiAgcmV0dXJuIHJlc1xufVxuXG5mdW5jdGlvbiBnZXRSYXdEaXJOYW1lIChkaXIpIHtcbiAgcmV0dXJuIGRpci5yYXdOYW1lIHx8ICgoZGlyLm5hbWUpICsgXCIuXCIgKyAoT2JqZWN0LmtleXMoZGlyLm1vZGlmaWVycyB8fCB7fSkuam9pbignLicpKSlcbn1cblxuZnVuY3Rpb24gY2FsbEhvb2skMSAoZGlyLCBob29rLCB2bm9kZSwgb2xkVm5vZGUsIGlzRGVzdHJveSkge1xuICB2YXIgZm4gPSBkaXIuZGVmICYmIGRpci5kZWZbaG9va107XG4gIGlmIChmbikge1xuICAgIHRyeSB7XG4gICAgICBmbih2bm9kZS5lbG0sIGRpciwgdm5vZGUsIG9sZFZub2RlLCBpc0Rlc3Ryb3kpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGhhbmRsZUVycm9yKGUsIHZub2RlLmNvbnRleHQsIChcImRpcmVjdGl2ZSBcIiArIChkaXIubmFtZSkgKyBcIiBcIiArIGhvb2sgKyBcIiBob29rXCIpKTtcbiAgICB9XG4gIH1cbn1cblxudmFyIGJhc2VNb2R1bGVzID0gW1xuICByZWYsXG4gIGRpcmVjdGl2ZXNcbl07XG5cbi8qICAqL1xuXG5mdW5jdGlvbiB1cGRhdGVBdHRycyAob2xkVm5vZGUsIHZub2RlKSB7XG4gIHZhciBvcHRzID0gdm5vZGUuY29tcG9uZW50T3B0aW9ucztcbiAgaWYgKGlzRGVmKG9wdHMpICYmIG9wdHMuQ3Rvci5vcHRpb25zLmluaGVyaXRBdHRycyA9PT0gZmFsc2UpIHtcbiAgICByZXR1cm5cbiAgfVxuICBpZiAoaXNVbmRlZihvbGRWbm9kZS5kYXRhLmF0dHJzKSAmJiBpc1VuZGVmKHZub2RlLmRhdGEuYXR0cnMpKSB7XG4gICAgcmV0dXJuXG4gIH1cbiAgdmFyIGtleSwgY3VyLCBvbGQ7XG4gIHZhciBlbG0gPSB2bm9kZS5lbG07XG4gIHZhciBvbGRBdHRycyA9IG9sZFZub2RlLmRhdGEuYXR0cnMgfHwge307XG4gIHZhciBhdHRycyA9IHZub2RlLmRhdGEuYXR0cnMgfHwge307XG4gIC8vIGNsb25lIG9ic2VydmVkIG9iamVjdHMsIGFzIHRoZSB1c2VyIHByb2JhYmx5IHdhbnRzIHRvIG11dGF0ZSBpdFxuICBpZiAoaXNEZWYoYXR0cnMuX19vYl9fKSkge1xuICAgIGF0dHJzID0gdm5vZGUuZGF0YS5hdHRycyA9IGV4dGVuZCh7fSwgYXR0cnMpO1xuICB9XG5cbiAgZm9yIChrZXkgaW4gYXR0cnMpIHtcbiAgICBjdXIgPSBhdHRyc1trZXldO1xuICAgIG9sZCA9IG9sZEF0dHJzW2tleV07XG4gICAgaWYgKG9sZCAhPT0gY3VyKSB7XG4gICAgICBzZXRBdHRyKGVsbSwga2V5LCBjdXIsIHZub2RlLmRhdGEucHJlKTtcbiAgICB9XG4gIH1cbiAgLy8gIzQzOTE6IGluIElFOSwgc2V0dGluZyB0eXBlIGNhbiByZXNldCB2YWx1ZSBmb3IgaW5wdXRbdHlwZT1yYWRpb11cbiAgLy8gIzY2NjY6IElFL0VkZ2UgZm9yY2VzIHByb2dyZXNzIHZhbHVlIGRvd24gdG8gMSBiZWZvcmUgc2V0dGluZyBhIG1heFxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgaWYgKChpc0lFIHx8IGlzRWRnZSkgJiYgYXR0cnMudmFsdWUgIT09IG9sZEF0dHJzLnZhbHVlKSB7XG4gICAgc2V0QXR0cihlbG0sICd2YWx1ZScsIGF0dHJzLnZhbHVlKTtcbiAgfVxuICBmb3IgKGtleSBpbiBvbGRBdHRycykge1xuICAgIGlmIChpc1VuZGVmKGF0dHJzW2tleV0pKSB7XG4gICAgICBpZiAoaXNYbGluayhrZXkpKSB7XG4gICAgICAgIGVsbS5yZW1vdmVBdHRyaWJ1dGVOUyh4bGlua05TLCBnZXRYbGlua1Byb3Aoa2V5KSk7XG4gICAgICB9IGVsc2UgaWYgKCFpc0VudW1lcmF0ZWRBdHRyKGtleSkpIHtcbiAgICAgICAgZWxtLnJlbW92ZUF0dHJpYnV0ZShrZXkpO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBzZXRBdHRyIChlbCwga2V5LCB2YWx1ZSwgaXNJblByZSkge1xuICBpZiAoaXNJblByZSB8fCBlbC50YWdOYW1lLmluZGV4T2YoJy0nKSA+IC0xKSB7XG4gICAgYmFzZVNldEF0dHIoZWwsIGtleSwgdmFsdWUpO1xuICB9IGVsc2UgaWYgKGlzQm9vbGVhbkF0dHIoa2V5KSkge1xuICAgIC8vIHNldCBhdHRyaWJ1dGUgZm9yIGJsYW5rIHZhbHVlXG4gICAgLy8gZS5nLiA8b3B0aW9uIGRpc2FibGVkPlNlbGVjdCBvbmU8L29wdGlvbj5cbiAgICBpZiAoaXNGYWxzeUF0dHJWYWx1ZSh2YWx1ZSkpIHtcbiAgICAgIGVsLnJlbW92ZUF0dHJpYnV0ZShrZXkpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyB0ZWNobmljYWxseSBhbGxvd2Z1bGxzY3JlZW4gaXMgYSBib29sZWFuIGF0dHJpYnV0ZSBmb3IgPGlmcmFtZT4sXG4gICAgICAvLyBidXQgRmxhc2ggZXhwZWN0cyBhIHZhbHVlIG9mIFwidHJ1ZVwiIHdoZW4gdXNlZCBvbiA8ZW1iZWQ+IHRhZ1xuICAgICAgdmFsdWUgPSBrZXkgPT09ICdhbGxvd2Z1bGxzY3JlZW4nICYmIGVsLnRhZ05hbWUgPT09ICdFTUJFRCdcbiAgICAgICAgPyAndHJ1ZSdcbiAgICAgICAgOiBrZXk7XG4gICAgICBlbC5zZXRBdHRyaWJ1dGUoa2V5LCB2YWx1ZSk7XG4gICAgfVxuICB9IGVsc2UgaWYgKGlzRW51bWVyYXRlZEF0dHIoa2V5KSkge1xuICAgIGVsLnNldEF0dHJpYnV0ZShrZXksIGNvbnZlcnRFbnVtZXJhdGVkVmFsdWUoa2V5LCB2YWx1ZSkpO1xuICB9IGVsc2UgaWYgKGlzWGxpbmsoa2V5KSkge1xuICAgIGlmIChpc0ZhbHN5QXR0clZhbHVlKHZhbHVlKSkge1xuICAgICAgZWwucmVtb3ZlQXR0cmlidXRlTlMoeGxpbmtOUywgZ2V0WGxpbmtQcm9wKGtleSkpO1xuICAgIH0gZWxzZSB7XG4gICAgICBlbC5zZXRBdHRyaWJ1dGVOUyh4bGlua05TLCBrZXksIHZhbHVlKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgYmFzZVNldEF0dHIoZWwsIGtleSwgdmFsdWUpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGJhc2VTZXRBdHRyIChlbCwga2V5LCB2YWx1ZSkge1xuICBpZiAoaXNGYWxzeUF0dHJWYWx1ZSh2YWx1ZSkpIHtcbiAgICBlbC5yZW1vdmVBdHRyaWJ1dGUoa2V5KTtcbiAgfSBlbHNlIHtcbiAgICAvLyAjNzEzODogSUUxMCAmIDExIGZpcmVzIGlucHV0IGV2ZW50IHdoZW4gc2V0dGluZyBwbGFjZWhvbGRlciBvblxuICAgIC8vIDx0ZXh0YXJlYT4uLi4gYmxvY2sgdGhlIGZpcnN0IGlucHV0IGV2ZW50IGFuZCByZW1vdmUgdGhlIGJsb2NrZXJcbiAgICAvLyBpbW1lZGlhdGVseS5cbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICBpZiAoXG4gICAgICBpc0lFICYmICFpc0lFOSAmJlxuICAgICAgZWwudGFnTmFtZSA9PT0gJ1RFWFRBUkVBJyAmJlxuICAgICAga2V5ID09PSAncGxhY2Vob2xkZXInICYmIHZhbHVlICE9PSAnJyAmJiAhZWwuX19pZXBoXG4gICAgKSB7XG4gICAgICB2YXIgYmxvY2tlciA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIGUuc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uKCk7XG4gICAgICAgIGVsLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2lucHV0JywgYmxvY2tlcik7XG4gICAgICB9O1xuICAgICAgZWwuYWRkRXZlbnRMaXN0ZW5lcignaW5wdXQnLCBibG9ja2VyKTtcbiAgICAgIC8vICRmbG93LWRpc2FibGUtbGluZVxuICAgICAgZWwuX19pZXBoID0gdHJ1ZTsgLyogSUUgcGxhY2Vob2xkZXIgcGF0Y2hlZCAqL1xuICAgIH1cbiAgICBlbC5zZXRBdHRyaWJ1dGUoa2V5LCB2YWx1ZSk7XG4gIH1cbn1cblxudmFyIGF0dHJzID0ge1xuICBjcmVhdGU6IHVwZGF0ZUF0dHJzLFxuICB1cGRhdGU6IHVwZGF0ZUF0dHJzXG59O1xuXG4vKiAgKi9cblxuZnVuY3Rpb24gdXBkYXRlQ2xhc3MgKG9sZFZub2RlLCB2bm9kZSkge1xuICB2YXIgZWwgPSB2bm9kZS5lbG07XG4gIHZhciBkYXRhID0gdm5vZGUuZGF0YTtcbiAgdmFyIG9sZERhdGEgPSBvbGRWbm9kZS5kYXRhO1xuICBpZiAoXG4gICAgaXNVbmRlZihkYXRhLnN0YXRpY0NsYXNzKSAmJlxuICAgIGlzVW5kZWYoZGF0YS5jbGFzcykgJiYgKFxuICAgICAgaXNVbmRlZihvbGREYXRhKSB8fCAoXG4gICAgICAgIGlzVW5kZWYob2xkRGF0YS5zdGF0aWNDbGFzcykgJiZcbiAgICAgICAgaXNVbmRlZihvbGREYXRhLmNsYXNzKVxuICAgICAgKVxuICAgIClcbiAgKSB7XG4gICAgcmV0dXJuXG4gIH1cblxuICB2YXIgY2xzID0gZ2VuQ2xhc3NGb3JWbm9kZSh2bm9kZSk7XG5cbiAgLy8gaGFuZGxlIHRyYW5zaXRpb24gY2xhc3Nlc1xuICB2YXIgdHJhbnNpdGlvbkNsYXNzID0gZWwuX3RyYW5zaXRpb25DbGFzc2VzO1xuICBpZiAoaXNEZWYodHJhbnNpdGlvbkNsYXNzKSkge1xuICAgIGNscyA9IGNvbmNhdChjbHMsIHN0cmluZ2lmeUNsYXNzKHRyYW5zaXRpb25DbGFzcykpO1xuICB9XG5cbiAgLy8gc2V0IHRoZSBjbGFzc1xuICBpZiAoY2xzICE9PSBlbC5fcHJldkNsYXNzKSB7XG4gICAgZWwuc2V0QXR0cmlidXRlKCdjbGFzcycsIGNscyk7XG4gICAgZWwuX3ByZXZDbGFzcyA9IGNscztcbiAgfVxufVxuXG52YXIga2xhc3MgPSB7XG4gIGNyZWF0ZTogdXBkYXRlQ2xhc3MsXG4gIHVwZGF0ZTogdXBkYXRlQ2xhc3Ncbn07XG5cbi8qICAqL1xuXG52YXIgdmFsaWREaXZpc2lvbkNoYXJSRSA9IC9bXFx3KS4rXFwtXyRcXF1dLztcblxuZnVuY3Rpb24gcGFyc2VGaWx0ZXJzIChleHApIHtcbiAgdmFyIGluU2luZ2xlID0gZmFsc2U7XG4gIHZhciBpbkRvdWJsZSA9IGZhbHNlO1xuICB2YXIgaW5UZW1wbGF0ZVN0cmluZyA9IGZhbHNlO1xuICB2YXIgaW5SZWdleCA9IGZhbHNlO1xuICB2YXIgY3VybHkgPSAwO1xuICB2YXIgc3F1YXJlID0gMDtcbiAgdmFyIHBhcmVuID0gMDtcbiAgdmFyIGxhc3RGaWx0ZXJJbmRleCA9IDA7XG4gIHZhciBjLCBwcmV2LCBpLCBleHByZXNzaW9uLCBmaWx0ZXJzO1xuXG4gIGZvciAoaSA9IDA7IGkgPCBleHAubGVuZ3RoOyBpKyspIHtcbiAgICBwcmV2ID0gYztcbiAgICBjID0gZXhwLmNoYXJDb2RlQXQoaSk7XG4gICAgaWYgKGluU2luZ2xlKSB7XG4gICAgICBpZiAoYyA9PT0gMHgyNyAmJiBwcmV2ICE9PSAweDVDKSB7IGluU2luZ2xlID0gZmFsc2U7IH1cbiAgICB9IGVsc2UgaWYgKGluRG91YmxlKSB7XG4gICAgICBpZiAoYyA9PT0gMHgyMiAmJiBwcmV2ICE9PSAweDVDKSB7IGluRG91YmxlID0gZmFsc2U7IH1cbiAgICB9IGVsc2UgaWYgKGluVGVtcGxhdGVTdHJpbmcpIHtcbiAgICAgIGlmIChjID09PSAweDYwICYmIHByZXYgIT09IDB4NUMpIHsgaW5UZW1wbGF0ZVN0cmluZyA9IGZhbHNlOyB9XG4gICAgfSBlbHNlIGlmIChpblJlZ2V4KSB7XG4gICAgICBpZiAoYyA9PT0gMHgyZiAmJiBwcmV2ICE9PSAweDVDKSB7IGluUmVnZXggPSBmYWxzZTsgfVxuICAgIH0gZWxzZSBpZiAoXG4gICAgICBjID09PSAweDdDICYmIC8vIHBpcGVcbiAgICAgIGV4cC5jaGFyQ29kZUF0KGkgKyAxKSAhPT0gMHg3QyAmJlxuICAgICAgZXhwLmNoYXJDb2RlQXQoaSAtIDEpICE9PSAweDdDICYmXG4gICAgICAhY3VybHkgJiYgIXNxdWFyZSAmJiAhcGFyZW5cbiAgICApIHtcbiAgICAgIGlmIChleHByZXNzaW9uID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgLy8gZmlyc3QgZmlsdGVyLCBlbmQgb2YgZXhwcmVzc2lvblxuICAgICAgICBsYXN0RmlsdGVySW5kZXggPSBpICsgMTtcbiAgICAgICAgZXhwcmVzc2lvbiA9IGV4cC5zbGljZSgwLCBpKS50cmltKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwdXNoRmlsdGVyKCk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHN3aXRjaCAoYykge1xuICAgICAgICBjYXNlIDB4MjI6IGluRG91YmxlID0gdHJ1ZTsgYnJlYWsgICAgICAgICAvLyBcIlxuICAgICAgICBjYXNlIDB4Mjc6IGluU2luZ2xlID0gdHJ1ZTsgYnJlYWsgICAgICAgICAvLyAnXG4gICAgICAgIGNhc2UgMHg2MDogaW5UZW1wbGF0ZVN0cmluZyA9IHRydWU7IGJyZWFrIC8vIGBcbiAgICAgICAgY2FzZSAweDI4OiBwYXJlbisrOyBicmVhayAgICAgICAgICAgICAgICAgLy8gKFxuICAgICAgICBjYXNlIDB4Mjk6IHBhcmVuLS07IGJyZWFrICAgICAgICAgICAgICAgICAvLyApXG4gICAgICAgIGNhc2UgMHg1Qjogc3F1YXJlKys7IGJyZWFrICAgICAgICAgICAgICAgIC8vIFtcbiAgICAgICAgY2FzZSAweDVEOiBzcXVhcmUtLTsgYnJlYWsgICAgICAgICAgICAgICAgLy8gXVxuICAgICAgICBjYXNlIDB4N0I6IGN1cmx5Kys7IGJyZWFrICAgICAgICAgICAgICAgICAvLyB7XG4gICAgICAgIGNhc2UgMHg3RDogY3VybHktLTsgYnJlYWsgICAgICAgICAgICAgICAgIC8vIH1cbiAgICAgIH1cbiAgICAgIGlmIChjID09PSAweDJmKSB7IC8vIC9cbiAgICAgICAgdmFyIGogPSBpIC0gMTtcbiAgICAgICAgdmFyIHAgPSAodm9pZCAwKTtcbiAgICAgICAgLy8gZmluZCBmaXJzdCBub24td2hpdGVzcGFjZSBwcmV2IGNoYXJcbiAgICAgICAgZm9yICg7IGogPj0gMDsgai0tKSB7XG4gICAgICAgICAgcCA9IGV4cC5jaGFyQXQoaik7XG4gICAgICAgICAgaWYgKHAgIT09ICcgJykgeyBicmVhayB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFwIHx8ICF2YWxpZERpdmlzaW9uQ2hhclJFLnRlc3QocCkpIHtcbiAgICAgICAgICBpblJlZ2V4ID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGlmIChleHByZXNzaW9uID09PSB1bmRlZmluZWQpIHtcbiAgICBleHByZXNzaW9uID0gZXhwLnNsaWNlKDAsIGkpLnRyaW0oKTtcbiAgfSBlbHNlIGlmIChsYXN0RmlsdGVySW5kZXggIT09IDApIHtcbiAgICBwdXNoRmlsdGVyKCk7XG4gIH1cblxuICBmdW5jdGlvbiBwdXNoRmlsdGVyICgpIHtcbiAgICAoZmlsdGVycyB8fCAoZmlsdGVycyA9IFtdKSkucHVzaChleHAuc2xpY2UobGFzdEZpbHRlckluZGV4LCBpKS50cmltKCkpO1xuICAgIGxhc3RGaWx0ZXJJbmRleCA9IGkgKyAxO1xuICB9XG5cbiAgaWYgKGZpbHRlcnMpIHtcbiAgICBmb3IgKGkgPSAwOyBpIDwgZmlsdGVycy5sZW5ndGg7IGkrKykge1xuICAgICAgZXhwcmVzc2lvbiA9IHdyYXBGaWx0ZXIoZXhwcmVzc2lvbiwgZmlsdGVyc1tpXSk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGV4cHJlc3Npb25cbn1cblxuZnVuY3Rpb24gd3JhcEZpbHRlciAoZXhwLCBmaWx0ZXIpIHtcbiAgdmFyIGkgPSBmaWx0ZXIuaW5kZXhPZignKCcpO1xuICBpZiAoaSA8IDApIHtcbiAgICAvLyBfZjogcmVzb2x2ZUZpbHRlclxuICAgIHJldHVybiAoXCJfZihcXFwiXCIgKyBmaWx0ZXIgKyBcIlxcXCIpKFwiICsgZXhwICsgXCIpXCIpXG4gIH0gZWxzZSB7XG4gICAgdmFyIG5hbWUgPSBmaWx0ZXIuc2xpY2UoMCwgaSk7XG4gICAgdmFyIGFyZ3MgPSBmaWx0ZXIuc2xpY2UoaSArIDEpO1xuICAgIHJldHVybiAoXCJfZihcXFwiXCIgKyBuYW1lICsgXCJcXFwiKShcIiArIGV4cCArIChhcmdzICE9PSAnKScgPyAnLCcgKyBhcmdzIDogYXJncykpXG4gIH1cbn1cblxuLyogICovXG5cblxuXG4vKiBlc2xpbnQtZGlzYWJsZSBuby11bnVzZWQtdmFycyAqL1xuZnVuY3Rpb24gYmFzZVdhcm4gKG1zZywgcmFuZ2UpIHtcbiAgY29uc29sZS5lcnJvcigoXCJbVnVlIGNvbXBpbGVyXTogXCIgKyBtc2cpKTtcbn1cbi8qIGVzbGludC1lbmFibGUgbm8tdW51c2VkLXZhcnMgKi9cblxuZnVuY3Rpb24gcGx1Y2tNb2R1bGVGdW5jdGlvbiAoXG4gIG1vZHVsZXMsXG4gIGtleVxuKSB7XG4gIHJldHVybiBtb2R1bGVzXG4gICAgPyBtb2R1bGVzLm1hcChmdW5jdGlvbiAobSkgeyByZXR1cm4gbVtrZXldOyB9KS5maWx0ZXIoZnVuY3Rpb24gKF8pIHsgcmV0dXJuIF87IH0pXG4gICAgOiBbXVxufVxuXG5mdW5jdGlvbiBhZGRQcm9wIChlbCwgbmFtZSwgdmFsdWUsIHJhbmdlLCBkeW5hbWljKSB7XG4gIChlbC5wcm9wcyB8fCAoZWwucHJvcHMgPSBbXSkpLnB1c2gocmFuZ2VTZXRJdGVtKHsgbmFtZTogbmFtZSwgdmFsdWU6IHZhbHVlLCBkeW5hbWljOiBkeW5hbWljIH0sIHJhbmdlKSk7XG4gIGVsLnBsYWluID0gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIGFkZEF0dHIgKGVsLCBuYW1lLCB2YWx1ZSwgcmFuZ2UsIGR5bmFtaWMpIHtcbiAgdmFyIGF0dHJzID0gZHluYW1pY1xuICAgID8gKGVsLmR5bmFtaWNBdHRycyB8fCAoZWwuZHluYW1pY0F0dHJzID0gW10pKVxuICAgIDogKGVsLmF0dHJzIHx8IChlbC5hdHRycyA9IFtdKSk7XG4gIGF0dHJzLnB1c2gocmFuZ2VTZXRJdGVtKHsgbmFtZTogbmFtZSwgdmFsdWU6IHZhbHVlLCBkeW5hbWljOiBkeW5hbWljIH0sIHJhbmdlKSk7XG4gIGVsLnBsYWluID0gZmFsc2U7XG59XG5cbi8vIGFkZCBhIHJhdyBhdHRyICh1c2UgdGhpcyBpbiBwcmVUcmFuc2Zvcm1zKVxuZnVuY3Rpb24gYWRkUmF3QXR0ciAoZWwsIG5hbWUsIHZhbHVlLCByYW5nZSkge1xuICBlbC5hdHRyc01hcFtuYW1lXSA9IHZhbHVlO1xuICBlbC5hdHRyc0xpc3QucHVzaChyYW5nZVNldEl0ZW0oeyBuYW1lOiBuYW1lLCB2YWx1ZTogdmFsdWUgfSwgcmFuZ2UpKTtcbn1cblxuZnVuY3Rpb24gYWRkRGlyZWN0aXZlIChcbiAgZWwsXG4gIG5hbWUsXG4gIHJhd05hbWUsXG4gIHZhbHVlLFxuICBhcmcsXG4gIGlzRHluYW1pY0FyZyxcbiAgbW9kaWZpZXJzLFxuICByYW5nZVxuKSB7XG4gIChlbC5kaXJlY3RpdmVzIHx8IChlbC5kaXJlY3RpdmVzID0gW10pKS5wdXNoKHJhbmdlU2V0SXRlbSh7XG4gICAgbmFtZTogbmFtZSxcbiAgICByYXdOYW1lOiByYXdOYW1lLFxuICAgIHZhbHVlOiB2YWx1ZSxcbiAgICBhcmc6IGFyZyxcbiAgICBpc0R5bmFtaWNBcmc6IGlzRHluYW1pY0FyZyxcbiAgICBtb2RpZmllcnM6IG1vZGlmaWVyc1xuICB9LCByYW5nZSkpO1xuICBlbC5wbGFpbiA9IGZhbHNlO1xufVxuXG5mdW5jdGlvbiBwcmVwZW5kTW9kaWZpZXJNYXJrZXIgKHN5bWJvbCwgbmFtZSwgZHluYW1pYykge1xuICByZXR1cm4gZHluYW1pY1xuICAgID8gKFwiX3AoXCIgKyBuYW1lICsgXCIsXFxcIlwiICsgc3ltYm9sICsgXCJcXFwiKVwiKVxuICAgIDogc3ltYm9sICsgbmFtZSAvLyBtYXJrIHRoZSBldmVudCBhcyBjYXB0dXJlZFxufVxuXG5mdW5jdGlvbiBhZGRIYW5kbGVyIChcbiAgZWwsXG4gIG5hbWUsXG4gIHZhbHVlLFxuICBtb2RpZmllcnMsXG4gIGltcG9ydGFudCxcbiAgd2FybixcbiAgcmFuZ2UsXG4gIGR5bmFtaWNcbikge1xuICBtb2RpZmllcnMgPSBtb2RpZmllcnMgfHwgZW1wdHlPYmplY3Q7XG4gIC8vIHdhcm4gcHJldmVudCBhbmQgcGFzc2l2ZSBtb2RpZmllclxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgaWYgKFxuICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgd2FybiAmJlxuICAgIG1vZGlmaWVycy5wcmV2ZW50ICYmIG1vZGlmaWVycy5wYXNzaXZlXG4gICkge1xuICAgIHdhcm4oXG4gICAgICAncGFzc2l2ZSBhbmQgcHJldmVudCBjYW5cXCd0IGJlIHVzZWQgdG9nZXRoZXIuICcgK1xuICAgICAgJ1Bhc3NpdmUgaGFuZGxlciBjYW5cXCd0IHByZXZlbnQgZGVmYXVsdCBldmVudC4nLFxuICAgICAgcmFuZ2VcbiAgICApO1xuICB9XG5cbiAgLy8gbm9ybWFsaXplIGNsaWNrLnJpZ2h0IGFuZCBjbGljay5taWRkbGUgc2luY2UgdGhleSBkb24ndCBhY3R1YWxseSBmaXJlXG4gIC8vIHRoaXMgaXMgdGVjaG5pY2FsbHkgYnJvd3Nlci1zcGVjaWZpYywgYnV0IGF0IGxlYXN0IGZvciBub3cgYnJvd3NlcnMgYXJlXG4gIC8vIHRoZSBvbmx5IHRhcmdldCBlbnZzIHRoYXQgaGF2ZSByaWdodC9taWRkbGUgY2xpY2tzLlxuICBpZiAobW9kaWZpZXJzLnJpZ2h0KSB7XG4gICAgaWYgKGR5bmFtaWMpIHtcbiAgICAgIG5hbWUgPSBcIihcIiArIG5hbWUgKyBcIik9PT0nY2xpY2snPydjb250ZXh0bWVudSc6KFwiICsgbmFtZSArIFwiKVwiO1xuICAgIH0gZWxzZSBpZiAobmFtZSA9PT0gJ2NsaWNrJykge1xuICAgICAgbmFtZSA9ICdjb250ZXh0bWVudSc7XG4gICAgICBkZWxldGUgbW9kaWZpZXJzLnJpZ2h0O1xuICAgIH1cbiAgfSBlbHNlIGlmIChtb2RpZmllcnMubWlkZGxlKSB7XG4gICAgaWYgKGR5bmFtaWMpIHtcbiAgICAgIG5hbWUgPSBcIihcIiArIG5hbWUgKyBcIik9PT0nY2xpY2snPydtb3VzZXVwJzooXCIgKyBuYW1lICsgXCIpXCI7XG4gICAgfSBlbHNlIGlmIChuYW1lID09PSAnY2xpY2snKSB7XG4gICAgICBuYW1lID0gJ21vdXNldXAnO1xuICAgIH1cbiAgfVxuXG4gIC8vIGNoZWNrIGNhcHR1cmUgbW9kaWZpZXJcbiAgaWYgKG1vZGlmaWVycy5jYXB0dXJlKSB7XG4gICAgZGVsZXRlIG1vZGlmaWVycy5jYXB0dXJlO1xuICAgIG5hbWUgPSBwcmVwZW5kTW9kaWZpZXJNYXJrZXIoJyEnLCBuYW1lLCBkeW5hbWljKTtcbiAgfVxuICBpZiAobW9kaWZpZXJzLm9uY2UpIHtcbiAgICBkZWxldGUgbW9kaWZpZXJzLm9uY2U7XG4gICAgbmFtZSA9IHByZXBlbmRNb2RpZmllck1hcmtlcignficsIG5hbWUsIGR5bmFtaWMpO1xuICB9XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICBpZiAobW9kaWZpZXJzLnBhc3NpdmUpIHtcbiAgICBkZWxldGUgbW9kaWZpZXJzLnBhc3NpdmU7XG4gICAgbmFtZSA9IHByZXBlbmRNb2RpZmllck1hcmtlcignJicsIG5hbWUsIGR5bmFtaWMpO1xuICB9XG5cbiAgdmFyIGV2ZW50cztcbiAgaWYgKG1vZGlmaWVycy5uYXRpdmUpIHtcbiAgICBkZWxldGUgbW9kaWZpZXJzLm5hdGl2ZTtcbiAgICBldmVudHMgPSBlbC5uYXRpdmVFdmVudHMgfHwgKGVsLm5hdGl2ZUV2ZW50cyA9IHt9KTtcbiAgfSBlbHNlIHtcbiAgICBldmVudHMgPSBlbC5ldmVudHMgfHwgKGVsLmV2ZW50cyA9IHt9KTtcbiAgfVxuXG4gIHZhciBuZXdIYW5kbGVyID0gcmFuZ2VTZXRJdGVtKHsgdmFsdWU6IHZhbHVlLnRyaW0oKSwgZHluYW1pYzogZHluYW1pYyB9LCByYW5nZSk7XG4gIGlmIChtb2RpZmllcnMgIT09IGVtcHR5T2JqZWN0KSB7XG4gICAgbmV3SGFuZGxlci5tb2RpZmllcnMgPSBtb2RpZmllcnM7XG4gIH1cblxuICB2YXIgaGFuZGxlcnMgPSBldmVudHNbbmFtZV07XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICBpZiAoQXJyYXkuaXNBcnJheShoYW5kbGVycykpIHtcbiAgICBpbXBvcnRhbnQgPyBoYW5kbGVycy51bnNoaWZ0KG5ld0hhbmRsZXIpIDogaGFuZGxlcnMucHVzaChuZXdIYW5kbGVyKTtcbiAgfSBlbHNlIGlmIChoYW5kbGVycykge1xuICAgIGV2ZW50c1tuYW1lXSA9IGltcG9ydGFudCA/IFtuZXdIYW5kbGVyLCBoYW5kbGVyc10gOiBbaGFuZGxlcnMsIG5ld0hhbmRsZXJdO1xuICB9IGVsc2Uge1xuICAgIGV2ZW50c1tuYW1lXSA9IG5ld0hhbmRsZXI7XG4gIH1cblxuICBlbC5wbGFpbiA9IGZhbHNlO1xufVxuXG5mdW5jdGlvbiBnZXRSYXdCaW5kaW5nQXR0ciAoXG4gIGVsLFxuICBuYW1lXG4pIHtcbiAgcmV0dXJuIGVsLnJhd0F0dHJzTWFwWyc6JyArIG5hbWVdIHx8XG4gICAgZWwucmF3QXR0cnNNYXBbJ3YtYmluZDonICsgbmFtZV0gfHxcbiAgICBlbC5yYXdBdHRyc01hcFtuYW1lXVxufVxuXG5mdW5jdGlvbiBnZXRCaW5kaW5nQXR0ciAoXG4gIGVsLFxuICBuYW1lLFxuICBnZXRTdGF0aWNcbikge1xuICB2YXIgZHluYW1pY1ZhbHVlID1cbiAgICBnZXRBbmRSZW1vdmVBdHRyKGVsLCAnOicgKyBuYW1lKSB8fFxuICAgIGdldEFuZFJlbW92ZUF0dHIoZWwsICd2LWJpbmQ6JyArIG5hbWUpO1xuICBpZiAoZHluYW1pY1ZhbHVlICE9IG51bGwpIHtcbiAgICByZXR1cm4gcGFyc2VGaWx0ZXJzKGR5bmFtaWNWYWx1ZSlcbiAgfSBlbHNlIGlmIChnZXRTdGF0aWMgIT09IGZhbHNlKSB7XG4gICAgdmFyIHN0YXRpY1ZhbHVlID0gZ2V0QW5kUmVtb3ZlQXR0cihlbCwgbmFtZSk7XG4gICAgaWYgKHN0YXRpY1ZhbHVlICE9IG51bGwpIHtcbiAgICAgIHJldHVybiBKU09OLnN0cmluZ2lmeShzdGF0aWNWYWx1ZSlcbiAgICB9XG4gIH1cbn1cblxuLy8gbm90ZTogdGhpcyBvbmx5IHJlbW92ZXMgdGhlIGF0dHIgZnJvbSB0aGUgQXJyYXkgKGF0dHJzTGlzdCkgc28gdGhhdCBpdFxuLy8gZG9lc24ndCBnZXQgcHJvY2Vzc2VkIGJ5IHByb2Nlc3NBdHRycy5cbi8vIEJ5IGRlZmF1bHQgaXQgZG9lcyBOT1QgcmVtb3ZlIGl0IGZyb20gdGhlIG1hcCAoYXR0cnNNYXApIGJlY2F1c2UgdGhlIG1hcCBpc1xuLy8gbmVlZGVkIGR1cmluZyBjb2RlZ2VuLlxuZnVuY3Rpb24gZ2V0QW5kUmVtb3ZlQXR0ciAoXG4gIGVsLFxuICBuYW1lLFxuICByZW1vdmVGcm9tTWFwXG4pIHtcbiAgdmFyIHZhbDtcbiAgaWYgKCh2YWwgPSBlbC5hdHRyc01hcFtuYW1lXSkgIT0gbnVsbCkge1xuICAgIHZhciBsaXN0ID0gZWwuYXR0cnNMaXN0O1xuICAgIGZvciAodmFyIGkgPSAwLCBsID0gbGlzdC5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgIGlmIChsaXN0W2ldLm5hbWUgPT09IG5hbWUpIHtcbiAgICAgICAgbGlzdC5zcGxpY2UoaSwgMSk7XG4gICAgICAgIGJyZWFrXG4gICAgICB9XG4gICAgfVxuICB9XG4gIGlmIChyZW1vdmVGcm9tTWFwKSB7XG4gICAgZGVsZXRlIGVsLmF0dHJzTWFwW25hbWVdO1xuICB9XG4gIHJldHVybiB2YWxcbn1cblxuZnVuY3Rpb24gZ2V0QW5kUmVtb3ZlQXR0ckJ5UmVnZXggKFxuICBlbCxcbiAgbmFtZVxuKSB7XG4gIHZhciBsaXN0ID0gZWwuYXR0cnNMaXN0O1xuICBmb3IgKHZhciBpID0gMCwgbCA9IGxpc3QubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgdmFyIGF0dHIgPSBsaXN0W2ldO1xuICAgIGlmIChuYW1lLnRlc3QoYXR0ci5uYW1lKSkge1xuICAgICAgbGlzdC5zcGxpY2UoaSwgMSk7XG4gICAgICByZXR1cm4gYXR0clxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiByYW5nZVNldEl0ZW0gKFxuICBpdGVtLFxuICByYW5nZVxuKSB7XG4gIGlmIChyYW5nZSkge1xuICAgIGlmIChyYW5nZS5zdGFydCAhPSBudWxsKSB7XG4gICAgICBpdGVtLnN0YXJ0ID0gcmFuZ2Uuc3RhcnQ7XG4gICAgfVxuICAgIGlmIChyYW5nZS5lbmQgIT0gbnVsbCkge1xuICAgICAgaXRlbS5lbmQgPSByYW5nZS5lbmQ7XG4gICAgfVxuICB9XG4gIHJldHVybiBpdGVtXG59XG5cbi8qICAqL1xuXG4vKipcbiAqIENyb3NzLXBsYXRmb3JtIGNvZGUgZ2VuZXJhdGlvbiBmb3IgY29tcG9uZW50IHYtbW9kZWxcbiAqL1xuZnVuY3Rpb24gZ2VuQ29tcG9uZW50TW9kZWwgKFxuICBlbCxcbiAgdmFsdWUsXG4gIG1vZGlmaWVyc1xuKSB7XG4gIHZhciByZWYgPSBtb2RpZmllcnMgfHwge307XG4gIHZhciBudW1iZXIgPSByZWYubnVtYmVyO1xuICB2YXIgdHJpbSA9IHJlZi50cmltO1xuXG4gIHZhciBiYXNlVmFsdWVFeHByZXNzaW9uID0gJyQkdic7XG4gIHZhciB2YWx1ZUV4cHJlc3Npb24gPSBiYXNlVmFsdWVFeHByZXNzaW9uO1xuICBpZiAodHJpbSkge1xuICAgIHZhbHVlRXhwcmVzc2lvbiA9XG4gICAgICBcIih0eXBlb2YgXCIgKyBiYXNlVmFsdWVFeHByZXNzaW9uICsgXCIgPT09ICdzdHJpbmcnXCIgK1xuICAgICAgXCI/IFwiICsgYmFzZVZhbHVlRXhwcmVzc2lvbiArIFwiLnRyaW0oKVwiICtcbiAgICAgIFwiOiBcIiArIGJhc2VWYWx1ZUV4cHJlc3Npb24gKyBcIilcIjtcbiAgfVxuICBpZiAobnVtYmVyKSB7XG4gICAgdmFsdWVFeHByZXNzaW9uID0gXCJfbihcIiArIHZhbHVlRXhwcmVzc2lvbiArIFwiKVwiO1xuICB9XG4gIHZhciBhc3NpZ25tZW50ID0gZ2VuQXNzaWdubWVudENvZGUodmFsdWUsIHZhbHVlRXhwcmVzc2lvbik7XG5cbiAgZWwubW9kZWwgPSB7XG4gICAgdmFsdWU6IChcIihcIiArIHZhbHVlICsgXCIpXCIpLFxuICAgIGV4cHJlc3Npb246IEpTT04uc3RyaW5naWZ5KHZhbHVlKSxcbiAgICBjYWxsYmFjazogKFwiZnVuY3Rpb24gKFwiICsgYmFzZVZhbHVlRXhwcmVzc2lvbiArIFwiKSB7XCIgKyBhc3NpZ25tZW50ICsgXCJ9XCIpXG4gIH07XG59XG5cbi8qKlxuICogQ3Jvc3MtcGxhdGZvcm0gY29kZWdlbiBoZWxwZXIgZm9yIGdlbmVyYXRpbmcgdi1tb2RlbCB2YWx1ZSBhc3NpZ25tZW50IGNvZGUuXG4gKi9cbmZ1bmN0aW9uIGdlbkFzc2lnbm1lbnRDb2RlIChcbiAgdmFsdWUsXG4gIGFzc2lnbm1lbnRcbikge1xuICB2YXIgcmVzID0gcGFyc2VNb2RlbCh2YWx1ZSk7XG4gIGlmIChyZXMua2V5ID09PSBudWxsKSB7XG4gICAgcmV0dXJuICh2YWx1ZSArIFwiPVwiICsgYXNzaWdubWVudClcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gKFwiJHNldChcIiArIChyZXMuZXhwKSArIFwiLCBcIiArIChyZXMua2V5KSArIFwiLCBcIiArIGFzc2lnbm1lbnQgKyBcIilcIilcbiAgfVxufVxuXG4vKipcbiAqIFBhcnNlIGEgdi1tb2RlbCBleHByZXNzaW9uIGludG8gYSBiYXNlIHBhdGggYW5kIGEgZmluYWwga2V5IHNlZ21lbnQuXG4gKiBIYW5kbGVzIGJvdGggZG90LXBhdGggYW5kIHBvc3NpYmxlIHNxdWFyZSBicmFja2V0cy5cbiAqXG4gKiBQb3NzaWJsZSBjYXNlczpcbiAqXG4gKiAtIHRlc3RcbiAqIC0gdGVzdFtrZXldXG4gKiAtIHRlc3RbdGVzdDFba2V5XV1cbiAqIC0gdGVzdFtcImFcIl1ba2V5XVxuICogLSB4eHgudGVzdFthW2FdLnRlc3QxW2tleV1dXG4gKiAtIHRlc3QueHh4LmFbXCJhc2FcIl1bdGVzdDFba2V5XV1cbiAqXG4gKi9cblxudmFyIGxlbiwgc3RyLCBjaHIsIGluZGV4JDEsIGV4cHJlc3Npb25Qb3MsIGV4cHJlc3Npb25FbmRQb3M7XG5cblxuXG5mdW5jdGlvbiBwYXJzZU1vZGVsICh2YWwpIHtcbiAgLy8gRml4IGh0dHBzOi8vZ2l0aHViLmNvbS92dWVqcy92dWUvcHVsbC83NzMwXG4gIC8vIGFsbG93IHYtbW9kZWw9XCJvYmoudmFsIFwiICh0cmFpbGluZyB3aGl0ZXNwYWNlKVxuICB2YWwgPSB2YWwudHJpbSgpO1xuICBsZW4gPSB2YWwubGVuZ3RoO1xuXG4gIGlmICh2YWwuaW5kZXhPZignWycpIDwgMCB8fCB2YWwubGFzdEluZGV4T2YoJ10nKSA8IGxlbiAtIDEpIHtcbiAgICBpbmRleCQxID0gdmFsLmxhc3RJbmRleE9mKCcuJyk7XG4gICAgaWYgKGluZGV4JDEgPiAtMSkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgZXhwOiB2YWwuc2xpY2UoMCwgaW5kZXgkMSksXG4gICAgICAgIGtleTogJ1wiJyArIHZhbC5zbGljZShpbmRleCQxICsgMSkgKyAnXCInXG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGV4cDogdmFsLFxuICAgICAgICBrZXk6IG51bGxcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBzdHIgPSB2YWw7XG4gIGluZGV4JDEgPSBleHByZXNzaW9uUG9zID0gZXhwcmVzc2lvbkVuZFBvcyA9IDA7XG5cbiAgd2hpbGUgKCFlb2YoKSkge1xuICAgIGNociA9IG5leHQoKTtcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICBpZiAoaXNTdHJpbmdTdGFydChjaHIpKSB7XG4gICAgICBwYXJzZVN0cmluZyhjaHIpO1xuICAgIH0gZWxzZSBpZiAoY2hyID09PSAweDVCKSB7XG4gICAgICBwYXJzZUJyYWNrZXQoY2hyKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4ge1xuICAgIGV4cDogdmFsLnNsaWNlKDAsIGV4cHJlc3Npb25Qb3MpLFxuICAgIGtleTogdmFsLnNsaWNlKGV4cHJlc3Npb25Qb3MgKyAxLCBleHByZXNzaW9uRW5kUG9zKVxuICB9XG59XG5cbmZ1bmN0aW9uIG5leHQgKCkge1xuICByZXR1cm4gc3RyLmNoYXJDb2RlQXQoKytpbmRleCQxKVxufVxuXG5mdW5jdGlvbiBlb2YgKCkge1xuICByZXR1cm4gaW5kZXgkMSA+PSBsZW5cbn1cblxuZnVuY3Rpb24gaXNTdHJpbmdTdGFydCAoY2hyKSB7XG4gIHJldHVybiBjaHIgPT09IDB4MjIgfHwgY2hyID09PSAweDI3XG59XG5cbmZ1bmN0aW9uIHBhcnNlQnJhY2tldCAoY2hyKSB7XG4gIHZhciBpbkJyYWNrZXQgPSAxO1xuICBleHByZXNzaW9uUG9zID0gaW5kZXgkMTtcbiAgd2hpbGUgKCFlb2YoKSkge1xuICAgIGNociA9IG5leHQoKTtcbiAgICBpZiAoaXNTdHJpbmdTdGFydChjaHIpKSB7XG4gICAgICBwYXJzZVN0cmluZyhjaHIpO1xuICAgICAgY29udGludWVcbiAgICB9XG4gICAgaWYgKGNociA9PT0gMHg1QikgeyBpbkJyYWNrZXQrKzsgfVxuICAgIGlmIChjaHIgPT09IDB4NUQpIHsgaW5CcmFja2V0LS07IH1cbiAgICBpZiAoaW5CcmFja2V0ID09PSAwKSB7XG4gICAgICBleHByZXNzaW9uRW5kUG9zID0gaW5kZXgkMTtcbiAgICAgIGJyZWFrXG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHBhcnNlU3RyaW5nIChjaHIpIHtcbiAgdmFyIHN0cmluZ1F1b3RlID0gY2hyO1xuICB3aGlsZSAoIWVvZigpKSB7XG4gICAgY2hyID0gbmV4dCgpO1xuICAgIGlmIChjaHIgPT09IHN0cmluZ1F1b3RlKSB7XG4gICAgICBicmVha1xuICAgIH1cbiAgfVxufVxuXG4vKiAgKi9cblxudmFyIHdhcm4kMTtcblxuLy8gaW4gc29tZSBjYXNlcywgdGhlIGV2ZW50IHVzZWQgaGFzIHRvIGJlIGRldGVybWluZWQgYXQgcnVudGltZVxuLy8gc28gd2UgdXNlZCBzb21lIHJlc2VydmVkIHRva2VucyBkdXJpbmcgY29tcGlsZS5cbnZhciBSQU5HRV9UT0tFTiA9ICdfX3InO1xudmFyIENIRUNLQk9YX1JBRElPX1RPS0VOID0gJ19fYyc7XG5cbmZ1bmN0aW9uIG1vZGVsIChcbiAgZWwsXG4gIGRpcixcbiAgX3dhcm5cbikge1xuICB3YXJuJDEgPSBfd2FybjtcbiAgdmFyIHZhbHVlID0gZGlyLnZhbHVlO1xuICB2YXIgbW9kaWZpZXJzID0gZGlyLm1vZGlmaWVycztcbiAgdmFyIHRhZyA9IGVsLnRhZztcbiAgdmFyIHR5cGUgPSBlbC5hdHRyc01hcC50eXBlO1xuXG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgLy8gaW5wdXRzIHdpdGggdHlwZT1cImZpbGVcIiBhcmUgcmVhZCBvbmx5IGFuZCBzZXR0aW5nIHRoZSBpbnB1dCdzXG4gICAgLy8gdmFsdWUgd2lsbCB0aHJvdyBhbiBlcnJvci5cbiAgICBpZiAodGFnID09PSAnaW5wdXQnICYmIHR5cGUgPT09ICdmaWxlJykge1xuICAgICAgd2FybiQxKFxuICAgICAgICBcIjxcIiArIChlbC50YWcpICsgXCIgdi1tb2RlbD1cXFwiXCIgKyB2YWx1ZSArIFwiXFxcIiB0eXBlPVxcXCJmaWxlXFxcIj46XFxuXCIgK1xuICAgICAgICBcIkZpbGUgaW5wdXRzIGFyZSByZWFkIG9ubHkuIFVzZSBhIHYtb246Y2hhbmdlIGxpc3RlbmVyIGluc3RlYWQuXCIsXG4gICAgICAgIGVsLnJhd0F0dHJzTWFwWyd2LW1vZGVsJ11cbiAgICAgICk7XG4gICAgfVxuICB9XG5cbiAgaWYgKGVsLmNvbXBvbmVudCkge1xuICAgIGdlbkNvbXBvbmVudE1vZGVsKGVsLCB2YWx1ZSwgbW9kaWZpZXJzKTtcbiAgICAvLyBjb21wb25lbnQgdi1tb2RlbCBkb2Vzbid0IG5lZWQgZXh0cmEgcnVudGltZVxuICAgIHJldHVybiBmYWxzZVxuICB9IGVsc2UgaWYgKHRhZyA9PT0gJ3NlbGVjdCcpIHtcbiAgICBnZW5TZWxlY3QoZWwsIHZhbHVlLCBtb2RpZmllcnMpO1xuICB9IGVsc2UgaWYgKHRhZyA9PT0gJ2lucHV0JyAmJiB0eXBlID09PSAnY2hlY2tib3gnKSB7XG4gICAgZ2VuQ2hlY2tib3hNb2RlbChlbCwgdmFsdWUsIG1vZGlmaWVycyk7XG4gIH0gZWxzZSBpZiAodGFnID09PSAnaW5wdXQnICYmIHR5cGUgPT09ICdyYWRpbycpIHtcbiAgICBnZW5SYWRpb01vZGVsKGVsLCB2YWx1ZSwgbW9kaWZpZXJzKTtcbiAgfSBlbHNlIGlmICh0YWcgPT09ICdpbnB1dCcgfHwgdGFnID09PSAndGV4dGFyZWEnKSB7XG4gICAgZ2VuRGVmYXVsdE1vZGVsKGVsLCB2YWx1ZSwgbW9kaWZpZXJzKTtcbiAgfSBlbHNlIGlmICghY29uZmlnLmlzUmVzZXJ2ZWRUYWcodGFnKSkge1xuICAgIGdlbkNvbXBvbmVudE1vZGVsKGVsLCB2YWx1ZSwgbW9kaWZpZXJzKTtcbiAgICAvLyBjb21wb25lbnQgdi1tb2RlbCBkb2Vzbid0IG5lZWQgZXh0cmEgcnVudGltZVxuICAgIHJldHVybiBmYWxzZVxuICB9IGVsc2UgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICB3YXJuJDEoXG4gICAgICBcIjxcIiArIChlbC50YWcpICsgXCIgdi1tb2RlbD1cXFwiXCIgKyB2YWx1ZSArIFwiXFxcIj46IFwiICtcbiAgICAgIFwidi1tb2RlbCBpcyBub3Qgc3VwcG9ydGVkIG9uIHRoaXMgZWxlbWVudCB0eXBlLiBcIiArXG4gICAgICAnSWYgeW91IGFyZSB3b3JraW5nIHdpdGggY29udGVudGVkaXRhYmxlLCBpdFxcJ3MgcmVjb21tZW5kZWQgdG8gJyArXG4gICAgICAnd3JhcCBhIGxpYnJhcnkgZGVkaWNhdGVkIGZvciB0aGF0IHB1cnBvc2UgaW5zaWRlIGEgY3VzdG9tIGNvbXBvbmVudC4nLFxuICAgICAgZWwucmF3QXR0cnNNYXBbJ3YtbW9kZWwnXVxuICAgICk7XG4gIH1cblxuICAvLyBlbnN1cmUgcnVudGltZSBkaXJlY3RpdmUgbWV0YWRhdGFcbiAgcmV0dXJuIHRydWVcbn1cblxuZnVuY3Rpb24gZ2VuQ2hlY2tib3hNb2RlbCAoXG4gIGVsLFxuICB2YWx1ZSxcbiAgbW9kaWZpZXJzXG4pIHtcbiAgdmFyIG51bWJlciA9IG1vZGlmaWVycyAmJiBtb2RpZmllcnMubnVtYmVyO1xuICB2YXIgdmFsdWVCaW5kaW5nID0gZ2V0QmluZGluZ0F0dHIoZWwsICd2YWx1ZScpIHx8ICdudWxsJztcbiAgdmFyIHRydWVWYWx1ZUJpbmRpbmcgPSBnZXRCaW5kaW5nQXR0cihlbCwgJ3RydWUtdmFsdWUnKSB8fCAndHJ1ZSc7XG4gIHZhciBmYWxzZVZhbHVlQmluZGluZyA9IGdldEJpbmRpbmdBdHRyKGVsLCAnZmFsc2UtdmFsdWUnKSB8fCAnZmFsc2UnO1xuICBhZGRQcm9wKGVsLCAnY2hlY2tlZCcsXG4gICAgXCJBcnJheS5pc0FycmF5KFwiICsgdmFsdWUgKyBcIilcIiArXG4gICAgXCI/X2koXCIgKyB2YWx1ZSArIFwiLFwiICsgdmFsdWVCaW5kaW5nICsgXCIpPi0xXCIgKyAoXG4gICAgICB0cnVlVmFsdWVCaW5kaW5nID09PSAndHJ1ZSdcbiAgICAgICAgPyAoXCI6KFwiICsgdmFsdWUgKyBcIilcIilcbiAgICAgICAgOiAoXCI6X3EoXCIgKyB2YWx1ZSArIFwiLFwiICsgdHJ1ZVZhbHVlQmluZGluZyArIFwiKVwiKVxuICAgIClcbiAgKTtcbiAgYWRkSGFuZGxlcihlbCwgJ2NoYW5nZScsXG4gICAgXCJ2YXIgJCRhPVwiICsgdmFsdWUgKyBcIixcIiArXG4gICAgICAgICckJGVsPSRldmVudC50YXJnZXQsJyArXG4gICAgICAgIFwiJCRjPSQkZWwuY2hlY2tlZD8oXCIgKyB0cnVlVmFsdWVCaW5kaW5nICsgXCIpOihcIiArIGZhbHNlVmFsdWVCaW5kaW5nICsgXCIpO1wiICtcbiAgICAnaWYoQXJyYXkuaXNBcnJheSgkJGEpKXsnICtcbiAgICAgIFwidmFyICQkdj1cIiArIChudW1iZXIgPyAnX24oJyArIHZhbHVlQmluZGluZyArICcpJyA6IHZhbHVlQmluZGluZykgKyBcIixcIiArXG4gICAgICAgICAgJyQkaT1faSgkJGEsJCR2KTsnICtcbiAgICAgIFwiaWYoJCRlbC5jaGVja2VkKXskJGk8MCYmKFwiICsgKGdlbkFzc2lnbm1lbnRDb2RlKHZhbHVlLCAnJCRhLmNvbmNhdChbJCR2XSknKSkgKyBcIil9XCIgK1xuICAgICAgXCJlbHNleyQkaT4tMSYmKFwiICsgKGdlbkFzc2lnbm1lbnRDb2RlKHZhbHVlLCAnJCRhLnNsaWNlKDAsJCRpKS5jb25jYXQoJCRhLnNsaWNlKCQkaSsxKSknKSkgKyBcIil9XCIgK1xuICAgIFwifWVsc2V7XCIgKyAoZ2VuQXNzaWdubWVudENvZGUodmFsdWUsICckJGMnKSkgKyBcIn1cIixcbiAgICBudWxsLCB0cnVlXG4gICk7XG59XG5cbmZ1bmN0aW9uIGdlblJhZGlvTW9kZWwgKFxuICBlbCxcbiAgdmFsdWUsXG4gIG1vZGlmaWVyc1xuKSB7XG4gIHZhciBudW1iZXIgPSBtb2RpZmllcnMgJiYgbW9kaWZpZXJzLm51bWJlcjtcbiAgdmFyIHZhbHVlQmluZGluZyA9IGdldEJpbmRpbmdBdHRyKGVsLCAndmFsdWUnKSB8fCAnbnVsbCc7XG4gIHZhbHVlQmluZGluZyA9IG51bWJlciA/IChcIl9uKFwiICsgdmFsdWVCaW5kaW5nICsgXCIpXCIpIDogdmFsdWVCaW5kaW5nO1xuICBhZGRQcm9wKGVsLCAnY2hlY2tlZCcsIChcIl9xKFwiICsgdmFsdWUgKyBcIixcIiArIHZhbHVlQmluZGluZyArIFwiKVwiKSk7XG4gIGFkZEhhbmRsZXIoZWwsICdjaGFuZ2UnLCBnZW5Bc3NpZ25tZW50Q29kZSh2YWx1ZSwgdmFsdWVCaW5kaW5nKSwgbnVsbCwgdHJ1ZSk7XG59XG5cbmZ1bmN0aW9uIGdlblNlbGVjdCAoXG4gIGVsLFxuICB2YWx1ZSxcbiAgbW9kaWZpZXJzXG4pIHtcbiAgdmFyIG51bWJlciA9IG1vZGlmaWVycyAmJiBtb2RpZmllcnMubnVtYmVyO1xuICB2YXIgc2VsZWN0ZWRWYWwgPSBcIkFycmF5LnByb3RvdHlwZS5maWx0ZXJcIiArXG4gICAgXCIuY2FsbCgkZXZlbnQudGFyZ2V0Lm9wdGlvbnMsZnVuY3Rpb24obyl7cmV0dXJuIG8uc2VsZWN0ZWR9KVwiICtcbiAgICBcIi5tYXAoZnVuY3Rpb24obyl7dmFyIHZhbCA9IFxcXCJfdmFsdWVcXFwiIGluIG8gPyBvLl92YWx1ZSA6IG8udmFsdWU7XCIgK1xuICAgIFwicmV0dXJuIFwiICsgKG51bWJlciA/ICdfbih2YWwpJyA6ICd2YWwnKSArIFwifSlcIjtcblxuICB2YXIgYXNzaWdubWVudCA9ICckZXZlbnQudGFyZ2V0Lm11bHRpcGxlID8gJCRzZWxlY3RlZFZhbCA6ICQkc2VsZWN0ZWRWYWxbMF0nO1xuICB2YXIgY29kZSA9IFwidmFyICQkc2VsZWN0ZWRWYWwgPSBcIiArIHNlbGVjdGVkVmFsICsgXCI7XCI7XG4gIGNvZGUgPSBjb2RlICsgXCIgXCIgKyAoZ2VuQXNzaWdubWVudENvZGUodmFsdWUsIGFzc2lnbm1lbnQpKTtcbiAgYWRkSGFuZGxlcihlbCwgJ2NoYW5nZScsIGNvZGUsIG51bGwsIHRydWUpO1xufVxuXG5mdW5jdGlvbiBnZW5EZWZhdWx0TW9kZWwgKFxuICBlbCxcbiAgdmFsdWUsXG4gIG1vZGlmaWVyc1xuKSB7XG4gIHZhciB0eXBlID0gZWwuYXR0cnNNYXAudHlwZTtcblxuICAvLyB3YXJuIGlmIHYtYmluZDp2YWx1ZSBjb25mbGljdHMgd2l0aCB2LW1vZGVsXG4gIC8vIGV4Y2VwdCBmb3IgaW5wdXRzIHdpdGggdi1iaW5kOnR5cGVcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICB2YXIgdmFsdWUkMSA9IGVsLmF0dHJzTWFwWyd2LWJpbmQ6dmFsdWUnXSB8fCBlbC5hdHRyc01hcFsnOnZhbHVlJ107XG4gICAgdmFyIHR5cGVCaW5kaW5nID0gZWwuYXR0cnNNYXBbJ3YtYmluZDp0eXBlJ10gfHwgZWwuYXR0cnNNYXBbJzp0eXBlJ107XG4gICAgaWYgKHZhbHVlJDEgJiYgIXR5cGVCaW5kaW5nKSB7XG4gICAgICB2YXIgYmluZGluZyA9IGVsLmF0dHJzTWFwWyd2LWJpbmQ6dmFsdWUnXSA/ICd2LWJpbmQ6dmFsdWUnIDogJzp2YWx1ZSc7XG4gICAgICB3YXJuJDEoXG4gICAgICAgIGJpbmRpbmcgKyBcIj1cXFwiXCIgKyB2YWx1ZSQxICsgXCJcXFwiIGNvbmZsaWN0cyB3aXRoIHYtbW9kZWwgb24gdGhlIHNhbWUgZWxlbWVudCBcIiArXG4gICAgICAgICdiZWNhdXNlIHRoZSBsYXR0ZXIgYWxyZWFkeSBleHBhbmRzIHRvIGEgdmFsdWUgYmluZGluZyBpbnRlcm5hbGx5JyxcbiAgICAgICAgZWwucmF3QXR0cnNNYXBbYmluZGluZ11cbiAgICAgICk7XG4gICAgfVxuICB9XG5cbiAgdmFyIHJlZiA9IG1vZGlmaWVycyB8fCB7fTtcbiAgdmFyIGxhenkgPSByZWYubGF6eTtcbiAgdmFyIG51bWJlciA9IHJlZi5udW1iZXI7XG4gIHZhciB0cmltID0gcmVmLnRyaW07XG4gIHZhciBuZWVkQ29tcG9zaXRpb25HdWFyZCA9ICFsYXp5ICYmIHR5cGUgIT09ICdyYW5nZSc7XG4gIHZhciBldmVudCA9IGxhenlcbiAgICA/ICdjaGFuZ2UnXG4gICAgOiB0eXBlID09PSAncmFuZ2UnXG4gICAgICA/IFJBTkdFX1RPS0VOXG4gICAgICA6ICdpbnB1dCc7XG5cbiAgdmFyIHZhbHVlRXhwcmVzc2lvbiA9ICckZXZlbnQudGFyZ2V0LnZhbHVlJztcbiAgaWYgKHRyaW0pIHtcbiAgICB2YWx1ZUV4cHJlc3Npb24gPSBcIiRldmVudC50YXJnZXQudmFsdWUudHJpbSgpXCI7XG4gIH1cbiAgaWYgKG51bWJlcikge1xuICAgIHZhbHVlRXhwcmVzc2lvbiA9IFwiX24oXCIgKyB2YWx1ZUV4cHJlc3Npb24gKyBcIilcIjtcbiAgfVxuXG4gIHZhciBjb2RlID0gZ2VuQXNzaWdubWVudENvZGUodmFsdWUsIHZhbHVlRXhwcmVzc2lvbik7XG4gIGlmIChuZWVkQ29tcG9zaXRpb25HdWFyZCkge1xuICAgIGNvZGUgPSBcImlmKCRldmVudC50YXJnZXQuY29tcG9zaW5nKXJldHVybjtcIiArIGNvZGU7XG4gIH1cblxuICBhZGRQcm9wKGVsLCAndmFsdWUnLCAoXCIoXCIgKyB2YWx1ZSArIFwiKVwiKSk7XG4gIGFkZEhhbmRsZXIoZWwsIGV2ZW50LCBjb2RlLCBudWxsLCB0cnVlKTtcbiAgaWYgKHRyaW0gfHwgbnVtYmVyKSB7XG4gICAgYWRkSGFuZGxlcihlbCwgJ2JsdXInLCAnJGZvcmNlVXBkYXRlKCknKTtcbiAgfVxufVxuXG4vKiAgKi9cblxuLy8gbm9ybWFsaXplIHYtbW9kZWwgZXZlbnQgdG9rZW5zIHRoYXQgY2FuIG9ubHkgYmUgZGV0ZXJtaW5lZCBhdCBydW50aW1lLlxuLy8gaXQncyBpbXBvcnRhbnQgdG8gcGxhY2UgdGhlIGV2ZW50IGFzIHRoZSBmaXJzdCBpbiB0aGUgYXJyYXkgYmVjYXVzZVxuLy8gdGhlIHdob2xlIHBvaW50IGlzIGVuc3VyaW5nIHRoZSB2LW1vZGVsIGNhbGxiYWNrIGdldHMgY2FsbGVkIGJlZm9yZVxuLy8gdXNlci1hdHRhY2hlZCBoYW5kbGVycy5cbmZ1bmN0aW9uIG5vcm1hbGl6ZUV2ZW50cyAob24pIHtcbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gIGlmIChpc0RlZihvbltSQU5HRV9UT0tFTl0pKSB7XG4gICAgLy8gSUUgaW5wdXRbdHlwZT1yYW5nZV0gb25seSBzdXBwb3J0cyBgY2hhbmdlYCBldmVudFxuICAgIHZhciBldmVudCA9IGlzSUUgPyAnY2hhbmdlJyA6ICdpbnB1dCc7XG4gICAgb25bZXZlbnRdID0gW10uY29uY2F0KG9uW1JBTkdFX1RPS0VOXSwgb25bZXZlbnRdIHx8IFtdKTtcbiAgICBkZWxldGUgb25bUkFOR0VfVE9LRU5dO1xuICB9XG4gIC8vIFRoaXMgd2FzIG9yaWdpbmFsbHkgaW50ZW5kZWQgdG8gZml4ICM0NTIxIGJ1dCBubyBsb25nZXIgbmVjZXNzYXJ5XG4gIC8vIGFmdGVyIDIuNS4gS2VlcGluZyBpdCBmb3IgYmFja3dhcmRzIGNvbXBhdCB3aXRoIGdlbmVyYXRlZCBjb2RlIGZyb20gPCAyLjRcbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gIGlmIChpc0RlZihvbltDSEVDS0JPWF9SQURJT19UT0tFTl0pKSB7XG4gICAgb24uY2hhbmdlID0gW10uY29uY2F0KG9uW0NIRUNLQk9YX1JBRElPX1RPS0VOXSwgb24uY2hhbmdlIHx8IFtdKTtcbiAgICBkZWxldGUgb25bQ0hFQ0tCT1hfUkFESU9fVE9LRU5dO1xuICB9XG59XG5cbnZhciB0YXJnZXQkMTtcblxuZnVuY3Rpb24gY3JlYXRlT25jZUhhbmRsZXIkMSAoZXZlbnQsIGhhbmRsZXIsIGNhcHR1cmUpIHtcbiAgdmFyIF90YXJnZXQgPSB0YXJnZXQkMTsgLy8gc2F2ZSBjdXJyZW50IHRhcmdldCBlbGVtZW50IGluIGNsb3N1cmVcbiAgcmV0dXJuIGZ1bmN0aW9uIG9uY2VIYW5kbGVyICgpIHtcbiAgICB2YXIgcmVzID0gaGFuZGxlci5hcHBseShudWxsLCBhcmd1bWVudHMpO1xuICAgIGlmIChyZXMgIT09IG51bGwpIHtcbiAgICAgIHJlbW92ZSQyKGV2ZW50LCBvbmNlSGFuZGxlciwgY2FwdHVyZSwgX3RhcmdldCk7XG4gICAgfVxuICB9XG59XG5cbi8vICM5NDQ2OiBGaXJlZm94IDw9IDUzIChpbiBwYXJ0aWN1bGFyLCBFU1IgNTIpIGhhcyBpbmNvcnJlY3QgRXZlbnQudGltZVN0YW1wXG4vLyBpbXBsZW1lbnRhdGlvbiBhbmQgZG9lcyBub3QgZmlyZSBtaWNyb3Rhc2tzIGluIGJldHdlZW4gZXZlbnQgcHJvcGFnYXRpb24sIHNvXG4vLyBzYWZlIHRvIGV4Y2x1ZGUuXG52YXIgdXNlTWljcm90YXNrRml4ID0gaXNVc2luZ01pY3JvVGFzayAmJiAhKGlzRkYgJiYgTnVtYmVyKGlzRkZbMV0pIDw9IDUzKTtcblxuZnVuY3Rpb24gYWRkJDEgKFxuICBuYW1lLFxuICBoYW5kbGVyLFxuICBjYXB0dXJlLFxuICBwYXNzaXZlXG4pIHtcbiAgLy8gYXN5bmMgZWRnZSBjYXNlICM2NTY2OiBpbm5lciBjbGljayBldmVudCB0cmlnZ2VycyBwYXRjaCwgZXZlbnQgaGFuZGxlclxuICAvLyBhdHRhY2hlZCB0byBvdXRlciBlbGVtZW50IGR1cmluZyBwYXRjaCwgYW5kIHRyaWdnZXJlZCBhZ2Fpbi4gVGhpc1xuICAvLyBoYXBwZW5zIGJlY2F1c2UgYnJvd3NlcnMgZmlyZSBtaWNyb3Rhc2sgdGlja3MgYmV0d2VlbiBldmVudCBwcm9wYWdhdGlvbi5cbiAgLy8gdGhlIHNvbHV0aW9uIGlzIHNpbXBsZTogd2Ugc2F2ZSB0aGUgdGltZXN0YW1wIHdoZW4gYSBoYW5kbGVyIGlzIGF0dGFjaGVkLFxuICAvLyBhbmQgdGhlIGhhbmRsZXIgd291bGQgb25seSBmaXJlIGlmIHRoZSBldmVudCBwYXNzZWQgdG8gaXQgd2FzIGZpcmVkXG4gIC8vIEFGVEVSIGl0IHdhcyBhdHRhY2hlZC5cbiAgaWYgKHVzZU1pY3JvdGFza0ZpeCkge1xuICAgIHZhciBhdHRhY2hlZFRpbWVzdGFtcCA9IGN1cnJlbnRGbHVzaFRpbWVzdGFtcDtcbiAgICB2YXIgb3JpZ2luYWwgPSBoYW5kbGVyO1xuICAgIGhhbmRsZXIgPSBvcmlnaW5hbC5fd3JhcHBlciA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICBpZiAoXG4gICAgICAgIC8vIG5vIGJ1YmJsaW5nLCBzaG91bGQgYWx3YXlzIGZpcmUuXG4gICAgICAgIC8vIHRoaXMgaXMganVzdCBhIHNhZmV0eSBuZXQgaW4gY2FzZSBldmVudC50aW1lU3RhbXAgaXMgdW5yZWxpYWJsZSBpblxuICAgICAgICAvLyBjZXJ0YWluIHdlaXJkIGVudmlyb25tZW50cy4uLlxuICAgICAgICBlLnRhcmdldCA9PT0gZS5jdXJyZW50VGFyZ2V0IHx8XG4gICAgICAgIC8vIGV2ZW50IGlzIGZpcmVkIGFmdGVyIGhhbmRsZXIgYXR0YWNobWVudFxuICAgICAgICBlLnRpbWVTdGFtcCA+PSBhdHRhY2hlZFRpbWVzdGFtcCB8fFxuICAgICAgICAvLyBiYWlsIGZvciBlbnZpcm9ubWVudHMgdGhhdCBoYXZlIGJ1Z2d5IGV2ZW50LnRpbWVTdGFtcCBpbXBsZW1lbnRhdGlvbnNcbiAgICAgICAgLy8gIzk0NjIgaU9TIDkgYnVnOiBldmVudC50aW1lU3RhbXAgaXMgMCBhZnRlciBoaXN0b3J5LnB1c2hTdGF0ZVxuICAgICAgICAvLyAjOTY4MSBRdFdlYkVuZ2luZSBldmVudC50aW1lU3RhbXAgaXMgbmVnYXRpdmUgdmFsdWVcbiAgICAgICAgZS50aW1lU3RhbXAgPD0gMCB8fFxuICAgICAgICAvLyAjOTQ0OCBiYWlsIGlmIGV2ZW50IGlzIGZpcmVkIGluIGFub3RoZXIgZG9jdW1lbnQgaW4gYSBtdWx0aS1wYWdlXG4gICAgICAgIC8vIGVsZWN0cm9uL253LmpzIGFwcCwgc2luY2UgZXZlbnQudGltZVN0YW1wIHdpbGwgYmUgdXNpbmcgYSBkaWZmZXJlbnRcbiAgICAgICAgLy8gc3RhcnRpbmcgcmVmZXJlbmNlXG4gICAgICAgIGUudGFyZ2V0Lm93bmVyRG9jdW1lbnQgIT09IGRvY3VtZW50XG4gICAgICApIHtcbiAgICAgICAgcmV0dXJuIG9yaWdpbmFsLmFwcGx5KHRoaXMsIGFyZ3VtZW50cylcbiAgICAgIH1cbiAgICB9O1xuICB9XG4gIHRhcmdldCQxLmFkZEV2ZW50TGlzdGVuZXIoXG4gICAgbmFtZSxcbiAgICBoYW5kbGVyLFxuICAgIHN1cHBvcnRzUGFzc2l2ZVxuICAgICAgPyB7IGNhcHR1cmU6IGNhcHR1cmUsIHBhc3NpdmU6IHBhc3NpdmUgfVxuICAgICAgOiBjYXB0dXJlXG4gICk7XG59XG5cbmZ1bmN0aW9uIHJlbW92ZSQyIChcbiAgbmFtZSxcbiAgaGFuZGxlcixcbiAgY2FwdHVyZSxcbiAgX3RhcmdldFxuKSB7XG4gIChfdGFyZ2V0IHx8IHRhcmdldCQxKS5yZW1vdmVFdmVudExpc3RlbmVyKFxuICAgIG5hbWUsXG4gICAgaGFuZGxlci5fd3JhcHBlciB8fCBoYW5kbGVyLFxuICAgIGNhcHR1cmVcbiAgKTtcbn1cblxuZnVuY3Rpb24gdXBkYXRlRE9NTGlzdGVuZXJzIChvbGRWbm9kZSwgdm5vZGUpIHtcbiAgaWYgKGlzVW5kZWYob2xkVm5vZGUuZGF0YS5vbikgJiYgaXNVbmRlZih2bm9kZS5kYXRhLm9uKSkge1xuICAgIHJldHVyblxuICB9XG4gIHZhciBvbiA9IHZub2RlLmRhdGEub24gfHwge307XG4gIHZhciBvbGRPbiA9IG9sZFZub2RlLmRhdGEub24gfHwge307XG4gIHRhcmdldCQxID0gdm5vZGUuZWxtO1xuICBub3JtYWxpemVFdmVudHMob24pO1xuICB1cGRhdGVMaXN0ZW5lcnMob24sIG9sZE9uLCBhZGQkMSwgcmVtb3ZlJDIsIGNyZWF0ZU9uY2VIYW5kbGVyJDEsIHZub2RlLmNvbnRleHQpO1xuICB0YXJnZXQkMSA9IHVuZGVmaW5lZDtcbn1cblxudmFyIGV2ZW50cyA9IHtcbiAgY3JlYXRlOiB1cGRhdGVET01MaXN0ZW5lcnMsXG4gIHVwZGF0ZTogdXBkYXRlRE9NTGlzdGVuZXJzXG59O1xuXG4vKiAgKi9cblxudmFyIHN2Z0NvbnRhaW5lcjtcblxuZnVuY3Rpb24gdXBkYXRlRE9NUHJvcHMgKG9sZFZub2RlLCB2bm9kZSkge1xuICBpZiAoaXNVbmRlZihvbGRWbm9kZS5kYXRhLmRvbVByb3BzKSAmJiBpc1VuZGVmKHZub2RlLmRhdGEuZG9tUHJvcHMpKSB7XG4gICAgcmV0dXJuXG4gIH1cbiAgdmFyIGtleSwgY3VyO1xuICB2YXIgZWxtID0gdm5vZGUuZWxtO1xuICB2YXIgb2xkUHJvcHMgPSBvbGRWbm9kZS5kYXRhLmRvbVByb3BzIHx8IHt9O1xuICB2YXIgcHJvcHMgPSB2bm9kZS5kYXRhLmRvbVByb3BzIHx8IHt9O1xuICAvLyBjbG9uZSBvYnNlcnZlZCBvYmplY3RzLCBhcyB0aGUgdXNlciBwcm9iYWJseSB3YW50cyB0byBtdXRhdGUgaXRcbiAgaWYgKGlzRGVmKHByb3BzLl9fb2JfXykpIHtcbiAgICBwcm9wcyA9IHZub2RlLmRhdGEuZG9tUHJvcHMgPSBleHRlbmQoe30sIHByb3BzKTtcbiAgfVxuXG4gIGZvciAoa2V5IGluIG9sZFByb3BzKSB7XG4gICAgaWYgKCEoa2V5IGluIHByb3BzKSkge1xuICAgICAgZWxtW2tleV0gPSAnJztcbiAgICB9XG4gIH1cblxuICBmb3IgKGtleSBpbiBwcm9wcykge1xuICAgIGN1ciA9IHByb3BzW2tleV07XG4gICAgLy8gaWdub3JlIGNoaWxkcmVuIGlmIHRoZSBub2RlIGhhcyB0ZXh0Q29udGVudCBvciBpbm5lckhUTUwsXG4gICAgLy8gYXMgdGhlc2Ugd2lsbCB0aHJvdyBhd2F5IGV4aXN0aW5nIERPTSBub2RlcyBhbmQgY2F1c2UgcmVtb3ZhbCBlcnJvcnNcbiAgICAvLyBvbiBzdWJzZXF1ZW50IHBhdGNoZXMgKCMzMzYwKVxuICAgIGlmIChrZXkgPT09ICd0ZXh0Q29udGVudCcgfHwga2V5ID09PSAnaW5uZXJIVE1MJykge1xuICAgICAgaWYgKHZub2RlLmNoaWxkcmVuKSB7IHZub2RlLmNoaWxkcmVuLmxlbmd0aCA9IDA7IH1cbiAgICAgIGlmIChjdXIgPT09IG9sZFByb3BzW2tleV0pIHsgY29udGludWUgfVxuICAgICAgLy8gIzY2MDEgd29yayBhcm91bmQgQ2hyb21lIHZlcnNpb24gPD0gNTUgYnVnIHdoZXJlIHNpbmdsZSB0ZXh0Tm9kZVxuICAgICAgLy8gcmVwbGFjZWQgYnkgaW5uZXJIVE1ML3RleHRDb250ZW50IHJldGFpbnMgaXRzIHBhcmVudE5vZGUgcHJvcGVydHlcbiAgICAgIGlmIChlbG0uY2hpbGROb2Rlcy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgZWxtLnJlbW92ZUNoaWxkKGVsbS5jaGlsZE5vZGVzWzBdKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoa2V5ID09PSAndmFsdWUnICYmIGVsbS50YWdOYW1lICE9PSAnUFJPR1JFU1MnKSB7XG4gICAgICAvLyBzdG9yZSB2YWx1ZSBhcyBfdmFsdWUgYXMgd2VsbCBzaW5jZVxuICAgICAgLy8gbm9uLXN0cmluZyB2YWx1ZXMgd2lsbCBiZSBzdHJpbmdpZmllZFxuICAgICAgZWxtLl92YWx1ZSA9IGN1cjtcbiAgICAgIC8vIGF2b2lkIHJlc2V0dGluZyBjdXJzb3IgcG9zaXRpb24gd2hlbiB2YWx1ZSBpcyB0aGUgc2FtZVxuICAgICAgdmFyIHN0ckN1ciA9IGlzVW5kZWYoY3VyKSA/ICcnIDogU3RyaW5nKGN1cik7XG4gICAgICBpZiAoc2hvdWxkVXBkYXRlVmFsdWUoZWxtLCBzdHJDdXIpKSB7XG4gICAgICAgIGVsbS52YWx1ZSA9IHN0ckN1cjtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGtleSA9PT0gJ2lubmVySFRNTCcgJiYgaXNTVkcoZWxtLnRhZ05hbWUpICYmIGlzVW5kZWYoZWxtLmlubmVySFRNTCkpIHtcbiAgICAgIC8vIElFIGRvZXNuJ3Qgc3VwcG9ydCBpbm5lckhUTUwgZm9yIFNWRyBlbGVtZW50c1xuICAgICAgc3ZnQ29udGFpbmVyID0gc3ZnQ29udGFpbmVyIHx8IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgc3ZnQ29udGFpbmVyLmlubmVySFRNTCA9IFwiPHN2Zz5cIiArIGN1ciArIFwiPC9zdmc+XCI7XG4gICAgICB2YXIgc3ZnID0gc3ZnQ29udGFpbmVyLmZpcnN0Q2hpbGQ7XG4gICAgICB3aGlsZSAoZWxtLmZpcnN0Q2hpbGQpIHtcbiAgICAgICAgZWxtLnJlbW92ZUNoaWxkKGVsbS5maXJzdENoaWxkKTtcbiAgICAgIH1cbiAgICAgIHdoaWxlIChzdmcuZmlyc3RDaGlsZCkge1xuICAgICAgICBlbG0uYXBwZW5kQ2hpbGQoc3ZnLmZpcnN0Q2hpbGQpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoXG4gICAgICAvLyBza2lwIHRoZSB1cGRhdGUgaWYgb2xkIGFuZCBuZXcgVkRPTSBzdGF0ZSBpcyB0aGUgc2FtZS5cbiAgICAgIC8vIGB2YWx1ZWAgaXMgaGFuZGxlZCBzZXBhcmF0ZWx5IGJlY2F1c2UgdGhlIERPTSB2YWx1ZSBtYXkgYmUgdGVtcG9yYXJpbHlcbiAgICAgIC8vIG91dCBvZiBzeW5jIHdpdGggVkRPTSBzdGF0ZSBkdWUgdG8gZm9jdXMsIGNvbXBvc2l0aW9uIGFuZCBtb2RpZmllcnMuXG4gICAgICAvLyBUaGlzICAjNDUyMSBieSBza2lwcGluZyB0aGUgdW5uZWNlc3NhcnkgYGNoZWNrZWRgIHVwZGF0ZS5cbiAgICAgIGN1ciAhPT0gb2xkUHJvcHNba2V5XVxuICAgICkge1xuICAgICAgLy8gc29tZSBwcm9wZXJ0eSB1cGRhdGVzIGNhbiB0aHJvd1xuICAgICAgLy8gZS5nLiBgdmFsdWVgIG9uIDxwcm9ncmVzcz4gdy8gbm9uLWZpbml0ZSB2YWx1ZVxuICAgICAgdHJ5IHtcbiAgICAgICAgZWxtW2tleV0gPSBjdXI7XG4gICAgICB9IGNhdGNoIChlKSB7fVxuICAgIH1cbiAgfVxufVxuXG4vLyBjaGVjayBwbGF0Zm9ybXMvd2ViL3V0aWwvYXR0cnMuanMgYWNjZXB0VmFsdWVcblxuXG5mdW5jdGlvbiBzaG91bGRVcGRhdGVWYWx1ZSAoZWxtLCBjaGVja1ZhbCkge1xuICByZXR1cm4gKCFlbG0uY29tcG9zaW5nICYmIChcbiAgICBlbG0udGFnTmFtZSA9PT0gJ09QVElPTicgfHxcbiAgICBpc05vdEluRm9jdXNBbmREaXJ0eShlbG0sIGNoZWNrVmFsKSB8fFxuICAgIGlzRGlydHlXaXRoTW9kaWZpZXJzKGVsbSwgY2hlY2tWYWwpXG4gICkpXG59XG5cbmZ1bmN0aW9uIGlzTm90SW5Gb2N1c0FuZERpcnR5IChlbG0sIGNoZWNrVmFsKSB7XG4gIC8vIHJldHVybiB0cnVlIHdoZW4gdGV4dGJveCAoLm51bWJlciBhbmQgLnRyaW0pIGxvc2VzIGZvY3VzIGFuZCBpdHMgdmFsdWUgaXNcbiAgLy8gbm90IGVxdWFsIHRvIHRoZSB1cGRhdGVkIHZhbHVlXG4gIHZhciBub3RJbkZvY3VzID0gdHJ1ZTtcbiAgLy8gIzYxNTdcbiAgLy8gd29yayBhcm91bmQgSUUgYnVnIHdoZW4gYWNjZXNzaW5nIGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQgaW4gYW4gaWZyYW1lXG4gIHRyeSB7IG5vdEluRm9jdXMgPSBkb2N1bWVudC5hY3RpdmVFbGVtZW50ICE9PSBlbG07IH0gY2F0Y2ggKGUpIHt9XG4gIHJldHVybiBub3RJbkZvY3VzICYmIGVsbS52YWx1ZSAhPT0gY2hlY2tWYWxcbn1cblxuZnVuY3Rpb24gaXNEaXJ0eVdpdGhNb2RpZmllcnMgKGVsbSwgbmV3VmFsKSB7XG4gIHZhciB2YWx1ZSA9IGVsbS52YWx1ZTtcbiAgdmFyIG1vZGlmaWVycyA9IGVsbS5fdk1vZGlmaWVyczsgLy8gaW5qZWN0ZWQgYnkgdi1tb2RlbCBydW50aW1lXG4gIGlmIChpc0RlZihtb2RpZmllcnMpKSB7XG4gICAgaWYgKG1vZGlmaWVycy5udW1iZXIpIHtcbiAgICAgIHJldHVybiB0b051bWJlcih2YWx1ZSkgIT09IHRvTnVtYmVyKG5ld1ZhbClcbiAgICB9XG4gICAgaWYgKG1vZGlmaWVycy50cmltKSB7XG4gICAgICByZXR1cm4gdmFsdWUudHJpbSgpICE9PSBuZXdWYWwudHJpbSgpXG4gICAgfVxuICB9XG4gIHJldHVybiB2YWx1ZSAhPT0gbmV3VmFsXG59XG5cbnZhciBkb21Qcm9wcyA9IHtcbiAgY3JlYXRlOiB1cGRhdGVET01Qcm9wcyxcbiAgdXBkYXRlOiB1cGRhdGVET01Qcm9wc1xufTtcblxuLyogICovXG5cbnZhciBwYXJzZVN0eWxlVGV4dCA9IGNhY2hlZChmdW5jdGlvbiAoY3NzVGV4dCkge1xuICB2YXIgcmVzID0ge307XG4gIHZhciBsaXN0RGVsaW1pdGVyID0gLzsoPyFbXihdKlxcKSkvZztcbiAgdmFyIHByb3BlcnR5RGVsaW1pdGVyID0gLzooLispLztcbiAgY3NzVGV4dC5zcGxpdChsaXN0RGVsaW1pdGVyKS5mb3JFYWNoKGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgaWYgKGl0ZW0pIHtcbiAgICAgIHZhciB0bXAgPSBpdGVtLnNwbGl0KHByb3BlcnR5RGVsaW1pdGVyKTtcbiAgICAgIHRtcC5sZW5ndGggPiAxICYmIChyZXNbdG1wWzBdLnRyaW0oKV0gPSB0bXBbMV0udHJpbSgpKTtcbiAgICB9XG4gIH0pO1xuICByZXR1cm4gcmVzXG59KTtcblxuLy8gbWVyZ2Ugc3RhdGljIGFuZCBkeW5hbWljIHN0eWxlIGRhdGEgb24gdGhlIHNhbWUgdm5vZGVcbmZ1bmN0aW9uIG5vcm1hbGl6ZVN0eWxlRGF0YSAoZGF0YSkge1xuICB2YXIgc3R5bGUgPSBub3JtYWxpemVTdHlsZUJpbmRpbmcoZGF0YS5zdHlsZSk7XG4gIC8vIHN0YXRpYyBzdHlsZSBpcyBwcmUtcHJvY2Vzc2VkIGludG8gYW4gb2JqZWN0IGR1cmluZyBjb21waWxhdGlvblxuICAvLyBhbmQgaXMgYWx3YXlzIGEgZnJlc2ggb2JqZWN0LCBzbyBpdCdzIHNhZmUgdG8gbWVyZ2UgaW50byBpdFxuICByZXR1cm4gZGF0YS5zdGF0aWNTdHlsZVxuICAgID8gZXh0ZW5kKGRhdGEuc3RhdGljU3R5bGUsIHN0eWxlKVxuICAgIDogc3R5bGVcbn1cblxuLy8gbm9ybWFsaXplIHBvc3NpYmxlIGFycmF5IC8gc3RyaW5nIHZhbHVlcyBpbnRvIE9iamVjdFxuZnVuY3Rpb24gbm9ybWFsaXplU3R5bGVCaW5kaW5nIChiaW5kaW5nU3R5bGUpIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkoYmluZGluZ1N0eWxlKSkge1xuICAgIHJldHVybiB0b09iamVjdChiaW5kaW5nU3R5bGUpXG4gIH1cbiAgaWYgKHR5cGVvZiBiaW5kaW5nU3R5bGUgPT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIHBhcnNlU3R5bGVUZXh0KGJpbmRpbmdTdHlsZSlcbiAgfVxuICByZXR1cm4gYmluZGluZ1N0eWxlXG59XG5cbi8qKlxuICogcGFyZW50IGNvbXBvbmVudCBzdHlsZSBzaG91bGQgYmUgYWZ0ZXIgY2hpbGQnc1xuICogc28gdGhhdCBwYXJlbnQgY29tcG9uZW50J3Mgc3R5bGUgY291bGQgb3ZlcnJpZGUgaXRcbiAqL1xuZnVuY3Rpb24gZ2V0U3R5bGUgKHZub2RlLCBjaGVja0NoaWxkKSB7XG4gIHZhciByZXMgPSB7fTtcbiAgdmFyIHN0eWxlRGF0YTtcblxuICBpZiAoY2hlY2tDaGlsZCkge1xuICAgIHZhciBjaGlsZE5vZGUgPSB2bm9kZTtcbiAgICB3aGlsZSAoY2hpbGROb2RlLmNvbXBvbmVudEluc3RhbmNlKSB7XG4gICAgICBjaGlsZE5vZGUgPSBjaGlsZE5vZGUuY29tcG9uZW50SW5zdGFuY2UuX3Zub2RlO1xuICAgICAgaWYgKFxuICAgICAgICBjaGlsZE5vZGUgJiYgY2hpbGROb2RlLmRhdGEgJiZcbiAgICAgICAgKHN0eWxlRGF0YSA9IG5vcm1hbGl6ZVN0eWxlRGF0YShjaGlsZE5vZGUuZGF0YSkpXG4gICAgICApIHtcbiAgICAgICAgZXh0ZW5kKHJlcywgc3R5bGVEYXRhKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBpZiAoKHN0eWxlRGF0YSA9IG5vcm1hbGl6ZVN0eWxlRGF0YSh2bm9kZS5kYXRhKSkpIHtcbiAgICBleHRlbmQocmVzLCBzdHlsZURhdGEpO1xuICB9XG5cbiAgdmFyIHBhcmVudE5vZGUgPSB2bm9kZTtcbiAgd2hpbGUgKChwYXJlbnROb2RlID0gcGFyZW50Tm9kZS5wYXJlbnQpKSB7XG4gICAgaWYgKHBhcmVudE5vZGUuZGF0YSAmJiAoc3R5bGVEYXRhID0gbm9ybWFsaXplU3R5bGVEYXRhKHBhcmVudE5vZGUuZGF0YSkpKSB7XG4gICAgICBleHRlbmQocmVzLCBzdHlsZURhdGEpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzXG59XG5cbi8qICAqL1xuXG52YXIgY3NzVmFyUkUgPSAvXi0tLztcbnZhciBpbXBvcnRhbnRSRSA9IC9cXHMqIWltcG9ydGFudCQvO1xudmFyIHNldFByb3AgPSBmdW5jdGlvbiAoZWwsIG5hbWUsIHZhbCkge1xuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgaWYgKGNzc1ZhclJFLnRlc3QobmFtZSkpIHtcbiAgICBlbC5zdHlsZS5zZXRQcm9wZXJ0eShuYW1lLCB2YWwpO1xuICB9IGVsc2UgaWYgKGltcG9ydGFudFJFLnRlc3QodmFsKSkge1xuICAgIGVsLnN0eWxlLnNldFByb3BlcnR5KGh5cGhlbmF0ZShuYW1lKSwgdmFsLnJlcGxhY2UoaW1wb3J0YW50UkUsICcnKSwgJ2ltcG9ydGFudCcpO1xuICB9IGVsc2Uge1xuICAgIHZhciBub3JtYWxpemVkTmFtZSA9IG5vcm1hbGl6ZShuYW1lKTtcbiAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWwpKSB7XG4gICAgICAvLyBTdXBwb3J0IHZhbHVlcyBhcnJheSBjcmVhdGVkIGJ5IGF1dG9wcmVmaXhlciwgZS5nLlxuICAgICAgLy8ge2Rpc3BsYXk6IFtcIi13ZWJraXQtYm94XCIsIFwiLW1zLWZsZXhib3hcIiwgXCJmbGV4XCJdfVxuICAgICAgLy8gU2V0IHRoZW0gb25lIGJ5IG9uZSwgYW5kIHRoZSBicm93c2VyIHdpbGwgb25seSBzZXQgdGhvc2UgaXQgY2FuIHJlY29nbml6ZVxuICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IHZhbC5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICBlbC5zdHlsZVtub3JtYWxpemVkTmFtZV0gPSB2YWxbaV07XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGVsLnN0eWxlW25vcm1hbGl6ZWROYW1lXSA9IHZhbDtcbiAgICB9XG4gIH1cbn07XG5cbnZhciB2ZW5kb3JOYW1lcyA9IFsnV2Via2l0JywgJ01veicsICdtcyddO1xuXG52YXIgZW1wdHlTdHlsZTtcbnZhciBub3JtYWxpemUgPSBjYWNoZWQoZnVuY3Rpb24gKHByb3ApIHtcbiAgZW1wdHlTdHlsZSA9IGVtcHR5U3R5bGUgfHwgZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jykuc3R5bGU7XG4gIHByb3AgPSBjYW1lbGl6ZShwcm9wKTtcbiAgaWYgKHByb3AgIT09ICdmaWx0ZXInICYmIChwcm9wIGluIGVtcHR5U3R5bGUpKSB7XG4gICAgcmV0dXJuIHByb3BcbiAgfVxuICB2YXIgY2FwTmFtZSA9IHByb3AuY2hhckF0KDApLnRvVXBwZXJDYXNlKCkgKyBwcm9wLnNsaWNlKDEpO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHZlbmRvck5hbWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIG5hbWUgPSB2ZW5kb3JOYW1lc1tpXSArIGNhcE5hbWU7XG4gICAgaWYgKG5hbWUgaW4gZW1wdHlTdHlsZSkge1xuICAgICAgcmV0dXJuIG5hbWVcbiAgICB9XG4gIH1cbn0pO1xuXG5mdW5jdGlvbiB1cGRhdGVTdHlsZSAob2xkVm5vZGUsIHZub2RlKSB7XG4gIHZhciBkYXRhID0gdm5vZGUuZGF0YTtcbiAgdmFyIG9sZERhdGEgPSBvbGRWbm9kZS5kYXRhO1xuXG4gIGlmIChpc1VuZGVmKGRhdGEuc3RhdGljU3R5bGUpICYmIGlzVW5kZWYoZGF0YS5zdHlsZSkgJiZcbiAgICBpc1VuZGVmKG9sZERhdGEuc3RhdGljU3R5bGUpICYmIGlzVW5kZWYob2xkRGF0YS5zdHlsZSlcbiAgKSB7XG4gICAgcmV0dXJuXG4gIH1cblxuICB2YXIgY3VyLCBuYW1lO1xuICB2YXIgZWwgPSB2bm9kZS5lbG07XG4gIHZhciBvbGRTdGF0aWNTdHlsZSA9IG9sZERhdGEuc3RhdGljU3R5bGU7XG4gIHZhciBvbGRTdHlsZUJpbmRpbmcgPSBvbGREYXRhLm5vcm1hbGl6ZWRTdHlsZSB8fCBvbGREYXRhLnN0eWxlIHx8IHt9O1xuXG4gIC8vIGlmIHN0YXRpYyBzdHlsZSBleGlzdHMsIHN0eWxlYmluZGluZyBhbHJlYWR5IG1lcmdlZCBpbnRvIGl0IHdoZW4gZG9pbmcgbm9ybWFsaXplU3R5bGVEYXRhXG4gIHZhciBvbGRTdHlsZSA9IG9sZFN0YXRpY1N0eWxlIHx8IG9sZFN0eWxlQmluZGluZztcblxuICB2YXIgc3R5bGUgPSBub3JtYWxpemVTdHlsZUJpbmRpbmcodm5vZGUuZGF0YS5zdHlsZSkgfHwge307XG5cbiAgLy8gc3RvcmUgbm9ybWFsaXplZCBzdHlsZSB1bmRlciBhIGRpZmZlcmVudCBrZXkgZm9yIG5leHQgZGlmZlxuICAvLyBtYWtlIHN1cmUgdG8gY2xvbmUgaXQgaWYgaXQncyByZWFjdGl2ZSwgc2luY2UgdGhlIHVzZXIgbGlrZWx5IHdhbnRzXG4gIC8vIHRvIG11dGF0ZSBpdC5cbiAgdm5vZGUuZGF0YS5ub3JtYWxpemVkU3R5bGUgPSBpc0RlZihzdHlsZS5fX29iX18pXG4gICAgPyBleHRlbmQoe30sIHN0eWxlKVxuICAgIDogc3R5bGU7XG5cbiAgdmFyIG5ld1N0eWxlID0gZ2V0U3R5bGUodm5vZGUsIHRydWUpO1xuXG4gIGZvciAobmFtZSBpbiBvbGRTdHlsZSkge1xuICAgIGlmIChpc1VuZGVmKG5ld1N0eWxlW25hbWVdKSkge1xuICAgICAgc2V0UHJvcChlbCwgbmFtZSwgJycpO1xuICAgIH1cbiAgfVxuICBmb3IgKG5hbWUgaW4gbmV3U3R5bGUpIHtcbiAgICBjdXIgPSBuZXdTdHlsZVtuYW1lXTtcbiAgICBpZiAoY3VyICE9PSBvbGRTdHlsZVtuYW1lXSkge1xuICAgICAgLy8gaWU5IHNldHRpbmcgdG8gbnVsbCBoYXMgbm8gZWZmZWN0LCBtdXN0IHVzZSBlbXB0eSBzdHJpbmdcbiAgICAgIHNldFByb3AoZWwsIG5hbWUsIGN1ciA9PSBudWxsID8gJycgOiBjdXIpO1xuICAgIH1cbiAgfVxufVxuXG52YXIgc3R5bGUgPSB7XG4gIGNyZWF0ZTogdXBkYXRlU3R5bGUsXG4gIHVwZGF0ZTogdXBkYXRlU3R5bGVcbn07XG5cbi8qICAqL1xuXG52YXIgd2hpdGVzcGFjZVJFID0gL1xccysvO1xuXG4vKipcbiAqIEFkZCBjbGFzcyB3aXRoIGNvbXBhdGliaWxpdHkgZm9yIFNWRyBzaW5jZSBjbGFzc0xpc3QgaXMgbm90IHN1cHBvcnRlZCBvblxuICogU1ZHIGVsZW1lbnRzIGluIElFXG4gKi9cbmZ1bmN0aW9uIGFkZENsYXNzIChlbCwgY2xzKSB7XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICBpZiAoIWNscyB8fCAhKGNscyA9IGNscy50cmltKCkpKSB7XG4gICAgcmV0dXJuXG4gIH1cblxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICBpZiAoZWwuY2xhc3NMaXN0KSB7XG4gICAgaWYgKGNscy5pbmRleE9mKCcgJykgPiAtMSkge1xuICAgICAgY2xzLnNwbGl0KHdoaXRlc3BhY2VSRSkuZm9yRWFjaChmdW5jdGlvbiAoYykgeyByZXR1cm4gZWwuY2xhc3NMaXN0LmFkZChjKTsgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGVsLmNsYXNzTGlzdC5hZGQoY2xzKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgdmFyIGN1ciA9IFwiIFwiICsgKGVsLmdldEF0dHJpYnV0ZSgnY2xhc3MnKSB8fCAnJykgKyBcIiBcIjtcbiAgICBpZiAoY3VyLmluZGV4T2YoJyAnICsgY2xzICsgJyAnKSA8IDApIHtcbiAgICAgIGVsLnNldEF0dHJpYnV0ZSgnY2xhc3MnLCAoY3VyICsgY2xzKS50cmltKCkpO1xuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIFJlbW92ZSBjbGFzcyB3aXRoIGNvbXBhdGliaWxpdHkgZm9yIFNWRyBzaW5jZSBjbGFzc0xpc3QgaXMgbm90IHN1cHBvcnRlZCBvblxuICogU1ZHIGVsZW1lbnRzIGluIElFXG4gKi9cbmZ1bmN0aW9uIHJlbW92ZUNsYXNzIChlbCwgY2xzKSB7XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICBpZiAoIWNscyB8fCAhKGNscyA9IGNscy50cmltKCkpKSB7XG4gICAgcmV0dXJuXG4gIH1cblxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICBpZiAoZWwuY2xhc3NMaXN0KSB7XG4gICAgaWYgKGNscy5pbmRleE9mKCcgJykgPiAtMSkge1xuICAgICAgY2xzLnNwbGl0KHdoaXRlc3BhY2VSRSkuZm9yRWFjaChmdW5jdGlvbiAoYykgeyByZXR1cm4gZWwuY2xhc3NMaXN0LnJlbW92ZShjKTsgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGVsLmNsYXNzTGlzdC5yZW1vdmUoY2xzKTtcbiAgICB9XG4gICAgaWYgKCFlbC5jbGFzc0xpc3QubGVuZ3RoKSB7XG4gICAgICBlbC5yZW1vdmVBdHRyaWJ1dGUoJ2NsYXNzJyk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHZhciBjdXIgPSBcIiBcIiArIChlbC5nZXRBdHRyaWJ1dGUoJ2NsYXNzJykgfHwgJycpICsgXCIgXCI7XG4gICAgdmFyIHRhciA9ICcgJyArIGNscyArICcgJztcbiAgICB3aGlsZSAoY3VyLmluZGV4T2YodGFyKSA+PSAwKSB7XG4gICAgICBjdXIgPSBjdXIucmVwbGFjZSh0YXIsICcgJyk7XG4gICAgfVxuICAgIGN1ciA9IGN1ci50cmltKCk7XG4gICAgaWYgKGN1cikge1xuICAgICAgZWwuc2V0QXR0cmlidXRlKCdjbGFzcycsIGN1cik7XG4gICAgfSBlbHNlIHtcbiAgICAgIGVsLnJlbW92ZUF0dHJpYnV0ZSgnY2xhc3MnKTtcbiAgICB9XG4gIH1cbn1cblxuLyogICovXG5cbmZ1bmN0aW9uIHJlc29sdmVUcmFuc2l0aW9uIChkZWYkJDEpIHtcbiAgaWYgKCFkZWYkJDEpIHtcbiAgICByZXR1cm5cbiAgfVxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICBpZiAodHlwZW9mIGRlZiQkMSA9PT0gJ29iamVjdCcpIHtcbiAgICB2YXIgcmVzID0ge307XG4gICAgaWYgKGRlZiQkMS5jc3MgIT09IGZhbHNlKSB7XG4gICAgICBleHRlbmQocmVzLCBhdXRvQ3NzVHJhbnNpdGlvbihkZWYkJDEubmFtZSB8fCAndicpKTtcbiAgICB9XG4gICAgZXh0ZW5kKHJlcywgZGVmJCQxKTtcbiAgICByZXR1cm4gcmVzXG4gIH0gZWxzZSBpZiAodHlwZW9mIGRlZiQkMSA9PT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gYXV0b0Nzc1RyYW5zaXRpb24oZGVmJCQxKVxuICB9XG59XG5cbnZhciBhdXRvQ3NzVHJhbnNpdGlvbiA9IGNhY2hlZChmdW5jdGlvbiAobmFtZSkge1xuICByZXR1cm4ge1xuICAgIGVudGVyQ2xhc3M6IChuYW1lICsgXCItZW50ZXJcIiksXG4gICAgZW50ZXJUb0NsYXNzOiAobmFtZSArIFwiLWVudGVyLXRvXCIpLFxuICAgIGVudGVyQWN0aXZlQ2xhc3M6IChuYW1lICsgXCItZW50ZXItYWN0aXZlXCIpLFxuICAgIGxlYXZlQ2xhc3M6IChuYW1lICsgXCItbGVhdmVcIiksXG4gICAgbGVhdmVUb0NsYXNzOiAobmFtZSArIFwiLWxlYXZlLXRvXCIpLFxuICAgIGxlYXZlQWN0aXZlQ2xhc3M6IChuYW1lICsgXCItbGVhdmUtYWN0aXZlXCIpXG4gIH1cbn0pO1xuXG52YXIgaGFzVHJhbnNpdGlvbiA9IGluQnJvd3NlciAmJiAhaXNJRTk7XG52YXIgVFJBTlNJVElPTiA9ICd0cmFuc2l0aW9uJztcbnZhciBBTklNQVRJT04gPSAnYW5pbWF0aW9uJztcblxuLy8gVHJhbnNpdGlvbiBwcm9wZXJ0eS9ldmVudCBzbmlmZmluZ1xudmFyIHRyYW5zaXRpb25Qcm9wID0gJ3RyYW5zaXRpb24nO1xudmFyIHRyYW5zaXRpb25FbmRFdmVudCA9ICd0cmFuc2l0aW9uZW5kJztcbnZhciBhbmltYXRpb25Qcm9wID0gJ2FuaW1hdGlvbic7XG52YXIgYW5pbWF0aW9uRW5kRXZlbnQgPSAnYW5pbWF0aW9uZW5kJztcbmlmIChoYXNUcmFuc2l0aW9uKSB7XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICBpZiAod2luZG93Lm9udHJhbnNpdGlvbmVuZCA9PT0gdW5kZWZpbmVkICYmXG4gICAgd2luZG93Lm9ud2Via2l0dHJhbnNpdGlvbmVuZCAhPT0gdW5kZWZpbmVkXG4gICkge1xuICAgIHRyYW5zaXRpb25Qcm9wID0gJ1dlYmtpdFRyYW5zaXRpb24nO1xuICAgIHRyYW5zaXRpb25FbmRFdmVudCA9ICd3ZWJraXRUcmFuc2l0aW9uRW5kJztcbiAgfVxuICBpZiAod2luZG93Lm9uYW5pbWF0aW9uZW5kID09PSB1bmRlZmluZWQgJiZcbiAgICB3aW5kb3cub253ZWJraXRhbmltYXRpb25lbmQgIT09IHVuZGVmaW5lZFxuICApIHtcbiAgICBhbmltYXRpb25Qcm9wID0gJ1dlYmtpdEFuaW1hdGlvbic7XG4gICAgYW5pbWF0aW9uRW5kRXZlbnQgPSAnd2Via2l0QW5pbWF0aW9uRW5kJztcbiAgfVxufVxuXG4vLyBiaW5kaW5nIHRvIHdpbmRvdyBpcyBuZWNlc3NhcnkgdG8gbWFrZSBob3QgcmVsb2FkIHdvcmsgaW4gSUUgaW4gc3RyaWN0IG1vZGVcbnZhciByYWYgPSBpbkJyb3dzZXJcbiAgPyB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lXG4gICAgPyB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lLmJpbmQod2luZG93KVxuICAgIDogc2V0VGltZW91dFxuICA6IC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovIGZ1bmN0aW9uIChmbikgeyByZXR1cm4gZm4oKTsgfTtcblxuZnVuY3Rpb24gbmV4dEZyYW1lIChmbikge1xuICByYWYoZnVuY3Rpb24gKCkge1xuICAgIHJhZihmbik7XG4gIH0pO1xufVxuXG5mdW5jdGlvbiBhZGRUcmFuc2l0aW9uQ2xhc3MgKGVsLCBjbHMpIHtcbiAgdmFyIHRyYW5zaXRpb25DbGFzc2VzID0gZWwuX3RyYW5zaXRpb25DbGFzc2VzIHx8IChlbC5fdHJhbnNpdGlvbkNsYXNzZXMgPSBbXSk7XG4gIGlmICh0cmFuc2l0aW9uQ2xhc3Nlcy5pbmRleE9mKGNscykgPCAwKSB7XG4gICAgdHJhbnNpdGlvbkNsYXNzZXMucHVzaChjbHMpO1xuICAgIGFkZENsYXNzKGVsLCBjbHMpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHJlbW92ZVRyYW5zaXRpb25DbGFzcyAoZWwsIGNscykge1xuICBpZiAoZWwuX3RyYW5zaXRpb25DbGFzc2VzKSB7XG4gICAgcmVtb3ZlKGVsLl90cmFuc2l0aW9uQ2xhc3NlcywgY2xzKTtcbiAgfVxuICByZW1vdmVDbGFzcyhlbCwgY2xzKTtcbn1cblxuZnVuY3Rpb24gd2hlblRyYW5zaXRpb25FbmRzIChcbiAgZWwsXG4gIGV4cGVjdGVkVHlwZSxcbiAgY2Jcbikge1xuICB2YXIgcmVmID0gZ2V0VHJhbnNpdGlvbkluZm8oZWwsIGV4cGVjdGVkVHlwZSk7XG4gIHZhciB0eXBlID0gcmVmLnR5cGU7XG4gIHZhciB0aW1lb3V0ID0gcmVmLnRpbWVvdXQ7XG4gIHZhciBwcm9wQ291bnQgPSByZWYucHJvcENvdW50O1xuICBpZiAoIXR5cGUpIHsgcmV0dXJuIGNiKCkgfVxuICB2YXIgZXZlbnQgPSB0eXBlID09PSBUUkFOU0lUSU9OID8gdHJhbnNpdGlvbkVuZEV2ZW50IDogYW5pbWF0aW9uRW5kRXZlbnQ7XG4gIHZhciBlbmRlZCA9IDA7XG4gIHZhciBlbmQgPSBmdW5jdGlvbiAoKSB7XG4gICAgZWwucmVtb3ZlRXZlbnRMaXN0ZW5lcihldmVudCwgb25FbmQpO1xuICAgIGNiKCk7XG4gIH07XG4gIHZhciBvbkVuZCA9IGZ1bmN0aW9uIChlKSB7XG4gICAgaWYgKGUudGFyZ2V0ID09PSBlbCkge1xuICAgICAgaWYgKCsrZW5kZWQgPj0gcHJvcENvdW50KSB7XG4gICAgICAgIGVuZCgpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcbiAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgaWYgKGVuZGVkIDwgcHJvcENvdW50KSB7XG4gICAgICBlbmQoKTtcbiAgICB9XG4gIH0sIHRpbWVvdXQgKyAxKTtcbiAgZWwuYWRkRXZlbnRMaXN0ZW5lcihldmVudCwgb25FbmQpO1xufVxuXG52YXIgdHJhbnNmb3JtUkUgPSAvXFxiKHRyYW5zZm9ybXxhbGwpKCx8JCkvO1xuXG5mdW5jdGlvbiBnZXRUcmFuc2l0aW9uSW5mbyAoZWwsIGV4cGVjdGVkVHlwZSkge1xuICB2YXIgc3R5bGVzID0gd2luZG93LmdldENvbXB1dGVkU3R5bGUoZWwpO1xuICAvLyBKU0RPTSBtYXkgcmV0dXJuIHVuZGVmaW5lZCBmb3IgdHJhbnNpdGlvbiBwcm9wZXJ0aWVzXG4gIHZhciB0cmFuc2l0aW9uRGVsYXlzID0gKHN0eWxlc1t0cmFuc2l0aW9uUHJvcCArICdEZWxheSddIHx8ICcnKS5zcGxpdCgnLCAnKTtcbiAgdmFyIHRyYW5zaXRpb25EdXJhdGlvbnMgPSAoc3R5bGVzW3RyYW5zaXRpb25Qcm9wICsgJ0R1cmF0aW9uJ10gfHwgJycpLnNwbGl0KCcsICcpO1xuICB2YXIgdHJhbnNpdGlvblRpbWVvdXQgPSBnZXRUaW1lb3V0KHRyYW5zaXRpb25EZWxheXMsIHRyYW5zaXRpb25EdXJhdGlvbnMpO1xuICB2YXIgYW5pbWF0aW9uRGVsYXlzID0gKHN0eWxlc1thbmltYXRpb25Qcm9wICsgJ0RlbGF5J10gfHwgJycpLnNwbGl0KCcsICcpO1xuICB2YXIgYW5pbWF0aW9uRHVyYXRpb25zID0gKHN0eWxlc1thbmltYXRpb25Qcm9wICsgJ0R1cmF0aW9uJ10gfHwgJycpLnNwbGl0KCcsICcpO1xuICB2YXIgYW5pbWF0aW9uVGltZW91dCA9IGdldFRpbWVvdXQoYW5pbWF0aW9uRGVsYXlzLCBhbmltYXRpb25EdXJhdGlvbnMpO1xuXG4gIHZhciB0eXBlO1xuICB2YXIgdGltZW91dCA9IDA7XG4gIHZhciBwcm9wQ291bnQgPSAwO1xuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgaWYgKGV4cGVjdGVkVHlwZSA9PT0gVFJBTlNJVElPTikge1xuICAgIGlmICh0cmFuc2l0aW9uVGltZW91dCA+IDApIHtcbiAgICAgIHR5cGUgPSBUUkFOU0lUSU9OO1xuICAgICAgdGltZW91dCA9IHRyYW5zaXRpb25UaW1lb3V0O1xuICAgICAgcHJvcENvdW50ID0gdHJhbnNpdGlvbkR1cmF0aW9ucy5sZW5ndGg7XG4gICAgfVxuICB9IGVsc2UgaWYgKGV4cGVjdGVkVHlwZSA9PT0gQU5JTUFUSU9OKSB7XG4gICAgaWYgKGFuaW1hdGlvblRpbWVvdXQgPiAwKSB7XG4gICAgICB0eXBlID0gQU5JTUFUSU9OO1xuICAgICAgdGltZW91dCA9IGFuaW1hdGlvblRpbWVvdXQ7XG4gICAgICBwcm9wQ291bnQgPSBhbmltYXRpb25EdXJhdGlvbnMubGVuZ3RoO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB0aW1lb3V0ID0gTWF0aC5tYXgodHJhbnNpdGlvblRpbWVvdXQsIGFuaW1hdGlvblRpbWVvdXQpO1xuICAgIHR5cGUgPSB0aW1lb3V0ID4gMFxuICAgICAgPyB0cmFuc2l0aW9uVGltZW91dCA+IGFuaW1hdGlvblRpbWVvdXRcbiAgICAgICAgPyBUUkFOU0lUSU9OXG4gICAgICAgIDogQU5JTUFUSU9OXG4gICAgICA6IG51bGw7XG4gICAgcHJvcENvdW50ID0gdHlwZVxuICAgICAgPyB0eXBlID09PSBUUkFOU0lUSU9OXG4gICAgICAgID8gdHJhbnNpdGlvbkR1cmF0aW9ucy5sZW5ndGhcbiAgICAgICAgOiBhbmltYXRpb25EdXJhdGlvbnMubGVuZ3RoXG4gICAgICA6IDA7XG4gIH1cbiAgdmFyIGhhc1RyYW5zZm9ybSA9XG4gICAgdHlwZSA9PT0gVFJBTlNJVElPTiAmJlxuICAgIHRyYW5zZm9ybVJFLnRlc3Qoc3R5bGVzW3RyYW5zaXRpb25Qcm9wICsgJ1Byb3BlcnR5J10pO1xuICByZXR1cm4ge1xuICAgIHR5cGU6IHR5cGUsXG4gICAgdGltZW91dDogdGltZW91dCxcbiAgICBwcm9wQ291bnQ6IHByb3BDb3VudCxcbiAgICBoYXNUcmFuc2Zvcm06IGhhc1RyYW5zZm9ybVxuICB9XG59XG5cbmZ1bmN0aW9uIGdldFRpbWVvdXQgKGRlbGF5cywgZHVyYXRpb25zKSB7XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gIHdoaWxlIChkZWxheXMubGVuZ3RoIDwgZHVyYXRpb25zLmxlbmd0aCkge1xuICAgIGRlbGF5cyA9IGRlbGF5cy5jb25jYXQoZGVsYXlzKTtcbiAgfVxuXG4gIHJldHVybiBNYXRoLm1heC5hcHBseShudWxsLCBkdXJhdGlvbnMubWFwKGZ1bmN0aW9uIChkLCBpKSB7XG4gICAgcmV0dXJuIHRvTXMoZCkgKyB0b01zKGRlbGF5c1tpXSlcbiAgfSkpXG59XG5cbi8vIE9sZCB2ZXJzaW9ucyBvZiBDaHJvbWl1bSAoYmVsb3cgNjEuMC4zMTYzLjEwMCkgZm9ybWF0cyBmbG9hdGluZyBwb2ludGVyIG51bWJlcnNcbi8vIGluIGEgbG9jYWxlLWRlcGVuZGVudCB3YXksIHVzaW5nIGEgY29tbWEgaW5zdGVhZCBvZiBhIGRvdC5cbi8vIElmIGNvbW1hIGlzIG5vdCByZXBsYWNlZCB3aXRoIGEgZG90LCB0aGUgaW5wdXQgd2lsbCBiZSByb3VuZGVkIGRvd24gKGkuZS4gYWN0aW5nXG4vLyBhcyBhIGZsb29yIGZ1bmN0aW9uKSBjYXVzaW5nIHVuZXhwZWN0ZWQgYmVoYXZpb3JzXG5mdW5jdGlvbiB0b01zIChzKSB7XG4gIHJldHVybiBOdW1iZXIocy5zbGljZSgwLCAtMSkucmVwbGFjZSgnLCcsICcuJykpICogMTAwMFxufVxuXG4vKiAgKi9cblxuZnVuY3Rpb24gZW50ZXIgKHZub2RlLCB0b2dnbGVEaXNwbGF5KSB7XG4gIHZhciBlbCA9IHZub2RlLmVsbTtcblxuICAvLyBjYWxsIGxlYXZlIGNhbGxiYWNrIG5vd1xuICBpZiAoaXNEZWYoZWwuX2xlYXZlQ2IpKSB7XG4gICAgZWwuX2xlYXZlQ2IuY2FuY2VsbGVkID0gdHJ1ZTtcbiAgICBlbC5fbGVhdmVDYigpO1xuICB9XG5cbiAgdmFyIGRhdGEgPSByZXNvbHZlVHJhbnNpdGlvbih2bm9kZS5kYXRhLnRyYW5zaXRpb24pO1xuICBpZiAoaXNVbmRlZihkYXRhKSkge1xuICAgIHJldHVyblxuICB9XG5cbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gIGlmIChpc0RlZihlbC5fZW50ZXJDYikgfHwgZWwubm9kZVR5cGUgIT09IDEpIHtcbiAgICByZXR1cm5cbiAgfVxuXG4gIHZhciBjc3MgPSBkYXRhLmNzcztcbiAgdmFyIHR5cGUgPSBkYXRhLnR5cGU7XG4gIHZhciBlbnRlckNsYXNzID0gZGF0YS5lbnRlckNsYXNzO1xuICB2YXIgZW50ZXJUb0NsYXNzID0gZGF0YS5lbnRlclRvQ2xhc3M7XG4gIHZhciBlbnRlckFjdGl2ZUNsYXNzID0gZGF0YS5lbnRlckFjdGl2ZUNsYXNzO1xuICB2YXIgYXBwZWFyQ2xhc3MgPSBkYXRhLmFwcGVhckNsYXNzO1xuICB2YXIgYXBwZWFyVG9DbGFzcyA9IGRhdGEuYXBwZWFyVG9DbGFzcztcbiAgdmFyIGFwcGVhckFjdGl2ZUNsYXNzID0gZGF0YS5hcHBlYXJBY3RpdmVDbGFzcztcbiAgdmFyIGJlZm9yZUVudGVyID0gZGF0YS5iZWZvcmVFbnRlcjtcbiAgdmFyIGVudGVyID0gZGF0YS5lbnRlcjtcbiAgdmFyIGFmdGVyRW50ZXIgPSBkYXRhLmFmdGVyRW50ZXI7XG4gIHZhciBlbnRlckNhbmNlbGxlZCA9IGRhdGEuZW50ZXJDYW5jZWxsZWQ7XG4gIHZhciBiZWZvcmVBcHBlYXIgPSBkYXRhLmJlZm9yZUFwcGVhcjtcbiAgdmFyIGFwcGVhciA9IGRhdGEuYXBwZWFyO1xuICB2YXIgYWZ0ZXJBcHBlYXIgPSBkYXRhLmFmdGVyQXBwZWFyO1xuICB2YXIgYXBwZWFyQ2FuY2VsbGVkID0gZGF0YS5hcHBlYXJDYW5jZWxsZWQ7XG4gIHZhciBkdXJhdGlvbiA9IGRhdGEuZHVyYXRpb247XG5cbiAgLy8gYWN0aXZlSW5zdGFuY2Ugd2lsbCBhbHdheXMgYmUgdGhlIDx0cmFuc2l0aW9uPiBjb21wb25lbnQgbWFuYWdpbmcgdGhpc1xuICAvLyB0cmFuc2l0aW9uLiBPbmUgZWRnZSBjYXNlIHRvIGNoZWNrIGlzIHdoZW4gdGhlIDx0cmFuc2l0aW9uPiBpcyBwbGFjZWRcbiAgLy8gYXMgdGhlIHJvb3Qgbm9kZSBvZiBhIGNoaWxkIGNvbXBvbmVudC4gSW4gdGhhdCBjYXNlIHdlIG5lZWQgdG8gY2hlY2tcbiAgLy8gPHRyYW5zaXRpb24+J3MgcGFyZW50IGZvciBhcHBlYXIgY2hlY2suXG4gIHZhciBjb250ZXh0ID0gYWN0aXZlSW5zdGFuY2U7XG4gIHZhciB0cmFuc2l0aW9uTm9kZSA9IGFjdGl2ZUluc3RhbmNlLiR2bm9kZTtcbiAgd2hpbGUgKHRyYW5zaXRpb25Ob2RlICYmIHRyYW5zaXRpb25Ob2RlLnBhcmVudCkge1xuICAgIGNvbnRleHQgPSB0cmFuc2l0aW9uTm9kZS5jb250ZXh0O1xuICAgIHRyYW5zaXRpb25Ob2RlID0gdHJhbnNpdGlvbk5vZGUucGFyZW50O1xuICB9XG5cbiAgdmFyIGlzQXBwZWFyID0gIWNvbnRleHQuX2lzTW91bnRlZCB8fCAhdm5vZGUuaXNSb290SW5zZXJ0O1xuXG4gIGlmIChpc0FwcGVhciAmJiAhYXBwZWFyICYmIGFwcGVhciAhPT0gJycpIHtcbiAgICByZXR1cm5cbiAgfVxuXG4gIHZhciBzdGFydENsYXNzID0gaXNBcHBlYXIgJiYgYXBwZWFyQ2xhc3NcbiAgICA/IGFwcGVhckNsYXNzXG4gICAgOiBlbnRlckNsYXNzO1xuICB2YXIgYWN0aXZlQ2xhc3MgPSBpc0FwcGVhciAmJiBhcHBlYXJBY3RpdmVDbGFzc1xuICAgID8gYXBwZWFyQWN0aXZlQ2xhc3NcbiAgICA6IGVudGVyQWN0aXZlQ2xhc3M7XG4gIHZhciB0b0NsYXNzID0gaXNBcHBlYXIgJiYgYXBwZWFyVG9DbGFzc1xuICAgID8gYXBwZWFyVG9DbGFzc1xuICAgIDogZW50ZXJUb0NsYXNzO1xuXG4gIHZhciBiZWZvcmVFbnRlckhvb2sgPSBpc0FwcGVhclxuICAgID8gKGJlZm9yZUFwcGVhciB8fCBiZWZvcmVFbnRlcilcbiAgICA6IGJlZm9yZUVudGVyO1xuICB2YXIgZW50ZXJIb29rID0gaXNBcHBlYXJcbiAgICA/ICh0eXBlb2YgYXBwZWFyID09PSAnZnVuY3Rpb24nID8gYXBwZWFyIDogZW50ZXIpXG4gICAgOiBlbnRlcjtcbiAgdmFyIGFmdGVyRW50ZXJIb29rID0gaXNBcHBlYXJcbiAgICA/IChhZnRlckFwcGVhciB8fCBhZnRlckVudGVyKVxuICAgIDogYWZ0ZXJFbnRlcjtcbiAgdmFyIGVudGVyQ2FuY2VsbGVkSG9vayA9IGlzQXBwZWFyXG4gICAgPyAoYXBwZWFyQ2FuY2VsbGVkIHx8IGVudGVyQ2FuY2VsbGVkKVxuICAgIDogZW50ZXJDYW5jZWxsZWQ7XG5cbiAgdmFyIGV4cGxpY2l0RW50ZXJEdXJhdGlvbiA9IHRvTnVtYmVyKFxuICAgIGlzT2JqZWN0KGR1cmF0aW9uKVxuICAgICAgPyBkdXJhdGlvbi5lbnRlclxuICAgICAgOiBkdXJhdGlvblxuICApO1xuXG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIGV4cGxpY2l0RW50ZXJEdXJhdGlvbiAhPSBudWxsKSB7XG4gICAgY2hlY2tEdXJhdGlvbihleHBsaWNpdEVudGVyRHVyYXRpb24sICdlbnRlcicsIHZub2RlKTtcbiAgfVxuXG4gIHZhciBleHBlY3RzQ1NTID0gY3NzICE9PSBmYWxzZSAmJiAhaXNJRTk7XG4gIHZhciB1c2VyV2FudHNDb250cm9sID0gZ2V0SG9va0FyZ3VtZW50c0xlbmd0aChlbnRlckhvb2spO1xuXG4gIHZhciBjYiA9IGVsLl9lbnRlckNiID0gb25jZShmdW5jdGlvbiAoKSB7XG4gICAgaWYgKGV4cGVjdHNDU1MpIHtcbiAgICAgIHJlbW92ZVRyYW5zaXRpb25DbGFzcyhlbCwgdG9DbGFzcyk7XG4gICAgICByZW1vdmVUcmFuc2l0aW9uQ2xhc3MoZWwsIGFjdGl2ZUNsYXNzKTtcbiAgICB9XG4gICAgaWYgKGNiLmNhbmNlbGxlZCkge1xuICAgICAgaWYgKGV4cGVjdHNDU1MpIHtcbiAgICAgICAgcmVtb3ZlVHJhbnNpdGlvbkNsYXNzKGVsLCBzdGFydENsYXNzKTtcbiAgICAgIH1cbiAgICAgIGVudGVyQ2FuY2VsbGVkSG9vayAmJiBlbnRlckNhbmNlbGxlZEhvb2soZWwpO1xuICAgIH0gZWxzZSB7XG4gICAgICBhZnRlckVudGVySG9vayAmJiBhZnRlckVudGVySG9vayhlbCk7XG4gICAgfVxuICAgIGVsLl9lbnRlckNiID0gbnVsbDtcbiAgfSk7XG5cbiAgaWYgKCF2bm9kZS5kYXRhLnNob3cpIHtcbiAgICAvLyByZW1vdmUgcGVuZGluZyBsZWF2ZSBlbGVtZW50IG9uIGVudGVyIGJ5IGluamVjdGluZyBhbiBpbnNlcnQgaG9va1xuICAgIG1lcmdlVk5vZGVIb29rKHZub2RlLCAnaW5zZXJ0JywgZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIHBhcmVudCA9IGVsLnBhcmVudE5vZGU7XG4gICAgICB2YXIgcGVuZGluZ05vZGUgPSBwYXJlbnQgJiYgcGFyZW50Ll9wZW5kaW5nICYmIHBhcmVudC5fcGVuZGluZ1t2bm9kZS5rZXldO1xuICAgICAgaWYgKHBlbmRpbmdOb2RlICYmXG4gICAgICAgIHBlbmRpbmdOb2RlLnRhZyA9PT0gdm5vZGUudGFnICYmXG4gICAgICAgIHBlbmRpbmdOb2RlLmVsbS5fbGVhdmVDYlxuICAgICAgKSB7XG4gICAgICAgIHBlbmRpbmdOb2RlLmVsbS5fbGVhdmVDYigpO1xuICAgICAgfVxuICAgICAgZW50ZXJIb29rICYmIGVudGVySG9vayhlbCwgY2IpO1xuICAgIH0pO1xuICB9XG5cbiAgLy8gc3RhcnQgZW50ZXIgdHJhbnNpdGlvblxuICBiZWZvcmVFbnRlckhvb2sgJiYgYmVmb3JlRW50ZXJIb29rKGVsKTtcbiAgaWYgKGV4cGVjdHNDU1MpIHtcbiAgICBhZGRUcmFuc2l0aW9uQ2xhc3MoZWwsIHN0YXJ0Q2xhc3MpO1xuICAgIGFkZFRyYW5zaXRpb25DbGFzcyhlbCwgYWN0aXZlQ2xhc3MpO1xuICAgIG5leHRGcmFtZShmdW5jdGlvbiAoKSB7XG4gICAgICByZW1vdmVUcmFuc2l0aW9uQ2xhc3MoZWwsIHN0YXJ0Q2xhc3MpO1xuICAgICAgaWYgKCFjYi5jYW5jZWxsZWQpIHtcbiAgICAgICAgYWRkVHJhbnNpdGlvbkNsYXNzKGVsLCB0b0NsYXNzKTtcbiAgICAgICAgaWYgKCF1c2VyV2FudHNDb250cm9sKSB7XG4gICAgICAgICAgaWYgKGlzVmFsaWREdXJhdGlvbihleHBsaWNpdEVudGVyRHVyYXRpb24pKSB7XG4gICAgICAgICAgICBzZXRUaW1lb3V0KGNiLCBleHBsaWNpdEVudGVyRHVyYXRpb24pO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB3aGVuVHJhbnNpdGlvbkVuZHMoZWwsIHR5cGUsIGNiKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIGlmICh2bm9kZS5kYXRhLnNob3cpIHtcbiAgICB0b2dnbGVEaXNwbGF5ICYmIHRvZ2dsZURpc3BsYXkoKTtcbiAgICBlbnRlckhvb2sgJiYgZW50ZXJIb29rKGVsLCBjYik7XG4gIH1cblxuICBpZiAoIWV4cGVjdHNDU1MgJiYgIXVzZXJXYW50c0NvbnRyb2wpIHtcbiAgICBjYigpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGxlYXZlICh2bm9kZSwgcm0pIHtcbiAgdmFyIGVsID0gdm5vZGUuZWxtO1xuXG4gIC8vIGNhbGwgZW50ZXIgY2FsbGJhY2sgbm93XG4gIGlmIChpc0RlZihlbC5fZW50ZXJDYikpIHtcbiAgICBlbC5fZW50ZXJDYi5jYW5jZWxsZWQgPSB0cnVlO1xuICAgIGVsLl9lbnRlckNiKCk7XG4gIH1cblxuICB2YXIgZGF0YSA9IHJlc29sdmVUcmFuc2l0aW9uKHZub2RlLmRhdGEudHJhbnNpdGlvbik7XG4gIGlmIChpc1VuZGVmKGRhdGEpIHx8IGVsLm5vZGVUeXBlICE9PSAxKSB7XG4gICAgcmV0dXJuIHJtKClcbiAgfVxuXG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICBpZiAoaXNEZWYoZWwuX2xlYXZlQ2IpKSB7XG4gICAgcmV0dXJuXG4gIH1cblxuICB2YXIgY3NzID0gZGF0YS5jc3M7XG4gIHZhciB0eXBlID0gZGF0YS50eXBlO1xuICB2YXIgbGVhdmVDbGFzcyA9IGRhdGEubGVhdmVDbGFzcztcbiAgdmFyIGxlYXZlVG9DbGFzcyA9IGRhdGEubGVhdmVUb0NsYXNzO1xuICB2YXIgbGVhdmVBY3RpdmVDbGFzcyA9IGRhdGEubGVhdmVBY3RpdmVDbGFzcztcbiAgdmFyIGJlZm9yZUxlYXZlID0gZGF0YS5iZWZvcmVMZWF2ZTtcbiAgdmFyIGxlYXZlID0gZGF0YS5sZWF2ZTtcbiAgdmFyIGFmdGVyTGVhdmUgPSBkYXRhLmFmdGVyTGVhdmU7XG4gIHZhciBsZWF2ZUNhbmNlbGxlZCA9IGRhdGEubGVhdmVDYW5jZWxsZWQ7XG4gIHZhciBkZWxheUxlYXZlID0gZGF0YS5kZWxheUxlYXZlO1xuICB2YXIgZHVyYXRpb24gPSBkYXRhLmR1cmF0aW9uO1xuXG4gIHZhciBleHBlY3RzQ1NTID0gY3NzICE9PSBmYWxzZSAmJiAhaXNJRTk7XG4gIHZhciB1c2VyV2FudHNDb250cm9sID0gZ2V0SG9va0FyZ3VtZW50c0xlbmd0aChsZWF2ZSk7XG5cbiAgdmFyIGV4cGxpY2l0TGVhdmVEdXJhdGlvbiA9IHRvTnVtYmVyKFxuICAgIGlzT2JqZWN0KGR1cmF0aW9uKVxuICAgICAgPyBkdXJhdGlvbi5sZWF2ZVxuICAgICAgOiBkdXJhdGlvblxuICApO1xuXG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIGlzRGVmKGV4cGxpY2l0TGVhdmVEdXJhdGlvbikpIHtcbiAgICBjaGVja0R1cmF0aW9uKGV4cGxpY2l0TGVhdmVEdXJhdGlvbiwgJ2xlYXZlJywgdm5vZGUpO1xuICB9XG5cbiAgdmFyIGNiID0gZWwuX2xlYXZlQ2IgPSBvbmNlKGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoZWwucGFyZW50Tm9kZSAmJiBlbC5wYXJlbnROb2RlLl9wZW5kaW5nKSB7XG4gICAgICBlbC5wYXJlbnROb2RlLl9wZW5kaW5nW3Zub2RlLmtleV0gPSBudWxsO1xuICAgIH1cbiAgICBpZiAoZXhwZWN0c0NTUykge1xuICAgICAgcmVtb3ZlVHJhbnNpdGlvbkNsYXNzKGVsLCBsZWF2ZVRvQ2xhc3MpO1xuICAgICAgcmVtb3ZlVHJhbnNpdGlvbkNsYXNzKGVsLCBsZWF2ZUFjdGl2ZUNsYXNzKTtcbiAgICB9XG4gICAgaWYgKGNiLmNhbmNlbGxlZCkge1xuICAgICAgaWYgKGV4cGVjdHNDU1MpIHtcbiAgICAgICAgcmVtb3ZlVHJhbnNpdGlvbkNsYXNzKGVsLCBsZWF2ZUNsYXNzKTtcbiAgICAgIH1cbiAgICAgIGxlYXZlQ2FuY2VsbGVkICYmIGxlYXZlQ2FuY2VsbGVkKGVsKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcm0oKTtcbiAgICAgIGFmdGVyTGVhdmUgJiYgYWZ0ZXJMZWF2ZShlbCk7XG4gICAgfVxuICAgIGVsLl9sZWF2ZUNiID0gbnVsbDtcbiAgfSk7XG5cbiAgaWYgKGRlbGF5TGVhdmUpIHtcbiAgICBkZWxheUxlYXZlKHBlcmZvcm1MZWF2ZSk7XG4gIH0gZWxzZSB7XG4gICAgcGVyZm9ybUxlYXZlKCk7XG4gIH1cblxuICBmdW5jdGlvbiBwZXJmb3JtTGVhdmUgKCkge1xuICAgIC8vIHRoZSBkZWxheWVkIGxlYXZlIG1heSBoYXZlIGFscmVhZHkgYmVlbiBjYW5jZWxsZWRcbiAgICBpZiAoY2IuY2FuY2VsbGVkKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG4gICAgLy8gcmVjb3JkIGxlYXZpbmcgZWxlbWVudFxuICAgIGlmICghdm5vZGUuZGF0YS5zaG93ICYmIGVsLnBhcmVudE5vZGUpIHtcbiAgICAgIChlbC5wYXJlbnROb2RlLl9wZW5kaW5nIHx8IChlbC5wYXJlbnROb2RlLl9wZW5kaW5nID0ge30pKVsodm5vZGUua2V5KV0gPSB2bm9kZTtcbiAgICB9XG4gICAgYmVmb3JlTGVhdmUgJiYgYmVmb3JlTGVhdmUoZWwpO1xuICAgIGlmIChleHBlY3RzQ1NTKSB7XG4gICAgICBhZGRUcmFuc2l0aW9uQ2xhc3MoZWwsIGxlYXZlQ2xhc3MpO1xuICAgICAgYWRkVHJhbnNpdGlvbkNsYXNzKGVsLCBsZWF2ZUFjdGl2ZUNsYXNzKTtcbiAgICAgIG5leHRGcmFtZShmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJlbW92ZVRyYW5zaXRpb25DbGFzcyhlbCwgbGVhdmVDbGFzcyk7XG4gICAgICAgIGlmICghY2IuY2FuY2VsbGVkKSB7XG4gICAgICAgICAgYWRkVHJhbnNpdGlvbkNsYXNzKGVsLCBsZWF2ZVRvQ2xhc3MpO1xuICAgICAgICAgIGlmICghdXNlcldhbnRzQ29udHJvbCkge1xuICAgICAgICAgICAgaWYgKGlzVmFsaWREdXJhdGlvbihleHBsaWNpdExlYXZlRHVyYXRpb24pKSB7XG4gICAgICAgICAgICAgIHNldFRpbWVvdXQoY2IsIGV4cGxpY2l0TGVhdmVEdXJhdGlvbik7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICB3aGVuVHJhbnNpdGlvbkVuZHMoZWwsIHR5cGUsIGNiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgICBsZWF2ZSAmJiBsZWF2ZShlbCwgY2IpO1xuICAgIGlmICghZXhwZWN0c0NTUyAmJiAhdXNlcldhbnRzQ29udHJvbCkge1xuICAgICAgY2IoKTtcbiAgICB9XG4gIH1cbn1cblxuLy8gb25seSB1c2VkIGluIGRldiBtb2RlXG5mdW5jdGlvbiBjaGVja0R1cmF0aW9uICh2YWwsIG5hbWUsIHZub2RlKSB7XG4gIGlmICh0eXBlb2YgdmFsICE9PSAnbnVtYmVyJykge1xuICAgIHdhcm4oXG4gICAgICBcIjx0cmFuc2l0aW9uPiBleHBsaWNpdCBcIiArIG5hbWUgKyBcIiBkdXJhdGlvbiBpcyBub3QgYSB2YWxpZCBudW1iZXIgLSBcIiArXG4gICAgICBcImdvdCBcIiArIChKU09OLnN0cmluZ2lmeSh2YWwpKSArIFwiLlwiLFxuICAgICAgdm5vZGUuY29udGV4dFxuICAgICk7XG4gIH0gZWxzZSBpZiAoaXNOYU4odmFsKSkge1xuICAgIHdhcm4oXG4gICAgICBcIjx0cmFuc2l0aW9uPiBleHBsaWNpdCBcIiArIG5hbWUgKyBcIiBkdXJhdGlvbiBpcyBOYU4gLSBcIiArXG4gICAgICAndGhlIGR1cmF0aW9uIGV4cHJlc3Npb24gbWlnaHQgYmUgaW5jb3JyZWN0LicsXG4gICAgICB2bm9kZS5jb250ZXh0XG4gICAgKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBpc1ZhbGlkRHVyYXRpb24gKHZhbCkge1xuICByZXR1cm4gdHlwZW9mIHZhbCA9PT0gJ251bWJlcicgJiYgIWlzTmFOKHZhbClcbn1cblxuLyoqXG4gKiBOb3JtYWxpemUgYSB0cmFuc2l0aW9uIGhvb2sncyBhcmd1bWVudCBsZW5ndGguIFRoZSBob29rIG1heSBiZTpcbiAqIC0gYSBtZXJnZWQgaG9vayAoaW52b2tlcikgd2l0aCB0aGUgb3JpZ2luYWwgaW4gLmZuc1xuICogLSBhIHdyYXBwZWQgY29tcG9uZW50IG1ldGhvZCAoY2hlY2sgLl9sZW5ndGgpXG4gKiAtIGEgcGxhaW4gZnVuY3Rpb24gKC5sZW5ndGgpXG4gKi9cbmZ1bmN0aW9uIGdldEhvb2tBcmd1bWVudHNMZW5ndGggKGZuKSB7XG4gIGlmIChpc1VuZGVmKGZuKSkge1xuICAgIHJldHVybiBmYWxzZVxuICB9XG4gIHZhciBpbnZva2VyRm5zID0gZm4uZm5zO1xuICBpZiAoaXNEZWYoaW52b2tlckZucykpIHtcbiAgICAvLyBpbnZva2VyXG4gICAgcmV0dXJuIGdldEhvb2tBcmd1bWVudHNMZW5ndGgoXG4gICAgICBBcnJheS5pc0FycmF5KGludm9rZXJGbnMpXG4gICAgICAgID8gaW52b2tlckZuc1swXVxuICAgICAgICA6IGludm9rZXJGbnNcbiAgICApXG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIChmbi5fbGVuZ3RoIHx8IGZuLmxlbmd0aCkgPiAxXG4gIH1cbn1cblxuZnVuY3Rpb24gX2VudGVyIChfLCB2bm9kZSkge1xuICBpZiAodm5vZGUuZGF0YS5zaG93ICE9PSB0cnVlKSB7XG4gICAgZW50ZXIodm5vZGUpO1xuICB9XG59XG5cbnZhciB0cmFuc2l0aW9uID0gaW5Ccm93c2VyID8ge1xuICBjcmVhdGU6IF9lbnRlcixcbiAgYWN0aXZhdGU6IF9lbnRlcixcbiAgcmVtb3ZlOiBmdW5jdGlvbiByZW1vdmUkJDEgKHZub2RlLCBybSkge1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG4gICAgaWYgKHZub2RlLmRhdGEuc2hvdyAhPT0gdHJ1ZSkge1xuICAgICAgbGVhdmUodm5vZGUsIHJtKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcm0oKTtcbiAgICB9XG4gIH1cbn0gOiB7fTtcblxudmFyIHBsYXRmb3JtTW9kdWxlcyA9IFtcbiAgYXR0cnMsXG4gIGtsYXNzLFxuICBldmVudHMsXG4gIGRvbVByb3BzLFxuICBzdHlsZSxcbiAgdHJhbnNpdGlvblxuXTtcblxuLyogICovXG5cbi8vIHRoZSBkaXJlY3RpdmUgbW9kdWxlIHNob3VsZCBiZSBhcHBsaWVkIGxhc3QsIGFmdGVyIGFsbFxuLy8gYnVpbHQtaW4gbW9kdWxlcyBoYXZlIGJlZW4gYXBwbGllZC5cbnZhciBtb2R1bGVzID0gcGxhdGZvcm1Nb2R1bGVzLmNvbmNhdChiYXNlTW9kdWxlcyk7XG5cbnZhciBwYXRjaCA9IGNyZWF0ZVBhdGNoRnVuY3Rpb24oeyBub2RlT3BzOiBub2RlT3BzLCBtb2R1bGVzOiBtb2R1bGVzIH0pO1xuXG4vKipcbiAqIE5vdCB0eXBlIGNoZWNraW5nIHRoaXMgZmlsZSBiZWNhdXNlIGZsb3cgZG9lc24ndCBsaWtlIGF0dGFjaGluZ1xuICogcHJvcGVydGllcyB0byBFbGVtZW50cy5cbiAqL1xuXG4vKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbmlmIChpc0lFOSkge1xuICAvLyBodHRwOi8vd3d3Lm1hdHRzNDExLmNvbS9wb3N0L2ludGVybmV0LWV4cGxvcmVyLTktb25pbnB1dC9cbiAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignc2VsZWN0aW9uY2hhbmdlJywgZnVuY3Rpb24gKCkge1xuICAgIHZhciBlbCA9IGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQ7XG4gICAgaWYgKGVsICYmIGVsLnZtb2RlbCkge1xuICAgICAgdHJpZ2dlcihlbCwgJ2lucHV0Jyk7XG4gICAgfVxuICB9KTtcbn1cblxudmFyIGRpcmVjdGl2ZSA9IHtcbiAgaW5zZXJ0ZWQ6IGZ1bmN0aW9uIGluc2VydGVkIChlbCwgYmluZGluZywgdm5vZGUsIG9sZFZub2RlKSB7XG4gICAgaWYgKHZub2RlLnRhZyA9PT0gJ3NlbGVjdCcpIHtcbiAgICAgIC8vICM2OTAzXG4gICAgICBpZiAob2xkVm5vZGUuZWxtICYmICFvbGRWbm9kZS5lbG0uX3ZPcHRpb25zKSB7XG4gICAgICAgIG1lcmdlVk5vZGVIb29rKHZub2RlLCAncG9zdHBhdGNoJywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgIGRpcmVjdGl2ZS5jb21wb25lbnRVcGRhdGVkKGVsLCBiaW5kaW5nLCB2bm9kZSk7XG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc2V0U2VsZWN0ZWQoZWwsIGJpbmRpbmcsIHZub2RlLmNvbnRleHQpO1xuICAgICAgfVxuICAgICAgZWwuX3ZPcHRpb25zID0gW10ubWFwLmNhbGwoZWwub3B0aW9ucywgZ2V0VmFsdWUpO1xuICAgIH0gZWxzZSBpZiAodm5vZGUudGFnID09PSAndGV4dGFyZWEnIHx8IGlzVGV4dElucHV0VHlwZShlbC50eXBlKSkge1xuICAgICAgZWwuX3ZNb2RpZmllcnMgPSBiaW5kaW5nLm1vZGlmaWVycztcbiAgICAgIGlmICghYmluZGluZy5tb2RpZmllcnMubGF6eSkge1xuICAgICAgICBlbC5hZGRFdmVudExpc3RlbmVyKCdjb21wb3NpdGlvbnN0YXJ0Jywgb25Db21wb3NpdGlvblN0YXJ0KTtcbiAgICAgICAgZWwuYWRkRXZlbnRMaXN0ZW5lcignY29tcG9zaXRpb25lbmQnLCBvbkNvbXBvc2l0aW9uRW5kKTtcbiAgICAgICAgLy8gU2FmYXJpIDwgMTAuMiAmIFVJV2ViVmlldyBkb2Vzbid0IGZpcmUgY29tcG9zaXRpb25lbmQgd2hlblxuICAgICAgICAvLyBzd2l0Y2hpbmcgZm9jdXMgYmVmb3JlIGNvbmZpcm1pbmcgY29tcG9zaXRpb24gY2hvaWNlXG4gICAgICAgIC8vIHRoaXMgYWxzbyBmaXhlcyB0aGUgaXNzdWUgd2hlcmUgc29tZSBicm93c2VycyBlLmcuIGlPUyBDaHJvbWVcbiAgICAgICAgLy8gZmlyZXMgXCJjaGFuZ2VcIiBpbnN0ZWFkIG9mIFwiaW5wdXRcIiBvbiBhdXRvY29tcGxldGUuXG4gICAgICAgIGVsLmFkZEV2ZW50TGlzdGVuZXIoJ2NoYW5nZScsIG9uQ29tcG9zaXRpb25FbmQpO1xuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgICAgaWYgKGlzSUU5KSB7XG4gICAgICAgICAgZWwudm1vZGVsID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfSxcblxuICBjb21wb25lbnRVcGRhdGVkOiBmdW5jdGlvbiBjb21wb25lbnRVcGRhdGVkIChlbCwgYmluZGluZywgdm5vZGUpIHtcbiAgICBpZiAodm5vZGUudGFnID09PSAnc2VsZWN0Jykge1xuICAgICAgc2V0U2VsZWN0ZWQoZWwsIGJpbmRpbmcsIHZub2RlLmNvbnRleHQpO1xuICAgICAgLy8gaW4gY2FzZSB0aGUgb3B0aW9ucyByZW5kZXJlZCBieSB2LWZvciBoYXZlIGNoYW5nZWQsXG4gICAgICAvLyBpdCdzIHBvc3NpYmxlIHRoYXQgdGhlIHZhbHVlIGlzIG91dC1vZi1zeW5jIHdpdGggdGhlIHJlbmRlcmVkIG9wdGlvbnMuXG4gICAgICAvLyBkZXRlY3Qgc3VjaCBjYXNlcyBhbmQgZmlsdGVyIG91dCB2YWx1ZXMgdGhhdCBubyBsb25nZXIgaGFzIGEgbWF0Y2hpbmdcbiAgICAgIC8vIG9wdGlvbiBpbiB0aGUgRE9NLlxuICAgICAgdmFyIHByZXZPcHRpb25zID0gZWwuX3ZPcHRpb25zO1xuICAgICAgdmFyIGN1ck9wdGlvbnMgPSBlbC5fdk9wdGlvbnMgPSBbXS5tYXAuY2FsbChlbC5vcHRpb25zLCBnZXRWYWx1ZSk7XG4gICAgICBpZiAoY3VyT3B0aW9ucy5zb21lKGZ1bmN0aW9uIChvLCBpKSB7IHJldHVybiAhbG9vc2VFcXVhbChvLCBwcmV2T3B0aW9uc1tpXSk7IH0pKSB7XG4gICAgICAgIC8vIHRyaWdnZXIgY2hhbmdlIGV2ZW50IGlmXG4gICAgICAgIC8vIG5vIG1hdGNoaW5nIG9wdGlvbiBmb3VuZCBmb3IgYXQgbGVhc3Qgb25lIHZhbHVlXG4gICAgICAgIHZhciBuZWVkUmVzZXQgPSBlbC5tdWx0aXBsZVxuICAgICAgICAgID8gYmluZGluZy52YWx1ZS5zb21lKGZ1bmN0aW9uICh2KSB7IHJldHVybiBoYXNOb01hdGNoaW5nT3B0aW9uKHYsIGN1ck9wdGlvbnMpOyB9KVxuICAgICAgICAgIDogYmluZGluZy52YWx1ZSAhPT0gYmluZGluZy5vbGRWYWx1ZSAmJiBoYXNOb01hdGNoaW5nT3B0aW9uKGJpbmRpbmcudmFsdWUsIGN1ck9wdGlvbnMpO1xuICAgICAgICBpZiAobmVlZFJlc2V0KSB7XG4gICAgICAgICAgdHJpZ2dlcihlbCwgJ2NoYW5nZScpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG59O1xuXG5mdW5jdGlvbiBzZXRTZWxlY3RlZCAoZWwsIGJpbmRpbmcsIHZtKSB7XG4gIGFjdHVhbGx5U2V0U2VsZWN0ZWQoZWwsIGJpbmRpbmcsIHZtKTtcbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gIGlmIChpc0lFIHx8IGlzRWRnZSkge1xuICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgYWN0dWFsbHlTZXRTZWxlY3RlZChlbCwgYmluZGluZywgdm0pO1xuICAgIH0sIDApO1xuICB9XG59XG5cbmZ1bmN0aW9uIGFjdHVhbGx5U2V0U2VsZWN0ZWQgKGVsLCBiaW5kaW5nLCB2bSkge1xuICB2YXIgdmFsdWUgPSBiaW5kaW5nLnZhbHVlO1xuICB2YXIgaXNNdWx0aXBsZSA9IGVsLm11bHRpcGxlO1xuICBpZiAoaXNNdWx0aXBsZSAmJiAhQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIHdhcm4oXG4gICAgICBcIjxzZWxlY3QgbXVsdGlwbGUgdi1tb2RlbD1cXFwiXCIgKyAoYmluZGluZy5leHByZXNzaW9uKSArIFwiXFxcIj4gXCIgK1xuICAgICAgXCJleHBlY3RzIGFuIEFycmF5IHZhbHVlIGZvciBpdHMgYmluZGluZywgYnV0IGdvdCBcIiArIChPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodmFsdWUpLnNsaWNlKDgsIC0xKSksXG4gICAgICB2bVxuICAgICk7XG4gICAgcmV0dXJuXG4gIH1cbiAgdmFyIHNlbGVjdGVkLCBvcHRpb247XG4gIGZvciAodmFyIGkgPSAwLCBsID0gZWwub3B0aW9ucy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICBvcHRpb24gPSBlbC5vcHRpb25zW2ldO1xuICAgIGlmIChpc011bHRpcGxlKSB7XG4gICAgICBzZWxlY3RlZCA9IGxvb3NlSW5kZXhPZih2YWx1ZSwgZ2V0VmFsdWUob3B0aW9uKSkgPiAtMTtcbiAgICAgIGlmIChvcHRpb24uc2VsZWN0ZWQgIT09IHNlbGVjdGVkKSB7XG4gICAgICAgIG9wdGlvbi5zZWxlY3RlZCA9IHNlbGVjdGVkO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBpZiAobG9vc2VFcXVhbChnZXRWYWx1ZShvcHRpb24pLCB2YWx1ZSkpIHtcbiAgICAgICAgaWYgKGVsLnNlbGVjdGVkSW5kZXggIT09IGkpIHtcbiAgICAgICAgICBlbC5zZWxlY3RlZEluZGV4ID0gaTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm5cbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgaWYgKCFpc011bHRpcGxlKSB7XG4gICAgZWwuc2VsZWN0ZWRJbmRleCA9IC0xO1xuICB9XG59XG5cbmZ1bmN0aW9uIGhhc05vTWF0Y2hpbmdPcHRpb24gKHZhbHVlLCBvcHRpb25zKSB7XG4gIHJldHVybiBvcHRpb25zLmV2ZXJ5KGZ1bmN0aW9uIChvKSB7IHJldHVybiAhbG9vc2VFcXVhbChvLCB2YWx1ZSk7IH0pXG59XG5cbmZ1bmN0aW9uIGdldFZhbHVlIChvcHRpb24pIHtcbiAgcmV0dXJuICdfdmFsdWUnIGluIG9wdGlvblxuICAgID8gb3B0aW9uLl92YWx1ZVxuICAgIDogb3B0aW9uLnZhbHVlXG59XG5cbmZ1bmN0aW9uIG9uQ29tcG9zaXRpb25TdGFydCAoZSkge1xuICBlLnRhcmdldC5jb21wb3NpbmcgPSB0cnVlO1xufVxuXG5mdW5jdGlvbiBvbkNvbXBvc2l0aW9uRW5kIChlKSB7XG4gIC8vIHByZXZlbnQgdHJpZ2dlcmluZyBhbiBpbnB1dCBldmVudCBmb3Igbm8gcmVhc29uXG4gIGlmICghZS50YXJnZXQuY29tcG9zaW5nKSB7IHJldHVybiB9XG4gIGUudGFyZ2V0LmNvbXBvc2luZyA9IGZhbHNlO1xuICB0cmlnZ2VyKGUudGFyZ2V0LCAnaW5wdXQnKTtcbn1cblxuZnVuY3Rpb24gdHJpZ2dlciAoZWwsIHR5cGUpIHtcbiAgdmFyIGUgPSBkb2N1bWVudC5jcmVhdGVFdmVudCgnSFRNTEV2ZW50cycpO1xuICBlLmluaXRFdmVudCh0eXBlLCB0cnVlLCB0cnVlKTtcbiAgZWwuZGlzcGF0Y2hFdmVudChlKTtcbn1cblxuLyogICovXG5cbi8vIHJlY3Vyc2l2ZWx5IHNlYXJjaCBmb3IgcG9zc2libGUgdHJhbnNpdGlvbiBkZWZpbmVkIGluc2lkZSB0aGUgY29tcG9uZW50IHJvb3RcbmZ1bmN0aW9uIGxvY2F0ZU5vZGUgKHZub2RlKSB7XG4gIHJldHVybiB2bm9kZS5jb21wb25lbnRJbnN0YW5jZSAmJiAoIXZub2RlLmRhdGEgfHwgIXZub2RlLmRhdGEudHJhbnNpdGlvbilcbiAgICA/IGxvY2F0ZU5vZGUodm5vZGUuY29tcG9uZW50SW5zdGFuY2UuX3Zub2RlKVxuICAgIDogdm5vZGVcbn1cblxudmFyIHNob3cgPSB7XG4gIGJpbmQ6IGZ1bmN0aW9uIGJpbmQgKGVsLCByZWYsIHZub2RlKSB7XG4gICAgdmFyIHZhbHVlID0gcmVmLnZhbHVlO1xuXG4gICAgdm5vZGUgPSBsb2NhdGVOb2RlKHZub2RlKTtcbiAgICB2YXIgdHJhbnNpdGlvbiQkMSA9IHZub2RlLmRhdGEgJiYgdm5vZGUuZGF0YS50cmFuc2l0aW9uO1xuICAgIHZhciBvcmlnaW5hbERpc3BsYXkgPSBlbC5fX3ZPcmlnaW5hbERpc3BsYXkgPVxuICAgICAgZWwuc3R5bGUuZGlzcGxheSA9PT0gJ25vbmUnID8gJycgOiBlbC5zdHlsZS5kaXNwbGF5O1xuICAgIGlmICh2YWx1ZSAmJiB0cmFuc2l0aW9uJCQxKSB7XG4gICAgICB2bm9kZS5kYXRhLnNob3cgPSB0cnVlO1xuICAgICAgZW50ZXIodm5vZGUsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZWwuc3R5bGUuZGlzcGxheSA9IG9yaWdpbmFsRGlzcGxheTtcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBlbC5zdHlsZS5kaXNwbGF5ID0gdmFsdWUgPyBvcmlnaW5hbERpc3BsYXkgOiAnbm9uZSc7XG4gICAgfVxuICB9LFxuXG4gIHVwZGF0ZTogZnVuY3Rpb24gdXBkYXRlIChlbCwgcmVmLCB2bm9kZSkge1xuICAgIHZhciB2YWx1ZSA9IHJlZi52YWx1ZTtcbiAgICB2YXIgb2xkVmFsdWUgPSByZWYub2xkVmFsdWU7XG5cbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICBpZiAoIXZhbHVlID09PSAhb2xkVmFsdWUpIHsgcmV0dXJuIH1cbiAgICB2bm9kZSA9IGxvY2F0ZU5vZGUodm5vZGUpO1xuICAgIHZhciB0cmFuc2l0aW9uJCQxID0gdm5vZGUuZGF0YSAmJiB2bm9kZS5kYXRhLnRyYW5zaXRpb247XG4gICAgaWYgKHRyYW5zaXRpb24kJDEpIHtcbiAgICAgIHZub2RlLmRhdGEuc2hvdyA9IHRydWU7XG4gICAgICBpZiAodmFsdWUpIHtcbiAgICAgICAgZW50ZXIodm5vZGUsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBlbC5zdHlsZS5kaXNwbGF5ID0gZWwuX192T3JpZ2luYWxEaXNwbGF5O1xuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGxlYXZlKHZub2RlLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgZWwuc3R5bGUuZGlzcGxheSA9ICdub25lJztcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGVsLnN0eWxlLmRpc3BsYXkgPSB2YWx1ZSA/IGVsLl9fdk9yaWdpbmFsRGlzcGxheSA6ICdub25lJztcbiAgICB9XG4gIH0sXG5cbiAgdW5iaW5kOiBmdW5jdGlvbiB1bmJpbmQgKFxuICAgIGVsLFxuICAgIGJpbmRpbmcsXG4gICAgdm5vZGUsXG4gICAgb2xkVm5vZGUsXG4gICAgaXNEZXN0cm95XG4gICkge1xuICAgIGlmICghaXNEZXN0cm95KSB7XG4gICAgICBlbC5zdHlsZS5kaXNwbGF5ID0gZWwuX192T3JpZ2luYWxEaXNwbGF5O1xuICAgIH1cbiAgfVxufTtcblxudmFyIHBsYXRmb3JtRGlyZWN0aXZlcyA9IHtcbiAgbW9kZWw6IGRpcmVjdGl2ZSxcbiAgc2hvdzogc2hvd1xufTtcblxuLyogICovXG5cbnZhciB0cmFuc2l0aW9uUHJvcHMgPSB7XG4gIG5hbWU6IFN0cmluZyxcbiAgYXBwZWFyOiBCb29sZWFuLFxuICBjc3M6IEJvb2xlYW4sXG4gIG1vZGU6IFN0cmluZyxcbiAgdHlwZTogU3RyaW5nLFxuICBlbnRlckNsYXNzOiBTdHJpbmcsXG4gIGxlYXZlQ2xhc3M6IFN0cmluZyxcbiAgZW50ZXJUb0NsYXNzOiBTdHJpbmcsXG4gIGxlYXZlVG9DbGFzczogU3RyaW5nLFxuICBlbnRlckFjdGl2ZUNsYXNzOiBTdHJpbmcsXG4gIGxlYXZlQWN0aXZlQ2xhc3M6IFN0cmluZyxcbiAgYXBwZWFyQ2xhc3M6IFN0cmluZyxcbiAgYXBwZWFyQWN0aXZlQ2xhc3M6IFN0cmluZyxcbiAgYXBwZWFyVG9DbGFzczogU3RyaW5nLFxuICBkdXJhdGlvbjogW051bWJlciwgU3RyaW5nLCBPYmplY3RdXG59O1xuXG4vLyBpbiBjYXNlIHRoZSBjaGlsZCBpcyBhbHNvIGFuIGFic3RyYWN0IGNvbXBvbmVudCwgZS5nLiA8a2VlcC1hbGl2ZT5cbi8vIHdlIHdhbnQgdG8gcmVjdXJzaXZlbHkgcmV0cmlldmUgdGhlIHJlYWwgY29tcG9uZW50IHRvIGJlIHJlbmRlcmVkXG5mdW5jdGlvbiBnZXRSZWFsQ2hpbGQgKHZub2RlKSB7XG4gIHZhciBjb21wT3B0aW9ucyA9IHZub2RlICYmIHZub2RlLmNvbXBvbmVudE9wdGlvbnM7XG4gIGlmIChjb21wT3B0aW9ucyAmJiBjb21wT3B0aW9ucy5DdG9yLm9wdGlvbnMuYWJzdHJhY3QpIHtcbiAgICByZXR1cm4gZ2V0UmVhbENoaWxkKGdldEZpcnN0Q29tcG9uZW50Q2hpbGQoY29tcE9wdGlvbnMuY2hpbGRyZW4pKVxuICB9IGVsc2Uge1xuICAgIHJldHVybiB2bm9kZVxuICB9XG59XG5cbmZ1bmN0aW9uIGV4dHJhY3RUcmFuc2l0aW9uRGF0YSAoY29tcCkge1xuICB2YXIgZGF0YSA9IHt9O1xuICB2YXIgb3B0aW9ucyA9IGNvbXAuJG9wdGlvbnM7XG4gIC8vIHByb3BzXG4gIGZvciAodmFyIGtleSBpbiBvcHRpb25zLnByb3BzRGF0YSkge1xuICAgIGRhdGFba2V5XSA9IGNvbXBba2V5XTtcbiAgfVxuICAvLyBldmVudHMuXG4gIC8vIGV4dHJhY3QgbGlzdGVuZXJzIGFuZCBwYXNzIHRoZW0gZGlyZWN0bHkgdG8gdGhlIHRyYW5zaXRpb24gbWV0aG9kc1xuICB2YXIgbGlzdGVuZXJzID0gb3B0aW9ucy5fcGFyZW50TGlzdGVuZXJzO1xuICBmb3IgKHZhciBrZXkkMSBpbiBsaXN0ZW5lcnMpIHtcbiAgICBkYXRhW2NhbWVsaXplKGtleSQxKV0gPSBsaXN0ZW5lcnNba2V5JDFdO1xuICB9XG4gIHJldHVybiBkYXRhXG59XG5cbmZ1bmN0aW9uIHBsYWNlaG9sZGVyIChoLCByYXdDaGlsZCkge1xuICBpZiAoL1xcZC1rZWVwLWFsaXZlJC8udGVzdChyYXdDaGlsZC50YWcpKSB7XG4gICAgcmV0dXJuIGgoJ2tlZXAtYWxpdmUnLCB7XG4gICAgICBwcm9wczogcmF3Q2hpbGQuY29tcG9uZW50T3B0aW9ucy5wcm9wc0RhdGFcbiAgICB9KVxuICB9XG59XG5cbmZ1bmN0aW9uIGhhc1BhcmVudFRyYW5zaXRpb24gKHZub2RlKSB7XG4gIHdoaWxlICgodm5vZGUgPSB2bm9kZS5wYXJlbnQpKSB7XG4gICAgaWYgKHZub2RlLmRhdGEudHJhbnNpdGlvbikge1xuICAgICAgcmV0dXJuIHRydWVcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gaXNTYW1lQ2hpbGQgKGNoaWxkLCBvbGRDaGlsZCkge1xuICByZXR1cm4gb2xkQ2hpbGQua2V5ID09PSBjaGlsZC5rZXkgJiYgb2xkQ2hpbGQudGFnID09PSBjaGlsZC50YWdcbn1cblxudmFyIGlzTm90VGV4dE5vZGUgPSBmdW5jdGlvbiAoYykgeyByZXR1cm4gYy50YWcgfHwgaXNBc3luY1BsYWNlaG9sZGVyKGMpOyB9O1xuXG52YXIgaXNWU2hvd0RpcmVjdGl2ZSA9IGZ1bmN0aW9uIChkKSB7IHJldHVybiBkLm5hbWUgPT09ICdzaG93JzsgfTtcblxudmFyIFRyYW5zaXRpb24gPSB7XG4gIG5hbWU6ICd0cmFuc2l0aW9uJyxcbiAgcHJvcHM6IHRyYW5zaXRpb25Qcm9wcyxcbiAgYWJzdHJhY3Q6IHRydWUsXG5cbiAgcmVuZGVyOiBmdW5jdGlvbiByZW5kZXIgKGgpIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICAgIHZhciBjaGlsZHJlbiA9IHRoaXMuJHNsb3RzLmRlZmF1bHQ7XG4gICAgaWYgKCFjaGlsZHJlbikge1xuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgLy8gZmlsdGVyIG91dCB0ZXh0IG5vZGVzIChwb3NzaWJsZSB3aGl0ZXNwYWNlcylcbiAgICBjaGlsZHJlbiA9IGNoaWxkcmVuLmZpbHRlcihpc05vdFRleHROb2RlKTtcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICBpZiAoIWNoaWxkcmVuLmxlbmd0aCkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgLy8gd2FybiBtdWx0aXBsZSBlbGVtZW50c1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIGNoaWxkcmVuLmxlbmd0aCA+IDEpIHtcbiAgICAgIHdhcm4oXG4gICAgICAgICc8dHJhbnNpdGlvbj4gY2FuIG9ubHkgYmUgdXNlZCBvbiBhIHNpbmdsZSBlbGVtZW50LiBVc2UgJyArXG4gICAgICAgICc8dHJhbnNpdGlvbi1ncm91cD4gZm9yIGxpc3RzLicsXG4gICAgICAgIHRoaXMuJHBhcmVudFxuICAgICAgKTtcbiAgICB9XG5cbiAgICB2YXIgbW9kZSA9IHRoaXMubW9kZTtcblxuICAgIC8vIHdhcm4gaW52YWxpZCBtb2RlXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiZcbiAgICAgIG1vZGUgJiYgbW9kZSAhPT0gJ2luLW91dCcgJiYgbW9kZSAhPT0gJ291dC1pbidcbiAgICApIHtcbiAgICAgIHdhcm4oXG4gICAgICAgICdpbnZhbGlkIDx0cmFuc2l0aW9uPiBtb2RlOiAnICsgbW9kZSxcbiAgICAgICAgdGhpcy4kcGFyZW50XG4gICAgICApO1xuICAgIH1cblxuICAgIHZhciByYXdDaGlsZCA9IGNoaWxkcmVuWzBdO1xuXG4gICAgLy8gaWYgdGhpcyBpcyBhIGNvbXBvbmVudCByb290IG5vZGUgYW5kIHRoZSBjb21wb25lbnQnc1xuICAgIC8vIHBhcmVudCBjb250YWluZXIgbm9kZSBhbHNvIGhhcyB0cmFuc2l0aW9uLCBza2lwLlxuICAgIGlmIChoYXNQYXJlbnRUcmFuc2l0aW9uKHRoaXMuJHZub2RlKSkge1xuICAgICAgcmV0dXJuIHJhd0NoaWxkXG4gICAgfVxuXG4gICAgLy8gYXBwbHkgdHJhbnNpdGlvbiBkYXRhIHRvIGNoaWxkXG4gICAgLy8gdXNlIGdldFJlYWxDaGlsZCgpIHRvIGlnbm9yZSBhYnN0cmFjdCBjb21wb25lbnRzIGUuZy4ga2VlcC1hbGl2ZVxuICAgIHZhciBjaGlsZCA9IGdldFJlYWxDaGlsZChyYXdDaGlsZCk7XG4gICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgaWYgKCFjaGlsZCkge1xuICAgICAgcmV0dXJuIHJhd0NoaWxkXG4gICAgfVxuXG4gICAgaWYgKHRoaXMuX2xlYXZpbmcpIHtcbiAgICAgIHJldHVybiBwbGFjZWhvbGRlcihoLCByYXdDaGlsZClcbiAgICB9XG5cbiAgICAvLyBlbnN1cmUgYSBrZXkgdGhhdCBpcyB1bmlxdWUgdG8gdGhlIHZub2RlIHR5cGUgYW5kIHRvIHRoaXMgdHJhbnNpdGlvblxuICAgIC8vIGNvbXBvbmVudCBpbnN0YW5jZS4gVGhpcyBrZXkgd2lsbCBiZSB1c2VkIHRvIHJlbW92ZSBwZW5kaW5nIGxlYXZpbmcgbm9kZXNcbiAgICAvLyBkdXJpbmcgZW50ZXJpbmcuXG4gICAgdmFyIGlkID0gXCJfX3RyYW5zaXRpb24tXCIgKyAodGhpcy5fdWlkKSArIFwiLVwiO1xuICAgIGNoaWxkLmtleSA9IGNoaWxkLmtleSA9PSBudWxsXG4gICAgICA/IGNoaWxkLmlzQ29tbWVudFxuICAgICAgICA/IGlkICsgJ2NvbW1lbnQnXG4gICAgICAgIDogaWQgKyBjaGlsZC50YWdcbiAgICAgIDogaXNQcmltaXRpdmUoY2hpbGQua2V5KVxuICAgICAgICA/IChTdHJpbmcoY2hpbGQua2V5KS5pbmRleE9mKGlkKSA9PT0gMCA/IGNoaWxkLmtleSA6IGlkICsgY2hpbGQua2V5KVxuICAgICAgICA6IGNoaWxkLmtleTtcblxuICAgIHZhciBkYXRhID0gKGNoaWxkLmRhdGEgfHwgKGNoaWxkLmRhdGEgPSB7fSkpLnRyYW5zaXRpb24gPSBleHRyYWN0VHJhbnNpdGlvbkRhdGEodGhpcyk7XG4gICAgdmFyIG9sZFJhd0NoaWxkID0gdGhpcy5fdm5vZGU7XG4gICAgdmFyIG9sZENoaWxkID0gZ2V0UmVhbENoaWxkKG9sZFJhd0NoaWxkKTtcblxuICAgIC8vIG1hcmsgdi1zaG93XG4gICAgLy8gc28gdGhhdCB0aGUgdHJhbnNpdGlvbiBtb2R1bGUgY2FuIGhhbmQgb3ZlciB0aGUgY29udHJvbCB0byB0aGUgZGlyZWN0aXZlXG4gICAgaWYgKGNoaWxkLmRhdGEuZGlyZWN0aXZlcyAmJiBjaGlsZC5kYXRhLmRpcmVjdGl2ZXMuc29tZShpc1ZTaG93RGlyZWN0aXZlKSkge1xuICAgICAgY2hpbGQuZGF0YS5zaG93ID0gdHJ1ZTtcbiAgICB9XG5cbiAgICBpZiAoXG4gICAgICBvbGRDaGlsZCAmJlxuICAgICAgb2xkQ2hpbGQuZGF0YSAmJlxuICAgICAgIWlzU2FtZUNoaWxkKGNoaWxkLCBvbGRDaGlsZCkgJiZcbiAgICAgICFpc0FzeW5jUGxhY2Vob2xkZXIob2xkQ2hpbGQpICYmXG4gICAgICAvLyAjNjY4NyBjb21wb25lbnQgcm9vdCBpcyBhIGNvbW1lbnQgbm9kZVxuICAgICAgIShvbGRDaGlsZC5jb21wb25lbnRJbnN0YW5jZSAmJiBvbGRDaGlsZC5jb21wb25lbnRJbnN0YW5jZS5fdm5vZGUuaXNDb21tZW50KVxuICAgICkge1xuICAgICAgLy8gcmVwbGFjZSBvbGQgY2hpbGQgdHJhbnNpdGlvbiBkYXRhIHdpdGggZnJlc2ggb25lXG4gICAgICAvLyBpbXBvcnRhbnQgZm9yIGR5bmFtaWMgdHJhbnNpdGlvbnMhXG4gICAgICB2YXIgb2xkRGF0YSA9IG9sZENoaWxkLmRhdGEudHJhbnNpdGlvbiA9IGV4dGVuZCh7fSwgZGF0YSk7XG4gICAgICAvLyBoYW5kbGUgdHJhbnNpdGlvbiBtb2RlXG4gICAgICBpZiAobW9kZSA9PT0gJ291dC1pbicpIHtcbiAgICAgICAgLy8gcmV0dXJuIHBsYWNlaG9sZGVyIG5vZGUgYW5kIHF1ZXVlIHVwZGF0ZSB3aGVuIGxlYXZlIGZpbmlzaGVzXG4gICAgICAgIHRoaXMuX2xlYXZpbmcgPSB0cnVlO1xuICAgICAgICBtZXJnZVZOb2RlSG9vayhvbGREYXRhLCAnYWZ0ZXJMZWF2ZScsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICB0aGlzJDEuX2xlYXZpbmcgPSBmYWxzZTtcbiAgICAgICAgICB0aGlzJDEuJGZvcmNlVXBkYXRlKCk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gcGxhY2Vob2xkZXIoaCwgcmF3Q2hpbGQpXG4gICAgICB9IGVsc2UgaWYgKG1vZGUgPT09ICdpbi1vdXQnKSB7XG4gICAgICAgIGlmIChpc0FzeW5jUGxhY2Vob2xkZXIoY2hpbGQpKSB7XG4gICAgICAgICAgcmV0dXJuIG9sZFJhd0NoaWxkXG4gICAgICAgIH1cbiAgICAgICAgdmFyIGRlbGF5ZWRMZWF2ZTtcbiAgICAgICAgdmFyIHBlcmZvcm1MZWF2ZSA9IGZ1bmN0aW9uICgpIHsgZGVsYXllZExlYXZlKCk7IH07XG4gICAgICAgIG1lcmdlVk5vZGVIb29rKGRhdGEsICdhZnRlckVudGVyJywgcGVyZm9ybUxlYXZlKTtcbiAgICAgICAgbWVyZ2VWTm9kZUhvb2soZGF0YSwgJ2VudGVyQ2FuY2VsbGVkJywgcGVyZm9ybUxlYXZlKTtcbiAgICAgICAgbWVyZ2VWTm9kZUhvb2sob2xkRGF0YSwgJ2RlbGF5TGVhdmUnLCBmdW5jdGlvbiAobGVhdmUpIHsgZGVsYXllZExlYXZlID0gbGVhdmU7IH0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiByYXdDaGlsZFxuICB9XG59O1xuXG4vKiAgKi9cblxudmFyIHByb3BzID0gZXh0ZW5kKHtcbiAgdGFnOiBTdHJpbmcsXG4gIG1vdmVDbGFzczogU3RyaW5nXG59LCB0cmFuc2l0aW9uUHJvcHMpO1xuXG5kZWxldGUgcHJvcHMubW9kZTtcblxudmFyIFRyYW5zaXRpb25Hcm91cCA9IHtcbiAgcHJvcHM6IHByb3BzLFxuXG4gIGJlZm9yZU1vdW50OiBmdW5jdGlvbiBiZWZvcmVNb3VudCAoKSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgICB2YXIgdXBkYXRlID0gdGhpcy5fdXBkYXRlO1xuICAgIHRoaXMuX3VwZGF0ZSA9IGZ1bmN0aW9uICh2bm9kZSwgaHlkcmF0aW5nKSB7XG4gICAgICB2YXIgcmVzdG9yZUFjdGl2ZUluc3RhbmNlID0gc2V0QWN0aXZlSW5zdGFuY2UodGhpcyQxKTtcbiAgICAgIC8vIGZvcmNlIHJlbW92aW5nIHBhc3NcbiAgICAgIHRoaXMkMS5fX3BhdGNoX18oXG4gICAgICAgIHRoaXMkMS5fdm5vZGUsXG4gICAgICAgIHRoaXMkMS5rZXB0LFxuICAgICAgICBmYWxzZSwgLy8gaHlkcmF0aW5nXG4gICAgICAgIHRydWUgLy8gcmVtb3ZlT25seSAoIWltcG9ydGFudCwgYXZvaWRzIHVubmVjZXNzYXJ5IG1vdmVzKVxuICAgICAgKTtcbiAgICAgIHRoaXMkMS5fdm5vZGUgPSB0aGlzJDEua2VwdDtcbiAgICAgIHJlc3RvcmVBY3RpdmVJbnN0YW5jZSgpO1xuICAgICAgdXBkYXRlLmNhbGwodGhpcyQxLCB2bm9kZSwgaHlkcmF0aW5nKTtcbiAgICB9O1xuICB9LFxuXG4gIHJlbmRlcjogZnVuY3Rpb24gcmVuZGVyIChoKSB7XG4gICAgdmFyIHRhZyA9IHRoaXMudGFnIHx8IHRoaXMuJHZub2RlLmRhdGEudGFnIHx8ICdzcGFuJztcbiAgICB2YXIgbWFwID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICB2YXIgcHJldkNoaWxkcmVuID0gdGhpcy5wcmV2Q2hpbGRyZW4gPSB0aGlzLmNoaWxkcmVuO1xuICAgIHZhciByYXdDaGlsZHJlbiA9IHRoaXMuJHNsb3RzLmRlZmF1bHQgfHwgW107XG4gICAgdmFyIGNoaWxkcmVuID0gdGhpcy5jaGlsZHJlbiA9IFtdO1xuICAgIHZhciB0cmFuc2l0aW9uRGF0YSA9IGV4dHJhY3RUcmFuc2l0aW9uRGF0YSh0aGlzKTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcmF3Q2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBjID0gcmF3Q2hpbGRyZW5baV07XG4gICAgICBpZiAoYy50YWcpIHtcbiAgICAgICAgaWYgKGMua2V5ICE9IG51bGwgJiYgU3RyaW5nKGMua2V5KS5pbmRleE9mKCdfX3ZsaXN0JykgIT09IDApIHtcbiAgICAgICAgICBjaGlsZHJlbi5wdXNoKGMpO1xuICAgICAgICAgIG1hcFtjLmtleV0gPSBjXG4gICAgICAgICAgOyhjLmRhdGEgfHwgKGMuZGF0YSA9IHt9KSkudHJhbnNpdGlvbiA9IHRyYW5zaXRpb25EYXRhO1xuICAgICAgICB9IGVsc2UgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgICB2YXIgb3B0cyA9IGMuY29tcG9uZW50T3B0aW9ucztcbiAgICAgICAgICB2YXIgbmFtZSA9IG9wdHMgPyAob3B0cy5DdG9yLm9wdGlvbnMubmFtZSB8fCBvcHRzLnRhZyB8fCAnJykgOiBjLnRhZztcbiAgICAgICAgICB3YXJuKChcIjx0cmFuc2l0aW9uLWdyb3VwPiBjaGlsZHJlbiBtdXN0IGJlIGtleWVkOiA8XCIgKyBuYW1lICsgXCI+XCIpKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChwcmV2Q2hpbGRyZW4pIHtcbiAgICAgIHZhciBrZXB0ID0gW107XG4gICAgICB2YXIgcmVtb3ZlZCA9IFtdO1xuICAgICAgZm9yICh2YXIgaSQxID0gMDsgaSQxIDwgcHJldkNoaWxkcmVuLmxlbmd0aDsgaSQxKyspIHtcbiAgICAgICAgdmFyIGMkMSA9IHByZXZDaGlsZHJlbltpJDFdO1xuICAgICAgICBjJDEuZGF0YS50cmFuc2l0aW9uID0gdHJhbnNpdGlvbkRhdGE7XG4gICAgICAgIGMkMS5kYXRhLnBvcyA9IGMkMS5lbG0uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICAgIGlmIChtYXBbYyQxLmtleV0pIHtcbiAgICAgICAgICBrZXB0LnB1c2goYyQxKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZW1vdmVkLnB1c2goYyQxKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdGhpcy5rZXB0ID0gaCh0YWcsIG51bGwsIGtlcHQpO1xuICAgICAgdGhpcy5yZW1vdmVkID0gcmVtb3ZlZDtcbiAgICB9XG5cbiAgICByZXR1cm4gaCh0YWcsIG51bGwsIGNoaWxkcmVuKVxuICB9LFxuXG4gIHVwZGF0ZWQ6IGZ1bmN0aW9uIHVwZGF0ZWQgKCkge1xuICAgIHZhciBjaGlsZHJlbiA9IHRoaXMucHJldkNoaWxkcmVuO1xuICAgIHZhciBtb3ZlQ2xhc3MgPSB0aGlzLm1vdmVDbGFzcyB8fCAoKHRoaXMubmFtZSB8fCAndicpICsgJy1tb3ZlJyk7XG4gICAgaWYgKCFjaGlsZHJlbi5sZW5ndGggfHwgIXRoaXMuaGFzTW92ZShjaGlsZHJlblswXS5lbG0sIG1vdmVDbGFzcykpIHtcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIC8vIHdlIGRpdmlkZSB0aGUgd29yayBpbnRvIHRocmVlIGxvb3BzIHRvIGF2b2lkIG1peGluZyBET00gcmVhZHMgYW5kIHdyaXRlc1xuICAgIC8vIGluIGVhY2ggaXRlcmF0aW9uIC0gd2hpY2ggaGVscHMgcHJldmVudCBsYXlvdXQgdGhyYXNoaW5nLlxuICAgIGNoaWxkcmVuLmZvckVhY2goY2FsbFBlbmRpbmdDYnMpO1xuICAgIGNoaWxkcmVuLmZvckVhY2gocmVjb3JkUG9zaXRpb24pO1xuICAgIGNoaWxkcmVuLmZvckVhY2goYXBwbHlUcmFuc2xhdGlvbik7XG5cbiAgICAvLyBmb3JjZSByZWZsb3cgdG8gcHV0IGV2ZXJ5dGhpbmcgaW4gcG9zaXRpb25cbiAgICAvLyBhc3NpZ24gdG8gdGhpcyB0byBhdm9pZCBiZWluZyByZW1vdmVkIGluIHRyZWUtc2hha2luZ1xuICAgIC8vICRmbG93LWRpc2FibGUtbGluZVxuICAgIHRoaXMuX3JlZmxvdyA9IGRvY3VtZW50LmJvZHkub2Zmc2V0SGVpZ2h0O1xuXG4gICAgY2hpbGRyZW4uZm9yRWFjaChmdW5jdGlvbiAoYykge1xuICAgICAgaWYgKGMuZGF0YS5tb3ZlZCkge1xuICAgICAgICB2YXIgZWwgPSBjLmVsbTtcbiAgICAgICAgdmFyIHMgPSBlbC5zdHlsZTtcbiAgICAgICAgYWRkVHJhbnNpdGlvbkNsYXNzKGVsLCBtb3ZlQ2xhc3MpO1xuICAgICAgICBzLnRyYW5zZm9ybSA9IHMuV2Via2l0VHJhbnNmb3JtID0gcy50cmFuc2l0aW9uRHVyYXRpb24gPSAnJztcbiAgICAgICAgZWwuYWRkRXZlbnRMaXN0ZW5lcih0cmFuc2l0aW9uRW5kRXZlbnQsIGVsLl9tb3ZlQ2IgPSBmdW5jdGlvbiBjYiAoZSkge1xuICAgICAgICAgIGlmIChlICYmIGUudGFyZ2V0ICE9PSBlbCkge1xuICAgICAgICAgICAgcmV0dXJuXG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICghZSB8fCAvdHJhbnNmb3JtJC8udGVzdChlLnByb3BlcnR5TmFtZSkpIHtcbiAgICAgICAgICAgIGVsLnJlbW92ZUV2ZW50TGlzdGVuZXIodHJhbnNpdGlvbkVuZEV2ZW50LCBjYik7XG4gICAgICAgICAgICBlbC5fbW92ZUNiID0gbnVsbDtcbiAgICAgICAgICAgIHJlbW92ZVRyYW5zaXRpb25DbGFzcyhlbCwgbW92ZUNsYXNzKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0pO1xuICB9LFxuXG4gIG1ldGhvZHM6IHtcbiAgICBoYXNNb3ZlOiBmdW5jdGlvbiBoYXNNb3ZlIChlbCwgbW92ZUNsYXNzKSB7XG4gICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgIGlmICghaGFzVHJhbnNpdGlvbikge1xuICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgIH1cbiAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgaWYgKHRoaXMuX2hhc01vdmUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2hhc01vdmVcbiAgICAgIH1cbiAgICAgIC8vIERldGVjdCB3aGV0aGVyIGFuIGVsZW1lbnQgd2l0aCB0aGUgbW92ZSBjbGFzcyBhcHBsaWVkIGhhc1xuICAgICAgLy8gQ1NTIHRyYW5zaXRpb25zLiBTaW5jZSB0aGUgZWxlbWVudCBtYXkgYmUgaW5zaWRlIGFuIGVudGVyaW5nXG4gICAgICAvLyB0cmFuc2l0aW9uIGF0IHRoaXMgdmVyeSBtb21lbnQsIHdlIG1ha2UgYSBjbG9uZSBvZiBpdCBhbmQgcmVtb3ZlXG4gICAgICAvLyBhbGwgb3RoZXIgdHJhbnNpdGlvbiBjbGFzc2VzIGFwcGxpZWQgdG8gZW5zdXJlIG9ubHkgdGhlIG1vdmUgY2xhc3NcbiAgICAgIC8vIGlzIGFwcGxpZWQuXG4gICAgICB2YXIgY2xvbmUgPSBlbC5jbG9uZU5vZGUoKTtcbiAgICAgIGlmIChlbC5fdHJhbnNpdGlvbkNsYXNzZXMpIHtcbiAgICAgICAgZWwuX3RyYW5zaXRpb25DbGFzc2VzLmZvckVhY2goZnVuY3Rpb24gKGNscykgeyByZW1vdmVDbGFzcyhjbG9uZSwgY2xzKTsgfSk7XG4gICAgICB9XG4gICAgICBhZGRDbGFzcyhjbG9uZSwgbW92ZUNsYXNzKTtcbiAgICAgIGNsb25lLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG4gICAgICB0aGlzLiRlbC5hcHBlbmRDaGlsZChjbG9uZSk7XG4gICAgICB2YXIgaW5mbyA9IGdldFRyYW5zaXRpb25JbmZvKGNsb25lKTtcbiAgICAgIHRoaXMuJGVsLnJlbW92ZUNoaWxkKGNsb25lKTtcbiAgICAgIHJldHVybiAodGhpcy5faGFzTW92ZSA9IGluZm8uaGFzVHJhbnNmb3JtKVxuICAgIH1cbiAgfVxufTtcblxuZnVuY3Rpb24gY2FsbFBlbmRpbmdDYnMgKGMpIHtcbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gIGlmIChjLmVsbS5fbW92ZUNiKSB7XG4gICAgYy5lbG0uX21vdmVDYigpO1xuICB9XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICBpZiAoYy5lbG0uX2VudGVyQ2IpIHtcbiAgICBjLmVsbS5fZW50ZXJDYigpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHJlY29yZFBvc2l0aW9uIChjKSB7XG4gIGMuZGF0YS5uZXdQb3MgPSBjLmVsbS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbn1cblxuZnVuY3Rpb24gYXBwbHlUcmFuc2xhdGlvbiAoYykge1xuICB2YXIgb2xkUG9zID0gYy5kYXRhLnBvcztcbiAgdmFyIG5ld1BvcyA9IGMuZGF0YS5uZXdQb3M7XG4gIHZhciBkeCA9IG9sZFBvcy5sZWZ0IC0gbmV3UG9zLmxlZnQ7XG4gIHZhciBkeSA9IG9sZFBvcy50b3AgLSBuZXdQb3MudG9wO1xuICBpZiAoZHggfHwgZHkpIHtcbiAgICBjLmRhdGEubW92ZWQgPSB0cnVlO1xuICAgIHZhciBzID0gYy5lbG0uc3R5bGU7XG4gICAgcy50cmFuc2Zvcm0gPSBzLldlYmtpdFRyYW5zZm9ybSA9IFwidHJhbnNsYXRlKFwiICsgZHggKyBcInB4LFwiICsgZHkgKyBcInB4KVwiO1xuICAgIHMudHJhbnNpdGlvbkR1cmF0aW9uID0gJzBzJztcbiAgfVxufVxuXG52YXIgcGxhdGZvcm1Db21wb25lbnRzID0ge1xuICBUcmFuc2l0aW9uOiBUcmFuc2l0aW9uLFxuICBUcmFuc2l0aW9uR3JvdXA6IFRyYW5zaXRpb25Hcm91cFxufTtcblxuLyogICovXG5cbi8vIGluc3RhbGwgcGxhdGZvcm0gc3BlY2lmaWMgdXRpbHNcblZ1ZS5jb25maWcubXVzdFVzZVByb3AgPSBtdXN0VXNlUHJvcDtcblZ1ZS5jb25maWcuaXNSZXNlcnZlZFRhZyA9IGlzUmVzZXJ2ZWRUYWc7XG5WdWUuY29uZmlnLmlzUmVzZXJ2ZWRBdHRyID0gaXNSZXNlcnZlZEF0dHI7XG5WdWUuY29uZmlnLmdldFRhZ05hbWVzcGFjZSA9IGdldFRhZ05hbWVzcGFjZTtcblZ1ZS5jb25maWcuaXNVbmtub3duRWxlbWVudCA9IGlzVW5rbm93bkVsZW1lbnQ7XG5cbi8vIGluc3RhbGwgcGxhdGZvcm0gcnVudGltZSBkaXJlY3RpdmVzICYgY29tcG9uZW50c1xuZXh0ZW5kKFZ1ZS5vcHRpb25zLmRpcmVjdGl2ZXMsIHBsYXRmb3JtRGlyZWN0aXZlcyk7XG5leHRlbmQoVnVlLm9wdGlvbnMuY29tcG9uZW50cywgcGxhdGZvcm1Db21wb25lbnRzKTtcblxuLy8gaW5zdGFsbCBwbGF0Zm9ybSBwYXRjaCBmdW5jdGlvblxuVnVlLnByb3RvdHlwZS5fX3BhdGNoX18gPSBpbkJyb3dzZXIgPyBwYXRjaCA6IG5vb3A7XG5cbi8vIHB1YmxpYyBtb3VudCBtZXRob2RcblZ1ZS5wcm90b3R5cGUuJG1vdW50ID0gZnVuY3Rpb24gKFxuICBlbCxcbiAgaHlkcmF0aW5nXG4pIHtcbiAgZWwgPSBlbCAmJiBpbkJyb3dzZXIgPyBxdWVyeShlbCkgOiB1bmRlZmluZWQ7XG4gIHJldHVybiBtb3VudENvbXBvbmVudCh0aGlzLCBlbCwgaHlkcmF0aW5nKVxufTtcblxuLy8gZGV2dG9vbHMgZ2xvYmFsIGhvb2tcbi8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG5pZiAoaW5Ccm93c2VyKSB7XG4gIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgIGlmIChjb25maWcuZGV2dG9vbHMpIHtcbiAgICAgIGlmIChkZXZ0b29scykge1xuICAgICAgICBkZXZ0b29scy5lbWl0KCdpbml0JywgVnVlKTtcbiAgICAgIH0gZWxzZSBpZiAoXG4gICAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiZcbiAgICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICd0ZXN0J1xuICAgICAgKSB7XG4gICAgICAgIGNvbnNvbGVbY29uc29sZS5pbmZvID8gJ2luZm8nIDogJ2xvZyddKFxuICAgICAgICAgICdEb3dubG9hZCB0aGUgVnVlIERldnRvb2xzIGV4dGVuc2lvbiBmb3IgYSBiZXR0ZXIgZGV2ZWxvcG1lbnQgZXhwZXJpZW5jZTpcXG4nICtcbiAgICAgICAgICAnaHR0cHM6Ly9naXRodWIuY29tL3Z1ZWpzL3Z1ZS1kZXZ0b29scydcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiZcbiAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAndGVzdCcgJiZcbiAgICAgIGNvbmZpZy5wcm9kdWN0aW9uVGlwICE9PSBmYWxzZSAmJlxuICAgICAgdHlwZW9mIGNvbnNvbGUgIT09ICd1bmRlZmluZWQnXG4gICAgKSB7XG4gICAgICBjb25zb2xlW2NvbnNvbGUuaW5mbyA/ICdpbmZvJyA6ICdsb2cnXShcbiAgICAgICAgXCJZb3UgYXJlIHJ1bm5pbmcgVnVlIGluIGRldmVsb3BtZW50IG1vZGUuXFxuXCIgK1xuICAgICAgICBcIk1ha2Ugc3VyZSB0byB0dXJuIG9uIHByb2R1Y3Rpb24gbW9kZSB3aGVuIGRlcGxveWluZyBmb3IgcHJvZHVjdGlvbi5cXG5cIiArXG4gICAgICAgIFwiU2VlIG1vcmUgdGlwcyBhdCBodHRwczovL3Z1ZWpzLm9yZy9ndWlkZS9kZXBsb3ltZW50Lmh0bWxcIlxuICAgICAgKTtcbiAgICB9XG4gIH0sIDApO1xufVxuXG4vKiAgKi9cblxudmFyIGRlZmF1bHRUYWdSRSA9IC9cXHtcXHsoKD86LnxcXHI/XFxuKSs/KVxcfVxcfS9nO1xudmFyIHJlZ2V4RXNjYXBlUkUgPSAvWy0uKis/XiR7fSgpfFtcXF1cXC9cXFxcXS9nO1xuXG52YXIgYnVpbGRSZWdleCA9IGNhY2hlZChmdW5jdGlvbiAoZGVsaW1pdGVycykge1xuICB2YXIgb3BlbiA9IGRlbGltaXRlcnNbMF0ucmVwbGFjZShyZWdleEVzY2FwZVJFLCAnXFxcXCQmJyk7XG4gIHZhciBjbG9zZSA9IGRlbGltaXRlcnNbMV0ucmVwbGFjZShyZWdleEVzY2FwZVJFLCAnXFxcXCQmJyk7XG4gIHJldHVybiBuZXcgUmVnRXhwKG9wZW4gKyAnKCg/Oi58XFxcXG4pKz8pJyArIGNsb3NlLCAnZycpXG59KTtcblxuXG5cbmZ1bmN0aW9uIHBhcnNlVGV4dCAoXG4gIHRleHQsXG4gIGRlbGltaXRlcnNcbikge1xuICB2YXIgdGFnUkUgPSBkZWxpbWl0ZXJzID8gYnVpbGRSZWdleChkZWxpbWl0ZXJzKSA6IGRlZmF1bHRUYWdSRTtcbiAgaWYgKCF0YWdSRS50ZXN0KHRleHQpKSB7XG4gICAgcmV0dXJuXG4gIH1cbiAgdmFyIHRva2VucyA9IFtdO1xuICB2YXIgcmF3VG9rZW5zID0gW107XG4gIHZhciBsYXN0SW5kZXggPSB0YWdSRS5sYXN0SW5kZXggPSAwO1xuICB2YXIgbWF0Y2gsIGluZGV4LCB0b2tlblZhbHVlO1xuICB3aGlsZSAoKG1hdGNoID0gdGFnUkUuZXhlYyh0ZXh0KSkpIHtcbiAgICBpbmRleCA9IG1hdGNoLmluZGV4O1xuICAgIC8vIHB1c2ggdGV4dCB0b2tlblxuICAgIGlmIChpbmRleCA+IGxhc3RJbmRleCkge1xuICAgICAgcmF3VG9rZW5zLnB1c2godG9rZW5WYWx1ZSA9IHRleHQuc2xpY2UobGFzdEluZGV4LCBpbmRleCkpO1xuICAgICAgdG9rZW5zLnB1c2goSlNPTi5zdHJpbmdpZnkodG9rZW5WYWx1ZSkpO1xuICAgIH1cbiAgICAvLyB0YWcgdG9rZW5cbiAgICB2YXIgZXhwID0gcGFyc2VGaWx0ZXJzKG1hdGNoWzFdLnRyaW0oKSk7XG4gICAgdG9rZW5zLnB1c2goKFwiX3MoXCIgKyBleHAgKyBcIilcIikpO1xuICAgIHJhd1Rva2Vucy5wdXNoKHsgJ0BiaW5kaW5nJzogZXhwIH0pO1xuICAgIGxhc3RJbmRleCA9IGluZGV4ICsgbWF0Y2hbMF0ubGVuZ3RoO1xuICB9XG4gIGlmIChsYXN0SW5kZXggPCB0ZXh0Lmxlbmd0aCkge1xuICAgIHJhd1Rva2Vucy5wdXNoKHRva2VuVmFsdWUgPSB0ZXh0LnNsaWNlKGxhc3RJbmRleCkpO1xuICAgIHRva2Vucy5wdXNoKEpTT04uc3RyaW5naWZ5KHRva2VuVmFsdWUpKTtcbiAgfVxuICByZXR1cm4ge1xuICAgIGV4cHJlc3Npb246IHRva2Vucy5qb2luKCcrJyksXG4gICAgdG9rZW5zOiByYXdUb2tlbnNcbiAgfVxufVxuXG4vKiAgKi9cblxuZnVuY3Rpb24gdHJhbnNmb3JtTm9kZSAoZWwsIG9wdGlvbnMpIHtcbiAgdmFyIHdhcm4gPSBvcHRpb25zLndhcm4gfHwgYmFzZVdhcm47XG4gIHZhciBzdGF0aWNDbGFzcyA9IGdldEFuZFJlbW92ZUF0dHIoZWwsICdjbGFzcycpO1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiBzdGF0aWNDbGFzcykge1xuICAgIHZhciByZXMgPSBwYXJzZVRleHQoc3RhdGljQ2xhc3MsIG9wdGlvbnMuZGVsaW1pdGVycyk7XG4gICAgaWYgKHJlcykge1xuICAgICAgd2FybihcbiAgICAgICAgXCJjbGFzcz1cXFwiXCIgKyBzdGF0aWNDbGFzcyArIFwiXFxcIjogXCIgK1xuICAgICAgICAnSW50ZXJwb2xhdGlvbiBpbnNpZGUgYXR0cmlidXRlcyBoYXMgYmVlbiByZW1vdmVkLiAnICtcbiAgICAgICAgJ1VzZSB2LWJpbmQgb3IgdGhlIGNvbG9uIHNob3J0aGFuZCBpbnN0ZWFkLiBGb3IgZXhhbXBsZSwgJyArXG4gICAgICAgICdpbnN0ZWFkIG9mIDxkaXYgY2xhc3M9XCJ7eyB2YWwgfX1cIj4sIHVzZSA8ZGl2IDpjbGFzcz1cInZhbFwiPi4nLFxuICAgICAgICBlbC5yYXdBdHRyc01hcFsnY2xhc3MnXVxuICAgICAgKTtcbiAgICB9XG4gIH1cbiAgaWYgKHN0YXRpY0NsYXNzKSB7XG4gICAgZWwuc3RhdGljQ2xhc3MgPSBKU09OLnN0cmluZ2lmeShzdGF0aWNDbGFzcyk7XG4gIH1cbiAgdmFyIGNsYXNzQmluZGluZyA9IGdldEJpbmRpbmdBdHRyKGVsLCAnY2xhc3MnLCBmYWxzZSAvKiBnZXRTdGF0aWMgKi8pO1xuICBpZiAoY2xhc3NCaW5kaW5nKSB7XG4gICAgZWwuY2xhc3NCaW5kaW5nID0gY2xhc3NCaW5kaW5nO1xuICB9XG59XG5cbmZ1bmN0aW9uIGdlbkRhdGEgKGVsKSB7XG4gIHZhciBkYXRhID0gJyc7XG4gIGlmIChlbC5zdGF0aWNDbGFzcykge1xuICAgIGRhdGEgKz0gXCJzdGF0aWNDbGFzczpcIiArIChlbC5zdGF0aWNDbGFzcykgKyBcIixcIjtcbiAgfVxuICBpZiAoZWwuY2xhc3NCaW5kaW5nKSB7XG4gICAgZGF0YSArPSBcImNsYXNzOlwiICsgKGVsLmNsYXNzQmluZGluZykgKyBcIixcIjtcbiAgfVxuICByZXR1cm4gZGF0YVxufVxuXG52YXIga2xhc3MkMSA9IHtcbiAgc3RhdGljS2V5czogWydzdGF0aWNDbGFzcyddLFxuICB0cmFuc2Zvcm1Ob2RlOiB0cmFuc2Zvcm1Ob2RlLFxuICBnZW5EYXRhOiBnZW5EYXRhXG59O1xuXG4vKiAgKi9cblxuZnVuY3Rpb24gdHJhbnNmb3JtTm9kZSQxIChlbCwgb3B0aW9ucykge1xuICB2YXIgd2FybiA9IG9wdGlvbnMud2FybiB8fCBiYXNlV2FybjtcbiAgdmFyIHN0YXRpY1N0eWxlID0gZ2V0QW5kUmVtb3ZlQXR0cihlbCwgJ3N0eWxlJyk7XG4gIGlmIChzdGF0aWNTdHlsZSkge1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICB2YXIgcmVzID0gcGFyc2VUZXh0KHN0YXRpY1N0eWxlLCBvcHRpb25zLmRlbGltaXRlcnMpO1xuICAgICAgaWYgKHJlcykge1xuICAgICAgICB3YXJuKFxuICAgICAgICAgIFwic3R5bGU9XFxcIlwiICsgc3RhdGljU3R5bGUgKyBcIlxcXCI6IFwiICtcbiAgICAgICAgICAnSW50ZXJwb2xhdGlvbiBpbnNpZGUgYXR0cmlidXRlcyBoYXMgYmVlbiByZW1vdmVkLiAnICtcbiAgICAgICAgICAnVXNlIHYtYmluZCBvciB0aGUgY29sb24gc2hvcnRoYW5kIGluc3RlYWQuIEZvciBleGFtcGxlLCAnICtcbiAgICAgICAgICAnaW5zdGVhZCBvZiA8ZGl2IHN0eWxlPVwie3sgdmFsIH19XCI+LCB1c2UgPGRpdiA6c3R5bGU9XCJ2YWxcIj4uJyxcbiAgICAgICAgICBlbC5yYXdBdHRyc01hcFsnc3R5bGUnXVxuICAgICAgICApO1xuICAgICAgfVxuICAgIH1cbiAgICBlbC5zdGF0aWNTdHlsZSA9IEpTT04uc3RyaW5naWZ5KHBhcnNlU3R5bGVUZXh0KHN0YXRpY1N0eWxlKSk7XG4gIH1cblxuICB2YXIgc3R5bGVCaW5kaW5nID0gZ2V0QmluZGluZ0F0dHIoZWwsICdzdHlsZScsIGZhbHNlIC8qIGdldFN0YXRpYyAqLyk7XG4gIGlmIChzdHlsZUJpbmRpbmcpIHtcbiAgICBlbC5zdHlsZUJpbmRpbmcgPSBzdHlsZUJpbmRpbmc7XG4gIH1cbn1cblxuZnVuY3Rpb24gZ2VuRGF0YSQxIChlbCkge1xuICB2YXIgZGF0YSA9ICcnO1xuICBpZiAoZWwuc3RhdGljU3R5bGUpIHtcbiAgICBkYXRhICs9IFwic3RhdGljU3R5bGU6XCIgKyAoZWwuc3RhdGljU3R5bGUpICsgXCIsXCI7XG4gIH1cbiAgaWYgKGVsLnN0eWxlQmluZGluZykge1xuICAgIGRhdGEgKz0gXCJzdHlsZTooXCIgKyAoZWwuc3R5bGVCaW5kaW5nKSArIFwiKSxcIjtcbiAgfVxuICByZXR1cm4gZGF0YVxufVxuXG52YXIgc3R5bGUkMSA9IHtcbiAgc3RhdGljS2V5czogWydzdGF0aWNTdHlsZSddLFxuICB0cmFuc2Zvcm1Ob2RlOiB0cmFuc2Zvcm1Ob2RlJDEsXG4gIGdlbkRhdGE6IGdlbkRhdGEkMVxufTtcblxuLyogICovXG5cbnZhciBkZWNvZGVyO1xuXG52YXIgaGUgPSB7XG4gIGRlY29kZTogZnVuY3Rpb24gZGVjb2RlIChodG1sKSB7XG4gICAgZGVjb2RlciA9IGRlY29kZXIgfHwgZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgZGVjb2Rlci5pbm5lckhUTUwgPSBodG1sO1xuICAgIHJldHVybiBkZWNvZGVyLnRleHRDb250ZW50XG4gIH1cbn07XG5cbi8qICAqL1xuXG52YXIgaXNVbmFyeVRhZyA9IG1ha2VNYXAoXG4gICdhcmVhLGJhc2UsYnIsY29sLGVtYmVkLGZyYW1lLGhyLGltZyxpbnB1dCxpc2luZGV4LGtleWdlbiwnICtcbiAgJ2xpbmssbWV0YSxwYXJhbSxzb3VyY2UsdHJhY2ssd2JyJ1xuKTtcblxuLy8gRWxlbWVudHMgdGhhdCB5b3UgY2FuLCBpbnRlbnRpb25hbGx5LCBsZWF2ZSBvcGVuXG4vLyAoYW5kIHdoaWNoIGNsb3NlIHRoZW1zZWx2ZXMpXG52YXIgY2FuQmVMZWZ0T3BlblRhZyA9IG1ha2VNYXAoXG4gICdjb2xncm91cCxkZCxkdCxsaSxvcHRpb25zLHAsdGQsdGZvb3QsdGgsdGhlYWQsdHIsc291cmNlJ1xuKTtcblxuLy8gSFRNTDUgdGFncyBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9pbmRpY2VzLmh0bWwjZWxlbWVudHMtM1xuLy8gUGhyYXNpbmcgQ29udGVudCBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9kb20uaHRtbCNwaHJhc2luZy1jb250ZW50XG52YXIgaXNOb25QaHJhc2luZ1RhZyA9IG1ha2VNYXAoXG4gICdhZGRyZXNzLGFydGljbGUsYXNpZGUsYmFzZSxibG9ja3F1b3RlLGJvZHksY2FwdGlvbixjb2wsY29sZ3JvdXAsZGQsJyArXG4gICdkZXRhaWxzLGRpYWxvZyxkaXYsZGwsZHQsZmllbGRzZXQsZmlnY2FwdGlvbixmaWd1cmUsZm9vdGVyLGZvcm0sJyArXG4gICdoMSxoMixoMyxoNCxoNSxoNixoZWFkLGhlYWRlcixoZ3JvdXAsaHIsaHRtbCxsZWdlbmQsbGksbWVudWl0ZW0sbWV0YSwnICtcbiAgJ29wdGdyb3VwLG9wdGlvbixwYXJhbSxycCxydCxzb3VyY2Usc3R5bGUsc3VtbWFyeSx0Ym9keSx0ZCx0Zm9vdCx0aCx0aGVhZCwnICtcbiAgJ3RpdGxlLHRyLHRyYWNrJ1xuKTtcblxuLyoqXG4gKiBOb3QgdHlwZS1jaGVja2luZyB0aGlzIGZpbGUgYmVjYXVzZSBpdCdzIG1vc3RseSB2ZW5kb3IgY29kZS5cbiAqL1xuXG4vLyBSZWd1bGFyIEV4cHJlc3Npb25zIGZvciBwYXJzaW5nIHRhZ3MgYW5kIGF0dHJpYnV0ZXNcbnZhciBhdHRyaWJ1dGUgPSAvXlxccyooW15cXHNcIic8PlxcLz1dKykoPzpcXHMqKD0pXFxzKig/OlwiKFteXCJdKilcIit8JyhbXiddKiknK3woW15cXHNcIic9PD5gXSspKSk/LztcbnZhciBkeW5hbWljQXJnQXR0cmlidXRlID0gL15cXHMqKCg/OnYtW1xcdy1dKzp8QHw6fCMpXFxbW149XSs/XFxdW15cXHNcIic8PlxcLz1dKikoPzpcXHMqKD0pXFxzKig/OlwiKFteXCJdKilcIit8JyhbXiddKiknK3woW15cXHNcIic9PD5gXSspKSk/LztcbnZhciBuY25hbWUgPSBcIlthLXpBLVpfXVtcXFxcLVxcXFwuMC05X2EtekEtWlwiICsgKHVuaWNvZGVSZWdFeHAuc291cmNlKSArIFwiXSpcIjtcbnZhciBxbmFtZUNhcHR1cmUgPSBcIigoPzpcIiArIG5jbmFtZSArIFwiXFxcXDopP1wiICsgbmNuYW1lICsgXCIpXCI7XG52YXIgc3RhcnRUYWdPcGVuID0gbmV3IFJlZ0V4cCgoXCJePFwiICsgcW5hbWVDYXB0dXJlKSk7XG52YXIgc3RhcnRUYWdDbG9zZSA9IC9eXFxzKihcXC8/KT4vO1xudmFyIGVuZFRhZyA9IG5ldyBSZWdFeHAoKFwiXjxcXFxcL1wiICsgcW5hbWVDYXB0dXJlICsgXCJbXj5dKj5cIikpO1xudmFyIGRvY3R5cGUgPSAvXjwhRE9DVFlQRSBbXj5dKz4vaTtcbi8vICM3Mjk4OiBlc2NhcGUgLSB0byBhdm9pZCBiZWluZyBwYXNzZWQgYXMgSFRNTCBjb21tZW50IHdoZW4gaW5saW5lZCBpbiBwYWdlXG52YXIgY29tbWVudCA9IC9ePCFcXC0tLztcbnZhciBjb25kaXRpb25hbENvbW1lbnQgPSAvXjwhXFxbLztcblxuLy8gU3BlY2lhbCBFbGVtZW50cyAoY2FuIGNvbnRhaW4gYW55dGhpbmcpXG52YXIgaXNQbGFpblRleHRFbGVtZW50ID0gbWFrZU1hcCgnc2NyaXB0LHN0eWxlLHRleHRhcmVhJywgdHJ1ZSk7XG52YXIgcmVDYWNoZSA9IHt9O1xuXG52YXIgZGVjb2RpbmdNYXAgPSB7XG4gICcmbHQ7JzogJzwnLFxuICAnJmd0Oyc6ICc+JyxcbiAgJyZxdW90Oyc6ICdcIicsXG4gICcmYW1wOyc6ICcmJyxcbiAgJyYjMTA7JzogJ1xcbicsXG4gICcmIzk7JzogJ1xcdCcsXG4gICcmIzM5Oyc6IFwiJ1wiXG59O1xudmFyIGVuY29kZWRBdHRyID0gLyYoPzpsdHxndHxxdW90fGFtcHwjMzkpOy9nO1xudmFyIGVuY29kZWRBdHRyV2l0aE5ld0xpbmVzID0gLyYoPzpsdHxndHxxdW90fGFtcHwjMzl8IzEwfCM5KTsvZztcblxuLy8gIzU5OTJcbnZhciBpc0lnbm9yZU5ld2xpbmVUYWcgPSBtYWtlTWFwKCdwcmUsdGV4dGFyZWEnLCB0cnVlKTtcbnZhciBzaG91bGRJZ25vcmVGaXJzdE5ld2xpbmUgPSBmdW5jdGlvbiAodGFnLCBodG1sKSB7IHJldHVybiB0YWcgJiYgaXNJZ25vcmVOZXdsaW5lVGFnKHRhZykgJiYgaHRtbFswXSA9PT0gJ1xcbic7IH07XG5cbmZ1bmN0aW9uIGRlY29kZUF0dHIgKHZhbHVlLCBzaG91bGREZWNvZGVOZXdsaW5lcykge1xuICB2YXIgcmUgPSBzaG91bGREZWNvZGVOZXdsaW5lcyA/IGVuY29kZWRBdHRyV2l0aE5ld0xpbmVzIDogZW5jb2RlZEF0dHI7XG4gIHJldHVybiB2YWx1ZS5yZXBsYWNlKHJlLCBmdW5jdGlvbiAobWF0Y2gpIHsgcmV0dXJuIGRlY29kaW5nTWFwW21hdGNoXTsgfSlcbn1cblxuZnVuY3Rpb24gcGFyc2VIVE1MIChodG1sLCBvcHRpb25zKSB7XG4gIHZhciBzdGFjayA9IFtdO1xuICB2YXIgZXhwZWN0SFRNTCA9IG9wdGlvbnMuZXhwZWN0SFRNTDtcbiAgdmFyIGlzVW5hcnlUYWckJDEgPSBvcHRpb25zLmlzVW5hcnlUYWcgfHwgbm87XG4gIHZhciBjYW5CZUxlZnRPcGVuVGFnJCQxID0gb3B0aW9ucy5jYW5CZUxlZnRPcGVuVGFnIHx8IG5vO1xuICB2YXIgaW5kZXggPSAwO1xuICB2YXIgbGFzdCwgbGFzdFRhZztcbiAgd2hpbGUgKGh0bWwpIHtcbiAgICBsYXN0ID0gaHRtbDtcbiAgICAvLyBNYWtlIHN1cmUgd2UncmUgbm90IGluIGEgcGxhaW50ZXh0IGNvbnRlbnQgZWxlbWVudCBsaWtlIHNjcmlwdC9zdHlsZVxuICAgIGlmICghbGFzdFRhZyB8fCAhaXNQbGFpblRleHRFbGVtZW50KGxhc3RUYWcpKSB7XG4gICAgICB2YXIgdGV4dEVuZCA9IGh0bWwuaW5kZXhPZignPCcpO1xuICAgICAgaWYgKHRleHRFbmQgPT09IDApIHtcbiAgICAgICAgLy8gQ29tbWVudDpcbiAgICAgICAgaWYgKGNvbW1lbnQudGVzdChodG1sKSkge1xuICAgICAgICAgIHZhciBjb21tZW50RW5kID0gaHRtbC5pbmRleE9mKCctLT4nKTtcblxuICAgICAgICAgIGlmIChjb21tZW50RW5kID49IDApIHtcbiAgICAgICAgICAgIGlmIChvcHRpb25zLnNob3VsZEtlZXBDb21tZW50KSB7XG4gICAgICAgICAgICAgIG9wdGlvbnMuY29tbWVudChodG1sLnN1YnN0cmluZyg0LCBjb21tZW50RW5kKSwgaW5kZXgsIGluZGV4ICsgY29tbWVudEVuZCArIDMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYWR2YW5jZShjb21tZW50RW5kICsgMyk7XG4gICAgICAgICAgICBjb250aW51ZVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGh0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvQ29uZGl0aW9uYWxfY29tbWVudCNEb3dubGV2ZWwtcmV2ZWFsZWRfY29uZGl0aW9uYWxfY29tbWVudFxuICAgICAgICBpZiAoY29uZGl0aW9uYWxDb21tZW50LnRlc3QoaHRtbCkpIHtcbiAgICAgICAgICB2YXIgY29uZGl0aW9uYWxFbmQgPSBodG1sLmluZGV4T2YoJ10+Jyk7XG5cbiAgICAgICAgICBpZiAoY29uZGl0aW9uYWxFbmQgPj0gMCkge1xuICAgICAgICAgICAgYWR2YW5jZShjb25kaXRpb25hbEVuZCArIDIpO1xuICAgICAgICAgICAgY29udGludWVcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBEb2N0eXBlOlxuICAgICAgICB2YXIgZG9jdHlwZU1hdGNoID0gaHRtbC5tYXRjaChkb2N0eXBlKTtcbiAgICAgICAgaWYgKGRvY3R5cGVNYXRjaCkge1xuICAgICAgICAgIGFkdmFuY2UoZG9jdHlwZU1hdGNoWzBdLmxlbmd0aCk7XG4gICAgICAgICAgY29udGludWVcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEVuZCB0YWc6XG4gICAgICAgIHZhciBlbmRUYWdNYXRjaCA9IGh0bWwubWF0Y2goZW5kVGFnKTtcbiAgICAgICAgaWYgKGVuZFRhZ01hdGNoKSB7XG4gICAgICAgICAgdmFyIGN1ckluZGV4ID0gaW5kZXg7XG4gICAgICAgICAgYWR2YW5jZShlbmRUYWdNYXRjaFswXS5sZW5ndGgpO1xuICAgICAgICAgIHBhcnNlRW5kVGFnKGVuZFRhZ01hdGNoWzFdLCBjdXJJbmRleCwgaW5kZXgpO1xuICAgICAgICAgIGNvbnRpbnVlXG4gICAgICAgIH1cblxuICAgICAgICAvLyBTdGFydCB0YWc6XG4gICAgICAgIHZhciBzdGFydFRhZ01hdGNoID0gcGFyc2VTdGFydFRhZygpO1xuICAgICAgICBpZiAoc3RhcnRUYWdNYXRjaCkge1xuICAgICAgICAgIGhhbmRsZVN0YXJ0VGFnKHN0YXJ0VGFnTWF0Y2gpO1xuICAgICAgICAgIGlmIChzaG91bGRJZ25vcmVGaXJzdE5ld2xpbmUoc3RhcnRUYWdNYXRjaC50YWdOYW1lLCBodG1sKSkge1xuICAgICAgICAgICAgYWR2YW5jZSgxKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgY29udGludWVcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB2YXIgdGV4dCA9ICh2b2lkIDApLCByZXN0ID0gKHZvaWQgMCksIG5leHQgPSAodm9pZCAwKTtcbiAgICAgIGlmICh0ZXh0RW5kID49IDApIHtcbiAgICAgICAgcmVzdCA9IGh0bWwuc2xpY2UodGV4dEVuZCk7XG4gICAgICAgIHdoaWxlIChcbiAgICAgICAgICAhZW5kVGFnLnRlc3QocmVzdCkgJiZcbiAgICAgICAgICAhc3RhcnRUYWdPcGVuLnRlc3QocmVzdCkgJiZcbiAgICAgICAgICAhY29tbWVudC50ZXN0KHJlc3QpICYmXG4gICAgICAgICAgIWNvbmRpdGlvbmFsQ29tbWVudC50ZXN0KHJlc3QpXG4gICAgICAgICkge1xuICAgICAgICAgIC8vIDwgaW4gcGxhaW4gdGV4dCwgYmUgZm9yZ2l2aW5nIGFuZCB0cmVhdCBpdCBhcyB0ZXh0XG4gICAgICAgICAgbmV4dCA9IHJlc3QuaW5kZXhPZignPCcsIDEpO1xuICAgICAgICAgIGlmIChuZXh0IDwgMCkgeyBicmVhayB9XG4gICAgICAgICAgdGV4dEVuZCArPSBuZXh0O1xuICAgICAgICAgIHJlc3QgPSBodG1sLnNsaWNlKHRleHRFbmQpO1xuICAgICAgICB9XG4gICAgICAgIHRleHQgPSBodG1sLnN1YnN0cmluZygwLCB0ZXh0RW5kKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHRleHRFbmQgPCAwKSB7XG4gICAgICAgIHRleHQgPSBodG1sO1xuICAgICAgfVxuXG4gICAgICBpZiAodGV4dCkge1xuICAgICAgICBhZHZhbmNlKHRleHQubGVuZ3RoKTtcbiAgICAgIH1cblxuICAgICAgaWYgKG9wdGlvbnMuY2hhcnMgJiYgdGV4dCkge1xuICAgICAgICBvcHRpb25zLmNoYXJzKHRleHQsIGluZGV4IC0gdGV4dC5sZW5ndGgsIGluZGV4KTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIGVuZFRhZ0xlbmd0aCA9IDA7XG4gICAgICB2YXIgc3RhY2tlZFRhZyA9IGxhc3RUYWcudG9Mb3dlckNhc2UoKTtcbiAgICAgIHZhciByZVN0YWNrZWRUYWcgPSByZUNhY2hlW3N0YWNrZWRUYWddIHx8IChyZUNhY2hlW3N0YWNrZWRUYWddID0gbmV3IFJlZ0V4cCgnKFtcXFxcc1xcXFxTXSo/KSg8LycgKyBzdGFja2VkVGFnICsgJ1tePl0qPiknLCAnaScpKTtcbiAgICAgIHZhciByZXN0JDEgPSBodG1sLnJlcGxhY2UocmVTdGFja2VkVGFnLCBmdW5jdGlvbiAoYWxsLCB0ZXh0LCBlbmRUYWcpIHtcbiAgICAgICAgZW5kVGFnTGVuZ3RoID0gZW5kVGFnLmxlbmd0aDtcbiAgICAgICAgaWYgKCFpc1BsYWluVGV4dEVsZW1lbnQoc3RhY2tlZFRhZykgJiYgc3RhY2tlZFRhZyAhPT0gJ25vc2NyaXB0Jykge1xuICAgICAgICAgIHRleHQgPSB0ZXh0XG4gICAgICAgICAgICAucmVwbGFjZSgvPCFcXC0tKFtcXHNcXFNdKj8pLS0+L2csICckMScpIC8vICM3Mjk4XG4gICAgICAgICAgICAucmVwbGFjZSgvPCFcXFtDREFUQVxcWyhbXFxzXFxTXSo/KV1dPi9nLCAnJDEnKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc2hvdWxkSWdub3JlRmlyc3ROZXdsaW5lKHN0YWNrZWRUYWcsIHRleHQpKSB7XG4gICAgICAgICAgdGV4dCA9IHRleHQuc2xpY2UoMSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9wdGlvbnMuY2hhcnMpIHtcbiAgICAgICAgICBvcHRpb25zLmNoYXJzKHRleHQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAnJ1xuICAgICAgfSk7XG4gICAgICBpbmRleCArPSBodG1sLmxlbmd0aCAtIHJlc3QkMS5sZW5ndGg7XG4gICAgICBodG1sID0gcmVzdCQxO1xuICAgICAgcGFyc2VFbmRUYWcoc3RhY2tlZFRhZywgaW5kZXggLSBlbmRUYWdMZW5ndGgsIGluZGV4KTtcbiAgICB9XG5cbiAgICBpZiAoaHRtbCA9PT0gbGFzdCkge1xuICAgICAgb3B0aW9ucy5jaGFycyAmJiBvcHRpb25zLmNoYXJzKGh0bWwpO1xuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgIXN0YWNrLmxlbmd0aCAmJiBvcHRpb25zLndhcm4pIHtcbiAgICAgICAgb3B0aW9ucy53YXJuKChcIk1hbC1mb3JtYXR0ZWQgdGFnIGF0IGVuZCBvZiB0ZW1wbGF0ZTogXFxcIlwiICsgaHRtbCArIFwiXFxcIlwiKSwgeyBzdGFydDogaW5kZXggKyBodG1sLmxlbmd0aCB9KTtcbiAgICAgIH1cbiAgICAgIGJyZWFrXG4gICAgfVxuICB9XG5cbiAgLy8gQ2xlYW4gdXAgYW55IHJlbWFpbmluZyB0YWdzXG4gIHBhcnNlRW5kVGFnKCk7XG5cbiAgZnVuY3Rpb24gYWR2YW5jZSAobikge1xuICAgIGluZGV4ICs9IG47XG4gICAgaHRtbCA9IGh0bWwuc3Vic3RyaW5nKG4pO1xuICB9XG5cbiAgZnVuY3Rpb24gcGFyc2VTdGFydFRhZyAoKSB7XG4gICAgdmFyIHN0YXJ0ID0gaHRtbC5tYXRjaChzdGFydFRhZ09wZW4pO1xuICAgIGlmIChzdGFydCkge1xuICAgICAgdmFyIG1hdGNoID0ge1xuICAgICAgICB0YWdOYW1lOiBzdGFydFsxXSxcbiAgICAgICAgYXR0cnM6IFtdLFxuICAgICAgICBzdGFydDogaW5kZXhcbiAgICAgIH07XG4gICAgICBhZHZhbmNlKHN0YXJ0WzBdLmxlbmd0aCk7XG4gICAgICB2YXIgZW5kLCBhdHRyO1xuICAgICAgd2hpbGUgKCEoZW5kID0gaHRtbC5tYXRjaChzdGFydFRhZ0Nsb3NlKSkgJiYgKGF0dHIgPSBodG1sLm1hdGNoKGR5bmFtaWNBcmdBdHRyaWJ1dGUpIHx8IGh0bWwubWF0Y2goYXR0cmlidXRlKSkpIHtcbiAgICAgICAgYXR0ci5zdGFydCA9IGluZGV4O1xuICAgICAgICBhZHZhbmNlKGF0dHJbMF0ubGVuZ3RoKTtcbiAgICAgICAgYXR0ci5lbmQgPSBpbmRleDtcbiAgICAgICAgbWF0Y2guYXR0cnMucHVzaChhdHRyKTtcbiAgICAgIH1cbiAgICAgIGlmIChlbmQpIHtcbiAgICAgICAgbWF0Y2gudW5hcnlTbGFzaCA9IGVuZFsxXTtcbiAgICAgICAgYWR2YW5jZShlbmRbMF0ubGVuZ3RoKTtcbiAgICAgICAgbWF0Y2guZW5kID0gaW5kZXg7XG4gICAgICAgIHJldHVybiBtYXRjaFxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGhhbmRsZVN0YXJ0VGFnIChtYXRjaCkge1xuICAgIHZhciB0YWdOYW1lID0gbWF0Y2gudGFnTmFtZTtcbiAgICB2YXIgdW5hcnlTbGFzaCA9IG1hdGNoLnVuYXJ5U2xhc2g7XG5cbiAgICBpZiAoZXhwZWN0SFRNTCkge1xuICAgICAgaWYgKGxhc3RUYWcgPT09ICdwJyAmJiBpc05vblBocmFzaW5nVGFnKHRhZ05hbWUpKSB7XG4gICAgICAgIHBhcnNlRW5kVGFnKGxhc3RUYWcpO1xuICAgICAgfVxuICAgICAgaWYgKGNhbkJlTGVmdE9wZW5UYWckJDEodGFnTmFtZSkgJiYgbGFzdFRhZyA9PT0gdGFnTmFtZSkge1xuICAgICAgICBwYXJzZUVuZFRhZyh0YWdOYW1lKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgdW5hcnkgPSBpc1VuYXJ5VGFnJCQxKHRhZ05hbWUpIHx8ICEhdW5hcnlTbGFzaDtcblxuICAgIHZhciBsID0gbWF0Y2guYXR0cnMubGVuZ3RoO1xuICAgIHZhciBhdHRycyA9IG5ldyBBcnJheShsKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGw7IGkrKykge1xuICAgICAgdmFyIGFyZ3MgPSBtYXRjaC5hdHRyc1tpXTtcbiAgICAgIHZhciB2YWx1ZSA9IGFyZ3NbM10gfHwgYXJnc1s0XSB8fCBhcmdzWzVdIHx8ICcnO1xuICAgICAgdmFyIHNob3VsZERlY29kZU5ld2xpbmVzID0gdGFnTmFtZSA9PT0gJ2EnICYmIGFyZ3NbMV0gPT09ICdocmVmJ1xuICAgICAgICA/IG9wdGlvbnMuc2hvdWxkRGVjb2RlTmV3bGluZXNGb3JIcmVmXG4gICAgICAgIDogb3B0aW9ucy5zaG91bGREZWNvZGVOZXdsaW5lcztcbiAgICAgIGF0dHJzW2ldID0ge1xuICAgICAgICBuYW1lOiBhcmdzWzFdLFxuICAgICAgICB2YWx1ZTogZGVjb2RlQXR0cih2YWx1ZSwgc2hvdWxkRGVjb2RlTmV3bGluZXMpXG4gICAgICB9O1xuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgb3B0aW9ucy5vdXRwdXRTb3VyY2VSYW5nZSkge1xuICAgICAgICBhdHRyc1tpXS5zdGFydCA9IGFyZ3Muc3RhcnQgKyBhcmdzWzBdLm1hdGNoKC9eXFxzKi8pLmxlbmd0aDtcbiAgICAgICAgYXR0cnNbaV0uZW5kID0gYXJncy5lbmQ7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKCF1bmFyeSkge1xuICAgICAgc3RhY2sucHVzaCh7IHRhZzogdGFnTmFtZSwgbG93ZXJDYXNlZFRhZzogdGFnTmFtZS50b0xvd2VyQ2FzZSgpLCBhdHRyczogYXR0cnMsIHN0YXJ0OiBtYXRjaC5zdGFydCwgZW5kOiBtYXRjaC5lbmQgfSk7XG4gICAgICBsYXN0VGFnID0gdGFnTmFtZTtcbiAgICB9XG5cbiAgICBpZiAob3B0aW9ucy5zdGFydCkge1xuICAgICAgb3B0aW9ucy5zdGFydCh0YWdOYW1lLCBhdHRycywgdW5hcnksIG1hdGNoLnN0YXJ0LCBtYXRjaC5lbmQpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHBhcnNlRW5kVGFnICh0YWdOYW1lLCBzdGFydCwgZW5kKSB7XG4gICAgdmFyIHBvcywgbG93ZXJDYXNlZFRhZ05hbWU7XG4gICAgaWYgKHN0YXJ0ID09IG51bGwpIHsgc3RhcnQgPSBpbmRleDsgfVxuICAgIGlmIChlbmQgPT0gbnVsbCkgeyBlbmQgPSBpbmRleDsgfVxuXG4gICAgLy8gRmluZCB0aGUgY2xvc2VzdCBvcGVuZWQgdGFnIG9mIHRoZSBzYW1lIHR5cGVcbiAgICBpZiAodGFnTmFtZSkge1xuICAgICAgbG93ZXJDYXNlZFRhZ05hbWUgPSB0YWdOYW1lLnRvTG93ZXJDYXNlKCk7XG4gICAgICBmb3IgKHBvcyA9IHN0YWNrLmxlbmd0aCAtIDE7IHBvcyA+PSAwOyBwb3MtLSkge1xuICAgICAgICBpZiAoc3RhY2tbcG9zXS5sb3dlckNhc2VkVGFnID09PSBsb3dlckNhc2VkVGFnTmFtZSkge1xuICAgICAgICAgIGJyZWFrXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gSWYgbm8gdGFnIG5hbWUgaXMgcHJvdmlkZWQsIGNsZWFuIHNob3BcbiAgICAgIHBvcyA9IDA7XG4gICAgfVxuXG4gICAgaWYgKHBvcyA+PSAwKSB7XG4gICAgICAvLyBDbG9zZSBhbGwgdGhlIG9wZW4gZWxlbWVudHMsIHVwIHRoZSBzdGFja1xuICAgICAgZm9yICh2YXIgaSA9IHN0YWNrLmxlbmd0aCAtIDE7IGkgPj0gcG9zOyBpLS0pIHtcbiAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiZcbiAgICAgICAgICAoaSA+IHBvcyB8fCAhdGFnTmFtZSkgJiZcbiAgICAgICAgICBvcHRpb25zLndhcm5cbiAgICAgICAgKSB7XG4gICAgICAgICAgb3B0aW9ucy53YXJuKFxuICAgICAgICAgICAgKFwidGFnIDxcIiArIChzdGFja1tpXS50YWcpICsgXCI+IGhhcyBubyBtYXRjaGluZyBlbmQgdGFnLlwiKSxcbiAgICAgICAgICAgIHsgc3RhcnQ6IHN0YWNrW2ldLnN0YXJ0LCBlbmQ6IHN0YWNrW2ldLmVuZCB9XG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAob3B0aW9ucy5lbmQpIHtcbiAgICAgICAgICBvcHRpb25zLmVuZChzdGFja1tpXS50YWcsIHN0YXJ0LCBlbmQpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIFJlbW92ZSB0aGUgb3BlbiBlbGVtZW50cyBmcm9tIHRoZSBzdGFja1xuICAgICAgc3RhY2subGVuZ3RoID0gcG9zO1xuICAgICAgbGFzdFRhZyA9IHBvcyAmJiBzdGFja1twb3MgLSAxXS50YWc7XG4gICAgfSBlbHNlIGlmIChsb3dlckNhc2VkVGFnTmFtZSA9PT0gJ2JyJykge1xuICAgICAgaWYgKG9wdGlvbnMuc3RhcnQpIHtcbiAgICAgICAgb3B0aW9ucy5zdGFydCh0YWdOYW1lLCBbXSwgdHJ1ZSwgc3RhcnQsIGVuZCk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChsb3dlckNhc2VkVGFnTmFtZSA9PT0gJ3AnKSB7XG4gICAgICBpZiAob3B0aW9ucy5zdGFydCkge1xuICAgICAgICBvcHRpb25zLnN0YXJ0KHRhZ05hbWUsIFtdLCBmYWxzZSwgc3RhcnQsIGVuZCk7XG4gICAgICB9XG4gICAgICBpZiAob3B0aW9ucy5lbmQpIHtcbiAgICAgICAgb3B0aW9ucy5lbmQodGFnTmFtZSwgc3RhcnQsIGVuZCk7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbi8qICAqL1xuXG52YXIgb25SRSA9IC9eQHxedi1vbjovO1xudmFyIGRpclJFID0gL152LXxeQHxeOnxeIy87XG52YXIgZm9yQWxpYXNSRSA9IC8oW1xcc1xcU10qPylcXHMrKD86aW58b2YpXFxzKyhbXFxzXFxTXSopLztcbnZhciBmb3JJdGVyYXRvclJFID0gLywoW14sXFx9XFxdXSopKD86LChbXixcXH1cXF1dKikpPyQvO1xudmFyIHN0cmlwUGFyZW5zUkUgPSAvXlxcKHxcXCkkL2c7XG52YXIgZHluYW1pY0FyZ1JFID0gL15cXFsuKlxcXSQvO1xuXG52YXIgYXJnUkUgPSAvOiguKikkLztcbnZhciBiaW5kUkUgPSAvXjp8XlxcLnxedi1iaW5kOi87XG52YXIgbW9kaWZpZXJSRSA9IC9cXC5bXi5cXF1dKyg/PVteXFxdXSokKS9nO1xuXG52YXIgc2xvdFJFID0gL152LXNsb3QoOnwkKXxeIy87XG5cbnZhciBsaW5lQnJlYWtSRSA9IC9bXFxyXFxuXS87XG52YXIgd2hpdGVzcGFjZVJFJDEgPSAvWyBcXGZcXHRcXHJcXG5dKy9nO1xuXG52YXIgaW52YWxpZEF0dHJpYnV0ZVJFID0gL1tcXHNcIic8PlxcLz1dLztcblxudmFyIGRlY29kZUhUTUxDYWNoZWQgPSBjYWNoZWQoaGUuZGVjb2RlKTtcblxudmFyIGVtcHR5U2xvdFNjb3BlVG9rZW4gPSBcIl9lbXB0eV9cIjtcblxuLy8gY29uZmlndXJhYmxlIHN0YXRlXG52YXIgd2FybiQyO1xudmFyIGRlbGltaXRlcnM7XG52YXIgdHJhbnNmb3JtcztcbnZhciBwcmVUcmFuc2Zvcm1zO1xudmFyIHBvc3RUcmFuc2Zvcm1zO1xudmFyIHBsYXRmb3JtSXNQcmVUYWc7XG52YXIgcGxhdGZvcm1NdXN0VXNlUHJvcDtcbnZhciBwbGF0Zm9ybUdldFRhZ05hbWVzcGFjZTtcbnZhciBtYXliZUNvbXBvbmVudDtcblxuZnVuY3Rpb24gY3JlYXRlQVNURWxlbWVudCAoXG4gIHRhZyxcbiAgYXR0cnMsXG4gIHBhcmVudFxuKSB7XG4gIHJldHVybiB7XG4gICAgdHlwZTogMSxcbiAgICB0YWc6IHRhZyxcbiAgICBhdHRyc0xpc3Q6IGF0dHJzLFxuICAgIGF0dHJzTWFwOiBtYWtlQXR0cnNNYXAoYXR0cnMpLFxuICAgIHJhd0F0dHJzTWFwOiB7fSxcbiAgICBwYXJlbnQ6IHBhcmVudCxcbiAgICBjaGlsZHJlbjogW11cbiAgfVxufVxuXG4vKipcbiAqIENvbnZlcnQgSFRNTCBzdHJpbmcgdG8gQVNULlxuICovXG5mdW5jdGlvbiBwYXJzZSAoXG4gIHRlbXBsYXRlLFxuICBvcHRpb25zXG4pIHtcbiAgd2FybiQyID0gb3B0aW9ucy53YXJuIHx8IGJhc2VXYXJuO1xuXG4gIHBsYXRmb3JtSXNQcmVUYWcgPSBvcHRpb25zLmlzUHJlVGFnIHx8IG5vO1xuICBwbGF0Zm9ybU11c3RVc2VQcm9wID0gb3B0aW9ucy5tdXN0VXNlUHJvcCB8fCBubztcbiAgcGxhdGZvcm1HZXRUYWdOYW1lc3BhY2UgPSBvcHRpb25zLmdldFRhZ05hbWVzcGFjZSB8fCBubztcbiAgdmFyIGlzUmVzZXJ2ZWRUYWcgPSBvcHRpb25zLmlzUmVzZXJ2ZWRUYWcgfHwgbm87XG4gIG1heWJlQ29tcG9uZW50ID0gZnVuY3Rpb24gKGVsKSB7IHJldHVybiAhIShcbiAgICBlbC5jb21wb25lbnQgfHxcbiAgICBlbC5hdHRyc01hcFsnOmlzJ10gfHxcbiAgICBlbC5hdHRyc01hcFsndi1iaW5kOmlzJ10gfHxcbiAgICAhKGVsLmF0dHJzTWFwLmlzID8gaXNSZXNlcnZlZFRhZyhlbC5hdHRyc01hcC5pcykgOiBpc1Jlc2VydmVkVGFnKGVsLnRhZykpXG4gICk7IH07XG4gIHRyYW5zZm9ybXMgPSBwbHVja01vZHVsZUZ1bmN0aW9uKG9wdGlvbnMubW9kdWxlcywgJ3RyYW5zZm9ybU5vZGUnKTtcbiAgcHJlVHJhbnNmb3JtcyA9IHBsdWNrTW9kdWxlRnVuY3Rpb24ob3B0aW9ucy5tb2R1bGVzLCAncHJlVHJhbnNmb3JtTm9kZScpO1xuICBwb3N0VHJhbnNmb3JtcyA9IHBsdWNrTW9kdWxlRnVuY3Rpb24ob3B0aW9ucy5tb2R1bGVzLCAncG9zdFRyYW5zZm9ybU5vZGUnKTtcblxuICBkZWxpbWl0ZXJzID0gb3B0aW9ucy5kZWxpbWl0ZXJzO1xuXG4gIHZhciBzdGFjayA9IFtdO1xuICB2YXIgcHJlc2VydmVXaGl0ZXNwYWNlID0gb3B0aW9ucy5wcmVzZXJ2ZVdoaXRlc3BhY2UgIT09IGZhbHNlO1xuICB2YXIgd2hpdGVzcGFjZU9wdGlvbiA9IG9wdGlvbnMud2hpdGVzcGFjZTtcbiAgdmFyIHJvb3Q7XG4gIHZhciBjdXJyZW50UGFyZW50O1xuICB2YXIgaW5WUHJlID0gZmFsc2U7XG4gIHZhciBpblByZSA9IGZhbHNlO1xuICB2YXIgd2FybmVkID0gZmFsc2U7XG5cbiAgZnVuY3Rpb24gd2Fybk9uY2UgKG1zZywgcmFuZ2UpIHtcbiAgICBpZiAoIXdhcm5lZCkge1xuICAgICAgd2FybmVkID0gdHJ1ZTtcbiAgICAgIHdhcm4kMihtc2csIHJhbmdlKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBjbG9zZUVsZW1lbnQgKGVsZW1lbnQpIHtcbiAgICB0cmltRW5kaW5nV2hpdGVzcGFjZShlbGVtZW50KTtcbiAgICBpZiAoIWluVlByZSAmJiAhZWxlbWVudC5wcm9jZXNzZWQpIHtcbiAgICAgIGVsZW1lbnQgPSBwcm9jZXNzRWxlbWVudChlbGVtZW50LCBvcHRpb25zKTtcbiAgICB9XG4gICAgLy8gdHJlZSBtYW5hZ2VtZW50XG4gICAgaWYgKCFzdGFjay5sZW5ndGggJiYgZWxlbWVudCAhPT0gcm9vdCkge1xuICAgICAgLy8gYWxsb3cgcm9vdCBlbGVtZW50cyB3aXRoIHYtaWYsIHYtZWxzZS1pZiBhbmQgdi1lbHNlXG4gICAgICBpZiAocm9vdC5pZiAmJiAoZWxlbWVudC5lbHNlaWYgfHwgZWxlbWVudC5lbHNlKSkge1xuICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICAgIGNoZWNrUm9vdENvbnN0cmFpbnRzKGVsZW1lbnQpO1xuICAgICAgICB9XG4gICAgICAgIGFkZElmQ29uZGl0aW9uKHJvb3QsIHtcbiAgICAgICAgICBleHA6IGVsZW1lbnQuZWxzZWlmLFxuICAgICAgICAgIGJsb2NrOiBlbGVtZW50XG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgIHdhcm5PbmNlKFxuICAgICAgICAgIFwiQ29tcG9uZW50IHRlbXBsYXRlIHNob3VsZCBjb250YWluIGV4YWN0bHkgb25lIHJvb3QgZWxlbWVudC4gXCIgK1xuICAgICAgICAgIFwiSWYgeW91IGFyZSB1c2luZyB2LWlmIG9uIG11bHRpcGxlIGVsZW1lbnRzLCBcIiArXG4gICAgICAgICAgXCJ1c2Ugdi1lbHNlLWlmIHRvIGNoYWluIHRoZW0gaW5zdGVhZC5cIixcbiAgICAgICAgICB7IHN0YXJ0OiBlbGVtZW50LnN0YXJ0IH1cbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGN1cnJlbnRQYXJlbnQgJiYgIWVsZW1lbnQuZm9yYmlkZGVuKSB7XG4gICAgICBpZiAoZWxlbWVudC5lbHNlaWYgfHwgZWxlbWVudC5lbHNlKSB7XG4gICAgICAgIHByb2Nlc3NJZkNvbmRpdGlvbnMoZWxlbWVudCwgY3VycmVudFBhcmVudCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoZWxlbWVudC5zbG90U2NvcGUpIHtcbiAgICAgICAgICAvLyBzY29wZWQgc2xvdFxuICAgICAgICAgIC8vIGtlZXAgaXQgaW4gdGhlIGNoaWxkcmVuIGxpc3Qgc28gdGhhdCB2LWVsc2UoLWlmKSBjb25kaXRpb25zIGNhblxuICAgICAgICAgIC8vIGZpbmQgaXQgYXMgdGhlIHByZXYgbm9kZS5cbiAgICAgICAgICB2YXIgbmFtZSA9IGVsZW1lbnQuc2xvdFRhcmdldCB8fCAnXCJkZWZhdWx0XCInXG4gICAgICAgICAgOyhjdXJyZW50UGFyZW50LnNjb3BlZFNsb3RzIHx8IChjdXJyZW50UGFyZW50LnNjb3BlZFNsb3RzID0ge30pKVtuYW1lXSA9IGVsZW1lbnQ7XG4gICAgICAgIH1cbiAgICAgICAgY3VycmVudFBhcmVudC5jaGlsZHJlbi5wdXNoKGVsZW1lbnQpO1xuICAgICAgICBlbGVtZW50LnBhcmVudCA9IGN1cnJlbnRQYXJlbnQ7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gZmluYWwgY2hpbGRyZW4gY2xlYW51cFxuICAgIC8vIGZpbHRlciBvdXQgc2NvcGVkIHNsb3RzXG4gICAgZWxlbWVudC5jaGlsZHJlbiA9IGVsZW1lbnQuY2hpbGRyZW4uZmlsdGVyKGZ1bmN0aW9uIChjKSB7IHJldHVybiAhKGMpLnNsb3RTY29wZTsgfSk7XG4gICAgLy8gcmVtb3ZlIHRyYWlsaW5nIHdoaXRlc3BhY2Ugbm9kZSBhZ2FpblxuICAgIHRyaW1FbmRpbmdXaGl0ZXNwYWNlKGVsZW1lbnQpO1xuXG4gICAgLy8gY2hlY2sgcHJlIHN0YXRlXG4gICAgaWYgKGVsZW1lbnQucHJlKSB7XG4gICAgICBpblZQcmUgPSBmYWxzZTtcbiAgICB9XG4gICAgaWYgKHBsYXRmb3JtSXNQcmVUYWcoZWxlbWVudC50YWcpKSB7XG4gICAgICBpblByZSA9IGZhbHNlO1xuICAgIH1cbiAgICAvLyBhcHBseSBwb3N0LXRyYW5zZm9ybXNcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHBvc3RUcmFuc2Zvcm1zLmxlbmd0aDsgaSsrKSB7XG4gICAgICBwb3N0VHJhbnNmb3Jtc1tpXShlbGVtZW50LCBvcHRpb25zKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiB0cmltRW5kaW5nV2hpdGVzcGFjZSAoZWwpIHtcbiAgICAvLyByZW1vdmUgdHJhaWxpbmcgd2hpdGVzcGFjZSBub2RlXG4gICAgaWYgKCFpblByZSkge1xuICAgICAgdmFyIGxhc3ROb2RlO1xuICAgICAgd2hpbGUgKFxuICAgICAgICAobGFzdE5vZGUgPSBlbC5jaGlsZHJlbltlbC5jaGlsZHJlbi5sZW5ndGggLSAxXSkgJiZcbiAgICAgICAgbGFzdE5vZGUudHlwZSA9PT0gMyAmJlxuICAgICAgICBsYXN0Tm9kZS50ZXh0ID09PSAnICdcbiAgICAgICkge1xuICAgICAgICBlbC5jaGlsZHJlbi5wb3AoKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBjaGVja1Jvb3RDb25zdHJhaW50cyAoZWwpIHtcbiAgICBpZiAoZWwudGFnID09PSAnc2xvdCcgfHwgZWwudGFnID09PSAndGVtcGxhdGUnKSB7XG4gICAgICB3YXJuT25jZShcbiAgICAgICAgXCJDYW5ub3QgdXNlIDxcIiArIChlbC50YWcpICsgXCI+IGFzIGNvbXBvbmVudCByb290IGVsZW1lbnQgYmVjYXVzZSBpdCBtYXkgXCIgK1xuICAgICAgICAnY29udGFpbiBtdWx0aXBsZSBub2Rlcy4nLFxuICAgICAgICB7IHN0YXJ0OiBlbC5zdGFydCB9XG4gICAgICApO1xuICAgIH1cbiAgICBpZiAoZWwuYXR0cnNNYXAuaGFzT3duUHJvcGVydHkoJ3YtZm9yJykpIHtcbiAgICAgIHdhcm5PbmNlKFxuICAgICAgICAnQ2Fubm90IHVzZSB2LWZvciBvbiBzdGF0ZWZ1bCBjb21wb25lbnQgcm9vdCBlbGVtZW50IGJlY2F1c2UgJyArXG4gICAgICAgICdpdCByZW5kZXJzIG11bHRpcGxlIGVsZW1lbnRzLicsXG4gICAgICAgIGVsLnJhd0F0dHJzTWFwWyd2LWZvciddXG4gICAgICApO1xuICAgIH1cbiAgfVxuXG4gIHBhcnNlSFRNTCh0ZW1wbGF0ZSwge1xuICAgIHdhcm46IHdhcm4kMixcbiAgICBleHBlY3RIVE1MOiBvcHRpb25zLmV4cGVjdEhUTUwsXG4gICAgaXNVbmFyeVRhZzogb3B0aW9ucy5pc1VuYXJ5VGFnLFxuICAgIGNhbkJlTGVmdE9wZW5UYWc6IG9wdGlvbnMuY2FuQmVMZWZ0T3BlblRhZyxcbiAgICBzaG91bGREZWNvZGVOZXdsaW5lczogb3B0aW9ucy5zaG91bGREZWNvZGVOZXdsaW5lcyxcbiAgICBzaG91bGREZWNvZGVOZXdsaW5lc0ZvckhyZWY6IG9wdGlvbnMuc2hvdWxkRGVjb2RlTmV3bGluZXNGb3JIcmVmLFxuICAgIHNob3VsZEtlZXBDb21tZW50OiBvcHRpb25zLmNvbW1lbnRzLFxuICAgIG91dHB1dFNvdXJjZVJhbmdlOiBvcHRpb25zLm91dHB1dFNvdXJjZVJhbmdlLFxuICAgIHN0YXJ0OiBmdW5jdGlvbiBzdGFydCAodGFnLCBhdHRycywgdW5hcnksIHN0YXJ0JDEsIGVuZCkge1xuICAgICAgLy8gY2hlY2sgbmFtZXNwYWNlLlxuICAgICAgLy8gaW5oZXJpdCBwYXJlbnQgbnMgaWYgdGhlcmUgaXMgb25lXG4gICAgICB2YXIgbnMgPSAoY3VycmVudFBhcmVudCAmJiBjdXJyZW50UGFyZW50Lm5zKSB8fCBwbGF0Zm9ybUdldFRhZ05hbWVzcGFjZSh0YWcpO1xuXG4gICAgICAvLyBoYW5kbGUgSUUgc3ZnIGJ1Z1xuICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICBpZiAoaXNJRSAmJiBucyA9PT0gJ3N2ZycpIHtcbiAgICAgICAgYXR0cnMgPSBndWFyZElFU1ZHQnVnKGF0dHJzKTtcbiAgICAgIH1cblxuICAgICAgdmFyIGVsZW1lbnQgPSBjcmVhdGVBU1RFbGVtZW50KHRhZywgYXR0cnMsIGN1cnJlbnRQYXJlbnQpO1xuICAgICAgaWYgKG5zKSB7XG4gICAgICAgIGVsZW1lbnQubnMgPSBucztcbiAgICAgIH1cblxuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgaWYgKG9wdGlvbnMub3V0cHV0U291cmNlUmFuZ2UpIHtcbiAgICAgICAgICBlbGVtZW50LnN0YXJ0ID0gc3RhcnQkMTtcbiAgICAgICAgICBlbGVtZW50LmVuZCA9IGVuZDtcbiAgICAgICAgICBlbGVtZW50LnJhd0F0dHJzTWFwID0gZWxlbWVudC5hdHRyc0xpc3QucmVkdWNlKGZ1bmN0aW9uIChjdW11bGF0ZWQsIGF0dHIpIHtcbiAgICAgICAgICAgIGN1bXVsYXRlZFthdHRyLm5hbWVdID0gYXR0cjtcbiAgICAgICAgICAgIHJldHVybiBjdW11bGF0ZWRcbiAgICAgICAgICB9LCB7fSk7XG4gICAgICAgIH1cbiAgICAgICAgYXR0cnMuZm9yRWFjaChmdW5jdGlvbiAoYXR0cikge1xuICAgICAgICAgIGlmIChpbnZhbGlkQXR0cmlidXRlUkUudGVzdChhdHRyLm5hbWUpKSB7XG4gICAgICAgICAgICB3YXJuJDIoXG4gICAgICAgICAgICAgIFwiSW52YWxpZCBkeW5hbWljIGFyZ3VtZW50IGV4cHJlc3Npb246IGF0dHJpYnV0ZSBuYW1lcyBjYW5ub3QgY29udGFpbiBcIiArXG4gICAgICAgICAgICAgIFwic3BhY2VzLCBxdW90ZXMsIDwsID4sIC8gb3IgPS5cIixcbiAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHN0YXJ0OiBhdHRyLnN0YXJ0ICsgYXR0ci5uYW1lLmluZGV4T2YoXCJbXCIpLFxuICAgICAgICAgICAgICAgIGVuZDogYXR0ci5zdGFydCArIGF0dHIubmFtZS5sZW5ndGhcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICBpZiAoaXNGb3JiaWRkZW5UYWcoZWxlbWVudCkgJiYgIWlzU2VydmVyUmVuZGVyaW5nKCkpIHtcbiAgICAgICAgZWxlbWVudC5mb3JiaWRkZW4gPSB0cnVlO1xuICAgICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIHdhcm4kMihcbiAgICAgICAgICAnVGVtcGxhdGVzIHNob3VsZCBvbmx5IGJlIHJlc3BvbnNpYmxlIGZvciBtYXBwaW5nIHRoZSBzdGF0ZSB0byB0aGUgJyArXG4gICAgICAgICAgJ1VJLiBBdm9pZCBwbGFjaW5nIHRhZ3Mgd2l0aCBzaWRlLWVmZmVjdHMgaW4geW91ciB0ZW1wbGF0ZXMsIHN1Y2ggYXMgJyArXG4gICAgICAgICAgXCI8XCIgKyB0YWcgKyBcIj5cIiArICcsIGFzIHRoZXkgd2lsbCBub3QgYmUgcGFyc2VkLicsXG4gICAgICAgICAgeyBzdGFydDogZWxlbWVudC5zdGFydCB9XG4gICAgICAgICk7XG4gICAgICB9XG5cbiAgICAgIC8vIGFwcGx5IHByZS10cmFuc2Zvcm1zXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHByZVRyYW5zZm9ybXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgZWxlbWVudCA9IHByZVRyYW5zZm9ybXNbaV0oZWxlbWVudCwgb3B0aW9ucykgfHwgZWxlbWVudDtcbiAgICAgIH1cblxuICAgICAgaWYgKCFpblZQcmUpIHtcbiAgICAgICAgcHJvY2Vzc1ByZShlbGVtZW50KTtcbiAgICAgICAgaWYgKGVsZW1lbnQucHJlKSB7XG4gICAgICAgICAgaW5WUHJlID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKHBsYXRmb3JtSXNQcmVUYWcoZWxlbWVudC50YWcpKSB7XG4gICAgICAgIGluUHJlID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIGlmIChpblZQcmUpIHtcbiAgICAgICAgcHJvY2Vzc1Jhd0F0dHJzKGVsZW1lbnQpO1xuICAgICAgfSBlbHNlIGlmICghZWxlbWVudC5wcm9jZXNzZWQpIHtcbiAgICAgICAgLy8gc3RydWN0dXJhbCBkaXJlY3RpdmVzXG4gICAgICAgIHByb2Nlc3NGb3IoZWxlbWVudCk7XG4gICAgICAgIHByb2Nlc3NJZihlbGVtZW50KTtcbiAgICAgICAgcHJvY2Vzc09uY2UoZWxlbWVudCk7XG4gICAgICB9XG5cbiAgICAgIGlmICghcm9vdCkge1xuICAgICAgICByb290ID0gZWxlbWVudDtcbiAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgICBjaGVja1Jvb3RDb25zdHJhaW50cyhyb290KTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoIXVuYXJ5KSB7XG4gICAgICAgIGN1cnJlbnRQYXJlbnQgPSBlbGVtZW50O1xuICAgICAgICBzdGFjay5wdXNoKGVsZW1lbnQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY2xvc2VFbGVtZW50KGVsZW1lbnQpO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICBlbmQ6IGZ1bmN0aW9uIGVuZCAodGFnLCBzdGFydCwgZW5kJDEpIHtcbiAgICAgIHZhciBlbGVtZW50ID0gc3RhY2tbc3RhY2subGVuZ3RoIC0gMV07XG4gICAgICAvLyBwb3Agc3RhY2tcbiAgICAgIHN0YWNrLmxlbmd0aCAtPSAxO1xuICAgICAgY3VycmVudFBhcmVudCA9IHN0YWNrW3N0YWNrLmxlbmd0aCAtIDFdO1xuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgb3B0aW9ucy5vdXRwdXRTb3VyY2VSYW5nZSkge1xuICAgICAgICBlbGVtZW50LmVuZCA9IGVuZCQxO1xuICAgICAgfVxuICAgICAgY2xvc2VFbGVtZW50KGVsZW1lbnQpO1xuICAgIH0sXG5cbiAgICBjaGFyczogZnVuY3Rpb24gY2hhcnMgKHRleHQsIHN0YXJ0LCBlbmQpIHtcbiAgICAgIGlmICghY3VycmVudFBhcmVudCkge1xuICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICAgIGlmICh0ZXh0ID09PSB0ZW1wbGF0ZSkge1xuICAgICAgICAgICAgd2Fybk9uY2UoXG4gICAgICAgICAgICAgICdDb21wb25lbnQgdGVtcGxhdGUgcmVxdWlyZXMgYSByb290IGVsZW1lbnQsIHJhdGhlciB0aGFuIGp1c3QgdGV4dC4nLFxuICAgICAgICAgICAgICB7IHN0YXJ0OiBzdGFydCB9XG4gICAgICAgICAgICApO1xuICAgICAgICAgIH0gZWxzZSBpZiAoKHRleHQgPSB0ZXh0LnRyaW0oKSkpIHtcbiAgICAgICAgICAgIHdhcm5PbmNlKFxuICAgICAgICAgICAgICAoXCJ0ZXh0IFxcXCJcIiArIHRleHQgKyBcIlxcXCIgb3V0c2lkZSByb290IGVsZW1lbnQgd2lsbCBiZSBpZ25vcmVkLlwiKSxcbiAgICAgICAgICAgICAgeyBzdGFydDogc3RhcnQgfVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG4gICAgICAvLyBJRSB0ZXh0YXJlYSBwbGFjZWhvbGRlciBidWdcbiAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgaWYgKGlzSUUgJiZcbiAgICAgICAgY3VycmVudFBhcmVudC50YWcgPT09ICd0ZXh0YXJlYScgJiZcbiAgICAgICAgY3VycmVudFBhcmVudC5hdHRyc01hcC5wbGFjZWhvbGRlciA9PT0gdGV4dFxuICAgICAgKSB7XG4gICAgICAgIHJldHVyblxuICAgICAgfVxuICAgICAgdmFyIGNoaWxkcmVuID0gY3VycmVudFBhcmVudC5jaGlsZHJlbjtcbiAgICAgIGlmIChpblByZSB8fCB0ZXh0LnRyaW0oKSkge1xuICAgICAgICB0ZXh0ID0gaXNUZXh0VGFnKGN1cnJlbnRQYXJlbnQpID8gdGV4dCA6IGRlY29kZUhUTUxDYWNoZWQodGV4dCk7XG4gICAgICB9IGVsc2UgaWYgKCFjaGlsZHJlbi5sZW5ndGgpIHtcbiAgICAgICAgLy8gcmVtb3ZlIHRoZSB3aGl0ZXNwYWNlLW9ubHkgbm9kZSByaWdodCBhZnRlciBhbiBvcGVuaW5nIHRhZ1xuICAgICAgICB0ZXh0ID0gJyc7XG4gICAgICB9IGVsc2UgaWYgKHdoaXRlc3BhY2VPcHRpb24pIHtcbiAgICAgICAgaWYgKHdoaXRlc3BhY2VPcHRpb24gPT09ICdjb25kZW5zZScpIHtcbiAgICAgICAgICAvLyBpbiBjb25kZW5zZSBtb2RlLCByZW1vdmUgdGhlIHdoaXRlc3BhY2Ugbm9kZSBpZiBpdCBjb250YWluc1xuICAgICAgICAgIC8vIGxpbmUgYnJlYWssIG90aGVyd2lzZSBjb25kZW5zZSB0byBhIHNpbmdsZSBzcGFjZVxuICAgICAgICAgIHRleHQgPSBsaW5lQnJlYWtSRS50ZXN0KHRleHQpID8gJycgOiAnICc7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGV4dCA9ICcgJztcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGV4dCA9IHByZXNlcnZlV2hpdGVzcGFjZSA/ICcgJyA6ICcnO1xuICAgICAgfVxuICAgICAgaWYgKHRleHQpIHtcbiAgICAgICAgaWYgKCFpblByZSAmJiB3aGl0ZXNwYWNlT3B0aW9uID09PSAnY29uZGVuc2UnKSB7XG4gICAgICAgICAgLy8gY29uZGVuc2UgY29uc2VjdXRpdmUgd2hpdGVzcGFjZXMgaW50byBzaW5nbGUgc3BhY2VcbiAgICAgICAgICB0ZXh0ID0gdGV4dC5yZXBsYWNlKHdoaXRlc3BhY2VSRSQxLCAnICcpO1xuICAgICAgICB9XG4gICAgICAgIHZhciByZXM7XG4gICAgICAgIHZhciBjaGlsZDtcbiAgICAgICAgaWYgKCFpblZQcmUgJiYgdGV4dCAhPT0gJyAnICYmIChyZXMgPSBwYXJzZVRleHQodGV4dCwgZGVsaW1pdGVycykpKSB7XG4gICAgICAgICAgY2hpbGQgPSB7XG4gICAgICAgICAgICB0eXBlOiAyLFxuICAgICAgICAgICAgZXhwcmVzc2lvbjogcmVzLmV4cHJlc3Npb24sXG4gICAgICAgICAgICB0b2tlbnM6IHJlcy50b2tlbnMsXG4gICAgICAgICAgICB0ZXh0OiB0ZXh0XG4gICAgICAgICAgfTtcbiAgICAgICAgfSBlbHNlIGlmICh0ZXh0ICE9PSAnICcgfHwgIWNoaWxkcmVuLmxlbmd0aCB8fCBjaGlsZHJlbltjaGlsZHJlbi5sZW5ndGggLSAxXS50ZXh0ICE9PSAnICcpIHtcbiAgICAgICAgICBjaGlsZCA9IHtcbiAgICAgICAgICAgIHR5cGU6IDMsXG4gICAgICAgICAgICB0ZXh0OiB0ZXh0XG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY2hpbGQpIHtcbiAgICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiBvcHRpb25zLm91dHB1dFNvdXJjZVJhbmdlKSB7XG4gICAgICAgICAgICBjaGlsZC5zdGFydCA9IHN0YXJ0O1xuICAgICAgICAgICAgY2hpbGQuZW5kID0gZW5kO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjaGlsZHJlbi5wdXNoKGNoaWxkKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG4gICAgY29tbWVudDogZnVuY3Rpb24gY29tbWVudCAodGV4dCwgc3RhcnQsIGVuZCkge1xuICAgICAgLy8gYWRkaW5nIGFueXRoaW5nIGFzIGEgc2libGluZyB0byB0aGUgcm9vdCBub2RlIGlzIGZvcmJpZGRlblxuICAgICAgLy8gY29tbWVudHMgc2hvdWxkIHN0aWxsIGJlIGFsbG93ZWQsIGJ1dCBpZ25vcmVkXG4gICAgICBpZiAoY3VycmVudFBhcmVudCkge1xuICAgICAgICB2YXIgY2hpbGQgPSB7XG4gICAgICAgICAgdHlwZTogMyxcbiAgICAgICAgICB0ZXh0OiB0ZXh0LFxuICAgICAgICAgIGlzQ29tbWVudDogdHJ1ZVxuICAgICAgICB9O1xuICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiBvcHRpb25zLm91dHB1dFNvdXJjZVJhbmdlKSB7XG4gICAgICAgICAgY2hpbGQuc3RhcnQgPSBzdGFydDtcbiAgICAgICAgICBjaGlsZC5lbmQgPSBlbmQ7XG4gICAgICAgIH1cbiAgICAgICAgY3VycmVudFBhcmVudC5jaGlsZHJlbi5wdXNoKGNoaWxkKTtcbiAgICAgIH1cbiAgICB9XG4gIH0pO1xuICByZXR1cm4gcm9vdFxufVxuXG5mdW5jdGlvbiBwcm9jZXNzUHJlIChlbCkge1xuICBpZiAoZ2V0QW5kUmVtb3ZlQXR0cihlbCwgJ3YtcHJlJykgIT0gbnVsbCkge1xuICAgIGVsLnByZSA9IHRydWU7XG4gIH1cbn1cblxuZnVuY3Rpb24gcHJvY2Vzc1Jhd0F0dHJzIChlbCkge1xuICB2YXIgbGlzdCA9IGVsLmF0dHJzTGlzdDtcbiAgdmFyIGxlbiA9IGxpc3QubGVuZ3RoO1xuICBpZiAobGVuKSB7XG4gICAgdmFyIGF0dHJzID0gZWwuYXR0cnMgPSBuZXcgQXJyYXkobGVuKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICBhdHRyc1tpXSA9IHtcbiAgICAgICAgbmFtZTogbGlzdFtpXS5uYW1lLFxuICAgICAgICB2YWx1ZTogSlNPTi5zdHJpbmdpZnkobGlzdFtpXS52YWx1ZSlcbiAgICAgIH07XG4gICAgICBpZiAobGlzdFtpXS5zdGFydCAhPSBudWxsKSB7XG4gICAgICAgIGF0dHJzW2ldLnN0YXJ0ID0gbGlzdFtpXS5zdGFydDtcbiAgICAgICAgYXR0cnNbaV0uZW5kID0gbGlzdFtpXS5lbmQ7XG4gICAgICB9XG4gICAgfVxuICB9IGVsc2UgaWYgKCFlbC5wcmUpIHtcbiAgICAvLyBub24gcm9vdCBub2RlIGluIHByZSBibG9ja3Mgd2l0aCBubyBhdHRyaWJ1dGVzXG4gICAgZWwucGxhaW4gPSB0cnVlO1xuICB9XG59XG5cbmZ1bmN0aW9uIHByb2Nlc3NFbGVtZW50IChcbiAgZWxlbWVudCxcbiAgb3B0aW9uc1xuKSB7XG4gIHByb2Nlc3NLZXkoZWxlbWVudCk7XG5cbiAgLy8gZGV0ZXJtaW5lIHdoZXRoZXIgdGhpcyBpcyBhIHBsYWluIGVsZW1lbnQgYWZ0ZXJcbiAgLy8gcmVtb3Zpbmcgc3RydWN0dXJhbCBhdHRyaWJ1dGVzXG4gIGVsZW1lbnQucGxhaW4gPSAoXG4gICAgIWVsZW1lbnQua2V5ICYmXG4gICAgIWVsZW1lbnQuc2NvcGVkU2xvdHMgJiZcbiAgICAhZWxlbWVudC5hdHRyc0xpc3QubGVuZ3RoXG4gICk7XG5cbiAgcHJvY2Vzc1JlZihlbGVtZW50KTtcbiAgcHJvY2Vzc1Nsb3RDb250ZW50KGVsZW1lbnQpO1xuICBwcm9jZXNzU2xvdE91dGxldChlbGVtZW50KTtcbiAgcHJvY2Vzc0NvbXBvbmVudChlbGVtZW50KTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCB0cmFuc2Zvcm1zLmxlbmd0aDsgaSsrKSB7XG4gICAgZWxlbWVudCA9IHRyYW5zZm9ybXNbaV0oZWxlbWVudCwgb3B0aW9ucykgfHwgZWxlbWVudDtcbiAgfVxuICBwcm9jZXNzQXR0cnMoZWxlbWVudCk7XG4gIHJldHVybiBlbGVtZW50XG59XG5cbmZ1bmN0aW9uIHByb2Nlc3NLZXkgKGVsKSB7XG4gIHZhciBleHAgPSBnZXRCaW5kaW5nQXR0cihlbCwgJ2tleScpO1xuICBpZiAoZXhwKSB7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIGlmIChlbC50YWcgPT09ICd0ZW1wbGF0ZScpIHtcbiAgICAgICAgd2FybiQyKFxuICAgICAgICAgIFwiPHRlbXBsYXRlPiBjYW5ub3QgYmUga2V5ZWQuIFBsYWNlIHRoZSBrZXkgb24gcmVhbCBlbGVtZW50cyBpbnN0ZWFkLlwiLFxuICAgICAgICAgIGdldFJhd0JpbmRpbmdBdHRyKGVsLCAna2V5JylcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIGlmIChlbC5mb3IpIHtcbiAgICAgICAgdmFyIGl0ZXJhdG9yID0gZWwuaXRlcmF0b3IyIHx8IGVsLml0ZXJhdG9yMTtcbiAgICAgICAgdmFyIHBhcmVudCA9IGVsLnBhcmVudDtcbiAgICAgICAgaWYgKGl0ZXJhdG9yICYmIGl0ZXJhdG9yID09PSBleHAgJiYgcGFyZW50ICYmIHBhcmVudC50YWcgPT09ICd0cmFuc2l0aW9uLWdyb3VwJykge1xuICAgICAgICAgIHdhcm4kMihcbiAgICAgICAgICAgIFwiRG8gbm90IHVzZSB2LWZvciBpbmRleCBhcyBrZXkgb24gPHRyYW5zaXRpb24tZ3JvdXA+IGNoaWxkcmVuLCBcIiArXG4gICAgICAgICAgICBcInRoaXMgaXMgdGhlIHNhbWUgYXMgbm90IHVzaW5nIGtleXMuXCIsXG4gICAgICAgICAgICBnZXRSYXdCaW5kaW5nQXR0cihlbCwgJ2tleScpLFxuICAgICAgICAgICAgdHJ1ZSAvKiB0aXAgKi9cbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGVsLmtleSA9IGV4cDtcbiAgfVxufVxuXG5mdW5jdGlvbiBwcm9jZXNzUmVmIChlbCkge1xuICB2YXIgcmVmID0gZ2V0QmluZGluZ0F0dHIoZWwsICdyZWYnKTtcbiAgaWYgKHJlZikge1xuICAgIGVsLnJlZiA9IHJlZjtcbiAgICBlbC5yZWZJbkZvciA9IGNoZWNrSW5Gb3IoZWwpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHByb2Nlc3NGb3IgKGVsKSB7XG4gIHZhciBleHA7XG4gIGlmICgoZXhwID0gZ2V0QW5kUmVtb3ZlQXR0cihlbCwgJ3YtZm9yJykpKSB7XG4gICAgdmFyIHJlcyA9IHBhcnNlRm9yKGV4cCk7XG4gICAgaWYgKHJlcykge1xuICAgICAgZXh0ZW5kKGVsLCByZXMpO1xuICAgIH0gZWxzZSBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgd2FybiQyKFxuICAgICAgICAoXCJJbnZhbGlkIHYtZm9yIGV4cHJlc3Npb246IFwiICsgZXhwKSxcbiAgICAgICAgZWwucmF3QXR0cnNNYXBbJ3YtZm9yJ11cbiAgICAgICk7XG4gICAgfVxuICB9XG59XG5cblxuXG5mdW5jdGlvbiBwYXJzZUZvciAoZXhwKSB7XG4gIHZhciBpbk1hdGNoID0gZXhwLm1hdGNoKGZvckFsaWFzUkUpO1xuICBpZiAoIWluTWF0Y2gpIHsgcmV0dXJuIH1cbiAgdmFyIHJlcyA9IHt9O1xuICByZXMuZm9yID0gaW5NYXRjaFsyXS50cmltKCk7XG4gIHZhciBhbGlhcyA9IGluTWF0Y2hbMV0udHJpbSgpLnJlcGxhY2Uoc3RyaXBQYXJlbnNSRSwgJycpO1xuICB2YXIgaXRlcmF0b3JNYXRjaCA9IGFsaWFzLm1hdGNoKGZvckl0ZXJhdG9yUkUpO1xuICBpZiAoaXRlcmF0b3JNYXRjaCkge1xuICAgIHJlcy5hbGlhcyA9IGFsaWFzLnJlcGxhY2UoZm9ySXRlcmF0b3JSRSwgJycpLnRyaW0oKTtcbiAgICByZXMuaXRlcmF0b3IxID0gaXRlcmF0b3JNYXRjaFsxXS50cmltKCk7XG4gICAgaWYgKGl0ZXJhdG9yTWF0Y2hbMl0pIHtcbiAgICAgIHJlcy5pdGVyYXRvcjIgPSBpdGVyYXRvck1hdGNoWzJdLnRyaW0oKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgcmVzLmFsaWFzID0gYWxpYXM7XG4gIH1cbiAgcmV0dXJuIHJlc1xufVxuXG5mdW5jdGlvbiBwcm9jZXNzSWYgKGVsKSB7XG4gIHZhciBleHAgPSBnZXRBbmRSZW1vdmVBdHRyKGVsLCAndi1pZicpO1xuICBpZiAoZXhwKSB7XG4gICAgZWwuaWYgPSBleHA7XG4gICAgYWRkSWZDb25kaXRpb24oZWwsIHtcbiAgICAgIGV4cDogZXhwLFxuICAgICAgYmxvY2s6IGVsXG4gICAgfSk7XG4gIH0gZWxzZSB7XG4gICAgaWYgKGdldEFuZFJlbW92ZUF0dHIoZWwsICd2LWVsc2UnKSAhPSBudWxsKSB7XG4gICAgICBlbC5lbHNlID0gdHJ1ZTtcbiAgICB9XG4gICAgdmFyIGVsc2VpZiA9IGdldEFuZFJlbW92ZUF0dHIoZWwsICd2LWVsc2UtaWYnKTtcbiAgICBpZiAoZWxzZWlmKSB7XG4gICAgICBlbC5lbHNlaWYgPSBlbHNlaWY7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHByb2Nlc3NJZkNvbmRpdGlvbnMgKGVsLCBwYXJlbnQpIHtcbiAgdmFyIHByZXYgPSBmaW5kUHJldkVsZW1lbnQocGFyZW50LmNoaWxkcmVuKTtcbiAgaWYgKHByZXYgJiYgcHJldi5pZikge1xuICAgIGFkZElmQ29uZGl0aW9uKHByZXYsIHtcbiAgICAgIGV4cDogZWwuZWxzZWlmLFxuICAgICAgYmxvY2s6IGVsXG4gICAgfSk7XG4gIH0gZWxzZSBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIHdhcm4kMihcbiAgICAgIFwidi1cIiArIChlbC5lbHNlaWYgPyAoJ2Vsc2UtaWY9XCInICsgZWwuZWxzZWlmICsgJ1wiJykgOiAnZWxzZScpICsgXCIgXCIgK1xuICAgICAgXCJ1c2VkIG9uIGVsZW1lbnQgPFwiICsgKGVsLnRhZykgKyBcIj4gd2l0aG91dCBjb3JyZXNwb25kaW5nIHYtaWYuXCIsXG4gICAgICBlbC5yYXdBdHRyc01hcFtlbC5lbHNlaWYgPyAndi1lbHNlLWlmJyA6ICd2LWVsc2UnXVxuICAgICk7XG4gIH1cbn1cblxuZnVuY3Rpb24gZmluZFByZXZFbGVtZW50IChjaGlsZHJlbikge1xuICB2YXIgaSA9IGNoaWxkcmVuLmxlbmd0aDtcbiAgd2hpbGUgKGktLSkge1xuICAgIGlmIChjaGlsZHJlbltpXS50eXBlID09PSAxKSB7XG4gICAgICByZXR1cm4gY2hpbGRyZW5baV1cbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgY2hpbGRyZW5baV0udGV4dCAhPT0gJyAnKSB7XG4gICAgICAgIHdhcm4kMihcbiAgICAgICAgICBcInRleHQgXFxcIlwiICsgKGNoaWxkcmVuW2ldLnRleHQudHJpbSgpKSArIFwiXFxcIiBiZXR3ZWVuIHYtaWYgYW5kIHYtZWxzZSgtaWYpIFwiICtcbiAgICAgICAgICBcIndpbGwgYmUgaWdub3JlZC5cIixcbiAgICAgICAgICBjaGlsZHJlbltpXVxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgY2hpbGRyZW4ucG9wKCk7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGFkZElmQ29uZGl0aW9uIChlbCwgY29uZGl0aW9uKSB7XG4gIGlmICghZWwuaWZDb25kaXRpb25zKSB7XG4gICAgZWwuaWZDb25kaXRpb25zID0gW107XG4gIH1cbiAgZWwuaWZDb25kaXRpb25zLnB1c2goY29uZGl0aW9uKTtcbn1cblxuZnVuY3Rpb24gcHJvY2Vzc09uY2UgKGVsKSB7XG4gIHZhciBvbmNlJCQxID0gZ2V0QW5kUmVtb3ZlQXR0cihlbCwgJ3Ytb25jZScpO1xuICBpZiAob25jZSQkMSAhPSBudWxsKSB7XG4gICAgZWwub25jZSA9IHRydWU7XG4gIH1cbn1cblxuLy8gaGFuZGxlIGNvbnRlbnQgYmVpbmcgcGFzc2VkIHRvIGEgY29tcG9uZW50IGFzIHNsb3QsXG4vLyBlLmcuIDx0ZW1wbGF0ZSBzbG90PVwieHh4XCI+LCA8ZGl2IHNsb3Qtc2NvcGU9XCJ4eHhcIj5cbmZ1bmN0aW9uIHByb2Nlc3NTbG90Q29udGVudCAoZWwpIHtcbiAgdmFyIHNsb3RTY29wZTtcbiAgaWYgKGVsLnRhZyA9PT0gJ3RlbXBsYXRlJykge1xuICAgIHNsb3RTY29wZSA9IGdldEFuZFJlbW92ZUF0dHIoZWwsICdzY29wZScpO1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIHNsb3RTY29wZSkge1xuICAgICAgd2FybiQyKFxuICAgICAgICBcInRoZSBcXFwic2NvcGVcXFwiIGF0dHJpYnV0ZSBmb3Igc2NvcGVkIHNsb3RzIGhhdmUgYmVlbiBkZXByZWNhdGVkIGFuZCBcIiArXG4gICAgICAgIFwicmVwbGFjZWQgYnkgXFxcInNsb3Qtc2NvcGVcXFwiIHNpbmNlIDIuNS4gVGhlIG5ldyBcXFwic2xvdC1zY29wZVxcXCIgYXR0cmlidXRlIFwiICtcbiAgICAgICAgXCJjYW4gYWxzbyBiZSB1c2VkIG9uIHBsYWluIGVsZW1lbnRzIGluIGFkZGl0aW9uIHRvIDx0ZW1wbGF0ZT4gdG8gXCIgK1xuICAgICAgICBcImRlbm90ZSBzY29wZWQgc2xvdHMuXCIsXG4gICAgICAgIGVsLnJhd0F0dHJzTWFwWydzY29wZSddLFxuICAgICAgICB0cnVlXG4gICAgICApO1xuICAgIH1cbiAgICBlbC5zbG90U2NvcGUgPSBzbG90U2NvcGUgfHwgZ2V0QW5kUmVtb3ZlQXR0cihlbCwgJ3Nsb3Qtc2NvcGUnKTtcbiAgfSBlbHNlIGlmICgoc2xvdFNjb3BlID0gZ2V0QW5kUmVtb3ZlQXR0cihlbCwgJ3Nsb3Qtc2NvcGUnKSkpIHtcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiBlbC5hdHRyc01hcFsndi1mb3InXSkge1xuICAgICAgd2FybiQyKFxuICAgICAgICBcIkFtYmlndW91cyBjb21iaW5lZCB1c2FnZSBvZiBzbG90LXNjb3BlIGFuZCB2LWZvciBvbiA8XCIgKyAoZWwudGFnKSArIFwiPiBcIiArXG4gICAgICAgIFwiKHYtZm9yIHRha2VzIGhpZ2hlciBwcmlvcml0eSkuIFVzZSBhIHdyYXBwZXIgPHRlbXBsYXRlPiBmb3IgdGhlIFwiICtcbiAgICAgICAgXCJzY29wZWQgc2xvdCB0byBtYWtlIGl0IGNsZWFyZXIuXCIsXG4gICAgICAgIGVsLnJhd0F0dHJzTWFwWydzbG90LXNjb3BlJ10sXG4gICAgICAgIHRydWVcbiAgICAgICk7XG4gICAgfVxuICAgIGVsLnNsb3RTY29wZSA9IHNsb3RTY29wZTtcbiAgfVxuXG4gIC8vIHNsb3Q9XCJ4eHhcIlxuICB2YXIgc2xvdFRhcmdldCA9IGdldEJpbmRpbmdBdHRyKGVsLCAnc2xvdCcpO1xuICBpZiAoc2xvdFRhcmdldCkge1xuICAgIGVsLnNsb3RUYXJnZXQgPSBzbG90VGFyZ2V0ID09PSAnXCJcIicgPyAnXCJkZWZhdWx0XCInIDogc2xvdFRhcmdldDtcbiAgICBlbC5zbG90VGFyZ2V0RHluYW1pYyA9ICEhKGVsLmF0dHJzTWFwWyc6c2xvdCddIHx8IGVsLmF0dHJzTWFwWyd2LWJpbmQ6c2xvdCddKTtcbiAgICAvLyBwcmVzZXJ2ZSBzbG90IGFzIGFuIGF0dHJpYnV0ZSBmb3IgbmF0aXZlIHNoYWRvdyBET00gY29tcGF0XG4gICAgLy8gb25seSBmb3Igbm9uLXNjb3BlZCBzbG90cy5cbiAgICBpZiAoZWwudGFnICE9PSAndGVtcGxhdGUnICYmICFlbC5zbG90U2NvcGUpIHtcbiAgICAgIGFkZEF0dHIoZWwsICdzbG90Jywgc2xvdFRhcmdldCwgZ2V0UmF3QmluZGluZ0F0dHIoZWwsICdzbG90JykpO1xuICAgIH1cbiAgfVxuXG4gIC8vIDIuNiB2LXNsb3Qgc3ludGF4XG4gIHtcbiAgICBpZiAoZWwudGFnID09PSAndGVtcGxhdGUnKSB7XG4gICAgICAvLyB2LXNsb3Qgb24gPHRlbXBsYXRlPlxuICAgICAgdmFyIHNsb3RCaW5kaW5nID0gZ2V0QW5kUmVtb3ZlQXR0ckJ5UmVnZXgoZWwsIHNsb3RSRSk7XG4gICAgICBpZiAoc2xvdEJpbmRpbmcpIHtcbiAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgICBpZiAoZWwuc2xvdFRhcmdldCB8fCBlbC5zbG90U2NvcGUpIHtcbiAgICAgICAgICAgIHdhcm4kMihcbiAgICAgICAgICAgICAgXCJVbmV4cGVjdGVkIG1peGVkIHVzYWdlIG9mIGRpZmZlcmVudCBzbG90IHN5bnRheGVzLlwiLFxuICAgICAgICAgICAgICBlbFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGVsLnBhcmVudCAmJiAhbWF5YmVDb21wb25lbnQoZWwucGFyZW50KSkge1xuICAgICAgICAgICAgd2FybiQyKFxuICAgICAgICAgICAgICBcIjx0ZW1wbGF0ZSB2LXNsb3Q+IGNhbiBvbmx5IGFwcGVhciBhdCB0aGUgcm9vdCBsZXZlbCBpbnNpZGUgXCIgK1xuICAgICAgICAgICAgICBcInRoZSByZWNlaXZpbmcgY29tcG9uZW50XCIsXG4gICAgICAgICAgICAgIGVsXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB2YXIgcmVmID0gZ2V0U2xvdE5hbWUoc2xvdEJpbmRpbmcpO1xuICAgICAgICB2YXIgbmFtZSA9IHJlZi5uYW1lO1xuICAgICAgICB2YXIgZHluYW1pYyA9IHJlZi5keW5hbWljO1xuICAgICAgICBlbC5zbG90VGFyZ2V0ID0gbmFtZTtcbiAgICAgICAgZWwuc2xvdFRhcmdldER5bmFtaWMgPSBkeW5hbWljO1xuICAgICAgICBlbC5zbG90U2NvcGUgPSBzbG90QmluZGluZy52YWx1ZSB8fCBlbXB0eVNsb3RTY29wZVRva2VuOyAvLyBmb3JjZSBpdCBpbnRvIGEgc2NvcGVkIHNsb3QgZm9yIHBlcmZcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gdi1zbG90IG9uIGNvbXBvbmVudCwgZGVub3RlcyBkZWZhdWx0IHNsb3RcbiAgICAgIHZhciBzbG90QmluZGluZyQxID0gZ2V0QW5kUmVtb3ZlQXR0ckJ5UmVnZXgoZWwsIHNsb3RSRSk7XG4gICAgICBpZiAoc2xvdEJpbmRpbmckMSkge1xuICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICAgIGlmICghbWF5YmVDb21wb25lbnQoZWwpKSB7XG4gICAgICAgICAgICB3YXJuJDIoXG4gICAgICAgICAgICAgIFwidi1zbG90IGNhbiBvbmx5IGJlIHVzZWQgb24gY29tcG9uZW50cyBvciA8dGVtcGxhdGU+LlwiLFxuICAgICAgICAgICAgICBzbG90QmluZGluZyQxXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoZWwuc2xvdFNjb3BlIHx8IGVsLnNsb3RUYXJnZXQpIHtcbiAgICAgICAgICAgIHdhcm4kMihcbiAgICAgICAgICAgICAgXCJVbmV4cGVjdGVkIG1peGVkIHVzYWdlIG9mIGRpZmZlcmVudCBzbG90IHN5bnRheGVzLlwiLFxuICAgICAgICAgICAgICBlbFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGVsLnNjb3BlZFNsb3RzKSB7XG4gICAgICAgICAgICB3YXJuJDIoXG4gICAgICAgICAgICAgIFwiVG8gYXZvaWQgc2NvcGUgYW1iaWd1aXR5LCB0aGUgZGVmYXVsdCBzbG90IHNob3VsZCBhbHNvIHVzZSBcIiArXG4gICAgICAgICAgICAgIFwiPHRlbXBsYXRlPiBzeW50YXggd2hlbiB0aGVyZSBhcmUgb3RoZXIgbmFtZWQgc2xvdHMuXCIsXG4gICAgICAgICAgICAgIHNsb3RCaW5kaW5nJDFcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIGFkZCB0aGUgY29tcG9uZW50J3MgY2hpbGRyZW4gdG8gaXRzIGRlZmF1bHQgc2xvdFxuICAgICAgICB2YXIgc2xvdHMgPSBlbC5zY29wZWRTbG90cyB8fCAoZWwuc2NvcGVkU2xvdHMgPSB7fSk7XG4gICAgICAgIHZhciByZWYkMSA9IGdldFNsb3ROYW1lKHNsb3RCaW5kaW5nJDEpO1xuICAgICAgICB2YXIgbmFtZSQxID0gcmVmJDEubmFtZTtcbiAgICAgICAgdmFyIGR5bmFtaWMkMSA9IHJlZiQxLmR5bmFtaWM7XG4gICAgICAgIHZhciBzbG90Q29udGFpbmVyID0gc2xvdHNbbmFtZSQxXSA9IGNyZWF0ZUFTVEVsZW1lbnQoJ3RlbXBsYXRlJywgW10sIGVsKTtcbiAgICAgICAgc2xvdENvbnRhaW5lci5zbG90VGFyZ2V0ID0gbmFtZSQxO1xuICAgICAgICBzbG90Q29udGFpbmVyLnNsb3RUYXJnZXREeW5hbWljID0gZHluYW1pYyQxO1xuICAgICAgICBzbG90Q29udGFpbmVyLmNoaWxkcmVuID0gZWwuY2hpbGRyZW4uZmlsdGVyKGZ1bmN0aW9uIChjKSB7XG4gICAgICAgICAgaWYgKCFjLnNsb3RTY29wZSkge1xuICAgICAgICAgICAgYy5wYXJlbnQgPSBzbG90Q29udGFpbmVyO1xuICAgICAgICAgICAgcmV0dXJuIHRydWVcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBzbG90Q29udGFpbmVyLnNsb3RTY29wZSA9IHNsb3RCaW5kaW5nJDEudmFsdWUgfHwgZW1wdHlTbG90U2NvcGVUb2tlbjtcbiAgICAgICAgLy8gcmVtb3ZlIGNoaWxkcmVuIGFzIHRoZXkgYXJlIHJldHVybmVkIGZyb20gc2NvcGVkU2xvdHMgbm93XG4gICAgICAgIGVsLmNoaWxkcmVuID0gW107XG4gICAgICAgIC8vIG1hcmsgZWwgbm9uLXBsYWluIHNvIGRhdGEgZ2V0cyBnZW5lcmF0ZWRcbiAgICAgICAgZWwucGxhaW4gPSBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gZ2V0U2xvdE5hbWUgKGJpbmRpbmcpIHtcbiAgdmFyIG5hbWUgPSBiaW5kaW5nLm5hbWUucmVwbGFjZShzbG90UkUsICcnKTtcbiAgaWYgKCFuYW1lKSB7XG4gICAgaWYgKGJpbmRpbmcubmFtZVswXSAhPT0gJyMnKSB7XG4gICAgICBuYW1lID0gJ2RlZmF1bHQnO1xuICAgIH0gZWxzZSBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgd2FybiQyKFxuICAgICAgICBcInYtc2xvdCBzaG9ydGhhbmQgc3ludGF4IHJlcXVpcmVzIGEgc2xvdCBuYW1lLlwiLFxuICAgICAgICBiaW5kaW5nXG4gICAgICApO1xuICAgIH1cbiAgfVxuICByZXR1cm4gZHluYW1pY0FyZ1JFLnRlc3QobmFtZSlcbiAgICAvLyBkeW5hbWljIFtuYW1lXVxuICAgID8geyBuYW1lOiBuYW1lLnNsaWNlKDEsIC0xKSwgZHluYW1pYzogdHJ1ZSB9XG4gICAgLy8gc3RhdGljIG5hbWVcbiAgICA6IHsgbmFtZTogKFwiXFxcIlwiICsgbmFtZSArIFwiXFxcIlwiKSwgZHluYW1pYzogZmFsc2UgfVxufVxuXG4vLyBoYW5kbGUgPHNsb3QvPiBvdXRsZXRzXG5mdW5jdGlvbiBwcm9jZXNzU2xvdE91dGxldCAoZWwpIHtcbiAgaWYgKGVsLnRhZyA9PT0gJ3Nsb3QnKSB7XG4gICAgZWwuc2xvdE5hbWUgPSBnZXRCaW5kaW5nQXR0cihlbCwgJ25hbWUnKTtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiBlbC5rZXkpIHtcbiAgICAgIHdhcm4kMihcbiAgICAgICAgXCJga2V5YCBkb2VzIG5vdCB3b3JrIG9uIDxzbG90PiBiZWNhdXNlIHNsb3RzIGFyZSBhYnN0cmFjdCBvdXRsZXRzIFwiICtcbiAgICAgICAgXCJhbmQgY2FuIHBvc3NpYmx5IGV4cGFuZCBpbnRvIG11bHRpcGxlIGVsZW1lbnRzLiBcIiArXG4gICAgICAgIFwiVXNlIHRoZSBrZXkgb24gYSB3cmFwcGluZyBlbGVtZW50IGluc3RlYWQuXCIsXG4gICAgICAgIGdldFJhd0JpbmRpbmdBdHRyKGVsLCAna2V5JylcbiAgICAgICk7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHByb2Nlc3NDb21wb25lbnQgKGVsKSB7XG4gIHZhciBiaW5kaW5nO1xuICBpZiAoKGJpbmRpbmcgPSBnZXRCaW5kaW5nQXR0cihlbCwgJ2lzJykpKSB7XG4gICAgZWwuY29tcG9uZW50ID0gYmluZGluZztcbiAgfVxuICBpZiAoZ2V0QW5kUmVtb3ZlQXR0cihlbCwgJ2lubGluZS10ZW1wbGF0ZScpICE9IG51bGwpIHtcbiAgICBlbC5pbmxpbmVUZW1wbGF0ZSA9IHRydWU7XG4gIH1cbn1cblxuZnVuY3Rpb24gcHJvY2Vzc0F0dHJzIChlbCkge1xuICB2YXIgbGlzdCA9IGVsLmF0dHJzTGlzdDtcbiAgdmFyIGksIGwsIG5hbWUsIHJhd05hbWUsIHZhbHVlLCBtb2RpZmllcnMsIHN5bmNHZW4sIGlzRHluYW1pYztcbiAgZm9yIChpID0gMCwgbCA9IGxpc3QubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgbmFtZSA9IHJhd05hbWUgPSBsaXN0W2ldLm5hbWU7XG4gICAgdmFsdWUgPSBsaXN0W2ldLnZhbHVlO1xuICAgIGlmIChkaXJSRS50ZXN0KG5hbWUpKSB7XG4gICAgICAvLyBtYXJrIGVsZW1lbnQgYXMgZHluYW1pY1xuICAgICAgZWwuaGFzQmluZGluZ3MgPSB0cnVlO1xuICAgICAgLy8gbW9kaWZpZXJzXG4gICAgICBtb2RpZmllcnMgPSBwYXJzZU1vZGlmaWVycyhuYW1lLnJlcGxhY2UoZGlyUkUsICcnKSk7XG4gICAgICAvLyBzdXBwb3J0IC5mb28gc2hvcnRoYW5kIHN5bnRheCBmb3IgdGhlIC5wcm9wIG1vZGlmaWVyXG4gICAgICBpZiAobW9kaWZpZXJzKSB7XG4gICAgICAgIG5hbWUgPSBuYW1lLnJlcGxhY2UobW9kaWZpZXJSRSwgJycpO1xuICAgICAgfVxuICAgICAgaWYgKGJpbmRSRS50ZXN0KG5hbWUpKSB7IC8vIHYtYmluZFxuICAgICAgICBuYW1lID0gbmFtZS5yZXBsYWNlKGJpbmRSRSwgJycpO1xuICAgICAgICB2YWx1ZSA9IHBhcnNlRmlsdGVycyh2YWx1ZSk7XG4gICAgICAgIGlzRHluYW1pYyA9IGR5bmFtaWNBcmdSRS50ZXN0KG5hbWUpO1xuICAgICAgICBpZiAoaXNEeW5hbWljKSB7XG4gICAgICAgICAgbmFtZSA9IG5hbWUuc2xpY2UoMSwgLTEpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChcbiAgICAgICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmXG4gICAgICAgICAgdmFsdWUudHJpbSgpLmxlbmd0aCA9PT0gMFxuICAgICAgICApIHtcbiAgICAgICAgICB3YXJuJDIoXG4gICAgICAgICAgICAoXCJUaGUgdmFsdWUgZm9yIGEgdi1iaW5kIGV4cHJlc3Npb24gY2Fubm90IGJlIGVtcHR5LiBGb3VuZCBpbiBcXFwidi1iaW5kOlwiICsgbmFtZSArIFwiXFxcIlwiKVxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1vZGlmaWVycykge1xuICAgICAgICAgIGlmIChtb2RpZmllcnMucHJvcCAmJiAhaXNEeW5hbWljKSB7XG4gICAgICAgICAgICBuYW1lID0gY2FtZWxpemUobmFtZSk7XG4gICAgICAgICAgICBpZiAobmFtZSA9PT0gJ2lubmVySHRtbCcpIHsgbmFtZSA9ICdpbm5lckhUTUwnOyB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChtb2RpZmllcnMuY2FtZWwgJiYgIWlzRHluYW1pYykge1xuICAgICAgICAgICAgbmFtZSA9IGNhbWVsaXplKG5hbWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAobW9kaWZpZXJzLnN5bmMpIHtcbiAgICAgICAgICAgIHN5bmNHZW4gPSBnZW5Bc3NpZ25tZW50Q29kZSh2YWx1ZSwgXCIkZXZlbnRcIik7XG4gICAgICAgICAgICBpZiAoIWlzRHluYW1pYykge1xuICAgICAgICAgICAgICBhZGRIYW5kbGVyKFxuICAgICAgICAgICAgICAgIGVsLFxuICAgICAgICAgICAgICAgIChcInVwZGF0ZTpcIiArIChjYW1lbGl6ZShuYW1lKSkpLFxuICAgICAgICAgICAgICAgIHN5bmNHZW4sXG4gICAgICAgICAgICAgICAgbnVsbCxcbiAgICAgICAgICAgICAgICBmYWxzZSxcbiAgICAgICAgICAgICAgICB3YXJuJDIsXG4gICAgICAgICAgICAgICAgbGlzdFtpXVxuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICBpZiAoaHlwaGVuYXRlKG5hbWUpICE9PSBjYW1lbGl6ZShuYW1lKSkge1xuICAgICAgICAgICAgICAgIGFkZEhhbmRsZXIoXG4gICAgICAgICAgICAgICAgICBlbCxcbiAgICAgICAgICAgICAgICAgIChcInVwZGF0ZTpcIiArIChoeXBoZW5hdGUobmFtZSkpKSxcbiAgICAgICAgICAgICAgICAgIHN5bmNHZW4sXG4gICAgICAgICAgICAgICAgICBudWxsLFxuICAgICAgICAgICAgICAgICAgZmFsc2UsXG4gICAgICAgICAgICAgICAgICB3YXJuJDIsXG4gICAgICAgICAgICAgICAgICBsaXN0W2ldXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgLy8gaGFuZGxlciB3LyBkeW5hbWljIGV2ZW50IG5hbWVcbiAgICAgICAgICAgICAgYWRkSGFuZGxlcihcbiAgICAgICAgICAgICAgICBlbCxcbiAgICAgICAgICAgICAgICAoXCJcXFwidXBkYXRlOlxcXCIrKFwiICsgbmFtZSArIFwiKVwiKSxcbiAgICAgICAgICAgICAgICBzeW5jR2VuLFxuICAgICAgICAgICAgICAgIG51bGwsXG4gICAgICAgICAgICAgICAgZmFsc2UsXG4gICAgICAgICAgICAgICAgd2FybiQyLFxuICAgICAgICAgICAgICAgIGxpc3RbaV0sXG4gICAgICAgICAgICAgICAgdHJ1ZSAvLyBkeW5hbWljXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICgobW9kaWZpZXJzICYmIG1vZGlmaWVycy5wcm9wKSB8fCAoXG4gICAgICAgICAgIWVsLmNvbXBvbmVudCAmJiBwbGF0Zm9ybU11c3RVc2VQcm9wKGVsLnRhZywgZWwuYXR0cnNNYXAudHlwZSwgbmFtZSlcbiAgICAgICAgKSkge1xuICAgICAgICAgIGFkZFByb3AoZWwsIG5hbWUsIHZhbHVlLCBsaXN0W2ldLCBpc0R5bmFtaWMpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGFkZEF0dHIoZWwsIG5hbWUsIHZhbHVlLCBsaXN0W2ldLCBpc0R5bmFtaWMpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKG9uUkUudGVzdChuYW1lKSkgeyAvLyB2LW9uXG4gICAgICAgIG5hbWUgPSBuYW1lLnJlcGxhY2Uob25SRSwgJycpO1xuICAgICAgICBpc0R5bmFtaWMgPSBkeW5hbWljQXJnUkUudGVzdChuYW1lKTtcbiAgICAgICAgaWYgKGlzRHluYW1pYykge1xuICAgICAgICAgIG5hbWUgPSBuYW1lLnNsaWNlKDEsIC0xKTtcbiAgICAgICAgfVxuICAgICAgICBhZGRIYW5kbGVyKGVsLCBuYW1lLCB2YWx1ZSwgbW9kaWZpZXJzLCBmYWxzZSwgd2FybiQyLCBsaXN0W2ldLCBpc0R5bmFtaWMpO1xuICAgICAgfSBlbHNlIHsgLy8gbm9ybWFsIGRpcmVjdGl2ZXNcbiAgICAgICAgbmFtZSA9IG5hbWUucmVwbGFjZShkaXJSRSwgJycpO1xuICAgICAgICAvLyBwYXJzZSBhcmdcbiAgICAgICAgdmFyIGFyZ01hdGNoID0gbmFtZS5tYXRjaChhcmdSRSk7XG4gICAgICAgIHZhciBhcmcgPSBhcmdNYXRjaCAmJiBhcmdNYXRjaFsxXTtcbiAgICAgICAgaXNEeW5hbWljID0gZmFsc2U7XG4gICAgICAgIGlmIChhcmcpIHtcbiAgICAgICAgICBuYW1lID0gbmFtZS5zbGljZSgwLCAtKGFyZy5sZW5ndGggKyAxKSk7XG4gICAgICAgICAgaWYgKGR5bmFtaWNBcmdSRS50ZXN0KGFyZykpIHtcbiAgICAgICAgICAgIGFyZyA9IGFyZy5zbGljZSgxLCAtMSk7XG4gICAgICAgICAgICBpc0R5bmFtaWMgPSB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBhZGREaXJlY3RpdmUoZWwsIG5hbWUsIHJhd05hbWUsIHZhbHVlLCBhcmcsIGlzRHluYW1pYywgbW9kaWZpZXJzLCBsaXN0W2ldKTtcbiAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgbmFtZSA9PT0gJ21vZGVsJykge1xuICAgICAgICAgIGNoZWNrRm9yQWxpYXNNb2RlbChlbCwgdmFsdWUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGxpdGVyYWwgYXR0cmlidXRlXG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICB2YXIgcmVzID0gcGFyc2VUZXh0KHZhbHVlLCBkZWxpbWl0ZXJzKTtcbiAgICAgICAgaWYgKHJlcykge1xuICAgICAgICAgIHdhcm4kMihcbiAgICAgICAgICAgIG5hbWUgKyBcIj1cXFwiXCIgKyB2YWx1ZSArIFwiXFxcIjogXCIgK1xuICAgICAgICAgICAgJ0ludGVycG9sYXRpb24gaW5zaWRlIGF0dHJpYnV0ZXMgaGFzIGJlZW4gcmVtb3ZlZC4gJyArXG4gICAgICAgICAgICAnVXNlIHYtYmluZCBvciB0aGUgY29sb24gc2hvcnRoYW5kIGluc3RlYWQuIEZvciBleGFtcGxlLCAnICtcbiAgICAgICAgICAgICdpbnN0ZWFkIG9mIDxkaXYgaWQ9XCJ7eyB2YWwgfX1cIj4sIHVzZSA8ZGl2IDppZD1cInZhbFwiPi4nLFxuICAgICAgICAgICAgbGlzdFtpXVxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGFkZEF0dHIoZWwsIG5hbWUsIEpTT04uc3RyaW5naWZ5KHZhbHVlKSwgbGlzdFtpXSk7XG4gICAgICAvLyAjNjg4NyBmaXJlZm94IGRvZXNuJ3QgdXBkYXRlIG11dGVkIHN0YXRlIGlmIHNldCB2aWEgYXR0cmlidXRlXG4gICAgICAvLyBldmVuIGltbWVkaWF0ZWx5IGFmdGVyIGVsZW1lbnQgY3JlYXRpb25cbiAgICAgIGlmICghZWwuY29tcG9uZW50ICYmXG4gICAgICAgICAgbmFtZSA9PT0gJ211dGVkJyAmJlxuICAgICAgICAgIHBsYXRmb3JtTXVzdFVzZVByb3AoZWwudGFnLCBlbC5hdHRyc01hcC50eXBlLCBuYW1lKSkge1xuICAgICAgICBhZGRQcm9wKGVsLCBuYW1lLCAndHJ1ZScsIGxpc3RbaV0pO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBjaGVja0luRm9yIChlbCkge1xuICB2YXIgcGFyZW50ID0gZWw7XG4gIHdoaWxlIChwYXJlbnQpIHtcbiAgICBpZiAocGFyZW50LmZvciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH1cbiAgICBwYXJlbnQgPSBwYXJlbnQucGFyZW50O1xuICB9XG4gIHJldHVybiBmYWxzZVxufVxuXG5mdW5jdGlvbiBwYXJzZU1vZGlmaWVycyAobmFtZSkge1xuICB2YXIgbWF0Y2ggPSBuYW1lLm1hdGNoKG1vZGlmaWVyUkUpO1xuICBpZiAobWF0Y2gpIHtcbiAgICB2YXIgcmV0ID0ge307XG4gICAgbWF0Y2guZm9yRWFjaChmdW5jdGlvbiAobSkgeyByZXRbbS5zbGljZSgxKV0gPSB0cnVlOyB9KTtcbiAgICByZXR1cm4gcmV0XG4gIH1cbn1cblxuZnVuY3Rpb24gbWFrZUF0dHJzTWFwIChhdHRycykge1xuICB2YXIgbWFwID0ge307XG4gIGZvciAodmFyIGkgPSAwLCBsID0gYXR0cnMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgaWYgKFxuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJlxuICAgICAgbWFwW2F0dHJzW2ldLm5hbWVdICYmICFpc0lFICYmICFpc0VkZ2VcbiAgICApIHtcbiAgICAgIHdhcm4kMignZHVwbGljYXRlIGF0dHJpYnV0ZTogJyArIGF0dHJzW2ldLm5hbWUsIGF0dHJzW2ldKTtcbiAgICB9XG4gICAgbWFwW2F0dHJzW2ldLm5hbWVdID0gYXR0cnNbaV0udmFsdWU7XG4gIH1cbiAgcmV0dXJuIG1hcFxufVxuXG4vLyBmb3Igc2NyaXB0IChlLmcuIHR5cGU9XCJ4L3RlbXBsYXRlXCIpIG9yIHN0eWxlLCBkbyBub3QgZGVjb2RlIGNvbnRlbnRcbmZ1bmN0aW9uIGlzVGV4dFRhZyAoZWwpIHtcbiAgcmV0dXJuIGVsLnRhZyA9PT0gJ3NjcmlwdCcgfHwgZWwudGFnID09PSAnc3R5bGUnXG59XG5cbmZ1bmN0aW9uIGlzRm9yYmlkZGVuVGFnIChlbCkge1xuICByZXR1cm4gKFxuICAgIGVsLnRhZyA9PT0gJ3N0eWxlJyB8fFxuICAgIChlbC50YWcgPT09ICdzY3JpcHQnICYmIChcbiAgICAgICFlbC5hdHRyc01hcC50eXBlIHx8XG4gICAgICBlbC5hdHRyc01hcC50eXBlID09PSAndGV4dC9qYXZhc2NyaXB0J1xuICAgICkpXG4gIClcbn1cblxudmFyIGllTlNCdWcgPSAvXnhtbG5zOk5TXFxkKy87XG52YXIgaWVOU1ByZWZpeCA9IC9eTlNcXGQrOi87XG5cbi8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG5mdW5jdGlvbiBndWFyZElFU1ZHQnVnIChhdHRycykge1xuICB2YXIgcmVzID0gW107XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgYXR0cnMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgYXR0ciA9IGF0dHJzW2ldO1xuICAgIGlmICghaWVOU0J1Zy50ZXN0KGF0dHIubmFtZSkpIHtcbiAgICAgIGF0dHIubmFtZSA9IGF0dHIubmFtZS5yZXBsYWNlKGllTlNQcmVmaXgsICcnKTtcbiAgICAgIHJlcy5wdXNoKGF0dHIpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzXG59XG5cbmZ1bmN0aW9uIGNoZWNrRm9yQWxpYXNNb2RlbCAoZWwsIHZhbHVlKSB7XG4gIHZhciBfZWwgPSBlbDtcbiAgd2hpbGUgKF9lbCkge1xuICAgIGlmIChfZWwuZm9yICYmIF9lbC5hbGlhcyA9PT0gdmFsdWUpIHtcbiAgICAgIHdhcm4kMihcbiAgICAgICAgXCI8XCIgKyAoZWwudGFnKSArIFwiIHYtbW9kZWw9XFxcIlwiICsgdmFsdWUgKyBcIlxcXCI+OiBcIiArXG4gICAgICAgIFwiWW91IGFyZSBiaW5kaW5nIHYtbW9kZWwgZGlyZWN0bHkgdG8gYSB2LWZvciBpdGVyYXRpb24gYWxpYXMuIFwiICtcbiAgICAgICAgXCJUaGlzIHdpbGwgbm90IGJlIGFibGUgdG8gbW9kaWZ5IHRoZSB2LWZvciBzb3VyY2UgYXJyYXkgYmVjYXVzZSBcIiArXG4gICAgICAgIFwid3JpdGluZyB0byB0aGUgYWxpYXMgaXMgbGlrZSBtb2RpZnlpbmcgYSBmdW5jdGlvbiBsb2NhbCB2YXJpYWJsZS4gXCIgK1xuICAgICAgICBcIkNvbnNpZGVyIHVzaW5nIGFuIGFycmF5IG9mIG9iamVjdHMgYW5kIHVzZSB2LW1vZGVsIG9uIGFuIG9iamVjdCBwcm9wZXJ0eSBpbnN0ZWFkLlwiLFxuICAgICAgICBlbC5yYXdBdHRyc01hcFsndi1tb2RlbCddXG4gICAgICApO1xuICAgIH1cbiAgICBfZWwgPSBfZWwucGFyZW50O1xuICB9XG59XG5cbi8qICAqL1xuXG5mdW5jdGlvbiBwcmVUcmFuc2Zvcm1Ob2RlIChlbCwgb3B0aW9ucykge1xuICBpZiAoZWwudGFnID09PSAnaW5wdXQnKSB7XG4gICAgdmFyIG1hcCA9IGVsLmF0dHJzTWFwO1xuICAgIGlmICghbWFwWyd2LW1vZGVsJ10pIHtcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIHZhciB0eXBlQmluZGluZztcbiAgICBpZiAobWFwWyc6dHlwZSddIHx8IG1hcFsndi1iaW5kOnR5cGUnXSkge1xuICAgICAgdHlwZUJpbmRpbmcgPSBnZXRCaW5kaW5nQXR0cihlbCwgJ3R5cGUnKTtcbiAgICB9XG4gICAgaWYgKCFtYXAudHlwZSAmJiAhdHlwZUJpbmRpbmcgJiYgbWFwWyd2LWJpbmQnXSkge1xuICAgICAgdHlwZUJpbmRpbmcgPSBcIihcIiArIChtYXBbJ3YtYmluZCddKSArIFwiKS50eXBlXCI7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVCaW5kaW5nKSB7XG4gICAgICB2YXIgaWZDb25kaXRpb24gPSBnZXRBbmRSZW1vdmVBdHRyKGVsLCAndi1pZicsIHRydWUpO1xuICAgICAgdmFyIGlmQ29uZGl0aW9uRXh0cmEgPSBpZkNvbmRpdGlvbiA/IChcIiYmKFwiICsgaWZDb25kaXRpb24gKyBcIilcIikgOiBcIlwiO1xuICAgICAgdmFyIGhhc0Vsc2UgPSBnZXRBbmRSZW1vdmVBdHRyKGVsLCAndi1lbHNlJywgdHJ1ZSkgIT0gbnVsbDtcbiAgICAgIHZhciBlbHNlSWZDb25kaXRpb24gPSBnZXRBbmRSZW1vdmVBdHRyKGVsLCAndi1lbHNlLWlmJywgdHJ1ZSk7XG4gICAgICAvLyAxLiBjaGVja2JveFxuICAgICAgdmFyIGJyYW5jaDAgPSBjbG9uZUFTVEVsZW1lbnQoZWwpO1xuICAgICAgLy8gcHJvY2VzcyBmb3Igb24gdGhlIG1haW4gbm9kZVxuICAgICAgcHJvY2Vzc0ZvcihicmFuY2gwKTtcbiAgICAgIGFkZFJhd0F0dHIoYnJhbmNoMCwgJ3R5cGUnLCAnY2hlY2tib3gnKTtcbiAgICAgIHByb2Nlc3NFbGVtZW50KGJyYW5jaDAsIG9wdGlvbnMpO1xuICAgICAgYnJhbmNoMC5wcm9jZXNzZWQgPSB0cnVlOyAvLyBwcmV2ZW50IGl0IGZyb20gZG91YmxlLXByb2Nlc3NlZFxuICAgICAgYnJhbmNoMC5pZiA9IFwiKFwiICsgdHlwZUJpbmRpbmcgKyBcIik9PT0nY2hlY2tib3gnXCIgKyBpZkNvbmRpdGlvbkV4dHJhO1xuICAgICAgYWRkSWZDb25kaXRpb24oYnJhbmNoMCwge1xuICAgICAgICBleHA6IGJyYW5jaDAuaWYsXG4gICAgICAgIGJsb2NrOiBicmFuY2gwXG4gICAgICB9KTtcbiAgICAgIC8vIDIuIGFkZCByYWRpbyBlbHNlLWlmIGNvbmRpdGlvblxuICAgICAgdmFyIGJyYW5jaDEgPSBjbG9uZUFTVEVsZW1lbnQoZWwpO1xuICAgICAgZ2V0QW5kUmVtb3ZlQXR0cihicmFuY2gxLCAndi1mb3InLCB0cnVlKTtcbiAgICAgIGFkZFJhd0F0dHIoYnJhbmNoMSwgJ3R5cGUnLCAncmFkaW8nKTtcbiAgICAgIHByb2Nlc3NFbGVtZW50KGJyYW5jaDEsIG9wdGlvbnMpO1xuICAgICAgYWRkSWZDb25kaXRpb24oYnJhbmNoMCwge1xuICAgICAgICBleHA6IFwiKFwiICsgdHlwZUJpbmRpbmcgKyBcIik9PT0ncmFkaW8nXCIgKyBpZkNvbmRpdGlvbkV4dHJhLFxuICAgICAgICBibG9jazogYnJhbmNoMVxuICAgICAgfSk7XG4gICAgICAvLyAzLiBvdGhlclxuICAgICAgdmFyIGJyYW5jaDIgPSBjbG9uZUFTVEVsZW1lbnQoZWwpO1xuICAgICAgZ2V0QW5kUmVtb3ZlQXR0cihicmFuY2gyLCAndi1mb3InLCB0cnVlKTtcbiAgICAgIGFkZFJhd0F0dHIoYnJhbmNoMiwgJzp0eXBlJywgdHlwZUJpbmRpbmcpO1xuICAgICAgcHJvY2Vzc0VsZW1lbnQoYnJhbmNoMiwgb3B0aW9ucyk7XG4gICAgICBhZGRJZkNvbmRpdGlvbihicmFuY2gwLCB7XG4gICAgICAgIGV4cDogaWZDb25kaXRpb24sXG4gICAgICAgIGJsb2NrOiBicmFuY2gyXG4gICAgICB9KTtcblxuICAgICAgaWYgKGhhc0Vsc2UpIHtcbiAgICAgICAgYnJhbmNoMC5lbHNlID0gdHJ1ZTtcbiAgICAgIH0gZWxzZSBpZiAoZWxzZUlmQ29uZGl0aW9uKSB7XG4gICAgICAgIGJyYW5jaDAuZWxzZWlmID0gZWxzZUlmQ29uZGl0aW9uO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gYnJhbmNoMFxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBjbG9uZUFTVEVsZW1lbnQgKGVsKSB7XG4gIHJldHVybiBjcmVhdGVBU1RFbGVtZW50KGVsLnRhZywgZWwuYXR0cnNMaXN0LnNsaWNlKCksIGVsLnBhcmVudClcbn1cblxudmFyIG1vZGVsJDEgPSB7XG4gIHByZVRyYW5zZm9ybU5vZGU6IHByZVRyYW5zZm9ybU5vZGVcbn07XG5cbnZhciBtb2R1bGVzJDEgPSBbXG4gIGtsYXNzJDEsXG4gIHN0eWxlJDEsXG4gIG1vZGVsJDFcbl07XG5cbi8qICAqL1xuXG5mdW5jdGlvbiB0ZXh0IChlbCwgZGlyKSB7XG4gIGlmIChkaXIudmFsdWUpIHtcbiAgICBhZGRQcm9wKGVsLCAndGV4dENvbnRlbnQnLCAoXCJfcyhcIiArIChkaXIudmFsdWUpICsgXCIpXCIpLCBkaXIpO1xuICB9XG59XG5cbi8qICAqL1xuXG5mdW5jdGlvbiBodG1sIChlbCwgZGlyKSB7XG4gIGlmIChkaXIudmFsdWUpIHtcbiAgICBhZGRQcm9wKGVsLCAnaW5uZXJIVE1MJywgKFwiX3MoXCIgKyAoZGlyLnZhbHVlKSArIFwiKVwiKSwgZGlyKTtcbiAgfVxufVxuXG52YXIgZGlyZWN0aXZlcyQxID0ge1xuICBtb2RlbDogbW9kZWwsXG4gIHRleHQ6IHRleHQsXG4gIGh0bWw6IGh0bWxcbn07XG5cbi8qICAqL1xuXG52YXIgYmFzZU9wdGlvbnMgPSB7XG4gIGV4cGVjdEhUTUw6IHRydWUsXG4gIG1vZHVsZXM6IG1vZHVsZXMkMSxcbiAgZGlyZWN0aXZlczogZGlyZWN0aXZlcyQxLFxuICBpc1ByZVRhZzogaXNQcmVUYWcsXG4gIGlzVW5hcnlUYWc6IGlzVW5hcnlUYWcsXG4gIG11c3RVc2VQcm9wOiBtdXN0VXNlUHJvcCxcbiAgY2FuQmVMZWZ0T3BlblRhZzogY2FuQmVMZWZ0T3BlblRhZyxcbiAgaXNSZXNlcnZlZFRhZzogaXNSZXNlcnZlZFRhZyxcbiAgZ2V0VGFnTmFtZXNwYWNlOiBnZXRUYWdOYW1lc3BhY2UsXG4gIHN0YXRpY0tleXM6IGdlblN0YXRpY0tleXMobW9kdWxlcyQxKVxufTtcblxuLyogICovXG5cbnZhciBpc1N0YXRpY0tleTtcbnZhciBpc1BsYXRmb3JtUmVzZXJ2ZWRUYWc7XG5cbnZhciBnZW5TdGF0aWNLZXlzQ2FjaGVkID0gY2FjaGVkKGdlblN0YXRpY0tleXMkMSk7XG5cbi8qKlxuICogR29hbCBvZiB0aGUgb3B0aW1pemVyOiB3YWxrIHRoZSBnZW5lcmF0ZWQgdGVtcGxhdGUgQVNUIHRyZWVcbiAqIGFuZCBkZXRlY3Qgc3ViLXRyZWVzIHRoYXQgYXJlIHB1cmVseSBzdGF0aWMsIGkuZS4gcGFydHMgb2ZcbiAqIHRoZSBET00gdGhhdCBuZXZlciBuZWVkcyB0byBjaGFuZ2UuXG4gKlxuICogT25jZSB3ZSBkZXRlY3QgdGhlc2Ugc3ViLXRyZWVzLCB3ZSBjYW46XG4gKlxuICogMS4gSG9pc3QgdGhlbSBpbnRvIGNvbnN0YW50cywgc28gdGhhdCB3ZSBubyBsb25nZXIgbmVlZCB0b1xuICogICAgY3JlYXRlIGZyZXNoIG5vZGVzIGZvciB0aGVtIG9uIGVhY2ggcmUtcmVuZGVyO1xuICogMi4gQ29tcGxldGVseSBza2lwIHRoZW0gaW4gdGhlIHBhdGNoaW5nIHByb2Nlc3MuXG4gKi9cbmZ1bmN0aW9uIG9wdGltaXplIChyb290LCBvcHRpb25zKSB7XG4gIGlmICghcm9vdCkgeyByZXR1cm4gfVxuICBpc1N0YXRpY0tleSA9IGdlblN0YXRpY0tleXNDYWNoZWQob3B0aW9ucy5zdGF0aWNLZXlzIHx8ICcnKTtcbiAgaXNQbGF0Zm9ybVJlc2VydmVkVGFnID0gb3B0aW9ucy5pc1Jlc2VydmVkVGFnIHx8IG5vO1xuICAvLyBmaXJzdCBwYXNzOiBtYXJrIGFsbCBub24tc3RhdGljIG5vZGVzLlxuICBtYXJrU3RhdGljJDEocm9vdCk7XG4gIC8vIHNlY29uZCBwYXNzOiBtYXJrIHN0YXRpYyByb290cy5cbiAgbWFya1N0YXRpY1Jvb3RzKHJvb3QsIGZhbHNlKTtcbn1cblxuZnVuY3Rpb24gZ2VuU3RhdGljS2V5cyQxIChrZXlzKSB7XG4gIHJldHVybiBtYWtlTWFwKFxuICAgICd0eXBlLHRhZyxhdHRyc0xpc3QsYXR0cnNNYXAscGxhaW4scGFyZW50LGNoaWxkcmVuLGF0dHJzLHN0YXJ0LGVuZCxyYXdBdHRyc01hcCcgK1xuICAgIChrZXlzID8gJywnICsga2V5cyA6ICcnKVxuICApXG59XG5cbmZ1bmN0aW9uIG1hcmtTdGF0aWMkMSAobm9kZSkge1xuICBub2RlLnN0YXRpYyA9IGlzU3RhdGljKG5vZGUpO1xuICBpZiAobm9kZS50eXBlID09PSAxKSB7XG4gICAgLy8gZG8gbm90IG1ha2UgY29tcG9uZW50IHNsb3QgY29udGVudCBzdGF0aWMuIHRoaXMgYXZvaWRzXG4gICAgLy8gMS4gY29tcG9uZW50cyBub3QgYWJsZSB0byBtdXRhdGUgc2xvdCBub2Rlc1xuICAgIC8vIDIuIHN0YXRpYyBzbG90IGNvbnRlbnQgZmFpbHMgZm9yIGhvdC1yZWxvYWRpbmdcbiAgICBpZiAoXG4gICAgICAhaXNQbGF0Zm9ybVJlc2VydmVkVGFnKG5vZGUudGFnKSAmJlxuICAgICAgbm9kZS50YWcgIT09ICdzbG90JyAmJlxuICAgICAgbm9kZS5hdHRyc01hcFsnaW5saW5lLXRlbXBsYXRlJ10gPT0gbnVsbFxuICAgICkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuICAgIGZvciAodmFyIGkgPSAwLCBsID0gbm9kZS5jaGlsZHJlbi5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgIHZhciBjaGlsZCA9IG5vZGUuY2hpbGRyZW5baV07XG4gICAgICBtYXJrU3RhdGljJDEoY2hpbGQpO1xuICAgICAgaWYgKCFjaGlsZC5zdGF0aWMpIHtcbiAgICAgICAgbm9kZS5zdGF0aWMgPSBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKG5vZGUuaWZDb25kaXRpb25zKSB7XG4gICAgICBmb3IgKHZhciBpJDEgPSAxLCBsJDEgPSBub2RlLmlmQ29uZGl0aW9ucy5sZW5ndGg7IGkkMSA8IGwkMTsgaSQxKyspIHtcbiAgICAgICAgdmFyIGJsb2NrID0gbm9kZS5pZkNvbmRpdGlvbnNbaSQxXS5ibG9jaztcbiAgICAgICAgbWFya1N0YXRpYyQxKGJsb2NrKTtcbiAgICAgICAgaWYgKCFibG9jay5zdGF0aWMpIHtcbiAgICAgICAgICBub2RlLnN0YXRpYyA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIG1hcmtTdGF0aWNSb290cyAobm9kZSwgaXNJbkZvcikge1xuICBpZiAobm9kZS50eXBlID09PSAxKSB7XG4gICAgaWYgKG5vZGUuc3RhdGljIHx8IG5vZGUub25jZSkge1xuICAgICAgbm9kZS5zdGF0aWNJbkZvciA9IGlzSW5Gb3I7XG4gICAgfVxuICAgIC8vIEZvciBhIG5vZGUgdG8gcXVhbGlmeSBhcyBhIHN0YXRpYyByb290LCBpdCBzaG91bGQgaGF2ZSBjaGlsZHJlbiB0aGF0XG4gICAgLy8gYXJlIG5vdCBqdXN0IHN0YXRpYyB0ZXh0LiBPdGhlcndpc2UgdGhlIGNvc3Qgb2YgaG9pc3Rpbmcgb3V0IHdpbGxcbiAgICAvLyBvdXR3ZWlnaCB0aGUgYmVuZWZpdHMgYW5kIGl0J3MgYmV0dGVyIG9mZiB0byBqdXN0IGFsd2F5cyByZW5kZXIgaXQgZnJlc2guXG4gICAgaWYgKG5vZGUuc3RhdGljICYmIG5vZGUuY2hpbGRyZW4ubGVuZ3RoICYmICEoXG4gICAgICBub2RlLmNoaWxkcmVuLmxlbmd0aCA9PT0gMSAmJlxuICAgICAgbm9kZS5jaGlsZHJlblswXS50eXBlID09PSAzXG4gICAgKSkge1xuICAgICAgbm9kZS5zdGF0aWNSb290ID0gdHJ1ZTtcbiAgICAgIHJldHVyblxuICAgIH0gZWxzZSB7XG4gICAgICBub2RlLnN0YXRpY1Jvb3QgPSBmYWxzZTtcbiAgICB9XG4gICAgaWYgKG5vZGUuY2hpbGRyZW4pIHtcbiAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gbm9kZS5jaGlsZHJlbi5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgbWFya1N0YXRpY1Jvb3RzKG5vZGUuY2hpbGRyZW5baV0sIGlzSW5Gb3IgfHwgISFub2RlLmZvcik7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChub2RlLmlmQ29uZGl0aW9ucykge1xuICAgICAgZm9yICh2YXIgaSQxID0gMSwgbCQxID0gbm9kZS5pZkNvbmRpdGlvbnMubGVuZ3RoOyBpJDEgPCBsJDE7IGkkMSsrKSB7XG4gICAgICAgIG1hcmtTdGF0aWNSb290cyhub2RlLmlmQ29uZGl0aW9uc1tpJDFdLmJsb2NrLCBpc0luRm9yKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gaXNTdGF0aWMgKG5vZGUpIHtcbiAgaWYgKG5vZGUudHlwZSA9PT0gMikgeyAvLyBleHByZXNzaW9uXG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cbiAgaWYgKG5vZGUudHlwZSA9PT0gMykgeyAvLyB0ZXh0XG4gICAgcmV0dXJuIHRydWVcbiAgfVxuICByZXR1cm4gISEobm9kZS5wcmUgfHwgKFxuICAgICFub2RlLmhhc0JpbmRpbmdzICYmIC8vIG5vIGR5bmFtaWMgYmluZGluZ3NcbiAgICAhbm9kZS5pZiAmJiAhbm9kZS5mb3IgJiYgLy8gbm90IHYtaWYgb3Igdi1mb3Igb3Igdi1lbHNlXG4gICAgIWlzQnVpbHRJblRhZyhub2RlLnRhZykgJiYgLy8gbm90IGEgYnVpbHQtaW5cbiAgICBpc1BsYXRmb3JtUmVzZXJ2ZWRUYWcobm9kZS50YWcpICYmIC8vIG5vdCBhIGNvbXBvbmVudFxuICAgICFpc0RpcmVjdENoaWxkT2ZUZW1wbGF0ZUZvcihub2RlKSAmJlxuICAgIE9iamVjdC5rZXlzKG5vZGUpLmV2ZXJ5KGlzU3RhdGljS2V5KVxuICApKVxufVxuXG5mdW5jdGlvbiBpc0RpcmVjdENoaWxkT2ZUZW1wbGF0ZUZvciAobm9kZSkge1xuICB3aGlsZSAobm9kZS5wYXJlbnQpIHtcbiAgICBub2RlID0gbm9kZS5wYXJlbnQ7XG4gICAgaWYgKG5vZGUudGFnICE9PSAndGVtcGxhdGUnKSB7XG4gICAgICByZXR1cm4gZmFsc2VcbiAgICB9XG4gICAgaWYgKG5vZGUuZm9yKSB7XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH1cbiAgfVxuICByZXR1cm4gZmFsc2Vcbn1cblxuLyogICovXG5cbnZhciBmbkV4cFJFID0gL14oW1xcdyRfXSt8XFwoW14pXSo/XFwpKVxccyo9PnxeZnVuY3Rpb24oPzpcXHMrW1xcdyRdKyk/XFxzKlxcKC87XG52YXIgZm5JbnZva2VSRSA9IC9cXChbXildKj9cXCk7KiQvO1xudmFyIHNpbXBsZVBhdGhSRSA9IC9eW0EtWmEtel8kXVtcXHckXSooPzpcXC5bQS1aYS16XyRdW1xcdyRdKnxcXFsnW14nXSo/J118XFxbXCJbXlwiXSo/XCJdfFxcW1xcZCtdfFxcW1tBLVphLXpfJF1bXFx3JF0qXSkqJC87XG5cbi8vIEtleWJvYXJkRXZlbnQua2V5Q29kZSBhbGlhc2VzXG52YXIga2V5Q29kZXMgPSB7XG4gIGVzYzogMjcsXG4gIHRhYjogOSxcbiAgZW50ZXI6IDEzLFxuICBzcGFjZTogMzIsXG4gIHVwOiAzOCxcbiAgbGVmdDogMzcsXG4gIHJpZ2h0OiAzOSxcbiAgZG93bjogNDAsXG4gICdkZWxldGUnOiBbOCwgNDZdXG59O1xuXG4vLyBLZXlib2FyZEV2ZW50LmtleSBhbGlhc2VzXG52YXIga2V5TmFtZXMgPSB7XG4gIC8vICM3ODgwOiBJRTExIGFuZCBFZGdlIHVzZSBgRXNjYCBmb3IgRXNjYXBlIGtleSBuYW1lLlxuICBlc2M6IFsnRXNjJywgJ0VzY2FwZSddLFxuICB0YWI6ICdUYWInLFxuICBlbnRlcjogJ0VudGVyJyxcbiAgLy8gIzkxMTI6IElFMTEgdXNlcyBgU3BhY2ViYXJgIGZvciBTcGFjZSBrZXkgbmFtZS5cbiAgc3BhY2U6IFsnICcsICdTcGFjZWJhciddLFxuICAvLyAjNzgwNjogSUUxMSB1c2VzIGtleSBuYW1lcyB3aXRob3V0IGBBcnJvd2AgcHJlZml4IGZvciBhcnJvdyBrZXlzLlxuICB1cDogWydVcCcsICdBcnJvd1VwJ10sXG4gIGxlZnQ6IFsnTGVmdCcsICdBcnJvd0xlZnQnXSxcbiAgcmlnaHQ6IFsnUmlnaHQnLCAnQXJyb3dSaWdodCddLFxuICBkb3duOiBbJ0Rvd24nLCAnQXJyb3dEb3duJ10sXG4gIC8vICM5MTEyOiBJRTExIHVzZXMgYERlbGAgZm9yIERlbGV0ZSBrZXkgbmFtZS5cbiAgJ2RlbGV0ZSc6IFsnQmFja3NwYWNlJywgJ0RlbGV0ZScsICdEZWwnXVxufTtcblxuLy8gIzQ4Njg6IG1vZGlmaWVycyB0aGF0IHByZXZlbnQgdGhlIGV4ZWN1dGlvbiBvZiB0aGUgbGlzdGVuZXJcbi8vIG5lZWQgdG8gZXhwbGljaXRseSByZXR1cm4gbnVsbCBzbyB0aGF0IHdlIGNhbiBkZXRlcm1pbmUgd2hldGhlciB0byByZW1vdmVcbi8vIHRoZSBsaXN0ZW5lciBmb3IgLm9uY2VcbnZhciBnZW5HdWFyZCA9IGZ1bmN0aW9uIChjb25kaXRpb24pIHsgcmV0dXJuIChcImlmKFwiICsgY29uZGl0aW9uICsgXCIpcmV0dXJuIG51bGw7XCIpOyB9O1xuXG52YXIgbW9kaWZpZXJDb2RlID0ge1xuICBzdG9wOiAnJGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpOycsXG4gIHByZXZlbnQ6ICckZXZlbnQucHJldmVudERlZmF1bHQoKTsnLFxuICBzZWxmOiBnZW5HdWFyZChcIiRldmVudC50YXJnZXQgIT09ICRldmVudC5jdXJyZW50VGFyZ2V0XCIpLFxuICBjdHJsOiBnZW5HdWFyZChcIiEkZXZlbnQuY3RybEtleVwiKSxcbiAgc2hpZnQ6IGdlbkd1YXJkKFwiISRldmVudC5zaGlmdEtleVwiKSxcbiAgYWx0OiBnZW5HdWFyZChcIiEkZXZlbnQuYWx0S2V5XCIpLFxuICBtZXRhOiBnZW5HdWFyZChcIiEkZXZlbnQubWV0YUtleVwiKSxcbiAgbGVmdDogZ2VuR3VhcmQoXCInYnV0dG9uJyBpbiAkZXZlbnQgJiYgJGV2ZW50LmJ1dHRvbiAhPT0gMFwiKSxcbiAgbWlkZGxlOiBnZW5HdWFyZChcIididXR0b24nIGluICRldmVudCAmJiAkZXZlbnQuYnV0dG9uICE9PSAxXCIpLFxuICByaWdodDogZ2VuR3VhcmQoXCInYnV0dG9uJyBpbiAkZXZlbnQgJiYgJGV2ZW50LmJ1dHRvbiAhPT0gMlwiKVxufTtcblxuZnVuY3Rpb24gZ2VuSGFuZGxlcnMgKFxuICBldmVudHMsXG4gIGlzTmF0aXZlXG4pIHtcbiAgdmFyIHByZWZpeCA9IGlzTmF0aXZlID8gJ25hdGl2ZU9uOicgOiAnb246JztcbiAgdmFyIHN0YXRpY0hhbmRsZXJzID0gXCJcIjtcbiAgdmFyIGR5bmFtaWNIYW5kbGVycyA9IFwiXCI7XG4gIGZvciAodmFyIG5hbWUgaW4gZXZlbnRzKSB7XG4gICAgdmFyIGhhbmRsZXJDb2RlID0gZ2VuSGFuZGxlcihldmVudHNbbmFtZV0pO1xuICAgIGlmIChldmVudHNbbmFtZV0gJiYgZXZlbnRzW25hbWVdLmR5bmFtaWMpIHtcbiAgICAgIGR5bmFtaWNIYW5kbGVycyArPSBuYW1lICsgXCIsXCIgKyBoYW5kbGVyQ29kZSArIFwiLFwiO1xuICAgIH0gZWxzZSB7XG4gICAgICBzdGF0aWNIYW5kbGVycyArPSBcIlxcXCJcIiArIG5hbWUgKyBcIlxcXCI6XCIgKyBoYW5kbGVyQ29kZSArIFwiLFwiO1xuICAgIH1cbiAgfVxuICBzdGF0aWNIYW5kbGVycyA9IFwie1wiICsgKHN0YXRpY0hhbmRsZXJzLnNsaWNlKDAsIC0xKSkgKyBcIn1cIjtcbiAgaWYgKGR5bmFtaWNIYW5kbGVycykge1xuICAgIHJldHVybiBwcmVmaXggKyBcIl9kKFwiICsgc3RhdGljSGFuZGxlcnMgKyBcIixbXCIgKyAoZHluYW1pY0hhbmRsZXJzLnNsaWNlKDAsIC0xKSkgKyBcIl0pXCJcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gcHJlZml4ICsgc3RhdGljSGFuZGxlcnNcbiAgfVxufVxuXG5mdW5jdGlvbiBnZW5IYW5kbGVyIChoYW5kbGVyKSB7XG4gIGlmICghaGFuZGxlcikge1xuICAgIHJldHVybiAnZnVuY3Rpb24oKXt9J1xuICB9XG5cbiAgaWYgKEFycmF5LmlzQXJyYXkoaGFuZGxlcikpIHtcbiAgICByZXR1cm4gKFwiW1wiICsgKGhhbmRsZXIubWFwKGZ1bmN0aW9uIChoYW5kbGVyKSB7IHJldHVybiBnZW5IYW5kbGVyKGhhbmRsZXIpOyB9KS5qb2luKCcsJykpICsgXCJdXCIpXG4gIH1cblxuICB2YXIgaXNNZXRob2RQYXRoID0gc2ltcGxlUGF0aFJFLnRlc3QoaGFuZGxlci52YWx1ZSk7XG4gIHZhciBpc0Z1bmN0aW9uRXhwcmVzc2lvbiA9IGZuRXhwUkUudGVzdChoYW5kbGVyLnZhbHVlKTtcbiAgdmFyIGlzRnVuY3Rpb25JbnZvY2F0aW9uID0gc2ltcGxlUGF0aFJFLnRlc3QoaGFuZGxlci52YWx1ZS5yZXBsYWNlKGZuSW52b2tlUkUsICcnKSk7XG5cbiAgaWYgKCFoYW5kbGVyLm1vZGlmaWVycykge1xuICAgIGlmIChpc01ldGhvZFBhdGggfHwgaXNGdW5jdGlvbkV4cHJlc3Npb24pIHtcbiAgICAgIHJldHVybiBoYW5kbGVyLnZhbHVlXG4gICAgfVxuICAgIHJldHVybiAoXCJmdW5jdGlvbigkZXZlbnQpe1wiICsgKGlzRnVuY3Rpb25JbnZvY2F0aW9uID8gKFwicmV0dXJuIFwiICsgKGhhbmRsZXIudmFsdWUpKSA6IGhhbmRsZXIudmFsdWUpICsgXCJ9XCIpIC8vIGlubGluZSBzdGF0ZW1lbnRcbiAgfSBlbHNlIHtcbiAgICB2YXIgY29kZSA9ICcnO1xuICAgIHZhciBnZW5Nb2RpZmllckNvZGUgPSAnJztcbiAgICB2YXIga2V5cyA9IFtdO1xuICAgIGZvciAodmFyIGtleSBpbiBoYW5kbGVyLm1vZGlmaWVycykge1xuICAgICAgaWYgKG1vZGlmaWVyQ29kZVtrZXldKSB7XG4gICAgICAgIGdlbk1vZGlmaWVyQ29kZSArPSBtb2RpZmllckNvZGVba2V5XTtcbiAgICAgICAgLy8gbGVmdC9yaWdodFxuICAgICAgICBpZiAoa2V5Q29kZXNba2V5XSkge1xuICAgICAgICAgIGtleXMucHVzaChrZXkpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKGtleSA9PT0gJ2V4YWN0Jykge1xuICAgICAgICB2YXIgbW9kaWZpZXJzID0gKGhhbmRsZXIubW9kaWZpZXJzKTtcbiAgICAgICAgZ2VuTW9kaWZpZXJDb2RlICs9IGdlbkd1YXJkKFxuICAgICAgICAgIFsnY3RybCcsICdzaGlmdCcsICdhbHQnLCAnbWV0YSddXG4gICAgICAgICAgICAuZmlsdGVyKGZ1bmN0aW9uIChrZXlNb2RpZmllcikgeyByZXR1cm4gIW1vZGlmaWVyc1trZXlNb2RpZmllcl07IH0pXG4gICAgICAgICAgICAubWFwKGZ1bmN0aW9uIChrZXlNb2RpZmllcikgeyByZXR1cm4gKFwiJGV2ZW50LlwiICsga2V5TW9kaWZpZXIgKyBcIktleVwiKTsgfSlcbiAgICAgICAgICAgIC5qb2luKCd8fCcpXG4gICAgICAgICk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBrZXlzLnB1c2goa2V5KTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGtleXMubGVuZ3RoKSB7XG4gICAgICBjb2RlICs9IGdlbktleUZpbHRlcihrZXlzKTtcbiAgICB9XG4gICAgLy8gTWFrZSBzdXJlIG1vZGlmaWVycyBsaWtlIHByZXZlbnQgYW5kIHN0b3AgZ2V0IGV4ZWN1dGVkIGFmdGVyIGtleSBmaWx0ZXJpbmdcbiAgICBpZiAoZ2VuTW9kaWZpZXJDb2RlKSB7XG4gICAgICBjb2RlICs9IGdlbk1vZGlmaWVyQ29kZTtcbiAgICB9XG4gICAgdmFyIGhhbmRsZXJDb2RlID0gaXNNZXRob2RQYXRoXG4gICAgICA/IChcInJldHVybiBcIiArIChoYW5kbGVyLnZhbHVlKSArIFwiLmFwcGx5KG51bGwsIGFyZ3VtZW50cylcIilcbiAgICAgIDogaXNGdW5jdGlvbkV4cHJlc3Npb25cbiAgICAgICAgPyAoXCJyZXR1cm4gKFwiICsgKGhhbmRsZXIudmFsdWUpICsgXCIpLmFwcGx5KG51bGwsIGFyZ3VtZW50cylcIilcbiAgICAgICAgOiBpc0Z1bmN0aW9uSW52b2NhdGlvblxuICAgICAgICAgID8gKFwicmV0dXJuIFwiICsgKGhhbmRsZXIudmFsdWUpKVxuICAgICAgICAgIDogaGFuZGxlci52YWx1ZTtcbiAgICByZXR1cm4gKFwiZnVuY3Rpb24oJGV2ZW50KXtcIiArIGNvZGUgKyBoYW5kbGVyQ29kZSArIFwifVwiKVxuICB9XG59XG5cbmZ1bmN0aW9uIGdlbktleUZpbHRlciAoa2V5cykge1xuICByZXR1cm4gKFxuICAgIC8vIG1ha2Ugc3VyZSB0aGUga2V5IGZpbHRlcnMgb25seSBhcHBseSB0byBLZXlib2FyZEV2ZW50c1xuICAgIC8vICM5NDQxOiBjYW4ndCB1c2UgJ2tleUNvZGUnIGluICRldmVudCBiZWNhdXNlIENocm9tZSBhdXRvZmlsbCBmaXJlcyBmYWtlXG4gICAgLy8ga2V5IGV2ZW50cyB0aGF0IGRvIG5vdCBoYXZlIGtleUNvZGUgcHJvcGVydHkuLi5cbiAgICBcImlmKCEkZXZlbnQudHlwZS5pbmRleE9mKCdrZXknKSYmXCIgK1xuICAgIChrZXlzLm1hcChnZW5GaWx0ZXJDb2RlKS5qb2luKCcmJicpKSArIFwiKXJldHVybiBudWxsO1wiXG4gIClcbn1cblxuZnVuY3Rpb24gZ2VuRmlsdGVyQ29kZSAoa2V5KSB7XG4gIHZhciBrZXlWYWwgPSBwYXJzZUludChrZXksIDEwKTtcbiAgaWYgKGtleVZhbCkge1xuICAgIHJldHVybiAoXCIkZXZlbnQua2V5Q29kZSE9PVwiICsga2V5VmFsKVxuICB9XG4gIHZhciBrZXlDb2RlID0ga2V5Q29kZXNba2V5XTtcbiAgdmFyIGtleU5hbWUgPSBrZXlOYW1lc1trZXldO1xuICByZXR1cm4gKFxuICAgIFwiX2soJGV2ZW50LmtleUNvZGUsXCIgK1xuICAgIChKU09OLnN0cmluZ2lmeShrZXkpKSArIFwiLFwiICtcbiAgICAoSlNPTi5zdHJpbmdpZnkoa2V5Q29kZSkpICsgXCIsXCIgK1xuICAgIFwiJGV2ZW50LmtleSxcIiArXG4gICAgXCJcIiArIChKU09OLnN0cmluZ2lmeShrZXlOYW1lKSkgK1xuICAgIFwiKVwiXG4gIClcbn1cblxuLyogICovXG5cbmZ1bmN0aW9uIG9uIChlbCwgZGlyKSB7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIGRpci5tb2RpZmllcnMpIHtcbiAgICB3YXJuKFwidi1vbiB3aXRob3V0IGFyZ3VtZW50IGRvZXMgbm90IHN1cHBvcnQgbW9kaWZpZXJzLlwiKTtcbiAgfVxuICBlbC53cmFwTGlzdGVuZXJzID0gZnVuY3Rpb24gKGNvZGUpIHsgcmV0dXJuIChcIl9nKFwiICsgY29kZSArIFwiLFwiICsgKGRpci52YWx1ZSkgKyBcIilcIik7IH07XG59XG5cbi8qICAqL1xuXG5mdW5jdGlvbiBiaW5kJDEgKGVsLCBkaXIpIHtcbiAgZWwud3JhcERhdGEgPSBmdW5jdGlvbiAoY29kZSkge1xuICAgIHJldHVybiAoXCJfYihcIiArIGNvZGUgKyBcIiwnXCIgKyAoZWwudGFnKSArIFwiJyxcIiArIChkaXIudmFsdWUpICsgXCIsXCIgKyAoZGlyLm1vZGlmaWVycyAmJiBkaXIubW9kaWZpZXJzLnByb3AgPyAndHJ1ZScgOiAnZmFsc2UnKSArIChkaXIubW9kaWZpZXJzICYmIGRpci5tb2RpZmllcnMuc3luYyA/ICcsdHJ1ZScgOiAnJykgKyBcIilcIilcbiAgfTtcbn1cblxuLyogICovXG5cbnZhciBiYXNlRGlyZWN0aXZlcyA9IHtcbiAgb246IG9uLFxuICBiaW5kOiBiaW5kJDEsXG4gIGNsb2FrOiBub29wXG59O1xuXG4vKiAgKi9cblxuXG5cblxuXG52YXIgQ29kZWdlblN0YXRlID0gZnVuY3Rpb24gQ29kZWdlblN0YXRlIChvcHRpb25zKSB7XG4gIHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG4gIHRoaXMud2FybiA9IG9wdGlvbnMud2FybiB8fCBiYXNlV2FybjtcbiAgdGhpcy50cmFuc2Zvcm1zID0gcGx1Y2tNb2R1bGVGdW5jdGlvbihvcHRpb25zLm1vZHVsZXMsICd0cmFuc2Zvcm1Db2RlJyk7XG4gIHRoaXMuZGF0YUdlbkZucyA9IHBsdWNrTW9kdWxlRnVuY3Rpb24ob3B0aW9ucy5tb2R1bGVzLCAnZ2VuRGF0YScpO1xuICB0aGlzLmRpcmVjdGl2ZXMgPSBleHRlbmQoZXh0ZW5kKHt9LCBiYXNlRGlyZWN0aXZlcyksIG9wdGlvbnMuZGlyZWN0aXZlcyk7XG4gIHZhciBpc1Jlc2VydmVkVGFnID0gb3B0aW9ucy5pc1Jlc2VydmVkVGFnIHx8IG5vO1xuICB0aGlzLm1heWJlQ29tcG9uZW50ID0gZnVuY3Rpb24gKGVsKSB7IHJldHVybiAhIWVsLmNvbXBvbmVudCB8fCAhaXNSZXNlcnZlZFRhZyhlbC50YWcpOyB9O1xuICB0aGlzLm9uY2VJZCA9IDA7XG4gIHRoaXMuc3RhdGljUmVuZGVyRm5zID0gW107XG4gIHRoaXMucHJlID0gZmFsc2U7XG59O1xuXG5cblxuZnVuY3Rpb24gZ2VuZXJhdGUgKFxuICBhc3QsXG4gIG9wdGlvbnNcbikge1xuICB2YXIgc3RhdGUgPSBuZXcgQ29kZWdlblN0YXRlKG9wdGlvbnMpO1xuICAvLyBmaXggIzExNDgzLCBSb290IGxldmVsIDxzY3JpcHQ+IHRhZ3Mgc2hvdWxkIG5vdCBiZSByZW5kZXJlZC5cbiAgdmFyIGNvZGUgPSBhc3QgPyAoYXN0LnRhZyA9PT0gJ3NjcmlwdCcgPyAnbnVsbCcgOiBnZW5FbGVtZW50KGFzdCwgc3RhdGUpKSA6ICdfYyhcImRpdlwiKSc7XG4gIHJldHVybiB7XG4gICAgcmVuZGVyOiAoXCJ3aXRoKHRoaXMpe3JldHVybiBcIiArIGNvZGUgKyBcIn1cIiksXG4gICAgc3RhdGljUmVuZGVyRm5zOiBzdGF0ZS5zdGF0aWNSZW5kZXJGbnNcbiAgfVxufVxuXG5mdW5jdGlvbiBnZW5FbGVtZW50IChlbCwgc3RhdGUpIHtcbiAgaWYgKGVsLnBhcmVudCkge1xuICAgIGVsLnByZSA9IGVsLnByZSB8fCBlbC5wYXJlbnQucHJlO1xuICB9XG5cbiAgaWYgKGVsLnN0YXRpY1Jvb3QgJiYgIWVsLnN0YXRpY1Byb2Nlc3NlZCkge1xuICAgIHJldHVybiBnZW5TdGF0aWMoZWwsIHN0YXRlKVxuICB9IGVsc2UgaWYgKGVsLm9uY2UgJiYgIWVsLm9uY2VQcm9jZXNzZWQpIHtcbiAgICByZXR1cm4gZ2VuT25jZShlbCwgc3RhdGUpXG4gIH0gZWxzZSBpZiAoZWwuZm9yICYmICFlbC5mb3JQcm9jZXNzZWQpIHtcbiAgICByZXR1cm4gZ2VuRm9yKGVsLCBzdGF0ZSlcbiAgfSBlbHNlIGlmIChlbC5pZiAmJiAhZWwuaWZQcm9jZXNzZWQpIHtcbiAgICByZXR1cm4gZ2VuSWYoZWwsIHN0YXRlKVxuICB9IGVsc2UgaWYgKGVsLnRhZyA9PT0gJ3RlbXBsYXRlJyAmJiAhZWwuc2xvdFRhcmdldCAmJiAhc3RhdGUucHJlKSB7XG4gICAgcmV0dXJuIGdlbkNoaWxkcmVuKGVsLCBzdGF0ZSkgfHwgJ3ZvaWQgMCdcbiAgfSBlbHNlIGlmIChlbC50YWcgPT09ICdzbG90Jykge1xuICAgIHJldHVybiBnZW5TbG90KGVsLCBzdGF0ZSlcbiAgfSBlbHNlIHtcbiAgICAvLyBjb21wb25lbnQgb3IgZWxlbWVudFxuICAgIHZhciBjb2RlO1xuICAgIGlmIChlbC5jb21wb25lbnQpIHtcbiAgICAgIGNvZGUgPSBnZW5Db21wb25lbnQoZWwuY29tcG9uZW50LCBlbCwgc3RhdGUpO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgZGF0YTtcbiAgICAgIGlmICghZWwucGxhaW4gfHwgKGVsLnByZSAmJiBzdGF0ZS5tYXliZUNvbXBvbmVudChlbCkpKSB7XG4gICAgICAgIGRhdGEgPSBnZW5EYXRhJDIoZWwsIHN0YXRlKTtcbiAgICAgIH1cblxuICAgICAgdmFyIGNoaWxkcmVuID0gZWwuaW5saW5lVGVtcGxhdGUgPyBudWxsIDogZ2VuQ2hpbGRyZW4oZWwsIHN0YXRlLCB0cnVlKTtcbiAgICAgIGNvZGUgPSBcIl9jKCdcIiArIChlbC50YWcpICsgXCInXCIgKyAoZGF0YSA/IChcIixcIiArIGRhdGEpIDogJycpICsgKGNoaWxkcmVuID8gKFwiLFwiICsgY2hpbGRyZW4pIDogJycpICsgXCIpXCI7XG4gICAgfVxuICAgIC8vIG1vZHVsZSB0cmFuc2Zvcm1zXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdGF0ZS50cmFuc2Zvcm1zLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb2RlID0gc3RhdGUudHJhbnNmb3Jtc1tpXShlbCwgY29kZSk7XG4gICAgfVxuICAgIHJldHVybiBjb2RlXG4gIH1cbn1cblxuLy8gaG9pc3Qgc3RhdGljIHN1Yi10cmVlcyBvdXRcbmZ1bmN0aW9uIGdlblN0YXRpYyAoZWwsIHN0YXRlKSB7XG4gIGVsLnN0YXRpY1Byb2Nlc3NlZCA9IHRydWU7XG4gIC8vIFNvbWUgZWxlbWVudHMgKHRlbXBsYXRlcykgbmVlZCB0byBiZWhhdmUgZGlmZmVyZW50bHkgaW5zaWRlIG9mIGEgdi1wcmVcbiAgLy8gbm9kZS4gIEFsbCBwcmUgbm9kZXMgYXJlIHN0YXRpYyByb290cywgc28gd2UgY2FuIHVzZSB0aGlzIGFzIGEgbG9jYXRpb24gdG9cbiAgLy8gd3JhcCBhIHN0YXRlIGNoYW5nZSBhbmQgcmVzZXQgaXQgdXBvbiBleGl0aW5nIHRoZSBwcmUgbm9kZS5cbiAgdmFyIG9yaWdpbmFsUHJlU3RhdGUgPSBzdGF0ZS5wcmU7XG4gIGlmIChlbC5wcmUpIHtcbiAgICBzdGF0ZS5wcmUgPSBlbC5wcmU7XG4gIH1cbiAgc3RhdGUuc3RhdGljUmVuZGVyRm5zLnB1c2goKFwid2l0aCh0aGlzKXtyZXR1cm4gXCIgKyAoZ2VuRWxlbWVudChlbCwgc3RhdGUpKSArIFwifVwiKSk7XG4gIHN0YXRlLnByZSA9IG9yaWdpbmFsUHJlU3RhdGU7XG4gIHJldHVybiAoXCJfbShcIiArIChzdGF0ZS5zdGF0aWNSZW5kZXJGbnMubGVuZ3RoIC0gMSkgKyAoZWwuc3RhdGljSW5Gb3IgPyAnLHRydWUnIDogJycpICsgXCIpXCIpXG59XG5cbi8vIHYtb25jZVxuZnVuY3Rpb24gZ2VuT25jZSAoZWwsIHN0YXRlKSB7XG4gIGVsLm9uY2VQcm9jZXNzZWQgPSB0cnVlO1xuICBpZiAoZWwuaWYgJiYgIWVsLmlmUHJvY2Vzc2VkKSB7XG4gICAgcmV0dXJuIGdlbklmKGVsLCBzdGF0ZSlcbiAgfSBlbHNlIGlmIChlbC5zdGF0aWNJbkZvcikge1xuICAgIHZhciBrZXkgPSAnJztcbiAgICB2YXIgcGFyZW50ID0gZWwucGFyZW50O1xuICAgIHdoaWxlIChwYXJlbnQpIHtcbiAgICAgIGlmIChwYXJlbnQuZm9yKSB7XG4gICAgICAgIGtleSA9IHBhcmVudC5rZXk7XG4gICAgICAgIGJyZWFrXG4gICAgICB9XG4gICAgICBwYXJlbnQgPSBwYXJlbnQucGFyZW50O1xuICAgIH1cbiAgICBpZiAoIWtleSkge1xuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiBzdGF0ZS53YXJuKFxuICAgICAgICBcInYtb25jZSBjYW4gb25seSBiZSB1c2VkIGluc2lkZSB2LWZvciB0aGF0IGlzIGtleWVkLiBcIixcbiAgICAgICAgZWwucmF3QXR0cnNNYXBbJ3Ytb25jZSddXG4gICAgICApO1xuICAgICAgcmV0dXJuIGdlbkVsZW1lbnQoZWwsIHN0YXRlKVxuICAgIH1cbiAgICByZXR1cm4gKFwiX28oXCIgKyAoZ2VuRWxlbWVudChlbCwgc3RhdGUpKSArIFwiLFwiICsgKHN0YXRlLm9uY2VJZCsrKSArIFwiLFwiICsga2V5ICsgXCIpXCIpXG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGdlblN0YXRpYyhlbCwgc3RhdGUpXG4gIH1cbn1cblxuZnVuY3Rpb24gZ2VuSWYgKFxuICBlbCxcbiAgc3RhdGUsXG4gIGFsdEdlbixcbiAgYWx0RW1wdHlcbikge1xuICBlbC5pZlByb2Nlc3NlZCA9IHRydWU7IC8vIGF2b2lkIHJlY3Vyc2lvblxuICByZXR1cm4gZ2VuSWZDb25kaXRpb25zKGVsLmlmQ29uZGl0aW9ucy5zbGljZSgpLCBzdGF0ZSwgYWx0R2VuLCBhbHRFbXB0eSlcbn1cblxuZnVuY3Rpb24gZ2VuSWZDb25kaXRpb25zIChcbiAgY29uZGl0aW9ucyxcbiAgc3RhdGUsXG4gIGFsdEdlbixcbiAgYWx0RW1wdHlcbikge1xuICBpZiAoIWNvbmRpdGlvbnMubGVuZ3RoKSB7XG4gICAgcmV0dXJuIGFsdEVtcHR5IHx8ICdfZSgpJ1xuICB9XG5cbiAgdmFyIGNvbmRpdGlvbiA9IGNvbmRpdGlvbnMuc2hpZnQoKTtcbiAgaWYgKGNvbmRpdGlvbi5leHApIHtcbiAgICByZXR1cm4gKFwiKFwiICsgKGNvbmRpdGlvbi5leHApICsgXCIpP1wiICsgKGdlblRlcm5hcnlFeHAoY29uZGl0aW9uLmJsb2NrKSkgKyBcIjpcIiArIChnZW5JZkNvbmRpdGlvbnMoY29uZGl0aW9ucywgc3RhdGUsIGFsdEdlbiwgYWx0RW1wdHkpKSlcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gKFwiXCIgKyAoZ2VuVGVybmFyeUV4cChjb25kaXRpb24uYmxvY2spKSlcbiAgfVxuXG4gIC8vIHYtaWYgd2l0aCB2LW9uY2Ugc2hvdWxkIGdlbmVyYXRlIGNvZGUgbGlrZSAoYSk/X20oMCk6X20oMSlcbiAgZnVuY3Rpb24gZ2VuVGVybmFyeUV4cCAoZWwpIHtcbiAgICByZXR1cm4gYWx0R2VuXG4gICAgICA/IGFsdEdlbihlbCwgc3RhdGUpXG4gICAgICA6IGVsLm9uY2VcbiAgICAgICAgPyBnZW5PbmNlKGVsLCBzdGF0ZSlcbiAgICAgICAgOiBnZW5FbGVtZW50KGVsLCBzdGF0ZSlcbiAgfVxufVxuXG5mdW5jdGlvbiBnZW5Gb3IgKFxuICBlbCxcbiAgc3RhdGUsXG4gIGFsdEdlbixcbiAgYWx0SGVscGVyXG4pIHtcbiAgdmFyIGV4cCA9IGVsLmZvcjtcbiAgdmFyIGFsaWFzID0gZWwuYWxpYXM7XG4gIHZhciBpdGVyYXRvcjEgPSBlbC5pdGVyYXRvcjEgPyAoXCIsXCIgKyAoZWwuaXRlcmF0b3IxKSkgOiAnJztcbiAgdmFyIGl0ZXJhdG9yMiA9IGVsLml0ZXJhdG9yMiA/IChcIixcIiArIChlbC5pdGVyYXRvcjIpKSA6ICcnO1xuXG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmXG4gICAgc3RhdGUubWF5YmVDb21wb25lbnQoZWwpICYmXG4gICAgZWwudGFnICE9PSAnc2xvdCcgJiZcbiAgICBlbC50YWcgIT09ICd0ZW1wbGF0ZScgJiZcbiAgICAhZWwua2V5XG4gICkge1xuICAgIHN0YXRlLndhcm4oXG4gICAgICBcIjxcIiArIChlbC50YWcpICsgXCIgdi1mb3I9XFxcIlwiICsgYWxpYXMgKyBcIiBpbiBcIiArIGV4cCArIFwiXFxcIj46IGNvbXBvbmVudCBsaXN0cyByZW5kZXJlZCB3aXRoIFwiICtcbiAgICAgIFwidi1mb3Igc2hvdWxkIGhhdmUgZXhwbGljaXQga2V5cy4gXCIgK1xuICAgICAgXCJTZWUgaHR0cHM6Ly92dWVqcy5vcmcvZ3VpZGUvbGlzdC5odG1sI2tleSBmb3IgbW9yZSBpbmZvLlwiLFxuICAgICAgZWwucmF3QXR0cnNNYXBbJ3YtZm9yJ10sXG4gICAgICB0cnVlIC8qIHRpcCAqL1xuICAgICk7XG4gIH1cblxuICBlbC5mb3JQcm9jZXNzZWQgPSB0cnVlOyAvLyBhdm9pZCByZWN1cnNpb25cbiAgcmV0dXJuIChhbHRIZWxwZXIgfHwgJ19sJykgKyBcIigoXCIgKyBleHAgKyBcIiksXCIgK1xuICAgIFwiZnVuY3Rpb24oXCIgKyBhbGlhcyArIGl0ZXJhdG9yMSArIGl0ZXJhdG9yMiArIFwiKXtcIiArXG4gICAgICBcInJldHVybiBcIiArICgoYWx0R2VuIHx8IGdlbkVsZW1lbnQpKGVsLCBzdGF0ZSkpICtcbiAgICAnfSknXG59XG5cbmZ1bmN0aW9uIGdlbkRhdGEkMiAoZWwsIHN0YXRlKSB7XG4gIHZhciBkYXRhID0gJ3snO1xuXG4gIC8vIGRpcmVjdGl2ZXMgZmlyc3QuXG4gIC8vIGRpcmVjdGl2ZXMgbWF5IG11dGF0ZSB0aGUgZWwncyBvdGhlciBwcm9wZXJ0aWVzIGJlZm9yZSB0aGV5IGFyZSBnZW5lcmF0ZWQuXG4gIHZhciBkaXJzID0gZ2VuRGlyZWN0aXZlcyhlbCwgc3RhdGUpO1xuICBpZiAoZGlycykgeyBkYXRhICs9IGRpcnMgKyAnLCc7IH1cblxuICAvLyBrZXlcbiAgaWYgKGVsLmtleSkge1xuICAgIGRhdGEgKz0gXCJrZXk6XCIgKyAoZWwua2V5KSArIFwiLFwiO1xuICB9XG4gIC8vIHJlZlxuICBpZiAoZWwucmVmKSB7XG4gICAgZGF0YSArPSBcInJlZjpcIiArIChlbC5yZWYpICsgXCIsXCI7XG4gIH1cbiAgaWYgKGVsLnJlZkluRm9yKSB7XG4gICAgZGF0YSArPSBcInJlZkluRm9yOnRydWUsXCI7XG4gIH1cbiAgLy8gcHJlXG4gIGlmIChlbC5wcmUpIHtcbiAgICBkYXRhICs9IFwicHJlOnRydWUsXCI7XG4gIH1cbiAgLy8gcmVjb3JkIG9yaWdpbmFsIHRhZyBuYW1lIGZvciBjb21wb25lbnRzIHVzaW5nIFwiaXNcIiBhdHRyaWJ1dGVcbiAgaWYgKGVsLmNvbXBvbmVudCkge1xuICAgIGRhdGEgKz0gXCJ0YWc6XFxcIlwiICsgKGVsLnRhZykgKyBcIlxcXCIsXCI7XG4gIH1cbiAgLy8gbW9kdWxlIGRhdGEgZ2VuZXJhdGlvbiBmdW5jdGlvbnNcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdGF0ZS5kYXRhR2VuRm5zLmxlbmd0aDsgaSsrKSB7XG4gICAgZGF0YSArPSBzdGF0ZS5kYXRhR2VuRm5zW2ldKGVsKTtcbiAgfVxuICAvLyBhdHRyaWJ1dGVzXG4gIGlmIChlbC5hdHRycykge1xuICAgIGRhdGEgKz0gXCJhdHRyczpcIiArIChnZW5Qcm9wcyhlbC5hdHRycykpICsgXCIsXCI7XG4gIH1cbiAgLy8gRE9NIHByb3BzXG4gIGlmIChlbC5wcm9wcykge1xuICAgIGRhdGEgKz0gXCJkb21Qcm9wczpcIiArIChnZW5Qcm9wcyhlbC5wcm9wcykpICsgXCIsXCI7XG4gIH1cbiAgLy8gZXZlbnQgaGFuZGxlcnNcbiAgaWYgKGVsLmV2ZW50cykge1xuICAgIGRhdGEgKz0gKGdlbkhhbmRsZXJzKGVsLmV2ZW50cywgZmFsc2UpKSArIFwiLFwiO1xuICB9XG4gIGlmIChlbC5uYXRpdmVFdmVudHMpIHtcbiAgICBkYXRhICs9IChnZW5IYW5kbGVycyhlbC5uYXRpdmVFdmVudHMsIHRydWUpKSArIFwiLFwiO1xuICB9XG4gIC8vIHNsb3QgdGFyZ2V0XG4gIC8vIG9ubHkgZm9yIG5vbi1zY29wZWQgc2xvdHNcbiAgaWYgKGVsLnNsb3RUYXJnZXQgJiYgIWVsLnNsb3RTY29wZSkge1xuICAgIGRhdGEgKz0gXCJzbG90OlwiICsgKGVsLnNsb3RUYXJnZXQpICsgXCIsXCI7XG4gIH1cbiAgLy8gc2NvcGVkIHNsb3RzXG4gIGlmIChlbC5zY29wZWRTbG90cykge1xuICAgIGRhdGEgKz0gKGdlblNjb3BlZFNsb3RzKGVsLCBlbC5zY29wZWRTbG90cywgc3RhdGUpKSArIFwiLFwiO1xuICB9XG4gIC8vIGNvbXBvbmVudCB2LW1vZGVsXG4gIGlmIChlbC5tb2RlbCkge1xuICAgIGRhdGEgKz0gXCJtb2RlbDp7dmFsdWU6XCIgKyAoZWwubW9kZWwudmFsdWUpICsgXCIsY2FsbGJhY2s6XCIgKyAoZWwubW9kZWwuY2FsbGJhY2spICsgXCIsZXhwcmVzc2lvbjpcIiArIChlbC5tb2RlbC5leHByZXNzaW9uKSArIFwifSxcIjtcbiAgfVxuICAvLyBpbmxpbmUtdGVtcGxhdGVcbiAgaWYgKGVsLmlubGluZVRlbXBsYXRlKSB7XG4gICAgdmFyIGlubGluZVRlbXBsYXRlID0gZ2VuSW5saW5lVGVtcGxhdGUoZWwsIHN0YXRlKTtcbiAgICBpZiAoaW5saW5lVGVtcGxhdGUpIHtcbiAgICAgIGRhdGEgKz0gaW5saW5lVGVtcGxhdGUgKyBcIixcIjtcbiAgICB9XG4gIH1cbiAgZGF0YSA9IGRhdGEucmVwbGFjZSgvLCQvLCAnJykgKyAnfSc7XG4gIC8vIHYtYmluZCBkeW5hbWljIGFyZ3VtZW50IHdyYXBcbiAgLy8gdi1iaW5kIHdpdGggZHluYW1pYyBhcmd1bWVudHMgbXVzdCBiZSBhcHBsaWVkIHVzaW5nIHRoZSBzYW1lIHYtYmluZCBvYmplY3RcbiAgLy8gbWVyZ2UgaGVscGVyIHNvIHRoYXQgY2xhc3Mvc3R5bGUvbXVzdFVzZVByb3AgYXR0cnMgYXJlIGhhbmRsZWQgY29ycmVjdGx5LlxuICBpZiAoZWwuZHluYW1pY0F0dHJzKSB7XG4gICAgZGF0YSA9IFwiX2IoXCIgKyBkYXRhICsgXCIsXFxcIlwiICsgKGVsLnRhZykgKyBcIlxcXCIsXCIgKyAoZ2VuUHJvcHMoZWwuZHluYW1pY0F0dHJzKSkgKyBcIilcIjtcbiAgfVxuICAvLyB2LWJpbmQgZGF0YSB3cmFwXG4gIGlmIChlbC53cmFwRGF0YSkge1xuICAgIGRhdGEgPSBlbC53cmFwRGF0YShkYXRhKTtcbiAgfVxuICAvLyB2LW9uIGRhdGEgd3JhcFxuICBpZiAoZWwud3JhcExpc3RlbmVycykge1xuICAgIGRhdGEgPSBlbC53cmFwTGlzdGVuZXJzKGRhdGEpO1xuICB9XG4gIHJldHVybiBkYXRhXG59XG5cbmZ1bmN0aW9uIGdlbkRpcmVjdGl2ZXMgKGVsLCBzdGF0ZSkge1xuICB2YXIgZGlycyA9IGVsLmRpcmVjdGl2ZXM7XG4gIGlmICghZGlycykgeyByZXR1cm4gfVxuICB2YXIgcmVzID0gJ2RpcmVjdGl2ZXM6Wyc7XG4gIHZhciBoYXNSdW50aW1lID0gZmFsc2U7XG4gIHZhciBpLCBsLCBkaXIsIG5lZWRSdW50aW1lO1xuICBmb3IgKGkgPSAwLCBsID0gZGlycy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICBkaXIgPSBkaXJzW2ldO1xuICAgIG5lZWRSdW50aW1lID0gdHJ1ZTtcbiAgICB2YXIgZ2VuID0gc3RhdGUuZGlyZWN0aXZlc1tkaXIubmFtZV07XG4gICAgaWYgKGdlbikge1xuICAgICAgLy8gY29tcGlsZS10aW1lIGRpcmVjdGl2ZSB0aGF0IG1hbmlwdWxhdGVzIEFTVC5cbiAgICAgIC8vIHJldHVybnMgdHJ1ZSBpZiBpdCBhbHNvIG5lZWRzIGEgcnVudGltZSBjb3VudGVycGFydC5cbiAgICAgIG5lZWRSdW50aW1lID0gISFnZW4oZWwsIGRpciwgc3RhdGUud2Fybik7XG4gICAgfVxuICAgIGlmIChuZWVkUnVudGltZSkge1xuICAgICAgaGFzUnVudGltZSA9IHRydWU7XG4gICAgICByZXMgKz0gXCJ7bmFtZTpcXFwiXCIgKyAoZGlyLm5hbWUpICsgXCJcXFwiLHJhd05hbWU6XFxcIlwiICsgKGRpci5yYXdOYW1lKSArIFwiXFxcIlwiICsgKGRpci52YWx1ZSA/IChcIix2YWx1ZTooXCIgKyAoZGlyLnZhbHVlKSArIFwiKSxleHByZXNzaW9uOlwiICsgKEpTT04uc3RyaW5naWZ5KGRpci52YWx1ZSkpKSA6ICcnKSArIChkaXIuYXJnID8gKFwiLGFyZzpcIiArIChkaXIuaXNEeW5hbWljQXJnID8gZGlyLmFyZyA6IChcIlxcXCJcIiArIChkaXIuYXJnKSArIFwiXFxcIlwiKSkpIDogJycpICsgKGRpci5tb2RpZmllcnMgPyAoXCIsbW9kaWZpZXJzOlwiICsgKEpTT04uc3RyaW5naWZ5KGRpci5tb2RpZmllcnMpKSkgOiAnJykgKyBcIn0sXCI7XG4gICAgfVxuICB9XG4gIGlmIChoYXNSdW50aW1lKSB7XG4gICAgcmV0dXJuIHJlcy5zbGljZSgwLCAtMSkgKyAnXSdcbiAgfVxufVxuXG5mdW5jdGlvbiBnZW5JbmxpbmVUZW1wbGF0ZSAoZWwsIHN0YXRlKSB7XG4gIHZhciBhc3QgPSBlbC5jaGlsZHJlblswXTtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgKFxuICAgIGVsLmNoaWxkcmVuLmxlbmd0aCAhPT0gMSB8fCBhc3QudHlwZSAhPT0gMVxuICApKSB7XG4gICAgc3RhdGUud2FybihcbiAgICAgICdJbmxpbmUtdGVtcGxhdGUgY29tcG9uZW50cyBtdXN0IGhhdmUgZXhhY3RseSBvbmUgY2hpbGQgZWxlbWVudC4nLFxuICAgICAgeyBzdGFydDogZWwuc3RhcnQgfVxuICAgICk7XG4gIH1cbiAgaWYgKGFzdCAmJiBhc3QudHlwZSA9PT0gMSkge1xuICAgIHZhciBpbmxpbmVSZW5kZXJGbnMgPSBnZW5lcmF0ZShhc3QsIHN0YXRlLm9wdGlvbnMpO1xuICAgIHJldHVybiAoXCJpbmxpbmVUZW1wbGF0ZTp7cmVuZGVyOmZ1bmN0aW9uKCl7XCIgKyAoaW5saW5lUmVuZGVyRm5zLnJlbmRlcikgKyBcIn0sc3RhdGljUmVuZGVyRm5zOltcIiArIChpbmxpbmVSZW5kZXJGbnMuc3RhdGljUmVuZGVyRm5zLm1hcChmdW5jdGlvbiAoY29kZSkgeyByZXR1cm4gKFwiZnVuY3Rpb24oKXtcIiArIGNvZGUgKyBcIn1cIik7IH0pLmpvaW4oJywnKSkgKyBcIl19XCIpXG4gIH1cbn1cblxuZnVuY3Rpb24gZ2VuU2NvcGVkU2xvdHMgKFxuICBlbCxcbiAgc2xvdHMsXG4gIHN0YXRlXG4pIHtcbiAgLy8gYnkgZGVmYXVsdCBzY29wZWQgc2xvdHMgYXJlIGNvbnNpZGVyZWQgXCJzdGFibGVcIiwgdGhpcyBhbGxvd3MgY2hpbGRcbiAgLy8gY29tcG9uZW50cyB3aXRoIG9ubHkgc2NvcGVkIHNsb3RzIHRvIHNraXAgZm9yY2VkIHVwZGF0ZXMgZnJvbSBwYXJlbnQuXG4gIC8vIGJ1dCBpbiBzb21lIGNhc2VzIHdlIGhhdmUgdG8gYmFpbC1vdXQgb2YgdGhpcyBvcHRpbWl6YXRpb25cbiAgLy8gZm9yIGV4YW1wbGUgaWYgdGhlIHNsb3QgY29udGFpbnMgZHluYW1pYyBuYW1lcywgaGFzIHYtaWYgb3Igdi1mb3Igb24gdGhlbS4uLlxuICB2YXIgbmVlZHNGb3JjZVVwZGF0ZSA9IGVsLmZvciB8fCBPYmplY3Qua2V5cyhzbG90cykuc29tZShmdW5jdGlvbiAoa2V5KSB7XG4gICAgdmFyIHNsb3QgPSBzbG90c1trZXldO1xuICAgIHJldHVybiAoXG4gICAgICBzbG90LnNsb3RUYXJnZXREeW5hbWljIHx8XG4gICAgICBzbG90LmlmIHx8XG4gICAgICBzbG90LmZvciB8fFxuICAgICAgY29udGFpbnNTbG90Q2hpbGQoc2xvdCkgLy8gaXMgcGFzc2luZyBkb3duIHNsb3QgZnJvbSBwYXJlbnQgd2hpY2ggbWF5IGJlIGR5bmFtaWNcbiAgICApXG4gIH0pO1xuXG4gIC8vICM5NTM0OiBpZiBhIGNvbXBvbmVudCB3aXRoIHNjb3BlZCBzbG90cyBpcyBpbnNpZGUgYSBjb25kaXRpb25hbCBicmFuY2gsXG4gIC8vIGl0J3MgcG9zc2libGUgZm9yIHRoZSBzYW1lIGNvbXBvbmVudCB0byBiZSByZXVzZWQgYnV0IHdpdGggZGlmZmVyZW50XG4gIC8vIGNvbXBpbGVkIHNsb3QgY29udGVudC4gVG8gYXZvaWQgdGhhdCwgd2UgZ2VuZXJhdGUgYSB1bmlxdWUga2V5IGJhc2VkIG9uXG4gIC8vIHRoZSBnZW5lcmF0ZWQgY29kZSBvZiBhbGwgdGhlIHNsb3QgY29udGVudHMuXG4gIHZhciBuZWVkc0tleSA9ICEhZWwuaWY7XG5cbiAgLy8gT1Igd2hlbiBpdCBpcyBpbnNpZGUgYW5vdGhlciBzY29wZWQgc2xvdCBvciB2LWZvciAodGhlIHJlYWN0aXZpdHkgbWF5IGJlXG4gIC8vIGRpc2Nvbm5lY3RlZCBkdWUgdG8gdGhlIGludGVybWVkaWF0ZSBzY29wZSB2YXJpYWJsZSlcbiAgLy8gIzk0MzgsICM5NTA2XG4gIC8vIFRPRE86IHRoaXMgY2FuIGJlIGZ1cnRoZXIgb3B0aW1pemVkIGJ5IHByb3Blcmx5IGFuYWx5emluZyBpbi1zY29wZSBiaW5kaW5nc1xuICAvLyBhbmQgc2tpcCBmb3JjZSB1cGRhdGluZyBvbmVzIHRoYXQgZG8gbm90IGFjdHVhbGx5IHVzZSBzY29wZSB2YXJpYWJsZXMuXG4gIGlmICghbmVlZHNGb3JjZVVwZGF0ZSkge1xuICAgIHZhciBwYXJlbnQgPSBlbC5wYXJlbnQ7XG4gICAgd2hpbGUgKHBhcmVudCkge1xuICAgICAgaWYgKFxuICAgICAgICAocGFyZW50LnNsb3RTY29wZSAmJiBwYXJlbnQuc2xvdFNjb3BlICE9PSBlbXB0eVNsb3RTY29wZVRva2VuKSB8fFxuICAgICAgICBwYXJlbnQuZm9yXG4gICAgICApIHtcbiAgICAgICAgbmVlZHNGb3JjZVVwZGF0ZSA9IHRydWU7XG4gICAgICAgIGJyZWFrXG4gICAgICB9XG4gICAgICBpZiAocGFyZW50LmlmKSB7XG4gICAgICAgIG5lZWRzS2V5ID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIHBhcmVudCA9IHBhcmVudC5wYXJlbnQ7XG4gICAgfVxuICB9XG5cbiAgdmFyIGdlbmVyYXRlZFNsb3RzID0gT2JqZWN0LmtleXMoc2xvdHMpXG4gICAgLm1hcChmdW5jdGlvbiAoa2V5KSB7IHJldHVybiBnZW5TY29wZWRTbG90KHNsb3RzW2tleV0sIHN0YXRlKTsgfSlcbiAgICAuam9pbignLCcpO1xuXG4gIHJldHVybiAoXCJzY29wZWRTbG90czpfdShbXCIgKyBnZW5lcmF0ZWRTbG90cyArIFwiXVwiICsgKG5lZWRzRm9yY2VVcGRhdGUgPyBcIixudWxsLHRydWVcIiA6IFwiXCIpICsgKCFuZWVkc0ZvcmNlVXBkYXRlICYmIG5lZWRzS2V5ID8gKFwiLG51bGwsZmFsc2UsXCIgKyAoaGFzaChnZW5lcmF0ZWRTbG90cykpKSA6IFwiXCIpICsgXCIpXCIpXG59XG5cbmZ1bmN0aW9uIGhhc2goc3RyKSB7XG4gIHZhciBoYXNoID0gNTM4MTtcbiAgdmFyIGkgPSBzdHIubGVuZ3RoO1xuICB3aGlsZShpKSB7XG4gICAgaGFzaCA9IChoYXNoICogMzMpIF4gc3RyLmNoYXJDb2RlQXQoLS1pKTtcbiAgfVxuICByZXR1cm4gaGFzaCA+Pj4gMFxufVxuXG5mdW5jdGlvbiBjb250YWluc1Nsb3RDaGlsZCAoZWwpIHtcbiAgaWYgKGVsLnR5cGUgPT09IDEpIHtcbiAgICBpZiAoZWwudGFnID09PSAnc2xvdCcpIHtcbiAgICAgIHJldHVybiB0cnVlXG4gICAgfVxuICAgIHJldHVybiBlbC5jaGlsZHJlbi5zb21lKGNvbnRhaW5zU2xvdENoaWxkKVxuICB9XG4gIHJldHVybiBmYWxzZVxufVxuXG5mdW5jdGlvbiBnZW5TY29wZWRTbG90IChcbiAgZWwsXG4gIHN0YXRlXG4pIHtcbiAgdmFyIGlzTGVnYWN5U3ludGF4ID0gZWwuYXR0cnNNYXBbJ3Nsb3Qtc2NvcGUnXTtcbiAgaWYgKGVsLmlmICYmICFlbC5pZlByb2Nlc3NlZCAmJiAhaXNMZWdhY3lTeW50YXgpIHtcbiAgICByZXR1cm4gZ2VuSWYoZWwsIHN0YXRlLCBnZW5TY29wZWRTbG90LCBcIm51bGxcIilcbiAgfVxuICBpZiAoZWwuZm9yICYmICFlbC5mb3JQcm9jZXNzZWQpIHtcbiAgICByZXR1cm4gZ2VuRm9yKGVsLCBzdGF0ZSwgZ2VuU2NvcGVkU2xvdClcbiAgfVxuICB2YXIgc2xvdFNjb3BlID0gZWwuc2xvdFNjb3BlID09PSBlbXB0eVNsb3RTY29wZVRva2VuXG4gICAgPyBcIlwiXG4gICAgOiBTdHJpbmcoZWwuc2xvdFNjb3BlKTtcbiAgdmFyIGZuID0gXCJmdW5jdGlvbihcIiArIHNsb3RTY29wZSArIFwiKXtcIiArXG4gICAgXCJyZXR1cm4gXCIgKyAoZWwudGFnID09PSAndGVtcGxhdGUnXG4gICAgICA/IGVsLmlmICYmIGlzTGVnYWN5U3ludGF4XG4gICAgICAgID8gKFwiKFwiICsgKGVsLmlmKSArIFwiKT9cIiArIChnZW5DaGlsZHJlbihlbCwgc3RhdGUpIHx8ICd1bmRlZmluZWQnKSArIFwiOnVuZGVmaW5lZFwiKVxuICAgICAgICA6IGdlbkNoaWxkcmVuKGVsLCBzdGF0ZSkgfHwgJ3VuZGVmaW5lZCdcbiAgICAgIDogZ2VuRWxlbWVudChlbCwgc3RhdGUpKSArIFwifVwiO1xuICAvLyByZXZlcnNlIHByb3h5IHYtc2xvdCB3aXRob3V0IHNjb3BlIG9uIHRoaXMuJHNsb3RzXG4gIHZhciByZXZlcnNlUHJveHkgPSBzbG90U2NvcGUgPyBcIlwiIDogXCIscHJveHk6dHJ1ZVwiO1xuICByZXR1cm4gKFwie2tleTpcIiArIChlbC5zbG90VGFyZ2V0IHx8IFwiXFxcImRlZmF1bHRcXFwiXCIpICsgXCIsZm46XCIgKyBmbiArIHJldmVyc2VQcm94eSArIFwifVwiKVxufVxuXG5mdW5jdGlvbiBnZW5DaGlsZHJlbiAoXG4gIGVsLFxuICBzdGF0ZSxcbiAgY2hlY2tTa2lwLFxuICBhbHRHZW5FbGVtZW50LFxuICBhbHRHZW5Ob2RlXG4pIHtcbiAgdmFyIGNoaWxkcmVuID0gZWwuY2hpbGRyZW47XG4gIGlmIChjaGlsZHJlbi5sZW5ndGgpIHtcbiAgICB2YXIgZWwkMSA9IGNoaWxkcmVuWzBdO1xuICAgIC8vIG9wdGltaXplIHNpbmdsZSB2LWZvclxuICAgIGlmIChjaGlsZHJlbi5sZW5ndGggPT09IDEgJiZcbiAgICAgIGVsJDEuZm9yICYmXG4gICAgICBlbCQxLnRhZyAhPT0gJ3RlbXBsYXRlJyAmJlxuICAgICAgZWwkMS50YWcgIT09ICdzbG90J1xuICAgICkge1xuICAgICAgdmFyIG5vcm1hbGl6YXRpb25UeXBlID0gY2hlY2tTa2lwXG4gICAgICAgID8gc3RhdGUubWF5YmVDb21wb25lbnQoZWwkMSkgPyBcIiwxXCIgOiBcIiwwXCJcbiAgICAgICAgOiBcIlwiO1xuICAgICAgcmV0dXJuIChcIlwiICsgKChhbHRHZW5FbGVtZW50IHx8IGdlbkVsZW1lbnQpKGVsJDEsIHN0YXRlKSkgKyBub3JtYWxpemF0aW9uVHlwZSlcbiAgICB9XG4gICAgdmFyIG5vcm1hbGl6YXRpb25UeXBlJDEgPSBjaGVja1NraXBcbiAgICAgID8gZ2V0Tm9ybWFsaXphdGlvblR5cGUoY2hpbGRyZW4sIHN0YXRlLm1heWJlQ29tcG9uZW50KVxuICAgICAgOiAwO1xuICAgIHZhciBnZW4gPSBhbHRHZW5Ob2RlIHx8IGdlbk5vZGU7XG4gICAgcmV0dXJuIChcIltcIiArIChjaGlsZHJlbi5tYXAoZnVuY3Rpb24gKGMpIHsgcmV0dXJuIGdlbihjLCBzdGF0ZSk7IH0pLmpvaW4oJywnKSkgKyBcIl1cIiArIChub3JtYWxpemF0aW9uVHlwZSQxID8gKFwiLFwiICsgbm9ybWFsaXphdGlvblR5cGUkMSkgOiAnJykpXG4gIH1cbn1cblxuLy8gZGV0ZXJtaW5lIHRoZSBub3JtYWxpemF0aW9uIG5lZWRlZCBmb3IgdGhlIGNoaWxkcmVuIGFycmF5LlxuLy8gMDogbm8gbm9ybWFsaXphdGlvbiBuZWVkZWRcbi8vIDE6IHNpbXBsZSBub3JtYWxpemF0aW9uIG5lZWRlZCAocG9zc2libGUgMS1sZXZlbCBkZWVwIG5lc3RlZCBhcnJheSlcbi8vIDI6IGZ1bGwgbm9ybWFsaXphdGlvbiBuZWVkZWRcbmZ1bmN0aW9uIGdldE5vcm1hbGl6YXRpb25UeXBlIChcbiAgY2hpbGRyZW4sXG4gIG1heWJlQ29tcG9uZW50XG4pIHtcbiAgdmFyIHJlcyA9IDA7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgZWwgPSBjaGlsZHJlbltpXTtcbiAgICBpZiAoZWwudHlwZSAhPT0gMSkge1xuICAgICAgY29udGludWVcbiAgICB9XG4gICAgaWYgKG5lZWRzTm9ybWFsaXphdGlvbihlbCkgfHxcbiAgICAgICAgKGVsLmlmQ29uZGl0aW9ucyAmJiBlbC5pZkNvbmRpdGlvbnMuc29tZShmdW5jdGlvbiAoYykgeyByZXR1cm4gbmVlZHNOb3JtYWxpemF0aW9uKGMuYmxvY2spOyB9KSkpIHtcbiAgICAgIHJlcyA9IDI7XG4gICAgICBicmVha1xuICAgIH1cbiAgICBpZiAobWF5YmVDb21wb25lbnQoZWwpIHx8XG4gICAgICAgIChlbC5pZkNvbmRpdGlvbnMgJiYgZWwuaWZDb25kaXRpb25zLnNvbWUoZnVuY3Rpb24gKGMpIHsgcmV0dXJuIG1heWJlQ29tcG9uZW50KGMuYmxvY2spOyB9KSkpIHtcbiAgICAgIHJlcyA9IDE7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXNcbn1cblxuZnVuY3Rpb24gbmVlZHNOb3JtYWxpemF0aW9uIChlbCkge1xuICByZXR1cm4gZWwuZm9yICE9PSB1bmRlZmluZWQgfHwgZWwudGFnID09PSAndGVtcGxhdGUnIHx8IGVsLnRhZyA9PT0gJ3Nsb3QnXG59XG5cbmZ1bmN0aW9uIGdlbk5vZGUgKG5vZGUsIHN0YXRlKSB7XG4gIGlmIChub2RlLnR5cGUgPT09IDEpIHtcbiAgICByZXR1cm4gZ2VuRWxlbWVudChub2RlLCBzdGF0ZSlcbiAgfSBlbHNlIGlmIChub2RlLnR5cGUgPT09IDMgJiYgbm9kZS5pc0NvbW1lbnQpIHtcbiAgICByZXR1cm4gZ2VuQ29tbWVudChub2RlKVxuICB9IGVsc2Uge1xuICAgIHJldHVybiBnZW5UZXh0KG5vZGUpXG4gIH1cbn1cblxuZnVuY3Rpb24gZ2VuVGV4dCAodGV4dCkge1xuICByZXR1cm4gKFwiX3YoXCIgKyAodGV4dC50eXBlID09PSAyXG4gICAgPyB0ZXh0LmV4cHJlc3Npb24gLy8gbm8gbmVlZCBmb3IgKCkgYmVjYXVzZSBhbHJlYWR5IHdyYXBwZWQgaW4gX3MoKVxuICAgIDogdHJhbnNmb3JtU3BlY2lhbE5ld2xpbmVzKEpTT04uc3RyaW5naWZ5KHRleHQudGV4dCkpKSArIFwiKVwiKVxufVxuXG5mdW5jdGlvbiBnZW5Db21tZW50IChjb21tZW50KSB7XG4gIHJldHVybiAoXCJfZShcIiArIChKU09OLnN0cmluZ2lmeShjb21tZW50LnRleHQpKSArIFwiKVwiKVxufVxuXG5mdW5jdGlvbiBnZW5TbG90IChlbCwgc3RhdGUpIHtcbiAgdmFyIHNsb3ROYW1lID0gZWwuc2xvdE5hbWUgfHwgJ1wiZGVmYXVsdFwiJztcbiAgdmFyIGNoaWxkcmVuID0gZ2VuQ2hpbGRyZW4oZWwsIHN0YXRlKTtcbiAgdmFyIHJlcyA9IFwiX3QoXCIgKyBzbG90TmFtZSArIChjaGlsZHJlbiA/IChcIixmdW5jdGlvbigpe3JldHVybiBcIiArIGNoaWxkcmVuICsgXCJ9XCIpIDogJycpO1xuICB2YXIgYXR0cnMgPSBlbC5hdHRycyB8fCBlbC5keW5hbWljQXR0cnNcbiAgICA/IGdlblByb3BzKChlbC5hdHRycyB8fCBbXSkuY29uY2F0KGVsLmR5bmFtaWNBdHRycyB8fCBbXSkubWFwKGZ1bmN0aW9uIChhdHRyKSB7IHJldHVybiAoe1xuICAgICAgICAvLyBzbG90IHByb3BzIGFyZSBjYW1lbGl6ZWRcbiAgICAgICAgbmFtZTogY2FtZWxpemUoYXR0ci5uYW1lKSxcbiAgICAgICAgdmFsdWU6IGF0dHIudmFsdWUsXG4gICAgICAgIGR5bmFtaWM6IGF0dHIuZHluYW1pY1xuICAgICAgfSk7IH0pKVxuICAgIDogbnVsbDtcbiAgdmFyIGJpbmQkJDEgPSBlbC5hdHRyc01hcFsndi1iaW5kJ107XG4gIGlmICgoYXR0cnMgfHwgYmluZCQkMSkgJiYgIWNoaWxkcmVuKSB7XG4gICAgcmVzICs9IFwiLG51bGxcIjtcbiAgfVxuICBpZiAoYXR0cnMpIHtcbiAgICByZXMgKz0gXCIsXCIgKyBhdHRycztcbiAgfVxuICBpZiAoYmluZCQkMSkge1xuICAgIHJlcyArPSAoYXR0cnMgPyAnJyA6ICcsbnVsbCcpICsgXCIsXCIgKyBiaW5kJCQxO1xuICB9XG4gIHJldHVybiByZXMgKyAnKSdcbn1cblxuLy8gY29tcG9uZW50TmFtZSBpcyBlbC5jb21wb25lbnQsIHRha2UgaXQgYXMgYXJndW1lbnQgdG8gc2h1biBmbG93J3MgcGVzc2ltaXN0aWMgcmVmaW5lbWVudFxuZnVuY3Rpb24gZ2VuQ29tcG9uZW50IChcbiAgY29tcG9uZW50TmFtZSxcbiAgZWwsXG4gIHN0YXRlXG4pIHtcbiAgdmFyIGNoaWxkcmVuID0gZWwuaW5saW5lVGVtcGxhdGUgPyBudWxsIDogZ2VuQ2hpbGRyZW4oZWwsIHN0YXRlLCB0cnVlKTtcbiAgcmV0dXJuIChcIl9jKFwiICsgY29tcG9uZW50TmFtZSArIFwiLFwiICsgKGdlbkRhdGEkMihlbCwgc3RhdGUpKSArIChjaGlsZHJlbiA/IChcIixcIiArIGNoaWxkcmVuKSA6ICcnKSArIFwiKVwiKVxufVxuXG5mdW5jdGlvbiBnZW5Qcm9wcyAocHJvcHMpIHtcbiAgdmFyIHN0YXRpY1Byb3BzID0gXCJcIjtcbiAgdmFyIGR5bmFtaWNQcm9wcyA9IFwiXCI7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgcHJvcCA9IHByb3BzW2ldO1xuICAgIHZhciB2YWx1ZSA9IHRyYW5zZm9ybVNwZWNpYWxOZXdsaW5lcyhwcm9wLnZhbHVlKTtcbiAgICBpZiAocHJvcC5keW5hbWljKSB7XG4gICAgICBkeW5hbWljUHJvcHMgKz0gKHByb3AubmFtZSkgKyBcIixcIiArIHZhbHVlICsgXCIsXCI7XG4gICAgfSBlbHNlIHtcbiAgICAgIHN0YXRpY1Byb3BzICs9IFwiXFxcIlwiICsgKHByb3AubmFtZSkgKyBcIlxcXCI6XCIgKyB2YWx1ZSArIFwiLFwiO1xuICAgIH1cbiAgfVxuICBzdGF0aWNQcm9wcyA9IFwie1wiICsgKHN0YXRpY1Byb3BzLnNsaWNlKDAsIC0xKSkgKyBcIn1cIjtcbiAgaWYgKGR5bmFtaWNQcm9wcykge1xuICAgIHJldHVybiAoXCJfZChcIiArIHN0YXRpY1Byb3BzICsgXCIsW1wiICsgKGR5bmFtaWNQcm9wcy5zbGljZSgwLCAtMSkpICsgXCJdKVwiKVxuICB9IGVsc2Uge1xuICAgIHJldHVybiBzdGF0aWNQcm9wc1xuICB9XG59XG5cbi8vICMzODk1LCAjNDI2OFxuZnVuY3Rpb24gdHJhbnNmb3JtU3BlY2lhbE5ld2xpbmVzICh0ZXh0KSB7XG4gIHJldHVybiB0ZXh0XG4gICAgLnJlcGxhY2UoL1xcdTIwMjgvZywgJ1xcXFx1MjAyOCcpXG4gICAgLnJlcGxhY2UoL1xcdTIwMjkvZywgJ1xcXFx1MjAyOScpXG59XG5cbi8qICAqL1xuXG5cblxuLy8gdGhlc2Uga2V5d29yZHMgc2hvdWxkIG5vdCBhcHBlYXIgaW5zaWRlIGV4cHJlc3Npb25zLCBidXQgb3BlcmF0b3JzIGxpa2Vcbi8vIHR5cGVvZiwgaW5zdGFuY2VvZiBhbmQgaW4gYXJlIGFsbG93ZWRcbnZhciBwcm9oaWJpdGVkS2V5d29yZFJFID0gbmV3IFJlZ0V4cCgnXFxcXGInICsgKFxuICAnZG8saWYsZm9yLGxldCxuZXcsdHJ5LHZhcixjYXNlLGVsc2Usd2l0aCxhd2FpdCxicmVhayxjYXRjaCxjbGFzcyxjb25zdCwnICtcbiAgJ3N1cGVyLHRocm93LHdoaWxlLHlpZWxkLGRlbGV0ZSxleHBvcnQsaW1wb3J0LHJldHVybixzd2l0Y2gsZGVmYXVsdCwnICtcbiAgJ2V4dGVuZHMsZmluYWxseSxjb250aW51ZSxkZWJ1Z2dlcixmdW5jdGlvbixhcmd1bWVudHMnXG4pLnNwbGl0KCcsJykuam9pbignXFxcXGJ8XFxcXGInKSArICdcXFxcYicpO1xuXG4vLyB0aGVzZSB1bmFyeSBvcGVyYXRvcnMgc2hvdWxkIG5vdCBiZSB1c2VkIGFzIHByb3BlcnR5L21ldGhvZCBuYW1lc1xudmFyIHVuYXJ5T3BlcmF0b3JzUkUgPSBuZXcgUmVnRXhwKCdcXFxcYicgKyAoXG4gICdkZWxldGUsdHlwZW9mLHZvaWQnXG4pLnNwbGl0KCcsJykuam9pbignXFxcXHMqXFxcXChbXlxcXFwpXSpcXFxcKXxcXFxcYicpICsgJ1xcXFxzKlxcXFwoW15cXFxcKV0qXFxcXCknKTtcblxuLy8gc3RyaXAgc3RyaW5ncyBpbiBleHByZXNzaW9uc1xudmFyIHN0cmlwU3RyaW5nUkUgPSAvJyg/OlteJ1xcXFxdfFxcXFwuKSonfFwiKD86W15cIlxcXFxdfFxcXFwuKSpcInxgKD86W15gXFxcXF18XFxcXC4pKlxcJFxce3xcXH0oPzpbXmBcXFxcXXxcXFxcLikqYHxgKD86W15gXFxcXF18XFxcXC4pKmAvZztcblxuLy8gZGV0ZWN0IHByb2JsZW1hdGljIGV4cHJlc3Npb25zIGluIGEgdGVtcGxhdGVcbmZ1bmN0aW9uIGRldGVjdEVycm9ycyAoYXN0LCB3YXJuKSB7XG4gIGlmIChhc3QpIHtcbiAgICBjaGVja05vZGUoYXN0LCB3YXJuKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBjaGVja05vZGUgKG5vZGUsIHdhcm4pIHtcbiAgaWYgKG5vZGUudHlwZSA9PT0gMSkge1xuICAgIGZvciAodmFyIG5hbWUgaW4gbm9kZS5hdHRyc01hcCkge1xuICAgICAgaWYgKGRpclJFLnRlc3QobmFtZSkpIHtcbiAgICAgICAgdmFyIHZhbHVlID0gbm9kZS5hdHRyc01hcFtuYW1lXTtcbiAgICAgICAgaWYgKHZhbHVlKSB7XG4gICAgICAgICAgdmFyIHJhbmdlID0gbm9kZS5yYXdBdHRyc01hcFtuYW1lXTtcbiAgICAgICAgICBpZiAobmFtZSA9PT0gJ3YtZm9yJykge1xuICAgICAgICAgICAgY2hlY2tGb3Iobm9kZSwgKFwidi1mb3I9XFxcIlwiICsgdmFsdWUgKyBcIlxcXCJcIiksIHdhcm4sIHJhbmdlKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKG5hbWUgPT09ICd2LXNsb3QnIHx8IG5hbWVbMF0gPT09ICcjJykge1xuICAgICAgICAgICAgY2hlY2tGdW5jdGlvblBhcmFtZXRlckV4cHJlc3Npb24odmFsdWUsIChuYW1lICsgXCI9XFxcIlwiICsgdmFsdWUgKyBcIlxcXCJcIiksIHdhcm4sIHJhbmdlKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKG9uUkUudGVzdChuYW1lKSkge1xuICAgICAgICAgICAgY2hlY2tFdmVudCh2YWx1ZSwgKG5hbWUgKyBcIj1cXFwiXCIgKyB2YWx1ZSArIFwiXFxcIlwiKSwgd2FybiwgcmFuZ2UpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjaGVja0V4cHJlc3Npb24odmFsdWUsIChuYW1lICsgXCI9XFxcIlwiICsgdmFsdWUgKyBcIlxcXCJcIiksIHdhcm4sIHJhbmdlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKG5vZGUuY2hpbGRyZW4pIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbm9kZS5jaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgICBjaGVja05vZGUobm9kZS5jaGlsZHJlbltpXSwgd2Fybik7XG4gICAgICB9XG4gICAgfVxuICB9IGVsc2UgaWYgKG5vZGUudHlwZSA9PT0gMikge1xuICAgIGNoZWNrRXhwcmVzc2lvbihub2RlLmV4cHJlc3Npb24sIG5vZGUudGV4dCwgd2Fybiwgbm9kZSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gY2hlY2tFdmVudCAoZXhwLCB0ZXh0LCB3YXJuLCByYW5nZSkge1xuICB2YXIgc3RyaXBwZWQgPSBleHAucmVwbGFjZShzdHJpcFN0cmluZ1JFLCAnJyk7XG4gIHZhciBrZXl3b3JkTWF0Y2ggPSBzdHJpcHBlZC5tYXRjaCh1bmFyeU9wZXJhdG9yc1JFKTtcbiAgaWYgKGtleXdvcmRNYXRjaCAmJiBzdHJpcHBlZC5jaGFyQXQoa2V5d29yZE1hdGNoLmluZGV4IC0gMSkgIT09ICckJykge1xuICAgIHdhcm4oXG4gICAgICBcImF2b2lkIHVzaW5nIEphdmFTY3JpcHQgdW5hcnkgb3BlcmF0b3IgYXMgcHJvcGVydHkgbmFtZTogXCIgK1xuICAgICAgXCJcXFwiXCIgKyAoa2V5d29yZE1hdGNoWzBdKSArIFwiXFxcIiBpbiBleHByZXNzaW9uIFwiICsgKHRleHQudHJpbSgpKSxcbiAgICAgIHJhbmdlXG4gICAgKTtcbiAgfVxuICBjaGVja0V4cHJlc3Npb24oZXhwLCB0ZXh0LCB3YXJuLCByYW5nZSk7XG59XG5cbmZ1bmN0aW9uIGNoZWNrRm9yIChub2RlLCB0ZXh0LCB3YXJuLCByYW5nZSkge1xuICBjaGVja0V4cHJlc3Npb24obm9kZS5mb3IgfHwgJycsIHRleHQsIHdhcm4sIHJhbmdlKTtcbiAgY2hlY2tJZGVudGlmaWVyKG5vZGUuYWxpYXMsICd2LWZvciBhbGlhcycsIHRleHQsIHdhcm4sIHJhbmdlKTtcbiAgY2hlY2tJZGVudGlmaWVyKG5vZGUuaXRlcmF0b3IxLCAndi1mb3IgaXRlcmF0b3InLCB0ZXh0LCB3YXJuLCByYW5nZSk7XG4gIGNoZWNrSWRlbnRpZmllcihub2RlLml0ZXJhdG9yMiwgJ3YtZm9yIGl0ZXJhdG9yJywgdGV4dCwgd2FybiwgcmFuZ2UpO1xufVxuXG5mdW5jdGlvbiBjaGVja0lkZW50aWZpZXIgKFxuICBpZGVudCxcbiAgdHlwZSxcbiAgdGV4dCxcbiAgd2FybixcbiAgcmFuZ2Vcbikge1xuICBpZiAodHlwZW9mIGlkZW50ID09PSAnc3RyaW5nJykge1xuICAgIHRyeSB7XG4gICAgICBuZXcgRnVuY3Rpb24oKFwidmFyIFwiICsgaWRlbnQgKyBcIj1fXCIpKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICB3YXJuKChcImludmFsaWQgXCIgKyB0eXBlICsgXCIgXFxcIlwiICsgaWRlbnQgKyBcIlxcXCIgaW4gZXhwcmVzc2lvbjogXCIgKyAodGV4dC50cmltKCkpKSwgcmFuZ2UpO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBjaGVja0V4cHJlc3Npb24gKGV4cCwgdGV4dCwgd2FybiwgcmFuZ2UpIHtcbiAgdHJ5IHtcbiAgICBuZXcgRnVuY3Rpb24oKFwicmV0dXJuIFwiICsgZXhwKSk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICB2YXIga2V5d29yZE1hdGNoID0gZXhwLnJlcGxhY2Uoc3RyaXBTdHJpbmdSRSwgJycpLm1hdGNoKHByb2hpYml0ZWRLZXl3b3JkUkUpO1xuICAgIGlmIChrZXl3b3JkTWF0Y2gpIHtcbiAgICAgIHdhcm4oXG4gICAgICAgIFwiYXZvaWQgdXNpbmcgSmF2YVNjcmlwdCBrZXl3b3JkIGFzIHByb3BlcnR5IG5hbWU6IFwiICtcbiAgICAgICAgXCJcXFwiXCIgKyAoa2V5d29yZE1hdGNoWzBdKSArIFwiXFxcIlxcbiAgUmF3IGV4cHJlc3Npb246IFwiICsgKHRleHQudHJpbSgpKSxcbiAgICAgICAgcmFuZ2VcbiAgICAgICk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHdhcm4oXG4gICAgICAgIFwiaW52YWxpZCBleHByZXNzaW9uOiBcIiArIChlLm1lc3NhZ2UpICsgXCIgaW5cXG5cXG5cIiArXG4gICAgICAgIFwiICAgIFwiICsgZXhwICsgXCJcXG5cXG5cIiArXG4gICAgICAgIFwiICBSYXcgZXhwcmVzc2lvbjogXCIgKyAodGV4dC50cmltKCkpICsgXCJcXG5cIixcbiAgICAgICAgcmFuZ2VcbiAgICAgICk7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGNoZWNrRnVuY3Rpb25QYXJhbWV0ZXJFeHByZXNzaW9uIChleHAsIHRleHQsIHdhcm4sIHJhbmdlKSB7XG4gIHRyeSB7XG4gICAgbmV3IEZ1bmN0aW9uKGV4cCwgJycpO1xuICB9IGNhdGNoIChlKSB7XG4gICAgd2FybihcbiAgICAgIFwiaW52YWxpZCBmdW5jdGlvbiBwYXJhbWV0ZXIgZXhwcmVzc2lvbjogXCIgKyAoZS5tZXNzYWdlKSArIFwiIGluXFxuXFxuXCIgK1xuICAgICAgXCIgICAgXCIgKyBleHAgKyBcIlxcblxcblwiICtcbiAgICAgIFwiICBSYXcgZXhwcmVzc2lvbjogXCIgKyAodGV4dC50cmltKCkpICsgXCJcXG5cIixcbiAgICAgIHJhbmdlXG4gICAgKTtcbiAgfVxufVxuXG4vKiAgKi9cblxudmFyIHJhbmdlID0gMjtcblxuZnVuY3Rpb24gZ2VuZXJhdGVDb2RlRnJhbWUgKFxuICBzb3VyY2UsXG4gIHN0YXJ0LFxuICBlbmRcbikge1xuICBpZiAoIHN0YXJ0ID09PSB2b2lkIDAgKSBzdGFydCA9IDA7XG4gIGlmICggZW5kID09PSB2b2lkIDAgKSBlbmQgPSBzb3VyY2UubGVuZ3RoO1xuXG4gIHZhciBsaW5lcyA9IHNvdXJjZS5zcGxpdCgvXFxyP1xcbi8pO1xuICB2YXIgY291bnQgPSAwO1xuICB2YXIgcmVzID0gW107XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGluZXMubGVuZ3RoOyBpKyspIHtcbiAgICBjb3VudCArPSBsaW5lc1tpXS5sZW5ndGggKyAxO1xuICAgIGlmIChjb3VudCA+PSBzdGFydCkge1xuICAgICAgZm9yICh2YXIgaiA9IGkgLSByYW5nZTsgaiA8PSBpICsgcmFuZ2UgfHwgZW5kID4gY291bnQ7IGorKykge1xuICAgICAgICBpZiAoaiA8IDAgfHwgaiA+PSBsaW5lcy5sZW5ndGgpIHsgY29udGludWUgfVxuICAgICAgICByZXMucHVzaCgoXCJcIiArIChqICsgMSkgKyAocmVwZWF0JDEoXCIgXCIsIDMgLSBTdHJpbmcoaiArIDEpLmxlbmd0aCkpICsgXCJ8ICBcIiArIChsaW5lc1tqXSkpKTtcbiAgICAgICAgdmFyIGxpbmVMZW5ndGggPSBsaW5lc1tqXS5sZW5ndGg7XG4gICAgICAgIGlmIChqID09PSBpKSB7XG4gICAgICAgICAgLy8gcHVzaCB1bmRlcmxpbmVcbiAgICAgICAgICB2YXIgcGFkID0gc3RhcnQgLSAoY291bnQgLSBsaW5lTGVuZ3RoKSArIDE7XG4gICAgICAgICAgdmFyIGxlbmd0aCA9IGVuZCA+IGNvdW50ID8gbGluZUxlbmd0aCAtIHBhZCA6IGVuZCAtIHN0YXJ0O1xuICAgICAgICAgIHJlcy5wdXNoKFwiICAgfCAgXCIgKyByZXBlYXQkMShcIiBcIiwgcGFkKSArIHJlcGVhdCQxKFwiXlwiLCBsZW5ndGgpKTtcbiAgICAgICAgfSBlbHNlIGlmIChqID4gaSkge1xuICAgICAgICAgIGlmIChlbmQgPiBjb3VudCkge1xuICAgICAgICAgICAgdmFyIGxlbmd0aCQxID0gTWF0aC5taW4oZW5kIC0gY291bnQsIGxpbmVMZW5ndGgpO1xuICAgICAgICAgICAgcmVzLnB1c2goXCIgICB8ICBcIiArIHJlcGVhdCQxKFwiXlwiLCBsZW5ndGgkMSkpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjb3VudCArPSBsaW5lTGVuZ3RoICsgMTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgYnJlYWtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlcy5qb2luKCdcXG4nKVxufVxuXG5mdW5jdGlvbiByZXBlYXQkMSAoc3RyLCBuKSB7XG4gIHZhciByZXN1bHQgPSAnJztcbiAgaWYgKG4gPiAwKSB7XG4gICAgd2hpbGUgKHRydWUpIHsgLy8gZXNsaW50LWRpc2FibGUtbGluZVxuICAgICAgaWYgKG4gJiAxKSB7IHJlc3VsdCArPSBzdHI7IH1cbiAgICAgIG4gPj4+PSAxO1xuICAgICAgaWYgKG4gPD0gMCkgeyBicmVhayB9XG4gICAgICBzdHIgKz0gc3RyO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzdWx0XG59XG5cbi8qICAqL1xuXG5cblxuZnVuY3Rpb24gY3JlYXRlRnVuY3Rpb24gKGNvZGUsIGVycm9ycykge1xuICB0cnkge1xuICAgIHJldHVybiBuZXcgRnVuY3Rpb24oY29kZSlcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgZXJyb3JzLnB1c2goeyBlcnI6IGVyciwgY29kZTogY29kZSB9KTtcbiAgICByZXR1cm4gbm9vcFxuICB9XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUNvbXBpbGVUb0Z1bmN0aW9uRm4gKGNvbXBpbGUpIHtcbiAgdmFyIGNhY2hlID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcblxuICByZXR1cm4gZnVuY3Rpb24gY29tcGlsZVRvRnVuY3Rpb25zIChcbiAgICB0ZW1wbGF0ZSxcbiAgICBvcHRpb25zLFxuICAgIHZtXG4gICkge1xuICAgIG9wdGlvbnMgPSBleHRlbmQoe30sIG9wdGlvbnMpO1xuICAgIHZhciB3YXJuJCQxID0gb3B0aW9ucy53YXJuIHx8IHdhcm47XG4gICAgZGVsZXRlIG9wdGlvbnMud2FybjtcblxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAvLyBkZXRlY3QgcG9zc2libGUgQ1NQIHJlc3RyaWN0aW9uXG4gICAgICB0cnkge1xuICAgICAgICBuZXcgRnVuY3Rpb24oJ3JldHVybiAxJyk7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGlmIChlLnRvU3RyaW5nKCkubWF0Y2goL3Vuc2FmZS1ldmFsfENTUC8pKSB7XG4gICAgICAgICAgd2FybiQkMShcbiAgICAgICAgICAgICdJdCBzZWVtcyB5b3UgYXJlIHVzaW5nIHRoZSBzdGFuZGFsb25lIGJ1aWxkIG9mIFZ1ZS5qcyBpbiBhbiAnICtcbiAgICAgICAgICAgICdlbnZpcm9ubWVudCB3aXRoIENvbnRlbnQgU2VjdXJpdHkgUG9saWN5IHRoYXQgcHJvaGliaXRzIHVuc2FmZS1ldmFsLiAnICtcbiAgICAgICAgICAgICdUaGUgdGVtcGxhdGUgY29tcGlsZXIgY2Fubm90IHdvcmsgaW4gdGhpcyBlbnZpcm9ubWVudC4gQ29uc2lkZXIgJyArXG4gICAgICAgICAgICAncmVsYXhpbmcgdGhlIHBvbGljeSB0byBhbGxvdyB1bnNhZmUtZXZhbCBvciBwcmUtY29tcGlsaW5nIHlvdXIgJyArXG4gICAgICAgICAgICAndGVtcGxhdGVzIGludG8gcmVuZGVyIGZ1bmN0aW9ucy4nXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIC8vIGNoZWNrIGNhY2hlXG4gICAgdmFyIGtleSA9IG9wdGlvbnMuZGVsaW1pdGVyc1xuICAgICAgPyBTdHJpbmcob3B0aW9ucy5kZWxpbWl0ZXJzKSArIHRlbXBsYXRlXG4gICAgICA6IHRlbXBsYXRlO1xuICAgIGlmIChjYWNoZVtrZXldKSB7XG4gICAgICByZXR1cm4gY2FjaGVba2V5XVxuICAgIH1cblxuICAgIC8vIGNvbXBpbGVcbiAgICB2YXIgY29tcGlsZWQgPSBjb21waWxlKHRlbXBsYXRlLCBvcHRpb25zKTtcblxuICAgIC8vIGNoZWNrIGNvbXBpbGF0aW9uIGVycm9ycy90aXBzXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIGlmIChjb21waWxlZC5lcnJvcnMgJiYgY29tcGlsZWQuZXJyb3JzLmxlbmd0aCkge1xuICAgICAgICBpZiAob3B0aW9ucy5vdXRwdXRTb3VyY2VSYW5nZSkge1xuICAgICAgICAgIGNvbXBpbGVkLmVycm9ycy5mb3JFYWNoKGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICB3YXJuJCQxKFxuICAgICAgICAgICAgICBcIkVycm9yIGNvbXBpbGluZyB0ZW1wbGF0ZTpcXG5cXG5cIiArIChlLm1zZykgKyBcIlxcblxcblwiICtcbiAgICAgICAgICAgICAgZ2VuZXJhdGVDb2RlRnJhbWUodGVtcGxhdGUsIGUuc3RhcnQsIGUuZW5kKSxcbiAgICAgICAgICAgICAgdm1cbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgd2FybiQkMShcbiAgICAgICAgICAgIFwiRXJyb3IgY29tcGlsaW5nIHRlbXBsYXRlOlxcblxcblwiICsgdGVtcGxhdGUgKyBcIlxcblxcblwiICtcbiAgICAgICAgICAgIGNvbXBpbGVkLmVycm9ycy5tYXAoZnVuY3Rpb24gKGUpIHsgcmV0dXJuIChcIi0gXCIgKyBlKTsgfSkuam9pbignXFxuJykgKyAnXFxuJyxcbiAgICAgICAgICAgIHZtXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGNvbXBpbGVkLnRpcHMgJiYgY29tcGlsZWQudGlwcy5sZW5ndGgpIHtcbiAgICAgICAgaWYgKG9wdGlvbnMub3V0cHV0U291cmNlUmFuZ2UpIHtcbiAgICAgICAgICBjb21waWxlZC50aXBzLmZvckVhY2goZnVuY3Rpb24gKGUpIHsgcmV0dXJuIHRpcChlLm1zZywgdm0pOyB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjb21waWxlZC50aXBzLmZvckVhY2goZnVuY3Rpb24gKG1zZykgeyByZXR1cm4gdGlwKG1zZywgdm0pOyB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIC8vIHR1cm4gY29kZSBpbnRvIGZ1bmN0aW9uc1xuICAgIHZhciByZXMgPSB7fTtcbiAgICB2YXIgZm5HZW5FcnJvcnMgPSBbXTtcbiAgICByZXMucmVuZGVyID0gY3JlYXRlRnVuY3Rpb24oY29tcGlsZWQucmVuZGVyLCBmbkdlbkVycm9ycyk7XG4gICAgcmVzLnN0YXRpY1JlbmRlckZucyA9IGNvbXBpbGVkLnN0YXRpY1JlbmRlckZucy5tYXAoZnVuY3Rpb24gKGNvZGUpIHtcbiAgICAgIHJldHVybiBjcmVhdGVGdW5jdGlvbihjb2RlLCBmbkdlbkVycm9ycylcbiAgICB9KTtcblxuICAgIC8vIGNoZWNrIGZ1bmN0aW9uIGdlbmVyYXRpb24gZXJyb3JzLlxuICAgIC8vIHRoaXMgc2hvdWxkIG9ubHkgaGFwcGVuIGlmIHRoZXJlIGlzIGEgYnVnIGluIHRoZSBjb21waWxlciBpdHNlbGYuXG4gICAgLy8gbW9zdGx5IGZvciBjb2RlZ2VuIGRldmVsb3BtZW50IHVzZVxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICBpZiAoKCFjb21waWxlZC5lcnJvcnMgfHwgIWNvbXBpbGVkLmVycm9ycy5sZW5ndGgpICYmIGZuR2VuRXJyb3JzLmxlbmd0aCkge1xuICAgICAgICB3YXJuJCQxKFxuICAgICAgICAgIFwiRmFpbGVkIHRvIGdlbmVyYXRlIHJlbmRlciBmdW5jdGlvbjpcXG5cXG5cIiArXG4gICAgICAgICAgZm5HZW5FcnJvcnMubWFwKGZ1bmN0aW9uIChyZWYpIHtcbiAgICAgICAgICAgIHZhciBlcnIgPSByZWYuZXJyO1xuICAgICAgICAgICAgdmFyIGNvZGUgPSByZWYuY29kZTtcblxuICAgICAgICAgICAgcmV0dXJuICgoZXJyLnRvU3RyaW5nKCkpICsgXCIgaW5cXG5cXG5cIiArIGNvZGUgKyBcIlxcblwiKTtcbiAgICAgICAgfSkuam9pbignXFxuJyksXG4gICAgICAgICAgdm1cbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gKGNhY2hlW2tleV0gPSByZXMpXG4gIH1cbn1cblxuLyogICovXG5cbmZ1bmN0aW9uIGNyZWF0ZUNvbXBpbGVyQ3JlYXRvciAoYmFzZUNvbXBpbGUpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIGNyZWF0ZUNvbXBpbGVyIChiYXNlT3B0aW9ucykge1xuICAgIGZ1bmN0aW9uIGNvbXBpbGUgKFxuICAgICAgdGVtcGxhdGUsXG4gICAgICBvcHRpb25zXG4gICAgKSB7XG4gICAgICB2YXIgZmluYWxPcHRpb25zID0gT2JqZWN0LmNyZWF0ZShiYXNlT3B0aW9ucyk7XG4gICAgICB2YXIgZXJyb3JzID0gW107XG4gICAgICB2YXIgdGlwcyA9IFtdO1xuXG4gICAgICB2YXIgd2FybiA9IGZ1bmN0aW9uIChtc2csIHJhbmdlLCB0aXApIHtcbiAgICAgICAgKHRpcCA/IHRpcHMgOiBlcnJvcnMpLnB1c2gobXNnKTtcbiAgICAgIH07XG5cbiAgICAgIGlmIChvcHRpb25zKSB7XG4gICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIG9wdGlvbnMub3V0cHV0U291cmNlUmFuZ2UpIHtcbiAgICAgICAgICAvLyAkZmxvdy1kaXNhYmxlLWxpbmVcbiAgICAgICAgICB2YXIgbGVhZGluZ1NwYWNlTGVuZ3RoID0gdGVtcGxhdGUubWF0Y2goL15cXHMqLylbMF0ubGVuZ3RoO1xuXG4gICAgICAgICAgd2FybiA9IGZ1bmN0aW9uIChtc2csIHJhbmdlLCB0aXApIHtcbiAgICAgICAgICAgIHZhciBkYXRhID0geyBtc2c6IG1zZyB9O1xuICAgICAgICAgICAgaWYgKHJhbmdlKSB7XG4gICAgICAgICAgICAgIGlmIChyYW5nZS5zdGFydCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgZGF0YS5zdGFydCA9IHJhbmdlLnN0YXJ0ICsgbGVhZGluZ1NwYWNlTGVuZ3RoO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmIChyYW5nZS5lbmQgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGRhdGEuZW5kID0gcmFuZ2UuZW5kICsgbGVhZGluZ1NwYWNlTGVuZ3RoO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAodGlwID8gdGlwcyA6IGVycm9ycykucHVzaChkYXRhKTtcbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIC8vIG1lcmdlIGN1c3RvbSBtb2R1bGVzXG4gICAgICAgIGlmIChvcHRpb25zLm1vZHVsZXMpIHtcbiAgICAgICAgICBmaW5hbE9wdGlvbnMubW9kdWxlcyA9XG4gICAgICAgICAgICAoYmFzZU9wdGlvbnMubW9kdWxlcyB8fCBbXSkuY29uY2F0KG9wdGlvbnMubW9kdWxlcyk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gbWVyZ2UgY3VzdG9tIGRpcmVjdGl2ZXNcbiAgICAgICAgaWYgKG9wdGlvbnMuZGlyZWN0aXZlcykge1xuICAgICAgICAgIGZpbmFsT3B0aW9ucy5kaXJlY3RpdmVzID0gZXh0ZW5kKFxuICAgICAgICAgICAgT2JqZWN0LmNyZWF0ZShiYXNlT3B0aW9ucy5kaXJlY3RpdmVzIHx8IG51bGwpLFxuICAgICAgICAgICAgb3B0aW9ucy5kaXJlY3RpdmVzXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBjb3B5IG90aGVyIG9wdGlvbnNcbiAgICAgICAgZm9yICh2YXIga2V5IGluIG9wdGlvbnMpIHtcbiAgICAgICAgICBpZiAoa2V5ICE9PSAnbW9kdWxlcycgJiYga2V5ICE9PSAnZGlyZWN0aXZlcycpIHtcbiAgICAgICAgICAgIGZpbmFsT3B0aW9uc1trZXldID0gb3B0aW9uc1trZXldO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBmaW5hbE9wdGlvbnMud2FybiA9IHdhcm47XG5cbiAgICAgIHZhciBjb21waWxlZCA9IGJhc2VDb21waWxlKHRlbXBsYXRlLnRyaW0oKSwgZmluYWxPcHRpb25zKTtcbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgIGRldGVjdEVycm9ycyhjb21waWxlZC5hc3QsIHdhcm4pO1xuICAgICAgfVxuICAgICAgY29tcGlsZWQuZXJyb3JzID0gZXJyb3JzO1xuICAgICAgY29tcGlsZWQudGlwcyA9IHRpcHM7XG4gICAgICByZXR1cm4gY29tcGlsZWRcbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgY29tcGlsZTogY29tcGlsZSxcbiAgICAgIGNvbXBpbGVUb0Z1bmN0aW9uczogY3JlYXRlQ29tcGlsZVRvRnVuY3Rpb25Gbihjb21waWxlKVxuICAgIH1cbiAgfVxufVxuXG4vKiAgKi9cblxuLy8gYGNyZWF0ZUNvbXBpbGVyQ3JlYXRvcmAgYWxsb3dzIGNyZWF0aW5nIGNvbXBpbGVycyB0aGF0IHVzZSBhbHRlcm5hdGl2ZVxuLy8gcGFyc2VyL29wdGltaXplci9jb2RlZ2VuLCBlLmcgdGhlIFNTUiBvcHRpbWl6aW5nIGNvbXBpbGVyLlxuLy8gSGVyZSB3ZSBqdXN0IGV4cG9ydCBhIGRlZmF1bHQgY29tcGlsZXIgdXNpbmcgdGhlIGRlZmF1bHQgcGFydHMuXG52YXIgY3JlYXRlQ29tcGlsZXIgPSBjcmVhdGVDb21waWxlckNyZWF0b3IoZnVuY3Rpb24gYmFzZUNvbXBpbGUgKFxuICB0ZW1wbGF0ZSxcbiAgb3B0aW9uc1xuKSB7XG4gIHZhciBhc3QgPSBwYXJzZSh0ZW1wbGF0ZS50cmltKCksIG9wdGlvbnMpO1xuICBpZiAob3B0aW9ucy5vcHRpbWl6ZSAhPT0gZmFsc2UpIHtcbiAgICBvcHRpbWl6ZShhc3QsIG9wdGlvbnMpO1xuICB9XG4gIHZhciBjb2RlID0gZ2VuZXJhdGUoYXN0LCBvcHRpb25zKTtcbiAgcmV0dXJuIHtcbiAgICBhc3Q6IGFzdCxcbiAgICByZW5kZXI6IGNvZGUucmVuZGVyLFxuICAgIHN0YXRpY1JlbmRlckZuczogY29kZS5zdGF0aWNSZW5kZXJGbnNcbiAgfVxufSk7XG5cbi8qICAqL1xuXG52YXIgcmVmJDEgPSBjcmVhdGVDb21waWxlcihiYXNlT3B0aW9ucyk7XG52YXIgY29tcGlsZSA9IHJlZiQxLmNvbXBpbGU7XG52YXIgY29tcGlsZVRvRnVuY3Rpb25zID0gcmVmJDEuY29tcGlsZVRvRnVuY3Rpb25zO1xuXG4vKiAgKi9cblxuLy8gY2hlY2sgd2hldGhlciBjdXJyZW50IGJyb3dzZXIgZW5jb2RlcyBhIGNoYXIgaW5zaWRlIGF0dHJpYnV0ZSB2YWx1ZXNcbnZhciBkaXY7XG5mdW5jdGlvbiBnZXRTaG91bGREZWNvZGUgKGhyZWYpIHtcbiAgZGl2ID0gZGl2IHx8IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICBkaXYuaW5uZXJIVE1MID0gaHJlZiA/IFwiPGEgaHJlZj1cXFwiXFxuXFxcIi8+XCIgOiBcIjxkaXYgYT1cXFwiXFxuXFxcIi8+XCI7XG4gIHJldHVybiBkaXYuaW5uZXJIVE1MLmluZGV4T2YoJyYjMTA7JykgPiAwXG59XG5cbi8vICMzNjYzOiBJRSBlbmNvZGVzIG5ld2xpbmVzIGluc2lkZSBhdHRyaWJ1dGUgdmFsdWVzIHdoaWxlIG90aGVyIGJyb3dzZXJzIGRvbid0XG52YXIgc2hvdWxkRGVjb2RlTmV3bGluZXMgPSBpbkJyb3dzZXIgPyBnZXRTaG91bGREZWNvZGUoZmFsc2UpIDogZmFsc2U7XG4vLyAjNjgyODogY2hyb21lIGVuY29kZXMgY29udGVudCBpbiBhW2hyZWZdXG52YXIgc2hvdWxkRGVjb2RlTmV3bGluZXNGb3JIcmVmID0gaW5Ccm93c2VyID8gZ2V0U2hvdWxkRGVjb2RlKHRydWUpIDogZmFsc2U7XG5cbi8qICAqL1xuXG52YXIgaWRUb1RlbXBsYXRlID0gY2FjaGVkKGZ1bmN0aW9uIChpZCkge1xuICB2YXIgZWwgPSBxdWVyeShpZCk7XG4gIHJldHVybiBlbCAmJiBlbC5pbm5lckhUTUxcbn0pO1xuXG52YXIgbW91bnQgPSBWdWUucHJvdG90eXBlLiRtb3VudDtcblZ1ZS5wcm90b3R5cGUuJG1vdW50ID0gZnVuY3Rpb24gKFxuICBlbCxcbiAgaHlkcmF0aW5nXG4pIHtcbiAgZWwgPSBlbCAmJiBxdWVyeShlbCk7XG5cbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gIGlmIChlbCA9PT0gZG9jdW1lbnQuYm9keSB8fCBlbCA9PT0gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50KSB7XG4gICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiB3YXJuKFxuICAgICAgXCJEbyBub3QgbW91bnQgVnVlIHRvIDxodG1sPiBvciA8Ym9keT4gLSBtb3VudCB0byBub3JtYWwgZWxlbWVudHMgaW5zdGVhZC5cIlxuICAgICk7XG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG4gIHZhciBvcHRpb25zID0gdGhpcy4kb3B0aW9ucztcbiAgLy8gcmVzb2x2ZSB0ZW1wbGF0ZS9lbCBhbmQgY29udmVydCB0byByZW5kZXIgZnVuY3Rpb25cbiAgaWYgKCFvcHRpb25zLnJlbmRlcikge1xuICAgIHZhciB0ZW1wbGF0ZSA9IG9wdGlvbnMudGVtcGxhdGU7XG4gICAgaWYgKHRlbXBsYXRlKSB7XG4gICAgICBpZiAodHlwZW9mIHRlbXBsYXRlID09PSAnc3RyaW5nJykge1xuICAgICAgICBpZiAodGVtcGxhdGUuY2hhckF0KDApID09PSAnIycpIHtcbiAgICAgICAgICB0ZW1wbGF0ZSA9IGlkVG9UZW1wbGF0ZSh0ZW1wbGF0ZSk7XG4gICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgIXRlbXBsYXRlKSB7XG4gICAgICAgICAgICB3YXJuKFxuICAgICAgICAgICAgICAoXCJUZW1wbGF0ZSBlbGVtZW50IG5vdCBmb3VuZCBvciBpcyBlbXB0eTogXCIgKyAob3B0aW9ucy50ZW1wbGF0ZSkpLFxuICAgICAgICAgICAgICB0aGlzXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmICh0ZW1wbGF0ZS5ub2RlVHlwZSkge1xuICAgICAgICB0ZW1wbGF0ZSA9IHRlbXBsYXRlLmlubmVySFRNTDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgICAgd2FybignaW52YWxpZCB0ZW1wbGF0ZSBvcHRpb246JyArIHRlbXBsYXRlLCB0aGlzKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpc1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoZWwpIHtcbiAgICAgIHRlbXBsYXRlID0gZ2V0T3V0ZXJIVE1MKGVsKTtcbiAgICB9XG4gICAgaWYgKHRlbXBsYXRlKSB7XG4gICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIGNvbmZpZy5wZXJmb3JtYW5jZSAmJiBtYXJrKSB7XG4gICAgICAgIG1hcmsoJ2NvbXBpbGUnKTtcbiAgICAgIH1cblxuICAgICAgdmFyIHJlZiA9IGNvbXBpbGVUb0Z1bmN0aW9ucyh0ZW1wbGF0ZSwge1xuICAgICAgICBvdXRwdXRTb3VyY2VSYW5nZTogcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyxcbiAgICAgICAgc2hvdWxkRGVjb2RlTmV3bGluZXM6IHNob3VsZERlY29kZU5ld2xpbmVzLFxuICAgICAgICBzaG91bGREZWNvZGVOZXdsaW5lc0ZvckhyZWY6IHNob3VsZERlY29kZU5ld2xpbmVzRm9ySHJlZixcbiAgICAgICAgZGVsaW1pdGVyczogb3B0aW9ucy5kZWxpbWl0ZXJzLFxuICAgICAgICBjb21tZW50czogb3B0aW9ucy5jb21tZW50c1xuICAgICAgfSwgdGhpcyk7XG4gICAgICB2YXIgcmVuZGVyID0gcmVmLnJlbmRlcjtcbiAgICAgIHZhciBzdGF0aWNSZW5kZXJGbnMgPSByZWYuc3RhdGljUmVuZGVyRm5zO1xuICAgICAgb3B0aW9ucy5yZW5kZXIgPSByZW5kZXI7XG4gICAgICBvcHRpb25zLnN0YXRpY1JlbmRlckZucyA9IHN0YXRpY1JlbmRlckZucztcblxuICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiBjb25maWcucGVyZm9ybWFuY2UgJiYgbWFyaykge1xuICAgICAgICBtYXJrKCdjb21waWxlIGVuZCcpO1xuICAgICAgICBtZWFzdXJlKChcInZ1ZSBcIiArICh0aGlzLl9uYW1lKSArIFwiIGNvbXBpbGVcIiksICdjb21waWxlJywgJ2NvbXBpbGUgZW5kJyk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiBtb3VudC5jYWxsKHRoaXMsIGVsLCBoeWRyYXRpbmcpXG59O1xuXG4vKipcbiAqIEdldCBvdXRlckhUTUwgb2YgZWxlbWVudHMsIHRha2luZyBjYXJlXG4gKiBvZiBTVkcgZWxlbWVudHMgaW4gSUUgYXMgd2VsbC5cbiAqL1xuZnVuY3Rpb24gZ2V0T3V0ZXJIVE1MIChlbCkge1xuICBpZiAoZWwub3V0ZXJIVE1MKSB7XG4gICAgcmV0dXJuIGVsLm91dGVySFRNTFxuICB9IGVsc2Uge1xuICAgIHZhciBjb250YWluZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICBjb250YWluZXIuYXBwZW5kQ2hpbGQoZWwuY2xvbmVOb2RlKHRydWUpKTtcbiAgICByZXR1cm4gY29udGFpbmVyLmlubmVySFRNTFxuICB9XG59XG5cblZ1ZS5jb21waWxlID0gY29tcGlsZVRvRnVuY3Rpb25zO1xuXG5leHBvcnQgZGVmYXVsdCBWdWU7XG4iLCIvLyBUaGUgbW9kdWxlIGNhY2hlXG52YXIgX193ZWJwYWNrX21vZHVsZV9jYWNoZV9fID0ge307XG5cbi8vIFRoZSByZXF1aXJlIGZ1bmN0aW9uXG5mdW5jdGlvbiBfX3dlYnBhY2tfcmVxdWlyZV9fKG1vZHVsZUlkKSB7XG5cdC8vIENoZWNrIGlmIG1vZHVsZSBpcyBpbiBjYWNoZVxuXHR2YXIgY2FjaGVkTW9kdWxlID0gX193ZWJwYWNrX21vZHVsZV9jYWNoZV9fW21vZHVsZUlkXTtcblx0aWYgKGNhY2hlZE1vZHVsZSAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0cmV0dXJuIGNhY2hlZE1vZHVsZS5leHBvcnRzO1xuXHR9XG5cdC8vIENyZWF0ZSBhIG5ldyBtb2R1bGUgKGFuZCBwdXQgaXQgaW50byB0aGUgY2FjaGUpXG5cdHZhciBtb2R1bGUgPSBfX3dlYnBhY2tfbW9kdWxlX2NhY2hlX19bbW9kdWxlSWRdID0ge1xuXHRcdC8vIG5vIG1vZHVsZS5pZCBuZWVkZWRcblx0XHQvLyBubyBtb2R1bGUubG9hZGVkIG5lZWRlZFxuXHRcdGV4cG9ydHM6IHt9XG5cdH07XG5cblx0Ly8gRXhlY3V0ZSB0aGUgbW9kdWxlIGZ1bmN0aW9uXG5cdF9fd2VicGFja19tb2R1bGVzX19bbW9kdWxlSWRdKG1vZHVsZSwgbW9kdWxlLmV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pO1xuXG5cdC8vIFJldHVybiB0aGUgZXhwb3J0cyBvZiB0aGUgbW9kdWxlXG5cdHJldHVybiBtb2R1bGUuZXhwb3J0cztcbn1cblxuIiwiLy8gZ2V0RGVmYXVsdEV4cG9ydCBmdW5jdGlvbiBmb3IgY29tcGF0aWJpbGl0eSB3aXRoIG5vbi1oYXJtb255IG1vZHVsZXNcbl9fd2VicGFja19yZXF1aXJlX18ubiA9IChtb2R1bGUpID0+IHtcblx0dmFyIGdldHRlciA9IG1vZHVsZSAmJiBtb2R1bGUuX19lc01vZHVsZSA/XG5cdFx0KCkgPT4gKG1vZHVsZVsnZGVmYXVsdCddKSA6XG5cdFx0KCkgPT4gKG1vZHVsZSk7XG5cdF9fd2VicGFja19yZXF1aXJlX18uZChnZXR0ZXIsIHsgYTogZ2V0dGVyIH0pO1xuXHRyZXR1cm4gZ2V0dGVyO1xufTsiLCIvLyBkZWZpbmUgZ2V0dGVyIGZ1bmN0aW9ucyBmb3IgaGFybW9ueSBleHBvcnRzXG5fX3dlYnBhY2tfcmVxdWlyZV9fLmQgPSAoZXhwb3J0cywgZGVmaW5pdGlvbikgPT4ge1xuXHRmb3IodmFyIGtleSBpbiBkZWZpbml0aW9uKSB7XG5cdFx0aWYoX193ZWJwYWNrX3JlcXVpcmVfXy5vKGRlZmluaXRpb24sIGtleSkgJiYgIV9fd2VicGFja19yZXF1aXJlX18ubyhleHBvcnRzLCBrZXkpKSB7XG5cdFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywga2V5LCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZGVmaW5pdGlvbltrZXldIH0pO1xuXHRcdH1cblx0fVxufTsiLCJfX3dlYnBhY2tfcmVxdWlyZV9fLmcgPSAoZnVuY3Rpb24oKSB7XG5cdGlmICh0eXBlb2YgZ2xvYmFsVGhpcyA9PT0gJ29iamVjdCcpIHJldHVybiBnbG9iYWxUaGlzO1xuXHR0cnkge1xuXHRcdHJldHVybiB0aGlzIHx8IG5ldyBGdW5jdGlvbigncmV0dXJuIHRoaXMnKSgpO1xuXHR9IGNhdGNoIChlKSB7XG5cdFx0aWYgKHR5cGVvZiB3aW5kb3cgPT09ICdvYmplY3QnKSByZXR1cm4gd2luZG93O1xuXHR9XG59KSgpOyIsIl9fd2VicGFja19yZXF1aXJlX18ubyA9IChvYmosIHByb3ApID0+IChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBwcm9wKSkiLCIvLyBkZWZpbmUgX19lc01vZHVsZSBvbiBleHBvcnRzXG5fX3dlYnBhY2tfcmVxdWlyZV9fLnIgPSAoZXhwb3J0cykgPT4ge1xuXHRpZih0eXBlb2YgU3ltYm9sICE9PSAndW5kZWZpbmVkJyAmJiBTeW1ib2wudG9TdHJpbmdUYWcpIHtcblx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgU3ltYm9sLnRvU3RyaW5nVGFnLCB7IHZhbHVlOiAnTW9kdWxlJyB9KTtcblx0fVxuXHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xufTsiLCIvKipcbiAqIE1haW4gYXBwIGVudHJ5IGZpbGUuXG4gKi9cbndpbmRvdy5ERUJVRyA9IGZhbHNlO1xuXG4vLyBhcHAgZGVwZW5kZW5jaWVzXG5pbXBvcnQgZGVmT3B0cyBmcm9tICcuL2NvbmZpZ3MvZGVmYXVsdE9wdGlvbnMnO1xuaW1wb3J0IE9wdGlvbnMgZnJvbSAnLi9tb2R1bGVzL29wdGlvbnMnO1xuaW1wb3J0IEFqYXggZnJvbSAnLi9tb2R1bGVzL2FqYXgnO1xuaW1wb3J0IEJpbmFuY2UgZnJvbSAnLi9tb2R1bGVzL2JpbmFuY2UnO1xuaW1wb3J0IENvaW5jYXAgZnJvbSAnLi9tb2R1bGVzL2NvaW5jYXAnO1xuaW1wb3J0IEFsYXJtcyBmcm9tICcuL21vZHVsZXMvYWxhcm1zJztcbmltcG9ydCBIaXN0b3J5IGZyb20gJy4vbW9kdWxlcy9oaXN0b3J5JztcbmltcG9ydCBOb3RpZnkgZnJvbSAnLi9tb2R1bGVzL25vdGlmeSc7XG5pbXBvcnQgTmV3cyBmcm9tICcuL21vZHVsZXMvbmV3cyc7XG5pbXBvcnQgTWVzc2VuZ2VyIGZyb20gJy4vbW9kdWxlcy9tZXNzZW5nZXInO1xuaW1wb3J0IFJvdXRlciBmcm9tICcuL21vZHVsZXMvcm91dGVyJztcbmltcG9ydCBCdXMgZnJvbSAnLi9tb2R1bGVzL2J1cyc7XG5pbXBvcnQgU29ydGVyIGZyb20gJy4vbW9kdWxlcy9zb3J0ZXInO1xuaW1wb3J0IFNjcm9sbGVyIGZyb20gJy4vbW9kdWxlcy9zY3JvbGxlcic7XG5pbXBvcnQgVG9vbHRpcCBmcm9tICcuL21vZHVsZXMvdG9vbHRpcCc7XG5pbXBvcnQgc3RvcmUgZnJvbSAnLi9tb2R1bGVzL3N0b3JlJztcbmltcG9ydCBzZW50aW1lbnQgZnJvbSAnLi9tb2R1bGVzL3NlbnRpbWVudCc7XG5pbXBvcnQgdXRpbHMgZnJvbSAnLi9tb2R1bGVzL3V0aWxzJztcbmltcG9ydCBBcHAgZnJvbSAnLi9jb21wb25lbnRzL0FwcC52dWUnO1xuaW1wb3J0IFZ1ZSBmcm9tICd2dWUnO1xuaW1wb3J0IENvaW5iYXNlcHJvIGZyb20gJy4vbW9kdWxlcy9jb2luYmFzZXBybyc7XG5cbi8vIHNldHVwIGNvbW1vbiBoZWxwZXIgY2xhc3Nlc1xuY29uc3QgX29wdGlvbnMgPSBuZXcgT3B0aW9ucyggZGVmT3B0cyApO1xuY29uc3QgX2FqYXggPSBuZXcgQWpheCgpO1xuY29uc3QgX2JpbmFuY2UgPSBuZXcgQmluYW5jZSgpO1xuY29uc3QgX2NvaW5iYXNlcHJvID0gbmV3IENvaW5iYXNlcHJvKCk7XG5jb25zdCBfY29pbmNhcCA9IG5ldyBDb2luY2FwKCk7XG5jb25zdCBfYWxhcm1zID0gbmV3IEFsYXJtcygpO1xuY29uc3QgX2hpc3RvcnkgPSBuZXcgSGlzdG9yeSgpO1xuY29uc3QgX25vdGlmeSA9IG5ldyBOb3RpZnkoKTtcbmNvbnN0IF9uZXdzID0gbmV3IE5ld3MoKTtcbmNvbnN0IF9tZXNzZW5nZXIgPSBuZXcgTWVzc2VuZ2VyKCk7XG5jb25zdCBfcm91dGVyID0gbmV3IFJvdXRlcigpO1xuY29uc3QgX2J1cyA9IG5ldyBCdXMoKTtcbmNvbnN0IF9zb3J0ZXIgPSBuZXcgU29ydGVyKCk7XG5jb25zdCBfc2Nyb2xsZXIgPSBuZXcgU2Nyb2xsZXIoKTtcbmNvbnN0IF90b29sdGlwID0gbmV3IFRvb2x0aXAoKTtcblxuLy8gY3JlYXRlIGN1c3RvbSBnbG9iYWwgdnVlIHByb3BlcnRpZXNcbk9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKCBWdWUucHJvdG90eXBlLCB7XG4gICRvcHRzOiB7IGdldCgpIHsgcmV0dXJuIF9vcHRpb25zOyB9IH0sXG4gICRhamF4OiB7IGdldCgpIHsgcmV0dXJuIF9hamF4OyB9IH0sXG4gICRiaW5hbmNlOiB7IGdldCgpIHsgcmV0dXJuIF9iaW5hbmNlOyB9IH0sXG4gICRjb2luYmFzZXBybzogeyBnZXQoKSB7IHJldHVybiBfY29pbmJhc2Vwcm87IH0gfSxcbiAgJGNvaW5jYXA6IHsgZ2V0KCkgeyByZXR1cm4gX2NvaW5jYXA7IH0gfSxcbiAgJGFsYXJtczogeyBnZXQoKSB7IHJldHVybiBfYWxhcm1zOyB9IH0sXG4gICRoaXN0b3J5OiB7IGdldCgpIHsgcmV0dXJuIF9oaXN0b3J5OyB9IH0sXG4gICRub3RpZnk6IHsgZ2V0KCkgeyByZXR1cm4gX25vdGlmeTsgfSB9LFxuICAkbmV3czogeyBnZXQoKSB7IHJldHVybiBfbmV3czsgfSB9LFxuICAkbWVzc2VuZ2VyOiB7IGdldCgpIHsgcmV0dXJuIF9tZXNzZW5nZXI7IH0gfSxcbiAgJHJvdXRlcjogeyBnZXQoKSB7IHJldHVybiBfcm91dGVyOyB9IH0sXG4gICRzY3JvbGxlcjogeyBnZXQoKSB7IHJldHVybiBfc2Nyb2xsZXI7IH0gfSxcbiAgJGJ1czogeyBnZXQoKSB7IHJldHVybiBfYnVzOyB9IH0sXG4gICRzb3J0ZXI6IHsgZ2V0KCkgeyByZXR1cm4gX3NvcnRlcjsgfSB9LFxuICAkc3RvcmU6IHsgZ2V0KCkgeyByZXR1cm4gc3RvcmU7IH0gfSxcbiAgJHNlbnRpbWVudDogeyBnZXQoKSB7IHJldHVybiBzZW50aW1lbnQ7IH0gfSxcbiAgJHV0aWxzOiB7IGdldCgpIHsgcmV0dXJuIHV0aWxzOyB9IH0sXG59KTtcblxuLy8gc2luZ2xlIHRvb2x0aXAgaW5zdGFuY2UgZm9yIGVudGlyZSBhcHBcblZ1ZS5kaXJlY3RpdmUoICd0b29sdGlwJywge1xuICBiaW5kOiBlbCA9PiB7IF90b29sdGlwLnNlbGVjdCggZWwgKTsgfSxcbiAgdW5iaW5kOiBlbCA9PiB7IF90b29sdGlwLnVuc2VsZWN0KCBlbCApOyB9LFxufSk7XG5cbi8vIGdsb2JhbCBmaWx0ZXJzIHVzZWQgdG8gZm9ybWF0IGN1cnJlbmN5IGFuZCBwcmljZSBjaGFuZ2UgdmFsdWVzXG5WdWUuZmlsdGVyKCAndG9MaW5rcycsICggdGV4dCApID0+IHV0aWxzLmxpbmtVcmwoIHRleHQgKSApO1xuVnVlLmZpbHRlciggJ3RvTm91bicsICggbnVtLCBzLCBwICkgPT4gdXRpbHMubm91biggbnVtLCBzLCBwICkgKTtcblZ1ZS5maWx0ZXIoICd0b0VsYXBzZWQnLCAoIHRpbWUsIHN1ZmZpeCwgc2hvcnQgKSA9PiB1dGlscy5lbGFwc2VkKCAoIERhdGUubm93KCkgLSB0aW1lICkgLyAxMDAwLCBzdWZmaXgsIHNob3J0ICkgKTtcblZ1ZS5maWx0ZXIoICd0b0RhdGUnLCAoIHRpbWUsIGZ1bGwgKSA9PiB1dGlscy5kYXRlKCB0aW1lLCBmdWxsICkgKTtcblZ1ZS5maWx0ZXIoICd0b01vbmV5JywgKCBudW0sIGRlY2ltYWxzICkgPT4gdXRpbHMubW9uZXkoIG51bSwgZGVjaW1hbHMgKSApO1xuVnVlLmZpbHRlciggJ3RvRml4ZWQnLCAoIG51bSwgYXNzZXQgKSA9PiB1dGlscy5maXhlZCggbnVtLCBhc3NldCApICk7XG5cbi8vIGluaXQgYW5kL29yIHJlbmRlclxud2luZG93LmFkZEV2ZW50TGlzdGVuZXIoICdsb2FkJywgZSA9PiB7XG4gIGlmICggd2luZG93LnRvcCAhPT0gd2luZG93ICkgcmV0dXJuO1xuICBkb2N1bWVudC5ib2R5LnNldEF0dHJpYnV0ZSggJ3RhYmluZGV4JywgJzAnICk7XG4gIG5ldyBWdWUoIHsgZWw6ICcjbWFya2V0JywgcmVuZGVyOiBoID0+IGgoIEFwcCApIH0gKTtcbn0pO1xuIl0sIm5hbWVzIjpbInR4dCIsInByb3h5IiwicHJveHlsaXN0Iiwibm90aWZ5IiwiZW5hYmxlZCIsImR1cmF0aW9uIiwiYXVkaW8iLCJ2b2x1bWUiLCJmaWxlIiwic2VhcmNoIiwiZnVsbHdvcmQiLCJmdWxsY2FzZSIsInByaWNlcyIsImhlYWRlciIsImNoYXJ0IiwibWFya2V0Iiwic29ydCIsIm9yZGVyIiwibGltaXQiLCJuZXdzIiwic2VuZCIsImludGVydmFsIiwiZGVsYXkiLCJ0d2VldHMiLCJ0b3RhbCIsIm1heCIsImRheXMiLCJiaW5hbmNlIiwiYXBpa2V5IiwiYXBpc2VjcmV0IiwibWFpbGd1biIsImRvbWFpbiIsImVtYWlsIiwidGVsZWdyYW0iLCJib3RrZXkiLCJ1c2VyaWQiLCJzdG9yZSIsImxvZ2dlciIsInV0aWxzIiwiQWpheCIsIm9wdGlvbnMiLCJfdXJsIiwiX29wdGlvbnMiLCJjYWNoZSIsInByZWZpeCIsInNldE9wdGlvbnMiLCJPYmplY3QiLCJhc3NpZ24iLCJkYXRhIiwicSIsImtleXMiLCJmb3JFYWNoIiwiayIsInB1c2giLCJlbmNvZGVVUklDb21wb25lbnQiLCJqb2luIiwiYWRkcmVzcyIsInJlcXVlc3QiLCJtZXRob2QiLCJTdHJpbmciLCJ0b1VwcGVyQ2FzZSIsInRyaW0iLCJpc0RvbmUiLCJ0eXBlIiwidGltZW91dCIsInBhcnNlSW50IiwiaGVhZGVycyIsImNhY2hlVGltZSIsImNhY2hlS2V5IiwidW5pcXVlIiwieGhyIiwiWE1MSHR0cFJlcXVlc3QiLCJvbkVycm9yIiwiZXJyb3IiLCJvblN1Y2Nlc3MiLCJzdWNjZXNzIiwib25Eb25lIiwiZG9uZSIsImNhY2hlRGF0YSIsImdldERhdGEiLCJmdWxsVXJsIiwiVVJMIiwiZXJyIiwic2VyaWFsaXplRGF0YSIsIm9wZW4iLCJyZXNwb25zZVR5cGUiLCJzZXRSZXF1ZXN0SGVhZGVyIiwibm90QWpheCIsImF1dGgiLCJ1c2VybmFtZSIsInBhc3N3b3JkIiwiYnRvYSIsIm5hbWUiLCJhZGRFdmVudExpc3RlbmVyIiwiZSIsIl9yZXNwb25zZVBhcmFtcyIsInN0YXR1cyIsInJlc3BvbnNlIiwic2V0RGF0YSIsImV2dCIsImhvc3RuYW1lIiwicmVzcG9uc2VUZXh0IiwiX2RhdGFSZWR1Y2UiLCJvdXRwdXQiLCJrZXkiLCJyZXBsYWNlIiwiQnVzIiwiQWxhcm1zIiwiX2FsYXJtcyIsImVtaXQiLCJBcnJheSIsImlzQXJyYXkiLCJzeW1ib2wiLCJmaWx0ZXIiLCJhIiwiYWN0aXZlIiwibGVuZ3RoIiwicGFpckRhdGEiLCJwcmljZSIsImNsb3NlIiwidG9rZW4iLCJhc3NldCIsInBhaXIiLCJpbWFnZSIsInBhcnNlRmxvYXQiLCJmaW5kIiwiaWQiLCJyYW5kU3RyaW5nIiwidGltZSIsIkRhdGUiLCJub3ciLCJhcnJvdyIsInNpZ24iLCJjaGVjayIsImFsYXJtIiwic2F2ZURhdGEiLCJjYWxsYmFjayIsImNvdW50IiwiaSIsIk51bWJlciIsImRpZmYiLCJjbG9zZUZpeGVkIiwidG9GaXhlZCIsInByaWNlRml4ZWQiLCJ0aXRsZSIsImluZm8iLCJTeW1ib2wiLCJCaW5hbmNlIiwiX2FqYXgiLCJfYXBpdXJsIiwiX3dzc3VybCIsIl9hcGlrZXkiLCJfYXBpc2VjcmV0IiwiX2xpc3RlbmtleSIsIl93YWl0IiwiX2NvaW5kYXRhIiwiX3N5bWJvbHMiLCJfbWFya2V0cyIsIl9yZWNvbm5lY3QiLCJfdGltZXJzIiwiX3NvY2tzIiwiYWpheCIsInNlY3JldCIsInRvZ2dsZSIsInNldFRpbWVvdXQiLCJlbmRwb2ludCIsInBhcmFtcyIsInFzdHIiLCJjcnlwdG8iLCJ3aW5kb3ciLCJDcnlwdG9KUyIsInJlY3ZXaW5kb3ciLCJ0aW1lc3RhbXAiLCJzaWduYXR1cmUiLCJIbWFjU0hBMjU2IiwidG9TdHJpbmciLCJlbmMiLCJIZXgiLCJyZW1vdGUiLCJsb2NhbCIsImhhbmRsZVJlc3BvbnNlIiwicmVzIiwic3ltYm9scyIsInN5bWIiLCJxdW90ZUFzc2V0IiwicyIsImJhc2VBc3NldCIsImdldCIsImNiIiwiY29uc29sZSIsIndhcm4iLCJiYWxhbmNlcyIsIkIiLCJtYXAiLCJ0Iiwicm91dGUiLCJfbmFtZXMiLCJmcmVlIiwiZiIsImxvY2tlZCIsImwiLCJUIiwidHJhbnNhY3RUaW1lIiwib3JkZXJJZCIsInNpZGUiLCJTIiwibyIsIlgiLCJwIiwicXVhbnRpdHkiLCJvcmlnUXR5IiwiZmlsbGVkIiwieiIsImV4ZWN1dGVkUXR5IiwiWiIsImN1bW11bGF0aXZlUXVvdGVRdHkiLCJmZWVBc3NldCIsIk4iLCJmZWVBbW91bnQiLCJuIiwicGVyY2VudCIsInNtYiIsImFtb3VudCIsIk1hdGgiLCJmbG9vciIsInByaWNlU3RyIiwicXVhbnRpdHlTdHIiLCJ0b3RhbFN0ciIsInBhcnNlT3JkZXJEYXRhIiwic2VjcyIsInJhbmRvbSIsIm9yZGVyT3BlbiIsImZha2VPcmRlckRhdGEiLCJvcmRlckZpbGxlZCIsIm9yZGVyQ2FuY2VsZWQiLCJvcmRlclJlc3VsdCIsImluZm9yY2UiLCJ0aW1lSW5Gb3JjZSIsIm5ld09yZGVyUmVzcFR5cGUiLCJwb3N0IiwiZ2V0U2lnbmVkVXJsIiwicGFyc2VVc2VyQmFsYW5jZXMiLCJzdG9wVXNlclN0cmVhbSIsInJlY29ubmVjdCIsImdldFB1YmxpY1VybCIsImZ1bmMiLCJleHRlbmRTdHJlYW1LZXkiLCJiaW5kIiwibGlzdGVuS2V5Iiwic3RhcnRVc2VyU3RyZWFtIiwic3RhcnRUaW1lciIsInB1dCIsInNldFJlY29ubmVjdCIsIndzIiwic29ja0Nvbm5lY3QiLCJmZXRjaFVzZXJBY2NvdW50IiwiZmV0Y2hPcGVuT3JkZXJzIiwic3RvcFRpbWVyIiwiY2hlY2tSZWNvbm5lY3QiLCJKU09OIiwicGFyc2UiLCJzb2NrQ2xvc2UiLCJzdGFydFRpY2tlclRpbWVyIiwic3RhcnRUaWNrZXJTdHJlYW0iLCJsaXN0IiwibWFya2V0cyIsInRpY2tlciIsInNwbGl0U3ltYm9sIiwic2V0Q29pbkRhdGEiLCJzZXRUaWNrZXJEYXRhIiwicmVzb2x2ZUltYWdlIiwiaW5pdCIsInNldEludGVydmFsIiwiaGFzT3duUHJvcGVydHkiLCJjbGVhckludGVydmFsIiwiV2ViU29ja2V0IiwibWVzc2FnZSIsIl9ldmVudHMiLCJhcmdzIiwiZnJvbSIsImFyZ3VtZW50cyIsInNoaWZ0IiwiYXBwbHkiLCJ1bmRlZmluZWQiLCJDb2luYmFzZXBybyIsIkNvaW5jYXAiLCJfY29pbnMiLCJiZWZvcmVTZW5kIiwiYyIsIkhpc3RvcnkiLCJfc3RvIiwiZXhwaXJlIiwiX2F1dG9DbGVhbiIsImNsZWFyVGltZW91dCIsImljb24iLCJpc05ldyIsInVuc2hpZnQiLCJzbGljZSIsInciLCJnbG9iYWwiLCJERUJVRyIsInN0cmluZ2lmeSIsImxvZyIsInJlcGVhdCIsIk1lc3NlbmdlciIsIl9xdWV1ZSIsInNlY29uZHMiLCJzdG9wIiwiX2NoZWNrUXVldWUiLCJfbWFpbGd1blNlbmQiLCJfdGVsZWdyYW1TZW5kIiwiY29udGVudCIsImh0bWwiLCJmZGF0YSIsIkZvcm1EYXRhIiwiYXBwZW5kIiwib2siLCJUd2l0dGVyIiwiTmV3cyIsIl9hY2NvdW50c0tleSIsIl90d2VldHNLZXkiLCJfaGFuZGxlcnMiLCJfdHdlZXRzIiwiX2JsYWNrbGlzdCIsIl9jb3VudGVyIiwiX2ludGVydmFsIiwidHdlZXRzSGFuZGxlciIsInNldHVwVGltZXIiLCJ1cGRhdGVIYW5kbGVycyIsImZpbHRlclR3ZWV0cyIsImFjY291bnRzIiwiaW1wb3J0QWNjb3VudHMiLCJ0dyIsImhhbmRsZSIsInJlc2V0Iiwic2F2ZSIsInRyYWNrQWNjb3VudCIsInNhdmVBY2NvdW50cyIsImZldGNoIiwidHJhY2tpbmciLCJmZXRjaFR3ZWV0cyIsInNhdmVUd2VldHMiLCJmZXRjaERlbGF5IiwibGltaXRDb3VudCIsInJlc2V0VHdlZXRzIiwidGlkIiwidHdlZXQiLCJ0d2VldEV4aXN0cyIsInR3ZWV0QmxvY2tlZCIsInR3ZWV0RXhwaXJlZCIsImFnZSIsImNlaWwiLCJhZGRlZCIsImFkZFR3ZWV0IiwiYiIsImxhc3QiLCJmZXRjaE5leHRIYW5kbGVyIiwiTm90aWZ5IiwiX25vdGljZXMiLCJzb3VuZCIsIl93YXRjaFF1ZXVlIiwiYm9keSIsImxpbmsiLCJoYXNTdXBwb3J0IiwiTm90aWZpY2F0aW9uIiwicGVybWlzc2lvbiIsInJlcXVlc3RQZXJtaXNzaW9uIiwidGhlbiIsInBsYXlBdWRpbyIsIl9jbGVhbnVwTm90aWZpY2F0aW9ucyIsImNhbk5vdGlmeSIsInRhZyIsInR0bCIsInRhcmdldCIsInBsYXlTb3VuZCIsInByZXZlbnREZWZhdWx0IiwiT3B0aW9ucyIsIl9rZXkiLCJkZWVwTWVyZ2UiLCJkZWYiLCJSb3V0ZXIiLCJfcm91dGVzIiwiX2luaXQiLCJfcGF0aCIsImxvY2F0aW9uIiwiaGFzaCIsInBhdGgiLCJyZWciLCJSZWdFeHAiLCJtYXRjaGVzIiwiZXhlYyIsIl93IiwidHJpZ2dlciIsIlNjcm9sbGVyIiwiX3RkZWYiLCJkb2N1bWVudCIsInNjcm9sbGluZ0VsZW1lbnQiLCJkb2N1bWVudEVsZW1lbnQiLCJfdGFyZ2V0IiwiRWxlbWVudCIsIl9zY3JvbGxpbmciLCJfcG9zIiwiX3RvIiwiX21pbiIsIl9tYXgiLCJfZWFzZSIsIl90cmlnZ2VycyIsIl9vblNjcm9sbCIsImFkZFRyaWdnZXIiLCJwb3MiLCJ0b0xvd2VyQ2FzZSIsInBvc2l0aW9uIiwiY2FsbGVkIiwib24iLCJ0YXJnZXRzIiwiZWxtcyIsIl9nZXRFbG1MaXN0IiwiZW1hcCIsImZpbGwiLCJkZXN0Iiwic2Nyb2xsSGVpZ2h0IiwiY2xpZW50SGVpZ2h0Iiwic2Nyb2xsVG9wIiwiZ2V0Qm91bmRpbmdDbGllbnRSZWN0IiwidG9wIiwidGVzdCIsIm5vZGUiLCJxdWVyeVNlbGVjdG9yIiwibWluIiwiX2p1bXBMb29wIiwiYWJzIiwiX29uU2Nyb2xsVGljayIsInJlcXVlc3RBbmltYXRpb25GcmFtZSIsInNwIiwidiIsIl9jaGVja1Zpc2libGUiLCJlbG0iLCJoZWlnaHQiLCJib3giLCJ5UG9zIiwicXVlcnlTZWxlY3RvckFsbCIsIk5vZGVMaXN0IiwiX2FmaW5uIiwiX25lZ2F0b3JzIiwibWVyZ2UiLCJhbmFseXplIiwidGV4dCIsInNjb3JlIiwibmVnYXRpdmUiLCJwb3NpdGl2ZSIsImNvbXBhcmF0aXZlIiwiX3NwbGl0V29yZHMiLCJpbmRleE9mIiwid29yZCIsInN0eWxlcyIsInNlbnRpbWVudCIsImlucHV0IiwiZGl2IiwiY3JlYXRlRWxlbWVudCIsImlubmVySFRNTCIsInRleHRDb250ZW50IiwiaW5uZXJUZXh0Iiwic3BsaXQiLCJTb3J0ZXIiLCJfbGlzdHMiLCJjb2x1bW4iLCJkIiwiX2FwaSIsIl9wcmVmaXgiLCJfdHRsIiwiX3NhdmUiLCJfY2xlYW4iLCJfZmV0Y2giLCJkZWxldGVEYXRhIiwiX2RlbGV0ZSIsIl9lcnJvciIsIl9jb2RlIiwiY29kZSIsIl9uYW1lIiwiX2luZm8iLCJfc3RvcmUiLCJfdGltZSIsIl9zdHJpbmciLCJzZXRJdGVtIiwiX3BhcnNlZCIsImdldEl0ZW0iLCJyZW1vdmVJdGVtIiwiX2RhdGEiLCJfc2VjcyIsImltYWdlTG9hZGVkIiwiaGlnaCIsImxvdyIsImNoYW5nZSIsInRyYWRlcyIsInRva2VuVm9sdW1lIiwibWFya2V0Vm9sdW1lIiwidm9sYXRpbGl0eSIsImRhbmdlciIsInJhbmsiLCJzdXBwbHkiLCJjYXB1c2QiLCJoaXN0b3J5IiwiY2FuZGxlcyIsInN0eWxlIiwicXVvdGVzIiwicmVnZXhwIiwibWFya2V0Q2FwVXNkIiwib3BlblByaWNlIiwiaCIsImhpZ2hQcmljZSIsImxvd1ByaWNlIiwibGFzdFByaWNlIiwicHJpY2VDaGFuZ2UiLCJQIiwicHJpY2VDaGFuZ2VQZXJjZW50IiwicXVvdGVWb2x1bWUiLCJjYWxjVm9sYXRpbGl0eSIsImNhbGNEYW5nZXIiLCJjYWxjSGlzdG9yeSIsImNhbGNTdHlsZSIsIndhaXQiLCJocnMiLCJzcGxpY2UiLCJpZHgiLCJmYWtlSGlzdG9yeSIsIm51bSIsInJhbmQiLCJWaWV3cG9ydCIsIlRvb2x0aXAiLCJ0aXBDbGFzcyIsImxlZnRDbGFzcyIsInJpZ2h0Q2xhc3MiLCJ0b3BDbGFzcyIsImJvdHRvbUNsYXNzIiwic2hvd0RlbGF5IiwiaGlkZURlbGF5IiwiX3Rvb2x0aXAiLCJfaG92SXRlbSIsIl90aW1lb3V0IiwiX2F1dG9oaWRlIiwiX3Zpc2libGUiLCJfZWxlbWVudHMiLCJzZWxlY3RvciIsIl9zZXR1cEl0ZW0iLCJfaGlkZVRvb2x0aXAiLCJlbGVtZW50IiwiX3Jlc2V0SXRlbSIsImNvbnRhaW5zIiwicmVtb3ZlQ2hpbGQiLCJyZW1vdmVFdmVudExpc3RlbmVyIiwiY2xhc3NOYW1lIiwiYXBwZW5kQ2hpbGQiLCJpdGVtIiwiaGFzQXR0cmlidXRlIiwiX3Bhc3NpdmUiLCJwYXNzaXZlIiwic2V0QXR0cmlidXRlIiwiZ2V0QXR0cmlidXRlIiwicmVtb3ZlQXR0cmlidXRlIiwiX29uRW50ZXIiLCJfb25MZWF2ZSIsImNlbnRlclgiLCJsZWZ0Iiwib2Zmc2V0V2lkdGgiLCJjZW50ZXJZIiwib2Zmc2V0SGVpZ2h0IiwibGVmdFBvcyIsInJpZ2h0UG9zIiwidG9wUG9zIiwiYm90dG9tUG9zIiwidGlwSGFsZiIsImJveENlbnRlciIsImhhbGZTY3JlZW4iLCJpbm5lckhlaWdodCIsImlzTmVhckxlZnQiLCJpc05lYXJSaWdodCIsImNsaWVudFdpZHRoIiwiY2xzcyIsInNjcm9sbExlZnQiLCJfc2hvd1Rvb2x0aXAiLCJ1aWQiLCJhdmF0YXIiLCJ1cmwiLCJmZXRjaGluZyIsInNraXBQaW5uZWQiLCJza2lwUmV0d2VldCIsImNsZWFuVHdlZXRzIiwiX2NhbkZldGNoIiwicGFyc2VyIiwiRE9NUGFyc2VyIiwiX2NsZWFuSHRtbCIsImRvYyIsInBhcnNlRnJvbVN0cmluZyIsIkhUTUxEb2N1bWVudCIsInBhcnNlVHdlZXRzIiwic3JjIiwiaXRlbXMiLCJwb3N0ZWQiLCJfY2xlYW5Ud2VldCIsImNsYXNzTGlzdCIsImRhdGUiLCJ0b0RhdGVTdHJpbmciLCJlbGFwc2VkIiwibW9kdWxlIiwiZXhwb3J0cyIsInBhcnNlVXJsIiwicHJvcCIsImhyZWYiLCJsaW5rVXJsIiwic3RyaXBIdG1sIiwicmVtb3ZlVXJscyIsInJlbHBhdGgiLCJsb2MiLCJwYXRobmFtZSIsInJlbCIsInByb3RvY29sIiwiaG9zdCIsInZvbCIsIkF1ZGlvIiwiY3Jvc3NPcmlnaW4iLCJwbGF5IiwibG9hZCIsImNvcHlUZXh0IiwidmFsdWUiLCJzZWxlY3QiLCJyZW1vdmUiLCJleGVjQ29tbWFuZCIsImNsYW1wIiwic3RyIiwic3Vic3RyaW5nIiwiY2hhciIsIm5vdW4iLCJzaW5ndWxhciIsInBsdXRhbCIsIm1vbmV5IiwiZml4ZWQiLCJtaW5pbXVtRnJhY3Rpb25EaWdpdHMiLCJtYXhpbXVtRnJhY3Rpb25EaWdpdHMiLCJJbnRsIiwiTnVtYmVyRm9ybWF0IiwiZm9ybWF0IiwiZGVjaW1hbHMiLCJzdWZmaXgiLCJzaG9ydCIsImRhdGVEYXRhIiwidG9Mb2NhbGVTdHJpbmciLCJfcCIsIm1vbnRoIiwiZ2V0TW9udGgiLCJ5ZWFyIiwiZ2V0RnVsbFllYXIiLCJkYXkiLCJnZXREYXRlIiwibWludXRlIiwiZ2V0TWludXRlcyIsInNlY29uZCIsImdldFNlY29uZHMiLCJmdWxsaCIsImdldEhvdXJzIiwiYW1wbSIsImhvdXIiLCJmdWxsIiwib3V0IiwiY3VycmVudCIsInRvTnVtIiwiaXNudW0iLCJCb29sZWFuIiwiaXN1cCIsImNvbG9yIiwicG9pbnRzIiwid2lkdGgiLCJ2YWx1ZXMiLCJyZWR1Y2UiLCJ2YWwiLCJsZW4iLCJoYWxmIiwicmFuZ2UiLCJnYXAiLCJ4IiwieSIsImJveFBvc2l0aW9uIiwidHJpZ2dlckVsbSIsInJpZ2h0IiwiYm90dG9tIiwiSFRNTEVsZW1lbnQiLCJwb3N4IiwicG9zeSIsImNlbnRlcngiLCJpbm5lcldpZHRoIiwiY2VudGVyeSIsImtleWJvYXJkIiwia2V5Q29kZSIsInVwIiwiZG93biIsImJhY2siLCJlc2NhcGUiLCJzcGFjZSIsImVudGVyIiwic2h1ZmZsZSIsImoiLCJyZWdleCIsImlnbm9yZSIsIl9hIiwiX2IiLCJ0cmltTGVmdCIsInRyaW1SaWdodCIsImNoYXJDb2RlQXQiLCJjaGFycyIsImNoYXJBdCIsImlkU3RyaW5nIiwic3Vic3RyIiwiX3MiLCJzY3JlZW4iLCJfZCIsInNjcmVlbldpZHRoIiwiYXZhaWxXaWR0aCIsInNjcmVlbkhlaWdodCIsImF2YWlsSGVpZ2h0IiwicGFnZVdpZHRoIiwic2Nyb2xsV2lkdGgiLCJwYWdlSGVpZ2h0IiwicGFnZUxlZnQiLCJjbGllbnRMZWZ0IiwicGFnZVRvcCIsImNsaWVudFRvcCIsInBhZ2VYT2Zmc2V0IiwicGFnZVlPZmZzZXQiLCJzY3JvbGxSaWdodCIsInNjcm9sbEJvdHRvbSIsIm1vdXNlTGVmdCIsImNoYW5nZWRUb3VjaGVzIiwicGFnZVgiLCJjbGllbnRYIiwibW91c2VUb3AiLCJwYWdlWSIsImNsaWVudFkiLCJlbGVtZW50V2lkdGgiLCJlbGVtZW50SGVpZ2h0IiwiZWxlbWVudExlZnQiLCJlbGVtZW50VG9wIiwiY2xhbXBWYWx1ZSIsImRlZk9wdHMiLCJBcHAiLCJWdWUiLCJfYmluYW5jZSIsIl9jb2luYmFzZXBybyIsIl9jb2luY2FwIiwiX2hpc3RvcnkiLCJfbm90aWZ5IiwiX25ld3MiLCJfbWVzc2VuZ2VyIiwiX3JvdXRlciIsIl9idXMiLCJfc29ydGVyIiwiX3Njcm9sbGVyIiwiZGVmaW5lUHJvcGVydGllcyIsInByb3RvdHlwZSIsIiRvcHRzIiwiJGFqYXgiLCIkYmluYW5jZSIsIiRjb2luYmFzZXBybyIsIiRjb2luY2FwIiwiJGFsYXJtcyIsIiRoaXN0b3J5IiwiJG5vdGlmeSIsIiRuZXdzIiwiJG1lc3NlbmdlciIsIiRyb3V0ZXIiLCIkc2Nyb2xsZXIiLCIkYnVzIiwiJHNvcnRlciIsIiRzdG9yZSIsIiRzZW50aW1lbnQiLCIkdXRpbHMiLCJkaXJlY3RpdmUiLCJlbCIsInVuYmluZCIsInVuc2VsZWN0IiwicmVuZGVyIl0sInNvdXJjZVJvb3QiOiIifQ==